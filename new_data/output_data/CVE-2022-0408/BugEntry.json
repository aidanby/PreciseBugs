{"buggy_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * spellsuggest.c: functions for spelling suggestions\n */\n\n#include \"vim.h\"\n\n#if defined(FEAT_SPELL) || defined(PROTO)\n\n/*\n * Use this to adjust the score after finding suggestions, based on the\n * suggested word sounding like the bad word.  This is much faster than doing\n * it for every possible suggestion.\n * Disadvantage: When \"the\" is typed as \"hte\" it sounds quite different (\"@\"\n * vs \"ht\") and goes down in the list.\n * Used when 'spellsuggest' is set to \"best\".\n */\n#define RESCORE(word_score, sound_score) ((3 * word_score + sound_score) / 4)\n\n/*\n * Do the opposite: based on a maximum end score and a known sound score,\n * compute the maximum word score that can be used.\n */\n#define MAXSCORE(word_score, sound_score) ((4 * word_score - sound_score) / 3)\n\n// only used for su_badflags\n#define WF_MIXCAP   0x20\t// mix of upper and lower case: macaRONI\n\n/*\n * Information used when looking for suggestions.\n */\ntypedef struct suginfo_S\n{\n    garray_T\tsu_ga;\t\t    // suggestions, contains \"suggest_T\"\n    int\t\tsu_maxcount;\t    // max. number of suggestions displayed\n    int\t\tsu_maxscore;\t    // maximum score for adding to su_ga\n    int\t\tsu_sfmaxscore;\t    // idem, for when doing soundfold words\n    garray_T\tsu_sga;\t\t    // like su_ga, sound-folded scoring\n    char_u\t*su_badptr;\t    // start of bad word in line\n    int\t\tsu_badlen;\t    // length of detected bad word in line\n    int\t\tsu_badflags;\t    // caps flags for bad word\n    char_u\tsu_badword[MAXWLEN]; // bad word truncated at su_badlen\n    char_u\tsu_fbadword[MAXWLEN]; // su_badword case-folded\n    char_u\tsu_sal_badword[MAXWLEN]; // su_badword soundfolded\n    hashtab_T\tsu_banned;\t    // table with banned words\n    slang_T\t*su_sallang;\t    // default language for sound folding\n} suginfo_T;\n\n// One word suggestion.  Used in \"si_ga\".\ntypedef struct suggest_S\n{\n    char_u\t*st_word;\t// suggested word, allocated string\n    int\t\tst_wordlen;\t// STRLEN(st_word)\n    int\t\tst_orglen;\t// length of replaced text\n    int\t\tst_score;\t// lower is better\n    int\t\tst_altscore;\t// used when st_score compares equal\n    int\t\tst_salscore;\t// st_score is for soundalike\n    int\t\tst_had_bonus;\t// bonus already included in score\n    slang_T\t*st_slang;\t// language used for sound folding\n} suggest_T;\n\n#define SUG(ga, i) (((suggest_T *)(ga).ga_data)[i])\n\n// TRUE if a word appears in the list of banned words.\n#define WAS_BANNED(su, word) (!HASHITEM_EMPTY(hash_find(&su->su_banned, word)))\n\n// Number of suggestions kept when cleaning up.  We need to keep more than\n// what is displayed, because when rescore_suggestions() is called the score\n// may change and wrong suggestions may be removed later.\n#define SUG_CLEAN_COUNT(su)    ((su)->su_maxcount < 130 ? 150 : (su)->su_maxcount + 20)\n\n// Threshold for sorting and cleaning up suggestions.  Don't want to keep lots\n// of suggestions that are not going to be displayed.\n#define SUG_MAX_COUNT(su)\t(SUG_CLEAN_COUNT(su) + 50)\n\n// score for various changes\n#define SCORE_SPLIT\t149\t// split bad word\n#define SCORE_SPLIT_NO\t249\t// split bad word with NOSPLITSUGS\n#define SCORE_ICASE\t52\t// slightly different case\n#define SCORE_REGION\t200\t// word is for different region\n#define SCORE_RARE\t180\t// rare word\n#define SCORE_SWAP\t75\t// swap two characters\n#define SCORE_SWAP3\t110\t// swap two characters in three\n#define SCORE_REP\t65\t// REP replacement\n#define SCORE_SUBST\t93\t// substitute a character\n#define SCORE_SIMILAR\t33\t// substitute a similar character\n#define SCORE_SUBCOMP\t33\t// substitute a composing character\n#define SCORE_DEL\t94\t// delete a character\n#define SCORE_DELDUP\t66\t// delete a duplicated character\n#define SCORE_DELCOMP\t28\t// delete a composing character\n#define SCORE_INS\t96\t// insert a character\n#define SCORE_INSDUP\t67\t// insert a duplicate character\n#define SCORE_INSCOMP\t30\t// insert a composing character\n#define SCORE_NONWORD\t103\t// change non-word to word char\n\n#define SCORE_FILE\t30\t// suggestion from a file\n#define SCORE_MAXINIT\t350\t// Initial maximum score: higher == slower.\n\t\t\t\t// 350 allows for about three changes.\n\n#define SCORE_COMMON1\t30\t// subtracted for words seen before\n#define SCORE_COMMON2\t40\t// subtracted for words often seen\n#define SCORE_COMMON3\t50\t// subtracted for words very often seen\n#define SCORE_THRES2\t10\t// word count threshold for COMMON2\n#define SCORE_THRES3\t100\t// word count threshold for COMMON3\n\n// When trying changed soundfold words it becomes slow when trying more than\n// two changes.  With less than two changes it's slightly faster but we miss a\n// few good suggestions.  In rare cases we need to try three of four changes.\n#define SCORE_SFMAX1\t200\t// maximum score for first try\n#define SCORE_SFMAX2\t300\t// maximum score for second try\n#define SCORE_SFMAX3\t400\t// maximum score for third try\n\n#define SCORE_BIG\tSCORE_INS * 3\t// big difference\n#define SCORE_MAXMAX\t999999\t\t// accept any score\n#define SCORE_LIMITMAX\t350\t\t// for spell_edit_score_limit()\n\n// for spell_edit_score_limit() we need to know the minimum value of\n// SCORE_ICASE, SCORE_SWAP, SCORE_DEL, SCORE_SIMILAR and SCORE_INS\n#define SCORE_EDIT_MIN\tSCORE_SIMILAR\n\n/*\n * For finding suggestions: At each node in the tree these states are tried:\n */\ntypedef enum\n{\n    STATE_START = 0,\t// At start of node check for NUL bytes (goodword\n\t\t\t// ends); if badword ends there is a match, otherwise\n\t\t\t// try splitting word.\n    STATE_NOPREFIX,\t// try without prefix\n    STATE_SPLITUNDO,\t// Undo splitting.\n    STATE_ENDNUL,\t// Past NUL bytes at start of the node.\n    STATE_PLAIN,\t// Use each byte of the node.\n    STATE_DEL,\t\t// Delete a byte from the bad word.\n    STATE_INS_PREP,\t// Prepare for inserting bytes.\n    STATE_INS,\t\t// Insert a byte in the bad word.\n    STATE_SWAP,\t\t// Swap two bytes.\n    STATE_UNSWAP,\t// Undo swap two characters.\n    STATE_SWAP3,\t// Swap two characters over three.\n    STATE_UNSWAP3,\t// Undo Swap two characters over three.\n    STATE_UNROT3L,\t// Undo rotate three characters left\n    STATE_UNROT3R,\t// Undo rotate three characters right\n    STATE_REP_INI,\t// Prepare for using REP items.\n    STATE_REP,\t\t// Use matching REP items from the .aff file.\n    STATE_REP_UNDO,\t// Undo a REP item replacement.\n    STATE_FINAL\t\t// End of this node.\n} state_T;\n\n/*\n * Struct to keep the state at each level in suggest_try_change().\n */\ntypedef struct trystate_S\n{\n    state_T\tts_state;\t// state at this level, STATE_\n    int\t\tts_score;\t// score\n    idx_T\tts_arridx;\t// index in tree array, start of node\n    short\tts_curi;\t// index in list of child nodes\n    char_u\tts_fidx;\t// index in fword[], case-folded bad word\n    char_u\tts_fidxtry;\t// ts_fidx at which bytes may be changed\n    char_u\tts_twordlen;\t// valid length of tword[]\n    char_u\tts_prefixdepth;\t// stack depth for end of prefix or\n\t\t\t\t// PFD_PREFIXTREE or PFD_NOPREFIX\n    char_u\tts_flags;\t// TSF_ flags\n    char_u\tts_tcharlen;\t// number of bytes in tword character\n    char_u\tts_tcharidx;\t// current byte index in tword character\n    char_u\tts_isdiff;\t// DIFF_ values\n    char_u\tts_fcharstart;\t// index in fword where badword char started\n    char_u\tts_prewordlen;\t// length of word in \"preword[]\"\n    char_u\tts_splitoff;\t// index in \"tword\" after last split\n    char_u\tts_splitfidx;\t// \"ts_fidx\" at word split\n    char_u\tts_complen;\t// nr of compound words used\n    char_u\tts_compsplit;\t// index for \"compflags\" where word was spit\n    char_u\tts_save_badflags;   // su_badflags saved here\n    char_u\tts_delidx;\t// index in fword for char that was deleted,\n\t\t\t\t// valid when \"ts_flags\" has TSF_DIDDEL\n} trystate_T;\n\n// values for ts_isdiff\n#define DIFF_NONE\t0\t// no different byte (yet)\n#define DIFF_YES\t1\t// different byte found\n#define DIFF_INSERT\t2\t// inserting character\n\n// values for ts_flags\n#define TSF_PREFIXOK\t1\t// already checked that prefix is OK\n#define TSF_DIDSPLIT\t2\t// tried split at this point\n#define TSF_DIDDEL\t4\t// did a delete, \"ts_delidx\" has index\n\n// special values ts_prefixdepth\n#define PFD_NOPREFIX\t0xff\t// not using prefixes\n#define PFD_PREFIXTREE\t0xfe\t// walking through the prefix tree\n#define PFD_NOTSPECIAL\t0xfd\t// highest value that's not special\n\nstatic void spell_find_suggest(char_u *badptr, int badlen, suginfo_T *su, int maxcount, int banbadword, int need_cap, int interactive);\n#ifdef FEAT_EVAL\nstatic void spell_suggest_expr(suginfo_T *su, char_u *expr);\n#endif\nstatic void spell_suggest_file(suginfo_T *su, char_u *fname);\nstatic void spell_suggest_intern(suginfo_T *su, int interactive);\nstatic void spell_find_cleanup(suginfo_T *su);\nstatic void suggest_try_special(suginfo_T *su);\nstatic void suggest_try_change(suginfo_T *su);\nstatic void suggest_trie_walk(suginfo_T *su, langp_T *lp, char_u *fword, int soundfold);\nstatic void go_deeper(trystate_T *stack, int depth, int score_add);\nstatic void find_keepcap_word(slang_T *slang, char_u *fword, char_u *kword);\nstatic void score_comp_sal(suginfo_T *su);\nstatic void score_combine(suginfo_T *su);\nstatic int stp_sal_score(suggest_T *stp, suginfo_T *su, slang_T *slang, char_u *badsound);\nstatic void suggest_try_soundalike_prep(void);\nstatic void suggest_try_soundalike(suginfo_T *su);\nstatic void suggest_try_soundalike_finish(void);\nstatic void add_sound_suggest(suginfo_T *su, char_u *goodword, int score, langp_T *lp);\nstatic int soundfold_find(slang_T *slang, char_u *word);\nstatic int similar_chars(slang_T *slang, int c1, int c2);\nstatic void add_suggestion(suginfo_T *su, garray_T *gap, char_u *goodword, int badlen, int score, int altscore, int had_bonus, slang_T *slang, int maxsf);\nstatic void check_suggestions(suginfo_T *su, garray_T *gap);\nstatic void add_banned(suginfo_T *su, char_u *word);\nstatic void rescore_suggestions(suginfo_T *su);\nstatic void rescore_one(suginfo_T *su, suggest_T *stp);\nstatic int cleanup_suggestions(garray_T *gap, int maxscore, int keep);\nstatic int soundalike_score(char_u *goodsound, char_u *badsound);\nstatic int spell_edit_score(slang_T *slang, char_u *badword, char_u *goodword);\nstatic int spell_edit_score_limit(slang_T *slang, char_u *badword, char_u *goodword, int limit);\nstatic int spell_edit_score_limit_w(slang_T *slang, char_u *badword, char_u *goodword, int limit);\n\n/*\n * Return TRUE when the sequence of flags in \"compflags\" plus \"flag\" can\n * possibly form a valid compounded word.  This also checks the COMPOUNDRULE\n * lines if they don't contain wildcards.\n */\n    static int\ncan_be_compound(\n    trystate_T\t*sp,\n    slang_T\t*slang,\n    char_u\t*compflags,\n    int\t\tflag)\n{\n    // If the flag doesn't appear in sl_compstartflags or sl_compallflags\n    // then it can't possibly compound.\n    if (!byte_in_str(sp->ts_complen == sp->ts_compsplit\n\t\t? slang->sl_compstartflags : slang->sl_compallflags, flag))\n\treturn FALSE;\n\n    // If there are no wildcards, we can check if the flags collected so far\n    // possibly can form a match with COMPOUNDRULE patterns.  This only\n    // makes sense when we have two or more words.\n    if (slang->sl_comprules != NULL && sp->ts_complen > sp->ts_compsplit)\n    {\n\tint v;\n\n\tcompflags[sp->ts_complen] = flag;\n\tcompflags[sp->ts_complen + 1] = NUL;\n\tv = match_compoundrule(slang, compflags + sp->ts_compsplit);\n\tcompflags[sp->ts_complen] = NUL;\n\treturn v;\n    }\n\n    return TRUE;\n}\n\n/*\n * Adjust the score of common words.\n */\n    static int\nscore_wordcount_adj(\n    slang_T\t*slang,\n    int\t\tscore,\n    char_u\t*word,\n    int\t\tsplit)\t    // word was split, less bonus\n{\n    hashitem_T\t*hi;\n    wordcount_T\t*wc;\n    int\t\tbonus;\n    int\t\tnewscore;\n\n    hi = hash_find(&slang->sl_wordcount, word);\n    if (!HASHITEM_EMPTY(hi))\n    {\n\twc = HI2WC(hi);\n\tif (wc->wc_count < SCORE_THRES2)\n\t    bonus = SCORE_COMMON1;\n\telse if (wc->wc_count < SCORE_THRES3)\n\t    bonus = SCORE_COMMON2;\n\telse\n\t    bonus = SCORE_COMMON3;\n\tif (split)\n\t    newscore = score - bonus / 2;\n\telse\n\t    newscore = score - bonus;\n\tif (newscore < 0)\n\t    return 0;\n\treturn newscore;\n    }\n    return score;\n}\n\n/*\n * Like captype() but for a KEEPCAP word add ONECAP if the word starts with a\n * capital.  So that make_case_word() can turn WOrd into Word.\n * Add ALLCAP for \"WOrD\".\n */\n    static int\nbadword_captype(char_u *word, char_u *end)\n{\n    int\t\tflags = captype(word, end);\n    int\t\tc;\n    int\t\tl, u;\n    int\t\tfirst;\n    char_u\t*p;\n\n    if (flags & WF_KEEPCAP)\n    {\n\t// Count the number of UPPER and lower case letters.\n\tl = u = 0;\n\tfirst = FALSE;\n\tfor (p = word; p < end; MB_PTR_ADV(p))\n\t{\n\t    c = PTR2CHAR(p);\n\t    if (SPELL_ISUPPER(c))\n\t    {\n\t\t++u;\n\t\tif (p == word)\n\t\t    first = TRUE;\n\t    }\n\t    else\n\t\t++l;\n\t}\n\n\t// If there are more UPPER than lower case letters suggest an\n\t// ALLCAP word.  Otherwise, if the first letter is UPPER then\n\t// suggest ONECAP.  Exception: \"ALl\" most likely should be \"All\",\n\t// require three upper case letters.\n\tif (u > l && u > 2)\n\t    flags |= WF_ALLCAP;\n\telse if (first)\n\t    flags |= WF_ONECAP;\n\n\tif (u >= 2 && l >= 2)\t// maCARONI maCAroni\n\t    flags |= WF_MIXCAP;\n    }\n    return flags;\n}\n\n/*\n * Opposite of offset2bytes().\n * \"pp\" points to the bytes and is advanced over it.\n * Returns the offset.\n */\n    static int\nbytes2offset(char_u **pp)\n{\n    char_u\t*p = *pp;\n    int\t\tnr;\n    int\t\tc;\n\n    c = *p++;\n    if ((c & 0x80) == 0x00)\t\t// 1 byte\n    {\n\tnr = c - 1;\n    }\n    else if ((c & 0xc0) == 0x80)\t// 2 bytes\n    {\n\tnr = (c & 0x3f) - 1;\n\tnr = nr * 255 + (*p++ - 1);\n    }\n    else if ((c & 0xe0) == 0xc0)\t// 3 bytes\n    {\n\tnr = (c & 0x1f) - 1;\n\tnr = nr * 255 + (*p++ - 1);\n\tnr = nr * 255 + (*p++ - 1);\n    }\n    else\t\t\t\t// 4 bytes\n    {\n\tnr = (c & 0x0f) - 1;\n\tnr = nr * 255 + (*p++ - 1);\n\tnr = nr * 255 + (*p++ - 1);\n\tnr = nr * 255 + (*p++ - 1);\n    }\n\n    *pp = p;\n    return nr;\n}\n\n// values for sps_flags\n#define SPS_BEST    1\n#define SPS_FAST    2\n#define SPS_DOUBLE  4\n\nstatic int sps_flags = SPS_BEST;\t// flags from 'spellsuggest'\nstatic int sps_limit = 9999;\t\t// max nr of suggestions given\n\n/*\n * Check the 'spellsuggest' option.  Return FAIL if it's wrong.\n * Sets \"sps_flags\" and \"sps_limit\".\n */\n    int\nspell_check_sps(void)\n{\n    char_u\t*p;\n    char_u\t*s;\n    char_u\tbuf[MAXPATHL];\n    int\t\tf;\n\n    sps_flags = 0;\n    sps_limit = 9999;\n\n    for (p = p_sps; *p != NUL; )\n    {\n\tcopy_option_part(&p, buf, MAXPATHL, \",\");\n\n\tf = 0;\n\tif (VIM_ISDIGIT(*buf))\n\t{\n\t    s = buf;\n\t    sps_limit = getdigits(&s);\n\t    if (*s != NUL && !VIM_ISDIGIT(*s))\n\t\tf = -1;\n\t}\n\telse if (STRCMP(buf, \"best\") == 0)\n\t    f = SPS_BEST;\n\telse if (STRCMP(buf, \"fast\") == 0)\n\t    f = SPS_FAST;\n\telse if (STRCMP(buf, \"double\") == 0)\n\t    f = SPS_DOUBLE;\n\telse if (STRNCMP(buf, \"expr:\", 5) != 0\n\t\t&& STRNCMP(buf, \"file:\", 5) != 0)\n\t    f = -1;\n\n\tif (f == -1 || (sps_flags != 0 && f != 0))\n\t{\n\t    sps_flags = SPS_BEST;\n\t    sps_limit = 9999;\n\t    return FAIL;\n\t}\n\tif (f != 0)\n\t    sps_flags = f;\n    }\n\n    if (sps_flags == 0)\n\tsps_flags = SPS_BEST;\n\n    return OK;\n}\n\n/*\n * \"z=\": Find badly spelled word under or after the cursor.\n * Give suggestions for the properly spelled word.\n * In Visual mode use the highlighted word as the bad word.\n * When \"count\" is non-zero use that suggestion.\n */\n    void\nspell_suggest(int count)\n{\n    char_u\t*line;\n    pos_T\tprev_cursor = curwin->w_cursor;\n    char_u\twcopy[MAXWLEN + 2];\n    char_u\t*p;\n    int\t\ti;\n    int\t\tc;\n    suginfo_T\tsug;\n    suggest_T\t*stp;\n    int\t\tmouse_used;\n    int\t\tneed_cap;\n    int\t\tlimit;\n    int\t\tselected = count;\n    int\t\tbadlen = 0;\n    int\t\tmsg_scroll_save = msg_scroll;\n    int\t\two_spell_save = curwin->w_p_spell;\n\n    if (!curwin->w_p_spell)\n    {\n\tdid_set_spelllang(curwin);\n\tcurwin->w_p_spell = TRUE;\n    }\n\n    if (*curwin->w_s->b_p_spl == NUL)\n    {\n\temsg(_(e_spell_checking_is_not_possible));\n\treturn;\n    }\n\n    if (VIsual_active)\n    {\n\t// Use the Visually selected text as the bad word.  But reject\n\t// a multi-line selection.\n\tif (curwin->w_cursor.lnum != VIsual.lnum)\n\t{\n\t    vim_beep(BO_SPELL);\n\t    return;\n\t}\n\tbadlen = (int)curwin->w_cursor.col - (int)VIsual.col;\n\tif (badlen < 0)\n\t    badlen = -badlen;\n\telse\n\t    curwin->w_cursor.col = VIsual.col;\n\t++badlen;\n\tend_visual_mode();\n    }\n    // Find the start of the badly spelled word.\n    else if (spell_move_to(curwin, FORWARD, TRUE, TRUE, NULL) == 0\n\t    || curwin->w_cursor.col > prev_cursor.col)\n    {\n\t// No bad word or it starts after the cursor: use the word under the\n\t// cursor.\n\tcurwin->w_cursor = prev_cursor;\n\tline = ml_get_curline();\n\tp = line + curwin->w_cursor.col;\n\t// Backup to before start of word.\n\twhile (p > line && spell_iswordp_nmw(p, curwin))\n\t    MB_PTR_BACK(line, p);\n\t// Forward to start of word.\n\twhile (*p != NUL && !spell_iswordp_nmw(p, curwin))\n\t    MB_PTR_ADV(p);\n\n\tif (!spell_iswordp_nmw(p, curwin))\t\t// No word found.\n\t{\n\t    beep_flush();\n\t    return;\n\t}\n\tcurwin->w_cursor.col = (colnr_T)(p - line);\n    }\n\n    // Get the word and its length.\n\n    // Figure out if the word should be capitalised.\n    need_cap = check_need_cap(curwin->w_cursor.lnum, curwin->w_cursor.col);\n\n    // Make a copy of current line since autocommands may free the line.\n    line = vim_strsave(ml_get_curline());\n    if (line == NULL)\n\tgoto skip;\n\n    // Get the list of suggestions.  Limit to 'lines' - 2 or the number in\n    // 'spellsuggest', whatever is smaller.\n    if (sps_limit > (int)Rows - 2)\n\tlimit = (int)Rows - 2;\n    else\n\tlimit = sps_limit;\n    spell_find_suggest(line + curwin->w_cursor.col, badlen, &sug, limit,\n\t\t\t\t\t\t\tTRUE, need_cap, TRUE);\n\n    if (sug.su_ga.ga_len == 0)\n\tmsg(_(\"Sorry, no suggestions\"));\n    else if (count > 0)\n    {\n\tif (count > sug.su_ga.ga_len)\n\t    smsg(_(\"Sorry, only %ld suggestions\"), (long)sug.su_ga.ga_len);\n    }\n    else\n    {\n#ifdef FEAT_RIGHTLEFT\n\t// When 'rightleft' is set the list is drawn right-left.\n\tcmdmsg_rl = curwin->w_p_rl;\n\tif (cmdmsg_rl)\n\t    msg_col = Columns - 1;\n#endif\n\n\t// List the suggestions.\n\tmsg_start();\n\tmsg_row = Rows - 1;\t// for when 'cmdheight' > 1\n\tlines_left = Rows;\t// avoid more prompt\n\tvim_snprintf((char *)IObuff, IOSIZE, _(\"Change \\\"%.*s\\\" to:\"),\n\t\t\t\t\t\tsug.su_badlen, sug.su_badptr);\n#ifdef FEAT_RIGHTLEFT\n\tif (cmdmsg_rl && STRNCMP(IObuff, \"Change\", 6) == 0)\n\t{\n\t    // And now the rabbit from the high hat: Avoid showing the\n\t    // untranslated message rightleft.\n\t    vim_snprintf((char *)IObuff, IOSIZE, \":ot \\\"%.*s\\\" egnahC\",\n\t\t\t\t\t\tsug.su_badlen, sug.su_badptr);\n\t}\n#endif\n\tmsg_puts((char *)IObuff);\n\tmsg_clr_eos();\n\tmsg_putchar('\\n');\n\n\tmsg_scroll = TRUE;\n\tfor (i = 0; i < sug.su_ga.ga_len; ++i)\n\t{\n\t    stp = &SUG(sug.su_ga, i);\n\n\t    // The suggested word may replace only part of the bad word, add\n\t    // the not replaced part.\n\t    vim_strncpy(wcopy, stp->st_word, MAXWLEN);\n\t    if (sug.su_badlen > stp->st_orglen)\n\t\tvim_strncpy(wcopy + stp->st_wordlen,\n\t\t\t\t\t       sug.su_badptr + stp->st_orglen,\n\t\t\t\t\t      sug.su_badlen - stp->st_orglen);\n\t    vim_snprintf((char *)IObuff, IOSIZE, \"%2d\", i + 1);\n#ifdef FEAT_RIGHTLEFT\n\t    if (cmdmsg_rl)\n\t\trl_mirror(IObuff);\n#endif\n\t    msg_puts((char *)IObuff);\n\n\t    vim_snprintf((char *)IObuff, IOSIZE, \" \\\"%s\\\"\", wcopy);\n\t    msg_puts((char *)IObuff);\n\n\t    // The word may replace more than \"su_badlen\".\n\t    if (sug.su_badlen < stp->st_orglen)\n\t    {\n\t\tvim_snprintf((char *)IObuff, IOSIZE, _(\" < \\\"%.*s\\\"\"),\n\t\t\t\t\t       stp->st_orglen, sug.su_badptr);\n\t\tmsg_puts((char *)IObuff);\n\t    }\n\n\t    if (p_verbose > 0)\n\t    {\n\t\t// Add the score.\n\t\tif (sps_flags & (SPS_DOUBLE | SPS_BEST))\n\t\t    vim_snprintf((char *)IObuff, IOSIZE, \" (%s%d - %d)\",\n\t\t\tstp->st_salscore ? \"s \" : \"\",\n\t\t\tstp->st_score, stp->st_altscore);\n\t\telse\n\t\t    vim_snprintf((char *)IObuff, IOSIZE, \" (%d)\",\n\t\t\t    stp->st_score);\n#ifdef FEAT_RIGHTLEFT\n\t\tif (cmdmsg_rl)\n\t\t    // Mirror the numbers, but keep the leading space.\n\t\t    rl_mirror(IObuff + 1);\n#endif\n\t\tmsg_advance(30);\n\t\tmsg_puts((char *)IObuff);\n\t    }\n\t    msg_putchar('\\n');\n\t}\n\n#ifdef FEAT_RIGHTLEFT\n\tcmdmsg_rl = FALSE;\n\tmsg_col = 0;\n#endif\n\t// Ask for choice.\n\tselected = prompt_for_number(&mouse_used);\n\tif (mouse_used)\n\t    selected -= lines_left;\n\tlines_left = Rows;\t\t// avoid more prompt\n\t// don't delay for 'smd' in normal_cmd()\n\tmsg_scroll = msg_scroll_save;\n    }\n\n    if (selected > 0 && selected <= sug.su_ga.ga_len && u_save_cursor() == OK)\n    {\n\t// Save the from and to text for :spellrepall.\n\tVIM_CLEAR(repl_from);\n\tVIM_CLEAR(repl_to);\n\n\tstp = &SUG(sug.su_ga, selected - 1);\n\tif (sug.su_badlen > stp->st_orglen)\n\t{\n\t    // Replacing less than \"su_badlen\", append the remainder to\n\t    // repl_to.\n\t    repl_from = vim_strnsave(sug.su_badptr, sug.su_badlen);\n\t    vim_snprintf((char *)IObuff, IOSIZE, \"%s%.*s\", stp->st_word,\n\t\t    sug.su_badlen - stp->st_orglen,\n\t\t\t\t\t      sug.su_badptr + stp->st_orglen);\n\t    repl_to = vim_strsave(IObuff);\n\t}\n\telse\n\t{\n\t    // Replacing su_badlen or more, use the whole word.\n\t    repl_from = vim_strnsave(sug.su_badptr, stp->st_orglen);\n\t    repl_to = vim_strsave(stp->st_word);\n\t}\n\n\t// Replace the word.\n\tp = alloc(STRLEN(line) - stp->st_orglen + stp->st_wordlen + 1);\n\tif (p != NULL)\n\t{\n\t    c = (int)(sug.su_badptr - line);\n\t    mch_memmove(p, line, c);\n\t    STRCPY(p + c, stp->st_word);\n\t    STRCAT(p, sug.su_badptr + stp->st_orglen);\n\n\t    // For redo we use a change-word command.\n\t    ResetRedobuff();\n\t    AppendToRedobuff((char_u *)\"ciw\");\n\t    AppendToRedobuffLit(p + c,\n\t\t\t    stp->st_wordlen + sug.su_badlen - stp->st_orglen);\n\t    AppendCharToRedobuff(ESC);\n\n\t    // \"p\" may be freed here\n\t    ml_replace(curwin->w_cursor.lnum, p, FALSE);\n\t    curwin->w_cursor.col = c;\n\n\t    changed_bytes(curwin->w_cursor.lnum, c);\n\t}\n    }\n    else\n\tcurwin->w_cursor = prev_cursor;\n\n    spell_find_cleanup(&sug);\nskip:\n    vim_free(line);\n    curwin->w_p_spell = wo_spell_save;\n}\n\n/*\n * Find spell suggestions for \"word\".  Return them in the growarray \"*gap\" as\n * a list of allocated strings.\n */\n    void\nspell_suggest_list(\n    garray_T\t*gap,\n    char_u\t*word,\n    int\t\tmaxcount,\t// maximum nr of suggestions\n    int\t\tneed_cap,\t// 'spellcapcheck' matched\n    int\t\tinteractive)\n{\n    suginfo_T\tsug;\n    int\t\ti;\n    suggest_T\t*stp;\n    char_u\t*wcopy;\n\n    spell_find_suggest(word, 0, &sug, maxcount, FALSE, need_cap, interactive);\n\n    // Make room in \"gap\".\n    ga_init2(gap, sizeof(char_u *), sug.su_ga.ga_len + 1);\n    if (ga_grow(gap, sug.su_ga.ga_len) == OK)\n    {\n\tfor (i = 0; i < sug.su_ga.ga_len; ++i)\n\t{\n\t    stp = &SUG(sug.su_ga, i);\n\n\t    // The suggested word may replace only part of \"word\", add the not\n\t    // replaced part.\n\t    wcopy = alloc(stp->st_wordlen\n\t\t      + (unsigned)STRLEN(sug.su_badptr + stp->st_orglen) + 1);\n\t    if (wcopy == NULL)\n\t\tbreak;\n\t    STRCPY(wcopy, stp->st_word);\n\t    STRCPY(wcopy + stp->st_wordlen, sug.su_badptr + stp->st_orglen);\n\t    ((char_u **)gap->ga_data)[gap->ga_len++] = wcopy;\n\t}\n    }\n\n    spell_find_cleanup(&sug);\n}\n\n/*\n * Find spell suggestions for the word at the start of \"badptr\".\n * Return the suggestions in \"su->su_ga\".\n * The maximum number of suggestions is \"maxcount\".\n * Note: does use info for the current window.\n * This is based on the mechanisms of Aspell, but completely reimplemented.\n */\n    static void\nspell_find_suggest(\n    char_u\t*badptr,\n    int\t\tbadlen,\t\t// length of bad word or 0 if unknown\n    suginfo_T\t*su,\n    int\t\tmaxcount,\n    int\t\tbanbadword,\t// don't include badword in suggestions\n    int\t\tneed_cap,\t// word should start with capital\n    int\t\tinteractive)\n{\n    hlf_T\tattr = HLF_COUNT;\n    char_u\tbuf[MAXPATHL];\n    char_u\t*p;\n    int\t\tdo_combine = FALSE;\n    char_u\t*sps_copy;\n#ifdef FEAT_EVAL\n    static int\texpr_busy = FALSE;\n#endif\n    int\t\tc;\n    int\t\ti;\n    langp_T\t*lp;\n    int\t\tdid_intern = FALSE;\n\n    // Set the info in \"*su\".\n    CLEAR_POINTER(su);\n    ga_init2(&su->su_ga, sizeof(suggest_T), 10);\n    ga_init2(&su->su_sga, sizeof(suggest_T), 10);\n    if (*badptr == NUL)\n\treturn;\n    hash_init(&su->su_banned);\n\n    su->su_badptr = badptr;\n    if (badlen != 0)\n\tsu->su_badlen = badlen;\n    else\n\tsu->su_badlen = spell_check(curwin, su->su_badptr, &attr, NULL, FALSE);\n    su->su_maxcount = maxcount;\n    su->su_maxscore = SCORE_MAXINIT;\n\n    if (su->su_badlen >= MAXWLEN)\n\tsu->su_badlen = MAXWLEN - 1;\t// just in case\n    vim_strncpy(su->su_badword, su->su_badptr, su->su_badlen);\n    (void)spell_casefold(curwin, su->su_badptr, su->su_badlen,\n\t\t\t\t\t\t    su->su_fbadword, MAXWLEN);\n    // TODO: make this work if the case-folded text is longer than the original\n    // text. Currently an illegal byte causes wrong pointer computations.\n    su->su_fbadword[su->su_badlen] = NUL;\n\n    // get caps flags for bad word\n    su->su_badflags = badword_captype(su->su_badptr,\n\t\t\t\t\t       su->su_badptr + su->su_badlen);\n    if (need_cap)\n\tsu->su_badflags |= WF_ONECAP;\n\n    // Find the default language for sound folding.  We simply use the first\n    // one in 'spelllang' that supports sound folding.  That's good for when\n    // using multiple files for one language, it's not that bad when mixing\n    // languages (e.g., \"pl,en\").\n    for (i = 0; i < curbuf->b_s.b_langp.ga_len; ++i)\n    {\n\tlp = LANGP_ENTRY(curbuf->b_s.b_langp, i);\n\tif (lp->lp_sallang != NULL)\n\t{\n\t    su->su_sallang = lp->lp_sallang;\n\t    break;\n\t}\n    }\n\n    // Soundfold the bad word with the default sound folding, so that we don't\n    // have to do this many times.\n    if (su->su_sallang != NULL)\n\tspell_soundfold(su->su_sallang, su->su_fbadword, TRUE,\n\t\t\t\t\t\t\t  su->su_sal_badword);\n\n    // If the word is not capitalised and spell_check() doesn't consider the\n    // word to be bad then it might need to be capitalised.  Add a suggestion\n    // for that.\n    c = PTR2CHAR(su->su_badptr);\n    if (!SPELL_ISUPPER(c) && attr == HLF_COUNT)\n    {\n\tmake_case_word(su->su_badword, buf, WF_ONECAP);\n\tadd_suggestion(su, &su->su_ga, buf, su->su_badlen, SCORE_ICASE,\n\t\t\t\t\t      0, TRUE, su->su_sallang, FALSE);\n    }\n\n    // Ban the bad word itself.  It may appear in another region.\n    if (banbadword)\n\tadd_banned(su, su->su_badword);\n\n    // Make a copy of 'spellsuggest', because the expression may change it.\n    sps_copy = vim_strsave(p_sps);\n    if (sps_copy == NULL)\n\treturn;\n\n    // Loop over the items in 'spellsuggest'.\n    for (p = sps_copy; *p != NUL; )\n    {\n\tcopy_option_part(&p, buf, MAXPATHL, \",\");\n\n\tif (STRNCMP(buf, \"expr:\", 5) == 0)\n\t{\n#ifdef FEAT_EVAL\n\t    // Evaluate an expression.  Skip this when called recursively,\n\t    // when using spellsuggest() in the expression.\n\t    if (!expr_busy)\n\t    {\n\t\texpr_busy = TRUE;\n\t\tspell_suggest_expr(su, buf + 5);\n\t\texpr_busy = FALSE;\n\t    }\n#endif\n\t}\n\telse if (STRNCMP(buf, \"file:\", 5) == 0)\n\t    // Use list of suggestions in a file.\n\t    spell_suggest_file(su, buf + 5);\n\telse if (!did_intern)\n\t{\n\t    // Use internal method once.\n\t    spell_suggest_intern(su, interactive);\n\t    if (sps_flags & SPS_DOUBLE)\n\t\tdo_combine = TRUE;\n\t    did_intern = TRUE;\n\t}\n    }\n\n    vim_free(sps_copy);\n\n    if (do_combine)\n\t// Combine the two list of suggestions.  This must be done last,\n\t// because sorting changes the order again.\n\tscore_combine(su);\n}\n\n#ifdef FEAT_EVAL\n/*\n * Find suggestions by evaluating expression \"expr\".\n */\n    static void\nspell_suggest_expr(suginfo_T *su, char_u *expr)\n{\n    list_T\t*list;\n    listitem_T\t*li;\n    int\t\tscore;\n    char_u\t*p;\n\n    // The work is split up in a few parts to avoid having to export\n    // suginfo_T.\n    // First evaluate the expression and get the resulting list.\n    list = eval_spell_expr(su->su_badword, expr);\n    if (list != NULL)\n    {\n\t// Loop over the items in the list.\n\tFOR_ALL_LIST_ITEMS(list, li)\n\t    if (li->li_tv.v_type == VAR_LIST)\n\t    {\n\t\t// Get the word and the score from the items.\n\t\tscore = get_spellword(li->li_tv.vval.v_list, &p);\n\t\tif (score >= 0 && score <= su->su_maxscore)\n\t\t    add_suggestion(su, &su->su_ga, p, su->su_badlen,\n\t\t\t\t       score, 0, TRUE, su->su_sallang, FALSE);\n\t    }\n\tlist_unref(list);\n    }\n\n    // Remove bogus suggestions, sort and truncate at \"maxcount\".\n    check_suggestions(su, &su->su_ga);\n    (void)cleanup_suggestions(&su->su_ga, su->su_maxscore, su->su_maxcount);\n}\n#endif\n\n/*\n * Find suggestions in file \"fname\".  Used for \"file:\" in 'spellsuggest'.\n */\n    static void\nspell_suggest_file(suginfo_T *su, char_u *fname)\n{\n    FILE\t*fd;\n    char_u\tline[MAXWLEN * 2];\n    char_u\t*p;\n    int\t\tlen;\n    char_u\tcword[MAXWLEN];\n\n    // Open the file.\n    fd = mch_fopen((char *)fname, \"r\");\n    if (fd == NULL)\n    {\n\tsemsg(_(e_cant_open_file_str), fname);\n\treturn;\n    }\n\n    // Read it line by line.\n    while (!vim_fgets(line, MAXWLEN * 2, fd) && !got_int)\n    {\n\tline_breakcheck();\n\n\tp = vim_strchr(line, '/');\n\tif (p == NULL)\n\t    continue;\t    // No Tab found, just skip the line.\n\t*p++ = NUL;\n\tif (STRICMP(su->su_badword, line) == 0)\n\t{\n\t    // Match!  Isolate the good word, until CR or NL.\n\t    for (len = 0; p[len] >= ' '; ++len)\n\t\t;\n\t    p[len] = NUL;\n\n\t    // If the suggestion doesn't have specific case duplicate the case\n\t    // of the bad word.\n\t    if (captype(p, NULL) == 0)\n\t    {\n\t\tmake_case_word(p, cword, su->su_badflags);\n\t\tp = cword;\n\t    }\n\n\t    add_suggestion(su, &su->su_ga, p, su->su_badlen,\n\t\t\t\t  SCORE_FILE, 0, TRUE, su->su_sallang, FALSE);\n\t}\n    }\n\n    fclose(fd);\n\n    // Remove bogus suggestions, sort and truncate at \"maxcount\".\n    check_suggestions(su, &su->su_ga);\n    (void)cleanup_suggestions(&su->su_ga, su->su_maxscore, su->su_maxcount);\n}\n\n/*\n * Find suggestions for the internal method indicated by \"sps_flags\".\n */\n    static void\nspell_suggest_intern(suginfo_T *su, int interactive)\n{\n    // Load the .sug file(s) that are available and not done yet.\n    suggest_load_files();\n\n    // 1. Try special cases, such as repeating a word: \"the the\" -> \"the\".\n    //\n    // Set a maximum score to limit the combination of operations that is\n    // tried.\n    suggest_try_special(su);\n\n    // 2. Try inserting/deleting/swapping/changing a letter, use REP entries\n    //    from the .aff file and inserting a space (split the word).\n    suggest_try_change(su);\n\n    // For the resulting top-scorers compute the sound-a-like score.\n    if (sps_flags & SPS_DOUBLE)\n\tscore_comp_sal(su);\n\n    // 3. Try finding sound-a-like words.\n    if ((sps_flags & SPS_FAST) == 0)\n    {\n\tif (sps_flags & SPS_BEST)\n\t    // Adjust the word score for the suggestions found so far for how\n\t    // they sound like.\n\t    rescore_suggestions(su);\n\n\t// While going through the soundfold tree \"su_maxscore\" is the score\n\t// for the soundfold word, limits the changes that are being tried,\n\t// and \"su_sfmaxscore\" the rescored score, which is set by\n\t// cleanup_suggestions().\n\t// First find words with a small edit distance, because this is much\n\t// faster and often already finds the top-N suggestions.  If we didn't\n\t// find many suggestions try again with a higher edit distance.\n\t// \"sl_sounddone\" is used to avoid doing the same word twice.\n\tsuggest_try_soundalike_prep();\n\tsu->su_maxscore = SCORE_SFMAX1;\n\tsu->su_sfmaxscore = SCORE_MAXINIT * 3;\n\tsuggest_try_soundalike(su);\n\tif (su->su_ga.ga_len < SUG_CLEAN_COUNT(su))\n\t{\n\t    // We didn't find enough matches, try again, allowing more\n\t    // changes to the soundfold word.\n\t    su->su_maxscore = SCORE_SFMAX2;\n\t    suggest_try_soundalike(su);\n\t    if (su->su_ga.ga_len < SUG_CLEAN_COUNT(su))\n\t    {\n\t\t// Still didn't find enough matches, try again, allowing even\n\t\t// more changes to the soundfold word.\n\t\tsu->su_maxscore = SCORE_SFMAX3;\n\t\tsuggest_try_soundalike(su);\n\t    }\n\t}\n\tsu->su_maxscore = su->su_sfmaxscore;\n\tsuggest_try_soundalike_finish();\n    }\n\n    // When CTRL-C was hit while searching do show the results.  Only clear\n    // got_int when using a command, not for spellsuggest().\n    ui_breakcheck();\n    if (interactive && got_int)\n    {\n\t(void)vgetc();\n\tgot_int = FALSE;\n    }\n\n    if ((sps_flags & SPS_DOUBLE) == 0 && su->su_ga.ga_len != 0)\n    {\n\tif (sps_flags & SPS_BEST)\n\t    // Adjust the word score for how it sounds like.\n\t    rescore_suggestions(su);\n\n\t// Remove bogus suggestions, sort and truncate at \"maxcount\".\n\tcheck_suggestions(su, &su->su_ga);\n\t(void)cleanup_suggestions(&su->su_ga, su->su_maxscore, su->su_maxcount);\n    }\n}\n\n/*\n * Free the info put in \"*su\" by spell_find_suggest().\n */\n    static void\nspell_find_cleanup(suginfo_T *su)\n{\n    int\t\ti;\n\n    // Free the suggestions.\n    for (i = 0; i < su->su_ga.ga_len; ++i)\n\tvim_free(SUG(su->su_ga, i).st_word);\n    ga_clear(&su->su_ga);\n    for (i = 0; i < su->su_sga.ga_len; ++i)\n\tvim_free(SUG(su->su_sga, i).st_word);\n    ga_clear(&su->su_sga);\n\n    // Free the banned words.\n    hash_clear_all(&su->su_banned, 0);\n}\n\n/*\n * Try finding suggestions by recognizing specific situations.\n */\n    static void\nsuggest_try_special(suginfo_T *su)\n{\n    char_u\t*p;\n    size_t\tlen;\n    int\t\tc;\n    char_u\tword[MAXWLEN];\n\n    // Recognize a word that is repeated: \"the the\".\n    p = skiptowhite(su->su_fbadword);\n    len = p - su->su_fbadword;\n    p = skipwhite(p);\n    if (STRLEN(p) == len && STRNCMP(su->su_fbadword, p, len) == 0)\n    {\n\t// Include badflags: if the badword is onecap or allcap\n\t// use that for the goodword too: \"The the\" -> \"The\".\n\tc = su->su_fbadword[len];\n\tsu->su_fbadword[len] = NUL;\n\tmake_case_word(su->su_fbadword, word, su->su_badflags);\n\tsu->su_fbadword[len] = c;\n\n\t// Give a soundalike score of 0, compute the score as if deleting one\n\t// character.\n\tadd_suggestion(su, &su->su_ga, word, su->su_badlen,\n\t\t       RESCORE(SCORE_REP, 0), 0, TRUE, su->su_sallang, FALSE);\n    }\n}\n\n/*\n * Change the 0 to 1 to measure how much time is spent in each state.\n * Output is dumped in \"suggestprof\".\n */\n#if 0\n# define SUGGEST_PROFILE\nproftime_T current;\nproftime_T total;\nproftime_T times[STATE_FINAL + 1];\nlong counts[STATE_FINAL + 1];\n\n    static void\nprof_init(void)\n{\n    for (int i = 0; i <= STATE_FINAL; ++i)\n    {\n\tprofile_zero(&times[i]);\n\tcounts[i] = 0;\n    }\n    profile_start(&current);\n    profile_start(&total);\n}\n\n// call before changing state\n    static void\nprof_store(state_T state)\n{\n    profile_end(&current);\n    profile_add(&times[state], &current);\n    ++counts[state];\n    profile_start(&current);\n}\n# define PROF_STORE(state) prof_store(state);\n\n    static void\nprof_report(char *name)\n{\n    FILE *fd = fopen(\"suggestprof\", \"a\");\n\n    profile_end(&total);\n    fprintf(fd, \"-----------------------\\n\");\n    fprintf(fd, \"%s: %s\\n\", name, profile_msg(&total));\n    for (int i = 0; i <= STATE_FINAL; ++i)\n\tfprintf(fd, \"%d: %s (%ld)\\n\", i, profile_msg(&times[i]), counts[i]);\n    fclose(fd);\n}\n#else\n# define PROF_STORE(state)\n#endif\n\n/*\n * Try finding suggestions by adding/removing/swapping letters.\n */\n    static void\nsuggest_try_change(suginfo_T *su)\n{\n    char_u\tfword[MAXWLEN];\t    // copy of the bad word, case-folded\n    int\t\tn;\n    char_u\t*p;\n    int\t\tlpi;\n    langp_T\t*lp;\n\n    // We make a copy of the case-folded bad word, so that we can modify it\n    // to find matches (esp. REP items).  Append some more text, changing\n    // chars after the bad word may help.\n    STRCPY(fword, su->su_fbadword);\n    n = (int)STRLEN(fword);\n    p = su->su_badptr + su->su_badlen;\n    (void)spell_casefold(curwin, p, (int)STRLEN(p), fword + n, MAXWLEN - n);\n\n    // Make sure the resulting text is not longer than the original text.\n    n = (int)STRLEN(su->su_badptr);\n    if (n < MAXWLEN)\n\tfword[n] = NUL;\n\n    for (lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi)\n    {\n\tlp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);\n\n\t// If reloading a spell file fails it's still in the list but\n\t// everything has been cleared.\n\tif (lp->lp_slang->sl_fbyts == NULL)\n\t    continue;\n\n\t// Try it for this language.  Will add possible suggestions.\n#ifdef SUGGEST_PROFILE\n\tprof_init();\n#endif\n\tsuggest_trie_walk(su, lp, fword, FALSE);\n#ifdef SUGGEST_PROFILE\n\tprof_report(\"try_change\");\n#endif\n    }\n}\n\n// Check the maximum score, if we go over it we won't try this change.\n#define TRY_DEEPER(su, stack, depth, add) \\\n\t\t(stack[depth].ts_score + (add) < su->su_maxscore)\n\n/*\n * Try finding suggestions by adding/removing/swapping letters.\n *\n * This uses a state machine.  At each node in the tree we try various\n * operations.  When trying if an operation works \"depth\" is increased and the\n * stack[] is used to store info.  This allows combinations, thus insert one\n * character, replace one and delete another.  The number of changes is\n * limited by su->su_maxscore.\n *\n * After implementing this I noticed an article by Kemal Oflazer that\n * describes something similar: \"Error-tolerant Finite State Recognition with\n * Applications to Morphological Analysis and Spelling Correction\" (1996).\n * The implementation in the article is simplified and requires a stack of\n * unknown depth.  The implementation here only needs a stack depth equal to\n * the length of the word.\n *\n * This is also used for the sound-folded word, \"soundfold\" is TRUE then.\n * The mechanism is the same, but we find a match with a sound-folded word\n * that comes from one or more original words.  Each of these words may be\n * added, this is done by add_sound_suggest().\n * Don't use:\n *\tthe prefix tree or the keep-case tree\n *\t\"su->su_badlen\"\n *\tanything to do with upper and lower case\n *\tanything to do with word or non-word characters (\"spell_iswordp()\")\n *\tbanned words\n *\tword flags (rare, region, compounding)\n *\tword splitting for now\n *\t\"similar_chars()\"\n *\tuse \"slang->sl_repsal\" instead of \"lp->lp_replang->sl_rep\"\n */\n    static void\nsuggest_trie_walk(\n    suginfo_T\t*su,\n    langp_T\t*lp,\n    char_u\t*fword,\n    int\t\tsoundfold)\n{\n    char_u\ttword[MAXWLEN];\t    // good word collected so far\n    trystate_T\tstack[MAXWLEN];\n    char_u\tpreword[MAXWLEN * 3]; // word found with proper case;\n\t\t\t\t      // concatenation of prefix compound\n\t\t\t\t      // words and split word.  NUL terminated\n\t\t\t\t      // when going deeper but not when coming\n\t\t\t\t      // back.\n    char_u\tcompflags[MAXWLEN];\t// compound flags, one for each word\n    trystate_T\t*sp;\n    int\t\tnewscore;\n    int\t\tscore;\n    char_u\t*byts, *fbyts, *pbyts;\n    idx_T\t*idxs, *fidxs, *pidxs;\n    int\t\tdepth;\n    int\t\tc, c2, c3;\n    int\t\tn = 0;\n    int\t\tflags;\n    garray_T\t*gap;\n    idx_T\tarridx;\n    int\t\tlen;\n    char_u\t*p;\n    fromto_T\t*ftp;\n    int\t\tfl = 0, tl;\n    int\t\trepextra = 0;\t    // extra bytes in fword[] from REP item\n    slang_T\t*slang = lp->lp_slang;\n    int\t\tfword_ends;\n    int\t\tgoodword_ends;\n#ifdef DEBUG_TRIEWALK\n    // Stores the name of the change made at each level.\n    char_u\tchangename[MAXWLEN][80];\n#endif\n    int\t\tbreakcheckcount = 1000;\n    int\t\tcompound_ok;\n\n    // Go through the whole case-fold tree, try changes at each node.\n    // \"tword[]\" contains the word collected from nodes in the tree.\n    // \"fword[]\" the word we are trying to match with (initially the bad\n    // word).\n    depth = 0;\n    sp = &stack[0];\n    CLEAR_POINTER(sp);\n    sp->ts_curi = 1;\n\n    if (soundfold)\n    {\n\t// Going through the soundfold tree.\n\tbyts = fbyts = slang->sl_sbyts;\n\tidxs = fidxs = slang->sl_sidxs;\n\tpbyts = NULL;\n\tpidxs = NULL;\n\tsp->ts_prefixdepth = PFD_NOPREFIX;\n\tsp->ts_state = STATE_START;\n    }\n    else\n    {\n\t// When there are postponed prefixes we need to use these first.  At\n\t// the end of the prefix we continue in the case-fold tree.\n\tfbyts = slang->sl_fbyts;\n\tfidxs = slang->sl_fidxs;\n\tpbyts = slang->sl_pbyts;\n\tpidxs = slang->sl_pidxs;\n\tif (pbyts != NULL)\n\t{\n\t    byts = pbyts;\n\t    idxs = pidxs;\n\t    sp->ts_prefixdepth = PFD_PREFIXTREE;\n\t    sp->ts_state = STATE_NOPREFIX;\t// try without prefix first\n\t}\n\telse\n\t{\n\t    byts = fbyts;\n\t    idxs = fidxs;\n\t    sp->ts_prefixdepth = PFD_NOPREFIX;\n\t    sp->ts_state = STATE_START;\n\t}\n    }\n\n    // Loop to find all suggestions.  At each round we either:\n    // - For the current state try one operation, advance \"ts_curi\",\n    //   increase \"depth\".\n    // - When a state is done go to the next, set \"ts_state\".\n    // - When all states are tried decrease \"depth\".\n    while (depth >= 0 && !got_int)\n    {\n\tsp = &stack[depth];\n\tswitch (sp->ts_state)\n\t{\n\tcase STATE_START:\n\tcase STATE_NOPREFIX:\n\t    // Start of node: Deal with NUL bytes, which means\n\t    // tword[] may end here.\n\t    arridx = sp->ts_arridx;\t    // current node in the tree\n\t    len = byts[arridx];\t\t    // bytes in this node\n\t    arridx += sp->ts_curi;\t    // index of current byte\n\n\t    if (sp->ts_prefixdepth == PFD_PREFIXTREE)\n\t    {\n\t\t// Skip over the NUL bytes, we use them later.\n\t\tfor (n = 0; n < len && byts[arridx + n] == 0; ++n)\n\t\t    ;\n\t\tsp->ts_curi += n;\n\n\t\t// Always past NUL bytes now.\n\t\tn = (int)sp->ts_state;\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_ENDNUL;\n\t\tsp->ts_save_badflags = su->su_badflags;\n\n\t\t// At end of a prefix or at start of prefixtree: check for\n\t\t// following word.\n\t\tif (byts[arridx] == 0 || n == (int)STATE_NOPREFIX)\n\t\t{\n\t\t    // Set su->su_badflags to the caps type at this position.\n\t\t    // Use the caps type until here for the prefix itself.\n\t\t    if (has_mbyte)\n\t\t\tn = nofold_len(fword, sp->ts_fidx, su->su_badptr);\n\t\t    else\n\t\t\tn = sp->ts_fidx;\n\t\t    flags = badword_captype(su->su_badptr, su->su_badptr + n);\n\t\t    su->su_badflags = badword_captype(su->su_badptr + n,\n\t\t\t\t\t       su->su_badptr + su->su_badlen);\n#ifdef DEBUG_TRIEWALK\n\t\t    sprintf(changename[depth], \"prefix\");\n#endif\n\t\t    go_deeper(stack, depth, 0);\n\t\t    ++depth;\n\t\t    sp = &stack[depth];\n\t\t    sp->ts_prefixdepth = depth - 1;\n\t\t    byts = fbyts;\n\t\t    idxs = fidxs;\n\t\t    sp->ts_arridx = 0;\n\n\t\t    // Move the prefix to preword[] with the right case\n\t\t    // and make find_keepcap_word() works.\n\t\t    tword[sp->ts_twordlen] = NUL;\n\t\t    make_case_word(tword + sp->ts_splitoff,\n\t\t\t\t\t  preword + sp->ts_prewordlen, flags);\n\t\t    sp->ts_prewordlen = (char_u)STRLEN(preword);\n\t\t    sp->ts_splitoff = sp->ts_twordlen;\n\t\t}\n\t\tbreak;\n\t    }\n\n\t    if (sp->ts_curi > len || byts[arridx] != 0)\n\t    {\n\t\t// Past bytes in node and/or past NUL bytes.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_ENDNUL;\n\t\tsp->ts_save_badflags = su->su_badflags;\n\t\tbreak;\n\t    }\n\n\t    // End of word in tree.\n\t    ++sp->ts_curi;\t\t// eat one NUL byte\n\n\t    flags = (int)idxs[arridx];\n\n\t    // Skip words with the NOSUGGEST flag.\n\t    if (flags & WF_NOSUGGEST)\n\t\tbreak;\n\n\t    fword_ends = (fword[sp->ts_fidx] == NUL\n\t\t\t   || (soundfold\n\t\t\t       ? VIM_ISWHITE(fword[sp->ts_fidx])\n\t\t\t       : !spell_iswordp(fword + sp->ts_fidx, curwin)));\n\t    tword[sp->ts_twordlen] = NUL;\n\n\t    if (sp->ts_prefixdepth <= PFD_NOTSPECIAL\n\t\t\t\t\t&& (sp->ts_flags & TSF_PREFIXOK) == 0\n\t\t\t\t\t&& pbyts != NULL)\n\t    {\n\t\t// There was a prefix before the word.  Check that the prefix\n\t\t// can be used with this word.\n\t\t// Count the length of the NULs in the prefix.  If there are\n\t\t// none this must be the first try without a prefix.\n\t\tn = stack[sp->ts_prefixdepth].ts_arridx;\n\t\tlen = pbyts[n++];\n\t\tfor (c = 0; c < len && pbyts[n + c] == 0; ++c)\n\t\t    ;\n\t\tif (c > 0)\n\t\t{\n\t\t    c = valid_word_prefix(c, n, flags,\n\t\t\t\t       tword + sp->ts_splitoff, slang, FALSE);\n\t\t    if (c == 0)\n\t\t\tbreak;\n\n\t\t    // Use the WF_RARE flag for a rare prefix.\n\t\t    if (c & WF_RAREPFX)\n\t\t\tflags |= WF_RARE;\n\n\t\t    // Tricky: when checking for both prefix and compounding\n\t\t    // we run into the prefix flag first.\n\t\t    // Remember that it's OK, so that we accept the prefix\n\t\t    // when arriving at a compound flag.\n\t\t    sp->ts_flags |= TSF_PREFIXOK;\n\t\t}\n\t    }\n\n\t    // Check NEEDCOMPOUND: can't use word without compounding.  Do try\n\t    // appending another compound word below.\n\t    if (sp->ts_complen == sp->ts_compsplit && fword_ends\n\t\t\t\t\t\t     && (flags & WF_NEEDCOMP))\n\t\tgoodword_ends = FALSE;\n\t    else\n\t\tgoodword_ends = TRUE;\n\n\t    p = NULL;\n\t    compound_ok = TRUE;\n\t    if (sp->ts_complen > sp->ts_compsplit)\n\t    {\n\t\tif (slang->sl_nobreak)\n\t\t{\n\t\t    // There was a word before this word.  When there was no\n\t\t    // change in this word (it was correct) add the first word\n\t\t    // as a suggestion.  If this word was corrected too, we\n\t\t    // need to check if a correct word follows.\n\t\t    if (sp->ts_fidx - sp->ts_splitfidx\n\t\t\t\t\t  == sp->ts_twordlen - sp->ts_splitoff\n\t\t\t    && STRNCMP(fword + sp->ts_splitfidx,\n\t\t\t\t\ttword + sp->ts_splitoff,\n\t\t\t\t\t sp->ts_fidx - sp->ts_splitfidx) == 0)\n\t\t    {\n\t\t\tpreword[sp->ts_prewordlen] = NUL;\n\t\t\tnewscore = score_wordcount_adj(slang, sp->ts_score,\n\t\t\t\t\t\t preword + sp->ts_prewordlen,\n\t\t\t\t\t\t sp->ts_prewordlen > 0);\n\t\t\t// Add the suggestion if the score isn't too bad.\n\t\t\tif (newscore <= su->su_maxscore)\n\t\t\t    add_suggestion(su, &su->su_ga, preword,\n\t\t\t\t    sp->ts_splitfidx - repextra,\n\t\t\t\t    newscore, 0, FALSE,\n\t\t\t\t    lp->lp_sallang, FALSE);\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    // There was a compound word before this word.  If this\n\t\t    // word does not support compounding then give up\n\t\t    // (splitting is tried for the word without compound\n\t\t    // flag).\n\t\t    if (((unsigned)flags >> 24) == 0\n\t\t\t    || sp->ts_twordlen - sp->ts_splitoff\n\t\t\t\t\t\t       < slang->sl_compminlen)\n\t\t\tbreak;\n\t\t    // For multi-byte chars check character length against\n\t\t    // COMPOUNDMIN.\n\t\t    if (has_mbyte\n\t\t\t    && slang->sl_compminlen > 0\n\t\t\t    && mb_charlen(tword + sp->ts_splitoff)\n\t\t\t\t\t\t       < slang->sl_compminlen)\n\t\t\tbreak;\n\n\t\t    compflags[sp->ts_complen] = ((unsigned)flags >> 24);\n\t\t    compflags[sp->ts_complen + 1] = NUL;\n\t\t    vim_strncpy(preword + sp->ts_prewordlen,\n\t\t\t    tword + sp->ts_splitoff,\n\t\t\t    sp->ts_twordlen - sp->ts_splitoff);\n\n\t\t    // Verify CHECKCOMPOUNDPATTERN  rules.\n\t\t    if (match_checkcompoundpattern(preword,  sp->ts_prewordlen,\n\t\t\t\t\t\t\t  &slang->sl_comppat))\n\t\t\tcompound_ok = FALSE;\n\n\t\t    if (compound_ok)\n\t\t    {\n\t\t\tp = preword;\n\t\t\twhile (*skiptowhite(p) != NUL)\n\t\t\t    p = skipwhite(skiptowhite(p));\n\t\t\tif (fword_ends && !can_compound(slang, p,\n\t\t\t\t\t\tcompflags + sp->ts_compsplit))\n\t\t\t    // Compound is not allowed.  But it may still be\n\t\t\t    // possible if we add another (short) word.\n\t\t\t    compound_ok = FALSE;\n\t\t    }\n\n\t\t    // Get pointer to last char of previous word.\n\t\t    p = preword + sp->ts_prewordlen;\n\t\t    MB_PTR_BACK(preword, p);\n\t\t}\n\t    }\n\n\t    // Form the word with proper case in preword.\n\t    // If there is a word from a previous split, append.\n\t    // For the soundfold tree don't change the case, simply append.\n\t    if (soundfold)\n\t\tSTRCPY(preword + sp->ts_prewordlen, tword + sp->ts_splitoff);\n\t    else if (flags & WF_KEEPCAP)\n\t\t// Must find the word in the keep-case tree.\n\t\tfind_keepcap_word(slang, tword + sp->ts_splitoff,\n\t\t\t\t\t\t preword + sp->ts_prewordlen);\n\t    else\n\t    {\n\t\t// Include badflags: If the badword is onecap or allcap\n\t\t// use that for the goodword too.  But if the badword is\n\t\t// allcap and it's only one char long use onecap.\n\t\tc = su->su_badflags;\n\t\tif ((c & WF_ALLCAP)\n\t\t\t&& su->su_badlen == (*mb_ptr2len)(su->su_badptr))\n\t\t    c = WF_ONECAP;\n\t\tc |= flags;\n\n\t\t// When appending a compound word after a word character don't\n\t\t// use Onecap.\n\t\tif (p != NULL && spell_iswordp_nmw(p, curwin))\n\t\t    c &= ~WF_ONECAP;\n\t\tmake_case_word(tword + sp->ts_splitoff,\n\t\t\t\t\t      preword + sp->ts_prewordlen, c);\n\t    }\n\n\t    if (!soundfold)\n\t    {\n\t\t// Don't use a banned word.  It may appear again as a good\n\t\t// word, thus remember it.\n\t\tif (flags & WF_BANNED)\n\t\t{\n\t\t    add_banned(su, preword + sp->ts_prewordlen);\n\t\t    break;\n\t\t}\n\t\tif ((sp->ts_complen == sp->ts_compsplit\n\t\t\t    && WAS_BANNED(su, preword + sp->ts_prewordlen))\n\t\t\t\t\t\t   || WAS_BANNED(su, preword))\n\t\t{\n\t\t    if (slang->sl_compprog == NULL)\n\t\t\tbreak;\n\t\t    // the word so far was banned but we may try compounding\n\t\t    goodword_ends = FALSE;\n\t\t}\n\t    }\n\n\t    newscore = 0;\n\t    if (!soundfold)\t// soundfold words don't have flags\n\t    {\n\t\tif ((flags & WF_REGION)\n\t\t\t    && (((unsigned)flags >> 16) & lp->lp_region) == 0)\n\t\t    newscore += SCORE_REGION;\n\t\tif (flags & WF_RARE)\n\t\t    newscore += SCORE_RARE;\n\n\t\tif (!spell_valid_case(su->su_badflags,\n\t\t\t\t  captype(preword + sp->ts_prewordlen, NULL)))\n\t\t    newscore += SCORE_ICASE;\n\t    }\n\n\t    // TODO: how about splitting in the soundfold tree?\n\t    if (fword_ends\n\t\t    && goodword_ends\n\t\t    && sp->ts_fidx >= sp->ts_fidxtry\n\t\t    && compound_ok)\n\t    {\n\t\t// The badword also ends: add suggestions.\n#ifdef DEBUG_TRIEWALK\n\t\tif (soundfold && STRCMP(preword, \"smwrd\") == 0)\n\t\t{\n\t\t    int\t    j;\n\n\t\t    // print the stack of changes that brought us here\n\t\t    smsg(\"------ %s -------\", fword);\n\t\t    for (j = 0; j < depth; ++j)\n\t\t\tsmsg(\"%s\", changename[j]);\n\t\t}\n#endif\n\t\tif (soundfold)\n\t\t{\n\t\t    // For soundfolded words we need to find the original\n\t\t    // words, the edit distance and then add them.\n\t\t    add_sound_suggest(su, preword, sp->ts_score, lp);\n\t\t}\n\t\telse if (sp->ts_fidx > 0)\n\t\t{\n\t\t    // Give a penalty when changing non-word char to word\n\t\t    // char, e.g., \"thes,\" -> \"these\".\n\t\t    p = fword + sp->ts_fidx;\n\t\t    MB_PTR_BACK(fword, p);\n\t\t    if (!spell_iswordp(p, curwin) && *preword != NUL)\n\t\t    {\n\t\t\tp = preword + STRLEN(preword);\n\t\t\tMB_PTR_BACK(preword, p);\n\t\t\tif (spell_iswordp(p, curwin))\n\t\t\t    newscore += SCORE_NONWORD;\n\t\t    }\n\n\t\t    // Give a bonus to words seen before.\n\t\t    score = score_wordcount_adj(slang,\n\t\t\t\t\t\tsp->ts_score + newscore,\n\t\t\t\t\t\tpreword + sp->ts_prewordlen,\n\t\t\t\t\t\tsp->ts_prewordlen > 0);\n\n\t\t    // Add the suggestion if the score isn't too bad.\n\t\t    if (score <= su->su_maxscore)\n\t\t    {\n\t\t\tadd_suggestion(su, &su->su_ga, preword,\n\t\t\t\t    sp->ts_fidx - repextra,\n\t\t\t\t    score, 0, FALSE, lp->lp_sallang, FALSE);\n\n\t\t\tif (su->su_badflags & WF_MIXCAP)\n\t\t\t{\n\t\t\t    // We really don't know if the word should be\n\t\t\t    // upper or lower case, add both.\n\t\t\t    c = captype(preword, NULL);\n\t\t\t    if (c == 0 || c == WF_ALLCAP)\n\t\t\t    {\n\t\t\t\tmake_case_word(tword + sp->ts_splitoff,\n\t\t\t\t\t      preword + sp->ts_prewordlen,\n\t\t\t\t\t\t      c == 0 ? WF_ALLCAP : 0);\n\n\t\t\t\tadd_suggestion(su, &su->su_ga, preword,\n\t\t\t\t\tsp->ts_fidx - repextra,\n\t\t\t\t\tscore + SCORE_ICASE, 0, FALSE,\n\t\t\t\t\tlp->lp_sallang, FALSE);\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\n\t    // Try word split and/or compounding.\n\t    if ((sp->ts_fidx >= sp->ts_fidxtry || fword_ends)\n\t\t    // Don't split halfway a character.\n\t\t    && (!has_mbyte || sp->ts_tcharlen == 0))\n\t    {\n\t\tint\ttry_compound;\n\t\tint\ttry_split;\n\n\t\t// If past the end of the bad word don't try a split.\n\t\t// Otherwise try changing the next word.  E.g., find\n\t\t// suggestions for \"the the\" where the second \"the\" is\n\t\t// different.  It's done like a split.\n\t\t// TODO: word split for soundfold words\n\t\ttry_split = (sp->ts_fidx - repextra < su->su_badlen)\n\t\t\t\t\t\t\t\t&& !soundfold;\n\n\t\t// Get here in several situations:\n\t\t// 1. The word in the tree ends:\n\t\t//    If the word allows compounding try that.  Otherwise try\n\t\t//    a split by inserting a space.  For both check that a\n\t\t//    valid words starts at fword[sp->ts_fidx].\n\t\t//    For NOBREAK do like compounding to be able to check if\n\t\t//    the next word is valid.\n\t\t// 2. The badword does end, but it was due to a change (e.g.,\n\t\t//    a swap).  No need to split, but do check that the\n\t\t//    following word is valid.\n\t\t// 3. The badword and the word in the tree end.  It may still\n\t\t//    be possible to compound another (short) word.\n\t\ttry_compound = FALSE;\n\t\tif (!soundfold\n\t\t\t&& !slang->sl_nocompoundsugs\n\t\t\t&& slang->sl_compprog != NULL\n\t\t\t&& ((unsigned)flags >> 24) != 0\n\t\t\t&& sp->ts_twordlen - sp->ts_splitoff\n\t\t\t\t\t\t       >= slang->sl_compminlen\n\t\t\t&& (!has_mbyte\n\t\t\t    || slang->sl_compminlen == 0\n\t\t\t    || mb_charlen(tword + sp->ts_splitoff)\n\t\t\t\t\t\t      >= slang->sl_compminlen)\n\t\t\t&& (slang->sl_compsylmax < MAXWLEN\n\t\t\t    || sp->ts_complen + 1 - sp->ts_compsplit\n\t\t\t\t\t\t\t  < slang->sl_compmax)\n\t\t\t&& (can_be_compound(sp, slang,\n\t\t\t\t\t compflags, ((unsigned)flags >> 24))))\n\n\t\t{\n\t\t    try_compound = TRUE;\n\t\t    compflags[sp->ts_complen] = ((unsigned)flags >> 24);\n\t\t    compflags[sp->ts_complen + 1] = NUL;\n\t\t}\n\n\t\t// For NOBREAK we never try splitting, it won't make any word\n\t\t// valid.\n\t\tif (slang->sl_nobreak && !slang->sl_nocompoundsugs)\n\t\t    try_compound = TRUE;\n\n\t\t// If we could add a compound word, and it's also possible to\n\t\t// split at this point, do the split first and set\n\t\t// TSF_DIDSPLIT to avoid doing it again.\n\t\telse if (!fword_ends\n\t\t\t&& try_compound\n\t\t\t&& (sp->ts_flags & TSF_DIDSPLIT) == 0)\n\t\t{\n\t\t    try_compound = FALSE;\n\t\t    sp->ts_flags |= TSF_DIDSPLIT;\n\t\t    --sp->ts_curi;\t    // do the same NUL again\n\t\t    compflags[sp->ts_complen] = NUL;\n\t\t}\n\t\telse\n\t\t    sp->ts_flags &= ~TSF_DIDSPLIT;\n\n\t\tif (try_split || try_compound)\n\t\t{\n\t\t    if (!try_compound && (!fword_ends || !goodword_ends))\n\t\t    {\n\t\t\t// If we're going to split need to check that the\n\t\t\t// words so far are valid for compounding.  If there\n\t\t\t// is only one word it must not have the NEEDCOMPOUND\n\t\t\t// flag.\n\t\t\tif (sp->ts_complen == sp->ts_compsplit\n\t\t\t\t\t\t     && (flags & WF_NEEDCOMP))\n\t\t\t    break;\n\t\t\tp = preword;\n\t\t\twhile (*skiptowhite(p) != NUL)\n\t\t\t    p = skipwhite(skiptowhite(p));\n\t\t\tif (sp->ts_complen > sp->ts_compsplit\n\t\t\t\t&& !can_compound(slang, p,\n\t\t\t\t\t\tcompflags + sp->ts_compsplit))\n\t\t\t    break;\n\n\t\t\tif (slang->sl_nosplitsugs)\n\t\t\t    newscore += SCORE_SPLIT_NO;\n\t\t\telse\n\t\t\t    newscore += SCORE_SPLIT;\n\n\t\t\t// Give a bonus to words seen before.\n\t\t\tnewscore = score_wordcount_adj(slang, newscore,\n\t\t\t\t\t   preword + sp->ts_prewordlen, TRUE);\n\t\t    }\n\n\t\t    if (TRY_DEEPER(su, stack, depth, newscore))\n\t\t    {\n\t\t\tgo_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\t\t\tif (!try_compound && !fword_ends)\n\t\t\t    sprintf(changename[depth], \"%.*s-%s: split\",\n\t\t\t\t sp->ts_twordlen, tword, fword + sp->ts_fidx);\n\t\t\telse\n\t\t\t    sprintf(changename[depth], \"%.*s-%s: compound\",\n\t\t\t\t sp->ts_twordlen, tword, fword + sp->ts_fidx);\n#endif\n\t\t\t// Save things to be restored at STATE_SPLITUNDO.\n\t\t\tsp->ts_save_badflags = su->su_badflags;\n\t\t\tPROF_STORE(sp->ts_state)\n\t\t\tsp->ts_state = STATE_SPLITUNDO;\n\n\t\t\t++depth;\n\t\t\tsp = &stack[depth];\n\n\t\t\t// Append a space to preword when splitting.\n\t\t\tif (!try_compound && !fword_ends)\n\t\t\t    STRCAT(preword, \" \");\n\t\t\tsp->ts_prewordlen = (char_u)STRLEN(preword);\n\t\t\tsp->ts_splitoff = sp->ts_twordlen;\n\t\t\tsp->ts_splitfidx = sp->ts_fidx;\n\n\t\t\t// If the badword has a non-word character at this\n\t\t\t// position skip it.  That means replacing the\n\t\t\t// non-word character with a space.  Always skip a\n\t\t\t// character when the word ends.  But only when the\n\t\t\t// good word can end.\n\t\t\tif (((!try_compound && !spell_iswordp_nmw(fword\n\t\t\t\t\t\t\t       + sp->ts_fidx,\n\t\t\t\t\t\t\t       curwin))\n\t\t\t\t    || fword_ends)\n\t\t\t\t&& fword[sp->ts_fidx] != NUL\n\t\t\t\t&& goodword_ends)\n\t\t\t{\n\t\t\t    int\t    l;\n\n\t\t\t    l = mb_ptr2len(fword + sp->ts_fidx);\n\t\t\t    if (fword_ends)\n\t\t\t    {\n\t\t\t\t// Copy the skipped character to preword.\n\t\t\t\tmch_memmove(preword + sp->ts_prewordlen,\n\t\t\t\t\t\t      fword + sp->ts_fidx, l);\n\t\t\t\tsp->ts_prewordlen += l;\n\t\t\t\tpreword[sp->ts_prewordlen] = NUL;\n\t\t\t    }\n\t\t\t    else\n\t\t\t\tsp->ts_score -= SCORE_SPLIT - SCORE_SUBST;\n\t\t\t    sp->ts_fidx += l;\n\t\t\t}\n\n\t\t\t// When compounding include compound flag in\n\t\t\t// compflags[] (already set above).  When splitting we\n\t\t\t// may start compounding over again.\n\t\t\tif (try_compound)\n\t\t\t    ++sp->ts_complen;\n\t\t\telse\n\t\t\t    sp->ts_compsplit = sp->ts_complen;\n\t\t\tsp->ts_prefixdepth = PFD_NOPREFIX;\n\n\t\t\t// set su->su_badflags to the caps type at this\n\t\t\t// position\n\t\t\tif (has_mbyte)\n\t\t\t    n = nofold_len(fword, sp->ts_fidx, su->su_badptr);\n\t\t\telse\n\t\t\t    n = sp->ts_fidx;\n\t\t\tsu->su_badflags = badword_captype(su->su_badptr + n,\n\t\t\t\t\t       su->su_badptr + su->su_badlen);\n\n\t\t\t// Restart at top of the tree.\n\t\t\tsp->ts_arridx = 0;\n\n\t\t\t// If there are postponed prefixes, try these too.\n\t\t\tif (pbyts != NULL)\n\t\t\t{\n\t\t\t    byts = pbyts;\n\t\t\t    idxs = pidxs;\n\t\t\t    sp->ts_prefixdepth = PFD_PREFIXTREE;\n\t\t\t    PROF_STORE(sp->ts_state)\n\t\t\t    sp->ts_state = STATE_NOPREFIX;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    break;\n\n\tcase STATE_SPLITUNDO:\n\t    // Undo the changes done for word split or compound word.\n\t    su->su_badflags = sp->ts_save_badflags;\n\n\t    // Continue looking for NUL bytes.\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_START;\n\n\t    // In case we went into the prefix tree.\n\t    byts = fbyts;\n\t    idxs = fidxs;\n\t    break;\n\n\tcase STATE_ENDNUL:\n\t    // Past the NUL bytes in the node.\n\t    su->su_badflags = sp->ts_save_badflags;\n\t    if (fword[sp->ts_fidx] == NUL && sp->ts_tcharlen == 0)\n\t    {\n\t\t// The badword ends, can't use STATE_PLAIN.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_DEL;\n\t\tbreak;\n\t    }\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_PLAIN;\n\t    // FALLTHROUGH\n\n\tcase STATE_PLAIN:\n\t    // Go over all possible bytes at this node, add each to tword[]\n\t    // and use child node.  \"ts_curi\" is the index.\n\t    arridx = sp->ts_arridx;\n\t    if (sp->ts_curi > byts[arridx])\n\t    {\n\t\t// Done all bytes at this node, do next state.  When still at\n\t\t// already changed bytes skip the other tricks.\n\t\tPROF_STORE(sp->ts_state)\n\t\tif (sp->ts_fidx >= sp->ts_fidxtry)\n\t\t    sp->ts_state = STATE_DEL;\n\t\telse\n\t\t    sp->ts_state = STATE_FINAL;\n\t    }\n\t    else\n\t    {\n\t\tarridx += sp->ts_curi++;\n\t\tc = byts[arridx];\n\n\t\t// Normal byte, go one level deeper.  If it's not equal to the\n\t\t// byte in the bad word adjust the score.  But don't even try\n\t\t// when the byte was already changed.  And don't try when we\n\t\t// just deleted this byte, accepting it is always cheaper than\n\t\t// delete + substitute.\n\t\tif (c == fword[sp->ts_fidx]\n\t\t\t|| (sp->ts_tcharlen > 0 && sp->ts_isdiff != DIFF_NONE))\n\t\t    newscore = 0;\n\t\telse\n\t\t    newscore = SCORE_SUBST;\n\t\tif ((newscore == 0\n\t\t\t    || (sp->ts_fidx >= sp->ts_fidxtry\n\t\t\t\t&& ((sp->ts_flags & TSF_DIDDEL) == 0\n\t\t\t\t    || c != fword[sp->ts_delidx])))\n\t\t\t&& TRY_DEEPER(su, stack, depth, newscore))\n\t\t{\n\t\t    go_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\t\t    if (newscore > 0)\n\t\t\tsprintf(changename[depth], \"%.*s-%s: subst %c to %c\",\n\t\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\t\tfword[sp->ts_fidx], c);\n\t\t    else\n\t\t\tsprintf(changename[depth], \"%.*s-%s: accept %c\",\n\t\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\t\tfword[sp->ts_fidx]);\n#endif\n\t\t    ++depth;\n\t\t    sp = &stack[depth];\n\t\t    ++sp->ts_fidx;\n\t\t    tword[sp->ts_twordlen++] = c;\n\t\t    sp->ts_arridx = idxs[arridx];\n\t\t    if (newscore == SCORE_SUBST)\n\t\t\tsp->ts_isdiff = DIFF_YES;\n\t\t    if (has_mbyte)\n\t\t    {\n\t\t\t// Multi-byte characters are a bit complicated to\n\t\t\t// handle: They differ when any of the bytes differ\n\t\t\t// and then their length may also differ.\n\t\t\tif (sp->ts_tcharlen == 0)\n\t\t\t{\n\t\t\t    // First byte.\n\t\t\t    sp->ts_tcharidx = 0;\n\t\t\t    sp->ts_tcharlen = MB_BYTE2LEN(c);\n\t\t\t    sp->ts_fcharstart = sp->ts_fidx - 1;\n\t\t\t    sp->ts_isdiff = (newscore != 0)\n\t\t\t\t\t\t       ? DIFF_YES : DIFF_NONE;\n\t\t\t}\n\t\t\telse if (sp->ts_isdiff == DIFF_INSERT)\n\t\t\t    // When inserting trail bytes don't advance in the\n\t\t\t    // bad word.\n\t\t\t    --sp->ts_fidx;\n\t\t\tif (++sp->ts_tcharidx == sp->ts_tcharlen)\n\t\t\t{\n\t\t\t    // Last byte of character.\n\t\t\t    if (sp->ts_isdiff == DIFF_YES)\n\t\t\t    {\n\t\t\t\t// Correct ts_fidx for the byte length of the\n\t\t\t\t// character (we didn't check that before).\n\t\t\t\tsp->ts_fidx = sp->ts_fcharstart\n\t\t\t\t\t    + mb_ptr2len(\n\t\t\t\t\t\t    fword + sp->ts_fcharstart);\n\t\t\t\t// For changing a composing character adjust\n\t\t\t\t// the score from SCORE_SUBST to\n\t\t\t\t// SCORE_SUBCOMP.\n\t\t\t\tif (enc_utf8\n\t\t\t\t\t&& utf_iscomposing(\n\t\t\t\t\t    utf_ptr2char(tword\n\t\t\t\t\t\t+ sp->ts_twordlen\n\t\t\t\t\t\t\t   - sp->ts_tcharlen))\n\t\t\t\t\t&& utf_iscomposing(\n\t\t\t\t\t    utf_ptr2char(fword\n\t\t\t\t\t\t\t+ sp->ts_fcharstart)))\n\t\t\t\t    sp->ts_score -=\n\t\t\t\t\t\t  SCORE_SUBST - SCORE_SUBCOMP;\n\n\t\t\t\t// For a similar character adjust score from\n\t\t\t\t// SCORE_SUBST to SCORE_SIMILAR.\n\t\t\t\telse if (!soundfold\n\t\t\t\t\t&& slang->sl_has_map\n\t\t\t\t\t&& similar_chars(slang,\n\t\t\t\t\t    mb_ptr2char(tword\n\t\t\t\t\t\t+ sp->ts_twordlen\n\t\t\t\t\t\t\t   - sp->ts_tcharlen),\n\t\t\t\t\t    mb_ptr2char(fword\n\t\t\t\t\t\t\t+ sp->ts_fcharstart)))\n\t\t\t\t    sp->ts_score -=\n\t\t\t\t\t\t  SCORE_SUBST - SCORE_SIMILAR;\n\t\t\t    }\n\t\t\t    else if (sp->ts_isdiff == DIFF_INSERT\n\t\t\t\t\t && sp->ts_twordlen > sp->ts_tcharlen)\n\t\t\t    {\n\t\t\t\tp = tword + sp->ts_twordlen - sp->ts_tcharlen;\n\t\t\t\tc = mb_ptr2char(p);\n\t\t\t\tif (enc_utf8 && utf_iscomposing(c))\n\t\t\t\t{\n\t\t\t\t    // Inserting a composing char doesn't\n\t\t\t\t    // count that much.\n\t\t\t\t    sp->ts_score -= SCORE_INS - SCORE_INSCOMP;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t    // If the previous character was the same,\n\t\t\t\t    // thus doubling a character, give a bonus\n\t\t\t\t    // to the score.  Also for the soundfold\n\t\t\t\t    // tree (might seem illogical but does\n\t\t\t\t    // give better scores).\n\t\t\t\t    MB_PTR_BACK(tword, p);\n\t\t\t\t    if (c == mb_ptr2char(p))\n\t\t\t\t\tsp->ts_score -= SCORE_INS\n\t\t\t\t\t\t\t       - SCORE_INSDUP;\n\t\t\t\t}\n\t\t\t    }\n\n\t\t\t    // Starting a new char, reset the length.\n\t\t\t    sp->ts_tcharlen = 0;\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// If we found a similar char adjust the score.\n\t\t\t// We do this after calling go_deeper() because\n\t\t\t// it's slow.\n\t\t\tif (newscore != 0\n\t\t\t\t&& !soundfold\n\t\t\t\t&& slang->sl_has_map\n\t\t\t\t&& similar_chars(slang,\n\t\t\t\t\t\t   c, fword[sp->ts_fidx - 1]))\n\t\t\t    sp->ts_score -= SCORE_SUBST - SCORE_SIMILAR;\n\t\t    }\n\t\t}\n\t    }\n\t    break;\n\n\tcase STATE_DEL:\n\t    // When past the first byte of a multi-byte char don't try\n\t    // delete/insert/swap a character.\n\t    if (has_mbyte && sp->ts_tcharlen > 0)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t\tbreak;\n\t    }\n\t    // Try skipping one character in the bad word (delete it).\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_INS_PREP;\n\t    sp->ts_curi = 1;\n\t    if (soundfold && sp->ts_fidx == 0 && fword[sp->ts_fidx] == '*')\n\t\t// Deleting a vowel at the start of a word counts less, see\n\t\t// soundalike_score().\n\t\tnewscore = 2 * SCORE_DEL / 3;\n\t    else\n\t\tnewscore = SCORE_DEL;\n\t    if (fword[sp->ts_fidx] != NUL\n\t\t\t\t    && TRY_DEEPER(su, stack, depth, newscore))\n\t    {\n\t\tgo_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth], \"%.*s-%s: delete %c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tfword[sp->ts_fidx]);\n#endif\n\t\t++depth;\n\n\t\t// Remember what character we deleted, so that we can avoid\n\t\t// inserting it again.\n\t\tstack[depth].ts_flags |= TSF_DIDDEL;\n\t\tstack[depth].ts_delidx = sp->ts_fidx;\n\n\t\t// Advance over the character in fword[].  Give a bonus to the\n\t\t// score if the same character is following \"nn\" -> \"n\".  It's\n\t\t// a bit illogical for soundfold tree but it does give better\n\t\t// results.\n\t\tif (has_mbyte)\n\t\t{\n\t\t    c = mb_ptr2char(fword + sp->ts_fidx);\n\t\t    stack[depth].ts_fidx += mb_ptr2len(fword + sp->ts_fidx);\n\t\t    if (enc_utf8 && utf_iscomposing(c))\n\t\t\tstack[depth].ts_score -= SCORE_DEL - SCORE_DELCOMP;\n\t\t    else if (c == mb_ptr2char(fword + stack[depth].ts_fidx))\n\t\t\tstack[depth].ts_score -= SCORE_DEL - SCORE_DELDUP;\n\t\t}\n\t\telse\n\t\t{\n\t\t    ++stack[depth].ts_fidx;\n\t\t    if (fword[sp->ts_fidx] == fword[sp->ts_fidx + 1])\n\t\t\tstack[depth].ts_score -= SCORE_DEL - SCORE_DELDUP;\n\t\t}\n\t\tbreak;\n\t    }\n\t    // FALLTHROUGH\n\n\tcase STATE_INS_PREP:\n\t    if (sp->ts_flags & TSF_DIDDEL)\n\t    {\n\t\t// If we just deleted a byte then inserting won't make sense,\n\t\t// a substitute is always cheaper.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_SWAP;\n\t\tbreak;\n\t    }\n\n\t    // skip over NUL bytes\n\t    n = sp->ts_arridx;\n\t    for (;;)\n\t    {\n\t\tif (sp->ts_curi > byts[n])\n\t\t{\n\t\t    // Only NUL bytes at this node, go to next state.\n\t\t    PROF_STORE(sp->ts_state)\n\t\t    sp->ts_state = STATE_SWAP;\n\t\t    break;\n\t\t}\n\t\tif (byts[n + sp->ts_curi] != NUL)\n\t\t{\n\t\t    // Found a byte to insert.\n\t\t    PROF_STORE(sp->ts_state)\n\t\t    sp->ts_state = STATE_INS;\n\t\t    break;\n\t\t}\n\t\t++sp->ts_curi;\n\t    }\n\t    break;\n\n\t    // FALLTHROUGH\n\n\tcase STATE_INS:\n\t    // Insert one byte.  Repeat this for each possible byte at this\n\t    // node.\n\t    n = sp->ts_arridx;\n\t    if (sp->ts_curi > byts[n])\n\t    {\n\t\t// Done all bytes at this node, go to next state.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_SWAP;\n\t\tbreak;\n\t    }\n\n\t    // Do one more byte at this node, but:\n\t    // - Skip NUL bytes.\n\t    // - Skip the byte if it's equal to the byte in the word,\n\t    //   accepting that byte is always better.\n\t    n += sp->ts_curi++;\n\t    c = byts[n];\n\t    if (soundfold && sp->ts_twordlen == 0 && c == '*')\n\t\t// Inserting a vowel at the start of a word counts less,\n\t\t// see soundalike_score().\n\t\tnewscore = 2 * SCORE_INS / 3;\n\t    else\n\t\tnewscore = SCORE_INS;\n\t    if (c != fword[sp->ts_fidx]\n\t\t\t\t    && TRY_DEEPER(su, stack, depth, newscore))\n\t    {\n\t\tgo_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth], \"%.*s-%s: insert %c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tc);\n#endif\n\t\t++depth;\n\t\tsp = &stack[depth];\n\t\ttword[sp->ts_twordlen++] = c;\n\t\tsp->ts_arridx = idxs[n];\n\t\tif (has_mbyte)\n\t\t{\n\t\t    fl = MB_BYTE2LEN(c);\n\t\t    if (fl > 1)\n\t\t    {\n\t\t\t// There are following bytes for the same character.\n\t\t\t// We must find all bytes before trying\n\t\t\t// delete/insert/swap/etc.\n\t\t\tsp->ts_tcharlen = fl;\n\t\t\tsp->ts_tcharidx = 1;\n\t\t\tsp->ts_isdiff = DIFF_INSERT;\n\t\t    }\n\t\t}\n\t\telse\n\t\t    fl = 1;\n\t\tif (fl == 1)\n\t\t{\n\t\t    // If the previous character was the same, thus doubling a\n\t\t    // character, give a bonus to the score.  Also for\n\t\t    // soundfold words (illogical but does give a better\n\t\t    // score).\n\t\t    if (sp->ts_twordlen >= 2\n\t\t\t\t\t   && tword[sp->ts_twordlen - 2] == c)\n\t\t\tsp->ts_score -= SCORE_INS - SCORE_INSDUP;\n\t\t}\n\t    }\n\t    break;\n\n\tcase STATE_SWAP:\n\t    // Swap two bytes in the bad word: \"12\" -> \"21\".\n\t    // We change \"fword\" here, it's changed back afterwards at\n\t    // STATE_UNSWAP.\n\t    p = fword + sp->ts_fidx;\n\t    c = *p;\n\t    if (c == NUL)\n\t    {\n\t\t// End of word, can't swap or replace.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t\tbreak;\n\t    }\n\n\t    // Don't swap if the first character is not a word character.\n\t    // SWAP3 etc. also don't make sense then.\n\t    if (!soundfold && !spell_iswordp(p, curwin))\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t\tbreak;\n\t    }\n\n\t    if (has_mbyte)\n\t    {\n\t\tn = MB_CPTR2LEN(p);\n\t\tc = mb_ptr2char(p);\n\t\tif (p[n] == NUL)\n\t\t    c2 = NUL;\n\t\telse if (!soundfold && !spell_iswordp(p + n, curwin))\n\t\t    c2 = c; // don't swap non-word char\n\t\telse\n\t\t    c2 = mb_ptr2char(p + n);\n\t    }\n\t    else\n\t    {\n\t\tif (p[1] == NUL)\n\t\t    c2 = NUL;\n\t\telse if (!soundfold && !spell_iswordp(p + 1, curwin))\n\t\t    c2 = c; // don't swap non-word char\n\t\telse\n\t\t    c2 = p[1];\n\t    }\n\n\t    // When the second character is NUL we can't swap.\n\t    if (c2 == NUL)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t\tbreak;\n\t    }\n\n\t    // When characters are identical, swap won't do anything.\n\t    // Also get here if the second char is not a word character.\n\t    if (c == c2)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_SWAP3;\n\t\tbreak;\n\t    }\n\t    if (c2 != NUL && TRY_DEEPER(su, stack, depth, SCORE_SWAP))\n\t    {\n\t\tgo_deeper(stack, depth, SCORE_SWAP);\n#ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth], \"%.*s-%s: swap %c and %c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tc, c2);\n#endif\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_UNSWAP;\n\t\t++depth;\n\t\tif (has_mbyte)\n\t\t{\n\t\t    fl = mb_char2len(c2);\n\t\t    mch_memmove(p, p + n, fl);\n\t\t    mb_char2bytes(c, p + fl);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + n + fl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    p[0] = c2;\n\t\t    p[1] = c;\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + 2;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// If this swap doesn't work then SWAP3 won't either.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t    }\n\t    break;\n\n\tcase STATE_UNSWAP:\n\t    // Undo the STATE_SWAP swap: \"21\" -> \"12\".\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tn = mb_ptr2len(p);\n\t\tc = mb_ptr2char(p + n);\n\t\tmch_memmove(p + mb_ptr2len(p + n), p, n);\n\t\tmb_char2bytes(c, p);\n\t    }\n\t    else\n\t    {\n\t\tc = *p;\n\t\t*p = p[1];\n\t\tp[1] = c;\n\t    }\n\t    // FALLTHROUGH\n\n\tcase STATE_SWAP3:\n\t    // Swap two bytes, skipping one: \"123\" -> \"321\".  We change\n\t    // \"fword\" here, it's changed back afterwards at STATE_UNSWAP3.\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tn = MB_CPTR2LEN(p);\n\t\tc = mb_ptr2char(p);\n\t\tfl = MB_CPTR2LEN(p + n);\n\t\tc2 = mb_ptr2char(p + n);\n\t\tif (!soundfold && !spell_iswordp(p + n + fl, curwin))\n\t\t    c3 = c;\t// don't swap non-word char\n\t\telse\n\t\t    c3 = mb_ptr2char(p + n + fl);\n\t    }\n\t    else\n\t    {\n\t\tc = *p;\n\t\tc2 = p[1];\n\t\tif (!soundfold && !spell_iswordp(p + 2, curwin))\n\t\t    c3 = c;\t// don't swap non-word char\n\t\telse\n\t\t    c3 = p[2];\n\t    }\n\n\t    // When characters are identical: \"121\" then SWAP3 result is\n\t    // identical, ROT3L result is same as SWAP: \"211\", ROT3L result is\n\t    // same as SWAP on next char: \"112\".  Thus skip all swapping.\n\t    // Also skip when c3 is NUL.\n\t    // Also get here when the third character is not a word character.\n\t    // Second character may any char: \"a.b\" -> \"b.a\"\n\t    if (c == c3 || c3 == NUL)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t\tbreak;\n\t    }\n\t    if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3))\n\t    {\n\t\tgo_deeper(stack, depth, SCORE_SWAP3);\n#ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth], \"%.*s-%s: swap3 %c and %c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tc, c3);\n#endif\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_UNSWAP3;\n\t\t++depth;\n\t\tif (has_mbyte)\n\t\t{\n\t\t    tl = mb_char2len(c3);\n\t\t    mch_memmove(p, p + n + fl, tl);\n\t\t    mb_char2bytes(c2, p + tl);\n\t\t    mb_char2bytes(c, p + fl + tl);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + n + fl + tl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    p[0] = p[2];\n\t\t    p[2] = c;\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + 3;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t    }\n\t    break;\n\n\tcase STATE_UNSWAP3:\n\t    // Undo STATE_SWAP3: \"321\" -> \"123\"\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tn = mb_ptr2len(p);\n\t\tc2 = mb_ptr2char(p + n);\n\t\tfl = mb_ptr2len(p + n);\n\t\tc = mb_ptr2char(p + n + fl);\n\t\ttl = mb_ptr2len(p + n + fl);\n\t\tmch_memmove(p + fl + tl, p, n);\n\t\tmb_char2bytes(c, p);\n\t\tmb_char2bytes(c2, p + tl);\n\t\tp = p + tl;\n\t    }\n\t    else\n\t    {\n\t\tc = *p;\n\t\t*p = p[2];\n\t\tp[2] = c;\n\t\t++p;\n\t    }\n\n\t    if (!soundfold && !spell_iswordp(p, curwin))\n\t    {\n\t\t// Middle char is not a word char, skip the rotate.  First and\n\t\t// third char were already checked at swap and swap3.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t\tbreak;\n\t    }\n\n\t    // Rotate three characters left: \"123\" -> \"231\".  We change\n\t    // \"fword\" here, it's changed back afterwards at STATE_UNROT3L.\n\t    if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3))\n\t    {\n\t\tgo_deeper(stack, depth, SCORE_SWAP3);\n#ifdef DEBUG_TRIEWALK\n\t\tp = fword + sp->ts_fidx;\n\t\tsprintf(changename[depth], \"%.*s-%s: rotate left %c%c%c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tp[0], p[1], p[2]);\n#endif\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_UNROT3L;\n\t\t++depth;\n\t\tp = fword + sp->ts_fidx;\n\t\tif (has_mbyte)\n\t\t{\n\t\t    n = MB_CPTR2LEN(p);\n\t\t    c = mb_ptr2char(p);\n\t\t    fl = MB_CPTR2LEN(p + n);\n\t\t    fl += MB_CPTR2LEN(p + n + fl);\n\t\t    mch_memmove(p, p + n, fl);\n\t\t    mb_char2bytes(c, p + fl);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + n + fl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    c = *p;\n\t\t    *p = p[1];\n\t\t    p[1] = p[2];\n\t\t    p[2] = c;\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + 3;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t    }\n\t    break;\n\n\tcase STATE_UNROT3L:\n\t    // Undo ROT3L: \"231\" -> \"123\"\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tn = mb_ptr2len(p);\n\t\tn += mb_ptr2len(p + n);\n\t\tc = mb_ptr2char(p + n);\n\t\ttl = mb_ptr2len(p + n);\n\t\tmch_memmove(p + tl, p, n);\n\t\tmb_char2bytes(c, p);\n\t    }\n\t    else\n\t    {\n\t\tc = p[2];\n\t\tp[2] = p[1];\n\t\tp[1] = *p;\n\t\t*p = c;\n\t    }\n\n\t    // Rotate three bytes right: \"123\" -> \"312\".  We change \"fword\"\n\t    // here, it's changed back afterwards at STATE_UNROT3R.\n\t    if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3))\n\t    {\n\t\tgo_deeper(stack, depth, SCORE_SWAP3);\n#ifdef DEBUG_TRIEWALK\n\t\tp = fword + sp->ts_fidx;\n\t\tsprintf(changename[depth], \"%.*s-%s: rotate right %c%c%c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tp[0], p[1], p[2]);\n#endif\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_UNROT3R;\n\t\t++depth;\n\t\tp = fword + sp->ts_fidx;\n\t\tif (has_mbyte)\n\t\t{\n\t\t    n = MB_CPTR2LEN(p);\n\t\t    n += MB_CPTR2LEN(p + n);\n\t\t    c = mb_ptr2char(p + n);\n\t\t    tl = MB_CPTR2LEN(p + n);\n\t\t    mch_memmove(p + tl, p, n);\n\t\t    mb_char2bytes(c, p);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + n + tl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    c = p[2];\n\t\t    p[2] = p[1];\n\t\t    p[1] = *p;\n\t\t    *p = c;\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + 3;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t    }\n\t    break;\n\n\tcase STATE_UNROT3R:\n\t    // Undo ROT3R: \"312\" -> \"123\"\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tc = mb_ptr2char(p);\n\t\ttl = mb_ptr2len(p);\n\t\tn = mb_ptr2len(p + tl);\n\t\tn += mb_ptr2len(p + tl + n);\n\t\tmch_memmove(p, p + tl, n);\n\t\tmb_char2bytes(c, p + n);\n\t    }\n\t    else\n\t    {\n\t\tc = *p;\n\t\t*p = p[1];\n\t\tp[1] = p[2];\n\t\tp[2] = c;\n\t    }\n\t    // FALLTHROUGH\n\n\tcase STATE_REP_INI:\n\t    // Check if matching with REP items from the .aff file would work.\n\t    // Quickly skip if:\n\t    // - there are no REP items and we are not in the soundfold trie\n\t    // - the score is going to be too high anyway\n\t    // - already applied a REP item or swapped here\n\t    if ((lp->lp_replang == NULL && !soundfold)\n\t\t    || sp->ts_score + SCORE_REP >= su->su_maxscore\n\t\t    || sp->ts_fidx < sp->ts_fidxtry)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t\tbreak;\n\t    }\n\n\t    // Use the first byte to quickly find the first entry that may\n\t    // match.  If the index is -1 there is none.\n\t    if (soundfold)\n\t\tsp->ts_curi = slang->sl_repsal_first[fword[sp->ts_fidx]];\n\t    else\n\t\tsp->ts_curi = lp->lp_replang->sl_rep_first[fword[sp->ts_fidx]];\n\n\t    if (sp->ts_curi < 0)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t\tbreak;\n\t    }\n\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_REP;\n\t    // FALLTHROUGH\n\n\tcase STATE_REP:\n\t    // Try matching with REP items from the .aff file.  For each match\n\t    // replace the characters and check if the resulting word is\n\t    // valid.\n\t    p = fword + sp->ts_fidx;\n\n\t    if (soundfold)\n\t\tgap = &slang->sl_repsal;\n\t    else\n\t\tgap = &lp->lp_replang->sl_rep;\n\t    while (sp->ts_curi < gap->ga_len)\n\t    {\n\t\tftp = (fromto_T *)gap->ga_data + sp->ts_curi++;\n\t\tif (*ftp->ft_from != *p)\n\t\t{\n\t\t    // past possible matching entries\n\t\t    sp->ts_curi = gap->ga_len;\n\t\t    break;\n\t\t}\n\t\tif (STRNCMP(ftp->ft_from, p, STRLEN(ftp->ft_from)) == 0\n\t\t\t&& TRY_DEEPER(su, stack, depth, SCORE_REP))\n\t\t{\n\t\t    go_deeper(stack, depth, SCORE_REP);\n#ifdef DEBUG_TRIEWALK\n\t\t    sprintf(changename[depth], \"%.*s-%s: replace %s with %s\",\n\t\t\t    sp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\t    ftp->ft_from, ftp->ft_to);\n#endif\n\t\t    // Need to undo this afterwards.\n\t\t    PROF_STORE(sp->ts_state)\n\t\t    sp->ts_state = STATE_REP_UNDO;\n\n\t\t    // Change the \"from\" to the \"to\" string.\n\t\t    ++depth;\n\t\t    fl = (int)STRLEN(ftp->ft_from);\n\t\t    tl = (int)STRLEN(ftp->ft_to);\n\t\t    if (fl != tl)\n\t\t    {\n\t\t\tSTRMOVE(p + tl, p + fl);\n\t\t\trepextra += tl - fl;\n\t\t    }\n\t\t    mch_memmove(p, ftp->ft_to, tl);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + tl;\n\t\t    stack[depth].ts_tcharlen = 0;\n\t\t    break;\n\t\t}\n\t    }\n\n\t    if (sp->ts_curi >= gap->ga_len && sp->ts_state == STATE_REP)\n\t    {\n\t\t// No (more) matches.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t    }\n\n\t    break;\n\n\tcase STATE_REP_UNDO:\n\t    // Undo a REP replacement and continue with the next one.\n\t    if (soundfold)\n\t\tgap = &slang->sl_repsal;\n\t    else\n\t\tgap = &lp->lp_replang->sl_rep;\n\t    ftp = (fromto_T *)gap->ga_data + sp->ts_curi - 1;\n\t    fl = (int)STRLEN(ftp->ft_from);\n\t    tl = (int)STRLEN(ftp->ft_to);\n\t    p = fword + sp->ts_fidx;\n\t    if (fl != tl)\n\t    {\n\t\tSTRMOVE(p + fl, p + tl);\n\t\trepextra -= tl - fl;\n\t    }\n\t    mch_memmove(p, ftp->ft_from, fl);\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_REP;\n\t    break;\n\n\tdefault:\n\t    // Did all possible states at this level, go up one level.\n\t    --depth;\n\n\t    if (depth >= 0 && stack[depth].ts_prefixdepth == PFD_PREFIXTREE)\n\t    {\n\t\t// Continue in or go back to the prefix tree.\n\t\tbyts = pbyts;\n\t\tidxs = pidxs;\n\t    }\n\n\t    // Don't check for CTRL-C too often, it takes time.\n\t    if (--breakcheckcount == 0)\n\t    {\n\t\tui_breakcheck();\n\t\tbreakcheckcount = 1000;\n\t    }\n\t}\n    }\n}\n\n\n/*\n * Go one level deeper in the tree.\n */\n    static void\ngo_deeper(trystate_T *stack, int depth, int score_add)\n{\n    stack[depth + 1] = stack[depth];\n    stack[depth + 1].ts_state = STATE_START;\n    stack[depth + 1].ts_score = stack[depth].ts_score + score_add;\n    stack[depth + 1].ts_curi = 1;\t// start just after length byte\n    stack[depth + 1].ts_flags = 0;\n}\n\n/*\n * \"fword\" is a good word with case folded.  Find the matching keep-case\n * words and put it in \"kword\".\n * Theoretically there could be several keep-case words that result in the\n * same case-folded word, but we only find one...\n */\n    static void\nfind_keepcap_word(slang_T *slang, char_u *fword, char_u *kword)\n{\n    char_u\tuword[MAXWLEN];\t\t// \"fword\" in upper-case\n    int\t\tdepth;\n    idx_T\ttryidx;\n\n    // The following arrays are used at each depth in the tree.\n    idx_T\tarridx[MAXWLEN];\n    int\t\tround[MAXWLEN];\n    int\t\tfwordidx[MAXWLEN];\n    int\t\tuwordidx[MAXWLEN];\n    int\t\tkwordlen[MAXWLEN];\n\n    int\t\tflen, ulen;\n    int\t\tl;\n    int\t\tlen;\n    int\t\tc;\n    idx_T\tlo, hi, m;\n    char_u\t*p;\n    char_u\t*byts = slang->sl_kbyts;    // array with bytes of the words\n    idx_T\t*idxs = slang->sl_kidxs;    // array with indexes\n\n    if (byts == NULL)\n    {\n\t// array is empty: \"cannot happen\"\n\t*kword = NUL;\n\treturn;\n    }\n\n    // Make an all-cap version of \"fword\".\n    allcap_copy(fword, uword);\n\n    // Each character needs to be tried both case-folded and upper-case.\n    // All this gets very complicated if we keep in mind that changing case\n    // may change the byte length of a multi-byte character...\n    depth = 0;\n    arridx[0] = 0;\n    round[0] = 0;\n    fwordidx[0] = 0;\n    uwordidx[0] = 0;\n    kwordlen[0] = 0;\n    while (depth >= 0)\n    {\n\tif (fword[fwordidx[depth]] == NUL)\n\t{\n\t    // We are at the end of \"fword\".  If the tree allows a word to end\n\t    // here we have found a match.\n\t    if (byts[arridx[depth] + 1] == 0)\n\t    {\n\t\tkword[kwordlen[depth]] = NUL;\n\t\treturn;\n\t    }\n\n\t    // kword is getting too long, continue one level up\n\t    --depth;\n\t}\n\telse if (++round[depth] > 2)\n\t{\n\t    // tried both fold-case and upper-case character, continue one\n\t    // level up\n\t    --depth;\n\t}\n\telse\n\t{\n\t    // round[depth] == 1: Try using the folded-case character.\n\t    // round[depth] == 2: Try using the upper-case character.\n\t    if (has_mbyte)\n\t    {\n\t\tflen = MB_CPTR2LEN(fword + fwordidx[depth]);\n\t\tulen = MB_CPTR2LEN(uword + uwordidx[depth]);\n\t    }\n\t    else\n\t\tulen = flen = 1;\n\t    if (round[depth] == 1)\n\t    {\n\t\tp = fword + fwordidx[depth];\n\t\tl = flen;\n\t    }\n\t    else\n\t    {\n\t\tp = uword + uwordidx[depth];\n\t\tl = ulen;\n\t    }\n\n\t    for (tryidx = arridx[depth]; l > 0; --l)\n\t    {\n\t\t// Perform a binary search in the list of accepted bytes.\n\t\tlen = byts[tryidx++];\n\t\tc = *p++;\n\t\tlo = tryidx;\n\t\thi = tryidx + len - 1;\n\t\twhile (lo < hi)\n\t\t{\n\t\t    m = (lo + hi) / 2;\n\t\t    if (byts[m] > c)\n\t\t\thi = m - 1;\n\t\t    else if (byts[m] < c)\n\t\t\tlo = m + 1;\n\t\t    else\n\t\t    {\n\t\t\tlo = hi = m;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\n\t\t// Stop if there is no matching byte.\n\t\tif (hi < lo || byts[lo] != c)\n\t\t    break;\n\n\t\t// Continue at the child (if there is one).\n\t\ttryidx = idxs[lo];\n\t    }\n\n\t    if (l == 0)\n\t    {\n\t\t// Found the matching char.  Copy it to \"kword\" and go a\n\t\t// level deeper.\n\t\tif (round[depth] == 1)\n\t\t{\n\t\t    STRNCPY(kword + kwordlen[depth], fword + fwordidx[depth],\n\t\t\t\t\t\t\t\t\tflen);\n\t\t    kwordlen[depth + 1] = kwordlen[depth] + flen;\n\t\t}\n\t\telse\n\t\t{\n\t\t    STRNCPY(kword + kwordlen[depth], uword + uwordidx[depth],\n\t\t\t\t\t\t\t\t\tulen);\n\t\t    kwordlen[depth + 1] = kwordlen[depth] + ulen;\n\t\t}\n\t\tfwordidx[depth + 1] = fwordidx[depth] + flen;\n\t\tuwordidx[depth + 1] = uwordidx[depth] + ulen;\n\n\t\t++depth;\n\t\tarridx[depth] = tryidx;\n\t\tround[depth] = 0;\n\t    }\n\t}\n    }\n\n    // Didn't find it: \"cannot happen\".\n    *kword = NUL;\n}\n\n/*\n * Compute the sound-a-like score for suggestions in su->su_ga and add them to\n * su->su_sga.\n */\n    static void\nscore_comp_sal(suginfo_T *su)\n{\n    langp_T\t*lp;\n    char_u\tbadsound[MAXWLEN];\n    int\t\ti;\n    suggest_T   *stp;\n    suggest_T   *sstp;\n    int\t\tscore;\n    int\t\tlpi;\n\n    if (ga_grow(&su->su_sga, su->su_ga.ga_len) == FAIL)\n\treturn;\n\n    // Use the sound-folding of the first language that supports it.\n    for (lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi)\n    {\n\tlp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);\n\tif (lp->lp_slang->sl_sal.ga_len > 0)\n\t{\n\t    // soundfold the bad word\n\t    spell_soundfold(lp->lp_slang, su->su_fbadword, TRUE, badsound);\n\n\t    for (i = 0; i < su->su_ga.ga_len; ++i)\n\t    {\n\t\tstp = &SUG(su->su_ga, i);\n\n\t\t// Case-fold the suggested word, sound-fold it and compute the\n\t\t// sound-a-like score.\n\t\tscore = stp_sal_score(stp, su, lp->lp_slang, badsound);\n\t\tif (score < SCORE_MAXMAX)\n\t\t{\n\t\t    // Add the suggestion.\n\t\t    sstp = &SUG(su->su_sga, su->su_sga.ga_len);\n\t\t    sstp->st_word = vim_strsave(stp->st_word);\n\t\t    if (sstp->st_word != NULL)\n\t\t    {\n\t\t\tsstp->st_wordlen = stp->st_wordlen;\n\t\t\tsstp->st_score = score;\n\t\t\tsstp->st_altscore = 0;\n\t\t\tsstp->st_orglen = stp->st_orglen;\n\t\t\t++su->su_sga.ga_len;\n\t\t    }\n\t\t}\n\t    }\n\t    break;\n\t}\n    }\n}\n\n/*\n * Combine the list of suggestions in su->su_ga and su->su_sga.\n * They are entwined.\n */\n    static void\nscore_combine(suginfo_T *su)\n{\n    int\t\ti;\n    int\t\tj;\n    garray_T\tga;\n    garray_T\t*gap;\n    langp_T\t*lp;\n    suggest_T\t*stp;\n    char_u\t*p;\n    char_u\tbadsound[MAXWLEN];\n    int\t\tround;\n    int\t\tlpi;\n    slang_T\t*slang = NULL;\n\n    // Add the alternate score to su_ga.\n    for (lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi)\n    {\n\tlp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);\n\tif (lp->lp_slang->sl_sal.ga_len > 0)\n\t{\n\t    // soundfold the bad word\n\t    slang = lp->lp_slang;\n\t    spell_soundfold(slang, su->su_fbadword, TRUE, badsound);\n\n\t    for (i = 0; i < su->su_ga.ga_len; ++i)\n\t    {\n\t\tstp = &SUG(su->su_ga, i);\n\t\tstp->st_altscore = stp_sal_score(stp, su, slang, badsound);\n\t\tif (stp->st_altscore == SCORE_MAXMAX)\n\t\t    stp->st_score = (stp->st_score * 3 + SCORE_BIG) / 4;\n\t\telse\n\t\t    stp->st_score = (stp->st_score * 3\n\t\t\t\t\t\t  + stp->st_altscore) / 4;\n\t\tstp->st_salscore = FALSE;\n\t    }\n\t    break;\n\t}\n    }\n\n    if (slang == NULL)\t// Using \"double\" without sound folding.\n    {\n\t(void)cleanup_suggestions(&su->su_ga, su->su_maxscore,\n\t\t\t\t\t\t\t     su->su_maxcount);\n\treturn;\n    }\n\n    // Add the alternate score to su_sga.\n    for (i = 0; i < su->su_sga.ga_len; ++i)\n    {\n\tstp = &SUG(su->su_sga, i);\n\tstp->st_altscore = spell_edit_score(slang,\n\t\t\t\t\t\tsu->su_badword, stp->st_word);\n\tif (stp->st_score == SCORE_MAXMAX)\n\t    stp->st_score = (SCORE_BIG * 7 + stp->st_altscore) / 8;\n\telse\n\t    stp->st_score = (stp->st_score * 7 + stp->st_altscore) / 8;\n\tstp->st_salscore = TRUE;\n    }\n\n    // Remove bad suggestions, sort the suggestions and truncate at \"maxcount\"\n    // for both lists.\n    check_suggestions(su, &su->su_ga);\n    (void)cleanup_suggestions(&su->su_ga, su->su_maxscore, su->su_maxcount);\n    check_suggestions(su, &su->su_sga);\n    (void)cleanup_suggestions(&su->su_sga, su->su_maxscore, su->su_maxcount);\n\n    ga_init2(&ga, sizeof(suginfo_T), 1);\n    if (ga_grow(&ga, su->su_ga.ga_len + su->su_sga.ga_len) == FAIL)\n\treturn;\n\n    stp = &SUG(ga, 0);\n    for (i = 0; i < su->su_ga.ga_len || i < su->su_sga.ga_len; ++i)\n    {\n\t// round 1: get a suggestion from su_ga\n\t// round 2: get a suggestion from su_sga\n\tfor (round = 1; round <= 2; ++round)\n\t{\n\t    gap = round == 1 ? &su->su_ga : &su->su_sga;\n\t    if (i < gap->ga_len)\n\t    {\n\t\t// Don't add a word if it's already there.\n\t\tp = SUG(*gap, i).st_word;\n\t\tfor (j = 0; j < ga.ga_len; ++j)\n\t\t    if (STRCMP(stp[j].st_word, p) == 0)\n\t\t\tbreak;\n\t\tif (j == ga.ga_len)\n\t\t    stp[ga.ga_len++] = SUG(*gap, i);\n\t\telse\n\t\t    vim_free(p);\n\t    }\n\t}\n    }\n\n    ga_clear(&su->su_ga);\n    ga_clear(&su->su_sga);\n\n    // Truncate the list to the number of suggestions that will be displayed.\n    if (ga.ga_len > su->su_maxcount)\n    {\n\tfor (i = su->su_maxcount; i < ga.ga_len; ++i)\n\t    vim_free(stp[i].st_word);\n\tga.ga_len = su->su_maxcount;\n    }\n\n    su->su_ga = ga;\n}\n\n/*\n * For the goodword in \"stp\" compute the soundalike score compared to the\n * badword.\n */\n    static int\nstp_sal_score(\n    suggest_T\t*stp,\n    suginfo_T\t*su,\n    slang_T\t*slang,\n    char_u\t*badsound)\t// sound-folded badword\n{\n    char_u\t*p;\n    char_u\t*pbad;\n    char_u\t*pgood;\n    char_u\tbadsound2[MAXWLEN];\n    char_u\tfword[MAXWLEN];\n    char_u\tgoodsound[MAXWLEN];\n    char_u\tgoodword[MAXWLEN];\n    int\t\tlendiff;\n\n    lendiff = (int)(su->su_badlen - stp->st_orglen);\n    if (lendiff >= 0)\n\tpbad = badsound;\n    else\n    {\n\t// soundfold the bad word with more characters following\n\t(void)spell_casefold(curwin,\n\t\t\t\tsu->su_badptr, stp->st_orglen, fword, MAXWLEN);\n\n\t// When joining two words the sound often changes a lot.  E.g., \"t he\"\n\t// sounds like \"t h\" while \"the\" sounds like \"@\".  Avoid that by\n\t// removing the space.  Don't do it when the good word also contains a\n\t// space.\n\tif (VIM_ISWHITE(su->su_badptr[su->su_badlen])\n\t\t\t\t\t && *skiptowhite(stp->st_word) == NUL)\n\t    for (p = fword; *(p = skiptowhite(p)) != NUL; )\n\t\tSTRMOVE(p, p + 1);\n\n\tspell_soundfold(slang, fword, TRUE, badsound2);\n\tpbad = badsound2;\n    }\n\n    if (lendiff > 0 && stp->st_wordlen + lendiff < MAXWLEN)\n    {\n\t// Add part of the bad word to the good word, so that we soundfold\n\t// what replaces the bad word.\n\tSTRCPY(goodword, stp->st_word);\n\tvim_strncpy(goodword + stp->st_wordlen,\n\t\t\t    su->su_badptr + su->su_badlen - lendiff, lendiff);\n\tpgood = goodword;\n    }\n    else\n\tpgood = stp->st_word;\n\n    // Sound-fold the word and compute the score for the difference.\n    spell_soundfold(slang, pgood, FALSE, goodsound);\n\n    return soundalike_score(goodsound, pbad);\n}\n\n// structure used to store soundfolded words that add_sound_suggest() has\n// handled already.\ntypedef struct\n{\n    short\tsft_score;\t// lowest score used\n    char_u\tsft_word[1];    // soundfolded word, actually longer\n} sftword_T;\n\nstatic sftword_T dumsft;\n#define HIKEY2SFT(p)  ((sftword_T *)(p - (dumsft.sft_word - (char_u *)&dumsft)))\n#define HI2SFT(hi)     HIKEY2SFT((hi)->hi_key)\n\n/*\n * Prepare for calling suggest_try_soundalike().\n */\n    static void\nsuggest_try_soundalike_prep(void)\n{\n    langp_T\t*lp;\n    int\t\tlpi;\n    slang_T\t*slang;\n\n    // Do this for all languages that support sound folding and for which a\n    // .sug file has been loaded.\n    for (lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi)\n    {\n\tlp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);\n\tslang = lp->lp_slang;\n\tif (slang->sl_sal.ga_len > 0 && slang->sl_sbyts != NULL)\n\t    // prepare the hashtable used by add_sound_suggest()\n\t    hash_init(&slang->sl_sounddone);\n    }\n}\n\n/*\n * Find suggestions by comparing the word in a sound-a-like form.\n * Note: This doesn't support postponed prefixes.\n */\n    static void\nsuggest_try_soundalike(suginfo_T *su)\n{\n    char_u\tsalword[MAXWLEN];\n    langp_T\t*lp;\n    int\t\tlpi;\n    slang_T\t*slang;\n\n    // Do this for all languages that support sound folding and for which a\n    // .sug file has been loaded.\n    for (lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi)\n    {\n\tlp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);\n\tslang = lp->lp_slang;\n\tif (slang->sl_sal.ga_len > 0 && slang->sl_sbyts != NULL)\n\t{\n\t    // soundfold the bad word\n\t    spell_soundfold(slang, su->su_fbadword, TRUE, salword);\n\n\t    // try all kinds of inserts/deletes/swaps/etc.\n\t    // TODO: also soundfold the next words, so that we can try joining\n\t    // and splitting\n#ifdef SUGGEST_PROFILE\n\tprof_init();\n#endif\n\t    suggest_trie_walk(su, lp, salword, TRUE);\n#ifdef SUGGEST_PROFILE\n\tprof_report(\"soundalike\");\n#endif\n\t}\n    }\n}\n\n/*\n * Finish up after calling suggest_try_soundalike().\n */\n    static void\nsuggest_try_soundalike_finish(void)\n{\n    langp_T\t*lp;\n    int\t\tlpi;\n    slang_T\t*slang;\n    int\t\ttodo;\n    hashitem_T\t*hi;\n\n    // Do this for all languages that support sound folding and for which a\n    // .sug file has been loaded.\n    for (lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi)\n    {\n\tlp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);\n\tslang = lp->lp_slang;\n\tif (slang->sl_sal.ga_len > 0 && slang->sl_sbyts != NULL)\n\t{\n\t    // Free the info about handled words.\n\t    todo = (int)slang->sl_sounddone.ht_used;\n\t    for (hi = slang->sl_sounddone.ht_array; todo > 0; ++hi)\n\t\tif (!HASHITEM_EMPTY(hi))\n\t\t{\n\t\t    vim_free(HI2SFT(hi));\n\t\t    --todo;\n\t\t}\n\n\t    // Clear the hashtable, it may also be used by another region.\n\t    hash_clear(&slang->sl_sounddone);\n\t    hash_init(&slang->sl_sounddone);\n\t}\n    }\n}\n\n/*\n * A match with a soundfolded word is found.  Add the good word(s) that\n * produce this soundfolded word.\n */\n    static void\nadd_sound_suggest(\n    suginfo_T\t*su,\n    char_u\t*goodword,\n    int\t\tscore,\t\t// soundfold score\n    langp_T\t*lp)\n{\n    slang_T\t*slang = lp->lp_slang;\t// language for sound folding\n    int\t\tsfwordnr;\n    char_u\t*nrline;\n    int\t\torgnr;\n    char_u\ttheword[MAXWLEN];\n    int\t\ti;\n    int\t\twlen;\n    char_u\t*byts;\n    idx_T\t*idxs;\n    int\t\tn;\n    int\t\twordcount;\n    int\t\twc;\n    int\t\tgoodscore;\n    hash_T\thash;\n    hashitem_T  *hi;\n    sftword_T\t*sft;\n    int\t\tbc, gc;\n    int\t\tlimit;\n\n    // It's very well possible that the same soundfold word is found several\n    // times with different scores.  Since the following is quite slow only do\n    // the words that have a better score than before.  Use a hashtable to\n    // remember the words that have been done.\n    hash = hash_hash(goodword);\n    hi = hash_lookup(&slang->sl_sounddone, goodword, hash);\n    if (HASHITEM_EMPTY(hi))\n    {\n\tsft = alloc(sizeof(sftword_T) + STRLEN(goodword));\n\tif (sft != NULL)\n\t{\n\t    sft->sft_score = score;\n\t    STRCPY(sft->sft_word, goodword);\n\t    hash_add_item(&slang->sl_sounddone, hi, sft->sft_word, hash);\n\t}\n    }\n    else\n    {\n\tsft = HI2SFT(hi);\n\tif (score >= sft->sft_score)\n\t    return;\n\tsft->sft_score = score;\n    }\n\n    // Find the word nr in the soundfold tree.\n    sfwordnr = soundfold_find(slang, goodword);\n    if (sfwordnr < 0)\n    {\n\tinternal_error(\"add_sound_suggest()\");\n\treturn;\n    }\n\n    // go over the list of good words that produce this soundfold word\n    nrline = ml_get_buf(slang->sl_sugbuf, (linenr_T)(sfwordnr + 1), FALSE);\n    orgnr = 0;\n    while (*nrline != NUL)\n    {\n\t// The wordnr was stored in a minimal nr of bytes as an offset to the\n\t// previous wordnr.\n\torgnr += bytes2offset(&nrline);\n\n\tbyts = slang->sl_fbyts;\n\tidxs = slang->sl_fidxs;\n\n\t// Lookup the word \"orgnr\" one of the two tries.\n\tn = 0;\n\twordcount = 0;\n\tfor (wlen = 0; wlen < MAXWLEN - 3; ++wlen)\n\t{\n\t    i = 1;\n\t    if (wordcount == orgnr && byts[n + 1] == NUL)\n\t\tbreak;\t// found end of word\n\n\t    if (byts[n + 1] == NUL)\n\t\t++wordcount;\n\n\t    // skip over the NUL bytes\n\t    for ( ; byts[n + i] == NUL; ++i)\n\t\tif (i > byts[n])\t// safety check\n\t\t{\n\t\t    STRCPY(theword + wlen, \"BAD\");\n\t\t    wlen += 3;\n\t\t    goto badword;\n\t\t}\n\n\t    // One of the siblings must have the word.\n\t    for ( ; i < byts[n]; ++i)\n\t    {\n\t\twc = idxs[idxs[n + i]];\t// nr of words under this byte\n\t\tif (wordcount + wc > orgnr)\n\t\t    break;\n\t\twordcount += wc;\n\t    }\n\n\t    theword[wlen] = byts[n + i];\n\t    n = idxs[n + i];\n\t}\nbadword:\n\ttheword[wlen] = NUL;\n\n\t// Go over the possible flags and regions.\n\tfor (; i <= byts[n] && byts[n + i] == NUL; ++i)\n\t{\n\t    char_u\tcword[MAXWLEN];\n\t    char_u\t*p;\n\t    int\t\tflags = (int)idxs[n + i];\n\n\t    // Skip words with the NOSUGGEST flag\n\t    if (flags & WF_NOSUGGEST)\n\t\tcontinue;\n\n\t    if (flags & WF_KEEPCAP)\n\t    {\n\t\t// Must find the word in the keep-case tree.\n\t\tfind_keepcap_word(slang, theword, cword);\n\t\tp = cword;\n\t    }\n\t    else\n\t    {\n\t\tflags |= su->su_badflags;\n\t\tif ((flags & WF_CAPMASK) != 0)\n\t\t{\n\t\t    // Need to fix case according to \"flags\".\n\t\t    make_case_word(theword, cword, flags);\n\t\t    p = cword;\n\t\t}\n\t\telse\n\t\t    p = theword;\n\t    }\n\n\t    // Add the suggestion.\n\t    if (sps_flags & SPS_DOUBLE)\n\t    {\n\t\t// Add the suggestion if the score isn't too bad.\n\t\tif (score <= su->su_maxscore)\n\t\t    add_suggestion(su, &su->su_sga, p, su->su_badlen,\n\t\t\t\t\t       score, 0, FALSE, slang, FALSE);\n\t    }\n\t    else\n\t    {\n\t\t// Add a penalty for words in another region.\n\t\tif ((flags & WF_REGION)\n\t\t\t    && (((unsigned)flags >> 16) & lp->lp_region) == 0)\n\t\t    goodscore = SCORE_REGION;\n\t\telse\n\t\t    goodscore = 0;\n\n\t\t// Add a small penalty for changing the first letter from\n\t\t// lower to upper case.  Helps for \"tath\" -> \"Kath\", which is\n\t\t// less common than \"tath\" -> \"path\".  Don't do it when the\n\t\t// letter is the same, that has already been counted.\n\t\tgc = PTR2CHAR(p);\n\t\tif (SPELL_ISUPPER(gc))\n\t\t{\n\t\t    bc = PTR2CHAR(su->su_badword);\n\t\t    if (!SPELL_ISUPPER(bc)\n\t\t\t\t      && SPELL_TOFOLD(bc) != SPELL_TOFOLD(gc))\n\t\t\tgoodscore += SCORE_ICASE / 2;\n\t\t}\n\n\t\t// Compute the score for the good word.  This only does letter\n\t\t// insert/delete/swap/replace.  REP items are not considered,\n\t\t// which may make the score a bit higher.\n\t\t// Use a limit for the score to make it work faster.  Use\n\t\t// MAXSCORE(), because RESCORE() will change the score.\n\t\t// If the limit is very high then the iterative method is\n\t\t// inefficient, using an array is quicker.\n\t\tlimit = MAXSCORE(su->su_sfmaxscore - goodscore, score);\n\t\tif (limit > SCORE_LIMITMAX)\n\t\t    goodscore += spell_edit_score(slang, su->su_badword, p);\n\t\telse\n\t\t    goodscore += spell_edit_score_limit(slang, su->su_badword,\n\t\t\t\t\t\t\t\t    p, limit);\n\n\t\t// When going over the limit don't bother to do the rest.\n\t\tif (goodscore < SCORE_MAXMAX)\n\t\t{\n\t\t    // Give a bonus to words seen before.\n\t\t    goodscore = score_wordcount_adj(slang, goodscore, p, FALSE);\n\n\t\t    // Add the suggestion if the score isn't too bad.\n\t\t    goodscore = RESCORE(goodscore, score);\n\t\t    if (goodscore <= su->su_sfmaxscore)\n\t\t\tadd_suggestion(su, &su->su_ga, p, su->su_badlen,\n\t\t\t\t\t goodscore, score, TRUE, slang, TRUE);\n\t\t}\n\t    }\n\t}\n\t// smsg(\"word %s (%d): %s (%d)\", sftword, sftnr, theword, orgnr);\n    }\n}\n\n/*\n * Find word \"word\" in fold-case tree for \"slang\" and return the word number.\n */\n    static int\nsoundfold_find(slang_T *slang, char_u *word)\n{\n    idx_T\tarridx = 0;\n    int\t\tlen;\n    int\t\twlen = 0;\n    int\t\tc;\n    char_u\t*ptr = word;\n    char_u\t*byts;\n    idx_T\t*idxs;\n    int\t\twordnr = 0;\n\n    byts = slang->sl_sbyts;\n    idxs = slang->sl_sidxs;\n\n    for (;;)\n    {\n\t// First byte is the number of possible bytes.\n\tlen = byts[arridx++];\n\n\t// If the first possible byte is a zero the word could end here.\n\t// If the word ends we found the word.  If not skip the NUL bytes.\n\tc = ptr[wlen];\n\tif (byts[arridx] == NUL)\n\t{\n\t    if (c == NUL)\n\t\tbreak;\n\n\t    // Skip over the zeros, there can be several.\n\t    while (len > 0 && byts[arridx] == NUL)\n\t    {\n\t\t++arridx;\n\t\t--len;\n\t    }\n\t    if (len == 0)\n\t\treturn -1;    // no children, word should have ended here\n\t    ++wordnr;\n\t}\n\n\t// If the word ends we didn't find it.\n\tif (c == NUL)\n\t    return -1;\n\n\t// Perform a binary search in the list of accepted bytes.\n\tif (c == TAB)\t    // <Tab> is handled like <Space>\n\t    c = ' ';\n\twhile (byts[arridx] < c)\n\t{\n\t    // The word count is in the first idxs[] entry of the child.\n\t    wordnr += idxs[idxs[arridx]];\n\t    ++arridx;\n\t    if (--len == 0)\t// end of the bytes, didn't find it\n\t\treturn -1;\n\t}\n\tif (byts[arridx] != c)\t// didn't find the byte\n\t    return -1;\n\n\t// Continue at the child (if there is one).\n\tarridx = idxs[arridx];\n\t++wlen;\n\n\t// One space in the good word may stand for several spaces in the\n\t// checked word.\n\tif (c == ' ')\n\t    while (ptr[wlen] == ' ' || ptr[wlen] == TAB)\n\t\t++wlen;\n    }\n\n    return wordnr;\n}\n\n/*\n * Return TRUE if \"c1\" and \"c2\" are similar characters according to the MAP\n * lines in the .aff file.\n */\n    static int\nsimilar_chars(slang_T *slang, int c1, int c2)\n{\n    int\t\tm1, m2;\n    char_u\tbuf[MB_MAXBYTES + 1];\n    hashitem_T  *hi;\n\n    if (c1 >= 256)\n    {\n\tbuf[mb_char2bytes(c1, buf)] = 0;\n\thi = hash_find(&slang->sl_map_hash, buf);\n\tif (HASHITEM_EMPTY(hi))\n\t    m1 = 0;\n\telse\n\t    m1 = mb_ptr2char(hi->hi_key + STRLEN(hi->hi_key) + 1);\n    }\n    else\n\tm1 = slang->sl_map_array[c1];\n    if (m1 == 0)\n\treturn FALSE;\n\n\n    if (c2 >= 256)\n    {\n\tbuf[mb_char2bytes(c2, buf)] = 0;\n\thi = hash_find(&slang->sl_map_hash, buf);\n\tif (HASHITEM_EMPTY(hi))\n\t    m2 = 0;\n\telse\n\t    m2 = mb_ptr2char(hi->hi_key + STRLEN(hi->hi_key) + 1);\n    }\n    else\n\tm2 = slang->sl_map_array[c2];\n\n    return m1 == m2;\n}\n\n/*\n * Add a suggestion to the list of suggestions.\n * For a suggestion that is already in the list the lowest score is remembered.\n */\n    static void\nadd_suggestion(\n    suginfo_T\t*su,\n    garray_T\t*gap,\t\t// either su_ga or su_sga\n    char_u\t*goodword,\n    int\t\tbadlenarg,\t// len of bad word replaced with \"goodword\"\n    int\t\tscore,\n    int\t\taltscore,\n    int\t\thad_bonus,\t// value for st_had_bonus\n    slang_T\t*slang,\t\t// language for sound folding\n    int\t\tmaxsf)\t\t// su_maxscore applies to soundfold score,\n\t\t\t\t// su_sfmaxscore to the total score.\n{\n    int\t\tgoodlen;\t// len of goodword changed\n    int\t\tbadlen;\t\t// len of bad word changed\n    suggest_T   *stp;\n    suggest_T   new_sug;\n    int\t\ti;\n    char_u\t*pgood, *pbad;\n\n    // Minimize \"badlen\" for consistency.  Avoids that changing \"the the\" to\n    // \"thee the\" is added next to changing the first \"the\" the \"thee\".\n    pgood = goodword + STRLEN(goodword);\n    pbad = su->su_badptr + badlenarg;\n    for (;;)\n    {\n\tgoodlen = (int)(pgood - goodword);\n\tbadlen = (int)(pbad - su->su_badptr);\n\tif (goodlen <= 0 || badlen <= 0)\n\t    break;\n\tMB_PTR_BACK(goodword, pgood);\n\tMB_PTR_BACK(su->su_badptr, pbad);\n\tif (has_mbyte)\n\t{\n\t    if (mb_ptr2char(pgood) != mb_ptr2char(pbad))\n\t\tbreak;\n\t}\n\telse if (*pgood != *pbad)\n\t\tbreak;\n    }\n\n    if (badlen == 0 && goodlen == 0)\n\t// goodword doesn't change anything; may happen for \"the the\" changing\n\t// the first \"the\" to itself.\n\treturn;\n\n    if (gap->ga_len == 0)\n\ti = -1;\n    else\n    {\n\t// Check if the word is already there.  Also check the length that is\n\t// being replaced \"thes,\" -> \"these\" is a different suggestion from\n\t// \"thes\" -> \"these\".\n\tstp = &SUG(*gap, 0);\n\tfor (i = gap->ga_len; --i >= 0; ++stp)\n\t    if (stp->st_wordlen == goodlen\n\t\t    && stp->st_orglen == badlen\n\t\t    && STRNCMP(stp->st_word, goodword, goodlen) == 0)\n\t    {\n\t\t// Found it.  Remember the word with the lowest score.\n\t\tif (stp->st_slang == NULL)\n\t\t    stp->st_slang = slang;\n\n\t\tnew_sug.st_score = score;\n\t\tnew_sug.st_altscore = altscore;\n\t\tnew_sug.st_had_bonus = had_bonus;\n\n\t\tif (stp->st_had_bonus != had_bonus)\n\t\t{\n\t\t    // Only one of the two had the soundalike score computed.\n\t\t    // Need to do that for the other one now, otherwise the\n\t\t    // scores can't be compared.  This happens because\n\t\t    // suggest_try_change() doesn't compute the soundalike\n\t\t    // word to keep it fast, while some special methods set\n\t\t    // the soundalike score to zero.\n\t\t    if (had_bonus)\n\t\t\trescore_one(su, stp);\n\t\t    else\n\t\t    {\n\t\t\tnew_sug.st_word = stp->st_word;\n\t\t\tnew_sug.st_wordlen = stp->st_wordlen;\n\t\t\tnew_sug.st_slang = stp->st_slang;\n\t\t\tnew_sug.st_orglen = badlen;\n\t\t\trescore_one(su, &new_sug);\n\t\t    }\n\t\t}\n\n\t\tif (stp->st_score > new_sug.st_score)\n\t\t{\n\t\t    stp->st_score = new_sug.st_score;\n\t\t    stp->st_altscore = new_sug.st_altscore;\n\t\t    stp->st_had_bonus = new_sug.st_had_bonus;\n\t\t}\n\t\tbreak;\n\t    }\n    }\n\n    if (i < 0 && ga_grow(gap, 1) == OK)\n    {\n\t// Add a suggestion.\n\tstp = &SUG(*gap, gap->ga_len);\n\tstp->st_word = vim_strnsave(goodword, goodlen);\n\tif (stp->st_word != NULL)\n\t{\n\t    stp->st_wordlen = goodlen;\n\t    stp->st_score = score;\n\t    stp->st_altscore = altscore;\n\t    stp->st_had_bonus = had_bonus;\n\t    stp->st_orglen = badlen;\n\t    stp->st_slang = slang;\n\t    ++gap->ga_len;\n\n\t    // If we have too many suggestions now, sort the list and keep\n\t    // the best suggestions.\n\t    if (gap->ga_len > SUG_MAX_COUNT(su))\n\t    {\n\t\tif (maxsf)\n\t\t    su->su_sfmaxscore = cleanup_suggestions(gap,\n\t\t\t\t      su->su_sfmaxscore, SUG_CLEAN_COUNT(su));\n\t\telse\n\t\t    su->su_maxscore = cleanup_suggestions(gap,\n\t\t\t\t\tsu->su_maxscore, SUG_CLEAN_COUNT(su));\n\t    }\n\t}\n    }\n}\n\n/*\n * Suggestions may in fact be flagged as errors.  Esp. for banned words and\n * for split words, such as \"the the\".  Remove these from the list here.\n */\n    static void\ncheck_suggestions(\n    suginfo_T\t*su,\n    garray_T\t*gap)\t\t    // either su_ga or su_sga\n{\n    suggest_T   *stp;\n    int\t\ti;\n    char_u\tlongword[MAXWLEN + 1];\n    int\t\tlen;\n    hlf_T\tattr;\n\n    if (gap->ga_len == 0)\n\treturn;\n    stp = &SUG(*gap, 0);\n    for (i = gap->ga_len - 1; i >= 0; --i)\n    {\n\t// Need to append what follows to check for \"the the\".\n\tvim_strncpy(longword, stp[i].st_word, MAXWLEN);\n\tlen = stp[i].st_wordlen;\n\tvim_strncpy(longword + len, su->su_badptr + stp[i].st_orglen,\n\t\t\t\t\t\t\t       MAXWLEN - len);\n\tattr = HLF_COUNT;\n\t(void)spell_check(curwin, longword, &attr, NULL, FALSE);\n\tif (attr != HLF_COUNT)\n\t{\n\t    // Remove this entry.\n\t    vim_free(stp[i].st_word);\n\t    --gap->ga_len;\n\t    if (i < gap->ga_len)\n\t\tmch_memmove(stp + i, stp + i + 1,\n\t\t\t\t       sizeof(suggest_T) * (gap->ga_len - i));\n\t}\n    }\n}\n\n\n/*\n * Add a word to be banned.\n */\n    static void\nadd_banned(\n    suginfo_T\t*su,\n    char_u\t*word)\n{\n    char_u\t*s;\n    hash_T\thash;\n    hashitem_T\t*hi;\n\n    hash = hash_hash(word);\n    hi = hash_lookup(&su->su_banned, word, hash);\n    if (HASHITEM_EMPTY(hi))\n    {\n\ts = vim_strsave(word);\n\tif (s != NULL)\n\t    hash_add_item(&su->su_banned, hi, s, hash);\n    }\n}\n\n/*\n * Recompute the score for all suggestions if sound-folding is possible.  This\n * is slow, thus only done for the final results.\n */\n    static void\nrescore_suggestions(suginfo_T *su)\n{\n    int\t\ti;\n\n    if (su->su_sallang != NULL)\n\tfor (i = 0; i < su->su_ga.ga_len; ++i)\n\t    rescore_one(su, &SUG(su->su_ga, i));\n}\n\n/*\n * Recompute the score for one suggestion if sound-folding is possible.\n */\n    static void\nrescore_one(suginfo_T *su, suggest_T *stp)\n{\n    slang_T\t*slang = stp->st_slang;\n    char_u\tsal_badword[MAXWLEN];\n    char_u\t*p;\n\n    // Only rescore suggestions that have no sal score yet and do have a\n    // language.\n    if (slang != NULL && slang->sl_sal.ga_len > 0 && !stp->st_had_bonus)\n    {\n\tif (slang == su->su_sallang)\n\t    p = su->su_sal_badword;\n\telse\n\t{\n\t    spell_soundfold(slang, su->su_fbadword, TRUE, sal_badword);\n\t    p = sal_badword;\n\t}\n\n\tstp->st_altscore = stp_sal_score(stp, su, slang, p);\n\tif (stp->st_altscore == SCORE_MAXMAX)\n\t    stp->st_altscore = SCORE_BIG;\n\tstp->st_score = RESCORE(stp->st_score, stp->st_altscore);\n\tstp->st_had_bonus = TRUE;\n    }\n}\n\nstatic int sug_compare(const void *s1, const void *s2);\n\n/*\n * Function given to qsort() to sort the suggestions on st_score.\n * First on \"st_score\", then \"st_altscore\" then alphabetically.\n */\n    static int\nsug_compare(const void *s1, const void *s2)\n{\n    suggest_T\t*p1 = (suggest_T *)s1;\n    suggest_T\t*p2 = (suggest_T *)s2;\n    int\t\tn = p1->st_score - p2->st_score;\n\n    if (n == 0)\n    {\n\tn = p1->st_altscore - p2->st_altscore;\n\tif (n == 0)\n\t    n = STRICMP(p1->st_word, p2->st_word);\n    }\n    return n;\n}\n\n/*\n * Cleanup the suggestions:\n * - Sort on score.\n * - Remove words that won't be displayed.\n * Returns the maximum score in the list or \"maxscore\" unmodified.\n */\n    static int\ncleanup_suggestions(\n    garray_T\t*gap,\n    int\t\tmaxscore,\n    int\t\tkeep)\t\t// nr of suggestions to keep\n{\n    if (gap->ga_len > 0)\n    {\n\t// Sort the list.\n\tqsort(gap->ga_data, (size_t)gap->ga_len, sizeof(suggest_T),\n\t\t\t\t\t\t\t\t  sug_compare);\n\n\t// Truncate the list to the number of suggestions that will be\n\t// displayed.\n\tif (gap->ga_len > keep)\n\t{\n\t    int\t\ti;\n\t    suggest_T   *stp = &SUG(*gap, 0);\n\n\t    for (i = keep; i < gap->ga_len; ++i)\n\t\tvim_free(stp[i].st_word);\n\t    gap->ga_len = keep;\n\t    if (keep >= 1)\n\t\treturn stp[keep - 1].st_score;\n\t}\n    }\n    return maxscore;\n}\n\n/*\n * Compute a score for two sound-a-like words.\n * This permits up to two inserts/deletes/swaps/etc. to keep things fast.\n * Instead of a generic loop we write out the code.  That keeps it fast by\n * avoiding checks that will not be possible.\n */\n    static int\nsoundalike_score(\n    char_u\t*goodstart,\t// sound-folded good word\n    char_u\t*badstart)\t// sound-folded bad word\n{\n    char_u\t*goodsound = goodstart;\n    char_u\t*badsound = badstart;\n    int\t\tgoodlen;\n    int\t\tbadlen;\n    int\t\tn;\n    char_u\t*pl, *ps;\n    char_u\t*pl2, *ps2;\n    int\t\tscore = 0;\n\n    // Adding/inserting \"*\" at the start (word starts with vowel) shouldn't be\n    // counted so much, vowels halfway the word aren't counted at all.\n    if ((*badsound == '*' || *goodsound == '*') && *badsound != *goodsound)\n    {\n\tif ((badsound[0] == NUL && goodsound[1] == NUL)\n\t    || (goodsound[0] == NUL && badsound[1] == NUL))\n\t    // changing word with vowel to word without a sound\n\t    return SCORE_DEL;\n\tif (badsound[0] == NUL || goodsound[0] == NUL)\n\t    // more than two changes\n\t    return SCORE_MAXMAX;\n\n\tif (badsound[1] == goodsound[1]\n\t\t|| (badsound[1] != NUL\n\t\t    && goodsound[1] != NUL\n\t\t    && badsound[2] == goodsound[2]))\n\t{\n\t    // handle like a substitute\n\t}\n\telse\n\t{\n\t    score = 2 * SCORE_DEL / 3;\n\t    if (*badsound == '*')\n\t\t++badsound;\n\t    else\n\t\t++goodsound;\n\t}\n    }\n\n    goodlen = (int)STRLEN(goodsound);\n    badlen = (int)STRLEN(badsound);\n\n    // Return quickly if the lengths are too different to be fixed by two\n    // changes.\n    n = goodlen - badlen;\n    if (n < -2 || n > 2)\n\treturn SCORE_MAXMAX;\n\n    if (n > 0)\n    {\n\tpl = goodsound;\t    // goodsound is longest\n\tps = badsound;\n    }\n    else\n    {\n\tpl = badsound;\t    // badsound is longest\n\tps = goodsound;\n    }\n\n    // Skip over the identical part.\n    while (*pl == *ps && *pl != NUL)\n    {\n\t++pl;\n\t++ps;\n    }\n\n    switch (n)\n    {\n\tcase -2:\n\tcase 2:\n\t    // Must delete two characters from \"pl\".\n\t    ++pl;\t// first delete\n\t    while (*pl == *ps)\n\t    {\n\t\t++pl;\n\t\t++ps;\n\t    }\n\t    // strings must be equal after second delete\n\t    if (STRCMP(pl + 1, ps) == 0)\n\t\treturn score + SCORE_DEL * 2;\n\n\t    // Failed to compare.\n\t    break;\n\n\tcase -1:\n\tcase 1:\n\t    // Minimal one delete from \"pl\" required.\n\n\t    // 1: delete\n\t    pl2 = pl + 1;\n\t    ps2 = ps;\n\t    while (*pl2 == *ps2)\n\t    {\n\t\tif (*pl2 == NUL)\t// reached the end\n\t\t    return score + SCORE_DEL;\n\t\t++pl2;\n\t\t++ps2;\n\t    }\n\n\t    // 2: delete then swap, then rest must be equal\n\t    if (pl2[0] == ps2[1] && pl2[1] == ps2[0]\n\t\t\t\t\t     && STRCMP(pl2 + 2, ps2 + 2) == 0)\n\t\treturn score + SCORE_DEL + SCORE_SWAP;\n\n\t    // 3: delete then substitute, then the rest must be equal\n\t    if (STRCMP(pl2 + 1, ps2 + 1) == 0)\n\t\treturn score + SCORE_DEL + SCORE_SUBST;\n\n\t    // 4: first swap then delete\n\t    if (pl[0] == ps[1] && pl[1] == ps[0])\n\t    {\n\t\tpl2 = pl + 2;\t    // swap, skip two chars\n\t\tps2 = ps + 2;\n\t\twhile (*pl2 == *ps2)\n\t\t{\n\t\t    ++pl2;\n\t\t    ++ps2;\n\t\t}\n\t\t// delete a char and then strings must be equal\n\t\tif (STRCMP(pl2 + 1, ps2) == 0)\n\t\t    return score + SCORE_SWAP + SCORE_DEL;\n\t    }\n\n\t    // 5: first substitute then delete\n\t    pl2 = pl + 1;\t    // substitute, skip one char\n\t    ps2 = ps + 1;\n\t    while (*pl2 == *ps2)\n\t    {\n\t\t++pl2;\n\t\t++ps2;\n\t    }\n\t    // delete a char and then strings must be equal\n\t    if (STRCMP(pl2 + 1, ps2) == 0)\n\t\treturn score + SCORE_SUBST + SCORE_DEL;\n\n\t    // Failed to compare.\n\t    break;\n\n\tcase 0:\n\t    // Lengths are equal, thus changes must result in same length: An\n\t    // insert is only possible in combination with a delete.\n\t    // 1: check if for identical strings\n\t    if (*pl == NUL)\n\t\treturn score;\n\n\t    // 2: swap\n\t    if (pl[0] == ps[1] && pl[1] == ps[0])\n\t    {\n\t\tpl2 = pl + 2;\t    // swap, skip two chars\n\t\tps2 = ps + 2;\n\t\twhile (*pl2 == *ps2)\n\t\t{\n\t\t    if (*pl2 == NUL)\t// reached the end\n\t\t\treturn score + SCORE_SWAP;\n\t\t    ++pl2;\n\t\t    ++ps2;\n\t\t}\n\t\t// 3: swap and swap again\n\t\tif (pl2[0] == ps2[1] && pl2[1] == ps2[0]\n\t\t\t\t\t     && STRCMP(pl2 + 2, ps2 + 2) == 0)\n\t\t    return score + SCORE_SWAP + SCORE_SWAP;\n\n\t\t// 4: swap and substitute\n\t\tif (STRCMP(pl2 + 1, ps2 + 1) == 0)\n\t\t    return score + SCORE_SWAP + SCORE_SUBST;\n\t    }\n\n\t    // 5: substitute\n\t    pl2 = pl + 1;\n\t    ps2 = ps + 1;\n\t    while (*pl2 == *ps2)\n\t    {\n\t\tif (*pl2 == NUL)\t// reached the end\n\t\t    return score + SCORE_SUBST;\n\t\t++pl2;\n\t\t++ps2;\n\t    }\n\n\t    // 6: substitute and swap\n\t    if (pl2[0] == ps2[1] && pl2[1] == ps2[0]\n\t\t\t\t\t     && STRCMP(pl2 + 2, ps2 + 2) == 0)\n\t\treturn score + SCORE_SUBST + SCORE_SWAP;\n\n\t    // 7: substitute and substitute\n\t    if (STRCMP(pl2 + 1, ps2 + 1) == 0)\n\t\treturn score + SCORE_SUBST + SCORE_SUBST;\n\n\t    // 8: insert then delete\n\t    pl2 = pl;\n\t    ps2 = ps + 1;\n\t    while (*pl2 == *ps2)\n\t    {\n\t\t++pl2;\n\t\t++ps2;\n\t    }\n\t    if (STRCMP(pl2 + 1, ps2) == 0)\n\t\treturn score + SCORE_INS + SCORE_DEL;\n\n\t    // 9: delete then insert\n\t    pl2 = pl + 1;\n\t    ps2 = ps;\n\t    while (*pl2 == *ps2)\n\t    {\n\t\t++pl2;\n\t\t++ps2;\n\t    }\n\t    if (STRCMP(pl2, ps2 + 1) == 0)\n\t\treturn score + SCORE_INS + SCORE_DEL;\n\n\t    // Failed to compare.\n\t    break;\n    }\n\n    return SCORE_MAXMAX;\n}\n\n/*\n * Compute the \"edit distance\" to turn \"badword\" into \"goodword\".  The less\n * deletes/inserts/substitutes/swaps are required the lower the score.\n *\n * The algorithm is described by Du and Chang, 1992.\n * The implementation of the algorithm comes from Aspell editdist.cpp,\n * edit_distance().  It has been converted from C++ to C and modified to\n * support multi-byte characters.\n */\n    static int\nspell_edit_score(\n    slang_T\t*slang,\n    char_u\t*badword,\n    char_u\t*goodword)\n{\n    int\t\t*cnt;\n    int\t\tbadlen, goodlen;\t// lengths including NUL\n    int\t\tj, i;\n    int\t\tt;\n    int\t\tbc, gc;\n    int\t\tpbc, pgc;\n    char_u\t*p;\n    int\t\twbadword[MAXWLEN];\n    int\t\twgoodword[MAXWLEN];\n\n    if (has_mbyte)\n    {\n\t// Get the characters from the multi-byte strings and put them in an\n\t// int array for easy access.\n\tfor (p = badword, badlen = 0; *p != NUL; )\n\t    wbadword[badlen++] = mb_cptr2char_adv(&p);\n\twbadword[badlen++] = 0;\n\tfor (p = goodword, goodlen = 0; *p != NUL; )\n\t    wgoodword[goodlen++] = mb_cptr2char_adv(&p);\n\twgoodword[goodlen++] = 0;\n    }\n    else\n    {\n\tbadlen = (int)STRLEN(badword) + 1;\n\tgoodlen = (int)STRLEN(goodword) + 1;\n    }\n\n    // We use \"cnt\" as an array: CNT(badword_idx, goodword_idx).\n#define CNT(a, b)   cnt[(a) + (b) * (badlen + 1)]\n    cnt = ALLOC_MULT(int, (badlen + 1) * (goodlen + 1));\n    if (cnt == NULL)\n\treturn 0;\t// out of memory\n\n    CNT(0, 0) = 0;\n    for (j = 1; j <= goodlen; ++j)\n\tCNT(0, j) = CNT(0, j - 1) + SCORE_INS;\n\n    for (i = 1; i <= badlen; ++i)\n    {\n\tCNT(i, 0) = CNT(i - 1, 0) + SCORE_DEL;\n\tfor (j = 1; j <= goodlen; ++j)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tbc = wbadword[i - 1];\n\t\tgc = wgoodword[j - 1];\n\t    }\n\t    else\n\t    {\n\t\tbc = badword[i - 1];\n\t\tgc = goodword[j - 1];\n\t    }\n\t    if (bc == gc)\n\t\tCNT(i, j) = CNT(i - 1, j - 1);\n\t    else\n\t    {\n\t\t// Use a better score when there is only a case difference.\n\t\tif (SPELL_TOFOLD(bc) == SPELL_TOFOLD(gc))\n\t\t    CNT(i, j) = SCORE_ICASE + CNT(i - 1, j - 1);\n\t\telse\n\t\t{\n\t\t    // For a similar character use SCORE_SIMILAR.\n\t\t    if (slang != NULL\n\t\t\t    && slang->sl_has_map\n\t\t\t    && similar_chars(slang, gc, bc))\n\t\t\tCNT(i, j) = SCORE_SIMILAR + CNT(i - 1, j - 1);\n\t\t    else\n\t\t\tCNT(i, j) = SCORE_SUBST + CNT(i - 1, j - 1);\n\t\t}\n\n\t\tif (i > 1 && j > 1)\n\t\t{\n\t\t    if (has_mbyte)\n\t\t    {\n\t\t\tpbc = wbadword[i - 2];\n\t\t\tpgc = wgoodword[j - 2];\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tpbc = badword[i - 2];\n\t\t\tpgc = goodword[j - 2];\n\t\t    }\n\t\t    if (bc == pgc && pbc == gc)\n\t\t    {\n\t\t\tt = SCORE_SWAP + CNT(i - 2, j - 2);\n\t\t\tif (t < CNT(i, j))\n\t\t\t    CNT(i, j) = t;\n\t\t    }\n\t\t}\n\t\tt = SCORE_DEL + CNT(i - 1, j);\n\t\tif (t < CNT(i, j))\n\t\t    CNT(i, j) = t;\n\t\tt = SCORE_INS + CNT(i, j - 1);\n\t\tif (t < CNT(i, j))\n\t\t    CNT(i, j) = t;\n\t    }\n\t}\n    }\n\n    i = CNT(badlen - 1, goodlen - 1);\n    vim_free(cnt);\n    return i;\n}\n\ntypedef struct\n{\n    int\t\tbadi;\n    int\t\tgoodi;\n    int\t\tscore;\n} limitscore_T;\n\n/*\n * Like spell_edit_score(), but with a limit on the score to make it faster.\n * May return SCORE_MAXMAX when the score is higher than \"limit\".\n *\n * This uses a stack for the edits still to be tried.\n * The idea comes from Aspell leditdist.cpp.  Rewritten in C and added support\n * for multi-byte characters.\n */\n    static int\nspell_edit_score_limit(\n    slang_T\t*slang,\n    char_u\t*badword,\n    char_u\t*goodword,\n    int\t\tlimit)\n{\n    limitscore_T    stack[10];\t\t// allow for over 3 * 2 edits\n    int\t\t    stackidx;\n    int\t\t    bi, gi;\n    int\t\t    bi2, gi2;\n    int\t\t    bc, gc;\n    int\t\t    score;\n    int\t\t    score_off;\n    int\t\t    minscore;\n    int\t\t    round;\n\n    // Multi-byte characters require a bit more work, use a different function\n    // to avoid testing \"has_mbyte\" quite often.\n    if (has_mbyte)\n\treturn spell_edit_score_limit_w(slang, badword, goodword, limit);\n\n    // The idea is to go from start to end over the words.  So long as\n    // characters are equal just continue, this always gives the lowest score.\n    // When there is a difference try several alternatives.  Each alternative\n    // increases \"score\" for the edit distance.  Some of the alternatives are\n    // pushed unto a stack and tried later, some are tried right away.  At the\n    // end of the word the score for one alternative is known.  The lowest\n    // possible score is stored in \"minscore\".\n    stackidx = 0;\n    bi = 0;\n    gi = 0;\n    score = 0;\n    minscore = limit + 1;\n\n    for (;;)\n    {\n\t// Skip over an equal part, score remains the same.\n\tfor (;;)\n\t{\n\t    bc = badword[bi];\n\t    gc = goodword[gi];\n\t    if (bc != gc)\t// stop at a char that's different\n\t\tbreak;\n\t    if (bc == NUL)\t// both words end\n\t    {\n\t\tif (score < minscore)\n\t\t    minscore = score;\n\t\tgoto pop;\t// do next alternative\n\t    }\n\t    ++bi;\n\t    ++gi;\n\t}\n\n\tif (gc == NUL)    // goodword ends, delete badword chars\n\t{\n\t    do\n\t    {\n\t\tif ((score += SCORE_DEL) >= minscore)\n\t\t    goto pop;\t    // do next alternative\n\t    } while (badword[++bi] != NUL);\n\t    minscore = score;\n\t}\n\telse if (bc == NUL) // badword ends, insert badword chars\n\t{\n\t    do\n\t    {\n\t\tif ((score += SCORE_INS) >= minscore)\n\t\t    goto pop;\t    // do next alternative\n\t    } while (goodword[++gi] != NUL);\n\t    minscore = score;\n\t}\n\telse\t\t\t// both words continue\n\t{\n\t    // If not close to the limit, perform a change.  Only try changes\n\t    // that may lead to a lower score than \"minscore\".\n\t    // round 0: try deleting a char from badword\n\t    // round 1: try inserting a char in badword\n\t    for (round = 0; round <= 1; ++round)\n\t    {\n\t\tscore_off = score + (round == 0 ? SCORE_DEL : SCORE_INS);\n\t\tif (score_off < minscore)\n\t\t{\n\t\t    if (score_off + SCORE_EDIT_MIN >= minscore)\n\t\t    {\n\t\t\t// Near the limit, rest of the words must match.  We\n\t\t\t// can check that right now, no need to push an item\n\t\t\t// onto the stack.\n\t\t\tbi2 = bi + 1 - round;\n\t\t\tgi2 = gi + round;\n\t\t\twhile (goodword[gi2] == badword[bi2])\n\t\t\t{\n\t\t\t    if (goodword[gi2] == NUL)\n\t\t\t    {\n\t\t\t\tminscore = score_off;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t    ++bi2;\n\t\t\t    ++gi2;\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// try deleting/inserting a character later\n\t\t\tstack[stackidx].badi = bi + 1 - round;\n\t\t\tstack[stackidx].goodi = gi + round;\n\t\t\tstack[stackidx].score = score_off;\n\t\t\t++stackidx;\n\t\t    }\n\t\t}\n\t    }\n\n\t    if (score + SCORE_SWAP < minscore)\n\t    {\n\t\t// If swapping two characters makes a match then the\n\t\t// substitution is more expensive, thus there is no need to\n\t\t// try both.\n\t\tif (gc == badword[bi + 1] && bc == goodword[gi + 1])\n\t\t{\n\t\t    // Swap two characters, that is: skip them.\n\t\t    gi += 2;\n\t\t    bi += 2;\n\t\t    score += SCORE_SWAP;\n\t\t    continue;\n\t\t}\n\t    }\n\n\t    // Substitute one character for another which is the same\n\t    // thing as deleting a character from both goodword and badword.\n\t    // Use a better score when there is only a case difference.\n\t    if (SPELL_TOFOLD(bc) == SPELL_TOFOLD(gc))\n\t\tscore += SCORE_ICASE;\n\t    else\n\t    {\n\t\t// For a similar character use SCORE_SIMILAR.\n\t\tif (slang != NULL\n\t\t\t&& slang->sl_has_map\n\t\t\t&& similar_chars(slang, gc, bc))\n\t\t    score += SCORE_SIMILAR;\n\t\telse\n\t\t    score += SCORE_SUBST;\n\t    }\n\n\t    if (score < minscore)\n\t    {\n\t\t// Do the substitution.\n\t\t++gi;\n\t\t++bi;\n\t\tcontinue;\n\t    }\n\t}\npop:\n\t// Get here to try the next alternative, pop it from the stack.\n\tif (stackidx == 0)\t\t// stack is empty, finished\n\t    break;\n\n\t// pop an item from the stack\n\t--stackidx;\n\tgi = stack[stackidx].goodi;\n\tbi = stack[stackidx].badi;\n\tscore = stack[stackidx].score;\n    }\n\n    // When the score goes over \"limit\" it may actually be much higher.\n    // Return a very large number to avoid going below the limit when giving a\n    // bonus.\n    if (minscore > limit)\n\treturn SCORE_MAXMAX;\n    return minscore;\n}\n\n/*\n * Multi-byte version of spell_edit_score_limit().\n * Keep it in sync with the above!\n */\n    static int\nspell_edit_score_limit_w(\n    slang_T\t*slang,\n    char_u\t*badword,\n    char_u\t*goodword,\n    int\t\tlimit)\n{\n    limitscore_T    stack[10];\t\t// allow for over 3 * 2 edits\n    int\t\t    stackidx;\n    int\t\t    bi, gi;\n    int\t\t    bi2, gi2;\n    int\t\t    bc, gc;\n    int\t\t    score;\n    int\t\t    score_off;\n    int\t\t    minscore;\n    int\t\t    round;\n    char_u\t    *p;\n    int\t\t    wbadword[MAXWLEN];\n    int\t\t    wgoodword[MAXWLEN];\n\n    // Get the characters from the multi-byte strings and put them in an\n    // int array for easy access.\n    bi = 0;\n    for (p = badword; *p != NUL; )\n\twbadword[bi++] = mb_cptr2char_adv(&p);\n    wbadword[bi++] = 0;\n    gi = 0;\n    for (p = goodword; *p != NUL; )\n\twgoodword[gi++] = mb_cptr2char_adv(&p);\n    wgoodword[gi++] = 0;\n\n    // The idea is to go from start to end over the words.  So long as\n    // characters are equal just continue, this always gives the lowest score.\n    // When there is a difference try several alternatives.  Each alternative\n    // increases \"score\" for the edit distance.  Some of the alternatives are\n    // pushed unto a stack and tried later, some are tried right away.  At the\n    // end of the word the score for one alternative is known.  The lowest\n    // possible score is stored in \"minscore\".\n    stackidx = 0;\n    bi = 0;\n    gi = 0;\n    score = 0;\n    minscore = limit + 1;\n\n    for (;;)\n    {\n\t// Skip over an equal part, score remains the same.\n\tfor (;;)\n\t{\n\t    bc = wbadword[bi];\n\t    gc = wgoodword[gi];\n\n\t    if (bc != gc)\t// stop at a char that's different\n\t\tbreak;\n\t    if (bc == NUL)\t// both words end\n\t    {\n\t\tif (score < minscore)\n\t\t    minscore = score;\n\t\tgoto pop;\t// do next alternative\n\t    }\n\t    ++bi;\n\t    ++gi;\n\t}\n\n\tif (gc == NUL)    // goodword ends, delete badword chars\n\t{\n\t    do\n\t    {\n\t\tif ((score += SCORE_DEL) >= minscore)\n\t\t    goto pop;\t    // do next alternative\n\t    } while (wbadword[++bi] != NUL);\n\t    minscore = score;\n\t}\n\telse if (bc == NUL) // badword ends, insert badword chars\n\t{\n\t    do\n\t    {\n\t\tif ((score += SCORE_INS) >= minscore)\n\t\t    goto pop;\t    // do next alternative\n\t    } while (wgoodword[++gi] != NUL);\n\t    minscore = score;\n\t}\n\telse\t\t\t// both words continue\n\t{\n\t    // If not close to the limit, perform a change.  Only try changes\n\t    // that may lead to a lower score than \"minscore\".\n\t    // round 0: try deleting a char from badword\n\t    // round 1: try inserting a char in badword\n\t    for (round = 0; round <= 1; ++round)\n\t    {\n\t\tscore_off = score + (round == 0 ? SCORE_DEL : SCORE_INS);\n\t\tif (score_off < minscore)\n\t\t{\n\t\t    if (score_off + SCORE_EDIT_MIN >= minscore)\n\t\t    {\n\t\t\t// Near the limit, rest of the words must match.  We\n\t\t\t// can check that right now, no need to push an item\n\t\t\t// onto the stack.\n\t\t\tbi2 = bi + 1 - round;\n\t\t\tgi2 = gi + round;\n\t\t\twhile (wgoodword[gi2] == wbadword[bi2])\n\t\t\t{\n\t\t\t    if (wgoodword[gi2] == NUL)\n\t\t\t    {\n\t\t\t\tminscore = score_off;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t    ++bi2;\n\t\t\t    ++gi2;\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// try deleting a character from badword later\n\t\t\tstack[stackidx].badi = bi + 1 - round;\n\t\t\tstack[stackidx].goodi = gi + round;\n\t\t\tstack[stackidx].score = score_off;\n\t\t\t++stackidx;\n\t\t    }\n\t\t}\n\t    }\n\n\t    if (score + SCORE_SWAP < minscore)\n\t    {\n\t\t// If swapping two characters makes a match then the\n\t\t// substitution is more expensive, thus there is no need to\n\t\t// try both.\n\t\tif (gc == wbadword[bi + 1] && bc == wgoodword[gi + 1])\n\t\t{\n\t\t    // Swap two characters, that is: skip them.\n\t\t    gi += 2;\n\t\t    bi += 2;\n\t\t    score += SCORE_SWAP;\n\t\t    continue;\n\t\t}\n\t    }\n\n\t    // Substitute one character for another which is the same\n\t    // thing as deleting a character from both goodword and badword.\n\t    // Use a better score when there is only a case difference.\n\t    if (SPELL_TOFOLD(bc) == SPELL_TOFOLD(gc))\n\t\tscore += SCORE_ICASE;\n\t    else\n\t    {\n\t\t// For a similar character use SCORE_SIMILAR.\n\t\tif (slang != NULL\n\t\t\t&& slang->sl_has_map\n\t\t\t&& similar_chars(slang, gc, bc))\n\t\t    score += SCORE_SIMILAR;\n\t\telse\n\t\t    score += SCORE_SUBST;\n\t    }\n\n\t    if (score < minscore)\n\t    {\n\t\t// Do the substitution.\n\t\t++gi;\n\t\t++bi;\n\t\tcontinue;\n\t    }\n\t}\npop:\n\t// Get here to try the next alternative, pop it from the stack.\n\tif (stackidx == 0)\t\t// stack is empty, finished\n\t    break;\n\n\t// pop an item from the stack\n\t--stackidx;\n\tgi = stack[stackidx].goodi;\n\tbi = stack[stackidx].badi;\n\tscore = stack[stackidx].score;\n    }\n\n    // When the score goes over \"limit\" it may actually be much higher.\n    // Return a very large number to avoid going below the limit when giving a\n    // bonus.\n    if (minscore > limit)\n\treturn SCORE_MAXMAX;\n    return minscore;\n}\n#endif  // FEAT_SPELL\n", "\" Test spell checking\n\" Note: this file uses latin1 encoding, but is used with utf-8 encoding.\n\nsource check.vim\nCheckFeature spell\n\nsource screendump.vim\n\nfunc TearDown()\n  set nospell\n  call delete('Xtest.aff')\n  call delete('Xtest.dic')\n  call delete('Xtest.latin1.add')\n  call delete('Xtest.latin1.add.spl')\n  call delete('Xtest.latin1.spl')\n  call delete('Xtest.latin1.sug')\nendfunc\n\nfunc Test_wrap_search()\n  new\n  call setline(1, ['The', '', 'A plong line with two zpelling mistakes', '', 'End'])\n  set spell wrapscan\n  normal ]s\n  call assert_equal('plong', expand('<cword>'))\n  normal ]s\n  call assert_equal('zpelling', expand('<cword>'))\n  normal ]s\n  call assert_equal('plong', expand('<cword>'))\n  bwipe!\n  set nospell\nendfunc\n\nfunc Test_curswant()\n  new\n  call setline(1, ['Another plong line', 'abcdefghijklmnopq'])\n  set spell wrapscan\n  normal 0]s\n  call assert_equal('plong', expand('<cword>'))\n  normal j\n  call assert_equal(9, getcurpos()[2])\n  normal 0[s\n  call assert_equal('plong', expand('<cword>'))\n  normal j\n  call assert_equal(9, getcurpos()[2])\n\n  normal 0]S\n  call assert_equal('plong', expand('<cword>'))\n  normal j\n  call assert_equal(9, getcurpos()[2])\n  normal 0[S\n  call assert_equal('plong', expand('<cword>'))\n  normal j\n  call assert_equal(9, getcurpos()[2])\n\n  normal 1G0\n  call assert_equal('plong', spellbadword()[0])\n  normal j\n  call assert_equal(9, getcurpos()[2])\n\n  bwipe!\n  set nospell\nendfunc\n\nfunc Test_z_equal_on_invalid_utf8_word()\n  split\n  set spell\n  call setline(1, \"\\xff\")\n  norm z=\n  set nospell\n  bwipe!\nendfunc\n\n\" Test spellbadword() with argument\nfunc Test_spellbadword()\n  set spell\n\n  call assert_equal(['bycycle', 'bad'],  spellbadword('My bycycle.'))\n  call assert_equal(['another', 'caps'], 'A sentence. another sentence'->spellbadword())\n\n  call assert_equal(['TheCamelWord', 'bad'], 'TheCamelWord asdf'->spellbadword())\n  set spelloptions=camel\n  call assert_equal(['asdf', 'bad'], 'TheCamelWord asdf'->spellbadword())\n  set spelloptions=\n\n  set spelllang=en\n  call assert_equal(['', ''],            spellbadword('centre'))\n  call assert_equal(['', ''],            spellbadword('center'))\n  set spelllang=en_us\n  call assert_equal(['centre', 'local'], spellbadword('centre'))\n  call assert_equal(['', ''],            spellbadword('center'))\n  set spelllang=en_gb\n  call assert_equal(['', ''],            spellbadword('centre'))\n  call assert_equal(['center', 'local'], spellbadword('center'))\n\n  \" Create a small word list to test that spellbadword('...')\n  \" can return ['...', 'rare'].\n  e Xwords\n  insert\nfoo\nfoobar/?\n.\n   w!\n   mkspell! Xwords.spl Xwords\n   set spelllang=Xwords.spl\n   call assert_equal(['foobar', 'rare'], spellbadword('foo foobar'))\n\n  \" Typo should be detected even without the 'spell' option.\n  set spelllang=en_gb nospell\n  call assert_equal(['', ''], spellbadword('centre'))\n  call assert_equal(['bycycle', 'bad'], spellbadword('My bycycle.'))\n  call assert_equal(['another', 'caps'], spellbadword('A sentence. another sentence'))\n\n  set spelllang=\n  call assert_fails(\"call spellbadword('maxch')\", 'E756:')\n  call assert_fails(\"spelldump\", 'E756:')\n\n  call delete('Xwords.spl')\n  call delete('Xwords')\n  set spelllang&\n  set spell&\nendfunc\n\nfunc Test_spell_file_missing()\n  let s:spell_file_missing = 0\n  augroup TestSpellFileMissing\n    autocmd! SpellFileMissing * let s:spell_file_missing += 1\n  augroup END\n\n  set spell spelllang=ab_cd\n  let messages = GetMessages()\n  call assert_equal('Warning: Cannot find word list \"ab.utf-8.spl\" or \"ab.ascii.spl\"', messages[-1])\n  call assert_equal(1, s:spell_file_missing)\n\n  new XTestSpellFileMissing\n  augroup TestSpellFileMissing\n    autocmd! SpellFileMissing * bwipe\n  augroup END\n  call assert_fails('set spell spelllang=ab_cd', 'E797:')\n\n  augroup! TestSpellFileMissing\n  unlet s:spell_file_missing\n  set spell& spelllang&\n  %bwipe!\nendfunc\n\nfunc Test_spelldump()\n  set spell spelllang=en\n  spellrare! emacs\n\n  spelldump\n\n  \" Check assumption about region: 1: us, 2: au, 3: ca, 4: gb, 5: nz.\n  call assert_equal('/regions=usaucagbnz', getline(1))\n  call assert_notequal(0, search('^theater/1$'))    \" US English only.\n  call assert_notequal(0, search('^theatre/2345$')) \" AU, CA, GB or NZ English.\n\n  call assert_notequal(0, search('^emacs/?$'))      \" ? for a rare word.\n  call assert_notequal(0, search('^the the/!$'))    \" ! for a wrong word.\n\n  bwipe\n  set spell&\nendfunc\n\nfunc Test_spelldump_bang()\n  new\n  call setline(1, 'This is a sample sentence.')\n  redraw\n  set spell\n  redraw\n  spelldump!\n\n  \" :spelldump! includes the number of times a word was found while updating\n  \" the screen.\n  \" Common word count starts at 10, regular word count starts at 0.\n  call assert_notequal(0, search(\"^is\\t11$\"))    \" common word found once.\n  call assert_notequal(0, search(\"^the\\t10$\"))   \" common word never found.\n  call assert_notequal(0, search(\"^sample\\t1$\")) \" regular word found once.\n  call assert_equal(0, search(\"^screen\\t\"))      \" regular word never found.\n\n  %bwipe!\n  set spell&\nendfunc\n\nfunc Test_spelllang_inv_region()\n  set spell spelllang=en_xx\n  let messages = GetMessages()\n  call assert_equal('Warning: region xx not supported', messages[-1])\n  set spell& spelllang&\nendfunc\n\nfunc Test_compl_with_CTRL_X_CTRL_K_using_spell()\n  \" When spell checking is enabled and 'dictionary' is empty,\n  \" CTRL-X CTRL-K in insert mode completes using the spelling dictionary.\n  new\n  set spell spelllang=en dictionary=\n\n  set ignorecase\n  call feedkeys(\"Senglis\\<c-x>\\<c-k>\\<esc>\", 'tnx')\n  call assert_equal(['English'], getline(1, '$'))\n  call feedkeys(\"SEnglis\\<c-x>\\<c-k>\\<esc>\", 'tnx')\n  call assert_equal(['English'], getline(1, '$'))\n\n  set noignorecase\n  call feedkeys(\"Senglis\\<c-x>\\<c-k>\\<esc>\", 'tnx')\n  call assert_equal(['englis'], getline(1, '$'))\n  call feedkeys(\"SEnglis\\<c-x>\\<c-k>\\<esc>\", 'tnx')\n  call assert_equal(['English'], getline(1, '$'))\n\n  set spelllang=en_us\n  call feedkeys(\"Stheat\\<c-x>\\<c-k>\\<esc>\", 'tnx')\n  call assert_equal(['theater'], getline(1, '$'))\n  set spelllang=en_gb\n  call feedkeys(\"Stheat\\<c-x>\\<c-k>\\<esc>\", 'tnx')\n  \" FIXME: commented out, expected theatre bug got theater. See issue #7025.\n  \" call assert_equal(['theatre'], getline(1, '$'))\n\n  bwipe!\n  set spell& spelllang& dictionary& ignorecase&\nendfunc\n\nfunc Test_spellreall()\n  new\n  set spell\n  call assert_fails('spellrepall', 'E752:')\n  call setline(1, ['A speling mistake. The same speling mistake.',\n        \\                'Another speling mistake.'])\n  call feedkeys(']s1z=', 'tx')\n  call assert_equal('A spelling mistake. The same speling mistake.', getline(1))\n  call assert_equal('Another speling mistake.', getline(2))\n  spellrepall\n  call assert_equal('A spelling mistake. The same spelling mistake.', getline(1))\n  call assert_equal('Another spelling mistake.', getline(2))\n  call assert_fails('spellrepall', 'E753:')\n  set spell&\n  bwipe!\nendfunc\n\n\" Test spellsuggest({word} [, {max} [, {capital}]])\nfunc Test_spellsuggest()\n  \" Verify suggestions are given even when spell checking is not enabled.\n  set nospell\n  call assert_equal(['march', 'March'], spellsuggest('marrch', 2))\n\n  set spell\n\n  \" With 1 argument.\n  call assert_equal(['march', 'March'], spellsuggest('marrch')[0:1])\n\n  \" With 2 arguments.\n  call assert_equal(['march', 'March'], spellsuggest('marrch', 2))\n\n  \" With 3 arguments.\n  call assert_equal(['march'], spellsuggest('marrch', 1, 0))\n  call assert_equal(['March'], spellsuggest('marrch', 1, 1))\n\n  \" Test with digits and hyphen.\n  call assert_equal('Carbon-14', spellsuggest('Carbon-15')[0])\n\n  \" Comment taken from spellsuggest.c explains the following test cases:\n  \"\n  \" If there are more UPPER than lower case letters suggest an\n  \" ALLCAP word.  Otherwise, if the first letter is UPPER then\n  \" suggest ONECAP.  Exception: \"ALl\" most likely should be \"All\",\n  \" require three upper case letters.\n  call assert_equal(['THIRD', 'third'], spellsuggest('thIRD', 2))\n  call assert_equal(['third', 'THIRD'], spellsuggest('tHIrd', 2))\n  call assert_equal(['Third'], spellsuggest('THird', 1))\n  call assert_equal(['All'],      spellsuggest('ALl', 1))\n\n  \" Special suggestion for repeated 'the the'.\n  call assert_inrange(0, 2, index(spellsuggest('the the',   3), 'the'))\n  call assert_inrange(0, 2, index(spellsuggest('the   the', 3), 'the'))\n  call assert_inrange(0, 2, index(spellsuggest('The the',   3), 'The'))\n\n  call assert_fails(\"call spellsuggest('maxch', [])\", 'E745:')\n  call assert_fails(\"call spellsuggest('maxch', 2, [])\", 'E745:')\n\n  set spelllang=\n  call assert_fails(\"call spellsuggest('maxch')\", 'E756:')\n  set spelllang&\n\n  set spell&\nendfunc\n\n\" Test 'spellsuggest' option with methods fast, best and double.\nfunc Test_spellsuggest_option_methods()\n  set spell\n\n  for e in ['latin1', 'utf-8']\n    exe 'set encoding=' .. e\n\n    set spellsuggest=fast\n    call assert_equal(['Stick', 'Stitch'], spellsuggest('Stich', 2), e)\n\n    \" With best or double option, \"Stitch\" should become the top suggestion\n    \" because of better phonetic matching.\n    set spellsuggest=best\n    call assert_equal(['Stitch', 'Stick'], spellsuggest('Stich', 2), e)\n\n    set spellsuggest=double\n    call assert_equal(['Stitch', 'Stick'], spellsuggest('Stich', 2), e)\n  endfor\n\n  set spell& spellsuggest& encoding&\nendfunc\n\n\" Test 'spellsuggest' option with value file:{filename}\nfunc Test_spellsuggest_option_file()\n  set spell spellsuggest=file:Xspellsuggest\n  call writefile(['emacs/vim',\n        \\         'theribal/terrible',\n        \\         'teribal/terrrible',\n        \\         'terribal'],\n        \\         'Xspellsuggest')\n\n  call assert_equal(['vim'],      spellsuggest('emacs', 2))\n  call assert_equal(['terrible'], spellsuggest('theribal',2))\n\n  \" If the suggestion is misspelled (*terrrible* with 3 r),\n  \" it should not be proposed.\n  \" The entry for \"terribal\" should be ignored because of missing slash.\n  call assert_equal([], spellsuggest('teribal', 2))\n  call assert_equal([], spellsuggest('terribal', 2))\n\n  set spell spellsuggest=best,file:Xspellsuggest\n  call assert_equal(['vim', 'Emacs'],       spellsuggest('emacs', 2))\n  call assert_equal(['terrible', 'tribal'], spellsuggest('theribal', 2))\n  call assert_equal(['tribal'],             spellsuggest('teribal', 1))\n  call assert_equal(['tribal'],             spellsuggest('terribal', 1))\n\n  call delete('Xspellsuggest')\n  call assert_fails(\"call spellsuggest('vim')\", \"E484: Can't open file Xspellsuggest\")\n\n  set spellsuggest& spell&\nendfunc\n\n\" Test 'spellsuggest' option with value {number}\n\" to limit the number of suggestions\nfunc Test_spellsuggest_option_number()\n  set spell spellsuggest=2,best\n  new\n\n  \" We limited the number of suggestions to 2, so selecting\n  \" the 1st and 2nd suggestion should correct the word, but\n  \" selecting a 3rd suggestion should do nothing.\n  call setline(1, 'A baord')\n  norm $1z=\n  call assert_equal('A board', getline(1))\n\n  call setline(1, 'A baord')\n  norm $2z=\n  call assert_equal('A bard', getline(1))\n\n  call setline(1, 'A baord')\n  norm $3z=\n  call assert_equal('A baord', getline(1))\n\n  let a = execute('norm $z=')\n  call assert_equal(\n  \\    \"\\n\"\n  \\ .. \"Change \\\"baord\\\" to:\\n\"\n  \\ .. \" 1 \\\"board\\\"\\n\"\n  \\ .. \" 2 \\\"bard\\\"\\n\"\n  \\ .. \"Type number and <Enter> or click with the mouse (q or empty cancels): \", a)\n\n  set spell spellsuggest=0\n  call assert_equal(\"\\nSorry, no suggestions\", execute('norm $z='))\n\n  \" Unlike z=, function spellsuggest(...) should not be affected by the\n  \" max number of suggestions (2) set by the 'spellsuggest' option.\n  call assert_equal(['board', 'bard', 'broad'], spellsuggest('baord', 3))\n\n  set spellsuggest& spell&\n  bwipe!\nendfunc\n\n\" Test 'spellsuggest' option with value expr:{expr}\nfunc Test_spellsuggest_option_expr()\n  \" A silly 'spellsuggest' function which makes suggestions all uppercase\n  \" and makes the score of each suggestion the length of the suggested word.\n  \" So shorter suggestions are preferred.\n  func MySuggest()\n    let spellsuggest_save = &spellsuggest\n    set spellsuggest=3,best\n    let result = map(spellsuggest(v:val, 3), \"[toupper(v:val), len(v:val)]\")\n    let &spellsuggest = spellsuggest_save\n    return result\n  endfunc\n\n  set spell spellsuggest=expr:MySuggest()\n  call assert_equal(['BARD', 'BOARD', 'BROAD'], spellsuggest('baord', 3))\n\n  new\n  call setline(1, 'baord')\n  let a = execute('norm z=')\n  call assert_equal(\n  \\    \"\\n\"\n  \\ .. \"Change \\\"baord\\\" to:\\n\"\n  \\ .. \" 1 \\\"BARD\\\"\\n\"\n  \\ .. \" 2 \\\"BOARD\\\"\\n\"\n  \\ .. \" 3 \\\"BROAD\\\"\\n\"\n  \\ .. \"Type number and <Enter> or click with the mouse (q or empty cancels): \", a)\n\n  \" With verbose, z= should show the score i.e. word length with\n  \" our SpellSuggest() function.\n  set verbose=1\n  let a = execute('norm z=')\n  call assert_equal(\n  \\    \"\\n\"\n  \\ .. \"Change \\\"baord\\\" to:\\n\"\n  \\ .. \" 1 \\\"BARD\\\"                      (4 - 0)\\n\"\n  \\ .. \" 2 \\\"BOARD\\\"                     (5 - 0)\\n\"\n  \\ .. \" 3 \\\"BROAD\\\"                     (5 - 0)\\n\"\n  \\ .. \"Type number and <Enter> or click with the mouse (q or empty cancels): \", a)\n\n  set spell& spellsuggest& verbose&\n  bwipe!\nendfunc\n\n\" Test for 'spellsuggest' expr errrors\nfunc Test_spellsuggest_expr_errors()\n  \" 'spellsuggest'\n  func MySuggest()\n    return range(3)\n  endfunc\n  set spell spellsuggest=expr:MySuggest()\n  call assert_equal([], spellsuggest('baord', 3))\n\n  \" Test for 'spellsuggest' expression returning a non-list value\n  func! MySuggest2()\n    return 'good'\n  endfunc\n  set spellsuggest=expr:MySuggest2()\n  call assert_equal([], spellsuggest('baord'))\n\n  \" Test for 'spellsuggest' expression returning a list with dict values\n  func! MySuggest3()\n    return [[{}, {}]]\n  endfunc\n  set spellsuggest=expr:MySuggest3()\n  call assert_fails(\"call spellsuggest('baord')\", 'E731:')\n\n  set nospell spellsuggest&\n  delfunc MySuggest\n  delfunc MySuggest2\n  delfunc MySuggest3\nendfunc\n\nfunc Test_spellinfo()\n  new\n  let runtime = substitute($VIMRUNTIME, '\\\\', '/', 'g')\n\n  set enc=latin1 spell spelllang=en\n  call assert_match(\"^\\nfile: \" .. runtime .. \"/spell/en.latin1.spl\\n$\", execute('spellinfo'))\n\n  set enc=cp1250 spell spelllang=en\n  call assert_match(\"^\\nfile: \" .. runtime .. \"/spell/en.ascii.spl\\n$\", execute('spellinfo'))\n\n  set enc=utf-8 spell spelllang=en\n  call assert_match(\"^\\nfile: \" .. runtime .. \"/spell/en.utf-8.spl\\n$\", execute('spellinfo'))\n\n  set enc=latin1 spell spelllang=en_us,en_nz\n  call assert_match(\"^\\n\" .\n                 \\  \"file: \" .. runtime .. \"/spell/en.latin1.spl\\n\" .\n                 \\  \"file: \" .. runtime.. \"/spell/en.latin1.spl\\n$\", execute('spellinfo'))\n\n  set spell spelllang=\n  call assert_fails('spellinfo', 'E756:')\n\n  set nospell spelllang=en\n  call assert_fails('spellinfo', 'E756:')\n\n  call assert_fails('set spelllang=foo/bar', 'E474:')\n  call assert_fails('set spelllang=foo\\ bar', 'E474:')\n  call assert_fails(\"set spelllang=foo\\\\\\nbar\", 'E474:')\n  call assert_fails(\"set spelllang=foo\\\\\\rbar\", 'E474:')\n  call assert_fails(\"set spelllang=foo+bar\", 'E474:')\n\n  set enc& spell& spelllang&\n  bwipe\nendfunc\n\nfunc Test_zz_basic()\n  call LoadAffAndDic(g:test_data_aff1, g:test_data_dic1)\n  call RunGoodBad(\"wrong OK puts. Test the end\",\n        \\ \"bad: inputs comment ok Ok. test d\\xE9\\xF4l end the\",\n        \\[\"Comment\", \"deol\", \"d\\xE9\\xF4r\", \"input\", \"OK\", \"output\", \"outputs\", \"outtest\", \"put\", \"puts\",\n        \\  \"test\", \"testen\", \"testn\", \"the end\", \"uk\", \"wrong\"],\n        \\[\n        \\   [\"bad\", [\"put\", \"uk\", \"OK\"]],\n        \\   [\"inputs\", [\"input\", \"puts\", \"outputs\"]],\n        \\   [\"comment\", [\"Comment\", \"outtest\", \"the end\"]],\n        \\   [\"ok\", [\"OK\", \"uk\", \"put\"]],\n        \\   [\"Ok\", [\"OK\", \"Uk\", \"Put\"]],\n        \\   [\"test\", [\"Test\", \"testn\", \"testen\"]],\n        \\   [\"d\\xE9\\xF4l\", [\"deol\", \"d\\xE9\\xF4r\", \"test\"]],\n        \\   [\"end\", [\"put\", \"uk\", \"test\"]],\n        \\   [\"the\", [\"put\", \"uk\", \"test\"]],\n        \\ ]\n        \\ )\n\n  call assert_equal(\"gebletegek\", soundfold('goobledygoook'))\n  call assert_equal(\"kepereneven\", 'k\u00f3op\u00ebr\u02d9n\u00f4ven'->soundfold())\n  call assert_equal(\"everles gesvets etele\", soundfold('oeverloos gezwets edale'))\nendfunc\n\n\" Postponed prefixes\nfunc Test_zz_prefixes()\n  call LoadAffAndDic(g:test_data_aff2, g:test_data_dic1)\n  call RunGoodBad(\"puts\",\n        \\ \"bad: inputs comment ok Ok end the. test d\\xE9\\xF4l\",\n        \\ [\"Comment\", \"deol\", \"d\\xE9\\xF4r\", \"OK\", \"put\", \"input\", \"output\", \"puts\", \"outputs\", \"test\", \"outtest\", \"testen\", \"testn\", \"the end\", \"uk\", \"wrong\"],\n        \\ [\n        \\   [\"bad\", [\"put\", \"uk\", \"OK\"]],\n        \\   [\"inputs\", [\"input\", \"puts\", \"outputs\"]],\n        \\   [\"comment\", [\"Comment\"]],\n        \\   [\"ok\", [\"OK\", \"uk\", \"put\"]],\n        \\   [\"Ok\", [\"OK\", \"Uk\", \"Put\"]],\n        \\   [\"end\", [\"put\", \"uk\", \"deol\"]],\n        \\   [\"the\", [\"put\", \"uk\", \"test\"]],\n        \\   [\"test\", [\"Test\", \"testn\", \"testen\"]],\n        \\   [\"d\\xE9\\xF4l\", [\"deol\", \"d\\xE9\\xF4r\", \"test\"]],\n        \\ ])\nendfunc\n\n\"Compound words\nfunc Test_zz_compound()\n  call LoadAffAndDic(g:test_data_aff3, g:test_data_dic3)\n  call RunGoodBad(\"foo m\\xEF foobar foofoobar barfoo barbarfoo\",\n        \\ \"bad: bar la foom\\xEF barm\\xEF m\\xEFfoo m\\xEFbar m\\xEFm\\xEF lala m\\xEFla lam\\xEF foola labar\",\n        \\ [\"foo\", \"m\\xEF\"],\n        \\ [\n        \\   [\"bad\", [\"foo\", \"m\\xEF\"]],\n        \\   [\"bar\", [\"barfoo\", \"foobar\", \"foo\"]],\n        \\   [\"la\", [\"m\\xEF\", \"foo\"]],\n        \\   [\"foom\\xEF\", [\"foo m\\xEF\", \"foo\", \"foofoo\"]],\n        \\   [\"barm\\xEF\", [\"barfoo\", \"m\\xEF\", \"barbar\"]],\n        \\   [\"m\\xEFfoo\", [\"m\\xEF foo\", \"foo\", \"foofoo\"]],\n        \\   [\"m\\xEFbar\", [\"foobar\", \"barbar\", \"m\\xEF\"]],\n        \\   [\"m\\xEFm\\xEF\", [\"m\\xEF m\\xEF\", \"m\\xEF\"]],\n        \\   [\"lala\", []],\n        \\   [\"m\\xEFla\", [\"m\\xEF\", \"m\\xEF m\\xEF\"]],\n        \\   [\"lam\\xEF\", [\"m\\xEF\", \"m\\xEF m\\xEF\"]],\n        \\   [\"foola\", [\"foo\", \"foobar\", \"foofoo\"]],\n        \\   [\"labar\", [\"barbar\", \"foobar\"]],\n        \\ ])\n\n  call LoadAffAndDic(g:test_data_aff4, g:test_data_dic4)\n  call RunGoodBad(\"word util bork prebork start end wordutil wordutils pro-ok bork borkbork borkborkbork borkborkborkbork borkborkborkborkbork tomato tomatotomato startend startword startwordword startwordend startwordwordend startwordwordwordend prebork preborkbork preborkborkbork nouword\",\n        \\ \"bad: wordutilize pro borkborkborkborkborkbork tomatotomatotomato endstart endend startstart wordend wordstart preborkprebork  preborkpreborkbork startwordwordwordwordend borkpreborkpreborkbork utilsbork  startnouword\",\n        \\ [\"bork\", \"prebork\", \"end\", \"pro-ok\", \"start\", \"tomato\", \"util\", \"utilize\", \"utils\", \"word\", \"nouword\"],\n        \\ [\n        \\   [\"bad\", [\"end\", \"bork\", \"word\"]],\n        \\   [\"wordutilize\", [\"word utilize\", \"wordutils\", \"wordutil\"]],\n        \\   [\"pro\", [\"bork\", \"word\", \"end\"]],\n        \\   [\"borkborkborkborkborkbork\", [\"bork borkborkborkborkbork\", \"borkbork borkborkborkbork\", \"borkborkbork borkborkbork\"]],\n        \\   [\"tomatotomatotomato\", [\"tomato tomatotomato\", \"tomatotomato tomato\", \"tomato tomato tomato\"]],\n        \\   [\"endstart\", [\"end start\", \"start\"]],\n        \\   [\"endend\", [\"end end\", \"end\"]],\n        \\   [\"startstart\", [\"start start\"]],\n        \\   [\"wordend\", [\"word end\", \"word\", \"wordword\"]],\n        \\   [\"wordstart\", [\"word start\", \"bork start\"]],\n        \\   [\"preborkprebork\", [\"prebork prebork\", \"preborkbork\", \"preborkborkbork\"]],\n        \\   [\"preborkpreborkbork\", [\"prebork preborkbork\", \"preborkborkbork\", \"preborkborkborkbork\"]],\n        \\   [\"startwordwordwordwordend\", [\"startwordwordwordword end\", \"startwordwordwordword\", \"start wordwordwordword end\"]],\n        \\   [\"borkpreborkpreborkbork\", [\"bork preborkpreborkbork\", \"bork prebork preborkbork\", \"bork preborkprebork bork\"]],\n        \\   [\"utilsbork\", [\"utilbork\", \"utils bork\", \"util bork\"]],\n        \\   [\"startnouword\", [\"start nouword\", \"startword\", \"startborkword\"]],\n        \\ ])\n\nendfunc\n\n\"Test affix flags with two characters\nfunc Test_zz_affix()\n  call LoadAffAndDic(g:test_data_aff5, g:test_data_dic5)\n  call RunGoodBad(\"fooa1 fooa\\xE9 bar prebar barbork prebarbork  startprebar start end startend  startmiddleend nouend\",\n        \\ \"bad: foo fooa2 prabar probarbirk middle startmiddle middleend endstart startprobar startnouend\",\n        \\ [\"bar\", \"barbork\", \"end\", \"fooa1\", \"fooa\\xE9\", \"nouend\", \"prebar\", \"prebarbork\", \"start\"],\n        \\ [\n        \\   [\"bad\", [\"bar\", \"end\", \"fooa1\"]],\n        \\   [\"foo\", [\"fooa1\", \"fooa\\xE9\", \"bar\"]],\n        \\   [\"fooa2\", [\"fooa1\", \"fooa\\xE9\", \"bar\"]],\n        \\   [\"prabar\", [\"prebar\", \"bar\", \"bar bar\"]],\n        \\   [\"probarbirk\", [\"prebarbork\"]],\n        \\   [\"middle\", []],\n        \\   [\"startmiddle\", [\"startmiddleend\", \"startmiddlebar\"]],\n        \\   [\"middleend\", []],\n        \\   [\"endstart\", [\"end start\", \"start\"]],\n        \\   [\"startprobar\", [\"startprebar\", \"start prebar\", \"startbar\"]],\n        \\   [\"startnouend\", [\"start nouend\", \"startend\"]],\n        \\ ])\n\n  call LoadAffAndDic(g:test_data_aff6, g:test_data_dic6)\n  call RunGoodBad(\"meea1 meea\\xE9 bar prebar barbork prebarbork  leadprebar lead end leadend  leadmiddleend\",\n        \\  \"bad: mee meea2 prabar probarbirk middle leadmiddle middleend endlead leadprobar\",\n        \\ [\"bar\", \"barbork\", \"end\", \"lead\", \"meea1\", \"meea\\xE9\", \"prebar\", \"prebarbork\"],\n        \\ [\n        \\   [\"bad\", [\"bar\", \"end\", \"lead\"]],\n        \\   [\"mee\", [\"meea1\", \"meea\\xE9\", \"bar\"]],\n        \\   [\"meea2\", [\"meea1\", \"meea\\xE9\", \"lead\"]],\n        \\   [\"prabar\", [\"prebar\", \"bar\", \"leadbar\"]],\n        \\   [\"probarbirk\", [\"prebarbork\"]],\n        \\   [\"middle\", []],\n        \\   [\"leadmiddle\", [\"leadmiddleend\", \"leadmiddlebar\"]],\n        \\   [\"middleend\", []],\n        \\   [\"endlead\", [\"end lead\", \"lead\", \"end end\"]],\n        \\   [\"leadprobar\", [\"leadprebar\", \"lead prebar\", \"leadbar\"]],\n        \\ ])\n\n  call LoadAffAndDic(g:test_data_aff7, g:test_data_dic7)\n  call RunGoodBad(\"meea1 meezero meea\\xE9 bar prebar barmeat prebarmeat  leadprebar lead tail leadtail  leadmiddletail\",\n        \\ \"bad: mee meea2 prabar probarmaat middle leadmiddle middletail taillead leadprobar\",\n        \\ [\"bar\", \"barmeat\", \"lead\", \"meea1\", \"meea\\xE9\", \"meezero\", \"prebar\", \"prebarmeat\", \"tail\"],\n        \\ [\n        \\   [\"bad\", [\"bar\", \"lead\", \"tail\"]],\n        \\   [\"mee\", [\"meea1\", \"meea\\xE9\", \"bar\"]],\n        \\   [\"meea2\", [\"meea1\", \"meea\\xE9\", \"lead\"]],\n        \\   [\"prabar\", [\"prebar\", \"bar\", \"leadbar\"]],\n        \\   [\"probarmaat\", [\"prebarmeat\"]],\n        \\   [\"middle\", []],\n        \\   [\"leadmiddle\", [\"leadmiddlebar\"]],\n        \\   [\"middletail\", []],\n        \\   [\"taillead\", [\"tail lead\", \"tail\"]],\n        \\   [\"leadprobar\", [\"leadprebar\", \"lead prebar\", \"leadbar\"]],\n        \\ ])\nendfunc\n\nfunc Test_zz_NOSLITSUGS()\n  call LoadAffAndDic(g:test_data_aff8, g:test_data_dic8)\n  call RunGoodBad(\"foo bar faabar\", \"bad: foobar barfoo\",\n        \\ [\"bar\", \"faabar\", \"foo\"],\n        \\ [\n        \\   [\"bad\", [\"bar\", \"foo\"]],\n        \\   [\"foobar\", [\"faabar\", \"foo bar\", \"bar\"]],\n        \\   [\"barfoo\", [\"bar foo\", \"bar\", \"foo\"]],\n        \\ ])\nendfunc\n\n\" Numbers\nfunc Test_zz_Numbers()\n  call LoadAffAndDic(g:test_data_aff9, g:test_data_dic9)\n  call RunGoodBad(\"0b1011 0777 1234 0x01ff\", \"\",\n        \\ [\"bar\", \"foo\"],\n        \\ [\n        \\ ])\nendfunc\n\n\" Affix flags\nfunc Test_zz_affix_flags()\n  call LoadAffAndDic(g:test_data_aff10, g:test_data_dic10)\n  call RunGoodBad(\"drink drinkable drinkables drinktable drinkabletable\",\n\t\\ \"bad: drinks drinkstable drinkablestable\",\n        \\ [\"drink\", \"drinkable\", \"drinkables\", \"table\"],\n        \\ [['bad', []],\n\t\\ ['drinks', ['drink']],\n\t\\ ['drinkstable', ['drinktable', 'drinkable', 'drink table']],\n        \\ ['drinkablestable', ['drinkabletable', 'drinkables table', 'drinkable table']],\n\t\\ ])\nendfunc\n\nfunction FirstSpellWord()\n  call feedkeys(\"/^start:\\n\", 'tx')\n  normal ]smm\n  let [str, a] = spellbadword()\n  return str\nendfunc\n\nfunction SecondSpellWord()\n  normal `m]s\n  let [str, a] = spellbadword()\n  return str\nendfunc\n\n\"Test with SAL instead of SOFO items; test automatic reloading\nfunc Test_zz_sal_and_addition()\n  set enc=latin1\n  set spellfile=\n  call writefile(g:test_data_dic1, \"Xtest.dic\")\n  call writefile(g:test_data_aff_sal, \"Xtest.aff\")\n  mkspell! Xtest Xtest\n  set spl=Xtest.latin1.spl spell\n  call assert_equal('kbltykk', soundfold('goobledygoook'))\n  call assert_equal('kprnfn', soundfold('k\u00f3op\u00ebr\u02d9n\u00f4ven'))\n  call assert_equal('*fls kswts tl', soundfold('oeverloos gezwets edale'))\n\n  \"also use an addition file\n  call writefile([\"/regions=usgbnz\", \"elequint/2\", \"elekwint/3\"], \"Xtest.latin1.add\")\n  mkspell! Xtest.latin1.add.spl Xtest.latin1.add\n\n  bwipe!\n  call setline(1, [\"start: elequint test elekwint test elekwent asdf\"])\n\n  set spellfile=Xtest.latin1.add\n  call assert_equal(\"elekwent\", FirstSpellWord())\n\n  set spl=Xtest_us.latin1.spl\n  call assert_equal(\"elequint\", FirstSpellWord())\n  call assert_equal(\"elekwint\", SecondSpellWord())\n\n  set spl=Xtest_gb.latin1.spl\n  call assert_equal(\"elekwint\", FirstSpellWord())\n  call assert_equal(\"elekwent\", SecondSpellWord())\n\n  set spl=Xtest_nz.latin1.spl\n  call assert_equal(\"elequint\", FirstSpellWord())\n  call assert_equal(\"elekwent\", SecondSpellWord())\n\n  set spl=Xtest_ca.latin1.spl\n  call assert_equal(\"elequint\", FirstSpellWord())\n  call assert_equal(\"elekwint\", SecondSpellWord())\nendfunc\n\nfunc Test_spellfile_value()\n  set spellfile=Xdir/Xtest.latin1.add\n  set spellfile=Xdir/Xtest.utf-8.add,Xtest_other.add\nendfunc\n\nfunc Test_region_error()\n  messages clear\n  call writefile([\"/regions=usgbnz\", \"elequint/0\"], \"Xtest.latin1.add\")\n  mkspell! Xtest.latin1.add.spl Xtest.latin1.add\n  call assert_match('Invalid region nr in Xtest.latin1.add line 2: 0', execute('messages'))\n  call delete('Xtest.latin1.add')\n  call delete('Xtest.latin1.add.spl')\nendfunc\n\n\" Check using z= in new buffer (crash fixed by patch 7.4a.028).\nfunc Test_zeq_crash()\n  new\n  set maxmem=512 spell\n  call feedkeys('iasd\u001bz=:\\\"', 'tx')\n\n  bwipe!\nendfunc\n\n\" Check that z= works even when 'nospell' is set.  This test uses one of the\n\" tests in Test_spellsuggest_option_number() just to verify that z= basically\n\" works and that \"E756: Spell checking is not enabled\" is not generated.\nfunc Test_zeq_nospell()\n  new\n  set nospell spellsuggest=1,best\n  call setline(1, 'A baord')\n  try\n    norm $1z=\n    call assert_equal('A board', getline(1))\n  catch\n    call assert_report(\"Caught exception: \" . v:exception)\n  endtry\n  set spell& spellsuggest&\n  bwipe!\nendfunc\n\n\" Check that \"E756: Spell checking is not possible\" is reported when z= is\n\" executed and 'spelllang' is empty.\nfunc Test_zeq_no_spelllang()\n  new\n  set spelllang= spellsuggest=1,best\n  call setline(1, 'A baord')\n  call assert_fails('normal $1z=', 'E756:')\n  set spelllang& spellsuggest&\n  bwipe!\nendfunc\n\n\" Check handling a word longer than MAXWLEN.\nfunc Test_spell_long_word()\n  set enc=utf-8\n  new\n  call setline(1, \"d\\xCC\\xB4\\xCC\\xBD\\xCD\\x88\\xCD\\x94a\\xCC\\xB5\\xCD\\x84\\xCD\\x84\\xCC\\xA8\\xCD\\x9Cr\\xCC\\xB5\\xCC\\x8E\\xCD\\x85\\xCD\\x85k\\xCC\\xB6\\xCC\\x89\\xCC\\x9D \\xCC\\xB6\\xCC\\x83\\xCC\\x8F\\xCC\\xA4\\xCD\\x8Ef\\xCC\\xB7\\xCC\\x81\\xCC\\x80\\xCC\\xA9\\xCC\\xB0\\xCC\\xAC\\xCC\\xA2\\xCD\\x95\\xCD\\x87\\xCD\\x8D\\xCC\\x9E\\xCD\\x99\\xCC\\xAD\\xCC\\xAB\\xCC\\x97\\xCC\\xBBo\\xCC\\xB6\\xCC\\x84\\xCC\\x95\\xCC\\x8C\\xCC\\x8B\\xCD\\x9B\\xCD\\x9C\\xCC\\xAFr\\xCC\\xB7\\xCC\\x94\\xCD\\x83\\xCD\\x97\\xCC\\x8C\\xCC\\x82\\xCD\\x82\\xCD\\x80\\xCD\\x91\\xCC\\x80\\xCC\\xBE\\xCC\\x82\\xCC\\x8F\\xCC\\xA3\\xCD\\x85\\xCC\\xAE\\xCD\\x8D\\xCD\\x99\\xCC\\xBC\\xCC\\xAB\\xCC\\xA7\\xCD\\x88c\\xCC\\xB7\\xCD\\x83\\xCC\\x84\\xCD\\x92\\xCC\\x86\\xCC\\x83\\xCC\\x88\\xCC\\x92\\xCC\\x94\\xCC\\xBE\\xCC\\x9D\\xCC\\xAF\\xCC\\x98\\xCC\\x9D\\xCC\\xBB\\xCD\\x8E\\xCC\\xBB\\xCC\\xB3\\xCC\\xA3\\xCD\\x8E\\xCD\\x99\\xCC\\xA5\\xCC\\xAD\\xCC\\x99\\xCC\\xB9\\xCC\\xAE\\xCC\\xA5\\xCC\\x9E\\xCD\\x88\\xCC\\xAE\\xCC\\x9E\\xCC\\xA9\\xCC\\x97\\xCC\\xBC\\xCC\\x99\\xCC\\xA5\\xCD\\x87\\xCC\\x97\\xCD\\x8E\\xCD\\x94\\xCC\\x99\\xCC\\x9D\\xCC\\x96\\xCD\\x94\\xCC\\xAB\\xCC\\xA7\\xCC\\xA5\\xCC\\x98\\xCC\\xBB\\xCC\\xAF\\xCC\\xABe\\xCC\\xB7\\xCC\\x8E\\xCC\\x82\\xCD\\x86\\xCD\\x9B\\xCC\\x94\\xCD\\x83\\xCC\\x85\\xCD\\x8A\\xCD\\x8C\\xCC\\x8B\\xCD\\x92\\xCD\\x91\\xCC\\x8F\\xCC\\x81\\xCD\\x95\\xCC\\xA2\\xCC\\xB9\\xCC\\xB2\\xCD\\x9C\\xCC\\xB1\\xCC\\xA6\\xCC\\xB3\\xCC\\xAF\\xCC\\xAE\\xCC\\x9C\\xCD\\x99s\\xCC\\xB8\\xCC\\x8C\\xCC\\x8E\\xCC\\x87\\xCD\\x81\\xCD\\x82\\xCC\\x86\\xCD\\x8C\\xCD\\x8C\\xCC\\x8B\\xCC\\x84\\xCC\\x8C\\xCD\\x84\\xCD\\x9B\\xCD\\x86\\xCC\\x93\\xCD\\x90\\xCC\\x85\\xCC\\x94\\xCD\\x98\\xCD\\x84\\xCD\\x92\\xCD\\x8B\\xCC\\x90\\xCC\\x83\\xCC\\x8F\\xCD\\x84\\xCD\\x81\\xCD\\x9B\\xCC\\x90\\xCD\\x81\\xCC\\x8F\\xCC\\xBD\\xCC\\x88\\xCC\\xBF\\xCC\\x88\\xCC\\x84\\xCC\\x8E\\xCD\\x99\\xCD\\x94\\xCC\\x99\\xCD\\x99\\xCC\\xB0\\xCC\\xA8\\xCC\\xA3\\xCC\\xA8\\xCC\\x96\\xCC\\x99\\xCC\\xAE\\xCC\\xBC\\xCC\\x99\\xCD\\x9A\\xCC\\xB2\\xCC\\xB1\\xCC\\x9F\\xCC\\xBB\\xCC\\xA6\\xCD\\x85\\xCC\\xAA\\xCD\\x89\\xCC\\x9D\\xCC\\x99\\xCD\\x96\\xCC\\xB1\\xCC\\xB1\\xCC\\x99\\xCC\\xA6\\xCC\\xA5\\xCD\\x95\\xCC\\xB2\\xCC\\xA0\\xCD\\x99 within\")\n  set spell spelllang=en\n  redraw\n  redraw!\n  bwipe!\n  set nospell\nendfunc\n\nfunc LoadAffAndDic(aff_contents, dic_contents)\n  set enc=latin1\n  set spellfile=\n  call writefile(a:aff_contents, \"Xtest.aff\")\n  call writefile(a:dic_contents, \"Xtest.dic\")\n  \" Generate a .spl file from a .dic and .aff file.\n  mkspell! Xtest Xtest\n  \" use that spell file\n  set spl=Xtest.latin1.spl spell\nendfunc\n\nfunc ListWords()\n  spelldump\n  %yank\n  quit\n  return split(@\", \"\\n\")\nendfunc\n\nfunc TestGoodBadBase()\n  exe '1;/^good:'\n  normal 0f:]s\n  let prevbad = ''\n  let result = []\n  while 1\n    let [bad, a] = spellbadword()\n    if bad == '' || bad == prevbad || bad == 'badend'\n      break\n    endif\n    let prevbad = bad\n    let lst = bad->spellsuggest(3)\n    normal mm\n\n    call add(result, [bad, lst])\n    normal `m]s\n  endwhile\n  return result\nendfunc\n\nfunc RunGoodBad(good, bad, expected_words, expected_bad_words)\n  bwipe!\n  call setline(1, [\"good: \", a:good,  a:bad, \" badend \"])\n  let words = ListWords()\n  call assert_equal(a:expected_words, words[1:-1])\n  let bad_words = TestGoodBadBase()\n  call assert_equal(a:expected_bad_words, bad_words)\n  bwipe!\nendfunc\n\nfunc Test_spell_screendump()\n  CheckScreendump\n\n  let lines =<< trim END\n       call setline(1, [\n             \\ \"This is some text without any spell errors.  Everything\",\n             \\ \"should just be black, nothing wrong here.\",\n             \\ \"\",\n             \\ \"This line has a sepll error. and missing caps.\",\n             \\ \"And and this is the the duplication.\",\n             \\ \"with missing caps here.\",\n             \\ ])\n       set spell spelllang=en_nz\n  END\n  call writefile(lines, 'XtestSpell')\n  let buf = RunVimInTerminal('-S XtestSpell', {'rows': 8})\n  call VerifyScreenDump(buf, 'Test_spell_1', {})\n\n  \" clean up\n  call StopVimInTerminal(buf)\n  call delete('XtestSpell')\nendfunc\n\nfunc Test_spell_single_word()\n  new\n  silent! norm 0R00\n  spell! \u00df\u00c2\n  silent 0norm 0r$ Dvz=\n  bwipe!\nendfunc\n\nlet g:test_data_aff1 = [\n      \\\"SET ISO8859-1\",\n      \\\"TRY esianrtolcdugmphbyfvkwjkqxz-\\xEB\\xE9\\xE8\\xEA\\xEF\\xEE\\xE4\\xE0\\xE2\\xF6\\xFC\\xFB'ESIANRTOLCDUGMPHBYFVKWJKQXZ\",\n      \\\"\",\n      \\\"FOL  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"LOW  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"UPP  \\xC0\\xC1\\xC2\\xC3\\xC4\\xC5\\xC6\\xC7\\xC8\\xC9\\xCA\\xCB\\xCC\\xCD\\xCE\\xCF\\xD0\\xD1\\xD2\\xD3\\xD4\\xD5\\xD6\\xD8\\xD9\\xDA\\xDB\\xDC\\xDD\\xDE\\xDF\\xFF\",\n      \\\"\",\n      \\\"SOFOFROM abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\\xC0\\xC1\\xC2\\xC3\\xC4\\xC5\\xC6\\xC7\\xC8\\xC9\\xCA\\xCB\\xCC\\xCD\\xCE\\xCF\\xD0\\xD1\\xD2\\xD3\\xD4\\xD5\\xD6\\xD8\\xD9\\xDA\\xDB\\xDC\\xDD\\xDE\\xBF\",\n      \\\"SOFOTO   ebctefghejklnnepkrstevvkesebctefghejklnnepkrstevvkeseeeeeeeceeeeeeeedneeeeeeeeeeepseeeeeeeeceeeeeeeedneeeeeeeeeeep?\",\n      \\\"\",\n      \\\"MIDWORD\\t'-\",\n      \\\"\",\n      \\\"KEP =\",\n      \\\"RAR ?\",\n      \\\"BAD !\",\n      \\\"\",\n      \\\"PFX I N 1\",\n      \\\"PFX I 0 in .\",\n      \\\"\",\n      \\\"PFX O Y 1\",\n      \\\"PFX O 0 out .\",\n      \\\"\",\n      \\\"SFX S Y 2\",\n      \\\"SFX S 0 s [^s]\",\n      \\\"SFX S 0 es s\",\n      \\\"\",\n      \\\"SFX N N 3\",\n      \\\"SFX N 0 en [^n]\",\n      \\\"SFX N 0 nen n\",\n      \\\"SFX N 0 n .\",\n      \\\"\",\n      \\\"REP 3\",\n      \\\"REP g ch\",\n      \\\"REP ch g\",\n      \\\"REP svp s.v.p.\",\n      \\\"\",\n      \\\"MAP 9\",\n      \\\"MAP a\\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\",\n      \\\"MAP e\\xE8\\xE9\\xEA\\xEB\",\n      \\\"MAP i\\xEC\\xED\\xEE\\xEF\",\n      \\\"MAP o\\xF2\\xF3\\xF4\\xF5\\xF6\",\n      \\\"MAP u\\xF9\\xFA\\xFB\\xFC\",\n      \\\"MAP n\\xF1\",\n      \\\"MAP c\\xE7\",\n      \\\"MAP y\\xFF\\xFD\",\n      \\\"MAP s\\xDF\",\n      \\ ]\nlet g:test_data_dic1 = [\n      \\\"123456\",\n      \\\"test/NO\",\n      \\\"# comment\",\n      \\\"wrong\",\n      \\\"Comment\",\n      \\\"OK\",\n      \\\"uk\",\n      \\\"put/ISO\",\n      \\\"the end\",\n      \\\"deol\",\n      \\\"d\\xE9\\xF4r\",\n      \\ ]\nlet g:test_data_aff2 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"FOL  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"LOW  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"UPP  \\xC0\\xC1\\xC2\\xC3\\xC4\\xC5\\xC6\\xC7\\xC8\\xC9\\xCA\\xCB\\xCC\\xCD\\xCE\\xCF\\xD0\\xD1\\xD2\\xD3\\xD4\\xD5\\xD6\\xD8\\xD9\\xDA\\xDB\\xDC\\xDD\\xDE\\xDF\\xFF\",\n      \\\"\",\n      \\\"PFXPOSTPONE\",\n      \\\"\",\n      \\\"MIDWORD\\t'-\",\n      \\\"\",\n      \\\"KEP =\",\n      \\\"RAR ?\",\n      \\\"BAD !\",\n      \\\"\",\n      \\\"PFX I N 1\",\n      \\\"PFX I 0 in .\",\n      \\\"\",\n      \\\"PFX O Y 1\",\n      \\\"PFX O 0 out [a-z]\",\n      \\\"\",\n      \\\"SFX S Y 2\",\n      \\\"SFX S 0 s [^s]\",\n      \\\"SFX S 0 es s\",\n      \\\"\",\n      \\\"SFX N N 3\",\n      \\\"SFX N 0 en [^n]\",\n      \\\"SFX N 0 nen n\",\n      \\\"SFX N 0 n .\",\n      \\\"\",\n      \\\"REP 3\",\n      \\\"REP g ch\",\n      \\\"REP ch g\",\n      \\\"REP svp s.v.p.\",\n      \\\"\",\n      \\\"MAP 9\",\n      \\\"MAP a\\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\",\n      \\\"MAP e\\xE8\\xE9\\xEA\\xEB\",\n      \\\"MAP i\\xEC\\xED\\xEE\\xEF\",\n      \\\"MAP o\\xF2\\xF3\\xF4\\xF5\\xF6\",\n      \\\"MAP u\\xF9\\xFA\\xFB\\xFC\",\n      \\\"MAP n\\xF1\",\n      \\\"MAP c\\xE7\",\n      \\\"MAP y\\xFF\\xFD\",\n      \\\"MAP s\\xDF\",\n      \\ ]\nlet g:test_data_aff3 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"COMPOUNDMIN 3\",\n      \\\"COMPOUNDRULE m*\",\n      \\\"NEEDCOMPOUND x\",\n      \\ ]\nlet g:test_data_dic3 = [\n      \\\"1234\",\n      \\\"foo/m\",\n      \\\"bar/mx\",\n      \\\"m\\xEF/m\",\n      \\\"la/mx\",\n      \\ ]\nlet g:test_data_aff4 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"FOL  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"LOW  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"UPP  \\xC0\\xC1\\xC2\\xC3\\xC4\\xC5\\xC6\\xC7\\xC8\\xC9\\xCA\\xCB\\xCC\\xCD\\xCE\\xCF\\xD0\\xD1\\xD2\\xD3\\xD4\\xD5\\xD6\\xD8\\xD9\\xDA\\xDB\\xDC\\xDD\\xDE\\xDF\\xFF\",\n      \\\"\",\n      \\\"COMPOUNDRULE m+\",\n      \\\"COMPOUNDRULE sm*e\",\n      \\\"COMPOUNDRULE sm+\",\n      \\\"COMPOUNDMIN 3\",\n      \\\"COMPOUNDWORDMAX 3\",\n      \\\"COMPOUNDFORBIDFLAG t\",\n      \\\"\",\n      \\\"COMPOUNDSYLMAX 5\",\n      \\\"SYLLABLE a\\xE1e\\xE9i\\xEDo\\xF3\\xF6\\xF5u\\xFA\\xFC\\xFBy/aa/au/ea/ee/ei/ie/oa/oe/oo/ou/uu/ui\",\n      \\\"\",\n      \\\"MAP 9\",\n      \\\"MAP a\\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\",\n      \\\"MAP e\\xE8\\xE9\\xEA\\xEB\",\n      \\\"MAP i\\xEC\\xED\\xEE\\xEF\",\n      \\\"MAP o\\xF2\\xF3\\xF4\\xF5\\xF6\",\n      \\\"MAP u\\xF9\\xFA\\xFB\\xFC\",\n      \\\"MAP n\\xF1\",\n      \\\"MAP c\\xE7\",\n      \\\"MAP y\\xFF\\xFD\",\n      \\\"MAP s\\xDF\",\n      \\\"\",\n      \\\"NEEDAFFIX x\",\n      \\\"\",\n      \\\"PFXPOSTPONE\",\n      \\\"\",\n      \\\"MIDWORD '-\",\n      \\\"\",\n      \\\"SFX q N 1\",\n      \\\"SFX q   0    -ok .\",\n      \\\"\",\n      \\\"SFX a Y 2\",\n      \\\"SFX a 0 s .\",\n      \\\"SFX a 0 ize/t .\",\n      \\\"\",\n      \\\"PFX p N 1\",\n      \\\"PFX p 0 pre .\",\n      \\\"\",\n      \\\"PFX P N 1\",\n      \\\"PFX P 0 nou .\",\n      \\ ]\nlet g:test_data_dic4 = [\n      \\\"1234\",\n      \\\"word/mP\",\n      \\\"util/am\",\n      \\\"pro/xq\",\n      \\\"tomato/m\",\n      \\\"bork/mp\",\n      \\\"start/s\",\n      \\\"end/e\",\n      \\ ]\nlet g:test_data_aff5 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"FLAG long\",\n      \\\"\",\n      \\\"NEEDAFFIX !!\",\n      \\\"\",\n      \\\"COMPOUNDRULE ssmm*ee\",\n      \\\"\",\n      \\\"NEEDCOMPOUND xx\",\n      \\\"COMPOUNDPERMITFLAG pp\",\n      \\\"\",\n      \\\"SFX 13 Y 1\",\n      \\\"SFX 13 0 bork .\",\n      \\\"\",\n      \\\"SFX a1 Y 1\",\n      \\\"SFX a1 0 a1 .\",\n      \\\"\",\n      \\\"SFX a\\xE9 Y 1\",\n      \\\"SFX a\\xE9 0 a\\xE9 .\",\n      \\\"\",\n      \\\"PFX zz Y 1\",\n      \\\"PFX zz 0 pre/pp .\",\n      \\\"\",\n      \\\"PFX yy Y 1\",\n      \\\"PFX yy 0 nou .\",\n      \\ ]\nlet g:test_data_dic5 = [\n      \\\"1234\",\n      \\\"foo/a1a\\xE9!!\",\n      \\\"bar/zz13ee\",\n      \\\"start/ss\",\n      \\\"end/eeyy\",\n      \\\"middle/mmxx\",\n      \\ ]\nlet g:test_data_aff6 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"FLAG caplong\",\n      \\\"\",\n      \\\"NEEDAFFIX A!\",\n      \\\"\",\n      \\\"COMPOUNDRULE sMm*Ee\",\n      \\\"\",\n      \\\"NEEDCOMPOUND Xx\",\n      \\\"\",\n      \\\"COMPOUNDPERMITFLAG p\",\n      \\\"\",\n      \\\"SFX N3 Y 1\",\n      \\\"SFX N3 0 bork .\",\n      \\\"\",\n      \\\"SFX A1 Y 1\",\n      \\\"SFX A1 0 a1 .\",\n      \\\"\",\n      \\\"SFX A\\xE9 Y 1\",\n      \\\"SFX A\\xE9 0 a\\xE9 .\",\n      \\\"\",\n      \\\"PFX Zz Y 1\",\n      \\\"PFX Zz 0 pre/p .\",\n      \\ ]\nlet g:test_data_dic6 = [\n      \\\"1234\",\n      \\\"mee/A1A\\xE9A!\",\n      \\\"bar/ZzN3Ee\",\n      \\\"lead/s\",\n      \\\"end/Ee\",\n      \\\"middle/MmXx\",\n      \\ ]\nlet g:test_data_aff7 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"FLAG num\",\n      \\\"\",\n      \\\"NEEDAFFIX 9999\",\n      \\\"\",\n      \\\"COMPOUNDRULE 2,77*123\",\n      \\\"\",\n      \\\"NEEDCOMPOUND 1\",\n      \\\"COMPOUNDPERMITFLAG 432\",\n      \\\"\",\n      \\\"SFX 61003 Y 1\",\n      \\\"SFX 61003 0 meat .\",\n      \\\"\",\n      \\\"SFX 0 Y 1\",\n      \\\"SFX 0 0 zero .\",\n      \\\"\",\n      \\\"SFX 391 Y 1\",\n      \\\"SFX 391 0 a1 .\",\n      \\\"\",\n      \\\"SFX 111 Y 1\",\n      \\\"SFX 111 0 a\\xE9 .\",\n      \\\"\",\n      \\\"PFX 17 Y 1\",\n      \\\"PFX 17 0 pre/432 .\",\n      \\ ]\nlet g:test_data_dic7 = [\n      \\\"1234\",\n      \\\"mee/0,391,111,9999\",\n      \\\"bar/17,61003,123\",\n      \\\"lead/2\",\n      \\\"tail/123\",\n      \\\"middle/77,1\",\n      \\ ]\nlet g:test_data_aff8 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"NOSPLITSUGS\",\n      \\ ]\nlet g:test_data_dic8 = [\n      \\\"1234\",\n      \\\"foo\",\n      \\\"bar\",\n      \\\"faabar\",\n      \\ ]\nlet g:test_data_aff9 = [\n      \\ ]\nlet g:test_data_dic9 = [\n      \\\"1234\",\n      \\\"foo\",\n      \\\"bar\",\n      \\ ]\nlet g:test_data_aff10 = [\n      \\\"COMPOUNDRULE se\",\n      \\\"COMPOUNDPERMITFLAG p\",\n      \\\"\",\n      \\\"SFX A Y 1\",\n      \\\"SFX A 0 able/Mp .\",\n      \\\"\",\n      \\\"SFX M Y 1\",\n      \\\"SFX M 0 s .\",\n      \\ ]\nlet g:test_data_dic10 = [\n      \\\"1234\",\n      \\\"drink/As\",\n      \\\"table/e\",\n      \\ ]\nlet g:test_data_aff_sal = [\n      \\\"SET ISO8859-1\",\n      \\\"TRY esianrtolcdugmphbyfvkwjkqxz-\\xEB\\xE9\\xE8\\xEA\\xEF\\xEE\\xE4\\xE0\\xE2\\xF6\\xFC\\xFB'ESIANRTOLCDUGMPHBYFVKWJKQXZ\",\n      \\\"\",\n      \\\"FOL  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"LOW  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"UPP  \\xC0\\xC1\\xC2\\xC3\\xC4\\xC5\\xC6\\xC7\\xC8\\xC9\\xCA\\xCB\\xCC\\xCD\\xCE\\xCF\\xD0\\xD1\\xD2\\xD3\\xD4\\xD5\\xD6\\xD8\\xD9\\xDA\\xDB\\xDC\\xDD\\xDE\\xDF\\xFF\",\n      \\\"\",\n      \\\"MIDWORD\\t'-\",\n      \\\"\",\n      \\\"KEP =\",\n      \\\"RAR ?\",\n      \\\"BAD !\",\n      \\\"\",\n      \\\"PFX I N 1\",\n      \\\"PFX I 0 in .\",\n      \\\"\",\n      \\\"PFX O Y 1\",\n      \\\"PFX O 0 out .\",\n      \\\"\",\n      \\\"SFX S Y 2\",\n      \\\"SFX S 0 s [^s]\",\n      \\\"SFX S 0 es s\",\n      \\\"\",\n      \\\"SFX N N 3\",\n      \\\"SFX N 0 en [^n]\",\n      \\\"SFX N 0 nen n\",\n      \\\"SFX N 0 n .\",\n      \\\"\",\n      \\\"REP 3\",\n      \\\"REP g ch\",\n      \\\"REP ch g\",\n      \\\"REP svp s.v.p.\",\n      \\\"\",\n      \\\"MAP 9\",\n      \\\"MAP a\\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\",\n      \\\"MAP e\\xE8\\xE9\\xEA\\xEB\",\n      \\\"MAP i\\xEC\\xED\\xEE\\xEF\",\n      \\\"MAP o\\xF2\\xF3\\xF4\\xF5\\xF6\",\n      \\\"MAP u\\xF9\\xFA\\xFB\\xFC\",\n      \\\"MAP n\\xF1\",\n      \\\"MAP c\\xE7\",\n      \\\"MAP y\\xFF\\xFD\",\n      \\\"MAP s\\xDF\",\n      \\\"\",\n      \\\"SAL AH(AEIOUY)-^         *H\",\n      \\\"SAL AR(AEIOUY)-^         *R\",\n      \\\"SAL A(HR)^               *\",\n      \\\"SAL A^                   *\",\n      \\\"SAL AH(AEIOUY)-          H\",\n      \\\"SAL AR(AEIOUY)-          R\",\n      \\\"SAL A(HR)                _\",\n      \\\"SAL \\xC0^                   *\",\n      \\\"SAL \\xC5^                   *\",\n      \\\"SAL BB-                  _\",\n      \\\"SAL B                    B\",\n      \\\"SAL CQ-                  _\",\n      \\\"SAL CIA                  X\",\n      \\\"SAL CH                   X\",\n      \\\"SAL C(EIY)-              S\",\n      \\\"SAL CK                   K\",\n      \\\"SAL COUGH^               KF\",\n      \\\"SAL CC<                  C\",\n      \\\"SAL C                    K\",\n      \\\"SAL DG(EIY)              K\",\n      \\\"SAL DD-                  _\",\n      \\\"SAL D                    T\",\n      \\\"SAL \\xC9<                   E\",\n      \\\"SAL EH(AEIOUY)-^         *H\",\n      \\\"SAL ER(AEIOUY)-^         *R\",\n      \\\"SAL E(HR)^               *\",\n      \\\"SAL ENOUGH^$             *NF\",\n      \\\"SAL E^                   *\",\n      \\\"SAL EH(AEIOUY)-          H\",\n      \\\"SAL ER(AEIOUY)-          R\",\n      \\\"SAL E(HR)                _\",\n      \\\"SAL FF-                  _\",\n      \\\"SAL F                    F\",\n      \\\"SAL GN^                  N\",\n      \\\"SAL GN$                  N\",\n      \\\"SAL GNS$                 NS\",\n      \\\"SAL GNED$                N\",\n      \\\"SAL GH(AEIOUY)-          K\",\n      \\\"SAL GH                   _\",\n      \\\"SAL GG9                  K\",\n      \\\"SAL G                    K\",\n      \\\"SAL H                    H\",\n      \\\"SAL IH(AEIOUY)-^         *H\",\n      \\\"SAL IR(AEIOUY)-^         *R\",\n      \\\"SAL I(HR)^               *\",\n      \\\"SAL I^                   *\",\n      \\\"SAL ING6                 N\",\n      \\\"SAL IH(AEIOUY)-          H\",\n      \\\"SAL IR(AEIOUY)-          R\",\n      \\\"SAL I(HR)                _\",\n      \\\"SAL J                    K\",\n      \\\"SAL KN^                  N\",\n      \\\"SAL KK-                  _\",\n      \\\"SAL K                    K\",\n      \\\"SAL LAUGH^               LF\",\n      \\\"SAL LL-                  _\",\n      \\\"SAL L                    L\",\n      \\\"SAL MB$                  M\",\n      \\\"SAL MM                   M\",\n      \\\"SAL M                    M\",\n      \\\"SAL NN-                  _\",\n      \\\"SAL N                    N\",\n      \\\"SAL OH(AEIOUY)-^         *H\",\n      \\\"SAL OR(AEIOUY)-^         *R\",\n      \\\"SAL O(HR)^               *\",\n      \\\"SAL O^                   *\",\n      \\\"SAL OH(AEIOUY)-          H\",\n      \\\"SAL OR(AEIOUY)-          R\",\n      \\\"SAL O(HR)                _\",\n      \\\"SAL PH                   F\",\n      \\\"SAL PN^                  N\",\n      \\\"SAL PP-                  _\",\n      \\\"SAL P                    P\",\n      \\\"SAL Q                    K\",\n      \\\"SAL RH^                  R\",\n      \\\"SAL ROUGH^               RF\",\n      \\\"SAL RR-                  _\",\n      \\\"SAL R                    R\",\n      \\\"SAL SCH(EOU)-            SK\",\n      \\\"SAL SC(IEY)-             S\",\n      \\\"SAL SH                   X\",\n      \\\"SAL SI(AO)-              X\",\n      \\\"SAL SS-                  _\",\n      \\\"SAL S                    S\",\n      \\\"SAL TI(AO)-              X\",\n      \\\"SAL TH                   @\",\n      \\\"SAL TCH--                _\",\n      \\\"SAL TOUGH^               TF\",\n      \\\"SAL TT-                  _\",\n      \\\"SAL T                    T\",\n      \\\"SAL UH(AEIOUY)-^         *H\",\n      \\\"SAL UR(AEIOUY)-^         *R\",\n      \\\"SAL U(HR)^               *\",\n      \\\"SAL U^                   *\",\n      \\\"SAL UH(AEIOUY)-          H\",\n      \\\"SAL UR(AEIOUY)-          R\",\n      \\\"SAL U(HR)                _\",\n      \\\"SAL V^                   W\",\n      \\\"SAL V                    F\",\n      \\\"SAL WR^                  R\",\n      \\\"SAL WH^                  W\",\n      \\\"SAL W(AEIOU)-            W\",\n      \\\"SAL X^                   S\",\n      \\\"SAL X                    KS\",\n      \\\"SAL Y(AEIOU)-            Y\",\n      \\\"SAL ZZ-                  _\",\n      \\\"SAL Z                    S\",\n      \\ ]\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n#ifdef FEAT_CINDENT\n\t\"+cindent\",\n#else\n\t\"-cindent\",\n#endif\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n#ifdef EBCDIC\n\t\"+ebcdic\",\n#else\n\t\"-ebcdic\",\n#endif\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n#ifdef FEAT_LISP\n\t\"+lispindent\",\n#else\n\t\"-lispindent\",\n#endif\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n\t\"+mouse_gpm\",\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n#ifdef FEAT_SMARTINDENT\n\t\"+smartindent\",\n#else\n\t\"-smartindent\",\n#endif\n#ifdef FEAT_SODIUM\n\t\"+sodium\",\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n#ifdef FEAT_TAG_BINS\n\t\"+tag_binary\",\n#else\n\t\"-tag_binary\",\n#endif\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#ifdef MSWIN\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#else\n# ifdef HAVE_XPM\n\t\"+xpm\",\n# else\n\t\"-xpm\",\n# endif\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef USE_XSMP_INTERACT\n\t\"+xsmp_interact\",\n# else\n#  ifdef USE_XSMP\n\t\"+xsmp\",\n#  else\n\t\"-xsmp\",\n#  endif\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    4246,\n/**/\n    4245,\n/**/\n    4244,\n/**/\n    4243,\n/**/\n    4242,\n/**/\n    4241,\n/**/\n    4240,\n/**/\n    4239,\n/**/\n    4238,\n/**/\n    4237,\n/**/\n    4236,\n/**/\n    4235,\n/**/\n    4234,\n/**/\n    4233,\n/**/\n    4232,\n/**/\n    4231,\n/**/\n    4230,\n/**/\n    4229,\n/**/\n    4228,\n/**/\n    4227,\n/**/\n    4226,\n/**/\n    4225,\n/**/\n    4224,\n/**/\n    4223,\n/**/\n    4222,\n/**/\n    4221,\n/**/\n    4220,\n/**/\n    4219,\n/**/\n    4218,\n/**/\n    4217,\n/**/\n    4216,\n/**/\n    4215,\n/**/\n    4214,\n/**/\n    4213,\n/**/\n    4212,\n/**/\n    4211,\n/**/\n    4210,\n/**/\n    4209,\n/**/\n    4208,\n/**/\n    4207,\n/**/\n    4206,\n/**/\n    4205,\n/**/\n    4204,\n/**/\n    4203,\n/**/\n    4202,\n/**/\n    4201,\n/**/\n    4200,\n/**/\n    4199,\n/**/\n    4198,\n/**/\n    4197,\n/**/\n    4196,\n/**/\n    4195,\n/**/\n    4194,\n/**/\n    4193,\n/**/\n    4192,\n/**/\n    4191,\n/**/\n    4190,\n/**/\n    4189,\n/**/\n    4188,\n/**/\n    4187,\n/**/\n    4186,\n/**/\n    4185,\n/**/\n    4184,\n/**/\n    4183,\n/**/\n    4182,\n/**/\n    4181,\n/**/\n    4180,\n/**/\n    4179,\n/**/\n    4178,\n/**/\n    4177,\n/**/\n    4176,\n/**/\n    4175,\n/**/\n    4174,\n/**/\n    4173,\n/**/\n    4172,\n/**/\n    4171,\n/**/\n    4170,\n/**/\n    4169,\n/**/\n    4168,\n/**/\n    4167,\n/**/\n    4166,\n/**/\n    4165,\n/**/\n    4164,\n/**/\n    4163,\n/**/\n    4162,\n/**/\n    4161,\n/**/\n    4160,\n/**/\n    4159,\n/**/\n    4158,\n/**/\n    4157,\n/**/\n    4156,\n/**/\n    4155,\n/**/\n    4154,\n/**/\n    4153,\n/**/\n    4152,\n/**/\n    4151,\n/**/\n    4150,\n/**/\n    4149,\n/**/\n    4148,\n/**/\n    4147,\n/**/\n    4146,\n/**/\n    4145,\n/**/\n    4144,\n/**/\n    4143,\n/**/\n    4142,\n/**/\n    4141,\n/**/\n    4140,\n/**/\n    4139,\n/**/\n    4138,\n/**/\n    4137,\n/**/\n    4136,\n/**/\n    4135,\n/**/\n    4134,\n/**/\n    4133,\n/**/\n    4132,\n/**/\n    4131,\n/**/\n    4130,\n/**/\n    4129,\n/**/\n    4128,\n/**/\n    4127,\n/**/\n    4126,\n/**/\n    4125,\n/**/\n    4124,\n/**/\n    4123,\n/**/\n    4122,\n/**/\n    4121,\n/**/\n    4120,\n/**/\n    4119,\n/**/\n    4118,\n/**/\n    4117,\n/**/\n    4116,\n/**/\n    4115,\n/**/\n    4114,\n/**/\n    4113,\n/**/\n    4112,\n/**/\n    4111,\n/**/\n    4110,\n/**/\n    4109,\n/**/\n    4108,\n/**/\n    4107,\n/**/\n    4106,\n/**/\n    4105,\n/**/\n    4104,\n/**/\n    4103,\n/**/\n    4102,\n/**/\n    4101,\n/**/\n    4100,\n/**/\n    4099,\n/**/\n    4098,\n/**/\n    4097,\n/**/\n    4096,\n/**/\n    4095,\n/**/\n    4094,\n/**/\n    4093,\n/**/\n    4092,\n/**/\n    4091,\n/**/\n    4090,\n/**/\n    4089,\n/**/\n    4088,\n/**/\n    4087,\n/**/\n    4086,\n/**/\n    4085,\n/**/\n    4084,\n/**/\n    4083,\n/**/\n    4082,\n/**/\n    4081,\n/**/\n    4080,\n/**/\n    4079,\n/**/\n    4078,\n/**/\n    4077,\n/**/\n    4076,\n/**/\n    4075,\n/**/\n    4074,\n/**/\n    4073,\n/**/\n    4072,\n/**/\n    4071,\n/**/\n    4070,\n/**/\n    4069,\n/**/\n    4068,\n/**/\n    4067,\n/**/\n    4066,\n/**/\n    4065,\n/**/\n    4064,\n/**/\n    4063,\n/**/\n    4062,\n/**/\n    4061,\n/**/\n    4060,\n/**/\n    4059,\n/**/\n    4058,\n/**/\n    4057,\n/**/\n    4056,\n/**/\n    4055,\n/**/\n    4054,\n/**/\n    4053,\n/**/\n    4052,\n/**/\n    4051,\n/**/\n    4050,\n/**/\n    4049,\n/**/\n    4048,\n/**/\n    4047,\n/**/\n    4046,\n/**/\n    4045,\n/**/\n    4044,\n/**/\n    4043,\n/**/\n    4042,\n/**/\n    4041,\n/**/\n    4040,\n/**/\n    4039,\n/**/\n    4038,\n/**/\n    4037,\n/**/\n    4036,\n/**/\n    4035,\n/**/\n    4034,\n/**/\n    4033,\n/**/\n    4032,\n/**/\n    4031,\n/**/\n    4030,\n/**/\n    4029,\n/**/\n    4028,\n/**/\n    4027,\n/**/\n    4026,\n/**/\n    4025,\n/**/\n    4024,\n/**/\n    4023,\n/**/\n    4022,\n/**/\n    4021,\n/**/\n    4020,\n/**/\n    4019,\n/**/\n    4018,\n/**/\n    4017,\n/**/\n    4016,\n/**/\n    4015,\n/**/\n    4014,\n/**/\n    4013,\n/**/\n    4012,\n/**/\n    4011,\n/**/\n    4010,\n/**/\n    4009,\n/**/\n    4008,\n/**/\n    4007,\n/**/\n    4006,\n/**/\n    4005,\n/**/\n    4004,\n/**/\n    4003,\n/**/\n    4002,\n/**/\n    4001,\n/**/\n    4000,\n/**/\n    3999,\n/**/\n    3998,\n/**/\n    3997,\n/**/\n    3996,\n/**/\n    3995,\n/**/\n    3994,\n/**/\n    3993,\n/**/\n    3992,\n/**/\n    3991,\n/**/\n    3990,\n/**/\n    3989,\n/**/\n    3988,\n/**/\n    3987,\n/**/\n    3986,\n/**/\n    3985,\n/**/\n    3984,\n/**/\n    3983,\n/**/\n    3982,\n/**/\n    3981,\n/**/\n    3980,\n/**/\n    3979,\n/**/\n    3978,\n/**/\n    3977,\n/**/\n    3976,\n/**/\n    3975,\n/**/\n    3974,\n/**/\n    3973,\n/**/\n    3972,\n/**/\n    3971,\n/**/\n    3970,\n/**/\n    3969,\n/**/\n    3968,\n/**/\n    3967,\n/**/\n    3966,\n/**/\n    3965,\n/**/\n    3964,\n/**/\n    3963,\n/**/\n    3962,\n/**/\n    3961,\n/**/\n    3960,\n/**/\n    3959,\n/**/\n    3958,\n/**/\n    3957,\n/**/\n    3956,\n/**/\n    3955,\n/**/\n    3954,\n/**/\n    3953,\n/**/\n    3952,\n/**/\n    3951,\n/**/\n    3950,\n/**/\n    3949,\n/**/\n    3948,\n/**/\n    3947,\n/**/\n    3946,\n/**/\n    3945,\n/**/\n    3944,\n/**/\n    3943,\n/**/\n    3942,\n/**/\n    3941,\n/**/\n    3940,\n/**/\n    3939,\n/**/\n    3938,\n/**/\n    3937,\n/**/\n    3936,\n/**/\n    3935,\n/**/\n    3934,\n/**/\n    3933,\n/**/\n    3932,\n/**/\n    3931,\n/**/\n    3930,\n/**/\n    3929,\n/**/\n    3928,\n/**/\n    3927,\n/**/\n    3926,\n/**/\n    3925,\n/**/\n    3924,\n/**/\n    3923,\n/**/\n    3922,\n/**/\n    3921,\n/**/\n    3920,\n/**/\n    3919,\n/**/\n    3918,\n/**/\n    3917,\n/**/\n    3916,\n/**/\n    3915,\n/**/\n    3914,\n/**/\n    3913,\n/**/\n    3912,\n/**/\n    3911,\n/**/\n    3910,\n/**/\n    3909,\n/**/\n    3908,\n/**/\n    3907,\n/**/\n    3906,\n/**/\n    3905,\n/**/\n    3904,\n/**/\n    3903,\n/**/\n    3902,\n/**/\n    3901,\n/**/\n    3900,\n/**/\n    3899,\n/**/\n    3898,\n/**/\n    3897,\n/**/\n    3896,\n/**/\n    3895,\n/**/\n    3894,\n/**/\n    3893,\n/**/\n    3892,\n/**/\n    3891,\n/**/\n    3890,\n/**/\n    3889,\n/**/\n    3888,\n/**/\n    3887,\n/**/\n    3886,\n/**/\n    3885,\n/**/\n    3884,\n/**/\n    3883,\n/**/\n    3882,\n/**/\n    3881,\n/**/\n    3880,\n/**/\n    3879,\n/**/\n    3878,\n/**/\n    3877,\n/**/\n    3876,\n/**/\n    3875,\n/**/\n    3874,\n/**/\n    3873,\n/**/\n    3872,\n/**/\n    3871,\n/**/\n    3870,\n/**/\n    3869,\n/**/\n    3868,\n/**/\n    3867,\n/**/\n    3866,\n/**/\n    3865,\n/**/\n    3864,\n/**/\n    3863,\n/**/\n    3862,\n/**/\n    3861,\n/**/\n    3860,\n/**/\n    3859,\n/**/\n    3858,\n/**/\n    3857,\n/**/\n    3856,\n/**/\n    3855,\n/**/\n    3854,\n/**/\n    3853,\n/**/\n    3852,\n/**/\n    3851,\n/**/\n    3850,\n/**/\n    3849,\n/**/\n    3848,\n/**/\n    3847,\n/**/\n    3846,\n/**/\n    3845,\n/**/\n    3844,\n/**/\n    3843,\n/**/\n    3842,\n/**/\n    3841,\n/**/\n    3840,\n/**/\n    3839,\n/**/\n    3838,\n/**/\n    3837,\n/**/\n    3836,\n/**/\n    3835,\n/**/\n    3834,\n/**/\n    3833,\n/**/\n    3832,\n/**/\n    3831,\n/**/\n    3830,\n/**/\n    3829,\n/**/\n    3828,\n/**/\n    3827,\n/**/\n    3826,\n/**/\n    3825,\n/**/\n    3824,\n/**/\n    3823,\n/**/\n    3822,\n/**/\n    3821,\n/**/\n    3820,\n/**/\n    3819,\n/**/\n    3818,\n/**/\n    3817,\n/**/\n    3816,\n/**/\n    3815,\n/**/\n    3814,\n/**/\n    3813,\n/**/\n    3812,\n/**/\n    3811,\n/**/\n    3810,\n/**/\n    3809,\n/**/\n    3808,\n/**/\n    3807,\n/**/\n    3806,\n/**/\n    3805,\n/**/\n    3804,\n/**/\n    3803,\n/**/\n    3802,\n/**/\n    3801,\n/**/\n    3800,\n/**/\n    3799,\n/**/\n    3798,\n/**/\n    3797,\n/**/\n    3796,\n/**/\n    3795,\n/**/\n    3794,\n/**/\n    3793,\n/**/\n    3792,\n/**/\n    3791,\n/**/\n    3790,\n/**/\n    3789,\n/**/\n    3788,\n/**/\n    3787,\n/**/\n    3786,\n/**/\n    3785,\n/**/\n    3784,\n/**/\n    3783,\n/**/\n    3782,\n/**/\n    3781,\n/**/\n    3780,\n/**/\n    3779,\n/**/\n    3778,\n/**/\n    3777,\n/**/\n    3776,\n/**/\n    3775,\n/**/\n    3774,\n/**/\n    3773,\n/**/\n    3772,\n/**/\n    3771,\n/**/\n    3770,\n/**/\n    3769,\n/**/\n    3768,\n/**/\n    3767,\n/**/\n    3766,\n/**/\n    3765,\n/**/\n    3764,\n/**/\n    3763,\n/**/\n    3762,\n/**/\n    3761,\n/**/\n    3760,\n/**/\n    3759,\n/**/\n    3758,\n/**/\n    3757,\n/**/\n    3756,\n/**/\n    3755,\n/**/\n    3754,\n/**/\n    3753,\n/**/\n    3752,\n/**/\n    3751,\n/**/\n    3750,\n/**/\n    3749,\n/**/\n    3748,\n/**/\n    3747,\n/**/\n    3746,\n/**/\n    3745,\n/**/\n    3744,\n/**/\n    3743,\n/**/\n    3742,\n/**/\n    3741,\n/**/\n    3740,\n/**/\n    3739,\n/**/\n    3738,\n/**/\n    3737,\n/**/\n    3736,\n/**/\n    3735,\n/**/\n    3734,\n/**/\n    3733,\n/**/\n    3732,\n/**/\n    3731,\n/**/\n    3730,\n/**/\n    3729,\n/**/\n    3728,\n/**/\n    3727,\n/**/\n    3726,\n/**/\n    3725,\n/**/\n    3724,\n/**/\n    3723,\n/**/\n    3722,\n/**/\n    3721,\n/**/\n    3720,\n/**/\n    3719,\n/**/\n    3718,\n/**/\n    3717,\n/**/\n    3716,\n/**/\n    3715,\n/**/\n    3714,\n/**/\n    3713,\n/**/\n    3712,\n/**/\n    3711,\n/**/\n    3710,\n/**/\n    3709,\n/**/\n    3708,\n/**/\n    3707,\n/**/\n    3706,\n/**/\n    3705,\n/**/\n    3704,\n/**/\n    3703,\n/**/\n    3702,\n/**/\n    3701,\n/**/\n    3700,\n/**/\n    3699,\n/**/\n    3698,\n/**/\n    3697,\n/**/\n    3696,\n/**/\n    3695,\n/**/\n    3694,\n/**/\n    3693,\n/**/\n    3692,\n/**/\n    3691,\n/**/\n    3690,\n/**/\n    3689,\n/**/\n    3688,\n/**/\n    3687,\n/**/\n    3686,\n/**/\n    3685,\n/**/\n    3684,\n/**/\n    3683,\n/**/\n    3682,\n/**/\n    3681,\n/**/\n    3680,\n/**/\n    3679,\n/**/\n    3678,\n/**/\n    3677,\n/**/\n    3676,\n/**/\n    3675,\n/**/\n    3674,\n/**/\n    3673,\n/**/\n    3672,\n/**/\n    3671,\n/**/\n    3670,\n/**/\n    3669,\n/**/\n    3668,\n/**/\n    3667,\n/**/\n    3666,\n/**/\n    3665,\n/**/\n    3664,\n/**/\n    3663,\n/**/\n    3662,\n/**/\n    3661,\n/**/\n    3660,\n/**/\n    3659,\n/**/\n    3658,\n/**/\n    3657,\n/**/\n    3656,\n/**/\n    3655,\n/**/\n    3654,\n/**/\n    3653,\n/**/\n    3652,\n/**/\n    3651,\n/**/\n    3650,\n/**/\n    3649,\n/**/\n    3648,\n/**/\n    3647,\n/**/\n    3646,\n/**/\n    3645,\n/**/\n    3644,\n/**/\n    3643,\n/**/\n    3642,\n/**/\n    3641,\n/**/\n    3640,\n/**/\n    3639,\n/**/\n    3638,\n/**/\n    3637,\n/**/\n    3636,\n/**/\n    3635,\n/**/\n    3634,\n/**/\n    3633,\n/**/\n    3632,\n/**/\n    3631,\n/**/\n    3630,\n/**/\n    3629,\n/**/\n    3628,\n/**/\n    3627,\n/**/\n    3626,\n/**/\n    3625,\n/**/\n    3624,\n/**/\n    3623,\n/**/\n    3622,\n/**/\n    3621,\n/**/\n    3620,\n/**/\n    3619,\n/**/\n    3618,\n/**/\n    3617,\n/**/\n    3616,\n/**/\n    3615,\n/**/\n    3614,\n/**/\n    3613,\n/**/\n    3612,\n/**/\n    3611,\n/**/\n    3610,\n/**/\n    3609,\n/**/\n    3608,\n/**/\n    3607,\n/**/\n    3606,\n/**/\n    3605,\n/**/\n    3604,\n/**/\n    3603,\n/**/\n    3602,\n/**/\n    3601,\n/**/\n    3600,\n/**/\n    3599,\n/**/\n    3598,\n/**/\n    3597,\n/**/\n    3596,\n/**/\n    3595,\n/**/\n    3594,\n/**/\n    3593,\n/**/\n    3592,\n/**/\n    3591,\n/**/\n    3590,\n/**/\n    3589,\n/**/\n    3588,\n/**/\n    3587,\n/**/\n    3586,\n/**/\n    3585,\n/**/\n    3584,\n/**/\n    3583,\n/**/\n    3582,\n/**/\n    3581,\n/**/\n    3580,\n/**/\n    3579,\n/**/\n    3578,\n/**/\n    3577,\n/**/\n    3576,\n/**/\n    3575,\n/**/\n    3574,\n/**/\n    3573,\n/**/\n    3572,\n/**/\n    3571,\n/**/\n    3570,\n/**/\n    3569,\n/**/\n    3568,\n/**/\n    3567,\n/**/\n    3566,\n/**/\n    3565,\n/**/\n    3564,\n/**/\n    3563,\n/**/\n    3562,\n/**/\n    3561,\n/**/\n    3560,\n/**/\n    3559,\n/**/\n    3558,\n/**/\n    3557,\n/**/\n    3556,\n/**/\n    3555,\n/**/\n    3554,\n/**/\n    3553,\n/**/\n    3552,\n/**/\n    3551,\n/**/\n    3550,\n/**/\n    3549,\n/**/\n    3548,\n/**/\n    3547,\n/**/\n    3546,\n/**/\n    3545,\n/**/\n    3544,\n/**/\n    3543,\n/**/\n    3542,\n/**/\n    3541,\n/**/\n    3540,\n/**/\n    3539,\n/**/\n    3538,\n/**/\n    3537,\n/**/\n    3536,\n/**/\n    3535,\n/**/\n    3534,\n/**/\n    3533,\n/**/\n    3532,\n/**/\n    3531,\n/**/\n    3530,\n/**/\n    3529,\n/**/\n    3528,\n/**/\n    3527,\n/**/\n    3526,\n/**/\n    3525,\n/**/\n    3524,\n/**/\n    3523,\n/**/\n    3522,\n/**/\n    3521,\n/**/\n    3520,\n/**/\n    3519,\n/**/\n    3518,\n/**/\n    3517,\n/**/\n    3516,\n/**/\n    3515,\n/**/\n    3514,\n/**/\n    3513,\n/**/\n    3512,\n/**/\n    3511,\n/**/\n    3510,\n/**/\n    3509,\n/**/\n    3508,\n/**/\n    3507,\n/**/\n    3506,\n/**/\n    3505,\n/**/\n    3504,\n/**/\n    3503,\n/**/\n    3502,\n/**/\n    3501,\n/**/\n    3500,\n/**/\n    3499,\n/**/\n    3498,\n/**/\n    3497,\n/**/\n    3496,\n/**/\n    3495,\n/**/\n    3494,\n/**/\n    3493,\n/**/\n    3492,\n/**/\n    3491,\n/**/\n    3490,\n/**/\n    3489,\n/**/\n    3488,\n/**/\n    3487,\n/**/\n    3486,\n/**/\n    3485,\n/**/\n    3484,\n/**/\n    3483,\n/**/\n    3482,\n/**/\n    3481,\n/**/\n    3480,\n/**/\n    3479,\n/**/\n    3478,\n/**/\n    3477,\n/**/\n    3476,\n/**/\n    3475,\n/**/\n    3474,\n/**/\n    3473,\n/**/\n    3472,\n/**/\n    3471,\n/**/\n    3470,\n/**/\n    3469,\n/**/\n    3468,\n/**/\n    3467,\n/**/\n    3466,\n/**/\n    3465,\n/**/\n    3464,\n/**/\n    3463,\n/**/\n    3462,\n/**/\n    3461,\n/**/\n    3460,\n/**/\n    3459,\n/**/\n    3458,\n/**/\n    3457,\n/**/\n    3456,\n/**/\n    3455,\n/**/\n    3454,\n/**/\n    3453,\n/**/\n    3452,\n/**/\n    3451,\n/**/\n    3450,\n/**/\n    3449,\n/**/\n    3448,\n/**/\n    3447,\n/**/\n    3446,\n/**/\n    3445,\n/**/\n    3444,\n/**/\n    3443,\n/**/\n    3442,\n/**/\n    3441,\n/**/\n    3440,\n/**/\n    3439,\n/**/\n    3438,\n/**/\n    3437,\n/**/\n    3436,\n/**/\n    3435,\n/**/\n    3434,\n/**/\n    3433,\n/**/\n    3432,\n/**/\n    3431,\n/**/\n    3430,\n/**/\n    3429,\n/**/\n    3428,\n/**/\n    3427,\n/**/\n    3426,\n/**/\n    3425,\n/**/\n    3424,\n/**/\n    3423,\n/**/\n    3422,\n/**/\n    3421,\n/**/\n    3420,\n/**/\n    3419,\n/**/\n    3418,\n/**/\n    3417,\n/**/\n    3416,\n/**/\n    3415,\n/**/\n    3414,\n/**/\n    3413,\n/**/\n    3412,\n/**/\n    3411,\n/**/\n    3410,\n/**/\n    3409,\n/**/\n    3408,\n/**/\n    3407,\n/**/\n    3406,\n/**/\n    3405,\n/**/\n    3404,\n/**/\n    3403,\n/**/\n    3402,\n/**/\n    3401,\n/**/\n    3400,\n/**/\n    3399,\n/**/\n    3398,\n/**/\n    3397,\n/**/\n    3396,\n/**/\n    3395,\n/**/\n    3394,\n/**/\n    3393,\n/**/\n    3392,\n/**/\n    3391,\n/**/\n    3390,\n/**/\n    3389,\n/**/\n    3388,\n/**/\n    3387,\n/**/\n    3386,\n/**/\n    3385,\n/**/\n    3384,\n/**/\n    3383,\n/**/\n    3382,\n/**/\n    3381,\n/**/\n    3380,\n/**/\n    3379,\n/**/\n    3378,\n/**/\n    3377,\n/**/\n    3376,\n/**/\n    3375,\n/**/\n    3374,\n/**/\n    3373,\n/**/\n    3372,\n/**/\n    3371,\n/**/\n    3370,\n/**/\n    3369,\n/**/\n    3368,\n/**/\n    3367,\n/**/\n    3366,\n/**/\n    3365,\n/**/\n    3364,\n/**/\n    3363,\n/**/\n    3362,\n/**/\n    3361,\n/**/\n    3360,\n/**/\n    3359,\n/**/\n    3358,\n/**/\n    3357,\n/**/\n    3356,\n/**/\n    3355,\n/**/\n    3354,\n/**/\n    3353,\n/**/\n    3352,\n/**/\n    3351,\n/**/\n    3350,\n/**/\n    3349,\n/**/\n    3348,\n/**/\n    3347,\n/**/\n    3346,\n/**/\n    3345,\n/**/\n    3344,\n/**/\n    3343,\n/**/\n    3342,\n/**/\n    3341,\n/**/\n    3340,\n/**/\n    3339,\n/**/\n    3338,\n/**/\n    3337,\n/**/\n    3336,\n/**/\n    3335,\n/**/\n    3334,\n/**/\n    3333,\n/**/\n    3332,\n/**/\n    3331,\n/**/\n    3330,\n/**/\n    3329,\n/**/\n    3328,\n/**/\n    3327,\n/**/\n    3326,\n/**/\n    3325,\n/**/\n    3324,\n/**/\n    3323,\n/**/\n    3322,\n/**/\n    3321,\n/**/\n    3320,\n/**/\n    3319,\n/**/\n    3318,\n/**/\n    3317,\n/**/\n    3316,\n/**/\n    3315,\n/**/\n    3314,\n/**/\n    3313,\n/**/\n    3312,\n/**/\n    3311,\n/**/\n    3310,\n/**/\n    3309,\n/**/\n    3308,\n/**/\n    3307,\n/**/\n    3306,\n/**/\n    3305,\n/**/\n    3304,\n/**/\n    3303,\n/**/\n    3302,\n/**/\n    3301,\n/**/\n    3300,\n/**/\n    3299,\n/**/\n    3298,\n/**/\n    3297,\n/**/\n    3296,\n/**/\n    3295,\n/**/\n    3294,\n/**/\n    3293,\n/**/\n    3292,\n/**/\n    3291,\n/**/\n    3290,\n/**/\n    3289,\n/**/\n    3288,\n/**/\n    3287,\n/**/\n    3286,\n/**/\n    3285,\n/**/\n    3284,\n/**/\n    3283,\n/**/\n    3282,\n/**/\n    3281,\n/**/\n    3280,\n/**/\n    3279,\n/**/\n    3278,\n/**/\n    3277,\n/**/\n    3276,\n/**/\n    3275,\n/**/\n    3274,\n/**/\n    3273,\n/**/\n    3272,\n/**/\n    3271,\n/**/\n    3270,\n/**/\n    3269,\n/**/\n    3268,\n/**/\n    3267,\n/**/\n    3266,\n/**/\n    3265,\n/**/\n    3264,\n/**/\n    3263,\n/**/\n    3262,\n/**/\n    3261,\n/**/\n    3260,\n/**/\n    3259,\n/**/\n    3258,\n/**/\n    3257,\n/**/\n    3256,\n/**/\n    3255,\n/**/\n    3254,\n/**/\n    3253,\n/**/\n    3252,\n/**/\n    3251,\n/**/\n    3250,\n/**/\n    3249,\n/**/\n    3248,\n/**/\n    3247,\n/**/\n    3246,\n/**/\n    3245,\n/**/\n    3244,\n/**/\n    3243,\n/**/\n    3242,\n/**/\n    3241,\n/**/\n    3240,\n/**/\n    3239,\n/**/\n    3238,\n/**/\n    3237,\n/**/\n    3236,\n/**/\n    3235,\n/**/\n    3234,\n/**/\n    3233,\n/**/\n    3232,\n/**/\n    3231,\n/**/\n    3230,\n/**/\n    3229,\n/**/\n    3228,\n/**/\n    3227,\n/**/\n    3226,\n/**/\n    3225,\n/**/\n    3224,\n/**/\n    3223,\n/**/\n    3222,\n/**/\n    3221,\n/**/\n    3220,\n/**/\n    3219,\n/**/\n    3218,\n/**/\n    3217,\n/**/\n    3216,\n/**/\n    3215,\n/**/\n    3214,\n/**/\n    3213,\n/**/\n    3212,\n/**/\n    3211,\n/**/\n    3210,\n/**/\n    3209,\n/**/\n    3208,\n/**/\n    3207,\n/**/\n    3206,\n/**/\n    3205,\n/**/\n    3204,\n/**/\n    3203,\n/**/\n    3202,\n/**/\n    3201,\n/**/\n    3200,\n/**/\n    3199,\n/**/\n    3198,\n/**/\n    3197,\n/**/\n    3196,\n/**/\n    3195,\n/**/\n    3194,\n/**/\n    3193,\n/**/\n    3192,\n/**/\n    3191,\n/**/\n    3190,\n/**/\n    3189,\n/**/\n    3188,\n/**/\n    3187,\n/**/\n    3186,\n/**/\n    3185,\n/**/\n    3184,\n/**/\n    3183,\n/**/\n    3182,\n/**/\n    3181,\n/**/\n    3180,\n/**/\n    3179,\n/**/\n    3178,\n/**/\n    3177,\n/**/\n    3176,\n/**/\n    3175,\n/**/\n    3174,\n/**/\n    3173,\n/**/\n    3172,\n/**/\n    3171,\n/**/\n    3170,\n/**/\n    3169,\n/**/\n    3168,\n/**/\n    3167,\n/**/\n    3166,\n/**/\n    3165,\n/**/\n    3164,\n/**/\n    3163,\n/**/\n    3162,\n/**/\n    3161,\n/**/\n    3160,\n/**/\n    3159,\n/**/\n    3158,\n/**/\n    3157,\n/**/\n    3156,\n/**/\n    3155,\n/**/\n    3154,\n/**/\n    3153,\n/**/\n    3152,\n/**/\n    3151,\n/**/\n    3150,\n/**/\n    3149,\n/**/\n    3148,\n/**/\n    3147,\n/**/\n    3146,\n/**/\n    3145,\n/**/\n    3144,\n/**/\n    3143,\n/**/\n    3142,\n/**/\n    3141,\n/**/\n    3140,\n/**/\n    3139,\n/**/\n    3138,\n/**/\n    3137,\n/**/\n    3136,\n/**/\n    3135,\n/**/\n    3134,\n/**/\n    3133,\n/**/\n    3132,\n/**/\n    3131,\n/**/\n    3130,\n/**/\n    3129,\n/**/\n    3128,\n/**/\n    3127,\n/**/\n    3126,\n/**/\n    3125,\n/**/\n    3124,\n/**/\n    3123,\n/**/\n    3122,\n/**/\n    3121,\n/**/\n    3120,\n/**/\n    3119,\n/**/\n    3118,\n/**/\n    3117,\n/**/\n    3116,\n/**/\n    3115,\n/**/\n    3114,\n/**/\n    3113,\n/**/\n    3112,\n/**/\n    3111,\n/**/\n    3110,\n/**/\n    3109,\n/**/\n    3108,\n/**/\n    3107,\n/**/\n    3106,\n/**/\n    3105,\n/**/\n    3104,\n/**/\n    3103,\n/**/\n    3102,\n/**/\n    3101,\n/**/\n    3100,\n/**/\n    3099,\n/**/\n    3098,\n/**/\n    3097,\n/**/\n    3096,\n/**/\n    3095,\n/**/\n    3094,\n/**/\n    3093,\n/**/\n    3092,\n/**/\n    3091,\n/**/\n    3090,\n/**/\n    3089,\n/**/\n    3088,\n/**/\n    3087,\n/**/\n    3086,\n/**/\n    3085,\n/**/\n    3084,\n/**/\n    3083,\n/**/\n    3082,\n/**/\n    3081,\n/**/\n    3080,\n/**/\n    3079,\n/**/\n    3078,\n/**/\n    3077,\n/**/\n    3076,\n/**/\n    3075,\n/**/\n    3074,\n/**/\n    3073,\n/**/\n    3072,\n/**/\n    3071,\n/**/\n    3070,\n/**/\n    3069,\n/**/\n    3068,\n/**/\n    3067,\n/**/\n    3066,\n/**/\n    3065,\n/**/\n    3064,\n/**/\n    3063,\n/**/\n    3062,\n/**/\n    3061,\n/**/\n    3060,\n/**/\n    3059,\n/**/\n    3058,\n/**/\n    3057,\n/**/\n    3056,\n/**/\n    3055,\n/**/\n    3054,\n/**/\n    3053,\n/**/\n    3052,\n/**/\n    3051,\n/**/\n    3050,\n/**/\n    3049,\n/**/\n    3048,\n/**/\n    3047,\n/**/\n    3046,\n/**/\n    3045,\n/**/\n    3044,\n/**/\n    3043,\n/**/\n    3042,\n/**/\n    3041,\n/**/\n    3040,\n/**/\n    3039,\n/**/\n    3038,\n/**/\n    3037,\n/**/\n    3036,\n/**/\n    3035,\n/**/\n    3034,\n/**/\n    3033,\n/**/\n    3032,\n/**/\n    3031,\n/**/\n    3030,\n/**/\n    3029,\n/**/\n    3028,\n/**/\n    3027,\n/**/\n    3026,\n/**/\n    3025,\n/**/\n    3024,\n/**/\n    3023,\n/**/\n    3022,\n/**/\n    3021,\n/**/\n    3020,\n/**/\n    3019,\n/**/\n    3018,\n/**/\n    3017,\n/**/\n    3016,\n/**/\n    3015,\n/**/\n    3014,\n/**/\n    3013,\n/**/\n    3012,\n/**/\n    3011,\n/**/\n    3010,\n/**/\n    3009,\n/**/\n    3008,\n/**/\n    3007,\n/**/\n    3006,\n/**/\n    3005,\n/**/\n    3004,\n/**/\n    3003,\n/**/\n    3002,\n/**/\n    3001,\n/**/\n    3000,\n/**/\n    2999,\n/**/\n    2998,\n/**/\n    2997,\n/**/\n    2996,\n/**/\n    2995,\n/**/\n    2994,\n/**/\n    2993,\n/**/\n    2992,\n/**/\n    2991,\n/**/\n    2990,\n/**/\n    2989,\n/**/\n    2988,\n/**/\n    2987,\n/**/\n    2986,\n/**/\n    2985,\n/**/\n    2984,\n/**/\n    2983,\n/**/\n    2982,\n/**/\n    2981,\n/**/\n    2980,\n/**/\n    2979,\n/**/\n    2978,\n/**/\n    2977,\n/**/\n    2976,\n/**/\n    2975,\n/**/\n    2974,\n/**/\n    2973,\n/**/\n    2972,\n/**/\n    2971,\n/**/\n    2970,\n/**/\n    2969,\n/**/\n    2968,\n/**/\n    2967,\n/**/\n    2966,\n/**/\n    2965,\n/**/\n    2964,\n/**/\n    2963,\n/**/\n    2962,\n/**/\n    2961,\n/**/\n    2960,\n/**/\n    2959,\n/**/\n    2958,\n/**/\n    2957,\n/**/\n    2956,\n/**/\n    2955,\n/**/\n    2954,\n/**/\n    2953,\n/**/\n    2952,\n/**/\n    2951,\n/**/\n    2950,\n/**/\n    2949,\n/**/\n    2948,\n/**/\n    2947,\n/**/\n    2946,\n/**/\n    2945,\n/**/\n    2944,\n/**/\n    2943,\n/**/\n    2942,\n/**/\n    2941,\n/**/\n    2940,\n/**/\n    2939,\n/**/\n    2938,\n/**/\n    2937,\n/**/\n    2936,\n/**/\n    2935,\n/**/\n    2934,\n/**/\n    2933,\n/**/\n    2932,\n/**/\n    2931,\n/**/\n    2930,\n/**/\n    2929,\n/**/\n    2928,\n/**/\n    2927,\n/**/\n    2926,\n/**/\n    2925,\n/**/\n    2924,\n/**/\n    2923,\n/**/\n    2922,\n/**/\n    2921,\n/**/\n    2920,\n/**/\n    2919,\n/**/\n    2918,\n/**/\n    2917,\n/**/\n    2916,\n/**/\n    2915,\n/**/\n    2914,\n/**/\n    2913,\n/**/\n    2912,\n/**/\n    2911,\n/**/\n    2910,\n/**/\n    2909,\n/**/\n    2908,\n/**/\n    2907,\n/**/\n    2906,\n/**/\n    2905,\n/**/\n    2904,\n/**/\n    2903,\n/**/\n    2902,\n/**/\n    2901,\n/**/\n    2900,\n/**/\n    2899,\n/**/\n    2898,\n/**/\n    2897,\n/**/\n    2896,\n/**/\n    2895,\n/**/\n    2894,\n/**/\n    2893,\n/**/\n    2892,\n/**/\n    2891,\n/**/\n    2890,\n/**/\n    2889,\n/**/\n    2888,\n/**/\n    2887,\n/**/\n    2886,\n/**/\n    2885,\n/**/\n    2884,\n/**/\n    2883,\n/**/\n    2882,\n/**/\n    2881,\n/**/\n    2880,\n/**/\n    2879,\n/**/\n    2878,\n/**/\n    2877,\n/**/\n    2876,\n/**/\n    2875,\n/**/\n    2874,\n/**/\n    2873,\n/**/\n    2872,\n/**/\n    2871,\n/**/\n    2870,\n/**/\n    2869,\n/**/\n    2868,\n/**/\n    2867,\n/**/\n    2866,\n/**/\n    2865,\n/**/\n    2864,\n/**/\n    2863,\n/**/\n    2862,\n/**/\n    2861,\n/**/\n    2860,\n/**/\n    2859,\n/**/\n    2858,\n/**/\n    2857,\n/**/\n    2856,\n/**/\n    2855,\n/**/\n    2854,\n/**/\n    2853,\n/**/\n    2852,\n/**/\n    2851,\n/**/\n    2850,\n/**/\n    2849,\n/**/\n    2848,\n/**/\n    2847,\n/**/\n    2846,\n/**/\n    2845,\n/**/\n    2844,\n/**/\n    2843,\n/**/\n    2842,\n/**/\n    2841,\n/**/\n    2840,\n/**/\n    2839,\n/**/\n    2838,\n/**/\n    2837,\n/**/\n    2836,\n/**/\n    2835,\n/**/\n    2834,\n/**/\n    2833,\n/**/\n    2832,\n/**/\n    2831,\n/**/\n    2830,\n/**/\n    2829,\n/**/\n    2828,\n/**/\n    2827,\n/**/\n    2826,\n/**/\n    2825,\n/**/\n    2824,\n/**/\n    2823,\n/**/\n    2822,\n/**/\n    2821,\n/**/\n    2820,\n/**/\n    2819,\n/**/\n    2818,\n/**/\n    2817,\n/**/\n    2816,\n/**/\n    2815,\n/**/\n    2814,\n/**/\n    2813,\n/**/\n    2812,\n/**/\n    2811,\n/**/\n    2810,\n/**/\n    2809,\n/**/\n    2808,\n/**/\n    2807,\n/**/\n    2806,\n/**/\n    2805,\n/**/\n    2804,\n/**/\n    2803,\n/**/\n    2802,\n/**/\n    2801,\n/**/\n    2800,\n/**/\n    2799,\n/**/\n    2798,\n/**/\n    2797,\n/**/\n    2796,\n/**/\n    2795,\n/**/\n    2794,\n/**/\n    2793,\n/**/\n    2792,\n/**/\n    2791,\n/**/\n    2790,\n/**/\n    2789,\n/**/\n    2788,\n/**/\n    2787,\n/**/\n    2786,\n/**/\n    2785,\n/**/\n    2784,\n/**/\n    2783,\n/**/\n    2782,\n/**/\n    2781,\n/**/\n    2780,\n/**/\n    2779,\n/**/\n    2778,\n/**/\n    2777,\n/**/\n    2776,\n/**/\n    2775,\n/**/\n    2774,\n/**/\n    2773,\n/**/\n    2772,\n/**/\n    2771,\n/**/\n    2770,\n/**/\n    2769,\n/**/\n    2768,\n/**/\n    2767,\n/**/\n    2766,\n/**/\n    2765,\n/**/\n    2764,\n/**/\n    2763,\n/**/\n    2762,\n/**/\n    2761,\n/**/\n    2760,\n/**/\n    2759,\n/**/\n    2758,\n/**/\n    2757,\n/**/\n    2756,\n/**/\n    2755,\n/**/\n    2754,\n/**/\n    2753,\n/**/\n    2752,\n/**/\n    2751,\n/**/\n    2750,\n/**/\n    2749,\n/**/\n    2748,\n/**/\n    2747,\n/**/\n    2746,\n/**/\n    2745,\n/**/\n    2744,\n/**/\n    2743,\n/**/\n    2742,\n/**/\n    2741,\n/**/\n    2740,\n/**/\n    2739,\n/**/\n    2738,\n/**/\n    2737,\n/**/\n    2736,\n/**/\n    2735,\n/**/\n    2734,\n/**/\n    2733,\n/**/\n    2732,\n/**/\n    2731,\n/**/\n    2730,\n/**/\n    2729,\n/**/\n    2728,\n/**/\n    2727,\n/**/\n    2726,\n/**/\n    2725,\n/**/\n    2724,\n/**/\n    2723,\n/**/\n    2722,\n/**/\n    2721,\n/**/\n    2720,\n/**/\n    2719,\n/**/\n    2718,\n/**/\n    2717,\n/**/\n    2716,\n/**/\n    2715,\n/**/\n    2714,\n/**/\n    2713,\n/**/\n    2712,\n/**/\n    2711,\n/**/\n    2710,\n/**/\n    2709,\n/**/\n    2708,\n/**/\n    2707,\n/**/\n    2706,\n/**/\n    2705,\n/**/\n    2704,\n/**/\n    2703,\n/**/\n    2702,\n/**/\n    2701,\n/**/\n    2700,\n/**/\n    2699,\n/**/\n    2698,\n/**/\n    2697,\n/**/\n    2696,\n/**/\n    2695,\n/**/\n    2694,\n/**/\n    2693,\n/**/\n    2692,\n/**/\n    2691,\n/**/\n    2690,\n/**/\n    2689,\n/**/\n    2688,\n/**/\n    2687,\n/**/\n    2686,\n/**/\n    2685,\n/**/\n    2684,\n/**/\n    2683,\n/**/\n    2682,\n/**/\n    2681,\n/**/\n    2680,\n/**/\n    2679,\n/**/\n    2678,\n/**/\n    2677,\n/**/\n    2676,\n/**/\n    2675,\n/**/\n    2674,\n/**/\n    2673,\n/**/\n    2672,\n/**/\n    2671,\n/**/\n    2670,\n/**/\n    2669,\n/**/\n    2668,\n/**/\n    2667,\n/**/\n    2666,\n/**/\n    2665,\n/**/\n    2664,\n/**/\n    2663,\n/**/\n    2662,\n/**/\n    2661,\n/**/\n    2660,\n/**/\n    2659,\n/**/\n    2658,\n/**/\n    2657,\n/**/\n    2656,\n/**/\n    2655,\n/**/\n    2654,\n/**/\n    2653,\n/**/\n    2652,\n/**/\n    2651,\n/**/\n    2650,\n/**/\n    2649,\n/**/\n    2648,\n/**/\n    2647,\n/**/\n    2646,\n/**/\n    2645,\n/**/\n    2644,\n/**/\n    2643,\n/**/\n    2642,\n/**/\n    2641,\n/**/\n    2640,\n/**/\n    2639,\n/**/\n    2638,\n/**/\n    2637,\n/**/\n    2636,\n/**/\n    2635,\n/**/\n    2634,\n/**/\n    2633,\n/**/\n    2632,\n/**/\n    2631,\n/**/\n    2630,\n/**/\n    2629,\n/**/\n    2628,\n/**/\n    2627,\n/**/\n    2626,\n/**/\n    2625,\n/**/\n    2624,\n/**/\n    2623,\n/**/\n    2622,\n/**/\n    2621,\n/**/\n    2620,\n/**/\n    2619,\n/**/\n    2618,\n/**/\n    2617,\n/**/\n    2616,\n/**/\n    2615,\n/**/\n    2614,\n/**/\n    2613,\n/**/\n    2612,\n/**/\n    2611,\n/**/\n    2610,\n/**/\n    2609,\n/**/\n    2608,\n/**/\n    2607,\n/**/\n    2606,\n/**/\n    2605,\n/**/\n    2604,\n/**/\n    2603,\n/**/\n    2602,\n/**/\n    2601,\n/**/\n    2600,\n/**/\n    2599,\n/**/\n    2598,\n/**/\n    2597,\n/**/\n    2596,\n/**/\n    2595,\n/**/\n    2594,\n/**/\n    2593,\n/**/\n    2592,\n/**/\n    2591,\n/**/\n    2590,\n/**/\n    2589,\n/**/\n    2588,\n/**/\n    2587,\n/**/\n    2586,\n/**/\n    2585,\n/**/\n    2584,\n/**/\n    2583,\n/**/\n    2582,\n/**/\n    2581,\n/**/\n    2580,\n/**/\n    2579,\n/**/\n    2578,\n/**/\n    2577,\n/**/\n    2576,\n/**/\n    2575,\n/**/\n    2574,\n/**/\n    2573,\n/**/\n    2572,\n/**/\n    2571,\n/**/\n    2570,\n/**/\n    2569,\n/**/\n    2568,\n/**/\n    2567,\n/**/\n    2566,\n/**/\n    2565,\n/**/\n    2564,\n/**/\n    2563,\n/**/\n    2562,\n/**/\n    2561,\n/**/\n    2560,\n/**/\n    2559,\n/**/\n    2558,\n/**/\n    2557,\n/**/\n    2556,\n/**/\n    2555,\n/**/\n    2554,\n/**/\n    2553,\n/**/\n    2552,\n/**/\n    2551,\n/**/\n    2550,\n/**/\n    2549,\n/**/\n    2548,\n/**/\n    2547,\n/**/\n    2546,\n/**/\n    2545,\n/**/\n    2544,\n/**/\n    2543,\n/**/\n    2542,\n/**/\n    2541,\n/**/\n    2540,\n/**/\n    2539,\n/**/\n    2538,\n/**/\n    2537,\n/**/\n    2536,\n/**/\n    2535,\n/**/\n    2534,\n/**/\n    2533,\n/**/\n    2532,\n/**/\n    2531,\n/**/\n    2530,\n/**/\n    2529,\n/**/\n    2528,\n/**/\n    2527,\n/**/\n    2526,\n/**/\n    2525,\n/**/\n    2524,\n/**/\n    2523,\n/**/\n    2522,\n/**/\n    2521,\n/**/\n    2520,\n/**/\n    2519,\n/**/\n    2518,\n/**/\n    2517,\n/**/\n    2516,\n/**/\n    2515,\n/**/\n    2514,\n/**/\n    2513,\n/**/\n    2512,\n/**/\n    2511,\n/**/\n    2510,\n/**/\n    2509,\n/**/\n    2508,\n/**/\n    2507,\n/**/\n    2506,\n/**/\n    2505,\n/**/\n    2504,\n/**/\n    2503,\n/**/\n    2502,\n/**/\n    2501,\n/**/\n    2500,\n/**/\n    2499,\n/**/\n    2498,\n/**/\n    2497,\n/**/\n    2496,\n/**/\n    2495,\n/**/\n    2494,\n/**/\n    2493,\n/**/\n    2492,\n/**/\n    2491,\n/**/\n    2490,\n/**/\n    2489,\n/**/\n    2488,\n/**/\n    2487,\n/**/\n    2486,\n/**/\n    2485,\n/**/\n    2484,\n/**/\n    2483,\n/**/\n    2482,\n/**/\n    2481,\n/**/\n    2480,\n/**/\n    2479,\n/**/\n    2478,\n/**/\n    2477,\n/**/\n    2476,\n/**/\n    2475,\n/**/\n    2474,\n/**/\n    2473,\n/**/\n    2472,\n/**/\n    2471,\n/**/\n    2470,\n/**/\n    2469,\n/**/\n    2468,\n/**/\n    2467,\n/**/\n    2466,\n/**/\n    2465,\n/**/\n    2464,\n/**/\n    2463,\n/**/\n    2462,\n/**/\n    2461,\n/**/\n    2460,\n/**/\n    2459,\n/**/\n    2458,\n/**/\n    2457,\n/**/\n    2456,\n/**/\n    2455,\n/**/\n    2454,\n/**/\n    2453,\n/**/\n    2452,\n/**/\n    2451,\n/**/\n    2450,\n/**/\n    2449,\n/**/\n    2448,\n/**/\n    2447,\n/**/\n    2446,\n/**/\n    2445,\n/**/\n    2444,\n/**/\n    2443,\n/**/\n    2442,\n/**/\n    2441,\n/**/\n    2440,\n/**/\n    2439,\n/**/\n    2438,\n/**/\n    2437,\n/**/\n    2436,\n/**/\n    2435,\n/**/\n    2434,\n/**/\n    2433,\n/**/\n    2432,\n/**/\n    2431,\n/**/\n    2430,\n/**/\n    2429,\n/**/\n    2428,\n/**/\n    2427,\n/**/\n    2426,\n/**/\n    2425,\n/**/\n    2424,\n/**/\n    2423,\n/**/\n    2422,\n/**/\n    2421,\n/**/\n    2420,\n/**/\n    2419,\n/**/\n    2418,\n/**/\n    2417,\n/**/\n    2416,\n/**/\n    2415,\n/**/\n    2414,\n/**/\n    2413,\n/**/\n    2412,\n/**/\n    2411,\n/**/\n    2410,\n/**/\n    2409,\n/**/\n    2408,\n/**/\n    2407,\n/**/\n    2406,\n/**/\n    2405,\n/**/\n    2404,\n/**/\n    2403,\n/**/\n    2402,\n/**/\n    2401,\n/**/\n    2400,\n/**/\n    2399,\n/**/\n    2398,\n/**/\n    2397,\n/**/\n    2396,\n/**/\n    2395,\n/**/\n    2394,\n/**/\n    2393,\n/**/\n    2392,\n/**/\n    2391,\n/**/\n    2390,\n/**/\n    2389,\n/**/\n    2388,\n/**/\n    2387,\n/**/\n    2386,\n/**/\n    2385,\n/**/\n    2384,\n/**/\n    2383,\n/**/\n    2382,\n/**/\n    2381,\n/**/\n    2380,\n/**/\n    2379,\n/**/\n    2378,\n/**/\n    2377,\n/**/\n    2376,\n/**/\n    2375,\n/**/\n    2374,\n/**/\n    2373,\n/**/\n    2372,\n/**/\n    2371,\n/**/\n    2370,\n/**/\n    2369,\n/**/\n    2368,\n/**/\n    2367,\n/**/\n    2366,\n/**/\n    2365,\n/**/\n    2364,\n/**/\n    2363,\n/**/\n    2362,\n/**/\n    2361,\n/**/\n    2360,\n/**/\n    2359,\n/**/\n    2358,\n/**/\n    2357,\n/**/\n    2356,\n/**/\n    2355,\n/**/\n    2354,\n/**/\n    2353,\n/**/\n    2352,\n/**/\n    2351,\n/**/\n    2350,\n/**/\n    2349,\n/**/\n    2348,\n/**/\n    2347,\n/**/\n    2346,\n/**/\n    2345,\n/**/\n    2344,\n/**/\n    2343,\n/**/\n    2342,\n/**/\n    2341,\n/**/\n    2340,\n/**/\n    2339,\n/**/\n    2338,\n/**/\n    2337,\n/**/\n    2336,\n/**/\n    2335,\n/**/\n    2334,\n/**/\n    2333,\n/**/\n    2332,\n/**/\n    2331,\n/**/\n    2330,\n/**/\n    2329,\n/**/\n    2328,\n/**/\n    2327,\n/**/\n    2326,\n/**/\n    2325,\n/**/\n    2324,\n/**/\n    2323,\n/**/\n    2322,\n/**/\n    2321,\n/**/\n    2320,\n/**/\n    2319,\n/**/\n    2318,\n/**/\n    2317,\n/**/\n    2316,\n/**/\n    2315,\n/**/\n    2314,\n/**/\n    2313,\n/**/\n    2312,\n/**/\n    2311,\n/**/\n    2310,\n/**/\n    2309,\n/**/\n    2308,\n/**/\n    2307,\n/**/\n    2306,\n/**/\n    2305,\n/**/\n    2304,\n/**/\n    2303,\n/**/\n    2302,\n/**/\n    2301,\n/**/\n    2300,\n/**/\n    2299,\n/**/\n    2298,\n/**/\n    2297,\n/**/\n    2296,\n/**/\n    2295,\n/**/\n    2294,\n/**/\n    2293,\n/**/\n    2292,\n/**/\n    2291,\n/**/\n    2290,\n/**/\n    2289,\n/**/\n    2288,\n/**/\n    2287,\n/**/\n    2286,\n/**/\n    2285,\n/**/\n    2284,\n/**/\n    2283,\n/**/\n    2282,\n/**/\n    2281,\n/**/\n    2280,\n/**/\n    2279,\n/**/\n    2278,\n/**/\n    2277,\n/**/\n    2276,\n/**/\n    2275,\n/**/\n    2274,\n/**/\n    2273,\n/**/\n    2272,\n/**/\n    2271,\n/**/\n    2270,\n/**/\n    2269,\n/**/\n    2268,\n/**/\n    2267,\n/**/\n    2266,\n/**/\n    2265,\n/**/\n    2264,\n/**/\n    2263,\n/**/\n    2262,\n/**/\n    2261,\n/**/\n    2260,\n/**/\n    2259,\n/**/\n    2258,\n/**/\n    2257,\n/**/\n    2256,\n/**/\n    2255,\n/**/\n    2254,\n/**/\n    2253,\n/**/\n    2252,\n/**/\n    2251,\n/**/\n    2250,\n/**/\n    2249,\n/**/\n    2248,\n/**/\n    2247,\n/**/\n    2246,\n/**/\n    2245,\n/**/\n    2244,\n/**/\n    2243,\n/**/\n    2242,\n/**/\n    2241,\n/**/\n    2240,\n/**/\n    2239,\n/**/\n    2238,\n/**/\n    2237,\n/**/\n    2236,\n/**/\n    2235,\n/**/\n    2234,\n/**/\n    2233,\n/**/\n    2232,\n/**/\n    2231,\n/**/\n    2230,\n/**/\n    2229,\n/**/\n    2228,\n/**/\n    2227,\n/**/\n    2226,\n/**/\n    2225,\n/**/\n    2224,\n/**/\n    2223,\n/**/\n    2222,\n/**/\n    2221,\n/**/\n    2220,\n/**/\n    2219,\n/**/\n    2218,\n/**/\n    2217,\n/**/\n    2216,\n/**/\n    2215,\n/**/\n    2214,\n/**/\n    2213,\n/**/\n    2212,\n/**/\n    2211,\n/**/\n    2210,\n/**/\n    2209,\n/**/\n    2208,\n/**/\n    2207,\n/**/\n    2206,\n/**/\n    2205,\n/**/\n    2204,\n/**/\n    2203,\n/**/\n    2202,\n/**/\n    2201,\n/**/\n    2200,\n/**/\n    2199,\n/**/\n    2198,\n/**/\n    2197,\n/**/\n    2196,\n/**/\n    2195,\n/**/\n    2194,\n/**/\n    2193,\n/**/\n    2192,\n/**/\n    2191,\n/**/\n    2190,\n/**/\n    2189,\n/**/\n    2188,\n/**/\n    2187,\n/**/\n    2186,\n/**/\n    2185,\n/**/\n    2184,\n/**/\n    2183,\n/**/\n    2182,\n/**/\n    2181,\n/**/\n    2180,\n/**/\n    2179,\n/**/\n    2178,\n/**/\n    2177,\n/**/\n    2176,\n/**/\n    2175,\n/**/\n    2174,\n/**/\n    2173,\n/**/\n    2172,\n/**/\n    2171,\n/**/\n    2170,\n/**/\n    2169,\n/**/\n    2168,\n/**/\n    2167,\n/**/\n    2166,\n/**/\n    2165,\n/**/\n    2164,\n/**/\n    2163,\n/**/\n    2162,\n/**/\n    2161,\n/**/\n    2160,\n/**/\n    2159,\n/**/\n    2158,\n/**/\n    2157,\n/**/\n    2156,\n/**/\n    2155,\n/**/\n    2154,\n/**/\n    2153,\n/**/\n    2152,\n/**/\n    2151,\n/**/\n    2150,\n/**/\n    2149,\n/**/\n    2148,\n/**/\n    2147,\n/**/\n    2146,\n/**/\n    2145,\n/**/\n    2144,\n/**/\n    2143,\n/**/\n    2142,\n/**/\n    2141,\n/**/\n    2140,\n/**/\n    2139,\n/**/\n    2138,\n/**/\n    2137,\n/**/\n    2136,\n/**/\n    2135,\n/**/\n    2134,\n/**/\n    2133,\n/**/\n    2132,\n/**/\n    2131,\n/**/\n    2130,\n/**/\n    2129,\n/**/\n    2128,\n/**/\n    2127,\n/**/\n    2126,\n/**/\n    2125,\n/**/\n    2124,\n/**/\n    2123,\n/**/\n    2122,\n/**/\n    2121,\n/**/\n    2120,\n/**/\n    2119,\n/**/\n    2118,\n/**/\n    2117,\n/**/\n    2116,\n/**/\n    2115,\n/**/\n    2114,\n/**/\n    2113,\n/**/\n    2112,\n/**/\n    2111,\n/**/\n    2110,\n/**/\n    2109,\n/**/\n    2108,\n/**/\n    2107,\n/**/\n    2106,\n/**/\n    2105,\n/**/\n    2104,\n/**/\n    2103,\n/**/\n    2102,\n/**/\n    2101,\n/**/\n    2100,\n/**/\n    2099,\n/**/\n    2098,\n/**/\n    2097,\n/**/\n    2096,\n/**/\n    2095,\n/**/\n    2094,\n/**/\n    2093,\n/**/\n    2092,\n/**/\n    2091,\n/**/\n    2090,\n/**/\n    2089,\n/**/\n    2088,\n/**/\n    2087,\n/**/\n    2086,\n/**/\n    2085,\n/**/\n    2084,\n/**/\n    2083,\n/**/\n    2082,\n/**/\n    2081,\n/**/\n    2080,\n/**/\n    2079,\n/**/\n    2078,\n/**/\n    2077,\n/**/\n    2076,\n/**/\n    2075,\n/**/\n    2074,\n/**/\n    2073,\n/**/\n    2072,\n/**/\n    2071,\n/**/\n    2070,\n/**/\n    2069,\n/**/\n    2068,\n/**/\n    2067,\n/**/\n    2066,\n/**/\n    2065,\n/**/\n    2064,\n/**/\n    2063,\n/**/\n    2062,\n/**/\n    2061,\n/**/\n    2060,\n/**/\n    2059,\n/**/\n    2058,\n/**/\n    2057,\n/**/\n    2056,\n/**/\n    2055,\n/**/\n    2054,\n/**/\n    2053,\n/**/\n    2052,\n/**/\n    2051,\n/**/\n    2050,\n/**/\n    2049,\n/**/\n    2048,\n/**/\n    2047,\n/**/\n    2046,\n/**/\n    2045,\n/**/\n    2044,\n/**/\n    2043,\n/**/\n    2042,\n/**/\n    2041,\n/**/\n    2040,\n/**/\n    2039,\n/**/\n    2038,\n/**/\n    2037,\n/**/\n    2036,\n/**/\n    2035,\n/**/\n    2034,\n/**/\n    2033,\n/**/\n    2032,\n/**/\n    2031,\n/**/\n    2030,\n/**/\n    2029,\n/**/\n    2028,\n/**/\n    2027,\n/**/\n    2026,\n/**/\n    2025,\n/**/\n    2024,\n/**/\n    2023,\n/**/\n    2022,\n/**/\n    2021,\n/**/\n    2020,\n/**/\n    2019,\n/**/\n    2018,\n/**/\n    2017,\n/**/\n    2016,\n/**/\n    2015,\n/**/\n    2014,\n/**/\n    2013,\n/**/\n    2012,\n/**/\n    2011,\n/**/\n    2010,\n/**/\n    2009,\n/**/\n    2008,\n/**/\n    2007,\n/**/\n    2006,\n/**/\n    2005,\n/**/\n    2004,\n/**/\n    2003,\n/**/\n    2002,\n/**/\n    2001,\n/**/\n    2000,\n/**/\n    1999,\n/**/\n    1998,\n/**/\n    1997,\n/**/\n    1996,\n/**/\n    1995,\n/**/\n    1994,\n/**/\n    1993,\n/**/\n    1992,\n/**/\n    1991,\n/**/\n    1990,\n/**/\n    1989,\n/**/\n    1988,\n/**/\n    1987,\n/**/\n    1986,\n/**/\n    1985,\n/**/\n    1984,\n/**/\n    1983,\n/**/\n    1982,\n/**/\n    1981,\n/**/\n    1980,\n/**/\n    1979,\n/**/\n    1978,\n/**/\n    1977,\n/**/\n    1976,\n/**/\n    1975,\n/**/\n    1974,\n/**/\n    1973,\n/**/\n    1972,\n/**/\n    1971,\n/**/\n    1970,\n/**/\n    1969,\n/**/\n    1968,\n/**/\n    1967,\n/**/\n    1966,\n/**/\n    1965,\n/**/\n    1964,\n/**/\n    1963,\n/**/\n    1962,\n/**/\n    1961,\n/**/\n    1960,\n/**/\n    1959,\n/**/\n    1958,\n/**/\n    1957,\n/**/\n    1956,\n/**/\n    1955,\n/**/\n    1954,\n/**/\n    1953,\n/**/\n    1952,\n/**/\n    1951,\n/**/\n    1950,\n/**/\n    1949,\n/**/\n    1948,\n/**/\n    1947,\n/**/\n    1946,\n/**/\n    1945,\n/**/\n    1944,\n/**/\n    1943,\n/**/\n    1942,\n/**/\n    1941,\n/**/\n    1940,\n/**/\n    1939,\n/**/\n    1938,\n/**/\n    1937,\n/**/\n    1936,\n/**/\n    1935,\n/**/\n    1934,\n/**/\n    1933,\n/**/\n    1932,\n/**/\n    1931,\n/**/\n    1930,\n/**/\n    1929,\n/**/\n    1928,\n/**/\n    1927,\n/**/\n    1926,\n/**/\n    1925,\n/**/\n    1924,\n/**/\n    1923,\n/**/\n    1922,\n/**/\n    1921,\n/**/\n    1920,\n/**/\n    1919,\n/**/\n    1918,\n/**/\n    1917,\n/**/\n    1916,\n/**/\n    1915,\n/**/\n    1914,\n/**/\n    1913,\n/**/\n    1912,\n/**/\n    1911,\n/**/\n    1910,\n/**/\n    1909,\n/**/\n    1908,\n/**/\n    1907,\n/**/\n    1906,\n/**/\n    1905,\n/**/\n    1904,\n/**/\n    1903,\n/**/\n    1902,\n/**/\n    1901,\n/**/\n    1900,\n/**/\n    1899,\n/**/\n    1898,\n/**/\n    1897,\n/**/\n    1896,\n/**/\n    1895,\n/**/\n    1894,\n/**/\n    1893,\n/**/\n    1892,\n/**/\n    1891,\n/**/\n    1890,\n/**/\n    1889,\n/**/\n    1888,\n/**/\n    1887,\n/**/\n    1886,\n/**/\n    1885,\n/**/\n    1884,\n/**/\n    1883,\n/**/\n    1882,\n/**/\n    1881,\n/**/\n    1880,\n/**/\n    1879,\n/**/\n    1878,\n/**/\n    1877,\n/**/\n    1876,\n/**/\n    1875,\n/**/\n    1874,\n/**/\n    1873,\n/**/\n    1872,\n/**/\n    1871,\n/**/\n    1870,\n/**/\n    1869,\n/**/\n    1868,\n/**/\n    1867,\n/**/\n    1866,\n/**/\n    1865,\n/**/\n    1864,\n/**/\n    1863,\n/**/\n    1862,\n/**/\n    1861,\n/**/\n    1860,\n/**/\n    1859,\n/**/\n    1858,\n/**/\n    1857,\n/**/\n    1856,\n/**/\n    1855,\n/**/\n    1854,\n/**/\n    1853,\n/**/\n    1852,\n/**/\n    1851,\n/**/\n    1850,\n/**/\n    1849,\n/**/\n    1848,\n/**/\n    1847,\n/**/\n    1846,\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    while (l < h)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + (item_count % ncol ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#ifdef FEAT_HUGE\n    msg_puts(_(\"\\nHuge version \"));\n#else\n# ifdef FEAT_BIG\n    msg_puts(_(\"\\nBig version \"));\n# else\n#  ifdef FEAT_NORMAL\n    msg_puts(_(\"\\nNormal version \"));\n#  else\n#   ifdef FEAT_SMALL\n    msg_puts(_(\"\\nSmall version \"));\n#   else\n    msg_puts(_(\"\\nTiny version \"));\n#   endif\n#  endif\n# endif\n#endif\n#ifndef FEAT_GUI\n    msg_puts(_(\"without GUI.\"));\n#else\n# ifdef FEAT_GUI_GTK\n#  ifdef USE_GTK3\n    msg_puts(_(\"with GTK3 GUI.\"));\n#  else\n#   ifdef FEAT_GUI_GNOME\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n#   else\n     msg_puts(_(\"with GTK2 GUI.\"));\n#   endif\n# endif\n# else\n#  ifdef FEAT_GUI_MOTIF\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#  else\n#   ifdef FEAT_GUI_ATHENA\n#    ifdef FEAT_GUI_NEXTAW\n    msg_puts(_(\"with X11-neXtaw GUI.\"));\n#    else\n    msg_puts(_(\"with X11-Athena GUI.\"));\n#    endif\n#   else\n#    ifdef FEAT_GUI_HAIKU\n    msg_puts(_(\"with Haiku GUI.\"));\n#    else\n#     ifdef FEAT_GUI_PHOTON\n    msg_puts(_(\"with Photon GUI.\"));\n#     else\n#      if defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#      endif\n#     endif\n#    endif\n#   endif\n#  endif\n# endif\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version8<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "fixing_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * spellsuggest.c: functions for spelling suggestions\n */\n\n#include \"vim.h\"\n\n#if defined(FEAT_SPELL) || defined(PROTO)\n\n/*\n * Use this to adjust the score after finding suggestions, based on the\n * suggested word sounding like the bad word.  This is much faster than doing\n * it for every possible suggestion.\n * Disadvantage: When \"the\" is typed as \"hte\" it sounds quite different (\"@\"\n * vs \"ht\") and goes down in the list.\n * Used when 'spellsuggest' is set to \"best\".\n */\n#define RESCORE(word_score, sound_score) ((3 * word_score + sound_score) / 4)\n\n/*\n * Do the opposite: based on a maximum end score and a known sound score,\n * compute the maximum word score that can be used.\n */\n#define MAXSCORE(word_score, sound_score) ((4 * word_score - sound_score) / 3)\n\n// only used for su_badflags\n#define WF_MIXCAP   0x20\t// mix of upper and lower case: macaRONI\n\n/*\n * Information used when looking for suggestions.\n */\ntypedef struct suginfo_S\n{\n    garray_T\tsu_ga;\t\t    // suggestions, contains \"suggest_T\"\n    int\t\tsu_maxcount;\t    // max. number of suggestions displayed\n    int\t\tsu_maxscore;\t    // maximum score for adding to su_ga\n    int\t\tsu_sfmaxscore;\t    // idem, for when doing soundfold words\n    garray_T\tsu_sga;\t\t    // like su_ga, sound-folded scoring\n    char_u\t*su_badptr;\t    // start of bad word in line\n    int\t\tsu_badlen;\t    // length of detected bad word in line\n    int\t\tsu_badflags;\t    // caps flags for bad word\n    char_u\tsu_badword[MAXWLEN]; // bad word truncated at su_badlen\n    char_u\tsu_fbadword[MAXWLEN]; // su_badword case-folded\n    char_u\tsu_sal_badword[MAXWLEN]; // su_badword soundfolded\n    hashtab_T\tsu_banned;\t    // table with banned words\n    slang_T\t*su_sallang;\t    // default language for sound folding\n} suginfo_T;\n\n// One word suggestion.  Used in \"si_ga\".\ntypedef struct suggest_S\n{\n    char_u\t*st_word;\t// suggested word, allocated string\n    int\t\tst_wordlen;\t// STRLEN(st_word)\n    int\t\tst_orglen;\t// length of replaced text\n    int\t\tst_score;\t// lower is better\n    int\t\tst_altscore;\t// used when st_score compares equal\n    int\t\tst_salscore;\t// st_score is for soundalike\n    int\t\tst_had_bonus;\t// bonus already included in score\n    slang_T\t*st_slang;\t// language used for sound folding\n} suggest_T;\n\n#define SUG(ga, i) (((suggest_T *)(ga).ga_data)[i])\n\n// TRUE if a word appears in the list of banned words.\n#define WAS_BANNED(su, word) (!HASHITEM_EMPTY(hash_find(&su->su_banned, word)))\n\n// Number of suggestions kept when cleaning up.  We need to keep more than\n// what is displayed, because when rescore_suggestions() is called the score\n// may change and wrong suggestions may be removed later.\n#define SUG_CLEAN_COUNT(su)    ((su)->su_maxcount < 130 ? 150 : (su)->su_maxcount + 20)\n\n// Threshold for sorting and cleaning up suggestions.  Don't want to keep lots\n// of suggestions that are not going to be displayed.\n#define SUG_MAX_COUNT(su)\t(SUG_CLEAN_COUNT(su) + 50)\n\n// score for various changes\n#define SCORE_SPLIT\t149\t// split bad word\n#define SCORE_SPLIT_NO\t249\t// split bad word with NOSPLITSUGS\n#define SCORE_ICASE\t52\t// slightly different case\n#define SCORE_REGION\t200\t// word is for different region\n#define SCORE_RARE\t180\t// rare word\n#define SCORE_SWAP\t75\t// swap two characters\n#define SCORE_SWAP3\t110\t// swap two characters in three\n#define SCORE_REP\t65\t// REP replacement\n#define SCORE_SUBST\t93\t// substitute a character\n#define SCORE_SIMILAR\t33\t// substitute a similar character\n#define SCORE_SUBCOMP\t33\t// substitute a composing character\n#define SCORE_DEL\t94\t// delete a character\n#define SCORE_DELDUP\t66\t// delete a duplicated character\n#define SCORE_DELCOMP\t28\t// delete a composing character\n#define SCORE_INS\t96\t// insert a character\n#define SCORE_INSDUP\t67\t// insert a duplicate character\n#define SCORE_INSCOMP\t30\t// insert a composing character\n#define SCORE_NONWORD\t103\t// change non-word to word char\n\n#define SCORE_FILE\t30\t// suggestion from a file\n#define SCORE_MAXINIT\t350\t// Initial maximum score: higher == slower.\n\t\t\t\t// 350 allows for about three changes.\n\n#define SCORE_COMMON1\t30\t// subtracted for words seen before\n#define SCORE_COMMON2\t40\t// subtracted for words often seen\n#define SCORE_COMMON3\t50\t// subtracted for words very often seen\n#define SCORE_THRES2\t10\t// word count threshold for COMMON2\n#define SCORE_THRES3\t100\t// word count threshold for COMMON3\n\n// When trying changed soundfold words it becomes slow when trying more than\n// two changes.  With less than two changes it's slightly faster but we miss a\n// few good suggestions.  In rare cases we need to try three of four changes.\n#define SCORE_SFMAX1\t200\t// maximum score for first try\n#define SCORE_SFMAX2\t300\t// maximum score for second try\n#define SCORE_SFMAX3\t400\t// maximum score for third try\n\n#define SCORE_BIG\tSCORE_INS * 3\t// big difference\n#define SCORE_MAXMAX\t999999\t\t// accept any score\n#define SCORE_LIMITMAX\t350\t\t// for spell_edit_score_limit()\n\n// for spell_edit_score_limit() we need to know the minimum value of\n// SCORE_ICASE, SCORE_SWAP, SCORE_DEL, SCORE_SIMILAR and SCORE_INS\n#define SCORE_EDIT_MIN\tSCORE_SIMILAR\n\n/*\n * For finding suggestions: At each node in the tree these states are tried:\n */\ntypedef enum\n{\n    STATE_START = 0,\t// At start of node check for NUL bytes (goodword\n\t\t\t// ends); if badword ends there is a match, otherwise\n\t\t\t// try splitting word.\n    STATE_NOPREFIX,\t// try without prefix\n    STATE_SPLITUNDO,\t// Undo splitting.\n    STATE_ENDNUL,\t// Past NUL bytes at start of the node.\n    STATE_PLAIN,\t// Use each byte of the node.\n    STATE_DEL,\t\t// Delete a byte from the bad word.\n    STATE_INS_PREP,\t// Prepare for inserting bytes.\n    STATE_INS,\t\t// Insert a byte in the bad word.\n    STATE_SWAP,\t\t// Swap two bytes.\n    STATE_UNSWAP,\t// Undo swap two characters.\n    STATE_SWAP3,\t// Swap two characters over three.\n    STATE_UNSWAP3,\t// Undo Swap two characters over three.\n    STATE_UNROT3L,\t// Undo rotate three characters left\n    STATE_UNROT3R,\t// Undo rotate three characters right\n    STATE_REP_INI,\t// Prepare for using REP items.\n    STATE_REP,\t\t// Use matching REP items from the .aff file.\n    STATE_REP_UNDO,\t// Undo a REP item replacement.\n    STATE_FINAL\t\t// End of this node.\n} state_T;\n\n/*\n * Struct to keep the state at each level in suggest_try_change().\n */\ntypedef struct trystate_S\n{\n    state_T\tts_state;\t// state at this level, STATE_\n    int\t\tts_score;\t// score\n    idx_T\tts_arridx;\t// index in tree array, start of node\n    short\tts_curi;\t// index in list of child nodes\n    char_u\tts_fidx;\t// index in fword[], case-folded bad word\n    char_u\tts_fidxtry;\t// ts_fidx at which bytes may be changed\n    char_u\tts_twordlen;\t// valid length of tword[]\n    char_u\tts_prefixdepth;\t// stack depth for end of prefix or\n\t\t\t\t// PFD_PREFIXTREE or PFD_NOPREFIX\n    char_u\tts_flags;\t// TSF_ flags\n    char_u\tts_tcharlen;\t// number of bytes in tword character\n    char_u\tts_tcharidx;\t// current byte index in tword character\n    char_u\tts_isdiff;\t// DIFF_ values\n    char_u\tts_fcharstart;\t// index in fword where badword char started\n    char_u\tts_prewordlen;\t// length of word in \"preword[]\"\n    char_u\tts_splitoff;\t// index in \"tword\" after last split\n    char_u\tts_splitfidx;\t// \"ts_fidx\" at word split\n    char_u\tts_complen;\t// nr of compound words used\n    char_u\tts_compsplit;\t// index for \"compflags\" where word was spit\n    char_u\tts_save_badflags;   // su_badflags saved here\n    char_u\tts_delidx;\t// index in fword for char that was deleted,\n\t\t\t\t// valid when \"ts_flags\" has TSF_DIDDEL\n} trystate_T;\n\n// values for ts_isdiff\n#define DIFF_NONE\t0\t// no different byte (yet)\n#define DIFF_YES\t1\t// different byte found\n#define DIFF_INSERT\t2\t// inserting character\n\n// values for ts_flags\n#define TSF_PREFIXOK\t1\t// already checked that prefix is OK\n#define TSF_DIDSPLIT\t2\t// tried split at this point\n#define TSF_DIDDEL\t4\t// did a delete, \"ts_delidx\" has index\n\n// special values ts_prefixdepth\n#define PFD_NOPREFIX\t0xff\t// not using prefixes\n#define PFD_PREFIXTREE\t0xfe\t// walking through the prefix tree\n#define PFD_NOTSPECIAL\t0xfd\t// highest value that's not special\n\nstatic void spell_find_suggest(char_u *badptr, int badlen, suginfo_T *su, int maxcount, int banbadword, int need_cap, int interactive);\n#ifdef FEAT_EVAL\nstatic void spell_suggest_expr(suginfo_T *su, char_u *expr);\n#endif\nstatic void spell_suggest_file(suginfo_T *su, char_u *fname);\nstatic void spell_suggest_intern(suginfo_T *su, int interactive);\nstatic void spell_find_cleanup(suginfo_T *su);\nstatic void suggest_try_special(suginfo_T *su);\nstatic void suggest_try_change(suginfo_T *su);\nstatic void suggest_trie_walk(suginfo_T *su, langp_T *lp, char_u *fword, int soundfold);\nstatic void go_deeper(trystate_T *stack, int depth, int score_add);\nstatic void find_keepcap_word(slang_T *slang, char_u *fword, char_u *kword);\nstatic void score_comp_sal(suginfo_T *su);\nstatic void score_combine(suginfo_T *su);\nstatic int stp_sal_score(suggest_T *stp, suginfo_T *su, slang_T *slang, char_u *badsound);\nstatic void suggest_try_soundalike_prep(void);\nstatic void suggest_try_soundalike(suginfo_T *su);\nstatic void suggest_try_soundalike_finish(void);\nstatic void add_sound_suggest(suginfo_T *su, char_u *goodword, int score, langp_T *lp);\nstatic int soundfold_find(slang_T *slang, char_u *word);\nstatic int similar_chars(slang_T *slang, int c1, int c2);\nstatic void add_suggestion(suginfo_T *su, garray_T *gap, char_u *goodword, int badlen, int score, int altscore, int had_bonus, slang_T *slang, int maxsf);\nstatic void check_suggestions(suginfo_T *su, garray_T *gap);\nstatic void add_banned(suginfo_T *su, char_u *word);\nstatic void rescore_suggestions(suginfo_T *su);\nstatic void rescore_one(suginfo_T *su, suggest_T *stp);\nstatic int cleanup_suggestions(garray_T *gap, int maxscore, int keep);\nstatic int soundalike_score(char_u *goodsound, char_u *badsound);\nstatic int spell_edit_score(slang_T *slang, char_u *badword, char_u *goodword);\nstatic int spell_edit_score_limit(slang_T *slang, char_u *badword, char_u *goodword, int limit);\nstatic int spell_edit_score_limit_w(slang_T *slang, char_u *badword, char_u *goodword, int limit);\n\n/*\n * Return TRUE when the sequence of flags in \"compflags\" plus \"flag\" can\n * possibly form a valid compounded word.  This also checks the COMPOUNDRULE\n * lines if they don't contain wildcards.\n */\n    static int\ncan_be_compound(\n    trystate_T\t*sp,\n    slang_T\t*slang,\n    char_u\t*compflags,\n    int\t\tflag)\n{\n    // If the flag doesn't appear in sl_compstartflags or sl_compallflags\n    // then it can't possibly compound.\n    if (!byte_in_str(sp->ts_complen == sp->ts_compsplit\n\t\t? slang->sl_compstartflags : slang->sl_compallflags, flag))\n\treturn FALSE;\n\n    // If there are no wildcards, we can check if the flags collected so far\n    // possibly can form a match with COMPOUNDRULE patterns.  This only\n    // makes sense when we have two or more words.\n    if (slang->sl_comprules != NULL && sp->ts_complen > sp->ts_compsplit)\n    {\n\tint v;\n\n\tcompflags[sp->ts_complen] = flag;\n\tcompflags[sp->ts_complen + 1] = NUL;\n\tv = match_compoundrule(slang, compflags + sp->ts_compsplit);\n\tcompflags[sp->ts_complen] = NUL;\n\treturn v;\n    }\n\n    return TRUE;\n}\n\n/*\n * Adjust the score of common words.\n */\n    static int\nscore_wordcount_adj(\n    slang_T\t*slang,\n    int\t\tscore,\n    char_u\t*word,\n    int\t\tsplit)\t    // word was split, less bonus\n{\n    hashitem_T\t*hi;\n    wordcount_T\t*wc;\n    int\t\tbonus;\n    int\t\tnewscore;\n\n    hi = hash_find(&slang->sl_wordcount, word);\n    if (!HASHITEM_EMPTY(hi))\n    {\n\twc = HI2WC(hi);\n\tif (wc->wc_count < SCORE_THRES2)\n\t    bonus = SCORE_COMMON1;\n\telse if (wc->wc_count < SCORE_THRES3)\n\t    bonus = SCORE_COMMON2;\n\telse\n\t    bonus = SCORE_COMMON3;\n\tif (split)\n\t    newscore = score - bonus / 2;\n\telse\n\t    newscore = score - bonus;\n\tif (newscore < 0)\n\t    return 0;\n\treturn newscore;\n    }\n    return score;\n}\n\n/*\n * Like captype() but for a KEEPCAP word add ONECAP if the word starts with a\n * capital.  So that make_case_word() can turn WOrd into Word.\n * Add ALLCAP for \"WOrD\".\n */\n    static int\nbadword_captype(char_u *word, char_u *end)\n{\n    int\t\tflags = captype(word, end);\n    int\t\tc;\n    int\t\tl, u;\n    int\t\tfirst;\n    char_u\t*p;\n\n    if (flags & WF_KEEPCAP)\n    {\n\t// Count the number of UPPER and lower case letters.\n\tl = u = 0;\n\tfirst = FALSE;\n\tfor (p = word; p < end; MB_PTR_ADV(p))\n\t{\n\t    c = PTR2CHAR(p);\n\t    if (SPELL_ISUPPER(c))\n\t    {\n\t\t++u;\n\t\tif (p == word)\n\t\t    first = TRUE;\n\t    }\n\t    else\n\t\t++l;\n\t}\n\n\t// If there are more UPPER than lower case letters suggest an\n\t// ALLCAP word.  Otherwise, if the first letter is UPPER then\n\t// suggest ONECAP.  Exception: \"ALl\" most likely should be \"All\",\n\t// require three upper case letters.\n\tif (u > l && u > 2)\n\t    flags |= WF_ALLCAP;\n\telse if (first)\n\t    flags |= WF_ONECAP;\n\n\tif (u >= 2 && l >= 2)\t// maCARONI maCAroni\n\t    flags |= WF_MIXCAP;\n    }\n    return flags;\n}\n\n/*\n * Opposite of offset2bytes().\n * \"pp\" points to the bytes and is advanced over it.\n * Returns the offset.\n */\n    static int\nbytes2offset(char_u **pp)\n{\n    char_u\t*p = *pp;\n    int\t\tnr;\n    int\t\tc;\n\n    c = *p++;\n    if ((c & 0x80) == 0x00)\t\t// 1 byte\n    {\n\tnr = c - 1;\n    }\n    else if ((c & 0xc0) == 0x80)\t// 2 bytes\n    {\n\tnr = (c & 0x3f) - 1;\n\tnr = nr * 255 + (*p++ - 1);\n    }\n    else if ((c & 0xe0) == 0xc0)\t// 3 bytes\n    {\n\tnr = (c & 0x1f) - 1;\n\tnr = nr * 255 + (*p++ - 1);\n\tnr = nr * 255 + (*p++ - 1);\n    }\n    else\t\t\t\t// 4 bytes\n    {\n\tnr = (c & 0x0f) - 1;\n\tnr = nr * 255 + (*p++ - 1);\n\tnr = nr * 255 + (*p++ - 1);\n\tnr = nr * 255 + (*p++ - 1);\n    }\n\n    *pp = p;\n    return nr;\n}\n\n// values for sps_flags\n#define SPS_BEST    1\n#define SPS_FAST    2\n#define SPS_DOUBLE  4\n\nstatic int sps_flags = SPS_BEST;\t// flags from 'spellsuggest'\nstatic int sps_limit = 9999;\t\t// max nr of suggestions given\n\n/*\n * Check the 'spellsuggest' option.  Return FAIL if it's wrong.\n * Sets \"sps_flags\" and \"sps_limit\".\n */\n    int\nspell_check_sps(void)\n{\n    char_u\t*p;\n    char_u\t*s;\n    char_u\tbuf[MAXPATHL];\n    int\t\tf;\n\n    sps_flags = 0;\n    sps_limit = 9999;\n\n    for (p = p_sps; *p != NUL; )\n    {\n\tcopy_option_part(&p, buf, MAXPATHL, \",\");\n\n\tf = 0;\n\tif (VIM_ISDIGIT(*buf))\n\t{\n\t    s = buf;\n\t    sps_limit = getdigits(&s);\n\t    if (*s != NUL && !VIM_ISDIGIT(*s))\n\t\tf = -1;\n\t}\n\telse if (STRCMP(buf, \"best\") == 0)\n\t    f = SPS_BEST;\n\telse if (STRCMP(buf, \"fast\") == 0)\n\t    f = SPS_FAST;\n\telse if (STRCMP(buf, \"double\") == 0)\n\t    f = SPS_DOUBLE;\n\telse if (STRNCMP(buf, \"expr:\", 5) != 0\n\t\t&& STRNCMP(buf, \"file:\", 5) != 0)\n\t    f = -1;\n\n\tif (f == -1 || (sps_flags != 0 && f != 0))\n\t{\n\t    sps_flags = SPS_BEST;\n\t    sps_limit = 9999;\n\t    return FAIL;\n\t}\n\tif (f != 0)\n\t    sps_flags = f;\n    }\n\n    if (sps_flags == 0)\n\tsps_flags = SPS_BEST;\n\n    return OK;\n}\n\n/*\n * \"z=\": Find badly spelled word under or after the cursor.\n * Give suggestions for the properly spelled word.\n * In Visual mode use the highlighted word as the bad word.\n * When \"count\" is non-zero use that suggestion.\n */\n    void\nspell_suggest(int count)\n{\n    char_u\t*line;\n    pos_T\tprev_cursor = curwin->w_cursor;\n    char_u\twcopy[MAXWLEN + 2];\n    char_u\t*p;\n    int\t\ti;\n    int\t\tc;\n    suginfo_T\tsug;\n    suggest_T\t*stp;\n    int\t\tmouse_used;\n    int\t\tneed_cap;\n    int\t\tlimit;\n    int\t\tselected = count;\n    int\t\tbadlen = 0;\n    int\t\tmsg_scroll_save = msg_scroll;\n    int\t\two_spell_save = curwin->w_p_spell;\n\n    if (!curwin->w_p_spell)\n    {\n\tdid_set_spelllang(curwin);\n\tcurwin->w_p_spell = TRUE;\n    }\n\n    if (*curwin->w_s->b_p_spl == NUL)\n    {\n\temsg(_(e_spell_checking_is_not_possible));\n\treturn;\n    }\n\n    if (VIsual_active)\n    {\n\t// Use the Visually selected text as the bad word.  But reject\n\t// a multi-line selection.\n\tif (curwin->w_cursor.lnum != VIsual.lnum)\n\t{\n\t    vim_beep(BO_SPELL);\n\t    return;\n\t}\n\tbadlen = (int)curwin->w_cursor.col - (int)VIsual.col;\n\tif (badlen < 0)\n\t    badlen = -badlen;\n\telse\n\t    curwin->w_cursor.col = VIsual.col;\n\t++badlen;\n\tend_visual_mode();\n    }\n    // Find the start of the badly spelled word.\n    else if (spell_move_to(curwin, FORWARD, TRUE, TRUE, NULL) == 0\n\t    || curwin->w_cursor.col > prev_cursor.col)\n    {\n\t// No bad word or it starts after the cursor: use the word under the\n\t// cursor.\n\tcurwin->w_cursor = prev_cursor;\n\tline = ml_get_curline();\n\tp = line + curwin->w_cursor.col;\n\t// Backup to before start of word.\n\twhile (p > line && spell_iswordp_nmw(p, curwin))\n\t    MB_PTR_BACK(line, p);\n\t// Forward to start of word.\n\twhile (*p != NUL && !spell_iswordp_nmw(p, curwin))\n\t    MB_PTR_ADV(p);\n\n\tif (!spell_iswordp_nmw(p, curwin))\t\t// No word found.\n\t{\n\t    beep_flush();\n\t    return;\n\t}\n\tcurwin->w_cursor.col = (colnr_T)(p - line);\n    }\n\n    // Get the word and its length.\n\n    // Figure out if the word should be capitalised.\n    need_cap = check_need_cap(curwin->w_cursor.lnum, curwin->w_cursor.col);\n\n    // Make a copy of current line since autocommands may free the line.\n    line = vim_strsave(ml_get_curline());\n    if (line == NULL)\n\tgoto skip;\n\n    // Get the list of suggestions.  Limit to 'lines' - 2 or the number in\n    // 'spellsuggest', whatever is smaller.\n    if (sps_limit > (int)Rows - 2)\n\tlimit = (int)Rows - 2;\n    else\n\tlimit = sps_limit;\n    spell_find_suggest(line + curwin->w_cursor.col, badlen, &sug, limit,\n\t\t\t\t\t\t\tTRUE, need_cap, TRUE);\n\n    if (sug.su_ga.ga_len == 0)\n\tmsg(_(\"Sorry, no suggestions\"));\n    else if (count > 0)\n    {\n\tif (count > sug.su_ga.ga_len)\n\t    smsg(_(\"Sorry, only %ld suggestions\"), (long)sug.su_ga.ga_len);\n    }\n    else\n    {\n#ifdef FEAT_RIGHTLEFT\n\t// When 'rightleft' is set the list is drawn right-left.\n\tcmdmsg_rl = curwin->w_p_rl;\n\tif (cmdmsg_rl)\n\t    msg_col = Columns - 1;\n#endif\n\n\t// List the suggestions.\n\tmsg_start();\n\tmsg_row = Rows - 1;\t// for when 'cmdheight' > 1\n\tlines_left = Rows;\t// avoid more prompt\n\tvim_snprintf((char *)IObuff, IOSIZE, _(\"Change \\\"%.*s\\\" to:\"),\n\t\t\t\t\t\tsug.su_badlen, sug.su_badptr);\n#ifdef FEAT_RIGHTLEFT\n\tif (cmdmsg_rl && STRNCMP(IObuff, \"Change\", 6) == 0)\n\t{\n\t    // And now the rabbit from the high hat: Avoid showing the\n\t    // untranslated message rightleft.\n\t    vim_snprintf((char *)IObuff, IOSIZE, \":ot \\\"%.*s\\\" egnahC\",\n\t\t\t\t\t\tsug.su_badlen, sug.su_badptr);\n\t}\n#endif\n\tmsg_puts((char *)IObuff);\n\tmsg_clr_eos();\n\tmsg_putchar('\\n');\n\n\tmsg_scroll = TRUE;\n\tfor (i = 0; i < sug.su_ga.ga_len; ++i)\n\t{\n\t    stp = &SUG(sug.su_ga, i);\n\n\t    // The suggested word may replace only part of the bad word, add\n\t    // the not replaced part.\n\t    vim_strncpy(wcopy, stp->st_word, MAXWLEN);\n\t    if (sug.su_badlen > stp->st_orglen)\n\t\tvim_strncpy(wcopy + stp->st_wordlen,\n\t\t\t\t\t       sug.su_badptr + stp->st_orglen,\n\t\t\t\t\t      sug.su_badlen - stp->st_orglen);\n\t    vim_snprintf((char *)IObuff, IOSIZE, \"%2d\", i + 1);\n#ifdef FEAT_RIGHTLEFT\n\t    if (cmdmsg_rl)\n\t\trl_mirror(IObuff);\n#endif\n\t    msg_puts((char *)IObuff);\n\n\t    vim_snprintf((char *)IObuff, IOSIZE, \" \\\"%s\\\"\", wcopy);\n\t    msg_puts((char *)IObuff);\n\n\t    // The word may replace more than \"su_badlen\".\n\t    if (sug.su_badlen < stp->st_orglen)\n\t    {\n\t\tvim_snprintf((char *)IObuff, IOSIZE, _(\" < \\\"%.*s\\\"\"),\n\t\t\t\t\t       stp->st_orglen, sug.su_badptr);\n\t\tmsg_puts((char *)IObuff);\n\t    }\n\n\t    if (p_verbose > 0)\n\t    {\n\t\t// Add the score.\n\t\tif (sps_flags & (SPS_DOUBLE | SPS_BEST))\n\t\t    vim_snprintf((char *)IObuff, IOSIZE, \" (%s%d - %d)\",\n\t\t\tstp->st_salscore ? \"s \" : \"\",\n\t\t\tstp->st_score, stp->st_altscore);\n\t\telse\n\t\t    vim_snprintf((char *)IObuff, IOSIZE, \" (%d)\",\n\t\t\t    stp->st_score);\n#ifdef FEAT_RIGHTLEFT\n\t\tif (cmdmsg_rl)\n\t\t    // Mirror the numbers, but keep the leading space.\n\t\t    rl_mirror(IObuff + 1);\n#endif\n\t\tmsg_advance(30);\n\t\tmsg_puts((char *)IObuff);\n\t    }\n\t    msg_putchar('\\n');\n\t}\n\n#ifdef FEAT_RIGHTLEFT\n\tcmdmsg_rl = FALSE;\n\tmsg_col = 0;\n#endif\n\t// Ask for choice.\n\tselected = prompt_for_number(&mouse_used);\n\tif (mouse_used)\n\t    selected -= lines_left;\n\tlines_left = Rows;\t\t// avoid more prompt\n\t// don't delay for 'smd' in normal_cmd()\n\tmsg_scroll = msg_scroll_save;\n    }\n\n    if (selected > 0 && selected <= sug.su_ga.ga_len && u_save_cursor() == OK)\n    {\n\t// Save the from and to text for :spellrepall.\n\tVIM_CLEAR(repl_from);\n\tVIM_CLEAR(repl_to);\n\n\tstp = &SUG(sug.su_ga, selected - 1);\n\tif (sug.su_badlen > stp->st_orglen)\n\t{\n\t    // Replacing less than \"su_badlen\", append the remainder to\n\t    // repl_to.\n\t    repl_from = vim_strnsave(sug.su_badptr, sug.su_badlen);\n\t    vim_snprintf((char *)IObuff, IOSIZE, \"%s%.*s\", stp->st_word,\n\t\t    sug.su_badlen - stp->st_orglen,\n\t\t\t\t\t      sug.su_badptr + stp->st_orglen);\n\t    repl_to = vim_strsave(IObuff);\n\t}\n\telse\n\t{\n\t    // Replacing su_badlen or more, use the whole word.\n\t    repl_from = vim_strnsave(sug.su_badptr, stp->st_orglen);\n\t    repl_to = vim_strsave(stp->st_word);\n\t}\n\n\t// Replace the word.\n\tp = alloc(STRLEN(line) - stp->st_orglen + stp->st_wordlen + 1);\n\tif (p != NULL)\n\t{\n\t    c = (int)(sug.su_badptr - line);\n\t    mch_memmove(p, line, c);\n\t    STRCPY(p + c, stp->st_word);\n\t    STRCAT(p, sug.su_badptr + stp->st_orglen);\n\n\t    // For redo we use a change-word command.\n\t    ResetRedobuff();\n\t    AppendToRedobuff((char_u *)\"ciw\");\n\t    AppendToRedobuffLit(p + c,\n\t\t\t    stp->st_wordlen + sug.su_badlen - stp->st_orglen);\n\t    AppendCharToRedobuff(ESC);\n\n\t    // \"p\" may be freed here\n\t    ml_replace(curwin->w_cursor.lnum, p, FALSE);\n\t    curwin->w_cursor.col = c;\n\n\t    changed_bytes(curwin->w_cursor.lnum, c);\n\t}\n    }\n    else\n\tcurwin->w_cursor = prev_cursor;\n\n    spell_find_cleanup(&sug);\nskip:\n    vim_free(line);\n    curwin->w_p_spell = wo_spell_save;\n}\n\n/*\n * Find spell suggestions for \"word\".  Return them in the growarray \"*gap\" as\n * a list of allocated strings.\n */\n    void\nspell_suggest_list(\n    garray_T\t*gap,\n    char_u\t*word,\n    int\t\tmaxcount,\t// maximum nr of suggestions\n    int\t\tneed_cap,\t// 'spellcapcheck' matched\n    int\t\tinteractive)\n{\n    suginfo_T\tsug;\n    int\t\ti;\n    suggest_T\t*stp;\n    char_u\t*wcopy;\n\n    spell_find_suggest(word, 0, &sug, maxcount, FALSE, need_cap, interactive);\n\n    // Make room in \"gap\".\n    ga_init2(gap, sizeof(char_u *), sug.su_ga.ga_len + 1);\n    if (ga_grow(gap, sug.su_ga.ga_len) == OK)\n    {\n\tfor (i = 0; i < sug.su_ga.ga_len; ++i)\n\t{\n\t    stp = &SUG(sug.su_ga, i);\n\n\t    // The suggested word may replace only part of \"word\", add the not\n\t    // replaced part.\n\t    wcopy = alloc(stp->st_wordlen\n\t\t      + (unsigned)STRLEN(sug.su_badptr + stp->st_orglen) + 1);\n\t    if (wcopy == NULL)\n\t\tbreak;\n\t    STRCPY(wcopy, stp->st_word);\n\t    STRCPY(wcopy + stp->st_wordlen, sug.su_badptr + stp->st_orglen);\n\t    ((char_u **)gap->ga_data)[gap->ga_len++] = wcopy;\n\t}\n    }\n\n    spell_find_cleanup(&sug);\n}\n\n/*\n * Find spell suggestions for the word at the start of \"badptr\".\n * Return the suggestions in \"su->su_ga\".\n * The maximum number of suggestions is \"maxcount\".\n * Note: does use info for the current window.\n * This is based on the mechanisms of Aspell, but completely reimplemented.\n */\n    static void\nspell_find_suggest(\n    char_u\t*badptr,\n    int\t\tbadlen,\t\t// length of bad word or 0 if unknown\n    suginfo_T\t*su,\n    int\t\tmaxcount,\n    int\t\tbanbadword,\t// don't include badword in suggestions\n    int\t\tneed_cap,\t// word should start with capital\n    int\t\tinteractive)\n{\n    hlf_T\tattr = HLF_COUNT;\n    char_u\tbuf[MAXPATHL];\n    char_u\t*p;\n    int\t\tdo_combine = FALSE;\n    char_u\t*sps_copy;\n#ifdef FEAT_EVAL\n    static int\texpr_busy = FALSE;\n#endif\n    int\t\tc;\n    int\t\ti;\n    langp_T\t*lp;\n    int\t\tdid_intern = FALSE;\n\n    // Set the info in \"*su\".\n    CLEAR_POINTER(su);\n    ga_init2(&su->su_ga, sizeof(suggest_T), 10);\n    ga_init2(&su->su_sga, sizeof(suggest_T), 10);\n    if (*badptr == NUL)\n\treturn;\n    hash_init(&su->su_banned);\n\n    su->su_badptr = badptr;\n    if (badlen != 0)\n\tsu->su_badlen = badlen;\n    else\n\tsu->su_badlen = spell_check(curwin, su->su_badptr, &attr, NULL, FALSE);\n    su->su_maxcount = maxcount;\n    su->su_maxscore = SCORE_MAXINIT;\n\n    if (su->su_badlen >= MAXWLEN)\n\tsu->su_badlen = MAXWLEN - 1;\t// just in case\n    vim_strncpy(su->su_badword, su->su_badptr, su->su_badlen);\n    (void)spell_casefold(curwin, su->su_badptr, su->su_badlen,\n\t\t\t\t\t\t    su->su_fbadword, MAXWLEN);\n    // TODO: make this work if the case-folded text is longer than the original\n    // text. Currently an illegal byte causes wrong pointer computations.\n    su->su_fbadword[su->su_badlen] = NUL;\n\n    // get caps flags for bad word\n    su->su_badflags = badword_captype(su->su_badptr,\n\t\t\t\t\t       su->su_badptr + su->su_badlen);\n    if (need_cap)\n\tsu->su_badflags |= WF_ONECAP;\n\n    // Find the default language for sound folding.  We simply use the first\n    // one in 'spelllang' that supports sound folding.  That's good for when\n    // using multiple files for one language, it's not that bad when mixing\n    // languages (e.g., \"pl,en\").\n    for (i = 0; i < curbuf->b_s.b_langp.ga_len; ++i)\n    {\n\tlp = LANGP_ENTRY(curbuf->b_s.b_langp, i);\n\tif (lp->lp_sallang != NULL)\n\t{\n\t    su->su_sallang = lp->lp_sallang;\n\t    break;\n\t}\n    }\n\n    // Soundfold the bad word with the default sound folding, so that we don't\n    // have to do this many times.\n    if (su->su_sallang != NULL)\n\tspell_soundfold(su->su_sallang, su->su_fbadword, TRUE,\n\t\t\t\t\t\t\t  su->su_sal_badword);\n\n    // If the word is not capitalised and spell_check() doesn't consider the\n    // word to be bad then it might need to be capitalised.  Add a suggestion\n    // for that.\n    c = PTR2CHAR(su->su_badptr);\n    if (!SPELL_ISUPPER(c) && attr == HLF_COUNT)\n    {\n\tmake_case_word(su->su_badword, buf, WF_ONECAP);\n\tadd_suggestion(su, &su->su_ga, buf, su->su_badlen, SCORE_ICASE,\n\t\t\t\t\t      0, TRUE, su->su_sallang, FALSE);\n    }\n\n    // Ban the bad word itself.  It may appear in another region.\n    if (banbadword)\n\tadd_banned(su, su->su_badword);\n\n    // Make a copy of 'spellsuggest', because the expression may change it.\n    sps_copy = vim_strsave(p_sps);\n    if (sps_copy == NULL)\n\treturn;\n\n    // Loop over the items in 'spellsuggest'.\n    for (p = sps_copy; *p != NUL; )\n    {\n\tcopy_option_part(&p, buf, MAXPATHL, \",\");\n\n\tif (STRNCMP(buf, \"expr:\", 5) == 0)\n\t{\n#ifdef FEAT_EVAL\n\t    // Evaluate an expression.  Skip this when called recursively,\n\t    // when using spellsuggest() in the expression.\n\t    if (!expr_busy)\n\t    {\n\t\texpr_busy = TRUE;\n\t\tspell_suggest_expr(su, buf + 5);\n\t\texpr_busy = FALSE;\n\t    }\n#endif\n\t}\n\telse if (STRNCMP(buf, \"file:\", 5) == 0)\n\t    // Use list of suggestions in a file.\n\t    spell_suggest_file(su, buf + 5);\n\telse if (!did_intern)\n\t{\n\t    // Use internal method once.\n\t    spell_suggest_intern(su, interactive);\n\t    if (sps_flags & SPS_DOUBLE)\n\t\tdo_combine = TRUE;\n\t    did_intern = TRUE;\n\t}\n    }\n\n    vim_free(sps_copy);\n\n    if (do_combine)\n\t// Combine the two list of suggestions.  This must be done last,\n\t// because sorting changes the order again.\n\tscore_combine(su);\n}\n\n#ifdef FEAT_EVAL\n/*\n * Find suggestions by evaluating expression \"expr\".\n */\n    static void\nspell_suggest_expr(suginfo_T *su, char_u *expr)\n{\n    list_T\t*list;\n    listitem_T\t*li;\n    int\t\tscore;\n    char_u\t*p;\n\n    // The work is split up in a few parts to avoid having to export\n    // suginfo_T.\n    // First evaluate the expression and get the resulting list.\n    list = eval_spell_expr(su->su_badword, expr);\n    if (list != NULL)\n    {\n\t// Loop over the items in the list.\n\tFOR_ALL_LIST_ITEMS(list, li)\n\t    if (li->li_tv.v_type == VAR_LIST)\n\t    {\n\t\t// Get the word and the score from the items.\n\t\tscore = get_spellword(li->li_tv.vval.v_list, &p);\n\t\tif (score >= 0 && score <= su->su_maxscore)\n\t\t    add_suggestion(su, &su->su_ga, p, su->su_badlen,\n\t\t\t\t       score, 0, TRUE, su->su_sallang, FALSE);\n\t    }\n\tlist_unref(list);\n    }\n\n    // Remove bogus suggestions, sort and truncate at \"maxcount\".\n    check_suggestions(su, &su->su_ga);\n    (void)cleanup_suggestions(&su->su_ga, su->su_maxscore, su->su_maxcount);\n}\n#endif\n\n/*\n * Find suggestions in file \"fname\".  Used for \"file:\" in 'spellsuggest'.\n */\n    static void\nspell_suggest_file(suginfo_T *su, char_u *fname)\n{\n    FILE\t*fd;\n    char_u\tline[MAXWLEN * 2];\n    char_u\t*p;\n    int\t\tlen;\n    char_u\tcword[MAXWLEN];\n\n    // Open the file.\n    fd = mch_fopen((char *)fname, \"r\");\n    if (fd == NULL)\n    {\n\tsemsg(_(e_cant_open_file_str), fname);\n\treturn;\n    }\n\n    // Read it line by line.\n    while (!vim_fgets(line, MAXWLEN * 2, fd) && !got_int)\n    {\n\tline_breakcheck();\n\n\tp = vim_strchr(line, '/');\n\tif (p == NULL)\n\t    continue;\t    // No Tab found, just skip the line.\n\t*p++ = NUL;\n\tif (STRICMP(su->su_badword, line) == 0)\n\t{\n\t    // Match!  Isolate the good word, until CR or NL.\n\t    for (len = 0; p[len] >= ' '; ++len)\n\t\t;\n\t    p[len] = NUL;\n\n\t    // If the suggestion doesn't have specific case duplicate the case\n\t    // of the bad word.\n\t    if (captype(p, NULL) == 0)\n\t    {\n\t\tmake_case_word(p, cword, su->su_badflags);\n\t\tp = cword;\n\t    }\n\n\t    add_suggestion(su, &su->su_ga, p, su->su_badlen,\n\t\t\t\t  SCORE_FILE, 0, TRUE, su->su_sallang, FALSE);\n\t}\n    }\n\n    fclose(fd);\n\n    // Remove bogus suggestions, sort and truncate at \"maxcount\".\n    check_suggestions(su, &su->su_ga);\n    (void)cleanup_suggestions(&su->su_ga, su->su_maxscore, su->su_maxcount);\n}\n\n/*\n * Find suggestions for the internal method indicated by \"sps_flags\".\n */\n    static void\nspell_suggest_intern(suginfo_T *su, int interactive)\n{\n    // Load the .sug file(s) that are available and not done yet.\n    suggest_load_files();\n\n    // 1. Try special cases, such as repeating a word: \"the the\" -> \"the\".\n    //\n    // Set a maximum score to limit the combination of operations that is\n    // tried.\n    suggest_try_special(su);\n\n    // 2. Try inserting/deleting/swapping/changing a letter, use REP entries\n    //    from the .aff file and inserting a space (split the word).\n    suggest_try_change(su);\n\n    // For the resulting top-scorers compute the sound-a-like score.\n    if (sps_flags & SPS_DOUBLE)\n\tscore_comp_sal(su);\n\n    // 3. Try finding sound-a-like words.\n    if ((sps_flags & SPS_FAST) == 0)\n    {\n\tif (sps_flags & SPS_BEST)\n\t    // Adjust the word score for the suggestions found so far for how\n\t    // they sound like.\n\t    rescore_suggestions(su);\n\n\t// While going through the soundfold tree \"su_maxscore\" is the score\n\t// for the soundfold word, limits the changes that are being tried,\n\t// and \"su_sfmaxscore\" the rescored score, which is set by\n\t// cleanup_suggestions().\n\t// First find words with a small edit distance, because this is much\n\t// faster and often already finds the top-N suggestions.  If we didn't\n\t// find many suggestions try again with a higher edit distance.\n\t// \"sl_sounddone\" is used to avoid doing the same word twice.\n\tsuggest_try_soundalike_prep();\n\tsu->su_maxscore = SCORE_SFMAX1;\n\tsu->su_sfmaxscore = SCORE_MAXINIT * 3;\n\tsuggest_try_soundalike(su);\n\tif (su->su_ga.ga_len < SUG_CLEAN_COUNT(su))\n\t{\n\t    // We didn't find enough matches, try again, allowing more\n\t    // changes to the soundfold word.\n\t    su->su_maxscore = SCORE_SFMAX2;\n\t    suggest_try_soundalike(su);\n\t    if (su->su_ga.ga_len < SUG_CLEAN_COUNT(su))\n\t    {\n\t\t// Still didn't find enough matches, try again, allowing even\n\t\t// more changes to the soundfold word.\n\t\tsu->su_maxscore = SCORE_SFMAX3;\n\t\tsuggest_try_soundalike(su);\n\t    }\n\t}\n\tsu->su_maxscore = su->su_sfmaxscore;\n\tsuggest_try_soundalike_finish();\n    }\n\n    // When CTRL-C was hit while searching do show the results.  Only clear\n    // got_int when using a command, not for spellsuggest().\n    ui_breakcheck();\n    if (interactive && got_int)\n    {\n\t(void)vgetc();\n\tgot_int = FALSE;\n    }\n\n    if ((sps_flags & SPS_DOUBLE) == 0 && su->su_ga.ga_len != 0)\n    {\n\tif (sps_flags & SPS_BEST)\n\t    // Adjust the word score for how it sounds like.\n\t    rescore_suggestions(su);\n\n\t// Remove bogus suggestions, sort and truncate at \"maxcount\".\n\tcheck_suggestions(su, &su->su_ga);\n\t(void)cleanup_suggestions(&su->su_ga, su->su_maxscore, su->su_maxcount);\n    }\n}\n\n/*\n * Free the info put in \"*su\" by spell_find_suggest().\n */\n    static void\nspell_find_cleanup(suginfo_T *su)\n{\n    int\t\ti;\n\n    // Free the suggestions.\n    for (i = 0; i < su->su_ga.ga_len; ++i)\n\tvim_free(SUG(su->su_ga, i).st_word);\n    ga_clear(&su->su_ga);\n    for (i = 0; i < su->su_sga.ga_len; ++i)\n\tvim_free(SUG(su->su_sga, i).st_word);\n    ga_clear(&su->su_sga);\n\n    // Free the banned words.\n    hash_clear_all(&su->su_banned, 0);\n}\n\n/*\n * Try finding suggestions by recognizing specific situations.\n */\n    static void\nsuggest_try_special(suginfo_T *su)\n{\n    char_u\t*p;\n    size_t\tlen;\n    int\t\tc;\n    char_u\tword[MAXWLEN];\n\n    // Recognize a word that is repeated: \"the the\".\n    p = skiptowhite(su->su_fbadword);\n    len = p - su->su_fbadword;\n    p = skipwhite(p);\n    if (STRLEN(p) == len && STRNCMP(su->su_fbadword, p, len) == 0)\n    {\n\t// Include badflags: if the badword is onecap or allcap\n\t// use that for the goodword too: \"The the\" -> \"The\".\n\tc = su->su_fbadword[len];\n\tsu->su_fbadword[len] = NUL;\n\tmake_case_word(su->su_fbadword, word, su->su_badflags);\n\tsu->su_fbadword[len] = c;\n\n\t// Give a soundalike score of 0, compute the score as if deleting one\n\t// character.\n\tadd_suggestion(su, &su->su_ga, word, su->su_badlen,\n\t\t       RESCORE(SCORE_REP, 0), 0, TRUE, su->su_sallang, FALSE);\n    }\n}\n\n/*\n * Change the 0 to 1 to measure how much time is spent in each state.\n * Output is dumped in \"suggestprof\".\n */\n#if 0\n# define SUGGEST_PROFILE\nproftime_T current;\nproftime_T total;\nproftime_T times[STATE_FINAL + 1];\nlong counts[STATE_FINAL + 1];\n\n    static void\nprof_init(void)\n{\n    for (int i = 0; i <= STATE_FINAL; ++i)\n    {\n\tprofile_zero(&times[i]);\n\tcounts[i] = 0;\n    }\n    profile_start(&current);\n    profile_start(&total);\n}\n\n// call before changing state\n    static void\nprof_store(state_T state)\n{\n    profile_end(&current);\n    profile_add(&times[state], &current);\n    ++counts[state];\n    profile_start(&current);\n}\n# define PROF_STORE(state) prof_store(state);\n\n    static void\nprof_report(char *name)\n{\n    FILE *fd = fopen(\"suggestprof\", \"a\");\n\n    profile_end(&total);\n    fprintf(fd, \"-----------------------\\n\");\n    fprintf(fd, \"%s: %s\\n\", name, profile_msg(&total));\n    for (int i = 0; i <= STATE_FINAL; ++i)\n\tfprintf(fd, \"%d: %s (%ld)\\n\", i, profile_msg(&times[i]), counts[i]);\n    fclose(fd);\n}\n#else\n# define PROF_STORE(state)\n#endif\n\n/*\n * Try finding suggestions by adding/removing/swapping letters.\n */\n    static void\nsuggest_try_change(suginfo_T *su)\n{\n    char_u\tfword[MAXWLEN];\t    // copy of the bad word, case-folded\n    int\t\tn;\n    char_u\t*p;\n    int\t\tlpi;\n    langp_T\t*lp;\n\n    // We make a copy of the case-folded bad word, so that we can modify it\n    // to find matches (esp. REP items).  Append some more text, changing\n    // chars after the bad word may help.\n    STRCPY(fword, su->su_fbadword);\n    n = (int)STRLEN(fword);\n    p = su->su_badptr + su->su_badlen;\n    (void)spell_casefold(curwin, p, (int)STRLEN(p), fword + n, MAXWLEN - n);\n\n    // Make sure the resulting text is not longer than the original text.\n    n = (int)STRLEN(su->su_badptr);\n    if (n < MAXWLEN)\n\tfword[n] = NUL;\n\n    for (lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi)\n    {\n\tlp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);\n\n\t// If reloading a spell file fails it's still in the list but\n\t// everything has been cleared.\n\tif (lp->lp_slang->sl_fbyts == NULL)\n\t    continue;\n\n\t// Try it for this language.  Will add possible suggestions.\n#ifdef SUGGEST_PROFILE\n\tprof_init();\n#endif\n\tsuggest_trie_walk(su, lp, fword, FALSE);\n#ifdef SUGGEST_PROFILE\n\tprof_report(\"try_change\");\n#endif\n    }\n}\n\n// Check the maximum score, if we go over it we won't try this change.\n#define TRY_DEEPER(su, stack, depth, add) \\\n\t   (depth < MAXWLEN && stack[depth].ts_score + (add) < su->su_maxscore)\n\n/*\n * Try finding suggestions by adding/removing/swapping letters.\n *\n * This uses a state machine.  At each node in the tree we try various\n * operations.  When trying if an operation works \"depth\" is increased and the\n * stack[] is used to store info.  This allows combinations, thus insert one\n * character, replace one and delete another.  The number of changes is\n * limited by su->su_maxscore.\n *\n * After implementing this I noticed an article by Kemal Oflazer that\n * describes something similar: \"Error-tolerant Finite State Recognition with\n * Applications to Morphological Analysis and Spelling Correction\" (1996).\n * The implementation in the article is simplified and requires a stack of\n * unknown depth.  The implementation here only needs a stack depth equal to\n * the length of the word.\n *\n * This is also used for the sound-folded word, \"soundfold\" is TRUE then.\n * The mechanism is the same, but we find a match with a sound-folded word\n * that comes from one or more original words.  Each of these words may be\n * added, this is done by add_sound_suggest().\n * Don't use:\n *\tthe prefix tree or the keep-case tree\n *\t\"su->su_badlen\"\n *\tanything to do with upper and lower case\n *\tanything to do with word or non-word characters (\"spell_iswordp()\")\n *\tbanned words\n *\tword flags (rare, region, compounding)\n *\tword splitting for now\n *\t\"similar_chars()\"\n *\tuse \"slang->sl_repsal\" instead of \"lp->lp_replang->sl_rep\"\n */\n    static void\nsuggest_trie_walk(\n    suginfo_T\t*su,\n    langp_T\t*lp,\n    char_u\t*fword,\n    int\t\tsoundfold)\n{\n    char_u\ttword[MAXWLEN];\t    // good word collected so far\n    trystate_T\tstack[MAXWLEN];\n    char_u\tpreword[MAXWLEN * 3]; // word found with proper case;\n\t\t\t\t      // concatenation of prefix compound\n\t\t\t\t      // words and split word.  NUL terminated\n\t\t\t\t      // when going deeper but not when coming\n\t\t\t\t      // back.\n    char_u\tcompflags[MAXWLEN];\t// compound flags, one for each word\n    trystate_T\t*sp;\n    int\t\tnewscore;\n    int\t\tscore;\n    char_u\t*byts, *fbyts, *pbyts;\n    idx_T\t*idxs, *fidxs, *pidxs;\n    int\t\tdepth;\n    int\t\tc, c2, c3;\n    int\t\tn = 0;\n    int\t\tflags;\n    garray_T\t*gap;\n    idx_T\tarridx;\n    int\t\tlen;\n    char_u\t*p;\n    fromto_T\t*ftp;\n    int\t\tfl = 0, tl;\n    int\t\trepextra = 0;\t    // extra bytes in fword[] from REP item\n    slang_T\t*slang = lp->lp_slang;\n    int\t\tfword_ends;\n    int\t\tgoodword_ends;\n#ifdef DEBUG_TRIEWALK\n    // Stores the name of the change made at each level.\n    char_u\tchangename[MAXWLEN][80];\n#endif\n    int\t\tbreakcheckcount = 1000;\n#ifdef FEAT_RELTIME\n    proftime_T\ttime_limit;\n#endif\n    int\t\tcompound_ok;\n\n    // Go through the whole case-fold tree, try changes at each node.\n    // \"tword[]\" contains the word collected from nodes in the tree.\n    // \"fword[]\" the word we are trying to match with (initially the bad\n    // word).\n    depth = 0;\n    sp = &stack[0];\n    CLEAR_POINTER(sp);\n    sp->ts_curi = 1;\n\n    if (soundfold)\n    {\n\t// Going through the soundfold tree.\n\tbyts = fbyts = slang->sl_sbyts;\n\tidxs = fidxs = slang->sl_sidxs;\n\tpbyts = NULL;\n\tpidxs = NULL;\n\tsp->ts_prefixdepth = PFD_NOPREFIX;\n\tsp->ts_state = STATE_START;\n    }\n    else\n    {\n\t// When there are postponed prefixes we need to use these first.  At\n\t// the end of the prefix we continue in the case-fold tree.\n\tfbyts = slang->sl_fbyts;\n\tfidxs = slang->sl_fidxs;\n\tpbyts = slang->sl_pbyts;\n\tpidxs = slang->sl_pidxs;\n\tif (pbyts != NULL)\n\t{\n\t    byts = pbyts;\n\t    idxs = pidxs;\n\t    sp->ts_prefixdepth = PFD_PREFIXTREE;\n\t    sp->ts_state = STATE_NOPREFIX;\t// try without prefix first\n\t}\n\telse\n\t{\n\t    byts = fbyts;\n\t    idxs = fidxs;\n\t    sp->ts_prefixdepth = PFD_NOPREFIX;\n\t    sp->ts_state = STATE_START;\n\t}\n    }\n#ifdef FEAT_RELTIME\n    // The loop may take an indefinite amount of time. Break out after five\n    // sectonds. TODO: add an option for the time limit.\n    profile_setlimit(5000, &time_limit);\n#endif\n\n    // Loop to find all suggestions.  At each round we either:\n    // - For the current state try one operation, advance \"ts_curi\",\n    //   increase \"depth\".\n    // - When a state is done go to the next, set \"ts_state\".\n    // - When all states are tried decrease \"depth\".\n    while (depth >= 0 && !got_int)\n    {\n\tsp = &stack[depth];\n\tswitch (sp->ts_state)\n\t{\n\tcase STATE_START:\n\tcase STATE_NOPREFIX:\n\t    // Start of node: Deal with NUL bytes, which means\n\t    // tword[] may end here.\n\t    arridx = sp->ts_arridx;\t    // current node in the tree\n\t    len = byts[arridx];\t\t    // bytes in this node\n\t    arridx += sp->ts_curi;\t    // index of current byte\n\n\t    if (sp->ts_prefixdepth == PFD_PREFIXTREE)\n\t    {\n\t\t// Skip over the NUL bytes, we use them later.\n\t\tfor (n = 0; n < len && byts[arridx + n] == 0; ++n)\n\t\t    ;\n\t\tsp->ts_curi += n;\n\n\t\t// Always past NUL bytes now.\n\t\tn = (int)sp->ts_state;\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_ENDNUL;\n\t\tsp->ts_save_badflags = su->su_badflags;\n\n\t\t// At end of a prefix or at start of prefixtree: check for\n\t\t// following word.\n\t\tif (depth < MAXWLEN\n\t\t\t    && (byts[arridx] == 0 || n == (int)STATE_NOPREFIX))\n\t\t{\n\t\t    // Set su->su_badflags to the caps type at this position.\n\t\t    // Use the caps type until here for the prefix itself.\n\t\t    if (has_mbyte)\n\t\t\tn = nofold_len(fword, sp->ts_fidx, su->su_badptr);\n\t\t    else\n\t\t\tn = sp->ts_fidx;\n\t\t    flags = badword_captype(su->su_badptr, su->su_badptr + n);\n\t\t    su->su_badflags = badword_captype(su->su_badptr + n,\n\t\t\t\t\t       su->su_badptr + su->su_badlen);\n#ifdef DEBUG_TRIEWALK\n\t\t    sprintf(changename[depth], \"prefix\");\n#endif\n\t\t    go_deeper(stack, depth, 0);\n\t\t    ++depth;\n\t\t    sp = &stack[depth];\n\t\t    sp->ts_prefixdepth = depth - 1;\n\t\t    byts = fbyts;\n\t\t    idxs = fidxs;\n\t\t    sp->ts_arridx = 0;\n\n\t\t    // Move the prefix to preword[] with the right case\n\t\t    // and make find_keepcap_word() works.\n\t\t    tword[sp->ts_twordlen] = NUL;\n\t\t    make_case_word(tword + sp->ts_splitoff,\n\t\t\t\t\t  preword + sp->ts_prewordlen, flags);\n\t\t    sp->ts_prewordlen = (char_u)STRLEN(preword);\n\t\t    sp->ts_splitoff = sp->ts_twordlen;\n\t\t}\n\t\tbreak;\n\t    }\n\n\t    if (sp->ts_curi > len || byts[arridx] != 0)\n\t    {\n\t\t// Past bytes in node and/or past NUL bytes.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_ENDNUL;\n\t\tsp->ts_save_badflags = su->su_badflags;\n\t\tbreak;\n\t    }\n\n\t    // End of word in tree.\n\t    ++sp->ts_curi;\t\t// eat one NUL byte\n\n\t    flags = (int)idxs[arridx];\n\n\t    // Skip words with the NOSUGGEST flag.\n\t    if (flags & WF_NOSUGGEST)\n\t\tbreak;\n\n\t    fword_ends = (fword[sp->ts_fidx] == NUL\n\t\t\t   || (soundfold\n\t\t\t       ? VIM_ISWHITE(fword[sp->ts_fidx])\n\t\t\t       : !spell_iswordp(fword + sp->ts_fidx, curwin)));\n\t    tword[sp->ts_twordlen] = NUL;\n\n\t    if (sp->ts_prefixdepth <= PFD_NOTSPECIAL\n\t\t\t\t\t&& (sp->ts_flags & TSF_PREFIXOK) == 0\n\t\t\t\t\t&& pbyts != NULL)\n\t    {\n\t\t// There was a prefix before the word.  Check that the prefix\n\t\t// can be used with this word.\n\t\t// Count the length of the NULs in the prefix.  If there are\n\t\t// none this must be the first try without a prefix.\n\t\tn = stack[sp->ts_prefixdepth].ts_arridx;\n\t\tlen = pbyts[n++];\n\t\tfor (c = 0; c < len && pbyts[n + c] == 0; ++c)\n\t\t    ;\n\t\tif (c > 0)\n\t\t{\n\t\t    c = valid_word_prefix(c, n, flags,\n\t\t\t\t       tword + sp->ts_splitoff, slang, FALSE);\n\t\t    if (c == 0)\n\t\t\tbreak;\n\n\t\t    // Use the WF_RARE flag for a rare prefix.\n\t\t    if (c & WF_RAREPFX)\n\t\t\tflags |= WF_RARE;\n\n\t\t    // Tricky: when checking for both prefix and compounding\n\t\t    // we run into the prefix flag first.\n\t\t    // Remember that it's OK, so that we accept the prefix\n\t\t    // when arriving at a compound flag.\n\t\t    sp->ts_flags |= TSF_PREFIXOK;\n\t\t}\n\t    }\n\n\t    // Check NEEDCOMPOUND: can't use word without compounding.  Do try\n\t    // appending another compound word below.\n\t    if (sp->ts_complen == sp->ts_compsplit && fword_ends\n\t\t\t\t\t\t     && (flags & WF_NEEDCOMP))\n\t\tgoodword_ends = FALSE;\n\t    else\n\t\tgoodword_ends = TRUE;\n\n\t    p = NULL;\n\t    compound_ok = TRUE;\n\t    if (sp->ts_complen > sp->ts_compsplit)\n\t    {\n\t\tif (slang->sl_nobreak)\n\t\t{\n\t\t    // There was a word before this word.  When there was no\n\t\t    // change in this word (it was correct) add the first word\n\t\t    // as a suggestion.  If this word was corrected too, we\n\t\t    // need to check if a correct word follows.\n\t\t    if (sp->ts_fidx - sp->ts_splitfidx\n\t\t\t\t\t  == sp->ts_twordlen - sp->ts_splitoff\n\t\t\t    && STRNCMP(fword + sp->ts_splitfidx,\n\t\t\t\t\ttword + sp->ts_splitoff,\n\t\t\t\t\t sp->ts_fidx - sp->ts_splitfidx) == 0)\n\t\t    {\n\t\t\tpreword[sp->ts_prewordlen] = NUL;\n\t\t\tnewscore = score_wordcount_adj(slang, sp->ts_score,\n\t\t\t\t\t\t preword + sp->ts_prewordlen,\n\t\t\t\t\t\t sp->ts_prewordlen > 0);\n\t\t\t// Add the suggestion if the score isn't too bad.\n\t\t\tif (newscore <= su->su_maxscore)\n\t\t\t    add_suggestion(su, &su->su_ga, preword,\n\t\t\t\t    sp->ts_splitfidx - repextra,\n\t\t\t\t    newscore, 0, FALSE,\n\t\t\t\t    lp->lp_sallang, FALSE);\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    // There was a compound word before this word.  If this\n\t\t    // word does not support compounding then give up\n\t\t    // (splitting is tried for the word without compound\n\t\t    // flag).\n\t\t    if (((unsigned)flags >> 24) == 0\n\t\t\t    || sp->ts_twordlen - sp->ts_splitoff\n\t\t\t\t\t\t       < slang->sl_compminlen)\n\t\t\tbreak;\n\t\t    // For multi-byte chars check character length against\n\t\t    // COMPOUNDMIN.\n\t\t    if (has_mbyte\n\t\t\t    && slang->sl_compminlen > 0\n\t\t\t    && mb_charlen(tword + sp->ts_splitoff)\n\t\t\t\t\t\t       < slang->sl_compminlen)\n\t\t\tbreak;\n\n\t\t    compflags[sp->ts_complen] = ((unsigned)flags >> 24);\n\t\t    compflags[sp->ts_complen + 1] = NUL;\n\t\t    vim_strncpy(preword + sp->ts_prewordlen,\n\t\t\t    tword + sp->ts_splitoff,\n\t\t\t    sp->ts_twordlen - sp->ts_splitoff);\n\n\t\t    // Verify CHECKCOMPOUNDPATTERN  rules.\n\t\t    if (match_checkcompoundpattern(preword,  sp->ts_prewordlen,\n\t\t\t\t\t\t\t  &slang->sl_comppat))\n\t\t\tcompound_ok = FALSE;\n\n\t\t    if (compound_ok)\n\t\t    {\n\t\t\tp = preword;\n\t\t\twhile (*skiptowhite(p) != NUL)\n\t\t\t    p = skipwhite(skiptowhite(p));\n\t\t\tif (fword_ends && !can_compound(slang, p,\n\t\t\t\t\t\tcompflags + sp->ts_compsplit))\n\t\t\t    // Compound is not allowed.  But it may still be\n\t\t\t    // possible if we add another (short) word.\n\t\t\t    compound_ok = FALSE;\n\t\t    }\n\n\t\t    // Get pointer to last char of previous word.\n\t\t    p = preword + sp->ts_prewordlen;\n\t\t    MB_PTR_BACK(preword, p);\n\t\t}\n\t    }\n\n\t    // Form the word with proper case in preword.\n\t    // If there is a word from a previous split, append.\n\t    // For the soundfold tree don't change the case, simply append.\n\t    if (soundfold)\n\t\tSTRCPY(preword + sp->ts_prewordlen, tword + sp->ts_splitoff);\n\t    else if (flags & WF_KEEPCAP)\n\t\t// Must find the word in the keep-case tree.\n\t\tfind_keepcap_word(slang, tword + sp->ts_splitoff,\n\t\t\t\t\t\t preword + sp->ts_prewordlen);\n\t    else\n\t    {\n\t\t// Include badflags: If the badword is onecap or allcap\n\t\t// use that for the goodword too.  But if the badword is\n\t\t// allcap and it's only one char long use onecap.\n\t\tc = su->su_badflags;\n\t\tif ((c & WF_ALLCAP)\n\t\t\t&& su->su_badlen == (*mb_ptr2len)(su->su_badptr))\n\t\t    c = WF_ONECAP;\n\t\tc |= flags;\n\n\t\t// When appending a compound word after a word character don't\n\t\t// use Onecap.\n\t\tif (p != NULL && spell_iswordp_nmw(p, curwin))\n\t\t    c &= ~WF_ONECAP;\n\t\tmake_case_word(tword + sp->ts_splitoff,\n\t\t\t\t\t      preword + sp->ts_prewordlen, c);\n\t    }\n\n\t    if (!soundfold)\n\t    {\n\t\t// Don't use a banned word.  It may appear again as a good\n\t\t// word, thus remember it.\n\t\tif (flags & WF_BANNED)\n\t\t{\n\t\t    add_banned(su, preword + sp->ts_prewordlen);\n\t\t    break;\n\t\t}\n\t\tif ((sp->ts_complen == sp->ts_compsplit\n\t\t\t    && WAS_BANNED(su, preword + sp->ts_prewordlen))\n\t\t\t\t\t\t   || WAS_BANNED(su, preword))\n\t\t{\n\t\t    if (slang->sl_compprog == NULL)\n\t\t\tbreak;\n\t\t    // the word so far was banned but we may try compounding\n\t\t    goodword_ends = FALSE;\n\t\t}\n\t    }\n\n\t    newscore = 0;\n\t    if (!soundfold)\t// soundfold words don't have flags\n\t    {\n\t\tif ((flags & WF_REGION)\n\t\t\t    && (((unsigned)flags >> 16) & lp->lp_region) == 0)\n\t\t    newscore += SCORE_REGION;\n\t\tif (flags & WF_RARE)\n\t\t    newscore += SCORE_RARE;\n\n\t\tif (!spell_valid_case(su->su_badflags,\n\t\t\t\t  captype(preword + sp->ts_prewordlen, NULL)))\n\t\t    newscore += SCORE_ICASE;\n\t    }\n\n\t    // TODO: how about splitting in the soundfold tree?\n\t    if (fword_ends\n\t\t    && goodword_ends\n\t\t    && sp->ts_fidx >= sp->ts_fidxtry\n\t\t    && compound_ok)\n\t    {\n\t\t// The badword also ends: add suggestions.\n#ifdef DEBUG_TRIEWALK\n\t\tif (soundfold && STRCMP(preword, \"smwrd\") == 0)\n\t\t{\n\t\t    int\t    j;\n\n\t\t    // print the stack of changes that brought us here\n\t\t    smsg(\"------ %s -------\", fword);\n\t\t    for (j = 0; j < depth; ++j)\n\t\t\tsmsg(\"%s\", changename[j]);\n\t\t}\n#endif\n\t\tif (soundfold)\n\t\t{\n\t\t    // For soundfolded words we need to find the original\n\t\t    // words, the edit distance and then add them.\n\t\t    add_sound_suggest(su, preword, sp->ts_score, lp);\n\t\t}\n\t\telse if (sp->ts_fidx > 0)\n\t\t{\n\t\t    // Give a penalty when changing non-word char to word\n\t\t    // char, e.g., \"thes,\" -> \"these\".\n\t\t    p = fword + sp->ts_fidx;\n\t\t    MB_PTR_BACK(fword, p);\n\t\t    if (!spell_iswordp(p, curwin) && *preword != NUL)\n\t\t    {\n\t\t\tp = preword + STRLEN(preword);\n\t\t\tMB_PTR_BACK(preword, p);\n\t\t\tif (spell_iswordp(p, curwin))\n\t\t\t    newscore += SCORE_NONWORD;\n\t\t    }\n\n\t\t    // Give a bonus to words seen before.\n\t\t    score = score_wordcount_adj(slang,\n\t\t\t\t\t\tsp->ts_score + newscore,\n\t\t\t\t\t\tpreword + sp->ts_prewordlen,\n\t\t\t\t\t\tsp->ts_prewordlen > 0);\n\n\t\t    // Add the suggestion if the score isn't too bad.\n\t\t    if (score <= su->su_maxscore)\n\t\t    {\n\t\t\tadd_suggestion(su, &su->su_ga, preword,\n\t\t\t\t    sp->ts_fidx - repextra,\n\t\t\t\t    score, 0, FALSE, lp->lp_sallang, FALSE);\n\n\t\t\tif (su->su_badflags & WF_MIXCAP)\n\t\t\t{\n\t\t\t    // We really don't know if the word should be\n\t\t\t    // upper or lower case, add both.\n\t\t\t    c = captype(preword, NULL);\n\t\t\t    if (c == 0 || c == WF_ALLCAP)\n\t\t\t    {\n\t\t\t\tmake_case_word(tword + sp->ts_splitoff,\n\t\t\t\t\t      preword + sp->ts_prewordlen,\n\t\t\t\t\t\t      c == 0 ? WF_ALLCAP : 0);\n\n\t\t\t\tadd_suggestion(su, &su->su_ga, preword,\n\t\t\t\t\tsp->ts_fidx - repextra,\n\t\t\t\t\tscore + SCORE_ICASE, 0, FALSE,\n\t\t\t\t\tlp->lp_sallang, FALSE);\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\n\t    // Try word split and/or compounding.\n\t    if ((sp->ts_fidx >= sp->ts_fidxtry || fword_ends)\n\t\t    // Don't split halfway a character.\n\t\t    && (!has_mbyte || sp->ts_tcharlen == 0))\n\t    {\n\t\tint\ttry_compound;\n\t\tint\ttry_split;\n\n\t\t// If past the end of the bad word don't try a split.\n\t\t// Otherwise try changing the next word.  E.g., find\n\t\t// suggestions for \"the the\" where the second \"the\" is\n\t\t// different.  It's done like a split.\n\t\t// TODO: word split for soundfold words\n\t\ttry_split = (sp->ts_fidx - repextra < su->su_badlen)\n\t\t\t\t\t\t\t\t&& !soundfold;\n\n\t\t// Get here in several situations:\n\t\t// 1. The word in the tree ends:\n\t\t//    If the word allows compounding try that.  Otherwise try\n\t\t//    a split by inserting a space.  For both check that a\n\t\t//    valid words starts at fword[sp->ts_fidx].\n\t\t//    For NOBREAK do like compounding to be able to check if\n\t\t//    the next word is valid.\n\t\t// 2. The badword does end, but it was due to a change (e.g.,\n\t\t//    a swap).  No need to split, but do check that the\n\t\t//    following word is valid.\n\t\t// 3. The badword and the word in the tree end.  It may still\n\t\t//    be possible to compound another (short) word.\n\t\ttry_compound = FALSE;\n\t\tif (!soundfold\n\t\t\t&& !slang->sl_nocompoundsugs\n\t\t\t&& slang->sl_compprog != NULL\n\t\t\t&& ((unsigned)flags >> 24) != 0\n\t\t\t&& sp->ts_twordlen - sp->ts_splitoff\n\t\t\t\t\t\t       >= slang->sl_compminlen\n\t\t\t&& (!has_mbyte\n\t\t\t    || slang->sl_compminlen == 0\n\t\t\t    || mb_charlen(tword + sp->ts_splitoff)\n\t\t\t\t\t\t      >= slang->sl_compminlen)\n\t\t\t&& (slang->sl_compsylmax < MAXWLEN\n\t\t\t    || sp->ts_complen + 1 - sp->ts_compsplit\n\t\t\t\t\t\t\t  < slang->sl_compmax)\n\t\t\t&& (can_be_compound(sp, slang,\n\t\t\t\t\t compflags, ((unsigned)flags >> 24))))\n\n\t\t{\n\t\t    try_compound = TRUE;\n\t\t    compflags[sp->ts_complen] = ((unsigned)flags >> 24);\n\t\t    compflags[sp->ts_complen + 1] = NUL;\n\t\t}\n\n\t\t// For NOBREAK we never try splitting, it won't make any word\n\t\t// valid.\n\t\tif (slang->sl_nobreak && !slang->sl_nocompoundsugs)\n\t\t    try_compound = TRUE;\n\n\t\t// If we could add a compound word, and it's also possible to\n\t\t// split at this point, do the split first and set\n\t\t// TSF_DIDSPLIT to avoid doing it again.\n\t\telse if (!fword_ends\n\t\t\t&& try_compound\n\t\t\t&& (sp->ts_flags & TSF_DIDSPLIT) == 0)\n\t\t{\n\t\t    try_compound = FALSE;\n\t\t    sp->ts_flags |= TSF_DIDSPLIT;\n\t\t    --sp->ts_curi;\t    // do the same NUL again\n\t\t    compflags[sp->ts_complen] = NUL;\n\t\t}\n\t\telse\n\t\t    sp->ts_flags &= ~TSF_DIDSPLIT;\n\n\t\tif (try_split || try_compound)\n\t\t{\n\t\t    if (!try_compound && (!fword_ends || !goodword_ends))\n\t\t    {\n\t\t\t// If we're going to split need to check that the\n\t\t\t// words so far are valid for compounding.  If there\n\t\t\t// is only one word it must not have the NEEDCOMPOUND\n\t\t\t// flag.\n\t\t\tif (sp->ts_complen == sp->ts_compsplit\n\t\t\t\t\t\t     && (flags & WF_NEEDCOMP))\n\t\t\t    break;\n\t\t\tp = preword;\n\t\t\twhile (*skiptowhite(p) != NUL)\n\t\t\t    p = skipwhite(skiptowhite(p));\n\t\t\tif (sp->ts_complen > sp->ts_compsplit\n\t\t\t\t&& !can_compound(slang, p,\n\t\t\t\t\t\tcompflags + sp->ts_compsplit))\n\t\t\t    break;\n\n\t\t\tif (slang->sl_nosplitsugs)\n\t\t\t    newscore += SCORE_SPLIT_NO;\n\t\t\telse\n\t\t\t    newscore += SCORE_SPLIT;\n\n\t\t\t// Give a bonus to words seen before.\n\t\t\tnewscore = score_wordcount_adj(slang, newscore,\n\t\t\t\t\t   preword + sp->ts_prewordlen, TRUE);\n\t\t    }\n\n\t\t    if (TRY_DEEPER(su, stack, depth, newscore))\n\t\t    {\n\t\t\tgo_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\t\t\tif (!try_compound && !fword_ends)\n\t\t\t    sprintf(changename[depth], \"%.*s-%s: split\",\n\t\t\t\t sp->ts_twordlen, tword, fword + sp->ts_fidx);\n\t\t\telse\n\t\t\t    sprintf(changename[depth], \"%.*s-%s: compound\",\n\t\t\t\t sp->ts_twordlen, tword, fword + sp->ts_fidx);\n#endif\n\t\t\t// Save things to be restored at STATE_SPLITUNDO.\n\t\t\tsp->ts_save_badflags = su->su_badflags;\n\t\t\tPROF_STORE(sp->ts_state)\n\t\t\tsp->ts_state = STATE_SPLITUNDO;\n\n\t\t\t++depth;\n\t\t\tsp = &stack[depth];\n\n\t\t\t// Append a space to preword when splitting.\n\t\t\tif (!try_compound && !fword_ends)\n\t\t\t    STRCAT(preword, \" \");\n\t\t\tsp->ts_prewordlen = (char_u)STRLEN(preword);\n\t\t\tsp->ts_splitoff = sp->ts_twordlen;\n\t\t\tsp->ts_splitfidx = sp->ts_fidx;\n\n\t\t\t// If the badword has a non-word character at this\n\t\t\t// position skip it.  That means replacing the\n\t\t\t// non-word character with a space.  Always skip a\n\t\t\t// character when the word ends.  But only when the\n\t\t\t// good word can end.\n\t\t\tif (((!try_compound && !spell_iswordp_nmw(fword\n\t\t\t\t\t\t\t       + sp->ts_fidx,\n\t\t\t\t\t\t\t       curwin))\n\t\t\t\t    || fword_ends)\n\t\t\t\t&& fword[sp->ts_fidx] != NUL\n\t\t\t\t&& goodword_ends)\n\t\t\t{\n\t\t\t    int\t    l;\n\n\t\t\t    l = mb_ptr2len(fword + sp->ts_fidx);\n\t\t\t    if (fword_ends)\n\t\t\t    {\n\t\t\t\t// Copy the skipped character to preword.\n\t\t\t\tmch_memmove(preword + sp->ts_prewordlen,\n\t\t\t\t\t\t      fword + sp->ts_fidx, l);\n\t\t\t\tsp->ts_prewordlen += l;\n\t\t\t\tpreword[sp->ts_prewordlen] = NUL;\n\t\t\t    }\n\t\t\t    else\n\t\t\t\tsp->ts_score -= SCORE_SPLIT - SCORE_SUBST;\n\t\t\t    sp->ts_fidx += l;\n\t\t\t}\n\n\t\t\t// When compounding include compound flag in\n\t\t\t// compflags[] (already set above).  When splitting we\n\t\t\t// may start compounding over again.\n\t\t\tif (try_compound)\n\t\t\t    ++sp->ts_complen;\n\t\t\telse\n\t\t\t    sp->ts_compsplit = sp->ts_complen;\n\t\t\tsp->ts_prefixdepth = PFD_NOPREFIX;\n\n\t\t\t// set su->su_badflags to the caps type at this\n\t\t\t// position\n\t\t\tif (has_mbyte)\n\t\t\t    n = nofold_len(fword, sp->ts_fidx, su->su_badptr);\n\t\t\telse\n\t\t\t    n = sp->ts_fidx;\n\t\t\tsu->su_badflags = badword_captype(su->su_badptr + n,\n\t\t\t\t\t       su->su_badptr + su->su_badlen);\n\n\t\t\t// Restart at top of the tree.\n\t\t\tsp->ts_arridx = 0;\n\n\t\t\t// If there are postponed prefixes, try these too.\n\t\t\tif (pbyts != NULL)\n\t\t\t{\n\t\t\t    byts = pbyts;\n\t\t\t    idxs = pidxs;\n\t\t\t    sp->ts_prefixdepth = PFD_PREFIXTREE;\n\t\t\t    PROF_STORE(sp->ts_state)\n\t\t\t    sp->ts_state = STATE_NOPREFIX;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    break;\n\n\tcase STATE_SPLITUNDO:\n\t    // Undo the changes done for word split or compound word.\n\t    su->su_badflags = sp->ts_save_badflags;\n\n\t    // Continue looking for NUL bytes.\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_START;\n\n\t    // In case we went into the prefix tree.\n\t    byts = fbyts;\n\t    idxs = fidxs;\n\t    break;\n\n\tcase STATE_ENDNUL:\n\t    // Past the NUL bytes in the node.\n\t    su->su_badflags = sp->ts_save_badflags;\n\t    if (fword[sp->ts_fidx] == NUL && sp->ts_tcharlen == 0)\n\t    {\n\t\t// The badword ends, can't use STATE_PLAIN.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_DEL;\n\t\tbreak;\n\t    }\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_PLAIN;\n\t    // FALLTHROUGH\n\n\tcase STATE_PLAIN:\n\t    // Go over all possible bytes at this node, add each to tword[]\n\t    // and use child node.  \"ts_curi\" is the index.\n\t    arridx = sp->ts_arridx;\n\t    if (sp->ts_curi > byts[arridx])\n\t    {\n\t\t// Done all bytes at this node, do next state.  When still at\n\t\t// already changed bytes skip the other tricks.\n\t\tPROF_STORE(sp->ts_state)\n\t\tif (sp->ts_fidx >= sp->ts_fidxtry)\n\t\t    sp->ts_state = STATE_DEL;\n\t\telse\n\t\t    sp->ts_state = STATE_FINAL;\n\t    }\n\t    else\n\t    {\n\t\tarridx += sp->ts_curi++;\n\t\tc = byts[arridx];\n\n\t\t// Normal byte, go one level deeper.  If it's not equal to the\n\t\t// byte in the bad word adjust the score.  But don't even try\n\t\t// when the byte was already changed.  And don't try when we\n\t\t// just deleted this byte, accepting it is always cheaper than\n\t\t// delete + substitute.\n\t\tif (c == fword[sp->ts_fidx]\n\t\t\t|| (sp->ts_tcharlen > 0 && sp->ts_isdiff != DIFF_NONE))\n\t\t    newscore = 0;\n\t\telse\n\t\t    newscore = SCORE_SUBST;\n\t\tif ((newscore == 0\n\t\t\t    || (sp->ts_fidx >= sp->ts_fidxtry\n\t\t\t\t&& ((sp->ts_flags & TSF_DIDDEL) == 0\n\t\t\t\t    || c != fword[sp->ts_delidx])))\n\t\t\t&& TRY_DEEPER(su, stack, depth, newscore))\n\t\t{\n\t\t    go_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\t\t    if (newscore > 0)\n\t\t\tsprintf(changename[depth], \"%.*s-%s: subst %c to %c\",\n\t\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\t\tfword[sp->ts_fidx], c);\n\t\t    else\n\t\t\tsprintf(changename[depth], \"%.*s-%s: accept %c\",\n\t\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\t\tfword[sp->ts_fidx]);\n#endif\n\t\t    ++depth;\n\t\t    sp = &stack[depth];\n\t\t    ++sp->ts_fidx;\n\t\t    tword[sp->ts_twordlen++] = c;\n\t\t    sp->ts_arridx = idxs[arridx];\n\t\t    if (newscore == SCORE_SUBST)\n\t\t\tsp->ts_isdiff = DIFF_YES;\n\t\t    if (has_mbyte)\n\t\t    {\n\t\t\t// Multi-byte characters are a bit complicated to\n\t\t\t// handle: They differ when any of the bytes differ\n\t\t\t// and then their length may also differ.\n\t\t\tif (sp->ts_tcharlen == 0)\n\t\t\t{\n\t\t\t    // First byte.\n\t\t\t    sp->ts_tcharidx = 0;\n\t\t\t    sp->ts_tcharlen = MB_BYTE2LEN(c);\n\t\t\t    sp->ts_fcharstart = sp->ts_fidx - 1;\n\t\t\t    sp->ts_isdiff = (newscore != 0)\n\t\t\t\t\t\t       ? DIFF_YES : DIFF_NONE;\n\t\t\t}\n\t\t\telse if (sp->ts_isdiff == DIFF_INSERT)\n\t\t\t    // When inserting trail bytes don't advance in the\n\t\t\t    // bad word.\n\t\t\t    --sp->ts_fidx;\n\t\t\tif (++sp->ts_tcharidx == sp->ts_tcharlen)\n\t\t\t{\n\t\t\t    // Last byte of character.\n\t\t\t    if (sp->ts_isdiff == DIFF_YES)\n\t\t\t    {\n\t\t\t\t// Correct ts_fidx for the byte length of the\n\t\t\t\t// character (we didn't check that before).\n\t\t\t\tsp->ts_fidx = sp->ts_fcharstart\n\t\t\t\t\t    + mb_ptr2len(\n\t\t\t\t\t\t    fword + sp->ts_fcharstart);\n\t\t\t\t// For changing a composing character adjust\n\t\t\t\t// the score from SCORE_SUBST to\n\t\t\t\t// SCORE_SUBCOMP.\n\t\t\t\tif (enc_utf8\n\t\t\t\t\t&& utf_iscomposing(\n\t\t\t\t\t    utf_ptr2char(tword\n\t\t\t\t\t\t+ sp->ts_twordlen\n\t\t\t\t\t\t\t   - sp->ts_tcharlen))\n\t\t\t\t\t&& utf_iscomposing(\n\t\t\t\t\t    utf_ptr2char(fword\n\t\t\t\t\t\t\t+ sp->ts_fcharstart)))\n\t\t\t\t    sp->ts_score -=\n\t\t\t\t\t\t  SCORE_SUBST - SCORE_SUBCOMP;\n\n\t\t\t\t// For a similar character adjust score from\n\t\t\t\t// SCORE_SUBST to SCORE_SIMILAR.\n\t\t\t\telse if (!soundfold\n\t\t\t\t\t&& slang->sl_has_map\n\t\t\t\t\t&& similar_chars(slang,\n\t\t\t\t\t    mb_ptr2char(tword\n\t\t\t\t\t\t+ sp->ts_twordlen\n\t\t\t\t\t\t\t   - sp->ts_tcharlen),\n\t\t\t\t\t    mb_ptr2char(fword\n\t\t\t\t\t\t\t+ sp->ts_fcharstart)))\n\t\t\t\t    sp->ts_score -=\n\t\t\t\t\t\t  SCORE_SUBST - SCORE_SIMILAR;\n\t\t\t    }\n\t\t\t    else if (sp->ts_isdiff == DIFF_INSERT\n\t\t\t\t\t && sp->ts_twordlen > sp->ts_tcharlen)\n\t\t\t    {\n\t\t\t\tp = tword + sp->ts_twordlen - sp->ts_tcharlen;\n\t\t\t\tc = mb_ptr2char(p);\n\t\t\t\tif (enc_utf8 && utf_iscomposing(c))\n\t\t\t\t{\n\t\t\t\t    // Inserting a composing char doesn't\n\t\t\t\t    // count that much.\n\t\t\t\t    sp->ts_score -= SCORE_INS - SCORE_INSCOMP;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t    // If the previous character was the same,\n\t\t\t\t    // thus doubling a character, give a bonus\n\t\t\t\t    // to the score.  Also for the soundfold\n\t\t\t\t    // tree (might seem illogical but does\n\t\t\t\t    // give better scores).\n\t\t\t\t    MB_PTR_BACK(tword, p);\n\t\t\t\t    if (c == mb_ptr2char(p))\n\t\t\t\t\tsp->ts_score -= SCORE_INS\n\t\t\t\t\t\t\t       - SCORE_INSDUP;\n\t\t\t\t}\n\t\t\t    }\n\n\t\t\t    // Starting a new char, reset the length.\n\t\t\t    sp->ts_tcharlen = 0;\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// If we found a similar char adjust the score.\n\t\t\t// We do this after calling go_deeper() because\n\t\t\t// it's slow.\n\t\t\tif (newscore != 0\n\t\t\t\t&& !soundfold\n\t\t\t\t&& slang->sl_has_map\n\t\t\t\t&& similar_chars(slang,\n\t\t\t\t\t\t   c, fword[sp->ts_fidx - 1]))\n\t\t\t    sp->ts_score -= SCORE_SUBST - SCORE_SIMILAR;\n\t\t    }\n\t\t}\n\t    }\n\t    break;\n\n\tcase STATE_DEL:\n\t    // When past the first byte of a multi-byte char don't try\n\t    // delete/insert/swap a character.\n\t    if (has_mbyte && sp->ts_tcharlen > 0)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t\tbreak;\n\t    }\n\t    // Try skipping one character in the bad word (delete it).\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_INS_PREP;\n\t    sp->ts_curi = 1;\n\t    if (soundfold && sp->ts_fidx == 0 && fword[sp->ts_fidx] == '*')\n\t\t// Deleting a vowel at the start of a word counts less, see\n\t\t// soundalike_score().\n\t\tnewscore = 2 * SCORE_DEL / 3;\n\t    else\n\t\tnewscore = SCORE_DEL;\n\t    if (fword[sp->ts_fidx] != NUL\n\t\t\t\t    && TRY_DEEPER(su, stack, depth, newscore))\n\t    {\n\t\tgo_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth], \"%.*s-%s: delete %c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tfword[sp->ts_fidx]);\n#endif\n\t\t++depth;\n\n\t\t// Remember what character we deleted, so that we can avoid\n\t\t// inserting it again.\n\t\tstack[depth].ts_flags |= TSF_DIDDEL;\n\t\tstack[depth].ts_delidx = sp->ts_fidx;\n\n\t\t// Advance over the character in fword[].  Give a bonus to the\n\t\t// score if the same character is following \"nn\" -> \"n\".  It's\n\t\t// a bit illogical for soundfold tree but it does give better\n\t\t// results.\n\t\tif (has_mbyte)\n\t\t{\n\t\t    c = mb_ptr2char(fword + sp->ts_fidx);\n\t\t    stack[depth].ts_fidx += mb_ptr2len(fword + sp->ts_fidx);\n\t\t    if (enc_utf8 && utf_iscomposing(c))\n\t\t\tstack[depth].ts_score -= SCORE_DEL - SCORE_DELCOMP;\n\t\t    else if (c == mb_ptr2char(fword + stack[depth].ts_fidx))\n\t\t\tstack[depth].ts_score -= SCORE_DEL - SCORE_DELDUP;\n\t\t}\n\t\telse\n\t\t{\n\t\t    ++stack[depth].ts_fidx;\n\t\t    if (fword[sp->ts_fidx] == fword[sp->ts_fidx + 1])\n\t\t\tstack[depth].ts_score -= SCORE_DEL - SCORE_DELDUP;\n\t\t}\n\t\tbreak;\n\t    }\n\t    // FALLTHROUGH\n\n\tcase STATE_INS_PREP:\n\t    if (sp->ts_flags & TSF_DIDDEL)\n\t    {\n\t\t// If we just deleted a byte then inserting won't make sense,\n\t\t// a substitute is always cheaper.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_SWAP;\n\t\tbreak;\n\t    }\n\n\t    // skip over NUL bytes\n\t    n = sp->ts_arridx;\n\t    for (;;)\n\t    {\n\t\tif (sp->ts_curi > byts[n])\n\t\t{\n\t\t    // Only NUL bytes at this node, go to next state.\n\t\t    PROF_STORE(sp->ts_state)\n\t\t    sp->ts_state = STATE_SWAP;\n\t\t    break;\n\t\t}\n\t\tif (byts[n + sp->ts_curi] != NUL)\n\t\t{\n\t\t    // Found a byte to insert.\n\t\t    PROF_STORE(sp->ts_state)\n\t\t    sp->ts_state = STATE_INS;\n\t\t    break;\n\t\t}\n\t\t++sp->ts_curi;\n\t    }\n\t    break;\n\n\t    // FALLTHROUGH\n\n\tcase STATE_INS:\n\t    // Insert one byte.  Repeat this for each possible byte at this\n\t    // node.\n\t    n = sp->ts_arridx;\n\t    if (sp->ts_curi > byts[n])\n\t    {\n\t\t// Done all bytes at this node, go to next state.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_SWAP;\n\t\tbreak;\n\t    }\n\n\t    // Do one more byte at this node, but:\n\t    // - Skip NUL bytes.\n\t    // - Skip the byte if it's equal to the byte in the word,\n\t    //   accepting that byte is always better.\n\t    n += sp->ts_curi++;\n\t    c = byts[n];\n\t    if (soundfold && sp->ts_twordlen == 0 && c == '*')\n\t\t// Inserting a vowel at the start of a word counts less,\n\t\t// see soundalike_score().\n\t\tnewscore = 2 * SCORE_INS / 3;\n\t    else\n\t\tnewscore = SCORE_INS;\n\t    if (c != fword[sp->ts_fidx]\n\t\t\t\t    && TRY_DEEPER(su, stack, depth, newscore))\n\t    {\n\t\tgo_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth], \"%.*s-%s: insert %c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tc);\n#endif\n\t\t++depth;\n\t\tsp = &stack[depth];\n\t\ttword[sp->ts_twordlen++] = c;\n\t\tsp->ts_arridx = idxs[n];\n\t\tif (has_mbyte)\n\t\t{\n\t\t    fl = MB_BYTE2LEN(c);\n\t\t    if (fl > 1)\n\t\t    {\n\t\t\t// There are following bytes for the same character.\n\t\t\t// We must find all bytes before trying\n\t\t\t// delete/insert/swap/etc.\n\t\t\tsp->ts_tcharlen = fl;\n\t\t\tsp->ts_tcharidx = 1;\n\t\t\tsp->ts_isdiff = DIFF_INSERT;\n\t\t    }\n\t\t}\n\t\telse\n\t\t    fl = 1;\n\t\tif (fl == 1)\n\t\t{\n\t\t    // If the previous character was the same, thus doubling a\n\t\t    // character, give a bonus to the score.  Also for\n\t\t    // soundfold words (illogical but does give a better\n\t\t    // score).\n\t\t    if (sp->ts_twordlen >= 2\n\t\t\t\t\t   && tword[sp->ts_twordlen - 2] == c)\n\t\t\tsp->ts_score -= SCORE_INS - SCORE_INSDUP;\n\t\t}\n\t    }\n\t    break;\n\n\tcase STATE_SWAP:\n\t    // Swap two bytes in the bad word: \"12\" -> \"21\".\n\t    // We change \"fword\" here, it's changed back afterwards at\n\t    // STATE_UNSWAP.\n\t    p = fword + sp->ts_fidx;\n\t    c = *p;\n\t    if (c == NUL)\n\t    {\n\t\t// End of word, can't swap or replace.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t\tbreak;\n\t    }\n\n\t    // Don't swap if the first character is not a word character.\n\t    // SWAP3 etc. also don't make sense then.\n\t    if (!soundfold && !spell_iswordp(p, curwin))\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t\tbreak;\n\t    }\n\n\t    if (has_mbyte)\n\t    {\n\t\tn = MB_CPTR2LEN(p);\n\t\tc = mb_ptr2char(p);\n\t\tif (p[n] == NUL)\n\t\t    c2 = NUL;\n\t\telse if (!soundfold && !spell_iswordp(p + n, curwin))\n\t\t    c2 = c; // don't swap non-word char\n\t\telse\n\t\t    c2 = mb_ptr2char(p + n);\n\t    }\n\t    else\n\t    {\n\t\tif (p[1] == NUL)\n\t\t    c2 = NUL;\n\t\telse if (!soundfold && !spell_iswordp(p + 1, curwin))\n\t\t    c2 = c; // don't swap non-word char\n\t\telse\n\t\t    c2 = p[1];\n\t    }\n\n\t    // When the second character is NUL we can't swap.\n\t    if (c2 == NUL)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t\tbreak;\n\t    }\n\n\t    // When characters are identical, swap won't do anything.\n\t    // Also get here if the second char is not a word character.\n\t    if (c == c2)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_SWAP3;\n\t\tbreak;\n\t    }\n\t    if (c2 != NUL && TRY_DEEPER(su, stack, depth, SCORE_SWAP))\n\t    {\n\t\tgo_deeper(stack, depth, SCORE_SWAP);\n#ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth], \"%.*s-%s: swap %c and %c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tc, c2);\n#endif\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_UNSWAP;\n\t\t++depth;\n\t\tif (has_mbyte)\n\t\t{\n\t\t    fl = mb_char2len(c2);\n\t\t    mch_memmove(p, p + n, fl);\n\t\t    mb_char2bytes(c, p + fl);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + n + fl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    p[0] = c2;\n\t\t    p[1] = c;\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + 2;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// If this swap doesn't work then SWAP3 won't either.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t    }\n\t    break;\n\n\tcase STATE_UNSWAP:\n\t    // Undo the STATE_SWAP swap: \"21\" -> \"12\".\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tn = mb_ptr2len(p);\n\t\tc = mb_ptr2char(p + n);\n\t\tmch_memmove(p + mb_ptr2len(p + n), p, n);\n\t\tmb_char2bytes(c, p);\n\t    }\n\t    else\n\t    {\n\t\tc = *p;\n\t\t*p = p[1];\n\t\tp[1] = c;\n\t    }\n\t    // FALLTHROUGH\n\n\tcase STATE_SWAP3:\n\t    // Swap two bytes, skipping one: \"123\" -> \"321\".  We change\n\t    // \"fword\" here, it's changed back afterwards at STATE_UNSWAP3.\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tn = MB_CPTR2LEN(p);\n\t\tc = mb_ptr2char(p);\n\t\tfl = MB_CPTR2LEN(p + n);\n\t\tc2 = mb_ptr2char(p + n);\n\t\tif (!soundfold && !spell_iswordp(p + n + fl, curwin))\n\t\t    c3 = c;\t// don't swap non-word char\n\t\telse\n\t\t    c3 = mb_ptr2char(p + n + fl);\n\t    }\n\t    else\n\t    {\n\t\tc = *p;\n\t\tc2 = p[1];\n\t\tif (!soundfold && !spell_iswordp(p + 2, curwin))\n\t\t    c3 = c;\t// don't swap non-word char\n\t\telse\n\t\t    c3 = p[2];\n\t    }\n\n\t    // When characters are identical: \"121\" then SWAP3 result is\n\t    // identical, ROT3L result is same as SWAP: \"211\", ROT3L result is\n\t    // same as SWAP on next char: \"112\".  Thus skip all swapping.\n\t    // Also skip when c3 is NUL.\n\t    // Also get here when the third character is not a word character.\n\t    // Second character may any char: \"a.b\" -> \"b.a\"\n\t    if (c == c3 || c3 == NUL)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t\tbreak;\n\t    }\n\t    if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3))\n\t    {\n\t\tgo_deeper(stack, depth, SCORE_SWAP3);\n#ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth], \"%.*s-%s: swap3 %c and %c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tc, c3);\n#endif\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_UNSWAP3;\n\t\t++depth;\n\t\tif (has_mbyte)\n\t\t{\n\t\t    tl = mb_char2len(c3);\n\t\t    mch_memmove(p, p + n + fl, tl);\n\t\t    mb_char2bytes(c2, p + tl);\n\t\t    mb_char2bytes(c, p + fl + tl);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + n + fl + tl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    p[0] = p[2];\n\t\t    p[2] = c;\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + 3;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t    }\n\t    break;\n\n\tcase STATE_UNSWAP3:\n\t    // Undo STATE_SWAP3: \"321\" -> \"123\"\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tn = mb_ptr2len(p);\n\t\tc2 = mb_ptr2char(p + n);\n\t\tfl = mb_ptr2len(p + n);\n\t\tc = mb_ptr2char(p + n + fl);\n\t\ttl = mb_ptr2len(p + n + fl);\n\t\tmch_memmove(p + fl + tl, p, n);\n\t\tmb_char2bytes(c, p);\n\t\tmb_char2bytes(c2, p + tl);\n\t\tp = p + tl;\n\t    }\n\t    else\n\t    {\n\t\tc = *p;\n\t\t*p = p[2];\n\t\tp[2] = c;\n\t\t++p;\n\t    }\n\n\t    if (!soundfold && !spell_iswordp(p, curwin))\n\t    {\n\t\t// Middle char is not a word char, skip the rotate.  First and\n\t\t// third char were already checked at swap and swap3.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t\tbreak;\n\t    }\n\n\t    // Rotate three characters left: \"123\" -> \"231\".  We change\n\t    // \"fword\" here, it's changed back afterwards at STATE_UNROT3L.\n\t    if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3))\n\t    {\n\t\tgo_deeper(stack, depth, SCORE_SWAP3);\n#ifdef DEBUG_TRIEWALK\n\t\tp = fword + sp->ts_fidx;\n\t\tsprintf(changename[depth], \"%.*s-%s: rotate left %c%c%c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tp[0], p[1], p[2]);\n#endif\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_UNROT3L;\n\t\t++depth;\n\t\tp = fword + sp->ts_fidx;\n\t\tif (has_mbyte)\n\t\t{\n\t\t    n = MB_CPTR2LEN(p);\n\t\t    c = mb_ptr2char(p);\n\t\t    fl = MB_CPTR2LEN(p + n);\n\t\t    fl += MB_CPTR2LEN(p + n + fl);\n\t\t    mch_memmove(p, p + n, fl);\n\t\t    mb_char2bytes(c, p + fl);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + n + fl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    c = *p;\n\t\t    *p = p[1];\n\t\t    p[1] = p[2];\n\t\t    p[2] = c;\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + 3;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t    }\n\t    break;\n\n\tcase STATE_UNROT3L:\n\t    // Undo ROT3L: \"231\" -> \"123\"\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tn = mb_ptr2len(p);\n\t\tn += mb_ptr2len(p + n);\n\t\tc = mb_ptr2char(p + n);\n\t\ttl = mb_ptr2len(p + n);\n\t\tmch_memmove(p + tl, p, n);\n\t\tmb_char2bytes(c, p);\n\t    }\n\t    else\n\t    {\n\t\tc = p[2];\n\t\tp[2] = p[1];\n\t\tp[1] = *p;\n\t\t*p = c;\n\t    }\n\n\t    // Rotate three bytes right: \"123\" -> \"312\".  We change \"fword\"\n\t    // here, it's changed back afterwards at STATE_UNROT3R.\n\t    if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3))\n\t    {\n\t\tgo_deeper(stack, depth, SCORE_SWAP3);\n#ifdef DEBUG_TRIEWALK\n\t\tp = fword + sp->ts_fidx;\n\t\tsprintf(changename[depth], \"%.*s-%s: rotate right %c%c%c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tp[0], p[1], p[2]);\n#endif\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_UNROT3R;\n\t\t++depth;\n\t\tp = fword + sp->ts_fidx;\n\t\tif (has_mbyte)\n\t\t{\n\t\t    n = MB_CPTR2LEN(p);\n\t\t    n += MB_CPTR2LEN(p + n);\n\t\t    c = mb_ptr2char(p + n);\n\t\t    tl = MB_CPTR2LEN(p + n);\n\t\t    mch_memmove(p + tl, p, n);\n\t\t    mb_char2bytes(c, p);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + n + tl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    c = p[2];\n\t\t    p[2] = p[1];\n\t\t    p[1] = *p;\n\t\t    *p = c;\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + 3;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t    }\n\t    break;\n\n\tcase STATE_UNROT3R:\n\t    // Undo ROT3R: \"312\" -> \"123\"\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tc = mb_ptr2char(p);\n\t\ttl = mb_ptr2len(p);\n\t\tn = mb_ptr2len(p + tl);\n\t\tn += mb_ptr2len(p + tl + n);\n\t\tmch_memmove(p, p + tl, n);\n\t\tmb_char2bytes(c, p + n);\n\t    }\n\t    else\n\t    {\n\t\tc = *p;\n\t\t*p = p[1];\n\t\tp[1] = p[2];\n\t\tp[2] = c;\n\t    }\n\t    // FALLTHROUGH\n\n\tcase STATE_REP_INI:\n\t    // Check if matching with REP items from the .aff file would work.\n\t    // Quickly skip if:\n\t    // - there are no REP items and we are not in the soundfold trie\n\t    // - the score is going to be too high anyway\n\t    // - already applied a REP item or swapped here\n\t    if ((lp->lp_replang == NULL && !soundfold)\n\t\t    || sp->ts_score + SCORE_REP >= su->su_maxscore\n\t\t    || sp->ts_fidx < sp->ts_fidxtry)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t\tbreak;\n\t    }\n\n\t    // Use the first byte to quickly find the first entry that may\n\t    // match.  If the index is -1 there is none.\n\t    if (soundfold)\n\t\tsp->ts_curi = slang->sl_repsal_first[fword[sp->ts_fidx]];\n\t    else\n\t\tsp->ts_curi = lp->lp_replang->sl_rep_first[fword[sp->ts_fidx]];\n\n\t    if (sp->ts_curi < 0)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t\tbreak;\n\t    }\n\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_REP;\n\t    // FALLTHROUGH\n\n\tcase STATE_REP:\n\t    // Try matching with REP items from the .aff file.  For each match\n\t    // replace the characters and check if the resulting word is\n\t    // valid.\n\t    p = fword + sp->ts_fidx;\n\n\t    if (soundfold)\n\t\tgap = &slang->sl_repsal;\n\t    else\n\t\tgap = &lp->lp_replang->sl_rep;\n\t    while (sp->ts_curi < gap->ga_len)\n\t    {\n\t\tftp = (fromto_T *)gap->ga_data + sp->ts_curi++;\n\t\tif (*ftp->ft_from != *p)\n\t\t{\n\t\t    // past possible matching entries\n\t\t    sp->ts_curi = gap->ga_len;\n\t\t    break;\n\t\t}\n\t\tif (STRNCMP(ftp->ft_from, p, STRLEN(ftp->ft_from)) == 0\n\t\t\t&& TRY_DEEPER(su, stack, depth, SCORE_REP))\n\t\t{\n\t\t    go_deeper(stack, depth, SCORE_REP);\n#ifdef DEBUG_TRIEWALK\n\t\t    sprintf(changename[depth], \"%.*s-%s: replace %s with %s\",\n\t\t\t    sp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\t    ftp->ft_from, ftp->ft_to);\n#endif\n\t\t    // Need to undo this afterwards.\n\t\t    PROF_STORE(sp->ts_state)\n\t\t    sp->ts_state = STATE_REP_UNDO;\n\n\t\t    // Change the \"from\" to the \"to\" string.\n\t\t    ++depth;\n\t\t    fl = (int)STRLEN(ftp->ft_from);\n\t\t    tl = (int)STRLEN(ftp->ft_to);\n\t\t    if (fl != tl)\n\t\t    {\n\t\t\tSTRMOVE(p + tl, p + fl);\n\t\t\trepextra += tl - fl;\n\t\t    }\n\t\t    mch_memmove(p, ftp->ft_to, tl);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + tl;\n\t\t    stack[depth].ts_tcharlen = 0;\n\t\t    break;\n\t\t}\n\t    }\n\n\t    if (sp->ts_curi >= gap->ga_len && sp->ts_state == STATE_REP)\n\t    {\n\t\t// No (more) matches.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t    }\n\n\t    break;\n\n\tcase STATE_REP_UNDO:\n\t    // Undo a REP replacement and continue with the next one.\n\t    if (soundfold)\n\t\tgap = &slang->sl_repsal;\n\t    else\n\t\tgap = &lp->lp_replang->sl_rep;\n\t    ftp = (fromto_T *)gap->ga_data + sp->ts_curi - 1;\n\t    fl = (int)STRLEN(ftp->ft_from);\n\t    tl = (int)STRLEN(ftp->ft_to);\n\t    p = fword + sp->ts_fidx;\n\t    if (fl != tl)\n\t    {\n\t\tSTRMOVE(p + fl, p + tl);\n\t\trepextra -= tl - fl;\n\t    }\n\t    mch_memmove(p, ftp->ft_from, fl);\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_REP;\n\t    break;\n\n\tdefault:\n\t    // Did all possible states at this level, go up one level.\n\t    --depth;\n\n\t    if (depth >= 0 && stack[depth].ts_prefixdepth == PFD_PREFIXTREE)\n\t    {\n\t\t// Continue in or go back to the prefix tree.\n\t\tbyts = pbyts;\n\t\tidxs = pidxs;\n\t    }\n\n\t    // Don't check for CTRL-C too often, it takes time.\n\t    if (--breakcheckcount == 0)\n\t    {\n\t\tui_breakcheck();\n\t\tbreakcheckcount = 1000;\n#ifdef FEAT_RELTIME\n\t\tif (profile_passed_limit(&time_limit))\n\t\t    got_int = TRUE;\n#endif\n\t    }\n\t}\n    }\n}\n\n\n/*\n * Go one level deeper in the tree.\n */\n    static void\ngo_deeper(trystate_T *stack, int depth, int score_add)\n{\n    stack[depth + 1] = stack[depth];\n    stack[depth + 1].ts_state = STATE_START;\n    stack[depth + 1].ts_score = stack[depth].ts_score + score_add;\n    stack[depth + 1].ts_curi = 1;\t// start just after length byte\n    stack[depth + 1].ts_flags = 0;\n}\n\n/*\n * \"fword\" is a good word with case folded.  Find the matching keep-case\n * words and put it in \"kword\".\n * Theoretically there could be several keep-case words that result in the\n * same case-folded word, but we only find one...\n */\n    static void\nfind_keepcap_word(slang_T *slang, char_u *fword, char_u *kword)\n{\n    char_u\tuword[MAXWLEN];\t\t// \"fword\" in upper-case\n    int\t\tdepth;\n    idx_T\ttryidx;\n\n    // The following arrays are used at each depth in the tree.\n    idx_T\tarridx[MAXWLEN];\n    int\t\tround[MAXWLEN];\n    int\t\tfwordidx[MAXWLEN];\n    int\t\tuwordidx[MAXWLEN];\n    int\t\tkwordlen[MAXWLEN];\n\n    int\t\tflen, ulen;\n    int\t\tl;\n    int\t\tlen;\n    int\t\tc;\n    idx_T\tlo, hi, m;\n    char_u\t*p;\n    char_u\t*byts = slang->sl_kbyts;    // array with bytes of the words\n    idx_T\t*idxs = slang->sl_kidxs;    // array with indexes\n\n    if (byts == NULL)\n    {\n\t// array is empty: \"cannot happen\"\n\t*kword = NUL;\n\treturn;\n    }\n\n    // Make an all-cap version of \"fword\".\n    allcap_copy(fword, uword);\n\n    // Each character needs to be tried both case-folded and upper-case.\n    // All this gets very complicated if we keep in mind that changing case\n    // may change the byte length of a multi-byte character...\n    depth = 0;\n    arridx[0] = 0;\n    round[0] = 0;\n    fwordidx[0] = 0;\n    uwordidx[0] = 0;\n    kwordlen[0] = 0;\n    while (depth >= 0)\n    {\n\tif (fword[fwordidx[depth]] == NUL)\n\t{\n\t    // We are at the end of \"fword\".  If the tree allows a word to end\n\t    // here we have found a match.\n\t    if (byts[arridx[depth] + 1] == 0)\n\t    {\n\t\tkword[kwordlen[depth]] = NUL;\n\t\treturn;\n\t    }\n\n\t    // kword is getting too long, continue one level up\n\t    --depth;\n\t}\n\telse if (++round[depth] > 2)\n\t{\n\t    // tried both fold-case and upper-case character, continue one\n\t    // level up\n\t    --depth;\n\t}\n\telse\n\t{\n\t    // round[depth] == 1: Try using the folded-case character.\n\t    // round[depth] == 2: Try using the upper-case character.\n\t    if (has_mbyte)\n\t    {\n\t\tflen = MB_CPTR2LEN(fword + fwordidx[depth]);\n\t\tulen = MB_CPTR2LEN(uword + uwordidx[depth]);\n\t    }\n\t    else\n\t\tulen = flen = 1;\n\t    if (round[depth] == 1)\n\t    {\n\t\tp = fword + fwordidx[depth];\n\t\tl = flen;\n\t    }\n\t    else\n\t    {\n\t\tp = uword + uwordidx[depth];\n\t\tl = ulen;\n\t    }\n\n\t    for (tryidx = arridx[depth]; l > 0; --l)\n\t    {\n\t\t// Perform a binary search in the list of accepted bytes.\n\t\tlen = byts[tryidx++];\n\t\tc = *p++;\n\t\tlo = tryidx;\n\t\thi = tryidx + len - 1;\n\t\twhile (lo < hi)\n\t\t{\n\t\t    m = (lo + hi) / 2;\n\t\t    if (byts[m] > c)\n\t\t\thi = m - 1;\n\t\t    else if (byts[m] < c)\n\t\t\tlo = m + 1;\n\t\t    else\n\t\t    {\n\t\t\tlo = hi = m;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\n\t\t// Stop if there is no matching byte.\n\t\tif (hi < lo || byts[lo] != c)\n\t\t    break;\n\n\t\t// Continue at the child (if there is one).\n\t\ttryidx = idxs[lo];\n\t    }\n\n\t    if (l == 0)\n\t    {\n\t\t// Found the matching char.  Copy it to \"kword\" and go a\n\t\t// level deeper.\n\t\tif (round[depth] == 1)\n\t\t{\n\t\t    STRNCPY(kword + kwordlen[depth], fword + fwordidx[depth],\n\t\t\t\t\t\t\t\t\tflen);\n\t\t    kwordlen[depth + 1] = kwordlen[depth] + flen;\n\t\t}\n\t\telse\n\t\t{\n\t\t    STRNCPY(kword + kwordlen[depth], uword + uwordidx[depth],\n\t\t\t\t\t\t\t\t\tulen);\n\t\t    kwordlen[depth + 1] = kwordlen[depth] + ulen;\n\t\t}\n\t\tfwordidx[depth + 1] = fwordidx[depth] + flen;\n\t\tuwordidx[depth + 1] = uwordidx[depth] + ulen;\n\n\t\t++depth;\n\t\tarridx[depth] = tryidx;\n\t\tround[depth] = 0;\n\t    }\n\t}\n    }\n\n    // Didn't find it: \"cannot happen\".\n    *kword = NUL;\n}\n\n/*\n * Compute the sound-a-like score for suggestions in su->su_ga and add them to\n * su->su_sga.\n */\n    static void\nscore_comp_sal(suginfo_T *su)\n{\n    langp_T\t*lp;\n    char_u\tbadsound[MAXWLEN];\n    int\t\ti;\n    suggest_T   *stp;\n    suggest_T   *sstp;\n    int\t\tscore;\n    int\t\tlpi;\n\n    if (ga_grow(&su->su_sga, su->su_ga.ga_len) == FAIL)\n\treturn;\n\n    // Use the sound-folding of the first language that supports it.\n    for (lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi)\n    {\n\tlp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);\n\tif (lp->lp_slang->sl_sal.ga_len > 0)\n\t{\n\t    // soundfold the bad word\n\t    spell_soundfold(lp->lp_slang, su->su_fbadword, TRUE, badsound);\n\n\t    for (i = 0; i < su->su_ga.ga_len; ++i)\n\t    {\n\t\tstp = &SUG(su->su_ga, i);\n\n\t\t// Case-fold the suggested word, sound-fold it and compute the\n\t\t// sound-a-like score.\n\t\tscore = stp_sal_score(stp, su, lp->lp_slang, badsound);\n\t\tif (score < SCORE_MAXMAX)\n\t\t{\n\t\t    // Add the suggestion.\n\t\t    sstp = &SUG(su->su_sga, su->su_sga.ga_len);\n\t\t    sstp->st_word = vim_strsave(stp->st_word);\n\t\t    if (sstp->st_word != NULL)\n\t\t    {\n\t\t\tsstp->st_wordlen = stp->st_wordlen;\n\t\t\tsstp->st_score = score;\n\t\t\tsstp->st_altscore = 0;\n\t\t\tsstp->st_orglen = stp->st_orglen;\n\t\t\t++su->su_sga.ga_len;\n\t\t    }\n\t\t}\n\t    }\n\t    break;\n\t}\n    }\n}\n\n/*\n * Combine the list of suggestions in su->su_ga and su->su_sga.\n * They are entwined.\n */\n    static void\nscore_combine(suginfo_T *su)\n{\n    int\t\ti;\n    int\t\tj;\n    garray_T\tga;\n    garray_T\t*gap;\n    langp_T\t*lp;\n    suggest_T\t*stp;\n    char_u\t*p;\n    char_u\tbadsound[MAXWLEN];\n    int\t\tround;\n    int\t\tlpi;\n    slang_T\t*slang = NULL;\n\n    // Add the alternate score to su_ga.\n    for (lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi)\n    {\n\tlp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);\n\tif (lp->lp_slang->sl_sal.ga_len > 0)\n\t{\n\t    // soundfold the bad word\n\t    slang = lp->lp_slang;\n\t    spell_soundfold(slang, su->su_fbadword, TRUE, badsound);\n\n\t    for (i = 0; i < su->su_ga.ga_len; ++i)\n\t    {\n\t\tstp = &SUG(su->su_ga, i);\n\t\tstp->st_altscore = stp_sal_score(stp, su, slang, badsound);\n\t\tif (stp->st_altscore == SCORE_MAXMAX)\n\t\t    stp->st_score = (stp->st_score * 3 + SCORE_BIG) / 4;\n\t\telse\n\t\t    stp->st_score = (stp->st_score * 3\n\t\t\t\t\t\t  + stp->st_altscore) / 4;\n\t\tstp->st_salscore = FALSE;\n\t    }\n\t    break;\n\t}\n    }\n\n    if (slang == NULL)\t// Using \"double\" without sound folding.\n    {\n\t(void)cleanup_suggestions(&su->su_ga, su->su_maxscore,\n\t\t\t\t\t\t\t     su->su_maxcount);\n\treturn;\n    }\n\n    // Add the alternate score to su_sga.\n    for (i = 0; i < su->su_sga.ga_len; ++i)\n    {\n\tstp = &SUG(su->su_sga, i);\n\tstp->st_altscore = spell_edit_score(slang,\n\t\t\t\t\t\tsu->su_badword, stp->st_word);\n\tif (stp->st_score == SCORE_MAXMAX)\n\t    stp->st_score = (SCORE_BIG * 7 + stp->st_altscore) / 8;\n\telse\n\t    stp->st_score = (stp->st_score * 7 + stp->st_altscore) / 8;\n\tstp->st_salscore = TRUE;\n    }\n\n    // Remove bad suggestions, sort the suggestions and truncate at \"maxcount\"\n    // for both lists.\n    check_suggestions(su, &su->su_ga);\n    (void)cleanup_suggestions(&su->su_ga, su->su_maxscore, su->su_maxcount);\n    check_suggestions(su, &su->su_sga);\n    (void)cleanup_suggestions(&su->su_sga, su->su_maxscore, su->su_maxcount);\n\n    ga_init2(&ga, sizeof(suginfo_T), 1);\n    if (ga_grow(&ga, su->su_ga.ga_len + su->su_sga.ga_len) == FAIL)\n\treturn;\n\n    stp = &SUG(ga, 0);\n    for (i = 0; i < su->su_ga.ga_len || i < su->su_sga.ga_len; ++i)\n    {\n\t// round 1: get a suggestion from su_ga\n\t// round 2: get a suggestion from su_sga\n\tfor (round = 1; round <= 2; ++round)\n\t{\n\t    gap = round == 1 ? &su->su_ga : &su->su_sga;\n\t    if (i < gap->ga_len)\n\t    {\n\t\t// Don't add a word if it's already there.\n\t\tp = SUG(*gap, i).st_word;\n\t\tfor (j = 0; j < ga.ga_len; ++j)\n\t\t    if (STRCMP(stp[j].st_word, p) == 0)\n\t\t\tbreak;\n\t\tif (j == ga.ga_len)\n\t\t    stp[ga.ga_len++] = SUG(*gap, i);\n\t\telse\n\t\t    vim_free(p);\n\t    }\n\t}\n    }\n\n    ga_clear(&su->su_ga);\n    ga_clear(&su->su_sga);\n\n    // Truncate the list to the number of suggestions that will be displayed.\n    if (ga.ga_len > su->su_maxcount)\n    {\n\tfor (i = su->su_maxcount; i < ga.ga_len; ++i)\n\t    vim_free(stp[i].st_word);\n\tga.ga_len = su->su_maxcount;\n    }\n\n    su->su_ga = ga;\n}\n\n/*\n * For the goodword in \"stp\" compute the soundalike score compared to the\n * badword.\n */\n    static int\nstp_sal_score(\n    suggest_T\t*stp,\n    suginfo_T\t*su,\n    slang_T\t*slang,\n    char_u\t*badsound)\t// sound-folded badword\n{\n    char_u\t*p;\n    char_u\t*pbad;\n    char_u\t*pgood;\n    char_u\tbadsound2[MAXWLEN];\n    char_u\tfword[MAXWLEN];\n    char_u\tgoodsound[MAXWLEN];\n    char_u\tgoodword[MAXWLEN];\n    int\t\tlendiff;\n\n    lendiff = (int)(su->su_badlen - stp->st_orglen);\n    if (lendiff >= 0)\n\tpbad = badsound;\n    else\n    {\n\t// soundfold the bad word with more characters following\n\t(void)spell_casefold(curwin,\n\t\t\t\tsu->su_badptr, stp->st_orglen, fword, MAXWLEN);\n\n\t// When joining two words the sound often changes a lot.  E.g., \"t he\"\n\t// sounds like \"t h\" while \"the\" sounds like \"@\".  Avoid that by\n\t// removing the space.  Don't do it when the good word also contains a\n\t// space.\n\tif (VIM_ISWHITE(su->su_badptr[su->su_badlen])\n\t\t\t\t\t && *skiptowhite(stp->st_word) == NUL)\n\t    for (p = fword; *(p = skiptowhite(p)) != NUL; )\n\t\tSTRMOVE(p, p + 1);\n\n\tspell_soundfold(slang, fword, TRUE, badsound2);\n\tpbad = badsound2;\n    }\n\n    if (lendiff > 0 && stp->st_wordlen + lendiff < MAXWLEN)\n    {\n\t// Add part of the bad word to the good word, so that we soundfold\n\t// what replaces the bad word.\n\tSTRCPY(goodword, stp->st_word);\n\tvim_strncpy(goodword + stp->st_wordlen,\n\t\t\t    su->su_badptr + su->su_badlen - lendiff, lendiff);\n\tpgood = goodword;\n    }\n    else\n\tpgood = stp->st_word;\n\n    // Sound-fold the word and compute the score for the difference.\n    spell_soundfold(slang, pgood, FALSE, goodsound);\n\n    return soundalike_score(goodsound, pbad);\n}\n\n// structure used to store soundfolded words that add_sound_suggest() has\n// handled already.\ntypedef struct\n{\n    short\tsft_score;\t// lowest score used\n    char_u\tsft_word[1];    // soundfolded word, actually longer\n} sftword_T;\n\nstatic sftword_T dumsft;\n#define HIKEY2SFT(p)  ((sftword_T *)(p - (dumsft.sft_word - (char_u *)&dumsft)))\n#define HI2SFT(hi)     HIKEY2SFT((hi)->hi_key)\n\n/*\n * Prepare for calling suggest_try_soundalike().\n */\n    static void\nsuggest_try_soundalike_prep(void)\n{\n    langp_T\t*lp;\n    int\t\tlpi;\n    slang_T\t*slang;\n\n    // Do this for all languages that support sound folding and for which a\n    // .sug file has been loaded.\n    for (lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi)\n    {\n\tlp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);\n\tslang = lp->lp_slang;\n\tif (slang->sl_sal.ga_len > 0 && slang->sl_sbyts != NULL)\n\t    // prepare the hashtable used by add_sound_suggest()\n\t    hash_init(&slang->sl_sounddone);\n    }\n}\n\n/*\n * Find suggestions by comparing the word in a sound-a-like form.\n * Note: This doesn't support postponed prefixes.\n */\n    static void\nsuggest_try_soundalike(suginfo_T *su)\n{\n    char_u\tsalword[MAXWLEN];\n    langp_T\t*lp;\n    int\t\tlpi;\n    slang_T\t*slang;\n\n    // Do this for all languages that support sound folding and for which a\n    // .sug file has been loaded.\n    for (lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi)\n    {\n\tlp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);\n\tslang = lp->lp_slang;\n\tif (slang->sl_sal.ga_len > 0 && slang->sl_sbyts != NULL)\n\t{\n\t    // soundfold the bad word\n\t    spell_soundfold(slang, su->su_fbadword, TRUE, salword);\n\n\t    // try all kinds of inserts/deletes/swaps/etc.\n\t    // TODO: also soundfold the next words, so that we can try joining\n\t    // and splitting\n#ifdef SUGGEST_PROFILE\n\tprof_init();\n#endif\n\t    suggest_trie_walk(su, lp, salword, TRUE);\n#ifdef SUGGEST_PROFILE\n\tprof_report(\"soundalike\");\n#endif\n\t}\n    }\n}\n\n/*\n * Finish up after calling suggest_try_soundalike().\n */\n    static void\nsuggest_try_soundalike_finish(void)\n{\n    langp_T\t*lp;\n    int\t\tlpi;\n    slang_T\t*slang;\n    int\t\ttodo;\n    hashitem_T\t*hi;\n\n    // Do this for all languages that support sound folding and for which a\n    // .sug file has been loaded.\n    for (lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi)\n    {\n\tlp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);\n\tslang = lp->lp_slang;\n\tif (slang->sl_sal.ga_len > 0 && slang->sl_sbyts != NULL)\n\t{\n\t    // Free the info about handled words.\n\t    todo = (int)slang->sl_sounddone.ht_used;\n\t    for (hi = slang->sl_sounddone.ht_array; todo > 0; ++hi)\n\t\tif (!HASHITEM_EMPTY(hi))\n\t\t{\n\t\t    vim_free(HI2SFT(hi));\n\t\t    --todo;\n\t\t}\n\n\t    // Clear the hashtable, it may also be used by another region.\n\t    hash_clear(&slang->sl_sounddone);\n\t    hash_init(&slang->sl_sounddone);\n\t}\n    }\n}\n\n/*\n * A match with a soundfolded word is found.  Add the good word(s) that\n * produce this soundfolded word.\n */\n    static void\nadd_sound_suggest(\n    suginfo_T\t*su,\n    char_u\t*goodword,\n    int\t\tscore,\t\t// soundfold score\n    langp_T\t*lp)\n{\n    slang_T\t*slang = lp->lp_slang;\t// language for sound folding\n    int\t\tsfwordnr;\n    char_u\t*nrline;\n    int\t\torgnr;\n    char_u\ttheword[MAXWLEN];\n    int\t\ti;\n    int\t\twlen;\n    char_u\t*byts;\n    idx_T\t*idxs;\n    int\t\tn;\n    int\t\twordcount;\n    int\t\twc;\n    int\t\tgoodscore;\n    hash_T\thash;\n    hashitem_T  *hi;\n    sftword_T\t*sft;\n    int\t\tbc, gc;\n    int\t\tlimit;\n\n    // It's very well possible that the same soundfold word is found several\n    // times with different scores.  Since the following is quite slow only do\n    // the words that have a better score than before.  Use a hashtable to\n    // remember the words that have been done.\n    hash = hash_hash(goodword);\n    hi = hash_lookup(&slang->sl_sounddone, goodword, hash);\n    if (HASHITEM_EMPTY(hi))\n    {\n\tsft = alloc(sizeof(sftword_T) + STRLEN(goodword));\n\tif (sft != NULL)\n\t{\n\t    sft->sft_score = score;\n\t    STRCPY(sft->sft_word, goodword);\n\t    hash_add_item(&slang->sl_sounddone, hi, sft->sft_word, hash);\n\t}\n    }\n    else\n    {\n\tsft = HI2SFT(hi);\n\tif (score >= sft->sft_score)\n\t    return;\n\tsft->sft_score = score;\n    }\n\n    // Find the word nr in the soundfold tree.\n    sfwordnr = soundfold_find(slang, goodword);\n    if (sfwordnr < 0)\n    {\n\tinternal_error(\"add_sound_suggest()\");\n\treturn;\n    }\n\n    // go over the list of good words that produce this soundfold word\n    nrline = ml_get_buf(slang->sl_sugbuf, (linenr_T)(sfwordnr + 1), FALSE);\n    orgnr = 0;\n    while (*nrline != NUL)\n    {\n\t// The wordnr was stored in a minimal nr of bytes as an offset to the\n\t// previous wordnr.\n\torgnr += bytes2offset(&nrline);\n\n\tbyts = slang->sl_fbyts;\n\tidxs = slang->sl_fidxs;\n\n\t// Lookup the word \"orgnr\" one of the two tries.\n\tn = 0;\n\twordcount = 0;\n\tfor (wlen = 0; wlen < MAXWLEN - 3; ++wlen)\n\t{\n\t    i = 1;\n\t    if (wordcount == orgnr && byts[n + 1] == NUL)\n\t\tbreak;\t// found end of word\n\n\t    if (byts[n + 1] == NUL)\n\t\t++wordcount;\n\n\t    // skip over the NUL bytes\n\t    for ( ; byts[n + i] == NUL; ++i)\n\t\tif (i > byts[n])\t// safety check\n\t\t{\n\t\t    STRCPY(theword + wlen, \"BAD\");\n\t\t    wlen += 3;\n\t\t    goto badword;\n\t\t}\n\n\t    // One of the siblings must have the word.\n\t    for ( ; i < byts[n]; ++i)\n\t    {\n\t\twc = idxs[idxs[n + i]];\t// nr of words under this byte\n\t\tif (wordcount + wc > orgnr)\n\t\t    break;\n\t\twordcount += wc;\n\t    }\n\n\t    theword[wlen] = byts[n + i];\n\t    n = idxs[n + i];\n\t}\nbadword:\n\ttheword[wlen] = NUL;\n\n\t// Go over the possible flags and regions.\n\tfor (; i <= byts[n] && byts[n + i] == NUL; ++i)\n\t{\n\t    char_u\tcword[MAXWLEN];\n\t    char_u\t*p;\n\t    int\t\tflags = (int)idxs[n + i];\n\n\t    // Skip words with the NOSUGGEST flag\n\t    if (flags & WF_NOSUGGEST)\n\t\tcontinue;\n\n\t    if (flags & WF_KEEPCAP)\n\t    {\n\t\t// Must find the word in the keep-case tree.\n\t\tfind_keepcap_word(slang, theword, cword);\n\t\tp = cword;\n\t    }\n\t    else\n\t    {\n\t\tflags |= su->su_badflags;\n\t\tif ((flags & WF_CAPMASK) != 0)\n\t\t{\n\t\t    // Need to fix case according to \"flags\".\n\t\t    make_case_word(theword, cword, flags);\n\t\t    p = cword;\n\t\t}\n\t\telse\n\t\t    p = theword;\n\t    }\n\n\t    // Add the suggestion.\n\t    if (sps_flags & SPS_DOUBLE)\n\t    {\n\t\t// Add the suggestion if the score isn't too bad.\n\t\tif (score <= su->su_maxscore)\n\t\t    add_suggestion(su, &su->su_sga, p, su->su_badlen,\n\t\t\t\t\t       score, 0, FALSE, slang, FALSE);\n\t    }\n\t    else\n\t    {\n\t\t// Add a penalty for words in another region.\n\t\tif ((flags & WF_REGION)\n\t\t\t    && (((unsigned)flags >> 16) & lp->lp_region) == 0)\n\t\t    goodscore = SCORE_REGION;\n\t\telse\n\t\t    goodscore = 0;\n\n\t\t// Add a small penalty for changing the first letter from\n\t\t// lower to upper case.  Helps for \"tath\" -> \"Kath\", which is\n\t\t// less common than \"tath\" -> \"path\".  Don't do it when the\n\t\t// letter is the same, that has already been counted.\n\t\tgc = PTR2CHAR(p);\n\t\tif (SPELL_ISUPPER(gc))\n\t\t{\n\t\t    bc = PTR2CHAR(su->su_badword);\n\t\t    if (!SPELL_ISUPPER(bc)\n\t\t\t\t      && SPELL_TOFOLD(bc) != SPELL_TOFOLD(gc))\n\t\t\tgoodscore += SCORE_ICASE / 2;\n\t\t}\n\n\t\t// Compute the score for the good word.  This only does letter\n\t\t// insert/delete/swap/replace.  REP items are not considered,\n\t\t// which may make the score a bit higher.\n\t\t// Use a limit for the score to make it work faster.  Use\n\t\t// MAXSCORE(), because RESCORE() will change the score.\n\t\t// If the limit is very high then the iterative method is\n\t\t// inefficient, using an array is quicker.\n\t\tlimit = MAXSCORE(su->su_sfmaxscore - goodscore, score);\n\t\tif (limit > SCORE_LIMITMAX)\n\t\t    goodscore += spell_edit_score(slang, su->su_badword, p);\n\t\telse\n\t\t    goodscore += spell_edit_score_limit(slang, su->su_badword,\n\t\t\t\t\t\t\t\t    p, limit);\n\n\t\t// When going over the limit don't bother to do the rest.\n\t\tif (goodscore < SCORE_MAXMAX)\n\t\t{\n\t\t    // Give a bonus to words seen before.\n\t\t    goodscore = score_wordcount_adj(slang, goodscore, p, FALSE);\n\n\t\t    // Add the suggestion if the score isn't too bad.\n\t\t    goodscore = RESCORE(goodscore, score);\n\t\t    if (goodscore <= su->su_sfmaxscore)\n\t\t\tadd_suggestion(su, &su->su_ga, p, su->su_badlen,\n\t\t\t\t\t goodscore, score, TRUE, slang, TRUE);\n\t\t}\n\t    }\n\t}\n\t// smsg(\"word %s (%d): %s (%d)\", sftword, sftnr, theword, orgnr);\n    }\n}\n\n/*\n * Find word \"word\" in fold-case tree for \"slang\" and return the word number.\n */\n    static int\nsoundfold_find(slang_T *slang, char_u *word)\n{\n    idx_T\tarridx = 0;\n    int\t\tlen;\n    int\t\twlen = 0;\n    int\t\tc;\n    char_u\t*ptr = word;\n    char_u\t*byts;\n    idx_T\t*idxs;\n    int\t\twordnr = 0;\n\n    byts = slang->sl_sbyts;\n    idxs = slang->sl_sidxs;\n\n    for (;;)\n    {\n\t// First byte is the number of possible bytes.\n\tlen = byts[arridx++];\n\n\t// If the first possible byte is a zero the word could end here.\n\t// If the word ends we found the word.  If not skip the NUL bytes.\n\tc = ptr[wlen];\n\tif (byts[arridx] == NUL)\n\t{\n\t    if (c == NUL)\n\t\tbreak;\n\n\t    // Skip over the zeros, there can be several.\n\t    while (len > 0 && byts[arridx] == NUL)\n\t    {\n\t\t++arridx;\n\t\t--len;\n\t    }\n\t    if (len == 0)\n\t\treturn -1;    // no children, word should have ended here\n\t    ++wordnr;\n\t}\n\n\t// If the word ends we didn't find it.\n\tif (c == NUL)\n\t    return -1;\n\n\t// Perform a binary search in the list of accepted bytes.\n\tif (c == TAB)\t    // <Tab> is handled like <Space>\n\t    c = ' ';\n\twhile (byts[arridx] < c)\n\t{\n\t    // The word count is in the first idxs[] entry of the child.\n\t    wordnr += idxs[idxs[arridx]];\n\t    ++arridx;\n\t    if (--len == 0)\t// end of the bytes, didn't find it\n\t\treturn -1;\n\t}\n\tif (byts[arridx] != c)\t// didn't find the byte\n\t    return -1;\n\n\t// Continue at the child (if there is one).\n\tarridx = idxs[arridx];\n\t++wlen;\n\n\t// One space in the good word may stand for several spaces in the\n\t// checked word.\n\tif (c == ' ')\n\t    while (ptr[wlen] == ' ' || ptr[wlen] == TAB)\n\t\t++wlen;\n    }\n\n    return wordnr;\n}\n\n/*\n * Return TRUE if \"c1\" and \"c2\" are similar characters according to the MAP\n * lines in the .aff file.\n */\n    static int\nsimilar_chars(slang_T *slang, int c1, int c2)\n{\n    int\t\tm1, m2;\n    char_u\tbuf[MB_MAXBYTES + 1];\n    hashitem_T  *hi;\n\n    if (c1 >= 256)\n    {\n\tbuf[mb_char2bytes(c1, buf)] = 0;\n\thi = hash_find(&slang->sl_map_hash, buf);\n\tif (HASHITEM_EMPTY(hi))\n\t    m1 = 0;\n\telse\n\t    m1 = mb_ptr2char(hi->hi_key + STRLEN(hi->hi_key) + 1);\n    }\n    else\n\tm1 = slang->sl_map_array[c1];\n    if (m1 == 0)\n\treturn FALSE;\n\n\n    if (c2 >= 256)\n    {\n\tbuf[mb_char2bytes(c2, buf)] = 0;\n\thi = hash_find(&slang->sl_map_hash, buf);\n\tif (HASHITEM_EMPTY(hi))\n\t    m2 = 0;\n\telse\n\t    m2 = mb_ptr2char(hi->hi_key + STRLEN(hi->hi_key) + 1);\n    }\n    else\n\tm2 = slang->sl_map_array[c2];\n\n    return m1 == m2;\n}\n\n/*\n * Add a suggestion to the list of suggestions.\n * For a suggestion that is already in the list the lowest score is remembered.\n */\n    static void\nadd_suggestion(\n    suginfo_T\t*su,\n    garray_T\t*gap,\t\t// either su_ga or su_sga\n    char_u\t*goodword,\n    int\t\tbadlenarg,\t// len of bad word replaced with \"goodword\"\n    int\t\tscore,\n    int\t\taltscore,\n    int\t\thad_bonus,\t// value for st_had_bonus\n    slang_T\t*slang,\t\t// language for sound folding\n    int\t\tmaxsf)\t\t// su_maxscore applies to soundfold score,\n\t\t\t\t// su_sfmaxscore to the total score.\n{\n    int\t\tgoodlen;\t// len of goodword changed\n    int\t\tbadlen;\t\t// len of bad word changed\n    suggest_T   *stp;\n    suggest_T   new_sug;\n    int\t\ti;\n    char_u\t*pgood, *pbad;\n\n    // Minimize \"badlen\" for consistency.  Avoids that changing \"the the\" to\n    // \"thee the\" is added next to changing the first \"the\" the \"thee\".\n    pgood = goodword + STRLEN(goodword);\n    pbad = su->su_badptr + badlenarg;\n    for (;;)\n    {\n\tgoodlen = (int)(pgood - goodword);\n\tbadlen = (int)(pbad - su->su_badptr);\n\tif (goodlen <= 0 || badlen <= 0)\n\t    break;\n\tMB_PTR_BACK(goodword, pgood);\n\tMB_PTR_BACK(su->su_badptr, pbad);\n\tif (has_mbyte)\n\t{\n\t    if (mb_ptr2char(pgood) != mb_ptr2char(pbad))\n\t\tbreak;\n\t}\n\telse if (*pgood != *pbad)\n\t\tbreak;\n    }\n\n    if (badlen == 0 && goodlen == 0)\n\t// goodword doesn't change anything; may happen for \"the the\" changing\n\t// the first \"the\" to itself.\n\treturn;\n\n    if (gap->ga_len == 0)\n\ti = -1;\n    else\n    {\n\t// Check if the word is already there.  Also check the length that is\n\t// being replaced \"thes,\" -> \"these\" is a different suggestion from\n\t// \"thes\" -> \"these\".\n\tstp = &SUG(*gap, 0);\n\tfor (i = gap->ga_len; --i >= 0; ++stp)\n\t    if (stp->st_wordlen == goodlen\n\t\t    && stp->st_orglen == badlen\n\t\t    && STRNCMP(stp->st_word, goodword, goodlen) == 0)\n\t    {\n\t\t// Found it.  Remember the word with the lowest score.\n\t\tif (stp->st_slang == NULL)\n\t\t    stp->st_slang = slang;\n\n\t\tnew_sug.st_score = score;\n\t\tnew_sug.st_altscore = altscore;\n\t\tnew_sug.st_had_bonus = had_bonus;\n\n\t\tif (stp->st_had_bonus != had_bonus)\n\t\t{\n\t\t    // Only one of the two had the soundalike score computed.\n\t\t    // Need to do that for the other one now, otherwise the\n\t\t    // scores can't be compared.  This happens because\n\t\t    // suggest_try_change() doesn't compute the soundalike\n\t\t    // word to keep it fast, while some special methods set\n\t\t    // the soundalike score to zero.\n\t\t    if (had_bonus)\n\t\t\trescore_one(su, stp);\n\t\t    else\n\t\t    {\n\t\t\tnew_sug.st_word = stp->st_word;\n\t\t\tnew_sug.st_wordlen = stp->st_wordlen;\n\t\t\tnew_sug.st_slang = stp->st_slang;\n\t\t\tnew_sug.st_orglen = badlen;\n\t\t\trescore_one(su, &new_sug);\n\t\t    }\n\t\t}\n\n\t\tif (stp->st_score > new_sug.st_score)\n\t\t{\n\t\t    stp->st_score = new_sug.st_score;\n\t\t    stp->st_altscore = new_sug.st_altscore;\n\t\t    stp->st_had_bonus = new_sug.st_had_bonus;\n\t\t}\n\t\tbreak;\n\t    }\n    }\n\n    if (i < 0 && ga_grow(gap, 1) == OK)\n    {\n\t// Add a suggestion.\n\tstp = &SUG(*gap, gap->ga_len);\n\tstp->st_word = vim_strnsave(goodword, goodlen);\n\tif (stp->st_word != NULL)\n\t{\n\t    stp->st_wordlen = goodlen;\n\t    stp->st_score = score;\n\t    stp->st_altscore = altscore;\n\t    stp->st_had_bonus = had_bonus;\n\t    stp->st_orglen = badlen;\n\t    stp->st_slang = slang;\n\t    ++gap->ga_len;\n\n\t    // If we have too many suggestions now, sort the list and keep\n\t    // the best suggestions.\n\t    if (gap->ga_len > SUG_MAX_COUNT(su))\n\t    {\n\t\tif (maxsf)\n\t\t    su->su_sfmaxscore = cleanup_suggestions(gap,\n\t\t\t\t      su->su_sfmaxscore, SUG_CLEAN_COUNT(su));\n\t\telse\n\t\t    su->su_maxscore = cleanup_suggestions(gap,\n\t\t\t\t\tsu->su_maxscore, SUG_CLEAN_COUNT(su));\n\t    }\n\t}\n    }\n}\n\n/*\n * Suggestions may in fact be flagged as errors.  Esp. for banned words and\n * for split words, such as \"the the\".  Remove these from the list here.\n */\n    static void\ncheck_suggestions(\n    suginfo_T\t*su,\n    garray_T\t*gap)\t\t    // either su_ga or su_sga\n{\n    suggest_T   *stp;\n    int\t\ti;\n    char_u\tlongword[MAXWLEN + 1];\n    int\t\tlen;\n    hlf_T\tattr;\n\n    if (gap->ga_len == 0)\n\treturn;\n    stp = &SUG(*gap, 0);\n    for (i = gap->ga_len - 1; i >= 0; --i)\n    {\n\t// Need to append what follows to check for \"the the\".\n\tvim_strncpy(longword, stp[i].st_word, MAXWLEN);\n\tlen = stp[i].st_wordlen;\n\tvim_strncpy(longword + len, su->su_badptr + stp[i].st_orglen,\n\t\t\t\t\t\t\t       MAXWLEN - len);\n\tattr = HLF_COUNT;\n\t(void)spell_check(curwin, longword, &attr, NULL, FALSE);\n\tif (attr != HLF_COUNT)\n\t{\n\t    // Remove this entry.\n\t    vim_free(stp[i].st_word);\n\t    --gap->ga_len;\n\t    if (i < gap->ga_len)\n\t\tmch_memmove(stp + i, stp + i + 1,\n\t\t\t\t       sizeof(suggest_T) * (gap->ga_len - i));\n\t}\n    }\n}\n\n\n/*\n * Add a word to be banned.\n */\n    static void\nadd_banned(\n    suginfo_T\t*su,\n    char_u\t*word)\n{\n    char_u\t*s;\n    hash_T\thash;\n    hashitem_T\t*hi;\n\n    hash = hash_hash(word);\n    hi = hash_lookup(&su->su_banned, word, hash);\n    if (HASHITEM_EMPTY(hi))\n    {\n\ts = vim_strsave(word);\n\tif (s != NULL)\n\t    hash_add_item(&su->su_banned, hi, s, hash);\n    }\n}\n\n/*\n * Recompute the score for all suggestions if sound-folding is possible.  This\n * is slow, thus only done for the final results.\n */\n    static void\nrescore_suggestions(suginfo_T *su)\n{\n    int\t\ti;\n\n    if (su->su_sallang != NULL)\n\tfor (i = 0; i < su->su_ga.ga_len; ++i)\n\t    rescore_one(su, &SUG(su->su_ga, i));\n}\n\n/*\n * Recompute the score for one suggestion if sound-folding is possible.\n */\n    static void\nrescore_one(suginfo_T *su, suggest_T *stp)\n{\n    slang_T\t*slang = stp->st_slang;\n    char_u\tsal_badword[MAXWLEN];\n    char_u\t*p;\n\n    // Only rescore suggestions that have no sal score yet and do have a\n    // language.\n    if (slang != NULL && slang->sl_sal.ga_len > 0 && !stp->st_had_bonus)\n    {\n\tif (slang == su->su_sallang)\n\t    p = su->su_sal_badword;\n\telse\n\t{\n\t    spell_soundfold(slang, su->su_fbadword, TRUE, sal_badword);\n\t    p = sal_badword;\n\t}\n\n\tstp->st_altscore = stp_sal_score(stp, su, slang, p);\n\tif (stp->st_altscore == SCORE_MAXMAX)\n\t    stp->st_altscore = SCORE_BIG;\n\tstp->st_score = RESCORE(stp->st_score, stp->st_altscore);\n\tstp->st_had_bonus = TRUE;\n    }\n}\n\nstatic int sug_compare(const void *s1, const void *s2);\n\n/*\n * Function given to qsort() to sort the suggestions on st_score.\n * First on \"st_score\", then \"st_altscore\" then alphabetically.\n */\n    static int\nsug_compare(const void *s1, const void *s2)\n{\n    suggest_T\t*p1 = (suggest_T *)s1;\n    suggest_T\t*p2 = (suggest_T *)s2;\n    int\t\tn = p1->st_score - p2->st_score;\n\n    if (n == 0)\n    {\n\tn = p1->st_altscore - p2->st_altscore;\n\tif (n == 0)\n\t    n = STRICMP(p1->st_word, p2->st_word);\n    }\n    return n;\n}\n\n/*\n * Cleanup the suggestions:\n * - Sort on score.\n * - Remove words that won't be displayed.\n * Returns the maximum score in the list or \"maxscore\" unmodified.\n */\n    static int\ncleanup_suggestions(\n    garray_T\t*gap,\n    int\t\tmaxscore,\n    int\t\tkeep)\t\t// nr of suggestions to keep\n{\n    if (gap->ga_len > 0)\n    {\n\t// Sort the list.\n\tqsort(gap->ga_data, (size_t)gap->ga_len, sizeof(suggest_T),\n\t\t\t\t\t\t\t\t  sug_compare);\n\n\t// Truncate the list to the number of suggestions that will be\n\t// displayed.\n\tif (gap->ga_len > keep)\n\t{\n\t    int\t\ti;\n\t    suggest_T   *stp = &SUG(*gap, 0);\n\n\t    for (i = keep; i < gap->ga_len; ++i)\n\t\tvim_free(stp[i].st_word);\n\t    gap->ga_len = keep;\n\t    if (keep >= 1)\n\t\treturn stp[keep - 1].st_score;\n\t}\n    }\n    return maxscore;\n}\n\n/*\n * Compute a score for two sound-a-like words.\n * This permits up to two inserts/deletes/swaps/etc. to keep things fast.\n * Instead of a generic loop we write out the code.  That keeps it fast by\n * avoiding checks that will not be possible.\n */\n    static int\nsoundalike_score(\n    char_u\t*goodstart,\t// sound-folded good word\n    char_u\t*badstart)\t// sound-folded bad word\n{\n    char_u\t*goodsound = goodstart;\n    char_u\t*badsound = badstart;\n    int\t\tgoodlen;\n    int\t\tbadlen;\n    int\t\tn;\n    char_u\t*pl, *ps;\n    char_u\t*pl2, *ps2;\n    int\t\tscore = 0;\n\n    // Adding/inserting \"*\" at the start (word starts with vowel) shouldn't be\n    // counted so much, vowels halfway the word aren't counted at all.\n    if ((*badsound == '*' || *goodsound == '*') && *badsound != *goodsound)\n    {\n\tif ((badsound[0] == NUL && goodsound[1] == NUL)\n\t    || (goodsound[0] == NUL && badsound[1] == NUL))\n\t    // changing word with vowel to word without a sound\n\t    return SCORE_DEL;\n\tif (badsound[0] == NUL || goodsound[0] == NUL)\n\t    // more than two changes\n\t    return SCORE_MAXMAX;\n\n\tif (badsound[1] == goodsound[1]\n\t\t|| (badsound[1] != NUL\n\t\t    && goodsound[1] != NUL\n\t\t    && badsound[2] == goodsound[2]))\n\t{\n\t    // handle like a substitute\n\t}\n\telse\n\t{\n\t    score = 2 * SCORE_DEL / 3;\n\t    if (*badsound == '*')\n\t\t++badsound;\n\t    else\n\t\t++goodsound;\n\t}\n    }\n\n    goodlen = (int)STRLEN(goodsound);\n    badlen = (int)STRLEN(badsound);\n\n    // Return quickly if the lengths are too different to be fixed by two\n    // changes.\n    n = goodlen - badlen;\n    if (n < -2 || n > 2)\n\treturn SCORE_MAXMAX;\n\n    if (n > 0)\n    {\n\tpl = goodsound;\t    // goodsound is longest\n\tps = badsound;\n    }\n    else\n    {\n\tpl = badsound;\t    // badsound is longest\n\tps = goodsound;\n    }\n\n    // Skip over the identical part.\n    while (*pl == *ps && *pl != NUL)\n    {\n\t++pl;\n\t++ps;\n    }\n\n    switch (n)\n    {\n\tcase -2:\n\tcase 2:\n\t    // Must delete two characters from \"pl\".\n\t    ++pl;\t// first delete\n\t    while (*pl == *ps)\n\t    {\n\t\t++pl;\n\t\t++ps;\n\t    }\n\t    // strings must be equal after second delete\n\t    if (STRCMP(pl + 1, ps) == 0)\n\t\treturn score + SCORE_DEL * 2;\n\n\t    // Failed to compare.\n\t    break;\n\n\tcase -1:\n\tcase 1:\n\t    // Minimal one delete from \"pl\" required.\n\n\t    // 1: delete\n\t    pl2 = pl + 1;\n\t    ps2 = ps;\n\t    while (*pl2 == *ps2)\n\t    {\n\t\tif (*pl2 == NUL)\t// reached the end\n\t\t    return score + SCORE_DEL;\n\t\t++pl2;\n\t\t++ps2;\n\t    }\n\n\t    // 2: delete then swap, then rest must be equal\n\t    if (pl2[0] == ps2[1] && pl2[1] == ps2[0]\n\t\t\t\t\t     && STRCMP(pl2 + 2, ps2 + 2) == 0)\n\t\treturn score + SCORE_DEL + SCORE_SWAP;\n\n\t    // 3: delete then substitute, then the rest must be equal\n\t    if (STRCMP(pl2 + 1, ps2 + 1) == 0)\n\t\treturn score + SCORE_DEL + SCORE_SUBST;\n\n\t    // 4: first swap then delete\n\t    if (pl[0] == ps[1] && pl[1] == ps[0])\n\t    {\n\t\tpl2 = pl + 2;\t    // swap, skip two chars\n\t\tps2 = ps + 2;\n\t\twhile (*pl2 == *ps2)\n\t\t{\n\t\t    ++pl2;\n\t\t    ++ps2;\n\t\t}\n\t\t// delete a char and then strings must be equal\n\t\tif (STRCMP(pl2 + 1, ps2) == 0)\n\t\t    return score + SCORE_SWAP + SCORE_DEL;\n\t    }\n\n\t    // 5: first substitute then delete\n\t    pl2 = pl + 1;\t    // substitute, skip one char\n\t    ps2 = ps + 1;\n\t    while (*pl2 == *ps2)\n\t    {\n\t\t++pl2;\n\t\t++ps2;\n\t    }\n\t    // delete a char and then strings must be equal\n\t    if (STRCMP(pl2 + 1, ps2) == 0)\n\t\treturn score + SCORE_SUBST + SCORE_DEL;\n\n\t    // Failed to compare.\n\t    break;\n\n\tcase 0:\n\t    // Lengths are equal, thus changes must result in same length: An\n\t    // insert is only possible in combination with a delete.\n\t    // 1: check if for identical strings\n\t    if (*pl == NUL)\n\t\treturn score;\n\n\t    // 2: swap\n\t    if (pl[0] == ps[1] && pl[1] == ps[0])\n\t    {\n\t\tpl2 = pl + 2;\t    // swap, skip two chars\n\t\tps2 = ps + 2;\n\t\twhile (*pl2 == *ps2)\n\t\t{\n\t\t    if (*pl2 == NUL)\t// reached the end\n\t\t\treturn score + SCORE_SWAP;\n\t\t    ++pl2;\n\t\t    ++ps2;\n\t\t}\n\t\t// 3: swap and swap again\n\t\tif (pl2[0] == ps2[1] && pl2[1] == ps2[0]\n\t\t\t\t\t     && STRCMP(pl2 + 2, ps2 + 2) == 0)\n\t\t    return score + SCORE_SWAP + SCORE_SWAP;\n\n\t\t// 4: swap and substitute\n\t\tif (STRCMP(pl2 + 1, ps2 + 1) == 0)\n\t\t    return score + SCORE_SWAP + SCORE_SUBST;\n\t    }\n\n\t    // 5: substitute\n\t    pl2 = pl + 1;\n\t    ps2 = ps + 1;\n\t    while (*pl2 == *ps2)\n\t    {\n\t\tif (*pl2 == NUL)\t// reached the end\n\t\t    return score + SCORE_SUBST;\n\t\t++pl2;\n\t\t++ps2;\n\t    }\n\n\t    // 6: substitute and swap\n\t    if (pl2[0] == ps2[1] && pl2[1] == ps2[0]\n\t\t\t\t\t     && STRCMP(pl2 + 2, ps2 + 2) == 0)\n\t\treturn score + SCORE_SUBST + SCORE_SWAP;\n\n\t    // 7: substitute and substitute\n\t    if (STRCMP(pl2 + 1, ps2 + 1) == 0)\n\t\treturn score + SCORE_SUBST + SCORE_SUBST;\n\n\t    // 8: insert then delete\n\t    pl2 = pl;\n\t    ps2 = ps + 1;\n\t    while (*pl2 == *ps2)\n\t    {\n\t\t++pl2;\n\t\t++ps2;\n\t    }\n\t    if (STRCMP(pl2 + 1, ps2) == 0)\n\t\treturn score + SCORE_INS + SCORE_DEL;\n\n\t    // 9: delete then insert\n\t    pl2 = pl + 1;\n\t    ps2 = ps;\n\t    while (*pl2 == *ps2)\n\t    {\n\t\t++pl2;\n\t\t++ps2;\n\t    }\n\t    if (STRCMP(pl2, ps2 + 1) == 0)\n\t\treturn score + SCORE_INS + SCORE_DEL;\n\n\t    // Failed to compare.\n\t    break;\n    }\n\n    return SCORE_MAXMAX;\n}\n\n/*\n * Compute the \"edit distance\" to turn \"badword\" into \"goodword\".  The less\n * deletes/inserts/substitutes/swaps are required the lower the score.\n *\n * The algorithm is described by Du and Chang, 1992.\n * The implementation of the algorithm comes from Aspell editdist.cpp,\n * edit_distance().  It has been converted from C++ to C and modified to\n * support multi-byte characters.\n */\n    static int\nspell_edit_score(\n    slang_T\t*slang,\n    char_u\t*badword,\n    char_u\t*goodword)\n{\n    int\t\t*cnt;\n    int\t\tbadlen, goodlen;\t// lengths including NUL\n    int\t\tj, i;\n    int\t\tt;\n    int\t\tbc, gc;\n    int\t\tpbc, pgc;\n    char_u\t*p;\n    int\t\twbadword[MAXWLEN];\n    int\t\twgoodword[MAXWLEN];\n\n    if (has_mbyte)\n    {\n\t// Get the characters from the multi-byte strings and put them in an\n\t// int array for easy access.\n\tfor (p = badword, badlen = 0; *p != NUL; )\n\t    wbadword[badlen++] = mb_cptr2char_adv(&p);\n\twbadword[badlen++] = 0;\n\tfor (p = goodword, goodlen = 0; *p != NUL; )\n\t    wgoodword[goodlen++] = mb_cptr2char_adv(&p);\n\twgoodword[goodlen++] = 0;\n    }\n    else\n    {\n\tbadlen = (int)STRLEN(badword) + 1;\n\tgoodlen = (int)STRLEN(goodword) + 1;\n    }\n\n    // We use \"cnt\" as an array: CNT(badword_idx, goodword_idx).\n#define CNT(a, b)   cnt[(a) + (b) * (badlen + 1)]\n    cnt = ALLOC_MULT(int, (badlen + 1) * (goodlen + 1));\n    if (cnt == NULL)\n\treturn 0;\t// out of memory\n\n    CNT(0, 0) = 0;\n    for (j = 1; j <= goodlen; ++j)\n\tCNT(0, j) = CNT(0, j - 1) + SCORE_INS;\n\n    for (i = 1; i <= badlen; ++i)\n    {\n\tCNT(i, 0) = CNT(i - 1, 0) + SCORE_DEL;\n\tfor (j = 1; j <= goodlen; ++j)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tbc = wbadword[i - 1];\n\t\tgc = wgoodword[j - 1];\n\t    }\n\t    else\n\t    {\n\t\tbc = badword[i - 1];\n\t\tgc = goodword[j - 1];\n\t    }\n\t    if (bc == gc)\n\t\tCNT(i, j) = CNT(i - 1, j - 1);\n\t    else\n\t    {\n\t\t// Use a better score when there is only a case difference.\n\t\tif (SPELL_TOFOLD(bc) == SPELL_TOFOLD(gc))\n\t\t    CNT(i, j) = SCORE_ICASE + CNT(i - 1, j - 1);\n\t\telse\n\t\t{\n\t\t    // For a similar character use SCORE_SIMILAR.\n\t\t    if (slang != NULL\n\t\t\t    && slang->sl_has_map\n\t\t\t    && similar_chars(slang, gc, bc))\n\t\t\tCNT(i, j) = SCORE_SIMILAR + CNT(i - 1, j - 1);\n\t\t    else\n\t\t\tCNT(i, j) = SCORE_SUBST + CNT(i - 1, j - 1);\n\t\t}\n\n\t\tif (i > 1 && j > 1)\n\t\t{\n\t\t    if (has_mbyte)\n\t\t    {\n\t\t\tpbc = wbadword[i - 2];\n\t\t\tpgc = wgoodword[j - 2];\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tpbc = badword[i - 2];\n\t\t\tpgc = goodword[j - 2];\n\t\t    }\n\t\t    if (bc == pgc && pbc == gc)\n\t\t    {\n\t\t\tt = SCORE_SWAP + CNT(i - 2, j - 2);\n\t\t\tif (t < CNT(i, j))\n\t\t\t    CNT(i, j) = t;\n\t\t    }\n\t\t}\n\t\tt = SCORE_DEL + CNT(i - 1, j);\n\t\tif (t < CNT(i, j))\n\t\t    CNT(i, j) = t;\n\t\tt = SCORE_INS + CNT(i, j - 1);\n\t\tif (t < CNT(i, j))\n\t\t    CNT(i, j) = t;\n\t    }\n\t}\n    }\n\n    i = CNT(badlen - 1, goodlen - 1);\n    vim_free(cnt);\n    return i;\n}\n\ntypedef struct\n{\n    int\t\tbadi;\n    int\t\tgoodi;\n    int\t\tscore;\n} limitscore_T;\n\n/*\n * Like spell_edit_score(), but with a limit on the score to make it faster.\n * May return SCORE_MAXMAX when the score is higher than \"limit\".\n *\n * This uses a stack for the edits still to be tried.\n * The idea comes from Aspell leditdist.cpp.  Rewritten in C and added support\n * for multi-byte characters.\n */\n    static int\nspell_edit_score_limit(\n    slang_T\t*slang,\n    char_u\t*badword,\n    char_u\t*goodword,\n    int\t\tlimit)\n{\n    limitscore_T    stack[10];\t\t// allow for over 3 * 2 edits\n    int\t\t    stackidx;\n    int\t\t    bi, gi;\n    int\t\t    bi2, gi2;\n    int\t\t    bc, gc;\n    int\t\t    score;\n    int\t\t    score_off;\n    int\t\t    minscore;\n    int\t\t    round;\n\n    // Multi-byte characters require a bit more work, use a different function\n    // to avoid testing \"has_mbyte\" quite often.\n    if (has_mbyte)\n\treturn spell_edit_score_limit_w(slang, badword, goodword, limit);\n\n    // The idea is to go from start to end over the words.  So long as\n    // characters are equal just continue, this always gives the lowest score.\n    // When there is a difference try several alternatives.  Each alternative\n    // increases \"score\" for the edit distance.  Some of the alternatives are\n    // pushed unto a stack and tried later, some are tried right away.  At the\n    // end of the word the score for one alternative is known.  The lowest\n    // possible score is stored in \"minscore\".\n    stackidx = 0;\n    bi = 0;\n    gi = 0;\n    score = 0;\n    minscore = limit + 1;\n\n    for (;;)\n    {\n\t// Skip over an equal part, score remains the same.\n\tfor (;;)\n\t{\n\t    bc = badword[bi];\n\t    gc = goodword[gi];\n\t    if (bc != gc)\t// stop at a char that's different\n\t\tbreak;\n\t    if (bc == NUL)\t// both words end\n\t    {\n\t\tif (score < minscore)\n\t\t    minscore = score;\n\t\tgoto pop;\t// do next alternative\n\t    }\n\t    ++bi;\n\t    ++gi;\n\t}\n\n\tif (gc == NUL)    // goodword ends, delete badword chars\n\t{\n\t    do\n\t    {\n\t\tif ((score += SCORE_DEL) >= minscore)\n\t\t    goto pop;\t    // do next alternative\n\t    } while (badword[++bi] != NUL);\n\t    minscore = score;\n\t}\n\telse if (bc == NUL) // badword ends, insert badword chars\n\t{\n\t    do\n\t    {\n\t\tif ((score += SCORE_INS) >= minscore)\n\t\t    goto pop;\t    // do next alternative\n\t    } while (goodword[++gi] != NUL);\n\t    minscore = score;\n\t}\n\telse\t\t\t// both words continue\n\t{\n\t    // If not close to the limit, perform a change.  Only try changes\n\t    // that may lead to a lower score than \"minscore\".\n\t    // round 0: try deleting a char from badword\n\t    // round 1: try inserting a char in badword\n\t    for (round = 0; round <= 1; ++round)\n\t    {\n\t\tscore_off = score + (round == 0 ? SCORE_DEL : SCORE_INS);\n\t\tif (score_off < minscore)\n\t\t{\n\t\t    if (score_off + SCORE_EDIT_MIN >= minscore)\n\t\t    {\n\t\t\t// Near the limit, rest of the words must match.  We\n\t\t\t// can check that right now, no need to push an item\n\t\t\t// onto the stack.\n\t\t\tbi2 = bi + 1 - round;\n\t\t\tgi2 = gi + round;\n\t\t\twhile (goodword[gi2] == badword[bi2])\n\t\t\t{\n\t\t\t    if (goodword[gi2] == NUL)\n\t\t\t    {\n\t\t\t\tminscore = score_off;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t    ++bi2;\n\t\t\t    ++gi2;\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// try deleting/inserting a character later\n\t\t\tstack[stackidx].badi = bi + 1 - round;\n\t\t\tstack[stackidx].goodi = gi + round;\n\t\t\tstack[stackidx].score = score_off;\n\t\t\t++stackidx;\n\t\t    }\n\t\t}\n\t    }\n\n\t    if (score + SCORE_SWAP < minscore)\n\t    {\n\t\t// If swapping two characters makes a match then the\n\t\t// substitution is more expensive, thus there is no need to\n\t\t// try both.\n\t\tif (gc == badword[bi + 1] && bc == goodword[gi + 1])\n\t\t{\n\t\t    // Swap two characters, that is: skip them.\n\t\t    gi += 2;\n\t\t    bi += 2;\n\t\t    score += SCORE_SWAP;\n\t\t    continue;\n\t\t}\n\t    }\n\n\t    // Substitute one character for another which is the same\n\t    // thing as deleting a character from both goodword and badword.\n\t    // Use a better score when there is only a case difference.\n\t    if (SPELL_TOFOLD(bc) == SPELL_TOFOLD(gc))\n\t\tscore += SCORE_ICASE;\n\t    else\n\t    {\n\t\t// For a similar character use SCORE_SIMILAR.\n\t\tif (slang != NULL\n\t\t\t&& slang->sl_has_map\n\t\t\t&& similar_chars(slang, gc, bc))\n\t\t    score += SCORE_SIMILAR;\n\t\telse\n\t\t    score += SCORE_SUBST;\n\t    }\n\n\t    if (score < minscore)\n\t    {\n\t\t// Do the substitution.\n\t\t++gi;\n\t\t++bi;\n\t\tcontinue;\n\t    }\n\t}\npop:\n\t// Get here to try the next alternative, pop it from the stack.\n\tif (stackidx == 0)\t\t// stack is empty, finished\n\t    break;\n\n\t// pop an item from the stack\n\t--stackidx;\n\tgi = stack[stackidx].goodi;\n\tbi = stack[stackidx].badi;\n\tscore = stack[stackidx].score;\n    }\n\n    // When the score goes over \"limit\" it may actually be much higher.\n    // Return a very large number to avoid going below the limit when giving a\n    // bonus.\n    if (minscore > limit)\n\treturn SCORE_MAXMAX;\n    return minscore;\n}\n\n/*\n * Multi-byte version of spell_edit_score_limit().\n * Keep it in sync with the above!\n */\n    static int\nspell_edit_score_limit_w(\n    slang_T\t*slang,\n    char_u\t*badword,\n    char_u\t*goodword,\n    int\t\tlimit)\n{\n    limitscore_T    stack[10];\t\t// allow for over 3 * 2 edits\n    int\t\t    stackidx;\n    int\t\t    bi, gi;\n    int\t\t    bi2, gi2;\n    int\t\t    bc, gc;\n    int\t\t    score;\n    int\t\t    score_off;\n    int\t\t    minscore;\n    int\t\t    round;\n    char_u\t    *p;\n    int\t\t    wbadword[MAXWLEN];\n    int\t\t    wgoodword[MAXWLEN];\n\n    // Get the characters from the multi-byte strings and put them in an\n    // int array for easy access.\n    bi = 0;\n    for (p = badword; *p != NUL; )\n\twbadword[bi++] = mb_cptr2char_adv(&p);\n    wbadword[bi++] = 0;\n    gi = 0;\n    for (p = goodword; *p != NUL; )\n\twgoodword[gi++] = mb_cptr2char_adv(&p);\n    wgoodword[gi++] = 0;\n\n    // The idea is to go from start to end over the words.  So long as\n    // characters are equal just continue, this always gives the lowest score.\n    // When there is a difference try several alternatives.  Each alternative\n    // increases \"score\" for the edit distance.  Some of the alternatives are\n    // pushed unto a stack and tried later, some are tried right away.  At the\n    // end of the word the score for one alternative is known.  The lowest\n    // possible score is stored in \"minscore\".\n    stackidx = 0;\n    bi = 0;\n    gi = 0;\n    score = 0;\n    minscore = limit + 1;\n\n    for (;;)\n    {\n\t// Skip over an equal part, score remains the same.\n\tfor (;;)\n\t{\n\t    bc = wbadword[bi];\n\t    gc = wgoodword[gi];\n\n\t    if (bc != gc)\t// stop at a char that's different\n\t\tbreak;\n\t    if (bc == NUL)\t// both words end\n\t    {\n\t\tif (score < minscore)\n\t\t    minscore = score;\n\t\tgoto pop;\t// do next alternative\n\t    }\n\t    ++bi;\n\t    ++gi;\n\t}\n\n\tif (gc == NUL)    // goodword ends, delete badword chars\n\t{\n\t    do\n\t    {\n\t\tif ((score += SCORE_DEL) >= minscore)\n\t\t    goto pop;\t    // do next alternative\n\t    } while (wbadword[++bi] != NUL);\n\t    minscore = score;\n\t}\n\telse if (bc == NUL) // badword ends, insert badword chars\n\t{\n\t    do\n\t    {\n\t\tif ((score += SCORE_INS) >= minscore)\n\t\t    goto pop;\t    // do next alternative\n\t    } while (wgoodword[++gi] != NUL);\n\t    minscore = score;\n\t}\n\telse\t\t\t// both words continue\n\t{\n\t    // If not close to the limit, perform a change.  Only try changes\n\t    // that may lead to a lower score than \"minscore\".\n\t    // round 0: try deleting a char from badword\n\t    // round 1: try inserting a char in badword\n\t    for (round = 0; round <= 1; ++round)\n\t    {\n\t\tscore_off = score + (round == 0 ? SCORE_DEL : SCORE_INS);\n\t\tif (score_off < minscore)\n\t\t{\n\t\t    if (score_off + SCORE_EDIT_MIN >= minscore)\n\t\t    {\n\t\t\t// Near the limit, rest of the words must match.  We\n\t\t\t// can check that right now, no need to push an item\n\t\t\t// onto the stack.\n\t\t\tbi2 = bi + 1 - round;\n\t\t\tgi2 = gi + round;\n\t\t\twhile (wgoodword[gi2] == wbadword[bi2])\n\t\t\t{\n\t\t\t    if (wgoodword[gi2] == NUL)\n\t\t\t    {\n\t\t\t\tminscore = score_off;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t    ++bi2;\n\t\t\t    ++gi2;\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// try deleting a character from badword later\n\t\t\tstack[stackidx].badi = bi + 1 - round;\n\t\t\tstack[stackidx].goodi = gi + round;\n\t\t\tstack[stackidx].score = score_off;\n\t\t\t++stackidx;\n\t\t    }\n\t\t}\n\t    }\n\n\t    if (score + SCORE_SWAP < minscore)\n\t    {\n\t\t// If swapping two characters makes a match then the\n\t\t// substitution is more expensive, thus there is no need to\n\t\t// try both.\n\t\tif (gc == wbadword[bi + 1] && bc == wgoodword[gi + 1])\n\t\t{\n\t\t    // Swap two characters, that is: skip them.\n\t\t    gi += 2;\n\t\t    bi += 2;\n\t\t    score += SCORE_SWAP;\n\t\t    continue;\n\t\t}\n\t    }\n\n\t    // Substitute one character for another which is the same\n\t    // thing as deleting a character from both goodword and badword.\n\t    // Use a better score when there is only a case difference.\n\t    if (SPELL_TOFOLD(bc) == SPELL_TOFOLD(gc))\n\t\tscore += SCORE_ICASE;\n\t    else\n\t    {\n\t\t// For a similar character use SCORE_SIMILAR.\n\t\tif (slang != NULL\n\t\t\t&& slang->sl_has_map\n\t\t\t&& similar_chars(slang, gc, bc))\n\t\t    score += SCORE_SIMILAR;\n\t\telse\n\t\t    score += SCORE_SUBST;\n\t    }\n\n\t    if (score < minscore)\n\t    {\n\t\t// Do the substitution.\n\t\t++gi;\n\t\t++bi;\n\t\tcontinue;\n\t    }\n\t}\npop:\n\t// Get here to try the next alternative, pop it from the stack.\n\tif (stackidx == 0)\t\t// stack is empty, finished\n\t    break;\n\n\t// pop an item from the stack\n\t--stackidx;\n\tgi = stack[stackidx].goodi;\n\tbi = stack[stackidx].badi;\n\tscore = stack[stackidx].score;\n    }\n\n    // When the score goes over \"limit\" it may actually be much higher.\n    // Return a very large number to avoid going below the limit when giving a\n    // bonus.\n    if (minscore > limit)\n\treturn SCORE_MAXMAX;\n    return minscore;\n}\n#endif  // FEAT_SPELL\n", "\" Test spell checking\n\" Note: this file uses latin1 encoding, but is used with utf-8 encoding.\n\nsource check.vim\nCheckFeature spell\n\nsource screendump.vim\n\nfunc TearDown()\n  set nospell\n  call delete('Xtest.aff')\n  call delete('Xtest.dic')\n  call delete('Xtest.latin1.add')\n  call delete('Xtest.latin1.add.spl')\n  call delete('Xtest.latin1.spl')\n  call delete('Xtest.latin1.sug')\nendfunc\n\nfunc Test_wrap_search()\n  new\n  call setline(1, ['The', '', 'A plong line with two zpelling mistakes', '', 'End'])\n  set spell wrapscan\n  normal ]s\n  call assert_equal('plong', expand('<cword>'))\n  normal ]s\n  call assert_equal('zpelling', expand('<cword>'))\n  normal ]s\n  call assert_equal('plong', expand('<cword>'))\n  bwipe!\n  set nospell\nendfunc\n\nfunc Test_curswant()\n  new\n  call setline(1, ['Another plong line', 'abcdefghijklmnopq'])\n  set spell wrapscan\n  normal 0]s\n  call assert_equal('plong', expand('<cword>'))\n  normal j\n  call assert_equal(9, getcurpos()[2])\n  normal 0[s\n  call assert_equal('plong', expand('<cword>'))\n  normal j\n  call assert_equal(9, getcurpos()[2])\n\n  normal 0]S\n  call assert_equal('plong', expand('<cword>'))\n  normal j\n  call assert_equal(9, getcurpos()[2])\n  normal 0[S\n  call assert_equal('plong', expand('<cword>'))\n  normal j\n  call assert_equal(9, getcurpos()[2])\n\n  normal 1G0\n  call assert_equal('plong', spellbadword()[0])\n  normal j\n  call assert_equal(9, getcurpos()[2])\n\n  bwipe!\n  set nospell\nendfunc\n\nfunc Test_z_equal_on_invalid_utf8_word()\n  split\n  set spell\n  call setline(1, \"\\xff\")\n  norm z=\n  set nospell\n  bwipe!\nendfunc\n\n\" Test spellbadword() with argument\nfunc Test_spellbadword()\n  set spell\n\n  call assert_equal(['bycycle', 'bad'],  spellbadword('My bycycle.'))\n  call assert_equal(['another', 'caps'], 'A sentence. another sentence'->spellbadword())\n\n  call assert_equal(['TheCamelWord', 'bad'], 'TheCamelWord asdf'->spellbadword())\n  set spelloptions=camel\n  call assert_equal(['asdf', 'bad'], 'TheCamelWord asdf'->spellbadword())\n  set spelloptions=\n\n  set spelllang=en\n  call assert_equal(['', ''],            spellbadword('centre'))\n  call assert_equal(['', ''],            spellbadword('center'))\n  set spelllang=en_us\n  call assert_equal(['centre', 'local'], spellbadword('centre'))\n  call assert_equal(['', ''],            spellbadword('center'))\n  set spelllang=en_gb\n  call assert_equal(['', ''],            spellbadword('centre'))\n  call assert_equal(['center', 'local'], spellbadword('center'))\n\n  \" Create a small word list to test that spellbadword('...')\n  \" can return ['...', 'rare'].\n  e Xwords\n  insert\nfoo\nfoobar/?\n.\n   w!\n   mkspell! Xwords.spl Xwords\n   set spelllang=Xwords.spl\n   call assert_equal(['foobar', 'rare'], spellbadword('foo foobar'))\n\n  \" Typo should be detected even without the 'spell' option.\n  set spelllang=en_gb nospell\n  call assert_equal(['', ''], spellbadword('centre'))\n  call assert_equal(['bycycle', 'bad'], spellbadword('My bycycle.'))\n  call assert_equal(['another', 'caps'], spellbadword('A sentence. another sentence'))\n\n  set spelllang=\n  call assert_fails(\"call spellbadword('maxch')\", 'E756:')\n  call assert_fails(\"spelldump\", 'E756:')\n\n  call delete('Xwords.spl')\n  call delete('Xwords')\n  set spelllang&\n  set spell&\nendfunc\n\nfunc Test_spell_file_missing()\n  let s:spell_file_missing = 0\n  augroup TestSpellFileMissing\n    autocmd! SpellFileMissing * let s:spell_file_missing += 1\n  augroup END\n\n  set spell spelllang=ab_cd\n  let messages = GetMessages()\n  call assert_equal('Warning: Cannot find word list \"ab.utf-8.spl\" or \"ab.ascii.spl\"', messages[-1])\n  call assert_equal(1, s:spell_file_missing)\n\n  new XTestSpellFileMissing\n  augroup TestSpellFileMissing\n    autocmd! SpellFileMissing * bwipe\n  augroup END\n  call assert_fails('set spell spelllang=ab_cd', 'E797:')\n\n  augroup! TestSpellFileMissing\n  unlet s:spell_file_missing\n  set spell& spelllang&\n  %bwipe!\nendfunc\n\nfunc Test_spelldump()\n  set spell spelllang=en\n  spellrare! emacs\n\n  spelldump\n\n  \" Check assumption about region: 1: us, 2: au, 3: ca, 4: gb, 5: nz.\n  call assert_equal('/regions=usaucagbnz', getline(1))\n  call assert_notequal(0, search('^theater/1$'))    \" US English only.\n  call assert_notequal(0, search('^theatre/2345$')) \" AU, CA, GB or NZ English.\n\n  call assert_notequal(0, search('^emacs/?$'))      \" ? for a rare word.\n  call assert_notequal(0, search('^the the/!$'))    \" ! for a wrong word.\n\n  bwipe\n  set spell&\nendfunc\n\nfunc Test_spelldump_bang()\n  new\n  call setline(1, 'This is a sample sentence.')\n  redraw\n  set spell\n  redraw\n  spelldump!\n\n  \" :spelldump! includes the number of times a word was found while updating\n  \" the screen.\n  \" Common word count starts at 10, regular word count starts at 0.\n  call assert_notequal(0, search(\"^is\\t11$\"))    \" common word found once.\n  call assert_notequal(0, search(\"^the\\t10$\"))   \" common word never found.\n  call assert_notequal(0, search(\"^sample\\t1$\")) \" regular word found once.\n  call assert_equal(0, search(\"^screen\\t\"))      \" regular word never found.\n\n  %bwipe!\n  set spell&\nendfunc\n\nfunc Test_spelllang_inv_region()\n  set spell spelllang=en_xx\n  let messages = GetMessages()\n  call assert_equal('Warning: region xx not supported', messages[-1])\n  set spell& spelllang&\nendfunc\n\nfunc Test_compl_with_CTRL_X_CTRL_K_using_spell()\n  \" When spell checking is enabled and 'dictionary' is empty,\n  \" CTRL-X CTRL-K in insert mode completes using the spelling dictionary.\n  new\n  set spell spelllang=en dictionary=\n\n  set ignorecase\n  call feedkeys(\"Senglis\\<c-x>\\<c-k>\\<esc>\", 'tnx')\n  call assert_equal(['English'], getline(1, '$'))\n  call feedkeys(\"SEnglis\\<c-x>\\<c-k>\\<esc>\", 'tnx')\n  call assert_equal(['English'], getline(1, '$'))\n\n  set noignorecase\n  call feedkeys(\"Senglis\\<c-x>\\<c-k>\\<esc>\", 'tnx')\n  call assert_equal(['englis'], getline(1, '$'))\n  call feedkeys(\"SEnglis\\<c-x>\\<c-k>\\<esc>\", 'tnx')\n  call assert_equal(['English'], getline(1, '$'))\n\n  set spelllang=en_us\n  call feedkeys(\"Stheat\\<c-x>\\<c-k>\\<esc>\", 'tnx')\n  call assert_equal(['theater'], getline(1, '$'))\n  set spelllang=en_gb\n  call feedkeys(\"Stheat\\<c-x>\\<c-k>\\<esc>\", 'tnx')\n  \" FIXME: commented out, expected theatre bug got theater. See issue #7025.\n  \" call assert_equal(['theatre'], getline(1, '$'))\n\n  bwipe!\n  set spell& spelllang& dictionary& ignorecase&\nendfunc\n\nfunc Test_spellreall()\n  new\n  set spell\n  call assert_fails('spellrepall', 'E752:')\n  call setline(1, ['A speling mistake. The same speling mistake.',\n        \\                'Another speling mistake.'])\n  call feedkeys(']s1z=', 'tx')\n  call assert_equal('A spelling mistake. The same speling mistake.', getline(1))\n  call assert_equal('Another speling mistake.', getline(2))\n  spellrepall\n  call assert_equal('A spelling mistake. The same spelling mistake.', getline(1))\n  call assert_equal('Another spelling mistake.', getline(2))\n  call assert_fails('spellrepall', 'E753:')\n  set spell&\n  bwipe!\nendfunc\n\n\" Test spellsuggest({word} [, {max} [, {capital}]])\nfunc Test_spellsuggest()\n  \" Verify suggestions are given even when spell checking is not enabled.\n  set nospell\n  call assert_equal(['march', 'March'], spellsuggest('marrch', 2))\n\n  set spell\n\n  \" With 1 argument.\n  call assert_equal(['march', 'March'], spellsuggest('marrch')[0:1])\n\n  \" With 2 arguments.\n  call assert_equal(['march', 'March'], spellsuggest('marrch', 2))\n\n  \" With 3 arguments.\n  call assert_equal(['march'], spellsuggest('marrch', 1, 0))\n  call assert_equal(['March'], spellsuggest('marrch', 1, 1))\n\n  \" Test with digits and hyphen.\n  call assert_equal('Carbon-14', spellsuggest('Carbon-15')[0])\n\n  \" Comment taken from spellsuggest.c explains the following test cases:\n  \"\n  \" If there are more UPPER than lower case letters suggest an\n  \" ALLCAP word.  Otherwise, if the first letter is UPPER then\n  \" suggest ONECAP.  Exception: \"ALl\" most likely should be \"All\",\n  \" require three upper case letters.\n  call assert_equal(['THIRD', 'third'], spellsuggest('thIRD', 2))\n  call assert_equal(['third', 'THIRD'], spellsuggest('tHIrd', 2))\n  call assert_equal(['Third'], spellsuggest('THird', 1))\n  call assert_equal(['All'],      spellsuggest('ALl', 1))\n\n  \" Special suggestion for repeated 'the the'.\n  call assert_inrange(0, 2, index(spellsuggest('the the',   3), 'the'))\n  call assert_inrange(0, 2, index(spellsuggest('the   the', 3), 'the'))\n  call assert_inrange(0, 2, index(spellsuggest('The the',   3), 'The'))\n\n  call assert_fails(\"call spellsuggest('maxch', [])\", 'E745:')\n  call assert_fails(\"call spellsuggest('maxch', 2, [])\", 'E745:')\n\n  set spelllang=\n  call assert_fails(\"call spellsuggest('maxch')\", 'E756:')\n  set spelllang&\n\n  set spell&\nendfunc\n\n\" Test 'spellsuggest' option with methods fast, best and double.\nfunc Test_spellsuggest_option_methods()\n  set spell\n\n  for e in ['latin1', 'utf-8']\n    exe 'set encoding=' .. e\n\n    set spellsuggest=fast\n    call assert_equal(['Stick', 'Stitch'], spellsuggest('Stich', 2), e)\n\n    \" With best or double option, \"Stitch\" should become the top suggestion\n    \" because of better phonetic matching.\n    set spellsuggest=best\n    call assert_equal(['Stitch', 'Stick'], spellsuggest('Stich', 2), e)\n\n    set spellsuggest=double\n    call assert_equal(['Stitch', 'Stick'], spellsuggest('Stich', 2), e)\n  endfor\n\n  set spell& spellsuggest& encoding&\nendfunc\n\n\" Test 'spellsuggest' option with value file:{filename}\nfunc Test_spellsuggest_option_file()\n  set spell spellsuggest=file:Xspellsuggest\n  call writefile(['emacs/vim',\n        \\         'theribal/terrible',\n        \\         'teribal/terrrible',\n        \\         'terribal'],\n        \\         'Xspellsuggest')\n\n  call assert_equal(['vim'],      spellsuggest('emacs', 2))\n  call assert_equal(['terrible'], spellsuggest('theribal',2))\n\n  \" If the suggestion is misspelled (*terrrible* with 3 r),\n  \" it should not be proposed.\n  \" The entry for \"terribal\" should be ignored because of missing slash.\n  call assert_equal([], spellsuggest('teribal', 2))\n  call assert_equal([], spellsuggest('terribal', 2))\n\n  set spell spellsuggest=best,file:Xspellsuggest\n  call assert_equal(['vim', 'Emacs'],       spellsuggest('emacs', 2))\n  call assert_equal(['terrible', 'tribal'], spellsuggest('theribal', 2))\n  call assert_equal(['tribal'],             spellsuggest('teribal', 1))\n  call assert_equal(['tribal'],             spellsuggest('terribal', 1))\n\n  call delete('Xspellsuggest')\n  call assert_fails(\"call spellsuggest('vim')\", \"E484: Can't open file Xspellsuggest\")\n\n  set spellsuggest& spell&\nendfunc\n\n\" Test 'spellsuggest' option with value {number}\n\" to limit the number of suggestions\nfunc Test_spellsuggest_option_number()\n  set spell spellsuggest=2,best\n  new\n\n  \" We limited the number of suggestions to 2, so selecting\n  \" the 1st and 2nd suggestion should correct the word, but\n  \" selecting a 3rd suggestion should do nothing.\n  call setline(1, 'A baord')\n  norm $1z=\n  call assert_equal('A board', getline(1))\n\n  call setline(1, 'A baord')\n  norm $2z=\n  call assert_equal('A bard', getline(1))\n\n  call setline(1, 'A baord')\n  norm $3z=\n  call assert_equal('A baord', getline(1))\n\n  let a = execute('norm $z=')\n  call assert_equal(\n  \\    \"\\n\"\n  \\ .. \"Change \\\"baord\\\" to:\\n\"\n  \\ .. \" 1 \\\"board\\\"\\n\"\n  \\ .. \" 2 \\\"bard\\\"\\n\"\n  \\ .. \"Type number and <Enter> or click with the mouse (q or empty cancels): \", a)\n\n  set spell spellsuggest=0\n  call assert_equal(\"\\nSorry, no suggestions\", execute('norm $z='))\n\n  \" Unlike z=, function spellsuggest(...) should not be affected by the\n  \" max number of suggestions (2) set by the 'spellsuggest' option.\n  call assert_equal(['board', 'bard', 'broad'], spellsuggest('baord', 3))\n\n  set spellsuggest& spell&\n  bwipe!\nendfunc\n\n\" Test 'spellsuggest' option with value expr:{expr}\nfunc Test_spellsuggest_option_expr()\n  \" A silly 'spellsuggest' function which makes suggestions all uppercase\n  \" and makes the score of each suggestion the length of the suggested word.\n  \" So shorter suggestions are preferred.\n  func MySuggest()\n    let spellsuggest_save = &spellsuggest\n    set spellsuggest=3,best\n    let result = map(spellsuggest(v:val, 3), \"[toupper(v:val), len(v:val)]\")\n    let &spellsuggest = spellsuggest_save\n    return result\n  endfunc\n\n  set spell spellsuggest=expr:MySuggest()\n  call assert_equal(['BARD', 'BOARD', 'BROAD'], spellsuggest('baord', 3))\n\n  new\n  call setline(1, 'baord')\n  let a = execute('norm z=')\n  call assert_equal(\n  \\    \"\\n\"\n  \\ .. \"Change \\\"baord\\\" to:\\n\"\n  \\ .. \" 1 \\\"BARD\\\"\\n\"\n  \\ .. \" 2 \\\"BOARD\\\"\\n\"\n  \\ .. \" 3 \\\"BROAD\\\"\\n\"\n  \\ .. \"Type number and <Enter> or click with the mouse (q or empty cancels): \", a)\n\n  \" With verbose, z= should show the score i.e. word length with\n  \" our SpellSuggest() function.\n  set verbose=1\n  let a = execute('norm z=')\n  call assert_equal(\n  \\    \"\\n\"\n  \\ .. \"Change \\\"baord\\\" to:\\n\"\n  \\ .. \" 1 \\\"BARD\\\"                      (4 - 0)\\n\"\n  \\ .. \" 2 \\\"BOARD\\\"                     (5 - 0)\\n\"\n  \\ .. \" 3 \\\"BROAD\\\"                     (5 - 0)\\n\"\n  \\ .. \"Type number and <Enter> or click with the mouse (q or empty cancels): \", a)\n\n  set spell& spellsuggest& verbose&\n  bwipe!\nendfunc\n\n\" Test for 'spellsuggest' expr errrors\nfunc Test_spellsuggest_expr_errors()\n  \" 'spellsuggest'\n  func MySuggest()\n    return range(3)\n  endfunc\n  set spell spellsuggest=expr:MySuggest()\n  call assert_equal([], spellsuggest('baord', 3))\n\n  \" Test for 'spellsuggest' expression returning a non-list value\n  func! MySuggest2()\n    return 'good'\n  endfunc\n  set spellsuggest=expr:MySuggest2()\n  call assert_equal([], spellsuggest('baord'))\n\n  \" Test for 'spellsuggest' expression returning a list with dict values\n  func! MySuggest3()\n    return [[{}, {}]]\n  endfunc\n  set spellsuggest=expr:MySuggest3()\n  call assert_fails(\"call spellsuggest('baord')\", 'E731:')\n\n  set nospell spellsuggest&\n  delfunc MySuggest\n  delfunc MySuggest2\n  delfunc MySuggest3\nendfunc\n\nfunc Test_spellinfo()\n  new\n  let runtime = substitute($VIMRUNTIME, '\\\\', '/', 'g')\n\n  set enc=latin1 spell spelllang=en\n  call assert_match(\"^\\nfile: \" .. runtime .. \"/spell/en.latin1.spl\\n$\", execute('spellinfo'))\n\n  set enc=cp1250 spell spelllang=en\n  call assert_match(\"^\\nfile: \" .. runtime .. \"/spell/en.ascii.spl\\n$\", execute('spellinfo'))\n\n  set enc=utf-8 spell spelllang=en\n  call assert_match(\"^\\nfile: \" .. runtime .. \"/spell/en.utf-8.spl\\n$\", execute('spellinfo'))\n\n  set enc=latin1 spell spelllang=en_us,en_nz\n  call assert_match(\"^\\n\" .\n                 \\  \"file: \" .. runtime .. \"/spell/en.latin1.spl\\n\" .\n                 \\  \"file: \" .. runtime.. \"/spell/en.latin1.spl\\n$\", execute('spellinfo'))\n\n  set spell spelllang=\n  call assert_fails('spellinfo', 'E756:')\n\n  set nospell spelllang=en\n  call assert_fails('spellinfo', 'E756:')\n\n  call assert_fails('set spelllang=foo/bar', 'E474:')\n  call assert_fails('set spelllang=foo\\ bar', 'E474:')\n  call assert_fails(\"set spelllang=foo\\\\\\nbar\", 'E474:')\n  call assert_fails(\"set spelllang=foo\\\\\\rbar\", 'E474:')\n  call assert_fails(\"set spelllang=foo+bar\", 'E474:')\n\n  set enc& spell& spelllang&\n  bwipe\nendfunc\n\nfunc Test_zz_basic()\n  call LoadAffAndDic(g:test_data_aff1, g:test_data_dic1)\n  call RunGoodBad(\"wrong OK puts. Test the end\",\n        \\ \"bad: inputs comment ok Ok. test d\\xE9\\xF4l end the\",\n        \\[\"Comment\", \"deol\", \"d\\xE9\\xF4r\", \"input\", \"OK\", \"output\", \"outputs\", \"outtest\", \"put\", \"puts\",\n        \\  \"test\", \"testen\", \"testn\", \"the end\", \"uk\", \"wrong\"],\n        \\[\n        \\   [\"bad\", [\"put\", \"uk\", \"OK\"]],\n        \\   [\"inputs\", [\"input\", \"puts\", \"outputs\"]],\n        \\   [\"comment\", [\"Comment\", \"outtest\", \"the end\"]],\n        \\   [\"ok\", [\"OK\", \"uk\", \"put\"]],\n        \\   [\"Ok\", [\"OK\", \"Uk\", \"Put\"]],\n        \\   [\"test\", [\"Test\", \"testn\", \"testen\"]],\n        \\   [\"d\\xE9\\xF4l\", [\"deol\", \"d\\xE9\\xF4r\", \"test\"]],\n        \\   [\"end\", [\"put\", \"uk\", \"test\"]],\n        \\   [\"the\", [\"put\", \"uk\", \"test\"]],\n        \\ ]\n        \\ )\n\n  call assert_equal(\"gebletegek\", soundfold('goobledygoook'))\n  call assert_equal(\"kepereneven\", 'k\u00f3op\u00ebr\u02d9n\u00f4ven'->soundfold())\n  call assert_equal(\"everles gesvets etele\", soundfold('oeverloos gezwets edale'))\nendfunc\n\n\" Postponed prefixes\nfunc Test_zz_prefixes()\n  call LoadAffAndDic(g:test_data_aff2, g:test_data_dic1)\n  call RunGoodBad(\"puts\",\n        \\ \"bad: inputs comment ok Ok end the. test d\\xE9\\xF4l\",\n        \\ [\"Comment\", \"deol\", \"d\\xE9\\xF4r\", \"OK\", \"put\", \"input\", \"output\", \"puts\", \"outputs\", \"test\", \"outtest\", \"testen\", \"testn\", \"the end\", \"uk\", \"wrong\"],\n        \\ [\n        \\   [\"bad\", [\"put\", \"uk\", \"OK\"]],\n        \\   [\"inputs\", [\"input\", \"puts\", \"outputs\"]],\n        \\   [\"comment\", [\"Comment\"]],\n        \\   [\"ok\", [\"OK\", \"uk\", \"put\"]],\n        \\   [\"Ok\", [\"OK\", \"Uk\", \"Put\"]],\n        \\   [\"end\", [\"put\", \"uk\", \"deol\"]],\n        \\   [\"the\", [\"put\", \"uk\", \"test\"]],\n        \\   [\"test\", [\"Test\", \"testn\", \"testen\"]],\n        \\   [\"d\\xE9\\xF4l\", [\"deol\", \"d\\xE9\\xF4r\", \"test\"]],\n        \\ ])\nendfunc\n\n\"Compound words\nfunc Test_zz_compound()\n  call LoadAffAndDic(g:test_data_aff3, g:test_data_dic3)\n  call RunGoodBad(\"foo m\\xEF foobar foofoobar barfoo barbarfoo\",\n        \\ \"bad: bar la foom\\xEF barm\\xEF m\\xEFfoo m\\xEFbar m\\xEFm\\xEF lala m\\xEFla lam\\xEF foola labar\",\n        \\ [\"foo\", \"m\\xEF\"],\n        \\ [\n        \\   [\"bad\", [\"foo\", \"m\\xEF\"]],\n        \\   [\"bar\", [\"barfoo\", \"foobar\", \"foo\"]],\n        \\   [\"la\", [\"m\\xEF\", \"foo\"]],\n        \\   [\"foom\\xEF\", [\"foo m\\xEF\", \"foo\", \"foofoo\"]],\n        \\   [\"barm\\xEF\", [\"barfoo\", \"m\\xEF\", \"barbar\"]],\n        \\   [\"m\\xEFfoo\", [\"m\\xEF foo\", \"foo\", \"foofoo\"]],\n        \\   [\"m\\xEFbar\", [\"foobar\", \"barbar\", \"m\\xEF\"]],\n        \\   [\"m\\xEFm\\xEF\", [\"m\\xEF m\\xEF\", \"m\\xEF\"]],\n        \\   [\"lala\", []],\n        \\   [\"m\\xEFla\", [\"m\\xEF\", \"m\\xEF m\\xEF\"]],\n        \\   [\"lam\\xEF\", [\"m\\xEF\", \"m\\xEF m\\xEF\"]],\n        \\   [\"foola\", [\"foo\", \"foobar\", \"foofoo\"]],\n        \\   [\"labar\", [\"barbar\", \"foobar\"]],\n        \\ ])\n\n  call LoadAffAndDic(g:test_data_aff4, g:test_data_dic4)\n  call RunGoodBad(\"word util bork prebork start end wordutil wordutils pro-ok bork borkbork borkborkbork borkborkborkbork borkborkborkborkbork tomato tomatotomato startend startword startwordword startwordend startwordwordend startwordwordwordend prebork preborkbork preborkborkbork nouword\",\n        \\ \"bad: wordutilize pro borkborkborkborkborkbork tomatotomatotomato endstart endend startstart wordend wordstart preborkprebork  preborkpreborkbork startwordwordwordwordend borkpreborkpreborkbork utilsbork  startnouword\",\n        \\ [\"bork\", \"prebork\", \"end\", \"pro-ok\", \"start\", \"tomato\", \"util\", \"utilize\", \"utils\", \"word\", \"nouword\"],\n        \\ [\n        \\   [\"bad\", [\"end\", \"bork\", \"word\"]],\n        \\   [\"wordutilize\", [\"word utilize\", \"wordutils\", \"wordutil\"]],\n        \\   [\"pro\", [\"bork\", \"word\", \"end\"]],\n        \\   [\"borkborkborkborkborkbork\", [\"bork borkborkborkborkbork\", \"borkbork borkborkborkbork\", \"borkborkbork borkborkbork\"]],\n        \\   [\"tomatotomatotomato\", [\"tomato tomatotomato\", \"tomatotomato tomato\", \"tomato tomato tomato\"]],\n        \\   [\"endstart\", [\"end start\", \"start\"]],\n        \\   [\"endend\", [\"end end\", \"end\"]],\n        \\   [\"startstart\", [\"start start\"]],\n        \\   [\"wordend\", [\"word end\", \"word\", \"wordword\"]],\n        \\   [\"wordstart\", [\"word start\", \"bork start\"]],\n        \\   [\"preborkprebork\", [\"prebork prebork\", \"preborkbork\", \"preborkborkbork\"]],\n        \\   [\"preborkpreborkbork\", [\"prebork preborkbork\", \"preborkborkbork\", \"preborkborkborkbork\"]],\n        \\   [\"startwordwordwordwordend\", [\"startwordwordwordword end\", \"startwordwordwordword\", \"start wordwordwordword end\"]],\n        \\   [\"borkpreborkpreborkbork\", [\"bork preborkpreborkbork\", \"bork prebork preborkbork\", \"bork preborkprebork bork\"]],\n        \\   [\"utilsbork\", [\"utilbork\", \"utils bork\", \"util bork\"]],\n        \\   [\"startnouword\", [\"start nouword\", \"startword\", \"startborkword\"]],\n        \\ ])\n\nendfunc\n\n\"Test affix flags with two characters\nfunc Test_zz_affix()\n  call LoadAffAndDic(g:test_data_aff5, g:test_data_dic5)\n  call RunGoodBad(\"fooa1 fooa\\xE9 bar prebar barbork prebarbork  startprebar start end startend  startmiddleend nouend\",\n        \\ \"bad: foo fooa2 prabar probarbirk middle startmiddle middleend endstart startprobar startnouend\",\n        \\ [\"bar\", \"barbork\", \"end\", \"fooa1\", \"fooa\\xE9\", \"nouend\", \"prebar\", \"prebarbork\", \"start\"],\n        \\ [\n        \\   [\"bad\", [\"bar\", \"end\", \"fooa1\"]],\n        \\   [\"foo\", [\"fooa1\", \"fooa\\xE9\", \"bar\"]],\n        \\   [\"fooa2\", [\"fooa1\", \"fooa\\xE9\", \"bar\"]],\n        \\   [\"prabar\", [\"prebar\", \"bar\", \"bar bar\"]],\n        \\   [\"probarbirk\", [\"prebarbork\"]],\n        \\   [\"middle\", []],\n        \\   [\"startmiddle\", [\"startmiddleend\", \"startmiddlebar\"]],\n        \\   [\"middleend\", []],\n        \\   [\"endstart\", [\"end start\", \"start\"]],\n        \\   [\"startprobar\", [\"startprebar\", \"start prebar\", \"startbar\"]],\n        \\   [\"startnouend\", [\"start nouend\", \"startend\"]],\n        \\ ])\n\n  call LoadAffAndDic(g:test_data_aff6, g:test_data_dic6)\n  call RunGoodBad(\"meea1 meea\\xE9 bar prebar barbork prebarbork  leadprebar lead end leadend  leadmiddleend\",\n        \\  \"bad: mee meea2 prabar probarbirk middle leadmiddle middleend endlead leadprobar\",\n        \\ [\"bar\", \"barbork\", \"end\", \"lead\", \"meea1\", \"meea\\xE9\", \"prebar\", \"prebarbork\"],\n        \\ [\n        \\   [\"bad\", [\"bar\", \"end\", \"lead\"]],\n        \\   [\"mee\", [\"meea1\", \"meea\\xE9\", \"bar\"]],\n        \\   [\"meea2\", [\"meea1\", \"meea\\xE9\", \"lead\"]],\n        \\   [\"prabar\", [\"prebar\", \"bar\", \"leadbar\"]],\n        \\   [\"probarbirk\", [\"prebarbork\"]],\n        \\   [\"middle\", []],\n        \\   [\"leadmiddle\", [\"leadmiddleend\", \"leadmiddlebar\"]],\n        \\   [\"middleend\", []],\n        \\   [\"endlead\", [\"end lead\", \"lead\", \"end end\"]],\n        \\   [\"leadprobar\", [\"leadprebar\", \"lead prebar\", \"leadbar\"]],\n        \\ ])\n\n  call LoadAffAndDic(g:test_data_aff7, g:test_data_dic7)\n  call RunGoodBad(\"meea1 meezero meea\\xE9 bar prebar barmeat prebarmeat  leadprebar lead tail leadtail  leadmiddletail\",\n        \\ \"bad: mee meea2 prabar probarmaat middle leadmiddle middletail taillead leadprobar\",\n        \\ [\"bar\", \"barmeat\", \"lead\", \"meea1\", \"meea\\xE9\", \"meezero\", \"prebar\", \"prebarmeat\", \"tail\"],\n        \\ [\n        \\   [\"bad\", [\"bar\", \"lead\", \"tail\"]],\n        \\   [\"mee\", [\"meea1\", \"meea\\xE9\", \"bar\"]],\n        \\   [\"meea2\", [\"meea1\", \"meea\\xE9\", \"lead\"]],\n        \\   [\"prabar\", [\"prebar\", \"bar\", \"leadbar\"]],\n        \\   [\"probarmaat\", [\"prebarmeat\"]],\n        \\   [\"middle\", []],\n        \\   [\"leadmiddle\", [\"leadmiddlebar\"]],\n        \\   [\"middletail\", []],\n        \\   [\"taillead\", [\"tail lead\", \"tail\"]],\n        \\   [\"leadprobar\", [\"leadprebar\", \"lead prebar\", \"leadbar\"]],\n        \\ ])\nendfunc\n\nfunc Test_zz_NOSLITSUGS()\n  call LoadAffAndDic(g:test_data_aff8, g:test_data_dic8)\n  call RunGoodBad(\"foo bar faabar\", \"bad: foobar barfoo\",\n        \\ [\"bar\", \"faabar\", \"foo\"],\n        \\ [\n        \\   [\"bad\", [\"bar\", \"foo\"]],\n        \\   [\"foobar\", [\"faabar\", \"foo bar\", \"bar\"]],\n        \\   [\"barfoo\", [\"bar foo\", \"bar\", \"foo\"]],\n        \\ ])\nendfunc\n\n\" Numbers\nfunc Test_zz_Numbers()\n  call LoadAffAndDic(g:test_data_aff9, g:test_data_dic9)\n  call RunGoodBad(\"0b1011 0777 1234 0x01ff\", \"\",\n        \\ [\"bar\", \"foo\"],\n        \\ [\n        \\ ])\nendfunc\n\n\" Affix flags\nfunc Test_zz_affix_flags()\n  call LoadAffAndDic(g:test_data_aff10, g:test_data_dic10)\n  call RunGoodBad(\"drink drinkable drinkables drinktable drinkabletable\",\n\t\\ \"bad: drinks drinkstable drinkablestable\",\n        \\ [\"drink\", \"drinkable\", \"drinkables\", \"table\"],\n        \\ [['bad', []],\n\t\\ ['drinks', ['drink']],\n\t\\ ['drinkstable', ['drinktable', 'drinkable', 'drink table']],\n        \\ ['drinkablestable', ['drinkabletable', 'drinkables table', 'drinkable table']],\n\t\\ ])\nendfunc\n\nfunction FirstSpellWord()\n  call feedkeys(\"/^start:\\n\", 'tx')\n  normal ]smm\n  let [str, a] = spellbadword()\n  return str\nendfunc\n\nfunction SecondSpellWord()\n  normal `m]s\n  let [str, a] = spellbadword()\n  return str\nendfunc\n\n\"Test with SAL instead of SOFO items; test automatic reloading\nfunc Test_zz_sal_and_addition()\n  set enc=latin1\n  set spellfile=\n  call writefile(g:test_data_dic1, \"Xtest.dic\")\n  call writefile(g:test_data_aff_sal, \"Xtest.aff\")\n  mkspell! Xtest Xtest\n  set spl=Xtest.latin1.spl spell\n  call assert_equal('kbltykk', soundfold('goobledygoook'))\n  call assert_equal('kprnfn', soundfold('k\u00f3op\u00ebr\u02d9n\u00f4ven'))\n  call assert_equal('*fls kswts tl', soundfold('oeverloos gezwets edale'))\n\n  \"also use an addition file\n  call writefile([\"/regions=usgbnz\", \"elequint/2\", \"elekwint/3\"], \"Xtest.latin1.add\")\n  mkspell! Xtest.latin1.add.spl Xtest.latin1.add\n\n  bwipe!\n  call setline(1, [\"start: elequint test elekwint test elekwent asdf\"])\n\n  set spellfile=Xtest.latin1.add\n  call assert_equal(\"elekwent\", FirstSpellWord())\n\n  set spl=Xtest_us.latin1.spl\n  call assert_equal(\"elequint\", FirstSpellWord())\n  call assert_equal(\"elekwint\", SecondSpellWord())\n\n  set spl=Xtest_gb.latin1.spl\n  call assert_equal(\"elekwint\", FirstSpellWord())\n  call assert_equal(\"elekwent\", SecondSpellWord())\n\n  set spl=Xtest_nz.latin1.spl\n  call assert_equal(\"elequint\", FirstSpellWord())\n  call assert_equal(\"elekwent\", SecondSpellWord())\n\n  set spl=Xtest_ca.latin1.spl\n  call assert_equal(\"elequint\", FirstSpellWord())\n  call assert_equal(\"elekwint\", SecondSpellWord())\nendfunc\n\nfunc Test_spellfile_value()\n  set spellfile=Xdir/Xtest.latin1.add\n  set spellfile=Xdir/Xtest.utf-8.add,Xtest_other.add\nendfunc\n\nfunc Test_region_error()\n  messages clear\n  call writefile([\"/regions=usgbnz\", \"elequint/0\"], \"Xtest.latin1.add\")\n  mkspell! Xtest.latin1.add.spl Xtest.latin1.add\n  call assert_match('Invalid region nr in Xtest.latin1.add line 2: 0', execute('messages'))\n  call delete('Xtest.latin1.add')\n  call delete('Xtest.latin1.add.spl')\nendfunc\n\n\" Check using z= in new buffer (crash fixed by patch 7.4a.028).\nfunc Test_zeq_crash()\n  new\n  set maxmem=512 spell\n  call feedkeys('iasd\u001bz=:\\\"', 'tx')\n\n  bwipe!\nendfunc\n\n\" Check that z= works even when 'nospell' is set.  This test uses one of the\n\" tests in Test_spellsuggest_option_number() just to verify that z= basically\n\" works and that \"E756: Spell checking is not enabled\" is not generated.\nfunc Test_zeq_nospell()\n  new\n  set nospell spellsuggest=1,best\n  call setline(1, 'A baord')\n  try\n    norm $1z=\n    call assert_equal('A board', getline(1))\n  catch\n    call assert_report(\"Caught exception: \" . v:exception)\n  endtry\n  set spell& spellsuggest&\n  bwipe!\nendfunc\n\n\" Check that \"E756: Spell checking is not possible\" is reported when z= is\n\" executed and 'spelllang' is empty.\nfunc Test_zeq_no_spelllang()\n  new\n  set spelllang= spellsuggest=1,best\n  call setline(1, 'A baord')\n  call assert_fails('normal $1z=', 'E756:')\n  set spelllang& spellsuggest&\n  bwipe!\nendfunc\n\n\" Check handling a word longer than MAXWLEN.\nfunc Test_spell_long_word()\n  set enc=utf-8\n  new\n  call setline(1, \"d\\xCC\\xB4\\xCC\\xBD\\xCD\\x88\\xCD\\x94a\\xCC\\xB5\\xCD\\x84\\xCD\\x84\\xCC\\xA8\\xCD\\x9Cr\\xCC\\xB5\\xCC\\x8E\\xCD\\x85\\xCD\\x85k\\xCC\\xB6\\xCC\\x89\\xCC\\x9D \\xCC\\xB6\\xCC\\x83\\xCC\\x8F\\xCC\\xA4\\xCD\\x8Ef\\xCC\\xB7\\xCC\\x81\\xCC\\x80\\xCC\\xA9\\xCC\\xB0\\xCC\\xAC\\xCC\\xA2\\xCD\\x95\\xCD\\x87\\xCD\\x8D\\xCC\\x9E\\xCD\\x99\\xCC\\xAD\\xCC\\xAB\\xCC\\x97\\xCC\\xBBo\\xCC\\xB6\\xCC\\x84\\xCC\\x95\\xCC\\x8C\\xCC\\x8B\\xCD\\x9B\\xCD\\x9C\\xCC\\xAFr\\xCC\\xB7\\xCC\\x94\\xCD\\x83\\xCD\\x97\\xCC\\x8C\\xCC\\x82\\xCD\\x82\\xCD\\x80\\xCD\\x91\\xCC\\x80\\xCC\\xBE\\xCC\\x82\\xCC\\x8F\\xCC\\xA3\\xCD\\x85\\xCC\\xAE\\xCD\\x8D\\xCD\\x99\\xCC\\xBC\\xCC\\xAB\\xCC\\xA7\\xCD\\x88c\\xCC\\xB7\\xCD\\x83\\xCC\\x84\\xCD\\x92\\xCC\\x86\\xCC\\x83\\xCC\\x88\\xCC\\x92\\xCC\\x94\\xCC\\xBE\\xCC\\x9D\\xCC\\xAF\\xCC\\x98\\xCC\\x9D\\xCC\\xBB\\xCD\\x8E\\xCC\\xBB\\xCC\\xB3\\xCC\\xA3\\xCD\\x8E\\xCD\\x99\\xCC\\xA5\\xCC\\xAD\\xCC\\x99\\xCC\\xB9\\xCC\\xAE\\xCC\\xA5\\xCC\\x9E\\xCD\\x88\\xCC\\xAE\\xCC\\x9E\\xCC\\xA9\\xCC\\x97\\xCC\\xBC\\xCC\\x99\\xCC\\xA5\\xCD\\x87\\xCC\\x97\\xCD\\x8E\\xCD\\x94\\xCC\\x99\\xCC\\x9D\\xCC\\x96\\xCD\\x94\\xCC\\xAB\\xCC\\xA7\\xCC\\xA5\\xCC\\x98\\xCC\\xBB\\xCC\\xAF\\xCC\\xABe\\xCC\\xB7\\xCC\\x8E\\xCC\\x82\\xCD\\x86\\xCD\\x9B\\xCC\\x94\\xCD\\x83\\xCC\\x85\\xCD\\x8A\\xCD\\x8C\\xCC\\x8B\\xCD\\x92\\xCD\\x91\\xCC\\x8F\\xCC\\x81\\xCD\\x95\\xCC\\xA2\\xCC\\xB9\\xCC\\xB2\\xCD\\x9C\\xCC\\xB1\\xCC\\xA6\\xCC\\xB3\\xCC\\xAF\\xCC\\xAE\\xCC\\x9C\\xCD\\x99s\\xCC\\xB8\\xCC\\x8C\\xCC\\x8E\\xCC\\x87\\xCD\\x81\\xCD\\x82\\xCC\\x86\\xCD\\x8C\\xCD\\x8C\\xCC\\x8B\\xCC\\x84\\xCC\\x8C\\xCD\\x84\\xCD\\x9B\\xCD\\x86\\xCC\\x93\\xCD\\x90\\xCC\\x85\\xCC\\x94\\xCD\\x98\\xCD\\x84\\xCD\\x92\\xCD\\x8B\\xCC\\x90\\xCC\\x83\\xCC\\x8F\\xCD\\x84\\xCD\\x81\\xCD\\x9B\\xCC\\x90\\xCD\\x81\\xCC\\x8F\\xCC\\xBD\\xCC\\x88\\xCC\\xBF\\xCC\\x88\\xCC\\x84\\xCC\\x8E\\xCD\\x99\\xCD\\x94\\xCC\\x99\\xCD\\x99\\xCC\\xB0\\xCC\\xA8\\xCC\\xA3\\xCC\\xA8\\xCC\\x96\\xCC\\x99\\xCC\\xAE\\xCC\\xBC\\xCC\\x99\\xCD\\x9A\\xCC\\xB2\\xCC\\xB1\\xCC\\x9F\\xCC\\xBB\\xCC\\xA6\\xCD\\x85\\xCC\\xAA\\xCD\\x89\\xCC\\x9D\\xCC\\x99\\xCD\\x96\\xCC\\xB1\\xCC\\xB1\\xCC\\x99\\xCC\\xA6\\xCC\\xA5\\xCD\\x95\\xCC\\xB2\\xCC\\xA0\\xCD\\x99 within\")\n  set spell spelllang=en\n  redraw\n  redraw!\n  bwipe!\n  set nospell\nendfunc\n\nfunc Test_spellsuggest_too_deep()\n  \" This was incrementing \"depth\" over MAXWLEN.\n  new\n  norm \u0016s000G00\u00fd000000000000\n  sil norm ..vzG................vvzG0     v z=\n  bwipe!\nendfunc\n\nfunc LoadAffAndDic(aff_contents, dic_contents)\n  set enc=latin1\n  set spellfile=\n  call writefile(a:aff_contents, \"Xtest.aff\")\n  call writefile(a:dic_contents, \"Xtest.dic\")\n  \" Generate a .spl file from a .dic and .aff file.\n  mkspell! Xtest Xtest\n  \" use that spell file\n  set spl=Xtest.latin1.spl spell\nendfunc\n\nfunc ListWords()\n  spelldump\n  %yank\n  quit\n  return split(@\", \"\\n\")\nendfunc\n\nfunc TestGoodBadBase()\n  exe '1;/^good:'\n  normal 0f:]s\n  let prevbad = ''\n  let result = []\n  while 1\n    let [bad, a] = spellbadword()\n    if bad == '' || bad == prevbad || bad == 'badend'\n      break\n    endif\n    let prevbad = bad\n    let lst = bad->spellsuggest(3)\n    normal mm\n\n    call add(result, [bad, lst])\n    normal `m]s\n  endwhile\n  return result\nendfunc\n\nfunc RunGoodBad(good, bad, expected_words, expected_bad_words)\n  bwipe!\n  call setline(1, [\"good: \", a:good,  a:bad, \" badend \"])\n  let words = ListWords()\n  call assert_equal(a:expected_words, words[1:-1])\n  let bad_words = TestGoodBadBase()\n  call assert_equal(a:expected_bad_words, bad_words)\n  bwipe!\nendfunc\n\nfunc Test_spell_screendump()\n  CheckScreendump\n\n  let lines =<< trim END\n       call setline(1, [\n             \\ \"This is some text without any spell errors.  Everything\",\n             \\ \"should just be black, nothing wrong here.\",\n             \\ \"\",\n             \\ \"This line has a sepll error. and missing caps.\",\n             \\ \"And and this is the the duplication.\",\n             \\ \"with missing caps here.\",\n             \\ ])\n       set spell spelllang=en_nz\n  END\n  call writefile(lines, 'XtestSpell')\n  let buf = RunVimInTerminal('-S XtestSpell', {'rows': 8})\n  call VerifyScreenDump(buf, 'Test_spell_1', {})\n\n  \" clean up\n  call StopVimInTerminal(buf)\n  call delete('XtestSpell')\nendfunc\n\nfunc Test_spell_single_word()\n  new\n  silent! norm 0R00\n  spell! \u00df\u00c2\n  silent 0norm 0r$ Dvz=\n  bwipe!\nendfunc\n\nlet g:test_data_aff1 = [\n      \\\"SET ISO8859-1\",\n      \\\"TRY esianrtolcdugmphbyfvkwjkqxz-\\xEB\\xE9\\xE8\\xEA\\xEF\\xEE\\xE4\\xE0\\xE2\\xF6\\xFC\\xFB'ESIANRTOLCDUGMPHBYFVKWJKQXZ\",\n      \\\"\",\n      \\\"FOL  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"LOW  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"UPP  \\xC0\\xC1\\xC2\\xC3\\xC4\\xC5\\xC6\\xC7\\xC8\\xC9\\xCA\\xCB\\xCC\\xCD\\xCE\\xCF\\xD0\\xD1\\xD2\\xD3\\xD4\\xD5\\xD6\\xD8\\xD9\\xDA\\xDB\\xDC\\xDD\\xDE\\xDF\\xFF\",\n      \\\"\",\n      \\\"SOFOFROM abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\\xC0\\xC1\\xC2\\xC3\\xC4\\xC5\\xC6\\xC7\\xC8\\xC9\\xCA\\xCB\\xCC\\xCD\\xCE\\xCF\\xD0\\xD1\\xD2\\xD3\\xD4\\xD5\\xD6\\xD8\\xD9\\xDA\\xDB\\xDC\\xDD\\xDE\\xBF\",\n      \\\"SOFOTO   ebctefghejklnnepkrstevvkesebctefghejklnnepkrstevvkeseeeeeeeceeeeeeeedneeeeeeeeeeepseeeeeeeeceeeeeeeedneeeeeeeeeeep?\",\n      \\\"\",\n      \\\"MIDWORD\\t'-\",\n      \\\"\",\n      \\\"KEP =\",\n      \\\"RAR ?\",\n      \\\"BAD !\",\n      \\\"\",\n      \\\"PFX I N 1\",\n      \\\"PFX I 0 in .\",\n      \\\"\",\n      \\\"PFX O Y 1\",\n      \\\"PFX O 0 out .\",\n      \\\"\",\n      \\\"SFX S Y 2\",\n      \\\"SFX S 0 s [^s]\",\n      \\\"SFX S 0 es s\",\n      \\\"\",\n      \\\"SFX N N 3\",\n      \\\"SFX N 0 en [^n]\",\n      \\\"SFX N 0 nen n\",\n      \\\"SFX N 0 n .\",\n      \\\"\",\n      \\\"REP 3\",\n      \\\"REP g ch\",\n      \\\"REP ch g\",\n      \\\"REP svp s.v.p.\",\n      \\\"\",\n      \\\"MAP 9\",\n      \\\"MAP a\\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\",\n      \\\"MAP e\\xE8\\xE9\\xEA\\xEB\",\n      \\\"MAP i\\xEC\\xED\\xEE\\xEF\",\n      \\\"MAP o\\xF2\\xF3\\xF4\\xF5\\xF6\",\n      \\\"MAP u\\xF9\\xFA\\xFB\\xFC\",\n      \\\"MAP n\\xF1\",\n      \\\"MAP c\\xE7\",\n      \\\"MAP y\\xFF\\xFD\",\n      \\\"MAP s\\xDF\",\n      \\ ]\nlet g:test_data_dic1 = [\n      \\\"123456\",\n      \\\"test/NO\",\n      \\\"# comment\",\n      \\\"wrong\",\n      \\\"Comment\",\n      \\\"OK\",\n      \\\"uk\",\n      \\\"put/ISO\",\n      \\\"the end\",\n      \\\"deol\",\n      \\\"d\\xE9\\xF4r\",\n      \\ ]\nlet g:test_data_aff2 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"FOL  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"LOW  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"UPP  \\xC0\\xC1\\xC2\\xC3\\xC4\\xC5\\xC6\\xC7\\xC8\\xC9\\xCA\\xCB\\xCC\\xCD\\xCE\\xCF\\xD0\\xD1\\xD2\\xD3\\xD4\\xD5\\xD6\\xD8\\xD9\\xDA\\xDB\\xDC\\xDD\\xDE\\xDF\\xFF\",\n      \\\"\",\n      \\\"PFXPOSTPONE\",\n      \\\"\",\n      \\\"MIDWORD\\t'-\",\n      \\\"\",\n      \\\"KEP =\",\n      \\\"RAR ?\",\n      \\\"BAD !\",\n      \\\"\",\n      \\\"PFX I N 1\",\n      \\\"PFX I 0 in .\",\n      \\\"\",\n      \\\"PFX O Y 1\",\n      \\\"PFX O 0 out [a-z]\",\n      \\\"\",\n      \\\"SFX S Y 2\",\n      \\\"SFX S 0 s [^s]\",\n      \\\"SFX S 0 es s\",\n      \\\"\",\n      \\\"SFX N N 3\",\n      \\\"SFX N 0 en [^n]\",\n      \\\"SFX N 0 nen n\",\n      \\\"SFX N 0 n .\",\n      \\\"\",\n      \\\"REP 3\",\n      \\\"REP g ch\",\n      \\\"REP ch g\",\n      \\\"REP svp s.v.p.\",\n      \\\"\",\n      \\\"MAP 9\",\n      \\\"MAP a\\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\",\n      \\\"MAP e\\xE8\\xE9\\xEA\\xEB\",\n      \\\"MAP i\\xEC\\xED\\xEE\\xEF\",\n      \\\"MAP o\\xF2\\xF3\\xF4\\xF5\\xF6\",\n      \\\"MAP u\\xF9\\xFA\\xFB\\xFC\",\n      \\\"MAP n\\xF1\",\n      \\\"MAP c\\xE7\",\n      \\\"MAP y\\xFF\\xFD\",\n      \\\"MAP s\\xDF\",\n      \\ ]\nlet g:test_data_aff3 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"COMPOUNDMIN 3\",\n      \\\"COMPOUNDRULE m*\",\n      \\\"NEEDCOMPOUND x\",\n      \\ ]\nlet g:test_data_dic3 = [\n      \\\"1234\",\n      \\\"foo/m\",\n      \\\"bar/mx\",\n      \\\"m\\xEF/m\",\n      \\\"la/mx\",\n      \\ ]\nlet g:test_data_aff4 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"FOL  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"LOW  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"UPP  \\xC0\\xC1\\xC2\\xC3\\xC4\\xC5\\xC6\\xC7\\xC8\\xC9\\xCA\\xCB\\xCC\\xCD\\xCE\\xCF\\xD0\\xD1\\xD2\\xD3\\xD4\\xD5\\xD6\\xD8\\xD9\\xDA\\xDB\\xDC\\xDD\\xDE\\xDF\\xFF\",\n      \\\"\",\n      \\\"COMPOUNDRULE m+\",\n      \\\"COMPOUNDRULE sm*e\",\n      \\\"COMPOUNDRULE sm+\",\n      \\\"COMPOUNDMIN 3\",\n      \\\"COMPOUNDWORDMAX 3\",\n      \\\"COMPOUNDFORBIDFLAG t\",\n      \\\"\",\n      \\\"COMPOUNDSYLMAX 5\",\n      \\\"SYLLABLE a\\xE1e\\xE9i\\xEDo\\xF3\\xF6\\xF5u\\xFA\\xFC\\xFBy/aa/au/ea/ee/ei/ie/oa/oe/oo/ou/uu/ui\",\n      \\\"\",\n      \\\"MAP 9\",\n      \\\"MAP a\\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\",\n      \\\"MAP e\\xE8\\xE9\\xEA\\xEB\",\n      \\\"MAP i\\xEC\\xED\\xEE\\xEF\",\n      \\\"MAP o\\xF2\\xF3\\xF4\\xF5\\xF6\",\n      \\\"MAP u\\xF9\\xFA\\xFB\\xFC\",\n      \\\"MAP n\\xF1\",\n      \\\"MAP c\\xE7\",\n      \\\"MAP y\\xFF\\xFD\",\n      \\\"MAP s\\xDF\",\n      \\\"\",\n      \\\"NEEDAFFIX x\",\n      \\\"\",\n      \\\"PFXPOSTPONE\",\n      \\\"\",\n      \\\"MIDWORD '-\",\n      \\\"\",\n      \\\"SFX q N 1\",\n      \\\"SFX q   0    -ok .\",\n      \\\"\",\n      \\\"SFX a Y 2\",\n      \\\"SFX a 0 s .\",\n      \\\"SFX a 0 ize/t .\",\n      \\\"\",\n      \\\"PFX p N 1\",\n      \\\"PFX p 0 pre .\",\n      \\\"\",\n      \\\"PFX P N 1\",\n      \\\"PFX P 0 nou .\",\n      \\ ]\nlet g:test_data_dic4 = [\n      \\\"1234\",\n      \\\"word/mP\",\n      \\\"util/am\",\n      \\\"pro/xq\",\n      \\\"tomato/m\",\n      \\\"bork/mp\",\n      \\\"start/s\",\n      \\\"end/e\",\n      \\ ]\nlet g:test_data_aff5 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"FLAG long\",\n      \\\"\",\n      \\\"NEEDAFFIX !!\",\n      \\\"\",\n      \\\"COMPOUNDRULE ssmm*ee\",\n      \\\"\",\n      \\\"NEEDCOMPOUND xx\",\n      \\\"COMPOUNDPERMITFLAG pp\",\n      \\\"\",\n      \\\"SFX 13 Y 1\",\n      \\\"SFX 13 0 bork .\",\n      \\\"\",\n      \\\"SFX a1 Y 1\",\n      \\\"SFX a1 0 a1 .\",\n      \\\"\",\n      \\\"SFX a\\xE9 Y 1\",\n      \\\"SFX a\\xE9 0 a\\xE9 .\",\n      \\\"\",\n      \\\"PFX zz Y 1\",\n      \\\"PFX zz 0 pre/pp .\",\n      \\\"\",\n      \\\"PFX yy Y 1\",\n      \\\"PFX yy 0 nou .\",\n      \\ ]\nlet g:test_data_dic5 = [\n      \\\"1234\",\n      \\\"foo/a1a\\xE9!!\",\n      \\\"bar/zz13ee\",\n      \\\"start/ss\",\n      \\\"end/eeyy\",\n      \\\"middle/mmxx\",\n      \\ ]\nlet g:test_data_aff6 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"FLAG caplong\",\n      \\\"\",\n      \\\"NEEDAFFIX A!\",\n      \\\"\",\n      \\\"COMPOUNDRULE sMm*Ee\",\n      \\\"\",\n      \\\"NEEDCOMPOUND Xx\",\n      \\\"\",\n      \\\"COMPOUNDPERMITFLAG p\",\n      \\\"\",\n      \\\"SFX N3 Y 1\",\n      \\\"SFX N3 0 bork .\",\n      \\\"\",\n      \\\"SFX A1 Y 1\",\n      \\\"SFX A1 0 a1 .\",\n      \\\"\",\n      \\\"SFX A\\xE9 Y 1\",\n      \\\"SFX A\\xE9 0 a\\xE9 .\",\n      \\\"\",\n      \\\"PFX Zz Y 1\",\n      \\\"PFX Zz 0 pre/p .\",\n      \\ ]\nlet g:test_data_dic6 = [\n      \\\"1234\",\n      \\\"mee/A1A\\xE9A!\",\n      \\\"bar/ZzN3Ee\",\n      \\\"lead/s\",\n      \\\"end/Ee\",\n      \\\"middle/MmXx\",\n      \\ ]\nlet g:test_data_aff7 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"FLAG num\",\n      \\\"\",\n      \\\"NEEDAFFIX 9999\",\n      \\\"\",\n      \\\"COMPOUNDRULE 2,77*123\",\n      \\\"\",\n      \\\"NEEDCOMPOUND 1\",\n      \\\"COMPOUNDPERMITFLAG 432\",\n      \\\"\",\n      \\\"SFX 61003 Y 1\",\n      \\\"SFX 61003 0 meat .\",\n      \\\"\",\n      \\\"SFX 0 Y 1\",\n      \\\"SFX 0 0 zero .\",\n      \\\"\",\n      \\\"SFX 391 Y 1\",\n      \\\"SFX 391 0 a1 .\",\n      \\\"\",\n      \\\"SFX 111 Y 1\",\n      \\\"SFX 111 0 a\\xE9 .\",\n      \\\"\",\n      \\\"PFX 17 Y 1\",\n      \\\"PFX 17 0 pre/432 .\",\n      \\ ]\nlet g:test_data_dic7 = [\n      \\\"1234\",\n      \\\"mee/0,391,111,9999\",\n      \\\"bar/17,61003,123\",\n      \\\"lead/2\",\n      \\\"tail/123\",\n      \\\"middle/77,1\",\n      \\ ]\nlet g:test_data_aff8 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"NOSPLITSUGS\",\n      \\ ]\nlet g:test_data_dic8 = [\n      \\\"1234\",\n      \\\"foo\",\n      \\\"bar\",\n      \\\"faabar\",\n      \\ ]\nlet g:test_data_aff9 = [\n      \\ ]\nlet g:test_data_dic9 = [\n      \\\"1234\",\n      \\\"foo\",\n      \\\"bar\",\n      \\ ]\nlet g:test_data_aff10 = [\n      \\\"COMPOUNDRULE se\",\n      \\\"COMPOUNDPERMITFLAG p\",\n      \\\"\",\n      \\\"SFX A Y 1\",\n      \\\"SFX A 0 able/Mp .\",\n      \\\"\",\n      \\\"SFX M Y 1\",\n      \\\"SFX M 0 s .\",\n      \\ ]\nlet g:test_data_dic10 = [\n      \\\"1234\",\n      \\\"drink/As\",\n      \\\"table/e\",\n      \\ ]\nlet g:test_data_aff_sal = [\n      \\\"SET ISO8859-1\",\n      \\\"TRY esianrtolcdugmphbyfvkwjkqxz-\\xEB\\xE9\\xE8\\xEA\\xEF\\xEE\\xE4\\xE0\\xE2\\xF6\\xFC\\xFB'ESIANRTOLCDUGMPHBYFVKWJKQXZ\",\n      \\\"\",\n      \\\"FOL  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"LOW  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"UPP  \\xC0\\xC1\\xC2\\xC3\\xC4\\xC5\\xC6\\xC7\\xC8\\xC9\\xCA\\xCB\\xCC\\xCD\\xCE\\xCF\\xD0\\xD1\\xD2\\xD3\\xD4\\xD5\\xD6\\xD8\\xD9\\xDA\\xDB\\xDC\\xDD\\xDE\\xDF\\xFF\",\n      \\\"\",\n      \\\"MIDWORD\\t'-\",\n      \\\"\",\n      \\\"KEP =\",\n      \\\"RAR ?\",\n      \\\"BAD !\",\n      \\\"\",\n      \\\"PFX I N 1\",\n      \\\"PFX I 0 in .\",\n      \\\"\",\n      \\\"PFX O Y 1\",\n      \\\"PFX O 0 out .\",\n      \\\"\",\n      \\\"SFX S Y 2\",\n      \\\"SFX S 0 s [^s]\",\n      \\\"SFX S 0 es s\",\n      \\\"\",\n      \\\"SFX N N 3\",\n      \\\"SFX N 0 en [^n]\",\n      \\\"SFX N 0 nen n\",\n      \\\"SFX N 0 n .\",\n      \\\"\",\n      \\\"REP 3\",\n      \\\"REP g ch\",\n      \\\"REP ch g\",\n      \\\"REP svp s.v.p.\",\n      \\\"\",\n      \\\"MAP 9\",\n      \\\"MAP a\\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\",\n      \\\"MAP e\\xE8\\xE9\\xEA\\xEB\",\n      \\\"MAP i\\xEC\\xED\\xEE\\xEF\",\n      \\\"MAP o\\xF2\\xF3\\xF4\\xF5\\xF6\",\n      \\\"MAP u\\xF9\\xFA\\xFB\\xFC\",\n      \\\"MAP n\\xF1\",\n      \\\"MAP c\\xE7\",\n      \\\"MAP y\\xFF\\xFD\",\n      \\\"MAP s\\xDF\",\n      \\\"\",\n      \\\"SAL AH(AEIOUY)-^         *H\",\n      \\\"SAL AR(AEIOUY)-^         *R\",\n      \\\"SAL A(HR)^               *\",\n      \\\"SAL A^                   *\",\n      \\\"SAL AH(AEIOUY)-          H\",\n      \\\"SAL AR(AEIOUY)-          R\",\n      \\\"SAL A(HR)                _\",\n      \\\"SAL \\xC0^                   *\",\n      \\\"SAL \\xC5^                   *\",\n      \\\"SAL BB-                  _\",\n      \\\"SAL B                    B\",\n      \\\"SAL CQ-                  _\",\n      \\\"SAL CIA                  X\",\n      \\\"SAL CH                   X\",\n      \\\"SAL C(EIY)-              S\",\n      \\\"SAL CK                   K\",\n      \\\"SAL COUGH^               KF\",\n      \\\"SAL CC<                  C\",\n      \\\"SAL C                    K\",\n      \\\"SAL DG(EIY)              K\",\n      \\\"SAL DD-                  _\",\n      \\\"SAL D                    T\",\n      \\\"SAL \\xC9<                   E\",\n      \\\"SAL EH(AEIOUY)-^         *H\",\n      \\\"SAL ER(AEIOUY)-^         *R\",\n      \\\"SAL E(HR)^               *\",\n      \\\"SAL ENOUGH^$             *NF\",\n      \\\"SAL E^                   *\",\n      \\\"SAL EH(AEIOUY)-          H\",\n      \\\"SAL ER(AEIOUY)-          R\",\n      \\\"SAL E(HR)                _\",\n      \\\"SAL FF-                  _\",\n      \\\"SAL F                    F\",\n      \\\"SAL GN^                  N\",\n      \\\"SAL GN$                  N\",\n      \\\"SAL GNS$                 NS\",\n      \\\"SAL GNED$                N\",\n      \\\"SAL GH(AEIOUY)-          K\",\n      \\\"SAL GH                   _\",\n      \\\"SAL GG9                  K\",\n      \\\"SAL G                    K\",\n      \\\"SAL H                    H\",\n      \\\"SAL IH(AEIOUY)-^         *H\",\n      \\\"SAL IR(AEIOUY)-^         *R\",\n      \\\"SAL I(HR)^               *\",\n      \\\"SAL I^                   *\",\n      \\\"SAL ING6                 N\",\n      \\\"SAL IH(AEIOUY)-          H\",\n      \\\"SAL IR(AEIOUY)-          R\",\n      \\\"SAL I(HR)                _\",\n      \\\"SAL J                    K\",\n      \\\"SAL KN^                  N\",\n      \\\"SAL KK-                  _\",\n      \\\"SAL K                    K\",\n      \\\"SAL LAUGH^               LF\",\n      \\\"SAL LL-                  _\",\n      \\\"SAL L                    L\",\n      \\\"SAL MB$                  M\",\n      \\\"SAL MM                   M\",\n      \\\"SAL M                    M\",\n      \\\"SAL NN-                  _\",\n      \\\"SAL N                    N\",\n      \\\"SAL OH(AEIOUY)-^         *H\",\n      \\\"SAL OR(AEIOUY)-^         *R\",\n      \\\"SAL O(HR)^               *\",\n      \\\"SAL O^                   *\",\n      \\\"SAL OH(AEIOUY)-          H\",\n      \\\"SAL OR(AEIOUY)-          R\",\n      \\\"SAL O(HR)                _\",\n      \\\"SAL PH                   F\",\n      \\\"SAL PN^                  N\",\n      \\\"SAL PP-                  _\",\n      \\\"SAL P                    P\",\n      \\\"SAL Q                    K\",\n      \\\"SAL RH^                  R\",\n      \\\"SAL ROUGH^               RF\",\n      \\\"SAL RR-                  _\",\n      \\\"SAL R                    R\",\n      \\\"SAL SCH(EOU)-            SK\",\n      \\\"SAL SC(IEY)-             S\",\n      \\\"SAL SH                   X\",\n      \\\"SAL SI(AO)-              X\",\n      \\\"SAL SS-                  _\",\n      \\\"SAL S                    S\",\n      \\\"SAL TI(AO)-              X\",\n      \\\"SAL TH                   @\",\n      \\\"SAL TCH--                _\",\n      \\\"SAL TOUGH^               TF\",\n      \\\"SAL TT-                  _\",\n      \\\"SAL T                    T\",\n      \\\"SAL UH(AEIOUY)-^         *H\",\n      \\\"SAL UR(AEIOUY)-^         *R\",\n      \\\"SAL U(HR)^               *\",\n      \\\"SAL U^                   *\",\n      \\\"SAL UH(AEIOUY)-          H\",\n      \\\"SAL UR(AEIOUY)-          R\",\n      \\\"SAL U(HR)                _\",\n      \\\"SAL V^                   W\",\n      \\\"SAL V                    F\",\n      \\\"SAL WR^                  R\",\n      \\\"SAL WH^                  W\",\n      \\\"SAL W(AEIOU)-            W\",\n      \\\"SAL X^                   S\",\n      \\\"SAL X                    KS\",\n      \\\"SAL Y(AEIOU)-            Y\",\n      \\\"SAL ZZ-                  _\",\n      \\\"SAL Z                    S\",\n      \\ ]\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n#ifdef FEAT_CINDENT\n\t\"+cindent\",\n#else\n\t\"-cindent\",\n#endif\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n#ifdef EBCDIC\n\t\"+ebcdic\",\n#else\n\t\"-ebcdic\",\n#endif\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n#ifdef FEAT_LISP\n\t\"+lispindent\",\n#else\n\t\"-lispindent\",\n#endif\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n\t\"+mouse_gpm\",\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n#ifdef FEAT_SMARTINDENT\n\t\"+smartindent\",\n#else\n\t\"-smartindent\",\n#endif\n#ifdef FEAT_SODIUM\n\t\"+sodium\",\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n#ifdef FEAT_TAG_BINS\n\t\"+tag_binary\",\n#else\n\t\"-tag_binary\",\n#endif\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#ifdef MSWIN\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#else\n# ifdef HAVE_XPM\n\t\"+xpm\",\n# else\n\t\"-xpm\",\n# endif\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef USE_XSMP_INTERACT\n\t\"+xsmp_interact\",\n# else\n#  ifdef USE_XSMP\n\t\"+xsmp\",\n#  else\n\t\"-xsmp\",\n#  endif\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    4247,\n/**/\n    4246,\n/**/\n    4245,\n/**/\n    4244,\n/**/\n    4243,\n/**/\n    4242,\n/**/\n    4241,\n/**/\n    4240,\n/**/\n    4239,\n/**/\n    4238,\n/**/\n    4237,\n/**/\n    4236,\n/**/\n    4235,\n/**/\n    4234,\n/**/\n    4233,\n/**/\n    4232,\n/**/\n    4231,\n/**/\n    4230,\n/**/\n    4229,\n/**/\n    4228,\n/**/\n    4227,\n/**/\n    4226,\n/**/\n    4225,\n/**/\n    4224,\n/**/\n    4223,\n/**/\n    4222,\n/**/\n    4221,\n/**/\n    4220,\n/**/\n    4219,\n/**/\n    4218,\n/**/\n    4217,\n/**/\n    4216,\n/**/\n    4215,\n/**/\n    4214,\n/**/\n    4213,\n/**/\n    4212,\n/**/\n    4211,\n/**/\n    4210,\n/**/\n    4209,\n/**/\n    4208,\n/**/\n    4207,\n/**/\n    4206,\n/**/\n    4205,\n/**/\n    4204,\n/**/\n    4203,\n/**/\n    4202,\n/**/\n    4201,\n/**/\n    4200,\n/**/\n    4199,\n/**/\n    4198,\n/**/\n    4197,\n/**/\n    4196,\n/**/\n    4195,\n/**/\n    4194,\n/**/\n    4193,\n/**/\n    4192,\n/**/\n    4191,\n/**/\n    4190,\n/**/\n    4189,\n/**/\n    4188,\n/**/\n    4187,\n/**/\n    4186,\n/**/\n    4185,\n/**/\n    4184,\n/**/\n    4183,\n/**/\n    4182,\n/**/\n    4181,\n/**/\n    4180,\n/**/\n    4179,\n/**/\n    4178,\n/**/\n    4177,\n/**/\n    4176,\n/**/\n    4175,\n/**/\n    4174,\n/**/\n    4173,\n/**/\n    4172,\n/**/\n    4171,\n/**/\n    4170,\n/**/\n    4169,\n/**/\n    4168,\n/**/\n    4167,\n/**/\n    4166,\n/**/\n    4165,\n/**/\n    4164,\n/**/\n    4163,\n/**/\n    4162,\n/**/\n    4161,\n/**/\n    4160,\n/**/\n    4159,\n/**/\n    4158,\n/**/\n    4157,\n/**/\n    4156,\n/**/\n    4155,\n/**/\n    4154,\n/**/\n    4153,\n/**/\n    4152,\n/**/\n    4151,\n/**/\n    4150,\n/**/\n    4149,\n/**/\n    4148,\n/**/\n    4147,\n/**/\n    4146,\n/**/\n    4145,\n/**/\n    4144,\n/**/\n    4143,\n/**/\n    4142,\n/**/\n    4141,\n/**/\n    4140,\n/**/\n    4139,\n/**/\n    4138,\n/**/\n    4137,\n/**/\n    4136,\n/**/\n    4135,\n/**/\n    4134,\n/**/\n    4133,\n/**/\n    4132,\n/**/\n    4131,\n/**/\n    4130,\n/**/\n    4129,\n/**/\n    4128,\n/**/\n    4127,\n/**/\n    4126,\n/**/\n    4125,\n/**/\n    4124,\n/**/\n    4123,\n/**/\n    4122,\n/**/\n    4121,\n/**/\n    4120,\n/**/\n    4119,\n/**/\n    4118,\n/**/\n    4117,\n/**/\n    4116,\n/**/\n    4115,\n/**/\n    4114,\n/**/\n    4113,\n/**/\n    4112,\n/**/\n    4111,\n/**/\n    4110,\n/**/\n    4109,\n/**/\n    4108,\n/**/\n    4107,\n/**/\n    4106,\n/**/\n    4105,\n/**/\n    4104,\n/**/\n    4103,\n/**/\n    4102,\n/**/\n    4101,\n/**/\n    4100,\n/**/\n    4099,\n/**/\n    4098,\n/**/\n    4097,\n/**/\n    4096,\n/**/\n    4095,\n/**/\n    4094,\n/**/\n    4093,\n/**/\n    4092,\n/**/\n    4091,\n/**/\n    4090,\n/**/\n    4089,\n/**/\n    4088,\n/**/\n    4087,\n/**/\n    4086,\n/**/\n    4085,\n/**/\n    4084,\n/**/\n    4083,\n/**/\n    4082,\n/**/\n    4081,\n/**/\n    4080,\n/**/\n    4079,\n/**/\n    4078,\n/**/\n    4077,\n/**/\n    4076,\n/**/\n    4075,\n/**/\n    4074,\n/**/\n    4073,\n/**/\n    4072,\n/**/\n    4071,\n/**/\n    4070,\n/**/\n    4069,\n/**/\n    4068,\n/**/\n    4067,\n/**/\n    4066,\n/**/\n    4065,\n/**/\n    4064,\n/**/\n    4063,\n/**/\n    4062,\n/**/\n    4061,\n/**/\n    4060,\n/**/\n    4059,\n/**/\n    4058,\n/**/\n    4057,\n/**/\n    4056,\n/**/\n    4055,\n/**/\n    4054,\n/**/\n    4053,\n/**/\n    4052,\n/**/\n    4051,\n/**/\n    4050,\n/**/\n    4049,\n/**/\n    4048,\n/**/\n    4047,\n/**/\n    4046,\n/**/\n    4045,\n/**/\n    4044,\n/**/\n    4043,\n/**/\n    4042,\n/**/\n    4041,\n/**/\n    4040,\n/**/\n    4039,\n/**/\n    4038,\n/**/\n    4037,\n/**/\n    4036,\n/**/\n    4035,\n/**/\n    4034,\n/**/\n    4033,\n/**/\n    4032,\n/**/\n    4031,\n/**/\n    4030,\n/**/\n    4029,\n/**/\n    4028,\n/**/\n    4027,\n/**/\n    4026,\n/**/\n    4025,\n/**/\n    4024,\n/**/\n    4023,\n/**/\n    4022,\n/**/\n    4021,\n/**/\n    4020,\n/**/\n    4019,\n/**/\n    4018,\n/**/\n    4017,\n/**/\n    4016,\n/**/\n    4015,\n/**/\n    4014,\n/**/\n    4013,\n/**/\n    4012,\n/**/\n    4011,\n/**/\n    4010,\n/**/\n    4009,\n/**/\n    4008,\n/**/\n    4007,\n/**/\n    4006,\n/**/\n    4005,\n/**/\n    4004,\n/**/\n    4003,\n/**/\n    4002,\n/**/\n    4001,\n/**/\n    4000,\n/**/\n    3999,\n/**/\n    3998,\n/**/\n    3997,\n/**/\n    3996,\n/**/\n    3995,\n/**/\n    3994,\n/**/\n    3993,\n/**/\n    3992,\n/**/\n    3991,\n/**/\n    3990,\n/**/\n    3989,\n/**/\n    3988,\n/**/\n    3987,\n/**/\n    3986,\n/**/\n    3985,\n/**/\n    3984,\n/**/\n    3983,\n/**/\n    3982,\n/**/\n    3981,\n/**/\n    3980,\n/**/\n    3979,\n/**/\n    3978,\n/**/\n    3977,\n/**/\n    3976,\n/**/\n    3975,\n/**/\n    3974,\n/**/\n    3973,\n/**/\n    3972,\n/**/\n    3971,\n/**/\n    3970,\n/**/\n    3969,\n/**/\n    3968,\n/**/\n    3967,\n/**/\n    3966,\n/**/\n    3965,\n/**/\n    3964,\n/**/\n    3963,\n/**/\n    3962,\n/**/\n    3961,\n/**/\n    3960,\n/**/\n    3959,\n/**/\n    3958,\n/**/\n    3957,\n/**/\n    3956,\n/**/\n    3955,\n/**/\n    3954,\n/**/\n    3953,\n/**/\n    3952,\n/**/\n    3951,\n/**/\n    3950,\n/**/\n    3949,\n/**/\n    3948,\n/**/\n    3947,\n/**/\n    3946,\n/**/\n    3945,\n/**/\n    3944,\n/**/\n    3943,\n/**/\n    3942,\n/**/\n    3941,\n/**/\n    3940,\n/**/\n    3939,\n/**/\n    3938,\n/**/\n    3937,\n/**/\n    3936,\n/**/\n    3935,\n/**/\n    3934,\n/**/\n    3933,\n/**/\n    3932,\n/**/\n    3931,\n/**/\n    3930,\n/**/\n    3929,\n/**/\n    3928,\n/**/\n    3927,\n/**/\n    3926,\n/**/\n    3925,\n/**/\n    3924,\n/**/\n    3923,\n/**/\n    3922,\n/**/\n    3921,\n/**/\n    3920,\n/**/\n    3919,\n/**/\n    3918,\n/**/\n    3917,\n/**/\n    3916,\n/**/\n    3915,\n/**/\n    3914,\n/**/\n    3913,\n/**/\n    3912,\n/**/\n    3911,\n/**/\n    3910,\n/**/\n    3909,\n/**/\n    3908,\n/**/\n    3907,\n/**/\n    3906,\n/**/\n    3905,\n/**/\n    3904,\n/**/\n    3903,\n/**/\n    3902,\n/**/\n    3901,\n/**/\n    3900,\n/**/\n    3899,\n/**/\n    3898,\n/**/\n    3897,\n/**/\n    3896,\n/**/\n    3895,\n/**/\n    3894,\n/**/\n    3893,\n/**/\n    3892,\n/**/\n    3891,\n/**/\n    3890,\n/**/\n    3889,\n/**/\n    3888,\n/**/\n    3887,\n/**/\n    3886,\n/**/\n    3885,\n/**/\n    3884,\n/**/\n    3883,\n/**/\n    3882,\n/**/\n    3881,\n/**/\n    3880,\n/**/\n    3879,\n/**/\n    3878,\n/**/\n    3877,\n/**/\n    3876,\n/**/\n    3875,\n/**/\n    3874,\n/**/\n    3873,\n/**/\n    3872,\n/**/\n    3871,\n/**/\n    3870,\n/**/\n    3869,\n/**/\n    3868,\n/**/\n    3867,\n/**/\n    3866,\n/**/\n    3865,\n/**/\n    3864,\n/**/\n    3863,\n/**/\n    3862,\n/**/\n    3861,\n/**/\n    3860,\n/**/\n    3859,\n/**/\n    3858,\n/**/\n    3857,\n/**/\n    3856,\n/**/\n    3855,\n/**/\n    3854,\n/**/\n    3853,\n/**/\n    3852,\n/**/\n    3851,\n/**/\n    3850,\n/**/\n    3849,\n/**/\n    3848,\n/**/\n    3847,\n/**/\n    3846,\n/**/\n    3845,\n/**/\n    3844,\n/**/\n    3843,\n/**/\n    3842,\n/**/\n    3841,\n/**/\n    3840,\n/**/\n    3839,\n/**/\n    3838,\n/**/\n    3837,\n/**/\n    3836,\n/**/\n    3835,\n/**/\n    3834,\n/**/\n    3833,\n/**/\n    3832,\n/**/\n    3831,\n/**/\n    3830,\n/**/\n    3829,\n/**/\n    3828,\n/**/\n    3827,\n/**/\n    3826,\n/**/\n    3825,\n/**/\n    3824,\n/**/\n    3823,\n/**/\n    3822,\n/**/\n    3821,\n/**/\n    3820,\n/**/\n    3819,\n/**/\n    3818,\n/**/\n    3817,\n/**/\n    3816,\n/**/\n    3815,\n/**/\n    3814,\n/**/\n    3813,\n/**/\n    3812,\n/**/\n    3811,\n/**/\n    3810,\n/**/\n    3809,\n/**/\n    3808,\n/**/\n    3807,\n/**/\n    3806,\n/**/\n    3805,\n/**/\n    3804,\n/**/\n    3803,\n/**/\n    3802,\n/**/\n    3801,\n/**/\n    3800,\n/**/\n    3799,\n/**/\n    3798,\n/**/\n    3797,\n/**/\n    3796,\n/**/\n    3795,\n/**/\n    3794,\n/**/\n    3793,\n/**/\n    3792,\n/**/\n    3791,\n/**/\n    3790,\n/**/\n    3789,\n/**/\n    3788,\n/**/\n    3787,\n/**/\n    3786,\n/**/\n    3785,\n/**/\n    3784,\n/**/\n    3783,\n/**/\n    3782,\n/**/\n    3781,\n/**/\n    3780,\n/**/\n    3779,\n/**/\n    3778,\n/**/\n    3777,\n/**/\n    3776,\n/**/\n    3775,\n/**/\n    3774,\n/**/\n    3773,\n/**/\n    3772,\n/**/\n    3771,\n/**/\n    3770,\n/**/\n    3769,\n/**/\n    3768,\n/**/\n    3767,\n/**/\n    3766,\n/**/\n    3765,\n/**/\n    3764,\n/**/\n    3763,\n/**/\n    3762,\n/**/\n    3761,\n/**/\n    3760,\n/**/\n    3759,\n/**/\n    3758,\n/**/\n    3757,\n/**/\n    3756,\n/**/\n    3755,\n/**/\n    3754,\n/**/\n    3753,\n/**/\n    3752,\n/**/\n    3751,\n/**/\n    3750,\n/**/\n    3749,\n/**/\n    3748,\n/**/\n    3747,\n/**/\n    3746,\n/**/\n    3745,\n/**/\n    3744,\n/**/\n    3743,\n/**/\n    3742,\n/**/\n    3741,\n/**/\n    3740,\n/**/\n    3739,\n/**/\n    3738,\n/**/\n    3737,\n/**/\n    3736,\n/**/\n    3735,\n/**/\n    3734,\n/**/\n    3733,\n/**/\n    3732,\n/**/\n    3731,\n/**/\n    3730,\n/**/\n    3729,\n/**/\n    3728,\n/**/\n    3727,\n/**/\n    3726,\n/**/\n    3725,\n/**/\n    3724,\n/**/\n    3723,\n/**/\n    3722,\n/**/\n    3721,\n/**/\n    3720,\n/**/\n    3719,\n/**/\n    3718,\n/**/\n    3717,\n/**/\n    3716,\n/**/\n    3715,\n/**/\n    3714,\n/**/\n    3713,\n/**/\n    3712,\n/**/\n    3711,\n/**/\n    3710,\n/**/\n    3709,\n/**/\n    3708,\n/**/\n    3707,\n/**/\n    3706,\n/**/\n    3705,\n/**/\n    3704,\n/**/\n    3703,\n/**/\n    3702,\n/**/\n    3701,\n/**/\n    3700,\n/**/\n    3699,\n/**/\n    3698,\n/**/\n    3697,\n/**/\n    3696,\n/**/\n    3695,\n/**/\n    3694,\n/**/\n    3693,\n/**/\n    3692,\n/**/\n    3691,\n/**/\n    3690,\n/**/\n    3689,\n/**/\n    3688,\n/**/\n    3687,\n/**/\n    3686,\n/**/\n    3685,\n/**/\n    3684,\n/**/\n    3683,\n/**/\n    3682,\n/**/\n    3681,\n/**/\n    3680,\n/**/\n    3679,\n/**/\n    3678,\n/**/\n    3677,\n/**/\n    3676,\n/**/\n    3675,\n/**/\n    3674,\n/**/\n    3673,\n/**/\n    3672,\n/**/\n    3671,\n/**/\n    3670,\n/**/\n    3669,\n/**/\n    3668,\n/**/\n    3667,\n/**/\n    3666,\n/**/\n    3665,\n/**/\n    3664,\n/**/\n    3663,\n/**/\n    3662,\n/**/\n    3661,\n/**/\n    3660,\n/**/\n    3659,\n/**/\n    3658,\n/**/\n    3657,\n/**/\n    3656,\n/**/\n    3655,\n/**/\n    3654,\n/**/\n    3653,\n/**/\n    3652,\n/**/\n    3651,\n/**/\n    3650,\n/**/\n    3649,\n/**/\n    3648,\n/**/\n    3647,\n/**/\n    3646,\n/**/\n    3645,\n/**/\n    3644,\n/**/\n    3643,\n/**/\n    3642,\n/**/\n    3641,\n/**/\n    3640,\n/**/\n    3639,\n/**/\n    3638,\n/**/\n    3637,\n/**/\n    3636,\n/**/\n    3635,\n/**/\n    3634,\n/**/\n    3633,\n/**/\n    3632,\n/**/\n    3631,\n/**/\n    3630,\n/**/\n    3629,\n/**/\n    3628,\n/**/\n    3627,\n/**/\n    3626,\n/**/\n    3625,\n/**/\n    3624,\n/**/\n    3623,\n/**/\n    3622,\n/**/\n    3621,\n/**/\n    3620,\n/**/\n    3619,\n/**/\n    3618,\n/**/\n    3617,\n/**/\n    3616,\n/**/\n    3615,\n/**/\n    3614,\n/**/\n    3613,\n/**/\n    3612,\n/**/\n    3611,\n/**/\n    3610,\n/**/\n    3609,\n/**/\n    3608,\n/**/\n    3607,\n/**/\n    3606,\n/**/\n    3605,\n/**/\n    3604,\n/**/\n    3603,\n/**/\n    3602,\n/**/\n    3601,\n/**/\n    3600,\n/**/\n    3599,\n/**/\n    3598,\n/**/\n    3597,\n/**/\n    3596,\n/**/\n    3595,\n/**/\n    3594,\n/**/\n    3593,\n/**/\n    3592,\n/**/\n    3591,\n/**/\n    3590,\n/**/\n    3589,\n/**/\n    3588,\n/**/\n    3587,\n/**/\n    3586,\n/**/\n    3585,\n/**/\n    3584,\n/**/\n    3583,\n/**/\n    3582,\n/**/\n    3581,\n/**/\n    3580,\n/**/\n    3579,\n/**/\n    3578,\n/**/\n    3577,\n/**/\n    3576,\n/**/\n    3575,\n/**/\n    3574,\n/**/\n    3573,\n/**/\n    3572,\n/**/\n    3571,\n/**/\n    3570,\n/**/\n    3569,\n/**/\n    3568,\n/**/\n    3567,\n/**/\n    3566,\n/**/\n    3565,\n/**/\n    3564,\n/**/\n    3563,\n/**/\n    3562,\n/**/\n    3561,\n/**/\n    3560,\n/**/\n    3559,\n/**/\n    3558,\n/**/\n    3557,\n/**/\n    3556,\n/**/\n    3555,\n/**/\n    3554,\n/**/\n    3553,\n/**/\n    3552,\n/**/\n    3551,\n/**/\n    3550,\n/**/\n    3549,\n/**/\n    3548,\n/**/\n    3547,\n/**/\n    3546,\n/**/\n    3545,\n/**/\n    3544,\n/**/\n    3543,\n/**/\n    3542,\n/**/\n    3541,\n/**/\n    3540,\n/**/\n    3539,\n/**/\n    3538,\n/**/\n    3537,\n/**/\n    3536,\n/**/\n    3535,\n/**/\n    3534,\n/**/\n    3533,\n/**/\n    3532,\n/**/\n    3531,\n/**/\n    3530,\n/**/\n    3529,\n/**/\n    3528,\n/**/\n    3527,\n/**/\n    3526,\n/**/\n    3525,\n/**/\n    3524,\n/**/\n    3523,\n/**/\n    3522,\n/**/\n    3521,\n/**/\n    3520,\n/**/\n    3519,\n/**/\n    3518,\n/**/\n    3517,\n/**/\n    3516,\n/**/\n    3515,\n/**/\n    3514,\n/**/\n    3513,\n/**/\n    3512,\n/**/\n    3511,\n/**/\n    3510,\n/**/\n    3509,\n/**/\n    3508,\n/**/\n    3507,\n/**/\n    3506,\n/**/\n    3505,\n/**/\n    3504,\n/**/\n    3503,\n/**/\n    3502,\n/**/\n    3501,\n/**/\n    3500,\n/**/\n    3499,\n/**/\n    3498,\n/**/\n    3497,\n/**/\n    3496,\n/**/\n    3495,\n/**/\n    3494,\n/**/\n    3493,\n/**/\n    3492,\n/**/\n    3491,\n/**/\n    3490,\n/**/\n    3489,\n/**/\n    3488,\n/**/\n    3487,\n/**/\n    3486,\n/**/\n    3485,\n/**/\n    3484,\n/**/\n    3483,\n/**/\n    3482,\n/**/\n    3481,\n/**/\n    3480,\n/**/\n    3479,\n/**/\n    3478,\n/**/\n    3477,\n/**/\n    3476,\n/**/\n    3475,\n/**/\n    3474,\n/**/\n    3473,\n/**/\n    3472,\n/**/\n    3471,\n/**/\n    3470,\n/**/\n    3469,\n/**/\n    3468,\n/**/\n    3467,\n/**/\n    3466,\n/**/\n    3465,\n/**/\n    3464,\n/**/\n    3463,\n/**/\n    3462,\n/**/\n    3461,\n/**/\n    3460,\n/**/\n    3459,\n/**/\n    3458,\n/**/\n    3457,\n/**/\n    3456,\n/**/\n    3455,\n/**/\n    3454,\n/**/\n    3453,\n/**/\n    3452,\n/**/\n    3451,\n/**/\n    3450,\n/**/\n    3449,\n/**/\n    3448,\n/**/\n    3447,\n/**/\n    3446,\n/**/\n    3445,\n/**/\n    3444,\n/**/\n    3443,\n/**/\n    3442,\n/**/\n    3441,\n/**/\n    3440,\n/**/\n    3439,\n/**/\n    3438,\n/**/\n    3437,\n/**/\n    3436,\n/**/\n    3435,\n/**/\n    3434,\n/**/\n    3433,\n/**/\n    3432,\n/**/\n    3431,\n/**/\n    3430,\n/**/\n    3429,\n/**/\n    3428,\n/**/\n    3427,\n/**/\n    3426,\n/**/\n    3425,\n/**/\n    3424,\n/**/\n    3423,\n/**/\n    3422,\n/**/\n    3421,\n/**/\n    3420,\n/**/\n    3419,\n/**/\n    3418,\n/**/\n    3417,\n/**/\n    3416,\n/**/\n    3415,\n/**/\n    3414,\n/**/\n    3413,\n/**/\n    3412,\n/**/\n    3411,\n/**/\n    3410,\n/**/\n    3409,\n/**/\n    3408,\n/**/\n    3407,\n/**/\n    3406,\n/**/\n    3405,\n/**/\n    3404,\n/**/\n    3403,\n/**/\n    3402,\n/**/\n    3401,\n/**/\n    3400,\n/**/\n    3399,\n/**/\n    3398,\n/**/\n    3397,\n/**/\n    3396,\n/**/\n    3395,\n/**/\n    3394,\n/**/\n    3393,\n/**/\n    3392,\n/**/\n    3391,\n/**/\n    3390,\n/**/\n    3389,\n/**/\n    3388,\n/**/\n    3387,\n/**/\n    3386,\n/**/\n    3385,\n/**/\n    3384,\n/**/\n    3383,\n/**/\n    3382,\n/**/\n    3381,\n/**/\n    3380,\n/**/\n    3379,\n/**/\n    3378,\n/**/\n    3377,\n/**/\n    3376,\n/**/\n    3375,\n/**/\n    3374,\n/**/\n    3373,\n/**/\n    3372,\n/**/\n    3371,\n/**/\n    3370,\n/**/\n    3369,\n/**/\n    3368,\n/**/\n    3367,\n/**/\n    3366,\n/**/\n    3365,\n/**/\n    3364,\n/**/\n    3363,\n/**/\n    3362,\n/**/\n    3361,\n/**/\n    3360,\n/**/\n    3359,\n/**/\n    3358,\n/**/\n    3357,\n/**/\n    3356,\n/**/\n    3355,\n/**/\n    3354,\n/**/\n    3353,\n/**/\n    3352,\n/**/\n    3351,\n/**/\n    3350,\n/**/\n    3349,\n/**/\n    3348,\n/**/\n    3347,\n/**/\n    3346,\n/**/\n    3345,\n/**/\n    3344,\n/**/\n    3343,\n/**/\n    3342,\n/**/\n    3341,\n/**/\n    3340,\n/**/\n    3339,\n/**/\n    3338,\n/**/\n    3337,\n/**/\n    3336,\n/**/\n    3335,\n/**/\n    3334,\n/**/\n    3333,\n/**/\n    3332,\n/**/\n    3331,\n/**/\n    3330,\n/**/\n    3329,\n/**/\n    3328,\n/**/\n    3327,\n/**/\n    3326,\n/**/\n    3325,\n/**/\n    3324,\n/**/\n    3323,\n/**/\n    3322,\n/**/\n    3321,\n/**/\n    3320,\n/**/\n    3319,\n/**/\n    3318,\n/**/\n    3317,\n/**/\n    3316,\n/**/\n    3315,\n/**/\n    3314,\n/**/\n    3313,\n/**/\n    3312,\n/**/\n    3311,\n/**/\n    3310,\n/**/\n    3309,\n/**/\n    3308,\n/**/\n    3307,\n/**/\n    3306,\n/**/\n    3305,\n/**/\n    3304,\n/**/\n    3303,\n/**/\n    3302,\n/**/\n    3301,\n/**/\n    3300,\n/**/\n    3299,\n/**/\n    3298,\n/**/\n    3297,\n/**/\n    3296,\n/**/\n    3295,\n/**/\n    3294,\n/**/\n    3293,\n/**/\n    3292,\n/**/\n    3291,\n/**/\n    3290,\n/**/\n    3289,\n/**/\n    3288,\n/**/\n    3287,\n/**/\n    3286,\n/**/\n    3285,\n/**/\n    3284,\n/**/\n    3283,\n/**/\n    3282,\n/**/\n    3281,\n/**/\n    3280,\n/**/\n    3279,\n/**/\n    3278,\n/**/\n    3277,\n/**/\n    3276,\n/**/\n    3275,\n/**/\n    3274,\n/**/\n    3273,\n/**/\n    3272,\n/**/\n    3271,\n/**/\n    3270,\n/**/\n    3269,\n/**/\n    3268,\n/**/\n    3267,\n/**/\n    3266,\n/**/\n    3265,\n/**/\n    3264,\n/**/\n    3263,\n/**/\n    3262,\n/**/\n    3261,\n/**/\n    3260,\n/**/\n    3259,\n/**/\n    3258,\n/**/\n    3257,\n/**/\n    3256,\n/**/\n    3255,\n/**/\n    3254,\n/**/\n    3253,\n/**/\n    3252,\n/**/\n    3251,\n/**/\n    3250,\n/**/\n    3249,\n/**/\n    3248,\n/**/\n    3247,\n/**/\n    3246,\n/**/\n    3245,\n/**/\n    3244,\n/**/\n    3243,\n/**/\n    3242,\n/**/\n    3241,\n/**/\n    3240,\n/**/\n    3239,\n/**/\n    3238,\n/**/\n    3237,\n/**/\n    3236,\n/**/\n    3235,\n/**/\n    3234,\n/**/\n    3233,\n/**/\n    3232,\n/**/\n    3231,\n/**/\n    3230,\n/**/\n    3229,\n/**/\n    3228,\n/**/\n    3227,\n/**/\n    3226,\n/**/\n    3225,\n/**/\n    3224,\n/**/\n    3223,\n/**/\n    3222,\n/**/\n    3221,\n/**/\n    3220,\n/**/\n    3219,\n/**/\n    3218,\n/**/\n    3217,\n/**/\n    3216,\n/**/\n    3215,\n/**/\n    3214,\n/**/\n    3213,\n/**/\n    3212,\n/**/\n    3211,\n/**/\n    3210,\n/**/\n    3209,\n/**/\n    3208,\n/**/\n    3207,\n/**/\n    3206,\n/**/\n    3205,\n/**/\n    3204,\n/**/\n    3203,\n/**/\n    3202,\n/**/\n    3201,\n/**/\n    3200,\n/**/\n    3199,\n/**/\n    3198,\n/**/\n    3197,\n/**/\n    3196,\n/**/\n    3195,\n/**/\n    3194,\n/**/\n    3193,\n/**/\n    3192,\n/**/\n    3191,\n/**/\n    3190,\n/**/\n    3189,\n/**/\n    3188,\n/**/\n    3187,\n/**/\n    3186,\n/**/\n    3185,\n/**/\n    3184,\n/**/\n    3183,\n/**/\n    3182,\n/**/\n    3181,\n/**/\n    3180,\n/**/\n    3179,\n/**/\n    3178,\n/**/\n    3177,\n/**/\n    3176,\n/**/\n    3175,\n/**/\n    3174,\n/**/\n    3173,\n/**/\n    3172,\n/**/\n    3171,\n/**/\n    3170,\n/**/\n    3169,\n/**/\n    3168,\n/**/\n    3167,\n/**/\n    3166,\n/**/\n    3165,\n/**/\n    3164,\n/**/\n    3163,\n/**/\n    3162,\n/**/\n    3161,\n/**/\n    3160,\n/**/\n    3159,\n/**/\n    3158,\n/**/\n    3157,\n/**/\n    3156,\n/**/\n    3155,\n/**/\n    3154,\n/**/\n    3153,\n/**/\n    3152,\n/**/\n    3151,\n/**/\n    3150,\n/**/\n    3149,\n/**/\n    3148,\n/**/\n    3147,\n/**/\n    3146,\n/**/\n    3145,\n/**/\n    3144,\n/**/\n    3143,\n/**/\n    3142,\n/**/\n    3141,\n/**/\n    3140,\n/**/\n    3139,\n/**/\n    3138,\n/**/\n    3137,\n/**/\n    3136,\n/**/\n    3135,\n/**/\n    3134,\n/**/\n    3133,\n/**/\n    3132,\n/**/\n    3131,\n/**/\n    3130,\n/**/\n    3129,\n/**/\n    3128,\n/**/\n    3127,\n/**/\n    3126,\n/**/\n    3125,\n/**/\n    3124,\n/**/\n    3123,\n/**/\n    3122,\n/**/\n    3121,\n/**/\n    3120,\n/**/\n    3119,\n/**/\n    3118,\n/**/\n    3117,\n/**/\n    3116,\n/**/\n    3115,\n/**/\n    3114,\n/**/\n    3113,\n/**/\n    3112,\n/**/\n    3111,\n/**/\n    3110,\n/**/\n    3109,\n/**/\n    3108,\n/**/\n    3107,\n/**/\n    3106,\n/**/\n    3105,\n/**/\n    3104,\n/**/\n    3103,\n/**/\n    3102,\n/**/\n    3101,\n/**/\n    3100,\n/**/\n    3099,\n/**/\n    3098,\n/**/\n    3097,\n/**/\n    3096,\n/**/\n    3095,\n/**/\n    3094,\n/**/\n    3093,\n/**/\n    3092,\n/**/\n    3091,\n/**/\n    3090,\n/**/\n    3089,\n/**/\n    3088,\n/**/\n    3087,\n/**/\n    3086,\n/**/\n    3085,\n/**/\n    3084,\n/**/\n    3083,\n/**/\n    3082,\n/**/\n    3081,\n/**/\n    3080,\n/**/\n    3079,\n/**/\n    3078,\n/**/\n    3077,\n/**/\n    3076,\n/**/\n    3075,\n/**/\n    3074,\n/**/\n    3073,\n/**/\n    3072,\n/**/\n    3071,\n/**/\n    3070,\n/**/\n    3069,\n/**/\n    3068,\n/**/\n    3067,\n/**/\n    3066,\n/**/\n    3065,\n/**/\n    3064,\n/**/\n    3063,\n/**/\n    3062,\n/**/\n    3061,\n/**/\n    3060,\n/**/\n    3059,\n/**/\n    3058,\n/**/\n    3057,\n/**/\n    3056,\n/**/\n    3055,\n/**/\n    3054,\n/**/\n    3053,\n/**/\n    3052,\n/**/\n    3051,\n/**/\n    3050,\n/**/\n    3049,\n/**/\n    3048,\n/**/\n    3047,\n/**/\n    3046,\n/**/\n    3045,\n/**/\n    3044,\n/**/\n    3043,\n/**/\n    3042,\n/**/\n    3041,\n/**/\n    3040,\n/**/\n    3039,\n/**/\n    3038,\n/**/\n    3037,\n/**/\n    3036,\n/**/\n    3035,\n/**/\n    3034,\n/**/\n    3033,\n/**/\n    3032,\n/**/\n    3031,\n/**/\n    3030,\n/**/\n    3029,\n/**/\n    3028,\n/**/\n    3027,\n/**/\n    3026,\n/**/\n    3025,\n/**/\n    3024,\n/**/\n    3023,\n/**/\n    3022,\n/**/\n    3021,\n/**/\n    3020,\n/**/\n    3019,\n/**/\n    3018,\n/**/\n    3017,\n/**/\n    3016,\n/**/\n    3015,\n/**/\n    3014,\n/**/\n    3013,\n/**/\n    3012,\n/**/\n    3011,\n/**/\n    3010,\n/**/\n    3009,\n/**/\n    3008,\n/**/\n    3007,\n/**/\n    3006,\n/**/\n    3005,\n/**/\n    3004,\n/**/\n    3003,\n/**/\n    3002,\n/**/\n    3001,\n/**/\n    3000,\n/**/\n    2999,\n/**/\n    2998,\n/**/\n    2997,\n/**/\n    2996,\n/**/\n    2995,\n/**/\n    2994,\n/**/\n    2993,\n/**/\n    2992,\n/**/\n    2991,\n/**/\n    2990,\n/**/\n    2989,\n/**/\n    2988,\n/**/\n    2987,\n/**/\n    2986,\n/**/\n    2985,\n/**/\n    2984,\n/**/\n    2983,\n/**/\n    2982,\n/**/\n    2981,\n/**/\n    2980,\n/**/\n    2979,\n/**/\n    2978,\n/**/\n    2977,\n/**/\n    2976,\n/**/\n    2975,\n/**/\n    2974,\n/**/\n    2973,\n/**/\n    2972,\n/**/\n    2971,\n/**/\n    2970,\n/**/\n    2969,\n/**/\n    2968,\n/**/\n    2967,\n/**/\n    2966,\n/**/\n    2965,\n/**/\n    2964,\n/**/\n    2963,\n/**/\n    2962,\n/**/\n    2961,\n/**/\n    2960,\n/**/\n    2959,\n/**/\n    2958,\n/**/\n    2957,\n/**/\n    2956,\n/**/\n    2955,\n/**/\n    2954,\n/**/\n    2953,\n/**/\n    2952,\n/**/\n    2951,\n/**/\n    2950,\n/**/\n    2949,\n/**/\n    2948,\n/**/\n    2947,\n/**/\n    2946,\n/**/\n    2945,\n/**/\n    2944,\n/**/\n    2943,\n/**/\n    2942,\n/**/\n    2941,\n/**/\n    2940,\n/**/\n    2939,\n/**/\n    2938,\n/**/\n    2937,\n/**/\n    2936,\n/**/\n    2935,\n/**/\n    2934,\n/**/\n    2933,\n/**/\n    2932,\n/**/\n    2931,\n/**/\n    2930,\n/**/\n    2929,\n/**/\n    2928,\n/**/\n    2927,\n/**/\n    2926,\n/**/\n    2925,\n/**/\n    2924,\n/**/\n    2923,\n/**/\n    2922,\n/**/\n    2921,\n/**/\n    2920,\n/**/\n    2919,\n/**/\n    2918,\n/**/\n    2917,\n/**/\n    2916,\n/**/\n    2915,\n/**/\n    2914,\n/**/\n    2913,\n/**/\n    2912,\n/**/\n    2911,\n/**/\n    2910,\n/**/\n    2909,\n/**/\n    2908,\n/**/\n    2907,\n/**/\n    2906,\n/**/\n    2905,\n/**/\n    2904,\n/**/\n    2903,\n/**/\n    2902,\n/**/\n    2901,\n/**/\n    2900,\n/**/\n    2899,\n/**/\n    2898,\n/**/\n    2897,\n/**/\n    2896,\n/**/\n    2895,\n/**/\n    2894,\n/**/\n    2893,\n/**/\n    2892,\n/**/\n    2891,\n/**/\n    2890,\n/**/\n    2889,\n/**/\n    2888,\n/**/\n    2887,\n/**/\n    2886,\n/**/\n    2885,\n/**/\n    2884,\n/**/\n    2883,\n/**/\n    2882,\n/**/\n    2881,\n/**/\n    2880,\n/**/\n    2879,\n/**/\n    2878,\n/**/\n    2877,\n/**/\n    2876,\n/**/\n    2875,\n/**/\n    2874,\n/**/\n    2873,\n/**/\n    2872,\n/**/\n    2871,\n/**/\n    2870,\n/**/\n    2869,\n/**/\n    2868,\n/**/\n    2867,\n/**/\n    2866,\n/**/\n    2865,\n/**/\n    2864,\n/**/\n    2863,\n/**/\n    2862,\n/**/\n    2861,\n/**/\n    2860,\n/**/\n    2859,\n/**/\n    2858,\n/**/\n    2857,\n/**/\n    2856,\n/**/\n    2855,\n/**/\n    2854,\n/**/\n    2853,\n/**/\n    2852,\n/**/\n    2851,\n/**/\n    2850,\n/**/\n    2849,\n/**/\n    2848,\n/**/\n    2847,\n/**/\n    2846,\n/**/\n    2845,\n/**/\n    2844,\n/**/\n    2843,\n/**/\n    2842,\n/**/\n    2841,\n/**/\n    2840,\n/**/\n    2839,\n/**/\n    2838,\n/**/\n    2837,\n/**/\n    2836,\n/**/\n    2835,\n/**/\n    2834,\n/**/\n    2833,\n/**/\n    2832,\n/**/\n    2831,\n/**/\n    2830,\n/**/\n    2829,\n/**/\n    2828,\n/**/\n    2827,\n/**/\n    2826,\n/**/\n    2825,\n/**/\n    2824,\n/**/\n    2823,\n/**/\n    2822,\n/**/\n    2821,\n/**/\n    2820,\n/**/\n    2819,\n/**/\n    2818,\n/**/\n    2817,\n/**/\n    2816,\n/**/\n    2815,\n/**/\n    2814,\n/**/\n    2813,\n/**/\n    2812,\n/**/\n    2811,\n/**/\n    2810,\n/**/\n    2809,\n/**/\n    2808,\n/**/\n    2807,\n/**/\n    2806,\n/**/\n    2805,\n/**/\n    2804,\n/**/\n    2803,\n/**/\n    2802,\n/**/\n    2801,\n/**/\n    2800,\n/**/\n    2799,\n/**/\n    2798,\n/**/\n    2797,\n/**/\n    2796,\n/**/\n    2795,\n/**/\n    2794,\n/**/\n    2793,\n/**/\n    2792,\n/**/\n    2791,\n/**/\n    2790,\n/**/\n    2789,\n/**/\n    2788,\n/**/\n    2787,\n/**/\n    2786,\n/**/\n    2785,\n/**/\n    2784,\n/**/\n    2783,\n/**/\n    2782,\n/**/\n    2781,\n/**/\n    2780,\n/**/\n    2779,\n/**/\n    2778,\n/**/\n    2777,\n/**/\n    2776,\n/**/\n    2775,\n/**/\n    2774,\n/**/\n    2773,\n/**/\n    2772,\n/**/\n    2771,\n/**/\n    2770,\n/**/\n    2769,\n/**/\n    2768,\n/**/\n    2767,\n/**/\n    2766,\n/**/\n    2765,\n/**/\n    2764,\n/**/\n    2763,\n/**/\n    2762,\n/**/\n    2761,\n/**/\n    2760,\n/**/\n    2759,\n/**/\n    2758,\n/**/\n    2757,\n/**/\n    2756,\n/**/\n    2755,\n/**/\n    2754,\n/**/\n    2753,\n/**/\n    2752,\n/**/\n    2751,\n/**/\n    2750,\n/**/\n    2749,\n/**/\n    2748,\n/**/\n    2747,\n/**/\n    2746,\n/**/\n    2745,\n/**/\n    2744,\n/**/\n    2743,\n/**/\n    2742,\n/**/\n    2741,\n/**/\n    2740,\n/**/\n    2739,\n/**/\n    2738,\n/**/\n    2737,\n/**/\n    2736,\n/**/\n    2735,\n/**/\n    2734,\n/**/\n    2733,\n/**/\n    2732,\n/**/\n    2731,\n/**/\n    2730,\n/**/\n    2729,\n/**/\n    2728,\n/**/\n    2727,\n/**/\n    2726,\n/**/\n    2725,\n/**/\n    2724,\n/**/\n    2723,\n/**/\n    2722,\n/**/\n    2721,\n/**/\n    2720,\n/**/\n    2719,\n/**/\n    2718,\n/**/\n    2717,\n/**/\n    2716,\n/**/\n    2715,\n/**/\n    2714,\n/**/\n    2713,\n/**/\n    2712,\n/**/\n    2711,\n/**/\n    2710,\n/**/\n    2709,\n/**/\n    2708,\n/**/\n    2707,\n/**/\n    2706,\n/**/\n    2705,\n/**/\n    2704,\n/**/\n    2703,\n/**/\n    2702,\n/**/\n    2701,\n/**/\n    2700,\n/**/\n    2699,\n/**/\n    2698,\n/**/\n    2697,\n/**/\n    2696,\n/**/\n    2695,\n/**/\n    2694,\n/**/\n    2693,\n/**/\n    2692,\n/**/\n    2691,\n/**/\n    2690,\n/**/\n    2689,\n/**/\n    2688,\n/**/\n    2687,\n/**/\n    2686,\n/**/\n    2685,\n/**/\n    2684,\n/**/\n    2683,\n/**/\n    2682,\n/**/\n    2681,\n/**/\n    2680,\n/**/\n    2679,\n/**/\n    2678,\n/**/\n    2677,\n/**/\n    2676,\n/**/\n    2675,\n/**/\n    2674,\n/**/\n    2673,\n/**/\n    2672,\n/**/\n    2671,\n/**/\n    2670,\n/**/\n    2669,\n/**/\n    2668,\n/**/\n    2667,\n/**/\n    2666,\n/**/\n    2665,\n/**/\n    2664,\n/**/\n    2663,\n/**/\n    2662,\n/**/\n    2661,\n/**/\n    2660,\n/**/\n    2659,\n/**/\n    2658,\n/**/\n    2657,\n/**/\n    2656,\n/**/\n    2655,\n/**/\n    2654,\n/**/\n    2653,\n/**/\n    2652,\n/**/\n    2651,\n/**/\n    2650,\n/**/\n    2649,\n/**/\n    2648,\n/**/\n    2647,\n/**/\n    2646,\n/**/\n    2645,\n/**/\n    2644,\n/**/\n    2643,\n/**/\n    2642,\n/**/\n    2641,\n/**/\n    2640,\n/**/\n    2639,\n/**/\n    2638,\n/**/\n    2637,\n/**/\n    2636,\n/**/\n    2635,\n/**/\n    2634,\n/**/\n    2633,\n/**/\n    2632,\n/**/\n    2631,\n/**/\n    2630,\n/**/\n    2629,\n/**/\n    2628,\n/**/\n    2627,\n/**/\n    2626,\n/**/\n    2625,\n/**/\n    2624,\n/**/\n    2623,\n/**/\n    2622,\n/**/\n    2621,\n/**/\n    2620,\n/**/\n    2619,\n/**/\n    2618,\n/**/\n    2617,\n/**/\n    2616,\n/**/\n    2615,\n/**/\n    2614,\n/**/\n    2613,\n/**/\n    2612,\n/**/\n    2611,\n/**/\n    2610,\n/**/\n    2609,\n/**/\n    2608,\n/**/\n    2607,\n/**/\n    2606,\n/**/\n    2605,\n/**/\n    2604,\n/**/\n    2603,\n/**/\n    2602,\n/**/\n    2601,\n/**/\n    2600,\n/**/\n    2599,\n/**/\n    2598,\n/**/\n    2597,\n/**/\n    2596,\n/**/\n    2595,\n/**/\n    2594,\n/**/\n    2593,\n/**/\n    2592,\n/**/\n    2591,\n/**/\n    2590,\n/**/\n    2589,\n/**/\n    2588,\n/**/\n    2587,\n/**/\n    2586,\n/**/\n    2585,\n/**/\n    2584,\n/**/\n    2583,\n/**/\n    2582,\n/**/\n    2581,\n/**/\n    2580,\n/**/\n    2579,\n/**/\n    2578,\n/**/\n    2577,\n/**/\n    2576,\n/**/\n    2575,\n/**/\n    2574,\n/**/\n    2573,\n/**/\n    2572,\n/**/\n    2571,\n/**/\n    2570,\n/**/\n    2569,\n/**/\n    2568,\n/**/\n    2567,\n/**/\n    2566,\n/**/\n    2565,\n/**/\n    2564,\n/**/\n    2563,\n/**/\n    2562,\n/**/\n    2561,\n/**/\n    2560,\n/**/\n    2559,\n/**/\n    2558,\n/**/\n    2557,\n/**/\n    2556,\n/**/\n    2555,\n/**/\n    2554,\n/**/\n    2553,\n/**/\n    2552,\n/**/\n    2551,\n/**/\n    2550,\n/**/\n    2549,\n/**/\n    2548,\n/**/\n    2547,\n/**/\n    2546,\n/**/\n    2545,\n/**/\n    2544,\n/**/\n    2543,\n/**/\n    2542,\n/**/\n    2541,\n/**/\n    2540,\n/**/\n    2539,\n/**/\n    2538,\n/**/\n    2537,\n/**/\n    2536,\n/**/\n    2535,\n/**/\n    2534,\n/**/\n    2533,\n/**/\n    2532,\n/**/\n    2531,\n/**/\n    2530,\n/**/\n    2529,\n/**/\n    2528,\n/**/\n    2527,\n/**/\n    2526,\n/**/\n    2525,\n/**/\n    2524,\n/**/\n    2523,\n/**/\n    2522,\n/**/\n    2521,\n/**/\n    2520,\n/**/\n    2519,\n/**/\n    2518,\n/**/\n    2517,\n/**/\n    2516,\n/**/\n    2515,\n/**/\n    2514,\n/**/\n    2513,\n/**/\n    2512,\n/**/\n    2511,\n/**/\n    2510,\n/**/\n    2509,\n/**/\n    2508,\n/**/\n    2507,\n/**/\n    2506,\n/**/\n    2505,\n/**/\n    2504,\n/**/\n    2503,\n/**/\n    2502,\n/**/\n    2501,\n/**/\n    2500,\n/**/\n    2499,\n/**/\n    2498,\n/**/\n    2497,\n/**/\n    2496,\n/**/\n    2495,\n/**/\n    2494,\n/**/\n    2493,\n/**/\n    2492,\n/**/\n    2491,\n/**/\n    2490,\n/**/\n    2489,\n/**/\n    2488,\n/**/\n    2487,\n/**/\n    2486,\n/**/\n    2485,\n/**/\n    2484,\n/**/\n    2483,\n/**/\n    2482,\n/**/\n    2481,\n/**/\n    2480,\n/**/\n    2479,\n/**/\n    2478,\n/**/\n    2477,\n/**/\n    2476,\n/**/\n    2475,\n/**/\n    2474,\n/**/\n    2473,\n/**/\n    2472,\n/**/\n    2471,\n/**/\n    2470,\n/**/\n    2469,\n/**/\n    2468,\n/**/\n    2467,\n/**/\n    2466,\n/**/\n    2465,\n/**/\n    2464,\n/**/\n    2463,\n/**/\n    2462,\n/**/\n    2461,\n/**/\n    2460,\n/**/\n    2459,\n/**/\n    2458,\n/**/\n    2457,\n/**/\n    2456,\n/**/\n    2455,\n/**/\n    2454,\n/**/\n    2453,\n/**/\n    2452,\n/**/\n    2451,\n/**/\n    2450,\n/**/\n    2449,\n/**/\n    2448,\n/**/\n    2447,\n/**/\n    2446,\n/**/\n    2445,\n/**/\n    2444,\n/**/\n    2443,\n/**/\n    2442,\n/**/\n    2441,\n/**/\n    2440,\n/**/\n    2439,\n/**/\n    2438,\n/**/\n    2437,\n/**/\n    2436,\n/**/\n    2435,\n/**/\n    2434,\n/**/\n    2433,\n/**/\n    2432,\n/**/\n    2431,\n/**/\n    2430,\n/**/\n    2429,\n/**/\n    2428,\n/**/\n    2427,\n/**/\n    2426,\n/**/\n    2425,\n/**/\n    2424,\n/**/\n    2423,\n/**/\n    2422,\n/**/\n    2421,\n/**/\n    2420,\n/**/\n    2419,\n/**/\n    2418,\n/**/\n    2417,\n/**/\n    2416,\n/**/\n    2415,\n/**/\n    2414,\n/**/\n    2413,\n/**/\n    2412,\n/**/\n    2411,\n/**/\n    2410,\n/**/\n    2409,\n/**/\n    2408,\n/**/\n    2407,\n/**/\n    2406,\n/**/\n    2405,\n/**/\n    2404,\n/**/\n    2403,\n/**/\n    2402,\n/**/\n    2401,\n/**/\n    2400,\n/**/\n    2399,\n/**/\n    2398,\n/**/\n    2397,\n/**/\n    2396,\n/**/\n    2395,\n/**/\n    2394,\n/**/\n    2393,\n/**/\n    2392,\n/**/\n    2391,\n/**/\n    2390,\n/**/\n    2389,\n/**/\n    2388,\n/**/\n    2387,\n/**/\n    2386,\n/**/\n    2385,\n/**/\n    2384,\n/**/\n    2383,\n/**/\n    2382,\n/**/\n    2381,\n/**/\n    2380,\n/**/\n    2379,\n/**/\n    2378,\n/**/\n    2377,\n/**/\n    2376,\n/**/\n    2375,\n/**/\n    2374,\n/**/\n    2373,\n/**/\n    2372,\n/**/\n    2371,\n/**/\n    2370,\n/**/\n    2369,\n/**/\n    2368,\n/**/\n    2367,\n/**/\n    2366,\n/**/\n    2365,\n/**/\n    2364,\n/**/\n    2363,\n/**/\n    2362,\n/**/\n    2361,\n/**/\n    2360,\n/**/\n    2359,\n/**/\n    2358,\n/**/\n    2357,\n/**/\n    2356,\n/**/\n    2355,\n/**/\n    2354,\n/**/\n    2353,\n/**/\n    2352,\n/**/\n    2351,\n/**/\n    2350,\n/**/\n    2349,\n/**/\n    2348,\n/**/\n    2347,\n/**/\n    2346,\n/**/\n    2345,\n/**/\n    2344,\n/**/\n    2343,\n/**/\n    2342,\n/**/\n    2341,\n/**/\n    2340,\n/**/\n    2339,\n/**/\n    2338,\n/**/\n    2337,\n/**/\n    2336,\n/**/\n    2335,\n/**/\n    2334,\n/**/\n    2333,\n/**/\n    2332,\n/**/\n    2331,\n/**/\n    2330,\n/**/\n    2329,\n/**/\n    2328,\n/**/\n    2327,\n/**/\n    2326,\n/**/\n    2325,\n/**/\n    2324,\n/**/\n    2323,\n/**/\n    2322,\n/**/\n    2321,\n/**/\n    2320,\n/**/\n    2319,\n/**/\n    2318,\n/**/\n    2317,\n/**/\n    2316,\n/**/\n    2315,\n/**/\n    2314,\n/**/\n    2313,\n/**/\n    2312,\n/**/\n    2311,\n/**/\n    2310,\n/**/\n    2309,\n/**/\n    2308,\n/**/\n    2307,\n/**/\n    2306,\n/**/\n    2305,\n/**/\n    2304,\n/**/\n    2303,\n/**/\n    2302,\n/**/\n    2301,\n/**/\n    2300,\n/**/\n    2299,\n/**/\n    2298,\n/**/\n    2297,\n/**/\n    2296,\n/**/\n    2295,\n/**/\n    2294,\n/**/\n    2293,\n/**/\n    2292,\n/**/\n    2291,\n/**/\n    2290,\n/**/\n    2289,\n/**/\n    2288,\n/**/\n    2287,\n/**/\n    2286,\n/**/\n    2285,\n/**/\n    2284,\n/**/\n    2283,\n/**/\n    2282,\n/**/\n    2281,\n/**/\n    2280,\n/**/\n    2279,\n/**/\n    2278,\n/**/\n    2277,\n/**/\n    2276,\n/**/\n    2275,\n/**/\n    2274,\n/**/\n    2273,\n/**/\n    2272,\n/**/\n    2271,\n/**/\n    2270,\n/**/\n    2269,\n/**/\n    2268,\n/**/\n    2267,\n/**/\n    2266,\n/**/\n    2265,\n/**/\n    2264,\n/**/\n    2263,\n/**/\n    2262,\n/**/\n    2261,\n/**/\n    2260,\n/**/\n    2259,\n/**/\n    2258,\n/**/\n    2257,\n/**/\n    2256,\n/**/\n    2255,\n/**/\n    2254,\n/**/\n    2253,\n/**/\n    2252,\n/**/\n    2251,\n/**/\n    2250,\n/**/\n    2249,\n/**/\n    2248,\n/**/\n    2247,\n/**/\n    2246,\n/**/\n    2245,\n/**/\n    2244,\n/**/\n    2243,\n/**/\n    2242,\n/**/\n    2241,\n/**/\n    2240,\n/**/\n    2239,\n/**/\n    2238,\n/**/\n    2237,\n/**/\n    2236,\n/**/\n    2235,\n/**/\n    2234,\n/**/\n    2233,\n/**/\n    2232,\n/**/\n    2231,\n/**/\n    2230,\n/**/\n    2229,\n/**/\n    2228,\n/**/\n    2227,\n/**/\n    2226,\n/**/\n    2225,\n/**/\n    2224,\n/**/\n    2223,\n/**/\n    2222,\n/**/\n    2221,\n/**/\n    2220,\n/**/\n    2219,\n/**/\n    2218,\n/**/\n    2217,\n/**/\n    2216,\n/**/\n    2215,\n/**/\n    2214,\n/**/\n    2213,\n/**/\n    2212,\n/**/\n    2211,\n/**/\n    2210,\n/**/\n    2209,\n/**/\n    2208,\n/**/\n    2207,\n/**/\n    2206,\n/**/\n    2205,\n/**/\n    2204,\n/**/\n    2203,\n/**/\n    2202,\n/**/\n    2201,\n/**/\n    2200,\n/**/\n    2199,\n/**/\n    2198,\n/**/\n    2197,\n/**/\n    2196,\n/**/\n    2195,\n/**/\n    2194,\n/**/\n    2193,\n/**/\n    2192,\n/**/\n    2191,\n/**/\n    2190,\n/**/\n    2189,\n/**/\n    2188,\n/**/\n    2187,\n/**/\n    2186,\n/**/\n    2185,\n/**/\n    2184,\n/**/\n    2183,\n/**/\n    2182,\n/**/\n    2181,\n/**/\n    2180,\n/**/\n    2179,\n/**/\n    2178,\n/**/\n    2177,\n/**/\n    2176,\n/**/\n    2175,\n/**/\n    2174,\n/**/\n    2173,\n/**/\n    2172,\n/**/\n    2171,\n/**/\n    2170,\n/**/\n    2169,\n/**/\n    2168,\n/**/\n    2167,\n/**/\n    2166,\n/**/\n    2165,\n/**/\n    2164,\n/**/\n    2163,\n/**/\n    2162,\n/**/\n    2161,\n/**/\n    2160,\n/**/\n    2159,\n/**/\n    2158,\n/**/\n    2157,\n/**/\n    2156,\n/**/\n    2155,\n/**/\n    2154,\n/**/\n    2153,\n/**/\n    2152,\n/**/\n    2151,\n/**/\n    2150,\n/**/\n    2149,\n/**/\n    2148,\n/**/\n    2147,\n/**/\n    2146,\n/**/\n    2145,\n/**/\n    2144,\n/**/\n    2143,\n/**/\n    2142,\n/**/\n    2141,\n/**/\n    2140,\n/**/\n    2139,\n/**/\n    2138,\n/**/\n    2137,\n/**/\n    2136,\n/**/\n    2135,\n/**/\n    2134,\n/**/\n    2133,\n/**/\n    2132,\n/**/\n    2131,\n/**/\n    2130,\n/**/\n    2129,\n/**/\n    2128,\n/**/\n    2127,\n/**/\n    2126,\n/**/\n    2125,\n/**/\n    2124,\n/**/\n    2123,\n/**/\n    2122,\n/**/\n    2121,\n/**/\n    2120,\n/**/\n    2119,\n/**/\n    2118,\n/**/\n    2117,\n/**/\n    2116,\n/**/\n    2115,\n/**/\n    2114,\n/**/\n    2113,\n/**/\n    2112,\n/**/\n    2111,\n/**/\n    2110,\n/**/\n    2109,\n/**/\n    2108,\n/**/\n    2107,\n/**/\n    2106,\n/**/\n    2105,\n/**/\n    2104,\n/**/\n    2103,\n/**/\n    2102,\n/**/\n    2101,\n/**/\n    2100,\n/**/\n    2099,\n/**/\n    2098,\n/**/\n    2097,\n/**/\n    2096,\n/**/\n    2095,\n/**/\n    2094,\n/**/\n    2093,\n/**/\n    2092,\n/**/\n    2091,\n/**/\n    2090,\n/**/\n    2089,\n/**/\n    2088,\n/**/\n    2087,\n/**/\n    2086,\n/**/\n    2085,\n/**/\n    2084,\n/**/\n    2083,\n/**/\n    2082,\n/**/\n    2081,\n/**/\n    2080,\n/**/\n    2079,\n/**/\n    2078,\n/**/\n    2077,\n/**/\n    2076,\n/**/\n    2075,\n/**/\n    2074,\n/**/\n    2073,\n/**/\n    2072,\n/**/\n    2071,\n/**/\n    2070,\n/**/\n    2069,\n/**/\n    2068,\n/**/\n    2067,\n/**/\n    2066,\n/**/\n    2065,\n/**/\n    2064,\n/**/\n    2063,\n/**/\n    2062,\n/**/\n    2061,\n/**/\n    2060,\n/**/\n    2059,\n/**/\n    2058,\n/**/\n    2057,\n/**/\n    2056,\n/**/\n    2055,\n/**/\n    2054,\n/**/\n    2053,\n/**/\n    2052,\n/**/\n    2051,\n/**/\n    2050,\n/**/\n    2049,\n/**/\n    2048,\n/**/\n    2047,\n/**/\n    2046,\n/**/\n    2045,\n/**/\n    2044,\n/**/\n    2043,\n/**/\n    2042,\n/**/\n    2041,\n/**/\n    2040,\n/**/\n    2039,\n/**/\n    2038,\n/**/\n    2037,\n/**/\n    2036,\n/**/\n    2035,\n/**/\n    2034,\n/**/\n    2033,\n/**/\n    2032,\n/**/\n    2031,\n/**/\n    2030,\n/**/\n    2029,\n/**/\n    2028,\n/**/\n    2027,\n/**/\n    2026,\n/**/\n    2025,\n/**/\n    2024,\n/**/\n    2023,\n/**/\n    2022,\n/**/\n    2021,\n/**/\n    2020,\n/**/\n    2019,\n/**/\n    2018,\n/**/\n    2017,\n/**/\n    2016,\n/**/\n    2015,\n/**/\n    2014,\n/**/\n    2013,\n/**/\n    2012,\n/**/\n    2011,\n/**/\n    2010,\n/**/\n    2009,\n/**/\n    2008,\n/**/\n    2007,\n/**/\n    2006,\n/**/\n    2005,\n/**/\n    2004,\n/**/\n    2003,\n/**/\n    2002,\n/**/\n    2001,\n/**/\n    2000,\n/**/\n    1999,\n/**/\n    1998,\n/**/\n    1997,\n/**/\n    1996,\n/**/\n    1995,\n/**/\n    1994,\n/**/\n    1993,\n/**/\n    1992,\n/**/\n    1991,\n/**/\n    1990,\n/**/\n    1989,\n/**/\n    1988,\n/**/\n    1987,\n/**/\n    1986,\n/**/\n    1985,\n/**/\n    1984,\n/**/\n    1983,\n/**/\n    1982,\n/**/\n    1981,\n/**/\n    1980,\n/**/\n    1979,\n/**/\n    1978,\n/**/\n    1977,\n/**/\n    1976,\n/**/\n    1975,\n/**/\n    1974,\n/**/\n    1973,\n/**/\n    1972,\n/**/\n    1971,\n/**/\n    1970,\n/**/\n    1969,\n/**/\n    1968,\n/**/\n    1967,\n/**/\n    1966,\n/**/\n    1965,\n/**/\n    1964,\n/**/\n    1963,\n/**/\n    1962,\n/**/\n    1961,\n/**/\n    1960,\n/**/\n    1959,\n/**/\n    1958,\n/**/\n    1957,\n/**/\n    1956,\n/**/\n    1955,\n/**/\n    1954,\n/**/\n    1953,\n/**/\n    1952,\n/**/\n    1951,\n/**/\n    1950,\n/**/\n    1949,\n/**/\n    1948,\n/**/\n    1947,\n/**/\n    1946,\n/**/\n    1945,\n/**/\n    1944,\n/**/\n    1943,\n/**/\n    1942,\n/**/\n    1941,\n/**/\n    1940,\n/**/\n    1939,\n/**/\n    1938,\n/**/\n    1937,\n/**/\n    1936,\n/**/\n    1935,\n/**/\n    1934,\n/**/\n    1933,\n/**/\n    1932,\n/**/\n    1931,\n/**/\n    1930,\n/**/\n    1929,\n/**/\n    1928,\n/**/\n    1927,\n/**/\n    1926,\n/**/\n    1925,\n/**/\n    1924,\n/**/\n    1923,\n/**/\n    1922,\n/**/\n    1921,\n/**/\n    1920,\n/**/\n    1919,\n/**/\n    1918,\n/**/\n    1917,\n/**/\n    1916,\n/**/\n    1915,\n/**/\n    1914,\n/**/\n    1913,\n/**/\n    1912,\n/**/\n    1911,\n/**/\n    1910,\n/**/\n    1909,\n/**/\n    1908,\n/**/\n    1907,\n/**/\n    1906,\n/**/\n    1905,\n/**/\n    1904,\n/**/\n    1903,\n/**/\n    1902,\n/**/\n    1901,\n/**/\n    1900,\n/**/\n    1899,\n/**/\n    1898,\n/**/\n    1897,\n/**/\n    1896,\n/**/\n    1895,\n/**/\n    1894,\n/**/\n    1893,\n/**/\n    1892,\n/**/\n    1891,\n/**/\n    1890,\n/**/\n    1889,\n/**/\n    1888,\n/**/\n    1887,\n/**/\n    1886,\n/**/\n    1885,\n/**/\n    1884,\n/**/\n    1883,\n/**/\n    1882,\n/**/\n    1881,\n/**/\n    1880,\n/**/\n    1879,\n/**/\n    1878,\n/**/\n    1877,\n/**/\n    1876,\n/**/\n    1875,\n/**/\n    1874,\n/**/\n    1873,\n/**/\n    1872,\n/**/\n    1871,\n/**/\n    1870,\n/**/\n    1869,\n/**/\n    1868,\n/**/\n    1867,\n/**/\n    1866,\n/**/\n    1865,\n/**/\n    1864,\n/**/\n    1863,\n/**/\n    1862,\n/**/\n    1861,\n/**/\n    1860,\n/**/\n    1859,\n/**/\n    1858,\n/**/\n    1857,\n/**/\n    1856,\n/**/\n    1855,\n/**/\n    1854,\n/**/\n    1853,\n/**/\n    1852,\n/**/\n    1851,\n/**/\n    1850,\n/**/\n    1849,\n/**/\n    1848,\n/**/\n    1847,\n/**/\n    1846,\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    while (l < h)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + (item_count % ncol ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#ifdef FEAT_HUGE\n    msg_puts(_(\"\\nHuge version \"));\n#else\n# ifdef FEAT_BIG\n    msg_puts(_(\"\\nBig version \"));\n# else\n#  ifdef FEAT_NORMAL\n    msg_puts(_(\"\\nNormal version \"));\n#  else\n#   ifdef FEAT_SMALL\n    msg_puts(_(\"\\nSmall version \"));\n#   else\n    msg_puts(_(\"\\nTiny version \"));\n#   endif\n#  endif\n# endif\n#endif\n#ifndef FEAT_GUI\n    msg_puts(_(\"without GUI.\"));\n#else\n# ifdef FEAT_GUI_GTK\n#  ifdef USE_GTK3\n    msg_puts(_(\"with GTK3 GUI.\"));\n#  else\n#   ifdef FEAT_GUI_GNOME\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n#   else\n     msg_puts(_(\"with GTK2 GUI.\"));\n#   endif\n# endif\n# else\n#  ifdef FEAT_GUI_MOTIF\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#  else\n#   ifdef FEAT_GUI_ATHENA\n#    ifdef FEAT_GUI_NEXTAW\n    msg_puts(_(\"with X11-neXtaw GUI.\"));\n#    else\n    msg_puts(_(\"with X11-Athena GUI.\"));\n#    endif\n#   else\n#    ifdef FEAT_GUI_HAIKU\n    msg_puts(_(\"with Haiku GUI.\"));\n#    else\n#     ifdef FEAT_GUI_PHOTON\n    msg_puts(_(\"with Photon GUI.\"));\n#     else\n#      if defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#      endif\n#     endif\n#    endif\n#   endif\n#  endif\n# endif\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version8<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "filenames": ["src/spellsuggest.c", "src/testdir/test_spell.vim", "src/version.c"], "buggy_code_start_loc": [1208, 773, 752], "buggy_code_end_loc": [2651, 773, 752], "fixing_code_start_loc": [1208, 774, 753], "fixing_code_end_loc": [2665, 782, 755], "type": "CWE-121", "message": "Stack-based Buffer Overflow in GitHub repository vim/vim prior to 8.2.", "other": {"cve": {"id": "CVE-2022-0408", "sourceIdentifier": "security@huntr.dev", "published": "2022-01-30T15:15:07.857", "lastModified": "2022-12-13T16:42:41.270", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Stack-based Buffer Overflow in GitHub repository vim/vim prior to 8.2."}, {"lang": "es", "value": "Desbordamiento de b\u00fafer basado en la pila en el repositorio de GitHub vim/vim anterior a la versi\u00f3n 8.2."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.4, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.5, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-121"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndExcluding": "8.2.4247", "matchCriteriaId": "34FEE682-0CF1-4BD4-B4FE-9707E19AB111"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "https://github.com/vim/vim/commit/06f15416bb8d5636200a10776f1752c4d6e49f31", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/5e635bad-5cf6-46cd-aeac-34ef224e179d", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/03/msg00018.html", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/11/msg00009.html", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/7ZLEHVP4LNAGER4ZDGUDS5V5YVQD6INF/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/UFXFAILMLUIK4MBUEZO4HNBNKYZRJ5AP/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202208-32", "source": "security@huntr.dev", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/vim/vim/commit/06f15416bb8d5636200a10776f1752c4d6e49f31"}}