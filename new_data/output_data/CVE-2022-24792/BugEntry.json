{"buggy_code": ["/* $Id$ */\n/* \n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n#ifndef __PJ_TYPES_H__\n#define __PJ_TYPES_H__\n\n\n/**\n * @file types.h\n * @brief Declaration of basic types and utility.\n */\n/**\n * @defgroup PJ_BASIC Basic Data Types and Library Functionality.\n * @ingroup PJ_DS\n * @{\n */\n#include <pj/config.h>\n\nPJ_BEGIN_DECL\n\n/* ************************************************************************* */\n\n/** Signed 32bit integer. */\ntypedef int\t\tpj_int32_t;\n\n/** Unsigned 32bit integer. */\ntypedef unsigned int\tpj_uint32_t;\n\n/** Signed 16bit integer. */\ntypedef short\t\tpj_int16_t;\n\n/** Unsigned 16bit integer. */\ntypedef unsigned short\tpj_uint16_t;\n\n/** Signed 8bit integer. */\ntypedef signed char\tpj_int8_t;\n\n/** Unsigned 8bit integer. */\ntypedef unsigned char\tpj_uint8_t;\n\n/** Large unsigned integer. */\ntypedef size_t\t\tpj_size_t;\n\n/** Large signed integer. */\n#if defined(PJ_WIN64) && PJ_WIN64!=0\n    typedef pj_int64_t     pj_ssize_t;\n#else\n    typedef long           pj_ssize_t;\n#endif\n\n/** Status code. */\ntypedef int\t\tpj_status_t;\n\n/** Boolean. */\ntypedef int\t\tpj_bool_t;\n\n/** Native char type, which will be equal to wchar_t for Unicode\n * and char for ANSI. */\n#if defined(PJ_NATIVE_STRING_IS_UNICODE) && PJ_NATIVE_STRING_IS_UNICODE!=0\n    typedef wchar_t pj_char_t;\n#else\n    typedef char pj_char_t;\n#endif\n\n/** This macro creates Unicode or ANSI literal string depending whether\n *  native platform string is Unicode or ANSI. */\n#if defined(PJ_NATIVE_STRING_IS_UNICODE) && PJ_NATIVE_STRING_IS_UNICODE!=0\n#   define PJ_T(literal_str)\tL##literal_str\n#else\n#   define PJ_T(literal_str)\tliteral_str\n#endif\n\n/** Some constants */\nenum pj_constants_\n{\n    /** Status is OK. */\n    PJ_SUCCESS=0,\n\n    /** True value. */\n    PJ_TRUE=1,\n\n    /** False value. */\n    PJ_FALSE=0\n};\n\n/**\n * File offset type.\n */\n#if defined(PJ_HAS_INT64) && PJ_HAS_INT64!=0\ntypedef pj_int64_t pj_off_t;\n#else\ntypedef pj_ssize_t pj_off_t;\n#endif\n\n/* ************************************************************************* */\n/*\n * Data structure types.\n */\n/**\n * This type is used as replacement to legacy C string, and used throughout\n * the library. By convention, the string is NOT null terminated.\n */\nstruct pj_str_t\n{\n    /** Buffer pointer, which is by convention NOT null terminated. */\n    char       *ptr;\n\n    /** The length of the string. */\n    pj_ssize_t  slen;\n};\n\n/**\n * This structure represents high resolution (64bit) time value. The time\n * values represent time in cycles, which is retrieved by calling\n * #pj_get_timestamp().\n */\ntypedef union pj_timestamp\n{\n    struct\n    {\n#if defined(PJ_IS_LITTLE_ENDIAN) && PJ_IS_LITTLE_ENDIAN!=0\n\tpj_uint32_t lo;     /**< Low 32-bit value of the 64-bit value. */\n\tpj_uint32_t hi;     /**< high 32-bit value of the 64-bit value. */\n#else\n\tpj_uint32_t hi;     /**< high 32-bit value of the 64-bit value. */\n\tpj_uint32_t lo;     /**< Low 32-bit value of the 64-bit value. */\n#endif\n    } u32;                  /**< The 64-bit value as two 32-bit values. */\n\n#if PJ_HAS_INT64\n    pj_uint64_t u64;        /**< The whole 64-bit value, where available. */\n#endif\n} pj_timestamp;\n\n\n\n/**\n * The opaque data type for linked list, which is used as arguments throughout\n * the linked list operations.\n */\ntypedef void pj_list_type;\n\n/** \n * List.\n */\ntypedef struct pj_list pj_list;\n\n/**\n * Opaque data type for hash tables.\n */\ntypedef struct pj_hash_table_t pj_hash_table_t;\n\n/**\n * Opaque data type for hash entry (only used internally by hash table).\n */\ntypedef struct pj_hash_entry pj_hash_entry;\n\n/**\n * Data type for hash search iterator.\n * This structure should be opaque, however applications need to declare\n * concrete variable of this type, that's why the declaration is visible here.\n */\ntypedef struct pj_hash_iterator_t\n{\n    pj_uint32_t\t     index;     /**< Internal index.     */\n    pj_hash_entry   *entry;     /**< Internal entry.     */\n} pj_hash_iterator_t;\n\n\n/**\n * Forward declaration for memory pool factory.\n */\ntypedef struct pj_pool_factory pj_pool_factory;\n\n/**\n * Opaque data type for memory pool.\n */\ntypedef struct pj_pool_t pj_pool_t;\n\n/**\n * Forward declaration for caching pool, a pool factory implementation.\n */\ntypedef struct pj_caching_pool pj_caching_pool;\n\n/**\n * This type is used as replacement to legacy C string, and used throughout\n * the library.\n */\ntypedef struct pj_str_t pj_str_t;\n\n/**\n * Opaque data type for I/O Queue structure.\n */\ntypedef struct pj_ioqueue_t pj_ioqueue_t;\n\n/**\n * Opaque data type for key that identifies a handle registered to the\n * I/O queue framework.\n */\ntypedef struct pj_ioqueue_key_t pj_ioqueue_key_t;\n\n/**\n * Opaque data to identify timer heap.\n */\ntypedef struct pj_timer_heap_t pj_timer_heap_t;\n\n/** \n * Opaque data type for atomic operations.\n */\ntypedef struct pj_atomic_t pj_atomic_t;\n\n/**\n * Value type of an atomic variable.\n */\ntypedef PJ_ATOMIC_VALUE_TYPE pj_atomic_value_t;\n \n/* ************************************************************************* */\n\n/** Thread handle. */\ntypedef struct pj_thread_t pj_thread_t;\n\n/** Lock object. */\ntypedef struct pj_lock_t pj_lock_t;\n\n/** Group lock */\ntypedef struct pj_grp_lock_t pj_grp_lock_t;\n\n/** Mutex handle. */\ntypedef struct pj_mutex_t pj_mutex_t;\n\n/** Semaphore handle. */\ntypedef struct pj_sem_t pj_sem_t;\n\n/** Event object. */\ntypedef struct pj_event_t pj_event_t;\n\n/** Unidirectional stream pipe object. */\ntypedef struct pj_pipe_t pj_pipe_t;\n\n/** Operating system handle. */\ntypedef void *pj_oshandle_t;\n\n/** Socket handle. */\n#if defined(PJ_WIN64) && PJ_WIN64!=0\n    typedef pj_int64_t pj_sock_t;\n#else\n    typedef long pj_sock_t;\n#endif\n\n/** Generic socket address. */\ntypedef void pj_sockaddr_t;\n\n/** Forward declaration. */\ntypedef struct pj_sockaddr_in pj_sockaddr_in;\n\n/** Color type. */\ntypedef unsigned int pj_color_t;\n\n/** Exception id. */\ntypedef int pj_exception_id_t;\n\n/* ************************************************************************* */\n\n/** Utility macro to compute the number of elements in static array. */\n#define PJ_ARRAY_SIZE(a)    (sizeof(a)/sizeof(a[0]))\n\n/**\n * Length of object names.\n */\n#define PJ_MAX_OBJ_NAME\t32\n\n/* ************************************************************************* */\n/*\n * General.\n */\n/**\n * Initialize the PJ Library.\n * This function must be called before using the library. The purpose of this\n * function is to initialize static library data, such as character table used\n * in random string generation, and to initialize operating system dependent\n * functionality (such as WSAStartup() in Windows).\n *\n * Apart from calling pj_init(), application typically should also initialize\n * the random seed by calling pj_srand().\n *\n * @return PJ_SUCCESS on success.\n */\nPJ_DECL(pj_status_t) pj_init(void);\n\n\n/**\n * Shutdown PJLIB.\n */\nPJ_DECL(void) pj_shutdown(void);\n\n/**\n * Type of callback to register to pj_atexit().\n */\ntypedef void (*pj_exit_callback)(void);\n\n/**\n * Register cleanup function to be called by PJLIB when pj_shutdown() is \n * called.\n *\n * @param func\t    The function to be registered.\n *\n * @return PJ_SUCCESS on success.\n */\nPJ_DECL(pj_status_t) pj_atexit(pj_exit_callback func);\n\n\n\n/**\n * Swap the byte order of an 16bit data.\n *\n * @param val16\t    The 16bit data.\n *\n * @return\t    An 16bit data with swapped byte order.\n */\nPJ_INLINE(pj_int16_t) pj_swap16(pj_int16_t val16)\n{\n    pj_uint8_t *p = (pj_uint8_t*)&val16;\n    pj_uint8_t tmp = *p;\n    *p = *(p+1);\n    *(p+1) = tmp;\n    return val16;\n}\n\n/**\n * Swap the byte order of an 32bit data.\n *\n * @param val32\t    The 32bit data.\n *\n * @return\t    An 32bit data with swapped byte order.\n */\nPJ_INLINE(pj_int32_t) pj_swap32(pj_int32_t val32)\n{\n    pj_uint8_t *p = (pj_uint8_t*)&val32;\n    pj_uint8_t tmp = *p;\n    *p = *(p+3);\n    *(p+3) = tmp;\n    tmp = *(p+1);\n    *(p+1) = *(p+2);\n    *(p+2) = tmp;\n    return val32;\n}\n\n\n/**\n * @}\n */\n/**\n * @addtogroup PJ_TIME Time Data Type and Manipulation.\n * @ingroup PJ_MISC\n * @{\n */\n\n/**\n * Representation of time value in this library.\n * This type can be used to represent either an interval or a specific time\n * or date. \n */\ntypedef struct pj_time_val\n{\n    /** The seconds part of the time. */\n    long    sec;\n\n    /** The miliseconds fraction of the time. */\n    long    msec;\n\n} pj_time_val;\n\n/**\n * Normalize the value in time value.\n * @param t     Time value to be normalized.\n */\nPJ_DECL(void) pj_time_val_normalize(pj_time_val *t);\n\n/**\n * Get the total time value in miliseconds. This is the same as\n * multiplying the second part with 1000 and then add the miliseconds\n * part to the result.\n *\n * @param t     The time value.\n * @return      Total time in miliseconds.\n * @hideinitializer\n */\n#define PJ_TIME_VAL_MSEC(t)\t((t).sec * 1000 + (t).msec)\n\n/**\n * This macro will check if \\a t1 is equal to \\a t2.\n *\n * @param t1    The first time value to compare.\n * @param t2    The second time value to compare.\n * @return      Non-zero if both time values are equal.\n * @hideinitializer\n */\n#define PJ_TIME_VAL_EQ(t1, t2)\t((t1).sec==(t2).sec && (t1).msec==(t2).msec)\n\n/**\n * This macro will check if \\a t1 is greater than \\a t2\n *\n * @param t1    The first time value to compare.\n * @param t2    The second time value to compare.\n * @return      Non-zero if t1 is greater than t2.\n * @hideinitializer\n */\n#define PJ_TIME_VAL_GT(t1, t2)\t((t1).sec>(t2).sec || \\\n                                ((t1).sec==(t2).sec && (t1).msec>(t2).msec))\n\n/**\n * This macro will check if \\a t1 is greater than or equal to \\a t2\n *\n * @param t1    The first time value to compare.\n * @param t2    The second time value to compare.\n * @return      Non-zero if t1 is greater than or equal to t2.\n * @hideinitializer\n */\n#define PJ_TIME_VAL_GTE(t1, t2)\t(PJ_TIME_VAL_GT(t1,t2) || \\\n                                 PJ_TIME_VAL_EQ(t1,t2))\n\n/**\n * This macro will check if \\a t1 is less than \\a t2\n *\n * @param t1    The first time value to compare.\n * @param t2    The second time value to compare.\n * @return      Non-zero if t1 is less than t2.\n * @hideinitializer\n */\n#define PJ_TIME_VAL_LT(t1, t2)\t(!(PJ_TIME_VAL_GTE(t1,t2)))\n\n/**\n * This macro will check if \\a t1 is less than or equal to \\a t2.\n *\n * @param t1    The first time value to compare.\n * @param t2    The second time value to compare.\n * @return      Non-zero if t1 is less than or equal to t2.\n * @hideinitializer\n */\n#define PJ_TIME_VAL_LTE(t1, t2)\t(!PJ_TIME_VAL_GT(t1, t2))\n\n/**\n * Add \\a t2 to \\a t1 and store the result in \\a t1. Effectively\n *\n * this macro will expand as: (\\a t1 += \\a t2).\n * @param t1    The time value to add.\n * @param t2    The time value to be added to \\a t1.\n * @hideinitializer\n */\n#define PJ_TIME_VAL_ADD(t1, t2)\t    do {\t\t\t    \\\n\t\t\t\t\t(t1).sec += (t2).sec;\t    \\\n\t\t\t\t\t(t1).msec += (t2).msec;\t    \\\n\t\t\t\t\tpj_time_val_normalize(&(t1)); \\\n\t\t\t\t    } while (0)\n\n\n/**\n * Substract \\a t2 from \\a t1 and store the result in \\a t1. Effectively\n * this macro will expand as (\\a t1 -= \\a t2).\n *\n * @param t1    The time value to subsctract.\n * @param t2    The time value to be substracted from \\a t1.\n * @hideinitializer\n */\n#define PJ_TIME_VAL_SUB(t1, t2)\t    do {\t\t\t    \\\n\t\t\t\t\t(t1).sec -= (t2).sec;\t    \\\n\t\t\t\t\t(t1).msec -= (t2).msec;\t    \\\n\t\t\t\t\tpj_time_val_normalize(&(t1)); \\\n\t\t\t\t    } while (0)\n\n\n/**\n * This structure represent the parsed representation of time.\n * It is acquired by calling #pj_time_decode().\n */\ntypedef struct pj_parsed_time\n{\n    /** This represents day of week where value zero means Sunday */\n    int wday;\n\n    /* This represents day of the year, 0-365, where zero means\n     *  1st of January.\n     */\n    /*int yday; */\n\n    /** This represents day of month: 1-31 */\n    int day;\n\n    /** This represents month, with the value is 0 - 11 (zero is January) */\n    int mon;\n\n    /** This represent the actual year (unlike in ANSI libc where\n     *  the value must be added by 1900).\n     */\n    int year;\n\n    /** This represents the second part, with the value is 0-59 */\n    int sec;\n\n    /** This represents the minute part, with the value is: 0-59 */\n    int min;\n\n    /** This represents the hour part, with the value is 0-23 */\n    int hour;\n\n    /** This represents the milisecond part, with the value is 0-999 */\n    int msec;\n\n} pj_parsed_time;\n\n\n/**\n * @}\t// Time Management\n */\n\n/* ************************************************************************* */\n/*\n * Terminal.\n */\n/**\n * Color code combination.\n */\nenum {\n    PJ_TERM_COLOR_R\t= 2,    /**< Red            */\n    PJ_TERM_COLOR_G\t= 4,    /**< Green          */\n    PJ_TERM_COLOR_B\t= 1,    /**< Blue.          */\n    PJ_TERM_COLOR_BRIGHT = 8    /**< Bright mask.   */\n};\n\n\n\n\nPJ_END_DECL\n\n\n#endif /* __PJ_TYPES_H__ */\n\n", "/* $Id$ */\n/* \n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n#include <pj/file_io.h>\n#include <pj/assert.h>\n#include <pj/errno.h>\n#include <stdio.h>\n#include <errno.h>\n\nPJ_DEF(pj_status_t) pj_file_open( pj_pool_t *pool,\n                                  const char *pathname, \n                                  unsigned flags,\n                                  pj_oshandle_t *fd)\n{\n    char mode[8];\n    char *p = mode;\n\n    PJ_ASSERT_RETURN(pathname && fd, PJ_EINVAL);\n    PJ_UNUSED_ARG(pool);\n\n    if ((flags & PJ_O_APPEND) == PJ_O_APPEND) {\n        if ((flags & PJ_O_WRONLY) == PJ_O_WRONLY) {\n            *p++ = 'a';\n            if ((flags & PJ_O_RDONLY) == PJ_O_RDONLY)\n                *p++ = '+';\n        } else {\n            /* This is invalid.\n             * Can not specify PJ_O_RDONLY with PJ_O_APPEND! \n             */\n        }\n    } else {\n        if ((flags & PJ_O_RDONLY) == PJ_O_RDONLY) {\n            *p++ = 'r';\n            if ((flags & PJ_O_WRONLY) == PJ_O_WRONLY)\n                *p++ = '+';\n        } else {\n            *p++ = 'w';\n        }\n    }\n\n    if (p==mode)\n        return PJ_EINVAL;\n\n    *p++ = 'b';\n    *p++ = '\\0';\n\n    *fd = fopen(pathname, mode);\n    if (*fd == NULL)\n        return PJ_RETURN_OS_ERROR(errno);\n    \n    return PJ_SUCCESS;\n}\n\nPJ_DEF(pj_status_t) pj_file_close(pj_oshandle_t fd)\n{\n    PJ_ASSERT_RETURN(fd, PJ_EINVAL);\n    if (fclose((FILE*)fd) != 0)\n        return PJ_RETURN_OS_ERROR(errno);\n\n    return PJ_SUCCESS;\n}\n\nPJ_DEF(pj_status_t) pj_file_write( pj_oshandle_t fd,\n                                   const void *data,\n                                   pj_ssize_t *size)\n{\n    size_t written;\n\n    clearerr((FILE*)fd);\n    written = fwrite(data, 1, *size, (FILE*)fd);\n    if (ferror((FILE*)fd)) {\n        *size = -1;\n        return PJ_RETURN_OS_ERROR(errno);\n    }\n\n    *size = written;\n    return PJ_SUCCESS;\n}\n\nPJ_DEF(pj_status_t) pj_file_read( pj_oshandle_t fd,\n                                  void *data,\n                                  pj_ssize_t *size)\n{\n    size_t bytes;\n\n    clearerr((FILE*)fd);\n    bytes = fread(data, 1, *size, (FILE*)fd);\n    if (ferror((FILE*)fd)) {\n        *size = -1;\n        return PJ_RETURN_OS_ERROR(errno);\n    }\n\n    *size = bytes;\n    return PJ_SUCCESS;\n}\n\n/*\nPJ_DEF(pj_bool_t) pj_file_eof(pj_oshandle_t fd, enum pj_file_access access)\n{\n    PJ_UNUSED_ARG(access);\n    return feof((FILE*)fd) ? PJ_TRUE : 0;\n}\n*/\n\nPJ_DEF(pj_status_t) pj_file_setpos( pj_oshandle_t fd,\n                                    pj_off_t offset,\n                                    enum pj_file_seek_type whence)\n{\n    int mode;\n\n    switch (whence) {\n    case PJ_SEEK_SET:\n        mode = SEEK_SET; break;\n    case PJ_SEEK_CUR:\n        mode = SEEK_CUR; break;\n    case PJ_SEEK_END:\n        mode = SEEK_END; break;\n    default:\n        pj_assert(!\"Invalid whence in file_setpos\");\n        return PJ_EINVAL;\n    }\n\n    if (fseek((FILE*)fd, (long)offset, mode) != 0)\n        return PJ_RETURN_OS_ERROR(errno);\n\n    return PJ_SUCCESS;\n}\n\nPJ_DEF(pj_status_t) pj_file_getpos( pj_oshandle_t fd,\n                                    pj_off_t *pos)\n{\n    long offset;\n\n    offset = ftell((FILE*)fd);\n    if (offset == -1) {\n        *pos = -1;\n        return PJ_RETURN_OS_ERROR(errno);\n    }\n\n    *pos = offset;\n    return PJ_SUCCESS;\n}\n\nPJ_DEF(pj_status_t) pj_file_flush(pj_oshandle_t fd)\n{\n    int rc;\n\n    rc = fflush((FILE*)fd);\n    if (rc == EOF) {\n\treturn PJ_RETURN_OS_ERROR(errno);\n    }\n\n    return PJ_SUCCESS;\n}\n", "/* $Id$ */\n/* \n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n\n/**\n * Default file player/writer buffer size.\n */\n#include <pjmedia/avi_stream.h>\n#include <pjmedia/alaw_ulaw.h>\n#include <pjmedia/avi.h>\n#include <pjmedia/errno.h>\n#include <pjmedia/wave.h>\n#include <pj/assert.h>\n#include <pj/file_access.h>\n#include <pj/file_io.h>\n#include <pj/log.h>\n#include <pj/pool.h>\n#include <pj/string.h>\n\n\n#if defined(PJMEDIA_HAS_VIDEO) && (PJMEDIA_HAS_VIDEO != 0)\n\n\n#define THIS_FILE   \"avi_player.c\"\n\n#define AVIF_MUSTUSEINDEX       0x00000020\n#define AVIF_ISINTERLEAVED      0x00000100\n#define AVISF_DISABLED          0x00000001\n#define AVISF_VIDEO_PALCHANGES  0x00010000\n\n#define AVI_EOF 0xFFEEFFEE\n\n//#define COMPARE_TAG(doc_tag, tag) (doc_tag==*((pj_uint32_t*)avi_tags[tag]))\n#define COMPARE_TAG(doc_tag, tag) \\\n\t    (pj_memcmp(&(doc_tag), &avi_tags[tag], 4)==0)\n\n#define SIGNATURE\t    PJMEDIA_SIG_PORT_VID_AVI_PLAYER\n\n#define VIDEO_CLOCK_RATE\t90000\n\n#if 0\n#   define TRACE_(x)\tPJ_LOG(4,x)\n#else\n#   define TRACE_(x)\n#endif\n\n#if defined(PJ_IS_BIG_ENDIAN) && PJ_IS_BIG_ENDIAN!=0\n    static void data_to_host(void *data, pj_uint8_t bits, unsigned count)\n    {\n\tunsigned i;\n\n        count /= (bits == 32? 4 : 2);\n\n\tif (bits == 32) {\n\t    pj_int32_t *data32 = (pj_int32_t *)data;\n\t    for (i=0; i<count; ++i)\n\t\tdata32[i] = pj_swap32(data32[i]);\n\t} else {\n\t    pj_int16_t *data16 = (pj_int16_t *)data;\n\t    for (i=0; i<count; ++i)\n\t\tdata16[i] = pj_swap16(data16[i]);\n\t}\n\n    }\n    static void data_to_host2(void *data, pj_uint8_t nsizes,\n                              pj_uint8_t *sizes)\n    {\n\tunsigned i;\n        pj_int8_t *datap = (pj_int8_t *)data;\n        for (i = 0; i < nsizes; i++) {\n            data_to_host(datap, 32, sizes[i]);\n            datap += sizes[i++];\n            if (i >= nsizes)\n                break;\n            data_to_host(datap, 16, sizes[i]);\n            datap += sizes[i];\n\t}\n    }\n#else\n#   define data_to_host(data, bits, count)\n#   define data_to_host2(data, nsizes, sizes)\n#endif\n\ntypedef struct avi_fmt_info\n{\n    pjmedia_format_id   fmt_id;\n    pjmedia_format_id   eff_fmt_id;\n} avi_fmt_info;\n\nstatic avi_fmt_info avi_fmts[] =\n{\n    {PJMEDIA_FORMAT_MJPEG}, {PJMEDIA_FORMAT_H264},\n    {PJMEDIA_FORMAT_UYVY}, {PJMEDIA_FORMAT_YUY2},\n    {PJMEDIA_FORMAT_IYUV}, {PJMEDIA_FORMAT_I420},\n    {PJMEDIA_FORMAT_DIB}, {PJMEDIA_FORMAT_RGB24},\n    {PJMEDIA_FORMAT_RGB32},\n    {PJMEDIA_FORMAT_PACK('X','V','I','D'), PJMEDIA_FORMAT_MPEG4},\n    {PJMEDIA_FORMAT_PACK('x','v','i','d'), PJMEDIA_FORMAT_MPEG4},\n    {PJMEDIA_FORMAT_PACK('D','I','V','X'), PJMEDIA_FORMAT_MPEG4},\n    {PJMEDIA_FORMAT_PACK('F','M','P','4'), PJMEDIA_FORMAT_MPEG4},\n    {PJMEDIA_FORMAT_PACK('D','X','5','0'), PJMEDIA_FORMAT_MPEG4}\n};\n\nstruct pjmedia_avi_streams\n{\n    unsigned        num_streams;\n    pjmedia_port  **streams;\n};\n\nstruct avi_reader_port\n{\n    pjmedia_port     base;\n    unsigned         stream_id;\n    unsigned\t     options;\n    pjmedia_format_id fmt_id;\n    unsigned         usec_per_frame;\n    pj_uint16_t\t     bits_per_sample;\n    pj_bool_t\t     eof;\n    pj_off_t\t     fsize;\n    pj_off_t\t     start_data;\n    pj_uint8_t       pad;\n    pj_oshandle_t    fd;\n    pj_ssize_t       size_left;\n    pj_timestamp     next_ts;\n\n    pj_status_t\t   (*cb)(pjmedia_port*, void*);\n    pj_bool_t\t     subscribed;\n    void\t   (*cb2)(pjmedia_port*, void*);\n};\n\n\nstatic pj_status_t avi_get_frame(pjmedia_port *this_port, \n\t\t\t         pjmedia_frame *frame);\nstatic pj_status_t avi_on_destroy(pjmedia_port *this_port);\n\nstatic struct avi_reader_port *create_avi_port(pj_pool_t *pool)\n{\n    const pj_str_t name = pj_str(\"file\");\n    struct avi_reader_port *port;\n\n    port = PJ_POOL_ZALLOC_T(pool, struct avi_reader_port);\n    if (!port)\n\treturn NULL;\n\n    /* Put in default values.\n     * These will be overriden once the file is read.\n     */\n    pjmedia_port_info_init(&port->base.info, &name, SIGNATURE, \n\t\t\t   8000, 1, 16, 80);\n\n    port->fd = (pj_oshandle_t)(pj_ssize_t)-1;\n    port->base.get_frame = &avi_get_frame;\n    port->base.on_destroy = &avi_on_destroy;\n\n    return port;\n}\n\n#define file_read(fd, data, size) file_read2(fd, data, size, 32)\n#define file_read2(fd, data, size, bits) file_read3(fd, data, size, bits, NULL)\n\nstatic pj_status_t file_read3(pj_oshandle_t fd, void *data, pj_ssize_t size,\n                              pj_uint16_t bits, pj_ssize_t *psz_read)\n{\n    pj_ssize_t size_read = size, size_to_read = size;\n    pj_status_t status = pj_file_read(fd, data, &size_read);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    /* Normalize AVI header fields values from little-endian to host\n     * byte order.\n     */\n    if (bits > 0)\n        data_to_host(data, bits, size_read);\n\n    if (size_read != size_to_read) {\n        if (psz_read)\n            *psz_read = size_read;\n        return AVI_EOF;\n    }\n\n    return status;\n}\n\n/*\n * Create AVI player port.\n */\nPJ_DEF(pj_status_t)\npjmedia_avi_player_create_streams(pj_pool_t *pool,\n                                  const char *filename,\n\t\t\t\t  unsigned options,\n\t\t\t\t  pjmedia_avi_streams **p_streams)\n{\n    pjmedia_avi_hdr avi_hdr;\n    struct avi_reader_port *fport[PJMEDIA_AVI_MAX_NUM_STREAMS];\n    pj_off_t pos;\n    unsigned i, nstr = 0;\n    pj_status_t status = PJ_SUCCESS;\n\n    /* Check arguments. */\n    PJ_ASSERT_RETURN(pool && filename && p_streams, PJ_EINVAL);\n\n    /* Check the file really exists. */\n    if (!pj_file_exists(filename)) {\n\treturn PJ_ENOTFOUND;\n    }\n\n    /* Create fport instance. */\n    fport[0] = create_avi_port(pool);\n    if (!fport[0]) {\n\treturn PJ_ENOMEM;\n    }\n\n    /* Get the file size. */\n    fport[0]->fsize = pj_file_size(filename);\n\n    /* Size must be more than AVI header size */\n    if (fport[0]->fsize <= sizeof(riff_hdr_t) + sizeof(avih_hdr_t) + \n                           sizeof(strl_hdr_t))\n    {\n\treturn PJMEDIA_EINVALIMEDIATYPE;\n    }\n\n    /* Open file. */\n    status = pj_file_open(pool, filename, PJ_O_RDONLY, &fport[0]->fd);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Read the RIFF + AVIH header. */\n    status = file_read(fport[0]->fd, &avi_hdr,\n                       sizeof(riff_hdr_t) + sizeof(avih_hdr_t));\n    if (status != PJ_SUCCESS)\n        goto on_error;\n\n    /* Validate AVI file. */\n    if (!COMPARE_TAG(avi_hdr.riff_hdr.riff, PJMEDIA_AVI_RIFF_TAG) ||\n\t!COMPARE_TAG(avi_hdr.riff_hdr.avi, PJMEDIA_AVI_AVI_TAG) ||\n        !COMPARE_TAG(avi_hdr.avih_hdr.list_tag, PJMEDIA_AVI_LIST_TAG) ||\n        !COMPARE_TAG(avi_hdr.avih_hdr.hdrl_tag, PJMEDIA_AVI_HDRL_TAG) ||\n        !COMPARE_TAG(avi_hdr.avih_hdr.avih, PJMEDIA_AVI_AVIH_TAG))\n    {\n\tstatus = PJMEDIA_EINVALIMEDIATYPE;\n        goto on_error;\n    }\n\n    PJ_LOG(5, (THIS_FILE, \"The AVI file has %d streams.\",\n               avi_hdr.avih_hdr.num_streams));\n\n    /* Unsupported AVI format. */\n    if (avi_hdr.avih_hdr.num_streams > PJMEDIA_AVI_MAX_NUM_STREAMS) {\n        status = PJMEDIA_EAVIUNSUPP;\n        goto on_error;\n    }\n\n    /** \n     * TODO: Possibly unsupported AVI format.\n     * If you encounter this warning, verify whether the avi player\n     * is working properly.\n     */\n    if (avi_hdr.avih_hdr.flags & AVIF_MUSTUSEINDEX ||\n        avi_hdr.avih_hdr.pad > 1)\n    {\n        PJ_LOG(3, (THIS_FILE, \"Warning!!! Possibly unsupported AVI format: \"\n                   \"flags:%d, pad:%d\", avi_hdr.avih_hdr.flags, \n                   avi_hdr.avih_hdr.pad));\n    }\n\n    /* Read the headers of each stream. */\n    for (i = 0; i < avi_hdr.avih_hdr.num_streams; i++) {\n        pj_size_t elem = 0;\n        pj_ssize_t size_to_read;\n\n        /* Read strl header */\n        status = file_read(fport[0]->fd, &avi_hdr.strl_hdr[i],\n                           sizeof(strl_hdr_t));\n        if (status != PJ_SUCCESS)\n            goto on_error;\n        \n        elem = COMPARE_TAG(avi_hdr.strl_hdr[i].data_type, \n                           PJMEDIA_AVI_VIDS_TAG) ? \n               sizeof(strf_video_hdr_t) :\n               COMPARE_TAG(avi_hdr.strl_hdr[i].data_type, \n                           PJMEDIA_AVI_AUDS_TAG) ?\n               sizeof(strf_audio_hdr_t) : 0;\n\n        /* Read strf header */\n        status = file_read2(fport[0]->fd, &avi_hdr.strf_hdr[i],\n                            elem, 0);\n        if (status != PJ_SUCCESS)\n            goto on_error;\n\n        /* Normalize the endian */\n        if (elem == sizeof(strf_video_hdr_t))\n            data_to_host2(&avi_hdr.strf_hdr[i],\n                          sizeof(strf_video_hdr_sizes)/\n                          sizeof(strf_video_hdr_sizes[0]),\n                          strf_video_hdr_sizes);\n        else if (elem == sizeof(strf_audio_hdr_t))\n            data_to_host2(&avi_hdr.strf_hdr[i],\n                          sizeof(strf_audio_hdr_sizes)/\n                          sizeof(strf_audio_hdr_sizes[0]),\n                          strf_audio_hdr_sizes);\n\n        /* Skip the remainder of the header */\n        size_to_read = avi_hdr.strl_hdr[i].list_sz - (sizeof(strl_hdr_t) -\n                       8) - elem;\n\tstatus = pj_file_setpos(fport[0]->fd, size_to_read, PJ_SEEK_CUR);\n\tif (status != PJ_SUCCESS) {\n            goto on_error;\n\t}\n    }\n\n    /* Finish reading the AVIH header */\n    status = pj_file_setpos(fport[0]->fd, avi_hdr.avih_hdr.list_sz +\n                            sizeof(riff_hdr_t) + 8, PJ_SEEK_SET);\n    if (status != PJ_SUCCESS) {\n        goto on_error;\n    }\n\n    /* Skip any JUNK or LIST INFO until we get MOVI tag */\n    do {\n        pjmedia_avi_subchunk ch;\n        int read = 0;\n\n        status = file_read(fport[0]->fd, &ch, sizeof(pjmedia_avi_subchunk));\n        if (status != PJ_SUCCESS) {\n            goto on_error;\n        }\n\n        if (COMPARE_TAG(ch.id, PJMEDIA_AVI_LIST_TAG))\n        {\n            read = 4;\n            status = file_read(fport[0]->fd, &ch, read);\n            if (COMPARE_TAG(ch.id, PJMEDIA_AVI_MOVI_TAG))\n                break;\n        }\n\n        status = pj_file_setpos(fport[0]->fd, ch.len-read, PJ_SEEK_CUR);\n        if (status != PJ_SUCCESS) {\n            goto on_error;\n        }\n    } while(1);\n\n    status = pj_file_getpos(fport[0]->fd, &pos);\n    if (status != PJ_SUCCESS)\n        goto on_error;\n\n    for (i = 0, nstr = 0; i < avi_hdr.avih_hdr.num_streams; i++) {\n\tpjmedia_format_id fmt_id;\n\n        /* Skip non-audio, non-video, or disabled streams) */\n        if ((!COMPARE_TAG(avi_hdr.strl_hdr[i].data_type, \n                          PJMEDIA_AVI_VIDS_TAG) &&\n             !COMPARE_TAG(avi_hdr.strl_hdr[i].data_type, \n                          PJMEDIA_AVI_AUDS_TAG)) ||\n            avi_hdr.strl_hdr[i].flags & AVISF_DISABLED)\n        {\n            continue;\n        }\n\n        if (COMPARE_TAG(avi_hdr.strl_hdr[i].data_type, \n                        PJMEDIA_AVI_VIDS_TAG))\n        {\n            int j;\n\n            if (avi_hdr.strl_hdr[i].flags & AVISF_VIDEO_PALCHANGES) {\n                PJ_LOG(4, (THIS_FILE, \"Unsupported video stream\"));\n                continue;\n            }\n\n            fmt_id = avi_hdr.strl_hdr[i].codec;\n            for (j = sizeof(avi_fmts)/sizeof(avi_fmts[0])-1; j >= 0; j--) {\n                /* Check supported video formats here */\n                if (fmt_id == avi_fmts[j].fmt_id) {\n                    if (avi_fmts[j].eff_fmt_id)\n                        fmt_id = avi_fmts[j].eff_fmt_id;\n                    break;\n                }\n            }\n            \n            if (j < 0) {\n                PJ_LOG(4, (THIS_FILE, \"Unsupported video stream\"));\n                continue;\n            }\n        } else {\n            /* Check supported audio formats here */\n\t    strf_audio_hdr_t *hdr = (strf_audio_hdr_t*)\n\t\t\t\t    &avi_hdr.strf_hdr[i].strf_audio_hdr;\n            if (hdr->fmt_tag == PJMEDIA_WAVE_FMT_TAG_PCM &&\n\t\thdr->bits_per_sample == 16)\n\t    {\n\t\tfmt_id = PJMEDIA_FORMAT_PCM;\n\t    }\n\t    else if (hdr->fmt_tag == PJMEDIA_WAVE_FMT_TAG_ALAW)\n\t    {\n\t\tfmt_id = PJMEDIA_FORMAT_PCMA;\n\t    }\n\t    else if (hdr->fmt_tag == PJMEDIA_WAVE_FMT_TAG_ULAW)\n\t    {\n\t\tfmt_id = PJMEDIA_FORMAT_PCMU;\n\t    }\n\t    else\n            {\n                PJ_LOG(4, (THIS_FILE, \"Unsupported audio stream\"));\n                continue;\n            }\n        }\n\n        if (nstr > 0) {\n            /* Create fport instance. */\n            fport[nstr] = create_avi_port(pool);\n            if (!fport[nstr]) {\n\t        status = PJ_ENOMEM;\n                goto on_error;\n            }\n\n            /* Open file. */\n            status = pj_file_open(pool, filename, PJ_O_RDONLY,\n                                  &fport[nstr]->fd);\n            if (status != PJ_SUCCESS)\n                goto on_error;\n\n            /* Set the file position */\n            status = pj_file_setpos(fport[nstr]->fd, pos, PJ_SEEK_SET);\n            if (status != PJ_SUCCESS) {\n                goto on_error;\n            }\n        }\n\n        fport[nstr]->stream_id = i;\n        fport[nstr]->fmt_id = fmt_id;\n\n        nstr++;\n    }\n\n    if (nstr == 0) {\n        status = PJMEDIA_EAVIUNSUPP;\n        goto on_error;\n    }\n\n    for (i = 0; i < nstr; i++) {\n        strl_hdr_t *strl_hdr = &avi_hdr.strl_hdr[fport[i]->stream_id];\n\n        /* Initialize */\n        fport[i]->options = options;\n        fport[i]->fsize = fport[0]->fsize;\n        /* Current file position now points to start of data */\n        fport[i]->start_data = pos;\n        \n        if (COMPARE_TAG(strl_hdr->data_type, PJMEDIA_AVI_VIDS_TAG)) {\n            strf_video_hdr_t *strf_hdr =\n                &avi_hdr.strf_hdr[fport[i]->stream_id].strf_video_hdr;\n            const pjmedia_video_format_info *vfi;\n\n            vfi = pjmedia_get_video_format_info(\n                pjmedia_video_format_mgr_instance(),\n                strl_hdr->codec);\n\n            fport[i]->bits_per_sample = (vfi ? vfi->bpp : 0);\n            fport[i]->usec_per_frame = avi_hdr.avih_hdr.usec_per_frame;\n            pjmedia_format_init_video(&fport[i]->base.info.fmt,\n                                      fport[i]->fmt_id,\n                                      strf_hdr->biWidth,\n                                      strf_hdr->biHeight,\n                                      strl_hdr->rate,\n                                      strl_hdr->scale);\n#if 0\n            /* The calculation below is wrong. strf_hdr->biSizeImage shows\n             * uncompressed size. Looks like we need to go the ugly way to\n             * get the bitrage:\n             *    http://www.virtualdub.org/blog/pivot/entry.php?id=159\n             */\n            bps = strf_hdr->biSizeImage * 8 * strl_hdr->rate / strl_hdr->scale;\n            if (bps==0) {\n        \t/* strf_hdr->biSizeImage may be zero for uncompressed RGB */\n        \tbps = strf_hdr->biWidth * strf_hdr->biHeight *\n        \t\tstrf_hdr->biBitCount *\n        \t\tstrl_hdr->rate / strl_hdr->scale;\n            }\n            fport[i]->base.info.fmt.det.vid.avg_bps = bps;\n            fport[i]->base.info.fmt.det.vid.max_bps = bps;\n#endif\n        } else {\n            strf_audio_hdr_t *strf_hdr =\n                &avi_hdr.strf_hdr[fport[i]->stream_id].strf_audio_hdr;\n\n            fport[i]->bits_per_sample = strf_hdr->bits_per_sample;\n            fport[i]->usec_per_frame = avi_hdr.avih_hdr.usec_per_frame;\n            pjmedia_format_init_audio(&fport[i]->base.info.fmt,\n                                      fport[i]->fmt_id,\n                                      strf_hdr->sample_rate,\n                                      strf_hdr->nchannels,\n                                      strf_hdr->bits_per_sample,\n                                      20000 /* fport[i]->usec_per_frame */,\n                                      strf_hdr->bytes_per_sec * 8,\n                                      strf_hdr->bytes_per_sec * 8);\n\n\t    /* Set format to PCM (we will decode PCMA/U) */\n\t    if (fport[i]->fmt_id == PJMEDIA_FORMAT_PCMA ||\n\t\tfport[i]->fmt_id == PJMEDIA_FORMAT_PCMU)\n\t    {\n\t\tfport[i]->base.info.fmt.id = PJMEDIA_FORMAT_PCM;\n\t\tfport[i]->base.info.fmt.det.aud.bits_per_sample = 16;\n\t    }\n\t}\n\n        pj_strdup2(pool, &fport[i]->base.info.name, filename);\n    }\n\n    /* Done. */\n    *p_streams = pj_pool_alloc(pool, sizeof(pjmedia_avi_streams));\n    (*p_streams)->num_streams = nstr;\n    (*p_streams)->streams = pj_pool_calloc(pool, (*p_streams)->num_streams,\n                                           sizeof(pjmedia_port *));\n    for (i = 0; i < nstr; i++)\n        (*p_streams)->streams[i] = &fport[i]->base;\n\n    PJ_LOG(4,(THIS_FILE, \n\t      \"AVI file player '%.*s' created with \"\n\t      \"%d media ports\",\n\t      (int)fport[0]->base.info.name.slen,\n\t      fport[0]->base.info.name.ptr,\n              (*p_streams)->num_streams));\n\n    return PJ_SUCCESS;\n\non_error:\n    fport[0]->base.on_destroy(&fport[0]->base);\n    for (i = 1; i < nstr; i++)\n        fport[i]->base.on_destroy(&fport[i]->base);\n    if (status == AVI_EOF)\n        return PJMEDIA_EINVALIMEDIATYPE;\n    return status;\n}\n\nPJ_DEF(unsigned)\npjmedia_avi_streams_get_num_streams(pjmedia_avi_streams *streams)\n{\n    pj_assert(streams);\n    return streams->num_streams;\n}\n\nPJ_DEF(pjmedia_avi_stream *)\npjmedia_avi_streams_get_stream(pjmedia_avi_streams *streams,\n                               unsigned idx)\n{\n    pj_assert(streams);\n    return (idx < streams->num_streams ? streams->streams[idx] : NULL);\n}\n\nPJ_DEF(pjmedia_avi_stream *)\npjmedia_avi_streams_get_stream_by_media(pjmedia_avi_streams *streams,\n                                        unsigned start_idx,\n                                        pjmedia_type media_type)\n{\n    unsigned i;\n\n    pj_assert(streams);\n    for (i = start_idx; i < streams->num_streams; i++)\n        if (streams->streams[i]->info.fmt.type == media_type)\n            return streams->streams[i];\n    return NULL;\n}\n\n\n/*\n * Get the data length, in bytes.\n */\nPJ_DEF(pj_ssize_t) pjmedia_avi_stream_get_len(pjmedia_avi_stream *stream)\n{\n    struct avi_reader_port *fport;\n\n    /* Sanity check */\n    PJ_ASSERT_RETURN(stream, -PJ_EINVAL);\n\n    /* Check that this is really a player port */\n    PJ_ASSERT_RETURN(stream->info.signature == SIGNATURE, -PJ_EINVALIDOP);\n\n    fport = (struct avi_reader_port*) stream;\n\n    return (pj_ssize_t)(fport->fsize - fport->start_data);\n}\n\n\n#if !DEPRECATED_FOR_TICKET_2251\n/*\n * Register a callback to be called when the file reading has reached the\n * end of file.\n */\nPJ_DEF(pj_status_t)\npjmedia_avi_stream_set_eof_cb( pjmedia_avi_stream *stream,\n\t\t\t       void *user_data,\n\t\t\t       pj_status_t (*cb)(pjmedia_avi_stream *stream,\n\t\t\t\t\t\t void *usr_data))\n{\n    struct avi_reader_port *fport;\n\n    /* Sanity check */\n    PJ_ASSERT_RETURN(stream, -PJ_EINVAL);\n\n    /* Check that this is really a player port */\n    PJ_ASSERT_RETURN(stream->info.signature == SIGNATURE, -PJ_EINVALIDOP);\n\n    PJ_LOG(1, (THIS_FILE, \"pjmedia_avi_stream_set_eof_cb() is deprecated. \"\n    \t       \"Use pjmedia_avi_stream_set_eof_cb2() instead.\"));\n\n    fport = (struct avi_reader_port*) stream;\n\n    fport->base.port_data.pdata = user_data;\n    fport->cb = cb;\n\n    return PJ_SUCCESS;\n}\n#endif\n\n\n/*\n * Register a callback to be called when the file reading has reached the\n * end of file.\n */\nPJ_DEF(pj_status_t)\npjmedia_avi_stream_set_eof_cb2(pjmedia_avi_stream *stream,\n\t\t\t       void *user_data,\n\t\t\t       void (*cb)(pjmedia_avi_stream *stream,\n\t\t\t\t\t  void *usr_data))\n{\n    struct avi_reader_port *fport;\n\n    /* Sanity check */\n    PJ_ASSERT_RETURN(stream, -PJ_EINVAL);\n\n    /* Check that this is really a player port */\n    PJ_ASSERT_RETURN(stream->info.signature == SIGNATURE, -PJ_EINVALIDOP);\n\n    fport = (struct avi_reader_port*) stream;\n\n    fport->base.port_data.pdata = user_data;\n    fport->cb2 = cb;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic pj_status_t file_on_event(pjmedia_event *event,\n                                 void *user_data)\n{\n    struct avi_reader_port *fport = (struct avi_reader_port*)user_data;\n\n    if (event->type == PJMEDIA_EVENT_CALLBACK) {\n\tif (fport->cb2)\n\t    (*fport->cb2)(&fport->base, fport->base.port_data.pdata);\n    }\n    \n    return PJ_SUCCESS;\n}\n\n\n/*\n * Get frame from file.\n */\nstatic pj_status_t avi_get_frame(pjmedia_port *this_port, \n\t\t\t         pjmedia_frame *frame)\n{\n    struct avi_reader_port *fport = (struct avi_reader_port*)this_port;\n    pj_status_t status = PJ_SUCCESS;\n    pj_ssize_t size_read = 0, size_to_read = 0;\n\n    pj_assert(fport->base.info.signature == SIGNATURE);\n\n    /* We encountered end of file */\n    if (fport->eof) {\n\tPJ_LOG(5,(THIS_FILE, \"File port %.*s EOF\",\n\t\t  (int)fport->base.info.name.slen,\n\t\t  fport->base.info.name.ptr));\n\n\t/* Call callback, if any */\n\tif (fport->cb2) {\n\t    pj_bool_t no_loop = (fport->options & PJMEDIA_AVI_FILE_NO_LOOP);\n\n\t    if (!fport->subscribed) {\n\t    \tstatus = pjmedia_event_subscribe(NULL, &file_on_event,\n\t    \t\t\t\t         fport, fport);\n\t    \tfport->subscribed = (status == PJ_SUCCESS)? PJ_TRUE:\n\t    \t\t\t    PJ_FALSE;\n\t    }\n\n\t    if (fport->subscribed && fport->eof != 2) {\n\t    \tpjmedia_event event;\n\n\t    \tif (no_loop) {\n\t    \t    /* To prevent the callback from being called repeatedly */\n\t    \t    fport->eof = 2;\n\t    \t} else {\n\t    \t    fport->eof = PJ_FALSE;\n        \t    pj_file_setpos(fport->fd, fport->start_data, PJ_SEEK_SET);\n\t    \t}\n\n\t    \tpjmedia_event_init(&event, PJMEDIA_EVENT_CALLBACK,\n\t                      \t   NULL, fport);\n\t    \tpjmedia_event_publish(NULL, fport, &event,\n\t                              PJMEDIA_EVENT_PUBLISH_POST_EVENT);\n\t    }\n\t    \n\t    /* Should not access player port after this since\n\t     * it might have been destroyed by the callback.\n\t     */\n\t    frame->type = PJMEDIA_FRAME_TYPE_NONE;\n\t    frame->size = 0;\n\t    \n\t    return (no_loop? PJ_EEOF: PJ_SUCCESS);\n\n\t} else if (fport->cb) {\n\t    status = (*fport->cb)(this_port, fport->base.port_data.pdata);\n\t}\n\n\t/* If callback returns non PJ_SUCCESS or 'no loop' is specified,\n\t * return immediately (and don't try to access player port since\n\t * it might have been destroyed by the callback).\n\t */\n\tif ((status != PJ_SUCCESS) ||\n            (fport->options & PJMEDIA_AVI_FILE_NO_LOOP)) \n        {\n\t    frame->type = PJMEDIA_FRAME_TYPE_NONE;\n\t    frame->size = 0;\n\t    return PJ_EEOF;\n\t}\n\n        /* Rewind file */\n\tPJ_LOG(5,(THIS_FILE, \"File port %.*s rewinding..\",\n\t\t  (int)fport->base.info.name.slen,\n\t\t  fport->base.info.name.ptr));\n\tfport->eof = PJ_FALSE;\n        pj_file_setpos(fport->fd, fport->start_data, PJ_SEEK_SET);\n    }\n\n    /* For PCMU/A audio stream, reduce frame size to half (temporarily). */\n    if (fport->base.info.fmt.type == PJMEDIA_TYPE_AUDIO &&\n\t(fport->fmt_id == PJMEDIA_FORMAT_PCMA ||\n\t fport->fmt_id == PJMEDIA_FORMAT_PCMU))\n    {\n\tframe->size >>= 1;\n    }\n\n    /* Fill frame buffer. */\n    size_to_read = frame->size;\n    do {\n        pjmedia_avi_subchunk ch = {0, 0};\n        char *cid;\n        unsigned stream_id;\n\n        /* We need to read data from the file past the chunk boundary */\n        if (fport->size_left > 0 && fport->size_left < size_to_read) {\n            status = file_read3(fport->fd, frame->buf, fport->size_left,\n                                fport->bits_per_sample, &size_read);\n            if (status != PJ_SUCCESS)\n                goto on_error2;\n            size_to_read -= fport->size_left;\n            fport->size_left = 0;\n        }\n\n        /* Read new chunk data */\n        if (fport->size_left == 0) {\n            pj_off_t pos;\n            pj_file_getpos(fport->fd, &pos);\n\n            /* Data is padded to the nearest WORD boundary */\n            if (fport->pad) {\n                status = pj_file_setpos(fport->fd, fport->pad, PJ_SEEK_CUR);\n                fport->pad = 0;\n            }\n\n            status = file_read(fport->fd, &ch, sizeof(pjmedia_avi_subchunk));\n            if (status != PJ_SUCCESS) {\n                size_read = 0;\n                goto on_error2;\n            }\n\n            cid = (char *)&ch.id;\n            if (cid[0] >= '0' && cid[0] <= '9' &&\n                cid[1] >= '0' && cid[1] <= '9') \n            {\n                stream_id = (cid[0] - '0') * 10 + (cid[1] - '0');\n            } else\n                stream_id = 100;\n            fport->pad = (pj_uint8_t)ch.len & 1;\n\n            TRACE_((THIS_FILE, \"Reading movi data at pos %u (%x), id: %.*s, \"\n                               \"length: %u\", (unsigned long)pos,\n                               (unsigned long)pos, 4, cid, ch.len));\n\n            /* We are only interested in data with our stream id */\n            if (stream_id != fport->stream_id) {\n                if (COMPARE_TAG(ch.id, PJMEDIA_AVI_LIST_TAG))\n                    PJ_LOG(5, (THIS_FILE, \"Unsupported LIST tag found in \"\n                                          \"the movi data.\"));\n                else if (COMPARE_TAG(ch.id, PJMEDIA_AVI_RIFF_TAG)) {\n                    PJ_LOG(3, (THIS_FILE, \"Unsupported format: multiple \"\n                           \"AVIs in a single file.\"));\n                    status = AVI_EOF;\n                    goto on_error2;\n                }\n\n                status = pj_file_setpos(fport->fd, ch.len,\n                                        PJ_SEEK_CUR);\n                continue;\n            }\n            fport->size_left = ch.len;\n        }\n\n        frame->type = (fport->base.info.fmt.type == PJMEDIA_TYPE_VIDEO ?\n                       PJMEDIA_FRAME_TYPE_VIDEO : PJMEDIA_FRAME_TYPE_AUDIO);\n\n        if (frame->type == PJMEDIA_FRAME_TYPE_AUDIO) {\n            if (size_to_read > fport->size_left)\n                size_to_read = fport->size_left;\n            status = file_read3(fport->fd, (char *)frame->buf + frame->size -\n                                size_to_read, size_to_read,\n                                fport->bits_per_sample, &size_read);\n            if (status != PJ_SUCCESS)\n                goto on_error2;\n            fport->size_left -= size_to_read;\n        } else {\n            pj_assert(frame->size >= ch.len);\n            status = file_read3(fport->fd, frame->buf, ch.len,\n                                0, &size_read);\n            if (status != PJ_SUCCESS)\n                goto on_error2;\n            frame->size = ch.len;\n            fport->size_left = 0;\n        }\n\n        break;\n\n    } while(1);\n    frame->timestamp.u64 = fport->next_ts.u64;\n    if (frame->type == PJMEDIA_FRAME_TYPE_AUDIO) {\n\n\t/* Decode PCMU/A frame */\n\tif (fport->fmt_id == PJMEDIA_FORMAT_PCMA ||\n\t    fport->fmt_id == PJMEDIA_FORMAT_PCMU)\n\t{\n\t    unsigned i;\n\t    pj_uint16_t *dst;\n\t    pj_uint8_t *src;\n\n\t    dst = (pj_uint16_t*)frame->buf + frame->size - 1;\n\t    src = (pj_uint8_t*)frame->buf + frame->size - 1;\n\n\t    if (fport->fmt_id == PJMEDIA_FORMAT_PCMU) {\n\t\tfor (i = 0; i < frame->size; ++i) {\n\t\t    *dst-- = (pj_uint16_t) pjmedia_ulaw2linear(*src--);\n\t\t}\n\t    } else {\n\t\tfor (i = 0; i < frame->size; ++i) {\n\t\t    *dst-- = (pj_uint16_t) pjmedia_alaw2linear(*src--);\n\t\t}\n\t    }\n\n\t    /* Return back the frame size */\n\t    frame->size <<= 1;\n\t}\n\n\tif (fport->usec_per_frame) {\n\t    fport->next_ts.u64 += (fport->usec_per_frame *\n\t\t\t\t   fport->base.info.fmt.det.aud.clock_rate /\n\t\t\t\t   1000000);\n\t} else {\n\t    fport->next_ts.u64 += (frame->size *\n\t\t\t\t   fport->base.info.fmt.det.aud.clock_rate /\n\t\t\t\t   (fport->base.info.fmt.det.aud.avg_bps / 8));\n\t}\n    } else {\n\tif (fport->usec_per_frame) {\n\t    fport->next_ts.u64 += (fport->usec_per_frame * VIDEO_CLOCK_RATE /\n\t\t\t\t   1000000);\n\t} else {\n\t    fport->next_ts.u64 += (frame->size * VIDEO_CLOCK_RATE /\n\t\t\t\t   (fport->base.info.fmt.det.vid.avg_bps / 8));\n\t}\n    }\n\n    return PJ_SUCCESS;\n\non_error2:\n    if (status == AVI_EOF) {\n        fport->eof = PJ_TRUE;\n\n        size_to_read -= size_read;\n        if (size_to_read == (pj_ssize_t)frame->size) {\n            /* Frame is empty */\n \t    frame->type = PJMEDIA_FRAME_TYPE_NONE;\n\t    frame->size = 0;\n\t    return PJ_EEOF;           \n        }\n        pj_bzero((char *)frame->buf + frame->size - size_to_read,\n                 size_to_read);\n\n        return PJ_SUCCESS;\n    }\n\n    return status;\n}\n\n/*\n * Destroy port.\n */\nstatic pj_status_t avi_on_destroy(pjmedia_port *this_port)\n{\n    struct avi_reader_port *fport = (struct avi_reader_port*) this_port;\n\n    pj_assert(this_port->info.signature == SIGNATURE);\n\n    if (fport->subscribed) {\n    \tpjmedia_event_unsubscribe(NULL, &file_on_event, fport, fport);\n    \tfport->subscribed = PJ_FALSE;\n    }\n\n    if (fport->fd != (pj_oshandle_t) (pj_ssize_t)-1)\n        pj_file_close(fport->fd);\n    return PJ_SUCCESS;\n}\n\n\n#endif /* PJMEDIA_HAS_VIDEO */\n", "/* $Id$ */\n/* \n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n#include <pjmedia/wav_port.h>\n#include <pjmedia/alaw_ulaw.h>\n#include <pjmedia/errno.h>\n#include <pjmedia/wave.h>\n#include <pj/assert.h>\n#include <pj/file_access.h>\n#include <pj/file_io.h>\n#include <pj/log.h>\n#include <pj/pool.h>\n#include <pj/string.h>\n\n\n#define THIS_FILE   \"wav_player.c\"\n\n\n#define SIGNATURE\t    PJMEDIA_SIG_PORT_WAV_PLAYER\n#define BITS_PER_SAMPLE\t    16\n\n#if 1\n#   define TRACE_(x)\tPJ_LOG(4,x)\n#else\n#   define TRACE_(x)\n#endif\n\n#if defined(PJ_IS_BIG_ENDIAN) && PJ_IS_BIG_ENDIAN!=0\n    static void samples_to_host(pj_int16_t *samples, unsigned count)\n    {\n\tunsigned i;\n\tfor (i=0; i<count; ++i) {\n\t    samples[i] = pj_swap16(samples[i]);\n\t}\n    }\n#else\n#   define samples_to_host(samples,count)\n#endif\n\nstruct file_reader_port\n{\n    pjmedia_port     base;\n    unsigned\t     options;\n    pjmedia_wave_fmt_tag fmt_tag;\n    pj_uint16_t\t     bytes_per_sample;\n    pj_bool_t\t     eof;\n    pj_uint32_t\t     bufsize;\n    char\t    *buf;\n    char\t    *readpos;\n    char\t    *eofpos;\n\n    pj_off_t\t     fsize;\n    unsigned\t     start_data;\n    unsigned         data_len;\n    unsigned         data_left;\n    pj_off_t\t     fpos;\n    pj_oshandle_t    fd;\n\n    pj_status_t\t   (*cb)(pjmedia_port*, void*);\n    pj_bool_t\t     subscribed;\n    void\t   (*cb2)(pjmedia_port*, void*);\n};\n\n\nstatic pj_status_t file_get_frame(pjmedia_port *this_port, \n\t\t\t\t  pjmedia_frame *frame);\nstatic pj_status_t file_on_destroy(pjmedia_port *this_port);\n\nstatic struct file_reader_port *create_file_port(pj_pool_t *pool)\n{\n    const pj_str_t name = pj_str(\"file\");\n    struct file_reader_port *port;\n\n    port = PJ_POOL_ZALLOC_T(pool, struct file_reader_port);\n    if (!port)\n\treturn NULL;\n\n    /* Put in default values.\n     * These will be overriden once the file is read.\n     */\n    pjmedia_port_info_init(&port->base.info, &name, SIGNATURE, \n\t\t\t   8000, 1, 16, 80);\n\n    port->base.get_frame = &file_get_frame;\n    port->base.on_destroy = &file_on_destroy;\n\n\n    return port;\n}\n\n/*\n * Fill buffer.\n */\nstatic pj_status_t fill_buffer(struct file_reader_port *fport)\n{\n    pj_uint32_t size_left = fport->bufsize;\n    unsigned size_to_read;\n    pj_ssize_t size;\n    pj_status_t status;\n\n    fport->eofpos = NULL;\n    \n    while (size_left > 0) {\n\n\t/* Calculate how many bytes to read in this run. */\n\tsize = size_to_read = size_left;\n\tstatus = pj_file_read(fport->fd, \n\t\t\t      &fport->buf[fport->bufsize-size_left], \n\t\t\t      &size);\n\tif (status != PJ_SUCCESS)\n\t    return status;\n\tif (size < 0) {\n\t    /* Should return more appropriate error code here.. */\n\t    return PJ_ECANCELLED;\n\t}\n\n        if (size > (pj_ssize_t)fport->data_left) {\n            /* We passed the end of the data chunk,\n             * only count the portion read from the data chunk.\n             */\n            size = (pj_ssize_t)fport->data_left;\n        }\n\n\tsize_left -= (pj_uint32_t)size;\n        fport->data_left -= (pj_uint32_t)size;\n\tfport->fpos += size;\n\n\t/* If size is less than size_to_read, it indicates that we've\n\t * encountered EOF. Rewind the file.\n\t */\n        if (size < (pj_ssize_t)size_to_read) {\n            fport->eof = PJ_TRUE;\n            fport->eofpos = fport->buf + fport->bufsize - size_left;\n\n            if (fport->options & PJMEDIA_FILE_NO_LOOP) {\n                /* Zero remaining buffer */\n                if (fport->fmt_tag == PJMEDIA_WAVE_FMT_TAG_PCM) {\n                    pj_bzero(fport->eofpos, size_left);\n                } else if (fport->fmt_tag == PJMEDIA_WAVE_FMT_TAG_ULAW) {\n                    int val = pjmedia_linear2ulaw(0);\n                    pj_memset(fport->eofpos, val, size_left);\n                } else if (fport->fmt_tag == PJMEDIA_WAVE_FMT_TAG_ALAW) {\n                    int val = pjmedia_linear2alaw(0);\n                    pj_memset(fport->eofpos, val, size_left);\n                }\n\t\tsize_left = 0;\n            }\n\n\t    /* Rewind file */\n\t    fport->fpos = fport->start_data;\n\t    pj_file_setpos( fport->fd, fport->fpos, PJ_SEEK_SET);\n            fport->data_left = fport->data_len;\n\t}\n    }\n\n    /* Convert samples to host rep */\n    samples_to_host((pj_int16_t*)fport->buf, \n\t\t    fport->bufsize/fport->bytes_per_sample);\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Create WAVE player port.\n */\nPJ_DEF(pj_status_t) pjmedia_wav_player_port_create( pj_pool_t *pool,\n\t\t\t\t\t\t     const char *filename,\n\t\t\t\t\t\t     unsigned ptime,\n\t\t\t\t\t\t     unsigned options,\n\t\t\t\t\t\t     pj_ssize_t buff_size,\n\t\t\t\t\t\t     pjmedia_port **p_port )\n{\n    pjmedia_wave_hdr wave_hdr;\n    pj_ssize_t size_to_read, size_read;\n    struct file_reader_port *fport;\n    pjmedia_audio_format_detail *ad;\n    pj_off_t pos;\n    pj_str_t name;\n    unsigned samples_per_frame;\n    pj_status_t status = PJ_SUCCESS;\n\n\n    /* Check arguments. */\n    PJ_ASSERT_RETURN(pool && filename && p_port, PJ_EINVAL);\n\n    /* Check the file really exists. */\n    if (!pj_file_exists(filename)) {\n\treturn PJ_ENOTFOUND;\n    }\n\n    /* Normalize ptime */\n    if (ptime == 0)\n\tptime = 20;\n\n    /* Normalize buff_size */\n    if (buff_size < 1) buff_size = PJMEDIA_FILE_PORT_BUFSIZE;\n\n\n    /* Create fport instance. */\n    fport = create_file_port(pool);\n    if (!fport) {\n\treturn PJ_ENOMEM;\n    }\n\n\n    /* Get the file size. */\n    fport->fsize = pj_file_size(filename);\n\n    /* Size must be more than WAVE header size */\n    if (fport->fsize <= sizeof(pjmedia_wave_hdr)) {\n\treturn PJMEDIA_ENOTVALIDWAVE;\n    }\n\n    /* Open file. */\n    status = pj_file_open( pool, filename, PJ_O_RDONLY, &fport->fd);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Read the file header plus fmt header only. */\n    size_read = size_to_read = sizeof(wave_hdr) - 8;\n    status = pj_file_read( fport->fd, &wave_hdr, &size_read);\n    if (status != PJ_SUCCESS) {\n\tpj_file_close(fport->fd);\n\treturn status;\n    }\n    if (size_read != size_to_read) {\n\tpj_file_close(fport->fd);\n\treturn PJMEDIA_ENOTVALIDWAVE;\n    }\n\n    /* Normalize WAVE header fields values from little-endian to host\n     * byte order.\n     */\n    pjmedia_wave_hdr_file_to_host(&wave_hdr);\n    \n    /* Validate WAVE file. */\n    if (wave_hdr.riff_hdr.riff != PJMEDIA_RIFF_TAG ||\n\twave_hdr.riff_hdr.wave != PJMEDIA_WAVE_TAG ||\n\twave_hdr.fmt_hdr.fmt != PJMEDIA_FMT_TAG)\n    {\n\tpj_file_close(fport->fd);\n\tTRACE_((THIS_FILE, \n\t\t\"actual value|expected riff=%x|%x, wave=%x|%x fmt=%x|%x\",\n\t\twave_hdr.riff_hdr.riff, PJMEDIA_RIFF_TAG,\n\t\twave_hdr.riff_hdr.wave, PJMEDIA_WAVE_TAG,\n\t\twave_hdr.fmt_hdr.fmt, PJMEDIA_FMT_TAG));\n\treturn PJMEDIA_ENOTVALIDWAVE;\n    }\n\n    /* Validate format and its attributes (i.e: bits per sample, block align) */\n    switch (wave_hdr.fmt_hdr.fmt_tag) {\n    case PJMEDIA_WAVE_FMT_TAG_PCM:\n\tif (wave_hdr.fmt_hdr.bits_per_sample != 16 || \n\t    wave_hdr.fmt_hdr.block_align != 2 * wave_hdr.fmt_hdr.nchan)\n\t    status = PJMEDIA_EWAVEUNSUPP;\n\tbreak;\n\n    case PJMEDIA_WAVE_FMT_TAG_ALAW:\n    case PJMEDIA_WAVE_FMT_TAG_ULAW:\n\tif (wave_hdr.fmt_hdr.bits_per_sample != 8 ||\n\t    wave_hdr.fmt_hdr.block_align != wave_hdr.fmt_hdr.nchan)\n\t    status = PJMEDIA_ENOTVALIDWAVE;\n\tbreak;\n\n    default:\n\tstatus = PJMEDIA_EWAVEUNSUPP;\n\tbreak;\n    }\n\n    if (status != PJ_SUCCESS) {\n\tpj_file_close(fport->fd);\n\treturn status;\n    }\n\n    fport->fmt_tag = (pjmedia_wave_fmt_tag)wave_hdr.fmt_hdr.fmt_tag;\n    fport->bytes_per_sample = (pj_uint16_t) \n\t\t\t      (wave_hdr.fmt_hdr.bits_per_sample / 8);\n\n    /* If length of fmt_header is greater than 16, skip the remaining\n     * fmt header data.\n     */\n    if (wave_hdr.fmt_hdr.len > 16) {\n\tsize_to_read = wave_hdr.fmt_hdr.len - 16;\n\tstatus = pj_file_setpos(fport->fd, size_to_read, PJ_SEEK_CUR);\n\tif (status != PJ_SUCCESS) {\n\t    pj_file_close(fport->fd);\n\t    return status;\n\t}\n    }\n\n    /* Repeat reading the WAVE file until we have 'data' chunk */\n    for (;;) {\n\tpjmedia_wave_subchunk subchunk;\n\tsize_read = 8;\n\tstatus = pj_file_read(fport->fd, &subchunk, &size_read);\n\tif (status != PJ_SUCCESS || size_read != 8) {\n\t    pj_file_close(fport->fd);\n\t    return PJMEDIA_EWAVETOOSHORT;\n\t}\n\n\t/* Normalize endianness */\n\tPJMEDIA_WAVE_NORMALIZE_SUBCHUNK(&subchunk);\n\n\t/* Break if this is \"data\" chunk */\n\tif (subchunk.id == PJMEDIA_DATA_TAG) {\n\t    wave_hdr.data_hdr.data = PJMEDIA_DATA_TAG;\n\t    wave_hdr.data_hdr.len = subchunk.len;\n\t    break;\n\t}\n\n\t/* Otherwise skip the chunk contents */\n\tsize_to_read = subchunk.len;\n\tstatus = pj_file_setpos(fport->fd, size_to_read, PJ_SEEK_CUR);\n\tif (status != PJ_SUCCESS) {\n\t    pj_file_close(fport->fd);\n\t    return status;\n\t}\n    }\n\n    /* Current file position now points to start of data */\n    status = pj_file_getpos(fport->fd, &pos);\n    fport->start_data = (unsigned)pos;\n    fport->data_len = wave_hdr.data_hdr.len;\n    fport->data_left = wave_hdr.data_hdr.len;\n\n    /* Validate length. */\n    if (wave_hdr.data_hdr.len > fport->fsize - fport->start_data) {\n    \t/* Actual data length may be shorter than declared. We should still\n    \t * try to play whatever data is there instead of immediately returning\n    \t * error.\n    \t */\n    \twave_hdr.data_hdr.len = (pj_uint32_t)fport->fsize - fport->start_data;\n\t// pj_file_close(fport->fd);\n\t// return PJMEDIA_EWAVEUNSUPP;\n    }\n    if (wave_hdr.data_hdr.len < ptime * wave_hdr.fmt_hdr.sample_rate *\n\t\t\t\twave_hdr.fmt_hdr.nchan / 1000)\n    {\n\tpj_file_close(fport->fd);\n\treturn PJMEDIA_EWAVETOOSHORT;\n    }\n\n    /* It seems like we have a valid WAVE file. */\n\n    /* Initialize */\n    fport->options = options;\n\n    /* Update port info. */\n    ad = pjmedia_format_get_audio_format_detail(&fport->base.info.fmt, 1);\n    pj_strdup2(pool, &name, filename);\n    samples_per_frame = ptime * wave_hdr.fmt_hdr.sample_rate *\n\t\t        wave_hdr.fmt_hdr.nchan / 1000;\n    pjmedia_port_info_init(&fport->base.info, &name, SIGNATURE,\n\t\t\t   wave_hdr.fmt_hdr.sample_rate,\n\t\t\t   wave_hdr.fmt_hdr.nchan,\n\t\t\t   BITS_PER_SAMPLE,\n\t\t\t   samples_per_frame);\n\n    /* If file is shorter than buffer size, adjust buffer size to file\n     * size. Otherwise EOF callback will be called multiple times when\n     * fill_buffer() is called.\n     */\n    if (wave_hdr.data_hdr.len < (unsigned)buff_size)\n\tbuff_size = wave_hdr.data_hdr.len;\n\n    /* Create file buffer.\n     */\n    fport->bufsize = (pj_uint32_t)buff_size;\n\n\n    /* samples_per_frame must be smaller than bufsize (because get_frame()\n     * doesn't handle this case).\n     */\n    if (samples_per_frame * fport->bytes_per_sample >= fport->bufsize) {\n\tpj_file_close(fport->fd);\n\treturn PJ_EINVAL;\n    }\n\n    /* Create buffer. */\n    fport->buf = (char*) pj_pool_alloc(pool, fport->bufsize);\n    if (!fport->buf) {\n\tpj_file_close(fport->fd);\n\treturn PJ_ENOMEM;\n    }\n \n    fport->readpos = fport->buf;\n\n    /* Set initial position of the file. */\n    fport->fpos = fport->start_data;\n\n    /* Fill up the buffer. */\n    status = fill_buffer(fport);\n    if (status != PJ_SUCCESS) {\n\tpj_file_close(fport->fd);\n\treturn status;\n    }\n\n    /* Done. */\n\n    *p_port = &fport->base;\n\n\n    PJ_LOG(4,(THIS_FILE, \n\t      \"File player '%.*s' created: samp.rate=%d, ch=%d, bufsize=%uKB, \"\n\t      \"filesize=%luKB\",\n\t      (int)fport->base.info.name.slen,\n\t      fport->base.info.name.ptr,\n\t      ad->clock_rate,\n\t      ad->channel_count,\n\t      fport->bufsize / 1000,\n\t      (unsigned long)(fport->fsize / 1000)));\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Get additional info about the file player.\n */\nPJ_DEF(pj_status_t) pjmedia_wav_player_get_info(\n\t\t\t\t\tpjmedia_port *port,\n\t\t\t\t\tpjmedia_wav_player_info *info)\n{\n    struct file_reader_port *fport;\n    PJ_ASSERT_RETURN(port && info, PJ_EINVAL);\n\n    pj_bzero(info, sizeof(*info));\n\n    /* Check that this is really a player port */\n    PJ_ASSERT_RETURN(port->info.signature == SIGNATURE, PJ_EINVALIDOP);\n\n    fport = (struct file_reader_port*) port;\n\n    if (fport->fmt_tag == PJMEDIA_WAVE_FMT_TAG_PCM) {\n\tinfo->fmt_id = PJMEDIA_FORMAT_PCM;\n\tinfo->payload_bits_per_sample = 16;\n    } else if (fport->fmt_tag == PJMEDIA_WAVE_FMT_TAG_ULAW) {\n\tinfo->fmt_id = PJMEDIA_FORMAT_ULAW;\n\tinfo->payload_bits_per_sample = 8;\n    } else if (fport->fmt_tag == PJMEDIA_WAVE_FMT_TAG_ALAW) {\n\tinfo->fmt_id = PJMEDIA_FORMAT_ALAW;\n\tinfo->payload_bits_per_sample = 8;\n    } else {\n\tpj_assert(!\"Unsupported format\");\n\treturn PJ_ENOTSUP;\n    }\n\n    info->size_bytes = (pj_uint32_t)pjmedia_wav_player_get_len(port);\n    info->size_samples = info->size_bytes /\n\t\t\t (info->payload_bits_per_sample / 8);\n\n    return PJ_SUCCESS;\n}\n\n/*\n * Get the data length, in bytes.\n */\nPJ_DEF(pj_ssize_t) pjmedia_wav_player_get_len(pjmedia_port *port)\n{\n    struct file_reader_port *fport;\n    pj_ssize_t size;\n\n    /* Sanity check */\n    PJ_ASSERT_RETURN(port, -PJ_EINVAL);\n\n    /* Check that this is really a player port */\n    PJ_ASSERT_RETURN(port->info.signature == SIGNATURE, -PJ_EINVALIDOP);\n\n    fport = (struct file_reader_port*) port;\n\n    size = (pj_ssize_t) fport->fsize;\n    return size - fport->start_data;\n}\n\n\n/*\n * Set position.\n */\nPJ_DEF(pj_status_t) pjmedia_wav_player_port_set_pos(pjmedia_port *port,\n\t\t\t\t\t\t    pj_uint32_t bytes )\n{\n    struct file_reader_port *fport;\n    pj_status_t status;\n\n    /* Sanity check */\n    PJ_ASSERT_RETURN(port, PJ_EINVAL);\n\n    /* Check that this is really a player port */\n    PJ_ASSERT_RETURN(port->info.signature == SIGNATURE, PJ_EINVALIDOP);\n\n\n    fport = (struct file_reader_port*) port;\n\n    /* Check that this offset does not pass the audio-data (in case of\n     * extra chunk after audio data chunk\n     */\n    PJ_ASSERT_RETURN(bytes < fport->data_len, PJ_EINVAL);\n\n    fport->fpos = fport->start_data + bytes;\n    fport->data_left = fport->data_len - bytes;\n    pj_file_setpos( fport->fd, fport->fpos, PJ_SEEK_SET);\n\n    fport->eof = PJ_FALSE;\n    status = fill_buffer(fport);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    fport->readpos = fport->buf;\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Get the file play position of WAV player (in bytes).\n */\nPJ_DEF(pj_ssize_t) pjmedia_wav_player_port_get_pos( pjmedia_port *port )\n{\n    struct file_reader_port *fport;\n    pj_size_t payload_pos;\n\n    /* Sanity check */\n    PJ_ASSERT_RETURN(port, -PJ_EINVAL);\n\n    /* Check that this is really a player port */\n    PJ_ASSERT_RETURN(port->info.signature == SIGNATURE, -PJ_EINVALIDOP);\n\n    fport = (struct file_reader_port*) port;\n\n    payload_pos = (pj_size_t)(fport->fpos - fport->start_data);\n    if (payload_pos == 0)\n\treturn 0;\n    else if (payload_pos >= fport->bufsize)\n\treturn payload_pos - fport->bufsize + (fport->readpos - fport->buf);\n    else\n\treturn (fport->readpos - fport->buf) % payload_pos;\n}\n\n\n#if !DEPRECATED_FOR_TICKET_2251\n/*\n * Register a callback to be called when the file reading has reached the\n * end of file.\n */\nPJ_DEF(pj_status_t) pjmedia_wav_player_set_eof_cb( pjmedia_port *port,\n\t\t\t       void *user_data,\n\t\t\t       pj_status_t (*cb)(pjmedia_port *port,\n\t\t\t\t\t\t void *usr_data))\n{\n    struct file_reader_port *fport;\n\n    /* Sanity check */\n    PJ_ASSERT_RETURN(port, -PJ_EINVAL);\n\n    /* Check that this is really a player port */\n    PJ_ASSERT_RETURN(port->info.signature == SIGNATURE, -PJ_EINVALIDOP);\n\n    PJ_LOG(1, (THIS_FILE, \"pjmedia_wav_player_set_eof_cb() is deprecated. \"\n    \t       \"Use pjmedia_wav_player_set_eof_cb2() instead.\"));\n\n    fport = (struct file_reader_port*) port;\n\n    fport->base.port_data.pdata = user_data;\n    fport->cb = cb;\n\n    return PJ_SUCCESS;\n}\n#endif\n\n\n/*\n * Register a callback to be called when the file reading has reached the\n * end of file.\n */\nPJ_DEF(pj_status_t) pjmedia_wav_player_set_eof_cb2(pjmedia_port *port,\n\t\t\t       void *user_data,\n\t\t\t       void (*cb)(pjmedia_port *port,\n\t\t\t\t\t  void *usr_data))\n{\n    struct file_reader_port *fport;\n\n    /* Sanity check */\n    PJ_ASSERT_RETURN(port, -PJ_EINVAL);\n\n    /* Check that this is really a player port */\n    PJ_ASSERT_RETURN(port->info.signature == SIGNATURE, -PJ_EINVALIDOP);\n\n    fport = (struct file_reader_port*) port;\n\n    fport->base.port_data.pdata = user_data;\n    fport->cb2 = cb;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic pj_status_t file_on_event(pjmedia_event *event,\n                                 void *user_data)\n{\n    struct file_reader_port *fport = (struct file_reader_port*)user_data;\n\n    if (event->type == PJMEDIA_EVENT_CALLBACK) {\n\tif (fport->cb2)\n\t    (*fport->cb2)(&fport->base, fport->base.port_data.pdata);\n    }\n    \n    return PJ_SUCCESS;\n}\n\n\n/*\n * Get frame from file.\n */\nstatic pj_status_t file_get_frame(pjmedia_port *this_port, \n\t\t\t\t  pjmedia_frame *frame)\n{\n    struct file_reader_port *fport = (struct file_reader_port*)this_port;\n    pj_size_t frame_size;\n    pj_status_t status = PJ_SUCCESS;\n\n    pj_assert(fport->base.info.signature == SIGNATURE);\n    pj_assert(frame->size <= fport->bufsize);\n\n    /* EOF is set and readpos already passed the eofpos */\n    if (fport->eof && fport->readpos >= fport->eofpos) {\n\tPJ_LOG(5,(THIS_FILE, \"File port %.*s EOF\",\n\t\t  (int)fport->base.info.name.slen,\n\t\t  fport->base.info.name.ptr));\n\n\t/* Call callback, if any */\n\tif (fport->cb2) {\n\t    pj_bool_t no_loop = (fport->options & PJMEDIA_FILE_NO_LOOP);\n\n\t    if (!fport->subscribed) {\n\t    \tstatus = pjmedia_event_subscribe(NULL, &file_on_event,\n\t    \t\t\t\t         fport, fport);\n\t    \tfport->subscribed = (status == PJ_SUCCESS)? PJ_TRUE:\n\t    \t\t\t    PJ_FALSE;\n\t    }\n\n\t    if (fport->subscribed && fport->eof != 2) {\n\t    \tpjmedia_event event;\n\n\t    \tif (no_loop) {\n\t    \t    /* To prevent the callback from being called repeatedly */\n\t    \t    fport->eof = 2;\n\t    \t} else {\n\t    \t    fport->eof = PJ_FALSE;\n\t    \t}\n\n\t    \tpjmedia_event_init(&event, PJMEDIA_EVENT_CALLBACK,\n\t                      \t   NULL, fport);\n\t    \tpjmedia_event_publish(NULL, fport, &event,\n\t                              PJMEDIA_EVENT_PUBLISH_POST_EVENT);\n\t    }\n\t    \n\t    /* Should not access player port after this since\n\t     * it might have been destroyed by the callback.\n\t     */\n\t    frame->type = PJMEDIA_FRAME_TYPE_NONE;\n\t    frame->size = 0;\n\t    \n\t    return (no_loop? PJ_EEOF: PJ_SUCCESS);\n\n\t} else if (fport->cb) {\n\t    status = (*fport->cb)(this_port, fport->base.port_data.pdata);\n\t}\n\n\t/* If callback returns non PJ_SUCCESS or 'no loop' is specified,\n\t * return immediately (and don't try to access player port since\n\t * it might have been destroyed by the callback).\n\t */\n\tif ((status != PJ_SUCCESS) || (fport->options & PJMEDIA_FILE_NO_LOOP))\n\t{\n\t    frame->type = PJMEDIA_FRAME_TYPE_NONE;\n\t    frame->size = 0;\n\t    return PJ_EEOF;\n\t}\n\n        /* Rewind file */\n\tPJ_LOG(5,(THIS_FILE, \"File port %.*s rewinding..\",\n\t\t  (int)fport->base.info.name.slen,\n\t\t  fport->base.info.name.ptr));\n\tfport->eof = PJ_FALSE;\n    }\n\n    //pj_assert(frame->size == fport->base.info.bytes_per_frame);\n    if (fport->fmt_tag == PJMEDIA_WAVE_FMT_TAG_PCM) {\n\tframe_size = frame->size;\n\t//frame->size = frame_size;\n    } else {\n\t/* Must be ULAW or ALAW */\n\tpj_assert(fport->fmt_tag == PJMEDIA_WAVE_FMT_TAG_ULAW || \n\t\t  fport->fmt_tag == PJMEDIA_WAVE_FMT_TAG_ALAW);\n\n\tframe_size = frame->size >> 1;\n\tframe->size = frame_size << 1;\n    }\n\n    /* Copy frame from buffer. */\n    frame->type = PJMEDIA_FRAME_TYPE_AUDIO;\n    frame->timestamp.u64 = 0;\n\n    if ((fport->readpos + frame_size) <= (fport->buf + fport->bufsize))\n    {\n\t/* Read contiguous buffer. */\n\tpj_memcpy(frame->buf, fport->readpos, frame_size);\n\n\t/* Fill up the buffer if all has been read. */\n\tfport->readpos += frame_size;\n\tif (fport->readpos == fport->buf + fport->bufsize) {\n\t    fport->readpos = fport->buf;\n\n\t    status = fill_buffer(fport);\n\t    if (status != PJ_SUCCESS) {\n\t\tframe->type = PJMEDIA_FRAME_TYPE_NONE;\n\t\tframe->size = 0;\n\t\tfport->readpos = fport->buf + fport->bufsize;\n\t\treturn status;\n\t    }\n\t}\n    } else {\n\tunsigned endread;\n\n\t/* Split read.\n\t * First stage: read until end of buffer. \n\t */\n\tendread = (unsigned)((fport->buf+fport->bufsize) - fport->readpos);\n\tpj_memcpy(frame->buf, fport->readpos, endread);\n\n\t/* End Of Buffer and EOF and NO LOOP */\n\tif (fport->eof && (fport->options & PJMEDIA_FILE_NO_LOOP)) {\n\t    fport->readpos += endread;\n\n            if (fport->fmt_tag == PJMEDIA_WAVE_FMT_TAG_PCM) {\n                pj_bzero((char*)frame->buf + endread, frame_size - endread);\n            } else if (fport->fmt_tag == PJMEDIA_WAVE_FMT_TAG_ULAW) {\n                int val = pjmedia_linear2ulaw(0);\n                pj_memset((char*)frame->buf + endread, val,\n                          frame_size - endread);\n            } else if (fport->fmt_tag == PJMEDIA_WAVE_FMT_TAG_ALAW) {\n                int val = pjmedia_linear2alaw(0);\n                pj_memset((char*)frame->buf + endread, val,\n                          frame_size - endread);\n            }\n\n\t    return PJ_SUCCESS;\n\t}\n\n\t/* Second stage: fill up buffer, and read from the start of buffer. */\n\tstatus = fill_buffer(fport);\n\tif (status != PJ_SUCCESS) {\n\t    frame->type = PJMEDIA_FRAME_TYPE_NONE;\n\t    frame->size = 0;\n\t    fport->readpos = fport->buf + fport->bufsize;\n\t    return status;\n\t}\n\n\tpj_memcpy(((char*)frame->buf)+endread, fport->buf, frame_size-endread);\n\tfport->readpos = fport->buf + (frame_size - endread);\n    }\n\n    if (fport->fmt_tag == PJMEDIA_WAVE_FMT_TAG_ULAW ||\n\tfport->fmt_tag == PJMEDIA_WAVE_FMT_TAG_ALAW)\n    {\n\tunsigned i;\n\tpj_uint16_t *dst;\n\tpj_uint8_t *src;\n\n\tdst = (pj_uint16_t*)frame->buf + frame_size - 1;\n\tsrc = (pj_uint8_t*)frame->buf + frame_size - 1;\n\n\tif (fport->fmt_tag == PJMEDIA_WAVE_FMT_TAG_ULAW) {\n\t    for (i = 0; i < frame_size; ++i) {\n\t\t*dst-- = (pj_uint16_t) pjmedia_ulaw2linear(*src--);\n\t    }\n\t} else {\n\t    for (i = 0; i < frame_size; ++i) {\n\t\t*dst-- = (pj_uint16_t) pjmedia_alaw2linear(*src--);\n\t    }\n\t}\n    }\n\n    return PJ_SUCCESS;\n}\n\n/*\n * Destroy port.\n */\nstatic pj_status_t file_on_destroy(pjmedia_port *this_port)\n{\n    struct file_reader_port *fport = (struct file_reader_port*) this_port;\n\n    pj_assert(this_port->info.signature == SIGNATURE);\n\n    pj_file_close(fport->fd);\n\n    if (fport->subscribed) {\n    \tpjmedia_event_unsubscribe(NULL, &file_on_event, fport, fport);\n    \tfport->subscribed = PJ_FALSE;\n    }\n\n    return PJ_SUCCESS;\n}\n\n", "/* $Id$ */\n/* \n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * Original author:\n *  David Clark <vdc1048 @ tx.rr.com>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n#include <pjmedia/wav_playlist.h>\n#include <pjmedia/errno.h>\n#include <pjmedia/wave.h>\n#include <pj/assert.h>\n#include <pj/file_access.h>\n#include <pj/file_io.h>\n#include <pj/log.h>\n#include <pj/pool.h>\n#include <pj/string.h>\n\n#define THIS_FILE\t    \"wav_playlist.c\"\n\n#define SIGNATURE\t    PJMEDIA_SIG_PORT_WAV_PLAYLIST\n#define BYTES_PER_SAMPLE    2\n\n\n#if 1\n#   define TRACE_(x)\tPJ_LOG(4,x)\n#else\n#   define TRACE_(x)\n#endif\n\n#if defined(PJ_IS_BIG_ENDIAN) && PJ_IS_BIG_ENDIAN!=0\n    static void samples_to_host(pj_int16_t *samples, unsigned count)\n    {\n\tunsigned i;\n\tfor (i=0; i<count; ++i) {\n\t    samples[i] = pj_swap16(samples[i]);\n\t}\n    }\n#else\n#   define samples_to_host(samples,count)\n#endif\n\n\nstruct playlist_port\n{\n    pjmedia_port     base;\n    unsigned\t     options;\n    pj_bool_t\t     eof;\n    pj_uint32_t\t     bufsize;\n    char\t    *buf;\n    char\t    *readpos;\n\n    pj_off_t        *fsize_list;\n    unsigned        *start_data_list;\n    unsigned        *data_len_list;\n    unsigned        *data_left_list;\n    pj_off_t        *fpos_list;\n    pj_oshandle_t   *fd_list;\t    /* list of file descriptors\t*/\n    int              current_file;  /* index of current file.\t*/\n    int              max_file;\t    /* how many files.\t\t*/\n\n    pj_status_t\t   (*cb)(pjmedia_port*, void*);\n    pj_bool_t\t     subscribed;\n    void\t   (*cb2)(pjmedia_port*, void*);\n};\n\n\nstatic pj_status_t file_list_get_frame(pjmedia_port *this_port,\n\t\t\t\t       pjmedia_frame *frame);\nstatic pj_status_t file_list_on_destroy(pjmedia_port *this_port);\n\n\nstatic struct playlist_port *create_file_list_port(pj_pool_t *pool,\n\t\t\t\t\t\t   const pj_str_t *name)\n{\n    struct playlist_port *port;\n\n    port = PJ_POOL_ZALLOC_T(pool, struct playlist_port);\n    if (!port)\n\treturn NULL;\n\n    /* Put in default values.\n     * These will be overriden once the file is read.\n     */\n    pjmedia_port_info_init(&port->base.info, name, SIGNATURE,\n\t\t\t   8000, 1, 16, 80);\n\n    port->base.get_frame = &file_list_get_frame;\n    port->base.on_destroy = &file_list_on_destroy;\n\n    return port;\n}\n\n\nstatic pj_status_t file_on_event(pjmedia_event *event,\n                                 void *user_data)\n{\n    struct playlist_port *fport = (struct playlist_port*)user_data;\n\n    if (event->type == PJMEDIA_EVENT_CALLBACK) {\n\tif (fport->cb2)\n\t    (*fport->cb2)(&fport->base, fport->base.port_data.pdata);\n    }\n    \n    return PJ_SUCCESS;\n}\n\n\n/*\n * Fill buffer for file_list operations.\n */\nstatic pj_status_t file_fill_buffer(struct playlist_port *fport)\n{\n    pj_uint32_t size_left = fport->bufsize;\n    pj_uint32_t size_to_read;\n    pj_ssize_t size;\n    pj_status_t status;\n    int current_file = fport->current_file;\n\n    /* Can't read file if EOF and loop flag is disabled */\n    if (fport->eof)\n\treturn PJ_EEOF;\n\n    while (size_left > 0)\n    {\n\t/* Calculate how many bytes to read in this run. */\n\tsize = size_to_read = size_left;\n\tstatus = pj_file_read(fport->fd_list[current_file],\n\t\t\t      &fport->buf[fport->bufsize-size_left],\n\t\t\t      &size);\n\tif (status != PJ_SUCCESS)\n\t    return status;\n\t\n\tif (size < 0)\n\t{\n\t    /* Should return more appropriate error code here.. */\n\t    return PJ_ECANCELLED;\n\t}\n\n        if (size > (pj_ssize_t)fport->data_left_list[current_file]) {\n            /* We passed the end of the data chunk,\n             * only count the portion read from the data chunk.\n             */\n            size = (pj_ssize_t)fport->data_left_list[current_file];\n        }\n\t\n\tsize_left -= (pj_uint32_t)size;\n\tfport->data_left_list[current_file] -= (pj_uint32_t)size;\n\tfport->fpos_list[current_file] += size;\t\n\t\n\t/* If size is less than size_to_read, it indicates that we've\n\t * encountered EOF. Rewind the file.\n\t */\n\tif (size < (pj_ssize_t)size_to_read)\n\t{\n\t    /* Rewind the file for the next iteration */\n\t    fport->fpos_list[current_file] = \n\t\tfport->start_data_list[current_file];\n\t    pj_file_setpos(fport->fd_list[current_file], \n\t\t\t   fport->fpos_list[current_file], PJ_SEEK_SET);\n\t    fport->data_left_list[current_file] = \n\t\t\t\t\t    fport->data_len_list[current_file];\n\n\t    /* Move to next file */\n\t    current_file++;\n\t    fport->current_file = current_file;\n\n\t    if (fport->current_file == fport->max_file)\n\t    {\n\t\t/* Clear the remaining part of the buffer first, to prevent\n\t\t * old samples from being played. If the playback restarts,\n\t\t * this will be overwritten by new reading.\n\t\t */\n\t\tif (size_left > 0) {\n\t\t    pj_bzero(&fport->buf[fport->bufsize-size_left], \n\t\t\t     size_left);\n\t\t}\n\n\t\t/* All files have been played. Call callback, if any. */\n\t\tif (fport->cb2) {\n\t    \t    pj_bool_t no_loop = (fport->options & PJMEDIA_FILE_NO_LOOP);\n\n\t    \t    if (!fport->subscribed) {\n\t    \t\tstatus = pjmedia_event_subscribe(NULL, &file_on_event,\n\t    \t\t\t\t         \t fport, fport);\n\t    \t\tfport->subscribed = (status == PJ_SUCCESS)? PJ_TRUE:\n\t    \t\t\t    \t    PJ_FALSE;\n\t    \t    }\n\n\t    \t    if (fport->subscribed && fport->eof != 2) {\n\t    \t    \tpjmedia_event event;\n\n\t    \t\tif (no_loop) {\n\t    \t    \t    /* To prevent the callback from being called\n\t    \t    \t     * repeatedly.\n\t    \t    \t     */\n\t    \t    \t    fport->eof = 2;\n\t    \t\t} else {\n\t    \t    \t    fport->eof = PJ_FALSE;\n\t\t    \t    /* start with first file again. */\n\t\t    \t    fport->current_file = current_file = 0;\n\t\t    \t    fport->fpos_list[0] = fport->start_data_list[0];\n\t\t    \t    pj_file_setpos(fport->fd_list[0],\n\t\t    \t    \t\t   fport->fpos_list[0], PJ_SEEK_SET);\n\t\t    \t    fport->data_left_list[0] = fport->data_len_list[0];\n\t    \t\t}\n\n\t    \t    \tpjmedia_event_init(&event, PJMEDIA_EVENT_CALLBACK,\n\t                      \t       \t   NULL, fport);\n\t    \t    \tpjmedia_event_publish(NULL, fport, &event,\n\t                              \t  PJMEDIA_EVENT_PUBLISH_POST_EVENT);\n\t            }\n\n\t    \t    /* Should not access player port after this since\n\t     \t     * it might have been destroyed by the callback.\n\t     \t     */\n\t    \t    return (no_loop? PJ_EEOF: PJ_SUCCESS);\n\n\t    \t} else if (fport->cb) {\n\t\t    PJ_LOG(5,(THIS_FILE,\n\t\t\t      \"File port %.*s EOF, calling callback\",\n\t\t\t      (int)fport->base.info.name.slen,\n\t\t\t      fport->base.info.name.ptr));\n\t\t    \n\t\t    fport->eof = PJ_TRUE;\n\n\t\t    status = (*fport->cb)(&fport->base,\n\t\t\t\t\t  fport->base.port_data.pdata);\n\n\t\t    if (status != PJ_SUCCESS)\n\t\t    {\n\t\t\t/* This will crash if file port is destroyed in the\n\t\t\t * callback, that's why we set the eof flag before\n\t\t\t * calling the callback:\n\t\t\t fport->eof = PJ_TRUE;\n\t\t\t */\n\t\t\treturn status;\n\t\t    }\n\n\t\t    fport->eof = PJ_FALSE;\n\t\t}\n\n\n\t\tif (fport->options & PJMEDIA_FILE_NO_LOOP)\n\t\t{\n\t\t    PJ_LOG(5,(THIS_FILE, \"File port %.*s EOF, stopping..\",\n\t\t\t      (int)fport->base.info.name.slen,\n\t\t\t      fport->base.info.name.ptr));\n\t\t    fport->eof = PJ_TRUE;\n\t\t    return PJ_EEOF;\n\t\t}\n\t\telse\n\t\t{\n\t\t    PJ_LOG(5,(THIS_FILE, \"File port %.*s EOF, rewinding..\",\n\t\t\t      (int)fport->base.info.name.slen,\n\t\t\t      fport->base.info.name.ptr));\n\t\t    \n\t\t    /* start with first file again. */\n\t\t    fport->current_file = current_file = 0;\n\t\t    fport->fpos_list[0] = fport->start_data_list[0];\n\t\t    pj_file_setpos(fport->fd_list[0], fport->fpos_list[0],\n\t\t\t\t   PJ_SEEK_SET);\n\t\t    fport->data_left_list[0] = fport->data_len_list[0];\n\t\t}\t\t\n\t\t\n\t    } /* if current_file == max_file */\n\n\t} /* size < size_to_read */\n\n    } /* while () */\n    \n    /* Convert samples to host rep */\n    samples_to_host((pj_int16_t*)fport->buf, fport->bufsize/BYTES_PER_SAMPLE);\n    \n    return PJ_SUCCESS;\n}\n\n\n/*\n * Create wave list player.\n */\nPJ_DEF(pj_status_t) pjmedia_wav_playlist_create(pj_pool_t *pool,\n\t\t\t\t\t\tconst pj_str_t *port_label,\n\t\t\t\t\t\tconst pj_str_t file_list[],\n\t\t\t\t\t\tint file_count,\n\t\t\t\t\t\tunsigned ptime,\n\t\t\t\t\t\tunsigned options,\n\t\t\t\t\t\tpj_ssize_t buff_size,\n\t\t\t\t\t\tpjmedia_port **p_port)\n{\n    struct playlist_port *fport;\n    pjmedia_audio_format_detail *afd;\n    pj_off_t pos;\n    pj_status_t status;\n    int index;\n    pj_bool_t has_wave_info = PJ_FALSE;\n    pj_str_t tmp_port_label;\n    char filename[PJ_MAXPATH];\t/* filename for open operations.    */\n\n\n    /* Check arguments. */\n    PJ_ASSERT_RETURN(pool && file_list && file_count && p_port, PJ_EINVAL);\n\n    /* Normalize port_label */\n    if (port_label == NULL || port_label->slen == 0) {\n\ttmp_port_label = pj_str(\"WAV playlist\");\n\tport_label = &tmp_port_label;\n    }\n\n    /* Be sure all files exist\t*/\n    for (index=0; index<file_count; index++) {\n\n\tPJ_ASSERT_RETURN(file_list[index].slen >= 0, PJ_ETOOSMALL);\n\tif (file_list[index].slen >= PJ_MAXPATH)\n\t    return PJ_ENAMETOOLONG;\n\n\tpj_memcpy(filename, file_list[index].ptr, file_list[index].slen);\n\tfilename[file_list[index].slen] = '\\0';\n\n    \t/* Check the file really exists. */\n    \tif (!pj_file_exists(filename)) {\n\t    PJ_LOG(4,(THIS_FILE,\n\t\t      \"WAV playlist error: file '%s' not found\",\n\t      \t      filename));\n\t    return PJ_ENOTFOUND;\n    \t}\n    }\n\n    /* Normalize ptime */\n    if (ptime == 0)\n\tptime = 20;\n\n    /* Create fport instance. */\n    fport = create_file_list_port(pool, port_label);\n    if (!fport) {\n\treturn PJ_ENOMEM;\n    }\n\n    afd = pjmedia_format_get_audio_format_detail(&fport->base.info.fmt, 1);\n\n    /* start with the first file. */\n    fport->current_file = 0;\n    fport->max_file = file_count;\n\n    /* Create file descriptor list */\n    fport->fd_list = (pj_oshandle_t*)\n\t\t     pj_pool_zalloc(pool, sizeof(pj_oshandle_t)*file_count);\n    if (!fport->fd_list) {\n\treturn PJ_ENOMEM;\n    }\n\n    /* Create file size list */\n    fport->fsize_list = (pj_off_t*)\n\t\t\tpj_pool_alloc(pool, sizeof(pj_off_t)*file_count);\n    if (!fport->fsize_list) {\n\treturn PJ_ENOMEM;\n    }\n\n    /* Create start of WAVE data list */\n    fport->start_data_list = (unsigned*)\n\t\t\t     pj_pool_alloc(pool, sizeof(unsigned)*file_count);\n    if (!fport->start_data_list) {\n\treturn PJ_ENOMEM;\n    }\n\n    /* Create data len list */\n    fport->data_len_list = (unsigned*)\n\t\t\t     pj_pool_alloc(pool, sizeof(unsigned)*file_count);\n    if (!fport->data_len_list) {\n\treturn PJ_ENOMEM;\n    }\n\n    /* Create data left list */\n    fport->data_left_list = (unsigned*)\n\t\t\t     pj_pool_alloc(pool, sizeof(unsigned)*file_count);\n    if (!fport->data_left_list) {\n\treturn PJ_ENOMEM;\n    }\n\n    /* Create file position list */\n    fport->fpos_list = (pj_off_t*)\n\t\t       pj_pool_alloc(pool, sizeof(pj_off_t)*file_count);\n    if (!fport->fpos_list) {\n\treturn PJ_ENOMEM;\n    }\n\n    /* Create file buffer once for this operation.\n     */\n    if (buff_size < 1) buff_size = PJMEDIA_FILE_PORT_BUFSIZE;\n    fport->bufsize = (pj_uint32_t)buff_size;\n\n\n    /* Create buffer. */\n    fport->buf = (char*) pj_pool_alloc(pool, fport->bufsize);\n    if (!fport->buf) {\n\treturn PJ_ENOMEM;\n    }\n\n    /* Initialize port */\n    fport->options = options;\n    fport->readpos = fport->buf;\n\n\n    /* ok run this for all files to be sure all are good for playback. */\n    for (index=file_count-1; index>=0; index--) {\n\n\tpjmedia_wave_hdr wavehdr;\n\tpj_ssize_t size_to_read, size_read;\n\n\t/* we end with the last one so we are good to go if still in function*/\n\tpj_memcpy(filename, file_list[index].ptr, file_list[index].slen);\n\tfilename[file_list[index].slen] = '\\0';\n\n\t/* Get the file size. */\n\tfport->current_file = index;\n\tfport->fsize_list[index] = pj_file_size(filename);\n\t\n\t/* Size must be more than WAVE header size */\n\tif (fport->fsize_list[index] <= sizeof(pjmedia_wave_hdr)) {\n\t    status = PJMEDIA_ENOTVALIDWAVE;\n\t    goto on_error;\n\t}\n\t\n\t/* Open file. */\n\tstatus = pj_file_open( pool, filename, PJ_O_RDONLY, \n\t\t\t       &fport->fd_list[index]);\n\tif (status != PJ_SUCCESS)\n\t    goto on_error;\n\t\n\t/* Read the file header plus fmt header only. */\n\tsize_read = size_to_read = sizeof(wavehdr) - 8;\n\tstatus = pj_file_read( fport->fd_list[index], &wavehdr, &size_read);\n\tif (status != PJ_SUCCESS) {\n\t    goto on_error;\n\t}\n\n\tif (size_read != size_to_read) {\n\t    status = PJMEDIA_ENOTVALIDWAVE;\n\t    goto on_error;\n\t}\n\t\n\t/* Normalize WAVE header fields values from little-endian to host\n\t * byte order.\n\t */\n\tpjmedia_wave_hdr_file_to_host(&wavehdr);\n\t\n\t/* Validate WAVE file. */\n\tif (wavehdr.riff_hdr.riff != PJMEDIA_RIFF_TAG ||\n\t    wavehdr.riff_hdr.wave != PJMEDIA_WAVE_TAG ||\n\t    wavehdr.fmt_hdr.fmt != PJMEDIA_FMT_TAG)\n\t{\n\t    TRACE_((THIS_FILE,\n\t\t\"actual value|expected riff=%x|%x, wave=%x|%x fmt=%x|%x\",\n\t\twavehdr.riff_hdr.riff, PJMEDIA_RIFF_TAG,\n\t\twavehdr.riff_hdr.wave, PJMEDIA_WAVE_TAG,\n\t\twavehdr.fmt_hdr.fmt, PJMEDIA_FMT_TAG));\n\t    status = PJMEDIA_ENOTVALIDWAVE;\n\t    goto on_error;\n\t}\n\t\n\t/* Must be PCM with 16bits per sample */\n\tif (wavehdr.fmt_hdr.fmt_tag != 1 ||\n\t    wavehdr.fmt_hdr.bits_per_sample != 16)\n\t{\n\t    status = PJMEDIA_EWAVEUNSUPP;\n\t    goto on_error;\n\t}\n\t\n\t/* Block align must be 2*nchannels */\n\tif (wavehdr.fmt_hdr.block_align != \n\t\twavehdr.fmt_hdr.nchan * BYTES_PER_SAMPLE)\n\t{\n\t    status = PJMEDIA_EWAVEUNSUPP;\n\t    goto on_error;\n\t}\n\t\n\t/* If length of fmt_header is greater than 16, skip the remaining\n\t * fmt header data.\n\t */\n\tif (wavehdr.fmt_hdr.len > 16) {\n\t    size_to_read = wavehdr.fmt_hdr.len - 16;\n\t    status = pj_file_setpos(fport->fd_list[index], size_to_read, \n\t\t\t\t    PJ_SEEK_CUR);\n\t    if (status != PJ_SUCCESS) {\n\t\tgoto on_error;\n\t    }\n\t}\n\t\n\t/* Repeat reading the WAVE file until we have 'data' chunk */\n\tfor (;;) {\n\t    pjmedia_wave_subchunk subchunk;\n\t    size_read = 8;\n\t    status = pj_file_read(fport->fd_list[index], &subchunk, \n\t\t\t\t  &size_read);\n\t    if (status != PJ_SUCCESS || size_read != 8) {\n\t\tstatus = PJMEDIA_EWAVETOOSHORT;\n\t\tgoto on_error;\n\t    }\n\t    \n\t    /* Normalize endianness */\n\t    PJMEDIA_WAVE_NORMALIZE_SUBCHUNK(&subchunk);\n\t    \n\t    /* Break if this is \"data\" chunk */\n\t    if (subchunk.id == PJMEDIA_DATA_TAG) {\n\t\twavehdr.data_hdr.data = PJMEDIA_DATA_TAG;\n\t\twavehdr.data_hdr.len = subchunk.len;\n\t\tbreak;\n\t    }\n\t    \n\t    /* Otherwise skip the chunk contents */\n\t    size_to_read = subchunk.len;\n\t    status = pj_file_setpos(fport->fd_list[index], size_to_read, \n\t\t\t\t    PJ_SEEK_CUR);\n\t    if (status != PJ_SUCCESS) {\n\t\tgoto on_error;\n\t    }\n\t}\n\t\n\t/* Current file position now points to start of data */\n\tstatus = pj_file_getpos(fport->fd_list[index], &pos);\n\tfport->start_data_list[index] = (unsigned)pos;\n\tfport->data_len_list[index] = wavehdr.data_hdr.len;\n\tfport->data_left_list[index] = wavehdr.data_hdr.len;\n\t\n\t/* Validate length. */\n\tif (wavehdr.data_hdr.len > fport->fsize_list[index] - \n\t\t\t\t       fport->start_data_list[index]) \n\t{\n\t    status = PJMEDIA_EWAVEUNSUPP;\n\t    goto on_error;\n\t}\n\tif (wavehdr.data_hdr.len < ptime * wavehdr.fmt_hdr.sample_rate *\n\t\t\t\t    wavehdr.fmt_hdr.nchan / 1000)\n\t{\n\t    status = PJMEDIA_EWAVETOOSHORT;\n\t    goto on_error;\n\t}\n\t\n\t/* It seems like we have a valid WAVE file. */\n\t\n\t/* Update port info if we don't have one, otherwise check\n\t * that the WAV file has the same attributes as previous files. \n\t */\n\tif (!has_wave_info) {\n\t    afd->channel_count = wavehdr.fmt_hdr.nchan;\n\t    afd->clock_rate = wavehdr.fmt_hdr.sample_rate;\n\t    afd->bits_per_sample = wavehdr.fmt_hdr.bits_per_sample;\n\t    afd->frame_time_usec = ptime * 1000;\n\t    afd->avg_bps = afd->max_bps = afd->clock_rate *\n\t\t\t\t\t  afd->channel_count *\n\t\t\t\t\t  afd->bits_per_sample;\n\n\t    has_wave_info = PJ_TRUE;\n\n\t} else {\n\n\t    /* Check that this file has the same characteristics as the other\n\t     * files.\n\t     */\n\t    if (wavehdr.fmt_hdr.nchan != afd->channel_count ||\n\t\twavehdr.fmt_hdr.sample_rate != afd->clock_rate ||\n\t\twavehdr.fmt_hdr.bits_per_sample != afd->bits_per_sample)\n\t    {\n\t\t/* This file has different characteristics than the other \n\t\t * files. \n\t\t */\n\t\tPJ_LOG(4,(THIS_FILE,\n\t\t          \"WAV playlist error: file '%s' has differrent number\"\n\t\t\t  \" of channels, sample rate, or bits per sample\",\n\t      \t\t  filename));\n\t\tstatus = PJMEDIA_EWAVEUNSUPP;\n\t\tgoto on_error;\n\t    }\n\n\t}\n\n\t/* If file is shorter than buffer size, adjust buffer size to file\n\t * size. Otherwise EOF callback will be called multiple times when\n\t * file_fill_buffer() is called.\n\t */\n\tif (wavehdr.data_hdr.len < (unsigned)buff_size)\n\t    buff_size = wavehdr.data_hdr.len;\n\n\t/* Create file buffer.\n\t */\n\tfport->bufsize = (pj_uint32_t)buff_size;\t\n\t\n\t/* Set initial position of the file. */\n\tfport->fpos_list[index] = fport->start_data_list[index];\n    }\n\n    /* Fill up the buffer. */\n    status = file_fill_buffer(fport);\n    if (status != PJ_SUCCESS) {\n\tgoto on_error;\n    }\n    \n    /* Done. */\n    \n    *p_port = &fport->base;\n    \n    PJ_LOG(4,(THIS_FILE,\n\t     \"WAV playlist '%.*s' created: samp.rate=%d, ch=%d, bufsize=%uKB\",\n\t     (int)port_label->slen,\n\t     port_label->ptr,\n\t     afd->clock_rate,\n\t     afd->channel_count,\n\t     fport->bufsize / 1000));\n    \n    return PJ_SUCCESS;\n\non_error:\n    for (index=0; index<file_count; ++index) {\n\tif (fport->fd_list[index] != 0)\n\t    pj_file_close(fport->fd_list[index]);\n    }\n\n    return status;\n}\n\n\n#if !DEPRECATED_FOR_TICKET_2251\n/*\n * Register a callback to be called when the file reading has reached the\n * end of the last file.\n */\nPJ_DEF(pj_status_t) pjmedia_wav_playlist_set_eof_cb(pjmedia_port *port,\n\t\t\t        void *user_data,\n\t\t\t        pj_status_t (*cb)(pjmedia_port *port,\n\t\t\t\t\t\t  void *usr_data))\n{\n    struct playlist_port *fport;\n\n    /* Sanity check */\n    PJ_ASSERT_RETURN(port, PJ_EINVAL);\n\n    /* Check that this is really a playlist port */\n    PJ_ASSERT_RETURN(port->info.signature == SIGNATURE, PJ_EINVALIDOP);\n\n    PJ_LOG(1, (THIS_FILE, \"pjmedia_wav_playlist_set_eof_cb() is deprecated. \"\n    \t       \"Use pjmedia_wav_playlist_set_eof_cb2() instead.\"));\n\n    fport = (struct playlist_port*) port;\n\n    fport->base.port_data.pdata = user_data;\n    fport->cb = cb;\n\n    return PJ_SUCCESS;\n}\n#endif\n\n\n/*\n * Register a callback to be called when the file reading has reached the\n * end of the last file.\n */\nPJ_DEF(pj_status_t) pjmedia_wav_playlist_set_eof_cb2(pjmedia_port *port,\n\t\t\t        void *user_data,\n\t\t\t        void (*cb)(pjmedia_port *port,\n\t\t\t\t\t   void *usr_data))\n{\n    struct playlist_port *fport;\n\n    /* Sanity check */\n    PJ_ASSERT_RETURN(port, PJ_EINVAL);\n\n    /* Check that this is really a playlist port */\n    PJ_ASSERT_RETURN(port->info.signature == SIGNATURE, PJ_EINVALIDOP);\n\n    fport = (struct playlist_port*) port;\n\n    fport->base.port_data.pdata = user_data;\n    fport->cb2 = cb;\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Get frame from file for file_list operation\n */\nstatic pj_status_t file_list_get_frame(pjmedia_port *this_port,\n\t\t\t\t       pjmedia_frame *frame)\n{\n    struct playlist_port *fport = (struct playlist_port*)this_port;\n    pj_size_t frame_size;\n    pj_status_t status;\n\n    pj_assert(fport->base.info.signature == SIGNATURE);\n\n    //frame_size = fport->base.info.bytes_per_frame;\n    //pj_assert(frame->size == frame_size);\n    frame_size = frame->size;\n\n    /* Copy frame from buffer. */\n    frame->type = PJMEDIA_FRAME_TYPE_AUDIO;\n    frame->size = frame_size;\n    frame->timestamp.u64 = 0;\n\n    if (fport->readpos + frame_size <= fport->buf + fport->bufsize) {\n\n\t/* Read contiguous buffer. */\n\tpj_memcpy(frame->buf, fport->readpos, frame_size);\n\n\t/* Fill up the buffer if all has been read. */\n\tfport->readpos += frame_size;\n\tif (fport->readpos == fport->buf + fport->bufsize) {\n\t    fport->readpos = fport->buf;\n\n\t    status = file_fill_buffer(fport);\n\t    if (status != PJ_SUCCESS) {\n\t\tframe->type = PJMEDIA_FRAME_TYPE_NONE;\n\t\tframe->size = 0;\n\t\treturn status;\n\t    }\n\t}\n    } else {\n\tunsigned endread;\n\n\t/* Split read.\n\t * First stage: read until end of buffer.\n\t */\n\tendread = (unsigned)((fport->buf+fport->bufsize) - fport->readpos);\n\tpj_memcpy(frame->buf, fport->readpos, endread);\n\n\t/* Second stage: fill up buffer, and read from the start of buffer. */\n\tstatus = file_fill_buffer(fport);\n\tif (status != PJ_SUCCESS) {\n\t    pj_bzero(((char*)frame->buf)+endread, frame_size-endread);\n\t    return status;\n\t}\n\n\tpj_memcpy(((char*)frame->buf)+endread, fport->buf, frame_size-endread);\n\tfport->readpos = fport->buf + (frame_size - endread);\n    }\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Destroy port.\n */\nstatic pj_status_t file_list_on_destroy(pjmedia_port *this_port)\n{\n    struct playlist_port *fport = (struct playlist_port*) this_port;\n    int index;\n\n    pj_assert(this_port->info.signature == SIGNATURE);\n\n    if (fport->subscribed) {\n    \tpjmedia_event_unsubscribe(NULL, &file_on_event, fport, fport);\n    \tfport->subscribed = PJ_FALSE;\n    }\n\n    for (index=0; index<fport->max_file; index++)\n\tpj_file_close(fport->fd_list[index]);\n\n    return PJ_SUCCESS;\n}\n\n"], "fixing_code": ["/* $Id$ */\n/* \n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n#ifndef __PJ_TYPES_H__\n#define __PJ_TYPES_H__\n\n\n/**\n * @file types.h\n * @brief Declaration of basic types and utility.\n */\n/**\n * @defgroup PJ_BASIC Basic Data Types and Library Functionality.\n * @ingroup PJ_DS\n * @{\n */\n#include <pj/config.h>\n#include <pj/limits.h>\n\nPJ_BEGIN_DECL\n\n/* ************************************************************************* */\n\n/** Signed 32bit integer. */\ntypedef int\t\tpj_int32_t;\n\n/** Unsigned 32bit integer. */\ntypedef unsigned int\tpj_uint32_t;\n\n/** Signed 16bit integer. */\ntypedef short\t\tpj_int16_t;\n\n/** Unsigned 16bit integer. */\ntypedef unsigned short\tpj_uint16_t;\n\n/** Signed 8bit integer. */\ntypedef signed char\tpj_int8_t;\n\n/** Unsigned 8bit integer. */\ntypedef unsigned char\tpj_uint8_t;\n\n/** Large unsigned integer. */\ntypedef size_t\t\tpj_size_t;\n\n/** Large signed integer. */\n#if defined(PJ_WIN64) && PJ_WIN64!=0\n    typedef pj_int64_t     pj_ssize_t;\n#else\n    typedef long           pj_ssize_t;\n#endif\n\n/** Status code. */\ntypedef int\t\tpj_status_t;\n\n/** Boolean. */\ntypedef int\t\tpj_bool_t;\n\n/** Native char type, which will be equal to wchar_t for Unicode\n * and char for ANSI. */\n#if defined(PJ_NATIVE_STRING_IS_UNICODE) && PJ_NATIVE_STRING_IS_UNICODE!=0\n    typedef wchar_t pj_char_t;\n#else\n    typedef char pj_char_t;\n#endif\n\n/** This macro creates Unicode or ANSI literal string depending whether\n *  native platform string is Unicode or ANSI. */\n#if defined(PJ_NATIVE_STRING_IS_UNICODE) && PJ_NATIVE_STRING_IS_UNICODE!=0\n#   define PJ_T(literal_str)\tL##literal_str\n#else\n#   define PJ_T(literal_str)\tliteral_str\n#endif\n\n/** Some constants */\nenum pj_constants_\n{\n    /** Status is OK. */\n    PJ_SUCCESS=0,\n\n    /** True value. */\n    PJ_TRUE=1,\n\n    /** False value. */\n    PJ_FALSE=0\n};\n\n/**\n * File offset type.\n */\n#if defined(PJ_HAS_INT64) && PJ_HAS_INT64!=0\ntypedef pj_int64_t pj_off_t;\n#else\ntypedef pj_ssize_t pj_off_t;\n#endif\n\n/* ************************************************************************* */\n/*\n * Data structure types.\n */\n/**\n * This type is used as replacement to legacy C string, and used throughout\n * the library. By convention, the string is NOT null terminated.\n */\nstruct pj_str_t\n{\n    /** Buffer pointer, which is by convention NOT null terminated. */\n    char       *ptr;\n\n    /** The length of the string. */\n    pj_ssize_t  slen;\n};\n\n/**\n * This structure represents high resolution (64bit) time value. The time\n * values represent time in cycles, which is retrieved by calling\n * #pj_get_timestamp().\n */\ntypedef union pj_timestamp\n{\n    struct\n    {\n#if defined(PJ_IS_LITTLE_ENDIAN) && PJ_IS_LITTLE_ENDIAN!=0\n\tpj_uint32_t lo;     /**< Low 32-bit value of the 64-bit value. */\n\tpj_uint32_t hi;     /**< high 32-bit value of the 64-bit value. */\n#else\n\tpj_uint32_t hi;     /**< high 32-bit value of the 64-bit value. */\n\tpj_uint32_t lo;     /**< Low 32-bit value of the 64-bit value. */\n#endif\n    } u32;                  /**< The 64-bit value as two 32-bit values. */\n\n#if PJ_HAS_INT64\n    pj_uint64_t u64;        /**< The whole 64-bit value, where available. */\n#endif\n} pj_timestamp;\n\n\n\n/**\n * The opaque data type for linked list, which is used as arguments throughout\n * the linked list operations.\n */\ntypedef void pj_list_type;\n\n/** \n * List.\n */\ntypedef struct pj_list pj_list;\n\n/**\n * Opaque data type for hash tables.\n */\ntypedef struct pj_hash_table_t pj_hash_table_t;\n\n/**\n * Opaque data type for hash entry (only used internally by hash table).\n */\ntypedef struct pj_hash_entry pj_hash_entry;\n\n/**\n * Data type for hash search iterator.\n * This structure should be opaque, however applications need to declare\n * concrete variable of this type, that's why the declaration is visible here.\n */\ntypedef struct pj_hash_iterator_t\n{\n    pj_uint32_t\t     index;     /**< Internal index.     */\n    pj_hash_entry   *entry;     /**< Internal entry.     */\n} pj_hash_iterator_t;\n\n\n/**\n * Forward declaration for memory pool factory.\n */\ntypedef struct pj_pool_factory pj_pool_factory;\n\n/**\n * Opaque data type for memory pool.\n */\ntypedef struct pj_pool_t pj_pool_t;\n\n/**\n * Forward declaration for caching pool, a pool factory implementation.\n */\ntypedef struct pj_caching_pool pj_caching_pool;\n\n/**\n * This type is used as replacement to legacy C string, and used throughout\n * the library.\n */\ntypedef struct pj_str_t pj_str_t;\n\n/**\n * Opaque data type for I/O Queue structure.\n */\ntypedef struct pj_ioqueue_t pj_ioqueue_t;\n\n/**\n * Opaque data type for key that identifies a handle registered to the\n * I/O queue framework.\n */\ntypedef struct pj_ioqueue_key_t pj_ioqueue_key_t;\n\n/**\n * Opaque data to identify timer heap.\n */\ntypedef struct pj_timer_heap_t pj_timer_heap_t;\n\n/** \n * Opaque data type for atomic operations.\n */\ntypedef struct pj_atomic_t pj_atomic_t;\n\n/**\n * Value type of an atomic variable.\n */\ntypedef PJ_ATOMIC_VALUE_TYPE pj_atomic_value_t;\n \n/* ************************************************************************* */\n\n/** Thread handle. */\ntypedef struct pj_thread_t pj_thread_t;\n\n/** Lock object. */\ntypedef struct pj_lock_t pj_lock_t;\n\n/** Group lock */\ntypedef struct pj_grp_lock_t pj_grp_lock_t;\n\n/** Mutex handle. */\ntypedef struct pj_mutex_t pj_mutex_t;\n\n/** Semaphore handle. */\ntypedef struct pj_sem_t pj_sem_t;\n\n/** Event object. */\ntypedef struct pj_event_t pj_event_t;\n\n/** Unidirectional stream pipe object. */\ntypedef struct pj_pipe_t pj_pipe_t;\n\n/** Operating system handle. */\ntypedef void *pj_oshandle_t;\n\n/** Socket handle. */\n#if defined(PJ_WIN64) && PJ_WIN64!=0\n    typedef pj_int64_t pj_sock_t;\n#else\n    typedef long pj_sock_t;\n#endif\n\n/** Generic socket address. */\ntypedef void pj_sockaddr_t;\n\n/** Forward declaration. */\ntypedef struct pj_sockaddr_in pj_sockaddr_in;\n\n/** Color type. */\ntypedef unsigned int pj_color_t;\n\n/** Exception id. */\ntypedef int pj_exception_id_t;\n\n/* ************************************************************************* */\n\n/** Utility macro to compute the number of elements in static array. */\n#define PJ_ARRAY_SIZE(a)    (sizeof(a)/sizeof(a[0]))\n\n/**\n * Length of object names.\n */\n#define PJ_MAX_OBJ_NAME\t32\n\n/* ************************************************************************* */\n/*\n * General.\n */\n/**\n * Initialize the PJ Library.\n * This function must be called before using the library. The purpose of this\n * function is to initialize static library data, such as character table used\n * in random string generation, and to initialize operating system dependent\n * functionality (such as WSAStartup() in Windows).\n *\n * Apart from calling pj_init(), application typically should also initialize\n * the random seed by calling pj_srand().\n *\n * @return PJ_SUCCESS on success.\n */\nPJ_DECL(pj_status_t) pj_init(void);\n\n\n/**\n * Shutdown PJLIB.\n */\nPJ_DECL(void) pj_shutdown(void);\n\n/**\n * Type of callback to register to pj_atexit().\n */\ntypedef void (*pj_exit_callback)(void);\n\n/**\n * Register cleanup function to be called by PJLIB when pj_shutdown() is \n * called.\n *\n * @param func\t    The function to be registered.\n *\n * @return PJ_SUCCESS on success.\n */\nPJ_DECL(pj_status_t) pj_atexit(pj_exit_callback func);\n\n\n\n/**\n * Swap the byte order of an 16bit data.\n *\n * @param val16\t    The 16bit data.\n *\n * @return\t    An 16bit data with swapped byte order.\n */\nPJ_INLINE(pj_int16_t) pj_swap16(pj_int16_t val16)\n{\n    pj_uint8_t *p = (pj_uint8_t*)&val16;\n    pj_uint8_t tmp = *p;\n    *p = *(p+1);\n    *(p+1) = tmp;\n    return val16;\n}\n\n/**\n * Swap the byte order of an 32bit data.\n *\n * @param val32\t    The 32bit data.\n *\n * @return\t    An 32bit data with swapped byte order.\n */\nPJ_INLINE(pj_int32_t) pj_swap32(pj_int32_t val32)\n{\n    pj_uint8_t *p = (pj_uint8_t*)&val32;\n    pj_uint8_t tmp = *p;\n    *p = *(p+3);\n    *(p+3) = tmp;\n    tmp = *(p+1);\n    *(p+1) = *(p+2);\n    *(p+2) = tmp;\n    return val32;\n}\n\n/* This is to check if uint32 var will overflow if converted to signed long */\n#define PJ_CHECK_OVERFLOW_UINT32_TO_LONG(uint32_var, exec_on_overflow) \\\n\tdo { \\\n\t    if (uint32_var > PJ_MAXLONG) { \\\n\t\texec_on_overflow; \\\n\t    } \\\n\t} while (0)\n\n/**\n * @}\n */\n/**\n * @addtogroup PJ_TIME Time Data Type and Manipulation.\n * @ingroup PJ_MISC\n * @{\n */\n\n/**\n * Representation of time value in this library.\n * This type can be used to represent either an interval or a specific time\n * or date. \n */\ntypedef struct pj_time_val\n{\n    /** The seconds part of the time. */\n    long    sec;\n\n    /** The miliseconds fraction of the time. */\n    long    msec;\n\n} pj_time_val;\n\n/**\n * Normalize the value in time value.\n * @param t     Time value to be normalized.\n */\nPJ_DECL(void) pj_time_val_normalize(pj_time_val *t);\n\n/**\n * Get the total time value in miliseconds. This is the same as\n * multiplying the second part with 1000 and then add the miliseconds\n * part to the result.\n *\n * @param t     The time value.\n * @return      Total time in miliseconds.\n * @hideinitializer\n */\n#define PJ_TIME_VAL_MSEC(t)\t((t).sec * 1000 + (t).msec)\n\n/**\n * This macro will check if \\a t1 is equal to \\a t2.\n *\n * @param t1    The first time value to compare.\n * @param t2    The second time value to compare.\n * @return      Non-zero if both time values are equal.\n * @hideinitializer\n */\n#define PJ_TIME_VAL_EQ(t1, t2)\t((t1).sec==(t2).sec && (t1).msec==(t2).msec)\n\n/**\n * This macro will check if \\a t1 is greater than \\a t2\n *\n * @param t1    The first time value to compare.\n * @param t2    The second time value to compare.\n * @return      Non-zero if t1 is greater than t2.\n * @hideinitializer\n */\n#define PJ_TIME_VAL_GT(t1, t2)\t((t1).sec>(t2).sec || \\\n                                ((t1).sec==(t2).sec && (t1).msec>(t2).msec))\n\n/**\n * This macro will check if \\a t1 is greater than or equal to \\a t2\n *\n * @param t1    The first time value to compare.\n * @param t2    The second time value to compare.\n * @return      Non-zero if t1 is greater than or equal to t2.\n * @hideinitializer\n */\n#define PJ_TIME_VAL_GTE(t1, t2)\t(PJ_TIME_VAL_GT(t1,t2) || \\\n                                 PJ_TIME_VAL_EQ(t1,t2))\n\n/**\n * This macro will check if \\a t1 is less than \\a t2\n *\n * @param t1    The first time value to compare.\n * @param t2    The second time value to compare.\n * @return      Non-zero if t1 is less than t2.\n * @hideinitializer\n */\n#define PJ_TIME_VAL_LT(t1, t2)\t(!(PJ_TIME_VAL_GTE(t1,t2)))\n\n/**\n * This macro will check if \\a t1 is less than or equal to \\a t2.\n *\n * @param t1    The first time value to compare.\n * @param t2    The second time value to compare.\n * @return      Non-zero if t1 is less than or equal to t2.\n * @hideinitializer\n */\n#define PJ_TIME_VAL_LTE(t1, t2)\t(!PJ_TIME_VAL_GT(t1, t2))\n\n/**\n * Add \\a t2 to \\a t1 and store the result in \\a t1. Effectively\n *\n * this macro will expand as: (\\a t1 += \\a t2).\n * @param t1    The time value to add.\n * @param t2    The time value to be added to \\a t1.\n * @hideinitializer\n */\n#define PJ_TIME_VAL_ADD(t1, t2)\t    do {\t\t\t    \\\n\t\t\t\t\t(t1).sec += (t2).sec;\t    \\\n\t\t\t\t\t(t1).msec += (t2).msec;\t    \\\n\t\t\t\t\tpj_time_val_normalize(&(t1)); \\\n\t\t\t\t    } while (0)\n\n\n/**\n * Substract \\a t2 from \\a t1 and store the result in \\a t1. Effectively\n * this macro will expand as (\\a t1 -= \\a t2).\n *\n * @param t1    The time value to subsctract.\n * @param t2    The time value to be substracted from \\a t1.\n * @hideinitializer\n */\n#define PJ_TIME_VAL_SUB(t1, t2)\t    do {\t\t\t    \\\n\t\t\t\t\t(t1).sec -= (t2).sec;\t    \\\n\t\t\t\t\t(t1).msec -= (t2).msec;\t    \\\n\t\t\t\t\tpj_time_val_normalize(&(t1)); \\\n\t\t\t\t    } while (0)\n\n\n/**\n * This structure represent the parsed representation of time.\n * It is acquired by calling #pj_time_decode().\n */\ntypedef struct pj_parsed_time\n{\n    /** This represents day of week where value zero means Sunday */\n    int wday;\n\n    /* This represents day of the year, 0-365, where zero means\n     *  1st of January.\n     */\n    /*int yday; */\n\n    /** This represents day of month: 1-31 */\n    int day;\n\n    /** This represents month, with the value is 0 - 11 (zero is January) */\n    int mon;\n\n    /** This represent the actual year (unlike in ANSI libc where\n     *  the value must be added by 1900).\n     */\n    int year;\n\n    /** This represents the second part, with the value is 0-59 */\n    int sec;\n\n    /** This represents the minute part, with the value is: 0-59 */\n    int min;\n\n    /** This represents the hour part, with the value is 0-23 */\n    int hour;\n\n    /** This represents the milisecond part, with the value is 0-999 */\n    int msec;\n\n} pj_parsed_time;\n\n\n/**\n * @}\t// Time Management\n */\n\n/* ************************************************************************* */\n/*\n * Terminal.\n */\n/**\n * Color code combination.\n */\nenum {\n    PJ_TERM_COLOR_R\t= 2,    /**< Red            */\n    PJ_TERM_COLOR_G\t= 4,    /**< Green          */\n    PJ_TERM_COLOR_B\t= 1,    /**< Blue.          */\n    PJ_TERM_COLOR_BRIGHT = 8    /**< Bright mask.   */\n};\n\n\n\n\nPJ_END_DECL\n\n\n#endif /* __PJ_TYPES_H__ */\n\n", "/* $Id$ */\n/* \n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n#include <pj/file_io.h>\n#include <pj/assert.h>\n#include <pj/errno.h>\n#include <pj/limits.h>\n#include <stdio.h>\n#include <errno.h>\n\nPJ_DEF(pj_status_t) pj_file_open( pj_pool_t *pool,\n                                  const char *pathname, \n                                  unsigned flags,\n                                  pj_oshandle_t *fd)\n{\n    char mode[8];\n    char *p = mode;\n\n    PJ_ASSERT_RETURN(pathname && fd, PJ_EINVAL);\n    PJ_UNUSED_ARG(pool);\n\n    if ((flags & PJ_O_APPEND) == PJ_O_APPEND) {\n        if ((flags & PJ_O_WRONLY) == PJ_O_WRONLY) {\n            *p++ = 'a';\n            if ((flags & PJ_O_RDONLY) == PJ_O_RDONLY)\n                *p++ = '+';\n        } else {\n            /* This is invalid.\n             * Can not specify PJ_O_RDONLY with PJ_O_APPEND! \n             */\n        }\n    } else {\n        if ((flags & PJ_O_RDONLY) == PJ_O_RDONLY) {\n            *p++ = 'r';\n            if ((flags & PJ_O_WRONLY) == PJ_O_WRONLY)\n                *p++ = '+';\n        } else {\n            *p++ = 'w';\n        }\n    }\n\n    if (p==mode)\n        return PJ_EINVAL;\n\n    *p++ = 'b';\n    *p++ = '\\0';\n\n    *fd = fopen(pathname, mode);\n    if (*fd == NULL)\n        return PJ_RETURN_OS_ERROR(errno);\n    \n    return PJ_SUCCESS;\n}\n\nPJ_DEF(pj_status_t) pj_file_close(pj_oshandle_t fd)\n{\n    PJ_ASSERT_RETURN(fd, PJ_EINVAL);\n    if (fclose((FILE*)fd) != 0)\n        return PJ_RETURN_OS_ERROR(errno);\n\n    return PJ_SUCCESS;\n}\n\nPJ_DEF(pj_status_t) pj_file_write( pj_oshandle_t fd,\n                                   const void *data,\n                                   pj_ssize_t *size)\n{\n    size_t written;\n\n    clearerr((FILE*)fd);\n    written = fwrite(data, 1, *size, (FILE*)fd);\n    if (ferror((FILE*)fd)) {\n        *size = -1;\n        return PJ_RETURN_OS_ERROR(errno);\n    }\n\n    *size = written;\n    return PJ_SUCCESS;\n}\n\nPJ_DEF(pj_status_t) pj_file_read( pj_oshandle_t fd,\n                                  void *data,\n                                  pj_ssize_t *size)\n{\n    size_t bytes;\n\n    clearerr((FILE*)fd);\n    bytes = fread(data, 1, *size, (FILE*)fd);\n    if (ferror((FILE*)fd)) {\n        *size = -1;\n        return PJ_RETURN_OS_ERROR(errno);\n    }\n\n    *size = bytes;\n    return PJ_SUCCESS;\n}\n\n/*\nPJ_DEF(pj_bool_t) pj_file_eof(pj_oshandle_t fd, enum pj_file_access access)\n{\n    PJ_UNUSED_ARG(access);\n    return feof((FILE*)fd) ? PJ_TRUE : 0;\n}\n*/\n\nPJ_DEF(pj_status_t) pj_file_setpos( pj_oshandle_t fd,\n                                    pj_off_t offset,\n                                    enum pj_file_seek_type whence)\n{\n    int mode;\n\n    if ((sizeof(pj_off_t) > sizeof(long)) &&\n        (offset > PJ_MAXLONG || offset < PJ_MINLONG)) \n    {\n        return PJ_ENOTSUP;\n    }\n\n    switch (whence) {\n    case PJ_SEEK_SET:\n        mode = SEEK_SET; break;\n    case PJ_SEEK_CUR:\n        mode = SEEK_CUR; break;\n    case PJ_SEEK_END:\n        mode = SEEK_END; break;\n    default:\n        pj_assert(!\"Invalid whence in file_setpos\");\n        return PJ_EINVAL;\n    }\n\n    if (fseek((FILE*)fd, (long)offset, mode) != 0)\n        return PJ_RETURN_OS_ERROR(errno);\n\n    return PJ_SUCCESS;\n}\n\nPJ_DEF(pj_status_t) pj_file_getpos( pj_oshandle_t fd,\n                                    pj_off_t *pos)\n{\n    long offset;\n\n    offset = ftell((FILE*)fd);\n    if (offset == -1) {\n        *pos = -1;\n        return PJ_RETURN_OS_ERROR(errno);\n    }\n\n    *pos = offset;\n    return PJ_SUCCESS;\n}\n\nPJ_DEF(pj_status_t) pj_file_flush(pj_oshandle_t fd)\n{\n    int rc;\n\n    rc = fflush((FILE*)fd);\n    if (rc == EOF) {\n\treturn PJ_RETURN_OS_ERROR(errno);\n    }\n\n    return PJ_SUCCESS;\n}\n", "/* $Id$ */\n/* \n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n\n/**\n * Default file player/writer buffer size.\n */\n#include <pjmedia/avi_stream.h>\n#include <pjmedia/alaw_ulaw.h>\n#include <pjmedia/avi.h>\n#include <pjmedia/errno.h>\n#include <pjmedia/wave.h>\n#include <pj/assert.h>\n#include <pj/file_access.h>\n#include <pj/file_io.h>\n#include <pj/log.h>\n#include <pj/pool.h>\n#include <pj/string.h>\n\n\n#if defined(PJMEDIA_HAS_VIDEO) && (PJMEDIA_HAS_VIDEO != 0)\n\n\n#define THIS_FILE   \"avi_player.c\"\n\n#define AVIF_MUSTUSEINDEX       0x00000020\n#define AVIF_ISINTERLEAVED      0x00000100\n#define AVISF_DISABLED          0x00000001\n#define AVISF_VIDEO_PALCHANGES  0x00010000\n\n#define AVI_EOF 0xFFEEFFEE\n\n//#define COMPARE_TAG(doc_tag, tag) (doc_tag==*((pj_uint32_t*)avi_tags[tag]))\n#define COMPARE_TAG(doc_tag, tag) \\\n\t    (pj_memcmp(&(doc_tag), &avi_tags[tag], 4)==0)\n\n#define SIGNATURE\t    PJMEDIA_SIG_PORT_VID_AVI_PLAYER\n\n#define VIDEO_CLOCK_RATE\t90000\n\n#if 0\n#   define TRACE_(x)\tPJ_LOG(4,x)\n#else\n#   define TRACE_(x)\n#endif\n\n#if defined(PJ_IS_BIG_ENDIAN) && PJ_IS_BIG_ENDIAN!=0\n    static void data_to_host(void *data, pj_uint8_t bits, unsigned count)\n    {\n\tunsigned i;\n\n        count /= (bits == 32? 4 : 2);\n\n\tif (bits == 32) {\n\t    pj_int32_t *data32 = (pj_int32_t *)data;\n\t    for (i=0; i<count; ++i)\n\t\tdata32[i] = pj_swap32(data32[i]);\n\t} else {\n\t    pj_int16_t *data16 = (pj_int16_t *)data;\n\t    for (i=0; i<count; ++i)\n\t\tdata16[i] = pj_swap16(data16[i]);\n\t}\n\n    }\n    static void data_to_host2(void *data, pj_uint8_t nsizes,\n                              pj_uint8_t *sizes)\n    {\n\tunsigned i;\n        pj_int8_t *datap = (pj_int8_t *)data;\n        for (i = 0; i < nsizes; i++) {\n            data_to_host(datap, 32, sizes[i]);\n            datap += sizes[i++];\n            if (i >= nsizes)\n                break;\n            data_to_host(datap, 16, sizes[i]);\n            datap += sizes[i];\n\t}\n    }\n#else\n#   define data_to_host(data, bits, count)\n#   define data_to_host2(data, nsizes, sizes)\n#endif\n\ntypedef struct avi_fmt_info\n{\n    pjmedia_format_id   fmt_id;\n    pjmedia_format_id   eff_fmt_id;\n} avi_fmt_info;\n\nstatic avi_fmt_info avi_fmts[] =\n{\n    {PJMEDIA_FORMAT_MJPEG}, {PJMEDIA_FORMAT_H264},\n    {PJMEDIA_FORMAT_UYVY}, {PJMEDIA_FORMAT_YUY2},\n    {PJMEDIA_FORMAT_IYUV}, {PJMEDIA_FORMAT_I420},\n    {PJMEDIA_FORMAT_DIB}, {PJMEDIA_FORMAT_RGB24},\n    {PJMEDIA_FORMAT_RGB32},\n    {PJMEDIA_FORMAT_PACK('X','V','I','D'), PJMEDIA_FORMAT_MPEG4},\n    {PJMEDIA_FORMAT_PACK('x','v','i','d'), PJMEDIA_FORMAT_MPEG4},\n    {PJMEDIA_FORMAT_PACK('D','I','V','X'), PJMEDIA_FORMAT_MPEG4},\n    {PJMEDIA_FORMAT_PACK('F','M','P','4'), PJMEDIA_FORMAT_MPEG4},\n    {PJMEDIA_FORMAT_PACK('D','X','5','0'), PJMEDIA_FORMAT_MPEG4}\n};\n\nstruct pjmedia_avi_streams\n{\n    unsigned        num_streams;\n    pjmedia_port  **streams;\n};\n\nstruct avi_reader_port\n{\n    pjmedia_port     base;\n    unsigned         stream_id;\n    unsigned\t     options;\n    pjmedia_format_id fmt_id;\n    unsigned         usec_per_frame;\n    pj_uint16_t\t     bits_per_sample;\n    pj_bool_t\t     eof;\n    pj_off_t\t     fsize;\n    pj_off_t\t     start_data;\n    pj_uint8_t       pad;\n    pj_oshandle_t    fd;\n    pj_ssize_t       size_left;\n    pj_timestamp     next_ts;\n\n    pj_status_t\t   (*cb)(pjmedia_port*, void*);\n    pj_bool_t\t     subscribed;\n    void\t   (*cb2)(pjmedia_port*, void*);\n};\n\n\nstatic pj_status_t avi_get_frame(pjmedia_port *this_port, \n\t\t\t         pjmedia_frame *frame);\nstatic pj_status_t avi_on_destroy(pjmedia_port *this_port);\n\nstatic struct avi_reader_port *create_avi_port(pj_pool_t *pool)\n{\n    const pj_str_t name = pj_str(\"file\");\n    struct avi_reader_port *port;\n\n    port = PJ_POOL_ZALLOC_T(pool, struct avi_reader_port);\n    if (!port)\n\treturn NULL;\n\n    /* Put in default values.\n     * These will be overriden once the file is read.\n     */\n    pjmedia_port_info_init(&port->base.info, &name, SIGNATURE, \n\t\t\t   8000, 1, 16, 80);\n\n    port->fd = (pj_oshandle_t)(pj_ssize_t)-1;\n    port->base.get_frame = &avi_get_frame;\n    port->base.on_destroy = &avi_on_destroy;\n\n    return port;\n}\n\n#define file_read(fd, data, size) file_read2(fd, data, size, 32)\n#define file_read2(fd, data, size, bits) file_read3(fd, data, size, bits, NULL)\n\nstatic pj_status_t file_read3(pj_oshandle_t fd, void *data, pj_ssize_t size,\n                              pj_uint16_t bits, pj_ssize_t *psz_read)\n{\n    pj_ssize_t size_read = size, size_to_read = size;\n    pj_status_t status = pj_file_read(fd, data, &size_read);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    /* Normalize AVI header fields values from little-endian to host\n     * byte order.\n     */\n    if (bits > 0)\n        data_to_host(data, bits, size_read);\n\n    if (size_read != size_to_read) {\n        if (psz_read)\n            *psz_read = size_read;\n        return AVI_EOF;\n    }\n\n    return status;\n}\n\n/*\n * Create AVI player port.\n */\nPJ_DEF(pj_status_t)\npjmedia_avi_player_create_streams(pj_pool_t *pool,\n                                  const char *filename,\n\t\t\t\t  unsigned options,\n\t\t\t\t  pjmedia_avi_streams **p_streams)\n{\n    pjmedia_avi_hdr avi_hdr;\n    struct avi_reader_port *fport[PJMEDIA_AVI_MAX_NUM_STREAMS];\n    pj_off_t pos;\n    unsigned i, nstr = 0;\n    pj_status_t status = PJ_SUCCESS;\n\n    /* Check arguments. */\n    PJ_ASSERT_RETURN(pool && filename && p_streams, PJ_EINVAL);\n\n    /* Check the file really exists. */\n    if (!pj_file_exists(filename)) {\n\treturn PJ_ENOTFOUND;\n    }\n\n    /* Create fport instance. */\n    fport[0] = create_avi_port(pool);\n    if (!fport[0]) {\n\treturn PJ_ENOMEM;\n    }\n\n    /* Get the file size. */\n    fport[0]->fsize = pj_file_size(filename);\n\n    /* Size must be more than AVI header size */\n    if (fport[0]->fsize <= sizeof(riff_hdr_t) + sizeof(avih_hdr_t) + \n                           sizeof(strl_hdr_t))\n    {\n\treturn PJMEDIA_EINVALIMEDIATYPE;\n    }\n\n    /* Open file. */\n    status = pj_file_open(pool, filename, PJ_O_RDONLY, &fport[0]->fd);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Read the RIFF + AVIH header. */\n    status = file_read(fport[0]->fd, &avi_hdr,\n                       sizeof(riff_hdr_t) + sizeof(avih_hdr_t));\n    if (status != PJ_SUCCESS)\n        goto on_error;\n\n    /* Validate AVI file. */\n    if (!COMPARE_TAG(avi_hdr.riff_hdr.riff, PJMEDIA_AVI_RIFF_TAG) ||\n\t!COMPARE_TAG(avi_hdr.riff_hdr.avi, PJMEDIA_AVI_AVI_TAG) ||\n        !COMPARE_TAG(avi_hdr.avih_hdr.list_tag, PJMEDIA_AVI_LIST_TAG) ||\n        !COMPARE_TAG(avi_hdr.avih_hdr.hdrl_tag, PJMEDIA_AVI_HDRL_TAG) ||\n        !COMPARE_TAG(avi_hdr.avih_hdr.avih, PJMEDIA_AVI_AVIH_TAG))\n    {\n\tstatus = PJMEDIA_EINVALIMEDIATYPE;\n        goto on_error;\n    }\n\n    PJ_LOG(5, (THIS_FILE, \"The AVI file has %d streams.\",\n               avi_hdr.avih_hdr.num_streams));\n\n    /* Unsupported AVI format. */\n    if (avi_hdr.avih_hdr.num_streams > PJMEDIA_AVI_MAX_NUM_STREAMS) {\n        status = PJMEDIA_EAVIUNSUPP;\n        goto on_error;\n    }\n\n    /** \n     * TODO: Possibly unsupported AVI format.\n     * If you encounter this warning, verify whether the avi player\n     * is working properly.\n     */\n    if (avi_hdr.avih_hdr.flags & AVIF_MUSTUSEINDEX ||\n        avi_hdr.avih_hdr.pad > 1)\n    {\n        PJ_LOG(3, (THIS_FILE, \"Warning!!! Possibly unsupported AVI format: \"\n                   \"flags:%d, pad:%d\", avi_hdr.avih_hdr.flags, \n                   avi_hdr.avih_hdr.pad));\n    }\n\n    /* Read the headers of each stream. */\n    for (i = 0; i < avi_hdr.avih_hdr.num_streams; i++) {\n        pj_size_t elem = 0;\n        pj_off_t size_to_read;\n\n        /* Read strl header */\n        status = file_read(fport[0]->fd, &avi_hdr.strl_hdr[i],\n                           sizeof(strl_hdr_t));\n        if (status != PJ_SUCCESS)\n            goto on_error;\n        \n        elem = COMPARE_TAG(avi_hdr.strl_hdr[i].data_type, \n                           PJMEDIA_AVI_VIDS_TAG) ? \n               sizeof(strf_video_hdr_t) :\n               COMPARE_TAG(avi_hdr.strl_hdr[i].data_type, \n                           PJMEDIA_AVI_AUDS_TAG) ?\n               sizeof(strf_audio_hdr_t) : 0;\n\n        /* Read strf header */\n        status = file_read2(fport[0]->fd, &avi_hdr.strf_hdr[i],\n                            elem, 0);\n        if (status != PJ_SUCCESS)\n            goto on_error;\n\n        /* Normalize the endian */\n        if (elem == sizeof(strf_video_hdr_t))\n            data_to_host2(&avi_hdr.strf_hdr[i],\n                          sizeof(strf_video_hdr_sizes)/\n                          sizeof(strf_video_hdr_sizes[0]),\n                          strf_video_hdr_sizes);\n        else if (elem == sizeof(strf_audio_hdr_t))\n            data_to_host2(&avi_hdr.strf_hdr[i],\n                          sizeof(strf_audio_hdr_sizes)/\n                          sizeof(strf_audio_hdr_sizes[0]),\n                          strf_audio_hdr_sizes);\n\n        /* Skip the remainder of the header */\n        size_to_read = avi_hdr.strl_hdr[i].list_sz - (sizeof(strl_hdr_t) -\n                       8) - elem;\n\tstatus = pj_file_setpos(fport[0]->fd, size_to_read, PJ_SEEK_CUR);\n\tif (status != PJ_SUCCESS) {\n            goto on_error;\n\t}\n    }\n\n    /* Finish reading the AVIH header */\n    status = pj_file_setpos(fport[0]->fd, avi_hdr.avih_hdr.list_sz +\n                            sizeof(riff_hdr_t) + 8, PJ_SEEK_SET);\n    if (status != PJ_SUCCESS) {\n        goto on_error;\n    }\n\n    /* Skip any JUNK or LIST INFO until we get MOVI tag */\n    do {\n        pjmedia_avi_subchunk ch;\n        int read = 0;\n        pj_off_t size_to_read;\n\n        status = file_read(fport[0]->fd, &ch, sizeof(pjmedia_avi_subchunk));\n        if (status != PJ_SUCCESS) {\n            goto on_error;\n        }\n\n        if (COMPARE_TAG(ch.id, PJMEDIA_AVI_LIST_TAG))\n        {\n            read = 4;\n            status = file_read(fport[0]->fd, &ch, read);\n            if (COMPARE_TAG(ch.id, PJMEDIA_AVI_MOVI_TAG))\n                break;\n        }\n\n        if (ch.len < read) {\n            status = PJ_EINVAL;\n            goto on_error;\n        }\n        PJ_CHECK_OVERFLOW_UINT32_TO_LONG(ch.len - read, \n                                         status = PJ_EINVAL; goto on_error;);\n        size_to_read = (pj_off_t)ch.len - read;\n\n        status = pj_file_setpos(fport[0]->fd, size_to_read, PJ_SEEK_CUR);\n        if (status != PJ_SUCCESS) {\n            goto on_error;\n        }\n    } while(1);\n\n    status = pj_file_getpos(fport[0]->fd, &pos);\n    if (status != PJ_SUCCESS)\n        goto on_error;\n\n    for (i = 0, nstr = 0; i < avi_hdr.avih_hdr.num_streams; i++) {\n\tpjmedia_format_id fmt_id;\n\n        /* Skip non-audio, non-video, or disabled streams) */\n        if ((!COMPARE_TAG(avi_hdr.strl_hdr[i].data_type, \n                          PJMEDIA_AVI_VIDS_TAG) &&\n             !COMPARE_TAG(avi_hdr.strl_hdr[i].data_type, \n                          PJMEDIA_AVI_AUDS_TAG)) ||\n            avi_hdr.strl_hdr[i].flags & AVISF_DISABLED)\n        {\n            continue;\n        }\n\n        if (COMPARE_TAG(avi_hdr.strl_hdr[i].data_type, \n                        PJMEDIA_AVI_VIDS_TAG))\n        {\n            int j;\n\n            if (avi_hdr.strl_hdr[i].flags & AVISF_VIDEO_PALCHANGES) {\n                PJ_LOG(4, (THIS_FILE, \"Unsupported video stream\"));\n                continue;\n            }\n\n            fmt_id = avi_hdr.strl_hdr[i].codec;\n            for (j = sizeof(avi_fmts)/sizeof(avi_fmts[0])-1; j >= 0; j--) {\n                /* Check supported video formats here */\n                if (fmt_id == avi_fmts[j].fmt_id) {\n                    if (avi_fmts[j].eff_fmt_id)\n                        fmt_id = avi_fmts[j].eff_fmt_id;\n                    break;\n                }\n            }\n            \n            if (j < 0) {\n                PJ_LOG(4, (THIS_FILE, \"Unsupported video stream\"));\n                continue;\n            }\n        } else {\n            /* Check supported audio formats here */\n\t    strf_audio_hdr_t *hdr = (strf_audio_hdr_t*)\n\t\t\t\t    &avi_hdr.strf_hdr[i].strf_audio_hdr;\n            if (hdr->fmt_tag == PJMEDIA_WAVE_FMT_TAG_PCM &&\n\t\thdr->bits_per_sample == 16)\n\t    {\n\t\tfmt_id = PJMEDIA_FORMAT_PCM;\n\t    }\n\t    else if (hdr->fmt_tag == PJMEDIA_WAVE_FMT_TAG_ALAW)\n\t    {\n\t\tfmt_id = PJMEDIA_FORMAT_PCMA;\n\t    }\n\t    else if (hdr->fmt_tag == PJMEDIA_WAVE_FMT_TAG_ULAW)\n\t    {\n\t\tfmt_id = PJMEDIA_FORMAT_PCMU;\n\t    }\n\t    else\n            {\n                PJ_LOG(4, (THIS_FILE, \"Unsupported audio stream\"));\n                continue;\n            }\n        }\n\n        if (nstr > 0) {\n            /* Create fport instance. */\n            fport[nstr] = create_avi_port(pool);\n            if (!fport[nstr]) {\n\t        status = PJ_ENOMEM;\n                goto on_error;\n            }\n\n            /* Open file. */\n            status = pj_file_open(pool, filename, PJ_O_RDONLY,\n                                  &fport[nstr]->fd);\n            if (status != PJ_SUCCESS)\n                goto on_error;\n\n            /* Set the file position */\n            status = pj_file_setpos(fport[nstr]->fd, pos, PJ_SEEK_SET);\n            if (status != PJ_SUCCESS) {\n                goto on_error;\n            }\n        }\n\n        fport[nstr]->stream_id = i;\n        fport[nstr]->fmt_id = fmt_id;\n\n        nstr++;\n    }\n\n    if (nstr == 0) {\n        status = PJMEDIA_EAVIUNSUPP;\n        goto on_error;\n    }\n\n    for (i = 0; i < nstr; i++) {\n        strl_hdr_t *strl_hdr = &avi_hdr.strl_hdr[fport[i]->stream_id];\n\n        /* Initialize */\n        fport[i]->options = options;\n        fport[i]->fsize = fport[0]->fsize;\n        /* Current file position now points to start of data */\n        fport[i]->start_data = pos;\n        \n        if (COMPARE_TAG(strl_hdr->data_type, PJMEDIA_AVI_VIDS_TAG)) {\n            strf_video_hdr_t *strf_hdr =\n                &avi_hdr.strf_hdr[fport[i]->stream_id].strf_video_hdr;\n            const pjmedia_video_format_info *vfi;\n\n            vfi = pjmedia_get_video_format_info(\n                pjmedia_video_format_mgr_instance(),\n                strl_hdr->codec);\n\n            fport[i]->bits_per_sample = (vfi ? vfi->bpp : 0);\n            fport[i]->usec_per_frame = avi_hdr.avih_hdr.usec_per_frame;\n            pjmedia_format_init_video(&fport[i]->base.info.fmt,\n                                      fport[i]->fmt_id,\n                                      strf_hdr->biWidth,\n                                      strf_hdr->biHeight,\n                                      strl_hdr->rate,\n                                      strl_hdr->scale);\n#if 0\n            /* The calculation below is wrong. strf_hdr->biSizeImage shows\n             * uncompressed size. Looks like we need to go the ugly way to\n             * get the bitrage:\n             *    http://www.virtualdub.org/blog/pivot/entry.php?id=159\n             */\n            bps = strf_hdr->biSizeImage * 8 * strl_hdr->rate / strl_hdr->scale;\n            if (bps==0) {\n        \t/* strf_hdr->biSizeImage may be zero for uncompressed RGB */\n        \tbps = strf_hdr->biWidth * strf_hdr->biHeight *\n        \t\tstrf_hdr->biBitCount *\n        \t\tstrl_hdr->rate / strl_hdr->scale;\n            }\n            fport[i]->base.info.fmt.det.vid.avg_bps = bps;\n            fport[i]->base.info.fmt.det.vid.max_bps = bps;\n#endif\n        } else {\n            strf_audio_hdr_t *strf_hdr =\n                &avi_hdr.strf_hdr[fport[i]->stream_id].strf_audio_hdr;\n\n            fport[i]->bits_per_sample = strf_hdr->bits_per_sample;\n            fport[i]->usec_per_frame = avi_hdr.avih_hdr.usec_per_frame;\n            pjmedia_format_init_audio(&fport[i]->base.info.fmt,\n                                      fport[i]->fmt_id,\n                                      strf_hdr->sample_rate,\n                                      strf_hdr->nchannels,\n                                      strf_hdr->bits_per_sample,\n                                      20000 /* fport[i]->usec_per_frame */,\n                                      strf_hdr->bytes_per_sec * 8,\n                                      strf_hdr->bytes_per_sec * 8);\n\n\t    /* Set format to PCM (we will decode PCMA/U) */\n\t    if (fport[i]->fmt_id == PJMEDIA_FORMAT_PCMA ||\n\t\tfport[i]->fmt_id == PJMEDIA_FORMAT_PCMU)\n\t    {\n\t\tfport[i]->base.info.fmt.id = PJMEDIA_FORMAT_PCM;\n\t\tfport[i]->base.info.fmt.det.aud.bits_per_sample = 16;\n\t    }\n\t}\n\n        pj_strdup2(pool, &fport[i]->base.info.name, filename);\n    }\n\n    /* Done. */\n    *p_streams = pj_pool_alloc(pool, sizeof(pjmedia_avi_streams));\n    (*p_streams)->num_streams = nstr;\n    (*p_streams)->streams = pj_pool_calloc(pool, (*p_streams)->num_streams,\n                                           sizeof(pjmedia_port *));\n    for (i = 0; i < nstr; i++)\n        (*p_streams)->streams[i] = &fport[i]->base;\n\n    PJ_LOG(4,(THIS_FILE, \n\t      \"AVI file player '%.*s' created with \"\n\t      \"%d media ports\",\n\t      (int)fport[0]->base.info.name.slen,\n\t      fport[0]->base.info.name.ptr,\n              (*p_streams)->num_streams));\n\n    return PJ_SUCCESS;\n\non_error:\n    fport[0]->base.on_destroy(&fport[0]->base);\n    for (i = 1; i < nstr; i++)\n        fport[i]->base.on_destroy(&fport[i]->base);\n    if (status == AVI_EOF)\n        return PJMEDIA_EINVALIMEDIATYPE;\n    return status;\n}\n\nPJ_DEF(unsigned)\npjmedia_avi_streams_get_num_streams(pjmedia_avi_streams *streams)\n{\n    pj_assert(streams);\n    return streams->num_streams;\n}\n\nPJ_DEF(pjmedia_avi_stream *)\npjmedia_avi_streams_get_stream(pjmedia_avi_streams *streams,\n                               unsigned idx)\n{\n    pj_assert(streams);\n    return (idx < streams->num_streams ? streams->streams[idx] : NULL);\n}\n\nPJ_DEF(pjmedia_avi_stream *)\npjmedia_avi_streams_get_stream_by_media(pjmedia_avi_streams *streams,\n                                        unsigned start_idx,\n                                        pjmedia_type media_type)\n{\n    unsigned i;\n\n    pj_assert(streams);\n    for (i = start_idx; i < streams->num_streams; i++)\n        if (streams->streams[i]->info.fmt.type == media_type)\n            return streams->streams[i];\n    return NULL;\n}\n\n\n/*\n * Get the data length, in bytes.\n */\nPJ_DEF(pj_ssize_t) pjmedia_avi_stream_get_len(pjmedia_avi_stream *stream)\n{\n    struct avi_reader_port *fport;\n\n    /* Sanity check */\n    PJ_ASSERT_RETURN(stream, -PJ_EINVAL);\n\n    /* Check that this is really a player port */\n    PJ_ASSERT_RETURN(stream->info.signature == SIGNATURE, -PJ_EINVALIDOP);\n\n    fport = (struct avi_reader_port*) stream;\n\n    return (pj_ssize_t)(fport->fsize - fport->start_data);\n}\n\n\n#if !DEPRECATED_FOR_TICKET_2251\n/*\n * Register a callback to be called when the file reading has reached the\n * end of file.\n */\nPJ_DEF(pj_status_t)\npjmedia_avi_stream_set_eof_cb( pjmedia_avi_stream *stream,\n\t\t\t       void *user_data,\n\t\t\t       pj_status_t (*cb)(pjmedia_avi_stream *stream,\n\t\t\t\t\t\t void *usr_data))\n{\n    struct avi_reader_port *fport;\n\n    /* Sanity check */\n    PJ_ASSERT_RETURN(stream, -PJ_EINVAL);\n\n    /* Check that this is really a player port */\n    PJ_ASSERT_RETURN(stream->info.signature == SIGNATURE, -PJ_EINVALIDOP);\n\n    PJ_LOG(1, (THIS_FILE, \"pjmedia_avi_stream_set_eof_cb() is deprecated. \"\n    \t       \"Use pjmedia_avi_stream_set_eof_cb2() instead.\"));\n\n    fport = (struct avi_reader_port*) stream;\n\n    fport->base.port_data.pdata = user_data;\n    fport->cb = cb;\n\n    return PJ_SUCCESS;\n}\n#endif\n\n\n/*\n * Register a callback to be called when the file reading has reached the\n * end of file.\n */\nPJ_DEF(pj_status_t)\npjmedia_avi_stream_set_eof_cb2(pjmedia_avi_stream *stream,\n\t\t\t       void *user_data,\n\t\t\t       void (*cb)(pjmedia_avi_stream *stream,\n\t\t\t\t\t  void *usr_data))\n{\n    struct avi_reader_port *fport;\n\n    /* Sanity check */\n    PJ_ASSERT_RETURN(stream, -PJ_EINVAL);\n\n    /* Check that this is really a player port */\n    PJ_ASSERT_RETURN(stream->info.signature == SIGNATURE, -PJ_EINVALIDOP);\n\n    fport = (struct avi_reader_port*) stream;\n\n    fport->base.port_data.pdata = user_data;\n    fport->cb2 = cb;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic pj_status_t file_on_event(pjmedia_event *event,\n                                 void *user_data)\n{\n    struct avi_reader_port *fport = (struct avi_reader_port*)user_data;\n\n    if (event->type == PJMEDIA_EVENT_CALLBACK) {\n\tif (fport->cb2)\n\t    (*fport->cb2)(&fport->base, fport->base.port_data.pdata);\n    }\n    \n    return PJ_SUCCESS;\n}\n\n\n/*\n * Get frame from file.\n */\nstatic pj_status_t avi_get_frame(pjmedia_port *this_port, \n\t\t\t         pjmedia_frame *frame)\n{\n    struct avi_reader_port *fport = (struct avi_reader_port*)this_port;\n    pj_status_t status = PJ_SUCCESS;\n    pj_ssize_t size_read = 0, size_to_read = 0;\n\n    pj_assert(fport->base.info.signature == SIGNATURE);\n\n    /* We encountered end of file */\n    if (fport->eof) {\n\tPJ_LOG(5,(THIS_FILE, \"File port %.*s EOF\",\n\t\t  (int)fport->base.info.name.slen,\n\t\t  fport->base.info.name.ptr));\n\n\t/* Call callback, if any */\n\tif (fport->cb2) {\n\t    pj_bool_t no_loop = (fport->options & PJMEDIA_AVI_FILE_NO_LOOP);\n\n\t    if (!fport->subscribed) {\n\t    \tstatus = pjmedia_event_subscribe(NULL, &file_on_event,\n\t    \t\t\t\t         fport, fport);\n\t    \tfport->subscribed = (status == PJ_SUCCESS)? PJ_TRUE:\n\t    \t\t\t    PJ_FALSE;\n\t    }\n\n\t    if (fport->subscribed && fport->eof != 2) {\n\t    \tpjmedia_event event;\n\n\t    \tif (no_loop) {\n\t    \t    /* To prevent the callback from being called repeatedly */\n\t    \t    fport->eof = 2;\n\t    \t} else {\n\t    \t    fport->eof = PJ_FALSE;\n        \t    pj_file_setpos(fport->fd, fport->start_data, PJ_SEEK_SET);\n\t    \t}\n\n\t    \tpjmedia_event_init(&event, PJMEDIA_EVENT_CALLBACK,\n\t                      \t   NULL, fport);\n\t    \tpjmedia_event_publish(NULL, fport, &event,\n\t                              PJMEDIA_EVENT_PUBLISH_POST_EVENT);\n\t    }\n\t    \n\t    /* Should not access player port after this since\n\t     * it might have been destroyed by the callback.\n\t     */\n\t    frame->type = PJMEDIA_FRAME_TYPE_NONE;\n\t    frame->size = 0;\n\t    \n\t    return (no_loop? PJ_EEOF: PJ_SUCCESS);\n\n\t} else if (fport->cb) {\n\t    status = (*fport->cb)(this_port, fport->base.port_data.pdata);\n\t}\n\n\t/* If callback returns non PJ_SUCCESS or 'no loop' is specified,\n\t * return immediately (and don't try to access player port since\n\t * it might have been destroyed by the callback).\n\t */\n\tif ((status != PJ_SUCCESS) ||\n            (fport->options & PJMEDIA_AVI_FILE_NO_LOOP)) \n        {\n\t    frame->type = PJMEDIA_FRAME_TYPE_NONE;\n\t    frame->size = 0;\n\t    return PJ_EEOF;\n\t}\n\n        /* Rewind file */\n\tPJ_LOG(5,(THIS_FILE, \"File port %.*s rewinding..\",\n\t\t  (int)fport->base.info.name.slen,\n\t\t  fport->base.info.name.ptr));\n\tfport->eof = PJ_FALSE;\n        pj_file_setpos(fport->fd, fport->start_data, PJ_SEEK_SET);\n    }\n\n    /* For PCMU/A audio stream, reduce frame size to half (temporarily). */\n    if (fport->base.info.fmt.type == PJMEDIA_TYPE_AUDIO &&\n\t(fport->fmt_id == PJMEDIA_FORMAT_PCMA ||\n\t fport->fmt_id == PJMEDIA_FORMAT_PCMU))\n    {\n\tframe->size >>= 1;\n    }\n\n    /* Fill frame buffer. */\n    size_to_read = frame->size;\n    do {\n        pjmedia_avi_subchunk ch = {0, 0};\n        char *cid;\n        unsigned stream_id;\n\n        /* We need to read data from the file past the chunk boundary */\n        if (fport->size_left > 0 && fport->size_left < size_to_read) {\n            status = file_read3(fport->fd, frame->buf, fport->size_left,\n                                fport->bits_per_sample, &size_read);\n            if (status != PJ_SUCCESS)\n                goto on_error2;\n            size_to_read -= fport->size_left;\n            fport->size_left = 0;\n        }\n\n        /* Read new chunk data */\n        if (fport->size_left == 0) {\n            pj_off_t pos;\n            pj_off_t ch_len;\n\n            pj_file_getpos(fport->fd, &pos);\n\n            /* Data is padded to the nearest WORD boundary */\n            if (fport->pad) {\n                status = pj_file_setpos(fport->fd, fport->pad, PJ_SEEK_CUR);\n                fport->pad = 0;\n            }\n\n            status = file_read(fport->fd, &ch, sizeof(pjmedia_avi_subchunk));\n            if (status != PJ_SUCCESS) {\n                size_read = 0;\n                goto on_error2;\n            }\n            \n            PJ_CHECK_OVERFLOW_UINT32_TO_LONG(ch.len, \n                                         status = PJ_EINVAL;  goto on_error2;);\n            ch_len = ch.len;\n\n            cid = (char *)&ch.id;\n            if (cid[0] >= '0' && cid[0] <= '9' &&\n                cid[1] >= '0' && cid[1] <= '9') \n            {\n                stream_id = (cid[0] - '0') * 10 + (cid[1] - '0');\n            } else\n                stream_id = 100;\n            fport->pad = (pj_uint8_t)ch.len & 1;\n\n            TRACE_((THIS_FILE, \"Reading movi data at pos %u (%x), id: %.*s, \"\n                               \"length: %u\", (unsigned long)pos,\n                               (unsigned long)pos, 4, cid, ch.len));\n\n            /* We are only interested in data with our stream id */\n            if (stream_id != fport->stream_id) {\n                if (COMPARE_TAG(ch.id, PJMEDIA_AVI_LIST_TAG))\n                    PJ_LOG(5, (THIS_FILE, \"Unsupported LIST tag found in \"\n                                          \"the movi data.\"));\n                else if (COMPARE_TAG(ch.id, PJMEDIA_AVI_RIFF_TAG)) {\n                    PJ_LOG(3, (THIS_FILE, \"Unsupported format: multiple \"\n                           \"AVIs in a single file.\"));\n                    status = AVI_EOF;\n                    goto on_error2;\n                }\n\n                status = pj_file_setpos(fport->fd, ch_len, PJ_SEEK_CUR);\n                continue;\n            }\n            fport->size_left = ch.len;\n        }\n\n        frame->type = (fport->base.info.fmt.type == PJMEDIA_TYPE_VIDEO ?\n                       PJMEDIA_FRAME_TYPE_VIDEO : PJMEDIA_FRAME_TYPE_AUDIO);\n\n        if (frame->type == PJMEDIA_FRAME_TYPE_AUDIO) {\n            if (size_to_read > fport->size_left)\n                size_to_read = fport->size_left;\n            status = file_read3(fport->fd, (char *)frame->buf + frame->size -\n                                size_to_read, size_to_read,\n                                fport->bits_per_sample, &size_read);\n            if (status != PJ_SUCCESS)\n                goto on_error2;\n            fport->size_left -= size_to_read;\n        } else {\n            pj_assert(frame->size >= ch.len);\n            status = file_read3(fport->fd, frame->buf, ch.len,\n                                0, &size_read);\n            if (status != PJ_SUCCESS)\n                goto on_error2;\n            frame->size = ch.len;\n            fport->size_left = 0;\n        }\n\n        break;\n\n    } while(1);\n    frame->timestamp.u64 = fport->next_ts.u64;\n    if (frame->type == PJMEDIA_FRAME_TYPE_AUDIO) {\n\n\t/* Decode PCMU/A frame */\n\tif (fport->fmt_id == PJMEDIA_FORMAT_PCMA ||\n\t    fport->fmt_id == PJMEDIA_FORMAT_PCMU)\n\t{\n\t    unsigned i;\n\t    pj_uint16_t *dst;\n\t    pj_uint8_t *src;\n\n\t    dst = (pj_uint16_t*)frame->buf + frame->size - 1;\n\t    src = (pj_uint8_t*)frame->buf + frame->size - 1;\n\n\t    if (fport->fmt_id == PJMEDIA_FORMAT_PCMU) {\n\t\tfor (i = 0; i < frame->size; ++i) {\n\t\t    *dst-- = (pj_uint16_t) pjmedia_ulaw2linear(*src--);\n\t\t}\n\t    } else {\n\t\tfor (i = 0; i < frame->size; ++i) {\n\t\t    *dst-- = (pj_uint16_t) pjmedia_alaw2linear(*src--);\n\t\t}\n\t    }\n\n\t    /* Return back the frame size */\n\t    frame->size <<= 1;\n\t}\n\n\tif (fport->usec_per_frame) {\n\t    fport->next_ts.u64 += (fport->usec_per_frame *\n\t\t\t\t   fport->base.info.fmt.det.aud.clock_rate /\n\t\t\t\t   1000000);\n\t} else {\n\t    fport->next_ts.u64 += (frame->size *\n\t\t\t\t   fport->base.info.fmt.det.aud.clock_rate /\n\t\t\t\t   (fport->base.info.fmt.det.aud.avg_bps / 8));\n\t}\n    } else {\n\tif (fport->usec_per_frame) {\n\t    fport->next_ts.u64 += (fport->usec_per_frame * VIDEO_CLOCK_RATE /\n\t\t\t\t   1000000);\n\t} else {\n\t    fport->next_ts.u64 += (frame->size * VIDEO_CLOCK_RATE /\n\t\t\t\t   (fport->base.info.fmt.det.vid.avg_bps / 8));\n\t}\n    }\n\n    return PJ_SUCCESS;\n\non_error2:\n    if (status == AVI_EOF) {\n        fport->eof = PJ_TRUE;\n\n        size_to_read -= size_read;\n        if (size_to_read == (pj_ssize_t)frame->size) {\n            /* Frame is empty */\n \t    frame->type = PJMEDIA_FRAME_TYPE_NONE;\n\t    frame->size = 0;\n\t    return PJ_EEOF;           \n        }\n        pj_bzero((char *)frame->buf + frame->size - size_to_read,\n                 size_to_read);\n\n        return PJ_SUCCESS;\n    }\n\n    return status;\n}\n\n/*\n * Destroy port.\n */\nstatic pj_status_t avi_on_destroy(pjmedia_port *this_port)\n{\n    struct avi_reader_port *fport = (struct avi_reader_port*) this_port;\n\n    pj_assert(this_port->info.signature == SIGNATURE);\n\n    if (fport->subscribed) {\n    \tpjmedia_event_unsubscribe(NULL, &file_on_event, fport, fport);\n    \tfport->subscribed = PJ_FALSE;\n    }\n\n    if (fport->fd != (pj_oshandle_t) (pj_ssize_t)-1)\n        pj_file_close(fport->fd);\n    return PJ_SUCCESS;\n}\n\n\n#endif /* PJMEDIA_HAS_VIDEO */\n", "/* $Id$ */\n/* \n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n#include <pjmedia/wav_port.h>\n#include <pjmedia/alaw_ulaw.h>\n#include <pjmedia/errno.h>\n#include <pjmedia/wave.h>\n#include <pj/assert.h>\n#include <pj/file_access.h>\n#include <pj/file_io.h>\n#include <pj/log.h>\n#include <pj/pool.h>\n#include <pj/string.h>\n\n\n#define THIS_FILE   \"wav_player.c\"\n\n\n#define SIGNATURE\t    PJMEDIA_SIG_PORT_WAV_PLAYER\n#define BITS_PER_SAMPLE\t    16\n\n#if 1\n#   define TRACE_(x)\tPJ_LOG(4,x)\n#else\n#   define TRACE_(x)\n#endif\n\n#if defined(PJ_IS_BIG_ENDIAN) && PJ_IS_BIG_ENDIAN!=0\n    static void samples_to_host(pj_int16_t *samples, unsigned count)\n    {\n\tunsigned i;\n\tfor (i=0; i<count; ++i) {\n\t    samples[i] = pj_swap16(samples[i]);\n\t}\n    }\n#else\n#   define samples_to_host(samples,count)\n#endif\n\nstruct file_reader_port\n{\n    pjmedia_port     base;\n    unsigned\t     options;\n    pjmedia_wave_fmt_tag fmt_tag;\n    pj_uint16_t\t     bytes_per_sample;\n    pj_bool_t\t     eof;\n    pj_uint32_t\t     bufsize;\n    char\t    *buf;\n    char\t    *readpos;\n    char\t    *eofpos;\n\n    pj_off_t\t     fsize;\n    unsigned\t     start_data;\n    unsigned         data_len;\n    unsigned         data_left;\n    pj_off_t\t     fpos;\n    pj_oshandle_t    fd;\n\n    pj_status_t\t   (*cb)(pjmedia_port*, void*);\n    pj_bool_t\t     subscribed;\n    void\t   (*cb2)(pjmedia_port*, void*);\n};\n\n\nstatic pj_status_t file_get_frame(pjmedia_port *this_port, \n\t\t\t\t  pjmedia_frame *frame);\nstatic pj_status_t file_on_destroy(pjmedia_port *this_port);\n\nstatic struct file_reader_port *create_file_port(pj_pool_t *pool)\n{\n    const pj_str_t name = pj_str(\"file\");\n    struct file_reader_port *port;\n\n    port = PJ_POOL_ZALLOC_T(pool, struct file_reader_port);\n    if (!port)\n\treturn NULL;\n\n    /* Put in default values.\n     * These will be overriden once the file is read.\n     */\n    pjmedia_port_info_init(&port->base.info, &name, SIGNATURE, \n\t\t\t   8000, 1, 16, 80);\n\n    port->base.get_frame = &file_get_frame;\n    port->base.on_destroy = &file_on_destroy;\n\n\n    return port;\n}\n\n/*\n * Fill buffer.\n */\nstatic pj_status_t fill_buffer(struct file_reader_port *fport)\n{\n    pj_uint32_t size_left = fport->bufsize;\n    unsigned size_to_read;\n    pj_ssize_t size;\n    pj_status_t status;\n\n    fport->eofpos = NULL;\n    \n    while (size_left > 0) {\n\n\t/* Calculate how many bytes to read in this run. */\n\tsize = size_to_read = size_left;\n\tstatus = pj_file_read(fport->fd, \n\t\t\t      &fport->buf[fport->bufsize-size_left], \n\t\t\t      &size);\n\tif (status != PJ_SUCCESS)\n\t    return status;\n\tif (size < 0) {\n\t    /* Should return more appropriate error code here.. */\n\t    return PJ_ECANCELLED;\n\t}\n\n        if (size > (pj_ssize_t)fport->data_left) {\n            /* We passed the end of the data chunk,\n             * only count the portion read from the data chunk.\n             */\n            size = (pj_ssize_t)fport->data_left;\n        }\n\n\tsize_left -= (pj_uint32_t)size;\n        fport->data_left -= (pj_uint32_t)size;\n\tfport->fpos += size;\n\n\t/* If size is less than size_to_read, it indicates that we've\n\t * encountered EOF. Rewind the file.\n\t */\n        if (size < (pj_ssize_t)size_to_read) {\n            fport->eof = PJ_TRUE;\n            fport->eofpos = fport->buf + fport->bufsize - size_left;\n\n            if (fport->options & PJMEDIA_FILE_NO_LOOP) {\n                /* Zero remaining buffer */\n                if (fport->fmt_tag == PJMEDIA_WAVE_FMT_TAG_PCM) {\n                    pj_bzero(fport->eofpos, size_left);\n                } else if (fport->fmt_tag == PJMEDIA_WAVE_FMT_TAG_ULAW) {\n                    int val = pjmedia_linear2ulaw(0);\n                    pj_memset(fport->eofpos, val, size_left);\n                } else if (fport->fmt_tag == PJMEDIA_WAVE_FMT_TAG_ALAW) {\n                    int val = pjmedia_linear2alaw(0);\n                    pj_memset(fport->eofpos, val, size_left);\n                }\n\t\tsize_left = 0;\n            }\n\n\t    /* Rewind file */\n\t    fport->fpos = fport->start_data;\n\t    pj_file_setpos( fport->fd, fport->fpos, PJ_SEEK_SET);\n            fport->data_left = fport->data_len;\n\t}\n    }\n\n    /* Convert samples to host rep */\n    samples_to_host((pj_int16_t*)fport->buf, \n\t\t    fport->bufsize/fport->bytes_per_sample);\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Create WAVE player port.\n */\nPJ_DEF(pj_status_t) pjmedia_wav_player_port_create( pj_pool_t *pool,\n\t\t\t\t\t\t     const char *filename,\n\t\t\t\t\t\t     unsigned ptime,\n\t\t\t\t\t\t     unsigned options,\n\t\t\t\t\t\t     pj_ssize_t buff_size,\n\t\t\t\t\t\t     pjmedia_port **p_port )\n{\n    pjmedia_wave_hdr wave_hdr;\n    pj_ssize_t size_read;\n    pj_off_t size_to_read;\n    struct file_reader_port *fport;\n    pjmedia_audio_format_detail *ad;\n    pj_off_t pos;\n    pj_str_t name;\n    unsigned samples_per_frame;\n    pj_status_t status = PJ_SUCCESS;\n\n\n    /* Check arguments. */\n    PJ_ASSERT_RETURN(pool && filename && p_port, PJ_EINVAL);\n\n    /* Check the file really exists. */\n    if (!pj_file_exists(filename)) {\n\treturn PJ_ENOTFOUND;\n    }\n\n    /* Normalize ptime */\n    if (ptime == 0)\n\tptime = 20;\n\n    /* Normalize buff_size */\n    if (buff_size < 1) buff_size = PJMEDIA_FILE_PORT_BUFSIZE;\n\n\n    /* Create fport instance. */\n    fport = create_file_port(pool);\n    if (!fport) {\n\treturn PJ_ENOMEM;\n    }\n\n\n    /* Get the file size. */\n    fport->fsize = pj_file_size(filename);\n\n    /* Size must be more than WAVE header size */\n    if (fport->fsize <= sizeof(pjmedia_wave_hdr)) {\n\treturn PJMEDIA_ENOTVALIDWAVE;\n    }\n\n    /* Open file. */\n    status = pj_file_open( pool, filename, PJ_O_RDONLY, &fport->fd);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Read the file header plus fmt header only. */\n    size_to_read = size_read = sizeof(wave_hdr) - 8;\n    status = pj_file_read( fport->fd, &wave_hdr, &size_read);\n    if (status != PJ_SUCCESS) {\n\tpj_file_close(fport->fd);\n\treturn status;\n    }\n    if (size_read != size_to_read) {\n\tpj_file_close(fport->fd);\n\treturn PJMEDIA_ENOTVALIDWAVE;\n    }\n\n    /* Normalize WAVE header fields values from little-endian to host\n     * byte order.\n     */\n    pjmedia_wave_hdr_file_to_host(&wave_hdr);\n    \n    /* Validate WAVE file. */\n    if (wave_hdr.riff_hdr.riff != PJMEDIA_RIFF_TAG ||\n\twave_hdr.riff_hdr.wave != PJMEDIA_WAVE_TAG ||\n\twave_hdr.fmt_hdr.fmt != PJMEDIA_FMT_TAG)\n    {\n\tpj_file_close(fport->fd);\n\tTRACE_((THIS_FILE, \n\t\t\"actual value|expected riff=%x|%x, wave=%x|%x fmt=%x|%x\",\n\t\twave_hdr.riff_hdr.riff, PJMEDIA_RIFF_TAG,\n\t\twave_hdr.riff_hdr.wave, PJMEDIA_WAVE_TAG,\n\t\twave_hdr.fmt_hdr.fmt, PJMEDIA_FMT_TAG));\n\treturn PJMEDIA_ENOTVALIDWAVE;\n    }\n\n    /* Validate format and its attributes (i.e: bits per sample, block align) */\n    switch (wave_hdr.fmt_hdr.fmt_tag) {\n    case PJMEDIA_WAVE_FMT_TAG_PCM:\n\tif (wave_hdr.fmt_hdr.bits_per_sample != 16 || \n\t    wave_hdr.fmt_hdr.block_align != 2 * wave_hdr.fmt_hdr.nchan)\n\t    status = PJMEDIA_EWAVEUNSUPP;\n\tbreak;\n\n    case PJMEDIA_WAVE_FMT_TAG_ALAW:\n    case PJMEDIA_WAVE_FMT_TAG_ULAW:\n\tif (wave_hdr.fmt_hdr.bits_per_sample != 8 ||\n\t    wave_hdr.fmt_hdr.block_align != wave_hdr.fmt_hdr.nchan)\n\t    status = PJMEDIA_ENOTVALIDWAVE;\n\tbreak;\n\n    default:\n\tstatus = PJMEDIA_EWAVEUNSUPP;\n\tbreak;\n    }\n\n    if (status != PJ_SUCCESS) {\n\tpj_file_close(fport->fd);\n\treturn status;\n    }\n\n    fport->fmt_tag = (pjmedia_wave_fmt_tag)wave_hdr.fmt_hdr.fmt_tag;\n    fport->bytes_per_sample = (pj_uint16_t) \n\t\t\t      (wave_hdr.fmt_hdr.bits_per_sample / 8);\n\n    /* If length of fmt_header is greater than 16, skip the remaining\n     * fmt header data.\n     */\n    if (wave_hdr.fmt_hdr.len > 16) {\n\tPJ_CHECK_OVERFLOW_UINT32_TO_LONG(wave_hdr.fmt_hdr.len - 16,\n\t\t      pj_file_close(fport->fd); return PJMEDIA_ENOTVALIDWAVE;);\n\tsize_to_read = (pj_off_t)wave_hdr.fmt_hdr.len - 16;\n\tstatus = pj_file_setpos(fport->fd, size_to_read, PJ_SEEK_CUR);\n\tif (status != PJ_SUCCESS) {\n\t    pj_file_close(fport->fd);\n\t    return status;\n\t}\n    }\n\n    /* Repeat reading the WAVE file until we have 'data' chunk */\n    for (;;) {\n\tpjmedia_wave_subchunk subchunk;\n\tsize_read = 8;\n\tstatus = pj_file_read(fport->fd, &subchunk, &size_read);\n\tif (status != PJ_SUCCESS || size_read != 8) {\n\t    pj_file_close(fport->fd);\n\t    return PJMEDIA_EWAVETOOSHORT;\n\t}\n\n\t/* Normalize endianness */\n\tPJMEDIA_WAVE_NORMALIZE_SUBCHUNK(&subchunk);\n\n\t/* Break if this is \"data\" chunk */\n\tif (subchunk.id == PJMEDIA_DATA_TAG) {\n\t    wave_hdr.data_hdr.data = PJMEDIA_DATA_TAG;\n\t    wave_hdr.data_hdr.len = subchunk.len;\n\t    break;\n\t}\n\n\t/* Otherwise skip the chunk contents */\n\tPJ_CHECK_OVERFLOW_UINT32_TO_LONG(subchunk.len, \n\t\t      pj_file_close(fport->fd); return PJMEDIA_ENOTVALIDWAVE;);\n\tsize_to_read = subchunk.len;\n\n\tstatus = pj_file_setpos(fport->fd, size_to_read, PJ_SEEK_CUR);\n\tif (status != PJ_SUCCESS) {\n\t    pj_file_close(fport->fd);\n\t    return status;\n\t}\n    }\n\n    /* Current file position now points to start of data */\n    status = pj_file_getpos(fport->fd, &pos);\n    fport->start_data = (unsigned)pos;\n    fport->data_len = wave_hdr.data_hdr.len;\n    fport->data_left = wave_hdr.data_hdr.len;\n\n    /* Validate length. */\n    if (wave_hdr.data_hdr.len > fport->fsize - fport->start_data) {\n    \t/* Actual data length may be shorter than declared. We should still\n    \t * try to play whatever data is there instead of immediately returning\n    \t * error.\n    \t */\n    \twave_hdr.data_hdr.len = (pj_uint32_t)fport->fsize - fport->start_data;\n\t// pj_file_close(fport->fd);\n\t// return PJMEDIA_EWAVEUNSUPP;\n    }\n    if (wave_hdr.data_hdr.len < ptime * wave_hdr.fmt_hdr.sample_rate *\n\t\t\t\twave_hdr.fmt_hdr.nchan / 1000)\n    {\n\tpj_file_close(fport->fd);\n\treturn PJMEDIA_EWAVETOOSHORT;\n    }\n\n    /* It seems like we have a valid WAVE file. */\n\n    /* Initialize */\n    fport->options = options;\n\n    /* Update port info. */\n    ad = pjmedia_format_get_audio_format_detail(&fport->base.info.fmt, 1);\n    pj_strdup2(pool, &name, filename);\n    samples_per_frame = ptime * wave_hdr.fmt_hdr.sample_rate *\n\t\t        wave_hdr.fmt_hdr.nchan / 1000;\n    pjmedia_port_info_init(&fport->base.info, &name, SIGNATURE,\n\t\t\t   wave_hdr.fmt_hdr.sample_rate,\n\t\t\t   wave_hdr.fmt_hdr.nchan,\n\t\t\t   BITS_PER_SAMPLE,\n\t\t\t   samples_per_frame);\n\n    /* If file is shorter than buffer size, adjust buffer size to file\n     * size. Otherwise EOF callback will be called multiple times when\n     * fill_buffer() is called.\n     */\n    if (wave_hdr.data_hdr.len < (unsigned)buff_size)\n\tbuff_size = wave_hdr.data_hdr.len;\n\n    /* Create file buffer.\n     */\n    fport->bufsize = (pj_uint32_t)buff_size;\n\n\n    /* samples_per_frame must be smaller than bufsize (because get_frame()\n     * doesn't handle this case).\n     */\n    if (samples_per_frame * fport->bytes_per_sample >= fport->bufsize) {\n\tpj_file_close(fport->fd);\n\treturn PJ_EINVAL;\n    }\n\n    /* Create buffer. */\n    fport->buf = (char*) pj_pool_alloc(pool, fport->bufsize);\n    if (!fport->buf) {\n\tpj_file_close(fport->fd);\n\treturn PJ_ENOMEM;\n    }\n \n    fport->readpos = fport->buf;\n\n    /* Set initial position of the file. */\n    fport->fpos = fport->start_data;\n\n    /* Fill up the buffer. */\n    status = fill_buffer(fport);\n    if (status != PJ_SUCCESS) {\n\tpj_file_close(fport->fd);\n\treturn status;\n    }\n\n    /* Done. */\n\n    *p_port = &fport->base;\n\n\n    PJ_LOG(4,(THIS_FILE, \n\t      \"File player '%.*s' created: samp.rate=%d, ch=%d, bufsize=%uKB, \"\n\t      \"filesize=%luKB\",\n\t      (int)fport->base.info.name.slen,\n\t      fport->base.info.name.ptr,\n\t      ad->clock_rate,\n\t      ad->channel_count,\n\t      fport->bufsize / 1000,\n\t      (unsigned long)(fport->fsize / 1000)));\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Get additional info about the file player.\n */\nPJ_DEF(pj_status_t) pjmedia_wav_player_get_info(\n\t\t\t\t\tpjmedia_port *port,\n\t\t\t\t\tpjmedia_wav_player_info *info)\n{\n    struct file_reader_port *fport;\n    PJ_ASSERT_RETURN(port && info, PJ_EINVAL);\n\n    pj_bzero(info, sizeof(*info));\n\n    /* Check that this is really a player port */\n    PJ_ASSERT_RETURN(port->info.signature == SIGNATURE, PJ_EINVALIDOP);\n\n    fport = (struct file_reader_port*) port;\n\n    if (fport->fmt_tag == PJMEDIA_WAVE_FMT_TAG_PCM) {\n\tinfo->fmt_id = PJMEDIA_FORMAT_PCM;\n\tinfo->payload_bits_per_sample = 16;\n    } else if (fport->fmt_tag == PJMEDIA_WAVE_FMT_TAG_ULAW) {\n\tinfo->fmt_id = PJMEDIA_FORMAT_ULAW;\n\tinfo->payload_bits_per_sample = 8;\n    } else if (fport->fmt_tag == PJMEDIA_WAVE_FMT_TAG_ALAW) {\n\tinfo->fmt_id = PJMEDIA_FORMAT_ALAW;\n\tinfo->payload_bits_per_sample = 8;\n    } else {\n\tpj_assert(!\"Unsupported format\");\n\treturn PJ_ENOTSUP;\n    }\n\n    info->size_bytes = (pj_uint32_t)pjmedia_wav_player_get_len(port);\n    info->size_samples = info->size_bytes /\n\t\t\t (info->payload_bits_per_sample / 8);\n\n    return PJ_SUCCESS;\n}\n\n/*\n * Get the data length, in bytes.\n */\nPJ_DEF(pj_ssize_t) pjmedia_wav_player_get_len(pjmedia_port *port)\n{\n    struct file_reader_port *fport;\n    pj_ssize_t size;\n\n    /* Sanity check */\n    PJ_ASSERT_RETURN(port, -PJ_EINVAL);\n\n    /* Check that this is really a player port */\n    PJ_ASSERT_RETURN(port->info.signature == SIGNATURE, -PJ_EINVALIDOP);\n\n    fport = (struct file_reader_port*) port;\n\n    size = (pj_ssize_t) fport->fsize;\n    return size - fport->start_data;\n}\n\n\n/*\n * Set position.\n */\nPJ_DEF(pj_status_t) pjmedia_wav_player_port_set_pos(pjmedia_port *port,\n\t\t\t\t\t\t    pj_uint32_t bytes )\n{\n    struct file_reader_port *fport;\n    pj_status_t status;\n\n    /* Sanity check */\n    PJ_ASSERT_RETURN(port, PJ_EINVAL);\n\n    /* Check that this is really a player port */\n    PJ_ASSERT_RETURN(port->info.signature == SIGNATURE, PJ_EINVALIDOP);\n\n\n    fport = (struct file_reader_port*) port;\n\n    /* Check that this offset does not pass the audio-data (in case of\n     * extra chunk after audio data chunk\n     */\n    PJ_ASSERT_RETURN(bytes < fport->data_len, PJ_EINVAL);\n\n    fport->fpos = fport->start_data + bytes;\n    fport->data_left = fport->data_len - bytes;\n    pj_file_setpos( fport->fd, fport->fpos, PJ_SEEK_SET);\n\n    fport->eof = PJ_FALSE;\n    status = fill_buffer(fport);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    fport->readpos = fport->buf;\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Get the file play position of WAV player (in bytes).\n */\nPJ_DEF(pj_ssize_t) pjmedia_wav_player_port_get_pos( pjmedia_port *port )\n{\n    struct file_reader_port *fport;\n    pj_size_t payload_pos;\n\n    /* Sanity check */\n    PJ_ASSERT_RETURN(port, -PJ_EINVAL);\n\n    /* Check that this is really a player port */\n    PJ_ASSERT_RETURN(port->info.signature == SIGNATURE, -PJ_EINVALIDOP);\n\n    fport = (struct file_reader_port*) port;\n\n    payload_pos = (pj_size_t)(fport->fpos - fport->start_data);\n    if (payload_pos == 0)\n\treturn 0;\n    else if (payload_pos >= fport->bufsize)\n\treturn payload_pos - fport->bufsize + (fport->readpos - fport->buf);\n    else\n\treturn (fport->readpos - fport->buf) % payload_pos;\n}\n\n\n#if !DEPRECATED_FOR_TICKET_2251\n/*\n * Register a callback to be called when the file reading has reached the\n * end of file.\n */\nPJ_DEF(pj_status_t) pjmedia_wav_player_set_eof_cb( pjmedia_port *port,\n\t\t\t       void *user_data,\n\t\t\t       pj_status_t (*cb)(pjmedia_port *port,\n\t\t\t\t\t\t void *usr_data))\n{\n    struct file_reader_port *fport;\n\n    /* Sanity check */\n    PJ_ASSERT_RETURN(port, -PJ_EINVAL);\n\n    /* Check that this is really a player port */\n    PJ_ASSERT_RETURN(port->info.signature == SIGNATURE, -PJ_EINVALIDOP);\n\n    PJ_LOG(1, (THIS_FILE, \"pjmedia_wav_player_set_eof_cb() is deprecated. \"\n    \t       \"Use pjmedia_wav_player_set_eof_cb2() instead.\"));\n\n    fport = (struct file_reader_port*) port;\n\n    fport->base.port_data.pdata = user_data;\n    fport->cb = cb;\n\n    return PJ_SUCCESS;\n}\n#endif\n\n\n/*\n * Register a callback to be called when the file reading has reached the\n * end of file.\n */\nPJ_DEF(pj_status_t) pjmedia_wav_player_set_eof_cb2(pjmedia_port *port,\n\t\t\t       void *user_data,\n\t\t\t       void (*cb)(pjmedia_port *port,\n\t\t\t\t\t  void *usr_data))\n{\n    struct file_reader_port *fport;\n\n    /* Sanity check */\n    PJ_ASSERT_RETURN(port, -PJ_EINVAL);\n\n    /* Check that this is really a player port */\n    PJ_ASSERT_RETURN(port->info.signature == SIGNATURE, -PJ_EINVALIDOP);\n\n    fport = (struct file_reader_port*) port;\n\n    fport->base.port_data.pdata = user_data;\n    fport->cb2 = cb;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic pj_status_t file_on_event(pjmedia_event *event,\n                                 void *user_data)\n{\n    struct file_reader_port *fport = (struct file_reader_port*)user_data;\n\n    if (event->type == PJMEDIA_EVENT_CALLBACK) {\n\tif (fport->cb2)\n\t    (*fport->cb2)(&fport->base, fport->base.port_data.pdata);\n    }\n    \n    return PJ_SUCCESS;\n}\n\n\n/*\n * Get frame from file.\n */\nstatic pj_status_t file_get_frame(pjmedia_port *this_port, \n\t\t\t\t  pjmedia_frame *frame)\n{\n    struct file_reader_port *fport = (struct file_reader_port*)this_port;\n    pj_size_t frame_size;\n    pj_status_t status = PJ_SUCCESS;\n\n    pj_assert(fport->base.info.signature == SIGNATURE);\n    pj_assert(frame->size <= fport->bufsize);\n\n    /* EOF is set and readpos already passed the eofpos */\n    if (fport->eof && fport->readpos >= fport->eofpos) {\n\tPJ_LOG(5,(THIS_FILE, \"File port %.*s EOF\",\n\t\t  (int)fport->base.info.name.slen,\n\t\t  fport->base.info.name.ptr));\n\n\t/* Call callback, if any */\n\tif (fport->cb2) {\n\t    pj_bool_t no_loop = (fport->options & PJMEDIA_FILE_NO_LOOP);\n\n\t    if (!fport->subscribed) {\n\t    \tstatus = pjmedia_event_subscribe(NULL, &file_on_event,\n\t    \t\t\t\t         fport, fport);\n\t    \tfport->subscribed = (status == PJ_SUCCESS)? PJ_TRUE:\n\t    \t\t\t    PJ_FALSE;\n\t    }\n\n\t    if (fport->subscribed && fport->eof != 2) {\n\t    \tpjmedia_event event;\n\n\t    \tif (no_loop) {\n\t    \t    /* To prevent the callback from being called repeatedly */\n\t    \t    fport->eof = 2;\n\t    \t} else {\n\t    \t    fport->eof = PJ_FALSE;\n\t    \t}\n\n\t    \tpjmedia_event_init(&event, PJMEDIA_EVENT_CALLBACK,\n\t                      \t   NULL, fport);\n\t    \tpjmedia_event_publish(NULL, fport, &event,\n\t                              PJMEDIA_EVENT_PUBLISH_POST_EVENT);\n\t    }\n\t    \n\t    /* Should not access player port after this since\n\t     * it might have been destroyed by the callback.\n\t     */\n\t    frame->type = PJMEDIA_FRAME_TYPE_NONE;\n\t    frame->size = 0;\n\t    \n\t    return (no_loop? PJ_EEOF: PJ_SUCCESS);\n\n\t} else if (fport->cb) {\n\t    status = (*fport->cb)(this_port, fport->base.port_data.pdata);\n\t}\n\n\t/* If callback returns non PJ_SUCCESS or 'no loop' is specified,\n\t * return immediately (and don't try to access player port since\n\t * it might have been destroyed by the callback).\n\t */\n\tif ((status != PJ_SUCCESS) || (fport->options & PJMEDIA_FILE_NO_LOOP))\n\t{\n\t    frame->type = PJMEDIA_FRAME_TYPE_NONE;\n\t    frame->size = 0;\n\t    return PJ_EEOF;\n\t}\n\n        /* Rewind file */\n\tPJ_LOG(5,(THIS_FILE, \"File port %.*s rewinding..\",\n\t\t  (int)fport->base.info.name.slen,\n\t\t  fport->base.info.name.ptr));\n\tfport->eof = PJ_FALSE;\n    }\n\n    //pj_assert(frame->size == fport->base.info.bytes_per_frame);\n    if (fport->fmt_tag == PJMEDIA_WAVE_FMT_TAG_PCM) {\n\tframe_size = frame->size;\n\t//frame->size = frame_size;\n    } else {\n\t/* Must be ULAW or ALAW */\n\tpj_assert(fport->fmt_tag == PJMEDIA_WAVE_FMT_TAG_ULAW || \n\t\t  fport->fmt_tag == PJMEDIA_WAVE_FMT_TAG_ALAW);\n\n\tframe_size = frame->size >> 1;\n\tframe->size = frame_size << 1;\n    }\n\n    /* Copy frame from buffer. */\n    frame->type = PJMEDIA_FRAME_TYPE_AUDIO;\n    frame->timestamp.u64 = 0;\n\n    if ((fport->readpos + frame_size) <= (fport->buf + fport->bufsize))\n    {\n\t/* Read contiguous buffer. */\n\tpj_memcpy(frame->buf, fport->readpos, frame_size);\n\n\t/* Fill up the buffer if all has been read. */\n\tfport->readpos += frame_size;\n\tif (fport->readpos == fport->buf + fport->bufsize) {\n\t    fport->readpos = fport->buf;\n\n\t    status = fill_buffer(fport);\n\t    if (status != PJ_SUCCESS) {\n\t\tframe->type = PJMEDIA_FRAME_TYPE_NONE;\n\t\tframe->size = 0;\n\t\tfport->readpos = fport->buf + fport->bufsize;\n\t\treturn status;\n\t    }\n\t}\n    } else {\n\tunsigned endread;\n\n\t/* Split read.\n\t * First stage: read until end of buffer. \n\t */\n\tendread = (unsigned)((fport->buf+fport->bufsize) - fport->readpos);\n\tpj_memcpy(frame->buf, fport->readpos, endread);\n\n\t/* End Of Buffer and EOF and NO LOOP */\n\tif (fport->eof && (fport->options & PJMEDIA_FILE_NO_LOOP)) {\n\t    fport->readpos += endread;\n\n            if (fport->fmt_tag == PJMEDIA_WAVE_FMT_TAG_PCM) {\n                pj_bzero((char*)frame->buf + endread, frame_size - endread);\n            } else if (fport->fmt_tag == PJMEDIA_WAVE_FMT_TAG_ULAW) {\n                int val = pjmedia_linear2ulaw(0);\n                pj_memset((char*)frame->buf + endread, val,\n                          frame_size - endread);\n            } else if (fport->fmt_tag == PJMEDIA_WAVE_FMT_TAG_ALAW) {\n                int val = pjmedia_linear2alaw(0);\n                pj_memset((char*)frame->buf + endread, val,\n                          frame_size - endread);\n            }\n\n\t    return PJ_SUCCESS;\n\t}\n\n\t/* Second stage: fill up buffer, and read from the start of buffer. */\n\tstatus = fill_buffer(fport);\n\tif (status != PJ_SUCCESS) {\n\t    frame->type = PJMEDIA_FRAME_TYPE_NONE;\n\t    frame->size = 0;\n\t    fport->readpos = fport->buf + fport->bufsize;\n\t    return status;\n\t}\n\n\tpj_memcpy(((char*)frame->buf)+endread, fport->buf, frame_size-endread);\n\tfport->readpos = fport->buf + (frame_size - endread);\n    }\n\n    if (fport->fmt_tag == PJMEDIA_WAVE_FMT_TAG_ULAW ||\n\tfport->fmt_tag == PJMEDIA_WAVE_FMT_TAG_ALAW)\n    {\n\tunsigned i;\n\tpj_uint16_t *dst;\n\tpj_uint8_t *src;\n\n\tdst = (pj_uint16_t*)frame->buf + frame_size - 1;\n\tsrc = (pj_uint8_t*)frame->buf + frame_size - 1;\n\n\tif (fport->fmt_tag == PJMEDIA_WAVE_FMT_TAG_ULAW) {\n\t    for (i = 0; i < frame_size; ++i) {\n\t\t*dst-- = (pj_uint16_t) pjmedia_ulaw2linear(*src--);\n\t    }\n\t} else {\n\t    for (i = 0; i < frame_size; ++i) {\n\t\t*dst-- = (pj_uint16_t) pjmedia_alaw2linear(*src--);\n\t    }\n\t}\n    }\n\n    return PJ_SUCCESS;\n}\n\n/*\n * Destroy port.\n */\nstatic pj_status_t file_on_destroy(pjmedia_port *this_port)\n{\n    struct file_reader_port *fport = (struct file_reader_port*) this_port;\n\n    pj_assert(this_port->info.signature == SIGNATURE);\n\n    pj_file_close(fport->fd);\n\n    if (fport->subscribed) {\n    \tpjmedia_event_unsubscribe(NULL, &file_on_event, fport, fport);\n    \tfport->subscribed = PJ_FALSE;\n    }\n\n    return PJ_SUCCESS;\n}\n\n", "/* $Id$ */\n/* \n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * Original author:\n *  David Clark <vdc1048 @ tx.rr.com>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n#include <pjmedia/wav_playlist.h>\n#include <pjmedia/errno.h>\n#include <pjmedia/wave.h>\n#include <pj/assert.h>\n#include <pj/file_access.h>\n#include <pj/file_io.h>\n#include <pj/log.h>\n#include <pj/pool.h>\n#include <pj/string.h>\n\n#define THIS_FILE\t    \"wav_playlist.c\"\n\n#define SIGNATURE\t    PJMEDIA_SIG_PORT_WAV_PLAYLIST\n#define BYTES_PER_SAMPLE    2\n\n\n#if 1\n#   define TRACE_(x)\tPJ_LOG(4,x)\n#else\n#   define TRACE_(x)\n#endif\n\n#if defined(PJ_IS_BIG_ENDIAN) && PJ_IS_BIG_ENDIAN!=0\n    static void samples_to_host(pj_int16_t *samples, unsigned count)\n    {\n\tunsigned i;\n\tfor (i=0; i<count; ++i) {\n\t    samples[i] = pj_swap16(samples[i]);\n\t}\n    }\n#else\n#   define samples_to_host(samples,count)\n#endif\n\n\nstruct playlist_port\n{\n    pjmedia_port     base;\n    unsigned\t     options;\n    pj_bool_t\t     eof;\n    pj_uint32_t\t     bufsize;\n    char\t    *buf;\n    char\t    *readpos;\n\n    pj_off_t        *fsize_list;\n    unsigned        *start_data_list;\n    unsigned        *data_len_list;\n    unsigned        *data_left_list;\n    pj_off_t        *fpos_list;\n    pj_oshandle_t   *fd_list;\t    /* list of file descriptors\t*/\n    int              current_file;  /* index of current file.\t*/\n    int              max_file;\t    /* how many files.\t\t*/\n\n    pj_status_t\t   (*cb)(pjmedia_port*, void*);\n    pj_bool_t\t     subscribed;\n    void\t   (*cb2)(pjmedia_port*, void*);\n};\n\n\nstatic pj_status_t file_list_get_frame(pjmedia_port *this_port,\n\t\t\t\t       pjmedia_frame *frame);\nstatic pj_status_t file_list_on_destroy(pjmedia_port *this_port);\n\n\nstatic struct playlist_port *create_file_list_port(pj_pool_t *pool,\n\t\t\t\t\t\t   const pj_str_t *name)\n{\n    struct playlist_port *port;\n\n    port = PJ_POOL_ZALLOC_T(pool, struct playlist_port);\n    if (!port)\n\treturn NULL;\n\n    /* Put in default values.\n     * These will be overriden once the file is read.\n     */\n    pjmedia_port_info_init(&port->base.info, name, SIGNATURE,\n\t\t\t   8000, 1, 16, 80);\n\n    port->base.get_frame = &file_list_get_frame;\n    port->base.on_destroy = &file_list_on_destroy;\n\n    return port;\n}\n\n\nstatic pj_status_t file_on_event(pjmedia_event *event,\n                                 void *user_data)\n{\n    struct playlist_port *fport = (struct playlist_port*)user_data;\n\n    if (event->type == PJMEDIA_EVENT_CALLBACK) {\n\tif (fport->cb2)\n\t    (*fport->cb2)(&fport->base, fport->base.port_data.pdata);\n    }\n    \n    return PJ_SUCCESS;\n}\n\n\n/*\n * Fill buffer for file_list operations.\n */\nstatic pj_status_t file_fill_buffer(struct playlist_port *fport)\n{\n    pj_uint32_t size_left = fport->bufsize;\n    pj_uint32_t size_to_read;\n    pj_ssize_t size;\n    pj_status_t status;\n    int current_file = fport->current_file;\n\n    /* Can't read file if EOF and loop flag is disabled */\n    if (fport->eof)\n\treturn PJ_EEOF;\n\n    while (size_left > 0)\n    {\n\t/* Calculate how many bytes to read in this run. */\n\tsize = size_to_read = size_left;\n\tstatus = pj_file_read(fport->fd_list[current_file],\n\t\t\t      &fport->buf[fport->bufsize-size_left],\n\t\t\t      &size);\n\tif (status != PJ_SUCCESS)\n\t    return status;\n\t\n\tif (size < 0)\n\t{\n\t    /* Should return more appropriate error code here.. */\n\t    return PJ_ECANCELLED;\n\t}\n\n        if (size > (pj_ssize_t)fport->data_left_list[current_file]) {\n            /* We passed the end of the data chunk,\n             * only count the portion read from the data chunk.\n             */\n            size = (pj_ssize_t)fport->data_left_list[current_file];\n        }\n\t\n\tsize_left -= (pj_uint32_t)size;\n\tfport->data_left_list[current_file] -= (pj_uint32_t)size;\n\tfport->fpos_list[current_file] += size;\t\n\t\n\t/* If size is less than size_to_read, it indicates that we've\n\t * encountered EOF. Rewind the file.\n\t */\n\tif (size < (pj_ssize_t)size_to_read)\n\t{\n\t    /* Rewind the file for the next iteration */\n\t    fport->fpos_list[current_file] = \n\t\tfport->start_data_list[current_file];\n\t    pj_file_setpos(fport->fd_list[current_file], \n\t\t\t   fport->fpos_list[current_file], PJ_SEEK_SET);\n\t    fport->data_left_list[current_file] = \n\t\t\t\t\t    fport->data_len_list[current_file];\n\n\t    /* Move to next file */\n\t    current_file++;\n\t    fport->current_file = current_file;\n\n\t    if (fport->current_file == fport->max_file)\n\t    {\n\t\t/* Clear the remaining part of the buffer first, to prevent\n\t\t * old samples from being played. If the playback restarts,\n\t\t * this will be overwritten by new reading.\n\t\t */\n\t\tif (size_left > 0) {\n\t\t    pj_bzero(&fport->buf[fport->bufsize-size_left], \n\t\t\t     size_left);\n\t\t}\n\n\t\t/* All files have been played. Call callback, if any. */\n\t\tif (fport->cb2) {\n\t    \t    pj_bool_t no_loop = (fport->options & PJMEDIA_FILE_NO_LOOP);\n\n\t    \t    if (!fport->subscribed) {\n\t    \t\tstatus = pjmedia_event_subscribe(NULL, &file_on_event,\n\t    \t\t\t\t         \t fport, fport);\n\t    \t\tfport->subscribed = (status == PJ_SUCCESS)? PJ_TRUE:\n\t    \t\t\t    \t    PJ_FALSE;\n\t    \t    }\n\n\t    \t    if (fport->subscribed && fport->eof != 2) {\n\t    \t    \tpjmedia_event event;\n\n\t    \t\tif (no_loop) {\n\t    \t    \t    /* To prevent the callback from being called\n\t    \t    \t     * repeatedly.\n\t    \t    \t     */\n\t    \t    \t    fport->eof = 2;\n\t    \t\t} else {\n\t    \t    \t    fport->eof = PJ_FALSE;\n\t\t    \t    /* start with first file again. */\n\t\t    \t    fport->current_file = current_file = 0;\n\t\t    \t    fport->fpos_list[0] = fport->start_data_list[0];\n\t\t    \t    pj_file_setpos(fport->fd_list[0],\n\t\t    \t    \t\t   fport->fpos_list[0], PJ_SEEK_SET);\n\t\t    \t    fport->data_left_list[0] = fport->data_len_list[0];\n\t    \t\t}\n\n\t    \t    \tpjmedia_event_init(&event, PJMEDIA_EVENT_CALLBACK,\n\t                      \t       \t   NULL, fport);\n\t    \t    \tpjmedia_event_publish(NULL, fport, &event,\n\t                              \t  PJMEDIA_EVENT_PUBLISH_POST_EVENT);\n\t            }\n\n\t    \t    /* Should not access player port after this since\n\t     \t     * it might have been destroyed by the callback.\n\t     \t     */\n\t    \t    return (no_loop? PJ_EEOF: PJ_SUCCESS);\n\n\t    \t} else if (fport->cb) {\n\t\t    PJ_LOG(5,(THIS_FILE,\n\t\t\t      \"File port %.*s EOF, calling callback\",\n\t\t\t      (int)fport->base.info.name.slen,\n\t\t\t      fport->base.info.name.ptr));\n\t\t    \n\t\t    fport->eof = PJ_TRUE;\n\n\t\t    status = (*fport->cb)(&fport->base,\n\t\t\t\t\t  fport->base.port_data.pdata);\n\n\t\t    if (status != PJ_SUCCESS)\n\t\t    {\n\t\t\t/* This will crash if file port is destroyed in the\n\t\t\t * callback, that's why we set the eof flag before\n\t\t\t * calling the callback:\n\t\t\t fport->eof = PJ_TRUE;\n\t\t\t */\n\t\t\treturn status;\n\t\t    }\n\n\t\t    fport->eof = PJ_FALSE;\n\t\t}\n\n\n\t\tif (fport->options & PJMEDIA_FILE_NO_LOOP)\n\t\t{\n\t\t    PJ_LOG(5,(THIS_FILE, \"File port %.*s EOF, stopping..\",\n\t\t\t      (int)fport->base.info.name.slen,\n\t\t\t      fport->base.info.name.ptr));\n\t\t    fport->eof = PJ_TRUE;\n\t\t    return PJ_EEOF;\n\t\t}\n\t\telse\n\t\t{\n\t\t    PJ_LOG(5,(THIS_FILE, \"File port %.*s EOF, rewinding..\",\n\t\t\t      (int)fport->base.info.name.slen,\n\t\t\t      fport->base.info.name.ptr));\n\t\t    \n\t\t    /* start with first file again. */\n\t\t    fport->current_file = current_file = 0;\n\t\t    fport->fpos_list[0] = fport->start_data_list[0];\n\t\t    pj_file_setpos(fport->fd_list[0], fport->fpos_list[0],\n\t\t\t\t   PJ_SEEK_SET);\n\t\t    fport->data_left_list[0] = fport->data_len_list[0];\n\t\t}\t\t\n\t\t\n\t    } /* if current_file == max_file */\n\n\t} /* size < size_to_read */\n\n    } /* while () */\n    \n    /* Convert samples to host rep */\n    samples_to_host((pj_int16_t*)fport->buf, fport->bufsize/BYTES_PER_SAMPLE);\n    \n    return PJ_SUCCESS;\n}\n\n\n/*\n * Create wave list player.\n */\nPJ_DEF(pj_status_t) pjmedia_wav_playlist_create(pj_pool_t *pool,\n\t\t\t\t\t\tconst pj_str_t *port_label,\n\t\t\t\t\t\tconst pj_str_t file_list[],\n\t\t\t\t\t\tint file_count,\n\t\t\t\t\t\tunsigned ptime,\n\t\t\t\t\t\tunsigned options,\n\t\t\t\t\t\tpj_ssize_t buff_size,\n\t\t\t\t\t\tpjmedia_port **p_port)\n{\n    struct playlist_port *fport;\n    pjmedia_audio_format_detail *afd;\n    pj_off_t pos;\n    pj_status_t status;\n    int index;\n    pj_bool_t has_wave_info = PJ_FALSE;\n    pj_str_t tmp_port_label;\n    char filename[PJ_MAXPATH];\t/* filename for open operations.    */\n\n\n    /* Check arguments. */\n    PJ_ASSERT_RETURN(pool && file_list && file_count && p_port, PJ_EINVAL);\n\n    /* Normalize port_label */\n    if (port_label == NULL || port_label->slen == 0) {\n\ttmp_port_label = pj_str(\"WAV playlist\");\n\tport_label = &tmp_port_label;\n    }\n\n    /* Be sure all files exist\t*/\n    for (index=0; index<file_count; index++) {\n\n\tPJ_ASSERT_RETURN(file_list[index].slen >= 0, PJ_ETOOSMALL);\n\tif (file_list[index].slen >= PJ_MAXPATH)\n\t    return PJ_ENAMETOOLONG;\n\n\tpj_memcpy(filename, file_list[index].ptr, file_list[index].slen);\n\tfilename[file_list[index].slen] = '\\0';\n\n    \t/* Check the file really exists. */\n    \tif (!pj_file_exists(filename)) {\n\t    PJ_LOG(4,(THIS_FILE,\n\t\t      \"WAV playlist error: file '%s' not found\",\n\t      \t      filename));\n\t    return PJ_ENOTFOUND;\n    \t}\n    }\n\n    /* Normalize ptime */\n    if (ptime == 0)\n\tptime = 20;\n\n    /* Create fport instance. */\n    fport = create_file_list_port(pool, port_label);\n    if (!fport) {\n\treturn PJ_ENOMEM;\n    }\n\n    afd = pjmedia_format_get_audio_format_detail(&fport->base.info.fmt, 1);\n\n    /* start with the first file. */\n    fport->current_file = 0;\n    fport->max_file = file_count;\n\n    /* Create file descriptor list */\n    fport->fd_list = (pj_oshandle_t*)\n\t\t     pj_pool_zalloc(pool, sizeof(pj_oshandle_t)*file_count);\n    if (!fport->fd_list) {\n\treturn PJ_ENOMEM;\n    }\n\n    /* Create file size list */\n    fport->fsize_list = (pj_off_t*)\n\t\t\tpj_pool_alloc(pool, sizeof(pj_off_t)*file_count);\n    if (!fport->fsize_list) {\n\treturn PJ_ENOMEM;\n    }\n\n    /* Create start of WAVE data list */\n    fport->start_data_list = (unsigned*)\n\t\t\t     pj_pool_alloc(pool, sizeof(unsigned)*file_count);\n    if (!fport->start_data_list) {\n\treturn PJ_ENOMEM;\n    }\n\n    /* Create data len list */\n    fport->data_len_list = (unsigned*)\n\t\t\t     pj_pool_alloc(pool, sizeof(unsigned)*file_count);\n    if (!fport->data_len_list) {\n\treturn PJ_ENOMEM;\n    }\n\n    /* Create data left list */\n    fport->data_left_list = (unsigned*)\n\t\t\t     pj_pool_alloc(pool, sizeof(unsigned)*file_count);\n    if (!fport->data_left_list) {\n\treturn PJ_ENOMEM;\n    }\n\n    /* Create file position list */\n    fport->fpos_list = (pj_off_t*)\n\t\t       pj_pool_alloc(pool, sizeof(pj_off_t)*file_count);\n    if (!fport->fpos_list) {\n\treturn PJ_ENOMEM;\n    }\n\n    /* Create file buffer once for this operation.\n     */\n    if (buff_size < 1) buff_size = PJMEDIA_FILE_PORT_BUFSIZE;\n    fport->bufsize = (pj_uint32_t)buff_size;\n\n\n    /* Create buffer. */\n    fport->buf = (char*) pj_pool_alloc(pool, fport->bufsize);\n    if (!fport->buf) {\n\treturn PJ_ENOMEM;\n    }\n\n    /* Initialize port */\n    fport->options = options;\n    fport->readpos = fport->buf;\n\n\n    /* ok run this for all files to be sure all are good for playback. */\n    for (index=file_count-1; index>=0; index--) {\n\n\tpjmedia_wave_hdr wavehdr;\n\tpj_ssize_t size_read;\n\tpj_off_t size_to_read;\n\n\t/* we end with the last one so we are good to go if still in function*/\n\tpj_memcpy(filename, file_list[index].ptr, file_list[index].slen);\n\tfilename[file_list[index].slen] = '\\0';\n\n\t/* Get the file size. */\n\tfport->current_file = index;\n\tfport->fsize_list[index] = pj_file_size(filename);\n\t\n\t/* Size must be more than WAVE header size */\n\tif (fport->fsize_list[index] <= sizeof(pjmedia_wave_hdr)) {\n\t    status = PJMEDIA_ENOTVALIDWAVE;\n\t    goto on_error;\n\t}\n\t\n\t/* Open file. */\n\tstatus = pj_file_open( pool, filename, PJ_O_RDONLY, \n\t\t\t       &fport->fd_list[index]);\n\tif (status != PJ_SUCCESS)\n\t    goto on_error;\n\t\n\t/* Read the file header plus fmt header only. */\n\tsize_to_read = size_read = sizeof(wavehdr) - 8;\t\n\tstatus = pj_file_read( fport->fd_list[index], &wavehdr, &size_read);\n\tif (status != PJ_SUCCESS) {\n\t    goto on_error;\n\t}\n\n\tif (size_read != size_to_read) {\n\t    status = PJMEDIA_ENOTVALIDWAVE;\n\t    goto on_error;\n\t}\n\t\n\t/* Normalize WAVE header fields values from little-endian to host\n\t * byte order.\n\t */\n\tpjmedia_wave_hdr_file_to_host(&wavehdr);\n\t\n\t/* Validate WAVE file. */\n\tif (wavehdr.riff_hdr.riff != PJMEDIA_RIFF_TAG ||\n\t    wavehdr.riff_hdr.wave != PJMEDIA_WAVE_TAG ||\n\t    wavehdr.fmt_hdr.fmt != PJMEDIA_FMT_TAG)\n\t{\n\t    TRACE_((THIS_FILE,\n\t\t\"actual value|expected riff=%x|%x, wave=%x|%x fmt=%x|%x\",\n\t\twavehdr.riff_hdr.riff, PJMEDIA_RIFF_TAG,\n\t\twavehdr.riff_hdr.wave, PJMEDIA_WAVE_TAG,\n\t\twavehdr.fmt_hdr.fmt, PJMEDIA_FMT_TAG));\n\t    status = PJMEDIA_ENOTVALIDWAVE;\n\t    goto on_error;\n\t}\n\t\n\t/* Must be PCM with 16bits per sample */\n\tif (wavehdr.fmt_hdr.fmt_tag != 1 ||\n\t    wavehdr.fmt_hdr.bits_per_sample != 16)\n\t{\n\t    status = PJMEDIA_EWAVEUNSUPP;\n\t    goto on_error;\n\t}\n\t\n\t/* Block align must be 2*nchannels */\n\tif (wavehdr.fmt_hdr.block_align != \n\t\twavehdr.fmt_hdr.nchan * BYTES_PER_SAMPLE)\n\t{\n\t    status = PJMEDIA_EWAVEUNSUPP;\n\t    goto on_error;\n\t}\n\t\n\t/* If length of fmt_header is greater than 16, skip the remaining\n\t * fmt header data.\n\t */\n\tif (wavehdr.fmt_hdr.len > 16) {\n\t    PJ_CHECK_OVERFLOW_UINT32_TO_LONG(wavehdr.fmt_hdr.len-16,\n\t\t\t       status = PJMEDIA_ENOTVALIDWAVE; goto on_error;);\n\t    size_to_read = (pj_off_t)wavehdr.fmt_hdr.len - 16;\n\t    status = pj_file_setpos(fport->fd_list[index], size_to_read, \n\t\t\t\t    PJ_SEEK_CUR);\n\t    if (status != PJ_SUCCESS) {\n\t\tgoto on_error;\n\t    }\n\t}\n\t\n\t/* Repeat reading the WAVE file until we have 'data' chunk */\n\tfor (;;) {\n\t    pjmedia_wave_subchunk subchunk;\n\t    size_read = 8;\n\t    status = pj_file_read(fport->fd_list[index], &subchunk, \n\t\t\t\t  &size_read);\n\t    if (status != PJ_SUCCESS || size_read != 8) {\n\t\tstatus = PJMEDIA_EWAVETOOSHORT;\n\t\tgoto on_error;\n\t    }\n\t    \n\t    /* Normalize endianness */\n\t    PJMEDIA_WAVE_NORMALIZE_SUBCHUNK(&subchunk);\n\t    \n\t    /* Break if this is \"data\" chunk */\n\t    if (subchunk.id == PJMEDIA_DATA_TAG) {\n\t\twavehdr.data_hdr.data = PJMEDIA_DATA_TAG;\n\t\twavehdr.data_hdr.len = subchunk.len;\n\t\tbreak;\n\t    }\n\t    \n\t    /* Otherwise skip the chunk contents */\n\t    PJ_CHECK_OVERFLOW_UINT32_TO_LONG(subchunk.len, \n\t\t\t       status = PJMEDIA_ENOTVALIDWAVE; goto on_error;);\n\t    size_to_read = subchunk.len;\n\n\t    status = pj_file_setpos(fport->fd_list[index], size_to_read, \n\t\t\t\t    PJ_SEEK_CUR);\n\t    if (status != PJ_SUCCESS) {\n\t\tgoto on_error;\n\t    }\n\t}\n\t\n\t/* Current file position now points to start of data */\n\tstatus = pj_file_getpos(fport->fd_list[index], &pos);\n\tfport->start_data_list[index] = (unsigned)pos;\n\tfport->data_len_list[index] = wavehdr.data_hdr.len;\n\tfport->data_left_list[index] = wavehdr.data_hdr.len;\n\t\n\t/* Validate length. */\n\tif (wavehdr.data_hdr.len > fport->fsize_list[index] - \n\t\t\t\t       fport->start_data_list[index]) \n\t{\n\t    status = PJMEDIA_EWAVEUNSUPP;\n\t    goto on_error;\n\t}\n\tif (wavehdr.data_hdr.len < ptime * wavehdr.fmt_hdr.sample_rate *\n\t\t\t\t    wavehdr.fmt_hdr.nchan / 1000)\n\t{\n\t    status = PJMEDIA_EWAVETOOSHORT;\n\t    goto on_error;\n\t}\n\t\n\t/* It seems like we have a valid WAVE file. */\n\t\n\t/* Update port info if we don't have one, otherwise check\n\t * that the WAV file has the same attributes as previous files. \n\t */\n\tif (!has_wave_info) {\n\t    afd->channel_count = wavehdr.fmt_hdr.nchan;\n\t    afd->clock_rate = wavehdr.fmt_hdr.sample_rate;\n\t    afd->bits_per_sample = wavehdr.fmt_hdr.bits_per_sample;\n\t    afd->frame_time_usec = ptime * 1000;\n\t    afd->avg_bps = afd->max_bps = afd->clock_rate *\n\t\t\t\t\t  afd->channel_count *\n\t\t\t\t\t  afd->bits_per_sample;\n\n\t    has_wave_info = PJ_TRUE;\n\n\t} else {\n\n\t    /* Check that this file has the same characteristics as the other\n\t     * files.\n\t     */\n\t    if (wavehdr.fmt_hdr.nchan != afd->channel_count ||\n\t\twavehdr.fmt_hdr.sample_rate != afd->clock_rate ||\n\t\twavehdr.fmt_hdr.bits_per_sample != afd->bits_per_sample)\n\t    {\n\t\t/* This file has different characteristics than the other \n\t\t * files. \n\t\t */\n\t\tPJ_LOG(4,(THIS_FILE,\n\t\t          \"WAV playlist error: file '%s' has differrent number\"\n\t\t\t  \" of channels, sample rate, or bits per sample\",\n\t      \t\t  filename));\n\t\tstatus = PJMEDIA_EWAVEUNSUPP;\n\t\tgoto on_error;\n\t    }\n\n\t}\n\n\t/* If file is shorter than buffer size, adjust buffer size to file\n\t * size. Otherwise EOF callback will be called multiple times when\n\t * file_fill_buffer() is called.\n\t */\n\tif (wavehdr.data_hdr.len < (unsigned)buff_size)\n\t    buff_size = wavehdr.data_hdr.len;\n\n\t/* Create file buffer.\n\t */\n\tfport->bufsize = (pj_uint32_t)buff_size;\t\n\t\n\t/* Set initial position of the file. */\n\tfport->fpos_list[index] = fport->start_data_list[index];\n    }\n\n    /* Fill up the buffer. */\n    status = file_fill_buffer(fport);\n    if (status != PJ_SUCCESS) {\n\tgoto on_error;\n    }\n    \n    /* Done. */\n    \n    *p_port = &fport->base;\n    \n    PJ_LOG(4,(THIS_FILE,\n\t     \"WAV playlist '%.*s' created: samp.rate=%d, ch=%d, bufsize=%uKB\",\n\t     (int)port_label->slen,\n\t     port_label->ptr,\n\t     afd->clock_rate,\n\t     afd->channel_count,\n\t     fport->bufsize / 1000));\n    \n    return PJ_SUCCESS;\n\non_error:\n    for (index=0; index<file_count; ++index) {\n\tif (fport->fd_list[index] != 0)\n\t    pj_file_close(fport->fd_list[index]);\n    }\n\n    return status;\n}\n\n\n#if !DEPRECATED_FOR_TICKET_2251\n/*\n * Register a callback to be called when the file reading has reached the\n * end of the last file.\n */\nPJ_DEF(pj_status_t) pjmedia_wav_playlist_set_eof_cb(pjmedia_port *port,\n\t\t\t        void *user_data,\n\t\t\t        pj_status_t (*cb)(pjmedia_port *port,\n\t\t\t\t\t\t  void *usr_data))\n{\n    struct playlist_port *fport;\n\n    /* Sanity check */\n    PJ_ASSERT_RETURN(port, PJ_EINVAL);\n\n    /* Check that this is really a playlist port */\n    PJ_ASSERT_RETURN(port->info.signature == SIGNATURE, PJ_EINVALIDOP);\n\n    PJ_LOG(1, (THIS_FILE, \"pjmedia_wav_playlist_set_eof_cb() is deprecated. \"\n    \t       \"Use pjmedia_wav_playlist_set_eof_cb2() instead.\"));\n\n    fport = (struct playlist_port*) port;\n\n    fport->base.port_data.pdata = user_data;\n    fport->cb = cb;\n\n    return PJ_SUCCESS;\n}\n#endif\n\n\n/*\n * Register a callback to be called when the file reading has reached the\n * end of the last file.\n */\nPJ_DEF(pj_status_t) pjmedia_wav_playlist_set_eof_cb2(pjmedia_port *port,\n\t\t\t        void *user_data,\n\t\t\t        void (*cb)(pjmedia_port *port,\n\t\t\t\t\t   void *usr_data))\n{\n    struct playlist_port *fport;\n\n    /* Sanity check */\n    PJ_ASSERT_RETURN(port, PJ_EINVAL);\n\n    /* Check that this is really a playlist port */\n    PJ_ASSERT_RETURN(port->info.signature == SIGNATURE, PJ_EINVALIDOP);\n\n    fport = (struct playlist_port*) port;\n\n    fport->base.port_data.pdata = user_data;\n    fport->cb2 = cb;\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Get frame from file for file_list operation\n */\nstatic pj_status_t file_list_get_frame(pjmedia_port *this_port,\n\t\t\t\t       pjmedia_frame *frame)\n{\n    struct playlist_port *fport = (struct playlist_port*)this_port;\n    pj_size_t frame_size;\n    pj_status_t status;\n\n    pj_assert(fport->base.info.signature == SIGNATURE);\n\n    //frame_size = fport->base.info.bytes_per_frame;\n    //pj_assert(frame->size == frame_size);\n    frame_size = frame->size;\n\n    /* Copy frame from buffer. */\n    frame->type = PJMEDIA_FRAME_TYPE_AUDIO;\n    frame->size = frame_size;\n    frame->timestamp.u64 = 0;\n\n    if (fport->readpos + frame_size <= fport->buf + fport->bufsize) {\n\n\t/* Read contiguous buffer. */\n\tpj_memcpy(frame->buf, fport->readpos, frame_size);\n\n\t/* Fill up the buffer if all has been read. */\n\tfport->readpos += frame_size;\n\tif (fport->readpos == fport->buf + fport->bufsize) {\n\t    fport->readpos = fport->buf;\n\n\t    status = file_fill_buffer(fport);\n\t    if (status != PJ_SUCCESS) {\n\t\tframe->type = PJMEDIA_FRAME_TYPE_NONE;\n\t\tframe->size = 0;\n\t\treturn status;\n\t    }\n\t}\n    } else {\n\tunsigned endread;\n\n\t/* Split read.\n\t * First stage: read until end of buffer.\n\t */\n\tendread = (unsigned)((fport->buf+fport->bufsize) - fport->readpos);\n\tpj_memcpy(frame->buf, fport->readpos, endread);\n\n\t/* Second stage: fill up buffer, and read from the start of buffer. */\n\tstatus = file_fill_buffer(fport);\n\tif (status != PJ_SUCCESS) {\n\t    pj_bzero(((char*)frame->buf)+endread, frame_size-endread);\n\t    return status;\n\t}\n\n\tpj_memcpy(((char*)frame->buf)+endread, fport->buf, frame_size-endread);\n\tfport->readpos = fport->buf + (frame_size - endread);\n    }\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Destroy port.\n */\nstatic pj_status_t file_list_on_destroy(pjmedia_port *this_port)\n{\n    struct playlist_port *fport = (struct playlist_port*) this_port;\n    int index;\n\n    pj_assert(this_port->info.signature == SIGNATURE);\n\n    if (fport->subscribed) {\n    \tpjmedia_event_unsubscribe(NULL, &file_on_event, fport, fport);\n    \tfport->subscribed = PJ_FALSE;\n    }\n\n    for (index=0; index<fport->max_file; index++)\n\tpj_file_close(fport->fd_list[index]);\n\n    return PJ_SUCCESS;\n}\n\n"], "filenames": ["pjlib/include/pj/types.h", "pjlib/src/pj/file_io_ansi.c", "pjmedia/src/pjmedia/avi_player.c", "pjmedia/src/pjmedia/wav_player.c", "pjmedia/src/pjmedia/wav_playlist.c"], "buggy_code_start_loc": [33, 22, 285, 191, 422], "buggy_code_end_loc": [363, 126, 819, 329, 525], "fixing_code_start_loc": [34, 23, 285, 191, 422], "fixing_code_end_loc": [372, 134, 833, 336, 532], "type": "CWE-835", "message": "PJSIP is a free and open source multimedia communication library written in C. A denial-of-service vulnerability affects applications on a 32-bit systems that use PJSIP versions 2.12 and prior to play/read invalid WAV files. The vulnerability occurs when reading WAV file data chunks with length greater than 31-bit integers. The vulnerability does not affect 64-bit apps and should not affect apps that only plays trusted WAV files. A patch is available on the `master` branch of the `pjsip/project` GitHub repository. As a workaround, apps can reject a WAV file received from an unknown source or validate the file first.", "other": {"cve": {"id": "CVE-2022-24792", "sourceIdentifier": "security-advisories@github.com", "published": "2022-04-25T16:16:09.003", "lastModified": "2022-12-06T21:55:00.540", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "PJSIP is a free and open source multimedia communication library written in C. A denial-of-service vulnerability affects applications on a 32-bit systems that use PJSIP versions 2.12 and prior to play/read invalid WAV files. The vulnerability occurs when reading WAV file data chunks with length greater than 31-bit integers. The vulnerability does not affect 64-bit apps and should not affect apps that only plays trusted WAV files. A patch is available on the `master` branch of the `pjsip/project` GitHub repository. As a workaround, apps can reject a WAV file received from an unknown source or validate the file first."}, {"lang": "es", "value": "PJSIP es una biblioteca de comunicaci\u00f3n multimedia gratuita y de c\u00f3digo abierto escrita en C. Una vulnerabilidad de denegaci\u00f3n de servicio afecta a las aplicaciones en sistemas de 32 bits que usan PJSIP versiones 2.12 y anteriores para reproducir/leer archivos WAV no v\u00e1lidos. La vulnerabilidad es producida cuando son le\u00eddos trozos de datos de archivos WAV con una longitud superior a los enteros de 31 bits. La vulnerabilidad no afecta a aplicaciones de 64 bits y no deber\u00eda afectar a las aplicaciones que s\u00f3lo reproducen archivos WAV confiables. Se presenta un parche disponible en la rama \"master\" del repositorio GitHub \"pjsip/project\". Como medida de mitigaci\u00f3n, las aplicaciones pueden rechazar un archivo WAV recibido de una fuente desconocida o comprobar primero el archivo"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-835"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-835"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:teluu:pjsip:*:*:*:*:*:*:x86:*", "versionEndIncluding": "2.12", "matchCriteriaId": "5ACC52D7-10C8-4A11-9042-47C22D6E33AB"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:11.0:*:*:*:*:*:*:*", "matchCriteriaId": "FA6FEEC2-9F11-4643-8827-749718254FED"}]}]}], "references": [{"url": "https://github.com/pjsip/pjproject/commit/947bc1ee6d05be10204b918df75a503415fd3213", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/pjsip/pjproject/security/advisories/GHSA-rwgw-vwxg-q799", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/05/msg00047.html", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/11/msg00021.html", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202210-37", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2022/dsa-5285", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/pjsip/pjproject/commit/947bc1ee6d05be10204b918df75a503415fd3213"}}