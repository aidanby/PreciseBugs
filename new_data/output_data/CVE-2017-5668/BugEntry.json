{"buggy_code": ["/***************************************************************************\\\n*                                                                           *\n*  BitlBee - An IRC to IM gateway                                           *\n*  libpurple module - File transfer stuff                                   *\n*                                                                           *\n*  Copyright 2009-2010 Wilmer van der Gaast <wilmer@gaast.net>              *\n*                                                                           *\n*  This program is free software; you can redistribute it and/or modify     *\n*  it under the terms of the GNU General Public License as published by     *\n*  the Free Software Foundation; either version 2 of the License, or        *\n*  (at your option) any later version.                                      *\n*                                                                           *\n*  This program is distributed in the hope that it will be useful,          *\n*  but WITHOUT ANY WARRANTY; without even the implied warranty of           *\n*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            *\n*  GNU General Public License for more details.                             *\n*                                                                           *\n*  You should have received a copy of the GNU General Public License along  *\n*  with this program; if not, write to the Free Software Foundation, Inc.,  *\n*  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.              *\n*                                                                           *\n\\***************************************************************************/\n\n/* Do file transfers via disk for now, since libpurple was really designed\n   for straight-to/from disk fts and is only just learning how to pass the\n   file contents the the UI instead (2.6.0 and higher it seems, and with\n   varying levels of success). */\n\n#include \"bitlbee.h\"\n#include \"bpurple.h\"\n\n#include <stdarg.h>\n\n#include <glib.h>\n#include <purple.h>\n\nstruct prpl_xfer_data {\n\tPurpleXfer *xfer;\n\tfile_transfer_t *ft;\n\tstruct im_connection *ic;\n\tint fd;\n\tchar *fn, *handle;\n\tgboolean ui_wants_data;\n\tint timeout;\n};\n\nstatic file_transfer_t *next_ft;\n\nstruct im_connection *purple_ic_by_pa(PurpleAccount *pa);\nstatic gboolean prplcb_xfer_new_send_cb(gpointer data, gint fd, b_input_condition cond);\nstatic gboolean prpl_xfer_write_request(struct file_transfer *ft);\n\n\n/* Receiving files (IM->UI): */\nstatic void prpl_xfer_accept(struct file_transfer *ft)\n{\n\tstruct prpl_xfer_data *px = ft->data;\n\n\tpurple_xfer_request_accepted(px->xfer, NULL);\n\tprpl_xfer_write_request(ft);\n}\n\nstatic void prpl_xfer_canceled(struct file_transfer *ft, char *reason)\n{\n\tstruct prpl_xfer_data *px = ft->data;\n\n\tif (px->xfer) {\n\t\tif (!purple_xfer_is_completed(px->xfer) && !purple_xfer_is_canceled(px->xfer)) {\n\t\t\tpurple_xfer_cancel_local(px->xfer);\n\t\t}\n\t\tpx->xfer->ui_data = NULL;\n\t\tpurple_xfer_unref(px->xfer);\n\t\tpx->xfer = NULL;\n\t}\n}\n\nstatic void prpl_xfer_free(struct file_transfer *ft)\n{\n\tstruct prpl_xfer_data *px = ft->data;\n\tstruct purple_data *pd = px->ic->proto_data;\n\n\tpd->filetransfers = g_slist_remove(pd->filetransfers, px);\n\n\tif (px->xfer) {\n\t\tpx->xfer->ui_data = NULL;\n\t\tpurple_xfer_unref(px->xfer);\n\t}\n\n\tif (px->timeout) {\n\t\tb_event_remove(px->timeout);\n\t}\n\n\tg_free(px->fn);\n\tg_free(px->handle);\n\tif (px->fd >= 0) {\n\t\tclose(px->fd);\n\t}\n\tg_free(px);\n}\n\nstatic void prplcb_xfer_new(PurpleXfer *xfer)\n{\n\tpurple_xfer_ref(xfer);\n\n\tif (purple_xfer_get_type(xfer) == PURPLE_XFER_RECEIVE) {\n\t\tstruct prpl_xfer_data *px = g_new0(struct prpl_xfer_data, 1);\n\t\tstruct purple_data *pd;\n\n\t\txfer->ui_data = px;\n\t\tpx->xfer = xfer;\n\t\tpx->fn = mktemp(g_strdup(\"/tmp/bitlbee-purple-ft.XXXXXX\"));\n\t\tpx->fd = -1;\n\t\tpx->ic = purple_ic_by_pa(xfer->account);\n\n\t\tpd = px->ic->proto_data;\n\t\tpd->filetransfers = g_slist_prepend(pd->filetransfers, px);\n\n\t\tpurple_xfer_set_local_filename(xfer, px->fn);\n\n\t\t/* Sadly the xfer struct is still empty ATM so come back after\n\t\t   the caller is done. */\n\t\tb_timeout_add(0, prplcb_xfer_new_send_cb, xfer);\n\t} else {\n\t\tstruct file_transfer *ft = next_ft;\n\t\tstruct prpl_xfer_data *px = ft->data;\n\n\t\txfer->ui_data = px;\n\t\tpx->xfer = xfer;\n\n\t\tnext_ft = NULL;\n\t}\n}\n\nstatic gboolean prplcb_xfer_new_send_cb(gpointer data, gint fd, b_input_condition cond)\n{\n\tPurpleXfer *xfer = data;\n\tstruct im_connection *ic = purple_ic_by_pa(xfer->account);\n\tstruct prpl_xfer_data *px = xfer->ui_data;\n\tPurpleBuddy *buddy;\n\tconst char *who;\n\n\tbuddy = purple_find_buddy(xfer->account, xfer->who);\n\twho = buddy ? purple_buddy_get_name(buddy) : xfer->who;\n\n\t/* TODO(wilmer): After spreading some more const goodness in BitlBee,\n\t   remove the evil cast below. */\n\tpx->ft = imcb_file_send_start(ic, (char *) who, xfer->filename, xfer->size);\n\tpx->ft->data = px;\n\n\tpx->ft->accept = prpl_xfer_accept;\n\tpx->ft->canceled = prpl_xfer_canceled;\n\tpx->ft->free = prpl_xfer_free;\n\tpx->ft->write_request = prpl_xfer_write_request;\n\n\treturn FALSE;\n}\n\ngboolean try_write_to_ui(gpointer data, gint fd, b_input_condition cond)\n{\n\tstruct file_transfer *ft = data;\n\tstruct prpl_xfer_data *px = ft->data;\n\tstruct stat fs;\n\toff_t tx_bytes;\n\n\t/* If we don't have the file opened yet, there's no data so wait. */\n\tif (px->fd < 0 || !px->ui_wants_data) {\n\t\treturn FALSE;\n\t}\n\n\ttx_bytes = lseek(px->fd, 0, SEEK_CUR);\n\tfstat(px->fd, &fs);\n\n\tif (fs.st_size > tx_bytes) {\n\t\tchar buf[1024];\n\t\tsize_t n = MIN(fs.st_size - tx_bytes, sizeof(buf));\n\n\t\tif (read(px->fd, buf, n) == n && ft->write(ft, buf, n)) {\n\t\t\tpx->ui_wants_data = FALSE;\n\t\t} else {\n\t\t\tpurple_xfer_cancel_local(px->xfer);\n\t\t\timcb_file_canceled(px->ic, ft, \"Read error\");\n\t\t}\n\t}\n\n\tif (lseek(px->fd, 0, SEEK_CUR) == px->xfer->size) {\n\t\t/*purple_xfer_end( px->xfer );*/\n\t\timcb_file_finished(px->ic, ft);\n\t}\n\n\treturn FALSE;\n}\n\n/* UI calls this when its buffer is empty and wants more data to send to the user. */\nstatic gboolean prpl_xfer_write_request(struct file_transfer *ft)\n{\n\tstruct prpl_xfer_data *px = ft->data;\n\n\tpx->ui_wants_data = TRUE;\n\ttry_write_to_ui(ft, 0, 0);\n\n\treturn FALSE;\n}\n\n\nstatic void prplcb_xfer_destroy(PurpleXfer *xfer)\n{\n\tstruct prpl_xfer_data *px = xfer->ui_data;\n\n\tif (px) {\n\t\tpx->xfer = NULL;\n\t}\n}\n\nstatic void prplcb_xfer_progress(PurpleXfer *xfer, double percent)\n{\n\tstruct prpl_xfer_data *px = xfer->ui_data;\n\n\tif (px == NULL) {\n\t\treturn;\n\t}\n\n\tif (purple_xfer_get_type(xfer) == PURPLE_XFER_SEND) {\n\t\tif (*px->fn) {\n\t\t\tchar *slash;\n\n\t\t\tunlink(px->fn);\n\t\t\tif ((slash = strrchr(px->fn, '/'))) {\n\t\t\t\t*slash = '\\0';\n\t\t\t\trmdir(px->fn);\n\t\t\t}\n\t\t\t*px->fn = '\\0';\n\t\t}\n\n\t\treturn;\n\t}\n\n\tif (px->fd == -1 && percent > 0) {\n\t\t/* Weeeeeeeee, we're getting data! That means the file exists\n\t\t   by now so open it and start sending to the UI. */\n\t\tpx->fd = open(px->fn, O_RDONLY);\n\n\t\t/* Unlink it now, because we don't need it after this. */\n\t\tunlink(px->fn);\n\t}\n\n\tif (percent < 1) {\n\t\ttry_write_to_ui(px->ft, 0, 0);\n\t} else {\n\t\t/* Another nice problem: If we have the whole file, it only\n\t\t   gets closed when we return. Problem: There may still be\n\t\t   stuff buffered and not written, we'll only see it after\n\t\t   the caller close()s the file. So poll the file after that. */\n\t\tb_timeout_add(0, try_write_to_ui, px->ft);\n\t}\n}\n\nstatic void prplcb_xfer_cancel_remote(PurpleXfer *xfer)\n{\n\tstruct prpl_xfer_data *px = xfer->ui_data;\n\n\tif (px && px->ft) {\n\t\timcb_file_canceled(px->ic, px->ft, \"Canceled by remote end\");\n\t} else if (px) {\n\t\t/* px->ft == NULL for sends, because of the two stages. :-/ */\n\t\timcb_error(px->ic, \"File transfer cancelled by remote end\");\n\t}\n}\n\n\n/* Sending files (UI->IM): */\nstatic gboolean prpl_xfer_write(struct file_transfer *ft, char *buffer, unsigned int len);\nstatic gboolean purple_transfer_request_cb(gpointer data, gint fd, b_input_condition cond);\n\nvoid purple_transfer_request(struct im_connection *ic, file_transfer_t *ft, char *handle)\n{\n\tstruct prpl_xfer_data *px = g_new0(struct prpl_xfer_data, 1);\n\tstruct purple_data *pd;\n\tchar *dir, *basename;\n\n\tft->data = px;\n\tpx->ft = ft;\n\tpx->ft->free = prpl_xfer_free;\n\n\tdir = g_strdup(\"/tmp/bitlbee-purple-ft.XXXXXX\");\n\tif (!mkdtemp(dir)) {\n\t\timcb_error(ic, \"Could not create temporary file for file transfer\");\n\t\tg_free(px);\n\t\tg_free(dir);\n\t\treturn;\n\t}\n\n\tif ((basename = strrchr(ft->file_name, '/'))) {\n\t\tbasename++;\n\t} else {\n\t\tbasename = ft->file_name;\n\t}\n\tpx->fn = g_strdup_printf(\"%s/%s\", dir, basename);\n\tpx->fd = open(px->fn, O_WRONLY | O_CREAT, 0600);\n\tg_free(dir);\n\n\tif (px->fd < 0) {\n\t\timcb_error(ic, \"Could not create temporary file for file transfer\");\n\t\tg_free(px);\n\t\tg_free(px->fn);\n\t\treturn;\n\t}\n\n\tpx->ic = ic;\n\tpx->handle = g_strdup(handle);\n\n\tpd = px->ic->proto_data;\n\tpd->filetransfers = g_slist_prepend(pd->filetransfers, px);\n\n\timcb_log(ic,\n\t         \"Due to libpurple limitations, the file has to be cached locally before proceeding with the actual file transfer. Please wait...\");\n\n\tpx->timeout = b_timeout_add(0, purple_transfer_request_cb, ft);\n}\n\nstatic void purple_transfer_forward(struct file_transfer *ft)\n{\n\tstruct prpl_xfer_data *px = ft->data;\n\tstruct purple_data *pd = px->ic->proto_data;\n\n\t/* xfer_new() will pick up this variable. It's a hack but we're not\n\t   multi-threaded anyway. */\n\tnext_ft = ft;\n\tserv_send_file(purple_account_get_connection(pd->account),\n                   px->handle, px->fn);\n}\n\nstatic gboolean purple_transfer_request_cb(gpointer data, gint fd, b_input_condition cond)\n{\n\tfile_transfer_t *ft = data;\n\tstruct prpl_xfer_data *px = ft->data;\n\n\tpx->timeout = 0;\n\n\tif (ft->write == NULL) {\n\t\tft->write = prpl_xfer_write;\n\t\timcb_file_recv_start(px->ic, ft);\n\t}\n\n\tft->write_request(ft);\n\n\treturn FALSE;\n}\n\nstatic gboolean prpl_xfer_write(struct file_transfer *ft, char *buffer, unsigned int len)\n{\n\tstruct prpl_xfer_data *px = ft->data;\n\n\tif (write(px->fd, buffer, len) != len) {\n\t\timcb_file_canceled(px->ic, ft, \"Error while writing temporary file\");\n\t\treturn FALSE;\n\t}\n\n\tif (lseek(px->fd, 0, SEEK_CUR) >= ft->file_size) {\n\t\tclose(px->fd);\n\t\tpx->fd = -1;\n\n\t\tpurple_transfer_forward(ft);\n\t\timcb_file_finished(px->ic, ft);\n\t\tpx->ft = NULL;\n\t} else {\n\t\tpx->timeout = b_timeout_add(0, purple_transfer_request_cb, ft);\n\t}\n\n\treturn TRUE;\n}\n\nvoid purple_transfer_cancel_all(struct im_connection *ic)\n{\n\tstruct purple_data *pd = ic->proto_data;\n\n\twhile (pd->filetransfers) {\n\t\tstruct prpl_xfer_data *px = pd->filetransfers->data;\n\n\t\tif (px->ft) {\n\t\t\timcb_file_canceled(ic, px->ft, \"Logging out\");\n\t\t}\n\n\t\tpd->filetransfers = g_slist_remove(pd->filetransfers, px);\n\t}\n}\n\n\n\nPurpleXferUiOps bee_xfer_uiops =\n{\n\tprplcb_xfer_new,           /* new_xfer */\n\tprplcb_xfer_destroy,       /* destroy */\n\tNULL,                      /* add_xfer */\n\tprplcb_xfer_progress,      /* update_progress */\n\tNULL,                      /* cancel_local */\n\tprplcb_xfer_cancel_remote, /* cancel_remote */\n\tNULL,                      /* ui_write */\n\tNULL,                      /* ui_read */\n\tNULL,                      /* data_not_sent */\n};\n"], "fixing_code": ["/***************************************************************************\\\n*                                                                           *\n*  BitlBee - An IRC to IM gateway                                           *\n*  libpurple module - File transfer stuff                                   *\n*                                                                           *\n*  Copyright 2009-2010 Wilmer van der Gaast <wilmer@gaast.net>              *\n*                                                                           *\n*  This program is free software; you can redistribute it and/or modify     *\n*  it under the terms of the GNU General Public License as published by     *\n*  the Free Software Foundation; either version 2 of the License, or        *\n*  (at your option) any later version.                                      *\n*                                                                           *\n*  This program is distributed in the hope that it will be useful,          *\n*  but WITHOUT ANY WARRANTY; without even the implied warranty of           *\n*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            *\n*  GNU General Public License for more details.                             *\n*                                                                           *\n*  You should have received a copy of the GNU General Public License along  *\n*  with this program; if not, write to the Free Software Foundation, Inc.,  *\n*  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.              *\n*                                                                           *\n\\***************************************************************************/\n\n/* Do file transfers via disk for now, since libpurple was really designed\n   for straight-to/from disk fts and is only just learning how to pass the\n   file contents the the UI instead (2.6.0 and higher it seems, and with\n   varying levels of success). */\n\n#include \"bitlbee.h\"\n#include \"bpurple.h\"\n\n#include <stdarg.h>\n\n#include <glib.h>\n#include <purple.h>\n\nstruct prpl_xfer_data {\n\tPurpleXfer *xfer;\n\tfile_transfer_t *ft;\n\tstruct im_connection *ic;\n\tint fd;\n\tchar *fn, *handle;\n\tgboolean ui_wants_data;\n\tint timeout;\n};\n\nstatic file_transfer_t *next_ft;\n\nstruct im_connection *purple_ic_by_pa(PurpleAccount *pa);\nstatic gboolean prplcb_xfer_new_send_cb(gpointer data, gint fd, b_input_condition cond);\nstatic gboolean prpl_xfer_write_request(struct file_transfer *ft);\n\n\n/* Receiving files (IM->UI): */\nstatic void prpl_xfer_accept(struct file_transfer *ft)\n{\n\tstruct prpl_xfer_data *px = ft->data;\n\n\tpurple_xfer_request_accepted(px->xfer, NULL);\n\tprpl_xfer_write_request(ft);\n}\n\nstatic void prpl_xfer_canceled(struct file_transfer *ft, char *reason)\n{\n\tstruct prpl_xfer_data *px = ft->data;\n\n\tif (px->xfer) {\n\t\tif (!purple_xfer_is_completed(px->xfer) && !purple_xfer_is_canceled(px->xfer)) {\n\t\t\tpurple_xfer_cancel_local(px->xfer);\n\t\t}\n\t\tpx->xfer->ui_data = NULL;\n\t\tpurple_xfer_unref(px->xfer);\n\t\tpx->xfer = NULL;\n\t}\n}\n\nstatic void prpl_xfer_free(struct file_transfer *ft)\n{\n\tstruct prpl_xfer_data *px = ft->data;\n\tstruct purple_data *pd = px->ic->proto_data;\n\n\tpd->filetransfers = g_slist_remove(pd->filetransfers, px);\n\n\tif (px->xfer) {\n\t\tpx->xfer->ui_data = NULL;\n\t\tpurple_xfer_unref(px->xfer);\n\t}\n\n\tif (px->timeout) {\n\t\tb_event_remove(px->timeout);\n\t}\n\n\tg_free(px->fn);\n\tg_free(px->handle);\n\tif (px->fd >= 0) {\n\t\tclose(px->fd);\n\t}\n\tg_free(px);\n}\n\nstatic void prplcb_xfer_new(PurpleXfer *xfer)\n{\n\tpurple_xfer_ref(xfer);\n\n\tif (purple_xfer_get_type(xfer) == PURPLE_XFER_RECEIVE) {\n\t\tstruct prpl_xfer_data *px = g_new0(struct prpl_xfer_data, 1);\n\t\tstruct purple_data *pd;\n\n\t\txfer->ui_data = px;\n\t\tpx->xfer = xfer;\n\t\tpx->fn = mktemp(g_strdup(\"/tmp/bitlbee-purple-ft.XXXXXX\"));\n\t\tpx->fd = -1;\n\t\tpx->ic = purple_ic_by_pa(xfer->account);\n\n\t\tpd = px->ic->proto_data;\n\t\tpd->filetransfers = g_slist_prepend(pd->filetransfers, px);\n\n\t\tpurple_xfer_set_local_filename(xfer, px->fn);\n\n\t\t/* Sadly the xfer struct is still empty ATM so come back after\n\t\t   the caller is done. */\n\t\tb_timeout_add(0, prplcb_xfer_new_send_cb, xfer);\n\t} else {\n\t\tstruct file_transfer *ft = next_ft;\n\t\tstruct prpl_xfer_data *px = ft->data;\n\n\t\txfer->ui_data = px;\n\t\tpx->xfer = xfer;\n\n\t\tnext_ft = NULL;\n\t}\n}\n\nstatic gboolean prplcb_xfer_new_send_cb(gpointer data, gint fd, b_input_condition cond)\n{\n\tPurpleXfer *xfer = data;\n\tstruct im_connection *ic = purple_ic_by_pa(xfer->account);\n\tstruct prpl_xfer_data *px = xfer->ui_data;\n\tPurpleBuddy *buddy;\n\tconst char *who;\n\n\tbuddy = purple_find_buddy(xfer->account, xfer->who);\n\twho = buddy ? purple_buddy_get_name(buddy) : xfer->who;\n\n\t/* TODO(wilmer): After spreading some more const goodness in BitlBee,\n\t   remove the evil cast below. */\n\tpx->ft = imcb_file_send_start(ic, (char *) who, xfer->filename, xfer->size);\n\n\tif (!px->ft) {\n\t\treturn FALSE;\n\t}\n\tpx->ft->data = px;\n\n\tpx->ft->accept = prpl_xfer_accept;\n\tpx->ft->canceled = prpl_xfer_canceled;\n\tpx->ft->free = prpl_xfer_free;\n\tpx->ft->write_request = prpl_xfer_write_request;\n\n\treturn FALSE;\n}\n\ngboolean try_write_to_ui(gpointer data, gint fd, b_input_condition cond)\n{\n\tstruct file_transfer *ft = data;\n\tstruct prpl_xfer_data *px = ft->data;\n\tstruct stat fs;\n\toff_t tx_bytes;\n\n\t/* If we don't have the file opened yet, there's no data so wait. */\n\tif (px->fd < 0 || !px->ui_wants_data) {\n\t\treturn FALSE;\n\t}\n\n\ttx_bytes = lseek(px->fd, 0, SEEK_CUR);\n\tfstat(px->fd, &fs);\n\n\tif (fs.st_size > tx_bytes) {\n\t\tchar buf[1024];\n\t\tsize_t n = MIN(fs.st_size - tx_bytes, sizeof(buf));\n\n\t\tif (read(px->fd, buf, n) == n && ft->write(ft, buf, n)) {\n\t\t\tpx->ui_wants_data = FALSE;\n\t\t} else {\n\t\t\tpurple_xfer_cancel_local(px->xfer);\n\t\t\timcb_file_canceled(px->ic, ft, \"Read error\");\n\t\t}\n\t}\n\n\tif (lseek(px->fd, 0, SEEK_CUR) == px->xfer->size) {\n\t\t/*purple_xfer_end( px->xfer );*/\n\t\timcb_file_finished(px->ic, ft);\n\t}\n\n\treturn FALSE;\n}\n\n/* UI calls this when its buffer is empty and wants more data to send to the user. */\nstatic gboolean prpl_xfer_write_request(struct file_transfer *ft)\n{\n\tstruct prpl_xfer_data *px = ft->data;\n\n\tpx->ui_wants_data = TRUE;\n\ttry_write_to_ui(ft, 0, 0);\n\n\treturn FALSE;\n}\n\n\nstatic void prplcb_xfer_destroy(PurpleXfer *xfer)\n{\n\tstruct prpl_xfer_data *px = xfer->ui_data;\n\n\tif (px) {\n\t\tpx->xfer = NULL;\n\t}\n}\n\nstatic void prplcb_xfer_progress(PurpleXfer *xfer, double percent)\n{\n\tstruct prpl_xfer_data *px = xfer->ui_data;\n\n\tif (px == NULL) {\n\t\treturn;\n\t}\n\n\tif (purple_xfer_get_type(xfer) == PURPLE_XFER_SEND) {\n\t\tif (*px->fn) {\n\t\t\tchar *slash;\n\n\t\t\tunlink(px->fn);\n\t\t\tif ((slash = strrchr(px->fn, '/'))) {\n\t\t\t\t*slash = '\\0';\n\t\t\t\trmdir(px->fn);\n\t\t\t}\n\t\t\t*px->fn = '\\0';\n\t\t}\n\n\t\treturn;\n\t}\n\n\tif (px->fd == -1 && percent > 0) {\n\t\t/* Weeeeeeeee, we're getting data! That means the file exists\n\t\t   by now so open it and start sending to the UI. */\n\t\tpx->fd = open(px->fn, O_RDONLY);\n\n\t\t/* Unlink it now, because we don't need it after this. */\n\t\tunlink(px->fn);\n\t}\n\n\tif (percent < 1) {\n\t\ttry_write_to_ui(px->ft, 0, 0);\n\t} else {\n\t\t/* Another nice problem: If we have the whole file, it only\n\t\t   gets closed when we return. Problem: There may still be\n\t\t   stuff buffered and not written, we'll only see it after\n\t\t   the caller close()s the file. So poll the file after that. */\n\t\tb_timeout_add(0, try_write_to_ui, px->ft);\n\t}\n}\n\nstatic void prplcb_xfer_cancel_remote(PurpleXfer *xfer)\n{\n\tstruct prpl_xfer_data *px = xfer->ui_data;\n\n\tif (px && px->ft) {\n\t\timcb_file_canceled(px->ic, px->ft, \"Canceled by remote end\");\n\t} else if (px) {\n\t\t/* px->ft == NULL for sends, because of the two stages. :-/ */\n\t\timcb_error(px->ic, \"File transfer cancelled by remote end\");\n\t}\n}\n\n\n/* Sending files (UI->IM): */\nstatic gboolean prpl_xfer_write(struct file_transfer *ft, char *buffer, unsigned int len);\nstatic gboolean purple_transfer_request_cb(gpointer data, gint fd, b_input_condition cond);\n\nvoid purple_transfer_request(struct im_connection *ic, file_transfer_t *ft, char *handle)\n{\n\tstruct prpl_xfer_data *px = g_new0(struct prpl_xfer_data, 1);\n\tstruct purple_data *pd;\n\tchar *dir, *basename;\n\n\tft->data = px;\n\tpx->ft = ft;\n\tpx->ft->free = prpl_xfer_free;\n\n\tdir = g_strdup(\"/tmp/bitlbee-purple-ft.XXXXXX\");\n\tif (!mkdtemp(dir)) {\n\t\timcb_error(ic, \"Could not create temporary file for file transfer\");\n\t\tg_free(px);\n\t\tg_free(dir);\n\t\treturn;\n\t}\n\n\tif ((basename = strrchr(ft->file_name, '/'))) {\n\t\tbasename++;\n\t} else {\n\t\tbasename = ft->file_name;\n\t}\n\tpx->fn = g_strdup_printf(\"%s/%s\", dir, basename);\n\tpx->fd = open(px->fn, O_WRONLY | O_CREAT, 0600);\n\tg_free(dir);\n\n\tif (px->fd < 0) {\n\t\timcb_error(ic, \"Could not create temporary file for file transfer\");\n\t\tg_free(px);\n\t\tg_free(px->fn);\n\t\treturn;\n\t}\n\n\tpx->ic = ic;\n\tpx->handle = g_strdup(handle);\n\n\tpd = px->ic->proto_data;\n\tpd->filetransfers = g_slist_prepend(pd->filetransfers, px);\n\n\timcb_log(ic,\n\t         \"Due to libpurple limitations, the file has to be cached locally before proceeding with the actual file transfer. Please wait...\");\n\n\tpx->timeout = b_timeout_add(0, purple_transfer_request_cb, ft);\n}\n\nstatic void purple_transfer_forward(struct file_transfer *ft)\n{\n\tstruct prpl_xfer_data *px = ft->data;\n\tstruct purple_data *pd = px->ic->proto_data;\n\n\t/* xfer_new() will pick up this variable. It's a hack but we're not\n\t   multi-threaded anyway. */\n\tnext_ft = ft;\n\tserv_send_file(purple_account_get_connection(pd->account),\n                   px->handle, px->fn);\n}\n\nstatic gboolean purple_transfer_request_cb(gpointer data, gint fd, b_input_condition cond)\n{\n\tfile_transfer_t *ft = data;\n\tstruct prpl_xfer_data *px = ft->data;\n\n\tpx->timeout = 0;\n\n\tif (ft->write == NULL) {\n\t\tft->write = prpl_xfer_write;\n\t\timcb_file_recv_start(px->ic, ft);\n\t}\n\n\tft->write_request(ft);\n\n\treturn FALSE;\n}\n\nstatic gboolean prpl_xfer_write(struct file_transfer *ft, char *buffer, unsigned int len)\n{\n\tstruct prpl_xfer_data *px = ft->data;\n\n\tif (write(px->fd, buffer, len) != len) {\n\t\timcb_file_canceled(px->ic, ft, \"Error while writing temporary file\");\n\t\treturn FALSE;\n\t}\n\n\tif (lseek(px->fd, 0, SEEK_CUR) >= ft->file_size) {\n\t\tclose(px->fd);\n\t\tpx->fd = -1;\n\n\t\tpurple_transfer_forward(ft);\n\t\timcb_file_finished(px->ic, ft);\n\t\tpx->ft = NULL;\n\t} else {\n\t\tpx->timeout = b_timeout_add(0, purple_transfer_request_cb, ft);\n\t}\n\n\treturn TRUE;\n}\n\nvoid purple_transfer_cancel_all(struct im_connection *ic)\n{\n\tstruct purple_data *pd = ic->proto_data;\n\n\twhile (pd->filetransfers) {\n\t\tstruct prpl_xfer_data *px = pd->filetransfers->data;\n\n\t\tif (px->ft) {\n\t\t\timcb_file_canceled(ic, px->ft, \"Logging out\");\n\t\t}\n\n\t\tpd->filetransfers = g_slist_remove(pd->filetransfers, px);\n\t}\n}\n\n\n\nPurpleXferUiOps bee_xfer_uiops =\n{\n\tprplcb_xfer_new,           /* new_xfer */\n\tprplcb_xfer_destroy,       /* destroy */\n\tNULL,                      /* add_xfer */\n\tprplcb_xfer_progress,      /* update_progress */\n\tNULL,                      /* cancel_local */\n\tprplcb_xfer_cancel_remote, /* cancel_remote */\n\tNULL,                      /* ui_write */\n\tNULL,                      /* ui_read */\n\tNULL,                      /* data_not_sent */\n};\n"], "filenames": ["protocols/purple/ft.c"], "buggy_code_start_loc": [147], "buggy_code_end_loc": [147], "fixing_code_start_loc": [148], "fixing_code_end_loc": [152], "type": "CWE-476", "message": "bitlbee-libpurple before 3.5.1 allows remote attackers to cause a denial of service (NULL pointer dereference and crash) and possibly execute arbitrary code via a file transfer request for a contact that is not in the contact list.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2016-10189.", "other": {"cve": {"id": "CVE-2017-5668", "sourceIdentifier": "cve@mitre.org", "published": "2017-03-14T14:59:00.417", "lastModified": "2017-03-16T01:59:02.217", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "bitlbee-libpurple before 3.5.1 allows remote attackers to cause a denial of service (NULL pointer dereference and crash) and possibly execute arbitrary code via a file transfer request for a contact that is not in the contact list.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2016-10189."}, {"lang": "es", "value": "bitlbee-libpurple en versiones anteriores a 3.5.1 permite a atacantes remotos provocar una denegaci\u00f3n de servicio (referencia a puntero NULL y ca\u00edda) y posiblemente ejecutar c\u00f3digo arbitrario mediante una solicitud de transferencia de archivos para un contacto que no est\u00e1 en la lista de contactos. NOTA: esta vulnerabilidad existe debido a una soluci\u00f3n incompleta para CVE-2016-10189."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:bitlbee:bitlbee:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.4.2", "matchCriteriaId": "79E1B13E-6F21-43C5-AE1B-19F9F698283D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bitlbee:bitlbee-libpurple:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.5", "matchCriteriaId": "A13DFB9F-3CF0-4DA6-8167-F361B4611C9B"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2017/01/30/4", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2017/01/31/11", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/95932", "source": "cve@mitre.org"}, {"url": "https://bugs.bitlbee.org/ticket/1282", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Vendor Advisory"]}, {"url": "https://github.com/bitlbee/bitlbee/commit/30d598ce7cd3f136ee9d7097f39fa9818a272441", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/bitlbee/bitlbee/commit/30d598ce7cd3f136ee9d7097f39fa9818a272441"}}