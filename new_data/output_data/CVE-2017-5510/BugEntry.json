{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                            PPPP   SSSSS  DDDD                               %\n%                            P   P  SS     D   D                              %\n%                            PPPP    SSS   D   D                              %\n%                            P         SS  D   D                              %\n%                            P      SSSSS  DDDD                               %\n%                                                                             %\n%                                                                             %\n%                   Read/Write Adobe Photoshop Image Format                   %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                              Leonard Rosenthol                              %\n%                                 July 1992                                   %\n%                                Dirk Lemstra                                 %\n%                                December 2013                                %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2017 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/artifact.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/channel.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colormap-private.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/enhance.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/log.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/pixel.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/profile.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/registry.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/thread-private.h\"\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n#include <zlib.h>\n#endif\n#include \"psd-private.h\"\n\n/*\n  Define declaractions.\n*/\n#define MaxPSDChannels  56\n#define PSDQuantum(x) (((ssize_t) (x)+1) & -2)\n\f\n/*\n  Enumerated declaractions.\n*/\ntypedef enum\n{\n  Raw = 0,\n  RLE = 1,\n  ZipWithoutPrediction = 2,\n  ZipWithPrediction = 3\n} PSDCompressionType;\n\ntypedef enum\n{\n  BitmapMode = 0,\n  GrayscaleMode = 1,\n  IndexedMode = 2,\n  RGBMode = 3,\n  CMYKMode = 4,\n  MultichannelMode = 7,\n  DuotoneMode = 8,\n  LabMode = 9\n} PSDImageType;\n\f\n/*\n  Typedef declaractions.\n*/\ntypedef struct _ChannelInfo\n{\n  short int\n    type;\n\n  size_t\n    size;\n} ChannelInfo;\n\ntypedef struct _MaskInfo\n{\n  Image\n    *image;\n\n  RectangleInfo\n    page;\n\n  unsigned char\n    background,\n    flags;\n} MaskInfo;\n\ntypedef struct _LayerInfo\n{\n  ChannelInfo\n    channel_info[MaxPSDChannels];\n\n  char\n    blendkey[4];\n\n  Image\n    *image;\n\n  MaskInfo\n    mask;\n\n  Quantum\n    opacity;\n\n  RectangleInfo\n    page;\n\n  size_t\n    offset_x,\n    offset_y;\n\n  unsigned char\n    clipping,\n    flags,\n    name[256],\n    visible;\n\n  unsigned short\n    channels;\n\n  StringInfo\n    *info;\n} LayerInfo;\n\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  WritePSDImage(const ImageInfo *,Image *,ExceptionInfo *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s P S D                                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsPSD()() returns MagickTrue if the image format type, identified by the\n%  magick string, is PSD.\n%\n%  The format of the IsPSD method is:\n%\n%      MagickBooleanType IsPSD(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsPSD(const unsigned char *magick,const size_t length)\n{\n  if (length < 4)\n    return(MagickFalse);\n  if (LocaleNCompare((const char *) magick,\"8BPS\",4) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d P S D I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadPSDImage() reads an Adobe Photoshop image file and returns it.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the ReadPSDImage method is:\n%\n%      Image *ReadPSDImage(image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic const char *CompositeOperatorToPSDBlendMode(CompositeOperator op)\n{\n  const char\n    *blend_mode;\n\n  switch (op)\n  {\n    case ColorBurnCompositeOp:  blend_mode = \"idiv\";  break;\n    case ColorDodgeCompositeOp: blend_mode = \"div \";  break;\n    case ColorizeCompositeOp:   blend_mode = \"colr\";  break;\n    case DarkenCompositeOp:     blend_mode = \"dark\";  break;\n    case DifferenceCompositeOp: blend_mode = \"diff\";  break;\n    case DissolveCompositeOp:   blend_mode = \"diss\";  break;\n    case ExclusionCompositeOp:  blend_mode = \"smud\";  break;\n    case HardLightCompositeOp:  blend_mode = \"hLit\";  break;\n    case HardMixCompositeOp:    blend_mode = \"hMix\";  break;\n    case HueCompositeOp:        blend_mode = \"hue \";  break;\n    case LightenCompositeOp:    blend_mode = \"lite\";  break;\n    case LinearBurnCompositeOp: blend_mode = \"lbrn\";  break;\n    case LinearDodgeCompositeOp:blend_mode = \"lddg\";  break;\n    case LinearLightCompositeOp:blend_mode = \"lLit\";  break;\n    case LuminizeCompositeOp:   blend_mode = \"lum \";  break;\n    case MultiplyCompositeOp:   blend_mode = \"mul \";  break;\n    case OverCompositeOp:       blend_mode = \"norm\";  break;\n    case OverlayCompositeOp:    blend_mode = \"over\";  break;\n    case PinLightCompositeOp:   blend_mode = \"pLit\";  break;\n    case SaturateCompositeOp:   blend_mode = \"sat \";  break;\n    case ScreenCompositeOp:     blend_mode = \"scrn\";  break;\n    case SoftLightCompositeOp:  blend_mode = \"sLit\";  break;\n    case VividLightCompositeOp: blend_mode = \"vLit\";  break;\n    default:                    blend_mode = \"norm\";\n  }\n  return(blend_mode);\n}\n\n/*\n  For some reason Photoshop seems to blend semi-transparent pixels with white.\n  This method reverts the blending. This can be disabled by setting the\n  option 'psd:alpha-unblend' to off.\n*/\nstatic MagickBooleanType CorrectPSDAlphaBlend(const ImageInfo *image_info,\n  Image *image,ExceptionInfo* exception)\n{\n  const char\n    *option;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    y;\n\n  if (image->alpha_trait != BlendPixelTrait || image->colorspace != sRGBColorspace)\n    return(MagickTrue);\n  option=GetImageOption(image_info,\"psd:alpha-unblend\");\n  if (IsStringFalse(option) != MagickFalse)\n    return(MagickTrue);\n  status=MagickTrue;\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n#pragma omp parallel for schedule(static,4) shared(status) \\\n  magick_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n    {\n      status=MagickFalse;\n      continue;\n    }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double\n        gamma;\n\n      register ssize_t\n        i;\n\n      gamma=QuantumScale*GetPixelAlpha(image, q);\n      if (gamma != 0.0 && gamma != 1.0)\n        {\n          for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n          {\n            PixelChannel channel=GetPixelChannelChannel(image,i);\n            if (channel != AlphaPixelChannel)\n              q[i]=ClampToQuantum((q[i]-((1.0-gamma)*QuantumRange))/gamma);\n          }\n        }\n      q+=GetPixelChannels(image);\n    }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n\n  return(status);\n}\n\nstatic inline CompressionType ConvertPSDCompression(\n  PSDCompressionType compression)\n{\n  switch (compression)\n  {\n    case RLE:\n      return RLECompression;\n    case ZipWithPrediction:\n    case ZipWithoutPrediction:\n      return ZipCompression;\n    default:\n      return NoCompression;\n  }\n}\n\nstatic MagickBooleanType ApplyPSDLayerOpacity(Image *image,Quantum opacity,\n  MagickBooleanType revert,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  ssize_t\n    y;\n\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  applying layer opacity %.20g\", (double) opacity);\n  if (opacity == OpaqueAlpha)\n    return(MagickTrue);\n  image->alpha_trait=BlendPixelTrait;\n  status=MagickTrue;\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n#pragma omp parallel for schedule(static,4) shared(status) \\\n  magick_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      if (revert == MagickFalse)\n        SetPixelAlpha(image,(Quantum) (QuantumScale*(GetPixelAlpha(image,q))*\n          opacity),q);\n      else if (opacity > 0)\n        SetPixelAlpha(image,(Quantum) (QuantumRange*(GetPixelAlpha(image,q)/\n          (MagickRealType) opacity)),q);\n      q+=GetPixelChannels(image);\n    }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n\n  return(status);\n}\n\nstatic MagickBooleanType ApplyPSDOpacityMask(Image *image,const Image *mask,\n  Quantum background,MagickBooleanType revert,ExceptionInfo *exception)\n{\n  Image\n    *complete_mask;\n\n  MagickBooleanType\n    status;\n\n  PixelInfo\n    color;\n\n  ssize_t\n    y;\n\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  applying opacity mask\");\n  complete_mask=CloneImage(image,image->columns,image->rows,MagickTrue,\n    exception);\n  complete_mask->alpha_trait=BlendPixelTrait;\n  GetPixelInfo(complete_mask,&color);\n  color.red=background;\n  SetImageColor(complete_mask,&color,exception);\n  status=CompositeImage(complete_mask,mask,OverCompositeOp,MagickTrue,\n    mask->page.x-image->page.x,mask->page.y-image->page.y,exception);\n  if (status == MagickFalse)\n    {\n      complete_mask=DestroyImage(complete_mask);\n      return(status);\n    }\n  image->alpha_trait=BlendPixelTrait;\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n#pragma omp parallel for schedule(static,4) shared(status) \\\n  magick_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register Quantum\n      *magick_restrict q;\n\n    register Quantum\n      *p;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n    p=GetAuthenticPixels(complete_mask,0,y,complete_mask->columns,1,exception);\n    if ((q == (Quantum *) NULL) || (p == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      MagickRealType\n        alpha,\n        intensity;\n\n      alpha=GetPixelAlpha(image,q);\n      intensity=GetPixelIntensity(complete_mask,p);\n      if (revert == MagickFalse)\n        SetPixelAlpha(image,ClampToQuantum(intensity*(QuantumScale*alpha)),q);\n      else if (intensity > 0)\n        SetPixelAlpha(image,ClampToQuantum((alpha/intensity)*QuantumRange),q);\n      q+=GetPixelChannels(image);\n      p+=GetPixelChannels(complete_mask);\n    }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n  complete_mask=DestroyImage(complete_mask);\n  return(status);\n}\n\nstatic void PreservePSDOpacityMask(Image *image,LayerInfo* layer_info,\n  ExceptionInfo *exception)\n{\n  char\n    *key;\n\n  RandomInfo\n    *random_info;\n\n  StringInfo\n    *key_info;\n\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  preserving opacity mask\");\n  random_info=AcquireRandomInfo();\n  key_info=GetRandomKey(random_info,2+1);\n  key=(char *) GetStringInfoDatum(key_info);\n  key[8]=layer_info->mask.background;\n  key[9]='\\0';\n  layer_info->mask.image->page.x+=layer_info->page.x;\n  layer_info->mask.image->page.y+=layer_info->page.y;\n  (void) SetImageRegistry(ImageRegistryType,(const char *) key,\n    layer_info->mask.image,exception);\n  (void) SetImageArtifact(layer_info->image,\"psd:opacity-mask\",\n    (const char *) key);\n  key_info=DestroyStringInfo(key_info);\n  random_info=DestroyRandomInfo(random_info);\n}\n\nstatic ssize_t DecodePSDPixels(const size_t number_compact_pixels,\n  const unsigned char *compact_pixels,const ssize_t depth,\n  const size_t number_pixels,unsigned char *pixels)\n{\n#define CheckNumberCompactPixels \\\n  if (packets == 0) \\\n    return(i); \\\n  packets--\n\n#define CheckNumberPixels(count) \\\n  if (((ssize_t) i + count) > (ssize_t) number_pixels) \\\n    return(i); \\\n  i+=count\n\n  int\n    pixel;\n\n  register ssize_t\n    i,\n    j;\n\n  size_t\n    length;\n\n  ssize_t\n    packets;\n\n  packets=(ssize_t) number_compact_pixels;\n  for (i=0; (packets > 1) && (i < (ssize_t) number_pixels); )\n  {\n    packets--;\n    length=(size_t) (*compact_pixels++);\n    if (length == 128)\n      continue;\n    if (length > 128)\n      {\n        length=256-length+1;\n        CheckNumberCompactPixels;\n        pixel=(*compact_pixels++);\n        for (j=0; j < (ssize_t) length; j++)\n        {\n          switch (depth)\n          {\n            case 1:\n            {\n              CheckNumberPixels(8);\n              *pixels++=(pixel >> 7) & 0x01 ? 0U : 255U;\n              *pixels++=(pixel >> 6) & 0x01 ? 0U : 255U;\n              *pixels++=(pixel >> 5) & 0x01 ? 0U : 255U;\n              *pixels++=(pixel >> 4) & 0x01 ? 0U : 255U;\n              *pixels++=(pixel >> 3) & 0x01 ? 0U : 255U;\n              *pixels++=(pixel >> 2) & 0x01 ? 0U : 255U;\n              *pixels++=(pixel >> 1) & 0x01 ? 0U : 255U;\n              *pixels++=(pixel >> 0) & 0x01 ? 0U : 255U;\n              break;\n            }\n            case 2:\n            {\n              CheckNumberPixels(4);\n              *pixels++=(unsigned char) ((pixel >> 6) & 0x03);\n              *pixels++=(unsigned char) ((pixel >> 4) & 0x03);\n              *pixels++=(unsigned char) ((pixel >> 2) & 0x03);\n              *pixels++=(unsigned char) ((pixel & 0x03) & 0x03);\n              break;\n            }\n            case 4:\n            {\n              CheckNumberPixels(2);\n              *pixels++=(unsigned char) ((pixel >> 4) & 0xff);\n              *pixels++=(unsigned char) ((pixel & 0x0f) & 0xff);\n              break;\n            }\n            default:\n            {\n              CheckNumberPixels(1);\n              *pixels++=(unsigned char) pixel;\n              break;\n            }\n          }\n        }\n        continue;\n      }\n    length++;\n    for (j=0; j < (ssize_t) length; j++)\n    {\n      CheckNumberCompactPixels;\n      switch (depth)\n      {\n        case 1:\n        {\n          CheckNumberPixels(8);\n          *pixels++=(*compact_pixels >> 7) & 0x01 ? 0U : 255U;\n          *pixels++=(*compact_pixels >> 6) & 0x01 ? 0U : 255U;\n          *pixels++=(*compact_pixels >> 5) & 0x01 ? 0U : 255U;\n          *pixels++=(*compact_pixels >> 4) & 0x01 ? 0U : 255U;\n          *pixels++=(*compact_pixels >> 3) & 0x01 ? 0U : 255U;\n          *pixels++=(*compact_pixels >> 2) & 0x01 ? 0U : 255U;\n          *pixels++=(*compact_pixels >> 1) & 0x01 ? 0U : 255U;\n          *pixels++=(*compact_pixels >> 0) & 0x01 ? 0U : 255U;\n          break;\n        }\n        case 2:\n        {\n          CheckNumberPixels(4);\n          *pixels++=(*compact_pixels >> 6) & 0x03;\n          *pixels++=(*compact_pixels >> 4) & 0x03;\n          *pixels++=(*compact_pixels >> 2) & 0x03;\n          *pixels++=(*compact_pixels & 0x03) & 0x03;\n          break;\n        }\n        case 4:\n        {\n          CheckNumberPixels(2);\n          *pixels++=(*compact_pixels >> 4) & 0xff;\n          *pixels++=(*compact_pixels & 0x0f) & 0xff;\n          break;\n        }\n        default:\n        {\n          CheckNumberPixels(1);\n          *pixels++=(*compact_pixels);\n          break;\n        }\n      }\n      compact_pixels++;\n    }\n  }\n  return(i);\n}\n\nstatic inline LayerInfo *DestroyLayerInfo(LayerInfo *layer_info,\n  const ssize_t number_layers)\n{\n  ssize_t\n    i;\n\n  for (i=0; i<number_layers; i++)\n  {\n    if (layer_info[i].image != (Image *) NULL)\n      layer_info[i].image=DestroyImage(layer_info[i].image);\n    if (layer_info[i].mask.image != (Image *) NULL)\n      layer_info[i].mask.image=DestroyImage(layer_info[i].mask.image);\n    if (layer_info[i].info != (StringInfo *) NULL)\n      layer_info[i].info=DestroyStringInfo(layer_info[i].info);\n  }\n\n  return (LayerInfo *) RelinquishMagickMemory(layer_info);\n}\n\nstatic inline size_t GetPSDPacketSize(Image *image)\n{\n  if (image->storage_class == PseudoClass)\n    {\n      if (image->colors > 256)\n        return(2);\n      else if (image->depth > 8)\n        return(2);\n    }\n  else\n    if (image->depth > 8)\n      return(2);\n\n  return(1);\n}\n\nstatic inline MagickSizeType GetPSDSize(const PSDInfo *psd_info,Image *image)\n{\n  if (psd_info->version == 1)\n    return((MagickSizeType) ReadBlobLong(image));\n  return((MagickSizeType) ReadBlobLongLong(image));\n}\n\nstatic inline size_t GetPSDRowSize(Image *image)\n{\n  if (image->depth == 1)\n    return(((image->columns+7)/8)*GetPSDPacketSize(image));\n  else\n    return(image->columns*GetPSDPacketSize(image));\n}\n\nstatic const char *ModeToString(PSDImageType type)\n{\n  switch (type)\n  {\n    case BitmapMode: return \"Bitmap\";\n    case GrayscaleMode: return \"Grayscale\";\n    case IndexedMode: return \"Indexed\";\n    case RGBMode: return \"RGB\";\n    case CMYKMode:  return \"CMYK\";\n    case MultichannelMode: return \"Multichannel\";\n    case DuotoneMode: return \"Duotone\";\n    case LabMode: return \"L*A*B\";\n    default: return \"unknown\";\n  }\n}\n\nstatic MagickBooleanType NegateCMYK(Image *image,ExceptionInfo *exception)\n{\n  ChannelType\n    channel_mask;\n\n  MagickBooleanType\n    status;\n\n  channel_mask=SetImageChannelMask(image,(ChannelType)(AllChannels &~\n    AlphaChannel));\n  status=NegateImage(image,MagickFalse,exception);\n  (void) SetImageChannelMask(image,channel_mask);\n  return(status);\n}\n\nstatic void ParseImageResourceBlocks(Image *image,\n  const unsigned char *blocks,size_t length,\n  MagickBooleanType *has_merged_image,ExceptionInfo *exception)\n{\n  const unsigned char\n    *p;\n\n  StringInfo\n    *profile;\n\n  unsigned int\n    count,\n    long_sans;\n\n  unsigned short\n    id,\n    short_sans;\n\n  if (length < 16)\n    return;\n  profile=BlobToStringInfo((const unsigned char *) NULL,length);\n  SetStringInfoDatum(profile,blocks);\n  (void) SetImageProfile(image,\"8bim\",profile,exception);\n  profile=DestroyStringInfo(profile);\n  for (p=blocks; (p >= blocks) && (p < (blocks+length-16)); )\n  {\n    if (LocaleNCompare((const char *) p,\"8BIM\",4) != 0)\n      break;\n    p=PushLongPixel(MSBEndian,p,&long_sans);\n    p=PushShortPixel(MSBEndian,p,&id);\n    p=PushShortPixel(MSBEndian,p,&short_sans);\n    p=PushLongPixel(MSBEndian,p,&count);\n    if ((p+count) > (blocks+length-16))\n      return;\n    switch (id)\n    {\n      case 0x03ed:\n      {\n        char\n          value[MagickPathExtent];\n\n        unsigned short\n          resolution;\n\n        /*\n          Resolution info.\n        */\n        p=PushShortPixel(MSBEndian,p,&resolution);\n        image->resolution.x=(double) resolution;\n        (void) FormatLocaleString(value,MagickPathExtent,\"%g\",image->resolution.x);\n        (void) SetImageProperty(image,\"tiff:XResolution\",value,exception);\n        p=PushShortPixel(MSBEndian,p,&short_sans);\n        p=PushShortPixel(MSBEndian,p,&short_sans);\n        p=PushShortPixel(MSBEndian,p,&short_sans);\n        p=PushShortPixel(MSBEndian,p,&resolution);\n        image->resolution.y=(double) resolution;\n        (void) FormatLocaleString(value,MagickPathExtent,\"%g\",image->resolution.y);\n        (void) SetImageProperty(image,\"tiff:YResolution\",value,exception);\n        p=PushShortPixel(MSBEndian,p,&short_sans);\n        p=PushShortPixel(MSBEndian,p,&short_sans);\n        p=PushShortPixel(MSBEndian,p,&short_sans);\n        image->units=PixelsPerInchResolution;\n        break;\n      }\n      case 0x0421:\n      {\n        if (*(p+4) == 0)\n          *has_merged_image=MagickFalse;\n        p+=count;\n        break;\n      }\n      default:\n      {\n        p+=count;\n        break;\n      }\n    }\n    if ((count & 0x01) != 0)\n      p++;\n  }\n  return;\n}\n\nstatic CompositeOperator PSDBlendModeToCompositeOperator(const char *mode)\n{\n  if (mode == (const char *) NULL)\n    return(OverCompositeOp);\n  if (LocaleNCompare(mode,\"norm\",4) == 0)\n    return(OverCompositeOp);\n  if (LocaleNCompare(mode,\"mul \",4) == 0)\n    return(MultiplyCompositeOp);\n  if (LocaleNCompare(mode,\"diss\",4) == 0)\n    return(DissolveCompositeOp);\n  if (LocaleNCompare(mode,\"diff\",4) == 0)\n    return(DifferenceCompositeOp);\n  if (LocaleNCompare(mode,\"dark\",4) == 0)\n    return(DarkenCompositeOp);\n  if (LocaleNCompare(mode,\"lite\",4) == 0)\n    return(LightenCompositeOp);\n  if (LocaleNCompare(mode,\"hue \",4) == 0)\n    return(HueCompositeOp);\n  if (LocaleNCompare(mode,\"sat \",4) == 0)\n    return(SaturateCompositeOp);\n  if (LocaleNCompare(mode,\"colr\",4) == 0)\n    return(ColorizeCompositeOp);\n  if (LocaleNCompare(mode,\"lum \",4) == 0)\n    return(LuminizeCompositeOp);\n  if (LocaleNCompare(mode,\"scrn\",4) == 0)\n    return(ScreenCompositeOp);\n  if (LocaleNCompare(mode,\"over\",4) == 0)\n    return(OverlayCompositeOp);\n  if (LocaleNCompare(mode,\"hLit\",4) == 0)\n    return(HardLightCompositeOp);\n  if (LocaleNCompare(mode,\"sLit\",4) == 0)\n    return(SoftLightCompositeOp);\n  if (LocaleNCompare(mode,\"smud\",4) == 0)\n    return(ExclusionCompositeOp);\n  if (LocaleNCompare(mode,\"div \",4) == 0)\n    return(ColorDodgeCompositeOp);\n  if (LocaleNCompare(mode,\"idiv\",4) == 0)\n    return(ColorBurnCompositeOp);\n  if (LocaleNCompare(mode,\"lbrn\",4) == 0)\n    return(LinearBurnCompositeOp);\n  if (LocaleNCompare(mode,\"lddg\",4) == 0)\n    return(LinearDodgeCompositeOp);\n  if (LocaleNCompare(mode,\"lLit\",4) == 0)\n    return(LinearLightCompositeOp);\n  if (LocaleNCompare(mode,\"vLit\",4) == 0)\n    return(VividLightCompositeOp);\n  if (LocaleNCompare(mode,\"pLit\",4) == 0)\n    return(PinLightCompositeOp);\n  if (LocaleNCompare(mode,\"hMix\",4) == 0)\n    return(HardMixCompositeOp);\n  return(OverCompositeOp);\n}\n\nstatic inline void ReversePSDString(Image *image,char *p,size_t length)\n{\n  char\n    *q;\n\n  if (image->endian == MSBEndian)\n    return;\n\n  q=p+length;\n  for(--q; p < q; ++p, --q)\n  {\n    *p = *p ^ *q,\n    *q = *p ^ *q,\n    *p = *p ^ *q;\n  }\n}\n\nstatic inline void SetPSDPixel(Image *image,const size_t channels,\n  const ssize_t type,const size_t packet_size,const Quantum pixel,Quantum *q,\n  ExceptionInfo *exception)\n{\n  if (image->storage_class == PseudoClass)\n    {\n      if (packet_size == 1)\n        SetPixelIndex(image,ScaleQuantumToChar(pixel),q);\n      else\n        SetPixelIndex(image,ScaleQuantumToShort(pixel),q);\n      SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n        ConstrainColormapIndex(image,GetPixelIndex(image,q),exception),q);\n      return;\n    }\n  switch (type)\n  {\n    case -1:\n    {\n      SetPixelAlpha(image, pixel,q);\n      break;\n    }\n    case -2:\n    case 0:\n    {\n      SetPixelRed(image,pixel,q);\n      if (channels == 1 || type == -2)\n        SetPixelGray(image,pixel,q);\n      break;\n    }\n    case 1:\n    {\n      if (image->storage_class == PseudoClass)\n        SetPixelAlpha(image,pixel,q);\n      else\n        SetPixelGreen(image,pixel,q);\n      break;\n    }\n    case 2:\n    {\n      if (image->storage_class == PseudoClass)\n        SetPixelAlpha(image,pixel,q);\n      else\n        SetPixelBlue(image,pixel,q);\n      break;\n    }\n    case 3:\n    {\n      if (image->colorspace == CMYKColorspace)\n        SetPixelBlack(image,pixel,q);\n      else\n        if (image->alpha_trait != UndefinedPixelTrait)\n          SetPixelAlpha(image,pixel,q);\n      break;\n    }\n    case 4:\n    {\n      if ((IssRGBCompatibleColorspace(image->colorspace) != MagickFalse) &&\n          (channels > 3))\n        break;\n      if (image->alpha_trait != UndefinedPixelTrait)\n        SetPixelAlpha(image,pixel,q);\n      break;\n    }\n  }\n}\n\nstatic MagickBooleanType ReadPSDChannelPixels(Image *image,\n  const size_t channels,const size_t row,const ssize_t type,\n  const unsigned char *pixels,ExceptionInfo *exception)\n{\n  Quantum\n    pixel;\n\n  register const unsigned char\n    *p;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    x;\n\n  size_t\n    packet_size;\n\n  unsigned short\n    nibble;\n\n  p=pixels;\n  q=GetAuthenticPixels(image,0,row,image->columns,1,exception);\n  if (q == (Quantum *) NULL)\n    return MagickFalse;\n  packet_size=GetPSDPacketSize(image);\n  for (x=0; x < (ssize_t) image->columns; x++)\n  {\n    if (packet_size == 1)\n      pixel=ScaleCharToQuantum(*p++);\n    else\n      {\n        p=PushShortPixel(MSBEndian,p,&nibble);\n        pixel=ScaleShortToQuantum(nibble);\n      }\n    if (image->depth > 1)\n      {\n        SetPSDPixel(image,channels,type,packet_size,pixel,q,exception);\n        q+=GetPixelChannels(image);\n      }\n    else\n      {\n        ssize_t\n          bit,\n          number_bits;\n      \n        number_bits=image->columns-x;\n        if (number_bits > 8)\n          number_bits=8;\n        for (bit = 0; bit < number_bits; bit++)\n        {\n          SetPSDPixel(image,channels,type,packet_size,(((unsigned char) pixel)\n            & (0x01 << (7-bit))) != 0 ? 0 : QuantumRange,q,exception);\n          q+=GetPixelChannels(image);\n          x++;\n        }\n        if (x != (ssize_t) image->columns)\n          x--;\n        continue;\n      }\n  }\n  return(SyncAuthenticPixels(image,exception));\n}\n\nstatic MagickBooleanType ReadPSDChannelRaw(Image *image,const size_t channels,\n  const ssize_t type,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  size_t\n    count,\n    row_size;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *pixels;\n\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n       \"      layer data is RAW\");\n\n  row_size=GetPSDRowSize(image);\n  pixels=(unsigned char *) AcquireQuantumMemory(row_size,sizeof(*pixels));\n  if (pixels == (unsigned char *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n\n  status=MagickTrue;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    status=MagickFalse;\n\n    count=ReadBlob(image,row_size,pixels);\n    if (count != row_size)\n      break;\n\n    status=ReadPSDChannelPixels(image,channels,y,type,pixels,exception);\n    if (status == MagickFalse)\n      break;\n  }\n\n  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  return(status);\n}\n\nstatic inline MagickOffsetType *ReadPSDRLESizes(Image *image,\n  const PSDInfo *psd_info,const size_t size)\n{\n  MagickOffsetType\n    *sizes;\n\n  ssize_t\n    y;\n\n  sizes=(MagickOffsetType *) AcquireQuantumMemory(size,sizeof(*sizes));\n  if(sizes != (MagickOffsetType *) NULL)\n    {\n      for (y=0; y < (ssize_t) size; y++)\n      {\n        if (psd_info->version == 1)\n          sizes[y]=(MagickOffsetType) ReadBlobShort(image);\n        else\n          sizes[y]=(MagickOffsetType) ReadBlobLong(image);\n      }\n    }\n  return sizes;\n}\n\nstatic MagickBooleanType ReadPSDChannelRLE(Image *image,const PSDInfo *psd_info,\n  const ssize_t type,MagickOffsetType *sizes,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  size_t\n    length,\n    row_size;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *compact_pixels,\n    *pixels;\n\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n       \"      layer data is RLE compressed\");\n\n  row_size=GetPSDRowSize(image);\n  pixels=(unsigned char *) AcquireQuantumMemory(row_size,sizeof(*pixels));\n  if (pixels == (unsigned char *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n\n  length=0;\n  for (y=0; y < (ssize_t) image->rows; y++)\n    if ((MagickOffsetType) length < sizes[y])\n      length=(size_t) sizes[y];\n\n  if (length > row_size + 256) // arbitrary number\n    {\n      pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n      ThrowBinaryException(ResourceLimitError,\"InvalidLength\",\n        image->filename);\n    }\n\n  compact_pixels=(unsigned char *) AcquireQuantumMemory(length,sizeof(*pixels));\n  if (compact_pixels == (unsigned char *) NULL)\n    {\n      pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image->filename);\n    }\n\n  (void) ResetMagickMemory(compact_pixels,0,length*sizeof(*compact_pixels));\n\n  status=MagickTrue;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    status=MagickFalse;\n\n    count=ReadBlob(image,(size_t) sizes[y],compact_pixels);\n    if (count != (ssize_t) sizes[y])\n      break;\n\n    count=DecodePSDPixels((size_t) sizes[y],compact_pixels,\n      (ssize_t) (image->depth == 1 ? 123456 : image->depth),row_size,pixels);\n    if (count != (ssize_t) row_size)\n      break;\n\n    status=ReadPSDChannelPixels(image,psd_info->channels,y,type,pixels,\n      exception);\n    if (status == MagickFalse)\n      break;\n  }\n\n  compact_pixels=(unsigned char *) RelinquishMagickMemory(compact_pixels);\n  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  return(status);\n}\n\n#ifdef MAGICKCORE_ZLIB_DELEGATE\nstatic MagickBooleanType ReadPSDChannelZip(Image *image,const size_t channels,\n  const ssize_t type,const PSDCompressionType compression,\n  const size_t compact_size,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  register unsigned char\n    *p;\n\n  size_t\n    count,\n    length,\n    packet_size,\n    row_size;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *compact_pixels,\n    *pixels;\n\n  z_stream\n    stream;\n\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n       \"      layer data is ZIP compressed\");\n\n  compact_pixels=(unsigned char *) AcquireQuantumMemory(compact_size,\n    sizeof(*compact_pixels));\n  if (compact_pixels == (unsigned char *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n\n  packet_size=GetPSDPacketSize(image);\n  row_size=image->columns*packet_size;\n  count=image->rows*row_size;\n\n  pixels=(unsigned char *) AcquireQuantumMemory(count,sizeof(*pixels));\n  if (pixels == (unsigned char *) NULL)\n    {\n      compact_pixels=(unsigned char *) RelinquishMagickMemory(compact_pixels);\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image->filename);\n    }\n\n  ResetMagickMemory(&stream,0,sizeof(stream));\n  stream.data_type=Z_BINARY;\n  (void) ReadBlob(image,compact_size,compact_pixels);\n\n  stream.next_in=(Bytef *)compact_pixels;\n  stream.avail_in=(uInt) compact_size;\n  stream.next_out=(Bytef *)pixels;\n  stream.avail_out=(uInt) count;\n\n  if (inflateInit(&stream) == Z_OK)\n    {\n      int\n        ret;\n\n      while (stream.avail_out > 0)\n      {\n        ret=inflate(&stream,Z_SYNC_FLUSH);\n        if ((ret != Z_OK) && (ret != Z_STREAM_END))\n          {\n            compact_pixels=(unsigned char *) RelinquishMagickMemory(\n              compact_pixels);\n            pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n            return(MagickFalse);\n          }\n      }\n    }\n\n  if (compression == ZipWithPrediction)\n  {\n     p=pixels;\n     while (count > 0)\n     {\n       length=image->columns;\n       while (--length)\n       {\n         if (packet_size == 2)\n           {\n             p[2]+=p[0]+((p[1]+p[3]) >> 8);\n             p[3]+=p[1];\n           }\n         else\n          *(p+1)+=*p;\n         p+=packet_size;\n       }\n       p+=packet_size;\n       count-=row_size;\n     }\n  }\n\n  status=MagickTrue;\n  p=pixels;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    status=ReadPSDChannelPixels(image,channels,y,type,p,exception);\n    if (status == MagickFalse)\n      break;\n\n    p+=row_size;\n  }\n\n  compact_pixels=(unsigned char *) RelinquishMagickMemory(compact_pixels);\n  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  return(status);\n}\n#endif\n\nstatic MagickBooleanType ReadPSDChannel(Image *image,\n  const ImageInfo *image_info,const PSDInfo *psd_info,LayerInfo* layer_info,\n  const size_t channel,const PSDCompressionType compression,\n  ExceptionInfo *exception)\n{\n  Image\n    *channel_image,\n    *mask;\n\n  MagickOffsetType\n    offset;\n\n  MagickBooleanType\n    status;\n\n  channel_image=image;\n  mask=(Image *) NULL;\n  if (layer_info->channel_info[channel].type < -1)\n    {\n      const char\n        *option;\n      /*\n        Ignore mask that is not a user supplied layer mask, if the mask is\n        disabled or if the flags have unsupported values.\n      */\n      option=GetImageOption(image_info,\"psd:preserve-opacity-mask\");\n      if ((layer_info->channel_info[channel].type != -2) ||\n          (layer_info->mask.flags > 2) || ((layer_info->mask.flags & 0x02) &&\n           (IsStringTrue(option) == MagickFalse)))\n      {\n        SeekBlob(image,layer_info->channel_info[channel].size-2,SEEK_CUR);\n        return(MagickTrue);\n      }\n      mask=CloneImage(image,layer_info->mask.page.width,\n        layer_info->mask.page.height,MagickFalse,exception);\n      SetImageType(mask,GrayscaleType,exception);\n      channel_image=mask;\n    }\n\n  offset=TellBlob(image);\n  status=MagickTrue;\n  switch(compression)\n  {\n    case Raw:\n      status=ReadPSDChannelRaw(channel_image,psd_info->channels,\n        layer_info->channel_info[channel].type,exception);\n      break;\n    case RLE:\n      {\n        MagickOffsetType\n          *sizes;\n\n        sizes=ReadPSDRLESizes(channel_image,psd_info,channel_image->rows);\n        if (sizes == (MagickOffsetType *) NULL)\n          ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n            image->filename);\n        status=ReadPSDChannelRLE(channel_image,psd_info,\n          layer_info->channel_info[channel].type,sizes,exception);\n        sizes=(MagickOffsetType *) RelinquishMagickMemory(sizes);\n      }\n      break;\n    case ZipWithPrediction:\n    case ZipWithoutPrediction:\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n      status=ReadPSDChannelZip(channel_image,layer_info->channels,\n        layer_info->channel_info[channel].type,compression,\n        layer_info->channel_info[channel].size-2,exception);\n#else\n      (void) ThrowMagickException(exception,GetMagickModule(),\n          MissingDelegateWarning,\"DelegateLibrarySupportNotBuiltIn\",\n            \"'%s' (ZLIB)\",image->filename);\n#endif\n      break;\n    default:\n      (void) ThrowMagickException(exception,GetMagickModule(),TypeWarning,\n        \"CompressionNotSupported\",\"'%.20g'\",(double) compression);\n      break;\n  }\n\n  SeekBlob(image,offset+layer_info->channel_info[channel].size-2,SEEK_SET);\n  if (status == MagickFalse)\n    {\n      if (mask != (Image *) NULL)\n        DestroyImage(mask);\n      ThrowBinaryException(CoderError,\"UnableToDecompressImage\",\n        image->filename);\n    }\n  layer_info->mask.image=mask;\n  return(status);\n}\n\nstatic MagickBooleanType ReadPSDLayer(Image *image,const ImageInfo *image_info,\n  const PSDInfo *psd_info,LayerInfo* layer_info,ExceptionInfo *exception)\n{\n  char\n    message[MagickPathExtent];\n\n  MagickBooleanType\n    status;\n\n  PSDCompressionType\n    compression;\n\n  ssize_t\n    j;\n\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    setting up new layer image\");\n  if (psd_info->mode != IndexedMode)\n    (void) SetImageBackgroundColor(layer_info->image,exception);\n  layer_info->image->compose=PSDBlendModeToCompositeOperator(\n    layer_info->blendkey);\n  if (layer_info->visible == MagickFalse)\n    layer_info->image->compose=NoCompositeOp;\n  if (psd_info->mode == CMYKMode)\n    SetImageColorspace(layer_info->image,CMYKColorspace,exception);\n  else if ((psd_info->mode == BitmapMode) || (psd_info->mode == DuotoneMode) ||\n           (psd_info->mode == GrayscaleMode))\n    SetImageColorspace(layer_info->image,GRAYColorspace,exception);\n  /*\n    Set up some hidden attributes for folks that need them.\n  */\n  (void) FormatLocaleString(message,MagickPathExtent,\"%.20g\",\n    (double) layer_info->page.x);\n  (void) SetImageArtifact(layer_info->image,\"psd:layer.x\",message);\n  (void) FormatLocaleString(message,MagickPathExtent,\"%.20g\",\n    (double) layer_info->page.y);\n  (void) SetImageArtifact(layer_info->image,\"psd:layer.y\",message);\n  (void) FormatLocaleString(message,MagickPathExtent,\"%.20g\",(double)\n    layer_info->opacity);\n  (void) SetImageArtifact(layer_info->image,\"psd:layer.opacity\",message);\n  (void) SetImageProperty(layer_info->image,\"label\",(char *) layer_info->name,\n    exception);\n\n  status=MagickTrue;\n  for (j=0; j < (ssize_t) layer_info->channels; j++)\n  {\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    reading data for channel %.20g\",(double) j);\n\n    compression=(PSDCompressionType) ReadBlobShort(layer_info->image);\n    layer_info->image->compression=ConvertPSDCompression(compression);\n    if (layer_info->channel_info[j].type == -1)\n      layer_info->image->alpha_trait=BlendPixelTrait;\n\n    status=ReadPSDChannel(layer_info->image,image_info,psd_info,layer_info,j,\n      compression,exception);\n\n    if (status == MagickFalse)\n      break;\n  }\n\n  if (status != MagickFalse)\n    status=ApplyPSDLayerOpacity(layer_info->image,layer_info->opacity,\n      MagickFalse,exception);\n\n  if ((status != MagickFalse) &&\n      (layer_info->image->colorspace == CMYKColorspace))\n    status=NegateCMYK(layer_info->image,exception);\n\n  if ((status != MagickFalse) && (layer_info->mask.image != (Image *) NULL))\n    {\n      const char\n        *option;\n      \n      layer_info->mask.image->page.x=layer_info->mask.page.x;\n      layer_info->mask.image->page.y=layer_info->mask.page.y;\n      /* Do not composite the mask when it is disabled */\n      if ((layer_info->mask.flags & 0x02) == 0x02)\n        layer_info->mask.image->compose=NoCompositeOp;\n      else\n        status=ApplyPSDOpacityMask(layer_info->image,layer_info->mask.image,\n          layer_info->mask.background == 0 ? 0 : QuantumRange,MagickFalse,\n          exception);\n      option=GetImageOption(image_info,\"psd:preserve-opacity-mask\");\n      if (IsStringTrue(option) != MagickFalse)\n        PreservePSDOpacityMask(image,layer_info,exception);\n      layer_info->mask.image=DestroyImage(layer_info->mask.image);\n    }\n\n  return(status);\n}\n\nModuleExport MagickBooleanType ReadPSDLayers(Image *image,\n  const ImageInfo *image_info,const PSDInfo *psd_info,\n  const MagickBooleanType skip_layers,ExceptionInfo *exception)\n{\n  char\n    type[4];\n\n  LayerInfo\n    *layer_info;\n\n  MagickSizeType\n    size;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    count,\n    j,\n    number_layers;\n\n  size=GetPSDSize(psd_info,image);\n  if (size == 0)\n    {\n      /*\n        Skip layers & masks.\n      */\n      (void) ReadBlobLong(image);\n      count=ReadBlob(image,4,(unsigned char *) type);\n      ReversePSDString(image,type,4);\n      status=MagickFalse;\n      if ((count == 0) || (LocaleNCompare(type,\"8BIM\",4) != 0))\n        return(MagickTrue);\n      else\n        {\n          count=ReadBlob(image,4,(unsigned char *) type);\n          ReversePSDString(image,type,4);\n          if ((count != 0) && (LocaleNCompare(type,\"Lr16\",4) == 0))\n            size=GetPSDSize(psd_info,image);\n          else\n            return(MagickTrue);\n        }\n    }\n  status=MagickTrue;\n  if (size != 0)\n    {\n      layer_info=(LayerInfo *) NULL;\n      number_layers=(short) ReadBlobShort(image);\n\n      if (number_layers < 0)\n        {\n          /*\n            The first alpha channel in the merged result contains the\n            transparency data for the merged result.\n          */\n          number_layers=MagickAbsoluteValue(number_layers);\n          if (image->debug != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  negative layer count corrected for\");\n          image->alpha_trait=BlendPixelTrait;\n        }\n\n      /*\n        We only need to know if the image has an alpha channel\n      */\n      if (skip_layers != MagickFalse)\n        return(MagickTrue);\n\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  image contains %.20g layers\",(double) number_layers);\n\n      if (number_layers == 0)\n        ThrowBinaryException(CorruptImageError,\"InvalidNumberOfLayers\",\n          image->filename);\n\n      layer_info=(LayerInfo *) AcquireQuantumMemory((size_t) number_layers,\n        sizeof(*layer_info));\n      if (layer_info == (LayerInfo *) NULL)\n        {\n          if (image->debug != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  allocation of LayerInfo failed\");\n          ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n            image->filename);\n        }\n      (void) ResetMagickMemory(layer_info,0,(size_t) number_layers*\n        sizeof(*layer_info));\n\n      for (i=0; i < number_layers; i++)\n      {\n        ssize_t\n          x,\n          y;\n\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  reading layer #%.20g\",(double) i+1);\n        layer_info[i].page.y=ReadBlobSignedLong(image);\n        layer_info[i].page.x=ReadBlobSignedLong(image);\n        y=ReadBlobSignedLong(image);\n        x=ReadBlobSignedLong(image);\n        layer_info[i].page.width=(size_t) (x-layer_info[i].page.x);\n        layer_info[i].page.height=(size_t) (y-layer_info[i].page.y);\n        layer_info[i].channels=ReadBlobShort(image);\n        if (layer_info[i].channels > MaxPSDChannels)\n          {\n            layer_info=DestroyLayerInfo(layer_info,number_layers);\n            ThrowBinaryException(CorruptImageError,\"MaximumChannelsExceeded\",\n              image->filename);\n          }\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    offset(%.20g,%.20g), size(%.20g,%.20g), channels=%.20g\",\n            (double) layer_info[i].page.x,(double) layer_info[i].page.y,\n            (double) layer_info[i].page.height,(double)\n            layer_info[i].page.width,(double) layer_info[i].channels);\n        for (j=0; j < (ssize_t) layer_info[i].channels; j++)\n        {\n          layer_info[i].channel_info[j].type=(short) ReadBlobShort(image);\n          layer_info[i].channel_info[j].size=(size_t) GetPSDSize(psd_info,\n            image);\n          if (image->debug != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    channel[%.20g]: type=%.20g, size=%.20g\",(double) j,\n              (double) layer_info[i].channel_info[j].type,\n              (double) layer_info[i].channel_info[j].size);\n        }\n        count=ReadBlob(image,4,(unsigned char *) type);\n        ReversePSDString(image,type,4);\n        if ((count == 0) || (LocaleNCompare(type,\"8BIM\",4) != 0))\n          {\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  layer type was %.4s instead of 8BIM\", type);\n            layer_info=DestroyLayerInfo(layer_info,number_layers);\n            ThrowBinaryException(CorruptImageError,\"ImproperImageHeader\",\n              image->filename);\n          }\n        count=ReadBlob(image,4,(unsigned char *) layer_info[i].blendkey);\n        ReversePSDString(image,layer_info[i].blendkey,4);\n        layer_info[i].opacity=(Quantum) ScaleCharToQuantum((unsigned char)\n          ReadBlobByte(image));\n        layer_info[i].clipping=(unsigned char) ReadBlobByte(image);\n        layer_info[i].flags=(unsigned char) ReadBlobByte(image);\n        layer_info[i].visible=!(layer_info[i].flags & 0x02);\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"   blend=%.4s, opacity=%.20g, clipping=%s, flags=%d, visible=%s\",\n            layer_info[i].blendkey,(double) layer_info[i].opacity,\n            layer_info[i].clipping ? \"true\" : \"false\",layer_info[i].flags,\n            layer_info[i].visible ? \"true\" : \"false\");\n        (void) ReadBlobByte(image);  /* filler */\n\n        size=ReadBlobLong(image);\n        if (size != 0)\n          {\n            MagickSizeType\n              combined_length,\n              length;\n\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    layer contains additional info\");\n            length=ReadBlobLong(image);\n            combined_length=length+4;\n            if (length != 0)\n              {\n                /*\n                  Layer mask info.\n                */\n                layer_info[i].mask.page.y=ReadBlobSignedLong(image);\n                layer_info[i].mask.page.x=ReadBlobSignedLong(image);\n                layer_info[i].mask.page.height=(size_t) (ReadBlobLong(image)-\n                  layer_info[i].mask.page.y);\n                layer_info[i].mask.page.width=(size_t) (ReadBlobLong(image)-\n                  layer_info[i].mask.page.x);\n                layer_info[i].mask.background=(unsigned char) ReadBlobByte(\n                  image);\n                layer_info[i].mask.flags=(unsigned char) ReadBlobByte(image);\n                if (!(layer_info[i].mask.flags & 0x01))\n                  {\n                    layer_info[i].mask.page.y=layer_info[i].mask.page.y-\n                      layer_info[i].page.y;\n                    layer_info[i].mask.page.x=layer_info[i].mask.page.x-\n                      layer_info[i].page.x;\n                  }\n                if (image->debug != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"      layer mask: offset(%.20g,%.20g), size(%.20g,%.20g), length=%.20g\",\n                    (double) layer_info[i].mask.page.x,(double) \n                    layer_info[i].mask.page.y,(double) layer_info[i].mask.page.width,\n                    (double) layer_info[i].mask.page.height,(double)\n                    ((MagickOffsetType) length)-18);\n                /*\n                  Skip over the rest of the layer mask information.\n                */\n                if (DiscardBlobBytes(image,(MagickSizeType) (length-18)) == MagickFalse)\n                  {\n                    layer_info=DestroyLayerInfo(layer_info,number_layers);\n                    ThrowBinaryException(CorruptImageError,\"UnexpectedEndOfFile\",\n                      image->filename);\n                  }\n              }\n            length=ReadBlobLong(image);\n            combined_length+=length+4;\n            if (length != 0)\n              {\n                /*\n                  Layer blending ranges info.\n                */\n                if (image->debug != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"      layer blending ranges: length=%.20g\",(double)\n                    ((MagickOffsetType) length));\n                /*\n                  We read it, but don't use it...\n                */\n                for (j=0; j < (ssize_t) length; j+=8)\n                {\n                  size_t blend_source=ReadBlobLong(image);\n                  size_t blend_dest=ReadBlobLong(image);\n                  if (image->debug != MagickFalse)\n                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                      \"        source(%x), dest(%x)\",(unsigned int)\n                      blend_source,(unsigned int) blend_dest);\n                }\n              }\n            /*\n              Layer name.\n            */\n            length=(MagickSizeType) (unsigned char) ReadBlobByte(image);\n            combined_length+=length+1;\n            if (length > 0)\n              (void) ReadBlob(image,(size_t) length++,layer_info[i].name);\n            layer_info[i].name[length]='\\0';\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"      layer name: %s\",layer_info[i].name);\n            if ((length % 4) != 0)\n              {\n                length=4-(length % 4);\n                combined_length+=length;\n                /* Skip over the padding of the layer name */\n                if (DiscardBlobBytes(image,length) == MagickFalse)\n                  {\n                    layer_info=DestroyLayerInfo(layer_info,number_layers);\n                    ThrowBinaryException(CorruptImageError,\n                      \"UnexpectedEndOfFile\",image->filename);\n                  }\n              }\n            length=(MagickSizeType) size-combined_length;\n            if (length > 0)\n              {\n                unsigned char\n                  *info;\n\n                layer_info[i].info=AcquireStringInfo((const size_t) length);\n                info=GetStringInfoDatum(layer_info[i].info);\n                (void) ReadBlob(image,(const size_t) length,info);\n              }\n          }\n      }\n\n      for (i=0; i < number_layers; i++)\n      {\n        if ((layer_info[i].page.width == 0) ||\n              (layer_info[i].page.height == 0))\n          {\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"      layer data is empty\");\n            if (layer_info[i].info != (StringInfo *) NULL)\n              layer_info[i].info=DestroyStringInfo(layer_info[i].info);\n            continue;\n          }\n\n        /*\n          Allocate layered image.\n        */\n        layer_info[i].image=CloneImage(image,layer_info[i].page.width,\n          layer_info[i].page.height,MagickFalse,exception);\n        if (layer_info[i].image == (Image *) NULL)\n          {\n            layer_info=DestroyLayerInfo(layer_info,number_layers);\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  allocation of image for layer %.20g failed\",(double) i);\n            ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n              image->filename);\n          }\n\n        if (layer_info[i].info != (StringInfo *) NULL)\n          {\n            (void) SetImageProfile(layer_info[i].image,\"psd:additional-info\",\n              layer_info[i].info,exception);\n            layer_info[i].info=DestroyStringInfo(layer_info[i].info);\n          }\n      }\n\n      if (image_info->ping == MagickFalse)\n        {\n          for (i=0; i < number_layers; i++)\n          {\n            if (layer_info[i].image == (Image *) NULL)\n              {\n                for (j=0; j < layer_info[i].channels; j++)\n                {\n                  if (DiscardBlobBytes(image,(MagickSizeType)\n                      layer_info[i].channel_info[j].size) == MagickFalse)\n                    {\n                      layer_info=DestroyLayerInfo(layer_info,number_layers);\n                      ThrowBinaryException(CorruptImageError,\n                        \"UnexpectedEndOfFile\",image->filename);\n                    }\n                }\n                continue;\n              }\n\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  reading data for layer %.20g\",(double) i);\n\n            status=ReadPSDLayer(image,image_info,psd_info,&layer_info[i],\n              exception);\n            if (status == MagickFalse)\n              break;\n\n            status=SetImageProgress(image,LoadImagesTag,i,(MagickSizeType)\n              number_layers);\n            if (status == MagickFalse)\n              break;\n          }\n        }\n\n      if (status != MagickFalse)\n        {\n          for (i=0; i < number_layers; i++)\n          {\n            if (layer_info[i].image == (Image *) NULL)\n              {\n                for (j=i; j < number_layers - 1; j++)\n                  layer_info[j] = layer_info[j+1];\n                number_layers--;\n                i--;\n              }\n          }\n\n          if (number_layers > 0)\n            {\n              for (i=0; i < number_layers; i++)\n              {\n                if (i > 0)\n                  layer_info[i].image->previous=layer_info[i-1].image;\n                if (i < (number_layers-1))\n                  layer_info[i].image->next=layer_info[i+1].image;\n                layer_info[i].image->page=layer_info[i].page;\n              }\n              image->next=layer_info[0].image;\n              layer_info[0].image->previous=image;\n            }\n          layer_info=(LayerInfo *) RelinquishMagickMemory(layer_info);\n        }\n      else\n        layer_info=DestroyLayerInfo(layer_info,number_layers);\n    }\n\n  return(status);\n}\n\nstatic MagickBooleanType ReadPSDMergedImage(const ImageInfo *image_info,\n  Image *image,const PSDInfo *psd_info,ExceptionInfo *exception)\n{\n  MagickOffsetType\n    *sizes;\n\n  MagickBooleanType\n    status;\n\n  PSDCompressionType\n    compression;\n\n  register ssize_t\n    i;\n\n  compression=(PSDCompressionType) ReadBlobMSBShort(image);\n  image->compression=ConvertPSDCompression(compression);\n\n  if (compression != Raw && compression != RLE)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        TypeWarning,\"CompressionNotSupported\",\"'%.20g'\",(double) compression);\n      return(MagickFalse);\n    }\n\n  sizes=(MagickOffsetType *) NULL;\n  if (compression == RLE)\n    {\n      sizes=ReadPSDRLESizes(image,psd_info,image->rows*psd_info->channels);\n      if (sizes == (MagickOffsetType *) NULL)\n        ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n          image->filename);\n    }\n\n  status=MagickTrue;\n  for (i=0; i < (ssize_t) psd_info->channels; i++)\n  {\n    if (compression == RLE)\n      status=ReadPSDChannelRLE(image,psd_info,i,sizes+(i*image->rows),\n        exception);\n    else\n      status=ReadPSDChannelRaw(image,psd_info->channels,i,exception);\n\n    if (status != MagickFalse)\n      status=SetImageProgress(image,LoadImagesTag,i,psd_info->channels);\n\n    if (status == MagickFalse)\n      break;\n  }\n\n  if ((status != MagickFalse) && (image->colorspace == CMYKColorspace))\n    status=NegateCMYK(image,exception);\n\n  if (status != MagickFalse)\n    status=CorrectPSDAlphaBlend(image_info,image,exception);\n\n  sizes=(MagickOffsetType *) RelinquishMagickMemory(sizes);\n\n  return(status);\n}\n\nstatic Image *ReadPSDImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  MagickBooleanType\n    has_merged_image,\n    skip_layers;\n\n  MagickOffsetType\n    offset;\n\n  MagickSizeType\n    length;\n\n  MagickBooleanType\n    status;\n\n  PSDInfo\n    psd_info;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    count;\n\n  unsigned char\n    *data;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read image header.\n  */\n  image->endian=MSBEndian;\n  count=ReadBlob(image,4,(unsigned char *) psd_info.signature);\n  psd_info.version=ReadBlobMSBShort(image);\n  if ((count == 0) || (LocaleNCompare(psd_info.signature,\"8BPS\",4) != 0) ||\n      ((psd_info.version != 1) && (psd_info.version != 2)))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  (void) ReadBlob(image,6,psd_info.reserved);\n  psd_info.channels=ReadBlobMSBShort(image);\n  if (psd_info.channels > MaxPSDChannels)\n    ThrowReaderException(CorruptImageError,\"MaximumChannelsExceeded\");\n  psd_info.rows=ReadBlobMSBLong(image);\n  psd_info.columns=ReadBlobMSBLong(image);\n  if ((psd_info.version == 1) && ((psd_info.rows > 30000) ||\n      (psd_info.columns > 30000)))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  psd_info.depth=ReadBlobMSBShort(image);\n  if ((psd_info.depth != 1) && (psd_info.depth != 8) && (psd_info.depth != 16))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  psd_info.mode=ReadBlobMSBShort(image);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Image is %.20g x %.20g with channels=%.20g, depth=%.20g, mode=%s\",\n      (double) psd_info.columns,(double) psd_info.rows,(double)\n      psd_info.channels,(double) psd_info.depth,ModeToString((PSDImageType)\n      psd_info.mode));\n  /*\n    Initialize image.\n  */\n  image->depth=psd_info.depth;\n  image->columns=psd_info.columns;\n  image->rows=psd_info.rows;\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  if (SetImageBackgroundColor(image,exception) == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if (psd_info.mode == LabMode)\n    SetImageColorspace(image,LabColorspace,exception);\n  if (psd_info.mode == CMYKMode)\n    {\n      SetImageColorspace(image,CMYKColorspace,exception);\n      if (psd_info.channels > 4)\n        SetImageAlphaChannel(image,ActivateAlphaChannel,exception);\n    }\n  else if ((psd_info.mode == BitmapMode) || (psd_info.mode == GrayscaleMode) ||\n           (psd_info.mode == DuotoneMode))\n    {\n      status=AcquireImageColormap(image,psd_info.depth != 16 ? 256 : 65536,\n        exception);\n      if (status == MagickFalse)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  Image colormap allocated\");\n      SetImageColorspace(image,GRAYColorspace,exception);\n      if (psd_info.channels > 1)\n        SetImageAlphaChannel(image,ActivateAlphaChannel,exception);\n    }\n  else\n    if (psd_info.channels > 3)\n      SetImageAlphaChannel(image,ActivateAlphaChannel,exception);\n  /*\n    Read PSD raster colormap only present for indexed and duotone images.\n  */\n  length=ReadBlobMSBLong(image);\n  if (length != 0)\n    {\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  reading colormap\");\n      if (psd_info.mode == DuotoneMode)\n        {\n          /*\n            Duotone image data;  the format of this data is undocumented.\n          */\n          data=(unsigned char *) AcquireQuantumMemory((size_t) length,\n            sizeof(*data));\n          if (data == (unsigned char *) NULL)\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          (void) ReadBlob(image,(size_t) length,data);\n          data=(unsigned char *) RelinquishMagickMemory(data);\n        }\n      else\n        {\n          size_t\n            number_colors;\n\n          /*\n            Read PSD raster colormap.\n          */\n          number_colors=length/3;\n          if (number_colors > 65536)\n            ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n          if (AcquireImageColormap(image,number_colors,exception) == MagickFalse)\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          for (i=0; i < (ssize_t) image->colors; i++)\n            image->colormap[i].red=ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n          for (i=0; i < (ssize_t) image->colors; i++)\n            image->colormap[i].green=ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n          for (i=0; i < (ssize_t) image->colors; i++)\n            image->colormap[i].blue=ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n          image->alpha_trait=UndefinedPixelTrait;\n        }\n    }\n  if ((image->depth == 1) && (image->storage_class != PseudoClass))\n    ThrowReaderException(CorruptImageError, \"ImproperImageHeader\");\n  has_merged_image=MagickTrue;\n  length=ReadBlobMSBLong(image);\n  if (length != 0)\n    {\n      unsigned char\n        *blocks;\n\n      /*\n        Image resources block.\n      */\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  reading image resource blocks - %.20g bytes\",(double)\n          ((MagickOffsetType) length));\n      blocks=(unsigned char *) AcquireQuantumMemory((size_t) length,\n        sizeof(*blocks));\n      if (blocks == (unsigned char *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      count=ReadBlob(image,(size_t) length,blocks);\n      if ((count != (ssize_t) length) || (length < 4) ||\n          (LocaleNCompare((char *) blocks,\"8BIM\",4) != 0))\n        {\n          blocks=(unsigned char *) RelinquishMagickMemory(blocks);\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        }\n      ParseImageResourceBlocks(image,blocks,(size_t) length,&has_merged_image,\n        exception);\n      blocks=(unsigned char *) RelinquishMagickMemory(blocks);\n    }\n  /*\n    Layer and mask block.\n  */\n  length=GetPSDSize(&psd_info,image);\n  if (length == 8)\n    {\n      length=ReadBlobMSBLong(image);\n      length=ReadBlobMSBLong(image);\n    }\n  offset=TellBlob(image);\n  skip_layers=MagickFalse;\n  if ((image_info->number_scenes == 1) && (image_info->scene == 0) &&\n      (has_merged_image != MagickFalse))\n    {\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  read composite only\");\n      skip_layers=MagickTrue;\n    }\n  if (length == 0)\n    {\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  image has no layers\");\n    }\n  else\n    {\n      if (ReadPSDLayers(image,image_info,&psd_info,skip_layers,exception) !=\n          MagickTrue)\n        {\n          (void) CloseBlob(image);\n          image=DestroyImageList(image);\n          return((Image *) NULL);\n        }\n\n      /*\n         Skip the rest of the layer and mask information.\n      */\n      SeekBlob(image,offset+length,SEEK_SET);\n    }\n  /*\n    If we are only \"pinging\" the image, then we're done - so return.\n  */\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(GetFirstImageInList(image));\n    }\n  /*\n    Read the precombined layer, present for PSD < 4 compatibility.\n  */\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  reading the precombined layer\");\n  if ((has_merged_image != MagickFalse) || (GetImageListLength(image) == 1))\n    has_merged_image=(MagickBooleanType) ReadPSDMergedImage(image_info,image,\n      &psd_info,exception);\n  if ((has_merged_image == MagickFalse) && (GetImageListLength(image) == 1) &&\n      (length != 0))\n    {\n      SeekBlob(image,offset,SEEK_SET);\n      status=ReadPSDLayers(image,image_info,&psd_info,MagickFalse,exception);\n      if (status != MagickTrue)\n        {\n          (void) CloseBlob(image);\n          image=DestroyImageList(image);\n          return((Image *) NULL);\n        }\n    }\n  if (has_merged_image == MagickFalse)\n    {\n      Image\n        *merged;\n\n      if (GetImageListLength(image) == 1)\n        ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n      SetImageAlphaChannel(image,TransparentAlphaChannel,exception);\n      image->background_color.alpha=TransparentAlpha;\n      image->background_color.alpha_trait=BlendPixelTrait;\n      merged=MergeImageLayers(image,FlattenLayer,exception);\n      ReplaceImageInList(&image,merged);\n    }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r P S D I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterPSDImage() adds properties for the PSD image format to\n%  the list of supported formats.  The properties include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterPSDImage method is:\n%\n%      size_t RegisterPSDImage(void)\n%\n*/\nModuleExport size_t RegisterPSDImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"PSD\",\"PSB\",\"Adobe Large Document Format\");\n  entry->decoder=(DecodeImageHandler *) ReadPSDImage;\n  entry->encoder=(EncodeImageHandler *) WritePSDImage;\n  entry->magick=(IsImageFormatHandler *) IsPSD;\n  entry->flags|=CoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PSD\",\"PSD\",\"Adobe Photoshop bitmap\");\n  entry->decoder=(DecodeImageHandler *) ReadPSDImage;\n  entry->encoder=(EncodeImageHandler *) WritePSDImage;\n  entry->magick=(IsImageFormatHandler *) IsPSD;\n  entry->flags|=CoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r P S D I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterPSDImage() removes format registrations made by the\n%  PSD module from the list of supported formats.\n%\n%  The format of the UnregisterPSDImage method is:\n%\n%      UnregisterPSDImage(void)\n%\n*/\nModuleExport void UnregisterPSDImage(void)\n{\n  (void) UnregisterMagickInfo(\"PSB\");\n  (void) UnregisterMagickInfo(\"PSD\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e P S D I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WritePSDImage() writes an image in the Adobe Photoshop encoded image format.\n%\n%  The format of the WritePSDImage method is:\n%\n%      MagickBooleanType WritePSDImage(const ImageInfo *image_info,Image *image,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline ssize_t SetPSDOffset(const PSDInfo *psd_info,Image *image,\n  const size_t offset)\n{\n  if (psd_info->version == 1)\n    return(WriteBlobMSBShort(image,(unsigned short) offset));\n  return(WriteBlobMSBLong(image,(unsigned short) offset));\n}\n\nstatic inline ssize_t WritePSDOffset(const PSDInfo *psd_info,Image *image,\n  const MagickSizeType size,const MagickSizeType offset)\n{\n  MagickSizeType\n    current_offset;\n\n  ssize_t\n    result;\n\n  current_offset=TellBlob(image);\n  SeekBlob(image,offset,SEEK_SET);\n  if (psd_info->version == 1)\n    result=WriteBlobMSBShort(image,(unsigned short) size);\n  else\n    result=(WriteBlobMSBLong(image,(unsigned short) size));\n  SeekBlob(image,current_offset,SEEK_SET);\n  return(result);\n}\n\nstatic inline ssize_t SetPSDSize(const PSDInfo *psd_info,Image *image,\n  const MagickSizeType size)\n{\n  if (psd_info->version == 1)\n    return(WriteBlobMSBLong(image,(unsigned int) size));\n  return(WriteBlobMSBLongLong(image,size));\n}\n\nstatic inline ssize_t WritePSDSize(const PSDInfo *psd_info,Image *image,\n  const MagickSizeType size,const MagickSizeType offset)\n{\n  MagickSizeType\n    current_offset;\n\n  ssize_t\n    result;\n\n  current_offset=TellBlob(image);\n  SeekBlob(image,offset,SEEK_SET);\n  if (psd_info->version == 1)\n    result=WriteBlobMSBLong(image,(unsigned int) size);\n  else\n    result=WriteBlobMSBLongLong(image,size);\n  SeekBlob(image,current_offset,SEEK_SET);\n  return(result);\n}\n\nstatic size_t PSDPackbitsEncodeImage(Image *image,const size_t length,\n  const unsigned char *pixels,unsigned char *compact_pixels,\n  ExceptionInfo *exception)\n{\n  int\n    count;\n\n  register ssize_t\n    i,\n    j;\n\n  register unsigned char\n    *q;\n\n  unsigned char\n    *packbits;\n\n  /*\n    Compress pixels with Packbits encoding.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(pixels != (unsigned char *) NULL);\n  assert(compact_pixels != (unsigned char *) NULL);\n  packbits=(unsigned char *) AcquireQuantumMemory(128UL,sizeof(*packbits));\n  if (packbits == (unsigned char *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  q=compact_pixels;\n  for (i=(ssize_t) length; i != 0; )\n  {\n    switch (i)\n    {\n      case 1:\n      {\n        i--;\n        *q++=(unsigned char) 0;\n        *q++=(*pixels);\n        break;\n      }\n      case 2:\n      {\n        i-=2;\n        *q++=(unsigned char) 1;\n        *q++=(*pixels);\n        *q++=pixels[1];\n        break;\n      }\n      case 3:\n      {\n        i-=3;\n        if ((*pixels == *(pixels+1)) && (*(pixels+1) == *(pixels+2)))\n          {\n            *q++=(unsigned char) ((256-3)+1);\n            *q++=(*pixels);\n            break;\n          }\n        *q++=(unsigned char) 2;\n        *q++=(*pixels);\n        *q++=pixels[1];\n        *q++=pixels[2];\n        break;\n      }\n      default:\n      {\n        if ((*pixels == *(pixels+1)) && (*(pixels+1) == *(pixels+2)))\n          {\n            /*\n              Packed run.\n            */\n            count=3;\n            while (((ssize_t) count < i) && (*pixels == *(pixels+count)))\n            {\n              count++;\n              if (count >= 127)\n                break;\n            }\n            i-=count;\n            *q++=(unsigned char) ((256-count)+1);\n            *q++=(*pixels);\n            pixels+=count;\n            break;\n          }\n        /*\n          Literal run.\n        */\n        count=0;\n        while ((*(pixels+count) != *(pixels+count+1)) ||\n               (*(pixels+count+1) != *(pixels+count+2)))\n        {\n          packbits[count+1]=pixels[count];\n          count++;\n          if (((ssize_t) count >= (i-3)) || (count >= 127))\n            break;\n        }\n        i-=count;\n        *packbits=(unsigned char) (count-1);\n        for (j=0; j <= (ssize_t) count; j++)\n          *q++=packbits[j];\n        pixels+=count;\n        break;\n      }\n    }\n  }\n  *q++=(unsigned char) 128;  /* EOD marker */\n  packbits=(unsigned char *) RelinquishMagickMemory(packbits);\n  return((size_t) (q-compact_pixels));\n}\n\nstatic size_t WriteCompressionStart(const PSDInfo *psd_info,Image *image,\n  const Image *next_image,const ssize_t channels)\n{\n  size_t\n    length;\n\n  ssize_t\n    i,\n    y;\n\n  if (next_image->compression == RLECompression)\n    {\n      length=WriteBlobMSBShort(image,RLE);\n      for (i=0; i < channels; i++)\n        for (y=0; y < (ssize_t) next_image->rows; y++)\n          length+=SetPSDOffset(psd_info,image,0);\n    }\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n  else if (next_image->compression == ZipCompression)\n    length=WriteBlobMSBShort(image,ZipWithoutPrediction);\n#endif\n  else\n    length=WriteBlobMSBShort(image,Raw);\n  return(length);\n}\n\nstatic size_t WritePSDChannel(const PSDInfo *psd_info,\n  const ImageInfo *image_info,Image *image,Image *next_image,\n  const QuantumType quantum_type, unsigned char *compact_pixels,\n  MagickOffsetType size_offset,const MagickBooleanType separate,\n  ExceptionInfo *exception)\n{\n  int\n    y;\n\n  MagickBooleanType\n    monochrome;\n\n  QuantumInfo\n    *quantum_info;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i;\n\n  size_t\n    count,\n    length;\n\n  unsigned char\n    *pixels;\n\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n\n#define CHUNK 16384\n\n  int\n    flush,\n    level;\n\n  unsigned char\n    *compressed_pixels;\n\n  z_stream\n    stream;\n\n  compressed_pixels=(unsigned char *) NULL;\n  flush=Z_NO_FLUSH;\n#endif\n  count=0;\n  if (separate != MagickFalse)\n    {\n      size_offset=TellBlob(image)+2;\n      count+=WriteCompressionStart(psd_info,image,next_image,1);\n    }\n  if (next_image->depth > 8)\n    next_image->depth=16;\n  monochrome=IsImageMonochrome(image) && (image->depth == 1) ?\n    MagickTrue : MagickFalse;\n  quantum_info=AcquireQuantumInfo(image_info,image);\n  if (quantum_info == (QuantumInfo *) NULL)\n    return(0);\n  pixels=(unsigned char *) GetQuantumPixels(quantum_info);\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n  if (next_image->compression == ZipCompression)\n    {\n      compressed_pixels=(unsigned char *) AcquireQuantumMemory(CHUNK,\n        sizeof(*compressed_pixels));\n      if (compressed_pixels == (unsigned char *) NULL)\n        {\n          quantum_info=DestroyQuantumInfo(quantum_info);\n          return(0);\n        }\n      ResetMagickMemory(&stream,0,sizeof(stream));\n      stream.data_type=Z_BINARY;\n      level=Z_DEFAULT_COMPRESSION;\n      if ((image_info->quality > 0 && image_info->quality < 10))\n        level=(int) image_info->quality;\n      if (deflateInit(&stream,level) != Z_OK)\n        {\n          quantum_info=DestroyQuantumInfo(quantum_info);\n          return(0);\n        }\n    }\n#endif\n  for (y=0; y < (ssize_t) next_image->rows; y++)\n  {\n    p=GetVirtualPixels(next_image,0,y,next_image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    length=ExportQuantumPixels(next_image,(CacheView *) NULL,quantum_info,\n      quantum_type,pixels,exception);\n    if (monochrome != MagickFalse)\n      for (i=0; i < (ssize_t) length; i++)\n        pixels[i]=(~pixels[i]);\n    if (next_image->compression == RLECompression)\n      {\n        length=PSDPackbitsEncodeImage(image,length,pixels,compact_pixels,\n          exception);\n        count+=WriteBlob(image,length,compact_pixels);\n        size_offset+=WritePSDOffset(psd_info,image,length,size_offset);\n      }\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n    else if (next_image->compression == ZipCompression)\n      {\n        stream.avail_in=(uInt) length;\n        stream.next_in=(Bytef *) pixels;\n        if (y == (ssize_t) next_image->rows-1)\n          flush=Z_FINISH;\n        do {\n            stream.avail_out=(uInt) CHUNK;\n            stream.next_out=(Bytef *) compressed_pixels;\n            if (deflate(&stream,flush) == Z_STREAM_ERROR)\n              break;\n            length=(size_t) CHUNK-stream.avail_out;\n            if (length > 0)\n              count+=WriteBlob(image,length,compressed_pixels);\n        } while (stream.avail_out == 0);\n      }\n#endif\n    else\n      count+=WriteBlob(image,length,pixels);\n  }\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n  if (next_image->compression == ZipCompression)\n    {\n      (void) deflateEnd(&stream);\n      compressed_pixels=(unsigned char *) RelinquishMagickMemory(\n        compressed_pixels);\n    }\n#endif\n  quantum_info=DestroyQuantumInfo(quantum_info);\n  return(count);\n}\n\nstatic unsigned char *AcquireCompactPixels(const Image *image,\n  ExceptionInfo *exception)\n{\n  size_t\n    packet_size;\n\n  unsigned char\n    *compact_pixels;\n\n  packet_size=image->depth > 8UL ? 2UL : 1UL;\n  compact_pixels=(unsigned char *) AcquireQuantumMemory((9*\n    image->columns)+1,packet_size*sizeof(*compact_pixels));\n  if (compact_pixels == (unsigned char *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\n        image->filename);\n    }\n  return(compact_pixels);\n}\n\nstatic size_t WritePSDChannels(const PSDInfo *psd_info,\n  const ImageInfo *image_info,Image *image,Image *next_image,\n  MagickOffsetType size_offset,const MagickBooleanType separate,\n  ExceptionInfo *exception)\n{\n  Image\n    *mask;\n\n  MagickOffsetType\n    rows_offset;\n\n  size_t\n    channels,\n    count,\n    length,\n    offset_length;\n\n  unsigned char\n    *compact_pixels;\n\n  count=0;\n  offset_length=0;\n  rows_offset=0;\n  compact_pixels=(unsigned char *) NULL;\n  if (next_image->compression == RLECompression)\n    {\n      compact_pixels=AcquireCompactPixels(image,exception);\n      if (compact_pixels == (unsigned char *) NULL)\n        return(0);\n    }\n  channels=1;\n  if (separate == MagickFalse)\n    {\n      if (next_image->storage_class != PseudoClass)\n        {\n          if (IsImageGray(next_image) == MagickFalse)\n            channels=next_image->colorspace == CMYKColorspace ? 4 : 3;\n          if (next_image->alpha_trait != UndefinedPixelTrait)\n            channels++;\n        }\n      rows_offset=TellBlob(image)+2;\n      count+=WriteCompressionStart(psd_info,image,next_image,channels);\n      offset_length=(next_image->rows*(psd_info->version == 1 ? 2 : 4));\n    }\n  size_offset+=2;\n  if (next_image->storage_class == PseudoClass)\n    {\n      length=WritePSDChannel(psd_info,image_info,image,next_image,\n        IndexQuantum,compact_pixels,rows_offset,separate,exception);\n      if (separate != MagickFalse)\n        size_offset+=WritePSDSize(psd_info,image,length,size_offset)+2;\n      else\n        rows_offset+=offset_length;\n      count+=length;\n    }\n  else\n    {\n      if (IsImageGray(next_image) != MagickFalse)\n        {\n          length=WritePSDChannel(psd_info,image_info,image,next_image,\n            GrayQuantum,compact_pixels,rows_offset,separate,exception);\n          if (separate != MagickFalse)\n            size_offset+=WritePSDSize(psd_info,image,length,size_offset)+2;\n          else\n            rows_offset+=offset_length;\n          count+=length;\n        }\n      else\n        {\n          if (next_image->colorspace == CMYKColorspace)\n            (void) NegateCMYK(next_image,exception);\n\n          length=WritePSDChannel(psd_info,image_info,image,next_image,\n            RedQuantum,compact_pixels,rows_offset,separate,exception);\n          if (separate != MagickFalse)\n            size_offset+=WritePSDSize(psd_info,image,length,size_offset)+2;\n          else\n            rows_offset+=offset_length;\n          count+=length;\n\n          length=WritePSDChannel(psd_info,image_info,image,next_image,\n            GreenQuantum,compact_pixels,rows_offset,separate,exception);\n          if (separate != MagickFalse)\n            size_offset+=WritePSDSize(psd_info,image,length,size_offset)+2;\n          else\n            rows_offset+=offset_length;\n          count+=length;\n\n          length=WritePSDChannel(psd_info,image_info,image,next_image,\n            BlueQuantum,compact_pixels,rows_offset,separate,exception);\n          if (separate != MagickFalse)\n            size_offset+=WritePSDSize(psd_info,image,length,size_offset)+2;\n          else\n            rows_offset+=offset_length;\n          count+=length;\n\n          if (next_image->colorspace == CMYKColorspace)\n            {\n              length=WritePSDChannel(psd_info,image_info,image,next_image,\n                BlackQuantum,compact_pixels,rows_offset,separate,exception);\n              if (separate != MagickFalse)\n                size_offset+=WritePSDSize(psd_info,image,length,size_offset)+2;\n              else\n                rows_offset+=offset_length;\n              count+=length;\n            }\n        }\n      if (next_image->alpha_trait != UndefinedPixelTrait)\n        {\n          length=WritePSDChannel(psd_info,image_info,image,next_image,\n            AlphaQuantum,compact_pixels,rows_offset,separate,exception);\n          if (separate != MagickFalse)\n            size_offset+=WritePSDSize(psd_info,image,length,size_offset)+2;\n          else\n            rows_offset+=offset_length;\n          count+=length;\n        }\n    }\n  compact_pixels=(unsigned char *) RelinquishMagickMemory(compact_pixels);\n  if (next_image->colorspace == CMYKColorspace)\n    (void) NegateCMYK(next_image,exception);\n  if (separate != MagickFalse)\n    {\n      const char\n        *property;\n\n      property=GetImageArtifact(next_image,\"psd:opacity-mask\");\n      if (property != (const char *) NULL)\n        {\n          mask=(Image *) GetImageRegistry(ImageRegistryType,property,\n            exception);\n          if (mask != (Image *) NULL)\n            {\n              if (mask->compression == RLECompression)\n                {\n                  compact_pixels=AcquireCompactPixels(mask,exception);\n                  if (compact_pixels == (unsigned char *) NULL)\n                    return(0);\n                }\n              length=WritePSDChannel(psd_info,image_info,image,mask,\n                RedQuantum,compact_pixels,rows_offset,MagickTrue,exception);\n              (void) WritePSDSize(psd_info,image,length,size_offset);\n              count+=length;\n              compact_pixels=(unsigned char *) RelinquishMagickMemory(\n                compact_pixels);\n            }\n        }\n    }\n  return(count);\n}\n\nstatic size_t WritePascalString(Image *image,const char *value,size_t padding)\n{\n  size_t\n    count,\n    length;\n\n  register ssize_t\n    i;\n\n  /*\n    Max length is 255.\n  */\n  count=0;\n  length=(strlen(value) > 255UL ) ? 255UL : strlen(value);\n  if (length ==  0)\n    count+=WriteBlobByte(image,0);\n  else\n    {\n      count+=WriteBlobByte(image,(unsigned char) length);\n      count+=WriteBlob(image,length,(const unsigned char *) value);\n    }\n  length++;\n  if ((length % padding) == 0)\n    return(count);\n  for (i=0; i < (ssize_t) (padding-(length % padding)); i++)\n    count+=WriteBlobByte(image,0);\n  return(count);\n}\n\nstatic void WriteResolutionResourceBlock(Image *image)\n{\n  double\n    x_resolution,\n    y_resolution;\n\n  unsigned short\n    units;\n\n  if (image->units == PixelsPerCentimeterResolution)\n    {\n      x_resolution=2.54*65536.0*image->resolution.x+0.5;\n      y_resolution=2.54*65536.0*image->resolution.y+0.5;\n      units=2;\n    }\n  else\n    {\n      x_resolution=65536.0*image->resolution.x+0.5;\n      y_resolution=65536.0*image->resolution.y+0.5;\n      units=1;\n    }\n  (void) WriteBlob(image,4,(const unsigned char *) \"8BIM\");\n  (void) WriteBlobMSBShort(image,0x03ED);\n  (void) WriteBlobMSBShort(image,0);\n  (void) WriteBlobMSBLong(image,16); /* resource size */\n  (void) WriteBlobMSBLong(image,(unsigned int) (x_resolution+0.5));\n  (void) WriteBlobMSBShort(image,units); /* horizontal resolution unit */\n  (void) WriteBlobMSBShort(image,units); /* width unit */\n  (void) WriteBlobMSBLong(image,(unsigned int) (y_resolution+0.5));\n  (void) WriteBlobMSBShort(image,units); /* vertical resolution unit */\n  (void) WriteBlobMSBShort(image,units); /* height unit */\n}\n\nstatic inline size_t WriteChannelSize(const PSDInfo *psd_info,Image *image,\n  const signed short channel)\n{\n  size_t\n    count;\n\n  count=WriteBlobMSBSignedShort(image,channel);\n  count+=SetPSDSize(psd_info,image,0);\n  return(count);\n}\n\nstatic void RemoveICCProfileFromResourceBlock(StringInfo *bim_profile)\n{\n  register const unsigned char\n    *p;\n\n  size_t\n    length;\n\n  unsigned char\n    *datum;\n\n  unsigned int\n    count,\n    long_sans;\n\n  unsigned short\n    id,\n    short_sans;\n\n  length=GetStringInfoLength(bim_profile);\n  if (length < 16)\n    return;\n  datum=GetStringInfoDatum(bim_profile);\n  for (p=datum; (p >= datum) && (p < (datum+length-16)); )\n  {\n    register unsigned char\n      *q;\n\n    q=(unsigned char *) p;\n    if (LocaleNCompare((const char *) p,\"8BIM\",4) != 0)\n      break;\n    p=PushLongPixel(MSBEndian,p,&long_sans);\n    p=PushShortPixel(MSBEndian,p,&id);\n    p=PushShortPixel(MSBEndian,p,&short_sans);\n    p=PushLongPixel(MSBEndian,p,&count);\n    if (id == 0x0000040f)\n      {\n        ssize_t\n          quantum;\n\n        quantum=PSDQuantum(count)+12;\n        if ((quantum >= 12) && (quantum < (ssize_t) length))\n          {\n            if ((q+quantum < (datum+length-16)))\n              (void) CopyMagickMemory(q,q+quantum,length-quantum-(q-datum));\n            SetStringInfoLength(bim_profile,length-quantum);\n          }\n        break;\n      }\n    p+=count;\n    if ((count & 0x01) != 0)\n      p++;\n  }\n}\n\nstatic void RemoveResolutionFromResourceBlock(StringInfo *bim_profile)\n{\n  register const unsigned char\n    *p;\n\n  size_t\n    length;\n\n  unsigned char\n    *datum;\n\n  unsigned int\n    count,\n    long_sans;\n\n  unsigned short\n    id,\n    short_sans;\n\n  length=GetStringInfoLength(bim_profile);\n  if (length < 16)\n    return;\n  datum=GetStringInfoDatum(bim_profile);\n  for (p=datum; (p >= datum) && (p < (datum+length-16)); )\n  {\n    register unsigned char\n      *q;\n\n    ssize_t\n      cnt;\n\n    q=(unsigned char *) p;\n    if (LocaleNCompare((const char *) p,\"8BIM\",4) != 0)\n      return;\n    p=PushLongPixel(MSBEndian,p,&long_sans);\n    p=PushShortPixel(MSBEndian,p,&id);\n    p=PushShortPixel(MSBEndian,p,&short_sans);\n    p=PushLongPixel(MSBEndian,p,&count);\n    cnt=PSDQuantum(count);\n    if (cnt < 0)\n      return;\n    if ((id == 0x000003ed) && (cnt < (ssize_t) (length-12)))\n      {\n        (void) CopyMagickMemory(q,q+cnt+12,length-(cnt+12)-(q-datum));\n        SetStringInfoLength(bim_profile,length-(cnt+12));\n        break;\n      }\n    p+=count;\n    if ((count & 0x01) != 0)\n      p++;\n  }\n}\n\nstatic const StringInfo *GetAdditionalInformation(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n#define PSDKeySize 5\n#define PSDAllowedLength 36\n\n  char\n    key[PSDKeySize];\n\n  /* Whitelist of keys from: https://www.adobe.com/devnet-apps/photoshop/fileformatashtml/ */\n  const char\n    allowed[PSDAllowedLength][PSDKeySize] = {\n      \"blnc\", \"blwh\", \"brit\", \"brst\", \"clbl\", \"clrL\", \"curv\", \"expA\", \"FMsk\",\n      \"GdFl\", \"grdm\", \"hue \", \"hue2\", \"infx\", \"knko\", \"lclr\", \"levl\", \"lnsr\",\n      \"lfx2\", \"luni\", \"lrFX\", \"lspf\", \"lyid\", \"lyvr\", \"mixr\", \"nvrt\", \"phfl\",\n      \"post\", \"PtFl\", \"selc\", \"shpa\", \"sn2P\", \"SoCo\", \"thrs\", \"tsly\", \"vibA\"\n    },\n    *option;\n\n  const StringInfo\n    *info;\n\n  MagickBooleanType\n    found;\n\n  register size_t\n    i;\n\n  size_t\n    remaining_length,\n    length;\n\n  StringInfo\n    *profile;\n\n  unsigned char\n    *p;\n\n  unsigned int\n    size;\n\n  info=GetImageProfile(image,\"psd:additional-info\");\n  if (info == (const StringInfo *) NULL)\n    return((const StringInfo *) NULL);\n  option=GetImageOption(image_info,\"psd:additional-info\");\n  if (LocaleCompare(option,\"all\") == 0)\n    return(info);\n  if (LocaleCompare(option,\"selective\") != 0)\n    {\n      profile=RemoveImageProfile(image,\"psd:additional-info\");\n      return(DestroyStringInfo(profile));\n    }\n  length=GetStringInfoLength(info);\n  p=GetStringInfoDatum(info);\n  remaining_length=length;\n  length=0;\n  while (remaining_length >= 12)\n  {\n    /* skip over signature */\n    p+=4;\n    key[0]=(*p++);\n    key[1]=(*p++);\n    key[2]=(*p++);\n    key[3]=(*p++);\n    key[4]='\\0';\n    size=(unsigned int) (*p++) << 24;\n    size|=(unsigned int) (*p++) << 16;\n    size|=(unsigned int) (*p++) << 8;\n    size|=(unsigned int) (*p++);\n    size=size & 0xffffffff;\n    remaining_length-=12;\n    if ((size_t) size > remaining_length)\n      return((const StringInfo *) NULL);\n    found=MagickFalse;\n    for (i=0; i < PSDAllowedLength; i++)\n    {\n      if (LocaleNCompare(key,allowed[i],PSDKeySize) != 0)\n        continue;\n\n      found=MagickTrue;\n      break;\n    }\n    remaining_length-=(size_t) size;\n    if (found == MagickFalse)\n      {\n        if (remaining_length > 0)\n          p=(unsigned char *) CopyMagickMemory(p-12,p+size,remaining_length);\n        continue;\n      }\n    length+=(size_t) size+12;\n    p+=size;\n  }\n  profile=RemoveImageProfile(image,\"psd:additional-info\");\n  if (length == 0)\n    return(DestroyStringInfo(profile));\n  SetStringInfoLength(profile,(const size_t) length);\n  SetImageProfile(image,\"psd:additional-info\",info,exception);\n  return(profile);\n}\n\nstatic MagickBooleanType WritePSDImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  char\n    layer_name[MagickPathExtent];\n\n  const char\n    *property;\n\n  const StringInfo\n    *icc_profile,\n    *info;\n\n  Image\n    *base_image,\n    *next_image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    *layer_size_offsets,\n    size_offset;\n\n  PSDInfo\n    psd_info;\n\n  register ssize_t\n    i;\n\n  size_t\n    layer_count,\n    layer_index,\n    length,\n    name_length,\n    num_channels,\n    packet_size,\n    rounded_size,\n    size;\n\n  StringInfo\n    *bim_profile;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  packet_size=(size_t) (image->depth > 8 ? 6 : 3);\n  if (image->alpha_trait != UndefinedPixelTrait)\n    packet_size+=image->depth > 8 ? 2 : 1;\n  psd_info.version=1;\n  if ((LocaleCompare(image_info->magick,\"PSB\") == 0) ||\n      (image->columns > 30000) || (image->rows > 30000))\n    psd_info.version=2;\n  (void) WriteBlob(image,4,(const unsigned char *) \"8BPS\");\n  (void) WriteBlobMSBShort(image,psd_info.version);  /* version */\n  for (i=1; i <= 6; i++)\n    (void) WriteBlobByte(image, 0);  /* 6 bytes of reserved */\n  if (SetImageGray(image,exception) != MagickFalse)\n    num_channels=(image->alpha_trait != UndefinedPixelTrait ? 2UL : 1UL);\n  else\n    if ((image_info->type != TrueColorType) && (image_info->type !=\n         TrueColorAlphaType) && (image->storage_class == PseudoClass))\n      num_channels=(image->alpha_trait != UndefinedPixelTrait ? 2UL : 1UL);\n    else\n      {\n        if (image->storage_class == PseudoClass)\n          (void) SetImageStorageClass(image,DirectClass,exception);\n        if (image->colorspace != CMYKColorspace)\n          num_channels=(image->alpha_trait != UndefinedPixelTrait ? 4UL : 3UL);\n        else\n          num_channels=(image->alpha_trait != UndefinedPixelTrait ? 5UL : 4UL);\n      }\n  (void) WriteBlobMSBShort(image,(unsigned short) num_channels);\n  (void) WriteBlobMSBLong(image,(unsigned int) image->rows);\n  (void) WriteBlobMSBLong(image,(unsigned int) image->columns);\n  if (IsImageGray(image) != MagickFalse)\n    {\n      MagickBooleanType\n        monochrome;\n\n      /*\n        Write depth & mode.\n      */\n      monochrome=IsImageMonochrome(image) && (image->depth == 1) ?\n        MagickTrue : MagickFalse;\n      (void) WriteBlobMSBShort(image,(unsigned short)\n        (monochrome != MagickFalse ? 1 : image->depth > 8 ? 16 : 8));\n      (void) WriteBlobMSBShort(image,(unsigned short)\n        (monochrome != MagickFalse ? BitmapMode : GrayscaleMode));\n    }\n  else\n    {\n      (void) WriteBlobMSBShort(image,(unsigned short) (image->storage_class ==\n        PseudoClass ? 8 : image->depth > 8 ? 16 : 8));\n\n      if (((image_info->colorspace != UndefinedColorspace) ||\n           (image->colorspace != CMYKColorspace)) &&\n          (image_info->colorspace != CMYKColorspace))\n        {\n          (void) TransformImageColorspace(image,sRGBColorspace,exception);\n          (void) WriteBlobMSBShort(image,(unsigned short)\n            (image->storage_class == PseudoClass ? IndexedMode : RGBMode));\n        }\n      else\n        {\n          if (image->colorspace != CMYKColorspace)\n            (void) TransformImageColorspace(image,CMYKColorspace,exception);\n          (void) WriteBlobMSBShort(image,CMYKMode);\n        }\n    }\n  if ((IsImageGray(image) != MagickFalse) ||\n      (image->storage_class == DirectClass) || (image->colors > 256))\n    (void) WriteBlobMSBLong(image,0);\n  else\n    {\n      /*\n        Write PSD raster colormap.\n      */\n      (void) WriteBlobMSBLong(image,768);\n      for (i=0; i < (ssize_t) image->colors; i++)\n        (void) WriteBlobByte(image,ScaleQuantumToChar(image->colormap[i].red));\n      for ( ; i < 256; i++)\n        (void) WriteBlobByte(image,0);\n      for (i=0; i < (ssize_t) image->colors; i++)\n        (void) WriteBlobByte(image,ScaleQuantumToChar(\n          image->colormap[i].green));\n      for ( ; i < 256; i++)\n        (void) WriteBlobByte(image,0);\n      for (i=0; i < (ssize_t) image->colors; i++)\n        (void) WriteBlobByte(image,ScaleQuantumToChar(image->colormap[i].blue));\n      for ( ; i < 256; i++)\n        (void) WriteBlobByte(image,0);\n    }\n  /*\n    Image resource block.\n  */\n  length=28; /* 0x03EB */\n  bim_profile=(StringInfo *) GetImageProfile(image,\"8bim\");\n  icc_profile=GetImageProfile(image,\"icc\");\n  if (bim_profile != (StringInfo *) NULL)\n    {\n      bim_profile=CloneStringInfo(bim_profile);\n      if (icc_profile != (StringInfo *) NULL)\n        RemoveICCProfileFromResourceBlock(bim_profile);\n      RemoveResolutionFromResourceBlock(bim_profile);\n      length+=PSDQuantum(GetStringInfoLength(bim_profile));\n    }\n  if (icc_profile != (const StringInfo *) NULL)\n    length+=PSDQuantum(GetStringInfoLength(icc_profile))+12;\n  (void) WriteBlobMSBLong(image,(unsigned int) length);\n  WriteResolutionResourceBlock(image);\n  if (bim_profile != (StringInfo *) NULL)\n    {\n      (void) WriteBlob(image,GetStringInfoLength(bim_profile),\n        GetStringInfoDatum(bim_profile));\n      bim_profile=DestroyStringInfo(bim_profile);\n    }\n  if (icc_profile != (StringInfo *) NULL)\n    {\n      (void) WriteBlob(image,4,(const unsigned char *) \"8BIM\");\n      (void) WriteBlobMSBShort(image,0x0000040F);\n      (void) WriteBlobMSBShort(image,0);\n      (void) WriteBlobMSBLong(image,(unsigned int) GetStringInfoLength(\n        icc_profile));\n      (void) WriteBlob(image,GetStringInfoLength(icc_profile),\n        GetStringInfoDatum(icc_profile));\n      if ((MagickOffsetType) GetStringInfoLength(icc_profile) !=\n          PSDQuantum(GetStringInfoLength(icc_profile)))\n        (void) WriteBlobByte(image,0);\n    }\n  base_image=GetNextImageInList(image);\n  if (base_image == (Image *) NULL)\n    base_image=image;\n  size=0;\n  size_offset=TellBlob(image);\n  SetPSDSize(&psd_info,image,0);\n  SetPSDSize(&psd_info,image,0);\n  layer_count=0;\n  for (next_image=base_image; next_image != NULL; )\n  {\n    layer_count++;\n    next_image=GetNextImageInList(next_image);\n  }\n  if (image->alpha_trait != UndefinedPixelTrait)\n    size+=WriteBlobMSBShort(image,-(unsigned short) layer_count);\n  else\n    size+=WriteBlobMSBShort(image,(unsigned short) layer_count);\n  layer_size_offsets=(MagickOffsetType *) AcquireQuantumMemory(\n    (size_t) layer_count,sizeof(MagickOffsetType));\n  if (layer_size_offsets == (MagickOffsetType *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  layer_index=0;\n  for (next_image=base_image; next_image != NULL; )\n  {\n    Image\n      *mask;\n\n    unsigned char\n      default_color;\n\n    unsigned short\n      channels,\n      total_channels;\n\n    mask=(Image *) NULL;\n    property=GetImageArtifact(next_image,\"psd:opacity-mask\");\n    default_color=0;\n    if (property != (const char *) NULL)\n      {\n        mask=(Image *) GetImageRegistry(ImageRegistryType,property,exception);\n        default_color=strlen(property) == 9 ? 255 : 0;\n      }\n    size+=WriteBlobMSBLong(image,(unsigned int) next_image->page.y);\n    size+=WriteBlobMSBLong(image,(unsigned int) next_image->page.x);\n    size+=WriteBlobMSBLong(image,(unsigned int) (next_image->page.y+\n      next_image->rows));\n    size+=WriteBlobMSBLong(image,(unsigned int) (next_image->page.x+\n      next_image->columns));\n    channels=1U;\n    if ((next_image->storage_class != PseudoClass) &&\n        (IsImageGray(next_image) == MagickFalse))\n      channels=next_image->colorspace == CMYKColorspace ? 4U : 3U;\n    total_channels=channels;\n    if (next_image->alpha_trait != UndefinedPixelTrait)\n      total_channels++;\n    if (mask != (Image *) NULL)\n      total_channels++;\n    size+=WriteBlobMSBShort(image,total_channels);\n    layer_size_offsets[layer_index++]=TellBlob(image);\n    for (i=0; i < (ssize_t) channels; i++)\n      size+=WriteChannelSize(&psd_info,image,(signed short) i);\n    if (next_image->alpha_trait != UndefinedPixelTrait)\n      size+=WriteChannelSize(&psd_info,image,-1);\n    if (mask != (Image *) NULL)\n      size+=WriteChannelSize(&psd_info,image,-2);\n    size+=WriteBlob(image,4,(const unsigned char *) \"8BIM\");\n    size+=WriteBlob(image,4,(const unsigned char *)\n      CompositeOperatorToPSDBlendMode(next_image->compose));\n    property=GetImageArtifact(next_image,\"psd:layer.opacity\");\n    if (property != (const char *) NULL)\n      {\n        Quantum\n          opacity;\n\n        opacity=(Quantum) StringToInteger(property);\n        size+=WriteBlobByte(image,ScaleQuantumToChar(opacity));\n        (void) ApplyPSDLayerOpacity(next_image,opacity,MagickTrue,exception);\n      }\n    else\n      size+=WriteBlobByte(image,255);\n    size+=WriteBlobByte(image,0);\n    size+=WriteBlobByte(image,next_image->compose==NoCompositeOp ?\n      1 << 0x02 : 1); /* layer properties - visible, etc. */\n    size+=WriteBlobByte(image,0);\n    info=GetAdditionalInformation(image_info,next_image,exception);\n    property=(const char *) GetImageProperty(next_image,\"label\",exception);\n    if (property == (const char *) NULL)\n      {\n        (void) FormatLocaleString(layer_name,MagickPathExtent,\"L%.20g\",\n          (double) layer_index);\n        property=layer_name;\n      }\n    name_length=strlen(property)+1;\n    if ((name_length % 4) != 0)\n      name_length+=(4-(name_length % 4));\n    if (info != (const StringInfo *) NULL)\n      name_length+=GetStringInfoLength(info);\n    name_length+=8;\n    if (mask != (Image *) NULL)\n      name_length+=20;\n    size+=WriteBlobMSBLong(image,(unsigned int) name_length);\n    if (mask == (Image *) NULL)\n      size+=WriteBlobMSBLong(image,0);\n    else\n      {\n        if (mask->compose != NoCompositeOp)\n          (void) ApplyPSDOpacityMask(next_image,mask,ScaleCharToQuantum(\n            default_color),MagickTrue,exception);\n        mask->page.y+=image->page.y;\n        mask->page.x+=image->page.x;\n        size+=WriteBlobMSBLong(image,20);\n        size+=WriteBlobMSBSignedLong(image,mask->page.y);\n        size+=WriteBlobMSBSignedLong(image,mask->page.x);\n        size+=WriteBlobMSBLong(image,(const unsigned int) mask->rows+\n          mask->page.y);\n        size+=WriteBlobMSBLong(image,(const unsigned int) mask->columns+\n          mask->page.x);\n        size+=WriteBlobByte(image,default_color);\n        size+=WriteBlobByte(image,mask->compose == NoCompositeOp ? 2 : 0);\n        size+=WriteBlobMSBShort(image,0);\n      }\n    size+=WriteBlobMSBLong(image,0);\n    size+=WritePascalString(image,property,4);\n    if (info != (const StringInfo *) NULL)\n      size+=WriteBlob(image,GetStringInfoLength(info),\n        GetStringInfoDatum(info));\n    next_image=GetNextImageInList(next_image);\n  }\n  /*\n    Now the image data!\n  */\n  next_image=base_image;\n  layer_index=0;\n  while (next_image != NULL)\n  {\n    length=WritePSDChannels(&psd_info,image_info,image,next_image,\n      layer_size_offsets[layer_index++],MagickTrue,exception);\n    if (length == 0)\n      {\n        status=MagickFalse;\n        break;\n      }\n    size+=length;\n    next_image=GetNextImageInList(next_image);\n  }\n  (void) WriteBlobMSBLong(image,0);  /* user mask data */\n  /*\n    Write the total size\n  */\n  size_offset+=WritePSDSize(&psd_info,image,size+\n    (psd_info.version == 1 ? 8 : 16),size_offset);\n  if ((size/2) != ((size+1)/2))\n    rounded_size=size+1;\n  else\n    rounded_size=size;\n  (void) WritePSDSize(&psd_info,image,rounded_size,size_offset);\n  layer_size_offsets=(MagickOffsetType *) RelinquishMagickMemory(\n    layer_size_offsets);\n  /*\n    Remove the opacity mask from the registry\n  */\n  next_image=base_image;\n  while (next_image != (Image *) NULL)\n  {\n    property=GetImageArtifact(next_image,\"psd:opacity-mask\");\n    if (property != (const char *) NULL)\n      DeleteImageRegistry(property);\n    next_image=GetNextImageInList(next_image);\n  }\n  /*\n    Write composite image.\n  */\n  if (status != MagickFalse)\n    {\n      CompressionType\n        compression;\n\n      compression=image->compression;\n      if (image->compression == ZipCompression)\n        image->compression=RLECompression;\n      if (WritePSDChannels(&psd_info,image_info,image,image,0,MagickFalse,\n          exception) == 0)\n        status=MagickFalse;\n      image->compression=compression;\n    }\n  (void) CloseBlob(image);\n  return(status);\n}\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                            PPPP   SSSSS  DDDD                               %\n%                            P   P  SS     D   D                              %\n%                            PPPP    SSS   D   D                              %\n%                            P         SS  D   D                              %\n%                            P      SSSSS  DDDD                               %\n%                                                                             %\n%                                                                             %\n%                   Read/Write Adobe Photoshop Image Format                   %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                              Leonard Rosenthol                              %\n%                                 July 1992                                   %\n%                                Dirk Lemstra                                 %\n%                                December 2013                                %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2017 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/artifact.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/channel.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colormap-private.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/enhance.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/log.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/pixel.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/profile.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/registry.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/thread-private.h\"\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n#include <zlib.h>\n#endif\n#include \"psd-private.h\"\n\n/*\n  Define declaractions.\n*/\n#define MaxPSDChannels  56\n#define PSDQuantum(x) (((ssize_t) (x)+1) & -2)\n\f\n/*\n  Enumerated declaractions.\n*/\ntypedef enum\n{\n  Raw = 0,\n  RLE = 1,\n  ZipWithoutPrediction = 2,\n  ZipWithPrediction = 3\n} PSDCompressionType;\n\ntypedef enum\n{\n  BitmapMode = 0,\n  GrayscaleMode = 1,\n  IndexedMode = 2,\n  RGBMode = 3,\n  CMYKMode = 4,\n  MultichannelMode = 7,\n  DuotoneMode = 8,\n  LabMode = 9\n} PSDImageType;\n\f\n/*\n  Typedef declaractions.\n*/\ntypedef struct _ChannelInfo\n{\n  short int\n    type;\n\n  size_t\n    size;\n} ChannelInfo;\n\ntypedef struct _MaskInfo\n{\n  Image\n    *image;\n\n  RectangleInfo\n    page;\n\n  unsigned char\n    background,\n    flags;\n} MaskInfo;\n\ntypedef struct _LayerInfo\n{\n  ChannelInfo\n    channel_info[MaxPSDChannels];\n\n  char\n    blendkey[4];\n\n  Image\n    *image;\n\n  MaskInfo\n    mask;\n\n  Quantum\n    opacity;\n\n  RectangleInfo\n    page;\n\n  size_t\n    offset_x,\n    offset_y;\n\n  unsigned char\n    clipping,\n    flags,\n    name[256],\n    visible;\n\n  unsigned short\n    channels;\n\n  StringInfo\n    *info;\n} LayerInfo;\n\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  WritePSDImage(const ImageInfo *,Image *,ExceptionInfo *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s P S D                                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsPSD()() returns MagickTrue if the image format type, identified by the\n%  magick string, is PSD.\n%\n%  The format of the IsPSD method is:\n%\n%      MagickBooleanType IsPSD(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsPSD(const unsigned char *magick,const size_t length)\n{\n  if (length < 4)\n    return(MagickFalse);\n  if (LocaleNCompare((const char *) magick,\"8BPS\",4) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d P S D I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadPSDImage() reads an Adobe Photoshop image file and returns it.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the ReadPSDImage method is:\n%\n%      Image *ReadPSDImage(image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic const char *CompositeOperatorToPSDBlendMode(CompositeOperator op)\n{\n  const char\n    *blend_mode;\n\n  switch (op)\n  {\n    case ColorBurnCompositeOp:  blend_mode = \"idiv\";  break;\n    case ColorDodgeCompositeOp: blend_mode = \"div \";  break;\n    case ColorizeCompositeOp:   blend_mode = \"colr\";  break;\n    case DarkenCompositeOp:     blend_mode = \"dark\";  break;\n    case DifferenceCompositeOp: blend_mode = \"diff\";  break;\n    case DissolveCompositeOp:   blend_mode = \"diss\";  break;\n    case ExclusionCompositeOp:  blend_mode = \"smud\";  break;\n    case HardLightCompositeOp:  blend_mode = \"hLit\";  break;\n    case HardMixCompositeOp:    blend_mode = \"hMix\";  break;\n    case HueCompositeOp:        blend_mode = \"hue \";  break;\n    case LightenCompositeOp:    blend_mode = \"lite\";  break;\n    case LinearBurnCompositeOp: blend_mode = \"lbrn\";  break;\n    case LinearDodgeCompositeOp:blend_mode = \"lddg\";  break;\n    case LinearLightCompositeOp:blend_mode = \"lLit\";  break;\n    case LuminizeCompositeOp:   blend_mode = \"lum \";  break;\n    case MultiplyCompositeOp:   blend_mode = \"mul \";  break;\n    case OverCompositeOp:       blend_mode = \"norm\";  break;\n    case OverlayCompositeOp:    blend_mode = \"over\";  break;\n    case PinLightCompositeOp:   blend_mode = \"pLit\";  break;\n    case SaturateCompositeOp:   blend_mode = \"sat \";  break;\n    case ScreenCompositeOp:     blend_mode = \"scrn\";  break;\n    case SoftLightCompositeOp:  blend_mode = \"sLit\";  break;\n    case VividLightCompositeOp: blend_mode = \"vLit\";  break;\n    default:                    blend_mode = \"norm\";\n  }\n  return(blend_mode);\n}\n\n/*\n  For some reason Photoshop seems to blend semi-transparent pixels with white.\n  This method reverts the blending. This can be disabled by setting the\n  option 'psd:alpha-unblend' to off.\n*/\nstatic MagickBooleanType CorrectPSDAlphaBlend(const ImageInfo *image_info,\n  Image *image,ExceptionInfo* exception)\n{\n  const char\n    *option;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    y;\n\n  if (image->alpha_trait != BlendPixelTrait || image->colorspace != sRGBColorspace)\n    return(MagickTrue);\n  option=GetImageOption(image_info,\"psd:alpha-unblend\");\n  if (IsStringFalse(option) != MagickFalse)\n    return(MagickTrue);\n  status=MagickTrue;\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n#pragma omp parallel for schedule(static,4) shared(status) \\\n  magick_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n    {\n      status=MagickFalse;\n      continue;\n    }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double\n        gamma;\n\n      register ssize_t\n        i;\n\n      gamma=QuantumScale*GetPixelAlpha(image, q);\n      if (gamma != 0.0 && gamma != 1.0)\n        {\n          for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n          {\n            PixelChannel channel=GetPixelChannelChannel(image,i);\n            if (channel != AlphaPixelChannel)\n              q[i]=ClampToQuantum((q[i]-((1.0-gamma)*QuantumRange))/gamma);\n          }\n        }\n      q+=GetPixelChannels(image);\n    }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n\n  return(status);\n}\n\nstatic inline CompressionType ConvertPSDCompression(\n  PSDCompressionType compression)\n{\n  switch (compression)\n  {\n    case RLE:\n      return RLECompression;\n    case ZipWithPrediction:\n    case ZipWithoutPrediction:\n      return ZipCompression;\n    default:\n      return NoCompression;\n  }\n}\n\nstatic MagickBooleanType ApplyPSDLayerOpacity(Image *image,Quantum opacity,\n  MagickBooleanType revert,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  ssize_t\n    y;\n\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  applying layer opacity %.20g\", (double) opacity);\n  if (opacity == OpaqueAlpha)\n    return(MagickTrue);\n  image->alpha_trait=BlendPixelTrait;\n  status=MagickTrue;\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n#pragma omp parallel for schedule(static,4) shared(status) \\\n  magick_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      if (revert == MagickFalse)\n        SetPixelAlpha(image,(Quantum) (QuantumScale*(GetPixelAlpha(image,q))*\n          opacity),q);\n      else if (opacity > 0)\n        SetPixelAlpha(image,(Quantum) (QuantumRange*(GetPixelAlpha(image,q)/\n          (MagickRealType) opacity)),q);\n      q+=GetPixelChannels(image);\n    }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n\n  return(status);\n}\n\nstatic MagickBooleanType ApplyPSDOpacityMask(Image *image,const Image *mask,\n  Quantum background,MagickBooleanType revert,ExceptionInfo *exception)\n{\n  Image\n    *complete_mask;\n\n  MagickBooleanType\n    status;\n\n  PixelInfo\n    color;\n\n  ssize_t\n    y;\n\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  applying opacity mask\");\n  complete_mask=CloneImage(image,image->columns,image->rows,MagickTrue,\n    exception);\n  complete_mask->alpha_trait=BlendPixelTrait;\n  GetPixelInfo(complete_mask,&color);\n  color.red=background;\n  SetImageColor(complete_mask,&color,exception);\n  status=CompositeImage(complete_mask,mask,OverCompositeOp,MagickTrue,\n    mask->page.x-image->page.x,mask->page.y-image->page.y,exception);\n  if (status == MagickFalse)\n    {\n      complete_mask=DestroyImage(complete_mask);\n      return(status);\n    }\n  image->alpha_trait=BlendPixelTrait;\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n#pragma omp parallel for schedule(static,4) shared(status) \\\n  magick_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register Quantum\n      *magick_restrict q;\n\n    register Quantum\n      *p;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n    p=GetAuthenticPixels(complete_mask,0,y,complete_mask->columns,1,exception);\n    if ((q == (Quantum *) NULL) || (p == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      MagickRealType\n        alpha,\n        intensity;\n\n      alpha=GetPixelAlpha(image,q);\n      intensity=GetPixelIntensity(complete_mask,p);\n      if (revert == MagickFalse)\n        SetPixelAlpha(image,ClampToQuantum(intensity*(QuantumScale*alpha)),q);\n      else if (intensity > 0)\n        SetPixelAlpha(image,ClampToQuantum((alpha/intensity)*QuantumRange),q);\n      q+=GetPixelChannels(image);\n      p+=GetPixelChannels(complete_mask);\n    }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n  complete_mask=DestroyImage(complete_mask);\n  return(status);\n}\n\nstatic void PreservePSDOpacityMask(Image *image,LayerInfo* layer_info,\n  ExceptionInfo *exception)\n{\n  char\n    *key;\n\n  RandomInfo\n    *random_info;\n\n  StringInfo\n    *key_info;\n\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  preserving opacity mask\");\n  random_info=AcquireRandomInfo();\n  key_info=GetRandomKey(random_info,2+1);\n  key=(char *) GetStringInfoDatum(key_info);\n  key[8]=layer_info->mask.background;\n  key[9]='\\0';\n  layer_info->mask.image->page.x+=layer_info->page.x;\n  layer_info->mask.image->page.y+=layer_info->page.y;\n  (void) SetImageRegistry(ImageRegistryType,(const char *) key,\n    layer_info->mask.image,exception);\n  (void) SetImageArtifact(layer_info->image,\"psd:opacity-mask\",\n    (const char *) key);\n  key_info=DestroyStringInfo(key_info);\n  random_info=DestroyRandomInfo(random_info);\n}\n\nstatic ssize_t DecodePSDPixels(const size_t number_compact_pixels,\n  const unsigned char *compact_pixels,const ssize_t depth,\n  const size_t number_pixels,unsigned char *pixels)\n{\n#define CheckNumberCompactPixels \\\n  if (packets == 0) \\\n    return(i); \\\n  packets--\n\n#define CheckNumberPixels(count) \\\n  if (((ssize_t) i + count) > (ssize_t) number_pixels) \\\n    return(i); \\\n  i+=count\n\n  int\n    pixel;\n\n  register ssize_t\n    i,\n    j;\n\n  size_t\n    length;\n\n  ssize_t\n    packets;\n\n  packets=(ssize_t) number_compact_pixels;\n  for (i=0; (packets > 1) && (i < (ssize_t) number_pixels); )\n  {\n    packets--;\n    length=(size_t) (*compact_pixels++);\n    if (length == 128)\n      continue;\n    if (length > 128)\n      {\n        length=256-length+1;\n        CheckNumberCompactPixels;\n        pixel=(*compact_pixels++);\n        for (j=0; j < (ssize_t) length; j++)\n        {\n          switch (depth)\n          {\n            case 1:\n            {\n              CheckNumberPixels(8);\n              *pixels++=(pixel >> 7) & 0x01 ? 0U : 255U;\n              *pixels++=(pixel >> 6) & 0x01 ? 0U : 255U;\n              *pixels++=(pixel >> 5) & 0x01 ? 0U : 255U;\n              *pixels++=(pixel >> 4) & 0x01 ? 0U : 255U;\n              *pixels++=(pixel >> 3) & 0x01 ? 0U : 255U;\n              *pixels++=(pixel >> 2) & 0x01 ? 0U : 255U;\n              *pixels++=(pixel >> 1) & 0x01 ? 0U : 255U;\n              *pixels++=(pixel >> 0) & 0x01 ? 0U : 255U;\n              break;\n            }\n            case 2:\n            {\n              CheckNumberPixels(4);\n              *pixels++=(unsigned char) ((pixel >> 6) & 0x03);\n              *pixels++=(unsigned char) ((pixel >> 4) & 0x03);\n              *pixels++=(unsigned char) ((pixel >> 2) & 0x03);\n              *pixels++=(unsigned char) ((pixel & 0x03) & 0x03);\n              break;\n            }\n            case 4:\n            {\n              CheckNumberPixels(2);\n              *pixels++=(unsigned char) ((pixel >> 4) & 0xff);\n              *pixels++=(unsigned char) ((pixel & 0x0f) & 0xff);\n              break;\n            }\n            default:\n            {\n              CheckNumberPixels(1);\n              *pixels++=(unsigned char) pixel;\n              break;\n            }\n          }\n        }\n        continue;\n      }\n    length++;\n    for (j=0; j < (ssize_t) length; j++)\n    {\n      CheckNumberCompactPixels;\n      switch (depth)\n      {\n        case 1:\n        {\n          CheckNumberPixels(8);\n          *pixels++=(*compact_pixels >> 7) & 0x01 ? 0U : 255U;\n          *pixels++=(*compact_pixels >> 6) & 0x01 ? 0U : 255U;\n          *pixels++=(*compact_pixels >> 5) & 0x01 ? 0U : 255U;\n          *pixels++=(*compact_pixels >> 4) & 0x01 ? 0U : 255U;\n          *pixels++=(*compact_pixels >> 3) & 0x01 ? 0U : 255U;\n          *pixels++=(*compact_pixels >> 2) & 0x01 ? 0U : 255U;\n          *pixels++=(*compact_pixels >> 1) & 0x01 ? 0U : 255U;\n          *pixels++=(*compact_pixels >> 0) & 0x01 ? 0U : 255U;\n          break;\n        }\n        case 2:\n        {\n          CheckNumberPixels(4);\n          *pixels++=(*compact_pixels >> 6) & 0x03;\n          *pixels++=(*compact_pixels >> 4) & 0x03;\n          *pixels++=(*compact_pixels >> 2) & 0x03;\n          *pixels++=(*compact_pixels & 0x03) & 0x03;\n          break;\n        }\n        case 4:\n        {\n          CheckNumberPixels(2);\n          *pixels++=(*compact_pixels >> 4) & 0xff;\n          *pixels++=(*compact_pixels & 0x0f) & 0xff;\n          break;\n        }\n        default:\n        {\n          CheckNumberPixels(1);\n          *pixels++=(*compact_pixels);\n          break;\n        }\n      }\n      compact_pixels++;\n    }\n  }\n  return(i);\n}\n\nstatic inline LayerInfo *DestroyLayerInfo(LayerInfo *layer_info,\n  const ssize_t number_layers)\n{\n  ssize_t\n    i;\n\n  for (i=0; i<number_layers; i++)\n  {\n    if (layer_info[i].image != (Image *) NULL)\n      layer_info[i].image=DestroyImage(layer_info[i].image);\n    if (layer_info[i].mask.image != (Image *) NULL)\n      layer_info[i].mask.image=DestroyImage(layer_info[i].mask.image);\n    if (layer_info[i].info != (StringInfo *) NULL)\n      layer_info[i].info=DestroyStringInfo(layer_info[i].info);\n  }\n\n  return (LayerInfo *) RelinquishMagickMemory(layer_info);\n}\n\nstatic inline size_t GetPSDPacketSize(Image *image)\n{\n  if (image->storage_class == PseudoClass)\n    {\n      if (image->colors > 256)\n        return(2);\n      else if (image->depth > 8)\n        return(2);\n    }\n  else\n    if (image->depth > 8)\n      return(2);\n\n  return(1);\n}\n\nstatic inline MagickSizeType GetPSDSize(const PSDInfo *psd_info,Image *image)\n{\n  if (psd_info->version == 1)\n    return((MagickSizeType) ReadBlobLong(image));\n  return((MagickSizeType) ReadBlobLongLong(image));\n}\n\nstatic inline size_t GetPSDRowSize(Image *image)\n{\n  if (image->depth == 1)\n    return(((image->columns+7)/8)*GetPSDPacketSize(image));\n  else\n    return(image->columns*GetPSDPacketSize(image));\n}\n\nstatic const char *ModeToString(PSDImageType type)\n{\n  switch (type)\n  {\n    case BitmapMode: return \"Bitmap\";\n    case GrayscaleMode: return \"Grayscale\";\n    case IndexedMode: return \"Indexed\";\n    case RGBMode: return \"RGB\";\n    case CMYKMode:  return \"CMYK\";\n    case MultichannelMode: return \"Multichannel\";\n    case DuotoneMode: return \"Duotone\";\n    case LabMode: return \"L*A*B\";\n    default: return \"unknown\";\n  }\n}\n\nstatic MagickBooleanType NegateCMYK(Image *image,ExceptionInfo *exception)\n{\n  ChannelType\n    channel_mask;\n\n  MagickBooleanType\n    status;\n\n  channel_mask=SetImageChannelMask(image,(ChannelType)(AllChannels &~\n    AlphaChannel));\n  status=NegateImage(image,MagickFalse,exception);\n  (void) SetImageChannelMask(image,channel_mask);\n  return(status);\n}\n\nstatic void ParseImageResourceBlocks(Image *image,\n  const unsigned char *blocks,size_t length,\n  MagickBooleanType *has_merged_image,ExceptionInfo *exception)\n{\n  const unsigned char\n    *p;\n\n  StringInfo\n    *profile;\n\n  unsigned int\n    count,\n    long_sans;\n\n  unsigned short\n    id,\n    short_sans;\n\n  if (length < 16)\n    return;\n  profile=BlobToStringInfo((const unsigned char *) NULL,length);\n  SetStringInfoDatum(profile,blocks);\n  (void) SetImageProfile(image,\"8bim\",profile,exception);\n  profile=DestroyStringInfo(profile);\n  for (p=blocks; (p >= blocks) && (p < (blocks+length-16)); )\n  {\n    if (LocaleNCompare((const char *) p,\"8BIM\",4) != 0)\n      break;\n    p=PushLongPixel(MSBEndian,p,&long_sans);\n    p=PushShortPixel(MSBEndian,p,&id);\n    p=PushShortPixel(MSBEndian,p,&short_sans);\n    p=PushLongPixel(MSBEndian,p,&count);\n    if ((p+count) > (blocks+length-16))\n      return;\n    switch (id)\n    {\n      case 0x03ed:\n      {\n        char\n          value[MagickPathExtent];\n\n        unsigned short\n          resolution;\n\n        /*\n          Resolution info.\n        */\n        p=PushShortPixel(MSBEndian,p,&resolution);\n        image->resolution.x=(double) resolution;\n        (void) FormatLocaleString(value,MagickPathExtent,\"%g\",image->resolution.x);\n        (void) SetImageProperty(image,\"tiff:XResolution\",value,exception);\n        p=PushShortPixel(MSBEndian,p,&short_sans);\n        p=PushShortPixel(MSBEndian,p,&short_sans);\n        p=PushShortPixel(MSBEndian,p,&short_sans);\n        p=PushShortPixel(MSBEndian,p,&resolution);\n        image->resolution.y=(double) resolution;\n        (void) FormatLocaleString(value,MagickPathExtent,\"%g\",image->resolution.y);\n        (void) SetImageProperty(image,\"tiff:YResolution\",value,exception);\n        p=PushShortPixel(MSBEndian,p,&short_sans);\n        p=PushShortPixel(MSBEndian,p,&short_sans);\n        p=PushShortPixel(MSBEndian,p,&short_sans);\n        image->units=PixelsPerInchResolution;\n        break;\n      }\n      case 0x0421:\n      {\n        if (*(p+4) == 0)\n          *has_merged_image=MagickFalse;\n        p+=count;\n        break;\n      }\n      default:\n      {\n        p+=count;\n        break;\n      }\n    }\n    if ((count & 0x01) != 0)\n      p++;\n  }\n  return;\n}\n\nstatic CompositeOperator PSDBlendModeToCompositeOperator(const char *mode)\n{\n  if (mode == (const char *) NULL)\n    return(OverCompositeOp);\n  if (LocaleNCompare(mode,\"norm\",4) == 0)\n    return(OverCompositeOp);\n  if (LocaleNCompare(mode,\"mul \",4) == 0)\n    return(MultiplyCompositeOp);\n  if (LocaleNCompare(mode,\"diss\",4) == 0)\n    return(DissolveCompositeOp);\n  if (LocaleNCompare(mode,\"diff\",4) == 0)\n    return(DifferenceCompositeOp);\n  if (LocaleNCompare(mode,\"dark\",4) == 0)\n    return(DarkenCompositeOp);\n  if (LocaleNCompare(mode,\"lite\",4) == 0)\n    return(LightenCompositeOp);\n  if (LocaleNCompare(mode,\"hue \",4) == 0)\n    return(HueCompositeOp);\n  if (LocaleNCompare(mode,\"sat \",4) == 0)\n    return(SaturateCompositeOp);\n  if (LocaleNCompare(mode,\"colr\",4) == 0)\n    return(ColorizeCompositeOp);\n  if (LocaleNCompare(mode,\"lum \",4) == 0)\n    return(LuminizeCompositeOp);\n  if (LocaleNCompare(mode,\"scrn\",4) == 0)\n    return(ScreenCompositeOp);\n  if (LocaleNCompare(mode,\"over\",4) == 0)\n    return(OverlayCompositeOp);\n  if (LocaleNCompare(mode,\"hLit\",4) == 0)\n    return(HardLightCompositeOp);\n  if (LocaleNCompare(mode,\"sLit\",4) == 0)\n    return(SoftLightCompositeOp);\n  if (LocaleNCompare(mode,\"smud\",4) == 0)\n    return(ExclusionCompositeOp);\n  if (LocaleNCompare(mode,\"div \",4) == 0)\n    return(ColorDodgeCompositeOp);\n  if (LocaleNCompare(mode,\"idiv\",4) == 0)\n    return(ColorBurnCompositeOp);\n  if (LocaleNCompare(mode,\"lbrn\",4) == 0)\n    return(LinearBurnCompositeOp);\n  if (LocaleNCompare(mode,\"lddg\",4) == 0)\n    return(LinearDodgeCompositeOp);\n  if (LocaleNCompare(mode,\"lLit\",4) == 0)\n    return(LinearLightCompositeOp);\n  if (LocaleNCompare(mode,\"vLit\",4) == 0)\n    return(VividLightCompositeOp);\n  if (LocaleNCompare(mode,\"pLit\",4) == 0)\n    return(PinLightCompositeOp);\n  if (LocaleNCompare(mode,\"hMix\",4) == 0)\n    return(HardMixCompositeOp);\n  return(OverCompositeOp);\n}\n\nstatic inline void ReversePSDString(Image *image,char *p,size_t length)\n{\n  char\n    *q;\n\n  if (image->endian == MSBEndian)\n    return;\n\n  q=p+length;\n  for(--q; p < q; ++p, --q)\n  {\n    *p = *p ^ *q,\n    *q = *p ^ *q,\n    *p = *p ^ *q;\n  }\n}\n\nstatic inline void SetPSDPixel(Image *image,const size_t channels,\n  const ssize_t type,const size_t packet_size,const Quantum pixel,Quantum *q,\n  ExceptionInfo *exception)\n{\n  if (image->storage_class == PseudoClass)\n    {\n      if (packet_size == 1)\n        SetPixelIndex(image,ScaleQuantumToChar(pixel),q);\n      else\n        SetPixelIndex(image,ScaleQuantumToShort(pixel),q);\n      SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n        ConstrainColormapIndex(image,GetPixelIndex(image,q),exception),q);\n      return;\n    }\n  switch (type)\n  {\n    case -1:\n    {\n      SetPixelAlpha(image, pixel,q);\n      break;\n    }\n    case -2:\n    case 0:\n    {\n      SetPixelRed(image,pixel,q);\n      if (channels == 1 || type == -2)\n        SetPixelGray(image,pixel,q);\n      break;\n    }\n    case 1:\n    {\n      if (image->storage_class == PseudoClass)\n        SetPixelAlpha(image,pixel,q);\n      else\n        SetPixelGreen(image,pixel,q);\n      break;\n    }\n    case 2:\n    {\n      if (image->storage_class == PseudoClass)\n        SetPixelAlpha(image,pixel,q);\n      else\n        SetPixelBlue(image,pixel,q);\n      break;\n    }\n    case 3:\n    {\n      if (image->colorspace == CMYKColorspace)\n        SetPixelBlack(image,pixel,q);\n      else\n        if (image->alpha_trait != UndefinedPixelTrait)\n          SetPixelAlpha(image,pixel,q);\n      break;\n    }\n    case 4:\n    {\n      if ((IssRGBCompatibleColorspace(image->colorspace) != MagickFalse) &&\n          (channels > 3))\n        break;\n      if (image->alpha_trait != UndefinedPixelTrait)\n        SetPixelAlpha(image,pixel,q);\n      break;\n    }\n  }\n}\n\nstatic MagickBooleanType ReadPSDChannelPixels(Image *image,\n  const size_t channels,const size_t row,const ssize_t type,\n  const unsigned char *pixels,ExceptionInfo *exception)\n{\n  Quantum\n    pixel;\n\n  register const unsigned char\n    *p;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    x;\n\n  size_t\n    packet_size;\n\n  unsigned short\n    nibble;\n\n  p=pixels;\n  q=GetAuthenticPixels(image,0,row,image->columns,1,exception);\n  if (q == (Quantum *) NULL)\n    return MagickFalse;\n  packet_size=GetPSDPacketSize(image);\n  for (x=0; x < (ssize_t) image->columns; x++)\n  {\n    if (packet_size == 1)\n      pixel=ScaleCharToQuantum(*p++);\n    else\n      {\n        p=PushShortPixel(MSBEndian,p,&nibble);\n        pixel=ScaleShortToQuantum(nibble);\n      }\n    if (image->depth > 1)\n      {\n        SetPSDPixel(image,channels,type,packet_size,pixel,q,exception);\n        q+=GetPixelChannels(image);\n      }\n    else\n      {\n        ssize_t\n          bit,\n          number_bits;\n      \n        number_bits=image->columns-x;\n        if (number_bits > 8)\n          number_bits=8;\n        for (bit = 0; bit < number_bits; bit++)\n        {\n          SetPSDPixel(image,channels,type,packet_size,(((unsigned char) pixel)\n            & (0x01 << (7-bit))) != 0 ? 0 : QuantumRange,q,exception);\n          q+=GetPixelChannels(image);\n          x++;\n        }\n        if (x != (ssize_t) image->columns)\n          x--;\n        continue;\n      }\n  }\n  return(SyncAuthenticPixels(image,exception));\n}\n\nstatic MagickBooleanType ReadPSDChannelRaw(Image *image,const size_t channels,\n  const ssize_t type,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  size_t\n    count,\n    row_size;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *pixels;\n\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n       \"      layer data is RAW\");\n\n  row_size=GetPSDRowSize(image);\n  pixels=(unsigned char *) AcquireQuantumMemory(row_size,sizeof(*pixels));\n  if (pixels == (unsigned char *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n\n  status=MagickTrue;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    status=MagickFalse;\n\n    count=ReadBlob(image,row_size,pixels);\n    if (count != row_size)\n      break;\n\n    status=ReadPSDChannelPixels(image,channels,y,type,pixels,exception);\n    if (status == MagickFalse)\n      break;\n  }\n\n  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  return(status);\n}\n\nstatic inline MagickOffsetType *ReadPSDRLESizes(Image *image,\n  const PSDInfo *psd_info,const size_t size)\n{\n  MagickOffsetType\n    *sizes;\n\n  ssize_t\n    y;\n\n  sizes=(MagickOffsetType *) AcquireQuantumMemory(size,sizeof(*sizes));\n  if(sizes != (MagickOffsetType *) NULL)\n    {\n      for (y=0; y < (ssize_t) size; y++)\n      {\n        if (psd_info->version == 1)\n          sizes[y]=(MagickOffsetType) ReadBlobShort(image);\n        else\n          sizes[y]=(MagickOffsetType) ReadBlobLong(image);\n      }\n    }\n  return sizes;\n}\n\nstatic MagickBooleanType ReadPSDChannelRLE(Image *image,const PSDInfo *psd_info,\n  const ssize_t type,MagickOffsetType *sizes,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  size_t\n    length,\n    row_size;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *compact_pixels,\n    *pixels;\n\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n       \"      layer data is RLE compressed\");\n\n  row_size=GetPSDRowSize(image);\n  pixels=(unsigned char *) AcquireQuantumMemory(row_size,sizeof(*pixels));\n  if (pixels == (unsigned char *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n\n  length=0;\n  for (y=0; y < (ssize_t) image->rows; y++)\n    if ((MagickOffsetType) length < sizes[y])\n      length=(size_t) sizes[y];\n\n  if (length > row_size + 256) // arbitrary number\n    {\n      pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n      ThrowBinaryException(ResourceLimitError,\"InvalidLength\",\n        image->filename);\n    }\n\n  compact_pixels=(unsigned char *) AcquireQuantumMemory(length,sizeof(*pixels));\n  if (compact_pixels == (unsigned char *) NULL)\n    {\n      pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image->filename);\n    }\n\n  (void) ResetMagickMemory(compact_pixels,0,length*sizeof(*compact_pixels));\n\n  status=MagickTrue;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    status=MagickFalse;\n\n    count=ReadBlob(image,(size_t) sizes[y],compact_pixels);\n    if (count != (ssize_t) sizes[y])\n      break;\n\n    count=DecodePSDPixels((size_t) sizes[y],compact_pixels,\n      (ssize_t) (image->depth == 1 ? 123456 : image->depth),row_size,pixels);\n    if (count != (ssize_t) row_size)\n      break;\n\n    status=ReadPSDChannelPixels(image,psd_info->channels,y,type,pixels,\n      exception);\n    if (status == MagickFalse)\n      break;\n  }\n\n  compact_pixels=(unsigned char *) RelinquishMagickMemory(compact_pixels);\n  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  return(status);\n}\n\n#ifdef MAGICKCORE_ZLIB_DELEGATE\nstatic MagickBooleanType ReadPSDChannelZip(Image *image,const size_t channels,\n  const ssize_t type,const PSDCompressionType compression,\n  const size_t compact_size,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  register unsigned char\n    *p;\n\n  size_t\n    count,\n    length,\n    packet_size,\n    row_size;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *compact_pixels,\n    *pixels;\n\n  z_stream\n    stream;\n\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n       \"      layer data is ZIP compressed\");\n\n  compact_pixels=(unsigned char *) AcquireQuantumMemory(compact_size,\n    sizeof(*compact_pixels));\n  if (compact_pixels == (unsigned char *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n\n  packet_size=GetPSDPacketSize(image);\n  row_size=image->columns*packet_size;\n  count=image->rows*row_size;\n\n  pixels=(unsigned char *) AcquireQuantumMemory(count,sizeof(*pixels));\n  if (pixels == (unsigned char *) NULL)\n    {\n      compact_pixels=(unsigned char *) RelinquishMagickMemory(compact_pixels);\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image->filename);\n    }\n\n  ResetMagickMemory(&stream,0,sizeof(stream));\n  stream.data_type=Z_BINARY;\n  (void) ReadBlob(image,compact_size,compact_pixels);\n\n  stream.next_in=(Bytef *)compact_pixels;\n  stream.avail_in=(uInt) compact_size;\n  stream.next_out=(Bytef *)pixels;\n  stream.avail_out=(uInt) count;\n\n  if (inflateInit(&stream) == Z_OK)\n    {\n      int\n        ret;\n\n      while (stream.avail_out > 0)\n      {\n        ret=inflate(&stream,Z_SYNC_FLUSH);\n        if ((ret != Z_OK) && (ret != Z_STREAM_END))\n          {\n            compact_pixels=(unsigned char *) RelinquishMagickMemory(\n              compact_pixels);\n            pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n            return(MagickFalse);\n          }\n      }\n    }\n\n  if (compression == ZipWithPrediction)\n  {\n     p=pixels;\n     while (count > 0)\n     {\n       length=image->columns;\n       while (--length)\n       {\n         if (packet_size == 2)\n           {\n             p[2]+=p[0]+((p[1]+p[3]) >> 8);\n             p[3]+=p[1];\n           }\n         else\n          *(p+1)+=*p;\n         p+=packet_size;\n       }\n       p+=packet_size;\n       count-=row_size;\n     }\n  }\n\n  status=MagickTrue;\n  p=pixels;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    status=ReadPSDChannelPixels(image,channels,y,type,p,exception);\n    if (status == MagickFalse)\n      break;\n\n    p+=row_size;\n  }\n\n  compact_pixels=(unsigned char *) RelinquishMagickMemory(compact_pixels);\n  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  return(status);\n}\n#endif\n\nstatic MagickBooleanType ReadPSDChannel(Image *image,\n  const ImageInfo *image_info,const PSDInfo *psd_info,LayerInfo* layer_info,\n  const size_t channel,const PSDCompressionType compression,\n  ExceptionInfo *exception)\n{\n  Image\n    *channel_image,\n    *mask;\n\n  MagickOffsetType\n    offset;\n\n  MagickBooleanType\n    status;\n\n  channel_image=image;\n  mask=(Image *) NULL;\n  if (layer_info->channel_info[channel].type < -1)\n    {\n      const char\n        *option;\n      /*\n        Ignore mask that is not a user supplied layer mask, if the mask is\n        disabled or if the flags have unsupported values.\n      */\n      option=GetImageOption(image_info,\"psd:preserve-opacity-mask\");\n      if ((layer_info->channel_info[channel].type != -2) ||\n          (layer_info->mask.flags > 2) || ((layer_info->mask.flags & 0x02) &&\n           (IsStringTrue(option) == MagickFalse)))\n      {\n        SeekBlob(image,layer_info->channel_info[channel].size-2,SEEK_CUR);\n        return(MagickTrue);\n      }\n      mask=CloneImage(image,layer_info->mask.page.width,\n        layer_info->mask.page.height,MagickFalse,exception);\n      SetImageType(mask,GrayscaleType,exception);\n      channel_image=mask;\n    }\n\n  offset=TellBlob(image);\n  status=MagickTrue;\n  switch(compression)\n  {\n    case Raw:\n      status=ReadPSDChannelRaw(channel_image,psd_info->channels,\n        layer_info->channel_info[channel].type,exception);\n      break;\n    case RLE:\n      {\n        MagickOffsetType\n          *sizes;\n\n        sizes=ReadPSDRLESizes(channel_image,psd_info,channel_image->rows);\n        if (sizes == (MagickOffsetType *) NULL)\n          ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n            image->filename);\n        status=ReadPSDChannelRLE(channel_image,psd_info,\n          layer_info->channel_info[channel].type,sizes,exception);\n        sizes=(MagickOffsetType *) RelinquishMagickMemory(sizes);\n      }\n      break;\n    case ZipWithPrediction:\n    case ZipWithoutPrediction:\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n      status=ReadPSDChannelZip(channel_image,layer_info->channels,\n        layer_info->channel_info[channel].type,compression,\n        layer_info->channel_info[channel].size-2,exception);\n#else\n      (void) ThrowMagickException(exception,GetMagickModule(),\n          MissingDelegateWarning,\"DelegateLibrarySupportNotBuiltIn\",\n            \"'%s' (ZLIB)\",image->filename);\n#endif\n      break;\n    default:\n      (void) ThrowMagickException(exception,GetMagickModule(),TypeWarning,\n        \"CompressionNotSupported\",\"'%.20g'\",(double) compression);\n      break;\n  }\n\n  SeekBlob(image,offset+layer_info->channel_info[channel].size-2,SEEK_SET);\n  if (status == MagickFalse)\n    {\n      if (mask != (Image *) NULL)\n        DestroyImage(mask);\n      ThrowBinaryException(CoderError,\"UnableToDecompressImage\",\n        image->filename);\n    }\n  layer_info->mask.image=mask;\n  return(status);\n}\n\nstatic MagickBooleanType ReadPSDLayer(Image *image,const ImageInfo *image_info,\n  const PSDInfo *psd_info,LayerInfo* layer_info,ExceptionInfo *exception)\n{\n  char\n    message[MagickPathExtent];\n\n  MagickBooleanType\n    status;\n\n  PSDCompressionType\n    compression;\n\n  ssize_t\n    j;\n\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    setting up new layer image\");\n  if (psd_info->mode != IndexedMode)\n    (void) SetImageBackgroundColor(layer_info->image,exception);\n  layer_info->image->compose=PSDBlendModeToCompositeOperator(\n    layer_info->blendkey);\n  if (layer_info->visible == MagickFalse)\n    layer_info->image->compose=NoCompositeOp;\n  if (psd_info->mode == CMYKMode)\n    SetImageColorspace(layer_info->image,CMYKColorspace,exception);\n  else if ((psd_info->mode == BitmapMode) || (psd_info->mode == DuotoneMode) ||\n           (psd_info->mode == GrayscaleMode))\n    SetImageColorspace(layer_info->image,GRAYColorspace,exception);\n  /*\n    Set up some hidden attributes for folks that need them.\n  */\n  (void) FormatLocaleString(message,MagickPathExtent,\"%.20g\",\n    (double) layer_info->page.x);\n  (void) SetImageArtifact(layer_info->image,\"psd:layer.x\",message);\n  (void) FormatLocaleString(message,MagickPathExtent,\"%.20g\",\n    (double) layer_info->page.y);\n  (void) SetImageArtifact(layer_info->image,\"psd:layer.y\",message);\n  (void) FormatLocaleString(message,MagickPathExtent,\"%.20g\",(double)\n    layer_info->opacity);\n  (void) SetImageArtifact(layer_info->image,\"psd:layer.opacity\",message);\n  (void) SetImageProperty(layer_info->image,\"label\",(char *) layer_info->name,\n    exception);\n\n  status=MagickTrue;\n  for (j=0; j < (ssize_t) layer_info->channels; j++)\n  {\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    reading data for channel %.20g\",(double) j);\n\n    compression=(PSDCompressionType) ReadBlobShort(layer_info->image);\n    layer_info->image->compression=ConvertPSDCompression(compression);\n    if (layer_info->channel_info[j].type == -1)\n      layer_info->image->alpha_trait=BlendPixelTrait;\n\n    status=ReadPSDChannel(layer_info->image,image_info,psd_info,layer_info,j,\n      compression,exception);\n\n    if (status == MagickFalse)\n      break;\n  }\n\n  if (status != MagickFalse)\n    status=ApplyPSDLayerOpacity(layer_info->image,layer_info->opacity,\n      MagickFalse,exception);\n\n  if ((status != MagickFalse) &&\n      (layer_info->image->colorspace == CMYKColorspace))\n    status=NegateCMYK(layer_info->image,exception);\n\n  if ((status != MagickFalse) && (layer_info->mask.image != (Image *) NULL))\n    {\n      const char\n        *option;\n      \n      layer_info->mask.image->page.x=layer_info->mask.page.x;\n      layer_info->mask.image->page.y=layer_info->mask.page.y;\n      /* Do not composite the mask when it is disabled */\n      if ((layer_info->mask.flags & 0x02) == 0x02)\n        layer_info->mask.image->compose=NoCompositeOp;\n      else\n        status=ApplyPSDOpacityMask(layer_info->image,layer_info->mask.image,\n          layer_info->mask.background == 0 ? 0 : QuantumRange,MagickFalse,\n          exception);\n      option=GetImageOption(image_info,\"psd:preserve-opacity-mask\");\n      if (IsStringTrue(option) != MagickFalse)\n        PreservePSDOpacityMask(image,layer_info,exception);\n      layer_info->mask.image=DestroyImage(layer_info->mask.image);\n    }\n\n  return(status);\n}\n\nModuleExport MagickBooleanType ReadPSDLayers(Image *image,\n  const ImageInfo *image_info,const PSDInfo *psd_info,\n  const MagickBooleanType skip_layers,ExceptionInfo *exception)\n{\n  char\n    type[4];\n\n  LayerInfo\n    *layer_info;\n\n  MagickSizeType\n    size;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    count,\n    j,\n    number_layers;\n\n  size=GetPSDSize(psd_info,image);\n  if (size == 0)\n    {\n      /*\n        Skip layers & masks.\n      */\n      (void) ReadBlobLong(image);\n      count=ReadBlob(image,4,(unsigned char *) type);\n      ReversePSDString(image,type,4);\n      status=MagickFalse;\n      if ((count == 0) || (LocaleNCompare(type,\"8BIM\",4) != 0))\n        return(MagickTrue);\n      else\n        {\n          count=ReadBlob(image,4,(unsigned char *) type);\n          ReversePSDString(image,type,4);\n          if ((count != 0) && (LocaleNCompare(type,\"Lr16\",4) == 0))\n            size=GetPSDSize(psd_info,image);\n          else\n            return(MagickTrue);\n        }\n    }\n  status=MagickTrue;\n  if (size != 0)\n    {\n      layer_info=(LayerInfo *) NULL;\n      number_layers=(short) ReadBlobShort(image);\n\n      if (number_layers < 0)\n        {\n          /*\n            The first alpha channel in the merged result contains the\n            transparency data for the merged result.\n          */\n          number_layers=MagickAbsoluteValue(number_layers);\n          if (image->debug != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  negative layer count corrected for\");\n          image->alpha_trait=BlendPixelTrait;\n        }\n\n      /*\n        We only need to know if the image has an alpha channel\n      */\n      if (skip_layers != MagickFalse)\n        return(MagickTrue);\n\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  image contains %.20g layers\",(double) number_layers);\n\n      if (number_layers == 0)\n        ThrowBinaryException(CorruptImageError,\"InvalidNumberOfLayers\",\n          image->filename);\n\n      layer_info=(LayerInfo *) AcquireQuantumMemory((size_t) number_layers,\n        sizeof(*layer_info));\n      if (layer_info == (LayerInfo *) NULL)\n        {\n          if (image->debug != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  allocation of LayerInfo failed\");\n          ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n            image->filename);\n        }\n      (void) ResetMagickMemory(layer_info,0,(size_t) number_layers*\n        sizeof(*layer_info));\n\n      for (i=0; i < number_layers; i++)\n      {\n        ssize_t\n          x,\n          y;\n\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  reading layer #%.20g\",(double) i+1);\n        layer_info[i].page.y=ReadBlobSignedLong(image);\n        layer_info[i].page.x=ReadBlobSignedLong(image);\n        y=ReadBlobSignedLong(image);\n        x=ReadBlobSignedLong(image);\n        layer_info[i].page.width=(size_t) (x-layer_info[i].page.x);\n        layer_info[i].page.height=(size_t) (y-layer_info[i].page.y);\n        layer_info[i].channels=ReadBlobShort(image);\n        if (layer_info[i].channels > MaxPSDChannels)\n          {\n            layer_info=DestroyLayerInfo(layer_info,number_layers);\n            ThrowBinaryException(CorruptImageError,\"MaximumChannelsExceeded\",\n              image->filename);\n          }\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    offset(%.20g,%.20g), size(%.20g,%.20g), channels=%.20g\",\n            (double) layer_info[i].page.x,(double) layer_info[i].page.y,\n            (double) layer_info[i].page.height,(double)\n            layer_info[i].page.width,(double) layer_info[i].channels);\n        for (j=0; j < (ssize_t) layer_info[i].channels; j++)\n        {\n          layer_info[i].channel_info[j].type=(short) ReadBlobShort(image);\n          layer_info[i].channel_info[j].size=(size_t) GetPSDSize(psd_info,\n            image);\n          if (image->debug != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    channel[%.20g]: type=%.20g, size=%.20g\",(double) j,\n              (double) layer_info[i].channel_info[j].type,\n              (double) layer_info[i].channel_info[j].size);\n        }\n        count=ReadBlob(image,4,(unsigned char *) type);\n        ReversePSDString(image,type,4);\n        if ((count == 0) || (LocaleNCompare(type,\"8BIM\",4) != 0))\n          {\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  layer type was %.4s instead of 8BIM\", type);\n            layer_info=DestroyLayerInfo(layer_info,number_layers);\n            ThrowBinaryException(CorruptImageError,\"ImproperImageHeader\",\n              image->filename);\n          }\n        count=ReadBlob(image,4,(unsigned char *) layer_info[i].blendkey);\n        ReversePSDString(image,layer_info[i].blendkey,4);\n        layer_info[i].opacity=(Quantum) ScaleCharToQuantum((unsigned char)\n          ReadBlobByte(image));\n        layer_info[i].clipping=(unsigned char) ReadBlobByte(image);\n        layer_info[i].flags=(unsigned char) ReadBlobByte(image);\n        layer_info[i].visible=!(layer_info[i].flags & 0x02);\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"   blend=%.4s, opacity=%.20g, clipping=%s, flags=%d, visible=%s\",\n            layer_info[i].blendkey,(double) layer_info[i].opacity,\n            layer_info[i].clipping ? \"true\" : \"false\",layer_info[i].flags,\n            layer_info[i].visible ? \"true\" : \"false\");\n        (void) ReadBlobByte(image);  /* filler */\n\n        size=ReadBlobLong(image);\n        if (size != 0)\n          {\n            MagickSizeType\n              combined_length,\n              length;\n\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    layer contains additional info\");\n            length=ReadBlobLong(image);\n            combined_length=length+4;\n            if (length != 0)\n              {\n                /*\n                  Layer mask info.\n                */\n                layer_info[i].mask.page.y=ReadBlobSignedLong(image);\n                layer_info[i].mask.page.x=ReadBlobSignedLong(image);\n                layer_info[i].mask.page.height=(size_t) (ReadBlobLong(image)-\n                  layer_info[i].mask.page.y);\n                layer_info[i].mask.page.width=(size_t) (ReadBlobLong(image)-\n                  layer_info[i].mask.page.x);\n                layer_info[i].mask.background=(unsigned char) ReadBlobByte(\n                  image);\n                layer_info[i].mask.flags=(unsigned char) ReadBlobByte(image);\n                if (!(layer_info[i].mask.flags & 0x01))\n                  {\n                    layer_info[i].mask.page.y=layer_info[i].mask.page.y-\n                      layer_info[i].page.y;\n                    layer_info[i].mask.page.x=layer_info[i].mask.page.x-\n                      layer_info[i].page.x;\n                  }\n                if (image->debug != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"      layer mask: offset(%.20g,%.20g), size(%.20g,%.20g), length=%.20g\",\n                    (double) layer_info[i].mask.page.x,(double) \n                    layer_info[i].mask.page.y,(double) layer_info[i].mask.page.width,\n                    (double) layer_info[i].mask.page.height,(double)\n                    ((MagickOffsetType) length)-18);\n                /*\n                  Skip over the rest of the layer mask information.\n                */\n                if (DiscardBlobBytes(image,(MagickSizeType) (length-18)) == MagickFalse)\n                  {\n                    layer_info=DestroyLayerInfo(layer_info,number_layers);\n                    ThrowBinaryException(CorruptImageError,\"UnexpectedEndOfFile\",\n                      image->filename);\n                  }\n              }\n            length=ReadBlobLong(image);\n            combined_length+=length+4;\n            if (length != 0)\n              {\n                /*\n                  Layer blending ranges info.\n                */\n                if (image->debug != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"      layer blending ranges: length=%.20g\",(double)\n                    ((MagickOffsetType) length));\n                /*\n                  We read it, but don't use it...\n                */\n                for (j=0; j < (ssize_t) length; j+=8)\n                {\n                  size_t blend_source=ReadBlobLong(image);\n                  size_t blend_dest=ReadBlobLong(image);\n                  if (image->debug != MagickFalse)\n                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                      \"        source(%x), dest(%x)\",(unsigned int)\n                      blend_source,(unsigned int) blend_dest);\n                }\n              }\n            /*\n              Layer name.\n            */\n            length=(MagickSizeType) (unsigned char) ReadBlobByte(image);\n            combined_length+=length+1;\n            if (length > 0)\n              (void) ReadBlob(image,(size_t) length++,layer_info[i].name);\n            layer_info[i].name[length]='\\0';\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"      layer name: %s\",layer_info[i].name);\n            if ((length % 4) != 0)\n              {\n                length=4-(length % 4);\n                combined_length+=length;\n                /* Skip over the padding of the layer name */\n                if (DiscardBlobBytes(image,length) == MagickFalse)\n                  {\n                    layer_info=DestroyLayerInfo(layer_info,number_layers);\n                    ThrowBinaryException(CorruptImageError,\n                      \"UnexpectedEndOfFile\",image->filename);\n                  }\n              }\n            length=(MagickSizeType) size-combined_length;\n            if (length > 0)\n              {\n                unsigned char\n                  *info;\n\n                layer_info[i].info=AcquireStringInfo((const size_t) length);\n                info=GetStringInfoDatum(layer_info[i].info);\n                (void) ReadBlob(image,(const size_t) length,info);\n              }\n          }\n      }\n\n      for (i=0; i < number_layers; i++)\n      {\n        if ((layer_info[i].page.width == 0) ||\n              (layer_info[i].page.height == 0))\n          {\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"      layer data is empty\");\n            if (layer_info[i].info != (StringInfo *) NULL)\n              layer_info[i].info=DestroyStringInfo(layer_info[i].info);\n            continue;\n          }\n\n        /*\n          Allocate layered image.\n        */\n        layer_info[i].image=CloneImage(image,layer_info[i].page.width,\n          layer_info[i].page.height,MagickFalse,exception);\n        if (layer_info[i].image == (Image *) NULL)\n          {\n            layer_info=DestroyLayerInfo(layer_info,number_layers);\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  allocation of image for layer %.20g failed\",(double) i);\n            ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n              image->filename);\n          }\n\n        if (layer_info[i].info != (StringInfo *) NULL)\n          {\n            (void) SetImageProfile(layer_info[i].image,\"psd:additional-info\",\n              layer_info[i].info,exception);\n            layer_info[i].info=DestroyStringInfo(layer_info[i].info);\n          }\n      }\n\n      if (image_info->ping == MagickFalse)\n        {\n          for (i=0; i < number_layers; i++)\n          {\n            if (layer_info[i].image == (Image *) NULL)\n              {\n                for (j=0; j < layer_info[i].channels; j++)\n                {\n                  if (DiscardBlobBytes(image,(MagickSizeType)\n                      layer_info[i].channel_info[j].size) == MagickFalse)\n                    {\n                      layer_info=DestroyLayerInfo(layer_info,number_layers);\n                      ThrowBinaryException(CorruptImageError,\n                        \"UnexpectedEndOfFile\",image->filename);\n                    }\n                }\n                continue;\n              }\n\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  reading data for layer %.20g\",(double) i);\n\n            status=ReadPSDLayer(image,image_info,psd_info,&layer_info[i],\n              exception);\n            if (status == MagickFalse)\n              break;\n\n            status=SetImageProgress(image,LoadImagesTag,i,(MagickSizeType)\n              number_layers);\n            if (status == MagickFalse)\n              break;\n          }\n        }\n\n      if (status != MagickFalse)\n        {\n          for (i=0; i < number_layers; i++)\n          {\n            if (layer_info[i].image == (Image *) NULL)\n              {\n                for (j=i; j < number_layers - 1; j++)\n                  layer_info[j] = layer_info[j+1];\n                number_layers--;\n                i--;\n              }\n          }\n\n          if (number_layers > 0)\n            {\n              for (i=0; i < number_layers; i++)\n              {\n                if (i > 0)\n                  layer_info[i].image->previous=layer_info[i-1].image;\n                if (i < (number_layers-1))\n                  layer_info[i].image->next=layer_info[i+1].image;\n                layer_info[i].image->page=layer_info[i].page;\n              }\n              image->next=layer_info[0].image;\n              layer_info[0].image->previous=image;\n            }\n          layer_info=(LayerInfo *) RelinquishMagickMemory(layer_info);\n        }\n      else\n        layer_info=DestroyLayerInfo(layer_info,number_layers);\n    }\n\n  return(status);\n}\n\nstatic MagickBooleanType ReadPSDMergedImage(const ImageInfo *image_info,\n  Image *image,const PSDInfo *psd_info,ExceptionInfo *exception)\n{\n  MagickOffsetType\n    *sizes;\n\n  MagickBooleanType\n    status;\n\n  PSDCompressionType\n    compression;\n\n  register ssize_t\n    i;\n\n  compression=(PSDCompressionType) ReadBlobMSBShort(image);\n  image->compression=ConvertPSDCompression(compression);\n\n  if (compression != Raw && compression != RLE)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        TypeWarning,\"CompressionNotSupported\",\"'%.20g'\",(double) compression);\n      return(MagickFalse);\n    }\n\n  sizes=(MagickOffsetType *) NULL;\n  if (compression == RLE)\n    {\n      sizes=ReadPSDRLESizes(image,psd_info,image->rows*psd_info->channels);\n      if (sizes == (MagickOffsetType *) NULL)\n        ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n          image->filename);\n    }\n\n  status=MagickTrue;\n  for (i=0; i < (ssize_t) psd_info->channels; i++)\n  {\n    if (compression == RLE)\n      status=ReadPSDChannelRLE(image,psd_info,i,sizes+(i*image->rows),\n        exception);\n    else\n      status=ReadPSDChannelRaw(image,psd_info->channels,i,exception);\n\n    if (status != MagickFalse)\n      status=SetImageProgress(image,LoadImagesTag,i,psd_info->channels);\n\n    if (status == MagickFalse)\n      break;\n  }\n\n  if ((status != MagickFalse) && (image->colorspace == CMYKColorspace))\n    status=NegateCMYK(image,exception);\n\n  if (status != MagickFalse)\n    status=CorrectPSDAlphaBlend(image_info,image,exception);\n\n  sizes=(MagickOffsetType *) RelinquishMagickMemory(sizes);\n\n  return(status);\n}\n\nstatic Image *ReadPSDImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  MagickBooleanType\n    has_merged_image,\n    skip_layers;\n\n  MagickOffsetType\n    offset;\n\n  MagickSizeType\n    length;\n\n  MagickBooleanType\n    status;\n\n  PSDInfo\n    psd_info;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    count;\n\n  unsigned char\n    *data;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read image header.\n  */\n  image->endian=MSBEndian;\n  count=ReadBlob(image,4,(unsigned char *) psd_info.signature);\n  psd_info.version=ReadBlobMSBShort(image);\n  if ((count == 0) || (LocaleNCompare(psd_info.signature,\"8BPS\",4) != 0) ||\n      ((psd_info.version != 1) && (psd_info.version != 2)))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  (void) ReadBlob(image,6,psd_info.reserved);\n  psd_info.channels=ReadBlobMSBShort(image);\n  if (psd_info.channels > MaxPSDChannels)\n    ThrowReaderException(CorruptImageError,\"MaximumChannelsExceeded\");\n  psd_info.rows=ReadBlobMSBLong(image);\n  psd_info.columns=ReadBlobMSBLong(image);\n  if ((psd_info.version == 1) && ((psd_info.rows > 30000) ||\n      (psd_info.columns > 30000)))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  psd_info.depth=ReadBlobMSBShort(image);\n  if ((psd_info.depth != 1) && (psd_info.depth != 8) && (psd_info.depth != 16))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  psd_info.mode=ReadBlobMSBShort(image);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Image is %.20g x %.20g with channels=%.20g, depth=%.20g, mode=%s\",\n      (double) psd_info.columns,(double) psd_info.rows,(double)\n      psd_info.channels,(double) psd_info.depth,ModeToString((PSDImageType)\n      psd_info.mode));\n  /*\n    Initialize image.\n  */\n  image->depth=psd_info.depth;\n  image->columns=psd_info.columns;\n  image->rows=psd_info.rows;\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  if (SetImageBackgroundColor(image,exception) == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if (psd_info.mode == LabMode)\n    SetImageColorspace(image,LabColorspace,exception);\n  if (psd_info.mode == CMYKMode)\n    {\n      SetImageColorspace(image,CMYKColorspace,exception);\n      if (psd_info.channels > 4)\n        SetImageAlphaChannel(image,ActivateAlphaChannel,exception);\n    }\n  else if ((psd_info.mode == BitmapMode) || (psd_info.mode == GrayscaleMode) ||\n           (psd_info.mode == DuotoneMode))\n    {\n      status=AcquireImageColormap(image,psd_info.depth != 16 ? 256 : 65536,\n        exception);\n      if (status == MagickFalse)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  Image colormap allocated\");\n      SetImageColorspace(image,GRAYColorspace,exception);\n      if (psd_info.channels > 1)\n        SetImageAlphaChannel(image,ActivateAlphaChannel,exception);\n    }\n  else\n    if (psd_info.channels > 3)\n      SetImageAlphaChannel(image,ActivateAlphaChannel,exception);\n  /*\n    Read PSD raster colormap only present for indexed and duotone images.\n  */\n  length=ReadBlobMSBLong(image);\n  if (length != 0)\n    {\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  reading colormap\");\n      if (psd_info.mode == DuotoneMode)\n        {\n          /*\n            Duotone image data;  the format of this data is undocumented.\n          */\n          data=(unsigned char *) AcquireQuantumMemory((size_t) length,\n            sizeof(*data));\n          if (data == (unsigned char *) NULL)\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          (void) ReadBlob(image,(size_t) length,data);\n          data=(unsigned char *) RelinquishMagickMemory(data);\n        }\n      else\n        {\n          size_t\n            number_colors;\n\n          /*\n            Read PSD raster colormap.\n          */\n          number_colors=length/3;\n          if (number_colors > 65536)\n            ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n          if (AcquireImageColormap(image,number_colors,exception) == MagickFalse)\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          for (i=0; i < (ssize_t) image->colors; i++)\n            image->colormap[i].red=ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n          for (i=0; i < (ssize_t) image->colors; i++)\n            image->colormap[i].green=ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n          for (i=0; i < (ssize_t) image->colors; i++)\n            image->colormap[i].blue=ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n          image->alpha_trait=UndefinedPixelTrait;\n        }\n    }\n  if ((image->depth == 1) && (image->storage_class != PseudoClass))\n    ThrowReaderException(CorruptImageError, \"ImproperImageHeader\");\n  has_merged_image=MagickTrue;\n  length=ReadBlobMSBLong(image);\n  if (length != 0)\n    {\n      unsigned char\n        *blocks;\n\n      /*\n        Image resources block.\n      */\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  reading image resource blocks - %.20g bytes\",(double)\n          ((MagickOffsetType) length));\n      blocks=(unsigned char *) AcquireQuantumMemory((size_t) length,\n        sizeof(*blocks));\n      if (blocks == (unsigned char *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      count=ReadBlob(image,(size_t) length,blocks);\n      if ((count != (ssize_t) length) || (length < 4) ||\n          (LocaleNCompare((char *) blocks,\"8BIM\",4) != 0))\n        {\n          blocks=(unsigned char *) RelinquishMagickMemory(blocks);\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        }\n      ParseImageResourceBlocks(image,blocks,(size_t) length,&has_merged_image,\n        exception);\n      blocks=(unsigned char *) RelinquishMagickMemory(blocks);\n    }\n  /*\n    Layer and mask block.\n  */\n  length=GetPSDSize(&psd_info,image);\n  if (length == 8)\n    {\n      length=ReadBlobMSBLong(image);\n      length=ReadBlobMSBLong(image);\n    }\n  offset=TellBlob(image);\n  skip_layers=MagickFalse;\n  if ((image_info->number_scenes == 1) && (image_info->scene == 0) &&\n      (has_merged_image != MagickFalse))\n    {\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  read composite only\");\n      skip_layers=MagickTrue;\n    }\n  if (length == 0)\n    {\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  image has no layers\");\n    }\n  else\n    {\n      if (ReadPSDLayers(image,image_info,&psd_info,skip_layers,exception) !=\n          MagickTrue)\n        {\n          (void) CloseBlob(image);\n          image=DestroyImageList(image);\n          return((Image *) NULL);\n        }\n\n      /*\n         Skip the rest of the layer and mask information.\n      */\n      SeekBlob(image,offset+length,SEEK_SET);\n    }\n  /*\n    If we are only \"pinging\" the image, then we're done - so return.\n  */\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(GetFirstImageInList(image));\n    }\n  /*\n    Read the precombined layer, present for PSD < 4 compatibility.\n  */\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  reading the precombined layer\");\n  if ((has_merged_image != MagickFalse) || (GetImageListLength(image) == 1))\n    has_merged_image=(MagickBooleanType) ReadPSDMergedImage(image_info,image,\n      &psd_info,exception);\n  if ((has_merged_image == MagickFalse) && (GetImageListLength(image) == 1) &&\n      (length != 0))\n    {\n      SeekBlob(image,offset,SEEK_SET);\n      status=ReadPSDLayers(image,image_info,&psd_info,MagickFalse,exception);\n      if (status != MagickTrue)\n        {\n          (void) CloseBlob(image);\n          image=DestroyImageList(image);\n          return((Image *) NULL);\n        }\n    }\n  if (has_merged_image == MagickFalse)\n    {\n      Image\n        *merged;\n\n      if (GetImageListLength(image) == 1)\n        ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n      SetImageAlphaChannel(image,TransparentAlphaChannel,exception);\n      image->background_color.alpha=TransparentAlpha;\n      image->background_color.alpha_trait=BlendPixelTrait;\n      merged=MergeImageLayers(image,FlattenLayer,exception);\n      ReplaceImageInList(&image,merged);\n    }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r P S D I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterPSDImage() adds properties for the PSD image format to\n%  the list of supported formats.  The properties include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterPSDImage method is:\n%\n%      size_t RegisterPSDImage(void)\n%\n*/\nModuleExport size_t RegisterPSDImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"PSD\",\"PSB\",\"Adobe Large Document Format\");\n  entry->decoder=(DecodeImageHandler *) ReadPSDImage;\n  entry->encoder=(EncodeImageHandler *) WritePSDImage;\n  entry->magick=(IsImageFormatHandler *) IsPSD;\n  entry->flags|=CoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PSD\",\"PSD\",\"Adobe Photoshop bitmap\");\n  entry->decoder=(DecodeImageHandler *) ReadPSDImage;\n  entry->encoder=(EncodeImageHandler *) WritePSDImage;\n  entry->magick=(IsImageFormatHandler *) IsPSD;\n  entry->flags|=CoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r P S D I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterPSDImage() removes format registrations made by the\n%  PSD module from the list of supported formats.\n%\n%  The format of the UnregisterPSDImage method is:\n%\n%      UnregisterPSDImage(void)\n%\n*/\nModuleExport void UnregisterPSDImage(void)\n{\n  (void) UnregisterMagickInfo(\"PSB\");\n  (void) UnregisterMagickInfo(\"PSD\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e P S D I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WritePSDImage() writes an image in the Adobe Photoshop encoded image format.\n%\n%  The format of the WritePSDImage method is:\n%\n%      MagickBooleanType WritePSDImage(const ImageInfo *image_info,Image *image,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline ssize_t SetPSDOffset(const PSDInfo *psd_info,Image *image,\n  const size_t offset)\n{\n  if (psd_info->version == 1)\n    return(WriteBlobMSBShort(image,(unsigned short) offset));\n  return(WriteBlobMSBLong(image,(unsigned short) offset));\n}\n\nstatic inline ssize_t WritePSDOffset(const PSDInfo *psd_info,Image *image,\n  const MagickSizeType size,const MagickSizeType offset)\n{\n  MagickSizeType\n    current_offset;\n\n  ssize_t\n    result;\n\n  current_offset=TellBlob(image);\n  SeekBlob(image,offset,SEEK_SET);\n  if (psd_info->version == 1)\n    result=WriteBlobMSBShort(image,(unsigned short) size);\n  else\n    result=(WriteBlobMSBLong(image,(unsigned short) size));\n  SeekBlob(image,current_offset,SEEK_SET);\n  return(result);\n}\n\nstatic inline ssize_t SetPSDSize(const PSDInfo *psd_info,Image *image,\n  const MagickSizeType size)\n{\n  if (psd_info->version == 1)\n    return(WriteBlobMSBLong(image,(unsigned int) size));\n  return(WriteBlobMSBLongLong(image,size));\n}\n\nstatic inline ssize_t WritePSDSize(const PSDInfo *psd_info,Image *image,\n  const MagickSizeType size,const MagickSizeType offset)\n{\n  MagickSizeType\n    current_offset;\n\n  ssize_t\n    result;\n\n  current_offset=TellBlob(image);\n  SeekBlob(image,offset,SEEK_SET);\n  if (psd_info->version == 1)\n    result=WriteBlobMSBLong(image,(unsigned int) size);\n  else\n    result=WriteBlobMSBLongLong(image,size);\n  SeekBlob(image,current_offset,SEEK_SET);\n  return(result);\n}\n\nstatic size_t PSDPackbitsEncodeImage(Image *image,const size_t length,\n  const unsigned char *pixels,unsigned char *compact_pixels,\n  ExceptionInfo *exception)\n{\n  int\n    count;\n\n  register ssize_t\n    i,\n    j;\n\n  register unsigned char\n    *q;\n\n  unsigned char\n    *packbits;\n\n  /*\n    Compress pixels with Packbits encoding.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(pixels != (unsigned char *) NULL);\n  assert(compact_pixels != (unsigned char *) NULL);\n  packbits=(unsigned char *) AcquireQuantumMemory(128UL,sizeof(*packbits));\n  if (packbits == (unsigned char *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  q=compact_pixels;\n  for (i=(ssize_t) length; i != 0; )\n  {\n    switch (i)\n    {\n      case 1:\n      {\n        i--;\n        *q++=(unsigned char) 0;\n        *q++=(*pixels);\n        break;\n      }\n      case 2:\n      {\n        i-=2;\n        *q++=(unsigned char) 1;\n        *q++=(*pixels);\n        *q++=pixels[1];\n        break;\n      }\n      case 3:\n      {\n        i-=3;\n        if ((*pixels == *(pixels+1)) && (*(pixels+1) == *(pixels+2)))\n          {\n            *q++=(unsigned char) ((256-3)+1);\n            *q++=(*pixels);\n            break;\n          }\n        *q++=(unsigned char) 2;\n        *q++=(*pixels);\n        *q++=pixels[1];\n        *q++=pixels[2];\n        break;\n      }\n      default:\n      {\n        if ((*pixels == *(pixels+1)) && (*(pixels+1) == *(pixels+2)))\n          {\n            /*\n              Packed run.\n            */\n            count=3;\n            while (((ssize_t) count < i) && (*pixels == *(pixels+count)))\n            {\n              count++;\n              if (count >= 127)\n                break;\n            }\n            i-=count;\n            *q++=(unsigned char) ((256-count)+1);\n            *q++=(*pixels);\n            pixels+=count;\n            break;\n          }\n        /*\n          Literal run.\n        */\n        count=0;\n        while ((*(pixels+count) != *(pixels+count+1)) ||\n               (*(pixels+count+1) != *(pixels+count+2)))\n        {\n          packbits[count+1]=pixels[count];\n          count++;\n          if (((ssize_t) count >= (i-3)) || (count >= 127))\n            break;\n        }\n        i-=count;\n        *packbits=(unsigned char) (count-1);\n        for (j=0; j <= (ssize_t) count; j++)\n          *q++=packbits[j];\n        pixels+=count;\n        break;\n      }\n    }\n  }\n  *q++=(unsigned char) 128;  /* EOD marker */\n  packbits=(unsigned char *) RelinquishMagickMemory(packbits);\n  return((size_t) (q-compact_pixels));\n}\n\nstatic size_t WriteCompressionStart(const PSDInfo *psd_info,Image *image,\n  const Image *next_image,const ssize_t channels)\n{\n  size_t\n    length;\n\n  ssize_t\n    i,\n    y;\n\n  if (next_image->compression == RLECompression)\n    {\n      length=WriteBlobMSBShort(image,RLE);\n      for (i=0; i < channels; i++)\n        for (y=0; y < (ssize_t) next_image->rows; y++)\n          length+=SetPSDOffset(psd_info,image,0);\n    }\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n  else if (next_image->compression == ZipCompression)\n    length=WriteBlobMSBShort(image,ZipWithoutPrediction);\n#endif\n  else\n    length=WriteBlobMSBShort(image,Raw);\n  return(length);\n}\n\nstatic size_t WritePSDChannel(const PSDInfo *psd_info,\n  const ImageInfo *image_info,Image *image,Image *next_image,\n  const QuantumType quantum_type, unsigned char *compact_pixels,\n  MagickOffsetType size_offset,const MagickBooleanType separate,\n  ExceptionInfo *exception)\n{\n  int\n    y;\n\n  MagickBooleanType\n    monochrome;\n\n  QuantumInfo\n    *quantum_info;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i;\n\n  size_t\n    count,\n    length;\n\n  unsigned char\n    *pixels;\n\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n\n#define CHUNK 16384\n\n  int\n    flush,\n    level;\n\n  unsigned char\n    *compressed_pixels;\n\n  z_stream\n    stream;\n\n  compressed_pixels=(unsigned char *) NULL;\n  flush=Z_NO_FLUSH;\n#endif\n  count=0;\n  if (separate != MagickFalse)\n    {\n      size_offset=TellBlob(image)+2;\n      count+=WriteCompressionStart(psd_info,image,next_image,1);\n    }\n  if (next_image->depth > 8)\n    next_image->depth=16;\n  monochrome=IsImageMonochrome(image) && (image->depth == 1) ?\n    MagickTrue : MagickFalse;\n  quantum_info=AcquireQuantumInfo(image_info,next_image);\n  if (quantum_info == (QuantumInfo *) NULL)\n    return(0);\n  pixels=(unsigned char *) GetQuantumPixels(quantum_info);\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n  if (next_image->compression == ZipCompression)\n    {\n      compressed_pixels=(unsigned char *) AcquireQuantumMemory(CHUNK,\n        sizeof(*compressed_pixels));\n      if (compressed_pixels == (unsigned char *) NULL)\n        {\n          quantum_info=DestroyQuantumInfo(quantum_info);\n          return(0);\n        }\n      ResetMagickMemory(&stream,0,sizeof(stream));\n      stream.data_type=Z_BINARY;\n      level=Z_DEFAULT_COMPRESSION;\n      if ((image_info->quality > 0 && image_info->quality < 10))\n        level=(int) image_info->quality;\n      if (deflateInit(&stream,level) != Z_OK)\n        {\n          quantum_info=DestroyQuantumInfo(quantum_info);\n          return(0);\n        }\n    }\n#endif\n  for (y=0; y < (ssize_t) next_image->rows; y++)\n  {\n    p=GetVirtualPixels(next_image,0,y,next_image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    length=ExportQuantumPixels(next_image,(CacheView *) NULL,quantum_info,\n      quantum_type,pixels,exception);\n    if (monochrome != MagickFalse)\n      for (i=0; i < (ssize_t) length; i++)\n        pixels[i]=(~pixels[i]);\n    if (next_image->compression == RLECompression)\n      {\n        length=PSDPackbitsEncodeImage(image,length,pixels,compact_pixels,\n          exception);\n        count+=WriteBlob(image,length,compact_pixels);\n        size_offset+=WritePSDOffset(psd_info,image,length,size_offset);\n      }\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n    else if (next_image->compression == ZipCompression)\n      {\n        stream.avail_in=(uInt) length;\n        stream.next_in=(Bytef *) pixels;\n        if (y == (ssize_t) next_image->rows-1)\n          flush=Z_FINISH;\n        do {\n            stream.avail_out=(uInt) CHUNK;\n            stream.next_out=(Bytef *) compressed_pixels;\n            if (deflate(&stream,flush) == Z_STREAM_ERROR)\n              break;\n            length=(size_t) CHUNK-stream.avail_out;\n            if (length > 0)\n              count+=WriteBlob(image,length,compressed_pixels);\n        } while (stream.avail_out == 0);\n      }\n#endif\n    else\n      count+=WriteBlob(image,length,pixels);\n  }\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n  if (next_image->compression == ZipCompression)\n    {\n      (void) deflateEnd(&stream);\n      compressed_pixels=(unsigned char *) RelinquishMagickMemory(\n        compressed_pixels);\n    }\n#endif\n  quantum_info=DestroyQuantumInfo(quantum_info);\n  return(count);\n}\n\nstatic unsigned char *AcquireCompactPixels(const Image *image,\n  ExceptionInfo *exception)\n{\n  size_t\n    packet_size;\n\n  unsigned char\n    *compact_pixels;\n\n  packet_size=image->depth > 8UL ? 2UL : 1UL;\n  compact_pixels=(unsigned char *) AcquireQuantumMemory((9*\n    image->columns)+1,packet_size*sizeof(*compact_pixels));\n  if (compact_pixels == (unsigned char *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\n        image->filename);\n    }\n  return(compact_pixels);\n}\n\nstatic size_t WritePSDChannels(const PSDInfo *psd_info,\n  const ImageInfo *image_info,Image *image,Image *next_image,\n  MagickOffsetType size_offset,const MagickBooleanType separate,\n  ExceptionInfo *exception)\n{\n  Image\n    *mask;\n\n  MagickOffsetType\n    rows_offset;\n\n  size_t\n    channels,\n    count,\n    length,\n    offset_length;\n\n  unsigned char\n    *compact_pixels;\n\n  count=0;\n  offset_length=0;\n  rows_offset=0;\n  compact_pixels=(unsigned char *) NULL;\n  if (next_image->compression == RLECompression)\n    {\n      compact_pixels=AcquireCompactPixels(image,exception);\n      if (compact_pixels == (unsigned char *) NULL)\n        return(0);\n    }\n  channels=1;\n  if (separate == MagickFalse)\n    {\n      if (next_image->storage_class != PseudoClass)\n        {\n          if (IsImageGray(next_image) == MagickFalse)\n            channels=next_image->colorspace == CMYKColorspace ? 4 : 3;\n          if (next_image->alpha_trait != UndefinedPixelTrait)\n            channels++;\n        }\n      rows_offset=TellBlob(image)+2;\n      count+=WriteCompressionStart(psd_info,image,next_image,channels);\n      offset_length=(next_image->rows*(psd_info->version == 1 ? 2 : 4));\n    }\n  size_offset+=2;\n  if (next_image->storage_class == PseudoClass)\n    {\n      length=WritePSDChannel(psd_info,image_info,image,next_image,\n        IndexQuantum,compact_pixels,rows_offset,separate,exception);\n      if (separate != MagickFalse)\n        size_offset+=WritePSDSize(psd_info,image,length,size_offset)+2;\n      else\n        rows_offset+=offset_length;\n      count+=length;\n    }\n  else\n    {\n      if (IsImageGray(next_image) != MagickFalse)\n        {\n          length=WritePSDChannel(psd_info,image_info,image,next_image,\n            GrayQuantum,compact_pixels,rows_offset,separate,exception);\n          if (separate != MagickFalse)\n            size_offset+=WritePSDSize(psd_info,image,length,size_offset)+2;\n          else\n            rows_offset+=offset_length;\n          count+=length;\n        }\n      else\n        {\n          if (next_image->colorspace == CMYKColorspace)\n            (void) NegateCMYK(next_image,exception);\n\n          length=WritePSDChannel(psd_info,image_info,image,next_image,\n            RedQuantum,compact_pixels,rows_offset,separate,exception);\n          if (separate != MagickFalse)\n            size_offset+=WritePSDSize(psd_info,image,length,size_offset)+2;\n          else\n            rows_offset+=offset_length;\n          count+=length;\n\n          length=WritePSDChannel(psd_info,image_info,image,next_image,\n            GreenQuantum,compact_pixels,rows_offset,separate,exception);\n          if (separate != MagickFalse)\n            size_offset+=WritePSDSize(psd_info,image,length,size_offset)+2;\n          else\n            rows_offset+=offset_length;\n          count+=length;\n\n          length=WritePSDChannel(psd_info,image_info,image,next_image,\n            BlueQuantum,compact_pixels,rows_offset,separate,exception);\n          if (separate != MagickFalse)\n            size_offset+=WritePSDSize(psd_info,image,length,size_offset)+2;\n          else\n            rows_offset+=offset_length;\n          count+=length;\n\n          if (next_image->colorspace == CMYKColorspace)\n            {\n              length=WritePSDChannel(psd_info,image_info,image,next_image,\n                BlackQuantum,compact_pixels,rows_offset,separate,exception);\n              if (separate != MagickFalse)\n                size_offset+=WritePSDSize(psd_info,image,length,size_offset)+2;\n              else\n                rows_offset+=offset_length;\n              count+=length;\n            }\n        }\n      if (next_image->alpha_trait != UndefinedPixelTrait)\n        {\n          length=WritePSDChannel(psd_info,image_info,image,next_image,\n            AlphaQuantum,compact_pixels,rows_offset,separate,exception);\n          if (separate != MagickFalse)\n            size_offset+=WritePSDSize(psd_info,image,length,size_offset)+2;\n          else\n            rows_offset+=offset_length;\n          count+=length;\n        }\n    }\n  compact_pixels=(unsigned char *) RelinquishMagickMemory(compact_pixels);\n  if (next_image->colorspace == CMYKColorspace)\n    (void) NegateCMYK(next_image,exception);\n  if (separate != MagickFalse)\n    {\n      const char\n        *property;\n\n      property=GetImageArtifact(next_image,\"psd:opacity-mask\");\n      if (property != (const char *) NULL)\n        {\n          mask=(Image *) GetImageRegistry(ImageRegistryType,property,\n            exception);\n          if (mask != (Image *) NULL)\n            {\n              if (mask->compression == RLECompression)\n                {\n                  compact_pixels=AcquireCompactPixels(mask,exception);\n                  if (compact_pixels == (unsigned char *) NULL)\n                    return(0);\n                }\n              length=WritePSDChannel(psd_info,image_info,image,mask,\n                RedQuantum,compact_pixels,rows_offset,MagickTrue,exception);\n              (void) WritePSDSize(psd_info,image,length,size_offset);\n              count+=length;\n              compact_pixels=(unsigned char *) RelinquishMagickMemory(\n                compact_pixels);\n            }\n        }\n    }\n  return(count);\n}\n\nstatic size_t WritePascalString(Image *image,const char *value,size_t padding)\n{\n  size_t\n    count,\n    length;\n\n  register ssize_t\n    i;\n\n  /*\n    Max length is 255.\n  */\n  count=0;\n  length=(strlen(value) > 255UL ) ? 255UL : strlen(value);\n  if (length ==  0)\n    count+=WriteBlobByte(image,0);\n  else\n    {\n      count+=WriteBlobByte(image,(unsigned char) length);\n      count+=WriteBlob(image,length,(const unsigned char *) value);\n    }\n  length++;\n  if ((length % padding) == 0)\n    return(count);\n  for (i=0; i < (ssize_t) (padding-(length % padding)); i++)\n    count+=WriteBlobByte(image,0);\n  return(count);\n}\n\nstatic void WriteResolutionResourceBlock(Image *image)\n{\n  double\n    x_resolution,\n    y_resolution;\n\n  unsigned short\n    units;\n\n  if (image->units == PixelsPerCentimeterResolution)\n    {\n      x_resolution=2.54*65536.0*image->resolution.x+0.5;\n      y_resolution=2.54*65536.0*image->resolution.y+0.5;\n      units=2;\n    }\n  else\n    {\n      x_resolution=65536.0*image->resolution.x+0.5;\n      y_resolution=65536.0*image->resolution.y+0.5;\n      units=1;\n    }\n  (void) WriteBlob(image,4,(const unsigned char *) \"8BIM\");\n  (void) WriteBlobMSBShort(image,0x03ED);\n  (void) WriteBlobMSBShort(image,0);\n  (void) WriteBlobMSBLong(image,16); /* resource size */\n  (void) WriteBlobMSBLong(image,(unsigned int) (x_resolution+0.5));\n  (void) WriteBlobMSBShort(image,units); /* horizontal resolution unit */\n  (void) WriteBlobMSBShort(image,units); /* width unit */\n  (void) WriteBlobMSBLong(image,(unsigned int) (y_resolution+0.5));\n  (void) WriteBlobMSBShort(image,units); /* vertical resolution unit */\n  (void) WriteBlobMSBShort(image,units); /* height unit */\n}\n\nstatic inline size_t WriteChannelSize(const PSDInfo *psd_info,Image *image,\n  const signed short channel)\n{\n  size_t\n    count;\n\n  count=WriteBlobMSBSignedShort(image,channel);\n  count+=SetPSDSize(psd_info,image,0);\n  return(count);\n}\n\nstatic void RemoveICCProfileFromResourceBlock(StringInfo *bim_profile)\n{\n  register const unsigned char\n    *p;\n\n  size_t\n    length;\n\n  unsigned char\n    *datum;\n\n  unsigned int\n    count,\n    long_sans;\n\n  unsigned short\n    id,\n    short_sans;\n\n  length=GetStringInfoLength(bim_profile);\n  if (length < 16)\n    return;\n  datum=GetStringInfoDatum(bim_profile);\n  for (p=datum; (p >= datum) && (p < (datum+length-16)); )\n  {\n    register unsigned char\n      *q;\n\n    q=(unsigned char *) p;\n    if (LocaleNCompare((const char *) p,\"8BIM\",4) != 0)\n      break;\n    p=PushLongPixel(MSBEndian,p,&long_sans);\n    p=PushShortPixel(MSBEndian,p,&id);\n    p=PushShortPixel(MSBEndian,p,&short_sans);\n    p=PushLongPixel(MSBEndian,p,&count);\n    if (id == 0x0000040f)\n      {\n        ssize_t\n          quantum;\n\n        quantum=PSDQuantum(count)+12;\n        if ((quantum >= 12) && (quantum < (ssize_t) length))\n          {\n            if ((q+quantum < (datum+length-16)))\n              (void) CopyMagickMemory(q,q+quantum,length-quantum-(q-datum));\n            SetStringInfoLength(bim_profile,length-quantum);\n          }\n        break;\n      }\n    p+=count;\n    if ((count & 0x01) != 0)\n      p++;\n  }\n}\n\nstatic void RemoveResolutionFromResourceBlock(StringInfo *bim_profile)\n{\n  register const unsigned char\n    *p;\n\n  size_t\n    length;\n\n  unsigned char\n    *datum;\n\n  unsigned int\n    count,\n    long_sans;\n\n  unsigned short\n    id,\n    short_sans;\n\n  length=GetStringInfoLength(bim_profile);\n  if (length < 16)\n    return;\n  datum=GetStringInfoDatum(bim_profile);\n  for (p=datum; (p >= datum) && (p < (datum+length-16)); )\n  {\n    register unsigned char\n      *q;\n\n    ssize_t\n      cnt;\n\n    q=(unsigned char *) p;\n    if (LocaleNCompare((const char *) p,\"8BIM\",4) != 0)\n      return;\n    p=PushLongPixel(MSBEndian,p,&long_sans);\n    p=PushShortPixel(MSBEndian,p,&id);\n    p=PushShortPixel(MSBEndian,p,&short_sans);\n    p=PushLongPixel(MSBEndian,p,&count);\n    cnt=PSDQuantum(count);\n    if (cnt < 0)\n      return;\n    if ((id == 0x000003ed) && (cnt < (ssize_t) (length-12)))\n      {\n        (void) CopyMagickMemory(q,q+cnt+12,length-(cnt+12)-(q-datum));\n        SetStringInfoLength(bim_profile,length-(cnt+12));\n        break;\n      }\n    p+=count;\n    if ((count & 0x01) != 0)\n      p++;\n  }\n}\n\nstatic const StringInfo *GetAdditionalInformation(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n#define PSDKeySize 5\n#define PSDAllowedLength 36\n\n  char\n    key[PSDKeySize];\n\n  /* Whitelist of keys from: https://www.adobe.com/devnet-apps/photoshop/fileformatashtml/ */\n  const char\n    allowed[PSDAllowedLength][PSDKeySize] = {\n      \"blnc\", \"blwh\", \"brit\", \"brst\", \"clbl\", \"clrL\", \"curv\", \"expA\", \"FMsk\",\n      \"GdFl\", \"grdm\", \"hue \", \"hue2\", \"infx\", \"knko\", \"lclr\", \"levl\", \"lnsr\",\n      \"lfx2\", \"luni\", \"lrFX\", \"lspf\", \"lyid\", \"lyvr\", \"mixr\", \"nvrt\", \"phfl\",\n      \"post\", \"PtFl\", \"selc\", \"shpa\", \"sn2P\", \"SoCo\", \"thrs\", \"tsly\", \"vibA\"\n    },\n    *option;\n\n  const StringInfo\n    *info;\n\n  MagickBooleanType\n    found;\n\n  register size_t\n    i;\n\n  size_t\n    remaining_length,\n    length;\n\n  StringInfo\n    *profile;\n\n  unsigned char\n    *p;\n\n  unsigned int\n    size;\n\n  info=GetImageProfile(image,\"psd:additional-info\");\n  if (info == (const StringInfo *) NULL)\n    return((const StringInfo *) NULL);\n  option=GetImageOption(image_info,\"psd:additional-info\");\n  if (LocaleCompare(option,\"all\") == 0)\n    return(info);\n  if (LocaleCompare(option,\"selective\") != 0)\n    {\n      profile=RemoveImageProfile(image,\"psd:additional-info\");\n      return(DestroyStringInfo(profile));\n    }\n  length=GetStringInfoLength(info);\n  p=GetStringInfoDatum(info);\n  remaining_length=length;\n  length=0;\n  while (remaining_length >= 12)\n  {\n    /* skip over signature */\n    p+=4;\n    key[0]=(*p++);\n    key[1]=(*p++);\n    key[2]=(*p++);\n    key[3]=(*p++);\n    key[4]='\\0';\n    size=(unsigned int) (*p++) << 24;\n    size|=(unsigned int) (*p++) << 16;\n    size|=(unsigned int) (*p++) << 8;\n    size|=(unsigned int) (*p++);\n    size=size & 0xffffffff;\n    remaining_length-=12;\n    if ((size_t) size > remaining_length)\n      return((const StringInfo *) NULL);\n    found=MagickFalse;\n    for (i=0; i < PSDAllowedLength; i++)\n    {\n      if (LocaleNCompare(key,allowed[i],PSDKeySize) != 0)\n        continue;\n\n      found=MagickTrue;\n      break;\n    }\n    remaining_length-=(size_t) size;\n    if (found == MagickFalse)\n      {\n        if (remaining_length > 0)\n          p=(unsigned char *) CopyMagickMemory(p-12,p+size,remaining_length);\n        continue;\n      }\n    length+=(size_t) size+12;\n    p+=size;\n  }\n  profile=RemoveImageProfile(image,\"psd:additional-info\");\n  if (length == 0)\n    return(DestroyStringInfo(profile));\n  SetStringInfoLength(profile,(const size_t) length);\n  SetImageProfile(image,\"psd:additional-info\",info,exception);\n  return(profile);\n}\n\nstatic MagickBooleanType WritePSDImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  char\n    layer_name[MagickPathExtent];\n\n  const char\n    *property;\n\n  const StringInfo\n    *icc_profile,\n    *info;\n\n  Image\n    *base_image,\n    *next_image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    *layer_size_offsets,\n    size_offset;\n\n  PSDInfo\n    psd_info;\n\n  register ssize_t\n    i;\n\n  size_t\n    layer_count,\n    layer_index,\n    length,\n    name_length,\n    num_channels,\n    packet_size,\n    rounded_size,\n    size;\n\n  StringInfo\n    *bim_profile;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  packet_size=(size_t) (image->depth > 8 ? 6 : 3);\n  if (image->alpha_trait != UndefinedPixelTrait)\n    packet_size+=image->depth > 8 ? 2 : 1;\n  psd_info.version=1;\n  if ((LocaleCompare(image_info->magick,\"PSB\") == 0) ||\n      (image->columns > 30000) || (image->rows > 30000))\n    psd_info.version=2;\n  (void) WriteBlob(image,4,(const unsigned char *) \"8BPS\");\n  (void) WriteBlobMSBShort(image,psd_info.version);  /* version */\n  for (i=1; i <= 6; i++)\n    (void) WriteBlobByte(image, 0);  /* 6 bytes of reserved */\n  if (SetImageGray(image,exception) != MagickFalse)\n    num_channels=(image->alpha_trait != UndefinedPixelTrait ? 2UL : 1UL);\n  else\n    if ((image_info->type != TrueColorType) && (image_info->type !=\n         TrueColorAlphaType) && (image->storage_class == PseudoClass))\n      num_channels=(image->alpha_trait != UndefinedPixelTrait ? 2UL : 1UL);\n    else\n      {\n        if (image->storage_class == PseudoClass)\n          (void) SetImageStorageClass(image,DirectClass,exception);\n        if (image->colorspace != CMYKColorspace)\n          num_channels=(image->alpha_trait != UndefinedPixelTrait ? 4UL : 3UL);\n        else\n          num_channels=(image->alpha_trait != UndefinedPixelTrait ? 5UL : 4UL);\n      }\n  (void) WriteBlobMSBShort(image,(unsigned short) num_channels);\n  (void) WriteBlobMSBLong(image,(unsigned int) image->rows);\n  (void) WriteBlobMSBLong(image,(unsigned int) image->columns);\n  if (IsImageGray(image) != MagickFalse)\n    {\n      MagickBooleanType\n        monochrome;\n\n      /*\n        Write depth & mode.\n      */\n      monochrome=IsImageMonochrome(image) && (image->depth == 1) ?\n        MagickTrue : MagickFalse;\n      (void) WriteBlobMSBShort(image,(unsigned short)\n        (monochrome != MagickFalse ? 1 : image->depth > 8 ? 16 : 8));\n      (void) WriteBlobMSBShort(image,(unsigned short)\n        (monochrome != MagickFalse ? BitmapMode : GrayscaleMode));\n    }\n  else\n    {\n      (void) WriteBlobMSBShort(image,(unsigned short) (image->storage_class ==\n        PseudoClass ? 8 : image->depth > 8 ? 16 : 8));\n\n      if (((image_info->colorspace != UndefinedColorspace) ||\n           (image->colorspace != CMYKColorspace)) &&\n          (image_info->colorspace != CMYKColorspace))\n        {\n          (void) TransformImageColorspace(image,sRGBColorspace,exception);\n          (void) WriteBlobMSBShort(image,(unsigned short)\n            (image->storage_class == PseudoClass ? IndexedMode : RGBMode));\n        }\n      else\n        {\n          if (image->colorspace != CMYKColorspace)\n            (void) TransformImageColorspace(image,CMYKColorspace,exception);\n          (void) WriteBlobMSBShort(image,CMYKMode);\n        }\n    }\n  if ((IsImageGray(image) != MagickFalse) ||\n      (image->storage_class == DirectClass) || (image->colors > 256))\n    (void) WriteBlobMSBLong(image,0);\n  else\n    {\n      /*\n        Write PSD raster colormap.\n      */\n      (void) WriteBlobMSBLong(image,768);\n      for (i=0; i < (ssize_t) image->colors; i++)\n        (void) WriteBlobByte(image,ScaleQuantumToChar(image->colormap[i].red));\n      for ( ; i < 256; i++)\n        (void) WriteBlobByte(image,0);\n      for (i=0; i < (ssize_t) image->colors; i++)\n        (void) WriteBlobByte(image,ScaleQuantumToChar(\n          image->colormap[i].green));\n      for ( ; i < 256; i++)\n        (void) WriteBlobByte(image,0);\n      for (i=0; i < (ssize_t) image->colors; i++)\n        (void) WriteBlobByte(image,ScaleQuantumToChar(image->colormap[i].blue));\n      for ( ; i < 256; i++)\n        (void) WriteBlobByte(image,0);\n    }\n  /*\n    Image resource block.\n  */\n  length=28; /* 0x03EB */\n  bim_profile=(StringInfo *) GetImageProfile(image,\"8bim\");\n  icc_profile=GetImageProfile(image,\"icc\");\n  if (bim_profile != (StringInfo *) NULL)\n    {\n      bim_profile=CloneStringInfo(bim_profile);\n      if (icc_profile != (StringInfo *) NULL)\n        RemoveICCProfileFromResourceBlock(bim_profile);\n      RemoveResolutionFromResourceBlock(bim_profile);\n      length+=PSDQuantum(GetStringInfoLength(bim_profile));\n    }\n  if (icc_profile != (const StringInfo *) NULL)\n    length+=PSDQuantum(GetStringInfoLength(icc_profile))+12;\n  (void) WriteBlobMSBLong(image,(unsigned int) length);\n  WriteResolutionResourceBlock(image);\n  if (bim_profile != (StringInfo *) NULL)\n    {\n      (void) WriteBlob(image,GetStringInfoLength(bim_profile),\n        GetStringInfoDatum(bim_profile));\n      bim_profile=DestroyStringInfo(bim_profile);\n    }\n  if (icc_profile != (StringInfo *) NULL)\n    {\n      (void) WriteBlob(image,4,(const unsigned char *) \"8BIM\");\n      (void) WriteBlobMSBShort(image,0x0000040F);\n      (void) WriteBlobMSBShort(image,0);\n      (void) WriteBlobMSBLong(image,(unsigned int) GetStringInfoLength(\n        icc_profile));\n      (void) WriteBlob(image,GetStringInfoLength(icc_profile),\n        GetStringInfoDatum(icc_profile));\n      if ((MagickOffsetType) GetStringInfoLength(icc_profile) !=\n          PSDQuantum(GetStringInfoLength(icc_profile)))\n        (void) WriteBlobByte(image,0);\n    }\n  base_image=GetNextImageInList(image);\n  if (base_image == (Image *) NULL)\n    base_image=image;\n  size=0;\n  size_offset=TellBlob(image);\n  SetPSDSize(&psd_info,image,0);\n  SetPSDSize(&psd_info,image,0);\n  layer_count=0;\n  for (next_image=base_image; next_image != NULL; )\n  {\n    layer_count++;\n    next_image=GetNextImageInList(next_image);\n  }\n  if (image->alpha_trait != UndefinedPixelTrait)\n    size+=WriteBlobMSBShort(image,-(unsigned short) layer_count);\n  else\n    size+=WriteBlobMSBShort(image,(unsigned short) layer_count);\n  layer_size_offsets=(MagickOffsetType *) AcquireQuantumMemory(\n    (size_t) layer_count,sizeof(MagickOffsetType));\n  if (layer_size_offsets == (MagickOffsetType *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  layer_index=0;\n  for (next_image=base_image; next_image != NULL; )\n  {\n    Image\n      *mask;\n\n    unsigned char\n      default_color;\n\n    unsigned short\n      channels,\n      total_channels;\n\n    mask=(Image *) NULL;\n    property=GetImageArtifact(next_image,\"psd:opacity-mask\");\n    default_color=0;\n    if (property != (const char *) NULL)\n      {\n        mask=(Image *) GetImageRegistry(ImageRegistryType,property,exception);\n        default_color=strlen(property) == 9 ? 255 : 0;\n      }\n    size+=WriteBlobMSBLong(image,(unsigned int) next_image->page.y);\n    size+=WriteBlobMSBLong(image,(unsigned int) next_image->page.x);\n    size+=WriteBlobMSBLong(image,(unsigned int) (next_image->page.y+\n      next_image->rows));\n    size+=WriteBlobMSBLong(image,(unsigned int) (next_image->page.x+\n      next_image->columns));\n    channels=1U;\n    if ((next_image->storage_class != PseudoClass) &&\n        (IsImageGray(next_image) == MagickFalse))\n      channels=next_image->colorspace == CMYKColorspace ? 4U : 3U;\n    total_channels=channels;\n    if (next_image->alpha_trait != UndefinedPixelTrait)\n      total_channels++;\n    if (mask != (Image *) NULL)\n      total_channels++;\n    size+=WriteBlobMSBShort(image,total_channels);\n    layer_size_offsets[layer_index++]=TellBlob(image);\n    for (i=0; i < (ssize_t) channels; i++)\n      size+=WriteChannelSize(&psd_info,image,(signed short) i);\n    if (next_image->alpha_trait != UndefinedPixelTrait)\n      size+=WriteChannelSize(&psd_info,image,-1);\n    if (mask != (Image *) NULL)\n      size+=WriteChannelSize(&psd_info,image,-2);\n    size+=WriteBlob(image,4,(const unsigned char *) \"8BIM\");\n    size+=WriteBlob(image,4,(const unsigned char *)\n      CompositeOperatorToPSDBlendMode(next_image->compose));\n    property=GetImageArtifact(next_image,\"psd:layer.opacity\");\n    if (property != (const char *) NULL)\n      {\n        Quantum\n          opacity;\n\n        opacity=(Quantum) StringToInteger(property);\n        size+=WriteBlobByte(image,ScaleQuantumToChar(opacity));\n        (void) ApplyPSDLayerOpacity(next_image,opacity,MagickTrue,exception);\n      }\n    else\n      size+=WriteBlobByte(image,255);\n    size+=WriteBlobByte(image,0);\n    size+=WriteBlobByte(image,next_image->compose==NoCompositeOp ?\n      1 << 0x02 : 1); /* layer properties - visible, etc. */\n    size+=WriteBlobByte(image,0);\n    info=GetAdditionalInformation(image_info,next_image,exception);\n    property=(const char *) GetImageProperty(next_image,\"label\",exception);\n    if (property == (const char *) NULL)\n      {\n        (void) FormatLocaleString(layer_name,MagickPathExtent,\"L%.20g\",\n          (double) layer_index);\n        property=layer_name;\n      }\n    name_length=strlen(property)+1;\n    if ((name_length % 4) != 0)\n      name_length+=(4-(name_length % 4));\n    if (info != (const StringInfo *) NULL)\n      name_length+=GetStringInfoLength(info);\n    name_length+=8;\n    if (mask != (Image *) NULL)\n      name_length+=20;\n    size+=WriteBlobMSBLong(image,(unsigned int) name_length);\n    if (mask == (Image *) NULL)\n      size+=WriteBlobMSBLong(image,0);\n    else\n      {\n        if (mask->compose != NoCompositeOp)\n          (void) ApplyPSDOpacityMask(next_image,mask,ScaleCharToQuantum(\n            default_color),MagickTrue,exception);\n        mask->page.y+=image->page.y;\n        mask->page.x+=image->page.x;\n        size+=WriteBlobMSBLong(image,20);\n        size+=WriteBlobMSBSignedLong(image,mask->page.y);\n        size+=WriteBlobMSBSignedLong(image,mask->page.x);\n        size+=WriteBlobMSBLong(image,(const unsigned int) mask->rows+\n          mask->page.y);\n        size+=WriteBlobMSBLong(image,(const unsigned int) mask->columns+\n          mask->page.x);\n        size+=WriteBlobByte(image,default_color);\n        size+=WriteBlobByte(image,mask->compose == NoCompositeOp ? 2 : 0);\n        size+=WriteBlobMSBShort(image,0);\n      }\n    size+=WriteBlobMSBLong(image,0);\n    size+=WritePascalString(image,property,4);\n    if (info != (const StringInfo *) NULL)\n      size+=WriteBlob(image,GetStringInfoLength(info),\n        GetStringInfoDatum(info));\n    next_image=GetNextImageInList(next_image);\n  }\n  /*\n    Now the image data!\n  */\n  next_image=base_image;\n  layer_index=0;\n  while (next_image != NULL)\n  {\n    length=WritePSDChannels(&psd_info,image_info,image,next_image,\n      layer_size_offsets[layer_index++],MagickTrue,exception);\n    if (length == 0)\n      {\n        status=MagickFalse;\n        break;\n      }\n    size+=length;\n    next_image=GetNextImageInList(next_image);\n  }\n  (void) WriteBlobMSBLong(image,0);  /* user mask data */\n  /*\n    Write the total size\n  */\n  size_offset+=WritePSDSize(&psd_info,image,size+\n    (psd_info.version == 1 ? 8 : 16),size_offset);\n  if ((size/2) != ((size+1)/2))\n    rounded_size=size+1;\n  else\n    rounded_size=size;\n  (void) WritePSDSize(&psd_info,image,rounded_size,size_offset);\n  layer_size_offsets=(MagickOffsetType *) RelinquishMagickMemory(\n    layer_size_offsets);\n  /*\n    Remove the opacity mask from the registry\n  */\n  next_image=base_image;\n  while (next_image != (Image *) NULL)\n  {\n    property=GetImageArtifact(next_image,\"psd:opacity-mask\");\n    if (property != (const char *) NULL)\n      DeleteImageRegistry(property);\n    next_image=GetNextImageInList(next_image);\n  }\n  /*\n    Write composite image.\n  */\n  if (status != MagickFalse)\n    {\n      CompressionType\n        compression;\n\n      compression=image->compression;\n      if (image->compression == ZipCompression)\n        image->compression=RLECompression;\n      if (WritePSDChannels(&psd_info,image_info,image,image,0,MagickFalse,\n          exception) == 0)\n        status=MagickFalse;\n      image->compression=compression;\n    }\n  (void) CloseBlob(image);\n  return(status);\n}\n"], "filenames": ["coders/psd.c"], "buggy_code_start_loc": [2522], "buggy_code_end_loc": [2523], "fixing_code_start_loc": [2522], "fixing_code_end_loc": [2523], "type": "CWE-787", "message": "coders/psd.c in ImageMagick allows remote attackers to have unspecified impact via a crafted PSD file, which triggers an out-of-bounds write.", "other": {"cve": {"id": "CVE-2017-5510", "sourceIdentifier": "security@debian.org", "published": "2017-03-24T15:59:01.170", "lastModified": "2020-10-28T19:25:30.583", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "coders/psd.c in ImageMagick allows remote attackers to have unspecified impact via a crafted PSD file, which triggers an out-of-bounds write."}, {"lang": "es", "value": "Coders/psd.c en ImageMagick permite a los atacantes remotos tener un impacto no especificado a trav\u00e9s de un archivo PSD manipulado, lo que desencadena una escritura fuera de los l\u00edmites."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "matchCriteriaId": "BE6EA542-A222-4E6A-869B-F3805CAFCDD0"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "http://www.debian.org/security/2017/dsa-3799", "source": "security@debian.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2017/01/16/6", "source": "security@debian.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2017/01/17/5", "source": "security@debian.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/95755", "source": "security@debian.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=851376", "source": "security@debian.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/91cc3f36f2ccbd485a0456bab9aebe63b635da88", "source": "security@debian.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/e87af64b1ff1635a32d9b6162f1b0e260fb54ed9", "source": "security@debian.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/issues/348", "source": "security@debian.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201702-09", "source": "security@debian.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/91cc3f36f2ccbd485a0456bab9aebe63b635da88"}}