{"buggy_code": ["/*\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n *\n * Copyright (c) 1997-2012 Oracle and/or its affiliates. All rights reserved.\n *\n * The contents of this file are subject to the terms of either the GNU\n * General Public License Version 2 only (\"GPL\") or the Common Development\n * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n * may not use this file except in compliance with the License.  You can\n * obtain a copy of the License at\n * https://glassfish.dev.java.net/public/CDDL+GPL_1_1.html\n * or packager/legal/LICENSE.txt.  See the License for the specific\n * language governing permissions and limitations under the License.\n *\n * When distributing the software, include this License Header Notice in each\n * file and include the License file at packager/legal/LICENSE.txt.\n *\n * GPL Classpath Exception:\n * Oracle designates this particular file as subject to the \"Classpath\"\n * exception as provided by Oracle in the GPL Version 2 section of the License\n * file that accompanied this code.\n *\n * Modifications:\n * If applicable, add the following below the License Header, with the fields\n * enclosed by brackets [] replaced by your own identifying information:\n * \"Portions Copyright [year] [name of copyright owner]\"\n *\n * Contributor(s):\n * If you wish your version of this file to be governed by only the CDDL or\n * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n * elects to include this software in this distribution under the [CDDL or GPL\n * Version 2] license.\"  If you don't indicate a single choice of license, a\n * recipient has the option to distribute your version of this file under\n * either the CDDL, the GPL Version 2 or to extend the choice of license to\n * its licensees as provided above.  However, if you add GPL Version 2 code\n * and therefore, elected the GPL Version 2 license, then the option applies\n * only if the new code is made subject to such option by the copyright\n * holder.\n *\n *\n * This file incorporates work covered by the following copyright and\n * permission notice:\n *\n * Copyright 2004 The Apache Software Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Portions Copyright [2016-2022] [Payara Foundation and/or its affiliates]\n\npackage org.apache.catalina.core;\n\n\nimport org.apache.catalina.*;\nimport org.apache.catalina.valves.ValveBase;\nimport org.glassfish.web.valve.GlassFishValve;\n\nimport javax.servlet.*;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.util.Locale;\n\nimport org.glassfish.grizzly.utils.Charsets;\n\n/**\n * Valve that implements the default basic behavior for the\n * <code>StandardContext</code> container implementation.\n * <p>\n * <b>USAGE CONSTRAINT</b>:  This implementation is likely to be useful only\n * when processing HTTP requests.\n *\n * @author Craig R. McClanahan\n * @version $Revision: 1.19 $ $Date: 2007/05/05 05:31:54 $\n */\nfinal class StandardContextValve\n    extends ValveBase {\n\n\n    // ----------------------------------------------------- Instance Variables\n\n\n    /**\n     * The descriptive information related to this implementation.\n     */\n    private static final String info =\n        \"org.apache.catalina.core.StandardContextValve/1.0\";\n\n\n    private StandardContext context = null;\n\n\n    // ------------------------------------------------------------- Properties\n\n\n    /**\n     * Return descriptive information about this Valve implementation.\n     */\n    @Override\n    public String getInfo() {\n        return (info);\n\n    }\n\n\n    // --------------------------------------------------------- Public Methods\n\n\n    /**\n     * Cast to a StandardContext right away, as it will be needed later.\n     * \n     * @see org.apache.catalina.Contained#setContainer(org.apache.catalina.Container)\n     */\n    @Override\n    public void setContainer(Container container) {\n        super.setContainer(container);\n        if (container instanceof StandardContext) {\n            context = (StandardContext) container;\n        }\n    }\n\n\n    /**\n     * Select the appropriate child Wrapper to process this request,\n     * based on the specified request URI.  If no matching Wrapper can\n     * be found, return an appropriate HTTP error.\n     *\n     * @param request Request to be processed\n     * @param response Response to be produced\n     *\n     * @exception IOException if an input/output error occurred\n     * @exception ServletException if a servlet error occurred\n     */\n    @Override\n    public int invoke(Request request, Response response)\n        throws IOException, ServletException {\n\n        Wrapper wrapper = preInvoke(request, response);\n        if (wrapper == null) {\n            return END_PIPELINE;\n        }\n\n        /* GlassFish 1343\n        wrapper.getPipeline().invoke(request, response);\n        */\n        // START GlassFish 1343\n        if (wrapper.getPipeline().hasNonBasicValves() ||\n                wrapper.hasCustomPipeline()) {\n            wrapper.getPipeline().invoke(request, response);\n        } else {\n            GlassFishValve basic = wrapper.getPipeline().getBasic();\n            if (basic != null) {\n                basic.invoke(request, response);\n                basic.postInvoke(request, response);\n            }\n        }\n        // END GlassFish 1343\n\n        return END_PIPELINE;\n    } \n\n\n    /**\n     * Tomcat style invocation.\n     */\n    @Override\n    public void invoke(org.apache.catalina.connector.Request request,\n                       org.apache.catalina.connector.Response response)\n            throws IOException, ServletException {\n\n        Wrapper wrapper = preInvoke(request, response);\n        if (wrapper == null) {\n            return;\n        }\n\n        /* GlassFish 1343\n        wrapper.getPipeline().invoke(request, response);\n        */\n        // START GlassFish 1343\n        if (wrapper.getPipeline().hasNonBasicValves() ||\n                wrapper.hasCustomPipeline()) {\n            wrapper.getPipeline().invoke(request, response);\n        } else {\n            GlassFishValve basic = wrapper.getPipeline().getBasic();\n            if (basic != null) {\n                basic.invoke(request, response);\n                basic.postInvoke(request, response);\n            }\n        }\n        // END GlassFish 1343\n\n        postInvoke(request, response);\n    }\n\n\n    @Override\n    public void postInvoke(Request request, Response response)\n            throws IOException, ServletException {\n    }\n\n\n    /**\n     * Report a \"not found\" error for the specified resource.  FIXME:  We\n     * should really be using the error reporting settings for this web\n     * application, but currently that code runs at the wrapper level rather\n     * than the context level.\n     *\n     * @param response The response we are creating\n     */\n    private void notFound(HttpServletResponse response) {\n\n        try {\n            response.sendError(HttpServletResponse.SC_NOT_FOUND);\n        } catch (IllegalStateException | IOException e) {\n            // Ignore\n        }\n\n    }\n\n\n    /**\n     * Log a message on the Logger associated with our Container (if any)\n     *\n     * @param message Message to be logged\n     *\n    private void log(String message) {\n        org.apache.catalina.Logger logger = null;\n        String containerName = null;\n        if (container != null) {\n            logger = container.getLogger();\n            containerName = container.getName();\n        }\n        if (logger != null) {\n            logger.log(\"StandardContextValve[\" + container.getName() + \"]: \" +\n                       message);\n        } else {\n            if (log.isLoggable(Level.INFO)) {\n                log.info(\"StandardContextValve[\" + containerName + \"]: \" +\n                         message);\n            }\n        }\n    }\n\n\n    /**\n     * Log a message on the Logger associated with our Container (if any)\n     *\n     * @param message Message to be logged\n     * @param t Associated exception\n     *\n    private void log(String message, Throwable t) {\n        org.apache.catalina.Logger logger = null;\n        String containerName = null;\n        if (container != null) {\n            logger = container.getLogger();\n            containerName = container.getName();\n        }\n        if (logger != null) {\n            logger.log(\"StandardContextValve[\" + container.getName() + \"]: \" +\n                message, t, org.apache.catalina.Logger.WARNING);\n        } else {\n            log.log(Level.WARNING, \"StandardContextValve[\" + containerName +\n                \"]: \" + message, t);\n        }\n    }\n    */\n\n    /**\n     * resolves '.' and '..' elements in the path\n     * if there are too many, making a path negative, returns null\n     *\n     * @param path to be normalized\n     * @return normalized path or null\n     */\n    protected String normalize(String path) {\n        if (path == null) {\n            return null;\n        }\n\n        String rv = path;\n        // starts with a double-slash\n        if (rv.indexOf(\"//\") == 0) {\n            rv = rv.replace(\"//\", \"/\");\n        }\n        // starts with dot-slash\n        if (rv.indexOf(\"./\") == 0) {\n            rv = rv.replaceFirst(\"./\", \"/\");\n        }\n        // has /WEB-INF or /META-INF\n        final String RV = rv.toUpperCase();\n        int index = RV.indexOf(\"/WEB-INF/\");\n        if (index != -1 || RV.endsWith(\"/WEB-INF\")) {\n            return \"/WEB-INF\";\n        }\n\n        // Normalize the slashes and add leading slash if necessary\n        if (rv.indexOf('\\\\') >= 0) {\n            rv = rv.replace('\\\\', '/');\n        }\n\n        // Resolve occurrences of \"/../\" in the normalized path\n        while (true) {\n            int idx = rv.indexOf(\"/../\");\n            if (idx < 0) {\n                break;\n            }\n            if (idx == 0) {\n                return null;  // negative relative path\n            }\n            int index2 = rv.lastIndexOf('/', idx - 1);\n            rv = rv.substring(0, index2) + rv.substring(idx + 3);\n        }\n\n        // Resolve occurrences of \"/./\" example if the path looks like /app/./some/./something/./my.jsp\n        //then after processing should look like /app/some/something/my.jsp\n        rv = evaluateNormalizedPathWithSinglePoint(rv);\n\n        //if the path don't start with / then include it\n        if(!rv.startsWith(\"/\")) {\n            rv = \"/\" + rv;\n        }\n\n        // Return the normalized path that we have completed\n        return rv;\n    }\n\n    /**\n     * this method helps to evaluate the element \"/./\" on the path\n     * @param path to be normalized\n     * @return normalized path\n     */\n    private String evaluateNormalizedPathWithSinglePoint(String path) {\n        // Resolve occurrences of \"/./\" in the normalized path\n        while (true) {\n            int idx = path.indexOf(\"/./\");\n            if (idx < 0) {\n                break;\n            }\n            path = path.substring(0, idx) + path.substring(idx + 2);\n        }\n        return path;\n    }\n\n    private Wrapper preInvoke(Request request, Response response) {\n\n        // Disallow any direct access to resources under WEB-INF or META-INF\n        HttpRequest hreq = (HttpRequest) request;\n        // START CR 6415120\n        if (request.getCheckRestrictedResources()) {\n        // END CR 6415120\n            String requestPath = normalize(hreq.getRequestPathMB().toString(Charsets.UTF8_CHARSET));\n            if ((requestPath == null)\n                    || (requestPath.toUpperCase().startsWith(\"/META-INF/\", 0))\n                    || (requestPath.equalsIgnoreCase(\"/META-INF\"))\n                    || (requestPath.toUpperCase().startsWith(\"/WEB-INF/\", 0))\n                    || (requestPath.equalsIgnoreCase(\"/WEB-INF\"))) {\n                notFound((HttpServletResponse) response.getResponse());\n                return null;\n            }\n        // START CR 6415120\n        }\n        // END CR 6415120\n\n        // Wait if we are reloading\n        boolean reloaded = false;\n        while (((StandardContext) container).getPaused()) {\n            reloaded = true;\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                // Ignore\n            }\n        }\n\n        // Reloading will have stopped the old webappclassloader and\n        // created a new one\n        if (reloaded &&\n                context.getLoader() != null &&\n                context.getLoader().getClassLoader() != null) {\n            Thread.currentThread().setContextClassLoader(\n                    context.getLoader().getClassLoader());\n        }\n\n        // Select the Wrapper to be used for this Request\n        Wrapper wrapper = request.getWrapper();\n        if (wrapper == null) {\n            notFound((HttpServletResponse) response.getResponse());\n            return null;\n        } else if (wrapper.isUnavailable()) {\n            // May be as a result of a reload, try and find the new wrapper\n            wrapper = (Wrapper) container.findChild(wrapper.getName());\n            if (wrapper == null) {\n                notFound((HttpServletResponse) response.getResponse());\n                return null;\n            }\n        }\n\n        return wrapper;\n    }\n}\n", "/*\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n *\n * Copyright (c) [2021-2022] Payara Foundation and/or its affiliates. All rights reserved.\n *\n * The contents of this file are subject to the terms of either the GNU\n * General Public License Version 2 only (\"GPL\") or the Common Development\n * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n * may not use this file except in compliance with the License.  You can\n * obtain a copy of the License at\n * https://github.com/payara/Payara/blob/master/LICENSE.txt\n * See the License for the specific\n * language governing permissions and limitations under the License.\n *\n * When distributing the software, include this License Header Notice in each\n * file and include the License file at glassfish/legal/LICENSE.txt.\n *\n * GPL Classpath Exception:\n * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n * file that accompanied this code.\n *\n * Modifications:\n * If applicable, add the following below the License Header, with the fields\n * enclosed by brackets [] replaced by your own identifying information:\n * \"Portions Copyright [year] [name of copyright owner]\"\n *\n * Contributor(s):\n * If you wish your version of this file to be governed by only the CDDL or\n * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n * elects to include this software in this distribution under the [CDDL or GPL\n * Version 2] license.\"  If you don't indicate a single choice of license, a\n * recipient has the option to distribute your version of this file under\n * either the CDDL, the GPL Version 2 or to extend the choice of license to\n * its licensees as provided above.  However, if you add GPL Version 2 code\n * and therefore, elected the GPL Version 2 license, then the option applies\n * only if the new code is made subject to such option by the copyright\n * holder.\n */\npackage org.apache.catalina.core;\n\nimport junit.framework.TestCase;\nimport org.apache.catalina.HttpRequest;\nimport org.apache.catalina.HttpResponse;\nimport org.glassfish.grizzly.http.util.DataChunk;\nimport org.glassfish.web.valve.GlassFishValve;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.InjectMocks;\nimport org.mockito.Mock;\nimport org.mockito.runners.MockitoJUnitRunner;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\nimport static org.mockito.Mockito.*;\n\n@RunWith(MockitoJUnitRunner.class)\npublic class StandardContextValveTest extends TestCase {\n\n    @Mock\n    private HttpRequest httpRequest;\n\n    @Mock\n    private HttpResponse httpResponse;\n\n    @Mock\n    private HttpServletResponse httpServletResponse;\n\n    @InjectMocks\n    private StandardContextValve standardContextValve = new StandardContextValve();\n\n    @Test\n    public void preventAccessToRestrictedDirectoryWithEmptyContextRootTest() throws IOException, ServletException {\n        DataChunk dataChunkURL1 = DataChunk.newInstance();\n        dataChunkURL1.setString(\"WEB-INF/web.xml\");\n        DataChunk dataChunkURL2 = DataChunk.newInstance();\n        dataChunkURL2.setString(\"META-INF/MANIFEST.MF\");\n\n        when(httpRequest.getCheckRestrictedResources()).thenReturn(true);\n        when(httpRequest.getRequestPathMB()).thenReturn(dataChunkURL1).thenReturn(dataChunkURL2);\n        when(httpResponse.getResponse()).thenReturn(httpServletResponse);\n\n        int pipelineResult = standardContextValve.invoke(httpRequest, httpResponse);\n\n        verifyThatResourceIsNotFound(pipelineResult, 1, httpRequest, httpResponse, httpServletResponse);\n\n        pipelineResult = standardContextValve.invoke(httpRequest, httpResponse);\n\n        verifyThatResourceIsNotFound(pipelineResult, 2, httpRequest, httpResponse, httpServletResponse);\n    }\n\n    @Test\n    public void normalizeURLTest() {\n        String path1 = \"/app/../some/../something/../my.jsp\";\n        String path2 = \"/app/./some/./something/./my.jsp\";\n        String path3 = \"./my.jsp\";\n        String path4 = \"../app/WEB-INF/web.xml\";\n\n        String result = standardContextValve.normalize(path1);\n\n        assertEquals(\"/my.jsp\", result);\n\n        result = standardContextValve.normalize(path2);\n\n        assertEquals(\"/app/some/something/my.jsp\", result);\n\n        result = standardContextValve.normalize(path3);\n\n        assertEquals(\"/my.jsp\", result);\n\n        result = standardContextValve.normalize(path4);\n\n        assertEquals(\"/WEB-INF\", result);\n    }\n\n    protected void verifyThatResourceIsNotFound(int pipelineResult, int times, HttpRequest httpRequest, HttpResponse httpResponse,\n                                 HttpServletResponse httpServletResponse) throws IOException {\n        assertEquals(GlassFishValve.END_PIPELINE, pipelineResult);\n        verify(httpRequest, times(times)).getCheckRestrictedResources();\n        verify(httpRequest, times(times)).getRequestPathMB();\n        verify(httpResponse, times(times)).getResponse();\n        verify(httpServletResponse, times(times)).sendError(HttpServletResponse.SC_NOT_FOUND);\n    }\n}"], "fixing_code": ["/*\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n *\n * Copyright (c) 1997-2012 Oracle and/or its affiliates. All rights reserved.\n *\n * The contents of this file are subject to the terms of either the GNU\n * General Public License Version 2 only (\"GPL\") or the Common Development\n * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n * may not use this file except in compliance with the License.  You can\n * obtain a copy of the License at\n * https://glassfish.dev.java.net/public/CDDL+GPL_1_1.html\n * or packager/legal/LICENSE.txt.  See the License for the specific\n * language governing permissions and limitations under the License.\n *\n * When distributing the software, include this License Header Notice in each\n * file and include the License file at packager/legal/LICENSE.txt.\n *\n * GPL Classpath Exception:\n * Oracle designates this particular file as subject to the \"Classpath\"\n * exception as provided by Oracle in the GPL Version 2 section of the License\n * file that accompanied this code.\n *\n * Modifications:\n * If applicable, add the following below the License Header, with the fields\n * enclosed by brackets [] replaced by your own identifying information:\n * \"Portions Copyright [year] [name of copyright owner]\"\n *\n * Contributor(s):\n * If you wish your version of this file to be governed by only the CDDL or\n * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n * elects to include this software in this distribution under the [CDDL or GPL\n * Version 2] license.\"  If you don't indicate a single choice of license, a\n * recipient has the option to distribute your version of this file under\n * either the CDDL, the GPL Version 2 or to extend the choice of license to\n * its licensees as provided above.  However, if you add GPL Version 2 code\n * and therefore, elected the GPL Version 2 license, then the option applies\n * only if the new code is made subject to such option by the copyright\n * holder.\n *\n *\n * This file incorporates work covered by the following copyright and\n * permission notice:\n *\n * Copyright 2004 The Apache Software Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Portions Copyright [2016-2022] [Payara Foundation and/or its affiliates]\n\npackage org.apache.catalina.core;\n\n\nimport org.apache.catalina.*;\nimport org.apache.catalina.valves.ValveBase;\nimport org.glassfish.web.valve.GlassFishValve;\n\nimport javax.servlet.*;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.util.Locale;\nimport java.util.regex.Pattern;\n\nimport org.glassfish.grizzly.utils.Charsets;\n\n/**\n * Valve that implements the default basic behavior for the\n * <code>StandardContext</code> container implementation.\n * <p>\n * <b>USAGE CONSTRAINT</b>:  This implementation is likely to be useful only\n * when processing HTTP requests.\n *\n * @author Craig R. McClanahan\n * @version $Revision: 1.19 $ $Date: 2007/05/05 05:31:54 $\n */\nfinal class StandardContextValve\n    extends ValveBase {\n\n\n    // ----------------------------------------------------- Instance Variables\n\n\n    /**\n     * The descriptive information related to this implementation.\n     */\n    private static final String info =\n        \"org.apache.catalina.core.StandardContextValve/1.0\";\n\n\n    private StandardContext context = null;\n\n    private static final Pattern PATTERN_META_INF = Pattern.compile(\"[.]{2}[/]?.*[/](META-INF[/].*|META-INF$)\",\n            Pattern.CASE_INSENSITIVE);\n\n    private static final Pattern PATTERN_WEB_INF = Pattern.compile(\"[.]{2}[/]?.*[/](WEB-INF[/].*|WEB-INF$)\",\n            Pattern.CASE_INSENSITIVE);\n\n    // ------------------------------------------------------------- Properties\n\n\n    /**\n     * Return descriptive information about this Valve implementation.\n     */\n    @Override\n    public String getInfo() {\n        return (info);\n\n    }\n\n\n    // --------------------------------------------------------- Public Methods\n\n\n    /**\n     * Cast to a StandardContext right away, as it will be needed later.\n     * \n     * @see org.apache.catalina.Contained#setContainer(org.apache.catalina.Container)\n     */\n    @Override\n    public void setContainer(Container container) {\n        super.setContainer(container);\n        if (container instanceof StandardContext) {\n            context = (StandardContext) container;\n        }\n    }\n\n\n    /**\n     * Select the appropriate child Wrapper to process this request,\n     * based on the specified request URI.  If no matching Wrapper can\n     * be found, return an appropriate HTTP error.\n     *\n     * @param request Request to be processed\n     * @param response Response to be produced\n     *\n     * @exception IOException if an input/output error occurred\n     * @exception ServletException if a servlet error occurred\n     */\n    @Override\n    public int invoke(Request request, Response response)\n        throws IOException, ServletException {\n\n        Wrapper wrapper = preInvoke(request, response);\n        if (wrapper == null) {\n            return END_PIPELINE;\n        }\n\n        /* GlassFish 1343\n        wrapper.getPipeline().invoke(request, response);\n        */\n        // START GlassFish 1343\n        if (wrapper.getPipeline().hasNonBasicValves() ||\n                wrapper.hasCustomPipeline()) {\n            wrapper.getPipeline().invoke(request, response);\n        } else {\n            GlassFishValve basic = wrapper.getPipeline().getBasic();\n            if (basic != null) {\n                basic.invoke(request, response);\n                basic.postInvoke(request, response);\n            }\n        }\n        // END GlassFish 1343\n\n        return END_PIPELINE;\n    } \n\n\n    /**\n     * Tomcat style invocation.\n     */\n    @Override\n    public void invoke(org.apache.catalina.connector.Request request,\n                       org.apache.catalina.connector.Response response)\n            throws IOException, ServletException {\n\n        Wrapper wrapper = preInvoke(request, response);\n        if (wrapper == null) {\n            return;\n        }\n\n        /* GlassFish 1343\n        wrapper.getPipeline().invoke(request, response);\n        */\n        // START GlassFish 1343\n        if (wrapper.getPipeline().hasNonBasicValves() ||\n                wrapper.hasCustomPipeline()) {\n            wrapper.getPipeline().invoke(request, response);\n        } else {\n            GlassFishValve basic = wrapper.getPipeline().getBasic();\n            if (basic != null) {\n                basic.invoke(request, response);\n                basic.postInvoke(request, response);\n            }\n        }\n        // END GlassFish 1343\n\n        postInvoke(request, response);\n    }\n\n\n    @Override\n    public void postInvoke(Request request, Response response)\n            throws IOException, ServletException {\n    }\n\n\n    /**\n     * Report a \"not found\" error for the specified resource.  FIXME:  We\n     * should really be using the error reporting settings for this web\n     * application, but currently that code runs at the wrapper level rather\n     * than the context level.\n     *\n     * @param response The response we are creating\n     */\n    private void notFound(HttpServletResponse response) {\n\n        try {\n            response.sendError(HttpServletResponse.SC_NOT_FOUND);\n        } catch (IllegalStateException | IOException e) {\n            // Ignore\n        }\n\n    }\n\n\n    /**\n     * Log a message on the Logger associated with our Container (if any)\n     *\n     * @param message Message to be logged\n     *\n    private void log(String message) {\n        org.apache.catalina.Logger logger = null;\n        String containerName = null;\n        if (container != null) {\n            logger = container.getLogger();\n            containerName = container.getName();\n        }\n        if (logger != null) {\n            logger.log(\"StandardContextValve[\" + container.getName() + \"]: \" +\n                       message);\n        } else {\n            if (log.isLoggable(Level.INFO)) {\n                log.info(\"StandardContextValve[\" + containerName + \"]: \" +\n                         message);\n            }\n        }\n    }\n\n\n    /**\n     * Log a message on the Logger associated with our Container (if any)\n     *\n     * @param message Message to be logged\n     * @param t Associated exception\n     *\n    private void log(String message, Throwable t) {\n        org.apache.catalina.Logger logger = null;\n        String containerName = null;\n        if (container != null) {\n            logger = container.getLogger();\n            containerName = container.getName();\n        }\n        if (logger != null) {\n            logger.log(\"StandardContextValve[\" + container.getName() + \"]: \" +\n                message, t, org.apache.catalina.Logger.WARNING);\n        } else {\n            log.log(Level.WARNING, \"StandardContextValve[\" + containerName +\n                \"]: \" + message, t);\n        }\n    }\n    */\n\n    /**\n     * resolves '.' and '..' elements in the path\n     * if there are too many, making a path negative, returns null\n     *\n     * @param path to be normalized\n     * @return normalized path or null\n     */\n    protected String normalize(String path) {\n        if (path == null) {\n            return null;\n        }\n\n        String rv = path;\n        // starts with a double-slash\n        if (rv.indexOf(\"//\") == 0) {\n            rv = rv.replace(\"//\", \"/\");\n        }\n        // starts with dot-slash\n        if (rv.indexOf(\"./\") == 0) {\n            rv = rv.replaceFirst(\"./\", \"/\");\n        }\n        // has ../*/WEB-INF/* or ../*/META-INF/*\n        if (PATTERN_WEB_INF.matcher(rv).find()) {\n            return \"/WEB-INF\";\n        }\n        if (PATTERN_META_INF.matcher(rv).find()) {\n            return \"/META-INF\";\n        }\n\n        // Normalize the slashes and add leading slash if necessary\n        if (rv.indexOf('\\\\') >= 0) {\n            rv = rv.replace('\\\\', '/');\n        }\n\n        // Resolve occurrences of \"/../\" in the normalized path\n        while (true) {\n            int idx = rv.indexOf(\"/../\");\n            if (idx < 0) {\n                break;\n            }\n            if (idx == 0) {\n                return null;  // negative relative path\n            }\n            int index2 = rv.lastIndexOf('/', idx - 1);\n            rv = rv.substring(0, index2) + rv.substring(idx + 3);\n        }\n\n        // Resolve occurrences of \"/./\" example if the path looks like /app/./some/./something/./my.jsp\n        //then after processing should look like /app/some/something/my.jsp\n        rv = evaluateNormalizedPathWithSinglePoint(rv);\n\n        //if the path don't start with / then include it\n        if(!rv.startsWith(\"/\")) {\n            rv = \"/\" + rv;\n        }\n\n        // Return the normalized path that we have completed\n        return rv;\n    }\n\n    /**\n     * this method helps to evaluate the element \"/./\" on the path\n     * @param path to be normalized\n     * @return normalized path\n     */\n    private String evaluateNormalizedPathWithSinglePoint(String path) {\n        // Resolve occurrences of \"/./\" in the normalized path\n        while (true) {\n            int idx = path.indexOf(\"/./\");\n            if (idx < 0) {\n                break;\n            }\n            path = path.substring(0, idx) + path.substring(idx + 2);\n        }\n        return path;\n    }\n\n    private Wrapper preInvoke(Request request, Response response) {\n\n        // Disallow any direct access to resources under WEB-INF or META-INF\n        HttpRequest hreq = (HttpRequest) request;\n        // START CR 6415120\n        if (request.getCheckRestrictedResources()) {\n        // END CR 6415120\n            String requestPath = normalize(hreq.getRequestPathMB().toString(Charsets.UTF8_CHARSET));\n            if ((requestPath == null)\n                    || (requestPath.toUpperCase().startsWith(\"/META-INF/\", 0))\n                    || (requestPath.equalsIgnoreCase(\"/META-INF\"))\n                    || (requestPath.toUpperCase().startsWith(\"/WEB-INF/\", 0))\n                    || (requestPath.equalsIgnoreCase(\"/WEB-INF\"))) {\n                notFound((HttpServletResponse) response.getResponse());\n                return null;\n            }\n        // START CR 6415120\n        }\n        // END CR 6415120\n\n        // Wait if we are reloading\n        boolean reloaded = false;\n        while (((StandardContext) container).getPaused()) {\n            reloaded = true;\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                // Ignore\n            }\n        }\n\n        // Reloading will have stopped the old webappclassloader and\n        // created a new one\n        if (reloaded &&\n                context.getLoader() != null &&\n                context.getLoader().getClassLoader() != null) {\n            Thread.currentThread().setContextClassLoader(\n                    context.getLoader().getClassLoader());\n        }\n\n        // Select the Wrapper to be used for this Request\n        Wrapper wrapper = request.getWrapper();\n        if (wrapper == null) {\n            notFound((HttpServletResponse) response.getResponse());\n            return null;\n        } else if (wrapper.isUnavailable()) {\n            // May be as a result of a reload, try and find the new wrapper\n            wrapper = (Wrapper) container.findChild(wrapper.getName());\n            if (wrapper == null) {\n                notFound((HttpServletResponse) response.getResponse());\n                return null;\n            }\n        }\n\n        return wrapper;\n    }\n}\n", "/*\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n *\n * Copyright (c) [2021-2022] Payara Foundation and/or its affiliates. All rights reserved.\n *\n * The contents of this file are subject to the terms of either the GNU\n * General Public License Version 2 only (\"GPL\") or the Common Development\n * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n * may not use this file except in compliance with the License.  You can\n * obtain a copy of the License at\n * https://github.com/payara/Payara/blob/master/LICENSE.txt\n * See the License for the specific\n * language governing permissions and limitations under the License.\n *\n * When distributing the software, include this License Header Notice in each\n * file and include the License file at glassfish/legal/LICENSE.txt.\n *\n * GPL Classpath Exception:\n * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n * file that accompanied this code.\n *\n * Modifications:\n * If applicable, add the following below the License Header, with the fields\n * enclosed by brackets [] replaced by your own identifying information:\n * \"Portions Copyright [year] [name of copyright owner]\"\n *\n * Contributor(s):\n * If you wish your version of this file to be governed by only the CDDL or\n * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n * elects to include this software in this distribution under the [CDDL or GPL\n * Version 2] license.\"  If you don't indicate a single choice of license, a\n * recipient has the option to distribute your version of this file under\n * either the CDDL, the GPL Version 2 or to extend the choice of license to\n * its licensees as provided above.  However, if you add GPL Version 2 code\n * and therefore, elected the GPL Version 2 license, then the option applies\n * only if the new code is made subject to such option by the copyright\n * holder.\n */\npackage org.apache.catalina.core;\n\nimport junit.framework.TestCase;\nimport org.apache.catalina.HttpRequest;\nimport org.apache.catalina.HttpResponse;\nimport org.glassfish.grizzly.http.util.DataChunk;\nimport org.glassfish.web.valve.GlassFishValve;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.InjectMocks;\nimport org.mockito.Mock;\nimport org.mockito.runners.MockitoJUnitRunner;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\nimport static org.mockito.Mockito.*;\n\n@RunWith(MockitoJUnitRunner.class)\npublic class StandardContextValveTest extends TestCase {\n\n    @Mock\n    private HttpRequest httpRequest;\n\n    @Mock\n    private HttpResponse httpResponse;\n\n    @Mock\n    private HttpServletResponse httpServletResponse;\n\n    @InjectMocks\n    private StandardContextValve standardContextValve = new StandardContextValve();\n\n    @Test\n    public void preventAccessToRestrictedDirectoryWithEmptyContextRootTest() throws IOException, ServletException {\n        DataChunk dataChunkURL1 = DataChunk.newInstance();\n        dataChunkURL1.setString(\"WEB-INF/web.xml\");\n        DataChunk dataChunkURL2 = DataChunk.newInstance();\n        dataChunkURL2.setString(\"META-INF/MANIFEST.MF\");\n\n        when(httpRequest.getCheckRestrictedResources()).thenReturn(true);\n        when(httpRequest.getRequestPathMB()).thenReturn(dataChunkURL1).thenReturn(dataChunkURL2);\n        when(httpResponse.getResponse()).thenReturn(httpServletResponse);\n\n        int pipelineResult = standardContextValve.invoke(httpRequest, httpResponse);\n\n        verifyThatResourceIsNotFound(pipelineResult, 1, httpRequest, httpResponse, httpServletResponse);\n\n        pipelineResult = standardContextValve.invoke(httpRequest, httpResponse);\n\n        verifyThatResourceIsNotFound(pipelineResult, 2, httpRequest, httpResponse, httpServletResponse);\n    }\n\n    @Test\n    public void normalizeURLTest() {\n        String path1 = \"/app/../some/../something/../my.jsp\";\n        String path2 = \"/app/./some/./something/./my.jsp\";\n        String path3 = \"./my.jsp\";\n        String path4 = \"../app/WEB-INF/web.xml\";\n        String path5 = \"../app/META-INF/MANIFEST.MF\";\n\n        String result = standardContextValve.normalize(path1);\n\n        assertEquals(\"/my.jsp\", result);\n\n        result = standardContextValve.normalize(path2);\n\n        assertEquals(\"/app/some/something/my.jsp\", result);\n\n        result = standardContextValve.normalize(path3);\n\n        assertEquals(\"/my.jsp\", result);\n\n        result = standardContextValve.normalize(path4);\n\n        assertEquals(\"/WEB-INF\", result);\n\n        result = standardContextValve.normalize(path5);\n\n        assertEquals(\"/META-INF\", result);\n    }\n\n    protected void verifyThatResourceIsNotFound(int pipelineResult, int times, HttpRequest httpRequest, HttpResponse httpResponse,\n                                 HttpServletResponse httpServletResponse) throws IOException {\n        assertEquals(GlassFishValve.END_PIPELINE, pipelineResult);\n        verify(httpRequest, times(times)).getCheckRestrictedResources();\n        verify(httpRequest, times(times)).getRequestPathMB();\n        verify(httpResponse, times(times)).getResponse();\n        verify(httpServletResponse, times(times)).sendError(HttpServletResponse.SC_NOT_FOUND);\n    }\n}"], "filenames": ["appserver/web/web-core/src/main/java/org/apache/catalina/core/StandardContextValve.java", "appserver/web/web-core/src/test/java/org/apache/catalina/core/StandardContextValveTest.java"], "buggy_code_start_loc": [70, 99], "buggy_code_end_loc": [301, 115], "fixing_code_start_loc": [71, 100], "fixing_code_end_loc": [309, 121], "type": "CWE-552", "message": "Payara before 2022-11-04, when deployed to the root context, allows attackers to visit META-INF and WEB-INF, a different vulnerability than CVE-2022-37422. This affects Payara Platform Community before 4.1.2.191.38, 5.x before 5.2022.4, and 6.x before 6.2022.1, and Payara Platform Enterprise before 5.45.0.", "other": {"cve": {"id": "CVE-2022-45129", "sourceIdentifier": "cve@mitre.org", "published": "2022-11-10T06:15:13.813", "lastModified": "2023-01-20T14:49:28.157", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Payara before 2022-11-04, when deployed to the root context, allows attackers to visit META-INF and WEB-INF, a different vulnerability than CVE-2022-37422. This affects Payara Platform Community before 4.1.2.191.38, 5.x before 5.2022.4, and 6.x before 6.2022.1, and Payara Platform Enterprise before 5.45.0."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-552"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:payara:payara:*:*:*:*:community:*:*:*", "versionEndExcluding": "4.1.2.191.38", "matchCriteriaId": "E3A4E671-807C-427F-99F9-8432AC4BF9AE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:payara:payara:*:*:*:*:enterprise:*:*:*", "versionEndExcluding": "5.45.0", "matchCriteriaId": "166832EB-78AC-45D0-9CBC-6224B42F6377"}, {"vulnerable": true, "criteria": "cpe:2.3:a:payara:payara:*:*:*:*:community:*:*:*", "versionStartIncluding": "5.0.0", "versionEndExcluding": "5.2022.4", "matchCriteriaId": "164CD4C9-D211-45C5-8B34-441A549C197C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:payara:payara:*:*:*:*:community:*:*:*", "versionStartIncluding": "6.0.0", "versionEndExcluding": "6.2022.1", "matchCriteriaId": "13FD7C98-C2AC-44DE-BD23-0AB067E2AB0B"}]}]}], "references": [{"url": "http://packetstormsecurity.com/files/169864/Payara-Platform-Path-Traversal.html", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory", "VDB Entry"]}, {"url": "http://seclists.org/fulldisclosure/2022/Nov/11", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://blog.payara.fish/whats-new-in-the-november-2022-payara-platform-release", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://docs.payara.fish/community/docs/6.2022.1/Release%20Notes/Release%20Notes%206.2022.1.html", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://docs.payara.fish/community/docs/Release%20Notes/Release%20Notes%205.2022.4.html", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://docs.payara.fish/enterprise/docs/Release%20Notes/Release%20Notes%205.45.0.html", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://github.com/payara/Payara/commit/cccdfddeda71c78ae7b3179db5429e1bb8a56b2e", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/payara/Payara/commit/cccdfddeda71c78ae7b3179db5429e1bb8a56b2e"}}