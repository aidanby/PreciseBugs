{"buggy_code": ["/*\n * Westwood Studios VQA Video Decoder\n * Copyright (C) 2003 The FFmpeg project\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n/**\n * @file\n * VQA Video Decoder\n * @author Mike Melanson (melanson@pcisys.net)\n * @see http://wiki.multimedia.cx/index.php?title=VQA\n *\n * The VQA video decoder outputs PAL8 or RGB555 colorspace data, depending\n * on the type of data in the file.\n *\n * This decoder needs the 42-byte VQHD header from the beginning\n * of the VQA file passed through the extradata field. The VQHD header\n * is laid out as:\n *\n *   bytes 0-3   chunk fourcc: 'VQHD'\n *   bytes 4-7   chunk size in big-endian format, should be 0x0000002A\n *   bytes 8-49  VQHD chunk data\n *\n * Bytes 8-49 are what this decoder expects to see.\n *\n * Briefly, VQA is a vector quantized animation format that operates in a\n * VGA palettized colorspace. It operates on pixel vectors (blocks)\n * of either 4x2 or 4x4 in size. Compressed VQA chunks can contain vector\n * codebooks, palette information, and code maps for rendering vectors onto\n * frames. Any of these components can also be compressed with a run-length\n * encoding (RLE) algorithm commonly referred to as \"format80\".\n *\n * VQA takes a novel approach to rate control. Each group of n frames\n * (usually, n = 8) relies on a different vector codebook. Rather than\n * transporting an entire codebook every 8th frame, the new codebook is\n * broken up into 8 pieces and sent along with the compressed video chunks\n * for each of the 8 frames preceding the 8 frames which require the\n * codebook. A full codebook is also sent on the very first frame of a\n * file. This is an interesting technique, although it makes random file\n * seeking difficult despite the fact that the frames are all intracoded.\n *\n * V1,2 VQA uses 12-bit codebook indexes. If the 12-bit indexes were\n * packed into bytes and then RLE compressed, bytewise, the results would\n * be poor. That is why the coding method divides each index into 2 parts,\n * the top 4 bits and the bottom 8 bits, then RL encodes the 4-bit pieces\n * together and the 8-bit pieces together. If most of the vectors are\n * clustered into one group of 256 vectors, most of the 4-bit index pieces\n * should be the same.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"libavutil/intreadwrite.h\"\n#include \"libavutil/imgutils.h\"\n#include \"avcodec.h\"\n#include \"bytestream.h\"\n#include \"internal.h\"\n\n#define PALETTE_COUNT 256\n#define VQA_HEADER_SIZE 0x2A\n\n/* allocate the maximum vector space, regardless of the file version:\n * (0xFF00 codebook vectors + 0x100 solid pixel vectors) * (4x4 pixels/block) */\n#define MAX_CODEBOOK_VECTORS 0xFF00\n#define SOLID_PIXEL_VECTORS 0x100\n#define MAX_VECTORS (MAX_CODEBOOK_VECTORS + SOLID_PIXEL_VECTORS)\n#define MAX_CODEBOOK_SIZE (MAX_VECTORS * 4 * 4)\n\n#define CBF0_TAG MKBETAG('C', 'B', 'F', '0')\n#define CBFZ_TAG MKBETAG('C', 'B', 'F', 'Z')\n#define CBP0_TAG MKBETAG('C', 'B', 'P', '0')\n#define CBPZ_TAG MKBETAG('C', 'B', 'P', 'Z')\n#define CPL0_TAG MKBETAG('C', 'P', 'L', '0')\n#define CPLZ_TAG MKBETAG('C', 'P', 'L', 'Z')\n#define VPTZ_TAG MKBETAG('V', 'P', 'T', 'Z')\n\ntypedef struct VqaContext {\n\n    AVCodecContext *avctx;\n    GetByteContext gb;\n\n    uint32_t palette[PALETTE_COUNT];\n\n    int width;   /* width of a frame */\n    int height;   /* height of a frame */\n    int vector_width;  /* width of individual vector */\n    int vector_height;  /* height of individual vector */\n    int vqa_version;  /* this should be either 1, 2 or 3 */\n\n    unsigned char *codebook;         /* the current codebook */\n    int codebook_size;\n    unsigned char *next_codebook_buffer;  /* accumulator for next codebook */\n    int next_codebook_buffer_index;\n\n    unsigned char *decode_buffer;\n    int decode_buffer_size;\n\n    /* number of frames to go before replacing codebook */\n    int partial_countdown;\n    int partial_count;\n\n} VqaContext;\n\nstatic av_cold int vqa_decode_init(AVCodecContext *avctx)\n{\n    VqaContext *s = avctx->priv_data;\n    int i, j, codebook_index, ret;\n\n    s->avctx = avctx;\n    avctx->pix_fmt = AV_PIX_FMT_PAL8;\n\n    /* make sure the extradata made it */\n    if (s->avctx->extradata_size != VQA_HEADER_SIZE) {\n        av_log(s->avctx, AV_LOG_ERROR, \"expected extradata size of %d\\n\", VQA_HEADER_SIZE);\n        return AVERROR(EINVAL);\n    }\n\n    /* load up the VQA parameters from the header */\n    s->vqa_version = s->avctx->extradata[0];\n    switch (s->vqa_version) {\n    case 1:\n    case 2:\n        break;\n    case 3:\n        avpriv_report_missing_feature(avctx, \"VQA Version %d\", s->vqa_version);\n        return AVERROR_PATCHWELCOME;\n    default:\n        avpriv_request_sample(avctx, \"VQA Version %i\", s->vqa_version);\n        return AVERROR_PATCHWELCOME;\n    }\n    s->width = AV_RL16(&s->avctx->extradata[6]);\n    s->height = AV_RL16(&s->avctx->extradata[8]);\n    if ((ret = av_image_check_size(s->width, s->height, 0, avctx)) < 0) {\n        s->width= s->height= 0;\n        return ret;\n    }\n    s->vector_width = s->avctx->extradata[10];\n    s->vector_height = s->avctx->extradata[11];\n    s->partial_count = s->partial_countdown = s->avctx->extradata[13];\n\n    /* the vector dimensions have to meet very stringent requirements */\n    if ((s->vector_width != 4) ||\n        ((s->vector_height != 2) && (s->vector_height != 4))) {\n        /* return without further initialization */\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (s->width % s->vector_width || s->height % s->vector_height) {\n        av_log(avctx, AV_LOG_ERROR, \"Image size not multiple of block size\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    /* allocate codebooks */\n    s->codebook_size = MAX_CODEBOOK_SIZE;\n    s->codebook = av_malloc(s->codebook_size);\n    if (!s->codebook)\n        goto fail;\n    s->next_codebook_buffer = av_malloc(s->codebook_size);\n    if (!s->next_codebook_buffer)\n        goto fail;\n\n    /* allocate decode buffer */\n    s->decode_buffer_size = (s->width / s->vector_width) *\n        (s->height / s->vector_height) * 2;\n    s->decode_buffer = av_mallocz(s->decode_buffer_size);\n    if (!s->decode_buffer)\n        goto fail;\n\n    /* initialize the solid-color vectors */\n    if (s->vector_height == 4) {\n        codebook_index = 0xFF00 * 16;\n        for (i = 0; i < 256; i++)\n            for (j = 0; j < 16; j++)\n                s->codebook[codebook_index++] = i;\n    } else {\n        codebook_index = 0xF00 * 8;\n        for (i = 0; i < 256; i++)\n            for (j = 0; j < 8; j++)\n                s->codebook[codebook_index++] = i;\n    }\n    s->next_codebook_buffer_index = 0;\n\n    return 0;\nfail:\n    av_freep(&s->codebook);\n    av_freep(&s->next_codebook_buffer);\n    av_freep(&s->decode_buffer);\n    return AVERROR(ENOMEM);\n}\n\n#define CHECK_COUNT() \\\n    if (dest_index + count > dest_size) { \\\n        av_log(s->avctx, AV_LOG_ERROR, \"decode_format80 problem: next op would overflow dest_index\\n\"); \\\n        av_log(s->avctx, AV_LOG_ERROR, \"current dest_index = %d, count = %d, dest_size = %d\\n\", \\\n            dest_index, count, dest_size); \\\n        return AVERROR_INVALIDDATA; \\\n    }\n\n#define CHECK_COPY(idx) \\\n    if (idx < 0 || idx + count > dest_size) { \\\n        av_log(s->avctx, AV_LOG_ERROR, \"decode_format80 problem: next op would overflow dest_index\\n\"); \\\n        av_log(s->avctx, AV_LOG_ERROR, \"current src_pos = %d, count = %d, dest_size = %d\\n\", \\\n            src_pos, count, dest_size); \\\n        return AVERROR_INVALIDDATA; \\\n    }\n\n\nstatic int decode_format80(VqaContext *s, int src_size,\n    unsigned char *dest, int dest_size, int check_size) {\n\n    int dest_index = 0;\n    int count, opcode, start;\n    int src_pos;\n    unsigned char color;\n    int i;\n\n    if (src_size < 0 || src_size > bytestream2_get_bytes_left(&s->gb)) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Chunk size %d is out of range\\n\",\n               src_size);\n        return AVERROR_INVALIDDATA;\n    }\n\n    start = bytestream2_tell(&s->gb);\n    while (bytestream2_tell(&s->gb) - start < src_size) {\n        opcode = bytestream2_get_byte(&s->gb);\n        ff_tlog(s->avctx, \"opcode %02X: \", opcode);\n\n        /* 0x80 means that frame is finished */\n        if (opcode == 0x80)\n            break;\n\n        if (dest_index >= dest_size) {\n            av_log(s->avctx, AV_LOG_ERROR, \"decode_format80 problem: dest_index (%d) exceeded dest_size (%d)\\n\",\n                dest_index, dest_size);\n            return AVERROR_INVALIDDATA;\n        }\n\n        if (opcode == 0xFF) {\n\n            count   = bytestream2_get_le16(&s->gb);\n            src_pos = bytestream2_get_le16(&s->gb);\n            ff_tlog(s->avctx, \"(1) copy %X bytes from absolute pos %X\\n\", count, src_pos);\n            CHECK_COUNT();\n            CHECK_COPY(src_pos);\n            for (i = 0; i < count; i++)\n                dest[dest_index + i] = dest[src_pos + i];\n            dest_index += count;\n\n        } else if (opcode == 0xFE) {\n\n            count = bytestream2_get_le16(&s->gb);\n            color = bytestream2_get_byte(&s->gb);\n            ff_tlog(s->avctx, \"(2) set %X bytes to %02X\\n\", count, color);\n            CHECK_COUNT();\n            memset(&dest[dest_index], color, count);\n            dest_index += count;\n\n        } else if ((opcode & 0xC0) == 0xC0) {\n\n            count = (opcode & 0x3F) + 3;\n            src_pos = bytestream2_get_le16(&s->gb);\n            ff_tlog(s->avctx, \"(3) copy %X bytes from absolute pos %X\\n\", count, src_pos);\n            CHECK_COUNT();\n            CHECK_COPY(src_pos);\n            for (i = 0; i < count; i++)\n                dest[dest_index + i] = dest[src_pos + i];\n            dest_index += count;\n\n        } else if (opcode > 0x80) {\n\n            count = opcode & 0x3F;\n            ff_tlog(s->avctx, \"(4) copy %X bytes from source to dest\\n\", count);\n            CHECK_COUNT();\n            bytestream2_get_buffer(&s->gb, &dest[dest_index], count);\n            dest_index += count;\n\n        } else {\n\n            count = ((opcode & 0x70) >> 4) + 3;\n            src_pos = bytestream2_get_byte(&s->gb) | ((opcode & 0x0F) << 8);\n            ff_tlog(s->avctx, \"(5) copy %X bytes from relpos %X\\n\", count, src_pos);\n            CHECK_COUNT();\n            CHECK_COPY(dest_index - src_pos);\n            for (i = 0; i < count; i++)\n                dest[dest_index + i] = dest[dest_index - src_pos + i];\n            dest_index += count;\n        }\n    }\n\n    /* validate that the entire destination buffer was filled; this is\n     * important for decoding frame maps since each vector needs to have a\n     * codebook entry; it is not important for compressed codebooks because\n     * not every entry needs to be filled */\n    if (check_size)\n        if (dest_index < dest_size) {\n            av_log(s->avctx, AV_LOG_ERROR, \"decode_format80 problem: decode finished with dest_index (%d) < dest_size (%d)\\n\",\n                dest_index, dest_size);\n            memset(dest + dest_index, 0, dest_size - dest_index);\n        }\n\n    return 0; // let's display what we decoded anyway\n}\n\nstatic int vqa_decode_chunk(VqaContext *s, AVFrame *frame)\n{\n    unsigned int chunk_type;\n    unsigned int chunk_size;\n    int byte_skip;\n    unsigned int index = 0;\n    int i;\n    unsigned char r, g, b;\n    int index_shift;\n    int res;\n\n    int cbf0_chunk = -1;\n    int cbfz_chunk = -1;\n    int cbp0_chunk = -1;\n    int cbpz_chunk = -1;\n    int cpl0_chunk = -1;\n    int cplz_chunk = -1;\n    int vptz_chunk = -1;\n\n    int x, y;\n    int lines = 0;\n    int pixel_ptr;\n    int vector_index = 0;\n    int lobyte = 0;\n    int hibyte = 0;\n    int lobytes = 0;\n    int hibytes = s->decode_buffer_size / 2;\n\n    /* first, traverse through the frame and find the subchunks */\n    while (bytestream2_get_bytes_left(&s->gb) >= 8) {\n\n        chunk_type = bytestream2_get_be32u(&s->gb);\n        index      = bytestream2_tell(&s->gb);\n        chunk_size = bytestream2_get_be32u(&s->gb);\n\n        switch (chunk_type) {\n\n        case CBF0_TAG:\n            cbf0_chunk = index;\n            break;\n\n        case CBFZ_TAG:\n            cbfz_chunk = index;\n            break;\n\n        case CBP0_TAG:\n            cbp0_chunk = index;\n            break;\n\n        case CBPZ_TAG:\n            cbpz_chunk = index;\n            break;\n\n        case CPL0_TAG:\n            cpl0_chunk = index;\n            break;\n\n        case CPLZ_TAG:\n            cplz_chunk = index;\n            break;\n\n        case VPTZ_TAG:\n            vptz_chunk = index;\n            break;\n\n        default:\n            av_log(s->avctx, AV_LOG_ERROR, \"Found unknown chunk type: %s (%08X)\\n\",\n                   av_fourcc2str(av_bswap32(chunk_type)), chunk_type);\n            break;\n        }\n\n        byte_skip = chunk_size & 0x01;\n        bytestream2_skip(&s->gb, chunk_size + byte_skip);\n    }\n\n    /* next, deal with the palette */\n    if ((cpl0_chunk != -1) && (cplz_chunk != -1)) {\n\n        /* a chunk should not have both chunk types */\n        av_log(s->avctx, AV_LOG_ERROR, \"problem: found both CPL0 and CPLZ chunks\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    /* decompress the palette chunk */\n    if (cplz_chunk != -1) {\n\n/* yet to be handled */\n\n    }\n\n    /* convert the RGB palette into the machine's endian format */\n    if (cpl0_chunk != -1) {\n\n        bytestream2_seek(&s->gb, cpl0_chunk, SEEK_SET);\n        chunk_size = bytestream2_get_be32(&s->gb);\n        /* sanity check the palette size */\n        if (chunk_size / 3 > 256 || chunk_size > bytestream2_get_bytes_left(&s->gb)) {\n            av_log(s->avctx, AV_LOG_ERROR, \"problem: found a palette chunk with %d colors\\n\",\n                chunk_size / 3);\n            return AVERROR_INVALIDDATA;\n        }\n        for (i = 0; i < chunk_size / 3; i++) {\n            /* scale by 4 to transform 6-bit palette -> 8-bit */\n            r = bytestream2_get_byteu(&s->gb) * 4;\n            g = bytestream2_get_byteu(&s->gb) * 4;\n            b = bytestream2_get_byteu(&s->gb) * 4;\n            s->palette[i] = 0xFFU << 24 | r << 16 | g << 8 | b;\n            s->palette[i] |= s->palette[i] >> 6 & 0x30303;\n        }\n    }\n\n    /* next, look for a full codebook */\n    if ((cbf0_chunk != -1) && (cbfz_chunk != -1)) {\n\n        /* a chunk should not have both chunk types */\n        av_log(s->avctx, AV_LOG_ERROR, \"problem: found both CBF0 and CBFZ chunks\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    /* decompress the full codebook chunk */\n    if (cbfz_chunk != -1) {\n\n        bytestream2_seek(&s->gb, cbfz_chunk, SEEK_SET);\n        chunk_size = bytestream2_get_be32(&s->gb);\n        if ((res = decode_format80(s, chunk_size, s->codebook,\n                                   s->codebook_size, 0)) < 0)\n            return res;\n    }\n\n    /* copy a full codebook */\n    if (cbf0_chunk != -1) {\n\n        bytestream2_seek(&s->gb, cbf0_chunk, SEEK_SET);\n        chunk_size = bytestream2_get_be32(&s->gb);\n        /* sanity check the full codebook size */\n        if (chunk_size > MAX_CODEBOOK_SIZE) {\n            av_log(s->avctx, AV_LOG_ERROR, \"problem: CBF0 chunk too large (0x%X bytes)\\n\",\n                chunk_size);\n            return AVERROR_INVALIDDATA;\n        }\n\n        bytestream2_get_buffer(&s->gb, s->codebook, chunk_size);\n    }\n\n    /* decode the frame */\n    if (vptz_chunk == -1) {\n\n        /* something is wrong if there is no VPTZ chunk */\n        av_log(s->avctx, AV_LOG_ERROR, \"problem: no VPTZ chunk found\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    bytestream2_seek(&s->gb, vptz_chunk, SEEK_SET);\n    chunk_size = bytestream2_get_be32(&s->gb);\n    if ((res = decode_format80(s, chunk_size,\n                               s->decode_buffer, s->decode_buffer_size, 1)) < 0)\n        return res;\n\n    /* render the final PAL8 frame */\n    if (s->vector_height == 4)\n        index_shift = 4;\n    else\n        index_shift = 3;\n    for (y = 0; y < s->height; y += s->vector_height) {\n        for (x = 0; x < s->width; x += 4, lobytes++, hibytes++) {\n            pixel_ptr = y * frame->linesize[0] + x;\n\n            /* get the vector index, the method for which varies according to\n             * VQA file version */\n            switch (s->vqa_version) {\n\n            case 1:\n                lobyte = s->decode_buffer[lobytes * 2];\n                hibyte = s->decode_buffer[(lobytes * 2) + 1];\n                vector_index = ((hibyte << 8) | lobyte) >> 3;\n                vector_index <<= index_shift;\n                lines = s->vector_height;\n                /* uniform color fill - a quick hack */\n                if (hibyte == 0xFF) {\n                    while (lines--) {\n                        frame->data[0][pixel_ptr + 0] = 255 - lobyte;\n                        frame->data[0][pixel_ptr + 1] = 255 - lobyte;\n                        frame->data[0][pixel_ptr + 2] = 255 - lobyte;\n                        frame->data[0][pixel_ptr + 3] = 255 - lobyte;\n                        pixel_ptr += frame->linesize[0];\n                    }\n                    lines=0;\n                }\n                break;\n\n            case 2:\n                lobyte = s->decode_buffer[lobytes];\n                hibyte = s->decode_buffer[hibytes];\n                vector_index = (hibyte << 8) | lobyte;\n                vector_index <<= index_shift;\n                lines = s->vector_height;\n                break;\n\n            case 3:\n/* not implemented yet */\n                lines = 0;\n                break;\n            }\n\n            while (lines--) {\n                frame->data[0][pixel_ptr + 0] = s->codebook[vector_index++];\n                frame->data[0][pixel_ptr + 1] = s->codebook[vector_index++];\n                frame->data[0][pixel_ptr + 2] = s->codebook[vector_index++];\n                frame->data[0][pixel_ptr + 3] = s->codebook[vector_index++];\n                pixel_ptr += frame->linesize[0];\n            }\n        }\n    }\n\n    /* handle partial codebook */\n    if ((cbp0_chunk != -1) && (cbpz_chunk != -1)) {\n        /* a chunk should not have both chunk types */\n        av_log(s->avctx, AV_LOG_ERROR, \"problem: found both CBP0 and CBPZ chunks\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (cbp0_chunk != -1) {\n\n        bytestream2_seek(&s->gb, cbp0_chunk, SEEK_SET);\n        chunk_size = bytestream2_get_be32(&s->gb);\n\n        if (chunk_size > MAX_CODEBOOK_SIZE - s->next_codebook_buffer_index) {\n            av_log(s->avctx, AV_LOG_ERROR, \"cbp0 chunk too large (%u bytes)\\n\",\n                   chunk_size);\n            return AVERROR_INVALIDDATA;\n        }\n\n        /* accumulate partial codebook */\n        bytestream2_get_buffer(&s->gb, &s->next_codebook_buffer[s->next_codebook_buffer_index],\n                               chunk_size);\n        s->next_codebook_buffer_index += chunk_size;\n\n        s->partial_countdown--;\n        if (s->partial_countdown <= 0) {\n\n            /* time to replace codebook */\n            memcpy(s->codebook, s->next_codebook_buffer,\n                s->next_codebook_buffer_index);\n\n            /* reset accounting */\n            s->next_codebook_buffer_index = 0;\n            s->partial_countdown = s->partial_count;\n        }\n    }\n\n    if (cbpz_chunk != -1) {\n\n        bytestream2_seek(&s->gb, cbpz_chunk, SEEK_SET);\n        chunk_size = bytestream2_get_be32(&s->gb);\n\n        if (chunk_size > MAX_CODEBOOK_SIZE - s->next_codebook_buffer_index) {\n            av_log(s->avctx, AV_LOG_ERROR, \"cbpz chunk too large (%u bytes)\\n\",\n                   chunk_size);\n            return AVERROR_INVALIDDATA;\n        }\n\n        /* accumulate partial codebook */\n        bytestream2_get_buffer(&s->gb, &s->next_codebook_buffer[s->next_codebook_buffer_index],\n                               chunk_size);\n        s->next_codebook_buffer_index += chunk_size;\n\n        s->partial_countdown--;\n        if (s->partial_countdown <= 0) {\n            bytestream2_init(&s->gb, s->next_codebook_buffer, s->next_codebook_buffer_index);\n            /* decompress codebook */\n            if ((res = decode_format80(s, s->next_codebook_buffer_index,\n                                       s->codebook, s->codebook_size, 0)) < 0)\n                return res;\n\n            /* reset accounting */\n            s->next_codebook_buffer_index = 0;\n            s->partial_countdown = s->partial_count;\n        }\n    }\n\n    return 0;\n}\n\nstatic int vqa_decode_frame(AVCodecContext *avctx,\n                            void *data, int *got_frame,\n                            AVPacket *avpkt)\n{\n    VqaContext *s = avctx->priv_data;\n    AVFrame *frame = data;\n    int res;\n\n    if ((res = ff_get_buffer(avctx, frame, 0)) < 0)\n        return res;\n\n    bytestream2_init(&s->gb, avpkt->data, avpkt->size);\n    if ((res = vqa_decode_chunk(s, frame)) < 0)\n        return res;\n\n    /* make the palette available on the way out */\n    memcpy(frame->data[1], s->palette, PALETTE_COUNT * 4);\n    frame->palette_has_changed = 1;\n\n    *got_frame      = 1;\n\n    /* report that the buffer was completely consumed */\n    return avpkt->size;\n}\n\nstatic av_cold int vqa_decode_end(AVCodecContext *avctx)\n{\n    VqaContext *s = avctx->priv_data;\n\n    av_freep(&s->codebook);\n    av_freep(&s->next_codebook_buffer);\n    av_freep(&s->decode_buffer);\n\n    return 0;\n}\n\nAVCodec ff_vqa_decoder = {\n    .name           = \"vqavideo\",\n    .long_name      = NULL_IF_CONFIG_SMALL(\"Westwood Studios VQA (Vector Quantized Animation) video\"),\n    .type           = AVMEDIA_TYPE_VIDEO,\n    .id             = AV_CODEC_ID_WS_VQA,\n    .priv_data_size = sizeof(VqaContext),\n    .init           = vqa_decode_init,\n    .close          = vqa_decode_end,\n    .decode         = vqa_decode_frame,\n    .capabilities   = AV_CODEC_CAP_DR1,\n};\n"], "fixing_code": ["/*\n * Westwood Studios VQA Video Decoder\n * Copyright (C) 2003 The FFmpeg project\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n/**\n * @file\n * VQA Video Decoder\n * @author Mike Melanson (melanson@pcisys.net)\n * @see http://wiki.multimedia.cx/index.php?title=VQA\n *\n * The VQA video decoder outputs PAL8 or RGB555 colorspace data, depending\n * on the type of data in the file.\n *\n * This decoder needs the 42-byte VQHD header from the beginning\n * of the VQA file passed through the extradata field. The VQHD header\n * is laid out as:\n *\n *   bytes 0-3   chunk fourcc: 'VQHD'\n *   bytes 4-7   chunk size in big-endian format, should be 0x0000002A\n *   bytes 8-49  VQHD chunk data\n *\n * Bytes 8-49 are what this decoder expects to see.\n *\n * Briefly, VQA is a vector quantized animation format that operates in a\n * VGA palettized colorspace. It operates on pixel vectors (blocks)\n * of either 4x2 or 4x4 in size. Compressed VQA chunks can contain vector\n * codebooks, palette information, and code maps for rendering vectors onto\n * frames. Any of these components can also be compressed with a run-length\n * encoding (RLE) algorithm commonly referred to as \"format80\".\n *\n * VQA takes a novel approach to rate control. Each group of n frames\n * (usually, n = 8) relies on a different vector codebook. Rather than\n * transporting an entire codebook every 8th frame, the new codebook is\n * broken up into 8 pieces and sent along with the compressed video chunks\n * for each of the 8 frames preceding the 8 frames which require the\n * codebook. A full codebook is also sent on the very first frame of a\n * file. This is an interesting technique, although it makes random file\n * seeking difficult despite the fact that the frames are all intracoded.\n *\n * V1,2 VQA uses 12-bit codebook indexes. If the 12-bit indexes were\n * packed into bytes and then RLE compressed, bytewise, the results would\n * be poor. That is why the coding method divides each index into 2 parts,\n * the top 4 bits and the bottom 8 bits, then RL encodes the 4-bit pieces\n * together and the 8-bit pieces together. If most of the vectors are\n * clustered into one group of 256 vectors, most of the 4-bit index pieces\n * should be the same.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"libavutil/intreadwrite.h\"\n#include \"libavutil/imgutils.h\"\n#include \"avcodec.h\"\n#include \"bytestream.h\"\n#include \"internal.h\"\n\n#define PALETTE_COUNT 256\n#define VQA_HEADER_SIZE 0x2A\n\n/* allocate the maximum vector space, regardless of the file version:\n * (0xFF00 codebook vectors + 0x100 solid pixel vectors) * (4x4 pixels/block) */\n#define MAX_CODEBOOK_VECTORS 0xFF00\n#define SOLID_PIXEL_VECTORS 0x100\n#define MAX_VECTORS (MAX_CODEBOOK_VECTORS + SOLID_PIXEL_VECTORS)\n#define MAX_CODEBOOK_SIZE (MAX_VECTORS * 4 * 4)\n\n#define CBF0_TAG MKBETAG('C', 'B', 'F', '0')\n#define CBFZ_TAG MKBETAG('C', 'B', 'F', 'Z')\n#define CBP0_TAG MKBETAG('C', 'B', 'P', '0')\n#define CBPZ_TAG MKBETAG('C', 'B', 'P', 'Z')\n#define CPL0_TAG MKBETAG('C', 'P', 'L', '0')\n#define CPLZ_TAG MKBETAG('C', 'P', 'L', 'Z')\n#define VPTZ_TAG MKBETAG('V', 'P', 'T', 'Z')\n\ntypedef struct VqaContext {\n\n    AVCodecContext *avctx;\n    GetByteContext gb;\n\n    uint32_t palette[PALETTE_COUNT];\n\n    int width;   /* width of a frame */\n    int height;   /* height of a frame */\n    int vector_width;  /* width of individual vector */\n    int vector_height;  /* height of individual vector */\n    int vqa_version;  /* this should be either 1, 2 or 3 */\n\n    unsigned char *codebook;         /* the current codebook */\n    int codebook_size;\n    unsigned char *next_codebook_buffer;  /* accumulator for next codebook */\n    int next_codebook_buffer_index;\n\n    unsigned char *decode_buffer;\n    int decode_buffer_size;\n\n    /* number of frames to go before replacing codebook */\n    int partial_countdown;\n    int partial_count;\n\n} VqaContext;\n\nstatic av_cold int vqa_decode_init(AVCodecContext *avctx)\n{\n    VqaContext *s = avctx->priv_data;\n    int i, j, codebook_index, ret;\n\n    s->avctx = avctx;\n    avctx->pix_fmt = AV_PIX_FMT_PAL8;\n\n    /* make sure the extradata made it */\n    if (s->avctx->extradata_size != VQA_HEADER_SIZE) {\n        av_log(s->avctx, AV_LOG_ERROR, \"expected extradata size of %d\\n\", VQA_HEADER_SIZE);\n        return AVERROR(EINVAL);\n    }\n\n    /* load up the VQA parameters from the header */\n    s->vqa_version = s->avctx->extradata[0];\n    switch (s->vqa_version) {\n    case 1:\n    case 2:\n        break;\n    case 3:\n        avpriv_report_missing_feature(avctx, \"VQA Version %d\", s->vqa_version);\n        return AVERROR_PATCHWELCOME;\n    default:\n        avpriv_request_sample(avctx, \"VQA Version %i\", s->vqa_version);\n        return AVERROR_PATCHWELCOME;\n    }\n    s->width = AV_RL16(&s->avctx->extradata[6]);\n    s->height = AV_RL16(&s->avctx->extradata[8]);\n    if ((ret = ff_set_dimensions(avctx, s->width, s->height)) < 0) {\n        s->width= s->height= 0;\n        return ret;\n    }\n    s->vector_width = s->avctx->extradata[10];\n    s->vector_height = s->avctx->extradata[11];\n    s->partial_count = s->partial_countdown = s->avctx->extradata[13];\n\n    /* the vector dimensions have to meet very stringent requirements */\n    if ((s->vector_width != 4) ||\n        ((s->vector_height != 2) && (s->vector_height != 4))) {\n        /* return without further initialization */\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (s->width % s->vector_width || s->height % s->vector_height) {\n        av_log(avctx, AV_LOG_ERROR, \"Image size not multiple of block size\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    /* allocate codebooks */\n    s->codebook_size = MAX_CODEBOOK_SIZE;\n    s->codebook = av_malloc(s->codebook_size);\n    if (!s->codebook)\n        goto fail;\n    s->next_codebook_buffer = av_malloc(s->codebook_size);\n    if (!s->next_codebook_buffer)\n        goto fail;\n\n    /* allocate decode buffer */\n    s->decode_buffer_size = (s->width / s->vector_width) *\n        (s->height / s->vector_height) * 2;\n    s->decode_buffer = av_mallocz(s->decode_buffer_size);\n    if (!s->decode_buffer)\n        goto fail;\n\n    /* initialize the solid-color vectors */\n    if (s->vector_height == 4) {\n        codebook_index = 0xFF00 * 16;\n        for (i = 0; i < 256; i++)\n            for (j = 0; j < 16; j++)\n                s->codebook[codebook_index++] = i;\n    } else {\n        codebook_index = 0xF00 * 8;\n        for (i = 0; i < 256; i++)\n            for (j = 0; j < 8; j++)\n                s->codebook[codebook_index++] = i;\n    }\n    s->next_codebook_buffer_index = 0;\n\n    return 0;\nfail:\n    av_freep(&s->codebook);\n    av_freep(&s->next_codebook_buffer);\n    av_freep(&s->decode_buffer);\n    return AVERROR(ENOMEM);\n}\n\n#define CHECK_COUNT() \\\n    if (dest_index + count > dest_size) { \\\n        av_log(s->avctx, AV_LOG_ERROR, \"decode_format80 problem: next op would overflow dest_index\\n\"); \\\n        av_log(s->avctx, AV_LOG_ERROR, \"current dest_index = %d, count = %d, dest_size = %d\\n\", \\\n            dest_index, count, dest_size); \\\n        return AVERROR_INVALIDDATA; \\\n    }\n\n#define CHECK_COPY(idx) \\\n    if (idx < 0 || idx + count > dest_size) { \\\n        av_log(s->avctx, AV_LOG_ERROR, \"decode_format80 problem: next op would overflow dest_index\\n\"); \\\n        av_log(s->avctx, AV_LOG_ERROR, \"current src_pos = %d, count = %d, dest_size = %d\\n\", \\\n            src_pos, count, dest_size); \\\n        return AVERROR_INVALIDDATA; \\\n    }\n\n\nstatic int decode_format80(VqaContext *s, int src_size,\n    unsigned char *dest, int dest_size, int check_size) {\n\n    int dest_index = 0;\n    int count, opcode, start;\n    int src_pos;\n    unsigned char color;\n    int i;\n\n    if (src_size < 0 || src_size > bytestream2_get_bytes_left(&s->gb)) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Chunk size %d is out of range\\n\",\n               src_size);\n        return AVERROR_INVALIDDATA;\n    }\n\n    start = bytestream2_tell(&s->gb);\n    while (bytestream2_tell(&s->gb) - start < src_size) {\n        opcode = bytestream2_get_byte(&s->gb);\n        ff_tlog(s->avctx, \"opcode %02X: \", opcode);\n\n        /* 0x80 means that frame is finished */\n        if (opcode == 0x80)\n            break;\n\n        if (dest_index >= dest_size) {\n            av_log(s->avctx, AV_LOG_ERROR, \"decode_format80 problem: dest_index (%d) exceeded dest_size (%d)\\n\",\n                dest_index, dest_size);\n            return AVERROR_INVALIDDATA;\n        }\n\n        if (opcode == 0xFF) {\n\n            count   = bytestream2_get_le16(&s->gb);\n            src_pos = bytestream2_get_le16(&s->gb);\n            ff_tlog(s->avctx, \"(1) copy %X bytes from absolute pos %X\\n\", count, src_pos);\n            CHECK_COUNT();\n            CHECK_COPY(src_pos);\n            for (i = 0; i < count; i++)\n                dest[dest_index + i] = dest[src_pos + i];\n            dest_index += count;\n\n        } else if (opcode == 0xFE) {\n\n            count = bytestream2_get_le16(&s->gb);\n            color = bytestream2_get_byte(&s->gb);\n            ff_tlog(s->avctx, \"(2) set %X bytes to %02X\\n\", count, color);\n            CHECK_COUNT();\n            memset(&dest[dest_index], color, count);\n            dest_index += count;\n\n        } else if ((opcode & 0xC0) == 0xC0) {\n\n            count = (opcode & 0x3F) + 3;\n            src_pos = bytestream2_get_le16(&s->gb);\n            ff_tlog(s->avctx, \"(3) copy %X bytes from absolute pos %X\\n\", count, src_pos);\n            CHECK_COUNT();\n            CHECK_COPY(src_pos);\n            for (i = 0; i < count; i++)\n                dest[dest_index + i] = dest[src_pos + i];\n            dest_index += count;\n\n        } else if (opcode > 0x80) {\n\n            count = opcode & 0x3F;\n            ff_tlog(s->avctx, \"(4) copy %X bytes from source to dest\\n\", count);\n            CHECK_COUNT();\n            bytestream2_get_buffer(&s->gb, &dest[dest_index], count);\n            dest_index += count;\n\n        } else {\n\n            count = ((opcode & 0x70) >> 4) + 3;\n            src_pos = bytestream2_get_byte(&s->gb) | ((opcode & 0x0F) << 8);\n            ff_tlog(s->avctx, \"(5) copy %X bytes from relpos %X\\n\", count, src_pos);\n            CHECK_COUNT();\n            CHECK_COPY(dest_index - src_pos);\n            for (i = 0; i < count; i++)\n                dest[dest_index + i] = dest[dest_index - src_pos + i];\n            dest_index += count;\n        }\n    }\n\n    /* validate that the entire destination buffer was filled; this is\n     * important for decoding frame maps since each vector needs to have a\n     * codebook entry; it is not important for compressed codebooks because\n     * not every entry needs to be filled */\n    if (check_size)\n        if (dest_index < dest_size) {\n            av_log(s->avctx, AV_LOG_ERROR, \"decode_format80 problem: decode finished with dest_index (%d) < dest_size (%d)\\n\",\n                dest_index, dest_size);\n            memset(dest + dest_index, 0, dest_size - dest_index);\n        }\n\n    return 0; // let's display what we decoded anyway\n}\n\nstatic int vqa_decode_chunk(VqaContext *s, AVFrame *frame)\n{\n    unsigned int chunk_type;\n    unsigned int chunk_size;\n    int byte_skip;\n    unsigned int index = 0;\n    int i;\n    unsigned char r, g, b;\n    int index_shift;\n    int res;\n\n    int cbf0_chunk = -1;\n    int cbfz_chunk = -1;\n    int cbp0_chunk = -1;\n    int cbpz_chunk = -1;\n    int cpl0_chunk = -1;\n    int cplz_chunk = -1;\n    int vptz_chunk = -1;\n\n    int x, y;\n    int lines = 0;\n    int pixel_ptr;\n    int vector_index = 0;\n    int lobyte = 0;\n    int hibyte = 0;\n    int lobytes = 0;\n    int hibytes = s->decode_buffer_size / 2;\n\n    /* first, traverse through the frame and find the subchunks */\n    while (bytestream2_get_bytes_left(&s->gb) >= 8) {\n\n        chunk_type = bytestream2_get_be32u(&s->gb);\n        index      = bytestream2_tell(&s->gb);\n        chunk_size = bytestream2_get_be32u(&s->gb);\n\n        switch (chunk_type) {\n\n        case CBF0_TAG:\n            cbf0_chunk = index;\n            break;\n\n        case CBFZ_TAG:\n            cbfz_chunk = index;\n            break;\n\n        case CBP0_TAG:\n            cbp0_chunk = index;\n            break;\n\n        case CBPZ_TAG:\n            cbpz_chunk = index;\n            break;\n\n        case CPL0_TAG:\n            cpl0_chunk = index;\n            break;\n\n        case CPLZ_TAG:\n            cplz_chunk = index;\n            break;\n\n        case VPTZ_TAG:\n            vptz_chunk = index;\n            break;\n\n        default:\n            av_log(s->avctx, AV_LOG_ERROR, \"Found unknown chunk type: %s (%08X)\\n\",\n                   av_fourcc2str(av_bswap32(chunk_type)), chunk_type);\n            break;\n        }\n\n        byte_skip = chunk_size & 0x01;\n        bytestream2_skip(&s->gb, chunk_size + byte_skip);\n    }\n\n    /* next, deal with the palette */\n    if ((cpl0_chunk != -1) && (cplz_chunk != -1)) {\n\n        /* a chunk should not have both chunk types */\n        av_log(s->avctx, AV_LOG_ERROR, \"problem: found both CPL0 and CPLZ chunks\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    /* decompress the palette chunk */\n    if (cplz_chunk != -1) {\n\n/* yet to be handled */\n\n    }\n\n    /* convert the RGB palette into the machine's endian format */\n    if (cpl0_chunk != -1) {\n\n        bytestream2_seek(&s->gb, cpl0_chunk, SEEK_SET);\n        chunk_size = bytestream2_get_be32(&s->gb);\n        /* sanity check the palette size */\n        if (chunk_size / 3 > 256 || chunk_size > bytestream2_get_bytes_left(&s->gb)) {\n            av_log(s->avctx, AV_LOG_ERROR, \"problem: found a palette chunk with %d colors\\n\",\n                chunk_size / 3);\n            return AVERROR_INVALIDDATA;\n        }\n        for (i = 0; i < chunk_size / 3; i++) {\n            /* scale by 4 to transform 6-bit palette -> 8-bit */\n            r = bytestream2_get_byteu(&s->gb) * 4;\n            g = bytestream2_get_byteu(&s->gb) * 4;\n            b = bytestream2_get_byteu(&s->gb) * 4;\n            s->palette[i] = 0xFFU << 24 | r << 16 | g << 8 | b;\n            s->palette[i] |= s->palette[i] >> 6 & 0x30303;\n        }\n    }\n\n    /* next, look for a full codebook */\n    if ((cbf0_chunk != -1) && (cbfz_chunk != -1)) {\n\n        /* a chunk should not have both chunk types */\n        av_log(s->avctx, AV_LOG_ERROR, \"problem: found both CBF0 and CBFZ chunks\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    /* decompress the full codebook chunk */\n    if (cbfz_chunk != -1) {\n\n        bytestream2_seek(&s->gb, cbfz_chunk, SEEK_SET);\n        chunk_size = bytestream2_get_be32(&s->gb);\n        if ((res = decode_format80(s, chunk_size, s->codebook,\n                                   s->codebook_size, 0)) < 0)\n            return res;\n    }\n\n    /* copy a full codebook */\n    if (cbf0_chunk != -1) {\n\n        bytestream2_seek(&s->gb, cbf0_chunk, SEEK_SET);\n        chunk_size = bytestream2_get_be32(&s->gb);\n        /* sanity check the full codebook size */\n        if (chunk_size > MAX_CODEBOOK_SIZE) {\n            av_log(s->avctx, AV_LOG_ERROR, \"problem: CBF0 chunk too large (0x%X bytes)\\n\",\n                chunk_size);\n            return AVERROR_INVALIDDATA;\n        }\n\n        bytestream2_get_buffer(&s->gb, s->codebook, chunk_size);\n    }\n\n    /* decode the frame */\n    if (vptz_chunk == -1) {\n\n        /* something is wrong if there is no VPTZ chunk */\n        av_log(s->avctx, AV_LOG_ERROR, \"problem: no VPTZ chunk found\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    bytestream2_seek(&s->gb, vptz_chunk, SEEK_SET);\n    chunk_size = bytestream2_get_be32(&s->gb);\n    if ((res = decode_format80(s, chunk_size,\n                               s->decode_buffer, s->decode_buffer_size, 1)) < 0)\n        return res;\n\n    /* render the final PAL8 frame */\n    if (s->vector_height == 4)\n        index_shift = 4;\n    else\n        index_shift = 3;\n    for (y = 0; y < s->height; y += s->vector_height) {\n        for (x = 0; x < s->width; x += 4, lobytes++, hibytes++) {\n            pixel_ptr = y * frame->linesize[0] + x;\n\n            /* get the vector index, the method for which varies according to\n             * VQA file version */\n            switch (s->vqa_version) {\n\n            case 1:\n                lobyte = s->decode_buffer[lobytes * 2];\n                hibyte = s->decode_buffer[(lobytes * 2) + 1];\n                vector_index = ((hibyte << 8) | lobyte) >> 3;\n                vector_index <<= index_shift;\n                lines = s->vector_height;\n                /* uniform color fill - a quick hack */\n                if (hibyte == 0xFF) {\n                    while (lines--) {\n                        frame->data[0][pixel_ptr + 0] = 255 - lobyte;\n                        frame->data[0][pixel_ptr + 1] = 255 - lobyte;\n                        frame->data[0][pixel_ptr + 2] = 255 - lobyte;\n                        frame->data[0][pixel_ptr + 3] = 255 - lobyte;\n                        pixel_ptr += frame->linesize[0];\n                    }\n                    lines=0;\n                }\n                break;\n\n            case 2:\n                lobyte = s->decode_buffer[lobytes];\n                hibyte = s->decode_buffer[hibytes];\n                vector_index = (hibyte << 8) | lobyte;\n                vector_index <<= index_shift;\n                lines = s->vector_height;\n                break;\n\n            case 3:\n/* not implemented yet */\n                lines = 0;\n                break;\n            }\n\n            while (lines--) {\n                frame->data[0][pixel_ptr + 0] = s->codebook[vector_index++];\n                frame->data[0][pixel_ptr + 1] = s->codebook[vector_index++];\n                frame->data[0][pixel_ptr + 2] = s->codebook[vector_index++];\n                frame->data[0][pixel_ptr + 3] = s->codebook[vector_index++];\n                pixel_ptr += frame->linesize[0];\n            }\n        }\n    }\n\n    /* handle partial codebook */\n    if ((cbp0_chunk != -1) && (cbpz_chunk != -1)) {\n        /* a chunk should not have both chunk types */\n        av_log(s->avctx, AV_LOG_ERROR, \"problem: found both CBP0 and CBPZ chunks\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (cbp0_chunk != -1) {\n\n        bytestream2_seek(&s->gb, cbp0_chunk, SEEK_SET);\n        chunk_size = bytestream2_get_be32(&s->gb);\n\n        if (chunk_size > MAX_CODEBOOK_SIZE - s->next_codebook_buffer_index) {\n            av_log(s->avctx, AV_LOG_ERROR, \"cbp0 chunk too large (%u bytes)\\n\",\n                   chunk_size);\n            return AVERROR_INVALIDDATA;\n        }\n\n        /* accumulate partial codebook */\n        bytestream2_get_buffer(&s->gb, &s->next_codebook_buffer[s->next_codebook_buffer_index],\n                               chunk_size);\n        s->next_codebook_buffer_index += chunk_size;\n\n        s->partial_countdown--;\n        if (s->partial_countdown <= 0) {\n\n            /* time to replace codebook */\n            memcpy(s->codebook, s->next_codebook_buffer,\n                s->next_codebook_buffer_index);\n\n            /* reset accounting */\n            s->next_codebook_buffer_index = 0;\n            s->partial_countdown = s->partial_count;\n        }\n    }\n\n    if (cbpz_chunk != -1) {\n\n        bytestream2_seek(&s->gb, cbpz_chunk, SEEK_SET);\n        chunk_size = bytestream2_get_be32(&s->gb);\n\n        if (chunk_size > MAX_CODEBOOK_SIZE - s->next_codebook_buffer_index) {\n            av_log(s->avctx, AV_LOG_ERROR, \"cbpz chunk too large (%u bytes)\\n\",\n                   chunk_size);\n            return AVERROR_INVALIDDATA;\n        }\n\n        /* accumulate partial codebook */\n        bytestream2_get_buffer(&s->gb, &s->next_codebook_buffer[s->next_codebook_buffer_index],\n                               chunk_size);\n        s->next_codebook_buffer_index += chunk_size;\n\n        s->partial_countdown--;\n        if (s->partial_countdown <= 0) {\n            bytestream2_init(&s->gb, s->next_codebook_buffer, s->next_codebook_buffer_index);\n            /* decompress codebook */\n            if ((res = decode_format80(s, s->next_codebook_buffer_index,\n                                       s->codebook, s->codebook_size, 0)) < 0)\n                return res;\n\n            /* reset accounting */\n            s->next_codebook_buffer_index = 0;\n            s->partial_countdown = s->partial_count;\n        }\n    }\n\n    return 0;\n}\n\nstatic int vqa_decode_frame(AVCodecContext *avctx,\n                            void *data, int *got_frame,\n                            AVPacket *avpkt)\n{\n    VqaContext *s = avctx->priv_data;\n    AVFrame *frame = data;\n    int res;\n\n    if ((res = ff_get_buffer(avctx, frame, 0)) < 0)\n        return res;\n\n    bytestream2_init(&s->gb, avpkt->data, avpkt->size);\n    if ((res = vqa_decode_chunk(s, frame)) < 0)\n        return res;\n\n    /* make the palette available on the way out */\n    memcpy(frame->data[1], s->palette, PALETTE_COUNT * 4);\n    frame->palette_has_changed = 1;\n\n    *got_frame      = 1;\n\n    /* report that the buffer was completely consumed */\n    return avpkt->size;\n}\n\nstatic av_cold int vqa_decode_end(AVCodecContext *avctx)\n{\n    VqaContext *s = avctx->priv_data;\n\n    av_freep(&s->codebook);\n    av_freep(&s->next_codebook_buffer);\n    av_freep(&s->decode_buffer);\n\n    return 0;\n}\n\nAVCodec ff_vqa_decoder = {\n    .name           = \"vqavideo\",\n    .long_name      = NULL_IF_CONFIG_SMALL(\"Westwood Studios VQA (Vector Quantized Animation) video\"),\n    .type           = AVMEDIA_TYPE_VIDEO,\n    .id             = AV_CODEC_ID_WS_VQA,\n    .priv_data_size = sizeof(VqaContext),\n    .init           = vqa_decode_init,\n    .close          = vqa_decode_end,\n    .decode         = vqa_decode_frame,\n    .capabilities   = AV_CODEC_CAP_DR1,\n};\n"], "filenames": ["libavcodec/vqavideo.c"], "buggy_code_start_loc": [150], "buggy_code_end_loc": [151], "fixing_code_start_loc": [150], "fixing_code_end_loc": [151], "type": "CWE-787", "message": "FFmpeg before 4.2 has a heap-based buffer overflow in vqa_decode_chunk because of an out-of-array access in vqa_decode_init in libavcodec/vqavideo.c.", "other": {"cve": {"id": "CVE-2019-17542", "sourceIdentifier": "cve@mitre.org", "published": "2019-10-14T02:15:10.780", "lastModified": "2021-07-21T11:39:23.747", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "FFmpeg before 4.2 has a heap-based buffer overflow in vqa_decode_chunk because of an out-of-array access in vqa_decode_init in libavcodec/vqavideo.c."}, {"lang": "es", "value": "FFmpeg versiones anteriores a 4.2, presenta un desbordamiento de b\u00fafer en la regi\u00f3n heap de la memoria en la funci\u00f3n vqa_decode_chunk debido a un acceso fuera de la matriz en la funci\u00f3n vqa_decode_init en el archivo libavcodec/vqavideo.c."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.8.16", "matchCriteriaId": "34E25C2C-77A4-4A04-A551-EC6FCF5B149C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.2", "versionEndExcluding": "3.2.15", "matchCriteriaId": "AD67FB4E-6E5D-4BE3-B676-AD6D8AF92351"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.4", "versionEndExcluding": "3.4.7", "matchCriteriaId": "538C8DA9-A977-48EC-8726-E87BD7DD1A57"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.0", "versionEndExcluding": "4.0.5", "matchCriteriaId": "A8A5D02A-1A59-4AF1-ABBD-52AD5943F61D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.1", "versionEndExcluding": "4.1.5", "matchCriteriaId": "7BCF2541-70F2-48DC-83B3-A7EE329F315F"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:20.04:*:*:*:lts:*:*:*", "matchCriteriaId": "902B8056-9E37-443B-8905-8AA93E2447FB"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=15919", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/FFmpeg/FFmpeg/commit/02f909dc24b1f05cfbba75077c7707b905e63cd2", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/12/msg00003.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/07/msg00022.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202003-65", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4431-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2020/dsa-4722", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/FFmpeg/FFmpeg/commit/02f909dc24b1f05cfbba75077c7707b905e63cd2"}}