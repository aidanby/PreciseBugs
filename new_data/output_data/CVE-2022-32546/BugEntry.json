{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                            PPPP    CCCC  L                                  %\n%                            P   P  C      L                                  %\n%                            PPPP   C      L                                  %\n%                            P      C      L                                  %\n%                            P       CCCC  LLLLL                              %\n%                                                                             %\n%                                                                             %\n%                      Read/Write HP PCL Printer Format                       %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright @ 1999 ImageMagick Studio LLC, a non-profit organization         %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/artifact.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/delegate.h\"\n#include \"MagickCore/draw.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/profile.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/token.h\"\n#include \"MagickCore/transform.h\"\n#include \"MagickCore/utility.h\"\n\f\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  WritePCLImage(const ImageInfo *,Image *,ExceptionInfo *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s P C L                                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsPCL() returns MagickTrue if the image format type, identified by the\n%  magick string, is PCL.\n%\n%  The format of the IsPCL method is:\n%\n%      MagickBooleanType IsPCL(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsPCL(const unsigned char *magick,const size_t length)\n{\n  if (length < 4)\n    return(MagickFalse);\n  if (memcmp(magick,\"\\033E\\033&\",4) == 0)\n    return(MagickFalse);\n  if (memcmp(magick,\"\\033E\\033\",3) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d P C L I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadPCLImage() reads a Printer Control Language image file and returns it.\n%  It allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the ReadPCLImage method is:\n%\n%      Image *ReadPCLImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *ReadPCLImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define CropBox  \"CropBox\"\n#define DeviceCMYK  \"DeviceCMYK\"\n#define MediaBox  \"MediaBox\"\n#define RenderPCLText  \"  Rendering PCL...  \"\n\n  char\n    command[MagickPathExtent],\n    *density,\n    filename[MagickPathExtent],\n    geometry[MagickPathExtent],\n    *options,\n    input_filename[MagickPathExtent];\n\n  const DelegateInfo\n    *delegate_info;\n\n  Image\n    *image,\n    *next_image;\n\n  ImageInfo\n    *read_info;\n\n  MagickBooleanType\n    cmyk,\n    status;\n\n  PointInfo\n    delta;\n\n  RectangleInfo\n    bounding_box,\n    page;\n\n  char\n    *p;\n\n  ssize_t\n    c;\n\n  SegmentInfo\n    bounds;\n\n  size_t\n    height,\n    width;\n\n  ssize_t\n    count;\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  /*\n    Open image file.\n  */\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  status=AcquireUniqueSymbolicLink(image_info->filename,input_filename);\n  if (status == MagickFalse)\n    {\n      ThrowFileException(exception,FileOpenError,\"UnableToCreateTemporaryFile\",\n        image_info->filename);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Set the page density.\n  */\n  delta.x=DefaultResolution;\n  delta.y=DefaultResolution;\n  if ((image->resolution.x == 0.0) || (image->resolution.y == 0.0))\n    {\n      GeometryInfo\n        geometry_info;\n\n      MagickStatusType\n        flags;\n\n      flags=ParseGeometry(PSDensityGeometry,&geometry_info);\n      if ((flags & RhoValue) != 0)\n        image->resolution.x=geometry_info.rho;\n      image->resolution.y=image->resolution.x;\n      if ((flags & SigmaValue) != 0)\n        image->resolution.y=geometry_info.sigma;\n    }\n  /*\n    Determine page geometry from the PCL media box.\n  */\n  cmyk=image->colorspace == CMYKColorspace ? MagickTrue : MagickFalse;\n  count=0;\n  (void) memset(&bounding_box,0,sizeof(bounding_box));\n  (void) memset(&bounds,0,sizeof(bounds));\n  (void) memset(&page,0,sizeof(page));\n  (void) memset(command,0,sizeof(command));\n  p=command;\n  for (c=ReadBlobByte(image); c != EOF; c=ReadBlobByte(image))\n  {\n    if (image_info->page != (char *) NULL)\n      continue;\n    /*\n      Note PCL elements.\n    */\n    *p++=(char) c;\n    if ((c != (int) '/') && (c != '\\n') &&\n        ((size_t) (p-command) < (MagickPathExtent-1)))\n      continue;\n    *p='\\0';\n    p=command;\n    /*\n      Is this a CMYK document?\n    */\n    if (LocaleNCompare(DeviceCMYK,command,strlen(DeviceCMYK)) == 0)\n      cmyk=MagickTrue;\n    if (LocaleNCompare(CropBox,command,strlen(CropBox)) == 0)\n      {\n        /*\n          Note region defined by crop box.\n        */\n        count=(ssize_t) sscanf(command,\"CropBox [%lf %lf %lf %lf\",\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n        if (count != 4)\n          count=(ssize_t) sscanf(command,\"CropBox[%lf %lf %lf %lf\",\n            &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n      }\n    if (LocaleNCompare(MediaBox,command,strlen(MediaBox)) == 0)\n      {\n        /*\n          Note region defined by media box.\n        */\n        count=(ssize_t) sscanf(command,\"MediaBox [%lf %lf %lf %lf\",\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n        if (count != 4)\n          count=(ssize_t) sscanf(command,\"MediaBox[%lf %lf %lf %lf\",\n            &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n      }\n    if (count != 4)\n      continue;\n    /*\n      Set PCL render geometry.\n    */\n    width=(size_t) floor(bounds.x2-bounds.x1+0.5);\n    height=(size_t) floor(bounds.y2-bounds.y1+0.5);\n    if (width > page.width)\n      page.width=width;\n    if (height > page.height)\n      page.height=height;\n  }\n  (void) CloseBlob(image);\n  /*\n    Render PCL with the GhostPCL delegate.\n  */\n  if ((page.width == 0) || (page.height == 0))\n    (void) ParseAbsoluteGeometry(PSPageGeometry,&page);\n  if (image_info->page != (char *) NULL)\n    (void) ParseAbsoluteGeometry(image_info->page,&page);\n  (void) FormatLocaleString(geometry,MagickPathExtent,\"%.20gx%.20g\",(double)\n    page.width,(double) page.height);\n  if (image_info->monochrome != MagickFalse)\n    delegate_info=GetDelegateInfo(\"pcl:mono\",(char *) NULL,exception);\n  else\n     if (cmyk != MagickFalse)\n       delegate_info=GetDelegateInfo(\"pcl:cmyk\",(char *) NULL,exception);\n     else\n       delegate_info=GetDelegateInfo(\"pcl:color\",(char *) NULL,exception);\n  if (delegate_info == (const DelegateInfo *) NULL)\n    {\n      image=DestroyImage(image);\n      return((Image *) NULL);\n    }\n  if ((page.width == 0) || (page.height == 0))\n    (void) ParseAbsoluteGeometry(PSPageGeometry,&page);\n  if (image_info->page != (char *) NULL)\n    (void) ParseAbsoluteGeometry(image_info->page,&page);\n  density=AcquireString(\"\");\n  options=AcquireString(\"\");\n  (void) FormatLocaleString(density,MagickPathExtent,\"%gx%g\",\n    image->resolution.x,image->resolution.y);\n  if (image_info->ping != MagickFalse)\n    (void) FormatLocaleString(density,MagickPathExtent,\"2.0x2.0\");\n  page.width=(size_t) floor(page.width*image->resolution.x/delta.x+0.5);\n  page.height=(size_t) floor(page.height*image->resolution.y/delta.y+0.5);\n  (void) FormatLocaleString(options,MagickPathExtent,\"-g%.20gx%.20g \",(double)\n    page.width,(double) page.height);\n  image=DestroyImage(image);\n  read_info=CloneImageInfo(image_info);\n  *read_info->magick='\\0';\n  if (read_info->number_scenes != 0)\n    {\n      if (read_info->number_scenes != 1)\n        (void) FormatLocaleString(options,MagickPathExtent,\"-dLastPage=%.20g\",\n          (double) (read_info->scene+read_info->number_scenes));\n      else\n        (void) FormatLocaleString(options,MagickPathExtent,\n          \"-dFirstPage=%.20g -dLastPage=%.20g\",(double) read_info->scene+1,\n          (double) (read_info->scene+read_info->number_scenes));\n      read_info->number_scenes=0;\n      if (read_info->scenes != (char *) NULL)\n        *read_info->scenes='\\0';\n    }\n  (void) CopyMagickString(filename,read_info->filename,MagickPathExtent);\n  (void) AcquireUniqueFilename(read_info->filename);\n  (void) FormatLocaleString(command,MagickPathExtent,\n    GetDelegateCommands(delegate_info),\n    read_info->antialias != MagickFalse ? 4 : 1,\n    read_info->antialias != MagickFalse ? 4 : 1,density,options,\n    read_info->filename,input_filename);\n  options=DestroyString(options);\n  density=DestroyString(density);\n  status=ExternalDelegateCommand(MagickFalse,read_info->verbose,command,\n    (char *) NULL,exception) != 0 ? MagickTrue : MagickFalse;\n  image=ReadImage(read_info,exception);\n  (void) RelinquishUniqueFileResource(read_info->filename);\n  (void) RelinquishUniqueFileResource(input_filename);\n  read_info=DestroyImageInfo(read_info);\n  if (image == (Image *) NULL)\n    ThrowReaderException(DelegateError,\"PCLDelegateFailed\");\n  if (LocaleCompare(image->magick,\"BMP\") == 0)\n    {\n      Image\n        *cmyk_image;\n\n      cmyk_image=ConsolidateCMYKImages(image,exception);\n      if (cmyk_image != (Image *) NULL)\n        {\n          image=DestroyImageList(image);\n          image=cmyk_image;\n        }\n    }\n  do\n  {\n    (void) CopyMagickString(image->filename,filename,MagickPathExtent);\n    image->page=page;\n    if (image_info->ping != MagickFalse)\n      {\n        image->magick_columns*=image->resolution.x/2.0;\n        image->magick_rows*=image->resolution.y/2.0;\n        image->columns*=image->resolution.x/2.0;\n        image->rows*=image->resolution.y/2.0;\n      }\n    next_image=SyncNextImageInList(image);\n    if (next_image != (Image *) NULL)\n      image=next_image;\n  } while (next_image != (Image *) NULL);\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r P C L I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterPCLImage() adds attributes for the PCL image format to\n%  the list of supported formats.  The attributes include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the i file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterPCLImage method is:\n%\n%      size_t RegisterPCLImage(void)\n%\n*/\nModuleExport size_t RegisterPCLImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"PCL\",\"PCL\",\"Printer Control Language\");\n  entry->decoder=(DecodeImageHandler *) ReadPCLImage;\n  entry->encoder=(EncodeImageHandler *) WritePCLImage;\n  entry->magick=(IsImageFormatHandler *) IsPCL;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->flags^=CoderDecoderThreadSupportFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r P C L I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterPCLImage() removes format registrations made by the PCL module\n%  from the list of supported formats.\n%\n%  The format of the UnregisterPCLImage method is:\n%\n%      UnregisterPCLImage(void)\n%\n*/\nModuleExport void UnregisterPCLImage(void)\n{\n  (void) UnregisterMagickInfo(\"PCL\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e P C L I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WritePCLImage() writes an image in the Page Control Language encoded\n%  image format.\n%\n%  The format of the WritePCLImage method is:\n%\n%      MagickBooleanType WritePCLImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic size_t PCLDeltaCompressImage(const size_t length,\n  const unsigned char *previous_pixels,const unsigned char *pixels,\n  unsigned char *compress_pixels)\n{\n  int\n    delta,\n    j,\n    replacement;\n\n  ssize_t\n    i,\n    x;\n\n  unsigned char\n    *q;\n\n  q=compress_pixels;\n  for (x=0; x < (ssize_t) length; )\n  {\n    j=0;\n    for (i=0; x < (ssize_t) length; x++)\n    {\n      if (*pixels++ != *previous_pixels++)\n        {\n          i=1;\n          break;\n        }\n      j++;\n    }\n    while (x < (ssize_t) length)\n    {\n      x++;\n      if (*pixels == *previous_pixels)\n        break;\n      i++;\n      previous_pixels++;\n      pixels++;\n    }\n    if (i == 0)\n      break;\n    replacement=j >= 31 ? 31 : j;\n    j-=replacement;\n    delta=i >= 8 ? 8 : i;\n    *q++=(unsigned char) (((delta-1) << 5) | replacement);\n    if (replacement == 31)\n      {\n        for (replacement=255; j != 0; )\n        {\n          if (replacement > j)\n            replacement=j;\n          *q++=(unsigned char) replacement;\n          j-=replacement;\n        }\n        if (replacement == 255)\n          *q++='\\0';\n      }\n    for (pixels-=i; i != 0; )\n    {\n      for (i-=delta; delta != 0; delta--)\n        *q++=(*pixels++);\n      if (i == 0)\n        break;\n      delta=i;\n      if (i >= 8)\n        delta=8;\n      *q++=(unsigned char) ((delta-1) << 5);\n    }\n  }\n  return((size_t) (q-compress_pixels));\n}\n\nstatic size_t PCLPackbitsCompressImage(const size_t length,\n  const unsigned char *pixels,unsigned char *compress_pixels)\n{\n  int\n    count;\n\n  ssize_t\n    x;\n\n  unsigned char\n    *q;\n\n  ssize_t\n    j;\n\n  unsigned char\n    packbits[128];\n\n  /*\n    Compress pixels with Packbits encoding.\n  */\n  q=compress_pixels;\n  for (x=(ssize_t) length; x != 0; )\n  {\n    switch (x)\n    {\n      case 1:\n      {\n        x--;\n        *q++=0;\n        *q++=(*pixels);\n        break;\n      }\n      case 2:\n      {\n        x-=2;\n        *q++=1;\n        *q++=(*pixels);\n        *q++=pixels[1];\n        break;\n      }\n      case 3:\n      {\n        x-=3;\n        if ((*pixels == *(pixels+1)) && (*(pixels+1) == *(pixels+2)))\n          {\n            *q++=(unsigned char) ((256-3)+1);\n            *q++=(*pixels);\n            break;\n          }\n        *q++=2;\n        *q++=(*pixels);\n        *q++=pixels[1];\n        *q++=pixels[2];\n        break;\n      }\n      default:\n      {\n        if ((*pixels == *(pixels+1)) && (*(pixels+1) == *(pixels+2)))\n          {\n            /*\n              Packed run.\n            */\n            count=3;\n            while (((ssize_t) count < x) && (*pixels == *(pixels+count)))\n            {\n              count++;\n              if (count >= 127)\n                break;\n            }\n            x-=count;\n            *q++=(unsigned char) ((256-count)+1);\n            *q++=(*pixels);\n            pixels+=count;\n            break;\n          }\n        /*\n          Literal run.\n        */\n        count=0;\n        while ((*(pixels+count) != *(pixels+count+1)) ||\n               (*(pixels+count+1) != *(pixels+count+2)))\n        {\n          packbits[count+1]=pixels[count];\n          count++;\n          if (((ssize_t) count >= (x-3)) || (count >= 127))\n            break;\n        }\n        x-=count;\n        *packbits=(unsigned char) (count-1);\n        for (j=0; j <= (ssize_t) count; j++)\n          *q++=packbits[j];\n        pixels+=count;\n        break;\n      }\n    }\n  }\n  *q++=128; /* EOD marker */\n  return((size_t) (q-compress_pixels));\n}\n\nstatic MagickBooleanType WritePCLImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  char\n    buffer[MagickPathExtent];\n\n  CompressionType\n    compression;\n\n  const char\n    *option;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    scene;\n\n  const Quantum *p;\n\n  ssize_t i, x;\n\n  unsigned char *q;\n\n  size_t\n    density,\n    imageListLength,\n    length,\n    one,\n    packets;\n\n  ssize_t\n    y;\n\n  unsigned char\n    bits_per_pixel,\n    *compress_pixels,\n    *pixels,\n    *previous_pixels;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  density=75;\n  if (image_info->density != (char *) NULL)\n    {\n      GeometryInfo\n        geometry;\n\n      (void) ParseGeometry(image_info->density,&geometry);\n      density=(size_t) geometry.rho;\n    }\n  scene=0;\n  one=1;\n  imageListLength=GetImageListLength(image);\n  do\n  {\n    /*\n      Initialize the printer.\n    */\n    if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n      (void) TransformImageColorspace(image,sRGBColorspace,exception);\n    (void) WriteBlobString(image,\"\\033E\");  /* printer reset */\n    (void) WriteBlobString(image,\"\\033*r3F\");  /* set presentation mode */\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"\\033*r%.20gs%.20gT\",\n      (double) image->columns,(double) image->rows);\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"\\033*t%.20gR\",(double)\n      density);\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\"\\033&l0E\");  /* top margin 0 */\n    if (SetImageMonochrome(image,exception) != MagickFalse)\n      {\n        /*\n          Monochrome image: use default printer monochrome setup.\n        */\n        bits_per_pixel=1;\n      }\n    else\n      if (image->storage_class == DirectClass)\n        {\n          /*\n            DirectClass image.\n          */\n          bits_per_pixel=24;\n          (void) WriteBlobString(image,\"\\033*v6W\"); /* set color mode */\n          (void) WriteBlobByte(image,0); /* RGB */\n          (void) WriteBlobByte(image,3); /* direct by pixel */\n          (void) WriteBlobByte(image,0); /* bits per index (ignored) */\n          (void) WriteBlobByte(image,8); /* bits per red component */\n          (void) WriteBlobByte(image,8); /* bits per green component */\n          (void) WriteBlobByte(image,8); /* bits per blue component */\n        }\n      else\n        {\n          /*\n            Colormapped image.\n          */\n          bits_per_pixel=8;\n          (void) WriteBlobString(image,\"\\033*v6W\"); /* set color mode... */\n          (void) WriteBlobByte(image,0); /* RGB */\n          (void) WriteBlobByte(image,1); /* indexed by pixel */\n          (void) WriteBlobByte(image,bits_per_pixel); /* bits per index */\n          (void) WriteBlobByte(image,8); /* bits per red component */\n          (void) WriteBlobByte(image,8); /* bits per green component */\n          (void) WriteBlobByte(image,8); /* bits per blue component */\n          for (i=0; i < (ssize_t) image->colors; i++)\n          {\n            (void) FormatLocaleString(buffer,MagickPathExtent,\n              \"\\033*v%da%db%dc%.20gI\",\n              ScaleQuantumToChar(image->colormap[i].red),\n              ScaleQuantumToChar(image->colormap[i].green),\n              ScaleQuantumToChar(image->colormap[i].blue),(double) i);\n            (void) WriteBlobString(image,buffer);\n          }\n          for (one=1; i < (ssize_t) (one << bits_per_pixel); i++)\n          {\n            (void) FormatLocaleString(buffer,MagickPathExtent,\"\\033*v%.20gI\",\n              (double) i);\n            (void) WriteBlobString(image,buffer);\n          }\n        }\n    option=GetImageOption(image_info,\"pcl:fit-to-page\");\n    if (IsStringTrue(option) != MagickFalse)\n      (void) WriteBlobString(image,\"\\033*r3A\");\n    else\n      (void) WriteBlobString(image,\"\\033*r1A\");  /* start raster graphics */\n    (void) WriteBlobString(image,\"\\033*b0Y\");  /* set y offset */\n    length=(image->columns*bits_per_pixel+7)/8;\n    pixels=(unsigned char *) AcquireQuantumMemory(length+1,sizeof(*pixels));\n    if (pixels == (unsigned char *) NULL)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) memset(pixels,0,(length+1)*sizeof(*pixels));\n    compress_pixels=(unsigned char *) NULL;\n    previous_pixels=(unsigned char *) NULL;\n\n    compression=UndefinedCompression;\n    if (image_info->compression != UndefinedCompression)\n      compression=image_info->compression;\n    switch (compression)\n    {\n      case NoCompression:\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"\\033*b0M\");\n        (void) WriteBlobString(image,buffer);\n        break;\n      }\n      case RLECompression:\n      {\n        compress_pixels=(unsigned char *) AcquireQuantumMemory(length+256,\n          sizeof(*compress_pixels));\n        if (compress_pixels == (unsigned char *) NULL)\n          {\n            pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n            ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        (void) memset(compress_pixels,0,(length+256)*\n          sizeof(*compress_pixels));\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"\\033*b2M\");\n        (void) WriteBlobString(image,buffer);\n        break;\n      }\n      default:\n      {\n        compress_pixels=(unsigned char *) AcquireQuantumMemory(3*length+256,\n          sizeof(*compress_pixels));\n        if (compress_pixels == (unsigned char *) NULL)\n          {\n            pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n            ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        (void) memset(compress_pixels,0,(3*length+256)*\n          sizeof(*compress_pixels));\n        previous_pixels=(unsigned char *) AcquireQuantumMemory(length+1,\n          sizeof(*previous_pixels));\n        if (previous_pixels == (unsigned char *) NULL)\n          {\n            compress_pixels=(unsigned char *) RelinquishMagickMemory(\n              compress_pixels);\n            pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n            ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        (void) memset(previous_pixels,0,(length+1)*\n          sizeof(*previous_pixels));\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"\\033*b3M\");\n        (void) WriteBlobString(image,buffer);\n        break;\n      }\n    }\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n      if (p == (const Quantum *) NULL)\n        break;\n      q=pixels;\n      switch (bits_per_pixel)\n      {\n        case 1:\n        {\n          unsigned char\n            bit,\n            byte;\n\n          /*\n            Monochrome image.\n          */\n          bit=0;\n          byte=0;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            byte<<=1;\n            if (GetPixelLuma(image,p) < (QuantumRange/2.0))\n              byte|=0x01;\n            bit++;\n            if (bit == 8)\n              {\n                *q++=byte;\n                bit=0;\n                byte=0;\n              }\n            p+=GetPixelChannels(image);\n          }\n          if (bit != 0)\n            *q++=byte << (8-bit);\n          break;\n        }\n        case 8:\n        {\n          /*\n            Colormapped image.\n          */\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            *q++=(unsigned char) ((ssize_t) GetPixelIndex(image,p));\n            p+=GetPixelChannels(image);\n          }\n          break;\n        }\n        case 24:\n        case 32:\n        {\n          /*\n            Truecolor image.\n          */\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            *q++=ScaleQuantumToChar(GetPixelRed(image,p));\n            *q++=ScaleQuantumToChar(GetPixelGreen(image,p));\n            *q++=ScaleQuantumToChar(GetPixelBlue(image,p));\n            p+=GetPixelChannels(image);\n          }\n          break;\n        }\n      }\n      switch (compression)\n      {\n        case NoCompression:\n        {\n          (void) FormatLocaleString(buffer,MagickPathExtent,\"\\033*b%.20gW\",\n            (double) length);\n          (void) WriteBlobString(image,buffer);\n          (void) WriteBlob(image,length,pixels);\n          break;\n        }\n        case RLECompression:\n        {\n          packets=PCLPackbitsCompressImage(length,pixels,compress_pixels);\n          (void) FormatLocaleString(buffer,MagickPathExtent,\"\\033*b%.20gW\",\n            (double) packets);\n          (void) WriteBlobString(image,buffer);\n          (void) WriteBlob(image,packets,compress_pixels);\n          break;\n        }\n        default:\n        {\n          if (y == 0)\n            for (i=0; i < (ssize_t) length; i++)\n              previous_pixels[i]=(~pixels[i]);\n          packets=PCLDeltaCompressImage(length,previous_pixels,pixels,\n            compress_pixels);\n          (void) FormatLocaleString(buffer,MagickPathExtent,\"\\033*b%.20gW\",\n            (double) packets);\n          (void) WriteBlobString(image,buffer);\n          (void) WriteBlob(image,packets,compress_pixels);\n          (void) memcpy(previous_pixels,pixels,length*\n            sizeof(*pixels));\n          break;\n        }\n      }\n    }\n    (void) WriteBlobString(image,\"\\033*rB\");  /* end graphics */\n    switch (compression)\n    {\n      case NoCompression:\n        break;\n      case RLECompression:\n      {\n        compress_pixels=(unsigned char *) RelinquishMagickMemory(\n          compress_pixels);\n        break;\n      }\n      default:\n      {\n        previous_pixels=(unsigned char *) RelinquishMagickMemory(\n          previous_pixels);\n        compress_pixels=(unsigned char *) RelinquishMagickMemory(\n          compress_pixels);\n        break;\n      }\n    }\n    pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,imageListLength);\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  (void) WriteBlobString(image,\"\\033E\");\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                            PPPP    CCCC  L                                  %\n%                            P   P  C      L                                  %\n%                            PPPP   C      L                                  %\n%                            P      C      L                                  %\n%                            P       CCCC  LLLLL                              %\n%                                                                             %\n%                                                                             %\n%                      Read/Write HP PCL Printer Format                       %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright @ 1999 ImageMagick Studio LLC, a non-profit organization         %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/artifact.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/delegate.h\"\n#include \"MagickCore/draw.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/profile.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/token.h\"\n#include \"MagickCore/transform.h\"\n#include \"MagickCore/utility.h\"\n\f\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  WritePCLImage(const ImageInfo *,Image *,ExceptionInfo *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s P C L                                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsPCL() returns MagickTrue if the image format type, identified by the\n%  magick string, is PCL.\n%\n%  The format of the IsPCL method is:\n%\n%      MagickBooleanType IsPCL(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsPCL(const unsigned char *magick,const size_t length)\n{\n  if (length < 4)\n    return(MagickFalse);\n  if (memcmp(magick,\"\\033E\\033&\",4) == 0)\n    return(MagickFalse);\n  if (memcmp(magick,\"\\033E\\033\",3) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d P C L I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadPCLImage() reads a Printer Control Language image file and returns it.\n%  It allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the ReadPCLImage method is:\n%\n%      Image *ReadPCLImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *ReadPCLImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define CropBox  \"CropBox\"\n#define DeviceCMYK  \"DeviceCMYK\"\n#define MediaBox  \"MediaBox\"\n#define RenderPCLText  \"  Rendering PCL...  \"\n\n  char\n    command[MagickPathExtent],\n    *density,\n    filename[MagickPathExtent],\n    geometry[MagickPathExtent],\n    *options,\n    input_filename[MagickPathExtent];\n\n  const DelegateInfo\n    *delegate_info;\n\n  Image\n    *image,\n    *next_image;\n\n  ImageInfo\n    *read_info;\n\n  MagickBooleanType\n    cmyk,\n    status;\n\n  PointInfo\n    delta;\n\n  RectangleInfo\n    bounding_box,\n    page;\n\n  char\n    *p;\n\n  ssize_t\n    c;\n\n  SegmentInfo\n    bounds;\n\n  size_t\n    height,\n    width;\n\n  ssize_t\n    count;\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  /*\n    Open image file.\n  */\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  status=AcquireUniqueSymbolicLink(image_info->filename,input_filename);\n  if (status == MagickFalse)\n    {\n      ThrowFileException(exception,FileOpenError,\"UnableToCreateTemporaryFile\",\n        image_info->filename);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Set the page density.\n  */\n  delta.x=DefaultResolution;\n  delta.y=DefaultResolution;\n  if ((image->resolution.x == 0.0) || (image->resolution.y == 0.0))\n    {\n      GeometryInfo\n        geometry_info;\n\n      MagickStatusType\n        flags;\n\n      flags=ParseGeometry(PSDensityGeometry,&geometry_info);\n      if ((flags & RhoValue) != 0)\n        image->resolution.x=geometry_info.rho;\n      image->resolution.y=image->resolution.x;\n      if ((flags & SigmaValue) != 0)\n        image->resolution.y=geometry_info.sigma;\n    }\n  /*\n    Determine page geometry from the PCL media box.\n  */\n  cmyk=image->colorspace == CMYKColorspace ? MagickTrue : MagickFalse;\n  count=0;\n  (void) memset(&bounding_box,0,sizeof(bounding_box));\n  (void) memset(&bounds,0,sizeof(bounds));\n  (void) memset(&page,0,sizeof(page));\n  (void) memset(command,0,sizeof(command));\n  p=command;\n  for (c=ReadBlobByte(image); c != EOF; c=ReadBlobByte(image))\n  {\n    if (image_info->page != (char *) NULL)\n      continue;\n    /*\n      Note PCL elements.\n    */\n    *p++=(char) c;\n    if ((c != (int) '/') && (c != '\\n') &&\n        ((size_t) (p-command) < (MagickPathExtent-1)))\n      continue;\n    *p='\\0';\n    p=command;\n    /*\n      Is this a CMYK document?\n    */\n    if (LocaleNCompare(DeviceCMYK,command,strlen(DeviceCMYK)) == 0)\n      cmyk=MagickTrue;\n    if (LocaleNCompare(CropBox,command,strlen(CropBox)) == 0)\n      {\n        /*\n          Note region defined by crop box.\n        */\n        count=(ssize_t) sscanf(command,\"CropBox [%lf %lf %lf %lf\",\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n        if (count != 4)\n          count=(ssize_t) sscanf(command,\"CropBox[%lf %lf %lf %lf\",\n            &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n      }\n    if (LocaleNCompare(MediaBox,command,strlen(MediaBox)) == 0)\n      {\n        /*\n          Note region defined by media box.\n        */\n        count=(ssize_t) sscanf(command,\"MediaBox [%lf %lf %lf %lf\",\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n        if (count != 4)\n          count=(ssize_t) sscanf(command,\"MediaBox[%lf %lf %lf %lf\",\n            &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n      }\n    if (count != 4)\n      continue;\n    /*\n      Set PCL render geometry.\n    */\n    width=(size_t)CastDoubleToLong(floor(bounds.x2-bounds.x1+0.5));\n    height=(size_t)CastDoubleToLong(floor(bounds.y2-bounds.y1+0.5));\n    if (width > page.width)\n      page.width=width;\n    if (height > page.height)\n      page.height=height;\n  }\n  (void) CloseBlob(image);\n  /*\n    Render PCL with the GhostPCL delegate.\n  */\n  if ((page.width == 0) || (page.height == 0))\n    (void) ParseAbsoluteGeometry(PSPageGeometry,&page);\n  if (image_info->page != (char *) NULL)\n    (void) ParseAbsoluteGeometry(image_info->page,&page);\n  (void) FormatLocaleString(geometry,MagickPathExtent,\"%.20gx%.20g\",(double)\n    page.width,(double) page.height);\n  if (image_info->monochrome != MagickFalse)\n    delegate_info=GetDelegateInfo(\"pcl:mono\",(char *) NULL,exception);\n  else\n     if (cmyk != MagickFalse)\n       delegate_info=GetDelegateInfo(\"pcl:cmyk\",(char *) NULL,exception);\n     else\n       delegate_info=GetDelegateInfo(\"pcl:color\",(char *) NULL,exception);\n  if (delegate_info == (const DelegateInfo *) NULL)\n    {\n      image=DestroyImage(image);\n      return((Image *) NULL);\n    }\n  if ((page.width == 0) || (page.height == 0))\n    (void) ParseAbsoluteGeometry(PSPageGeometry,&page);\n  if (image_info->page != (char *) NULL)\n    (void) ParseAbsoluteGeometry(image_info->page,&page);\n  density=AcquireString(\"\");\n  options=AcquireString(\"\");\n  (void) FormatLocaleString(density,MagickPathExtent,\"%gx%g\",\n    image->resolution.x,image->resolution.y);\n  if (image_info->ping != MagickFalse)\n    (void) FormatLocaleString(density,MagickPathExtent,\"2.0x2.0\");\n  page.width=(size_t) floor(page.width*image->resolution.x/delta.x+0.5);\n  page.height=(size_t) floor(page.height*image->resolution.y/delta.y+0.5);\n  (void) FormatLocaleString(options,MagickPathExtent,\"-g%.20gx%.20g \",(double)\n    page.width,(double) page.height);\n  image=DestroyImage(image);\n  read_info=CloneImageInfo(image_info);\n  *read_info->magick='\\0';\n  if (read_info->number_scenes != 0)\n    {\n      if (read_info->number_scenes != 1)\n        (void) FormatLocaleString(options,MagickPathExtent,\"-dLastPage=%.20g\",\n          (double) (read_info->scene+read_info->number_scenes));\n      else\n        (void) FormatLocaleString(options,MagickPathExtent,\n          \"-dFirstPage=%.20g -dLastPage=%.20g\",(double) read_info->scene+1,\n          (double) (read_info->scene+read_info->number_scenes));\n      read_info->number_scenes=0;\n      if (read_info->scenes != (char *) NULL)\n        *read_info->scenes='\\0';\n    }\n  (void) CopyMagickString(filename,read_info->filename,MagickPathExtent);\n  (void) AcquireUniqueFilename(read_info->filename);\n  (void) FormatLocaleString(command,MagickPathExtent,\n    GetDelegateCommands(delegate_info),\n    read_info->antialias != MagickFalse ? 4 : 1,\n    read_info->antialias != MagickFalse ? 4 : 1,density,options,\n    read_info->filename,input_filename);\n  options=DestroyString(options);\n  density=DestroyString(density);\n  status=ExternalDelegateCommand(MagickFalse,read_info->verbose,command,\n    (char *) NULL,exception) != 0 ? MagickTrue : MagickFalse;\n  image=ReadImage(read_info,exception);\n  (void) RelinquishUniqueFileResource(read_info->filename);\n  (void) RelinquishUniqueFileResource(input_filename);\n  read_info=DestroyImageInfo(read_info);\n  if (image == (Image *) NULL)\n    ThrowReaderException(DelegateError,\"PCLDelegateFailed\");\n  if (LocaleCompare(image->magick,\"BMP\") == 0)\n    {\n      Image\n        *cmyk_image;\n\n      cmyk_image=ConsolidateCMYKImages(image,exception);\n      if (cmyk_image != (Image *) NULL)\n        {\n          image=DestroyImageList(image);\n          image=cmyk_image;\n        }\n    }\n  do\n  {\n    (void) CopyMagickString(image->filename,filename,MagickPathExtent);\n    image->page=page;\n    if (image_info->ping != MagickFalse)\n      {\n        image->magick_columns*=image->resolution.x/2.0;\n        image->magick_rows*=image->resolution.y/2.0;\n        image->columns*=image->resolution.x/2.0;\n        image->rows*=image->resolution.y/2.0;\n      }\n    next_image=SyncNextImageInList(image);\n    if (next_image != (Image *) NULL)\n      image=next_image;\n  } while (next_image != (Image *) NULL);\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r P C L I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterPCLImage() adds attributes for the PCL image format to\n%  the list of supported formats.  The attributes include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the i file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterPCLImage method is:\n%\n%      size_t RegisterPCLImage(void)\n%\n*/\nModuleExport size_t RegisterPCLImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"PCL\",\"PCL\",\"Printer Control Language\");\n  entry->decoder=(DecodeImageHandler *) ReadPCLImage;\n  entry->encoder=(EncodeImageHandler *) WritePCLImage;\n  entry->magick=(IsImageFormatHandler *) IsPCL;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->flags^=CoderDecoderThreadSupportFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r P C L I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterPCLImage() removes format registrations made by the PCL module\n%  from the list of supported formats.\n%\n%  The format of the UnregisterPCLImage method is:\n%\n%      UnregisterPCLImage(void)\n%\n*/\nModuleExport void UnregisterPCLImage(void)\n{\n  (void) UnregisterMagickInfo(\"PCL\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e P C L I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WritePCLImage() writes an image in the Page Control Language encoded\n%  image format.\n%\n%  The format of the WritePCLImage method is:\n%\n%      MagickBooleanType WritePCLImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic size_t PCLDeltaCompressImage(const size_t length,\n  const unsigned char *previous_pixels,const unsigned char *pixels,\n  unsigned char *compress_pixels)\n{\n  int\n    delta,\n    j,\n    replacement;\n\n  ssize_t\n    i,\n    x;\n\n  unsigned char\n    *q;\n\n  q=compress_pixels;\n  for (x=0; x < (ssize_t) length; )\n  {\n    j=0;\n    for (i=0; x < (ssize_t) length; x++)\n    {\n      if (*pixels++ != *previous_pixels++)\n        {\n          i=1;\n          break;\n        }\n      j++;\n    }\n    while (x < (ssize_t) length)\n    {\n      x++;\n      if (*pixels == *previous_pixels)\n        break;\n      i++;\n      previous_pixels++;\n      pixels++;\n    }\n    if (i == 0)\n      break;\n    replacement=j >= 31 ? 31 : j;\n    j-=replacement;\n    delta=i >= 8 ? 8 : i;\n    *q++=(unsigned char) (((delta-1) << 5) | replacement);\n    if (replacement == 31)\n      {\n        for (replacement=255; j != 0; )\n        {\n          if (replacement > j)\n            replacement=j;\n          *q++=(unsigned char) replacement;\n          j-=replacement;\n        }\n        if (replacement == 255)\n          *q++='\\0';\n      }\n    for (pixels-=i; i != 0; )\n    {\n      for (i-=delta; delta != 0; delta--)\n        *q++=(*pixels++);\n      if (i == 0)\n        break;\n      delta=i;\n      if (i >= 8)\n        delta=8;\n      *q++=(unsigned char) ((delta-1) << 5);\n    }\n  }\n  return((size_t) (q-compress_pixels));\n}\n\nstatic size_t PCLPackbitsCompressImage(const size_t length,\n  const unsigned char *pixels,unsigned char *compress_pixels)\n{\n  int\n    count;\n\n  ssize_t\n    x;\n\n  unsigned char\n    *q;\n\n  ssize_t\n    j;\n\n  unsigned char\n    packbits[128];\n\n  /*\n    Compress pixels with Packbits encoding.\n  */\n  q=compress_pixels;\n  for (x=(ssize_t) length; x != 0; )\n  {\n    switch (x)\n    {\n      case 1:\n      {\n        x--;\n        *q++=0;\n        *q++=(*pixels);\n        break;\n      }\n      case 2:\n      {\n        x-=2;\n        *q++=1;\n        *q++=(*pixels);\n        *q++=pixels[1];\n        break;\n      }\n      case 3:\n      {\n        x-=3;\n        if ((*pixels == *(pixels+1)) && (*(pixels+1) == *(pixels+2)))\n          {\n            *q++=(unsigned char) ((256-3)+1);\n            *q++=(*pixels);\n            break;\n          }\n        *q++=2;\n        *q++=(*pixels);\n        *q++=pixels[1];\n        *q++=pixels[2];\n        break;\n      }\n      default:\n      {\n        if ((*pixels == *(pixels+1)) && (*(pixels+1) == *(pixels+2)))\n          {\n            /*\n              Packed run.\n            */\n            count=3;\n            while (((ssize_t) count < x) && (*pixels == *(pixels+count)))\n            {\n              count++;\n              if (count >= 127)\n                break;\n            }\n            x-=count;\n            *q++=(unsigned char) ((256-count)+1);\n            *q++=(*pixels);\n            pixels+=count;\n            break;\n          }\n        /*\n          Literal run.\n        */\n        count=0;\n        while ((*(pixels+count) != *(pixels+count+1)) ||\n               (*(pixels+count+1) != *(pixels+count+2)))\n        {\n          packbits[count+1]=pixels[count];\n          count++;\n          if (((ssize_t) count >= (x-3)) || (count >= 127))\n            break;\n        }\n        x-=count;\n        *packbits=(unsigned char) (count-1);\n        for (j=0; j <= (ssize_t) count; j++)\n          *q++=packbits[j];\n        pixels+=count;\n        break;\n      }\n    }\n  }\n  *q++=128; /* EOD marker */\n  return((size_t) (q-compress_pixels));\n}\n\nstatic MagickBooleanType WritePCLImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  char\n    buffer[MagickPathExtent];\n\n  CompressionType\n    compression;\n\n  const char\n    *option;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    scene;\n\n  const Quantum *p;\n\n  ssize_t i, x;\n\n  unsigned char *q;\n\n  size_t\n    density,\n    imageListLength,\n    length,\n    one,\n    packets;\n\n  ssize_t\n    y;\n\n  unsigned char\n    bits_per_pixel,\n    *compress_pixels,\n    *pixels,\n    *previous_pixels;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  density=75;\n  if (image_info->density != (char *) NULL)\n    {\n      GeometryInfo\n        geometry;\n\n      (void) ParseGeometry(image_info->density,&geometry);\n      density=(size_t) geometry.rho;\n    }\n  scene=0;\n  one=1;\n  imageListLength=GetImageListLength(image);\n  do\n  {\n    /*\n      Initialize the printer.\n    */\n    if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n      (void) TransformImageColorspace(image,sRGBColorspace,exception);\n    (void) WriteBlobString(image,\"\\033E\");  /* printer reset */\n    (void) WriteBlobString(image,\"\\033*r3F\");  /* set presentation mode */\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"\\033*r%.20gs%.20gT\",\n      (double) image->columns,(double) image->rows);\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"\\033*t%.20gR\",(double)\n      density);\n    (void) WriteBlobString(image,buffer);\n    (void) WriteBlobString(image,\"\\033&l0E\");  /* top margin 0 */\n    if (SetImageMonochrome(image,exception) != MagickFalse)\n      {\n        /*\n          Monochrome image: use default printer monochrome setup.\n        */\n        bits_per_pixel=1;\n      }\n    else\n      if (image->storage_class == DirectClass)\n        {\n          /*\n            DirectClass image.\n          */\n          bits_per_pixel=24;\n          (void) WriteBlobString(image,\"\\033*v6W\"); /* set color mode */\n          (void) WriteBlobByte(image,0); /* RGB */\n          (void) WriteBlobByte(image,3); /* direct by pixel */\n          (void) WriteBlobByte(image,0); /* bits per index (ignored) */\n          (void) WriteBlobByte(image,8); /* bits per red component */\n          (void) WriteBlobByte(image,8); /* bits per green component */\n          (void) WriteBlobByte(image,8); /* bits per blue component */\n        }\n      else\n        {\n          /*\n            Colormapped image.\n          */\n          bits_per_pixel=8;\n          (void) WriteBlobString(image,\"\\033*v6W\"); /* set color mode... */\n          (void) WriteBlobByte(image,0); /* RGB */\n          (void) WriteBlobByte(image,1); /* indexed by pixel */\n          (void) WriteBlobByte(image,bits_per_pixel); /* bits per index */\n          (void) WriteBlobByte(image,8); /* bits per red component */\n          (void) WriteBlobByte(image,8); /* bits per green component */\n          (void) WriteBlobByte(image,8); /* bits per blue component */\n          for (i=0; i < (ssize_t) image->colors; i++)\n          {\n            (void) FormatLocaleString(buffer,MagickPathExtent,\n              \"\\033*v%da%db%dc%.20gI\",\n              ScaleQuantumToChar(image->colormap[i].red),\n              ScaleQuantumToChar(image->colormap[i].green),\n              ScaleQuantumToChar(image->colormap[i].blue),(double) i);\n            (void) WriteBlobString(image,buffer);\n          }\n          for (one=1; i < (ssize_t) (one << bits_per_pixel); i++)\n          {\n            (void) FormatLocaleString(buffer,MagickPathExtent,\"\\033*v%.20gI\",\n              (double) i);\n            (void) WriteBlobString(image,buffer);\n          }\n        }\n    option=GetImageOption(image_info,\"pcl:fit-to-page\");\n    if (IsStringTrue(option) != MagickFalse)\n      (void) WriteBlobString(image,\"\\033*r3A\");\n    else\n      (void) WriteBlobString(image,\"\\033*r1A\");  /* start raster graphics */\n    (void) WriteBlobString(image,\"\\033*b0Y\");  /* set y offset */\n    length=(image->columns*bits_per_pixel+7)/8;\n    pixels=(unsigned char *) AcquireQuantumMemory(length+1,sizeof(*pixels));\n    if (pixels == (unsigned char *) NULL)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) memset(pixels,0,(length+1)*sizeof(*pixels));\n    compress_pixels=(unsigned char *) NULL;\n    previous_pixels=(unsigned char *) NULL;\n\n    compression=UndefinedCompression;\n    if (image_info->compression != UndefinedCompression)\n      compression=image_info->compression;\n    switch (compression)\n    {\n      case NoCompression:\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"\\033*b0M\");\n        (void) WriteBlobString(image,buffer);\n        break;\n      }\n      case RLECompression:\n      {\n        compress_pixels=(unsigned char *) AcquireQuantumMemory(length+256,\n          sizeof(*compress_pixels));\n        if (compress_pixels == (unsigned char *) NULL)\n          {\n            pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n            ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        (void) memset(compress_pixels,0,(length+256)*\n          sizeof(*compress_pixels));\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"\\033*b2M\");\n        (void) WriteBlobString(image,buffer);\n        break;\n      }\n      default:\n      {\n        compress_pixels=(unsigned char *) AcquireQuantumMemory(3*length+256,\n          sizeof(*compress_pixels));\n        if (compress_pixels == (unsigned char *) NULL)\n          {\n            pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n            ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        (void) memset(compress_pixels,0,(3*length+256)*\n          sizeof(*compress_pixels));\n        previous_pixels=(unsigned char *) AcquireQuantumMemory(length+1,\n          sizeof(*previous_pixels));\n        if (previous_pixels == (unsigned char *) NULL)\n          {\n            compress_pixels=(unsigned char *) RelinquishMagickMemory(\n              compress_pixels);\n            pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n            ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        (void) memset(previous_pixels,0,(length+1)*\n          sizeof(*previous_pixels));\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"\\033*b3M\");\n        (void) WriteBlobString(image,buffer);\n        break;\n      }\n    }\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n      if (p == (const Quantum *) NULL)\n        break;\n      q=pixels;\n      switch (bits_per_pixel)\n      {\n        case 1:\n        {\n          unsigned char\n            bit,\n            byte;\n\n          /*\n            Monochrome image.\n          */\n          bit=0;\n          byte=0;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            byte<<=1;\n            if (GetPixelLuma(image,p) < (QuantumRange/2.0))\n              byte|=0x01;\n            bit++;\n            if (bit == 8)\n              {\n                *q++=byte;\n                bit=0;\n                byte=0;\n              }\n            p+=GetPixelChannels(image);\n          }\n          if (bit != 0)\n            *q++=byte << (8-bit);\n          break;\n        }\n        case 8:\n        {\n          /*\n            Colormapped image.\n          */\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            *q++=(unsigned char) ((ssize_t) GetPixelIndex(image,p));\n            p+=GetPixelChannels(image);\n          }\n          break;\n        }\n        case 24:\n        case 32:\n        {\n          /*\n            Truecolor image.\n          */\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            *q++=ScaleQuantumToChar(GetPixelRed(image,p));\n            *q++=ScaleQuantumToChar(GetPixelGreen(image,p));\n            *q++=ScaleQuantumToChar(GetPixelBlue(image,p));\n            p+=GetPixelChannels(image);\n          }\n          break;\n        }\n      }\n      switch (compression)\n      {\n        case NoCompression:\n        {\n          (void) FormatLocaleString(buffer,MagickPathExtent,\"\\033*b%.20gW\",\n            (double) length);\n          (void) WriteBlobString(image,buffer);\n          (void) WriteBlob(image,length,pixels);\n          break;\n        }\n        case RLECompression:\n        {\n          packets=PCLPackbitsCompressImage(length,pixels,compress_pixels);\n          (void) FormatLocaleString(buffer,MagickPathExtent,\"\\033*b%.20gW\",\n            (double) packets);\n          (void) WriteBlobString(image,buffer);\n          (void) WriteBlob(image,packets,compress_pixels);\n          break;\n        }\n        default:\n        {\n          if (y == 0)\n            for (i=0; i < (ssize_t) length; i++)\n              previous_pixels[i]=(~pixels[i]);\n          packets=PCLDeltaCompressImage(length,previous_pixels,pixels,\n            compress_pixels);\n          (void) FormatLocaleString(buffer,MagickPathExtent,\"\\033*b%.20gW\",\n            (double) packets);\n          (void) WriteBlobString(image,buffer);\n          (void) WriteBlob(image,packets,compress_pixels);\n          (void) memcpy(previous_pixels,pixels,length*\n            sizeof(*pixels));\n          break;\n        }\n      }\n    }\n    (void) WriteBlobString(image,\"\\033*rB\");  /* end graphics */\n    switch (compression)\n    {\n      case NoCompression:\n        break;\n      case RLECompression:\n      {\n        compress_pixels=(unsigned char *) RelinquishMagickMemory(\n          compress_pixels);\n        break;\n      }\n      default:\n      {\n        previous_pixels=(unsigned char *) RelinquishMagickMemory(\n          previous_pixels);\n        compress_pixels=(unsigned char *) RelinquishMagickMemory(\n          compress_pixels);\n        break;\n      }\n    }\n    pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,imageListLength);\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  (void) WriteBlobString(image,\"\\033E\");\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n"], "filenames": ["coders/pcl.c"], "buggy_code_start_loc": [302], "buggy_code_end_loc": [304], "fixing_code_start_loc": [302], "fixing_code_end_loc": [304], "type": "CWE-190", "message": "A vulnerability was found in ImageMagick, causing an outside the range of representable values of type 'unsigned long' at coders/pcl.c, when crafted or untrusted input is processed. This leads to a negative impact to application availability or other problems related to undefined behavior.", "other": {"cve": {"id": "CVE-2022-32546", "sourceIdentifier": "secalert@redhat.com", "published": "2022-06-16T18:15:10.927", "lastModified": "2023-05-22T02:15:11.357", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "A vulnerability was found in ImageMagick, causing an outside the range of representable values of type 'unsigned long' at coders/pcl.c, when crafted or untrusted input is processed. This leads to a negative impact to application availability or other problems related to undefined behavior."}, {"lang": "es", "value": "Se ha encontrado una vulnerabilidad en ImageMagick, que causa una salida del rango de valores representables del tipo \"unsigned long\" en el archivo coders/pcl.c, cuando es procesada una entrada dise\u00f1ada o no confiable. Esto conlleva un impacto negativo en la disponibilidad de la aplicaci\u00f3n u otros problemas relacionados con un comportamiento indefinido"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "versionEndExcluding": "6.9.12-44", "matchCriteriaId": "62ED872E-70D8-4736-9876-F307A77839D4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "versionStartIncluding": "7.1.0", "versionEndExcluding": "7.1.0-29", "matchCriteriaId": "7D490A92-4291-4932-B39B-371F7F3592E0"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:fedoraproject:extra_packages_for_enterprise_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "BB176AC3-3CDA-4DDA-9089-C67B2F73AA62"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "2F6AB192-9D7D-4A9A-8995-E53A9DE9EAFC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "142AD0DD-4CF3-4D74-9442-459CE3347E3A"}]}]}], "references": [{"url": "https://bugzilla.redhat.com/show_bug.cgi?id=2091812", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/f221ea0fa3171f0f4fdf74ac9d81b203b9534c23", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick6/commit/29c8abce0da56b536542f76a9ddfebdaab5b2943", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2023/05/msg00020.html", "source": "secalert@redhat.com"}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/f221ea0fa3171f0f4fdf74ac9d81b203b9534c23"}}