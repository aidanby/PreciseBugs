{"buggy_code": ["/*\n** io.c - IO class\n*/\n\n#include \"mruby.h\"\n#include \"mruby/array.h\"\n#include \"mruby/class.h\"\n#include \"mruby/data.h\"\n#include \"mruby/hash.h\"\n#include \"mruby/string.h\"\n#include \"mruby/variable.h\"\n#include \"mruby/ext/io.h\"\n\n#if MRUBY_RELEASE_NO < 10000\n#include \"error.h\"\n#else\n#include \"mruby/error.h\"\n#endif\n\n#include <sys/types.h>\n#include <sys/stat.h>\n\n#if defined(_WIN32) || defined(_WIN64)\n  #include <winsock.h>\n  #include <io.h>\n  #define open  _open\n  #define close _close\n  #define dup _dup\n  #define dup2 _dup2\n  #define read  _read\n  #define write _write\n  #define lseek _lseek\n  #define isatty _isatty\n  #define WEXITSTATUS(x) (x)\n  typedef int fsize_t;\n  typedef long ftime_t;\n  typedef long fsuseconds_t;\n  typedef int fmode_t;\n\n#else\n  #include <sys/wait.h>\n  #include <unistd.h>\n  typedef size_t fsize_t;\n  typedef time_t ftime_t;\n  typedef suseconds_t fsuseconds_t;\n  typedef mode_t fmode_t;\n#endif\n\n#ifdef _MSC_VER\ntypedef mrb_int pid_t;\n#endif\n\n#include <fcntl.h>\n\n#include <errno.h>\n#include <stdio.h>\n#include <string.h>\n\n\nstatic void mrb_io_free(mrb_state *mrb, void *ptr);\nstruct mrb_data_type mrb_io_type = { \"IO\", mrb_io_free };\n\n\nstatic struct mrb_io *io_get_open_fptr(mrb_state *mrb, mrb_value self);\nstatic int mrb_io_modestr_to_flags(mrb_state *mrb, const char *modestr);\nstatic int mrb_io_flags_to_modenum(mrb_state *mrb, int flags);\nstatic void fptr_finalize(mrb_state *mrb, struct mrb_io *fptr, int quiet);\n\n#if MRUBY_RELEASE_NO < 10000\nstatic struct RClass *\nmrb_module_get(mrb_state *mrb, const char *name)\n{\n  return mrb_class_get(mrb, name);\n}\n#endif\n\nstatic struct mrb_io *\nio_get_open_fptr(mrb_state *mrb, mrb_value self)\n{\n  struct mrb_io *fptr;\n\n  fptr = (struct mrb_io *)mrb_get_datatype(mrb, self, &mrb_io_type);\n  if (fptr->fd < 0) {\n    mrb_raise(mrb, E_IO_ERROR, \"closed stream.\");\n  }\n  return fptr;\n}\n\nstatic void\nio_set_process_status(mrb_state *mrb, pid_t pid, int status)\n{\n  struct RClass *c_process, *c_status;\n  mrb_value v;\n\n  c_status = NULL;\n  if (mrb_class_defined(mrb, \"Process\")) {\n    c_process = mrb_module_get(mrb, \"Process\");\n    if (mrb_const_defined(mrb, mrb_obj_value(c_process), mrb_intern_cstr(mrb, \"Status\"))) {\n      c_status = mrb_class_get_under(mrb, c_process, \"Status\");\n    }\n  }\n  if (c_status != NULL) {\n    v = mrb_funcall(mrb, mrb_obj_value(c_status), \"new\", 2, mrb_fixnum_value(pid), mrb_fixnum_value(status));\n  } else {\n    v = mrb_fixnum_value(WEXITSTATUS(status));\n  }\n  mrb_gv_set(mrb, mrb_intern_cstr(mrb, \"$?\"), v);\n}\n\nstatic int\nmrb_io_modestr_to_flags(mrb_state *mrb, const char *mode)\n{\n  int flags = 0;\n  const char *m = mode;\n\n  switch (*m++) {\n    case 'r':\n      flags |= FMODE_READABLE;\n      break;\n    case 'w':\n      flags |= FMODE_WRITABLE | FMODE_CREATE | FMODE_TRUNC;\n      break;\n    case 'a':\n      flags |= FMODE_WRITABLE | FMODE_APPEND | FMODE_CREATE;\n      break;\n    default:\n      mrb_raisef(mrb, E_ARGUMENT_ERROR, \"illegal access mode %S\", mrb_str_new_cstr(mrb, mode));\n  }\n\n  while (*m) {\n    switch (*m++) {\n      case 'b':\n        flags |= FMODE_BINMODE;\n        break;\n      case '+':\n        flags |= FMODE_READWRITE;\n        break;\n      case ':':\n        /* XXX: PASSTHROUGH*/\n      default:\n        mrb_raisef(mrb, E_ARGUMENT_ERROR, \"illegal access mode %S\", mrb_str_new_cstr(mrb, mode));\n    }\n  }\n\n  return flags;\n}\n\nstatic int\nmrb_io_flags_to_modenum(mrb_state *mrb, int flags)\n{\n  int modenum = 0;\n\n  switch(flags & (FMODE_READABLE|FMODE_WRITABLE|FMODE_READWRITE)) {\n    case FMODE_READABLE:\n      modenum = O_RDONLY;\n      break;\n    case FMODE_WRITABLE:\n      modenum = O_WRONLY;\n      break;\n    case FMODE_READWRITE:\n      modenum = O_RDWR;\n      break;\n  }\n\n  if (flags & FMODE_APPEND) {\n    modenum |= O_APPEND;\n  }\n  if (flags & FMODE_TRUNC) {\n    modenum |= O_TRUNC;\n  }\n  if (flags & FMODE_CREATE) {\n    modenum |= O_CREAT;\n  }\n#ifdef O_BINARY\n  if (flags & FMODE_BINMODE) {\n    modenum |= O_BINARY;\n  }\n#endif\n\n  return modenum;\n}\n\nstatic void\nmrb_fd_cloexec(mrb_state *mrb, int fd)\n{\n#if defined(F_GETFD) && defined(F_SETFD) && defined(FD_CLOEXEC)\n  int flags, flags2;\n\n  flags = fcntl(fd, F_GETFD);\n  if (flags == -1) {\n    mrb_bug(mrb, \"mrb_fd_cloexec: fcntl(%S, F_GETFD) failed: %S\",\n      mrb_fixnum_value(fd), mrb_fixnum_value(errno));\n  }\n  if (fd <= 2) {\n    flags2 = flags & ~FD_CLOEXEC; /* Clear CLOEXEC for standard file descriptors: 0, 1, 2. */\n  }\n  else {\n    flags2 = flags | FD_CLOEXEC; /* Set CLOEXEC for non-standard file descriptors: 3, 4, 5, ... */\n  }\n  if (flags != flags2) {\n    if (fcntl(fd, F_SETFD, flags2) == -1) {\n      mrb_bug(mrb, \"mrb_fd_cloexec: fcntl(%S, F_SETFD, %S) failed: %S\",\n        mrb_fixnum_value(fd), mrb_fixnum_value(flags2), mrb_fixnum_value(errno));\n    }\n  }\n#endif\n}\n\n#ifndef _WIN32\nstatic int\nmrb_cloexec_pipe(mrb_state *mrb, int fildes[2])\n{\n  int ret;\n  ret = pipe(fildes);\n  if (ret == -1)\n    return -1;\n  mrb_fd_cloexec(mrb, fildes[0]);\n  mrb_fd_cloexec(mrb, fildes[1]);\n  return ret;\n}\n\nstatic int\nmrb_pipe(mrb_state *mrb, int pipes[2])\n{\n  int ret;\n  ret = mrb_cloexec_pipe(mrb, pipes);\n  if (ret == -1) {\n    if (errno == EMFILE || errno == ENFILE) {\n      mrb_garbage_collect(mrb);\n      ret = mrb_cloexec_pipe(mrb, pipes);\n    }\n  }\n  return ret;\n}\n\nstatic int\nmrb_proc_exec(const char *pname)\n{\n  const char *s;\n  s = pname;\n\n  while (*s == ' ' || *s == '\\t' || *s == '\\n')\n    s++;\n\n  if (!*s) {\n    errno = ENOENT;\n    return -1;\n  }\n\n  execl(\"/bin/sh\", \"sh\", \"-c\", pname, (char *)NULL);\n  return -1;\n}\n#endif\n\nstatic void\nmrb_io_free(mrb_state *mrb, void *ptr)\n{\n  struct mrb_io *io = (struct mrb_io *)ptr;\n  if (io != NULL) {\n    fptr_finalize(mrb, io, TRUE);\n    mrb_free(mrb, io);\n  }\n}\n\nstatic struct mrb_io *\nmrb_io_alloc(mrb_state *mrb)\n{\n  struct mrb_io *fptr;\n\n  fptr = (struct mrb_io *)mrb_malloc(mrb, sizeof(struct mrb_io));\n  fptr->fd = -1;\n  fptr->fd2 = -1;\n  fptr->pid = 0;\n  fptr->readable = 0;\n  fptr->writable = 0;\n  fptr->sync = 0;\n  fptr->is_socket = 0;\n  return fptr;\n}\n\n#ifndef NOFILE\n#define NOFILE 64\n#endif\n\nstatic int\noption_to_fd(mrb_state *mrb, mrb_value obj, const char *key)\n{\n  mrb_value opt = mrb_funcall(mrb, obj, \"[]\", 1, mrb_symbol_value(mrb_intern_static(mrb, key, strlen(key))));\n  if (mrb_nil_p(opt)) {\n    return -1;\n  }\n\n  switch (mrb_type(opt)) {\n    case MRB_TT_DATA: /* IO */\n      return (int)mrb_fixnum(mrb_io_fileno(mrb, opt));\n    case MRB_TT_FIXNUM:\n      return (int)mrb_fixnum(opt);\n    default:\n      mrb_raise(mrb, E_ARGUMENT_ERROR, \"wrong exec redirect action\");\n      break;\n  }\n  return -1; /* never reached */\n}\n\n#ifndef _WIN32\nmrb_value\nmrb_io_s_popen(mrb_state *mrb, mrb_value klass)\n{\n  mrb_value cmd, io, result;\n  mrb_value mode = mrb_str_new_cstr(mrb, \"r\");\n  mrb_value opt  = mrb_hash_new(mrb);\n\n  struct mrb_io *fptr;\n  const char *pname;\n  int pid, flags, fd, write_fd = -1;\n  int pr[2] = { -1, -1 };\n  int pw[2] = { -1, -1 };\n  int doexec;\n  int saved_errno;\n  int opt_in, opt_out, opt_err;\n\n  mrb_get_args(mrb, \"S|SH\", &cmd, &mode, &opt);\n  io = mrb_obj_value(mrb_data_object_alloc(mrb, mrb_class_ptr(klass), NULL, &mrb_io_type));\n\n  pname = mrb_string_value_cstr(mrb, &cmd);\n  flags = mrb_io_modestr_to_flags(mrb, mrb_string_value_cstr(mrb, &mode));\n\n  doexec = (strcmp(\"-\", pname) != 0);\n  opt_in = option_to_fd(mrb, opt, \"in\");\n  opt_out = option_to_fd(mrb, opt, \"out\");\n  opt_err = option_to_fd(mrb, opt, \"err\");\n\n  if (flags & FMODE_READABLE) {\n    if (pipe(pr) == -1) {\n      mrb_sys_fail(mrb, \"pipe\");\n    }\n    mrb_fd_cloexec(mrb, pr[0]);\n    mrb_fd_cloexec(mrb, pr[1]);\n  }\n\n  if (flags & FMODE_WRITABLE) {\n    if (pipe(pw) == -1) {\n      if (pr[0] != -1) close(pr[0]);\n      if (pr[1] != -1) close(pr[1]);\n      mrb_sys_fail(mrb, \"pipe\");\n    }\n    mrb_fd_cloexec(mrb, pw[0]);\n    mrb_fd_cloexec(mrb, pw[1]);\n  }\n\n  if (!doexec) {\n    // XXX\n    fflush(stdin);\n    fflush(stdout);\n    fflush(stderr);\n  }\n\n  result = mrb_nil_value();\n  switch (pid = fork()) {\n    case 0: /* child */\n      if (opt_in != -1) {\n        dup2(opt_in, 0);\n      }\n      if (opt_out != -1) {\n        dup2(opt_out, 1);\n      }\n      if (opt_err != -1) {\n        dup2(opt_err, 2);\n      }\n      if (flags & FMODE_READABLE) {\n        close(pr[0]);\n        if (pr[1] != 1) {\n          dup2(pr[1], 1);\n          close(pr[1]);\n        }\n      }\n      if (flags & FMODE_WRITABLE) {\n        close(pw[1]);\n        if (pw[0] != 0) {\n          dup2(pw[0], 0);\n          close(pw[0]);\n        }\n      }\n      if (doexec) {\n        for (fd = 3; fd < NOFILE; fd++) {\n          close(fd);\n        }\n        mrb_proc_exec(pname);\n        mrb_raisef(mrb, E_IO_ERROR, \"command not found: %S\", cmd);\n        _exit(127);\n      }\n      result = mrb_nil_value();\n      break;\n\n    default: /* parent */\n      if ((flags & FMODE_READABLE) && (flags & FMODE_WRITABLE)) {\n        close(pr[1]);\n        fd = pr[0];\n        close(pw[0]);\n        write_fd = pw[1];\n      } else if (flags & FMODE_READABLE) {\n        close(pr[1]);\n        fd = pr[0];\n      } else {\n        close(pw[0]);\n        fd = pw[1];\n      }\n\n      mrb_iv_set(mrb, io, mrb_intern_cstr(mrb, \"@buf\"), mrb_str_new_cstr(mrb, \"\"));\n\n      fptr = mrb_io_alloc(mrb);\n      fptr->fd = fd;\n      fptr->fd2 = write_fd;\n      fptr->pid = pid;\n      fptr->readable = ((flags & FMODE_READABLE) != 0);\n      fptr->writable = ((flags & FMODE_WRITABLE) != 0);\n      fptr->sync = 0;\n\n      DATA_TYPE(io) = &mrb_io_type;\n      DATA_PTR(io)  = fptr;\n      result = io;\n      break;\n\n    case -1: /* error */\n      saved_errno = errno;\n      if (flags & FMODE_READABLE) {\n        close(pr[0]);\n        close(pr[1]);\n      }\n      if (flags & FMODE_WRITABLE) {\n        close(pw[0]);\n        close(pw[1]);\n      }\n      errno = saved_errno;\n      mrb_sys_fail(mrb, \"pipe_open failed.\");\n      break;\n  }\n  return result;\n}\n#else\nmrb_value\nmrb_io_s_popen(mrb_state *mrb, mrb_value klass)\n{\n  mrb_value cmd, io;\n  mrb_value mode = mrb_str_new_cstr(mrb, \"r\");\n  mrb_value opt  = mrb_hash_new(mrb);\n\n  struct mrb_io *fptr;\n  const char *pname;\n  int pid = 0, flags;\n  STARTUPINFO si;\n  PROCESS_INFORMATION pi;\n  SECURITY_ATTRIBUTES saAttr;\n\n  HANDLE ifd[2];\n  HANDLE ofd[2];\n\n  int doexec;\n  int opt_in, opt_out, opt_err;\n\n  ifd[0] = INVALID_HANDLE_VALUE;\n  ifd[1] = INVALID_HANDLE_VALUE;\n  ofd[0] = INVALID_HANDLE_VALUE;\n  ofd[1] = INVALID_HANDLE_VALUE;\n\n  mrb_get_args(mrb, \"S|SH\", &cmd, &mode, &opt);\n  io = mrb_obj_value(mrb_data_object_alloc(mrb, mrb_class_ptr(klass), NULL, &mrb_io_type));\n\n  pname = mrb_string_value_cstr(mrb, &cmd);\n  flags = mrb_io_modestr_to_flags(mrb, mrb_string_value_cstr(mrb, &mode));\n\n  doexec = (strcmp(\"-\", pname) != 0);\n  opt_in = option_to_fd(mrb, opt, \"in\");\n  opt_out = option_to_fd(mrb, opt, \"out\");\n  opt_err = option_to_fd(mrb, opt, \"err\");\n\n  saAttr.nLength = sizeof(SECURITY_ATTRIBUTES);\n  saAttr.bInheritHandle = TRUE;\n  saAttr.lpSecurityDescriptor = NULL;\n\n  if (flags & FMODE_READABLE) {\n    if (!CreatePipe(&ofd[0], &ofd[1], &saAttr, 0)\n        || !SetHandleInformation(ofd[0], HANDLE_FLAG_INHERIT, 0)) {\n      mrb_sys_fail(mrb, \"pipe\");\n    }\n  }\n\n  if (flags & FMODE_WRITABLE) {\n    if (!CreatePipe(&ifd[0], &ifd[1], &saAttr, 0)\n        || !SetHandleInformation(ifd[1], HANDLE_FLAG_INHERIT, 0)) {\n      mrb_sys_fail(mrb, \"pipe\");\n    }\n  }\n\n  if (doexec) {\n    ZeroMemory(&pi, sizeof(pi));\n    ZeroMemory(&si, sizeof(si));\n    si.cb = sizeof(si);\n    si.dwFlags |= STARTF_USESHOWWINDOW;\n    si.wShowWindow = SW_HIDE;\n    si.dwFlags |= STARTF_USESTDHANDLES;\n    if (flags & FMODE_READABLE) {\n      si.hStdOutput = ofd[1];\n      si.hStdError = ofd[1];\n    }\n    if (flags & FMODE_WRITABLE) {\n      si.hStdInput = ifd[0];\n    }\n    if (!CreateProcess(\n        NULL, (char*)pname, NULL, NULL,\n        TRUE, CREATE_NEW_PROCESS_GROUP, NULL, NULL, &si, &pi)) {\n      CloseHandle(ifd[0]);\n      CloseHandle(ifd[1]);\n      CloseHandle(ofd[0]);\n      CloseHandle(ofd[1]);\n      mrb_raisef(mrb, E_IO_ERROR, \"command not found: %S\", cmd);\n    }\n    CloseHandle(pi.hThread);\n    CloseHandle(ifd[0]);\n    CloseHandle(ofd[1]);\n    pid = pi.dwProcessId;\n  }\n\n  mrb_iv_set(mrb, io, mrb_intern_cstr(mrb, \"@buf\"), mrb_str_new_cstr(mrb, \"\"));\n\n  fptr = mrb_io_alloc(mrb);\n  fptr->fd = _open_osfhandle((intptr_t)ofd[0], 0);\n  fptr->fd2 = _open_osfhandle((intptr_t)ifd[1], 0);\n  fptr->pid = pid;\n  fptr->readable = ((flags & FMODE_READABLE) != 0);\n  fptr->writable = ((flags & FMODE_WRITABLE) != 0);\n  fptr->sync = 0;\n\n  DATA_TYPE(io) = &mrb_io_type;\n  DATA_PTR(io)  = fptr;\n  return io;\n}\n#endif\n\nstatic int\nmrb_dup(mrb_state *mrb, int fd, mrb_bool *failed)\n{\n  int new_fd;\n\n  *failed = FALSE;\n  if (fd < 0)\n    return fd;\n\n  new_fd = dup(fd);\n  if (new_fd == -1) *failed = TRUE;\n  return new_fd;\n}\n\nmrb_value\nmrb_io_initialize_copy(mrb_state *mrb, mrb_value copy)\n{\n  mrb_value orig;\n  mrb_value buf;\n  struct mrb_io *fptr_copy;\n  struct mrb_io *fptr_orig;\n  mrb_bool failed = TRUE;\n\n  mrb_get_args(mrb, \"o\", &orig);\n  fptr_copy = (struct mrb_io *)DATA_PTR(copy);\n  if (fptr_copy != NULL) {\n    fptr_finalize(mrb, fptr_copy, FALSE);\n    mrb_free(mrb, fptr_copy);\n  }\n  fptr_copy = (struct mrb_io *)mrb_io_alloc(mrb);\n  fptr_orig = io_get_open_fptr(mrb, orig);\n\n  DATA_TYPE(copy) = &mrb_io_type;\n  DATA_PTR(copy) = fptr_copy;\n\n  buf = mrb_iv_get(mrb, orig, mrb_intern_cstr(mrb, \"@buf\"));\n  mrb_iv_set(mrb, copy, mrb_intern_cstr(mrb, \"@buf\"), buf);\n\n  fptr_copy->fd = mrb_dup(mrb, fptr_orig->fd, &failed);\n  if (failed) {\n    mrb_sys_fail(mrb, 0);\n  }\n  mrb_fd_cloexec(mrb, fptr_copy->fd);\n\n  if (fptr_orig->fd2 != -1) {\n    fptr_copy->fd2 = mrb_dup(mrb, fptr_orig->fd2, &failed);\n    if (failed) {\n      close(fptr_copy->fd);\n      mrb_sys_fail(mrb, 0);\n    }\n    mrb_fd_cloexec(mrb, fptr_copy->fd2);\n  }\n\n  fptr_copy->pid = fptr_orig->pid;\n  fptr_copy->readable = fptr_orig->readable;\n  fptr_copy->writable = fptr_orig->writable;\n  fptr_copy->sync = fptr_orig->sync;\n  fptr_copy->is_socket = fptr_orig->is_socket;\n\n  return copy;\n}\n\nmrb_value\nmrb_io_initialize(mrb_state *mrb, mrb_value io)\n{\n  struct mrb_io *fptr;\n  mrb_int fd;\n  mrb_value mode, opt;\n  int flags;\n\n  mode = opt = mrb_nil_value();\n\n  mrb_get_args(mrb, \"i|So\", &fd, &mode, &opt);\n  if (mrb_nil_p(mode)) {\n    mode = mrb_str_new_cstr(mrb, \"r\");\n  }\n  if (mrb_nil_p(opt)) {\n    opt = mrb_hash_new(mrb);\n  }\n\n  flags = mrb_io_modestr_to_flags(mrb, mrb_string_value_cstr(mrb, &mode));\n\n  mrb_iv_set(mrb, io, mrb_intern_cstr(mrb, \"@buf\"), mrb_str_new_cstr(mrb, \"\"));\n\n  fptr = (struct mrb_io *)DATA_PTR(io);\n  if (fptr != NULL) {\n    fptr_finalize(mrb, fptr, TRUE);\n    mrb_free(mrb, fptr);\n  }\n  fptr = mrb_io_alloc(mrb);\n\n  DATA_TYPE(io) = &mrb_io_type;\n  DATA_PTR(io) = fptr;\n\n  fptr->fd = (int)fd;\n  fptr->readable = ((flags & FMODE_READABLE) != 0);\n  fptr->writable = ((flags & FMODE_WRITABLE) != 0);\n  fptr->sync = 0;\n  return io;\n}\n\nstatic void\nfptr_finalize(mrb_state *mrb, struct mrb_io *fptr, int quiet)\n{\n  int saved_errno = 0;\n\n  if (fptr == NULL) {\n    return;\n  }\n\n  if (fptr->fd > 2) {\n#ifdef _WIN32\n    if (fptr->is_socket) {\n      if (closesocket(fptr->fd) != 0) {\n        saved_errno = WSAGetLastError();\n      }\n      fptr->fd = -1;\n    }\n#endif\n    if (fptr->fd != -1) {\n      if (close(fptr->fd) == -1) {\n        saved_errno = errno;\n      }\n    }\n    fptr->fd = -1;\n  }\n\n  if (fptr->fd2 > 2) {\n    if (close(fptr->fd2) == -1) {\n      if (saved_errno == 0) {\n        saved_errno = errno;\n      }\n    }\n    fptr->fd2 = -1;\n  }\n\n  if (fptr->pid != 0) {\n#if !defined(_WIN32) && !defined(_WIN64)\n    pid_t pid;\n    int status;\n    do {\n      pid = waitpid(fptr->pid, &status, 0);\n    } while (pid == -1 && errno == EINTR);\n    if (!quiet && pid == fptr->pid) {\n      io_set_process_status(mrb, pid, status);\n    }\n#else\n    HANDLE h = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, fptr->pid);\n    DWORD status;\n    if (WaitForSingleObject(h, INFINITE) && GetExitCodeProcess(h, &status))\n      if (!quiet)\n        io_set_process_status(mrb, fptr->pid, (int)status);\n    CloseHandle(h);\n#endif\n    fptr->pid = 0;\n    /* Note: we don't raise an exception when waitpid(3) fails */\n  }\n\n  if (!quiet && saved_errno != 0) {\n    errno = saved_errno;\n    mrb_sys_fail(mrb, \"fptr_finalize failed.\");\n  }\n}\n\nmrb_value\nmrb_io_check_readable(mrb_state *mrb, mrb_value self)\n{\n  struct mrb_io *fptr = io_get_open_fptr(mrb, self);\n  if (! fptr->readable) {\n    mrb_raise(mrb, E_IO_ERROR, \"not opened for reading\");\n  }\n  return mrb_nil_value();\n}\n\nmrb_value\nmrb_io_isatty(mrb_state *mrb, mrb_value self)\n{\n  struct mrb_io *fptr;\n\n  fptr = io_get_open_fptr(mrb, self);\n  if (isatty(fptr->fd) == 0)\n    return mrb_false_value();\n  return mrb_true_value();\n}\n\nmrb_value\nmrb_io_s_for_fd(mrb_state *mrb, mrb_value klass)\n{\n  struct RClass *c = mrb_class_ptr(klass);\n  enum mrb_vtype ttype = MRB_INSTANCE_TT(c);\n  mrb_value obj;\n\n  /* copied from mrb_instance_alloc() */\n  if (ttype == 0) ttype = MRB_TT_OBJECT;\n  obj = mrb_obj_value((struct RObject*)mrb_obj_alloc(mrb, ttype, c));\n  return mrb_io_initialize(mrb, obj);\n}\n\nmrb_value\nmrb_io_s_sysclose(mrb_state *mrb, mrb_value klass)\n{\n  mrb_int fd;\n  mrb_get_args(mrb, \"i\", &fd);\n  if (close((int)fd) == -1) {\n    mrb_sys_fail(mrb, \"close\");\n  }\n  return mrb_fixnum_value(0);\n}\n\nint\nmrb_cloexec_open(mrb_state *mrb, const char *pathname, mrb_int flags, mrb_int mode)\n{\n  mrb_value emsg;\n  int fd, retry = FALSE;\n  char* fname = mrb_locale_from_utf8(pathname, -1);\n\n#ifdef O_CLOEXEC\n  /* O_CLOEXEC is available since Linux 2.6.23.  Linux 2.6.18 silently ignore it. */\n  flags |= O_CLOEXEC;\n#elif defined O_NOINHERIT\n  flags |= O_NOINHERIT;\n#endif\nreopen:\n  fd = open(fname, (int)flags, (fmode_t)mode);\n  if (fd == -1) {\n    if (!retry) {\n      switch (errno) {\n        case ENFILE:\n        case EMFILE:\n        mrb_garbage_collect(mrb);\n        retry = TRUE;\n        goto reopen;\n      }\n    }\n\n    emsg = mrb_format(mrb, \"open %S\", mrb_str_new_cstr(mrb, pathname));\n    mrb_str_modify(mrb, mrb_str_ptr(emsg));\n    mrb_sys_fail(mrb, RSTRING_PTR(emsg));\n  }\n  mrb_utf8_free(fname);\n\n  if (fd <= 2) {\n    mrb_fd_cloexec(mrb, fd);\n  }\n  return fd;\n}\n\nmrb_value\nmrb_io_s_sysopen(mrb_state *mrb, mrb_value klass)\n{\n  mrb_value path = mrb_nil_value();\n  mrb_value mode = mrb_nil_value();\n  mrb_int fd, perm = -1;\n  const char *pat;\n  int flags, modenum;\n\n  mrb_get_args(mrb, \"S|Si\", &path, &mode, &perm);\n  if (mrb_nil_p(mode)) {\n    mode = mrb_str_new_cstr(mrb, \"r\");\n  }\n  if (perm < 0) {\n    perm = 0666;\n  }\n\n  pat = mrb_string_value_cstr(mrb, &path);\n  flags = mrb_io_modestr_to_flags(mrb, mrb_string_value_cstr(mrb, &mode));\n  modenum = mrb_io_flags_to_modenum(mrb, flags);\n  fd = mrb_cloexec_open(mrb, pat, modenum, perm);\n  return mrb_fixnum_value(fd);\n}\n\nmrb_value\nmrb_io_sysread(mrb_state *mrb, mrb_value io)\n{\n  struct mrb_io *fptr;\n  mrb_value buf = mrb_nil_value();\n  mrb_int maxlen;\n  int ret;\n\n  mrb_get_args(mrb, \"i|S\", &maxlen, &buf);\n  if (maxlen < 0) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"negative expanding string size\");\n  }\n  else if (maxlen == 0) {\n    return mrb_str_new(mrb, NULL, maxlen);\n  }\n\n  if (mrb_nil_p(buf)) {\n    buf = mrb_str_new(mrb, NULL, maxlen);\n  }\n\n  if (RSTRING_LEN(buf) != maxlen) {\n    buf = mrb_str_resize(mrb, buf, maxlen);\n  } else {\n    mrb_str_modify(mrb, RSTRING(buf));\n  }\n\n  fptr = (struct mrb_io *)io_get_open_fptr(mrb, io);\n  if (!fptr->readable) {\n    mrb_raise(mrb, E_IO_ERROR, \"not opened for reading\");\n  }\n  ret = read(fptr->fd, RSTRING_PTR(buf), (fsize_t)maxlen);\n  switch (ret) {\n    case 0: /* EOF */\n      if (maxlen == 0) {\n        buf = mrb_str_new_cstr(mrb, \"\");\n      } else {\n        mrb_raise(mrb, E_EOF_ERROR, \"sysread failed: End of File\");\n      }\n      break;\n    case -1: /* Error */\n      mrb_sys_fail(mrb, \"sysread failed\");\n      break;\n    default:\n      if (RSTRING_LEN(buf) != ret) {\n        buf = mrb_str_resize(mrb, buf, ret);\n      }\n      break;\n  }\n\n  return buf;\n}\n\nmrb_value\nmrb_io_sysseek(mrb_state *mrb, mrb_value io)\n{\n  struct mrb_io *fptr;\n  off_t pos;\n  mrb_int offset, whence = -1;\n\n  mrb_get_args(mrb, \"i|i\", &offset, &whence);\n  if (whence < 0) {\n    whence = 0;\n  }\n\n  fptr = (struct mrb_io *)mrb_get_datatype(mrb, io, &mrb_io_type);\n  pos = lseek(fptr->fd, (off_t)offset, (int)whence);\n  if (pos == -1) {\n    mrb_sys_fail(mrb, \"sysseek\");\n  }\n  if (pos > MRB_INT_MAX) {\n#ifndef MRB_WITHOUT_FLOAT\n    return mrb_float_value(mrb, (mrb_float)pos);\n#else\n    mrb_raise(mrb, E_IO_ERROR, \"sysseek reached too far for MRB_WITHOUT_FLOAT\");\n#endif\n  } else {\n    return mrb_fixnum_value(pos);\n  }\n}\n\nmrb_value\nmrb_io_syswrite(mrb_state *mrb, mrb_value io)\n{\n  struct mrb_io *fptr;\n  mrb_value str, buf;\n  int fd, length;\n\n  fptr = (struct mrb_io *)mrb_get_datatype(mrb, io, &mrb_io_type);\n  if (! fptr->writable) {\n    mrb_raise(mrb, E_IO_ERROR, \"not opened for writing\");\n  }\n\n  mrb_get_args(mrb, \"S\", &str);\n  if (mrb_type(str) != MRB_TT_STRING) {\n    buf = mrb_funcall(mrb, str, \"to_s\", 0);\n  } else {\n    buf = str;\n  }\n\n  if (fptr->fd2 == -1) {\n    fd = fptr->fd;\n  } else {\n    fd = fptr->fd2;\n  }\n  length = write(fd, RSTRING_PTR(buf), (fsize_t)RSTRING_LEN(buf));\n  if (length == -1) {\n    mrb_sys_fail(mrb, 0);\n  }\n\n  return mrb_fixnum_value(length);\n}\n\nmrb_value\nmrb_io_close(mrb_state *mrb, mrb_value self)\n{\n  struct mrb_io *fptr;\n  fptr = io_get_open_fptr(mrb, self);\n  fptr_finalize(mrb, fptr, FALSE);\n  return mrb_nil_value();\n}\n\nmrb_value\nmrb_io_close_write(mrb_state *mrb, mrb_value self)\n{\n  struct mrb_io *fptr;\n  fptr = io_get_open_fptr(mrb, self);\n  if (close((int)fptr->fd2) == -1) {\n    mrb_sys_fail(mrb, \"close\");\n  }\n  return mrb_nil_value();\n}\n\nmrb_value\nmrb_io_closed(mrb_state *mrb, mrb_value io)\n{\n  struct mrb_io *fptr;\n  fptr = (struct mrb_io *)mrb_get_datatype(mrb, io, &mrb_io_type);\n  if (fptr->fd >= 0) {\n    return mrb_false_value();\n  }\n\n  return mrb_true_value();\n}\n\nmrb_value\nmrb_io_pid(mrb_state *mrb, mrb_value io)\n{\n  struct mrb_io *fptr;\n  fptr = (struct mrb_io *)mrb_get_datatype(mrb, io, &mrb_io_type);\n\n  if (fptr->pid > 0) {\n    return mrb_fixnum_value(fptr->pid);\n  }\n\n  return mrb_nil_value();\n}\n\nstatic struct timeval\ntime2timeval(mrb_state *mrb, mrb_value time)\n{\n  struct timeval t = { 0, 0 };\n\n  switch (mrb_type(time)) {\n    case MRB_TT_FIXNUM:\n      t.tv_sec = (ftime_t)mrb_fixnum(time);\n      t.tv_usec = 0;\n      break;\n\n#ifndef MRB_WITHOUT_FLOAT\n    case MRB_TT_FLOAT:\n      t.tv_sec = (ftime_t)mrb_float(time);\n      t.tv_usec = (fsuseconds_t)((mrb_float(time) - t.tv_sec) * 1000000.0);\n      break;\n#endif\n\n    default:\n      mrb_raise(mrb, E_TYPE_ERROR, \"wrong argument class\");\n  }\n\n  return t;\n}\n\nstatic int\nmrb_io_read_data_pending(mrb_state *mrb, mrb_value io)\n{\n  mrb_value buf = mrb_iv_get(mrb, io, mrb_intern_cstr(mrb, \"@buf\"));\n  if (mrb_type(buf) == MRB_TT_STRING && RSTRING_LEN(buf) > 0) {\n    return 1;\n  }\n  return 0;\n}\n\n#ifndef _WIN32\nstatic mrb_value\nmrb_io_s_pipe(mrb_state *mrb, mrb_value klass)\n{\n  mrb_value r = mrb_nil_value();\n  mrb_value w = mrb_nil_value();\n  struct mrb_io *fptr_r;\n  struct mrb_io *fptr_w;\n  int pipes[2];\n\n  if (mrb_pipe(mrb, pipes) == -1) {\n    mrb_sys_fail(mrb, \"pipe\");\n  }\n\n  r = mrb_obj_value(mrb_data_object_alloc(mrb, mrb_class_ptr(klass), NULL, &mrb_io_type));\n  mrb_iv_set(mrb, r, mrb_intern_cstr(mrb, \"@buf\"), mrb_str_new_cstr(mrb, \"\"));\n  fptr_r = mrb_io_alloc(mrb);\n  fptr_r->fd = pipes[0];\n  fptr_r->readable = 1;\n  fptr_r->writable = 0;\n  fptr_r->sync = 0;\n  DATA_TYPE(r) = &mrb_io_type;\n  DATA_PTR(r)  = fptr_r;\n\n  w = mrb_obj_value(mrb_data_object_alloc(mrb, mrb_class_ptr(klass), NULL, &mrb_io_type));\n  mrb_iv_set(mrb, w, mrb_intern_cstr(mrb, \"@buf\"), mrb_str_new_cstr(mrb, \"\"));\n  fptr_w = mrb_io_alloc(mrb);\n  fptr_w->fd = pipes[1];\n  fptr_w->readable = 0;\n  fptr_w->writable = 1;\n  fptr_w->sync = 1;\n  DATA_TYPE(w) = &mrb_io_type;\n  DATA_PTR(w)  = fptr_w;\n\n  return mrb_assoc_new(mrb, r, w);\n}\n#endif\n\nstatic mrb_value\nmrb_io_s_select(mrb_state *mrb, mrb_value klass)\n{\n  mrb_value *argv;\n  mrb_int argc;\n  mrb_value read, read_io, write, except, timeout, list;\n  struct timeval *tp, timerec;\n  fd_set pset, rset, wset, eset;\n  fd_set *rp, *wp, *ep;\n  struct mrb_io *fptr;\n  int pending = 0;\n  mrb_value result;\n  int max = 0;\n  int interrupt_flag = 0;\n  int i, n;\n\n  mrb_get_args(mrb, \"*\", &argv, &argc);\n\n  if (argc < 1 || argc > 4) {\n    mrb_raisef(mrb, E_ARGUMENT_ERROR, \"wrong number of arguments (%S for 1..4)\", mrb_fixnum_value(argc));\n  }\n\n  timeout = mrb_nil_value();\n  except = mrb_nil_value();\n  write = mrb_nil_value();\n  if (argc > 3)\n    timeout = argv[3];\n  if (argc > 2)\n    except = argv[2];\n  if (argc > 1)\n    write = argv[1];\n  read = argv[0];\n\n  if (mrb_nil_p(timeout)) {\n    tp = NULL;\n  } else {\n    timerec = time2timeval(mrb, timeout);\n    tp = &timerec;\n  }\n\n  FD_ZERO(&pset);\n  if (!mrb_nil_p(read)) {\n    mrb_check_type(mrb, read, MRB_TT_ARRAY);\n    rp = &rset;\n    FD_ZERO(rp);\n    for (i = 0; i < RARRAY_LEN(read); i++) {\n      read_io = RARRAY_PTR(read)[i];\n      fptr = (struct mrb_io *)mrb_get_datatype(mrb, read_io, &mrb_io_type);\n      FD_SET(fptr->fd, rp);\n      if (mrb_io_read_data_pending(mrb, read_io)) {\n        pending++;\n        FD_SET(fptr->fd, &pset);\n      }\n      if (max < fptr->fd)\n        max = fptr->fd;\n    }\n    if (pending) {\n      timerec.tv_sec = timerec.tv_usec = 0;\n      tp = &timerec;\n    }\n  } else {\n    rp = NULL;\n  }\n\n  if (!mrb_nil_p(write)) {\n    mrb_check_type(mrb, write, MRB_TT_ARRAY);\n    wp = &wset;\n    FD_ZERO(wp);\n    for (i = 0; i < RARRAY_LEN(write); i++) {\n      fptr = (struct mrb_io *)mrb_get_datatype(mrb, RARRAY_PTR(write)[i], &mrb_io_type);\n      FD_SET(fptr->fd, wp);\n      if (max < fptr->fd)\n        max = fptr->fd;\n      if (fptr->fd2 >= 0) {\n        FD_SET(fptr->fd2, wp);\n        if (max < fptr->fd2)\n          max = fptr->fd2;\n      }\n    }\n  } else {\n    wp = NULL;\n  }\n\n  if (!mrb_nil_p(except)) {\n    mrb_check_type(mrb, except, MRB_TT_ARRAY);\n    ep = &eset;\n    FD_ZERO(ep);\n    for (i = 0; i < RARRAY_LEN(except); i++) {\n      fptr = (struct mrb_io *)mrb_get_datatype(mrb, RARRAY_PTR(except)[i], &mrb_io_type);\n      FD_SET(fptr->fd, ep);\n      if (max < fptr->fd)\n        max = fptr->fd;\n      if (fptr->fd2 >= 0) {\n        FD_SET(fptr->fd2, ep);\n        if (max < fptr->fd2)\n          max = fptr->fd2;\n      }\n    }\n  } else {\n    ep = NULL;\n  }\n\n  max++;\n\nretry:\n  n = select(max, rp, wp, ep, tp);\n  if (n < 0) {\n    if (errno != EINTR)\n      mrb_sys_fail(mrb, \"select failed\");\n    if (tp == NULL)\n      goto retry;\n    interrupt_flag = 1;\n  }\n\n  if (!pending && n == 0)\n    return mrb_nil_value();\n\n  result = mrb_ary_new_capa(mrb, 3);\n  mrb_ary_push(mrb, result, rp? mrb_ary_new(mrb) : mrb_ary_new_capa(mrb, 0));\n  mrb_ary_push(mrb, result, wp? mrb_ary_new(mrb) : mrb_ary_new_capa(mrb, 0));\n  mrb_ary_push(mrb, result, ep? mrb_ary_new(mrb) : mrb_ary_new_capa(mrb, 0));\n\n  if (interrupt_flag == 0) {\n    if (rp) {\n      list = RARRAY_PTR(result)[0];\n      for (i = 0; i < RARRAY_LEN(read); i++) {\n        fptr = (struct mrb_io *)mrb_get_datatype(mrb, RARRAY_PTR(read)[i], &mrb_io_type);\n        if (FD_ISSET(fptr->fd, rp) ||\n            FD_ISSET(fptr->fd, &pset)) {\n          mrb_ary_push(mrb, list, RARRAY_PTR(read)[i]);\n        }\n      }\n    }\n\n    if (wp) {\n      list = RARRAY_PTR(result)[1];\n      for (i = 0; i < RARRAY_LEN(write); i++) {\n        fptr = (struct mrb_io *)mrb_get_datatype(mrb, RARRAY_PTR(write)[i], &mrb_io_type);\n        if (FD_ISSET(fptr->fd, wp)) {\n          mrb_ary_push(mrb, list, RARRAY_PTR(write)[i]);\n        } else if (fptr->fd2 >= 0 && FD_ISSET(fptr->fd2, wp)) {\n          mrb_ary_push(mrb, list, RARRAY_PTR(write)[i]);\n        }\n      }\n    }\n\n    if (ep) {\n      list = RARRAY_PTR(result)[2];\n      for (i = 0; i < RARRAY_LEN(except); i++) {\n        fptr = (struct mrb_io *)mrb_get_datatype(mrb, RARRAY_PTR(except)[i], &mrb_io_type);\n        if (FD_ISSET(fptr->fd, ep)) {\n          mrb_ary_push(mrb, list, RARRAY_PTR(except)[i]);\n        } else if (fptr->fd2 >= 0 && FD_ISSET(fptr->fd2, ep)) {\n          mrb_ary_push(mrb, list, RARRAY_PTR(except)[i]);\n        }\n      }\n    }\n  }\n\n  return result;\n}\n\nmrb_value\nmrb_io_fileno(mrb_state *mrb, mrb_value io)\n{\n  struct mrb_io *fptr;\n  fptr = (struct mrb_io *)mrb_get_datatype(mrb, io, &mrb_io_type);\n  return mrb_fixnum_value(fptr->fd);\n}\n\nmrb_value\nmrb_io_close_on_exec_p(mrb_state *mrb, mrb_value self)\n{\n#if defined(F_GETFD) && defined(F_SETFD) && defined(FD_CLOEXEC)\n  struct mrb_io *fptr;\n  int ret;\n\n  fptr = io_get_open_fptr(mrb, self);\n\n  if (fptr->fd2 >= 0) {\n    if ((ret = fcntl(fptr->fd2, F_GETFD)) == -1) mrb_sys_fail(mrb, \"F_GETFD failed\");\n    if (!(ret & FD_CLOEXEC)) return mrb_false_value();\n  }\n\n  if ((ret = fcntl(fptr->fd, F_GETFD)) == -1) mrb_sys_fail(mrb, \"F_GETFD failed\");\n  if (!(ret & FD_CLOEXEC)) return mrb_false_value();\n  return mrb_true_value();\n\n#else\n  mrb_raise(mrb, E_NOTIMP_ERROR, \"IO#close_on_exec? is not supported on the platform\");\n  return mrb_false_value();\n#endif\n}\n\nmrb_value\nmrb_io_set_close_on_exec(mrb_state *mrb, mrb_value self)\n{\n#if defined(F_GETFD) && defined(F_SETFD) && defined(FD_CLOEXEC)\n  struct mrb_io *fptr;\n  int flag, ret;\n  mrb_bool b;\n\n  fptr = io_get_open_fptr(mrb, self);\n  mrb_get_args(mrb, \"b\", &b);\n  flag = b ? FD_CLOEXEC : 0;\n\n  if (fptr->fd2 >= 0) {\n    if ((ret = fcntl(fptr->fd2, F_GETFD)) == -1) mrb_sys_fail(mrb, \"F_GETFD failed\");\n    if ((ret & FD_CLOEXEC) != flag) {\n      ret = (ret & ~FD_CLOEXEC) | flag;\n      ret = fcntl(fptr->fd2, F_SETFD, ret);\n\n      if (ret == -1) mrb_sys_fail(mrb, \"F_SETFD failed\");\n    }\n  }\n\n  if ((ret = fcntl(fptr->fd, F_GETFD)) == -1) mrb_sys_fail(mrb, \"F_GETFD failed\");\n  if ((ret & FD_CLOEXEC) != flag) {\n    ret = (ret & ~FD_CLOEXEC) | flag;\n    ret = fcntl(fptr->fd, F_SETFD, ret);\n    if (ret == -1) mrb_sys_fail(mrb, \"F_SETFD failed\");\n  }\n\n  return mrb_bool_value(b);\n#else\n  mrb_raise(mrb, E_NOTIMP_ERROR, \"IO#close_on_exec= is not supported on the platform\");\n  return mrb_nil_value();\n#endif\n}\n\nmrb_value\nmrb_io_set_sync(mrb_state *mrb, mrb_value self)\n{\n  struct mrb_io *fptr;\n  mrb_bool b;\n\n  fptr = io_get_open_fptr(mrb, self);\n  mrb_get_args(mrb, \"b\", &b);\n  fptr->sync = b;\n  return mrb_bool_value(b);\n}\n\nmrb_value\nmrb_io_sync(mrb_state *mrb, mrb_value self)\n{\n  struct mrb_io *fptr;\n  fptr = io_get_open_fptr(mrb, self);\n  return mrb_bool_value(fptr->sync);\n}\n\nvoid\nmrb_init_io(mrb_state *mrb)\n{\n  struct RClass *io;\n\n  io      = mrb_define_class(mrb, \"IO\", mrb->object_class);\n  MRB_SET_INSTANCE_TT(io, MRB_TT_DATA);\n\n  mrb_include_module(mrb, io, mrb_module_get(mrb, \"Enumerable\")); /* 15.2.20.3 */\n  mrb_define_class_method(mrb, io, \"_popen\",  mrb_io_s_popen,   MRB_ARGS_ANY());\n  mrb_define_class_method(mrb, io, \"_sysclose\",  mrb_io_s_sysclose, MRB_ARGS_REQ(1));\n  mrb_define_class_method(mrb, io, \"for_fd\",  mrb_io_s_for_fd,   MRB_ARGS_ANY());\n  mrb_define_class_method(mrb, io, \"select\",  mrb_io_s_select,  MRB_ARGS_ANY());\n  mrb_define_class_method(mrb, io, \"sysopen\", mrb_io_s_sysopen, MRB_ARGS_ANY());\n#ifndef _WIN32\n  mrb_define_class_method(mrb, io, \"_pipe\", mrb_io_s_pipe, MRB_ARGS_NONE());\n#endif\n\n  mrb_define_method(mrb, io, \"initialize\", mrb_io_initialize, MRB_ARGS_ANY());    /* 15.2.20.5.21 (x)*/\n  mrb_define_method(mrb, io, \"initialize_copy\", mrb_io_initialize_copy, MRB_ARGS_REQ(1));\n  mrb_define_method(mrb, io, \"_check_readable\", mrb_io_check_readable, MRB_ARGS_NONE());\n  mrb_define_method(mrb, io, \"isatty\",     mrb_io_isatty,     MRB_ARGS_NONE());\n  mrb_define_method(mrb, io, \"sync\",       mrb_io_sync,       MRB_ARGS_NONE());\n  mrb_define_method(mrb, io, \"sync=\",      mrb_io_set_sync,   MRB_ARGS_REQ(1));\n  mrb_define_method(mrb, io, \"sysread\",    mrb_io_sysread,    MRB_ARGS_ANY());\n  mrb_define_method(mrb, io, \"sysseek\",    mrb_io_sysseek,    MRB_ARGS_REQ(1));\n  mrb_define_method(mrb, io, \"syswrite\",   mrb_io_syswrite,   MRB_ARGS_REQ(1));\n  mrb_define_method(mrb, io, \"close\",      mrb_io_close,      MRB_ARGS_NONE());   /* 15.2.20.5.1 */\n  mrb_define_method(mrb, io, \"close_write\",    mrb_io_close_write,       MRB_ARGS_NONE());\n  mrb_define_method(mrb, io, \"close_on_exec=\", mrb_io_set_close_on_exec, MRB_ARGS_REQ(1));\n  mrb_define_method(mrb, io, \"close_on_exec?\", mrb_io_close_on_exec_p,   MRB_ARGS_NONE());\n  mrb_define_method(mrb, io, \"closed?\",    mrb_io_closed,     MRB_ARGS_NONE());   /* 15.2.20.5.2 */\n  mrb_define_method(mrb, io, \"pid\",        mrb_io_pid,        MRB_ARGS_NONE());   /* 15.2.20.5.2 */\n  mrb_define_method(mrb, io, \"fileno\",     mrb_io_fileno,     MRB_ARGS_NONE());\n\n\n  mrb_gv_set(mrb, mrb_intern_cstr(mrb, \"$/\"), mrb_str_new_cstr(mrb, \"\\n\"));\n}\n"], "fixing_code": ["/*\n** io.c - IO class\n*/\n\n#include \"mruby.h\"\n#include \"mruby/array.h\"\n#include \"mruby/class.h\"\n#include \"mruby/data.h\"\n#include \"mruby/hash.h\"\n#include \"mruby/string.h\"\n#include \"mruby/variable.h\"\n#include \"mruby/ext/io.h\"\n\n#if MRUBY_RELEASE_NO < 10000\n#include \"error.h\"\n#else\n#include \"mruby/error.h\"\n#endif\n\n#include <sys/types.h>\n#include <sys/stat.h>\n\n#if defined(_WIN32) || defined(_WIN64)\n  #include <winsock.h>\n  #include <io.h>\n  #define open  _open\n  #define close _close\n  #define dup _dup\n  #define dup2 _dup2\n  #define read  _read\n  #define write _write\n  #define lseek _lseek\n  #define isatty _isatty\n  #define WEXITSTATUS(x) (x)\n  typedef int fsize_t;\n  typedef long ftime_t;\n  typedef long fsuseconds_t;\n  typedef int fmode_t;\n\n#else\n  #include <sys/wait.h>\n  #include <unistd.h>\n  typedef size_t fsize_t;\n  typedef time_t ftime_t;\n  typedef suseconds_t fsuseconds_t;\n  typedef mode_t fmode_t;\n#endif\n\n#ifdef _MSC_VER\ntypedef mrb_int pid_t;\n#endif\n\n#include <fcntl.h>\n\n#include <errno.h>\n#include <stdio.h>\n#include <string.h>\n\n\nstatic void mrb_io_free(mrb_state *mrb, void *ptr);\nstruct mrb_data_type mrb_io_type = { \"IO\", mrb_io_free };\n\n\nstatic struct mrb_io *io_get_open_fptr(mrb_state *mrb, mrb_value self);\nstatic int mrb_io_modestr_to_flags(mrb_state *mrb, const char *modestr);\nstatic int mrb_io_flags_to_modenum(mrb_state *mrb, int flags);\nstatic void fptr_finalize(mrb_state *mrb, struct mrb_io *fptr, int quiet);\n\n#if MRUBY_RELEASE_NO < 10000\nstatic struct RClass *\nmrb_module_get(mrb_state *mrb, const char *name)\n{\n  return mrb_class_get(mrb, name);\n}\n#endif\n\nstatic struct mrb_io *\nio_get_open_fptr(mrb_state *mrb, mrb_value self)\n{\n  struct mrb_io *fptr;\n\n  fptr = (struct mrb_io *)mrb_get_datatype(mrb, self, &mrb_io_type);\n  if (fptr->fd < 0) {\n    mrb_raise(mrb, E_IO_ERROR, \"closed stream.\");\n  }\n  return fptr;\n}\n\nstatic void\nio_set_process_status(mrb_state *mrb, pid_t pid, int status)\n{\n  struct RClass *c_process, *c_status;\n  mrb_value v;\n\n  c_status = NULL;\n  if (mrb_class_defined(mrb, \"Process\")) {\n    c_process = mrb_module_get(mrb, \"Process\");\n    if (mrb_const_defined(mrb, mrb_obj_value(c_process), mrb_intern_cstr(mrb, \"Status\"))) {\n      c_status = mrb_class_get_under(mrb, c_process, \"Status\");\n    }\n  }\n  if (c_status != NULL) {\n    v = mrb_funcall(mrb, mrb_obj_value(c_status), \"new\", 2, mrb_fixnum_value(pid), mrb_fixnum_value(status));\n  } else {\n    v = mrb_fixnum_value(WEXITSTATUS(status));\n  }\n  mrb_gv_set(mrb, mrb_intern_cstr(mrb, \"$?\"), v);\n}\n\nstatic int\nmrb_io_modestr_to_flags(mrb_state *mrb, const char *mode)\n{\n  int flags = 0;\n  const char *m = mode;\n\n  switch (*m++) {\n    case 'r':\n      flags |= FMODE_READABLE;\n      break;\n    case 'w':\n      flags |= FMODE_WRITABLE | FMODE_CREATE | FMODE_TRUNC;\n      break;\n    case 'a':\n      flags |= FMODE_WRITABLE | FMODE_APPEND | FMODE_CREATE;\n      break;\n    default:\n      mrb_raisef(mrb, E_ARGUMENT_ERROR, \"illegal access mode %S\", mrb_str_new_cstr(mrb, mode));\n  }\n\n  while (*m) {\n    switch (*m++) {\n      case 'b':\n        flags |= FMODE_BINMODE;\n        break;\n      case '+':\n        flags |= FMODE_READWRITE;\n        break;\n      case ':':\n        /* XXX: PASSTHROUGH*/\n      default:\n        mrb_raisef(mrb, E_ARGUMENT_ERROR, \"illegal access mode %S\", mrb_str_new_cstr(mrb, mode));\n    }\n  }\n\n  return flags;\n}\n\nstatic int\nmrb_io_flags_to_modenum(mrb_state *mrb, int flags)\n{\n  int modenum = 0;\n\n  switch(flags & (FMODE_READABLE|FMODE_WRITABLE|FMODE_READWRITE)) {\n    case FMODE_READABLE:\n      modenum = O_RDONLY;\n      break;\n    case FMODE_WRITABLE:\n      modenum = O_WRONLY;\n      break;\n    case FMODE_READWRITE:\n      modenum = O_RDWR;\n      break;\n  }\n\n  if (flags & FMODE_APPEND) {\n    modenum |= O_APPEND;\n  }\n  if (flags & FMODE_TRUNC) {\n    modenum |= O_TRUNC;\n  }\n  if (flags & FMODE_CREATE) {\n    modenum |= O_CREAT;\n  }\n#ifdef O_BINARY\n  if (flags & FMODE_BINMODE) {\n    modenum |= O_BINARY;\n  }\n#endif\n\n  return modenum;\n}\n\nstatic void\nmrb_fd_cloexec(mrb_state *mrb, int fd)\n{\n#if defined(F_GETFD) && defined(F_SETFD) && defined(FD_CLOEXEC)\n  int flags, flags2;\n\n  flags = fcntl(fd, F_GETFD);\n  if (flags == -1) {\n    mrb_bug(mrb, \"mrb_fd_cloexec: fcntl(%S, F_GETFD) failed: %S\",\n      mrb_fixnum_value(fd), mrb_fixnum_value(errno));\n  }\n  if (fd <= 2) {\n    flags2 = flags & ~FD_CLOEXEC; /* Clear CLOEXEC for standard file descriptors: 0, 1, 2. */\n  }\n  else {\n    flags2 = flags | FD_CLOEXEC; /* Set CLOEXEC for non-standard file descriptors: 3, 4, 5, ... */\n  }\n  if (flags != flags2) {\n    if (fcntl(fd, F_SETFD, flags2) == -1) {\n      mrb_bug(mrb, \"mrb_fd_cloexec: fcntl(%S, F_SETFD, %S) failed: %S\",\n        mrb_fixnum_value(fd), mrb_fixnum_value(flags2), mrb_fixnum_value(errno));\n    }\n  }\n#endif\n}\n\n#ifndef _WIN32\nstatic int\nmrb_cloexec_pipe(mrb_state *mrb, int fildes[2])\n{\n  int ret;\n  ret = pipe(fildes);\n  if (ret == -1)\n    return -1;\n  mrb_fd_cloexec(mrb, fildes[0]);\n  mrb_fd_cloexec(mrb, fildes[1]);\n  return ret;\n}\n\nstatic int\nmrb_pipe(mrb_state *mrb, int pipes[2])\n{\n  int ret;\n  ret = mrb_cloexec_pipe(mrb, pipes);\n  if (ret == -1) {\n    if (errno == EMFILE || errno == ENFILE) {\n      mrb_garbage_collect(mrb);\n      ret = mrb_cloexec_pipe(mrb, pipes);\n    }\n  }\n  return ret;\n}\n\nstatic int\nmrb_proc_exec(const char *pname)\n{\n  const char *s;\n  s = pname;\n\n  while (*s == ' ' || *s == '\\t' || *s == '\\n')\n    s++;\n\n  if (!*s) {\n    errno = ENOENT;\n    return -1;\n  }\n\n  execl(\"/bin/sh\", \"sh\", \"-c\", pname, (char *)NULL);\n  return -1;\n}\n#endif\n\nstatic void\nmrb_io_free(mrb_state *mrb, void *ptr)\n{\n  struct mrb_io *io = (struct mrb_io *)ptr;\n  if (io != NULL) {\n    fptr_finalize(mrb, io, TRUE);\n    mrb_free(mrb, io);\n  }\n}\n\nstatic struct mrb_io *\nmrb_io_alloc(mrb_state *mrb)\n{\n  struct mrb_io *fptr;\n\n  fptr = (struct mrb_io *)mrb_malloc(mrb, sizeof(struct mrb_io));\n  fptr->fd = -1;\n  fptr->fd2 = -1;\n  fptr->pid = 0;\n  fptr->readable = 0;\n  fptr->writable = 0;\n  fptr->sync = 0;\n  fptr->is_socket = 0;\n  return fptr;\n}\n\n#ifndef NOFILE\n#define NOFILE 64\n#endif\n\nstatic int\noption_to_fd(mrb_state *mrb, mrb_value obj, const char *key)\n{\n  mrb_value opt = mrb_funcall(mrb, obj, \"[]\", 1, mrb_symbol_value(mrb_intern_static(mrb, key, strlen(key))));\n  if (mrb_nil_p(opt)) {\n    return -1;\n  }\n\n  switch (mrb_type(opt)) {\n    case MRB_TT_DATA: /* IO */\n      return (int)mrb_fixnum(mrb_io_fileno(mrb, opt));\n    case MRB_TT_FIXNUM:\n      return (int)mrb_fixnum(opt);\n    default:\n      mrb_raise(mrb, E_ARGUMENT_ERROR, \"wrong exec redirect action\");\n      break;\n  }\n  return -1; /* never reached */\n}\n\n#ifndef _WIN32\nmrb_value\nmrb_io_s_popen(mrb_state *mrb, mrb_value klass)\n{\n  mrb_value cmd, io, result;\n  mrb_value mode = mrb_str_new_cstr(mrb, \"r\");\n  mrb_value opt  = mrb_hash_new(mrb);\n\n  struct mrb_io *fptr;\n  const char *pname;\n  int pid, flags, fd, write_fd = -1;\n  int pr[2] = { -1, -1 };\n  int pw[2] = { -1, -1 };\n  int doexec;\n  int saved_errno;\n  int opt_in, opt_out, opt_err;\n\n  mrb_get_args(mrb, \"S|SH\", &cmd, &mode, &opt);\n  io = mrb_obj_value(mrb_data_object_alloc(mrb, mrb_class_ptr(klass), NULL, &mrb_io_type));\n\n  pname = mrb_string_value_cstr(mrb, &cmd);\n  flags = mrb_io_modestr_to_flags(mrb, mrb_string_value_cstr(mrb, &mode));\n\n  doexec = (strcmp(\"-\", pname) != 0);\n  opt_in = option_to_fd(mrb, opt, \"in\");\n  opt_out = option_to_fd(mrb, opt, \"out\");\n  opt_err = option_to_fd(mrb, opt, \"err\");\n\n  if (flags & FMODE_READABLE) {\n    if (pipe(pr) == -1) {\n      mrb_sys_fail(mrb, \"pipe\");\n    }\n    mrb_fd_cloexec(mrb, pr[0]);\n    mrb_fd_cloexec(mrb, pr[1]);\n  }\n\n  if (flags & FMODE_WRITABLE) {\n    if (pipe(pw) == -1) {\n      if (pr[0] != -1) close(pr[0]);\n      if (pr[1] != -1) close(pr[1]);\n      mrb_sys_fail(mrb, \"pipe\");\n    }\n    mrb_fd_cloexec(mrb, pw[0]);\n    mrb_fd_cloexec(mrb, pw[1]);\n  }\n\n  if (!doexec) {\n    // XXX\n    fflush(stdin);\n    fflush(stdout);\n    fflush(stderr);\n  }\n\n  result = mrb_nil_value();\n  switch (pid = fork()) {\n    case 0: /* child */\n      if (opt_in != -1) {\n        dup2(opt_in, 0);\n      }\n      if (opt_out != -1) {\n        dup2(opt_out, 1);\n      }\n      if (opt_err != -1) {\n        dup2(opt_err, 2);\n      }\n      if (flags & FMODE_READABLE) {\n        close(pr[0]);\n        if (pr[1] != 1) {\n          dup2(pr[1], 1);\n          close(pr[1]);\n        }\n      }\n      if (flags & FMODE_WRITABLE) {\n        close(pw[1]);\n        if (pw[0] != 0) {\n          dup2(pw[0], 0);\n          close(pw[0]);\n        }\n      }\n      if (doexec) {\n        for (fd = 3; fd < NOFILE; fd++) {\n          close(fd);\n        }\n        mrb_proc_exec(pname);\n        mrb_raisef(mrb, E_IO_ERROR, \"command not found: %S\", cmd);\n        _exit(127);\n      }\n      result = mrb_nil_value();\n      break;\n\n    default: /* parent */\n      if ((flags & FMODE_READABLE) && (flags & FMODE_WRITABLE)) {\n        close(pr[1]);\n        fd = pr[0];\n        close(pw[0]);\n        write_fd = pw[1];\n      } else if (flags & FMODE_READABLE) {\n        close(pr[1]);\n        fd = pr[0];\n      } else {\n        close(pw[0]);\n        fd = pw[1];\n      }\n\n      mrb_iv_set(mrb, io, mrb_intern_cstr(mrb, \"@buf\"), mrb_str_new_cstr(mrb, \"\"));\n\n      fptr = mrb_io_alloc(mrb);\n      fptr->fd = fd;\n      fptr->fd2 = write_fd;\n      fptr->pid = pid;\n      fptr->readable = ((flags & FMODE_READABLE) != 0);\n      fptr->writable = ((flags & FMODE_WRITABLE) != 0);\n      fptr->sync = 0;\n\n      DATA_TYPE(io) = &mrb_io_type;\n      DATA_PTR(io)  = fptr;\n      result = io;\n      break;\n\n    case -1: /* error */\n      saved_errno = errno;\n      if (flags & FMODE_READABLE) {\n        close(pr[0]);\n        close(pr[1]);\n      }\n      if (flags & FMODE_WRITABLE) {\n        close(pw[0]);\n        close(pw[1]);\n      }\n      errno = saved_errno;\n      mrb_sys_fail(mrb, \"pipe_open failed.\");\n      break;\n  }\n  return result;\n}\n#else\nmrb_value\nmrb_io_s_popen(mrb_state *mrb, mrb_value klass)\n{\n  mrb_value cmd, io;\n  mrb_value mode = mrb_str_new_cstr(mrb, \"r\");\n  mrb_value opt  = mrb_hash_new(mrb);\n\n  struct mrb_io *fptr;\n  const char *pname;\n  int pid = 0, flags;\n  STARTUPINFO si;\n  PROCESS_INFORMATION pi;\n  SECURITY_ATTRIBUTES saAttr;\n\n  HANDLE ifd[2];\n  HANDLE ofd[2];\n\n  int doexec;\n  int opt_in, opt_out, opt_err;\n\n  ifd[0] = INVALID_HANDLE_VALUE;\n  ifd[1] = INVALID_HANDLE_VALUE;\n  ofd[0] = INVALID_HANDLE_VALUE;\n  ofd[1] = INVALID_HANDLE_VALUE;\n\n  mrb_get_args(mrb, \"S|SH\", &cmd, &mode, &opt);\n  io = mrb_obj_value(mrb_data_object_alloc(mrb, mrb_class_ptr(klass), NULL, &mrb_io_type));\n\n  pname = mrb_string_value_cstr(mrb, &cmd);\n  flags = mrb_io_modestr_to_flags(mrb, mrb_string_value_cstr(mrb, &mode));\n\n  doexec = (strcmp(\"-\", pname) != 0);\n  opt_in = option_to_fd(mrb, opt, \"in\");\n  opt_out = option_to_fd(mrb, opt, \"out\");\n  opt_err = option_to_fd(mrb, opt, \"err\");\n\n  saAttr.nLength = sizeof(SECURITY_ATTRIBUTES);\n  saAttr.bInheritHandle = TRUE;\n  saAttr.lpSecurityDescriptor = NULL;\n\n  if (flags & FMODE_READABLE) {\n    if (!CreatePipe(&ofd[0], &ofd[1], &saAttr, 0)\n        || !SetHandleInformation(ofd[0], HANDLE_FLAG_INHERIT, 0)) {\n      mrb_sys_fail(mrb, \"pipe\");\n    }\n  }\n\n  if (flags & FMODE_WRITABLE) {\n    if (!CreatePipe(&ifd[0], &ifd[1], &saAttr, 0)\n        || !SetHandleInformation(ifd[1], HANDLE_FLAG_INHERIT, 0)) {\n      mrb_sys_fail(mrb, \"pipe\");\n    }\n  }\n\n  if (doexec) {\n    ZeroMemory(&pi, sizeof(pi));\n    ZeroMemory(&si, sizeof(si));\n    si.cb = sizeof(si);\n    si.dwFlags |= STARTF_USESHOWWINDOW;\n    si.wShowWindow = SW_HIDE;\n    si.dwFlags |= STARTF_USESTDHANDLES;\n    if (flags & FMODE_READABLE) {\n      si.hStdOutput = ofd[1];\n      si.hStdError = ofd[1];\n    }\n    if (flags & FMODE_WRITABLE) {\n      si.hStdInput = ifd[0];\n    }\n    if (!CreateProcess(\n        NULL, (char*)pname, NULL, NULL,\n        TRUE, CREATE_NEW_PROCESS_GROUP, NULL, NULL, &si, &pi)) {\n      CloseHandle(ifd[0]);\n      CloseHandle(ifd[1]);\n      CloseHandle(ofd[0]);\n      CloseHandle(ofd[1]);\n      mrb_raisef(mrb, E_IO_ERROR, \"command not found: %S\", cmd);\n    }\n    CloseHandle(pi.hThread);\n    CloseHandle(ifd[0]);\n    CloseHandle(ofd[1]);\n    pid = pi.dwProcessId;\n  }\n\n  mrb_iv_set(mrb, io, mrb_intern_cstr(mrb, \"@buf\"), mrb_str_new_cstr(mrb, \"\"));\n\n  fptr = mrb_io_alloc(mrb);\n  fptr->fd = _open_osfhandle((intptr_t)ofd[0], 0);\n  fptr->fd2 = _open_osfhandle((intptr_t)ifd[1], 0);\n  fptr->pid = pid;\n  fptr->readable = ((flags & FMODE_READABLE) != 0);\n  fptr->writable = ((flags & FMODE_WRITABLE) != 0);\n  fptr->sync = 0;\n\n  DATA_TYPE(io) = &mrb_io_type;\n  DATA_PTR(io)  = fptr;\n  return io;\n}\n#endif\n\nstatic int\nmrb_dup(mrb_state *mrb, int fd, mrb_bool *failed)\n{\n  int new_fd;\n\n  *failed = FALSE;\n  if (fd < 0)\n    return fd;\n\n  new_fd = dup(fd);\n  if (new_fd == -1) *failed = TRUE;\n  return new_fd;\n}\n\nmrb_value\nmrb_io_initialize_copy(mrb_state *mrb, mrb_value copy)\n{\n  mrb_value orig;\n  mrb_value buf;\n  struct mrb_io *fptr_copy;\n  struct mrb_io *fptr_orig;\n  mrb_bool failed = TRUE;\n\n  mrb_get_args(mrb, \"o\", &orig);\n  fptr_orig = io_get_open_fptr(mrb, orig);\n  fptr_copy = (struct mrb_io *)DATA_PTR(copy);\n  if (fptr_copy != NULL) {\n    fptr_finalize(mrb, fptr_copy, FALSE);\n    mrb_free(mrb, fptr_copy);\n  }\n  fptr_copy = (struct mrb_io *)mrb_io_alloc(mrb);\n\n  DATA_TYPE(copy) = &mrb_io_type;\n  DATA_PTR(copy) = fptr_copy;\n\n  buf = mrb_iv_get(mrb, orig, mrb_intern_cstr(mrb, \"@buf\"));\n  mrb_iv_set(mrb, copy, mrb_intern_cstr(mrb, \"@buf\"), buf);\n\n  fptr_copy->fd = mrb_dup(mrb, fptr_orig->fd, &failed);\n  if (failed) {\n    mrb_sys_fail(mrb, 0);\n  }\n  mrb_fd_cloexec(mrb, fptr_copy->fd);\n\n  if (fptr_orig->fd2 != -1) {\n    fptr_copy->fd2 = mrb_dup(mrb, fptr_orig->fd2, &failed);\n    if (failed) {\n      close(fptr_copy->fd);\n      mrb_sys_fail(mrb, 0);\n    }\n    mrb_fd_cloexec(mrb, fptr_copy->fd2);\n  }\n\n  fptr_copy->pid = fptr_orig->pid;\n  fptr_copy->readable = fptr_orig->readable;\n  fptr_copy->writable = fptr_orig->writable;\n  fptr_copy->sync = fptr_orig->sync;\n  fptr_copy->is_socket = fptr_orig->is_socket;\n\n  return copy;\n}\n\nmrb_value\nmrb_io_initialize(mrb_state *mrb, mrb_value io)\n{\n  struct mrb_io *fptr;\n  mrb_int fd;\n  mrb_value mode, opt;\n  int flags;\n\n  mode = opt = mrb_nil_value();\n\n  mrb_get_args(mrb, \"i|So\", &fd, &mode, &opt);\n  if (mrb_nil_p(mode)) {\n    mode = mrb_str_new_cstr(mrb, \"r\");\n  }\n  if (mrb_nil_p(opt)) {\n    opt = mrb_hash_new(mrb);\n  }\n\n  flags = mrb_io_modestr_to_flags(mrb, mrb_string_value_cstr(mrb, &mode));\n\n  mrb_iv_set(mrb, io, mrb_intern_cstr(mrb, \"@buf\"), mrb_str_new_cstr(mrb, \"\"));\n\n  fptr = (struct mrb_io *)DATA_PTR(io);\n  if (fptr != NULL) {\n    fptr_finalize(mrb, fptr, TRUE);\n    mrb_free(mrb, fptr);\n  }\n  fptr = mrb_io_alloc(mrb);\n\n  DATA_TYPE(io) = &mrb_io_type;\n  DATA_PTR(io) = fptr;\n\n  fptr->fd = (int)fd;\n  fptr->readable = ((flags & FMODE_READABLE) != 0);\n  fptr->writable = ((flags & FMODE_WRITABLE) != 0);\n  fptr->sync = 0;\n  return io;\n}\n\nstatic void\nfptr_finalize(mrb_state *mrb, struct mrb_io *fptr, int quiet)\n{\n  int saved_errno = 0;\n\n  if (fptr == NULL) {\n    return;\n  }\n\n  if (fptr->fd > 2) {\n#ifdef _WIN32\n    if (fptr->is_socket) {\n      if (closesocket(fptr->fd) != 0) {\n        saved_errno = WSAGetLastError();\n      }\n      fptr->fd = -1;\n    }\n#endif\n    if (fptr->fd != -1) {\n      if (close(fptr->fd) == -1) {\n        saved_errno = errno;\n      }\n    }\n    fptr->fd = -1;\n  }\n\n  if (fptr->fd2 > 2) {\n    if (close(fptr->fd2) == -1) {\n      if (saved_errno == 0) {\n        saved_errno = errno;\n      }\n    }\n    fptr->fd2 = -1;\n  }\n\n  if (fptr->pid != 0) {\n#if !defined(_WIN32) && !defined(_WIN64)\n    pid_t pid;\n    int status;\n    do {\n      pid = waitpid(fptr->pid, &status, 0);\n    } while (pid == -1 && errno == EINTR);\n    if (!quiet && pid == fptr->pid) {\n      io_set_process_status(mrb, pid, status);\n    }\n#else\n    HANDLE h = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, fptr->pid);\n    DWORD status;\n    if (WaitForSingleObject(h, INFINITE) && GetExitCodeProcess(h, &status))\n      if (!quiet)\n        io_set_process_status(mrb, fptr->pid, (int)status);\n    CloseHandle(h);\n#endif\n    fptr->pid = 0;\n    /* Note: we don't raise an exception when waitpid(3) fails */\n  }\n\n  if (!quiet && saved_errno != 0) {\n    errno = saved_errno;\n    mrb_sys_fail(mrb, \"fptr_finalize failed.\");\n  }\n}\n\nmrb_value\nmrb_io_check_readable(mrb_state *mrb, mrb_value self)\n{\n  struct mrb_io *fptr = io_get_open_fptr(mrb, self);\n  if (! fptr->readable) {\n    mrb_raise(mrb, E_IO_ERROR, \"not opened for reading\");\n  }\n  return mrb_nil_value();\n}\n\nmrb_value\nmrb_io_isatty(mrb_state *mrb, mrb_value self)\n{\n  struct mrb_io *fptr;\n\n  fptr = io_get_open_fptr(mrb, self);\n  if (isatty(fptr->fd) == 0)\n    return mrb_false_value();\n  return mrb_true_value();\n}\n\nmrb_value\nmrb_io_s_for_fd(mrb_state *mrb, mrb_value klass)\n{\n  struct RClass *c = mrb_class_ptr(klass);\n  enum mrb_vtype ttype = MRB_INSTANCE_TT(c);\n  mrb_value obj;\n\n  /* copied from mrb_instance_alloc() */\n  if (ttype == 0) ttype = MRB_TT_OBJECT;\n  obj = mrb_obj_value((struct RObject*)mrb_obj_alloc(mrb, ttype, c));\n  return mrb_io_initialize(mrb, obj);\n}\n\nmrb_value\nmrb_io_s_sysclose(mrb_state *mrb, mrb_value klass)\n{\n  mrb_int fd;\n  mrb_get_args(mrb, \"i\", &fd);\n  if (close((int)fd) == -1) {\n    mrb_sys_fail(mrb, \"close\");\n  }\n  return mrb_fixnum_value(0);\n}\n\nint\nmrb_cloexec_open(mrb_state *mrb, const char *pathname, mrb_int flags, mrb_int mode)\n{\n  mrb_value emsg;\n  int fd, retry = FALSE;\n  char* fname = mrb_locale_from_utf8(pathname, -1);\n\n#ifdef O_CLOEXEC\n  /* O_CLOEXEC is available since Linux 2.6.23.  Linux 2.6.18 silently ignore it. */\n  flags |= O_CLOEXEC;\n#elif defined O_NOINHERIT\n  flags |= O_NOINHERIT;\n#endif\nreopen:\n  fd = open(fname, (int)flags, (fmode_t)mode);\n  if (fd == -1) {\n    if (!retry) {\n      switch (errno) {\n        case ENFILE:\n        case EMFILE:\n        mrb_garbage_collect(mrb);\n        retry = TRUE;\n        goto reopen;\n      }\n    }\n\n    emsg = mrb_format(mrb, \"open %S\", mrb_str_new_cstr(mrb, pathname));\n    mrb_str_modify(mrb, mrb_str_ptr(emsg));\n    mrb_sys_fail(mrb, RSTRING_PTR(emsg));\n  }\n  mrb_utf8_free(fname);\n\n  if (fd <= 2) {\n    mrb_fd_cloexec(mrb, fd);\n  }\n  return fd;\n}\n\nmrb_value\nmrb_io_s_sysopen(mrb_state *mrb, mrb_value klass)\n{\n  mrb_value path = mrb_nil_value();\n  mrb_value mode = mrb_nil_value();\n  mrb_int fd, perm = -1;\n  const char *pat;\n  int flags, modenum;\n\n  mrb_get_args(mrb, \"S|Si\", &path, &mode, &perm);\n  if (mrb_nil_p(mode)) {\n    mode = mrb_str_new_cstr(mrb, \"r\");\n  }\n  if (perm < 0) {\n    perm = 0666;\n  }\n\n  pat = mrb_string_value_cstr(mrb, &path);\n  flags = mrb_io_modestr_to_flags(mrb, mrb_string_value_cstr(mrb, &mode));\n  modenum = mrb_io_flags_to_modenum(mrb, flags);\n  fd = mrb_cloexec_open(mrb, pat, modenum, perm);\n  return mrb_fixnum_value(fd);\n}\n\nmrb_value\nmrb_io_sysread(mrb_state *mrb, mrb_value io)\n{\n  struct mrb_io *fptr;\n  mrb_value buf = mrb_nil_value();\n  mrb_int maxlen;\n  int ret;\n\n  mrb_get_args(mrb, \"i|S\", &maxlen, &buf);\n  if (maxlen < 0) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"negative expanding string size\");\n  }\n  else if (maxlen == 0) {\n    return mrb_str_new(mrb, NULL, maxlen);\n  }\n\n  if (mrb_nil_p(buf)) {\n    buf = mrb_str_new(mrb, NULL, maxlen);\n  }\n\n  if (RSTRING_LEN(buf) != maxlen) {\n    buf = mrb_str_resize(mrb, buf, maxlen);\n  } else {\n    mrb_str_modify(mrb, RSTRING(buf));\n  }\n\n  fptr = (struct mrb_io *)io_get_open_fptr(mrb, io);\n  if (!fptr->readable) {\n    mrb_raise(mrb, E_IO_ERROR, \"not opened for reading\");\n  }\n  ret = read(fptr->fd, RSTRING_PTR(buf), (fsize_t)maxlen);\n  switch (ret) {\n    case 0: /* EOF */\n      if (maxlen == 0) {\n        buf = mrb_str_new_cstr(mrb, \"\");\n      } else {\n        mrb_raise(mrb, E_EOF_ERROR, \"sysread failed: End of File\");\n      }\n      break;\n    case -1: /* Error */\n      mrb_sys_fail(mrb, \"sysread failed\");\n      break;\n    default:\n      if (RSTRING_LEN(buf) != ret) {\n        buf = mrb_str_resize(mrb, buf, ret);\n      }\n      break;\n  }\n\n  return buf;\n}\n\nmrb_value\nmrb_io_sysseek(mrb_state *mrb, mrb_value io)\n{\n  struct mrb_io *fptr;\n  off_t pos;\n  mrb_int offset, whence = -1;\n\n  mrb_get_args(mrb, \"i|i\", &offset, &whence);\n  if (whence < 0) {\n    whence = 0;\n  }\n\n  fptr = (struct mrb_io *)mrb_get_datatype(mrb, io, &mrb_io_type);\n  pos = lseek(fptr->fd, (off_t)offset, (int)whence);\n  if (pos == -1) {\n    mrb_sys_fail(mrb, \"sysseek\");\n  }\n  if (pos > MRB_INT_MAX) {\n#ifndef MRB_WITHOUT_FLOAT\n    return mrb_float_value(mrb, (mrb_float)pos);\n#else\n    mrb_raise(mrb, E_IO_ERROR, \"sysseek reached too far for MRB_WITHOUT_FLOAT\");\n#endif\n  } else {\n    return mrb_fixnum_value(pos);\n  }\n}\n\nmrb_value\nmrb_io_syswrite(mrb_state *mrb, mrb_value io)\n{\n  struct mrb_io *fptr;\n  mrb_value str, buf;\n  int fd, length;\n\n  fptr = (struct mrb_io *)mrb_get_datatype(mrb, io, &mrb_io_type);\n  if (! fptr->writable) {\n    mrb_raise(mrb, E_IO_ERROR, \"not opened for writing\");\n  }\n\n  mrb_get_args(mrb, \"S\", &str);\n  if (mrb_type(str) != MRB_TT_STRING) {\n    buf = mrb_funcall(mrb, str, \"to_s\", 0);\n  } else {\n    buf = str;\n  }\n\n  if (fptr->fd2 == -1) {\n    fd = fptr->fd;\n  } else {\n    fd = fptr->fd2;\n  }\n  length = write(fd, RSTRING_PTR(buf), (fsize_t)RSTRING_LEN(buf));\n  if (length == -1) {\n    mrb_sys_fail(mrb, 0);\n  }\n\n  return mrb_fixnum_value(length);\n}\n\nmrb_value\nmrb_io_close(mrb_state *mrb, mrb_value self)\n{\n  struct mrb_io *fptr;\n  fptr = io_get_open_fptr(mrb, self);\n  fptr_finalize(mrb, fptr, FALSE);\n  return mrb_nil_value();\n}\n\nmrb_value\nmrb_io_close_write(mrb_state *mrb, mrb_value self)\n{\n  struct mrb_io *fptr;\n  fptr = io_get_open_fptr(mrb, self);\n  if (close((int)fptr->fd2) == -1) {\n    mrb_sys_fail(mrb, \"close\");\n  }\n  return mrb_nil_value();\n}\n\nmrb_value\nmrb_io_closed(mrb_state *mrb, mrb_value io)\n{\n  struct mrb_io *fptr;\n  fptr = (struct mrb_io *)mrb_get_datatype(mrb, io, &mrb_io_type);\n  if (fptr->fd >= 0) {\n    return mrb_false_value();\n  }\n\n  return mrb_true_value();\n}\n\nmrb_value\nmrb_io_pid(mrb_state *mrb, mrb_value io)\n{\n  struct mrb_io *fptr;\n  fptr = (struct mrb_io *)mrb_get_datatype(mrb, io, &mrb_io_type);\n\n  if (fptr->pid > 0) {\n    return mrb_fixnum_value(fptr->pid);\n  }\n\n  return mrb_nil_value();\n}\n\nstatic struct timeval\ntime2timeval(mrb_state *mrb, mrb_value time)\n{\n  struct timeval t = { 0, 0 };\n\n  switch (mrb_type(time)) {\n    case MRB_TT_FIXNUM:\n      t.tv_sec = (ftime_t)mrb_fixnum(time);\n      t.tv_usec = 0;\n      break;\n\n#ifndef MRB_WITHOUT_FLOAT\n    case MRB_TT_FLOAT:\n      t.tv_sec = (ftime_t)mrb_float(time);\n      t.tv_usec = (fsuseconds_t)((mrb_float(time) - t.tv_sec) * 1000000.0);\n      break;\n#endif\n\n    default:\n      mrb_raise(mrb, E_TYPE_ERROR, \"wrong argument class\");\n  }\n\n  return t;\n}\n\nstatic int\nmrb_io_read_data_pending(mrb_state *mrb, mrb_value io)\n{\n  mrb_value buf = mrb_iv_get(mrb, io, mrb_intern_cstr(mrb, \"@buf\"));\n  if (mrb_type(buf) == MRB_TT_STRING && RSTRING_LEN(buf) > 0) {\n    return 1;\n  }\n  return 0;\n}\n\n#ifndef _WIN32\nstatic mrb_value\nmrb_io_s_pipe(mrb_state *mrb, mrb_value klass)\n{\n  mrb_value r = mrb_nil_value();\n  mrb_value w = mrb_nil_value();\n  struct mrb_io *fptr_r;\n  struct mrb_io *fptr_w;\n  int pipes[2];\n\n  if (mrb_pipe(mrb, pipes) == -1) {\n    mrb_sys_fail(mrb, \"pipe\");\n  }\n\n  r = mrb_obj_value(mrb_data_object_alloc(mrb, mrb_class_ptr(klass), NULL, &mrb_io_type));\n  mrb_iv_set(mrb, r, mrb_intern_cstr(mrb, \"@buf\"), mrb_str_new_cstr(mrb, \"\"));\n  fptr_r = mrb_io_alloc(mrb);\n  fptr_r->fd = pipes[0];\n  fptr_r->readable = 1;\n  fptr_r->writable = 0;\n  fptr_r->sync = 0;\n  DATA_TYPE(r) = &mrb_io_type;\n  DATA_PTR(r)  = fptr_r;\n\n  w = mrb_obj_value(mrb_data_object_alloc(mrb, mrb_class_ptr(klass), NULL, &mrb_io_type));\n  mrb_iv_set(mrb, w, mrb_intern_cstr(mrb, \"@buf\"), mrb_str_new_cstr(mrb, \"\"));\n  fptr_w = mrb_io_alloc(mrb);\n  fptr_w->fd = pipes[1];\n  fptr_w->readable = 0;\n  fptr_w->writable = 1;\n  fptr_w->sync = 1;\n  DATA_TYPE(w) = &mrb_io_type;\n  DATA_PTR(w)  = fptr_w;\n\n  return mrb_assoc_new(mrb, r, w);\n}\n#endif\n\nstatic mrb_value\nmrb_io_s_select(mrb_state *mrb, mrb_value klass)\n{\n  mrb_value *argv;\n  mrb_int argc;\n  mrb_value read, read_io, write, except, timeout, list;\n  struct timeval *tp, timerec;\n  fd_set pset, rset, wset, eset;\n  fd_set *rp, *wp, *ep;\n  struct mrb_io *fptr;\n  int pending = 0;\n  mrb_value result;\n  int max = 0;\n  int interrupt_flag = 0;\n  int i, n;\n\n  mrb_get_args(mrb, \"*\", &argv, &argc);\n\n  if (argc < 1 || argc > 4) {\n    mrb_raisef(mrb, E_ARGUMENT_ERROR, \"wrong number of arguments (%S for 1..4)\", mrb_fixnum_value(argc));\n  }\n\n  timeout = mrb_nil_value();\n  except = mrb_nil_value();\n  write = mrb_nil_value();\n  if (argc > 3)\n    timeout = argv[3];\n  if (argc > 2)\n    except = argv[2];\n  if (argc > 1)\n    write = argv[1];\n  read = argv[0];\n\n  if (mrb_nil_p(timeout)) {\n    tp = NULL;\n  } else {\n    timerec = time2timeval(mrb, timeout);\n    tp = &timerec;\n  }\n\n  FD_ZERO(&pset);\n  if (!mrb_nil_p(read)) {\n    mrb_check_type(mrb, read, MRB_TT_ARRAY);\n    rp = &rset;\n    FD_ZERO(rp);\n    for (i = 0; i < RARRAY_LEN(read); i++) {\n      read_io = RARRAY_PTR(read)[i];\n      fptr = (struct mrb_io *)mrb_get_datatype(mrb, read_io, &mrb_io_type);\n      FD_SET(fptr->fd, rp);\n      if (mrb_io_read_data_pending(mrb, read_io)) {\n        pending++;\n        FD_SET(fptr->fd, &pset);\n      }\n      if (max < fptr->fd)\n        max = fptr->fd;\n    }\n    if (pending) {\n      timerec.tv_sec = timerec.tv_usec = 0;\n      tp = &timerec;\n    }\n  } else {\n    rp = NULL;\n  }\n\n  if (!mrb_nil_p(write)) {\n    mrb_check_type(mrb, write, MRB_TT_ARRAY);\n    wp = &wset;\n    FD_ZERO(wp);\n    for (i = 0; i < RARRAY_LEN(write); i++) {\n      fptr = (struct mrb_io *)mrb_get_datatype(mrb, RARRAY_PTR(write)[i], &mrb_io_type);\n      FD_SET(fptr->fd, wp);\n      if (max < fptr->fd)\n        max = fptr->fd;\n      if (fptr->fd2 >= 0) {\n        FD_SET(fptr->fd2, wp);\n        if (max < fptr->fd2)\n          max = fptr->fd2;\n      }\n    }\n  } else {\n    wp = NULL;\n  }\n\n  if (!mrb_nil_p(except)) {\n    mrb_check_type(mrb, except, MRB_TT_ARRAY);\n    ep = &eset;\n    FD_ZERO(ep);\n    for (i = 0; i < RARRAY_LEN(except); i++) {\n      fptr = (struct mrb_io *)mrb_get_datatype(mrb, RARRAY_PTR(except)[i], &mrb_io_type);\n      FD_SET(fptr->fd, ep);\n      if (max < fptr->fd)\n        max = fptr->fd;\n      if (fptr->fd2 >= 0) {\n        FD_SET(fptr->fd2, ep);\n        if (max < fptr->fd2)\n          max = fptr->fd2;\n      }\n    }\n  } else {\n    ep = NULL;\n  }\n\n  max++;\n\nretry:\n  n = select(max, rp, wp, ep, tp);\n  if (n < 0) {\n    if (errno != EINTR)\n      mrb_sys_fail(mrb, \"select failed\");\n    if (tp == NULL)\n      goto retry;\n    interrupt_flag = 1;\n  }\n\n  if (!pending && n == 0)\n    return mrb_nil_value();\n\n  result = mrb_ary_new_capa(mrb, 3);\n  mrb_ary_push(mrb, result, rp? mrb_ary_new(mrb) : mrb_ary_new_capa(mrb, 0));\n  mrb_ary_push(mrb, result, wp? mrb_ary_new(mrb) : mrb_ary_new_capa(mrb, 0));\n  mrb_ary_push(mrb, result, ep? mrb_ary_new(mrb) : mrb_ary_new_capa(mrb, 0));\n\n  if (interrupt_flag == 0) {\n    if (rp) {\n      list = RARRAY_PTR(result)[0];\n      for (i = 0; i < RARRAY_LEN(read); i++) {\n        fptr = (struct mrb_io *)mrb_get_datatype(mrb, RARRAY_PTR(read)[i], &mrb_io_type);\n        if (FD_ISSET(fptr->fd, rp) ||\n            FD_ISSET(fptr->fd, &pset)) {\n          mrb_ary_push(mrb, list, RARRAY_PTR(read)[i]);\n        }\n      }\n    }\n\n    if (wp) {\n      list = RARRAY_PTR(result)[1];\n      for (i = 0; i < RARRAY_LEN(write); i++) {\n        fptr = (struct mrb_io *)mrb_get_datatype(mrb, RARRAY_PTR(write)[i], &mrb_io_type);\n        if (FD_ISSET(fptr->fd, wp)) {\n          mrb_ary_push(mrb, list, RARRAY_PTR(write)[i]);\n        } else if (fptr->fd2 >= 0 && FD_ISSET(fptr->fd2, wp)) {\n          mrb_ary_push(mrb, list, RARRAY_PTR(write)[i]);\n        }\n      }\n    }\n\n    if (ep) {\n      list = RARRAY_PTR(result)[2];\n      for (i = 0; i < RARRAY_LEN(except); i++) {\n        fptr = (struct mrb_io *)mrb_get_datatype(mrb, RARRAY_PTR(except)[i], &mrb_io_type);\n        if (FD_ISSET(fptr->fd, ep)) {\n          mrb_ary_push(mrb, list, RARRAY_PTR(except)[i]);\n        } else if (fptr->fd2 >= 0 && FD_ISSET(fptr->fd2, ep)) {\n          mrb_ary_push(mrb, list, RARRAY_PTR(except)[i]);\n        }\n      }\n    }\n  }\n\n  return result;\n}\n\nmrb_value\nmrb_io_fileno(mrb_state *mrb, mrb_value io)\n{\n  struct mrb_io *fptr;\n  fptr = (struct mrb_io *)mrb_get_datatype(mrb, io, &mrb_io_type);\n  return mrb_fixnum_value(fptr->fd);\n}\n\nmrb_value\nmrb_io_close_on_exec_p(mrb_state *mrb, mrb_value self)\n{\n#if defined(F_GETFD) && defined(F_SETFD) && defined(FD_CLOEXEC)\n  struct mrb_io *fptr;\n  int ret;\n\n  fptr = io_get_open_fptr(mrb, self);\n\n  if (fptr->fd2 >= 0) {\n    if ((ret = fcntl(fptr->fd2, F_GETFD)) == -1) mrb_sys_fail(mrb, \"F_GETFD failed\");\n    if (!(ret & FD_CLOEXEC)) return mrb_false_value();\n  }\n\n  if ((ret = fcntl(fptr->fd, F_GETFD)) == -1) mrb_sys_fail(mrb, \"F_GETFD failed\");\n  if (!(ret & FD_CLOEXEC)) return mrb_false_value();\n  return mrb_true_value();\n\n#else\n  mrb_raise(mrb, E_NOTIMP_ERROR, \"IO#close_on_exec? is not supported on the platform\");\n  return mrb_false_value();\n#endif\n}\n\nmrb_value\nmrb_io_set_close_on_exec(mrb_state *mrb, mrb_value self)\n{\n#if defined(F_GETFD) && defined(F_SETFD) && defined(FD_CLOEXEC)\n  struct mrb_io *fptr;\n  int flag, ret;\n  mrb_bool b;\n\n  fptr = io_get_open_fptr(mrb, self);\n  mrb_get_args(mrb, \"b\", &b);\n  flag = b ? FD_CLOEXEC : 0;\n\n  if (fptr->fd2 >= 0) {\n    if ((ret = fcntl(fptr->fd2, F_GETFD)) == -1) mrb_sys_fail(mrb, \"F_GETFD failed\");\n    if ((ret & FD_CLOEXEC) != flag) {\n      ret = (ret & ~FD_CLOEXEC) | flag;\n      ret = fcntl(fptr->fd2, F_SETFD, ret);\n\n      if (ret == -1) mrb_sys_fail(mrb, \"F_SETFD failed\");\n    }\n  }\n\n  if ((ret = fcntl(fptr->fd, F_GETFD)) == -1) mrb_sys_fail(mrb, \"F_GETFD failed\");\n  if ((ret & FD_CLOEXEC) != flag) {\n    ret = (ret & ~FD_CLOEXEC) | flag;\n    ret = fcntl(fptr->fd, F_SETFD, ret);\n    if (ret == -1) mrb_sys_fail(mrb, \"F_SETFD failed\");\n  }\n\n  return mrb_bool_value(b);\n#else\n  mrb_raise(mrb, E_NOTIMP_ERROR, \"IO#close_on_exec= is not supported on the platform\");\n  return mrb_nil_value();\n#endif\n}\n\nmrb_value\nmrb_io_set_sync(mrb_state *mrb, mrb_value self)\n{\n  struct mrb_io *fptr;\n  mrb_bool b;\n\n  fptr = io_get_open_fptr(mrb, self);\n  mrb_get_args(mrb, \"b\", &b);\n  fptr->sync = b;\n  return mrb_bool_value(b);\n}\n\nmrb_value\nmrb_io_sync(mrb_state *mrb, mrb_value self)\n{\n  struct mrb_io *fptr;\n  fptr = io_get_open_fptr(mrb, self);\n  return mrb_bool_value(fptr->sync);\n}\n\nvoid\nmrb_init_io(mrb_state *mrb)\n{\n  struct RClass *io;\n\n  io      = mrb_define_class(mrb, \"IO\", mrb->object_class);\n  MRB_SET_INSTANCE_TT(io, MRB_TT_DATA);\n\n  mrb_include_module(mrb, io, mrb_module_get(mrb, \"Enumerable\")); /* 15.2.20.3 */\n  mrb_define_class_method(mrb, io, \"_popen\",  mrb_io_s_popen,   MRB_ARGS_ANY());\n  mrb_define_class_method(mrb, io, \"_sysclose\",  mrb_io_s_sysclose, MRB_ARGS_REQ(1));\n  mrb_define_class_method(mrb, io, \"for_fd\",  mrb_io_s_for_fd,   MRB_ARGS_ANY());\n  mrb_define_class_method(mrb, io, \"select\",  mrb_io_s_select,  MRB_ARGS_ANY());\n  mrb_define_class_method(mrb, io, \"sysopen\", mrb_io_s_sysopen, MRB_ARGS_ANY());\n#ifndef _WIN32\n  mrb_define_class_method(mrb, io, \"_pipe\", mrb_io_s_pipe, MRB_ARGS_NONE());\n#endif\n\n  mrb_define_method(mrb, io, \"initialize\", mrb_io_initialize, MRB_ARGS_ANY());    /* 15.2.20.5.21 (x)*/\n  mrb_define_method(mrb, io, \"initialize_copy\", mrb_io_initialize_copy, MRB_ARGS_REQ(1));\n  mrb_define_method(mrb, io, \"_check_readable\", mrb_io_check_readable, MRB_ARGS_NONE());\n  mrb_define_method(mrb, io, \"isatty\",     mrb_io_isatty,     MRB_ARGS_NONE());\n  mrb_define_method(mrb, io, \"sync\",       mrb_io_sync,       MRB_ARGS_NONE());\n  mrb_define_method(mrb, io, \"sync=\",      mrb_io_set_sync,   MRB_ARGS_REQ(1));\n  mrb_define_method(mrb, io, \"sysread\",    mrb_io_sysread,    MRB_ARGS_ANY());\n  mrb_define_method(mrb, io, \"sysseek\",    mrb_io_sysseek,    MRB_ARGS_REQ(1));\n  mrb_define_method(mrb, io, \"syswrite\",   mrb_io_syswrite,   MRB_ARGS_REQ(1));\n  mrb_define_method(mrb, io, \"close\",      mrb_io_close,      MRB_ARGS_NONE());   /* 15.2.20.5.1 */\n  mrb_define_method(mrb, io, \"close_write\",    mrb_io_close_write,       MRB_ARGS_NONE());\n  mrb_define_method(mrb, io, \"close_on_exec=\", mrb_io_set_close_on_exec, MRB_ARGS_REQ(1));\n  mrb_define_method(mrb, io, \"close_on_exec?\", mrb_io_close_on_exec_p,   MRB_ARGS_NONE());\n  mrb_define_method(mrb, io, \"closed?\",    mrb_io_closed,     MRB_ARGS_NONE());   /* 15.2.20.5.2 */\n  mrb_define_method(mrb, io, \"pid\",        mrb_io_pid,        MRB_ARGS_NONE());   /* 15.2.20.5.2 */\n  mrb_define_method(mrb, io, \"fileno\",     mrb_io_fileno,     MRB_ARGS_NONE());\n\n\n  mrb_gv_set(mrb, mrb_intern_cstr(mrb, \"$/\"), mrb_str_new_cstr(mrb, \"\\n\"));\n}\n"], "filenames": ["mrbgems/mruby-io/src/io.c"], "buggy_code_start_loc": [563], "buggy_code_end_loc": [571], "fixing_code_start_loc": [564], "fixing_code_end_loc": [570], "type": "CWE-416", "message": "In versions of mruby up to and including 1.4.0, a use-after-free vulnerability exists in src/io.c::File#initilialize_copy(). An attacker that can cause Ruby code to be run can possibly use this to execute arbitrary code.", "other": {"cve": {"id": "CVE-2018-10199", "sourceIdentifier": "cve@mitre.org", "published": "2018-04-18T15:29:00.207", "lastModified": "2018-05-22T16:53:53.273", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In versions of mruby up to and including 1.4.0, a use-after-free vulnerability exists in src/io.c::File#initilialize_copy(). An attacker that can cause Ruby code to be run can possibly use this to execute arbitrary code."}, {"lang": "es", "value": "mruby, en versiones hasta, e incluyendo, la 1.4.0, existe una vulnerabilidad de uso de memoria previamente liberada en src/io.c::File#initilialize_copy(). Un atacante que pueda hacer que se ejecute c\u00f3digo Ruby puede aprovecharse de esto para ejecutar c\u00f3digo arbitrario."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mruby:mruby:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.4.0", "matchCriteriaId": "AAFA9D48-DDE1-4F5A-89B9-856124EA1DFC"}]}]}], "references": [{"url": "https://github.com/mruby/mruby/commit/b51b21fc63c9805862322551387d9036f2b63433", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/mruby/mruby/issues/4001", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/mruby/mruby/commit/b51b21fc63c9805862322551387d9036f2b63433"}}