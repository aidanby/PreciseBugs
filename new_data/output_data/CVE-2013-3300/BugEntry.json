{"buggy_code": ["/*\n * Copyright 2009-2010 WorldWide Conferencing, LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage net.liftweb\npackage json\n\n/** JSON parser.\n */\nobject JsonParser {\n  import java.io._\n\n  class ParseException(message: String, cause: Exception) extends Exception(message, cause)\n\n  /** Parsed tokens from low level pull parser.\n   */\n  sealed abstract class Token\n  case object OpenObj extends Token\n  case object CloseObj extends Token\n  case class FieldStart(name: String) extends Token\n  case object End extends Token\n  case class StringVal(value: String) extends Token\n  case class IntVal(value: BigInt) extends Token\n  case class DoubleVal(value: Double) extends Token\n  case class BoolVal(value: Boolean) extends Token\n  case object NullVal extends Token\n  case object OpenArr extends Token\n  case object CloseArr extends Token\n\n  /** Return parsed JSON.\n   * @throws ParseException is thrown if parsing fails\n   */\n  def parse(s: String): JValue = parse(new Buffer(new StringReader(s), false))\n\n  /** Return parsed JSON.\n   * @param closeAutomatically true (default) if the Reader is automatically closed on EOF\n   * @throws ParseException is thrown if parsing fails\n   */\n  def parse(s: Reader, closeAutomatically: Boolean = true): JValue = \n    parse(new Buffer(s, closeAutomatically))\n\n  /** Return parsed JSON.\n   */\n  def parseOpt(s: String): Option[JValue] = \n    try { parse(s).toOpt } catch { case e: Exception => None }\n\n  /** Return parsed JSON.\n   * @param closeAutomatically true (default) if the Reader is automatically closed on EOF\n   */\n  def parseOpt(s: Reader, closeAutomatically: Boolean = true): Option[JValue] = \n    try { parse(s, closeAutomatically).toOpt } catch { case e: Exception => None }\n\n  /** Parse in pull parsing style.\n   * Use <code>p.nextToken</code> to parse tokens one by one from a string.\n   * @see net.liftweb.json.JsonParser.Token\n   */\n  def parse[A](s: String, p: Parser => A): A = parse(new StringReader(s), p)\n\n  /** Parse in pull parsing style.\n   * Use <code>p.nextToken</code> to parse tokens one by one from a stream.\n   * The Reader must be closed when parsing is stopped.\n   * @see net.liftweb.json.JsonParser.Token\n   */\n  def parse[A](s: Reader, p: Parser => A): A = p(new Parser(new Buffer(s, false)))\n\n  private def parse(buf: Buffer): JValue = {\n    try {\n      astParser(new Parser(buf))\n    } catch {\n      case e: ParseException => throw e\n      case e: Exception => throw new ParseException(\"parsing failed\", e)\n    } finally { buf.release }\n  }\n  \n  private[json] def unquote(string: String): String = \n    unquote(new JsonParser.Buffer(new java.io.StringReader(string), false))\n  \n  private[json] def unquote(buf: JsonParser.Buffer): String = {\n    def unquote0(buf: JsonParser.Buffer, base: String): String = {\n      val s = new java.lang.StringBuilder(base)\n      var c = '\\\\'\n      while (c != '\"') {\n        if (c == '\\\\') {\n          buf.next match {\n            case '\"'  => s.append('\"')\n            case '\\\\' => s.append('\\\\')\n            case '/'  => s.append('/')\n            case 'b'  => s.append('\\b')\n            case 'f'  => s.append('\\f')\n            case 'n'  => s.append('\\n')\n            case 'r'  => s.append('\\r')\n            case 't'  => s.append('\\t')\n            case 'u' =>\n              val chars = Array(buf.next, buf.next, buf.next, buf.next)\n              val codePoint = Integer.parseInt(new String(chars), 16)\n              s.appendCodePoint(codePoint)\n            case _ => s.append('\\\\')\n          }\n        } else s.append(c)\n        c = buf.next\n      }\n      s.toString\n    }\n\n    buf.eofIsFailure = true\n    buf.mark\n    var c = buf.next\n    while (c != '\"') {\n      if (c == '\\\\') {\n        val s = unquote0(buf, buf.substring)\n        buf.eofIsFailure = false\n        return s\n      }\n      c = buf.next\n    }\n    buf.eofIsFailure = false\n    buf.substring\n  }\n\n  // FIXME fail fast to prevent infinite loop, see \n  // http://www.exploringbinary.com/java-hangs-when-converting-2-2250738585072012e-308/\n  private val BrokenDouble = BigDecimal(\"2.2250738585072012e-308\")\n  private[json] def parseDouble(s: String) = {\n    val d = BigDecimal(s)\n    if (d == BrokenDouble) sys.error(\"Error parsing 2.2250738585072012e-308\")\n    else d.doubleValue\n  }\n\n  private val astParser = (p: Parser) => {\n    val vals = new ValStack(p)\n    var token: Token = null\n    var root: Option[JValue] = None\n\n    // This is a slightly faster way to correct order of fields and arrays than using 'map'.\n    def reverse(v: JValue): JValue = v match {\n      case JObject(l) => JObject(l.map(reverse).asInstanceOf[List[JField]].reverse)\n      case JArray(l) => JArray(l.map(reverse).reverse)\n      case JField(name, value) => JField(name, reverse(value))\n      case x => x\n    }\n\n    def closeBlock(v: JValue) {\n      vals.peekOption match {\n        case Some(f: JField) =>\n          val field = vals.pop(classOf[JField])\n          val newField = JField(field.name, v)\n          val obj = vals.peek(classOf[JObject])\n          vals.replace(JObject(newField :: obj.obj))\n        case Some(o: JObject) => v match {\n          case x: JField => vals.replace(JObject(x :: o.obj))\n          case _ => p.fail(\"expected field but got \" + v)\n        }\n        case Some(a: JArray) => vals.replace(JArray(v :: a.arr))\n        case Some(x) => p.fail(\"expected field, array or object but got \" + x)\n        case None => root = Some(reverse(v))\n      }\n    }\n\n    def newValue(v: JValue) {\n      if (!vals.isEmpty)\n        vals.peek(classOf[JValue]) match {\n          case f: JField =>\n            vals.pop(classOf[JField])\n            val newField = JField(f.name, v)\n            val obj = vals.peek(classOf[JObject])\n            vals.replace(JObject(newField :: obj.obj))\n          case a: JArray => vals.replace(JArray(v :: a.arr))\n          case _ => p.fail(\"expected field or array\")\n        }\n      else {\n        vals.push(v)\n        root = Some(v)\n      }\n    }\n\n    do {\n      token = p.nextToken\n      token match {\n        case OpenObj          => vals.push(JObject(Nil))\n        case FieldStart(name) => vals.push(JField(name, null))\n        case StringVal(x)     => newValue(JString(x))\n        case IntVal(x)        => newValue(JInt(x))\n        case DoubleVal(x)     => newValue(JDouble(x))\n        case BoolVal(x)       => newValue(JBool(x))\n        case NullVal          => newValue(JNull)\n        case CloseObj         => closeBlock(vals.pop(classOf[JValue]))\n        case OpenArr          => vals.push(JArray(Nil))\n        case CloseArr         => closeBlock(vals.pop(classOf[JArray]))\n        case End              =>\n      }\n    } while (token != End)\n\n    root getOrElse JNothing\n  }\n\n  private val EOF = (-1).asInstanceOf[Char]\n\n  private class ValStack(parser: Parser) {\n    import java.util.LinkedList\n    private[this] val stack = new LinkedList[JValue]()\n\n    def pop[A <: JValue](expectedType: Class[A]) = convert(stack.poll, expectedType)\n    def push(v: JValue) = stack.addFirst(v)\n    def peek[A <: JValue](expectedType: Class[A]) = convert(stack.peek, expectedType)\n    def replace[A <: JValue](newTop: JValue) = stack.set(0, newTop)\n\n    private def convert[A <: JValue](x: JValue, expectedType: Class[A]): A = {\n      if (x == null) parser.fail(\"expected object or array\")\n      try { x.asInstanceOf[A] } catch { case _: ClassCastException => parser.fail(\"unexpected \" + x) }\n    }\n\n    def peekOption = if (stack isEmpty) None else Some(stack.peek)\n    def isEmpty = stack.isEmpty\n  }\n\n  class Parser(buf: Buffer) {\n    import java.util.LinkedList\n\n    private[this] val blocks = new LinkedList[BlockMode]()\n    private[this] var fieldNameMode = true\n\n    def fail(msg: String) = throw new ParseException(msg + \"\\nNear: \" + buf.near, null)\n\n    /** Parse next Token from stream.\n     */\n    def nextToken: Token = {\n      def isDelimiter(c: Char) = c == ' ' || c == '\\n' || c == ',' || c == '\\r' || c == '\\t' || c == '}' || c == ']'\n\n      def parseString: String = \n        try {\n          unquote(buf)\n        } catch {\n          case p: ParseException => throw p\n          case _: Exception => fail(\"unexpected string end\")\n        }\n\n      def parseValue(first: Char) = {\n        var wasInt = true\n        var doubleVal = false\n        val s = new StringBuilder\n        s.append(first)\n        while (wasInt) {\n          val c = buf.next\n          if (c == EOF) {\n            wasInt = false\n          } else if (c == '.' || c == 'e' || c == 'E') {\n            doubleVal = true\n            s.append(c)\n          } else if (!(Character.isDigit(c) || c == '.' || c == 'e' || c == 'E' || c == '-')) {\n            wasInt = false\n            buf.back\n          } else s.append(c)\n        }\n        val value = s.toString\n        if (doubleVal) DoubleVal(parseDouble(value)) \n        else IntVal(BigInt(value))\n      }\n\n      while (true) {\n        buf.next match {\n          case c if EOF == c => \n            buf.automaticClose\n            return End\n          case '{' =>\n            blocks.addFirst(OBJECT)\n            fieldNameMode = true\n            return OpenObj\n          case '}' =>\n            blocks.poll\n            return CloseObj\n          case '\"' =>\n            if (fieldNameMode && blocks.peek == OBJECT) return FieldStart(parseString)\n            else {\n              fieldNameMode = true\n              return StringVal(parseString)\n            }\n          case 't' =>\n            fieldNameMode = true\n            if (buf.next == 'r' && buf.next == 'u' && buf.next == 'e') {\n              return BoolVal(true)\n            }\n            fail(\"expected boolean\")\n          case 'f' =>\n            fieldNameMode = true\n            if (buf.next == 'a' && buf.next == 'l' && buf.next == 's' && buf.next == 'e') {\n              return BoolVal(false)\n            }\n            fail(\"expected boolean\")\n          case 'n' =>\n            fieldNameMode = true\n            if (buf.next == 'u' && buf.next == 'l' && buf.next == 'l') {\n              return NullVal\n            }\n            fail(\"expected null\")\n          case ':' =>\n            if (blocks.peek == ARRAY) fail(\"Colon in an invalid position\")\n            fieldNameMode = false\n          case '[' =>\n            blocks.addFirst(ARRAY)\n            return OpenArr\n          case ']' =>\n            fieldNameMode = true\n            blocks.poll\n            return CloseArr\n          case c if Character.isDigit(c) || c == '-' =>\n            fieldNameMode = true\n            return parseValue(c)\n          case c if isDelimiter(c) =>\n          case c => fail(\"unknown token \" + c)\n        }\n      }\n      buf.automaticClose\n      End\n    }\n\n    sealed abstract class BlockMode\n    case object ARRAY extends BlockMode\n    case object OBJECT extends BlockMode\n  }\n\n  /* Buffer used to parse JSON.\n   * Buffer is divided to one or more segments (preallocated in Segments pool).\n   */\n  private[json] class Buffer(in: Reader, closeAutomatically: Boolean) {\n    var offset = 0\n    var curMark = -1\n    var curMarkSegment = -1\n    var eofIsFailure = false\n    private[this] var segments: List[Segment] = List(Segments.apply())\n    private[this] var segment: Array[Char] = segments.head.seg\n    private[this] var cur = 0 // Pointer which points current parsing location\n    private[this] var curSegmentIdx = 0 // Pointer which points current segment\n\n    def mark = { curMark = cur; curMarkSegment = curSegmentIdx }\n    def back = cur = cur-1\n\n    def next: Char = {\n      if (cur >= offset && read < 0) {\n        if (eofIsFailure) throw new ParseException(\"unexpected eof\", null) else EOF\n      } else {\n        val c = segment(cur)\n        cur += 1\n        c\n      }\n    }\n\n    def substring = {\n      if (curSegmentIdx == curMarkSegment) new String(segment, curMark, cur-curMark-1)\n      else { // slower path for case when string is in two or more segments\n        var parts: List[(Int, Int, Array[Char])] = Nil\n        var i = curSegmentIdx\n        while (i >= curMarkSegment) {\n          val s = segments(i).seg\n          val start = if (i == curMarkSegment) curMark else 0\n          val end = if (i == curSegmentIdx) cur else s.length+1\n          parts = (start, end, s) :: parts\n          i = i-1\n        }\n        val len = parts.map(p => p._2 - p._1 - 1).foldLeft(0)(_ + _)\n        val chars = new Array[Char](len)\n        i = 0\n        var pos = 0\n\n        while (i < parts.size) {\n          val (start, end, b) = parts(i)\n          val partLen = end-start-1\n          System.arraycopy(b, start, chars, pos, partLen)\n          pos = pos + partLen\n          i = i+1\n        }\n        new String(chars)\n      }\n    }\n\n    def near = new String(segment, (cur-20) max 0, (cur + 1) min Segments.segmentSize)\n\n    def release = segments.foreach(Segments.release)\n\n    private[JsonParser] def automaticClose = if (closeAutomatically) in.close\n\n    private[this] def read = {\n      if (offset >= segment.length) {\n        val newSegment = Segments.apply()\n        offset = 0\n        segment = newSegment.seg\n        segments = segments ::: List(newSegment)\n        curSegmentIdx = segments.length - 1\n      }\n\n      val length = in.read(segment, offset, segment.length-offset)\n      if (length != -1) {\n        cur = offset\n        offset += length\n        length\n      } else -1\n    }\n  }\n\n  /* A pool of preallocated char arrays.\n   */\n  private[json] object Segments {\n    import java.util.concurrent.ArrayBlockingQueue\n    import java.util.concurrent.atomic.AtomicInteger\n\n    private[json] var segmentSize = 1000\n    private[this] val maxNumOfSegments = 10000\n    private[this] var segmentCount = new AtomicInteger(0)\n    private[this] val segments = new ArrayBlockingQueue[Segment](maxNumOfSegments)\n    private[json] def clear = segments.clear\n\n    def apply(): Segment = {\n      val s = acquire\n      // Give back a disposable segment if pool is exhausted.\n      if (s != null) s else DisposableSegment(new Array(segmentSize))\n    }\n\n    private[this] def acquire: Segment = {\n      val curCount = segmentCount.get\n      val createNew = \n        if (segments.size == 0 && curCount < maxNumOfSegments)\n          segmentCount.compareAndSet(curCount, curCount + 1)\n        else false\n\n      if (createNew) RecycledSegment(new Array(segmentSize)) else segments.poll\n    }\n\n    def release(s: Segment) = s match {\n      case _: RecycledSegment => segments.offer(s)\n      case _ =>\n    }\n  }\n\n  sealed trait Segment {\n    val seg: Array[Char]\n  }\n  case class RecycledSegment(seg: Array[Char]) extends Segment\n  case class DisposableSegment(seg: Array[Char]) extends Segment\n}\n", "/*\n * Copyright 2009-2011 WorldWide Conferencing, LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage net.liftweb\npackage json\n\nimport org.specs2.mutable.Specification\nimport org.specs2.ScalaCheck\nimport org.scalacheck.{Arbitrary, Gen}\nimport org.scalacheck.Prop._\n\n\n/**\n * System under specification for JSON Parser.\n */\nobject JsonParserSpec extends Specification with JValueGen with ScalaCheck {\n  \"JSON Parser Specification\".title\n\n  \"Any valid json can be parsed\" in {\n    val parsing = (json: JValue) => { parse(Printer.pretty(render(json))); true }\n    check(forAll(genJValue)(parsing))\n  }\n\n  \"Buffer size does not change parsing result\" in {\n    val bufSize = Gen.choose(2, 64)\n    val parsing = (x: JValue, s1: Int, s2: Int) => { parseVal(x, s1) == parseVal(x, s2) }\n    check(forAll(genObject, bufSize, bufSize)(parsing))\n  }\n\n  \"Parsing is thread safe\" in {\n    import java.util.concurrent._\n\n    val json = Examples.person\n    val executor = Executors.newFixedThreadPool(100)\n    val results = (0 to 100).map(_ =>\n      executor.submit(new Callable[JValue] { def call = parse(json) })).toList.map(_.get)\n    results.zip(results.tail).forall(pair => pair._1 == pair._2) mustEqual true\n  }\n\n  \"All valid string escape characters can be parsed\" in {\n    parse(\"[\\\"abc\\\\\\\"\\\\\\\\\\\\/\\\\b\\\\f\\\\n\\\\r\\\\t\\\\u00a0\\\"]\") must_== JArray(JString(\"abc\\\"\\\\/\\b\\f\\n\\r\\t\\u00a0\")::Nil)\n  }\n\n  \"Unclosed string literal fails parsing\" in {\n    parseOpt(\"{\\\"foo\\\":\\\"sd\") mustEqual None\n    parseOpt(\"{\\\"foo\\\":\\\"sd}\") mustEqual None\n  }\n\n  \"The EOF has reached when the Reader returns EOF\" in {\n    class StingyReader(s: String) extends java.io.StringReader(s) {\n      override def read(cbuf: Array[Char], off: Int, len: Int): Int = {\n        val c = read()\n        if (c == -1) -1\n        else {\n          cbuf(off) = c.toChar\n          1\n        }\n      }\n    }\n\n    val json = JsonParser.parse(new StingyReader(\"\"\" [\"hello\"] \"\"\"))\n    json mustEqual JArray(JString(\"hello\") :: Nil)\n  }\n\n  implicit def arbJValue: Arbitrary[JValue] = Arbitrary(genObject)\n\n  private def parseVal(json: JValue, bufSize: Int) = {\n    val existingSize = JsonParser.Segments.segmentSize\n    try {\n      JsonParser.Segments.segmentSize = bufSize\n      JsonParser.Segments.clear\n      JsonParser.parse(compact(render(json)))\n    } finally {\n      JsonParser.Segments.segmentSize = existingSize\n    }\n  }\n}\n"], "fixing_code": ["/*\n * Copyright 2009-2010 WorldWide Conferencing, LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage net.liftweb\npackage json\n\n/** JSON parser.\n */\nobject JsonParser {\n  import java.io._\n\n  class ParseException(message: String, cause: Exception) extends Exception(message, cause)\n\n  /** Parsed tokens from low level pull parser.\n   */\n  sealed abstract class Token\n  case object OpenObj extends Token\n  case object CloseObj extends Token\n  case class FieldStart(name: String) extends Token\n  case object End extends Token\n  case class StringVal(value: String) extends Token\n  case class IntVal(value: BigInt) extends Token\n  case class DoubleVal(value: Double) extends Token\n  case class BoolVal(value: Boolean) extends Token\n  case object NullVal extends Token\n  case object OpenArr extends Token\n  case object CloseArr extends Token\n\n  /** Return parsed JSON.\n   * @throws ParseException is thrown if parsing fails\n   */\n  def parse(s: String): JValue = parse(new Buffer(new StringReader(s), false))\n\n  /** Return parsed JSON.\n   * @param closeAutomatically true (default) if the Reader is automatically closed on EOF\n   * @throws ParseException is thrown if parsing fails\n   */\n  def parse(s: Reader, closeAutomatically: Boolean = true): JValue = \n    parse(new Buffer(s, closeAutomatically))\n\n  /** Return parsed JSON.\n   */\n  def parseOpt(s: String): Option[JValue] = \n    try { parse(s).toOpt } catch { case e: Exception => None }\n\n  /** Return parsed JSON.\n   * @param closeAutomatically true (default) if the Reader is automatically closed on EOF\n   */\n  def parseOpt(s: Reader, closeAutomatically: Boolean = true): Option[JValue] = \n    try { parse(s, closeAutomatically).toOpt } catch { case e: Exception => None }\n\n  /** Parse in pull parsing style.\n   * Use <code>p.nextToken</code> to parse tokens one by one from a string.\n   * @see net.liftweb.json.JsonParser.Token\n   */\n  def parse[A](s: String, p: Parser => A): A = parse(new StringReader(s), p)\n\n  /** Parse in pull parsing style.\n   * Use <code>p.nextToken</code> to parse tokens one by one from a stream.\n   * The Reader must be closed when parsing is stopped.\n   * @see net.liftweb.json.JsonParser.Token\n   */\n  def parse[A](s: Reader, p: Parser => A): A = p(new Parser(new Buffer(s, false)))\n\n  private def parse(buf: Buffer): JValue = {\n    try {\n      astParser(new Parser(buf))\n    } catch {\n      case e: ParseException => throw e\n      case e: Exception => throw new ParseException(\"parsing failed\", e)\n    } finally { buf.release }\n  }\n  \n  private[json] def unquote(string: String): String = \n    unquote(new JsonParser.Buffer(new java.io.StringReader(string), false))\n  \n  private[json] def unquote(buf: JsonParser.Buffer): String = {\n    def unquote0(buf: JsonParser.Buffer, base: String): String = {\n      val s = new java.lang.StringBuilder(base)\n      var c = '\\\\'\n      while (c != '\"') {\n        if (c == '\\\\') {\n          buf.next match {\n            case '\"'  => s.append('\"')\n            case '\\\\' => s.append('\\\\')\n            case '/'  => s.append('/')\n            case 'b'  => s.append('\\b')\n            case 'f'  => s.append('\\f')\n            case 'n'  => s.append('\\n')\n            case 'r'  => s.append('\\r')\n            case 't'  => s.append('\\t')\n            case 'u' =>\n              val chars = Array(buf.next, buf.next, buf.next, buf.next)\n              val codePoint = Integer.parseInt(new String(chars), 16)\n              s.appendCodePoint(codePoint)\n            case _ => s.append('\\\\')\n          }\n        } else s.append(c)\n        c = buf.next\n      }\n      s.toString\n    }\n\n    buf.eofIsFailure = true\n    buf.mark\n    var c = buf.next\n    while (c != '\"') {\n      if (c == '\\\\') {\n        val s = unquote0(buf, buf.substring)\n        buf.eofIsFailure = false\n        return s\n      }\n      c = buf.next\n    }\n    buf.eofIsFailure = false\n    buf.substring\n  }\n\n  // FIXME fail fast to prevent infinite loop, see \n  // http://www.exploringbinary.com/java-hangs-when-converting-2-2250738585072012e-308/\n  private val BrokenDouble = BigDecimal(\"2.2250738585072012e-308\")\n  private[json] def parseDouble(s: String) = {\n    val d = BigDecimal(s)\n    if (d == BrokenDouble) sys.error(\"Error parsing 2.2250738585072012e-308\")\n    else d.doubleValue\n  }\n\n  private val astParser = (p: Parser) => {\n    val vals = new ValStack(p)\n    var token: Token = null\n    var root: Option[JValue] = None\n\n    // This is a slightly faster way to correct order of fields and arrays than using 'map'.\n    def reverse(v: JValue): JValue = v match {\n      case JObject(l) => JObject(l.map(reverse).asInstanceOf[List[JField]].reverse)\n      case JArray(l) => JArray(l.map(reverse).reverse)\n      case JField(name, value) => JField(name, reverse(value))\n      case x => x\n    }\n\n    def closeBlock(v: JValue) {\n      vals.peekOption match {\n        case Some(f: JField) =>\n          val field = vals.pop(classOf[JField])\n          val newField = JField(field.name, v)\n          val obj = vals.peek(classOf[JObject])\n          vals.replace(JObject(newField :: obj.obj))\n        case Some(o: JObject) => v match {\n          case x: JField => vals.replace(JObject(x :: o.obj))\n          case _ => p.fail(\"expected field but got \" + v)\n        }\n        case Some(a: JArray) => vals.replace(JArray(v :: a.arr))\n        case Some(x) => p.fail(\"expected field, array or object but got \" + x)\n        case None => root = Some(reverse(v))\n      }\n    }\n\n    def newValue(v: JValue) {\n      if (!vals.isEmpty)\n        vals.peek(classOf[JValue]) match {\n          case f: JField =>\n            vals.pop(classOf[JField])\n            val newField = JField(f.name, v)\n            val obj = vals.peek(classOf[JObject])\n            vals.replace(JObject(newField :: obj.obj))\n          case a: JArray => vals.replace(JArray(v :: a.arr))\n          case _ => p.fail(\"expected field or array\")\n        }\n      else {\n        vals.push(v)\n        root = Some(v)\n      }\n    }\n\n    do {\n      token = p.nextToken\n      token match {\n        case OpenObj          => vals.push(JObject(Nil))\n        case FieldStart(name) => vals.push(JField(name, null))\n        case StringVal(x)     => newValue(JString(x))\n        case IntVal(x)        => newValue(JInt(x))\n        case DoubleVal(x)     => newValue(JDouble(x))\n        case BoolVal(x)       => newValue(JBool(x))\n        case NullVal          => newValue(JNull)\n        case CloseObj         => closeBlock(vals.pop(classOf[JValue]))\n        case OpenArr          => vals.push(JArray(Nil))\n        case CloseArr         => closeBlock(vals.pop(classOf[JArray]))\n        case End              =>\n      }\n    } while (token != End)\n\n    root getOrElse JNothing\n  }\n\n  private val EOF = (-1).asInstanceOf[Char]\n\n  private class ValStack(parser: Parser) {\n    import java.util.LinkedList\n    private[this] val stack = new LinkedList[JValue]()\n\n    def pop[A <: JValue](expectedType: Class[A]) = convert(stack.poll, expectedType)\n    def push(v: JValue) = stack.addFirst(v)\n    def peek[A <: JValue](expectedType: Class[A]) = convert(stack.peek, expectedType)\n    def replace[A <: JValue](newTop: JValue) = stack.set(0, newTop)\n\n    private def convert[A <: JValue](x: JValue, expectedType: Class[A]): A = {\n      if (x == null) parser.fail(\"expected object or array\")\n      try { x.asInstanceOf[A] } catch { case _: ClassCastException => parser.fail(\"unexpected \" + x) }\n    }\n\n    def peekOption = if (stack isEmpty) None else Some(stack.peek)\n    def isEmpty = stack.isEmpty\n  }\n\n  class Parser(buf: Buffer) {\n    import java.util.LinkedList\n\n    private[this] val blocks = new LinkedList[BlockMode]()\n    private[this] var fieldNameMode = true\n\n    def fail(msg: String) = throw new ParseException(msg + \"\\nNear: \" + buf.near, null)\n\n    /** Parse next Token from stream.\n     */\n    def nextToken: Token = {\n      def isDelimiter(c: Char) = c == ' ' || c == '\\n' || c == ',' || c == '\\r' || c == '\\t' || c == '}' || c == ']'\n\n      def parseString: String = \n        try {\n          unquote(buf)\n        } catch {\n          case p: ParseException => throw p\n          case _: Exception => fail(\"unexpected string end\")\n        }\n\n      def parseValue(first: Char) = {\n        var wasInt = true\n        var doubleVal = false\n        val s = new StringBuilder\n        s.append(first)\n        while (wasInt) {\n          val c = buf.next\n          if (c == EOF) {\n            wasInt = false\n          } else if (c == '.' || c == 'e' || c == 'E') {\n            doubleVal = true\n            s.append(c)\n          } else if (!(Character.isDigit(c) || c == '.' || c == 'e' || c == 'E' || c == '-')) {\n            wasInt = false\n            buf.back\n          } else s.append(c)\n        }\n        val value = s.toString\n        if (doubleVal) DoubleVal(parseDouble(value)) \n        else IntVal(BigInt(value))\n      }\n\n      while (true) {\n        buf.next match {\n          case c if EOF == c => \n            buf.automaticClose\n            return End\n          case '{' =>\n            blocks.addFirst(OBJECT)\n            fieldNameMode = true\n            return OpenObj\n          case '}' =>\n            blocks.poll\n            return CloseObj\n          case '\"' =>\n            if (fieldNameMode && blocks.peek == OBJECT) return FieldStart(parseString)\n            else {\n              fieldNameMode = true\n              return StringVal(parseString)\n            }\n          case 't' =>\n            fieldNameMode = true\n            if (buf.next == 'r' && buf.next == 'u' && buf.next == 'e') {\n              return BoolVal(true)\n            }\n            fail(\"expected boolean\")\n          case 'f' =>\n            fieldNameMode = true\n            if (buf.next == 'a' && buf.next == 'l' && buf.next == 's' && buf.next == 'e') {\n              return BoolVal(false)\n            }\n            fail(\"expected boolean\")\n          case 'n' =>\n            fieldNameMode = true\n            if (buf.next == 'u' && buf.next == 'l' && buf.next == 'l') {\n              return NullVal\n            }\n            fail(\"expected null\")\n          case ':' =>\n            if (blocks.peek == ARRAY) fail(\"Colon in an invalid position\")\n            fieldNameMode = false\n          case '[' =>\n            blocks.addFirst(ARRAY)\n            return OpenArr\n          case ']' =>\n            fieldNameMode = true\n            blocks.poll\n            return CloseArr\n          case c if Character.isDigit(c) || c == '-' =>\n            fieldNameMode = true\n            return parseValue(c)\n          case c if isDelimiter(c) =>\n          case c => fail(\"unknown token \" + c)\n        }\n      }\n      buf.automaticClose\n      End\n    }\n\n    sealed abstract class BlockMode\n    case object ARRAY extends BlockMode\n    case object OBJECT extends BlockMode\n  }\n\n  /* Buffer used to parse JSON.\n   * Buffer is divided to one or more segments (preallocated in Segments pool).\n   */\n  private[json] class Buffer(in: Reader, closeAutomatically: Boolean) {\n    var offset = 0\n    var curMark = -1\n    var curMarkSegment = -1\n    var eofIsFailure = false\n    private[this] var segments: List[Segment] = List(Segments.apply())\n    private[this] var segment: Array[Char] = segments.head.seg\n    private[this] var cur = 0 // Pointer which points current parsing location\n    private[this] var curSegmentIdx = 0 // Pointer which points current segment\n\n    def mark = { curMark = cur; curMarkSegment = curSegmentIdx }\n    def back = cur = cur-1\n\n    def next: Char = {\n      if (cur >= offset && read < 0) {\n        if (eofIsFailure) throw new ParseException(\"unexpected eof\", null) else EOF\n      } else {\n        val c = segment(cur)\n        cur += 1\n        c\n      }\n    }\n\n    def substring = {\n      if (curSegmentIdx == curMarkSegment) new String(segment, curMark, cur-curMark-1)\n      else { // slower path for case when string is in two or more segments\n        var parts: List[(Int, Int, Array[Char])] = Nil\n        var i = curSegmentIdx\n        while (i >= curMarkSegment) {\n          val s = segments(i).seg\n          val start = if (i == curMarkSegment) curMark else 0\n          val end = if (i == curSegmentIdx) cur else s.length+1\n          parts = (start, end, s) :: parts\n          i = i-1\n        }\n        val len = parts.map(p => p._2 - p._1 - 1).foldLeft(0)(_ + _)\n        val chars = new Array[Char](len)\n        i = 0\n        var pos = 0\n\n        while (i < parts.size) {\n          val (start, end, b) = parts(i)\n          val partLen = end-start-1\n          System.arraycopy(b, start, chars, pos, partLen)\n          pos = pos + partLen\n          i = i+1\n        }\n        new String(chars)\n      }\n    }\n\n    def near = {\n      val start = (cur - 20) max 0\n      val len = ((cur + 1) min Segments.segmentSize) - start\n      new String(segment, start, len)\n    }\n\n    def release = segments.foreach(Segments.release)\n\n    private[JsonParser] def automaticClose = if (closeAutomatically) in.close\n\n    private[this] def read = {\n      if (offset >= segment.length) {\n        val newSegment = Segments.apply()\n        offset = 0\n        segment = newSegment.seg\n        segments = segments ::: List(newSegment)\n        curSegmentIdx = segments.length - 1\n      }\n\n      val length = in.read(segment, offset, segment.length-offset)\n      if (length != -1) {\n        cur = offset\n        offset += length\n        length\n      } else -1\n    }\n  }\n\n  /* A pool of preallocated char arrays.\n   */\n  private[json] object Segments {\n    import java.util.concurrent.ArrayBlockingQueue\n    import java.util.concurrent.atomic.AtomicInteger\n\n    private[json] var segmentSize = 1000\n    private[this] val maxNumOfSegments = 10000\n    private[this] var segmentCount = new AtomicInteger(0)\n    private[this] val segments = new ArrayBlockingQueue[Segment](maxNumOfSegments)\n    private[json] def clear = segments.clear\n\n    def apply(): Segment = {\n      val s = acquire\n      // Give back a disposable segment if pool is exhausted.\n      if (s != null) s else DisposableSegment(new Array(segmentSize))\n    }\n\n    private[this] def acquire: Segment = {\n      val curCount = segmentCount.get\n      val createNew = \n        if (segments.size == 0 && curCount < maxNumOfSegments)\n          segmentCount.compareAndSet(curCount, curCount + 1)\n        else false\n\n      if (createNew) RecycledSegment(new Array(segmentSize)) else segments.poll\n    }\n\n    def release(s: Segment) = s match {\n      case _: RecycledSegment => segments.offer(s)\n      case _ =>\n    }\n  }\n\n  sealed trait Segment {\n    val seg: Array[Char]\n  }\n  case class RecycledSegment(seg: Array[Char]) extends Segment\n  case class DisposableSegment(seg: Array[Char]) extends Segment\n}\n", "/*\n * Copyright 2009-2011 WorldWide Conferencing, LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage net.liftweb\npackage json\n\nimport org.specs2.mutable.Specification\nimport org.specs2.ScalaCheck\nimport org.scalacheck.{Arbitrary, Gen}\nimport org.scalacheck.Prop._\n\n\n/**\n * System under specification for JSON Parser.\n */\nobject JsonParserSpec extends Specification with JValueGen with ScalaCheck {\n\n  private def parseBadThing(): String =     try {\n    parse(\"\"\"{\"user\":\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"<}\"\"\")\n    \"x\" * 1000\n  } catch {\n    case e: Throwable => e.getMessage\n  }\n\n\n  \"JSON Parser Specification\".title\n\n  \"Any valid json can be parsed\" in {\n    val parsing = (json: JValue) => { parse(Printer.pretty(render(json))); true }\n    check(forAll(genJValue)(parsing))\n  }\n\n  \"Buffer size does not change parsing result\" in {\n    val bufSize = Gen.choose(2, 64)\n    val parsing = (x: JValue, s1: Int, s2: Int) => { parseVal(x, s1) == parseVal(x, s2) }\n    check(forAll(genObject, bufSize, bufSize)(parsing))\n  }\n\n  \"Parsing is thread safe\" in {\n    import java.util.concurrent._\n\n    val json = Examples.person\n    val executor = Executors.newFixedThreadPool(100)\n    val results = (0 to 100).map(_ =>\n      executor.submit(new Callable[JValue] { def call = parse(json) })).toList.map(_.get)\n    results.zip(results.tail).forall(pair => pair._1 == pair._2) mustEqual true\n  }\n\n  \"All valid string escape characters can be parsed\" in {\n    parse(\"[\\\"abc\\\\\\\"\\\\\\\\\\\\/\\\\b\\\\f\\\\n\\\\r\\\\t\\\\u00a0\\\"]\") must_== JArray(JString(\"abc\\\"\\\\/\\b\\f\\n\\r\\t\\u00a0\")::Nil)\n  }\n\n\n  \"Parser does not bleed prior results\" in {\n    parse(\"\"\"{\"a\": \"now is the time for all good men to come to the aid of their dog and eat dog food with other dogs and bark and woof and do dog things. now is the time for all good men to come to the aid of their dog and eat dog food with other dogs and bark and woof and do dog things. now is the time for all good men to come to the aid of their dog and eat dog food with other dogs and bark and woof and do dog things. now is the time for all good men to come to the aid of their dog and eat dog food with other dogs and bark and woof and do dog things. now is the time for all good men to come to the aid of their dog and eat dog food with other dogs and bark and woof and do dog things. now is the time for all good men to come to the aid of their dog and eat dog food with other dogs and bark and woof and do dog things. now is the time for all good men to come to the aid of their dog and eat dog food with other dogs and bark and woof and do dog things.now is the time for all good men to come to the aid of their dog and eat dog food with other dogs and bark and woof and do dog things\"}\"\"\")\n\n    val msg = parseBadThing()\n\n    msg.length must be_<=(50)\n  }\n\n  \"Unclosed string literal fails parsing\" in {\n    parseOpt(\"{\\\"foo\\\":\\\"sd\") mustEqual None\n    parseOpt(\"{\\\"foo\\\":\\\"sd}\") mustEqual None\n  }\n\n  \"The EOF has reached when the Reader returns EOF\" in {\n    class StingyReader(s: String) extends java.io.StringReader(s) {\n      override def read(cbuf: Array[Char], off: Int, len: Int): Int = {\n        val c = read()\n        if (c == -1) -1\n        else {\n          cbuf(off) = c.toChar\n          1\n        }\n      }\n    }\n\n    val json = JsonParser.parse(new StingyReader(\"\"\" [\"hello\"] \"\"\"))\n    json mustEqual JArray(JString(\"hello\") :: Nil)\n  }\n\n  implicit def arbJValue: Arbitrary[JValue] = Arbitrary(genObject)\n\n  private def parseVal(json: JValue, bufSize: Int) = {\n    val existingSize = JsonParser.Segments.segmentSize\n    try {\n      JsonParser.Segments.segmentSize = bufSize\n      JsonParser.Segments.clear\n      JsonParser.parse(compact(render(json)))\n    } finally {\n      JsonParser.Segments.segmentSize = existingSize\n    }\n  }\n}\n"], "filenames": ["core/json/src/main/scala/net/liftweb/json/JsonParser.scala", "core/json/src/test/scala/net/liftweb/json/JsonParserSpec.scala"], "buggy_code_start_loc": [387, 29], "buggy_code_end_loc": [388, 54], "fixing_code_start_loc": [387, 30], "fixing_code_end_loc": [392, 73], "type": "CWE-119", "message": "The JsonParser class in json/JsonParser.scala in Lift before 2.5 interprets a certain end-index value as a length value, which allows remote authenticated users to obtain sensitive information from other users' sessions via invalid input data containing a < (less than) character.", "other": {"cve": {"id": "CVE-2013-3300", "sourceIdentifier": "cve@mitre.org", "published": "2013-07-29T13:59:05.480", "lastModified": "2013-07-29T13:59:05.480", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The JsonParser class in json/JsonParser.scala in Lift before 2.5 interprets a certain end-index value as a length value, which allows remote authenticated users to obtain sensitive information from other users' sessions via invalid input data containing a < (less than) character."}, {"lang": "es", "value": "La clase JsonParser en json/JsonParser.scala en Lift anterior a 2.5, interpreta un valor de end-index como un valor largo, lo que permite a usuarios autenticados remotamente obtener informaci\u00f3n sensible desde las sesiones de otros usuarios a trav\u00e9s de datos no v\u00e1lidos que contienen un car\u00e1cter \"<\"."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:liftweb:lift:*:rc6:*:*:*:*:*:*", "versionEndIncluding": "2.5", "matchCriteriaId": "64A7822D-2B0B-43F8-8F2E-607AFDF85792"}, {"vulnerable": true, "criteria": "cpe:2.3:a:liftweb:lift:2.1:*:*:*:*:*:*:*", "matchCriteriaId": "CDF2EF6D-AA97-4A6D-A438-1C5C273B4349"}, {"vulnerable": true, "criteria": "cpe:2.3:a:liftweb:lift:2.2:*:*:*:*:*:*:*", "matchCriteriaId": "76FD44BE-B420-44AE-8C03-EF00B19B7E8F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:liftweb:lift:2.3:*:*:*:*:*:*:*", "matchCriteriaId": "213FC528-8709-4C93-902E-0CFF7A3A3303"}, {"vulnerable": true, "criteria": "cpe:2.3:a:liftweb:lift:2.4:*:*:*:*:*:*:*", "matchCriteriaId": "B898631E-54F3-4438-8DAC-27147512D38C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:liftweb:lift:2.5:m4:*:*:*:*:*:*", "matchCriteriaId": "BA77D39D-B4B6-4F50-9D9E-FA5808467967"}, {"vulnerable": true, "criteria": "cpe:2.3:a:liftweb:lift:2.5:rc1:*:*:*:*:*:*", "matchCriteriaId": "BD29DD85-B67E-41BC-BCD6-058655033773"}, {"vulnerable": true, "criteria": "cpe:2.3:a:liftweb:lift:2.5:rc2:*:*:*:*:*:*", "matchCriteriaId": "7D712C21-8577-4D42-9076-68922E2250C4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:liftweb:lift:2.5:rc3:*:*:*:*:*:*", "matchCriteriaId": "B3C20517-60A8-4944-8ABF-3FD3EE9B709B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:liftweb:lift:2.5:rc4:*:*:*:*:*:*", "matchCriteriaId": "F9F99E35-1946-438E-9ECC-F98F547F743B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:liftweb:lift:2.5:rc5:*:*:*:*:*:*", "matchCriteriaId": "F8E40AE5-6A4D-4101-8A75-922A91FA9B5D"}]}]}], "references": [{"url": "http://blog.addepar.com/2013/07/an-atypical-web-vulnerability.html", "source": "cve@mitre.org", "tags": ["Exploit"]}, {"url": "https://github.com/lift/framework/commit/099d9c86cf6d81f4953957add478ab699946e601", "source": "cve@mitre.org", "tags": ["Exploit", "Patch"]}]}, "github_commit_url": "https://github.com/lift/framework/commit/099d9c86cf6d81f4953957add478ab699946e601"}}