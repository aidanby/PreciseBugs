{"buggy_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2012\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / Media Tools sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n\n\n#include <gpac/constants.h>\n#include <gpac/utf.h>\n#include <gpac/xml.h>\n#include <gpac/token.h>\n#include <gpac/color.h>\n#include <gpac/internal/media_dev.h>\n#include <gpac/internal/isomedia_dev.h>\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nvoid gf_media_update_bitrate(GF_ISOFile *file, u32 track);\n\nenum\n{\n\tGF_TEXT_IMPORT_NONE = 0,\n\tGF_TEXT_IMPORT_SRT,\n\tGF_TEXT_IMPORT_SUB,\n\tGF_TEXT_IMPORT_TTXT,\n\tGF_TEXT_IMPORT_TEXML,\n\tGF_TEXT_IMPORT_WEBVTT,\n\tGF_TEXT_IMPORT_TTML,\n\tGF_TEXT_IMPORT_SWF_SVG,\n};\n\n#define REM_TRAIL_MARKS(__str, __sep) while (1) {\t\\\n\t\tu32 _len = (u32) strlen(__str);\t\t\\\n\t\tif (!_len) break;\t\\\n\t\t_len--;\t\t\t\t\\\n\t\tif (strchr(__sep, __str[_len])) __str[_len] = 0;\t\\\n\t\telse break;\t\\\n\t}\t\\\n \n\ns32 gf_text_get_utf_type(FILE *in_src)\n{\n\tu32 read;\n\tunsigned char BOM[5];\n\tread = (u32) fread(BOM, sizeof(char), 5, in_src);\n\tif ((s32) read < 1)\n\t\treturn -1;\n\n\tif ((BOM[0]==0xFF) && (BOM[1]==0xFE)) {\n\t\t/*UTF32 not supported*/\n\t\tif (!BOM[2] && !BOM[3]) return -1;\n\t\tgf_fseek(in_src, 2, SEEK_SET);\n\t\treturn 3;\n\t}\n\tif ((BOM[0]==0xFE) && (BOM[1]==0xFF)) {\n\t\t/*UTF32 not supported*/\n\t\tif (!BOM[2] && !BOM[3]) return -1;\n\t\tgf_fseek(in_src, 2, SEEK_SET);\n\t\treturn 2;\n\t} else if ((BOM[0]==0xEF) && (BOM[1]==0xBB) && (BOM[2]==0xBF)) {\n\t\tgf_fseek(in_src, 3, SEEK_SET);\n\t\treturn 1;\n\t}\n\tif (BOM[0]<0x80) {\n\t\tgf_fseek(in_src, 0, SEEK_SET);\n\t\treturn 0;\n\t}\n\treturn -1;\n}\n\nstatic GF_Err gf_text_guess_format(char *filename, u32 *fmt)\n{\n\tchar szLine[2048];\n\tu32 val;\n\ts32 uni_type;\n\tFILE *test = gf_fopen(filename, \"rb\");\n\tif (!test) return GF_URL_ERROR;\n\tuni_type = gf_text_get_utf_type(test);\n\n\tif (uni_type>1) {\n\t\tconst u16 *sptr;\n\t\tchar szUTF[1024];\n\t\tu32 read = (u32) fread(szUTF, 1, 1023, test);\n\t\tif ((s32) read < 0) {\n\t\t\tgf_fclose(test);\n\t\t\treturn GF_IO_ERR;\n\t\t}\n\t\tszUTF[read]=0;\n\t\tsptr = (u16*)szUTF;\n\t\t/*read = (u32) */gf_utf8_wcstombs(szLine, read, &sptr);\n\t} else {\n\t\tval = (u32) fread(szLine, 1, 1024, test);\n\t\tif ((s32) val<0) return GF_IO_ERR;\n\t\t\n\t\tszLine[val]=0;\n\t}\n\tREM_TRAIL_MARKS(szLine, \"\\r\\n\\t \")\n\n\t*fmt = GF_TEXT_IMPORT_NONE;\n\tif ((szLine[0]=='{') && strstr(szLine, \"}{\")) *fmt = GF_TEXT_IMPORT_SUB;\n\telse if (szLine[0] == '<') {\n\t\tchar *ext = strrchr(filename, '.');\n\t\tif (!strnicmp(ext, \".ttxt\", 5)) *fmt = GF_TEXT_IMPORT_TTXT;\n\t\telse if (!strnicmp(ext, \".ttml\", 5)) *fmt = GF_TEXT_IMPORT_TTML;\n\t\text = strstr(szLine, \"?>\");\n\t\tif (ext) ext += 2;\n\t\tif (ext && !ext[0]) {\n\t\t\tif (!fgets(szLine, 2048, test))\n\t\t\t\tszLine[0] = '\\0';\n\t\t}\n\t\tif (strstr(szLine, \"x-quicktime-tx3g\") || strstr(szLine, \"text3GTrack\")) *fmt = GF_TEXT_IMPORT_TEXML;\n\t\telse if (strstr(szLine, \"TextStream\")) *fmt = GF_TEXT_IMPORT_TTXT;\n\t\telse if (strstr(szLine, \"tt\")) *fmt = GF_TEXT_IMPORT_TTML;\n\t}\n\telse if (strstr(szLine, \"WEBVTT\") )\n\t\t*fmt = GF_TEXT_IMPORT_WEBVTT;\n\telse if (strstr(szLine, \" --> \") )\n\t\t*fmt = GF_TEXT_IMPORT_SRT; /* might want to change the default to WebVTT */\n\n\tgf_fclose(test);\n\treturn GF_OK;\n}\n\n\n#define TTXT_DEFAULT_WIDTH\t400\n#define TTXT_DEFAULT_HEIGHT\t60\n#define TTXT_DEFAULT_FONT_SIZE\t18\n\n#ifndef GPAC_DISABLE_MEDIA_IMPORT\nvoid gf_text_get_video_size(GF_MediaImporter *import, u32 *width, u32 *height)\n{\n\tu32 w, h, f_w, f_h, i;\n\tGF_ISOFile *dest = import->dest;\n\n\tif (import->text_track_width && import->text_track_height) {\n\t\t(*width) = import->text_track_width;\n\t\t(*height) = import->text_track_height;\n\t\treturn;\n\t}\n\n\tf_w = f_h = 0;\n\tfor (i=0; i<gf_isom_get_track_count(dest); i++) {\n\t\tswitch (gf_isom_get_media_type(dest, i+1)) {\n\t\tcase GF_ISOM_MEDIA_SCENE:\n\t\tcase GF_ISOM_MEDIA_VISUAL:\n        case GF_ISOM_MEDIA_AUXV:\n        case GF_ISOM_MEDIA_PICT:\n\t\t\tgf_isom_get_visual_info(dest, i+1, 1, &w, &h);\n\t\t\tif (w > f_w) f_w = w;\n\t\t\tif (h > f_h) f_h = h;\n\t\t\tgf_isom_get_track_layout_info(dest, i+1, &w, &h, NULL, NULL, NULL);\n\t\t\tif (w > f_w) f_w = w;\n\t\t\tif (h > f_h) f_h = h;\n\t\t\tbreak;\n\t\t}\n\t}\n\t(*width) = f_w ? f_w : TTXT_DEFAULT_WIDTH;\n\t(*height) = f_h ? f_h : TTXT_DEFAULT_HEIGHT;\n}\n\n\nvoid gf_text_import_set_language(GF_MediaImporter *import, u32 track)\n{\n\tif (import->esd && import->esd->langDesc) {\n\t\tchar lang[4];\n\t\tlang[0] = (import->esd->langDesc->langCode>>16) & 0xFF;\n\t\tlang[1] = (import->esd->langDesc->langCode>>8) & 0xFF;\n\t\tlang[2] = (import->esd->langDesc->langCode) & 0xFF;\n\t\tlang[3] = 0;\n\t\tgf_isom_set_media_language(import->dest, track, lang);\n\t}\n}\n#endif\n\nchar *gf_text_get_utf8_line(char *szLine, u32 lineSize, FILE *txt_in, s32 unicode_type)\n{\n\tu32 i, j, len;\n\tchar *sOK;\n\tchar szLineConv[1024];\n\tunsigned short *sptr;\n\n\tmemset(szLine, 0, sizeof(char)*lineSize);\n\tsOK = fgets(szLine, lineSize, txt_in);\n\tif (!sOK) return NULL;\n\tif (unicode_type<=1) {\n\t\tj=0;\n\t\tlen = (u32) strlen(szLine);\n\t\tfor (i=0; i<len; i++) {\n\t\t\tif (!unicode_type && (szLine[i] & 0x80)) {\n\t\t\t\t/*non UTF8 (likely some win-CP)*/\n\t\t\t\tif ((szLine[i+1] & 0xc0) != 0x80) {\n\t\t\t\t\tszLineConv[j] = 0xc0 | ( (szLine[i] >> 6) & 0x3 );\n\t\t\t\t\tj++;\n\t\t\t\t\tszLine[i] &= 0xbf;\n\t\t\t\t}\n\t\t\t\t/*UTF8 2 bytes char*/\n\t\t\t\telse if ( (szLine[i] & 0xe0) == 0xc0) {\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\t/*UTF8 3 bytes char*/\n\t\t\t\telse if ( (szLine[i] & 0xf0) == 0xe0) {\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\t/*UTF8 4 bytes char*/\n\t\t\t\telse if ( (szLine[i] & 0xf8) == 0xf0) {\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t} else {\n\t\t\t\t\ti+=1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tszLineConv[j] = szLine[i];\n\t\t\tj++;\n\t\t}\n\t\tszLineConv[j] = 0;\n\t\tstrcpy(szLine, szLineConv);\n\t\treturn sOK;\n\t}\n\n#ifdef GPAC_BIG_ENDIAN\n\tif (unicode_type==3) {\n#else\n\tif (unicode_type==2) {\n#endif\n\t\ti=0;\n\t\twhile (1) {\n\t\t\tchar c;\n\t\t\tif (!szLine[i] && !szLine[i+1]) break;\n\t\t\tc = szLine[i+1];\n\t\t\tszLine[i+1] = szLine[i];\n\t\t\tszLine[i] = c;\n\t\t\ti+=2;\n\t\t}\n\t}\n\tsptr = (u16 *)szLine;\n\ti = (u32) gf_utf8_wcstombs(szLineConv, 1024, (const unsigned short **) &sptr);\n\tszLineConv[i] = 0;\n\tstrcpy(szLine, szLineConv);\n\t/*this is ugly indeed: since input is UTF16-LE, there are many chances the fgets never reads the \\0 after a \\n*/\n\tif (unicode_type==3) fgetc(txt_in);\n\treturn sOK;\n}\n\n\n#ifndef GPAC_DISABLE_MEDIA_IMPORT\n\nstatic GF_Err gf_text_import_srt(GF_MediaImporter *import)\n{\n\tFILE *srt_in;\n\tu32 track, timescale, i, count;\n\tGF_TextConfig*cfg;\n\tGF_Err e;\n\tGF_StyleRecord rec;\n\tGF_TextSample * samp;\n\tGF_ISOSample *s;\n\tu32 sh, sm, ss, sms, eh, em, es, ems, txt_line, char_len, char_line, nb_samp, j, duration, rem_styles;\n\tBool set_start_char, set_end_char, first_samp, rem_color;\n\tu64 start, end, prev_end, file_size;\n\tu32 state, curLine, line, len, ID, OCR_ES_ID, default_color;\n\ts32 unicode_type;\n\tchar szLine[2048], szText[2048], *ptr;\n\tunsigned short uniLine[5000], uniText[5000], *sptr;\n\n\tsrt_in = gf_fopen(import->in_name, \"rt\");\n\tgf_fseek(srt_in, 0, SEEK_END);\n\tfile_size = gf_ftell(srt_in);\n\tgf_fseek(srt_in, 0, SEEK_SET);\n\n\tunicode_type = gf_text_get_utf_type(srt_in);\n\tif (unicode_type<0) {\n\t\tgf_fclose(srt_in);\n\t\treturn gf_import_message(import, GF_NOT_SUPPORTED, \"Unsupported SRT UTF encoding\");\n\t}\n\n\tcfg = NULL;\n\tif (import->esd) {\n\t\tif (!import->esd->slConfig) {\n\t\t\timport->esd->slConfig = (GF_SLConfig *) gf_odf_desc_new(GF_ODF_SLC_TAG);\n\t\t\timport->esd->slConfig->predefined = 2;\n\t\t\timport->esd->slConfig->timestampResolution = 1000;\n\t\t}\n\t\ttimescale = import->esd->slConfig->timestampResolution;\n\t\tif (!timescale) timescale = 1000;\n\n\t\t/*explicit text config*/\n\t\tif (import->esd->decoderConfig && import->esd->decoderConfig->decoderSpecificInfo->tag == GF_ODF_TEXT_CFG_TAG) {\n\t\t\tcfg = (GF_TextConfig *) import->esd->decoderConfig->decoderSpecificInfo;\n\t\t\timport->esd->decoderConfig->decoderSpecificInfo = NULL;\n\t\t}\n\t\tID = import->esd->ESID;\n\t\tOCR_ES_ID = import->esd->OCRESID;\n\t} else {\n\t\ttimescale = 1000;\n\t\tOCR_ES_ID = ID = 0;\n\t}\n\n\tif (cfg && cfg->timescale) timescale = cfg->timescale;\n\ttrack = gf_isom_new_track(import->dest, ID, GF_ISOM_MEDIA_TEXT, timescale);\n\tif (!track) {\n\t\tgf_fclose(srt_in);\n\t\treturn gf_import_message(import, gf_isom_last_error(import->dest), \"Error creating text track\");\n\t}\n\tgf_isom_set_track_enabled(import->dest, track, 1);\n\timport->final_trackID = gf_isom_get_track_id(import->dest, track);\n\tif (import->esd && !import->esd->ESID) import->esd->ESID = import->final_trackID;\n\n\tif (OCR_ES_ID) gf_isom_set_track_reference(import->dest, track, GF_ISOM_REF_OCR, OCR_ES_ID);\n\n\t/*setup track*/\n\tif (cfg) {\n\t\tchar *firstFont = NULL;\n\t\t/*set track info*/\n\t\tgf_isom_set_track_layout_info(import->dest, track, cfg->text_width<<16, cfg->text_height<<16, 0, 0, cfg->layer);\n\n\t\t/*and set sample descriptions*/\n\t\tcount = gf_list_count(cfg->sample_descriptions);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_TextSampleDescriptor *sd= (GF_TextSampleDescriptor *)gf_list_get(cfg->sample_descriptions, i);\n\t\t\tif (!sd->font_count) {\n\t\t\t\tsd->fonts = (GF_FontRecord*)gf_malloc(sizeof(GF_FontRecord));\n\t\t\t\tsd->font_count = 1;\n\t\t\t\tsd->fonts[0].fontID = 1;\n\t\t\t\tsd->fonts[0].fontName = gf_strdup(\"Serif\");\n\t\t\t}\n\t\t\tif (!sd->default_style.fontID) sd->default_style.fontID = sd->fonts[0].fontID;\n\t\t\tif (!sd->default_style.font_size) sd->default_style.font_size = 16;\n\t\t\tif (!sd->default_style.text_color) sd->default_style.text_color = 0xFF000000;\n\t\t\t/*store attribs*/\n\t\t\tif (!i) rec = sd->default_style;\n\n\t\t\tgf_isom_new_text_description(import->dest, track, sd, NULL, NULL, &state);\n\t\t\tif (!firstFont) firstFont = sd->fonts[0].fontName;\n\t\t}\n\t\tgf_import_message(import, GF_OK, \"Timed Text (SRT) import - text track %d x %d, font %s (size %d)\", cfg->text_width, cfg->text_height, firstFont, rec.font_size);\n\n\t\tgf_odf_desc_del((GF_Descriptor *)cfg);\n\t} else {\n\t\tu32 w, h;\n\t\tGF_TextSampleDescriptor *sd;\n\t\tgf_text_get_video_size(import, &w, &h);\n\n\t\t/*have to work with default - use max size (if only one video, this means the text region is the\n\t\tentire display, and with bottom alignment things should be fine...*/\n\t\tgf_isom_set_track_layout_info(import->dest, track, w<<16, h<<16, 0, 0, 0);\n\t\tsd = (GF_TextSampleDescriptor*)gf_odf_desc_new(GF_ODF_TX3G_TAG);\n\t\tsd->fonts = (GF_FontRecord*)gf_malloc(sizeof(GF_FontRecord));\n\t\tsd->font_count = 1;\n\t\tsd->fonts[0].fontID = 1;\n\t\tsd->fonts[0].fontName = gf_strdup(import->fontName ? import->fontName : \"Serif\");\n\t\tsd->back_color = 0x00000000;\t/*transparent*/\n\t\tsd->default_style.fontID = 1;\n\t\tsd->default_style.font_size = import->fontSize ? import->fontSize : TTXT_DEFAULT_FONT_SIZE;\n\t\tsd->default_style.text_color = 0xFFFFFFFF;\t/*white*/\n\t\tsd->default_style.style_flags = 0;\n\t\tsd->horiz_justif = 1; /*center of scene*/\n\t\tsd->vert_justif = (s8) -1;\t/*bottom of scene*/\n\n\t\tif (import->flags & GF_IMPORT_SKIP_TXT_BOX) {\n\t\t\tsd->default_pos.top = sd->default_pos.left = sd->default_pos.right = sd->default_pos.bottom = 0;\n\t\t} else {\n\t\t\tif ((sd->default_pos.bottom==sd->default_pos.top) || (sd->default_pos.right==sd->default_pos.left)) {\n\t\t\t\tsd->default_pos.left = import->text_x;\n\t\t\t\tsd->default_pos.top = import->text_y;\n\t\t\t\tsd->default_pos.right = (import->text_width ? import->text_width : w) + sd->default_pos.left;\n\t\t\t\tsd->default_pos.bottom = (import->text_height ? import->text_height : h) + sd->default_pos.top;\n\t\t\t}\n\t\t}\n\n\t\t/*store attribs*/\n\t\trec = sd->default_style;\n\t\tgf_isom_new_text_description(import->dest, track, sd, NULL, NULL, &state);\n\n\t\tgf_import_message(import, GF_OK, \"Timed Text (SRT) import - text track %d x %d, font %s (size %d)\", w, h, sd->fonts[0].fontName, rec.font_size);\n\t\tgf_odf_desc_del((GF_Descriptor *)sd);\n\t}\n\tgf_text_import_set_language(import, track);\n\tduration = (u32) (((Double) import->duration)*timescale/1000.0);\n\n\tdefault_color = rec.text_color;\n\n\te = GF_OK;\n\tstate = 0;\n\tend = prev_end = 0;\n\tcurLine = 0;\n\ttxt_line = 0;\n\tset_start_char = set_end_char = GF_FALSE;\n\tchar_len = 0;\n\tstart = 0;\n\tnb_samp = 0;\n\tsamp = gf_isom_new_text_sample();\n\n\tfirst_samp = GF_TRUE;\n\twhile (1) {\n\t\tchar *sOK = gf_text_get_utf8_line(szLine, 2048, srt_in, unicode_type);\n\n\t\tif (sOK) REM_TRAIL_MARKS(szLine, \"\\r\\n\\t \")\n\t\t\tif (!sOK || !strlen(szLine)) {\n\t\t\t\trec.style_flags = 0;\n\t\t\t\trec.startCharOffset = rec.endCharOffset = 0;\n\t\t\t\tif (txt_line) {\n\t\t\t\t\tif (prev_end && (start != prev_end)) {\n\t\t\t\t\t\tGF_TextSample * empty_samp = gf_isom_new_text_sample();\n\t\t\t\t\t\ts = gf_isom_text_to_sample(empty_samp);\n\t\t\t\t\t\tgf_isom_delete_text_sample(empty_samp);\n\t\t\t\t\t\tif (state<=2) {\n\t\t\t\t\t\t\ts->DTS = (u64) ((timescale*prev_end)/1000);\n\t\t\t\t\t\t\ts->IsRAP = RAP;\n\t\t\t\t\t\t\tgf_isom_add_sample(import->dest, track, 1, s);\n\t\t\t\t\t\t\tnb_samp++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgf_isom_sample_del(&s);\n\t\t\t\t\t}\n\n\t\t\t\t\ts = gf_isom_text_to_sample(samp);\n\t\t\t\t\tif (state<=2) {\n\t\t\t\t\t\ts->DTS = (u64) ((timescale*start)/1000);\n\t\t\t\t\t\ts->IsRAP = RAP;\n\t\t\t\t\t\tgf_isom_add_sample(import->dest, track, 1, s);\n\t\t\t\t\t\tgf_isom_sample_del(&s);\n\t\t\t\t\t\tnb_samp++;\n\t\t\t\t\t\tprev_end = end;\n\t\t\t\t\t}\n\t\t\t\t\ttxt_line = 0;\n\t\t\t\t\tchar_len = 0;\n\t\t\t\t\tset_start_char = set_end_char = GF_FALSE;\n\t\t\t\t\trec.startCharOffset = rec.endCharOffset = 0;\n\t\t\t\t\tgf_isom_text_reset(samp);\n\n\t\t\t\t\t//gf_import_progress(import, nb_samp, nb_samp+1);\n\t\t\t\t\tgf_set_progress(\"Importing SRT\", gf_ftell(srt_in), file_size);\n\t\t\t\t\tif (duration && (end >= duration)) break;\n\t\t\t\t}\n\t\t\t\tstate = 0;\n\t\t\t\tif (!sOK) break;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\tswitch (state) {\n\t\tcase 0:\n\t\t\tif (sscanf(szLine, \"%u\", &line) != 1) {\n\t\t\t\te = gf_import_message(import, GF_CORRUPTED_DATA, \"Bad SRT formatting - expecting number got \\\"%s\\\"\", szLine);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tif (line != curLine + 1) gf_import_message(import, GF_OK, \"WARNING: corrupted SRT frame %d after frame %d\", line, curLine);\n\t\t\tcurLine = line;\n\t\t\tstate = 1;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (sscanf(szLine, \"%u:%u:%u,%u --> %u:%u:%u,%u\", &sh, &sm, &ss, &sms, &eh, &em, &es, &ems) != 8) {\n\t\t\t\tsh = eh = 0;\n\t\t\t\tif (sscanf(szLine, \"%u:%u,%u --> %u:%u,%u\", &sm, &ss, &sms, &em, &es, &ems) != 6) {\n\t\t\t\t\te = gf_import_message(import, GF_CORRUPTED_DATA, \"Error scanning SRT frame %d timing\", curLine);\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstart = (3600*sh + 60*sm + ss)*1000 + sms;\n\t\t\tif (start<end) {\n\t\t\t\tgf_import_message(import, GF_OK, \"WARNING: overlapping SRT frame %d - starts \"LLD\" ms is before end of previous one \"LLD\" ms - adjusting time stamps\", curLine, start, end);\n\t\t\t\tstart = end;\n\t\t\t}\n\n\t\t\tend = (3600*eh + 60*em + es)*1000 + ems;\n\t\t\t/*make stream start at 0 by inserting a fake AU*/\n\t\t\tif (first_samp && (start>0)) {\n\t\t\t\ts = gf_isom_text_to_sample(samp);\n\t\t\t\ts->DTS = 0;\n\t\t\t\tgf_isom_add_sample(import->dest, track, 1, s);\n\t\t\t\tgf_isom_sample_del(&s);\n\t\t\t\tnb_samp++;\n\t\t\t}\n\t\t\trec.style_flags = 0;\n\t\t\tstate = 2;\n\t\t\tif (end<=prev_end) {\n\t\t\t\tgf_import_message(import, GF_OK, \"WARNING: overlapping SRT frame %d end \"LLD\" is at or before previous end \"LLD\" - removing\", curLine, end, prev_end);\n\t\t\t\tstart = end;\n\t\t\t\tstate = 3;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/*reset only when text is present*/\n\t\t\tfirst_samp = GF_FALSE;\n\n\t\t\t/*go to line*/\n\t\t\tif (txt_line) {\n\t\t\t\tgf_isom_text_add_text(samp, \"\\n\", 1);\n\t\t\t\tchar_len += 1;\n\t\t\t}\n\n\t\t\tptr = (char *) szLine;\n\t\t\t{\n\t\t\t\tsize_t _len = gf_utf8_mbstowcs(uniLine, 5000, (const char **) &ptr);\n\t\t\t\tif (_len == (size_t) -1) {\n\t\t\t\t\te = gf_import_message(import, GF_CORRUPTED_DATA, \"Invalid UTF data (line %d)\", curLine);\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t\tlen = (u32) _len;\n\t\t\t}\n\t\t\ti=j=0;\n\t\t\trem_styles = 0;\n\t\t\trem_color = 0;\n\t\t\twhile (i<len) {\n\t\t\t\tu32 font_style = 0;\n\t\t\t\tu32 style_nb_chars = 0;\n\t\t\t\tu32 style_def_type = 0;\n\n\t\t\t\tif ( (uniLine[i]=='<') && (uniLine[i+2]=='>')) {\n\t\t\t\t\tstyle_nb_chars = 3;\n\t\t\t\t\tstyle_def_type = 1;\n\t\t\t\t}\n\t\t\t\telse if ( (uniLine[i]=='<') && (uniLine[i+1]=='/') && (uniLine[i+3]=='>')) {\n\t\t\t\t\tstyle_def_type = 2;\n\t\t\t\t\tstyle_nb_chars = 4;\n\t\t\t\t}\n\t\t\t\telse if (uniLine[i]=='<')  {\n\t\t\t\t\tconst unsigned short* src = uniLine + i;\n\t\t\t\t\tsize_t alen = gf_utf8_wcstombs(szLine, 2048, (const unsigned short**) & src);\n\t\t\t\t\tszLine[alen] = 0;\n\t\t\t\t\tstrlwr(szLine);\n\t\t\t\t\tif (!strncmp(szLine, \"<font \", 6) ) {\n\t\t\t\t\t\tchar *a_sep = strstr(szLine, \"color\");\n\t\t\t\t\t\tif (a_sep) a_sep = strchr(a_sep, '\"');\n\t\t\t\t\t\tif (a_sep) {\n\t\t\t\t\t\t\tchar *e_sep = strchr(a_sep+1, '\"');\n\t\t\t\t\t\t\tif (e_sep) {\n\t\t\t\t\t\t\t\te_sep[0] = 0;\n\t\t\t\t\t\t\t\tfont_style = gf_color_parse(a_sep+1);\n\t\t\t\t\t\t\t\te_sep[0] = '\"';\n\t\t\t\t\t\t\t\te_sep = strchr(e_sep+1, '>');\n\t\t\t\t\t\t\t\tif (e_sep) {\n\t\t\t\t\t\t\t\t\tstyle_nb_chars = (u32) (1 + e_sep - szLine);\n\t\t\t\t\t\t\t\t\tstyle_def_type = 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (!strncmp(szLine, \"</font>\", 7) ) {\n\t\t\t\t\t\tstyle_nb_chars = 7;\n\t\t\t\t\t\tstyle_def_type = 2;\n\t\t\t\t\t\tfont_style = 0xFFFFFFFF;\n\t\t\t\t\t}\n\t\t\t\t\t//skip unknown\n\t\t\t\t\telse {\n\t\t\t\t\t\tchar *a_sep = strstr(szLine, \">\");\n\t\t\t\t\t\tif (a_sep) {\n\t\t\t\t\t\t\tstyle_nb_chars = (u32) (a_sep - szLine);\n\t\t\t\t\t\t\ti += style_nb_chars;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t/*start of new style*/\n\t\t\t\tif (style_def_type==1)  {\n\t\t\t\t\t/*store prev style*/\n\t\t\t\t\tif (set_end_char) {\n\t\t\t\t\t\tassert(set_start_char);\n\t\t\t\t\t\tgf_isom_text_add_style(samp, &rec);\n\t\t\t\t\t\tset_end_char = set_start_char = GF_FALSE;\n\t\t\t\t\t\trec.style_flags &= ~rem_styles;\n\t\t\t\t\t\trem_styles = 0;\n\t\t\t\t\t\tif (rem_color) {\n\t\t\t\t\t\t\trec.text_color = default_color;\n\t\t\t\t\t\t\trem_color = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (set_start_char && (rec.startCharOffset != j)) {\n\t\t\t\t\t\trec.endCharOffset = char_len + j;\n\t\t\t\t\t\tif (rec.style_flags) gf_isom_text_add_style(samp, &rec);\n\t\t\t\t\t}\n\t\t\t\t\tswitch (uniLine[i+1]) {\n\t\t\t\t\tcase 'b':\n\t\t\t\t\tcase 'B':\n\t\t\t\t\t\trec.style_flags |= GF_TXT_STYLE_BOLD;\n\t\t\t\t\t\tset_start_char = GF_TRUE;\n\t\t\t\t\t\trec.startCharOffset = char_len + j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'i':\n\t\t\t\t\tcase 'I':\n\t\t\t\t\t\trec.style_flags |= GF_TXT_STYLE_ITALIC;\n\t\t\t\t\t\tset_start_char = GF_TRUE;\n\t\t\t\t\t\trec.startCharOffset = char_len + j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'u':\n\t\t\t\t\tcase 'U':\n\t\t\t\t\t\trec.style_flags |= GF_TXT_STYLE_UNDERLINED;\n\t\t\t\t\t\tset_start_char = GF_TRUE;\n\t\t\t\t\t\trec.startCharOffset = char_len + j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'f':\n\t\t\t\t\tcase 'F':\n\t\t\t\t\t\tif (font_style) {\n\t\t\t\t\t\t\trec.text_color = font_style;\n\t\t\t\t\t\t\tset_start_char = GF_TRUE;\n\t\t\t\t\t\t\trec.startCharOffset = char_len + j;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ti += style_nb_chars;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t/*end of prev style*/\n\t\t\t\tif (style_def_type==2)  {\n\t\t\t\t\tswitch (uniLine[i+2]) {\n\t\t\t\t\tcase 'b':\n\t\t\t\t\tcase 'B':\n\t\t\t\t\t\trem_styles |= GF_TXT_STYLE_BOLD;\n\t\t\t\t\t\tset_end_char = GF_TRUE;\n\t\t\t\t\t\trec.endCharOffset = char_len + j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'i':\n\t\t\t\t\tcase 'I':\n\t\t\t\t\t\trem_styles |= GF_TXT_STYLE_ITALIC;\n\t\t\t\t\t\tset_end_char = GF_TRUE;\n\t\t\t\t\t\trec.endCharOffset = char_len + j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'u':\n\t\t\t\t\tcase 'U':\n\t\t\t\t\t\trem_styles |= GF_TXT_STYLE_UNDERLINED;\n\t\t\t\t\t\tset_end_char = GF_TRUE;\n\t\t\t\t\t\trec.endCharOffset = char_len + j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'f':\n\t\t\t\t\tcase 'F':\n\t\t\t\t\t\tif (font_style) {\n\t\t\t\t\t\t\trem_color = 1;\n\t\t\t\t\t\t\tset_end_char = GF_TRUE;\n\t\t\t\t\t\t\trec.endCharOffset = char_len + j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ti+=style_nb_chars;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/*store style*/\n\t\t\t\tif (set_end_char) {\n\t\t\t\t\tgf_isom_text_add_style(samp, &rec);\n\t\t\t\t\tset_end_char = GF_FALSE;\n\t\t\t\t\tset_start_char = GF_TRUE;\n\t\t\t\t\trec.startCharOffset = char_len + j;\n\t\t\t\t\trec.style_flags &= ~rem_styles;\n\t\t\t\t\trem_styles = 0;\n\t\t\t\t\trec.text_color = default_color;\n\t\t\t\t\trem_color = 0;\n\t\t\t\t}\n\n\t\t\t\tuniText[j] = uniLine[i];\n\t\t\t\tj++;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\t/*store last style*/\n\t\t\tif (set_end_char) {\n\t\t\t\tgf_isom_text_add_style(samp, &rec);\n\t\t\t\tset_end_char = GF_FALSE;\n\t\t\t\tset_start_char = GF_TRUE;\n\t\t\t\trec.startCharOffset = char_len + j;\n\t\t\t\trec.style_flags &= ~rem_styles;\n\t\t\t}\n\n\t\t\tchar_line = j;\n\t\t\tuniText[j] = 0;\n\n\t\t\tsptr = (u16 *) uniText;\n\t\t\tlen = (u32) gf_utf8_wcstombs(szText, 5000, (const u16 **) &sptr);\n\n\t\t\tgf_isom_text_add_text(samp, szText, len);\n\t\t\tchar_len += char_line;\n\t\t\ttxt_line ++;\n\t\t\tbreak;\n\t\t}\n\t\tif (duration && (start >= duration)) {\n\t\t\tend = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*final flush*/\t\n\tif (end && !(import->flags & GF_IMPORT_NO_TEXT_FLUSH ) ) {\n\t\tgf_isom_text_reset(samp);\n\t\ts = gf_isom_text_to_sample(samp);\n\t\ts->DTS = (u64) ((timescale*end)/1000);\n\t\ts->IsRAP = RAP;\n\t\tgf_isom_add_sample(import->dest, track, 1, s);\n\t\tgf_isom_sample_del(&s);\n\t\tnb_samp++;\n\t\tgf_isom_set_last_sample_duration(import->dest, track, 0);\n\t} else {\n\t\tif (duration && (start >= duration)) {\n\t\t\tgf_isom_set_last_sample_duration(import->dest, track, (timescale*duration)/1000);\n\t\t} else {\n\t\t\tgf_isom_set_last_sample_duration(import->dest, track, 0);\n\t\t}\n\t}\n\tgf_isom_delete_text_sample(samp);\n\tgf_set_progress(\"Importing SRT\", nb_samp, nb_samp);\n\nexit:\n\tif (e) gf_isom_remove_track(import->dest, track);\n\tgf_fclose(srt_in);\n\treturn e;\n}\n\n/* Structure used to pass importer and track data to the parsers without exposing the GF_MediaImporter structure\n   used by WebVTT and Flash->SVG */\ntypedef struct {\n\tGF_MediaImporter *import;\n\tu32 timescale;\n\tu32 track;\n\tu32 descriptionIndex;\n} GF_ISOFlusher;\n\n#ifndef GPAC_DISABLE_VTT\n\nstatic GF_Err gf_webvtt_import_report(void *user, GF_Err e, char *message, const char *line)\n{\n\tGF_ISOFlusher     *flusher = (GF_ISOFlusher *)user;\n\treturn gf_import_message(flusher->import, e, message, line);\n}\n\nstatic void gf_webvtt_import_header(void *user, const char *config)\n{\n\tGF_ISOFlusher     *flusher = (GF_ISOFlusher *)user;\n\tgf_isom_update_webvtt_description(flusher->import->dest, flusher->track, flusher->descriptionIndex, config);\n}\n\nstatic void gf_webvtt_flush_sample_to_iso(void *user, GF_WebVTTSample *samp)\n{\n\tGF_ISOSample            *s;\n\tGF_ISOFlusher     *flusher = (GF_ISOFlusher *)user;\n\t//gf_webvtt_dump_sample(stdout, samp);\n\ts = gf_isom_webvtt_to_sample(samp);\n\tif (s) {\n\t\ts->DTS = (u64) (flusher->timescale*gf_webvtt_sample_get_start(samp)/1000);\n\t\ts->IsRAP = RAP;\n\t\tgf_isom_add_sample(flusher->import->dest, flusher->track, flusher->descriptionIndex, s);\n\t\tgf_isom_sample_del(&s);\n\t}\n\tgf_webvtt_sample_del(samp);\n}\n\nstatic GF_Err gf_text_import_webvtt(GF_MediaImporter *import)\n{\n\tGF_Err\t\t\t\t\t\te;\n\tu32\t\t\t\t\t\t\ttrack;\n\tu32\t\t\t\t\t\t\ttimescale;\n\tu32\t\t\t\t\t\t\tduration;\n\tu32\t\t\t\t\t\t\tdescIndex=1;\n\tu32\t\t\t\t\t\t\tID;\n\tu32\t\t\t\t\t\t\tOCR_ES_ID;\n\tGF_GenericSubtitleConfig\t*cfg;\n\tGF_WebVTTParser\t\t\t\t*vttparser;\n\tGF_ISOFlusher\t\t\t\tflusher;\n\n\tcfg\t= NULL;\n\tif (import->esd) {\n\t\tif (!import->esd->slConfig)\t{\n\t\t\timport->esd->slConfig =\t(GF_SLConfig *)\tgf_odf_desc_new(GF_ODF_SLC_TAG);\n\t\t\timport->esd->slConfig->predefined =\t2;\n\t\t\timport->esd->slConfig->timestampResolution = 1000;\n\t\t}\n\t\ttimescale =\timport->esd->slConfig->timestampResolution;\n\t\tif (!timescale)\ttimescale =\t1000;\n\n\t\t/*explicit text\tconfig*/\n\t\tif (import->esd->decoderConfig && import->esd->decoderConfig->decoderSpecificInfo->tag == GF_ODF_GEN_SUB_CFG_TAG) {\n\t\t\tcfg\t= (GF_GenericSubtitleConfig\t*) import->esd->decoderConfig->decoderSpecificInfo;\n\t\t\timport->esd->decoderConfig->decoderSpecificInfo\t= NULL;\n\t\t}\n\t\tID = import->esd->ESID;\n\t\tOCR_ES_ID =\timport->esd->OCRESID;\n\t} else {\n\t\ttimescale =\t1000;\n\t\tOCR_ES_ID =\tID = 0;\n\t}\n\n\tif (cfg\t&& cfg->timescale) timescale = cfg->timescale;\n\ttrack =\tgf_isom_new_track(import->dest,\tID,\tGF_ISOM_MEDIA_TEXT,\ttimescale);\n\tif (!track)\t{\n\t\treturn gf_import_message(import, gf_isom_last_error(import->dest), \"Error creating WebVTT track\");\n\t}\n\tgf_isom_set_track_enabled(import->dest, track, 1);\n\timport->final_trackID = gf_isom_get_track_id(import->dest, track);\n\tif (import->esd && !import->esd->ESID) import->esd->ESID = import->final_trackID;\n\n\tif (OCR_ES_ID) gf_isom_set_track_reference(import->dest, track,\tGF_ISOM_REF_OCR, OCR_ES_ID);\n\n\t/*setup\ttrack*/\n\tif (cfg) {\n\t\tu32\ti;\n\t\tu32\tcount;\n\t\t/*set track\tinfo*/\n\t\tgf_isom_set_track_layout_info(import->dest,\ttrack, cfg->text_width<<16,\tcfg->text_height<<16, 0, 0,\tcfg->layer);\n\n\t\t/*and set sample descriptions*/\n\t\tcount =\tgf_list_count(cfg->sample_descriptions);\n\t\tfor\t(i=0; i<count; i++)\t{\n\t\t\tgf_isom_new_webvtt_description(import->dest, track, NULL, NULL, NULL, &descIndex);\n\t\t}\n\t\tgf_import_message(import, GF_OK, \"WebVTT import\t- text track %d\tx %d\", cfg->text_width,\tcfg->text_height);\n\t\tgf_odf_desc_del((GF_Descriptor *)cfg);\n\t} else {\n\t\tu32\tw;\n\t\tu32\th;\n\n\t\tgf_text_get_video_size(import, &w, &h);\n\t\tgf_isom_set_track_layout_info(import->dest,\ttrack, w<<16, h<<16, 0,\t0, 0);\n\n\t\tgf_isom_new_webvtt_description(import->dest, track,\tNULL, NULL,\tNULL, &descIndex);\n\n\t\tgf_import_message(import, GF_OK, \"WebVTT import\");\n\t}\n\tgf_text_import_set_language(import, track);\n\tduration = (u32) (((Double) import->duration)*timescale/1000.0);\n\n\tvttparser = gf_webvtt_parser_new();\n\tflusher.import = import;\n\tflusher.timescale = timescale;\n\tflusher.track = track;\n\tflusher.descriptionIndex = descIndex;\n\te = gf_webvtt_parser_init(vttparser, import->in_name, &flusher, gf_webvtt_import_report, gf_webvtt_flush_sample_to_iso, gf_webvtt_import_header);\n\tif (e != GF_OK) {\n\t\tgf_webvtt_parser_del(vttparser);\n\t\treturn gf_import_message(import, GF_NOT_SUPPORTED, \"Unsupported WebVTT UTF encoding\");\n\t}\n\te = gf_webvtt_parser_parse(vttparser, duration);\n\tif (e != GF_OK) {\n\t\tgf_isom_remove_track(import->dest, track);\n\t}\n\n\t/*do not add any empty sample at the end since it modifies track duration and is not needed - it is the player job\n\tto figure out when to stop displaying the last text sample\n\tHowever update the last sample duration*/\n\tgf_isom_set_last_sample_duration(import->dest, track, (u32) gf_webvtt_parser_last_duration(vttparser));\n\t\n\tgf_webvtt_parser_del(vttparser);\n\treturn e;\n}\n\n#endif /*GPAC_DISABLE_VTT*/\n\nstatic char *ttxt_parse_string(GF_MediaImporter *import, char *str, Bool strip_lines)\n{\n\tu32 i=0;\n\tu32 k=0;\n\tu32 len = (u32) strlen(str);\n\tu32 state = 0;\n\n\tif (!strip_lines) {\n\t\tfor (i=0; i<len; i++) {\n\t\t\tif ((str[i] == '\\r') && (str[i+1] == '\\n')) {\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tstr[k] = str[i];\n\t\t\tk++;\n\t\t}\n\t\tstr[k]=0;\n\t\treturn str;\n\t}\n\n\tif (str[0]!='\\'') return str;\n\tfor (i=0; i<len; i++) {\n\t\tif (str[i] == '\\'') {\n\n\t\t\tif (!state) {\n\t\t\t\tif (k) {\n\t\t\t\t\tstr[k]='\\n';\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t\tstate = !state;\n\t\t\t} else if (state) {\n\t\t\t\tif ( (i+1==len) ||\n\t\t\t\t        ((str[i+1]==' ') || (str[i+1]=='\\n') || (str[i+1]=='\\r') || (str[i+1]=='\\t') || (str[i+1]=='\\''))\n\t\t\t\t   ) {\n\t\t\t\t\tstate = !state;\n\t\t\t\t} else {\n\t\t\t\t\tstr[k] = str[i];\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (state) {\n\t\t\tstr[k] = str[i];\n\t\t\tk++;\n\t\t}\n\t}\n\tstr[k]=0;\n\treturn str;\n}\n\nstatic void ttml_import_progress(void *cbk, u64 cur_samp, u64 count)\n{\n\tgf_set_progress(\"TTML Loading\", cur_samp, count);\n}\n\nstatic void gf_text_import_ebu_ttd_remove_samples(GF_XMLNode *root, GF_XMLNode **sample_list_node)\n{\n\tu32 idx = 0, body_num = 0;\n\tGF_XMLNode *node = NULL;\n\t*sample_list_node = NULL;\n\twhile ( (node = (GF_XMLNode*)gf_list_enum(root->content, &idx))) {\n\t\tif (!strcmp(node->name, \"body\")) {\n\t\t\tGF_XMLNode *body_node;\n\t\t\tu32 body_idx = 0;\n\t\t\twhile ( (body_node = (GF_XMLNode*)gf_list_enum(node->content, &body_idx))) {\n\t\t\t\tif (!strcmp(body_node->name, \"div\")) {\n\t\t\t\t\t*sample_list_node = body_node;\n\t\t\t\t\tbody_num = gf_list_count(body_node->content);\n\t\t\t\t\twhile (body_num--) {\n\t\t\t\t\t\tGF_XMLNode *content_node = (GF_XMLNode*)gf_list_get(body_node->content, 0);\n\t\t\t\t\t\tassert(gf_list_find(body_node->content, content_node) == 0);\n\t\t\t\t\t\tgf_list_rem(body_node->content, 0);\n\t\t\t\t\t\tgf_xml_dom_node_del(content_node);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n#define TTML_NAMESPACE \"http://www.w3.org/ns/ttml\"\nstatic GF_Err gf_text_import_ebu_ttd(GF_MediaImporter *import, GF_DOMParser *parser, GF_XMLNode *root)\n{\n\tGF_Err e, e_opt;\n\tu32 i, track, ID, desc_idx, nb_samples, nb_children;\n\tu64 last_sample_duration, last_sample_end;\n\tGF_XMLAttribute *att;\n\tGF_XMLNode *node, *root_working_copy, *sample_list_node;\n\tGF_DOMParser *parser_working_copy;\n\tchar *samp_text;\n\tBool has_body;\n\n\tsamp_text = NULL;\n\troot_working_copy = NULL;\n\tparser_working_copy = NULL;\n\n\t/*setup track in 3GP format directly (no ES desc)*/\n\tID = (import->esd) ? import->esd->ESID : 0;\n\ttrack = gf_isom_new_track(import->dest, ID, GF_ISOM_MEDIA_MPEG_SUBT, 1000);\n\tif (!track) {\n\t\te = gf_isom_last_error(import->dest);\n\t\tgoto exit;\n\t}\n\tgf_isom_set_track_enabled(import->dest, track, 1);\n\n\t/*some MPEG-4 setup*/\n\tif (import->esd) {\n\t\tif (!import->esd->ESID) import->esd->ESID = gf_isom_get_track_id(import->dest, track);\n\t\tif (!import->esd->decoderConfig) import->esd->decoderConfig = (GF_DecoderConfig *) gf_odf_desc_new(GF_ODF_DCD_TAG);\n\t\tif (!import->esd->slConfig) import->esd->slConfig = (GF_SLConfig *) gf_odf_desc_new(GF_ODF_SLC_TAG);\n\t\timport->esd->slConfig->timestampResolution = 1000;\n\t\timport->esd->decoderConfig->streamType = GF_STREAM_TEXT;\n\t\timport->esd->decoderConfig->objectTypeIndication = GPAC_OTI_TEXT_MPEG4;\n\t\tif (import->esd->OCRESID) gf_isom_set_track_reference(import->dest, track, GF_ISOM_REF_OCR, import->esd->OCRESID);\n\t}\n\n\tgf_import_message(import, GF_OK, \"TTML EBU-TTD Import\");\n\n\t/*** root (including language) ***/\n\ti=0;\n\twhile ( (att = (GF_XMLAttribute *)gf_list_enum(root->attributes, &i))) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"Found root attribute name %s, value %s\\n\", att->name, att->value));\n\n\t\tif (!strcmp(att->name, \"xmlns\")) {\n\t\t\tif (strcmp(att->value, TTML_NAMESPACE)) {\n\t\t\t\te = gf_import_message(import, GF_BAD_PARAM, \"Found invalid EBU-TTD root attribute name %s, value %s (shall be \\\"%s\\\")\\n\", att->name, att->value, TTML_NAMESPACE);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t} else if (!strcmp(att->name, \"xml:lang\")) {\n\t\t\tif (import->esd && !import->esd->langDesc) {\n\t\t\t\tchar *lang;\n\t\t\t\tlang = gf_strdup(att->value);\n\t\t\t\timport->esd->langDesc = (GF_Language *) gf_odf_desc_new(GF_ODF_LANG_TAG);\n\t\t\t\tgf_isom_set_media_language(import->dest, track, lang);\n\t\t\t} else {\n\t\t\t\tgf_isom_set_media_language(import->dest, track, att->value);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*** style ***/\n#if 0\n\t{\n\t\tBool has_styling, has_style;\n\t\tGF_TextSampleDescriptor *sd;\n\t\thas_styling = GF_FALSE;\n\t\thas_style = GF_FALSE;\n\t\tsd = (GF_TextSampleDescriptor*)gf_odf_desc_new(GF_ODF_TX3G_TAG);\n\t\ti=0;\n\t\twhile ( (node = (GF_XMLNode*)gf_list_enum(root->content, &i))) {\n\t\t\tif (node->type) {\n\t\t\t\tcontinue;\n\t\t\t} else if (gf_xml_get_element_check_namespace(node, \"head\", root->ns) == GF_OK) {\n\t\t\t\tGF_XMLNode *head_node;\n\t\t\t\tu32 head_idx = 0;\n\t\t\t\twhile ( (head_node = (GF_XMLNode*)gf_list_enum(node->content, &head_idx))) {\n\t\t\t\t\tif (gf_xml_get_element_check_namespace(head_node, \"styling\", root->ns) == GF_OK) {\n\t\t\t\t\t\tGF_XMLNode *styling_node;\n\t\t\t\t\t\tu32 styling_idx;\n\t\t\t\t\t\tif (has_styling) {\n\t\t\t\t\t\t\te = gf_import_message(import, GF_BAD_PARAM, \"[TTML EBU-TTD] duplicated \\\"styling\\\" element. Abort.\\n\");\n\t\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t\t}\n\t\t\t\t\t\thas_styling = GF_TRUE;\n\n\t\t\t\t\t\tstyling_idx = 0;\n\t\t\t\t\t\twhile ( (styling_node = (GF_XMLNode*)gf_list_enum(head_node->content, &styling_idx))) {\n\t\t\t\t\t\t\tif (gf_xml_get_element_check_namespace(styling_node, \"style\", root->ns) == GF_OK) {\n\t\t\t\t\t\t\t\tGF_XMLAttribute *p_att;\n\t\t\t\t\t\t\t\tu32 style_idx = 0;\n\t\t\t\t\t\t\t\twhile ( (p_att = (GF_XMLAttribute*)gf_list_enum(styling_node->attributes, &style_idx))) {\n\t\t\t\t\t\t\t\t\tif (!strcmp(p_att->name, \"tts:direction\")) {\n\t\t\t\t\t\t\t\t\t} else if (!strcmp(p_att->name, \"tts:fontFamily\")) {\n\t\t\t\t\t\t\t\t\t\tsd->fonts = (GF_FontRecord*)gf_malloc(sizeof(GF_FontRecord));\n\t\t\t\t\t\t\t\t\t\tsd->font_count = 1;\n\t\t\t\t\t\t\t\t\t\tsd->fonts[0].fontID = 1;\n\t\t\t\t\t\t\t\t\t\tsd->fonts[0].fontName = gf_strdup(p_att->value);\n\t\t\t\t\t\t\t\t\t} else if (!strcmp(p_att->name, \"tts:backgroundColor\")) {\n\t\t\t\t\t\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_PARSER, (\"EBU-TTD style attribute \\\"%s\\\" ignored.\\n\", p_att->name));\n\t\t\t\t\t\t\t\t\t\t//sd->back_color = ;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tif ( !strcmp(p_att->name, \"tts:fontSize\")\n\t\t\t\t\t\t\t\t\t\t        || !strcmp(p_att->name, \"tts:lineHeight\")\n\t\t\t\t\t\t\t\t\t\t        || !strcmp(p_att->name, \"tts:textAlign\")\n\t\t\t\t\t\t\t\t\t\t        || !strcmp(p_att->name, \"tts:color\")\n\t\t\t\t\t\t\t\t\t\t        || !strcmp(p_att->name, \"tts:fontStyle\")\n\t\t\t\t\t\t\t\t\t\t        || !strcmp(p_att->name, \"tts:fontWeight\")\n\t\t\t\t\t\t\t\t\t\t        || !strcmp(p_att->name, \"tts:textDecoration\")\n\t\t\t\t\t\t\t\t\t\t        || !strcmp(p_att->name, \"tts:unicodeBidi\")\n\t\t\t\t\t\t\t\t\t\t        || !strcmp(p_att->name, \"tts:wrapOption\")\n\t\t\t\t\t\t\t\t\t\t        || !strcmp(p_att->name, \"tts:multiRowAlign\")\n\t\t\t\t\t\t\t\t\t\t        || !strcmp(p_att->name, \"tts:linePadding\")) {\n\t\t\t\t\t\t\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_PARSER, (\"EBU-TTD style attribute \\\"%s\\\" ignored.\\n\", p_att->name));\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"EBU-TTD unknown style attribute: \\\"%s\\\". Ignoring.\\n\", p_att->name));\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak; //TODO: we only take care of the first style\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!has_styling) {\n\t\t\te = gf_import_message(import, GF_BAD_PARAM, \"[TTML EBU-TTD] missing \\\"styling\\\" element. Abort.\\n\");\n\t\t\tgoto exit;\n\t\t}\n\t\tif (!has_style) {\n\t\t\te = gf_import_message(import, GF_BAD_PARAM, \"[TTML EBU-TTD] missing \\\"style\\\" element. Abort.\\n\");\n\t\t\tgoto exit;\n\t\t}\n\t\te = gf_isom_new_text_description(import->dest, track, sd, NULL, NULL, &desc_idx);\n\t\tgf_odf_desc_del((GF_Descriptor*)sd);\n\t}\n#else\n\te = gf_isom_new_xml_subtitle_description(import->dest, track, TTML_NAMESPACE, NULL, NULL, &desc_idx);\n#endif\n\tif (e != GF_OK) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TTML EBU-TTD] incorrect sample description. Abort.\\n\"));\n\t\te = gf_isom_last_error(import->dest);\n\t\tgoto exit;\n\t}\n\n\t/*** body ***/\n\tparser_working_copy = gf_xml_dom_new();\n\te = gf_xml_dom_parse(parser_working_copy, import->in_name, NULL, NULL);\n\tassert (e == GF_OK);\n\troot_working_copy = gf_xml_dom_get_root(parser_working_copy);\n\tassert(root_working_copy);\n\tlast_sample_duration = 0;\n\tlast_sample_end = 0;\n\tnb_samples = 0;\n\tnb_children = gf_list_count(root->content);\n\thas_body = GF_FALSE;\n\ti=0;\n\twhile ( (node = (GF_XMLNode*)gf_list_enum(root->content, &i))) {\n\t\tif (node->type) {\n\t\t\tnb_children--;\n\t\t\tcontinue;\n\t\t}\n\n\t\te_opt = gf_xml_get_element_check_namespace(node, \"body\", root->ns);\n\t\tif (e_opt == GF_BAD_PARAM) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TTML EBU-TTD] ignored \\\"%s\\\" node, check your namespaces\\n\", node->name));\n\t\t} else if (e_opt == GF_OK) {\n\t\t\tGF_XMLNode *body_node;\n\t\t\tu32 body_idx = 0;\n\n\t\t\tif (has_body) {\n\t\t\t\te = gf_import_message(import, GF_BAD_PARAM, \"[TTML EBU-TTD] duplicated \\\"body\\\" element. Abort.\\n\");\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\thas_body = GF_TRUE;\n\n\t\t\t/*remove all the entries from the working copy, we'll add samples one to one to create full XML samples*/\n\t\t\tgf_text_import_ebu_ttd_remove_samples(root_working_copy, &sample_list_node);\n\n\t\t\twhile ( (body_node = (GF_XMLNode*)gf_list_enum(node->content, &body_idx))) {\n\t\t\t\te_opt = gf_xml_get_element_check_namespace(body_node, \"div\", root->ns);\n\t\t\t\tif (e_opt == GF_BAD_PARAM) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TTML EBU-TTD] ignored \\\"%s\\\" node, check your namespaces\\n\", node->name));\n\t\t\t\t} else if (e_opt == GF_OK) {\n\t\t\t\t\tGF_XMLNode *div_node;\n\t\t\t\t\tu32 div_idx = 0, nb_p_found = 0;\n\t\t\t\t\twhile ( (div_node = (GF_XMLNode*)gf_list_enum(body_node->content, &div_idx))) {\n\t\t\t\t\t\te_opt = gf_xml_get_element_check_namespace(div_node, \"p\", root->ns);\n\t\t\t\t\t\tif (e_opt != GF_OK) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TTML] ignored \\\"%s\\\" node, check your namespaces\\n\", node->name));\n\t\t\t\t\t\t} else if (e_opt == GF_OK) {\n\t\t\t\t\t\t\tGF_XMLNode *p_node;\n\t\t\t\t\t\t\tGF_XMLAttribute *p_att;\n\t\t\t\t\t\t\tu32 p_idx = 0, h, m, s, f, ms;\n\t\t\t\t\t\t\ts64 ts_begin = -1, ts_end = -1;\n\n\t\t\t\t\t\t\t//sample is either in the <p> ...\n\t\t\t\t\t\t\twhile ( (p_att = (GF_XMLAttribute*)gf_list_enum(div_node->attributes, &p_idx))) {\n\t\t\t\t\t\t\t\tif (!p_att) continue;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif (!strcmp(p_att->name, \"begin\")) {\n\t\t\t\t\t\t\t\t\tif (ts_begin != -1) {\n\t\t\t\t\t\t\t\t\t\te = gf_import_message(import, GF_BAD_PARAM, \"[TTML] duplicated \\\"begin\\\" attribute. Abort.\\n\");\n\t\t\t\t\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (sscanf(p_att->value, \"%u:%u:%u.%u\", &h, &m, &s, &ms) == 4) {\n\t\t\t\t\t\t\t\t\t\tts_begin = (h*3600 + m*60+s)*1000+ms;\n\t\t\t\t\t\t\t\t\t} else if (sscanf(p_att->value, \"%u:%u:%u:%u\", &h, &m, &s, &f) == 4) {\n\t\t\t\t\t\t\t\t\t\tts_begin = (h*3600 + m*60+s)*1000+f*40;\n\t\t\t\t\t\t\t\t\t} else if (sscanf(p_att->value, \"%u:%u:%u\", &h, &m, &s) == 3) {\n\t\t\t\t\t\t\t\t\t\tts_begin = (h*3600 + m*60+s)*1000;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if (!strcmp(p_att->name, \"end\")) {\n\t\t\t\t\t\t\t\t\tif (ts_end != -1) {\n\t\t\t\t\t\t\t\t\t\te = gf_import_message(import, GF_BAD_PARAM, \"[TTML] duplicated \\\"end\\\" attribute. Abort.\\n\");\n\t\t\t\t\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (sscanf(p_att->value, \"%u:%u:%u.%u\", &h, &m, &s, &ms) == 4) {\n\t\t\t\t\t\t\t\t\t\tts_end = (h*3600 + m*60+s)*1000+ms;\n\t\t\t\t\t\t\t\t\t} else if (sscanf(p_att->value, \"%u:%u:%u:%u\", &h, &m, &s, &f) == 4) {\n\t\t\t\t\t\t\t\t\t\tts_end = (h*3600 + m*60+s)*1000+f*40;\n\t\t\t\t\t\t\t\t\t} else if (sscanf(p_att->value, \"%u:%u:%u\", &h, &m, &s) == 3) {\n\t\t\t\t\t\t\t\t\t\tts_end = (h*3600 + m*60+s)*1000;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif ((ts_begin != -1) && (ts_end != -1) && !samp_text && sample_list_node) {\n\t\t\t\t\t\t\t\t\te = gf_xml_dom_append_child(sample_list_node, div_node);\n\t\t\t\t\t\t\t\t\tassert(e == GF_OK);\n\t\t\t\t\t\t\t\t\tassert(!samp_text);\n\t\t\t\t\t\t\t\t\tsamp_text = gf_xml_dom_serialize((GF_XMLNode*)root_working_copy, GF_FALSE);\n\t\t\t\t\t\t\t\t\te = gf_xml_dom_rem_child(sample_list_node, div_node);\n\t\t\t\t\t\t\t\t\tassert(e == GF_OK);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t//or under a <span>\n\t\t\t\t\t\t\tp_idx = 0;\n\t\t\t\t\t\t\twhile ( (p_node = (GF_XMLNode*)gf_list_enum(div_node->content, &p_idx))) {\n\t\t\t\t\t\t\t\te_opt = gf_xml_get_element_check_namespace(p_node, \"span\", root->ns);\n\t\t\t\t\t\t\t\tif (e_opt == GF_BAD_PARAM) {\n\t\t\t\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TTML] ignored \\\"%s\\\" node, check your namespaces\\n\", node->name));\n\t\t\t\t\t\t\t\t} else if (e_opt == GF_OK) {\n\t\t\t\t\t\t\t\t\tu32 span_idx = 0;\n\t\t\t\t\t\t\t\t\tGF_XMLAttribute *span_att;\n\t\t\t\t\t\t\t\t\twhile ( (span_att = (GF_XMLAttribute*)gf_list_enum(p_node->attributes, &span_idx))) {\n\t\t\t\t\t\t\t\t\t\tif (!span_att) continue;\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\tif (!strcmp(span_att->name, \"begin\")) {\n\t\t\t\t\t\t\t\t\t\t\tif (ts_begin != -1) {\n\t\t\t\t\t\t\t\t\t\t\t\te = gf_import_message(import, GF_BAD_PARAM, \"[TTML] duplicated \\\"begin\\\" attribute under <span>. Abort.\\n\");\n\t\t\t\t\t\t\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tif (sscanf(span_att->value, \"%u:%u:%u.%u\", &h, &m, &s, &ms) == 4) {\n\t\t\t\t\t\t\t\t\t\t\t\tts_begin = (h*3600 + m*60+s)*1000+ms;\n\t\t\t\t\t\t\t\t\t\t\t} else if (sscanf(p_att->value, \"%u:%u:%u:%u\", &h, &m, &s, &f) == 4) {\n\t\t\t\t\t\t\t\t\t\t\t\tts_begin = (h*3600 + m*60+s)*1000+f*40;\n\t\t\t\t\t\t\t\t\t\t\t} else if (sscanf(span_att->value, \"%u:%u:%u\", &h, &m, &s) == 3) {\n\t\t\t\t\t\t\t\t\t\t\t\tts_begin = (h*3600 + m*60+s)*1000;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t} else if (!strcmp(span_att->name, \"end\")) {\n\t\t\t\t\t\t\t\t\t\t\tif (ts_end != -1) {\n\t\t\t\t\t\t\t\t\t\t\t\te = gf_import_message(import, GF_BAD_PARAM, \"[TTML] duplicated \\\"end\\\" attribute under <span>. Abort.\\n\");\n\t\t\t\t\t\t\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tif (sscanf(span_att->value, \"%u:%u:%u.%u\", &h, &m, &s, &ms) == 4) {\n\t\t\t\t\t\t\t\t\t\t\t\tts_end = (h*3600 + m*60+s)*1000+ms;\n\t\t\t\t\t\t\t\t\t\t\t} else if (sscanf(p_att->value, \"%u:%u:%u:%u\", &h, &m, &s, &f) == 4) {\n\t\t\t\t\t\t\t\t\t\t\t\tts_end = (h*3600 + m*60+s)*1000+f*40;\n\t\t\t\t\t\t\t\t\t\t\t} else if (sscanf(span_att->value, \"%u:%u:%u\", &h, &m, &s) == 3) {\n\t\t\t\t\t\t\t\t\t\t\t\tts_end = (h*3600 + m*60+s)*1000;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif ((ts_begin != -1) && (ts_end != -1) && !samp_text && sample_list_node) {\n\t\t\t\t\t\t\t\t\t\t\tif (samp_text) {\n\t\t\t\t\t\t\t\t\t\t\t\te = gf_import_message(import, GF_BAD_PARAM, \"[TTML] duplicated sample text under <span>. Abort.\\n\");\n\t\t\t\t\t\t\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t/*append the sample*/\n\t\t\t\t\t\t\t\t\t\t\te = gf_xml_dom_append_child(sample_list_node, div_node);\n\t\t\t\t\t\t\t\t\t\t\tassert(e == GF_OK);\n\t\t\t\t\t\t\t\t\t\t\tassert(!samp_text);\n\t\t\t\t\t\t\t\t\t\t\tsamp_text = gf_xml_dom_serialize((GF_XMLNode*)root_working_copy, GF_FALSE);\n\t\t\t\t\t\t\t\t\t\t\te = gf_xml_dom_rem_child(sample_list_node, div_node);\n\t\t\t\t\t\t\t\t\t\t\tassert(e == GF_OK);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ((ts_begin != -1) && (ts_end != -1) && samp_text) {\n\t\t\t\t\t\t\t\tGF_ISOSample *s;\n\t\t\t\t\t\t\t\tGF_GenericSubtitleSample *samp;\n\t\t\t\t\t\t\t\tu32 len;\n\t\t\t\t\t\t\t\tchar *str;\n\n\t\t\t\t\t\t\t\tif (ts_end < ts_begin) {\n\t\t\t\t\t\t\t\t\te = gf_import_message(import, GF_BAD_PARAM, \"[TTML] invalid timings: \\\"begin\\\"=\"LLD\" , \\\"end\\\"=\"LLD\". Abort.\\n\", ts_begin, ts_end);\n\t\t\t\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (ts_begin < (s64)last_sample_end) {\n\t\t\t\t\t\t\t\t\te = gf_import_message(import, GF_BAD_PARAM, \"[TTML] timing overlapping not supported: \\\"begin\\\" is \"LLD\" , last \\\"end\\\" was \"LLD\". Abort.\\n\", ts_begin, last_sample_end);\n\t\t\t\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tstr = ttxt_parse_string(import, samp_text, GF_TRUE);\n\t\t\t\t\t\t\t\tlen = (u32) strlen(str);\n\t\t\t\t\t\t\t\tsamp = gf_isom_new_xml_subtitle_sample();\n\t\t\t\t\t\t\t\t/*each sample consists of a full valid XML file*/\n\t\t\t\t\t\t\t\te = gf_isom_xml_subtitle_sample_add_text(samp, str, len);\n\t\t\t\t\t\t\t\tif (e) {\n\t\t\t\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TTML] ISOM - sample add text: %s\", gf_error_to_string(e)));\n\t\t\t\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tgf_free(samp_text);\n\t\t\t\t\t\t\t\tsamp_text = NULL;\n\n\t\t\t\t\t\t\t\ts = gf_isom_xml_subtitle_to_sample(samp);\n\t\t\t\t\t\t\t\tgf_isom_delete_xml_subtitle_sample(samp);\n\t\t\t\t\t\t\t\tif (!nb_samples) {\n\t\t\t\t\t\t\t\t\ts->DTS = 0; /*in MP4 we must start at T=0*/\n\t\t\t\t\t\t\t\t\tlast_sample_duration = ts_end;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ts->DTS = ts_begin;\n\t\t\t\t\t\t\t\t\tlast_sample_duration = ts_end - ts_begin;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlast_sample_end = ts_end;\n\t\t\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"ts_begin=\"LLD\", ts_end=\"LLD\", last_sample_duration=\"LLU\" (real duration: \"LLU\"), last_sample_end=\"LLU\"\\n\", ts_begin, ts_end, ts_end - last_sample_end, last_sample_duration, last_sample_end));\n\n\t\t\t\t\t\t\t\te = gf_isom_add_sample(import->dest, track, desc_idx, s);\n\t\t\t\t\t\t\t\tif (e) {\n\t\t\t\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TTML] ISOM - Add Sample: %s\", gf_error_to_string(e)));\n\t\t\t\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tgf_isom_sample_del(&s);\n\t\t\t\t\t\t\t\tnb_samples++;\n\n\t\t\t\t\t\t\t\tnb_p_found++;\n\t\t\t\t\t\t\t\tgf_set_progress(\"Importing TTML\", nb_samples, nb_children);\n\t\t\t\t\t\t\t\tif (import->duration && (ts_end > import->duration))\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TTML] incomplete sample (begin=\"LLD\", end=\"LLD\", text=\\\"%s\\\"). Skip.\\n\", ts_begin, ts_end, samp_text ? samp_text : \"NULL\"));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!nb_p_found) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TTML EBU-TTD] \\\"%s\\\" div node has no <p> elements. Aborting.\\n\", node->name));\n\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!has_body) {\n\t\te = gf_import_message(import, GF_BAD_PARAM, \"[TTML EBU-TTD] missing \\\"body\\\" element. Abort.\\n\");\n\t\tgoto exit;\n\t}\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"last_sample_duration=\"LLU\", last_sample_end=\"LLU\"\\n\", last_sample_duration, last_sample_end));\n\tgf_isom_set_last_sample_duration(import->dest, track, (u32) last_sample_duration);\n\tgf_media_update_bitrate(import->dest, track);\n\tgf_set_progress(\"Importing TTML EBU-TTD\", nb_samples, nb_samples);\n\nexit:\n\tgf_free(samp_text);\n\tgf_xml_dom_del(parser_working_copy);\n\tif (!gf_isom_get_sample_count(import->dest, track)) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TTML EBU-TTD] No sample imported. Might be an error. Check your content.\\n\"));\n\t}\n\treturn e;\n}\n\nstatic GF_Err gf_text_import_ttml(GF_MediaImporter *import)\n{\n\tGF_Err e;\n\tGF_DOMParser *parser;\n\tGF_XMLNode *root;\n\n\tif (import->flags == GF_IMPORT_PROBE_ONLY)\n\t\treturn GF_OK;\n\n\tparser = gf_xml_dom_new();\n\te = gf_xml_dom_parse(parser, import->in_name, ttml_import_progress, import);\n\tif (e) {\n\t\tgf_import_message(import, e, \"Error parsing TTML file: Line %d - %s. Abort.\", gf_xml_dom_get_line(parser), gf_xml_dom_get_error(parser));\n\t\tgf_xml_dom_del(parser);\n\t\treturn e;\n\t}\n\troot = gf_xml_dom_get_root(parser);\n\tif (!root) {\n\t\tgf_import_message(import, e, \"Error parsing TTML file: no \\\"root\\\" found. Abort.\");\n\t\tgf_xml_dom_del(parser);\n\t\treturn e;\n\t}\n\n\t/*look for TTML*/\n\tif (gf_xml_get_element_check_namespace(root, \"tt\", NULL) == GF_OK) {\n\t\te = gf_text_import_ebu_ttd(import, parser, root);\n\t\tif (e == GF_OK) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"Note: TTML import - EBU-TTD detected\\n\"));\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"Parsing TTML file with error: %s\\n\", gf_error_to_string(e)));\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_PARSER, (\"Unsupported TTML file - only EBU-TTD is supported (root shall be \\\"tt\\\", got \\\"%s\\\")\\n\", root->name));\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_PARSER, (\"Importing as generic TTML\\n\"));\n\t\t\te = GF_OK;\n\t\t}\n\t} else {\n\t\tif (root->ns) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"TTML file not recognized: root element is \\\"%s:%s\\\" (check your namespaces)\\n\", root->ns, root->name));\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"TTML file not recognized: root element is \\\"%s\\\"\\n\", root->name));\n\t\t}\n\t\te = GF_BAD_PARAM;\n\t}\n\n\tgf_xml_dom_del(parser);\n\treturn e;\n}\n\n/* SimpleText Text tracks -related functions */\nGF_Box *boxstring_new_with_data(u32 type, const char *string);\n\n#ifndef GPAC_DISABLE_SWF_IMPORT\n\n/* SWF Importer */\n#include <gpac/internal/swf_dev.h>\n\nstatic GF_Err swf_svg_add_iso_sample(void *user, const char *data, u32 length, u64 timestamp, Bool isRap)\n{\n\tGF_Err\t\t\t\te = GF_OK;\n\tGF_ISOFlusher\t\t*flusher = (GF_ISOFlusher *)user;\n\tGF_ISOSample\t\t*s;\n\tGF_BitStream\t\t*bs;\n\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tif (!bs) return GF_BAD_PARAM;\n\tgf_bs_write_data(bs, data, length);\n\ts = gf_isom_sample_new();\n\tif (s) {\n\t\tgf_bs_get_content(bs, &s->data, &s->dataLength);\n\t\ts->DTS = (u64) (flusher->timescale*timestamp/1000);\n\t\ts->IsRAP = isRap ? RAP : RAP_NO;\n\t\tgf_isom_add_sample(flusher->import->dest, flusher->track, flusher->descriptionIndex, s);\n\t\tgf_isom_sample_del(&s);\n\t} else {\n\t\te = GF_BAD_PARAM;\n\t}\n\tgf_bs_del(bs);\n\treturn e;\n}\n\nstatic GF_Err swf_svg_add_iso_header(void *user, const char *data, u32 length, Bool isHeader)\n{\n\tGF_ISOFlusher\t\t*flusher = (GF_ISOFlusher *)user;\n\tif (!flusher) return GF_BAD_PARAM;\n\tif (isHeader) {\n\t\treturn gf_isom_update_stxt_description(flusher->import->dest, flusher->track, NULL, data, flusher->descriptionIndex);\n\t} else {\n\t\treturn gf_isom_append_sample_data(flusher->import->dest, flusher->track, (char *)data, length);\n\t}\n}\n\nGF_EXPORT\nGF_Err gf_text_import_swf(GF_MediaImporter *import)\n{\n\tGF_Err\t\t\t\t\t\te = GF_OK;\n\tu32\t\t\t\t\t\t\ttrack;\n\tu32\t\t\t\t\t\t\ttimescale;\n\t//u32\t\t\t\t\t\t\tduration;\n\tu32\t\t\t\t\t\t\tdescIndex;\n\tu32\t\t\t\t\t\t\tID;\n\tu32\t\t\t\t\t\t\tOCR_ES_ID;\n\tGF_GenericSubtitleConfig\t*cfg;\n\tSWFReader\t\t\t\t\t*read;\n\tGF_ISOFlusher\t\t\t\tflusher;\n\tchar\t\t\t\t\t\t*mime;\n\n\tif (import->flags & GF_IMPORT_PROBE_ONLY) {\n\t\timport->nb_tracks = 1;\n\t\treturn GF_OK;\n\t}\n\n\tcfg\t= NULL;\n\tif (import->esd) {\n\t\tif (!import->esd->slConfig)\t{\n\t\t\timport->esd->slConfig =\t(GF_SLConfig *)\tgf_odf_desc_new(GF_ODF_SLC_TAG);\n\t\t\timport->esd->slConfig->predefined =\t2;\n\t\t\timport->esd->slConfig->timestampResolution = 1000;\n\t\t}\n\t\ttimescale =\timport->esd->slConfig->timestampResolution;\n\t\tif (!timescale)\ttimescale =\t1000;\n\n\t\t/*explicit text\tconfig*/\n\t\tif (import->esd->decoderConfig && import->esd->decoderConfig->decoderSpecificInfo->tag == GF_ODF_GEN_SUB_CFG_TAG) {\n\t\t\tcfg\t= (GF_GenericSubtitleConfig\t*) import->esd->decoderConfig->decoderSpecificInfo;\n\t\t\timport->esd->decoderConfig->decoderSpecificInfo\t= NULL;\n\t\t}\n\t\tID = import->esd->ESID;\n\t\tOCR_ES_ID =\timport->esd->OCRESID;\n\t} else {\n\t\ttimescale =\t1000;\n\t\tOCR_ES_ID =\tID = 0;\n\t}\n\n\tif (cfg\t&& cfg->timescale) timescale = cfg->timescale;\n\ttrack =\tgf_isom_new_track(import->dest,\tID,\tGF_ISOM_MEDIA_TEXT,\ttimescale);\n\tif (!track)\t{\n\t\treturn gf_import_message(import, gf_isom_last_error(import->dest), \"Error creating text track\");\n\t}\n\tgf_isom_set_track_enabled(import->dest,\ttrack, 1);\n\tif (import->esd\t&& !import->esd->ESID) import->esd->ESID = gf_isom_get_track_id(import->dest, track);\n\n\tif (OCR_ES_ID) gf_isom_set_track_reference(import->dest, track,\tGF_ISOM_REF_OCR, OCR_ES_ID);\n\n\tif (!stricmp(import->streamFormat, \"SVG\")) {\n\t\tmime = \"image/svg+xml\";\n\t} else {\n\t\tmime = \"application/octet-stream\";\n\t}\n\n\tread = gf_swf_reader_new(NULL, import->in_name);\n\tgf_swf_read_header(read);\n\n\t/*setup\ttrack*/\n\tif (cfg) {\n\t\tu32\ti;\n\t\tu32\tcount;\n\t\t/*set track\tinfo*/\n\t\tgf_isom_set_track_layout_info(import->dest,\ttrack, cfg->text_width<<16,\tcfg->text_height<<16, 0, 0,\tcfg->layer);\n\n\t\t/*and set sample descriptions*/\n\t\tcount =\tgf_list_count(cfg->sample_descriptions);\n\t\tfor\t(i=0; i<count; i++)\t{\n\t\t\tgf_isom_new_stxt_description(import->dest, track, GF_ISOM_SUBTYPE_STXT, mime, NULL, NULL, &descIndex);\n\t\t}\n\t\tgf_import_message(import, GF_OK, \"SWF import - text track %d\tx %d\", cfg->text_width,\tcfg->text_height);\n\t\tgf_odf_desc_del((GF_Descriptor *)cfg);\n\t} else {\n\t\tu32\tw = (u32)read->width;\n\t\tu32\th = (u32)read->height;\n\n\t\tif (!w || !h)\n\t\t\tgf_text_get_video_size(import, &w, &h);\n\n\t\tgf_isom_set_track_layout_info(import->dest,\ttrack, w<<16, h<<16, 0,\t0, 0);\n\n\t\tgf_isom_new_stxt_description(import->dest, track, GF_ISOM_SUBTYPE_STXT, mime, NULL,\tNULL, &descIndex);\n\n\t\tgf_import_message(import, GF_OK, \"SWF import (as text - type: %s)\", import->streamFormat);\n\t}\n\tgf_text_import_set_language(import, track);\n\t//duration = (u32) (((Double) import->duration)*timescale/1000.0);\n\n\tflusher.import = import;\n\tflusher.track = track;\n\tflusher.timescale = timescale;\n\tflusher.descriptionIndex = descIndex;\n\tgf_swf_reader_set_user_mode(read, &flusher, swf_svg_add_iso_sample, swf_svg_add_iso_header);\n\n\tif (!import->streamFormat || (import->streamFormat && !stricmp(import->streamFormat, \"SVG\"))) {\n#ifndef GPAC_DISABLE_SVG\n\t\te = swf_to_svg_init(read, import->swf_flags, import->swf_flatten_angle);\n#endif\n\t} else { /*if (import->streamFormat && !strcmp(import->streamFormat, \"BIFS\"))*/\n#ifndef GPAC_DISABLE_VRML\n\t\te = swf_to_bifs_init(read);\n#endif\n\t}\n\tif (e) {\n\t\tgoto exit;\n\t}\n\t/*parse all tags*/\n\twhile (e == GF_OK) {\n\t\te = swf_parse_tag(read);\n\t}\n\tif (e==GF_EOS) e = GF_OK;\nexit:\n\tgf_swf_reader_del(read);\n\tgf_media_update_bitrate(import->dest, track);\n\treturn e;\n}\n/* end of SWF Importer */\n\n#else\n\nGF_EXPORT\nGF_Err gf_text_import_swf(GF_MediaImporter *import)\n{\n\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"Warning: GPAC was compiled without SWF import support, can't import track.\\n\"));\n\treturn GF_NOT_SUPPORTED;\n}\n\n#endif /*GPAC_DISABLE_SWF_IMPORT*/\n\nstatic GF_Err gf_text_import_sub(GF_MediaImporter *import)\n{\n\tFILE *sub_in;\n\tu32 track, ID, timescale, i, j, desc_idx, start, end, prev_end, nb_samp, duration, len, line;\n\tu64 file_size;\n\tGF_TextConfig*cfg;\n\tGF_Err e;\n\tDouble FPS;\n\tGF_TextSample * samp;\n\tBool first_samp;\n\ts32 unicode_type;\n\tchar szLine[2048], szTime[20], szText[2048];\n\tGF_ISOSample *s;\n\n\tsub_in = gf_fopen(import->in_name, \"rt\");\n\tunicode_type = gf_text_get_utf_type(sub_in);\n\tif (unicode_type<0) {\n\t\tgf_fclose(sub_in);\n\t\treturn gf_import_message(import, GF_NOT_SUPPORTED, \"Unsupported SUB UTF encoding\");\n\t}\n\n\tFPS = GF_IMPORT_DEFAULT_FPS;\n\tif (import->video_fps) FPS = import->video_fps;\n\n\tcfg = NULL;\n\tif (import->esd) {\n\t\tif (!import->esd->slConfig) {\n\t\t\timport->esd->slConfig = (GF_SLConfig *) gf_odf_desc_new(GF_ODF_SLC_TAG);\n\t\t\timport->esd->slConfig->predefined = 2;\n\t\t\timport->esd->slConfig->timestampResolution = 1000;\n\t\t}\n\t\ttimescale = import->esd->slConfig->timestampResolution;\n\t\tif (!timescale) timescale = 1000;\n\n\t\t/*explicit text config*/\n\t\tif (import->esd->decoderConfig && import->esd->decoderConfig->decoderSpecificInfo->tag == GF_ODF_TEXT_CFG_TAG) {\n\t\t\tcfg = (GF_TextConfig *) import->esd->decoderConfig->decoderSpecificInfo;\n\t\t\timport->esd->decoderConfig->decoderSpecificInfo = NULL;\n\t\t}\n\t\tID = import->esd->ESID;\n\t} else {\n\t\ttimescale = 1000;\n\t\tID = 0;\n\t}\n\n\tif (cfg && cfg->timescale) timescale = cfg->timescale;\n\ttrack = gf_isom_new_track(import->dest, ID, GF_ISOM_MEDIA_TEXT, timescale);\n\tif (!track) {\n\t\tgf_fclose(sub_in);\n\t\treturn gf_import_message(import, gf_isom_last_error(import->dest), \"Error creating text track\");\n\t}\n\tgf_isom_set_track_enabled(import->dest, track, 1);\n\tif (import->esd && !import->esd->ESID) import->esd->ESID = gf_isom_get_track_id(import->dest, track);\n\n\tgf_text_import_set_language(import, track);\n\n\tfile_size = 0;\n\t/*setup track*/\n\tif (cfg) {\n\t\tu32 count;\n\t\tchar *firstFont = NULL;\n\t\t/*set track info*/\n\t\tgf_isom_set_track_layout_info(import->dest, track, cfg->text_width<<16, cfg->text_height<<16, 0, 0, cfg->layer);\n\n\t\t/*and set sample descriptions*/\n\t\tcount = gf_list_count(cfg->sample_descriptions);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_TextSampleDescriptor *sd= (GF_TextSampleDescriptor *)gf_list_get(cfg->sample_descriptions, i);\n\t\t\tif (!sd->font_count) {\n\t\t\t\tsd->fonts = (GF_FontRecord*)gf_malloc(sizeof(GF_FontRecord));\n\t\t\t\tsd->font_count = 1;\n\t\t\t\tsd->fonts[0].fontID = 1;\n\t\t\t\tsd->fonts[0].fontName = gf_strdup(\"Serif\");\n\t\t\t}\n\t\t\tif (!sd->default_style.fontID) sd->default_style.fontID = sd->fonts[0].fontID;\n\t\t\tif (!sd->default_style.font_size) sd->default_style.font_size = 16;\n\t\t\tif (!sd->default_style.text_color) sd->default_style.text_color = 0xFF000000;\n\t\t\tfile_size = sd->default_style.font_size;\n\t\t\tgf_isom_new_text_description(import->dest, track, sd, NULL, NULL, &desc_idx);\n\t\t\tif (!firstFont) firstFont = sd->fonts[0].fontName;\n\t\t}\n\t\tgf_import_message(import, GF_OK, \"Timed Text (SUB @ %02.2f) import - text track %d x %d, font %s (size %d)\", FPS, cfg->text_width, cfg->text_height, firstFont, file_size);\n\n\t\tgf_odf_desc_del((GF_Descriptor *)cfg);\n\t} else {\n\t\tu32 w, h;\n\t\tGF_TextSampleDescriptor *sd;\n\t\tgf_text_get_video_size(import, &w, &h);\n\n\t\t/*have to work with default - use max size (if only one video, this means the text region is the\n\t\tentire display, and with bottom alignment things should be fine...*/\n\t\tgf_isom_set_track_layout_info(import->dest, track, w<<16, h<<16, 0, 0, 0);\n\t\tsd = (GF_TextSampleDescriptor*)gf_odf_desc_new(GF_ODF_TX3G_TAG);\n\t\tsd->fonts = (GF_FontRecord*)gf_malloc(sizeof(GF_FontRecord));\n\t\tsd->font_count = 1;\n\t\tsd->fonts[0].fontID = 1;\n\t\tsd->fonts[0].fontName = gf_strdup(\"Serif\");\n\t\tsd->back_color = 0x00000000;\t/*transparent*/\n\t\tsd->default_style.fontID = 1;\n\t\tsd->default_style.font_size = TTXT_DEFAULT_FONT_SIZE;\n\t\tsd->default_style.text_color = 0xFFFFFFFF;\t/*white*/\n\t\tsd->default_style.style_flags = 0;\n\t\tsd->horiz_justif = 1; /*center of scene*/\n\t\tsd->vert_justif = (s8) -1;\t/*bottom of scene*/\n\n\t\tif (import->flags & GF_IMPORT_SKIP_TXT_BOX) {\n\t\t\tsd->default_pos.top = sd->default_pos.left = sd->default_pos.right = sd->default_pos.bottom = 0;\n\t\t} else {\n\t\t\tif ((sd->default_pos.bottom==sd->default_pos.top) || (sd->default_pos.right==sd->default_pos.left)) {\n\t\t\t\tsd->default_pos.left = import->text_x;\n\t\t\t\tsd->default_pos.top = import->text_y;\n\t\t\t\tsd->default_pos.right = (import->text_width ? import->text_width : w) + sd->default_pos.left;\n\t\t\t\tsd->default_pos.bottom = (import->text_height ? import->text_height : h) + sd->default_pos.top;\n\t\t\t}\n\t\t}\n\n\t\tgf_isom_new_text_description(import->dest, track, sd, NULL, NULL, &desc_idx);\n\t\tgf_import_message(import, GF_OK, \"Timed Text (SUB @ %02.2f) import - text track %d x %d, font %s (size %d)\", FPS, w, h, sd->fonts[0].fontName, TTXT_DEFAULT_FONT_SIZE);\n\t\tgf_odf_desc_del((GF_Descriptor *)sd);\n\t}\n\n\tduration = (u32) (((Double) import->duration)*timescale/1000.0);\n\n\te = GF_OK;\n\tnb_samp = 0;\n\tsamp = gf_isom_new_text_sample();\n\n\tFPS = ((Double) timescale ) / FPS;\n\tend = prev_end = 0;\n\n\tline = 0;\n\tfirst_samp = GF_TRUE;\n\twhile (1) {\n\t\tchar *sOK = gf_text_get_utf8_line(szLine, 2048, sub_in, unicode_type);\n\t\tif (!sOK) break;\n\n\t\tREM_TRAIL_MARKS(szLine, \"\\r\\n\\t \")\n\n\t\tline++;\n\t\tlen = (u32) strlen(szLine);\n\t\tif (!len) continue;\n\n\t\ti=0;\n\t\tif (szLine[i] != '{') {\n\t\t\te = gf_import_message(import, GF_NON_COMPLIANT_BITSTREAM, \"Bad SUB file (line %d): expecting \\\"{\\\" got \\\"%c\\\"\", line, szLine[i]);\n\t\t\tgoto exit;\n\t\t}\n\t\twhile (szLine[i+1] && szLine[i+1]!='}') {\n\t\t\tszTime[i] = szLine[i+1];\n\t\t\ti++;\n\t\t}\n\t\tszTime[i] = 0;\n\t\tstart = atoi(szTime);\n\t\tif (start<end) {\n\t\t\tgf_import_message(import, GF_OK, \"WARNING: corrupted SUB frame (line %d) - starts (at %d ms) before end of previous one (%d ms) - adjusting time stamps\", line, start, end);\n\t\t\tstart = end;\n\t\t}\n\t\tj=i+2;\n\t\ti=0;\n\t\tif (szLine[i+j] != '{') {\n\t\t\te = gf_import_message(import, GF_NON_COMPLIANT_BITSTREAM, \"Bad SUB file - expecting \\\"{\\\" got \\\"%c\\\"\", szLine[i]);\n\t\t\tgoto exit;\n\t\t}\n\t\twhile (szLine[i+1+j] && szLine[i+1+j]!='}') {\n\t\t\tszTime[i] = szLine[i+1+j];\n\t\t\ti++;\n\t\t}\n\t\tszTime[i] = 0;\n\t\tend = atoi(szTime);\n\t\tj+=i+2;\n\n\t\tif (start>end) {\n\t\t\tgf_import_message(import, GF_OK, \"WARNING: corrupted SUB frame (line %d) - ends (at %d ms) before start of current frame (%d ms) - skipping\", line, end, start);\n\t\t\tcontinue;\n\t\t}\n\n\t\tgf_isom_text_reset(samp);\n\n\t\tif (start && first_samp) {\n\t\t\ts = gf_isom_text_to_sample(samp);\n\t\t\ts->DTS = 0;\n\t\t\ts->IsRAP = RAP;\n\t\t\tgf_isom_add_sample(import->dest, track, 1, s);\n\t\t\tgf_isom_sample_del(&s);\n\t\t\tfirst_samp = GF_FALSE;\n\t\t\tnb_samp++;\n\t\t}\n\n\t\tfor (i=j; i<len; i++) {\n\t\t\tif (szLine[i]=='|') {\n\t\t\t\tszText[i-j] = '\\n';\n\t\t\t} else {\n\t\t\t\tszText[i-j] = szLine[i];\n\t\t\t}\n\t\t}\n\t\tszText[i-j] = 0;\n\t\tgf_isom_text_add_text(samp, szText, (u32) strlen(szText) );\n\n\t\tif (prev_end) {\n\t\t\tGF_TextSample * empty_samp = gf_isom_new_text_sample();\n\t\t\ts = gf_isom_text_to_sample(empty_samp);\n\t\t\ts->DTS = (u64) (FPS*(s64)prev_end);\n\t\t\tgf_isom_add_sample(import->dest, track, 1, s);\n\t\t\tgf_isom_sample_del(&s);\n\t\t\tnb_samp++;\n\t\t\tgf_isom_delete_text_sample(empty_samp);\n\t\t}\n\n\t\ts = gf_isom_text_to_sample(samp);\n\t\ts->DTS = (u64) (FPS*(s64)start);\n\t\tgf_isom_add_sample(import->dest, track, 1, s);\n\t\tgf_isom_sample_del(&s);\n\t\tnb_samp++;\n\t\tgf_isom_text_reset(samp);\n\t\tprev_end = end;\n\t\tgf_set_progress(\"Importing SUB\", gf_ftell(sub_in), file_size);\n\t\tif (duration && (end >= duration)) break;\n\t}\n\t/*final flush*/\n\tif (end && !(import->flags & GF_IMPORT_NO_TEXT_FLUSH ) ) {\n\t\tgf_isom_text_reset(samp);\n\t\ts = gf_isom_text_to_sample(samp);\n\t\ts->DTS = (u64)(FPS*(s64)end);\n\t\tgf_isom_add_sample(import->dest, track, 1, s);\n\t\tgf_isom_sample_del(&s);\n\t\tnb_samp++;\n\t}\n\tgf_isom_delete_text_sample(samp);\n\t\n\tgf_isom_set_last_sample_duration(import->dest, track, 0);\n\tgf_set_progress(\"Importing SUB\", nb_samp, nb_samp);\n\nexit:\n\tif (e) gf_isom_remove_track(import->dest, track);\n\tgf_fclose(sub_in);\n\treturn e;\n}\n\n\n#define CHECK_STR(__str)\t\\\n\tif (!__str) { \\\n\t\te = gf_import_message(import, GF_BAD_PARAM, \"Invalid XML formatting (line %d)\", parser.line);\t\\\n\t\tgoto exit;\t\\\n\t}\t\\\n \n\nu32 ttxt_get_color(GF_MediaImporter *import, char *val)\n{\n\tu32 r, g, b, a, res;\n\tr = g = b = a = 0;\n\tif (sscanf(val, \"%x %x %x %x\", &r, &g, &b, &a) != 4) {\n\t\tgf_import_message(import, GF_OK, \"Warning: color badly formatted\");\n\t}\n\tres = (a&0xFF);\n\tres<<=8;\n\tres |= (r&0xFF);\n\tres<<=8;\n\tres |= (g&0xFF);\n\tres<<=8;\n\tres |= (b&0xFF);\n\treturn res;\n}\n\nvoid ttxt_parse_text_box(GF_MediaImporter *import, GF_XMLNode *n, GF_BoxRecord *box)\n{\n\tu32 i=0;\n\tGF_XMLAttribute *att;\n\tmemset(box, 0, sizeof(GF_BoxRecord));\n\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(n->attributes, &i))) {\n\t\tif (!stricmp(att->name, \"top\")) box->top = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"bottom\")) box->bottom = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"left\")) box->left = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"right\")) box->right = atoi(att->value);\n\t}\n}\n\nvoid ttxt_parse_text_style(GF_MediaImporter *import, GF_XMLNode *n, GF_StyleRecord *style)\n{\n\tu32 i=0;\n\tGF_XMLAttribute *att;\n\tmemset(style, 0, sizeof(GF_StyleRecord));\n\tstyle->fontID = 1;\n\tstyle->font_size = TTXT_DEFAULT_FONT_SIZE;\n\tstyle->text_color = 0xFFFFFFFF;\n\n\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(n->attributes, &i))) {\n\t\tif (!stricmp(att->name, \"fromChar\")) style->startCharOffset = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"toChar\")) style->endCharOffset = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"fontID\")) style->fontID = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"fontSize\")) style->font_size = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"color\")) style->text_color = ttxt_get_color(import, att->value);\n\t\telse if (!stricmp(att->name, \"styles\")) {\n\t\t\tif (strstr(att->value, \"Bold\")) style->style_flags |= GF_TXT_STYLE_BOLD;\n\t\t\tif (strstr(att->value, \"Italic\")) style->style_flags |= GF_TXT_STYLE_ITALIC;\n\t\t\tif (strstr(att->value, \"Underlined\")) style->style_flags |= GF_TXT_STYLE_UNDERLINED;\n\t\t}\n\t}\n}\n\nstatic void ttxt_import_progress(void *cbk, u64 cur_samp, u64 count)\n{\n\tgf_set_progress(\"TTXT Loading\", cur_samp, count);\n}\n\nstatic GF_Err gf_text_import_ttxt(GF_MediaImporter *import)\n{\n\tGF_Err e;\n\tBool last_sample_empty;\n\tu32 i, j, k, track, ID, nb_samples, nb_descs, nb_children;\n\tu64 last_sample_duration;\n\tGF_XMLAttribute *att;\n\tGF_DOMParser *parser;\n\tGF_XMLNode *root, *node, *ext;\n\n\tif (import->flags==GF_IMPORT_PROBE_ONLY) return GF_OK;\n\n\tparser = gf_xml_dom_new();\n\te = gf_xml_dom_parse(parser, import->in_name, ttxt_import_progress, import);\n\tif (e) {\n\t\tgf_import_message(import, e, \"Error parsing TTXT file: Line %d - %s\", gf_xml_dom_get_line(parser), gf_xml_dom_get_error(parser));\n\t\tgf_xml_dom_del(parser);\n\t\treturn e;\n\t}\n\troot = gf_xml_dom_get_root(parser);\n\n\te = GF_OK;\n\tif (strcmp(root->name, \"TextStream\")) {\n\t\te = gf_import_message(import, GF_BAD_PARAM, \"Invalid Timed Text file - expecting \\\"TextStream\\\" got %s\", \"TextStream\", root->name);\n\t\tgoto exit;\n\t}\n\n\t/*setup track in 3GP format directly (no ES desc)*/\n\tID = (import->esd) ? import->esd->ESID : 0;\n\ttrack = gf_isom_new_track(import->dest, ID, GF_ISOM_MEDIA_TEXT, 1000);\n\tif (!track) {\n\t\te = gf_isom_last_error(import->dest);\n\t\tgoto exit;\n\t}\n\tgf_isom_set_track_enabled(import->dest, track, 1);\n\t/*some MPEG-4 setup*/\n\tif (import->esd) {\n\t\tif (!import->esd->ESID) import->esd->ESID = gf_isom_get_track_id(import->dest, track);\n\t\tif (!import->esd->decoderConfig) import->esd->decoderConfig = (GF_DecoderConfig *) gf_odf_desc_new(GF_ODF_DCD_TAG);\n\t\tif (!import->esd->slConfig) import->esd->slConfig = (GF_SLConfig *) gf_odf_desc_new(GF_ODF_SLC_TAG);\n\t\timport->esd->slConfig->timestampResolution = 1000;\n\t\timport->esd->decoderConfig->streamType = GF_STREAM_TEXT;\n\t\timport->esd->decoderConfig->objectTypeIndication = GPAC_OTI_TEXT_MPEG4;\n\t\tif (import->esd->OCRESID) gf_isom_set_track_reference(import->dest, track, GF_ISOM_REF_OCR, import->esd->OCRESID);\n\t}\n\tgf_text_import_set_language(import, track);\n\n\tgf_import_message(import, GF_OK, \"Timed Text (GPAC TTXT) Import\");\n\n\tlast_sample_empty = GF_FALSE;\n\tlast_sample_duration = 0;\n\tnb_descs = 0;\n\tnb_samples = 0;\n\tnb_children = gf_list_count(root->content);\n\n\ti=0;\n\twhile ( (node = (GF_XMLNode*)gf_list_enum(root->content, &i))) {\n\t\tif (node->type) {\n\t\t\tnb_children--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strcmp(node->name, \"TextStreamHeader\")) {\n\t\t\tGF_XMLNode *sdesc;\n\t\t\ts32 w, h, tx, ty, layer;\n\t\t\tu32 tref_id;\n\t\t\tw = TTXT_DEFAULT_WIDTH;\n\t\t\th = TTXT_DEFAULT_HEIGHT;\n\t\t\ttx = ty = layer = 0;\n\t\t\tnb_children--;\n\t\t\ttref_id = 0;\n\n\t\t\tj=0;\n\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(node->attributes, &j))) {\n\t\t\t\tif (!strcmp(att->name, \"width\")) w = atoi(att->value);\n\t\t\t\telse if (!strcmp(att->name, \"height\")) h = atoi(att->value);\n\t\t\t\telse if (!strcmp(att->name, \"layer\")) layer = atoi(att->value);\n\t\t\t\telse if (!strcmp(att->name, \"translation_x\")) tx = atoi(att->value);\n\t\t\t\telse if (!strcmp(att->name, \"translation_y\")) ty = atoi(att->value);\n\t\t\t\telse if (!strcmp(att->name, \"trefID\")) tref_id = atoi(att->value);\n\t\t\t}\n\n\t\t\tif (tref_id)\n\t\t\t\tgf_isom_set_track_reference(import->dest, track, GF_ISOM_BOX_TYPE_CHAP, tref_id);\n\n\t\t\tgf_isom_set_track_layout_info(import->dest, track, w<<16, h<<16, tx<<16, ty<<16, (s16) layer);\n\n\t\t\tj=0;\n\t\t\twhile ( (sdesc=(GF_XMLNode*)gf_list_enum(node->content, &j))) {\n\t\t\t\tif (sdesc->type) continue;\n\n\t\t\t\tif (!strcmp(sdesc->name, \"TextSampleDescription\")) {\n\t\t\t\t\tGF_TextSampleDescriptor td;\n\t\t\t\t\tu32 idx;\n\t\t\t\t\tmemset(&td, 0, sizeof(GF_TextSampleDescriptor));\n\t\t\t\t\ttd.tag = GF_ODF_TEXT_CFG_TAG;\n\t\t\t\t\ttd.vert_justif = (s8) -1;\n\t\t\t\t\ttd.default_style.fontID = 1;\n\t\t\t\t\ttd.default_style.font_size = TTXT_DEFAULT_FONT_SIZE;\n\n\t\t\t\t\tk=0;\n\t\t\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(sdesc->attributes, &k))) {\n\t\t\t\t\t\tif (!strcmp(att->name, \"horizontalJustification\")) {\n\t\t\t\t\t\t\tif (!stricmp(att->value, \"center\")) td.horiz_justif = 1;\n\t\t\t\t\t\t\telse if (!stricmp(att->value, \"right\")) td.horiz_justif = (s8) -1;\n\t\t\t\t\t\t\telse if (!stricmp(att->value, \"left\")) td.horiz_justif = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (!strcmp(att->name, \"verticalJustification\")) {\n\t\t\t\t\t\t\tif (!stricmp(att->value, \"center\")) td.vert_justif = 1;\n\t\t\t\t\t\t\telse if (!stricmp(att->value, \"bottom\")) td.vert_justif = (s8) -1;\n\t\t\t\t\t\t\telse if (!stricmp(att->value, \"top\")) td.vert_justif = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (!strcmp(att->name, \"backColor\")) td.back_color = ttxt_get_color(import, att->value);\n\t\t\t\t\t\telse if (!strcmp(att->name, \"verticalText\") && !stricmp(att->value, \"yes\") ) td.displayFlags |= GF_TXT_VERTICAL;\n\t\t\t\t\t\telse if (!strcmp(att->name, \"fillTextRegion\") && !stricmp(att->value, \"yes\") ) td.displayFlags |= GF_TXT_FILL_REGION;\n\t\t\t\t\t\telse if (!strcmp(att->name, \"continuousKaraoke\") && !stricmp(att->value, \"yes\") ) td.displayFlags |= GF_TXT_KARAOKE;\n\t\t\t\t\t\telse if (!strcmp(att->name, \"scroll\")) {\n\t\t\t\t\t\t\tif (!stricmp(att->value, \"inout\")) td.displayFlags |= GF_TXT_SCROLL_IN | GF_TXT_SCROLL_OUT;\n\t\t\t\t\t\t\telse if (!stricmp(att->value, \"in\")) td.displayFlags |= GF_TXT_SCROLL_IN;\n\t\t\t\t\t\t\telse if (!stricmp(att->value, \"out\")) td.displayFlags |= GF_TXT_SCROLL_OUT;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (!strcmp(att->name, \"scrollMode\")) {\n\t\t\t\t\t\t\tu32 scroll_mode = GF_TXT_SCROLL_CREDITS;\n\t\t\t\t\t\t\tif (!stricmp(att->value, \"Credits\")) scroll_mode = GF_TXT_SCROLL_CREDITS;\n\t\t\t\t\t\t\telse if (!stricmp(att->value, \"Marquee\")) scroll_mode = GF_TXT_SCROLL_MARQUEE;\n\t\t\t\t\t\t\telse if (!stricmp(att->value, \"Right\")) scroll_mode = GF_TXT_SCROLL_RIGHT;\n\t\t\t\t\t\t\telse if (!stricmp(att->value, \"Down\")) scroll_mode = GF_TXT_SCROLL_DOWN;\n\t\t\t\t\t\t\ttd.displayFlags |= ((scroll_mode<<7) & GF_TXT_SCROLL_DIRECTION);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tk=0;\n\t\t\t\t\twhile ( (ext=(GF_XMLNode*)gf_list_enum(sdesc->content, &k))) {\n\t\t\t\t\t\tif (ext->type) continue;\n\t\t\t\t\t\tif (!strcmp(ext->name, \"TextBox\")) ttxt_parse_text_box(import, ext, &td.default_pos);\n\t\t\t\t\t\telse if (!strcmp(ext->name, \"Style\")) ttxt_parse_text_style(import, ext, &td.default_style);\n\t\t\t\t\t\telse if (!strcmp(ext->name, \"FontTable\")) {\n\t\t\t\t\t\t\tGF_XMLNode *ftable;\n\t\t\t\t\t\t\tu32 z=0;\n\t\t\t\t\t\t\twhile ( (ftable=(GF_XMLNode*)gf_list_enum(ext->content, &z))) {\n\t\t\t\t\t\t\t\tu32 m;\n\t\t\t\t\t\t\t\tif (ftable->type || strcmp(ftable->name, \"FontTableEntry\")) continue;\n\t\t\t\t\t\t\t\ttd.font_count += 1;\n\t\t\t\t\t\t\t\ttd.fonts = (GF_FontRecord*)gf_realloc(td.fonts, sizeof(GF_FontRecord)*td.font_count);\n\t\t\t\t\t\t\t\tm=0;\n\t\t\t\t\t\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(ftable->attributes, &m))) {\n\t\t\t\t\t\t\t\t\tif (!stricmp(att->name, \"fontID\")) td.fonts[td.font_count-1].fontID = atoi(att->value);\n\t\t\t\t\t\t\t\t\telse if (!stricmp(att->name, \"fontName\")) td.fonts[td.font_count-1].fontName = gf_strdup(att->value);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (import->flags & GF_IMPORT_SKIP_TXT_BOX) {\n\t\t\t\t\t\ttd.default_pos.top = td.default_pos.left = td.default_pos.right = td.default_pos.bottom = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif ((td.default_pos.bottom==td.default_pos.top) || (td.default_pos.right==td.default_pos.left)) {\n\t\t\t\t\t\t\ttd.default_pos.top = td.default_pos.left = 0;\n\t\t\t\t\t\t\ttd.default_pos.right = w;\n\t\t\t\t\t\t\ttd.default_pos.bottom = h;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!td.fonts) {\n\t\t\t\t\t\ttd.font_count = 1;\n\t\t\t\t\t\ttd.fonts = (GF_FontRecord*)gf_malloc(sizeof(GF_FontRecord));\n\t\t\t\t\t\ttd.fonts[0].fontID = 1;\n\t\t\t\t\t\ttd.fonts[0].fontName = gf_strdup(\"Serif\");\n\t\t\t\t\t}\n\t\t\t\t\tgf_isom_new_text_description(import->dest, track, &td, NULL, NULL, &idx);\n\t\t\t\t\tfor (k=0; k<td.font_count; k++) gf_free(td.fonts[k].fontName);\n\t\t\t\t\tgf_free(td.fonts);\n\t\t\t\t\tnb_descs ++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*sample text*/\n\t\telse if (!strcmp(node->name, \"TextSample\")) {\n\t\t\tGF_ISOSample *s;\n\t\t\tGF_TextSample * samp;\n\t\t\tu32 ts, descIndex;\n\t\t\tBool has_text = GF_FALSE;\n\t\t\tif (!nb_descs) {\n\t\t\t\te = gf_import_message(import, GF_BAD_PARAM, \"Invalid Timed Text file - text stream header not found or empty\");\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tsamp = gf_isom_new_text_sample();\n\t\t\tts = 0;\n\t\t\tdescIndex = 1;\n\t\t\tlast_sample_empty = GF_TRUE;\n\n\t\t\tj=0;\n\t\t\twhile ( (att=(GF_XMLAttribute*)gf_list_enum(node->attributes, &j))) {\n\t\t\t\tif (!strcmp(att->name, \"sampleTime\")) {\n\t\t\t\t\tu32 h, m, s, ms;\n\t\t\t\t\tif (sscanf(att->value, \"%u:%u:%u.%u\", &h, &m, &s, &ms) == 4) {\n\t\t\t\t\t\tts = (h*3600 + m*60 + s)*1000 + ms;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tts = (u32) (atof(att->value) * 1000);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (!strcmp(att->name, \"sampleDescriptionIndex\")) descIndex = atoi(att->value);\n\t\t\t\telse if (!strcmp(att->name, \"text\")) {\n\t\t\t\t\tu32 len;\n\t\t\t\t\tchar *str = ttxt_parse_string(import, att->value, GF_TRUE);\n\t\t\t\t\tlen = (u32) strlen(str);\n\t\t\t\t\tgf_isom_text_add_text(samp, str, len);\n\t\t\t\t\tlast_sample_empty = len ? GF_FALSE : GF_TRUE;\n\t\t\t\t\thas_text = GF_TRUE;\n\t\t\t\t}\n\t\t\t\telse if (!strcmp(att->name, \"scrollDelay\")) gf_isom_text_set_scroll_delay(samp, (u32) (1000*atoi(att->value)));\n\t\t\t\telse if (!strcmp(att->name, \"highlightColor\")) gf_isom_text_set_highlight_color_argb(samp, ttxt_get_color(import, att->value));\n\t\t\t\telse if (!strcmp(att->name, \"wrap\") && !strcmp(att->value, \"Automatic\")) gf_isom_text_set_wrap(samp, 0x01);\n\t\t\t}\n\n\t\t\t/*get all modifiers*/\n\t\t\tj=0;\n\t\t\twhile ( (ext=(GF_XMLNode*)gf_list_enum(node->content, &j))) {\n\t\t\t\tif (!has_text && (ext->type==GF_XML_TEXT_TYPE)) {\n\t\t\t\t\tu32 len;\n\t\t\t\t\tchar *str = ttxt_parse_string(import, ext->name, GF_FALSE);\n\t\t\t\t\tlen = (u32) strlen(str);\n\t\t\t\t\tgf_isom_text_add_text(samp, str, len);\n\t\t\t\t\tlast_sample_empty = len ? GF_FALSE : GF_TRUE;\n\t\t\t\t\thas_text = GF_TRUE;\n\t\t\t\t}\n\t\t\t\tif (ext->type) continue;\n\n\t\t\t\tif (!stricmp(ext->name, \"Style\")) {\n\t\t\t\t\tGF_StyleRecord r;\n\t\t\t\t\tttxt_parse_text_style(import, ext, &r);\n\t\t\t\t\tgf_isom_text_add_style(samp, &r);\n\t\t\t\t}\n\t\t\t\telse if (!stricmp(ext->name, \"TextBox\")) {\n\t\t\t\t\tGF_BoxRecord r;\n\t\t\t\t\tttxt_parse_text_box(import, ext, &r);\n\t\t\t\t\tgf_isom_text_set_box(samp, r.top, r.left, r.bottom, r.right);\n\t\t\t\t}\n\t\t\t\telse if (!stricmp(ext->name, \"Highlight\")) {\n\t\t\t\t\tu16 start, end;\n\t\t\t\t\tstart = end = 0;\n\t\t\t\t\tk=0;\n\t\t\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(ext->attributes, &k))) {\n\t\t\t\t\t\tif (!strcmp(att->name, \"fromChar\")) start = atoi(att->value);\n\t\t\t\t\t\telse if (!strcmp(att->name, \"toChar\")) end = atoi(att->value);\n\t\t\t\t\t}\n\t\t\t\t\tgf_isom_text_add_highlight(samp, start, end);\n\t\t\t\t}\n\t\t\t\telse if (!stricmp(ext->name, \"Blinking\")) {\n\t\t\t\t\tu16 start, end;\n\t\t\t\t\tstart = end = 0;\n\t\t\t\t\tk=0;\n\t\t\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(ext->attributes, &k))) {\n\t\t\t\t\t\tif (!strcmp(att->name, \"fromChar\")) start = atoi(att->value);\n\t\t\t\t\t\telse if (!strcmp(att->name, \"toChar\")) end = atoi(att->value);\n\t\t\t\t\t}\n\t\t\t\t\tgf_isom_text_add_blink(samp, start, end);\n\t\t\t\t}\n\t\t\t\telse if (!stricmp(ext->name, \"HyperLink\")) {\n\t\t\t\t\tu16 start, end;\n\t\t\t\t\tchar *url, *url_tt;\n\t\t\t\t\tstart = end = 0;\n\t\t\t\t\turl = url_tt = NULL;\n\t\t\t\t\tk=0;\n\t\t\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(ext->attributes, &k))) {\n\t\t\t\t\t\tif (!strcmp(att->name, \"fromChar\")) start = atoi(att->value);\n\t\t\t\t\t\telse if (!strcmp(att->name, \"toChar\")) end = atoi(att->value);\n\t\t\t\t\t\telse if (!strcmp(att->name, \"URL\")) url = gf_strdup(att->value);\n\t\t\t\t\t\telse if (!strcmp(att->name, \"URLToolTip\")) url_tt = gf_strdup(att->value);\n\t\t\t\t\t}\n\t\t\t\t\tgf_isom_text_add_hyperlink(samp, url, url_tt, start, end);\n\t\t\t\t\tif (url) gf_free(url);\n\t\t\t\t\tif (url_tt) gf_free(url_tt);\n\t\t\t\t}\n\t\t\t\telse if (!stricmp(ext->name, \"Karaoke\")) {\n\t\t\t\t\tu32 startTime;\n\t\t\t\t\tGF_XMLNode *krok;\n\t\t\t\t\tstartTime = 0;\n\t\t\t\t\tk=0;\n\t\t\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(ext->attributes, &k))) {\n\t\t\t\t\t\tif (!strcmp(att->name, \"startTime\")) startTime = (u32) (1000*atof(att->value));\n\t\t\t\t\t}\n\t\t\t\t\tgf_isom_text_add_karaoke(samp, startTime);\n\t\t\t\t\tk=0;\n\t\t\t\t\twhile ( (krok=(GF_XMLNode*)gf_list_enum(ext->content, &k))) {\n\t\t\t\t\t\tu16 start, end;\n\t\t\t\t\t\tu32 endTime, m;\n\t\t\t\t\t\tif (krok->type) continue;\n\t\t\t\t\t\tif (strcmp(krok->name, \"KaraokeRange\")) continue;\n\t\t\t\t\t\tstart = end = 0;\n\t\t\t\t\t\tendTime = 0;\n\t\t\t\t\t\tm=0;\n\t\t\t\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(krok->attributes, &m))) {\n\t\t\t\t\t\t\tif (!strcmp(att->name, \"fromChar\")) start = atoi(att->value);\n\t\t\t\t\t\t\telse if (!strcmp(att->name, \"toChar\")) end = atoi(att->value);\n\t\t\t\t\t\t\telse if (!strcmp(att->name, \"endTime\")) endTime = (u32) (1000*atof(att->value));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgf_isom_text_set_karaoke_segment(samp, endTime, start, end);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*in MP4 we must start at T=0, so add an empty sample*/\n\t\t\tif (ts && !nb_samples) {\n\t\t\t\tGF_TextSample * firstsamp = gf_isom_new_text_sample();\n\t\t\t\ts = gf_isom_text_to_sample(firstsamp);\n\t\t\t\ts->DTS = 0;\n\t\t\t\tgf_isom_add_sample(import->dest, track, 1, s);\n\t\t\t\tnb_samples++;\n\t\t\t\tgf_isom_delete_text_sample(firstsamp);\n\t\t\t\tgf_isom_sample_del(&s);\n\t\t\t}\n\n\t\t\ts = gf_isom_text_to_sample(samp);\n\t\t\tgf_isom_delete_text_sample(samp);\n\t\t\ts->DTS = ts;\n\t\t\tif (last_sample_empty) {\n\t\t\t\tlast_sample_duration = s->DTS - last_sample_duration;\n\t\t\t} else {\n\t\t\t\tlast_sample_duration = s->DTS;\n\t\t\t}\n\n\t\t\te = gf_isom_add_sample(import->dest, track, descIndex, s);\n\t\t\tif (e) goto exit;\n\t\t\tgf_isom_sample_del(&s);\n\t\t\tnb_samples++;\n\n\t\t\tgf_set_progress(\"Importing TTXT\", nb_samples, nb_children);\n\t\t\tif (import->duration && (ts>import->duration)) break;\n\t\t}\n\t}\n\tif (last_sample_empty) {\n\t\tgf_isom_remove_sample(import->dest, track, nb_samples);\n\t\tgf_isom_set_last_sample_duration(import->dest, track, (u32) last_sample_duration);\n\t}\n\tgf_set_progress(\"Importing TTXT\", nb_samples, nb_samples);\n\nexit:\n\tgf_xml_dom_del(parser);\n\treturn e;\n}\n\n\nu32 tx3g_get_color(GF_MediaImporter *import, char *value)\n{\n\tu32 r, g, b, a;\n\tu32 res, v;\n\tr = g = b = a = 0;\n\tif (sscanf(value, \"%u%%, %u%%, %u%%, %u%%\", &r, &g, &b, &a) != 4) {\n\t\tgf_import_message(import, GF_OK, \"Warning: color badly formatted\");\n\t}\n\tv = (u32) (a*255/100);\n\tres = (v&0xFF);\n\tres<<=8;\n\tv = (u32) (r*255/100);\n\tres |= (v&0xFF);\n\tres<<=8;\n\tv = (u32) (g*255/100);\n\tres |= (v&0xFF);\n\tres<<=8;\n\tv = (u32) (b*255/100);\n\tres |= (v&0xFF);\n\treturn res;\n}\n\nvoid tx3g_parse_text_box(GF_MediaImporter *import, GF_XMLNode *n, GF_BoxRecord *box)\n{\n\tu32 i=0;\n\tGF_XMLAttribute *att;\n\tmemset(box, 0, sizeof(GF_BoxRecord));\n\twhile ((att=(GF_XMLAttribute *)gf_list_enum(n->attributes, &i))) {\n\t\tif (!stricmp(att->name, \"x\")) box->left = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"y\")) box->top = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"height\")) box->bottom = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"width\")) box->right = atoi(att->value);\n\t}\n}\n\ntypedef struct\n{\n\tu32 id;\n\tu32 pos;\n} Marker;\n\n#define GET_MARKER_POS(_val, __isend) \\\n\t{\t\\\n\t\tu32 i, __m = atoi(att->value);\t\\\n\t\t_val = 0;\t\\\n\t\tfor (i=0; i<nb_marks; i++) { if (__m==marks[i].id) { _val = marks[i].pos; /*if (__isend) _val--; */break; } }\t \\\n\t}\n\n\nstatic void texml_import_progress(void *cbk, u64 cur_samp, u64 count)\n{\n\tgf_set_progress(\"TeXML Loading\", cur_samp, count);\n}\n\nstatic GF_Err gf_text_import_texml(GF_MediaImporter *import)\n{\n\tGF_Err e;\n\tu32 track, ID, nb_samples, nb_children, nb_descs, timescale, w, h, i, j, k;\n\tu64 DTS;\n\ts32 tx, ty, layer;\n\tGF_StyleRecord styles[50];\n\tMarker marks[50];\n\tGF_XMLAttribute *att;\n\tGF_DOMParser *parser;\n\tGF_XMLNode *root, *node;\n\n\tif (import->flags==GF_IMPORT_PROBE_ONLY) return GF_OK;\n\n\tparser = gf_xml_dom_new();\n\te = gf_xml_dom_parse(parser, import->in_name, texml_import_progress, import);\n\tif (e) {\n\t\tgf_import_message(import, e, \"Error parsing TeXML file: Line %d - %s\", gf_xml_dom_get_line(parser), gf_xml_dom_get_error(parser));\n\t\tgf_xml_dom_del(parser);\n\t\treturn e;\n\t}\n\troot = gf_xml_dom_get_root(parser);\n\n\tif (strcmp(root->name, \"text3GTrack\")) {\n\t\te = gf_import_message(import, GF_BAD_PARAM, \"Invalid QT TeXML file - expecting root \\\"text3GTrack\\\" got \\\"%s\\\"\", root->name);\n\t\tgoto exit;\n\t}\n\tw = TTXT_DEFAULT_WIDTH;\n\th = TTXT_DEFAULT_HEIGHT;\n\ttx = ty = 0;\n\tlayer = 0;\n\ttimescale = 1000;\n\ti=0;\n\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(root->attributes, &i))) {\n\t\tif (!strcmp(att->name, \"trackWidth\")) w = atoi(att->value);\n\t\telse if (!strcmp(att->name, \"trackHeight\")) h = atoi(att->value);\n\t\telse if (!strcmp(att->name, \"layer\")) layer = atoi(att->value);\n\t\telse if (!strcmp(att->name, \"timescale\")) timescale = atoi(att->value);\n\t\telse if (!strcmp(att->name, \"transform\")) {\n\t\t\tFloat fx, fy;\n\t\t\tsscanf(att->value, \"translate(%f,%f)\", &fx, &fy);\n\t\t\ttx = (u32) fx;\n\t\t\tty = (u32) fy;\n\t\t}\n\t}\n\n\t/*setup track in 3GP format directly (no ES desc)*/\n\tID = (import->esd) ? import->esd->ESID : 0;\n\ttrack = gf_isom_new_track(import->dest, ID, GF_ISOM_MEDIA_TEXT, timescale);\n\tif (!track) {\n\t\te = gf_isom_last_error(import->dest);\n\t\tgoto exit;\n\t}\n\tgf_isom_set_track_enabled(import->dest, track, 1);\n\t/*some MPEG-4 setup*/\n\tif (import->esd) {\n\t\tif (!import->esd->ESID) import->esd->ESID = gf_isom_get_track_id(import->dest, track);\n\t\tif (!import->esd->decoderConfig) import->esd->decoderConfig = (GF_DecoderConfig *) gf_odf_desc_new(GF_ODF_DCD_TAG);\n\t\tif (!import->esd->slConfig) import->esd->slConfig = (GF_SLConfig *) gf_odf_desc_new(GF_ODF_SLC_TAG);\n\t\timport->esd->slConfig->timestampResolution = timescale;\n\t\timport->esd->decoderConfig->streamType = GF_STREAM_TEXT;\n\t\timport->esd->decoderConfig->objectTypeIndication = GPAC_OTI_TEXT_MPEG4;\n\t\tif (import->esd->OCRESID) gf_isom_set_track_reference(import->dest, track, GF_ISOM_REF_OCR, import->esd->OCRESID);\n\t}\n\tDTS = 0;\n\tgf_isom_set_track_layout_info(import->dest, track, w<<16, h<<16, tx<<16, ty<<16, (s16) layer);\n\n\tgf_text_import_set_language(import, track);\n\te = GF_OK;\n\n\tgf_import_message(import, GF_OK, \"Timed Text (QT TeXML) Import - Track Size %d x %d\", w, h);\n\n\tnb_children = gf_list_count(root->content);\n\tnb_descs = 0;\n\tnb_samples = 0;\n\ti=0;\n\twhile ( (node=(GF_XMLNode*)gf_list_enum(root->content, &i))) {\n\t\tGF_XMLNode *desc;\n\t\tGF_TextSampleDescriptor td;\n\t\tGF_TextSample * samp = NULL;\n\t\tGF_ISOSample *s;\n\t\tu32 duration, descIndex, nb_styles, nb_marks;\n\t\tBool isRAP, same_style, same_box;\n\n\t\tif (node->type) continue;\n\t\tif (strcmp(node->name, \"sample\")) continue;\n\n\t\tisRAP = GF_FALSE;\n\t\tduration = 1000;\n\t\tj=0;\n\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(node->attributes, &j))) {\n\t\t\tif (!strcmp(att->name, \"duration\")) duration = atoi(att->value);\n\t\t\telse if (!strcmp(att->name, \"keyframe\")) isRAP = (!stricmp(att->value, \"true\") ? GF_TRUE : GF_FALSE);\n\t\t}\n\t\tnb_styles = 0;\n\t\tnb_marks = 0;\n\t\tsame_style = same_box = GF_FALSE;\n\t\tdescIndex = 1;\n\t\tj=0;\n\t\twhile ((desc=(GF_XMLNode*)gf_list_enum(node->content, &j))) {\n\t\t\tif (desc->type) continue;\n\n\t\t\tif (!strcmp(desc->name, \"description\")) {\n\t\t\t\tGF_XMLNode *sub;\n\t\t\t\tmemset(&td, 0, sizeof(GF_TextSampleDescriptor));\n\t\t\t\ttd.tag = GF_ODF_TEXT_CFG_TAG;\n\t\t\t\ttd.vert_justif = (s8) -1;\n\t\t\t\ttd.default_style.fontID = 1;\n\t\t\t\ttd.default_style.font_size = TTXT_DEFAULT_FONT_SIZE;\n\n\t\t\t\tk=0;\n\t\t\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(desc->attributes, &k))) {\n\t\t\t\t\tif (!strcmp(att->name, \"horizontalJustification\")) {\n\t\t\t\t\t\tif (!stricmp(att->value, \"center\")) td.horiz_justif = 1;\n\t\t\t\t\t\telse if (!stricmp(att->value, \"right\")) td.horiz_justif = (s8) -1;\n\t\t\t\t\t\telse if (!stricmp(att->value, \"left\")) td.horiz_justif = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse if (!strcmp(att->name, \"verticalJustification\")) {\n\t\t\t\t\t\tif (!stricmp(att->value, \"center\")) td.vert_justif = 1;\n\t\t\t\t\t\telse if (!stricmp(att->value, \"bottom\")) td.vert_justif = (s8) -1;\n\t\t\t\t\t\telse if (!stricmp(att->value, \"top\")) td.vert_justif = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse if (!strcmp(att->name, \"backgroundColor\")) td.back_color = tx3g_get_color(import, att->value);\n\t\t\t\t\telse if (!strcmp(att->name, \"displayFlags\")) {\n\t\t\t\t\t\tBool rev_scroll = GF_FALSE;\n\t\t\t\t\t\tif (strstr(att->value, \"scroll\")) {\n\t\t\t\t\t\t\tu32 scroll_mode = 0;\n\t\t\t\t\t\t\tif (strstr(att->value, \"scrollIn\")) td.displayFlags |= GF_TXT_SCROLL_IN;\n\t\t\t\t\t\t\tif (strstr(att->value, \"scrollOut\")) td.displayFlags |= GF_TXT_SCROLL_OUT;\n\t\t\t\t\t\t\tif (strstr(att->value, \"reverse\")) rev_scroll = GF_TRUE;\n\t\t\t\t\t\t\tif (strstr(att->value, \"horizontal\")) scroll_mode = rev_scroll ? GF_TXT_SCROLL_RIGHT : GF_TXT_SCROLL_MARQUEE;\n\t\t\t\t\t\t\telse scroll_mode = (rev_scroll ? GF_TXT_SCROLL_DOWN : GF_TXT_SCROLL_CREDITS);\n\t\t\t\t\t\t\ttd.displayFlags |= (scroll_mode<<7) & GF_TXT_SCROLL_DIRECTION;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/*TODO FIXME: check in QT doc !!*/\n\t\t\t\t\t\tif (strstr(att->value, \"writeTextVertically\")) td.displayFlags |= GF_TXT_VERTICAL;\n\t\t\t\t\t\tif (!strcmp(att->name, \"continuousKaraoke\")) td.displayFlags |= GF_TXT_KARAOKE;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tk=0;\n\t\t\t\twhile ((sub=(GF_XMLNode*)gf_list_enum(desc->content, &k))) {\n\t\t\t\t\tif (sub->type) continue;\n\t\t\t\t\tif (!strcmp(sub->name, \"defaultTextBox\")) tx3g_parse_text_box(import, sub, &td.default_pos);\n\t\t\t\t\telse if (!strcmp(sub->name, \"fontTable\")) {\n\t\t\t\t\t\tGF_XMLNode *ftable;\n\t\t\t\t\t\tu32 m=0;\n\t\t\t\t\t\twhile ((ftable=(GF_XMLNode*)gf_list_enum(sub->content, &m))) {\n\t\t\t\t\t\t\tif (ftable->type) continue;\n\t\t\t\t\t\t\tif (!strcmp(ftable->name, \"font\")) {\n\t\t\t\t\t\t\t\tu32 n=0;\n\t\t\t\t\t\t\t\ttd.font_count += 1;\n\t\t\t\t\t\t\t\ttd.fonts = (GF_FontRecord*)gf_realloc(td.fonts, sizeof(GF_FontRecord)*td.font_count);\n\t\t\t\t\t\t\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(ftable->attributes, &n))) {\n\t\t\t\t\t\t\t\t\tif (!stricmp(att->name, \"id\")) td.fonts[td.font_count-1].fontID = atoi(att->value);\n\t\t\t\t\t\t\t\t\telse if (!stricmp(att->name, \"name\")) td.fonts[td.font_count-1].fontName = gf_strdup(att->value);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (!strcmp(sub->name, \"sharedStyles\")) {\n\t\t\t\t\t\tGF_XMLNode *style, *ftable;\n\t\t\t\t\t\tu32 m=0;\n\t\t\t\t\t\twhile ((style=(GF_XMLNode*)gf_list_enum(sub->content, &m))) {\n\t\t\t\t\t\t\tif (style->type) continue;\n\t\t\t\t\t\t\tif (!strcmp(style->name, \"style\")) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (style) {\n\t\t\t\t\t\t\tchar *cur;\n\t\t\t\t\t\t\ts32 start=0;\n\t\t\t\t\t\t\tchar css_style[1024], css_val[1024];\n\t\t\t\t\t\t\tmemset(&styles[nb_styles], 0, sizeof(GF_StyleRecord));\n\t\t\t\t\t\t\tm=0;\n\t\t\t\t\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(style->attributes, &m))) {\n\t\t\t\t\t\t\t\tif (!strcmp(att->name, \"id\")) styles[nb_styles].startCharOffset = atoi(att->value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tm=0;\n\t\t\t\t\t\t\twhile ( (ftable=(GF_XMLNode*)gf_list_enum(style->content, &m))) {\n\t\t\t\t\t\t\t\tif (ftable->type) break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcur = ftable->name;\n\t\t\t\t\t\t\twhile (cur) {\n\t\t\t\t\t\t\t\tstart = gf_token_get_strip(cur, 0, \"{:\", \" \", css_style, 1024);\n\t\t\t\t\t\t\t\tif (start <0) break;\n\t\t\t\t\t\t\t\tstart = gf_token_get_strip(cur, start, \":}\", \" \", css_val, 1024);\n\t\t\t\t\t\t\t\tif (start <0) break;\n\t\t\t\t\t\t\t\tcur = strchr(cur+start, '{');\n\n\t\t\t\t\t\t\t\tif (!strcmp(css_style, \"font-table\")) {\n\t\t\t\t\t\t\t\t\tu32 z;\n\t\t\t\t\t\t\t\t\tstyles[nb_styles].fontID = atoi(css_val);\n\t\t\t\t\t\t\t\t\tfor (z=0; z<td.font_count; z++) {\n\t\t\t\t\t\t\t\t\t\tif (td.fonts[z].fontID == styles[nb_styles].fontID)\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if (!strcmp(css_style, \"font-size\")) styles[nb_styles].font_size = atoi(css_val);\n\t\t\t\t\t\t\t\telse if (!strcmp(css_style, \"font-style\") && !strcmp(css_val, \"italic\")) styles[nb_styles].style_flags |= GF_TXT_STYLE_ITALIC;\n\t\t\t\t\t\t\t\telse if (!strcmp(css_style, \"font-weight\") && !strcmp(css_val, \"bold\")) styles[nb_styles].style_flags |= GF_TXT_STYLE_BOLD;\n\t\t\t\t\t\t\t\telse if (!strcmp(css_style, \"text-decoration\") && !strcmp(css_val, \"underline\")) styles[nb_styles].style_flags |= GF_TXT_STYLE_UNDERLINED;\n\t\t\t\t\t\t\t\telse if (!strcmp(css_style, \"color\")) styles[nb_styles].text_color = tx3g_get_color(import, css_val);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!nb_styles) td.default_style = styles[0];\n\t\t\t\t\t\t\tnb_styles++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tif ((td.default_pos.bottom==td.default_pos.top) || (td.default_pos.right==td.default_pos.left)) {\n\t\t\t\t\ttd.default_pos.top = td.default_pos.left = 0;\n\t\t\t\t\ttd.default_pos.right = w;\n\t\t\t\t\ttd.default_pos.bottom = h;\n\t\t\t\t}\n\t\t\t\tif (!td.fonts) {\n\t\t\t\t\ttd.font_count = 1;\n\t\t\t\t\ttd.fonts = (GF_FontRecord*)gf_malloc(sizeof(GF_FontRecord));\n\t\t\t\t\ttd.fonts[0].fontID = 1;\n\t\t\t\t\ttd.fonts[0].fontName = gf_strdup(\"Serif\");\n\t\t\t\t}\n\t\t\t\tgf_isom_text_has_similar_description(import->dest, track, &td, &descIndex, &same_box, &same_style);\n\t\t\t\tif (!descIndex) {\n\t\t\t\t\tgf_isom_new_text_description(import->dest, track, &td, NULL, NULL, &descIndex);\n\t\t\t\t\tsame_style = same_box = GF_TRUE;\n\t\t\t\t}\n\n\t\t\t\tfor (k=0; k<td.font_count; k++) gf_free(td.fonts[k].fontName);\n\t\t\t\tgf_free(td.fonts);\n\t\t\t\tnb_descs ++;\n\t\t\t}\n\t\t\telse if (!strcmp(desc->name, \"sampleData\")) {\n\t\t\t\tGF_XMLNode *sub;\n\t\t\t\tu16 start, end;\n\t\t\t\tu32 styleID;\n\t\t\t\tu32 nb_chars, txt_len, m;\n\t\t\t\tnb_chars = 0;\n\n\t\t\t\tsamp = gf_isom_new_text_sample();\n\n\t\t\t\tk=0;\n\t\t\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(desc->attributes, &k))) {\n\t\t\t\t\tif (!strcmp(att->name, \"targetEncoding\") && !strcmp(att->value, \"utf16\")) ;//is_utf16 = 1;\n\t\t\t\t\telse if (!strcmp(att->name, \"scrollDelay\")) gf_isom_text_set_scroll_delay(samp, atoi(att->value) );\n\t\t\t\t\telse if (!strcmp(att->name, \"highlightColor\")) gf_isom_text_set_highlight_color_argb(samp, tx3g_get_color(import, att->value));\n\t\t\t\t}\n\t\t\t\tstart = end = 0;\n\t\t\t\tk=0;\n\t\t\t\twhile ((sub=(GF_XMLNode*)gf_list_enum(desc->content, &k))) {\n\t\t\t\t\tif (sub->type) continue;\n\t\t\t\t\tif (!strcmp(sub->name, \"text\")) {\n\t\t\t\t\t\tGF_XMLNode *text;\n\t\t\t\t\t\tstyleID = 0;\n\t\t\t\t\t\tm=0;\n\t\t\t\t\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(sub->attributes, &m))) {\n\t\t\t\t\t\t\tif (!strcmp(att->name, \"styleID\")) styleID = atoi(att->value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttxt_len = 0;\n\n\t\t\t\t\t\tm=0;\n\t\t\t\t\t\twhile ((text=(GF_XMLNode*)gf_list_enum(sub->content, &m))) {\n\t\t\t\t\t\t\tif (!text->type) {\n\t\t\t\t\t\t\t\tif (!strcmp(text->name, \"marker\")) {\n\t\t\t\t\t\t\t\t\tu32 z;\n\t\t\t\t\t\t\t\t\tmemset(&marks[nb_marks], 0, sizeof(Marker));\n\t\t\t\t\t\t\t\t\tmarks[nb_marks].pos = nb_chars+txt_len;\n\n\t\t\t\t\t\t\t\t\tz = 0;\n\t\t\t\t\t\t\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(text->attributes, &z))) {\n\t\t\t\t\t\t\t\t\t\tif (!strcmp(att->name, \"id\")) marks[nb_marks].id = atoi(att->value);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tnb_marks++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (text->type==GF_XML_TEXT_TYPE) {\n\t\t\t\t\t\t\t\ttxt_len += (u32) strlen(text->name);\n\t\t\t\t\t\t\t\tgf_isom_text_add_text(samp, text->name, (u32) strlen(text->name));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (styleID && (!same_style || (td.default_style.startCharOffset != styleID))) {\n\t\t\t\t\t\t\tGF_StyleRecord st = td.default_style;\n\t\t\t\t\t\t\tfor (m=0; m<nb_styles; m++) {\n\t\t\t\t\t\t\t\tif (styles[m].startCharOffset==styleID) {\n\t\t\t\t\t\t\t\t\tst = styles[m];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tst.startCharOffset = nb_chars;\n\t\t\t\t\t\t\tst.endCharOffset = nb_chars + txt_len;\n\t\t\t\t\t\t\tgf_isom_text_add_style(samp, &st);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnb_chars += txt_len;\n\t\t\t\t\t}\n\t\t\t\t\telse if (!stricmp(sub->name, \"highlight\")) {\n\t\t\t\t\t\tm=0;\n\t\t\t\t\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(sub->attributes, &m))) {\n\t\t\t\t\t\t\tif (!strcmp(att->name, \"startMarker\")) GET_MARKER_POS(start, 0)\n\t\t\t\t\t\t\t\telse if (!strcmp(att->name, \"endMarker\")) GET_MARKER_POS(end, 1)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\tgf_isom_text_add_highlight(samp, start, end);\n\t\t\t\t\t}\n\t\t\t\t\telse if (!stricmp(sub->name, \"blink\")) {\n\t\t\t\t\t\tm=0;\n\t\t\t\t\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(sub->attributes, &m))) {\n\t\t\t\t\t\t\tif (!strcmp(att->name, \"startMarker\")) GET_MARKER_POS(start, 0)\n\t\t\t\t\t\t\t\telse if (!strcmp(att->name, \"endMarker\")) GET_MARKER_POS(end, 1)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\tgf_isom_text_add_blink(samp, start, end);\n\t\t\t\t\t}\n\t\t\t\t\telse if (!stricmp(sub->name, \"link\")) {\n\t\t\t\t\t\tchar *url, *url_tt;\n\t\t\t\t\t\turl = url_tt = NULL;\n\t\t\t\t\t\tm=0;\n\t\t\t\t\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(sub->attributes, &m))) {\n\t\t\t\t\t\t\tif (!strcmp(att->name, \"startMarker\")) GET_MARKER_POS(start, 0)\n\t\t\t\t\t\t\t\telse if (!strcmp(att->name, \"endMarker\")) GET_MARKER_POS(end, 1)\n\t\t\t\t\t\t\t\t\telse if (!strcmp(att->name, \"URL\") || !strcmp(att->name, \"href\")) url = gf_strdup(att->value);\n\t\t\t\t\t\t\t\t\telse if (!strcmp(att->name, \"URLToolTip\") || !strcmp(att->name, \"altString\")) url_tt = gf_strdup(att->value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgf_isom_text_add_hyperlink(samp, url, url_tt, start, end);\n\t\t\t\t\t\tif (url) gf_free(url);\n\t\t\t\t\t\tif (url_tt) gf_free(url_tt);\n\t\t\t\t\t}\n\t\t\t\t\telse if (!stricmp(sub->name, \"karaoke\")) {\n\t\t\t\t\t\tu32 time = 0;\n\t\t\t\t\t\tGF_XMLNode *krok;\n\t\t\t\t\t\tm=0;\n\t\t\t\t\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(sub->attributes, &m))) {\n\t\t\t\t\t\t\tif (!strcmp(att->name, \"startTime\")) time = atoi(att->value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgf_isom_text_add_karaoke(samp, time);\n\t\t\t\t\t\tm=0;\n\t\t\t\t\t\twhile ((krok=(GF_XMLNode*)gf_list_enum(sub->content, &m))) {\n\t\t\t\t\t\t\tu32 u=0;\n\t\t\t\t\t\t\tif (krok->type) continue;\n\t\t\t\t\t\t\tif (strcmp(krok->name, \"run\")) continue;\n\t\t\t\t\t\t\tstart = end = 0;\n\t\t\t\t\t\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(krok->attributes, &u))) {\n\t\t\t\t\t\t\t\tif (!strcmp(att->name, \"startMarker\")) GET_MARKER_POS(start, 0)\n\t\t\t\t\t\t\t\t\telse if (!strcmp(att->name, \"endMarker\")) GET_MARKER_POS(end, 1)\n\t\t\t\t\t\t\t\t\t\telse if (!strcmp(att->name, \"duration\")) time += atoi(att->value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tgf_isom_text_set_karaoke_segment(samp, time, start, end);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*OK, let's add the sample*/\n\t\tif (samp) {\n\t\t\tif (!same_box) gf_isom_text_set_box(samp, td.default_pos.top, td.default_pos.left, td.default_pos.bottom, td.default_pos.right);\n//\t\t\tif (!same_style) gf_isom_text_add_style(samp, &td.default_style);\n\n\t\t\ts = gf_isom_text_to_sample(samp);\n\t\t\tgf_isom_delete_text_sample(samp);\n\t\t\ts->IsRAP = isRAP ? RAP : RAP_NO;\n\t\t\ts->DTS = DTS;\n\t\t\tgf_isom_add_sample(import->dest, track, descIndex, s);\n\t\t\tgf_isom_sample_del(&s);\n\t\t\tnb_samples++;\n\t\t\tDTS += duration;\n\t\t\tgf_set_progress(\"Importing TeXML\", nb_samples, nb_children);\n\t\t\tif (import->duration && (DTS*1000> timescale*import->duration)) break;\n\t\t}\n\t}\n\tgf_isom_set_last_sample_duration(import->dest, track, 0);\n\tgf_set_progress(\"Importing TeXML\", nb_samples, nb_samples);\n\nexit:\n\tgf_xml_dom_del(parser);\n\treturn e;\n}\n\n\nGF_Err gf_import_timed_text(GF_MediaImporter *import)\n{\n\tGF_Err e;\n\tu32 fmt;\n\te = gf_text_guess_format(import->in_name, &fmt);\n\tif (e) return e;\n\tif (import->streamFormat) {\n\t\tif (!strcmp(import->streamFormat, \"VTT\")) fmt = GF_TEXT_IMPORT_WEBVTT;\n\t\telse if (!strcmp(import->streamFormat, \"TTML\")) fmt = GF_TEXT_IMPORT_TTML;\n\t\tif ((strstr(import->in_name, \".swf\") || strstr(import->in_name, \".SWF\")) && !stricmp(import->streamFormat, \"SVG\")) fmt = GF_TEXT_IMPORT_SWF_SVG;\n\t}\n\tif (!fmt) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TTXT Import] Input %s does not look like a supported text format - ignoring\\n\", import->in_name));\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\tif (import->flags & GF_IMPORT_PROBE_ONLY) {\n\t\tif (fmt==GF_TEXT_IMPORT_SUB) import->flags |= GF_IMPORT_OVERRIDE_FPS;\n\t\treturn GF_OK;\n\t}\n\tswitch (fmt) {\n\tcase GF_TEXT_IMPORT_SRT:\n\t\treturn gf_text_import_srt(import);\n\tcase GF_TEXT_IMPORT_SUB:\n\t\treturn gf_text_import_sub(import);\n\tcase GF_TEXT_IMPORT_TTXT:\n\t\treturn gf_text_import_ttxt(import);\n\tcase GF_TEXT_IMPORT_TEXML:\n\t\treturn gf_text_import_texml(import);\n#ifndef GPAC_DISABLE_VTT\n\tcase GF_TEXT_IMPORT_WEBVTT:\n\t\treturn gf_text_import_webvtt(import);\n#endif\n\tcase GF_TEXT_IMPORT_SWF_SVG:\n\t\treturn gf_text_import_swf(import);\n\tcase GF_TEXT_IMPORT_TTML:\n\t\treturn gf_text_import_ttml(import);\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n}\n\n#endif /*GPAC_DISABLE_MEDIA_IMPORT*/\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n"], "fixing_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2012\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / Media Tools sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n\n\n#include <gpac/constants.h>\n#include <gpac/utf.h>\n#include <gpac/xml.h>\n#include <gpac/token.h>\n#include <gpac/color.h>\n#include <gpac/internal/media_dev.h>\n#include <gpac/internal/isomedia_dev.h>\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nvoid gf_media_update_bitrate(GF_ISOFile *file, u32 track);\n\nenum\n{\n\tGF_TEXT_IMPORT_NONE = 0,\n\tGF_TEXT_IMPORT_SRT,\n\tGF_TEXT_IMPORT_SUB,\n\tGF_TEXT_IMPORT_TTXT,\n\tGF_TEXT_IMPORT_TEXML,\n\tGF_TEXT_IMPORT_WEBVTT,\n\tGF_TEXT_IMPORT_TTML,\n\tGF_TEXT_IMPORT_SWF_SVG,\n};\n\n#define REM_TRAIL_MARKS(__str, __sep) while (1) {\t\\\n\t\tu32 _len = (u32) strlen(__str);\t\t\\\n\t\tif (!_len) break;\t\\\n\t\t_len--;\t\t\t\t\\\n\t\tif (strchr(__sep, __str[_len])) __str[_len] = 0;\t\\\n\t\telse break;\t\\\n\t}\t\\\n \n\ns32 gf_text_get_utf_type(FILE *in_src)\n{\n\tu32 read;\n\tunsigned char BOM[5];\n\tread = (u32) fread(BOM, sizeof(char), 5, in_src);\n\tif ((s32) read < 1)\n\t\treturn -1;\n\n\tif ((BOM[0]==0xFF) && (BOM[1]==0xFE)) {\n\t\t/*UTF32 not supported*/\n\t\tif (!BOM[2] && !BOM[3]) return -1;\n\t\tgf_fseek(in_src, 2, SEEK_SET);\n\t\treturn 3;\n\t}\n\tif ((BOM[0]==0xFE) && (BOM[1]==0xFF)) {\n\t\t/*UTF32 not supported*/\n\t\tif (!BOM[2] && !BOM[3]) return -1;\n\t\tgf_fseek(in_src, 2, SEEK_SET);\n\t\treturn 2;\n\t} else if ((BOM[0]==0xEF) && (BOM[1]==0xBB) && (BOM[2]==0xBF)) {\n\t\tgf_fseek(in_src, 3, SEEK_SET);\n\t\treturn 1;\n\t}\n\tif (BOM[0]<0x80) {\n\t\tgf_fseek(in_src, 0, SEEK_SET);\n\t\treturn 0;\n\t}\n\treturn -1;\n}\n\nstatic GF_Err gf_text_guess_format(char *filename, u32 *fmt)\n{\n\tchar szLine[2048];\n\tu32 val;\n\ts32 uni_type;\n\tFILE *test = gf_fopen(filename, \"rb\");\n\tif (!test) return GF_URL_ERROR;\n\tuni_type = gf_text_get_utf_type(test);\n\n\tif (uni_type>1) {\n\t\tconst u16 *sptr;\n\t\tchar szUTF[1024];\n\t\tu32 read = (u32) fread(szUTF, 1, 1023, test);\n\t\tif ((s32) read < 0) {\n\t\t\tgf_fclose(test);\n\t\t\treturn GF_IO_ERR;\n\t\t}\n\t\tszUTF[read]=0;\n\t\tsptr = (u16*)szUTF;\n\t\t/*read = (u32) */gf_utf8_wcstombs(szLine, read, &sptr);\n\t} else {\n\t\tval = (u32) fread(szLine, 1, 1024, test);\n\t\tif ((s32) val<0) return GF_IO_ERR;\n\t\t\n\t\tszLine[val]=0;\n\t}\n\tREM_TRAIL_MARKS(szLine, \"\\r\\n\\t \")\n\n\t*fmt = GF_TEXT_IMPORT_NONE;\n\tif ((szLine[0]=='{') && strstr(szLine, \"}{\")) *fmt = GF_TEXT_IMPORT_SUB;\n\telse if (szLine[0] == '<') {\n\t\tchar *ext = strrchr(filename, '.');\n\t\tif (!strnicmp(ext, \".ttxt\", 5)) *fmt = GF_TEXT_IMPORT_TTXT;\n\t\telse if (!strnicmp(ext, \".ttml\", 5)) *fmt = GF_TEXT_IMPORT_TTML;\n\t\text = strstr(szLine, \"?>\");\n\t\tif (ext) ext += 2;\n\t\tif (ext && !ext[0]) {\n\t\t\tif (!fgets(szLine, 2048, test))\n\t\t\t\tszLine[0] = '\\0';\n\t\t}\n\t\tif (strstr(szLine, \"x-quicktime-tx3g\") || strstr(szLine, \"text3GTrack\")) *fmt = GF_TEXT_IMPORT_TEXML;\n\t\telse if (strstr(szLine, \"TextStream\")) *fmt = GF_TEXT_IMPORT_TTXT;\n\t\telse if (strstr(szLine, \"tt\")) *fmt = GF_TEXT_IMPORT_TTML;\n\t}\n\telse if (strstr(szLine, \"WEBVTT\") )\n\t\t*fmt = GF_TEXT_IMPORT_WEBVTT;\n\telse if (strstr(szLine, \" --> \") )\n\t\t*fmt = GF_TEXT_IMPORT_SRT; /* might want to change the default to WebVTT */\n\n\tgf_fclose(test);\n\treturn GF_OK;\n}\n\n\n#define TTXT_DEFAULT_WIDTH\t400\n#define TTXT_DEFAULT_HEIGHT\t60\n#define TTXT_DEFAULT_FONT_SIZE\t18\n\n#ifndef GPAC_DISABLE_MEDIA_IMPORT\nvoid gf_text_get_video_size(GF_MediaImporter *import, u32 *width, u32 *height)\n{\n\tu32 w, h, f_w, f_h, i;\n\tGF_ISOFile *dest = import->dest;\n\n\tif (import->text_track_width && import->text_track_height) {\n\t\t(*width) = import->text_track_width;\n\t\t(*height) = import->text_track_height;\n\t\treturn;\n\t}\n\n\tf_w = f_h = 0;\n\tfor (i=0; i<gf_isom_get_track_count(dest); i++) {\n\t\tswitch (gf_isom_get_media_type(dest, i+1)) {\n\t\tcase GF_ISOM_MEDIA_SCENE:\n\t\tcase GF_ISOM_MEDIA_VISUAL:\n        case GF_ISOM_MEDIA_AUXV:\n        case GF_ISOM_MEDIA_PICT:\n\t\t\tgf_isom_get_visual_info(dest, i+1, 1, &w, &h);\n\t\t\tif (w > f_w) f_w = w;\n\t\t\tif (h > f_h) f_h = h;\n\t\t\tgf_isom_get_track_layout_info(dest, i+1, &w, &h, NULL, NULL, NULL);\n\t\t\tif (w > f_w) f_w = w;\n\t\t\tif (h > f_h) f_h = h;\n\t\t\tbreak;\n\t\t}\n\t}\n\t(*width) = f_w ? f_w : TTXT_DEFAULT_WIDTH;\n\t(*height) = f_h ? f_h : TTXT_DEFAULT_HEIGHT;\n}\n\n\nvoid gf_text_import_set_language(GF_MediaImporter *import, u32 track)\n{\n\tif (import->esd && import->esd->langDesc) {\n\t\tchar lang[4];\n\t\tlang[0] = (import->esd->langDesc->langCode>>16) & 0xFF;\n\t\tlang[1] = (import->esd->langDesc->langCode>>8) & 0xFF;\n\t\tlang[2] = (import->esd->langDesc->langCode) & 0xFF;\n\t\tlang[3] = 0;\n\t\tgf_isom_set_media_language(import->dest, track, lang);\n\t}\n}\n#endif\n\nchar *gf_text_get_utf8_line(char *szLine, u32 lineSize, FILE *txt_in, s32 unicode_type)\n{\n\tu32 i, j, len;\n\tchar *sOK;\n\tchar szLineConv[1024];\n\tunsigned short *sptr;\n\n\tmemset(szLine, 0, sizeof(char)*lineSize);\n\tsOK = fgets(szLine, lineSize, txt_in);\n\tif (!sOK) return NULL;\n\tif (unicode_type<=1) {\n\t\tj=0;\n\t\tlen = (u32) strlen(szLine);\n\t\tfor (i=0; i<len; i++) {\n\t\t\tif (!unicode_type && (szLine[i] & 0x80)) {\n\t\t\t\t/*non UTF8 (likely some win-CP)*/\n\t\t\t\tif ((szLine[i+1] & 0xc0) != 0x80) {\n\t\t\t\t\tszLineConv[j] = 0xc0 | ( (szLine[i] >> 6) & 0x3 );\n\t\t\t\t\tj++;\n\t\t\t\t\tszLine[i] &= 0xbf;\n\t\t\t\t}\n\t\t\t\t/*UTF8 2 bytes char*/\n\t\t\t\telse if ( (szLine[i] & 0xe0) == 0xc0) {\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\t/*UTF8 3 bytes char*/\n\t\t\t\telse if ( (szLine[i] & 0xf0) == 0xe0) {\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\t/*UTF8 4 bytes char*/\n\t\t\t\telse if ( (szLine[i] & 0xf8) == 0xf0) {\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t} else {\n\t\t\t\t\ti+=1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tszLineConv[j] = szLine[i];\n\t\t\tj++;\n\t\t}\n\t\tszLineConv[j] = 0;\n\t\tstrcpy(szLine, szLineConv);\n\t\treturn sOK;\n\t}\n\n#ifdef GPAC_BIG_ENDIAN\n\tif (unicode_type==3) {\n#else\n\tif (unicode_type==2) {\n#endif\n\t\ti=0;\n\t\twhile (1) {\n\t\t\tchar c;\n\t\t\tif (!szLine[i] && !szLine[i+1]) break;\n\t\t\tc = szLine[i+1];\n\t\t\tszLine[i+1] = szLine[i];\n\t\t\tszLine[i] = c;\n\t\t\ti+=2;\n\t\t}\n\t}\n\tsptr = (u16 *)szLine;\n\ti = (u32) gf_utf8_wcstombs(szLineConv, 1024, (const unsigned short **) &sptr);\n\tif (i >= (u32)ARRAY_LENGTH(szLineConv))\n\t\treturn NULL;\n\tszLineConv[i] = 0;\n\tstrcpy(szLine, szLineConv);\n\t/*this is ugly indeed: since input is UTF16-LE, there are many chances the fgets never reads the \\0 after a \\n*/\n\tif (unicode_type==3) fgetc(txt_in);\n\treturn sOK;\n}\n\n\n#ifndef GPAC_DISABLE_MEDIA_IMPORT\n\nstatic GF_Err gf_text_import_srt(GF_MediaImporter *import)\n{\n\tFILE *srt_in;\n\tu32 track, timescale, i, count;\n\tGF_TextConfig*cfg;\n\tGF_Err e;\n\tGF_StyleRecord rec;\n\tGF_TextSample * samp;\n\tGF_ISOSample *s;\n\tu32 sh, sm, ss, sms, eh, em, es, ems, txt_line, char_len, char_line, nb_samp, j, duration, rem_styles;\n\tBool set_start_char, set_end_char, first_samp, rem_color;\n\tu64 start, end, prev_end, file_size;\n\tu32 state, curLine, line, len, ID, OCR_ES_ID, default_color;\n\ts32 unicode_type;\n\tchar szLine[2048], szText[2048], *ptr;\n\tunsigned short uniLine[5000], uniText[5000], *sptr;\n\n\tsrt_in = gf_fopen(import->in_name, \"rt\");\n\tgf_fseek(srt_in, 0, SEEK_END);\n\tfile_size = gf_ftell(srt_in);\n\tgf_fseek(srt_in, 0, SEEK_SET);\n\n\tunicode_type = gf_text_get_utf_type(srt_in);\n\tif (unicode_type<0) {\n\t\tgf_fclose(srt_in);\n\t\treturn gf_import_message(import, GF_NOT_SUPPORTED, \"Unsupported SRT UTF encoding\");\n\t}\n\n\tcfg = NULL;\n\tif (import->esd) {\n\t\tif (!import->esd->slConfig) {\n\t\t\timport->esd->slConfig = (GF_SLConfig *) gf_odf_desc_new(GF_ODF_SLC_TAG);\n\t\t\timport->esd->slConfig->predefined = 2;\n\t\t\timport->esd->slConfig->timestampResolution = 1000;\n\t\t}\n\t\ttimescale = import->esd->slConfig->timestampResolution;\n\t\tif (!timescale) timescale = 1000;\n\n\t\t/*explicit text config*/\n\t\tif (import->esd->decoderConfig && import->esd->decoderConfig->decoderSpecificInfo->tag == GF_ODF_TEXT_CFG_TAG) {\n\t\t\tcfg = (GF_TextConfig *) import->esd->decoderConfig->decoderSpecificInfo;\n\t\t\timport->esd->decoderConfig->decoderSpecificInfo = NULL;\n\t\t}\n\t\tID = import->esd->ESID;\n\t\tOCR_ES_ID = import->esd->OCRESID;\n\t} else {\n\t\ttimescale = 1000;\n\t\tOCR_ES_ID = ID = 0;\n\t}\n\n\tif (cfg && cfg->timescale) timescale = cfg->timescale;\n\ttrack = gf_isom_new_track(import->dest, ID, GF_ISOM_MEDIA_TEXT, timescale);\n\tif (!track) {\n\t\tgf_fclose(srt_in);\n\t\treturn gf_import_message(import, gf_isom_last_error(import->dest), \"Error creating text track\");\n\t}\n\tgf_isom_set_track_enabled(import->dest, track, 1);\n\timport->final_trackID = gf_isom_get_track_id(import->dest, track);\n\tif (import->esd && !import->esd->ESID) import->esd->ESID = import->final_trackID;\n\n\tif (OCR_ES_ID) gf_isom_set_track_reference(import->dest, track, GF_ISOM_REF_OCR, OCR_ES_ID);\n\n\t/*setup track*/\n\tif (cfg) {\n\t\tchar *firstFont = NULL;\n\t\t/*set track info*/\n\t\tgf_isom_set_track_layout_info(import->dest, track, cfg->text_width<<16, cfg->text_height<<16, 0, 0, cfg->layer);\n\n\t\t/*and set sample descriptions*/\n\t\tcount = gf_list_count(cfg->sample_descriptions);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_TextSampleDescriptor *sd= (GF_TextSampleDescriptor *)gf_list_get(cfg->sample_descriptions, i);\n\t\t\tif (!sd->font_count) {\n\t\t\t\tsd->fonts = (GF_FontRecord*)gf_malloc(sizeof(GF_FontRecord));\n\t\t\t\tsd->font_count = 1;\n\t\t\t\tsd->fonts[0].fontID = 1;\n\t\t\t\tsd->fonts[0].fontName = gf_strdup(\"Serif\");\n\t\t\t}\n\t\t\tif (!sd->default_style.fontID) sd->default_style.fontID = sd->fonts[0].fontID;\n\t\t\tif (!sd->default_style.font_size) sd->default_style.font_size = 16;\n\t\t\tif (!sd->default_style.text_color) sd->default_style.text_color = 0xFF000000;\n\t\t\t/*store attribs*/\n\t\t\tif (!i) rec = sd->default_style;\n\n\t\t\tgf_isom_new_text_description(import->dest, track, sd, NULL, NULL, &state);\n\t\t\tif (!firstFont) firstFont = sd->fonts[0].fontName;\n\t\t}\n\t\tgf_import_message(import, GF_OK, \"Timed Text (SRT) import - text track %d x %d, font %s (size %d)\", cfg->text_width, cfg->text_height, firstFont, rec.font_size);\n\n\t\tgf_odf_desc_del((GF_Descriptor *)cfg);\n\t} else {\n\t\tu32 w, h;\n\t\tGF_TextSampleDescriptor *sd;\n\t\tgf_text_get_video_size(import, &w, &h);\n\n\t\t/*have to work with default - use max size (if only one video, this means the text region is the\n\t\tentire display, and with bottom alignment things should be fine...*/\n\t\tgf_isom_set_track_layout_info(import->dest, track, w<<16, h<<16, 0, 0, 0);\n\t\tsd = (GF_TextSampleDescriptor*)gf_odf_desc_new(GF_ODF_TX3G_TAG);\n\t\tsd->fonts = (GF_FontRecord*)gf_malloc(sizeof(GF_FontRecord));\n\t\tsd->font_count = 1;\n\t\tsd->fonts[0].fontID = 1;\n\t\tsd->fonts[0].fontName = gf_strdup(import->fontName ? import->fontName : \"Serif\");\n\t\tsd->back_color = 0x00000000;\t/*transparent*/\n\t\tsd->default_style.fontID = 1;\n\t\tsd->default_style.font_size = import->fontSize ? import->fontSize : TTXT_DEFAULT_FONT_SIZE;\n\t\tsd->default_style.text_color = 0xFFFFFFFF;\t/*white*/\n\t\tsd->default_style.style_flags = 0;\n\t\tsd->horiz_justif = 1; /*center of scene*/\n\t\tsd->vert_justif = (s8) -1;\t/*bottom of scene*/\n\n\t\tif (import->flags & GF_IMPORT_SKIP_TXT_BOX) {\n\t\t\tsd->default_pos.top = sd->default_pos.left = sd->default_pos.right = sd->default_pos.bottom = 0;\n\t\t} else {\n\t\t\tif ((sd->default_pos.bottom==sd->default_pos.top) || (sd->default_pos.right==sd->default_pos.left)) {\n\t\t\t\tsd->default_pos.left = import->text_x;\n\t\t\t\tsd->default_pos.top = import->text_y;\n\t\t\t\tsd->default_pos.right = (import->text_width ? import->text_width : w) + sd->default_pos.left;\n\t\t\t\tsd->default_pos.bottom = (import->text_height ? import->text_height : h) + sd->default_pos.top;\n\t\t\t}\n\t\t}\n\n\t\t/*store attribs*/\n\t\trec = sd->default_style;\n\t\tgf_isom_new_text_description(import->dest, track, sd, NULL, NULL, &state);\n\n\t\tgf_import_message(import, GF_OK, \"Timed Text (SRT) import - text track %d x %d, font %s (size %d)\", w, h, sd->fonts[0].fontName, rec.font_size);\n\t\tgf_odf_desc_del((GF_Descriptor *)sd);\n\t}\n\tgf_text_import_set_language(import, track);\n\tduration = (u32) (((Double) import->duration)*timescale/1000.0);\n\n\tdefault_color = rec.text_color;\n\n\te = GF_OK;\n\tstate = 0;\n\tend = prev_end = 0;\n\tcurLine = 0;\n\ttxt_line = 0;\n\tset_start_char = set_end_char = GF_FALSE;\n\tchar_len = 0;\n\tstart = 0;\n\tnb_samp = 0;\n\tsamp = gf_isom_new_text_sample();\n\n\tfirst_samp = GF_TRUE;\n\twhile (1) {\n\t\tchar *sOK = gf_text_get_utf8_line(szLine, 2048, srt_in, unicode_type);\n\n\t\tif (sOK) REM_TRAIL_MARKS(szLine, \"\\r\\n\\t \")\n\t\t\tif (!sOK || !strlen(szLine)) {\n\t\t\t\trec.style_flags = 0;\n\t\t\t\trec.startCharOffset = rec.endCharOffset = 0;\n\t\t\t\tif (txt_line) {\n\t\t\t\t\tif (prev_end && (start != prev_end)) {\n\t\t\t\t\t\tGF_TextSample * empty_samp = gf_isom_new_text_sample();\n\t\t\t\t\t\ts = gf_isom_text_to_sample(empty_samp);\n\t\t\t\t\t\tgf_isom_delete_text_sample(empty_samp);\n\t\t\t\t\t\tif (state<=2) {\n\t\t\t\t\t\t\ts->DTS = (u64) ((timescale*prev_end)/1000);\n\t\t\t\t\t\t\ts->IsRAP = RAP;\n\t\t\t\t\t\t\tgf_isom_add_sample(import->dest, track, 1, s);\n\t\t\t\t\t\t\tnb_samp++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgf_isom_sample_del(&s);\n\t\t\t\t\t}\n\n\t\t\t\t\ts = gf_isom_text_to_sample(samp);\n\t\t\t\t\tif (state<=2) {\n\t\t\t\t\t\ts->DTS = (u64) ((timescale*start)/1000);\n\t\t\t\t\t\ts->IsRAP = RAP;\n\t\t\t\t\t\tgf_isom_add_sample(import->dest, track, 1, s);\n\t\t\t\t\t\tgf_isom_sample_del(&s);\n\t\t\t\t\t\tnb_samp++;\n\t\t\t\t\t\tprev_end = end;\n\t\t\t\t\t}\n\t\t\t\t\ttxt_line = 0;\n\t\t\t\t\tchar_len = 0;\n\t\t\t\t\tset_start_char = set_end_char = GF_FALSE;\n\t\t\t\t\trec.startCharOffset = rec.endCharOffset = 0;\n\t\t\t\t\tgf_isom_text_reset(samp);\n\n\t\t\t\t\t//gf_import_progress(import, nb_samp, nb_samp+1);\n\t\t\t\t\tgf_set_progress(\"Importing SRT\", gf_ftell(srt_in), file_size);\n\t\t\t\t\tif (duration && (end >= duration)) break;\n\t\t\t\t}\n\t\t\t\tstate = 0;\n\t\t\t\tif (!sOK) break;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\tswitch (state) {\n\t\tcase 0:\n\t\t\tif (sscanf(szLine, \"%u\", &line) != 1) {\n\t\t\t\te = gf_import_message(import, GF_CORRUPTED_DATA, \"Bad SRT formatting - expecting number got \\\"%s\\\"\", szLine);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tif (line != curLine + 1) gf_import_message(import, GF_OK, \"WARNING: corrupted SRT frame %d after frame %d\", line, curLine);\n\t\t\tcurLine = line;\n\t\t\tstate = 1;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (sscanf(szLine, \"%u:%u:%u,%u --> %u:%u:%u,%u\", &sh, &sm, &ss, &sms, &eh, &em, &es, &ems) != 8) {\n\t\t\t\tsh = eh = 0;\n\t\t\t\tif (sscanf(szLine, \"%u:%u,%u --> %u:%u,%u\", &sm, &ss, &sms, &em, &es, &ems) != 6) {\n\t\t\t\t\te = gf_import_message(import, GF_CORRUPTED_DATA, \"Error scanning SRT frame %d timing\", curLine);\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstart = (3600*sh + 60*sm + ss)*1000 + sms;\n\t\t\tif (start<end) {\n\t\t\t\tgf_import_message(import, GF_OK, \"WARNING: overlapping SRT frame %d - starts \"LLD\" ms is before end of previous one \"LLD\" ms - adjusting time stamps\", curLine, start, end);\n\t\t\t\tstart = end;\n\t\t\t}\n\n\t\t\tend = (3600*eh + 60*em + es)*1000 + ems;\n\t\t\t/*make stream start at 0 by inserting a fake AU*/\n\t\t\tif (first_samp && (start>0)) {\n\t\t\t\ts = gf_isom_text_to_sample(samp);\n\t\t\t\ts->DTS = 0;\n\t\t\t\tgf_isom_add_sample(import->dest, track, 1, s);\n\t\t\t\tgf_isom_sample_del(&s);\n\t\t\t\tnb_samp++;\n\t\t\t}\n\t\t\trec.style_flags = 0;\n\t\t\tstate = 2;\n\t\t\tif (end<=prev_end) {\n\t\t\t\tgf_import_message(import, GF_OK, \"WARNING: overlapping SRT frame %d end \"LLD\" is at or before previous end \"LLD\" - removing\", curLine, end, prev_end);\n\t\t\t\tstart = end;\n\t\t\t\tstate = 3;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/*reset only when text is present*/\n\t\t\tfirst_samp = GF_FALSE;\n\n\t\t\t/*go to line*/\n\t\t\tif (txt_line) {\n\t\t\t\tgf_isom_text_add_text(samp, \"\\n\", 1);\n\t\t\t\tchar_len += 1;\n\t\t\t}\n\n\t\t\tptr = (char *) szLine;\n\t\t\t{\n\t\t\t\tsize_t _len = gf_utf8_mbstowcs(uniLine, 5000, (const char **) &ptr);\n\t\t\t\tif (_len == (size_t) -1) {\n\t\t\t\t\te = gf_import_message(import, GF_CORRUPTED_DATA, \"Invalid UTF data (line %d)\", curLine);\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t\tlen = (u32) _len;\n\t\t\t}\n\t\t\ti=j=0;\n\t\t\trem_styles = 0;\n\t\t\trem_color = 0;\n\t\t\twhile (i<len) {\n\t\t\t\tu32 font_style = 0;\n\t\t\t\tu32 style_nb_chars = 0;\n\t\t\t\tu32 style_def_type = 0;\n\n\t\t\t\tif ( (uniLine[i]=='<') && (uniLine[i+2]=='>')) {\n\t\t\t\t\tstyle_nb_chars = 3;\n\t\t\t\t\tstyle_def_type = 1;\n\t\t\t\t}\n\t\t\t\telse if ( (uniLine[i]=='<') && (uniLine[i+1]=='/') && (uniLine[i+3]=='>')) {\n\t\t\t\t\tstyle_def_type = 2;\n\t\t\t\t\tstyle_nb_chars = 4;\n\t\t\t\t}\n\t\t\t\telse if (uniLine[i]=='<')  {\n\t\t\t\t\tconst unsigned short* src = uniLine + i;\n\t\t\t\t\tsize_t alen = gf_utf8_wcstombs(szLine, 2048, (const unsigned short**) & src);\n\t\t\t\t\tszLine[alen] = 0;\n\t\t\t\t\tstrlwr(szLine);\n\t\t\t\t\tif (!strncmp(szLine, \"<font \", 6) ) {\n\t\t\t\t\t\tchar *a_sep = strstr(szLine, \"color\");\n\t\t\t\t\t\tif (a_sep) a_sep = strchr(a_sep, '\"');\n\t\t\t\t\t\tif (a_sep) {\n\t\t\t\t\t\t\tchar *e_sep = strchr(a_sep+1, '\"');\n\t\t\t\t\t\t\tif (e_sep) {\n\t\t\t\t\t\t\t\te_sep[0] = 0;\n\t\t\t\t\t\t\t\tfont_style = gf_color_parse(a_sep+1);\n\t\t\t\t\t\t\t\te_sep[0] = '\"';\n\t\t\t\t\t\t\t\te_sep = strchr(e_sep+1, '>');\n\t\t\t\t\t\t\t\tif (e_sep) {\n\t\t\t\t\t\t\t\t\tstyle_nb_chars = (u32) (1 + e_sep - szLine);\n\t\t\t\t\t\t\t\t\tstyle_def_type = 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (!strncmp(szLine, \"</font>\", 7) ) {\n\t\t\t\t\t\tstyle_nb_chars = 7;\n\t\t\t\t\t\tstyle_def_type = 2;\n\t\t\t\t\t\tfont_style = 0xFFFFFFFF;\n\t\t\t\t\t}\n\t\t\t\t\t//skip unknown\n\t\t\t\t\telse {\n\t\t\t\t\t\tchar *a_sep = strstr(szLine, \">\");\n\t\t\t\t\t\tif (a_sep) {\n\t\t\t\t\t\t\tstyle_nb_chars = (u32) (a_sep - szLine);\n\t\t\t\t\t\t\ti += style_nb_chars;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t/*start of new style*/\n\t\t\t\tif (style_def_type==1)  {\n\t\t\t\t\t/*store prev style*/\n\t\t\t\t\tif (set_end_char) {\n\t\t\t\t\t\tassert(set_start_char);\n\t\t\t\t\t\tgf_isom_text_add_style(samp, &rec);\n\t\t\t\t\t\tset_end_char = set_start_char = GF_FALSE;\n\t\t\t\t\t\trec.style_flags &= ~rem_styles;\n\t\t\t\t\t\trem_styles = 0;\n\t\t\t\t\t\tif (rem_color) {\n\t\t\t\t\t\t\trec.text_color = default_color;\n\t\t\t\t\t\t\trem_color = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (set_start_char && (rec.startCharOffset != j)) {\n\t\t\t\t\t\trec.endCharOffset = char_len + j;\n\t\t\t\t\t\tif (rec.style_flags) gf_isom_text_add_style(samp, &rec);\n\t\t\t\t\t}\n\t\t\t\t\tswitch (uniLine[i+1]) {\n\t\t\t\t\tcase 'b':\n\t\t\t\t\tcase 'B':\n\t\t\t\t\t\trec.style_flags |= GF_TXT_STYLE_BOLD;\n\t\t\t\t\t\tset_start_char = GF_TRUE;\n\t\t\t\t\t\trec.startCharOffset = char_len + j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'i':\n\t\t\t\t\tcase 'I':\n\t\t\t\t\t\trec.style_flags |= GF_TXT_STYLE_ITALIC;\n\t\t\t\t\t\tset_start_char = GF_TRUE;\n\t\t\t\t\t\trec.startCharOffset = char_len + j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'u':\n\t\t\t\t\tcase 'U':\n\t\t\t\t\t\trec.style_flags |= GF_TXT_STYLE_UNDERLINED;\n\t\t\t\t\t\tset_start_char = GF_TRUE;\n\t\t\t\t\t\trec.startCharOffset = char_len + j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'f':\n\t\t\t\t\tcase 'F':\n\t\t\t\t\t\tif (font_style) {\n\t\t\t\t\t\t\trec.text_color = font_style;\n\t\t\t\t\t\t\tset_start_char = GF_TRUE;\n\t\t\t\t\t\t\trec.startCharOffset = char_len + j;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ti += style_nb_chars;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t/*end of prev style*/\n\t\t\t\tif (style_def_type==2)  {\n\t\t\t\t\tswitch (uniLine[i+2]) {\n\t\t\t\t\tcase 'b':\n\t\t\t\t\tcase 'B':\n\t\t\t\t\t\trem_styles |= GF_TXT_STYLE_BOLD;\n\t\t\t\t\t\tset_end_char = GF_TRUE;\n\t\t\t\t\t\trec.endCharOffset = char_len + j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'i':\n\t\t\t\t\tcase 'I':\n\t\t\t\t\t\trem_styles |= GF_TXT_STYLE_ITALIC;\n\t\t\t\t\t\tset_end_char = GF_TRUE;\n\t\t\t\t\t\trec.endCharOffset = char_len + j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'u':\n\t\t\t\t\tcase 'U':\n\t\t\t\t\t\trem_styles |= GF_TXT_STYLE_UNDERLINED;\n\t\t\t\t\t\tset_end_char = GF_TRUE;\n\t\t\t\t\t\trec.endCharOffset = char_len + j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'f':\n\t\t\t\t\tcase 'F':\n\t\t\t\t\t\tif (font_style) {\n\t\t\t\t\t\t\trem_color = 1;\n\t\t\t\t\t\t\tset_end_char = GF_TRUE;\n\t\t\t\t\t\t\trec.endCharOffset = char_len + j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ti+=style_nb_chars;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/*store style*/\n\t\t\t\tif (set_end_char) {\n\t\t\t\t\tgf_isom_text_add_style(samp, &rec);\n\t\t\t\t\tset_end_char = GF_FALSE;\n\t\t\t\t\tset_start_char = GF_TRUE;\n\t\t\t\t\trec.startCharOffset = char_len + j;\n\t\t\t\t\trec.style_flags &= ~rem_styles;\n\t\t\t\t\trem_styles = 0;\n\t\t\t\t\trec.text_color = default_color;\n\t\t\t\t\trem_color = 0;\n\t\t\t\t}\n\n\t\t\t\tuniText[j] = uniLine[i];\n\t\t\t\tj++;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\t/*store last style*/\n\t\t\tif (set_end_char) {\n\t\t\t\tgf_isom_text_add_style(samp, &rec);\n\t\t\t\tset_end_char = GF_FALSE;\n\t\t\t\tset_start_char = GF_TRUE;\n\t\t\t\trec.startCharOffset = char_len + j;\n\t\t\t\trec.style_flags &= ~rem_styles;\n\t\t\t}\n\n\t\t\tchar_line = j;\n\t\t\tuniText[j] = 0;\n\n\t\t\tsptr = (u16 *) uniText;\n\t\t\tlen = (u32) gf_utf8_wcstombs(szText, 5000, (const u16 **) &sptr);\n\n\t\t\tgf_isom_text_add_text(samp, szText, len);\n\t\t\tchar_len += char_line;\n\t\t\ttxt_line ++;\n\t\t\tbreak;\n\t\t}\n\t\tif (duration && (start >= duration)) {\n\t\t\tend = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*final flush*/\t\n\tif (end && !(import->flags & GF_IMPORT_NO_TEXT_FLUSH ) ) {\n\t\tgf_isom_text_reset(samp);\n\t\ts = gf_isom_text_to_sample(samp);\n\t\ts->DTS = (u64) ((timescale*end)/1000);\n\t\ts->IsRAP = RAP;\n\t\tgf_isom_add_sample(import->dest, track, 1, s);\n\t\tgf_isom_sample_del(&s);\n\t\tnb_samp++;\n\t\tgf_isom_set_last_sample_duration(import->dest, track, 0);\n\t} else {\n\t\tif (duration && (start >= duration)) {\n\t\t\tgf_isom_set_last_sample_duration(import->dest, track, (timescale*duration)/1000);\n\t\t} else {\n\t\t\tgf_isom_set_last_sample_duration(import->dest, track, 0);\n\t\t}\n\t}\n\tgf_isom_delete_text_sample(samp);\n\tgf_set_progress(\"Importing SRT\", nb_samp, nb_samp);\n\nexit:\n\tif (e) gf_isom_remove_track(import->dest, track);\n\tgf_fclose(srt_in);\n\treturn e;\n}\n\n/* Structure used to pass importer and track data to the parsers without exposing the GF_MediaImporter structure\n   used by WebVTT and Flash->SVG */\ntypedef struct {\n\tGF_MediaImporter *import;\n\tu32 timescale;\n\tu32 track;\n\tu32 descriptionIndex;\n} GF_ISOFlusher;\n\n#ifndef GPAC_DISABLE_VTT\n\nstatic GF_Err gf_webvtt_import_report(void *user, GF_Err e, char *message, const char *line)\n{\n\tGF_ISOFlusher     *flusher = (GF_ISOFlusher *)user;\n\treturn gf_import_message(flusher->import, e, message, line);\n}\n\nstatic void gf_webvtt_import_header(void *user, const char *config)\n{\n\tGF_ISOFlusher     *flusher = (GF_ISOFlusher *)user;\n\tgf_isom_update_webvtt_description(flusher->import->dest, flusher->track, flusher->descriptionIndex, config);\n}\n\nstatic void gf_webvtt_flush_sample_to_iso(void *user, GF_WebVTTSample *samp)\n{\n\tGF_ISOSample            *s;\n\tGF_ISOFlusher     *flusher = (GF_ISOFlusher *)user;\n\t//gf_webvtt_dump_sample(stdout, samp);\n\ts = gf_isom_webvtt_to_sample(samp);\n\tif (s) {\n\t\ts->DTS = (u64) (flusher->timescale*gf_webvtt_sample_get_start(samp)/1000);\n\t\ts->IsRAP = RAP;\n\t\tgf_isom_add_sample(flusher->import->dest, flusher->track, flusher->descriptionIndex, s);\n\t\tgf_isom_sample_del(&s);\n\t}\n\tgf_webvtt_sample_del(samp);\n}\n\nstatic GF_Err gf_text_import_webvtt(GF_MediaImporter *import)\n{\n\tGF_Err\t\t\t\t\t\te;\n\tu32\t\t\t\t\t\t\ttrack;\n\tu32\t\t\t\t\t\t\ttimescale;\n\tu32\t\t\t\t\t\t\tduration;\n\tu32\t\t\t\t\t\t\tdescIndex=1;\n\tu32\t\t\t\t\t\t\tID;\n\tu32\t\t\t\t\t\t\tOCR_ES_ID;\n\tGF_GenericSubtitleConfig\t*cfg;\n\tGF_WebVTTParser\t\t\t\t*vttparser;\n\tGF_ISOFlusher\t\t\t\tflusher;\n\n\tcfg\t= NULL;\n\tif (import->esd) {\n\t\tif (!import->esd->slConfig)\t{\n\t\t\timport->esd->slConfig =\t(GF_SLConfig *)\tgf_odf_desc_new(GF_ODF_SLC_TAG);\n\t\t\timport->esd->slConfig->predefined =\t2;\n\t\t\timport->esd->slConfig->timestampResolution = 1000;\n\t\t}\n\t\ttimescale =\timport->esd->slConfig->timestampResolution;\n\t\tif (!timescale)\ttimescale =\t1000;\n\n\t\t/*explicit text\tconfig*/\n\t\tif (import->esd->decoderConfig && import->esd->decoderConfig->decoderSpecificInfo->tag == GF_ODF_GEN_SUB_CFG_TAG) {\n\t\t\tcfg\t= (GF_GenericSubtitleConfig\t*) import->esd->decoderConfig->decoderSpecificInfo;\n\t\t\timport->esd->decoderConfig->decoderSpecificInfo\t= NULL;\n\t\t}\n\t\tID = import->esd->ESID;\n\t\tOCR_ES_ID =\timport->esd->OCRESID;\n\t} else {\n\t\ttimescale =\t1000;\n\t\tOCR_ES_ID =\tID = 0;\n\t}\n\n\tif (cfg\t&& cfg->timescale) timescale = cfg->timescale;\n\ttrack =\tgf_isom_new_track(import->dest,\tID,\tGF_ISOM_MEDIA_TEXT,\ttimescale);\n\tif (!track)\t{\n\t\treturn gf_import_message(import, gf_isom_last_error(import->dest), \"Error creating WebVTT track\");\n\t}\n\tgf_isom_set_track_enabled(import->dest, track, 1);\n\timport->final_trackID = gf_isom_get_track_id(import->dest, track);\n\tif (import->esd && !import->esd->ESID) import->esd->ESID = import->final_trackID;\n\n\tif (OCR_ES_ID) gf_isom_set_track_reference(import->dest, track,\tGF_ISOM_REF_OCR, OCR_ES_ID);\n\n\t/*setup\ttrack*/\n\tif (cfg) {\n\t\tu32\ti;\n\t\tu32\tcount;\n\t\t/*set track\tinfo*/\n\t\tgf_isom_set_track_layout_info(import->dest,\ttrack, cfg->text_width<<16,\tcfg->text_height<<16, 0, 0,\tcfg->layer);\n\n\t\t/*and set sample descriptions*/\n\t\tcount =\tgf_list_count(cfg->sample_descriptions);\n\t\tfor\t(i=0; i<count; i++)\t{\n\t\t\tgf_isom_new_webvtt_description(import->dest, track, NULL, NULL, NULL, &descIndex);\n\t\t}\n\t\tgf_import_message(import, GF_OK, \"WebVTT import\t- text track %d\tx %d\", cfg->text_width,\tcfg->text_height);\n\t\tgf_odf_desc_del((GF_Descriptor *)cfg);\n\t} else {\n\t\tu32\tw;\n\t\tu32\th;\n\n\t\tgf_text_get_video_size(import, &w, &h);\n\t\tgf_isom_set_track_layout_info(import->dest,\ttrack, w<<16, h<<16, 0,\t0, 0);\n\n\t\tgf_isom_new_webvtt_description(import->dest, track,\tNULL, NULL,\tNULL, &descIndex);\n\n\t\tgf_import_message(import, GF_OK, \"WebVTT import\");\n\t}\n\tgf_text_import_set_language(import, track);\n\tduration = (u32) (((Double) import->duration)*timescale/1000.0);\n\n\tvttparser = gf_webvtt_parser_new();\n\tflusher.import = import;\n\tflusher.timescale = timescale;\n\tflusher.track = track;\n\tflusher.descriptionIndex = descIndex;\n\te = gf_webvtt_parser_init(vttparser, import->in_name, &flusher, gf_webvtt_import_report, gf_webvtt_flush_sample_to_iso, gf_webvtt_import_header);\n\tif (e != GF_OK) {\n\t\tgf_webvtt_parser_del(vttparser);\n\t\treturn gf_import_message(import, GF_NOT_SUPPORTED, \"Unsupported WebVTT UTF encoding\");\n\t}\n\te = gf_webvtt_parser_parse(vttparser, duration);\n\tif (e != GF_OK) {\n\t\tgf_isom_remove_track(import->dest, track);\n\t}\n\n\t/*do not add any empty sample at the end since it modifies track duration and is not needed - it is the player job\n\tto figure out when to stop displaying the last text sample\n\tHowever update the last sample duration*/\n\tgf_isom_set_last_sample_duration(import->dest, track, (u32) gf_webvtt_parser_last_duration(vttparser));\n\t\n\tgf_webvtt_parser_del(vttparser);\n\treturn e;\n}\n\n#endif /*GPAC_DISABLE_VTT*/\n\nstatic char *ttxt_parse_string(GF_MediaImporter *import, char *str, Bool strip_lines)\n{\n\tu32 i=0;\n\tu32 k=0;\n\tu32 len = (u32) strlen(str);\n\tu32 state = 0;\n\n\tif (!strip_lines) {\n\t\tfor (i=0; i<len; i++) {\n\t\t\tif ((str[i] == '\\r') && (str[i+1] == '\\n')) {\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tstr[k] = str[i];\n\t\t\tk++;\n\t\t}\n\t\tstr[k]=0;\n\t\treturn str;\n\t}\n\n\tif (str[0]!='\\'') return str;\n\tfor (i=0; i<len; i++) {\n\t\tif (str[i] == '\\'') {\n\n\t\t\tif (!state) {\n\t\t\t\tif (k) {\n\t\t\t\t\tstr[k]='\\n';\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t\tstate = !state;\n\t\t\t} else if (state) {\n\t\t\t\tif ( (i+1==len) ||\n\t\t\t\t        ((str[i+1]==' ') || (str[i+1]=='\\n') || (str[i+1]=='\\r') || (str[i+1]=='\\t') || (str[i+1]=='\\''))\n\t\t\t\t   ) {\n\t\t\t\t\tstate = !state;\n\t\t\t\t} else {\n\t\t\t\t\tstr[k] = str[i];\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (state) {\n\t\t\tstr[k] = str[i];\n\t\t\tk++;\n\t\t}\n\t}\n\tstr[k]=0;\n\treturn str;\n}\n\nstatic void ttml_import_progress(void *cbk, u64 cur_samp, u64 count)\n{\n\tgf_set_progress(\"TTML Loading\", cur_samp, count);\n}\n\nstatic void gf_text_import_ebu_ttd_remove_samples(GF_XMLNode *root, GF_XMLNode **sample_list_node)\n{\n\tu32 idx = 0, body_num = 0;\n\tGF_XMLNode *node = NULL;\n\t*sample_list_node = NULL;\n\twhile ( (node = (GF_XMLNode*)gf_list_enum(root->content, &idx))) {\n\t\tif (!strcmp(node->name, \"body\")) {\n\t\t\tGF_XMLNode *body_node;\n\t\t\tu32 body_idx = 0;\n\t\t\twhile ( (body_node = (GF_XMLNode*)gf_list_enum(node->content, &body_idx))) {\n\t\t\t\tif (!strcmp(body_node->name, \"div\")) {\n\t\t\t\t\t*sample_list_node = body_node;\n\t\t\t\t\tbody_num = gf_list_count(body_node->content);\n\t\t\t\t\twhile (body_num--) {\n\t\t\t\t\t\tGF_XMLNode *content_node = (GF_XMLNode*)gf_list_get(body_node->content, 0);\n\t\t\t\t\t\tassert(gf_list_find(body_node->content, content_node) == 0);\n\t\t\t\t\t\tgf_list_rem(body_node->content, 0);\n\t\t\t\t\t\tgf_xml_dom_node_del(content_node);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n#define TTML_NAMESPACE \"http://www.w3.org/ns/ttml\"\nstatic GF_Err gf_text_import_ebu_ttd(GF_MediaImporter *import, GF_DOMParser *parser, GF_XMLNode *root)\n{\n\tGF_Err e, e_opt;\n\tu32 i, track, ID, desc_idx, nb_samples, nb_children;\n\tu64 last_sample_duration, last_sample_end;\n\tGF_XMLAttribute *att;\n\tGF_XMLNode *node, *root_working_copy, *sample_list_node;\n\tGF_DOMParser *parser_working_copy;\n\tchar *samp_text;\n\tBool has_body;\n\n\tsamp_text = NULL;\n\troot_working_copy = NULL;\n\tparser_working_copy = NULL;\n\n\t/*setup track in 3GP format directly (no ES desc)*/\n\tID = (import->esd) ? import->esd->ESID : 0;\n\ttrack = gf_isom_new_track(import->dest, ID, GF_ISOM_MEDIA_MPEG_SUBT, 1000);\n\tif (!track) {\n\t\te = gf_isom_last_error(import->dest);\n\t\tgoto exit;\n\t}\n\tgf_isom_set_track_enabled(import->dest, track, 1);\n\n\t/*some MPEG-4 setup*/\n\tif (import->esd) {\n\t\tif (!import->esd->ESID) import->esd->ESID = gf_isom_get_track_id(import->dest, track);\n\t\tif (!import->esd->decoderConfig) import->esd->decoderConfig = (GF_DecoderConfig *) gf_odf_desc_new(GF_ODF_DCD_TAG);\n\t\tif (!import->esd->slConfig) import->esd->slConfig = (GF_SLConfig *) gf_odf_desc_new(GF_ODF_SLC_TAG);\n\t\timport->esd->slConfig->timestampResolution = 1000;\n\t\timport->esd->decoderConfig->streamType = GF_STREAM_TEXT;\n\t\timport->esd->decoderConfig->objectTypeIndication = GPAC_OTI_TEXT_MPEG4;\n\t\tif (import->esd->OCRESID) gf_isom_set_track_reference(import->dest, track, GF_ISOM_REF_OCR, import->esd->OCRESID);\n\t}\n\n\tgf_import_message(import, GF_OK, \"TTML EBU-TTD Import\");\n\n\t/*** root (including language) ***/\n\ti=0;\n\twhile ( (att = (GF_XMLAttribute *)gf_list_enum(root->attributes, &i))) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"Found root attribute name %s, value %s\\n\", att->name, att->value));\n\n\t\tif (!strcmp(att->name, \"xmlns\")) {\n\t\t\tif (strcmp(att->value, TTML_NAMESPACE)) {\n\t\t\t\te = gf_import_message(import, GF_BAD_PARAM, \"Found invalid EBU-TTD root attribute name %s, value %s (shall be \\\"%s\\\")\\n\", att->name, att->value, TTML_NAMESPACE);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t} else if (!strcmp(att->name, \"xml:lang\")) {\n\t\t\tif (import->esd && !import->esd->langDesc) {\n\t\t\t\tchar *lang;\n\t\t\t\tlang = gf_strdup(att->value);\n\t\t\t\timport->esd->langDesc = (GF_Language *) gf_odf_desc_new(GF_ODF_LANG_TAG);\n\t\t\t\tgf_isom_set_media_language(import->dest, track, lang);\n\t\t\t} else {\n\t\t\t\tgf_isom_set_media_language(import->dest, track, att->value);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*** style ***/\n#if 0\n\t{\n\t\tBool has_styling, has_style;\n\t\tGF_TextSampleDescriptor *sd;\n\t\thas_styling = GF_FALSE;\n\t\thas_style = GF_FALSE;\n\t\tsd = (GF_TextSampleDescriptor*)gf_odf_desc_new(GF_ODF_TX3G_TAG);\n\t\ti=0;\n\t\twhile ( (node = (GF_XMLNode*)gf_list_enum(root->content, &i))) {\n\t\t\tif (node->type) {\n\t\t\t\tcontinue;\n\t\t\t} else if (gf_xml_get_element_check_namespace(node, \"head\", root->ns) == GF_OK) {\n\t\t\t\tGF_XMLNode *head_node;\n\t\t\t\tu32 head_idx = 0;\n\t\t\t\twhile ( (head_node = (GF_XMLNode*)gf_list_enum(node->content, &head_idx))) {\n\t\t\t\t\tif (gf_xml_get_element_check_namespace(head_node, \"styling\", root->ns) == GF_OK) {\n\t\t\t\t\t\tGF_XMLNode *styling_node;\n\t\t\t\t\t\tu32 styling_idx;\n\t\t\t\t\t\tif (has_styling) {\n\t\t\t\t\t\t\te = gf_import_message(import, GF_BAD_PARAM, \"[TTML EBU-TTD] duplicated \\\"styling\\\" element. Abort.\\n\");\n\t\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t\t}\n\t\t\t\t\t\thas_styling = GF_TRUE;\n\n\t\t\t\t\t\tstyling_idx = 0;\n\t\t\t\t\t\twhile ( (styling_node = (GF_XMLNode*)gf_list_enum(head_node->content, &styling_idx))) {\n\t\t\t\t\t\t\tif (gf_xml_get_element_check_namespace(styling_node, \"style\", root->ns) == GF_OK) {\n\t\t\t\t\t\t\t\tGF_XMLAttribute *p_att;\n\t\t\t\t\t\t\t\tu32 style_idx = 0;\n\t\t\t\t\t\t\t\twhile ( (p_att = (GF_XMLAttribute*)gf_list_enum(styling_node->attributes, &style_idx))) {\n\t\t\t\t\t\t\t\t\tif (!strcmp(p_att->name, \"tts:direction\")) {\n\t\t\t\t\t\t\t\t\t} else if (!strcmp(p_att->name, \"tts:fontFamily\")) {\n\t\t\t\t\t\t\t\t\t\tsd->fonts = (GF_FontRecord*)gf_malloc(sizeof(GF_FontRecord));\n\t\t\t\t\t\t\t\t\t\tsd->font_count = 1;\n\t\t\t\t\t\t\t\t\t\tsd->fonts[0].fontID = 1;\n\t\t\t\t\t\t\t\t\t\tsd->fonts[0].fontName = gf_strdup(p_att->value);\n\t\t\t\t\t\t\t\t\t} else if (!strcmp(p_att->name, \"tts:backgroundColor\")) {\n\t\t\t\t\t\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_PARSER, (\"EBU-TTD style attribute \\\"%s\\\" ignored.\\n\", p_att->name));\n\t\t\t\t\t\t\t\t\t\t//sd->back_color = ;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tif ( !strcmp(p_att->name, \"tts:fontSize\")\n\t\t\t\t\t\t\t\t\t\t        || !strcmp(p_att->name, \"tts:lineHeight\")\n\t\t\t\t\t\t\t\t\t\t        || !strcmp(p_att->name, \"tts:textAlign\")\n\t\t\t\t\t\t\t\t\t\t        || !strcmp(p_att->name, \"tts:color\")\n\t\t\t\t\t\t\t\t\t\t        || !strcmp(p_att->name, \"tts:fontStyle\")\n\t\t\t\t\t\t\t\t\t\t        || !strcmp(p_att->name, \"tts:fontWeight\")\n\t\t\t\t\t\t\t\t\t\t        || !strcmp(p_att->name, \"tts:textDecoration\")\n\t\t\t\t\t\t\t\t\t\t        || !strcmp(p_att->name, \"tts:unicodeBidi\")\n\t\t\t\t\t\t\t\t\t\t        || !strcmp(p_att->name, \"tts:wrapOption\")\n\t\t\t\t\t\t\t\t\t\t        || !strcmp(p_att->name, \"tts:multiRowAlign\")\n\t\t\t\t\t\t\t\t\t\t        || !strcmp(p_att->name, \"tts:linePadding\")) {\n\t\t\t\t\t\t\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_PARSER, (\"EBU-TTD style attribute \\\"%s\\\" ignored.\\n\", p_att->name));\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"EBU-TTD unknown style attribute: \\\"%s\\\". Ignoring.\\n\", p_att->name));\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak; //TODO: we only take care of the first style\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!has_styling) {\n\t\t\te = gf_import_message(import, GF_BAD_PARAM, \"[TTML EBU-TTD] missing \\\"styling\\\" element. Abort.\\n\");\n\t\t\tgoto exit;\n\t\t}\n\t\tif (!has_style) {\n\t\t\te = gf_import_message(import, GF_BAD_PARAM, \"[TTML EBU-TTD] missing \\\"style\\\" element. Abort.\\n\");\n\t\t\tgoto exit;\n\t\t}\n\t\te = gf_isom_new_text_description(import->dest, track, sd, NULL, NULL, &desc_idx);\n\t\tgf_odf_desc_del((GF_Descriptor*)sd);\n\t}\n#else\n\te = gf_isom_new_xml_subtitle_description(import->dest, track, TTML_NAMESPACE, NULL, NULL, &desc_idx);\n#endif\n\tif (e != GF_OK) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TTML EBU-TTD] incorrect sample description. Abort.\\n\"));\n\t\te = gf_isom_last_error(import->dest);\n\t\tgoto exit;\n\t}\n\n\t/*** body ***/\n\tparser_working_copy = gf_xml_dom_new();\n\te = gf_xml_dom_parse(parser_working_copy, import->in_name, NULL, NULL);\n\tassert (e == GF_OK);\n\troot_working_copy = gf_xml_dom_get_root(parser_working_copy);\n\tassert(root_working_copy);\n\tlast_sample_duration = 0;\n\tlast_sample_end = 0;\n\tnb_samples = 0;\n\tnb_children = gf_list_count(root->content);\n\thas_body = GF_FALSE;\n\ti=0;\n\twhile ( (node = (GF_XMLNode*)gf_list_enum(root->content, &i))) {\n\t\tif (node->type) {\n\t\t\tnb_children--;\n\t\t\tcontinue;\n\t\t}\n\n\t\te_opt = gf_xml_get_element_check_namespace(node, \"body\", root->ns);\n\t\tif (e_opt == GF_BAD_PARAM) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TTML EBU-TTD] ignored \\\"%s\\\" node, check your namespaces\\n\", node->name));\n\t\t} else if (e_opt == GF_OK) {\n\t\t\tGF_XMLNode *body_node;\n\t\t\tu32 body_idx = 0;\n\n\t\t\tif (has_body) {\n\t\t\t\te = gf_import_message(import, GF_BAD_PARAM, \"[TTML EBU-TTD] duplicated \\\"body\\\" element. Abort.\\n\");\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\thas_body = GF_TRUE;\n\n\t\t\t/*remove all the entries from the working copy, we'll add samples one to one to create full XML samples*/\n\t\t\tgf_text_import_ebu_ttd_remove_samples(root_working_copy, &sample_list_node);\n\n\t\t\twhile ( (body_node = (GF_XMLNode*)gf_list_enum(node->content, &body_idx))) {\n\t\t\t\te_opt = gf_xml_get_element_check_namespace(body_node, \"div\", root->ns);\n\t\t\t\tif (e_opt == GF_BAD_PARAM) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TTML EBU-TTD] ignored \\\"%s\\\" node, check your namespaces\\n\", node->name));\n\t\t\t\t} else if (e_opt == GF_OK) {\n\t\t\t\t\tGF_XMLNode *div_node;\n\t\t\t\t\tu32 div_idx = 0, nb_p_found = 0;\n\t\t\t\t\twhile ( (div_node = (GF_XMLNode*)gf_list_enum(body_node->content, &div_idx))) {\n\t\t\t\t\t\te_opt = gf_xml_get_element_check_namespace(div_node, \"p\", root->ns);\n\t\t\t\t\t\tif (e_opt != GF_OK) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TTML] ignored \\\"%s\\\" node, check your namespaces\\n\", node->name));\n\t\t\t\t\t\t} else if (e_opt == GF_OK) {\n\t\t\t\t\t\t\tGF_XMLNode *p_node;\n\t\t\t\t\t\t\tGF_XMLAttribute *p_att;\n\t\t\t\t\t\t\tu32 p_idx = 0, h, m, s, f, ms;\n\t\t\t\t\t\t\ts64 ts_begin = -1, ts_end = -1;\n\n\t\t\t\t\t\t\t//sample is either in the <p> ...\n\t\t\t\t\t\t\twhile ( (p_att = (GF_XMLAttribute*)gf_list_enum(div_node->attributes, &p_idx))) {\n\t\t\t\t\t\t\t\tif (!p_att) continue;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif (!strcmp(p_att->name, \"begin\")) {\n\t\t\t\t\t\t\t\t\tif (ts_begin != -1) {\n\t\t\t\t\t\t\t\t\t\te = gf_import_message(import, GF_BAD_PARAM, \"[TTML] duplicated \\\"begin\\\" attribute. Abort.\\n\");\n\t\t\t\t\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (sscanf(p_att->value, \"%u:%u:%u.%u\", &h, &m, &s, &ms) == 4) {\n\t\t\t\t\t\t\t\t\t\tts_begin = (h*3600 + m*60+s)*1000+ms;\n\t\t\t\t\t\t\t\t\t} else if (sscanf(p_att->value, \"%u:%u:%u:%u\", &h, &m, &s, &f) == 4) {\n\t\t\t\t\t\t\t\t\t\tts_begin = (h*3600 + m*60+s)*1000+f*40;\n\t\t\t\t\t\t\t\t\t} else if (sscanf(p_att->value, \"%u:%u:%u\", &h, &m, &s) == 3) {\n\t\t\t\t\t\t\t\t\t\tts_begin = (h*3600 + m*60+s)*1000;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if (!strcmp(p_att->name, \"end\")) {\n\t\t\t\t\t\t\t\t\tif (ts_end != -1) {\n\t\t\t\t\t\t\t\t\t\te = gf_import_message(import, GF_BAD_PARAM, \"[TTML] duplicated \\\"end\\\" attribute. Abort.\\n\");\n\t\t\t\t\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (sscanf(p_att->value, \"%u:%u:%u.%u\", &h, &m, &s, &ms) == 4) {\n\t\t\t\t\t\t\t\t\t\tts_end = (h*3600 + m*60+s)*1000+ms;\n\t\t\t\t\t\t\t\t\t} else if (sscanf(p_att->value, \"%u:%u:%u:%u\", &h, &m, &s, &f) == 4) {\n\t\t\t\t\t\t\t\t\t\tts_end = (h*3600 + m*60+s)*1000+f*40;\n\t\t\t\t\t\t\t\t\t} else if (sscanf(p_att->value, \"%u:%u:%u\", &h, &m, &s) == 3) {\n\t\t\t\t\t\t\t\t\t\tts_end = (h*3600 + m*60+s)*1000;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif ((ts_begin != -1) && (ts_end != -1) && !samp_text && sample_list_node) {\n\t\t\t\t\t\t\t\t\te = gf_xml_dom_append_child(sample_list_node, div_node);\n\t\t\t\t\t\t\t\t\tassert(e == GF_OK);\n\t\t\t\t\t\t\t\t\tassert(!samp_text);\n\t\t\t\t\t\t\t\t\tsamp_text = gf_xml_dom_serialize((GF_XMLNode*)root_working_copy, GF_FALSE);\n\t\t\t\t\t\t\t\t\te = gf_xml_dom_rem_child(sample_list_node, div_node);\n\t\t\t\t\t\t\t\t\tassert(e == GF_OK);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t//or under a <span>\n\t\t\t\t\t\t\tp_idx = 0;\n\t\t\t\t\t\t\twhile ( (p_node = (GF_XMLNode*)gf_list_enum(div_node->content, &p_idx))) {\n\t\t\t\t\t\t\t\te_opt = gf_xml_get_element_check_namespace(p_node, \"span\", root->ns);\n\t\t\t\t\t\t\t\tif (e_opt == GF_BAD_PARAM) {\n\t\t\t\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TTML] ignored \\\"%s\\\" node, check your namespaces\\n\", node->name));\n\t\t\t\t\t\t\t\t} else if (e_opt == GF_OK) {\n\t\t\t\t\t\t\t\t\tu32 span_idx = 0;\n\t\t\t\t\t\t\t\t\tGF_XMLAttribute *span_att;\n\t\t\t\t\t\t\t\t\twhile ( (span_att = (GF_XMLAttribute*)gf_list_enum(p_node->attributes, &span_idx))) {\n\t\t\t\t\t\t\t\t\t\tif (!span_att) continue;\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\tif (!strcmp(span_att->name, \"begin\")) {\n\t\t\t\t\t\t\t\t\t\t\tif (ts_begin != -1) {\n\t\t\t\t\t\t\t\t\t\t\t\te = gf_import_message(import, GF_BAD_PARAM, \"[TTML] duplicated \\\"begin\\\" attribute under <span>. Abort.\\n\");\n\t\t\t\t\t\t\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tif (sscanf(span_att->value, \"%u:%u:%u.%u\", &h, &m, &s, &ms) == 4) {\n\t\t\t\t\t\t\t\t\t\t\t\tts_begin = (h*3600 + m*60+s)*1000+ms;\n\t\t\t\t\t\t\t\t\t\t\t} else if (sscanf(p_att->value, \"%u:%u:%u:%u\", &h, &m, &s, &f) == 4) {\n\t\t\t\t\t\t\t\t\t\t\t\tts_begin = (h*3600 + m*60+s)*1000+f*40;\n\t\t\t\t\t\t\t\t\t\t\t} else if (sscanf(span_att->value, \"%u:%u:%u\", &h, &m, &s) == 3) {\n\t\t\t\t\t\t\t\t\t\t\t\tts_begin = (h*3600 + m*60+s)*1000;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t} else if (!strcmp(span_att->name, \"end\")) {\n\t\t\t\t\t\t\t\t\t\t\tif (ts_end != -1) {\n\t\t\t\t\t\t\t\t\t\t\t\te = gf_import_message(import, GF_BAD_PARAM, \"[TTML] duplicated \\\"end\\\" attribute under <span>. Abort.\\n\");\n\t\t\t\t\t\t\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tif (sscanf(span_att->value, \"%u:%u:%u.%u\", &h, &m, &s, &ms) == 4) {\n\t\t\t\t\t\t\t\t\t\t\t\tts_end = (h*3600 + m*60+s)*1000+ms;\n\t\t\t\t\t\t\t\t\t\t\t} else if (sscanf(p_att->value, \"%u:%u:%u:%u\", &h, &m, &s, &f) == 4) {\n\t\t\t\t\t\t\t\t\t\t\t\tts_end = (h*3600 + m*60+s)*1000+f*40;\n\t\t\t\t\t\t\t\t\t\t\t} else if (sscanf(span_att->value, \"%u:%u:%u\", &h, &m, &s) == 3) {\n\t\t\t\t\t\t\t\t\t\t\t\tts_end = (h*3600 + m*60+s)*1000;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif ((ts_begin != -1) && (ts_end != -1) && !samp_text && sample_list_node) {\n\t\t\t\t\t\t\t\t\t\t\tif (samp_text) {\n\t\t\t\t\t\t\t\t\t\t\t\te = gf_import_message(import, GF_BAD_PARAM, \"[TTML] duplicated sample text under <span>. Abort.\\n\");\n\t\t\t\t\t\t\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t/*append the sample*/\n\t\t\t\t\t\t\t\t\t\t\te = gf_xml_dom_append_child(sample_list_node, div_node);\n\t\t\t\t\t\t\t\t\t\t\tassert(e == GF_OK);\n\t\t\t\t\t\t\t\t\t\t\tassert(!samp_text);\n\t\t\t\t\t\t\t\t\t\t\tsamp_text = gf_xml_dom_serialize((GF_XMLNode*)root_working_copy, GF_FALSE);\n\t\t\t\t\t\t\t\t\t\t\te = gf_xml_dom_rem_child(sample_list_node, div_node);\n\t\t\t\t\t\t\t\t\t\t\tassert(e == GF_OK);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ((ts_begin != -1) && (ts_end != -1) && samp_text) {\n\t\t\t\t\t\t\t\tGF_ISOSample *s;\n\t\t\t\t\t\t\t\tGF_GenericSubtitleSample *samp;\n\t\t\t\t\t\t\t\tu32 len;\n\t\t\t\t\t\t\t\tchar *str;\n\n\t\t\t\t\t\t\t\tif (ts_end < ts_begin) {\n\t\t\t\t\t\t\t\t\te = gf_import_message(import, GF_BAD_PARAM, \"[TTML] invalid timings: \\\"begin\\\"=\"LLD\" , \\\"end\\\"=\"LLD\". Abort.\\n\", ts_begin, ts_end);\n\t\t\t\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (ts_begin < (s64)last_sample_end) {\n\t\t\t\t\t\t\t\t\te = gf_import_message(import, GF_BAD_PARAM, \"[TTML] timing overlapping not supported: \\\"begin\\\" is \"LLD\" , last \\\"end\\\" was \"LLD\". Abort.\\n\", ts_begin, last_sample_end);\n\t\t\t\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tstr = ttxt_parse_string(import, samp_text, GF_TRUE);\n\t\t\t\t\t\t\t\tlen = (u32) strlen(str);\n\t\t\t\t\t\t\t\tsamp = gf_isom_new_xml_subtitle_sample();\n\t\t\t\t\t\t\t\t/*each sample consists of a full valid XML file*/\n\t\t\t\t\t\t\t\te = gf_isom_xml_subtitle_sample_add_text(samp, str, len);\n\t\t\t\t\t\t\t\tif (e) {\n\t\t\t\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TTML] ISOM - sample add text: %s\", gf_error_to_string(e)));\n\t\t\t\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tgf_free(samp_text);\n\t\t\t\t\t\t\t\tsamp_text = NULL;\n\n\t\t\t\t\t\t\t\ts = gf_isom_xml_subtitle_to_sample(samp);\n\t\t\t\t\t\t\t\tgf_isom_delete_xml_subtitle_sample(samp);\n\t\t\t\t\t\t\t\tif (!nb_samples) {\n\t\t\t\t\t\t\t\t\ts->DTS = 0; /*in MP4 we must start at T=0*/\n\t\t\t\t\t\t\t\t\tlast_sample_duration = ts_end;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ts->DTS = ts_begin;\n\t\t\t\t\t\t\t\t\tlast_sample_duration = ts_end - ts_begin;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlast_sample_end = ts_end;\n\t\t\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"ts_begin=\"LLD\", ts_end=\"LLD\", last_sample_duration=\"LLU\" (real duration: \"LLU\"), last_sample_end=\"LLU\"\\n\", ts_begin, ts_end, ts_end - last_sample_end, last_sample_duration, last_sample_end));\n\n\t\t\t\t\t\t\t\te = gf_isom_add_sample(import->dest, track, desc_idx, s);\n\t\t\t\t\t\t\t\tif (e) {\n\t\t\t\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TTML] ISOM - Add Sample: %s\", gf_error_to_string(e)));\n\t\t\t\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tgf_isom_sample_del(&s);\n\t\t\t\t\t\t\t\tnb_samples++;\n\n\t\t\t\t\t\t\t\tnb_p_found++;\n\t\t\t\t\t\t\t\tgf_set_progress(\"Importing TTML\", nb_samples, nb_children);\n\t\t\t\t\t\t\t\tif (import->duration && (ts_end > import->duration))\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TTML] incomplete sample (begin=\"LLD\", end=\"LLD\", text=\\\"%s\\\"). Skip.\\n\", ts_begin, ts_end, samp_text ? samp_text : \"NULL\"));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!nb_p_found) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TTML EBU-TTD] \\\"%s\\\" div node has no <p> elements. Aborting.\\n\", node->name));\n\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!has_body) {\n\t\te = gf_import_message(import, GF_BAD_PARAM, \"[TTML EBU-TTD] missing \\\"body\\\" element. Abort.\\n\");\n\t\tgoto exit;\n\t}\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"last_sample_duration=\"LLU\", last_sample_end=\"LLU\"\\n\", last_sample_duration, last_sample_end));\n\tgf_isom_set_last_sample_duration(import->dest, track, (u32) last_sample_duration);\n\tgf_media_update_bitrate(import->dest, track);\n\tgf_set_progress(\"Importing TTML EBU-TTD\", nb_samples, nb_samples);\n\nexit:\n\tgf_free(samp_text);\n\tgf_xml_dom_del(parser_working_copy);\n\tif (!gf_isom_get_sample_count(import->dest, track)) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TTML EBU-TTD] No sample imported. Might be an error. Check your content.\\n\"));\n\t}\n\treturn e;\n}\n\nstatic GF_Err gf_text_import_ttml(GF_MediaImporter *import)\n{\n\tGF_Err e;\n\tGF_DOMParser *parser;\n\tGF_XMLNode *root;\n\n\tif (import->flags == GF_IMPORT_PROBE_ONLY)\n\t\treturn GF_OK;\n\n\tparser = gf_xml_dom_new();\n\te = gf_xml_dom_parse(parser, import->in_name, ttml_import_progress, import);\n\tif (e) {\n\t\tgf_import_message(import, e, \"Error parsing TTML file: Line %d - %s. Abort.\", gf_xml_dom_get_line(parser), gf_xml_dom_get_error(parser));\n\t\tgf_xml_dom_del(parser);\n\t\treturn e;\n\t}\n\troot = gf_xml_dom_get_root(parser);\n\tif (!root) {\n\t\tgf_import_message(import, e, \"Error parsing TTML file: no \\\"root\\\" found. Abort.\");\n\t\tgf_xml_dom_del(parser);\n\t\treturn e;\n\t}\n\n\t/*look for TTML*/\n\tif (gf_xml_get_element_check_namespace(root, \"tt\", NULL) == GF_OK) {\n\t\te = gf_text_import_ebu_ttd(import, parser, root);\n\t\tif (e == GF_OK) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"Note: TTML import - EBU-TTD detected\\n\"));\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"Parsing TTML file with error: %s\\n\", gf_error_to_string(e)));\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_PARSER, (\"Unsupported TTML file - only EBU-TTD is supported (root shall be \\\"tt\\\", got \\\"%s\\\")\\n\", root->name));\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_PARSER, (\"Importing as generic TTML\\n\"));\n\t\t\te = GF_OK;\n\t\t}\n\t} else {\n\t\tif (root->ns) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"TTML file not recognized: root element is \\\"%s:%s\\\" (check your namespaces)\\n\", root->ns, root->name));\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"TTML file not recognized: root element is \\\"%s\\\"\\n\", root->name));\n\t\t}\n\t\te = GF_BAD_PARAM;\n\t}\n\n\tgf_xml_dom_del(parser);\n\treturn e;\n}\n\n/* SimpleText Text tracks -related functions */\nGF_Box *boxstring_new_with_data(u32 type, const char *string);\n\n#ifndef GPAC_DISABLE_SWF_IMPORT\n\n/* SWF Importer */\n#include <gpac/internal/swf_dev.h>\n\nstatic GF_Err swf_svg_add_iso_sample(void *user, const char *data, u32 length, u64 timestamp, Bool isRap)\n{\n\tGF_Err\t\t\t\te = GF_OK;\n\tGF_ISOFlusher\t\t*flusher = (GF_ISOFlusher *)user;\n\tGF_ISOSample\t\t*s;\n\tGF_BitStream\t\t*bs;\n\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tif (!bs) return GF_BAD_PARAM;\n\tgf_bs_write_data(bs, data, length);\n\ts = gf_isom_sample_new();\n\tif (s) {\n\t\tgf_bs_get_content(bs, &s->data, &s->dataLength);\n\t\ts->DTS = (u64) (flusher->timescale*timestamp/1000);\n\t\ts->IsRAP = isRap ? RAP : RAP_NO;\n\t\tgf_isom_add_sample(flusher->import->dest, flusher->track, flusher->descriptionIndex, s);\n\t\tgf_isom_sample_del(&s);\n\t} else {\n\t\te = GF_BAD_PARAM;\n\t}\n\tgf_bs_del(bs);\n\treturn e;\n}\n\nstatic GF_Err swf_svg_add_iso_header(void *user, const char *data, u32 length, Bool isHeader)\n{\n\tGF_ISOFlusher\t\t*flusher = (GF_ISOFlusher *)user;\n\tif (!flusher) return GF_BAD_PARAM;\n\tif (isHeader) {\n\t\treturn gf_isom_update_stxt_description(flusher->import->dest, flusher->track, NULL, data, flusher->descriptionIndex);\n\t} else {\n\t\treturn gf_isom_append_sample_data(flusher->import->dest, flusher->track, (char *)data, length);\n\t}\n}\n\nGF_EXPORT\nGF_Err gf_text_import_swf(GF_MediaImporter *import)\n{\n\tGF_Err\t\t\t\t\t\te = GF_OK;\n\tu32\t\t\t\t\t\t\ttrack;\n\tu32\t\t\t\t\t\t\ttimescale;\n\t//u32\t\t\t\t\t\t\tduration;\n\tu32\t\t\t\t\t\t\tdescIndex;\n\tu32\t\t\t\t\t\t\tID;\n\tu32\t\t\t\t\t\t\tOCR_ES_ID;\n\tGF_GenericSubtitleConfig\t*cfg;\n\tSWFReader\t\t\t\t\t*read;\n\tGF_ISOFlusher\t\t\t\tflusher;\n\tchar\t\t\t\t\t\t*mime;\n\n\tif (import->flags & GF_IMPORT_PROBE_ONLY) {\n\t\timport->nb_tracks = 1;\n\t\treturn GF_OK;\n\t}\n\n\tcfg\t= NULL;\n\tif (import->esd) {\n\t\tif (!import->esd->slConfig)\t{\n\t\t\timport->esd->slConfig =\t(GF_SLConfig *)\tgf_odf_desc_new(GF_ODF_SLC_TAG);\n\t\t\timport->esd->slConfig->predefined =\t2;\n\t\t\timport->esd->slConfig->timestampResolution = 1000;\n\t\t}\n\t\ttimescale =\timport->esd->slConfig->timestampResolution;\n\t\tif (!timescale)\ttimescale =\t1000;\n\n\t\t/*explicit text\tconfig*/\n\t\tif (import->esd->decoderConfig && import->esd->decoderConfig->decoderSpecificInfo->tag == GF_ODF_GEN_SUB_CFG_TAG) {\n\t\t\tcfg\t= (GF_GenericSubtitleConfig\t*) import->esd->decoderConfig->decoderSpecificInfo;\n\t\t\timport->esd->decoderConfig->decoderSpecificInfo\t= NULL;\n\t\t}\n\t\tID = import->esd->ESID;\n\t\tOCR_ES_ID =\timport->esd->OCRESID;\n\t} else {\n\t\ttimescale =\t1000;\n\t\tOCR_ES_ID =\tID = 0;\n\t}\n\n\tif (cfg\t&& cfg->timescale) timescale = cfg->timescale;\n\ttrack =\tgf_isom_new_track(import->dest,\tID,\tGF_ISOM_MEDIA_TEXT,\ttimescale);\n\tif (!track)\t{\n\t\treturn gf_import_message(import, gf_isom_last_error(import->dest), \"Error creating text track\");\n\t}\n\tgf_isom_set_track_enabled(import->dest,\ttrack, 1);\n\tif (import->esd\t&& !import->esd->ESID) import->esd->ESID = gf_isom_get_track_id(import->dest, track);\n\n\tif (OCR_ES_ID) gf_isom_set_track_reference(import->dest, track,\tGF_ISOM_REF_OCR, OCR_ES_ID);\n\n\tif (!stricmp(import->streamFormat, \"SVG\")) {\n\t\tmime = \"image/svg+xml\";\n\t} else {\n\t\tmime = \"application/octet-stream\";\n\t}\n\n\tread = gf_swf_reader_new(NULL, import->in_name);\n\tgf_swf_read_header(read);\n\n\t/*setup\ttrack*/\n\tif (cfg) {\n\t\tu32\ti;\n\t\tu32\tcount;\n\t\t/*set track\tinfo*/\n\t\tgf_isom_set_track_layout_info(import->dest,\ttrack, cfg->text_width<<16,\tcfg->text_height<<16, 0, 0,\tcfg->layer);\n\n\t\t/*and set sample descriptions*/\n\t\tcount =\tgf_list_count(cfg->sample_descriptions);\n\t\tfor\t(i=0; i<count; i++)\t{\n\t\t\tgf_isom_new_stxt_description(import->dest, track, GF_ISOM_SUBTYPE_STXT, mime, NULL, NULL, &descIndex);\n\t\t}\n\t\tgf_import_message(import, GF_OK, \"SWF import - text track %d\tx %d\", cfg->text_width,\tcfg->text_height);\n\t\tgf_odf_desc_del((GF_Descriptor *)cfg);\n\t} else {\n\t\tu32\tw = (u32)read->width;\n\t\tu32\th = (u32)read->height;\n\n\t\tif (!w || !h)\n\t\t\tgf_text_get_video_size(import, &w, &h);\n\n\t\tgf_isom_set_track_layout_info(import->dest,\ttrack, w<<16, h<<16, 0,\t0, 0);\n\n\t\tgf_isom_new_stxt_description(import->dest, track, GF_ISOM_SUBTYPE_STXT, mime, NULL,\tNULL, &descIndex);\n\n\t\tgf_import_message(import, GF_OK, \"SWF import (as text - type: %s)\", import->streamFormat);\n\t}\n\tgf_text_import_set_language(import, track);\n\t//duration = (u32) (((Double) import->duration)*timescale/1000.0);\n\n\tflusher.import = import;\n\tflusher.track = track;\n\tflusher.timescale = timescale;\n\tflusher.descriptionIndex = descIndex;\n\tgf_swf_reader_set_user_mode(read, &flusher, swf_svg_add_iso_sample, swf_svg_add_iso_header);\n\n\tif (!import->streamFormat || (import->streamFormat && !stricmp(import->streamFormat, \"SVG\"))) {\n#ifndef GPAC_DISABLE_SVG\n\t\te = swf_to_svg_init(read, import->swf_flags, import->swf_flatten_angle);\n#endif\n\t} else { /*if (import->streamFormat && !strcmp(import->streamFormat, \"BIFS\"))*/\n#ifndef GPAC_DISABLE_VRML\n\t\te = swf_to_bifs_init(read);\n#endif\n\t}\n\tif (e) {\n\t\tgoto exit;\n\t}\n\t/*parse all tags*/\n\twhile (e == GF_OK) {\n\t\te = swf_parse_tag(read);\n\t}\n\tif (e==GF_EOS) e = GF_OK;\nexit:\n\tgf_swf_reader_del(read);\n\tgf_media_update_bitrate(import->dest, track);\n\treturn e;\n}\n/* end of SWF Importer */\n\n#else\n\nGF_EXPORT\nGF_Err gf_text_import_swf(GF_MediaImporter *import)\n{\n\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"Warning: GPAC was compiled without SWF import support, can't import track.\\n\"));\n\treturn GF_NOT_SUPPORTED;\n}\n\n#endif /*GPAC_DISABLE_SWF_IMPORT*/\n\nstatic GF_Err gf_text_import_sub(GF_MediaImporter *import)\n{\n\tFILE *sub_in;\n\tu32 track, ID, timescale, i, j, desc_idx, start, end, prev_end, nb_samp, duration, len, line;\n\tu64 file_size;\n\tGF_TextConfig*cfg;\n\tGF_Err e;\n\tDouble FPS;\n\tGF_TextSample * samp;\n\tBool first_samp;\n\ts32 unicode_type;\n\tchar szLine[2048], szTime[20], szText[2048];\n\tGF_ISOSample *s;\n\n\tsub_in = gf_fopen(import->in_name, \"rt\");\n\tunicode_type = gf_text_get_utf_type(sub_in);\n\tif (unicode_type<0) {\n\t\tgf_fclose(sub_in);\n\t\treturn gf_import_message(import, GF_NOT_SUPPORTED, \"Unsupported SUB UTF encoding\");\n\t}\n\n\tFPS = GF_IMPORT_DEFAULT_FPS;\n\tif (import->video_fps) FPS = import->video_fps;\n\n\tcfg = NULL;\n\tif (import->esd) {\n\t\tif (!import->esd->slConfig) {\n\t\t\timport->esd->slConfig = (GF_SLConfig *) gf_odf_desc_new(GF_ODF_SLC_TAG);\n\t\t\timport->esd->slConfig->predefined = 2;\n\t\t\timport->esd->slConfig->timestampResolution = 1000;\n\t\t}\n\t\ttimescale = import->esd->slConfig->timestampResolution;\n\t\tif (!timescale) timescale = 1000;\n\n\t\t/*explicit text config*/\n\t\tif (import->esd->decoderConfig && import->esd->decoderConfig->decoderSpecificInfo->tag == GF_ODF_TEXT_CFG_TAG) {\n\t\t\tcfg = (GF_TextConfig *) import->esd->decoderConfig->decoderSpecificInfo;\n\t\t\timport->esd->decoderConfig->decoderSpecificInfo = NULL;\n\t\t}\n\t\tID = import->esd->ESID;\n\t} else {\n\t\ttimescale = 1000;\n\t\tID = 0;\n\t}\n\n\tif (cfg && cfg->timescale) timescale = cfg->timescale;\n\ttrack = gf_isom_new_track(import->dest, ID, GF_ISOM_MEDIA_TEXT, timescale);\n\tif (!track) {\n\t\tgf_fclose(sub_in);\n\t\treturn gf_import_message(import, gf_isom_last_error(import->dest), \"Error creating text track\");\n\t}\n\tgf_isom_set_track_enabled(import->dest, track, 1);\n\tif (import->esd && !import->esd->ESID) import->esd->ESID = gf_isom_get_track_id(import->dest, track);\n\n\tgf_text_import_set_language(import, track);\n\n\tfile_size = 0;\n\t/*setup track*/\n\tif (cfg) {\n\t\tu32 count;\n\t\tchar *firstFont = NULL;\n\t\t/*set track info*/\n\t\tgf_isom_set_track_layout_info(import->dest, track, cfg->text_width<<16, cfg->text_height<<16, 0, 0, cfg->layer);\n\n\t\t/*and set sample descriptions*/\n\t\tcount = gf_list_count(cfg->sample_descriptions);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_TextSampleDescriptor *sd= (GF_TextSampleDescriptor *)gf_list_get(cfg->sample_descriptions, i);\n\t\t\tif (!sd->font_count) {\n\t\t\t\tsd->fonts = (GF_FontRecord*)gf_malloc(sizeof(GF_FontRecord));\n\t\t\t\tsd->font_count = 1;\n\t\t\t\tsd->fonts[0].fontID = 1;\n\t\t\t\tsd->fonts[0].fontName = gf_strdup(\"Serif\");\n\t\t\t}\n\t\t\tif (!sd->default_style.fontID) sd->default_style.fontID = sd->fonts[0].fontID;\n\t\t\tif (!sd->default_style.font_size) sd->default_style.font_size = 16;\n\t\t\tif (!sd->default_style.text_color) sd->default_style.text_color = 0xFF000000;\n\t\t\tfile_size = sd->default_style.font_size;\n\t\t\tgf_isom_new_text_description(import->dest, track, sd, NULL, NULL, &desc_idx);\n\t\t\tif (!firstFont) firstFont = sd->fonts[0].fontName;\n\t\t}\n\t\tgf_import_message(import, GF_OK, \"Timed Text (SUB @ %02.2f) import - text track %d x %d, font %s (size %d)\", FPS, cfg->text_width, cfg->text_height, firstFont, file_size);\n\n\t\tgf_odf_desc_del((GF_Descriptor *)cfg);\n\t} else {\n\t\tu32 w, h;\n\t\tGF_TextSampleDescriptor *sd;\n\t\tgf_text_get_video_size(import, &w, &h);\n\n\t\t/*have to work with default - use max size (if only one video, this means the text region is the\n\t\tentire display, and with bottom alignment things should be fine...*/\n\t\tgf_isom_set_track_layout_info(import->dest, track, w<<16, h<<16, 0, 0, 0);\n\t\tsd = (GF_TextSampleDescriptor*)gf_odf_desc_new(GF_ODF_TX3G_TAG);\n\t\tsd->fonts = (GF_FontRecord*)gf_malloc(sizeof(GF_FontRecord));\n\t\tsd->font_count = 1;\n\t\tsd->fonts[0].fontID = 1;\n\t\tsd->fonts[0].fontName = gf_strdup(\"Serif\");\n\t\tsd->back_color = 0x00000000;\t/*transparent*/\n\t\tsd->default_style.fontID = 1;\n\t\tsd->default_style.font_size = TTXT_DEFAULT_FONT_SIZE;\n\t\tsd->default_style.text_color = 0xFFFFFFFF;\t/*white*/\n\t\tsd->default_style.style_flags = 0;\n\t\tsd->horiz_justif = 1; /*center of scene*/\n\t\tsd->vert_justif = (s8) -1;\t/*bottom of scene*/\n\n\t\tif (import->flags & GF_IMPORT_SKIP_TXT_BOX) {\n\t\t\tsd->default_pos.top = sd->default_pos.left = sd->default_pos.right = sd->default_pos.bottom = 0;\n\t\t} else {\n\t\t\tif ((sd->default_pos.bottom==sd->default_pos.top) || (sd->default_pos.right==sd->default_pos.left)) {\n\t\t\t\tsd->default_pos.left = import->text_x;\n\t\t\t\tsd->default_pos.top = import->text_y;\n\t\t\t\tsd->default_pos.right = (import->text_width ? import->text_width : w) + sd->default_pos.left;\n\t\t\t\tsd->default_pos.bottom = (import->text_height ? import->text_height : h) + sd->default_pos.top;\n\t\t\t}\n\t\t}\n\n\t\tgf_isom_new_text_description(import->dest, track, sd, NULL, NULL, &desc_idx);\n\t\tgf_import_message(import, GF_OK, \"Timed Text (SUB @ %02.2f) import - text track %d x %d, font %s (size %d)\", FPS, w, h, sd->fonts[0].fontName, TTXT_DEFAULT_FONT_SIZE);\n\t\tgf_odf_desc_del((GF_Descriptor *)sd);\n\t}\n\n\tduration = (u32) (((Double) import->duration)*timescale/1000.0);\n\n\te = GF_OK;\n\tnb_samp = 0;\n\tsamp = gf_isom_new_text_sample();\n\n\tFPS = ((Double) timescale ) / FPS;\n\tend = prev_end = 0;\n\n\tline = 0;\n\tfirst_samp = GF_TRUE;\n\twhile (1) {\n\t\tchar *sOK = gf_text_get_utf8_line(szLine, 2048, sub_in, unicode_type);\n\t\tif (!sOK) break;\n\n\t\tREM_TRAIL_MARKS(szLine, \"\\r\\n\\t \")\n\n\t\tline++;\n\t\tlen = (u32) strlen(szLine);\n\t\tif (!len) continue;\n\n\t\ti=0;\n\t\tif (szLine[i] != '{') {\n\t\t\te = gf_import_message(import, GF_NON_COMPLIANT_BITSTREAM, \"Bad SUB file (line %d): expecting \\\"{\\\" got \\\"%c\\\"\", line, szLine[i]);\n\t\t\tgoto exit;\n\t\t}\n\t\twhile (szLine[i+1] && szLine[i+1]!='}') {\n\t\t\tszTime[i] = szLine[i+1];\n\t\t\ti++;\n\t\t}\n\t\tszTime[i] = 0;\n\t\tstart = atoi(szTime);\n\t\tif (start<end) {\n\t\t\tgf_import_message(import, GF_OK, \"WARNING: corrupted SUB frame (line %d) - starts (at %d ms) before end of previous one (%d ms) - adjusting time stamps\", line, start, end);\n\t\t\tstart = end;\n\t\t}\n\t\tj=i+2;\n\t\ti=0;\n\t\tif (szLine[i+j] != '{') {\n\t\t\te = gf_import_message(import, GF_NON_COMPLIANT_BITSTREAM, \"Bad SUB file - expecting \\\"{\\\" got \\\"%c\\\"\", szLine[i]);\n\t\t\tgoto exit;\n\t\t}\n\t\twhile (szLine[i+1+j] && szLine[i+1+j]!='}') {\n\t\t\tszTime[i] = szLine[i+1+j];\n\t\t\ti++;\n\t\t}\n\t\tszTime[i] = 0;\n\t\tend = atoi(szTime);\n\t\tj+=i+2;\n\n\t\tif (start>end) {\n\t\t\tgf_import_message(import, GF_OK, \"WARNING: corrupted SUB frame (line %d) - ends (at %d ms) before start of current frame (%d ms) - skipping\", line, end, start);\n\t\t\tcontinue;\n\t\t}\n\n\t\tgf_isom_text_reset(samp);\n\n\t\tif (start && first_samp) {\n\t\t\ts = gf_isom_text_to_sample(samp);\n\t\t\ts->DTS = 0;\n\t\t\ts->IsRAP = RAP;\n\t\t\tgf_isom_add_sample(import->dest, track, 1, s);\n\t\t\tgf_isom_sample_del(&s);\n\t\t\tfirst_samp = GF_FALSE;\n\t\t\tnb_samp++;\n\t\t}\n\n\t\tfor (i=j; i<len; i++) {\n\t\t\tif (szLine[i]=='|') {\n\t\t\t\tszText[i-j] = '\\n';\n\t\t\t} else {\n\t\t\t\tszText[i-j] = szLine[i];\n\t\t\t}\n\t\t}\n\t\tszText[i-j] = 0;\n\t\tgf_isom_text_add_text(samp, szText, (u32) strlen(szText) );\n\n\t\tif (prev_end) {\n\t\t\tGF_TextSample * empty_samp = gf_isom_new_text_sample();\n\t\t\ts = gf_isom_text_to_sample(empty_samp);\n\t\t\ts->DTS = (u64) (FPS*(s64)prev_end);\n\t\t\tgf_isom_add_sample(import->dest, track, 1, s);\n\t\t\tgf_isom_sample_del(&s);\n\t\t\tnb_samp++;\n\t\t\tgf_isom_delete_text_sample(empty_samp);\n\t\t}\n\n\t\ts = gf_isom_text_to_sample(samp);\n\t\ts->DTS = (u64) (FPS*(s64)start);\n\t\tgf_isom_add_sample(import->dest, track, 1, s);\n\t\tgf_isom_sample_del(&s);\n\t\tnb_samp++;\n\t\tgf_isom_text_reset(samp);\n\t\tprev_end = end;\n\t\tgf_set_progress(\"Importing SUB\", gf_ftell(sub_in), file_size);\n\t\tif (duration && (end >= duration)) break;\n\t}\n\t/*final flush*/\n\tif (end && !(import->flags & GF_IMPORT_NO_TEXT_FLUSH ) ) {\n\t\tgf_isom_text_reset(samp);\n\t\ts = gf_isom_text_to_sample(samp);\n\t\ts->DTS = (u64)(FPS*(s64)end);\n\t\tgf_isom_add_sample(import->dest, track, 1, s);\n\t\tgf_isom_sample_del(&s);\n\t\tnb_samp++;\n\t}\n\tgf_isom_delete_text_sample(samp);\n\t\n\tgf_isom_set_last_sample_duration(import->dest, track, 0);\n\tgf_set_progress(\"Importing SUB\", nb_samp, nb_samp);\n\nexit:\n\tif (e) gf_isom_remove_track(import->dest, track);\n\tgf_fclose(sub_in);\n\treturn e;\n}\n\n\n#define CHECK_STR(__str)\t\\\n\tif (!__str) { \\\n\t\te = gf_import_message(import, GF_BAD_PARAM, \"Invalid XML formatting (line %d)\", parser.line);\t\\\n\t\tgoto exit;\t\\\n\t}\t\\\n \n\nu32 ttxt_get_color(GF_MediaImporter *import, char *val)\n{\n\tu32 r, g, b, a, res;\n\tr = g = b = a = 0;\n\tif (sscanf(val, \"%x %x %x %x\", &r, &g, &b, &a) != 4) {\n\t\tgf_import_message(import, GF_OK, \"Warning: color badly formatted\");\n\t}\n\tres = (a&0xFF);\n\tres<<=8;\n\tres |= (r&0xFF);\n\tres<<=8;\n\tres |= (g&0xFF);\n\tres<<=8;\n\tres |= (b&0xFF);\n\treturn res;\n}\n\nvoid ttxt_parse_text_box(GF_MediaImporter *import, GF_XMLNode *n, GF_BoxRecord *box)\n{\n\tu32 i=0;\n\tGF_XMLAttribute *att;\n\tmemset(box, 0, sizeof(GF_BoxRecord));\n\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(n->attributes, &i))) {\n\t\tif (!stricmp(att->name, \"top\")) box->top = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"bottom\")) box->bottom = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"left\")) box->left = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"right\")) box->right = atoi(att->value);\n\t}\n}\n\nvoid ttxt_parse_text_style(GF_MediaImporter *import, GF_XMLNode *n, GF_StyleRecord *style)\n{\n\tu32 i=0;\n\tGF_XMLAttribute *att;\n\tmemset(style, 0, sizeof(GF_StyleRecord));\n\tstyle->fontID = 1;\n\tstyle->font_size = TTXT_DEFAULT_FONT_SIZE;\n\tstyle->text_color = 0xFFFFFFFF;\n\n\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(n->attributes, &i))) {\n\t\tif (!stricmp(att->name, \"fromChar\")) style->startCharOffset = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"toChar\")) style->endCharOffset = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"fontID\")) style->fontID = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"fontSize\")) style->font_size = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"color\")) style->text_color = ttxt_get_color(import, att->value);\n\t\telse if (!stricmp(att->name, \"styles\")) {\n\t\t\tif (strstr(att->value, \"Bold\")) style->style_flags |= GF_TXT_STYLE_BOLD;\n\t\t\tif (strstr(att->value, \"Italic\")) style->style_flags |= GF_TXT_STYLE_ITALIC;\n\t\t\tif (strstr(att->value, \"Underlined\")) style->style_flags |= GF_TXT_STYLE_UNDERLINED;\n\t\t}\n\t}\n}\n\nstatic void ttxt_import_progress(void *cbk, u64 cur_samp, u64 count)\n{\n\tgf_set_progress(\"TTXT Loading\", cur_samp, count);\n}\n\nstatic GF_Err gf_text_import_ttxt(GF_MediaImporter *import)\n{\n\tGF_Err e;\n\tBool last_sample_empty;\n\tu32 i, j, k, track, ID, nb_samples, nb_descs, nb_children;\n\tu64 last_sample_duration;\n\tGF_XMLAttribute *att;\n\tGF_DOMParser *parser;\n\tGF_XMLNode *root, *node, *ext;\n\n\tif (import->flags==GF_IMPORT_PROBE_ONLY) return GF_OK;\n\n\tparser = gf_xml_dom_new();\n\te = gf_xml_dom_parse(parser, import->in_name, ttxt_import_progress, import);\n\tif (e) {\n\t\tgf_import_message(import, e, \"Error parsing TTXT file: Line %d - %s\", gf_xml_dom_get_line(parser), gf_xml_dom_get_error(parser));\n\t\tgf_xml_dom_del(parser);\n\t\treturn e;\n\t}\n\troot = gf_xml_dom_get_root(parser);\n\n\te = GF_OK;\n\tif (strcmp(root->name, \"TextStream\")) {\n\t\te = gf_import_message(import, GF_BAD_PARAM, \"Invalid Timed Text file - expecting \\\"TextStream\\\" got %s\", \"TextStream\", root->name);\n\t\tgoto exit;\n\t}\n\n\t/*setup track in 3GP format directly (no ES desc)*/\n\tID = (import->esd) ? import->esd->ESID : 0;\n\ttrack = gf_isom_new_track(import->dest, ID, GF_ISOM_MEDIA_TEXT, 1000);\n\tif (!track) {\n\t\te = gf_isom_last_error(import->dest);\n\t\tgoto exit;\n\t}\n\tgf_isom_set_track_enabled(import->dest, track, 1);\n\t/*some MPEG-4 setup*/\n\tif (import->esd) {\n\t\tif (!import->esd->ESID) import->esd->ESID = gf_isom_get_track_id(import->dest, track);\n\t\tif (!import->esd->decoderConfig) import->esd->decoderConfig = (GF_DecoderConfig *) gf_odf_desc_new(GF_ODF_DCD_TAG);\n\t\tif (!import->esd->slConfig) import->esd->slConfig = (GF_SLConfig *) gf_odf_desc_new(GF_ODF_SLC_TAG);\n\t\timport->esd->slConfig->timestampResolution = 1000;\n\t\timport->esd->decoderConfig->streamType = GF_STREAM_TEXT;\n\t\timport->esd->decoderConfig->objectTypeIndication = GPAC_OTI_TEXT_MPEG4;\n\t\tif (import->esd->OCRESID) gf_isom_set_track_reference(import->dest, track, GF_ISOM_REF_OCR, import->esd->OCRESID);\n\t}\n\tgf_text_import_set_language(import, track);\n\n\tgf_import_message(import, GF_OK, \"Timed Text (GPAC TTXT) Import\");\n\n\tlast_sample_empty = GF_FALSE;\n\tlast_sample_duration = 0;\n\tnb_descs = 0;\n\tnb_samples = 0;\n\tnb_children = gf_list_count(root->content);\n\n\ti=0;\n\twhile ( (node = (GF_XMLNode*)gf_list_enum(root->content, &i))) {\n\t\tif (node->type) {\n\t\t\tnb_children--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strcmp(node->name, \"TextStreamHeader\")) {\n\t\t\tGF_XMLNode *sdesc;\n\t\t\ts32 w, h, tx, ty, layer;\n\t\t\tu32 tref_id;\n\t\t\tw = TTXT_DEFAULT_WIDTH;\n\t\t\th = TTXT_DEFAULT_HEIGHT;\n\t\t\ttx = ty = layer = 0;\n\t\t\tnb_children--;\n\t\t\ttref_id = 0;\n\n\t\t\tj=0;\n\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(node->attributes, &j))) {\n\t\t\t\tif (!strcmp(att->name, \"width\")) w = atoi(att->value);\n\t\t\t\telse if (!strcmp(att->name, \"height\")) h = atoi(att->value);\n\t\t\t\telse if (!strcmp(att->name, \"layer\")) layer = atoi(att->value);\n\t\t\t\telse if (!strcmp(att->name, \"translation_x\")) tx = atoi(att->value);\n\t\t\t\telse if (!strcmp(att->name, \"translation_y\")) ty = atoi(att->value);\n\t\t\t\telse if (!strcmp(att->name, \"trefID\")) tref_id = atoi(att->value);\n\t\t\t}\n\n\t\t\tif (tref_id)\n\t\t\t\tgf_isom_set_track_reference(import->dest, track, GF_ISOM_BOX_TYPE_CHAP, tref_id);\n\n\t\t\tgf_isom_set_track_layout_info(import->dest, track, w<<16, h<<16, tx<<16, ty<<16, (s16) layer);\n\n\t\t\tj=0;\n\t\t\twhile ( (sdesc=(GF_XMLNode*)gf_list_enum(node->content, &j))) {\n\t\t\t\tif (sdesc->type) continue;\n\n\t\t\t\tif (!strcmp(sdesc->name, \"TextSampleDescription\")) {\n\t\t\t\t\tGF_TextSampleDescriptor td;\n\t\t\t\t\tu32 idx;\n\t\t\t\t\tmemset(&td, 0, sizeof(GF_TextSampleDescriptor));\n\t\t\t\t\ttd.tag = GF_ODF_TEXT_CFG_TAG;\n\t\t\t\t\ttd.vert_justif = (s8) -1;\n\t\t\t\t\ttd.default_style.fontID = 1;\n\t\t\t\t\ttd.default_style.font_size = TTXT_DEFAULT_FONT_SIZE;\n\n\t\t\t\t\tk=0;\n\t\t\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(sdesc->attributes, &k))) {\n\t\t\t\t\t\tif (!strcmp(att->name, \"horizontalJustification\")) {\n\t\t\t\t\t\t\tif (!stricmp(att->value, \"center\")) td.horiz_justif = 1;\n\t\t\t\t\t\t\telse if (!stricmp(att->value, \"right\")) td.horiz_justif = (s8) -1;\n\t\t\t\t\t\t\telse if (!stricmp(att->value, \"left\")) td.horiz_justif = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (!strcmp(att->name, \"verticalJustification\")) {\n\t\t\t\t\t\t\tif (!stricmp(att->value, \"center\")) td.vert_justif = 1;\n\t\t\t\t\t\t\telse if (!stricmp(att->value, \"bottom\")) td.vert_justif = (s8) -1;\n\t\t\t\t\t\t\telse if (!stricmp(att->value, \"top\")) td.vert_justif = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (!strcmp(att->name, \"backColor\")) td.back_color = ttxt_get_color(import, att->value);\n\t\t\t\t\t\telse if (!strcmp(att->name, \"verticalText\") && !stricmp(att->value, \"yes\") ) td.displayFlags |= GF_TXT_VERTICAL;\n\t\t\t\t\t\telse if (!strcmp(att->name, \"fillTextRegion\") && !stricmp(att->value, \"yes\") ) td.displayFlags |= GF_TXT_FILL_REGION;\n\t\t\t\t\t\telse if (!strcmp(att->name, \"continuousKaraoke\") && !stricmp(att->value, \"yes\") ) td.displayFlags |= GF_TXT_KARAOKE;\n\t\t\t\t\t\telse if (!strcmp(att->name, \"scroll\")) {\n\t\t\t\t\t\t\tif (!stricmp(att->value, \"inout\")) td.displayFlags |= GF_TXT_SCROLL_IN | GF_TXT_SCROLL_OUT;\n\t\t\t\t\t\t\telse if (!stricmp(att->value, \"in\")) td.displayFlags |= GF_TXT_SCROLL_IN;\n\t\t\t\t\t\t\telse if (!stricmp(att->value, \"out\")) td.displayFlags |= GF_TXT_SCROLL_OUT;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (!strcmp(att->name, \"scrollMode\")) {\n\t\t\t\t\t\t\tu32 scroll_mode = GF_TXT_SCROLL_CREDITS;\n\t\t\t\t\t\t\tif (!stricmp(att->value, \"Credits\")) scroll_mode = GF_TXT_SCROLL_CREDITS;\n\t\t\t\t\t\t\telse if (!stricmp(att->value, \"Marquee\")) scroll_mode = GF_TXT_SCROLL_MARQUEE;\n\t\t\t\t\t\t\telse if (!stricmp(att->value, \"Right\")) scroll_mode = GF_TXT_SCROLL_RIGHT;\n\t\t\t\t\t\t\telse if (!stricmp(att->value, \"Down\")) scroll_mode = GF_TXT_SCROLL_DOWN;\n\t\t\t\t\t\t\ttd.displayFlags |= ((scroll_mode<<7) & GF_TXT_SCROLL_DIRECTION);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tk=0;\n\t\t\t\t\twhile ( (ext=(GF_XMLNode*)gf_list_enum(sdesc->content, &k))) {\n\t\t\t\t\t\tif (ext->type) continue;\n\t\t\t\t\t\tif (!strcmp(ext->name, \"TextBox\")) ttxt_parse_text_box(import, ext, &td.default_pos);\n\t\t\t\t\t\telse if (!strcmp(ext->name, \"Style\")) ttxt_parse_text_style(import, ext, &td.default_style);\n\t\t\t\t\t\telse if (!strcmp(ext->name, \"FontTable\")) {\n\t\t\t\t\t\t\tGF_XMLNode *ftable;\n\t\t\t\t\t\t\tu32 z=0;\n\t\t\t\t\t\t\twhile ( (ftable=(GF_XMLNode*)gf_list_enum(ext->content, &z))) {\n\t\t\t\t\t\t\t\tu32 m;\n\t\t\t\t\t\t\t\tif (ftable->type || strcmp(ftable->name, \"FontTableEntry\")) continue;\n\t\t\t\t\t\t\t\ttd.font_count += 1;\n\t\t\t\t\t\t\t\ttd.fonts = (GF_FontRecord*)gf_realloc(td.fonts, sizeof(GF_FontRecord)*td.font_count);\n\t\t\t\t\t\t\t\tm=0;\n\t\t\t\t\t\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(ftable->attributes, &m))) {\n\t\t\t\t\t\t\t\t\tif (!stricmp(att->name, \"fontID\")) td.fonts[td.font_count-1].fontID = atoi(att->value);\n\t\t\t\t\t\t\t\t\telse if (!stricmp(att->name, \"fontName\")) td.fonts[td.font_count-1].fontName = gf_strdup(att->value);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (import->flags & GF_IMPORT_SKIP_TXT_BOX) {\n\t\t\t\t\t\ttd.default_pos.top = td.default_pos.left = td.default_pos.right = td.default_pos.bottom = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif ((td.default_pos.bottom==td.default_pos.top) || (td.default_pos.right==td.default_pos.left)) {\n\t\t\t\t\t\t\ttd.default_pos.top = td.default_pos.left = 0;\n\t\t\t\t\t\t\ttd.default_pos.right = w;\n\t\t\t\t\t\t\ttd.default_pos.bottom = h;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!td.fonts) {\n\t\t\t\t\t\ttd.font_count = 1;\n\t\t\t\t\t\ttd.fonts = (GF_FontRecord*)gf_malloc(sizeof(GF_FontRecord));\n\t\t\t\t\t\ttd.fonts[0].fontID = 1;\n\t\t\t\t\t\ttd.fonts[0].fontName = gf_strdup(\"Serif\");\n\t\t\t\t\t}\n\t\t\t\t\tgf_isom_new_text_description(import->dest, track, &td, NULL, NULL, &idx);\n\t\t\t\t\tfor (k=0; k<td.font_count; k++) gf_free(td.fonts[k].fontName);\n\t\t\t\t\tgf_free(td.fonts);\n\t\t\t\t\tnb_descs ++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*sample text*/\n\t\telse if (!strcmp(node->name, \"TextSample\")) {\n\t\t\tGF_ISOSample *s;\n\t\t\tGF_TextSample * samp;\n\t\t\tu32 ts, descIndex;\n\t\t\tBool has_text = GF_FALSE;\n\t\t\tif (!nb_descs) {\n\t\t\t\te = gf_import_message(import, GF_BAD_PARAM, \"Invalid Timed Text file - text stream header not found or empty\");\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tsamp = gf_isom_new_text_sample();\n\t\t\tts = 0;\n\t\t\tdescIndex = 1;\n\t\t\tlast_sample_empty = GF_TRUE;\n\n\t\t\tj=0;\n\t\t\twhile ( (att=(GF_XMLAttribute*)gf_list_enum(node->attributes, &j))) {\n\t\t\t\tif (!strcmp(att->name, \"sampleTime\")) {\n\t\t\t\t\tu32 h, m, s, ms;\n\t\t\t\t\tif (sscanf(att->value, \"%u:%u:%u.%u\", &h, &m, &s, &ms) == 4) {\n\t\t\t\t\t\tts = (h*3600 + m*60 + s)*1000 + ms;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tts = (u32) (atof(att->value) * 1000);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (!strcmp(att->name, \"sampleDescriptionIndex\")) descIndex = atoi(att->value);\n\t\t\t\telse if (!strcmp(att->name, \"text\")) {\n\t\t\t\t\tu32 len;\n\t\t\t\t\tchar *str = ttxt_parse_string(import, att->value, GF_TRUE);\n\t\t\t\t\tlen = (u32) strlen(str);\n\t\t\t\t\tgf_isom_text_add_text(samp, str, len);\n\t\t\t\t\tlast_sample_empty = len ? GF_FALSE : GF_TRUE;\n\t\t\t\t\thas_text = GF_TRUE;\n\t\t\t\t}\n\t\t\t\telse if (!strcmp(att->name, \"scrollDelay\")) gf_isom_text_set_scroll_delay(samp, (u32) (1000*atoi(att->value)));\n\t\t\t\telse if (!strcmp(att->name, \"highlightColor\")) gf_isom_text_set_highlight_color_argb(samp, ttxt_get_color(import, att->value));\n\t\t\t\telse if (!strcmp(att->name, \"wrap\") && !strcmp(att->value, \"Automatic\")) gf_isom_text_set_wrap(samp, 0x01);\n\t\t\t}\n\n\t\t\t/*get all modifiers*/\n\t\t\tj=0;\n\t\t\twhile ( (ext=(GF_XMLNode*)gf_list_enum(node->content, &j))) {\n\t\t\t\tif (!has_text && (ext->type==GF_XML_TEXT_TYPE)) {\n\t\t\t\t\tu32 len;\n\t\t\t\t\tchar *str = ttxt_parse_string(import, ext->name, GF_FALSE);\n\t\t\t\t\tlen = (u32) strlen(str);\n\t\t\t\t\tgf_isom_text_add_text(samp, str, len);\n\t\t\t\t\tlast_sample_empty = len ? GF_FALSE : GF_TRUE;\n\t\t\t\t\thas_text = GF_TRUE;\n\t\t\t\t}\n\t\t\t\tif (ext->type) continue;\n\n\t\t\t\tif (!stricmp(ext->name, \"Style\")) {\n\t\t\t\t\tGF_StyleRecord r;\n\t\t\t\t\tttxt_parse_text_style(import, ext, &r);\n\t\t\t\t\tgf_isom_text_add_style(samp, &r);\n\t\t\t\t}\n\t\t\t\telse if (!stricmp(ext->name, \"TextBox\")) {\n\t\t\t\t\tGF_BoxRecord r;\n\t\t\t\t\tttxt_parse_text_box(import, ext, &r);\n\t\t\t\t\tgf_isom_text_set_box(samp, r.top, r.left, r.bottom, r.right);\n\t\t\t\t}\n\t\t\t\telse if (!stricmp(ext->name, \"Highlight\")) {\n\t\t\t\t\tu16 start, end;\n\t\t\t\t\tstart = end = 0;\n\t\t\t\t\tk=0;\n\t\t\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(ext->attributes, &k))) {\n\t\t\t\t\t\tif (!strcmp(att->name, \"fromChar\")) start = atoi(att->value);\n\t\t\t\t\t\telse if (!strcmp(att->name, \"toChar\")) end = atoi(att->value);\n\t\t\t\t\t}\n\t\t\t\t\tgf_isom_text_add_highlight(samp, start, end);\n\t\t\t\t}\n\t\t\t\telse if (!stricmp(ext->name, \"Blinking\")) {\n\t\t\t\t\tu16 start, end;\n\t\t\t\t\tstart = end = 0;\n\t\t\t\t\tk=0;\n\t\t\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(ext->attributes, &k))) {\n\t\t\t\t\t\tif (!strcmp(att->name, \"fromChar\")) start = atoi(att->value);\n\t\t\t\t\t\telse if (!strcmp(att->name, \"toChar\")) end = atoi(att->value);\n\t\t\t\t\t}\n\t\t\t\t\tgf_isom_text_add_blink(samp, start, end);\n\t\t\t\t}\n\t\t\t\telse if (!stricmp(ext->name, \"HyperLink\")) {\n\t\t\t\t\tu16 start, end;\n\t\t\t\t\tchar *url, *url_tt;\n\t\t\t\t\tstart = end = 0;\n\t\t\t\t\turl = url_tt = NULL;\n\t\t\t\t\tk=0;\n\t\t\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(ext->attributes, &k))) {\n\t\t\t\t\t\tif (!strcmp(att->name, \"fromChar\")) start = atoi(att->value);\n\t\t\t\t\t\telse if (!strcmp(att->name, \"toChar\")) end = atoi(att->value);\n\t\t\t\t\t\telse if (!strcmp(att->name, \"URL\")) url = gf_strdup(att->value);\n\t\t\t\t\t\telse if (!strcmp(att->name, \"URLToolTip\")) url_tt = gf_strdup(att->value);\n\t\t\t\t\t}\n\t\t\t\t\tgf_isom_text_add_hyperlink(samp, url, url_tt, start, end);\n\t\t\t\t\tif (url) gf_free(url);\n\t\t\t\t\tif (url_tt) gf_free(url_tt);\n\t\t\t\t}\n\t\t\t\telse if (!stricmp(ext->name, \"Karaoke\")) {\n\t\t\t\t\tu32 startTime;\n\t\t\t\t\tGF_XMLNode *krok;\n\t\t\t\t\tstartTime = 0;\n\t\t\t\t\tk=0;\n\t\t\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(ext->attributes, &k))) {\n\t\t\t\t\t\tif (!strcmp(att->name, \"startTime\")) startTime = (u32) (1000*atof(att->value));\n\t\t\t\t\t}\n\t\t\t\t\tgf_isom_text_add_karaoke(samp, startTime);\n\t\t\t\t\tk=0;\n\t\t\t\t\twhile ( (krok=(GF_XMLNode*)gf_list_enum(ext->content, &k))) {\n\t\t\t\t\t\tu16 start, end;\n\t\t\t\t\t\tu32 endTime, m;\n\t\t\t\t\t\tif (krok->type) continue;\n\t\t\t\t\t\tif (strcmp(krok->name, \"KaraokeRange\")) continue;\n\t\t\t\t\t\tstart = end = 0;\n\t\t\t\t\t\tendTime = 0;\n\t\t\t\t\t\tm=0;\n\t\t\t\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(krok->attributes, &m))) {\n\t\t\t\t\t\t\tif (!strcmp(att->name, \"fromChar\")) start = atoi(att->value);\n\t\t\t\t\t\t\telse if (!strcmp(att->name, \"toChar\")) end = atoi(att->value);\n\t\t\t\t\t\t\telse if (!strcmp(att->name, \"endTime\")) endTime = (u32) (1000*atof(att->value));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgf_isom_text_set_karaoke_segment(samp, endTime, start, end);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*in MP4 we must start at T=0, so add an empty sample*/\n\t\t\tif (ts && !nb_samples) {\n\t\t\t\tGF_TextSample * firstsamp = gf_isom_new_text_sample();\n\t\t\t\ts = gf_isom_text_to_sample(firstsamp);\n\t\t\t\ts->DTS = 0;\n\t\t\t\tgf_isom_add_sample(import->dest, track, 1, s);\n\t\t\t\tnb_samples++;\n\t\t\t\tgf_isom_delete_text_sample(firstsamp);\n\t\t\t\tgf_isom_sample_del(&s);\n\t\t\t}\n\n\t\t\ts = gf_isom_text_to_sample(samp);\n\t\t\tgf_isom_delete_text_sample(samp);\n\t\t\ts->DTS = ts;\n\t\t\tif (last_sample_empty) {\n\t\t\t\tlast_sample_duration = s->DTS - last_sample_duration;\n\t\t\t} else {\n\t\t\t\tlast_sample_duration = s->DTS;\n\t\t\t}\n\n\t\t\te = gf_isom_add_sample(import->dest, track, descIndex, s);\n\t\t\tif (e) goto exit;\n\t\t\tgf_isom_sample_del(&s);\n\t\t\tnb_samples++;\n\n\t\t\tgf_set_progress(\"Importing TTXT\", nb_samples, nb_children);\n\t\t\tif (import->duration && (ts>import->duration)) break;\n\t\t}\n\t}\n\tif (last_sample_empty) {\n\t\tgf_isom_remove_sample(import->dest, track, nb_samples);\n\t\tgf_isom_set_last_sample_duration(import->dest, track, (u32) last_sample_duration);\n\t}\n\tgf_set_progress(\"Importing TTXT\", nb_samples, nb_samples);\n\nexit:\n\tgf_xml_dom_del(parser);\n\treturn e;\n}\n\n\nu32 tx3g_get_color(GF_MediaImporter *import, char *value)\n{\n\tu32 r, g, b, a;\n\tu32 res, v;\n\tr = g = b = a = 0;\n\tif (sscanf(value, \"%u%%, %u%%, %u%%, %u%%\", &r, &g, &b, &a) != 4) {\n\t\tgf_import_message(import, GF_OK, \"Warning: color badly formatted\");\n\t}\n\tv = (u32) (a*255/100);\n\tres = (v&0xFF);\n\tres<<=8;\n\tv = (u32) (r*255/100);\n\tres |= (v&0xFF);\n\tres<<=8;\n\tv = (u32) (g*255/100);\n\tres |= (v&0xFF);\n\tres<<=8;\n\tv = (u32) (b*255/100);\n\tres |= (v&0xFF);\n\treturn res;\n}\n\nvoid tx3g_parse_text_box(GF_MediaImporter *import, GF_XMLNode *n, GF_BoxRecord *box)\n{\n\tu32 i=0;\n\tGF_XMLAttribute *att;\n\tmemset(box, 0, sizeof(GF_BoxRecord));\n\twhile ((att=(GF_XMLAttribute *)gf_list_enum(n->attributes, &i))) {\n\t\tif (!stricmp(att->name, \"x\")) box->left = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"y\")) box->top = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"height\")) box->bottom = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"width\")) box->right = atoi(att->value);\n\t}\n}\n\ntypedef struct\n{\n\tu32 id;\n\tu32 pos;\n} Marker;\n\n#define GET_MARKER_POS(_val, __isend) \\\n\t{\t\\\n\t\tu32 i, __m = atoi(att->value);\t\\\n\t\t_val = 0;\t\\\n\t\tfor (i=0; i<nb_marks; i++) { if (__m==marks[i].id) { _val = marks[i].pos; /*if (__isend) _val--; */break; } }\t \\\n\t}\n\n\nstatic void texml_import_progress(void *cbk, u64 cur_samp, u64 count)\n{\n\tgf_set_progress(\"TeXML Loading\", cur_samp, count);\n}\n\nstatic GF_Err gf_text_import_texml(GF_MediaImporter *import)\n{\n\tGF_Err e;\n\tu32 track, ID, nb_samples, nb_children, nb_descs, timescale, w, h, i, j, k;\n\tu64 DTS;\n\ts32 tx, ty, layer;\n\tGF_StyleRecord styles[50];\n\tMarker marks[50];\n\tGF_XMLAttribute *att;\n\tGF_DOMParser *parser;\n\tGF_XMLNode *root, *node;\n\n\tif (import->flags==GF_IMPORT_PROBE_ONLY) return GF_OK;\n\n\tparser = gf_xml_dom_new();\n\te = gf_xml_dom_parse(parser, import->in_name, texml_import_progress, import);\n\tif (e) {\n\t\tgf_import_message(import, e, \"Error parsing TeXML file: Line %d - %s\", gf_xml_dom_get_line(parser), gf_xml_dom_get_error(parser));\n\t\tgf_xml_dom_del(parser);\n\t\treturn e;\n\t}\n\troot = gf_xml_dom_get_root(parser);\n\n\tif (strcmp(root->name, \"text3GTrack\")) {\n\t\te = gf_import_message(import, GF_BAD_PARAM, \"Invalid QT TeXML file - expecting root \\\"text3GTrack\\\" got \\\"%s\\\"\", root->name);\n\t\tgoto exit;\n\t}\n\tw = TTXT_DEFAULT_WIDTH;\n\th = TTXT_DEFAULT_HEIGHT;\n\ttx = ty = 0;\n\tlayer = 0;\n\ttimescale = 1000;\n\ti=0;\n\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(root->attributes, &i))) {\n\t\tif (!strcmp(att->name, \"trackWidth\")) w = atoi(att->value);\n\t\telse if (!strcmp(att->name, \"trackHeight\")) h = atoi(att->value);\n\t\telse if (!strcmp(att->name, \"layer\")) layer = atoi(att->value);\n\t\telse if (!strcmp(att->name, \"timescale\")) timescale = atoi(att->value);\n\t\telse if (!strcmp(att->name, \"transform\")) {\n\t\t\tFloat fx, fy;\n\t\t\tsscanf(att->value, \"translate(%f,%f)\", &fx, &fy);\n\t\t\ttx = (u32) fx;\n\t\t\tty = (u32) fy;\n\t\t}\n\t}\n\n\t/*setup track in 3GP format directly (no ES desc)*/\n\tID = (import->esd) ? import->esd->ESID : 0;\n\ttrack = gf_isom_new_track(import->dest, ID, GF_ISOM_MEDIA_TEXT, timescale);\n\tif (!track) {\n\t\te = gf_isom_last_error(import->dest);\n\t\tgoto exit;\n\t}\n\tgf_isom_set_track_enabled(import->dest, track, 1);\n\t/*some MPEG-4 setup*/\n\tif (import->esd) {\n\t\tif (!import->esd->ESID) import->esd->ESID = gf_isom_get_track_id(import->dest, track);\n\t\tif (!import->esd->decoderConfig) import->esd->decoderConfig = (GF_DecoderConfig *) gf_odf_desc_new(GF_ODF_DCD_TAG);\n\t\tif (!import->esd->slConfig) import->esd->slConfig = (GF_SLConfig *) gf_odf_desc_new(GF_ODF_SLC_TAG);\n\t\timport->esd->slConfig->timestampResolution = timescale;\n\t\timport->esd->decoderConfig->streamType = GF_STREAM_TEXT;\n\t\timport->esd->decoderConfig->objectTypeIndication = GPAC_OTI_TEXT_MPEG4;\n\t\tif (import->esd->OCRESID) gf_isom_set_track_reference(import->dest, track, GF_ISOM_REF_OCR, import->esd->OCRESID);\n\t}\n\tDTS = 0;\n\tgf_isom_set_track_layout_info(import->dest, track, w<<16, h<<16, tx<<16, ty<<16, (s16) layer);\n\n\tgf_text_import_set_language(import, track);\n\te = GF_OK;\n\n\tgf_import_message(import, GF_OK, \"Timed Text (QT TeXML) Import - Track Size %d x %d\", w, h);\n\n\tnb_children = gf_list_count(root->content);\n\tnb_descs = 0;\n\tnb_samples = 0;\n\ti=0;\n\twhile ( (node=(GF_XMLNode*)gf_list_enum(root->content, &i))) {\n\t\tGF_XMLNode *desc;\n\t\tGF_TextSampleDescriptor td;\n\t\tGF_TextSample * samp = NULL;\n\t\tGF_ISOSample *s;\n\t\tu32 duration, descIndex, nb_styles, nb_marks;\n\t\tBool isRAP, same_style, same_box;\n\n\t\tif (node->type) continue;\n\t\tif (strcmp(node->name, \"sample\")) continue;\n\n\t\tisRAP = GF_FALSE;\n\t\tduration = 1000;\n\t\tj=0;\n\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(node->attributes, &j))) {\n\t\t\tif (!strcmp(att->name, \"duration\")) duration = atoi(att->value);\n\t\t\telse if (!strcmp(att->name, \"keyframe\")) isRAP = (!stricmp(att->value, \"true\") ? GF_TRUE : GF_FALSE);\n\t\t}\n\t\tnb_styles = 0;\n\t\tnb_marks = 0;\n\t\tsame_style = same_box = GF_FALSE;\n\t\tdescIndex = 1;\n\t\tj=0;\n\t\twhile ((desc=(GF_XMLNode*)gf_list_enum(node->content, &j))) {\n\t\t\tif (desc->type) continue;\n\n\t\t\tif (!strcmp(desc->name, \"description\")) {\n\t\t\t\tGF_XMLNode *sub;\n\t\t\t\tmemset(&td, 0, sizeof(GF_TextSampleDescriptor));\n\t\t\t\ttd.tag = GF_ODF_TEXT_CFG_TAG;\n\t\t\t\ttd.vert_justif = (s8) -1;\n\t\t\t\ttd.default_style.fontID = 1;\n\t\t\t\ttd.default_style.font_size = TTXT_DEFAULT_FONT_SIZE;\n\n\t\t\t\tk=0;\n\t\t\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(desc->attributes, &k))) {\n\t\t\t\t\tif (!strcmp(att->name, \"horizontalJustification\")) {\n\t\t\t\t\t\tif (!stricmp(att->value, \"center\")) td.horiz_justif = 1;\n\t\t\t\t\t\telse if (!stricmp(att->value, \"right\")) td.horiz_justif = (s8) -1;\n\t\t\t\t\t\telse if (!stricmp(att->value, \"left\")) td.horiz_justif = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse if (!strcmp(att->name, \"verticalJustification\")) {\n\t\t\t\t\t\tif (!stricmp(att->value, \"center\")) td.vert_justif = 1;\n\t\t\t\t\t\telse if (!stricmp(att->value, \"bottom\")) td.vert_justif = (s8) -1;\n\t\t\t\t\t\telse if (!stricmp(att->value, \"top\")) td.vert_justif = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse if (!strcmp(att->name, \"backgroundColor\")) td.back_color = tx3g_get_color(import, att->value);\n\t\t\t\t\telse if (!strcmp(att->name, \"displayFlags\")) {\n\t\t\t\t\t\tBool rev_scroll = GF_FALSE;\n\t\t\t\t\t\tif (strstr(att->value, \"scroll\")) {\n\t\t\t\t\t\t\tu32 scroll_mode = 0;\n\t\t\t\t\t\t\tif (strstr(att->value, \"scrollIn\")) td.displayFlags |= GF_TXT_SCROLL_IN;\n\t\t\t\t\t\t\tif (strstr(att->value, \"scrollOut\")) td.displayFlags |= GF_TXT_SCROLL_OUT;\n\t\t\t\t\t\t\tif (strstr(att->value, \"reverse\")) rev_scroll = GF_TRUE;\n\t\t\t\t\t\t\tif (strstr(att->value, \"horizontal\")) scroll_mode = rev_scroll ? GF_TXT_SCROLL_RIGHT : GF_TXT_SCROLL_MARQUEE;\n\t\t\t\t\t\t\telse scroll_mode = (rev_scroll ? GF_TXT_SCROLL_DOWN : GF_TXT_SCROLL_CREDITS);\n\t\t\t\t\t\t\ttd.displayFlags |= (scroll_mode<<7) & GF_TXT_SCROLL_DIRECTION;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/*TODO FIXME: check in QT doc !!*/\n\t\t\t\t\t\tif (strstr(att->value, \"writeTextVertically\")) td.displayFlags |= GF_TXT_VERTICAL;\n\t\t\t\t\t\tif (!strcmp(att->name, \"continuousKaraoke\")) td.displayFlags |= GF_TXT_KARAOKE;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tk=0;\n\t\t\t\twhile ((sub=(GF_XMLNode*)gf_list_enum(desc->content, &k))) {\n\t\t\t\t\tif (sub->type) continue;\n\t\t\t\t\tif (!strcmp(sub->name, \"defaultTextBox\")) tx3g_parse_text_box(import, sub, &td.default_pos);\n\t\t\t\t\telse if (!strcmp(sub->name, \"fontTable\")) {\n\t\t\t\t\t\tGF_XMLNode *ftable;\n\t\t\t\t\t\tu32 m=0;\n\t\t\t\t\t\twhile ((ftable=(GF_XMLNode*)gf_list_enum(sub->content, &m))) {\n\t\t\t\t\t\t\tif (ftable->type) continue;\n\t\t\t\t\t\t\tif (!strcmp(ftable->name, \"font\")) {\n\t\t\t\t\t\t\t\tu32 n=0;\n\t\t\t\t\t\t\t\ttd.font_count += 1;\n\t\t\t\t\t\t\t\ttd.fonts = (GF_FontRecord*)gf_realloc(td.fonts, sizeof(GF_FontRecord)*td.font_count);\n\t\t\t\t\t\t\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(ftable->attributes, &n))) {\n\t\t\t\t\t\t\t\t\tif (!stricmp(att->name, \"id\")) td.fonts[td.font_count-1].fontID = atoi(att->value);\n\t\t\t\t\t\t\t\t\telse if (!stricmp(att->name, \"name\")) td.fonts[td.font_count-1].fontName = gf_strdup(att->value);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (!strcmp(sub->name, \"sharedStyles\")) {\n\t\t\t\t\t\tGF_XMLNode *style, *ftable;\n\t\t\t\t\t\tu32 m=0;\n\t\t\t\t\t\twhile ((style=(GF_XMLNode*)gf_list_enum(sub->content, &m))) {\n\t\t\t\t\t\t\tif (style->type) continue;\n\t\t\t\t\t\t\tif (!strcmp(style->name, \"style\")) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (style) {\n\t\t\t\t\t\t\tchar *cur;\n\t\t\t\t\t\t\ts32 start=0;\n\t\t\t\t\t\t\tchar css_style[1024], css_val[1024];\n\t\t\t\t\t\t\tmemset(&styles[nb_styles], 0, sizeof(GF_StyleRecord));\n\t\t\t\t\t\t\tm=0;\n\t\t\t\t\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(style->attributes, &m))) {\n\t\t\t\t\t\t\t\tif (!strcmp(att->name, \"id\")) styles[nb_styles].startCharOffset = atoi(att->value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tm=0;\n\t\t\t\t\t\t\twhile ( (ftable=(GF_XMLNode*)gf_list_enum(style->content, &m))) {\n\t\t\t\t\t\t\t\tif (ftable->type) break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcur = ftable->name;\n\t\t\t\t\t\t\twhile (cur) {\n\t\t\t\t\t\t\t\tstart = gf_token_get_strip(cur, 0, \"{:\", \" \", css_style, 1024);\n\t\t\t\t\t\t\t\tif (start <0) break;\n\t\t\t\t\t\t\t\tstart = gf_token_get_strip(cur, start, \":}\", \" \", css_val, 1024);\n\t\t\t\t\t\t\t\tif (start <0) break;\n\t\t\t\t\t\t\t\tcur = strchr(cur+start, '{');\n\n\t\t\t\t\t\t\t\tif (!strcmp(css_style, \"font-table\")) {\n\t\t\t\t\t\t\t\t\tu32 z;\n\t\t\t\t\t\t\t\t\tstyles[nb_styles].fontID = atoi(css_val);\n\t\t\t\t\t\t\t\t\tfor (z=0; z<td.font_count; z++) {\n\t\t\t\t\t\t\t\t\t\tif (td.fonts[z].fontID == styles[nb_styles].fontID)\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if (!strcmp(css_style, \"font-size\")) styles[nb_styles].font_size = atoi(css_val);\n\t\t\t\t\t\t\t\telse if (!strcmp(css_style, \"font-style\") && !strcmp(css_val, \"italic\")) styles[nb_styles].style_flags |= GF_TXT_STYLE_ITALIC;\n\t\t\t\t\t\t\t\telse if (!strcmp(css_style, \"font-weight\") && !strcmp(css_val, \"bold\")) styles[nb_styles].style_flags |= GF_TXT_STYLE_BOLD;\n\t\t\t\t\t\t\t\telse if (!strcmp(css_style, \"text-decoration\") && !strcmp(css_val, \"underline\")) styles[nb_styles].style_flags |= GF_TXT_STYLE_UNDERLINED;\n\t\t\t\t\t\t\t\telse if (!strcmp(css_style, \"color\")) styles[nb_styles].text_color = tx3g_get_color(import, css_val);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!nb_styles) td.default_style = styles[0];\n\t\t\t\t\t\t\tnb_styles++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tif ((td.default_pos.bottom==td.default_pos.top) || (td.default_pos.right==td.default_pos.left)) {\n\t\t\t\t\ttd.default_pos.top = td.default_pos.left = 0;\n\t\t\t\t\ttd.default_pos.right = w;\n\t\t\t\t\ttd.default_pos.bottom = h;\n\t\t\t\t}\n\t\t\t\tif (!td.fonts) {\n\t\t\t\t\ttd.font_count = 1;\n\t\t\t\t\ttd.fonts = (GF_FontRecord*)gf_malloc(sizeof(GF_FontRecord));\n\t\t\t\t\ttd.fonts[0].fontID = 1;\n\t\t\t\t\ttd.fonts[0].fontName = gf_strdup(\"Serif\");\n\t\t\t\t}\n\t\t\t\tgf_isom_text_has_similar_description(import->dest, track, &td, &descIndex, &same_box, &same_style);\n\t\t\t\tif (!descIndex) {\n\t\t\t\t\tgf_isom_new_text_description(import->dest, track, &td, NULL, NULL, &descIndex);\n\t\t\t\t\tsame_style = same_box = GF_TRUE;\n\t\t\t\t}\n\n\t\t\t\tfor (k=0; k<td.font_count; k++) gf_free(td.fonts[k].fontName);\n\t\t\t\tgf_free(td.fonts);\n\t\t\t\tnb_descs ++;\n\t\t\t}\n\t\t\telse if (!strcmp(desc->name, \"sampleData\")) {\n\t\t\t\tGF_XMLNode *sub;\n\t\t\t\tu16 start, end;\n\t\t\t\tu32 styleID;\n\t\t\t\tu32 nb_chars, txt_len, m;\n\t\t\t\tnb_chars = 0;\n\n\t\t\t\tsamp = gf_isom_new_text_sample();\n\n\t\t\t\tk=0;\n\t\t\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(desc->attributes, &k))) {\n\t\t\t\t\tif (!strcmp(att->name, \"targetEncoding\") && !strcmp(att->value, \"utf16\")) ;//is_utf16 = 1;\n\t\t\t\t\telse if (!strcmp(att->name, \"scrollDelay\")) gf_isom_text_set_scroll_delay(samp, atoi(att->value) );\n\t\t\t\t\telse if (!strcmp(att->name, \"highlightColor\")) gf_isom_text_set_highlight_color_argb(samp, tx3g_get_color(import, att->value));\n\t\t\t\t}\n\t\t\t\tstart = end = 0;\n\t\t\t\tk=0;\n\t\t\t\twhile ((sub=(GF_XMLNode*)gf_list_enum(desc->content, &k))) {\n\t\t\t\t\tif (sub->type) continue;\n\t\t\t\t\tif (!strcmp(sub->name, \"text\")) {\n\t\t\t\t\t\tGF_XMLNode *text;\n\t\t\t\t\t\tstyleID = 0;\n\t\t\t\t\t\tm=0;\n\t\t\t\t\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(sub->attributes, &m))) {\n\t\t\t\t\t\t\tif (!strcmp(att->name, \"styleID\")) styleID = atoi(att->value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttxt_len = 0;\n\n\t\t\t\t\t\tm=0;\n\t\t\t\t\t\twhile ((text=(GF_XMLNode*)gf_list_enum(sub->content, &m))) {\n\t\t\t\t\t\t\tif (!text->type) {\n\t\t\t\t\t\t\t\tif (!strcmp(text->name, \"marker\")) {\n\t\t\t\t\t\t\t\t\tu32 z;\n\t\t\t\t\t\t\t\t\tmemset(&marks[nb_marks], 0, sizeof(Marker));\n\t\t\t\t\t\t\t\t\tmarks[nb_marks].pos = nb_chars+txt_len;\n\n\t\t\t\t\t\t\t\t\tz = 0;\n\t\t\t\t\t\t\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(text->attributes, &z))) {\n\t\t\t\t\t\t\t\t\t\tif (!strcmp(att->name, \"id\")) marks[nb_marks].id = atoi(att->value);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tnb_marks++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (text->type==GF_XML_TEXT_TYPE) {\n\t\t\t\t\t\t\t\ttxt_len += (u32) strlen(text->name);\n\t\t\t\t\t\t\t\tgf_isom_text_add_text(samp, text->name, (u32) strlen(text->name));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (styleID && (!same_style || (td.default_style.startCharOffset != styleID))) {\n\t\t\t\t\t\t\tGF_StyleRecord st = td.default_style;\n\t\t\t\t\t\t\tfor (m=0; m<nb_styles; m++) {\n\t\t\t\t\t\t\t\tif (styles[m].startCharOffset==styleID) {\n\t\t\t\t\t\t\t\t\tst = styles[m];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tst.startCharOffset = nb_chars;\n\t\t\t\t\t\t\tst.endCharOffset = nb_chars + txt_len;\n\t\t\t\t\t\t\tgf_isom_text_add_style(samp, &st);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnb_chars += txt_len;\n\t\t\t\t\t}\n\t\t\t\t\telse if (!stricmp(sub->name, \"highlight\")) {\n\t\t\t\t\t\tm=0;\n\t\t\t\t\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(sub->attributes, &m))) {\n\t\t\t\t\t\t\tif (!strcmp(att->name, \"startMarker\")) GET_MARKER_POS(start, 0)\n\t\t\t\t\t\t\t\telse if (!strcmp(att->name, \"endMarker\")) GET_MARKER_POS(end, 1)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\tgf_isom_text_add_highlight(samp, start, end);\n\t\t\t\t\t}\n\t\t\t\t\telse if (!stricmp(sub->name, \"blink\")) {\n\t\t\t\t\t\tm=0;\n\t\t\t\t\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(sub->attributes, &m))) {\n\t\t\t\t\t\t\tif (!strcmp(att->name, \"startMarker\")) GET_MARKER_POS(start, 0)\n\t\t\t\t\t\t\t\telse if (!strcmp(att->name, \"endMarker\")) GET_MARKER_POS(end, 1)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\tgf_isom_text_add_blink(samp, start, end);\n\t\t\t\t\t}\n\t\t\t\t\telse if (!stricmp(sub->name, \"link\")) {\n\t\t\t\t\t\tchar *url, *url_tt;\n\t\t\t\t\t\turl = url_tt = NULL;\n\t\t\t\t\t\tm=0;\n\t\t\t\t\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(sub->attributes, &m))) {\n\t\t\t\t\t\t\tif (!strcmp(att->name, \"startMarker\")) GET_MARKER_POS(start, 0)\n\t\t\t\t\t\t\t\telse if (!strcmp(att->name, \"endMarker\")) GET_MARKER_POS(end, 1)\n\t\t\t\t\t\t\t\t\telse if (!strcmp(att->name, \"URL\") || !strcmp(att->name, \"href\")) url = gf_strdup(att->value);\n\t\t\t\t\t\t\t\t\telse if (!strcmp(att->name, \"URLToolTip\") || !strcmp(att->name, \"altString\")) url_tt = gf_strdup(att->value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgf_isom_text_add_hyperlink(samp, url, url_tt, start, end);\n\t\t\t\t\t\tif (url) gf_free(url);\n\t\t\t\t\t\tif (url_tt) gf_free(url_tt);\n\t\t\t\t\t}\n\t\t\t\t\telse if (!stricmp(sub->name, \"karaoke\")) {\n\t\t\t\t\t\tu32 time = 0;\n\t\t\t\t\t\tGF_XMLNode *krok;\n\t\t\t\t\t\tm=0;\n\t\t\t\t\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(sub->attributes, &m))) {\n\t\t\t\t\t\t\tif (!strcmp(att->name, \"startTime\")) time = atoi(att->value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgf_isom_text_add_karaoke(samp, time);\n\t\t\t\t\t\tm=0;\n\t\t\t\t\t\twhile ((krok=(GF_XMLNode*)gf_list_enum(sub->content, &m))) {\n\t\t\t\t\t\t\tu32 u=0;\n\t\t\t\t\t\t\tif (krok->type) continue;\n\t\t\t\t\t\t\tif (strcmp(krok->name, \"run\")) continue;\n\t\t\t\t\t\t\tstart = end = 0;\n\t\t\t\t\t\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(krok->attributes, &u))) {\n\t\t\t\t\t\t\t\tif (!strcmp(att->name, \"startMarker\")) GET_MARKER_POS(start, 0)\n\t\t\t\t\t\t\t\t\telse if (!strcmp(att->name, \"endMarker\")) GET_MARKER_POS(end, 1)\n\t\t\t\t\t\t\t\t\t\telse if (!strcmp(att->name, \"duration\")) time += atoi(att->value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tgf_isom_text_set_karaoke_segment(samp, time, start, end);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*OK, let's add the sample*/\n\t\tif (samp) {\n\t\t\tif (!same_box) gf_isom_text_set_box(samp, td.default_pos.top, td.default_pos.left, td.default_pos.bottom, td.default_pos.right);\n//\t\t\tif (!same_style) gf_isom_text_add_style(samp, &td.default_style);\n\n\t\t\ts = gf_isom_text_to_sample(samp);\n\t\t\tgf_isom_delete_text_sample(samp);\n\t\t\ts->IsRAP = isRAP ? RAP : RAP_NO;\n\t\t\ts->DTS = DTS;\n\t\t\tgf_isom_add_sample(import->dest, track, descIndex, s);\n\t\t\tgf_isom_sample_del(&s);\n\t\t\tnb_samples++;\n\t\t\tDTS += duration;\n\t\t\tgf_set_progress(\"Importing TeXML\", nb_samples, nb_children);\n\t\t\tif (import->duration && (DTS*1000> timescale*import->duration)) break;\n\t\t}\n\t}\n\tgf_isom_set_last_sample_duration(import->dest, track, 0);\n\tgf_set_progress(\"Importing TeXML\", nb_samples, nb_samples);\n\nexit:\n\tgf_xml_dom_del(parser);\n\treturn e;\n}\n\n\nGF_Err gf_import_timed_text(GF_MediaImporter *import)\n{\n\tGF_Err e;\n\tu32 fmt;\n\te = gf_text_guess_format(import->in_name, &fmt);\n\tif (e) return e;\n\tif (import->streamFormat) {\n\t\tif (!strcmp(import->streamFormat, \"VTT\")) fmt = GF_TEXT_IMPORT_WEBVTT;\n\t\telse if (!strcmp(import->streamFormat, \"TTML\")) fmt = GF_TEXT_IMPORT_TTML;\n\t\tif ((strstr(import->in_name, \".swf\") || strstr(import->in_name, \".SWF\")) && !stricmp(import->streamFormat, \"SVG\")) fmt = GF_TEXT_IMPORT_SWF_SVG;\n\t}\n\tif (!fmt) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TTXT Import] Input %s does not look like a supported text format - ignoring\\n\", import->in_name));\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\tif (import->flags & GF_IMPORT_PROBE_ONLY) {\n\t\tif (fmt==GF_TEXT_IMPORT_SUB) import->flags |= GF_IMPORT_OVERRIDE_FPS;\n\t\treturn GF_OK;\n\t}\n\tswitch (fmt) {\n\tcase GF_TEXT_IMPORT_SRT:\n\t\treturn gf_text_import_srt(import);\n\tcase GF_TEXT_IMPORT_SUB:\n\t\treturn gf_text_import_sub(import);\n\tcase GF_TEXT_IMPORT_TTXT:\n\t\treturn gf_text_import_ttxt(import);\n\tcase GF_TEXT_IMPORT_TEXML:\n\t\treturn gf_text_import_texml(import);\n#ifndef GPAC_DISABLE_VTT\n\tcase GF_TEXT_IMPORT_WEBVTT:\n\t\treturn gf_text_import_webvtt(import);\n#endif\n\tcase GF_TEXT_IMPORT_SWF_SVG:\n\t\treturn gf_text_import_swf(import);\n\tcase GF_TEXT_IMPORT_TTML:\n\t\treturn gf_text_import_ttml(import);\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n}\n\n#endif /*GPAC_DISABLE_MEDIA_IMPORT*/\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n"], "filenames": ["src/media_tools/text_import.c"], "buggy_code_start_loc": [271], "buggy_code_end_loc": [271], "fixing_code_start_loc": [272], "fixing_code_end_loc": [274], "type": "CWE-787", "message": "In GPAC 0.7.1 and earlier, gf_text_get_utf8_line in media_tools/text_import.c in libgpac_static.a allows an out-of-bounds write because a certain -1 return value is mishandled.", "other": {"cve": {"id": "CVE-2018-20760", "sourceIdentifier": "cve@mitre.org", "published": "2019-02-06T23:29:00.230", "lastModified": "2019-04-15T19:13:29.967", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In GPAC 0.7.1 and earlier, gf_text_get_utf8_line in media_tools/text_import.c in libgpac_static.a allows an out-of-bounds write because a certain -1 return value is mishandled."}, {"lang": "es", "value": "GPAC versi\u00f3n 0.7.1 y anteriores, gf_text_get_utf8_line en media_tools/text_import.c en libgpac_static.a permite una escritura fuera de l\u00edmites porque un determinado valor de retorno -1 se manjea de forma inadecuada."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gpac:gpac:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.7.1", "matchCriteriaId": "085CE50F-C216-47FB-A0A6-00BE575E4B4F"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.10:*:*:*:*:*:*:*", "matchCriteriaId": "07C312A0-CD2C-4B9C-B064-6409B25C278F"}]}]}], "references": [{"url": "https://github.com/gpac/gpac/commit/4c1360818fc8948e9307059fba4dc47ba8ad255d", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/gpac/gpac/issues/1177", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/02/msg00040.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3926-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/gpac/gpac/commit/4c1360818fc8948e9307059fba4dc47ba8ad255d"}}