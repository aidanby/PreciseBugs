{"buggy_code": ["/* userfunc.c */\nvoid func_init(void);\nhashtab_T *func_tbl_get(void);\nchar_u *get_lambda_name(void);\nchar_u *register_cfunc(cfunc_T cb, cfunc_free_T cb_free, void *state);\nint get_lambda_tv(char_u **arg, typval_T *rettv, int types_optional, evalarg_T *evalarg);\nchar_u *deref_func_name(char_u *name, int *lenp, partial_T **partialp, type_T **type, int no_autoload, int *found_var);\nvoid emsg_funcname(char *ermsg, char_u *name);\nint get_func_tv(char_u *name, int len, typval_T *rettv, char_u **arg, evalarg_T *evalarg, funcexe_T *funcexe);\nchar_u *fname_trans_sid(char_u *name, char_u *fname_buf, char_u **tofree, int *error);\nufunc_T *find_func_even_dead(char_u *name, int is_global, cctx_T *cctx);\nufunc_T *find_func(char_u *name, int is_global, cctx_T *cctx);\nint func_is_global(ufunc_T *ufunc);\nint func_name_refcount(char_u *name);\nvoid func_clear_free(ufunc_T *fp, int force);\nint copy_func(char_u *lambda, char_u *global, ectx_T *ectx);\nint funcdepth_increment(void);\nvoid funcdepth_decrement(void);\nint funcdepth_get(void);\nvoid funcdepth_restore(int depth);\nint check_user_func_argcount(ufunc_T *fp, int argcount);\nint call_user_func_check(ufunc_T *fp, int argcount, typval_T *argvars, typval_T *rettv, funcexe_T *funcexe, dict_T *selfdict);\nvoid save_funccal(funccal_entry_T *entry);\nvoid restore_funccal(void);\nfunccall_T *get_current_funccal(void);\nvoid delete_script_functions(int sid);\nvoid free_all_functions(void);\nint builtin_function(char_u *name, int len);\nint func_call(char_u *name, typval_T *args, partial_T *partial, dict_T *selfdict, typval_T *rettv);\nint get_callback_depth(void);\nint call_callback(callback_T *callback, int len, typval_T *rettv, int argcount, typval_T *argvars);\nvarnumber_T call_callback_retnr(callback_T *callback, int argcount, typval_T *argvars);\nvoid user_func_error(int error, char_u *name, funcexe_T *funcexe);\nint call_func(char_u *funcname, int len, typval_T *rettv, int argcount_in, typval_T *argvars_in, funcexe_T *funcexe);\nchar_u *printable_func_name(ufunc_T *fp);\nchar_u *trans_function_name(char_u **pp, int *is_global, int skip, int flags, funcdict_T *fdp, partial_T **partial, type_T **type);\nchar_u *untrans_function_name(char_u *name);\nchar_u *get_scriptlocal_funcname(char_u *funcname);\nchar_u *save_function_name(char_u **name, int *is_global, int skip, int flags, funcdict_T *fudi);\nvoid list_functions(regmatch_T *regmatch);\nufunc_T *define_function(exarg_T *eap, char_u *name_arg);\nvoid ex_function(exarg_T *eap);\nvoid ex_defcompile(exarg_T *eap);\nint eval_fname_script(char_u *p);\nint translated_function_exists(char_u *name, int is_global);\nint has_varargs(ufunc_T *ufunc);\nint function_exists(char_u *name, int no_deref);\nchar_u *get_expanded_name(char_u *name, int check);\nchar_u *get_user_func_name(expand_T *xp, int idx);\nvoid ex_delfunction(exarg_T *eap);\nvoid func_unref(char_u *name);\nvoid func_ptr_unref(ufunc_T *fp);\nvoid func_ref(char_u *name);\nvoid func_ptr_ref(ufunc_T *fp);\nvoid ex_return(exarg_T *eap);\nvoid ex_call(exarg_T *eap);\nint do_return(exarg_T *eap, int reanimate, int is_cmd, void *rettv);\nvoid discard_pending_return(void *rettv);\nchar_u *get_return_cmd(void *rettv);\nchar_u *get_func_line(int c, void *cookie, int indent, getline_opt_T options);\nint func_has_ended(void *cookie);\nint func_has_abort(void *cookie);\ndict_T *make_partial(dict_T *selfdict_in, typval_T *rettv);\nchar_u *func_name(void *cookie);\nlinenr_T *func_breakpoint(void *cookie);\nint *func_dbg_tick(void *cookie);\nint func_level(void *cookie);\nint current_func_returned(void);\nint free_unref_funccal(int copyID, int testing);\nhashtab_T *get_funccal_local_ht(void);\ndictitem_T *get_funccal_local_var(void);\nhashtab_T *get_funccal_args_ht(void);\ndictitem_T *get_funccal_args_var(void);\nvoid list_func_vars(int *first);\ndict_T *get_current_funccal_dict(hashtab_T *ht);\nhashitem_T *find_hi_in_scoped_ht(char_u *name, hashtab_T **pht);\ndictitem_T *find_var_in_scoped_ht(char_u *name, int no_autoload);\nint set_ref_in_previous_funccal(int copyID);\nint set_ref_in_call_stack(int copyID);\nint set_ref_in_functions(int copyID);\nint set_ref_in_func_args(int copyID);\nint set_ref_in_func(char_u *name, ufunc_T *fp_in, int copyID);\n/* vim: set ft=c : */\n", "\" Test various aspects of the Vim9 script language.\n\nsource check.vim\nsource term_util.vim\nsource view_util.vim\nsource vim9.vim\nsource screendump.vim\n\nfunc Test_def_basic()\n  def SomeFunc(): string\n    return 'yes'\n  enddef\n  call SomeFunc()->assert_equal('yes')\nendfunc\n\nfunc Test_compiling_error()\n  \" use a terminal to see the whole error message\n  CheckRunVimInTerminal\n\n  call TestCompilingError()\n  call TestCompilingErrorInTry()\nendfunc\n\ndef TestCompilingError()\n  var lines =<< trim END\n    vim9script\n    def Fails()\n      echo nothing\n    enddef\n    defcompile\n  END\n  writefile(lines, 'XTest_compile_error')\n  var buf = RunVimInTerminal('-S XTest_compile_error',\n              {rows: 10, wait_for_ruler: 0})\n  WaitForAssert(() => assert_match('Error detected while compiling command line.*Fails.*Variable not found: nothing',\n                     Term_getlines(buf, range(1, 9))))\n\n  # clean up\n  StopVimInTerminal(buf)\n  delete('XTest_compile_error')\nenddef\n\ndef TestCompilingErrorInTry()\n  var dir = 'Xdir/autoload'\n  mkdir(dir, 'p')\n\n  var lines =<< trim END\n      vim9script\n      def script#OnlyCompiled()\n        g:runtime = 'yes'\n        invalid\n      enddef\n  END\n  writefile(lines, dir .. '/script.vim')\n\n  lines =<< trim END\n      vim9script\n      todo\n      try\n        script#OnlyCompiled()\n      catch /nothing/\n      endtry\n  END\n  lines[1] = 'set rtp=' .. getcwd() .. '/Xdir'\n  writefile(lines, 'XTest_compile_error')\n\n  var buf = RunVimInTerminal('-S XTest_compile_error', {rows: 10, wait_for_ruler: 0})\n  WaitForAssert(() => assert_match('Error detected while compiling command line.*function script#OnlyCompiled.*Invalid command: invalid',\n                     Term_getlines(buf, range(1, 9))))\n\n  # clean up\n  StopVimInTerminal(buf)\n  delete('XTest_compile_error')\n  delete('Xdir', 'rf')\nenddef\n\ndef Test_compile_error_in_called_function()\n  var lines =<< trim END\n      vim9script\n      var n: number\n      def Foo()\n        &hls = n\n      enddef\n      def Bar()\n        Foo()\n      enddef\n      silent! Foo()\n      Bar()\n  END\n  CheckScriptFailureList(lines, ['E1012:', 'E1191:'])\nenddef\n\ndef Test_wrong_function_name()\n  var lines =<< trim END\n      vim9script\n      func _Foo()\n        echo 'foo'\n      endfunc\n  END\n  CheckScriptFailure(lines, 'E128:')\n\n  lines =<< trim END\n      vim9script\n      def _Foo()\n        echo 'foo'\n      enddef\n  END\n  CheckScriptFailure(lines, 'E128:')\nenddef\n\ndef Test_autoload_name_mismatch()\n  var dir = 'Xdir/autoload'\n  mkdir(dir, 'p')\n\n  var lines =<< trim END\n      vim9script\n      def scriptX#Function()\n        # comment\n        g:runtime = 'yes'\n      enddef\n  END\n  writefile(lines, dir .. '/script.vim')\n\n  var save_rtp = &rtp\n  exe 'set rtp=' .. getcwd() .. '/Xdir'\n  lines =<< trim END\n      call script#Function()\n  END\n  CheckScriptFailure(lines, 'E746:', 2)\n\n  &rtp = save_rtp\n  delete(dir, 'rf')\nenddef\n\ndef Test_autoload_names()\n  var dir = 'Xdir/autoload'\n  mkdir(dir, 'p')\n\n  var lines =<< trim END\n      func foobar#function()\n        return 'yes'\n      endfunc\n      let foobar#var = 'no'\n  END\n  writefile(lines, dir .. '/foobar.vim')\n\n  var save_rtp = &rtp\n  exe 'set rtp=' .. getcwd() .. '/Xdir'\n\n  lines =<< trim END\n      assert_equal('yes', foobar#function())\n      var Function = foobar#function\n      assert_equal('yes', Function())\n\n      assert_equal('no', foobar#var)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  &rtp = save_rtp\n  delete(dir, 'rf')\nenddef\n\ndef Test_autoload_error_in_script()\n  var dir = 'Xdir/autoload'\n  mkdir(dir, 'p')\n\n  var lines =<< trim END\n      func scripterror#function()\n        let g:called_function = 'yes'\n      endfunc\n      let 0 = 1\n  END\n  writefile(lines, dir .. '/scripterror.vim')\n\n  var save_rtp = &rtp\n  exe 'set rtp=' .. getcwd() .. '/Xdir'\n\n  g:called_function = 'no'\n  # The error in the autoload script cannot be checked with assert_fails(), use\n  # CheckDefSuccess() instead of CheckDefFailure()\n  try\n    CheckDefSuccess(['scripterror#function()'])\n  catch\n    assert_match('E121: Undefined variable: 0', v:exception)\n  endtry\n  assert_equal('no', g:called_function)\n\n  lines =<< trim END\n      func scriptcaught#function()\n        let g:called_function = 'yes'\n      endfunc\n      try\n        let 0 = 1\n      catch\n        let g:caught = v:exception\n      endtry\n  END\n  writefile(lines, dir .. '/scriptcaught.vim')\n\n  g:called_function = 'no'\n  CheckDefSuccess(['scriptcaught#function()'])\n  assert_match('E121: Undefined variable: 0', g:caught)\n  assert_equal('yes', g:called_function)\n\n  &rtp = save_rtp\n  delete(dir, 'rf')\nenddef\n\ndef CallRecursive(n: number): number\n  return CallRecursive(n + 1)\nenddef\n\ndef CallMapRecursive(l: list<number>): number\n  return map(l, (_, v) => CallMapRecursive([v]))[0]\nenddef\n\ndef Test_funcdepth_error()\n  set maxfuncdepth=10\n\n  var caught = false\n  try\n    CallRecursive(1)\n  catch /E132:/\n    caught = true\n  endtry\n  assert_true(caught)\n\n  caught = false\n  try\n    CallMapRecursive([1])\n  catch /E132:/\n    caught = true\n  endtry\n  assert_true(caught)\n\n  set maxfuncdepth&\nenddef\n\ndef Test_endfunc_enddef()\n  var lines =<< trim END\n    def Test()\n      echo 'test'\n      endfunc\n    enddef\n  END\n  CheckScriptFailure(lines, 'E1151:', 3)\n\n  lines =<< trim END\n    def Test()\n      func Nested()\n        echo 'test'\n      enddef\n    enddef\n  END\n  CheckScriptFailure(lines, 'E1152:', 4)\n\n  lines =<< trim END\n    def Ok()\n      echo 'hello'\n    enddef | echo 'there'\n    def Bad()\n      echo 'hello'\n    enddef there\n  END\n  CheckScriptFailure(lines, 'E1173: Text found after enddef: there', 6)\nenddef\n\ndef Test_missing_endfunc_enddef()\n  var lines =<< trim END\n    vim9script\n    def Test()\n      echo 'test'\n    endef\n  END\n  CheckScriptFailure(lines, 'E1057:', 2)\n\n  lines =<< trim END\n    vim9script\n    func Some()\n      echo 'test'\n    enfffunc\n  END\n  CheckScriptFailure(lines, 'E126:', 2)\nenddef\n\ndef Test_white_space_before_paren()\n  var lines =<< trim END\n    vim9script\n    def Test ()\n      echo 'test'\n    enddef\n  END\n  CheckScriptFailure(lines, 'E1068:', 2)\n\n  lines =<< trim END\n    vim9script\n    func Test ()\n      echo 'test'\n    endfunc\n  END\n  CheckScriptFailure(lines, 'E1068:', 2)\n\n  lines =<< trim END\n    def Test ()\n      echo 'test'\n    enddef\n  END\n  CheckScriptFailure(lines, 'E1068:', 1)\n\n  lines =<< trim END\n    func Test ()\n      echo 'test'\n    endfunc\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_enddef_dict_key()\n  var d = {\n    enddef: 'x',\n    endfunc: 'y',\n  }\n  assert_equal({enddef: 'x', endfunc: 'y'}, d)\nenddef\n\ndef ReturnString(): string\n  return 'string'\nenddef\n\ndef ReturnNumber(): number\n  return 123\nenddef\n\nlet g:notNumber = 'string'\n\ndef ReturnGlobal(): number\n  return g:notNumber\nenddef\n\ndef Test_return_something()\n  ReturnString()->assert_equal('string')\n  ReturnNumber()->assert_equal(123)\n  assert_fails('ReturnGlobal()', 'E1012: Type mismatch; expected number but got string', '', 1, 'ReturnGlobal')\nenddef\n\ndef Test_check_argument_type()\n  var lines =<< trim END\n      vim9script\n      def Val(a: number, b: number): number\n        return 0\n      enddef\n      def Func()\n        var x: any = true\n        Val(0, x)\n      enddef\n      disass Func\n      Func()\n  END\n  CheckScriptFailure(lines, 'E1013: Argument 2: type mismatch, expected number but got bool', 2)\nenddef\n\ndef Test_missing_return()\n  CheckDefFailure(['def Missing(): number',\n                   '  if g:cond',\n                   '    echo \"no return\"',\n                   '  else',\n                   '    return 0',\n                   '  endif'\n                   'enddef'], 'E1027:')\n  CheckDefFailure(['def Missing(): number',\n                   '  if g:cond',\n                   '    return 1',\n                   '  else',\n                   '    echo \"no return\"',\n                   '  endif'\n                   'enddef'], 'E1027:')\n  CheckDefFailure(['def Missing(): number',\n                   '  if g:cond',\n                   '    return 1',\n                   '  else',\n                   '    return 2',\n                   '  endif'\n                   '  return 3'\n                   'enddef'], 'E1095:')\nenddef\n\ndef Test_return_bool()\n  var lines =<< trim END\n      vim9script\n      def MenuFilter(id: number, key: string): bool\n        return popup_filter_menu(id, key)\n      enddef\n      def YesnoFilter(id: number, key: string): bool\n        return popup_filter_yesno(id, key)\n      enddef\n      defcompile\n  END\n  CheckScriptSuccess(lines)\nenddef\n\nlet s:nothing = 0\ndef ReturnNothing()\n  s:nothing = 1\n  if true\n    return\n  endif\n  s:nothing = 2\nenddef\n\ndef Test_return_nothing()\n  ReturnNothing()\n  s:nothing->assert_equal(1)\nenddef\n\ndef Test_return_invalid()\n  var lines =<< trim END\n    vim9script\n    def Func(): invalid\n      return xxx\n    enddef\n    defcompile\n  END\n  CheckScriptFailure(lines, 'E1010:', 2)\n\n  lines =<< trim END\n      vim9script\n      def Test(Fun: func(number): number): list<number>\n          return map([1, 2, 3], (_, i) => Fun(i))\n      enddef\n      defcompile\n      def Inc(nr: number): nr\n        return nr + 2\n      enddef\n      echo Test(Inc)\n  END\n  # doing this twice was leaking memory\n  CheckScriptFailure(lines, 'E1010:')\n  CheckScriptFailure(lines, 'E1010:')\nenddef\n\ndef Test_return_list_any()\n  var lines =<< trim END\n      vim9script\n      def Func(): list<string>\n        var l: list<any>\n        l->add('string')\n        return l\n      enddef\n      echo Func()\n  END\n  CheckScriptFailure(lines, 'E1012:')\n  lines =<< trim END\n      vim9script\n      def Func(): list<string>\n        var l: list<any>\n        l += ['string']\n        return l\n      enddef\n      echo Func()\n  END\n  CheckScriptFailure(lines, 'E1012:')\nenddef\n\nfunc Increment()\n  let g:counter += 1\nendfunc\n\ndef Test_call_ufunc_count()\n  g:counter = 1\n  Increment()\n  Increment()\n  Increment()\n  # works with and without :call\n  g:counter->assert_equal(4)\n  eval g:counter->assert_equal(4)\n  unlet g:counter\nenddef\n\ndef MyVarargs(arg: string, ...rest: list<string>): string\n  var res = arg\n  for s in rest\n    res ..= ',' .. s\n  endfor\n  return res\nenddef\n\ndef Test_call_varargs()\n  MyVarargs('one')->assert_equal('one')\n  MyVarargs('one', 'two')->assert_equal('one,two')\n  MyVarargs('one', 'two', 'three')->assert_equal('one,two,three')\nenddef\n\ndef Test_call_white_space()\n  CheckDefAndScriptFailure([\"call Test ('text')\"], ['E476:', 'E1068:'])\nenddef\n\ndef MyDefaultArgs(name = 'string'): string\n  return name\nenddef\n\ndef MyDefaultSecond(name: string, second: bool  = true): string\n  return second ? name : 'none'\nenddef\n\n\ndef Test_call_default_args()\n  MyDefaultArgs()->assert_equal('string')\n  MyDefaultArgs(v:none)->assert_equal('string')\n  MyDefaultArgs('one')->assert_equal('one')\n  assert_fails('MyDefaultArgs(\"one\", \"two\")', 'E118:', '', 4, 'Test_call_default_args')\n\n  MyDefaultSecond('test')->assert_equal('test')\n  MyDefaultSecond('test', true)->assert_equal('test')\n  MyDefaultSecond('test', false)->assert_equal('none')\n\n  var lines =<< trim END\n      def MyDefaultThird(name: string, aa = 'aa', bb = 'bb'): string\n        return name .. aa .. bb\n      enddef\n\n      MyDefaultThird('->')->assert_equal('->aabb')\n      MyDefaultThird('->', v:none)->assert_equal('->aabb')\n      MyDefaultThird('->', 'xx')->assert_equal('->xxbb')\n      MyDefaultThird('->', v:none, v:none)->assert_equal('->aabb')\n      MyDefaultThird('->', 'xx', v:none)->assert_equal('->xxbb')\n      MyDefaultThird('->', v:none, 'yy')->assert_equal('->aayy')\n      MyDefaultThird('->', 'xx', 'yy')->assert_equal('->xxyy')\n\n      def DefArg(mandatory: any, optional = mandatory): string\n        return mandatory .. optional\n      enddef\n      DefArg(1234)->assert_equal('12341234')\n      DefArg(\"ok\")->assert_equal('okok')\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  CheckScriptFailure(['def Func(arg: number = asdf)', 'enddef', 'defcompile'], 'E1001:')\n  delfunc g:Func\n  CheckScriptFailure(['def Func(arg: number = \"text\")', 'enddef', 'defcompile'], 'E1013: Argument 1: type mismatch, expected number but got string')\n  delfunc g:Func\n  CheckDefFailure(['def Func(x: number = )', 'enddef'], 'E15:')\n\n  lines =<< trim END\n      vim9script\n      def Func(a = b == 0 ? 1 : 2, b = 0)\n      enddef\n      defcompile\n  END\n  CheckScriptFailure(lines, 'E1001: Variable not found: b')\n\n  # using script variable requires matching type or type cast when executed\n  lines =<< trim END\n      vim9script\n      var a: any\n      def Func(arg: string = a)\n        echo arg\n      enddef\n      defcompile\n  END\n  CheckScriptSuccess(lines + ['a = \"text\"', 'Func()'])\n  CheckScriptFailure(lines + ['a = 123', 'Func()'], 'E1013: Argument 1: type mismatch, expected string but got number')\n\n  # using global variable does not require type cast\n  lines =<< trim END\n      vim9script\n      def Func(arg: string = g:str)\n        echo arg\n      enddef\n      g:str = 'works'\n      Func()\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef FuncWithComment(  # comment\n  a: number, #comment\n  b: bool, # comment\n  c: string) #comment\n  assert_equal(4, a)\n  assert_equal(true, b)\n  assert_equal('yes', c)\nenddef\n\ndef Test_func_with_comments()\n  FuncWithComment(4, true, 'yes')\n\n  var lines =<< trim END\n      def Func(# comment\n        arg: string)\n      enddef\n  END\n  CheckScriptFailure(lines, 'E125:', 1)\n\n  lines =<< trim END\n      def Func(\n        arg: string# comment\n        )\n      enddef\n  END\n  CheckScriptFailure(lines, 'E475:', 2)\n\n  lines =<< trim END\n      def Func(\n        arg: string\n        )# comment\n      enddef\n  END\n  CheckScriptFailure(lines, 'E488:', 3)\nenddef\n\ndef Test_nested_function()\n  def NestedDef(arg: string): string\n    return 'nested ' .. arg\n  enddef\n  NestedDef(':def')->assert_equal('nested :def')\n\n  func NestedFunc(arg)\n    return 'nested ' .. a:arg\n  endfunc\n  NestedFunc(':func')->assert_equal('nested :func')\n\n  CheckDefFailure(['def Nested()', 'enddef', 'Nested(66)'], 'E118:')\n  CheckDefFailure(['def Nested(arg: string)', 'enddef', 'Nested()'], 'E119:')\n\n  CheckDefFailure(['def s:Nested()', 'enddef'], 'E1075:')\n  CheckDefFailure(['def b:Nested()', 'enddef'], 'E1075:')\n\n  var lines =<< trim END\n      def Outer()\n        def Inner()\n          # comment\n        enddef\n        def Inner()\n        enddef\n      enddef\n  END\n  CheckDefFailure(lines, 'E1073:')\n\n  lines =<< trim END\n      def Outer()\n        def Inner()\n          # comment\n        enddef\n        def! Inner()\n        enddef\n      enddef\n  END\n  CheckDefFailure(lines, 'E1117:')\n\n  lines =<< trim END\n      vim9script\n      def Outer()\n        def Inner()\n          g:result = 'ok'\n        enddef\n        Inner()\n      enddef\n      Outer()\n      Inner()\n  END\n  CheckScriptFailure(lines, 'E117: Unknown function: Inner')\n  assert_equal('ok', g:result)\n  unlet g:result\n\n  # nested function inside conditional\n  lines =<< trim END\n      vim9script\n      var thecount = 0\n      if true\n        def Test(): number\n          def TheFunc(): number\n            thecount += 1\n            return thecount\n          enddef\n          return TheFunc()\n        enddef\n      endif\n      defcompile\n      assert_equal(1, Test())\n      assert_equal(2, Test())\n  END\n  CheckScriptSuccess(lines)\n\n  # also works when \"thecount\" is inside the \"if\" block\n  lines =<< trim END\n      vim9script\n      if true\n        var thecount = 0\n        def Test(): number\n          def TheFunc(): number\n            thecount += 1\n            return thecount\n          enddef\n          return TheFunc()\n        enddef\n      endif\n      defcompile\n      assert_equal(1, Test())\n      assert_equal(2, Test())\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Outer()\n        def Inner()\n          echo 'hello'\n        enddef burp\n      enddef\n      defcompile\n  END\n  CheckScriptFailure(lines, 'E1173: Text found after enddef: burp', 3)\nenddef\n\ndef Test_not_nested_function()\n  echo printf('%d',\n      function('len')('xxx'))\nenddef\n\nfunc Test_call_default_args_from_func()\n  call MyDefaultArgs()->assert_equal('string')\n  call MyDefaultArgs('one')->assert_equal('one')\n  call assert_fails('call MyDefaultArgs(\"one\", \"two\")', 'E118:', '', 3, 'Test_call_default_args_from_func')\nendfunc\n\ndef Test_nested_global_function()\n  var lines =<< trim END\n      vim9script\n      def Outer()\n          def g:Inner(): string\n              return 'inner'\n          enddef\n      enddef\n      defcompile\n      Outer()\n      g:Inner()->assert_equal('inner')\n      delfunc g:Inner\n      Outer()\n      g:Inner()->assert_equal('inner')\n      delfunc g:Inner\n      Outer()\n      g:Inner()->assert_equal('inner')\n      delfunc g:Inner\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Outer()\n          func g:Inner()\n            return 'inner'\n          endfunc\n      enddef\n      defcompile\n      Outer()\n      g:Inner()->assert_equal('inner')\n      delfunc g:Inner\n      Outer()\n      g:Inner()->assert_equal('inner')\n      delfunc g:Inner\n      Outer()\n      g:Inner()->assert_equal('inner')\n      delfunc g:Inner\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Outer()\n          def g:Inner(): string\n              return 'inner'\n          enddef\n      enddef\n      defcompile\n      Outer()\n      Outer()\n  END\n  CheckScriptFailure(lines, \"E122:\")\n  delfunc g:Inner\n\n  lines =<< trim END\n      vim9script\n      def Outer()\n        def g:Inner()\n          echo map([1, 2, 3], (_, v) => v + 1)\n        enddef\n        g:Inner()\n      enddef\n      Outer()\n  END\n  CheckScriptSuccess(lines)\n  delfunc g:Inner\n\n  lines =<< trim END\n      vim9script\n      def Func()\n        echo 'script'\n      enddef\n      def Outer()\n        def Func()\n          echo 'inner'\n        enddef\n      enddef\n      defcompile\n  END\n  CheckScriptFailure(lines, \"E1073:\", 1)\n\n  lines =<< trim END\n      vim9script\n      def Func()\n        echo 'script'\n      enddef\n      def Func()\n        echo 'script'\n      enddef\n  END\n  CheckScriptFailure(lines, \"E1073:\", 5)\nenddef\n\ndef DefListAll()\n  def\nenddef\n\ndef DefListOne()\n  def DefListOne\nenddef\n\ndef DefListMatches()\n  def /DefList\nenddef\n\ndef Test_nested_def_list()\n  var funcs = split(execute('call DefListAll()'), \"\\n\")\n  assert_true(len(funcs) > 10)\n  assert_true(funcs->index('def DefListAll()') >= 0)\n\n  funcs = split(execute('call DefListOne()'), \"\\n\")\n  assert_equal(['   def DefListOne()', '1    def DefListOne', '   enddef'], funcs)\n\n  funcs = split(execute('call DefListMatches()'), \"\\n\")\n  assert_true(len(funcs) >= 3)\n  assert_true(funcs->index('def DefListAll()') >= 0)\n  assert_true(funcs->index('def DefListOne()') >= 0)\n  assert_true(funcs->index('def DefListMatches()') >= 0)\n\n  var lines =<< trim END\n    vim9script\n    def Func()\n      def +Func+\n    enddef\n    defcompile\n  END\n  CheckScriptFailure(lines, 'E476:', 1)\nenddef\n\ndef Test_global_local_function()\n  var lines =<< trim END\n      vim9script\n      def g:Func(): string\n          return 'global'\n      enddef\n      def Func(): string\n          return 'local'\n      enddef\n      g:Func()->assert_equal('global')\n      Func()->assert_equal('local')\n      delfunc g:Func\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def g:Funcy()\n        echo 'funcy'\n      enddef\n      s:Funcy()\n  END\n  CheckScriptFailure(lines, 'E117:')\nenddef\n\ndef Test_local_function_shadows_global()\n  var lines =<< trim END\n      vim9script\n      def g:Gfunc(): string\n        return 'global'\n      enddef\n      def AnotherFunc(): number\n        var Gfunc = function('len')\n        return Gfunc('testing')\n      enddef\n      g:Gfunc()->assert_equal('global')\n      AnotherFunc()->assert_equal(7)\n      delfunc g:Gfunc\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def g:Func(): string\n        return 'global'\n      enddef\n      def AnotherFunc()\n        g:Func = function('len')\n      enddef\n      AnotherFunc()\n  END\n  CheckScriptFailure(lines, 'E705:')\n  delfunc g:Func\n\n  # global function is found without g: prefix\n  lines =<< trim END\n      vim9script\n      def g:Func(): string\n        return 'global'\n      enddef\n      def AnotherFunc(): string\n        return Func()\n      enddef\n      assert_equal('global', AnotherFunc())\n    delfunc g:Func\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def g:Func(): string\n        return 'global'\n      enddef\n      assert_equal('global', Func())\n      delfunc g:Func\n  END\n  CheckScriptSuccess(lines)\nenddef\n\nfunc TakesOneArg(arg)\n  echo a:arg\nendfunc\n\ndef Test_call_wrong_args()\n  CheckDefFailure(['TakesOneArg()'], 'E119:')\n  CheckDefFailure(['TakesOneArg(11, 22)'], 'E118:')\n  CheckDefFailure(['bufnr(xxx)'], 'E1001:')\n  CheckScriptFailure(['def Func(Ref: func(s: string))'], 'E475:')\n\n  var lines =<< trim END\n    vim9script\n    def Func(s: string)\n      echo s\n    enddef\n    Func([])\n  END\n  CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch, expected string but got list<unknown>', 5)\n\n  lines =<< trim END\n    vim9script\n    var name = 'piet'\n    def FuncOne(name: string)\n      echo nr\n    enddef\n  END\n  CheckScriptFailure(lines, 'E1168:')\n\n  lines =<< trim END\n    vim9script\n    def FuncOne(nr: number)\n      echo nr\n    enddef\n    def FuncTwo()\n      FuncOne()\n    enddef\n    defcompile\n  END\n  writefile(lines, 'Xscript')\n  var didCatch = false\n  try\n    source Xscript\n  catch\n    assert_match('E119: Not enough arguments for function: <SNR>\\d\\+_FuncOne', v:exception)\n    assert_match('Xscript\\[8\\]..function <SNR>\\d\\+_FuncTwo, line 1', v:throwpoint)\n    didCatch = true\n  endtry\n  assert_true(didCatch)\n\n  lines =<< trim END\n    vim9script\n    def FuncOne(nr: number)\n      echo nr\n    enddef\n    def FuncTwo()\n      FuncOne(1, 2)\n    enddef\n    defcompile\n  END\n  writefile(lines, 'Xscript')\n  didCatch = false\n  try\n    source Xscript\n  catch\n    assert_match('E118: Too many arguments for function: <SNR>\\d\\+_FuncOne', v:exception)\n    assert_match('Xscript\\[8\\]..function <SNR>\\d\\+_FuncTwo, line 1', v:throwpoint)\n    didCatch = true\n  endtry\n  assert_true(didCatch)\n\n  delete('Xscript')\nenddef\n\ndef Test_call_funcref_wrong_args()\n  var head =<< trim END\n      vim9script\n      def Func3(a1: string, a2: number, a3: list<number>)\n        echo a1 .. a2 .. a3[0]\n      enddef\n      def Testme()\n        var funcMap: dict<func> = {func: Func3}\n  END\n  var tail =<< trim END\n      enddef\n      Testme()\n  END\n  CheckScriptSuccess(head + [\"funcMap['func']('str', 123, [1, 2, 3])\"] + tail)\n\n  CheckScriptFailure(head + [\"funcMap['func']('str', 123)\"] + tail, 'E119:')\n  CheckScriptFailure(head + [\"funcMap['func']('str', 123, [1], 4)\"] + tail, 'E118:')\n\n  var lines =<< trim END\n      vim9script\n      var Ref: func(number): any\n      Ref = (j) => !j\n      echo Ref(false)\n  END\n  CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch, expected number but got bool', 4)\n\n  lines =<< trim END\n      vim9script\n      var Ref: func(number): any\n      Ref = (j) => !j\n      call Ref(false)\n  END\n  CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch, expected number but got bool', 4)\nenddef\n\ndef Test_call_lambda_args()\n  var lines =<< trim END\n    var Callback = (..._) => 'anything'\n    assert_equal('anything', Callback())\n    assert_equal('anything', Callback(1))\n    assert_equal('anything', Callback('a', 2))\n\n    assert_equal('xyz', ((a: string): string => a)('xyz'))\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  CheckDefFailure(['echo ((i) => 0)()'],\n                  'E119: Not enough arguments for function: ((i) => 0)()')\n\n  lines =<< trim END\n      var Ref = (x: number, y: number) => x + y\n      echo Ref(1, 'x')\n  END\n  CheckDefFailure(lines, 'E1013: Argument 2: type mismatch, expected number but got string')\n\n  lines =<< trim END\n    var Ref: func(job, string, number)\n    Ref = (x, y) => 0\n  END\n  CheckDefAndScriptFailure(lines, 'E1012:')\n\n  lines =<< trim END\n    var Ref: func(job, string)\n    Ref = (x, y, z) => 0\n  END\n  CheckDefAndScriptFailure(lines, 'E1012:')\n\n  lines =<< trim END\n      var one = 1\n      var l = [1, 2, 3]\n      echo map(l, (one) => one)\n  END\n  CheckDefFailure(lines, 'E1167:')\n  CheckScriptFailure(['vim9script'] + lines, 'E1168:')\n\n  lines =<< trim END\n    var Ref: func(any, ?any): bool\n    Ref = (_, y = 1) => false\n  END\n  CheckDefAndScriptFailure(lines, 'E1172:')\n\n  lines =<< trim END\n      var a = 0\n      var b = (a == 0 ? 1 : 2)\n      assert_equal(1, b)\n      var txt = 'a'\n      b = (txt =~ 'x' ? 1 : 2)\n      assert_equal(2, b)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      def ShadowLocal()\n        var one = 1\n        var l = [1, 2, 3]\n        echo map(l, (one) => one)\n      enddef\n  END\n  CheckDefFailure(lines, 'E1167:')\n\n  lines =<< trim END\n      def Shadowarg(one: number)\n        var l = [1, 2, 3]\n        echo map(l, (one) => one)\n      enddef\n  END\n  CheckDefFailure(lines, 'E1167:')\n\n  lines =<< trim END\n    echo ((a) => a)('aa', 'bb')\n  END\n  CheckDefAndScriptFailure(lines, 'E118:', 1)\n\n  lines =<< trim END\n    echo 'aa'->((a) => a)('bb')\n  END\n  CheckDefFailure(lines, 'E118: Too many arguments for function: ->((a) => a)(''bb'')', 1)\n  CheckScriptFailure(['vim9script'] + lines, 'E118: Too many arguments for function: <lambda>', 2)\nenddef\n\ndef Test_lambda_line_nr()\n  var lines =<< trim END\n      vim9script\n      # comment\n      # comment\n      var id = timer_start(1'000, (_) => 0)\n      var out = execute('verbose ' .. timer_info(id)[0].callback\n          ->string()\n          ->substitute(\"('\\\\|')\", ' ', 'g'))\n      assert_match('Last set from .* line 4', out)\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef FilterWithCond(x: string, Cond: func(string): bool): bool\n  return Cond(x)\nenddef\n\ndef Test_lambda_return_type()\n  var lines =<< trim END\n    var Ref = (): => 123\n  END\n  CheckDefAndScriptFailure(lines, 'E1157:', 1)\n\n  # no space before the return type\n  lines =<< trim END\n    var Ref = (x):number => x + 1\n  END\n  CheckDefAndScriptFailure(lines, 'E1069:', 1)\n\n  # this works\n  for x in ['foo', 'boo']\n    echo FilterWithCond(x, (v) => v =~ '^b')\n  endfor\n\n  # this fails\n  lines =<< trim END\n      echo FilterWithCond('foo', (v) => v .. '^b')\n  END\n  CheckDefAndScriptFailure(lines, 'E1013: Argument 2: type mismatch, expected func(string): bool but got func(any): string', 1)\n\n  lines =<< trim END\n      var Lambda1 = (x) => {\n              return x\n              }\n      assert_equal('asdf', Lambda1('asdf'))\n      var Lambda2 = (x): string => {\n              return x\n              }\n      assert_equal('foo', Lambda2('foo'))\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var Lambda = (x): string => {\n              return x\n              }\n      echo Lambda(['foo'])\n  END\n  CheckDefExecAndScriptFailure(lines, 'E1012:')\nenddef\n\ndef Test_lambda_uses_assigned_var()\n  CheckDefSuccess([\n        'var x: any = \"aaa\"'\n        'x = filter([\"bbb\"], (_, v) => v =~ x)'])\nenddef\n\ndef Test_pass_legacy_lambda_to_def_func()\n  var lines =<< trim END\n      vim9script\n      func Foo()\n        eval s:Bar({x -> 0})\n      endfunc\n      def Bar(y: any)\n      enddef\n      Foo()\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def g:TestFunc(f: func)\n      enddef\n      legacy call g:TestFunc({-> 0})\n      delfunc g:TestFunc\n\n      def g:TestFunc(f: func(number))\n      enddef\n      legacy call g:TestFunc({nr -> 0})\n      delfunc g:TestFunc\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_lambda_in_reduce_line_break()\n  # this was using freed memory\n  var lines =<< trim END\n      vim9script\n      const result: dict<number> =\n          ['Bob', 'Sam', 'Cat', 'Bob', 'Cat', 'Cat']\n          ->reduce((acc, val) => {\n              if has_key(acc, val)\n                  acc[val] += 1\n                  return acc\n              else\n                  acc[val] = 1\n                  return acc\n              endif\n          }, {})\n      assert_equal({Bob: 2, Sam: 1, Cat: 3}, result)\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_set_opfunc_to_lambda()\n  var lines =<< trim END\n    vim9script\n    nnoremap <expr> <F4> <SID>CountSpaces() .. '_'\n    def CountSpaces(type = ''): string\n      if type == ''\n        &operatorfunc = (t) => CountSpaces(t)\n        return 'g@'\n      endif\n      normal! '[V']y\n      g:result = getreg('\"')->count(' ')\n      return ''\n    enddef\n    new\n    'a b c d e'->setline(1)\n    feedkeys(\"\\<F4>\", 'x')\n    assert_equal(4, g:result)\n    bwipe!\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_set_opfunc_to_global_function()\n  var lines =<< trim END\n    vim9script\n    def g:CountSpaces(type = ''): string\n      normal! '[V']y\n      g:result = getreg('\"')->count(' ')\n      return ''\n    enddef\n    # global function works at script level\n    &operatorfunc = g:CountSpaces\n    new\n    'a b c d e'->setline(1)\n    feedkeys(\"g@_\", 'x')\n    assert_equal(4, g:result)\n\n    &operatorfunc = ''\n    g:result = 0\n    # global function works in :def function\n    def Func()\n      &operatorfunc = g:CountSpaces\n    enddef\n    Func()\n    feedkeys(\"g@_\", 'x')\n    assert_equal(4, g:result)\n\n    bwipe!\n  END\n  CheckScriptSuccess(lines)\n  &operatorfunc = ''\nenddef\n\ndef Test_use_script_func_name_with_prefix()\n  var lines =<< trim END\n      vim9script\n      func s:Getit()\n        return 'it'\n      endfunc\n      var Fn = s:Getit\n      assert_equal('it', Fn())\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_lambda_type_allocated()\n  # Check that unreferencing a partial using a lambda can use the variable type\n  # after the lambda has been freed and does not leak memory.\n  var lines =<< trim END\n    vim9script\n\n    func MyomniFunc1(val, findstart, base)\n      return a:findstart ? 0 : []\n    endfunc\n\n    var Lambda = (a, b) => MyomniFunc1(19, a, b)\n    &omnifunc = Lambda\n    Lambda = (a, b) => MyomniFunc1(20, a, b)\n    &omnifunc = string(Lambda)\n    Lambda = (a, b) => strlen(a)\n  END\n  CheckScriptSuccess(lines)\nenddef\n\n\" Default arg and varargs\ndef MyDefVarargs(one: string, two = 'foo', ...rest: list<string>): string\n  var res = one .. ',' .. two\n  for s in rest\n    res ..= ',' .. s\n  endfor\n  return res\nenddef\n\ndef Test_call_def_varargs()\n  assert_fails('MyDefVarargs()', 'E119:', '', 1, 'Test_call_def_varargs')\n  MyDefVarargs('one')->assert_equal('one,foo')\n  MyDefVarargs('one', 'two')->assert_equal('one,two')\n  MyDefVarargs('one', 'two', 'three')->assert_equal('one,two,three')\n  CheckDefFailure(['MyDefVarargs(\"one\", 22)'],\n      'E1013: Argument 2: type mismatch, expected string but got number')\n  CheckDefFailure(['MyDefVarargs(\"one\", \"two\", 123)'],\n      'E1013: Argument 3: type mismatch, expected string but got number')\n\n  var lines =<< trim END\n      vim9script\n      def Func(...l: list<string>)\n        echo l\n      enddef\n      Func('a', 'b', 'c')\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Func(...l: list<string>)\n        echo l\n      enddef\n      Func()\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Func(...l: list<any>)\n        echo l\n      enddef\n      Func(0)\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Func(...l: any)\n        echo l\n      enddef\n      Func(0)\n  END\n  CheckScriptFailure(lines, 'E1180:', 2)\n\n  lines =<< trim END\n      vim9script\n      def Func(..._l: list<string>)\n        echo _l\n      enddef\n      Func('a', 'b', 'c')\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Func(...l: list<string>)\n        echo l\n      enddef\n      Func(1, 2, 3)\n  END\n  CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch')\n\n  lines =<< trim END\n      vim9script\n      def Func(...l: list<string>)\n        echo l\n      enddef\n      Func('a', 9)\n  END\n  CheckScriptFailure(lines, 'E1013: Argument 2: type mismatch')\n\n  lines =<< trim END\n      vim9script\n      def Func(...l: list<string>)\n        echo l\n      enddef\n      Func(1, 'a')\n  END\n  CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch')\n\n  lines =<< trim END\n      vim9script\n      def Func(  # some comment\n                ...l = []\n                )\n        echo l\n      enddef\n  END\n  CheckScriptFailure(lines, 'E1160:')\n\n  lines =<< trim END\n      vim9script\n      def DoIt()\n        g:Later('')\n      enddef\n      defcompile\n      def g:Later(...l:  list<number>)\n      enddef\n      DoIt()\n  END\n  CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch, expected number but got string')\nenddef\n\nlet s:value = ''\n\ndef FuncOneDefArg(opt = 'text')\n  s:value = opt\nenddef\n\ndef FuncTwoDefArg(nr = 123, opt = 'text'): string\n  return nr .. opt\nenddef\n\ndef FuncVarargs(...arg: list<string>): string\n  return join(arg, ',')\nenddef\n\ndef Test_func_type_varargs()\n  var RefDefArg: func(?string)\n  RefDefArg = FuncOneDefArg\n  RefDefArg()\n  s:value->assert_equal('text')\n  RefDefArg('some')\n  s:value->assert_equal('some')\n\n  var RefDef2Arg: func(?number, ?string): string\n  RefDef2Arg = FuncTwoDefArg\n  RefDef2Arg()->assert_equal('123text')\n  RefDef2Arg(99)->assert_equal('99text')\n  RefDef2Arg(77, 'some')->assert_equal('77some')\n\n  CheckDefFailure(['var RefWrong: func(string?)'], 'E1010:')\n  CheckDefFailure(['var RefWrong: func(?string, string)'], 'E1007:')\n\n  var RefVarargs: func(...list<string>): string\n  RefVarargs = FuncVarargs\n  RefVarargs()->assert_equal('')\n  RefVarargs('one')->assert_equal('one')\n  RefVarargs('one', 'two')->assert_equal('one,two')\n\n  CheckDefFailure(['var RefWrong: func(...list<string>, string)'], 'E110:')\n  CheckDefFailure(['var RefWrong: func(...list<string>, ?string)'], 'E110:')\nenddef\n\n\" Only varargs\ndef MyVarargsOnly(...args: list<string>): string\n  return join(args, ',')\nenddef\n\ndef Test_call_varargs_only()\n  MyVarargsOnly()->assert_equal('')\n  MyVarargsOnly('one')->assert_equal('one')\n  MyVarargsOnly('one', 'two')->assert_equal('one,two')\n  CheckDefFailure(['MyVarargsOnly(1)'], 'E1013: Argument 1: type mismatch, expected string but got number')\n  CheckDefFailure(['MyVarargsOnly(\"one\", 2)'], 'E1013: Argument 2: type mismatch, expected string but got number')\nenddef\n\ndef Test_using_var_as_arg()\n  writefile(['def Func(x: number)',  'var x = 234', 'enddef', 'defcompile'], 'Xdef')\n  assert_fails('so Xdef', 'E1006:', '', 1, 'Func')\n  delete('Xdef')\nenddef\n\ndef DictArg(arg: dict<string>)\n  arg['key'] = 'value'\nenddef\n\ndef ListArg(arg: list<string>)\n  arg[0] = 'value'\nenddef\n\ndef Test_assign_to_argument()\n  # works for dict and list\n  var d: dict<string> = {}\n  DictArg(d)\n  d['key']->assert_equal('value')\n  var l: list<string> = []\n  ListArg(l)\n  l[0]->assert_equal('value')\n\n  CheckScriptFailure(['def Func(arg: number)', 'arg = 3', 'enddef', 'defcompile'], 'E1090:')\n  delfunc! g:Func\nenddef\n\n\" These argument names are reserved in legacy functions.\ndef WithReservedNames(firstline: string, lastline: string): string\n  return firstline .. lastline\nenddef\n\ndef Test_argument_names()\n  assert_equal('OK', WithReservedNames('O', 'K'))\nenddef\n\ndef Test_call_func_defined_later()\n  g:DefinedLater('one')->assert_equal('one')\n  assert_fails('NotDefined(\"one\")', 'E117:', '', 2, 'Test_call_func_defined_later')\nenddef\n\nfunc DefinedLater(arg)\n  return a:arg\nendfunc\n\ndef Test_call_funcref()\n  g:SomeFunc('abc')->assert_equal(3)\n  assert_fails('NotAFunc()', 'E117:', '', 2, 'Test_call_funcref') # comment after call\n  assert_fails('g:NotAFunc()', 'E1085:', '', 3, 'Test_call_funcref')\n\n  var lines =<< trim END\n    vim9script\n    def RetNumber(): number\n      return 123\n    enddef\n    var Funcref: func: number = function('RetNumber')\n    Funcref()->assert_equal(123)\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n    vim9script\n    def RetNumber(): number\n      return 123\n    enddef\n    def Bar(F: func: number): number\n      return F()\n    enddef\n    var Funcref = function('RetNumber')\n    Bar(Funcref)->assert_equal(123)\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n    vim9script\n    def UseNumber(nr: number)\n      echo nr\n    enddef\n    var Funcref: func(number) = function('UseNumber')\n    Funcref(123)\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n    vim9script\n    def UseNumber(nr: number)\n      echo nr\n    enddef\n    var Funcref: func(string) = function('UseNumber')\n  END\n  CheckScriptFailure(lines, 'E1012: Type mismatch; expected func(string) but got func(number)')\n\n  lines =<< trim END\n    vim9script\n    def EchoNr(nr = 34)\n      g:echo = nr\n    enddef\n    var Funcref: func(?number) = function('EchoNr')\n    Funcref()\n    g:echo->assert_equal(34)\n    Funcref(123)\n    g:echo->assert_equal(123)\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n    vim9script\n    def EchoList(...l: list<number>)\n      g:echo = l\n    enddef\n    var Funcref: func(...list<number>) = function('EchoList')\n    Funcref()\n    g:echo->assert_equal([])\n    Funcref(1, 2, 3)\n    g:echo->assert_equal([1, 2, 3])\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n    vim9script\n    def OptAndVar(nr: number, opt = 12, ...l: list<number>): number\n      g:optarg = opt\n      g:listarg = l\n      return nr\n    enddef\n    var Funcref: func(number, ?number, ...list<number>): number = function('OptAndVar')\n    Funcref(10)->assert_equal(10)\n    g:optarg->assert_equal(12)\n    g:listarg->assert_equal([])\n\n    Funcref(11, 22)->assert_equal(11)\n    g:optarg->assert_equal(22)\n    g:listarg->assert_equal([])\n\n    Funcref(17, 18, 1, 2, 3)->assert_equal(17)\n    g:optarg->assert_equal(18)\n    g:listarg->assert_equal([1, 2, 3])\n  END\n  CheckScriptSuccess(lines)\nenddef\n\nlet SomeFunc = function('len')\nlet NotAFunc = 'text'\n\ndef CombineFuncrefTypes()\n  # same arguments, different return type\n  var Ref1: func(bool): string\n  var Ref2: func(bool): number\n  var Ref3: func(bool): any\n  Ref3 = g:cond ? Ref1 : Ref2\n\n  # different number of arguments\n  var Refa1: func(bool): number\n  var Refa2: func(bool, number): number\n  var Refa3: func: number\n  Refa3 = g:cond ? Refa1 : Refa2\n\n  # different argument types\n  var Refb1: func(bool, string): number\n  var Refb2: func(string, number): number\n  var Refb3: func(any, any): number\n  Refb3 = g:cond ? Refb1 : Refb2\nenddef\n\ndef FuncWithForwardCall()\n  return g:DefinedEvenLater(\"yes\")\nenddef\n\ndef DefinedEvenLater(arg: string): string\n  return arg\nenddef\n\ndef Test_error_in_nested_function()\n  # Error in called function requires unwinding the call stack.\n  assert_fails('FuncWithForwardCall()', 'E1096:', '', 1, 'FuncWithForwardCall')\nenddef\n\ndef Test_return_type_wrong()\n  CheckScriptFailure([\n        'def Func(): number',\n        'return \"a\"',\n        'enddef',\n        'defcompile'], 'expected number but got string')\n  delfunc! g:Func\n  CheckScriptFailure([\n        'def Func(): string',\n        'return 1',\n        'enddef',\n        'defcompile'], 'expected string but got number')\n  delfunc! g:Func\n  CheckScriptFailure([\n        'def Func(): void',\n        'return \"a\"',\n        'enddef',\n        'defcompile'],\n        'E1096: Returning a value in a function without a return type')\n  delfunc! g:Func\n  CheckScriptFailure([\n        'def Func()',\n        'return \"a\"',\n        'enddef',\n        'defcompile'],\n        'E1096: Returning a value in a function without a return type')\n  delfunc! g:Func\n\n  CheckScriptFailure([\n        'def Func(): number',\n        'return',\n        'enddef',\n        'defcompile'], 'E1003:')\n  delfunc! g:Func\n\n  CheckScriptFailure([\n        'def Func():number',\n        'return 123',\n        'enddef',\n        'defcompile'], 'E1069:')\n  delfunc! g:Func\n\n  CheckScriptFailure([\n        'def Func() :number',\n        'return 123',\n        'enddef',\n        'defcompile'], 'E1059:')\n  delfunc! g:Func\n\n  CheckScriptFailure([\n        'def Func() : number',\n        'return 123',\n        'enddef',\n        'defcompile'], 'E1059:')\n  delfunc! g:Func\n\n  CheckScriptFailure(['def Func(): list', 'return []', 'enddef'], 'E1008:')\n  delfunc! g:Func\n  CheckScriptFailure(['def Func(): dict', 'return {}', 'enddef'], 'E1008:')\n  delfunc! g:Func\n  CheckScriptFailure(['def Func()', 'return 1'], 'E1057:')\n  delfunc! g:Func\n\n  CheckScriptFailure([\n        'vim9script',\n        'def FuncB()',\n        '  return 123',\n        'enddef',\n        'def FuncA()',\n        '   FuncB()',\n        'enddef',\n        'defcompile'], 'E1096:')\nenddef\n\ndef Test_arg_type_wrong()\n  CheckScriptFailure(['def Func3(items: list)', 'echo \"a\"', 'enddef'], 'E1008: Missing <type>')\n  CheckScriptFailure(['def Func4(...)', 'echo \"a\"', 'enddef'], 'E1055: Missing name after ...')\n  CheckScriptFailure(['def Func5(items:string)', 'echo \"a\"'], 'E1069:')\n  CheckScriptFailure(['def Func5(items)', 'echo \"a\"'], 'E1077:')\n  CheckScriptFailure(['def Func6(...x:list<number>)', 'echo \"a\"', 'enddef'], 'E1069:')\n  CheckScriptFailure(['def Func7(...x: int)', 'echo \"a\"', 'enddef'], 'E1010:')\nenddef\n\ndef Test_white_space_before_comma()\n  var lines =<< trim END\n    vim9script\n    def Func(a: number , b: number)\n    enddef\n  END\n  CheckScriptFailure(lines, 'E1068:')\n  call assert_fails('vim9cmd echo stridx(\"a\" .. \"b\" , \"a\")', 'E1068:')\nenddef\n\ndef Test_white_space_after_comma()\n  var lines =<< trim END\n    vim9script\n    def Func(a: number,b: number)\n    enddef\n  END\n  CheckScriptFailure(lines, 'E1069:')\n\n  # OK in legacy function\n  lines =<< trim END\n    vim9script\n    func Func(a,b)\n    endfunc\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_vim9script_call()\n  var lines =<< trim END\n    vim9script\n    var name = ''\n    def MyFunc(arg: string)\n       name = arg\n    enddef\n    MyFunc('foobar')\n    name->assert_equal('foobar')\n\n    var str = 'barfoo'\n    str->MyFunc()\n    name->assert_equal('barfoo')\n\n    g:value = 'value'\n    g:value->MyFunc()\n    name->assert_equal('value')\n\n    var listvar = []\n    def ListFunc(arg: list<number>)\n       listvar = arg\n    enddef\n    [1, 2, 3]->ListFunc()\n    listvar->assert_equal([1, 2, 3])\n\n    var dictvar = {}\n    def DictFunc(arg: dict<number>)\n       dictvar = arg\n    enddef\n    {a: 1, b: 2}->DictFunc()\n    dictvar->assert_equal({a: 1, b: 2})\n    def CompiledDict()\n      {a: 3, b: 4}->DictFunc()\n    enddef\n    CompiledDict()\n    dictvar->assert_equal({a: 3, b: 4})\n\n    {a: 3, b: 4}->DictFunc()\n    dictvar->assert_equal({a: 3, b: 4})\n\n    ('text')->MyFunc()\n    name->assert_equal('text')\n    (\"some\")->MyFunc()\n    name->assert_equal('some')\n\n    # line starting with single quote is not a mark\n    # line starting with double quote can be a method call\n    'asdfasdf'->MyFunc()\n    name->assert_equal('asdfasdf')\n    \"xyz\"->MyFunc()\n    name->assert_equal('xyz')\n\n    def UseString()\n      'xyork'->MyFunc()\n    enddef\n    UseString()\n    name->assert_equal('xyork')\n\n    def UseString2()\n      \"knife\"->MyFunc()\n    enddef\n    UseString2()\n    name->assert_equal('knife')\n\n    # prepending a colon makes it a mark\n    new\n    setline(1, ['aaa', 'bbb', 'ccc'])\n    normal! 3Gmt1G\n    :'t\n    getcurpos()[1]->assert_equal(3)\n    bwipe!\n\n    MyFunc(\n        'continued'\n        )\n    assert_equal('continued',\n            name\n            )\n\n    call MyFunc(\n        'more'\n          ..\n          'lines'\n        )\n    assert_equal(\n        'morelines',\n        name)\n  END\n  writefile(lines, 'Xcall.vim')\n  source Xcall.vim\n  delete('Xcall.vim')\nenddef\n\ndef Test_vim9script_call_fail_decl()\n  var lines =<< trim END\n    vim9script\n    var name = ''\n    def MyFunc(arg: string)\n       var name = 123\n    enddef\n    defcompile\n  END\n  CheckScriptFailure(lines, 'E1054:')\nenddef\n\ndef Test_vim9script_call_fail_type()\n  var lines =<< trim END\n    vim9script\n    def MyFunc(arg: string)\n      echo arg\n    enddef\n    MyFunc(1234)\n  END\n  CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch, expected string but got number')\nenddef\n\ndef Test_vim9script_call_fail_const()\n  var lines =<< trim END\n    vim9script\n    const var = ''\n    def MyFunc(arg: string)\n       var = 'asdf'\n    enddef\n    defcompile\n  END\n  writefile(lines, 'Xcall_const.vim')\n  assert_fails('source Xcall_const.vim', 'E46:', '', 1, 'MyFunc')\n  delete('Xcall_const.vim')\n\n  lines =<< trim END\n      const g:Aconst = 77\n      def Change()\n        # comment\n        g:Aconst = 99\n      enddef\n      call Change()\n      unlet g:Aconst\n  END\n  CheckScriptFailure(lines, 'E741: Value is locked: Aconst', 2)\nenddef\n\n\" Test that inside :function a Python function can be defined, :def is not\n\" recognized.\nfunc Test_function_python()\n  CheckFeature python3\n  let py = 'python3'\n  execute py \"<< EOF\"\ndef do_something():\n  return 1\nEOF\nendfunc\n\ndef Test_delfunc()\n  var lines =<< trim END\n    vim9script\n    def g:GoneSoon()\n      echo 'hello'\n    enddef\n\n    def CallGoneSoon()\n      GoneSoon()\n    enddef\n    defcompile\n\n    delfunc g:GoneSoon\n    CallGoneSoon()\n  END\n  writefile(lines, 'XToDelFunc')\n  assert_fails('so XToDelFunc', 'E933:', '', 1, 'CallGoneSoon')\n  assert_fails('so XToDelFunc', 'E933:', '', 1, 'CallGoneSoon')\n\n  delete('XToDelFunc')\nenddef\n\nfunc Test_free_dict_while_in_funcstack()\n  \" relies on the sleep command\n  CheckUnix\n  call Run_Test_free_dict_while_in_funcstack()\nendfunc\n\ndef Run_Test_free_dict_while_in_funcstack()\n\n  # this was freeing the TermRun() default argument dictionary while it was\n  # still referenced in a funcstack_T\n  var lines =<< trim END\n      vim9script\n\n      &updatetime = 400\n      def TermRun(_ = {})\n          def Post()\n          enddef\n          def Exec()\n              term_start('sleep 1', {\n                  term_finish: 'close',\n                  exit_cb: (_, _) => Post(),\n              })\n          enddef\n          Exec()\n      enddef\n      nnoremap <F4> <Cmd>call <SID>TermRun()<CR>\n      timer_start(100, (_) => feedkeys(\"\\<F4>\"))\n      timer_start(1000, (_) => feedkeys(\"\\<F4>\"))\n      sleep 1500m\n  END\n  CheckScriptSuccess(lines)\n  nunmap <F4>\n  set updatetime&\nenddef\n\ndef Test_redef_failure()\n  writefile(['def Func0(): string',  'return \"Func0\"', 'enddef'], 'Xdef')\n  so Xdef\n  writefile(['def Func1(): string',  'return \"Func1\"', 'enddef'], 'Xdef')\n  so Xdef\n  writefile(['def! Func0(): string', 'enddef', 'defcompile'], 'Xdef')\n  assert_fails('so Xdef', 'E1027:', '', 1, 'Func0')\n  writefile(['def Func2(): string',  'return \"Func2\"', 'enddef'], 'Xdef')\n  so Xdef\n  delete('Xdef')\n\n  assert_fails('g:Func0()', 'E1091:')\n  g:Func1()->assert_equal('Func1')\n  g:Func2()->assert_equal('Func2')\n\n  delfunc! Func0\n  delfunc! Func1\n  delfunc! Func2\nenddef\n\ndef Test_vim9script_func()\n  var lines =<< trim END\n    vim9script\n    func Func(arg)\n      echo a:arg\n    endfunc\n    Func('text')\n  END\n  writefile(lines, 'XVim9Func')\n  so XVim9Func\n\n  delete('XVim9Func')\nenddef\n\nlet s:funcResult = 0\n\ndef FuncNoArgNoRet()\n  s:funcResult = 11\nenddef\n\ndef FuncNoArgRetNumber(): number\n  s:funcResult = 22\n  return 1234\nenddef\n\ndef FuncNoArgRetString(): string\n  s:funcResult = 45\n  return 'text'\nenddef\n\ndef FuncOneArgNoRet(arg: number)\n  s:funcResult = arg\nenddef\n\ndef FuncOneArgRetNumber(arg: number): number\n  s:funcResult = arg\n  return arg\nenddef\n\ndef FuncTwoArgNoRet(one: bool, two: number)\n  s:funcResult = two\nenddef\n\ndef FuncOneArgRetString(arg: string): string\n  return arg\nenddef\n\ndef FuncOneArgRetAny(arg: any): any\n  return arg\nenddef\n\ndef Test_func_type()\n  var Ref1: func()\n  s:funcResult = 0\n  Ref1 = FuncNoArgNoRet\n  Ref1()\n  s:funcResult->assert_equal(11)\n\n  var Ref2: func\n  s:funcResult = 0\n  Ref2 = FuncNoArgNoRet\n  Ref2()\n  s:funcResult->assert_equal(11)\n\n  s:funcResult = 0\n  Ref2 = FuncOneArgNoRet\n  Ref2(12)\n  s:funcResult->assert_equal(12)\n\n  s:funcResult = 0\n  Ref2 = FuncNoArgRetNumber\n  Ref2()->assert_equal(1234)\n  s:funcResult->assert_equal(22)\n\n  s:funcResult = 0\n  Ref2 = FuncOneArgRetNumber\n  Ref2(13)->assert_equal(13)\n  s:funcResult->assert_equal(13)\nenddef\n\ndef Test_repeat_return_type()\n  var res = 0\n  for n in repeat([1], 3)\n    res += n\n  endfor\n  res->assert_equal(3)\n\n  res = 0\n  for n in add([1, 2], 3)\n    res += n\n  endfor\n  res->assert_equal(6)\nenddef\n\ndef Test_argv_return_type()\n  next fileone filetwo\n  var res = ''\n  for name in argv()\n    res ..= name\n  endfor\n  res->assert_equal('fileonefiletwo')\nenddef\n\ndef Test_func_type_part()\n  var RefVoid: func: void\n  RefVoid = FuncNoArgNoRet\n  RefVoid = FuncOneArgNoRet\n  CheckDefFailure(['var RefVoid: func: void', 'RefVoid = FuncNoArgRetNumber'], 'E1012: Type mismatch; expected func(...) but got func(): number')\n  CheckDefFailure(['var RefVoid: func: void', 'RefVoid = FuncNoArgRetString'], 'E1012: Type mismatch; expected func(...) but got func(): string')\n\n  var RefAny: func(): any\n  RefAny = FuncNoArgRetNumber\n  RefAny = FuncNoArgRetString\n  CheckDefFailure(['var RefAny: func(): any', 'RefAny = FuncNoArgNoRet'], 'E1012: Type mismatch; expected func(): any but got func()')\n  CheckDefFailure(['var RefAny: func(): any', 'RefAny = FuncOneArgNoRet'], 'E1012: Type mismatch; expected func(): any but got func(number)')\n\n  var RefAnyNoArgs: func: any = RefAny\n\n  var RefNr: func: number\n  RefNr = FuncNoArgRetNumber\n  RefNr = FuncOneArgRetNumber\n  CheckDefFailure(['var RefNr: func: number', 'RefNr = FuncNoArgNoRet'], 'E1012: Type mismatch; expected func(...): number but got func()')\n  CheckDefFailure(['var RefNr: func: number', 'RefNr = FuncNoArgRetString'], 'E1012: Type mismatch; expected func(...): number but got func(): string')\n\n  var RefStr: func: string\n  RefStr = FuncNoArgRetString\n  RefStr = FuncOneArgRetString\n  CheckDefFailure(['var RefStr: func: string', 'RefStr = FuncNoArgNoRet'], 'E1012: Type mismatch; expected func(...): string but got func()')\n  CheckDefFailure(['var RefStr: func: string', 'RefStr = FuncNoArgRetNumber'], 'E1012: Type mismatch; expected func(...): string but got func(): number')\nenddef\n\ndef Test_func_type_fails()\n  CheckDefFailure(['var ref1: func()'], 'E704:')\n\n  CheckDefFailure(['var Ref1: func()', 'Ref1 = FuncNoArgRetNumber'], 'E1012: Type mismatch; expected func() but got func(): number')\n  CheckDefFailure(['var Ref1: func()', 'Ref1 = FuncOneArgNoRet'], 'E1012: Type mismatch; expected func() but got func(number)')\n  CheckDefFailure(['var Ref1: func()', 'Ref1 = FuncOneArgRetNumber'], 'E1012: Type mismatch; expected func() but got func(number): number')\n  CheckDefFailure(['var Ref1: func(bool)', 'Ref1 = FuncTwoArgNoRet'], 'E1012: Type mismatch; expected func(bool) but got func(bool, number)')\n  CheckDefFailure(['var Ref1: func(?bool)', 'Ref1 = FuncTwoArgNoRet'], 'E1012: Type mismatch; expected func(?bool) but got func(bool, number)')\n  CheckDefFailure(['var Ref1: func(...bool)', 'Ref1 = FuncTwoArgNoRet'], 'E1012: Type mismatch; expected func(...bool) but got func(bool, number)')\n\n  CheckDefFailure(['var RefWrong: func(string ,number)'], 'E1068:')\n  CheckDefFailure(['var RefWrong: func(string,number)'], 'E1069:')\n  CheckDefFailure(['var RefWrong: func(bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool)'], 'E1005:')\n  CheckDefFailure(['var RefWrong: func(bool):string'], 'E1069:')\nenddef\n\ndef Test_func_return_type()\n  var nr: number\n  nr = FuncNoArgRetNumber()\n  nr->assert_equal(1234)\n\n  nr = FuncOneArgRetAny(122)\n  nr->assert_equal(122)\n\n  var str: string\n  str = FuncOneArgRetAny('yes')\n  str->assert_equal('yes')\n\n  CheckDefFailure(['var str: string', 'str = FuncNoArgRetNumber()'], 'E1012: Type mismatch; expected string but got number')\nenddef\n\ndef Test_func_common_type()\n  def FuncOne(n: number): number\n    return n\n  enddef\n  def FuncTwo(s: string): number\n    return len(s)\n  enddef\n  def FuncThree(n: number, s: string): number\n    return n + len(s)\n  enddef\n  var list = [FuncOne, FuncTwo, FuncThree]\n  assert_equal(8, list[0](8))\n  assert_equal(4, list[1]('word'))\n  assert_equal(7, list[2](3, 'word'))\nenddef\n\ndef MultiLine(\n    arg1: string,\n    arg2 = 1234,\n    ...rest: list<string>\n      ): string\n  return arg1 .. arg2 .. join(rest, '-')\nenddef\n\ndef MultiLineComment(\n    arg1: string, # comment\n    arg2 = 1234, # comment\n    ...rest: list<string> # comment\n      ): string # comment\n  return arg1 .. arg2 .. join(rest, '-')\nenddef\n\ndef Test_multiline()\n  MultiLine('text')->assert_equal('text1234')\n  MultiLine('text', 777)->assert_equal('text777')\n  MultiLine('text', 777, 'one')->assert_equal('text777one')\n  MultiLine('text', 777, 'one', 'two')->assert_equal('text777one-two')\nenddef\n\nfunc Test_multiline_not_vim9()\n  call MultiLine('text')->assert_equal('text1234')\n  call MultiLine('text', 777)->assert_equal('text777')\n  call MultiLine('text', 777, 'one')->assert_equal('text777one')\n  call MultiLine('text', 777, 'one', 'two')->assert_equal('text777one-two')\nendfunc\n\n\n\" When using CheckScriptFailure() for the below test, E1010 is generated instead\n\" of E1056.\nfunc Test_E1056_1059()\n  let caught_1056 = 0\n  try\n    def F():\n      return 1\n    enddef\n  catch /E1056:/\n    let caught_1056 = 1\n  endtry\n  eval caught_1056->assert_equal(1)\n\n  let caught_1059 = 0\n  try\n    def F5(items : list)\n      echo 'a'\n    enddef\n  catch /E1059:/\n    let caught_1059 = 1\n  endtry\n  eval caught_1059->assert_equal(1)\nendfunc\n\nfunc DelMe()\n  echo 'DelMe'\nendfunc\n\ndef Test_error_reporting()\n  # comment lines at the start of the function\n  var lines =<< trim END\n    \" comment\n    def Func()\n      # comment\n      # comment\n      invalid\n    enddef\n    defcompile\n  END\n  writefile(lines, 'Xdef')\n  try\n    source Xdef\n    assert_report('should have failed')\n  catch /E476:/\n    v:exception->assert_match('Invalid command: invalid')\n    v:throwpoint->assert_match(', line 3$')\n  endtry\n  delfunc! g:Func\n\n  # comment lines after the start of the function\n  lines =<< trim END\n    \" comment\n    def Func()\n      var x = 1234\n      # comment\n      # comment\n      invalid\n    enddef\n    defcompile\n  END\n  writefile(lines, 'Xdef')\n  try\n    source Xdef\n    assert_report('should have failed')\n  catch /E476:/\n    v:exception->assert_match('Invalid command: invalid')\n    v:throwpoint->assert_match(', line 4$')\n  endtry\n  delfunc! g:Func\n\n  lines =<< trim END\n    vim9script\n    def Func()\n      var db = {foo: 1, bar: 2}\n      # comment\n      var x = db.asdf\n    enddef\n    defcompile\n    Func()\n  END\n  writefile(lines, 'Xdef')\n  try\n    source Xdef\n    assert_report('should have failed')\n  catch /E716:/\n    v:throwpoint->assert_match('_Func, line 3$')\n  endtry\n  delfunc! g:Func\n\n  delete('Xdef')\nenddef\n\ndef Test_deleted_function()\n  CheckDefExecFailure([\n      'var RefMe: func = function(\"g:DelMe\")',\n      'delfunc g:DelMe',\n      'echo RefMe()'], 'E117:')\nenddef\n\ndef Test_unknown_function()\n  CheckDefExecFailure([\n      'var Ref: func = function(\"NotExist\")',\n      'delfunc g:NotExist'], 'E700:')\nenddef\n\ndef RefFunc(Ref: func(any): any): string\n  return Ref('more')\nenddef\n\ndef Test_closure_simple()\n  var local = 'some '\n  RefFunc((s) => local .. s)->assert_equal('some more')\nenddef\n\ndef MakeRef()\n  var local = 'some '\n  g:Ref = (s) => local .. s\nenddef\n\ndef Test_closure_ref_after_return()\n  MakeRef()\n  g:Ref('thing')->assert_equal('some thing')\n  unlet g:Ref\nenddef\n\ndef MakeTwoRefs()\n  var local = ['some']\n  g:Extend = (s) => local->add(s)\n  g:Read = () => local\nenddef\n\ndef Test_closure_two_refs()\n  MakeTwoRefs()\n  join(g:Read(), ' ')->assert_equal('some')\n  g:Extend('more')\n  join(g:Read(), ' ')->assert_equal('some more')\n  g:Extend('even')\n  join(g:Read(), ' ')->assert_equal('some more even')\n\n  unlet g:Extend\n  unlet g:Read\nenddef\n\ndef ReadRef(Ref: func(): list<string>): string\n  return join(Ref(), ' ')\nenddef\n\ndef ExtendRef(Ref: func(string): list<string>, add: string)\n  Ref(add)\nenddef\n\ndef Test_closure_two_indirect_refs()\n  MakeTwoRefs()\n  ReadRef(g:Read)->assert_equal('some')\n  ExtendRef(g:Extend, 'more')\n  ReadRef(g:Read)->assert_equal('some more')\n  ExtendRef(g:Extend, 'even')\n  ReadRef(g:Read)->assert_equal('some more even')\n\n  unlet g:Extend\n  unlet g:Read\nenddef\n\ndef MakeArgRefs(theArg: string)\n  var local = 'loc_val'\n  g:UseArg = (s) => theArg .. '/' .. local .. '/' .. s\nenddef\n\ndef MakeArgRefsVarargs(theArg: string, ...rest: list<string>)\n  var local = 'the_loc'\n  g:UseVararg = (s) => theArg .. '/' .. local .. '/' .. s .. '/' .. join(rest)\nenddef\n\ndef Test_closure_using_argument()\n  MakeArgRefs('arg_val')\n  g:UseArg('call_val')->assert_equal('arg_val/loc_val/call_val')\n\n  MakeArgRefsVarargs('arg_val', 'one', 'two')\n  g:UseVararg('call_val')->assert_equal('arg_val/the_loc/call_val/one two')\n\n  unlet g:UseArg\n  unlet g:UseVararg\n\n  var lines =<< trim END\n      vim9script\n      def Test(Fun: func(number): number): list<number>\n        return map([1, 2, 3], (_, i) => Fun(i))\n      enddef\n      def Inc(nr: number): number\n        return nr + 2\n      enddef\n      assert_equal([3, 4, 5], Test(Inc))\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef MakeGetAndAppendRefs()\n  var local = 'a'\n\n  def Append(arg: string)\n    local ..= arg\n  enddef\n  g:Append = Append\n\n  def Get(): string\n    return local\n  enddef\n  g:Get = Get\nenddef\n\ndef Test_closure_append_get()\n  MakeGetAndAppendRefs()\n  g:Get()->assert_equal('a')\n  g:Append('-b')\n  g:Get()->assert_equal('a-b')\n  g:Append('-c')\n  g:Get()->assert_equal('a-b-c')\n\n  unlet g:Append\n  unlet g:Get\nenddef\n\ndef Test_nested_closure()\n  var local = 'text'\n  def Closure(arg: string): string\n    return local .. arg\n  enddef\n  Closure('!!!')->assert_equal('text!!!')\nenddef\n\nfunc GetResult(Ref)\n  return a:Ref('some')\nendfunc\n\ndef Test_call_closure_not_compiled()\n  var text = 'text'\n  g:Ref = (s) =>  s .. text\n  GetResult(g:Ref)->assert_equal('sometext')\nenddef\n\ndef Test_double_closure_fails()\n  var lines =<< trim END\n    vim9script\n    def Func()\n      var name = 0\n      for i in range(2)\n          timer_start(0, () => name)\n      endfor\n    enddef\n    Func()\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_nested_closure_used()\n  var lines =<< trim END\n      vim9script\n      def Func()\n        var x = 'hello'\n        var Closure = () => x\n        g:Myclosure = () => Closure()\n      enddef\n      Func()\n      assert_equal('hello', g:Myclosure())\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_nested_closure_fails()\n  var lines =<< trim END\n    vim9script\n    def FuncA()\n      FuncB(0)\n    enddef\n    def FuncB(n: number): list<string>\n      return map([0], (_, v) => n)\n    enddef\n    FuncA()\n  END\n  CheckScriptFailure(lines, 'E1012:')\nenddef\n\ndef Test_global_closure()\n  var lines =<< trim END\n      vim9script\n      def ReverseEveryNLines(n: number, line1: number, line2: number)\n        var mods = 'sil keepj keepp lockm '\n        var range = ':' .. line1 .. ',' .. line2\n        def g:Offset(): number\n            var offset = (line('.') - line1 + 1) % n\n            return offset != 0 ? offset : n\n        enddef\n        exe mods .. range .. 'g/^/exe \"m .-\" .. g:Offset()'\n      enddef\n\n      new\n      repeat(['aaa', 'bbb', 'ccc'], 3)->setline(1)\n      ReverseEveryNLines(3, 1, 9)\n  END\n  CheckScriptSuccess(lines)\n  var expected = repeat(['ccc', 'bbb', 'aaa'], 3)\n  assert_equal(expected, getline(1, 9))\n  bwipe!\nenddef\n\ndef Test_global_closure_called_directly()\n  var lines =<< trim END\n      vim9script\n      def Outer()\n        var x = 1\n        def g:Inner()\n          var y = x\n          x += 1\n          assert_equal(1, y)\n        enddef\n        g:Inner()\n        assert_equal(2, x)\n      enddef\n      Outer()\n  END\n  CheckScriptSuccess(lines)\n  delfunc g:Inner\nenddef\n\ndef Test_closure_called_from_legacy()\n  var lines =<< trim END\n      vim9script\n      def Func()\n        var outer = 'foo'\n        var F = () => {\n              outer = 'bar'\n            }\n        execute printf('call %s()', string(F))\n      enddef\n      Func()\n  END\n  CheckScriptFailure(lines, 'E1248')\nenddef\n\ndef Test_failure_in_called_function()\n  # this was using the frame index as the return value\n  var lines =<< trim END\n      vim9script\n      au TerminalWinOpen * eval [][0]\n      def PopupTerm(a: any)\n        # make sure typvals on stack are string\n        ['a', 'b', 'c', 'd', 'e', 'f', 'g']->join()\n        FireEvent()\n      enddef\n      def FireEvent()\n          do TerminalWinOpen\n      enddef\n      # use try/catch to make eval fail\n      try\n          call PopupTerm(0)\n      catch\n      endtry\n      au! TerminalWinOpen\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_nested_lambda()\n  var lines =<< trim END\n    vim9script\n    def Func()\n      var x = 4\n      var Lambda1 = () => 7\n      var Lambda2 = () => [Lambda1(), x]\n      var res = Lambda2()\n      assert_equal([7, 4], res)\n    enddef\n    Func()\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_double_nested_lambda()\n  var lines =<< trim END\n      vim9script\n      def F(head: string): func(string): func(string): string\n        return (sep: string): func(string): string => ((tail: string): string => {\n            return head .. sep .. tail\n          })\n      enddef\n      assert_equal('hello-there', F('hello')('-')('there'))\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_nested_inline_lambda()\n  var lines =<< trim END\n      vim9script\n      def F(text: string): func(string): func(string): string\n        return (arg: string): func(string): string => ((sep: string): string => {\n            return sep .. arg .. text\n          })\n      enddef\n      assert_equal('--there++', F('++')('there')('--'))\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      echo range(4)->mapnew((_, v) => {\n        return range(v) ->mapnew((_, s) => {\n          return string(s)\n          })\n        })\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n\n      def s:func()\n        range(10)\n          ->mapnew((_, _) => ({\n            key: range(10)->mapnew((_, _) => {\n              return ' '\n            }),\n          }))\n      enddef\n\n      defcomp\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Shadowed(): list<number>\n  var FuncList: list<func: number> = [() => 42]\n  return FuncList->mapnew((_, Shadowed) => Shadowed())\nenddef\n\ndef Test_lambda_arg_shadows_func()\n  assert_equal([42], Shadowed())\nenddef\n\ndef Line_continuation_in_def(dir: string = ''): string\n  var path: string = empty(dir)\n          \\ ? 'empty'\n          \\ : 'full'\n  return path\nenddef\n\ndef Test_line_continuation_in_def()\n  Line_continuation_in_def('.')->assert_equal('full')\nenddef\n\ndef Test_script_var_in_lambda()\n  var lines =<< trim END\n      vim9script\n      var script = 'test'\n      assert_equal(['test'], map(['one'], (_, _) => script))\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Line_continuation_in_lambda(): list<string>\n  var x = range(97, 100)\n      ->mapnew((_, v) => nr2char(v)\n          ->toupper())\n      ->reverse()\n  return x\nenddef\n\ndef Test_line_continuation_in_lambda()\n  Line_continuation_in_lambda()->assert_equal(['D', 'C', 'B', 'A'])\n\n  var lines =<< trim END\n      vim9script\n      var res = [{n: 1, m: 2, s: 'xxx'}]\n                ->mapnew((_, v: dict<any>): string => printf('%d:%d:%s',\n                    v.n,\n                    v.m,\n                    substitute(v.s, '.*', 'yyy', '')\n                    ))\n      assert_equal(['1:2:yyy'], res)\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_list_lambda()\n  timer_start(1000, (_) => 0)\n  var body = execute(timer_info()[0].callback\n         ->string()\n         ->substitute(\"('\", ' ', '')\n         ->substitute(\"')\", '', '')\n         ->substitute('function\\zs', ' ', ''))\n  assert_match('def <lambda>\\d\\+(_: any): number\\n1  return 0\\n   enddef', body)\nenddef\n\ndef Test_lambda_block_variable()\n  var lines =<< trim END\n      vim9script\n      var flist: list<func>\n      for i in range(10)\n          var inloop = i\n          flist[i] = () => inloop\n      endfor\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      if true\n        var outloop = 5\n        var flist: list<func>\n        for i in range(10)\n          flist[i] = () => outloop\n        endfor\n      endif\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      if true\n        var outloop = 5\n      endif\n      var flist: list<func>\n      for i in range(10)\n        flist[i] = () => outloop\n      endfor\n  END\n  CheckScriptFailure(lines, 'E1001: Variable not found: outloop', 1)\n\n  lines =<< trim END\n      vim9script\n      for i in range(10)\n        var Ref = () => 0\n      endfor\n      assert_equal(0, ((i) => 0)(0))\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_legacy_lambda()\n  legacy echo {x -> 'hello ' .. x}('foo')\n\n  var lines =<< trim END\n      echo {x -> 'hello ' .. x}('foo')\n  END\n  CheckDefAndScriptFailure(lines, 'E720:')\n\n  lines =<< trim END\n      vim9script\n      def Func()\n        echo (() => 'no error')()\n      enddef\n      legacy call s:Func()\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_legacy()\n  var lines =<< trim END\n      vim9script\n      func g:LegacyFunction()\n        let g:legacyvar = 1\n      endfunc\n      def Testit()\n        legacy call g:LegacyFunction()\n      enddef\n      Testit()\n      assert_equal(1, g:legacyvar)\n      unlet g:legacyvar\n      delfunc g:LegacyFunction\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_legacy_errors()\n  for cmd in ['if', 'elseif', 'else', 'endif',\n              'for', 'endfor', 'continue', 'break',\n              'while', 'endwhile',\n              'try', 'catch', 'finally', 'endtry']\n    CheckDefFailure(['legacy ' .. cmd .. ' expr'], 'E1189:')\n  endfor\nenddef\n\ndef Test_call_legacy_with_dict()\n  var lines =<< trim END\n      vim9script\n      func Legacy() dict\n        let g:result = self.value\n      endfunc\n      def TestDirect()\n        var d = {value: 'yes', func: Legacy}\n        d.func()\n      enddef\n      TestDirect()\n      assert_equal('yes', g:result)\n      unlet g:result\n\n      def TestIndirect()\n        var d = {value: 'foo', func: Legacy}\n        var Fi = d.func\n        Fi()\n      enddef\n      TestIndirect()\n      assert_equal('foo', g:result)\n      unlet g:result\n\n      var d = {value: 'bar', func: Legacy}\n      d.func()\n      assert_equal('bar', g:result)\n      unlet g:result\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef DoFilterThis(a: string): list<string>\n  # closure nested inside another closure using argument\n  var Filter = (l) => filter(l, (_, v) => stridx(v, a) == 0)\n  return ['x', 'y', 'a', 'x2', 'c']->Filter()\nenddef\n\ndef Test_nested_closure_using_argument()\n  assert_equal(['x', 'x2'], DoFilterThis('x'))\nenddef\n\ndef Test_triple_nested_closure()\n  var what = 'x'\n  var Match = (val: string, cmp: string): bool => stridx(val, cmp) == 0\n  var Filter = (l) => filter(l, (_, v) => Match(v, what))\n  assert_equal(['x', 'x2'], ['x', 'y', 'a', 'x2', 'c']->Filter())\nenddef\n\nfunc Test_silent_echo()\n  CheckScreendump\n  call Run_Test_silent_echo()\nendfunc\n\ndef Run_Test_silent_echo()\n  var lines =<< trim END\n    vim9script\n    def EchoNothing()\n      silent echo ''\n    enddef\n    defcompile\n  END\n  writefile(lines, 'XTest_silent_echo')\n\n  # Check that the balloon shows up after a mouse move\n  var buf = RunVimInTerminal('-S XTest_silent_echo', {'rows': 6})\n  term_sendkeys(buf, \":abc\")\n  VerifyScreenDump(buf, 'Test_vim9_silent_echo', {})\n\n  # clean up\n  StopVimInTerminal(buf)\n  delete('XTest_silent_echo')\nenddef\n\ndef SilentlyError()\n  execute('silent! invalid')\n  g:did_it = 'yes'\nenddef\n\nfunc UserError()\n  silent! invalid\nendfunc\n\ndef SilentlyUserError()\n  UserError()\n  g:did_it = 'yes'\nenddef\n\n\" This can't be a :def function, because the assert would not be reached.\nfunc Test_ignore_silent_error()\n  let g:did_it = 'no'\n  call SilentlyError()\n  call assert_equal('yes', g:did_it)\n\n  let g:did_it = 'no'\n  call SilentlyUserError()\n  call assert_equal('yes', g:did_it)\n\n  unlet g:did_it\nendfunc\n\ndef Test_ignore_silent_error_in_filter()\n  var lines =<< trim END\n      vim9script\n      def Filter(winid: number, key: string): bool\n          if key == 'o'\n              silent! eval [][0]\n              return true\n          endif\n          return popup_filter_menu(winid, key)\n      enddef\n\n      popup_create('popup', {filter: Filter})\n      feedkeys(\"o\\r\", 'xnt')\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Fibonacci(n: number): number\n  if n < 2\n    return n\n  else\n    return Fibonacci(n - 1) + Fibonacci(n - 2)\n  endif\nenddef\n\ndef Test_recursive_call()\n  Fibonacci(20)->assert_equal(6765)\nenddef\n\ndef TreeWalk(dir: string): list<any>\n  return readdir(dir)->mapnew((_, val) =>\n            fnamemodify(dir .. '/' .. val, ':p')->isdirectory()\n               ? {[val]: TreeWalk(dir .. '/' .. val)}\n               : val\n             )\nenddef\n\ndef Test_closure_in_map()\n  mkdir('XclosureDir/tdir', 'p')\n  writefile(['111'], 'XclosureDir/file1')\n  writefile(['222'], 'XclosureDir/file2')\n  writefile(['333'], 'XclosureDir/tdir/file3')\n\n  TreeWalk('XclosureDir')->assert_equal(['file1', 'file2', {tdir: ['file3']}])\n\n  delete('XclosureDir', 'rf')\nenddef\n\ndef Test_invalid_function_name()\n  var lines =<< trim END\n      vim9script\n      def s: list<string>\n  END\n  CheckScriptFailure(lines, 'E129:')\n\n  lines =<< trim END\n      vim9script\n      def g: list<string>\n  END\n  CheckScriptFailure(lines, 'E129:')\n\n  lines =<< trim END\n      vim9script\n      def <SID>: list<string>\n  END\n  CheckScriptFailure(lines, 'E884:')\n\n  lines =<< trim END\n      vim9script\n      def F list<string>\n  END\n  CheckScriptFailure(lines, 'E488:')\nenddef\n\ndef Test_partial_call()\n  var lines =<< trim END\n      var Xsetlist: func\n      Xsetlist = function('setloclist', [0])\n      Xsetlist([], ' ', {title: 'test'})\n      getloclist(0, {title: 1})->assert_equal({title: 'test'})\n\n      Xsetlist = function('setloclist', [0, [], ' '])\n      Xsetlist({title: 'test'})\n      getloclist(0, {title: 1})->assert_equal({title: 'test'})\n\n      Xsetlist = function('setqflist')\n      Xsetlist([], ' ', {title: 'test'})\n      getqflist({title: 1})->assert_equal({title: 'test'})\n\n      Xsetlist = function('setqflist', [[], ' '])\n      Xsetlist({title: 'test'})\n      getqflist({title: 1})->assert_equal({title: 'test'})\n\n      var Len: func: number = function('len', ['word'])\n      assert_equal(4, Len())\n\n      var RepeatFunc = function('repeat', ['o'])\n      assert_equal('ooooo', RepeatFunc(5))\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Foo(Parser: any)\n      enddef\n      var Expr: func(dict<any>): dict<any>\n      const Call = Foo(Expr)\n  END\n  CheckScriptFailure(lines, 'E1235:')\nenddef\n\ndef Test_cmd_modifier()\n  tab echo '0'\n  CheckDefFailure(['5tab echo 3'], 'E16:')\nenddef\n\ndef Test_restore_modifiers()\n  # check that when compiling a :def function command modifiers are not messed\n  # up.\n  var lines =<< trim END\n      vim9script\n      set eventignore=\n      autocmd QuickFixCmdPost * copen\n      def AutocmdsDisabled()\n        eval 1 + 2\n      enddef\n      func Func()\n        noautocmd call s:AutocmdsDisabled()\n        let g:ei_after = &eventignore\n      endfunc\n      Func()\n  END\n  CheckScriptSuccess(lines)\n  g:ei_after->assert_equal('')\nenddef\n\ndef StackTop()\n  eval 1 + 2\n  eval 2 + 3\n  # call not on fourth line\n  StackBot()\nenddef\n\ndef StackBot()\n  # throw an error\n  eval [][0]\nenddef\n\ndef Test_callstack_def()\n  try\n    StackTop()\n  catch\n    v:throwpoint->assert_match('Test_callstack_def\\[2\\]..StackTop\\[4\\]..StackBot, line 2')\n  endtry\nenddef\n\n\" Re-using spot for variable used in block\ndef Test_block_scoped_var()\n  var lines =<< trim END\n      vim9script\n      def Func()\n        var x = ['a', 'b', 'c']\n        if 1\n          var y = 'x'\n          map(x, (_, _) => y)\n        endif\n        var z = x\n        assert_equal(['x', 'x', 'x'], z)\n      enddef\n      Func()\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_reset_did_emsg()\n  var lines =<< trim END\n      @s = 'blah'\n      au BufWinLeave * #\n      def Func()\n        var winid = popup_create('popup', {})\n        exe '*s'\n        popup_close(winid)\n      enddef\n      Func()\n  END\n  CheckScriptFailure(lines, 'E492:', 8)\n  delfunc! g:Func\nenddef\n\ndef Test_did_emsg_reset()\n  # executing an autocommand resets did_emsg, this should not result in a\n  # builtin function considered failing\n  var lines =<< trim END\n      vim9script\n      au BufWinLeave * #\n      def Func()\n          popup_menu('', {callback: (a, b) => popup_create('', {})->popup_close()})\n          eval [][0]\n      enddef\n      nno <F3> <cmd>call <sid>Func()<cr>\n      feedkeys(\"\\<F3>\\e\", 'xt')\n  END\n  writefile(lines, 'XemsgReset')\n  assert_fails('so XemsgReset', ['E684:', 'E684:'], lines, 2)\n  delete('XemsgReset')\n  nunmap <F3>\n  au! BufWinLeave\nenddef\n\ndef Test_abort_with_silent_call()\n  var lines =<< trim END\n      vim9script\n      g:result = 'none'\n      def Func()\n        g:result += 3\n        g:result = 'yes'\n      enddef\n      # error is silenced, but function aborts on error\n      silent! Func()\n      assert_equal('none', g:result)\n      unlet g:result\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_continues_with_silent_error()\n  var lines =<< trim END\n      vim9script\n      g:result = 'none'\n      def Func()\n        silent!  g:result += 3\n        g:result = 'yes'\n      enddef\n      # error is silenced, function does not abort\n      Func()\n      assert_equal('yes', g:result)\n      unlet g:result\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_abort_even_with_silent()\n  var lines =<< trim END\n      vim9script\n      g:result = 'none'\n      def Func()\n        eval {-> ''}() .. '' .. {}['X']\n        g:result = 'yes'\n      enddef\n      silent! Func()\n      assert_equal('none', g:result)\n      unlet g:result\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_cmdmod_silent_restored()\n  var lines =<< trim END\n      vim9script\n      def Func()\n        g:result = 'none'\n        silent! g:result += 3\n        g:result = 'none'\n        g:result += 3\n      enddef\n      Func()\n  END\n  # can't use CheckScriptFailure, it ignores the :silent!\n  var fname = 'Xdefsilent'\n  writefile(lines, fname)\n  var caught = 'no'\n  try\n    exe 'source ' .. fname\n  catch /E1030:/\n    caught = 'yes'\n    assert_match('Func, line 4', v:throwpoint)\n  endtry\n  assert_equal('yes', caught)\n  delete(fname)\nenddef\n\ndef Test_cmdmod_silent_nested()\n  var lines =<< trim END\n      vim9script\n      var result = ''\n\n      def Error()\n          result ..= 'Eb'\n          eval [][0]\n          result ..= 'Ea'\n      enddef\n\n      def Crash()\n          result ..= 'Cb'\n          sil! Error()\n          result ..= 'Ca'\n      enddef\n\n      Crash()\n      assert_equal('CbEbEaCa', result)\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_dict_member_with_silent()\n  var lines =<< trim END\n      vim9script\n      g:result = 'none'\n      var d: dict<any>\n      def Func()\n        try\n          g:result = map([], (_, v) => ({}[v]))->join() .. d['']\n        catch\n        endtry\n      enddef\n      silent! Func()\n      assert_equal('0', g:result)\n      unlet g:result\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_skip_cmds_with_silent()\n  var lines =<< trim END\n      vim9script\n\n      def Func(b: bool)\n        Crash()\n      enddef\n\n      def Crash()\n        sil! :/not found/d _\n        sil! :/not found/put _\n      enddef\n\n      Func(true)\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_opfunc()\n  nnoremap <F3> <cmd>set opfunc=Opfunc<cr>g@\n  def g:Opfunc(_: any): string\n    setline(1, 'ASDF')\n    return ''\n  enddef\n  new\n  setline(1, 'asdf')\n  feedkeys(\"\\<F3>$\", 'x')\n  assert_equal('ASDF', getline(1))\n\n  bwipe!\n  nunmap <F3>\nenddef\n\nfunc Test_opfunc_error()\n  CheckScreendump\n  call Run_Test_opfunc_error()\nendfunc\n\ndef Run_Test_opfunc_error()\n  # test that the error from Opfunc() is displayed right away\n  var lines =<< trim END\n      vim9script\n\n      def Opfunc(type: string)\n        try\n          eval [][0]\n        catch /nothing/  # error not caught\n        endtry\n      enddef\n      &operatorfunc = Opfunc\n      nnoremap <expr> l <SID>L()\n      def L(): string\n        return 'l'\n      enddef\n      'x'->repeat(10)->setline(1)\n      feedkeys('g@l', 'n')\n      feedkeys('llll')\n  END\n  call writefile(lines, 'XTest_opfunc_error')\n\n  var buf = RunVimInTerminal('-S XTest_opfunc_error', {rows: 6, wait_for_ruler: 0})\n  WaitForAssert(() => assert_match('Press ENTER', term_getline(buf, 6)))\n  WaitForAssert(() => assert_match('E684: list index out of range: 0', term_getline(buf, 5)))\n\n  # clean up\n  StopVimInTerminal(buf)\n  delete('XTest_opfunc_error')\nenddef\n\n\" this was crashing on exit\ndef Test_nested_lambda_in_closure()\n  var lines =<< trim END\n      vim9script\n      command WriteDone writefile(['Done'], 'XnestedDone')\n      def Outer()\n          def g:Inner()\n              echo map([1, 2, 3], {_, v -> v + 1})\n          enddef\n          g:Inner()\n      enddef\n      defcompile\n      # not reached\n  END\n  if !RunVim([], lines, '--clean -c WriteDone -c quit')\n    return\n  endif\n  assert_equal(['Done'], readfile('XnestedDone'))\n  delete('XnestedDone')\nenddef\n\ndef Test_check_func_arg_types()\n  var lines =<< trim END\n      vim9script\n      def F1(x: string): string\n        return x\n      enddef\n\n      def F2(x: number): number\n        return x + 1\n      enddef\n\n      def G(g: func): dict<func>\n        return {f: g}\n      enddef\n\n      def H(d: dict<func>): string\n        return d.f('a')\n      enddef\n  END\n\n  CheckScriptSuccess(lines + ['echo H(G(F1))'])\n  CheckScriptFailure(lines + ['echo H(G(F2))'], 'E1013:')\nenddef\n\ndef Test_list_any_type_checked()\n  var lines =<< trim END\n      vim9script\n      def Foo()\n        --decl--\n        Bar(l)\n      enddef\n      def Bar(ll: list<dict<any>>)\n      enddef\n      Foo()\n  END\n  lines[2] = 'var l: list<any>'\n  CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch, expected list<dict<any>> but got list<any>', 2)\n\n  lines[2] = 'var l: list<any> = []'\n  CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch, expected list<dict<any>> but got list<any>', 2)\n\n  lines[2] = 'var l: list<any> = [11]'\n  CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch, expected list<dict<any>> but got list<number>', 2)\nenddef\n\ndef Test_compile_error()\n  var lines =<< trim END\n    def g:Broken()\n      echo 'a' + {}\n    enddef\n    call g:Broken()\n  END\n  # First call: compilation error\n  CheckScriptFailure(lines, 'E1051: Wrong argument type for +')\n\n  # Second call won't try compiling again\n  assert_fails('call g:Broken()', 'E1091: Function is not compiled: Broken')\n  delfunc g:Broken\n\n  # No error when compiling with :silent!\n  lines =<< trim END\n    def g:Broken()\n      echo 'a' + []\n    enddef\n    silent! defcompile\n  END\n  CheckScriptSuccess(lines)\n\n  # Calling the function won't try compiling again\n  assert_fails('call g:Broken()', 'E1091: Function is not compiled: Broken')\n  delfunc g:Broken\nenddef\n\ndef Test_ignored_argument()\n  var lines =<< trim END\n      vim9script\n      def Ignore(_, _): string\n        return 'yes'\n      enddef\n      assert_equal('yes', Ignore(1, 2))\n\n      func Ok(_)\n        return a:_\n      endfunc\n      assert_equal('ok', Ok('ok'))\n\n      func Oktoo()\n        let _ = 'too'\n        return _\n      endfunc\n      assert_equal('too', Oktoo())\n\n      assert_equal([[1], [2], [3]], range(3)->mapnew((_, v) => [v]->map((_, w) => w + 1)))\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      def Ignore(_: string): string\n        return _\n      enddef\n      defcompile\n  END\n  CheckScriptFailure(lines, 'E1181:', 1)\n\n  lines =<< trim END\n      var _ = 1\n  END\n  CheckDefAndScriptFailure(lines, 'E1181:', 1)\n\n  lines =<< trim END\n      var x = _\n  END\n  CheckDefAndScriptFailure(lines, 'E1181:', 1)\nenddef\n\ndef Test_too_many_arguments()\n  var lines =<< trim END\n    echo [0, 1, 2]->map(() => 123)\n  END\n  CheckDefExecAndScriptFailure(lines, 'E1106: 2 arguments too many', 1)\n\n  lines =<< trim END\n    echo [0, 1, 2]->map((_) => 123)\n  END\n  CheckDefExecAndScriptFailure(lines, 'E1106: One argument too many', 1)\nenddef\n\ndef Test_closing_brace_at_start_of_line()\n  var lines =<< trim END\n      def Func()\n      enddef\n      Func(\n      )\n  END\n  call CheckDefAndScriptSuccess(lines)\nenddef\n\nfunc CreateMydict()\n  let g:mydict = {}\n  func g:mydict.afunc()\n    let g:result = self.key\n  endfunc\nendfunc\n\ndef Test_numbered_function_reference()\n  CreateMydict()\n  var output = execute('legacy func g:mydict.afunc')\n  var funcName = 'g:' .. substitute(output, '.*function \\(\\d\\+\\).*', '\\1', '')\n  execute 'function(' .. funcName .. ', [], {key: 42})()'\n  # check that the function still exists\n  assert_equal(output, execute('legacy func g:mydict.afunc'))\n  unlet g:mydict\nenddef\n\nif has('python3')\n  def Test_python3_heredoc()\n    py3 << trim EOF\n      import vim\n      vim.vars['didit'] = 'yes'\n    EOF\n    assert_equal('yes', g:didit)\n\n    python3 << trim EOF\n      import vim\n      vim.vars['didit'] = 'again'\n    EOF\n    assert_equal('again', g:didit)\n  enddef\nendif\n\n\" This messes up syntax highlight, keep near the end.\nif has('lua')\n  def Test_lua_heredoc()\n    g:d = {}\n    lua << trim EOF\n        x = vim.eval('g:d')\n        x['key'] = 'val'\n    EOF\n    assert_equal('val', g:d.key)\n  enddef\nendif\n\n\n\" vim: ts=8 sw=2 sts=2 expandtab tw=80 fdm=marker\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * userfunc.c: User defined function support\n */\n\n#include \"vim.h\"\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * All user-defined functions are found in this hashtable.\n */\nstatic hashtab_T\tfunc_hashtab;\n\n// Used by get_func_tv()\nstatic garray_T funcargs = GA_EMPTY;\n\n// pointer to funccal for currently active function\nstatic funccall_T *current_funccal = NULL;\n\n// Pointer to list of previously used funccal, still around because some\n// item in it is still being used.\nstatic funccall_T *previous_funccal = NULL;\n\nstatic char *e_funcexts = N_(\"E122: Function %s already exists, add ! to replace it\");\nstatic char *e_funcdict = N_(\"E717: Dictionary entry already exists\");\nstatic char *e_funcref = N_(\"E718: Funcref required\");\nstatic char *e_nofunc = N_(\"E130: Unknown function: %s\");\n\nstatic void funccal_unref(funccall_T *fc, ufunc_T *fp, int force);\nstatic void func_clear(ufunc_T *fp, int force);\nstatic int func_free(ufunc_T *fp, int force);\n\n    void\nfunc_init()\n{\n    hash_init(&func_hashtab);\n}\n\n/*\n * Return the function hash table\n */\n    hashtab_T *\nfunc_tbl_get(void)\n{\n    return &func_hashtab;\n}\n\n/*\n * Get one function argument.\n * If \"argtypes\" is not NULL also get the type: \"arg: type\" (:def function).\n * If \"types_optional\" is TRUE a missing type is OK, use \"any\".\n * If \"evalarg\" is not NULL use it to check for an already declared name.\n * Return a pointer to after the type.\n * When something is wrong return \"arg\".\n */\n    static char_u *\none_function_arg(\n\tchar_u\t    *arg,\n\tgarray_T    *newargs,\n\tgarray_T    *argtypes,\n\tint\t    types_optional,\n\tevalarg_T   *evalarg,\n\tint\t    is_vararg,\n\tint\t    skip)\n{\n    char_u\t*p = arg;\n    char_u\t*arg_copy = NULL;\n    int\t\tis_underscore = FALSE;\n\n    while (ASCII_ISALNUM(*p) || *p == '_')\n\t++p;\n    if (arg == p || isdigit(*arg)\n\t    || (argtypes == NULL\n\t\t&& ((p - arg == 9 && STRNCMP(arg, \"firstline\", 9) == 0)\n\t\t    || (p - arg == 8 && STRNCMP(arg, \"lastline\", 8) == 0))))\n    {\n\tif (!skip)\n\t    semsg(_(\"E125: Illegal argument: %s\"), arg);\n\treturn arg;\n    }\n\n    // Vim9 script: cannot use script var name for argument. In function: also\n    // check local vars and arguments.\n    if (!skip && argtypes != NULL && check_defined(arg, p - arg,\n\t\t    evalarg == NULL ? NULL : evalarg->eval_cctx, TRUE) == FAIL)\n\treturn arg;\n\n    if (newargs != NULL && ga_grow(newargs, 1) == FAIL)\n\treturn arg;\n    if (newargs != NULL)\n    {\n\tint\tc;\n\tint\ti;\n\n\tc = *p;\n\t*p = NUL;\n\targ_copy = vim_strsave(arg);\n\tif (arg_copy == NULL)\n\t{\n\t    *p = c;\n\t    return arg;\n\t}\n\tis_underscore = arg_copy[0] == '_' && arg_copy[1] == NUL;\n\tif (argtypes == NULL || !is_underscore)\n\t    // Check for duplicate argument name.\n\t    for (i = 0; i < newargs->ga_len; ++i)\n\t\tif (STRCMP(((char_u **)(newargs->ga_data))[i], arg_copy) == 0)\n\t\t{\n\t\t    semsg(_(\"E853: Duplicate argument name: %s\"), arg_copy);\n\t\t    vim_free(arg_copy);\n\t\t    return arg;\n\t\t}\n\t((char_u **)(newargs->ga_data))[newargs->ga_len] = arg_copy;\n\tnewargs->ga_len++;\n\n\t*p = c;\n    }\n\n    // get any type from \"arg: type\"\n    if (argtypes != NULL && (skip || ga_grow(argtypes, 1) == OK))\n    {\n\tchar_u *type = NULL;\n\n\tif (VIM_ISWHITE(*p) && *skipwhite(p) == ':')\n\t{\n\t    semsg(_(e_no_white_space_allowed_before_colon_str),\n\t\t\t\t\t    arg_copy == NULL ? arg : arg_copy);\n\t    p = skipwhite(p);\n\t}\n\tif (*p == ':')\n\t{\n\t    ++p;\n\t    if (!skip && !VIM_ISWHITE(*p))\n\t    {\n\t\tsemsg(_(e_white_space_required_after_str_str), \":\", p - 1);\n\t\treturn arg;\n\t    }\n\t    type = skipwhite(p);\n\t    p = skip_type(type, TRUE);\n\t    if (!skip)\n\t\ttype = vim_strnsave(type, p - type);\n\t}\n\telse if (*skipwhite(p) != '=' && !types_optional && !is_underscore)\n\t{\n\t    semsg(_(e_missing_argument_type_for_str),\n\t\t\t\t\t    arg_copy == NULL ? arg : arg_copy);\n\t    return arg;\n\t}\n\tif (!skip)\n\t{\n\t    if (type == NULL && types_optional)\n\t\t// lambda arguments default to \"any\" type\n\t\ttype = vim_strsave((char_u *)\n\t\t\t\t\t    (is_vararg ? \"list<any>\" : \"any\"));\n\t    ((char_u **)argtypes->ga_data)[argtypes->ga_len++] = type;\n\t}\n    }\n\n    return p;\n}\n\n/*\n * Get function arguments.\n * \"argp\" should point to just after the \"(\", possibly to white space.\n * \"argp\" is advanced just after \"endchar\".\n */\n    static int\nget_function_args(\n    char_u\t**argp,\n    char_u\tendchar,\n    garray_T\t*newargs,\n    garray_T\t*argtypes,\t// NULL unless using :def\n    int\t\ttypes_optional,\t// types optional if \"argtypes\" is not NULL\n    evalarg_T\t*evalarg,\t// context or NULL\n    int\t\t*varargs,\n    garray_T\t*default_args,\n    int\t\tskip,\n    exarg_T\t*eap,\n    char_u\t**line_to_free)\n{\n    int\t\tmustend = FALSE;\n    char_u\t*arg;\n    char_u\t*p;\n    int\t\tc;\n    int\t\tany_default = FALSE;\n    char_u\t*expr;\n    char_u\t*whitep = *argp;\n\n    if (newargs != NULL)\n\tga_init2(newargs, (int)sizeof(char_u *), 3);\n    if (argtypes != NULL)\n\tga_init2(argtypes, (int)sizeof(char_u *), 3);\n    if (!skip && default_args != NULL)\n\tga_init2(default_args, (int)sizeof(char_u *), 3);\n\n    if (varargs != NULL)\n\t*varargs = FALSE;\n\n    /*\n     * Isolate the arguments: \"arg1, arg2, ...)\"\n     */\n    arg = skipwhite(*argp);\n    p = arg;\n    while (*p != endchar)\n    {\n\twhile (eap != NULL && eap->getline != NULL\n\t\t\t && (*p == NUL || (VIM_ISWHITE(*whitep) && *p == '#')))\n\t{\n\t    char_u *theline;\n\n\t    // End of the line, get the next one.\n\t    theline = eap->getline(':', eap->cookie, 0, TRUE);\n\t    if (theline == NULL)\n\t\tbreak;\n\t    vim_free(*line_to_free);\n\t    *line_to_free = theline;\n\t    whitep = (char_u *)\" \";\n\t    p = skipwhite(theline);\n\t}\n\n\tif (mustend && *p != endchar)\n\t{\n\t    if (!skip)\n\t\tsemsg(_(e_invarg2), *argp);\n\t    goto err_ret;\n\t}\n\tif (*p == endchar)\n\t    break;\n\n\tif (p[0] == '.' && p[1] == '.' && p[2] == '.')\n\t{\n\t    if (varargs != NULL)\n\t\t*varargs = TRUE;\n\t    p += 3;\n\t    mustend = TRUE;\n\n\t    if (argtypes != NULL)\n\t    {\n\t\t// ...name: list<type>\n\t\tif (!eval_isnamec1(*p))\n\t\t{\n\t\t    if (!skip)\n\t\t\temsg(_(e_missing_name_after_dots));\n\t\t    goto err_ret;\n\t\t}\n\n\t\targ = p;\n\t\tp = one_function_arg(p, newargs, argtypes, types_optional,\n\t\t\t\t\t\t\t  evalarg, TRUE, skip);\n\t\tif (p == arg)\n\t\t    break;\n\t\tif (*skipwhite(p) == '=')\n\t\t{\n\t\t    emsg(_(e_cannot_use_default_for_variable_arguments));\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\telse\n\t{\n\t    char_u *np;\n\n\t    arg = p;\n\t    p = one_function_arg(p, newargs, argtypes, types_optional,\n\t\t\t\t\t\t\t evalarg, FALSE, skip);\n\t    if (p == arg)\n\t\tbreak;\n\n\t    // Recognize \" = expr\" but not \" == expr\".  A lambda can have\n\t    // \"(a = expr\" but \"(a == expr\" and \"(a =~ expr\" are not a lambda.\n\t    np = skipwhite(p);\n\t    if (*np == '=' && np[1] != '=' && np[1] != '~'\n\t\t\t\t\t\t       && default_args != NULL)\n\t    {\n\t\ttypval_T\trettv;\n\n\t\t// find the end of the expression (doesn't evaluate it)\n\t\tany_default = TRUE;\n\t\tp = skipwhite(p) + 1;\n\t\twhitep = p;\n\t\tp = skipwhite(p);\n\t\texpr = p;\n\t\tif (eval1(&p, &rettv, NULL) != FAIL)\n\t\t{\n\t\t    if (!skip)\n\t\t    {\n\t\t\tif (ga_grow(default_args, 1) == FAIL)\n\t\t\t    goto err_ret;\n\n\t\t\t// trim trailing whitespace\n\t\t\twhile (p > expr && VIM_ISWHITE(p[-1]))\n\t\t\t    p--;\n\t\t\tc = *p;\n\t\t\t*p = NUL;\n\t\t\texpr = vim_strsave(expr);\n\t\t\tif (expr == NULL)\n\t\t\t{\n\t\t\t    *p = c;\n\t\t\t    goto err_ret;\n\t\t\t}\n\t\t\t((char_u **)(default_args->ga_data))\n\t\t\t\t\t\t [default_args->ga_len] = expr;\n\t\t\tdefault_args->ga_len++;\n\t\t\t*p = c;\n\t\t    }\n\t\t}\n\t\telse\n\t\t    mustend = TRUE;\n\t    }\n\t    else if (any_default)\n\t    {\n\t\temsg(_(\"E989: Non-default argument follows default argument\"));\n\t\tgoto err_ret;\n\t    }\n\n\t    if (VIM_ISWHITE(*p) && *skipwhite(p) == ',')\n\t    {\n\t\t// Be tolerant when skipping\n\t\tif (!skip)\n\t\t{\n\t\t    semsg(_(e_no_white_space_allowed_before_str_str), \",\", p);\n\t\t    goto err_ret;\n\t\t}\n\t\tp = skipwhite(p);\n\t    }\n\t    if (*p == ',')\n\t    {\n\t\t++p;\n\t\t// Don't give this error when skipping, it makes the \"->\" not\n\t\t// found in \"{k,v -> x}\" and give a confusing error.\n\t\t// Allow missing space after comma in legacy functions.\n\t\tif (!skip && argtypes != NULL\n\t\t\t\t      && !IS_WHITE_OR_NUL(*p) && *p != endchar)\n\t\t{\n\t\t    semsg(_(e_white_space_required_after_str_str), \",\", p - 1);\n\t\t    goto err_ret;\n\t\t}\n\t    }\n\t    else\n\t\tmustend = TRUE;\n\t}\n\twhitep = p;\n\tp = skipwhite(p);\n    }\n\n    if (*p != endchar)\n\tgoto err_ret;\n    ++p;\t// skip \"endchar\"\n\n    *argp = p;\n    return OK;\n\nerr_ret:\n    if (newargs != NULL)\n\tga_clear_strings(newargs);\n    if (!skip && default_args != NULL)\n\tga_clear_strings(default_args);\n    return FAIL;\n}\n\n/*\n * Parse the argument types, filling \"fp->uf_arg_types\".\n * Return OK or FAIL.\n */\n    static int\nparse_argument_types(ufunc_T *fp, garray_T *argtypes, int varargs)\n{\n    int len = 0;\n\n    ga_init2(&fp->uf_type_list, sizeof(type_T *), 10);\n    if (argtypes->ga_len > 0)\n    {\n\t// When \"varargs\" is set the last name/type goes into uf_va_name\n\t// and uf_va_type.\n\tlen = argtypes->ga_len - (varargs ? 1 : 0);\n\n\tif (len > 0)\n\t    fp->uf_arg_types = ALLOC_CLEAR_MULT(type_T *, len);\n\tif (fp->uf_arg_types != NULL)\n\t{\n\t    int\ti;\n\t    type_T\t*type;\n\n\t    for (i = 0; i < len; ++ i)\n\t    {\n\t\tchar_u *p = ((char_u **)argtypes->ga_data)[i];\n\n\t\tif (p == NULL)\n\t\t    // will get the type from the default value\n\t\t    type = &t_unknown;\n\t\telse\n\t\t    type = parse_type(&p, &fp->uf_type_list, TRUE);\n\t\tif (type == NULL)\n\t\t    return FAIL;\n\t\tfp->uf_arg_types[i] = type;\n\t    }\n\t}\n    }\n\n    if (varargs)\n    {\n\tchar_u *p;\n\n\t// Move the last argument \"...name: type\" to uf_va_name and\n\t// uf_va_type.\n\tfp->uf_va_name = ((char_u **)fp->uf_args.ga_data)\n\t\t\t\t\t      [fp->uf_args.ga_len - 1];\n\t--fp->uf_args.ga_len;\n\tp = ((char_u **)argtypes->ga_data)[len];\n\tif (p == NULL)\n\t    // TODO: get type from default value\n\t    fp->uf_va_type = &t_list_any;\n\telse\n\t{\n\t    fp->uf_va_type = parse_type(&p, &fp->uf_type_list, TRUE);\n\t    if (fp->uf_va_type != NULL && fp->uf_va_type->tt_type != VAR_LIST)\n\t    {\n\t\tsemsg(_(e_variable_arguments_type_must_be_list_str),\n\t\t\t\t\t  ((char_u **)argtypes->ga_data)[len]);\n\t\treturn FAIL;\n\t    }\n\t}\n\tif (fp->uf_va_type == NULL)\n\t    return FAIL;\n    }\n\n    return OK;\n}\n\n    static int\nparse_return_type(ufunc_T *fp, char_u *ret_type)\n{\n    if (ret_type == NULL)\n\tfp->uf_ret_type = &t_void;\n    else\n    {\n\tchar_u *p = ret_type;\n\n\tfp->uf_ret_type = parse_type(&p, &fp->uf_type_list, TRUE);\n\tif (fp->uf_ret_type == NULL)\n\t{\n\t    fp->uf_ret_type = &t_void;\n\t    return FAIL;\n\t}\n    }\n    return OK;\n}\n\n/*\n * Register function \"fp\" as using \"current_funccal\" as its scope.\n */\n    static int\nregister_closure(ufunc_T *fp)\n{\n    if (fp->uf_scoped == current_funccal)\n\t// no change\n\treturn OK;\n    funccal_unref(fp->uf_scoped, fp, FALSE);\n    fp->uf_scoped = current_funccal;\n    current_funccal->fc_refcount++;\n\n    if (ga_grow(&current_funccal->fc_funcs, 1) == FAIL)\n\treturn FAIL;\n    ((ufunc_T **)current_funccal->fc_funcs.ga_data)\n\t[current_funccal->fc_funcs.ga_len++] = fp;\n    return OK;\n}\n\n    static void\nset_ufunc_name(ufunc_T *fp, char_u *name)\n{\n    // Add a type cast to avoid a warning for an overflow, the uf_name[] array\n    // actually extends beyond the struct.\n    STRCPY((void *)fp->uf_name, name);\n\n    if (name[0] == K_SPECIAL)\n    {\n\tfp->uf_name_exp = alloc(STRLEN(name) + 3);\n\tif (fp->uf_name_exp != NULL)\n\t{\n\t    STRCPY(fp->uf_name_exp, \"<SNR>\");\n\t    STRCAT(fp->uf_name_exp, fp->uf_name + 3);\n\t}\n    }\n}\n\n/*\n * Get a name for a lambda.  Returned in static memory.\n */\n    char_u *\nget_lambda_name(void)\n{\n    static char_u   name[30];\n    static int\t    lambda_no = 0;\n\n    sprintf((char*)name, \"<lambda>%d\", ++lambda_no);\n    return name;\n}\n\n#if defined(FEAT_LUA) || defined(PROTO)\n/*\n * Registers a native C callback which can be called from Vim script.\n * Returns the name of the Vim script function.\n */\n    char_u *\nregister_cfunc(cfunc_T cb, cfunc_free_T cb_free, void *state)\n{\n    char_u\t*name = get_lambda_name();\n    ufunc_T\t*fp;\n\n    fp = alloc_clear(offsetof(ufunc_T, uf_name) + STRLEN(name) + 1);\n    if (fp == NULL)\n\treturn NULL;\n\n    fp->uf_def_status = UF_NOT_COMPILED;\n    fp->uf_refcount = 1;\n    fp->uf_varargs = TRUE;\n    fp->uf_flags = FC_CFUNC | FC_LAMBDA;\n    fp->uf_calls = 0;\n    fp->uf_script_ctx = current_sctx;\n    fp->uf_cb = cb;\n    fp->uf_cb_free = cb_free;\n    fp->uf_cb_state = state;\n\n    set_ufunc_name(fp, name);\n    hash_add(&func_hashtab, UF2HIKEY(fp));\n\n    return name;\n}\n#endif\n\n/*\n * Skip over \"->\" or \"=>\" after the arguments of a lambda.\n * If \": type\" is found make \"ret_type\" point to \"type\".\n * If \"white_error\" is not NULL check for correct use of white space and set\n * \"white_error\" to TRUE if there is an error.\n * Return NULL if no valid arrow found.\n */\n    static char_u *\nskip_arrow(\n\tchar_u\t*start,\n\tint\tequal_arrow,\n\tchar_u\t**ret_type,\n\tint\t*white_error)\n{\n    char_u  *s = start;\n    char_u  *bef = start - 2; // \"start\" points to > of ->\n\n    if (equal_arrow)\n    {\n\tif (*s == ':')\n\t{\n\t    if (white_error != NULL && !VIM_ISWHITE(s[1]))\n\t    {\n\t\t*white_error = TRUE;\n\t\tsemsg(_(e_white_space_required_after_str_str), \":\", s);\n\t\treturn NULL;\n\t    }\n\t    s = skipwhite(s + 1);\n\t    *ret_type = s;\n\t    s = skip_type(s, TRUE);\n\t    if (s == *ret_type)\n\t    {\n\t\temsg(_(e_missing_return_type));\n\t\treturn NULL;\n\t    }\n\t}\n\tbef = s;\n\ts = skipwhite(s);\n\tif (*s != '=')\n\t    return NULL;\n\t++s;\n    }\n    if (*s != '>')\n\treturn NULL;\n    if (white_error != NULL && ((!VIM_ISWHITE(*bef) && *bef != '{')\n\t\t|| !IS_WHITE_OR_NUL(s[1])))\n    {\n\t*white_error = TRUE;\n\tsemsg(_(e_white_space_required_before_and_after_str_at_str),\n\t\t\t\t\t       equal_arrow ? \"=>\" : \"->\", bef);\n\treturn NULL;\n    }\n    return skipwhite(s + 1);\n}\n\n/*\n * Check if \"*cmd\" points to a function command and if so advance \"*cmd\" and\n * return TRUE.\n * Otherwise return FALSE;\n * Do not consider \"function(\" to be a command.\n */\n    static int\nis_function_cmd(char_u **cmd)\n{\n    char_u *p = *cmd;\n\n    if (checkforcmd(&p, \"function\", 2))\n    {\n\tif (*p == '(')\n\t    return FALSE;\n\t*cmd = p;\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Called when defining a function: The context may be needed for script\n * variables declared in a block that is visible now but not when the function\n * is compiled or called later.\n */\n    static void\nfunction_using_block_scopes(ufunc_T *fp, cstack_T *cstack)\n{\n    if (cstack != NULL && cstack->cs_idx >= 0)\n    {\n\tint\t    count = cstack->cs_idx + 1;\n\tint\t    i;\n\n\tfp->uf_block_ids = ALLOC_MULT(int, count);\n\tif (fp->uf_block_ids != NULL)\n\t{\n\t    mch_memmove(fp->uf_block_ids, cstack->cs_block_id,\n\t\t\t\t\t\t\t  sizeof(int) * count);\n\t    fp->uf_block_depth = count;\n\t}\n\n\t// Set flag in each block to indicate a function was defined.  This\n\t// is used to keep the variable when leaving the block, see\n\t// hide_script_var().\n\tfor (i = 0; i <= cstack->cs_idx; ++i)\n\t    cstack->cs_flags[i] |= CSF_FUNC_DEF;\n    }\n}\n\n/*\n * Read the body of a function, put every line in \"newlines\".\n * This stops at \"}\", \"endfunction\" or \"enddef\".\n * \"newlines\" must already have been initialized.\n * \"eap->cmdidx\" is CMD_function, CMD_def or CMD_block;\n */\n    static int\nget_function_body(\n\texarg_T\t    *eap,\n\tgarray_T    *newlines,\n\tchar_u\t    *line_arg_in,\n\tchar_u\t    **line_to_free)\n{\n    linenr_T\tsourcing_lnum_top = SOURCING_LNUM;\n    linenr_T\tsourcing_lnum_off;\n    int\t\tsaved_wait_return = need_wait_return;\n    char_u\t*line_arg = line_arg_in;\n    int\t\tvim9_function = eap->cmdidx == CMD_def\n\t\t\t\t\t\t   || eap->cmdidx == CMD_block;\n#define MAX_FUNC_NESTING 50\n    char\tnesting_def[MAX_FUNC_NESTING];\n    char\tnesting_inline[MAX_FUNC_NESTING];\n    int\t\tnesting = 0;\n    getline_opt_T getline_options;\n    int\t\tindent = 2;\n    char_u\t*skip_until = NULL;\n    int\t\tret = FAIL;\n    int\t\tis_heredoc = FALSE;\n    int\t\theredoc_concat_len = 0;\n    garray_T\theredoc_ga;\n    char_u\t*heredoc_trimmed = NULL;\n\n    ga_init2(&heredoc_ga, 1, 500);\n\n    // Detect having skipped over comment lines to find the return\n    // type.  Add NULL lines to keep the line count correct.\n    sourcing_lnum_off = get_sourced_lnum(eap->getline, eap->cookie);\n    if (SOURCING_LNUM < sourcing_lnum_off)\n    {\n\tsourcing_lnum_off -= SOURCING_LNUM;\n\tif (ga_grow(newlines, sourcing_lnum_off) == FAIL)\n\t    goto theend;\n\twhile (sourcing_lnum_off-- > 0)\n\t    ((char_u **)(newlines->ga_data))[newlines->ga_len++] = NULL;\n    }\n\n    nesting_def[0] = vim9_function;\n    nesting_inline[0] = eap->cmdidx == CMD_block;\n    getline_options = vim9_function\n\t\t\t\t? GETLINE_CONCAT_CONTBAR : GETLINE_CONCAT_CONT;\n    for (;;)\n    {\n\tchar_u\t*theline;\n\tchar_u\t*p;\n\tchar_u\t*arg;\n\n\tif (KeyTyped)\n\t{\n\t    msg_scroll = TRUE;\n\t    saved_wait_return = FALSE;\n\t}\n\tneed_wait_return = FALSE;\n\n\tif (line_arg != NULL)\n\t{\n\t    // Use eap->arg, split up in parts by line breaks.\n\t    theline = line_arg;\n\t    p = vim_strchr(theline, '\\n');\n\t    if (p == NULL)\n\t\tline_arg += STRLEN(line_arg);\n\t    else\n\t    {\n\t\t*p = NUL;\n\t\tline_arg = p + 1;\n\t    }\n\t}\n\telse\n\t{\n\t    vim_free(*line_to_free);\n\t    if (eap->getline == NULL)\n\t\ttheline = getcmdline(':', 0L, indent, getline_options);\n\t    else\n\t\ttheline = eap->getline(':', eap->cookie, indent,\n\t\t\t\t\t\t\t      getline_options);\n\t    *line_to_free = theline;\n\t}\n\tif (KeyTyped)\n\t    lines_left = Rows - 1;\n\tif (theline == NULL)\n\t{\n\t    // Use the start of the function for the line number.\n\t    SOURCING_LNUM = sourcing_lnum_top;\n\t    if (skip_until != NULL)\n\t\tsemsg(_(e_missing_heredoc_end_marker_str), skip_until);\n\t    else if (nesting_inline[nesting])\n\t\temsg(_(e_missing_end_block));\n\t    else if (eap->cmdidx == CMD_def)\n\t\temsg(_(e_missing_enddef));\n\t    else\n\t\temsg(_(\"E126: Missing :endfunction\"));\n\t    goto theend;\n\t}\n\n\t// Detect line continuation: SOURCING_LNUM increased more than one.\n\tsourcing_lnum_off = get_sourced_lnum(eap->getline, eap->cookie);\n\tif (SOURCING_LNUM < sourcing_lnum_off)\n\t    sourcing_lnum_off -= SOURCING_LNUM;\n\telse\n\t    sourcing_lnum_off = 0;\n\n\tif (skip_until != NULL)\n\t{\n\t    // Don't check for \":endfunc\"/\":enddef\" between\n\t    // * \":append\" and \".\"\n\t    // * \":python <<EOF\" and \"EOF\"\n\t    // * \":let {var-name} =<< [trim] {marker}\" and \"{marker}\"\n\t    if (heredoc_trimmed == NULL\n\t\t    || (is_heredoc && skipwhite(theline) == theline)\n\t\t    || STRNCMP(theline, heredoc_trimmed,\n\t\t\t\t\t\t STRLEN(heredoc_trimmed)) == 0)\n\t    {\n\t\tif (heredoc_trimmed == NULL)\n\t\t    p = theline;\n\t\telse if (is_heredoc)\n\t\t    p = skipwhite(theline) == theline\n\t\t\t\t ? theline : theline + STRLEN(heredoc_trimmed);\n\t\telse\n\t\t    p = theline + STRLEN(heredoc_trimmed);\n\t\tif (STRCMP(p, skip_until) == 0)\n\t\t{\n\t\t    VIM_CLEAR(skip_until);\n\t\t    VIM_CLEAR(heredoc_trimmed);\n\t\t    getline_options = vim9_function\n\t\t\t\t? GETLINE_CONCAT_CONTBAR : GETLINE_CONCAT_CONT;\n\t\t    is_heredoc = FALSE;\n\n\t\t    if (heredoc_concat_len > 0)\n\t\t    {\n\t\t\t// Replace the starting line with all the concatenated\n\t\t\t// lines.\n\t\t\tga_concat(&heredoc_ga, theline);\n\t\t\tvim_free(((char_u **)(newlines->ga_data))[\n\t\t\t\t\t\t      heredoc_concat_len - 1]);\n\t\t\t((char_u **)(newlines->ga_data))[\n\t\t\t\t  heredoc_concat_len - 1] = heredoc_ga.ga_data;\n\t\t\tga_init(&heredoc_ga);\n\t\t\theredoc_concat_len = 0;\n\t\t\ttheline += STRLEN(theline);  // skip the \"EOF\"\n\t\t    }\n\t\t}\n\t    }\n\t}\n\telse\n\t{\n\t    int\t    c;\n\t    char_u  *end;\n\n\t    // skip ':' and blanks\n\t    for (p = theline; VIM_ISWHITE(*p) || *p == ':'; ++p)\n\t\t;\n\n\t    // Check for \"endfunction\", \"enddef\" or \"}\".\n\t    // When a \":\" follows it must be a dict key; \"enddef: value,\"\n\t    if (nesting_inline[nesting]\n\t\t    ? *p == '}'\n\t\t    : (checkforcmd(&p, nesting_def[nesting]\n\t\t\t\t\t\t? \"enddef\" : \"endfunction\", 4)\n\t\t\t&& *p != ':'))\n\t    {\n\t\tif (nesting-- == 0)\n\t\t{\n\t\t    char_u *nextcmd = NULL;\n\n\t\t    if (*p == '|' || *p == '}')\n\t\t\tnextcmd = p + 1;\n\t\t    else if (line_arg != NULL && *skipwhite(line_arg) != NUL)\n\t\t\tnextcmd = line_arg;\n\t\t    else if (*p != NUL && *p != (vim9_function ? '#' : '\"')\n\t\t\t\t\t   && (vim9_function || p_verbose > 0))\n\t\t    {\n\t\t\tSOURCING_LNUM = sourcing_lnum_top\n\t\t\t\t\t\t\t+ newlines->ga_len + 1;\n\t\t\tif (eap->cmdidx == CMD_def)\n\t\t\t    semsg(_(e_text_found_after_enddef_str), p);\n\t\t\telse\n\t\t\t    give_warning2((char_u *)\n\t\t\t\t   _(\"W22: Text found after :endfunction: %s\"),\n\t\t\t\t   p, TRUE);\n\t\t    }\n\t\t    if (nextcmd != NULL && *skipwhite(nextcmd) != NUL)\n\t\t    {\n\t\t\t// Another command follows. If the line came from \"eap\"\n\t\t\t// we can simply point into it, otherwise we need to\n\t\t\t// change \"eap->cmdlinep\".\n\t\t\teap->nextcmd = nextcmd;\n\t\t\tif (*line_to_free != NULL)\n\t\t\t{\n\t\t\t    vim_free(*eap->cmdlinep);\n\t\t\t    *eap->cmdlinep = *line_to_free;\n\t\t\t    *line_to_free = NULL;\n\t\t\t}\n\t\t    }\n\t\t    break;\n\t\t}\n\t    }\n\n\t    // Check for mismatched \"endfunc\" or \"enddef\".\n\t    // We don't check for \"def\" inside \"func\" thus we also can't check\n\t    // for \"enddef\".\n\t    // We continue to find the end of the function, although we might\n\t    // not find it.\n\t    else if (nesting_def[nesting])\n\t    {\n\t\tif (checkforcmd(&p, \"endfunction\", 4) && *p != ':')\n\t\t    emsg(_(e_mismatched_endfunction));\n\t    }\n\t    else if (eap->cmdidx == CMD_def && checkforcmd(&p, \"enddef\", 4))\n\t\temsg(_(e_mismatched_enddef));\n\n\t    // Increase indent inside \"if\", \"while\", \"for\" and \"try\", decrease\n\t    // at \"end\".\n\t    if (indent > 2 && (*p == '}' || STRNCMP(p, \"end\", 3) == 0))\n\t\tindent -= 2;\n\t    else if (STRNCMP(p, \"if\", 2) == 0\n\t\t    || STRNCMP(p, \"wh\", 2) == 0\n\t\t    || STRNCMP(p, \"for\", 3) == 0\n\t\t    || STRNCMP(p, \"try\", 3) == 0)\n\t\tindent += 2;\n\n\t    // Check for defining a function inside this function.\n\t    // Only recognize \"def\" inside \"def\", not inside \"function\",\n\t    // For backwards compatibility, see Test_function_python().\n\t    c = *p;\n\t    if (is_function_cmd(&p)\n\t\t    || (eap->cmdidx == CMD_def && checkforcmd(&p, \"def\", 3)))\n\t    {\n\t\tif (*p == '!')\n\t\t    p = skipwhite(p + 1);\n\t\tp += eval_fname_script(p);\n\t\tvim_free(trans_function_name(&p, NULL, TRUE, 0, NULL,\n\t\t\t\t\t\t\t\t  NULL, NULL));\n\t\tif (*skipwhite(p) == '(')\n\t\t{\n\t\t    if (nesting == MAX_FUNC_NESTING - 1)\n\t\t\temsg(_(e_function_nesting_too_deep));\n\t\t    else\n\t\t    {\n\t\t\t++nesting;\n\t\t\tnesting_def[nesting] = (c == 'd');\n\t\t\tnesting_inline[nesting] = FALSE;\n\t\t\tindent += 2;\n\t\t    }\n\t\t}\n\t    }\n\n\t    if (nesting_def[nesting] ? *p != '#' : *p != '\"')\n\t    {\n\t\t// Not a comment line: check for nested inline function.\n\t\tend = p + STRLEN(p) - 1;\n\t\twhile (end > p && VIM_ISWHITE(*end))\n\t\t    --end;\n\t\tif (end > p + 1 && *end == '{' && VIM_ISWHITE(end[-1]))\n\t\t{\n\t\t    int\t    is_block;\n\n\t\t    // check for trailing \"=> {\": start of an inline function\n\t\t    --end;\n\t\t    while (end > p && VIM_ISWHITE(*end))\n\t\t\t--end;\n\t\t    is_block = end > p + 2 && end[-1] == '=' && end[0] == '>';\n\t\t    if (!is_block)\n\t\t    {\n\t\t\tchar_u *s = p;\n\n\t\t\t// check for line starting with \"au\" for :autocmd or\n\t\t\t// \"com\" for :command, these can use a {} block\n\t\t\tis_block = checkforcmd_noparen(&s, \"autocmd\", 2)\n\t\t\t\t      || checkforcmd_noparen(&s, \"command\", 3);\n\t\t    }\n\n\t\t    if (is_block)\n\t\t    {\n\t\t\tif (nesting == MAX_FUNC_NESTING - 1)\n\t\t\t    emsg(_(e_function_nesting_too_deep));\n\t\t\telse\n\t\t\t{\n\t\t\t    ++nesting;\n\t\t\t    nesting_def[nesting] = TRUE;\n\t\t\t    nesting_inline[nesting] = TRUE;\n\t\t\t    indent += 2;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\n\t    // Check for \":append\", \":change\", \":insert\".  Not for :def.\n\t    p = skip_range(p, FALSE, NULL);\n\t    if (!vim9_function\n\t\t&& ((p[0] == 'a' && (!ASCII_ISALPHA(p[1]) || p[1] == 'p'))\n\t\t    || (p[0] == 'c'\n\t\t\t&& (!ASCII_ISALPHA(p[1]) || (p[1] == 'h'\n\t\t\t\t&& (!ASCII_ISALPHA(p[2]) || (p[2] == 'a'\n\t\t\t\t\t&& (STRNCMP(&p[3], \"nge\", 3) != 0\n\t\t\t\t\t    || !ASCII_ISALPHA(p[6])))))))\n\t\t    || (p[0] == 'i'\n\t\t\t&& (!ASCII_ISALPHA(p[1]) || (p[1] == 'n'\n\t\t\t\t&& (!ASCII_ISALPHA(p[2])\n\t\t\t\t    || (p[2] == 's'\n\t\t\t\t\t&& (!ASCII_ISALPHA(p[3])\n\t\t\t\t\t\t|| p[3] == 'e'))))))))\n\t\tskip_until = vim_strsave((char_u *)\".\");\n\n\t    // Check for \":python <<EOF\", \":tcl <<EOF\", etc.\n\t    arg = skipwhite(skiptowhite(p));\n\t    if (arg[0] == '<' && arg[1] =='<'\n\t\t    && ((p[0] == 'p' && p[1] == 'y'\n\t\t\t\t    && (!ASCII_ISALNUM(p[2]) || p[2] == 't'\n\t\t\t\t\t|| ((p[2] == '3' || p[2] == 'x')\n\t\t\t\t\t\t   && !ASCII_ISALPHA(p[3]))))\n\t\t\t|| (p[0] == 'p' && p[1] == 'e'\n\t\t\t\t    && (!ASCII_ISALPHA(p[2]) || p[2] == 'r'))\n\t\t\t|| (p[0] == 't' && p[1] == 'c'\n\t\t\t\t    && (!ASCII_ISALPHA(p[2]) || p[2] == 'l'))\n\t\t\t|| (p[0] == 'l' && p[1] == 'u' && p[2] == 'a'\n\t\t\t\t    && !ASCII_ISALPHA(p[3]))\n\t\t\t|| (p[0] == 'r' && p[1] == 'u' && p[2] == 'b'\n\t\t\t\t    && (!ASCII_ISALPHA(p[3]) || p[3] == 'y'))\n\t\t\t|| (p[0] == 'm' && p[1] == 'z'\n\t\t\t\t    && (!ASCII_ISALPHA(p[2]) || p[2] == 's'))\n\t\t\t))\n\t    {\n\t\t// \":python <<\" continues until a dot, like \":append\"\n\t\tp = skipwhite(arg + 2);\n\t\tif (STRNCMP(p, \"trim\", 4) == 0)\n\t\t{\n\t\t    // Ignore leading white space.\n\t\t    p = skipwhite(p + 4);\n\t\t    heredoc_trimmed = vim_strnsave(theline,\n\t\t\t\t\t\t skipwhite(theline) - theline);\n\t\t}\n\t\tif (*p == NUL)\n\t\t    skip_until = vim_strsave((char_u *)\".\");\n\t\telse\n\t\t    skip_until = vim_strnsave(p, skiptowhite(p) - p);\n\t\tgetline_options = GETLINE_NONE;\n\t\tis_heredoc = TRUE;\n\t\tif (eap->cmdidx == CMD_def)\n\t\t    heredoc_concat_len = newlines->ga_len + 1;\n\t    }\n\n\t    // Check for \":cmd v =<< [trim] EOF\"\n\t    //       and \":cmd [a, b] =<< [trim] EOF\"\n\t    //       and \"lines =<< [trim] EOF\" for Vim9\n\t    // Where \"cmd\" can be \"let\", \"var\", \"final\" or \"const\".\n\t    arg = skipwhite(skiptowhite(p));\n\t    if (*arg == '[')\n\t\targ = vim_strchr(arg, ']');\n\t    if (arg != NULL)\n\t    {\n\t\tint found = (eap->cmdidx == CMD_def && arg[0] == '='\n\t\t\t\t\t     && arg[1] == '<' && arg[2] =='<');\n\n\t\tif (!found)\n\t\t    // skip over the argument after \"cmd\"\n\t\t    arg = skipwhite(skiptowhite(arg));\n\t\tif (found || (arg[0] == '=' && arg[1] == '<' && arg[2] =='<'\n\t\t\t&& (checkforcmd(&p, \"let\", 2)\n\t\t\t    || checkforcmd(&p, \"var\", 3)\n\t\t\t    || checkforcmd(&p, \"final\", 5)\n\t\t\t    || checkforcmd(&p, \"const\", 5))))\n\t\t{\n\t\t    p = skipwhite(arg + 3);\n\t\t    if (STRNCMP(p, \"trim\", 4) == 0)\n\t\t    {\n\t\t\t// Ignore leading white space.\n\t\t\tp = skipwhite(p + 4);\n\t\t\theredoc_trimmed = vim_strnsave(theline,\n\t\t\t\t\t\t skipwhite(theline) - theline);\n\t\t    }\n\t\t    skip_until = vim_strnsave(p, skiptowhite(p) - p);\n\t\t    getline_options = GETLINE_NONE;\n\t\t    is_heredoc = TRUE;\n\t\t}\n\t    }\n\t}\n\n\t// Add the line to the function.\n\tif (ga_grow(newlines, 1 + sourcing_lnum_off) == FAIL)\n\t    goto theend;\n\n\tif (heredoc_concat_len > 0)\n\t{\n\t    // For a :def function \"python << EOF\" concatenats all the lines,\n\t    // to be used for the instruction later.\n\t    ga_concat(&heredoc_ga, theline);\n\t    ga_concat(&heredoc_ga, (char_u *)\"\\n\");\n\t    p = vim_strsave((char_u *)\"\");\n\t}\n\telse\n\t{\n\t    // Copy the line to newly allocated memory.  get_one_sourceline()\n\t    // allocates 250 bytes per line, this saves 80% on average.  The\n\t    // cost is an extra alloc/free.\n\t    p = vim_strsave(theline);\n\t}\n\tif (p == NULL)\n\t    goto theend;\n\t((char_u **)(newlines->ga_data))[newlines->ga_len++] = p;\n\n\t// Add NULL lines for continuation lines, so that the line count is\n\t// equal to the index in the growarray.\n\twhile (sourcing_lnum_off-- > 0)\n\t    ((char_u **)(newlines->ga_data))[newlines->ga_len++] = NULL;\n\n\t// Check for end of eap->arg.\n\tif (line_arg != NULL && *line_arg == NUL)\n\t    line_arg = NULL;\n    }\n\n    // Return OK when no error was detected.\n    if (!did_emsg)\n\tret = OK;\n\ntheend:\n    vim_free(skip_until);\n    vim_free(heredoc_trimmed);\n    vim_free(heredoc_ga.ga_data);\n    need_wait_return |= saved_wait_return;\n    return ret;\n}\n\n/*\n * Handle the body of a lambda.  *arg points to the \"{\", process statements\n * until the matching \"}\".\n * When not evaluating \"newargs\" is NULL.\n * When successful \"rettv\" is set to a funcref.\n */\n    static int\nlambda_function_body(\n\tchar_u\t    **arg,\n\ttypval_T    *rettv,\n\tevalarg_T   *evalarg,\n\tgarray_T    *newargs,\n\tgarray_T    *argtypes,\n\tint\t    varargs,\n\tgarray_T    *default_args,\n\tchar_u\t    *ret_type)\n{\n    int\t\tevaluate = (evalarg->eval_flags & EVAL_EVALUATE);\n    garray_T\t*gap = &evalarg->eval_ga;\n    garray_T\t*freegap = &evalarg->eval_freega;\n    ufunc_T\t*ufunc = NULL;\n    exarg_T\teap;\n    garray_T\tnewlines;\n    char_u\t*cmdline = NULL;\n    int\t\tret = FAIL;\n    char_u\t*line_to_free = NULL;\n    partial_T\t*pt;\n    char_u\t*name;\n    int\t\tlnum_save = -1;\n    linenr_T\tsourcing_lnum_top = SOURCING_LNUM;\n\n    if (!ends_excmd2(*arg, skipwhite(*arg + 1)))\n    {\n\tsemsg(_(e_trailing_arg), *arg + 1);\n\treturn FAIL;\n    }\n\n    CLEAR_FIELD(eap);\n    eap.cmdidx = CMD_block;\n    eap.forceit = FALSE;\n    eap.cmdlinep = &cmdline;\n    eap.skip = !evaluate;\n    if (evalarg->eval_cctx != NULL)\n\tfill_exarg_from_cctx(&eap, evalarg->eval_cctx);\n    else\n    {\n\teap.getline = evalarg->eval_getline;\n\teap.cookie = evalarg->eval_cookie;\n    }\n\n    ga_init2(&newlines, (int)sizeof(char_u *), 10);\n    if (get_function_body(&eap, &newlines, NULL, &line_to_free) == FAIL)\n    {\n\tvim_free(cmdline);\n\tgoto erret;\n    }\n\n    // When inside a lambda must add the function lines to evalarg.eval_ga.\n    evalarg->eval_break_count += newlines.ga_len;\n    if (gap->ga_itemsize > 0)\n    {\n\tint\tidx;\n\tchar_u\t*last;\n\tsize_t  plen;\n\tchar_u  *pnl;\n\n\tfor (idx = 0; idx < newlines.ga_len; ++idx)\n\t{\n\t    char_u  *p = skipwhite(((char_u **)newlines.ga_data)[idx]);\n\n\t    if (ga_grow(gap, 1) == FAIL || ga_grow(freegap, 1) == FAIL)\n\t\tgoto erret;\n\n\t    // Going to concatenate the lines after parsing.  For an empty or\n\t    // comment line use an empty string.\n\t    // Insert NL characters at the start of each line, the string will\n\t    // be split again later in .get_lambda_tv().\n\t    if (*p == NUL || vim9_comment_start(p))\n\t\tp = (char_u *)\"\";\n\t    plen = STRLEN(p);\n\t    pnl = vim_strnsave((char_u *)\"\\n\", plen + 1);\n\t    if (pnl != NULL)\n\t\tmch_memmove(pnl + 1, p, plen + 1);\n\t    ((char_u **)gap->ga_data)[gap->ga_len++] = pnl;\n\t    ((char_u **)freegap->ga_data)[freegap->ga_len++] = pnl;\n\t}\n\tif (ga_grow(gap, 1) == FAIL || ga_grow(freegap, 1) == FAIL)\n\t    goto erret;\n\tif (cmdline != NULL)\n\t    // more is following after the \"}\", which was skipped\n\t    last = cmdline;\n\telse\n\t    // nothing is following the \"}\"\n\t    last = (char_u *)\"}\";\n\tplen = STRLEN(last);\n\tpnl = vim_strnsave((char_u *)\"\\n\", plen + 1);\n\tif (pnl != NULL)\n\t    mch_memmove(pnl + 1, last, plen + 1);\n\t((char_u **)gap->ga_data)[gap->ga_len++] = pnl;\n\t((char_u **)freegap->ga_data)[freegap->ga_len++] = pnl;\n    }\n\n    if (cmdline != NULL)\n    {\n\tgarray_T *tfgap = &evalarg->eval_tofree_ga;\n\n\t// Something comes after the \"}\".\n\t*arg = eap.nextcmd;\n\n\t// \"arg\" points into cmdline, need to keep the line and free it later.\n\tif (ga_grow(tfgap, 1) == OK)\n\t{\n\t    ((char_u **)(tfgap->ga_data))[tfgap->ga_len++] = cmdline;\n\t    evalarg->eval_using_cmdline = TRUE;\n\t}\n    }\n    else\n\t*arg = (char_u *)\"\";\n\n    if (!evaluate)\n    {\n\tret = OK;\n\tgoto erret;\n    }\n\n    name = get_lambda_name();\n    ufunc = alloc_clear(offsetof(ufunc_T, uf_name) + STRLEN(name) + 1);\n    if (ufunc == NULL)\n\tgoto erret;\n    set_ufunc_name(ufunc, name);\n    if (hash_add(&func_hashtab, UF2HIKEY(ufunc)) == FAIL)\n\tgoto erret;\n    ufunc->uf_flags = FC_LAMBDA;\n    ufunc->uf_refcount = 1;\n    ufunc->uf_args = *newargs;\n    newargs->ga_data = NULL;\n    ufunc->uf_def_args = *default_args;\n    default_args->ga_data = NULL;\n    ufunc->uf_func_type = &t_func_any;\n\n    // error messages are for the first function line\n    lnum_save = SOURCING_LNUM;\n    SOURCING_LNUM = sourcing_lnum_top;\n\n    // parse argument types\n    if (parse_argument_types(ufunc, argtypes, varargs) == FAIL)\n    {\n\tSOURCING_LNUM = lnum_save;\n\tgoto erret;\n    }\n\n    // parse the return type, if any\n    if (parse_return_type(ufunc, ret_type) == FAIL)\n\tgoto erret;\n\n    pt = ALLOC_CLEAR_ONE(partial_T);\n    if (pt == NULL)\n\tgoto erret;\n    pt->pt_func = ufunc;\n    pt->pt_refcount = 1;\n\n    ufunc->uf_lines = newlines;\n    newlines.ga_data = NULL;\n    if (sandbox)\n\tufunc->uf_flags |= FC_SANDBOX;\n    if (!ASCII_ISUPPER(*ufunc->uf_name))\n\tufunc->uf_flags |= FC_VIM9;\n    ufunc->uf_script_ctx = current_sctx;\n    ufunc->uf_script_ctx_version = current_sctx.sc_version;\n    ufunc->uf_script_ctx.sc_lnum += sourcing_lnum_top;\n    set_function_type(ufunc);\n\n    function_using_block_scopes(ufunc, evalarg->eval_cstack);\n\n    rettv->vval.v_partial = pt;\n    rettv->v_type = VAR_PARTIAL;\n    ufunc = NULL;\n    ret = OK;\n\nerret:\n    if (lnum_save >= 0)\n\tSOURCING_LNUM = lnum_save;\n    vim_free(line_to_free);\n    ga_clear_strings(&newlines);\n    if (newargs != NULL)\n\tga_clear_strings(newargs);\n    ga_clear_strings(default_args);\n    if (ufunc != NULL)\n    {\n\tfunc_clear(ufunc, TRUE);\n\tfunc_free(ufunc, TRUE);\n    }\n    return ret;\n}\n\n/*\n * Parse a lambda expression and get a Funcref from \"*arg\" into \"rettv\".\n * \"arg\" points to the { in \"{arg -> expr}\" or the ( in \"(arg) => expr\"\n * When \"types_optional\" is TRUE optionally take argument types.\n * Return OK or FAIL.  Returns NOTDONE for dict or {expr}.\n */\n    int\nget_lambda_tv(\n\tchar_u\t    **arg,\n\ttypval_T    *rettv,\n\tint\t    types_optional,\n\tevalarg_T   *evalarg)\n{\n    int\t\tevaluate = evalarg != NULL\n\t\t\t\t      && (evalarg->eval_flags & EVAL_EVALUATE);\n    garray_T\tnewargs;\n    garray_T\tnewlines;\n    garray_T\t*pnewargs;\n    garray_T\targtypes;\n    garray_T\tdefault_args;\n    ufunc_T\t*fp = NULL;\n    partial_T   *pt = NULL;\n    int\t\tvarargs;\n    char_u\t*ret_type = NULL;\n    int\t\tret;\n    char_u\t*s;\n    char_u\t*start, *end;\n    int\t\t*old_eval_lavars = eval_lavars_used;\n    int\t\teval_lavars = FALSE;\n    char_u\t*tofree1 = NULL;\n    char_u\t*tofree2 = NULL;\n    int\t\tequal_arrow = **arg == '(';\n    int\t\twhite_error = FALSE;\n    int\t\tcalled_emsg_start = called_emsg;\n\n    if (equal_arrow && !in_vim9script())\n\treturn NOTDONE;\n\n    ga_init(&newargs);\n    ga_init(&newlines);\n\n    // First, check if this is really a lambda expression. \"->\" or \"=>\" must\n    // be found after the arguments.\n    s = *arg + 1;\n    ret = get_function_args(&s, equal_arrow ? ')' : '-', NULL,\n\t    types_optional ? &argtypes : NULL, types_optional, evalarg,\n\t\t\t\t\tNULL, &default_args, TRUE, NULL, NULL);\n    if (ret == FAIL || skip_arrow(s, equal_arrow, &ret_type, NULL) == NULL)\n    {\n\tif (types_optional)\n\t    ga_clear_strings(&argtypes);\n\treturn called_emsg == called_emsg_start ? NOTDONE : FAIL;\n    }\n\n    // Parse the arguments for real.\n    if (evaluate)\n\tpnewargs = &newargs;\n    else\n\tpnewargs = NULL;\n    *arg += 1;\n    ret = get_function_args(arg, equal_arrow ? ')' : '-', pnewargs,\n\t    types_optional ? &argtypes : NULL, types_optional, evalarg,\n\t\t\t\t\t    &varargs, &default_args,\n\t\t\t\t\t    FALSE, NULL, NULL);\n    if (ret == FAIL\n\t\t  || (s = skip_arrow(*arg, equal_arrow, &ret_type,\n\t\tequal_arrow || in_vim9script() ? &white_error : NULL)) == NULL)\n    {\n\tif (types_optional)\n\t    ga_clear_strings(&argtypes);\n\tga_clear_strings(&newargs);\n\treturn white_error ? FAIL : NOTDONE;\n    }\n    *arg = s;\n\n    // Skipping over linebreaks may make \"ret_type\" invalid, make a copy.\n    if (ret_type != NULL)\n    {\n\tret_type = vim_strsave(ret_type);\n\ttofree2 = ret_type;\n    }\n\n    // Set up a flag for checking local variables and arguments.\n    if (evaluate)\n\teval_lavars_used = &eval_lavars;\n\n    *arg = skipwhite_and_linebreak(*arg, evalarg);\n\n    // Recognize \"{\" as the start of a function body.\n    if (equal_arrow && **arg == '{')\n    {\n\tif (evalarg == NULL)\n\t    // cannot happen?\n\t    goto theend;\n\tif (lambda_function_body(arg, rettv, evalarg, pnewargs,\n\t\t\t   types_optional ? &argtypes : NULL, varargs,\n\t\t\t   &default_args, ret_type) == FAIL)\n\t    goto errret;\n\tgoto theend;\n    }\n    if (default_args.ga_len > 0)\n    {\n\temsg(_(e_cannot_use_default_values_in_lambda));\n\tgoto errret;\n    }\n\n    // Get the start and the end of the expression.\n    start = *arg;\n    ret = skip_expr_concatenate(arg, &start, &end, evalarg);\n    if (ret == FAIL)\n\tgoto errret;\n    if (evalarg != NULL)\n    {\n\t// avoid that the expression gets freed when another line break follows\n\ttofree1 = evalarg->eval_tofree;\n\tevalarg->eval_tofree = NULL;\n    }\n\n    if (!equal_arrow)\n    {\n\t*arg = skipwhite_and_linebreak(*arg, evalarg);\n\tif (**arg != '}')\n\t{\n\t    semsg(_(\"E451: Expected }: %s\"), *arg);\n\t    goto errret;\n\t}\n\t++*arg;\n    }\n\n    if (evaluate)\n    {\n\tint\t    len;\n\tint\t    flags = FC_LAMBDA;\n\tchar_u\t    *p;\n\tchar_u\t    *line_end;\n\tchar_u\t    *name = get_lambda_name();\n\n\tfp = alloc_clear(offsetof(ufunc_T, uf_name) + STRLEN(name) + 1);\n\tif (fp == NULL)\n\t    goto errret;\n\tfp->uf_def_status = UF_NOT_COMPILED;\n\tpt = ALLOC_CLEAR_ONE(partial_T);\n\tif (pt == NULL)\n\t    goto errret;\n\n\tga_init2(&newlines, (int)sizeof(char_u *), 1);\n\tif (ga_grow(&newlines, 1) == FAIL)\n\t    goto errret;\n\n\t// If there are line breaks, we need to split up the string.\n\tline_end = vim_strchr(start, '\\n');\n\tif (line_end == NULL || line_end > end)\n\t    line_end = end;\n\n\t// Add \"return \" before the expression (or the first line).\n\tlen = 7 + (int)(line_end - start) + 1;\n\tp = alloc(len);\n\tif (p == NULL)\n\t    goto errret;\n\t((char_u **)(newlines.ga_data))[newlines.ga_len++] = p;\n\tSTRCPY(p, \"return \");\n\tvim_strncpy(p + 7, start, line_end - start);\n\n\tif (line_end != end)\n\t{\n\t    // Add more lines, split by line breaks.  Thus is used when a\n\t    // lambda with { cmds } is encountered.\n\t    while (*line_end == '\\n')\n\t    {\n\t\tif (ga_grow(&newlines, 1) == FAIL)\n\t\t    goto errret;\n\t\tstart = line_end + 1;\n\t\tline_end = vim_strchr(start, '\\n');\n\t\tif (line_end == NULL)\n\t\t    line_end = end;\n\t\t((char_u **)(newlines.ga_data))[newlines.ga_len++] =\n\t\t\t\t\t vim_strnsave(start, line_end - start);\n\t    }\n\t}\n\n\tif (strstr((char *)p + 7, \"a:\") == NULL)\n\t    // No a: variables are used for sure.\n\t    flags |= FC_NOARGS;\n\n\tfp->uf_refcount = 1;\n\tset_ufunc_name(fp, name);\n\tfp->uf_args = newargs;\n\tga_init(&fp->uf_def_args);\n\tif (types_optional)\n\t{\n\t    if (parse_argument_types(fp, &argtypes,\n\t\t\t\t\t   in_vim9script() && varargs) == FAIL)\n\t\tgoto errret;\n\t    if (ret_type != NULL)\n\t    {\n\t\tfp->uf_ret_type = parse_type(&ret_type,\n\t\t\t\t\t\t      &fp->uf_type_list, TRUE);\n\t\tif (fp->uf_ret_type == NULL)\n\t\t    goto errret;\n\t    }\n\t    else\n\t\tfp->uf_ret_type = &t_unknown;\n\t}\n\n\tfp->uf_lines = newlines;\n\tif (current_funccal != NULL && eval_lavars)\n\t{\n\t    flags |= FC_CLOSURE;\n\t    if (register_closure(fp) == FAIL)\n\t\tgoto errret;\n\t}\n\n#ifdef FEAT_PROFILE\n\tif (prof_def_func())\n\t    func_do_profile(fp);\n#endif\n\tif (sandbox)\n\t    flags |= FC_SANDBOX;\n\t// In legacy script a lambda can be called with more args than\n\t// uf_args.ga_len.  In Vim9 script \"...name\" has to be used.\n\tfp->uf_varargs = !in_vim9script() || varargs;\n\tfp->uf_flags = flags;\n\tfp->uf_calls = 0;\n\tfp->uf_script_ctx = current_sctx;\n\tfp->uf_script_ctx.sc_lnum += SOURCING_LNUM - newlines.ga_len + 1;\n\n\tfunction_using_block_scopes(fp, evalarg->eval_cstack);\n\n\tpt->pt_func = fp;\n\tpt->pt_refcount = 1;\n\trettv->vval.v_partial = pt;\n\trettv->v_type = VAR_PARTIAL;\n\n\thash_add(&func_hashtab, UF2HIKEY(fp));\n    }\n\ntheend:\n    eval_lavars_used = old_eval_lavars;\n    if (evalarg != NULL && evalarg->eval_tofree == NULL)\n\tevalarg->eval_tofree = tofree1;\n    else\n\tvim_free(tofree1);\n    vim_free(tofree2);\n    if (types_optional)\n\tga_clear_strings(&argtypes);\n\n    return OK;\n\nerrret:\n    ga_clear_strings(&newargs);\n    ga_clear_strings(&newlines);\n    ga_clear_strings(&default_args);\n    if (types_optional)\n    {\n\tga_clear_strings(&argtypes);\n\tif (fp != NULL)\n\t    vim_free(fp->uf_arg_types);\n    }\n    vim_free(fp);\n    vim_free(pt);\n    if (evalarg != NULL && evalarg->eval_tofree == NULL)\n\tevalarg->eval_tofree = tofree1;\n    else\n\tvim_free(tofree1);\n    vim_free(tofree2);\n    eval_lavars_used = old_eval_lavars;\n    return FAIL;\n}\n\n/*\n * Check if \"name\" is a variable of type VAR_FUNC.  If so, return the function\n * name it contains, otherwise return \"name\".\n * If \"partialp\" is not NULL, and \"name\" is of type VAR_PARTIAL also set\n * \"partialp\".\n * If \"type\" is not NULL and a Vim9 script-local variable is found look up the\n * type of the variable.\n * If \"found_var\" is not NULL and a variable was found set it to TRUE.\n */\n    char_u *\nderef_func_name(\n\tchar_u\t    *name,\n\tint\t    *lenp,\n\tpartial_T   **partialp,\n\ttype_T\t    **type,\n\tint\t    no_autoload,\n\tint\t    *found_var)\n{\n    dictitem_T\t*v;\n    typval_T\t*tv = NULL;\n    int\t\tcc;\n    char_u\t*s = NULL;\n    hashtab_T\t*ht;\n    int\t\tdid_type = FALSE;\n\n    if (partialp != NULL)\n\t*partialp = NULL;\n\n    cc = name[*lenp];\n    name[*lenp] = NUL;\n\n    v = find_var(name, &ht, no_autoload);\n    name[*lenp] = cc;\n    if (v != NULL)\n    {\n\ttv = &v->di_tv;\n    }\n    else if (in_vim9script() || STRNCMP(name, \"s:\", 2) == 0)\n    {\n\timported_T  *import;\n\tchar_u\t    *p = name;\n\tint\t    len = *lenp;\n\n\tif (STRNCMP(name, \"s:\", 2) == 0)\n\t{\n\t    p = name + 2;\n\t    len -= 2;\n\t}\n\timport = find_imported(p, len, NULL);\n\n\t// imported variable from another script\n\tif (import != NULL)\n\t{\n\t    if (import->imp_funcname != NULL)\n\t    {\n\t\ts = import->imp_funcname;\n\t\t*lenp = (int)STRLEN(s);\n\t\treturn s;\n\t    }\n\t    if (import->imp_flags & IMP_FLAGS_STAR)\n\t    {\n\t\tname[len] = NUL;\n\t\tsemsg(_(e_cannot_use_str_itself_it_is_imported_with_star),\n\t\t\t\t\t\t\t\t\t name);\n\t\tname[len] = cc;\n\t\t*lenp = 0;\n\t\treturn (char_u *)\"\";\t// just in case\n\t    }\n\t    else\n\t    {\n\t\tscriptitem_T    *si = SCRIPT_ITEM(import->imp_sid);\n\t\tsvar_T\t\t*sv = ((svar_T *)si->sn_var_vals.ga_data)\n\t\t\t\t\t\t    + import->imp_var_vals_idx;\n\t\ttv = sv->sv_tv;\n\t\tif (type != NULL)\n\t\t    *type = sv->sv_type;\n\t\tdid_type = TRUE;\n\t    }\n\t}\n    }\n\n    if (tv != NULL)\n    {\n\tif (found_var != NULL)\n\t    *found_var = TRUE;\n\tif (tv->v_type == VAR_FUNC)\n\t{\n\t    if (tv->vval.v_string == NULL)\n\t    {\n\t\t*lenp = 0;\n\t\treturn (char_u *)\"\";\t// just in case\n\t    }\n\t    s = tv->vval.v_string;\n\t    *lenp = (int)STRLEN(s);\n\t}\n\n\tif (tv->v_type == VAR_PARTIAL)\n\t{\n\t    partial_T *pt = tv->vval.v_partial;\n\n\t    if (pt == NULL)\n\t    {\n\t\t*lenp = 0;\n\t\treturn (char_u *)\"\";\t// just in case\n\t    }\n\t    if (partialp != NULL)\n\t\t*partialp = pt;\n\t    s = partial_name(pt);\n\t    *lenp = (int)STRLEN(s);\n\t}\n\n\tif (s != NULL)\n\t{\n\t    if (!did_type && type != NULL && ht == get_script_local_ht())\n\t    {\n\t\tsvar_T  *sv = find_typval_in_script(tv);\n\n\t\tif (sv != NULL)\n\t\t    *type = sv->sv_type;\n\t    }\n\t    return s;\n\t}\n    }\n\n    return name;\n}\n\n/*\n * Give an error message with a function name.  Handle <SNR> things.\n * \"ermsg\" is to be passed without translation, use N_() instead of _().\n */\n    void\nemsg_funcname(char *ermsg, char_u *name)\n{\n    char_u\t*p;\n\n    if (*name == K_SPECIAL)\n\tp = concat_str((char_u *)\"<SNR>\", name + 3);\n    else\n\tp = name;\n    semsg(_(ermsg), p);\n    if (p != name)\n\tvim_free(p);\n}\n\n/*\n * Allocate a variable for the result of a function.\n * Return OK or FAIL.\n */\n    int\nget_func_tv(\n    char_u\t*name,\t\t// name of the function\n    int\t\tlen,\t\t// length of \"name\" or -1 to use strlen()\n    typval_T\t*rettv,\n    char_u\t**arg,\t\t// argument, pointing to the '('\n    evalarg_T\t*evalarg,\t// for line continuation\n    funcexe_T\t*funcexe)\t// various values\n{\n    char_u\t*argp;\n    int\t\tret = OK;\n    typval_T\targvars[MAX_FUNC_ARGS + 1];\t// vars for arguments\n    int\t\targcount = 0;\t\t// number of arguments found\n    int\t\tvim9script = in_vim9script();\n\n    /*\n     * Get the arguments.\n     */\n    argp = *arg;\n    while (argcount < MAX_FUNC_ARGS - (funcexe->fe_partial == NULL ? 0\n\t\t\t\t\t       : funcexe->fe_partial->pt_argc))\n    {\n\t// skip the '(' or ',' and possibly line breaks\n\targp = skipwhite_and_linebreak(argp + 1, evalarg);\n\n\tif (*argp == ')' || *argp == ',' || *argp == NUL)\n\t    break;\n\tif (eval1(&argp, &argvars[argcount], evalarg) == FAIL)\n\t{\n\t    ret = FAIL;\n\t    break;\n\t}\n\t++argcount;\n\t// The comma should come right after the argument, but this wasn't\n\t// checked previously, thus only enforce it in Vim9 script.\n\tif (vim9script)\n\t{\n\t    if (*argp != ',' && *skipwhite(argp) == ',')\n\t    {\n\t\tsemsg(_(e_no_white_space_allowed_before_str_str), \",\", argp);\n\t\tret = FAIL;\n\t\tbreak;\n\t    }\n\t}\n\telse\n\t    argp = skipwhite(argp);\n\tif (*argp != ',')\n\t    break;\n\tif (vim9script && !IS_WHITE_OR_NUL(argp[1]))\n\t{\n\t    semsg(_(e_white_space_required_after_str_str), \",\", argp);\n\t    ret = FAIL;\n\t    break;\n\t}\n    }\n    argp = skipwhite_and_linebreak(argp, evalarg);\n    if (*argp == ')')\n\t++argp;\n    else\n\tret = FAIL;\n\n    if (ret == OK)\n    {\n\tint\ti = 0;\n\tint\tdid_emsg_before = did_emsg;\n\n\tif (get_vim_var_nr(VV_TESTING))\n\t{\n\t    // Prepare for calling test_garbagecollect_now(), need to know\n\t    // what variables are used on the call stack.\n\t    if (funcargs.ga_itemsize == 0)\n\t\tga_init2(&funcargs, (int)sizeof(typval_T *), 50);\n\t    for (i = 0; i < argcount; ++i)\n\t\tif (ga_grow(&funcargs, 1) == OK)\n\t\t    ((typval_T **)funcargs.ga_data)[funcargs.ga_len++] =\n\t\t\t\t\t\t\t\t  &argvars[i];\n\t}\n\n\tret = call_func(name, len, rettv, argcount, argvars, funcexe);\n\tif (in_vim9script() && did_emsg > did_emsg_before)\n\t{\n\t    // An error in a builtin function does not return FAIL, but we do\n\t    // want to abort further processing if an error was given.\n\t    ret = FAIL;\n\t    clear_tv(rettv);\n\t}\n\n\tfuncargs.ga_len -= i;\n    }\n    else if (!aborting())\n    {\n\tif (argcount == MAX_FUNC_ARGS)\n\t    emsg_funcname(N_(\"E740: Too many arguments for function %s\"), name);\n\telse\n\t    emsg_funcname(N_(e_invalid_arguments_for_function_str), name);\n    }\n\n    while (--argcount >= 0)\n\tclear_tv(&argvars[argcount]);\n\n    if (in_vim9script())\n\t*arg = argp;\n    else\n\t*arg = skipwhite(argp);\n    return ret;\n}\n\n/*\n * Return TRUE if \"p\" starts with \"<SID>\" or \"s:\".\n * Only works if eval_fname_script() returned non-zero for \"p\"!\n */\n    static int\neval_fname_sid(char_u *p)\n{\n    return (*p == 's' || TOUPPER_ASC(p[2]) == 'I');\n}\n\n/*\n * In a script change <SID>name() and s:name() to K_SNR 123_name().\n * Change <SNR>123_name() to K_SNR 123_name().\n * Use \"fname_buf[FLEN_FIXED + 1]\" when it fits, otherwise allocate memory\n * (slow).\n */\n    char_u *\nfname_trans_sid(char_u *name, char_u *fname_buf, char_u **tofree, int *error)\n{\n    int\t\tllen;\n    char_u\t*fname;\n    int\t\ti;\n\n    llen = eval_fname_script(name);\n    if (llen > 0)\n    {\n\tfname_buf[0] = K_SPECIAL;\n\tfname_buf[1] = KS_EXTRA;\n\tfname_buf[2] = (int)KE_SNR;\n\ti = 3;\n\tif (eval_fname_sid(name))\t// \"<SID>\" or \"s:\"\n\t{\n\t    if (current_sctx.sc_sid <= 0)\n\t\t*error = FCERR_SCRIPT;\n\t    else\n\t    {\n\t\tsprintf((char *)fname_buf + 3, \"%ld_\",\n\t\t\t\t\t\t    (long)current_sctx.sc_sid);\n\t\ti = (int)STRLEN(fname_buf);\n\t    }\n\t}\n\tif (i + STRLEN(name + llen) < FLEN_FIXED)\n\t{\n\t    STRCPY(fname_buf + i, name + llen);\n\t    fname = fname_buf;\n\t}\n\telse\n\t{\n\t    fname = alloc(i + STRLEN(name + llen) + 1);\n\t    if (fname == NULL)\n\t\t*error = FCERR_OTHER;\n\t    else\n\t    {\n\t\t*tofree = fname;\n\t\tmch_memmove(fname, fname_buf, (size_t)i);\n\t\tSTRCPY(fname + i, name + llen);\n\t    }\n\t}\n    }\n    else\n\tfname = name;\n    return fname;\n}\n\n/*\n * Find a function \"name\" in script \"sid\".\n */\n    static ufunc_T *\nfind_func_with_sid(char_u *name, int sid)\n{\n    hashitem_T\t*hi;\n    char_u\tbuffer[200];\n\n    buffer[0] = K_SPECIAL;\n    buffer[1] = KS_EXTRA;\n    buffer[2] = (int)KE_SNR;\n    vim_snprintf((char *)buffer + 3, sizeof(buffer) - 3, \"%ld_%s\",\n\t\t\t\t\t\t\t      (long)sid, name);\n    hi = hash_find(&func_hashtab, buffer);\n    if (!HASHITEM_EMPTY(hi))\n\treturn HI2UF(hi);\n\n    return NULL;\n}\n\n/*\n * Find a function by name, return pointer to it in ufuncs.\n * When \"is_global\" is true don't find script-local or imported functions.\n * Return NULL for unknown function.\n */\n    ufunc_T *\nfind_func_even_dead(char_u *name, int is_global, cctx_T *cctx)\n{\n    hashitem_T\t*hi;\n    ufunc_T\t*func;\n    imported_T\t*imported;\n\n    if (!is_global)\n    {\n\tchar_u\t*after_script = NULL;\n\tlong\tsid = 0;\n\tint\tfind_script_local = in_vim9script() && eval_isnamec1(*name)\n\t\t\t\t\t   && (name[1] != ':' || *name == 's');\n\n\tif (find_script_local)\n\t{\n\t    // Find script-local function before global one.\n\t    func = find_func_with_sid(name[0] == 's' && name[1] == ':'\n\t\t\t\t       ? name + 2 : name, current_sctx.sc_sid);\n\t    if (func != NULL)\n\t\treturn func;\n\t}\n\n\tif (name[0] == K_SPECIAL\n\t\t&& name[1] == KS_EXTRA\n\t\t&& name[2] == KE_SNR)\n\t{\n\t    // Caller changes s: to <SNR>99_name.\n\n\t    after_script = name + 3;\n\t    sid = getdigits(&after_script);\n\t    if (*after_script == '_')\n\t\t++after_script;\n\t    else\n\t\tafter_script = NULL;\n\t}\n\tif (find_script_local || after_script != NULL)\n\t{\n\t    // Find imported function before global one.\n\t    if (after_script != NULL && sid != current_sctx.sc_sid)\n\t\timported = find_imported_in_script(after_script, 0, sid);\n\t    else\n\t\timported = find_imported(after_script == NULL\n\t\t\t\t\t       ? name : after_script, 0, cctx);\n\t    if (imported != NULL && imported->imp_funcname != NULL)\n\t    {\n\t\thi = hash_find(&func_hashtab, imported->imp_funcname);\n\t\tif (!HASHITEM_EMPTY(hi))\n\t\t    return HI2UF(hi);\n\t    }\n\t}\n    }\n\n    hi = hash_find(&func_hashtab,\n\t\t\t\tSTRNCMP(name, \"g:\", 2) == 0 ? name + 2 : name);\n    if (!HASHITEM_EMPTY(hi))\n\treturn HI2UF(hi);\n\n    return NULL;\n}\n\n/*\n * Find a function by name, return pointer to it in ufuncs.\n * \"cctx\" is passed in a :def function to find imported functions.\n * Return NULL for unknown or dead function.\n */\n    ufunc_T *\nfind_func(char_u *name, int is_global, cctx_T *cctx)\n{\n    ufunc_T\t*fp = find_func_even_dead(name, is_global, cctx);\n\n    if (fp != NULL && (fp->uf_flags & FC_DEAD) == 0)\n\treturn fp;\n    return NULL;\n}\n\n/*\n * Return TRUE if \"ufunc\" is a global function.\n */\n    int\nfunc_is_global(ufunc_T *ufunc)\n{\n    return ufunc->uf_name[0] != K_SPECIAL;\n}\n\n/*\n * Copy the function name of \"fp\" to buffer \"buf\".\n * \"buf\" must be able to hold the function name plus three bytes.\n * Takes care of script-local function names.\n */\n    static void\ncat_func_name(char_u *buf, ufunc_T *fp)\n{\n    if (!func_is_global(fp))\n    {\n\tSTRCPY(buf, \"<SNR>\");\n\tSTRCAT(buf, fp->uf_name + 3);\n    }\n    else\n\tSTRCPY(buf, fp->uf_name);\n}\n\n/*\n * Add a number variable \"name\" to dict \"dp\" with value \"nr\".\n */\n    static void\nadd_nr_var(\n    dict_T\t*dp,\n    dictitem_T\t*v,\n    char\t*name,\n    varnumber_T nr)\n{\n    STRCPY(v->di_key, name);\n    v->di_flags = DI_FLAGS_RO | DI_FLAGS_FIX;\n    hash_add(&dp->dv_hashtab, DI2HIKEY(v));\n    v->di_tv.v_type = VAR_NUMBER;\n    v->di_tv.v_lock = VAR_FIXED;\n    v->di_tv.vval.v_number = nr;\n}\n\n/*\n * Free \"fc\".\n */\n    static void\nfree_funccal(funccall_T *fc)\n{\n    int\ti;\n\n    for (i = 0; i < fc->fc_funcs.ga_len; ++i)\n    {\n\tufunc_T *fp = ((ufunc_T **)(fc->fc_funcs.ga_data))[i];\n\n\t// When garbage collecting a funccall_T may be freed before the\n\t// function that references it, clear its uf_scoped field.\n\t// The function may have been redefined and point to another\n\t// funccall_T, don't clear it then.\n\tif (fp != NULL && fp->uf_scoped == fc)\n\t    fp->uf_scoped = NULL;\n    }\n    ga_clear(&fc->fc_funcs);\n\n    func_ptr_unref(fc->func);\n    vim_free(fc);\n}\n\n/*\n * Free \"fc\" and what it contains.\n * Can be called only when \"fc\" is kept beyond the period of it called,\n * i.e. after cleanup_function_call(fc).\n */\n   static void\nfree_funccal_contents(funccall_T *fc)\n{\n    listitem_T\t*li;\n\n    // Free all l: variables.\n    vars_clear(&fc->l_vars.dv_hashtab);\n\n    // Free all a: variables.\n    vars_clear(&fc->l_avars.dv_hashtab);\n\n    // Free the a:000 variables.\n    FOR_ALL_LIST_ITEMS(&fc->l_varlist, li)\n\tclear_tv(&li->li_tv);\n\n    free_funccal(fc);\n}\n\n/*\n * Handle the last part of returning from a function: free the local hashtable.\n * Unless it is still in use by a closure.\n */\n    static void\ncleanup_function_call(funccall_T *fc)\n{\n    int\tmay_free_fc = fc->fc_refcount <= 0;\n    int\tfree_fc = TRUE;\n\n    current_funccal = fc->caller;\n\n    // Free all l: variables if not referred.\n    if (may_free_fc && fc->l_vars.dv_refcount == DO_NOT_FREE_CNT)\n\tvars_clear(&fc->l_vars.dv_hashtab);\n    else\n\tfree_fc = FALSE;\n\n    // If the a:000 list and the l: and a: dicts are not referenced and\n    // there is no closure using it, we can free the funccall_T and what's\n    // in it.\n    if (may_free_fc && fc->l_avars.dv_refcount == DO_NOT_FREE_CNT)\n\tvars_clear_ext(&fc->l_avars.dv_hashtab, FALSE);\n    else\n    {\n\tint\t    todo;\n\thashitem_T  *hi;\n\tdictitem_T  *di;\n\n\tfree_fc = FALSE;\n\n\t// Make a copy of the a: variables, since we didn't do that above.\n\ttodo = (int)fc->l_avars.dv_hashtab.ht_used;\n\tfor (hi = fc->l_avars.dv_hashtab.ht_array; todo > 0; ++hi)\n\t{\n\t    if (!HASHITEM_EMPTY(hi))\n\t    {\n\t\t--todo;\n\t\tdi = HI2DI(hi);\n\t\tcopy_tv(&di->di_tv, &di->di_tv);\n\t    }\n\t}\n    }\n\n    if (may_free_fc && fc->l_varlist.lv_refcount == DO_NOT_FREE_CNT)\n\tfc->l_varlist.lv_first = NULL;\n    else\n    {\n\tlistitem_T *li;\n\n\tfree_fc = FALSE;\n\n\t// Make a copy of the a:000 items, since we didn't do that above.\n\tFOR_ALL_LIST_ITEMS(&fc->l_varlist, li)\n\t    copy_tv(&li->li_tv, &li->li_tv);\n    }\n\n    if (free_fc)\n\tfree_funccal(fc);\n    else\n    {\n\tstatic int made_copy = 0;\n\n\t// \"fc\" is still in use.  This can happen when returning \"a:000\",\n\t// assigning \"l:\" to a global variable or defining a closure.\n\t// Link \"fc\" in the list for garbage collection later.\n\tfc->caller = previous_funccal;\n\tprevious_funccal = fc;\n\n\tif (want_garbage_collect)\n\t    // If garbage collector is ready, clear count.\n\t    made_copy = 0;\n\telse if (++made_copy >= (int)((4096 * 1024) / sizeof(*fc)))\n\t{\n\t    // We have made a lot of copies, worth 4 Mbyte.  This can happen\n\t    // when repetitively calling a function that creates a reference to\n\t    // itself somehow.  Call the garbage collector soon to avoid using\n\t    // too much memory.\n\t    made_copy = 0;\n\t    want_garbage_collect = TRUE;\n\t}\n    }\n}\n\n/*\n * Return TRUE if \"name\" is a numbered function, ignoring a \"g:\" prefix.\n */\n    static int\nnumbered_function(char_u *name)\n{\n    return isdigit(*name)\n\t    || (name[0] == 'g' && name[1] == ':' && isdigit(name[2]));\n}\n\n/*\n * There are two kinds of function names:\n * 1. ordinary names, function defined with :function or :def\n * 2. numbered functions and lambdas\n * For the first we only count the name stored in func_hashtab as a reference,\n * using function() does not count as a reference, because the function is\n * looked up by name.\n */\n    int\nfunc_name_refcount(char_u *name)\n{\n    return numbered_function(name) || *name == '<';\n}\n\n/*\n * Unreference \"fc\": decrement the reference count and free it when it\n * becomes zero.  \"fp\" is detached from \"fc\".\n * When \"force\" is TRUE we are exiting.\n */\n    static void\nfunccal_unref(funccall_T *fc, ufunc_T *fp, int force)\n{\n    funccall_T\t**pfc;\n    int\t\ti;\n\n    if (fc == NULL)\n\treturn;\n\n    if (--fc->fc_refcount <= 0 && (force || (\n\t\tfc->l_varlist.lv_refcount == DO_NOT_FREE_CNT\n\t\t&& fc->l_vars.dv_refcount == DO_NOT_FREE_CNT\n\t\t&& fc->l_avars.dv_refcount == DO_NOT_FREE_CNT)))\n\tfor (pfc = &previous_funccal; *pfc != NULL; pfc = &(*pfc)->caller)\n\t{\n\t    if (fc == *pfc)\n\t    {\n\t\t*pfc = fc->caller;\n\t\tfree_funccal_contents(fc);\n\t\treturn;\n\t    }\n\t}\n    for (i = 0; i < fc->fc_funcs.ga_len; ++i)\n\tif (((ufunc_T **)(fc->fc_funcs.ga_data))[i] == fp)\n\t    ((ufunc_T **)(fc->fc_funcs.ga_data))[i] = NULL;\n}\n\n/*\n * Remove the function from the function hashtable.  If the function was\n * deleted while it still has references this was already done.\n * Return TRUE if the entry was deleted, FALSE if it wasn't found.\n */\n    static int\nfunc_remove(ufunc_T *fp)\n{\n    hashitem_T\t*hi;\n\n    // Return if it was already virtually deleted.\n    if (fp->uf_flags & FC_DEAD)\n\treturn FALSE;\n\n    hi = hash_find(&func_hashtab, UF2HIKEY(fp));\n    if (!HASHITEM_EMPTY(hi))\n    {\n\t// When there is a def-function index do not actually remove the\n\t// function, so we can find the index when defining the function again.\n\t// Do remove it when it's a copy.\n\tif (fp->uf_def_status == UF_COMPILED && (fp->uf_flags & FC_COPY) == 0)\n\t{\n\t    fp->uf_flags |= FC_DEAD;\n\t    return FALSE;\n\t}\n\thash_remove(&func_hashtab, hi);\n\tfp->uf_flags |= FC_DELETED;\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n    static void\nfunc_clear_items(ufunc_T *fp)\n{\n    ga_clear_strings(&(fp->uf_args));\n    ga_clear_strings(&(fp->uf_def_args));\n    ga_clear_strings(&(fp->uf_lines));\n    VIM_CLEAR(fp->uf_arg_types);\n    VIM_CLEAR(fp->uf_block_ids);\n    VIM_CLEAR(fp->uf_va_name);\n    clear_type_list(&fp->uf_type_list);\n\n    // Increment the refcount of this function to avoid it being freed\n    // recursively when the partial is freed.\n    fp->uf_refcount += 3;\n    partial_unref(fp->uf_partial);\n    fp->uf_partial = NULL;\n    fp->uf_refcount -= 3;\n\n#ifdef FEAT_LUA\n    if (fp->uf_cb_free != NULL)\n    {\n\tfp->uf_cb_free(fp->uf_cb_state);\n\tfp->uf_cb_free = NULL;\n    }\n\n    fp->uf_cb_state = NULL;\n    fp->uf_cb = NULL;\n#endif\n#ifdef FEAT_PROFILE\n    VIM_CLEAR(fp->uf_tml_count);\n    VIM_CLEAR(fp->uf_tml_total);\n    VIM_CLEAR(fp->uf_tml_self);\n#endif\n}\n\n/*\n * Free all things that a function contains.  Does not free the function\n * itself, use func_free() for that.\n * When \"force\" is TRUE we are exiting.\n */\n    static void\nfunc_clear(ufunc_T *fp, int force)\n{\n    if (fp->uf_cleared)\n\treturn;\n    fp->uf_cleared = TRUE;\n\n    // clear this function\n    func_clear_items(fp);\n    funccal_unref(fp->uf_scoped, fp, force);\n    unlink_def_function(fp);\n}\n\n/*\n * Free a function and remove it from the list of functions.  Does not free\n * what a function contains, call func_clear() first.\n * When \"force\" is TRUE we are exiting.\n * Returns OK when the function was actually freed.\n */\n    static int\nfunc_free(ufunc_T *fp, int force)\n{\n    // Only remove it when not done already, otherwise we would remove a newer\n    // version of the function with the same name.\n    if ((fp->uf_flags & (FC_DELETED | FC_REMOVED)) == 0)\n\tfunc_remove(fp);\n\n    if ((fp->uf_flags & FC_DEAD) == 0 || force)\n    {\n\tif (fp->uf_dfunc_idx > 0)\n\t    unlink_def_function(fp);\n\tVIM_CLEAR(fp->uf_name_exp);\n\tvim_free(fp);\n\treturn OK;\n    }\n    return FAIL;\n}\n\n/*\n * Free all things that a function contains and free the function itself.\n * When \"force\" is TRUE we are exiting.\n */\n    void\nfunc_clear_free(ufunc_T *fp, int force)\n{\n    func_clear(fp, force);\n    if (force || fp->uf_dfunc_idx == 0 || func_name_refcount(fp->uf_name)\n\t\t\t\t\t\t   || (fp->uf_flags & FC_COPY))\n\tfunc_free(fp, force);\n    else\n\tfp->uf_flags |= FC_DEAD;\n}\n\n/*\n * Copy already defined function \"lambda\" to a new function with name \"global\".\n * This is for when a compiled function defines a global function.\n */\n    int\ncopy_func(char_u *lambda, char_u *global, ectx_T *ectx)\n{\n    ufunc_T *ufunc = find_func_even_dead(lambda, TRUE, NULL);\n    ufunc_T *fp = NULL;\n\n    if (ufunc == NULL)\n    {\n\tsemsg(_(e_lambda_function_not_found_str), lambda);\n\treturn FAIL;\n    }\n\n    fp = find_func(global, TRUE, NULL);\n    if (fp != NULL)\n    {\n\t// TODO: handle ! to overwrite\n\tsemsg(_(e_funcexts), global);\n\treturn FAIL;\n    }\n\n    fp = alloc_clear(offsetof(ufunc_T, uf_name) + STRLEN(global) + 1);\n    if (fp == NULL)\n\treturn FAIL;\n\n    fp->uf_varargs = ufunc->uf_varargs;\n    fp->uf_flags = (ufunc->uf_flags & ~FC_VIM9) | FC_COPY;\n    fp->uf_def_status = ufunc->uf_def_status;\n    fp->uf_dfunc_idx = ufunc->uf_dfunc_idx;\n    if (ga_copy_strings(&ufunc->uf_args, &fp->uf_args) == FAIL\n\t    || ga_copy_strings(&ufunc->uf_def_args, &fp->uf_def_args)\n\t\t\t\t\t\t\t\t    == FAIL\n\t    || ga_copy_strings(&ufunc->uf_lines, &fp->uf_lines) == FAIL)\n\tgoto failed;\n\n    fp->uf_name_exp = ufunc->uf_name_exp == NULL ? NULL\n\t\t\t\t\t : vim_strsave(ufunc->uf_name_exp);\n    if (ufunc->uf_arg_types != NULL)\n    {\n\tfp->uf_arg_types = ALLOC_MULT(type_T *, fp->uf_args.ga_len);\n\tif (fp->uf_arg_types == NULL)\n\t    goto failed;\n\tmch_memmove(fp->uf_arg_types, ufunc->uf_arg_types,\n\t\t\t\t    sizeof(type_T *) * fp->uf_args.ga_len);\n    }\n    if (ufunc->uf_va_name != NULL)\n    {\n\tfp->uf_va_name = vim_strsave(ufunc->uf_va_name);\n\tif (fp->uf_va_name == NULL)\n\t    goto failed;\n    }\n    fp->uf_ret_type = ufunc->uf_ret_type;\n\n    fp->uf_refcount = 1;\n    STRCPY(fp->uf_name, global);\n    hash_add(&func_hashtab, UF2HIKEY(fp));\n\n    // the referenced dfunc_T is now used one more time\n    link_def_function(fp);\n\n    // Create a partial to store the context of the function where it was\n    // instantiated.  Only needs to be done once.  Do this on the original\n    // function, \"dfunc->df_ufunc\" will point to it.\n    if ((ufunc->uf_flags & FC_CLOSURE) && ufunc->uf_partial == NULL)\n    {\n\tpartial_T   *pt = ALLOC_CLEAR_ONE(partial_T);\n\n\tif (pt == NULL)\n\t    goto failed;\n\tif (fill_partial_and_closure(pt, ufunc, ectx) == FAIL)\n\t{\n            vim_free(pt);\n\t    goto failed;\n\t}\n\tufunc->uf_partial = pt;\n\t--pt->pt_refcount;  // not actually referenced here\n    }\n\n    return OK;\n\nfailed:\n    func_clear_free(fp, TRUE);\n    return FAIL;\n}\n\nstatic int\tfuncdepth = 0;\n\n/*\n * Increment the function call depth count.\n * Return FAIL when going over 'maxfuncdepth'.\n * Otherwise return OK, must call funcdepth_decrement() later!\n */\n    int\nfuncdepth_increment(void)\n{\n    if (funcdepth >= p_mfd)\n    {\n\temsg(_(\"E132: Function call depth is higher than 'maxfuncdepth'\"));\n\treturn FAIL;\n    }\n    ++funcdepth;\n    return OK;\n}\n\n    void\nfuncdepth_decrement(void)\n{\n    --funcdepth;\n}\n\n/*\n * Get the current function call depth.\n */\n    int\nfuncdepth_get(void)\n{\n    return funcdepth;\n}\n\n/*\n * Restore the function call depth.  This is for cases where there is no\n * guarantee funcdepth_decrement() can be called exactly the same number of\n * times as funcdepth_increment().\n */\n    void\nfuncdepth_restore(int depth)\n{\n    funcdepth = depth;\n}\n\n/*\n * Call a user function.\n */\n    static void\ncall_user_func(\n    ufunc_T\t*fp,\t\t// pointer to function\n    int\t\targcount,\t// nr of args\n    typval_T\t*argvars,\t// arguments\n    typval_T\t*rettv,\t\t// return value\n    funcexe_T\t*funcexe,\t// context\n    dict_T\t*selfdict)\t// Dictionary for \"self\"\n{\n    sctx_T\tsave_current_sctx;\n    int\t\tusing_sandbox = FALSE;\n    funccall_T\t*fc;\n    int\t\tsave_did_emsg;\n    int\t\tdefault_arg_err = FALSE;\n    dictitem_T\t*v;\n    int\t\tfixvar_idx = 0;\t// index in fixvar[]\n    int\t\ti;\n    int\t\tai;\n    int\t\tislambda = FALSE;\n    char_u\tnumbuf[NUMBUFLEN];\n    char_u\t*name;\n    typval_T\t*tv_to_free[MAX_FUNC_ARGS];\n    int\t\ttv_to_free_len = 0;\n#ifdef FEAT_PROFILE\n    profinfo_T\tprofile_info;\n#endif\n    ESTACK_CHECK_DECLARATION\n\n#ifdef FEAT_PROFILE\n    CLEAR_FIELD(profile_info);\n#endif\n\n    // If depth of calling is getting too high, don't execute the function.\n    if (funcdepth_increment() == FAIL)\n    {\n\trettv->v_type = VAR_NUMBER;\n\trettv->vval.v_number = -1;\n\treturn;\n    }\n\n    line_breakcheck();\t\t// check for CTRL-C hit\n\n    fc = ALLOC_CLEAR_ONE(funccall_T);\n    if (fc == NULL)\n\treturn;\n    fc->caller = current_funccal;\n    current_funccal = fc;\n    fc->func = fp;\n    fc->rettv = rettv;\n    fc->level = ex_nesting_level;\n    // Check if this function has a breakpoint.\n    fc->breakpoint = dbg_find_breakpoint(FALSE, fp->uf_name, (linenr_T)0);\n    fc->dbg_tick = debug_tick;\n    // Set up fields for closure.\n    ga_init2(&fc->fc_funcs, sizeof(ufunc_T *), 1);\n    func_ptr_ref(fp);\n\n    if (fp->uf_def_status != UF_NOT_COMPILED)\n    {\n#ifdef FEAT_PROFILE\n\tufunc_T *caller = fc->caller == NULL ? NULL : fc->caller->func;\n#endif\n\t// Execute the function, possibly compiling it first.\n#ifdef FEAT_PROFILE\n\tif (do_profiling == PROF_YES)\n\t    profile_may_start_func(&profile_info, fp, caller);\n#endif\n\tcall_def_function(fp, argcount, argvars, funcexe->fe_partial, rettv);\n\tfuncdepth_decrement();\n#ifdef FEAT_PROFILE\n\tif (do_profiling == PROF_YES && (fp->uf_profiling\n\t\t\t\t  || (caller != NULL && caller->uf_profiling)))\n\t    profile_may_end_func(&profile_info, fp, caller);\n#endif\n\tcurrent_funccal = fc->caller;\n\tfree_funccal(fc);\n\treturn;\n    }\n\n    islambda = fp->uf_flags & FC_LAMBDA;\n\n    /*\n     * Note about using fc->fixvar[]: This is an array of FIXVAR_CNT variables\n     * with names up to VAR_SHORT_LEN long.  This avoids having to alloc/free\n     * each argument variable and saves a lot of time.\n     */\n    /*\n     * Init l: variables.\n     */\n    init_var_dict(&fc->l_vars, &fc->l_vars_var, VAR_DEF_SCOPE);\n    if (selfdict != NULL)\n    {\n\t// Set l:self to \"selfdict\".  Use \"name\" to avoid a warning from\n\t// some compiler that checks the destination size.\n\tv = &fc->fixvar[fixvar_idx++].var;\n\tname = v->di_key;\n\tSTRCPY(name, \"self\");\n\tv->di_flags = DI_FLAGS_RO | DI_FLAGS_FIX;\n\thash_add(&fc->l_vars.dv_hashtab, DI2HIKEY(v));\n\tv->di_tv.v_type = VAR_DICT;\n\tv->di_tv.v_lock = 0;\n\tv->di_tv.vval.v_dict = selfdict;\n\t++selfdict->dv_refcount;\n    }\n\n    /*\n     * Init a: variables, unless none found (in lambda).\n     * Set a:0 to \"argcount\" less number of named arguments, if >= 0.\n     * Set a:000 to a list with room for the \"...\" arguments.\n     */\n    init_var_dict(&fc->l_avars, &fc->l_avars_var, VAR_SCOPE);\n    if ((fp->uf_flags & FC_NOARGS) == 0)\n\tadd_nr_var(&fc->l_avars, &fc->fixvar[fixvar_idx++].var, \"0\",\n\t\t\t\t(varnumber_T)(argcount >= fp->uf_args.ga_len\n\t\t\t\t    ? argcount - fp->uf_args.ga_len : 0));\n    fc->l_avars.dv_lock = VAR_FIXED;\n    if ((fp->uf_flags & FC_NOARGS) == 0)\n    {\n\t// Use \"name\" to avoid a warning from some compiler that checks the\n\t// destination size.\n\tv = &fc->fixvar[fixvar_idx++].var;\n\tname = v->di_key;\n\tSTRCPY(name, \"000\");\n\tv->di_flags = DI_FLAGS_RO | DI_FLAGS_FIX;\n\thash_add(&fc->l_avars.dv_hashtab, DI2HIKEY(v));\n\tv->di_tv.v_type = VAR_LIST;\n\tv->di_tv.v_lock = VAR_FIXED;\n\tv->di_tv.vval.v_list = &fc->l_varlist;\n    }\n    CLEAR_FIELD(fc->l_varlist);\n    fc->l_varlist.lv_refcount = DO_NOT_FREE_CNT;\n    fc->l_varlist.lv_lock = VAR_FIXED;\n\n    /*\n     * Set a:firstline to \"firstline\" and a:lastline to \"lastline\".\n     * Set a:name to named arguments.\n     * Set a:N to the \"...\" arguments.\n     * Skipped when no a: variables used (in lambda).\n     */\n    if ((fp->uf_flags & FC_NOARGS) == 0)\n    {\n\tadd_nr_var(&fc->l_avars, &fc->fixvar[fixvar_idx++].var, \"firstline\",\n\t\t\t\t\t   (varnumber_T)funcexe->fe_firstline);\n\tadd_nr_var(&fc->l_avars, &fc->fixvar[fixvar_idx++].var, \"lastline\",\n\t\t\t\t\t    (varnumber_T)funcexe->fe_lastline);\n    }\n    for (i = 0; i < argcount || i < fp->uf_args.ga_len; ++i)\n    {\n\tint\t    addlocal = FALSE;\n\ttypval_T    def_rettv;\n\tint\t    isdefault = FALSE;\n\n\tai = i - fp->uf_args.ga_len;\n\tif (ai < 0)\n\t{\n\t    // named argument a:name\n\t    name = FUNCARG(fp, i);\n\t    if (islambda)\n\t\taddlocal = TRUE;\n\n\t    // evaluate named argument default expression\n\t    isdefault = ai + fp->uf_def_args.ga_len >= 0\n\t\t       && (i >= argcount || (argvars[i].v_type == VAR_SPECIAL\n\t\t\t\t   && argvars[i].vval.v_number == VVAL_NONE));\n\t    if (isdefault)\n\t    {\n\t\tchar_u\t    *default_expr = NULL;\n\n\t\tdef_rettv.v_type = VAR_NUMBER;\n\t\tdef_rettv.vval.v_number = -1;\n\n\t\tdefault_expr = ((char_u **)(fp->uf_def_args.ga_data))\n\t\t\t\t\t\t [ai + fp->uf_def_args.ga_len];\n\t\tif (eval1(&default_expr, &def_rettv, &EVALARG_EVALUATE) == FAIL)\n\t\t{\n\t\t    default_arg_err = 1;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\telse\n\t{\n\t    if ((fp->uf_flags & FC_NOARGS) != 0)\n\t\t// Bail out if no a: arguments used (in lambda).\n\t\tbreak;\n\n\t    // \"...\" argument a:1, a:2, etc.\n\t    sprintf((char *)numbuf, \"%d\", ai + 1);\n\t    name = numbuf;\n\t}\n\tif (fixvar_idx < FIXVAR_CNT && STRLEN(name) <= VAR_SHORT_LEN)\n\t{\n\t    v = &fc->fixvar[fixvar_idx++].var;\n\t    v->di_flags = DI_FLAGS_RO | DI_FLAGS_FIX;\n\t    STRCPY(v->di_key, name);\n\t}\n\telse\n\t{\n\t    v = dictitem_alloc(name);\n\t    if (v == NULL)\n\t\tbreak;\n\t    v->di_flags |= DI_FLAGS_RO | DI_FLAGS_FIX;\n\t}\n\n\t// Note: the values are copied directly to avoid alloc/free.\n\t// \"argvars\" must have VAR_FIXED for v_lock.\n\tv->di_tv = isdefault ? def_rettv : argvars[i];\n\tv->di_tv.v_lock = VAR_FIXED;\n\n\tif (isdefault)\n\t    // Need to free this later, no matter where it's stored.\n\t    tv_to_free[tv_to_free_len++] = &v->di_tv;\n\n\tif (addlocal)\n\t{\n\t    // Named arguments should be accessed without the \"a:\" prefix in\n\t    // lambda expressions.  Add to the l: dict.\n\t    copy_tv(&v->di_tv, &v->di_tv);\n\t    hash_add(&fc->l_vars.dv_hashtab, DI2HIKEY(v));\n\t}\n\telse\n\t    hash_add(&fc->l_avars.dv_hashtab, DI2HIKEY(v));\n\n\tif (ai >= 0 && ai < MAX_FUNC_ARGS)\n\t{\n\t    listitem_T *li = &fc->l_listitems[ai];\n\n\t    li->li_tv = argvars[i];\n\t    li->li_tv.v_lock = VAR_FIXED;\n\t    list_append(&fc->l_varlist, li);\n\t}\n    }\n\n    // Don't redraw while executing the function.\n    ++RedrawingDisabled;\n\n    if (fp->uf_flags & FC_SANDBOX)\n    {\n\tusing_sandbox = TRUE;\n\t++sandbox;\n    }\n\n    estack_push_ufunc(fp, 1);\n    ESTACK_CHECK_SETUP\n    if (p_verbose >= 12)\n    {\n\t++no_wait_return;\n\tverbose_enter_scroll();\n\n\tsmsg(_(\"calling %s\"), SOURCING_NAME);\n\tif (p_verbose >= 14)\n\t{\n\t    char_u\tbuf[MSG_BUF_LEN];\n\t    char_u\tnumbuf2[NUMBUFLEN];\n\t    char_u\t*tofree;\n\t    char_u\t*s;\n\n\t    msg_puts(\"(\");\n\t    for (i = 0; i < argcount; ++i)\n\t    {\n\t\tif (i > 0)\n\t\t    msg_puts(\", \");\n\t\tif (argvars[i].v_type == VAR_NUMBER)\n\t\t    msg_outnum((long)argvars[i].vval.v_number);\n\t\telse\n\t\t{\n\t\t    // Do not want errors such as E724 here.\n\t\t    ++emsg_off;\n\t\t    s = tv2string(&argvars[i], &tofree, numbuf2, 0);\n\t\t    --emsg_off;\n\t\t    if (s != NULL)\n\t\t    {\n\t\t\tif (vim_strsize(s) > MSG_BUF_CLEN)\n\t\t\t{\n\t\t\t    trunc_string(s, buf, MSG_BUF_CLEN, MSG_BUF_LEN);\n\t\t\t    s = buf;\n\t\t\t}\n\t\t\tmsg_puts((char *)s);\n\t\t\tvim_free(tofree);\n\t\t    }\n\t\t}\n\t    }\n\t    msg_puts(\")\");\n\t}\n\tmsg_puts(\"\\n\");   // don't overwrite this either\n\n\tverbose_leave_scroll();\n\t--no_wait_return;\n    }\n#ifdef FEAT_PROFILE\n    if (do_profiling == PROF_YES)\n\tprofile_may_start_func(&profile_info, fp,\n\t\t\t\t fc->caller == NULL ? NULL : fc->caller->func);\n#endif\n\n    save_current_sctx = current_sctx;\n    current_sctx = fp->uf_script_ctx;\n    save_did_emsg = did_emsg;\n    did_emsg = FALSE;\n\n    if (default_arg_err && (fp->uf_flags & FC_ABORT))\n\tdid_emsg = TRUE;\n    else if (islambda)\n    {\n\tchar_u *p = *(char_u **)fp->uf_lines.ga_data + 7;\n\n\t// A Lambda always has the command \"return {expr}\".  It is much faster\n\t// to evaluate {expr} directly.\n\t++ex_nesting_level;\n\t(void)eval1(&p, rettv, &EVALARG_EVALUATE);\n\t--ex_nesting_level;\n    }\n    else\n\t// call do_cmdline() to execute the lines\n\tdo_cmdline(NULL, get_func_line, (void *)fc,\n\t\t\t\t     DOCMD_NOWAIT|DOCMD_VERBOSE|DOCMD_REPEAT);\n\n    --RedrawingDisabled;\n\n    // when the function was aborted because of an error, return -1\n    if ((did_emsg && (fp->uf_flags & FC_ABORT)) || rettv->v_type == VAR_UNKNOWN)\n    {\n\tclear_tv(rettv);\n\trettv->v_type = VAR_NUMBER;\n\trettv->vval.v_number = -1;\n    }\n\n#ifdef FEAT_PROFILE\n    if (do_profiling == PROF_YES)\n    {\n\tufunc_T *caller = fc->caller == NULL ? NULL : fc->caller->func;\n\n\tif (fp->uf_profiling || (caller != NULL && caller->uf_profiling))\n\t    profile_may_end_func(&profile_info, fp, caller);\n    }\n#endif\n\n    // when being verbose, mention the return value\n    if (p_verbose >= 12)\n    {\n\t++no_wait_return;\n\tverbose_enter_scroll();\n\n\tif (aborting())\n\t    smsg(_(\"%s aborted\"), SOURCING_NAME);\n\telse if (fc->rettv->v_type == VAR_NUMBER)\n\t    smsg(_(\"%s returning #%ld\"), SOURCING_NAME,\n\t\t\t\t\t       (long)fc->rettv->vval.v_number);\n\telse\n\t{\n\t    char_u\tbuf[MSG_BUF_LEN];\n\t    char_u\tnumbuf2[NUMBUFLEN];\n\t    char_u\t*tofree;\n\t    char_u\t*s;\n\n\t    // The value may be very long.  Skip the middle part, so that we\n\t    // have some idea how it starts and ends. smsg() would always\n\t    // truncate it at the end. Don't want errors such as E724 here.\n\t    ++emsg_off;\n\t    s = tv2string(fc->rettv, &tofree, numbuf2, 0);\n\t    --emsg_off;\n\t    if (s != NULL)\n\t    {\n\t\tif (vim_strsize(s) > MSG_BUF_CLEN)\n\t\t{\n\t\t    trunc_string(s, buf, MSG_BUF_CLEN, MSG_BUF_LEN);\n\t\t    s = buf;\n\t\t}\n\t\tsmsg(_(\"%s returning %s\"), SOURCING_NAME, s);\n\t\tvim_free(tofree);\n\t    }\n\t}\n\tmsg_puts(\"\\n\");   // don't overwrite this either\n\n\tverbose_leave_scroll();\n\t--no_wait_return;\n    }\n\n    ESTACK_CHECK_NOW\n    estack_pop();\n    current_sctx = save_current_sctx;\n#ifdef FEAT_PROFILE\n    if (do_profiling == PROF_YES)\n\tscript_prof_restore(&profile_info.pi_wait_start);\n#endif\n    if (using_sandbox)\n\t--sandbox;\n\n    if (p_verbose >= 12 && SOURCING_NAME != NULL)\n    {\n\t++no_wait_return;\n\tverbose_enter_scroll();\n\n\tsmsg(_(\"continuing in %s\"), SOURCING_NAME);\n\tmsg_puts(\"\\n\");   // don't overwrite this either\n\n\tverbose_leave_scroll();\n\t--no_wait_return;\n    }\n\n    did_emsg |= save_did_emsg;\n    funcdepth_decrement();\n    for (i = 0; i < tv_to_free_len; ++i)\n\tclear_tv(tv_to_free[i]);\n    cleanup_function_call(fc);\n}\n\n/*\n * Check the argument count for user function \"fp\".\n * Return FCERR_UNKNOWN if OK, FCERR_TOOFEW or FCERR_TOOMANY otherwise.\n */\n    int\ncheck_user_func_argcount(ufunc_T *fp, int argcount)\n{\n    int regular_args = fp->uf_args.ga_len;\n\n    if (argcount < regular_args - fp->uf_def_args.ga_len)\n\treturn FCERR_TOOFEW;\n    else if (!has_varargs(fp) && argcount > regular_args)\n\treturn FCERR_TOOMANY;\n    return FCERR_UNKNOWN;\n}\n\n/*\n * Call a user function after checking the arguments.\n */\n    int\ncall_user_func_check(\n\tufunc_T\t    *fp,\n\tint\t    argcount,\n\ttypval_T    *argvars,\n\ttypval_T    *rettv,\n\tfuncexe_T   *funcexe,\n\tdict_T\t    *selfdict)\n{\n    int error;\n\n    if (fp->uf_flags & FC_RANGE && funcexe->fe_doesrange != NULL)\n\t*funcexe->fe_doesrange = TRUE;\n    error = check_user_func_argcount(fp, argcount);\n    if (error != FCERR_UNKNOWN)\n\treturn error;\n    if ((fp->uf_flags & FC_DICT) && selfdict == NULL)\n\terror = FCERR_DICT;\n    else\n    {\n\tint\t\tdid_save_redo = FALSE;\n\tsave_redo_T\tsave_redo;\n\n\t/*\n\t * Call the user function.\n\t * Save and restore search patterns, script variables and\n\t * redo buffer.\n\t */\n\tsave_search_patterns();\n\tif (!ins_compl_active())\n\t{\n\t    saveRedobuff(&save_redo);\n\t    did_save_redo = TRUE;\n\t}\n\t++fp->uf_calls;\n\tcall_user_func(fp, argcount, argvars, rettv, funcexe,\n\t\t\t\t   (fp->uf_flags & FC_DICT) ? selfdict : NULL);\n\tif (--fp->uf_calls <= 0 && fp->uf_refcount <= 0)\n\t    // Function was unreferenced while being used, free it now.\n\t    func_clear_free(fp, FALSE);\n\tif (did_save_redo)\n\t    restoreRedobuff(&save_redo);\n\trestore_search_patterns();\n\terror = FCERR_NONE;\n    }\n    return error;\n}\n\nstatic funccal_entry_T *funccal_stack = NULL;\n\n/*\n * Save the current function call pointer, and set it to NULL.\n * Used when executing autocommands and for \":source\".\n */\n    void\nsave_funccal(funccal_entry_T *entry)\n{\n    entry->top_funccal = current_funccal;\n    entry->next = funccal_stack;\n    funccal_stack = entry;\n    current_funccal = NULL;\n}\n\n    void\nrestore_funccal(void)\n{\n    if (funccal_stack == NULL)\n\tiemsg(\"INTERNAL: restore_funccal()\");\n    else\n    {\n\tcurrent_funccal = funccal_stack->top_funccal;\n\tfunccal_stack = funccal_stack->next;\n    }\n}\n\n    funccall_T *\nget_current_funccal(void)\n{\n    return current_funccal;\n}\n\n/*\n * Mark all functions of script \"sid\" as deleted.\n */\n    void\ndelete_script_functions(int sid)\n{\n    hashitem_T\t*hi;\n    ufunc_T\t*fp;\n    long_u\ttodo = 1;\n    char_u\tbuf[30];\n    size_t\tlen;\n\n    buf[0] = K_SPECIAL;\n    buf[1] = KS_EXTRA;\n    buf[2] = (int)KE_SNR;\n    sprintf((char *)buf + 3, \"%d_\", sid);\n    len = STRLEN(buf);\n\n    while (todo > 0)\n    {\n\ttodo = func_hashtab.ht_used;\n\tfor (hi = func_hashtab.ht_array; todo > 0; ++hi)\n\t    if (!HASHITEM_EMPTY(hi))\n\t    {\n\t\tfp = HI2UF(hi);\n\t\tif (STRNCMP(fp->uf_name, buf, len) == 0)\n\t\t{\n\t\t    int changed = func_hashtab.ht_changed;\n\n\t\t    fp->uf_flags |= FC_DEAD;\n\n\t\t    if (fp->uf_calls > 0)\n\t\t    {\n\t\t\t// Function is executing, don't free it but do remove\n\t\t\t// it from the hashtable.\n\t\t\tif (func_remove(fp))\n\t\t\t    fp->uf_refcount--;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tfunc_clear(fp, TRUE);\n\t\t\t// When clearing a function another function can be\n\t\t\t// cleared as a side effect.  When that happens start\n\t\t\t// over.\n\t\t\tif (changed != func_hashtab.ht_changed)\n\t\t\t    break;\n\t\t    }\n\t\t}\n\t\t--todo;\n\t    }\n    }\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nfree_all_functions(void)\n{\n    hashitem_T\t*hi;\n    ufunc_T\t*fp;\n    long_u\tskipped = 0;\n    long_u\ttodo = 1;\n    int\t\tchanged;\n\n    // Clean up the current_funccal chain and the funccal stack.\n    while (current_funccal != NULL)\n    {\n\tclear_tv(current_funccal->rettv);\n\tcleanup_function_call(current_funccal);\n\tif (current_funccal == NULL && funccal_stack != NULL)\n\t    restore_funccal();\n    }\n\n    // First clear what the functions contain.  Since this may lower the\n    // reference count of a function, it may also free a function and change\n    // the hash table. Restart if that happens.\n    while (todo > 0)\n    {\n\ttodo = func_hashtab.ht_used;\n\tfor (hi = func_hashtab.ht_array; todo > 0; ++hi)\n\t    if (!HASHITEM_EMPTY(hi))\n\t    {\n\t\t// clear the def function index now\n\t\tfp = HI2UF(hi);\n\t\tfp->uf_flags &= ~FC_DEAD;\n\t\tfp->uf_def_status = UF_NOT_COMPILED;\n\n\t\t// Only free functions that are not refcounted, those are\n\t\t// supposed to be freed when no longer referenced.\n\t\tif (func_name_refcount(fp->uf_name))\n\t\t    ++skipped;\n\t\telse\n\t\t{\n\t\t    changed = func_hashtab.ht_changed;\n\t\t    func_clear(fp, TRUE);\n\t\t    if (changed != func_hashtab.ht_changed)\n\t\t    {\n\t\t\tskipped = 0;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\t--todo;\n\t    }\n    }\n\n    // Now actually free the functions.  Need to start all over every time,\n    // because func_free() may change the hash table.\n    skipped = 0;\n    while (func_hashtab.ht_used > skipped)\n    {\n\ttodo = func_hashtab.ht_used;\n\tfor (hi = func_hashtab.ht_array; todo > 0; ++hi)\n\t    if (!HASHITEM_EMPTY(hi))\n\t    {\n\t\t--todo;\n\t\t// Only free functions that are not refcounted, those are\n\t\t// supposed to be freed when no longer referenced.\n\t\tfp = HI2UF(hi);\n\t\tif (func_name_refcount(fp->uf_name))\n\t\t    ++skipped;\n\t\telse\n\t\t{\n\t\t    if (func_free(fp, FALSE) == OK)\n\t\t    {\n\t\t\tskipped = 0;\n\t\t\tbreak;\n\t\t    }\n\t\t    // did not actually free it\n\t\t    ++skipped;\n\t\t}\n\t    }\n    }\n    if (skipped == 0)\n\thash_clear(&func_hashtab);\n\n    free_def_functions();\n}\n#endif\n\n/*\n * Return TRUE if \"name\" looks like a builtin function name: starts with a\n * lower case letter and doesn't contain AUTOLOAD_CHAR or ':'.\n * \"len\" is the length of \"name\", or -1 for NUL terminated.\n */\n    int\nbuiltin_function(char_u *name, int len)\n{\n    char_u *p;\n\n    if (!ASCII_ISLOWER(name[0]) || name[1] == ':')\n\treturn FALSE;\n    p = vim_strchr(name, AUTOLOAD_CHAR);\n    return p == NULL || (len > 0 && p > name + len);\n}\n\n    int\nfunc_call(\n    char_u\t*name,\n    typval_T\t*args,\n    partial_T\t*partial,\n    dict_T\t*selfdict,\n    typval_T\t*rettv)\n{\n    list_T\t*l = args->vval.v_list;\n    listitem_T\t*item;\n    typval_T\targv[MAX_FUNC_ARGS + 1];\n    int\t\targc = 0;\n    int\t\tr = 0;\n\n    CHECK_LIST_MATERIALIZE(l);\n    FOR_ALL_LIST_ITEMS(l, item)\n    {\n\tif (argc == MAX_FUNC_ARGS - (partial == NULL ? 0 : partial->pt_argc))\n\t{\n\t    emsg(_(\"E699: Too many arguments\"));\n\t    break;\n\t}\n\t// Make a copy of each argument.  This is needed to be able to set\n\t// v_lock to VAR_FIXED in the copy without changing the original list.\n\tcopy_tv(&item->li_tv, &argv[argc++]);\n    }\n\n    if (item == NULL)\n    {\n\tfuncexe_T funcexe;\n\n\tCLEAR_FIELD(funcexe);\n\tfuncexe.fe_firstline = curwin->w_cursor.lnum;\n\tfuncexe.fe_lastline = curwin->w_cursor.lnum;\n\tfuncexe.fe_evaluate = TRUE;\n\tfuncexe.fe_partial = partial;\n\tfuncexe.fe_selfdict = selfdict;\n\tr = call_func(name, -1, rettv, argc, argv, &funcexe);\n    }\n\n    // Free the arguments.\n    while (argc > 0)\n\tclear_tv(&argv[--argc]);\n\n    return r;\n}\n\nstatic int callback_depth = 0;\n\n    int\nget_callback_depth(void)\n{\n    return callback_depth;\n}\n\n/*\n * Invoke call_func() with a callback.\n * Returns FAIL if the callback could not be called.\n */\n    int\ncall_callback(\n    callback_T\t*callback,\n    int\t\tlen,\t\t// length of \"name\" or -1 to use strlen()\n    typval_T\t*rettv,\t\t// return value goes here\n    int\t\targcount,\t// number of \"argvars\"\n    typval_T\t*argvars)\t// vars for arguments, must have \"argcount\"\n\t\t\t\t// PLUS ONE elements!\n{\n    funcexe_T\tfuncexe;\n    int\t\tret;\n\n    if (callback->cb_name == NULL || *callback->cb_name == NUL)\n\treturn FAIL;\n    CLEAR_FIELD(funcexe);\n    funcexe.fe_evaluate = TRUE;\n    funcexe.fe_partial = callback->cb_partial;\n    ++callback_depth;\n    ret = call_func(callback->cb_name, len, rettv, argcount, argvars, &funcexe);\n    --callback_depth;\n\n    // When a :def function was called that uses :try an error would be turned\n    // into an exception.  Need to give the error here.\n    if (need_rethrow && current_exception != NULL && trylevel == 0)\n    {\n\tneed_rethrow = FALSE;\n\thandle_did_throw();\n    }\n\n    return ret;\n}\n\n/*\n * call the 'callback' function and return the result as a number.\n * Returns -2 when calling the function fails.  Uses argv[0] to argv[argc - 1]\n * for the function arguments. argv[argc] should have type VAR_UNKNOWN.\n */\n    varnumber_T\ncall_callback_retnr(\n    callback_T\t*callback,\n    int\t\targcount,\t// number of \"argvars\"\n    typval_T\t*argvars)\t// vars for arguments, must have \"argcount\"\n\t\t\t\t// PLUS ONE elements!\n{\n    typval_T\trettv;\n    varnumber_T\tretval;\n\n    if (call_callback(callback, 0, &rettv, argcount, argvars) == FAIL)\n\treturn -2;\n\n    retval = tv_get_number_chk(&rettv, NULL);\n    clear_tv(&rettv);\n    return retval;\n}\n\n/*\n * Give an error message for the result of a function.\n * Nothing if \"error\" is FCERR_NONE.\n */\n    void\nuser_func_error(int error, char_u *name, funcexe_T *funcexe)\n{\n    switch (error)\n    {\n\tcase FCERR_UNKNOWN:\n\t\tif (funcexe->fe_found_var)\n\t\t    semsg(_(e_not_callable_type_str), name);\n\t\telse\n\t\t    emsg_funcname(e_unknown_function_str, name);\n\t\tbreak;\n\tcase FCERR_NOTMETHOD:\n\t\temsg_funcname(\n\t\t\tN_(\"E276: Cannot use function as a method: %s\"), name);\n\t\tbreak;\n\tcase FCERR_DELETED:\n\t\temsg_funcname(N_(e_func_deleted), name);\n\t\tbreak;\n\tcase FCERR_TOOMANY:\n\t\temsg_funcname((char *)e_too_many_arguments_for_function_str,\n\t\t\t\t\t\t\t\t\t name);\n\t\tbreak;\n\tcase FCERR_TOOFEW:\n\t\temsg_funcname((char *)e_not_enough_arguments_for_function_str,\n\t\t\t\t\t\t\t\t\t name);\n\t\tbreak;\n\tcase FCERR_SCRIPT:\n\t\temsg_funcname(\n\t\t    N_(e_using_sid_not_in_script_context_str), name);\n\t\tbreak;\n\tcase FCERR_DICT:\n\t\temsg_funcname(\n\t\t      N_(\"E725: Calling dict function without Dictionary: %s\"),\n\t\t\tname);\n\t\tbreak;\n    }\n}\n\n/*\n * Call a function with its resolved parameters\n *\n * Return FAIL when the function can't be called,  OK otherwise.\n * Also returns OK when an error was encountered while executing the function.\n */\n    int\ncall_func(\n    char_u\t*funcname,\t// name of the function\n    int\t\tlen,\t\t// length of \"name\" or -1 to use strlen()\n    typval_T\t*rettv,\t\t// return value goes here\n    int\t\targcount_in,\t// number of \"argvars\"\n    typval_T\t*argvars_in,\t// vars for arguments, must have \"argcount\"\n\t\t\t\t// PLUS ONE elements!\n    funcexe_T\t*funcexe)\t// more arguments\n{\n    int\t\tret = FAIL;\n    int\t\terror = FCERR_NONE;\n    int\t\ti;\n    ufunc_T\t*fp = NULL;\n    char_u\tfname_buf[FLEN_FIXED + 1];\n    char_u\t*tofree = NULL;\n    char_u\t*fname = NULL;\n    char_u\t*name = NULL;\n    int\t\targcount = argcount_in;\n    typval_T\t*argvars = argvars_in;\n    dict_T\t*selfdict = funcexe->fe_selfdict;\n    typval_T\targv[MAX_FUNC_ARGS + 1]; // used when \"partial\" or\n\t\t\t\t\t // \"funcexe->fe_basetv\" is not NULL\n    int\t\targv_clear = 0;\n    int\t\targv_base = 0;\n    partial_T\t*partial = funcexe->fe_partial;\n    type_T\tcheck_type;\n\n    // Initialize rettv so that it is safe for caller to invoke clear_tv(rettv)\n    // even when call_func() returns FAIL.\n    rettv->v_type = VAR_UNKNOWN;\n\n    if (partial != NULL)\n\tfp = partial->pt_func;\n    if (fp == NULL)\n    {\n\t// Make a copy of the name, if it comes from a funcref variable it\n\t// could be changed or deleted in the called function.\n\tname = len > 0 ? vim_strnsave(funcname, len) : vim_strsave(funcname);\n\tif (name == NULL)\n\t    return ret;\n\n\tfname = fname_trans_sid(name, fname_buf, &tofree, &error);\n    }\n\n    if (funcexe->fe_doesrange != NULL)\n\t*funcexe->fe_doesrange = FALSE;\n\n    if (partial != NULL)\n    {\n\t// When the function has a partial with a dict and there is a dict\n\t// argument, use the dict argument.  That is backwards compatible.\n\t// When the dict was bound explicitly use the one from the partial.\n\tif (partial->pt_dict != NULL && (selfdict == NULL || !partial->pt_auto))\n\t    selfdict = partial->pt_dict;\n\tif (error == FCERR_NONE && partial->pt_argc > 0)\n\t{\n\t    for (argv_clear = 0; argv_clear < partial->pt_argc; ++argv_clear)\n\t    {\n\t\tif (argv_clear + argcount_in >= MAX_FUNC_ARGS)\n\t\t{\n\t\t    error = FCERR_TOOMANY;\n\t\t    goto theend;\n\t\t}\n\t\tcopy_tv(&partial->pt_argv[argv_clear], &argv[argv_clear]);\n\t    }\n\t    for (i = 0; i < argcount_in; ++i)\n\t\targv[i + argv_clear] = argvars_in[i];\n\t    argvars = argv;\n\t    argcount = partial->pt_argc + argcount_in;\n\n\t    if (funcexe->fe_check_type != NULL\n\t\t\t\t  && funcexe->fe_check_type->tt_argcount != -1)\n\t    {\n\t\t// Now funcexe->fe_check_type is missing the added arguments,\n\t\t// make a copy of the type with the correction.\n\t\tcheck_type = *funcexe->fe_check_type;\n\t\tfuncexe->fe_check_type = &check_type;\n\t\tcheck_type.tt_argcount += partial->pt_argc;\n\t\tcheck_type.tt_min_argcount += partial->pt_argc;\n\t    }\n\t}\n    }\n\n    if (error == FCERR_NONE && funcexe->fe_check_type != NULL\n\t\t\t\t\t\t       && funcexe->fe_evaluate)\n    {\n\t// Check that the argument types are OK for the types of the funcref.\n\tif (check_argument_types(funcexe->fe_check_type, argvars, argcount,\n\t\t\t\t     (name != NULL) ? name : funcname) == FAIL)\n\t    error = FCERR_OTHER;\n    }\n\n    if (error == FCERR_NONE && funcexe->fe_evaluate)\n    {\n\tchar_u *rfname = fname;\n\tint\tis_global = FALSE;\n\n\t// Skip \"g:\" before a function name.\n\tif (fp == NULL && fname[0] == 'g' && fname[1] == ':')\n\t{\n\t    is_global = TRUE;\n\t    rfname = fname + 2;\n\t}\n\n\trettv->v_type = VAR_NUMBER;\t// default rettv is number zero\n\trettv->vval.v_number = 0;\n\terror = FCERR_UNKNOWN;\n\n\tif (fp != NULL || !builtin_function(rfname, -1))\n\t{\n\t    /*\n\t     * User defined function.\n\t     */\n\t    if (fp == NULL)\n\t\tfp = find_func(rfname, is_global, NULL);\n\n\t    // Trigger FuncUndefined event, may load the function.\n\t    if (fp == NULL\n\t\t    && apply_autocmds(EVENT_FUNCUNDEFINED,\n\t\t\t\t\t\t    rfname, rfname, TRUE, NULL)\n\t\t    && !aborting())\n\t    {\n\t\t// executed an autocommand, search for the function again\n\t\tfp = find_func(rfname, is_global, NULL);\n\t    }\n\t    // Try loading a package.\n\t    if (fp == NULL && script_autoload(rfname, TRUE) && !aborting())\n\t    {\n\t\t// loaded a package, search for the function again\n\t\tfp = find_func(rfname, is_global, NULL);\n\t    }\n\t    if (fp == NULL)\n\t    {\n\t\tchar_u *p = untrans_function_name(rfname);\n\n\t\t// If using Vim9 script try not local to the script.\n\t\t// Don't do this if the name starts with \"s:\".\n\t\tif (p != NULL && (funcname[0] != 's' || funcname[1] != ':'))\n\t\t    fp = find_func(p, is_global, NULL);\n\t    }\n\n\t    if (fp != NULL && (fp->uf_flags & FC_DELETED))\n\t\terror = FCERR_DELETED;\n#ifdef FEAT_LUA\n\t    else if (fp != NULL && (fp->uf_flags & FC_CFUNC))\n\t    {\n\t\tcfunc_T cb = fp->uf_cb;\n\n\t\terror = (*cb)(argcount, argvars, rettv, fp->uf_cb_state);\n\t    }\n#endif\n\t    else if (fp != NULL)\n\t    {\n\t\tif (funcexe->fe_argv_func != NULL)\n\t\t    // postponed filling in the arguments, do it now\n\t\t    argcount = funcexe->fe_argv_func(argcount, argvars,\n\t\t\t\t\t       argv_clear, fp->uf_args.ga_len);\n\n\t\tif (funcexe->fe_basetv != NULL)\n\t\t{\n\t\t    // Method call: base->Method()\n\t\t    mch_memmove(&argv[1], argvars, sizeof(typval_T) * argcount);\n\t\t    argv[0] = *funcexe->fe_basetv;\n\t\t    argcount++;\n\t\t    argvars = argv;\n\t\t    argv_base = 1;\n\t\t}\n\n\t\terror = call_user_func_check(fp, argcount, argvars, rettv,\n\t\t\t\t\t\t\t    funcexe, selfdict);\n\t    }\n\t}\n\telse if (funcexe->fe_basetv != NULL)\n\t{\n\t    /*\n\t     * expr->method(): Find the method name in the table, call its\n\t     * implementation with the base as one of the arguments.\n\t     */\n\t    error = call_internal_method(fname, argcount, argvars, rettv,\n\t\t\t\t\t\t\t   funcexe->fe_basetv);\n\t}\n\telse\n\t{\n\t    /*\n\t     * Find the function name in the table, call its implementation.\n\t     */\n\t    error = call_internal_func(fname, argcount, argvars, rettv);\n\t}\n\n\t/*\n\t * The function call (or \"FuncUndefined\" autocommand sequence) might\n\t * have been aborted by an error, an interrupt, or an explicitly thrown\n\t * exception that has not been caught so far.  This situation can be\n\t * tested for by calling aborting().  For an error in an internal\n\t * function or for the \"E132\" error in call_user_func(), however, the\n\t * throw point at which the \"force_abort\" flag (temporarily reset by\n\t * emsg()) is normally updated has not been reached yet. We need to\n\t * update that flag first to make aborting() reliable.\n\t */\n\tupdate_force_abort();\n    }\n    if (error == FCERR_NONE)\n\tret = OK;\n\ntheend:\n    /*\n     * Report an error unless the argument evaluation or function call has been\n     * cancelled due to an aborting error, an interrupt, or an exception.\n     */\n    if (!aborting())\n    {\n\tuser_func_error(error, (name != NULL) ? name : funcname, funcexe);\n    }\n\n    // clear the copies made from the partial\n    while (argv_clear > 0)\n\tclear_tv(&argv[--argv_clear + argv_base]);\n\n    vim_free(tofree);\n    vim_free(name);\n\n    return ret;\n}\n\n    char_u *\nprintable_func_name(ufunc_T *fp)\n{\n    return fp->uf_name_exp != NULL ? fp->uf_name_exp : fp->uf_name;\n}\n\n/*\n * List the head of the function: \"function name(arg1, arg2)\".\n */\n    static void\nlist_func_head(ufunc_T *fp, int indent)\n{\n    int\t\tj;\n\n    msg_start();\n    if (indent)\n\tmsg_puts(\"   \");\n    if (fp->uf_def_status != UF_NOT_COMPILED)\n\tmsg_puts(\"def \");\n    else\n\tmsg_puts(\"function \");\n    msg_puts((char *)printable_func_name(fp));\n    msg_putchar('(');\n    for (j = 0; j < fp->uf_args.ga_len; ++j)\n    {\n\tif (j)\n\t    msg_puts(\", \");\n\tmsg_puts((char *)FUNCARG(fp, j));\n\tif (fp->uf_arg_types != NULL)\n\t{\n\t    char *tofree;\n\n\t    msg_puts(\": \");\n\t    msg_puts(type_name(fp->uf_arg_types[j], &tofree));\n\t    vim_free(tofree);\n\t}\n\tif (j >= fp->uf_args.ga_len - fp->uf_def_args.ga_len)\n\t{\n\t    msg_puts(\" = \");\n\t    msg_puts(((char **)(fp->uf_def_args.ga_data))\n\t\t       [j - fp->uf_args.ga_len + fp->uf_def_args.ga_len]);\n\t}\n    }\n    if (fp->uf_varargs)\n    {\n\tif (j)\n\t    msg_puts(\", \");\n\tmsg_puts(\"...\");\n    }\n    if (fp->uf_va_name != NULL)\n    {\n\tif (j)\n\t    msg_puts(\", \");\n\tmsg_puts(\"...\");\n\tmsg_puts((char *)fp->uf_va_name);\n\tif (fp->uf_va_type != NULL)\n\t{\n\t    char *tofree;\n\n\t    msg_puts(\": \");\n\t    msg_puts(type_name(fp->uf_va_type, &tofree));\n\t    vim_free(tofree);\n\t}\n    }\n    msg_putchar(')');\n\n    if (fp->uf_def_status != UF_NOT_COMPILED)\n    {\n\tif (fp->uf_ret_type != &t_void)\n\t{\n\t    char *tofree;\n\n\t    msg_puts(\": \");\n\t    msg_puts(type_name(fp->uf_ret_type, &tofree));\n\t    vim_free(tofree);\n\t}\n    }\n    else if (fp->uf_flags & FC_ABORT)\n\tmsg_puts(\" abort\");\n    if (fp->uf_flags & FC_RANGE)\n\tmsg_puts(\" range\");\n    if (fp->uf_flags & FC_DICT)\n\tmsg_puts(\" dict\");\n    if (fp->uf_flags & FC_CLOSURE)\n\tmsg_puts(\" closure\");\n    msg_clr_eos();\n    if (p_verbose > 0)\n\tlast_set_msg(fp->uf_script_ctx);\n}\n\n/*\n * Get a function name, translating \"<SID>\" and \"<SNR>\".\n * Also handles a Funcref in a List or Dictionary.\n * Returns the function name in allocated memory, or NULL for failure.\n * Set \"*is_global\" to TRUE when the function must be global, unless\n * \"is_global\" is NULL.\n * flags:\n * TFN_INT:\t    internal function name OK\n * TFN_QUIET:\t    be quiet\n * TFN_NO_AUTOLOAD: do not use script autoloading\n * TFN_NO_DEREF:    do not dereference a Funcref\n * Advances \"pp\" to just after the function name (if no error).\n */\n    char_u *\ntrans_function_name(\n    char_u\t**pp,\n    int\t\t*is_global,\n    int\t\tskip,\t\t// only find the end, don't evaluate\n    int\t\tflags,\n    funcdict_T\t*fdp,\t\t// return: info about dictionary used\n    partial_T\t**partial,\t// return: partial of a FuncRef\n    type_T\t**type)\t\t// return: type of funcref if not NULL\n{\n    char_u\t*name = NULL;\n    char_u\t*start;\n    char_u\t*end;\n    int\t\tlead;\n    char_u\tsid_buf[20];\n    int\t\tlen;\n    int\t\textra = 0;\n    lval_T\tlv;\n    int\t\tvim9script;\n    static char *e_function_name = N_(\"E129: Function name required\");\n\n    if (fdp != NULL)\n\tCLEAR_POINTER(fdp);\n    start = *pp;\n\n    // Check for hard coded <SNR>: already translated function ID (from a user\n    // command).\n    if ((*pp)[0] == K_SPECIAL && (*pp)[1] == KS_EXTRA\n\t\t\t\t\t\t   && (*pp)[2] == (int)KE_SNR)\n    {\n\t*pp += 3;\n\tlen = get_id_len(pp) + 3;\n\treturn vim_strnsave(start, len);\n    }\n\n    // A name starting with \"<SID>\" or \"<SNR>\" is local to a script.  But\n    // don't skip over \"s:\", get_lval() needs it for \"s:dict.func\".\n    lead = eval_fname_script(start);\n    if (lead > 2)\n\tstart += lead;\n\n    // Note that TFN_ flags use the same values as GLV_ flags.\n    end = get_lval(start, NULL, &lv, FALSE, skip, flags | GLV_READ_ONLY,\n\t\t\t\t\t      lead > 2 ? 0 : FNE_CHECK_START);\n    if (end == start)\n    {\n\tif (!skip)\n\t    emsg(_(e_function_name));\n\tgoto theend;\n    }\n    if (end == NULL || (lv.ll_tv != NULL && (lead > 2 || lv.ll_range)))\n    {\n\t/*\n\t * Report an invalid expression in braces, unless the expression\n\t * evaluation has been cancelled due to an aborting error, an\n\t * interrupt, or an exception.\n\t */\n\tif (!aborting())\n\t{\n\t    if (end != NULL)\n\t\tsemsg(_(e_invarg2), start);\n\t}\n\telse\n\t    *pp = find_name_end(start, NULL, NULL, FNE_INCL_BR);\n\tgoto theend;\n    }\n\n    if (lv.ll_tv != NULL)\n    {\n\tif (fdp != NULL)\n\t{\n\t    fdp->fd_dict = lv.ll_dict;\n\t    fdp->fd_newkey = lv.ll_newkey;\n\t    lv.ll_newkey = NULL;\n\t    fdp->fd_di = lv.ll_di;\n\t}\n\tif (lv.ll_tv->v_type == VAR_FUNC && lv.ll_tv->vval.v_string != NULL)\n\t{\n\t    name = vim_strsave(lv.ll_tv->vval.v_string);\n\t    *pp = end;\n\t}\n\telse if (lv.ll_tv->v_type == VAR_PARTIAL\n\t\t\t\t\t  && lv.ll_tv->vval.v_partial != NULL)\n\t{\n\t    name = vim_strsave(partial_name(lv.ll_tv->vval.v_partial));\n\t    *pp = end;\n\t    if (partial != NULL)\n\t\t*partial = lv.ll_tv->vval.v_partial;\n\t}\n\telse\n\t{\n\t    if (!skip && !(flags & TFN_QUIET) && (fdp == NULL\n\t\t\t     || lv.ll_dict == NULL || fdp->fd_newkey == NULL))\n\t\temsg(_(e_funcref));\n\t    else\n\t\t*pp = end;\n\t    name = NULL;\n\t}\n\tgoto theend;\n    }\n\n    if (lv.ll_name == NULL)\n    {\n\t// Error found, but continue after the function name.\n\t*pp = end;\n\tgoto theend;\n    }\n\n    // Check if the name is a Funcref.  If so, use the value.\n    if (lv.ll_exp_name != NULL)\n    {\n\tlen = (int)STRLEN(lv.ll_exp_name);\n\tname = deref_func_name(lv.ll_exp_name, &len, partial, type,\n\t\t\t\t\t\tflags & TFN_NO_AUTOLOAD, NULL);\n\tif (name == lv.ll_exp_name)\n\t    name = NULL;\n    }\n    else if (!(flags & TFN_NO_DEREF))\n    {\n\tlen = (int)(end - *pp);\n\tname = deref_func_name(*pp, &len, partial, type,\n\t\t\t\t\t\tflags & TFN_NO_AUTOLOAD, NULL);\n\tif (name == *pp)\n\t    name = NULL;\n    }\n    if (name != NULL)\n    {\n\tname = vim_strsave(name);\n\t*pp = end;\n\tif (STRNCMP(name, \"<SNR>\", 5) == 0)\n\t{\n\t    // Change \"<SNR>\" to the byte sequence.\n\t    name[0] = K_SPECIAL;\n\t    name[1] = KS_EXTRA;\n\t    name[2] = (int)KE_SNR;\n\t    mch_memmove(name + 3, name + 5, STRLEN(name + 5) + 1);\n\t}\n\tgoto theend;\n    }\n\n    if (lv.ll_exp_name != NULL)\n    {\n\tlen = (int)STRLEN(lv.ll_exp_name);\n\tif (lead <= 2 && lv.ll_name == lv.ll_exp_name\n\t\t\t\t\t && STRNCMP(lv.ll_name, \"s:\", 2) == 0)\n\t{\n\t    // When there was \"s:\" already or the name expanded to get a\n\t    // leading \"s:\" then remove it.\n\t    lv.ll_name += 2;\n\t    len -= 2;\n\t    lead = 2;\n\t}\n    }\n    else\n    {\n\t// skip over \"s:\" and \"g:\"\n\tif (lead == 2 || (lv.ll_name[0] == 'g' && lv.ll_name[1] == ':'))\n\t{\n\t    if (is_global != NULL && lv.ll_name[0] == 'g')\n\t\t*is_global = TRUE;\n\t    lv.ll_name += 2;\n\t}\n\tlen = (int)(end - lv.ll_name);\n    }\n    if (len <= 0)\n    {\n\tif (!skip)\n\t    emsg(_(e_function_name));\n\tgoto theend;\n    }\n\n    // In Vim9 script a user function is script-local by default, unless it\n    // starts with a lower case character: dict.func().\n    vim9script = ASCII_ISUPPER(*start) && in_vim9script();\n    if (vim9script)\n    {\n\tchar_u *p;\n\n\t// SomeScript#func() is a global function.\n\tfor (p = start; *p != NUL && *p != '('; ++p)\n\t    if (*p == AUTOLOAD_CHAR)\n\t\tvim9script = FALSE;\n    }\n\n    /*\n     * Copy the function name to allocated memory.\n     * Accept <SID>name() inside a script, translate into <SNR>123_name().\n     * Accept <SNR>123_name() outside a script.\n     */\n    if (skip)\n\tlead = 0;\t// do nothing\n    else if (lead > 0 || vim9script)\n    {\n\tif (!vim9script)\n\t    lead = 3;\n\tif (vim9script || (lv.ll_exp_name != NULL\n\t\t\t\t\t     && eval_fname_sid(lv.ll_exp_name))\n\t\t\t\t\t\t       || eval_fname_sid(*pp))\n\t{\n\t    // It's script-local, \"s:\" or \"<SID>\"\n\t    if (current_sctx.sc_sid <= 0)\n\t    {\n\t\temsg(_(e_using_sid_not_in_script_context));\n\t\tgoto theend;\n\t    }\n\t    sprintf((char *)sid_buf, \"%ld_\", (long)current_sctx.sc_sid);\n\t    if (vim9script)\n\t\textra = 3 + (int)STRLEN(sid_buf);\n\t    else\n\t\tlead += (int)STRLEN(sid_buf);\n\t}\n    }\n    else if (!(flags & TFN_INT) && (builtin_function(lv.ll_name, len)\n\t\t\t\t   || (in_vim9script() && *lv.ll_name == '_')))\n    {\n\tsemsg(_(\"E128: Function name must start with a capital or \\\"s:\\\": %s\"),\n\t\t\t\t\t\t\t\t       start);\n\tgoto theend;\n    }\n    if (!skip && !(flags & TFN_QUIET) && !(flags & TFN_NO_DEREF))\n    {\n\tchar_u *cp = vim_strchr(lv.ll_name, ':');\n\n\tif (cp != NULL && cp < end)\n\t{\n\t    semsg(_(\"E884: Function name cannot contain a colon: %s\"), start);\n\t    goto theend;\n\t}\n    }\n\n    name = alloc(len + lead + extra + 1);\n    if (name != NULL)\n    {\n\tif (!skip && (lead > 0 || vim9script))\n\t{\n\t    name[0] = K_SPECIAL;\n\t    name[1] = KS_EXTRA;\n\t    name[2] = (int)KE_SNR;\n\t    if (vim9script || lead > 3)\t// If it's \"<SID>\"\n\t\tSTRCPY(name + 3, sid_buf);\n\t}\n\tmch_memmove(name + lead + extra, lv.ll_name, (size_t)len);\n\tname[lead + extra + len] = NUL;\n    }\n    *pp = end;\n\ntheend:\n    clear_lval(&lv);\n    return name;\n}\n\n/*\n * Assuming \"name\" is the result of trans_function_name() and it was prefixed\n * to use the script-local name, return the unmodified name (points into\n * \"name\").  Otherwise return NULL.\n * This can be used to first search for a script-local function and fall back\n * to the global function if not found.\n */\n    char_u *\nuntrans_function_name(char_u *name)\n{\n    char_u *p;\n\n    if (*name == K_SPECIAL && in_vim9script())\n    {\n\tp = vim_strchr(name, '_');\n\tif (p != NULL)\n\t    return p + 1;\n    }\n    return NULL;\n}\n\n/*\n * If the 'funcname' starts with \"s:\" or \"<SID>\", then expands it to the\n * current script ID and returns the expanded function name. The caller should\n * free the returned name. If not called from a script context or the function\n * name doesn't start with these prefixes, then returns NULL.\n * This doesn't check whether the script-local function exists or not.\n */\n    char_u *\nget_scriptlocal_funcname(char_u *funcname)\n{\n    char\tsid_buf[25];\n    int\t\toff;\n    char_u\t*newname;\n\n    if (funcname == NULL)\n\treturn NULL;\n\n    if (STRNCMP(funcname, \"s:\", 2) != 0\n\t\t&& STRNCMP(funcname, \"<SID>\", 5) != 0)\n\t// The function name is not a script-local function name\n\treturn NULL;\n\n    if (!SCRIPT_ID_VALID(current_sctx.sc_sid))\n    {\n\temsg(_(e_using_sid_not_in_script_context));\n\treturn NULL;\n    }\n    // Expand s: prefix into <SNR>nr_<name>\n    vim_snprintf(sid_buf, sizeof(sid_buf), \"<SNR>%ld_\",\n\t    (long)current_sctx.sc_sid);\n    off = *funcname == 's' ? 2 : 5;\n    newname = alloc(STRLEN(sid_buf) + STRLEN(funcname + off) + 1);\n    if (newname == NULL)\n\treturn NULL;\n    STRCPY(newname, sid_buf);\n    STRCAT(newname, funcname + off);\n\n    return newname;\n}\n\n/*\n * Call trans_function_name(), except that a lambda is returned as-is.\n * Returns the name in allocated memory.\n */\n    char_u *\nsave_function_name(\n\tchar_u\t    **name,\n\tint\t    *is_global,\n\tint\t    skip,\n\tint\t    flags,\n\tfuncdict_T  *fudi)\n{\n    char_u *p = *name;\n    char_u *saved;\n\n    if (STRNCMP(p, \"<lambda>\", 8) == 0)\n    {\n\tp += 8;\n\t(void)getdigits(&p);\n\tsaved = vim_strnsave(*name, p - *name);\n\tif (fudi != NULL)\n\t    CLEAR_POINTER(fudi);\n    }\n    else\n\tsaved = trans_function_name(&p, is_global, skip,\n\t\t\t\t\t\t      flags, fudi, NULL, NULL);\n    *name = p;\n    return saved;\n}\n\n/*\n * List functions.  When \"regmatch\" is NULL all of then.\n * Otherwise functions matching \"regmatch\".\n */\n    void\nlist_functions(regmatch_T *regmatch)\n{\n    int\t\tchanged = func_hashtab.ht_changed;\n    long_u\ttodo = func_hashtab.ht_used;\n    hashitem_T\t*hi;\n\n    for (hi = func_hashtab.ht_array; todo > 0 && !got_int; ++hi)\n    {\n\tif (!HASHITEM_EMPTY(hi))\n\t{\n\t    ufunc_T\t*fp = HI2UF(hi);\n\n\t    --todo;\n\t    if ((fp->uf_flags & FC_DEAD) == 0\n\t\t    && (regmatch == NULL\n\t\t\t? !message_filtered(fp->uf_name)\n\t\t\t    && !func_name_refcount(fp->uf_name)\n\t\t\t: !isdigit(*fp->uf_name)\n\t\t\t    && vim_regexec(regmatch, fp->uf_name, 0)))\n\t    {\n\t\tlist_func_head(fp, FALSE);\n\t\tif (changed != func_hashtab.ht_changed)\n\t\t{\n\t\t    emsg(_(\"E454: function list was modified\"));\n\t\t    return;\n\t\t}\n\t    }\n\t}\n    }\n}\n\n/*\n * \":function\" also supporting nested \":def\".\n * When \"name_arg\" is not NULL this is a nested function, using \"name_arg\" for\n * the function name.\n * Returns a pointer to the function or NULL if no function defined.\n */\n    ufunc_T *\ndefine_function(exarg_T *eap, char_u *name_arg)\n{\n    char_u\t*line_to_free = NULL;\n    int\t\tj;\n    int\t\tc;\n    int\t\tsaved_did_emsg;\n    char_u\t*name = name_arg;\n    int\t\tis_global = FALSE;\n    char_u\t*p;\n    char_u\t*arg;\n    char_u\t*whitep;\n    char_u\t*line_arg = NULL;\n    garray_T\tnewargs;\n    garray_T\targtypes;\n    garray_T\tdefault_args;\n    garray_T\tnewlines;\n    int\t\tvarargs = FALSE;\n    int\t\tflags = 0;\n    char_u\t*ret_type = NULL;\n    ufunc_T\t*fp = NULL;\n    int\t\tfp_allocated = FALSE;\n    int\t\tfree_fp = FALSE;\n    int\t\toverwrite = FALSE;\n    dictitem_T\t*v;\n    funcdict_T\tfudi;\n    static int\tfunc_nr = 0;\t    // number for nameless function\n    int\t\tparen;\n    hashitem_T\t*hi;\n    linenr_T\tsourcing_lnum_top;\n    int\t\tvim9script = in_vim9script();\n    imported_T\t*import = NULL;\n\n    /*\n     * \":function\" without argument: list functions.\n     */\n    if (ends_excmd2(eap->cmd, eap->arg))\n    {\n\tif (!eap->skip)\n\t    list_functions(NULL);\n\tset_nextcmd(eap, eap->arg);\n\treturn NULL;\n    }\n\n    /*\n     * \":function /pat\": list functions matching pattern.\n     */\n    if (*eap->arg == '/')\n    {\n\tp = skip_regexp(eap->arg + 1, '/', TRUE);\n\tif (!eap->skip)\n\t{\n\t    regmatch_T\tregmatch;\n\n\t    c = *p;\n\t    *p = NUL;\n\t    regmatch.regprog = vim_regcomp(eap->arg + 1, RE_MAGIC);\n\t    *p = c;\n\t    if (regmatch.regprog != NULL)\n\t    {\n\t\tregmatch.rm_ic = p_ic;\n\t\tlist_functions(&regmatch);\n\t\tvim_regfree(regmatch.regprog);\n\t    }\n\t}\n\tif (*p == '/')\n\t    ++p;\n\tset_nextcmd(eap, p);\n\treturn NULL;\n    }\n\n    ga_init(&newargs);\n    ga_init(&argtypes);\n    ga_init(&default_args);\n\n    /*\n     * Get the function name.  There are these situations:\n     * func\t    normal function name\n     *\t\t    \"name\" == func, \"fudi.fd_dict\" == NULL\n     * dict.func    new dictionary entry\n     *\t\t    \"name\" == NULL, \"fudi.fd_dict\" set,\n     *\t\t    \"fudi.fd_di\" == NULL, \"fudi.fd_newkey\" == func\n     * dict.func    existing dict entry with a Funcref\n     *\t\t    \"name\" == func, \"fudi.fd_dict\" set,\n     *\t\t    \"fudi.fd_di\" set, \"fudi.fd_newkey\" == NULL\n     * dict.func    existing dict entry that's not a Funcref\n     *\t\t    \"name\" == NULL, \"fudi.fd_dict\" set,\n     *\t\t    \"fudi.fd_di\" set, \"fudi.fd_newkey\" == NULL\n     * s:func\t    script-local function name\n     * g:func\t    global function name, same as \"func\"\n     */\n    p = eap->arg;\n    if (name_arg != NULL)\n    {\n\t// nested function, argument is (args).\n\tparen = TRUE;\n\tCLEAR_FIELD(fudi);\n    }\n    else\n    {\n\tname = save_function_name(&p, &is_global, eap->skip,\n\t\t\t\t\t\t       TFN_NO_AUTOLOAD, &fudi);\n\tparen = (vim_strchr(p, '(') != NULL);\n\tif (name == NULL && (fudi.fd_dict == NULL || !paren) && !eap->skip)\n\t{\n\t    /*\n\t     * Return on an invalid expression in braces, unless the expression\n\t     * evaluation has been cancelled due to an aborting error, an\n\t     * interrupt, or an exception.\n\t     */\n\t    if (!aborting())\n\t    {\n\t\tif (!eap->skip && fudi.fd_newkey != NULL)\n\t\t    semsg(_(e_dictkey), fudi.fd_newkey);\n\t\tvim_free(fudi.fd_newkey);\n\t\treturn NULL;\n\t    }\n\t    else\n\t\teap->skip = TRUE;\n\t}\n    }\n\n    // An error in a function call during evaluation of an expression in magic\n    // braces should not cause the function not to be defined.\n    saved_did_emsg = did_emsg;\n    did_emsg = FALSE;\n\n    /*\n     * \":function func\" with only function name: list function.\n     */\n    if (!paren)\n    {\n\tif (!ends_excmd(*skipwhite(p)))\n\t{\n\t    semsg(_(e_trailing_arg), p);\n\t    goto ret_free;\n\t}\n\tset_nextcmd(eap, p);\n\tif (eap->nextcmd != NULL)\n\t    *p = NUL;\n\tif (!eap->skip && !got_int)\n\t{\n\t    fp = find_func(name, is_global, NULL);\n\t    if (fp == NULL && ASCII_ISUPPER(*eap->arg))\n\t    {\n\t\tchar_u *up = untrans_function_name(name);\n\n\t\t// With Vim9 script the name was made script-local, if not\n\t\t// found try again with the original name.\n\t\tif (up != NULL)\n\t\t    fp = find_func(up, FALSE, NULL);\n\t    }\n\n\t    if (fp != NULL)\n\t    {\n\t\tlist_func_head(fp, TRUE);\n\t\tfor (j = 0; j < fp->uf_lines.ga_len && !got_int; ++j)\n\t\t{\n\t\t    if (FUNCLINE(fp, j) == NULL)\n\t\t\tcontinue;\n\t\t    msg_putchar('\\n');\n\t\t    msg_outnum((long)(j + 1));\n\t\t    if (j < 9)\n\t\t\tmsg_putchar(' ');\n\t\t    if (j < 99)\n\t\t\tmsg_putchar(' ');\n\t\t    msg_prt_line(FUNCLINE(fp, j), FALSE);\n\t\t    out_flush();\t// show a line at a time\n\t\t    ui_breakcheck();\n\t\t}\n\t\tif (!got_int)\n\t\t{\n\t\t    msg_putchar('\\n');\n\t\t    if (fp->uf_def_status != UF_NOT_COMPILED)\n\t\t\tmsg_puts(\"   enddef\");\n\t\t    else\n\t\t\tmsg_puts(\"   endfunction\");\n\t\t}\n\t    }\n\t    else\n\t\temsg_funcname(N_(\"E123: Undefined function: %s\"), eap->arg);\n\t}\n\tgoto ret_free;\n    }\n\n    /*\n     * \":function name(arg1, arg2)\" Define function.\n     */\n    p = skipwhite(p);\n    if (*p != '(')\n    {\n\tif (!eap->skip)\n\t{\n\t    semsg(_(\"E124: Missing '(': %s\"), eap->arg);\n\t    goto ret_free;\n\t}\n\t// attempt to continue by skipping some text\n\tif (vim_strchr(p, '(') != NULL)\n\t    p = vim_strchr(p, '(');\n    }\n\n    if ((vim9script || eap->cmdidx == CMD_def) && VIM_ISWHITE(p[-1]))\n    {\n\tsemsg(_(e_no_white_space_allowed_before_str_str), \"(\", p - 1);\n\tgoto ret_free;\n    }\n\n    // In Vim9 script only global functions can be redefined.\n    if (vim9script && eap->forceit && !is_global)\n    {\n\temsg(_(e_nobang));\n\tgoto ret_free;\n    }\n\n    ga_init2(&newlines, (int)sizeof(char_u *), 10);\n\n    if (!eap->skip && name_arg == NULL)\n    {\n\t// Check the name of the function.  Unless it's a dictionary function\n\t// (that we are overwriting).\n\tif (name != NULL)\n\t    arg = name;\n\telse\n\t    arg = fudi.fd_newkey;\n\tif (arg != NULL && (fudi.fd_di == NULL\n\t\t\t\t     || (fudi.fd_di->di_tv.v_type != VAR_FUNC\n\t\t\t\t && fudi.fd_di->di_tv.v_type != VAR_PARTIAL)))\n\t{\n\t    char_u  *name_base = arg;\n\t    int\t    i;\n\n\t    if (*arg == K_SPECIAL)\n\t    {\n\t\tname_base = vim_strchr(arg, '_');\n\t\tif (name_base == NULL)\n\t\t    name_base = arg + 3;\n\t\telse\n\t\t    ++name_base;\n\t    }\n\t    for (i = 0; name_base[i] != NUL && (i == 0\n\t\t\t\t\t? eval_isnamec1(name_base[i])\n\t\t\t\t\t: eval_isnamec(name_base[i])); ++i)\n\t\t;\n\t    if (name_base[i] != NUL)\n\t\temsg_funcname((char *)e_invarg2, arg);\n\n\t    // In Vim9 script a function cannot have the same name as a\n\t    // variable.\n\t    if (vim9script && *arg == K_SPECIAL\n\t\t&& eval_variable(name_base, (int)STRLEN(name_base), NULL, NULL,\n\t\t\t EVAL_VAR_NOAUTOLOAD + EVAL_VAR_IMPORT\n\t\t\t\t\t\t     + EVAL_VAR_NO_FUNC) == OK)\n\t    {\n\t\tsemsg(_(e_redefining_script_item_str), name_base);\n\t\tgoto ret_free;\n\t    }\n\t}\n\t// Disallow using the g: dict.\n\tif (fudi.fd_dict != NULL && fudi.fd_dict->dv_scope == VAR_DEF_SCOPE)\n\t{\n\t    emsg(_(\"E862: Cannot use g: here\"));\n\t    goto ret_free;\n\t}\n    }\n\n    // This may get more lines and make the pointers into the first line\n    // invalid.\n    ++p;\n    if (get_function_args(&p, ')', &newargs,\n\t\t\teap->cmdidx == CMD_def ? &argtypes : NULL, FALSE,\n\t\t\t NULL, &varargs, &default_args, eap->skip,\n\t\t\t eap, &line_to_free) == FAIL)\n\tgoto errret_2;\n    whitep = p;\n\n    if (eap->cmdidx == CMD_def)\n    {\n\t// find the return type: :def Func(): type\n\tif (*skipwhite(p) == ':')\n\t{\n\t    if (*p != ':')\n\t    {\n\t\tsemsg(_(e_no_white_space_allowed_before_colon_str), p);\n\t\tp = skipwhite(p);\n\t    }\n\t    else if (!IS_WHITE_OR_NUL(p[1]))\n\t\tsemsg(_(e_white_space_required_after_str_str), \":\", p);\n\t    ret_type = skipwhite(p + 1);\n\t    p = skip_type(ret_type, FALSE);\n\t    if (p > ret_type)\n\t    {\n\t\tret_type = vim_strnsave(ret_type, p - ret_type);\n\t\twhitep = p;\n\t\tp = skipwhite(p);\n\t    }\n\t    else\n\t    {\n\t\tsemsg(_(e_expected_type_str), ret_type);\n\t\tret_type = NULL;\n\t    }\n\t}\n\tp = skipwhite(p);\n    }\n    else\n\t// find extra arguments \"range\", \"dict\", \"abort\" and \"closure\"\n\tfor (;;)\n\t{\n\t    whitep = p;\n\t    p = skipwhite(p);\n\t    if (STRNCMP(p, \"range\", 5) == 0)\n\t    {\n\t\tflags |= FC_RANGE;\n\t\tp += 5;\n\t    }\n\t    else if (STRNCMP(p, \"dict\", 4) == 0)\n\t    {\n\t\tflags |= FC_DICT;\n\t\tp += 4;\n\t    }\n\t    else if (STRNCMP(p, \"abort\", 5) == 0)\n\t    {\n\t\tflags |= FC_ABORT;\n\t\tp += 5;\n\t    }\n\t    else if (STRNCMP(p, \"closure\", 7) == 0)\n\t    {\n\t\tflags |= FC_CLOSURE;\n\t\tp += 7;\n\t\tif (current_funccal == NULL)\n\t\t{\n\t\t    emsg_funcname(N_(\"E932: Closure function should not be at top level: %s\"),\n\t\t\t    name == NULL ? (char_u *)\"\" : name);\n\t\t    goto erret;\n\t\t}\n\t    }\n\t    else\n\t\tbreak;\n\t}\n\n    // When there is a line break use what follows for the function body.\n    // Makes 'exe \"func Test()\\n...\\nendfunc\"' work.\n    if (*p == '\\n')\n\tline_arg = p + 1;\n    else if (*p != NUL\n\t    && !(*p == '\"' && (!vim9script || eap->cmdidx == CMD_function)\n\t\t\t\t\t\t     && eap->cmdidx != CMD_def)\n\t    && !(VIM_ISWHITE(*whitep) && *p == '#'\n\t\t\t\t     && (vim9script || eap->cmdidx == CMD_def))\n\t    && !eap->skip\n\t    && !did_emsg)\n\tsemsg(_(e_trailing_arg), p);\n\n    /*\n     * Read the body of the function, until \"}\", \":endfunction\" or \":enddef\" is\n     * found.\n     */\n    if (KeyTyped)\n    {\n\t// Check if the function already exists, don't let the user type the\n\t// whole function before telling him it doesn't work!  For a script we\n\t// need to skip the body to be able to find what follows.\n\tif (!eap->skip && !eap->forceit)\n\t{\n\t    if (fudi.fd_dict != NULL && fudi.fd_newkey == NULL)\n\t\temsg(_(e_funcdict));\n\t    else if (name != NULL && find_func(name, is_global, NULL) != NULL)\n\t\temsg_funcname(e_funcexts, name);\n\t}\n\n\tif (!eap->skip && did_emsg)\n\t    goto erret;\n\n\tmsg_putchar('\\n');\t    // don't overwrite the function name\n\tcmdline_row = msg_row;\n    }\n\n    // Save the starting line number.\n    sourcing_lnum_top = SOURCING_LNUM;\n\n    // Do not define the function when getting the body fails and when\n    // skipping.\n    if (get_function_body(eap, &newlines, line_arg, &line_to_free) == FAIL\n\t    || eap->skip)\n\tgoto erret;\n\n    /*\n     * If there are no errors, add the function\n     */\n    if (fudi.fd_dict == NULL)\n    {\n\thashtab_T\t*ht;\n\n\tv = find_var(name, &ht, TRUE);\n\tif (v != NULL && v->di_tv.v_type == VAR_FUNC)\n\t{\n\t    emsg_funcname(N_(\"E707: Function name conflicts with variable: %s\"),\n\t\t\t\t\t\t\t\t\tname);\n\t    goto erret;\n\t}\n\n\tfp = find_func_even_dead(name, is_global, NULL);\n\tif (vim9script)\n\t{\n\t    char_u *uname = untrans_function_name(name);\n\n\t    import = find_imported(uname == NULL ? name : uname, 0, NULL);\n\t}\n\n\tif (fp != NULL || import != NULL)\n\t{\n\t    int dead = fp != NULL && (fp->uf_flags & FC_DEAD);\n\n\t    // Function can be replaced with \"function!\" and when sourcing the\n\t    // same script again, but only once.\n\t    // A name that is used by an import can not be overruled.\n\t    if (import != NULL\n\t\t    || (!dead && !eap->forceit\n\t\t\t&& (fp->uf_script_ctx.sc_sid != current_sctx.sc_sid\n\t\t\t  || fp->uf_script_ctx.sc_seq == current_sctx.sc_seq)))\n\t    {\n\t\tSOURCING_LNUM = sourcing_lnum_top;\n\t\tif (vim9script)\n\t\t    emsg_funcname(e_name_already_defined_str, name);\n\t\telse\n\t\t    emsg_funcname(e_funcexts, name);\n\t\tgoto erret;\n\t    }\n\t    if (fp->uf_calls > 0)\n\t    {\n\t\temsg_funcname(\n\t\t\tN_(\"E127: Cannot redefine function %s: It is in use\"),\n\t\t\t\t\t\t\t\t\tname);\n\t\tgoto erret;\n\t    }\n\t    if (fp->uf_refcount > 1)\n\t    {\n\t\t// This function is referenced somewhere, don't redefine it but\n\t\t// create a new one.\n\t\t--fp->uf_refcount;\n\t\tfp->uf_flags |= FC_REMOVED;\n\t\tfp = NULL;\n\t\toverwrite = TRUE;\n\t    }\n\t    else\n\t    {\n\t\tchar_u *exp_name = fp->uf_name_exp;\n\n\t\t// redefine existing function, keep the expanded name\n\t\tVIM_CLEAR(name);\n\t\tfp->uf_name_exp = NULL;\n\t\tfunc_clear_items(fp);\n\t\tfp->uf_name_exp = exp_name;\n\t\tfp->uf_flags &= ~FC_DEAD;\n#ifdef FEAT_PROFILE\n\t\tfp->uf_profiling = FALSE;\n\t\tfp->uf_prof_initialized = FALSE;\n#endif\n\t\tfp->uf_def_status = UF_NOT_COMPILED;\n\t    }\n\t}\n    }\n    else\n    {\n\tchar\tnumbuf[20];\n\n\tfp = NULL;\n\tif (fudi.fd_newkey == NULL && !eap->forceit)\n\t{\n\t    emsg(_(e_funcdict));\n\t    goto erret;\n\t}\n\tif (fudi.fd_di == NULL)\n\t{\n\t    // Can't add a function to a locked dictionary\n\t    if (value_check_lock(fudi.fd_dict->dv_lock, eap->arg, FALSE))\n\t\tgoto erret;\n\t}\n\t    // Can't change an existing function if it is locked\n\telse if (value_check_lock(fudi.fd_di->di_tv.v_lock, eap->arg, FALSE))\n\t    goto erret;\n\n\t// Give the function a sequential number.  Can only be used with a\n\t// Funcref!\n\tvim_free(name);\n\tsprintf(numbuf, \"%d\", ++func_nr);\n\tname = vim_strsave((char_u *)numbuf);\n\tif (name == NULL)\n\t    goto erret;\n    }\n\n    if (fp == NULL)\n    {\n\tif (fudi.fd_dict == NULL && vim_strchr(name, AUTOLOAD_CHAR) != NULL)\n\t{\n\t    int\t    slen, plen;\n\t    char_u  *scriptname;\n\n\t    // Check that the autoload name matches the script name.\n\t    j = FAIL;\n\t    if (SOURCING_NAME != NULL)\n\t    {\n\t\tscriptname = autoload_name(name);\n\t\tif (scriptname != NULL)\n\t\t{\n\t\t    p = vim_strchr(scriptname, '/');\n\t\t    plen = (int)STRLEN(p);\n\t\t    slen = (int)STRLEN(SOURCING_NAME);\n\t\t    if (slen > plen && fnamecmp(p,\n\t\t\t\t\t    SOURCING_NAME + slen - plen) == 0)\n\t\t\tj = OK;\n\t\t    vim_free(scriptname);\n\t\t}\n\t    }\n\t    if (j == FAIL)\n\t    {\n\t\tlinenr_T save_lnum = SOURCING_LNUM;\n\n\t\tSOURCING_LNUM = sourcing_lnum_top;\n\t\tsemsg(_(\"E746: Function name does not match script file name: %s\"), name);\n\t\tSOURCING_LNUM = save_lnum;\n\t\tgoto erret;\n\t    }\n\t}\n\n\tfp = alloc_clear(offsetof(ufunc_T, uf_name) + STRLEN(name) + 1);\n\tif (fp == NULL)\n\t    goto erret;\n\tfp_allocated = TRUE;\n\n\tif (fudi.fd_dict != NULL)\n\t{\n\t    if (fudi.fd_di == NULL)\n\t    {\n\t\t// add new dict entry\n\t\tfudi.fd_di = dictitem_alloc(fudi.fd_newkey);\n\t\tif (fudi.fd_di == NULL)\n\t\t{\n\t\t    vim_free(fp);\n\t\t    fp = NULL;\n\t\t    goto erret;\n\t\t}\n\t\tif (dict_add(fudi.fd_dict, fudi.fd_di) == FAIL)\n\t\t{\n\t\t    vim_free(fudi.fd_di);\n\t\t    vim_free(fp);\n\t\t    fp = NULL;\n\t\t    goto erret;\n\t\t}\n\t    }\n\t    else\n\t\t// overwrite existing dict entry\n\t\tclear_tv(&fudi.fd_di->di_tv);\n\t    fudi.fd_di->di_tv.v_type = VAR_FUNC;\n\t    fudi.fd_di->di_tv.vval.v_string = vim_strsave(name);\n\n\t    // behave like \"dict\" was used\n\t    flags |= FC_DICT;\n\t}\n    }\n    fp->uf_args = newargs;\n    fp->uf_def_args = default_args;\n    fp->uf_ret_type = &t_any;\n    fp->uf_func_type = &t_func_any;\n\n    if (eap->cmdidx == CMD_def)\n    {\n\tint\t    lnum_save = SOURCING_LNUM;\n\tcstack_T    *cstack = eap->cstack;\n\n\tfp->uf_def_status = UF_TO_BE_COMPILED;\n\n\t// error messages are for the first function line\n\tSOURCING_LNUM = sourcing_lnum_top;\n\n\t// The function may use script variables from the context.\n\tfunction_using_block_scopes(fp, cstack);\n\n\tif (parse_argument_types(fp, &argtypes, varargs) == FAIL)\n\t{\n\t    SOURCING_LNUM = lnum_save;\n\t    free_fp = fp_allocated;\n\t    goto erret;\n\t}\n\tvarargs = FALSE;\n\n\t// parse the return type, if any\n\tif (parse_return_type(fp, ret_type) == FAIL)\n\t{\n\t    SOURCING_LNUM = lnum_save;\n\t    free_fp = fp_allocated;\n\t    goto erret;\n\t}\n\tSOURCING_LNUM = lnum_save;\n    }\n    else\n\tfp->uf_def_status = UF_NOT_COMPILED;\n\n    if (fp_allocated)\n    {\n\t// insert the new function in the function list\n\tset_ufunc_name(fp, name);\n\tif (overwrite)\n\t{\n\t    hi = hash_find(&func_hashtab, name);\n\t    hi->hi_key = UF2HIKEY(fp);\n\t}\n\telse if (hash_add(&func_hashtab, UF2HIKEY(fp)) == FAIL)\n\t{\n\t    free_fp = TRUE;\n\t    goto erret;\n\t}\n\tfp->uf_refcount = 1;\n    }\n\n    fp->uf_lines = newlines;\n    newlines.ga_data = NULL;\n    if ((flags & FC_CLOSURE) != 0)\n    {\n\tif (register_closure(fp) == FAIL)\n\t    goto erret;\n    }\n    else\n\tfp->uf_scoped = NULL;\n\n#ifdef FEAT_PROFILE\n    if (prof_def_func())\n\tfunc_do_profile(fp);\n#endif\n    fp->uf_varargs = varargs;\n    if (sandbox)\n\tflags |= FC_SANDBOX;\n    if (vim9script && !ASCII_ISUPPER(*fp->uf_name))\n\tflags |= FC_VIM9;\n    fp->uf_flags = flags;\n    fp->uf_calls = 0;\n    fp->uf_cleared = FALSE;\n    fp->uf_script_ctx = current_sctx;\n    fp->uf_script_ctx_version = current_sctx.sc_version;\n    fp->uf_script_ctx.sc_lnum += sourcing_lnum_top;\n    if (is_export)\n    {\n\tfp->uf_flags |= FC_EXPORT;\n\t// let ex_export() know the export worked.\n\tis_export = FALSE;\n    }\n\n    if (eap->cmdidx == CMD_def)\n\tset_function_type(fp);\n    else if (fp->uf_script_ctx.sc_version == SCRIPT_VERSION_VIM9)\n\t// :func does not use Vim9 script syntax, even in a Vim9 script file\n\tfp->uf_script_ctx.sc_version = SCRIPT_VERSION_MAX;\n\n    goto ret_free;\n\nerret:\n    ga_clear_strings(&newargs);\n    ga_clear_strings(&default_args);\n    if (fp != NULL)\n    {\n\tga_init(&fp->uf_args);\n\tga_init(&fp->uf_def_args);\n    }\nerrret_2:\n    ga_clear_strings(&newlines);\n    if (fp != NULL)\n\tVIM_CLEAR(fp->uf_arg_types);\n    if (free_fp)\n    {\n\tvim_free(fp);\n\tfp = NULL;\n    }\nret_free:\n    ga_clear_strings(&argtypes);\n    vim_free(line_to_free);\n    vim_free(fudi.fd_newkey);\n    if (name != name_arg)\n\tvim_free(name);\n    vim_free(ret_type);\n    did_emsg |= saved_did_emsg;\n\n    return fp;\n}\n\n/*\n * \":function\"\n */\n    void\nex_function(exarg_T *eap)\n{\n    (void)define_function(eap, NULL);\n}\n\n/*\n * :defcompile - compile all :def functions in the current script that need to\n * be compiled.  Except dead functions.  Doesn't do profiling.\n */\n    void\nex_defcompile(exarg_T *eap UNUSED)\n{\n    long\ttodo = (long)func_hashtab.ht_used;\n    int\t\tchanged = func_hashtab.ht_changed;\n    hashitem_T\t*hi;\n    ufunc_T\t*ufunc;\n\n    for (hi = func_hashtab.ht_array; todo > 0 && !got_int; ++hi)\n    {\n\tif (!HASHITEM_EMPTY(hi))\n\t{\n\t    --todo;\n\t    ufunc = HI2UF(hi);\n\t    if (ufunc->uf_script_ctx.sc_sid == current_sctx.sc_sid\n\t\t    && ufunc->uf_def_status == UF_TO_BE_COMPILED\n\t\t    && (ufunc->uf_flags & FC_DEAD) == 0)\n\t    {\n\t\t(void)compile_def_function(ufunc, FALSE, CT_NONE, NULL);\n\n\t\tif (func_hashtab.ht_changed != changed)\n\t\t{\n\t\t    // a function has been added or removed, need to start over\n\t\t    todo = (long)func_hashtab.ht_used;\n\t\t    changed = func_hashtab.ht_changed;\n\t\t    hi = func_hashtab.ht_array;\n\t\t    --hi;\n\t\t}\n\t    }\n\t}\n    }\n}\n\n/*\n * Return 5 if \"p\" starts with \"<SID>\" or \"<SNR>\" (ignoring case).\n * Return 2 if \"p\" starts with \"s:\".\n * Return 0 otherwise.\n */\n    int\neval_fname_script(char_u *p)\n{\n    // Use MB_STRICMP() because in Turkish comparing the \"I\" may not work with\n    // the standard library function.\n    if (p[0] == '<' && (MB_STRNICMP(p + 1, \"SID>\", 4) == 0\n\t\t\t\t       || MB_STRNICMP(p + 1, \"SNR>\", 4) == 0))\n\treturn 5;\n    if (p[0] == 's' && p[1] == ':')\n\treturn 2;\n    return 0;\n}\n\n    int\ntranslated_function_exists(char_u *name, int is_global)\n{\n    if (builtin_function(name, -1))\n\treturn has_internal_func(name);\n    return find_func(name, is_global, NULL) != NULL;\n}\n\n/*\n * Return TRUE when \"ufunc\" has old-style \"...\" varargs\n * or named varargs \"...name: type\".\n */\n    int\nhas_varargs(ufunc_T *ufunc)\n{\n    return ufunc->uf_varargs || ufunc->uf_va_name != NULL;\n}\n\n/*\n * Return TRUE if a function \"name\" exists.\n * If \"no_defef\" is TRUE, do not dereference a Funcref.\n */\n    int\nfunction_exists(char_u *name, int no_deref)\n{\n    char_u  *nm = name;\n    char_u  *p;\n    int\t    n = FALSE;\n    int\t    flag;\n    int\t    is_global = FALSE;\n\n    flag = TFN_INT | TFN_QUIET | TFN_NO_AUTOLOAD;\n    if (no_deref)\n\tflag |= TFN_NO_DEREF;\n    p = trans_function_name(&nm, &is_global, FALSE, flag, NULL, NULL, NULL);\n    nm = skipwhite(nm);\n\n    // Only accept \"funcname\", \"funcname \", \"funcname (...\" and\n    // \"funcname(...\", not \"funcname!...\".\n    if (p != NULL && (*nm == NUL || *nm == '('))\n\tn = translated_function_exists(p, is_global);\n    vim_free(p);\n    return n;\n}\n\n#if defined(FEAT_PYTHON) || defined(FEAT_PYTHON3) || defined(PROTO)\n    char_u *\nget_expanded_name(char_u *name, int check)\n{\n    char_u\t*nm = name;\n    char_u\t*p;\n    int\t\tis_global = FALSE;\n\n    p = trans_function_name(&nm, &is_global, FALSE,\n\t\t\t\t\t  TFN_INT|TFN_QUIET, NULL, NULL, NULL);\n\n    if (p != NULL && *nm == NUL\n\t\t       && (!check || translated_function_exists(p, is_global)))\n\treturn p;\n\n    vim_free(p);\n    return NULL;\n}\n#endif\n\n/*\n * Function given to ExpandGeneric() to obtain the list of user defined\n * function names.\n */\n    char_u *\nget_user_func_name(expand_T *xp, int idx)\n{\n    static long_u\tdone;\n    static int\t\tchanged;\n    static hashitem_T\t*hi;\n    ufunc_T\t\t*fp;\n\n    if (idx == 0)\n    {\n\tdone = 0;\n\thi = func_hashtab.ht_array;\n\tchanged = func_hashtab.ht_changed;\n    }\n    if (changed == func_hashtab.ht_changed && done < func_hashtab.ht_used)\n    {\n\tif (done++ > 0)\n\t    ++hi;\n\twhile (HASHITEM_EMPTY(hi))\n\t    ++hi;\n\tfp = HI2UF(hi);\n\n\t// don't show dead, dict and lambda functions\n\tif ((fp->uf_flags & FC_DEAD) || (fp->uf_flags & FC_DICT)\n\t\t\t\t|| STRNCMP(fp->uf_name, \"<lambda>\", 8) == 0)\n\t    return (char_u *)\"\";\n\n\tif (STRLEN(fp->uf_name) + 4 >= IOSIZE)\n\t    return fp->uf_name;\t// prevents overflow\n\n\tcat_func_name(IObuff, fp);\n\tif (xp->xp_context != EXPAND_USER_FUNC\n\t\t\t\t       && xp->xp_context != EXPAND_DISASSEMBLE)\n\t{\n\t    STRCAT(IObuff, \"(\");\n\t    if (!has_varargs(fp) && fp->uf_args.ga_len == 0)\n\t\tSTRCAT(IObuff, \")\");\n\t}\n\treturn IObuff;\n    }\n    return NULL;\n}\n\n/*\n * \":delfunction {name}\"\n */\n    void\nex_delfunction(exarg_T *eap)\n{\n    ufunc_T\t*fp = NULL;\n    char_u\t*p;\n    char_u\t*name;\n    funcdict_T\tfudi;\n    int\t\tis_global = FALSE;\n\n    p = eap->arg;\n    name = trans_function_name(&p, &is_global, eap->skip, 0, &fudi,\n\t\t\t\t\t\t\t\t   NULL, NULL);\n    vim_free(fudi.fd_newkey);\n    if (name == NULL)\n    {\n\tif (fudi.fd_dict != NULL && !eap->skip)\n\t    emsg(_(e_funcref));\n\treturn;\n    }\n    if (!ends_excmd(*skipwhite(p)))\n    {\n\tvim_free(name);\n\tsemsg(_(e_trailing_arg), p);\n\treturn;\n    }\n    set_nextcmd(eap, p);\n    if (eap->nextcmd != NULL)\n\t*p = NUL;\n\n    if (numbered_function(name) && fudi.fd_dict == NULL)\n    {\n\tif (!eap->skip)\n\t    semsg(_(e_invarg2), eap->arg);\n\tvim_free(name);\n\treturn;\n    }\n    if (!eap->skip)\n\tfp = find_func(name, is_global, NULL);\n    vim_free(name);\n\n    if (!eap->skip)\n    {\n\tif (fp == NULL)\n\t{\n\t    if (!eap->forceit)\n\t\tsemsg(_(e_nofunc), eap->arg);\n\t    return;\n\t}\n\tif (fp->uf_calls > 0)\n\t{\n\t    semsg(_(\"E131: Cannot delete function %s: It is in use\"), eap->arg);\n\t    return;\n\t}\n\tif (fp->uf_flags & FC_VIM9)\n\t{\n\t    semsg(_(e_cannot_delete_vim9_script_function_str), eap->arg);\n\t    return;\n\t}\n\n\tif (fudi.fd_dict != NULL)\n\t{\n\t    // Delete the dict item that refers to the function, it will\n\t    // invoke func_unref() and possibly delete the function.\n\t    dictitem_remove(fudi.fd_dict, fudi.fd_di);\n\t}\n\telse\n\t{\n\t    // A normal function (not a numbered function or lambda) has a\n\t    // refcount of 1 for the entry in the hashtable.  When deleting\n\t    // it and the refcount is more than one, it should be kept.\n\t    // A numbered function and lambda should be kept if the refcount is\n\t    // one or more.\n\t    if (fp->uf_refcount > (func_name_refcount(fp->uf_name) ? 0 : 1))\n\t    {\n\t\t// Function is still referenced somewhere.  Don't free it but\n\t\t// do remove it from the hashtable.\n\t\tif (func_remove(fp))\n\t\t    fp->uf_refcount--;\n\t    }\n\t    else\n\t\tfunc_clear_free(fp, FALSE);\n\t}\n    }\n}\n\n/*\n * Unreference a Function: decrement the reference count and free it when it\n * becomes zero.\n */\n    void\nfunc_unref(char_u *name)\n{\n    ufunc_T *fp = NULL;\n\n    if (name == NULL || !func_name_refcount(name))\n\treturn;\n    fp = find_func(name, FALSE, NULL);\n    if (fp == NULL && numbered_function(name))\n    {\n#ifdef EXITFREE\n\tif (!entered_free_all_mem)\n#endif\n\t    internal_error(\"func_unref()\");\n    }\n    func_ptr_unref(fp);\n}\n\n/*\n * Unreference a Function: decrement the reference count and free it when it\n * becomes zero.\n * Also when it becomes one and uf_partial points to the function.\n */\n    void\nfunc_ptr_unref(ufunc_T *fp)\n{\n    if (fp != NULL && (--fp->uf_refcount <= 0\n\t\t|| (fp->uf_refcount == 1 && fp->uf_partial != NULL\n\t\t\t\t\t && fp->uf_partial->pt_refcount <= 1\n\t\t\t\t\t && fp->uf_partial->pt_func == fp)))\n    {\n\t// Only delete it when it's not being used.  Otherwise it's done\n\t// when \"uf_calls\" becomes zero.\n\tif (fp->uf_calls == 0)\n\t    func_clear_free(fp, FALSE);\n    }\n}\n\n/*\n * Count a reference to a Function.\n */\n    void\nfunc_ref(char_u *name)\n{\n    ufunc_T *fp;\n\n    if (name == NULL || !func_name_refcount(name))\n\treturn;\n    fp = find_func(name, FALSE, NULL);\n    if (fp != NULL)\n\t++fp->uf_refcount;\n    else if (numbered_function(name))\n\t// Only give an error for a numbered function.\n\t// Fail silently, when named or lambda function isn't found.\n\tinternal_error(\"func_ref()\");\n}\n\n/*\n * Count a reference to a Function.\n */\n    void\nfunc_ptr_ref(ufunc_T *fp)\n{\n    if (fp != NULL)\n\t++fp->uf_refcount;\n}\n\n/*\n * Return TRUE if items in \"fc\" do not have \"copyID\".  That means they are not\n * referenced from anywhere that is in use.\n */\n    static int\ncan_free_funccal(funccall_T *fc, int copyID)\n{\n    return (fc->l_varlist.lv_copyID != copyID\n\t    && fc->l_vars.dv_copyID != copyID\n\t    && fc->l_avars.dv_copyID != copyID\n\t    && fc->fc_copyID != copyID);\n}\n\n/*\n * \":return [expr]\"\n */\n    void\nex_return(exarg_T *eap)\n{\n    char_u\t*arg = eap->arg;\n    typval_T\trettv;\n    int\t\treturning = FALSE;\n    evalarg_T\tevalarg;\n\n    if (current_funccal == NULL)\n    {\n\temsg(_(\"E133: :return not inside a function\"));\n\treturn;\n    }\n\n    init_evalarg(&evalarg);\n    evalarg.eval_flags = eap->skip ? 0 : EVAL_EVALUATE;\n\n    if (eap->skip)\n\t++emsg_skip;\n\n    eap->nextcmd = NULL;\n    if ((*arg != NUL && *arg != '|' && *arg != '\\n')\n\t\t\t\t  && eval0(arg, &rettv, eap, &evalarg) != FAIL)\n    {\n\tif (!eap->skip)\n\t    returning = do_return(eap, FALSE, TRUE, &rettv);\n\telse\n\t    clear_tv(&rettv);\n    }\n    // It's safer to return also on error.\n    else if (!eap->skip)\n    {\n\t// In return statement, cause_abort should be force_abort.\n\tupdate_force_abort();\n\n\t/*\n\t * Return unless the expression evaluation has been cancelled due to an\n\t * aborting error, an interrupt, or an exception.\n\t */\n\tif (!aborting())\n\t    returning = do_return(eap, FALSE, TRUE, NULL);\n    }\n\n    // When skipping or the return gets pending, advance to the next command\n    // in this line (!returning).  Otherwise, ignore the rest of the line.\n    // Following lines will be ignored by get_func_line().\n    if (returning)\n\teap->nextcmd = NULL;\n    else if (eap->nextcmd == NULL)\t    // no argument\n\tset_nextcmd(eap, arg);\n\n    if (eap->skip)\n\t--emsg_skip;\n    clear_evalarg(&evalarg, eap);\n}\n\n/*\n * \":1,25call func(arg1, arg2)\"\tfunction call.\n */\n    void\nex_call(exarg_T *eap)\n{\n    char_u\t*arg = eap->arg;\n    char_u\t*startarg;\n    char_u\t*name;\n    char_u\t*tofree;\n    int\t\tlen;\n    typval_T\trettv;\n    linenr_T\tlnum;\n    int\t\tdoesrange;\n    int\t\tfailed = FALSE;\n    funcdict_T\tfudi;\n    partial_T\t*partial = NULL;\n    evalarg_T\tevalarg;\n    type_T\t*type = NULL;\n    int\t\tfound_var = FALSE;\n\n    fill_evalarg_from_eap(&evalarg, eap, eap->skip);\n    if (eap->skip)\n    {\n\t// trans_function_name() doesn't work well when skipping, use eval0()\n\t// instead to skip to any following command, e.g. for:\n\t//   :if 0 | call dict.foo().bar() | endif\n\t++emsg_skip;\n\tif (eval0(eap->arg, &rettv, eap, &evalarg) != FAIL)\n\t    clear_tv(&rettv);\n\t--emsg_skip;\n\tclear_evalarg(&evalarg, eap);\n\treturn;\n    }\n\n    tofree = trans_function_name(&arg, NULL, eap->skip, TFN_INT,\n\t\t\t      &fudi, &partial, in_vim9script() ? &type : NULL);\n    if (fudi.fd_newkey != NULL)\n    {\n\t// Still need to give an error message for missing key.\n\tsemsg(_(e_dictkey), fudi.fd_newkey);\n\tvim_free(fudi.fd_newkey);\n    }\n    if (tofree == NULL)\n\treturn;\n\n    // Increase refcount on dictionary, it could get deleted when evaluating\n    // the arguments.\n    if (fudi.fd_dict != NULL)\n\t++fudi.fd_dict->dv_refcount;\n\n    // If it is the name of a variable of type VAR_FUNC or VAR_PARTIAL use its\n    // contents.  For VAR_PARTIAL get its partial, unless we already have one\n    // from trans_function_name().\n    len = (int)STRLEN(tofree);\n    name = deref_func_name(tofree, &len, partial != NULL ? NULL : &partial,\n\t    in_vim9script() && type == NULL ? &type : NULL, FALSE, &found_var);\n\n    // Skip white space to allow \":call func ()\".  Not good, but required for\n    // backward compatibility.\n    startarg = skipwhite(arg);\n    if (*startarg != '(')\n    {\n\tsemsg(_(e_missing_parenthesis_str), eap->arg);\n\tgoto end;\n    }\n    if (in_vim9script() && startarg > arg)\n    {\n\tsemsg(_(e_no_white_space_allowed_before_str_str), \"(\", eap->arg);\n\tgoto end;\n    }\n\n    /*\n     * When skipping, evaluate the function once, to find the end of the\n     * arguments.\n     * When the function takes a range, this is discovered after the first\n     * call, and the loop is broken.\n     */\n    if (eap->skip)\n    {\n\t++emsg_skip;\n\tlnum = eap->line2;\t// do it once, also with an invalid range\n    }\n    else\n\tlnum = eap->line1;\n    for ( ; lnum <= eap->line2; ++lnum)\n    {\n\tfuncexe_T funcexe;\n\n\tif (!eap->skip && eap->addr_count > 0)\n\t{\n\t    if (lnum > curbuf->b_ml.ml_line_count)\n\t    {\n\t\t// If the function deleted lines or switched to another buffer\n\t\t// the line number may become invalid.\n\t\temsg(_(e_invalid_range));\n\t\tbreak;\n\t    }\n\t    curwin->w_cursor.lnum = lnum;\n\t    curwin->w_cursor.col = 0;\n\t    curwin->w_cursor.coladd = 0;\n\t}\n\targ = startarg;\n\n\tCLEAR_FIELD(funcexe);\n\tfuncexe.fe_firstline = eap->line1;\n\tfuncexe.fe_lastline = eap->line2;\n\tfuncexe.fe_doesrange = &doesrange;\n\tfuncexe.fe_evaluate = !eap->skip;\n\tfuncexe.fe_partial = partial;\n\tfuncexe.fe_selfdict = fudi.fd_dict;\n\tfuncexe.fe_check_type = type;\n\tfuncexe.fe_found_var = found_var;\n\trettv.v_type = VAR_UNKNOWN;\t// clear_tv() uses this\n\tif (get_func_tv(name, -1, &rettv, &arg, &evalarg, &funcexe) == FAIL)\n\t{\n\t    failed = TRUE;\n\t    break;\n\t}\n\tif (has_watchexpr())\n\t    dbg_check_breakpoint(eap);\n\n\t// Handle a function returning a Funcref, Dictionary or List.\n\tif (handle_subscript(&arg, &rettv,\n\t\t\t   eap->skip ? NULL : &EVALARG_EVALUATE, TRUE) == FAIL)\n\t{\n\t    failed = TRUE;\n\t    break;\n\t}\n\n\tclear_tv(&rettv);\n\tif (doesrange || eap->skip)\n\t    break;\n\n\t// Stop when immediately aborting on error, or when an interrupt\n\t// occurred or an exception was thrown but not caught.\n\t// get_func_tv() returned OK, so that the check for trailing\n\t// characters below is executed.\n\tif (aborting())\n\t    break;\n    }\n    if (eap->skip)\n\t--emsg_skip;\n    clear_evalarg(&evalarg, eap);\n\n    // When inside :try we need to check for following \"| catch\" or \"| endtry\".\n    // Not when there was an error, but do check if an exception was thrown.\n    if ((!aborting() || did_throw)\n\t\t\t\t  && (!failed || eap->cstack->cs_trylevel > 0))\n    {\n\t// Check for trailing illegal characters and a following command.\n\targ = skipwhite(arg);\n\tif (!ends_excmd2(eap->arg, arg))\n\t{\n\t    if (!failed && !aborting())\n\t    {\n\t\temsg_severe = TRUE;\n\t\tsemsg(_(e_trailing_arg), arg);\n\t    }\n\t}\n\telse\n\t    set_nextcmd(eap, arg);\n    }\n\nend:\n    dict_unref(fudi.fd_dict);\n    vim_free(tofree);\n}\n\n/*\n * Return from a function.  Possibly makes the return pending.  Also called\n * for a pending return at the \":endtry\" or after returning from an extra\n * do_cmdline().  \"reanimate\" is used in the latter case.  \"is_cmd\" is set\n * when called due to a \":return\" command.  \"rettv\" may point to a typval_T\n * with the return rettv.  Returns TRUE when the return can be carried out,\n * FALSE when the return gets pending.\n */\n    int\ndo_return(\n    exarg_T\t*eap,\n    int\t\treanimate,\n    int\t\tis_cmd,\n    void\t*rettv)\n{\n    int\t\tidx;\n    cstack_T\t*cstack = eap->cstack;\n\n    if (reanimate)\n\t// Undo the return.\n\tcurrent_funccal->returned = FALSE;\n\n    /*\n     * Cleanup (and inactivate) conditionals, but stop when a try conditional\n     * not in its finally clause (which then is to be executed next) is found.\n     * In this case, make the \":return\" pending for execution at the \":endtry\".\n     * Otherwise, return normally.\n     */\n    idx = cleanup_conditionals(eap->cstack, 0, TRUE);\n    if (idx >= 0)\n    {\n\tcstack->cs_pending[idx] = CSTP_RETURN;\n\n\tif (!is_cmd && !reanimate)\n\t    // A pending return again gets pending.  \"rettv\" points to an\n\t    // allocated variable with the rettv of the original \":return\"'s\n\t    // argument if present or is NULL else.\n\t    cstack->cs_rettv[idx] = rettv;\n\telse\n\t{\n\t    // When undoing a return in order to make it pending, get the stored\n\t    // return rettv.\n\t    if (reanimate)\n\t\trettv = current_funccal->rettv;\n\n\t    if (rettv != NULL)\n\t    {\n\t\t// Store the value of the pending return.\n\t\tif ((cstack->cs_rettv[idx] = alloc_tv()) != NULL)\n\t\t    *(typval_T *)cstack->cs_rettv[idx] = *(typval_T *)rettv;\n\t\telse\n\t\t    emsg(_(e_out_of_memory));\n\t    }\n\t    else\n\t\tcstack->cs_rettv[idx] = NULL;\n\n\t    if (reanimate)\n\t    {\n\t\t// The pending return value could be overwritten by a \":return\"\n\t\t// without argument in a finally clause; reset the default\n\t\t// return value.\n\t\tcurrent_funccal->rettv->v_type = VAR_NUMBER;\n\t\tcurrent_funccal->rettv->vval.v_number = 0;\n\t    }\n\t}\n\treport_make_pending(CSTP_RETURN, rettv);\n    }\n    else\n    {\n\tcurrent_funccal->returned = TRUE;\n\n\t// If the return is carried out now, store the return value.  For\n\t// a return immediately after reanimation, the value is already\n\t// there.\n\tif (!reanimate && rettv != NULL)\n\t{\n\t    clear_tv(current_funccal->rettv);\n\t    *current_funccal->rettv = *(typval_T *)rettv;\n\t    if (!is_cmd)\n\t\tvim_free(rettv);\n\t}\n    }\n\n    return idx < 0;\n}\n\n/*\n * Free the variable with a pending return value.\n */\n    void\ndiscard_pending_return(void *rettv)\n{\n    free_tv((typval_T *)rettv);\n}\n\n/*\n * Generate a return command for producing the value of \"rettv\".  The result\n * is an allocated string.  Used by report_pending() for verbose messages.\n */\n    char_u *\nget_return_cmd(void *rettv)\n{\n    char_u\t*s = NULL;\n    char_u\t*tofree = NULL;\n    char_u\tnumbuf[NUMBUFLEN];\n\n    if (rettv != NULL)\n\ts = echo_string((typval_T *)rettv, &tofree, numbuf, 0);\n    if (s == NULL)\n\ts = (char_u *)\"\";\n\n    STRCPY(IObuff, \":return \");\n    STRNCPY(IObuff + 8, s, IOSIZE - 8);\n    if (STRLEN(s) + 8 >= IOSIZE)\n\tSTRCPY(IObuff + IOSIZE - 4, \"...\");\n    vim_free(tofree);\n    return vim_strsave(IObuff);\n}\n\n/*\n * Get next function line.\n * Called by do_cmdline() to get the next line.\n * Returns allocated string, or NULL for end of function.\n */\n    char_u *\nget_func_line(\n    int\t    c UNUSED,\n    void    *cookie,\n    int\t    indent UNUSED,\n    getline_opt_T options UNUSED)\n{\n    funccall_T\t*fcp = (funccall_T *)cookie;\n    ufunc_T\t*fp = fcp->func;\n    char_u\t*retval;\n    garray_T\t*gap;  // growarray with function lines\n\n    // If breakpoints have been added/deleted need to check for it.\n    if (fcp->dbg_tick != debug_tick)\n    {\n\tfcp->breakpoint = dbg_find_breakpoint(FALSE, fp->uf_name,\n\t\t\t\t\t\t\t       SOURCING_LNUM);\n\tfcp->dbg_tick = debug_tick;\n    }\n#ifdef FEAT_PROFILE\n    if (do_profiling == PROF_YES)\n\tfunc_line_end(cookie);\n#endif\n\n    gap = &fp->uf_lines;\n    if (((fp->uf_flags & FC_ABORT) && did_emsg && !aborted_in_try())\n\t    || fcp->returned)\n\tretval = NULL;\n    else\n    {\n\t// Skip NULL lines (continuation lines).\n\twhile (fcp->linenr < gap->ga_len\n\t\t\t  && ((char_u **)(gap->ga_data))[fcp->linenr] == NULL)\n\t    ++fcp->linenr;\n\tif (fcp->linenr >= gap->ga_len)\n\t    retval = NULL;\n\telse\n\t{\n\t    retval = vim_strsave(((char_u **)(gap->ga_data))[fcp->linenr++]);\n\t    SOURCING_LNUM = fcp->linenr;\n#ifdef FEAT_PROFILE\n\t    if (do_profiling == PROF_YES)\n\t\tfunc_line_start(cookie, SOURCING_LNUM);\n#endif\n\t}\n    }\n\n    // Did we encounter a breakpoint?\n    if (fcp->breakpoint != 0 && fcp->breakpoint <= SOURCING_LNUM)\n    {\n\tdbg_breakpoint(fp->uf_name, SOURCING_LNUM);\n\t// Find next breakpoint.\n\tfcp->breakpoint = dbg_find_breakpoint(FALSE, fp->uf_name,\n\t\t\t\t\t\t\t       SOURCING_LNUM);\n\tfcp->dbg_tick = debug_tick;\n    }\n\n    return retval;\n}\n\n/*\n * Return TRUE if the currently active function should be ended, because a\n * return was encountered or an error occurred.  Used inside a \":while\".\n */\n    int\nfunc_has_ended(void *cookie)\n{\n    funccall_T  *fcp = (funccall_T *)cookie;\n\n    // Ignore the \"abort\" flag if the abortion behavior has been changed due to\n    // an error inside a try conditional.\n    return (((fcp->func->uf_flags & FC_ABORT) && did_emsg && !aborted_in_try())\n\t    || fcp->returned);\n}\n\n/*\n * return TRUE if cookie indicates a function which \"abort\"s on errors.\n */\n    int\nfunc_has_abort(\n    void    *cookie)\n{\n    return ((funccall_T *)cookie)->func->uf_flags & FC_ABORT;\n}\n\n\n/*\n * Turn \"dict.Func\" into a partial for \"Func\" bound to \"dict\".\n * Don't do this when \"Func\" is already a partial that was bound\n * explicitly (pt_auto is FALSE).\n * Changes \"rettv\" in-place.\n * Returns the updated \"selfdict_in\".\n */\n    dict_T *\nmake_partial(dict_T *selfdict_in, typval_T *rettv)\n{\n    char_u\t*fname;\n    char_u\t*tofree = NULL;\n    ufunc_T\t*fp;\n    char_u\tfname_buf[FLEN_FIXED + 1];\n    int\t\terror;\n    dict_T\t*selfdict = selfdict_in;\n\n    if (rettv->v_type == VAR_PARTIAL && rettv->vval.v_partial->pt_func != NULL)\n\tfp = rettv->vval.v_partial->pt_func;\n    else\n    {\n\tfname = rettv->v_type == VAR_FUNC ? rettv->vval.v_string\n\t\t\t\t\t      : rettv->vval.v_partial->pt_name;\n\t// Translate \"s:func\" to the stored function name.\n\tfname = fname_trans_sid(fname, fname_buf, &tofree, &error);\n\tfp = find_func(fname, FALSE, NULL);\n\tvim_free(tofree);\n    }\n\n    if (fp != NULL && (fp->uf_flags & FC_DICT))\n    {\n\tpartial_T\t*pt = ALLOC_CLEAR_ONE(partial_T);\n\n\tif (pt != NULL)\n\t{\n\t    pt->pt_refcount = 1;\n\t    pt->pt_dict = selfdict;\n\t    pt->pt_auto = TRUE;\n\t    selfdict = NULL;\n\t    if (rettv->v_type == VAR_FUNC)\n\t    {\n\t\t// Just a function: Take over the function name and use\n\t\t// selfdict.\n\t\tpt->pt_name = rettv->vval.v_string;\n\t    }\n\t    else\n\t    {\n\t\tpartial_T\t*ret_pt = rettv->vval.v_partial;\n\t\tint\t\ti;\n\n\t\t// Partial: copy the function name, use selfdict and copy\n\t\t// args.  Can't take over name or args, the partial might\n\t\t// be referenced elsewhere.\n\t\tif (ret_pt->pt_name != NULL)\n\t\t{\n\t\t    pt->pt_name = vim_strsave(ret_pt->pt_name);\n\t\t    func_ref(pt->pt_name);\n\t\t}\n\t\telse\n\t\t{\n\t\t    pt->pt_func = ret_pt->pt_func;\n\t\t    func_ptr_ref(pt->pt_func);\n\t\t}\n\t\tif (ret_pt->pt_argc > 0)\n\t\t{\n\t\t    pt->pt_argv = ALLOC_MULT(typval_T, ret_pt->pt_argc);\n\t\t    if (pt->pt_argv == NULL)\n\t\t\t// out of memory: drop the arguments\n\t\t\tpt->pt_argc = 0;\n\t\t    else\n\t\t    {\n\t\t\tpt->pt_argc = ret_pt->pt_argc;\n\t\t\tfor (i = 0; i < pt->pt_argc; i++)\n\t\t\t    copy_tv(&ret_pt->pt_argv[i], &pt->pt_argv[i]);\n\t\t    }\n\t\t}\n\t\tpartial_unref(ret_pt);\n\t    }\n\t    rettv->v_type = VAR_PARTIAL;\n\t    rettv->vval.v_partial = pt;\n\t}\n    }\n    return selfdict;\n}\n\n/*\n * Return the name of the executed function.\n */\n    char_u *\nfunc_name(void *cookie)\n{\n    return ((funccall_T *)cookie)->func->uf_name;\n}\n\n/*\n * Return the address holding the next breakpoint line for a funccall cookie.\n */\n    linenr_T *\nfunc_breakpoint(void *cookie)\n{\n    return &((funccall_T *)cookie)->breakpoint;\n}\n\n/*\n * Return the address holding the debug tick for a funccall cookie.\n */\n    int *\nfunc_dbg_tick(void *cookie)\n{\n    return &((funccall_T *)cookie)->dbg_tick;\n}\n\n/*\n * Return the nesting level for a funccall cookie.\n */\n    int\nfunc_level(void *cookie)\n{\n    return ((funccall_T *)cookie)->level;\n}\n\n/*\n * Return TRUE when a function was ended by a \":return\" command.\n */\n    int\ncurrent_func_returned(void)\n{\n    return current_funccal->returned;\n}\n\n    int\nfree_unref_funccal(int copyID, int testing)\n{\n    int\t\tdid_free = FALSE;\n    int\t\tdid_free_funccal = FALSE;\n    funccall_T\t*fc, **pfc;\n\n    for (pfc = &previous_funccal; *pfc != NULL; )\n    {\n\tif (can_free_funccal(*pfc, copyID))\n\t{\n\t    fc = *pfc;\n\t    *pfc = fc->caller;\n\t    free_funccal_contents(fc);\n\t    did_free = TRUE;\n\t    did_free_funccal = TRUE;\n\t}\n\telse\n\t    pfc = &(*pfc)->caller;\n    }\n    if (did_free_funccal)\n\t// When a funccal was freed some more items might be garbage\n\t// collected, so run again.\n\t(void)garbage_collect(testing);\n\n    return did_free;\n}\n\n/*\n * Get function call environment based on backtrace debug level\n */\n    static funccall_T *\nget_funccal(void)\n{\n    int\t\ti;\n    funccall_T\t*funccal;\n    funccall_T\t*temp_funccal;\n\n    funccal = current_funccal;\n    if (debug_backtrace_level > 0)\n    {\n\tfor (i = 0; i < debug_backtrace_level; i++)\n\t{\n\t    temp_funccal = funccal->caller;\n\t    if (temp_funccal)\n\t\tfunccal = temp_funccal;\n\t    else\n\t\t// backtrace level overflow. reset to max\n\t\tdebug_backtrace_level = i;\n\t}\n    }\n    return funccal;\n}\n\n/*\n * Return the hashtable used for local variables in the current funccal.\n * Return NULL if there is no current funccal.\n */\n    hashtab_T *\nget_funccal_local_ht()\n{\n    if (current_funccal == NULL || current_funccal->l_vars.dv_refcount == 0)\n\treturn NULL;\n    return &get_funccal()->l_vars.dv_hashtab;\n}\n\n/*\n * Return the l: scope variable.\n * Return NULL if there is no current funccal.\n */\n    dictitem_T *\nget_funccal_local_var()\n{\n    if (current_funccal == NULL || current_funccal->l_vars.dv_refcount == 0)\n\treturn NULL;\n    return &get_funccal()->l_vars_var;\n}\n\n/*\n * Return the hashtable used for argument in the current funccal.\n * Return NULL if there is no current funccal.\n */\n    hashtab_T *\nget_funccal_args_ht()\n{\n    if (current_funccal == NULL || current_funccal->l_vars.dv_refcount == 0)\n\treturn NULL;\n    return &get_funccal()->l_avars.dv_hashtab;\n}\n\n/*\n * Return the a: scope variable.\n * Return NULL if there is no current funccal.\n */\n    dictitem_T *\nget_funccal_args_var()\n{\n    if (current_funccal == NULL || current_funccal->l_vars.dv_refcount == 0)\n\treturn NULL;\n    return &get_funccal()->l_avars_var;\n}\n\n/*\n * List function variables, if there is a function.\n */\n    void\nlist_func_vars(int *first)\n{\n    if (current_funccal != NULL && current_funccal->l_vars.dv_refcount > 0)\n\tlist_hashtable_vars(&current_funccal->l_vars.dv_hashtab,\n\t\t\t\t\t\t\t   \"l:\", FALSE, first);\n}\n\n/*\n * If \"ht\" is the hashtable for local variables in the current funccal, return\n * the dict that contains it.\n * Otherwise return NULL.\n */\n    dict_T *\nget_current_funccal_dict(hashtab_T *ht)\n{\n    if (current_funccal != NULL\n\t    && ht == &current_funccal->l_vars.dv_hashtab)\n\treturn &current_funccal->l_vars;\n    return NULL;\n}\n\n/*\n * Search hashitem in parent scope.\n */\n    hashitem_T *\nfind_hi_in_scoped_ht(char_u *name, hashtab_T **pht)\n{\n    funccall_T\t*old_current_funccal = current_funccal;\n    hashtab_T\t*ht;\n    hashitem_T\t*hi = NULL;\n    char_u\t*varname;\n\n    if (current_funccal == NULL || current_funccal->func->uf_scoped == NULL)\n      return NULL;\n\n    // Search in parent scope, which can be referenced from a lambda.\n    current_funccal = current_funccal->func->uf_scoped;\n    while (current_funccal != NULL)\n    {\n\tht = find_var_ht(name, &varname);\n\tif (ht != NULL && *varname != NUL)\n\t{\n\t    hi = hash_find(ht, varname);\n\t    if (!HASHITEM_EMPTY(hi))\n\t    {\n\t\t*pht = ht;\n\t\tbreak;\n\t    }\n\t}\n\tif (current_funccal == current_funccal->func->uf_scoped)\n\t    break;\n\tcurrent_funccal = current_funccal->func->uf_scoped;\n    }\n    current_funccal = old_current_funccal;\n\n    return hi;\n}\n\n/*\n * Search variable in parent scope.\n */\n    dictitem_T *\nfind_var_in_scoped_ht(char_u *name, int no_autoload)\n{\n    dictitem_T\t*v = NULL;\n    funccall_T\t*old_current_funccal = current_funccal;\n    hashtab_T\t*ht;\n    char_u\t*varname;\n\n    if (current_funccal == NULL || current_funccal->func->uf_scoped == NULL)\n\treturn NULL;\n\n    // Search in parent scope which is possible to reference from lambda\n    current_funccal = current_funccal->func->uf_scoped;\n    while (current_funccal)\n    {\n\tht = find_var_ht(name, &varname);\n\tif (ht != NULL && *varname != NUL)\n\t{\n\t    v = find_var_in_ht(ht, *name, varname, no_autoload);\n\t    if (v != NULL)\n\t\tbreak;\n\t}\n\tif (current_funccal == current_funccal->func->uf_scoped)\n\t    break;\n\tcurrent_funccal = current_funccal->func->uf_scoped;\n    }\n    current_funccal = old_current_funccal;\n\n    return v;\n}\n\n/*\n * Set \"copyID + 1\" in previous_funccal and callers.\n */\n    int\nset_ref_in_previous_funccal(int copyID)\n{\n    funccall_T\t*fc;\n\n    for (fc = previous_funccal; fc != NULL; fc = fc->caller)\n    {\n\tfc->fc_copyID = copyID + 1;\n\tif (set_ref_in_ht(&fc->l_vars.dv_hashtab, copyID + 1, NULL)\n\t\t|| set_ref_in_ht(&fc->l_avars.dv_hashtab, copyID + 1, NULL)\n\t\t|| set_ref_in_list_items(&fc->l_varlist, copyID + 1, NULL))\n\t    return TRUE;\n    }\n    return FALSE;\n}\n\n    static int\nset_ref_in_funccal(funccall_T *fc, int copyID)\n{\n    if (fc->fc_copyID != copyID)\n    {\n\tfc->fc_copyID = copyID;\n\tif (set_ref_in_ht(&fc->l_vars.dv_hashtab, copyID, NULL)\n\t\t|| set_ref_in_ht(&fc->l_avars.dv_hashtab, copyID, NULL)\n\t\t|| set_ref_in_list_items(&fc->l_varlist, copyID, NULL)\n\t\t|| set_ref_in_func(NULL, fc->func, copyID))\n\t    return TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Set \"copyID\" in all local vars and arguments in the call stack.\n */\n    int\nset_ref_in_call_stack(int copyID)\n{\n    funccall_T\t\t*fc;\n    funccal_entry_T\t*entry;\n\n    for (fc = current_funccal; fc != NULL; fc = fc->caller)\n\tif (set_ref_in_funccal(fc, copyID))\n\t    return TRUE;\n\n    // Also go through the funccal_stack.\n    for (entry = funccal_stack; entry != NULL; entry = entry->next)\n\tfor (fc = entry->top_funccal; fc != NULL; fc = fc->caller)\n\t    if (set_ref_in_funccal(fc, copyID))\n\t\treturn TRUE;\n    return FALSE;\n}\n\n/*\n * Set \"copyID\" in all functions available by name.\n */\n    int\nset_ref_in_functions(int copyID)\n{\n    int\t\ttodo;\n    hashitem_T\t*hi = NULL;\n    ufunc_T\t*fp;\n\n    todo = (int)func_hashtab.ht_used;\n    for (hi = func_hashtab.ht_array; todo > 0 && !got_int; ++hi)\n    {\n\tif (!HASHITEM_EMPTY(hi))\n\t{\n\t    --todo;\n\t    fp = HI2UF(hi);\n\t    if (!func_name_refcount(fp->uf_name)\n\t\t\t\t\t  && set_ref_in_func(NULL, fp, copyID))\n\t\treturn TRUE;\n\t}\n    }\n    return FALSE;\n}\n\n/*\n * Set \"copyID\" in all function arguments.\n */\n    int\nset_ref_in_func_args(int copyID)\n{\n    int i;\n\n    for (i = 0; i < funcargs.ga_len; ++i)\n\tif (set_ref_in_item(((typval_T **)funcargs.ga_data)[i],\n\t\t\t\t\t\t\t  copyID, NULL, NULL))\n\t    return TRUE;\n    return FALSE;\n}\n\n/*\n * Mark all lists and dicts referenced through function \"name\" with \"copyID\".\n * Returns TRUE if setting references failed somehow.\n */\n    int\nset_ref_in_func(char_u *name, ufunc_T *fp_in, int copyID)\n{\n    ufunc_T\t*fp = fp_in;\n    funccall_T\t*fc;\n    int\t\terror = FCERR_NONE;\n    char_u\tfname_buf[FLEN_FIXED + 1];\n    char_u\t*tofree = NULL;\n    char_u\t*fname;\n    int\t\tabort = FALSE;\n\n    if (name == NULL && fp_in == NULL)\n\treturn FALSE;\n\n    if (fp_in == NULL)\n    {\n\tfname = fname_trans_sid(name, fname_buf, &tofree, &error);\n\tfp = find_func(fname, FALSE, NULL);\n    }\n    if (fp != NULL)\n    {\n\tfor (fc = fp->uf_scoped; fc != NULL; fc = fc->func->uf_scoped)\n\t    abort = abort || set_ref_in_funccal(fc, copyID);\n    }\n\n    vim_free(tofree);\n    return abort;\n}\n\n#endif // FEAT_EVAL\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n#ifdef FEAT_CINDENT\n\t\"+cindent\",\n#else\n\t\"-cindent\",\n#endif\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n#ifdef EBCDIC\n\t\"+ebcdic\",\n#else\n\t\"-ebcdic\",\n#endif\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n#ifdef FEAT_LISP\n\t\"+lispindent\",\n#else\n\t\"-lispindent\",\n#endif\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n\t\"+mouse_gpm\",\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n#ifdef FEAT_SMARTINDENT\n\t\"+smartindent\",\n#else\n\t\"-smartindent\",\n#endif\n#ifdef FEAT_SODIUM\n\t\"+sodium\",\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n#ifdef FEAT_TAG_BINS\n\t\"+tag_binary\",\n#else\n\t\"-tag_binary\",\n#endif\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#ifdef MSWIN\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#else\n# ifdef HAVE_XPM\n\t\"+xpm\",\n# else\n\t\"-xpm\",\n# endif\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef USE_XSMP_INTERACT\n\t\"+xsmp_interact\",\n# else\n#  ifdef USE_XSMP\n\t\"+xsmp\",\n#  else\n\t\"-xsmp\",\n#  endif\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    3901,\n/**/\n    3900,\n/**/\n    3899,\n/**/\n    3898,\n/**/\n    3897,\n/**/\n    3896,\n/**/\n    3895,\n/**/\n    3894,\n/**/\n    3893,\n/**/\n    3892,\n/**/\n    3891,\n/**/\n    3890,\n/**/\n    3889,\n/**/\n    3888,\n/**/\n    3887,\n/**/\n    3886,\n/**/\n    3885,\n/**/\n    3884,\n/**/\n    3883,\n/**/\n    3882,\n/**/\n    3881,\n/**/\n    3880,\n/**/\n    3879,\n/**/\n    3878,\n/**/\n    3877,\n/**/\n    3876,\n/**/\n    3875,\n/**/\n    3874,\n/**/\n    3873,\n/**/\n    3872,\n/**/\n    3871,\n/**/\n    3870,\n/**/\n    3869,\n/**/\n    3868,\n/**/\n    3867,\n/**/\n    3866,\n/**/\n    3865,\n/**/\n    3864,\n/**/\n    3863,\n/**/\n    3862,\n/**/\n    3861,\n/**/\n    3860,\n/**/\n    3859,\n/**/\n    3858,\n/**/\n    3857,\n/**/\n    3856,\n/**/\n    3855,\n/**/\n    3854,\n/**/\n    3853,\n/**/\n    3852,\n/**/\n    3851,\n/**/\n    3850,\n/**/\n    3849,\n/**/\n    3848,\n/**/\n    3847,\n/**/\n    3846,\n/**/\n    3845,\n/**/\n    3844,\n/**/\n    3843,\n/**/\n    3842,\n/**/\n    3841,\n/**/\n    3840,\n/**/\n    3839,\n/**/\n    3838,\n/**/\n    3837,\n/**/\n    3836,\n/**/\n    3835,\n/**/\n    3834,\n/**/\n    3833,\n/**/\n    3832,\n/**/\n    3831,\n/**/\n    3830,\n/**/\n    3829,\n/**/\n    3828,\n/**/\n    3827,\n/**/\n    3826,\n/**/\n    3825,\n/**/\n    3824,\n/**/\n    3823,\n/**/\n    3822,\n/**/\n    3821,\n/**/\n    3820,\n/**/\n    3819,\n/**/\n    3818,\n/**/\n    3817,\n/**/\n    3816,\n/**/\n    3815,\n/**/\n    3814,\n/**/\n    3813,\n/**/\n    3812,\n/**/\n    3811,\n/**/\n    3810,\n/**/\n    3809,\n/**/\n    3808,\n/**/\n    3807,\n/**/\n    3806,\n/**/\n    3805,\n/**/\n    3804,\n/**/\n    3803,\n/**/\n    3802,\n/**/\n    3801,\n/**/\n    3800,\n/**/\n    3799,\n/**/\n    3798,\n/**/\n    3797,\n/**/\n    3796,\n/**/\n    3795,\n/**/\n    3794,\n/**/\n    3793,\n/**/\n    3792,\n/**/\n    3791,\n/**/\n    3790,\n/**/\n    3789,\n/**/\n    3788,\n/**/\n    3787,\n/**/\n    3786,\n/**/\n    3785,\n/**/\n    3784,\n/**/\n    3783,\n/**/\n    3782,\n/**/\n    3781,\n/**/\n    3780,\n/**/\n    3779,\n/**/\n    3778,\n/**/\n    3777,\n/**/\n    3776,\n/**/\n    3775,\n/**/\n    3774,\n/**/\n    3773,\n/**/\n    3772,\n/**/\n    3771,\n/**/\n    3770,\n/**/\n    3769,\n/**/\n    3768,\n/**/\n    3767,\n/**/\n    3766,\n/**/\n    3765,\n/**/\n    3764,\n/**/\n    3763,\n/**/\n    3762,\n/**/\n    3761,\n/**/\n    3760,\n/**/\n    3759,\n/**/\n    3758,\n/**/\n    3757,\n/**/\n    3756,\n/**/\n    3755,\n/**/\n    3754,\n/**/\n    3753,\n/**/\n    3752,\n/**/\n    3751,\n/**/\n    3750,\n/**/\n    3749,\n/**/\n    3748,\n/**/\n    3747,\n/**/\n    3746,\n/**/\n    3745,\n/**/\n    3744,\n/**/\n    3743,\n/**/\n    3742,\n/**/\n    3741,\n/**/\n    3740,\n/**/\n    3739,\n/**/\n    3738,\n/**/\n    3737,\n/**/\n    3736,\n/**/\n    3735,\n/**/\n    3734,\n/**/\n    3733,\n/**/\n    3732,\n/**/\n    3731,\n/**/\n    3730,\n/**/\n    3729,\n/**/\n    3728,\n/**/\n    3727,\n/**/\n    3726,\n/**/\n    3725,\n/**/\n    3724,\n/**/\n    3723,\n/**/\n    3722,\n/**/\n    3721,\n/**/\n    3720,\n/**/\n    3719,\n/**/\n    3718,\n/**/\n    3717,\n/**/\n    3716,\n/**/\n    3715,\n/**/\n    3714,\n/**/\n    3713,\n/**/\n    3712,\n/**/\n    3711,\n/**/\n    3710,\n/**/\n    3709,\n/**/\n    3708,\n/**/\n    3707,\n/**/\n    3706,\n/**/\n    3705,\n/**/\n    3704,\n/**/\n    3703,\n/**/\n    3702,\n/**/\n    3701,\n/**/\n    3700,\n/**/\n    3699,\n/**/\n    3698,\n/**/\n    3697,\n/**/\n    3696,\n/**/\n    3695,\n/**/\n    3694,\n/**/\n    3693,\n/**/\n    3692,\n/**/\n    3691,\n/**/\n    3690,\n/**/\n    3689,\n/**/\n    3688,\n/**/\n    3687,\n/**/\n    3686,\n/**/\n    3685,\n/**/\n    3684,\n/**/\n    3683,\n/**/\n    3682,\n/**/\n    3681,\n/**/\n    3680,\n/**/\n    3679,\n/**/\n    3678,\n/**/\n    3677,\n/**/\n    3676,\n/**/\n    3675,\n/**/\n    3674,\n/**/\n    3673,\n/**/\n    3672,\n/**/\n    3671,\n/**/\n    3670,\n/**/\n    3669,\n/**/\n    3668,\n/**/\n    3667,\n/**/\n    3666,\n/**/\n    3665,\n/**/\n    3664,\n/**/\n    3663,\n/**/\n    3662,\n/**/\n    3661,\n/**/\n    3660,\n/**/\n    3659,\n/**/\n    3658,\n/**/\n    3657,\n/**/\n    3656,\n/**/\n    3655,\n/**/\n    3654,\n/**/\n    3653,\n/**/\n    3652,\n/**/\n    3651,\n/**/\n    3650,\n/**/\n    3649,\n/**/\n    3648,\n/**/\n    3647,\n/**/\n    3646,\n/**/\n    3645,\n/**/\n    3644,\n/**/\n    3643,\n/**/\n    3642,\n/**/\n    3641,\n/**/\n    3640,\n/**/\n    3639,\n/**/\n    3638,\n/**/\n    3637,\n/**/\n    3636,\n/**/\n    3635,\n/**/\n    3634,\n/**/\n    3633,\n/**/\n    3632,\n/**/\n    3631,\n/**/\n    3630,\n/**/\n    3629,\n/**/\n    3628,\n/**/\n    3627,\n/**/\n    3626,\n/**/\n    3625,\n/**/\n    3624,\n/**/\n    3623,\n/**/\n    3622,\n/**/\n    3621,\n/**/\n    3620,\n/**/\n    3619,\n/**/\n    3618,\n/**/\n    3617,\n/**/\n    3616,\n/**/\n    3615,\n/**/\n    3614,\n/**/\n    3613,\n/**/\n    3612,\n/**/\n    3611,\n/**/\n    3610,\n/**/\n    3609,\n/**/\n    3608,\n/**/\n    3607,\n/**/\n    3606,\n/**/\n    3605,\n/**/\n    3604,\n/**/\n    3603,\n/**/\n    3602,\n/**/\n    3601,\n/**/\n    3600,\n/**/\n    3599,\n/**/\n    3598,\n/**/\n    3597,\n/**/\n    3596,\n/**/\n    3595,\n/**/\n    3594,\n/**/\n    3593,\n/**/\n    3592,\n/**/\n    3591,\n/**/\n    3590,\n/**/\n    3589,\n/**/\n    3588,\n/**/\n    3587,\n/**/\n    3586,\n/**/\n    3585,\n/**/\n    3584,\n/**/\n    3583,\n/**/\n    3582,\n/**/\n    3581,\n/**/\n    3580,\n/**/\n    3579,\n/**/\n    3578,\n/**/\n    3577,\n/**/\n    3576,\n/**/\n    3575,\n/**/\n    3574,\n/**/\n    3573,\n/**/\n    3572,\n/**/\n    3571,\n/**/\n    3570,\n/**/\n    3569,\n/**/\n    3568,\n/**/\n    3567,\n/**/\n    3566,\n/**/\n    3565,\n/**/\n    3564,\n/**/\n    3563,\n/**/\n    3562,\n/**/\n    3561,\n/**/\n    3560,\n/**/\n    3559,\n/**/\n    3558,\n/**/\n    3557,\n/**/\n    3556,\n/**/\n    3555,\n/**/\n    3554,\n/**/\n    3553,\n/**/\n    3552,\n/**/\n    3551,\n/**/\n    3550,\n/**/\n    3549,\n/**/\n    3548,\n/**/\n    3547,\n/**/\n    3546,\n/**/\n    3545,\n/**/\n    3544,\n/**/\n    3543,\n/**/\n    3542,\n/**/\n    3541,\n/**/\n    3540,\n/**/\n    3539,\n/**/\n    3538,\n/**/\n    3537,\n/**/\n    3536,\n/**/\n    3535,\n/**/\n    3534,\n/**/\n    3533,\n/**/\n    3532,\n/**/\n    3531,\n/**/\n    3530,\n/**/\n    3529,\n/**/\n    3528,\n/**/\n    3527,\n/**/\n    3526,\n/**/\n    3525,\n/**/\n    3524,\n/**/\n    3523,\n/**/\n    3522,\n/**/\n    3521,\n/**/\n    3520,\n/**/\n    3519,\n/**/\n    3518,\n/**/\n    3517,\n/**/\n    3516,\n/**/\n    3515,\n/**/\n    3514,\n/**/\n    3513,\n/**/\n    3512,\n/**/\n    3511,\n/**/\n    3510,\n/**/\n    3509,\n/**/\n    3508,\n/**/\n    3507,\n/**/\n    3506,\n/**/\n    3505,\n/**/\n    3504,\n/**/\n    3503,\n/**/\n    3502,\n/**/\n    3501,\n/**/\n    3500,\n/**/\n    3499,\n/**/\n    3498,\n/**/\n    3497,\n/**/\n    3496,\n/**/\n    3495,\n/**/\n    3494,\n/**/\n    3493,\n/**/\n    3492,\n/**/\n    3491,\n/**/\n    3490,\n/**/\n    3489,\n/**/\n    3488,\n/**/\n    3487,\n/**/\n    3486,\n/**/\n    3485,\n/**/\n    3484,\n/**/\n    3483,\n/**/\n    3482,\n/**/\n    3481,\n/**/\n    3480,\n/**/\n    3479,\n/**/\n    3478,\n/**/\n    3477,\n/**/\n    3476,\n/**/\n    3475,\n/**/\n    3474,\n/**/\n    3473,\n/**/\n    3472,\n/**/\n    3471,\n/**/\n    3470,\n/**/\n    3469,\n/**/\n    3468,\n/**/\n    3467,\n/**/\n    3466,\n/**/\n    3465,\n/**/\n    3464,\n/**/\n    3463,\n/**/\n    3462,\n/**/\n    3461,\n/**/\n    3460,\n/**/\n    3459,\n/**/\n    3458,\n/**/\n    3457,\n/**/\n    3456,\n/**/\n    3455,\n/**/\n    3454,\n/**/\n    3453,\n/**/\n    3452,\n/**/\n    3451,\n/**/\n    3450,\n/**/\n    3449,\n/**/\n    3448,\n/**/\n    3447,\n/**/\n    3446,\n/**/\n    3445,\n/**/\n    3444,\n/**/\n    3443,\n/**/\n    3442,\n/**/\n    3441,\n/**/\n    3440,\n/**/\n    3439,\n/**/\n    3438,\n/**/\n    3437,\n/**/\n    3436,\n/**/\n    3435,\n/**/\n    3434,\n/**/\n    3433,\n/**/\n    3432,\n/**/\n    3431,\n/**/\n    3430,\n/**/\n    3429,\n/**/\n    3428,\n/**/\n    3427,\n/**/\n    3426,\n/**/\n    3425,\n/**/\n    3424,\n/**/\n    3423,\n/**/\n    3422,\n/**/\n    3421,\n/**/\n    3420,\n/**/\n    3419,\n/**/\n    3418,\n/**/\n    3417,\n/**/\n    3416,\n/**/\n    3415,\n/**/\n    3414,\n/**/\n    3413,\n/**/\n    3412,\n/**/\n    3411,\n/**/\n    3410,\n/**/\n    3409,\n/**/\n    3408,\n/**/\n    3407,\n/**/\n    3406,\n/**/\n    3405,\n/**/\n    3404,\n/**/\n    3403,\n/**/\n    3402,\n/**/\n    3401,\n/**/\n    3400,\n/**/\n    3399,\n/**/\n    3398,\n/**/\n    3397,\n/**/\n    3396,\n/**/\n    3395,\n/**/\n    3394,\n/**/\n    3393,\n/**/\n    3392,\n/**/\n    3391,\n/**/\n    3390,\n/**/\n    3389,\n/**/\n    3388,\n/**/\n    3387,\n/**/\n    3386,\n/**/\n    3385,\n/**/\n    3384,\n/**/\n    3383,\n/**/\n    3382,\n/**/\n    3381,\n/**/\n    3380,\n/**/\n    3379,\n/**/\n    3378,\n/**/\n    3377,\n/**/\n    3376,\n/**/\n    3375,\n/**/\n    3374,\n/**/\n    3373,\n/**/\n    3372,\n/**/\n    3371,\n/**/\n    3370,\n/**/\n    3369,\n/**/\n    3368,\n/**/\n    3367,\n/**/\n    3366,\n/**/\n    3365,\n/**/\n    3364,\n/**/\n    3363,\n/**/\n    3362,\n/**/\n    3361,\n/**/\n    3360,\n/**/\n    3359,\n/**/\n    3358,\n/**/\n    3357,\n/**/\n    3356,\n/**/\n    3355,\n/**/\n    3354,\n/**/\n    3353,\n/**/\n    3352,\n/**/\n    3351,\n/**/\n    3350,\n/**/\n    3349,\n/**/\n    3348,\n/**/\n    3347,\n/**/\n    3346,\n/**/\n    3345,\n/**/\n    3344,\n/**/\n    3343,\n/**/\n    3342,\n/**/\n    3341,\n/**/\n    3340,\n/**/\n    3339,\n/**/\n    3338,\n/**/\n    3337,\n/**/\n    3336,\n/**/\n    3335,\n/**/\n    3334,\n/**/\n    3333,\n/**/\n    3332,\n/**/\n    3331,\n/**/\n    3330,\n/**/\n    3329,\n/**/\n    3328,\n/**/\n    3327,\n/**/\n    3326,\n/**/\n    3325,\n/**/\n    3324,\n/**/\n    3323,\n/**/\n    3322,\n/**/\n    3321,\n/**/\n    3320,\n/**/\n    3319,\n/**/\n    3318,\n/**/\n    3317,\n/**/\n    3316,\n/**/\n    3315,\n/**/\n    3314,\n/**/\n    3313,\n/**/\n    3312,\n/**/\n    3311,\n/**/\n    3310,\n/**/\n    3309,\n/**/\n    3308,\n/**/\n    3307,\n/**/\n    3306,\n/**/\n    3305,\n/**/\n    3304,\n/**/\n    3303,\n/**/\n    3302,\n/**/\n    3301,\n/**/\n    3300,\n/**/\n    3299,\n/**/\n    3298,\n/**/\n    3297,\n/**/\n    3296,\n/**/\n    3295,\n/**/\n    3294,\n/**/\n    3293,\n/**/\n    3292,\n/**/\n    3291,\n/**/\n    3290,\n/**/\n    3289,\n/**/\n    3288,\n/**/\n    3287,\n/**/\n    3286,\n/**/\n    3285,\n/**/\n    3284,\n/**/\n    3283,\n/**/\n    3282,\n/**/\n    3281,\n/**/\n    3280,\n/**/\n    3279,\n/**/\n    3278,\n/**/\n    3277,\n/**/\n    3276,\n/**/\n    3275,\n/**/\n    3274,\n/**/\n    3273,\n/**/\n    3272,\n/**/\n    3271,\n/**/\n    3270,\n/**/\n    3269,\n/**/\n    3268,\n/**/\n    3267,\n/**/\n    3266,\n/**/\n    3265,\n/**/\n    3264,\n/**/\n    3263,\n/**/\n    3262,\n/**/\n    3261,\n/**/\n    3260,\n/**/\n    3259,\n/**/\n    3258,\n/**/\n    3257,\n/**/\n    3256,\n/**/\n    3255,\n/**/\n    3254,\n/**/\n    3253,\n/**/\n    3252,\n/**/\n    3251,\n/**/\n    3250,\n/**/\n    3249,\n/**/\n    3248,\n/**/\n    3247,\n/**/\n    3246,\n/**/\n    3245,\n/**/\n    3244,\n/**/\n    3243,\n/**/\n    3242,\n/**/\n    3241,\n/**/\n    3240,\n/**/\n    3239,\n/**/\n    3238,\n/**/\n    3237,\n/**/\n    3236,\n/**/\n    3235,\n/**/\n    3234,\n/**/\n    3233,\n/**/\n    3232,\n/**/\n    3231,\n/**/\n    3230,\n/**/\n    3229,\n/**/\n    3228,\n/**/\n    3227,\n/**/\n    3226,\n/**/\n    3225,\n/**/\n    3224,\n/**/\n    3223,\n/**/\n    3222,\n/**/\n    3221,\n/**/\n    3220,\n/**/\n    3219,\n/**/\n    3218,\n/**/\n    3217,\n/**/\n    3216,\n/**/\n    3215,\n/**/\n    3214,\n/**/\n    3213,\n/**/\n    3212,\n/**/\n    3211,\n/**/\n    3210,\n/**/\n    3209,\n/**/\n    3208,\n/**/\n    3207,\n/**/\n    3206,\n/**/\n    3205,\n/**/\n    3204,\n/**/\n    3203,\n/**/\n    3202,\n/**/\n    3201,\n/**/\n    3200,\n/**/\n    3199,\n/**/\n    3198,\n/**/\n    3197,\n/**/\n    3196,\n/**/\n    3195,\n/**/\n    3194,\n/**/\n    3193,\n/**/\n    3192,\n/**/\n    3191,\n/**/\n    3190,\n/**/\n    3189,\n/**/\n    3188,\n/**/\n    3187,\n/**/\n    3186,\n/**/\n    3185,\n/**/\n    3184,\n/**/\n    3183,\n/**/\n    3182,\n/**/\n    3181,\n/**/\n    3180,\n/**/\n    3179,\n/**/\n    3178,\n/**/\n    3177,\n/**/\n    3176,\n/**/\n    3175,\n/**/\n    3174,\n/**/\n    3173,\n/**/\n    3172,\n/**/\n    3171,\n/**/\n    3170,\n/**/\n    3169,\n/**/\n    3168,\n/**/\n    3167,\n/**/\n    3166,\n/**/\n    3165,\n/**/\n    3164,\n/**/\n    3163,\n/**/\n    3162,\n/**/\n    3161,\n/**/\n    3160,\n/**/\n    3159,\n/**/\n    3158,\n/**/\n    3157,\n/**/\n    3156,\n/**/\n    3155,\n/**/\n    3154,\n/**/\n    3153,\n/**/\n    3152,\n/**/\n    3151,\n/**/\n    3150,\n/**/\n    3149,\n/**/\n    3148,\n/**/\n    3147,\n/**/\n    3146,\n/**/\n    3145,\n/**/\n    3144,\n/**/\n    3143,\n/**/\n    3142,\n/**/\n    3141,\n/**/\n    3140,\n/**/\n    3139,\n/**/\n    3138,\n/**/\n    3137,\n/**/\n    3136,\n/**/\n    3135,\n/**/\n    3134,\n/**/\n    3133,\n/**/\n    3132,\n/**/\n    3131,\n/**/\n    3130,\n/**/\n    3129,\n/**/\n    3128,\n/**/\n    3127,\n/**/\n    3126,\n/**/\n    3125,\n/**/\n    3124,\n/**/\n    3123,\n/**/\n    3122,\n/**/\n    3121,\n/**/\n    3120,\n/**/\n    3119,\n/**/\n    3118,\n/**/\n    3117,\n/**/\n    3116,\n/**/\n    3115,\n/**/\n    3114,\n/**/\n    3113,\n/**/\n    3112,\n/**/\n    3111,\n/**/\n    3110,\n/**/\n    3109,\n/**/\n    3108,\n/**/\n    3107,\n/**/\n    3106,\n/**/\n    3105,\n/**/\n    3104,\n/**/\n    3103,\n/**/\n    3102,\n/**/\n    3101,\n/**/\n    3100,\n/**/\n    3099,\n/**/\n    3098,\n/**/\n    3097,\n/**/\n    3096,\n/**/\n    3095,\n/**/\n    3094,\n/**/\n    3093,\n/**/\n    3092,\n/**/\n    3091,\n/**/\n    3090,\n/**/\n    3089,\n/**/\n    3088,\n/**/\n    3087,\n/**/\n    3086,\n/**/\n    3085,\n/**/\n    3084,\n/**/\n    3083,\n/**/\n    3082,\n/**/\n    3081,\n/**/\n    3080,\n/**/\n    3079,\n/**/\n    3078,\n/**/\n    3077,\n/**/\n    3076,\n/**/\n    3075,\n/**/\n    3074,\n/**/\n    3073,\n/**/\n    3072,\n/**/\n    3071,\n/**/\n    3070,\n/**/\n    3069,\n/**/\n    3068,\n/**/\n    3067,\n/**/\n    3066,\n/**/\n    3065,\n/**/\n    3064,\n/**/\n    3063,\n/**/\n    3062,\n/**/\n    3061,\n/**/\n    3060,\n/**/\n    3059,\n/**/\n    3058,\n/**/\n    3057,\n/**/\n    3056,\n/**/\n    3055,\n/**/\n    3054,\n/**/\n    3053,\n/**/\n    3052,\n/**/\n    3051,\n/**/\n    3050,\n/**/\n    3049,\n/**/\n    3048,\n/**/\n    3047,\n/**/\n    3046,\n/**/\n    3045,\n/**/\n    3044,\n/**/\n    3043,\n/**/\n    3042,\n/**/\n    3041,\n/**/\n    3040,\n/**/\n    3039,\n/**/\n    3038,\n/**/\n    3037,\n/**/\n    3036,\n/**/\n    3035,\n/**/\n    3034,\n/**/\n    3033,\n/**/\n    3032,\n/**/\n    3031,\n/**/\n    3030,\n/**/\n    3029,\n/**/\n    3028,\n/**/\n    3027,\n/**/\n    3026,\n/**/\n    3025,\n/**/\n    3024,\n/**/\n    3023,\n/**/\n    3022,\n/**/\n    3021,\n/**/\n    3020,\n/**/\n    3019,\n/**/\n    3018,\n/**/\n    3017,\n/**/\n    3016,\n/**/\n    3015,\n/**/\n    3014,\n/**/\n    3013,\n/**/\n    3012,\n/**/\n    3011,\n/**/\n    3010,\n/**/\n    3009,\n/**/\n    3008,\n/**/\n    3007,\n/**/\n    3006,\n/**/\n    3005,\n/**/\n    3004,\n/**/\n    3003,\n/**/\n    3002,\n/**/\n    3001,\n/**/\n    3000,\n/**/\n    2999,\n/**/\n    2998,\n/**/\n    2997,\n/**/\n    2996,\n/**/\n    2995,\n/**/\n    2994,\n/**/\n    2993,\n/**/\n    2992,\n/**/\n    2991,\n/**/\n    2990,\n/**/\n    2989,\n/**/\n    2988,\n/**/\n    2987,\n/**/\n    2986,\n/**/\n    2985,\n/**/\n    2984,\n/**/\n    2983,\n/**/\n    2982,\n/**/\n    2981,\n/**/\n    2980,\n/**/\n    2979,\n/**/\n    2978,\n/**/\n    2977,\n/**/\n    2976,\n/**/\n    2975,\n/**/\n    2974,\n/**/\n    2973,\n/**/\n    2972,\n/**/\n    2971,\n/**/\n    2970,\n/**/\n    2969,\n/**/\n    2968,\n/**/\n    2967,\n/**/\n    2966,\n/**/\n    2965,\n/**/\n    2964,\n/**/\n    2963,\n/**/\n    2962,\n/**/\n    2961,\n/**/\n    2960,\n/**/\n    2959,\n/**/\n    2958,\n/**/\n    2957,\n/**/\n    2956,\n/**/\n    2955,\n/**/\n    2954,\n/**/\n    2953,\n/**/\n    2952,\n/**/\n    2951,\n/**/\n    2950,\n/**/\n    2949,\n/**/\n    2948,\n/**/\n    2947,\n/**/\n    2946,\n/**/\n    2945,\n/**/\n    2944,\n/**/\n    2943,\n/**/\n    2942,\n/**/\n    2941,\n/**/\n    2940,\n/**/\n    2939,\n/**/\n    2938,\n/**/\n    2937,\n/**/\n    2936,\n/**/\n    2935,\n/**/\n    2934,\n/**/\n    2933,\n/**/\n    2932,\n/**/\n    2931,\n/**/\n    2930,\n/**/\n    2929,\n/**/\n    2928,\n/**/\n    2927,\n/**/\n    2926,\n/**/\n    2925,\n/**/\n    2924,\n/**/\n    2923,\n/**/\n    2922,\n/**/\n    2921,\n/**/\n    2920,\n/**/\n    2919,\n/**/\n    2918,\n/**/\n    2917,\n/**/\n    2916,\n/**/\n    2915,\n/**/\n    2914,\n/**/\n    2913,\n/**/\n    2912,\n/**/\n    2911,\n/**/\n    2910,\n/**/\n    2909,\n/**/\n    2908,\n/**/\n    2907,\n/**/\n    2906,\n/**/\n    2905,\n/**/\n    2904,\n/**/\n    2903,\n/**/\n    2902,\n/**/\n    2901,\n/**/\n    2900,\n/**/\n    2899,\n/**/\n    2898,\n/**/\n    2897,\n/**/\n    2896,\n/**/\n    2895,\n/**/\n    2894,\n/**/\n    2893,\n/**/\n    2892,\n/**/\n    2891,\n/**/\n    2890,\n/**/\n    2889,\n/**/\n    2888,\n/**/\n    2887,\n/**/\n    2886,\n/**/\n    2885,\n/**/\n    2884,\n/**/\n    2883,\n/**/\n    2882,\n/**/\n    2881,\n/**/\n    2880,\n/**/\n    2879,\n/**/\n    2878,\n/**/\n    2877,\n/**/\n    2876,\n/**/\n    2875,\n/**/\n    2874,\n/**/\n    2873,\n/**/\n    2872,\n/**/\n    2871,\n/**/\n    2870,\n/**/\n    2869,\n/**/\n    2868,\n/**/\n    2867,\n/**/\n    2866,\n/**/\n    2865,\n/**/\n    2864,\n/**/\n    2863,\n/**/\n    2862,\n/**/\n    2861,\n/**/\n    2860,\n/**/\n    2859,\n/**/\n    2858,\n/**/\n    2857,\n/**/\n    2856,\n/**/\n    2855,\n/**/\n    2854,\n/**/\n    2853,\n/**/\n    2852,\n/**/\n    2851,\n/**/\n    2850,\n/**/\n    2849,\n/**/\n    2848,\n/**/\n    2847,\n/**/\n    2846,\n/**/\n    2845,\n/**/\n    2844,\n/**/\n    2843,\n/**/\n    2842,\n/**/\n    2841,\n/**/\n    2840,\n/**/\n    2839,\n/**/\n    2838,\n/**/\n    2837,\n/**/\n    2836,\n/**/\n    2835,\n/**/\n    2834,\n/**/\n    2833,\n/**/\n    2832,\n/**/\n    2831,\n/**/\n    2830,\n/**/\n    2829,\n/**/\n    2828,\n/**/\n    2827,\n/**/\n    2826,\n/**/\n    2825,\n/**/\n    2824,\n/**/\n    2823,\n/**/\n    2822,\n/**/\n    2821,\n/**/\n    2820,\n/**/\n    2819,\n/**/\n    2818,\n/**/\n    2817,\n/**/\n    2816,\n/**/\n    2815,\n/**/\n    2814,\n/**/\n    2813,\n/**/\n    2812,\n/**/\n    2811,\n/**/\n    2810,\n/**/\n    2809,\n/**/\n    2808,\n/**/\n    2807,\n/**/\n    2806,\n/**/\n    2805,\n/**/\n    2804,\n/**/\n    2803,\n/**/\n    2802,\n/**/\n    2801,\n/**/\n    2800,\n/**/\n    2799,\n/**/\n    2798,\n/**/\n    2797,\n/**/\n    2796,\n/**/\n    2795,\n/**/\n    2794,\n/**/\n    2793,\n/**/\n    2792,\n/**/\n    2791,\n/**/\n    2790,\n/**/\n    2789,\n/**/\n    2788,\n/**/\n    2787,\n/**/\n    2786,\n/**/\n    2785,\n/**/\n    2784,\n/**/\n    2783,\n/**/\n    2782,\n/**/\n    2781,\n/**/\n    2780,\n/**/\n    2779,\n/**/\n    2778,\n/**/\n    2777,\n/**/\n    2776,\n/**/\n    2775,\n/**/\n    2774,\n/**/\n    2773,\n/**/\n    2772,\n/**/\n    2771,\n/**/\n    2770,\n/**/\n    2769,\n/**/\n    2768,\n/**/\n    2767,\n/**/\n    2766,\n/**/\n    2765,\n/**/\n    2764,\n/**/\n    2763,\n/**/\n    2762,\n/**/\n    2761,\n/**/\n    2760,\n/**/\n    2759,\n/**/\n    2758,\n/**/\n    2757,\n/**/\n    2756,\n/**/\n    2755,\n/**/\n    2754,\n/**/\n    2753,\n/**/\n    2752,\n/**/\n    2751,\n/**/\n    2750,\n/**/\n    2749,\n/**/\n    2748,\n/**/\n    2747,\n/**/\n    2746,\n/**/\n    2745,\n/**/\n    2744,\n/**/\n    2743,\n/**/\n    2742,\n/**/\n    2741,\n/**/\n    2740,\n/**/\n    2739,\n/**/\n    2738,\n/**/\n    2737,\n/**/\n    2736,\n/**/\n    2735,\n/**/\n    2734,\n/**/\n    2733,\n/**/\n    2732,\n/**/\n    2731,\n/**/\n    2730,\n/**/\n    2729,\n/**/\n    2728,\n/**/\n    2727,\n/**/\n    2726,\n/**/\n    2725,\n/**/\n    2724,\n/**/\n    2723,\n/**/\n    2722,\n/**/\n    2721,\n/**/\n    2720,\n/**/\n    2719,\n/**/\n    2718,\n/**/\n    2717,\n/**/\n    2716,\n/**/\n    2715,\n/**/\n    2714,\n/**/\n    2713,\n/**/\n    2712,\n/**/\n    2711,\n/**/\n    2710,\n/**/\n    2709,\n/**/\n    2708,\n/**/\n    2707,\n/**/\n    2706,\n/**/\n    2705,\n/**/\n    2704,\n/**/\n    2703,\n/**/\n    2702,\n/**/\n    2701,\n/**/\n    2700,\n/**/\n    2699,\n/**/\n    2698,\n/**/\n    2697,\n/**/\n    2696,\n/**/\n    2695,\n/**/\n    2694,\n/**/\n    2693,\n/**/\n    2692,\n/**/\n    2691,\n/**/\n    2690,\n/**/\n    2689,\n/**/\n    2688,\n/**/\n    2687,\n/**/\n    2686,\n/**/\n    2685,\n/**/\n    2684,\n/**/\n    2683,\n/**/\n    2682,\n/**/\n    2681,\n/**/\n    2680,\n/**/\n    2679,\n/**/\n    2678,\n/**/\n    2677,\n/**/\n    2676,\n/**/\n    2675,\n/**/\n    2674,\n/**/\n    2673,\n/**/\n    2672,\n/**/\n    2671,\n/**/\n    2670,\n/**/\n    2669,\n/**/\n    2668,\n/**/\n    2667,\n/**/\n    2666,\n/**/\n    2665,\n/**/\n    2664,\n/**/\n    2663,\n/**/\n    2662,\n/**/\n    2661,\n/**/\n    2660,\n/**/\n    2659,\n/**/\n    2658,\n/**/\n    2657,\n/**/\n    2656,\n/**/\n    2655,\n/**/\n    2654,\n/**/\n    2653,\n/**/\n    2652,\n/**/\n    2651,\n/**/\n    2650,\n/**/\n    2649,\n/**/\n    2648,\n/**/\n    2647,\n/**/\n    2646,\n/**/\n    2645,\n/**/\n    2644,\n/**/\n    2643,\n/**/\n    2642,\n/**/\n    2641,\n/**/\n    2640,\n/**/\n    2639,\n/**/\n    2638,\n/**/\n    2637,\n/**/\n    2636,\n/**/\n    2635,\n/**/\n    2634,\n/**/\n    2633,\n/**/\n    2632,\n/**/\n    2631,\n/**/\n    2630,\n/**/\n    2629,\n/**/\n    2628,\n/**/\n    2627,\n/**/\n    2626,\n/**/\n    2625,\n/**/\n    2624,\n/**/\n    2623,\n/**/\n    2622,\n/**/\n    2621,\n/**/\n    2620,\n/**/\n    2619,\n/**/\n    2618,\n/**/\n    2617,\n/**/\n    2616,\n/**/\n    2615,\n/**/\n    2614,\n/**/\n    2613,\n/**/\n    2612,\n/**/\n    2611,\n/**/\n    2610,\n/**/\n    2609,\n/**/\n    2608,\n/**/\n    2607,\n/**/\n    2606,\n/**/\n    2605,\n/**/\n    2604,\n/**/\n    2603,\n/**/\n    2602,\n/**/\n    2601,\n/**/\n    2600,\n/**/\n    2599,\n/**/\n    2598,\n/**/\n    2597,\n/**/\n    2596,\n/**/\n    2595,\n/**/\n    2594,\n/**/\n    2593,\n/**/\n    2592,\n/**/\n    2591,\n/**/\n    2590,\n/**/\n    2589,\n/**/\n    2588,\n/**/\n    2587,\n/**/\n    2586,\n/**/\n    2585,\n/**/\n    2584,\n/**/\n    2583,\n/**/\n    2582,\n/**/\n    2581,\n/**/\n    2580,\n/**/\n    2579,\n/**/\n    2578,\n/**/\n    2577,\n/**/\n    2576,\n/**/\n    2575,\n/**/\n    2574,\n/**/\n    2573,\n/**/\n    2572,\n/**/\n    2571,\n/**/\n    2570,\n/**/\n    2569,\n/**/\n    2568,\n/**/\n    2567,\n/**/\n    2566,\n/**/\n    2565,\n/**/\n    2564,\n/**/\n    2563,\n/**/\n    2562,\n/**/\n    2561,\n/**/\n    2560,\n/**/\n    2559,\n/**/\n    2558,\n/**/\n    2557,\n/**/\n    2556,\n/**/\n    2555,\n/**/\n    2554,\n/**/\n    2553,\n/**/\n    2552,\n/**/\n    2551,\n/**/\n    2550,\n/**/\n    2549,\n/**/\n    2548,\n/**/\n    2547,\n/**/\n    2546,\n/**/\n    2545,\n/**/\n    2544,\n/**/\n    2543,\n/**/\n    2542,\n/**/\n    2541,\n/**/\n    2540,\n/**/\n    2539,\n/**/\n    2538,\n/**/\n    2537,\n/**/\n    2536,\n/**/\n    2535,\n/**/\n    2534,\n/**/\n    2533,\n/**/\n    2532,\n/**/\n    2531,\n/**/\n    2530,\n/**/\n    2529,\n/**/\n    2528,\n/**/\n    2527,\n/**/\n    2526,\n/**/\n    2525,\n/**/\n    2524,\n/**/\n    2523,\n/**/\n    2522,\n/**/\n    2521,\n/**/\n    2520,\n/**/\n    2519,\n/**/\n    2518,\n/**/\n    2517,\n/**/\n    2516,\n/**/\n    2515,\n/**/\n    2514,\n/**/\n    2513,\n/**/\n    2512,\n/**/\n    2511,\n/**/\n    2510,\n/**/\n    2509,\n/**/\n    2508,\n/**/\n    2507,\n/**/\n    2506,\n/**/\n    2505,\n/**/\n    2504,\n/**/\n    2503,\n/**/\n    2502,\n/**/\n    2501,\n/**/\n    2500,\n/**/\n    2499,\n/**/\n    2498,\n/**/\n    2497,\n/**/\n    2496,\n/**/\n    2495,\n/**/\n    2494,\n/**/\n    2493,\n/**/\n    2492,\n/**/\n    2491,\n/**/\n    2490,\n/**/\n    2489,\n/**/\n    2488,\n/**/\n    2487,\n/**/\n    2486,\n/**/\n    2485,\n/**/\n    2484,\n/**/\n    2483,\n/**/\n    2482,\n/**/\n    2481,\n/**/\n    2480,\n/**/\n    2479,\n/**/\n    2478,\n/**/\n    2477,\n/**/\n    2476,\n/**/\n    2475,\n/**/\n    2474,\n/**/\n    2473,\n/**/\n    2472,\n/**/\n    2471,\n/**/\n    2470,\n/**/\n    2469,\n/**/\n    2468,\n/**/\n    2467,\n/**/\n    2466,\n/**/\n    2465,\n/**/\n    2464,\n/**/\n    2463,\n/**/\n    2462,\n/**/\n    2461,\n/**/\n    2460,\n/**/\n    2459,\n/**/\n    2458,\n/**/\n    2457,\n/**/\n    2456,\n/**/\n    2455,\n/**/\n    2454,\n/**/\n    2453,\n/**/\n    2452,\n/**/\n    2451,\n/**/\n    2450,\n/**/\n    2449,\n/**/\n    2448,\n/**/\n    2447,\n/**/\n    2446,\n/**/\n    2445,\n/**/\n    2444,\n/**/\n    2443,\n/**/\n    2442,\n/**/\n    2441,\n/**/\n    2440,\n/**/\n    2439,\n/**/\n    2438,\n/**/\n    2437,\n/**/\n    2436,\n/**/\n    2435,\n/**/\n    2434,\n/**/\n    2433,\n/**/\n    2432,\n/**/\n    2431,\n/**/\n    2430,\n/**/\n    2429,\n/**/\n    2428,\n/**/\n    2427,\n/**/\n    2426,\n/**/\n    2425,\n/**/\n    2424,\n/**/\n    2423,\n/**/\n    2422,\n/**/\n    2421,\n/**/\n    2420,\n/**/\n    2419,\n/**/\n    2418,\n/**/\n    2417,\n/**/\n    2416,\n/**/\n    2415,\n/**/\n    2414,\n/**/\n    2413,\n/**/\n    2412,\n/**/\n    2411,\n/**/\n    2410,\n/**/\n    2409,\n/**/\n    2408,\n/**/\n    2407,\n/**/\n    2406,\n/**/\n    2405,\n/**/\n    2404,\n/**/\n    2403,\n/**/\n    2402,\n/**/\n    2401,\n/**/\n    2400,\n/**/\n    2399,\n/**/\n    2398,\n/**/\n    2397,\n/**/\n    2396,\n/**/\n    2395,\n/**/\n    2394,\n/**/\n    2393,\n/**/\n    2392,\n/**/\n    2391,\n/**/\n    2390,\n/**/\n    2389,\n/**/\n    2388,\n/**/\n    2387,\n/**/\n    2386,\n/**/\n    2385,\n/**/\n    2384,\n/**/\n    2383,\n/**/\n    2382,\n/**/\n    2381,\n/**/\n    2380,\n/**/\n    2379,\n/**/\n    2378,\n/**/\n    2377,\n/**/\n    2376,\n/**/\n    2375,\n/**/\n    2374,\n/**/\n    2373,\n/**/\n    2372,\n/**/\n    2371,\n/**/\n    2370,\n/**/\n    2369,\n/**/\n    2368,\n/**/\n    2367,\n/**/\n    2366,\n/**/\n    2365,\n/**/\n    2364,\n/**/\n    2363,\n/**/\n    2362,\n/**/\n    2361,\n/**/\n    2360,\n/**/\n    2359,\n/**/\n    2358,\n/**/\n    2357,\n/**/\n    2356,\n/**/\n    2355,\n/**/\n    2354,\n/**/\n    2353,\n/**/\n    2352,\n/**/\n    2351,\n/**/\n    2350,\n/**/\n    2349,\n/**/\n    2348,\n/**/\n    2347,\n/**/\n    2346,\n/**/\n    2345,\n/**/\n    2344,\n/**/\n    2343,\n/**/\n    2342,\n/**/\n    2341,\n/**/\n    2340,\n/**/\n    2339,\n/**/\n    2338,\n/**/\n    2337,\n/**/\n    2336,\n/**/\n    2335,\n/**/\n    2334,\n/**/\n    2333,\n/**/\n    2332,\n/**/\n    2331,\n/**/\n    2330,\n/**/\n    2329,\n/**/\n    2328,\n/**/\n    2327,\n/**/\n    2326,\n/**/\n    2325,\n/**/\n    2324,\n/**/\n    2323,\n/**/\n    2322,\n/**/\n    2321,\n/**/\n    2320,\n/**/\n    2319,\n/**/\n    2318,\n/**/\n    2317,\n/**/\n    2316,\n/**/\n    2315,\n/**/\n    2314,\n/**/\n    2313,\n/**/\n    2312,\n/**/\n    2311,\n/**/\n    2310,\n/**/\n    2309,\n/**/\n    2308,\n/**/\n    2307,\n/**/\n    2306,\n/**/\n    2305,\n/**/\n    2304,\n/**/\n    2303,\n/**/\n    2302,\n/**/\n    2301,\n/**/\n    2300,\n/**/\n    2299,\n/**/\n    2298,\n/**/\n    2297,\n/**/\n    2296,\n/**/\n    2295,\n/**/\n    2294,\n/**/\n    2293,\n/**/\n    2292,\n/**/\n    2291,\n/**/\n    2290,\n/**/\n    2289,\n/**/\n    2288,\n/**/\n    2287,\n/**/\n    2286,\n/**/\n    2285,\n/**/\n    2284,\n/**/\n    2283,\n/**/\n    2282,\n/**/\n    2281,\n/**/\n    2280,\n/**/\n    2279,\n/**/\n    2278,\n/**/\n    2277,\n/**/\n    2276,\n/**/\n    2275,\n/**/\n    2274,\n/**/\n    2273,\n/**/\n    2272,\n/**/\n    2271,\n/**/\n    2270,\n/**/\n    2269,\n/**/\n    2268,\n/**/\n    2267,\n/**/\n    2266,\n/**/\n    2265,\n/**/\n    2264,\n/**/\n    2263,\n/**/\n    2262,\n/**/\n    2261,\n/**/\n    2260,\n/**/\n    2259,\n/**/\n    2258,\n/**/\n    2257,\n/**/\n    2256,\n/**/\n    2255,\n/**/\n    2254,\n/**/\n    2253,\n/**/\n    2252,\n/**/\n    2251,\n/**/\n    2250,\n/**/\n    2249,\n/**/\n    2248,\n/**/\n    2247,\n/**/\n    2246,\n/**/\n    2245,\n/**/\n    2244,\n/**/\n    2243,\n/**/\n    2242,\n/**/\n    2241,\n/**/\n    2240,\n/**/\n    2239,\n/**/\n    2238,\n/**/\n    2237,\n/**/\n    2236,\n/**/\n    2235,\n/**/\n    2234,\n/**/\n    2233,\n/**/\n    2232,\n/**/\n    2231,\n/**/\n    2230,\n/**/\n    2229,\n/**/\n    2228,\n/**/\n    2227,\n/**/\n    2226,\n/**/\n    2225,\n/**/\n    2224,\n/**/\n    2223,\n/**/\n    2222,\n/**/\n    2221,\n/**/\n    2220,\n/**/\n    2219,\n/**/\n    2218,\n/**/\n    2217,\n/**/\n    2216,\n/**/\n    2215,\n/**/\n    2214,\n/**/\n    2213,\n/**/\n    2212,\n/**/\n    2211,\n/**/\n    2210,\n/**/\n    2209,\n/**/\n    2208,\n/**/\n    2207,\n/**/\n    2206,\n/**/\n    2205,\n/**/\n    2204,\n/**/\n    2203,\n/**/\n    2202,\n/**/\n    2201,\n/**/\n    2200,\n/**/\n    2199,\n/**/\n    2198,\n/**/\n    2197,\n/**/\n    2196,\n/**/\n    2195,\n/**/\n    2194,\n/**/\n    2193,\n/**/\n    2192,\n/**/\n    2191,\n/**/\n    2190,\n/**/\n    2189,\n/**/\n    2188,\n/**/\n    2187,\n/**/\n    2186,\n/**/\n    2185,\n/**/\n    2184,\n/**/\n    2183,\n/**/\n    2182,\n/**/\n    2181,\n/**/\n    2180,\n/**/\n    2179,\n/**/\n    2178,\n/**/\n    2177,\n/**/\n    2176,\n/**/\n    2175,\n/**/\n    2174,\n/**/\n    2173,\n/**/\n    2172,\n/**/\n    2171,\n/**/\n    2170,\n/**/\n    2169,\n/**/\n    2168,\n/**/\n    2167,\n/**/\n    2166,\n/**/\n    2165,\n/**/\n    2164,\n/**/\n    2163,\n/**/\n    2162,\n/**/\n    2161,\n/**/\n    2160,\n/**/\n    2159,\n/**/\n    2158,\n/**/\n    2157,\n/**/\n    2156,\n/**/\n    2155,\n/**/\n    2154,\n/**/\n    2153,\n/**/\n    2152,\n/**/\n    2151,\n/**/\n    2150,\n/**/\n    2149,\n/**/\n    2148,\n/**/\n    2147,\n/**/\n    2146,\n/**/\n    2145,\n/**/\n    2144,\n/**/\n    2143,\n/**/\n    2142,\n/**/\n    2141,\n/**/\n    2140,\n/**/\n    2139,\n/**/\n    2138,\n/**/\n    2137,\n/**/\n    2136,\n/**/\n    2135,\n/**/\n    2134,\n/**/\n    2133,\n/**/\n    2132,\n/**/\n    2131,\n/**/\n    2130,\n/**/\n    2129,\n/**/\n    2128,\n/**/\n    2127,\n/**/\n    2126,\n/**/\n    2125,\n/**/\n    2124,\n/**/\n    2123,\n/**/\n    2122,\n/**/\n    2121,\n/**/\n    2120,\n/**/\n    2119,\n/**/\n    2118,\n/**/\n    2117,\n/**/\n    2116,\n/**/\n    2115,\n/**/\n    2114,\n/**/\n    2113,\n/**/\n    2112,\n/**/\n    2111,\n/**/\n    2110,\n/**/\n    2109,\n/**/\n    2108,\n/**/\n    2107,\n/**/\n    2106,\n/**/\n    2105,\n/**/\n    2104,\n/**/\n    2103,\n/**/\n    2102,\n/**/\n    2101,\n/**/\n    2100,\n/**/\n    2099,\n/**/\n    2098,\n/**/\n    2097,\n/**/\n    2096,\n/**/\n    2095,\n/**/\n    2094,\n/**/\n    2093,\n/**/\n    2092,\n/**/\n    2091,\n/**/\n    2090,\n/**/\n    2089,\n/**/\n    2088,\n/**/\n    2087,\n/**/\n    2086,\n/**/\n    2085,\n/**/\n    2084,\n/**/\n    2083,\n/**/\n    2082,\n/**/\n    2081,\n/**/\n    2080,\n/**/\n    2079,\n/**/\n    2078,\n/**/\n    2077,\n/**/\n    2076,\n/**/\n    2075,\n/**/\n    2074,\n/**/\n    2073,\n/**/\n    2072,\n/**/\n    2071,\n/**/\n    2070,\n/**/\n    2069,\n/**/\n    2068,\n/**/\n    2067,\n/**/\n    2066,\n/**/\n    2065,\n/**/\n    2064,\n/**/\n    2063,\n/**/\n    2062,\n/**/\n    2061,\n/**/\n    2060,\n/**/\n    2059,\n/**/\n    2058,\n/**/\n    2057,\n/**/\n    2056,\n/**/\n    2055,\n/**/\n    2054,\n/**/\n    2053,\n/**/\n    2052,\n/**/\n    2051,\n/**/\n    2050,\n/**/\n    2049,\n/**/\n    2048,\n/**/\n    2047,\n/**/\n    2046,\n/**/\n    2045,\n/**/\n    2044,\n/**/\n    2043,\n/**/\n    2042,\n/**/\n    2041,\n/**/\n    2040,\n/**/\n    2039,\n/**/\n    2038,\n/**/\n    2037,\n/**/\n    2036,\n/**/\n    2035,\n/**/\n    2034,\n/**/\n    2033,\n/**/\n    2032,\n/**/\n    2031,\n/**/\n    2030,\n/**/\n    2029,\n/**/\n    2028,\n/**/\n    2027,\n/**/\n    2026,\n/**/\n    2025,\n/**/\n    2024,\n/**/\n    2023,\n/**/\n    2022,\n/**/\n    2021,\n/**/\n    2020,\n/**/\n    2019,\n/**/\n    2018,\n/**/\n    2017,\n/**/\n    2016,\n/**/\n    2015,\n/**/\n    2014,\n/**/\n    2013,\n/**/\n    2012,\n/**/\n    2011,\n/**/\n    2010,\n/**/\n    2009,\n/**/\n    2008,\n/**/\n    2007,\n/**/\n    2006,\n/**/\n    2005,\n/**/\n    2004,\n/**/\n    2003,\n/**/\n    2002,\n/**/\n    2001,\n/**/\n    2000,\n/**/\n    1999,\n/**/\n    1998,\n/**/\n    1997,\n/**/\n    1996,\n/**/\n    1995,\n/**/\n    1994,\n/**/\n    1993,\n/**/\n    1992,\n/**/\n    1991,\n/**/\n    1990,\n/**/\n    1989,\n/**/\n    1988,\n/**/\n    1987,\n/**/\n    1986,\n/**/\n    1985,\n/**/\n    1984,\n/**/\n    1983,\n/**/\n    1982,\n/**/\n    1981,\n/**/\n    1980,\n/**/\n    1979,\n/**/\n    1978,\n/**/\n    1977,\n/**/\n    1976,\n/**/\n    1975,\n/**/\n    1974,\n/**/\n    1973,\n/**/\n    1972,\n/**/\n    1971,\n/**/\n    1970,\n/**/\n    1969,\n/**/\n    1968,\n/**/\n    1967,\n/**/\n    1966,\n/**/\n    1965,\n/**/\n    1964,\n/**/\n    1963,\n/**/\n    1962,\n/**/\n    1961,\n/**/\n    1960,\n/**/\n    1959,\n/**/\n    1958,\n/**/\n    1957,\n/**/\n    1956,\n/**/\n    1955,\n/**/\n    1954,\n/**/\n    1953,\n/**/\n    1952,\n/**/\n    1951,\n/**/\n    1950,\n/**/\n    1949,\n/**/\n    1948,\n/**/\n    1947,\n/**/\n    1946,\n/**/\n    1945,\n/**/\n    1944,\n/**/\n    1943,\n/**/\n    1942,\n/**/\n    1941,\n/**/\n    1940,\n/**/\n    1939,\n/**/\n    1938,\n/**/\n    1937,\n/**/\n    1936,\n/**/\n    1935,\n/**/\n    1934,\n/**/\n    1933,\n/**/\n    1932,\n/**/\n    1931,\n/**/\n    1930,\n/**/\n    1929,\n/**/\n    1928,\n/**/\n    1927,\n/**/\n    1926,\n/**/\n    1925,\n/**/\n    1924,\n/**/\n    1923,\n/**/\n    1922,\n/**/\n    1921,\n/**/\n    1920,\n/**/\n    1919,\n/**/\n    1918,\n/**/\n    1917,\n/**/\n    1916,\n/**/\n    1915,\n/**/\n    1914,\n/**/\n    1913,\n/**/\n    1912,\n/**/\n    1911,\n/**/\n    1910,\n/**/\n    1909,\n/**/\n    1908,\n/**/\n    1907,\n/**/\n    1906,\n/**/\n    1905,\n/**/\n    1904,\n/**/\n    1903,\n/**/\n    1902,\n/**/\n    1901,\n/**/\n    1900,\n/**/\n    1899,\n/**/\n    1898,\n/**/\n    1897,\n/**/\n    1896,\n/**/\n    1895,\n/**/\n    1894,\n/**/\n    1893,\n/**/\n    1892,\n/**/\n    1891,\n/**/\n    1890,\n/**/\n    1889,\n/**/\n    1888,\n/**/\n    1887,\n/**/\n    1886,\n/**/\n    1885,\n/**/\n    1884,\n/**/\n    1883,\n/**/\n    1882,\n/**/\n    1881,\n/**/\n    1880,\n/**/\n    1879,\n/**/\n    1878,\n/**/\n    1877,\n/**/\n    1876,\n/**/\n    1875,\n/**/\n    1874,\n/**/\n    1873,\n/**/\n    1872,\n/**/\n    1871,\n/**/\n    1870,\n/**/\n    1869,\n/**/\n    1868,\n/**/\n    1867,\n/**/\n    1866,\n/**/\n    1865,\n/**/\n    1864,\n/**/\n    1863,\n/**/\n    1862,\n/**/\n    1861,\n/**/\n    1860,\n/**/\n    1859,\n/**/\n    1858,\n/**/\n    1857,\n/**/\n    1856,\n/**/\n    1855,\n/**/\n    1854,\n/**/\n    1853,\n/**/\n    1852,\n/**/\n    1851,\n/**/\n    1850,\n/**/\n    1849,\n/**/\n    1848,\n/**/\n    1847,\n/**/\n    1846,\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    while (l < h)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + (item_count % ncol ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#ifdef FEAT_HUGE\n    msg_puts(_(\"\\nHuge version \"));\n#else\n# ifdef FEAT_BIG\n    msg_puts(_(\"\\nBig version \"));\n# else\n#  ifdef FEAT_NORMAL\n    msg_puts(_(\"\\nNormal version \"));\n#  else\n#   ifdef FEAT_SMALL\n    msg_puts(_(\"\\nSmall version \"));\n#   else\n    msg_puts(_(\"\\nTiny version \"));\n#   endif\n#  endif\n# endif\n#endif\n#ifndef FEAT_GUI\n    msg_puts(_(\"without GUI.\"));\n#else\n# ifdef FEAT_GUI_GTK\n#  ifdef USE_GTK3\n    msg_puts(_(\"with GTK3 GUI.\"));\n#  else\n#   ifdef FEAT_GUI_GNOME\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n#   else\n     msg_puts(_(\"with GTK2 GUI.\"));\n#   endif\n# endif\n# else\n#  ifdef FEAT_GUI_MOTIF\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#  else\n#   ifdef FEAT_GUI_ATHENA\n#    ifdef FEAT_GUI_NEXTAW\n    msg_puts(_(\"with X11-neXtaw GUI.\"));\n#    else\n    msg_puts(_(\"with X11-Athena GUI.\"));\n#    endif\n#   else\n#    ifdef FEAT_GUI_HAIKU\n    msg_puts(_(\"with Haiku GUI.\"));\n#    else\n#     ifdef FEAT_GUI_PHOTON\n    msg_puts(_(\"with Photon GUI.\"));\n#     else\n#      if defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#      endif\n#     endif\n#    endif\n#   endif\n#  endif\n# endif\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version8<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * vim9compile.c: compiling a :def function\n */\n\n#define USING_FLOAT_STUFF\n#include \"vim.h\"\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n\n// When not generating protos this is included in proto.h\n#ifdef PROTO\n# include \"vim9.h\"\n#endif\n\n// Functions defined with :def are stored in this growarray.\n// They are never removed, so that they can be found by index.\n// Deleted functions have the df_deleted flag set.\ngarray_T def_functions = {0, 0, sizeof(dfunc_T), 50, NULL};\n\nstatic void delete_def_function_contents(dfunc_T *dfunc, int mark_deleted);\n\n/*\n * Lookup variable \"name\" in the local scope and return it in \"lvar\".\n * \"lvar->lv_from_outer\" is incremented accordingly.\n * If \"lvar\" is NULL only check if the variable can be found.\n * Return FAIL if not found.\n */\n    int\nlookup_local(char_u *name, size_t len, lvar_T *lvar, cctx_T *cctx)\n{\n    int\t    idx;\n    lvar_T  *lvp;\n\n    if (len == 0)\n\treturn FAIL;\n\n    // Find local in current function scope.\n    for (idx = 0; idx < cctx->ctx_locals.ga_len; ++idx)\n    {\n\tlvp = ((lvar_T *)cctx->ctx_locals.ga_data) + idx;\n\tif (STRNCMP(name, lvp->lv_name, len) == 0\n\t\t\t\t\t       && STRLEN(lvp->lv_name) == len)\n\t{\n\t    if (lvar != NULL)\n\t    {\n\t\t*lvar = *lvp;\n\t\tlvar->lv_from_outer = 0;\n\t    }\n\t    return OK;\n\t}\n    }\n\n    // Find local in outer function scope.\n    if (cctx->ctx_outer != NULL)\n    {\n\tif (lookup_local(name, len, lvar, cctx->ctx_outer) == OK)\n\t{\n\t    if (lvar != NULL)\n\t    {\n\t\tcctx->ctx_outer_used = TRUE;\n\t\t++lvar->lv_from_outer;\n\t    }\n\t    return OK;\n\t}\n    }\n\n    return FAIL;\n}\n\n/*\n * Lookup an argument in the current function and an enclosing function.\n * Returns the argument index in \"idxp\"\n * Returns the argument type in \"type\"\n * Sets \"gen_load_outer\" to TRUE if found in outer scope.\n * Returns OK when found, FAIL otherwise.\n */\n    int\narg_exists(\n\tchar_u\t*name,\n\tsize_t\tlen,\n\tint\t*idxp,\n\ttype_T\t**type,\n\tint\t*gen_load_outer,\n\tcctx_T\t*cctx)\n{\n    int\t    idx;\n    char_u  *va_name;\n\n    if (len == 0)\n\treturn FAIL;\n    for (idx = 0; idx < cctx->ctx_ufunc->uf_args_visible; ++idx)\n    {\n\tchar_u *arg = FUNCARG(cctx->ctx_ufunc, idx);\n\n\tif (STRNCMP(name, arg, len) == 0 && arg[len] == NUL)\n\t{\n\t    if (idxp != NULL)\n\t    {\n\t\t// Arguments are located above the frame pointer.  One further\n\t\t// if there is a vararg argument\n\t\t*idxp = idx - (cctx->ctx_ufunc->uf_args.ga_len\n\t\t\t\t\t\t\t    + STACK_FRAME_SIZE)\n\t\t\t      + (cctx->ctx_ufunc->uf_va_name != NULL ? -1 : 0);\n\n\t\tif (cctx->ctx_ufunc->uf_arg_types != NULL)\n\t\t    *type = cctx->ctx_ufunc->uf_arg_types[idx];\n\t\telse\n\t\t    *type = &t_any;\n\t    }\n\t    return OK;\n\t}\n    }\n\n    va_name = cctx->ctx_ufunc->uf_va_name;\n    if (va_name != NULL\n\t\t    && STRNCMP(name, va_name, len) == 0 && va_name[len] == NUL)\n    {\n\tif (idxp != NULL)\n\t{\n\t    // varargs is always the last argument\n\t    *idxp = -STACK_FRAME_SIZE - 1;\n\t    *type = cctx->ctx_ufunc->uf_va_type;\n\t}\n\treturn OK;\n    }\n\n    if (cctx->ctx_outer != NULL)\n    {\n\t// Lookup the name for an argument of the outer function.\n\tif (arg_exists(name, len, idxp, type, gen_load_outer, cctx->ctx_outer)\n\t\t\t\t\t\t\t\t\t == OK)\n\t{\n\t    if (gen_load_outer != NULL)\n\t\t++*gen_load_outer;\n\t    return OK;\n\t}\n    }\n\n    return FAIL;\n}\n\n/*\n * Lookup a script-local variable in the current script, possibly defined in a\n * block that contains the function \"cctx->ctx_ufunc\".\n * \"cctx\" is NULL at the script level.\n * If \"len\" is <= 0 \"name\" must be NUL terminated.\n * Return NULL when not found.\n */\n    static sallvar_T *\nfind_script_var(char_u *name, size_t len, cctx_T *cctx)\n{\n    scriptitem_T    *si = SCRIPT_ITEM(current_sctx.sc_sid);\n    hashitem_T\t    *hi;\n    int\t\t    cc;\n    sallvar_T\t    *sav;\n    sallvar_T\t    *found_sav;\n    ufunc_T\t    *ufunc;\n\n    // Find the list of all script variables with the right name.\n    if (len > 0)\n    {\n\tcc = name[len];\n\tname[len] = NUL;\n    }\n    hi = hash_find(&si->sn_all_vars.dv_hashtab, name);\n    if (len > 0)\n\tname[len] = cc;\n    if (HASHITEM_EMPTY(hi))\n\treturn NULL;\n\n    sav = HI2SAV(hi);\n    if (sav->sav_block_id == 0)\n\t// variable defined in the top script scope is always visible\n\treturn sav;\n\n    if (cctx == NULL)\n    {\n\t// Not in a function scope, find variable with block id equal to or\n\t// smaller than the current block id.\n\twhile (sav != NULL)\n\t{\n\t    if (sav->sav_block_id <= si->sn_current_block_id)\n\t\tbreak;\n\t    sav = sav->sav_next;\n\t}\n\treturn sav;\n    }\n\n    // Go over the variables with this name and find one that was visible\n    // from the function.\n    ufunc = cctx->ctx_ufunc;\n    found_sav = sav;\n    while (sav != NULL)\n    {\n\tint idx;\n\n\t// Go over the blocks that this function was defined in.  If the\n\t// variable block ID matches it was visible to the function.\n\tfor (idx = 0; idx < ufunc->uf_block_depth; ++idx)\n\t    if (ufunc->uf_block_ids[idx] == sav->sav_block_id)\n\t\treturn sav;\n\tsav = sav->sav_next;\n    }\n\n    // Not found, assume variable at script level was visible.\n    return found_sav;\n}\n\n/*\n * Return TRUE if the script context is Vim9 script.\n */\n    int\nscript_is_vim9()\n{\n    return SCRIPT_ITEM(current_sctx.sc_sid)->sn_version == SCRIPT_VERSION_VIM9;\n}\n\n/*\n * Lookup a variable (without s: prefix) in the current script.\n * \"cctx\" is NULL at the script level.\n * Returns OK or FAIL.\n */\n    int\nscript_var_exists(char_u *name, size_t len, cctx_T *cctx)\n{\n    if (current_sctx.sc_sid <= 0)\n\treturn FAIL;\n    if (script_is_vim9())\n    {\n\t// Check script variables that were visible where the function was\n\t// defined.\n\tif (find_script_var(name, len, cctx) != NULL)\n\t    return OK;\n    }\n    else\n    {\n\thashtab_T\t*ht = &SCRIPT_VARS(current_sctx.sc_sid);\n\tdictitem_T\t*di;\n\tint\t\tcc;\n\n\t// Check script variables that are currently visible\n\tcc = name[len];\n\tname[len] = NUL;\n\tdi = find_var_in_ht(ht, 0, name, TRUE);\n\tname[len] = cc;\n\tif (di != NULL)\n\t    return OK;\n    }\n\n    return FAIL;\n}\n\n/*\n * Return TRUE if \"name\" is a local variable, argument, script variable or\n * imported.\n */\n    static int\nvariable_exists(char_u *name, size_t len, cctx_T *cctx)\n{\n    return (cctx != NULL\n\t\t&& (lookup_local(name, len, NULL, cctx) == OK\n\t\t    || arg_exists(name, len, NULL, NULL, NULL, cctx) == OK))\n\t    || script_var_exists(name, len, cctx) == OK\n\t    || find_imported(name, len, cctx) != NULL;\n}\n\n/*\n * Return TRUE if \"name\" is a local variable, argument, script variable,\n * imported or function.\n */\n    static int\nitem_exists(char_u *name, size_t len, int cmd UNUSED, cctx_T *cctx)\n{\n    int\t    is_global;\n    char_u  *p;\n\n    if (variable_exists(name, len, cctx))\n\treturn TRUE;\n\n    // This is similar to what is in lookup_scriptitem():\n    // Find a function, so that a following \"->\" works.\n    // Require \"(\" or \"->\" to follow, \"Cmd\" is a user command while \"Cmd()\" is\n    // a function call.\n    p = skipwhite(name + len);\n\n    if (name[len] == '(' || (p[0] == '-' && p[1] == '>'))\n    {\n\t// Do not check for an internal function, since it might also be a\n\t// valid command, such as \":split\" versus \"split()\".\n\t// Skip \"g:\" before a function name.\n\tis_global = (name[0] == 'g' && name[1] == ':');\n\treturn find_func(is_global ? name + 2 : name, is_global, cctx) != NULL;\n    }\n    return FALSE;\n}\n\n/*\n * Check if \"p[len]\" is already defined, either in script \"import_sid\" or in\n * compilation context \"cctx\".  \"cctx\" is NULL at the script level.\n * Does not check the global namespace.\n * If \"is_arg\" is TRUE the error message is for an argument name.\n * Return FAIL and give an error if it defined.\n */\n    int\ncheck_defined(char_u *p, size_t len, cctx_T *cctx, int is_arg)\n{\n    int\t\tc = p[len];\n    ufunc_T\t*ufunc = NULL;\n\n    // underscore argument is OK\n    if (len == 1 && *p == '_')\n\treturn OK;\n\n    if (script_var_exists(p, len, cctx) == OK)\n    {\n\tif (is_arg)\n\t    semsg(_(e_argument_already_declared_in_script_str), p);\n\telse\n\t    semsg(_(e_variable_already_declared_in_script_str), p);\n\treturn FAIL;\n    }\n\n    p[len] = NUL;\n    if ((cctx != NULL\n\t\t&& (lookup_local(p, len, NULL, cctx) == OK\n\t\t    || arg_exists(p, len, NULL, NULL, NULL, cctx) == OK))\n\t    || find_imported(p, len, cctx) != NULL\n\t    || (ufunc = find_func_even_dead(p, FALSE, cctx)) != NULL)\n    {\n\t// A local or script-local function can shadow a global function.\n\tif (ufunc == NULL || ((ufunc->uf_flags & FC_DEAD) == 0\n\t\t    && (!func_is_global(ufunc)\n\t\t\t\t\t     || (p[0] == 'g' && p[1] == ':'))))\n\t{\n\t    if (is_arg)\n\t\tsemsg(_(e_argument_name_shadows_existing_variable_str), p);\n\t    else\n\t\tsemsg(_(e_name_already_defined_str), p);\n\t    p[len] = c;\n\t    return FAIL;\n\t}\n    }\n    p[len] = c;\n    return OK;\n}\n\n\n/*\n * Return TRUE if \"actual\" could be \"expected\" and a runtime typecheck is to be\n * used.  Return FALSE if the types will never match.\n */\n    static int\nuse_typecheck(type_T *actual, type_T *expected)\n{\n    if (actual->tt_type == VAR_ANY\n\t    || actual->tt_type == VAR_UNKNOWN\n\t    || (actual->tt_type == VAR_FUNC\n\t\t&& (expected->tt_type == VAR_FUNC\n\t\t\t\t\t   || expected->tt_type == VAR_PARTIAL)\n\t\t&& (actual->tt_member == &t_any\n\t\t    || actual->tt_member == &t_unknown\n\t\t    || actual->tt_argcount < 0)\n\t\t&& (actual->tt_member == &t_unknown ||\n\t\t    (actual->tt_member == &t_void)\n\t\t\t\t\t == (expected->tt_member == &t_void))))\n\treturn TRUE;\n    if ((actual->tt_type == VAR_LIST || actual->tt_type == VAR_DICT)\n\t\t\t\t       && actual->tt_type == expected->tt_type)\n\t// This takes care of a nested list or dict.\n\treturn use_typecheck(actual->tt_member, expected->tt_member);\n    return FALSE;\n}\n\n/*\n * Check that\n * - \"actual\" matches \"expected\" type or\n * - \"actual\" is a type that can be \"expected\" type: add a runtime check; or\n * - return FAIL.\n * If \"actual_is_const\" is TRUE then the type won't change at runtime, do not\n * generate a TYPECHECK.\n */\n    static int\nneed_type_where(\n\ttype_T\t*actual,\n\ttype_T\t*expected,\n\tint\toffset,\n\twhere_T\twhere,\n\tcctx_T\t*cctx,\n\tint\tsilent,\n\tint\tactual_is_const)\n{\n    int ret;\n\n    if (expected == &t_bool && actual != &t_bool\n\t\t\t\t\t&& (actual->tt_flags & TTFLAG_BOOL_OK))\n    {\n\t// Using \"0\", \"1\" or the result of an expression with \"&&\" or \"||\" as a\n\t// boolean is OK but requires a conversion.\n\tgenerate_2BOOL(cctx, FALSE, offset);\n\treturn OK;\n    }\n\n    ret = check_type_maybe(expected, actual, FALSE, where);\n    if (ret == OK)\n\treturn OK;\n\n    // If the actual type can be the expected type add a runtime check.\n    // If it's a constant a runtime check makes no sense.\n    if (!actual_is_const && ret == MAYBE && use_typecheck(actual, expected))\n    {\n\tgenerate_TYPECHECK(cctx, expected, offset, where.wt_index);\n\treturn OK;\n    }\n\n    if (!silent)\n\ttype_mismatch_where(expected, actual, where);\n    return FAIL;\n}\n\n    int\nneed_type(\n\ttype_T\t*actual,\n\ttype_T\t*expected,\n\tint\toffset,\n\tint\targ_idx,\n\tcctx_T\t*cctx,\n\tint\tsilent,\n\tint\tactual_is_const)\n{\n    where_T where = WHERE_INIT;\n\n    where.wt_index = arg_idx;\n    return need_type_where(actual, expected, offset, where,\n\t\t\t\t\t\tcctx, silent, actual_is_const);\n}\n\n/*\n * Reserve space for a local variable.\n * Return the variable or NULL if it failed.\n */\n    lvar_T *\nreserve_local(\n\tcctx_T\t*cctx,\n\tchar_u\t*name,\n\tsize_t\tlen,\n\tint\tisConst,\n\ttype_T\t*type)\n{\n    lvar_T  *lvar;\n    dfunc_T *dfunc;\n\n    if (arg_exists(name, len, NULL, NULL, NULL, cctx) == OK)\n    {\n\temsg_namelen(_(e_str_is_used_as_argument), name, (int)len);\n\treturn NULL;\n    }\n\n    if (GA_GROW_FAILS(&cctx->ctx_locals, 1))\n\treturn NULL;\n    lvar = ((lvar_T *)cctx->ctx_locals.ga_data) + cctx->ctx_locals.ga_len++;\n    CLEAR_POINTER(lvar);\n\n    // Every local variable uses the next entry on the stack.  We could re-use\n    // the last ones when leaving a scope, but then variables used in a closure\n    // might get overwritten.  To keep things simple do not re-use stack\n    // entries.  This is less efficient, but memory is cheap these days.\n    dfunc = ((dfunc_T *)def_functions.ga_data) + cctx->ctx_ufunc->uf_dfunc_idx;\n    lvar->lv_idx = dfunc->df_var_names.ga_len;\n\n    lvar->lv_name = vim_strnsave(name, len == 0 ? STRLEN(name) : len);\n    lvar->lv_const = isConst;\n    lvar->lv_type = type;\n\n    // Remember the name for debugging.\n    if (GA_GROW_FAILS(&dfunc->df_var_names, 1))\n\treturn NULL;\n    ((char_u **)dfunc->df_var_names.ga_data)[lvar->lv_idx] =\n\t\t\t\t\t\t    vim_strsave(lvar->lv_name);\n    ++dfunc->df_var_names.ga_len;\n\n    return lvar;\n}\n\n/*\n * If \"check_writable\" is ASSIGN_CONST give an error if the variable was\n * defined with :final or :const, if \"check_writable\" is ASSIGN_FINAL give an\n * error if the variable was defined with :const.\n */\n    static int\ncheck_item_writable(svar_T *sv, int check_writable, char_u *name)\n{\n    if ((check_writable == ASSIGN_CONST && sv->sv_const != 0)\n\t    || (check_writable == ASSIGN_FINAL\n\t\t\t\t\t      && sv->sv_const == ASSIGN_CONST))\n    {\n\tsemsg(_(e_cannot_change_readonly_variable_str), name);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Find \"name\" in script-local items of script \"sid\".\n * Pass \"check_writable\" to check_item_writable().\n * Returns the index in \"sn_var_vals\" if found.\n * If found but not in \"sn_var_vals\" returns -1.\n * If not found or the variable is not writable returns -2.\n */\n    int\nget_script_item_idx(int sid, char_u *name, int check_writable, cctx_T *cctx)\n{\n    hashtab_T\t    *ht;\n    dictitem_T\t    *di;\n    scriptitem_T    *si = SCRIPT_ITEM(sid);\n    svar_T\t    *sv;\n    int\t\t    idx;\n\n    if (!SCRIPT_ID_VALID(sid))\n\treturn -1;\n    if (sid == current_sctx.sc_sid)\n    {\n\tsallvar_T *sav = find_script_var(name, 0, cctx);\n\n\tif (sav == NULL)\n\t    return -2;\n\tidx = sav->sav_var_vals_idx;\n\tsv = ((svar_T *)si->sn_var_vals.ga_data) + idx;\n\tif (check_item_writable(sv, check_writable, name) == FAIL)\n\t    return -2;\n\treturn idx;\n    }\n\n    // First look the name up in the hashtable.\n    ht = &SCRIPT_VARS(sid);\n    di = find_var_in_ht(ht, 0, name, TRUE);\n    if (di == NULL)\n\treturn -2;\n\n    // Now find the svar_T index in sn_var_vals.\n    for (idx = 0; idx < si->sn_var_vals.ga_len; ++idx)\n    {\n\tsv = ((svar_T *)si->sn_var_vals.ga_data) + idx;\n\tif (sv->sv_tv == &di->di_tv)\n\t{\n\t    if (check_item_writable(sv, check_writable, name) == FAIL)\n\t\treturn -2;\n\t    return idx;\n\t}\n    }\n    return -1;\n}\n\n/*\n * Find \"name\" in imported items of the current script or in \"cctx\" if not\n * NULL.\n */\n    imported_T *\nfind_imported(char_u *name, size_t len, cctx_T *cctx)\n{\n    int\t\t    idx;\n\n    if (!SCRIPT_ID_VALID(current_sctx.sc_sid))\n\treturn NULL;\n    if (cctx != NULL)\n\tfor (idx = 0; idx < cctx->ctx_imports.ga_len; ++idx)\n\t{\n\t    imported_T *import = ((imported_T *)cctx->ctx_imports.ga_data)\n\t\t\t\t\t\t\t\t\t + idx;\n\n\t    if (len == 0 ? STRCMP(name, import->imp_name) == 0\n\t\t\t : STRLEN(import->imp_name) == len\n\t\t\t\t  && STRNCMP(name, import->imp_name, len) == 0)\n\t\treturn import;\n\t}\n\n    return find_imported_in_script(name, len, current_sctx.sc_sid);\n}\n\n    imported_T *\nfind_imported_in_script(char_u *name, size_t len, int sid)\n{\n    scriptitem_T    *si;\n    int\t\t    idx;\n\n    if (!SCRIPT_ID_VALID(sid))\n\treturn NULL;\n    si = SCRIPT_ITEM(sid);\n    for (idx = 0; idx < si->sn_imports.ga_len; ++idx)\n    {\n\timported_T *import = ((imported_T *)si->sn_imports.ga_data) + idx;\n\n\tif (len == 0 ? STRCMP(name, import->imp_name) == 0\n\t\t     : STRLEN(import->imp_name) == len\n\t\t\t\t  && STRNCMP(name, import->imp_name, len) == 0)\n\t    return import;\n    }\n    return NULL;\n}\n\n/*\n * Free all imported variables.\n */\n    static void\nfree_imported(cctx_T *cctx)\n{\n    int idx;\n\n    for (idx = 0; idx < cctx->ctx_imports.ga_len; ++idx)\n    {\n\timported_T *import = ((imported_T *)cctx->ctx_imports.ga_data) + idx;\n\n\tvim_free(import->imp_name);\n    }\n    ga_clear(&cctx->ctx_imports);\n}\n\n/*\n * Called when checking for a following operator at \"arg\".  When the rest of\n * the line is empty or only a comment, peek the next line.  If there is a next\n * line return a pointer to it and set \"nextp\".\n * Otherwise skip over white space.\n */\n    char_u *\nmay_peek_next_line(cctx_T *cctx, char_u *arg, char_u **nextp)\n{\n    char_u *p = skipwhite(arg);\n\n    *nextp = NULL;\n    if (*p == NUL || (VIM_ISWHITE(*arg) && vim9_comment_start(p)))\n    {\n\t*nextp = peek_next_line_from_context(cctx);\n\tif (*nextp != NULL)\n\t    return *nextp;\n    }\n    return p;\n}\n\n/*\n * Return a pointer to the next line that isn't empty or only contains a\n * comment. Skips over white space.\n * Returns NULL if there is none.\n */\n    char_u *\npeek_next_line_from_context(cctx_T *cctx)\n{\n    int lnum = cctx->ctx_lnum;\n\n    while (++lnum < cctx->ctx_ufunc->uf_lines.ga_len)\n    {\n\tchar_u *line = ((char_u **)cctx->ctx_ufunc->uf_lines.ga_data)[lnum];\n\tchar_u *p;\n\n\t// ignore NULLs inserted for continuation lines\n\tif (line != NULL)\n\t{\n\t    p = skipwhite(line);\n\t    if (vim9_bad_comment(p))\n\t\treturn NULL;\n\t    if (*p != NUL && !vim9_comment_start(p))\n\t\treturn p;\n\t}\n    }\n    return NULL;\n}\n\n/*\n * Get the next line of the function from \"cctx\".\n * Skips over empty lines.  Skips over comment lines if \"skip_comment\" is TRUE.\n * Returns NULL when at the end.\n */\n    char_u *\nnext_line_from_context(cctx_T *cctx, int skip_comment)\n{\n    char_u\t*line;\n\n    do\n    {\n\t++cctx->ctx_lnum;\n\tif (cctx->ctx_lnum >= cctx->ctx_ufunc->uf_lines.ga_len)\n\t{\n\t    line = NULL;\n\t    break;\n\t}\n\tline = ((char_u **)cctx->ctx_ufunc->uf_lines.ga_data)[cctx->ctx_lnum];\n\tcctx->ctx_line_start = line;\n\tSOURCING_LNUM = cctx->ctx_lnum + 1;\n    } while (line == NULL || *skipwhite(line) == NUL\n\t\t     || (skip_comment && vim9_comment_start(skipwhite(line))));\n    return line;\n}\n\n/*\n * Skip over white space at \"whitep\" and assign to \"*arg\".\n * If \"*arg\" is at the end of the line, advance to the next line.\n * Also when \"whitep\" points to white space and \"*arg\" is on a \"#\".\n * Return FAIL if beyond the last line, \"*arg\" is unmodified then.\n */\n    int\nmay_get_next_line(char_u *whitep, char_u **arg, cctx_T *cctx)\n{\n    *arg = skipwhite(whitep);\n    if (vim9_bad_comment(*arg))\n\treturn FAIL;\n    if (**arg == NUL || (VIM_ISWHITE(*whitep) && vim9_comment_start(*arg)))\n    {\n\tchar_u *next = next_line_from_context(cctx, TRUE);\n\n\tif (next == NULL)\n\t    return FAIL;\n\t*arg = skipwhite(next);\n    }\n    return OK;\n}\n\n/*\n * Idem, and give an error when failed.\n */\n    int\nmay_get_next_line_error(char_u *whitep, char_u **arg, cctx_T *cctx)\n{\n    if (may_get_next_line(whitep, arg, cctx) == FAIL)\n    {\n\tSOURCING_LNUM = cctx->ctx_lnum + 1;\n\temsg(_(e_line_incomplete));\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Get a line from the compilation context, compatible with exarg_T getline().\n * Return a pointer to the line in allocated memory.\n * Return NULL for end-of-file or some error.\n */\n    static char_u *\nexarg_getline(\n\tint c UNUSED,\n\tvoid *cookie,\n\tint indent UNUSED,\n\tgetline_opt_T options UNUSED)\n{\n    cctx_T  *cctx = (cctx_T *)cookie;\n    char_u  *p;\n\n    for (;;)\n    {\n\tif (cctx->ctx_lnum >= cctx->ctx_ufunc->uf_lines.ga_len - 1)\n\t    return NULL;\n\t++cctx->ctx_lnum;\n\tp = ((char_u **)cctx->ctx_ufunc->uf_lines.ga_data)[cctx->ctx_lnum];\n\t// Comment lines result in NULL pointers, skip them.\n\tif (p != NULL)\n\t    return vim_strsave(p);\n    }\n}\n\n    void\nfill_exarg_from_cctx(exarg_T *eap, cctx_T *cctx)\n{\n    eap->getline = exarg_getline;\n    eap->cookie = cctx;\n}\n\n/*\n * Return TRUE if \"ufunc\" should be compiled, taking into account whether\n * \"profile\" indicates profiling is to be done.\n */\n    int\nfunc_needs_compiling(ufunc_T *ufunc, compiletype_T compile_type)\n{\n    switch (ufunc->uf_def_status)\n    {\n\tcase UF_TO_BE_COMPILED:\n\t    return TRUE;\n\n\tcase UF_COMPILED:\n\t{\n\t    dfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t + ufunc->uf_dfunc_idx;\n\n\t    switch (compile_type)\n\t    {\n\t\tcase CT_PROFILE:\n#ifdef FEAT_PROFILE\n\t\t    return dfunc->df_instr_prof == NULL;\n#endif\n\t\tcase CT_NONE:\n\t\t    return dfunc->df_instr == NULL;\n\t\tcase CT_DEBUG:\n\t\t    return dfunc->df_instr_debug == NULL;\n\t    }\n\t}\n\n\tcase UF_NOT_COMPILED:\n\tcase UF_COMPILE_ERROR:\n\tcase UF_COMPILING:\n\t    break;\n    }\n    return FALSE;\n}\n\n/*\n * Compile a nested :def command.\n */\n    static char_u *\ncompile_nested_function(exarg_T *eap, cctx_T *cctx)\n{\n    int\t\tis_global = *eap->arg == 'g' && eap->arg[1] == ':';\n    char_u\t*name_start = eap->arg;\n    char_u\t*name_end = to_name_end(eap->arg, TRUE);\n    char_u\t*lambda_name;\n    ufunc_T\t*ufunc;\n    int\t\tr = FAIL;\n    compiletype_T   compile_type;\n\n    if (eap->forceit)\n    {\n\temsg(_(e_cannot_use_bang_with_nested_def));\n\treturn NULL;\n    }\n\n    if (*name_start == '/')\n    {\n\tname_end = skip_regexp(name_start + 1, '/', TRUE);\n\tif (*name_end == '/')\n\t    ++name_end;\n\tset_nextcmd(eap, name_end);\n    }\n    if (name_end == name_start || *skipwhite(name_end) != '(')\n    {\n\tif (!ends_excmd2(name_start, name_end))\n\t{\n\t    semsg(_(e_invalid_command_str), eap->cmd);\n\t    return NULL;\n\t}\n\n\t// \"def\" or \"def Name\": list functions\n\tif (generate_DEF(cctx, name_start, name_end - name_start) == FAIL)\n\t    return NULL;\n\treturn eap->nextcmd == NULL ? (char_u *)\"\" : eap->nextcmd;\n    }\n\n    // Only g:Func() can use a namespace.\n    if (name_start[1] == ':' && !is_global)\n    {\n\tsemsg(_(e_namespace_not_supported_str), name_start);\n\treturn NULL;\n    }\n    if (check_defined(name_start, name_end - name_start, cctx, FALSE) == FAIL)\n\treturn NULL;\n\n    eap->arg = name_end;\n    fill_exarg_from_cctx(eap, cctx);\n\n    eap->forceit = FALSE;\n    // We use the special <Lamba>99 name, but it's not really a lambda.\n    lambda_name = vim_strsave(get_lambda_name());\n    if (lambda_name == NULL)\n\treturn NULL;\n    ufunc = define_function(eap, lambda_name);\n\n    if (ufunc == NULL)\n    {\n\tr = eap->skip ? OK : FAIL;\n\tgoto theend;\n    }\n\n    // copy over the block scope IDs before compiling\n    if (!is_global && cctx->ctx_ufunc->uf_block_depth > 0)\n    {\n\tint block_depth = cctx->ctx_ufunc->uf_block_depth;\n\n\tufunc->uf_block_ids = ALLOC_MULT(int, block_depth);\n\tif (ufunc->uf_block_ids != NULL)\n\t{\n\t    mch_memmove(ufunc->uf_block_ids, cctx->ctx_ufunc->uf_block_ids,\n\t\t\t\t\t\t    sizeof(int) * block_depth);\n\t    ufunc->uf_block_depth = block_depth;\n\t}\n    }\n\n    compile_type = COMPILE_TYPE(ufunc);\n#ifdef FEAT_PROFILE\n    // If the outer function is profiled, also compile the nested function for\n    // profiling.\n    if (cctx->ctx_compile_type == CT_PROFILE)\n\tcompile_type = CT_PROFILE;\n#endif\n    if (func_needs_compiling(ufunc, compile_type)\n\t    && compile_def_function(ufunc, TRUE, compile_type, cctx) == FAIL)\n    {\n\tfunc_ptr_unref(ufunc);\n\tgoto theend;\n    }\n\n#ifdef FEAT_PROFILE\n    // When the outer function is compiled for profiling, the nested function\n    // may be called without profiling.  Compile it here in the right context.\n    if (compile_type == CT_PROFILE && func_needs_compiling(ufunc, CT_NONE))\n\tcompile_def_function(ufunc, FALSE, CT_NONE, cctx);\n#endif\n\n    if (is_global)\n    {\n\tchar_u *func_name = vim_strnsave(name_start + 2,\n\t\t\t\t\t\t    name_end - name_start - 2);\n\n\tif (func_name == NULL)\n\t    r = FAIL;\n\telse\n\t{\n\t    r = generate_NEWFUNC(cctx, lambda_name, func_name);\n\t    lambda_name = NULL;\n\t}\n    }\n    else\n    {\n\t// Define a local variable for the function reference.\n\tlvar_T\t*lvar = reserve_local(cctx, name_start, name_end - name_start,\n\t\t\t\t\t\t    TRUE, ufunc->uf_func_type);\n\n\tif (lvar == NULL)\n\t    goto theend;\n\tif (generate_FUNCREF(cctx, ufunc) == FAIL)\n\t    goto theend;\n\tr = generate_STORE(cctx, ISN_STORE, lvar->lv_idx, NULL);\n    }\n\ntheend:\n    vim_free(lambda_name);\n    return r == FAIL ? NULL : (char_u *)\"\";\n}\n\n/*\n * Return the length of an assignment operator, or zero if there isn't one.\n */\n    int\nassignment_len(char_u *p, int *heredoc)\n{\n    if (*p == '=')\n    {\n\tif (p[1] == '<' && p[2] == '<')\n\t{\n\t    *heredoc = TRUE;\n\t    return 3;\n\t}\n\treturn 1;\n    }\n    if (vim_strchr((char_u *)\"+-*/%\", *p) != NULL && p[1] == '=')\n\treturn 2;\n    if (STRNCMP(p, \"..=\", 3) == 0)\n\treturn 3;\n    return 0;\n}\n\n/*\n * Generate the load instruction for \"name\".\n */\n    static void\ngenerate_loadvar(\n\tcctx_T\t\t*cctx,\n\tassign_dest_T\tdest,\n\tchar_u\t\t*name,\n\tlvar_T\t\t*lvar,\n\ttype_T\t\t*type)\n{\n    switch (dest)\n    {\n\tcase dest_option:\n\tcase dest_func_option:\n\t    generate_LOAD(cctx, ISN_LOADOPT, 0, name, type);\n\t    break;\n\tcase dest_global:\n\t    if (vim_strchr(name, AUTOLOAD_CHAR) == NULL)\n\t\tgenerate_LOAD(cctx, ISN_LOADG, 0, name + 2, type);\n\t    else\n\t\tgenerate_LOAD(cctx, ISN_LOADAUTO, 0, name, type);\n\t    break;\n\tcase dest_buffer:\n\t    generate_LOAD(cctx, ISN_LOADB, 0, name + 2, type);\n\t    break;\n\tcase dest_window:\n\t    generate_LOAD(cctx, ISN_LOADW, 0, name + 2, type);\n\t    break;\n\tcase dest_tab:\n\t    generate_LOAD(cctx, ISN_LOADT, 0, name + 2, type);\n\t    break;\n\tcase dest_script:\n\t    compile_load_scriptvar(cctx,\n\t\t    name + (name[1] == ':' ? 2 : 0), NULL, NULL, TRUE);\n\t    break;\n\tcase dest_env:\n\t    // Include $ in the name here\n\t    generate_LOAD(cctx, ISN_LOADENV, 0, name, type);\n\t    break;\n\tcase dest_reg:\n\t    generate_LOAD(cctx, ISN_LOADREG, name[1], NULL, &t_string);\n\t    break;\n\tcase dest_vimvar:\n\t    generate_LOADV(cctx, name + 2, TRUE);\n\t    break;\n\tcase dest_local:\n\t    if (lvar->lv_from_outer > 0)\n\t\tgenerate_LOADOUTER(cctx, lvar->lv_idx, lvar->lv_from_outer,\n\t\t\t\t\t\t\t\t\t type);\n\t    else\n\t\tgenerate_LOAD(cctx, ISN_LOAD, lvar->lv_idx, NULL, type);\n\t    break;\n\tcase dest_expr:\n\t    // list or dict value should already be on the stack.\n\t    break;\n    }\n}\n\n/*\n * Skip over \"[expr]\" or \".member\".\n * Does not check for any errors.\n */\n    static char_u *\nskip_index(char_u *start)\n{\n    char_u *p = start;\n\n    if (*p == '[')\n    {\n\tp = skipwhite(p + 1);\n\t(void)skip_expr(&p, NULL);\n\tp = skipwhite(p);\n\tif (*p == ']')\n\t    return p + 1;\n\treturn p;\n    }\n    // if (*p == '.')\n    return to_name_end(p + 1, TRUE);\n}\n\n    void\nvim9_declare_error(char_u *name)\n{\n    char *scope = \"\";\n\n    switch (*name)\n    {\n\tcase 'g': scope = _(\"global\"); break;\n\tcase 'b': scope = _(\"buffer\"); break;\n\tcase 'w': scope = _(\"window\"); break;\n\tcase 't': scope = _(\"tab\"); break;\n\tcase 'v': scope = \"v:\"; break;\n\tcase '$': semsg(_(e_cannot_declare_an_environment_variable), name);\n\t\t  return;\n\tcase '&': semsg(_(e_cannot_declare_an_option), name);\n\t\t  return;\n\tcase '@': semsg(_(e_cannot_declare_a_register_str), name);\n\t\t  return;\n\tdefault: return;\n    }\n    semsg(_(e_cannot_declare_a_scope_variable), scope, name);\n}\n\n/*\n * For one assignment figure out the type of destination.  Return it in \"dest\".\n * When not recognized \"dest\" is not set.\n * For an option \"option_scope\" is set.\n * For a v:var \"vimvaridx\" is set.\n * \"type\" is set to the destination type if known, unchanted otherwise.\n * Return FAIL if an error message was given.\n */\n    int\nget_var_dest(\n\tchar_u\t\t*name,\n\tassign_dest_T\t*dest,\n\tint\t\tcmdidx,\n\tint\t\t*option_scope,\n\tint\t\t*vimvaridx,\n\ttype_T\t\t**type,\n\tcctx_T\t\t*cctx)\n{\n    char_u *p;\n\n    if (*name == '&')\n    {\n\tint\t\tcc;\n\tlong\t\tnumval;\n\tgetoption_T\topt_type;\n\tint\t\topt_p_flags;\n\n\t*dest = dest_option;\n\tif (cmdidx == CMD_final || cmdidx == CMD_const)\n\t{\n\t    emsg(_(e_const_option));\n\t    return FAIL;\n\t}\n\tp = name;\n\tp = find_option_end(&p, option_scope);\n\tif (p == NULL)\n\t{\n\t    // cannot happen?\n\t    emsg(_(e_unexpected_characters_in_assignment));\n\t    return FAIL;\n\t}\n\tcc = *p;\n\t*p = NUL;\n\topt_type = get_option_value(skip_option_env_lead(name),\n\t\t\t\t   &numval, NULL, &opt_p_flags, *option_scope);\n\t*p = cc;\n\tswitch (opt_type)\n\t{\n\t    case gov_unknown:\n\t\t    semsg(_(e_unknown_option_str), name);\n\t\t    return FAIL;\n\t    case gov_string:\n\t    case gov_hidden_string:\n\t\t    if (opt_p_flags & P_FUNC)\n\t\t    {\n\t\t\t// might be a Funcref, check the type later\n\t\t\t*type = &t_any;\n\t\t\t*dest = dest_func_option;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t*type = &t_string;\n\t\t    }\n\t\t    break;\n\t    case gov_bool:\n\t    case gov_hidden_bool:\n\t\t    *type = &t_bool;\n\t\t    break;\n\t    case gov_number:\n\t    case gov_hidden_number:\n\t\t    *type = &t_number;\n\t\t    break;\n\t}\n    }\n    else if (*name == '$')\n    {\n\t*dest = dest_env;\n\t*type = &t_string;\n    }\n    else if (*name == '@')\n    {\n\tif (name[1] != '@'\n\t\t\t&& (!valid_yank_reg(name[1], FALSE) || name[1] == '.'))\n\t{\n\t    emsg_invreg(name[1]);\n\t    return FAIL;\n\t}\n\t*dest = dest_reg;\n\t*type = name[1] == '#' ? &t_number_or_string : &t_string;\n    }\n    else if (STRNCMP(name, \"g:\", 2) == 0)\n    {\n\t*dest = dest_global;\n    }\n    else if (STRNCMP(name, \"b:\", 2) == 0)\n    {\n\t*dest = dest_buffer;\n    }\n    else if (STRNCMP(name, \"w:\", 2) == 0)\n    {\n\t*dest = dest_window;\n    }\n    else if (STRNCMP(name, \"t:\", 2) == 0)\n    {\n\t*dest = dest_tab;\n    }\n    else if (STRNCMP(name, \"v:\", 2) == 0)\n    {\n\ttypval_T\t*vtv;\n\tint\t\tdi_flags;\n\n\t*vimvaridx = find_vim_var(name + 2, &di_flags);\n\tif (*vimvaridx < 0)\n\t{\n\t    semsg(_(e_variable_not_found_str), name);\n\t    return FAIL;\n\t}\n\t// We use the current value of \"sandbox\" here, is that OK?\n\tif (var_check_ro(di_flags, name, FALSE))\n\t    return FAIL;\n\t*dest = dest_vimvar;\n\tvtv = get_vim_var_tv(*vimvaridx);\n\t*type = typval2type_vimvar(vtv, cctx->ctx_type_list);\n    }\n    return OK;\n}\n\n    static int\nis_decl_command(int cmdidx)\n{\n    return cmdidx == CMD_let || cmdidx == CMD_var\n\t\t\t\t || cmdidx == CMD_final || cmdidx == CMD_const;\n}\n\n/*\n * Figure out the LHS type and other properties for an assignment or one item\n * of \":unlet\" with an index.\n * Returns OK or FAIL.\n */\n    int\ncompile_lhs(\n\tchar_u\t*var_start,\n\tlhs_T\t*lhs,\n\tint\tcmdidx,\n\tint\theredoc,\n\tint\toplen,\n\tcctx_T\t*cctx)\n{\n    char_u\t*var_end;\n    int\t\tis_decl = is_decl_command(cmdidx);\n\n    CLEAR_POINTER(lhs);\n    lhs->lhs_dest = dest_local;\n    lhs->lhs_vimvaridx = -1;\n    lhs->lhs_scriptvar_idx = -1;\n\n    // \"dest_end\" is the end of the destination, including \"[expr]\" or\n    // \".name\".\n    // \"var_end\" is the end of the variable/option/etc. name.\n    lhs->lhs_dest_end = skip_var_one(var_start, FALSE);\n    if (*var_start == '@')\n\tvar_end = var_start + 2;\n    else\n    {\n\t// skip over the leading \"&\", \"&l:\", \"&g:\" and \"$\"\n\tvar_end = skip_option_env_lead(var_start);\n\tvar_end = to_name_end(var_end, TRUE);\n    }\n\n    // \"a: type\" is declaring variable \"a\" with a type, not dict \"a:\".\n    if (is_decl && lhs->lhs_dest_end == var_start + 2\n\t\t\t\t\t       && lhs->lhs_dest_end[-1] == ':')\n\t--lhs->lhs_dest_end;\n    if (is_decl && var_end == var_start + 2 && var_end[-1] == ':')\n\t--var_end;\n    lhs->lhs_end = lhs->lhs_dest_end;\n\n    // compute the length of the destination without \"[expr]\" or \".name\"\n    lhs->lhs_varlen = var_end - var_start;\n    lhs->lhs_varlen_total = lhs->lhs_varlen;\n    lhs->lhs_name = vim_strnsave(var_start, lhs->lhs_varlen);\n    if (lhs->lhs_name == NULL)\n\treturn FAIL;\n\n    if (lhs->lhs_dest_end > var_start + lhs->lhs_varlen)\n\t// Something follows after the variable: \"var[idx]\" or \"var.key\".\n\tlhs->lhs_has_index = TRUE;\n\n    if (heredoc)\n\tlhs->lhs_type = &t_list_string;\n    else\n\tlhs->lhs_type = &t_any;\n\n    if (cctx->ctx_skip != SKIP_YES)\n    {\n\tint\t    declare_error = FALSE;\n\n\tif (get_var_dest(lhs->lhs_name, &lhs->lhs_dest, cmdidx,\n\t\t\t\t      &lhs->lhs_opt_flags, &lhs->lhs_vimvaridx,\n\t\t\t\t\t\t &lhs->lhs_type, cctx) == FAIL)\n\t    return FAIL;\n\tif (lhs->lhs_dest != dest_local\n\t\t\t\t && cmdidx != CMD_const && cmdidx != CMD_final)\n\t{\n\t    // Specific kind of variable recognized.\n\t    declare_error = is_decl;\n\t}\n\telse\n\t{\n\t    // No specific kind of variable recognized, just a name.\n\t    if (check_reserved_name(lhs->lhs_name) == FAIL)\n\t\treturn FAIL;\n\n\t    if (lookup_local(var_start, lhs->lhs_varlen,\n\t\t\t\t\t     &lhs->lhs_local_lvar, cctx) == OK)\n\t\tlhs->lhs_lvar = &lhs->lhs_local_lvar;\n\t    else\n\t    {\n\t\tCLEAR_FIELD(lhs->lhs_arg_lvar);\n\t\tif (arg_exists(var_start, lhs->lhs_varlen,\n\t\t\t &lhs->lhs_arg_lvar.lv_idx, &lhs->lhs_arg_lvar.lv_type,\n\t\t\t    &lhs->lhs_arg_lvar.lv_from_outer, cctx) == OK)\n\t\t{\n\t\t    if (is_decl)\n\t\t    {\n\t\t\tsemsg(_(e_str_is_used_as_argument), lhs->lhs_name);\n\t\t\treturn FAIL;\n\t\t    }\n\t\t    lhs->lhs_lvar = &lhs->lhs_arg_lvar;\n\t\t}\n\t    }\n\t    if (lhs->lhs_lvar != NULL)\n\t    {\n\t\tif (is_decl)\n\t\t{\n\t\t    semsg(_(e_variable_already_declared), lhs->lhs_name);\n\t\t    return FAIL;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tint script_namespace = lhs->lhs_varlen > 1\n\t\t\t\t       && STRNCMP(var_start, \"s:\", 2) == 0;\n\t\tint script_var = (script_namespace\n\t\t\t? script_var_exists(var_start + 2, lhs->lhs_varlen - 2,\n\t\t\t\t\t\t\t\t\t  cctx)\n\t\t\t  : script_var_exists(var_start, lhs->lhs_varlen,\n\t\t\t\t\t\t\t\t  cctx)) == OK;\n\t\timported_T  *import =\n\t\t\t       find_imported(var_start, lhs->lhs_varlen, cctx);\n\n\t\tif (script_namespace || script_var || import != NULL)\n\t\t{\n\t\t    char_u\t*rawname = lhs->lhs_name\n\t\t\t\t\t   + (lhs->lhs_name[1] == ':' ? 2 : 0);\n\n\t\t    if (is_decl)\n\t\t    {\n\t\t\tif (script_namespace)\n\t\t\t    semsg(_(e_cannot_declare_script_variable_in_function),\n\t\t\t\t\t\t\t\tlhs->lhs_name);\n\t\t\telse\n\t\t\t    semsg(_(e_variable_already_declared_in_script_str),\n\t\t\t\t\t\t\t\tlhs->lhs_name);\n\t\t\treturn FAIL;\n\t\t    }\n\t\t    else if (cctx->ctx_ufunc->uf_script_ctx_version\n\t\t\t\t\t\t\t == SCRIPT_VERSION_VIM9\n\t\t\t\t    && script_namespace\n\t\t\t\t    && !script_var && import == NULL)\n\t\t    {\n\t\t\tsemsg(_(e_unknown_variable_str), lhs->lhs_name);\n\t\t\treturn FAIL;\n\t\t    }\n\n\t\t    lhs->lhs_dest = dest_script;\n\n\t\t    // existing script-local variables should have a type\n\t\t    lhs->lhs_scriptvar_sid = current_sctx.sc_sid;\n\t\t    if (import != NULL)\n\t\t\tlhs->lhs_scriptvar_sid = import->imp_sid;\n\t\t    if (SCRIPT_ID_VALID(lhs->lhs_scriptvar_sid))\n\t\t    {\n\t\t\t// Check writable only when no index follows.\n\t\t\tlhs->lhs_scriptvar_idx = get_script_item_idx(\n\t\t\t\t\t       lhs->lhs_scriptvar_sid, rawname,\n\t\t\t      lhs->lhs_has_index ? ASSIGN_FINAL : ASSIGN_CONST,\n\t\t\t\t\t\t\t\t\t cctx);\n\t\t\tif (lhs->lhs_scriptvar_idx >= 0)\n\t\t\t{\n\t\t\t    scriptitem_T *si = SCRIPT_ITEM(\n\t\t\t\t\t\t       lhs->lhs_scriptvar_sid);\n\t\t\t    svar_T\t *sv =\n\t\t\t\t\t    ((svar_T *)si->sn_var_vals.ga_data)\n\t\t\t\t\t\t      + lhs->lhs_scriptvar_idx;\n\t\t\t    lhs->lhs_type = sv->sv_type;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\telse if (check_defined(var_start, lhs->lhs_varlen, cctx, FALSE)\n\t\t\t\t\t\t\t\t       == FAIL)\n\t\t    return FAIL;\n\t    }\n\t}\n\n\tif (declare_error)\n\t{\n\t    vim9_declare_error(lhs->lhs_name);\n\t    return FAIL;\n\t}\n    }\n\n    // handle \"a:name\" as a name, not index \"name\" in \"a\"\n    if (lhs->lhs_varlen > 1 || var_start[lhs->lhs_varlen] != ':')\n\tvar_end = lhs->lhs_dest_end;\n\n    if (lhs->lhs_dest != dest_option && lhs->lhs_dest != dest_func_option)\n    {\n\tif (is_decl && *var_end == ':')\n\t{\n\t    char_u *p;\n\n\t    // parse optional type: \"let var: type = expr\"\n\t    if (!VIM_ISWHITE(var_end[1]))\n\t    {\n\t\tsemsg(_(e_white_space_required_after_str_str), \":\", var_end);\n\t\treturn FAIL;\n\t    }\n\t    p = skipwhite(var_end + 1);\n\t    lhs->lhs_type = parse_type(&p, cctx->ctx_type_list, TRUE);\n\t    if (lhs->lhs_type == NULL)\n\t\treturn FAIL;\n\t    lhs->lhs_has_type = TRUE;\n\t    lhs->lhs_end = p;\n\t}\n\telse if (lhs->lhs_lvar != NULL)\n\t    lhs->lhs_type = lhs->lhs_lvar->lv_type;\n    }\n\n    if (oplen == 3 && !heredoc\n\t\t   && lhs->lhs_dest != dest_global\n\t\t   && !lhs->lhs_has_index\n\t\t   && lhs->lhs_type->tt_type != VAR_STRING\n\t\t   && lhs->lhs_type->tt_type != VAR_ANY)\n    {\n\temsg(_(e_can_only_concatenate_to_string));\n\treturn FAIL;\n    }\n\n    if (lhs->lhs_lvar == NULL && lhs->lhs_dest == dest_local\n\t\t\t\t\t\t && cctx->ctx_skip != SKIP_YES)\n    {\n\tif (oplen > 1 && !heredoc)\n\t{\n\t    // +=, /=, etc. require an existing variable\n\t    semsg(_(e_cannot_use_operator_on_new_variable), lhs->lhs_name);\n\t    return FAIL;\n\t}\n\tif (!is_decl)\n\t{\n\t    semsg(_(e_unknown_variable_str), lhs->lhs_name);\n\t    return FAIL;\n\t}\n\n\t// Check the name is valid for a funcref.\n\tif ((lhs->lhs_type->tt_type == VAR_FUNC\n\t\t\t\t      || lhs->lhs_type->tt_type == VAR_PARTIAL)\n\t\t&& var_wrong_func_name(lhs->lhs_name, TRUE))\n\t    return FAIL;\n\n\t// New local variable.\n\tlhs->lhs_lvar = reserve_local(cctx, var_start, lhs->lhs_varlen,\n\t\t    cmdidx == CMD_final || cmdidx == CMD_const, lhs->lhs_type);\n\tif (lhs->lhs_lvar == NULL)\n\t    return FAIL;\n\tlhs->lhs_new_local = TRUE;\n    }\n\n    lhs->lhs_member_type = lhs->lhs_type;\n    if (lhs->lhs_has_index)\n    {\n\tchar_u\t*after = var_start + lhs->lhs_varlen;\n\tchar_u\t*p;\n\n\t// Something follows after the variable: \"var[idx]\" or \"var.key\".\n\tif (is_decl)\n\t{\n\t    emsg(_(e_cannot_use_index_when_declaring_variable));\n\t    return FAIL;\n\t}\n\n\t// Now: var_start[lhs->lhs_varlen] is '[' or '.'\n\t// Only the last index is used below, if there are others\n\t// before it generate code for the expression.  Thus for\n\t// \"ll[1][2]\" the expression is \"ll[1]\" and \"[2]\" is the index.\n\tfor (;;)\n\t{\n\t    p = skip_index(after);\n\t    if (*p != '[' && *p != '.')\n\t    {\n\t\tlhs->lhs_varlen_total = p - var_start;\n\t\tbreak;\n\t    }\n\t    after = p;\n\t}\n\tif (after > var_start + lhs->lhs_varlen)\n\t{\n\t    lhs->lhs_varlen = after - var_start;\n\t    lhs->lhs_dest = dest_expr;\n\t    // We don't know the type before evaluating the expression,\n\t    // use \"any\" until then.\n\t    lhs->lhs_type = &t_any;\n\t}\n\n\tif (lhs->lhs_type->tt_member == NULL)\n\t    lhs->lhs_member_type = &t_any;\n\telse\n\t    lhs->lhs_member_type = lhs->lhs_type->tt_member;\n    }\n    return OK;\n}\n\n/*\n * Figure out the LHS and check a few errors.\n */\n    int\ncompile_assign_lhs(\n\tchar_u\t*var_start,\n\tlhs_T\t*lhs,\n\tint\tcmdidx,\n\tint\tis_decl,\n\tint\theredoc,\n\tint\toplen,\n\tcctx_T\t*cctx)\n{\n    if (compile_lhs(var_start, lhs, cmdidx, heredoc, oplen, cctx) == FAIL)\n\treturn FAIL;\n\n    if (!lhs->lhs_has_index && lhs->lhs_lvar == &lhs->lhs_arg_lvar)\n    {\n\tsemsg(_(e_cannot_assign_to_argument), lhs->lhs_name);\n\treturn FAIL;\n    }\n    if (!is_decl && lhs->lhs_lvar != NULL\n\t\t\t   && lhs->lhs_lvar->lv_const && !lhs->lhs_has_index)\n    {\n\tsemsg(_(e_cannot_assign_to_constant), lhs->lhs_name);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Return TRUE if \"lhs\" has a range index: \"[expr : expr]\".\n */\n    static int\nhas_list_index(char_u *idx_start, cctx_T *cctx)\n{\n    char_u  *p = idx_start;\n    int\t    save_skip;\n\n    if (*p != '[')\n\treturn FALSE;\n\n    p = skipwhite(p + 1);\n    if (*p == ':')\n\treturn TRUE;\n\n    save_skip = cctx->ctx_skip;\n    cctx->ctx_skip = SKIP_YES;\n    (void)compile_expr0(&p, cctx);\n    cctx->ctx_skip = save_skip;\n    return *skipwhite(p) == ':';\n}\n\n/*\n * For an assignment with an index, compile the \"idx\" in \"var[idx]\" or \"key\" in\n * \"var.key\".\n */\n    static int\ncompile_assign_index(\n\tchar_u\t*var_start,\n\tlhs_T\t*lhs,\n\tint\t*range,\n\tcctx_T\t*cctx)\n{\n    size_t\tvarlen = lhs->lhs_varlen;\n    char_u\t*p;\n    int\t\tr = OK;\n    int\t\tneed_white_before = TRUE;\n    int\t\tempty_second;\n\n    p = var_start + varlen;\n    if (*p == '[')\n    {\n\tp = skipwhite(p + 1);\n\tif (*p == ':')\n\t{\n\t    // empty first index, push zero\n\t    r = generate_PUSHNR(cctx, 0);\n\t    need_white_before = FALSE;\n\t}\n\telse\n\t    r = compile_expr0(&p, cctx);\n\n\tif (r == OK && *skipwhite(p) == ':')\n\t{\n\t    // unlet var[idx : idx]\n\t    // blob[idx : idx] = value\n\t    *range = TRUE;\n\t    p = skipwhite(p);\n\t    empty_second = *skipwhite(p + 1) == ']';\n\t    if ((need_white_before && !IS_WHITE_OR_NUL(p[-1]))\n\t\t    || (!empty_second && !IS_WHITE_OR_NUL(p[1])))\n\t    {\n\t\tsemsg(_(e_white_space_required_before_and_after_str_at_str),\n\t\t\t\t\t\t\t\t      \":\", p);\n\t\treturn FAIL;\n\t    }\n\t    p = skipwhite(p + 1);\n\t    if (*p == ']')\n\t\t// empty second index, push \"none\"\n\t\tr = generate_PUSHSPEC(cctx, VVAL_NONE);\n\t    else\n\t\tr = compile_expr0(&p, cctx);\n\t}\n\n\tif (r == OK && *skipwhite(p) != ']')\n\t{\n\t    // this should not happen\n\t    emsg(_(e_missing_closing_square_brace));\n\t    r = FAIL;\n\t}\n    }\n    else // if (*p == '.')\n    {\n\tchar_u *key_end = to_name_end(p + 1, TRUE);\n\tchar_u *key = vim_strnsave(p + 1, key_end - p - 1);\n\n\tr = generate_PUSHS(cctx, &key);\n    }\n    return r;\n}\n\n/*\n * For a LHS with an index, load the variable to be indexed.\n */\n    static int\ncompile_load_lhs(\n\tlhs_T\t*lhs,\n\tchar_u\t*var_start,\n\ttype_T\t*rhs_type,\n\tcctx_T\t*cctx)\n{\n    if (lhs->lhs_dest == dest_expr)\n    {\n\tsize_t\t    varlen = lhs->lhs_varlen;\n\tint\t    c = var_start[varlen];\n\tint\t    lines_len = cctx->ctx_ufunc->uf_lines.ga_len;\n\tchar_u\t    *p = var_start;\n\tgarray_T    *stack = &cctx->ctx_type_stack;\n\tint\t    res;\n\n\t// Evaluate \"ll[expr]\" of \"ll[expr][idx]\".  End the line with a NUL and\n\t// limit the lines array length to avoid skipping to a following line.\n\tvar_start[varlen] = NUL;\n\tcctx->ctx_ufunc->uf_lines.ga_len = cctx->ctx_lnum + 1;\n\tres = compile_expr0(&p, cctx);\n\tvar_start[varlen] = c;\n\tcctx->ctx_ufunc->uf_lines.ga_len = lines_len;\n\tif (res == FAIL || p != var_start + varlen)\n\t{\n\t    // this should not happen\n\t    if (res != FAIL)\n\t\temsg(_(e_missing_closing_square_brace));\n\t    return FAIL;\n\t}\n\n\tlhs->lhs_type = stack->ga_len == 0 ? &t_void\n\t\t\t      : ((type_T **)stack->ga_data)[stack->ga_len - 1];\n\t// now we can properly check the type\n\tif (rhs_type != NULL && lhs->lhs_type->tt_member != NULL\n\t\t&& rhs_type != &t_void\n\t\t&& need_type(rhs_type, lhs->lhs_type->tt_member, -2, 0, cctx,\n\t\t\t\t\t\t\t FALSE, FALSE) == FAIL)\n\t    return FAIL;\n    }\n    else\n\tgenerate_loadvar(cctx, lhs->lhs_dest, lhs->lhs_name,\n\t\t\t\t\t\t lhs->lhs_lvar, lhs->lhs_type);\n    return OK;\n}\n\n/*\n * Produce code for loading \"lhs\" and also take care of an index.\n * Return OK/FAIL.\n */\n    int\ncompile_load_lhs_with_index(lhs_T *lhs, char_u *var_start, cctx_T *cctx)\n{\n    compile_load_lhs(lhs, var_start, NULL, cctx);\n\n    if (lhs->lhs_has_index)\n    {\n\tint range = FALSE;\n\n\t// Get member from list or dict.  First compile the\n\t// index value.\n\tif (compile_assign_index(var_start, lhs, &range, cctx) == FAIL)\n\t    return FAIL;\n\tif (range)\n\t{\n\t    semsg(_(e_cannot_use_range_with_assignment_operator_str),\n\t\t\t\t\t\t\t\t    var_start);\n\t    return FAIL;\n\t}\n\n\t// Get the member.\n\tif (compile_member(FALSE, NULL, cctx) == FAIL)\n\t    return FAIL;\n    }\n    return OK;\n}\n\n/*\n * Assignment to a list or dict member, or \":unlet\" for the item, using the\n * information in \"lhs\".\n * Returns OK or FAIL.\n */\n    int\ncompile_assign_unlet(\n\tchar_u\t*var_start,\n\tlhs_T\t*lhs,\n\tint\tis_assign,\n\ttype_T\t*rhs_type,\n\tcctx_T\t*cctx)\n{\n    vartype_T\tdest_type;\n    garray_T    *stack = &cctx->ctx_type_stack;\n    int\t\trange = FALSE;\n\n    if (compile_assign_index(var_start, lhs, &range, cctx) == FAIL)\n\treturn FAIL;\n    if (is_assign && range\n\t    && lhs->lhs_type->tt_type != VAR_LIST\n\t    && lhs->lhs_type != &t_blob\n\t    && lhs->lhs_type != &t_any)\n    {\n\tsemsg(_(e_cannot_use_range_with_assignment_str), var_start);\n\treturn FAIL;\n    }\n\n    if (lhs->lhs_type == &t_any)\n    {\n\t// Index on variable of unknown type: check at runtime.\n\tdest_type = VAR_ANY;\n    }\n    else\n    {\n\tdest_type = lhs->lhs_type->tt_type;\n\tif (dest_type == VAR_DICT && range)\n\t{\n\t    emsg(e_cannot_use_range_with_dictionary);\n\t    return FAIL;\n\t}\n\tif (dest_type == VAR_DICT\n\t\t\t      && may_generate_2STRING(-1, FALSE, cctx) == FAIL)\n\t    return FAIL;\n\tif (dest_type == VAR_LIST || dest_type == VAR_BLOB)\n\t{\n\t    type_T *type;\n\n\t    if (range)\n\t    {\n\t\ttype = ((type_T **)stack->ga_data)[stack->ga_len - 2];\n\t\tif (need_type(type, &t_number,\n\t\t\t\t\t    -1, 0, cctx, FALSE, FALSE) == FAIL)\n\t\treturn FAIL;\n\t    }\n\t    type = ((type_T **)stack->ga_data)[stack->ga_len - 1];\n\t    if ((dest_type != VAR_BLOB && type != &t_special)\n\t\t    && need_type(type, &t_number,\n\t\t\t\t\t    -1, 0, cctx, FALSE, FALSE) == FAIL)\n\t\treturn FAIL;\n\t}\n    }\n\n    // Load the dict or list.  On the stack we then have:\n    // - value (for assignment, not for :unlet)\n    // - index\n    // - for [a : b] second index\n    // - variable\n    if (compile_load_lhs(lhs, var_start, rhs_type, cctx) == FAIL)\n\treturn FAIL;\n\n    if (dest_type == VAR_LIST || dest_type == VAR_DICT\n\t\t\t      || dest_type == VAR_BLOB || dest_type == VAR_ANY)\n    {\n\tif (is_assign)\n\t{\n\t    if (range)\n\t    {\n\t\tif (generate_instr_drop(cctx, ISN_STORERANGE, 4) == NULL)\n\t\t    return FAIL;\n\t    }\n\t    else\n\t    {\n\t\tisn_T\t*isn = generate_instr_drop(cctx, ISN_STOREINDEX, 3);\n\n\t\tif (isn == NULL)\n\t\t    return FAIL;\n\t\tisn->isn_arg.vartype = dest_type;\n\t    }\n\t}\n\telse if (range)\n\t{\n\t    if (generate_instr_drop(cctx, ISN_UNLETRANGE, 3) == NULL)\n\t\treturn FAIL;\n\t}\n\telse\n\t{\n\t    if (generate_instr_drop(cctx, ISN_UNLETINDEX, 2) == NULL)\n\t\treturn FAIL;\n\t}\n    }\n    else\n    {\n\temsg(_(e_indexable_type_required));\n\treturn FAIL;\n    }\n\n    return OK;\n}\n\n/*\n * Compile declaration and assignment:\n * \"let name\"\n * \"var name = expr\"\n * \"final name = expr\"\n * \"const name = expr\"\n * \"name = expr\"\n * \"arg\" points to \"name\".\n * \"++arg\" and \"--arg\"\n * Return NULL for an error.\n * Return \"arg\" if it does not look like a variable list.\n */\n    static char_u *\ncompile_assignment(char_u *arg, exarg_T *eap, cmdidx_T cmdidx, cctx_T *cctx)\n{\n    char_u\t*var_start;\n    char_u\t*p;\n    char_u\t*end = arg;\n    char_u\t*ret = NULL;\n    int\t\tvar_count = 0;\n    int\t\tvar_idx;\n    int\t\tsemicolon = 0;\n    int\t\tdid_generate_slice = FALSE;\n    garray_T\t*instr = &cctx->ctx_instr;\n    garray_T    *stack = &cctx->ctx_type_stack;\n    char_u\t*op;\n    int\t\toplen = 0;\n    int\t\theredoc = FALSE;\n    int\t\tincdec = FALSE;\n    type_T\t*rhs_type = &t_any;\n    char_u\t*sp;\n    int\t\tis_decl = is_decl_command(cmdidx);\n    lhs_T\tlhs;\n    long\tstart_lnum = SOURCING_LNUM;\n\n    // Skip over the \"var\" or \"[var, var]\" to get to any \"=\".\n    p = skip_var_list(arg, TRUE, &var_count, &semicolon, TRUE);\n    if (p == NULL)\n\treturn *arg == '[' ? arg : NULL;\n\n    lhs.lhs_name = NULL;\n\n    sp = p;\n    p = skipwhite(p);\n    op = p;\n    oplen = assignment_len(p, &heredoc);\n\n    if (var_count > 0 && oplen == 0)\n\t// can be something like \"[1, 2]->func()\"\n\treturn arg;\n\n    if (oplen > 0 && (!VIM_ISWHITE(*sp) || !IS_WHITE_OR_NUL(op[oplen])))\n    {\n\terror_white_both(op, oplen);\n\treturn NULL;\n    }\n    if (eap->cmdidx == CMD_increment || eap->cmdidx == CMD_decrement)\n    {\n\tif (VIM_ISWHITE(eap->cmd[2]))\n\t{\n\t    semsg(_(e_no_white_space_allowed_after_str_str),\n\t\t\t eap->cmdidx == CMD_increment ? \"++\" : \"--\", eap->cmd);\n\t    return NULL;\n\t}\n\top = (char_u *)(eap->cmdidx == CMD_increment ? \"+=\" : \"-=\");\n\toplen = 2;\n\tincdec = TRUE;\n    }\n\n    if (heredoc)\n    {\n\tlist_T\t   *l;\n\tlistitem_T *li;\n\n\t// [let] varname =<< [trim] {end}\n\teap->getline = exarg_getline;\n\teap->cookie = cctx;\n\tl = heredoc_get(eap, op + 3, FALSE);\n\tif (l == NULL)\n\t    return NULL;\n\n\tif (cctx->ctx_skip != SKIP_YES)\n\t{\n\t    // Push each line and the create the list.\n\t    FOR_ALL_LIST_ITEMS(l, li)\n\t    {\n\t\tgenerate_PUSHS(cctx, &li->li_tv.vval.v_string);\n\t\tli->li_tv.vval.v_string = NULL;\n\t    }\n\t    generate_NEWLIST(cctx, l->lv_len);\n\t}\n\tlist_free(l);\n\tp += STRLEN(p);\n\tend = p;\n    }\n    else if (var_count > 0)\n    {\n\tchar_u *wp;\n\n\t// for \"[var, var] = expr\" evaluate the expression here, loop over the\n\t// list of variables below.\n\t// A line break may follow the \"=\".\n\n\twp = op + oplen;\n\tif (may_get_next_line_error(wp, &p, cctx) == FAIL)\n\t    return FAIL;\n\tif (compile_expr0(&p, cctx) == FAIL)\n\t    return NULL;\n\tend = p;\n\n\tif (cctx->ctx_skip != SKIP_YES)\n\t{\n\t    type_T\t*stacktype;\n\t    int\t\tneeded_list_len;\n\t    int\t\tdid_check = FALSE;\n\n\t    stacktype = stack->ga_len == 0 ? &t_void\n\t\t\t      : ((type_T **)stack->ga_data)[stack->ga_len - 1];\n\t    if (stacktype->tt_type == VAR_VOID)\n\t    {\n\t\temsg(_(e_cannot_use_void_value));\n\t\tgoto theend;\n\t    }\n\t    if (need_type(stacktype, &t_list_any, -1, 0, cctx,\n\t\t\t\t\t\t\t FALSE, FALSE) == FAIL)\n\t\tgoto theend;\n\t    // If a constant list was used we can check the length right here.\n\t    needed_list_len = semicolon ? var_count - 1 : var_count;\n\t    if (instr->ga_len > 0)\n\t    {\n\t\tisn_T\t*isn = ((isn_T *)instr->ga_data) + instr->ga_len - 1;\n\n\t\tif (isn->isn_type == ISN_NEWLIST)\n\t\t{\n\t\t    did_check = TRUE;\n\t\t    if (semicolon ? isn->isn_arg.number < needed_list_len\n\t\t\t    : isn->isn_arg.number != needed_list_len)\n\t\t    {\n\t\t\tsemsg(_(e_expected_nr_items_but_got_nr),\n\t\t\t\t\t needed_list_len, isn->isn_arg.number);\n\t\t\tgoto theend;\n\t\t    }\n\t\t}\n\t    }\n\t    if (!did_check)\n\t\tgenerate_CHECKLEN(cctx, needed_list_len, semicolon);\n\t    if (stacktype->tt_member != NULL)\n\t\trhs_type = stacktype->tt_member;\n\t}\n    }\n\n    /*\n     * Loop over variables in \"[var, var] = expr\".\n     * For \"var = expr\" and \"let var: type\" this is done only once.\n     */\n    if (var_count > 0)\n\tvar_start = skipwhite(arg + 1);  // skip over the \"[\"\n    else\n\tvar_start = arg;\n    for (var_idx = 0; var_idx == 0 || var_idx < var_count; var_idx++)\n    {\n\tint\tinstr_count = -1;\n\tint\tsave_lnum;\n\tint\tskip_store = FALSE;\n\n\tif (var_start[0] == '_' && !eval_isnamec(var_start[1]))\n\t{\n\t    // Ignore underscore in \"[a, _, b] = list\".\n\t    if (var_count > 0)\n\t    {\n\t\tvar_start = skipwhite(var_start + 2);\n\t\tcontinue;\n\t    }\n\t    emsg(_(e_cannot_use_underscore_here));\n\t    goto theend;\n\t}\n\tvim_free(lhs.lhs_name);\n\n\t/*\n\t * Figure out the LHS type and other properties.\n\t */\n\tif (compile_assign_lhs(var_start, &lhs, cmdidx,\n\t\t\t\t\tis_decl, heredoc, oplen, cctx) == FAIL)\n\t    goto theend;\n\tif (heredoc)\n\t{\n\t    SOURCING_LNUM = start_lnum;\n\t    if (lhs.lhs_has_type\n\t\t    && need_type(&t_list_string, lhs.lhs_type,\n\t\t\t\t\t    -1, 0, cctx, FALSE, FALSE) == FAIL)\n\t\tgoto theend;\n\t}\n\telse\n\t{\n\t    if (cctx->ctx_skip == SKIP_YES)\n\t    {\n\t\tif (oplen > 0 && var_count == 0)\n\t\t{\n\t\t    // skip over the \"=\" and the expression\n\t\t    p = skipwhite(op + oplen);\n\t\t    (void)compile_expr0(&p, cctx);\n\t\t}\n\t    }\n\t    else if (oplen > 0)\n\t    {\n\t\tint\tis_const = FALSE;\n\t\tchar_u\t*wp;\n\n\t\t// for \"+=\", \"*=\", \"..=\" etc. first load the current value\n\t\tif (*op != '='\n\t\t\t&& compile_load_lhs_with_index(&lhs, var_start,\n\t\t\t\t\t\t\t\t cctx) == FAIL)\n\t\t    goto theend;\n\n\t\t// For \"var = expr\" evaluate the expression.\n\t\tif (var_count == 0)\n\t\t{\n\t\t    int\tr;\n\n\t\t    // Compile the expression.\n\t\t    instr_count = instr->ga_len;\n\t\t    if (incdec)\n\t\t    {\n\t\t\tr = generate_PUSHNR(cctx, 1);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// Temporarily hide the new local variable here, it is\n\t\t\t// not available to this expression.\n\t\t\tif (lhs.lhs_new_local)\n\t\t\t    --cctx->ctx_locals.ga_len;\n\t\t\twp = op + oplen;\n\t\t\tif (may_get_next_line_error(wp, &p, cctx) == FAIL)\n\t\t\t{\n\t\t\t    if (lhs.lhs_new_local)\n\t\t\t\t++cctx->ctx_locals.ga_len;\n\t\t\t    goto theend;\n\t\t\t}\n\t\t\tr = compile_expr0_ext(&p, cctx, &is_const);\n\t\t\tif (lhs.lhs_new_local)\n\t\t\t    ++cctx->ctx_locals.ga_len;\n\t\t\tif (r == FAIL)\n\t\t\t    goto theend;\n\t\t    }\n\t\t}\n\t\telse if (semicolon && var_idx == var_count - 1)\n\t\t{\n\t\t    // For \"[var; var] = expr\" get the rest of the list\n\t\t    did_generate_slice = TRUE;\n\t\t    if (generate_SLICE(cctx, var_count - 1) == FAIL)\n\t\t\tgoto theend;\n\t\t}\n\t\telse\n\t\t{\n\t\t    // For \"[var, var] = expr\" get the \"var_idx\" item from the\n\t\t    // list.\n\t\t    if (generate_GETITEM(cctx, var_idx, *op != '=') == FAIL)\n\t\t\tgoto theend;\n\t\t}\n\n\t\trhs_type = stack->ga_len == 0 ? &t_void\n\t\t\t      : ((type_T **)stack->ga_data)[stack->ga_len - 1];\n\t\tif (lhs.lhs_lvar != NULL && (is_decl || !lhs.lhs_has_type))\n\t\t{\n\t\t    if ((rhs_type->tt_type == VAR_FUNC\n\t\t\t\t|| rhs_type->tt_type == VAR_PARTIAL)\n\t\t\t    && !lhs.lhs_has_index\n\t\t\t    && var_wrong_func_name(lhs.lhs_name, TRUE))\n\t\t\tgoto theend;\n\n\t\t    if (lhs.lhs_new_local && !lhs.lhs_has_type)\n\t\t    {\n\t\t\tif (rhs_type->tt_type == VAR_VOID)\n\t\t\t{\n\t\t\t    emsg(_(e_cannot_use_void_value));\n\t\t\t    goto theend;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // An empty list or dict has a &t_unknown member,\n\t\t\t    // for a variable that implies &t_any.\n\t\t\t    if (rhs_type == &t_list_empty)\n\t\t\t\tlhs.lhs_lvar->lv_type = &t_list_any;\n\t\t\t    else if (rhs_type == &t_dict_empty)\n\t\t\t\tlhs.lhs_lvar->lv_type = &t_dict_any;\n\t\t\t    else if (rhs_type == &t_unknown)\n\t\t\t\tlhs.lhs_lvar->lv_type = &t_any;\n\t\t\t    else\n\t\t\t\tlhs.lhs_lvar->lv_type = rhs_type;\n\t\t\t}\n\t\t    }\n\t\t    else if (*op == '=')\n\t\t    {\n\t\t\ttype_T *use_type = lhs.lhs_lvar->lv_type;\n\t\t\twhere_T where = WHERE_INIT;\n\n\t\t\t// Without operator check type here, otherwise below.\n\t\t\t// Use the line number of the assignment.\n\t\t\tSOURCING_LNUM = start_lnum;\n\t\t\twhere.wt_index = var_count > 0 ? var_idx + 1 : 0;\n\t\t\twhere.wt_variable = var_count > 0;\n\t\t\t// If assigning to a list or dict member, use the\n\t\t\t// member type.  Not for \"list[:] =\".\n\t\t\tif (lhs.lhs_has_index\n\t\t\t\t&& !has_list_index(var_start + lhs.lhs_varlen,\n\t\t\t\t\t\t\t\t\t cctx))\n\t\t\t    use_type = lhs.lhs_member_type;\n\t\t\tif (need_type_where(rhs_type, use_type, -1, where,\n\t\t\t\t    cctx, FALSE, is_const) == FAIL)\n\t\t\t    goto theend;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    type_T *lhs_type = lhs.lhs_member_type;\n\n\t\t    // Special case: assigning to @# can use a number or a\n\t\t    // string.\n\t\t    // Also: can assign a number to a float.\n\t\t    if ((lhs_type == &t_number_or_string\n\t\t\t\t|| lhs_type == &t_float)\n\t\t\t    && rhs_type->tt_type == VAR_NUMBER)\n\t\t\tlhs_type = &t_number;\n\t\t    if (*p != '=' && need_type(rhs_type, lhs_type,\n\t\t\t\t\t    -1, 0, cctx, FALSE, FALSE) == FAIL)\n\t\t    goto theend;\n\t\t}\n\t    }\n\t    else if (cmdidx == CMD_final)\n\t    {\n\t\temsg(_(e_final_requires_a_value));\n\t\tgoto theend;\n\t    }\n\t    else if (cmdidx == CMD_const)\n\t    {\n\t\temsg(_(e_const_requires_a_value));\n\t\tgoto theend;\n\t    }\n\t    else if (!lhs.lhs_has_type || lhs.lhs_dest == dest_option\n\t\t\t\t\t   || lhs.lhs_dest == dest_func_option)\n\t    {\n\t\temsg(_(e_type_or_initialization_required));\n\t\tgoto theend;\n\t    }\n\t    else\n\t    {\n\t\t// variables are always initialized\n\t\tif (GA_GROW_FAILS(instr, 1))\n\t\t    goto theend;\n\t\tswitch (lhs.lhs_member_type->tt_type)\n\t\t{\n\t\t    case VAR_BOOL:\n\t\t\tgenerate_PUSHBOOL(cctx, VVAL_FALSE);\n\t\t\tbreak;\n\t\t    case VAR_FLOAT:\n#ifdef FEAT_FLOAT\n\t\t\tgenerate_PUSHF(cctx, 0.0);\n#endif\n\t\t\tbreak;\n\t\t    case VAR_STRING:\n\t\t\tgenerate_PUSHS(cctx, NULL);\n\t\t\tbreak;\n\t\t    case VAR_BLOB:\n\t\t\tgenerate_PUSHBLOB(cctx, blob_alloc());\n\t\t\tbreak;\n\t\t    case VAR_FUNC:\n\t\t\tgenerate_PUSHFUNC(cctx, NULL, &t_func_void);\n\t\t\tbreak;\n\t\t    case VAR_LIST:\n\t\t\tgenerate_NEWLIST(cctx, 0);\n\t\t\tbreak;\n\t\t    case VAR_DICT:\n\t\t\tgenerate_NEWDICT(cctx, 0);\n\t\t\tbreak;\n\t\t    case VAR_JOB:\n\t\t\tgenerate_PUSHJOB(cctx, NULL);\n\t\t\tbreak;\n\t\t    case VAR_CHANNEL:\n\t\t\tgenerate_PUSHCHANNEL(cctx, NULL);\n\t\t\tbreak;\n\t\t    case VAR_NUMBER:\n\t\t    case VAR_UNKNOWN:\n\t\t    case VAR_ANY:\n\t\t    case VAR_PARTIAL:\n\t\t    case VAR_VOID:\n\t\t    case VAR_INSTR:\n\t\t    case VAR_SPECIAL:  // cannot happen\n\t\t\t// This is skipped for local variables, they are\n\t\t\t// always initialized to zero.\n\t\t\tif (lhs.lhs_dest == dest_local)\n\t\t\t    skip_store = TRUE;\n\t\t\telse\n\t\t\t    generate_PUSHNR(cctx, 0);\n\t\t\tbreak;\n\t\t}\n\t    }\n\t    if (var_count == 0)\n\t\tend = p;\n\t}\n\n\t// no need to parse more when skipping\n\tif (cctx->ctx_skip == SKIP_YES)\n\t    break;\n\n\tif (oplen > 0 && *op != '=')\n\t{\n\t    type_T\t    *expected;\n\t    type_T\t    *stacktype = NULL;\n\n\t    if (*op == '.')\n\t    {\n\t\tif (may_generate_2STRING(-1, FALSE, cctx) == FAIL)\n\t\t    goto theend;\n\t    }\n\t    else\n\t    {\n\t\texpected = lhs.lhs_member_type;\n\t\tstacktype = ((type_T **)stack->ga_data)[stack->ga_len - 1];\n\t\tif (\n#ifdef FEAT_FLOAT\n\t\t    // If variable is float operation with number is OK.\n\t\t    !(expected == &t_float && (stacktype == &t_number\n\t\t\t    || stacktype == &t_number_bool)) &&\n#endif\n\t\t    need_type(stacktype, expected, -1, 0, cctx,\n\t\t\t\t\t\t\t FALSE, FALSE) == FAIL)\n\t\t    goto theend;\n\t    }\n\n\t    if (*op == '.')\n\t    {\n\t\tif (generate_instr_drop(cctx, ISN_CONCAT, 1) == NULL)\n\t\t    goto theend;\n\t    }\n\t    else if (*op == '+')\n\t    {\n\t\tif (generate_add_instr(cctx,\n\t\t\t    operator_type(lhs.lhs_member_type, stacktype),\n\t\t\t\t       lhs.lhs_member_type, stacktype,\n\t\t\t\t\t\t\t  EXPR_APPEND) == FAIL)\n\t\t    goto theend;\n\t    }\n\t    else if (generate_two_op(cctx, op) == FAIL)\n\t\tgoto theend;\n\t}\n\n\t// Use the line number of the assignment for store instruction.\n\tsave_lnum = cctx->ctx_lnum;\n\tcctx->ctx_lnum = start_lnum - 1;\n\n\tif (lhs.lhs_has_index)\n\t{\n\t    // Use the info in \"lhs\" to store the value at the index in the\n\t    // list or dict.\n\t    if (compile_assign_unlet(var_start, &lhs, TRUE, rhs_type, cctx)\n\t\t\t\t\t\t\t\t       == FAIL)\n\t    {\n\t\tcctx->ctx_lnum = save_lnum;\n\t\tgoto theend;\n\t    }\n\t}\n\telse\n\t{\n\t    if (is_decl && cmdidx == CMD_const && (lhs.lhs_dest == dest_script\n\t\t\t\t\t\t|| lhs.lhs_dest == dest_global\n\t\t\t\t\t\t|| lhs.lhs_dest == dest_local))\n\t\t// \":const var\": lock the value, but not referenced variables\n\t\tgenerate_LOCKCONST(cctx);\n\n\t    if (is_decl\n\t\t    && (lhs.lhs_type->tt_type == VAR_DICT\n\t\t\t\t\t  || lhs.lhs_type->tt_type == VAR_LIST)\n\t\t    && lhs.lhs_type->tt_member != NULL\n\t\t    && !(lhs.lhs_type->tt_member == &t_any\n\t\t\t    && oplen > 0\n\t\t\t    && rhs_type != NULL\n\t\t\t    && rhs_type->tt_type == lhs.lhs_type->tt_type\n\t\t\t    && rhs_type->tt_member != &t_unknown)\n\t\t    && lhs.lhs_type->tt_member != &t_unknown)\n\t\t// Set the type in the list or dict, so that it can be checked,\n\t\t// also in legacy script.  Not for \"list<any> = val\", then the\n\t\t// type of \"val\" is used.\n\t\tgenerate_SETTYPE(cctx, lhs.lhs_type);\n\n\t    if (!skip_store && generate_store_lhs(cctx, &lhs,\n\t\t\t\t\t\t instr_count, is_decl) == FAIL)\n\t    {\n\t\tcctx->ctx_lnum = save_lnum;\n\t\tgoto theend;\n\t    }\n\t}\n\tcctx->ctx_lnum = save_lnum;\n\n\tif (var_idx + 1 < var_count)\n\t    var_start = skipwhite(lhs.lhs_end + 1);\n    }\n\n    // For \"[var, var] = expr\" drop the \"expr\" value.\n    // Also for \"[var, var; _] = expr\".\n    if (var_count > 0 && (!semicolon || !did_generate_slice))\n    {\n\tif (generate_instr_drop(cctx, ISN_DROP, 1) == NULL)\n\t    goto theend;\n    }\n\n    ret = skipwhite(end);\n\ntheend:\n    vim_free(lhs.lhs_name);\n    return ret;\n}\n\n/*\n * Check for an assignment at \"eap->cmd\", compile it if found.\n * Return NOTDONE if there is none, FAIL for failure, OK if done.\n */\n    static int\nmay_compile_assignment(exarg_T *eap, char_u **line, cctx_T *cctx)\n{\n    char_u  *pskip;\n    char_u  *p;\n\n    // Assuming the command starts with a variable or function name,\n    // find what follows.\n    // Skip over \"var.member\", \"var[idx]\" and the like.\n    // Also \"&opt = val\", \"$ENV = val\" and \"@r = val\".\n    pskip = (*eap->cmd == '&' || *eap->cmd == '$' || *eap->cmd == '@')\n\t\t\t\t\t\t ? eap->cmd + 1 : eap->cmd;\n    p = to_name_end(pskip, TRUE);\n    if (p > eap->cmd && *p != NUL)\n    {\n\tchar_u *var_end;\n\tint\toplen;\n\tint\theredoc;\n\n\tif (eap->cmd[0] == '@')\n\t    var_end = eap->cmd + 2;\n\telse\n\t    var_end = find_name_end(pskip, NULL, NULL,\n\t\t\t\t\tFNE_CHECK_START | FNE_INCL_BR);\n\toplen = assignment_len(skipwhite(var_end), &heredoc);\n\tif (oplen > 0)\n\t{\n\t    size_t len = p - eap->cmd;\n\n\t    // Recognize an assignment if we recognize the variable\n\t    // name:\n\t    // \"g:var = expr\"\n\t    // \"local = expr\"  where \"local\" is a local var.\n\t    // \"script = expr\"  where \"script\" is a script-local var.\n\t    // \"import = expr\"  where \"import\" is an imported var\n\t    // \"&opt = expr\"\n\t    // \"$ENV = expr\"\n\t    // \"@r = expr\"\n\t    if (*eap->cmd == '&'\n\t\t    || *eap->cmd == '$'\n\t\t    || *eap->cmd == '@'\n\t\t    || ((len) > 2 && eap->cmd[1] == ':')\n\t\t    || variable_exists(eap->cmd, len, cctx))\n\t    {\n\t\t*line = compile_assignment(eap->cmd, eap, CMD_SIZE, cctx);\n\t\tif (*line == NULL || *line == eap->cmd)\n\t\t    return FAIL;\n\t\treturn OK;\n\t    }\n\t}\n    }\n\n    if (*eap->cmd == '[')\n    {\n\t// [var, var] = expr\n\t*line = compile_assignment(eap->cmd, eap, CMD_SIZE, cctx);\n\tif (*line == NULL)\n\t    return FAIL;\n\tif (*line != eap->cmd)\n\t    return OK;\n    }\n    return NOTDONE;\n}\n\n\n/*\n * Add a function to the list of :def functions.\n * This sets \"ufunc->uf_dfunc_idx\" but the function isn't compiled yet.\n */\n    static int\nadd_def_function(ufunc_T *ufunc)\n{\n    dfunc_T *dfunc;\n\n    if (def_functions.ga_len == 0)\n    {\n\t// The first position is not used, so that a zero uf_dfunc_idx means it\n\t// wasn't set.\n\tif (GA_GROW_FAILS(&def_functions, 1))\n\t    return FAIL;\n\t++def_functions.ga_len;\n    }\n\n    // Add the function to \"def_functions\".\n    if (GA_GROW_FAILS(&def_functions, 1))\n\treturn FAIL;\n    dfunc = ((dfunc_T *)def_functions.ga_data) + def_functions.ga_len;\n    CLEAR_POINTER(dfunc);\n    dfunc->df_idx = def_functions.ga_len;\n    ufunc->uf_dfunc_idx = dfunc->df_idx;\n    dfunc->df_ufunc = ufunc;\n    dfunc->df_name = vim_strsave(ufunc->uf_name);\n    ga_init2(&dfunc->df_var_names, sizeof(char_u *), 10);\n    ++dfunc->df_refcount;\n    ++def_functions.ga_len;\n    return OK;\n}\n\n/*\n * After ex_function() has collected all the function lines: parse and compile\n * the lines into instructions.\n * Adds the function to \"def_functions\".\n * When \"check_return_type\" is set then set ufunc->uf_ret_type to the type of\n * the return statement (used for lambda).  When uf_ret_type is already set\n * then check that it matches.\n * When \"profiling\" is true add ISN_PROF_START instructions.\n * \"outer_cctx\" is set for a nested function.\n * This can be used recursively through compile_lambda(), which may reallocate\n * \"def_functions\".\n * Returns OK or FAIL.\n */\n    int\ncompile_def_function(\n\tufunc_T\t\t*ufunc,\n\tint\t\tcheck_return_type,\n\tcompiletype_T   compile_type,\n\tcctx_T\t\t*outer_cctx)\n{\n    char_u\t*line = NULL;\n    char_u\t*line_to_free = NULL;\n    char_u\t*p;\n    char\t*errormsg = NULL;\t// error message\n    cctx_T\tcctx;\n    garray_T\t*instr;\n    int\t\tdid_emsg_before = did_emsg;\n    int\t\tdid_emsg_silent_before = did_emsg_silent;\n    int\t\tret = FAIL;\n    sctx_T\tsave_current_sctx = current_sctx;\n    int\t\tsave_estack_compiling = estack_compiling;\n    int\t\tsave_cmod_flags = cmdmod.cmod_flags;\n    int\t\tdo_estack_push;\n    int\t\tnew_def_function = FALSE;\n#ifdef FEAT_PROFILE\n    int\t\tprof_lnum = -1;\n#endif\n    int\t\tdebug_lnum = -1;\n\n    // When using a function that was compiled before: Free old instructions.\n    // The index is reused.  Otherwise add a new entry in \"def_functions\".\n    if (ufunc->uf_dfunc_idx > 0)\n    {\n\tdfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t + ufunc->uf_dfunc_idx;\n\tisn_T\t*instr_dest = NULL;\n\n\tswitch (compile_type)\n\t{\n\t    case CT_PROFILE:\n#ifdef FEAT_PROFILE\n\t\t\t    instr_dest = dfunc->df_instr_prof; break;\n#endif\n\t    case CT_NONE:   instr_dest = dfunc->df_instr; break;\n\t    case CT_DEBUG:  instr_dest = dfunc->df_instr_debug; break;\n\t}\n\tif (instr_dest != NULL)\n\t    // Was compiled in this mode before: Free old instructions.\n\t    delete_def_function_contents(dfunc, FALSE);\n\tga_clear_strings(&dfunc->df_var_names);\n    }\n    else\n    {\n\tif (add_def_function(ufunc) == FAIL)\n\t    return FAIL;\n\tnew_def_function = TRUE;\n    }\n\n    ufunc->uf_def_status = UF_COMPILING;\n\n    CLEAR_FIELD(cctx);\n\n    cctx.ctx_compile_type = compile_type;\n    cctx.ctx_ufunc = ufunc;\n    cctx.ctx_lnum = -1;\n    cctx.ctx_outer = outer_cctx;\n    ga_init2(&cctx.ctx_locals, sizeof(lvar_T), 10);\n    ga_init2(&cctx.ctx_type_stack, sizeof(type_T *), 50);\n    ga_init2(&cctx.ctx_imports, sizeof(imported_T), 10);\n    cctx.ctx_type_list = &ufunc->uf_type_list;\n    ga_init2(&cctx.ctx_instr, sizeof(isn_T), 50);\n    instr = &cctx.ctx_instr;\n\n    // Set the context to the function, it may be compiled when called from\n    // another script.  Set the script version to the most modern one.\n    // The line number will be set in next_line_from_context().\n    current_sctx = ufunc->uf_script_ctx;\n    current_sctx.sc_version = SCRIPT_VERSION_VIM9;\n\n    // Don't use the flag from \":legacy\" here.\n    cmdmod.cmod_flags &= ~CMOD_LEGACY;\n\n    // Make sure error messages are OK.\n    do_estack_push = !estack_top_is_ufunc(ufunc, 1);\n    if (do_estack_push)\n\testack_push_ufunc(ufunc, 1);\n    estack_compiling = TRUE;\n\n    if (ufunc->uf_def_args.ga_len > 0)\n    {\n\tint\tcount = ufunc->uf_def_args.ga_len;\n\tint\tfirst_def_arg = ufunc->uf_args.ga_len - count;\n\tint\ti;\n\tchar_u\t*arg;\n\tint\toff = STACK_FRAME_SIZE + (ufunc->uf_va_name != NULL ? 1 : 0);\n\tint\tdid_set_arg_type = FALSE;\n\n\t// Produce instructions for the default values of optional arguments.\n\tSOURCING_LNUM = 0;  // line number unknown\n\tfor (i = 0; i < count; ++i)\n\t{\n\t    garray_T\t*stack = &cctx.ctx_type_stack;\n\t    type_T\t*val_type;\n\t    int\t\targ_idx = first_def_arg + i;\n\t    where_T\twhere = WHERE_INIT;\n\t    int\t\tr;\n\t    int\t\tjump_instr_idx = instr->ga_len;\n\t    isn_T\t*isn;\n\n\t    // Use a JUMP_IF_ARG_SET instruction to skip if the value was given.\n\t    if (generate_JUMP_IF_ARG_SET(&cctx, i - count - off) == FAIL)\n\t\tgoto erret;\n\n\t    // Make sure later arguments are not found.\n\t    ufunc->uf_args_visible = arg_idx;\n\n\t    arg = ((char_u **)(ufunc->uf_def_args.ga_data))[i];\n\t    r = compile_expr0(&arg, &cctx);\n\n\t    if (r == FAIL)\n\t\tgoto erret;\n\n\t    // If no type specified use the type of the default value.\n\t    // Otherwise check that the default value type matches the\n\t    // specified type.\n\t    val_type = ((type_T **)stack->ga_data)[stack->ga_len - 1];\n\t    where.wt_index = arg_idx + 1;\n\t    if (ufunc->uf_arg_types[arg_idx] == &t_unknown)\n\t    {\n\t\tdid_set_arg_type = TRUE;\n\t\tufunc->uf_arg_types[arg_idx] = val_type;\n\t    }\n\t    else if (need_type_where(val_type, ufunc->uf_arg_types[arg_idx],\n\t\t\t\t       -1, where, &cctx, FALSE, FALSE) == FAIL)\n\t\tgoto erret;\n\n\t    if (generate_STORE(&cctx, ISN_STORE, i - count - off, NULL) == FAIL)\n\t\tgoto erret;\n\n\t    // set instruction index in JUMP_IF_ARG_SET to here\n\t    isn = ((isn_T *)instr->ga_data) + jump_instr_idx;\n\t    isn->isn_arg.jumparg.jump_where = instr->ga_len;\n\t}\n\n\tif (did_set_arg_type)\n\t    set_function_type(ufunc);\n    }\n    ufunc->uf_args_visible = ufunc->uf_args.ga_len;\n\n    /*\n     * Loop over all the lines of the function and generate instructions.\n     */\n    for (;;)\n    {\n\texarg_T\t    ea;\n\tint\t    starts_with_colon = FALSE;\n\tchar_u\t    *cmd;\n\tcmdmod_T    local_cmdmod;\n\n\t// Bail out on the first error to avoid a flood of errors and report\n\t// the right line number when inside try/catch.\n\tif (did_emsg_before != did_emsg)\n\t    goto erret;\n\n\tif (line != NULL && *line == '|')\n\t    // the line continues after a '|'\n\t    ++line;\n\telse if (line != NULL && *skipwhite(line) != NUL\n\t\t&& !(*line == '#' && (line == cctx.ctx_line_start\n\t\t\t\t\t\t    || VIM_ISWHITE(line[-1]))))\n\t{\n\t    semsg(_(e_trailing_arg), line);\n\t    goto erret;\n\t}\n\telse if (line != NULL && vim9_bad_comment(skipwhite(line)))\n\t    goto erret;\n\telse\n\t{\n\t    line = next_line_from_context(&cctx, FALSE);\n\t    if (cctx.ctx_lnum >= ufunc->uf_lines.ga_len)\n\t    {\n\t\t// beyond the last line\n#ifdef FEAT_PROFILE\n\t\tif (cctx.ctx_skip != SKIP_YES)\n\t\t    may_generate_prof_end(&cctx, prof_lnum);\n#endif\n\t\tbreak;\n\t    }\n\t    // Make a copy, splitting off nextcmd and removing trailing spaces\n\t    // may change it.\n\t    if (line != NULL)\n\t    {\n\t\tline = vim_strsave(line);\n\t\tvim_free(line_to_free);\n\t\tline_to_free = line;\n\t    }\n\t}\n\n\tCLEAR_FIELD(ea);\n\tea.cmdlinep = &line;\n\tea.cmd = skipwhite(line);\n\n\tif (*ea.cmd == '#')\n\t{\n\t    // \"#\" starts a comment\n\t    line = (char_u *)\"\";\n\t    continue;\n\t}\n\n#ifdef FEAT_PROFILE\n\tif (cctx.ctx_compile_type == CT_PROFILE && cctx.ctx_lnum != prof_lnum\n\t\t\t\t\t\t  && cctx.ctx_skip != SKIP_YES)\n\t{\n\t    may_generate_prof_end(&cctx, prof_lnum);\n\n\t    prof_lnum = cctx.ctx_lnum;\n\t    generate_instr(&cctx, ISN_PROF_START);\n\t}\n#endif\n\tif (cctx.ctx_compile_type == CT_DEBUG && cctx.ctx_lnum != debug_lnum\n\t\t\t\t\t\t  && cctx.ctx_skip != SKIP_YES)\n\t{\n\t    debug_lnum = cctx.ctx_lnum;\n\t    generate_instr_debug(&cctx);\n\t}\n\tcctx.ctx_prev_lnum = cctx.ctx_lnum + 1;\n\n\t// Some things can be recognized by the first character.\n\tswitch (*ea.cmd)\n\t{\n\t    case '}':\n\t\t{\n\t\t    // \"}\" ends a block scope\n\t\t    scopetype_T stype = cctx.ctx_scope == NULL\n\t\t\t\t\t  ? NO_SCOPE : cctx.ctx_scope->se_type;\n\n\t\t    if (stype == BLOCK_SCOPE)\n\t\t    {\n\t\t\tcompile_endblock(&cctx);\n\t\t\tline = ea.cmd;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\temsg(_(e_using_rcurly_outside_if_block_scope));\n\t\t\tgoto erret;\n\t\t    }\n\t\t    if (line != NULL)\n\t\t\tline = skipwhite(ea.cmd + 1);\n\t\t    continue;\n\t\t}\n\n\t    case '{':\n\t\t// \"{\" starts a block scope\n\t\t// \"{'a': 1}->func() is something else\n\t\tif (ends_excmd(*skipwhite(ea.cmd + 1)))\n\t\t{\n\t\t    line = compile_block(ea.cmd, &cctx);\n\t\t    continue;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/*\n\t * COMMAND MODIFIERS\n\t */\n\tcctx.ctx_has_cmdmod = FALSE;\n\tif (parse_command_modifiers(&ea, &errormsg, &local_cmdmod, FALSE)\n\t\t\t\t\t\t\t\t       == FAIL)\n\t{\n\t    if (errormsg != NULL)\n\t\tgoto erret;\n\t    // empty line or comment\n\t    line = (char_u *)\"\";\n\t    continue;\n\t}\n\tgenerate_cmdmods(&cctx, &local_cmdmod);\n\tundo_cmdmod(&local_cmdmod);\n\n\t// Check if there was a colon after the last command modifier or before\n\t// the current position.\n\tfor (p = ea.cmd; p >= line; --p)\n\t{\n\t    if (*p == ':')\n\t\tstarts_with_colon = TRUE;\n\t    if (p < ea.cmd && !VIM_ISWHITE(*p))\n\t\tbreak;\n\t}\n\n\t// Skip \":call\" to get to the function name, unless using :legacy\n\tp = ea.cmd;\n\tif (!(local_cmdmod.cmod_flags & CMOD_LEGACY))\n\t{\n\t    if (checkforcmd(&ea.cmd, \"call\", 3))\n\t    {\n\t\tif (*ea.cmd == '(')\n\t\t    // not for \"call()\"\n\t\t    ea.cmd = p;\n\t\telse\n\t\t    ea.cmd = skipwhite(ea.cmd);\n\t    }\n\n\t    if (!starts_with_colon)\n\t    {\n\t\tint\t    assign;\n\n\t\t// Check for assignment after command modifiers.\n\t\tassign = may_compile_assignment(&ea, &line, &cctx);\n\t\tif (assign == OK)\n\t\t    goto nextline;\n\t\tif (assign == FAIL)\n\t\t    goto erret;\n\t    }\n\t}\n\n\t/*\n\t * COMMAND after range\n\t * 'text'->func() should not be confused with 'a mark\n\t * \"++nr\" and \"--nr\" are eval commands\n\t * in \"$ENV->func()\" the \"$\" is not a range\n\t */\n\tcmd = ea.cmd;\n\tif ((*cmd != '$' || starts_with_colon)\n\t\t&& (starts_with_colon || !(*cmd == '\\''\n\t\t       || (cmd[0] == cmd[1] && (*cmd == '+' || *cmd == '-')))))\n\t{\n\t    ea.cmd = skip_range(ea.cmd, TRUE, NULL);\n\t    if (ea.cmd > cmd)\n\t    {\n\t\tif (!starts_with_colon\n\t\t\t\t   && !(local_cmdmod.cmod_flags & CMOD_LEGACY))\n\t\t{\n\t\t    semsg(_(e_colon_required_before_range_str), cmd);\n\t\t    goto erret;\n\t\t}\n\t\tea.addr_count = 1;\n\t\tif (ends_excmd2(line, ea.cmd))\n\t\t{\n\t\t    // A range without a command: jump to the line.\n\t\t    generate_EXEC(&cctx, ISN_EXECRANGE,\n\t\t\t\t\t      vim_strnsave(cmd, ea.cmd - cmd));\n\t\t    line = ea.cmd;\n\t\t    goto nextline;\n\t\t}\n\t    }\n\t}\n\tp = find_ex_command(&ea, NULL,\n\t\tstarts_with_colon || (local_cmdmod.cmod_flags & CMOD_LEGACY)\n\t\t\t\t\t\t  ? NULL : item_exists, &cctx);\n\n\tif (p == NULL)\n\t{\n\t    if (cctx.ctx_skip != SKIP_YES)\n\t\temsg(_(e_ambiguous_use_of_user_defined_command));\n\t    goto erret;\n\t}\n\n\t// When using \":legacy cmd\" always use compile_exec().\n\tif (local_cmdmod.cmod_flags & CMOD_LEGACY)\n\t{\n\t    char_u *start = ea.cmd;\n\n\t    switch (ea.cmdidx)\n\t    {\n\t\tcase CMD_if:\n\t\tcase CMD_elseif:\n\t\tcase CMD_else:\n\t\tcase CMD_endif:\n\t\tcase CMD_for:\n\t\tcase CMD_endfor:\n\t\tcase CMD_continue:\n\t\tcase CMD_break:\n\t\tcase CMD_while:\n\t\tcase CMD_endwhile:\n\t\tcase CMD_try:\n\t\tcase CMD_catch:\n\t\tcase CMD_finally:\n\t\tcase CMD_endtry:\n\t\t\tsemsg(_(e_cannot_use_legacy_with_command_str), ea.cmd);\n\t\t\tgoto erret;\n\t\tdefault: break;\n\t    }\n\n\t    // \":legacy return expr\" needs to be handled differently.\n\t    if (checkforcmd(&start, \"return\", 4))\n\t\tea.cmdidx = CMD_return;\n\t    else\n\t\tea.cmdidx = CMD_legacy;\n\t}\n\n\tif (p == ea.cmd && ea.cmdidx != CMD_SIZE)\n\t{\n\t    if (cctx.ctx_skip == SKIP_YES && ea.cmdidx != CMD_eval)\n\t    {\n\t\tline += STRLEN(line);\n\t\tgoto nextline;\n\t    }\n\t    else if (ea.cmdidx != CMD_eval)\n\t    {\n\t\t// CMD_var cannot happen, compile_assignment() above would be\n\t\t// used.  Most likely an assignment to a non-existing variable.\n\t\tsemsg(_(e_command_not_recognized_str), ea.cmd);\n\t\tgoto erret;\n\t    }\n\t}\n\n\tif (cctx.ctx_had_return\n\t\t&& ea.cmdidx != CMD_elseif\n\t\t&& ea.cmdidx != CMD_else\n\t\t&& ea.cmdidx != CMD_endif\n\t\t&& ea.cmdidx != CMD_endfor\n\t\t&& ea.cmdidx != CMD_endwhile\n\t\t&& ea.cmdidx != CMD_catch\n\t\t&& ea.cmdidx != CMD_finally\n\t\t&& ea.cmdidx != CMD_endtry)\n\t{\n\t    emsg(_(e_unreachable_code_after_return));\n\t    goto erret;\n\t}\n\n\tp = skipwhite(p);\n\tif (ea.cmdidx != CMD_SIZE\n\t\t\t    && ea.cmdidx != CMD_write && ea.cmdidx != CMD_read)\n\t{\n\t    if (ea.cmdidx >= 0)\n\t\tea.argt = excmd_get_argt(ea.cmdidx);\n\t    if ((ea.argt & EX_BANG) && *p == '!')\n\t    {\n\t\tea.forceit = TRUE;\n\t\tp = skipwhite(p + 1);\n\t    }\n\t}\n\n\tswitch (ea.cmdidx)\n\t{\n\t    case CMD_def:\n\t    case CMD_function:\n\t\t    ea.arg = p;\n\t\t    line = compile_nested_function(&ea, &cctx);\n\t\t    break;\n\n\t    case CMD_return:\n\t\t    line = compile_return(p, check_return_type,\n\t\t\t\t local_cmdmod.cmod_flags & CMOD_LEGACY, &cctx);\n\t\t    cctx.ctx_had_return = TRUE;\n\t\t    break;\n\n\t    case CMD_let:\n\t\t    emsg(_(e_cannot_use_let_in_vim9_script));\n\t\t    break;\n\t    case CMD_var:\n\t    case CMD_final:\n\t    case CMD_const:\n\t    case CMD_increment:\n\t    case CMD_decrement:\n\t\t    line = compile_assignment(p, &ea, ea.cmdidx, &cctx);\n\t\t    if (line == p)\n\t\t\tline = NULL;\n\t\t    break;\n\n\t    case CMD_unlet:\n\t    case CMD_unlockvar:\n\t    case CMD_lockvar:\n\t\t    line = compile_unletlock(p, &ea, &cctx);\n\t\t    break;\n\n\t    case CMD_import:\n\t\t    emsg(_(e_import_can_only_be_used_in_script));\n\t\t    line = NULL;\n\t\t    break;\n\n\t    case CMD_if:\n\t\t    line = compile_if(p, &cctx);\n\t\t    break;\n\t    case CMD_elseif:\n\t\t    line = compile_elseif(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\t    case CMD_else:\n\t\t    line = compile_else(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\t    case CMD_endif:\n\t\t    line = compile_endif(p, &cctx);\n\t\t    break;\n\n\t    case CMD_while:\n\t\t    line = compile_while(p, &cctx);\n\t\t    break;\n\t    case CMD_endwhile:\n\t\t    line = compile_endwhile(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\n\t    case CMD_for:\n\t\t    line = compile_for(p, &cctx);\n\t\t    break;\n\t    case CMD_endfor:\n\t\t    line = compile_endfor(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\t    case CMD_continue:\n\t\t    line = compile_continue(p, &cctx);\n\t\t    break;\n\t    case CMD_break:\n\t\t    line = compile_break(p, &cctx);\n\t\t    break;\n\n\t    case CMD_try:\n\t\t    line = compile_try(p, &cctx);\n\t\t    break;\n\t    case CMD_catch:\n\t\t    line = compile_catch(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\t    case CMD_finally:\n\t\t    line = compile_finally(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\t    case CMD_endtry:\n\t\t    line = compile_endtry(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\t    case CMD_throw:\n\t\t    line = compile_throw(p, &cctx);\n\t\t    break;\n\n\t    case CMD_eval:\n\t\t    line = compile_eval(p, &cctx);\n\t\t    break;\n\n\t    case CMD_echo:\n\t    case CMD_echon:\n\t    case CMD_execute:\n\t    case CMD_echomsg:\n\t    case CMD_echoerr:\n\t    case CMD_echoconsole:\n\t\t    line = compile_mult_expr(p, ea.cmdidx, &cctx);\n\t\t    break;\n\n\t    case CMD_put:\n\t\t    ea.cmd = cmd;\n\t\t    line = compile_put(p, &ea, &cctx);\n\t\t    break;\n\n\t    case CMD_substitute:\n\t\t    if (check_global_and_subst(ea.cmd, p) == FAIL)\n\t\t\tgoto erret;\n\t\t    if (cctx.ctx_skip == SKIP_YES)\n\t\t\tline = (char_u *)\"\";\n\t\t    else\n\t\t    {\n\t\t\tea.arg = p;\n\t\t\tline = compile_substitute(line, &ea, &cctx);\n\t\t    }\n\t\t    break;\n\n\t    case CMD_redir:\n\t\t    ea.arg = p;\n\t\t    line = compile_redir(line, &ea, &cctx);\n\t\t    break;\n\n\t    case CMD_cexpr:\n\t    case CMD_lexpr:\n\t    case CMD_caddexpr:\n\t    case CMD_laddexpr:\n\t    case CMD_cgetexpr:\n\t    case CMD_lgetexpr:\n#ifdef FEAT_QUICKFIX\n\t\t    ea.arg = p;\n\t\t    line = compile_cexpr(line, &ea, &cctx);\n#else\n\t\t    ex_ni(&ea);\n\t\t    line = NULL;\n#endif\n\t\t    break;\n\n\t    case CMD_append:\n\t    case CMD_change:\n\t    case CMD_insert:\n\t    case CMD_k:\n\t    case CMD_t:\n\t    case CMD_xit:\n\t\t    not_in_vim9(&ea);\n\t\t    goto erret;\n\n\t    case CMD_SIZE:\n\t\t    if (cctx.ctx_skip != SKIP_YES)\n\t\t    {\n\t\t\tsemsg(_(e_invalid_command_str), ea.cmd);\n\t\t\tgoto erret;\n\t\t    }\n\t\t    // We don't check for a next command here.\n\t\t    line = (char_u *)\"\";\n\t\t    break;\n\n\t    case CMD_lua:\n\t    case CMD_mzscheme:\n\t    case CMD_perl:\n\t    case CMD_py3:\n\t    case CMD_python3:\n\t    case CMD_python:\n\t    case CMD_pythonx:\n\t    case CMD_ruby:\n\t    case CMD_tcl:\n\t\t    ea.arg = p;\n\t\t    if (vim_strchr(line, '\\n') == NULL)\n\t\t\tline = compile_exec(line, &ea, &cctx);\n\t\t    else\n\t\t\t// heredoc lines have been concatenated with NL\n\t\t\t// characters in get_function_body()\n\t\t\tline = compile_script(line, &cctx);\n\t\t    break;\n\n\t    case CMD_global:\n\t\t    if (check_global_and_subst(ea.cmd, p) == FAIL)\n\t\t\tgoto erret;\n\t\t    // FALLTHROUGH\n\t    default:\n\t\t    // Not recognized, execute with do_cmdline_cmd().\n\t\t    ea.arg = p;\n\t\t    line = compile_exec(line, &ea, &cctx);\n\t\t    break;\n\t}\nnextline:\n\tif (line == NULL)\n\t    goto erret;\n\tline = skipwhite(line);\n\n\t// Undo any command modifiers.\n\tgenerate_undo_cmdmods(&cctx);\n\n\tif (cctx.ctx_type_stack.ga_len < 0)\n\t{\n\t    iemsg(\"Type stack underflow\");\n\t    goto erret;\n\t}\n    }\n\n    if (cctx.ctx_scope != NULL)\n    {\n\tif (cctx.ctx_scope->se_type == IF_SCOPE)\n\t    emsg(_(e_endif));\n\telse if (cctx.ctx_scope->se_type == WHILE_SCOPE)\n\t    emsg(_(e_endwhile));\n\telse if (cctx.ctx_scope->se_type == FOR_SCOPE)\n\t    emsg(_(e_endfor));\n\telse\n\t    emsg(_(e_missing_rcurly));\n\tgoto erret;\n    }\n\n    if (!cctx.ctx_had_return)\n    {\n\tif (ufunc->uf_ret_type->tt_type == VAR_UNKNOWN)\n\t    ufunc->uf_ret_type = &t_void;\n\telse if (ufunc->uf_ret_type->tt_type != VAR_VOID)\n\t{\n\t    emsg(_(e_missing_return_statement));\n\t    goto erret;\n\t}\n\n\t// Return void if there is no return at the end.\n\tgenerate_instr(&cctx, ISN_RETURN_VOID);\n    }\n\n    // When compiled with \":silent!\" and there was an error don't consider the\n    // function compiled.\n    if (emsg_silent == 0 || did_emsg_silent == did_emsg_silent_before)\n    {\n\tdfunc_T\t*dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t + ufunc->uf_dfunc_idx;\n\tdfunc->df_deleted = FALSE;\n\tdfunc->df_script_seq = current_sctx.sc_seq;\n#ifdef FEAT_PROFILE\n\tif (cctx.ctx_compile_type == CT_PROFILE)\n\t{\n\t    dfunc->df_instr_prof = instr->ga_data;\n\t    dfunc->df_instr_prof_count = instr->ga_len;\n\t}\n\telse\n#endif\n\tif (cctx.ctx_compile_type == CT_DEBUG)\n\t{\n\t    dfunc->df_instr_debug = instr->ga_data;\n\t    dfunc->df_instr_debug_count = instr->ga_len;\n\t}\n\telse\n\t{\n\t    dfunc->df_instr = instr->ga_data;\n\t    dfunc->df_instr_count = instr->ga_len;\n\t}\n\tdfunc->df_varcount = dfunc->df_var_names.ga_len;\n\tdfunc->df_has_closure = cctx.ctx_has_closure;\n\tif (cctx.ctx_outer_used)\n\t    ufunc->uf_flags |= FC_CLOSURE;\n\tufunc->uf_def_status = UF_COMPILED;\n    }\n\n    ret = OK;\n\nerret:\n    if (ufunc->uf_def_status == UF_COMPILING)\n    {\n\tdfunc_T\t*dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t + ufunc->uf_dfunc_idx;\n\n\t// Compiling aborted, free the generated instructions.\n\tclear_instr_ga(instr);\n\tVIM_CLEAR(dfunc->df_name);\n\tga_clear_strings(&dfunc->df_var_names);\n\n\t// If using the last entry in the table and it was added above, we\n\t// might as well remove it.\n\tif (!dfunc->df_deleted && new_def_function\n\t\t\t    && ufunc->uf_dfunc_idx == def_functions.ga_len - 1)\n\t{\n\t    --def_functions.ga_len;\n\t    ufunc->uf_dfunc_idx = 0;\n\t}\n\tufunc->uf_def_status = UF_COMPILE_ERROR;\n\n\twhile (cctx.ctx_scope != NULL)\n\t    drop_scope(&cctx);\n\n\tif (errormsg != NULL)\n\t    emsg(errormsg);\n\telse if (did_emsg == did_emsg_before)\n\t    emsg(_(e_compiling_def_function_failed));\n    }\n\n    if (cctx.ctx_redir_lhs.lhs_name != NULL)\n    {\n\tif (ret == OK)\n\t{\n\t    emsg(_(e_missing_redir_end));\n\t    ret = FAIL;\n\t}\n\tvim_free(cctx.ctx_redir_lhs.lhs_name);\n\tvim_free(cctx.ctx_redir_lhs.lhs_whole);\n    }\n\n    current_sctx = save_current_sctx;\n    estack_compiling = save_estack_compiling;\n    cmdmod.cmod_flags =\tsave_cmod_flags;\n    if (do_estack_push)\n\testack_pop();\n\n    vim_free(line_to_free);\n    free_imported(&cctx);\n    free_locals(&cctx);\n    ga_clear(&cctx.ctx_type_stack);\n    return ret;\n}\n\n    void\nset_function_type(ufunc_T *ufunc)\n{\n    int varargs = ufunc->uf_va_name != NULL;\n    int argcount = ufunc->uf_args.ga_len;\n\n    // Create a type for the function, with the return type and any\n    // argument types.\n    // A vararg is included in uf_args.ga_len but not in uf_arg_types.\n    // The type is included in \"tt_args\".\n    if (argcount > 0 || varargs)\n    {\n\tif (ufunc->uf_type_list.ga_itemsize == 0)\n\t    ga_init2(&ufunc->uf_type_list, sizeof(type_T *), 10);\n\tufunc->uf_func_type = alloc_func_type(ufunc->uf_ret_type,\n\t\t\t\t\t   argcount, &ufunc->uf_type_list);\n\t// Add argument types to the function type.\n\tif (func_type_add_arg_types(ufunc->uf_func_type,\n\t\t\t\t    argcount + varargs,\n\t\t\t\t    &ufunc->uf_type_list) == FAIL)\n\t    return;\n\tufunc->uf_func_type->tt_argcount = argcount + varargs;\n\tufunc->uf_func_type->tt_min_argcount =\n\t\t\t\t      argcount - ufunc->uf_def_args.ga_len;\n\tif (ufunc->uf_arg_types == NULL)\n\t{\n\t    int i;\n\n\t    // lambda does not have argument types.\n\t    for (i = 0; i < argcount; ++i)\n\t\tufunc->uf_func_type->tt_args[i] = &t_any;\n\t}\n\telse\n\t    mch_memmove(ufunc->uf_func_type->tt_args,\n\t\t\t ufunc->uf_arg_types, sizeof(type_T *) * argcount);\n\tif (varargs)\n\t{\n\t    ufunc->uf_func_type->tt_args[argcount] =\n\t\t   ufunc->uf_va_type == NULL ? &t_list_any : ufunc->uf_va_type;\n\t    ufunc->uf_func_type->tt_flags = TTFLAG_VARARGS;\n\t}\n    }\n    else\n\t// No arguments, can use a predefined type.\n\tufunc->uf_func_type = get_func_type(ufunc->uf_ret_type,\n\t\t\t\t\t   argcount, &ufunc->uf_type_list);\n}\n\n/*\n * Free all instructions for \"dfunc\" except df_name.\n */\n    static void\ndelete_def_function_contents(dfunc_T *dfunc, int mark_deleted)\n{\n    int idx;\n\n    ga_clear(&dfunc->df_def_args_isn);\n    ga_clear_strings(&dfunc->df_var_names);\n\n    if (dfunc->df_instr != NULL)\n    {\n\tfor (idx = 0; idx < dfunc->df_instr_count; ++idx)\n\t    delete_instr(dfunc->df_instr + idx);\n\tVIM_CLEAR(dfunc->df_instr);\n\tdfunc->df_instr = NULL;\n    }\n    if (dfunc->df_instr_debug != NULL)\n    {\n\tfor (idx = 0; idx < dfunc->df_instr_debug_count; ++idx)\n\t    delete_instr(dfunc->df_instr_debug + idx);\n\tVIM_CLEAR(dfunc->df_instr_debug);\n\tdfunc->df_instr_debug = NULL;\n    }\n#ifdef FEAT_PROFILE\n    if (dfunc->df_instr_prof != NULL)\n    {\n\tfor (idx = 0; idx < dfunc->df_instr_prof_count; ++idx)\n\t    delete_instr(dfunc->df_instr_prof + idx);\n\tVIM_CLEAR(dfunc->df_instr_prof);\n\tdfunc->df_instr_prof = NULL;\n    }\n#endif\n\n    if (mark_deleted)\n\tdfunc->df_deleted = TRUE;\n    if (dfunc->df_ufunc != NULL)\n\tdfunc->df_ufunc->uf_def_status = UF_NOT_COMPILED;\n}\n\n/*\n * When a user function is deleted, clear the contents of any associated def\n * function, unless another user function still uses it.\n * The position in def_functions can be re-used.\n */\n    void\nunlink_def_function(ufunc_T *ufunc)\n{\n    if (ufunc->uf_dfunc_idx > 0)\n    {\n\tdfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t + ufunc->uf_dfunc_idx;\n\n\tif (--dfunc->df_refcount <= 0)\n\t    delete_def_function_contents(dfunc, TRUE);\n\tufunc->uf_def_status = UF_NOT_COMPILED;\n\tufunc->uf_dfunc_idx = 0;\n\tif (dfunc->df_ufunc == ufunc)\n\t    dfunc->df_ufunc = NULL;\n    }\n}\n\n/*\n * Used when a user function refers to an existing dfunc.\n */\n    void\nlink_def_function(ufunc_T *ufunc)\n{\n    if (ufunc->uf_dfunc_idx > 0)\n    {\n\tdfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t + ufunc->uf_dfunc_idx;\n\n\t++dfunc->df_refcount;\n    }\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n/*\n * Free all functions defined with \":def\".\n */\n    void\nfree_def_functions(void)\n{\n    int idx;\n\n    for (idx = 0; idx < def_functions.ga_len; ++idx)\n    {\n\tdfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data) + idx;\n\n\tdelete_def_function_contents(dfunc, TRUE);\n\tvim_free(dfunc->df_name);\n    }\n\n    ga_clear(&def_functions);\n}\n#endif\n\n\n#endif // FEAT_EVAL\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * vim9execute.c: execute Vim9 script instructions\n */\n\n#define USING_FLOAT_STUFF\n#include \"vim.h\"\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n\n// When not generating protos this is included in proto.h\n#ifdef PROTO\n# include \"vim9.h\"\n#endif\n\n\n// Structure put on ec_trystack when ISN_TRY is encountered.\ntypedef struct {\n    int\t    tcd_frame_idx;\t// ec_frame_idx at ISN_TRY\n    int\t    tcd_stack_len;\t// size of ectx.ec_stack at ISN_TRY\n    int\t    tcd_in_catch;\t// in catch or finally block\n    int\t    tcd_did_throw;\t// set did_throw in :endtry\n    int\t    tcd_catch_idx;\t// instruction of the first :catch or :finally\n    int\t    tcd_finally_idx;\t// instruction of the :finally block or zero\n    int\t    tcd_endtry_idx;\t// instruction of the :endtry\n    int\t    tcd_caught;\t\t// catch block entered\n    int\t    tcd_cont;\t\t// :continue encountered, jump here (minus one)\n    int\t    tcd_return;\t\t// when TRUE return from end of :finally\n} trycmd_T;\n\n// Data local to a function.\n// On a function call, if not empty, is saved on the stack and restored when\n// returning.\ntypedef struct {\n    int\t\tfloc_restore_cmdmod;\n    cmdmod_T\tfloc_save_cmdmod;\n    int\t\tfloc_restore_cmdmod_stacklen;\n} funclocal_T;\n\n// Structure to hold a reference to an outer_T, with information of whether it\n// was allocated.\ntypedef struct {\n    outer_T\t*or_outer;\n    partial_T\t*or_partial;\t// decrement \"or_partial->pt_refcount\" later\n    int\t\tor_outer_allocated;  // free \"or_outer\" later\n} outer_ref_T;\n\n// A stack is used to store:\n// - arguments passed to a :def function\n// - info about the calling function, to use when returning\n// - local variables\n// - temporary values\n//\n// In detail (FP == Frame Pointer):\n//\t  arg1\t\tfirst argument from caller (if present)\n//\t  arg2\t\tsecond argument from caller (if present)\n//\t  extra_arg1\tany missing optional argument default value\n// FP ->  cur_func\tcalling function\n//        current\tprevious instruction pointer\n//        frame_ptr\tprevious Frame Pointer\n//        var1\t\tspace for local variable\n//        var2\t\tspace for local variable\n//        ....\t\tfixed space for max. number of local variables\n//        temp\t\ttemporary values\n//        ....\t\tflexible space for temporary values (can grow big)\n\n/*\n * Execution context.\n */\nstruct ectx_S {\n    garray_T\tec_stack;\t// stack of typval_T values\n    int\t\tec_frame_idx;\t// index in ec_stack: context of ec_dfunc_idx\n    int\t\tec_initial_frame_idx;\t// frame index when called\n\n    outer_ref_T\t*ec_outer_ref;\t// outer scope used for closures, allocated\n    funclocal_T ec_funclocal;\n\n    garray_T\tec_trystack;\t// stack of trycmd_T values\n\n    isn_T\t*ec_instr;\t// array with instructions\n    int\t\tec_dfunc_idx;\t// current function index\n    int\t\tec_iidx;\t// index in ec_instr: instruction to execute\n\n    garray_T\tec_funcrefs;\t// partials that might be a closure\n\n    int\t\tec_did_emsg_before;\n    int\t\tec_trylevel_at_start;\n    where_T\tec_where;\n};\n\n#ifdef FEAT_PROFILE\n// stack of profinfo_T used when profiling.\nstatic garray_T profile_info_ga = {0, 0, sizeof(profinfo_T), 20, NULL};\n#endif\n\n// Get pointer to item relative to the bottom of the stack, -1 is the last one.\n#define STACK_TV_BOT(idx) (((typval_T *)ectx->ec_stack.ga_data) + ectx->ec_stack.ga_len + (idx))\n\n    void\nto_string_error(vartype_T vartype)\n{\n    semsg(_(e_cannot_convert_str_to_string), vartype_name(vartype));\n}\n\n/*\n * Return the number of arguments, including optional arguments and any vararg.\n */\n    static int\nufunc_argcount(ufunc_T *ufunc)\n{\n    return ufunc->uf_args.ga_len + (ufunc->uf_va_name != NULL ? 1 : 0);\n}\n\n/*\n * Create a new list from \"count\" items at the bottom of the stack.\n * When \"count\" is zero an empty list is added to the stack.\n */\n    static int\nexe_newlist(int count, ectx_T *ectx)\n{\n    list_T\t*list = list_alloc_with_items(count);\n    int\t\tidx;\n    typval_T\t*tv;\n\n    if (list == NULL)\n\treturn FAIL;\n    for (idx = 0; idx < count; ++idx)\n\tlist_set_item(list, idx, STACK_TV_BOT(idx - count));\n\n    if (count > 0)\n\tectx->ec_stack.ga_len -= count - 1;\n    else if (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\treturn FAIL;\n    else\n\t++ectx->ec_stack.ga_len;\n    tv = STACK_TV_BOT(-1);\n    tv->v_type = VAR_LIST;\n    tv->vval.v_list = list;\n    ++list->lv_refcount;\n    return OK;\n}\n\n/*\n * If debug_tick changed check if \"ufunc\" has a breakpoint and update\n * \"uf_has_breakpoint\".\n */\n    static void\nupdate_has_breakpoint(ufunc_T *ufunc)\n{\n    if (ufunc->uf_debug_tick != debug_tick)\n    {\n\tlinenr_T breakpoint;\n\n\tufunc->uf_debug_tick = debug_tick;\n\tbreakpoint = dbg_find_breakpoint(FALSE, ufunc->uf_name, 0);\n\tufunc->uf_has_breakpoint = breakpoint > 0;\n    }\n}\n\nstatic garray_T dict_stack = GA_EMPTY;\n\n/*\n * Put a value on the dict stack.  This consumes \"tv\".\n */\n    static int\ndict_stack_save(typval_T *tv)\n{\n    if (dict_stack.ga_growsize == 0)\n\tga_init2(&dict_stack, (int)sizeof(typval_T), 10);\n    if (ga_grow(&dict_stack, 1) == FAIL)\n\treturn FAIL;\n    ((typval_T *)dict_stack.ga_data)[dict_stack.ga_len] = *tv;\n    ++dict_stack.ga_len;\n    return OK;\n}\n\n/*\n * Get the typval at top of the dict stack.\n */\n    static typval_T *\ndict_stack_get_tv(void)\n{\n    if (dict_stack.ga_len == 0)\n\treturn NULL;\n    return ((typval_T *)dict_stack.ga_data) + dict_stack.ga_len - 1;\n}\n\n/*\n * Get the dict at top of the dict stack.\n */\n    static dict_T *\ndict_stack_get_dict(void)\n{\n    typval_T *tv;\n\n    if (dict_stack.ga_len == 0)\n\treturn NULL;\n    tv = ((typval_T *)dict_stack.ga_data) + dict_stack.ga_len - 1;\n    if (tv->v_type == VAR_DICT)\n\treturn tv->vval.v_dict;\n    return NULL;\n}\n\n/*\n * Drop an item from the dict stack.\n */\n    static void\ndict_stack_drop(void)\n{\n    if (dict_stack.ga_len == 0)\n    {\n\tiemsg(\"Dict stack underflow\");\n\treturn;\n    }\n    --dict_stack.ga_len;\n    clear_tv(((typval_T *)dict_stack.ga_data) + dict_stack.ga_len);\n}\n\n/*\n * Drop items from the dict stack until the length is equal to \"len\".\n */\n    static void\ndict_stack_clear(int len)\n{\n    while (dict_stack.ga_len > len)\n\tdict_stack_drop();\n}\n\n/*\n * Call compiled function \"cdf_idx\" from compiled code.\n * This adds a stack frame and sets the instruction pointer to the start of the\n * called function.\n * If \"pt\" is not null use \"pt->pt_outer\" for ec_outer_ref->or_outer.\n *\n * Stack has:\n * - current arguments (already there)\n * - omitted optional argument (default values) added here\n * - stack frame:\n *\t- pointer to calling function\n *\t- Index of next instruction in calling function\n *\t- previous frame pointer\n * - reserved space for local variables\n */\n    static int\ncall_dfunc(\n\tint\t\tcdf_idx,\n\tpartial_T\t*pt,\n\tint\t\targcount_arg,\n\tectx_T\t\t*ectx)\n{\n    int\t\targcount = argcount_arg;\n    dfunc_T\t*dfunc = ((dfunc_T *)def_functions.ga_data) + cdf_idx;\n    ufunc_T\t*ufunc = dfunc->df_ufunc;\n    int\t\tdid_emsg_before = did_emsg_cumul + did_emsg;\n    int\t\targ_to_add;\n    int\t\tvararg_count = 0;\n    int\t\tvarcount;\n    int\t\tidx;\n    estack_T\t*entry;\n    funclocal_T\t*floc = NULL;\n    int\t\tres = OK;\n\n    if (dfunc->df_deleted)\n    {\n\t// don't use ufunc->uf_name, it may have been freed\n\temsg_funcname(e_func_deleted,\n\t\tdfunc->df_name == NULL ? (char_u *)\"unknown\" : dfunc->df_name);\n\treturn FAIL;\n    }\n\n#ifdef FEAT_PROFILE\n    if (do_profiling == PROF_YES)\n    {\n\tif (GA_GROW_OK(&profile_info_ga, 1))\n\t{\n\t    profinfo_T *info = ((profinfo_T *)profile_info_ga.ga_data)\n\t\t\t\t\t\t      + profile_info_ga.ga_len;\n\t    ++profile_info_ga.ga_len;\n\t    CLEAR_POINTER(info);\n\t    profile_may_start_func(info, ufunc,\n\t\t\t(((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t      + ectx->ec_dfunc_idx)->df_ufunc);\n\t}\n    }\n#endif\n\n    // Update uf_has_breakpoint if needed.\n    update_has_breakpoint(ufunc);\n\n    // When debugging and using \"cont\" switches to the not-debugged\n    // instructions, may need to still compile them.\n    if (func_needs_compiling(ufunc, COMPILE_TYPE(ufunc)))\n    {\n\tres = compile_def_function(ufunc, FALSE, COMPILE_TYPE(ufunc), NULL);\n\n\t// compile_def_function() may cause def_functions.ga_data to change\n\tdfunc = ((dfunc_T *)def_functions.ga_data) + cdf_idx;\n    }\n    if (res == FAIL || INSTRUCTIONS(dfunc) == NULL)\n    {\n\tif (did_emsg_cumul + did_emsg == did_emsg_before)\n\t    semsg(_(e_function_is_not_compiled_str),\n\t\t\t\t\t\t   printable_func_name(ufunc));\n\treturn FAIL;\n    }\n\n    if (ufunc->uf_va_name != NULL)\n    {\n\t// Need to make a list out of the vararg arguments.\n\t// Stack at time of call with 2 varargs:\n\t//   normal_arg\n\t//   optional_arg\n\t//   vararg_1\n\t//   vararg_2\n\t// After creating the list:\n\t//   normal_arg\n\t//   optional_arg\n\t//   vararg-list\n\t// With missing optional arguments we get:\n\t//    normal_arg\n\t// After creating the list\n\t//    normal_arg\n\t//    (space for optional_arg)\n\t//    vararg-list\n\tvararg_count = argcount - ufunc->uf_args.ga_len;\n\tif (vararg_count < 0)\n\t    vararg_count = 0;\n\telse\n\t    argcount -= vararg_count;\n\tif (exe_newlist(vararg_count, ectx) == FAIL)\n\t    return FAIL;\n\n\tvararg_count = 1;\n    }\n\n    arg_to_add = ufunc->uf_args.ga_len - argcount;\n    if (arg_to_add < 0)\n    {\n\tif (arg_to_add == -1)\n\t    emsg(_(e_one_argument_too_many));\n\telse\n\t    semsg(_(e_nr_arguments_too_many), -arg_to_add);\n\treturn FAIL;\n    }\n\n    // Reserve space for:\n    // - missing arguments\n    // - stack frame\n    // - local variables\n    // - if needed: a counter for number of closures created in\n    //   ectx->ec_funcrefs.\n    varcount = dfunc->df_varcount + dfunc->df_has_closure;\n    if (GA_GROW_FAILS(&ectx->ec_stack, arg_to_add + STACK_FRAME_SIZE + varcount))\n\treturn FAIL;\n\n    // If depth of calling is getting too high, don't execute the function.\n    if (funcdepth_increment() == FAIL)\n\treturn FAIL;\n    ++ex_nesting_level;\n\n    // Only make a copy of funclocal if it contains something to restore.\n    if (ectx->ec_funclocal.floc_restore_cmdmod)\n    {\n\tfloc = ALLOC_ONE(funclocal_T);\n\tif (floc == NULL)\n\t    return FAIL;\n\t*floc = ectx->ec_funclocal;\n\tectx->ec_funclocal.floc_restore_cmdmod = FALSE;\n    }\n\n    // Move the vararg-list to below the missing optional arguments.\n    if (vararg_count > 0 && arg_to_add > 0)\n\t*STACK_TV_BOT(arg_to_add - 1) = *STACK_TV_BOT(-1);\n\n    // Reserve space for omitted optional arguments, filled in soon.\n    for (idx = 0; idx < arg_to_add; ++idx)\n\tSTACK_TV_BOT(idx - vararg_count)->v_type = VAR_UNKNOWN;\n    ectx->ec_stack.ga_len += arg_to_add;\n\n    // Store current execution state in stack frame for ISN_RETURN.\n    STACK_TV_BOT(STACK_FRAME_FUNC_OFF)->vval.v_number = ectx->ec_dfunc_idx;\n    STACK_TV_BOT(STACK_FRAME_IIDX_OFF)->vval.v_number = ectx->ec_iidx;\n    STACK_TV_BOT(STACK_FRAME_INSTR_OFF)->vval.v_string = (void *)ectx->ec_instr;\n    STACK_TV_BOT(STACK_FRAME_OUTER_OFF)->vval.v_string =\n\t\t\t\t\t\t    (void *)ectx->ec_outer_ref;\n    STACK_TV_BOT(STACK_FRAME_FUNCLOCAL_OFF)->vval.v_string = (void *)floc;\n    STACK_TV_BOT(STACK_FRAME_IDX_OFF)->vval.v_number = ectx->ec_frame_idx;\n    ectx->ec_frame_idx = ectx->ec_stack.ga_len;\n\n    // Initialize local variables\n    for (idx = 0; idx < dfunc->df_varcount; ++idx)\n    {\n\ttypval_T *tv = STACK_TV_BOT(STACK_FRAME_SIZE + idx);\n\n\ttv->v_type = VAR_NUMBER;\n\ttv->vval.v_number = 0;\n    }\n    if (dfunc->df_has_closure)\n    {\n\ttypval_T *tv = STACK_TV_BOT(STACK_FRAME_SIZE + dfunc->df_varcount);\n\n\ttv->v_type = VAR_NUMBER;\n\ttv->vval.v_number = 0;\n    }\n    ectx->ec_stack.ga_len += STACK_FRAME_SIZE + varcount;\n\n    if (pt != NULL || ufunc->uf_partial != NULL\n\t\t\t\t\t     || (ufunc->uf_flags & FC_CLOSURE))\n    {\n\touter_ref_T *ref = ALLOC_CLEAR_ONE(outer_ref_T);\n\n\tif (ref == NULL)\n\t    return FAIL;\n\tif (pt != NULL)\n\t{\n\t    ref->or_outer = &pt->pt_outer;\n\t    ++pt->pt_refcount;\n\t    ref->or_partial = pt;\n\t}\n\telse if (ufunc->uf_partial != NULL)\n\t{\n\t    ref->or_outer = &ufunc->uf_partial->pt_outer;\n\t    ++ufunc->uf_partial->pt_refcount;\n\t    ref->or_partial = ufunc->uf_partial;\n\t}\n\telse\n\t{\n\t    ref->or_outer = ALLOC_CLEAR_ONE(outer_T);\n\t    if (unlikely(ref->or_outer == NULL))\n\t    {\n\t\tvim_free(ref);\n\t\treturn FAIL;\n\t    }\n\t    ref->or_outer_allocated = TRUE;\n\t    ref->or_outer->out_stack = &ectx->ec_stack;\n\t    ref->or_outer->out_frame_idx = ectx->ec_frame_idx;\n\t    if (ectx->ec_outer_ref != NULL)\n\t\tref->or_outer->out_up = ectx->ec_outer_ref->or_outer;\n\t}\n\tectx->ec_outer_ref = ref;\n    }\n    else\n\tectx->ec_outer_ref = NULL;\n\n    ++ufunc->uf_calls;\n\n    // Set execution state to the start of the called function.\n    ectx->ec_dfunc_idx = cdf_idx;\n    ectx->ec_instr = INSTRUCTIONS(dfunc);\n    entry = estack_push_ufunc(ufunc, 1);\n    if (entry != NULL)\n    {\n\t// Set the script context to the script where the function was defined.\n\t// Save the current context so it can be restored on return.\n\tentry->es_save_sctx = current_sctx;\n\tcurrent_sctx = ufunc->uf_script_ctx;\n    }\n\n    // Start execution at the first instruction.\n    ectx->ec_iidx = 0;\n\n    return OK;\n}\n\n// Get pointer to item in the stack.\n#define STACK_TV(idx) (((typval_T *)ectx->ec_stack.ga_data) + idx)\n\n// Double linked list of funcstack_T in use.\nstatic funcstack_T *first_funcstack = NULL;\n\n    static void\nadd_funcstack_to_list(funcstack_T *funcstack)\n{\n\t// Link in list of funcstacks.\n    if (first_funcstack != NULL)\n\tfirst_funcstack->fs_prev = funcstack;\n    funcstack->fs_next = first_funcstack;\n    funcstack->fs_prev = NULL;\n    first_funcstack = funcstack;\n}\n\n    static void\nremove_funcstack_from_list(funcstack_T *funcstack)\n{\n    if (funcstack->fs_prev == NULL)\n\tfirst_funcstack = funcstack->fs_next;\n    else\n\tfuncstack->fs_prev->fs_next = funcstack->fs_next;\n    if (funcstack->fs_next != NULL)\n\tfuncstack->fs_next->fs_prev = funcstack->fs_prev;\n}\n\n/*\n * Used when returning from a function: Check if any closure is still\n * referenced.  If so then move the arguments and variables to a separate piece\n * of stack to be used when the closure is called.\n * When \"free_arguments\" is TRUE the arguments are to be freed.\n * Returns FAIL when out of memory.\n */\n    static int\nhandle_closure_in_use(ectx_T *ectx, int free_arguments)\n{\n    dfunc_T\t*dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t  + ectx->ec_dfunc_idx;\n    int\t\targcount;\n    int\t\ttop;\n    int\t\tidx;\n    typval_T\t*tv;\n    int\t\tclosure_in_use = FALSE;\n    garray_T\t*gap = &ectx->ec_funcrefs;\n    varnumber_T\tclosure_count;\n\n    if (dfunc->df_ufunc == NULL)\n\treturn OK;  // function was freed\n    if (dfunc->df_has_closure == 0)\n\treturn OK;  // no closures\n    tv = STACK_TV(ectx->ec_frame_idx + STACK_FRAME_SIZE + dfunc->df_varcount);\n    closure_count = tv->vval.v_number;\n    if (closure_count == 0)\n\treturn OK;  // no funcrefs created\n\n    argcount = ufunc_argcount(dfunc->df_ufunc);\n    top = ectx->ec_frame_idx - argcount;\n\n    // Check if any created closure is still in use.\n    for (idx = 0; idx < closure_count; ++idx)\n    {\n\tpartial_T   *pt;\n\tint\t    off = gap->ga_len - closure_count + idx;\n\n\tif (off < 0)\n\t    continue;  // count is off or already done\n\tpt = ((partial_T **)gap->ga_data)[off];\n\tif (pt->pt_refcount > 1)\n\t{\n\t    int refcount = pt->pt_refcount;\n\t    int i;\n\n\t    // A Reference in a local variables doesn't count, it gets\n\t    // unreferenced on return.\n\t    for (i = 0; i < dfunc->df_varcount; ++i)\n\t    {\n\t\ttypval_T *stv = STACK_TV(ectx->ec_frame_idx\n\t\t\t\t\t\t       + STACK_FRAME_SIZE + i);\n\t\tif (stv->v_type == VAR_PARTIAL && pt == stv->vval.v_partial)\n\t\t    --refcount;\n\t    }\n\t    if (refcount > 1)\n\t    {\n\t\tclosure_in_use = TRUE;\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    if (closure_in_use)\n    {\n\tfuncstack_T *funcstack = ALLOC_CLEAR_ONE(funcstack_T);\n\ttypval_T    *stack;\n\n\t// A closure is using the arguments and/or local variables.\n\t// Move them to the called function.\n\tif (funcstack == NULL)\n\t    return FAIL;\n\n\tfuncstack->fs_var_offset = argcount + STACK_FRAME_SIZE;\n\tfuncstack->fs_ga.ga_len = funcstack->fs_var_offset + dfunc->df_varcount;\n\tstack = ALLOC_CLEAR_MULT(typval_T, funcstack->fs_ga.ga_len);\n\tfuncstack->fs_ga.ga_data = stack;\n\tif (stack == NULL)\n\t{\n\t    vim_free(funcstack);\n\t    return FAIL;\n\t}\n\tadd_funcstack_to_list(funcstack);\n\n\t// Move or copy the arguments.\n\tfor (idx = 0; idx < argcount; ++idx)\n\t{\n\t    tv = STACK_TV(top + idx);\n\t    if (free_arguments)\n\t    {\n\t\t*(stack + idx) = *tv;\n\t\ttv->v_type = VAR_UNKNOWN;\n\t    }\n\t    else\n\t\tcopy_tv(tv, stack + idx);\n\t}\n\t// Move the local variables.\n\tfor (idx = 0; idx < dfunc->df_varcount; ++idx)\n\t{\n\t    tv = STACK_TV(ectx->ec_frame_idx + STACK_FRAME_SIZE + idx);\n\n\t    // A partial created for a local function, that is also used as a\n\t    // local variable, has a reference count for the variable, thus\n\t    // will never go down to zero.  When all these refcounts are one\n\t    // then the funcstack is unused.  We need to count how many we have\n\t    // so we know when to check.\n\t    if (tv->v_type == VAR_PARTIAL && tv->vval.v_partial != NULL)\n\t    {\n\t\tint\t    i;\n\n\t\tfor (i = 0; i < closure_count; ++i)\n\t\t    if (tv->vval.v_partial == ((partial_T **)gap->ga_data)[\n\t\t\t\t\t      gap->ga_len - closure_count + i])\n\t\t\t++funcstack->fs_min_refcount;\n\t    }\n\n\t    *(stack + funcstack->fs_var_offset + idx) = *tv;\n\t    tv->v_type = VAR_UNKNOWN;\n\t}\n\n\tfor (idx = 0; idx < closure_count; ++idx)\n\t{\n\t    partial_T *pt = ((partial_T **)gap->ga_data)[gap->ga_len\n\t\t\t\t\t\t\t- closure_count + idx];\n\t    if (pt->pt_refcount > 1)\n\t    {\n\t\t++funcstack->fs_refcount;\n\t\tpt->pt_funcstack = funcstack;\n\t\tpt->pt_outer.out_stack = &funcstack->fs_ga;\n\t\tpt->pt_outer.out_frame_idx = ectx->ec_frame_idx - top;\n\t    }\n\t}\n    }\n\n    for (idx = 0; idx < closure_count; ++idx)\n\tpartial_unref(((partial_T **)gap->ga_data)[gap->ga_len\n\t\t\t\t\t\t       - closure_count + idx]);\n    gap->ga_len -= closure_count;\n    if (gap->ga_len == 0)\n\tga_clear(gap);\n\n    return OK;\n}\n\n/*\n * Called when a partial is freed or its reference count goes down to one.  The\n * funcstack may be the only reference to the partials in the local variables.\n * Go over all of them, the funcref and can be freed if all partials\n * referencing the funcstack have a reference count of one.\n */\n    void\nfuncstack_check_refcount(funcstack_T *funcstack)\n{\n    int\t\t    i;\n    garray_T\t    *gap = &funcstack->fs_ga;\n    int\t\t    done = 0;\n\n    if (funcstack->fs_refcount > funcstack->fs_min_refcount)\n\treturn;\n    for (i = funcstack->fs_var_offset; i < gap->ga_len; ++i)\n    {\n\ttypval_T *tv = ((typval_T *)gap->ga_data) + i;\n\n\tif (tv->v_type == VAR_PARTIAL && tv->vval.v_partial != NULL\n\t\t&& tv->vval.v_partial->pt_funcstack == funcstack\n\t\t&& tv->vval.v_partial->pt_refcount == 1)\n\t    ++done;\n    }\n    if (done == funcstack->fs_min_refcount)\n    {\n\ttypval_T\t*stack = gap->ga_data;\n\n\t// All partials referencing the funcstack have a reference count of\n\t// one, thus the funcstack is no longer of use.\n\tfor (i = 0; i < gap->ga_len; ++i)\n\t    clear_tv(stack + i);\n\tvim_free(stack);\n\tremove_funcstack_from_list(funcstack);\n\tvim_free(funcstack);\n    }\n}\n\n/*\n * For garbage collecting: set references in all variables referenced by\n * all funcstacks.\n */\n    int\nset_ref_in_funcstacks(int copyID)\n{\n    funcstack_T *funcstack;\n\n    for (funcstack = first_funcstack; funcstack != NULL;\n\t\t\t\t\t\tfuncstack = funcstack->fs_next)\n    {\n\ttypval_T    *stack = funcstack->fs_ga.ga_data;\n\tint\t    i;\n\n\tfor (i = 0; i < funcstack->fs_ga.ga_len; ++i)\n\t    if (set_ref_in_item(stack + i, copyID, NULL, NULL))\n\t\treturn TRUE;  // abort\n    }\n    return FALSE;\n}\n\n/*\n * Return from the current function.\n */\n    static int\nfunc_return(ectx_T *ectx)\n{\n    int\t\tidx;\n    int\t\tret_idx;\n    dfunc_T\t*dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t  + ectx->ec_dfunc_idx;\n    int\t\targcount = ufunc_argcount(dfunc->df_ufunc);\n    int\t\ttop = ectx->ec_frame_idx - argcount;\n    estack_T\t*entry;\n    int\t\tprev_dfunc_idx = STACK_TV(ectx->ec_frame_idx\n\t\t\t\t\t+ STACK_FRAME_FUNC_OFF)->vval.v_number;\n    funclocal_T\t*floc;\n#ifdef FEAT_PROFILE\n    dfunc_T\t*prev_dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t      + prev_dfunc_idx;\n\n    if (do_profiling == PROF_YES)\n    {\n\tufunc_T *caller = prev_dfunc->df_ufunc;\n\n\tif (dfunc->df_ufunc->uf_profiling\n\t\t\t\t   || (caller != NULL && caller->uf_profiling))\n\t{\n\t    profile_may_end_func(((profinfo_T *)profile_info_ga.ga_data)\n\t\t\t+ profile_info_ga.ga_len - 1, dfunc->df_ufunc, caller);\n\t    --profile_info_ga.ga_len;\n\t}\n    }\n#endif\n\n    // No check for uf_refcount being zero, cannot think of a way that would\n    // happen.\n    --dfunc->df_ufunc->uf_calls;\n\n    // execution context goes one level up\n    entry = estack_pop();\n    if (entry != NULL)\n\tcurrent_sctx = entry->es_save_sctx;\n\n    if (handle_closure_in_use(ectx, TRUE) == FAIL)\n\treturn FAIL;\n\n    // Clear the arguments.\n    for (idx = top; idx < ectx->ec_frame_idx; ++idx)\n\tclear_tv(STACK_TV(idx));\n\n    // Clear local variables and temp values, but not the return value.\n    for (idx = ectx->ec_frame_idx + STACK_FRAME_SIZE;\n\t\t\t\t\tidx < ectx->ec_stack.ga_len - 1; ++idx)\n\tclear_tv(STACK_TV(idx));\n\n    // The return value should be on top of the stack.  However, when aborting\n    // it may not be there and ec_frame_idx is the top of the stack.\n    ret_idx = ectx->ec_stack.ga_len - 1;\n    if (ret_idx == ectx->ec_frame_idx + STACK_FRAME_IDX_OFF)\n\tret_idx = 0;\n\n    if (ectx->ec_outer_ref != NULL)\n    {\n\tif (ectx->ec_outer_ref->or_outer_allocated)\n\t    vim_free(ectx->ec_outer_ref->or_outer);\n\tpartial_unref(ectx->ec_outer_ref->or_partial);\n\tvim_free(ectx->ec_outer_ref);\n    }\n\n    // Restore the previous frame.\n    ectx->ec_dfunc_idx = prev_dfunc_idx;\n    ectx->ec_iidx = STACK_TV(ectx->ec_frame_idx\n\t\t\t\t\t+ STACK_FRAME_IIDX_OFF)->vval.v_number;\n    ectx->ec_instr = (void *)STACK_TV(ectx->ec_frame_idx\n\t\t\t\t       + STACK_FRAME_INSTR_OFF)->vval.v_string;\n    ectx->ec_outer_ref = (void *)STACK_TV(ectx->ec_frame_idx\n\t\t\t\t       + STACK_FRAME_OUTER_OFF)->vval.v_string;\n    floc = (void *)STACK_TV(ectx->ec_frame_idx\n\t\t\t\t   + STACK_FRAME_FUNCLOCAL_OFF)->vval.v_string;\n    // restoring ec_frame_idx must be last\n    ectx->ec_frame_idx = STACK_TV(ectx->ec_frame_idx\n\t\t\t\t       + STACK_FRAME_IDX_OFF)->vval.v_number;\n\n    if (floc == NULL)\n\tectx->ec_funclocal.floc_restore_cmdmod = FALSE;\n    else\n    {\n\tectx->ec_funclocal = *floc;\n\tvim_free(floc);\n    }\n\n    if (ret_idx > 0)\n    {\n\t// Reset the stack to the position before the call, with a spot for the\n\t// return value, moved there from above the frame.\n\tectx->ec_stack.ga_len = top + 1;\n\t*STACK_TV_BOT(-1) = *STACK_TV(ret_idx);\n    }\n    else\n\t// Reset the stack to the position before the call.\n\tectx->ec_stack.ga_len = top;\n\n    funcdepth_decrement();\n    --ex_nesting_level;\n    return OK;\n}\n\n#undef STACK_TV\n\n/*\n * Prepare arguments and rettv for calling a builtin or user function.\n */\n    static int\ncall_prepare(int argcount, typval_T *argvars, ectx_T *ectx)\n{\n    int\t\tidx;\n    typval_T\t*tv;\n\n    // Move arguments from bottom of the stack to argvars[] and add terminator.\n    for (idx = 0; idx < argcount; ++idx)\n\targvars[idx] = *STACK_TV_BOT(idx - argcount);\n    argvars[argcount].v_type = VAR_UNKNOWN;\n\n    // Result replaces the arguments on the stack.\n    if (argcount > 0)\n\tectx->ec_stack.ga_len -= argcount - 1;\n    else if (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\treturn FAIL;\n    else\n\t++ectx->ec_stack.ga_len;\n\n    // Default return value is zero.\n    tv = STACK_TV_BOT(-1);\n    tv->v_type = VAR_NUMBER;\n    tv->vval.v_number = 0;\n\n    return OK;\n}\n\n// Ugly global to avoid passing the execution context around through many\n// layers.\nstatic ectx_T *current_ectx = NULL;\n\n/*\n * Call a builtin function by index.\n */\n    static int\ncall_bfunc(int func_idx, int argcount, ectx_T *ectx)\n{\n    typval_T\targvars[MAX_FUNC_ARGS];\n    int\t\tidx;\n    int\t\tdid_emsg_before = did_emsg;\n    ectx_T\t*prev_ectx = current_ectx;\n    char\t*save_func_name = ectx->ec_where.wt_func_name;\n\n    if (call_prepare(argcount, argvars, ectx) == FAIL)\n\treturn FAIL;\n    ectx->ec_where.wt_func_name = internal_func_name(func_idx);\n\n    // Call the builtin function.  Set \"current_ectx\" so that when it\n    // recursively invokes call_def_function() a closure context can be set.\n    current_ectx = ectx;\n    call_internal_func_by_idx(func_idx, argvars, STACK_TV_BOT(-1));\n    current_ectx = prev_ectx;\n    ectx->ec_where.wt_func_name = save_func_name;\n\n    // Clear the arguments.\n    for (idx = 0; idx < argcount; ++idx)\n\tclear_tv(&argvars[idx]);\n\n    if (did_emsg > did_emsg_before)\n\treturn FAIL;\n    return OK;\n}\n\n/*\n * Execute a user defined function.\n * If the function is compiled this will add a stack frame and set the\n * instruction pointer at the start of the function.\n * Otherwise the function is called here.\n * If \"pt\" is not null use \"pt->pt_outer\" for ec_outer_ref->or_outer.\n * \"iptr\" can be used to replace the instruction with a more efficient one.\n */\n    static int\ncall_ufunc(\n\tufunc_T\t    *ufunc,\n\tpartial_T   *pt,\n\tint\t    argcount,\n\tectx_T\t    *ectx,\n\tisn_T\t    *iptr,\n\tdict_T\t    *selfdict)\n{\n    typval_T\targvars[MAX_FUNC_ARGS];\n    funcexe_T   funcexe;\n    int\t\terror;\n    int\t\tidx;\n    int\t\tdid_emsg_before = did_emsg;\n    compiletype_T compile_type = COMPILE_TYPE(ufunc);\n\n    if (func_needs_compiling(ufunc, compile_type)\n\t\t&& compile_def_function(ufunc, FALSE, compile_type, NULL)\n\t\t\t\t\t\t\t\t       == FAIL)\n\treturn FAIL;\n    if (ufunc->uf_def_status == UF_COMPILED)\n    {\n\terror = check_user_func_argcount(ufunc, argcount);\n\tif (error != FCERR_UNKNOWN)\n\t{\n\t    if (error == FCERR_TOOMANY)\n\t\tsemsg(_(e_too_many_arguments_for_function_str), ufunc->uf_name);\n\t    else\n\t\tsemsg(_(e_not_enough_arguments_for_function_str),\n\t\t\t\t\t\t\t       ufunc->uf_name);\n\t    return FAIL;\n\t}\n\n\t// The function has been compiled, can call it quickly.  For a function\n\t// that was defined later: we can call it directly next time.\n\tif (iptr != NULL)\n\t{\n\t    delete_instr(iptr);\n\t    iptr->isn_type = ISN_DCALL;\n\t    iptr->isn_arg.dfunc.cdf_idx = ufunc->uf_dfunc_idx;\n\t    iptr->isn_arg.dfunc.cdf_argcount = argcount;\n\t}\n\treturn call_dfunc(ufunc->uf_dfunc_idx, pt, argcount, ectx);\n    }\n\n    if (call_prepare(argcount, argvars, ectx) == FAIL)\n\treturn FAIL;\n    CLEAR_FIELD(funcexe);\n    funcexe.fe_evaluate = TRUE;\n    funcexe.fe_selfdict = selfdict != NULL ? selfdict : dict_stack_get_dict();\n\n    // Call the user function.  Result goes in last position on the stack.\n    error = call_user_func_check(ufunc, argcount, argvars,\n\t\t\t      STACK_TV_BOT(-1), &funcexe, funcexe.fe_selfdict);\n\n    // Clear the arguments.\n    for (idx = 0; idx < argcount; ++idx)\n\tclear_tv(&argvars[idx]);\n\n    if (error != FCERR_NONE)\n    {\n\tuser_func_error(error, ufunc->uf_name, &funcexe);\n\treturn FAIL;\n    }\n    if (did_emsg > did_emsg_before)\n\t// Error other than from calling the function itself.\n\treturn FAIL;\n    return OK;\n}\n\n/*\n * If command modifiers were applied restore them.\n */\n    static void\nmay_restore_cmdmod(funclocal_T *funclocal)\n{\n    if (funclocal->floc_restore_cmdmod)\n    {\n\tcmdmod.cmod_filter_regmatch.regprog = NULL;\n\tundo_cmdmod(&cmdmod);\n\tcmdmod = funclocal->floc_save_cmdmod;\n\tfunclocal->floc_restore_cmdmod = FALSE;\n    }\n}\n\n/*\n * Return TRUE if an error was given (not caught in try/catch) or CTRL-C was\n * pressed.\n */\n    static int\nvim9_aborting(int prev_uncaught_emsg)\n{\n    return uncaught_emsg > prev_uncaught_emsg || got_int || did_throw;\n}\n\n/*\n * Execute a function by \"name\".\n * This can be a builtin function or a user function.\n * \"iptr\" can be used to replace the instruction with a more efficient one.\n * Returns FAIL if not found without an error message.\n */\n    static int\ncall_by_name(\n\tchar_u\t    *name,\n\tint\t    argcount,\n\tectx_T\t    *ectx,\n\tisn_T\t    *iptr,\n\tdict_T\t    *selfdict)\n{\n    ufunc_T *ufunc;\n\n    if (builtin_function(name, -1))\n    {\n\tint func_idx = find_internal_func(name);\n\n\tif (func_idx < 0)\n\t    return FAIL;\n\tif (check_internal_func(func_idx, argcount) < 0)\n\t    return FAIL;\n\treturn call_bfunc(func_idx, argcount, ectx);\n    }\n\n    ufunc = find_func(name, FALSE, NULL);\n\n    if (ufunc == NULL)\n    {\n\tint prev_uncaught_emsg = uncaught_emsg;\n\n\tif (script_autoload(name, TRUE))\n\t    // loaded a package, search for the function again\n\t    ufunc = find_func(name, FALSE, NULL);\n\n\tif (vim9_aborting(prev_uncaught_emsg))\n\t    return FAIL;  // bail out if loading the script caused an error\n    }\n\n    if (ufunc != NULL)\n    {\n\tif (ufunc->uf_arg_types != NULL || ufunc->uf_va_type != NULL)\n\t{\n\t    int i;\n\t    typval_T\t*argv = STACK_TV_BOT(0) - argcount;\n\n\t    // The function can change at runtime, check that the argument\n\t    // types are correct.\n\t    for (i = 0; i < argcount; ++i)\n\t    {\n\t\ttype_T *type = NULL;\n\n\t\tif (i < ufunc->uf_args.ga_len && ufunc->uf_arg_types != NULL)\n\t\t    type = ufunc->uf_arg_types[i];\n\t\telse if (ufunc->uf_va_type != NULL)\n\t\t    type = ufunc->uf_va_type->tt_member;\n\t\tif (type != NULL && check_typval_arg_type(type,\n\t\t\t\t\t\t&argv[i], NULL, i + 1) == FAIL)\n\t\t    return FAIL;\n\t    }\n\t}\n\n\treturn call_ufunc(ufunc, NULL, argcount, ectx, iptr, selfdict);\n    }\n\n    return FAIL;\n}\n\n    static int\ncall_partial(\n\ttypval_T    *tv,\n\tint\t    argcount_arg,\n\tectx_T\t    *ectx)\n{\n    int\t\targcount = argcount_arg;\n    char_u\t*name = NULL;\n    int\t\tcalled_emsg_before = called_emsg;\n    int\t\tres = FAIL;\n    dict_T\t*selfdict = NULL;\n\n    if (tv->v_type == VAR_PARTIAL)\n    {\n\tpartial_T   *pt = tv->vval.v_partial;\n\tint\t    i;\n\n\tif (pt->pt_argc > 0)\n\t{\n\t    // Make space for arguments from the partial, shift the \"argcount\"\n\t    // arguments up.\n\t    if (GA_GROW_FAILS(&ectx->ec_stack, pt->pt_argc))\n\t\treturn FAIL;\n\t    for (i = 1; i <= argcount; ++i)\n\t\t*STACK_TV_BOT(-i + pt->pt_argc) = *STACK_TV_BOT(-i);\n\t    ectx->ec_stack.ga_len += pt->pt_argc;\n\t    argcount += pt->pt_argc;\n\n\t    // copy the arguments from the partial onto the stack\n\t    for (i = 0; i < pt->pt_argc; ++i)\n\t\tcopy_tv(&pt->pt_argv[i], STACK_TV_BOT(-argcount + i));\n\t}\n\tselfdict = pt->pt_dict;\n\n\tif (pt->pt_func != NULL)\n\t    return call_ufunc(pt->pt_func, pt, argcount, ectx, NULL, selfdict);\n\n\tname = pt->pt_name;\n    }\n    else if (tv->v_type == VAR_FUNC)\n\tname = tv->vval.v_string;\n    if (name != NULL)\n    {\n\tchar_u\tfname_buf[FLEN_FIXED + 1];\n\tchar_u\t*tofree = NULL;\n\tint\terror = FCERR_NONE;\n\tchar_u\t*fname;\n\n\t// May need to translate <SNR>123_ to K_SNR.\n\tfname = fname_trans_sid(name, fname_buf, &tofree, &error);\n\tif (error != FCERR_NONE)\n\t    res = FAIL;\n\telse\n\t    res = call_by_name(fname, argcount, ectx, NULL, selfdict);\n\tvim_free(tofree);\n    }\n\n    if (res == FAIL)\n    {\n\tif (called_emsg == called_emsg_before)\n\t    semsg(_(e_unknown_function_str),\n\t\t\t\t  name == NULL ? (char_u *)\"[unknown]\" : name);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Check if \"lock\" is VAR_LOCKED or VAR_FIXED.  If so give an error and return\n * TRUE.\n */\n    static int\nerror_if_locked(int lock, char *error)\n{\n    if (lock & (VAR_LOCKED | VAR_FIXED))\n    {\n\temsg(_(error));\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Give an error if \"tv\" is not a number and return FAIL.\n */\n    static int\ncheck_for_number(typval_T *tv)\n{\n    if (tv->v_type != VAR_NUMBER)\n    {\n\tsemsg(_(e_expected_str_but_got_str),\n\t\tvartype_name(VAR_NUMBER), vartype_name(tv->v_type));\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Store \"tv\" in variable \"name\".\n * This is for s: and g: variables.\n */\n    static void\nstore_var(char_u *name, typval_T *tv)\n{\n    funccal_entry_T entry;\n    int\t\t    flags = ASSIGN_DECL;\n\n    if (tv->v_lock)\n\tflags |= ASSIGN_CONST;\n    save_funccal(&entry);\n    set_var_const(name, NULL, tv, FALSE, flags, 0);\n    restore_funccal();\n}\n\n/*\n * Convert \"tv\" to a string.\n * Return FAIL if not allowed.\n */\n    static int\ndo_2string(typval_T *tv, int is_2string_any, int tolerant)\n{\n    if (tv->v_type != VAR_STRING)\n    {\n\tchar_u *str;\n\n\tif (is_2string_any)\n\t{\n\t    switch (tv->v_type)\n\t    {\n\t\tcase VAR_SPECIAL:\n\t\tcase VAR_BOOL:\n\t\tcase VAR_NUMBER:\n\t\tcase VAR_FLOAT:\n\t\tcase VAR_BLOB:\tbreak;\n\n\t\tcase VAR_LIST:\n\t\t\t\tif (tolerant)\n\t\t\t\t{\n\t\t\t\t    char_u\t*s, *e, *p;\n\t\t\t\t    garray_T\tga;\n\n\t\t\t\t    ga_init2(&ga, sizeof(char_u *), 1);\n\n\t\t\t\t    // Convert to NL separated items, then\n\t\t\t\t    // escape the items and replace the NL with\n\t\t\t\t    // a space.\n\t\t\t\t    str = typval2string(tv, TRUE);\n\t\t\t\t    if (str == NULL)\n\t\t\t\t\treturn FAIL;\n\t\t\t\t    s = str;\n\t\t\t\t    while ((e = vim_strchr(s, '\\n')) != NULL)\n\t\t\t\t    {\n\t\t\t\t\t*e = NUL;\n\t\t\t\t\tp = vim_strsave_fnameescape(s,\n\t\t\t\t\t\t\t\t     VSE_NONE);\n\t\t\t\t\tif (p != NULL)\n\t\t\t\t\t{\n\t\t\t\t\t    ga_concat(&ga, p);\n\t\t\t\t\t    ga_concat(&ga, (char_u *)\" \");\n\t\t\t\t\t    vim_free(p);\n\t\t\t\t\t}\n\t\t\t\t\ts = e + 1;\n\t\t\t\t    }\n\t\t\t\t    vim_free(str);\n\t\t\t\t    clear_tv(tv);\n\t\t\t\t    tv->v_type = VAR_STRING;\n\t\t\t\t    tv->vval.v_string = ga.ga_data;\n\t\t\t\t    return OK;\n\t\t\t\t}\n\t\t\t\t// FALLTHROUGH\n\t\tdefault:\tto_string_error(tv->v_type);\n\t\t\t\treturn FAIL;\n\t    }\n\t}\n\tstr = typval_tostring(tv, TRUE);\n\tclear_tv(tv);\n\ttv->v_type = VAR_STRING;\n\ttv->vval.v_string = str;\n    }\n    return OK;\n}\n\n/*\n * When the value of \"sv\" is a null list of dict, allocate it.\n */\n    static void\nallocate_if_null(typval_T *tv)\n{\n    switch (tv->v_type)\n    {\n\tcase VAR_LIST:\n\t    if (tv->vval.v_list == NULL)\n\t\t(void)rettv_list_alloc(tv);\n\t    break;\n\tcase VAR_DICT:\n\t    if (tv->vval.v_dict == NULL)\n\t\t(void)rettv_dict_alloc(tv);\n\t    break;\n\tcase VAR_BLOB:\n\t    if (tv->vval.v_blob == NULL)\n\t\t(void)rettv_blob_alloc(tv);\n\t    break;\n\tdefault:\n\t    break;\n    }\n}\n\n/*\n * Return the character \"str[index]\" where \"index\" is the character index,\n * including composing characters.\n * If \"index\" is out of range NULL is returned.\n */\n    char_u *\nchar_from_string(char_u *str, varnumber_T index)\n{\n    size_t\t    nbyte = 0;\n    varnumber_T\t    nchar = index;\n    size_t\t    slen;\n\n    if (str == NULL)\n\treturn NULL;\n    slen = STRLEN(str);\n\n    // Do the same as for a list: a negative index counts from the end.\n    // Optimization to check the first byte to be below 0x80 (and no composing\n    // character follows) makes this a lot faster.\n    if (index < 0)\n    {\n\tint\tclen = 0;\n\n\tfor (nbyte = 0; nbyte < slen; ++clen)\n\t{\n\t    if (str[nbyte] < 0x80 && str[nbyte + 1] < 0x80)\n\t\t++nbyte;\n\t    else if (enc_utf8)\n\t\tnbyte += utfc_ptr2len(str + nbyte);\n\t    else\n\t\tnbyte += mb_ptr2len(str + nbyte);\n\t}\n\tnchar = clen + index;\n\tif (nchar < 0)\n\t    // unlike list: index out of range results in empty string\n\t    return NULL;\n    }\n\n    for (nbyte = 0; nchar > 0 && nbyte < slen; --nchar)\n    {\n\tif (str[nbyte] < 0x80 && str[nbyte + 1] < 0x80)\n\t    ++nbyte;\n\telse if (enc_utf8)\n\t    nbyte += utfc_ptr2len(str + nbyte);\n\telse\n\t    nbyte += mb_ptr2len(str + nbyte);\n    }\n    if (nbyte >= slen)\n\treturn NULL;\n    return vim_strnsave(str + nbyte, mb_ptr2len(str + nbyte));\n}\n\n/*\n * Get the byte index for character index \"idx\" in string \"str\" with length\n * \"str_len\".  Composing characters are included.\n * If going over the end return \"str_len\".\n * If \"idx\" is negative count from the end, -1 is the last character.\n * When going over the start return -1.\n */\n    static long\nchar_idx2byte(char_u *str, size_t str_len, varnumber_T idx)\n{\n    varnumber_T nchar = idx;\n    size_t\tnbyte = 0;\n\n    if (nchar >= 0)\n    {\n\twhile (nchar > 0 && nbyte < str_len)\n\t{\n\t    nbyte += mb_ptr2len(str + nbyte);\n\t    --nchar;\n\t}\n    }\n    else\n    {\n\tnbyte = str_len;\n\twhile (nchar < 0 && nbyte > 0)\n\t{\n\t    --nbyte;\n\t    nbyte -= mb_head_off(str, str + nbyte);\n\t    ++nchar;\n\t}\n\tif (nchar < 0)\n\t    return -1;\n    }\n    return (long)nbyte;\n}\n\n/*\n * Return the slice \"str[first : last]\" using character indexes.  Composing\n * characters are included.\n * \"exclusive\" is TRUE for slice().\n * Return NULL when the result is empty.\n */\n    char_u *\nstring_slice(char_u *str, varnumber_T first, varnumber_T last, int exclusive)\n{\n    long\tstart_byte, end_byte;\n    size_t\tslen;\n\n    if (str == NULL)\n\treturn NULL;\n    slen = STRLEN(str);\n    start_byte = char_idx2byte(str, slen, first);\n    if (start_byte < 0)\n\tstart_byte = 0; // first index very negative: use zero\n    if ((last == -1 && !exclusive) || last == VARNUM_MAX)\n\tend_byte = (long)slen;\n    else\n    {\n\tend_byte = char_idx2byte(str, slen, last);\n\tif (!exclusive && end_byte >= 0 && end_byte < (long)slen)\n\t    // end index is inclusive\n\t    end_byte += mb_ptr2len(str + end_byte);\n    }\n\n    if (start_byte >= (long)slen || end_byte <= start_byte)\n\treturn NULL;\n    return vim_strnsave(str + start_byte, end_byte - start_byte);\n}\n\n/*\n * Get a script variable for ISN_STORESCRIPT and ISN_LOADSCRIPT.\n * When \"dfunc_idx\" is negative don't give an error.\n * Returns NULL for an error.\n */\n    static svar_T *\nget_script_svar(scriptref_T *sref, int dfunc_idx)\n{\n    scriptitem_T    *si = SCRIPT_ITEM(sref->sref_sid);\n    dfunc_T\t    *dfunc = dfunc_idx < 0 ? NULL\n\t\t\t      : ((dfunc_T *)def_functions.ga_data) + dfunc_idx;\n    svar_T\t    *sv;\n\n    if (sref->sref_seq != si->sn_script_seq)\n    {\n\t// The script was reloaded after the function was compiled, the\n\t// script_idx may not be valid.\n\tif (dfunc != NULL)\n\t    semsg(_(e_script_variable_invalid_after_reload_in_function_str),\n\t\t\t\t\t printable_func_name(dfunc->df_ufunc));\n\treturn NULL;\n    }\n    sv = ((svar_T *)si->sn_var_vals.ga_data) + sref->sref_idx;\n    if (!equal_type(sv->sv_type, sref->sref_type, 0))\n    {\n\tif (dfunc != NULL)\n\t    emsg(_(e_script_variable_type_changed));\n\treturn NULL;\n    }\n    return sv;\n}\n\n/*\n * Function passed to do_cmdline() for splitting a script joined by NL\n * characters.\n */\n    static char_u *\nget_split_sourceline(\n\tint c UNUSED,\n\tvoid *cookie,\n\tint indent UNUSED,\n\tgetline_opt_T options UNUSED)\n{\n    source_cookie_T\t*sp = (source_cookie_T *)cookie;\n    char_u\t\t*p;\n    char_u\t\t*line;\n\n    if (*sp->nextline == NUL)\n\treturn NULL;\n    p = vim_strchr(sp->nextline, '\\n');\n    if (p == NULL)\n    {\n\tline = vim_strsave(sp->nextline);\n\tsp->nextline += STRLEN(sp->nextline);\n    }\n    else\n    {\n\tline = vim_strnsave(sp->nextline, p - sp->nextline);\n\tsp->nextline = p + 1;\n    }\n    return line;\n}\n\n/*\n * Execute a function by \"name\".\n * This can be a builtin function, user function or a funcref.\n * \"iptr\" can be used to replace the instruction with a more efficient one.\n */\n    static int\ncall_eval_func(\n\tchar_u\t    *name,\n\tint\t    argcount,\n\tectx_T\t    *ectx,\n\tisn_T\t    *iptr)\n{\n    int\t    called_emsg_before = called_emsg;\n    int\t    res;\n\n    res = call_by_name(name, argcount, ectx, iptr, NULL);\n    if (res == FAIL && called_emsg == called_emsg_before)\n    {\n\tdictitem_T\t*v;\n\n\tv = find_var(name, NULL, FALSE);\n\tif (v == NULL)\n\t{\n\t    semsg(_(e_unknown_function_str), name);\n\t    return FAIL;\n\t}\n\tif (v->di_tv.v_type != VAR_PARTIAL && v->di_tv.v_type != VAR_FUNC)\n\t{\n\t    semsg(_(e_unknown_function_str), name);\n\t    return FAIL;\n\t}\n\treturn call_partial(&v->di_tv, argcount, ectx);\n    }\n    return res;\n}\n\n/*\n * When a function reference is used, fill a partial with the information\n * needed, especially when it is used as a closure.\n */\n    int\nfill_partial_and_closure(partial_T *pt, ufunc_T *ufunc, ectx_T *ectx)\n{\n    pt->pt_func = ufunc;\n    pt->pt_refcount = 1;\n\n    if (ufunc->uf_flags & FC_CLOSURE)\n    {\n\tdfunc_T\t*dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t  + ectx->ec_dfunc_idx;\n\n\t// The closure may need to find arguments and local variables in the\n\t// current stack.\n\tpt->pt_outer.out_stack = &ectx->ec_stack;\n\tpt->pt_outer.out_frame_idx = ectx->ec_frame_idx;\n\tif (ectx->ec_outer_ref != NULL)\n\t{\n\t    // The current context already has a context, link to that one.\n\t    pt->pt_outer.out_up = ectx->ec_outer_ref->or_outer;\n\t    if (ectx->ec_outer_ref->or_partial != NULL)\n\t    {\n\t\tpt->pt_outer.out_up_partial = ectx->ec_outer_ref->or_partial;\n\t\t++pt->pt_outer.out_up_partial->pt_refcount;\n\t    }\n\t}\n\n\t// If this function returns and the closure is still being used, we\n\t// need to make a copy of the context (arguments and local variables).\n\t// Store a reference to the partial so we can handle that.\n\tif (GA_GROW_FAILS(&ectx->ec_funcrefs, 1))\n\t{\n\t    vim_free(pt);\n\t    return FAIL;\n\t}\n\t// Extra variable keeps the count of closures created in the current\n\t// function call.\n\t++(((typval_T *)ectx->ec_stack.ga_data) + ectx->ec_frame_idx\n\t\t       + STACK_FRAME_SIZE + dfunc->df_varcount)->vval.v_number;\n\n\t((partial_T **)ectx->ec_funcrefs.ga_data)\n\t\t\t       [ectx->ec_funcrefs.ga_len] = pt;\n\t++pt->pt_refcount;\n\t++ectx->ec_funcrefs.ga_len;\n    }\n    ++ufunc->uf_refcount;\n    return OK;\n}\n\n/*\n * Execute iptr->isn_arg.string as an Ex command.\n */\n    static int\nexec_command(isn_T *iptr)\n{\n    source_cookie_T cookie;\n\n    SOURCING_LNUM = iptr->isn_lnum;\n    // Pass getsourceline to get an error for a missing \":end\"\n    // command.\n    CLEAR_FIELD(cookie);\n    cookie.sourcing_lnum = iptr->isn_lnum - 1;\n    if (do_cmdline(iptr->isn_arg.string,\n\t\tgetsourceline, &cookie,\n\t\t\t     DOCMD_VERBOSE|DOCMD_NOWAIT|DOCMD_KEYTYPED) == FAIL\n\t\t|| did_emsg)\n\treturn FAIL;\n    return OK;\n}\n\n// used for v_instr of typval of VAR_INSTR\nstruct instr_S {\n    ectx_T\t*instr_ectx;\n    isn_T\t*instr_instr;\n};\n\n// used for substitute_instr\ntypedef struct subs_expr_S {\n    ectx_T\t*subs_ectx;\n    isn_T\t*subs_instr;\n    int\t\tsubs_status;\n} subs_expr_T;\n\n// Get pointer to item in the stack.\n#define STACK_TV(idx) (((typval_T *)ectx->ec_stack.ga_data) + idx)\n\n// Get pointer to item at the bottom of the stack, -1 is the bottom.\n#undef STACK_TV_BOT\n#define STACK_TV_BOT(idx) (((typval_T *)ectx->ec_stack.ga_data) + ectx->ec_stack.ga_len + idx)\n\n// Get pointer to a local variable on the stack.  Negative for arguments.\n#define STACK_TV_VAR(idx) (((typval_T *)ectx->ec_stack.ga_data) + ectx->ec_frame_idx + STACK_FRAME_SIZE + idx)\n\n// Set when calling do_debug().\nstatic ectx_T\t*debug_context = NULL;\nstatic int\tdebug_var_count;\n\n/*\n * When debugging lookup \"name\" and return the typeval.\n * When not found return NULL.\n */\n    typval_T *\nlookup_debug_var(char_u *name)\n{\n    int\t\t    idx;\n    dfunc_T\t    *dfunc;\n    ufunc_T\t    *ufunc;\n    ectx_T\t    *ectx = debug_context;\n    int\t\t    varargs_off;\n\n    if (ectx == NULL)\n\treturn NULL;\n    dfunc = ((dfunc_T *)def_functions.ga_data) + ectx->ec_dfunc_idx;\n\n    // Go through the local variable names, from last to first.\n    for (idx = debug_var_count - 1; idx >= 0; --idx)\n    {\n\tif (STRCMP(((char_u **)dfunc->df_var_names.ga_data)[idx], name) == 0)\n\t    return STACK_TV_VAR(idx);\n    }\n\n    // Go through argument names.\n    ufunc = dfunc->df_ufunc;\n    varargs_off = ufunc->uf_va_name == NULL ? 0 : 1;\n    for (idx = 0; idx < ufunc->uf_args.ga_len; ++idx)\n\tif (STRCMP(((char_u **)(ufunc->uf_args.ga_data))[idx], name) == 0)\n\t    return STACK_TV(ectx->ec_frame_idx - ufunc->uf_args.ga_len\n\t\t\t\t\t\t\t  - varargs_off + idx);\n    if (ufunc->uf_va_name != NULL && STRCMP(ufunc->uf_va_name, name) == 0)\n\treturn STACK_TV(ectx->ec_frame_idx - 1);\n\n    return NULL;\n}\n\n/*\n * Return TRUE if there might be a breakpoint in \"ufunc\", which is when a\n * breakpoint was set in that function or when there is any expression.\n */\n    int\nmay_break_in_function(ufunc_T *ufunc)\n{\n    return ufunc->uf_has_breakpoint || debug_has_expr_breakpoint();\n}\n\n    static void\nhandle_debug(isn_T *iptr, ectx_T *ectx)\n{\n    char_u\t*line;\n    ufunc_T\t*ufunc = (((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t       + ectx->ec_dfunc_idx)->df_ufunc;\n    isn_T\t*ni;\n    int\t\tend_lnum = iptr->isn_lnum;\n    garray_T\tga;\n    int\t\tlnum;\n\n    if (ex_nesting_level > debug_break_level)\n    {\n\tlinenr_T breakpoint;\n\n\tif (!may_break_in_function(ufunc))\n\t    return;\n\n\t// check for the next breakpoint if needed\n\tbreakpoint = dbg_find_breakpoint(FALSE, ufunc->uf_name,\n\t\t\t\t\t   iptr->isn_arg.debug.dbg_break_lnum);\n\tif (breakpoint <= 0 || breakpoint > iptr->isn_lnum)\n\t    return;\n    }\n\n    SOURCING_LNUM = iptr->isn_lnum;\n    debug_context = ectx;\n    debug_var_count = iptr->isn_arg.debug.dbg_var_names_len;\n\n    for (ni = iptr + 1; ni->isn_type != ISN_FINISH; ++ni)\n\tif (ni->isn_type == ISN_DEBUG\n\t\t  || ni->isn_type == ISN_RETURN\n\t\t  || ni->isn_type == ISN_RETURN_VOID)\n\t{\n\t    end_lnum = ni->isn_lnum + (ni->isn_type == ISN_DEBUG ? 0 : 1);\n\t    break;\n\t}\n\n    if (end_lnum > iptr->isn_lnum)\n    {\n\tga_init2(&ga, sizeof(char_u *), 10);\n\tfor (lnum = iptr->isn_lnum; lnum < end_lnum\n\t\t\t\t     && lnum <= ufunc->uf_lines.ga_len; ++lnum)\n\t{\n\t    char_u *p = ((char_u **)ufunc->uf_lines.ga_data)[lnum - 1];\n\n\t    if (p == NULL)\n\t\tcontinue;  // left over from continuation line\n\t    p = skipwhite(p);\n\t    if (*p == '#')\n\t\tbreak;\n\t    if (GA_GROW_OK(&ga, 1))\n\t\t((char_u **)(ga.ga_data))[ga.ga_len++] = p;\n\t    if (STRNCMP(p, \"def \", 4) == 0)\n\t\tbreak;\n\t}\n\tline = ga_concat_strings(&ga, \"  \");\n\tvim_free(ga.ga_data);\n    }\n    else\n\tline = ((char_u **)ufunc->uf_lines.ga_data)[iptr->isn_lnum - 1];\n\n    do_debug(line == NULL ? (char_u *)\"[empty]\" : line);\n    debug_context = NULL;\n\n    if (end_lnum > iptr->isn_lnum)\n\tvim_free(line);\n}\n\n/*\n * Execute instructions in execution context \"ectx\".\n * Return OK or FAIL;\n */\n    static int\nexec_instructions(ectx_T *ectx)\n{\n    int\t\tret = FAIL;\n    int\t\tsave_trylevel_at_start = ectx->ec_trylevel_at_start;\n    int\t\tdict_stack_len_at_start = dict_stack.ga_len;\n\n    // Start execution at the first instruction.\n    ectx->ec_iidx = 0;\n\n    // Only catch exceptions in this instruction list.\n    ectx->ec_trylevel_at_start = trylevel;\n\n    for (;;)\n    {\n\tstatic int  breakcheck_count = 0;  // using \"static\" makes it faster\n\tisn_T\t    *iptr;\n\ttypval_T    *tv;\n\n\tif (unlikely(++breakcheck_count >= 100))\n\t{\n\t    line_breakcheck();\n\t    breakcheck_count = 0;\n\t}\n\tif (unlikely(got_int))\n\t{\n\t    // Turn CTRL-C into an exception.\n\t    got_int = FALSE;\n\t    if (throw_exception(\"Vim:Interrupt\", ET_INTERRUPT, NULL) == FAIL)\n\t\tgoto theend;\n\t    did_throw = TRUE;\n\t}\n\n\tif (unlikely(did_emsg && msg_list != NULL && *msg_list != NULL))\n\t{\n\t    // Turn an error message into an exception.\n\t    did_emsg = FALSE;\n\t    if (throw_exception(*msg_list, ET_ERROR, NULL) == FAIL)\n\t\tgoto theend;\n\t    did_throw = TRUE;\n\t    *msg_list = NULL;\n\t}\n\n\tif (unlikely(did_throw))\n\t{\n\t    garray_T\t*trystack = &ectx->ec_trystack;\n\t    trycmd_T    *trycmd = NULL;\n\t    int\t\tindex = trystack->ga_len;\n\n\t    // An exception jumps to the first catch, finally, or returns from\n\t    // the current function.\n\t    while (index > 0)\n\t    {\n\t\ttrycmd = ((trycmd_T *)trystack->ga_data) + index - 1;\n\t\tif (!trycmd->tcd_in_catch || trycmd->tcd_finally_idx != 0)\n\t\t    break;\n\t\t// In the catch and finally block of this try we have to go up\n\t\t// one level.\n\t\t--index;\n\t\ttrycmd = NULL;\n\t    }\n\t    if (trycmd != NULL && trycmd->tcd_frame_idx == ectx->ec_frame_idx)\n\t    {\n\t\tif (trycmd->tcd_in_catch)\n\t\t{\n\t\t    // exception inside \":catch\", jump to \":finally\" once\n\t\t    ectx->ec_iidx = trycmd->tcd_finally_idx;\n\t\t    trycmd->tcd_finally_idx = 0;\n\t\t}\n\t\telse\n\t\t    // jump to first \":catch\"\n\t\t    ectx->ec_iidx = trycmd->tcd_catch_idx;\n\t\ttrycmd->tcd_in_catch = TRUE;\n\t\tdid_throw = FALSE;  // don't come back here until :endtry\n\t\ttrycmd->tcd_did_throw = TRUE;\n\t    }\n\t    else\n\t    {\n\t\t// Not inside try or need to return from current functions.\n\t\t// Push a dummy return value.\n\t\tif (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t    goto theend;\n\t\ttv = STACK_TV_BOT(0);\n\t\ttv->v_type = VAR_NUMBER;\n\t\ttv->vval.v_number = 0;\n\t\t++ectx->ec_stack.ga_len;\n\t\tif (ectx->ec_frame_idx == ectx->ec_initial_frame_idx)\n\t\t{\n\t\t    // At the toplevel we are done.\n\t\t    need_rethrow = TRUE;\n\t\t    if (handle_closure_in_use(ectx, FALSE) == FAIL)\n\t\t\tgoto theend;\n\t\t    goto done;\n\t\t}\n\n\t\tif (func_return(ectx) == FAIL)\n\t\t    goto theend;\n\t    }\n\t    continue;\n\t}\n\n\tiptr = &ectx->ec_instr[ectx->ec_iidx++];\n\tswitch (iptr->isn_type)\n\t{\n\t    // execute Ex command line\n\t    case ISN_EXEC:\n\t\tif (exec_command(iptr) == FAIL)\n\t\t    goto on_error;\n\t\tbreak;\n\n\t    // execute Ex command line split at NL characters.\n\t    case ISN_EXEC_SPLIT:\n\t\t{\n\t\t    source_cookie_T cookie;\n\t\t    char_u\t    *line;\n\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    CLEAR_FIELD(cookie);\n\t\t    cookie.sourcing_lnum = iptr->isn_lnum - 1;\n\t\t    cookie.nextline = iptr->isn_arg.string;\n\t\t    line = get_split_sourceline(0, &cookie, 0, 0);\n\t\t    if (do_cmdline(line,\n\t\t\t\tget_split_sourceline, &cookie,\n\t\t\t\t   DOCMD_VERBOSE|DOCMD_NOWAIT|DOCMD_KEYTYPED)\n\t\t\t\t\t\t\t\t\t== FAIL\n\t\t\t\t|| did_emsg)\n\t\t    {\n\t\t\tvim_free(line);\n\t\t\tgoto on_error;\n\t\t    }\n\t\t    vim_free(line);\n\t\t}\n\t\tbreak;\n\n\t    // execute Ex command line that is only a range\n\t    case ISN_EXECRANGE:\n\t\t{\n\t\t    exarg_T\tea;\n\t\t    char\t*error = NULL;\n\n\t\t    CLEAR_FIELD(ea);\n\t\t    ea.cmdidx = CMD_SIZE;\n\t\t    ea.addr_type = ADDR_LINES;\n\t\t    ea.cmd = iptr->isn_arg.string;\n\t\t    parse_cmd_address(&ea, &error, FALSE);\n\t\t    if (ea.cmd == NULL)\n\t\t\tgoto on_error;\n\t\t    if (error == NULL)\n\t\t\terror = ex_range_without_command(&ea);\n\t\t    if (error != NULL)\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\temsg(error);\n\t\t\tgoto on_error;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    // Evaluate an expression with legacy syntax, push it onto the\n\t    // stack.\n\t    case ISN_LEGACY_EVAL:\n\t\t{\n\t\t    char_u  *arg = iptr->isn_arg.string;\n\t\t    int\t    res;\n\t\t    int\t    save_flags = cmdmod.cmod_flags;\n\n\t\t    if (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t\tgoto theend;\n\t\t    tv = STACK_TV_BOT(0);\n\t\t    init_tv(tv);\n\t\t    cmdmod.cmod_flags |= CMOD_LEGACY;\n\t\t    res = eval0(arg, tv, NULL, &EVALARG_EVALUATE);\n\t\t    cmdmod.cmod_flags = save_flags;\n\t\t    if (res == FAIL)\n\t\t\tgoto on_error;\n\t\t    ++ectx->ec_stack.ga_len;\n\t\t}\n\t\tbreak;\n\n\t    // push typeval VAR_INSTR with instructions to be executed\n\t    case ISN_INSTR:\n\t\t{\n\t\t    if (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t\tgoto theend;\n\t\t    tv = STACK_TV_BOT(0);\n\t\t    tv->vval.v_instr = ALLOC_ONE(instr_T);\n\t\t    if (tv->vval.v_instr == NULL)\n\t\t\tgoto on_error;\n\t\t    ++ectx->ec_stack.ga_len;\n\n\t\t    tv->v_type = VAR_INSTR;\n\t\t    tv->vval.v_instr->instr_ectx = ectx;\n\t\t    tv->vval.v_instr->instr_instr = iptr->isn_arg.instr;\n\t\t}\n\t\tbreak;\n\n\t    // execute :substitute with an expression\n\t    case ISN_SUBSTITUTE:\n\t\t{\n\t\t    subs_T\t\t*subs = &iptr->isn_arg.subs;\n\t\t    source_cookie_T\tcookie;\n\t\t    struct subs_expr_S\t*save_instr = substitute_instr;\n\t\t    struct subs_expr_S\tsubs_instr;\n\t\t    int\t\t\tres;\n\n\t\t    subs_instr.subs_ectx = ectx;\n\t\t    subs_instr.subs_instr = subs->subs_instr;\n\t\t    subs_instr.subs_status = OK;\n\t\t    substitute_instr = &subs_instr;\n\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    // This is very much like ISN_EXEC\n\t\t    CLEAR_FIELD(cookie);\n\t\t    cookie.sourcing_lnum = iptr->isn_lnum - 1;\n\t\t    res = do_cmdline(subs->subs_cmd,\n\t\t\t\tgetsourceline, &cookie,\n\t\t\t\t   DOCMD_VERBOSE|DOCMD_NOWAIT|DOCMD_KEYTYPED);\n\t\t    substitute_instr = save_instr;\n\n\t\t    if (res == FAIL || did_emsg\n\t\t\t\t\t     || subs_instr.subs_status == FAIL)\n\t\t\tgoto on_error;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_FINISH:\n\t\tgoto done;\n\n\t    case ISN_REDIRSTART:\n\t\t// create a dummy entry for var_redir_str()\n\t\tif (alloc_redir_lval() == FAIL)\n\t\t    goto on_error;\n\n\t\t// The output is stored in growarray \"redir_ga\" until\n\t\t// redirection ends.\n\t\tinit_redir_ga();\n\t\tredir_vname = 1;\n\t\tbreak;\n\n\t    case ISN_REDIREND:\n\t\t{\n\t\t    char_u *res = get_clear_redir_ga();\n\n\t\t    // End redirection, put redirected text on the stack.\n\t\t    clear_redir_lval();\n\t\t    redir_vname = 0;\n\n\t\t    if (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t    {\n\t\t\tvim_free(res);\n\t\t\tgoto theend;\n\t\t    }\n\t\t    tv = STACK_TV_BOT(0);\n\t\t    tv->v_type = VAR_STRING;\n\t\t    tv->vval.v_string = res;\n\t\t    ++ectx->ec_stack.ga_len;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_CEXPR_AUCMD:\n#ifdef FEAT_QUICKFIX\n\t\tif (trigger_cexpr_autocmd(iptr->isn_arg.number) == FAIL)\n\t\t    goto on_error;\n#endif\n\t\tbreak;\n\n\t    case ISN_CEXPR_CORE:\n#ifdef FEAT_QUICKFIX\n\t\t{\n\t\t    exarg_T ea;\n\t\t    int\t    res;\n\n\t\t    CLEAR_FIELD(ea);\n\t\t    ea.cmdidx = iptr->isn_arg.cexpr.cexpr_ref->cer_cmdidx;\n\t\t    ea.forceit = iptr->isn_arg.cexpr.cexpr_ref->cer_forceit;\n\t\t    ea.cmdlinep = &iptr->isn_arg.cexpr.cexpr_ref->cer_cmdline;\n\t\t    --ectx->ec_stack.ga_len;\n\t\t    tv = STACK_TV_BOT(0);\n\t\t    res = cexpr_core(&ea, tv);\n\t\t    clear_tv(tv);\n\t\t    if (res == FAIL)\n\t\t\tgoto on_error;\n\t\t}\n#endif\n\t\tbreak;\n\n\t    // execute Ex command from pieces on the stack\n\t    case ISN_EXECCONCAT:\n\t\t{\n\t\t    int\t    count = iptr->isn_arg.number;\n\t\t    size_t  len = 0;\n\t\t    int\t    pass;\n\t\t    int\t    i;\n\t\t    char_u  *cmd = NULL;\n\t\t    char_u  *str;\n\n\t\t    for (pass = 1; pass <= 2; ++pass)\n\t\t    {\n\t\t\tfor (i = 0; i < count; ++i)\n\t\t\t{\n\t\t\t    tv = STACK_TV_BOT(i - count);\n\t\t\t    str = tv->vval.v_string;\n\t\t\t    if (str != NULL && *str != NUL)\n\t\t\t    {\n\t\t\t\tif (pass == 2)\n\t\t\t\t    STRCPY(cmd + len, str);\n\t\t\t\tlen += STRLEN(str);\n\t\t\t    }\n\t\t\t    if (pass == 2)\n\t\t\t\tclear_tv(tv);\n\t\t\t}\n\t\t\tif (pass == 1)\n\t\t\t{\n\t\t\t    cmd = alloc(len + 1);\n\t\t\t    if (unlikely(cmd == NULL))\n\t\t\t\tgoto theend;\n\t\t\t    len = 0;\n\t\t\t}\n\t\t    }\n\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    do_cmdline_cmd(cmd);\n\t\t    vim_free(cmd);\n\t\t}\n\t\tbreak;\n\n\t    // execute :echo {string} ...\n\t    case ISN_ECHO:\n\t\t{\n\t\t    int count = iptr->isn_arg.echo.echo_count;\n\t\t    int\tatstart = TRUE;\n\t\t    int needclr = TRUE;\n\t\t    int\tidx;\n\n\t\t    for (idx = 0; idx < count; ++idx)\n\t\t    {\n\t\t\ttv = STACK_TV_BOT(idx - count);\n\t\t\techo_one(tv, iptr->isn_arg.echo.echo_with_white,\n\t\t\t\t\t\t\t   &atstart, &needclr);\n\t\t\tclear_tv(tv);\n\t\t    }\n\t\t    if (needclr)\n\t\t\tmsg_clr_eos();\n\t\t    ectx->ec_stack.ga_len -= count;\n\t\t}\n\t\tbreak;\n\n\t    // :execute {string} ...\n\t    // :echomsg {string} ...\n\t    // :echoconsole {string} ...\n\t    // :echoerr {string} ...\n\t    case ISN_EXECUTE:\n\t    case ISN_ECHOMSG:\n\t    case ISN_ECHOCONSOLE:\n\t    case ISN_ECHOERR:\n\t\t{\n\t\t    int\t\tcount = iptr->isn_arg.number;\n\t\t    garray_T\tga;\n\t\t    char_u\tbuf[NUMBUFLEN];\n\t\t    char_u\t*p;\n\t\t    int\t\tlen;\n\t\t    int\t\tfailed = FALSE;\n\t\t    int\t\tidx;\n\n\t\t    ga_init2(&ga, 1, 80);\n\t\t    for (idx = 0; idx < count; ++idx)\n\t\t    {\n\t\t\ttv = STACK_TV_BOT(idx - count);\n\t\t\tif (iptr->isn_type == ISN_EXECUTE)\n\t\t\t{\n\t\t\t    if (tv->v_type == VAR_CHANNEL\n\t\t\t\t\t\t      || tv->v_type == VAR_JOB)\n\t\t\t    {\n\t\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\t\tsemsg(_(e_using_invalid_value_as_string_str),\n\t\t\t\t\t\t    vartype_name(tv->v_type));\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t    else\n\t\t\t\tp = tv_get_string_buf(tv, buf);\n\t\t\t}\n\t\t\telse\n\t\t\t    p = tv_stringify(tv, buf);\n\n\t\t\tlen = (int)STRLEN(p);\n\t\t\tif (GA_GROW_FAILS(&ga, len + 2))\n\t\t\t    failed = TRUE;\n\t\t\telse\n\t\t\t{\n\t\t\t    if (ga.ga_len > 0)\n\t\t\t\t((char_u *)(ga.ga_data))[ga.ga_len++] = ' ';\n\t\t\t    STRCPY((char_u *)(ga.ga_data) + ga.ga_len, p);\n\t\t\t    ga.ga_len += len;\n\t\t\t}\n\t\t\tclear_tv(tv);\n\t\t    }\n\t\t    ectx->ec_stack.ga_len -= count;\n\t\t    if (failed)\n\t\t    {\n\t\t\tga_clear(&ga);\n\t\t\tgoto on_error;\n\t\t    }\n\n\t\t    if (ga.ga_data != NULL)\n\t\t    {\n\t\t\tif (iptr->isn_type == ISN_EXECUTE)\n\t\t\t{\n\t\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t\t    do_cmdline_cmd((char_u *)ga.ga_data);\n\t\t\t    if (did_emsg)\n\t\t\t    {\n\t\t\t\tga_clear(&ga);\n\t\t\t\tgoto on_error;\n\t\t\t    }\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    msg_sb_eol();\n\t\t\t    if (iptr->isn_type == ISN_ECHOMSG)\n\t\t\t    {\n\t\t\t\tmsg_attr(ga.ga_data, echo_attr);\n\t\t\t\tout_flush();\n\t\t\t    }\n\t\t\t    else if (iptr->isn_type == ISN_ECHOCONSOLE)\n\t\t\t    {\n\t\t\t\tui_write(ga.ga_data, (int)STRLEN(ga.ga_data),\n\t\t\t\t\t\t\t\t\t TRUE);\n\t\t\t\tui_write((char_u *)\"\\r\\n\", 2, TRUE);\n\t\t\t    }\n\t\t\t    else\n\t\t\t    {\n\t\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\t\temsg(ga.ga_data);\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    ga_clear(&ga);\n\t\t}\n\t\tbreak;\n\n\t    // load local variable or argument\n\t    case ISN_LOAD:\n\t\tif (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t    goto theend;\n\t\tcopy_tv(STACK_TV_VAR(iptr->isn_arg.number), STACK_TV_BOT(0));\n\t\t++ectx->ec_stack.ga_len;\n\t\tbreak;\n\n\t    // load v: variable\n\t    case ISN_LOADV:\n\t\tif (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t    goto theend;\n\t\tcopy_tv(get_vim_var_tv(iptr->isn_arg.number), STACK_TV_BOT(0));\n\t\t++ectx->ec_stack.ga_len;\n\t\tbreak;\n\n\t    // load s: variable in Vim9 script\n\t    case ISN_LOADSCRIPT:\n\t\t{\n\t\t    scriptref_T\t*sref = iptr->isn_arg.script.scriptref;\n\t\t    svar_T\t *sv;\n\n\t\t    sv = get_script_svar(sref, ectx->ec_dfunc_idx);\n\t\t    if (sv == NULL)\n\t\t\tgoto theend;\n\t\t    allocate_if_null(sv->sv_tv);\n\t\t    if (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t\tgoto theend;\n\t\t    copy_tv(sv->sv_tv, STACK_TV_BOT(0));\n\t\t    ++ectx->ec_stack.ga_len;\n\t\t}\n\t\tbreak;\n\n\t    // load s: variable in old script\n\t    case ISN_LOADS:\n\t\t{\n\t\t    hashtab_T\t*ht = &SCRIPT_VARS(\n\t\t\t\t\t       iptr->isn_arg.loadstore.ls_sid);\n\t\t    char_u\t*name = iptr->isn_arg.loadstore.ls_name;\n\t\t    dictitem_T\t*di = find_var_in_ht(ht, 0, name, TRUE);\n\n\t\t    if (di == NULL)\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\tsemsg(_(e_undefined_variable_str), name);\n\t\t\tgoto on_error;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t\t    goto theend;\n\t\t\tcopy_tv(&di->di_tv, STACK_TV_BOT(0));\n\t\t\t++ectx->ec_stack.ga_len;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    // load g:/b:/w:/t: variable\n\t    case ISN_LOADG:\n\t    case ISN_LOADB:\n\t    case ISN_LOADW:\n\t    case ISN_LOADT:\n\t\t{\n\t\t    dictitem_T *di = NULL;\n\t\t    hashtab_T *ht = NULL;\n\t\t    char namespace;\n\n\t\t    switch (iptr->isn_type)\n\t\t    {\n\t\t\tcase ISN_LOADG:\n\t\t\t    ht = get_globvar_ht();\n\t\t\t    namespace = 'g';\n\t\t\t    break;\n\t\t\tcase ISN_LOADB:\n\t\t\t    ht = &curbuf->b_vars->dv_hashtab;\n\t\t\t    namespace = 'b';\n\t\t\t    break;\n\t\t\tcase ISN_LOADW:\n\t\t\t    ht = &curwin->w_vars->dv_hashtab;\n\t\t\t    namespace = 'w';\n\t\t\t    break;\n\t\t\tcase ISN_LOADT:\n\t\t\t    ht = &curtab->tp_vars->dv_hashtab;\n\t\t\t    namespace = 't';\n\t\t\t    break;\n\t\t\tdefault:  // Cannot reach here\n\t\t\t    goto theend;\n\t\t    }\n\t\t    di = find_var_in_ht(ht, 0, iptr->isn_arg.string, TRUE);\n\n\t\t    if (di == NULL)\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\tsemsg(_(e_undefined_variable_char_str),\n\t\t\t\t\t     namespace, iptr->isn_arg.string);\n\t\t\tgoto on_error;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t\t    goto theend;\n\t\t\tcopy_tv(&di->di_tv, STACK_TV_BOT(0));\n\t\t\t++ectx->ec_stack.ga_len;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    // load autoload variable\n\t    case ISN_LOADAUTO:\n\t\t{\n\t\t    char_u *name = iptr->isn_arg.string;\n\n\t\t    if (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t\tgoto theend;\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    if (eval_variable(name, (int)STRLEN(name),\n\t\t\t      STACK_TV_BOT(0), NULL, EVAL_VAR_VERBOSE) == FAIL)\n\t\t\tgoto on_error;\n\t\t    ++ectx->ec_stack.ga_len;\n\t\t}\n\t\tbreak;\n\n\t    // load g:/b:/w:/t: namespace\n\t    case ISN_LOADGDICT:\n\t    case ISN_LOADBDICT:\n\t    case ISN_LOADWDICT:\n\t    case ISN_LOADTDICT:\n\t\t{\n\t\t    dict_T *d = NULL;\n\n\t\t    switch (iptr->isn_type)\n\t\t    {\n\t\t\tcase ISN_LOADGDICT: d = get_globvar_dict(); break;\n\t\t\tcase ISN_LOADBDICT: d = curbuf->b_vars; break;\n\t\t\tcase ISN_LOADWDICT: d = curwin->w_vars; break;\n\t\t\tcase ISN_LOADTDICT: d = curtab->tp_vars; break;\n\t\t\tdefault:  // Cannot reach here\n\t\t\t    goto theend;\n\t\t    }\n\t\t    if (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t\tgoto theend;\n\t\t    tv = STACK_TV_BOT(0);\n\t\t    tv->v_type = VAR_DICT;\n\t\t    tv->v_lock = 0;\n\t\t    tv->vval.v_dict = d;\n\t\t    ++d->dv_refcount;\n\t\t    ++ectx->ec_stack.ga_len;\n\t\t}\n\t\tbreak;\n\n\t    // load &option\n\t    case ISN_LOADOPT:\n\t\t{\n\t\t    typval_T\toptval;\n\t\t    char_u\t*name = iptr->isn_arg.string;\n\n\t\t    // This is not expected to fail, name is checked during\n\t\t    // compilation: don't set SOURCING_LNUM.\n\t\t    if (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t\tgoto theend;\n\t\t    if (eval_option(&name, &optval, TRUE) == FAIL)\n\t\t\tgoto theend;\n\t\t    *STACK_TV_BOT(0) = optval;\n\t\t    ++ectx->ec_stack.ga_len;\n\t\t}\n\t\tbreak;\n\n\t    // load $ENV\n\t    case ISN_LOADENV:\n\t\t{\n\t\t    typval_T\toptval;\n\t\t    char_u\t*name = iptr->isn_arg.string;\n\n\t\t    if (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t\tgoto theend;\n\t\t    // name is always valid, checked when compiling\n\t\t    (void)eval_env_var(&name, &optval, TRUE);\n\t\t    *STACK_TV_BOT(0) = optval;\n\t\t    ++ectx->ec_stack.ga_len;\n\t\t}\n\t\tbreak;\n\n\t    // load @register\n\t    case ISN_LOADREG:\n\t\tif (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t    goto theend;\n\t\ttv = STACK_TV_BOT(0);\n\t\ttv->v_type = VAR_STRING;\n\t\ttv->v_lock = 0;\n\t\t// This may result in NULL, which should be equivalent to an\n\t\t// empty string.\n\t\ttv->vval.v_string = get_reg_contents(\n\t\t\t\t\t  iptr->isn_arg.number, GREG_EXPR_SRC);\n\t\t++ectx->ec_stack.ga_len;\n\t\tbreak;\n\n\t    // store local variable\n\t    case ISN_STORE:\n\t\t--ectx->ec_stack.ga_len;\n\t\ttv = STACK_TV_VAR(iptr->isn_arg.number);\n\t\tclear_tv(tv);\n\t\t*tv = *STACK_TV_BOT(0);\n\t\tbreak;\n\n\t    // store s: variable in old script\n\t    case ISN_STORES:\n\t\t{\n\t\t    hashtab_T\t*ht = &SCRIPT_VARS(\n\t\t\t\t\t       iptr->isn_arg.loadstore.ls_sid);\n\t\t    char_u\t*name = iptr->isn_arg.loadstore.ls_name;\n\t\t    dictitem_T\t*di = find_var_in_ht(ht, 0, name + 2, TRUE);\n\n\t\t    --ectx->ec_stack.ga_len;\n\t\t    if (di == NULL)\n\t\t\tstore_var(name, STACK_TV_BOT(0));\n\t\t    else\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\tif (var_check_permission(di, name) == FAIL)\n\t\t\t{\n\t\t\t    clear_tv(STACK_TV_BOT(0));\n\t\t\t    goto on_error;\n\t\t\t}\n\t\t\tclear_tv(&di->di_tv);\n\t\t\tdi->di_tv = *STACK_TV_BOT(0);\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    // store script-local variable in Vim9 script\n\t    case ISN_STORESCRIPT:\n\t\t{\n\t\t    scriptref_T\t    *sref = iptr->isn_arg.script.scriptref;\n\t\t    svar_T\t    *sv;\n\n\t\t    sv = get_script_svar(sref, ectx->ec_dfunc_idx);\n\t\t    if (sv == NULL)\n\t\t\tgoto theend;\n\t\t    --ectx->ec_stack.ga_len;\n\n\t\t    // \"const\" and \"final\" are checked at compile time, locking\n\t\t    // the value needs to be checked here.\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    if (value_check_lock(sv->sv_tv->v_lock, sv->sv_name, FALSE))\n\t\t    {\n\t\t\tclear_tv(STACK_TV_BOT(0));\n\t\t\tgoto on_error;\n\t\t    }\n\n\t\t    clear_tv(sv->sv_tv);\n\t\t    *sv->sv_tv = *STACK_TV_BOT(0);\n\t\t}\n\t\tbreak;\n\n\t    // store option\n\t    case ISN_STOREOPT:\n\t    case ISN_STOREFUNCOPT:\n\t\t{\n\t\t    char_u\t*opt_name = iptr->isn_arg.storeopt.so_name;\n\t\t    int\t\topt_flags = iptr->isn_arg.storeopt.so_flags;\n\t\t    long\tn = 0;\n\t\t    char_u\t*s = NULL;\n\t\t    char\t*msg;\n\t\t    char_u\tnumbuf[NUMBUFLEN];\n\t\t    char_u\t*tofree = NULL;\n\n\t\t    --ectx->ec_stack.ga_len;\n\t\t    tv = STACK_TV_BOT(0);\n\t\t    if (tv->v_type == VAR_STRING)\n\t\t    {\n\t\t\ts = tv->vval.v_string;\n\t\t\tif (s == NULL)\n\t\t\t    s = (char_u *)\"\";\n\t\t    }\n\t\t    else if (iptr->isn_type == ISN_STOREFUNCOPT)\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\t// If the option can be set to a function reference or\n\t\t\t// a lambda and the passed value is a function\n\t\t\t// reference, then convert it to the name (string) of\n\t\t\t// the function reference.\n\t\t\ts = tv2string(tv, &tofree, numbuf, 0);\n\t\t\tif (s == NULL || *s == NUL)\n\t\t\t{\n\t\t\t    clear_tv(tv);\n\t\t\t    goto on_error;\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t\t// must be VAR_NUMBER, CHECKTYPE makes sure\n\t\t\tn = tv->vval.v_number;\n\t\t    msg = set_option_value(opt_name, n, s, opt_flags);\n\t\t    clear_tv(tv);\n\t\t    vim_free(tofree);\n\t\t    if (msg != NULL)\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\temsg(_(msg));\n\t\t\tgoto on_error;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    // store $ENV\n\t    case ISN_STOREENV:\n\t\t--ectx->ec_stack.ga_len;\n\t\ttv = STACK_TV_BOT(0);\n\t\tvim_setenv_ext(iptr->isn_arg.string, tv_get_string(tv));\n\t\tclear_tv(tv);\n\t\tbreak;\n\n\t    // store @r\n\t    case ISN_STOREREG:\n\t\t{\n\t\t    int\treg = iptr->isn_arg.number;\n\n\t\t    --ectx->ec_stack.ga_len;\n\t\t    tv = STACK_TV_BOT(0);\n\t\t    write_reg_contents(reg, tv_get_string(tv), -1, FALSE);\n\t\t    clear_tv(tv);\n\t\t}\n\t\tbreak;\n\n\t    // store v: variable\n\t    case ISN_STOREV:\n\t\t--ectx->ec_stack.ga_len;\n\t\tif (set_vim_var_tv(iptr->isn_arg.number, STACK_TV_BOT(0))\n\t\t\t\t\t\t\t\t       == FAIL)\n\t\t    // should not happen, type is checked when compiling\n\t\t    goto on_error;\n\t\tbreak;\n\n\t    // store g:/b:/w:/t: variable\n\t    case ISN_STOREG:\n\t    case ISN_STOREB:\n\t    case ISN_STOREW:\n\t    case ISN_STORET:\n\t\t{\n\t\t    dictitem_T\t*di;\n\t\t    hashtab_T\t*ht;\n\t\t    char_u\t*name = iptr->isn_arg.string + 2;\n\n\t\t    switch (iptr->isn_type)\n\t\t    {\n\t\t\tcase ISN_STOREG:\n\t\t\t    ht = get_globvar_ht();\n\t\t\t    break;\n\t\t\tcase ISN_STOREB:\n\t\t\t    ht = &curbuf->b_vars->dv_hashtab;\n\t\t\t    break;\n\t\t\tcase ISN_STOREW:\n\t\t\t    ht = &curwin->w_vars->dv_hashtab;\n\t\t\t    break;\n\t\t\tcase ISN_STORET:\n\t\t\t    ht = &curtab->tp_vars->dv_hashtab;\n\t\t\t    break;\n\t\t\tdefault:  // Cannot reach here\n\t\t\t    goto theend;\n\t\t    }\n\n\t\t    --ectx->ec_stack.ga_len;\n\t\t    di = find_var_in_ht(ht, 0, name, TRUE);\n\t\t    if (di == NULL)\n\t\t\tstore_var(iptr->isn_arg.string, STACK_TV_BOT(0));\n\t\t    else\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\tif (var_check_permission(di, name) == FAIL)\n\t\t\t    goto on_error;\n\t\t\tclear_tv(&di->di_tv);\n\t\t\tdi->di_tv = *STACK_TV_BOT(0);\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    // store an autoload variable\n\t    case ISN_STOREAUTO:\n\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\tset_var(iptr->isn_arg.string, STACK_TV_BOT(-1), TRUE);\n\t\tclear_tv(STACK_TV_BOT(-1));\n\t\t--ectx->ec_stack.ga_len;\n\t\tbreak;\n\n\t    // store number in local variable\n\t    case ISN_STORENR:\n\t\ttv = STACK_TV_VAR(iptr->isn_arg.storenr.stnr_idx);\n\t\tclear_tv(tv);\n\t\ttv->v_type = VAR_NUMBER;\n\t\ttv->vval.v_number = iptr->isn_arg.storenr.stnr_val;\n\t\tbreak;\n\n\t    // store value in list or dict variable\n\t    case ISN_STOREINDEX:\n\t\t{\n\t\t    vartype_T\tdest_type = iptr->isn_arg.vartype;\n\t\t    typval_T\t*tv_idx = STACK_TV_BOT(-2);\n\t\t    typval_T\t*tv_dest = STACK_TV_BOT(-1);\n\t\t    int\t\tstatus = OK;\n\n\t\t    // Stack contains:\n\t\t    // -3 value to be stored\n\t\t    // -2 index\n\t\t    // -1 dict or list\n\t\t    tv = STACK_TV_BOT(-3);\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    if (dest_type == VAR_ANY)\n\t\t    {\n\t\t\tdest_type = tv_dest->v_type;\n\t\t\tif (dest_type == VAR_DICT)\n\t\t\t    status = do_2string(tv_idx, TRUE, FALSE);\n\t\t\telse if (dest_type == VAR_LIST\n\t\t\t\t\t       && tv_idx->v_type != VAR_NUMBER)\n\t\t\t{\n\t\t\t    emsg(_(e_number_expected));\n\t\t\t    status = FAIL;\n\t\t\t}\n\t\t    }\n\t\t    else if (dest_type != tv_dest->v_type)\n\t\t    {\n\t\t\t// just in case, should be OK\n\t\t\tsemsg(_(e_expected_str_but_got_str),\n\t\t\t\t    vartype_name(dest_type),\n\t\t\t\t    vartype_name(tv_dest->v_type));\n\t\t\tstatus = FAIL;\n\t\t    }\n\n\t\t    if (status == OK && dest_type == VAR_LIST)\n\t\t    {\n\t\t\tlong\t    lidx = (long)tv_idx->vval.v_number;\n\t\t\tlist_T\t    *list = tv_dest->vval.v_list;\n\n\t\t\tif (list == NULL)\n\t\t\t{\n\t\t\t    emsg(_(e_list_not_set));\n\t\t\t    goto on_error;\n\t\t\t}\n\t\t\tif (lidx < 0 && list->lv_len + lidx >= 0)\n\t\t\t    // negative index is relative to the end\n\t\t\t    lidx = list->lv_len + lidx;\n\t\t\tif (lidx < 0 || lidx > list->lv_len)\n\t\t\t{\n\t\t\t    semsg(_(e_listidx), lidx);\n\t\t\t    goto on_error;\n\t\t\t}\n\t\t\tif (lidx < list->lv_len)\n\t\t\t{\n\t\t\t    listitem_T *li = list_find(list, lidx);\n\n\t\t\t    if (error_if_locked(li->li_tv.v_lock,\n\t\t\t\t\t\t    e_cannot_change_list_item))\n\t\t\t\tgoto on_error;\n\t\t\t    // overwrite existing list item\n\t\t\t    clear_tv(&li->li_tv);\n\t\t\t    li->li_tv = *tv;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    if (error_if_locked(list->lv_lock,\n\t\t\t\t\t\t\t e_cannot_change_list))\n\t\t\t\tgoto on_error;\n\t\t\t    // append to list, only fails when out of memory\n\t\t\t    if (list_append_tv(list, tv) == FAIL)\n\t\t\t\tgoto theend;\n\t\t\t    clear_tv(tv);\n\t\t\t}\n\t\t    }\n\t\t    else if (status == OK && dest_type == VAR_DICT)\n\t\t    {\n\t\t\tchar_u\t\t*key = tv_idx->vval.v_string;\n\t\t\tdict_T\t\t*dict = tv_dest->vval.v_dict;\n\t\t\tdictitem_T\t*di;\n\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\tif (dict == NULL)\n\t\t\t{\n\t\t\t    emsg(_(e_dictionary_not_set));\n\t\t\t    goto on_error;\n\t\t\t}\n\t\t\tif (key == NULL)\n\t\t\t    key = (char_u *)\"\";\n\t\t\tdi = dict_find(dict, key, -1);\n\t\t\tif (di != NULL)\n\t\t\t{\n\t\t\t    if (error_if_locked(di->di_tv.v_lock,\n\t\t\t\t\t\t    e_cannot_change_dict_item))\n\t\t\t\tgoto on_error;\n\t\t\t    // overwrite existing value\n\t\t\t    clear_tv(&di->di_tv);\n\t\t\t    di->di_tv = *tv;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    if (error_if_locked(dict->dv_lock,\n\t\t\t\t\t\t\t e_cannot_change_dict))\n\t\t\t\tgoto on_error;\n\t\t\t    // add to dict, only fails when out of memory\n\t\t\t    if (dict_add_tv(dict, (char *)key, tv) == FAIL)\n\t\t\t\tgoto theend;\n\t\t\t    clear_tv(tv);\n\t\t\t}\n\t\t    }\n\t\t    else if (status == OK && dest_type == VAR_BLOB)\n\t\t    {\n\t\t\tlong\t    lidx = (long)tv_idx->vval.v_number;\n\t\t\tblob_T\t    *blob = tv_dest->vval.v_blob;\n\t\t\tvarnumber_T nr;\n\t\t\tint\t    error = FALSE;\n\t\t\tint\t    len;\n\n\t\t\tif (blob == NULL)\n\t\t\t{\n\t\t\t    emsg(_(e_blob_not_set));\n\t\t\t    goto on_error;\n\t\t\t}\n\t\t\tlen = blob_len(blob);\n\t\t\tif (lidx < 0 && len + lidx >= 0)\n\t\t\t    // negative index is relative to the end\n\t\t\t    lidx = len + lidx;\n\n\t\t\t// Can add one byte at the end.\n\t\t\tif (lidx < 0 || lidx > len)\n\t\t\t{\n\t\t\t    semsg(_(e_blobidx), lidx);\n\t\t\t    goto on_error;\n\t\t\t}\n\t\t\tif (value_check_lock(blob->bv_lock,\n\t\t\t\t\t\t      (char_u *)\"blob\", FALSE))\n\t\t\t    goto on_error;\n\t\t\tnr = tv_get_number_chk(tv, &error);\n\t\t\tif (error)\n\t\t\t    goto on_error;\n\t\t\tblob_set_append(blob, lidx, nr);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tstatus = FAIL;\n\t\t\tsemsg(_(e_cannot_index_str), vartype_name(dest_type));\n\t\t    }\n\n\t\t    clear_tv(tv_idx);\n\t\t    clear_tv(tv_dest);\n\t\t    ectx->ec_stack.ga_len -= 3;\n\t\t    if (status == FAIL)\n\t\t    {\n\t\t\tclear_tv(tv);\n\t\t\tgoto on_error;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    // store value in blob range\n\t    case ISN_STORERANGE:\n\t\t{\n\t\t    typval_T\t*tv_idx1 = STACK_TV_BOT(-3);\n\t\t    typval_T\t*tv_idx2 = STACK_TV_BOT(-2);\n\t\t    typval_T\t*tv_dest = STACK_TV_BOT(-1);\n\t\t    int\t\tstatus = OK;\n\n\t\t    // Stack contains:\n\t\t    // -4 value to be stored\n\t\t    // -3 first index or \"none\"\n\t\t    // -2 second index or \"none\"\n\t\t    // -1 destination list or blob\n\t\t    tv = STACK_TV_BOT(-4);\n\t\t    if (tv_dest->v_type == VAR_LIST)\n\t\t    {\n\t\t\tlong\tn1;\n\t\t\tlong\tn2;\n\t\t\tint\terror = FALSE;\n\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\tn1 = (long)tv_get_number_chk(tv_idx1, &error);\n\t\t\tif (error)\n\t\t\t    status = FAIL;\n\t\t\telse\n\t\t\t{\n\t\t\t    if (tv_idx2->v_type == VAR_SPECIAL\n\t\t\t\t\t&& tv_idx2->vval.v_number == VVAL_NONE)\n\t\t\t\tn2 = list_len(tv_dest->vval.v_list) - 1;\n\t\t\t    else\n\t\t\t\tn2 = (long)tv_get_number_chk(tv_idx2, &error);\n\t\t\t    if (error)\n\t\t\t\tstatus = FAIL;\n\t\t\t    else\n\t\t\t    {\n\t\t\t\tlistitem_T *li1 = check_range_index_one(\n\t\t\t\t\ttv_dest->vval.v_list, &n1, FALSE);\n\n\t\t\t\tif (li1 == NULL)\n\t\t\t\t    status = FAIL;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t    status = check_range_index_two(\n\t\t\t\t\t    tv_dest->vval.v_list,\n\t\t\t\t\t    &n1, li1, &n2, FALSE);\n\t\t\t\t    if (status != FAIL)\n\t\t\t\t\tstatus = list_assign_range(\n\t\t\t\t\t\ttv_dest->vval.v_list,\n\t\t\t\t\t\ttv->vval.v_list,\n\t\t\t\t\t\tn1,\n\t\t\t\t\t\tn2,\n\t\t\t\t\t\ttv_idx2->v_type == VAR_SPECIAL,\n\t\t\t\t\t\t(char_u *)\"=\",\n\t\t\t\t\t\t(char_u *)\"[unknown]\");\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    else if (tv_dest->v_type == VAR_BLOB)\n\t\t    {\n\t\t\tvarnumber_T n1;\n\t\t\tvarnumber_T n2;\n\t\t\tint\t    error = FALSE;\n\n\t\t\tn1 = tv_get_number_chk(tv_idx1, &error);\n\t\t\tif (error)\n\t\t\t    status = FAIL;\n\t\t\telse\n\t\t\t{\n\t\t\t    if (tv_idx2->v_type == VAR_SPECIAL\n\t\t\t\t\t&& tv_idx2->vval.v_number == VVAL_NONE)\n\t\t\t\tn2 = blob_len(tv_dest->vval.v_blob) - 1;\n\t\t\t    else\n\t\t\t\tn2 = tv_get_number_chk(tv_idx2, &error);\n\t\t\t    if (error)\n\t\t\t\tstatus = FAIL;\n\t\t\t    else\n\t\t\t    {\n\t\t\t\tlong  bloblen = blob_len(tv_dest->vval.v_blob);\n\n\t\t\t\tif (check_blob_index(bloblen,\n\t\t\t\t\t\t\t     n1, FALSE) == FAIL\n\t\t\t\t\t|| check_blob_range(bloblen,\n\t\t\t\t\t\t\tn1, n2, FALSE) == FAIL)\n\t\t\t\t    status = FAIL;\n\t\t\t\telse\n\t\t\t\t    status = blob_set_range(\n\t\t\t\t\t     tv_dest->vval.v_blob, n1, n2, tv);\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tstatus = FAIL;\n\t\t\temsg(_(e_blob_required));\n\t\t    }\n\n\t\t    clear_tv(tv_idx1);\n\t\t    clear_tv(tv_idx2);\n\t\t    clear_tv(tv_dest);\n\t\t    ectx->ec_stack.ga_len -= 4;\n\t\t    clear_tv(tv);\n\n\t\t    if (status == FAIL)\n\t\t\tgoto on_error;\n\t\t}\n\t\tbreak;\n\n\t    // load or store variable or argument from outer scope\n\t    case ISN_LOADOUTER:\n\t    case ISN_STOREOUTER:\n\t\t{\n\t\t    int\t\tdepth = iptr->isn_arg.outer.outer_depth;\n\t\t    outer_T\t*outer = ectx->ec_outer_ref == NULL ? NULL\n\t\t\t\t\t\t: ectx->ec_outer_ref->or_outer;\n\n\t\t    while (depth > 1 && outer != NULL)\n\t\t    {\n\t\t\touter = outer->out_up;\n\t\t\t--depth;\n\t\t    }\n\t\t    if (outer == NULL)\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\tif (ectx->ec_frame_idx == ectx->ec_initial_frame_idx\n\t\t\t\t\t\t || ectx->ec_outer_ref == NULL)\n\t\t\t    // Possibly :def function called from legacy\n\t\t\t    // context.\n\t\t\t    emsg(_(e_closure_called_from_invalid_context));\n\t\t\telse\n\t\t\t    iemsg(\"LOADOUTER depth more than scope levels\");\n\t\t\tgoto theend;\n\t\t    }\n\t\t    tv = ((typval_T *)outer->out_stack->ga_data)\n\t\t\t\t    + outer->out_frame_idx + STACK_FRAME_SIZE\n\t\t\t\t    + iptr->isn_arg.outer.outer_idx;\n\t\t    if (iptr->isn_type == ISN_LOADOUTER)\n\t\t    {\n\t\t\tif (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t\t    goto theend;\n\t\t\tcopy_tv(tv, STACK_TV_BOT(0));\n\t\t\t++ectx->ec_stack.ga_len;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t--ectx->ec_stack.ga_len;\n\t\t\tclear_tv(tv);\n\t\t\t*tv = *STACK_TV_BOT(0);\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    // unlet item in list or dict variable\n\t    case ISN_UNLETINDEX:\n\t\t{\n\t\t    typval_T\t*tv_idx = STACK_TV_BOT(-2);\n\t\t    typval_T\t*tv_dest = STACK_TV_BOT(-1);\n\t\t    int\t\tstatus = OK;\n\n\t\t    // Stack contains:\n\t\t    // -2 index\n\t\t    // -1 dict or list\n\t\t    if (tv_dest->v_type == VAR_DICT)\n\t\t    {\n\t\t\t// unlet a dict item, index must be a string\n\t\t\tif (tv_idx->v_type != VAR_STRING)\n\t\t\t{\n\t\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t\t    semsg(_(e_expected_str_but_got_str),\n\t\t\t\t\tvartype_name(VAR_STRING),\n\t\t\t\t\tvartype_name(tv_idx->v_type));\n\t\t\t    status = FAIL;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    dict_T\t*d = tv_dest->vval.v_dict;\n\t\t\t    char_u\t*key = tv_idx->vval.v_string;\n\t\t\t    dictitem_T  *di = NULL;\n\n\t\t\t    if (d != NULL && value_check_lock(\n\t\t\t\t\t\t      d->dv_lock, NULL, FALSE))\n\t\t\t\tstatus = FAIL;\n\t\t\t    else\n\t\t\t    {\n\t\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\t\tif (key == NULL)\n\t\t\t\t    key = (char_u *)\"\";\n\t\t\t\tif (d != NULL)\n\t\t\t\t    di = dict_find(d, key, (int)STRLEN(key));\n\t\t\t\tif (di == NULL)\n\t\t\t\t{\n\t\t\t\t    // NULL dict is equivalent to empty dict\n\t\t\t\t    semsg(_(e_dictkey), key);\n\t\t\t\t    status = FAIL;\n\t\t\t\t}\n\t\t\t\telse if (var_check_fixed(di->di_flags,\n\t\t\t\t\t\t\t\t   NULL, FALSE)\n\t\t\t\t\t|| var_check_ro(di->di_flags,\n\t\t\t\t\t\t\t\t  NULL, FALSE))\n\t\t\t\t    status = FAIL;\n\t\t\t\telse\n\t\t\t\t    dictitem_remove(d, di);\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    else if (tv_dest->v_type == VAR_LIST)\n\t\t    {\n\t\t\t// unlet a List item, index must be a number\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\tif (check_for_number(tv_idx) == FAIL)\n\t\t\t{\n\t\t\t    status = FAIL;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    list_T\t*l = tv_dest->vval.v_list;\n\t\t\t    long\tn = (long)tv_idx->vval.v_number;\n\n\t\t\t    if (l != NULL && value_check_lock(\n\t\t\t\t\t\t      l->lv_lock, NULL, FALSE))\n\t\t\t\tstatus = FAIL;\n\t\t\t    else\n\t\t\t    {\n\t\t\t\tlistitem_T\t*li = list_find(l, n);\n\n\t\t\t\tif (li == NULL)\n\t\t\t\t{\n\t\t\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t\t\t    semsg(_(e_listidx), n);\n\t\t\t\t    status = FAIL;\n\t\t\t\t}\n\t\t\t\telse if (value_check_lock(li->li_tv.v_lock,\n\t\t\t\t\t\t\t\t  NULL, FALSE))\n\t\t\t\t    status = FAIL;\n\t\t\t\telse\n\t\t\t\t    listitem_remove(l, li);\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tstatus = FAIL;\n\t\t\tsemsg(_(e_cannot_index_str),\n\t\t\t\t\t\tvartype_name(tv_dest->v_type));\n\t\t    }\n\n\t\t    clear_tv(tv_idx);\n\t\t    clear_tv(tv_dest);\n\t\t    ectx->ec_stack.ga_len -= 2;\n\t\t    if (status == FAIL)\n\t\t\tgoto on_error;\n\t\t}\n\t\tbreak;\n\n\t    // unlet range of items in list variable\n\t    case ISN_UNLETRANGE:\n\t\t{\n\t\t    // Stack contains:\n\t\t    // -3 index1\n\t\t    // -2 index2\n\t\t    // -1 dict or list\n\t\t    typval_T\t*tv_idx1 = STACK_TV_BOT(-3);\n\t\t    typval_T\t*tv_idx2 = STACK_TV_BOT(-2);\n\t\t    typval_T\t*tv_dest = STACK_TV_BOT(-1);\n\t\t    int\t\tstatus = OK;\n\n\t\t    if (tv_dest->v_type == VAR_LIST)\n\t\t    {\n\t\t\t// indexes must be a number\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\tif (check_for_number(tv_idx1) == FAIL\n\t\t\t\t|| (tv_idx2->v_type != VAR_SPECIAL\n\t\t\t\t\t && check_for_number(tv_idx2) == FAIL))\n\t\t\t{\n\t\t\t    status = FAIL;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    list_T\t*l = tv_dest->vval.v_list;\n\t\t\t    long\tn1 = (long)tv_idx1->vval.v_number;\n\t\t\t    long\tn2 = tv_idx2->v_type == VAR_SPECIAL\n\t\t\t\t\t    ? 0 : (long)tv_idx2->vval.v_number;\n\t\t\t    listitem_T\t*li;\n\n\t\t\t    li = list_find_index(l, &n1);\n\t\t\t    if (li == NULL)\n\t\t\t\tstatus = FAIL;\n\t\t\t    else\n\t\t\t    {\n\t\t\t\tif (n1 < 0)\n\t\t\t\t    n1 = list_idx_of_item(l, li);\n\t\t\t\tif (n2 < 0)\n\t\t\t\t{\n\t\t\t\t    listitem_T *li2 = list_find(l, n2);\n\n\t\t\t\t    if (li2 == NULL)\n\t\t\t\t\tstatus = FAIL;\n\t\t\t\t    else\n\t\t\t\t\tn2 = list_idx_of_item(l, li2);\n\t\t\t\t}\n\t\t\t\tif (status != FAIL\n\t\t\t\t\t&& tv_idx2->v_type != VAR_SPECIAL\n\t\t\t\t\t&& n2 < n1)\n\t\t\t\t{\n\t\t\t\t    semsg(_(e_listidx), n2);\n\t\t\t\t    status = FAIL;\n\t\t\t\t}\n\t\t\t\tif (status != FAIL\n\t\t\t\t\t&& list_unlet_range(l, li, NULL, n1,\n\t\t\t\t\t    tv_idx2->v_type != VAR_SPECIAL, n2)\n\t\t\t\t\t\t\t\t       == FAIL)\n\t\t\t\t    status = FAIL;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tstatus = FAIL;\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\tsemsg(_(e_cannot_index_str),\n\t\t\t\t\t\tvartype_name(tv_dest->v_type));\n\t\t    }\n\n\t\t    clear_tv(tv_idx1);\n\t\t    clear_tv(tv_idx2);\n\t\t    clear_tv(tv_dest);\n\t\t    ectx->ec_stack.ga_len -= 3;\n\t\t    if (status == FAIL)\n\t\t\tgoto on_error;\n\t\t}\n\t\tbreak;\n\n\t    // push constant\n\t    case ISN_PUSHNR:\n\t    case ISN_PUSHBOOL:\n\t    case ISN_PUSHSPEC:\n\t    case ISN_PUSHF:\n\t    case ISN_PUSHS:\n\t    case ISN_PUSHBLOB:\n\t    case ISN_PUSHFUNC:\n\t    case ISN_PUSHCHANNEL:\n\t    case ISN_PUSHJOB:\n\t\tif (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t    goto theend;\n\t\ttv = STACK_TV_BOT(0);\n\t\ttv->v_lock = 0;\n\t\t++ectx->ec_stack.ga_len;\n\t\tswitch (iptr->isn_type)\n\t\t{\n\t\t    case ISN_PUSHNR:\n\t\t\ttv->v_type = VAR_NUMBER;\n\t\t\ttv->vval.v_number = iptr->isn_arg.number;\n\t\t\tbreak;\n\t\t    case ISN_PUSHBOOL:\n\t\t\ttv->v_type = VAR_BOOL;\n\t\t\ttv->vval.v_number = iptr->isn_arg.number;\n\t\t\tbreak;\n\t\t    case ISN_PUSHSPEC:\n\t\t\ttv->v_type = VAR_SPECIAL;\n\t\t\ttv->vval.v_number = iptr->isn_arg.number;\n\t\t\tbreak;\n#ifdef FEAT_FLOAT\n\t\t    case ISN_PUSHF:\n\t\t\ttv->v_type = VAR_FLOAT;\n\t\t\ttv->vval.v_float = iptr->isn_arg.fnumber;\n\t\t\tbreak;\n#endif\n\t\t    case ISN_PUSHBLOB:\n\t\t\tblob_copy(iptr->isn_arg.blob, tv);\n\t\t\tbreak;\n\t\t    case ISN_PUSHFUNC:\n\t\t\ttv->v_type = VAR_FUNC;\n\t\t\tif (iptr->isn_arg.string == NULL)\n\t\t\t    tv->vval.v_string = NULL;\n\t\t\telse\n\t\t\t    tv->vval.v_string =\n\t\t\t\t\t     vim_strsave(iptr->isn_arg.string);\n\t\t\tbreak;\n\t\t    case ISN_PUSHCHANNEL:\n#ifdef FEAT_JOB_CHANNEL\n\t\t\ttv->v_type = VAR_CHANNEL;\n\t\t\ttv->vval.v_channel = iptr->isn_arg.channel;\n\t\t\tif (tv->vval.v_channel != NULL)\n\t\t\t    ++tv->vval.v_channel->ch_refcount;\n#endif\n\t\t\tbreak;\n\t\t    case ISN_PUSHJOB:\n#ifdef FEAT_JOB_CHANNEL\n\t\t\ttv->v_type = VAR_JOB;\n\t\t\ttv->vval.v_job = iptr->isn_arg.job;\n\t\t\tif (tv->vval.v_job != NULL)\n\t\t\t    ++tv->vval.v_job->jv_refcount;\n#endif\n\t\t\tbreak;\n\t\t    default:\n\t\t\ttv->v_type = VAR_STRING;\n\t\t\ttv->vval.v_string = vim_strsave(\n\t\t\t\tiptr->isn_arg.string == NULL\n\t\t\t\t\t? (char_u *)\"\" : iptr->isn_arg.string);\n\t\t}\n\t\tbreak;\n\n\t    case ISN_UNLET:\n\t\tif (do_unlet(iptr->isn_arg.unlet.ul_name,\n\t\t\t\t       iptr->isn_arg.unlet.ul_forceit) == FAIL)\n\t\t    goto on_error;\n\t\tbreak;\n\t    case ISN_UNLETENV:\n\t\tvim_unsetenv(iptr->isn_arg.unlet.ul_name);\n\t\tbreak;\n\n\t    case ISN_LOCKUNLOCK:\n\t\t{\n\t\t    typval_T\t*lval_root_save = lval_root;\n\t\t    int\t\tres;\n\n\t\t    // Stack has the local variable, argument the whole :lock\n\t\t    // or :unlock command, like ISN_EXEC.\n\t\t    --ectx->ec_stack.ga_len;\n\t\t    lval_root = STACK_TV_BOT(0);\n\t\t    res = exec_command(iptr);\n\t\t    clear_tv(lval_root);\n\t\t    lval_root = lval_root_save;\n\t\t    if (res == FAIL)\n\t\t\tgoto on_error;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_LOCKCONST:\n\t\titem_lock(STACK_TV_BOT(-1), 100, TRUE, TRUE);\n\t\tbreak;\n\n\t    // create a list from items on the stack; uses a single allocation\n\t    // for the list header and the items\n\t    case ISN_NEWLIST:\n\t\tif (exe_newlist(iptr->isn_arg.number, ectx) == FAIL)\n\t\t    goto theend;\n\t\tbreak;\n\n\t    // create a dict from items on the stack\n\t    case ISN_NEWDICT:\n\t\t{\n\t\t    int\t\tcount = iptr->isn_arg.number;\n\t\t    dict_T\t*dict = dict_alloc();\n\t\t    dictitem_T\t*item;\n\t\t    char_u\t*key;\n\t\t    int\t\tidx;\n\n\t\t    if (unlikely(dict == NULL))\n\t\t\tgoto theend;\n\t\t    for (idx = 0; idx < count; ++idx)\n\t\t    {\n\t\t\t// have already checked key type is VAR_STRING\n\t\t\ttv = STACK_TV_BOT(2 * (idx - count));\n\t\t\t// check key is unique\n\t\t\tkey = tv->vval.v_string == NULL\n\t\t\t\t\t    ? (char_u *)\"\" : tv->vval.v_string;\n\t\t\titem = dict_find(dict, key, -1);\n\t\t\tif (item != NULL)\n\t\t\t{\n\t\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t\t    semsg(_(e_duplicate_key), key);\n\t\t\t    dict_unref(dict);\n\t\t\t    goto on_error;\n\t\t\t}\n\t\t\titem = dictitem_alloc(key);\n\t\t\tclear_tv(tv);\n\t\t\tif (unlikely(item == NULL))\n\t\t\t{\n\t\t\t    dict_unref(dict);\n\t\t\t    goto theend;\n\t\t\t}\n\t\t\titem->di_tv = *STACK_TV_BOT(2 * (idx - count) + 1);\n\t\t\titem->di_tv.v_lock = 0;\n\t\t\tif (dict_add(dict, item) == FAIL)\n\t\t\t{\n\t\t\t    // can this ever happen?\n\t\t\t    dict_unref(dict);\n\t\t\t    goto theend;\n\t\t\t}\n\t\t    }\n\n\t\t    if (count > 0)\n\t\t\tectx->ec_stack.ga_len -= 2 * count - 1;\n\t\t    else if (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t\tgoto theend;\n\t\t    else\n\t\t\t++ectx->ec_stack.ga_len;\n\t\t    tv = STACK_TV_BOT(-1);\n\t\t    tv->v_type = VAR_DICT;\n\t\t    tv->v_lock = 0;\n\t\t    tv->vval.v_dict = dict;\n\t\t    ++dict->dv_refcount;\n\t\t}\n\t\tbreak;\n\n\t    // call a :def function\n\t    case ISN_DCALL:\n\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\tif (call_dfunc(iptr->isn_arg.dfunc.cdf_idx,\n\t\t\t\tNULL,\n\t\t\t\tiptr->isn_arg.dfunc.cdf_argcount,\n\t\t\t\tectx) == FAIL)\n\t\t    goto on_error;\n\t\tbreak;\n\n\t    // call a builtin function\n\t    case ISN_BCALL:\n\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\tif (call_bfunc(iptr->isn_arg.bfunc.cbf_idx,\n\t\t\t      iptr->isn_arg.bfunc.cbf_argcount,\n\t\t\t      ectx) == FAIL)\n\t\t    goto on_error;\n\t\tbreak;\n\n\t    // call a funcref or partial\n\t    case ISN_PCALL:\n\t\t{\n\t\t    cpfunc_T\t*pfunc = &iptr->isn_arg.pfunc;\n\t\t    int\t\tr;\n\t\t    typval_T\tpartial_tv;\n\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    if (pfunc->cpf_top)\n\t\t    {\n\t\t\t// funcref is above the arguments\n\t\t\ttv = STACK_TV_BOT(-pfunc->cpf_argcount - 1);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// Get the funcref from the stack.\n\t\t\t--ectx->ec_stack.ga_len;\n\t\t\tpartial_tv = *STACK_TV_BOT(0);\n\t\t\ttv = &partial_tv;\n\t\t    }\n\t\t    r = call_partial(tv, pfunc->cpf_argcount, ectx);\n\t\t    if (tv == &partial_tv)\n\t\t\tclear_tv(&partial_tv);\n\t\t    if (r == FAIL)\n\t\t\tgoto on_error;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_PCALL_END:\n\t\t// PCALL finished, arguments have been consumed and replaced by\n\t\t// the return value.  Now clear the funcref from the stack,\n\t\t// and move the return value in its place.\n\t\t--ectx->ec_stack.ga_len;\n\t\tclear_tv(STACK_TV_BOT(-1));\n\t\t*STACK_TV_BOT(-1) = *STACK_TV_BOT(0);\n\t\tbreak;\n\n\t    // call a user defined function or funcref/partial\n\t    case ISN_UCALL:\n\t\t{\n\t\t    cufunc_T\t*cufunc = &iptr->isn_arg.ufunc;\n\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    if (call_eval_func(cufunc->cuf_name, cufunc->cuf_argcount,\n\t\t\t\t\t\t\t   ectx, iptr) == FAIL)\n\t\t\tgoto on_error;\n\t\t}\n\t\tbreak;\n\n\t    // return from a :def function call without a value\n\t    case ISN_RETURN_VOID:\n\t\tif (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t    goto theend;\n\t\ttv = STACK_TV_BOT(0);\n\t\t++ectx->ec_stack.ga_len;\n\t\ttv->v_type = VAR_VOID;\n\t\ttv->vval.v_number = 0;\n\t\ttv->v_lock = 0;\n\t\t// FALLTHROUGH\n\n\t    // return from a :def function call with what is on the stack\n\t    case ISN_RETURN:\n\t\t{\n\t\t    garray_T\t*trystack = &ectx->ec_trystack;\n\t\t    trycmd_T    *trycmd = NULL;\n\n\t\t    if (trystack->ga_len > 0)\n\t\t\ttrycmd = ((trycmd_T *)trystack->ga_data)\n\t\t\t\t\t\t\t+ trystack->ga_len - 1;\n\t\t    if (trycmd != NULL\n\t\t\t\t && trycmd->tcd_frame_idx == ectx->ec_frame_idx)\n\t\t    {\n\t\t\t// jump to \":finally\" or \":endtry\"\n\t\t\tif (trycmd->tcd_finally_idx != 0)\n\t\t\t    ectx->ec_iidx = trycmd->tcd_finally_idx;\n\t\t\telse\n\t\t\t    ectx->ec_iidx = trycmd->tcd_endtry_idx;\n\t\t\ttrycmd->tcd_return = TRUE;\n\t\t    }\n\t\t    else\n\t\t\tgoto func_return;\n\t\t}\n\t\tbreak;\n\n\t    // push a partial, a reference to a compiled function\n\t    case ISN_FUNCREF:\n\t\t{\n\t\t    partial_T   *pt = ALLOC_CLEAR_ONE(partial_T);\n\t\t    ufunc_T\t*ufunc;\n\t\t    funcref_T\t*funcref = &iptr->isn_arg.funcref;\n\n\t\t    if (pt == NULL)\n\t\t\tgoto theend;\n\t\t    if (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t    {\n\t\t\tvim_free(pt);\n\t\t\tgoto theend;\n\t\t    }\n\t\t    if (funcref->fr_func_name == NULL)\n\t\t    {\n\t\t\tdfunc_T\t*pt_dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t       + funcref->fr_dfunc_idx;\n\n\t\t\tufunc = pt_dfunc->df_ufunc;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tufunc = find_func(funcref->fr_func_name, FALSE, NULL);\n\t\t    }\n\t\t    if (ufunc == NULL)\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\temsg(_(e_function_reference_invalid));\n\t\t\tgoto theend;\n\t\t    }\n\t\t    if (fill_partial_and_closure(pt, ufunc, ectx) == FAIL)\n\t\t\tgoto theend;\n\t\t    tv = STACK_TV_BOT(0);\n\t\t    ++ectx->ec_stack.ga_len;\n\t\t    tv->vval.v_partial = pt;\n\t\t    tv->v_type = VAR_PARTIAL;\n\t\t    tv->v_lock = 0;\n\t\t}\n\t\tbreak;\n\n\t    // Create a global function from a lambda.\n\t    case ISN_NEWFUNC:\n\t\t{\n\t\t    newfunc_T\t*newfunc = &iptr->isn_arg.newfunc;\n\n\t\t    if (copy_func(newfunc->nf_lambda, newfunc->nf_global,\n\t\t\t\t\t\t\t\t ectx) == FAIL)\n\t\t\tgoto theend;\n\t\t}\n\t\tbreak;\n\n\t    // List functions\n\t    case ISN_DEF:\n\t\tif (iptr->isn_arg.string == NULL)\n\t\t    list_functions(NULL);\n\t\telse\n\t\t{\n\t\t    exarg_T ea;\n\n\t\t    CLEAR_FIELD(ea);\n\t\t    ea.cmd = ea.arg = iptr->isn_arg.string;\n\t\t    define_function(&ea, NULL);\n\t\t}\n\t\tbreak;\n\n\t    // jump if a condition is met\n\t    case ISN_JUMP:\n\t\t{\n\t\t    jumpwhen_T\twhen = iptr->isn_arg.jump.jump_when;\n\t\t    int\t\terror = FALSE;\n\t\t    int\t\tjump = TRUE;\n\n\t\t    if (when != JUMP_ALWAYS)\n\t\t    {\n\t\t\ttv = STACK_TV_BOT(-1);\n\t\t\tif (when == JUMP_IF_COND_FALSE\n\t\t\t\t|| when == JUMP_IF_FALSE\n\t\t\t\t|| when == JUMP_IF_COND_TRUE)\n\t\t\t{\n\t\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t\t    jump = tv_get_bool_chk(tv, &error);\n\t\t\t    if (error)\n\t\t\t\tgoto on_error;\n\t\t\t}\n\t\t\telse\n\t\t\t    jump = tv2bool(tv);\n\t\t\tif (when == JUMP_IF_FALSE\n\t\t\t\t\t     || when == JUMP_AND_KEEP_IF_FALSE\n\t\t\t\t\t     || when == JUMP_IF_COND_FALSE)\n\t\t\t    jump = !jump;\n\t\t\tif (when == JUMP_IF_FALSE || !jump)\n\t\t\t{\n\t\t\t    // drop the value from the stack\n\t\t\t    clear_tv(tv);\n\t\t\t    --ectx->ec_stack.ga_len;\n\t\t\t}\n\t\t    }\n\t\t    if (jump)\n\t\t\tectx->ec_iidx = iptr->isn_arg.jump.jump_where;\n\t\t}\n\t\tbreak;\n\n\t    // Jump if an argument with a default value was already set and not\n\t    // v:none.\n\t    case ISN_JUMP_IF_ARG_SET:\n\t\ttv = STACK_TV_VAR(iptr->isn_arg.jumparg.jump_arg_off);\n\t\tif (tv->v_type != VAR_UNKNOWN\n\t\t\t&& !(tv->v_type == VAR_SPECIAL\n\t\t\t\t\t    && tv->vval.v_number == VVAL_NONE))\n\t\t    ectx->ec_iidx = iptr->isn_arg.jumparg.jump_where;\n\t\tbreak;\n\n\t    // top of a for loop\n\t    case ISN_FOR:\n\t\t{\n\t\t    typval_T\t*ltv = STACK_TV_BOT(-1);\n\t\t    typval_T\t*idxtv =\n\t\t\t\t   STACK_TV_VAR(iptr->isn_arg.forloop.for_idx);\n\n\t\t    if (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t\tgoto theend;\n\t\t    if (ltv->v_type == VAR_LIST)\n\t\t    {\n\t\t\tlist_T *list = ltv->vval.v_list;\n\n\t\t\t// push the next item from the list\n\t\t\t++idxtv->vval.v_number;\n\t\t\tif (list == NULL\n\t\t\t\t       || idxtv->vval.v_number >= list->lv_len)\n\t\t\t{\n\t\t\t    // past the end of the list, jump to \"endfor\"\n\t\t\t    ectx->ec_iidx = iptr->isn_arg.forloop.for_end;\n\t\t\t    may_restore_cmdmod(&ectx->ec_funclocal);\n\t\t\t}\n\t\t\telse if (list->lv_first == &range_list_item)\n\t\t\t{\n\t\t\t    // non-materialized range() list\n\t\t\t    tv = STACK_TV_BOT(0);\n\t\t\t    tv->v_type = VAR_NUMBER;\n\t\t\t    tv->v_lock = 0;\n\t\t\t    tv->vval.v_number = list_find_nr(\n\t\t\t\t\t     list, idxtv->vval.v_number, NULL);\n\t\t\t    ++ectx->ec_stack.ga_len;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    listitem_T *li = list_find(list,\n\t\t\t\t\t\t\t idxtv->vval.v_number);\n\n\t\t\t    copy_tv(&li->li_tv, STACK_TV_BOT(0));\n\t\t\t    ++ectx->ec_stack.ga_len;\n\t\t\t}\n\t\t    }\n\t\t    else if (ltv->v_type == VAR_STRING)\n\t\t    {\n\t\t\tchar_u\t*str = ltv->vval.v_string;\n\n\t\t\t// The index is for the last byte of the previous\n\t\t\t// character.\n\t\t\t++idxtv->vval.v_number;\n\t\t\tif (str == NULL || str[idxtv->vval.v_number] == NUL)\n\t\t\t{\n\t\t\t    // past the end of the string, jump to \"endfor\"\n\t\t\t    ectx->ec_iidx = iptr->isn_arg.forloop.for_end;\n\t\t\t    may_restore_cmdmod(&ectx->ec_funclocal);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    int\tclen = mb_ptr2len(str + idxtv->vval.v_number);\n\n\t\t\t    // Push the next character from the string.\n\t\t\t    tv = STACK_TV_BOT(0);\n\t\t\t    tv->v_type = VAR_STRING;\n\t\t\t    tv->vval.v_string = vim_strnsave(\n\t\t\t\t\t     str + idxtv->vval.v_number, clen);\n\t\t\t    ++ectx->ec_stack.ga_len;\n\t\t\t    idxtv->vval.v_number += clen - 1;\n\t\t\t}\n\t\t    }\n\t\t    else if (ltv->v_type == VAR_BLOB)\n\t\t    {\n\t\t\tblob_T\t*blob = ltv->vval.v_blob;\n\n\t\t\t// When we get here the first time make a copy of the\n\t\t\t// blob, so that the iteration still works when it is\n\t\t\t// changed.\n\t\t\tif (idxtv->vval.v_number == -1 && blob != NULL)\n\t\t\t{\n\t\t\t    blob_copy(blob, ltv);\n\t\t\t    blob_unref(blob);\n\t\t\t    blob = ltv->vval.v_blob;\n\t\t\t}\n\n\t\t\t// The index is for the previous byte.\n\t\t\t++idxtv->vval.v_number;\n\t\t\tif (blob == NULL\n\t\t\t\t     || idxtv->vval.v_number >= blob_len(blob))\n\t\t\t{\n\t\t\t    // past the end of the blob, jump to \"endfor\"\n\t\t\t    ectx->ec_iidx = iptr->isn_arg.forloop.for_end;\n\t\t\t    may_restore_cmdmod(&ectx->ec_funclocal);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // Push the next byte from the blob.\n\t\t\t    tv = STACK_TV_BOT(0);\n\t\t\t    tv->v_type = VAR_NUMBER;\n\t\t\t    tv->vval.v_number = blob_get(blob,\n\t\t\t\t\t\t\t idxtv->vval.v_number);\n\t\t\t    ++ectx->ec_stack.ga_len;\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tsemsg(_(e_for_loop_on_str_not_supported),\n\t\t\t\t\t\t    vartype_name(ltv->v_type));\n\t\t\tgoto theend;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    // start of \":try\" block\n\t    case ISN_TRY:\n\t\t{\n\t\t    trycmd_T    *trycmd = NULL;\n\n\t\t    if (GA_GROW_FAILS(&ectx->ec_trystack, 1))\n\t\t\tgoto theend;\n\t\t    trycmd = ((trycmd_T *)ectx->ec_trystack.ga_data)\n\t\t\t\t\t\t     + ectx->ec_trystack.ga_len;\n\t\t    ++ectx->ec_trystack.ga_len;\n\t\t    ++trylevel;\n\t\t    CLEAR_POINTER(trycmd);\n\t\t    trycmd->tcd_frame_idx = ectx->ec_frame_idx;\n\t\t    trycmd->tcd_stack_len = ectx->ec_stack.ga_len;\n\t\t    trycmd->tcd_catch_idx =\n\t\t\t\t       iptr->isn_arg.tryref.try_ref->try_catch;\n\t\t    trycmd->tcd_finally_idx =\n\t\t\t\t     iptr->isn_arg.tryref.try_ref->try_finally;\n\t\t    trycmd->tcd_endtry_idx =\n\t\t\t\t      iptr->isn_arg.tryref.try_ref->try_endtry;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_PUSHEXC:\n\t\tif (current_exception == NULL)\n\t\t{\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    iemsg(\"Evaluating catch while current_exception is NULL\");\n\t\t    goto theend;\n\t\t}\n\t\tif (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t    goto theend;\n\t\ttv = STACK_TV_BOT(0);\n\t\t++ectx->ec_stack.ga_len;\n\t\ttv->v_type = VAR_STRING;\n\t\ttv->v_lock = 0;\n\t\ttv->vval.v_string = vim_strsave(\n\t\t\t\t\t   (char_u *)current_exception->value);\n\t\tbreak;\n\n\t    case ISN_CATCH:\n\t\t{\n\t\t    garray_T\t*trystack = &ectx->ec_trystack;\n\n\t\t    may_restore_cmdmod(&ectx->ec_funclocal);\n\t\t    if (trystack->ga_len > 0)\n\t\t    {\n\t\t\ttrycmd_T    *trycmd = ((trycmd_T *)trystack->ga_data)\n\t\t\t\t\t\t\t+ trystack->ga_len - 1;\n\t\t\ttrycmd->tcd_caught = TRUE;\n\t\t\ttrycmd->tcd_did_throw = FALSE;\n\t\t    }\n\t\t    did_emsg = got_int = did_throw = FALSE;\n\t\t    force_abort = need_rethrow = FALSE;\n\t\t    catch_exception(current_exception);\n\t\t}\n\t\tbreak;\n\n\t    case ISN_TRYCONT:\n\t\t{\n\t\t    garray_T\t*trystack = &ectx->ec_trystack;\n\t\t    trycont_T\t*trycont = &iptr->isn_arg.trycont;\n\t\t    int\t\ti;\n\t\t    trycmd_T    *trycmd;\n\t\t    int\t\tiidx = trycont->tct_where;\n\n\t\t    if (trystack->ga_len < trycont->tct_levels)\n\t\t    {\n\t\t\tsiemsg(\"TRYCONT: expected %d levels, found %d\",\n\t\t\t\t\ttrycont->tct_levels, trystack->ga_len);\n\t\t\tgoto theend;\n\t\t    }\n\t\t    // Make :endtry jump to any outer try block and the last\n\t\t    // :endtry inside the loop to the loop start.\n\t\t    for (i = trycont->tct_levels; i > 0; --i)\n\t\t    {\n\t\t\ttrycmd = ((trycmd_T *)trystack->ga_data)\n\t\t\t\t\t\t\t+ trystack->ga_len - i;\n\t\t\t// Add one to tcd_cont to be able to jump to\n\t\t\t// instruction with index zero.\n\t\t\ttrycmd->tcd_cont = iidx + 1;\n\t\t\tiidx = trycmd->tcd_finally_idx == 0\n\t\t\t    ? trycmd->tcd_endtry_idx : trycmd->tcd_finally_idx;\n\t\t    }\n\t\t    // jump to :finally or :endtry of current try statement\n\t\t    ectx->ec_iidx = iidx;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_FINALLY:\n\t\t{\n\t\t    garray_T\t*trystack = &ectx->ec_trystack;\n\t\t    trycmd_T    *trycmd = ((trycmd_T *)trystack->ga_data)\n\t\t\t\t\t\t\t+ trystack->ga_len - 1;\n\n\t\t    // Reset the index to avoid a return statement jumps here\n\t\t    // again.\n\t\t    trycmd->tcd_finally_idx = 0;\n\t\t    break;\n\t\t}\n\n\t    // end of \":try\" block\n\t    case ISN_ENDTRY:\n\t\t{\n\t\t    garray_T\t*trystack = &ectx->ec_trystack;\n\n\t\t    if (trystack->ga_len > 0)\n\t\t    {\n\t\t\ttrycmd_T    *trycmd;\n\n\t\t\t--trystack->ga_len;\n\t\t\t--trylevel;\n\t\t\ttrycmd = ((trycmd_T *)trystack->ga_data)\n\t\t\t\t\t\t\t    + trystack->ga_len;\n\t\t\tif (trycmd->tcd_did_throw)\n\t\t\t    did_throw = TRUE;\n\t\t\tif (trycmd->tcd_caught && current_exception != NULL)\n\t\t\t{\n\t\t\t    // discard the exception\n\t\t\t    if (caught_stack == current_exception)\n\t\t\t\tcaught_stack = caught_stack->caught;\n\t\t\t    discard_current_exception();\n\t\t\t}\n\n\t\t\tif (trycmd->tcd_return)\n\t\t\t    goto func_return;\n\n\t\t\twhile (ectx->ec_stack.ga_len > trycmd->tcd_stack_len)\n\t\t\t{\n\t\t\t    --ectx->ec_stack.ga_len;\n\t\t\t    clear_tv(STACK_TV_BOT(0));\n\t\t\t}\n\t\t\tif (trycmd->tcd_cont != 0)\n\t\t\t    // handling :continue: jump to outer try block or\n\t\t\t    // start of the loop\n\t\t\t    ectx->ec_iidx = trycmd->tcd_cont - 1;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    case ISN_THROW:\n\t\t{\n\t\t    garray_T\t*trystack = &ectx->ec_trystack;\n\n\t\t    if (trystack->ga_len == 0 && trylevel == 0 && emsg_silent)\n\t\t    {\n\t\t\t// throwing an exception while using \"silent!\" causes\n\t\t\t// the function to abort but not display an error.\n\t\t\ttv = STACK_TV_BOT(-1);\n\t\t\tclear_tv(tv);\n\t\t\ttv->v_type = VAR_NUMBER;\n\t\t\ttv->vval.v_number = 0;\n\t\t\tgoto done;\n\t\t    }\n\t\t    --ectx->ec_stack.ga_len;\n\t\t    tv = STACK_TV_BOT(0);\n\t\t    if (tv->vval.v_string == NULL\n\t\t\t\t       || *skipwhite(tv->vval.v_string) == NUL)\n\t\t    {\n\t\t\tvim_free(tv->vval.v_string);\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\temsg(_(e_throw_with_empty_string));\n\t\t\tgoto theend;\n\t\t    }\n\n\t\t    // Inside a \"catch\" we need to first discard the caught\n\t\t    // exception.\n\t\t    if (trystack->ga_len > 0)\n\t\t    {\n\t\t\ttrycmd_T    *trycmd = ((trycmd_T *)trystack->ga_data)\n\t\t\t\t\t\t\t+ trystack->ga_len - 1;\n\t\t\tif (trycmd->tcd_caught && current_exception != NULL)\n\t\t\t{\n\t\t\t    // discard the exception\n\t\t\t    if (caught_stack == current_exception)\n\t\t\t\tcaught_stack = caught_stack->caught;\n\t\t\t    discard_current_exception();\n\t\t\t    trycmd->tcd_caught = FALSE;\n\t\t\t}\n\t\t    }\n\n\t\t    if (throw_exception(tv->vval.v_string, ET_USER, NULL)\n\t\t\t\t\t\t\t\t       == FAIL)\n\t\t    {\n\t\t\tvim_free(tv->vval.v_string);\n\t\t\tgoto theend;\n\t\t    }\n\t\t    did_throw = TRUE;\n\t\t}\n\t\tbreak;\n\n\t    // compare with special values\n\t    case ISN_COMPAREBOOL:\n\t    case ISN_COMPARESPECIAL:\n\t\t{\n\t\t    typval_T\t*tv1 = STACK_TV_BOT(-2);\n\t\t    typval_T\t*tv2 = STACK_TV_BOT(-1);\n\t\t    varnumber_T arg1 = tv1->vval.v_number;\n\t\t    varnumber_T arg2 = tv2->vval.v_number;\n\t\t    int\t\tres;\n\n\t\t    switch (iptr->isn_arg.op.op_type)\n\t\t    {\n\t\t\tcase EXPR_EQUAL: res = arg1 == arg2; break;\n\t\t\tcase EXPR_NEQUAL: res = arg1 != arg2; break;\n\t\t\tdefault: res = 0; break;\n\t\t    }\n\n\t\t    --ectx->ec_stack.ga_len;\n\t\t    tv1->v_type = VAR_BOOL;\n\t\t    tv1->vval.v_number = res ? VVAL_TRUE : VVAL_FALSE;\n\t\t}\n\t\tbreak;\n\n\t    // Operation with two number arguments\n\t    case ISN_OPNR:\n\t    case ISN_COMPARENR:\n\t\t{\n\t\t    typval_T\t*tv1 = STACK_TV_BOT(-2);\n\t\t    typval_T\t*tv2 = STACK_TV_BOT(-1);\n\t\t    varnumber_T arg1 = tv1->vval.v_number;\n\t\t    varnumber_T arg2 = tv2->vval.v_number;\n\t\t    varnumber_T res = 0;\n\t\t    int\t\tdiv_zero = FALSE;\n\n\t\t    switch (iptr->isn_arg.op.op_type)\n\t\t    {\n\t\t\tcase EXPR_MULT: res = arg1 * arg2; break;\n\t\t\tcase EXPR_DIV:  if (arg2 == 0)\n\t\t\t\t\t    div_zero = TRUE;\n\t\t\t\t\telse\n\t\t\t\t\t    res = arg1 / arg2;\n\t\t\t\t\tbreak;\n\t\t\tcase EXPR_REM:  if (arg2 == 0)\n\t\t\t\t\t    div_zero = TRUE;\n\t\t\t\t\telse\n\t\t\t\t\t    res = arg1 % arg2;\n\t\t\t\t\tbreak;\n\t\t\tcase EXPR_SUB: res = arg1 - arg2; break;\n\t\t\tcase EXPR_ADD: res = arg1 + arg2; break;\n\n\t\t\tcase EXPR_EQUAL: res = arg1 == arg2; break;\n\t\t\tcase EXPR_NEQUAL: res = arg1 != arg2; break;\n\t\t\tcase EXPR_GREATER: res = arg1 > arg2; break;\n\t\t\tcase EXPR_GEQUAL: res = arg1 >= arg2; break;\n\t\t\tcase EXPR_SMALLER: res = arg1 < arg2; break;\n\t\t\tcase EXPR_SEQUAL: res = arg1 <= arg2; break;\n\t\t\tdefault: break;\n\t\t    }\n\n\t\t    --ectx->ec_stack.ga_len;\n\t\t    if (iptr->isn_type == ISN_COMPARENR)\n\t\t    {\n\t\t\ttv1->v_type = VAR_BOOL;\n\t\t\ttv1->vval.v_number = res ? VVAL_TRUE : VVAL_FALSE;\n\t\t    }\n\t\t    else\n\t\t\ttv1->vval.v_number = res;\n\t\t    if (div_zero)\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\temsg(_(e_divide_by_zero));\n\t\t\tgoto on_error;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    // Computation with two float arguments\n\t    case ISN_OPFLOAT:\n\t    case ISN_COMPAREFLOAT:\n#ifdef FEAT_FLOAT\n\t\t{\n\t\t    typval_T\t*tv1 = STACK_TV_BOT(-2);\n\t\t    typval_T\t*tv2 = STACK_TV_BOT(-1);\n\t\t    float_T\targ1 = tv1->vval.v_float;\n\t\t    float_T\targ2 = tv2->vval.v_float;\n\t\t    float_T\tres = 0;\n\t\t    int\t\tcmp = FALSE;\n\n\t\t    switch (iptr->isn_arg.op.op_type)\n\t\t    {\n\t\t\tcase EXPR_MULT: res = arg1 * arg2; break;\n\t\t\tcase EXPR_DIV: res = arg1 / arg2; break;\n\t\t\tcase EXPR_SUB: res = arg1 - arg2; break;\n\t\t\tcase EXPR_ADD: res = arg1 + arg2; break;\n\n\t\t\tcase EXPR_EQUAL: cmp = arg1 == arg2; break;\n\t\t\tcase EXPR_NEQUAL: cmp = arg1 != arg2; break;\n\t\t\tcase EXPR_GREATER: cmp = arg1 > arg2; break;\n\t\t\tcase EXPR_GEQUAL: cmp = arg1 >= arg2; break;\n\t\t\tcase EXPR_SMALLER: cmp = arg1 < arg2; break;\n\t\t\tcase EXPR_SEQUAL: cmp = arg1 <= arg2; break;\n\t\t\tdefault: cmp = 0; break;\n\t\t    }\n\t\t    --ectx->ec_stack.ga_len;\n\t\t    if (iptr->isn_type == ISN_COMPAREFLOAT)\n\t\t    {\n\t\t\ttv1->v_type = VAR_BOOL;\n\t\t\ttv1->vval.v_number = cmp ? VVAL_TRUE : VVAL_FALSE;\n\t\t    }\n\t\t    else\n\t\t\ttv1->vval.v_float = res;\n\t\t}\n#endif\n\t\tbreak;\n\n\t    case ISN_COMPARELIST:\n\t    case ISN_COMPAREDICT:\n\t    case ISN_COMPAREFUNC:\n\t    case ISN_COMPARESTRING:\n\t    case ISN_COMPAREBLOB:\n\t\t{\n\t\t    typval_T\t*tv1 = STACK_TV_BOT(-2);\n\t\t    typval_T\t*tv2 = STACK_TV_BOT(-1);\n\t\t    exprtype_T\texprtype = iptr->isn_arg.op.op_type;\n\t\t    int\t\tic = iptr->isn_arg.op.op_ic;\n\t\t    int\t\tres = FALSE;\n\t\t    int\t\tstatus = OK;\n\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    if (iptr->isn_type == ISN_COMPARELIST)\n\t\t    {\n\t\t\tstatus = typval_compare_list(tv1, tv2,\n\t\t\t\t\t\t\t   exprtype, ic, &res);\n\t\t    }\n\t\t    else if (iptr->isn_type == ISN_COMPAREDICT)\n\t\t    {\n\t\t\tstatus = typval_compare_dict(tv1, tv2,\n\t\t\t\t\t\t\t   exprtype, ic, &res);\n\t\t    }\n\t\t    else if (iptr->isn_type == ISN_COMPAREFUNC)\n\t\t    {\n\t\t\tstatus = typval_compare_func(tv1, tv2,\n\t\t\t\t\t\t\t   exprtype, ic, &res);\n\t\t    }\n\t\t    else if (iptr->isn_type == ISN_COMPARESTRING)\n\t\t    {\n\t\t\tstatus = typval_compare_string(tv1, tv2,\n\t\t\t\t\t\t\t   exprtype, ic, &res);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tstatus = typval_compare_blob(tv1, tv2, exprtype, &res);\n\t\t    }\n\t\t    --ectx->ec_stack.ga_len;\n\t\t    clear_tv(tv1);\n\t\t    clear_tv(tv2);\n\t\t    tv1->v_type = VAR_BOOL;\n\t\t    tv1->vval.v_number = res ? VVAL_TRUE : VVAL_FALSE;\n\t\t    if (status == FAIL)\n\t\t\tgoto theend;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_COMPAREANY:\n\t\t{\n\t\t    typval_T\t*tv1 = STACK_TV_BOT(-2);\n\t\t    typval_T\t*tv2 = STACK_TV_BOT(-1);\n\t\t    exprtype_T\texprtype = iptr->isn_arg.op.op_type;\n\t\t    int\t\tic = iptr->isn_arg.op.op_ic;\n\t\t    int\t\tstatus;\n\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    status = typval_compare(tv1, tv2, exprtype, ic);\n\t\t    clear_tv(tv2);\n\t\t    --ectx->ec_stack.ga_len;\n\t\t    if (status == FAIL)\n\t\t\tgoto theend;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_ADDLIST:\n\t    case ISN_ADDBLOB:\n\t\t{\n\t\t    typval_T *tv1 = STACK_TV_BOT(-2);\n\t\t    typval_T *tv2 = STACK_TV_BOT(-1);\n\n\t\t    // add two lists or blobs\n\t\t    if (iptr->isn_type == ISN_ADDLIST)\n\t\t    {\n\t\t\tif (iptr->isn_arg.op.op_type == EXPR_APPEND\n\t\t\t\t\t\t   && tv1->vval.v_list != NULL)\n\t\t\t    list_extend(tv1->vval.v_list, tv2->vval.v_list,\n\t\t\t\t\t\t\t\t\t NULL);\n\t\t\telse\n\t\t\t    eval_addlist(tv1, tv2);\n\t\t    }\n\t\t    else\n\t\t\teval_addblob(tv1, tv2);\n\t\t    clear_tv(tv2);\n\t\t    --ectx->ec_stack.ga_len;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_LISTAPPEND:\n\t\t{\n\t\t    typval_T\t*tv1 = STACK_TV_BOT(-2);\n\t\t    typval_T\t*tv2 = STACK_TV_BOT(-1);\n\t\t    list_T\t*l = tv1->vval.v_list;\n\n\t\t    // add an item to a list\n\t\t    if (l == NULL)\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\temsg(_(e_cannot_add_to_null_list));\n\t\t\tgoto on_error;\n\t\t    }\n\t\t    if (list_append_tv(l, tv2) == FAIL)\n\t\t\tgoto theend;\n\t\t    clear_tv(tv2);\n\t\t    --ectx->ec_stack.ga_len;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_BLOBAPPEND:\n\t\t{\n\t\t    typval_T\t*tv1 = STACK_TV_BOT(-2);\n\t\t    typval_T\t*tv2 = STACK_TV_BOT(-1);\n\t\t    blob_T\t*b = tv1->vval.v_blob;\n\t\t    int\t\terror = FALSE;\n\t\t    varnumber_T n;\n\n\t\t    // add a number to a blob\n\t\t    if (b == NULL)\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\temsg(_(e_cannot_add_to_null_blob));\n\t\t\tgoto on_error;\n\t\t    }\n\t\t    n = tv_get_number_chk(tv2, &error);\n\t\t    if (error)\n\t\t\tgoto on_error;\n\t\t    ga_append(&b->bv_ga, (int)n);\n\t\t    --ectx->ec_stack.ga_len;\n\t\t}\n\t\tbreak;\n\n\t    // Computation with two arguments of unknown type\n\t    case ISN_OPANY:\n\t\t{\n\t\t    typval_T\t*tv1 = STACK_TV_BOT(-2);\n\t\t    typval_T\t*tv2 = STACK_TV_BOT(-1);\n\t\t    varnumber_T\tn1, n2;\n#ifdef FEAT_FLOAT\n\t\t    float_T\tf1 = 0, f2 = 0;\n#endif\n\t\t    int\t\terror = FALSE;\n\n\t\t    if (iptr->isn_arg.op.op_type == EXPR_ADD)\n\t\t    {\n\t\t\tif (tv1->v_type == VAR_LIST && tv2->v_type == VAR_LIST)\n\t\t\t{\n\t\t\t    eval_addlist(tv1, tv2);\n\t\t\t    clear_tv(tv2);\n\t\t\t    --ectx->ec_stack.ga_len;\n\t\t\t    break;\n\t\t\t}\n\t\t\telse if (tv1->v_type == VAR_BLOB\n\t\t\t\t\t\t    && tv2->v_type == VAR_BLOB)\n\t\t\t{\n\t\t\t    eval_addblob(tv1, tv2);\n\t\t\t    clear_tv(tv2);\n\t\t\t    --ectx->ec_stack.ga_len;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n#ifdef FEAT_FLOAT\n\t\t    if (tv1->v_type == VAR_FLOAT)\n\t\t    {\n\t\t\tf1 = tv1->vval.v_float;\n\t\t\tn1 = 0;\n\t\t    }\n\t\t    else\n#endif\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\tn1 = tv_get_number_chk(tv1, &error);\n\t\t\tif (error)\n\t\t\t    goto on_error;\n#ifdef FEAT_FLOAT\n\t\t\tif (tv2->v_type == VAR_FLOAT)\n\t\t\t    f1 = n1;\n#endif\n\t\t    }\n#ifdef FEAT_FLOAT\n\t\t    if (tv2->v_type == VAR_FLOAT)\n\t\t    {\n\t\t\tf2 = tv2->vval.v_float;\n\t\t\tn2 = 0;\n\t\t    }\n\t\t    else\n#endif\n\t\t    {\n\t\t\tn2 = tv_get_number_chk(tv2, &error);\n\t\t\tif (error)\n\t\t\t    goto on_error;\n#ifdef FEAT_FLOAT\n\t\t\tif (tv1->v_type == VAR_FLOAT)\n\t\t\t    f2 = n2;\n#endif\n\t\t    }\n#ifdef FEAT_FLOAT\n\t\t    // if there is a float on either side the result is a float\n\t\t    if (tv1->v_type == VAR_FLOAT || tv2->v_type == VAR_FLOAT)\n\t\t    {\n\t\t\tswitch (iptr->isn_arg.op.op_type)\n\t\t\t{\n\t\t\t    case EXPR_MULT: f1 = f1 * f2; break;\n\t\t\t    case EXPR_DIV:  f1 = f1 / f2; break;\n\t\t\t    case EXPR_SUB:  f1 = f1 - f2; break;\n\t\t\t    case EXPR_ADD:  f1 = f1 + f2; break;\n\t\t\t    default: SOURCING_LNUM = iptr->isn_lnum;\n\t\t\t\t     emsg(_(e_modulus));\n\t\t\t\t     goto on_error;\n\t\t\t}\n\t\t\tclear_tv(tv1);\n\t\t\tclear_tv(tv2);\n\t\t\ttv1->v_type = VAR_FLOAT;\n\t\t\ttv1->vval.v_float = f1;\n\t\t\t--ectx->ec_stack.ga_len;\n\t\t    }\n\t\t    else\n#endif\n\t\t    {\n\t\t\tint failed = FALSE;\n\n\t\t\tswitch (iptr->isn_arg.op.op_type)\n\t\t\t{\n\t\t\t    case EXPR_MULT: n1 = n1 * n2; break;\n\t\t\t    case EXPR_DIV:  n1 = num_divide(n1, n2, &failed);\n\t\t\t\t\t    if (failed)\n\t\t\t\t\t\tgoto on_error;\n\t\t\t\t\t    break;\n\t\t\t    case EXPR_SUB:  n1 = n1 - n2; break;\n\t\t\t    case EXPR_ADD:  n1 = n1 + n2; break;\n\t\t\t    default:\t    n1 = num_modulus(n1, n2, &failed);\n\t\t\t\t\t    if (failed)\n\t\t\t\t\t\tgoto on_error;\n\t\t\t\t\t    break;\n\t\t\t}\n\t\t\tclear_tv(tv1);\n\t\t\tclear_tv(tv2);\n\t\t\ttv1->v_type = VAR_NUMBER;\n\t\t\ttv1->vval.v_number = n1;\n\t\t\t--ectx->ec_stack.ga_len;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    case ISN_CONCAT:\n\t\t{\n\t\t    char_u *str1 = STACK_TV_BOT(-2)->vval.v_string;\n\t\t    char_u *str2 = STACK_TV_BOT(-1)->vval.v_string;\n\t\t    char_u *res;\n\n\t\t    res = concat_str(str1, str2);\n\t\t    clear_tv(STACK_TV_BOT(-2));\n\t\t    clear_tv(STACK_TV_BOT(-1));\n\t\t    --ectx->ec_stack.ga_len;\n\t\t    STACK_TV_BOT(-1)->vval.v_string = res;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_STRINDEX:\n\t    case ISN_STRSLICE:\n\t\t{\n\t\t    int\t\tis_slice = iptr->isn_type == ISN_STRSLICE;\n\t\t    varnumber_T\tn1 = 0, n2;\n\t\t    char_u\t*res;\n\n\t\t    // string index: string is at stack-2, index at stack-1\n\t\t    // string slice: string is at stack-3, first index at\n\t\t    // stack-2, second index at stack-1\n\t\t    if (is_slice)\n\t\t    {\n\t\t\ttv = STACK_TV_BOT(-2);\n\t\t\tn1 = tv->vval.v_number;\n\t\t    }\n\n\t\t    tv = STACK_TV_BOT(-1);\n\t\t    n2 = tv->vval.v_number;\n\n\t\t    ectx->ec_stack.ga_len -= is_slice ? 2 : 1;\n\t\t    tv = STACK_TV_BOT(-1);\n\t\t    if (is_slice)\n\t\t\t// Slice: Select the characters from the string\n\t\t\tres = string_slice(tv->vval.v_string, n1, n2, FALSE);\n\t\t    else\n\t\t\t// Index: The resulting variable is a string of a\n\t\t\t// single character (including composing characters).\n\t\t\t// If the index is too big or negative the result is\n\t\t\t// empty.\n\t\t\tres = char_from_string(tv->vval.v_string, n2);\n\t\t    vim_free(tv->vval.v_string);\n\t\t    tv->vval.v_string = res;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_LISTINDEX:\n\t    case ISN_LISTSLICE:\n\t    case ISN_BLOBINDEX:\n\t    case ISN_BLOBSLICE:\n\t\t{\n\t\t    int\t\tis_slice = iptr->isn_type == ISN_LISTSLICE\n\t\t\t\t\t    || iptr->isn_type == ISN_BLOBSLICE;\n\t\t    int\t\tis_blob = iptr->isn_type == ISN_BLOBINDEX\n\t\t\t\t\t    || iptr->isn_type == ISN_BLOBSLICE;\n\t\t    varnumber_T\tn1, n2;\n\t\t    typval_T\t*val_tv;\n\n\t\t    // list index: list is at stack-2, index at stack-1\n\t\t    // list slice: list is at stack-3, indexes at stack-2 and\n\t\t    // stack-1\n\t\t    // Same for blob.\n\t\t    val_tv = is_slice ? STACK_TV_BOT(-3) : STACK_TV_BOT(-2);\n\n\t\t    tv = STACK_TV_BOT(-1);\n\t\t    n1 = n2 = tv->vval.v_number;\n\t\t    clear_tv(tv);\n\n\t\t    if (is_slice)\n\t\t    {\n\t\t\ttv = STACK_TV_BOT(-2);\n\t\t\tn1 = tv->vval.v_number;\n\t\t\tclear_tv(tv);\n\t\t    }\n\n\t\t    ectx->ec_stack.ga_len -= is_slice ? 2 : 1;\n\t\t    tv = STACK_TV_BOT(-1);\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    if (is_blob)\n\t\t    {\n\t\t\tif (blob_slice_or_index(val_tv->vval.v_blob, is_slice,\n\t\t\t\t\t\t    n1, n2, FALSE, tv) == FAIL)\n\t\t\t    goto on_error;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (list_slice_or_index(val_tv->vval.v_list, is_slice,\n\t\t\t\t\t      n1, n2, FALSE, tv, TRUE) == FAIL)\n\t\t\t    goto on_error;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    case ISN_ANYINDEX:\n\t    case ISN_ANYSLICE:\n\t\t{\n\t\t    int\t\tis_slice = iptr->isn_type == ISN_ANYSLICE;\n\t\t    typval_T\t*var1, *var2;\n\t\t    int\t\tres;\n\n\t\t    // index: composite is at stack-2, index at stack-1\n\t\t    // slice: composite is at stack-3, indexes at stack-2 and\n\t\t    // stack-1\n\t\t    tv = is_slice ? STACK_TV_BOT(-3) : STACK_TV_BOT(-2);\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    if (check_can_index(tv, TRUE, TRUE) == FAIL)\n\t\t\tgoto on_error;\n\t\t    var1 = is_slice ? STACK_TV_BOT(-2) : STACK_TV_BOT(-1);\n\t\t    var2 = is_slice ? STACK_TV_BOT(-1) : NULL;\n\t\t    res = eval_index_inner(tv, is_slice, var1, var2,\n\t\t\t\t\t\t\tFALSE, NULL, -1, TRUE);\n\t\t    clear_tv(var1);\n\t\t    if (is_slice)\n\t\t\tclear_tv(var2);\n\t\t    ectx->ec_stack.ga_len -= is_slice ? 2 : 1;\n\t\t    if (res == FAIL)\n\t\t\tgoto on_error;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_SLICE:\n\t\t{\n\t\t    list_T\t*list;\n\t\t    int\t\tcount = iptr->isn_arg.number;\n\n\t\t    // type will have been checked to be a list\n\t\t    tv = STACK_TV_BOT(-1);\n\t\t    list = tv->vval.v_list;\n\n\t\t    // no error for short list, expect it to be checked earlier\n\t\t    if (list != NULL && list->lv_len >= count)\n\t\t    {\n\t\t\tlist_T\t*newlist = list_slice(list,\n\t\t\t\t\t\t      count, list->lv_len - 1);\n\n\t\t\tif (newlist != NULL)\n\t\t\t{\n\t\t\t    list_unref(list);\n\t\t\t    tv->vval.v_list = newlist;\n\t\t\t    ++newlist->lv_refcount;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    case ISN_GETITEM:\n\t\t{\n\t\t    listitem_T\t*li;\n\t\t    getitem_T\t*gi = &iptr->isn_arg.getitem;\n\n\t\t    // Get list item: list is at stack-1, push item.\n\t\t    // List type and length is checked for when compiling.\n\t\t    tv = STACK_TV_BOT(-1 - gi->gi_with_op);\n\t\t    li = list_find(tv->vval.v_list, gi->gi_index);\n\n\t\t    if (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t\tgoto theend;\n\t\t    ++ectx->ec_stack.ga_len;\n\t\t    copy_tv(&li->li_tv, STACK_TV_BOT(-1));\n\n\t\t    // Useful when used in unpack assignment.  Reset at\n\t\t    // ISN_DROP.\n\t\t    ectx->ec_where.wt_index = gi->gi_index + 1;\n\t\t    ectx->ec_where.wt_variable = TRUE;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_MEMBER:\n\t\t{\n\t\t    dict_T\t*dict;\n\t\t    char_u\t*key;\n\t\t    dictitem_T\t*di;\n\n\t\t    // dict member: dict is at stack-2, key at stack-1\n\t\t    tv = STACK_TV_BOT(-2);\n\t\t    // no need to check for VAR_DICT, CHECKTYPE will check.\n\t\t    dict = tv->vval.v_dict;\n\n\t\t    tv = STACK_TV_BOT(-1);\n\t\t    // no need to check for VAR_STRING, 2STRING will check.\n\t\t    key = tv->vval.v_string;\n\t\t    if (key == NULL)\n\t\t\tkey = (char_u *)\"\";\n\n\t\t    if ((di = dict_find(dict, key, -1)) == NULL)\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\tsemsg(_(e_dictkey), key);\n\n\t\t\t// If :silent! is used we will continue, make sure the\n\t\t\t// stack contents makes sense and the dict stack is\n\t\t\t// updated.\n\t\t\tclear_tv(tv);\n\t\t\t--ectx->ec_stack.ga_len;\n\t\t\ttv = STACK_TV_BOT(-1);\n\t\t\t(void) dict_stack_save(tv);\n\t\t\ttv->v_type = VAR_NUMBER;\n\t\t\ttv->vval.v_number = 0;\n\t\t\tgoto on_fatal_error;\n\t\t    }\n\t\t    clear_tv(tv);\n\t\t    --ectx->ec_stack.ga_len;\n\t\t    // Put the dict used on the dict stack, it might be used by\n\t\t    // a dict function later.\n\t\t    tv = STACK_TV_BOT(-1);\n\t\t    if (dict_stack_save(tv) == FAIL)\n\t\t\tgoto on_fatal_error;\n\t\t    copy_tv(&di->di_tv, tv);\n\t\t}\n\t\tbreak;\n\n\t    // dict member with string key\n\t    case ISN_STRINGMEMBER:\n\t\t{\n\t\t    dict_T\t*dict;\n\t\t    dictitem_T\t*di;\n\n\t\t    tv = STACK_TV_BOT(-1);\n\t\t    if (tv->v_type != VAR_DICT || tv->vval.v_dict == NULL)\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\temsg(_(e_dictreq));\n\t\t\tgoto on_error;\n\t\t    }\n\t\t    dict = tv->vval.v_dict;\n\n\t\t    if ((di = dict_find(dict, iptr->isn_arg.string, -1))\n\t\t\t\t\t\t\t\t       == NULL)\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\tsemsg(_(e_dictkey), iptr->isn_arg.string);\n\t\t\tgoto on_error;\n\t\t    }\n\t\t    // Put the dict used on the dict stack, it might be used by\n\t\t    // a dict function later.\n\t\t    if (dict_stack_save(tv) == FAIL)\n\t\t\tgoto on_fatal_error;\n\n\t\t    copy_tv(&di->di_tv, tv);\n\t\t}\n\t\tbreak;\n\n\t    case ISN_CLEARDICT:\n\t\tdict_stack_drop();\n\t\tbreak;\n\n\t    case ISN_USEDICT:\n\t\t{\n\t\t    typval_T *dict_tv = dict_stack_get_tv();\n\n\t\t    // Turn \"dict.Func\" into a partial for \"Func\" bound to\n\t\t    // \"dict\".  Don't do this when \"Func\" is already a partial\n\t\t    // that was bound explicitly (pt_auto is FALSE).\n\t\t    tv = STACK_TV_BOT(-1);\n\t\t    if (dict_tv != NULL\n\t\t\t    && dict_tv->v_type == VAR_DICT\n\t\t\t    && dict_tv->vval.v_dict != NULL\n\t\t\t    && (tv->v_type == VAR_FUNC\n\t\t\t\t|| (tv->v_type == VAR_PARTIAL\n\t\t\t\t    && (tv->vval.v_partial->pt_auto\n\t\t\t\t     || tv->vval.v_partial->pt_dict == NULL))))\n\t\t    dict_tv->vval.v_dict =\n\t\t\t\t\tmake_partial(dict_tv->vval.v_dict, tv);\n\t\t    dict_stack_drop();\n\t\t}\n\t\tbreak;\n\n\t    case ISN_NEGATENR:\n\t\ttv = STACK_TV_BOT(-1);\n\t\tif (tv->v_type != VAR_NUMBER\n#ifdef FEAT_FLOAT\n\t\t\t&& tv->v_type != VAR_FLOAT\n#endif\n\t\t\t)\n\t\t{\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    emsg(_(e_number_expected));\n\t\t    goto on_error;\n\t\t}\n#ifdef FEAT_FLOAT\n\t\tif (tv->v_type == VAR_FLOAT)\n\t\t    tv->vval.v_float = -tv->vval.v_float;\n\t\telse\n#endif\n\t\t    tv->vval.v_number = -tv->vval.v_number;\n\t\tbreak;\n\n\t    case ISN_CHECKNR:\n\t\t{\n\t\t    int\t\terror = FALSE;\n\n\t\t    tv = STACK_TV_BOT(-1);\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    if (check_not_string(tv) == FAIL)\n\t\t\tgoto on_error;\n\t\t    (void)tv_get_number_chk(tv, &error);\n\t\t    if (error)\n\t\t\tgoto on_error;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_CHECKTYPE:\n\t\t{\n\t\t    checktype_T *ct = &iptr->isn_arg.type;\n\n\t\t    tv = STACK_TV_BOT((int)ct->ct_off);\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    if (!ectx->ec_where.wt_variable)\n\t\t\tectx->ec_where.wt_index = ct->ct_arg_idx;\n\t\t    if (check_typval_type(ct->ct_type, tv, ectx->ec_where)\n\t\t\t\t\t\t\t\t       == FAIL)\n\t\t\tgoto on_error;\n\t\t    if (!ectx->ec_where.wt_variable)\n\t\t\tectx->ec_where.wt_index = 0;\n\n\t\t    // number 0 is FALSE, number 1 is TRUE\n\t\t    if (tv->v_type == VAR_NUMBER\n\t\t\t    && ct->ct_type->tt_type == VAR_BOOL\n\t\t\t    && (tv->vval.v_number == 0\n\t\t\t\t\t\t|| tv->vval.v_number == 1))\n\t\t    {\n\t\t\ttv->v_type = VAR_BOOL;\n\t\t\ttv->vval.v_number = tv->vval.v_number\n\t\t\t\t\t\t      ? VVAL_TRUE : VVAL_FALSE;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    case ISN_CHECKLEN:\n\t\t{\n\t\t    int\t    min_len = iptr->isn_arg.checklen.cl_min_len;\n\t\t    list_T  *list = NULL;\n\n\t\t    tv = STACK_TV_BOT(-1);\n\t\t    if (tv->v_type == VAR_LIST)\n\t\t\t    list = tv->vval.v_list;\n\t\t    if (list == NULL || list->lv_len < min_len\n\t\t\t    || (list->lv_len > min_len\n\t\t\t\t\t&& !iptr->isn_arg.checklen.cl_more_OK))\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\tsemsg(_(e_expected_nr_items_but_got_nr),\n\t\t\t\t     min_len, list == NULL ? 0 : list->lv_len);\n\t\t\tgoto on_error;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    case ISN_SETTYPE:\n\t\t{\n\t\t    checktype_T *ct = &iptr->isn_arg.type;\n\n\t\t    tv = STACK_TV_BOT(-1);\n\t\t    if (tv->v_type == VAR_DICT && tv->vval.v_dict != NULL)\n\t\t    {\n\t\t\tfree_type(tv->vval.v_dict->dv_type);\n\t\t\ttv->vval.v_dict->dv_type = alloc_type(ct->ct_type);\n\t\t    }\n\t\t    else if (tv->v_type == VAR_LIST && tv->vval.v_list != NULL)\n\t\t    {\n\t\t\tfree_type(tv->vval.v_list->lv_type);\n\t\t\ttv->vval.v_list->lv_type = alloc_type(ct->ct_type);\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    case ISN_2BOOL:\n\t    case ISN_COND2BOOL:\n\t\t{\n\t\t    int n;\n\t\t    int error = FALSE;\n\n\t\t    if (iptr->isn_type == ISN_2BOOL)\n\t\t    {\n\t\t\ttv = STACK_TV_BOT(iptr->isn_arg.tobool.offset);\n\t\t\tn = tv2bool(tv);\n\t\t\tif (iptr->isn_arg.tobool.invert)\n\t\t\t    n = !n;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\ttv = STACK_TV_BOT(-1);\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\tn = tv_get_bool_chk(tv, &error);\n\t\t\tif (error)\n\t\t\t    goto on_error;\n\t\t    }\n\t\t    clear_tv(tv);\n\t\t    tv->v_type = VAR_BOOL;\n\t\t    tv->vval.v_number = n ? VVAL_TRUE : VVAL_FALSE;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_2STRING:\n\t    case ISN_2STRING_ANY:\n\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\tif (do_2string(STACK_TV_BOT(iptr->isn_arg.tostring.offset),\n\t\t\t\tiptr->isn_type == ISN_2STRING_ANY,\n\t\t\t\t      iptr->isn_arg.tostring.tolerant) == FAIL)\n\t\t\t    goto on_error;\n\t\tbreak;\n\n\t    case ISN_RANGE:\n\t\t{\n\t\t    exarg_T\tea;\n\t\t    char\t*errormsg;\n\n\t\t    ea.line2 = 0;\n\t\t    ea.addr_count = 0;\n\t\t    ea.addr_type = ADDR_LINES;\n\t\t    ea.cmd = iptr->isn_arg.string;\n\t\t    ea.skip = FALSE;\n\t\t    if (parse_cmd_address(&ea, &errormsg, FALSE) == FAIL)\n\t\t\tgoto on_error;\n\n\t\t    if (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t\tgoto theend;\n\t\t    ++ectx->ec_stack.ga_len;\n\t\t    tv = STACK_TV_BOT(-1);\n\t\t    tv->v_type = VAR_NUMBER;\n\t\t    tv->v_lock = 0;\n\t\t    if (ea.addr_count == 0)\n\t\t\ttv->vval.v_number = curwin->w_cursor.lnum;\n\t\t    else\n\t\t\ttv->vval.v_number = ea.line2;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_PUT:\n\t\t{\n\t\t    int\t\tregname = iptr->isn_arg.put.put_regname;\n\t\t    linenr_T\tlnum = iptr->isn_arg.put.put_lnum;\n\t\t    char_u\t*expr = NULL;\n\t\t    int\t\tdir = FORWARD;\n\n\t\t    if (lnum < -2)\n\t\t    {\n\t\t\t// line number was put on the stack by ISN_RANGE\n\t\t\ttv = STACK_TV_BOT(-1);\n\t\t\tcurwin->w_cursor.lnum = tv->vval.v_number;\n\t\t\tif (lnum == LNUM_VARIABLE_RANGE_ABOVE)\n\t\t\t    dir = BACKWARD;\n\t\t\t--ectx->ec_stack.ga_len;\n\t\t    }\n\t\t    else if (lnum == -2)\n\t\t\t// :put! above cursor\n\t\t\tdir = BACKWARD;\n\t\t    else if (lnum >= 0)\n\t\t\tcurwin->w_cursor.lnum = iptr->isn_arg.put.put_lnum;\n\n\t\t    if (regname == '=')\n\t\t    {\n\t\t\ttv = STACK_TV_BOT(-1);\n\t\t\tif (tv->v_type == VAR_STRING)\n\t\t\t    expr = tv->vval.v_string;\n\t\t\telse\n\t\t\t{\n\t\t\t    expr = typval2string(tv, TRUE); // allocates value\n\t\t\t    clear_tv(tv);\n\t\t\t}\n\t\t\t--ectx->ec_stack.ga_len;\n\t\t    }\n\t\t    check_cursor();\n\t\t    do_put(regname, expr, dir, 1L, PUT_LINE|PUT_CURSLINE);\n\t\t    vim_free(expr);\n\t\t}\n\t\tbreak;\n\n\t    case ISN_CMDMOD:\n\t\tectx->ec_funclocal.floc_save_cmdmod = cmdmod;\n\t\tectx->ec_funclocal.floc_restore_cmdmod = TRUE;\n\t\tectx->ec_funclocal.floc_restore_cmdmod_stacklen =\n\t\t\t\t\t\t\t ectx->ec_stack.ga_len;\n\t\tcmdmod = *iptr->isn_arg.cmdmod.cf_cmdmod;\n\t\tapply_cmdmod(&cmdmod);\n\t\tbreak;\n\n\t    case ISN_CMDMOD_REV:\n\t\t// filter regprog is owned by the instruction, don't free it\n\t\tcmdmod.cmod_filter_regmatch.regprog = NULL;\n\t\tundo_cmdmod(&cmdmod);\n\t\tcmdmod = ectx->ec_funclocal.floc_save_cmdmod;\n\t\tectx->ec_funclocal.floc_restore_cmdmod = FALSE;\n\t\tbreak;\n\n\t    case ISN_UNPACK:\n\t\t{\n\t\t    int\t\tcount = iptr->isn_arg.unpack.unp_count;\n\t\t    int\t\tsemicolon = iptr->isn_arg.unpack.unp_semicolon;\n\t\t    list_T\t*l;\n\t\t    listitem_T\t*li;\n\t\t    int\t\ti;\n\n\t\t    // Check there is a valid list to unpack.\n\t\t    tv = STACK_TV_BOT(-1);\n\t\t    if (tv->v_type != VAR_LIST)\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\temsg(_(e_for_argument_must_be_sequence_of_lists));\n\t\t\tgoto on_error;\n\t\t    }\n\t\t    l = tv->vval.v_list;\n\t\t    if (l == NULL\n\t\t\t\t|| l->lv_len < (semicolon ? count - 1 : count))\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\temsg(_(e_list_value_does_not_have_enough_items));\n\t\t\tgoto on_error;\n\t\t    }\n\t\t    else if (!semicolon && l->lv_len > count)\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\temsg(_(e_list_value_has_more_items_than_targets));\n\t\t\tgoto on_error;\n\t\t    }\n\n\t\t    CHECK_LIST_MATERIALIZE(l);\n\t\t    if (GA_GROW_FAILS(&ectx->ec_stack, count - 1))\n\t\t\tgoto theend;\n\t\t    ectx->ec_stack.ga_len += count - 1;\n\n\t\t    // Variable after semicolon gets a list with the remaining\n\t\t    // items.\n\t\t    if (semicolon)\n\t\t    {\n\t\t\tlist_T\t*rem_list =\n\t\t\t\t  list_alloc_with_items(l->lv_len - count + 1);\n\n\t\t\tif (rem_list == NULL)\n\t\t\t    goto theend;\n\t\t\ttv = STACK_TV_BOT(-count);\n\t\t\ttv->vval.v_list = rem_list;\n\t\t\t++rem_list->lv_refcount;\n\t\t\ttv->v_lock = 0;\n\t\t\tli = l->lv_first;\n\t\t\tfor (i = 0; i < count - 1; ++i)\n\t\t\t    li = li->li_next;\n\t\t\tfor (i = 0; li != NULL; ++i)\n\t\t\t{\n\t\t\t    list_set_item(rem_list, i, &li->li_tv);\n\t\t\t    li = li->li_next;\n\t\t\t}\n\t\t\t--count;\n\t\t    }\n\n\t\t    // Produce the values in reverse order, first item last.\n\t\t    li = l->lv_first;\n\t\t    for (i = 0; i < count; ++i)\n\t\t    {\n\t\t\ttv = STACK_TV_BOT(-i - 1);\n\t\t\tcopy_tv(&li->li_tv, tv);\n\t\t\tli = li->li_next;\n\t\t    }\n\n\t\t    list_unref(l);\n\t\t}\n\t\tbreak;\n\n\t    case ISN_PROF_START:\n\t    case ISN_PROF_END:\n\t\t{\n#ifdef FEAT_PROFILE\n\t\t    funccall_T cookie;\n\t\t    ufunc_T\t    *cur_ufunc =\n\t\t\t\t    (((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t       + ectx->ec_dfunc_idx)->df_ufunc;\n\n\t\t    cookie.func = cur_ufunc;\n\t\t    if (iptr->isn_type == ISN_PROF_START)\n\t\t    {\n\t\t\tfunc_line_start(&cookie, iptr->isn_lnum);\n\t\t\t// if we get here the instruction is executed\n\t\t\tfunc_line_exec(&cookie);\n\t\t    }\n\t\t    else\n\t\t\tfunc_line_end(&cookie);\n#endif\n\t\t}\n\t\tbreak;\n\n\t    case ISN_DEBUG:\n\t\thandle_debug(iptr, ectx);\n\t\tbreak;\n\n\t    case ISN_SHUFFLE:\n\t\t{\n\t\t    typval_T\ttmp_tv;\n\t\t    int\t\titem = iptr->isn_arg.shuffle.shfl_item;\n\t\t    int\t\tup = iptr->isn_arg.shuffle.shfl_up;\n\n\t\t    tmp_tv = *STACK_TV_BOT(-item);\n\t\t    for ( ; up > 0 && item > 1; --up)\n\t\t    {\n\t\t\t*STACK_TV_BOT(-item) = *STACK_TV_BOT(-item + 1);\n\t\t\t--item;\n\t\t    }\n\t\t    *STACK_TV_BOT(-item) = tmp_tv;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_DROP:\n\t\t--ectx->ec_stack.ga_len;\n\t\tclear_tv(STACK_TV_BOT(0));\n\t\tectx->ec_where.wt_index = 0;\n\t\tectx->ec_where.wt_variable = FALSE;\n\t\tbreak;\n\t}\n\tcontinue;\n\nfunc_return:\n\t// Restore previous function. If the frame pointer is where we started\n\t// then there is none and we are done.\n\tif (ectx->ec_frame_idx == ectx->ec_initial_frame_idx)\n\t    goto done;\n\n\tif (func_return(ectx) == FAIL)\n\t    // only fails when out of memory\n\t    goto theend;\n\tcontinue;\n\non_error:\n\t// Jump here for an error that does not require aborting execution.\n\t// If \"emsg_silent\" is set then ignore the error, unless it was set\n\t// when calling the function.\n\tif (did_emsg_cumul + did_emsg == ectx->ec_did_emsg_before\n\t\t\t\t\t   && emsg_silent && did_emsg_def == 0)\n\t{\n\t    // If a sequence of instructions causes an error while \":silent!\"\n\t    // was used, restore the stack length and jump ahead to restoring\n\t    // the cmdmod.\n\t    if (ectx->ec_funclocal.floc_restore_cmdmod)\n\t    {\n\t\twhile (ectx->ec_stack.ga_len\n\t\t\t     > ectx->ec_funclocal.floc_restore_cmdmod_stacklen)\n\t\t{\n\t\t    --ectx->ec_stack.ga_len;\n\t\t    clear_tv(STACK_TV_BOT(0));\n\t\t}\n\t\twhile (ectx->ec_instr[ectx->ec_iidx].isn_type != ISN_CMDMOD_REV)\n\t\t    ++ectx->ec_iidx;\n\t    }\n\t    continue;\n\t}\non_fatal_error:\n\t// Jump here for an error that messes up the stack.\n\t// If we are not inside a try-catch started here, abort execution.\n\tif (trylevel <= ectx->ec_trylevel_at_start)\n\t    goto theend;\n    }\n\ndone:\n    ret = OK;\ntheend:\n    dict_stack_clear(dict_stack_len_at_start);\n    ectx->ec_trylevel_at_start = save_trylevel_at_start;\n    return ret;\n}\n\n/*\n * Execute the instructions from a VAR_INSTR typeval and put the result in\n * \"rettv\".\n * Return OK or FAIL.\n */\n    int\nexe_typval_instr(typval_T *tv, typval_T *rettv)\n{\n    ectx_T\t*ectx = tv->vval.v_instr->instr_ectx;\n    isn_T\t*save_instr = ectx->ec_instr;\n    int\t\tsave_iidx = ectx->ec_iidx;\n    int\t\tres;\n\n    ectx->ec_instr = tv->vval.v_instr->instr_instr;\n    res = exec_instructions(ectx);\n    if (res == OK)\n    {\n\t*rettv = *STACK_TV_BOT(-1);\n\t--ectx->ec_stack.ga_len;\n    }\n\n    ectx->ec_instr = save_instr;\n    ectx->ec_iidx = save_iidx;\n\n    return res;\n}\n\n/*\n * Execute the instructions from an ISN_SUBSTITUTE command, which are in\n * \"substitute_instr\".\n */\n    char_u *\nexe_substitute_instr(void)\n{\n    ectx_T\t*ectx = substitute_instr->subs_ectx;\n    isn_T\t*save_instr = ectx->ec_instr;\n    int\t\tsave_iidx = ectx->ec_iidx;\n    char_u\t*res;\n\n    ectx->ec_instr = substitute_instr->subs_instr;\n    if (exec_instructions(ectx) == OK)\n    {\n\ttypval_T *tv = STACK_TV_BOT(-1);\n\n\tres = typval2string(tv, TRUE);\n\t--ectx->ec_stack.ga_len;\n\tclear_tv(tv);\n    }\n    else\n    {\n\tsubstitute_instr->subs_status = FAIL;\n\tres = vim_strsave((char_u *)\"\");\n    }\n\n    ectx->ec_instr = save_instr;\n    ectx->ec_iidx = save_iidx;\n\n    return res;\n}\n\n/*\n * Call a \"def\" function from old Vim script.\n * Return OK or FAIL.\n */\n    int\ncall_def_function(\n    ufunc_T\t*ufunc,\n    int\t\targc_arg,\t// nr of arguments\n    typval_T\t*argv,\t\t// arguments\n    partial_T\t*partial,\t// optional partial for context\n    typval_T\t*rettv)\t\t// return value\n{\n    ectx_T\tectx;\t\t// execution context\n    int\t\targc = argc_arg;\n    typval_T\t*tv;\n    int\t\tidx;\n    int\t\tret = FAIL;\n    int\t\tdefcount = ufunc->uf_args.ga_len - argc;\n    sctx_T\tsave_current_sctx = current_sctx;\n    int\t\tdid_emsg_before = did_emsg_cumul + did_emsg;\n    int\t\tsave_suppress_errthrow = suppress_errthrow;\n    msglist_T\t**saved_msg_list = NULL;\n    msglist_T\t*private_msg_list = NULL;\n    int\t\tsave_emsg_silent_def = emsg_silent_def;\n    int\t\tsave_did_emsg_def = did_emsg_def;\n    int\t\torig_funcdepth;\n    int\t\torig_nesting_level = ex_nesting_level;\n\n// Get pointer to item in the stack.\n#undef STACK_TV\n#define STACK_TV(idx) (((typval_T *)ectx.ec_stack.ga_data) + idx)\n\n// Get pointer to item at the bottom of the stack, -1 is the bottom.\n#undef STACK_TV_BOT\n#define STACK_TV_BOT(idx) (((typval_T *)ectx.ec_stack.ga_data) + ectx.ec_stack.ga_len + idx)\n\n// Get pointer to a local variable on the stack.  Negative for arguments.\n#undef STACK_TV_VAR\n#define STACK_TV_VAR(idx) (((typval_T *)ectx.ec_stack.ga_data) + ectx.ec_frame_idx + STACK_FRAME_SIZE + idx)\n\n    // Update uf_has_breakpoint if needed.\n    update_has_breakpoint(ufunc);\n\n    if (ufunc->uf_def_status == UF_NOT_COMPILED\n\t    || ufunc->uf_def_status == UF_COMPILE_ERROR\n\t    || (func_needs_compiling(ufunc, COMPILE_TYPE(ufunc))\n\t\t&& compile_def_function(ufunc, FALSE, COMPILE_TYPE(ufunc), NULL)\n\t\t\t\t\t\t\t\t      == FAIL))\n    {\n\tif (did_emsg_cumul + did_emsg == did_emsg_before)\n\t    semsg(_(e_function_is_not_compiled_str),\n\t\t\t\t\t\t   printable_func_name(ufunc));\n\treturn FAIL;\n    }\n\n    {\n\t// Check the function was really compiled.\n\tdfunc_T\t*dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t + ufunc->uf_dfunc_idx;\n\tif (INSTRUCTIONS(dfunc) == NULL)\n\t{\n\t    iemsg(\"using call_def_function() on not compiled function\");\n\t    return FAIL;\n\t}\n    }\n\n    // If depth of calling is getting too high, don't execute the function.\n    orig_funcdepth = funcdepth_get();\n    if (funcdepth_increment() == FAIL)\n\treturn FAIL;\n\n    CLEAR_FIELD(ectx);\n    ectx.ec_dfunc_idx = ufunc->uf_dfunc_idx;\n    ga_init2(&ectx.ec_stack, sizeof(typval_T), 500);\n    if (GA_GROW_FAILS(&ectx.ec_stack, 20))\n    {\n\tfuncdepth_decrement();\n\treturn FAIL;\n    }\n    ga_init2(&ectx.ec_trystack, sizeof(trycmd_T), 10);\n    ga_init2(&ectx.ec_funcrefs, sizeof(partial_T *), 10);\n    ectx.ec_did_emsg_before = did_emsg_before;\n    ++ex_nesting_level;\n\n    idx = argc - ufunc->uf_args.ga_len;\n    if (idx > 0 && ufunc->uf_va_name == NULL)\n    {\n\tif (idx == 1)\n\t    emsg(_(e_one_argument_too_many));\n\telse\n\t    semsg(_(e_nr_arguments_too_many), idx);\n\tgoto failed_early;\n    }\n    idx = argc - ufunc->uf_args.ga_len + ufunc->uf_def_args.ga_len;\n    if (idx < 0)\n    {\n\tif (idx == -1)\n\t    emsg(_(e_one_argument_too_few));\n\telse\n\t    semsg(_(e_nr_arguments_too_few), -idx);\n\tgoto failed_early;\n    }\n\n    // Put arguments on the stack, but no more than what the function expects.\n    // A lambda can be called with more arguments than it uses.\n    for (idx = 0; idx < argc\n\t    && (ufunc->uf_va_name != NULL || idx < ufunc->uf_args.ga_len);\n\t\t\t\t\t\t\t\t\t ++idx)\n    {\n\tif (idx >= ufunc->uf_args.ga_len - ufunc->uf_def_args.ga_len\n\t\t&& argv[idx].v_type == VAR_SPECIAL\n\t\t&& argv[idx].vval.v_number == VVAL_NONE)\n\t{\n\t    // Use the default value.\n\t    STACK_TV_BOT(0)->v_type = VAR_UNKNOWN;\n\t}\n\telse\n\t{\n\t    if (ufunc->uf_arg_types != NULL && idx < ufunc->uf_args.ga_len\n\t\t    && check_typval_arg_type(\n\t\t\tufunc->uf_arg_types[idx], &argv[idx],\n\t\t\t\t\t\t\tNULL, idx + 1) == FAIL)\n\t\tgoto failed_early;\n\t    copy_tv(&argv[idx], STACK_TV_BOT(0));\n\t}\n\t++ectx.ec_stack.ga_len;\n    }\n\n    // Turn varargs into a list.  Empty list if no args.\n    if (ufunc->uf_va_name != NULL)\n    {\n\tint vararg_count = argc - ufunc->uf_args.ga_len;\n\n\tif (vararg_count < 0)\n\t    vararg_count = 0;\n\telse\n\t    argc -= vararg_count;\n\tif (exe_newlist(vararg_count, &ectx) == FAIL)\n\t    goto failed_early;\n\n\t// Check the type of the list items.\n\ttv = STACK_TV_BOT(-1);\n\tif (ufunc->uf_va_type != NULL\n\t\t&& ufunc->uf_va_type != &t_list_any\n\t\t&& ufunc->uf_va_type->tt_member != &t_any\n\t\t&& tv->vval.v_list != NULL)\n\t{\n\t    type_T\t*expected = ufunc->uf_va_type->tt_member;\n\t    listitem_T\t*li = tv->vval.v_list->lv_first;\n\n\t    for (idx = 0; idx < vararg_count; ++idx)\n\t    {\n\t\tif (check_typval_arg_type(expected, &li->li_tv,\n\t\t\t\t\t\t NULL, argc + idx + 1) == FAIL)\n\t\t    goto failed_early;\n\t\tli = li->li_next;\n\t    }\n\t}\n\n\tif (defcount > 0)\n\t    // Move varargs list to below missing default arguments.\n\t    *STACK_TV_BOT(defcount - 1) = *STACK_TV_BOT(-1);\n\t--ectx.ec_stack.ga_len;\n    }\n\n    // Make space for omitted arguments, will store default value below.\n    // Any varargs list goes after them.\n    if (defcount > 0)\n\tfor (idx = 0; idx < defcount; ++idx)\n\t{\n\t    STACK_TV_BOT(0)->v_type = VAR_UNKNOWN;\n\t    ++ectx.ec_stack.ga_len;\n\t}\n    if (ufunc->uf_va_name != NULL)\n\t++ectx.ec_stack.ga_len;\n\n    // Frame pointer points to just after arguments.\n    ectx.ec_frame_idx = ectx.ec_stack.ga_len;\n    ectx.ec_initial_frame_idx = ectx.ec_frame_idx;\n\n    {\n\tdfunc_T\t*dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t + ufunc->uf_dfunc_idx;\n\tufunc_T *base_ufunc = dfunc->df_ufunc;\n\n\t// \"uf_partial\" is on the ufunc that \"df_ufunc\" points to, as is done\n\t// by copy_func().\n\tif (partial != NULL || base_ufunc->uf_partial != NULL)\n\t{\n\t    ectx.ec_outer_ref = ALLOC_CLEAR_ONE(outer_ref_T);\n\t    if (ectx.ec_outer_ref == NULL)\n\t\tgoto failed_early;\n\t    if (partial != NULL)\n\t    {\n\t\tif (partial->pt_outer.out_stack == NULL && current_ectx != NULL)\n\t\t{\n\t\t    if (current_ectx->ec_outer_ref != NULL\n\t\t\t    && current_ectx->ec_outer_ref->or_outer != NULL)\n\t\t\tectx.ec_outer_ref->or_outer =\n\t\t\t\t\t  current_ectx->ec_outer_ref->or_outer;\n\t\t}\n\t\telse\n\t\t{\n\t\t    ectx.ec_outer_ref->or_outer = &partial->pt_outer;\n\t\t    ++partial->pt_refcount;\n\t\t    ectx.ec_outer_ref->or_partial = partial;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tectx.ec_outer_ref->or_outer = &base_ufunc->uf_partial->pt_outer;\n\t\t++base_ufunc->uf_partial->pt_refcount;\n\t\tectx.ec_outer_ref->or_partial = base_ufunc->uf_partial;\n\t    }\n\t}\n    }\n\n    // dummy frame entries\n    for (idx = 0; idx < STACK_FRAME_SIZE; ++idx)\n    {\n\tSTACK_TV(ectx.ec_stack.ga_len)->v_type = VAR_UNKNOWN;\n\t++ectx.ec_stack.ga_len;\n    }\n\n    {\n\t// Reserve space for local variables and any closure reference count.\n\tdfunc_T\t*dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t + ufunc->uf_dfunc_idx;\n\n\t// Initialize variables to zero.  That avoids having to generate\n\t// initializing instructions for \"var nr: number\", \"var x: any\", etc.\n\tfor (idx = 0; idx < dfunc->df_varcount; ++idx)\n\t{\n\t    STACK_TV_VAR(idx)->v_type = VAR_NUMBER;\n\t    STACK_TV_VAR(idx)->vval.v_number = 0;\n\t}\n\tectx.ec_stack.ga_len += dfunc->df_varcount;\n\tif (dfunc->df_has_closure)\n\t{\n\t    STACK_TV_VAR(idx)->v_type = VAR_NUMBER;\n\t    STACK_TV_VAR(idx)->vval.v_number = 0;\n\t    ++ectx.ec_stack.ga_len;\n\t}\n\n\tectx.ec_instr = INSTRUCTIONS(dfunc);\n    }\n\n    // Following errors are in the function, not the caller.\n    // Commands behave like vim9script.\n    estack_push_ufunc(ufunc, 1);\n    current_sctx = ufunc->uf_script_ctx;\n    current_sctx.sc_version = SCRIPT_VERSION_VIM9;\n\n    // Use a specific location for storing error messages to be converted to an\n    // exception.\n    saved_msg_list = msg_list;\n    msg_list = &private_msg_list;\n\n    // Do turn errors into exceptions.\n    suppress_errthrow = FALSE;\n\n    // Do not delete the function while executing it.\n    ++ufunc->uf_calls;\n\n    // When \":silent!\" was used before calling then we still abort the\n    // function.  If \":silent!\" is used in the function then we don't.\n    emsg_silent_def = emsg_silent;\n    did_emsg_def = 0;\n\n    ectx.ec_where.wt_index = 0;\n    ectx.ec_where.wt_variable = FALSE;\n\n    // Execute the instructions until done.\n    ret = exec_instructions(&ectx);\n    if (ret == OK)\n    {\n\t// function finished, get result from the stack.\n\tif (ufunc->uf_ret_type == &t_void)\n\t{\n\t    rettv->v_type = VAR_VOID;\n\t}\n\telse\n\t{\n\t    tv = STACK_TV_BOT(-1);\n\t    *rettv = *tv;\n\t    tv->v_type = VAR_UNKNOWN;\n\t}\n    }\n\n    // When failed need to unwind the call stack.\n    while (ectx.ec_frame_idx != ectx.ec_initial_frame_idx)\n\tfunc_return(&ectx);\n\n    // Deal with any remaining closures, they may be in use somewhere.\n    if (ectx.ec_funcrefs.ga_len > 0)\n    {\n\thandle_closure_in_use(&ectx, FALSE);\n\tga_clear(&ectx.ec_funcrefs);\n    }\n\n    estack_pop();\n    current_sctx = save_current_sctx;\n\n    if (--ufunc->uf_calls <= 0 && ufunc->uf_refcount <= 0)\n\t// Function was unreferenced while being used, free it now.\n\tfunc_clear_free(ufunc, FALSE);\n\n    if (*msg_list != NULL && saved_msg_list != NULL)\n    {\n\tmsglist_T **plist = saved_msg_list;\n\n\t// Append entries from the current msg_list (uncaught exceptions) to\n\t// the saved msg_list.\n\twhile (*plist != NULL)\n\t    plist = &(*plist)->next;\n\n\t*plist = *msg_list;\n    }\n    msg_list = saved_msg_list;\n\n    if (ectx.ec_funclocal.floc_restore_cmdmod)\n    {\n\tcmdmod.cmod_filter_regmatch.regprog = NULL;\n\tundo_cmdmod(&cmdmod);\n\tcmdmod = ectx.ec_funclocal.floc_save_cmdmod;\n    }\n    emsg_silent_def = save_emsg_silent_def;\n    did_emsg_def += save_did_emsg_def;\n\nfailed_early:\n    // Free all local variables, but not arguments.\n    for (idx = 0; idx < ectx.ec_stack.ga_len; ++idx)\n\tclear_tv(STACK_TV(idx));\n    ex_nesting_level = orig_nesting_level;\n\n    vim_free(ectx.ec_stack.ga_data);\n    vim_free(ectx.ec_trystack.ga_data);\n    if (ectx.ec_outer_ref != NULL)\n    {\n\tif (ectx.ec_outer_ref->or_outer_allocated)\n\t    vim_free(ectx.ec_outer_ref->or_outer);\n\tpartial_unref(ectx.ec_outer_ref->or_partial);\n\tvim_free(ectx.ec_outer_ref);\n    }\n\n    // Not sure if this is necessary.\n    suppress_errthrow = save_suppress_errthrow;\n\n    if (ret != OK && did_emsg_cumul + did_emsg == did_emsg_before\n\t\t\t\t\t\t\t      && !need_rethrow)\n\tsemsg(_(e_unknown_error_while_executing_str),\n\t\t\t\t\t\t   printable_func_name(ufunc));\n    funcdepth_restore(orig_funcdepth);\n    return ret;\n}\n\n/*\n * List instructions \"instr\" up to \"instr_count\" or until ISN_FINISH.\n * \"ufunc\" has the source lines, NULL for the instructions of ISN_SUBSTITUTE.\n * \"pfx\" is prefixed to every line.\n */\n    static void\nlist_instructions(char *pfx, isn_T *instr, int instr_count, ufunc_T *ufunc)\n{\n    int\t\tline_idx = 0;\n    int\t\tprev_current = 0;\n    int\t\tcurrent;\n    int\t\tdef_arg_idx = 0;\n\n    for (current = 0; current < instr_count; ++current)\n    {\n\tisn_T\t    *iptr = &instr[current];\n\tchar\t    *line;\n\n\tif (ufunc != NULL)\n\t{\n\t    while (line_idx < iptr->isn_lnum\n\t\t\t\t\t  && line_idx < ufunc->uf_lines.ga_len)\n\t    {\n\t\tif (current > prev_current)\n\t\t{\n\t\t    msg_puts(\"\\n\\n\");\n\t\t    prev_current = current;\n\t\t}\n\t\tline = ((char **)ufunc->uf_lines.ga_data)[line_idx++];\n\t\tif (line != NULL)\n\t\t    msg(line);\n\t    }\n\t    if (iptr->isn_type == ISN_JUMP_IF_ARG_SET)\n\t    {\n\t\tint\tfirst_def_arg = ufunc->uf_args.ga_len\n\t\t\t\t\t\t   - ufunc->uf_def_args.ga_len;\n\n\t\tif (def_arg_idx > 0)\n\t\t    msg_puts(\"\\n\\n\");\n\t\tmsg_start();\n\t\tmsg_puts(\"  \");\n\t\tmsg_puts(((char **)(ufunc->uf_args.ga_data))[\n\t\t\t\t\t\t first_def_arg + def_arg_idx]);\n\t\tmsg_puts(\" = \");\n\t\tmsg_puts(((char **)(ufunc->uf_def_args.ga_data))[def_arg_idx++]);\n\t\tmsg_clr_eos();\n\t\tmsg_end();\n\t    }\n\t}\n\n\tswitch (iptr->isn_type)\n\t{\n\t    case ISN_EXEC:\n\t\tsmsg(\"%s%4d EXEC %s\", pfx, current, iptr->isn_arg.string);\n\t\tbreak;\n\t    case ISN_EXEC_SPLIT:\n\t\tsmsg(\"%s%4d EXEC_SPLIT %s\", pfx, current, iptr->isn_arg.string);\n\t\tbreak;\n\t    case ISN_EXECRANGE:\n\t\tsmsg(\"%s%4d EXECRANGE %s\", pfx, current, iptr->isn_arg.string);\n\t\tbreak;\n\t    case ISN_LEGACY_EVAL:\n\t\tsmsg(\"%s%4d EVAL legacy %s\", pfx, current,\n\t\t\t\t\t\t\t iptr->isn_arg.string);\n\t\tbreak;\n\t    case ISN_REDIRSTART:\n\t\tsmsg(\"%s%4d REDIR\", pfx, current);\n\t\tbreak;\n\t    case ISN_REDIREND:\n\t\tsmsg(\"%s%4d REDIR END%s\", pfx, current,\n\t\t\t\t\tiptr->isn_arg.number ? \" append\" : \"\");\n\t\tbreak;\n\t    case ISN_CEXPR_AUCMD:\n#ifdef FEAT_QUICKFIX\n\t\tsmsg(\"%s%4d CEXPR pre %s\", pfx, current,\n\t\t\t\t       cexpr_get_auname(iptr->isn_arg.number));\n#endif\n\t\tbreak;\n\t    case ISN_CEXPR_CORE:\n#ifdef FEAT_QUICKFIX\n\t\t{\n\t\t    cexprref_T\t    *cer = iptr->isn_arg.cexpr.cexpr_ref;\n\n\t\t    smsg(\"%s%4d CEXPR core %s%s \\\"%s\\\"\", pfx, current,\n\t\t\t\t       cexpr_get_auname(cer->cer_cmdidx),\n\t\t\t\t       cer->cer_forceit ? \"!\" : \"\",\n\t\t\t\t       cer->cer_cmdline);\n\t\t}\n#endif\n\t\tbreak;\n\t    case ISN_INSTR:\n\t\t{\n\t\t    smsg(\"%s%4d INSTR\", pfx, current);\n\t\t    list_instructions(\"    \", iptr->isn_arg.instr,\n\t\t\t\t\t\t\t\tINT_MAX, NULL);\n\t\t    msg(\"     -------------\");\n\t\t}\n\t\tbreak;\n\t    case ISN_SUBSTITUTE:\n\t\t{\n\t\t    subs_T *subs = &iptr->isn_arg.subs;\n\n\t\t    smsg(\"%s%4d SUBSTITUTE %s\", pfx, current, subs->subs_cmd);\n\t\t    list_instructions(\"    \", subs->subs_instr, INT_MAX, NULL);\n\t\t    msg(\"     -------------\");\n\t\t}\n\t\tbreak;\n\t    case ISN_EXECCONCAT:\n\t\tsmsg(\"%s%4d EXECCONCAT %lld\", pfx, current,\n\t\t\t\t\t      (varnumber_T)iptr->isn_arg.number);\n\t\tbreak;\n\t    case ISN_ECHO:\n\t\t{\n\t\t    echo_T *echo = &iptr->isn_arg.echo;\n\n\t\t    smsg(\"%s%4d %s %d\", pfx, current,\n\t\t\t    echo->echo_with_white ? \"ECHO\" : \"ECHON\",\n\t\t\t    echo->echo_count);\n\t\t}\n\t\tbreak;\n\t    case ISN_EXECUTE:\n\t\tsmsg(\"%s%4d EXECUTE %lld\", pfx, current,\n\t\t\t\t\t  (varnumber_T)(iptr->isn_arg.number));\n\t\tbreak;\n\t    case ISN_ECHOMSG:\n\t\tsmsg(\"%s%4d ECHOMSG %lld\", pfx, current,\n\t\t\t\t\t  (varnumber_T)(iptr->isn_arg.number));\n\t\tbreak;\n\t    case ISN_ECHOCONSOLE:\n\t\tsmsg(\"%s%4d ECHOCONSOLE %lld\", pfx, current,\n\t\t\t\t\t  (varnumber_T)(iptr->isn_arg.number));\n\t\tbreak;\n\t    case ISN_ECHOERR:\n\t\tsmsg(\"%s%4d ECHOERR %lld\", pfx, current,\n\t\t\t\t\t  (varnumber_T)(iptr->isn_arg.number));\n\t\tbreak;\n\t    case ISN_LOAD:\n\t\t{\n\t\t    if (iptr->isn_arg.number < 0)\n\t\t\tsmsg(\"%s%4d LOAD arg[%lld]\", pfx, current,\n\t\t\t\t(varnumber_T)(iptr->isn_arg.number\n\t\t\t\t\t\t\t  + STACK_FRAME_SIZE));\n\t\t    else\n\t\t\tsmsg(\"%s%4d LOAD $%lld\", pfx, current,\n\t\t\t\t\t  (varnumber_T)(iptr->isn_arg.number));\n\t\t}\n\t\tbreak;\n\t    case ISN_LOADOUTER:\n\t\t{\n\t\t    if (iptr->isn_arg.number < 0)\n\t\t\tsmsg(\"%s%4d LOADOUTER level %d arg[%d]\", pfx, current,\n\t\t\t\tiptr->isn_arg.outer.outer_depth,\n\t\t\t\tiptr->isn_arg.outer.outer_idx\n\t\t\t\t\t\t\t  + STACK_FRAME_SIZE);\n\t\t    else\n\t\t\tsmsg(\"%s%4d LOADOUTER level %d $%d\", pfx, current,\n\t\t\t\t\t      iptr->isn_arg.outer.outer_depth,\n\t\t\t\t\t      iptr->isn_arg.outer.outer_idx);\n\t\t}\n\t\tbreak;\n\t    case ISN_LOADV:\n\t\tsmsg(\"%s%4d LOADV v:%s\", pfx, current,\n\t\t\t\t       get_vim_var_name(iptr->isn_arg.number));\n\t\tbreak;\n\t    case ISN_LOADSCRIPT:\n\t\t{\n\t\t    scriptref_T\t    *sref = iptr->isn_arg.script.scriptref;\n\t\t    scriptitem_T    *si = SCRIPT_ITEM(sref->sref_sid);\n\t\t    svar_T\t    *sv;\n\n\t\t    sv = get_script_svar(sref, -1);\n\t\t    if (sv == NULL)\n\t\t\tsmsg(\"%s%4d LOADSCRIPT [deleted] from %s\",\n\t\t\t\t\t\t    pfx, current, si->sn_name);\n\t\t    else\n\t\t\tsmsg(\"%s%4d LOADSCRIPT %s-%d from %s\", pfx, current,\n\t\t\t\t\t    sv->sv_name,\n\t\t\t\t\t    sref->sref_idx,\n\t\t\t\t\t    si->sn_name);\n\t\t}\n\t\tbreak;\n\t    case ISN_LOADS:\n\t\t{\n\t\t    scriptitem_T *si = SCRIPT_ITEM(\n\t\t\t\t\t       iptr->isn_arg.loadstore.ls_sid);\n\n\t\t    smsg(\"%s%4d LOADS s:%s from %s\", pfx, current,\n\t\t\t\t iptr->isn_arg.loadstore.ls_name, si->sn_name);\n\t\t}\n\t\tbreak;\n\t    case ISN_LOADAUTO:\n\t\tsmsg(\"%s%4d LOADAUTO %s\", pfx, current, iptr->isn_arg.string);\n\t\tbreak;\n\t    case ISN_LOADG:\n\t\tsmsg(\"%s%4d LOADG g:%s\", pfx, current, iptr->isn_arg.string);\n\t\tbreak;\n\t    case ISN_LOADB:\n\t\tsmsg(\"%s%4d LOADB b:%s\", pfx, current, iptr->isn_arg.string);\n\t\tbreak;\n\t    case ISN_LOADW:\n\t\tsmsg(\"%s%4d LOADW w:%s\", pfx, current, iptr->isn_arg.string);\n\t\tbreak;\n\t    case ISN_LOADT:\n\t\tsmsg(\"%s%4d LOADT t:%s\", pfx, current, iptr->isn_arg.string);\n\t\tbreak;\n\t    case ISN_LOADGDICT:\n\t\tsmsg(\"%s%4d LOAD g:\", pfx, current);\n\t\tbreak;\n\t    case ISN_LOADBDICT:\n\t\tsmsg(\"%s%4d LOAD b:\", pfx, current);\n\t\tbreak;\n\t    case ISN_LOADWDICT:\n\t\tsmsg(\"%s%4d LOAD w:\", pfx, current);\n\t\tbreak;\n\t    case ISN_LOADTDICT:\n\t\tsmsg(\"%s%4d LOAD t:\", pfx, current);\n\t\tbreak;\n\t    case ISN_LOADOPT:\n\t\tsmsg(\"%s%4d LOADOPT %s\", pfx, current, iptr->isn_arg.string);\n\t\tbreak;\n\t    case ISN_LOADENV:\n\t\tsmsg(\"%s%4d LOADENV %s\", pfx, current, iptr->isn_arg.string);\n\t\tbreak;\n\t    case ISN_LOADREG:\n\t\tsmsg(\"%s%4d LOADREG @%c\", pfx, current,\n\t\t\t\t\t\t  (int)(iptr->isn_arg.number));\n\t\tbreak;\n\n\t    case ISN_STORE:\n\t\tif (iptr->isn_arg.number < 0)\n\t\t    smsg(\"%s%4d STORE arg[%lld]\", pfx, current,\n\t\t\t\t      iptr->isn_arg.number + STACK_FRAME_SIZE);\n\t\telse\n\t\t    smsg(\"%s%4d STORE $%lld\", pfx, current,\n\t\t\t\t\t\t\t iptr->isn_arg.number);\n\t\tbreak;\n\t    case ISN_STOREOUTER:\n\t\t{\n\t\tif (iptr->isn_arg.number < 0)\n\t\t    smsg(\"%s%4d STOREOUTEr level %d arg[%d]\", pfx, current,\n\t\t\t    iptr->isn_arg.outer.outer_depth,\n\t\t\t    iptr->isn_arg.outer.outer_idx + STACK_FRAME_SIZE);\n\t\telse\n\t\t    smsg(\"%s%4d STOREOUTER level %d $%d\", pfx, current,\n\t\t\t    iptr->isn_arg.outer.outer_depth,\n\t\t\t    iptr->isn_arg.outer.outer_idx);\n\t\t}\n\t\tbreak;\n\t    case ISN_STOREV:\n\t\tsmsg(\"%s%4d STOREV v:%s\", pfx, current,\n\t\t\t\t       get_vim_var_name(iptr->isn_arg.number));\n\t\tbreak;\n\t    case ISN_STOREAUTO:\n\t\tsmsg(\"%s%4d STOREAUTO %s\", pfx, current, iptr->isn_arg.string);\n\t\tbreak;\n\t    case ISN_STOREG:\n\t\tsmsg(\"%s%4d STOREG %s\", pfx, current, iptr->isn_arg.string);\n\t\tbreak;\n\t    case ISN_STOREB:\n\t\tsmsg(\"%s%4d STOREB %s\", pfx, current, iptr->isn_arg.string);\n\t\tbreak;\n\t    case ISN_STOREW:\n\t\tsmsg(\"%s%4d STOREW %s\", pfx, current, iptr->isn_arg.string);\n\t\tbreak;\n\t    case ISN_STORET:\n\t\tsmsg(\"%s%4d STORET %s\", pfx, current, iptr->isn_arg.string);\n\t\tbreak;\n\t    case ISN_STORES:\n\t\t{\n\t\t    scriptitem_T *si = SCRIPT_ITEM(\n\t\t\t\t\t       iptr->isn_arg.loadstore.ls_sid);\n\n\t\t    smsg(\"%s%4d STORES %s in %s\", pfx, current,\n\t\t\t\t iptr->isn_arg.loadstore.ls_name, si->sn_name);\n\t\t}\n\t\tbreak;\n\t    case ISN_STORESCRIPT:\n\t\t{\n\t\t    scriptref_T\t    *sref = iptr->isn_arg.script.scriptref;\n\t\t    scriptitem_T    *si = SCRIPT_ITEM(sref->sref_sid);\n\t\t    svar_T\t    *sv;\n\n\t\t    sv = get_script_svar(sref, -1);\n\t\t    if (sv == NULL)\n\t\t\tsmsg(\"%s%4d STORESCRIPT [deleted] in %s\",\n\t\t\t\t\t\t    pfx, current, si->sn_name);\n\t\t    else\n\t\t\tsmsg(\"%s%4d STORESCRIPT %s-%d in %s\", pfx, current,\n\t\t\t\t\t     sv->sv_name,\n\t\t\t\t\t     sref->sref_idx,\n\t\t\t\t\t     si->sn_name);\n\t\t}\n\t\tbreak;\n\t    case ISN_STOREOPT:\n\t    case ISN_STOREFUNCOPT:\n\t\tsmsg(\"%s%4d %s &%s\", pfx, current,\n\t\t  iptr->isn_type == ISN_STOREOPT ? \"STOREOPT\" : \"STOREFUNCOPT\",\n\t\t\t\t\t       iptr->isn_arg.storeopt.so_name);\n\t\tbreak;\n\t    case ISN_STOREENV:\n\t\tsmsg(\"%s%4d STOREENV $%s\", pfx, current, iptr->isn_arg.string);\n\t\tbreak;\n\t    case ISN_STOREREG:\n\t\tsmsg(\"%s%4d STOREREG @%c\", pfx, current,\n\t\t\t\t\t\t    (int)iptr->isn_arg.number);\n\t\tbreak;\n\t    case ISN_STORENR:\n\t\tsmsg(\"%s%4d STORE %lld in $%d\", pfx, current,\n\t\t\t\tiptr->isn_arg.storenr.stnr_val,\n\t\t\t\tiptr->isn_arg.storenr.stnr_idx);\n\t\tbreak;\n\n\t    case ISN_STOREINDEX:\n\t\tsmsg(\"%s%4d STOREINDEX %s\", pfx, current,\n\t\t\t\t\t  vartype_name(iptr->isn_arg.vartype));\n\t\tbreak;\n\n\t    case ISN_STORERANGE:\n\t\tsmsg(\"%s%4d STORERANGE\", pfx, current);\n\t\tbreak;\n\n\t    // constants\n\t    case ISN_PUSHNR:\n\t\tsmsg(\"%s%4d PUSHNR %lld\", pfx, current,\n\t\t\t\t\t    (varnumber_T)(iptr->isn_arg.number));\n\t\tbreak;\n\t    case ISN_PUSHBOOL:\n\t    case ISN_PUSHSPEC:\n\t\tsmsg(\"%s%4d PUSH %s\", pfx, current,\n\t\t\t\t   get_var_special_name(iptr->isn_arg.number));\n\t\tbreak;\n\t    case ISN_PUSHF:\n#ifdef FEAT_FLOAT\n\t\tsmsg(\"%s%4d PUSHF %g\", pfx, current, iptr->isn_arg.fnumber);\n#endif\n\t\tbreak;\n\t    case ISN_PUSHS:\n\t\tsmsg(\"%s%4d PUSHS \\\"%s\\\"\", pfx, current, iptr->isn_arg.string);\n\t\tbreak;\n\t    case ISN_PUSHBLOB:\n\t\t{\n\t\t    char_u\t*r;\n\t\t    char_u\tnumbuf[NUMBUFLEN];\n\t\t    char_u\t*tofree;\n\n\t\t    r = blob2string(iptr->isn_arg.blob, &tofree, numbuf);\n\t\t    smsg(\"%s%4d PUSHBLOB %s\", pfx, current, r);\n\t\t    vim_free(tofree);\n\t\t}\n\t\tbreak;\n\t    case ISN_PUSHFUNC:\n\t\t{\n\t\t    char *name = (char *)iptr->isn_arg.string;\n\n\t\t    smsg(\"%s%4d PUSHFUNC \\\"%s\\\"\", pfx, current,\n\t\t\t\t\t       name == NULL ? \"[none]\" : name);\n\t\t}\n\t\tbreak;\n\t    case ISN_PUSHCHANNEL:\n#ifdef FEAT_JOB_CHANNEL\n\t\t{\n\t\t    channel_T *channel = iptr->isn_arg.channel;\n\n\t\t    smsg(\"%s%4d PUSHCHANNEL %d\", pfx, current,\n\t\t\t\t\t channel == NULL ? 0 : channel->ch_id);\n\t\t}\n#endif\n\t\tbreak;\n\t    case ISN_PUSHJOB:\n#ifdef FEAT_JOB_CHANNEL\n\t\t{\n\t\t    typval_T\ttv;\n\t\t    char_u\t*name;\n\t\t    char_u\tbuf[NUMBUFLEN];\n\n\t\t    tv.v_type = VAR_JOB;\n\t\t    tv.vval.v_job = iptr->isn_arg.job;\n\t\t    name = job_to_string_buf(&tv, buf);\n\t\t    smsg(\"%s%4d PUSHJOB \\\"%s\\\"\", pfx, current, name);\n\t\t}\n#endif\n\t\tbreak;\n\t    case ISN_PUSHEXC:\n\t\tsmsg(\"%s%4d PUSH v:exception\", pfx, current);\n\t\tbreak;\n\t    case ISN_UNLET:\n\t\tsmsg(\"%s%4d UNLET%s %s\", pfx, current,\n\t\t\tiptr->isn_arg.unlet.ul_forceit ? \"!\" : \"\",\n\t\t\tiptr->isn_arg.unlet.ul_name);\n\t\tbreak;\n\t    case ISN_UNLETENV:\n\t\tsmsg(\"%s%4d UNLETENV%s $%s\", pfx, current,\n\t\t\tiptr->isn_arg.unlet.ul_forceit ? \"!\" : \"\",\n\t\t\tiptr->isn_arg.unlet.ul_name);\n\t\tbreak;\n\t    case ISN_UNLETINDEX:\n\t\tsmsg(\"%s%4d UNLETINDEX\", pfx, current);\n\t\tbreak;\n\t    case ISN_UNLETRANGE:\n\t\tsmsg(\"%s%4d UNLETRANGE\", pfx, current);\n\t\tbreak;\n\t    case ISN_LOCKUNLOCK:\n\t\tsmsg(\"%s%4d LOCKUNLOCK %s\", pfx, current, iptr->isn_arg.string);\n\t\tbreak;\n\t    case ISN_LOCKCONST:\n\t\tsmsg(\"%s%4d LOCKCONST\", pfx, current);\n\t\tbreak;\n\t    case ISN_NEWLIST:\n\t\tsmsg(\"%s%4d NEWLIST size %lld\", pfx, current,\n\t\t\t\t\t    (varnumber_T)(iptr->isn_arg.number));\n\t\tbreak;\n\t    case ISN_NEWDICT:\n\t\tsmsg(\"%s%4d NEWDICT size %lld\", pfx, current,\n\t\t\t\t\t    (varnumber_T)(iptr->isn_arg.number));\n\t\tbreak;\n\n\t    // function call\n\t    case ISN_BCALL:\n\t\t{\n\t\t    cbfunc_T\t*cbfunc = &iptr->isn_arg.bfunc;\n\n\t\t    smsg(\"%s%4d BCALL %s(argc %d)\", pfx, current,\n\t\t\t    internal_func_name(cbfunc->cbf_idx),\n\t\t\t    cbfunc->cbf_argcount);\n\t\t}\n\t\tbreak;\n\t    case ISN_DCALL:\n\t\t{\n\t\t    cdfunc_T\t*cdfunc = &iptr->isn_arg.dfunc;\n\t\t    dfunc_T\t*df = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t     + cdfunc->cdf_idx;\n\n\t\t    smsg(\"%s%4d DCALL %s(argc %d)\", pfx, current,\n\t\t\t\t\t    printable_func_name(df->df_ufunc),\n\t\t\t\t\t\t\t cdfunc->cdf_argcount);\n\t\t}\n\t\tbreak;\n\t    case ISN_UCALL:\n\t\t{\n\t\t    cufunc_T\t*cufunc = &iptr->isn_arg.ufunc;\n\n\t\t    smsg(\"%s%4d UCALL %s(argc %d)\", pfx, current,\n\t\t\t\t       cufunc->cuf_name, cufunc->cuf_argcount);\n\t\t}\n\t\tbreak;\n\t    case ISN_PCALL:\n\t\t{\n\t\t    cpfunc_T\t*cpfunc = &iptr->isn_arg.pfunc;\n\n\t\t    smsg(\"%s%4d PCALL%s (argc %d)\", pfx, current,\n\t\t\t   cpfunc->cpf_top ? \" top\" : \"\", cpfunc->cpf_argcount);\n\t\t}\n\t\tbreak;\n\t    case ISN_PCALL_END:\n\t\tsmsg(\"%s%4d PCALL end\", pfx, current);\n\t\tbreak;\n\t    case ISN_RETURN:\n\t\tsmsg(\"%s%4d RETURN\", pfx, current);\n\t\tbreak;\n\t    case ISN_RETURN_VOID:\n\t\tsmsg(\"%s%4d RETURN void\", pfx, current);\n\t\tbreak;\n\t    case ISN_FUNCREF:\n\t\t{\n\t\t    funcref_T\t*funcref = &iptr->isn_arg.funcref;\n\t\t    char_u\t*name;\n\n\t\t    if (funcref->fr_func_name == NULL)\n\t\t    {\n\t\t\tdfunc_T\t*df = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t       + funcref->fr_dfunc_idx;\n\t\t\tname = df->df_ufunc->uf_name;\n\t\t    }\n\t\t    else\n\t\t\tname = funcref->fr_func_name;\n\t\t    smsg(\"%s%4d FUNCREF %s\", pfx, current, name);\n\t\t}\n\t\tbreak;\n\n\t    case ISN_NEWFUNC:\n\t\t{\n\t\t    newfunc_T\t*newfunc = &iptr->isn_arg.newfunc;\n\n\t\t    smsg(\"%s%4d NEWFUNC %s %s\", pfx, current,\n\t\t\t\t       newfunc->nf_lambda, newfunc->nf_global);\n\t\t}\n\t\tbreak;\n\n\t    case ISN_DEF:\n\t\t{\n\t\t    char_u *name = iptr->isn_arg.string;\n\n\t\t    smsg(\"%s%4d DEF %s\", pfx, current,\n\t\t\t\t\t   name == NULL ? (char_u *)\"\" : name);\n\t\t}\n\t\tbreak;\n\n\t    case ISN_JUMP:\n\t\t{\n\t\t    char *when = \"?\";\n\n\t\t    switch (iptr->isn_arg.jump.jump_when)\n\t\t    {\n\t\t\tcase JUMP_ALWAYS:\n\t\t\t    when = \"JUMP\";\n\t\t\t    break;\n\t\t\tcase JUMP_NEVER:\n\t\t\t    iemsg(\"JUMP_NEVER should not be used\");\n\t\t\t    break;\n\t\t\tcase JUMP_AND_KEEP_IF_TRUE:\n\t\t\t    when = \"JUMP_AND_KEEP_IF_TRUE\";\n\t\t\t    break;\n\t\t\tcase JUMP_IF_FALSE:\n\t\t\t    when = \"JUMP_IF_FALSE\";\n\t\t\t    break;\n\t\t\tcase JUMP_AND_KEEP_IF_FALSE:\n\t\t\t    when = \"JUMP_AND_KEEP_IF_FALSE\";\n\t\t\t    break;\n\t\t\tcase JUMP_IF_COND_FALSE:\n\t\t\t    when = \"JUMP_IF_COND_FALSE\";\n\t\t\t    break;\n\t\t\tcase JUMP_IF_COND_TRUE:\n\t\t\t    when = \"JUMP_IF_COND_TRUE\";\n\t\t\t    break;\n\t\t    }\n\t\t    smsg(\"%s%4d %s -> %d\", pfx, current, when,\n\t\t\t\t\t\tiptr->isn_arg.jump.jump_where);\n\t\t}\n\t\tbreak;\n\n\t    case ISN_JUMP_IF_ARG_SET:\n\t\tsmsg(\"%s%4d JUMP_IF_ARG_SET arg[%d] -> %d\", pfx, current,\n\t\t\t iptr->isn_arg.jumparg.jump_arg_off + STACK_FRAME_SIZE,\n\t\t\t\t\t\tiptr->isn_arg.jump.jump_where);\n\t\tbreak;\n\n\t    case ISN_FOR:\n\t\t{\n\t\t    forloop_T *forloop = &iptr->isn_arg.forloop;\n\n\t\t    smsg(\"%s%4d FOR $%d -> %d\", pfx, current,\n\t\t\t\t\t   forloop->for_idx, forloop->for_end);\n\t\t}\n\t\tbreak;\n\n\t    case ISN_TRY:\n\t\t{\n\t\t    try_T *try = &iptr->isn_arg.tryref;\n\n\t\t    if (try->try_ref->try_finally == 0)\n\t\t\tsmsg(\"%s%4d TRY catch -> %d, endtry -> %d\",\n\t\t\t\tpfx, current,\n\t\t\t\ttry->try_ref->try_catch,\n\t\t\t\ttry->try_ref->try_endtry);\n\t\t    else\n\t\t\tsmsg(\"%s%4d TRY catch -> %d, finally -> %d, endtry -> %d\",\n\t\t\t\tpfx, current,\n\t\t\t\ttry->try_ref->try_catch,\n\t\t\t\ttry->try_ref->try_finally,\n\t\t\t\ttry->try_ref->try_endtry);\n\t\t}\n\t\tbreak;\n\t    case ISN_CATCH:\n\t\tsmsg(\"%s%4d CATCH\", pfx, current);\n\t\tbreak;\n\t    case ISN_TRYCONT:\n\t\t{\n\t\t    trycont_T *trycont = &iptr->isn_arg.trycont;\n\n\t\t    smsg(\"%s%4d TRY-CONTINUE %d level%s -> %d\", pfx, current,\n\t\t\t\t      trycont->tct_levels,\n\t\t\t\t      trycont->tct_levels == 1 ? \"\" : \"s\",\n\t\t\t\t      trycont->tct_where);\n\t\t}\n\t\tbreak;\n\t    case ISN_FINALLY:\n\t\tsmsg(\"%s%4d FINALLY\", pfx, current);\n\t\tbreak;\n\t    case ISN_ENDTRY:\n\t\tsmsg(\"%s%4d ENDTRY\", pfx, current);\n\t\tbreak;\n\t    case ISN_THROW:\n\t\tsmsg(\"%s%4d THROW\", pfx, current);\n\t\tbreak;\n\n\t    // expression operations on number\n\t    case ISN_OPNR:\n\t    case ISN_OPFLOAT:\n\t    case ISN_OPANY:\n\t\t{\n\t\t    char *what;\n\t\t    char *ins;\n\n\t\t    switch (iptr->isn_arg.op.op_type)\n\t\t    {\n\t\t\tcase EXPR_MULT: what = \"*\"; break;\n\t\t\tcase EXPR_DIV: what = \"/\"; break;\n\t\t\tcase EXPR_REM: what = \"%\"; break;\n\t\t\tcase EXPR_SUB: what = \"-\"; break;\n\t\t\tcase EXPR_ADD: what = \"+\"; break;\n\t\t\tdefault:       what = \"???\"; break;\n\t\t    }\n\t\t    switch (iptr->isn_type)\n\t\t    {\n\t\t\tcase ISN_OPNR: ins = \"OPNR\"; break;\n\t\t\tcase ISN_OPFLOAT: ins = \"OPFLOAT\"; break;\n\t\t\tcase ISN_OPANY: ins = \"OPANY\"; break;\n\t\t\tdefault: ins = \"???\"; break;\n\t\t    }\n\t\t    smsg(\"%s%4d %s %s\", pfx, current, ins, what);\n\t\t}\n\t\tbreak;\n\n\t    case ISN_COMPAREBOOL:\n\t    case ISN_COMPARESPECIAL:\n\t    case ISN_COMPARENR:\n\t    case ISN_COMPAREFLOAT:\n\t    case ISN_COMPARESTRING:\n\t    case ISN_COMPAREBLOB:\n\t    case ISN_COMPARELIST:\n\t    case ISN_COMPAREDICT:\n\t    case ISN_COMPAREFUNC:\n\t    case ISN_COMPAREANY:\n\t\t   {\n\t\t       char *p;\n\t\t       char buf[10];\n\t\t       char *type;\n\n\t\t       switch (iptr->isn_arg.op.op_type)\n\t\t       {\n\t\t\t   case EXPR_EQUAL:\t p = \"==\"; break;\n\t\t\t   case EXPR_NEQUAL:    p = \"!=\"; break;\n\t\t\t   case EXPR_GREATER:   p = \">\"; break;\n\t\t\t   case EXPR_GEQUAL:    p = \">=\"; break;\n\t\t\t   case EXPR_SMALLER:   p = \"<\"; break;\n\t\t\t   case EXPR_SEQUAL:    p = \"<=\"; break;\n\t\t\t   case EXPR_MATCH:\t p = \"=~\"; break;\n\t\t\t   case EXPR_IS:\t p = \"is\"; break;\n\t\t\t   case EXPR_ISNOT:\t p = \"isnot\"; break;\n\t\t\t   case EXPR_NOMATCH:\t p = \"!~\"; break;\n\t\t\t   default:  p = \"???\"; break;\n\t\t       }\n\t\t       STRCPY(buf, p);\n\t\t       if (iptr->isn_arg.op.op_ic == TRUE)\n\t\t\t   strcat(buf, \"?\");\n\t\t       switch(iptr->isn_type)\n\t\t       {\n\t\t\t   case ISN_COMPAREBOOL: type = \"COMPAREBOOL\"; break;\n\t\t\t   case ISN_COMPARESPECIAL:\n\t\t\t\t\t\t type = \"COMPARESPECIAL\"; break;\n\t\t\t   case ISN_COMPARENR: type = \"COMPARENR\"; break;\n\t\t\t   case ISN_COMPAREFLOAT: type = \"COMPAREFLOAT\"; break;\n\t\t\t   case ISN_COMPARESTRING:\n\t\t\t\t\t\t  type = \"COMPARESTRING\"; break;\n\t\t\t   case ISN_COMPAREBLOB: type = \"COMPAREBLOB\"; break;\n\t\t\t   case ISN_COMPARELIST: type = \"COMPARELIST\"; break;\n\t\t\t   case ISN_COMPAREDICT: type = \"COMPAREDICT\"; break;\n\t\t\t   case ISN_COMPAREFUNC: type = \"COMPAREFUNC\"; break;\n\t\t\t   case ISN_COMPAREANY: type = \"COMPAREANY\"; break;\n\t\t\t   default: type = \"???\"; break;\n\t\t       }\n\n\t\t       smsg(\"%s%4d %s %s\", pfx, current, type, buf);\n\t\t   }\n\t\t   break;\n\n\t    case ISN_ADDLIST: smsg(\"%s%4d ADDLIST\", pfx, current); break;\n\t    case ISN_ADDBLOB: smsg(\"%s%4d ADDBLOB\", pfx, current); break;\n\n\t    // expression operations\n\t    case ISN_CONCAT: smsg(\"%s%4d CONCAT\", pfx, current); break;\n\t    case ISN_STRINDEX: smsg(\"%s%4d STRINDEX\", pfx, current); break;\n\t    case ISN_STRSLICE: smsg(\"%s%4d STRSLICE\", pfx, current); break;\n\t    case ISN_BLOBINDEX: smsg(\"%s%4d BLOBINDEX\", pfx, current); break;\n\t    case ISN_BLOBSLICE: smsg(\"%s%4d BLOBSLICE\", pfx, current); break;\n\t    case ISN_LISTAPPEND: smsg(\"%s%4d LISTAPPEND\", pfx, current); break;\n\t    case ISN_BLOBAPPEND: smsg(\"%s%4d BLOBAPPEND\", pfx, current); break;\n\t    case ISN_LISTINDEX: smsg(\"%s%4d LISTINDEX\", pfx, current); break;\n\t    case ISN_LISTSLICE: smsg(\"%s%4d LISTSLICE\", pfx, current); break;\n\t    case ISN_ANYINDEX: smsg(\"%s%4d ANYINDEX\", pfx, current); break;\n\t    case ISN_ANYSLICE: smsg(\"%s%4d ANYSLICE\", pfx, current); break;\n\t    case ISN_SLICE: smsg(\"%s%4d SLICE %lld\",\n\t\t\t\t    pfx, current, iptr->isn_arg.number); break;\n\t    case ISN_GETITEM: smsg(\"%s%4d ITEM %lld%s\", pfx, current,\n\t\t\t\t\t iptr->isn_arg.getitem.gi_index,\n\t\t\t\t\t iptr->isn_arg.getitem.gi_with_op ?\n\t\t\t\t\t\t       \" with op\" : \"\"); break;\n\t    case ISN_MEMBER: smsg(\"%s%4d MEMBER\", pfx, current); break;\n\t    case ISN_STRINGMEMBER: smsg(\"%s%4d MEMBER %s\", pfx, current,\n\t\t\t\t\t\t  iptr->isn_arg.string); break;\n\t    case ISN_CLEARDICT: smsg(\"%s%4d CLEARDICT\", pfx, current); break;\n\t    case ISN_USEDICT: smsg(\"%s%4d USEDICT\", pfx, current); break;\n\n\t    case ISN_NEGATENR: smsg(\"%s%4d NEGATENR\", pfx, current); break;\n\n\t    case ISN_CHECKNR: smsg(\"%s%4d CHECKNR\", pfx, current); break;\n\t    case ISN_CHECKTYPE:\n\t\t  {\n\t\t      checktype_T *ct = &iptr->isn_arg.type;\n\t\t      char *tofree;\n\n\t\t      if (ct->ct_arg_idx == 0)\n\t\t\t  smsg(\"%s%4d CHECKTYPE %s stack[%d]\", pfx, current,\n\t\t\t\t\t  type_name(ct->ct_type, &tofree),\n\t\t\t\t\t  (int)ct->ct_off);\n\t\t      else\n\t\t\t  smsg(\"%s%4d CHECKTYPE %s stack[%d] arg %d\",\n\t\t\t\t\t  pfx, current,\n\t\t\t\t\t  type_name(ct->ct_type, &tofree),\n\t\t\t\t\t  (int)ct->ct_off,\n\t\t\t\t\t  (int)ct->ct_arg_idx);\n\t\t      vim_free(tofree);\n\t\t      break;\n\t\t  }\n\t    case ISN_CHECKLEN: smsg(\"%s%4d CHECKLEN %s%d\", pfx, current,\n\t\t\t\tiptr->isn_arg.checklen.cl_more_OK ? \">= \" : \"\",\n\t\t\t\tiptr->isn_arg.checklen.cl_min_len);\n\t\t\t       break;\n\t    case ISN_SETTYPE:\n\t\t  {\n\t\t      char *tofree;\n\n\t\t      smsg(\"%s%4d SETTYPE %s\", pfx, current,\n\t\t\t      type_name(iptr->isn_arg.type.ct_type, &tofree));\n\t\t      vim_free(tofree);\n\t\t      break;\n\t\t  }\n\t    case ISN_COND2BOOL: smsg(\"%s%4d COND2BOOL\", pfx, current); break;\n\t    case ISN_2BOOL: if (iptr->isn_arg.tobool.invert)\n\t\t\t\tsmsg(\"%s%4d INVERT %d (!val)\", pfx, current,\n\t\t\t\t\t iptr->isn_arg.tobool.offset);\n\t\t\t    else\n\t\t\t\tsmsg(\"%s%4d 2BOOL %d (!!val)\", pfx, current,\n\t\t\t\t\t iptr->isn_arg.tobool.offset);\n\t\t\t    break;\n\t    case ISN_2STRING: smsg(\"%s%4d 2STRING stack[%lld]\", pfx, current,\n\t\t\t\t (varnumber_T)(iptr->isn_arg.tostring.offset));\n\t\t\t      break;\n\t    case ISN_2STRING_ANY: smsg(\"%s%4d 2STRING_ANY stack[%lld]\",\n\t\t\t\t\t\t\t\t  pfx, current,\n\t\t\t\t (varnumber_T)(iptr->isn_arg.tostring.offset));\n\t\t\t      break;\n\t    case ISN_RANGE: smsg(\"%s%4d RANGE %s\", pfx, current,\n\t\t\t\t\t\t\t iptr->isn_arg.string);\n\t\t\t    break;\n\t    case ISN_PUT:\n\t        if (iptr->isn_arg.put.put_lnum == LNUM_VARIABLE_RANGE_ABOVE)\n\t\t    smsg(\"%s%4d PUT %c above range\",\n\t\t\t\t  pfx, current, iptr->isn_arg.put.put_regname);\n\t\telse if (iptr->isn_arg.put.put_lnum == LNUM_VARIABLE_RANGE)\n\t\t    smsg(\"%s%4d PUT %c range\",\n\t\t\t\t  pfx, current, iptr->isn_arg.put.put_regname);\n\t\telse\n\t\t    smsg(\"%s%4d PUT %c %ld\", pfx, current,\n\t\t\t\t\t\t iptr->isn_arg.put.put_regname,\n\t\t\t\t\t     (long)iptr->isn_arg.put.put_lnum);\n\t\tbreak;\n\n\t    case ISN_CMDMOD:\n\t\t{\n\t\t    char_u  *buf;\n\t\t    size_t  len = produce_cmdmods(\n\t\t\t\t  NULL, iptr->isn_arg.cmdmod.cf_cmdmod, FALSE);\n\n\t\t    buf = alloc(len + 1);\n\t\t    if (likely(buf != NULL))\n\t\t    {\n\t\t\t(void)produce_cmdmods(\n\t\t\t\t   buf, iptr->isn_arg.cmdmod.cf_cmdmod, FALSE);\n\t\t\tsmsg(\"%s%4d CMDMOD %s\", pfx, current, buf);\n\t\t\tvim_free(buf);\n\t\t    }\n\t\t    break;\n\t\t}\n\t    case ISN_CMDMOD_REV: smsg(\"%s%4d CMDMOD_REV\", pfx, current); break;\n\n\t    case ISN_PROF_START:\n\t\t smsg(\"%s%4d PROFILE START line %d\", pfx, current,\n\t\t\t\t\t\t\t       iptr->isn_lnum);\n\t\t break;\n\n\t    case ISN_PROF_END:\n\t\tsmsg(\"%s%4d PROFILE END\", pfx, current);\n\t\tbreak;\n\n\t    case ISN_DEBUG:\n\t\tsmsg(\"%s%4d DEBUG line %d-%d varcount %lld\", pfx, current,\n\t\t\tiptr->isn_arg.debug.dbg_break_lnum + 1,\n\t\t\tiptr->isn_lnum,\n\t\t\tiptr->isn_arg.debug.dbg_var_names_len);\n\t\tbreak;\n\n\t    case ISN_UNPACK: smsg(\"%s%4d UNPACK %d%s\", pfx, current,\n\t\t\tiptr->isn_arg.unpack.unp_count,\n\t\t\tiptr->isn_arg.unpack.unp_semicolon ? \" semicolon\" : \"\");\n\t\t\t      break;\n\t    case ISN_SHUFFLE: smsg(\"%s%4d SHUFFLE %d up %d\", pfx, current,\n\t\t\t\t\t iptr->isn_arg.shuffle.shfl_item,\n\t\t\t\t\t iptr->isn_arg.shuffle.shfl_up);\n\t\t\t      break;\n\t    case ISN_DROP: smsg(\"%s%4d DROP\", pfx, current); break;\n\n\t    case ISN_FINISH: // End of list of instructions for ISN_SUBSTITUTE.\n\t\t\t   return;\n\t}\n\n\tout_flush();\t    // output one line at a time\n\tui_breakcheck();\n\tif (got_int)\n\t    break;\n    }\n}\n\n/*\n * Handle command line completion for the :disassemble command.\n */\n    void\nset_context_in_disassemble_cmd(expand_T *xp, char_u *arg)\n{\n    char_u\t*p;\n\n    // Default: expand user functions, \"debug\" and \"profile\"\n    xp->xp_context = EXPAND_DISASSEMBLE;\n    xp->xp_pattern = arg;\n\n    // first argument already typed: only user function names\n    if (*arg != NUL && *(p = skiptowhite(arg)) != NUL)\n    {\n\txp->xp_context = EXPAND_USER_FUNC;\n\txp->xp_pattern = skipwhite(p);\n    }\n}\n\n/*\n * Function given to ExpandGeneric() to obtain the list of :disassemble\n * arguments.\n */\n    char_u *\nget_disassemble_argument(expand_T *xp, int idx)\n{\n    if (idx == 0)\n\treturn (char_u *)\"debug\";\n    if (idx == 1)\n\treturn (char_u *)\"profile\";\n    return get_user_func_name(xp, idx - 2);\n}\n\n/*\n * \":disassemble\".\n * We don't really need this at runtime, but we do have tests that require it,\n * so always include this.\n */\n    void\nex_disassemble(exarg_T *eap)\n{\n    char_u\t*arg = eap->arg;\n    char_u\t*fname;\n    ufunc_T\t*ufunc;\n    dfunc_T\t*dfunc;\n    isn_T\t*instr;\n    int\t\tinstr_count;\n    int\t\tis_global = FALSE;\n    compiletype_T compile_type = CT_NONE;\n\n    if (STRNCMP(arg, \"profile\", 7) == 0 && VIM_ISWHITE(arg[7]))\n    {\n\tcompile_type = CT_PROFILE;\n\targ = skipwhite(arg + 7);\n    }\n    else if (STRNCMP(arg, \"debug\", 5) == 0 && VIM_ISWHITE(arg[5]))\n    {\n\tcompile_type = CT_DEBUG;\n\targ = skipwhite(arg + 5);\n    }\n\n    if (STRNCMP(arg, \"<lambda>\", 8) == 0)\n    {\n\targ += 8;\n\t(void)getdigits(&arg);\n\tfname = vim_strnsave(eap->arg, arg - eap->arg);\n    }\n    else\n\tfname = trans_function_name(&arg, &is_global, FALSE,\n\t\t      TFN_INT | TFN_QUIET | TFN_NO_AUTOLOAD, NULL, NULL, NULL);\n    if (fname == NULL)\n    {\n\tsemsg(_(e_invarg2), eap->arg);\n\treturn;\n    }\n\n    ufunc = find_func(fname, is_global, NULL);\n    if (ufunc == NULL)\n    {\n\tchar_u *p = untrans_function_name(fname);\n\n\tif (p != NULL)\n\t    // Try again without making it script-local.\n\t    ufunc = find_func(p, FALSE, NULL);\n    }\n    vim_free(fname);\n    if (ufunc == NULL)\n    {\n\tsemsg(_(e_cannot_find_function_str), eap->arg);\n\treturn;\n    }\n    if (func_needs_compiling(ufunc, compile_type)\n\t    && compile_def_function(ufunc, FALSE, compile_type, NULL) == FAIL)\n\treturn;\n    if (ufunc->uf_def_status != UF_COMPILED)\n    {\n\tsemsg(_(e_function_is_not_compiled_str), eap->arg);\n\treturn;\n    }\n    msg((char *)printable_func_name(ufunc));\n\n    dfunc = ((dfunc_T *)def_functions.ga_data) + ufunc->uf_dfunc_idx;\n    switch (compile_type)\n    {\n\tcase CT_PROFILE:\n#ifdef FEAT_PROFILE\n\t    instr = dfunc->df_instr_prof;\n\t    instr_count = dfunc->df_instr_prof_count;\n\t    break;\n#endif\n\t    // FALLTHROUGH\n\tcase CT_NONE:\n\t    instr = dfunc->df_instr;\n\t    instr_count = dfunc->df_instr_count;\n\t    break;\n\tcase CT_DEBUG:\n\t    instr = dfunc->df_instr_debug;\n\t    instr_count = dfunc->df_instr_debug_count;\n\t    break;\n    }\n\n    list_instructions(\"\", instr, instr_count, ufunc);\n}\n\n/*\n * Return TRUE when \"tv\" is not falsy: non-zero, non-empty string, non-empty\n * list, etc.  Mostly like what JavaScript does, except that empty list and\n * empty dictionary are FALSE.\n */\n    int\ntv2bool(typval_T *tv)\n{\n    switch (tv->v_type)\n    {\n\tcase VAR_NUMBER:\n\t    return tv->vval.v_number != 0;\n\tcase VAR_FLOAT:\n#ifdef FEAT_FLOAT\n\t    return tv->vval.v_float != 0.0;\n#else\n\t    break;\n#endif\n\tcase VAR_PARTIAL:\n\t    return tv->vval.v_partial != NULL;\n\tcase VAR_FUNC:\n\tcase VAR_STRING:\n\t    return tv->vval.v_string != NULL && *tv->vval.v_string != NUL;\n\tcase VAR_LIST:\n\t    return tv->vval.v_list != NULL && tv->vval.v_list->lv_len > 0;\n\tcase VAR_DICT:\n\t    return tv->vval.v_dict != NULL\n\t\t\t\t    && tv->vval.v_dict->dv_hashtab.ht_used > 0;\n\tcase VAR_BOOL:\n\tcase VAR_SPECIAL:\n\t    return tv->vval.v_number == VVAL_TRUE ? TRUE : FALSE;\n\tcase VAR_JOB:\n#ifdef FEAT_JOB_CHANNEL\n\t    return tv->vval.v_job != NULL;\n#else\n\t    break;\n#endif\n\tcase VAR_CHANNEL:\n#ifdef FEAT_JOB_CHANNEL\n\t    return tv->vval.v_channel != NULL;\n#else\n\t    break;\n#endif\n\tcase VAR_BLOB:\n\t    return tv->vval.v_blob != NULL && tv->vval.v_blob->bv_ga.ga_len > 0;\n\tcase VAR_UNKNOWN:\n\tcase VAR_ANY:\n\tcase VAR_VOID:\n\tcase VAR_INSTR:\n\t    break;\n    }\n    return FALSE;\n}\n\n    void\nemsg_using_string_as(typval_T *tv, int as_number)\n{\n    semsg(_(as_number ? e_using_string_as_number_str\n\t\t\t\t\t\t : e_using_string_as_bool_str),\n\t\t       tv->vval.v_string == NULL\n\t\t\t\t\t   ? (char_u *)\"\" : tv->vval.v_string);\n}\n\n/*\n * If \"tv\" is a string give an error and return FAIL.\n */\n    int\ncheck_not_string(typval_T *tv)\n{\n    if (tv->v_type == VAR_STRING)\n    {\n\temsg_using_string_as(tv, TRUE);\n\tclear_tv(tv);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n\n#endif // FEAT_EVAL\n"], "fixing_code": ["/* userfunc.c */\nvoid func_init(void);\nhashtab_T *func_tbl_get(void);\nchar_u *get_lambda_name(void);\nchar_u *register_cfunc(cfunc_T cb, cfunc_free_T cb_free, void *state);\nint get_lambda_tv(char_u **arg, typval_T *rettv, int types_optional, evalarg_T *evalarg);\nchar_u *deref_func_name(char_u *name, int *lenp, partial_T **partialp, type_T **type, int no_autoload, int *found_var);\nvoid emsg_funcname(char *ermsg, char_u *name);\nint get_func_tv(char_u *name, int len, typval_T *rettv, char_u **arg, evalarg_T *evalarg, funcexe_T *funcexe);\nchar_u *fname_trans_sid(char_u *name, char_u *fname_buf, char_u **tofree, int *error);\nufunc_T *find_func_even_dead(char_u *name, int is_global, cctx_T *cctx);\nufunc_T *find_func(char_u *name, int is_global, cctx_T *cctx);\nint func_is_global(ufunc_T *ufunc);\nint func_name_refcount(char_u *name);\nvoid func_clear_free(ufunc_T *fp, int force);\nint copy_func(char_u *lambda, char_u *global, ectx_T *ectx);\nint funcdepth_increment(void);\nvoid funcdepth_decrement(void);\nint funcdepth_get(void);\nvoid funcdepth_restore(int depth);\nint check_user_func_argcount(ufunc_T *fp, int argcount);\nint call_user_func_check(ufunc_T *fp, int argcount, typval_T *argvars, typval_T *rettv, funcexe_T *funcexe, dict_T *selfdict);\nvoid save_funccal(funccal_entry_T *entry);\nvoid restore_funccal(void);\nfunccall_T *get_current_funccal(void);\nvoid delete_script_functions(int sid);\nvoid free_all_functions(void);\nint builtin_function(char_u *name, int len);\nint func_call(char_u *name, typval_T *args, partial_T *partial, dict_T *selfdict, typval_T *rettv);\nint get_callback_depth(void);\nint call_callback(callback_T *callback, int len, typval_T *rettv, int argcount, typval_T *argvars);\nvarnumber_T call_callback_retnr(callback_T *callback, int argcount, typval_T *argvars);\nvoid user_func_error(int error, char_u *name, funcexe_T *funcexe);\nint call_func(char_u *funcname, int len, typval_T *rettv, int argcount_in, typval_T *argvars_in, funcexe_T *funcexe);\nchar_u *printable_func_name(ufunc_T *fp);\nchar_u *trans_function_name(char_u **pp, int *is_global, int skip, int flags, funcdict_T *fdp, partial_T **partial, type_T **type);\nchar_u *untrans_function_name(char_u *name);\nchar_u *get_scriptlocal_funcname(char_u *funcname);\nchar_u *save_function_name(char_u **name, int *is_global, int skip, int flags, funcdict_T *fudi);\nvoid list_functions(regmatch_T *regmatch);\nufunc_T *define_function(exarg_T *eap, char_u *name_arg, char_u **line_to_free);\nvoid ex_function(exarg_T *eap);\nvoid ex_defcompile(exarg_T *eap);\nint eval_fname_script(char_u *p);\nint translated_function_exists(char_u *name, int is_global);\nint has_varargs(ufunc_T *ufunc);\nint function_exists(char_u *name, int no_deref);\nchar_u *get_expanded_name(char_u *name, int check);\nchar_u *get_user_func_name(expand_T *xp, int idx);\nvoid ex_delfunction(exarg_T *eap);\nvoid func_unref(char_u *name);\nvoid func_ptr_unref(ufunc_T *fp);\nvoid func_ref(char_u *name);\nvoid func_ptr_ref(ufunc_T *fp);\nvoid ex_return(exarg_T *eap);\nvoid ex_call(exarg_T *eap);\nint do_return(exarg_T *eap, int reanimate, int is_cmd, void *rettv);\nvoid discard_pending_return(void *rettv);\nchar_u *get_return_cmd(void *rettv);\nchar_u *get_func_line(int c, void *cookie, int indent, getline_opt_T options);\nint func_has_ended(void *cookie);\nint func_has_abort(void *cookie);\ndict_T *make_partial(dict_T *selfdict_in, typval_T *rettv);\nchar_u *func_name(void *cookie);\nlinenr_T *func_breakpoint(void *cookie);\nint *func_dbg_tick(void *cookie);\nint func_level(void *cookie);\nint current_func_returned(void);\nint free_unref_funccal(int copyID, int testing);\nhashtab_T *get_funccal_local_ht(void);\ndictitem_T *get_funccal_local_var(void);\nhashtab_T *get_funccal_args_ht(void);\ndictitem_T *get_funccal_args_var(void);\nvoid list_func_vars(int *first);\ndict_T *get_current_funccal_dict(hashtab_T *ht);\nhashitem_T *find_hi_in_scoped_ht(char_u *name, hashtab_T **pht);\ndictitem_T *find_var_in_scoped_ht(char_u *name, int no_autoload);\nint set_ref_in_previous_funccal(int copyID);\nint set_ref_in_call_stack(int copyID);\nint set_ref_in_functions(int copyID);\nint set_ref_in_func_args(int copyID);\nint set_ref_in_func(char_u *name, ufunc_T *fp_in, int copyID);\n/* vim: set ft=c : */\n", "\" Test various aspects of the Vim9 script language.\n\nsource check.vim\nsource term_util.vim\nsource view_util.vim\nsource vim9.vim\nsource screendump.vim\n\nfunc Test_def_basic()\n  def SomeFunc(): string\n    return 'yes'\n  enddef\n  call SomeFunc()->assert_equal('yes')\nendfunc\n\nfunc Test_compiling_error()\n  \" use a terminal to see the whole error message\n  CheckRunVimInTerminal\n\n  call TestCompilingError()\n  call TestCompilingErrorInTry()\nendfunc\n\ndef TestCompilingError()\n  var lines =<< trim END\n    vim9script\n    def Fails()\n      echo nothing\n    enddef\n    defcompile\n  END\n  writefile(lines, 'XTest_compile_error')\n  var buf = RunVimInTerminal('-S XTest_compile_error',\n              {rows: 10, wait_for_ruler: 0})\n  WaitForAssert(() => assert_match('Error detected while compiling command line.*Fails.*Variable not found: nothing',\n                     Term_getlines(buf, range(1, 9))))\n\n  # clean up\n  StopVimInTerminal(buf)\n  delete('XTest_compile_error')\nenddef\n\ndef TestCompilingErrorInTry()\n  var dir = 'Xdir/autoload'\n  mkdir(dir, 'p')\n\n  var lines =<< trim END\n      vim9script\n      def script#OnlyCompiled()\n        g:runtime = 'yes'\n        invalid\n      enddef\n  END\n  writefile(lines, dir .. '/script.vim')\n\n  lines =<< trim END\n      vim9script\n      todo\n      try\n        script#OnlyCompiled()\n      catch /nothing/\n      endtry\n  END\n  lines[1] = 'set rtp=' .. getcwd() .. '/Xdir'\n  writefile(lines, 'XTest_compile_error')\n\n  var buf = RunVimInTerminal('-S XTest_compile_error', {rows: 10, wait_for_ruler: 0})\n  WaitForAssert(() => assert_match('Error detected while compiling command line.*function script#OnlyCompiled.*Invalid command: invalid',\n                     Term_getlines(buf, range(1, 9))))\n\n  # clean up\n  StopVimInTerminal(buf)\n  delete('XTest_compile_error')\n  delete('Xdir', 'rf')\nenddef\n\ndef Test_compile_error_in_called_function()\n  var lines =<< trim END\n      vim9script\n      var n: number\n      def Foo()\n        &hls = n\n      enddef\n      def Bar()\n        Foo()\n      enddef\n      silent! Foo()\n      Bar()\n  END\n  CheckScriptFailureList(lines, ['E1012:', 'E1191:'])\nenddef\n\ndef Test_wrong_function_name()\n  var lines =<< trim END\n      vim9script\n      func _Foo()\n        echo 'foo'\n      endfunc\n  END\n  CheckScriptFailure(lines, 'E128:')\n\n  lines =<< trim END\n      vim9script\n      def _Foo()\n        echo 'foo'\n      enddef\n  END\n  CheckScriptFailure(lines, 'E128:')\nenddef\n\ndef Test_autoload_name_mismatch()\n  var dir = 'Xdir/autoload'\n  mkdir(dir, 'p')\n\n  var lines =<< trim END\n      vim9script\n      def scriptX#Function()\n        # comment\n        g:runtime = 'yes'\n      enddef\n  END\n  writefile(lines, dir .. '/script.vim')\n\n  var save_rtp = &rtp\n  exe 'set rtp=' .. getcwd() .. '/Xdir'\n  lines =<< trim END\n      call script#Function()\n  END\n  CheckScriptFailure(lines, 'E746:', 2)\n\n  &rtp = save_rtp\n  delete(dir, 'rf')\nenddef\n\ndef Test_autoload_names()\n  var dir = 'Xdir/autoload'\n  mkdir(dir, 'p')\n\n  var lines =<< trim END\n      func foobar#function()\n        return 'yes'\n      endfunc\n      let foobar#var = 'no'\n  END\n  writefile(lines, dir .. '/foobar.vim')\n\n  var save_rtp = &rtp\n  exe 'set rtp=' .. getcwd() .. '/Xdir'\n\n  lines =<< trim END\n      assert_equal('yes', foobar#function())\n      var Function = foobar#function\n      assert_equal('yes', Function())\n\n      assert_equal('no', foobar#var)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  &rtp = save_rtp\n  delete(dir, 'rf')\nenddef\n\ndef Test_autoload_error_in_script()\n  var dir = 'Xdir/autoload'\n  mkdir(dir, 'p')\n\n  var lines =<< trim END\n      func scripterror#function()\n        let g:called_function = 'yes'\n      endfunc\n      let 0 = 1\n  END\n  writefile(lines, dir .. '/scripterror.vim')\n\n  var save_rtp = &rtp\n  exe 'set rtp=' .. getcwd() .. '/Xdir'\n\n  g:called_function = 'no'\n  # The error in the autoload script cannot be checked with assert_fails(), use\n  # CheckDefSuccess() instead of CheckDefFailure()\n  try\n    CheckDefSuccess(['scripterror#function()'])\n  catch\n    assert_match('E121: Undefined variable: 0', v:exception)\n  endtry\n  assert_equal('no', g:called_function)\n\n  lines =<< trim END\n      func scriptcaught#function()\n        let g:called_function = 'yes'\n      endfunc\n      try\n        let 0 = 1\n      catch\n        let g:caught = v:exception\n      endtry\n  END\n  writefile(lines, dir .. '/scriptcaught.vim')\n\n  g:called_function = 'no'\n  CheckDefSuccess(['scriptcaught#function()'])\n  assert_match('E121: Undefined variable: 0', g:caught)\n  assert_equal('yes', g:called_function)\n\n  &rtp = save_rtp\n  delete(dir, 'rf')\nenddef\n\ndef CallRecursive(n: number): number\n  return CallRecursive(n + 1)\nenddef\n\ndef CallMapRecursive(l: list<number>): number\n  return map(l, (_, v) => CallMapRecursive([v]))[0]\nenddef\n\ndef Test_funcdepth_error()\n  set maxfuncdepth=10\n\n  var caught = false\n  try\n    CallRecursive(1)\n  catch /E132:/\n    caught = true\n  endtry\n  assert_true(caught)\n\n  caught = false\n  try\n    CallMapRecursive([1])\n  catch /E132:/\n    caught = true\n  endtry\n  assert_true(caught)\n\n  set maxfuncdepth&\nenddef\n\ndef Test_endfunc_enddef()\n  var lines =<< trim END\n    def Test()\n      echo 'test'\n      endfunc\n    enddef\n  END\n  CheckScriptFailure(lines, 'E1151:', 3)\n\n  lines =<< trim END\n    def Test()\n      func Nested()\n        echo 'test'\n      enddef\n    enddef\n  END\n  CheckScriptFailure(lines, 'E1152:', 4)\n\n  lines =<< trim END\n    def Ok()\n      echo 'hello'\n    enddef | echo 'there'\n    def Bad()\n      echo 'hello'\n    enddef there\n  END\n  CheckScriptFailure(lines, 'E1173: Text found after enddef: there', 6)\nenddef\n\ndef Test_missing_endfunc_enddef()\n  var lines =<< trim END\n    vim9script\n    def Test()\n      echo 'test'\n    endef\n  END\n  CheckScriptFailure(lines, 'E1057:', 2)\n\n  lines =<< trim END\n    vim9script\n    func Some()\n      echo 'test'\n    enfffunc\n  END\n  CheckScriptFailure(lines, 'E126:', 2)\nenddef\n\ndef Test_white_space_before_paren()\n  var lines =<< trim END\n    vim9script\n    def Test ()\n      echo 'test'\n    enddef\n  END\n  CheckScriptFailure(lines, 'E1068:', 2)\n\n  lines =<< trim END\n    vim9script\n    func Test ()\n      echo 'test'\n    endfunc\n  END\n  CheckScriptFailure(lines, 'E1068:', 2)\n\n  lines =<< trim END\n    def Test ()\n      echo 'test'\n    enddef\n  END\n  CheckScriptFailure(lines, 'E1068:', 1)\n\n  lines =<< trim END\n    func Test ()\n      echo 'test'\n    endfunc\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_enddef_dict_key()\n  var d = {\n    enddef: 'x',\n    endfunc: 'y',\n  }\n  assert_equal({enddef: 'x', endfunc: 'y'}, d)\nenddef\n\ndef ReturnString(): string\n  return 'string'\nenddef\n\ndef ReturnNumber(): number\n  return 123\nenddef\n\nlet g:notNumber = 'string'\n\ndef ReturnGlobal(): number\n  return g:notNumber\nenddef\n\ndef Test_return_something()\n  ReturnString()->assert_equal('string')\n  ReturnNumber()->assert_equal(123)\n  assert_fails('ReturnGlobal()', 'E1012: Type mismatch; expected number but got string', '', 1, 'ReturnGlobal')\nenddef\n\ndef Test_check_argument_type()\n  var lines =<< trim END\n      vim9script\n      def Val(a: number, b: number): number\n        return 0\n      enddef\n      def Func()\n        var x: any = true\n        Val(0, x)\n      enddef\n      disass Func\n      Func()\n  END\n  CheckScriptFailure(lines, 'E1013: Argument 2: type mismatch, expected number but got bool', 2)\nenddef\n\ndef Test_missing_return()\n  CheckDefFailure(['def Missing(): number',\n                   '  if g:cond',\n                   '    echo \"no return\"',\n                   '  else',\n                   '    return 0',\n                   '  endif'\n                   'enddef'], 'E1027:')\n  CheckDefFailure(['def Missing(): number',\n                   '  if g:cond',\n                   '    return 1',\n                   '  else',\n                   '    echo \"no return\"',\n                   '  endif'\n                   'enddef'], 'E1027:')\n  CheckDefFailure(['def Missing(): number',\n                   '  if g:cond',\n                   '    return 1',\n                   '  else',\n                   '    return 2',\n                   '  endif'\n                   '  return 3'\n                   'enddef'], 'E1095:')\nenddef\n\ndef Test_return_bool()\n  var lines =<< trim END\n      vim9script\n      def MenuFilter(id: number, key: string): bool\n        return popup_filter_menu(id, key)\n      enddef\n      def YesnoFilter(id: number, key: string): bool\n        return popup_filter_yesno(id, key)\n      enddef\n      defcompile\n  END\n  CheckScriptSuccess(lines)\nenddef\n\nlet s:nothing = 0\ndef ReturnNothing()\n  s:nothing = 1\n  if true\n    return\n  endif\n  s:nothing = 2\nenddef\n\ndef Test_return_nothing()\n  ReturnNothing()\n  s:nothing->assert_equal(1)\nenddef\n\ndef Test_return_invalid()\n  var lines =<< trim END\n    vim9script\n    def Func(): invalid\n      return xxx\n    enddef\n    defcompile\n  END\n  CheckScriptFailure(lines, 'E1010:', 2)\n\n  lines =<< trim END\n      vim9script\n      def Test(Fun: func(number): number): list<number>\n          return map([1, 2, 3], (_, i) => Fun(i))\n      enddef\n      defcompile\n      def Inc(nr: number): nr\n        return nr + 2\n      enddef\n      echo Test(Inc)\n  END\n  # doing this twice was leaking memory\n  CheckScriptFailure(lines, 'E1010:')\n  CheckScriptFailure(lines, 'E1010:')\nenddef\n\ndef Test_return_list_any()\n  var lines =<< trim END\n      vim9script\n      def Func(): list<string>\n        var l: list<any>\n        l->add('string')\n        return l\n      enddef\n      echo Func()\n  END\n  CheckScriptFailure(lines, 'E1012:')\n  lines =<< trim END\n      vim9script\n      def Func(): list<string>\n        var l: list<any>\n        l += ['string']\n        return l\n      enddef\n      echo Func()\n  END\n  CheckScriptFailure(lines, 'E1012:')\nenddef\n\nfunc Increment()\n  let g:counter += 1\nendfunc\n\ndef Test_call_ufunc_count()\n  g:counter = 1\n  Increment()\n  Increment()\n  Increment()\n  # works with and without :call\n  g:counter->assert_equal(4)\n  eval g:counter->assert_equal(4)\n  unlet g:counter\nenddef\n\ndef MyVarargs(arg: string, ...rest: list<string>): string\n  var res = arg\n  for s in rest\n    res ..= ',' .. s\n  endfor\n  return res\nenddef\n\ndef Test_call_varargs()\n  MyVarargs('one')->assert_equal('one')\n  MyVarargs('one', 'two')->assert_equal('one,two')\n  MyVarargs('one', 'two', 'three')->assert_equal('one,two,three')\nenddef\n\ndef Test_call_white_space()\n  CheckDefAndScriptFailure([\"call Test ('text')\"], ['E476:', 'E1068:'])\nenddef\n\ndef MyDefaultArgs(name = 'string'): string\n  return name\nenddef\n\ndef MyDefaultSecond(name: string, second: bool  = true): string\n  return second ? name : 'none'\nenddef\n\n\ndef Test_call_default_args()\n  MyDefaultArgs()->assert_equal('string')\n  MyDefaultArgs(v:none)->assert_equal('string')\n  MyDefaultArgs('one')->assert_equal('one')\n  assert_fails('MyDefaultArgs(\"one\", \"two\")', 'E118:', '', 4, 'Test_call_default_args')\n\n  MyDefaultSecond('test')->assert_equal('test')\n  MyDefaultSecond('test', true)->assert_equal('test')\n  MyDefaultSecond('test', false)->assert_equal('none')\n\n  var lines =<< trim END\n      def MyDefaultThird(name: string, aa = 'aa', bb = 'bb'): string\n        return name .. aa .. bb\n      enddef\n\n      MyDefaultThird('->')->assert_equal('->aabb')\n      MyDefaultThird('->', v:none)->assert_equal('->aabb')\n      MyDefaultThird('->', 'xx')->assert_equal('->xxbb')\n      MyDefaultThird('->', v:none, v:none)->assert_equal('->aabb')\n      MyDefaultThird('->', 'xx', v:none)->assert_equal('->xxbb')\n      MyDefaultThird('->', v:none, 'yy')->assert_equal('->aayy')\n      MyDefaultThird('->', 'xx', 'yy')->assert_equal('->xxyy')\n\n      def DefArg(mandatory: any, optional = mandatory): string\n        return mandatory .. optional\n      enddef\n      DefArg(1234)->assert_equal('12341234')\n      DefArg(\"ok\")->assert_equal('okok')\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  CheckScriptFailure(['def Func(arg: number = asdf)', 'enddef', 'defcompile'], 'E1001:')\n  delfunc g:Func\n  CheckScriptFailure(['def Func(arg: number = \"text\")', 'enddef', 'defcompile'], 'E1013: Argument 1: type mismatch, expected number but got string')\n  delfunc g:Func\n  CheckDefFailure(['def Func(x: number = )', 'enddef'], 'E15:')\n\n  lines =<< trim END\n      vim9script\n      def Func(a = b == 0 ? 1 : 2, b = 0)\n      enddef\n      defcompile\n  END\n  CheckScriptFailure(lines, 'E1001: Variable not found: b')\n\n  # using script variable requires matching type or type cast when executed\n  lines =<< trim END\n      vim9script\n      var a: any\n      def Func(arg: string = a)\n        echo arg\n      enddef\n      defcompile\n  END\n  CheckScriptSuccess(lines + ['a = \"text\"', 'Func()'])\n  CheckScriptFailure(lines + ['a = 123', 'Func()'], 'E1013: Argument 1: type mismatch, expected string but got number')\n\n  # using global variable does not require type cast\n  lines =<< trim END\n      vim9script\n      def Func(arg: string = g:str)\n        echo arg\n      enddef\n      g:str = 'works'\n      Func()\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef FuncWithComment(  # comment\n  a: number, #comment\n  b: bool, # comment\n  c: string) #comment\n  assert_equal(4, a)\n  assert_equal(true, b)\n  assert_equal('yes', c)\nenddef\n\ndef Test_func_with_comments()\n  FuncWithComment(4, true, 'yes')\n\n  var lines =<< trim END\n      def Func(# comment\n        arg: string)\n      enddef\n  END\n  CheckScriptFailure(lines, 'E125:', 1)\n\n  lines =<< trim END\n      def Func(\n        arg: string# comment\n        )\n      enddef\n  END\n  CheckScriptFailure(lines, 'E475:', 2)\n\n  lines =<< trim END\n      def Func(\n        arg: string\n        )# comment\n      enddef\n  END\n  CheckScriptFailure(lines, 'E488:', 3)\nenddef\n\ndef Test_nested_function()\n  def NestedDef(arg: string): string\n    return 'nested ' .. arg\n  enddef\n  NestedDef(':def')->assert_equal('nested :def')\n\n  func NestedFunc(arg)\n    return 'nested ' .. a:arg\n  endfunc\n  NestedFunc(':func')->assert_equal('nested :func')\n\n  CheckDefFailure(['def Nested()', 'enddef', 'Nested(66)'], 'E118:')\n  CheckDefFailure(['def Nested(arg: string)', 'enddef', 'Nested()'], 'E119:')\n\n  CheckDefFailure(['def s:Nested()', 'enddef'], 'E1075:')\n  CheckDefFailure(['def b:Nested()', 'enddef'], 'E1075:')\n\n  var lines =<< trim END\n      def Outer()\n        def Inner()\n          # comment\n        enddef\n        def Inner()\n        enddef\n      enddef\n  END\n  CheckDefFailure(lines, 'E1073:')\n\n  lines =<< trim END\n      def Outer()\n        def Inner()\n          # comment\n        enddef\n        def! Inner()\n        enddef\n      enddef\n  END\n  CheckDefFailure(lines, 'E1117:')\n\n  lines =<< trim END\n      vim9script\n      def Outer()\n        def Inner()\n          g:result = 'ok'\n        enddef\n        Inner()\n      enddef\n      Outer()\n      Inner()\n  END\n  CheckScriptFailure(lines, 'E117: Unknown function: Inner')\n  assert_equal('ok', g:result)\n  unlet g:result\n\n  # nested function inside conditional\n  lines =<< trim END\n      vim9script\n      var thecount = 0\n      if true\n        def Test(): number\n          def TheFunc(): number\n            thecount += 1\n            return thecount\n          enddef\n          return TheFunc()\n        enddef\n      endif\n      defcompile\n      assert_equal(1, Test())\n      assert_equal(2, Test())\n  END\n  CheckScriptSuccess(lines)\n\n  # also works when \"thecount\" is inside the \"if\" block\n  lines =<< trim END\n      vim9script\n      if true\n        var thecount = 0\n        def Test(): number\n          def TheFunc(): number\n            thecount += 1\n            return thecount\n          enddef\n          return TheFunc()\n        enddef\n      endif\n      defcompile\n      assert_equal(1, Test())\n      assert_equal(2, Test())\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Outer()\n        def Inner()\n          echo 'hello'\n        enddef burp\n      enddef\n      defcompile\n  END\n  CheckScriptFailure(lines, 'E1173: Text found after enddef: burp', 3)\nenddef\n\ndef Test_not_nested_function()\n  echo printf('%d',\n      function('len')('xxx'))\nenddef\n\nfunc Test_call_default_args_from_func()\n  call MyDefaultArgs()->assert_equal('string')\n  call MyDefaultArgs('one')->assert_equal('one')\n  call assert_fails('call MyDefaultArgs(\"one\", \"two\")', 'E118:', '', 3, 'Test_call_default_args_from_func')\nendfunc\n\ndef Test_nested_global_function()\n  var lines =<< trim END\n      vim9script\n      def Outer()\n          def g:Inner(): string\n              return 'inner'\n          enddef\n      enddef\n      defcompile\n      Outer()\n      g:Inner()->assert_equal('inner')\n      delfunc g:Inner\n      Outer()\n      g:Inner()->assert_equal('inner')\n      delfunc g:Inner\n      Outer()\n      g:Inner()->assert_equal('inner')\n      delfunc g:Inner\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Outer()\n          func g:Inner()\n            return 'inner'\n          endfunc\n      enddef\n      defcompile\n      Outer()\n      g:Inner()->assert_equal('inner')\n      delfunc g:Inner\n      Outer()\n      g:Inner()->assert_equal('inner')\n      delfunc g:Inner\n      Outer()\n      g:Inner()->assert_equal('inner')\n      delfunc g:Inner\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Outer()\n          def g:Inner(): string\n              return 'inner'\n          enddef\n      enddef\n      defcompile\n      Outer()\n      Outer()\n  END\n  CheckScriptFailure(lines, \"E122:\")\n  delfunc g:Inner\n\n  lines =<< trim END\n      vim9script\n      def Outer()\n        def g:Inner()\n          echo map([1, 2, 3], (_, v) => v + 1)\n        enddef\n        g:Inner()\n      enddef\n      Outer()\n  END\n  CheckScriptSuccess(lines)\n  delfunc g:Inner\n\n  lines =<< trim END\n      vim9script\n      def Func()\n        echo 'script'\n      enddef\n      def Outer()\n        def Func()\n          echo 'inner'\n        enddef\n      enddef\n      defcompile\n  END\n  CheckScriptFailure(lines, \"E1073:\", 1)\n\n  lines =<< trim END\n      vim9script\n      def Func()\n        echo 'script'\n      enddef\n      def Func()\n        echo 'script'\n      enddef\n  END\n  CheckScriptFailure(lines, \"E1073:\", 5)\nenddef\n\ndef DefListAll()\n  def\nenddef\n\ndef DefListOne()\n  def DefListOne\nenddef\n\ndef DefListMatches()\n  def /DefList\nenddef\n\ndef Test_nested_def_list()\n  var funcs = split(execute('call DefListAll()'), \"\\n\")\n  assert_true(len(funcs) > 10)\n  assert_true(funcs->index('def DefListAll()') >= 0)\n\n  funcs = split(execute('call DefListOne()'), \"\\n\")\n  assert_equal(['   def DefListOne()', '1    def DefListOne', '   enddef'], funcs)\n\n  funcs = split(execute('call DefListMatches()'), \"\\n\")\n  assert_true(len(funcs) >= 3)\n  assert_true(funcs->index('def DefListAll()') >= 0)\n  assert_true(funcs->index('def DefListOne()') >= 0)\n  assert_true(funcs->index('def DefListMatches()') >= 0)\n\n  var lines =<< trim END\n    vim9script\n    def Func()\n      def +Func+\n    enddef\n    defcompile\n  END\n  CheckScriptFailure(lines, 'E476:', 1)\nenddef\n\ndef Test_global_local_function()\n  var lines =<< trim END\n      vim9script\n      def g:Func(): string\n          return 'global'\n      enddef\n      def Func(): string\n          return 'local'\n      enddef\n      g:Func()->assert_equal('global')\n      Func()->assert_equal('local')\n      delfunc g:Func\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def g:Funcy()\n        echo 'funcy'\n      enddef\n      s:Funcy()\n  END\n  CheckScriptFailure(lines, 'E117:')\nenddef\n\ndef Test_local_function_shadows_global()\n  var lines =<< trim END\n      vim9script\n      def g:Gfunc(): string\n        return 'global'\n      enddef\n      def AnotherFunc(): number\n        var Gfunc = function('len')\n        return Gfunc('testing')\n      enddef\n      g:Gfunc()->assert_equal('global')\n      AnotherFunc()->assert_equal(7)\n      delfunc g:Gfunc\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def g:Func(): string\n        return 'global'\n      enddef\n      def AnotherFunc()\n        g:Func = function('len')\n      enddef\n      AnotherFunc()\n  END\n  CheckScriptFailure(lines, 'E705:')\n  delfunc g:Func\n\n  # global function is found without g: prefix\n  lines =<< trim END\n      vim9script\n      def g:Func(): string\n        return 'global'\n      enddef\n      def AnotherFunc(): string\n        return Func()\n      enddef\n      assert_equal('global', AnotherFunc())\n    delfunc g:Func\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def g:Func(): string\n        return 'global'\n      enddef\n      assert_equal('global', Func())\n      delfunc g:Func\n  END\n  CheckScriptSuccess(lines)\nenddef\n\nfunc TakesOneArg(arg)\n  echo a:arg\nendfunc\n\ndef Test_call_wrong_args()\n  CheckDefFailure(['TakesOneArg()'], 'E119:')\n  CheckDefFailure(['TakesOneArg(11, 22)'], 'E118:')\n  CheckDefFailure(['bufnr(xxx)'], 'E1001:')\n  CheckScriptFailure(['def Func(Ref: func(s: string))'], 'E475:')\n\n  var lines =<< trim END\n    vim9script\n    def Func(s: string)\n      echo s\n    enddef\n    Func([])\n  END\n  CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch, expected string but got list<unknown>', 5)\n\n  lines =<< trim END\n    vim9script\n    var name = 'piet'\n    def FuncOne(name: string)\n      echo nr\n    enddef\n  END\n  CheckScriptFailure(lines, 'E1168:')\n\n  lines =<< trim END\n    vim9script\n    def FuncOne(nr: number)\n      echo nr\n    enddef\n    def FuncTwo()\n      FuncOne()\n    enddef\n    defcompile\n  END\n  writefile(lines, 'Xscript')\n  var didCatch = false\n  try\n    source Xscript\n  catch\n    assert_match('E119: Not enough arguments for function: <SNR>\\d\\+_FuncOne', v:exception)\n    assert_match('Xscript\\[8\\]..function <SNR>\\d\\+_FuncTwo, line 1', v:throwpoint)\n    didCatch = true\n  endtry\n  assert_true(didCatch)\n\n  lines =<< trim END\n    vim9script\n    def FuncOne(nr: number)\n      echo nr\n    enddef\n    def FuncTwo()\n      FuncOne(1, 2)\n    enddef\n    defcompile\n  END\n  writefile(lines, 'Xscript')\n  didCatch = false\n  try\n    source Xscript\n  catch\n    assert_match('E118: Too many arguments for function: <SNR>\\d\\+_FuncOne', v:exception)\n    assert_match('Xscript\\[8\\]..function <SNR>\\d\\+_FuncTwo, line 1', v:throwpoint)\n    didCatch = true\n  endtry\n  assert_true(didCatch)\n\n  delete('Xscript')\nenddef\n\ndef Test_call_funcref_wrong_args()\n  var head =<< trim END\n      vim9script\n      def Func3(a1: string, a2: number, a3: list<number>)\n        echo a1 .. a2 .. a3[0]\n      enddef\n      def Testme()\n        var funcMap: dict<func> = {func: Func3}\n  END\n  var tail =<< trim END\n      enddef\n      Testme()\n  END\n  CheckScriptSuccess(head + [\"funcMap['func']('str', 123, [1, 2, 3])\"] + tail)\n\n  CheckScriptFailure(head + [\"funcMap['func']('str', 123)\"] + tail, 'E119:')\n  CheckScriptFailure(head + [\"funcMap['func']('str', 123, [1], 4)\"] + tail, 'E118:')\n\n  var lines =<< trim END\n      vim9script\n      var Ref: func(number): any\n      Ref = (j) => !j\n      echo Ref(false)\n  END\n  CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch, expected number but got bool', 4)\n\n  lines =<< trim END\n      vim9script\n      var Ref: func(number): any\n      Ref = (j) => !j\n      call Ref(false)\n  END\n  CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch, expected number but got bool', 4)\nenddef\n\ndef Test_call_lambda_args()\n  var lines =<< trim END\n    var Callback = (..._) => 'anything'\n    assert_equal('anything', Callback())\n    assert_equal('anything', Callback(1))\n    assert_equal('anything', Callback('a', 2))\n\n    assert_equal('xyz', ((a: string): string => a)('xyz'))\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  CheckDefFailure(['echo ((i) => 0)()'],\n                  'E119: Not enough arguments for function: ((i) => 0)()')\n\n  lines =<< trim END\n      var Ref = (x: number, y: number) => x + y\n      echo Ref(1, 'x')\n  END\n  CheckDefFailure(lines, 'E1013: Argument 2: type mismatch, expected number but got string')\n\n  lines =<< trim END\n    var Ref: func(job, string, number)\n    Ref = (x, y) => 0\n  END\n  CheckDefAndScriptFailure(lines, 'E1012:')\n\n  lines =<< trim END\n    var Ref: func(job, string)\n    Ref = (x, y, z) => 0\n  END\n  CheckDefAndScriptFailure(lines, 'E1012:')\n\n  lines =<< trim END\n      var one = 1\n      var l = [1, 2, 3]\n      echo map(l, (one) => one)\n  END\n  CheckDefFailure(lines, 'E1167:')\n  CheckScriptFailure(['vim9script'] + lines, 'E1168:')\n\n  lines =<< trim END\n    var Ref: func(any, ?any): bool\n    Ref = (_, y = 1) => false\n  END\n  CheckDefAndScriptFailure(lines, 'E1172:')\n\n  lines =<< trim END\n      var a = 0\n      var b = (a == 0 ? 1 : 2)\n      assert_equal(1, b)\n      var txt = 'a'\n      b = (txt =~ 'x' ? 1 : 2)\n      assert_equal(2, b)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      def ShadowLocal()\n        var one = 1\n        var l = [1, 2, 3]\n        echo map(l, (one) => one)\n      enddef\n  END\n  CheckDefFailure(lines, 'E1167:')\n\n  lines =<< trim END\n      def Shadowarg(one: number)\n        var l = [1, 2, 3]\n        echo map(l, (one) => one)\n      enddef\n  END\n  CheckDefFailure(lines, 'E1167:')\n\n  lines =<< trim END\n    echo ((a) => a)('aa', 'bb')\n  END\n  CheckDefAndScriptFailure(lines, 'E118:', 1)\n\n  lines =<< trim END\n    echo 'aa'->((a) => a)('bb')\n  END\n  CheckDefFailure(lines, 'E118: Too many arguments for function: ->((a) => a)(''bb'')', 1)\n  CheckScriptFailure(['vim9script'] + lines, 'E118: Too many arguments for function: <lambda>', 2)\nenddef\n\ndef Test_lambda_line_nr()\n  var lines =<< trim END\n      vim9script\n      # comment\n      # comment\n      var id = timer_start(1'000, (_) => 0)\n      var out = execute('verbose ' .. timer_info(id)[0].callback\n          ->string()\n          ->substitute(\"('\\\\|')\", ' ', 'g'))\n      assert_match('Last set from .* line 4', out)\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef FilterWithCond(x: string, Cond: func(string): bool): bool\n  return Cond(x)\nenddef\n\ndef Test_lambda_return_type()\n  var lines =<< trim END\n    var Ref = (): => 123\n  END\n  CheckDefAndScriptFailure(lines, 'E1157:', 1)\n\n  # no space before the return type\n  lines =<< trim END\n    var Ref = (x):number => x + 1\n  END\n  CheckDefAndScriptFailure(lines, 'E1069:', 1)\n\n  # this works\n  for x in ['foo', 'boo']\n    echo FilterWithCond(x, (v) => v =~ '^b')\n  endfor\n\n  # this fails\n  lines =<< trim END\n      echo FilterWithCond('foo', (v) => v .. '^b')\n  END\n  CheckDefAndScriptFailure(lines, 'E1013: Argument 2: type mismatch, expected func(string): bool but got func(any): string', 1)\n\n  lines =<< trim END\n      var Lambda1 = (x) => {\n              return x\n              }\n      assert_equal('asdf', Lambda1('asdf'))\n      var Lambda2 = (x): string => {\n              return x\n              }\n      assert_equal('foo', Lambda2('foo'))\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var Lambda = (x): string => {\n              return x\n              }\n      echo Lambda(['foo'])\n  END\n  CheckDefExecAndScriptFailure(lines, 'E1012:')\nenddef\n\ndef Test_lambda_uses_assigned_var()\n  CheckDefSuccess([\n        'var x: any = \"aaa\"'\n        'x = filter([\"bbb\"], (_, v) => v =~ x)'])\nenddef\n\ndef Test_pass_legacy_lambda_to_def_func()\n  var lines =<< trim END\n      vim9script\n      func Foo()\n        eval s:Bar({x -> 0})\n      endfunc\n      def Bar(y: any)\n      enddef\n      Foo()\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def g:TestFunc(f: func)\n      enddef\n      legacy call g:TestFunc({-> 0})\n      delfunc g:TestFunc\n\n      def g:TestFunc(f: func(number))\n      enddef\n      legacy call g:TestFunc({nr -> 0})\n      delfunc g:TestFunc\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_lambda_in_reduce_line_break()\n  # this was using freed memory\n  var lines =<< trim END\n      vim9script\n      const result: dict<number> =\n          ['Bob', 'Sam', 'Cat', 'Bob', 'Cat', 'Cat']\n          ->reduce((acc, val) => {\n              if has_key(acc, val)\n                  acc[val] += 1\n                  return acc\n              else\n                  acc[val] = 1\n                  return acc\n              endif\n          }, {})\n      assert_equal({Bob: 2, Sam: 1, Cat: 3}, result)\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_set_opfunc_to_lambda()\n  var lines =<< trim END\n    vim9script\n    nnoremap <expr> <F4> <SID>CountSpaces() .. '_'\n    def CountSpaces(type = ''): string\n      if type == ''\n        &operatorfunc = (t) => CountSpaces(t)\n        return 'g@'\n      endif\n      normal! '[V']y\n      g:result = getreg('\"')->count(' ')\n      return ''\n    enddef\n    new\n    'a b c d e'->setline(1)\n    feedkeys(\"\\<F4>\", 'x')\n    assert_equal(4, g:result)\n    bwipe!\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_set_opfunc_to_global_function()\n  var lines =<< trim END\n    vim9script\n    def g:CountSpaces(type = ''): string\n      normal! '[V']y\n      g:result = getreg('\"')->count(' ')\n      return ''\n    enddef\n    # global function works at script level\n    &operatorfunc = g:CountSpaces\n    new\n    'a b c d e'->setline(1)\n    feedkeys(\"g@_\", 'x')\n    assert_equal(4, g:result)\n\n    &operatorfunc = ''\n    g:result = 0\n    # global function works in :def function\n    def Func()\n      &operatorfunc = g:CountSpaces\n    enddef\n    Func()\n    feedkeys(\"g@_\", 'x')\n    assert_equal(4, g:result)\n\n    bwipe!\n  END\n  CheckScriptSuccess(lines)\n  &operatorfunc = ''\nenddef\n\ndef Test_use_script_func_name_with_prefix()\n  var lines =<< trim END\n      vim9script\n      func s:Getit()\n        return 'it'\n      endfunc\n      var Fn = s:Getit\n      assert_equal('it', Fn())\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_lambda_type_allocated()\n  # Check that unreferencing a partial using a lambda can use the variable type\n  # after the lambda has been freed and does not leak memory.\n  var lines =<< trim END\n    vim9script\n\n    func MyomniFunc1(val, findstart, base)\n      return a:findstart ? 0 : []\n    endfunc\n\n    var Lambda = (a, b) => MyomniFunc1(19, a, b)\n    &omnifunc = Lambda\n    Lambda = (a, b) => MyomniFunc1(20, a, b)\n    &omnifunc = string(Lambda)\n    Lambda = (a, b) => strlen(a)\n  END\n  CheckScriptSuccess(lines)\nenddef\n\n\" Default arg and varargs\ndef MyDefVarargs(one: string, two = 'foo', ...rest: list<string>): string\n  var res = one .. ',' .. two\n  for s in rest\n    res ..= ',' .. s\n  endfor\n  return res\nenddef\n\ndef Test_call_def_varargs()\n  assert_fails('MyDefVarargs()', 'E119:', '', 1, 'Test_call_def_varargs')\n  MyDefVarargs('one')->assert_equal('one,foo')\n  MyDefVarargs('one', 'two')->assert_equal('one,two')\n  MyDefVarargs('one', 'two', 'three')->assert_equal('one,two,three')\n  CheckDefFailure(['MyDefVarargs(\"one\", 22)'],\n      'E1013: Argument 2: type mismatch, expected string but got number')\n  CheckDefFailure(['MyDefVarargs(\"one\", \"two\", 123)'],\n      'E1013: Argument 3: type mismatch, expected string but got number')\n\n  var lines =<< trim END\n      vim9script\n      def Func(...l: list<string>)\n        echo l\n      enddef\n      Func('a', 'b', 'c')\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Func(...l: list<string>)\n        echo l\n      enddef\n      Func()\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Func(...l: list<any>)\n        echo l\n      enddef\n      Func(0)\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Func(...l: any)\n        echo l\n      enddef\n      Func(0)\n  END\n  CheckScriptFailure(lines, 'E1180:', 2)\n\n  lines =<< trim END\n      vim9script\n      def Func(..._l: list<string>)\n        echo _l\n      enddef\n      Func('a', 'b', 'c')\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Func(...l: list<string>)\n        echo l\n      enddef\n      Func(1, 2, 3)\n  END\n  CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch')\n\n  lines =<< trim END\n      vim9script\n      def Func(...l: list<string>)\n        echo l\n      enddef\n      Func('a', 9)\n  END\n  CheckScriptFailure(lines, 'E1013: Argument 2: type mismatch')\n\n  lines =<< trim END\n      vim9script\n      def Func(...l: list<string>)\n        echo l\n      enddef\n      Func(1, 'a')\n  END\n  CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch')\n\n  lines =<< trim END\n      vim9script\n      def Func(  # some comment\n                ...l = []\n                )\n        echo l\n      enddef\n  END\n  CheckScriptFailure(lines, 'E1160:')\n\n  lines =<< trim END\n      vim9script\n      def DoIt()\n        g:Later('')\n      enddef\n      defcompile\n      def g:Later(...l:  list<number>)\n      enddef\n      DoIt()\n  END\n  CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch, expected number but got string')\nenddef\n\nlet s:value = ''\n\ndef FuncOneDefArg(opt = 'text')\n  s:value = opt\nenddef\n\ndef FuncTwoDefArg(nr = 123, opt = 'text'): string\n  return nr .. opt\nenddef\n\ndef FuncVarargs(...arg: list<string>): string\n  return join(arg, ',')\nenddef\n\ndef Test_func_type_varargs()\n  var RefDefArg: func(?string)\n  RefDefArg = FuncOneDefArg\n  RefDefArg()\n  s:value->assert_equal('text')\n  RefDefArg('some')\n  s:value->assert_equal('some')\n\n  var RefDef2Arg: func(?number, ?string): string\n  RefDef2Arg = FuncTwoDefArg\n  RefDef2Arg()->assert_equal('123text')\n  RefDef2Arg(99)->assert_equal('99text')\n  RefDef2Arg(77, 'some')->assert_equal('77some')\n\n  CheckDefFailure(['var RefWrong: func(string?)'], 'E1010:')\n  CheckDefFailure(['var RefWrong: func(?string, string)'], 'E1007:')\n\n  var RefVarargs: func(...list<string>): string\n  RefVarargs = FuncVarargs\n  RefVarargs()->assert_equal('')\n  RefVarargs('one')->assert_equal('one')\n  RefVarargs('one', 'two')->assert_equal('one,two')\n\n  CheckDefFailure(['var RefWrong: func(...list<string>, string)'], 'E110:')\n  CheckDefFailure(['var RefWrong: func(...list<string>, ?string)'], 'E110:')\nenddef\n\n\" Only varargs\ndef MyVarargsOnly(...args: list<string>): string\n  return join(args, ',')\nenddef\n\ndef Test_call_varargs_only()\n  MyVarargsOnly()->assert_equal('')\n  MyVarargsOnly('one')->assert_equal('one')\n  MyVarargsOnly('one', 'two')->assert_equal('one,two')\n  CheckDefFailure(['MyVarargsOnly(1)'], 'E1013: Argument 1: type mismatch, expected string but got number')\n  CheckDefFailure(['MyVarargsOnly(\"one\", 2)'], 'E1013: Argument 2: type mismatch, expected string but got number')\nenddef\n\ndef Test_using_var_as_arg()\n  writefile(['def Func(x: number)',  'var x = 234', 'enddef', 'defcompile'], 'Xdef')\n  assert_fails('so Xdef', 'E1006:', '', 1, 'Func')\n  delete('Xdef')\nenddef\n\ndef DictArg(arg: dict<string>)\n  arg['key'] = 'value'\nenddef\n\ndef ListArg(arg: list<string>)\n  arg[0] = 'value'\nenddef\n\ndef Test_assign_to_argument()\n  # works for dict and list\n  var d: dict<string> = {}\n  DictArg(d)\n  d['key']->assert_equal('value')\n  var l: list<string> = []\n  ListArg(l)\n  l[0]->assert_equal('value')\n\n  CheckScriptFailure(['def Func(arg: number)', 'arg = 3', 'enddef', 'defcompile'], 'E1090:')\n  delfunc! g:Func\nenddef\n\n\" These argument names are reserved in legacy functions.\ndef WithReservedNames(firstline: string, lastline: string): string\n  return firstline .. lastline\nenddef\n\ndef Test_argument_names()\n  assert_equal('OK', WithReservedNames('O', 'K'))\nenddef\n\ndef Test_call_func_defined_later()\n  g:DefinedLater('one')->assert_equal('one')\n  assert_fails('NotDefined(\"one\")', 'E117:', '', 2, 'Test_call_func_defined_later')\nenddef\n\nfunc DefinedLater(arg)\n  return a:arg\nendfunc\n\ndef Test_call_funcref()\n  g:SomeFunc('abc')->assert_equal(3)\n  assert_fails('NotAFunc()', 'E117:', '', 2, 'Test_call_funcref') # comment after call\n  assert_fails('g:NotAFunc()', 'E1085:', '', 3, 'Test_call_funcref')\n\n  var lines =<< trim END\n    vim9script\n    def RetNumber(): number\n      return 123\n    enddef\n    var Funcref: func: number = function('RetNumber')\n    Funcref()->assert_equal(123)\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n    vim9script\n    def RetNumber(): number\n      return 123\n    enddef\n    def Bar(F: func: number): number\n      return F()\n    enddef\n    var Funcref = function('RetNumber')\n    Bar(Funcref)->assert_equal(123)\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n    vim9script\n    def UseNumber(nr: number)\n      echo nr\n    enddef\n    var Funcref: func(number) = function('UseNumber')\n    Funcref(123)\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n    vim9script\n    def UseNumber(nr: number)\n      echo nr\n    enddef\n    var Funcref: func(string) = function('UseNumber')\n  END\n  CheckScriptFailure(lines, 'E1012: Type mismatch; expected func(string) but got func(number)')\n\n  lines =<< trim END\n    vim9script\n    def EchoNr(nr = 34)\n      g:echo = nr\n    enddef\n    var Funcref: func(?number) = function('EchoNr')\n    Funcref()\n    g:echo->assert_equal(34)\n    Funcref(123)\n    g:echo->assert_equal(123)\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n    vim9script\n    def EchoList(...l: list<number>)\n      g:echo = l\n    enddef\n    var Funcref: func(...list<number>) = function('EchoList')\n    Funcref()\n    g:echo->assert_equal([])\n    Funcref(1, 2, 3)\n    g:echo->assert_equal([1, 2, 3])\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n    vim9script\n    def OptAndVar(nr: number, opt = 12, ...l: list<number>): number\n      g:optarg = opt\n      g:listarg = l\n      return nr\n    enddef\n    var Funcref: func(number, ?number, ...list<number>): number = function('OptAndVar')\n    Funcref(10)->assert_equal(10)\n    g:optarg->assert_equal(12)\n    g:listarg->assert_equal([])\n\n    Funcref(11, 22)->assert_equal(11)\n    g:optarg->assert_equal(22)\n    g:listarg->assert_equal([])\n\n    Funcref(17, 18, 1, 2, 3)->assert_equal(17)\n    g:optarg->assert_equal(18)\n    g:listarg->assert_equal([1, 2, 3])\n  END\n  CheckScriptSuccess(lines)\nenddef\n\nlet SomeFunc = function('len')\nlet NotAFunc = 'text'\n\ndef CombineFuncrefTypes()\n  # same arguments, different return type\n  var Ref1: func(bool): string\n  var Ref2: func(bool): number\n  var Ref3: func(bool): any\n  Ref3 = g:cond ? Ref1 : Ref2\n\n  # different number of arguments\n  var Refa1: func(bool): number\n  var Refa2: func(bool, number): number\n  var Refa3: func: number\n  Refa3 = g:cond ? Refa1 : Refa2\n\n  # different argument types\n  var Refb1: func(bool, string): number\n  var Refb2: func(string, number): number\n  var Refb3: func(any, any): number\n  Refb3 = g:cond ? Refb1 : Refb2\nenddef\n\ndef FuncWithForwardCall()\n  return g:DefinedEvenLater(\"yes\")\nenddef\n\ndef DefinedEvenLater(arg: string): string\n  return arg\nenddef\n\ndef Test_error_in_nested_function()\n  # Error in called function requires unwinding the call stack.\n  assert_fails('FuncWithForwardCall()', 'E1096:', '', 1, 'FuncWithForwardCall')\nenddef\n\ndef Test_nested_functin_with_nextcmd()\n  var lines =<< trim END\n      vim9script\n      # Define an outer function\n      def FirstFunction()\n        # Define an inner function\n        def SecondFunction()\n          # the function has a body, a double free is detected.\n          AAAAA\n\n         # enddef followed by | or } followed by # one or more characters\n         enddef|BBBB\n      enddef\n\n      # Compile all functions\n      defcompile\n  END\n  CheckScriptFailure(lines, 'E476: Invalid command: AAAAA')\nenddef\n\ndef Test_return_type_wrong()\n  CheckScriptFailure([\n        'def Func(): number',\n        'return \"a\"',\n        'enddef',\n        'defcompile'], 'expected number but got string')\n  delfunc! g:Func\n  CheckScriptFailure([\n        'def Func(): string',\n        'return 1',\n        'enddef',\n        'defcompile'], 'expected string but got number')\n  delfunc! g:Func\n  CheckScriptFailure([\n        'def Func(): void',\n        'return \"a\"',\n        'enddef',\n        'defcompile'],\n        'E1096: Returning a value in a function without a return type')\n  delfunc! g:Func\n  CheckScriptFailure([\n        'def Func()',\n        'return \"a\"',\n        'enddef',\n        'defcompile'],\n        'E1096: Returning a value in a function without a return type')\n  delfunc! g:Func\n\n  CheckScriptFailure([\n        'def Func(): number',\n        'return',\n        'enddef',\n        'defcompile'], 'E1003:')\n  delfunc! g:Func\n\n  CheckScriptFailure([\n        'def Func():number',\n        'return 123',\n        'enddef',\n        'defcompile'], 'E1069:')\n  delfunc! g:Func\n\n  CheckScriptFailure([\n        'def Func() :number',\n        'return 123',\n        'enddef',\n        'defcompile'], 'E1059:')\n  delfunc! g:Func\n\n  CheckScriptFailure([\n        'def Func() : number',\n        'return 123',\n        'enddef',\n        'defcompile'], 'E1059:')\n  delfunc! g:Func\n\n  CheckScriptFailure(['def Func(): list', 'return []', 'enddef'], 'E1008:')\n  delfunc! g:Func\n  CheckScriptFailure(['def Func(): dict', 'return {}', 'enddef'], 'E1008:')\n  delfunc! g:Func\n  CheckScriptFailure(['def Func()', 'return 1'], 'E1057:')\n  delfunc! g:Func\n\n  CheckScriptFailure([\n        'vim9script',\n        'def FuncB()',\n        '  return 123',\n        'enddef',\n        'def FuncA()',\n        '   FuncB()',\n        'enddef',\n        'defcompile'], 'E1096:')\nenddef\n\ndef Test_arg_type_wrong()\n  CheckScriptFailure(['def Func3(items: list)', 'echo \"a\"', 'enddef'], 'E1008: Missing <type>')\n  CheckScriptFailure(['def Func4(...)', 'echo \"a\"', 'enddef'], 'E1055: Missing name after ...')\n  CheckScriptFailure(['def Func5(items:string)', 'echo \"a\"'], 'E1069:')\n  CheckScriptFailure(['def Func5(items)', 'echo \"a\"'], 'E1077:')\n  CheckScriptFailure(['def Func6(...x:list<number>)', 'echo \"a\"', 'enddef'], 'E1069:')\n  CheckScriptFailure(['def Func7(...x: int)', 'echo \"a\"', 'enddef'], 'E1010:')\nenddef\n\ndef Test_white_space_before_comma()\n  var lines =<< trim END\n    vim9script\n    def Func(a: number , b: number)\n    enddef\n  END\n  CheckScriptFailure(lines, 'E1068:')\n  call assert_fails('vim9cmd echo stridx(\"a\" .. \"b\" , \"a\")', 'E1068:')\nenddef\n\ndef Test_white_space_after_comma()\n  var lines =<< trim END\n    vim9script\n    def Func(a: number,b: number)\n    enddef\n  END\n  CheckScriptFailure(lines, 'E1069:')\n\n  # OK in legacy function\n  lines =<< trim END\n    vim9script\n    func Func(a,b)\n    endfunc\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_vim9script_call()\n  var lines =<< trim END\n    vim9script\n    var name = ''\n    def MyFunc(arg: string)\n       name = arg\n    enddef\n    MyFunc('foobar')\n    name->assert_equal('foobar')\n\n    var str = 'barfoo'\n    str->MyFunc()\n    name->assert_equal('barfoo')\n\n    g:value = 'value'\n    g:value->MyFunc()\n    name->assert_equal('value')\n\n    var listvar = []\n    def ListFunc(arg: list<number>)\n       listvar = arg\n    enddef\n    [1, 2, 3]->ListFunc()\n    listvar->assert_equal([1, 2, 3])\n\n    var dictvar = {}\n    def DictFunc(arg: dict<number>)\n       dictvar = arg\n    enddef\n    {a: 1, b: 2}->DictFunc()\n    dictvar->assert_equal({a: 1, b: 2})\n    def CompiledDict()\n      {a: 3, b: 4}->DictFunc()\n    enddef\n    CompiledDict()\n    dictvar->assert_equal({a: 3, b: 4})\n\n    {a: 3, b: 4}->DictFunc()\n    dictvar->assert_equal({a: 3, b: 4})\n\n    ('text')->MyFunc()\n    name->assert_equal('text')\n    (\"some\")->MyFunc()\n    name->assert_equal('some')\n\n    # line starting with single quote is not a mark\n    # line starting with double quote can be a method call\n    'asdfasdf'->MyFunc()\n    name->assert_equal('asdfasdf')\n    \"xyz\"->MyFunc()\n    name->assert_equal('xyz')\n\n    def UseString()\n      'xyork'->MyFunc()\n    enddef\n    UseString()\n    name->assert_equal('xyork')\n\n    def UseString2()\n      \"knife\"->MyFunc()\n    enddef\n    UseString2()\n    name->assert_equal('knife')\n\n    # prepending a colon makes it a mark\n    new\n    setline(1, ['aaa', 'bbb', 'ccc'])\n    normal! 3Gmt1G\n    :'t\n    getcurpos()[1]->assert_equal(3)\n    bwipe!\n\n    MyFunc(\n        'continued'\n        )\n    assert_equal('continued',\n            name\n            )\n\n    call MyFunc(\n        'more'\n          ..\n          'lines'\n        )\n    assert_equal(\n        'morelines',\n        name)\n  END\n  writefile(lines, 'Xcall.vim')\n  source Xcall.vim\n  delete('Xcall.vim')\nenddef\n\ndef Test_vim9script_call_fail_decl()\n  var lines =<< trim END\n    vim9script\n    var name = ''\n    def MyFunc(arg: string)\n       var name = 123\n    enddef\n    defcompile\n  END\n  CheckScriptFailure(lines, 'E1054:')\nenddef\n\ndef Test_vim9script_call_fail_type()\n  var lines =<< trim END\n    vim9script\n    def MyFunc(arg: string)\n      echo arg\n    enddef\n    MyFunc(1234)\n  END\n  CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch, expected string but got number')\nenddef\n\ndef Test_vim9script_call_fail_const()\n  var lines =<< trim END\n    vim9script\n    const var = ''\n    def MyFunc(arg: string)\n       var = 'asdf'\n    enddef\n    defcompile\n  END\n  writefile(lines, 'Xcall_const.vim')\n  assert_fails('source Xcall_const.vim', 'E46:', '', 1, 'MyFunc')\n  delete('Xcall_const.vim')\n\n  lines =<< trim END\n      const g:Aconst = 77\n      def Change()\n        # comment\n        g:Aconst = 99\n      enddef\n      call Change()\n      unlet g:Aconst\n  END\n  CheckScriptFailure(lines, 'E741: Value is locked: Aconst', 2)\nenddef\n\n\" Test that inside :function a Python function can be defined, :def is not\n\" recognized.\nfunc Test_function_python()\n  CheckFeature python3\n  let py = 'python3'\n  execute py \"<< EOF\"\ndef do_something():\n  return 1\nEOF\nendfunc\n\ndef Test_delfunc()\n  var lines =<< trim END\n    vim9script\n    def g:GoneSoon()\n      echo 'hello'\n    enddef\n\n    def CallGoneSoon()\n      GoneSoon()\n    enddef\n    defcompile\n\n    delfunc g:GoneSoon\n    CallGoneSoon()\n  END\n  writefile(lines, 'XToDelFunc')\n  assert_fails('so XToDelFunc', 'E933:', '', 1, 'CallGoneSoon')\n  assert_fails('so XToDelFunc', 'E933:', '', 1, 'CallGoneSoon')\n\n  delete('XToDelFunc')\nenddef\n\nfunc Test_free_dict_while_in_funcstack()\n  \" relies on the sleep command\n  CheckUnix\n  call Run_Test_free_dict_while_in_funcstack()\nendfunc\n\ndef Run_Test_free_dict_while_in_funcstack()\n\n  # this was freeing the TermRun() default argument dictionary while it was\n  # still referenced in a funcstack_T\n  var lines =<< trim END\n      vim9script\n\n      &updatetime = 400\n      def TermRun(_ = {})\n          def Post()\n          enddef\n          def Exec()\n              term_start('sleep 1', {\n                  term_finish: 'close',\n                  exit_cb: (_, _) => Post(),\n              })\n          enddef\n          Exec()\n      enddef\n      nnoremap <F4> <Cmd>call <SID>TermRun()<CR>\n      timer_start(100, (_) => feedkeys(\"\\<F4>\"))\n      timer_start(1000, (_) => feedkeys(\"\\<F4>\"))\n      sleep 1500m\n  END\n  CheckScriptSuccess(lines)\n  nunmap <F4>\n  set updatetime&\nenddef\n\ndef Test_redef_failure()\n  writefile(['def Func0(): string',  'return \"Func0\"', 'enddef'], 'Xdef')\n  so Xdef\n  writefile(['def Func1(): string',  'return \"Func1\"', 'enddef'], 'Xdef')\n  so Xdef\n  writefile(['def! Func0(): string', 'enddef', 'defcompile'], 'Xdef')\n  assert_fails('so Xdef', 'E1027:', '', 1, 'Func0')\n  writefile(['def Func2(): string',  'return \"Func2\"', 'enddef'], 'Xdef')\n  so Xdef\n  delete('Xdef')\n\n  assert_fails('g:Func0()', 'E1091:')\n  g:Func1()->assert_equal('Func1')\n  g:Func2()->assert_equal('Func2')\n\n  delfunc! Func0\n  delfunc! Func1\n  delfunc! Func2\nenddef\n\ndef Test_vim9script_func()\n  var lines =<< trim END\n    vim9script\n    func Func(arg)\n      echo a:arg\n    endfunc\n    Func('text')\n  END\n  writefile(lines, 'XVim9Func')\n  so XVim9Func\n\n  delete('XVim9Func')\nenddef\n\nlet s:funcResult = 0\n\ndef FuncNoArgNoRet()\n  s:funcResult = 11\nenddef\n\ndef FuncNoArgRetNumber(): number\n  s:funcResult = 22\n  return 1234\nenddef\n\ndef FuncNoArgRetString(): string\n  s:funcResult = 45\n  return 'text'\nenddef\n\ndef FuncOneArgNoRet(arg: number)\n  s:funcResult = arg\nenddef\n\ndef FuncOneArgRetNumber(arg: number): number\n  s:funcResult = arg\n  return arg\nenddef\n\ndef FuncTwoArgNoRet(one: bool, two: number)\n  s:funcResult = two\nenddef\n\ndef FuncOneArgRetString(arg: string): string\n  return arg\nenddef\n\ndef FuncOneArgRetAny(arg: any): any\n  return arg\nenddef\n\ndef Test_func_type()\n  var Ref1: func()\n  s:funcResult = 0\n  Ref1 = FuncNoArgNoRet\n  Ref1()\n  s:funcResult->assert_equal(11)\n\n  var Ref2: func\n  s:funcResult = 0\n  Ref2 = FuncNoArgNoRet\n  Ref2()\n  s:funcResult->assert_equal(11)\n\n  s:funcResult = 0\n  Ref2 = FuncOneArgNoRet\n  Ref2(12)\n  s:funcResult->assert_equal(12)\n\n  s:funcResult = 0\n  Ref2 = FuncNoArgRetNumber\n  Ref2()->assert_equal(1234)\n  s:funcResult->assert_equal(22)\n\n  s:funcResult = 0\n  Ref2 = FuncOneArgRetNumber\n  Ref2(13)->assert_equal(13)\n  s:funcResult->assert_equal(13)\nenddef\n\ndef Test_repeat_return_type()\n  var res = 0\n  for n in repeat([1], 3)\n    res += n\n  endfor\n  res->assert_equal(3)\n\n  res = 0\n  for n in add([1, 2], 3)\n    res += n\n  endfor\n  res->assert_equal(6)\nenddef\n\ndef Test_argv_return_type()\n  next fileone filetwo\n  var res = ''\n  for name in argv()\n    res ..= name\n  endfor\n  res->assert_equal('fileonefiletwo')\nenddef\n\ndef Test_func_type_part()\n  var RefVoid: func: void\n  RefVoid = FuncNoArgNoRet\n  RefVoid = FuncOneArgNoRet\n  CheckDefFailure(['var RefVoid: func: void', 'RefVoid = FuncNoArgRetNumber'], 'E1012: Type mismatch; expected func(...) but got func(): number')\n  CheckDefFailure(['var RefVoid: func: void', 'RefVoid = FuncNoArgRetString'], 'E1012: Type mismatch; expected func(...) but got func(): string')\n\n  var RefAny: func(): any\n  RefAny = FuncNoArgRetNumber\n  RefAny = FuncNoArgRetString\n  CheckDefFailure(['var RefAny: func(): any', 'RefAny = FuncNoArgNoRet'], 'E1012: Type mismatch; expected func(): any but got func()')\n  CheckDefFailure(['var RefAny: func(): any', 'RefAny = FuncOneArgNoRet'], 'E1012: Type mismatch; expected func(): any but got func(number)')\n\n  var RefAnyNoArgs: func: any = RefAny\n\n  var RefNr: func: number\n  RefNr = FuncNoArgRetNumber\n  RefNr = FuncOneArgRetNumber\n  CheckDefFailure(['var RefNr: func: number', 'RefNr = FuncNoArgNoRet'], 'E1012: Type mismatch; expected func(...): number but got func()')\n  CheckDefFailure(['var RefNr: func: number', 'RefNr = FuncNoArgRetString'], 'E1012: Type mismatch; expected func(...): number but got func(): string')\n\n  var RefStr: func: string\n  RefStr = FuncNoArgRetString\n  RefStr = FuncOneArgRetString\n  CheckDefFailure(['var RefStr: func: string', 'RefStr = FuncNoArgNoRet'], 'E1012: Type mismatch; expected func(...): string but got func()')\n  CheckDefFailure(['var RefStr: func: string', 'RefStr = FuncNoArgRetNumber'], 'E1012: Type mismatch; expected func(...): string but got func(): number')\nenddef\n\ndef Test_func_type_fails()\n  CheckDefFailure(['var ref1: func()'], 'E704:')\n\n  CheckDefFailure(['var Ref1: func()', 'Ref1 = FuncNoArgRetNumber'], 'E1012: Type mismatch; expected func() but got func(): number')\n  CheckDefFailure(['var Ref1: func()', 'Ref1 = FuncOneArgNoRet'], 'E1012: Type mismatch; expected func() but got func(number)')\n  CheckDefFailure(['var Ref1: func()', 'Ref1 = FuncOneArgRetNumber'], 'E1012: Type mismatch; expected func() but got func(number): number')\n  CheckDefFailure(['var Ref1: func(bool)', 'Ref1 = FuncTwoArgNoRet'], 'E1012: Type mismatch; expected func(bool) but got func(bool, number)')\n  CheckDefFailure(['var Ref1: func(?bool)', 'Ref1 = FuncTwoArgNoRet'], 'E1012: Type mismatch; expected func(?bool) but got func(bool, number)')\n  CheckDefFailure(['var Ref1: func(...bool)', 'Ref1 = FuncTwoArgNoRet'], 'E1012: Type mismatch; expected func(...bool) but got func(bool, number)')\n\n  CheckDefFailure(['var RefWrong: func(string ,number)'], 'E1068:')\n  CheckDefFailure(['var RefWrong: func(string,number)'], 'E1069:')\n  CheckDefFailure(['var RefWrong: func(bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool)'], 'E1005:')\n  CheckDefFailure(['var RefWrong: func(bool):string'], 'E1069:')\nenddef\n\ndef Test_func_return_type()\n  var nr: number\n  nr = FuncNoArgRetNumber()\n  nr->assert_equal(1234)\n\n  nr = FuncOneArgRetAny(122)\n  nr->assert_equal(122)\n\n  var str: string\n  str = FuncOneArgRetAny('yes')\n  str->assert_equal('yes')\n\n  CheckDefFailure(['var str: string', 'str = FuncNoArgRetNumber()'], 'E1012: Type mismatch; expected string but got number')\nenddef\n\ndef Test_func_common_type()\n  def FuncOne(n: number): number\n    return n\n  enddef\n  def FuncTwo(s: string): number\n    return len(s)\n  enddef\n  def FuncThree(n: number, s: string): number\n    return n + len(s)\n  enddef\n  var list = [FuncOne, FuncTwo, FuncThree]\n  assert_equal(8, list[0](8))\n  assert_equal(4, list[1]('word'))\n  assert_equal(7, list[2](3, 'word'))\nenddef\n\ndef MultiLine(\n    arg1: string,\n    arg2 = 1234,\n    ...rest: list<string>\n      ): string\n  return arg1 .. arg2 .. join(rest, '-')\nenddef\n\ndef MultiLineComment(\n    arg1: string, # comment\n    arg2 = 1234, # comment\n    ...rest: list<string> # comment\n      ): string # comment\n  return arg1 .. arg2 .. join(rest, '-')\nenddef\n\ndef Test_multiline()\n  MultiLine('text')->assert_equal('text1234')\n  MultiLine('text', 777)->assert_equal('text777')\n  MultiLine('text', 777, 'one')->assert_equal('text777one')\n  MultiLine('text', 777, 'one', 'two')->assert_equal('text777one-two')\nenddef\n\nfunc Test_multiline_not_vim9()\n  call MultiLine('text')->assert_equal('text1234')\n  call MultiLine('text', 777)->assert_equal('text777')\n  call MultiLine('text', 777, 'one')->assert_equal('text777one')\n  call MultiLine('text', 777, 'one', 'two')->assert_equal('text777one-two')\nendfunc\n\n\n\" When using CheckScriptFailure() for the below test, E1010 is generated instead\n\" of E1056.\nfunc Test_E1056_1059()\n  let caught_1056 = 0\n  try\n    def F():\n      return 1\n    enddef\n  catch /E1056:/\n    let caught_1056 = 1\n  endtry\n  eval caught_1056->assert_equal(1)\n\n  let caught_1059 = 0\n  try\n    def F5(items : list)\n      echo 'a'\n    enddef\n  catch /E1059:/\n    let caught_1059 = 1\n  endtry\n  eval caught_1059->assert_equal(1)\nendfunc\n\nfunc DelMe()\n  echo 'DelMe'\nendfunc\n\ndef Test_error_reporting()\n  # comment lines at the start of the function\n  var lines =<< trim END\n    \" comment\n    def Func()\n      # comment\n      # comment\n      invalid\n    enddef\n    defcompile\n  END\n  writefile(lines, 'Xdef')\n  try\n    source Xdef\n    assert_report('should have failed')\n  catch /E476:/\n    v:exception->assert_match('Invalid command: invalid')\n    v:throwpoint->assert_match(', line 3$')\n  endtry\n  delfunc! g:Func\n\n  # comment lines after the start of the function\n  lines =<< trim END\n    \" comment\n    def Func()\n      var x = 1234\n      # comment\n      # comment\n      invalid\n    enddef\n    defcompile\n  END\n  writefile(lines, 'Xdef')\n  try\n    source Xdef\n    assert_report('should have failed')\n  catch /E476:/\n    v:exception->assert_match('Invalid command: invalid')\n    v:throwpoint->assert_match(', line 4$')\n  endtry\n  delfunc! g:Func\n\n  lines =<< trim END\n    vim9script\n    def Func()\n      var db = {foo: 1, bar: 2}\n      # comment\n      var x = db.asdf\n    enddef\n    defcompile\n    Func()\n  END\n  writefile(lines, 'Xdef')\n  try\n    source Xdef\n    assert_report('should have failed')\n  catch /E716:/\n    v:throwpoint->assert_match('_Func, line 3$')\n  endtry\n  delfunc! g:Func\n\n  delete('Xdef')\nenddef\n\ndef Test_deleted_function()\n  CheckDefExecFailure([\n      'var RefMe: func = function(\"g:DelMe\")',\n      'delfunc g:DelMe',\n      'echo RefMe()'], 'E117:')\nenddef\n\ndef Test_unknown_function()\n  CheckDefExecFailure([\n      'var Ref: func = function(\"NotExist\")',\n      'delfunc g:NotExist'], 'E700:')\nenddef\n\ndef RefFunc(Ref: func(any): any): string\n  return Ref('more')\nenddef\n\ndef Test_closure_simple()\n  var local = 'some '\n  RefFunc((s) => local .. s)->assert_equal('some more')\nenddef\n\ndef MakeRef()\n  var local = 'some '\n  g:Ref = (s) => local .. s\nenddef\n\ndef Test_closure_ref_after_return()\n  MakeRef()\n  g:Ref('thing')->assert_equal('some thing')\n  unlet g:Ref\nenddef\n\ndef MakeTwoRefs()\n  var local = ['some']\n  g:Extend = (s) => local->add(s)\n  g:Read = () => local\nenddef\n\ndef Test_closure_two_refs()\n  MakeTwoRefs()\n  join(g:Read(), ' ')->assert_equal('some')\n  g:Extend('more')\n  join(g:Read(), ' ')->assert_equal('some more')\n  g:Extend('even')\n  join(g:Read(), ' ')->assert_equal('some more even')\n\n  unlet g:Extend\n  unlet g:Read\nenddef\n\ndef ReadRef(Ref: func(): list<string>): string\n  return join(Ref(), ' ')\nenddef\n\ndef ExtendRef(Ref: func(string): list<string>, add: string)\n  Ref(add)\nenddef\n\ndef Test_closure_two_indirect_refs()\n  MakeTwoRefs()\n  ReadRef(g:Read)->assert_equal('some')\n  ExtendRef(g:Extend, 'more')\n  ReadRef(g:Read)->assert_equal('some more')\n  ExtendRef(g:Extend, 'even')\n  ReadRef(g:Read)->assert_equal('some more even')\n\n  unlet g:Extend\n  unlet g:Read\nenddef\n\ndef MakeArgRefs(theArg: string)\n  var local = 'loc_val'\n  g:UseArg = (s) => theArg .. '/' .. local .. '/' .. s\nenddef\n\ndef MakeArgRefsVarargs(theArg: string, ...rest: list<string>)\n  var local = 'the_loc'\n  g:UseVararg = (s) => theArg .. '/' .. local .. '/' .. s .. '/' .. join(rest)\nenddef\n\ndef Test_closure_using_argument()\n  MakeArgRefs('arg_val')\n  g:UseArg('call_val')->assert_equal('arg_val/loc_val/call_val')\n\n  MakeArgRefsVarargs('arg_val', 'one', 'two')\n  g:UseVararg('call_val')->assert_equal('arg_val/the_loc/call_val/one two')\n\n  unlet g:UseArg\n  unlet g:UseVararg\n\n  var lines =<< trim END\n      vim9script\n      def Test(Fun: func(number): number): list<number>\n        return map([1, 2, 3], (_, i) => Fun(i))\n      enddef\n      def Inc(nr: number): number\n        return nr + 2\n      enddef\n      assert_equal([3, 4, 5], Test(Inc))\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef MakeGetAndAppendRefs()\n  var local = 'a'\n\n  def Append(arg: string)\n    local ..= arg\n  enddef\n  g:Append = Append\n\n  def Get(): string\n    return local\n  enddef\n  g:Get = Get\nenddef\n\ndef Test_closure_append_get()\n  MakeGetAndAppendRefs()\n  g:Get()->assert_equal('a')\n  g:Append('-b')\n  g:Get()->assert_equal('a-b')\n  g:Append('-c')\n  g:Get()->assert_equal('a-b-c')\n\n  unlet g:Append\n  unlet g:Get\nenddef\n\ndef Test_nested_closure()\n  var local = 'text'\n  def Closure(arg: string): string\n    return local .. arg\n  enddef\n  Closure('!!!')->assert_equal('text!!!')\nenddef\n\nfunc GetResult(Ref)\n  return a:Ref('some')\nendfunc\n\ndef Test_call_closure_not_compiled()\n  var text = 'text'\n  g:Ref = (s) =>  s .. text\n  GetResult(g:Ref)->assert_equal('sometext')\nenddef\n\ndef Test_double_closure_fails()\n  var lines =<< trim END\n    vim9script\n    def Func()\n      var name = 0\n      for i in range(2)\n          timer_start(0, () => name)\n      endfor\n    enddef\n    Func()\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_nested_closure_used()\n  var lines =<< trim END\n      vim9script\n      def Func()\n        var x = 'hello'\n        var Closure = () => x\n        g:Myclosure = () => Closure()\n      enddef\n      Func()\n      assert_equal('hello', g:Myclosure())\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_nested_closure_fails()\n  var lines =<< trim END\n    vim9script\n    def FuncA()\n      FuncB(0)\n    enddef\n    def FuncB(n: number): list<string>\n      return map([0], (_, v) => n)\n    enddef\n    FuncA()\n  END\n  CheckScriptFailure(lines, 'E1012:')\nenddef\n\ndef Test_global_closure()\n  var lines =<< trim END\n      vim9script\n      def ReverseEveryNLines(n: number, line1: number, line2: number)\n        var mods = 'sil keepj keepp lockm '\n        var range = ':' .. line1 .. ',' .. line2\n        def g:Offset(): number\n            var offset = (line('.') - line1 + 1) % n\n            return offset != 0 ? offset : n\n        enddef\n        exe mods .. range .. 'g/^/exe \"m .-\" .. g:Offset()'\n      enddef\n\n      new\n      repeat(['aaa', 'bbb', 'ccc'], 3)->setline(1)\n      ReverseEveryNLines(3, 1, 9)\n  END\n  CheckScriptSuccess(lines)\n  var expected = repeat(['ccc', 'bbb', 'aaa'], 3)\n  assert_equal(expected, getline(1, 9))\n  bwipe!\nenddef\n\ndef Test_global_closure_called_directly()\n  var lines =<< trim END\n      vim9script\n      def Outer()\n        var x = 1\n        def g:Inner()\n          var y = x\n          x += 1\n          assert_equal(1, y)\n        enddef\n        g:Inner()\n        assert_equal(2, x)\n      enddef\n      Outer()\n  END\n  CheckScriptSuccess(lines)\n  delfunc g:Inner\nenddef\n\ndef Test_closure_called_from_legacy()\n  var lines =<< trim END\n      vim9script\n      def Func()\n        var outer = 'foo'\n        var F = () => {\n              outer = 'bar'\n            }\n        execute printf('call %s()', string(F))\n      enddef\n      Func()\n  END\n  CheckScriptFailure(lines, 'E1248')\nenddef\n\ndef Test_failure_in_called_function()\n  # this was using the frame index as the return value\n  var lines =<< trim END\n      vim9script\n      au TerminalWinOpen * eval [][0]\n      def PopupTerm(a: any)\n        # make sure typvals on stack are string\n        ['a', 'b', 'c', 'd', 'e', 'f', 'g']->join()\n        FireEvent()\n      enddef\n      def FireEvent()\n          do TerminalWinOpen\n      enddef\n      # use try/catch to make eval fail\n      try\n          call PopupTerm(0)\n      catch\n      endtry\n      au! TerminalWinOpen\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_nested_lambda()\n  var lines =<< trim END\n    vim9script\n    def Func()\n      var x = 4\n      var Lambda1 = () => 7\n      var Lambda2 = () => [Lambda1(), x]\n      var res = Lambda2()\n      assert_equal([7, 4], res)\n    enddef\n    Func()\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_double_nested_lambda()\n  var lines =<< trim END\n      vim9script\n      def F(head: string): func(string): func(string): string\n        return (sep: string): func(string): string => ((tail: string): string => {\n            return head .. sep .. tail\n          })\n      enddef\n      assert_equal('hello-there', F('hello')('-')('there'))\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_nested_inline_lambda()\n  var lines =<< trim END\n      vim9script\n      def F(text: string): func(string): func(string): string\n        return (arg: string): func(string): string => ((sep: string): string => {\n            return sep .. arg .. text\n          })\n      enddef\n      assert_equal('--there++', F('++')('there')('--'))\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      echo range(4)->mapnew((_, v) => {\n        return range(v) ->mapnew((_, s) => {\n          return string(s)\n          })\n        })\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n\n      def s:func()\n        range(10)\n          ->mapnew((_, _) => ({\n            key: range(10)->mapnew((_, _) => {\n              return ' '\n            }),\n          }))\n      enddef\n\n      defcomp\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Shadowed(): list<number>\n  var FuncList: list<func: number> = [() => 42]\n  return FuncList->mapnew((_, Shadowed) => Shadowed())\nenddef\n\ndef Test_lambda_arg_shadows_func()\n  assert_equal([42], Shadowed())\nenddef\n\ndef Line_continuation_in_def(dir: string = ''): string\n  var path: string = empty(dir)\n          \\ ? 'empty'\n          \\ : 'full'\n  return path\nenddef\n\ndef Test_line_continuation_in_def()\n  Line_continuation_in_def('.')->assert_equal('full')\nenddef\n\ndef Test_script_var_in_lambda()\n  var lines =<< trim END\n      vim9script\n      var script = 'test'\n      assert_equal(['test'], map(['one'], (_, _) => script))\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Line_continuation_in_lambda(): list<string>\n  var x = range(97, 100)\n      ->mapnew((_, v) => nr2char(v)\n          ->toupper())\n      ->reverse()\n  return x\nenddef\n\ndef Test_line_continuation_in_lambda()\n  Line_continuation_in_lambda()->assert_equal(['D', 'C', 'B', 'A'])\n\n  var lines =<< trim END\n      vim9script\n      var res = [{n: 1, m: 2, s: 'xxx'}]\n                ->mapnew((_, v: dict<any>): string => printf('%d:%d:%s',\n                    v.n,\n                    v.m,\n                    substitute(v.s, '.*', 'yyy', '')\n                    ))\n      assert_equal(['1:2:yyy'], res)\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_list_lambda()\n  timer_start(1000, (_) => 0)\n  var body = execute(timer_info()[0].callback\n         ->string()\n         ->substitute(\"('\", ' ', '')\n         ->substitute(\"')\", '', '')\n         ->substitute('function\\zs', ' ', ''))\n  assert_match('def <lambda>\\d\\+(_: any): number\\n1  return 0\\n   enddef', body)\nenddef\n\ndef Test_lambda_block_variable()\n  var lines =<< trim END\n      vim9script\n      var flist: list<func>\n      for i in range(10)\n          var inloop = i\n          flist[i] = () => inloop\n      endfor\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      if true\n        var outloop = 5\n        var flist: list<func>\n        for i in range(10)\n          flist[i] = () => outloop\n        endfor\n      endif\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      if true\n        var outloop = 5\n      endif\n      var flist: list<func>\n      for i in range(10)\n        flist[i] = () => outloop\n      endfor\n  END\n  CheckScriptFailure(lines, 'E1001: Variable not found: outloop', 1)\n\n  lines =<< trim END\n      vim9script\n      for i in range(10)\n        var Ref = () => 0\n      endfor\n      assert_equal(0, ((i) => 0)(0))\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_legacy_lambda()\n  legacy echo {x -> 'hello ' .. x}('foo')\n\n  var lines =<< trim END\n      echo {x -> 'hello ' .. x}('foo')\n  END\n  CheckDefAndScriptFailure(lines, 'E720:')\n\n  lines =<< trim END\n      vim9script\n      def Func()\n        echo (() => 'no error')()\n      enddef\n      legacy call s:Func()\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_legacy()\n  var lines =<< trim END\n      vim9script\n      func g:LegacyFunction()\n        let g:legacyvar = 1\n      endfunc\n      def Testit()\n        legacy call g:LegacyFunction()\n      enddef\n      Testit()\n      assert_equal(1, g:legacyvar)\n      unlet g:legacyvar\n      delfunc g:LegacyFunction\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_legacy_errors()\n  for cmd in ['if', 'elseif', 'else', 'endif',\n              'for', 'endfor', 'continue', 'break',\n              'while', 'endwhile',\n              'try', 'catch', 'finally', 'endtry']\n    CheckDefFailure(['legacy ' .. cmd .. ' expr'], 'E1189:')\n  endfor\nenddef\n\ndef Test_call_legacy_with_dict()\n  var lines =<< trim END\n      vim9script\n      func Legacy() dict\n        let g:result = self.value\n      endfunc\n      def TestDirect()\n        var d = {value: 'yes', func: Legacy}\n        d.func()\n      enddef\n      TestDirect()\n      assert_equal('yes', g:result)\n      unlet g:result\n\n      def TestIndirect()\n        var d = {value: 'foo', func: Legacy}\n        var Fi = d.func\n        Fi()\n      enddef\n      TestIndirect()\n      assert_equal('foo', g:result)\n      unlet g:result\n\n      var d = {value: 'bar', func: Legacy}\n      d.func()\n      assert_equal('bar', g:result)\n      unlet g:result\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef DoFilterThis(a: string): list<string>\n  # closure nested inside another closure using argument\n  var Filter = (l) => filter(l, (_, v) => stridx(v, a) == 0)\n  return ['x', 'y', 'a', 'x2', 'c']->Filter()\nenddef\n\ndef Test_nested_closure_using_argument()\n  assert_equal(['x', 'x2'], DoFilterThis('x'))\nenddef\n\ndef Test_triple_nested_closure()\n  var what = 'x'\n  var Match = (val: string, cmp: string): bool => stridx(val, cmp) == 0\n  var Filter = (l) => filter(l, (_, v) => Match(v, what))\n  assert_equal(['x', 'x2'], ['x', 'y', 'a', 'x2', 'c']->Filter())\nenddef\n\nfunc Test_silent_echo()\n  CheckScreendump\n  call Run_Test_silent_echo()\nendfunc\n\ndef Run_Test_silent_echo()\n  var lines =<< trim END\n    vim9script\n    def EchoNothing()\n      silent echo ''\n    enddef\n    defcompile\n  END\n  writefile(lines, 'XTest_silent_echo')\n\n  # Check that the balloon shows up after a mouse move\n  var buf = RunVimInTerminal('-S XTest_silent_echo', {'rows': 6})\n  term_sendkeys(buf, \":abc\")\n  VerifyScreenDump(buf, 'Test_vim9_silent_echo', {})\n\n  # clean up\n  StopVimInTerminal(buf)\n  delete('XTest_silent_echo')\nenddef\n\ndef SilentlyError()\n  execute('silent! invalid')\n  g:did_it = 'yes'\nenddef\n\nfunc UserError()\n  silent! invalid\nendfunc\n\ndef SilentlyUserError()\n  UserError()\n  g:did_it = 'yes'\nenddef\n\n\" This can't be a :def function, because the assert would not be reached.\nfunc Test_ignore_silent_error()\n  let g:did_it = 'no'\n  call SilentlyError()\n  call assert_equal('yes', g:did_it)\n\n  let g:did_it = 'no'\n  call SilentlyUserError()\n  call assert_equal('yes', g:did_it)\n\n  unlet g:did_it\nendfunc\n\ndef Test_ignore_silent_error_in_filter()\n  var lines =<< trim END\n      vim9script\n      def Filter(winid: number, key: string): bool\n          if key == 'o'\n              silent! eval [][0]\n              return true\n          endif\n          return popup_filter_menu(winid, key)\n      enddef\n\n      popup_create('popup', {filter: Filter})\n      feedkeys(\"o\\r\", 'xnt')\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Fibonacci(n: number): number\n  if n < 2\n    return n\n  else\n    return Fibonacci(n - 1) + Fibonacci(n - 2)\n  endif\nenddef\n\ndef Test_recursive_call()\n  Fibonacci(20)->assert_equal(6765)\nenddef\n\ndef TreeWalk(dir: string): list<any>\n  return readdir(dir)->mapnew((_, val) =>\n            fnamemodify(dir .. '/' .. val, ':p')->isdirectory()\n               ? {[val]: TreeWalk(dir .. '/' .. val)}\n               : val\n             )\nenddef\n\ndef Test_closure_in_map()\n  mkdir('XclosureDir/tdir', 'p')\n  writefile(['111'], 'XclosureDir/file1')\n  writefile(['222'], 'XclosureDir/file2')\n  writefile(['333'], 'XclosureDir/tdir/file3')\n\n  TreeWalk('XclosureDir')->assert_equal(['file1', 'file2', {tdir: ['file3']}])\n\n  delete('XclosureDir', 'rf')\nenddef\n\ndef Test_invalid_function_name()\n  var lines =<< trim END\n      vim9script\n      def s: list<string>\n  END\n  CheckScriptFailure(lines, 'E129:')\n\n  lines =<< trim END\n      vim9script\n      def g: list<string>\n  END\n  CheckScriptFailure(lines, 'E129:')\n\n  lines =<< trim END\n      vim9script\n      def <SID>: list<string>\n  END\n  CheckScriptFailure(lines, 'E884:')\n\n  lines =<< trim END\n      vim9script\n      def F list<string>\n  END\n  CheckScriptFailure(lines, 'E488:')\nenddef\n\ndef Test_partial_call()\n  var lines =<< trim END\n      var Xsetlist: func\n      Xsetlist = function('setloclist', [0])\n      Xsetlist([], ' ', {title: 'test'})\n      getloclist(0, {title: 1})->assert_equal({title: 'test'})\n\n      Xsetlist = function('setloclist', [0, [], ' '])\n      Xsetlist({title: 'test'})\n      getloclist(0, {title: 1})->assert_equal({title: 'test'})\n\n      Xsetlist = function('setqflist')\n      Xsetlist([], ' ', {title: 'test'})\n      getqflist({title: 1})->assert_equal({title: 'test'})\n\n      Xsetlist = function('setqflist', [[], ' '])\n      Xsetlist({title: 'test'})\n      getqflist({title: 1})->assert_equal({title: 'test'})\n\n      var Len: func: number = function('len', ['word'])\n      assert_equal(4, Len())\n\n      var RepeatFunc = function('repeat', ['o'])\n      assert_equal('ooooo', RepeatFunc(5))\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Foo(Parser: any)\n      enddef\n      var Expr: func(dict<any>): dict<any>\n      const Call = Foo(Expr)\n  END\n  CheckScriptFailure(lines, 'E1235:')\nenddef\n\ndef Test_cmd_modifier()\n  tab echo '0'\n  CheckDefFailure(['5tab echo 3'], 'E16:')\nenddef\n\ndef Test_restore_modifiers()\n  # check that when compiling a :def function command modifiers are not messed\n  # up.\n  var lines =<< trim END\n      vim9script\n      set eventignore=\n      autocmd QuickFixCmdPost * copen\n      def AutocmdsDisabled()\n        eval 1 + 2\n      enddef\n      func Func()\n        noautocmd call s:AutocmdsDisabled()\n        let g:ei_after = &eventignore\n      endfunc\n      Func()\n  END\n  CheckScriptSuccess(lines)\n  g:ei_after->assert_equal('')\nenddef\n\ndef StackTop()\n  eval 1 + 2\n  eval 2 + 3\n  # call not on fourth line\n  StackBot()\nenddef\n\ndef StackBot()\n  # throw an error\n  eval [][0]\nenddef\n\ndef Test_callstack_def()\n  try\n    StackTop()\n  catch\n    v:throwpoint->assert_match('Test_callstack_def\\[2\\]..StackTop\\[4\\]..StackBot, line 2')\n  endtry\nenddef\n\n\" Re-using spot for variable used in block\ndef Test_block_scoped_var()\n  var lines =<< trim END\n      vim9script\n      def Func()\n        var x = ['a', 'b', 'c']\n        if 1\n          var y = 'x'\n          map(x, (_, _) => y)\n        endif\n        var z = x\n        assert_equal(['x', 'x', 'x'], z)\n      enddef\n      Func()\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_reset_did_emsg()\n  var lines =<< trim END\n      @s = 'blah'\n      au BufWinLeave * #\n      def Func()\n        var winid = popup_create('popup', {})\n        exe '*s'\n        popup_close(winid)\n      enddef\n      Func()\n  END\n  CheckScriptFailure(lines, 'E492:', 8)\n  delfunc! g:Func\nenddef\n\ndef Test_did_emsg_reset()\n  # executing an autocommand resets did_emsg, this should not result in a\n  # builtin function considered failing\n  var lines =<< trim END\n      vim9script\n      au BufWinLeave * #\n      def Func()\n          popup_menu('', {callback: (a, b) => popup_create('', {})->popup_close()})\n          eval [][0]\n      enddef\n      nno <F3> <cmd>call <sid>Func()<cr>\n      feedkeys(\"\\<F3>\\e\", 'xt')\n  END\n  writefile(lines, 'XemsgReset')\n  assert_fails('so XemsgReset', ['E684:', 'E684:'], lines, 2)\n  delete('XemsgReset')\n  nunmap <F3>\n  au! BufWinLeave\nenddef\n\ndef Test_abort_with_silent_call()\n  var lines =<< trim END\n      vim9script\n      g:result = 'none'\n      def Func()\n        g:result += 3\n        g:result = 'yes'\n      enddef\n      # error is silenced, but function aborts on error\n      silent! Func()\n      assert_equal('none', g:result)\n      unlet g:result\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_continues_with_silent_error()\n  var lines =<< trim END\n      vim9script\n      g:result = 'none'\n      def Func()\n        silent!  g:result += 3\n        g:result = 'yes'\n      enddef\n      # error is silenced, function does not abort\n      Func()\n      assert_equal('yes', g:result)\n      unlet g:result\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_abort_even_with_silent()\n  var lines =<< trim END\n      vim9script\n      g:result = 'none'\n      def Func()\n        eval {-> ''}() .. '' .. {}['X']\n        g:result = 'yes'\n      enddef\n      silent! Func()\n      assert_equal('none', g:result)\n      unlet g:result\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_cmdmod_silent_restored()\n  var lines =<< trim END\n      vim9script\n      def Func()\n        g:result = 'none'\n        silent! g:result += 3\n        g:result = 'none'\n        g:result += 3\n      enddef\n      Func()\n  END\n  # can't use CheckScriptFailure, it ignores the :silent!\n  var fname = 'Xdefsilent'\n  writefile(lines, fname)\n  var caught = 'no'\n  try\n    exe 'source ' .. fname\n  catch /E1030:/\n    caught = 'yes'\n    assert_match('Func, line 4', v:throwpoint)\n  endtry\n  assert_equal('yes', caught)\n  delete(fname)\nenddef\n\ndef Test_cmdmod_silent_nested()\n  var lines =<< trim END\n      vim9script\n      var result = ''\n\n      def Error()\n          result ..= 'Eb'\n          eval [][0]\n          result ..= 'Ea'\n      enddef\n\n      def Crash()\n          result ..= 'Cb'\n          sil! Error()\n          result ..= 'Ca'\n      enddef\n\n      Crash()\n      assert_equal('CbEbEaCa', result)\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_dict_member_with_silent()\n  var lines =<< trim END\n      vim9script\n      g:result = 'none'\n      var d: dict<any>\n      def Func()\n        try\n          g:result = map([], (_, v) => ({}[v]))->join() .. d['']\n        catch\n        endtry\n      enddef\n      silent! Func()\n      assert_equal('0', g:result)\n      unlet g:result\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_skip_cmds_with_silent()\n  var lines =<< trim END\n      vim9script\n\n      def Func(b: bool)\n        Crash()\n      enddef\n\n      def Crash()\n        sil! :/not found/d _\n        sil! :/not found/put _\n      enddef\n\n      Func(true)\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_opfunc()\n  nnoremap <F3> <cmd>set opfunc=Opfunc<cr>g@\n  def g:Opfunc(_: any): string\n    setline(1, 'ASDF')\n    return ''\n  enddef\n  new\n  setline(1, 'asdf')\n  feedkeys(\"\\<F3>$\", 'x')\n  assert_equal('ASDF', getline(1))\n\n  bwipe!\n  nunmap <F3>\nenddef\n\nfunc Test_opfunc_error()\n  CheckScreendump\n  call Run_Test_opfunc_error()\nendfunc\n\ndef Run_Test_opfunc_error()\n  # test that the error from Opfunc() is displayed right away\n  var lines =<< trim END\n      vim9script\n\n      def Opfunc(type: string)\n        try\n          eval [][0]\n        catch /nothing/  # error not caught\n        endtry\n      enddef\n      &operatorfunc = Opfunc\n      nnoremap <expr> l <SID>L()\n      def L(): string\n        return 'l'\n      enddef\n      'x'->repeat(10)->setline(1)\n      feedkeys('g@l', 'n')\n      feedkeys('llll')\n  END\n  call writefile(lines, 'XTest_opfunc_error')\n\n  var buf = RunVimInTerminal('-S XTest_opfunc_error', {rows: 6, wait_for_ruler: 0})\n  WaitForAssert(() => assert_match('Press ENTER', term_getline(buf, 6)))\n  WaitForAssert(() => assert_match('E684: list index out of range: 0', term_getline(buf, 5)))\n\n  # clean up\n  StopVimInTerminal(buf)\n  delete('XTest_opfunc_error')\nenddef\n\n\" this was crashing on exit\ndef Test_nested_lambda_in_closure()\n  var lines =<< trim END\n      vim9script\n      command WriteDone writefile(['Done'], 'XnestedDone')\n      def Outer()\n          def g:Inner()\n              echo map([1, 2, 3], {_, v -> v + 1})\n          enddef\n          g:Inner()\n      enddef\n      defcompile\n      # not reached\n  END\n  if !RunVim([], lines, '--clean -c WriteDone -c quit')\n    return\n  endif\n  assert_equal(['Done'], readfile('XnestedDone'))\n  delete('XnestedDone')\nenddef\n\ndef Test_check_func_arg_types()\n  var lines =<< trim END\n      vim9script\n      def F1(x: string): string\n        return x\n      enddef\n\n      def F2(x: number): number\n        return x + 1\n      enddef\n\n      def G(g: func): dict<func>\n        return {f: g}\n      enddef\n\n      def H(d: dict<func>): string\n        return d.f('a')\n      enddef\n  END\n\n  CheckScriptSuccess(lines + ['echo H(G(F1))'])\n  CheckScriptFailure(lines + ['echo H(G(F2))'], 'E1013:')\nenddef\n\ndef Test_list_any_type_checked()\n  var lines =<< trim END\n      vim9script\n      def Foo()\n        --decl--\n        Bar(l)\n      enddef\n      def Bar(ll: list<dict<any>>)\n      enddef\n      Foo()\n  END\n  lines[2] = 'var l: list<any>'\n  CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch, expected list<dict<any>> but got list<any>', 2)\n\n  lines[2] = 'var l: list<any> = []'\n  CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch, expected list<dict<any>> but got list<any>', 2)\n\n  lines[2] = 'var l: list<any> = [11]'\n  CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch, expected list<dict<any>> but got list<number>', 2)\nenddef\n\ndef Test_compile_error()\n  var lines =<< trim END\n    def g:Broken()\n      echo 'a' + {}\n    enddef\n    call g:Broken()\n  END\n  # First call: compilation error\n  CheckScriptFailure(lines, 'E1051: Wrong argument type for +')\n\n  # Second call won't try compiling again\n  assert_fails('call g:Broken()', 'E1091: Function is not compiled: Broken')\n  delfunc g:Broken\n\n  # No error when compiling with :silent!\n  lines =<< trim END\n    def g:Broken()\n      echo 'a' + []\n    enddef\n    silent! defcompile\n  END\n  CheckScriptSuccess(lines)\n\n  # Calling the function won't try compiling again\n  assert_fails('call g:Broken()', 'E1091: Function is not compiled: Broken')\n  delfunc g:Broken\nenddef\n\ndef Test_ignored_argument()\n  var lines =<< trim END\n      vim9script\n      def Ignore(_, _): string\n        return 'yes'\n      enddef\n      assert_equal('yes', Ignore(1, 2))\n\n      func Ok(_)\n        return a:_\n      endfunc\n      assert_equal('ok', Ok('ok'))\n\n      func Oktoo()\n        let _ = 'too'\n        return _\n      endfunc\n      assert_equal('too', Oktoo())\n\n      assert_equal([[1], [2], [3]], range(3)->mapnew((_, v) => [v]->map((_, w) => w + 1)))\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      def Ignore(_: string): string\n        return _\n      enddef\n      defcompile\n  END\n  CheckScriptFailure(lines, 'E1181:', 1)\n\n  lines =<< trim END\n      var _ = 1\n  END\n  CheckDefAndScriptFailure(lines, 'E1181:', 1)\n\n  lines =<< trim END\n      var x = _\n  END\n  CheckDefAndScriptFailure(lines, 'E1181:', 1)\nenddef\n\ndef Test_too_many_arguments()\n  var lines =<< trim END\n    echo [0, 1, 2]->map(() => 123)\n  END\n  CheckDefExecAndScriptFailure(lines, 'E1106: 2 arguments too many', 1)\n\n  lines =<< trim END\n    echo [0, 1, 2]->map((_) => 123)\n  END\n  CheckDefExecAndScriptFailure(lines, 'E1106: One argument too many', 1)\nenddef\n\ndef Test_closing_brace_at_start_of_line()\n  var lines =<< trim END\n      def Func()\n      enddef\n      Func(\n      )\n  END\n  call CheckDefAndScriptSuccess(lines)\nenddef\n\nfunc CreateMydict()\n  let g:mydict = {}\n  func g:mydict.afunc()\n    let g:result = self.key\n  endfunc\nendfunc\n\ndef Test_numbered_function_reference()\n  CreateMydict()\n  var output = execute('legacy func g:mydict.afunc')\n  var funcName = 'g:' .. substitute(output, '.*function \\(\\d\\+\\).*', '\\1', '')\n  execute 'function(' .. funcName .. ', [], {key: 42})()'\n  # check that the function still exists\n  assert_equal(output, execute('legacy func g:mydict.afunc'))\n  unlet g:mydict\nenddef\n\nif has('python3')\n  def Test_python3_heredoc()\n    py3 << trim EOF\n      import vim\n      vim.vars['didit'] = 'yes'\n    EOF\n    assert_equal('yes', g:didit)\n\n    python3 << trim EOF\n      import vim\n      vim.vars['didit'] = 'again'\n    EOF\n    assert_equal('again', g:didit)\n  enddef\nendif\n\n\" This messes up syntax highlight, keep near the end.\nif has('lua')\n  def Test_lua_heredoc()\n    g:d = {}\n    lua << trim EOF\n        x = vim.eval('g:d')\n        x['key'] = 'val'\n    EOF\n    assert_equal('val', g:d.key)\n  enddef\nendif\n\n\n\" vim: ts=8 sw=2 sts=2 expandtab tw=80 fdm=marker\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * userfunc.c: User defined function support\n */\n\n#include \"vim.h\"\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * All user-defined functions are found in this hashtable.\n */\nstatic hashtab_T\tfunc_hashtab;\n\n// Used by get_func_tv()\nstatic garray_T funcargs = GA_EMPTY;\n\n// pointer to funccal for currently active function\nstatic funccall_T *current_funccal = NULL;\n\n// Pointer to list of previously used funccal, still around because some\n// item in it is still being used.\nstatic funccall_T *previous_funccal = NULL;\n\nstatic char *e_funcexts = N_(\"E122: Function %s already exists, add ! to replace it\");\nstatic char *e_funcdict = N_(\"E717: Dictionary entry already exists\");\nstatic char *e_funcref = N_(\"E718: Funcref required\");\nstatic char *e_nofunc = N_(\"E130: Unknown function: %s\");\n\nstatic void funccal_unref(funccall_T *fc, ufunc_T *fp, int force);\nstatic void func_clear(ufunc_T *fp, int force);\nstatic int func_free(ufunc_T *fp, int force);\n\n    void\nfunc_init()\n{\n    hash_init(&func_hashtab);\n}\n\n/*\n * Return the function hash table\n */\n    hashtab_T *\nfunc_tbl_get(void)\n{\n    return &func_hashtab;\n}\n\n/*\n * Get one function argument.\n * If \"argtypes\" is not NULL also get the type: \"arg: type\" (:def function).\n * If \"types_optional\" is TRUE a missing type is OK, use \"any\".\n * If \"evalarg\" is not NULL use it to check for an already declared name.\n * Return a pointer to after the type.\n * When something is wrong return \"arg\".\n */\n    static char_u *\none_function_arg(\n\tchar_u\t    *arg,\n\tgarray_T    *newargs,\n\tgarray_T    *argtypes,\n\tint\t    types_optional,\n\tevalarg_T   *evalarg,\n\tint\t    is_vararg,\n\tint\t    skip)\n{\n    char_u\t*p = arg;\n    char_u\t*arg_copy = NULL;\n    int\t\tis_underscore = FALSE;\n\n    while (ASCII_ISALNUM(*p) || *p == '_')\n\t++p;\n    if (arg == p || isdigit(*arg)\n\t    || (argtypes == NULL\n\t\t&& ((p - arg == 9 && STRNCMP(arg, \"firstline\", 9) == 0)\n\t\t    || (p - arg == 8 && STRNCMP(arg, \"lastline\", 8) == 0))))\n    {\n\tif (!skip)\n\t    semsg(_(\"E125: Illegal argument: %s\"), arg);\n\treturn arg;\n    }\n\n    // Vim9 script: cannot use script var name for argument. In function: also\n    // check local vars and arguments.\n    if (!skip && argtypes != NULL && check_defined(arg, p - arg,\n\t\t    evalarg == NULL ? NULL : evalarg->eval_cctx, TRUE) == FAIL)\n\treturn arg;\n\n    if (newargs != NULL && ga_grow(newargs, 1) == FAIL)\n\treturn arg;\n    if (newargs != NULL)\n    {\n\tint\tc;\n\tint\ti;\n\n\tc = *p;\n\t*p = NUL;\n\targ_copy = vim_strsave(arg);\n\tif (arg_copy == NULL)\n\t{\n\t    *p = c;\n\t    return arg;\n\t}\n\tis_underscore = arg_copy[0] == '_' && arg_copy[1] == NUL;\n\tif (argtypes == NULL || !is_underscore)\n\t    // Check for duplicate argument name.\n\t    for (i = 0; i < newargs->ga_len; ++i)\n\t\tif (STRCMP(((char_u **)(newargs->ga_data))[i], arg_copy) == 0)\n\t\t{\n\t\t    semsg(_(\"E853: Duplicate argument name: %s\"), arg_copy);\n\t\t    vim_free(arg_copy);\n\t\t    return arg;\n\t\t}\n\t((char_u **)(newargs->ga_data))[newargs->ga_len] = arg_copy;\n\tnewargs->ga_len++;\n\n\t*p = c;\n    }\n\n    // get any type from \"arg: type\"\n    if (argtypes != NULL && (skip || ga_grow(argtypes, 1) == OK))\n    {\n\tchar_u *type = NULL;\n\n\tif (VIM_ISWHITE(*p) && *skipwhite(p) == ':')\n\t{\n\t    semsg(_(e_no_white_space_allowed_before_colon_str),\n\t\t\t\t\t    arg_copy == NULL ? arg : arg_copy);\n\t    p = skipwhite(p);\n\t}\n\tif (*p == ':')\n\t{\n\t    ++p;\n\t    if (!skip && !VIM_ISWHITE(*p))\n\t    {\n\t\tsemsg(_(e_white_space_required_after_str_str), \":\", p - 1);\n\t\treturn arg;\n\t    }\n\t    type = skipwhite(p);\n\t    p = skip_type(type, TRUE);\n\t    if (!skip)\n\t\ttype = vim_strnsave(type, p - type);\n\t}\n\telse if (*skipwhite(p) != '=' && !types_optional && !is_underscore)\n\t{\n\t    semsg(_(e_missing_argument_type_for_str),\n\t\t\t\t\t    arg_copy == NULL ? arg : arg_copy);\n\t    return arg;\n\t}\n\tif (!skip)\n\t{\n\t    if (type == NULL && types_optional)\n\t\t// lambda arguments default to \"any\" type\n\t\ttype = vim_strsave((char_u *)\n\t\t\t\t\t    (is_vararg ? \"list<any>\" : \"any\"));\n\t    ((char_u **)argtypes->ga_data)[argtypes->ga_len++] = type;\n\t}\n    }\n\n    return p;\n}\n\n/*\n * Get function arguments.\n * \"argp\" should point to just after the \"(\", possibly to white space.\n * \"argp\" is advanced just after \"endchar\".\n */\n    static int\nget_function_args(\n    char_u\t**argp,\n    char_u\tendchar,\n    garray_T\t*newargs,\n    garray_T\t*argtypes,\t// NULL unless using :def\n    int\t\ttypes_optional,\t// types optional if \"argtypes\" is not NULL\n    evalarg_T\t*evalarg,\t// context or NULL\n    int\t\t*varargs,\n    garray_T\t*default_args,\n    int\t\tskip,\n    exarg_T\t*eap,\n    char_u\t**line_to_free)\n{\n    int\t\tmustend = FALSE;\n    char_u\t*arg;\n    char_u\t*p;\n    int\t\tc;\n    int\t\tany_default = FALSE;\n    char_u\t*expr;\n    char_u\t*whitep = *argp;\n\n    if (newargs != NULL)\n\tga_init2(newargs, (int)sizeof(char_u *), 3);\n    if (argtypes != NULL)\n\tga_init2(argtypes, (int)sizeof(char_u *), 3);\n    if (!skip && default_args != NULL)\n\tga_init2(default_args, (int)sizeof(char_u *), 3);\n\n    if (varargs != NULL)\n\t*varargs = FALSE;\n\n    /*\n     * Isolate the arguments: \"arg1, arg2, ...)\"\n     */\n    arg = skipwhite(*argp);\n    p = arg;\n    while (*p != endchar)\n    {\n\twhile (eap != NULL && eap->getline != NULL\n\t\t\t && (*p == NUL || (VIM_ISWHITE(*whitep) && *p == '#')))\n\t{\n\t    char_u *theline;\n\n\t    // End of the line, get the next one.\n\t    theline = eap->getline(':', eap->cookie, 0, TRUE);\n\t    if (theline == NULL)\n\t\tbreak;\n\t    vim_free(*line_to_free);\n\t    *line_to_free = theline;\n\t    whitep = (char_u *)\" \";\n\t    p = skipwhite(theline);\n\t}\n\n\tif (mustend && *p != endchar)\n\t{\n\t    if (!skip)\n\t\tsemsg(_(e_invarg2), *argp);\n\t    goto err_ret;\n\t}\n\tif (*p == endchar)\n\t    break;\n\n\tif (p[0] == '.' && p[1] == '.' && p[2] == '.')\n\t{\n\t    if (varargs != NULL)\n\t\t*varargs = TRUE;\n\t    p += 3;\n\t    mustend = TRUE;\n\n\t    if (argtypes != NULL)\n\t    {\n\t\t// ...name: list<type>\n\t\tif (!eval_isnamec1(*p))\n\t\t{\n\t\t    if (!skip)\n\t\t\temsg(_(e_missing_name_after_dots));\n\t\t    goto err_ret;\n\t\t}\n\n\t\targ = p;\n\t\tp = one_function_arg(p, newargs, argtypes, types_optional,\n\t\t\t\t\t\t\t  evalarg, TRUE, skip);\n\t\tif (p == arg)\n\t\t    break;\n\t\tif (*skipwhite(p) == '=')\n\t\t{\n\t\t    emsg(_(e_cannot_use_default_for_variable_arguments));\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\telse\n\t{\n\t    char_u *np;\n\n\t    arg = p;\n\t    p = one_function_arg(p, newargs, argtypes, types_optional,\n\t\t\t\t\t\t\t evalarg, FALSE, skip);\n\t    if (p == arg)\n\t\tbreak;\n\n\t    // Recognize \" = expr\" but not \" == expr\".  A lambda can have\n\t    // \"(a = expr\" but \"(a == expr\" and \"(a =~ expr\" are not a lambda.\n\t    np = skipwhite(p);\n\t    if (*np == '=' && np[1] != '=' && np[1] != '~'\n\t\t\t\t\t\t       && default_args != NULL)\n\t    {\n\t\ttypval_T\trettv;\n\n\t\t// find the end of the expression (doesn't evaluate it)\n\t\tany_default = TRUE;\n\t\tp = skipwhite(p) + 1;\n\t\twhitep = p;\n\t\tp = skipwhite(p);\n\t\texpr = p;\n\t\tif (eval1(&p, &rettv, NULL) != FAIL)\n\t\t{\n\t\t    if (!skip)\n\t\t    {\n\t\t\tif (ga_grow(default_args, 1) == FAIL)\n\t\t\t    goto err_ret;\n\n\t\t\t// trim trailing whitespace\n\t\t\twhile (p > expr && VIM_ISWHITE(p[-1]))\n\t\t\t    p--;\n\t\t\tc = *p;\n\t\t\t*p = NUL;\n\t\t\texpr = vim_strsave(expr);\n\t\t\tif (expr == NULL)\n\t\t\t{\n\t\t\t    *p = c;\n\t\t\t    goto err_ret;\n\t\t\t}\n\t\t\t((char_u **)(default_args->ga_data))\n\t\t\t\t\t\t [default_args->ga_len] = expr;\n\t\t\tdefault_args->ga_len++;\n\t\t\t*p = c;\n\t\t    }\n\t\t}\n\t\telse\n\t\t    mustend = TRUE;\n\t    }\n\t    else if (any_default)\n\t    {\n\t\temsg(_(\"E989: Non-default argument follows default argument\"));\n\t\tgoto err_ret;\n\t    }\n\n\t    if (VIM_ISWHITE(*p) && *skipwhite(p) == ',')\n\t    {\n\t\t// Be tolerant when skipping\n\t\tif (!skip)\n\t\t{\n\t\t    semsg(_(e_no_white_space_allowed_before_str_str), \",\", p);\n\t\t    goto err_ret;\n\t\t}\n\t\tp = skipwhite(p);\n\t    }\n\t    if (*p == ',')\n\t    {\n\t\t++p;\n\t\t// Don't give this error when skipping, it makes the \"->\" not\n\t\t// found in \"{k,v -> x}\" and give a confusing error.\n\t\t// Allow missing space after comma in legacy functions.\n\t\tif (!skip && argtypes != NULL\n\t\t\t\t      && !IS_WHITE_OR_NUL(*p) && *p != endchar)\n\t\t{\n\t\t    semsg(_(e_white_space_required_after_str_str), \",\", p - 1);\n\t\t    goto err_ret;\n\t\t}\n\t    }\n\t    else\n\t\tmustend = TRUE;\n\t}\n\twhitep = p;\n\tp = skipwhite(p);\n    }\n\n    if (*p != endchar)\n\tgoto err_ret;\n    ++p;\t// skip \"endchar\"\n\n    *argp = p;\n    return OK;\n\nerr_ret:\n    if (newargs != NULL)\n\tga_clear_strings(newargs);\n    if (!skip && default_args != NULL)\n\tga_clear_strings(default_args);\n    return FAIL;\n}\n\n/*\n * Parse the argument types, filling \"fp->uf_arg_types\".\n * Return OK or FAIL.\n */\n    static int\nparse_argument_types(ufunc_T *fp, garray_T *argtypes, int varargs)\n{\n    int len = 0;\n\n    ga_init2(&fp->uf_type_list, sizeof(type_T *), 10);\n    if (argtypes->ga_len > 0)\n    {\n\t// When \"varargs\" is set the last name/type goes into uf_va_name\n\t// and uf_va_type.\n\tlen = argtypes->ga_len - (varargs ? 1 : 0);\n\n\tif (len > 0)\n\t    fp->uf_arg_types = ALLOC_CLEAR_MULT(type_T *, len);\n\tif (fp->uf_arg_types != NULL)\n\t{\n\t    int\ti;\n\t    type_T\t*type;\n\n\t    for (i = 0; i < len; ++ i)\n\t    {\n\t\tchar_u *p = ((char_u **)argtypes->ga_data)[i];\n\n\t\tif (p == NULL)\n\t\t    // will get the type from the default value\n\t\t    type = &t_unknown;\n\t\telse\n\t\t    type = parse_type(&p, &fp->uf_type_list, TRUE);\n\t\tif (type == NULL)\n\t\t    return FAIL;\n\t\tfp->uf_arg_types[i] = type;\n\t    }\n\t}\n    }\n\n    if (varargs)\n    {\n\tchar_u *p;\n\n\t// Move the last argument \"...name: type\" to uf_va_name and\n\t// uf_va_type.\n\tfp->uf_va_name = ((char_u **)fp->uf_args.ga_data)\n\t\t\t\t\t      [fp->uf_args.ga_len - 1];\n\t--fp->uf_args.ga_len;\n\tp = ((char_u **)argtypes->ga_data)[len];\n\tif (p == NULL)\n\t    // TODO: get type from default value\n\t    fp->uf_va_type = &t_list_any;\n\telse\n\t{\n\t    fp->uf_va_type = parse_type(&p, &fp->uf_type_list, TRUE);\n\t    if (fp->uf_va_type != NULL && fp->uf_va_type->tt_type != VAR_LIST)\n\t    {\n\t\tsemsg(_(e_variable_arguments_type_must_be_list_str),\n\t\t\t\t\t  ((char_u **)argtypes->ga_data)[len]);\n\t\treturn FAIL;\n\t    }\n\t}\n\tif (fp->uf_va_type == NULL)\n\t    return FAIL;\n    }\n\n    return OK;\n}\n\n    static int\nparse_return_type(ufunc_T *fp, char_u *ret_type)\n{\n    if (ret_type == NULL)\n\tfp->uf_ret_type = &t_void;\n    else\n    {\n\tchar_u *p = ret_type;\n\n\tfp->uf_ret_type = parse_type(&p, &fp->uf_type_list, TRUE);\n\tif (fp->uf_ret_type == NULL)\n\t{\n\t    fp->uf_ret_type = &t_void;\n\t    return FAIL;\n\t}\n    }\n    return OK;\n}\n\n/*\n * Register function \"fp\" as using \"current_funccal\" as its scope.\n */\n    static int\nregister_closure(ufunc_T *fp)\n{\n    if (fp->uf_scoped == current_funccal)\n\t// no change\n\treturn OK;\n    funccal_unref(fp->uf_scoped, fp, FALSE);\n    fp->uf_scoped = current_funccal;\n    current_funccal->fc_refcount++;\n\n    if (ga_grow(&current_funccal->fc_funcs, 1) == FAIL)\n\treturn FAIL;\n    ((ufunc_T **)current_funccal->fc_funcs.ga_data)\n\t[current_funccal->fc_funcs.ga_len++] = fp;\n    return OK;\n}\n\n    static void\nset_ufunc_name(ufunc_T *fp, char_u *name)\n{\n    // Add a type cast to avoid a warning for an overflow, the uf_name[] array\n    // actually extends beyond the struct.\n    STRCPY((void *)fp->uf_name, name);\n\n    if (name[0] == K_SPECIAL)\n    {\n\tfp->uf_name_exp = alloc(STRLEN(name) + 3);\n\tif (fp->uf_name_exp != NULL)\n\t{\n\t    STRCPY(fp->uf_name_exp, \"<SNR>\");\n\t    STRCAT(fp->uf_name_exp, fp->uf_name + 3);\n\t}\n    }\n}\n\n/*\n * Get a name for a lambda.  Returned in static memory.\n */\n    char_u *\nget_lambda_name(void)\n{\n    static char_u   name[30];\n    static int\t    lambda_no = 0;\n\n    sprintf((char*)name, \"<lambda>%d\", ++lambda_no);\n    return name;\n}\n\n#if defined(FEAT_LUA) || defined(PROTO)\n/*\n * Registers a native C callback which can be called from Vim script.\n * Returns the name of the Vim script function.\n */\n    char_u *\nregister_cfunc(cfunc_T cb, cfunc_free_T cb_free, void *state)\n{\n    char_u\t*name = get_lambda_name();\n    ufunc_T\t*fp;\n\n    fp = alloc_clear(offsetof(ufunc_T, uf_name) + STRLEN(name) + 1);\n    if (fp == NULL)\n\treturn NULL;\n\n    fp->uf_def_status = UF_NOT_COMPILED;\n    fp->uf_refcount = 1;\n    fp->uf_varargs = TRUE;\n    fp->uf_flags = FC_CFUNC | FC_LAMBDA;\n    fp->uf_calls = 0;\n    fp->uf_script_ctx = current_sctx;\n    fp->uf_cb = cb;\n    fp->uf_cb_free = cb_free;\n    fp->uf_cb_state = state;\n\n    set_ufunc_name(fp, name);\n    hash_add(&func_hashtab, UF2HIKEY(fp));\n\n    return name;\n}\n#endif\n\n/*\n * Skip over \"->\" or \"=>\" after the arguments of a lambda.\n * If \": type\" is found make \"ret_type\" point to \"type\".\n * If \"white_error\" is not NULL check for correct use of white space and set\n * \"white_error\" to TRUE if there is an error.\n * Return NULL if no valid arrow found.\n */\n    static char_u *\nskip_arrow(\n\tchar_u\t*start,\n\tint\tequal_arrow,\n\tchar_u\t**ret_type,\n\tint\t*white_error)\n{\n    char_u  *s = start;\n    char_u  *bef = start - 2; // \"start\" points to > of ->\n\n    if (equal_arrow)\n    {\n\tif (*s == ':')\n\t{\n\t    if (white_error != NULL && !VIM_ISWHITE(s[1]))\n\t    {\n\t\t*white_error = TRUE;\n\t\tsemsg(_(e_white_space_required_after_str_str), \":\", s);\n\t\treturn NULL;\n\t    }\n\t    s = skipwhite(s + 1);\n\t    *ret_type = s;\n\t    s = skip_type(s, TRUE);\n\t    if (s == *ret_type)\n\t    {\n\t\temsg(_(e_missing_return_type));\n\t\treturn NULL;\n\t    }\n\t}\n\tbef = s;\n\ts = skipwhite(s);\n\tif (*s != '=')\n\t    return NULL;\n\t++s;\n    }\n    if (*s != '>')\n\treturn NULL;\n    if (white_error != NULL && ((!VIM_ISWHITE(*bef) && *bef != '{')\n\t\t|| !IS_WHITE_OR_NUL(s[1])))\n    {\n\t*white_error = TRUE;\n\tsemsg(_(e_white_space_required_before_and_after_str_at_str),\n\t\t\t\t\t       equal_arrow ? \"=>\" : \"->\", bef);\n\treturn NULL;\n    }\n    return skipwhite(s + 1);\n}\n\n/*\n * Check if \"*cmd\" points to a function command and if so advance \"*cmd\" and\n * return TRUE.\n * Otherwise return FALSE;\n * Do not consider \"function(\" to be a command.\n */\n    static int\nis_function_cmd(char_u **cmd)\n{\n    char_u *p = *cmd;\n\n    if (checkforcmd(&p, \"function\", 2))\n    {\n\tif (*p == '(')\n\t    return FALSE;\n\t*cmd = p;\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Called when defining a function: The context may be needed for script\n * variables declared in a block that is visible now but not when the function\n * is compiled or called later.\n */\n    static void\nfunction_using_block_scopes(ufunc_T *fp, cstack_T *cstack)\n{\n    if (cstack != NULL && cstack->cs_idx >= 0)\n    {\n\tint\t    count = cstack->cs_idx + 1;\n\tint\t    i;\n\n\tfp->uf_block_ids = ALLOC_MULT(int, count);\n\tif (fp->uf_block_ids != NULL)\n\t{\n\t    mch_memmove(fp->uf_block_ids, cstack->cs_block_id,\n\t\t\t\t\t\t\t  sizeof(int) * count);\n\t    fp->uf_block_depth = count;\n\t}\n\n\t// Set flag in each block to indicate a function was defined.  This\n\t// is used to keep the variable when leaving the block, see\n\t// hide_script_var().\n\tfor (i = 0; i <= cstack->cs_idx; ++i)\n\t    cstack->cs_flags[i] |= CSF_FUNC_DEF;\n    }\n}\n\n/*\n * Read the body of a function, put every line in \"newlines\".\n * This stops at \"}\", \"endfunction\" or \"enddef\".\n * \"newlines\" must already have been initialized.\n * \"eap->cmdidx\" is CMD_function, CMD_def or CMD_block;\n */\n    static int\nget_function_body(\n\texarg_T\t    *eap,\n\tgarray_T    *newlines,\n\tchar_u\t    *line_arg_in,\n\tchar_u\t    **line_to_free)\n{\n    linenr_T\tsourcing_lnum_top = SOURCING_LNUM;\n    linenr_T\tsourcing_lnum_off;\n    int\t\tsaved_wait_return = need_wait_return;\n    char_u\t*line_arg = line_arg_in;\n    int\t\tvim9_function = eap->cmdidx == CMD_def\n\t\t\t\t\t\t   || eap->cmdidx == CMD_block;\n#define MAX_FUNC_NESTING 50\n    char\tnesting_def[MAX_FUNC_NESTING];\n    char\tnesting_inline[MAX_FUNC_NESTING];\n    int\t\tnesting = 0;\n    getline_opt_T getline_options;\n    int\t\tindent = 2;\n    char_u\t*skip_until = NULL;\n    int\t\tret = FAIL;\n    int\t\tis_heredoc = FALSE;\n    int\t\theredoc_concat_len = 0;\n    garray_T\theredoc_ga;\n    char_u\t*heredoc_trimmed = NULL;\n\n    ga_init2(&heredoc_ga, 1, 500);\n\n    // Detect having skipped over comment lines to find the return\n    // type.  Add NULL lines to keep the line count correct.\n    sourcing_lnum_off = get_sourced_lnum(eap->getline, eap->cookie);\n    if (SOURCING_LNUM < sourcing_lnum_off)\n    {\n\tsourcing_lnum_off -= SOURCING_LNUM;\n\tif (ga_grow(newlines, sourcing_lnum_off) == FAIL)\n\t    goto theend;\n\twhile (sourcing_lnum_off-- > 0)\n\t    ((char_u **)(newlines->ga_data))[newlines->ga_len++] = NULL;\n    }\n\n    nesting_def[0] = vim9_function;\n    nesting_inline[0] = eap->cmdidx == CMD_block;\n    getline_options = vim9_function\n\t\t\t\t? GETLINE_CONCAT_CONTBAR : GETLINE_CONCAT_CONT;\n    for (;;)\n    {\n\tchar_u\t*theline;\n\tchar_u\t*p;\n\tchar_u\t*arg;\n\n\tif (KeyTyped)\n\t{\n\t    msg_scroll = TRUE;\n\t    saved_wait_return = FALSE;\n\t}\n\tneed_wait_return = FALSE;\n\n\tif (line_arg != NULL)\n\t{\n\t    // Use eap->arg, split up in parts by line breaks.\n\t    theline = line_arg;\n\t    p = vim_strchr(theline, '\\n');\n\t    if (p == NULL)\n\t\tline_arg += STRLEN(line_arg);\n\t    else\n\t    {\n\t\t*p = NUL;\n\t\tline_arg = p + 1;\n\t    }\n\t}\n\telse\n\t{\n\t    if (eap->getline == NULL)\n\t\ttheline = getcmdline(':', 0L, indent, getline_options);\n\t    else\n\t\ttheline = eap->getline(':', eap->cookie, indent,\n\t\t\t\t\t\t\t      getline_options);\n\t    if (*eap->cmdlinep == *line_to_free)\n\t\t*eap->cmdlinep = theline;\n\t    vim_free(*line_to_free);\n\t    *line_to_free = theline;\n\t}\n\tif (KeyTyped)\n\t    lines_left = Rows - 1;\n\tif (theline == NULL)\n\t{\n\t    // Use the start of the function for the line number.\n\t    SOURCING_LNUM = sourcing_lnum_top;\n\t    if (skip_until != NULL)\n\t\tsemsg(_(e_missing_heredoc_end_marker_str), skip_until);\n\t    else if (nesting_inline[nesting])\n\t\temsg(_(e_missing_end_block));\n\t    else if (eap->cmdidx == CMD_def)\n\t\temsg(_(e_missing_enddef));\n\t    else\n\t\temsg(_(\"E126: Missing :endfunction\"));\n\t    goto theend;\n\t}\n\n\t// Detect line continuation: SOURCING_LNUM increased more than one.\n\tsourcing_lnum_off = get_sourced_lnum(eap->getline, eap->cookie);\n\tif (SOURCING_LNUM < sourcing_lnum_off)\n\t    sourcing_lnum_off -= SOURCING_LNUM;\n\telse\n\t    sourcing_lnum_off = 0;\n\n\tif (skip_until != NULL)\n\t{\n\t    // Don't check for \":endfunc\"/\":enddef\" between\n\t    // * \":append\" and \".\"\n\t    // * \":python <<EOF\" and \"EOF\"\n\t    // * \":let {var-name} =<< [trim] {marker}\" and \"{marker}\"\n\t    if (heredoc_trimmed == NULL\n\t\t    || (is_heredoc && skipwhite(theline) == theline)\n\t\t    || STRNCMP(theline, heredoc_trimmed,\n\t\t\t\t\t\t STRLEN(heredoc_trimmed)) == 0)\n\t    {\n\t\tif (heredoc_trimmed == NULL)\n\t\t    p = theline;\n\t\telse if (is_heredoc)\n\t\t    p = skipwhite(theline) == theline\n\t\t\t\t ? theline : theline + STRLEN(heredoc_trimmed);\n\t\telse\n\t\t    p = theline + STRLEN(heredoc_trimmed);\n\t\tif (STRCMP(p, skip_until) == 0)\n\t\t{\n\t\t    VIM_CLEAR(skip_until);\n\t\t    VIM_CLEAR(heredoc_trimmed);\n\t\t    getline_options = vim9_function\n\t\t\t\t? GETLINE_CONCAT_CONTBAR : GETLINE_CONCAT_CONT;\n\t\t    is_heredoc = FALSE;\n\n\t\t    if (heredoc_concat_len > 0)\n\t\t    {\n\t\t\t// Replace the starting line with all the concatenated\n\t\t\t// lines.\n\t\t\tga_concat(&heredoc_ga, theline);\n\t\t\tvim_free(((char_u **)(newlines->ga_data))[\n\t\t\t\t\t\t      heredoc_concat_len - 1]);\n\t\t\t((char_u **)(newlines->ga_data))[\n\t\t\t\t  heredoc_concat_len - 1] = heredoc_ga.ga_data;\n\t\t\tga_init(&heredoc_ga);\n\t\t\theredoc_concat_len = 0;\n\t\t\ttheline += STRLEN(theline);  // skip the \"EOF\"\n\t\t    }\n\t\t}\n\t    }\n\t}\n\telse\n\t{\n\t    int\t    c;\n\t    char_u  *end;\n\n\t    // skip ':' and blanks\n\t    for (p = theline; VIM_ISWHITE(*p) || *p == ':'; ++p)\n\t\t;\n\n\t    // Check for \"endfunction\", \"enddef\" or \"}\".\n\t    // When a \":\" follows it must be a dict key; \"enddef: value,\"\n\t    if (nesting_inline[nesting]\n\t\t    ? *p == '}'\n\t\t    : (checkforcmd(&p, nesting_def[nesting]\n\t\t\t\t\t\t? \"enddef\" : \"endfunction\", 4)\n\t\t\t&& *p != ':'))\n\t    {\n\t\tif (nesting-- == 0)\n\t\t{\n\t\t    char_u *nextcmd = NULL;\n\n\t\t    if (*p == '|' || *p == '}')\n\t\t\tnextcmd = p + 1;\n\t\t    else if (line_arg != NULL && *skipwhite(line_arg) != NUL)\n\t\t\tnextcmd = line_arg;\n\t\t    else if (*p != NUL && *p != (vim9_function ? '#' : '\"')\n\t\t\t\t\t   && (vim9_function || p_verbose > 0))\n\t\t    {\n\t\t\tSOURCING_LNUM = sourcing_lnum_top\n\t\t\t\t\t\t\t+ newlines->ga_len + 1;\n\t\t\tif (eap->cmdidx == CMD_def)\n\t\t\t    semsg(_(e_text_found_after_enddef_str), p);\n\t\t\telse\n\t\t\t    give_warning2((char_u *)\n\t\t\t\t   _(\"W22: Text found after :endfunction: %s\"),\n\t\t\t\t   p, TRUE);\n\t\t    }\n\t\t    if (nextcmd != NULL && *skipwhite(nextcmd) != NUL)\n\t\t    {\n\t\t\t// Another command follows. If the line came from \"eap\"\n\t\t\t// we can simply point into it, otherwise we need to\n\t\t\t// change \"eap->cmdlinep\".\n\t\t\teap->nextcmd = nextcmd;\n\t\t\tif (*line_to_free != NULL\n\t\t\t\t\t    && *eap->cmdlinep != *line_to_free)\n\t\t\t{\n\t\t\t    vim_free(*eap->cmdlinep);\n\t\t\t    *eap->cmdlinep = *line_to_free;\n\t\t\t    *line_to_free = NULL;\n\t\t\t}\n\t\t    }\n\t\t    break;\n\t\t}\n\t    }\n\n\t    // Check for mismatched \"endfunc\" or \"enddef\".\n\t    // We don't check for \"def\" inside \"func\" thus we also can't check\n\t    // for \"enddef\".\n\t    // We continue to find the end of the function, although we might\n\t    // not find it.\n\t    else if (nesting_def[nesting])\n\t    {\n\t\tif (checkforcmd(&p, \"endfunction\", 4) && *p != ':')\n\t\t    emsg(_(e_mismatched_endfunction));\n\t    }\n\t    else if (eap->cmdidx == CMD_def && checkforcmd(&p, \"enddef\", 4))\n\t\temsg(_(e_mismatched_enddef));\n\n\t    // Increase indent inside \"if\", \"while\", \"for\" and \"try\", decrease\n\t    // at \"end\".\n\t    if (indent > 2 && (*p == '}' || STRNCMP(p, \"end\", 3) == 0))\n\t\tindent -= 2;\n\t    else if (STRNCMP(p, \"if\", 2) == 0\n\t\t    || STRNCMP(p, \"wh\", 2) == 0\n\t\t    || STRNCMP(p, \"for\", 3) == 0\n\t\t    || STRNCMP(p, \"try\", 3) == 0)\n\t\tindent += 2;\n\n\t    // Check for defining a function inside this function.\n\t    // Only recognize \"def\" inside \"def\", not inside \"function\",\n\t    // For backwards compatibility, see Test_function_python().\n\t    c = *p;\n\t    if (is_function_cmd(&p)\n\t\t    || (eap->cmdidx == CMD_def && checkforcmd(&p, \"def\", 3)))\n\t    {\n\t\tif (*p == '!')\n\t\t    p = skipwhite(p + 1);\n\t\tp += eval_fname_script(p);\n\t\tvim_free(trans_function_name(&p, NULL, TRUE, 0, NULL,\n\t\t\t\t\t\t\t\t  NULL, NULL));\n\t\tif (*skipwhite(p) == '(')\n\t\t{\n\t\t    if (nesting == MAX_FUNC_NESTING - 1)\n\t\t\temsg(_(e_function_nesting_too_deep));\n\t\t    else\n\t\t    {\n\t\t\t++nesting;\n\t\t\tnesting_def[nesting] = (c == 'd');\n\t\t\tnesting_inline[nesting] = FALSE;\n\t\t\tindent += 2;\n\t\t    }\n\t\t}\n\t    }\n\n\t    if (nesting_def[nesting] ? *p != '#' : *p != '\"')\n\t    {\n\t\t// Not a comment line: check for nested inline function.\n\t\tend = p + STRLEN(p) - 1;\n\t\twhile (end > p && VIM_ISWHITE(*end))\n\t\t    --end;\n\t\tif (end > p + 1 && *end == '{' && VIM_ISWHITE(end[-1]))\n\t\t{\n\t\t    int\t    is_block;\n\n\t\t    // check for trailing \"=> {\": start of an inline function\n\t\t    --end;\n\t\t    while (end > p && VIM_ISWHITE(*end))\n\t\t\t--end;\n\t\t    is_block = end > p + 2 && end[-1] == '=' && end[0] == '>';\n\t\t    if (!is_block)\n\t\t    {\n\t\t\tchar_u *s = p;\n\n\t\t\t// check for line starting with \"au\" for :autocmd or\n\t\t\t// \"com\" for :command, these can use a {} block\n\t\t\tis_block = checkforcmd_noparen(&s, \"autocmd\", 2)\n\t\t\t\t      || checkforcmd_noparen(&s, \"command\", 3);\n\t\t    }\n\n\t\t    if (is_block)\n\t\t    {\n\t\t\tif (nesting == MAX_FUNC_NESTING - 1)\n\t\t\t    emsg(_(e_function_nesting_too_deep));\n\t\t\telse\n\t\t\t{\n\t\t\t    ++nesting;\n\t\t\t    nesting_def[nesting] = TRUE;\n\t\t\t    nesting_inline[nesting] = TRUE;\n\t\t\t    indent += 2;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\n\t    // Check for \":append\", \":change\", \":insert\".  Not for :def.\n\t    p = skip_range(p, FALSE, NULL);\n\t    if (!vim9_function\n\t\t&& ((p[0] == 'a' && (!ASCII_ISALPHA(p[1]) || p[1] == 'p'))\n\t\t    || (p[0] == 'c'\n\t\t\t&& (!ASCII_ISALPHA(p[1]) || (p[1] == 'h'\n\t\t\t\t&& (!ASCII_ISALPHA(p[2]) || (p[2] == 'a'\n\t\t\t\t\t&& (STRNCMP(&p[3], \"nge\", 3) != 0\n\t\t\t\t\t    || !ASCII_ISALPHA(p[6])))))))\n\t\t    || (p[0] == 'i'\n\t\t\t&& (!ASCII_ISALPHA(p[1]) || (p[1] == 'n'\n\t\t\t\t&& (!ASCII_ISALPHA(p[2])\n\t\t\t\t    || (p[2] == 's'\n\t\t\t\t\t&& (!ASCII_ISALPHA(p[3])\n\t\t\t\t\t\t|| p[3] == 'e'))))))))\n\t\tskip_until = vim_strsave((char_u *)\".\");\n\n\t    // Check for \":python <<EOF\", \":tcl <<EOF\", etc.\n\t    arg = skipwhite(skiptowhite(p));\n\t    if (arg[0] == '<' && arg[1] =='<'\n\t\t    && ((p[0] == 'p' && p[1] == 'y'\n\t\t\t\t    && (!ASCII_ISALNUM(p[2]) || p[2] == 't'\n\t\t\t\t\t|| ((p[2] == '3' || p[2] == 'x')\n\t\t\t\t\t\t   && !ASCII_ISALPHA(p[3]))))\n\t\t\t|| (p[0] == 'p' && p[1] == 'e'\n\t\t\t\t    && (!ASCII_ISALPHA(p[2]) || p[2] == 'r'))\n\t\t\t|| (p[0] == 't' && p[1] == 'c'\n\t\t\t\t    && (!ASCII_ISALPHA(p[2]) || p[2] == 'l'))\n\t\t\t|| (p[0] == 'l' && p[1] == 'u' && p[2] == 'a'\n\t\t\t\t    && !ASCII_ISALPHA(p[3]))\n\t\t\t|| (p[0] == 'r' && p[1] == 'u' && p[2] == 'b'\n\t\t\t\t    && (!ASCII_ISALPHA(p[3]) || p[3] == 'y'))\n\t\t\t|| (p[0] == 'm' && p[1] == 'z'\n\t\t\t\t    && (!ASCII_ISALPHA(p[2]) || p[2] == 's'))\n\t\t\t))\n\t    {\n\t\t// \":python <<\" continues until a dot, like \":append\"\n\t\tp = skipwhite(arg + 2);\n\t\tif (STRNCMP(p, \"trim\", 4) == 0)\n\t\t{\n\t\t    // Ignore leading white space.\n\t\t    p = skipwhite(p + 4);\n\t\t    heredoc_trimmed = vim_strnsave(theline,\n\t\t\t\t\t\t skipwhite(theline) - theline);\n\t\t}\n\t\tif (*p == NUL)\n\t\t    skip_until = vim_strsave((char_u *)\".\");\n\t\telse\n\t\t    skip_until = vim_strnsave(p, skiptowhite(p) - p);\n\t\tgetline_options = GETLINE_NONE;\n\t\tis_heredoc = TRUE;\n\t\tif (eap->cmdidx == CMD_def)\n\t\t    heredoc_concat_len = newlines->ga_len + 1;\n\t    }\n\n\t    // Check for \":cmd v =<< [trim] EOF\"\n\t    //       and \":cmd [a, b] =<< [trim] EOF\"\n\t    //       and \"lines =<< [trim] EOF\" for Vim9\n\t    // Where \"cmd\" can be \"let\", \"var\", \"final\" or \"const\".\n\t    arg = skipwhite(skiptowhite(p));\n\t    if (*arg == '[')\n\t\targ = vim_strchr(arg, ']');\n\t    if (arg != NULL)\n\t    {\n\t\tint found = (eap->cmdidx == CMD_def && arg[0] == '='\n\t\t\t\t\t     && arg[1] == '<' && arg[2] =='<');\n\n\t\tif (!found)\n\t\t    // skip over the argument after \"cmd\"\n\t\t    arg = skipwhite(skiptowhite(arg));\n\t\tif (found || (arg[0] == '=' && arg[1] == '<' && arg[2] =='<'\n\t\t\t&& (checkforcmd(&p, \"let\", 2)\n\t\t\t    || checkforcmd(&p, \"var\", 3)\n\t\t\t    || checkforcmd(&p, \"final\", 5)\n\t\t\t    || checkforcmd(&p, \"const\", 5))))\n\t\t{\n\t\t    p = skipwhite(arg + 3);\n\t\t    if (STRNCMP(p, \"trim\", 4) == 0)\n\t\t    {\n\t\t\t// Ignore leading white space.\n\t\t\tp = skipwhite(p + 4);\n\t\t\theredoc_trimmed = vim_strnsave(theline,\n\t\t\t\t\t\t skipwhite(theline) - theline);\n\t\t    }\n\t\t    skip_until = vim_strnsave(p, skiptowhite(p) - p);\n\t\t    getline_options = GETLINE_NONE;\n\t\t    is_heredoc = TRUE;\n\t\t}\n\t    }\n\t}\n\n\t// Add the line to the function.\n\tif (ga_grow(newlines, 1 + sourcing_lnum_off) == FAIL)\n\t    goto theend;\n\n\tif (heredoc_concat_len > 0)\n\t{\n\t    // For a :def function \"python << EOF\" concatenats all the lines,\n\t    // to be used for the instruction later.\n\t    ga_concat(&heredoc_ga, theline);\n\t    ga_concat(&heredoc_ga, (char_u *)\"\\n\");\n\t    p = vim_strsave((char_u *)\"\");\n\t}\n\telse\n\t{\n\t    // Copy the line to newly allocated memory.  get_one_sourceline()\n\t    // allocates 250 bytes per line, this saves 80% on average.  The\n\t    // cost is an extra alloc/free.\n\t    p = vim_strsave(theline);\n\t}\n\tif (p == NULL)\n\t    goto theend;\n\t((char_u **)(newlines->ga_data))[newlines->ga_len++] = p;\n\n\t// Add NULL lines for continuation lines, so that the line count is\n\t// equal to the index in the growarray.\n\twhile (sourcing_lnum_off-- > 0)\n\t    ((char_u **)(newlines->ga_data))[newlines->ga_len++] = NULL;\n\n\t// Check for end of eap->arg.\n\tif (line_arg != NULL && *line_arg == NUL)\n\t    line_arg = NULL;\n    }\n\n    // Return OK when no error was detected.\n    if (!did_emsg)\n\tret = OK;\n\ntheend:\n    vim_free(skip_until);\n    vim_free(heredoc_trimmed);\n    vim_free(heredoc_ga.ga_data);\n    need_wait_return |= saved_wait_return;\n    return ret;\n}\n\n/*\n * Handle the body of a lambda.  *arg points to the \"{\", process statements\n * until the matching \"}\".\n * When not evaluating \"newargs\" is NULL.\n * When successful \"rettv\" is set to a funcref.\n */\n    static int\nlambda_function_body(\n\tchar_u\t    **arg,\n\ttypval_T    *rettv,\n\tevalarg_T   *evalarg,\n\tgarray_T    *newargs,\n\tgarray_T    *argtypes,\n\tint\t    varargs,\n\tgarray_T    *default_args,\n\tchar_u\t    *ret_type)\n{\n    int\t\tevaluate = (evalarg->eval_flags & EVAL_EVALUATE);\n    garray_T\t*gap = &evalarg->eval_ga;\n    garray_T\t*freegap = &evalarg->eval_freega;\n    ufunc_T\t*ufunc = NULL;\n    exarg_T\teap;\n    garray_T\tnewlines;\n    char_u\t*cmdline = NULL;\n    int\t\tret = FAIL;\n    char_u\t*line_to_free = NULL;\n    partial_T\t*pt;\n    char_u\t*name;\n    int\t\tlnum_save = -1;\n    linenr_T\tsourcing_lnum_top = SOURCING_LNUM;\n\n    if (!ends_excmd2(*arg, skipwhite(*arg + 1)))\n    {\n\tsemsg(_(e_trailing_arg), *arg + 1);\n\treturn FAIL;\n    }\n\n    CLEAR_FIELD(eap);\n    eap.cmdidx = CMD_block;\n    eap.forceit = FALSE;\n    eap.cmdlinep = &cmdline;\n    eap.skip = !evaluate;\n    if (evalarg->eval_cctx != NULL)\n\tfill_exarg_from_cctx(&eap, evalarg->eval_cctx);\n    else\n    {\n\teap.getline = evalarg->eval_getline;\n\teap.cookie = evalarg->eval_cookie;\n    }\n\n    ga_init2(&newlines, (int)sizeof(char_u *), 10);\n    if (get_function_body(&eap, &newlines, NULL, &line_to_free) == FAIL)\n    {\n\tvim_free(cmdline);\n\tgoto erret;\n    }\n\n    // When inside a lambda must add the function lines to evalarg.eval_ga.\n    evalarg->eval_break_count += newlines.ga_len;\n    if (gap->ga_itemsize > 0)\n    {\n\tint\tidx;\n\tchar_u\t*last;\n\tsize_t  plen;\n\tchar_u  *pnl;\n\n\tfor (idx = 0; idx < newlines.ga_len; ++idx)\n\t{\n\t    char_u  *p = skipwhite(((char_u **)newlines.ga_data)[idx]);\n\n\t    if (ga_grow(gap, 1) == FAIL || ga_grow(freegap, 1) == FAIL)\n\t\tgoto erret;\n\n\t    // Going to concatenate the lines after parsing.  For an empty or\n\t    // comment line use an empty string.\n\t    // Insert NL characters at the start of each line, the string will\n\t    // be split again later in .get_lambda_tv().\n\t    if (*p == NUL || vim9_comment_start(p))\n\t\tp = (char_u *)\"\";\n\t    plen = STRLEN(p);\n\t    pnl = vim_strnsave((char_u *)\"\\n\", plen + 1);\n\t    if (pnl != NULL)\n\t\tmch_memmove(pnl + 1, p, plen + 1);\n\t    ((char_u **)gap->ga_data)[gap->ga_len++] = pnl;\n\t    ((char_u **)freegap->ga_data)[freegap->ga_len++] = pnl;\n\t}\n\tif (ga_grow(gap, 1) == FAIL || ga_grow(freegap, 1) == FAIL)\n\t    goto erret;\n\tif (eap.nextcmd != NULL)\n\t    // more is following after the \"}\", which was skipped\n\t    last = cmdline;\n\telse\n\t    // nothing is following the \"}\"\n\t    last = (char_u *)\"}\";\n\tplen = STRLEN(last);\n\tpnl = vim_strnsave((char_u *)\"\\n\", plen + 1);\n\tif (pnl != NULL)\n\t    mch_memmove(pnl + 1, last, plen + 1);\n\t((char_u **)gap->ga_data)[gap->ga_len++] = pnl;\n\t((char_u **)freegap->ga_data)[freegap->ga_len++] = pnl;\n    }\n\n    if (eap.nextcmd != NULL)\n    {\n\tgarray_T *tfgap = &evalarg->eval_tofree_ga;\n\n\t// Something comes after the \"}\".\n\t*arg = eap.nextcmd;\n\n\t// \"arg\" points into cmdline, need to keep the line and free it later.\n\tif (ga_grow(tfgap, 1) == OK)\n\t{\n\t    ((char_u **)(tfgap->ga_data))[tfgap->ga_len++] = cmdline;\n\t    evalarg->eval_using_cmdline = TRUE;\n\t    if (cmdline == line_to_free)\n\t\tline_to_free = NULL;\n\t}\n    }\n    else\n\t*arg = (char_u *)\"\";\n\n    if (!evaluate)\n    {\n\tret = OK;\n\tgoto erret;\n    }\n\n    name = get_lambda_name();\n    ufunc = alloc_clear(offsetof(ufunc_T, uf_name) + STRLEN(name) + 1);\n    if (ufunc == NULL)\n\tgoto erret;\n    set_ufunc_name(ufunc, name);\n    if (hash_add(&func_hashtab, UF2HIKEY(ufunc)) == FAIL)\n\tgoto erret;\n    ufunc->uf_flags = FC_LAMBDA;\n    ufunc->uf_refcount = 1;\n    ufunc->uf_args = *newargs;\n    newargs->ga_data = NULL;\n    ufunc->uf_def_args = *default_args;\n    default_args->ga_data = NULL;\n    ufunc->uf_func_type = &t_func_any;\n\n    // error messages are for the first function line\n    lnum_save = SOURCING_LNUM;\n    SOURCING_LNUM = sourcing_lnum_top;\n\n    // parse argument types\n    if (parse_argument_types(ufunc, argtypes, varargs) == FAIL)\n    {\n\tSOURCING_LNUM = lnum_save;\n\tgoto erret;\n    }\n\n    // parse the return type, if any\n    if (parse_return_type(ufunc, ret_type) == FAIL)\n\tgoto erret;\n\n    pt = ALLOC_CLEAR_ONE(partial_T);\n    if (pt == NULL)\n\tgoto erret;\n    pt->pt_func = ufunc;\n    pt->pt_refcount = 1;\n\n    ufunc->uf_lines = newlines;\n    newlines.ga_data = NULL;\n    if (sandbox)\n\tufunc->uf_flags |= FC_SANDBOX;\n    if (!ASCII_ISUPPER(*ufunc->uf_name))\n\tufunc->uf_flags |= FC_VIM9;\n    ufunc->uf_script_ctx = current_sctx;\n    ufunc->uf_script_ctx_version = current_sctx.sc_version;\n    ufunc->uf_script_ctx.sc_lnum += sourcing_lnum_top;\n    set_function_type(ufunc);\n\n    function_using_block_scopes(ufunc, evalarg->eval_cstack);\n\n    rettv->vval.v_partial = pt;\n    rettv->v_type = VAR_PARTIAL;\n    ufunc = NULL;\n    ret = OK;\n\nerret:\n    if (lnum_save >= 0)\n\tSOURCING_LNUM = lnum_save;\n    vim_free(line_to_free);\n    ga_clear_strings(&newlines);\n    if (newargs != NULL)\n\tga_clear_strings(newargs);\n    ga_clear_strings(default_args);\n    if (ufunc != NULL)\n    {\n\tfunc_clear(ufunc, TRUE);\n\tfunc_free(ufunc, TRUE);\n    }\n    return ret;\n}\n\n/*\n * Parse a lambda expression and get a Funcref from \"*arg\" into \"rettv\".\n * \"arg\" points to the { in \"{arg -> expr}\" or the ( in \"(arg) => expr\"\n * When \"types_optional\" is TRUE optionally take argument types.\n * Return OK or FAIL.  Returns NOTDONE for dict or {expr}.\n */\n    int\nget_lambda_tv(\n\tchar_u\t    **arg,\n\ttypval_T    *rettv,\n\tint\t    types_optional,\n\tevalarg_T   *evalarg)\n{\n    int\t\tevaluate = evalarg != NULL\n\t\t\t\t      && (evalarg->eval_flags & EVAL_EVALUATE);\n    garray_T\tnewargs;\n    garray_T\tnewlines;\n    garray_T\t*pnewargs;\n    garray_T\targtypes;\n    garray_T\tdefault_args;\n    ufunc_T\t*fp = NULL;\n    partial_T   *pt = NULL;\n    int\t\tvarargs;\n    char_u\t*ret_type = NULL;\n    int\t\tret;\n    char_u\t*s;\n    char_u\t*start, *end;\n    int\t\t*old_eval_lavars = eval_lavars_used;\n    int\t\teval_lavars = FALSE;\n    char_u\t*tofree1 = NULL;\n    char_u\t*tofree2 = NULL;\n    int\t\tequal_arrow = **arg == '(';\n    int\t\twhite_error = FALSE;\n    int\t\tcalled_emsg_start = called_emsg;\n\n    if (equal_arrow && !in_vim9script())\n\treturn NOTDONE;\n\n    ga_init(&newargs);\n    ga_init(&newlines);\n\n    // First, check if this is really a lambda expression. \"->\" or \"=>\" must\n    // be found after the arguments.\n    s = *arg + 1;\n    ret = get_function_args(&s, equal_arrow ? ')' : '-', NULL,\n\t    types_optional ? &argtypes : NULL, types_optional, evalarg,\n\t\t\t\t\tNULL, &default_args, TRUE, NULL, NULL);\n    if (ret == FAIL || skip_arrow(s, equal_arrow, &ret_type, NULL) == NULL)\n    {\n\tif (types_optional)\n\t    ga_clear_strings(&argtypes);\n\treturn called_emsg == called_emsg_start ? NOTDONE : FAIL;\n    }\n\n    // Parse the arguments for real.\n    if (evaluate)\n\tpnewargs = &newargs;\n    else\n\tpnewargs = NULL;\n    *arg += 1;\n    ret = get_function_args(arg, equal_arrow ? ')' : '-', pnewargs,\n\t    types_optional ? &argtypes : NULL, types_optional, evalarg,\n\t\t\t\t\t    &varargs, &default_args,\n\t\t\t\t\t    FALSE, NULL, NULL);\n    if (ret == FAIL\n\t\t  || (s = skip_arrow(*arg, equal_arrow, &ret_type,\n\t\tequal_arrow || in_vim9script() ? &white_error : NULL)) == NULL)\n    {\n\tif (types_optional)\n\t    ga_clear_strings(&argtypes);\n\tga_clear_strings(&newargs);\n\treturn white_error ? FAIL : NOTDONE;\n    }\n    *arg = s;\n\n    // Skipping over linebreaks may make \"ret_type\" invalid, make a copy.\n    if (ret_type != NULL)\n    {\n\tret_type = vim_strsave(ret_type);\n\ttofree2 = ret_type;\n    }\n\n    // Set up a flag for checking local variables and arguments.\n    if (evaluate)\n\teval_lavars_used = &eval_lavars;\n\n    *arg = skipwhite_and_linebreak(*arg, evalarg);\n\n    // Recognize \"{\" as the start of a function body.\n    if (equal_arrow && **arg == '{')\n    {\n\tif (evalarg == NULL)\n\t    // cannot happen?\n\t    goto theend;\n\tif (lambda_function_body(arg, rettv, evalarg, pnewargs,\n\t\t\t   types_optional ? &argtypes : NULL, varargs,\n\t\t\t   &default_args, ret_type) == FAIL)\n\t    goto errret;\n\tgoto theend;\n    }\n    if (default_args.ga_len > 0)\n    {\n\temsg(_(e_cannot_use_default_values_in_lambda));\n\tgoto errret;\n    }\n\n    // Get the start and the end of the expression.\n    start = *arg;\n    ret = skip_expr_concatenate(arg, &start, &end, evalarg);\n    if (ret == FAIL)\n\tgoto errret;\n    if (evalarg != NULL)\n    {\n\t// avoid that the expression gets freed when another line break follows\n\ttofree1 = evalarg->eval_tofree;\n\tevalarg->eval_tofree = NULL;\n    }\n\n    if (!equal_arrow)\n    {\n\t*arg = skipwhite_and_linebreak(*arg, evalarg);\n\tif (**arg != '}')\n\t{\n\t    semsg(_(\"E451: Expected }: %s\"), *arg);\n\t    goto errret;\n\t}\n\t++*arg;\n    }\n\n    if (evaluate)\n    {\n\tint\t    len;\n\tint\t    flags = FC_LAMBDA;\n\tchar_u\t    *p;\n\tchar_u\t    *line_end;\n\tchar_u\t    *name = get_lambda_name();\n\n\tfp = alloc_clear(offsetof(ufunc_T, uf_name) + STRLEN(name) + 1);\n\tif (fp == NULL)\n\t    goto errret;\n\tfp->uf_def_status = UF_NOT_COMPILED;\n\tpt = ALLOC_CLEAR_ONE(partial_T);\n\tif (pt == NULL)\n\t    goto errret;\n\n\tga_init2(&newlines, (int)sizeof(char_u *), 1);\n\tif (ga_grow(&newlines, 1) == FAIL)\n\t    goto errret;\n\n\t// If there are line breaks, we need to split up the string.\n\tline_end = vim_strchr(start, '\\n');\n\tif (line_end == NULL || line_end > end)\n\t    line_end = end;\n\n\t// Add \"return \" before the expression (or the first line).\n\tlen = 7 + (int)(line_end - start) + 1;\n\tp = alloc(len);\n\tif (p == NULL)\n\t    goto errret;\n\t((char_u **)(newlines.ga_data))[newlines.ga_len++] = p;\n\tSTRCPY(p, \"return \");\n\tvim_strncpy(p + 7, start, line_end - start);\n\n\tif (line_end != end)\n\t{\n\t    // Add more lines, split by line breaks.  Thus is used when a\n\t    // lambda with { cmds } is encountered.\n\t    while (*line_end == '\\n')\n\t    {\n\t\tif (ga_grow(&newlines, 1) == FAIL)\n\t\t    goto errret;\n\t\tstart = line_end + 1;\n\t\tline_end = vim_strchr(start, '\\n');\n\t\tif (line_end == NULL)\n\t\t    line_end = end;\n\t\t((char_u **)(newlines.ga_data))[newlines.ga_len++] =\n\t\t\t\t\t vim_strnsave(start, line_end - start);\n\t    }\n\t}\n\n\tif (strstr((char *)p + 7, \"a:\") == NULL)\n\t    // No a: variables are used for sure.\n\t    flags |= FC_NOARGS;\n\n\tfp->uf_refcount = 1;\n\tset_ufunc_name(fp, name);\n\tfp->uf_args = newargs;\n\tga_init(&fp->uf_def_args);\n\tif (types_optional)\n\t{\n\t    if (parse_argument_types(fp, &argtypes,\n\t\t\t\t\t   in_vim9script() && varargs) == FAIL)\n\t\tgoto errret;\n\t    if (ret_type != NULL)\n\t    {\n\t\tfp->uf_ret_type = parse_type(&ret_type,\n\t\t\t\t\t\t      &fp->uf_type_list, TRUE);\n\t\tif (fp->uf_ret_type == NULL)\n\t\t    goto errret;\n\t    }\n\t    else\n\t\tfp->uf_ret_type = &t_unknown;\n\t}\n\n\tfp->uf_lines = newlines;\n\tif (current_funccal != NULL && eval_lavars)\n\t{\n\t    flags |= FC_CLOSURE;\n\t    if (register_closure(fp) == FAIL)\n\t\tgoto errret;\n\t}\n\n#ifdef FEAT_PROFILE\n\tif (prof_def_func())\n\t    func_do_profile(fp);\n#endif\n\tif (sandbox)\n\t    flags |= FC_SANDBOX;\n\t// In legacy script a lambda can be called with more args than\n\t// uf_args.ga_len.  In Vim9 script \"...name\" has to be used.\n\tfp->uf_varargs = !in_vim9script() || varargs;\n\tfp->uf_flags = flags;\n\tfp->uf_calls = 0;\n\tfp->uf_script_ctx = current_sctx;\n\tfp->uf_script_ctx.sc_lnum += SOURCING_LNUM - newlines.ga_len + 1;\n\n\tfunction_using_block_scopes(fp, evalarg->eval_cstack);\n\n\tpt->pt_func = fp;\n\tpt->pt_refcount = 1;\n\trettv->vval.v_partial = pt;\n\trettv->v_type = VAR_PARTIAL;\n\n\thash_add(&func_hashtab, UF2HIKEY(fp));\n    }\n\ntheend:\n    eval_lavars_used = old_eval_lavars;\n    if (evalarg != NULL && evalarg->eval_tofree == NULL)\n\tevalarg->eval_tofree = tofree1;\n    else\n\tvim_free(tofree1);\n    vim_free(tofree2);\n    if (types_optional)\n\tga_clear_strings(&argtypes);\n\n    return OK;\n\nerrret:\n    ga_clear_strings(&newargs);\n    ga_clear_strings(&newlines);\n    ga_clear_strings(&default_args);\n    if (types_optional)\n    {\n\tga_clear_strings(&argtypes);\n\tif (fp != NULL)\n\t    vim_free(fp->uf_arg_types);\n    }\n    vim_free(fp);\n    vim_free(pt);\n    if (evalarg != NULL && evalarg->eval_tofree == NULL)\n\tevalarg->eval_tofree = tofree1;\n    else\n\tvim_free(tofree1);\n    vim_free(tofree2);\n    eval_lavars_used = old_eval_lavars;\n    return FAIL;\n}\n\n/*\n * Check if \"name\" is a variable of type VAR_FUNC.  If so, return the function\n * name it contains, otherwise return \"name\".\n * If \"partialp\" is not NULL, and \"name\" is of type VAR_PARTIAL also set\n * \"partialp\".\n * If \"type\" is not NULL and a Vim9 script-local variable is found look up the\n * type of the variable.\n * If \"found_var\" is not NULL and a variable was found set it to TRUE.\n */\n    char_u *\nderef_func_name(\n\tchar_u\t    *name,\n\tint\t    *lenp,\n\tpartial_T   **partialp,\n\ttype_T\t    **type,\n\tint\t    no_autoload,\n\tint\t    *found_var)\n{\n    dictitem_T\t*v;\n    typval_T\t*tv = NULL;\n    int\t\tcc;\n    char_u\t*s = NULL;\n    hashtab_T\t*ht;\n    int\t\tdid_type = FALSE;\n\n    if (partialp != NULL)\n\t*partialp = NULL;\n\n    cc = name[*lenp];\n    name[*lenp] = NUL;\n\n    v = find_var(name, &ht, no_autoload);\n    name[*lenp] = cc;\n    if (v != NULL)\n    {\n\ttv = &v->di_tv;\n    }\n    else if (in_vim9script() || STRNCMP(name, \"s:\", 2) == 0)\n    {\n\timported_T  *import;\n\tchar_u\t    *p = name;\n\tint\t    len = *lenp;\n\n\tif (STRNCMP(name, \"s:\", 2) == 0)\n\t{\n\t    p = name + 2;\n\t    len -= 2;\n\t}\n\timport = find_imported(p, len, NULL);\n\n\t// imported variable from another script\n\tif (import != NULL)\n\t{\n\t    if (import->imp_funcname != NULL)\n\t    {\n\t\ts = import->imp_funcname;\n\t\t*lenp = (int)STRLEN(s);\n\t\treturn s;\n\t    }\n\t    if (import->imp_flags & IMP_FLAGS_STAR)\n\t    {\n\t\tname[len] = NUL;\n\t\tsemsg(_(e_cannot_use_str_itself_it_is_imported_with_star),\n\t\t\t\t\t\t\t\t\t name);\n\t\tname[len] = cc;\n\t\t*lenp = 0;\n\t\treturn (char_u *)\"\";\t// just in case\n\t    }\n\t    else\n\t    {\n\t\tscriptitem_T    *si = SCRIPT_ITEM(import->imp_sid);\n\t\tsvar_T\t\t*sv = ((svar_T *)si->sn_var_vals.ga_data)\n\t\t\t\t\t\t    + import->imp_var_vals_idx;\n\t\ttv = sv->sv_tv;\n\t\tif (type != NULL)\n\t\t    *type = sv->sv_type;\n\t\tdid_type = TRUE;\n\t    }\n\t}\n    }\n\n    if (tv != NULL)\n    {\n\tif (found_var != NULL)\n\t    *found_var = TRUE;\n\tif (tv->v_type == VAR_FUNC)\n\t{\n\t    if (tv->vval.v_string == NULL)\n\t    {\n\t\t*lenp = 0;\n\t\treturn (char_u *)\"\";\t// just in case\n\t    }\n\t    s = tv->vval.v_string;\n\t    *lenp = (int)STRLEN(s);\n\t}\n\n\tif (tv->v_type == VAR_PARTIAL)\n\t{\n\t    partial_T *pt = tv->vval.v_partial;\n\n\t    if (pt == NULL)\n\t    {\n\t\t*lenp = 0;\n\t\treturn (char_u *)\"\";\t// just in case\n\t    }\n\t    if (partialp != NULL)\n\t\t*partialp = pt;\n\t    s = partial_name(pt);\n\t    *lenp = (int)STRLEN(s);\n\t}\n\n\tif (s != NULL)\n\t{\n\t    if (!did_type && type != NULL && ht == get_script_local_ht())\n\t    {\n\t\tsvar_T  *sv = find_typval_in_script(tv);\n\n\t\tif (sv != NULL)\n\t\t    *type = sv->sv_type;\n\t    }\n\t    return s;\n\t}\n    }\n\n    return name;\n}\n\n/*\n * Give an error message with a function name.  Handle <SNR> things.\n * \"ermsg\" is to be passed without translation, use N_() instead of _().\n */\n    void\nemsg_funcname(char *ermsg, char_u *name)\n{\n    char_u\t*p;\n\n    if (*name == K_SPECIAL)\n\tp = concat_str((char_u *)\"<SNR>\", name + 3);\n    else\n\tp = name;\n    semsg(_(ermsg), p);\n    if (p != name)\n\tvim_free(p);\n}\n\n/*\n * Allocate a variable for the result of a function.\n * Return OK or FAIL.\n */\n    int\nget_func_tv(\n    char_u\t*name,\t\t// name of the function\n    int\t\tlen,\t\t// length of \"name\" or -1 to use strlen()\n    typval_T\t*rettv,\n    char_u\t**arg,\t\t// argument, pointing to the '('\n    evalarg_T\t*evalarg,\t// for line continuation\n    funcexe_T\t*funcexe)\t// various values\n{\n    char_u\t*argp;\n    int\t\tret = OK;\n    typval_T\targvars[MAX_FUNC_ARGS + 1];\t// vars for arguments\n    int\t\targcount = 0;\t\t// number of arguments found\n    int\t\tvim9script = in_vim9script();\n\n    /*\n     * Get the arguments.\n     */\n    argp = *arg;\n    while (argcount < MAX_FUNC_ARGS - (funcexe->fe_partial == NULL ? 0\n\t\t\t\t\t       : funcexe->fe_partial->pt_argc))\n    {\n\t// skip the '(' or ',' and possibly line breaks\n\targp = skipwhite_and_linebreak(argp + 1, evalarg);\n\n\tif (*argp == ')' || *argp == ',' || *argp == NUL)\n\t    break;\n\tif (eval1(&argp, &argvars[argcount], evalarg) == FAIL)\n\t{\n\t    ret = FAIL;\n\t    break;\n\t}\n\t++argcount;\n\t// The comma should come right after the argument, but this wasn't\n\t// checked previously, thus only enforce it in Vim9 script.\n\tif (vim9script)\n\t{\n\t    if (*argp != ',' && *skipwhite(argp) == ',')\n\t    {\n\t\tsemsg(_(e_no_white_space_allowed_before_str_str), \",\", argp);\n\t\tret = FAIL;\n\t\tbreak;\n\t    }\n\t}\n\telse\n\t    argp = skipwhite(argp);\n\tif (*argp != ',')\n\t    break;\n\tif (vim9script && !IS_WHITE_OR_NUL(argp[1]))\n\t{\n\t    semsg(_(e_white_space_required_after_str_str), \",\", argp);\n\t    ret = FAIL;\n\t    break;\n\t}\n    }\n    argp = skipwhite_and_linebreak(argp, evalarg);\n    if (*argp == ')')\n\t++argp;\n    else\n\tret = FAIL;\n\n    if (ret == OK)\n    {\n\tint\ti = 0;\n\tint\tdid_emsg_before = did_emsg;\n\n\tif (get_vim_var_nr(VV_TESTING))\n\t{\n\t    // Prepare for calling test_garbagecollect_now(), need to know\n\t    // what variables are used on the call stack.\n\t    if (funcargs.ga_itemsize == 0)\n\t\tga_init2(&funcargs, (int)sizeof(typval_T *), 50);\n\t    for (i = 0; i < argcount; ++i)\n\t\tif (ga_grow(&funcargs, 1) == OK)\n\t\t    ((typval_T **)funcargs.ga_data)[funcargs.ga_len++] =\n\t\t\t\t\t\t\t\t  &argvars[i];\n\t}\n\n\tret = call_func(name, len, rettv, argcount, argvars, funcexe);\n\tif (in_vim9script() && did_emsg > did_emsg_before)\n\t{\n\t    // An error in a builtin function does not return FAIL, but we do\n\t    // want to abort further processing if an error was given.\n\t    ret = FAIL;\n\t    clear_tv(rettv);\n\t}\n\n\tfuncargs.ga_len -= i;\n    }\n    else if (!aborting())\n    {\n\tif (argcount == MAX_FUNC_ARGS)\n\t    emsg_funcname(N_(\"E740: Too many arguments for function %s\"), name);\n\telse\n\t    emsg_funcname(N_(e_invalid_arguments_for_function_str), name);\n    }\n\n    while (--argcount >= 0)\n\tclear_tv(&argvars[argcount]);\n\n    if (in_vim9script())\n\t*arg = argp;\n    else\n\t*arg = skipwhite(argp);\n    return ret;\n}\n\n/*\n * Return TRUE if \"p\" starts with \"<SID>\" or \"s:\".\n * Only works if eval_fname_script() returned non-zero for \"p\"!\n */\n    static int\neval_fname_sid(char_u *p)\n{\n    return (*p == 's' || TOUPPER_ASC(p[2]) == 'I');\n}\n\n/*\n * In a script change <SID>name() and s:name() to K_SNR 123_name().\n * Change <SNR>123_name() to K_SNR 123_name().\n * Use \"fname_buf[FLEN_FIXED + 1]\" when it fits, otherwise allocate memory\n * (slow).\n */\n    char_u *\nfname_trans_sid(char_u *name, char_u *fname_buf, char_u **tofree, int *error)\n{\n    int\t\tllen;\n    char_u\t*fname;\n    int\t\ti;\n\n    llen = eval_fname_script(name);\n    if (llen > 0)\n    {\n\tfname_buf[0] = K_SPECIAL;\n\tfname_buf[1] = KS_EXTRA;\n\tfname_buf[2] = (int)KE_SNR;\n\ti = 3;\n\tif (eval_fname_sid(name))\t// \"<SID>\" or \"s:\"\n\t{\n\t    if (current_sctx.sc_sid <= 0)\n\t\t*error = FCERR_SCRIPT;\n\t    else\n\t    {\n\t\tsprintf((char *)fname_buf + 3, \"%ld_\",\n\t\t\t\t\t\t    (long)current_sctx.sc_sid);\n\t\ti = (int)STRLEN(fname_buf);\n\t    }\n\t}\n\tif (i + STRLEN(name + llen) < FLEN_FIXED)\n\t{\n\t    STRCPY(fname_buf + i, name + llen);\n\t    fname = fname_buf;\n\t}\n\telse\n\t{\n\t    fname = alloc(i + STRLEN(name + llen) + 1);\n\t    if (fname == NULL)\n\t\t*error = FCERR_OTHER;\n\t    else\n\t    {\n\t\t*tofree = fname;\n\t\tmch_memmove(fname, fname_buf, (size_t)i);\n\t\tSTRCPY(fname + i, name + llen);\n\t    }\n\t}\n    }\n    else\n\tfname = name;\n    return fname;\n}\n\n/*\n * Find a function \"name\" in script \"sid\".\n */\n    static ufunc_T *\nfind_func_with_sid(char_u *name, int sid)\n{\n    hashitem_T\t*hi;\n    char_u\tbuffer[200];\n\n    buffer[0] = K_SPECIAL;\n    buffer[1] = KS_EXTRA;\n    buffer[2] = (int)KE_SNR;\n    vim_snprintf((char *)buffer + 3, sizeof(buffer) - 3, \"%ld_%s\",\n\t\t\t\t\t\t\t      (long)sid, name);\n    hi = hash_find(&func_hashtab, buffer);\n    if (!HASHITEM_EMPTY(hi))\n\treturn HI2UF(hi);\n\n    return NULL;\n}\n\n/*\n * Find a function by name, return pointer to it in ufuncs.\n * When \"is_global\" is true don't find script-local or imported functions.\n * Return NULL for unknown function.\n */\n    ufunc_T *\nfind_func_even_dead(char_u *name, int is_global, cctx_T *cctx)\n{\n    hashitem_T\t*hi;\n    ufunc_T\t*func;\n    imported_T\t*imported;\n\n    if (!is_global)\n    {\n\tchar_u\t*after_script = NULL;\n\tlong\tsid = 0;\n\tint\tfind_script_local = in_vim9script() && eval_isnamec1(*name)\n\t\t\t\t\t   && (name[1] != ':' || *name == 's');\n\n\tif (find_script_local)\n\t{\n\t    // Find script-local function before global one.\n\t    func = find_func_with_sid(name[0] == 's' && name[1] == ':'\n\t\t\t\t       ? name + 2 : name, current_sctx.sc_sid);\n\t    if (func != NULL)\n\t\treturn func;\n\t}\n\n\tif (name[0] == K_SPECIAL\n\t\t&& name[1] == KS_EXTRA\n\t\t&& name[2] == KE_SNR)\n\t{\n\t    // Caller changes s: to <SNR>99_name.\n\n\t    after_script = name + 3;\n\t    sid = getdigits(&after_script);\n\t    if (*after_script == '_')\n\t\t++after_script;\n\t    else\n\t\tafter_script = NULL;\n\t}\n\tif (find_script_local || after_script != NULL)\n\t{\n\t    // Find imported function before global one.\n\t    if (after_script != NULL && sid != current_sctx.sc_sid)\n\t\timported = find_imported_in_script(after_script, 0, sid);\n\t    else\n\t\timported = find_imported(after_script == NULL\n\t\t\t\t\t       ? name : after_script, 0, cctx);\n\t    if (imported != NULL && imported->imp_funcname != NULL)\n\t    {\n\t\thi = hash_find(&func_hashtab, imported->imp_funcname);\n\t\tif (!HASHITEM_EMPTY(hi))\n\t\t    return HI2UF(hi);\n\t    }\n\t}\n    }\n\n    hi = hash_find(&func_hashtab,\n\t\t\t\tSTRNCMP(name, \"g:\", 2) == 0 ? name + 2 : name);\n    if (!HASHITEM_EMPTY(hi))\n\treturn HI2UF(hi);\n\n    return NULL;\n}\n\n/*\n * Find a function by name, return pointer to it in ufuncs.\n * \"cctx\" is passed in a :def function to find imported functions.\n * Return NULL for unknown or dead function.\n */\n    ufunc_T *\nfind_func(char_u *name, int is_global, cctx_T *cctx)\n{\n    ufunc_T\t*fp = find_func_even_dead(name, is_global, cctx);\n\n    if (fp != NULL && (fp->uf_flags & FC_DEAD) == 0)\n\treturn fp;\n    return NULL;\n}\n\n/*\n * Return TRUE if \"ufunc\" is a global function.\n */\n    int\nfunc_is_global(ufunc_T *ufunc)\n{\n    return ufunc->uf_name[0] != K_SPECIAL;\n}\n\n/*\n * Copy the function name of \"fp\" to buffer \"buf\".\n * \"buf\" must be able to hold the function name plus three bytes.\n * Takes care of script-local function names.\n */\n    static void\ncat_func_name(char_u *buf, ufunc_T *fp)\n{\n    if (!func_is_global(fp))\n    {\n\tSTRCPY(buf, \"<SNR>\");\n\tSTRCAT(buf, fp->uf_name + 3);\n    }\n    else\n\tSTRCPY(buf, fp->uf_name);\n}\n\n/*\n * Add a number variable \"name\" to dict \"dp\" with value \"nr\".\n */\n    static void\nadd_nr_var(\n    dict_T\t*dp,\n    dictitem_T\t*v,\n    char\t*name,\n    varnumber_T nr)\n{\n    STRCPY(v->di_key, name);\n    v->di_flags = DI_FLAGS_RO | DI_FLAGS_FIX;\n    hash_add(&dp->dv_hashtab, DI2HIKEY(v));\n    v->di_tv.v_type = VAR_NUMBER;\n    v->di_tv.v_lock = VAR_FIXED;\n    v->di_tv.vval.v_number = nr;\n}\n\n/*\n * Free \"fc\".\n */\n    static void\nfree_funccal(funccall_T *fc)\n{\n    int\ti;\n\n    for (i = 0; i < fc->fc_funcs.ga_len; ++i)\n    {\n\tufunc_T *fp = ((ufunc_T **)(fc->fc_funcs.ga_data))[i];\n\n\t// When garbage collecting a funccall_T may be freed before the\n\t// function that references it, clear its uf_scoped field.\n\t// The function may have been redefined and point to another\n\t// funccall_T, don't clear it then.\n\tif (fp != NULL && fp->uf_scoped == fc)\n\t    fp->uf_scoped = NULL;\n    }\n    ga_clear(&fc->fc_funcs);\n\n    func_ptr_unref(fc->func);\n    vim_free(fc);\n}\n\n/*\n * Free \"fc\" and what it contains.\n * Can be called only when \"fc\" is kept beyond the period of it called,\n * i.e. after cleanup_function_call(fc).\n */\n   static void\nfree_funccal_contents(funccall_T *fc)\n{\n    listitem_T\t*li;\n\n    // Free all l: variables.\n    vars_clear(&fc->l_vars.dv_hashtab);\n\n    // Free all a: variables.\n    vars_clear(&fc->l_avars.dv_hashtab);\n\n    // Free the a:000 variables.\n    FOR_ALL_LIST_ITEMS(&fc->l_varlist, li)\n\tclear_tv(&li->li_tv);\n\n    free_funccal(fc);\n}\n\n/*\n * Handle the last part of returning from a function: free the local hashtable.\n * Unless it is still in use by a closure.\n */\n    static void\ncleanup_function_call(funccall_T *fc)\n{\n    int\tmay_free_fc = fc->fc_refcount <= 0;\n    int\tfree_fc = TRUE;\n\n    current_funccal = fc->caller;\n\n    // Free all l: variables if not referred.\n    if (may_free_fc && fc->l_vars.dv_refcount == DO_NOT_FREE_CNT)\n\tvars_clear(&fc->l_vars.dv_hashtab);\n    else\n\tfree_fc = FALSE;\n\n    // If the a:000 list and the l: and a: dicts are not referenced and\n    // there is no closure using it, we can free the funccall_T and what's\n    // in it.\n    if (may_free_fc && fc->l_avars.dv_refcount == DO_NOT_FREE_CNT)\n\tvars_clear_ext(&fc->l_avars.dv_hashtab, FALSE);\n    else\n    {\n\tint\t    todo;\n\thashitem_T  *hi;\n\tdictitem_T  *di;\n\n\tfree_fc = FALSE;\n\n\t// Make a copy of the a: variables, since we didn't do that above.\n\ttodo = (int)fc->l_avars.dv_hashtab.ht_used;\n\tfor (hi = fc->l_avars.dv_hashtab.ht_array; todo > 0; ++hi)\n\t{\n\t    if (!HASHITEM_EMPTY(hi))\n\t    {\n\t\t--todo;\n\t\tdi = HI2DI(hi);\n\t\tcopy_tv(&di->di_tv, &di->di_tv);\n\t    }\n\t}\n    }\n\n    if (may_free_fc && fc->l_varlist.lv_refcount == DO_NOT_FREE_CNT)\n\tfc->l_varlist.lv_first = NULL;\n    else\n    {\n\tlistitem_T *li;\n\n\tfree_fc = FALSE;\n\n\t// Make a copy of the a:000 items, since we didn't do that above.\n\tFOR_ALL_LIST_ITEMS(&fc->l_varlist, li)\n\t    copy_tv(&li->li_tv, &li->li_tv);\n    }\n\n    if (free_fc)\n\tfree_funccal(fc);\n    else\n    {\n\tstatic int made_copy = 0;\n\n\t// \"fc\" is still in use.  This can happen when returning \"a:000\",\n\t// assigning \"l:\" to a global variable or defining a closure.\n\t// Link \"fc\" in the list for garbage collection later.\n\tfc->caller = previous_funccal;\n\tprevious_funccal = fc;\n\n\tif (want_garbage_collect)\n\t    // If garbage collector is ready, clear count.\n\t    made_copy = 0;\n\telse if (++made_copy >= (int)((4096 * 1024) / sizeof(*fc)))\n\t{\n\t    // We have made a lot of copies, worth 4 Mbyte.  This can happen\n\t    // when repetitively calling a function that creates a reference to\n\t    // itself somehow.  Call the garbage collector soon to avoid using\n\t    // too much memory.\n\t    made_copy = 0;\n\t    want_garbage_collect = TRUE;\n\t}\n    }\n}\n\n/*\n * Return TRUE if \"name\" is a numbered function, ignoring a \"g:\" prefix.\n */\n    static int\nnumbered_function(char_u *name)\n{\n    return isdigit(*name)\n\t    || (name[0] == 'g' && name[1] == ':' && isdigit(name[2]));\n}\n\n/*\n * There are two kinds of function names:\n * 1. ordinary names, function defined with :function or :def\n * 2. numbered functions and lambdas\n * For the first we only count the name stored in func_hashtab as a reference,\n * using function() does not count as a reference, because the function is\n * looked up by name.\n */\n    int\nfunc_name_refcount(char_u *name)\n{\n    return numbered_function(name) || *name == '<';\n}\n\n/*\n * Unreference \"fc\": decrement the reference count and free it when it\n * becomes zero.  \"fp\" is detached from \"fc\".\n * When \"force\" is TRUE we are exiting.\n */\n    static void\nfunccal_unref(funccall_T *fc, ufunc_T *fp, int force)\n{\n    funccall_T\t**pfc;\n    int\t\ti;\n\n    if (fc == NULL)\n\treturn;\n\n    if (--fc->fc_refcount <= 0 && (force || (\n\t\tfc->l_varlist.lv_refcount == DO_NOT_FREE_CNT\n\t\t&& fc->l_vars.dv_refcount == DO_NOT_FREE_CNT\n\t\t&& fc->l_avars.dv_refcount == DO_NOT_FREE_CNT)))\n\tfor (pfc = &previous_funccal; *pfc != NULL; pfc = &(*pfc)->caller)\n\t{\n\t    if (fc == *pfc)\n\t    {\n\t\t*pfc = fc->caller;\n\t\tfree_funccal_contents(fc);\n\t\treturn;\n\t    }\n\t}\n    for (i = 0; i < fc->fc_funcs.ga_len; ++i)\n\tif (((ufunc_T **)(fc->fc_funcs.ga_data))[i] == fp)\n\t    ((ufunc_T **)(fc->fc_funcs.ga_data))[i] = NULL;\n}\n\n/*\n * Remove the function from the function hashtable.  If the function was\n * deleted while it still has references this was already done.\n * Return TRUE if the entry was deleted, FALSE if it wasn't found.\n */\n    static int\nfunc_remove(ufunc_T *fp)\n{\n    hashitem_T\t*hi;\n\n    // Return if it was already virtually deleted.\n    if (fp->uf_flags & FC_DEAD)\n\treturn FALSE;\n\n    hi = hash_find(&func_hashtab, UF2HIKEY(fp));\n    if (!HASHITEM_EMPTY(hi))\n    {\n\t// When there is a def-function index do not actually remove the\n\t// function, so we can find the index when defining the function again.\n\t// Do remove it when it's a copy.\n\tif (fp->uf_def_status == UF_COMPILED && (fp->uf_flags & FC_COPY) == 0)\n\t{\n\t    fp->uf_flags |= FC_DEAD;\n\t    return FALSE;\n\t}\n\thash_remove(&func_hashtab, hi);\n\tfp->uf_flags |= FC_DELETED;\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n    static void\nfunc_clear_items(ufunc_T *fp)\n{\n    ga_clear_strings(&(fp->uf_args));\n    ga_clear_strings(&(fp->uf_def_args));\n    ga_clear_strings(&(fp->uf_lines));\n    VIM_CLEAR(fp->uf_arg_types);\n    VIM_CLEAR(fp->uf_block_ids);\n    VIM_CLEAR(fp->uf_va_name);\n    clear_type_list(&fp->uf_type_list);\n\n    // Increment the refcount of this function to avoid it being freed\n    // recursively when the partial is freed.\n    fp->uf_refcount += 3;\n    partial_unref(fp->uf_partial);\n    fp->uf_partial = NULL;\n    fp->uf_refcount -= 3;\n\n#ifdef FEAT_LUA\n    if (fp->uf_cb_free != NULL)\n    {\n\tfp->uf_cb_free(fp->uf_cb_state);\n\tfp->uf_cb_free = NULL;\n    }\n\n    fp->uf_cb_state = NULL;\n    fp->uf_cb = NULL;\n#endif\n#ifdef FEAT_PROFILE\n    VIM_CLEAR(fp->uf_tml_count);\n    VIM_CLEAR(fp->uf_tml_total);\n    VIM_CLEAR(fp->uf_tml_self);\n#endif\n}\n\n/*\n * Free all things that a function contains.  Does not free the function\n * itself, use func_free() for that.\n * When \"force\" is TRUE we are exiting.\n */\n    static void\nfunc_clear(ufunc_T *fp, int force)\n{\n    if (fp->uf_cleared)\n\treturn;\n    fp->uf_cleared = TRUE;\n\n    // clear this function\n    func_clear_items(fp);\n    funccal_unref(fp->uf_scoped, fp, force);\n    unlink_def_function(fp);\n}\n\n/*\n * Free a function and remove it from the list of functions.  Does not free\n * what a function contains, call func_clear() first.\n * When \"force\" is TRUE we are exiting.\n * Returns OK when the function was actually freed.\n */\n    static int\nfunc_free(ufunc_T *fp, int force)\n{\n    // Only remove it when not done already, otherwise we would remove a newer\n    // version of the function with the same name.\n    if ((fp->uf_flags & (FC_DELETED | FC_REMOVED)) == 0)\n\tfunc_remove(fp);\n\n    if ((fp->uf_flags & FC_DEAD) == 0 || force)\n    {\n\tif (fp->uf_dfunc_idx > 0)\n\t    unlink_def_function(fp);\n\tVIM_CLEAR(fp->uf_name_exp);\n\tvim_free(fp);\n\treturn OK;\n    }\n    return FAIL;\n}\n\n/*\n * Free all things that a function contains and free the function itself.\n * When \"force\" is TRUE we are exiting.\n */\n    void\nfunc_clear_free(ufunc_T *fp, int force)\n{\n    func_clear(fp, force);\n    if (force || fp->uf_dfunc_idx == 0 || func_name_refcount(fp->uf_name)\n\t\t\t\t\t\t   || (fp->uf_flags & FC_COPY))\n\tfunc_free(fp, force);\n    else\n\tfp->uf_flags |= FC_DEAD;\n}\n\n/*\n * Copy already defined function \"lambda\" to a new function with name \"global\".\n * This is for when a compiled function defines a global function.\n */\n    int\ncopy_func(char_u *lambda, char_u *global, ectx_T *ectx)\n{\n    ufunc_T *ufunc = find_func_even_dead(lambda, TRUE, NULL);\n    ufunc_T *fp = NULL;\n\n    if (ufunc == NULL)\n    {\n\tsemsg(_(e_lambda_function_not_found_str), lambda);\n\treturn FAIL;\n    }\n\n    fp = find_func(global, TRUE, NULL);\n    if (fp != NULL)\n    {\n\t// TODO: handle ! to overwrite\n\tsemsg(_(e_funcexts), global);\n\treturn FAIL;\n    }\n\n    fp = alloc_clear(offsetof(ufunc_T, uf_name) + STRLEN(global) + 1);\n    if (fp == NULL)\n\treturn FAIL;\n\n    fp->uf_varargs = ufunc->uf_varargs;\n    fp->uf_flags = (ufunc->uf_flags & ~FC_VIM9) | FC_COPY;\n    fp->uf_def_status = ufunc->uf_def_status;\n    fp->uf_dfunc_idx = ufunc->uf_dfunc_idx;\n    if (ga_copy_strings(&ufunc->uf_args, &fp->uf_args) == FAIL\n\t    || ga_copy_strings(&ufunc->uf_def_args, &fp->uf_def_args)\n\t\t\t\t\t\t\t\t    == FAIL\n\t    || ga_copy_strings(&ufunc->uf_lines, &fp->uf_lines) == FAIL)\n\tgoto failed;\n\n    fp->uf_name_exp = ufunc->uf_name_exp == NULL ? NULL\n\t\t\t\t\t : vim_strsave(ufunc->uf_name_exp);\n    if (ufunc->uf_arg_types != NULL)\n    {\n\tfp->uf_arg_types = ALLOC_MULT(type_T *, fp->uf_args.ga_len);\n\tif (fp->uf_arg_types == NULL)\n\t    goto failed;\n\tmch_memmove(fp->uf_arg_types, ufunc->uf_arg_types,\n\t\t\t\t    sizeof(type_T *) * fp->uf_args.ga_len);\n    }\n    if (ufunc->uf_va_name != NULL)\n    {\n\tfp->uf_va_name = vim_strsave(ufunc->uf_va_name);\n\tif (fp->uf_va_name == NULL)\n\t    goto failed;\n    }\n    fp->uf_ret_type = ufunc->uf_ret_type;\n\n    fp->uf_refcount = 1;\n    STRCPY(fp->uf_name, global);\n    hash_add(&func_hashtab, UF2HIKEY(fp));\n\n    // the referenced dfunc_T is now used one more time\n    link_def_function(fp);\n\n    // Create a partial to store the context of the function where it was\n    // instantiated.  Only needs to be done once.  Do this on the original\n    // function, \"dfunc->df_ufunc\" will point to it.\n    if ((ufunc->uf_flags & FC_CLOSURE) && ufunc->uf_partial == NULL)\n    {\n\tpartial_T   *pt = ALLOC_CLEAR_ONE(partial_T);\n\n\tif (pt == NULL)\n\t    goto failed;\n\tif (fill_partial_and_closure(pt, ufunc, ectx) == FAIL)\n\t{\n            vim_free(pt);\n\t    goto failed;\n\t}\n\tufunc->uf_partial = pt;\n\t--pt->pt_refcount;  // not actually referenced here\n    }\n\n    return OK;\n\nfailed:\n    func_clear_free(fp, TRUE);\n    return FAIL;\n}\n\nstatic int\tfuncdepth = 0;\n\n/*\n * Increment the function call depth count.\n * Return FAIL when going over 'maxfuncdepth'.\n * Otherwise return OK, must call funcdepth_decrement() later!\n */\n    int\nfuncdepth_increment(void)\n{\n    if (funcdepth >= p_mfd)\n    {\n\temsg(_(\"E132: Function call depth is higher than 'maxfuncdepth'\"));\n\treturn FAIL;\n    }\n    ++funcdepth;\n    return OK;\n}\n\n    void\nfuncdepth_decrement(void)\n{\n    --funcdepth;\n}\n\n/*\n * Get the current function call depth.\n */\n    int\nfuncdepth_get(void)\n{\n    return funcdepth;\n}\n\n/*\n * Restore the function call depth.  This is for cases where there is no\n * guarantee funcdepth_decrement() can be called exactly the same number of\n * times as funcdepth_increment().\n */\n    void\nfuncdepth_restore(int depth)\n{\n    funcdepth = depth;\n}\n\n/*\n * Call a user function.\n */\n    static void\ncall_user_func(\n    ufunc_T\t*fp,\t\t// pointer to function\n    int\t\targcount,\t// nr of args\n    typval_T\t*argvars,\t// arguments\n    typval_T\t*rettv,\t\t// return value\n    funcexe_T\t*funcexe,\t// context\n    dict_T\t*selfdict)\t// Dictionary for \"self\"\n{\n    sctx_T\tsave_current_sctx;\n    int\t\tusing_sandbox = FALSE;\n    funccall_T\t*fc;\n    int\t\tsave_did_emsg;\n    int\t\tdefault_arg_err = FALSE;\n    dictitem_T\t*v;\n    int\t\tfixvar_idx = 0;\t// index in fixvar[]\n    int\t\ti;\n    int\t\tai;\n    int\t\tislambda = FALSE;\n    char_u\tnumbuf[NUMBUFLEN];\n    char_u\t*name;\n    typval_T\t*tv_to_free[MAX_FUNC_ARGS];\n    int\t\ttv_to_free_len = 0;\n#ifdef FEAT_PROFILE\n    profinfo_T\tprofile_info;\n#endif\n    ESTACK_CHECK_DECLARATION\n\n#ifdef FEAT_PROFILE\n    CLEAR_FIELD(profile_info);\n#endif\n\n    // If depth of calling is getting too high, don't execute the function.\n    if (funcdepth_increment() == FAIL)\n    {\n\trettv->v_type = VAR_NUMBER;\n\trettv->vval.v_number = -1;\n\treturn;\n    }\n\n    line_breakcheck();\t\t// check for CTRL-C hit\n\n    fc = ALLOC_CLEAR_ONE(funccall_T);\n    if (fc == NULL)\n\treturn;\n    fc->caller = current_funccal;\n    current_funccal = fc;\n    fc->func = fp;\n    fc->rettv = rettv;\n    fc->level = ex_nesting_level;\n    // Check if this function has a breakpoint.\n    fc->breakpoint = dbg_find_breakpoint(FALSE, fp->uf_name, (linenr_T)0);\n    fc->dbg_tick = debug_tick;\n    // Set up fields for closure.\n    ga_init2(&fc->fc_funcs, sizeof(ufunc_T *), 1);\n    func_ptr_ref(fp);\n\n    if (fp->uf_def_status != UF_NOT_COMPILED)\n    {\n#ifdef FEAT_PROFILE\n\tufunc_T *caller = fc->caller == NULL ? NULL : fc->caller->func;\n#endif\n\t// Execute the function, possibly compiling it first.\n#ifdef FEAT_PROFILE\n\tif (do_profiling == PROF_YES)\n\t    profile_may_start_func(&profile_info, fp, caller);\n#endif\n\tcall_def_function(fp, argcount, argvars, funcexe->fe_partial, rettv);\n\tfuncdepth_decrement();\n#ifdef FEAT_PROFILE\n\tif (do_profiling == PROF_YES && (fp->uf_profiling\n\t\t\t\t  || (caller != NULL && caller->uf_profiling)))\n\t    profile_may_end_func(&profile_info, fp, caller);\n#endif\n\tcurrent_funccal = fc->caller;\n\tfree_funccal(fc);\n\treturn;\n    }\n\n    islambda = fp->uf_flags & FC_LAMBDA;\n\n    /*\n     * Note about using fc->fixvar[]: This is an array of FIXVAR_CNT variables\n     * with names up to VAR_SHORT_LEN long.  This avoids having to alloc/free\n     * each argument variable and saves a lot of time.\n     */\n    /*\n     * Init l: variables.\n     */\n    init_var_dict(&fc->l_vars, &fc->l_vars_var, VAR_DEF_SCOPE);\n    if (selfdict != NULL)\n    {\n\t// Set l:self to \"selfdict\".  Use \"name\" to avoid a warning from\n\t// some compiler that checks the destination size.\n\tv = &fc->fixvar[fixvar_idx++].var;\n\tname = v->di_key;\n\tSTRCPY(name, \"self\");\n\tv->di_flags = DI_FLAGS_RO | DI_FLAGS_FIX;\n\thash_add(&fc->l_vars.dv_hashtab, DI2HIKEY(v));\n\tv->di_tv.v_type = VAR_DICT;\n\tv->di_tv.v_lock = 0;\n\tv->di_tv.vval.v_dict = selfdict;\n\t++selfdict->dv_refcount;\n    }\n\n    /*\n     * Init a: variables, unless none found (in lambda).\n     * Set a:0 to \"argcount\" less number of named arguments, if >= 0.\n     * Set a:000 to a list with room for the \"...\" arguments.\n     */\n    init_var_dict(&fc->l_avars, &fc->l_avars_var, VAR_SCOPE);\n    if ((fp->uf_flags & FC_NOARGS) == 0)\n\tadd_nr_var(&fc->l_avars, &fc->fixvar[fixvar_idx++].var, \"0\",\n\t\t\t\t(varnumber_T)(argcount >= fp->uf_args.ga_len\n\t\t\t\t    ? argcount - fp->uf_args.ga_len : 0));\n    fc->l_avars.dv_lock = VAR_FIXED;\n    if ((fp->uf_flags & FC_NOARGS) == 0)\n    {\n\t// Use \"name\" to avoid a warning from some compiler that checks the\n\t// destination size.\n\tv = &fc->fixvar[fixvar_idx++].var;\n\tname = v->di_key;\n\tSTRCPY(name, \"000\");\n\tv->di_flags = DI_FLAGS_RO | DI_FLAGS_FIX;\n\thash_add(&fc->l_avars.dv_hashtab, DI2HIKEY(v));\n\tv->di_tv.v_type = VAR_LIST;\n\tv->di_tv.v_lock = VAR_FIXED;\n\tv->di_tv.vval.v_list = &fc->l_varlist;\n    }\n    CLEAR_FIELD(fc->l_varlist);\n    fc->l_varlist.lv_refcount = DO_NOT_FREE_CNT;\n    fc->l_varlist.lv_lock = VAR_FIXED;\n\n    /*\n     * Set a:firstline to \"firstline\" and a:lastline to \"lastline\".\n     * Set a:name to named arguments.\n     * Set a:N to the \"...\" arguments.\n     * Skipped when no a: variables used (in lambda).\n     */\n    if ((fp->uf_flags & FC_NOARGS) == 0)\n    {\n\tadd_nr_var(&fc->l_avars, &fc->fixvar[fixvar_idx++].var, \"firstline\",\n\t\t\t\t\t   (varnumber_T)funcexe->fe_firstline);\n\tadd_nr_var(&fc->l_avars, &fc->fixvar[fixvar_idx++].var, \"lastline\",\n\t\t\t\t\t    (varnumber_T)funcexe->fe_lastline);\n    }\n    for (i = 0; i < argcount || i < fp->uf_args.ga_len; ++i)\n    {\n\tint\t    addlocal = FALSE;\n\ttypval_T    def_rettv;\n\tint\t    isdefault = FALSE;\n\n\tai = i - fp->uf_args.ga_len;\n\tif (ai < 0)\n\t{\n\t    // named argument a:name\n\t    name = FUNCARG(fp, i);\n\t    if (islambda)\n\t\taddlocal = TRUE;\n\n\t    // evaluate named argument default expression\n\t    isdefault = ai + fp->uf_def_args.ga_len >= 0\n\t\t       && (i >= argcount || (argvars[i].v_type == VAR_SPECIAL\n\t\t\t\t   && argvars[i].vval.v_number == VVAL_NONE));\n\t    if (isdefault)\n\t    {\n\t\tchar_u\t    *default_expr = NULL;\n\n\t\tdef_rettv.v_type = VAR_NUMBER;\n\t\tdef_rettv.vval.v_number = -1;\n\n\t\tdefault_expr = ((char_u **)(fp->uf_def_args.ga_data))\n\t\t\t\t\t\t [ai + fp->uf_def_args.ga_len];\n\t\tif (eval1(&default_expr, &def_rettv, &EVALARG_EVALUATE) == FAIL)\n\t\t{\n\t\t    default_arg_err = 1;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\telse\n\t{\n\t    if ((fp->uf_flags & FC_NOARGS) != 0)\n\t\t// Bail out if no a: arguments used (in lambda).\n\t\tbreak;\n\n\t    // \"...\" argument a:1, a:2, etc.\n\t    sprintf((char *)numbuf, \"%d\", ai + 1);\n\t    name = numbuf;\n\t}\n\tif (fixvar_idx < FIXVAR_CNT && STRLEN(name) <= VAR_SHORT_LEN)\n\t{\n\t    v = &fc->fixvar[fixvar_idx++].var;\n\t    v->di_flags = DI_FLAGS_RO | DI_FLAGS_FIX;\n\t    STRCPY(v->di_key, name);\n\t}\n\telse\n\t{\n\t    v = dictitem_alloc(name);\n\t    if (v == NULL)\n\t\tbreak;\n\t    v->di_flags |= DI_FLAGS_RO | DI_FLAGS_FIX;\n\t}\n\n\t// Note: the values are copied directly to avoid alloc/free.\n\t// \"argvars\" must have VAR_FIXED for v_lock.\n\tv->di_tv = isdefault ? def_rettv : argvars[i];\n\tv->di_tv.v_lock = VAR_FIXED;\n\n\tif (isdefault)\n\t    // Need to free this later, no matter where it's stored.\n\t    tv_to_free[tv_to_free_len++] = &v->di_tv;\n\n\tif (addlocal)\n\t{\n\t    // Named arguments should be accessed without the \"a:\" prefix in\n\t    // lambda expressions.  Add to the l: dict.\n\t    copy_tv(&v->di_tv, &v->di_tv);\n\t    hash_add(&fc->l_vars.dv_hashtab, DI2HIKEY(v));\n\t}\n\telse\n\t    hash_add(&fc->l_avars.dv_hashtab, DI2HIKEY(v));\n\n\tif (ai >= 0 && ai < MAX_FUNC_ARGS)\n\t{\n\t    listitem_T *li = &fc->l_listitems[ai];\n\n\t    li->li_tv = argvars[i];\n\t    li->li_tv.v_lock = VAR_FIXED;\n\t    list_append(&fc->l_varlist, li);\n\t}\n    }\n\n    // Don't redraw while executing the function.\n    ++RedrawingDisabled;\n\n    if (fp->uf_flags & FC_SANDBOX)\n    {\n\tusing_sandbox = TRUE;\n\t++sandbox;\n    }\n\n    estack_push_ufunc(fp, 1);\n    ESTACK_CHECK_SETUP\n    if (p_verbose >= 12)\n    {\n\t++no_wait_return;\n\tverbose_enter_scroll();\n\n\tsmsg(_(\"calling %s\"), SOURCING_NAME);\n\tif (p_verbose >= 14)\n\t{\n\t    char_u\tbuf[MSG_BUF_LEN];\n\t    char_u\tnumbuf2[NUMBUFLEN];\n\t    char_u\t*tofree;\n\t    char_u\t*s;\n\n\t    msg_puts(\"(\");\n\t    for (i = 0; i < argcount; ++i)\n\t    {\n\t\tif (i > 0)\n\t\t    msg_puts(\", \");\n\t\tif (argvars[i].v_type == VAR_NUMBER)\n\t\t    msg_outnum((long)argvars[i].vval.v_number);\n\t\telse\n\t\t{\n\t\t    // Do not want errors such as E724 here.\n\t\t    ++emsg_off;\n\t\t    s = tv2string(&argvars[i], &tofree, numbuf2, 0);\n\t\t    --emsg_off;\n\t\t    if (s != NULL)\n\t\t    {\n\t\t\tif (vim_strsize(s) > MSG_BUF_CLEN)\n\t\t\t{\n\t\t\t    trunc_string(s, buf, MSG_BUF_CLEN, MSG_BUF_LEN);\n\t\t\t    s = buf;\n\t\t\t}\n\t\t\tmsg_puts((char *)s);\n\t\t\tvim_free(tofree);\n\t\t    }\n\t\t}\n\t    }\n\t    msg_puts(\")\");\n\t}\n\tmsg_puts(\"\\n\");   // don't overwrite this either\n\n\tverbose_leave_scroll();\n\t--no_wait_return;\n    }\n#ifdef FEAT_PROFILE\n    if (do_profiling == PROF_YES)\n\tprofile_may_start_func(&profile_info, fp,\n\t\t\t\t fc->caller == NULL ? NULL : fc->caller->func);\n#endif\n\n    save_current_sctx = current_sctx;\n    current_sctx = fp->uf_script_ctx;\n    save_did_emsg = did_emsg;\n    did_emsg = FALSE;\n\n    if (default_arg_err && (fp->uf_flags & FC_ABORT))\n\tdid_emsg = TRUE;\n    else if (islambda)\n    {\n\tchar_u *p = *(char_u **)fp->uf_lines.ga_data + 7;\n\n\t// A Lambda always has the command \"return {expr}\".  It is much faster\n\t// to evaluate {expr} directly.\n\t++ex_nesting_level;\n\t(void)eval1(&p, rettv, &EVALARG_EVALUATE);\n\t--ex_nesting_level;\n    }\n    else\n\t// call do_cmdline() to execute the lines\n\tdo_cmdline(NULL, get_func_line, (void *)fc,\n\t\t\t\t     DOCMD_NOWAIT|DOCMD_VERBOSE|DOCMD_REPEAT);\n\n    --RedrawingDisabled;\n\n    // when the function was aborted because of an error, return -1\n    if ((did_emsg && (fp->uf_flags & FC_ABORT)) || rettv->v_type == VAR_UNKNOWN)\n    {\n\tclear_tv(rettv);\n\trettv->v_type = VAR_NUMBER;\n\trettv->vval.v_number = -1;\n    }\n\n#ifdef FEAT_PROFILE\n    if (do_profiling == PROF_YES)\n    {\n\tufunc_T *caller = fc->caller == NULL ? NULL : fc->caller->func;\n\n\tif (fp->uf_profiling || (caller != NULL && caller->uf_profiling))\n\t    profile_may_end_func(&profile_info, fp, caller);\n    }\n#endif\n\n    // when being verbose, mention the return value\n    if (p_verbose >= 12)\n    {\n\t++no_wait_return;\n\tverbose_enter_scroll();\n\n\tif (aborting())\n\t    smsg(_(\"%s aborted\"), SOURCING_NAME);\n\telse if (fc->rettv->v_type == VAR_NUMBER)\n\t    smsg(_(\"%s returning #%ld\"), SOURCING_NAME,\n\t\t\t\t\t       (long)fc->rettv->vval.v_number);\n\telse\n\t{\n\t    char_u\tbuf[MSG_BUF_LEN];\n\t    char_u\tnumbuf2[NUMBUFLEN];\n\t    char_u\t*tofree;\n\t    char_u\t*s;\n\n\t    // The value may be very long.  Skip the middle part, so that we\n\t    // have some idea how it starts and ends. smsg() would always\n\t    // truncate it at the end. Don't want errors such as E724 here.\n\t    ++emsg_off;\n\t    s = tv2string(fc->rettv, &tofree, numbuf2, 0);\n\t    --emsg_off;\n\t    if (s != NULL)\n\t    {\n\t\tif (vim_strsize(s) > MSG_BUF_CLEN)\n\t\t{\n\t\t    trunc_string(s, buf, MSG_BUF_CLEN, MSG_BUF_LEN);\n\t\t    s = buf;\n\t\t}\n\t\tsmsg(_(\"%s returning %s\"), SOURCING_NAME, s);\n\t\tvim_free(tofree);\n\t    }\n\t}\n\tmsg_puts(\"\\n\");   // don't overwrite this either\n\n\tverbose_leave_scroll();\n\t--no_wait_return;\n    }\n\n    ESTACK_CHECK_NOW\n    estack_pop();\n    current_sctx = save_current_sctx;\n#ifdef FEAT_PROFILE\n    if (do_profiling == PROF_YES)\n\tscript_prof_restore(&profile_info.pi_wait_start);\n#endif\n    if (using_sandbox)\n\t--sandbox;\n\n    if (p_verbose >= 12 && SOURCING_NAME != NULL)\n    {\n\t++no_wait_return;\n\tverbose_enter_scroll();\n\n\tsmsg(_(\"continuing in %s\"), SOURCING_NAME);\n\tmsg_puts(\"\\n\");   // don't overwrite this either\n\n\tverbose_leave_scroll();\n\t--no_wait_return;\n    }\n\n    did_emsg |= save_did_emsg;\n    funcdepth_decrement();\n    for (i = 0; i < tv_to_free_len; ++i)\n\tclear_tv(tv_to_free[i]);\n    cleanup_function_call(fc);\n}\n\n/*\n * Check the argument count for user function \"fp\".\n * Return FCERR_UNKNOWN if OK, FCERR_TOOFEW or FCERR_TOOMANY otherwise.\n */\n    int\ncheck_user_func_argcount(ufunc_T *fp, int argcount)\n{\n    int regular_args = fp->uf_args.ga_len;\n\n    if (argcount < regular_args - fp->uf_def_args.ga_len)\n\treturn FCERR_TOOFEW;\n    else if (!has_varargs(fp) && argcount > regular_args)\n\treturn FCERR_TOOMANY;\n    return FCERR_UNKNOWN;\n}\n\n/*\n * Call a user function after checking the arguments.\n */\n    int\ncall_user_func_check(\n\tufunc_T\t    *fp,\n\tint\t    argcount,\n\ttypval_T    *argvars,\n\ttypval_T    *rettv,\n\tfuncexe_T   *funcexe,\n\tdict_T\t    *selfdict)\n{\n    int error;\n\n    if (fp->uf_flags & FC_RANGE && funcexe->fe_doesrange != NULL)\n\t*funcexe->fe_doesrange = TRUE;\n    error = check_user_func_argcount(fp, argcount);\n    if (error != FCERR_UNKNOWN)\n\treturn error;\n    if ((fp->uf_flags & FC_DICT) && selfdict == NULL)\n\terror = FCERR_DICT;\n    else\n    {\n\tint\t\tdid_save_redo = FALSE;\n\tsave_redo_T\tsave_redo;\n\n\t/*\n\t * Call the user function.\n\t * Save and restore search patterns, script variables and\n\t * redo buffer.\n\t */\n\tsave_search_patterns();\n\tif (!ins_compl_active())\n\t{\n\t    saveRedobuff(&save_redo);\n\t    did_save_redo = TRUE;\n\t}\n\t++fp->uf_calls;\n\tcall_user_func(fp, argcount, argvars, rettv, funcexe,\n\t\t\t\t   (fp->uf_flags & FC_DICT) ? selfdict : NULL);\n\tif (--fp->uf_calls <= 0 && fp->uf_refcount <= 0)\n\t    // Function was unreferenced while being used, free it now.\n\t    func_clear_free(fp, FALSE);\n\tif (did_save_redo)\n\t    restoreRedobuff(&save_redo);\n\trestore_search_patterns();\n\terror = FCERR_NONE;\n    }\n    return error;\n}\n\nstatic funccal_entry_T *funccal_stack = NULL;\n\n/*\n * Save the current function call pointer, and set it to NULL.\n * Used when executing autocommands and for \":source\".\n */\n    void\nsave_funccal(funccal_entry_T *entry)\n{\n    entry->top_funccal = current_funccal;\n    entry->next = funccal_stack;\n    funccal_stack = entry;\n    current_funccal = NULL;\n}\n\n    void\nrestore_funccal(void)\n{\n    if (funccal_stack == NULL)\n\tiemsg(\"INTERNAL: restore_funccal()\");\n    else\n    {\n\tcurrent_funccal = funccal_stack->top_funccal;\n\tfunccal_stack = funccal_stack->next;\n    }\n}\n\n    funccall_T *\nget_current_funccal(void)\n{\n    return current_funccal;\n}\n\n/*\n * Mark all functions of script \"sid\" as deleted.\n */\n    void\ndelete_script_functions(int sid)\n{\n    hashitem_T\t*hi;\n    ufunc_T\t*fp;\n    long_u\ttodo = 1;\n    char_u\tbuf[30];\n    size_t\tlen;\n\n    buf[0] = K_SPECIAL;\n    buf[1] = KS_EXTRA;\n    buf[2] = (int)KE_SNR;\n    sprintf((char *)buf + 3, \"%d_\", sid);\n    len = STRLEN(buf);\n\n    while (todo > 0)\n    {\n\ttodo = func_hashtab.ht_used;\n\tfor (hi = func_hashtab.ht_array; todo > 0; ++hi)\n\t    if (!HASHITEM_EMPTY(hi))\n\t    {\n\t\tfp = HI2UF(hi);\n\t\tif (STRNCMP(fp->uf_name, buf, len) == 0)\n\t\t{\n\t\t    int changed = func_hashtab.ht_changed;\n\n\t\t    fp->uf_flags |= FC_DEAD;\n\n\t\t    if (fp->uf_calls > 0)\n\t\t    {\n\t\t\t// Function is executing, don't free it but do remove\n\t\t\t// it from the hashtable.\n\t\t\tif (func_remove(fp))\n\t\t\t    fp->uf_refcount--;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tfunc_clear(fp, TRUE);\n\t\t\t// When clearing a function another function can be\n\t\t\t// cleared as a side effect.  When that happens start\n\t\t\t// over.\n\t\t\tif (changed != func_hashtab.ht_changed)\n\t\t\t    break;\n\t\t    }\n\t\t}\n\t\t--todo;\n\t    }\n    }\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nfree_all_functions(void)\n{\n    hashitem_T\t*hi;\n    ufunc_T\t*fp;\n    long_u\tskipped = 0;\n    long_u\ttodo = 1;\n    int\t\tchanged;\n\n    // Clean up the current_funccal chain and the funccal stack.\n    while (current_funccal != NULL)\n    {\n\tclear_tv(current_funccal->rettv);\n\tcleanup_function_call(current_funccal);\n\tif (current_funccal == NULL && funccal_stack != NULL)\n\t    restore_funccal();\n    }\n\n    // First clear what the functions contain.  Since this may lower the\n    // reference count of a function, it may also free a function and change\n    // the hash table. Restart if that happens.\n    while (todo > 0)\n    {\n\ttodo = func_hashtab.ht_used;\n\tfor (hi = func_hashtab.ht_array; todo > 0; ++hi)\n\t    if (!HASHITEM_EMPTY(hi))\n\t    {\n\t\t// clear the def function index now\n\t\tfp = HI2UF(hi);\n\t\tfp->uf_flags &= ~FC_DEAD;\n\t\tfp->uf_def_status = UF_NOT_COMPILED;\n\n\t\t// Only free functions that are not refcounted, those are\n\t\t// supposed to be freed when no longer referenced.\n\t\tif (func_name_refcount(fp->uf_name))\n\t\t    ++skipped;\n\t\telse\n\t\t{\n\t\t    changed = func_hashtab.ht_changed;\n\t\t    func_clear(fp, TRUE);\n\t\t    if (changed != func_hashtab.ht_changed)\n\t\t    {\n\t\t\tskipped = 0;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\t--todo;\n\t    }\n    }\n\n    // Now actually free the functions.  Need to start all over every time,\n    // because func_free() may change the hash table.\n    skipped = 0;\n    while (func_hashtab.ht_used > skipped)\n    {\n\ttodo = func_hashtab.ht_used;\n\tfor (hi = func_hashtab.ht_array; todo > 0; ++hi)\n\t    if (!HASHITEM_EMPTY(hi))\n\t    {\n\t\t--todo;\n\t\t// Only free functions that are not refcounted, those are\n\t\t// supposed to be freed when no longer referenced.\n\t\tfp = HI2UF(hi);\n\t\tif (func_name_refcount(fp->uf_name))\n\t\t    ++skipped;\n\t\telse\n\t\t{\n\t\t    if (func_free(fp, FALSE) == OK)\n\t\t    {\n\t\t\tskipped = 0;\n\t\t\tbreak;\n\t\t    }\n\t\t    // did not actually free it\n\t\t    ++skipped;\n\t\t}\n\t    }\n    }\n    if (skipped == 0)\n\thash_clear(&func_hashtab);\n\n    free_def_functions();\n}\n#endif\n\n/*\n * Return TRUE if \"name\" looks like a builtin function name: starts with a\n * lower case letter and doesn't contain AUTOLOAD_CHAR or ':'.\n * \"len\" is the length of \"name\", or -1 for NUL terminated.\n */\n    int\nbuiltin_function(char_u *name, int len)\n{\n    char_u *p;\n\n    if (!ASCII_ISLOWER(name[0]) || name[1] == ':')\n\treturn FALSE;\n    p = vim_strchr(name, AUTOLOAD_CHAR);\n    return p == NULL || (len > 0 && p > name + len);\n}\n\n    int\nfunc_call(\n    char_u\t*name,\n    typval_T\t*args,\n    partial_T\t*partial,\n    dict_T\t*selfdict,\n    typval_T\t*rettv)\n{\n    list_T\t*l = args->vval.v_list;\n    listitem_T\t*item;\n    typval_T\targv[MAX_FUNC_ARGS + 1];\n    int\t\targc = 0;\n    int\t\tr = 0;\n\n    CHECK_LIST_MATERIALIZE(l);\n    FOR_ALL_LIST_ITEMS(l, item)\n    {\n\tif (argc == MAX_FUNC_ARGS - (partial == NULL ? 0 : partial->pt_argc))\n\t{\n\t    emsg(_(\"E699: Too many arguments\"));\n\t    break;\n\t}\n\t// Make a copy of each argument.  This is needed to be able to set\n\t// v_lock to VAR_FIXED in the copy without changing the original list.\n\tcopy_tv(&item->li_tv, &argv[argc++]);\n    }\n\n    if (item == NULL)\n    {\n\tfuncexe_T funcexe;\n\n\tCLEAR_FIELD(funcexe);\n\tfuncexe.fe_firstline = curwin->w_cursor.lnum;\n\tfuncexe.fe_lastline = curwin->w_cursor.lnum;\n\tfuncexe.fe_evaluate = TRUE;\n\tfuncexe.fe_partial = partial;\n\tfuncexe.fe_selfdict = selfdict;\n\tr = call_func(name, -1, rettv, argc, argv, &funcexe);\n    }\n\n    // Free the arguments.\n    while (argc > 0)\n\tclear_tv(&argv[--argc]);\n\n    return r;\n}\n\nstatic int callback_depth = 0;\n\n    int\nget_callback_depth(void)\n{\n    return callback_depth;\n}\n\n/*\n * Invoke call_func() with a callback.\n * Returns FAIL if the callback could not be called.\n */\n    int\ncall_callback(\n    callback_T\t*callback,\n    int\t\tlen,\t\t// length of \"name\" or -1 to use strlen()\n    typval_T\t*rettv,\t\t// return value goes here\n    int\t\targcount,\t// number of \"argvars\"\n    typval_T\t*argvars)\t// vars for arguments, must have \"argcount\"\n\t\t\t\t// PLUS ONE elements!\n{\n    funcexe_T\tfuncexe;\n    int\t\tret;\n\n    if (callback->cb_name == NULL || *callback->cb_name == NUL)\n\treturn FAIL;\n    CLEAR_FIELD(funcexe);\n    funcexe.fe_evaluate = TRUE;\n    funcexe.fe_partial = callback->cb_partial;\n    ++callback_depth;\n    ret = call_func(callback->cb_name, len, rettv, argcount, argvars, &funcexe);\n    --callback_depth;\n\n    // When a :def function was called that uses :try an error would be turned\n    // into an exception.  Need to give the error here.\n    if (need_rethrow && current_exception != NULL && trylevel == 0)\n    {\n\tneed_rethrow = FALSE;\n\thandle_did_throw();\n    }\n\n    return ret;\n}\n\n/*\n * call the 'callback' function and return the result as a number.\n * Returns -2 when calling the function fails.  Uses argv[0] to argv[argc - 1]\n * for the function arguments. argv[argc] should have type VAR_UNKNOWN.\n */\n    varnumber_T\ncall_callback_retnr(\n    callback_T\t*callback,\n    int\t\targcount,\t// number of \"argvars\"\n    typval_T\t*argvars)\t// vars for arguments, must have \"argcount\"\n\t\t\t\t// PLUS ONE elements!\n{\n    typval_T\trettv;\n    varnumber_T\tretval;\n\n    if (call_callback(callback, 0, &rettv, argcount, argvars) == FAIL)\n\treturn -2;\n\n    retval = tv_get_number_chk(&rettv, NULL);\n    clear_tv(&rettv);\n    return retval;\n}\n\n/*\n * Give an error message for the result of a function.\n * Nothing if \"error\" is FCERR_NONE.\n */\n    void\nuser_func_error(int error, char_u *name, funcexe_T *funcexe)\n{\n    switch (error)\n    {\n\tcase FCERR_UNKNOWN:\n\t\tif (funcexe->fe_found_var)\n\t\t    semsg(_(e_not_callable_type_str), name);\n\t\telse\n\t\t    emsg_funcname(e_unknown_function_str, name);\n\t\tbreak;\n\tcase FCERR_NOTMETHOD:\n\t\temsg_funcname(\n\t\t\tN_(\"E276: Cannot use function as a method: %s\"), name);\n\t\tbreak;\n\tcase FCERR_DELETED:\n\t\temsg_funcname(N_(e_func_deleted), name);\n\t\tbreak;\n\tcase FCERR_TOOMANY:\n\t\temsg_funcname((char *)e_too_many_arguments_for_function_str,\n\t\t\t\t\t\t\t\t\t name);\n\t\tbreak;\n\tcase FCERR_TOOFEW:\n\t\temsg_funcname((char *)e_not_enough_arguments_for_function_str,\n\t\t\t\t\t\t\t\t\t name);\n\t\tbreak;\n\tcase FCERR_SCRIPT:\n\t\temsg_funcname(\n\t\t    N_(e_using_sid_not_in_script_context_str), name);\n\t\tbreak;\n\tcase FCERR_DICT:\n\t\temsg_funcname(\n\t\t      N_(\"E725: Calling dict function without Dictionary: %s\"),\n\t\t\tname);\n\t\tbreak;\n    }\n}\n\n/*\n * Call a function with its resolved parameters\n *\n * Return FAIL when the function can't be called,  OK otherwise.\n * Also returns OK when an error was encountered while executing the function.\n */\n    int\ncall_func(\n    char_u\t*funcname,\t// name of the function\n    int\t\tlen,\t\t// length of \"name\" or -1 to use strlen()\n    typval_T\t*rettv,\t\t// return value goes here\n    int\t\targcount_in,\t// number of \"argvars\"\n    typval_T\t*argvars_in,\t// vars for arguments, must have \"argcount\"\n\t\t\t\t// PLUS ONE elements!\n    funcexe_T\t*funcexe)\t// more arguments\n{\n    int\t\tret = FAIL;\n    int\t\terror = FCERR_NONE;\n    int\t\ti;\n    ufunc_T\t*fp = NULL;\n    char_u\tfname_buf[FLEN_FIXED + 1];\n    char_u\t*tofree = NULL;\n    char_u\t*fname = NULL;\n    char_u\t*name = NULL;\n    int\t\targcount = argcount_in;\n    typval_T\t*argvars = argvars_in;\n    dict_T\t*selfdict = funcexe->fe_selfdict;\n    typval_T\targv[MAX_FUNC_ARGS + 1]; // used when \"partial\" or\n\t\t\t\t\t // \"funcexe->fe_basetv\" is not NULL\n    int\t\targv_clear = 0;\n    int\t\targv_base = 0;\n    partial_T\t*partial = funcexe->fe_partial;\n    type_T\tcheck_type;\n\n    // Initialize rettv so that it is safe for caller to invoke clear_tv(rettv)\n    // even when call_func() returns FAIL.\n    rettv->v_type = VAR_UNKNOWN;\n\n    if (partial != NULL)\n\tfp = partial->pt_func;\n    if (fp == NULL)\n    {\n\t// Make a copy of the name, if it comes from a funcref variable it\n\t// could be changed or deleted in the called function.\n\tname = len > 0 ? vim_strnsave(funcname, len) : vim_strsave(funcname);\n\tif (name == NULL)\n\t    return ret;\n\n\tfname = fname_trans_sid(name, fname_buf, &tofree, &error);\n    }\n\n    if (funcexe->fe_doesrange != NULL)\n\t*funcexe->fe_doesrange = FALSE;\n\n    if (partial != NULL)\n    {\n\t// When the function has a partial with a dict and there is a dict\n\t// argument, use the dict argument.  That is backwards compatible.\n\t// When the dict was bound explicitly use the one from the partial.\n\tif (partial->pt_dict != NULL && (selfdict == NULL || !partial->pt_auto))\n\t    selfdict = partial->pt_dict;\n\tif (error == FCERR_NONE && partial->pt_argc > 0)\n\t{\n\t    for (argv_clear = 0; argv_clear < partial->pt_argc; ++argv_clear)\n\t    {\n\t\tif (argv_clear + argcount_in >= MAX_FUNC_ARGS)\n\t\t{\n\t\t    error = FCERR_TOOMANY;\n\t\t    goto theend;\n\t\t}\n\t\tcopy_tv(&partial->pt_argv[argv_clear], &argv[argv_clear]);\n\t    }\n\t    for (i = 0; i < argcount_in; ++i)\n\t\targv[i + argv_clear] = argvars_in[i];\n\t    argvars = argv;\n\t    argcount = partial->pt_argc + argcount_in;\n\n\t    if (funcexe->fe_check_type != NULL\n\t\t\t\t  && funcexe->fe_check_type->tt_argcount != -1)\n\t    {\n\t\t// Now funcexe->fe_check_type is missing the added arguments,\n\t\t// make a copy of the type with the correction.\n\t\tcheck_type = *funcexe->fe_check_type;\n\t\tfuncexe->fe_check_type = &check_type;\n\t\tcheck_type.tt_argcount += partial->pt_argc;\n\t\tcheck_type.tt_min_argcount += partial->pt_argc;\n\t    }\n\t}\n    }\n\n    if (error == FCERR_NONE && funcexe->fe_check_type != NULL\n\t\t\t\t\t\t       && funcexe->fe_evaluate)\n    {\n\t// Check that the argument types are OK for the types of the funcref.\n\tif (check_argument_types(funcexe->fe_check_type, argvars, argcount,\n\t\t\t\t     (name != NULL) ? name : funcname) == FAIL)\n\t    error = FCERR_OTHER;\n    }\n\n    if (error == FCERR_NONE && funcexe->fe_evaluate)\n    {\n\tchar_u *rfname = fname;\n\tint\tis_global = FALSE;\n\n\t// Skip \"g:\" before a function name.\n\tif (fp == NULL && fname[0] == 'g' && fname[1] == ':')\n\t{\n\t    is_global = TRUE;\n\t    rfname = fname + 2;\n\t}\n\n\trettv->v_type = VAR_NUMBER;\t// default rettv is number zero\n\trettv->vval.v_number = 0;\n\terror = FCERR_UNKNOWN;\n\n\tif (fp != NULL || !builtin_function(rfname, -1))\n\t{\n\t    /*\n\t     * User defined function.\n\t     */\n\t    if (fp == NULL)\n\t\tfp = find_func(rfname, is_global, NULL);\n\n\t    // Trigger FuncUndefined event, may load the function.\n\t    if (fp == NULL\n\t\t    && apply_autocmds(EVENT_FUNCUNDEFINED,\n\t\t\t\t\t\t    rfname, rfname, TRUE, NULL)\n\t\t    && !aborting())\n\t    {\n\t\t// executed an autocommand, search for the function again\n\t\tfp = find_func(rfname, is_global, NULL);\n\t    }\n\t    // Try loading a package.\n\t    if (fp == NULL && script_autoload(rfname, TRUE) && !aborting())\n\t    {\n\t\t// loaded a package, search for the function again\n\t\tfp = find_func(rfname, is_global, NULL);\n\t    }\n\t    if (fp == NULL)\n\t    {\n\t\tchar_u *p = untrans_function_name(rfname);\n\n\t\t// If using Vim9 script try not local to the script.\n\t\t// Don't do this if the name starts with \"s:\".\n\t\tif (p != NULL && (funcname[0] != 's' || funcname[1] != ':'))\n\t\t    fp = find_func(p, is_global, NULL);\n\t    }\n\n\t    if (fp != NULL && (fp->uf_flags & FC_DELETED))\n\t\terror = FCERR_DELETED;\n#ifdef FEAT_LUA\n\t    else if (fp != NULL && (fp->uf_flags & FC_CFUNC))\n\t    {\n\t\tcfunc_T cb = fp->uf_cb;\n\n\t\terror = (*cb)(argcount, argvars, rettv, fp->uf_cb_state);\n\t    }\n#endif\n\t    else if (fp != NULL)\n\t    {\n\t\tif (funcexe->fe_argv_func != NULL)\n\t\t    // postponed filling in the arguments, do it now\n\t\t    argcount = funcexe->fe_argv_func(argcount, argvars,\n\t\t\t\t\t       argv_clear, fp->uf_args.ga_len);\n\n\t\tif (funcexe->fe_basetv != NULL)\n\t\t{\n\t\t    // Method call: base->Method()\n\t\t    mch_memmove(&argv[1], argvars, sizeof(typval_T) * argcount);\n\t\t    argv[0] = *funcexe->fe_basetv;\n\t\t    argcount++;\n\t\t    argvars = argv;\n\t\t    argv_base = 1;\n\t\t}\n\n\t\terror = call_user_func_check(fp, argcount, argvars, rettv,\n\t\t\t\t\t\t\t    funcexe, selfdict);\n\t    }\n\t}\n\telse if (funcexe->fe_basetv != NULL)\n\t{\n\t    /*\n\t     * expr->method(): Find the method name in the table, call its\n\t     * implementation with the base as one of the arguments.\n\t     */\n\t    error = call_internal_method(fname, argcount, argvars, rettv,\n\t\t\t\t\t\t\t   funcexe->fe_basetv);\n\t}\n\telse\n\t{\n\t    /*\n\t     * Find the function name in the table, call its implementation.\n\t     */\n\t    error = call_internal_func(fname, argcount, argvars, rettv);\n\t}\n\n\t/*\n\t * The function call (or \"FuncUndefined\" autocommand sequence) might\n\t * have been aborted by an error, an interrupt, or an explicitly thrown\n\t * exception that has not been caught so far.  This situation can be\n\t * tested for by calling aborting().  For an error in an internal\n\t * function or for the \"E132\" error in call_user_func(), however, the\n\t * throw point at which the \"force_abort\" flag (temporarily reset by\n\t * emsg()) is normally updated has not been reached yet. We need to\n\t * update that flag first to make aborting() reliable.\n\t */\n\tupdate_force_abort();\n    }\n    if (error == FCERR_NONE)\n\tret = OK;\n\ntheend:\n    /*\n     * Report an error unless the argument evaluation or function call has been\n     * cancelled due to an aborting error, an interrupt, or an exception.\n     */\n    if (!aborting())\n    {\n\tuser_func_error(error, (name != NULL) ? name : funcname, funcexe);\n    }\n\n    // clear the copies made from the partial\n    while (argv_clear > 0)\n\tclear_tv(&argv[--argv_clear + argv_base]);\n\n    vim_free(tofree);\n    vim_free(name);\n\n    return ret;\n}\n\n    char_u *\nprintable_func_name(ufunc_T *fp)\n{\n    return fp->uf_name_exp != NULL ? fp->uf_name_exp : fp->uf_name;\n}\n\n/*\n * List the head of the function: \"function name(arg1, arg2)\".\n */\n    static void\nlist_func_head(ufunc_T *fp, int indent)\n{\n    int\t\tj;\n\n    msg_start();\n    if (indent)\n\tmsg_puts(\"   \");\n    if (fp->uf_def_status != UF_NOT_COMPILED)\n\tmsg_puts(\"def \");\n    else\n\tmsg_puts(\"function \");\n    msg_puts((char *)printable_func_name(fp));\n    msg_putchar('(');\n    for (j = 0; j < fp->uf_args.ga_len; ++j)\n    {\n\tif (j)\n\t    msg_puts(\", \");\n\tmsg_puts((char *)FUNCARG(fp, j));\n\tif (fp->uf_arg_types != NULL)\n\t{\n\t    char *tofree;\n\n\t    msg_puts(\": \");\n\t    msg_puts(type_name(fp->uf_arg_types[j], &tofree));\n\t    vim_free(tofree);\n\t}\n\tif (j >= fp->uf_args.ga_len - fp->uf_def_args.ga_len)\n\t{\n\t    msg_puts(\" = \");\n\t    msg_puts(((char **)(fp->uf_def_args.ga_data))\n\t\t       [j - fp->uf_args.ga_len + fp->uf_def_args.ga_len]);\n\t}\n    }\n    if (fp->uf_varargs)\n    {\n\tif (j)\n\t    msg_puts(\", \");\n\tmsg_puts(\"...\");\n    }\n    if (fp->uf_va_name != NULL)\n    {\n\tif (j)\n\t    msg_puts(\", \");\n\tmsg_puts(\"...\");\n\tmsg_puts((char *)fp->uf_va_name);\n\tif (fp->uf_va_type != NULL)\n\t{\n\t    char *tofree;\n\n\t    msg_puts(\": \");\n\t    msg_puts(type_name(fp->uf_va_type, &tofree));\n\t    vim_free(tofree);\n\t}\n    }\n    msg_putchar(')');\n\n    if (fp->uf_def_status != UF_NOT_COMPILED)\n    {\n\tif (fp->uf_ret_type != &t_void)\n\t{\n\t    char *tofree;\n\n\t    msg_puts(\": \");\n\t    msg_puts(type_name(fp->uf_ret_type, &tofree));\n\t    vim_free(tofree);\n\t}\n    }\n    else if (fp->uf_flags & FC_ABORT)\n\tmsg_puts(\" abort\");\n    if (fp->uf_flags & FC_RANGE)\n\tmsg_puts(\" range\");\n    if (fp->uf_flags & FC_DICT)\n\tmsg_puts(\" dict\");\n    if (fp->uf_flags & FC_CLOSURE)\n\tmsg_puts(\" closure\");\n    msg_clr_eos();\n    if (p_verbose > 0)\n\tlast_set_msg(fp->uf_script_ctx);\n}\n\n/*\n * Get a function name, translating \"<SID>\" and \"<SNR>\".\n * Also handles a Funcref in a List or Dictionary.\n * Returns the function name in allocated memory, or NULL for failure.\n * Set \"*is_global\" to TRUE when the function must be global, unless\n * \"is_global\" is NULL.\n * flags:\n * TFN_INT:\t    internal function name OK\n * TFN_QUIET:\t    be quiet\n * TFN_NO_AUTOLOAD: do not use script autoloading\n * TFN_NO_DEREF:    do not dereference a Funcref\n * Advances \"pp\" to just after the function name (if no error).\n */\n    char_u *\ntrans_function_name(\n    char_u\t**pp,\n    int\t\t*is_global,\n    int\t\tskip,\t\t// only find the end, don't evaluate\n    int\t\tflags,\n    funcdict_T\t*fdp,\t\t// return: info about dictionary used\n    partial_T\t**partial,\t// return: partial of a FuncRef\n    type_T\t**type)\t\t// return: type of funcref if not NULL\n{\n    char_u\t*name = NULL;\n    char_u\t*start;\n    char_u\t*end;\n    int\t\tlead;\n    char_u\tsid_buf[20];\n    int\t\tlen;\n    int\t\textra = 0;\n    lval_T\tlv;\n    int\t\tvim9script;\n    static char *e_function_name = N_(\"E129: Function name required\");\n\n    if (fdp != NULL)\n\tCLEAR_POINTER(fdp);\n    start = *pp;\n\n    // Check for hard coded <SNR>: already translated function ID (from a user\n    // command).\n    if ((*pp)[0] == K_SPECIAL && (*pp)[1] == KS_EXTRA\n\t\t\t\t\t\t   && (*pp)[2] == (int)KE_SNR)\n    {\n\t*pp += 3;\n\tlen = get_id_len(pp) + 3;\n\treturn vim_strnsave(start, len);\n    }\n\n    // A name starting with \"<SID>\" or \"<SNR>\" is local to a script.  But\n    // don't skip over \"s:\", get_lval() needs it for \"s:dict.func\".\n    lead = eval_fname_script(start);\n    if (lead > 2)\n\tstart += lead;\n\n    // Note that TFN_ flags use the same values as GLV_ flags.\n    end = get_lval(start, NULL, &lv, FALSE, skip, flags | GLV_READ_ONLY,\n\t\t\t\t\t      lead > 2 ? 0 : FNE_CHECK_START);\n    if (end == start)\n    {\n\tif (!skip)\n\t    emsg(_(e_function_name));\n\tgoto theend;\n    }\n    if (end == NULL || (lv.ll_tv != NULL && (lead > 2 || lv.ll_range)))\n    {\n\t/*\n\t * Report an invalid expression in braces, unless the expression\n\t * evaluation has been cancelled due to an aborting error, an\n\t * interrupt, or an exception.\n\t */\n\tif (!aborting())\n\t{\n\t    if (end != NULL)\n\t\tsemsg(_(e_invarg2), start);\n\t}\n\telse\n\t    *pp = find_name_end(start, NULL, NULL, FNE_INCL_BR);\n\tgoto theend;\n    }\n\n    if (lv.ll_tv != NULL)\n    {\n\tif (fdp != NULL)\n\t{\n\t    fdp->fd_dict = lv.ll_dict;\n\t    fdp->fd_newkey = lv.ll_newkey;\n\t    lv.ll_newkey = NULL;\n\t    fdp->fd_di = lv.ll_di;\n\t}\n\tif (lv.ll_tv->v_type == VAR_FUNC && lv.ll_tv->vval.v_string != NULL)\n\t{\n\t    name = vim_strsave(lv.ll_tv->vval.v_string);\n\t    *pp = end;\n\t}\n\telse if (lv.ll_tv->v_type == VAR_PARTIAL\n\t\t\t\t\t  && lv.ll_tv->vval.v_partial != NULL)\n\t{\n\t    name = vim_strsave(partial_name(lv.ll_tv->vval.v_partial));\n\t    *pp = end;\n\t    if (partial != NULL)\n\t\t*partial = lv.ll_tv->vval.v_partial;\n\t}\n\telse\n\t{\n\t    if (!skip && !(flags & TFN_QUIET) && (fdp == NULL\n\t\t\t     || lv.ll_dict == NULL || fdp->fd_newkey == NULL))\n\t\temsg(_(e_funcref));\n\t    else\n\t\t*pp = end;\n\t    name = NULL;\n\t}\n\tgoto theend;\n    }\n\n    if (lv.ll_name == NULL)\n    {\n\t// Error found, but continue after the function name.\n\t*pp = end;\n\tgoto theend;\n    }\n\n    // Check if the name is a Funcref.  If so, use the value.\n    if (lv.ll_exp_name != NULL)\n    {\n\tlen = (int)STRLEN(lv.ll_exp_name);\n\tname = deref_func_name(lv.ll_exp_name, &len, partial, type,\n\t\t\t\t\t\tflags & TFN_NO_AUTOLOAD, NULL);\n\tif (name == lv.ll_exp_name)\n\t    name = NULL;\n    }\n    else if (!(flags & TFN_NO_DEREF))\n    {\n\tlen = (int)(end - *pp);\n\tname = deref_func_name(*pp, &len, partial, type,\n\t\t\t\t\t\tflags & TFN_NO_AUTOLOAD, NULL);\n\tif (name == *pp)\n\t    name = NULL;\n    }\n    if (name != NULL)\n    {\n\tname = vim_strsave(name);\n\t*pp = end;\n\tif (STRNCMP(name, \"<SNR>\", 5) == 0)\n\t{\n\t    // Change \"<SNR>\" to the byte sequence.\n\t    name[0] = K_SPECIAL;\n\t    name[1] = KS_EXTRA;\n\t    name[2] = (int)KE_SNR;\n\t    mch_memmove(name + 3, name + 5, STRLEN(name + 5) + 1);\n\t}\n\tgoto theend;\n    }\n\n    if (lv.ll_exp_name != NULL)\n    {\n\tlen = (int)STRLEN(lv.ll_exp_name);\n\tif (lead <= 2 && lv.ll_name == lv.ll_exp_name\n\t\t\t\t\t && STRNCMP(lv.ll_name, \"s:\", 2) == 0)\n\t{\n\t    // When there was \"s:\" already or the name expanded to get a\n\t    // leading \"s:\" then remove it.\n\t    lv.ll_name += 2;\n\t    len -= 2;\n\t    lead = 2;\n\t}\n    }\n    else\n    {\n\t// skip over \"s:\" and \"g:\"\n\tif (lead == 2 || (lv.ll_name[0] == 'g' && lv.ll_name[1] == ':'))\n\t{\n\t    if (is_global != NULL && lv.ll_name[0] == 'g')\n\t\t*is_global = TRUE;\n\t    lv.ll_name += 2;\n\t}\n\tlen = (int)(end - lv.ll_name);\n    }\n    if (len <= 0)\n    {\n\tif (!skip)\n\t    emsg(_(e_function_name));\n\tgoto theend;\n    }\n\n    // In Vim9 script a user function is script-local by default, unless it\n    // starts with a lower case character: dict.func().\n    vim9script = ASCII_ISUPPER(*start) && in_vim9script();\n    if (vim9script)\n    {\n\tchar_u *p;\n\n\t// SomeScript#func() is a global function.\n\tfor (p = start; *p != NUL && *p != '('; ++p)\n\t    if (*p == AUTOLOAD_CHAR)\n\t\tvim9script = FALSE;\n    }\n\n    /*\n     * Copy the function name to allocated memory.\n     * Accept <SID>name() inside a script, translate into <SNR>123_name().\n     * Accept <SNR>123_name() outside a script.\n     */\n    if (skip)\n\tlead = 0;\t// do nothing\n    else if (lead > 0 || vim9script)\n    {\n\tif (!vim9script)\n\t    lead = 3;\n\tif (vim9script || (lv.ll_exp_name != NULL\n\t\t\t\t\t     && eval_fname_sid(lv.ll_exp_name))\n\t\t\t\t\t\t       || eval_fname_sid(*pp))\n\t{\n\t    // It's script-local, \"s:\" or \"<SID>\"\n\t    if (current_sctx.sc_sid <= 0)\n\t    {\n\t\temsg(_(e_using_sid_not_in_script_context));\n\t\tgoto theend;\n\t    }\n\t    sprintf((char *)sid_buf, \"%ld_\", (long)current_sctx.sc_sid);\n\t    if (vim9script)\n\t\textra = 3 + (int)STRLEN(sid_buf);\n\t    else\n\t\tlead += (int)STRLEN(sid_buf);\n\t}\n    }\n    else if (!(flags & TFN_INT) && (builtin_function(lv.ll_name, len)\n\t\t\t\t   || (in_vim9script() && *lv.ll_name == '_')))\n    {\n\tsemsg(_(\"E128: Function name must start with a capital or \\\"s:\\\": %s\"),\n\t\t\t\t\t\t\t\t       start);\n\tgoto theend;\n    }\n    if (!skip && !(flags & TFN_QUIET) && !(flags & TFN_NO_DEREF))\n    {\n\tchar_u *cp = vim_strchr(lv.ll_name, ':');\n\n\tif (cp != NULL && cp < end)\n\t{\n\t    semsg(_(\"E884: Function name cannot contain a colon: %s\"), start);\n\t    goto theend;\n\t}\n    }\n\n    name = alloc(len + lead + extra + 1);\n    if (name != NULL)\n    {\n\tif (!skip && (lead > 0 || vim9script))\n\t{\n\t    name[0] = K_SPECIAL;\n\t    name[1] = KS_EXTRA;\n\t    name[2] = (int)KE_SNR;\n\t    if (vim9script || lead > 3)\t// If it's \"<SID>\"\n\t\tSTRCPY(name + 3, sid_buf);\n\t}\n\tmch_memmove(name + lead + extra, lv.ll_name, (size_t)len);\n\tname[lead + extra + len] = NUL;\n    }\n    *pp = end;\n\ntheend:\n    clear_lval(&lv);\n    return name;\n}\n\n/*\n * Assuming \"name\" is the result of trans_function_name() and it was prefixed\n * to use the script-local name, return the unmodified name (points into\n * \"name\").  Otherwise return NULL.\n * This can be used to first search for a script-local function and fall back\n * to the global function if not found.\n */\n    char_u *\nuntrans_function_name(char_u *name)\n{\n    char_u *p;\n\n    if (*name == K_SPECIAL && in_vim9script())\n    {\n\tp = vim_strchr(name, '_');\n\tif (p != NULL)\n\t    return p + 1;\n    }\n    return NULL;\n}\n\n/*\n * If the 'funcname' starts with \"s:\" or \"<SID>\", then expands it to the\n * current script ID and returns the expanded function name. The caller should\n * free the returned name. If not called from a script context or the function\n * name doesn't start with these prefixes, then returns NULL.\n * This doesn't check whether the script-local function exists or not.\n */\n    char_u *\nget_scriptlocal_funcname(char_u *funcname)\n{\n    char\tsid_buf[25];\n    int\t\toff;\n    char_u\t*newname;\n\n    if (funcname == NULL)\n\treturn NULL;\n\n    if (STRNCMP(funcname, \"s:\", 2) != 0\n\t\t&& STRNCMP(funcname, \"<SID>\", 5) != 0)\n\t// The function name is not a script-local function name\n\treturn NULL;\n\n    if (!SCRIPT_ID_VALID(current_sctx.sc_sid))\n    {\n\temsg(_(e_using_sid_not_in_script_context));\n\treturn NULL;\n    }\n    // Expand s: prefix into <SNR>nr_<name>\n    vim_snprintf(sid_buf, sizeof(sid_buf), \"<SNR>%ld_\",\n\t    (long)current_sctx.sc_sid);\n    off = *funcname == 's' ? 2 : 5;\n    newname = alloc(STRLEN(sid_buf) + STRLEN(funcname + off) + 1);\n    if (newname == NULL)\n\treturn NULL;\n    STRCPY(newname, sid_buf);\n    STRCAT(newname, funcname + off);\n\n    return newname;\n}\n\n/*\n * Call trans_function_name(), except that a lambda is returned as-is.\n * Returns the name in allocated memory.\n */\n    char_u *\nsave_function_name(\n\tchar_u\t    **name,\n\tint\t    *is_global,\n\tint\t    skip,\n\tint\t    flags,\n\tfuncdict_T  *fudi)\n{\n    char_u *p = *name;\n    char_u *saved;\n\n    if (STRNCMP(p, \"<lambda>\", 8) == 0)\n    {\n\tp += 8;\n\t(void)getdigits(&p);\n\tsaved = vim_strnsave(*name, p - *name);\n\tif (fudi != NULL)\n\t    CLEAR_POINTER(fudi);\n    }\n    else\n\tsaved = trans_function_name(&p, is_global, skip,\n\t\t\t\t\t\t      flags, fudi, NULL, NULL);\n    *name = p;\n    return saved;\n}\n\n/*\n * List functions.  When \"regmatch\" is NULL all of then.\n * Otherwise functions matching \"regmatch\".\n */\n    void\nlist_functions(regmatch_T *regmatch)\n{\n    int\t\tchanged = func_hashtab.ht_changed;\n    long_u\ttodo = func_hashtab.ht_used;\n    hashitem_T\t*hi;\n\n    for (hi = func_hashtab.ht_array; todo > 0 && !got_int; ++hi)\n    {\n\tif (!HASHITEM_EMPTY(hi))\n\t{\n\t    ufunc_T\t*fp = HI2UF(hi);\n\n\t    --todo;\n\t    if ((fp->uf_flags & FC_DEAD) == 0\n\t\t    && (regmatch == NULL\n\t\t\t? !message_filtered(fp->uf_name)\n\t\t\t    && !func_name_refcount(fp->uf_name)\n\t\t\t: !isdigit(*fp->uf_name)\n\t\t\t    && vim_regexec(regmatch, fp->uf_name, 0)))\n\t    {\n\t\tlist_func_head(fp, FALSE);\n\t\tif (changed != func_hashtab.ht_changed)\n\t\t{\n\t\t    emsg(_(\"E454: function list was modified\"));\n\t\t    return;\n\t\t}\n\t    }\n\t}\n    }\n}\n\n/*\n * \":function\" also supporting nested \":def\".\n * When \"name_arg\" is not NULL this is a nested function, using \"name_arg\" for\n * the function name.\n * Returns a pointer to the function or NULL if no function defined.\n */\n    ufunc_T *\ndefine_function(exarg_T *eap, char_u *name_arg, char_u **line_to_free)\n{\n    int\t\tj;\n    int\t\tc;\n    int\t\tsaved_did_emsg;\n    char_u\t*name = name_arg;\n    int\t\tis_global = FALSE;\n    char_u\t*p;\n    char_u\t*arg;\n    char_u\t*whitep;\n    char_u\t*line_arg = NULL;\n    garray_T\tnewargs;\n    garray_T\targtypes;\n    garray_T\tdefault_args;\n    garray_T\tnewlines;\n    int\t\tvarargs = FALSE;\n    int\t\tflags = 0;\n    char_u\t*ret_type = NULL;\n    ufunc_T\t*fp = NULL;\n    int\t\tfp_allocated = FALSE;\n    int\t\tfree_fp = FALSE;\n    int\t\toverwrite = FALSE;\n    dictitem_T\t*v;\n    funcdict_T\tfudi;\n    static int\tfunc_nr = 0;\t    // number for nameless function\n    int\t\tparen;\n    hashitem_T\t*hi;\n    linenr_T\tsourcing_lnum_top;\n    int\t\tvim9script = in_vim9script();\n    imported_T\t*import = NULL;\n\n    /*\n     * \":function\" without argument: list functions.\n     */\n    if (ends_excmd2(eap->cmd, eap->arg))\n    {\n\tif (!eap->skip)\n\t    list_functions(NULL);\n\tset_nextcmd(eap, eap->arg);\n\treturn NULL;\n    }\n\n    /*\n     * \":function /pat\": list functions matching pattern.\n     */\n    if (*eap->arg == '/')\n    {\n\tp = skip_regexp(eap->arg + 1, '/', TRUE);\n\tif (!eap->skip)\n\t{\n\t    regmatch_T\tregmatch;\n\n\t    c = *p;\n\t    *p = NUL;\n\t    regmatch.regprog = vim_regcomp(eap->arg + 1, RE_MAGIC);\n\t    *p = c;\n\t    if (regmatch.regprog != NULL)\n\t    {\n\t\tregmatch.rm_ic = p_ic;\n\t\tlist_functions(&regmatch);\n\t\tvim_regfree(regmatch.regprog);\n\t    }\n\t}\n\tif (*p == '/')\n\t    ++p;\n\tset_nextcmd(eap, p);\n\treturn NULL;\n    }\n\n    ga_init(&newargs);\n    ga_init(&argtypes);\n    ga_init(&default_args);\n\n    /*\n     * Get the function name.  There are these situations:\n     * func\t    normal function name\n     *\t\t    \"name\" == func, \"fudi.fd_dict\" == NULL\n     * dict.func    new dictionary entry\n     *\t\t    \"name\" == NULL, \"fudi.fd_dict\" set,\n     *\t\t    \"fudi.fd_di\" == NULL, \"fudi.fd_newkey\" == func\n     * dict.func    existing dict entry with a Funcref\n     *\t\t    \"name\" == func, \"fudi.fd_dict\" set,\n     *\t\t    \"fudi.fd_di\" set, \"fudi.fd_newkey\" == NULL\n     * dict.func    existing dict entry that's not a Funcref\n     *\t\t    \"name\" == NULL, \"fudi.fd_dict\" set,\n     *\t\t    \"fudi.fd_di\" set, \"fudi.fd_newkey\" == NULL\n     * s:func\t    script-local function name\n     * g:func\t    global function name, same as \"func\"\n     */\n    p = eap->arg;\n    if (name_arg != NULL)\n    {\n\t// nested function, argument is (args).\n\tparen = TRUE;\n\tCLEAR_FIELD(fudi);\n    }\n    else\n    {\n\tname = save_function_name(&p, &is_global, eap->skip,\n\t\t\t\t\t\t       TFN_NO_AUTOLOAD, &fudi);\n\tparen = (vim_strchr(p, '(') != NULL);\n\tif (name == NULL && (fudi.fd_dict == NULL || !paren) && !eap->skip)\n\t{\n\t    /*\n\t     * Return on an invalid expression in braces, unless the expression\n\t     * evaluation has been cancelled due to an aborting error, an\n\t     * interrupt, or an exception.\n\t     */\n\t    if (!aborting())\n\t    {\n\t\tif (!eap->skip && fudi.fd_newkey != NULL)\n\t\t    semsg(_(e_dictkey), fudi.fd_newkey);\n\t\tvim_free(fudi.fd_newkey);\n\t\treturn NULL;\n\t    }\n\t    else\n\t\teap->skip = TRUE;\n\t}\n    }\n\n    // An error in a function call during evaluation of an expression in magic\n    // braces should not cause the function not to be defined.\n    saved_did_emsg = did_emsg;\n    did_emsg = FALSE;\n\n    /*\n     * \":function func\" with only function name: list function.\n     */\n    if (!paren)\n    {\n\tif (!ends_excmd(*skipwhite(p)))\n\t{\n\t    semsg(_(e_trailing_arg), p);\n\t    goto ret_free;\n\t}\n\tset_nextcmd(eap, p);\n\tif (eap->nextcmd != NULL)\n\t    *p = NUL;\n\tif (!eap->skip && !got_int)\n\t{\n\t    fp = find_func(name, is_global, NULL);\n\t    if (fp == NULL && ASCII_ISUPPER(*eap->arg))\n\t    {\n\t\tchar_u *up = untrans_function_name(name);\n\n\t\t// With Vim9 script the name was made script-local, if not\n\t\t// found try again with the original name.\n\t\tif (up != NULL)\n\t\t    fp = find_func(up, FALSE, NULL);\n\t    }\n\n\t    if (fp != NULL)\n\t    {\n\t\tlist_func_head(fp, TRUE);\n\t\tfor (j = 0; j < fp->uf_lines.ga_len && !got_int; ++j)\n\t\t{\n\t\t    if (FUNCLINE(fp, j) == NULL)\n\t\t\tcontinue;\n\t\t    msg_putchar('\\n');\n\t\t    msg_outnum((long)(j + 1));\n\t\t    if (j < 9)\n\t\t\tmsg_putchar(' ');\n\t\t    if (j < 99)\n\t\t\tmsg_putchar(' ');\n\t\t    msg_prt_line(FUNCLINE(fp, j), FALSE);\n\t\t    out_flush();\t// show a line at a time\n\t\t    ui_breakcheck();\n\t\t}\n\t\tif (!got_int)\n\t\t{\n\t\t    msg_putchar('\\n');\n\t\t    if (fp->uf_def_status != UF_NOT_COMPILED)\n\t\t\tmsg_puts(\"   enddef\");\n\t\t    else\n\t\t\tmsg_puts(\"   endfunction\");\n\t\t}\n\t    }\n\t    else\n\t\temsg_funcname(N_(\"E123: Undefined function: %s\"), eap->arg);\n\t}\n\tgoto ret_free;\n    }\n\n    /*\n     * \":function name(arg1, arg2)\" Define function.\n     */\n    p = skipwhite(p);\n    if (*p != '(')\n    {\n\tif (!eap->skip)\n\t{\n\t    semsg(_(\"E124: Missing '(': %s\"), eap->arg);\n\t    goto ret_free;\n\t}\n\t// attempt to continue by skipping some text\n\tif (vim_strchr(p, '(') != NULL)\n\t    p = vim_strchr(p, '(');\n    }\n\n    if ((vim9script || eap->cmdidx == CMD_def) && VIM_ISWHITE(p[-1]))\n    {\n\tsemsg(_(e_no_white_space_allowed_before_str_str), \"(\", p - 1);\n\tgoto ret_free;\n    }\n\n    // In Vim9 script only global functions can be redefined.\n    if (vim9script && eap->forceit && !is_global)\n    {\n\temsg(_(e_nobang));\n\tgoto ret_free;\n    }\n\n    ga_init2(&newlines, (int)sizeof(char_u *), 10);\n\n    if (!eap->skip && name_arg == NULL)\n    {\n\t// Check the name of the function.  Unless it's a dictionary function\n\t// (that we are overwriting).\n\tif (name != NULL)\n\t    arg = name;\n\telse\n\t    arg = fudi.fd_newkey;\n\tif (arg != NULL && (fudi.fd_di == NULL\n\t\t\t\t     || (fudi.fd_di->di_tv.v_type != VAR_FUNC\n\t\t\t\t && fudi.fd_di->di_tv.v_type != VAR_PARTIAL)))\n\t{\n\t    char_u  *name_base = arg;\n\t    int\t    i;\n\n\t    if (*arg == K_SPECIAL)\n\t    {\n\t\tname_base = vim_strchr(arg, '_');\n\t\tif (name_base == NULL)\n\t\t    name_base = arg + 3;\n\t\telse\n\t\t    ++name_base;\n\t    }\n\t    for (i = 0; name_base[i] != NUL && (i == 0\n\t\t\t\t\t? eval_isnamec1(name_base[i])\n\t\t\t\t\t: eval_isnamec(name_base[i])); ++i)\n\t\t;\n\t    if (name_base[i] != NUL)\n\t\temsg_funcname((char *)e_invarg2, arg);\n\n\t    // In Vim9 script a function cannot have the same name as a\n\t    // variable.\n\t    if (vim9script && *arg == K_SPECIAL\n\t\t&& eval_variable(name_base, (int)STRLEN(name_base), NULL, NULL,\n\t\t\t EVAL_VAR_NOAUTOLOAD + EVAL_VAR_IMPORT\n\t\t\t\t\t\t     + EVAL_VAR_NO_FUNC) == OK)\n\t    {\n\t\tsemsg(_(e_redefining_script_item_str), name_base);\n\t\tgoto ret_free;\n\t    }\n\t}\n\t// Disallow using the g: dict.\n\tif (fudi.fd_dict != NULL && fudi.fd_dict->dv_scope == VAR_DEF_SCOPE)\n\t{\n\t    emsg(_(\"E862: Cannot use g: here\"));\n\t    goto ret_free;\n\t}\n    }\n\n    // This may get more lines and make the pointers into the first line\n    // invalid.\n    ++p;\n    if (get_function_args(&p, ')', &newargs,\n\t\t\teap->cmdidx == CMD_def ? &argtypes : NULL, FALSE,\n\t\t\t NULL, &varargs, &default_args, eap->skip,\n\t\t\t eap, line_to_free) == FAIL)\n\tgoto errret_2;\n    whitep = p;\n\n    if (eap->cmdidx == CMD_def)\n    {\n\t// find the return type: :def Func(): type\n\tif (*skipwhite(p) == ':')\n\t{\n\t    if (*p != ':')\n\t    {\n\t\tsemsg(_(e_no_white_space_allowed_before_colon_str), p);\n\t\tp = skipwhite(p);\n\t    }\n\t    else if (!IS_WHITE_OR_NUL(p[1]))\n\t\tsemsg(_(e_white_space_required_after_str_str), \":\", p);\n\t    ret_type = skipwhite(p + 1);\n\t    p = skip_type(ret_type, FALSE);\n\t    if (p > ret_type)\n\t    {\n\t\tret_type = vim_strnsave(ret_type, p - ret_type);\n\t\twhitep = p;\n\t\tp = skipwhite(p);\n\t    }\n\t    else\n\t    {\n\t\tsemsg(_(e_expected_type_str), ret_type);\n\t\tret_type = NULL;\n\t    }\n\t}\n\tp = skipwhite(p);\n    }\n    else\n\t// find extra arguments \"range\", \"dict\", \"abort\" and \"closure\"\n\tfor (;;)\n\t{\n\t    whitep = p;\n\t    p = skipwhite(p);\n\t    if (STRNCMP(p, \"range\", 5) == 0)\n\t    {\n\t\tflags |= FC_RANGE;\n\t\tp += 5;\n\t    }\n\t    else if (STRNCMP(p, \"dict\", 4) == 0)\n\t    {\n\t\tflags |= FC_DICT;\n\t\tp += 4;\n\t    }\n\t    else if (STRNCMP(p, \"abort\", 5) == 0)\n\t    {\n\t\tflags |= FC_ABORT;\n\t\tp += 5;\n\t    }\n\t    else if (STRNCMP(p, \"closure\", 7) == 0)\n\t    {\n\t\tflags |= FC_CLOSURE;\n\t\tp += 7;\n\t\tif (current_funccal == NULL)\n\t\t{\n\t\t    emsg_funcname(N_(\"E932: Closure function should not be at top level: %s\"),\n\t\t\t    name == NULL ? (char_u *)\"\" : name);\n\t\t    goto erret;\n\t\t}\n\t    }\n\t    else\n\t\tbreak;\n\t}\n\n    // When there is a line break use what follows for the function body.\n    // Makes 'exe \"func Test()\\n...\\nendfunc\"' work.\n    if (*p == '\\n')\n\tline_arg = p + 1;\n    else if (*p != NUL\n\t    && !(*p == '\"' && (!vim9script || eap->cmdidx == CMD_function)\n\t\t\t\t\t\t     && eap->cmdidx != CMD_def)\n\t    && !(VIM_ISWHITE(*whitep) && *p == '#'\n\t\t\t\t     && (vim9script || eap->cmdidx == CMD_def))\n\t    && !eap->skip\n\t    && !did_emsg)\n\tsemsg(_(e_trailing_arg), p);\n\n    /*\n     * Read the body of the function, until \"}\", \":endfunction\" or \":enddef\" is\n     * found.\n     */\n    if (KeyTyped)\n    {\n\t// Check if the function already exists, don't let the user type the\n\t// whole function before telling him it doesn't work!  For a script we\n\t// need to skip the body to be able to find what follows.\n\tif (!eap->skip && !eap->forceit)\n\t{\n\t    if (fudi.fd_dict != NULL && fudi.fd_newkey == NULL)\n\t\temsg(_(e_funcdict));\n\t    else if (name != NULL && find_func(name, is_global, NULL) != NULL)\n\t\temsg_funcname(e_funcexts, name);\n\t}\n\n\tif (!eap->skip && did_emsg)\n\t    goto erret;\n\n\tmsg_putchar('\\n');\t    // don't overwrite the function name\n\tcmdline_row = msg_row;\n    }\n\n    // Save the starting line number.\n    sourcing_lnum_top = SOURCING_LNUM;\n\n    // Do not define the function when getting the body fails and when\n    // skipping.\n    if (get_function_body(eap, &newlines, line_arg, line_to_free) == FAIL\n\t    || eap->skip)\n\tgoto erret;\n\n    /*\n     * If there are no errors, add the function\n     */\n    if (fudi.fd_dict == NULL)\n    {\n\thashtab_T\t*ht;\n\n\tv = find_var(name, &ht, TRUE);\n\tif (v != NULL && v->di_tv.v_type == VAR_FUNC)\n\t{\n\t    emsg_funcname(N_(\"E707: Function name conflicts with variable: %s\"),\n\t\t\t\t\t\t\t\t\tname);\n\t    goto erret;\n\t}\n\n\tfp = find_func_even_dead(name, is_global, NULL);\n\tif (vim9script)\n\t{\n\t    char_u *uname = untrans_function_name(name);\n\n\t    import = find_imported(uname == NULL ? name : uname, 0, NULL);\n\t}\n\n\tif (fp != NULL || import != NULL)\n\t{\n\t    int dead = fp != NULL && (fp->uf_flags & FC_DEAD);\n\n\t    // Function can be replaced with \"function!\" and when sourcing the\n\t    // same script again, but only once.\n\t    // A name that is used by an import can not be overruled.\n\t    if (import != NULL\n\t\t    || (!dead && !eap->forceit\n\t\t\t&& (fp->uf_script_ctx.sc_sid != current_sctx.sc_sid\n\t\t\t  || fp->uf_script_ctx.sc_seq == current_sctx.sc_seq)))\n\t    {\n\t\tSOURCING_LNUM = sourcing_lnum_top;\n\t\tif (vim9script)\n\t\t    emsg_funcname(e_name_already_defined_str, name);\n\t\telse\n\t\t    emsg_funcname(e_funcexts, name);\n\t\tgoto erret;\n\t    }\n\t    if (fp->uf_calls > 0)\n\t    {\n\t\temsg_funcname(\n\t\t\tN_(\"E127: Cannot redefine function %s: It is in use\"),\n\t\t\t\t\t\t\t\t\tname);\n\t\tgoto erret;\n\t    }\n\t    if (fp->uf_refcount > 1)\n\t    {\n\t\t// This function is referenced somewhere, don't redefine it but\n\t\t// create a new one.\n\t\t--fp->uf_refcount;\n\t\tfp->uf_flags |= FC_REMOVED;\n\t\tfp = NULL;\n\t\toverwrite = TRUE;\n\t    }\n\t    else\n\t    {\n\t\tchar_u *exp_name = fp->uf_name_exp;\n\n\t\t// redefine existing function, keep the expanded name\n\t\tVIM_CLEAR(name);\n\t\tfp->uf_name_exp = NULL;\n\t\tfunc_clear_items(fp);\n\t\tfp->uf_name_exp = exp_name;\n\t\tfp->uf_flags &= ~FC_DEAD;\n#ifdef FEAT_PROFILE\n\t\tfp->uf_profiling = FALSE;\n\t\tfp->uf_prof_initialized = FALSE;\n#endif\n\t\tfp->uf_def_status = UF_NOT_COMPILED;\n\t    }\n\t}\n    }\n    else\n    {\n\tchar\tnumbuf[20];\n\n\tfp = NULL;\n\tif (fudi.fd_newkey == NULL && !eap->forceit)\n\t{\n\t    emsg(_(e_funcdict));\n\t    goto erret;\n\t}\n\tif (fudi.fd_di == NULL)\n\t{\n\t    // Can't add a function to a locked dictionary\n\t    if (value_check_lock(fudi.fd_dict->dv_lock, eap->arg, FALSE))\n\t\tgoto erret;\n\t}\n\t    // Can't change an existing function if it is locked\n\telse if (value_check_lock(fudi.fd_di->di_tv.v_lock, eap->arg, FALSE))\n\t    goto erret;\n\n\t// Give the function a sequential number.  Can only be used with a\n\t// Funcref!\n\tvim_free(name);\n\tsprintf(numbuf, \"%d\", ++func_nr);\n\tname = vim_strsave((char_u *)numbuf);\n\tif (name == NULL)\n\t    goto erret;\n    }\n\n    if (fp == NULL)\n    {\n\tif (fudi.fd_dict == NULL && vim_strchr(name, AUTOLOAD_CHAR) != NULL)\n\t{\n\t    int\t    slen, plen;\n\t    char_u  *scriptname;\n\n\t    // Check that the autoload name matches the script name.\n\t    j = FAIL;\n\t    if (SOURCING_NAME != NULL)\n\t    {\n\t\tscriptname = autoload_name(name);\n\t\tif (scriptname != NULL)\n\t\t{\n\t\t    p = vim_strchr(scriptname, '/');\n\t\t    plen = (int)STRLEN(p);\n\t\t    slen = (int)STRLEN(SOURCING_NAME);\n\t\t    if (slen > plen && fnamecmp(p,\n\t\t\t\t\t    SOURCING_NAME + slen - plen) == 0)\n\t\t\tj = OK;\n\t\t    vim_free(scriptname);\n\t\t}\n\t    }\n\t    if (j == FAIL)\n\t    {\n\t\tlinenr_T save_lnum = SOURCING_LNUM;\n\n\t\tSOURCING_LNUM = sourcing_lnum_top;\n\t\tsemsg(_(\"E746: Function name does not match script file name: %s\"), name);\n\t\tSOURCING_LNUM = save_lnum;\n\t\tgoto erret;\n\t    }\n\t}\n\n\tfp = alloc_clear(offsetof(ufunc_T, uf_name) + STRLEN(name) + 1);\n\tif (fp == NULL)\n\t    goto erret;\n\tfp_allocated = TRUE;\n\n\tif (fudi.fd_dict != NULL)\n\t{\n\t    if (fudi.fd_di == NULL)\n\t    {\n\t\t// add new dict entry\n\t\tfudi.fd_di = dictitem_alloc(fudi.fd_newkey);\n\t\tif (fudi.fd_di == NULL)\n\t\t{\n\t\t    vim_free(fp);\n\t\t    fp = NULL;\n\t\t    goto erret;\n\t\t}\n\t\tif (dict_add(fudi.fd_dict, fudi.fd_di) == FAIL)\n\t\t{\n\t\t    vim_free(fudi.fd_di);\n\t\t    vim_free(fp);\n\t\t    fp = NULL;\n\t\t    goto erret;\n\t\t}\n\t    }\n\t    else\n\t\t// overwrite existing dict entry\n\t\tclear_tv(&fudi.fd_di->di_tv);\n\t    fudi.fd_di->di_tv.v_type = VAR_FUNC;\n\t    fudi.fd_di->di_tv.vval.v_string = vim_strsave(name);\n\n\t    // behave like \"dict\" was used\n\t    flags |= FC_DICT;\n\t}\n    }\n    fp->uf_args = newargs;\n    fp->uf_def_args = default_args;\n    fp->uf_ret_type = &t_any;\n    fp->uf_func_type = &t_func_any;\n\n    if (eap->cmdidx == CMD_def)\n    {\n\tint\t    lnum_save = SOURCING_LNUM;\n\tcstack_T    *cstack = eap->cstack;\n\n\tfp->uf_def_status = UF_TO_BE_COMPILED;\n\n\t// error messages are for the first function line\n\tSOURCING_LNUM = sourcing_lnum_top;\n\n\t// The function may use script variables from the context.\n\tfunction_using_block_scopes(fp, cstack);\n\n\tif (parse_argument_types(fp, &argtypes, varargs) == FAIL)\n\t{\n\t    SOURCING_LNUM = lnum_save;\n\t    free_fp = fp_allocated;\n\t    goto erret;\n\t}\n\tvarargs = FALSE;\n\n\t// parse the return type, if any\n\tif (parse_return_type(fp, ret_type) == FAIL)\n\t{\n\t    SOURCING_LNUM = lnum_save;\n\t    free_fp = fp_allocated;\n\t    goto erret;\n\t}\n\tSOURCING_LNUM = lnum_save;\n    }\n    else\n\tfp->uf_def_status = UF_NOT_COMPILED;\n\n    if (fp_allocated)\n    {\n\t// insert the new function in the function list\n\tset_ufunc_name(fp, name);\n\tif (overwrite)\n\t{\n\t    hi = hash_find(&func_hashtab, name);\n\t    hi->hi_key = UF2HIKEY(fp);\n\t}\n\telse if (hash_add(&func_hashtab, UF2HIKEY(fp)) == FAIL)\n\t{\n\t    free_fp = TRUE;\n\t    goto erret;\n\t}\n\tfp->uf_refcount = 1;\n    }\n\n    fp->uf_lines = newlines;\n    newlines.ga_data = NULL;\n    if ((flags & FC_CLOSURE) != 0)\n    {\n\tif (register_closure(fp) == FAIL)\n\t    goto erret;\n    }\n    else\n\tfp->uf_scoped = NULL;\n\n#ifdef FEAT_PROFILE\n    if (prof_def_func())\n\tfunc_do_profile(fp);\n#endif\n    fp->uf_varargs = varargs;\n    if (sandbox)\n\tflags |= FC_SANDBOX;\n    if (vim9script && !ASCII_ISUPPER(*fp->uf_name))\n\tflags |= FC_VIM9;\n    fp->uf_flags = flags;\n    fp->uf_calls = 0;\n    fp->uf_cleared = FALSE;\n    fp->uf_script_ctx = current_sctx;\n    fp->uf_script_ctx_version = current_sctx.sc_version;\n    fp->uf_script_ctx.sc_lnum += sourcing_lnum_top;\n    if (is_export)\n    {\n\tfp->uf_flags |= FC_EXPORT;\n\t// let ex_export() know the export worked.\n\tis_export = FALSE;\n    }\n\n    if (eap->cmdidx == CMD_def)\n\tset_function_type(fp);\n    else if (fp->uf_script_ctx.sc_version == SCRIPT_VERSION_VIM9)\n\t// :func does not use Vim9 script syntax, even in a Vim9 script file\n\tfp->uf_script_ctx.sc_version = SCRIPT_VERSION_MAX;\n\n    goto ret_free;\n\nerret:\n    ga_clear_strings(&newargs);\n    ga_clear_strings(&default_args);\n    if (fp != NULL)\n    {\n\tga_init(&fp->uf_args);\n\tga_init(&fp->uf_def_args);\n    }\nerrret_2:\n    ga_clear_strings(&newlines);\n    if (fp != NULL)\n\tVIM_CLEAR(fp->uf_arg_types);\n    if (free_fp)\n    {\n\tvim_free(fp);\n\tfp = NULL;\n    }\nret_free:\n    ga_clear_strings(&argtypes);\n    vim_free(fudi.fd_newkey);\n    if (name != name_arg)\n\tvim_free(name);\n    vim_free(ret_type);\n    did_emsg |= saved_did_emsg;\n\n    return fp;\n}\n\n/*\n * \":function\"\n */\n    void\nex_function(exarg_T *eap)\n{\n    char_u *line_to_free = NULL;\n\n    (void)define_function(eap, NULL, &line_to_free);\n    vim_free(line_to_free);\n}\n\n/*\n * :defcompile - compile all :def functions in the current script that need to\n * be compiled.  Except dead functions.  Doesn't do profiling.\n */\n    void\nex_defcompile(exarg_T *eap UNUSED)\n{\n    long\ttodo = (long)func_hashtab.ht_used;\n    int\t\tchanged = func_hashtab.ht_changed;\n    hashitem_T\t*hi;\n    ufunc_T\t*ufunc;\n\n    for (hi = func_hashtab.ht_array; todo > 0 && !got_int; ++hi)\n    {\n\tif (!HASHITEM_EMPTY(hi))\n\t{\n\t    --todo;\n\t    ufunc = HI2UF(hi);\n\t    if (ufunc->uf_script_ctx.sc_sid == current_sctx.sc_sid\n\t\t    && ufunc->uf_def_status == UF_TO_BE_COMPILED\n\t\t    && (ufunc->uf_flags & FC_DEAD) == 0)\n\t    {\n\t\t(void)compile_def_function(ufunc, FALSE, CT_NONE, NULL);\n\n\t\tif (func_hashtab.ht_changed != changed)\n\t\t{\n\t\t    // a function has been added or removed, need to start over\n\t\t    todo = (long)func_hashtab.ht_used;\n\t\t    changed = func_hashtab.ht_changed;\n\t\t    hi = func_hashtab.ht_array;\n\t\t    --hi;\n\t\t}\n\t    }\n\t}\n    }\n}\n\n/*\n * Return 5 if \"p\" starts with \"<SID>\" or \"<SNR>\" (ignoring case).\n * Return 2 if \"p\" starts with \"s:\".\n * Return 0 otherwise.\n */\n    int\neval_fname_script(char_u *p)\n{\n    // Use MB_STRICMP() because in Turkish comparing the \"I\" may not work with\n    // the standard library function.\n    if (p[0] == '<' && (MB_STRNICMP(p + 1, \"SID>\", 4) == 0\n\t\t\t\t       || MB_STRNICMP(p + 1, \"SNR>\", 4) == 0))\n\treturn 5;\n    if (p[0] == 's' && p[1] == ':')\n\treturn 2;\n    return 0;\n}\n\n    int\ntranslated_function_exists(char_u *name, int is_global)\n{\n    if (builtin_function(name, -1))\n\treturn has_internal_func(name);\n    return find_func(name, is_global, NULL) != NULL;\n}\n\n/*\n * Return TRUE when \"ufunc\" has old-style \"...\" varargs\n * or named varargs \"...name: type\".\n */\n    int\nhas_varargs(ufunc_T *ufunc)\n{\n    return ufunc->uf_varargs || ufunc->uf_va_name != NULL;\n}\n\n/*\n * Return TRUE if a function \"name\" exists.\n * If \"no_defef\" is TRUE, do not dereference a Funcref.\n */\n    int\nfunction_exists(char_u *name, int no_deref)\n{\n    char_u  *nm = name;\n    char_u  *p;\n    int\t    n = FALSE;\n    int\t    flag;\n    int\t    is_global = FALSE;\n\n    flag = TFN_INT | TFN_QUIET | TFN_NO_AUTOLOAD;\n    if (no_deref)\n\tflag |= TFN_NO_DEREF;\n    p = trans_function_name(&nm, &is_global, FALSE, flag, NULL, NULL, NULL);\n    nm = skipwhite(nm);\n\n    // Only accept \"funcname\", \"funcname \", \"funcname (...\" and\n    // \"funcname(...\", not \"funcname!...\".\n    if (p != NULL && (*nm == NUL || *nm == '('))\n\tn = translated_function_exists(p, is_global);\n    vim_free(p);\n    return n;\n}\n\n#if defined(FEAT_PYTHON) || defined(FEAT_PYTHON3) || defined(PROTO)\n    char_u *\nget_expanded_name(char_u *name, int check)\n{\n    char_u\t*nm = name;\n    char_u\t*p;\n    int\t\tis_global = FALSE;\n\n    p = trans_function_name(&nm, &is_global, FALSE,\n\t\t\t\t\t  TFN_INT|TFN_QUIET, NULL, NULL, NULL);\n\n    if (p != NULL && *nm == NUL\n\t\t       && (!check || translated_function_exists(p, is_global)))\n\treturn p;\n\n    vim_free(p);\n    return NULL;\n}\n#endif\n\n/*\n * Function given to ExpandGeneric() to obtain the list of user defined\n * function names.\n */\n    char_u *\nget_user_func_name(expand_T *xp, int idx)\n{\n    static long_u\tdone;\n    static int\t\tchanged;\n    static hashitem_T\t*hi;\n    ufunc_T\t\t*fp;\n\n    if (idx == 0)\n    {\n\tdone = 0;\n\thi = func_hashtab.ht_array;\n\tchanged = func_hashtab.ht_changed;\n    }\n    if (changed == func_hashtab.ht_changed && done < func_hashtab.ht_used)\n    {\n\tif (done++ > 0)\n\t    ++hi;\n\twhile (HASHITEM_EMPTY(hi))\n\t    ++hi;\n\tfp = HI2UF(hi);\n\n\t// don't show dead, dict and lambda functions\n\tif ((fp->uf_flags & FC_DEAD) || (fp->uf_flags & FC_DICT)\n\t\t\t\t|| STRNCMP(fp->uf_name, \"<lambda>\", 8) == 0)\n\t    return (char_u *)\"\";\n\n\tif (STRLEN(fp->uf_name) + 4 >= IOSIZE)\n\t    return fp->uf_name;\t// prevents overflow\n\n\tcat_func_name(IObuff, fp);\n\tif (xp->xp_context != EXPAND_USER_FUNC\n\t\t\t\t       && xp->xp_context != EXPAND_DISASSEMBLE)\n\t{\n\t    STRCAT(IObuff, \"(\");\n\t    if (!has_varargs(fp) && fp->uf_args.ga_len == 0)\n\t\tSTRCAT(IObuff, \")\");\n\t}\n\treturn IObuff;\n    }\n    return NULL;\n}\n\n/*\n * \":delfunction {name}\"\n */\n    void\nex_delfunction(exarg_T *eap)\n{\n    ufunc_T\t*fp = NULL;\n    char_u\t*p;\n    char_u\t*name;\n    funcdict_T\tfudi;\n    int\t\tis_global = FALSE;\n\n    p = eap->arg;\n    name = trans_function_name(&p, &is_global, eap->skip, 0, &fudi,\n\t\t\t\t\t\t\t\t   NULL, NULL);\n    vim_free(fudi.fd_newkey);\n    if (name == NULL)\n    {\n\tif (fudi.fd_dict != NULL && !eap->skip)\n\t    emsg(_(e_funcref));\n\treturn;\n    }\n    if (!ends_excmd(*skipwhite(p)))\n    {\n\tvim_free(name);\n\tsemsg(_(e_trailing_arg), p);\n\treturn;\n    }\n    set_nextcmd(eap, p);\n    if (eap->nextcmd != NULL)\n\t*p = NUL;\n\n    if (numbered_function(name) && fudi.fd_dict == NULL)\n    {\n\tif (!eap->skip)\n\t    semsg(_(e_invarg2), eap->arg);\n\tvim_free(name);\n\treturn;\n    }\n    if (!eap->skip)\n\tfp = find_func(name, is_global, NULL);\n    vim_free(name);\n\n    if (!eap->skip)\n    {\n\tif (fp == NULL)\n\t{\n\t    if (!eap->forceit)\n\t\tsemsg(_(e_nofunc), eap->arg);\n\t    return;\n\t}\n\tif (fp->uf_calls > 0)\n\t{\n\t    semsg(_(\"E131: Cannot delete function %s: It is in use\"), eap->arg);\n\t    return;\n\t}\n\tif (fp->uf_flags & FC_VIM9)\n\t{\n\t    semsg(_(e_cannot_delete_vim9_script_function_str), eap->arg);\n\t    return;\n\t}\n\n\tif (fudi.fd_dict != NULL)\n\t{\n\t    // Delete the dict item that refers to the function, it will\n\t    // invoke func_unref() and possibly delete the function.\n\t    dictitem_remove(fudi.fd_dict, fudi.fd_di);\n\t}\n\telse\n\t{\n\t    // A normal function (not a numbered function or lambda) has a\n\t    // refcount of 1 for the entry in the hashtable.  When deleting\n\t    // it and the refcount is more than one, it should be kept.\n\t    // A numbered function and lambda should be kept if the refcount is\n\t    // one or more.\n\t    if (fp->uf_refcount > (func_name_refcount(fp->uf_name) ? 0 : 1))\n\t    {\n\t\t// Function is still referenced somewhere.  Don't free it but\n\t\t// do remove it from the hashtable.\n\t\tif (func_remove(fp))\n\t\t    fp->uf_refcount--;\n\t    }\n\t    else\n\t\tfunc_clear_free(fp, FALSE);\n\t}\n    }\n}\n\n/*\n * Unreference a Function: decrement the reference count and free it when it\n * becomes zero.\n */\n    void\nfunc_unref(char_u *name)\n{\n    ufunc_T *fp = NULL;\n\n    if (name == NULL || !func_name_refcount(name))\n\treturn;\n    fp = find_func(name, FALSE, NULL);\n    if (fp == NULL && numbered_function(name))\n    {\n#ifdef EXITFREE\n\tif (!entered_free_all_mem)\n#endif\n\t    internal_error(\"func_unref()\");\n    }\n    func_ptr_unref(fp);\n}\n\n/*\n * Unreference a Function: decrement the reference count and free it when it\n * becomes zero.\n * Also when it becomes one and uf_partial points to the function.\n */\n    void\nfunc_ptr_unref(ufunc_T *fp)\n{\n    if (fp != NULL && (--fp->uf_refcount <= 0\n\t\t|| (fp->uf_refcount == 1 && fp->uf_partial != NULL\n\t\t\t\t\t && fp->uf_partial->pt_refcount <= 1\n\t\t\t\t\t && fp->uf_partial->pt_func == fp)))\n    {\n\t// Only delete it when it's not being used.  Otherwise it's done\n\t// when \"uf_calls\" becomes zero.\n\tif (fp->uf_calls == 0)\n\t    func_clear_free(fp, FALSE);\n    }\n}\n\n/*\n * Count a reference to a Function.\n */\n    void\nfunc_ref(char_u *name)\n{\n    ufunc_T *fp;\n\n    if (name == NULL || !func_name_refcount(name))\n\treturn;\n    fp = find_func(name, FALSE, NULL);\n    if (fp != NULL)\n\t++fp->uf_refcount;\n    else if (numbered_function(name))\n\t// Only give an error for a numbered function.\n\t// Fail silently, when named or lambda function isn't found.\n\tinternal_error(\"func_ref()\");\n}\n\n/*\n * Count a reference to a Function.\n */\n    void\nfunc_ptr_ref(ufunc_T *fp)\n{\n    if (fp != NULL)\n\t++fp->uf_refcount;\n}\n\n/*\n * Return TRUE if items in \"fc\" do not have \"copyID\".  That means they are not\n * referenced from anywhere that is in use.\n */\n    static int\ncan_free_funccal(funccall_T *fc, int copyID)\n{\n    return (fc->l_varlist.lv_copyID != copyID\n\t    && fc->l_vars.dv_copyID != copyID\n\t    && fc->l_avars.dv_copyID != copyID\n\t    && fc->fc_copyID != copyID);\n}\n\n/*\n * \":return [expr]\"\n */\n    void\nex_return(exarg_T *eap)\n{\n    char_u\t*arg = eap->arg;\n    typval_T\trettv;\n    int\t\treturning = FALSE;\n    evalarg_T\tevalarg;\n\n    if (current_funccal == NULL)\n    {\n\temsg(_(\"E133: :return not inside a function\"));\n\treturn;\n    }\n\n    init_evalarg(&evalarg);\n    evalarg.eval_flags = eap->skip ? 0 : EVAL_EVALUATE;\n\n    if (eap->skip)\n\t++emsg_skip;\n\n    eap->nextcmd = NULL;\n    if ((*arg != NUL && *arg != '|' && *arg != '\\n')\n\t\t\t\t  && eval0(arg, &rettv, eap, &evalarg) != FAIL)\n    {\n\tif (!eap->skip)\n\t    returning = do_return(eap, FALSE, TRUE, &rettv);\n\telse\n\t    clear_tv(&rettv);\n    }\n    // It's safer to return also on error.\n    else if (!eap->skip)\n    {\n\t// In return statement, cause_abort should be force_abort.\n\tupdate_force_abort();\n\n\t/*\n\t * Return unless the expression evaluation has been cancelled due to an\n\t * aborting error, an interrupt, or an exception.\n\t */\n\tif (!aborting())\n\t    returning = do_return(eap, FALSE, TRUE, NULL);\n    }\n\n    // When skipping or the return gets pending, advance to the next command\n    // in this line (!returning).  Otherwise, ignore the rest of the line.\n    // Following lines will be ignored by get_func_line().\n    if (returning)\n\teap->nextcmd = NULL;\n    else if (eap->nextcmd == NULL)\t    // no argument\n\tset_nextcmd(eap, arg);\n\n    if (eap->skip)\n\t--emsg_skip;\n    clear_evalarg(&evalarg, eap);\n}\n\n/*\n * \":1,25call func(arg1, arg2)\"\tfunction call.\n */\n    void\nex_call(exarg_T *eap)\n{\n    char_u\t*arg = eap->arg;\n    char_u\t*startarg;\n    char_u\t*name;\n    char_u\t*tofree;\n    int\t\tlen;\n    typval_T\trettv;\n    linenr_T\tlnum;\n    int\t\tdoesrange;\n    int\t\tfailed = FALSE;\n    funcdict_T\tfudi;\n    partial_T\t*partial = NULL;\n    evalarg_T\tevalarg;\n    type_T\t*type = NULL;\n    int\t\tfound_var = FALSE;\n\n    fill_evalarg_from_eap(&evalarg, eap, eap->skip);\n    if (eap->skip)\n    {\n\t// trans_function_name() doesn't work well when skipping, use eval0()\n\t// instead to skip to any following command, e.g. for:\n\t//   :if 0 | call dict.foo().bar() | endif\n\t++emsg_skip;\n\tif (eval0(eap->arg, &rettv, eap, &evalarg) != FAIL)\n\t    clear_tv(&rettv);\n\t--emsg_skip;\n\tclear_evalarg(&evalarg, eap);\n\treturn;\n    }\n\n    tofree = trans_function_name(&arg, NULL, eap->skip, TFN_INT,\n\t\t\t      &fudi, &partial, in_vim9script() ? &type : NULL);\n    if (fudi.fd_newkey != NULL)\n    {\n\t// Still need to give an error message for missing key.\n\tsemsg(_(e_dictkey), fudi.fd_newkey);\n\tvim_free(fudi.fd_newkey);\n    }\n    if (tofree == NULL)\n\treturn;\n\n    // Increase refcount on dictionary, it could get deleted when evaluating\n    // the arguments.\n    if (fudi.fd_dict != NULL)\n\t++fudi.fd_dict->dv_refcount;\n\n    // If it is the name of a variable of type VAR_FUNC or VAR_PARTIAL use its\n    // contents.  For VAR_PARTIAL get its partial, unless we already have one\n    // from trans_function_name().\n    len = (int)STRLEN(tofree);\n    name = deref_func_name(tofree, &len, partial != NULL ? NULL : &partial,\n\t    in_vim9script() && type == NULL ? &type : NULL, FALSE, &found_var);\n\n    // Skip white space to allow \":call func ()\".  Not good, but required for\n    // backward compatibility.\n    startarg = skipwhite(arg);\n    if (*startarg != '(')\n    {\n\tsemsg(_(e_missing_parenthesis_str), eap->arg);\n\tgoto end;\n    }\n    if (in_vim9script() && startarg > arg)\n    {\n\tsemsg(_(e_no_white_space_allowed_before_str_str), \"(\", eap->arg);\n\tgoto end;\n    }\n\n    /*\n     * When skipping, evaluate the function once, to find the end of the\n     * arguments.\n     * When the function takes a range, this is discovered after the first\n     * call, and the loop is broken.\n     */\n    if (eap->skip)\n    {\n\t++emsg_skip;\n\tlnum = eap->line2;\t// do it once, also with an invalid range\n    }\n    else\n\tlnum = eap->line1;\n    for ( ; lnum <= eap->line2; ++lnum)\n    {\n\tfuncexe_T funcexe;\n\n\tif (!eap->skip && eap->addr_count > 0)\n\t{\n\t    if (lnum > curbuf->b_ml.ml_line_count)\n\t    {\n\t\t// If the function deleted lines or switched to another buffer\n\t\t// the line number may become invalid.\n\t\temsg(_(e_invalid_range));\n\t\tbreak;\n\t    }\n\t    curwin->w_cursor.lnum = lnum;\n\t    curwin->w_cursor.col = 0;\n\t    curwin->w_cursor.coladd = 0;\n\t}\n\targ = startarg;\n\n\tCLEAR_FIELD(funcexe);\n\tfuncexe.fe_firstline = eap->line1;\n\tfuncexe.fe_lastline = eap->line2;\n\tfuncexe.fe_doesrange = &doesrange;\n\tfuncexe.fe_evaluate = !eap->skip;\n\tfuncexe.fe_partial = partial;\n\tfuncexe.fe_selfdict = fudi.fd_dict;\n\tfuncexe.fe_check_type = type;\n\tfuncexe.fe_found_var = found_var;\n\trettv.v_type = VAR_UNKNOWN;\t// clear_tv() uses this\n\tif (get_func_tv(name, -1, &rettv, &arg, &evalarg, &funcexe) == FAIL)\n\t{\n\t    failed = TRUE;\n\t    break;\n\t}\n\tif (has_watchexpr())\n\t    dbg_check_breakpoint(eap);\n\n\t// Handle a function returning a Funcref, Dictionary or List.\n\tif (handle_subscript(&arg, &rettv,\n\t\t\t   eap->skip ? NULL : &EVALARG_EVALUATE, TRUE) == FAIL)\n\t{\n\t    failed = TRUE;\n\t    break;\n\t}\n\n\tclear_tv(&rettv);\n\tif (doesrange || eap->skip)\n\t    break;\n\n\t// Stop when immediately aborting on error, or when an interrupt\n\t// occurred or an exception was thrown but not caught.\n\t// get_func_tv() returned OK, so that the check for trailing\n\t// characters below is executed.\n\tif (aborting())\n\t    break;\n    }\n    if (eap->skip)\n\t--emsg_skip;\n    clear_evalarg(&evalarg, eap);\n\n    // When inside :try we need to check for following \"| catch\" or \"| endtry\".\n    // Not when there was an error, but do check if an exception was thrown.\n    if ((!aborting() || did_throw)\n\t\t\t\t  && (!failed || eap->cstack->cs_trylevel > 0))\n    {\n\t// Check for trailing illegal characters and a following command.\n\targ = skipwhite(arg);\n\tif (!ends_excmd2(eap->arg, arg))\n\t{\n\t    if (!failed && !aborting())\n\t    {\n\t\temsg_severe = TRUE;\n\t\tsemsg(_(e_trailing_arg), arg);\n\t    }\n\t}\n\telse\n\t    set_nextcmd(eap, arg);\n    }\n\nend:\n    dict_unref(fudi.fd_dict);\n    vim_free(tofree);\n}\n\n/*\n * Return from a function.  Possibly makes the return pending.  Also called\n * for a pending return at the \":endtry\" or after returning from an extra\n * do_cmdline().  \"reanimate\" is used in the latter case.  \"is_cmd\" is set\n * when called due to a \":return\" command.  \"rettv\" may point to a typval_T\n * with the return rettv.  Returns TRUE when the return can be carried out,\n * FALSE when the return gets pending.\n */\n    int\ndo_return(\n    exarg_T\t*eap,\n    int\t\treanimate,\n    int\t\tis_cmd,\n    void\t*rettv)\n{\n    int\t\tidx;\n    cstack_T\t*cstack = eap->cstack;\n\n    if (reanimate)\n\t// Undo the return.\n\tcurrent_funccal->returned = FALSE;\n\n    /*\n     * Cleanup (and inactivate) conditionals, but stop when a try conditional\n     * not in its finally clause (which then is to be executed next) is found.\n     * In this case, make the \":return\" pending for execution at the \":endtry\".\n     * Otherwise, return normally.\n     */\n    idx = cleanup_conditionals(eap->cstack, 0, TRUE);\n    if (idx >= 0)\n    {\n\tcstack->cs_pending[idx] = CSTP_RETURN;\n\n\tif (!is_cmd && !reanimate)\n\t    // A pending return again gets pending.  \"rettv\" points to an\n\t    // allocated variable with the rettv of the original \":return\"'s\n\t    // argument if present or is NULL else.\n\t    cstack->cs_rettv[idx] = rettv;\n\telse\n\t{\n\t    // When undoing a return in order to make it pending, get the stored\n\t    // return rettv.\n\t    if (reanimate)\n\t\trettv = current_funccal->rettv;\n\n\t    if (rettv != NULL)\n\t    {\n\t\t// Store the value of the pending return.\n\t\tif ((cstack->cs_rettv[idx] = alloc_tv()) != NULL)\n\t\t    *(typval_T *)cstack->cs_rettv[idx] = *(typval_T *)rettv;\n\t\telse\n\t\t    emsg(_(e_out_of_memory));\n\t    }\n\t    else\n\t\tcstack->cs_rettv[idx] = NULL;\n\n\t    if (reanimate)\n\t    {\n\t\t// The pending return value could be overwritten by a \":return\"\n\t\t// without argument in a finally clause; reset the default\n\t\t// return value.\n\t\tcurrent_funccal->rettv->v_type = VAR_NUMBER;\n\t\tcurrent_funccal->rettv->vval.v_number = 0;\n\t    }\n\t}\n\treport_make_pending(CSTP_RETURN, rettv);\n    }\n    else\n    {\n\tcurrent_funccal->returned = TRUE;\n\n\t// If the return is carried out now, store the return value.  For\n\t// a return immediately after reanimation, the value is already\n\t// there.\n\tif (!reanimate && rettv != NULL)\n\t{\n\t    clear_tv(current_funccal->rettv);\n\t    *current_funccal->rettv = *(typval_T *)rettv;\n\t    if (!is_cmd)\n\t\tvim_free(rettv);\n\t}\n    }\n\n    return idx < 0;\n}\n\n/*\n * Free the variable with a pending return value.\n */\n    void\ndiscard_pending_return(void *rettv)\n{\n    free_tv((typval_T *)rettv);\n}\n\n/*\n * Generate a return command for producing the value of \"rettv\".  The result\n * is an allocated string.  Used by report_pending() for verbose messages.\n */\n    char_u *\nget_return_cmd(void *rettv)\n{\n    char_u\t*s = NULL;\n    char_u\t*tofree = NULL;\n    char_u\tnumbuf[NUMBUFLEN];\n\n    if (rettv != NULL)\n\ts = echo_string((typval_T *)rettv, &tofree, numbuf, 0);\n    if (s == NULL)\n\ts = (char_u *)\"\";\n\n    STRCPY(IObuff, \":return \");\n    STRNCPY(IObuff + 8, s, IOSIZE - 8);\n    if (STRLEN(s) + 8 >= IOSIZE)\n\tSTRCPY(IObuff + IOSIZE - 4, \"...\");\n    vim_free(tofree);\n    return vim_strsave(IObuff);\n}\n\n/*\n * Get next function line.\n * Called by do_cmdline() to get the next line.\n * Returns allocated string, or NULL for end of function.\n */\n    char_u *\nget_func_line(\n    int\t    c UNUSED,\n    void    *cookie,\n    int\t    indent UNUSED,\n    getline_opt_T options UNUSED)\n{\n    funccall_T\t*fcp = (funccall_T *)cookie;\n    ufunc_T\t*fp = fcp->func;\n    char_u\t*retval;\n    garray_T\t*gap;  // growarray with function lines\n\n    // If breakpoints have been added/deleted need to check for it.\n    if (fcp->dbg_tick != debug_tick)\n    {\n\tfcp->breakpoint = dbg_find_breakpoint(FALSE, fp->uf_name,\n\t\t\t\t\t\t\t       SOURCING_LNUM);\n\tfcp->dbg_tick = debug_tick;\n    }\n#ifdef FEAT_PROFILE\n    if (do_profiling == PROF_YES)\n\tfunc_line_end(cookie);\n#endif\n\n    gap = &fp->uf_lines;\n    if (((fp->uf_flags & FC_ABORT) && did_emsg && !aborted_in_try())\n\t    || fcp->returned)\n\tretval = NULL;\n    else\n    {\n\t// Skip NULL lines (continuation lines).\n\twhile (fcp->linenr < gap->ga_len\n\t\t\t  && ((char_u **)(gap->ga_data))[fcp->linenr] == NULL)\n\t    ++fcp->linenr;\n\tif (fcp->linenr >= gap->ga_len)\n\t    retval = NULL;\n\telse\n\t{\n\t    retval = vim_strsave(((char_u **)(gap->ga_data))[fcp->linenr++]);\n\t    SOURCING_LNUM = fcp->linenr;\n#ifdef FEAT_PROFILE\n\t    if (do_profiling == PROF_YES)\n\t\tfunc_line_start(cookie, SOURCING_LNUM);\n#endif\n\t}\n    }\n\n    // Did we encounter a breakpoint?\n    if (fcp->breakpoint != 0 && fcp->breakpoint <= SOURCING_LNUM)\n    {\n\tdbg_breakpoint(fp->uf_name, SOURCING_LNUM);\n\t// Find next breakpoint.\n\tfcp->breakpoint = dbg_find_breakpoint(FALSE, fp->uf_name,\n\t\t\t\t\t\t\t       SOURCING_LNUM);\n\tfcp->dbg_tick = debug_tick;\n    }\n\n    return retval;\n}\n\n/*\n * Return TRUE if the currently active function should be ended, because a\n * return was encountered or an error occurred.  Used inside a \":while\".\n */\n    int\nfunc_has_ended(void *cookie)\n{\n    funccall_T  *fcp = (funccall_T *)cookie;\n\n    // Ignore the \"abort\" flag if the abortion behavior has been changed due to\n    // an error inside a try conditional.\n    return (((fcp->func->uf_flags & FC_ABORT) && did_emsg && !aborted_in_try())\n\t    || fcp->returned);\n}\n\n/*\n * return TRUE if cookie indicates a function which \"abort\"s on errors.\n */\n    int\nfunc_has_abort(\n    void    *cookie)\n{\n    return ((funccall_T *)cookie)->func->uf_flags & FC_ABORT;\n}\n\n\n/*\n * Turn \"dict.Func\" into a partial for \"Func\" bound to \"dict\".\n * Don't do this when \"Func\" is already a partial that was bound\n * explicitly (pt_auto is FALSE).\n * Changes \"rettv\" in-place.\n * Returns the updated \"selfdict_in\".\n */\n    dict_T *\nmake_partial(dict_T *selfdict_in, typval_T *rettv)\n{\n    char_u\t*fname;\n    char_u\t*tofree = NULL;\n    ufunc_T\t*fp;\n    char_u\tfname_buf[FLEN_FIXED + 1];\n    int\t\terror;\n    dict_T\t*selfdict = selfdict_in;\n\n    if (rettv->v_type == VAR_PARTIAL && rettv->vval.v_partial->pt_func != NULL)\n\tfp = rettv->vval.v_partial->pt_func;\n    else\n    {\n\tfname = rettv->v_type == VAR_FUNC ? rettv->vval.v_string\n\t\t\t\t\t      : rettv->vval.v_partial->pt_name;\n\t// Translate \"s:func\" to the stored function name.\n\tfname = fname_trans_sid(fname, fname_buf, &tofree, &error);\n\tfp = find_func(fname, FALSE, NULL);\n\tvim_free(tofree);\n    }\n\n    if (fp != NULL && (fp->uf_flags & FC_DICT))\n    {\n\tpartial_T\t*pt = ALLOC_CLEAR_ONE(partial_T);\n\n\tif (pt != NULL)\n\t{\n\t    pt->pt_refcount = 1;\n\t    pt->pt_dict = selfdict;\n\t    pt->pt_auto = TRUE;\n\t    selfdict = NULL;\n\t    if (rettv->v_type == VAR_FUNC)\n\t    {\n\t\t// Just a function: Take over the function name and use\n\t\t// selfdict.\n\t\tpt->pt_name = rettv->vval.v_string;\n\t    }\n\t    else\n\t    {\n\t\tpartial_T\t*ret_pt = rettv->vval.v_partial;\n\t\tint\t\ti;\n\n\t\t// Partial: copy the function name, use selfdict and copy\n\t\t// args.  Can't take over name or args, the partial might\n\t\t// be referenced elsewhere.\n\t\tif (ret_pt->pt_name != NULL)\n\t\t{\n\t\t    pt->pt_name = vim_strsave(ret_pt->pt_name);\n\t\t    func_ref(pt->pt_name);\n\t\t}\n\t\telse\n\t\t{\n\t\t    pt->pt_func = ret_pt->pt_func;\n\t\t    func_ptr_ref(pt->pt_func);\n\t\t}\n\t\tif (ret_pt->pt_argc > 0)\n\t\t{\n\t\t    pt->pt_argv = ALLOC_MULT(typval_T, ret_pt->pt_argc);\n\t\t    if (pt->pt_argv == NULL)\n\t\t\t// out of memory: drop the arguments\n\t\t\tpt->pt_argc = 0;\n\t\t    else\n\t\t    {\n\t\t\tpt->pt_argc = ret_pt->pt_argc;\n\t\t\tfor (i = 0; i < pt->pt_argc; i++)\n\t\t\t    copy_tv(&ret_pt->pt_argv[i], &pt->pt_argv[i]);\n\t\t    }\n\t\t}\n\t\tpartial_unref(ret_pt);\n\t    }\n\t    rettv->v_type = VAR_PARTIAL;\n\t    rettv->vval.v_partial = pt;\n\t}\n    }\n    return selfdict;\n}\n\n/*\n * Return the name of the executed function.\n */\n    char_u *\nfunc_name(void *cookie)\n{\n    return ((funccall_T *)cookie)->func->uf_name;\n}\n\n/*\n * Return the address holding the next breakpoint line for a funccall cookie.\n */\n    linenr_T *\nfunc_breakpoint(void *cookie)\n{\n    return &((funccall_T *)cookie)->breakpoint;\n}\n\n/*\n * Return the address holding the debug tick for a funccall cookie.\n */\n    int *\nfunc_dbg_tick(void *cookie)\n{\n    return &((funccall_T *)cookie)->dbg_tick;\n}\n\n/*\n * Return the nesting level for a funccall cookie.\n */\n    int\nfunc_level(void *cookie)\n{\n    return ((funccall_T *)cookie)->level;\n}\n\n/*\n * Return TRUE when a function was ended by a \":return\" command.\n */\n    int\ncurrent_func_returned(void)\n{\n    return current_funccal->returned;\n}\n\n    int\nfree_unref_funccal(int copyID, int testing)\n{\n    int\t\tdid_free = FALSE;\n    int\t\tdid_free_funccal = FALSE;\n    funccall_T\t*fc, **pfc;\n\n    for (pfc = &previous_funccal; *pfc != NULL; )\n    {\n\tif (can_free_funccal(*pfc, copyID))\n\t{\n\t    fc = *pfc;\n\t    *pfc = fc->caller;\n\t    free_funccal_contents(fc);\n\t    did_free = TRUE;\n\t    did_free_funccal = TRUE;\n\t}\n\telse\n\t    pfc = &(*pfc)->caller;\n    }\n    if (did_free_funccal)\n\t// When a funccal was freed some more items might be garbage\n\t// collected, so run again.\n\t(void)garbage_collect(testing);\n\n    return did_free;\n}\n\n/*\n * Get function call environment based on backtrace debug level\n */\n    static funccall_T *\nget_funccal(void)\n{\n    int\t\ti;\n    funccall_T\t*funccal;\n    funccall_T\t*temp_funccal;\n\n    funccal = current_funccal;\n    if (debug_backtrace_level > 0)\n    {\n\tfor (i = 0; i < debug_backtrace_level; i++)\n\t{\n\t    temp_funccal = funccal->caller;\n\t    if (temp_funccal)\n\t\tfunccal = temp_funccal;\n\t    else\n\t\t// backtrace level overflow. reset to max\n\t\tdebug_backtrace_level = i;\n\t}\n    }\n    return funccal;\n}\n\n/*\n * Return the hashtable used for local variables in the current funccal.\n * Return NULL if there is no current funccal.\n */\n    hashtab_T *\nget_funccal_local_ht()\n{\n    if (current_funccal == NULL || current_funccal->l_vars.dv_refcount == 0)\n\treturn NULL;\n    return &get_funccal()->l_vars.dv_hashtab;\n}\n\n/*\n * Return the l: scope variable.\n * Return NULL if there is no current funccal.\n */\n    dictitem_T *\nget_funccal_local_var()\n{\n    if (current_funccal == NULL || current_funccal->l_vars.dv_refcount == 0)\n\treturn NULL;\n    return &get_funccal()->l_vars_var;\n}\n\n/*\n * Return the hashtable used for argument in the current funccal.\n * Return NULL if there is no current funccal.\n */\n    hashtab_T *\nget_funccal_args_ht()\n{\n    if (current_funccal == NULL || current_funccal->l_vars.dv_refcount == 0)\n\treturn NULL;\n    return &get_funccal()->l_avars.dv_hashtab;\n}\n\n/*\n * Return the a: scope variable.\n * Return NULL if there is no current funccal.\n */\n    dictitem_T *\nget_funccal_args_var()\n{\n    if (current_funccal == NULL || current_funccal->l_vars.dv_refcount == 0)\n\treturn NULL;\n    return &get_funccal()->l_avars_var;\n}\n\n/*\n * List function variables, if there is a function.\n */\n    void\nlist_func_vars(int *first)\n{\n    if (current_funccal != NULL && current_funccal->l_vars.dv_refcount > 0)\n\tlist_hashtable_vars(&current_funccal->l_vars.dv_hashtab,\n\t\t\t\t\t\t\t   \"l:\", FALSE, first);\n}\n\n/*\n * If \"ht\" is the hashtable for local variables in the current funccal, return\n * the dict that contains it.\n * Otherwise return NULL.\n */\n    dict_T *\nget_current_funccal_dict(hashtab_T *ht)\n{\n    if (current_funccal != NULL\n\t    && ht == &current_funccal->l_vars.dv_hashtab)\n\treturn &current_funccal->l_vars;\n    return NULL;\n}\n\n/*\n * Search hashitem in parent scope.\n */\n    hashitem_T *\nfind_hi_in_scoped_ht(char_u *name, hashtab_T **pht)\n{\n    funccall_T\t*old_current_funccal = current_funccal;\n    hashtab_T\t*ht;\n    hashitem_T\t*hi = NULL;\n    char_u\t*varname;\n\n    if (current_funccal == NULL || current_funccal->func->uf_scoped == NULL)\n      return NULL;\n\n    // Search in parent scope, which can be referenced from a lambda.\n    current_funccal = current_funccal->func->uf_scoped;\n    while (current_funccal != NULL)\n    {\n\tht = find_var_ht(name, &varname);\n\tif (ht != NULL && *varname != NUL)\n\t{\n\t    hi = hash_find(ht, varname);\n\t    if (!HASHITEM_EMPTY(hi))\n\t    {\n\t\t*pht = ht;\n\t\tbreak;\n\t    }\n\t}\n\tif (current_funccal == current_funccal->func->uf_scoped)\n\t    break;\n\tcurrent_funccal = current_funccal->func->uf_scoped;\n    }\n    current_funccal = old_current_funccal;\n\n    return hi;\n}\n\n/*\n * Search variable in parent scope.\n */\n    dictitem_T *\nfind_var_in_scoped_ht(char_u *name, int no_autoload)\n{\n    dictitem_T\t*v = NULL;\n    funccall_T\t*old_current_funccal = current_funccal;\n    hashtab_T\t*ht;\n    char_u\t*varname;\n\n    if (current_funccal == NULL || current_funccal->func->uf_scoped == NULL)\n\treturn NULL;\n\n    // Search in parent scope which is possible to reference from lambda\n    current_funccal = current_funccal->func->uf_scoped;\n    while (current_funccal)\n    {\n\tht = find_var_ht(name, &varname);\n\tif (ht != NULL && *varname != NUL)\n\t{\n\t    v = find_var_in_ht(ht, *name, varname, no_autoload);\n\t    if (v != NULL)\n\t\tbreak;\n\t}\n\tif (current_funccal == current_funccal->func->uf_scoped)\n\t    break;\n\tcurrent_funccal = current_funccal->func->uf_scoped;\n    }\n    current_funccal = old_current_funccal;\n\n    return v;\n}\n\n/*\n * Set \"copyID + 1\" in previous_funccal and callers.\n */\n    int\nset_ref_in_previous_funccal(int copyID)\n{\n    funccall_T\t*fc;\n\n    for (fc = previous_funccal; fc != NULL; fc = fc->caller)\n    {\n\tfc->fc_copyID = copyID + 1;\n\tif (set_ref_in_ht(&fc->l_vars.dv_hashtab, copyID + 1, NULL)\n\t\t|| set_ref_in_ht(&fc->l_avars.dv_hashtab, copyID + 1, NULL)\n\t\t|| set_ref_in_list_items(&fc->l_varlist, copyID + 1, NULL))\n\t    return TRUE;\n    }\n    return FALSE;\n}\n\n    static int\nset_ref_in_funccal(funccall_T *fc, int copyID)\n{\n    if (fc->fc_copyID != copyID)\n    {\n\tfc->fc_copyID = copyID;\n\tif (set_ref_in_ht(&fc->l_vars.dv_hashtab, copyID, NULL)\n\t\t|| set_ref_in_ht(&fc->l_avars.dv_hashtab, copyID, NULL)\n\t\t|| set_ref_in_list_items(&fc->l_varlist, copyID, NULL)\n\t\t|| set_ref_in_func(NULL, fc->func, copyID))\n\t    return TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Set \"copyID\" in all local vars and arguments in the call stack.\n */\n    int\nset_ref_in_call_stack(int copyID)\n{\n    funccall_T\t\t*fc;\n    funccal_entry_T\t*entry;\n\n    for (fc = current_funccal; fc != NULL; fc = fc->caller)\n\tif (set_ref_in_funccal(fc, copyID))\n\t    return TRUE;\n\n    // Also go through the funccal_stack.\n    for (entry = funccal_stack; entry != NULL; entry = entry->next)\n\tfor (fc = entry->top_funccal; fc != NULL; fc = fc->caller)\n\t    if (set_ref_in_funccal(fc, copyID))\n\t\treturn TRUE;\n    return FALSE;\n}\n\n/*\n * Set \"copyID\" in all functions available by name.\n */\n    int\nset_ref_in_functions(int copyID)\n{\n    int\t\ttodo;\n    hashitem_T\t*hi = NULL;\n    ufunc_T\t*fp;\n\n    todo = (int)func_hashtab.ht_used;\n    for (hi = func_hashtab.ht_array; todo > 0 && !got_int; ++hi)\n    {\n\tif (!HASHITEM_EMPTY(hi))\n\t{\n\t    --todo;\n\t    fp = HI2UF(hi);\n\t    if (!func_name_refcount(fp->uf_name)\n\t\t\t\t\t  && set_ref_in_func(NULL, fp, copyID))\n\t\treturn TRUE;\n\t}\n    }\n    return FALSE;\n}\n\n/*\n * Set \"copyID\" in all function arguments.\n */\n    int\nset_ref_in_func_args(int copyID)\n{\n    int i;\n\n    for (i = 0; i < funcargs.ga_len; ++i)\n\tif (set_ref_in_item(((typval_T **)funcargs.ga_data)[i],\n\t\t\t\t\t\t\t  copyID, NULL, NULL))\n\t    return TRUE;\n    return FALSE;\n}\n\n/*\n * Mark all lists and dicts referenced through function \"name\" with \"copyID\".\n * Returns TRUE if setting references failed somehow.\n */\n    int\nset_ref_in_func(char_u *name, ufunc_T *fp_in, int copyID)\n{\n    ufunc_T\t*fp = fp_in;\n    funccall_T\t*fc;\n    int\t\terror = FCERR_NONE;\n    char_u\tfname_buf[FLEN_FIXED + 1];\n    char_u\t*tofree = NULL;\n    char_u\t*fname;\n    int\t\tabort = FALSE;\n\n    if (name == NULL && fp_in == NULL)\n\treturn FALSE;\n\n    if (fp_in == NULL)\n    {\n\tfname = fname_trans_sid(name, fname_buf, &tofree, &error);\n\tfp = find_func(fname, FALSE, NULL);\n    }\n    if (fp != NULL)\n    {\n\tfor (fc = fp->uf_scoped; fc != NULL; fc = fc->func->uf_scoped)\n\t    abort = abort || set_ref_in_funccal(fc, copyID);\n    }\n\n    vim_free(tofree);\n    return abort;\n}\n\n#endif // FEAT_EVAL\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n#ifdef FEAT_CINDENT\n\t\"+cindent\",\n#else\n\t\"-cindent\",\n#endif\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n#ifdef EBCDIC\n\t\"+ebcdic\",\n#else\n\t\"-ebcdic\",\n#endif\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n#ifdef FEAT_LISP\n\t\"+lispindent\",\n#else\n\t\"-lispindent\",\n#endif\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n\t\"+mouse_gpm\",\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n#ifdef FEAT_SMARTINDENT\n\t\"+smartindent\",\n#else\n\t\"-smartindent\",\n#endif\n#ifdef FEAT_SODIUM\n\t\"+sodium\",\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n#ifdef FEAT_TAG_BINS\n\t\"+tag_binary\",\n#else\n\t\"-tag_binary\",\n#endif\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#ifdef MSWIN\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#else\n# ifdef HAVE_XPM\n\t\"+xpm\",\n# else\n\t\"-xpm\",\n# endif\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef USE_XSMP_INTERACT\n\t\"+xsmp_interact\",\n# else\n#  ifdef USE_XSMP\n\t\"+xsmp\",\n#  else\n\t\"-xsmp\",\n#  endif\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    3902,\n/**/\n    3901,\n/**/\n    3900,\n/**/\n    3899,\n/**/\n    3898,\n/**/\n    3897,\n/**/\n    3896,\n/**/\n    3895,\n/**/\n    3894,\n/**/\n    3893,\n/**/\n    3892,\n/**/\n    3891,\n/**/\n    3890,\n/**/\n    3889,\n/**/\n    3888,\n/**/\n    3887,\n/**/\n    3886,\n/**/\n    3885,\n/**/\n    3884,\n/**/\n    3883,\n/**/\n    3882,\n/**/\n    3881,\n/**/\n    3880,\n/**/\n    3879,\n/**/\n    3878,\n/**/\n    3877,\n/**/\n    3876,\n/**/\n    3875,\n/**/\n    3874,\n/**/\n    3873,\n/**/\n    3872,\n/**/\n    3871,\n/**/\n    3870,\n/**/\n    3869,\n/**/\n    3868,\n/**/\n    3867,\n/**/\n    3866,\n/**/\n    3865,\n/**/\n    3864,\n/**/\n    3863,\n/**/\n    3862,\n/**/\n    3861,\n/**/\n    3860,\n/**/\n    3859,\n/**/\n    3858,\n/**/\n    3857,\n/**/\n    3856,\n/**/\n    3855,\n/**/\n    3854,\n/**/\n    3853,\n/**/\n    3852,\n/**/\n    3851,\n/**/\n    3850,\n/**/\n    3849,\n/**/\n    3848,\n/**/\n    3847,\n/**/\n    3846,\n/**/\n    3845,\n/**/\n    3844,\n/**/\n    3843,\n/**/\n    3842,\n/**/\n    3841,\n/**/\n    3840,\n/**/\n    3839,\n/**/\n    3838,\n/**/\n    3837,\n/**/\n    3836,\n/**/\n    3835,\n/**/\n    3834,\n/**/\n    3833,\n/**/\n    3832,\n/**/\n    3831,\n/**/\n    3830,\n/**/\n    3829,\n/**/\n    3828,\n/**/\n    3827,\n/**/\n    3826,\n/**/\n    3825,\n/**/\n    3824,\n/**/\n    3823,\n/**/\n    3822,\n/**/\n    3821,\n/**/\n    3820,\n/**/\n    3819,\n/**/\n    3818,\n/**/\n    3817,\n/**/\n    3816,\n/**/\n    3815,\n/**/\n    3814,\n/**/\n    3813,\n/**/\n    3812,\n/**/\n    3811,\n/**/\n    3810,\n/**/\n    3809,\n/**/\n    3808,\n/**/\n    3807,\n/**/\n    3806,\n/**/\n    3805,\n/**/\n    3804,\n/**/\n    3803,\n/**/\n    3802,\n/**/\n    3801,\n/**/\n    3800,\n/**/\n    3799,\n/**/\n    3798,\n/**/\n    3797,\n/**/\n    3796,\n/**/\n    3795,\n/**/\n    3794,\n/**/\n    3793,\n/**/\n    3792,\n/**/\n    3791,\n/**/\n    3790,\n/**/\n    3789,\n/**/\n    3788,\n/**/\n    3787,\n/**/\n    3786,\n/**/\n    3785,\n/**/\n    3784,\n/**/\n    3783,\n/**/\n    3782,\n/**/\n    3781,\n/**/\n    3780,\n/**/\n    3779,\n/**/\n    3778,\n/**/\n    3777,\n/**/\n    3776,\n/**/\n    3775,\n/**/\n    3774,\n/**/\n    3773,\n/**/\n    3772,\n/**/\n    3771,\n/**/\n    3770,\n/**/\n    3769,\n/**/\n    3768,\n/**/\n    3767,\n/**/\n    3766,\n/**/\n    3765,\n/**/\n    3764,\n/**/\n    3763,\n/**/\n    3762,\n/**/\n    3761,\n/**/\n    3760,\n/**/\n    3759,\n/**/\n    3758,\n/**/\n    3757,\n/**/\n    3756,\n/**/\n    3755,\n/**/\n    3754,\n/**/\n    3753,\n/**/\n    3752,\n/**/\n    3751,\n/**/\n    3750,\n/**/\n    3749,\n/**/\n    3748,\n/**/\n    3747,\n/**/\n    3746,\n/**/\n    3745,\n/**/\n    3744,\n/**/\n    3743,\n/**/\n    3742,\n/**/\n    3741,\n/**/\n    3740,\n/**/\n    3739,\n/**/\n    3738,\n/**/\n    3737,\n/**/\n    3736,\n/**/\n    3735,\n/**/\n    3734,\n/**/\n    3733,\n/**/\n    3732,\n/**/\n    3731,\n/**/\n    3730,\n/**/\n    3729,\n/**/\n    3728,\n/**/\n    3727,\n/**/\n    3726,\n/**/\n    3725,\n/**/\n    3724,\n/**/\n    3723,\n/**/\n    3722,\n/**/\n    3721,\n/**/\n    3720,\n/**/\n    3719,\n/**/\n    3718,\n/**/\n    3717,\n/**/\n    3716,\n/**/\n    3715,\n/**/\n    3714,\n/**/\n    3713,\n/**/\n    3712,\n/**/\n    3711,\n/**/\n    3710,\n/**/\n    3709,\n/**/\n    3708,\n/**/\n    3707,\n/**/\n    3706,\n/**/\n    3705,\n/**/\n    3704,\n/**/\n    3703,\n/**/\n    3702,\n/**/\n    3701,\n/**/\n    3700,\n/**/\n    3699,\n/**/\n    3698,\n/**/\n    3697,\n/**/\n    3696,\n/**/\n    3695,\n/**/\n    3694,\n/**/\n    3693,\n/**/\n    3692,\n/**/\n    3691,\n/**/\n    3690,\n/**/\n    3689,\n/**/\n    3688,\n/**/\n    3687,\n/**/\n    3686,\n/**/\n    3685,\n/**/\n    3684,\n/**/\n    3683,\n/**/\n    3682,\n/**/\n    3681,\n/**/\n    3680,\n/**/\n    3679,\n/**/\n    3678,\n/**/\n    3677,\n/**/\n    3676,\n/**/\n    3675,\n/**/\n    3674,\n/**/\n    3673,\n/**/\n    3672,\n/**/\n    3671,\n/**/\n    3670,\n/**/\n    3669,\n/**/\n    3668,\n/**/\n    3667,\n/**/\n    3666,\n/**/\n    3665,\n/**/\n    3664,\n/**/\n    3663,\n/**/\n    3662,\n/**/\n    3661,\n/**/\n    3660,\n/**/\n    3659,\n/**/\n    3658,\n/**/\n    3657,\n/**/\n    3656,\n/**/\n    3655,\n/**/\n    3654,\n/**/\n    3653,\n/**/\n    3652,\n/**/\n    3651,\n/**/\n    3650,\n/**/\n    3649,\n/**/\n    3648,\n/**/\n    3647,\n/**/\n    3646,\n/**/\n    3645,\n/**/\n    3644,\n/**/\n    3643,\n/**/\n    3642,\n/**/\n    3641,\n/**/\n    3640,\n/**/\n    3639,\n/**/\n    3638,\n/**/\n    3637,\n/**/\n    3636,\n/**/\n    3635,\n/**/\n    3634,\n/**/\n    3633,\n/**/\n    3632,\n/**/\n    3631,\n/**/\n    3630,\n/**/\n    3629,\n/**/\n    3628,\n/**/\n    3627,\n/**/\n    3626,\n/**/\n    3625,\n/**/\n    3624,\n/**/\n    3623,\n/**/\n    3622,\n/**/\n    3621,\n/**/\n    3620,\n/**/\n    3619,\n/**/\n    3618,\n/**/\n    3617,\n/**/\n    3616,\n/**/\n    3615,\n/**/\n    3614,\n/**/\n    3613,\n/**/\n    3612,\n/**/\n    3611,\n/**/\n    3610,\n/**/\n    3609,\n/**/\n    3608,\n/**/\n    3607,\n/**/\n    3606,\n/**/\n    3605,\n/**/\n    3604,\n/**/\n    3603,\n/**/\n    3602,\n/**/\n    3601,\n/**/\n    3600,\n/**/\n    3599,\n/**/\n    3598,\n/**/\n    3597,\n/**/\n    3596,\n/**/\n    3595,\n/**/\n    3594,\n/**/\n    3593,\n/**/\n    3592,\n/**/\n    3591,\n/**/\n    3590,\n/**/\n    3589,\n/**/\n    3588,\n/**/\n    3587,\n/**/\n    3586,\n/**/\n    3585,\n/**/\n    3584,\n/**/\n    3583,\n/**/\n    3582,\n/**/\n    3581,\n/**/\n    3580,\n/**/\n    3579,\n/**/\n    3578,\n/**/\n    3577,\n/**/\n    3576,\n/**/\n    3575,\n/**/\n    3574,\n/**/\n    3573,\n/**/\n    3572,\n/**/\n    3571,\n/**/\n    3570,\n/**/\n    3569,\n/**/\n    3568,\n/**/\n    3567,\n/**/\n    3566,\n/**/\n    3565,\n/**/\n    3564,\n/**/\n    3563,\n/**/\n    3562,\n/**/\n    3561,\n/**/\n    3560,\n/**/\n    3559,\n/**/\n    3558,\n/**/\n    3557,\n/**/\n    3556,\n/**/\n    3555,\n/**/\n    3554,\n/**/\n    3553,\n/**/\n    3552,\n/**/\n    3551,\n/**/\n    3550,\n/**/\n    3549,\n/**/\n    3548,\n/**/\n    3547,\n/**/\n    3546,\n/**/\n    3545,\n/**/\n    3544,\n/**/\n    3543,\n/**/\n    3542,\n/**/\n    3541,\n/**/\n    3540,\n/**/\n    3539,\n/**/\n    3538,\n/**/\n    3537,\n/**/\n    3536,\n/**/\n    3535,\n/**/\n    3534,\n/**/\n    3533,\n/**/\n    3532,\n/**/\n    3531,\n/**/\n    3530,\n/**/\n    3529,\n/**/\n    3528,\n/**/\n    3527,\n/**/\n    3526,\n/**/\n    3525,\n/**/\n    3524,\n/**/\n    3523,\n/**/\n    3522,\n/**/\n    3521,\n/**/\n    3520,\n/**/\n    3519,\n/**/\n    3518,\n/**/\n    3517,\n/**/\n    3516,\n/**/\n    3515,\n/**/\n    3514,\n/**/\n    3513,\n/**/\n    3512,\n/**/\n    3511,\n/**/\n    3510,\n/**/\n    3509,\n/**/\n    3508,\n/**/\n    3507,\n/**/\n    3506,\n/**/\n    3505,\n/**/\n    3504,\n/**/\n    3503,\n/**/\n    3502,\n/**/\n    3501,\n/**/\n    3500,\n/**/\n    3499,\n/**/\n    3498,\n/**/\n    3497,\n/**/\n    3496,\n/**/\n    3495,\n/**/\n    3494,\n/**/\n    3493,\n/**/\n    3492,\n/**/\n    3491,\n/**/\n    3490,\n/**/\n    3489,\n/**/\n    3488,\n/**/\n    3487,\n/**/\n    3486,\n/**/\n    3485,\n/**/\n    3484,\n/**/\n    3483,\n/**/\n    3482,\n/**/\n    3481,\n/**/\n    3480,\n/**/\n    3479,\n/**/\n    3478,\n/**/\n    3477,\n/**/\n    3476,\n/**/\n    3475,\n/**/\n    3474,\n/**/\n    3473,\n/**/\n    3472,\n/**/\n    3471,\n/**/\n    3470,\n/**/\n    3469,\n/**/\n    3468,\n/**/\n    3467,\n/**/\n    3466,\n/**/\n    3465,\n/**/\n    3464,\n/**/\n    3463,\n/**/\n    3462,\n/**/\n    3461,\n/**/\n    3460,\n/**/\n    3459,\n/**/\n    3458,\n/**/\n    3457,\n/**/\n    3456,\n/**/\n    3455,\n/**/\n    3454,\n/**/\n    3453,\n/**/\n    3452,\n/**/\n    3451,\n/**/\n    3450,\n/**/\n    3449,\n/**/\n    3448,\n/**/\n    3447,\n/**/\n    3446,\n/**/\n    3445,\n/**/\n    3444,\n/**/\n    3443,\n/**/\n    3442,\n/**/\n    3441,\n/**/\n    3440,\n/**/\n    3439,\n/**/\n    3438,\n/**/\n    3437,\n/**/\n    3436,\n/**/\n    3435,\n/**/\n    3434,\n/**/\n    3433,\n/**/\n    3432,\n/**/\n    3431,\n/**/\n    3430,\n/**/\n    3429,\n/**/\n    3428,\n/**/\n    3427,\n/**/\n    3426,\n/**/\n    3425,\n/**/\n    3424,\n/**/\n    3423,\n/**/\n    3422,\n/**/\n    3421,\n/**/\n    3420,\n/**/\n    3419,\n/**/\n    3418,\n/**/\n    3417,\n/**/\n    3416,\n/**/\n    3415,\n/**/\n    3414,\n/**/\n    3413,\n/**/\n    3412,\n/**/\n    3411,\n/**/\n    3410,\n/**/\n    3409,\n/**/\n    3408,\n/**/\n    3407,\n/**/\n    3406,\n/**/\n    3405,\n/**/\n    3404,\n/**/\n    3403,\n/**/\n    3402,\n/**/\n    3401,\n/**/\n    3400,\n/**/\n    3399,\n/**/\n    3398,\n/**/\n    3397,\n/**/\n    3396,\n/**/\n    3395,\n/**/\n    3394,\n/**/\n    3393,\n/**/\n    3392,\n/**/\n    3391,\n/**/\n    3390,\n/**/\n    3389,\n/**/\n    3388,\n/**/\n    3387,\n/**/\n    3386,\n/**/\n    3385,\n/**/\n    3384,\n/**/\n    3383,\n/**/\n    3382,\n/**/\n    3381,\n/**/\n    3380,\n/**/\n    3379,\n/**/\n    3378,\n/**/\n    3377,\n/**/\n    3376,\n/**/\n    3375,\n/**/\n    3374,\n/**/\n    3373,\n/**/\n    3372,\n/**/\n    3371,\n/**/\n    3370,\n/**/\n    3369,\n/**/\n    3368,\n/**/\n    3367,\n/**/\n    3366,\n/**/\n    3365,\n/**/\n    3364,\n/**/\n    3363,\n/**/\n    3362,\n/**/\n    3361,\n/**/\n    3360,\n/**/\n    3359,\n/**/\n    3358,\n/**/\n    3357,\n/**/\n    3356,\n/**/\n    3355,\n/**/\n    3354,\n/**/\n    3353,\n/**/\n    3352,\n/**/\n    3351,\n/**/\n    3350,\n/**/\n    3349,\n/**/\n    3348,\n/**/\n    3347,\n/**/\n    3346,\n/**/\n    3345,\n/**/\n    3344,\n/**/\n    3343,\n/**/\n    3342,\n/**/\n    3341,\n/**/\n    3340,\n/**/\n    3339,\n/**/\n    3338,\n/**/\n    3337,\n/**/\n    3336,\n/**/\n    3335,\n/**/\n    3334,\n/**/\n    3333,\n/**/\n    3332,\n/**/\n    3331,\n/**/\n    3330,\n/**/\n    3329,\n/**/\n    3328,\n/**/\n    3327,\n/**/\n    3326,\n/**/\n    3325,\n/**/\n    3324,\n/**/\n    3323,\n/**/\n    3322,\n/**/\n    3321,\n/**/\n    3320,\n/**/\n    3319,\n/**/\n    3318,\n/**/\n    3317,\n/**/\n    3316,\n/**/\n    3315,\n/**/\n    3314,\n/**/\n    3313,\n/**/\n    3312,\n/**/\n    3311,\n/**/\n    3310,\n/**/\n    3309,\n/**/\n    3308,\n/**/\n    3307,\n/**/\n    3306,\n/**/\n    3305,\n/**/\n    3304,\n/**/\n    3303,\n/**/\n    3302,\n/**/\n    3301,\n/**/\n    3300,\n/**/\n    3299,\n/**/\n    3298,\n/**/\n    3297,\n/**/\n    3296,\n/**/\n    3295,\n/**/\n    3294,\n/**/\n    3293,\n/**/\n    3292,\n/**/\n    3291,\n/**/\n    3290,\n/**/\n    3289,\n/**/\n    3288,\n/**/\n    3287,\n/**/\n    3286,\n/**/\n    3285,\n/**/\n    3284,\n/**/\n    3283,\n/**/\n    3282,\n/**/\n    3281,\n/**/\n    3280,\n/**/\n    3279,\n/**/\n    3278,\n/**/\n    3277,\n/**/\n    3276,\n/**/\n    3275,\n/**/\n    3274,\n/**/\n    3273,\n/**/\n    3272,\n/**/\n    3271,\n/**/\n    3270,\n/**/\n    3269,\n/**/\n    3268,\n/**/\n    3267,\n/**/\n    3266,\n/**/\n    3265,\n/**/\n    3264,\n/**/\n    3263,\n/**/\n    3262,\n/**/\n    3261,\n/**/\n    3260,\n/**/\n    3259,\n/**/\n    3258,\n/**/\n    3257,\n/**/\n    3256,\n/**/\n    3255,\n/**/\n    3254,\n/**/\n    3253,\n/**/\n    3252,\n/**/\n    3251,\n/**/\n    3250,\n/**/\n    3249,\n/**/\n    3248,\n/**/\n    3247,\n/**/\n    3246,\n/**/\n    3245,\n/**/\n    3244,\n/**/\n    3243,\n/**/\n    3242,\n/**/\n    3241,\n/**/\n    3240,\n/**/\n    3239,\n/**/\n    3238,\n/**/\n    3237,\n/**/\n    3236,\n/**/\n    3235,\n/**/\n    3234,\n/**/\n    3233,\n/**/\n    3232,\n/**/\n    3231,\n/**/\n    3230,\n/**/\n    3229,\n/**/\n    3228,\n/**/\n    3227,\n/**/\n    3226,\n/**/\n    3225,\n/**/\n    3224,\n/**/\n    3223,\n/**/\n    3222,\n/**/\n    3221,\n/**/\n    3220,\n/**/\n    3219,\n/**/\n    3218,\n/**/\n    3217,\n/**/\n    3216,\n/**/\n    3215,\n/**/\n    3214,\n/**/\n    3213,\n/**/\n    3212,\n/**/\n    3211,\n/**/\n    3210,\n/**/\n    3209,\n/**/\n    3208,\n/**/\n    3207,\n/**/\n    3206,\n/**/\n    3205,\n/**/\n    3204,\n/**/\n    3203,\n/**/\n    3202,\n/**/\n    3201,\n/**/\n    3200,\n/**/\n    3199,\n/**/\n    3198,\n/**/\n    3197,\n/**/\n    3196,\n/**/\n    3195,\n/**/\n    3194,\n/**/\n    3193,\n/**/\n    3192,\n/**/\n    3191,\n/**/\n    3190,\n/**/\n    3189,\n/**/\n    3188,\n/**/\n    3187,\n/**/\n    3186,\n/**/\n    3185,\n/**/\n    3184,\n/**/\n    3183,\n/**/\n    3182,\n/**/\n    3181,\n/**/\n    3180,\n/**/\n    3179,\n/**/\n    3178,\n/**/\n    3177,\n/**/\n    3176,\n/**/\n    3175,\n/**/\n    3174,\n/**/\n    3173,\n/**/\n    3172,\n/**/\n    3171,\n/**/\n    3170,\n/**/\n    3169,\n/**/\n    3168,\n/**/\n    3167,\n/**/\n    3166,\n/**/\n    3165,\n/**/\n    3164,\n/**/\n    3163,\n/**/\n    3162,\n/**/\n    3161,\n/**/\n    3160,\n/**/\n    3159,\n/**/\n    3158,\n/**/\n    3157,\n/**/\n    3156,\n/**/\n    3155,\n/**/\n    3154,\n/**/\n    3153,\n/**/\n    3152,\n/**/\n    3151,\n/**/\n    3150,\n/**/\n    3149,\n/**/\n    3148,\n/**/\n    3147,\n/**/\n    3146,\n/**/\n    3145,\n/**/\n    3144,\n/**/\n    3143,\n/**/\n    3142,\n/**/\n    3141,\n/**/\n    3140,\n/**/\n    3139,\n/**/\n    3138,\n/**/\n    3137,\n/**/\n    3136,\n/**/\n    3135,\n/**/\n    3134,\n/**/\n    3133,\n/**/\n    3132,\n/**/\n    3131,\n/**/\n    3130,\n/**/\n    3129,\n/**/\n    3128,\n/**/\n    3127,\n/**/\n    3126,\n/**/\n    3125,\n/**/\n    3124,\n/**/\n    3123,\n/**/\n    3122,\n/**/\n    3121,\n/**/\n    3120,\n/**/\n    3119,\n/**/\n    3118,\n/**/\n    3117,\n/**/\n    3116,\n/**/\n    3115,\n/**/\n    3114,\n/**/\n    3113,\n/**/\n    3112,\n/**/\n    3111,\n/**/\n    3110,\n/**/\n    3109,\n/**/\n    3108,\n/**/\n    3107,\n/**/\n    3106,\n/**/\n    3105,\n/**/\n    3104,\n/**/\n    3103,\n/**/\n    3102,\n/**/\n    3101,\n/**/\n    3100,\n/**/\n    3099,\n/**/\n    3098,\n/**/\n    3097,\n/**/\n    3096,\n/**/\n    3095,\n/**/\n    3094,\n/**/\n    3093,\n/**/\n    3092,\n/**/\n    3091,\n/**/\n    3090,\n/**/\n    3089,\n/**/\n    3088,\n/**/\n    3087,\n/**/\n    3086,\n/**/\n    3085,\n/**/\n    3084,\n/**/\n    3083,\n/**/\n    3082,\n/**/\n    3081,\n/**/\n    3080,\n/**/\n    3079,\n/**/\n    3078,\n/**/\n    3077,\n/**/\n    3076,\n/**/\n    3075,\n/**/\n    3074,\n/**/\n    3073,\n/**/\n    3072,\n/**/\n    3071,\n/**/\n    3070,\n/**/\n    3069,\n/**/\n    3068,\n/**/\n    3067,\n/**/\n    3066,\n/**/\n    3065,\n/**/\n    3064,\n/**/\n    3063,\n/**/\n    3062,\n/**/\n    3061,\n/**/\n    3060,\n/**/\n    3059,\n/**/\n    3058,\n/**/\n    3057,\n/**/\n    3056,\n/**/\n    3055,\n/**/\n    3054,\n/**/\n    3053,\n/**/\n    3052,\n/**/\n    3051,\n/**/\n    3050,\n/**/\n    3049,\n/**/\n    3048,\n/**/\n    3047,\n/**/\n    3046,\n/**/\n    3045,\n/**/\n    3044,\n/**/\n    3043,\n/**/\n    3042,\n/**/\n    3041,\n/**/\n    3040,\n/**/\n    3039,\n/**/\n    3038,\n/**/\n    3037,\n/**/\n    3036,\n/**/\n    3035,\n/**/\n    3034,\n/**/\n    3033,\n/**/\n    3032,\n/**/\n    3031,\n/**/\n    3030,\n/**/\n    3029,\n/**/\n    3028,\n/**/\n    3027,\n/**/\n    3026,\n/**/\n    3025,\n/**/\n    3024,\n/**/\n    3023,\n/**/\n    3022,\n/**/\n    3021,\n/**/\n    3020,\n/**/\n    3019,\n/**/\n    3018,\n/**/\n    3017,\n/**/\n    3016,\n/**/\n    3015,\n/**/\n    3014,\n/**/\n    3013,\n/**/\n    3012,\n/**/\n    3011,\n/**/\n    3010,\n/**/\n    3009,\n/**/\n    3008,\n/**/\n    3007,\n/**/\n    3006,\n/**/\n    3005,\n/**/\n    3004,\n/**/\n    3003,\n/**/\n    3002,\n/**/\n    3001,\n/**/\n    3000,\n/**/\n    2999,\n/**/\n    2998,\n/**/\n    2997,\n/**/\n    2996,\n/**/\n    2995,\n/**/\n    2994,\n/**/\n    2993,\n/**/\n    2992,\n/**/\n    2991,\n/**/\n    2990,\n/**/\n    2989,\n/**/\n    2988,\n/**/\n    2987,\n/**/\n    2986,\n/**/\n    2985,\n/**/\n    2984,\n/**/\n    2983,\n/**/\n    2982,\n/**/\n    2981,\n/**/\n    2980,\n/**/\n    2979,\n/**/\n    2978,\n/**/\n    2977,\n/**/\n    2976,\n/**/\n    2975,\n/**/\n    2974,\n/**/\n    2973,\n/**/\n    2972,\n/**/\n    2971,\n/**/\n    2970,\n/**/\n    2969,\n/**/\n    2968,\n/**/\n    2967,\n/**/\n    2966,\n/**/\n    2965,\n/**/\n    2964,\n/**/\n    2963,\n/**/\n    2962,\n/**/\n    2961,\n/**/\n    2960,\n/**/\n    2959,\n/**/\n    2958,\n/**/\n    2957,\n/**/\n    2956,\n/**/\n    2955,\n/**/\n    2954,\n/**/\n    2953,\n/**/\n    2952,\n/**/\n    2951,\n/**/\n    2950,\n/**/\n    2949,\n/**/\n    2948,\n/**/\n    2947,\n/**/\n    2946,\n/**/\n    2945,\n/**/\n    2944,\n/**/\n    2943,\n/**/\n    2942,\n/**/\n    2941,\n/**/\n    2940,\n/**/\n    2939,\n/**/\n    2938,\n/**/\n    2937,\n/**/\n    2936,\n/**/\n    2935,\n/**/\n    2934,\n/**/\n    2933,\n/**/\n    2932,\n/**/\n    2931,\n/**/\n    2930,\n/**/\n    2929,\n/**/\n    2928,\n/**/\n    2927,\n/**/\n    2926,\n/**/\n    2925,\n/**/\n    2924,\n/**/\n    2923,\n/**/\n    2922,\n/**/\n    2921,\n/**/\n    2920,\n/**/\n    2919,\n/**/\n    2918,\n/**/\n    2917,\n/**/\n    2916,\n/**/\n    2915,\n/**/\n    2914,\n/**/\n    2913,\n/**/\n    2912,\n/**/\n    2911,\n/**/\n    2910,\n/**/\n    2909,\n/**/\n    2908,\n/**/\n    2907,\n/**/\n    2906,\n/**/\n    2905,\n/**/\n    2904,\n/**/\n    2903,\n/**/\n    2902,\n/**/\n    2901,\n/**/\n    2900,\n/**/\n    2899,\n/**/\n    2898,\n/**/\n    2897,\n/**/\n    2896,\n/**/\n    2895,\n/**/\n    2894,\n/**/\n    2893,\n/**/\n    2892,\n/**/\n    2891,\n/**/\n    2890,\n/**/\n    2889,\n/**/\n    2888,\n/**/\n    2887,\n/**/\n    2886,\n/**/\n    2885,\n/**/\n    2884,\n/**/\n    2883,\n/**/\n    2882,\n/**/\n    2881,\n/**/\n    2880,\n/**/\n    2879,\n/**/\n    2878,\n/**/\n    2877,\n/**/\n    2876,\n/**/\n    2875,\n/**/\n    2874,\n/**/\n    2873,\n/**/\n    2872,\n/**/\n    2871,\n/**/\n    2870,\n/**/\n    2869,\n/**/\n    2868,\n/**/\n    2867,\n/**/\n    2866,\n/**/\n    2865,\n/**/\n    2864,\n/**/\n    2863,\n/**/\n    2862,\n/**/\n    2861,\n/**/\n    2860,\n/**/\n    2859,\n/**/\n    2858,\n/**/\n    2857,\n/**/\n    2856,\n/**/\n    2855,\n/**/\n    2854,\n/**/\n    2853,\n/**/\n    2852,\n/**/\n    2851,\n/**/\n    2850,\n/**/\n    2849,\n/**/\n    2848,\n/**/\n    2847,\n/**/\n    2846,\n/**/\n    2845,\n/**/\n    2844,\n/**/\n    2843,\n/**/\n    2842,\n/**/\n    2841,\n/**/\n    2840,\n/**/\n    2839,\n/**/\n    2838,\n/**/\n    2837,\n/**/\n    2836,\n/**/\n    2835,\n/**/\n    2834,\n/**/\n    2833,\n/**/\n    2832,\n/**/\n    2831,\n/**/\n    2830,\n/**/\n    2829,\n/**/\n    2828,\n/**/\n    2827,\n/**/\n    2826,\n/**/\n    2825,\n/**/\n    2824,\n/**/\n    2823,\n/**/\n    2822,\n/**/\n    2821,\n/**/\n    2820,\n/**/\n    2819,\n/**/\n    2818,\n/**/\n    2817,\n/**/\n    2816,\n/**/\n    2815,\n/**/\n    2814,\n/**/\n    2813,\n/**/\n    2812,\n/**/\n    2811,\n/**/\n    2810,\n/**/\n    2809,\n/**/\n    2808,\n/**/\n    2807,\n/**/\n    2806,\n/**/\n    2805,\n/**/\n    2804,\n/**/\n    2803,\n/**/\n    2802,\n/**/\n    2801,\n/**/\n    2800,\n/**/\n    2799,\n/**/\n    2798,\n/**/\n    2797,\n/**/\n    2796,\n/**/\n    2795,\n/**/\n    2794,\n/**/\n    2793,\n/**/\n    2792,\n/**/\n    2791,\n/**/\n    2790,\n/**/\n    2789,\n/**/\n    2788,\n/**/\n    2787,\n/**/\n    2786,\n/**/\n    2785,\n/**/\n    2784,\n/**/\n    2783,\n/**/\n    2782,\n/**/\n    2781,\n/**/\n    2780,\n/**/\n    2779,\n/**/\n    2778,\n/**/\n    2777,\n/**/\n    2776,\n/**/\n    2775,\n/**/\n    2774,\n/**/\n    2773,\n/**/\n    2772,\n/**/\n    2771,\n/**/\n    2770,\n/**/\n    2769,\n/**/\n    2768,\n/**/\n    2767,\n/**/\n    2766,\n/**/\n    2765,\n/**/\n    2764,\n/**/\n    2763,\n/**/\n    2762,\n/**/\n    2761,\n/**/\n    2760,\n/**/\n    2759,\n/**/\n    2758,\n/**/\n    2757,\n/**/\n    2756,\n/**/\n    2755,\n/**/\n    2754,\n/**/\n    2753,\n/**/\n    2752,\n/**/\n    2751,\n/**/\n    2750,\n/**/\n    2749,\n/**/\n    2748,\n/**/\n    2747,\n/**/\n    2746,\n/**/\n    2745,\n/**/\n    2744,\n/**/\n    2743,\n/**/\n    2742,\n/**/\n    2741,\n/**/\n    2740,\n/**/\n    2739,\n/**/\n    2738,\n/**/\n    2737,\n/**/\n    2736,\n/**/\n    2735,\n/**/\n    2734,\n/**/\n    2733,\n/**/\n    2732,\n/**/\n    2731,\n/**/\n    2730,\n/**/\n    2729,\n/**/\n    2728,\n/**/\n    2727,\n/**/\n    2726,\n/**/\n    2725,\n/**/\n    2724,\n/**/\n    2723,\n/**/\n    2722,\n/**/\n    2721,\n/**/\n    2720,\n/**/\n    2719,\n/**/\n    2718,\n/**/\n    2717,\n/**/\n    2716,\n/**/\n    2715,\n/**/\n    2714,\n/**/\n    2713,\n/**/\n    2712,\n/**/\n    2711,\n/**/\n    2710,\n/**/\n    2709,\n/**/\n    2708,\n/**/\n    2707,\n/**/\n    2706,\n/**/\n    2705,\n/**/\n    2704,\n/**/\n    2703,\n/**/\n    2702,\n/**/\n    2701,\n/**/\n    2700,\n/**/\n    2699,\n/**/\n    2698,\n/**/\n    2697,\n/**/\n    2696,\n/**/\n    2695,\n/**/\n    2694,\n/**/\n    2693,\n/**/\n    2692,\n/**/\n    2691,\n/**/\n    2690,\n/**/\n    2689,\n/**/\n    2688,\n/**/\n    2687,\n/**/\n    2686,\n/**/\n    2685,\n/**/\n    2684,\n/**/\n    2683,\n/**/\n    2682,\n/**/\n    2681,\n/**/\n    2680,\n/**/\n    2679,\n/**/\n    2678,\n/**/\n    2677,\n/**/\n    2676,\n/**/\n    2675,\n/**/\n    2674,\n/**/\n    2673,\n/**/\n    2672,\n/**/\n    2671,\n/**/\n    2670,\n/**/\n    2669,\n/**/\n    2668,\n/**/\n    2667,\n/**/\n    2666,\n/**/\n    2665,\n/**/\n    2664,\n/**/\n    2663,\n/**/\n    2662,\n/**/\n    2661,\n/**/\n    2660,\n/**/\n    2659,\n/**/\n    2658,\n/**/\n    2657,\n/**/\n    2656,\n/**/\n    2655,\n/**/\n    2654,\n/**/\n    2653,\n/**/\n    2652,\n/**/\n    2651,\n/**/\n    2650,\n/**/\n    2649,\n/**/\n    2648,\n/**/\n    2647,\n/**/\n    2646,\n/**/\n    2645,\n/**/\n    2644,\n/**/\n    2643,\n/**/\n    2642,\n/**/\n    2641,\n/**/\n    2640,\n/**/\n    2639,\n/**/\n    2638,\n/**/\n    2637,\n/**/\n    2636,\n/**/\n    2635,\n/**/\n    2634,\n/**/\n    2633,\n/**/\n    2632,\n/**/\n    2631,\n/**/\n    2630,\n/**/\n    2629,\n/**/\n    2628,\n/**/\n    2627,\n/**/\n    2626,\n/**/\n    2625,\n/**/\n    2624,\n/**/\n    2623,\n/**/\n    2622,\n/**/\n    2621,\n/**/\n    2620,\n/**/\n    2619,\n/**/\n    2618,\n/**/\n    2617,\n/**/\n    2616,\n/**/\n    2615,\n/**/\n    2614,\n/**/\n    2613,\n/**/\n    2612,\n/**/\n    2611,\n/**/\n    2610,\n/**/\n    2609,\n/**/\n    2608,\n/**/\n    2607,\n/**/\n    2606,\n/**/\n    2605,\n/**/\n    2604,\n/**/\n    2603,\n/**/\n    2602,\n/**/\n    2601,\n/**/\n    2600,\n/**/\n    2599,\n/**/\n    2598,\n/**/\n    2597,\n/**/\n    2596,\n/**/\n    2595,\n/**/\n    2594,\n/**/\n    2593,\n/**/\n    2592,\n/**/\n    2591,\n/**/\n    2590,\n/**/\n    2589,\n/**/\n    2588,\n/**/\n    2587,\n/**/\n    2586,\n/**/\n    2585,\n/**/\n    2584,\n/**/\n    2583,\n/**/\n    2582,\n/**/\n    2581,\n/**/\n    2580,\n/**/\n    2579,\n/**/\n    2578,\n/**/\n    2577,\n/**/\n    2576,\n/**/\n    2575,\n/**/\n    2574,\n/**/\n    2573,\n/**/\n    2572,\n/**/\n    2571,\n/**/\n    2570,\n/**/\n    2569,\n/**/\n    2568,\n/**/\n    2567,\n/**/\n    2566,\n/**/\n    2565,\n/**/\n    2564,\n/**/\n    2563,\n/**/\n    2562,\n/**/\n    2561,\n/**/\n    2560,\n/**/\n    2559,\n/**/\n    2558,\n/**/\n    2557,\n/**/\n    2556,\n/**/\n    2555,\n/**/\n    2554,\n/**/\n    2553,\n/**/\n    2552,\n/**/\n    2551,\n/**/\n    2550,\n/**/\n    2549,\n/**/\n    2548,\n/**/\n    2547,\n/**/\n    2546,\n/**/\n    2545,\n/**/\n    2544,\n/**/\n    2543,\n/**/\n    2542,\n/**/\n    2541,\n/**/\n    2540,\n/**/\n    2539,\n/**/\n    2538,\n/**/\n    2537,\n/**/\n    2536,\n/**/\n    2535,\n/**/\n    2534,\n/**/\n    2533,\n/**/\n    2532,\n/**/\n    2531,\n/**/\n    2530,\n/**/\n    2529,\n/**/\n    2528,\n/**/\n    2527,\n/**/\n    2526,\n/**/\n    2525,\n/**/\n    2524,\n/**/\n    2523,\n/**/\n    2522,\n/**/\n    2521,\n/**/\n    2520,\n/**/\n    2519,\n/**/\n    2518,\n/**/\n    2517,\n/**/\n    2516,\n/**/\n    2515,\n/**/\n    2514,\n/**/\n    2513,\n/**/\n    2512,\n/**/\n    2511,\n/**/\n    2510,\n/**/\n    2509,\n/**/\n    2508,\n/**/\n    2507,\n/**/\n    2506,\n/**/\n    2505,\n/**/\n    2504,\n/**/\n    2503,\n/**/\n    2502,\n/**/\n    2501,\n/**/\n    2500,\n/**/\n    2499,\n/**/\n    2498,\n/**/\n    2497,\n/**/\n    2496,\n/**/\n    2495,\n/**/\n    2494,\n/**/\n    2493,\n/**/\n    2492,\n/**/\n    2491,\n/**/\n    2490,\n/**/\n    2489,\n/**/\n    2488,\n/**/\n    2487,\n/**/\n    2486,\n/**/\n    2485,\n/**/\n    2484,\n/**/\n    2483,\n/**/\n    2482,\n/**/\n    2481,\n/**/\n    2480,\n/**/\n    2479,\n/**/\n    2478,\n/**/\n    2477,\n/**/\n    2476,\n/**/\n    2475,\n/**/\n    2474,\n/**/\n    2473,\n/**/\n    2472,\n/**/\n    2471,\n/**/\n    2470,\n/**/\n    2469,\n/**/\n    2468,\n/**/\n    2467,\n/**/\n    2466,\n/**/\n    2465,\n/**/\n    2464,\n/**/\n    2463,\n/**/\n    2462,\n/**/\n    2461,\n/**/\n    2460,\n/**/\n    2459,\n/**/\n    2458,\n/**/\n    2457,\n/**/\n    2456,\n/**/\n    2455,\n/**/\n    2454,\n/**/\n    2453,\n/**/\n    2452,\n/**/\n    2451,\n/**/\n    2450,\n/**/\n    2449,\n/**/\n    2448,\n/**/\n    2447,\n/**/\n    2446,\n/**/\n    2445,\n/**/\n    2444,\n/**/\n    2443,\n/**/\n    2442,\n/**/\n    2441,\n/**/\n    2440,\n/**/\n    2439,\n/**/\n    2438,\n/**/\n    2437,\n/**/\n    2436,\n/**/\n    2435,\n/**/\n    2434,\n/**/\n    2433,\n/**/\n    2432,\n/**/\n    2431,\n/**/\n    2430,\n/**/\n    2429,\n/**/\n    2428,\n/**/\n    2427,\n/**/\n    2426,\n/**/\n    2425,\n/**/\n    2424,\n/**/\n    2423,\n/**/\n    2422,\n/**/\n    2421,\n/**/\n    2420,\n/**/\n    2419,\n/**/\n    2418,\n/**/\n    2417,\n/**/\n    2416,\n/**/\n    2415,\n/**/\n    2414,\n/**/\n    2413,\n/**/\n    2412,\n/**/\n    2411,\n/**/\n    2410,\n/**/\n    2409,\n/**/\n    2408,\n/**/\n    2407,\n/**/\n    2406,\n/**/\n    2405,\n/**/\n    2404,\n/**/\n    2403,\n/**/\n    2402,\n/**/\n    2401,\n/**/\n    2400,\n/**/\n    2399,\n/**/\n    2398,\n/**/\n    2397,\n/**/\n    2396,\n/**/\n    2395,\n/**/\n    2394,\n/**/\n    2393,\n/**/\n    2392,\n/**/\n    2391,\n/**/\n    2390,\n/**/\n    2389,\n/**/\n    2388,\n/**/\n    2387,\n/**/\n    2386,\n/**/\n    2385,\n/**/\n    2384,\n/**/\n    2383,\n/**/\n    2382,\n/**/\n    2381,\n/**/\n    2380,\n/**/\n    2379,\n/**/\n    2378,\n/**/\n    2377,\n/**/\n    2376,\n/**/\n    2375,\n/**/\n    2374,\n/**/\n    2373,\n/**/\n    2372,\n/**/\n    2371,\n/**/\n    2370,\n/**/\n    2369,\n/**/\n    2368,\n/**/\n    2367,\n/**/\n    2366,\n/**/\n    2365,\n/**/\n    2364,\n/**/\n    2363,\n/**/\n    2362,\n/**/\n    2361,\n/**/\n    2360,\n/**/\n    2359,\n/**/\n    2358,\n/**/\n    2357,\n/**/\n    2356,\n/**/\n    2355,\n/**/\n    2354,\n/**/\n    2353,\n/**/\n    2352,\n/**/\n    2351,\n/**/\n    2350,\n/**/\n    2349,\n/**/\n    2348,\n/**/\n    2347,\n/**/\n    2346,\n/**/\n    2345,\n/**/\n    2344,\n/**/\n    2343,\n/**/\n    2342,\n/**/\n    2341,\n/**/\n    2340,\n/**/\n    2339,\n/**/\n    2338,\n/**/\n    2337,\n/**/\n    2336,\n/**/\n    2335,\n/**/\n    2334,\n/**/\n    2333,\n/**/\n    2332,\n/**/\n    2331,\n/**/\n    2330,\n/**/\n    2329,\n/**/\n    2328,\n/**/\n    2327,\n/**/\n    2326,\n/**/\n    2325,\n/**/\n    2324,\n/**/\n    2323,\n/**/\n    2322,\n/**/\n    2321,\n/**/\n    2320,\n/**/\n    2319,\n/**/\n    2318,\n/**/\n    2317,\n/**/\n    2316,\n/**/\n    2315,\n/**/\n    2314,\n/**/\n    2313,\n/**/\n    2312,\n/**/\n    2311,\n/**/\n    2310,\n/**/\n    2309,\n/**/\n    2308,\n/**/\n    2307,\n/**/\n    2306,\n/**/\n    2305,\n/**/\n    2304,\n/**/\n    2303,\n/**/\n    2302,\n/**/\n    2301,\n/**/\n    2300,\n/**/\n    2299,\n/**/\n    2298,\n/**/\n    2297,\n/**/\n    2296,\n/**/\n    2295,\n/**/\n    2294,\n/**/\n    2293,\n/**/\n    2292,\n/**/\n    2291,\n/**/\n    2290,\n/**/\n    2289,\n/**/\n    2288,\n/**/\n    2287,\n/**/\n    2286,\n/**/\n    2285,\n/**/\n    2284,\n/**/\n    2283,\n/**/\n    2282,\n/**/\n    2281,\n/**/\n    2280,\n/**/\n    2279,\n/**/\n    2278,\n/**/\n    2277,\n/**/\n    2276,\n/**/\n    2275,\n/**/\n    2274,\n/**/\n    2273,\n/**/\n    2272,\n/**/\n    2271,\n/**/\n    2270,\n/**/\n    2269,\n/**/\n    2268,\n/**/\n    2267,\n/**/\n    2266,\n/**/\n    2265,\n/**/\n    2264,\n/**/\n    2263,\n/**/\n    2262,\n/**/\n    2261,\n/**/\n    2260,\n/**/\n    2259,\n/**/\n    2258,\n/**/\n    2257,\n/**/\n    2256,\n/**/\n    2255,\n/**/\n    2254,\n/**/\n    2253,\n/**/\n    2252,\n/**/\n    2251,\n/**/\n    2250,\n/**/\n    2249,\n/**/\n    2248,\n/**/\n    2247,\n/**/\n    2246,\n/**/\n    2245,\n/**/\n    2244,\n/**/\n    2243,\n/**/\n    2242,\n/**/\n    2241,\n/**/\n    2240,\n/**/\n    2239,\n/**/\n    2238,\n/**/\n    2237,\n/**/\n    2236,\n/**/\n    2235,\n/**/\n    2234,\n/**/\n    2233,\n/**/\n    2232,\n/**/\n    2231,\n/**/\n    2230,\n/**/\n    2229,\n/**/\n    2228,\n/**/\n    2227,\n/**/\n    2226,\n/**/\n    2225,\n/**/\n    2224,\n/**/\n    2223,\n/**/\n    2222,\n/**/\n    2221,\n/**/\n    2220,\n/**/\n    2219,\n/**/\n    2218,\n/**/\n    2217,\n/**/\n    2216,\n/**/\n    2215,\n/**/\n    2214,\n/**/\n    2213,\n/**/\n    2212,\n/**/\n    2211,\n/**/\n    2210,\n/**/\n    2209,\n/**/\n    2208,\n/**/\n    2207,\n/**/\n    2206,\n/**/\n    2205,\n/**/\n    2204,\n/**/\n    2203,\n/**/\n    2202,\n/**/\n    2201,\n/**/\n    2200,\n/**/\n    2199,\n/**/\n    2198,\n/**/\n    2197,\n/**/\n    2196,\n/**/\n    2195,\n/**/\n    2194,\n/**/\n    2193,\n/**/\n    2192,\n/**/\n    2191,\n/**/\n    2190,\n/**/\n    2189,\n/**/\n    2188,\n/**/\n    2187,\n/**/\n    2186,\n/**/\n    2185,\n/**/\n    2184,\n/**/\n    2183,\n/**/\n    2182,\n/**/\n    2181,\n/**/\n    2180,\n/**/\n    2179,\n/**/\n    2178,\n/**/\n    2177,\n/**/\n    2176,\n/**/\n    2175,\n/**/\n    2174,\n/**/\n    2173,\n/**/\n    2172,\n/**/\n    2171,\n/**/\n    2170,\n/**/\n    2169,\n/**/\n    2168,\n/**/\n    2167,\n/**/\n    2166,\n/**/\n    2165,\n/**/\n    2164,\n/**/\n    2163,\n/**/\n    2162,\n/**/\n    2161,\n/**/\n    2160,\n/**/\n    2159,\n/**/\n    2158,\n/**/\n    2157,\n/**/\n    2156,\n/**/\n    2155,\n/**/\n    2154,\n/**/\n    2153,\n/**/\n    2152,\n/**/\n    2151,\n/**/\n    2150,\n/**/\n    2149,\n/**/\n    2148,\n/**/\n    2147,\n/**/\n    2146,\n/**/\n    2145,\n/**/\n    2144,\n/**/\n    2143,\n/**/\n    2142,\n/**/\n    2141,\n/**/\n    2140,\n/**/\n    2139,\n/**/\n    2138,\n/**/\n    2137,\n/**/\n    2136,\n/**/\n    2135,\n/**/\n    2134,\n/**/\n    2133,\n/**/\n    2132,\n/**/\n    2131,\n/**/\n    2130,\n/**/\n    2129,\n/**/\n    2128,\n/**/\n    2127,\n/**/\n    2126,\n/**/\n    2125,\n/**/\n    2124,\n/**/\n    2123,\n/**/\n    2122,\n/**/\n    2121,\n/**/\n    2120,\n/**/\n    2119,\n/**/\n    2118,\n/**/\n    2117,\n/**/\n    2116,\n/**/\n    2115,\n/**/\n    2114,\n/**/\n    2113,\n/**/\n    2112,\n/**/\n    2111,\n/**/\n    2110,\n/**/\n    2109,\n/**/\n    2108,\n/**/\n    2107,\n/**/\n    2106,\n/**/\n    2105,\n/**/\n    2104,\n/**/\n    2103,\n/**/\n    2102,\n/**/\n    2101,\n/**/\n    2100,\n/**/\n    2099,\n/**/\n    2098,\n/**/\n    2097,\n/**/\n    2096,\n/**/\n    2095,\n/**/\n    2094,\n/**/\n    2093,\n/**/\n    2092,\n/**/\n    2091,\n/**/\n    2090,\n/**/\n    2089,\n/**/\n    2088,\n/**/\n    2087,\n/**/\n    2086,\n/**/\n    2085,\n/**/\n    2084,\n/**/\n    2083,\n/**/\n    2082,\n/**/\n    2081,\n/**/\n    2080,\n/**/\n    2079,\n/**/\n    2078,\n/**/\n    2077,\n/**/\n    2076,\n/**/\n    2075,\n/**/\n    2074,\n/**/\n    2073,\n/**/\n    2072,\n/**/\n    2071,\n/**/\n    2070,\n/**/\n    2069,\n/**/\n    2068,\n/**/\n    2067,\n/**/\n    2066,\n/**/\n    2065,\n/**/\n    2064,\n/**/\n    2063,\n/**/\n    2062,\n/**/\n    2061,\n/**/\n    2060,\n/**/\n    2059,\n/**/\n    2058,\n/**/\n    2057,\n/**/\n    2056,\n/**/\n    2055,\n/**/\n    2054,\n/**/\n    2053,\n/**/\n    2052,\n/**/\n    2051,\n/**/\n    2050,\n/**/\n    2049,\n/**/\n    2048,\n/**/\n    2047,\n/**/\n    2046,\n/**/\n    2045,\n/**/\n    2044,\n/**/\n    2043,\n/**/\n    2042,\n/**/\n    2041,\n/**/\n    2040,\n/**/\n    2039,\n/**/\n    2038,\n/**/\n    2037,\n/**/\n    2036,\n/**/\n    2035,\n/**/\n    2034,\n/**/\n    2033,\n/**/\n    2032,\n/**/\n    2031,\n/**/\n    2030,\n/**/\n    2029,\n/**/\n    2028,\n/**/\n    2027,\n/**/\n    2026,\n/**/\n    2025,\n/**/\n    2024,\n/**/\n    2023,\n/**/\n    2022,\n/**/\n    2021,\n/**/\n    2020,\n/**/\n    2019,\n/**/\n    2018,\n/**/\n    2017,\n/**/\n    2016,\n/**/\n    2015,\n/**/\n    2014,\n/**/\n    2013,\n/**/\n    2012,\n/**/\n    2011,\n/**/\n    2010,\n/**/\n    2009,\n/**/\n    2008,\n/**/\n    2007,\n/**/\n    2006,\n/**/\n    2005,\n/**/\n    2004,\n/**/\n    2003,\n/**/\n    2002,\n/**/\n    2001,\n/**/\n    2000,\n/**/\n    1999,\n/**/\n    1998,\n/**/\n    1997,\n/**/\n    1996,\n/**/\n    1995,\n/**/\n    1994,\n/**/\n    1993,\n/**/\n    1992,\n/**/\n    1991,\n/**/\n    1990,\n/**/\n    1989,\n/**/\n    1988,\n/**/\n    1987,\n/**/\n    1986,\n/**/\n    1985,\n/**/\n    1984,\n/**/\n    1983,\n/**/\n    1982,\n/**/\n    1981,\n/**/\n    1980,\n/**/\n    1979,\n/**/\n    1978,\n/**/\n    1977,\n/**/\n    1976,\n/**/\n    1975,\n/**/\n    1974,\n/**/\n    1973,\n/**/\n    1972,\n/**/\n    1971,\n/**/\n    1970,\n/**/\n    1969,\n/**/\n    1968,\n/**/\n    1967,\n/**/\n    1966,\n/**/\n    1965,\n/**/\n    1964,\n/**/\n    1963,\n/**/\n    1962,\n/**/\n    1961,\n/**/\n    1960,\n/**/\n    1959,\n/**/\n    1958,\n/**/\n    1957,\n/**/\n    1956,\n/**/\n    1955,\n/**/\n    1954,\n/**/\n    1953,\n/**/\n    1952,\n/**/\n    1951,\n/**/\n    1950,\n/**/\n    1949,\n/**/\n    1948,\n/**/\n    1947,\n/**/\n    1946,\n/**/\n    1945,\n/**/\n    1944,\n/**/\n    1943,\n/**/\n    1942,\n/**/\n    1941,\n/**/\n    1940,\n/**/\n    1939,\n/**/\n    1938,\n/**/\n    1937,\n/**/\n    1936,\n/**/\n    1935,\n/**/\n    1934,\n/**/\n    1933,\n/**/\n    1932,\n/**/\n    1931,\n/**/\n    1930,\n/**/\n    1929,\n/**/\n    1928,\n/**/\n    1927,\n/**/\n    1926,\n/**/\n    1925,\n/**/\n    1924,\n/**/\n    1923,\n/**/\n    1922,\n/**/\n    1921,\n/**/\n    1920,\n/**/\n    1919,\n/**/\n    1918,\n/**/\n    1917,\n/**/\n    1916,\n/**/\n    1915,\n/**/\n    1914,\n/**/\n    1913,\n/**/\n    1912,\n/**/\n    1911,\n/**/\n    1910,\n/**/\n    1909,\n/**/\n    1908,\n/**/\n    1907,\n/**/\n    1906,\n/**/\n    1905,\n/**/\n    1904,\n/**/\n    1903,\n/**/\n    1902,\n/**/\n    1901,\n/**/\n    1900,\n/**/\n    1899,\n/**/\n    1898,\n/**/\n    1897,\n/**/\n    1896,\n/**/\n    1895,\n/**/\n    1894,\n/**/\n    1893,\n/**/\n    1892,\n/**/\n    1891,\n/**/\n    1890,\n/**/\n    1889,\n/**/\n    1888,\n/**/\n    1887,\n/**/\n    1886,\n/**/\n    1885,\n/**/\n    1884,\n/**/\n    1883,\n/**/\n    1882,\n/**/\n    1881,\n/**/\n    1880,\n/**/\n    1879,\n/**/\n    1878,\n/**/\n    1877,\n/**/\n    1876,\n/**/\n    1875,\n/**/\n    1874,\n/**/\n    1873,\n/**/\n    1872,\n/**/\n    1871,\n/**/\n    1870,\n/**/\n    1869,\n/**/\n    1868,\n/**/\n    1867,\n/**/\n    1866,\n/**/\n    1865,\n/**/\n    1864,\n/**/\n    1863,\n/**/\n    1862,\n/**/\n    1861,\n/**/\n    1860,\n/**/\n    1859,\n/**/\n    1858,\n/**/\n    1857,\n/**/\n    1856,\n/**/\n    1855,\n/**/\n    1854,\n/**/\n    1853,\n/**/\n    1852,\n/**/\n    1851,\n/**/\n    1850,\n/**/\n    1849,\n/**/\n    1848,\n/**/\n    1847,\n/**/\n    1846,\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    while (l < h)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + (item_count % ncol ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#ifdef FEAT_HUGE\n    msg_puts(_(\"\\nHuge version \"));\n#else\n# ifdef FEAT_BIG\n    msg_puts(_(\"\\nBig version \"));\n# else\n#  ifdef FEAT_NORMAL\n    msg_puts(_(\"\\nNormal version \"));\n#  else\n#   ifdef FEAT_SMALL\n    msg_puts(_(\"\\nSmall version \"));\n#   else\n    msg_puts(_(\"\\nTiny version \"));\n#   endif\n#  endif\n# endif\n#endif\n#ifndef FEAT_GUI\n    msg_puts(_(\"without GUI.\"));\n#else\n# ifdef FEAT_GUI_GTK\n#  ifdef USE_GTK3\n    msg_puts(_(\"with GTK3 GUI.\"));\n#  else\n#   ifdef FEAT_GUI_GNOME\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n#   else\n     msg_puts(_(\"with GTK2 GUI.\"));\n#   endif\n# endif\n# else\n#  ifdef FEAT_GUI_MOTIF\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#  else\n#   ifdef FEAT_GUI_ATHENA\n#    ifdef FEAT_GUI_NEXTAW\n    msg_puts(_(\"with X11-neXtaw GUI.\"));\n#    else\n    msg_puts(_(\"with X11-Athena GUI.\"));\n#    endif\n#   else\n#    ifdef FEAT_GUI_HAIKU\n    msg_puts(_(\"with Haiku GUI.\"));\n#    else\n#     ifdef FEAT_GUI_PHOTON\n    msg_puts(_(\"with Photon GUI.\"));\n#     else\n#      if defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#      endif\n#     endif\n#    endif\n#   endif\n#  endif\n# endif\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version8<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * vim9compile.c: compiling a :def function\n */\n\n#define USING_FLOAT_STUFF\n#include \"vim.h\"\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n\n// When not generating protos this is included in proto.h\n#ifdef PROTO\n# include \"vim9.h\"\n#endif\n\n// Functions defined with :def are stored in this growarray.\n// They are never removed, so that they can be found by index.\n// Deleted functions have the df_deleted flag set.\ngarray_T def_functions = {0, 0, sizeof(dfunc_T), 50, NULL};\n\nstatic void delete_def_function_contents(dfunc_T *dfunc, int mark_deleted);\n\n/*\n * Lookup variable \"name\" in the local scope and return it in \"lvar\".\n * \"lvar->lv_from_outer\" is incremented accordingly.\n * If \"lvar\" is NULL only check if the variable can be found.\n * Return FAIL if not found.\n */\n    int\nlookup_local(char_u *name, size_t len, lvar_T *lvar, cctx_T *cctx)\n{\n    int\t    idx;\n    lvar_T  *lvp;\n\n    if (len == 0)\n\treturn FAIL;\n\n    // Find local in current function scope.\n    for (idx = 0; idx < cctx->ctx_locals.ga_len; ++idx)\n    {\n\tlvp = ((lvar_T *)cctx->ctx_locals.ga_data) + idx;\n\tif (STRNCMP(name, lvp->lv_name, len) == 0\n\t\t\t\t\t       && STRLEN(lvp->lv_name) == len)\n\t{\n\t    if (lvar != NULL)\n\t    {\n\t\t*lvar = *lvp;\n\t\tlvar->lv_from_outer = 0;\n\t    }\n\t    return OK;\n\t}\n    }\n\n    // Find local in outer function scope.\n    if (cctx->ctx_outer != NULL)\n    {\n\tif (lookup_local(name, len, lvar, cctx->ctx_outer) == OK)\n\t{\n\t    if (lvar != NULL)\n\t    {\n\t\tcctx->ctx_outer_used = TRUE;\n\t\t++lvar->lv_from_outer;\n\t    }\n\t    return OK;\n\t}\n    }\n\n    return FAIL;\n}\n\n/*\n * Lookup an argument in the current function and an enclosing function.\n * Returns the argument index in \"idxp\"\n * Returns the argument type in \"type\"\n * Sets \"gen_load_outer\" to TRUE if found in outer scope.\n * Returns OK when found, FAIL otherwise.\n */\n    int\narg_exists(\n\tchar_u\t*name,\n\tsize_t\tlen,\n\tint\t*idxp,\n\ttype_T\t**type,\n\tint\t*gen_load_outer,\n\tcctx_T\t*cctx)\n{\n    int\t    idx;\n    char_u  *va_name;\n\n    if (len == 0)\n\treturn FAIL;\n    for (idx = 0; idx < cctx->ctx_ufunc->uf_args_visible; ++idx)\n    {\n\tchar_u *arg = FUNCARG(cctx->ctx_ufunc, idx);\n\n\tif (STRNCMP(name, arg, len) == 0 && arg[len] == NUL)\n\t{\n\t    if (idxp != NULL)\n\t    {\n\t\t// Arguments are located above the frame pointer.  One further\n\t\t// if there is a vararg argument\n\t\t*idxp = idx - (cctx->ctx_ufunc->uf_args.ga_len\n\t\t\t\t\t\t\t    + STACK_FRAME_SIZE)\n\t\t\t      + (cctx->ctx_ufunc->uf_va_name != NULL ? -1 : 0);\n\n\t\tif (cctx->ctx_ufunc->uf_arg_types != NULL)\n\t\t    *type = cctx->ctx_ufunc->uf_arg_types[idx];\n\t\telse\n\t\t    *type = &t_any;\n\t    }\n\t    return OK;\n\t}\n    }\n\n    va_name = cctx->ctx_ufunc->uf_va_name;\n    if (va_name != NULL\n\t\t    && STRNCMP(name, va_name, len) == 0 && va_name[len] == NUL)\n    {\n\tif (idxp != NULL)\n\t{\n\t    // varargs is always the last argument\n\t    *idxp = -STACK_FRAME_SIZE - 1;\n\t    *type = cctx->ctx_ufunc->uf_va_type;\n\t}\n\treturn OK;\n    }\n\n    if (cctx->ctx_outer != NULL)\n    {\n\t// Lookup the name for an argument of the outer function.\n\tif (arg_exists(name, len, idxp, type, gen_load_outer, cctx->ctx_outer)\n\t\t\t\t\t\t\t\t\t == OK)\n\t{\n\t    if (gen_load_outer != NULL)\n\t\t++*gen_load_outer;\n\t    return OK;\n\t}\n    }\n\n    return FAIL;\n}\n\n/*\n * Lookup a script-local variable in the current script, possibly defined in a\n * block that contains the function \"cctx->ctx_ufunc\".\n * \"cctx\" is NULL at the script level.\n * If \"len\" is <= 0 \"name\" must be NUL terminated.\n * Return NULL when not found.\n */\n    static sallvar_T *\nfind_script_var(char_u *name, size_t len, cctx_T *cctx)\n{\n    scriptitem_T    *si = SCRIPT_ITEM(current_sctx.sc_sid);\n    hashitem_T\t    *hi;\n    int\t\t    cc;\n    sallvar_T\t    *sav;\n    sallvar_T\t    *found_sav;\n    ufunc_T\t    *ufunc;\n\n    // Find the list of all script variables with the right name.\n    if (len > 0)\n    {\n\tcc = name[len];\n\tname[len] = NUL;\n    }\n    hi = hash_find(&si->sn_all_vars.dv_hashtab, name);\n    if (len > 0)\n\tname[len] = cc;\n    if (HASHITEM_EMPTY(hi))\n\treturn NULL;\n\n    sav = HI2SAV(hi);\n    if (sav->sav_block_id == 0)\n\t// variable defined in the top script scope is always visible\n\treturn sav;\n\n    if (cctx == NULL)\n    {\n\t// Not in a function scope, find variable with block id equal to or\n\t// smaller than the current block id.\n\twhile (sav != NULL)\n\t{\n\t    if (sav->sav_block_id <= si->sn_current_block_id)\n\t\tbreak;\n\t    sav = sav->sav_next;\n\t}\n\treturn sav;\n    }\n\n    // Go over the variables with this name and find one that was visible\n    // from the function.\n    ufunc = cctx->ctx_ufunc;\n    found_sav = sav;\n    while (sav != NULL)\n    {\n\tint idx;\n\n\t// Go over the blocks that this function was defined in.  If the\n\t// variable block ID matches it was visible to the function.\n\tfor (idx = 0; idx < ufunc->uf_block_depth; ++idx)\n\t    if (ufunc->uf_block_ids[idx] == sav->sav_block_id)\n\t\treturn sav;\n\tsav = sav->sav_next;\n    }\n\n    // Not found, assume variable at script level was visible.\n    return found_sav;\n}\n\n/*\n * Return TRUE if the script context is Vim9 script.\n */\n    int\nscript_is_vim9()\n{\n    return SCRIPT_ITEM(current_sctx.sc_sid)->sn_version == SCRIPT_VERSION_VIM9;\n}\n\n/*\n * Lookup a variable (without s: prefix) in the current script.\n * \"cctx\" is NULL at the script level.\n * Returns OK or FAIL.\n */\n    int\nscript_var_exists(char_u *name, size_t len, cctx_T *cctx)\n{\n    if (current_sctx.sc_sid <= 0)\n\treturn FAIL;\n    if (script_is_vim9())\n    {\n\t// Check script variables that were visible where the function was\n\t// defined.\n\tif (find_script_var(name, len, cctx) != NULL)\n\t    return OK;\n    }\n    else\n    {\n\thashtab_T\t*ht = &SCRIPT_VARS(current_sctx.sc_sid);\n\tdictitem_T\t*di;\n\tint\t\tcc;\n\n\t// Check script variables that are currently visible\n\tcc = name[len];\n\tname[len] = NUL;\n\tdi = find_var_in_ht(ht, 0, name, TRUE);\n\tname[len] = cc;\n\tif (di != NULL)\n\t    return OK;\n    }\n\n    return FAIL;\n}\n\n/*\n * Return TRUE if \"name\" is a local variable, argument, script variable or\n * imported.\n */\n    static int\nvariable_exists(char_u *name, size_t len, cctx_T *cctx)\n{\n    return (cctx != NULL\n\t\t&& (lookup_local(name, len, NULL, cctx) == OK\n\t\t    || arg_exists(name, len, NULL, NULL, NULL, cctx) == OK))\n\t    || script_var_exists(name, len, cctx) == OK\n\t    || find_imported(name, len, cctx) != NULL;\n}\n\n/*\n * Return TRUE if \"name\" is a local variable, argument, script variable,\n * imported or function.\n */\n    static int\nitem_exists(char_u *name, size_t len, int cmd UNUSED, cctx_T *cctx)\n{\n    int\t    is_global;\n    char_u  *p;\n\n    if (variable_exists(name, len, cctx))\n\treturn TRUE;\n\n    // This is similar to what is in lookup_scriptitem():\n    // Find a function, so that a following \"->\" works.\n    // Require \"(\" or \"->\" to follow, \"Cmd\" is a user command while \"Cmd()\" is\n    // a function call.\n    p = skipwhite(name + len);\n\n    if (name[len] == '(' || (p[0] == '-' && p[1] == '>'))\n    {\n\t// Do not check for an internal function, since it might also be a\n\t// valid command, such as \":split\" versus \"split()\".\n\t// Skip \"g:\" before a function name.\n\tis_global = (name[0] == 'g' && name[1] == ':');\n\treturn find_func(is_global ? name + 2 : name, is_global, cctx) != NULL;\n    }\n    return FALSE;\n}\n\n/*\n * Check if \"p[len]\" is already defined, either in script \"import_sid\" or in\n * compilation context \"cctx\".  \"cctx\" is NULL at the script level.\n * Does not check the global namespace.\n * If \"is_arg\" is TRUE the error message is for an argument name.\n * Return FAIL and give an error if it defined.\n */\n    int\ncheck_defined(char_u *p, size_t len, cctx_T *cctx, int is_arg)\n{\n    int\t\tc = p[len];\n    ufunc_T\t*ufunc = NULL;\n\n    // underscore argument is OK\n    if (len == 1 && *p == '_')\n\treturn OK;\n\n    if (script_var_exists(p, len, cctx) == OK)\n    {\n\tif (is_arg)\n\t    semsg(_(e_argument_already_declared_in_script_str), p);\n\telse\n\t    semsg(_(e_variable_already_declared_in_script_str), p);\n\treturn FAIL;\n    }\n\n    p[len] = NUL;\n    if ((cctx != NULL\n\t\t&& (lookup_local(p, len, NULL, cctx) == OK\n\t\t    || arg_exists(p, len, NULL, NULL, NULL, cctx) == OK))\n\t    || find_imported(p, len, cctx) != NULL\n\t    || (ufunc = find_func_even_dead(p, FALSE, cctx)) != NULL)\n    {\n\t// A local or script-local function can shadow a global function.\n\tif (ufunc == NULL || ((ufunc->uf_flags & FC_DEAD) == 0\n\t\t    && (!func_is_global(ufunc)\n\t\t\t\t\t     || (p[0] == 'g' && p[1] == ':'))))\n\t{\n\t    if (is_arg)\n\t\tsemsg(_(e_argument_name_shadows_existing_variable_str), p);\n\t    else\n\t\tsemsg(_(e_name_already_defined_str), p);\n\t    p[len] = c;\n\t    return FAIL;\n\t}\n    }\n    p[len] = c;\n    return OK;\n}\n\n\n/*\n * Return TRUE if \"actual\" could be \"expected\" and a runtime typecheck is to be\n * used.  Return FALSE if the types will never match.\n */\n    static int\nuse_typecheck(type_T *actual, type_T *expected)\n{\n    if (actual->tt_type == VAR_ANY\n\t    || actual->tt_type == VAR_UNKNOWN\n\t    || (actual->tt_type == VAR_FUNC\n\t\t&& (expected->tt_type == VAR_FUNC\n\t\t\t\t\t   || expected->tt_type == VAR_PARTIAL)\n\t\t&& (actual->tt_member == &t_any\n\t\t    || actual->tt_member == &t_unknown\n\t\t    || actual->tt_argcount < 0)\n\t\t&& (actual->tt_member == &t_unknown ||\n\t\t    (actual->tt_member == &t_void)\n\t\t\t\t\t == (expected->tt_member == &t_void))))\n\treturn TRUE;\n    if ((actual->tt_type == VAR_LIST || actual->tt_type == VAR_DICT)\n\t\t\t\t       && actual->tt_type == expected->tt_type)\n\t// This takes care of a nested list or dict.\n\treturn use_typecheck(actual->tt_member, expected->tt_member);\n    return FALSE;\n}\n\n/*\n * Check that\n * - \"actual\" matches \"expected\" type or\n * - \"actual\" is a type that can be \"expected\" type: add a runtime check; or\n * - return FAIL.\n * If \"actual_is_const\" is TRUE then the type won't change at runtime, do not\n * generate a TYPECHECK.\n */\n    static int\nneed_type_where(\n\ttype_T\t*actual,\n\ttype_T\t*expected,\n\tint\toffset,\n\twhere_T\twhere,\n\tcctx_T\t*cctx,\n\tint\tsilent,\n\tint\tactual_is_const)\n{\n    int ret;\n\n    if (expected == &t_bool && actual != &t_bool\n\t\t\t\t\t&& (actual->tt_flags & TTFLAG_BOOL_OK))\n    {\n\t// Using \"0\", \"1\" or the result of an expression with \"&&\" or \"||\" as a\n\t// boolean is OK but requires a conversion.\n\tgenerate_2BOOL(cctx, FALSE, offset);\n\treturn OK;\n    }\n\n    ret = check_type_maybe(expected, actual, FALSE, where);\n    if (ret == OK)\n\treturn OK;\n\n    // If the actual type can be the expected type add a runtime check.\n    // If it's a constant a runtime check makes no sense.\n    if (!actual_is_const && ret == MAYBE && use_typecheck(actual, expected))\n    {\n\tgenerate_TYPECHECK(cctx, expected, offset, where.wt_index);\n\treturn OK;\n    }\n\n    if (!silent)\n\ttype_mismatch_where(expected, actual, where);\n    return FAIL;\n}\n\n    int\nneed_type(\n\ttype_T\t*actual,\n\ttype_T\t*expected,\n\tint\toffset,\n\tint\targ_idx,\n\tcctx_T\t*cctx,\n\tint\tsilent,\n\tint\tactual_is_const)\n{\n    where_T where = WHERE_INIT;\n\n    where.wt_index = arg_idx;\n    return need_type_where(actual, expected, offset, where,\n\t\t\t\t\t\tcctx, silent, actual_is_const);\n}\n\n/*\n * Reserve space for a local variable.\n * Return the variable or NULL if it failed.\n */\n    lvar_T *\nreserve_local(\n\tcctx_T\t*cctx,\n\tchar_u\t*name,\n\tsize_t\tlen,\n\tint\tisConst,\n\ttype_T\t*type)\n{\n    lvar_T  *lvar;\n    dfunc_T *dfunc;\n\n    if (arg_exists(name, len, NULL, NULL, NULL, cctx) == OK)\n    {\n\temsg_namelen(_(e_str_is_used_as_argument), name, (int)len);\n\treturn NULL;\n    }\n\n    if (GA_GROW_FAILS(&cctx->ctx_locals, 1))\n\treturn NULL;\n    lvar = ((lvar_T *)cctx->ctx_locals.ga_data) + cctx->ctx_locals.ga_len++;\n    CLEAR_POINTER(lvar);\n\n    // Every local variable uses the next entry on the stack.  We could re-use\n    // the last ones when leaving a scope, but then variables used in a closure\n    // might get overwritten.  To keep things simple do not re-use stack\n    // entries.  This is less efficient, but memory is cheap these days.\n    dfunc = ((dfunc_T *)def_functions.ga_data) + cctx->ctx_ufunc->uf_dfunc_idx;\n    lvar->lv_idx = dfunc->df_var_names.ga_len;\n\n    lvar->lv_name = vim_strnsave(name, len == 0 ? STRLEN(name) : len);\n    lvar->lv_const = isConst;\n    lvar->lv_type = type;\n\n    // Remember the name for debugging.\n    if (GA_GROW_FAILS(&dfunc->df_var_names, 1))\n\treturn NULL;\n    ((char_u **)dfunc->df_var_names.ga_data)[lvar->lv_idx] =\n\t\t\t\t\t\t    vim_strsave(lvar->lv_name);\n    ++dfunc->df_var_names.ga_len;\n\n    return lvar;\n}\n\n/*\n * If \"check_writable\" is ASSIGN_CONST give an error if the variable was\n * defined with :final or :const, if \"check_writable\" is ASSIGN_FINAL give an\n * error if the variable was defined with :const.\n */\n    static int\ncheck_item_writable(svar_T *sv, int check_writable, char_u *name)\n{\n    if ((check_writable == ASSIGN_CONST && sv->sv_const != 0)\n\t    || (check_writable == ASSIGN_FINAL\n\t\t\t\t\t      && sv->sv_const == ASSIGN_CONST))\n    {\n\tsemsg(_(e_cannot_change_readonly_variable_str), name);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Find \"name\" in script-local items of script \"sid\".\n * Pass \"check_writable\" to check_item_writable().\n * Returns the index in \"sn_var_vals\" if found.\n * If found but not in \"sn_var_vals\" returns -1.\n * If not found or the variable is not writable returns -2.\n */\n    int\nget_script_item_idx(int sid, char_u *name, int check_writable, cctx_T *cctx)\n{\n    hashtab_T\t    *ht;\n    dictitem_T\t    *di;\n    scriptitem_T    *si = SCRIPT_ITEM(sid);\n    svar_T\t    *sv;\n    int\t\t    idx;\n\n    if (!SCRIPT_ID_VALID(sid))\n\treturn -1;\n    if (sid == current_sctx.sc_sid)\n    {\n\tsallvar_T *sav = find_script_var(name, 0, cctx);\n\n\tif (sav == NULL)\n\t    return -2;\n\tidx = sav->sav_var_vals_idx;\n\tsv = ((svar_T *)si->sn_var_vals.ga_data) + idx;\n\tif (check_item_writable(sv, check_writable, name) == FAIL)\n\t    return -2;\n\treturn idx;\n    }\n\n    // First look the name up in the hashtable.\n    ht = &SCRIPT_VARS(sid);\n    di = find_var_in_ht(ht, 0, name, TRUE);\n    if (di == NULL)\n\treturn -2;\n\n    // Now find the svar_T index in sn_var_vals.\n    for (idx = 0; idx < si->sn_var_vals.ga_len; ++idx)\n    {\n\tsv = ((svar_T *)si->sn_var_vals.ga_data) + idx;\n\tif (sv->sv_tv == &di->di_tv)\n\t{\n\t    if (check_item_writable(sv, check_writable, name) == FAIL)\n\t\treturn -2;\n\t    return idx;\n\t}\n    }\n    return -1;\n}\n\n/*\n * Find \"name\" in imported items of the current script or in \"cctx\" if not\n * NULL.\n */\n    imported_T *\nfind_imported(char_u *name, size_t len, cctx_T *cctx)\n{\n    int\t\t    idx;\n\n    if (!SCRIPT_ID_VALID(current_sctx.sc_sid))\n\treturn NULL;\n    if (cctx != NULL)\n\tfor (idx = 0; idx < cctx->ctx_imports.ga_len; ++idx)\n\t{\n\t    imported_T *import = ((imported_T *)cctx->ctx_imports.ga_data)\n\t\t\t\t\t\t\t\t\t + idx;\n\n\t    if (len == 0 ? STRCMP(name, import->imp_name) == 0\n\t\t\t : STRLEN(import->imp_name) == len\n\t\t\t\t  && STRNCMP(name, import->imp_name, len) == 0)\n\t\treturn import;\n\t}\n\n    return find_imported_in_script(name, len, current_sctx.sc_sid);\n}\n\n    imported_T *\nfind_imported_in_script(char_u *name, size_t len, int sid)\n{\n    scriptitem_T    *si;\n    int\t\t    idx;\n\n    if (!SCRIPT_ID_VALID(sid))\n\treturn NULL;\n    si = SCRIPT_ITEM(sid);\n    for (idx = 0; idx < si->sn_imports.ga_len; ++idx)\n    {\n\timported_T *import = ((imported_T *)si->sn_imports.ga_data) + idx;\n\n\tif (len == 0 ? STRCMP(name, import->imp_name) == 0\n\t\t     : STRLEN(import->imp_name) == len\n\t\t\t\t  && STRNCMP(name, import->imp_name, len) == 0)\n\t    return import;\n    }\n    return NULL;\n}\n\n/*\n * Free all imported variables.\n */\n    static void\nfree_imported(cctx_T *cctx)\n{\n    int idx;\n\n    for (idx = 0; idx < cctx->ctx_imports.ga_len; ++idx)\n    {\n\timported_T *import = ((imported_T *)cctx->ctx_imports.ga_data) + idx;\n\n\tvim_free(import->imp_name);\n    }\n    ga_clear(&cctx->ctx_imports);\n}\n\n/*\n * Called when checking for a following operator at \"arg\".  When the rest of\n * the line is empty or only a comment, peek the next line.  If there is a next\n * line return a pointer to it and set \"nextp\".\n * Otherwise skip over white space.\n */\n    char_u *\nmay_peek_next_line(cctx_T *cctx, char_u *arg, char_u **nextp)\n{\n    char_u *p = skipwhite(arg);\n\n    *nextp = NULL;\n    if (*p == NUL || (VIM_ISWHITE(*arg) && vim9_comment_start(p)))\n    {\n\t*nextp = peek_next_line_from_context(cctx);\n\tif (*nextp != NULL)\n\t    return *nextp;\n    }\n    return p;\n}\n\n/*\n * Return a pointer to the next line that isn't empty or only contains a\n * comment. Skips over white space.\n * Returns NULL if there is none.\n */\n    char_u *\npeek_next_line_from_context(cctx_T *cctx)\n{\n    int lnum = cctx->ctx_lnum;\n\n    while (++lnum < cctx->ctx_ufunc->uf_lines.ga_len)\n    {\n\tchar_u *line = ((char_u **)cctx->ctx_ufunc->uf_lines.ga_data)[lnum];\n\tchar_u *p;\n\n\t// ignore NULLs inserted for continuation lines\n\tif (line != NULL)\n\t{\n\t    p = skipwhite(line);\n\t    if (vim9_bad_comment(p))\n\t\treturn NULL;\n\t    if (*p != NUL && !vim9_comment_start(p))\n\t\treturn p;\n\t}\n    }\n    return NULL;\n}\n\n/*\n * Get the next line of the function from \"cctx\".\n * Skips over empty lines.  Skips over comment lines if \"skip_comment\" is TRUE.\n * Returns NULL when at the end.\n */\n    char_u *\nnext_line_from_context(cctx_T *cctx, int skip_comment)\n{\n    char_u\t*line;\n\n    do\n    {\n\t++cctx->ctx_lnum;\n\tif (cctx->ctx_lnum >= cctx->ctx_ufunc->uf_lines.ga_len)\n\t{\n\t    line = NULL;\n\t    break;\n\t}\n\tline = ((char_u **)cctx->ctx_ufunc->uf_lines.ga_data)[cctx->ctx_lnum];\n\tcctx->ctx_line_start = line;\n\tSOURCING_LNUM = cctx->ctx_lnum + 1;\n    } while (line == NULL || *skipwhite(line) == NUL\n\t\t     || (skip_comment && vim9_comment_start(skipwhite(line))));\n    return line;\n}\n\n/*\n * Skip over white space at \"whitep\" and assign to \"*arg\".\n * If \"*arg\" is at the end of the line, advance to the next line.\n * Also when \"whitep\" points to white space and \"*arg\" is on a \"#\".\n * Return FAIL if beyond the last line, \"*arg\" is unmodified then.\n */\n    int\nmay_get_next_line(char_u *whitep, char_u **arg, cctx_T *cctx)\n{\n    *arg = skipwhite(whitep);\n    if (vim9_bad_comment(*arg))\n\treturn FAIL;\n    if (**arg == NUL || (VIM_ISWHITE(*whitep) && vim9_comment_start(*arg)))\n    {\n\tchar_u *next = next_line_from_context(cctx, TRUE);\n\n\tif (next == NULL)\n\t    return FAIL;\n\t*arg = skipwhite(next);\n    }\n    return OK;\n}\n\n/*\n * Idem, and give an error when failed.\n */\n    int\nmay_get_next_line_error(char_u *whitep, char_u **arg, cctx_T *cctx)\n{\n    if (may_get_next_line(whitep, arg, cctx) == FAIL)\n    {\n\tSOURCING_LNUM = cctx->ctx_lnum + 1;\n\temsg(_(e_line_incomplete));\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Get a line from the compilation context, compatible with exarg_T getline().\n * Return a pointer to the line in allocated memory.\n * Return NULL for end-of-file or some error.\n */\n    static char_u *\nexarg_getline(\n\tint c UNUSED,\n\tvoid *cookie,\n\tint indent UNUSED,\n\tgetline_opt_T options UNUSED)\n{\n    cctx_T  *cctx = (cctx_T *)cookie;\n    char_u  *p;\n\n    for (;;)\n    {\n\tif (cctx->ctx_lnum >= cctx->ctx_ufunc->uf_lines.ga_len - 1)\n\t    return NULL;\n\t++cctx->ctx_lnum;\n\tp = ((char_u **)cctx->ctx_ufunc->uf_lines.ga_data)[cctx->ctx_lnum];\n\t// Comment lines result in NULL pointers, skip them.\n\tif (p != NULL)\n\t    return vim_strsave(p);\n    }\n}\n\n    void\nfill_exarg_from_cctx(exarg_T *eap, cctx_T *cctx)\n{\n    eap->getline = exarg_getline;\n    eap->cookie = cctx;\n}\n\n/*\n * Return TRUE if \"ufunc\" should be compiled, taking into account whether\n * \"profile\" indicates profiling is to be done.\n */\n    int\nfunc_needs_compiling(ufunc_T *ufunc, compiletype_T compile_type)\n{\n    switch (ufunc->uf_def_status)\n    {\n\tcase UF_TO_BE_COMPILED:\n\t    return TRUE;\n\n\tcase UF_COMPILED:\n\t{\n\t    dfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t + ufunc->uf_dfunc_idx;\n\n\t    switch (compile_type)\n\t    {\n\t\tcase CT_PROFILE:\n#ifdef FEAT_PROFILE\n\t\t    return dfunc->df_instr_prof == NULL;\n#endif\n\t\tcase CT_NONE:\n\t\t    return dfunc->df_instr == NULL;\n\t\tcase CT_DEBUG:\n\t\t    return dfunc->df_instr_debug == NULL;\n\t    }\n\t}\n\n\tcase UF_NOT_COMPILED:\n\tcase UF_COMPILE_ERROR:\n\tcase UF_COMPILING:\n\t    break;\n    }\n    return FALSE;\n}\n\n/*\n * Compile a nested :def command.\n */\n    static char_u *\ncompile_nested_function(exarg_T *eap, cctx_T *cctx, char_u **line_to_free)\n{\n    int\t\tis_global = *eap->arg == 'g' && eap->arg[1] == ':';\n    char_u\t*name_start = eap->arg;\n    char_u\t*name_end = to_name_end(eap->arg, TRUE);\n    int\t\toff;\n    char_u\t*func_name;\n    char_u\t*lambda_name;\n    ufunc_T\t*ufunc;\n    int\t\tr = FAIL;\n    compiletype_T   compile_type;\n\n    if (eap->forceit)\n    {\n\temsg(_(e_cannot_use_bang_with_nested_def));\n\treturn NULL;\n    }\n\n    if (*name_start == '/')\n    {\n\tname_end = skip_regexp(name_start + 1, '/', TRUE);\n\tif (*name_end == '/')\n\t    ++name_end;\n\tset_nextcmd(eap, name_end);\n    }\n    if (name_end == name_start || *skipwhite(name_end) != '(')\n    {\n\tif (!ends_excmd2(name_start, name_end))\n\t{\n\t    semsg(_(e_invalid_command_str), eap->cmd);\n\t    return NULL;\n\t}\n\n\t// \"def\" or \"def Name\": list functions\n\tif (generate_DEF(cctx, name_start, name_end - name_start) == FAIL)\n\t    return NULL;\n\treturn eap->nextcmd == NULL ? (char_u *)\"\" : eap->nextcmd;\n    }\n\n    // Only g:Func() can use a namespace.\n    if (name_start[1] == ':' && !is_global)\n    {\n\tsemsg(_(e_namespace_not_supported_str), name_start);\n\treturn NULL;\n    }\n    if (check_defined(name_start, name_end - name_start, cctx, FALSE) == FAIL)\n\treturn NULL;\n\n    eap->arg = name_end;\n    fill_exarg_from_cctx(eap, cctx);\n\n    eap->forceit = FALSE;\n    // We use the special <Lamba>99 name, but it's not really a lambda.\n    lambda_name = vim_strsave(get_lambda_name());\n    if (lambda_name == NULL)\n\treturn NULL;\n\n    // This may free the current line, make a copy of the name.\n    off = is_global ? 2 : 0;\n    func_name = vim_strnsave(name_start + off, name_end - name_start - off);\n    if (func_name == NULL)\n    {\n\tr = FAIL;\n\tgoto theend;\n    }\n\n    ufunc = define_function(eap, lambda_name, line_to_free);\n\n    if (ufunc == NULL)\n    {\n\tr = eap->skip ? OK : FAIL;\n\tgoto theend;\n    }\n\n    // copy over the block scope IDs before compiling\n    if (!is_global && cctx->ctx_ufunc->uf_block_depth > 0)\n    {\n\tint block_depth = cctx->ctx_ufunc->uf_block_depth;\n\n\tufunc->uf_block_ids = ALLOC_MULT(int, block_depth);\n\tif (ufunc->uf_block_ids != NULL)\n\t{\n\t    mch_memmove(ufunc->uf_block_ids, cctx->ctx_ufunc->uf_block_ids,\n\t\t\t\t\t\t    sizeof(int) * block_depth);\n\t    ufunc->uf_block_depth = block_depth;\n\t}\n    }\n\n    compile_type = COMPILE_TYPE(ufunc);\n#ifdef FEAT_PROFILE\n    // If the outer function is profiled, also compile the nested function for\n    // profiling.\n    if (cctx->ctx_compile_type == CT_PROFILE)\n\tcompile_type = CT_PROFILE;\n#endif\n    if (func_needs_compiling(ufunc, compile_type)\n\t    && compile_def_function(ufunc, TRUE, compile_type, cctx) == FAIL)\n    {\n\tfunc_ptr_unref(ufunc);\n\tgoto theend;\n    }\n\n#ifdef FEAT_PROFILE\n    // When the outer function is compiled for profiling, the nested function\n    // may be called without profiling.  Compile it here in the right context.\n    if (compile_type == CT_PROFILE && func_needs_compiling(ufunc, CT_NONE))\n\tcompile_def_function(ufunc, FALSE, CT_NONE, cctx);\n#endif\n\n    if (is_global)\n    {\n\tr = generate_NEWFUNC(cctx, lambda_name, func_name);\n\tfunc_name = NULL;\n\tlambda_name = NULL;\n    }\n    else\n    {\n\t// Define a local variable for the function reference.\n\tlvar_T\t*lvar = reserve_local(cctx, func_name, name_end - name_start,\n\t\t\t\t\t\t    TRUE, ufunc->uf_func_type);\n\n\tif (lvar == NULL)\n\t    goto theend;\n\tif (generate_FUNCREF(cctx, ufunc) == FAIL)\n\t    goto theend;\n\tr = generate_STORE(cctx, ISN_STORE, lvar->lv_idx, NULL);\n    }\n\ntheend:\n    vim_free(lambda_name);\n    vim_free(func_name);\n    return r == FAIL ? NULL : (char_u *)\"\";\n}\n\n/*\n * Return the length of an assignment operator, or zero if there isn't one.\n */\n    int\nassignment_len(char_u *p, int *heredoc)\n{\n    if (*p == '=')\n    {\n\tif (p[1] == '<' && p[2] == '<')\n\t{\n\t    *heredoc = TRUE;\n\t    return 3;\n\t}\n\treturn 1;\n    }\n    if (vim_strchr((char_u *)\"+-*/%\", *p) != NULL && p[1] == '=')\n\treturn 2;\n    if (STRNCMP(p, \"..=\", 3) == 0)\n\treturn 3;\n    return 0;\n}\n\n/*\n * Generate the load instruction for \"name\".\n */\n    static void\ngenerate_loadvar(\n\tcctx_T\t\t*cctx,\n\tassign_dest_T\tdest,\n\tchar_u\t\t*name,\n\tlvar_T\t\t*lvar,\n\ttype_T\t\t*type)\n{\n    switch (dest)\n    {\n\tcase dest_option:\n\tcase dest_func_option:\n\t    generate_LOAD(cctx, ISN_LOADOPT, 0, name, type);\n\t    break;\n\tcase dest_global:\n\t    if (vim_strchr(name, AUTOLOAD_CHAR) == NULL)\n\t\tgenerate_LOAD(cctx, ISN_LOADG, 0, name + 2, type);\n\t    else\n\t\tgenerate_LOAD(cctx, ISN_LOADAUTO, 0, name, type);\n\t    break;\n\tcase dest_buffer:\n\t    generate_LOAD(cctx, ISN_LOADB, 0, name + 2, type);\n\t    break;\n\tcase dest_window:\n\t    generate_LOAD(cctx, ISN_LOADW, 0, name + 2, type);\n\t    break;\n\tcase dest_tab:\n\t    generate_LOAD(cctx, ISN_LOADT, 0, name + 2, type);\n\t    break;\n\tcase dest_script:\n\t    compile_load_scriptvar(cctx,\n\t\t    name + (name[1] == ':' ? 2 : 0), NULL, NULL, TRUE);\n\t    break;\n\tcase dest_env:\n\t    // Include $ in the name here\n\t    generate_LOAD(cctx, ISN_LOADENV, 0, name, type);\n\t    break;\n\tcase dest_reg:\n\t    generate_LOAD(cctx, ISN_LOADREG, name[1], NULL, &t_string);\n\t    break;\n\tcase dest_vimvar:\n\t    generate_LOADV(cctx, name + 2, TRUE);\n\t    break;\n\tcase dest_local:\n\t    if (lvar->lv_from_outer > 0)\n\t\tgenerate_LOADOUTER(cctx, lvar->lv_idx, lvar->lv_from_outer,\n\t\t\t\t\t\t\t\t\t type);\n\t    else\n\t\tgenerate_LOAD(cctx, ISN_LOAD, lvar->lv_idx, NULL, type);\n\t    break;\n\tcase dest_expr:\n\t    // list or dict value should already be on the stack.\n\t    break;\n    }\n}\n\n/*\n * Skip over \"[expr]\" or \".member\".\n * Does not check for any errors.\n */\n    static char_u *\nskip_index(char_u *start)\n{\n    char_u *p = start;\n\n    if (*p == '[')\n    {\n\tp = skipwhite(p + 1);\n\t(void)skip_expr(&p, NULL);\n\tp = skipwhite(p);\n\tif (*p == ']')\n\t    return p + 1;\n\treturn p;\n    }\n    // if (*p == '.')\n    return to_name_end(p + 1, TRUE);\n}\n\n    void\nvim9_declare_error(char_u *name)\n{\n    char *scope = \"\";\n\n    switch (*name)\n    {\n\tcase 'g': scope = _(\"global\"); break;\n\tcase 'b': scope = _(\"buffer\"); break;\n\tcase 'w': scope = _(\"window\"); break;\n\tcase 't': scope = _(\"tab\"); break;\n\tcase 'v': scope = \"v:\"; break;\n\tcase '$': semsg(_(e_cannot_declare_an_environment_variable), name);\n\t\t  return;\n\tcase '&': semsg(_(e_cannot_declare_an_option), name);\n\t\t  return;\n\tcase '@': semsg(_(e_cannot_declare_a_register_str), name);\n\t\t  return;\n\tdefault: return;\n    }\n    semsg(_(e_cannot_declare_a_scope_variable), scope, name);\n}\n\n/*\n * For one assignment figure out the type of destination.  Return it in \"dest\".\n * When not recognized \"dest\" is not set.\n * For an option \"option_scope\" is set.\n * For a v:var \"vimvaridx\" is set.\n * \"type\" is set to the destination type if known, unchanted otherwise.\n * Return FAIL if an error message was given.\n */\n    int\nget_var_dest(\n\tchar_u\t\t*name,\n\tassign_dest_T\t*dest,\n\tint\t\tcmdidx,\n\tint\t\t*option_scope,\n\tint\t\t*vimvaridx,\n\ttype_T\t\t**type,\n\tcctx_T\t\t*cctx)\n{\n    char_u *p;\n\n    if (*name == '&')\n    {\n\tint\t\tcc;\n\tlong\t\tnumval;\n\tgetoption_T\topt_type;\n\tint\t\topt_p_flags;\n\n\t*dest = dest_option;\n\tif (cmdidx == CMD_final || cmdidx == CMD_const)\n\t{\n\t    emsg(_(e_const_option));\n\t    return FAIL;\n\t}\n\tp = name;\n\tp = find_option_end(&p, option_scope);\n\tif (p == NULL)\n\t{\n\t    // cannot happen?\n\t    emsg(_(e_unexpected_characters_in_assignment));\n\t    return FAIL;\n\t}\n\tcc = *p;\n\t*p = NUL;\n\topt_type = get_option_value(skip_option_env_lead(name),\n\t\t\t\t   &numval, NULL, &opt_p_flags, *option_scope);\n\t*p = cc;\n\tswitch (opt_type)\n\t{\n\t    case gov_unknown:\n\t\t    semsg(_(e_unknown_option_str), name);\n\t\t    return FAIL;\n\t    case gov_string:\n\t    case gov_hidden_string:\n\t\t    if (opt_p_flags & P_FUNC)\n\t\t    {\n\t\t\t// might be a Funcref, check the type later\n\t\t\t*type = &t_any;\n\t\t\t*dest = dest_func_option;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t*type = &t_string;\n\t\t    }\n\t\t    break;\n\t    case gov_bool:\n\t    case gov_hidden_bool:\n\t\t    *type = &t_bool;\n\t\t    break;\n\t    case gov_number:\n\t    case gov_hidden_number:\n\t\t    *type = &t_number;\n\t\t    break;\n\t}\n    }\n    else if (*name == '$')\n    {\n\t*dest = dest_env;\n\t*type = &t_string;\n    }\n    else if (*name == '@')\n    {\n\tif (name[1] != '@'\n\t\t\t&& (!valid_yank_reg(name[1], FALSE) || name[1] == '.'))\n\t{\n\t    emsg_invreg(name[1]);\n\t    return FAIL;\n\t}\n\t*dest = dest_reg;\n\t*type = name[1] == '#' ? &t_number_or_string : &t_string;\n    }\n    else if (STRNCMP(name, \"g:\", 2) == 0)\n    {\n\t*dest = dest_global;\n    }\n    else if (STRNCMP(name, \"b:\", 2) == 0)\n    {\n\t*dest = dest_buffer;\n    }\n    else if (STRNCMP(name, \"w:\", 2) == 0)\n    {\n\t*dest = dest_window;\n    }\n    else if (STRNCMP(name, \"t:\", 2) == 0)\n    {\n\t*dest = dest_tab;\n    }\n    else if (STRNCMP(name, \"v:\", 2) == 0)\n    {\n\ttypval_T\t*vtv;\n\tint\t\tdi_flags;\n\n\t*vimvaridx = find_vim_var(name + 2, &di_flags);\n\tif (*vimvaridx < 0)\n\t{\n\t    semsg(_(e_variable_not_found_str), name);\n\t    return FAIL;\n\t}\n\t// We use the current value of \"sandbox\" here, is that OK?\n\tif (var_check_ro(di_flags, name, FALSE))\n\t    return FAIL;\n\t*dest = dest_vimvar;\n\tvtv = get_vim_var_tv(*vimvaridx);\n\t*type = typval2type_vimvar(vtv, cctx->ctx_type_list);\n    }\n    return OK;\n}\n\n    static int\nis_decl_command(int cmdidx)\n{\n    return cmdidx == CMD_let || cmdidx == CMD_var\n\t\t\t\t || cmdidx == CMD_final || cmdidx == CMD_const;\n}\n\n/*\n * Figure out the LHS type and other properties for an assignment or one item\n * of \":unlet\" with an index.\n * Returns OK or FAIL.\n */\n    int\ncompile_lhs(\n\tchar_u\t*var_start,\n\tlhs_T\t*lhs,\n\tint\tcmdidx,\n\tint\theredoc,\n\tint\toplen,\n\tcctx_T\t*cctx)\n{\n    char_u\t*var_end;\n    int\t\tis_decl = is_decl_command(cmdidx);\n\n    CLEAR_POINTER(lhs);\n    lhs->lhs_dest = dest_local;\n    lhs->lhs_vimvaridx = -1;\n    lhs->lhs_scriptvar_idx = -1;\n\n    // \"dest_end\" is the end of the destination, including \"[expr]\" or\n    // \".name\".\n    // \"var_end\" is the end of the variable/option/etc. name.\n    lhs->lhs_dest_end = skip_var_one(var_start, FALSE);\n    if (*var_start == '@')\n\tvar_end = var_start + 2;\n    else\n    {\n\t// skip over the leading \"&\", \"&l:\", \"&g:\" and \"$\"\n\tvar_end = skip_option_env_lead(var_start);\n\tvar_end = to_name_end(var_end, TRUE);\n    }\n\n    // \"a: type\" is declaring variable \"a\" with a type, not dict \"a:\".\n    if (is_decl && lhs->lhs_dest_end == var_start + 2\n\t\t\t\t\t       && lhs->lhs_dest_end[-1] == ':')\n\t--lhs->lhs_dest_end;\n    if (is_decl && var_end == var_start + 2 && var_end[-1] == ':')\n\t--var_end;\n    lhs->lhs_end = lhs->lhs_dest_end;\n\n    // compute the length of the destination without \"[expr]\" or \".name\"\n    lhs->lhs_varlen = var_end - var_start;\n    lhs->lhs_varlen_total = lhs->lhs_varlen;\n    lhs->lhs_name = vim_strnsave(var_start, lhs->lhs_varlen);\n    if (lhs->lhs_name == NULL)\n\treturn FAIL;\n\n    if (lhs->lhs_dest_end > var_start + lhs->lhs_varlen)\n\t// Something follows after the variable: \"var[idx]\" or \"var.key\".\n\tlhs->lhs_has_index = TRUE;\n\n    if (heredoc)\n\tlhs->lhs_type = &t_list_string;\n    else\n\tlhs->lhs_type = &t_any;\n\n    if (cctx->ctx_skip != SKIP_YES)\n    {\n\tint\t    declare_error = FALSE;\n\n\tif (get_var_dest(lhs->lhs_name, &lhs->lhs_dest, cmdidx,\n\t\t\t\t      &lhs->lhs_opt_flags, &lhs->lhs_vimvaridx,\n\t\t\t\t\t\t &lhs->lhs_type, cctx) == FAIL)\n\t    return FAIL;\n\tif (lhs->lhs_dest != dest_local\n\t\t\t\t && cmdidx != CMD_const && cmdidx != CMD_final)\n\t{\n\t    // Specific kind of variable recognized.\n\t    declare_error = is_decl;\n\t}\n\telse\n\t{\n\t    // No specific kind of variable recognized, just a name.\n\t    if (check_reserved_name(lhs->lhs_name) == FAIL)\n\t\treturn FAIL;\n\n\t    if (lookup_local(var_start, lhs->lhs_varlen,\n\t\t\t\t\t     &lhs->lhs_local_lvar, cctx) == OK)\n\t\tlhs->lhs_lvar = &lhs->lhs_local_lvar;\n\t    else\n\t    {\n\t\tCLEAR_FIELD(lhs->lhs_arg_lvar);\n\t\tif (arg_exists(var_start, lhs->lhs_varlen,\n\t\t\t &lhs->lhs_arg_lvar.lv_idx, &lhs->lhs_arg_lvar.lv_type,\n\t\t\t    &lhs->lhs_arg_lvar.lv_from_outer, cctx) == OK)\n\t\t{\n\t\t    if (is_decl)\n\t\t    {\n\t\t\tsemsg(_(e_str_is_used_as_argument), lhs->lhs_name);\n\t\t\treturn FAIL;\n\t\t    }\n\t\t    lhs->lhs_lvar = &lhs->lhs_arg_lvar;\n\t\t}\n\t    }\n\t    if (lhs->lhs_lvar != NULL)\n\t    {\n\t\tif (is_decl)\n\t\t{\n\t\t    semsg(_(e_variable_already_declared), lhs->lhs_name);\n\t\t    return FAIL;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tint script_namespace = lhs->lhs_varlen > 1\n\t\t\t\t       && STRNCMP(var_start, \"s:\", 2) == 0;\n\t\tint script_var = (script_namespace\n\t\t\t? script_var_exists(var_start + 2, lhs->lhs_varlen - 2,\n\t\t\t\t\t\t\t\t\t  cctx)\n\t\t\t  : script_var_exists(var_start, lhs->lhs_varlen,\n\t\t\t\t\t\t\t\t  cctx)) == OK;\n\t\timported_T  *import =\n\t\t\t       find_imported(var_start, lhs->lhs_varlen, cctx);\n\n\t\tif (script_namespace || script_var || import != NULL)\n\t\t{\n\t\t    char_u\t*rawname = lhs->lhs_name\n\t\t\t\t\t   + (lhs->lhs_name[1] == ':' ? 2 : 0);\n\n\t\t    if (is_decl)\n\t\t    {\n\t\t\tif (script_namespace)\n\t\t\t    semsg(_(e_cannot_declare_script_variable_in_function),\n\t\t\t\t\t\t\t\tlhs->lhs_name);\n\t\t\telse\n\t\t\t    semsg(_(e_variable_already_declared_in_script_str),\n\t\t\t\t\t\t\t\tlhs->lhs_name);\n\t\t\treturn FAIL;\n\t\t    }\n\t\t    else if (cctx->ctx_ufunc->uf_script_ctx_version\n\t\t\t\t\t\t\t == SCRIPT_VERSION_VIM9\n\t\t\t\t    && script_namespace\n\t\t\t\t    && !script_var && import == NULL)\n\t\t    {\n\t\t\tsemsg(_(e_unknown_variable_str), lhs->lhs_name);\n\t\t\treturn FAIL;\n\t\t    }\n\n\t\t    lhs->lhs_dest = dest_script;\n\n\t\t    // existing script-local variables should have a type\n\t\t    lhs->lhs_scriptvar_sid = current_sctx.sc_sid;\n\t\t    if (import != NULL)\n\t\t\tlhs->lhs_scriptvar_sid = import->imp_sid;\n\t\t    if (SCRIPT_ID_VALID(lhs->lhs_scriptvar_sid))\n\t\t    {\n\t\t\t// Check writable only when no index follows.\n\t\t\tlhs->lhs_scriptvar_idx = get_script_item_idx(\n\t\t\t\t\t       lhs->lhs_scriptvar_sid, rawname,\n\t\t\t      lhs->lhs_has_index ? ASSIGN_FINAL : ASSIGN_CONST,\n\t\t\t\t\t\t\t\t\t cctx);\n\t\t\tif (lhs->lhs_scriptvar_idx >= 0)\n\t\t\t{\n\t\t\t    scriptitem_T *si = SCRIPT_ITEM(\n\t\t\t\t\t\t       lhs->lhs_scriptvar_sid);\n\t\t\t    svar_T\t *sv =\n\t\t\t\t\t    ((svar_T *)si->sn_var_vals.ga_data)\n\t\t\t\t\t\t      + lhs->lhs_scriptvar_idx;\n\t\t\t    lhs->lhs_type = sv->sv_type;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\telse if (check_defined(var_start, lhs->lhs_varlen, cctx, FALSE)\n\t\t\t\t\t\t\t\t       == FAIL)\n\t\t    return FAIL;\n\t    }\n\t}\n\n\tif (declare_error)\n\t{\n\t    vim9_declare_error(lhs->lhs_name);\n\t    return FAIL;\n\t}\n    }\n\n    // handle \"a:name\" as a name, not index \"name\" in \"a\"\n    if (lhs->lhs_varlen > 1 || var_start[lhs->lhs_varlen] != ':')\n\tvar_end = lhs->lhs_dest_end;\n\n    if (lhs->lhs_dest != dest_option && lhs->lhs_dest != dest_func_option)\n    {\n\tif (is_decl && *var_end == ':')\n\t{\n\t    char_u *p;\n\n\t    // parse optional type: \"let var: type = expr\"\n\t    if (!VIM_ISWHITE(var_end[1]))\n\t    {\n\t\tsemsg(_(e_white_space_required_after_str_str), \":\", var_end);\n\t\treturn FAIL;\n\t    }\n\t    p = skipwhite(var_end + 1);\n\t    lhs->lhs_type = parse_type(&p, cctx->ctx_type_list, TRUE);\n\t    if (lhs->lhs_type == NULL)\n\t\treturn FAIL;\n\t    lhs->lhs_has_type = TRUE;\n\t    lhs->lhs_end = p;\n\t}\n\telse if (lhs->lhs_lvar != NULL)\n\t    lhs->lhs_type = lhs->lhs_lvar->lv_type;\n    }\n\n    if (oplen == 3 && !heredoc\n\t\t   && lhs->lhs_dest != dest_global\n\t\t   && !lhs->lhs_has_index\n\t\t   && lhs->lhs_type->tt_type != VAR_STRING\n\t\t   && lhs->lhs_type->tt_type != VAR_ANY)\n    {\n\temsg(_(e_can_only_concatenate_to_string));\n\treturn FAIL;\n    }\n\n    if (lhs->lhs_lvar == NULL && lhs->lhs_dest == dest_local\n\t\t\t\t\t\t && cctx->ctx_skip != SKIP_YES)\n    {\n\tif (oplen > 1 && !heredoc)\n\t{\n\t    // +=, /=, etc. require an existing variable\n\t    semsg(_(e_cannot_use_operator_on_new_variable), lhs->lhs_name);\n\t    return FAIL;\n\t}\n\tif (!is_decl)\n\t{\n\t    semsg(_(e_unknown_variable_str), lhs->lhs_name);\n\t    return FAIL;\n\t}\n\n\t// Check the name is valid for a funcref.\n\tif ((lhs->lhs_type->tt_type == VAR_FUNC\n\t\t\t\t      || lhs->lhs_type->tt_type == VAR_PARTIAL)\n\t\t&& var_wrong_func_name(lhs->lhs_name, TRUE))\n\t    return FAIL;\n\n\t// New local variable.\n\tlhs->lhs_lvar = reserve_local(cctx, var_start, lhs->lhs_varlen,\n\t\t    cmdidx == CMD_final || cmdidx == CMD_const, lhs->lhs_type);\n\tif (lhs->lhs_lvar == NULL)\n\t    return FAIL;\n\tlhs->lhs_new_local = TRUE;\n    }\n\n    lhs->lhs_member_type = lhs->lhs_type;\n    if (lhs->lhs_has_index)\n    {\n\tchar_u\t*after = var_start + lhs->lhs_varlen;\n\tchar_u\t*p;\n\n\t// Something follows after the variable: \"var[idx]\" or \"var.key\".\n\tif (is_decl)\n\t{\n\t    emsg(_(e_cannot_use_index_when_declaring_variable));\n\t    return FAIL;\n\t}\n\n\t// Now: var_start[lhs->lhs_varlen] is '[' or '.'\n\t// Only the last index is used below, if there are others\n\t// before it generate code for the expression.  Thus for\n\t// \"ll[1][2]\" the expression is \"ll[1]\" and \"[2]\" is the index.\n\tfor (;;)\n\t{\n\t    p = skip_index(after);\n\t    if (*p != '[' && *p != '.')\n\t    {\n\t\tlhs->lhs_varlen_total = p - var_start;\n\t\tbreak;\n\t    }\n\t    after = p;\n\t}\n\tif (after > var_start + lhs->lhs_varlen)\n\t{\n\t    lhs->lhs_varlen = after - var_start;\n\t    lhs->lhs_dest = dest_expr;\n\t    // We don't know the type before evaluating the expression,\n\t    // use \"any\" until then.\n\t    lhs->lhs_type = &t_any;\n\t}\n\n\tif (lhs->lhs_type->tt_member == NULL)\n\t    lhs->lhs_member_type = &t_any;\n\telse\n\t    lhs->lhs_member_type = lhs->lhs_type->tt_member;\n    }\n    return OK;\n}\n\n/*\n * Figure out the LHS and check a few errors.\n */\n    int\ncompile_assign_lhs(\n\tchar_u\t*var_start,\n\tlhs_T\t*lhs,\n\tint\tcmdidx,\n\tint\tis_decl,\n\tint\theredoc,\n\tint\toplen,\n\tcctx_T\t*cctx)\n{\n    if (compile_lhs(var_start, lhs, cmdidx, heredoc, oplen, cctx) == FAIL)\n\treturn FAIL;\n\n    if (!lhs->lhs_has_index && lhs->lhs_lvar == &lhs->lhs_arg_lvar)\n    {\n\tsemsg(_(e_cannot_assign_to_argument), lhs->lhs_name);\n\treturn FAIL;\n    }\n    if (!is_decl && lhs->lhs_lvar != NULL\n\t\t\t   && lhs->lhs_lvar->lv_const && !lhs->lhs_has_index)\n    {\n\tsemsg(_(e_cannot_assign_to_constant), lhs->lhs_name);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Return TRUE if \"lhs\" has a range index: \"[expr : expr]\".\n */\n    static int\nhas_list_index(char_u *idx_start, cctx_T *cctx)\n{\n    char_u  *p = idx_start;\n    int\t    save_skip;\n\n    if (*p != '[')\n\treturn FALSE;\n\n    p = skipwhite(p + 1);\n    if (*p == ':')\n\treturn TRUE;\n\n    save_skip = cctx->ctx_skip;\n    cctx->ctx_skip = SKIP_YES;\n    (void)compile_expr0(&p, cctx);\n    cctx->ctx_skip = save_skip;\n    return *skipwhite(p) == ':';\n}\n\n/*\n * For an assignment with an index, compile the \"idx\" in \"var[idx]\" or \"key\" in\n * \"var.key\".\n */\n    static int\ncompile_assign_index(\n\tchar_u\t*var_start,\n\tlhs_T\t*lhs,\n\tint\t*range,\n\tcctx_T\t*cctx)\n{\n    size_t\tvarlen = lhs->lhs_varlen;\n    char_u\t*p;\n    int\t\tr = OK;\n    int\t\tneed_white_before = TRUE;\n    int\t\tempty_second;\n\n    p = var_start + varlen;\n    if (*p == '[')\n    {\n\tp = skipwhite(p + 1);\n\tif (*p == ':')\n\t{\n\t    // empty first index, push zero\n\t    r = generate_PUSHNR(cctx, 0);\n\t    need_white_before = FALSE;\n\t}\n\telse\n\t    r = compile_expr0(&p, cctx);\n\n\tif (r == OK && *skipwhite(p) == ':')\n\t{\n\t    // unlet var[idx : idx]\n\t    // blob[idx : idx] = value\n\t    *range = TRUE;\n\t    p = skipwhite(p);\n\t    empty_second = *skipwhite(p + 1) == ']';\n\t    if ((need_white_before && !IS_WHITE_OR_NUL(p[-1]))\n\t\t    || (!empty_second && !IS_WHITE_OR_NUL(p[1])))\n\t    {\n\t\tsemsg(_(e_white_space_required_before_and_after_str_at_str),\n\t\t\t\t\t\t\t\t      \":\", p);\n\t\treturn FAIL;\n\t    }\n\t    p = skipwhite(p + 1);\n\t    if (*p == ']')\n\t\t// empty second index, push \"none\"\n\t\tr = generate_PUSHSPEC(cctx, VVAL_NONE);\n\t    else\n\t\tr = compile_expr0(&p, cctx);\n\t}\n\n\tif (r == OK && *skipwhite(p) != ']')\n\t{\n\t    // this should not happen\n\t    emsg(_(e_missing_closing_square_brace));\n\t    r = FAIL;\n\t}\n    }\n    else // if (*p == '.')\n    {\n\tchar_u *key_end = to_name_end(p + 1, TRUE);\n\tchar_u *key = vim_strnsave(p + 1, key_end - p - 1);\n\n\tr = generate_PUSHS(cctx, &key);\n    }\n    return r;\n}\n\n/*\n * For a LHS with an index, load the variable to be indexed.\n */\n    static int\ncompile_load_lhs(\n\tlhs_T\t*lhs,\n\tchar_u\t*var_start,\n\ttype_T\t*rhs_type,\n\tcctx_T\t*cctx)\n{\n    if (lhs->lhs_dest == dest_expr)\n    {\n\tsize_t\t    varlen = lhs->lhs_varlen;\n\tint\t    c = var_start[varlen];\n\tint\t    lines_len = cctx->ctx_ufunc->uf_lines.ga_len;\n\tchar_u\t    *p = var_start;\n\tgarray_T    *stack = &cctx->ctx_type_stack;\n\tint\t    res;\n\n\t// Evaluate \"ll[expr]\" of \"ll[expr][idx]\".  End the line with a NUL and\n\t// limit the lines array length to avoid skipping to a following line.\n\tvar_start[varlen] = NUL;\n\tcctx->ctx_ufunc->uf_lines.ga_len = cctx->ctx_lnum + 1;\n\tres = compile_expr0(&p, cctx);\n\tvar_start[varlen] = c;\n\tcctx->ctx_ufunc->uf_lines.ga_len = lines_len;\n\tif (res == FAIL || p != var_start + varlen)\n\t{\n\t    // this should not happen\n\t    if (res != FAIL)\n\t\temsg(_(e_missing_closing_square_brace));\n\t    return FAIL;\n\t}\n\n\tlhs->lhs_type = stack->ga_len == 0 ? &t_void\n\t\t\t      : ((type_T **)stack->ga_data)[stack->ga_len - 1];\n\t// now we can properly check the type\n\tif (rhs_type != NULL && lhs->lhs_type->tt_member != NULL\n\t\t&& rhs_type != &t_void\n\t\t&& need_type(rhs_type, lhs->lhs_type->tt_member, -2, 0, cctx,\n\t\t\t\t\t\t\t FALSE, FALSE) == FAIL)\n\t    return FAIL;\n    }\n    else\n\tgenerate_loadvar(cctx, lhs->lhs_dest, lhs->lhs_name,\n\t\t\t\t\t\t lhs->lhs_lvar, lhs->lhs_type);\n    return OK;\n}\n\n/*\n * Produce code for loading \"lhs\" and also take care of an index.\n * Return OK/FAIL.\n */\n    int\ncompile_load_lhs_with_index(lhs_T *lhs, char_u *var_start, cctx_T *cctx)\n{\n    compile_load_lhs(lhs, var_start, NULL, cctx);\n\n    if (lhs->lhs_has_index)\n    {\n\tint range = FALSE;\n\n\t// Get member from list or dict.  First compile the\n\t// index value.\n\tif (compile_assign_index(var_start, lhs, &range, cctx) == FAIL)\n\t    return FAIL;\n\tif (range)\n\t{\n\t    semsg(_(e_cannot_use_range_with_assignment_operator_str),\n\t\t\t\t\t\t\t\t    var_start);\n\t    return FAIL;\n\t}\n\n\t// Get the member.\n\tif (compile_member(FALSE, NULL, cctx) == FAIL)\n\t    return FAIL;\n    }\n    return OK;\n}\n\n/*\n * Assignment to a list or dict member, or \":unlet\" for the item, using the\n * information in \"lhs\".\n * Returns OK or FAIL.\n */\n    int\ncompile_assign_unlet(\n\tchar_u\t*var_start,\n\tlhs_T\t*lhs,\n\tint\tis_assign,\n\ttype_T\t*rhs_type,\n\tcctx_T\t*cctx)\n{\n    vartype_T\tdest_type;\n    garray_T    *stack = &cctx->ctx_type_stack;\n    int\t\trange = FALSE;\n\n    if (compile_assign_index(var_start, lhs, &range, cctx) == FAIL)\n\treturn FAIL;\n    if (is_assign && range\n\t    && lhs->lhs_type->tt_type != VAR_LIST\n\t    && lhs->lhs_type != &t_blob\n\t    && lhs->lhs_type != &t_any)\n    {\n\tsemsg(_(e_cannot_use_range_with_assignment_str), var_start);\n\treturn FAIL;\n    }\n\n    if (lhs->lhs_type == &t_any)\n    {\n\t// Index on variable of unknown type: check at runtime.\n\tdest_type = VAR_ANY;\n    }\n    else\n    {\n\tdest_type = lhs->lhs_type->tt_type;\n\tif (dest_type == VAR_DICT && range)\n\t{\n\t    emsg(e_cannot_use_range_with_dictionary);\n\t    return FAIL;\n\t}\n\tif (dest_type == VAR_DICT\n\t\t\t      && may_generate_2STRING(-1, FALSE, cctx) == FAIL)\n\t    return FAIL;\n\tif (dest_type == VAR_LIST || dest_type == VAR_BLOB)\n\t{\n\t    type_T *type;\n\n\t    if (range)\n\t    {\n\t\ttype = ((type_T **)stack->ga_data)[stack->ga_len - 2];\n\t\tif (need_type(type, &t_number,\n\t\t\t\t\t    -1, 0, cctx, FALSE, FALSE) == FAIL)\n\t\treturn FAIL;\n\t    }\n\t    type = ((type_T **)stack->ga_data)[stack->ga_len - 1];\n\t    if ((dest_type != VAR_BLOB && type != &t_special)\n\t\t    && need_type(type, &t_number,\n\t\t\t\t\t    -1, 0, cctx, FALSE, FALSE) == FAIL)\n\t\treturn FAIL;\n\t}\n    }\n\n    // Load the dict or list.  On the stack we then have:\n    // - value (for assignment, not for :unlet)\n    // - index\n    // - for [a : b] second index\n    // - variable\n    if (compile_load_lhs(lhs, var_start, rhs_type, cctx) == FAIL)\n\treturn FAIL;\n\n    if (dest_type == VAR_LIST || dest_type == VAR_DICT\n\t\t\t      || dest_type == VAR_BLOB || dest_type == VAR_ANY)\n    {\n\tif (is_assign)\n\t{\n\t    if (range)\n\t    {\n\t\tif (generate_instr_drop(cctx, ISN_STORERANGE, 4) == NULL)\n\t\t    return FAIL;\n\t    }\n\t    else\n\t    {\n\t\tisn_T\t*isn = generate_instr_drop(cctx, ISN_STOREINDEX, 3);\n\n\t\tif (isn == NULL)\n\t\t    return FAIL;\n\t\tisn->isn_arg.vartype = dest_type;\n\t    }\n\t}\n\telse if (range)\n\t{\n\t    if (generate_instr_drop(cctx, ISN_UNLETRANGE, 3) == NULL)\n\t\treturn FAIL;\n\t}\n\telse\n\t{\n\t    if (generate_instr_drop(cctx, ISN_UNLETINDEX, 2) == NULL)\n\t\treturn FAIL;\n\t}\n    }\n    else\n    {\n\temsg(_(e_indexable_type_required));\n\treturn FAIL;\n    }\n\n    return OK;\n}\n\n/*\n * Compile declaration and assignment:\n * \"let name\"\n * \"var name = expr\"\n * \"final name = expr\"\n * \"const name = expr\"\n * \"name = expr\"\n * \"arg\" points to \"name\".\n * \"++arg\" and \"--arg\"\n * Return NULL for an error.\n * Return \"arg\" if it does not look like a variable list.\n */\n    static char_u *\ncompile_assignment(char_u *arg, exarg_T *eap, cmdidx_T cmdidx, cctx_T *cctx)\n{\n    char_u\t*var_start;\n    char_u\t*p;\n    char_u\t*end = arg;\n    char_u\t*ret = NULL;\n    int\t\tvar_count = 0;\n    int\t\tvar_idx;\n    int\t\tsemicolon = 0;\n    int\t\tdid_generate_slice = FALSE;\n    garray_T\t*instr = &cctx->ctx_instr;\n    garray_T    *stack = &cctx->ctx_type_stack;\n    char_u\t*op;\n    int\t\toplen = 0;\n    int\t\theredoc = FALSE;\n    int\t\tincdec = FALSE;\n    type_T\t*rhs_type = &t_any;\n    char_u\t*sp;\n    int\t\tis_decl = is_decl_command(cmdidx);\n    lhs_T\tlhs;\n    long\tstart_lnum = SOURCING_LNUM;\n\n    // Skip over the \"var\" or \"[var, var]\" to get to any \"=\".\n    p = skip_var_list(arg, TRUE, &var_count, &semicolon, TRUE);\n    if (p == NULL)\n\treturn *arg == '[' ? arg : NULL;\n\n    lhs.lhs_name = NULL;\n\n    sp = p;\n    p = skipwhite(p);\n    op = p;\n    oplen = assignment_len(p, &heredoc);\n\n    if (var_count > 0 && oplen == 0)\n\t// can be something like \"[1, 2]->func()\"\n\treturn arg;\n\n    if (oplen > 0 && (!VIM_ISWHITE(*sp) || !IS_WHITE_OR_NUL(op[oplen])))\n    {\n\terror_white_both(op, oplen);\n\treturn NULL;\n    }\n    if (eap->cmdidx == CMD_increment || eap->cmdidx == CMD_decrement)\n    {\n\tif (VIM_ISWHITE(eap->cmd[2]))\n\t{\n\t    semsg(_(e_no_white_space_allowed_after_str_str),\n\t\t\t eap->cmdidx == CMD_increment ? \"++\" : \"--\", eap->cmd);\n\t    return NULL;\n\t}\n\top = (char_u *)(eap->cmdidx == CMD_increment ? \"+=\" : \"-=\");\n\toplen = 2;\n\tincdec = TRUE;\n    }\n\n    if (heredoc)\n    {\n\tlist_T\t   *l;\n\tlistitem_T *li;\n\n\t// [let] varname =<< [trim] {end}\n\teap->getline = exarg_getline;\n\teap->cookie = cctx;\n\tl = heredoc_get(eap, op + 3, FALSE);\n\tif (l == NULL)\n\t    return NULL;\n\n\tif (cctx->ctx_skip != SKIP_YES)\n\t{\n\t    // Push each line and the create the list.\n\t    FOR_ALL_LIST_ITEMS(l, li)\n\t    {\n\t\tgenerate_PUSHS(cctx, &li->li_tv.vval.v_string);\n\t\tli->li_tv.vval.v_string = NULL;\n\t    }\n\t    generate_NEWLIST(cctx, l->lv_len);\n\t}\n\tlist_free(l);\n\tp += STRLEN(p);\n\tend = p;\n    }\n    else if (var_count > 0)\n    {\n\tchar_u *wp;\n\n\t// for \"[var, var] = expr\" evaluate the expression here, loop over the\n\t// list of variables below.\n\t// A line break may follow the \"=\".\n\n\twp = op + oplen;\n\tif (may_get_next_line_error(wp, &p, cctx) == FAIL)\n\t    return FAIL;\n\tif (compile_expr0(&p, cctx) == FAIL)\n\t    return NULL;\n\tend = p;\n\n\tif (cctx->ctx_skip != SKIP_YES)\n\t{\n\t    type_T\t*stacktype;\n\t    int\t\tneeded_list_len;\n\t    int\t\tdid_check = FALSE;\n\n\t    stacktype = stack->ga_len == 0 ? &t_void\n\t\t\t      : ((type_T **)stack->ga_data)[stack->ga_len - 1];\n\t    if (stacktype->tt_type == VAR_VOID)\n\t    {\n\t\temsg(_(e_cannot_use_void_value));\n\t\tgoto theend;\n\t    }\n\t    if (need_type(stacktype, &t_list_any, -1, 0, cctx,\n\t\t\t\t\t\t\t FALSE, FALSE) == FAIL)\n\t\tgoto theend;\n\t    // If a constant list was used we can check the length right here.\n\t    needed_list_len = semicolon ? var_count - 1 : var_count;\n\t    if (instr->ga_len > 0)\n\t    {\n\t\tisn_T\t*isn = ((isn_T *)instr->ga_data) + instr->ga_len - 1;\n\n\t\tif (isn->isn_type == ISN_NEWLIST)\n\t\t{\n\t\t    did_check = TRUE;\n\t\t    if (semicolon ? isn->isn_arg.number < needed_list_len\n\t\t\t    : isn->isn_arg.number != needed_list_len)\n\t\t    {\n\t\t\tsemsg(_(e_expected_nr_items_but_got_nr),\n\t\t\t\t\t needed_list_len, isn->isn_arg.number);\n\t\t\tgoto theend;\n\t\t    }\n\t\t}\n\t    }\n\t    if (!did_check)\n\t\tgenerate_CHECKLEN(cctx, needed_list_len, semicolon);\n\t    if (stacktype->tt_member != NULL)\n\t\trhs_type = stacktype->tt_member;\n\t}\n    }\n\n    /*\n     * Loop over variables in \"[var, var] = expr\".\n     * For \"var = expr\" and \"let var: type\" this is done only once.\n     */\n    if (var_count > 0)\n\tvar_start = skipwhite(arg + 1);  // skip over the \"[\"\n    else\n\tvar_start = arg;\n    for (var_idx = 0; var_idx == 0 || var_idx < var_count; var_idx++)\n    {\n\tint\tinstr_count = -1;\n\tint\tsave_lnum;\n\tint\tskip_store = FALSE;\n\n\tif (var_start[0] == '_' && !eval_isnamec(var_start[1]))\n\t{\n\t    // Ignore underscore in \"[a, _, b] = list\".\n\t    if (var_count > 0)\n\t    {\n\t\tvar_start = skipwhite(var_start + 2);\n\t\tcontinue;\n\t    }\n\t    emsg(_(e_cannot_use_underscore_here));\n\t    goto theend;\n\t}\n\tvim_free(lhs.lhs_name);\n\n\t/*\n\t * Figure out the LHS type and other properties.\n\t */\n\tif (compile_assign_lhs(var_start, &lhs, cmdidx,\n\t\t\t\t\tis_decl, heredoc, oplen, cctx) == FAIL)\n\t    goto theend;\n\tif (heredoc)\n\t{\n\t    SOURCING_LNUM = start_lnum;\n\t    if (lhs.lhs_has_type\n\t\t    && need_type(&t_list_string, lhs.lhs_type,\n\t\t\t\t\t    -1, 0, cctx, FALSE, FALSE) == FAIL)\n\t\tgoto theend;\n\t}\n\telse\n\t{\n\t    if (cctx->ctx_skip == SKIP_YES)\n\t    {\n\t\tif (oplen > 0 && var_count == 0)\n\t\t{\n\t\t    // skip over the \"=\" and the expression\n\t\t    p = skipwhite(op + oplen);\n\t\t    (void)compile_expr0(&p, cctx);\n\t\t}\n\t    }\n\t    else if (oplen > 0)\n\t    {\n\t\tint\tis_const = FALSE;\n\t\tchar_u\t*wp;\n\n\t\t// for \"+=\", \"*=\", \"..=\" etc. first load the current value\n\t\tif (*op != '='\n\t\t\t&& compile_load_lhs_with_index(&lhs, var_start,\n\t\t\t\t\t\t\t\t cctx) == FAIL)\n\t\t    goto theend;\n\n\t\t// For \"var = expr\" evaluate the expression.\n\t\tif (var_count == 0)\n\t\t{\n\t\t    int\tr;\n\n\t\t    // Compile the expression.\n\t\t    instr_count = instr->ga_len;\n\t\t    if (incdec)\n\t\t    {\n\t\t\tr = generate_PUSHNR(cctx, 1);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// Temporarily hide the new local variable here, it is\n\t\t\t// not available to this expression.\n\t\t\tif (lhs.lhs_new_local)\n\t\t\t    --cctx->ctx_locals.ga_len;\n\t\t\twp = op + oplen;\n\t\t\tif (may_get_next_line_error(wp, &p, cctx) == FAIL)\n\t\t\t{\n\t\t\t    if (lhs.lhs_new_local)\n\t\t\t\t++cctx->ctx_locals.ga_len;\n\t\t\t    goto theend;\n\t\t\t}\n\t\t\tr = compile_expr0_ext(&p, cctx, &is_const);\n\t\t\tif (lhs.lhs_new_local)\n\t\t\t    ++cctx->ctx_locals.ga_len;\n\t\t\tif (r == FAIL)\n\t\t\t    goto theend;\n\t\t    }\n\t\t}\n\t\telse if (semicolon && var_idx == var_count - 1)\n\t\t{\n\t\t    // For \"[var; var] = expr\" get the rest of the list\n\t\t    did_generate_slice = TRUE;\n\t\t    if (generate_SLICE(cctx, var_count - 1) == FAIL)\n\t\t\tgoto theend;\n\t\t}\n\t\telse\n\t\t{\n\t\t    // For \"[var, var] = expr\" get the \"var_idx\" item from the\n\t\t    // list.\n\t\t    if (generate_GETITEM(cctx, var_idx, *op != '=') == FAIL)\n\t\t\tgoto theend;\n\t\t}\n\n\t\trhs_type = stack->ga_len == 0 ? &t_void\n\t\t\t      : ((type_T **)stack->ga_data)[stack->ga_len - 1];\n\t\tif (lhs.lhs_lvar != NULL && (is_decl || !lhs.lhs_has_type))\n\t\t{\n\t\t    if ((rhs_type->tt_type == VAR_FUNC\n\t\t\t\t|| rhs_type->tt_type == VAR_PARTIAL)\n\t\t\t    && !lhs.lhs_has_index\n\t\t\t    && var_wrong_func_name(lhs.lhs_name, TRUE))\n\t\t\tgoto theend;\n\n\t\t    if (lhs.lhs_new_local && !lhs.lhs_has_type)\n\t\t    {\n\t\t\tif (rhs_type->tt_type == VAR_VOID)\n\t\t\t{\n\t\t\t    emsg(_(e_cannot_use_void_value));\n\t\t\t    goto theend;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // An empty list or dict has a &t_unknown member,\n\t\t\t    // for a variable that implies &t_any.\n\t\t\t    if (rhs_type == &t_list_empty)\n\t\t\t\tlhs.lhs_lvar->lv_type = &t_list_any;\n\t\t\t    else if (rhs_type == &t_dict_empty)\n\t\t\t\tlhs.lhs_lvar->lv_type = &t_dict_any;\n\t\t\t    else if (rhs_type == &t_unknown)\n\t\t\t\tlhs.lhs_lvar->lv_type = &t_any;\n\t\t\t    else\n\t\t\t\tlhs.lhs_lvar->lv_type = rhs_type;\n\t\t\t}\n\t\t    }\n\t\t    else if (*op == '=')\n\t\t    {\n\t\t\ttype_T *use_type = lhs.lhs_lvar->lv_type;\n\t\t\twhere_T where = WHERE_INIT;\n\n\t\t\t// Without operator check type here, otherwise below.\n\t\t\t// Use the line number of the assignment.\n\t\t\tSOURCING_LNUM = start_lnum;\n\t\t\twhere.wt_index = var_count > 0 ? var_idx + 1 : 0;\n\t\t\twhere.wt_variable = var_count > 0;\n\t\t\t// If assigning to a list or dict member, use the\n\t\t\t// member type.  Not for \"list[:] =\".\n\t\t\tif (lhs.lhs_has_index\n\t\t\t\t&& !has_list_index(var_start + lhs.lhs_varlen,\n\t\t\t\t\t\t\t\t\t cctx))\n\t\t\t    use_type = lhs.lhs_member_type;\n\t\t\tif (need_type_where(rhs_type, use_type, -1, where,\n\t\t\t\t    cctx, FALSE, is_const) == FAIL)\n\t\t\t    goto theend;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    type_T *lhs_type = lhs.lhs_member_type;\n\n\t\t    // Special case: assigning to @# can use a number or a\n\t\t    // string.\n\t\t    // Also: can assign a number to a float.\n\t\t    if ((lhs_type == &t_number_or_string\n\t\t\t\t|| lhs_type == &t_float)\n\t\t\t    && rhs_type->tt_type == VAR_NUMBER)\n\t\t\tlhs_type = &t_number;\n\t\t    if (*p != '=' && need_type(rhs_type, lhs_type,\n\t\t\t\t\t    -1, 0, cctx, FALSE, FALSE) == FAIL)\n\t\t    goto theend;\n\t\t}\n\t    }\n\t    else if (cmdidx == CMD_final)\n\t    {\n\t\temsg(_(e_final_requires_a_value));\n\t\tgoto theend;\n\t    }\n\t    else if (cmdidx == CMD_const)\n\t    {\n\t\temsg(_(e_const_requires_a_value));\n\t\tgoto theend;\n\t    }\n\t    else if (!lhs.lhs_has_type || lhs.lhs_dest == dest_option\n\t\t\t\t\t   || lhs.lhs_dest == dest_func_option)\n\t    {\n\t\temsg(_(e_type_or_initialization_required));\n\t\tgoto theend;\n\t    }\n\t    else\n\t    {\n\t\t// variables are always initialized\n\t\tif (GA_GROW_FAILS(instr, 1))\n\t\t    goto theend;\n\t\tswitch (lhs.lhs_member_type->tt_type)\n\t\t{\n\t\t    case VAR_BOOL:\n\t\t\tgenerate_PUSHBOOL(cctx, VVAL_FALSE);\n\t\t\tbreak;\n\t\t    case VAR_FLOAT:\n#ifdef FEAT_FLOAT\n\t\t\tgenerate_PUSHF(cctx, 0.0);\n#endif\n\t\t\tbreak;\n\t\t    case VAR_STRING:\n\t\t\tgenerate_PUSHS(cctx, NULL);\n\t\t\tbreak;\n\t\t    case VAR_BLOB:\n\t\t\tgenerate_PUSHBLOB(cctx, blob_alloc());\n\t\t\tbreak;\n\t\t    case VAR_FUNC:\n\t\t\tgenerate_PUSHFUNC(cctx, NULL, &t_func_void);\n\t\t\tbreak;\n\t\t    case VAR_LIST:\n\t\t\tgenerate_NEWLIST(cctx, 0);\n\t\t\tbreak;\n\t\t    case VAR_DICT:\n\t\t\tgenerate_NEWDICT(cctx, 0);\n\t\t\tbreak;\n\t\t    case VAR_JOB:\n\t\t\tgenerate_PUSHJOB(cctx, NULL);\n\t\t\tbreak;\n\t\t    case VAR_CHANNEL:\n\t\t\tgenerate_PUSHCHANNEL(cctx, NULL);\n\t\t\tbreak;\n\t\t    case VAR_NUMBER:\n\t\t    case VAR_UNKNOWN:\n\t\t    case VAR_ANY:\n\t\t    case VAR_PARTIAL:\n\t\t    case VAR_VOID:\n\t\t    case VAR_INSTR:\n\t\t    case VAR_SPECIAL:  // cannot happen\n\t\t\t// This is skipped for local variables, they are\n\t\t\t// always initialized to zero.\n\t\t\tif (lhs.lhs_dest == dest_local)\n\t\t\t    skip_store = TRUE;\n\t\t\telse\n\t\t\t    generate_PUSHNR(cctx, 0);\n\t\t\tbreak;\n\t\t}\n\t    }\n\t    if (var_count == 0)\n\t\tend = p;\n\t}\n\n\t// no need to parse more when skipping\n\tif (cctx->ctx_skip == SKIP_YES)\n\t    break;\n\n\tif (oplen > 0 && *op != '=')\n\t{\n\t    type_T\t    *expected;\n\t    type_T\t    *stacktype = NULL;\n\n\t    if (*op == '.')\n\t    {\n\t\tif (may_generate_2STRING(-1, FALSE, cctx) == FAIL)\n\t\t    goto theend;\n\t    }\n\t    else\n\t    {\n\t\texpected = lhs.lhs_member_type;\n\t\tstacktype = ((type_T **)stack->ga_data)[stack->ga_len - 1];\n\t\tif (\n#ifdef FEAT_FLOAT\n\t\t    // If variable is float operation with number is OK.\n\t\t    !(expected == &t_float && (stacktype == &t_number\n\t\t\t    || stacktype == &t_number_bool)) &&\n#endif\n\t\t    need_type(stacktype, expected, -1, 0, cctx,\n\t\t\t\t\t\t\t FALSE, FALSE) == FAIL)\n\t\t    goto theend;\n\t    }\n\n\t    if (*op == '.')\n\t    {\n\t\tif (generate_instr_drop(cctx, ISN_CONCAT, 1) == NULL)\n\t\t    goto theend;\n\t    }\n\t    else if (*op == '+')\n\t    {\n\t\tif (generate_add_instr(cctx,\n\t\t\t    operator_type(lhs.lhs_member_type, stacktype),\n\t\t\t\t       lhs.lhs_member_type, stacktype,\n\t\t\t\t\t\t\t  EXPR_APPEND) == FAIL)\n\t\t    goto theend;\n\t    }\n\t    else if (generate_two_op(cctx, op) == FAIL)\n\t\tgoto theend;\n\t}\n\n\t// Use the line number of the assignment for store instruction.\n\tsave_lnum = cctx->ctx_lnum;\n\tcctx->ctx_lnum = start_lnum - 1;\n\n\tif (lhs.lhs_has_index)\n\t{\n\t    // Use the info in \"lhs\" to store the value at the index in the\n\t    // list or dict.\n\t    if (compile_assign_unlet(var_start, &lhs, TRUE, rhs_type, cctx)\n\t\t\t\t\t\t\t\t       == FAIL)\n\t    {\n\t\tcctx->ctx_lnum = save_lnum;\n\t\tgoto theend;\n\t    }\n\t}\n\telse\n\t{\n\t    if (is_decl && cmdidx == CMD_const && (lhs.lhs_dest == dest_script\n\t\t\t\t\t\t|| lhs.lhs_dest == dest_global\n\t\t\t\t\t\t|| lhs.lhs_dest == dest_local))\n\t\t// \":const var\": lock the value, but not referenced variables\n\t\tgenerate_LOCKCONST(cctx);\n\n\t    if (is_decl\n\t\t    && (lhs.lhs_type->tt_type == VAR_DICT\n\t\t\t\t\t  || lhs.lhs_type->tt_type == VAR_LIST)\n\t\t    && lhs.lhs_type->tt_member != NULL\n\t\t    && !(lhs.lhs_type->tt_member == &t_any\n\t\t\t    && oplen > 0\n\t\t\t    && rhs_type != NULL\n\t\t\t    && rhs_type->tt_type == lhs.lhs_type->tt_type\n\t\t\t    && rhs_type->tt_member != &t_unknown)\n\t\t    && lhs.lhs_type->tt_member != &t_unknown)\n\t\t// Set the type in the list or dict, so that it can be checked,\n\t\t// also in legacy script.  Not for \"list<any> = val\", then the\n\t\t// type of \"val\" is used.\n\t\tgenerate_SETTYPE(cctx, lhs.lhs_type);\n\n\t    if (!skip_store && generate_store_lhs(cctx, &lhs,\n\t\t\t\t\t\t instr_count, is_decl) == FAIL)\n\t    {\n\t\tcctx->ctx_lnum = save_lnum;\n\t\tgoto theend;\n\t    }\n\t}\n\tcctx->ctx_lnum = save_lnum;\n\n\tif (var_idx + 1 < var_count)\n\t    var_start = skipwhite(lhs.lhs_end + 1);\n    }\n\n    // For \"[var, var] = expr\" drop the \"expr\" value.\n    // Also for \"[var, var; _] = expr\".\n    if (var_count > 0 && (!semicolon || !did_generate_slice))\n    {\n\tif (generate_instr_drop(cctx, ISN_DROP, 1) == NULL)\n\t    goto theend;\n    }\n\n    ret = skipwhite(end);\n\ntheend:\n    vim_free(lhs.lhs_name);\n    return ret;\n}\n\n/*\n * Check for an assignment at \"eap->cmd\", compile it if found.\n * Return NOTDONE if there is none, FAIL for failure, OK if done.\n */\n    static int\nmay_compile_assignment(exarg_T *eap, char_u **line, cctx_T *cctx)\n{\n    char_u  *pskip;\n    char_u  *p;\n\n    // Assuming the command starts with a variable or function name,\n    // find what follows.\n    // Skip over \"var.member\", \"var[idx]\" and the like.\n    // Also \"&opt = val\", \"$ENV = val\" and \"@r = val\".\n    pskip = (*eap->cmd == '&' || *eap->cmd == '$' || *eap->cmd == '@')\n\t\t\t\t\t\t ? eap->cmd + 1 : eap->cmd;\n    p = to_name_end(pskip, TRUE);\n    if (p > eap->cmd && *p != NUL)\n    {\n\tchar_u *var_end;\n\tint\toplen;\n\tint\theredoc;\n\n\tif (eap->cmd[0] == '@')\n\t    var_end = eap->cmd + 2;\n\telse\n\t    var_end = find_name_end(pskip, NULL, NULL,\n\t\t\t\t\tFNE_CHECK_START | FNE_INCL_BR);\n\toplen = assignment_len(skipwhite(var_end), &heredoc);\n\tif (oplen > 0)\n\t{\n\t    size_t len = p - eap->cmd;\n\n\t    // Recognize an assignment if we recognize the variable\n\t    // name:\n\t    // \"g:var = expr\"\n\t    // \"local = expr\"  where \"local\" is a local var.\n\t    // \"script = expr\"  where \"script\" is a script-local var.\n\t    // \"import = expr\"  where \"import\" is an imported var\n\t    // \"&opt = expr\"\n\t    // \"$ENV = expr\"\n\t    // \"@r = expr\"\n\t    if (*eap->cmd == '&'\n\t\t    || *eap->cmd == '$'\n\t\t    || *eap->cmd == '@'\n\t\t    || ((len) > 2 && eap->cmd[1] == ':')\n\t\t    || variable_exists(eap->cmd, len, cctx))\n\t    {\n\t\t*line = compile_assignment(eap->cmd, eap, CMD_SIZE, cctx);\n\t\tif (*line == NULL || *line == eap->cmd)\n\t\t    return FAIL;\n\t\treturn OK;\n\t    }\n\t}\n    }\n\n    if (*eap->cmd == '[')\n    {\n\t// [var, var] = expr\n\t*line = compile_assignment(eap->cmd, eap, CMD_SIZE, cctx);\n\tif (*line == NULL)\n\t    return FAIL;\n\tif (*line != eap->cmd)\n\t    return OK;\n    }\n    return NOTDONE;\n}\n\n\n/*\n * Add a function to the list of :def functions.\n * This sets \"ufunc->uf_dfunc_idx\" but the function isn't compiled yet.\n */\n    static int\nadd_def_function(ufunc_T *ufunc)\n{\n    dfunc_T *dfunc;\n\n    if (def_functions.ga_len == 0)\n    {\n\t// The first position is not used, so that a zero uf_dfunc_idx means it\n\t// wasn't set.\n\tif (GA_GROW_FAILS(&def_functions, 1))\n\t    return FAIL;\n\t++def_functions.ga_len;\n    }\n\n    // Add the function to \"def_functions\".\n    if (GA_GROW_FAILS(&def_functions, 1))\n\treturn FAIL;\n    dfunc = ((dfunc_T *)def_functions.ga_data) + def_functions.ga_len;\n    CLEAR_POINTER(dfunc);\n    dfunc->df_idx = def_functions.ga_len;\n    ufunc->uf_dfunc_idx = dfunc->df_idx;\n    dfunc->df_ufunc = ufunc;\n    dfunc->df_name = vim_strsave(ufunc->uf_name);\n    ga_init2(&dfunc->df_var_names, sizeof(char_u *), 10);\n    ++dfunc->df_refcount;\n    ++def_functions.ga_len;\n    return OK;\n}\n\n/*\n * After ex_function() has collected all the function lines: parse and compile\n * the lines into instructions.\n * Adds the function to \"def_functions\".\n * When \"check_return_type\" is set then set ufunc->uf_ret_type to the type of\n * the return statement (used for lambda).  When uf_ret_type is already set\n * then check that it matches.\n * When \"profiling\" is true add ISN_PROF_START instructions.\n * \"outer_cctx\" is set for a nested function.\n * This can be used recursively through compile_lambda(), which may reallocate\n * \"def_functions\".\n * Returns OK or FAIL.\n */\n    int\ncompile_def_function(\n\tufunc_T\t\t*ufunc,\n\tint\t\tcheck_return_type,\n\tcompiletype_T   compile_type,\n\tcctx_T\t\t*outer_cctx)\n{\n    char_u\t*line = NULL;\n    char_u\t*line_to_free = NULL;\n    char_u\t*p;\n    char\t*errormsg = NULL;\t// error message\n    cctx_T\tcctx;\n    garray_T\t*instr;\n    int\t\tdid_emsg_before = did_emsg;\n    int\t\tdid_emsg_silent_before = did_emsg_silent;\n    int\t\tret = FAIL;\n    sctx_T\tsave_current_sctx = current_sctx;\n    int\t\tsave_estack_compiling = estack_compiling;\n    int\t\tsave_cmod_flags = cmdmod.cmod_flags;\n    int\t\tdo_estack_push;\n    int\t\tnew_def_function = FALSE;\n#ifdef FEAT_PROFILE\n    int\t\tprof_lnum = -1;\n#endif\n    int\t\tdebug_lnum = -1;\n\n    // When using a function that was compiled before: Free old instructions.\n    // The index is reused.  Otherwise add a new entry in \"def_functions\".\n    if (ufunc->uf_dfunc_idx > 0)\n    {\n\tdfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t + ufunc->uf_dfunc_idx;\n\tisn_T\t*instr_dest = NULL;\n\n\tswitch (compile_type)\n\t{\n\t    case CT_PROFILE:\n#ifdef FEAT_PROFILE\n\t\t\t    instr_dest = dfunc->df_instr_prof; break;\n#endif\n\t    case CT_NONE:   instr_dest = dfunc->df_instr; break;\n\t    case CT_DEBUG:  instr_dest = dfunc->df_instr_debug; break;\n\t}\n\tif (instr_dest != NULL)\n\t    // Was compiled in this mode before: Free old instructions.\n\t    delete_def_function_contents(dfunc, FALSE);\n\tga_clear_strings(&dfunc->df_var_names);\n    }\n    else\n    {\n\tif (add_def_function(ufunc) == FAIL)\n\t    return FAIL;\n\tnew_def_function = TRUE;\n    }\n\n    ufunc->uf_def_status = UF_COMPILING;\n\n    CLEAR_FIELD(cctx);\n\n    cctx.ctx_compile_type = compile_type;\n    cctx.ctx_ufunc = ufunc;\n    cctx.ctx_lnum = -1;\n    cctx.ctx_outer = outer_cctx;\n    ga_init2(&cctx.ctx_locals, sizeof(lvar_T), 10);\n    ga_init2(&cctx.ctx_type_stack, sizeof(type_T *), 50);\n    ga_init2(&cctx.ctx_imports, sizeof(imported_T), 10);\n    cctx.ctx_type_list = &ufunc->uf_type_list;\n    ga_init2(&cctx.ctx_instr, sizeof(isn_T), 50);\n    instr = &cctx.ctx_instr;\n\n    // Set the context to the function, it may be compiled when called from\n    // another script.  Set the script version to the most modern one.\n    // The line number will be set in next_line_from_context().\n    current_sctx = ufunc->uf_script_ctx;\n    current_sctx.sc_version = SCRIPT_VERSION_VIM9;\n\n    // Don't use the flag from \":legacy\" here.\n    cmdmod.cmod_flags &= ~CMOD_LEGACY;\n\n    // Make sure error messages are OK.\n    do_estack_push = !estack_top_is_ufunc(ufunc, 1);\n    if (do_estack_push)\n\testack_push_ufunc(ufunc, 1);\n    estack_compiling = TRUE;\n\n    if (ufunc->uf_def_args.ga_len > 0)\n    {\n\tint\tcount = ufunc->uf_def_args.ga_len;\n\tint\tfirst_def_arg = ufunc->uf_args.ga_len - count;\n\tint\ti;\n\tchar_u\t*arg;\n\tint\toff = STACK_FRAME_SIZE + (ufunc->uf_va_name != NULL ? 1 : 0);\n\tint\tdid_set_arg_type = FALSE;\n\n\t// Produce instructions for the default values of optional arguments.\n\tSOURCING_LNUM = 0;  // line number unknown\n\tfor (i = 0; i < count; ++i)\n\t{\n\t    garray_T\t*stack = &cctx.ctx_type_stack;\n\t    type_T\t*val_type;\n\t    int\t\targ_idx = first_def_arg + i;\n\t    where_T\twhere = WHERE_INIT;\n\t    int\t\tr;\n\t    int\t\tjump_instr_idx = instr->ga_len;\n\t    isn_T\t*isn;\n\n\t    // Use a JUMP_IF_ARG_SET instruction to skip if the value was given.\n\t    if (generate_JUMP_IF_ARG_SET(&cctx, i - count - off) == FAIL)\n\t\tgoto erret;\n\n\t    // Make sure later arguments are not found.\n\t    ufunc->uf_args_visible = arg_idx;\n\n\t    arg = ((char_u **)(ufunc->uf_def_args.ga_data))[i];\n\t    r = compile_expr0(&arg, &cctx);\n\n\t    if (r == FAIL)\n\t\tgoto erret;\n\n\t    // If no type specified use the type of the default value.\n\t    // Otherwise check that the default value type matches the\n\t    // specified type.\n\t    val_type = ((type_T **)stack->ga_data)[stack->ga_len - 1];\n\t    where.wt_index = arg_idx + 1;\n\t    if (ufunc->uf_arg_types[arg_idx] == &t_unknown)\n\t    {\n\t\tdid_set_arg_type = TRUE;\n\t\tufunc->uf_arg_types[arg_idx] = val_type;\n\t    }\n\t    else if (need_type_where(val_type, ufunc->uf_arg_types[arg_idx],\n\t\t\t\t       -1, where, &cctx, FALSE, FALSE) == FAIL)\n\t\tgoto erret;\n\n\t    if (generate_STORE(&cctx, ISN_STORE, i - count - off, NULL) == FAIL)\n\t\tgoto erret;\n\n\t    // set instruction index in JUMP_IF_ARG_SET to here\n\t    isn = ((isn_T *)instr->ga_data) + jump_instr_idx;\n\t    isn->isn_arg.jumparg.jump_where = instr->ga_len;\n\t}\n\n\tif (did_set_arg_type)\n\t    set_function_type(ufunc);\n    }\n    ufunc->uf_args_visible = ufunc->uf_args.ga_len;\n\n    /*\n     * Loop over all the lines of the function and generate instructions.\n     */\n    for (;;)\n    {\n\texarg_T\t    ea;\n\tint\t    starts_with_colon = FALSE;\n\tchar_u\t    *cmd;\n\tcmdmod_T    local_cmdmod;\n\n\t// Bail out on the first error to avoid a flood of errors and report\n\t// the right line number when inside try/catch.\n\tif (did_emsg_before != did_emsg)\n\t    goto erret;\n\n\tif (line != NULL && *line == '|')\n\t    // the line continues after a '|'\n\t    ++line;\n\telse if (line != NULL && *skipwhite(line) != NUL\n\t\t&& !(*line == '#' && (line == cctx.ctx_line_start\n\t\t\t\t\t\t    || VIM_ISWHITE(line[-1]))))\n\t{\n\t    semsg(_(e_trailing_arg), line);\n\t    goto erret;\n\t}\n\telse if (line != NULL && vim9_bad_comment(skipwhite(line)))\n\t    goto erret;\n\telse\n\t{\n\t    line = next_line_from_context(&cctx, FALSE);\n\t    if (cctx.ctx_lnum >= ufunc->uf_lines.ga_len)\n\t    {\n\t\t// beyond the last line\n#ifdef FEAT_PROFILE\n\t\tif (cctx.ctx_skip != SKIP_YES)\n\t\t    may_generate_prof_end(&cctx, prof_lnum);\n#endif\n\t\tbreak;\n\t    }\n\t    // Make a copy, splitting off nextcmd and removing trailing spaces\n\t    // may change it.\n\t    if (line != NULL)\n\t    {\n\t\tline = vim_strsave(line);\n\t\tvim_free(line_to_free);\n\t\tline_to_free = line;\n\t    }\n\t}\n\n\tCLEAR_FIELD(ea);\n\tea.cmdlinep = &line;\n\tea.cmd = skipwhite(line);\n\n\tif (*ea.cmd == '#')\n\t{\n\t    // \"#\" starts a comment\n\t    line = (char_u *)\"\";\n\t    continue;\n\t}\n\n#ifdef FEAT_PROFILE\n\tif (cctx.ctx_compile_type == CT_PROFILE && cctx.ctx_lnum != prof_lnum\n\t\t\t\t\t\t  && cctx.ctx_skip != SKIP_YES)\n\t{\n\t    may_generate_prof_end(&cctx, prof_lnum);\n\n\t    prof_lnum = cctx.ctx_lnum;\n\t    generate_instr(&cctx, ISN_PROF_START);\n\t}\n#endif\n\tif (cctx.ctx_compile_type == CT_DEBUG && cctx.ctx_lnum != debug_lnum\n\t\t\t\t\t\t  && cctx.ctx_skip != SKIP_YES)\n\t{\n\t    debug_lnum = cctx.ctx_lnum;\n\t    generate_instr_debug(&cctx);\n\t}\n\tcctx.ctx_prev_lnum = cctx.ctx_lnum + 1;\n\n\t// Some things can be recognized by the first character.\n\tswitch (*ea.cmd)\n\t{\n\t    case '}':\n\t\t{\n\t\t    // \"}\" ends a block scope\n\t\t    scopetype_T stype = cctx.ctx_scope == NULL\n\t\t\t\t\t  ? NO_SCOPE : cctx.ctx_scope->se_type;\n\n\t\t    if (stype == BLOCK_SCOPE)\n\t\t    {\n\t\t\tcompile_endblock(&cctx);\n\t\t\tline = ea.cmd;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\temsg(_(e_using_rcurly_outside_if_block_scope));\n\t\t\tgoto erret;\n\t\t    }\n\t\t    if (line != NULL)\n\t\t\tline = skipwhite(ea.cmd + 1);\n\t\t    continue;\n\t\t}\n\n\t    case '{':\n\t\t// \"{\" starts a block scope\n\t\t// \"{'a': 1}->func() is something else\n\t\tif (ends_excmd(*skipwhite(ea.cmd + 1)))\n\t\t{\n\t\t    line = compile_block(ea.cmd, &cctx);\n\t\t    continue;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/*\n\t * COMMAND MODIFIERS\n\t */\n\tcctx.ctx_has_cmdmod = FALSE;\n\tif (parse_command_modifiers(&ea, &errormsg, &local_cmdmod, FALSE)\n\t\t\t\t\t\t\t\t       == FAIL)\n\t{\n\t    if (errormsg != NULL)\n\t\tgoto erret;\n\t    // empty line or comment\n\t    line = (char_u *)\"\";\n\t    continue;\n\t}\n\tgenerate_cmdmods(&cctx, &local_cmdmod);\n\tundo_cmdmod(&local_cmdmod);\n\n\t// Check if there was a colon after the last command modifier or before\n\t// the current position.\n\tfor (p = ea.cmd; p >= line; --p)\n\t{\n\t    if (*p == ':')\n\t\tstarts_with_colon = TRUE;\n\t    if (p < ea.cmd && !VIM_ISWHITE(*p))\n\t\tbreak;\n\t}\n\n\t// Skip \":call\" to get to the function name, unless using :legacy\n\tp = ea.cmd;\n\tif (!(local_cmdmod.cmod_flags & CMOD_LEGACY))\n\t{\n\t    if (checkforcmd(&ea.cmd, \"call\", 3))\n\t    {\n\t\tif (*ea.cmd == '(')\n\t\t    // not for \"call()\"\n\t\t    ea.cmd = p;\n\t\telse\n\t\t    ea.cmd = skipwhite(ea.cmd);\n\t    }\n\n\t    if (!starts_with_colon)\n\t    {\n\t\tint\t    assign;\n\n\t\t// Check for assignment after command modifiers.\n\t\tassign = may_compile_assignment(&ea, &line, &cctx);\n\t\tif (assign == OK)\n\t\t    goto nextline;\n\t\tif (assign == FAIL)\n\t\t    goto erret;\n\t    }\n\t}\n\n\t/*\n\t * COMMAND after range\n\t * 'text'->func() should not be confused with 'a mark\n\t * \"++nr\" and \"--nr\" are eval commands\n\t * in \"$ENV->func()\" the \"$\" is not a range\n\t */\n\tcmd = ea.cmd;\n\tif ((*cmd != '$' || starts_with_colon)\n\t\t&& (starts_with_colon || !(*cmd == '\\''\n\t\t       || (cmd[0] == cmd[1] && (*cmd == '+' || *cmd == '-')))))\n\t{\n\t    ea.cmd = skip_range(ea.cmd, TRUE, NULL);\n\t    if (ea.cmd > cmd)\n\t    {\n\t\tif (!starts_with_colon\n\t\t\t\t   && !(local_cmdmod.cmod_flags & CMOD_LEGACY))\n\t\t{\n\t\t    semsg(_(e_colon_required_before_range_str), cmd);\n\t\t    goto erret;\n\t\t}\n\t\tea.addr_count = 1;\n\t\tif (ends_excmd2(line, ea.cmd))\n\t\t{\n\t\t    // A range without a command: jump to the line.\n\t\t    generate_EXEC(&cctx, ISN_EXECRANGE,\n\t\t\t\t\t      vim_strnsave(cmd, ea.cmd - cmd));\n\t\t    line = ea.cmd;\n\t\t    goto nextline;\n\t\t}\n\t    }\n\t}\n\tp = find_ex_command(&ea, NULL,\n\t\tstarts_with_colon || (local_cmdmod.cmod_flags & CMOD_LEGACY)\n\t\t\t\t\t\t  ? NULL : item_exists, &cctx);\n\n\tif (p == NULL)\n\t{\n\t    if (cctx.ctx_skip != SKIP_YES)\n\t\temsg(_(e_ambiguous_use_of_user_defined_command));\n\t    goto erret;\n\t}\n\n\t// When using \":legacy cmd\" always use compile_exec().\n\tif (local_cmdmod.cmod_flags & CMOD_LEGACY)\n\t{\n\t    char_u *start = ea.cmd;\n\n\t    switch (ea.cmdidx)\n\t    {\n\t\tcase CMD_if:\n\t\tcase CMD_elseif:\n\t\tcase CMD_else:\n\t\tcase CMD_endif:\n\t\tcase CMD_for:\n\t\tcase CMD_endfor:\n\t\tcase CMD_continue:\n\t\tcase CMD_break:\n\t\tcase CMD_while:\n\t\tcase CMD_endwhile:\n\t\tcase CMD_try:\n\t\tcase CMD_catch:\n\t\tcase CMD_finally:\n\t\tcase CMD_endtry:\n\t\t\tsemsg(_(e_cannot_use_legacy_with_command_str), ea.cmd);\n\t\t\tgoto erret;\n\t\tdefault: break;\n\t    }\n\n\t    // \":legacy return expr\" needs to be handled differently.\n\t    if (checkforcmd(&start, \"return\", 4))\n\t\tea.cmdidx = CMD_return;\n\t    else\n\t\tea.cmdidx = CMD_legacy;\n\t}\n\n\tif (p == ea.cmd && ea.cmdidx != CMD_SIZE)\n\t{\n\t    if (cctx.ctx_skip == SKIP_YES && ea.cmdidx != CMD_eval)\n\t    {\n\t\tline += STRLEN(line);\n\t\tgoto nextline;\n\t    }\n\t    else if (ea.cmdidx != CMD_eval)\n\t    {\n\t\t// CMD_var cannot happen, compile_assignment() above would be\n\t\t// used.  Most likely an assignment to a non-existing variable.\n\t\tsemsg(_(e_command_not_recognized_str), ea.cmd);\n\t\tgoto erret;\n\t    }\n\t}\n\n\tif (cctx.ctx_had_return\n\t\t&& ea.cmdidx != CMD_elseif\n\t\t&& ea.cmdidx != CMD_else\n\t\t&& ea.cmdidx != CMD_endif\n\t\t&& ea.cmdidx != CMD_endfor\n\t\t&& ea.cmdidx != CMD_endwhile\n\t\t&& ea.cmdidx != CMD_catch\n\t\t&& ea.cmdidx != CMD_finally\n\t\t&& ea.cmdidx != CMD_endtry)\n\t{\n\t    emsg(_(e_unreachable_code_after_return));\n\t    goto erret;\n\t}\n\n\tp = skipwhite(p);\n\tif (ea.cmdidx != CMD_SIZE\n\t\t\t    && ea.cmdidx != CMD_write && ea.cmdidx != CMD_read)\n\t{\n\t    if (ea.cmdidx >= 0)\n\t\tea.argt = excmd_get_argt(ea.cmdidx);\n\t    if ((ea.argt & EX_BANG) && *p == '!')\n\t    {\n\t\tea.forceit = TRUE;\n\t\tp = skipwhite(p + 1);\n\t    }\n\t}\n\n\tswitch (ea.cmdidx)\n\t{\n\t    case CMD_def:\n\t    case CMD_function:\n\t\t    ea.arg = p;\n\t\t    line = compile_nested_function(&ea, &cctx, &line_to_free);\n\t\t    break;\n\n\t    case CMD_return:\n\t\t    line = compile_return(p, check_return_type,\n\t\t\t\t local_cmdmod.cmod_flags & CMOD_LEGACY, &cctx);\n\t\t    cctx.ctx_had_return = TRUE;\n\t\t    break;\n\n\t    case CMD_let:\n\t\t    emsg(_(e_cannot_use_let_in_vim9_script));\n\t\t    break;\n\t    case CMD_var:\n\t    case CMD_final:\n\t    case CMD_const:\n\t    case CMD_increment:\n\t    case CMD_decrement:\n\t\t    line = compile_assignment(p, &ea, ea.cmdidx, &cctx);\n\t\t    if (line == p)\n\t\t\tline = NULL;\n\t\t    break;\n\n\t    case CMD_unlet:\n\t    case CMD_unlockvar:\n\t    case CMD_lockvar:\n\t\t    line = compile_unletlock(p, &ea, &cctx);\n\t\t    break;\n\n\t    case CMD_import:\n\t\t    emsg(_(e_import_can_only_be_used_in_script));\n\t\t    line = NULL;\n\t\t    break;\n\n\t    case CMD_if:\n\t\t    line = compile_if(p, &cctx);\n\t\t    break;\n\t    case CMD_elseif:\n\t\t    line = compile_elseif(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\t    case CMD_else:\n\t\t    line = compile_else(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\t    case CMD_endif:\n\t\t    line = compile_endif(p, &cctx);\n\t\t    break;\n\n\t    case CMD_while:\n\t\t    line = compile_while(p, &cctx);\n\t\t    break;\n\t    case CMD_endwhile:\n\t\t    line = compile_endwhile(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\n\t    case CMD_for:\n\t\t    line = compile_for(p, &cctx);\n\t\t    break;\n\t    case CMD_endfor:\n\t\t    line = compile_endfor(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\t    case CMD_continue:\n\t\t    line = compile_continue(p, &cctx);\n\t\t    break;\n\t    case CMD_break:\n\t\t    line = compile_break(p, &cctx);\n\t\t    break;\n\n\t    case CMD_try:\n\t\t    line = compile_try(p, &cctx);\n\t\t    break;\n\t    case CMD_catch:\n\t\t    line = compile_catch(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\t    case CMD_finally:\n\t\t    line = compile_finally(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\t    case CMD_endtry:\n\t\t    line = compile_endtry(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\t    case CMD_throw:\n\t\t    line = compile_throw(p, &cctx);\n\t\t    break;\n\n\t    case CMD_eval:\n\t\t    line = compile_eval(p, &cctx);\n\t\t    break;\n\n\t    case CMD_echo:\n\t    case CMD_echon:\n\t    case CMD_execute:\n\t    case CMD_echomsg:\n\t    case CMD_echoerr:\n\t    case CMD_echoconsole:\n\t\t    line = compile_mult_expr(p, ea.cmdidx, &cctx);\n\t\t    break;\n\n\t    case CMD_put:\n\t\t    ea.cmd = cmd;\n\t\t    line = compile_put(p, &ea, &cctx);\n\t\t    break;\n\n\t    case CMD_substitute:\n\t\t    if (check_global_and_subst(ea.cmd, p) == FAIL)\n\t\t\tgoto erret;\n\t\t    if (cctx.ctx_skip == SKIP_YES)\n\t\t\tline = (char_u *)\"\";\n\t\t    else\n\t\t    {\n\t\t\tea.arg = p;\n\t\t\tline = compile_substitute(line, &ea, &cctx);\n\t\t    }\n\t\t    break;\n\n\t    case CMD_redir:\n\t\t    ea.arg = p;\n\t\t    line = compile_redir(line, &ea, &cctx);\n\t\t    break;\n\n\t    case CMD_cexpr:\n\t    case CMD_lexpr:\n\t    case CMD_caddexpr:\n\t    case CMD_laddexpr:\n\t    case CMD_cgetexpr:\n\t    case CMD_lgetexpr:\n#ifdef FEAT_QUICKFIX\n\t\t    ea.arg = p;\n\t\t    line = compile_cexpr(line, &ea, &cctx);\n#else\n\t\t    ex_ni(&ea);\n\t\t    line = NULL;\n#endif\n\t\t    break;\n\n\t    case CMD_append:\n\t    case CMD_change:\n\t    case CMD_insert:\n\t    case CMD_k:\n\t    case CMD_t:\n\t    case CMD_xit:\n\t\t    not_in_vim9(&ea);\n\t\t    goto erret;\n\n\t    case CMD_SIZE:\n\t\t    if (cctx.ctx_skip != SKIP_YES)\n\t\t    {\n\t\t\tsemsg(_(e_invalid_command_str), ea.cmd);\n\t\t\tgoto erret;\n\t\t    }\n\t\t    // We don't check for a next command here.\n\t\t    line = (char_u *)\"\";\n\t\t    break;\n\n\t    case CMD_lua:\n\t    case CMD_mzscheme:\n\t    case CMD_perl:\n\t    case CMD_py3:\n\t    case CMD_python3:\n\t    case CMD_python:\n\t    case CMD_pythonx:\n\t    case CMD_ruby:\n\t    case CMD_tcl:\n\t\t    ea.arg = p;\n\t\t    if (vim_strchr(line, '\\n') == NULL)\n\t\t\tline = compile_exec(line, &ea, &cctx);\n\t\t    else\n\t\t\t// heredoc lines have been concatenated with NL\n\t\t\t// characters in get_function_body()\n\t\t\tline = compile_script(line, &cctx);\n\t\t    break;\n\n\t    case CMD_global:\n\t\t    if (check_global_and_subst(ea.cmd, p) == FAIL)\n\t\t\tgoto erret;\n\t\t    // FALLTHROUGH\n\t    default:\n\t\t    // Not recognized, execute with do_cmdline_cmd().\n\t\t    ea.arg = p;\n\t\t    line = compile_exec(line, &ea, &cctx);\n\t\t    break;\n\t}\nnextline:\n\tif (line == NULL)\n\t    goto erret;\n\tline = skipwhite(line);\n\n\t// Undo any command modifiers.\n\tgenerate_undo_cmdmods(&cctx);\n\n\tif (cctx.ctx_type_stack.ga_len < 0)\n\t{\n\t    iemsg(\"Type stack underflow\");\n\t    goto erret;\n\t}\n    }\n\n    if (cctx.ctx_scope != NULL)\n    {\n\tif (cctx.ctx_scope->se_type == IF_SCOPE)\n\t    emsg(_(e_endif));\n\telse if (cctx.ctx_scope->se_type == WHILE_SCOPE)\n\t    emsg(_(e_endwhile));\n\telse if (cctx.ctx_scope->se_type == FOR_SCOPE)\n\t    emsg(_(e_endfor));\n\telse\n\t    emsg(_(e_missing_rcurly));\n\tgoto erret;\n    }\n\n    if (!cctx.ctx_had_return)\n    {\n\tif (ufunc->uf_ret_type->tt_type == VAR_UNKNOWN)\n\t    ufunc->uf_ret_type = &t_void;\n\telse if (ufunc->uf_ret_type->tt_type != VAR_VOID)\n\t{\n\t    emsg(_(e_missing_return_statement));\n\t    goto erret;\n\t}\n\n\t// Return void if there is no return at the end.\n\tgenerate_instr(&cctx, ISN_RETURN_VOID);\n    }\n\n    // When compiled with \":silent!\" and there was an error don't consider the\n    // function compiled.\n    if (emsg_silent == 0 || did_emsg_silent == did_emsg_silent_before)\n    {\n\tdfunc_T\t*dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t + ufunc->uf_dfunc_idx;\n\tdfunc->df_deleted = FALSE;\n\tdfunc->df_script_seq = current_sctx.sc_seq;\n#ifdef FEAT_PROFILE\n\tif (cctx.ctx_compile_type == CT_PROFILE)\n\t{\n\t    dfunc->df_instr_prof = instr->ga_data;\n\t    dfunc->df_instr_prof_count = instr->ga_len;\n\t}\n\telse\n#endif\n\tif (cctx.ctx_compile_type == CT_DEBUG)\n\t{\n\t    dfunc->df_instr_debug = instr->ga_data;\n\t    dfunc->df_instr_debug_count = instr->ga_len;\n\t}\n\telse\n\t{\n\t    dfunc->df_instr = instr->ga_data;\n\t    dfunc->df_instr_count = instr->ga_len;\n\t}\n\tdfunc->df_varcount = dfunc->df_var_names.ga_len;\n\tdfunc->df_has_closure = cctx.ctx_has_closure;\n\tif (cctx.ctx_outer_used)\n\t    ufunc->uf_flags |= FC_CLOSURE;\n\tufunc->uf_def_status = UF_COMPILED;\n    }\n\n    ret = OK;\n\nerret:\n    if (ufunc->uf_def_status == UF_COMPILING)\n    {\n\tdfunc_T\t*dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t + ufunc->uf_dfunc_idx;\n\n\t// Compiling aborted, free the generated instructions.\n\tclear_instr_ga(instr);\n\tVIM_CLEAR(dfunc->df_name);\n\tga_clear_strings(&dfunc->df_var_names);\n\n\t// If using the last entry in the table and it was added above, we\n\t// might as well remove it.\n\tif (!dfunc->df_deleted && new_def_function\n\t\t\t    && ufunc->uf_dfunc_idx == def_functions.ga_len - 1)\n\t{\n\t    --def_functions.ga_len;\n\t    ufunc->uf_dfunc_idx = 0;\n\t}\n\tufunc->uf_def_status = UF_COMPILE_ERROR;\n\n\twhile (cctx.ctx_scope != NULL)\n\t    drop_scope(&cctx);\n\n\tif (errormsg != NULL)\n\t    emsg(errormsg);\n\telse if (did_emsg == did_emsg_before)\n\t    emsg(_(e_compiling_def_function_failed));\n    }\n\n    if (cctx.ctx_redir_lhs.lhs_name != NULL)\n    {\n\tif (ret == OK)\n\t{\n\t    emsg(_(e_missing_redir_end));\n\t    ret = FAIL;\n\t}\n\tvim_free(cctx.ctx_redir_lhs.lhs_name);\n\tvim_free(cctx.ctx_redir_lhs.lhs_whole);\n    }\n\n    current_sctx = save_current_sctx;\n    estack_compiling = save_estack_compiling;\n    cmdmod.cmod_flags =\tsave_cmod_flags;\n    if (do_estack_push)\n\testack_pop();\n\n    vim_free(line_to_free);\n    free_imported(&cctx);\n    free_locals(&cctx);\n    ga_clear(&cctx.ctx_type_stack);\n    return ret;\n}\n\n    void\nset_function_type(ufunc_T *ufunc)\n{\n    int varargs = ufunc->uf_va_name != NULL;\n    int argcount = ufunc->uf_args.ga_len;\n\n    // Create a type for the function, with the return type and any\n    // argument types.\n    // A vararg is included in uf_args.ga_len but not in uf_arg_types.\n    // The type is included in \"tt_args\".\n    if (argcount > 0 || varargs)\n    {\n\tif (ufunc->uf_type_list.ga_itemsize == 0)\n\t    ga_init2(&ufunc->uf_type_list, sizeof(type_T *), 10);\n\tufunc->uf_func_type = alloc_func_type(ufunc->uf_ret_type,\n\t\t\t\t\t   argcount, &ufunc->uf_type_list);\n\t// Add argument types to the function type.\n\tif (func_type_add_arg_types(ufunc->uf_func_type,\n\t\t\t\t    argcount + varargs,\n\t\t\t\t    &ufunc->uf_type_list) == FAIL)\n\t    return;\n\tufunc->uf_func_type->tt_argcount = argcount + varargs;\n\tufunc->uf_func_type->tt_min_argcount =\n\t\t\t\t      argcount - ufunc->uf_def_args.ga_len;\n\tif (ufunc->uf_arg_types == NULL)\n\t{\n\t    int i;\n\n\t    // lambda does not have argument types.\n\t    for (i = 0; i < argcount; ++i)\n\t\tufunc->uf_func_type->tt_args[i] = &t_any;\n\t}\n\telse\n\t    mch_memmove(ufunc->uf_func_type->tt_args,\n\t\t\t ufunc->uf_arg_types, sizeof(type_T *) * argcount);\n\tif (varargs)\n\t{\n\t    ufunc->uf_func_type->tt_args[argcount] =\n\t\t   ufunc->uf_va_type == NULL ? &t_list_any : ufunc->uf_va_type;\n\t    ufunc->uf_func_type->tt_flags = TTFLAG_VARARGS;\n\t}\n    }\n    else\n\t// No arguments, can use a predefined type.\n\tufunc->uf_func_type = get_func_type(ufunc->uf_ret_type,\n\t\t\t\t\t   argcount, &ufunc->uf_type_list);\n}\n\n/*\n * Free all instructions for \"dfunc\" except df_name.\n */\n    static void\ndelete_def_function_contents(dfunc_T *dfunc, int mark_deleted)\n{\n    int idx;\n\n    ga_clear(&dfunc->df_def_args_isn);\n    ga_clear_strings(&dfunc->df_var_names);\n\n    if (dfunc->df_instr != NULL)\n    {\n\tfor (idx = 0; idx < dfunc->df_instr_count; ++idx)\n\t    delete_instr(dfunc->df_instr + idx);\n\tVIM_CLEAR(dfunc->df_instr);\n\tdfunc->df_instr = NULL;\n    }\n    if (dfunc->df_instr_debug != NULL)\n    {\n\tfor (idx = 0; idx < dfunc->df_instr_debug_count; ++idx)\n\t    delete_instr(dfunc->df_instr_debug + idx);\n\tVIM_CLEAR(dfunc->df_instr_debug);\n\tdfunc->df_instr_debug = NULL;\n    }\n#ifdef FEAT_PROFILE\n    if (dfunc->df_instr_prof != NULL)\n    {\n\tfor (idx = 0; idx < dfunc->df_instr_prof_count; ++idx)\n\t    delete_instr(dfunc->df_instr_prof + idx);\n\tVIM_CLEAR(dfunc->df_instr_prof);\n\tdfunc->df_instr_prof = NULL;\n    }\n#endif\n\n    if (mark_deleted)\n\tdfunc->df_deleted = TRUE;\n    if (dfunc->df_ufunc != NULL)\n\tdfunc->df_ufunc->uf_def_status = UF_NOT_COMPILED;\n}\n\n/*\n * When a user function is deleted, clear the contents of any associated def\n * function, unless another user function still uses it.\n * The position in def_functions can be re-used.\n */\n    void\nunlink_def_function(ufunc_T *ufunc)\n{\n    if (ufunc->uf_dfunc_idx > 0)\n    {\n\tdfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t + ufunc->uf_dfunc_idx;\n\n\tif (--dfunc->df_refcount <= 0)\n\t    delete_def_function_contents(dfunc, TRUE);\n\tufunc->uf_def_status = UF_NOT_COMPILED;\n\tufunc->uf_dfunc_idx = 0;\n\tif (dfunc->df_ufunc == ufunc)\n\t    dfunc->df_ufunc = NULL;\n    }\n}\n\n/*\n * Used when a user function refers to an existing dfunc.\n */\n    void\nlink_def_function(ufunc_T *ufunc)\n{\n    if (ufunc->uf_dfunc_idx > 0)\n    {\n\tdfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t + ufunc->uf_dfunc_idx;\n\n\t++dfunc->df_refcount;\n    }\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n/*\n * Free all functions defined with \":def\".\n */\n    void\nfree_def_functions(void)\n{\n    int idx;\n\n    for (idx = 0; idx < def_functions.ga_len; ++idx)\n    {\n\tdfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data) + idx;\n\n\tdelete_def_function_contents(dfunc, TRUE);\n\tvim_free(dfunc->df_name);\n    }\n\n    ga_clear(&def_functions);\n}\n#endif\n\n\n#endif // FEAT_EVAL\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * vim9execute.c: execute Vim9 script instructions\n */\n\n#define USING_FLOAT_STUFF\n#include \"vim.h\"\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n\n// When not generating protos this is included in proto.h\n#ifdef PROTO\n# include \"vim9.h\"\n#endif\n\n\n// Structure put on ec_trystack when ISN_TRY is encountered.\ntypedef struct {\n    int\t    tcd_frame_idx;\t// ec_frame_idx at ISN_TRY\n    int\t    tcd_stack_len;\t// size of ectx.ec_stack at ISN_TRY\n    int\t    tcd_in_catch;\t// in catch or finally block\n    int\t    tcd_did_throw;\t// set did_throw in :endtry\n    int\t    tcd_catch_idx;\t// instruction of the first :catch or :finally\n    int\t    tcd_finally_idx;\t// instruction of the :finally block or zero\n    int\t    tcd_endtry_idx;\t// instruction of the :endtry\n    int\t    tcd_caught;\t\t// catch block entered\n    int\t    tcd_cont;\t\t// :continue encountered, jump here (minus one)\n    int\t    tcd_return;\t\t// when TRUE return from end of :finally\n} trycmd_T;\n\n// Data local to a function.\n// On a function call, if not empty, is saved on the stack and restored when\n// returning.\ntypedef struct {\n    int\t\tfloc_restore_cmdmod;\n    cmdmod_T\tfloc_save_cmdmod;\n    int\t\tfloc_restore_cmdmod_stacklen;\n} funclocal_T;\n\n// Structure to hold a reference to an outer_T, with information of whether it\n// was allocated.\ntypedef struct {\n    outer_T\t*or_outer;\n    partial_T\t*or_partial;\t// decrement \"or_partial->pt_refcount\" later\n    int\t\tor_outer_allocated;  // free \"or_outer\" later\n} outer_ref_T;\n\n// A stack is used to store:\n// - arguments passed to a :def function\n// - info about the calling function, to use when returning\n// - local variables\n// - temporary values\n//\n// In detail (FP == Frame Pointer):\n//\t  arg1\t\tfirst argument from caller (if present)\n//\t  arg2\t\tsecond argument from caller (if present)\n//\t  extra_arg1\tany missing optional argument default value\n// FP ->  cur_func\tcalling function\n//        current\tprevious instruction pointer\n//        frame_ptr\tprevious Frame Pointer\n//        var1\t\tspace for local variable\n//        var2\t\tspace for local variable\n//        ....\t\tfixed space for max. number of local variables\n//        temp\t\ttemporary values\n//        ....\t\tflexible space for temporary values (can grow big)\n\n/*\n * Execution context.\n */\nstruct ectx_S {\n    garray_T\tec_stack;\t// stack of typval_T values\n    int\t\tec_frame_idx;\t// index in ec_stack: context of ec_dfunc_idx\n    int\t\tec_initial_frame_idx;\t// frame index when called\n\n    outer_ref_T\t*ec_outer_ref;\t// outer scope used for closures, allocated\n    funclocal_T ec_funclocal;\n\n    garray_T\tec_trystack;\t// stack of trycmd_T values\n\n    isn_T\t*ec_instr;\t// array with instructions\n    int\t\tec_dfunc_idx;\t// current function index\n    int\t\tec_iidx;\t// index in ec_instr: instruction to execute\n\n    garray_T\tec_funcrefs;\t// partials that might be a closure\n\n    int\t\tec_did_emsg_before;\n    int\t\tec_trylevel_at_start;\n    where_T\tec_where;\n};\n\n#ifdef FEAT_PROFILE\n// stack of profinfo_T used when profiling.\nstatic garray_T profile_info_ga = {0, 0, sizeof(profinfo_T), 20, NULL};\n#endif\n\n// Get pointer to item relative to the bottom of the stack, -1 is the last one.\n#define STACK_TV_BOT(idx) (((typval_T *)ectx->ec_stack.ga_data) + ectx->ec_stack.ga_len + (idx))\n\n    void\nto_string_error(vartype_T vartype)\n{\n    semsg(_(e_cannot_convert_str_to_string), vartype_name(vartype));\n}\n\n/*\n * Return the number of arguments, including optional arguments and any vararg.\n */\n    static int\nufunc_argcount(ufunc_T *ufunc)\n{\n    return ufunc->uf_args.ga_len + (ufunc->uf_va_name != NULL ? 1 : 0);\n}\n\n/*\n * Create a new list from \"count\" items at the bottom of the stack.\n * When \"count\" is zero an empty list is added to the stack.\n */\n    static int\nexe_newlist(int count, ectx_T *ectx)\n{\n    list_T\t*list = list_alloc_with_items(count);\n    int\t\tidx;\n    typval_T\t*tv;\n\n    if (list == NULL)\n\treturn FAIL;\n    for (idx = 0; idx < count; ++idx)\n\tlist_set_item(list, idx, STACK_TV_BOT(idx - count));\n\n    if (count > 0)\n\tectx->ec_stack.ga_len -= count - 1;\n    else if (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\treturn FAIL;\n    else\n\t++ectx->ec_stack.ga_len;\n    tv = STACK_TV_BOT(-1);\n    tv->v_type = VAR_LIST;\n    tv->vval.v_list = list;\n    ++list->lv_refcount;\n    return OK;\n}\n\n/*\n * If debug_tick changed check if \"ufunc\" has a breakpoint and update\n * \"uf_has_breakpoint\".\n */\n    static void\nupdate_has_breakpoint(ufunc_T *ufunc)\n{\n    if (ufunc->uf_debug_tick != debug_tick)\n    {\n\tlinenr_T breakpoint;\n\n\tufunc->uf_debug_tick = debug_tick;\n\tbreakpoint = dbg_find_breakpoint(FALSE, ufunc->uf_name, 0);\n\tufunc->uf_has_breakpoint = breakpoint > 0;\n    }\n}\n\nstatic garray_T dict_stack = GA_EMPTY;\n\n/*\n * Put a value on the dict stack.  This consumes \"tv\".\n */\n    static int\ndict_stack_save(typval_T *tv)\n{\n    if (dict_stack.ga_growsize == 0)\n\tga_init2(&dict_stack, (int)sizeof(typval_T), 10);\n    if (ga_grow(&dict_stack, 1) == FAIL)\n\treturn FAIL;\n    ((typval_T *)dict_stack.ga_data)[dict_stack.ga_len] = *tv;\n    ++dict_stack.ga_len;\n    return OK;\n}\n\n/*\n * Get the typval at top of the dict stack.\n */\n    static typval_T *\ndict_stack_get_tv(void)\n{\n    if (dict_stack.ga_len == 0)\n\treturn NULL;\n    return ((typval_T *)dict_stack.ga_data) + dict_stack.ga_len - 1;\n}\n\n/*\n * Get the dict at top of the dict stack.\n */\n    static dict_T *\ndict_stack_get_dict(void)\n{\n    typval_T *tv;\n\n    if (dict_stack.ga_len == 0)\n\treturn NULL;\n    tv = ((typval_T *)dict_stack.ga_data) + dict_stack.ga_len - 1;\n    if (tv->v_type == VAR_DICT)\n\treturn tv->vval.v_dict;\n    return NULL;\n}\n\n/*\n * Drop an item from the dict stack.\n */\n    static void\ndict_stack_drop(void)\n{\n    if (dict_stack.ga_len == 0)\n    {\n\tiemsg(\"Dict stack underflow\");\n\treturn;\n    }\n    --dict_stack.ga_len;\n    clear_tv(((typval_T *)dict_stack.ga_data) + dict_stack.ga_len);\n}\n\n/*\n * Drop items from the dict stack until the length is equal to \"len\".\n */\n    static void\ndict_stack_clear(int len)\n{\n    while (dict_stack.ga_len > len)\n\tdict_stack_drop();\n}\n\n/*\n * Call compiled function \"cdf_idx\" from compiled code.\n * This adds a stack frame and sets the instruction pointer to the start of the\n * called function.\n * If \"pt\" is not null use \"pt->pt_outer\" for ec_outer_ref->or_outer.\n *\n * Stack has:\n * - current arguments (already there)\n * - omitted optional argument (default values) added here\n * - stack frame:\n *\t- pointer to calling function\n *\t- Index of next instruction in calling function\n *\t- previous frame pointer\n * - reserved space for local variables\n */\n    static int\ncall_dfunc(\n\tint\t\tcdf_idx,\n\tpartial_T\t*pt,\n\tint\t\targcount_arg,\n\tectx_T\t\t*ectx)\n{\n    int\t\targcount = argcount_arg;\n    dfunc_T\t*dfunc = ((dfunc_T *)def_functions.ga_data) + cdf_idx;\n    ufunc_T\t*ufunc = dfunc->df_ufunc;\n    int\t\tdid_emsg_before = did_emsg_cumul + did_emsg;\n    int\t\targ_to_add;\n    int\t\tvararg_count = 0;\n    int\t\tvarcount;\n    int\t\tidx;\n    estack_T\t*entry;\n    funclocal_T\t*floc = NULL;\n    int\t\tres = OK;\n\n    if (dfunc->df_deleted)\n    {\n\t// don't use ufunc->uf_name, it may have been freed\n\temsg_funcname(e_func_deleted,\n\t\tdfunc->df_name == NULL ? (char_u *)\"unknown\" : dfunc->df_name);\n\treturn FAIL;\n    }\n\n#ifdef FEAT_PROFILE\n    if (do_profiling == PROF_YES)\n    {\n\tif (GA_GROW_OK(&profile_info_ga, 1))\n\t{\n\t    profinfo_T *info = ((profinfo_T *)profile_info_ga.ga_data)\n\t\t\t\t\t\t      + profile_info_ga.ga_len;\n\t    ++profile_info_ga.ga_len;\n\t    CLEAR_POINTER(info);\n\t    profile_may_start_func(info, ufunc,\n\t\t\t(((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t      + ectx->ec_dfunc_idx)->df_ufunc);\n\t}\n    }\n#endif\n\n    // Update uf_has_breakpoint if needed.\n    update_has_breakpoint(ufunc);\n\n    // When debugging and using \"cont\" switches to the not-debugged\n    // instructions, may need to still compile them.\n    if (func_needs_compiling(ufunc, COMPILE_TYPE(ufunc)))\n    {\n\tres = compile_def_function(ufunc, FALSE, COMPILE_TYPE(ufunc), NULL);\n\n\t// compile_def_function() may cause def_functions.ga_data to change\n\tdfunc = ((dfunc_T *)def_functions.ga_data) + cdf_idx;\n    }\n    if (res == FAIL || INSTRUCTIONS(dfunc) == NULL)\n    {\n\tif (did_emsg_cumul + did_emsg == did_emsg_before)\n\t    semsg(_(e_function_is_not_compiled_str),\n\t\t\t\t\t\t   printable_func_name(ufunc));\n\treturn FAIL;\n    }\n\n    if (ufunc->uf_va_name != NULL)\n    {\n\t// Need to make a list out of the vararg arguments.\n\t// Stack at time of call with 2 varargs:\n\t//   normal_arg\n\t//   optional_arg\n\t//   vararg_1\n\t//   vararg_2\n\t// After creating the list:\n\t//   normal_arg\n\t//   optional_arg\n\t//   vararg-list\n\t// With missing optional arguments we get:\n\t//    normal_arg\n\t// After creating the list\n\t//    normal_arg\n\t//    (space for optional_arg)\n\t//    vararg-list\n\tvararg_count = argcount - ufunc->uf_args.ga_len;\n\tif (vararg_count < 0)\n\t    vararg_count = 0;\n\telse\n\t    argcount -= vararg_count;\n\tif (exe_newlist(vararg_count, ectx) == FAIL)\n\t    return FAIL;\n\n\tvararg_count = 1;\n    }\n\n    arg_to_add = ufunc->uf_args.ga_len - argcount;\n    if (arg_to_add < 0)\n    {\n\tif (arg_to_add == -1)\n\t    emsg(_(e_one_argument_too_many));\n\telse\n\t    semsg(_(e_nr_arguments_too_many), -arg_to_add);\n\treturn FAIL;\n    }\n\n    // Reserve space for:\n    // - missing arguments\n    // - stack frame\n    // - local variables\n    // - if needed: a counter for number of closures created in\n    //   ectx->ec_funcrefs.\n    varcount = dfunc->df_varcount + dfunc->df_has_closure;\n    if (GA_GROW_FAILS(&ectx->ec_stack, arg_to_add + STACK_FRAME_SIZE + varcount))\n\treturn FAIL;\n\n    // If depth of calling is getting too high, don't execute the function.\n    if (funcdepth_increment() == FAIL)\n\treturn FAIL;\n    ++ex_nesting_level;\n\n    // Only make a copy of funclocal if it contains something to restore.\n    if (ectx->ec_funclocal.floc_restore_cmdmod)\n    {\n\tfloc = ALLOC_ONE(funclocal_T);\n\tif (floc == NULL)\n\t    return FAIL;\n\t*floc = ectx->ec_funclocal;\n\tectx->ec_funclocal.floc_restore_cmdmod = FALSE;\n    }\n\n    // Move the vararg-list to below the missing optional arguments.\n    if (vararg_count > 0 && arg_to_add > 0)\n\t*STACK_TV_BOT(arg_to_add - 1) = *STACK_TV_BOT(-1);\n\n    // Reserve space for omitted optional arguments, filled in soon.\n    for (idx = 0; idx < arg_to_add; ++idx)\n\tSTACK_TV_BOT(idx - vararg_count)->v_type = VAR_UNKNOWN;\n    ectx->ec_stack.ga_len += arg_to_add;\n\n    // Store current execution state in stack frame for ISN_RETURN.\n    STACK_TV_BOT(STACK_FRAME_FUNC_OFF)->vval.v_number = ectx->ec_dfunc_idx;\n    STACK_TV_BOT(STACK_FRAME_IIDX_OFF)->vval.v_number = ectx->ec_iidx;\n    STACK_TV_BOT(STACK_FRAME_INSTR_OFF)->vval.v_string = (void *)ectx->ec_instr;\n    STACK_TV_BOT(STACK_FRAME_OUTER_OFF)->vval.v_string =\n\t\t\t\t\t\t    (void *)ectx->ec_outer_ref;\n    STACK_TV_BOT(STACK_FRAME_FUNCLOCAL_OFF)->vval.v_string = (void *)floc;\n    STACK_TV_BOT(STACK_FRAME_IDX_OFF)->vval.v_number = ectx->ec_frame_idx;\n    ectx->ec_frame_idx = ectx->ec_stack.ga_len;\n\n    // Initialize local variables\n    for (idx = 0; idx < dfunc->df_varcount; ++idx)\n    {\n\ttypval_T *tv = STACK_TV_BOT(STACK_FRAME_SIZE + idx);\n\n\ttv->v_type = VAR_NUMBER;\n\ttv->vval.v_number = 0;\n    }\n    if (dfunc->df_has_closure)\n    {\n\ttypval_T *tv = STACK_TV_BOT(STACK_FRAME_SIZE + dfunc->df_varcount);\n\n\ttv->v_type = VAR_NUMBER;\n\ttv->vval.v_number = 0;\n    }\n    ectx->ec_stack.ga_len += STACK_FRAME_SIZE + varcount;\n\n    if (pt != NULL || ufunc->uf_partial != NULL\n\t\t\t\t\t     || (ufunc->uf_flags & FC_CLOSURE))\n    {\n\touter_ref_T *ref = ALLOC_CLEAR_ONE(outer_ref_T);\n\n\tif (ref == NULL)\n\t    return FAIL;\n\tif (pt != NULL)\n\t{\n\t    ref->or_outer = &pt->pt_outer;\n\t    ++pt->pt_refcount;\n\t    ref->or_partial = pt;\n\t}\n\telse if (ufunc->uf_partial != NULL)\n\t{\n\t    ref->or_outer = &ufunc->uf_partial->pt_outer;\n\t    ++ufunc->uf_partial->pt_refcount;\n\t    ref->or_partial = ufunc->uf_partial;\n\t}\n\telse\n\t{\n\t    ref->or_outer = ALLOC_CLEAR_ONE(outer_T);\n\t    if (unlikely(ref->or_outer == NULL))\n\t    {\n\t\tvim_free(ref);\n\t\treturn FAIL;\n\t    }\n\t    ref->or_outer_allocated = TRUE;\n\t    ref->or_outer->out_stack = &ectx->ec_stack;\n\t    ref->or_outer->out_frame_idx = ectx->ec_frame_idx;\n\t    if (ectx->ec_outer_ref != NULL)\n\t\tref->or_outer->out_up = ectx->ec_outer_ref->or_outer;\n\t}\n\tectx->ec_outer_ref = ref;\n    }\n    else\n\tectx->ec_outer_ref = NULL;\n\n    ++ufunc->uf_calls;\n\n    // Set execution state to the start of the called function.\n    ectx->ec_dfunc_idx = cdf_idx;\n    ectx->ec_instr = INSTRUCTIONS(dfunc);\n    entry = estack_push_ufunc(ufunc, 1);\n    if (entry != NULL)\n    {\n\t// Set the script context to the script where the function was defined.\n\t// Save the current context so it can be restored on return.\n\tentry->es_save_sctx = current_sctx;\n\tcurrent_sctx = ufunc->uf_script_ctx;\n    }\n\n    // Start execution at the first instruction.\n    ectx->ec_iidx = 0;\n\n    return OK;\n}\n\n// Get pointer to item in the stack.\n#define STACK_TV(idx) (((typval_T *)ectx->ec_stack.ga_data) + idx)\n\n// Double linked list of funcstack_T in use.\nstatic funcstack_T *first_funcstack = NULL;\n\n    static void\nadd_funcstack_to_list(funcstack_T *funcstack)\n{\n\t// Link in list of funcstacks.\n    if (first_funcstack != NULL)\n\tfirst_funcstack->fs_prev = funcstack;\n    funcstack->fs_next = first_funcstack;\n    funcstack->fs_prev = NULL;\n    first_funcstack = funcstack;\n}\n\n    static void\nremove_funcstack_from_list(funcstack_T *funcstack)\n{\n    if (funcstack->fs_prev == NULL)\n\tfirst_funcstack = funcstack->fs_next;\n    else\n\tfuncstack->fs_prev->fs_next = funcstack->fs_next;\n    if (funcstack->fs_next != NULL)\n\tfuncstack->fs_next->fs_prev = funcstack->fs_prev;\n}\n\n/*\n * Used when returning from a function: Check if any closure is still\n * referenced.  If so then move the arguments and variables to a separate piece\n * of stack to be used when the closure is called.\n * When \"free_arguments\" is TRUE the arguments are to be freed.\n * Returns FAIL when out of memory.\n */\n    static int\nhandle_closure_in_use(ectx_T *ectx, int free_arguments)\n{\n    dfunc_T\t*dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t  + ectx->ec_dfunc_idx;\n    int\t\targcount;\n    int\t\ttop;\n    int\t\tidx;\n    typval_T\t*tv;\n    int\t\tclosure_in_use = FALSE;\n    garray_T\t*gap = &ectx->ec_funcrefs;\n    varnumber_T\tclosure_count;\n\n    if (dfunc->df_ufunc == NULL)\n\treturn OK;  // function was freed\n    if (dfunc->df_has_closure == 0)\n\treturn OK;  // no closures\n    tv = STACK_TV(ectx->ec_frame_idx + STACK_FRAME_SIZE + dfunc->df_varcount);\n    closure_count = tv->vval.v_number;\n    if (closure_count == 0)\n\treturn OK;  // no funcrefs created\n\n    argcount = ufunc_argcount(dfunc->df_ufunc);\n    top = ectx->ec_frame_idx - argcount;\n\n    // Check if any created closure is still in use.\n    for (idx = 0; idx < closure_count; ++idx)\n    {\n\tpartial_T   *pt;\n\tint\t    off = gap->ga_len - closure_count + idx;\n\n\tif (off < 0)\n\t    continue;  // count is off or already done\n\tpt = ((partial_T **)gap->ga_data)[off];\n\tif (pt->pt_refcount > 1)\n\t{\n\t    int refcount = pt->pt_refcount;\n\t    int i;\n\n\t    // A Reference in a local variables doesn't count, it gets\n\t    // unreferenced on return.\n\t    for (i = 0; i < dfunc->df_varcount; ++i)\n\t    {\n\t\ttypval_T *stv = STACK_TV(ectx->ec_frame_idx\n\t\t\t\t\t\t       + STACK_FRAME_SIZE + i);\n\t\tif (stv->v_type == VAR_PARTIAL && pt == stv->vval.v_partial)\n\t\t    --refcount;\n\t    }\n\t    if (refcount > 1)\n\t    {\n\t\tclosure_in_use = TRUE;\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    if (closure_in_use)\n    {\n\tfuncstack_T *funcstack = ALLOC_CLEAR_ONE(funcstack_T);\n\ttypval_T    *stack;\n\n\t// A closure is using the arguments and/or local variables.\n\t// Move them to the called function.\n\tif (funcstack == NULL)\n\t    return FAIL;\n\n\tfuncstack->fs_var_offset = argcount + STACK_FRAME_SIZE;\n\tfuncstack->fs_ga.ga_len = funcstack->fs_var_offset + dfunc->df_varcount;\n\tstack = ALLOC_CLEAR_MULT(typval_T, funcstack->fs_ga.ga_len);\n\tfuncstack->fs_ga.ga_data = stack;\n\tif (stack == NULL)\n\t{\n\t    vim_free(funcstack);\n\t    return FAIL;\n\t}\n\tadd_funcstack_to_list(funcstack);\n\n\t// Move or copy the arguments.\n\tfor (idx = 0; idx < argcount; ++idx)\n\t{\n\t    tv = STACK_TV(top + idx);\n\t    if (free_arguments)\n\t    {\n\t\t*(stack + idx) = *tv;\n\t\ttv->v_type = VAR_UNKNOWN;\n\t    }\n\t    else\n\t\tcopy_tv(tv, stack + idx);\n\t}\n\t// Move the local variables.\n\tfor (idx = 0; idx < dfunc->df_varcount; ++idx)\n\t{\n\t    tv = STACK_TV(ectx->ec_frame_idx + STACK_FRAME_SIZE + idx);\n\n\t    // A partial created for a local function, that is also used as a\n\t    // local variable, has a reference count for the variable, thus\n\t    // will never go down to zero.  When all these refcounts are one\n\t    // then the funcstack is unused.  We need to count how many we have\n\t    // so we know when to check.\n\t    if (tv->v_type == VAR_PARTIAL && tv->vval.v_partial != NULL)\n\t    {\n\t\tint\t    i;\n\n\t\tfor (i = 0; i < closure_count; ++i)\n\t\t    if (tv->vval.v_partial == ((partial_T **)gap->ga_data)[\n\t\t\t\t\t      gap->ga_len - closure_count + i])\n\t\t\t++funcstack->fs_min_refcount;\n\t    }\n\n\t    *(stack + funcstack->fs_var_offset + idx) = *tv;\n\t    tv->v_type = VAR_UNKNOWN;\n\t}\n\n\tfor (idx = 0; idx < closure_count; ++idx)\n\t{\n\t    partial_T *pt = ((partial_T **)gap->ga_data)[gap->ga_len\n\t\t\t\t\t\t\t- closure_count + idx];\n\t    if (pt->pt_refcount > 1)\n\t    {\n\t\t++funcstack->fs_refcount;\n\t\tpt->pt_funcstack = funcstack;\n\t\tpt->pt_outer.out_stack = &funcstack->fs_ga;\n\t\tpt->pt_outer.out_frame_idx = ectx->ec_frame_idx - top;\n\t    }\n\t}\n    }\n\n    for (idx = 0; idx < closure_count; ++idx)\n\tpartial_unref(((partial_T **)gap->ga_data)[gap->ga_len\n\t\t\t\t\t\t       - closure_count + idx]);\n    gap->ga_len -= closure_count;\n    if (gap->ga_len == 0)\n\tga_clear(gap);\n\n    return OK;\n}\n\n/*\n * Called when a partial is freed or its reference count goes down to one.  The\n * funcstack may be the only reference to the partials in the local variables.\n * Go over all of them, the funcref and can be freed if all partials\n * referencing the funcstack have a reference count of one.\n */\n    void\nfuncstack_check_refcount(funcstack_T *funcstack)\n{\n    int\t\t    i;\n    garray_T\t    *gap = &funcstack->fs_ga;\n    int\t\t    done = 0;\n\n    if (funcstack->fs_refcount > funcstack->fs_min_refcount)\n\treturn;\n    for (i = funcstack->fs_var_offset; i < gap->ga_len; ++i)\n    {\n\ttypval_T *tv = ((typval_T *)gap->ga_data) + i;\n\n\tif (tv->v_type == VAR_PARTIAL && tv->vval.v_partial != NULL\n\t\t&& tv->vval.v_partial->pt_funcstack == funcstack\n\t\t&& tv->vval.v_partial->pt_refcount == 1)\n\t    ++done;\n    }\n    if (done == funcstack->fs_min_refcount)\n    {\n\ttypval_T\t*stack = gap->ga_data;\n\n\t// All partials referencing the funcstack have a reference count of\n\t// one, thus the funcstack is no longer of use.\n\tfor (i = 0; i < gap->ga_len; ++i)\n\t    clear_tv(stack + i);\n\tvim_free(stack);\n\tremove_funcstack_from_list(funcstack);\n\tvim_free(funcstack);\n    }\n}\n\n/*\n * For garbage collecting: set references in all variables referenced by\n * all funcstacks.\n */\n    int\nset_ref_in_funcstacks(int copyID)\n{\n    funcstack_T *funcstack;\n\n    for (funcstack = first_funcstack; funcstack != NULL;\n\t\t\t\t\t\tfuncstack = funcstack->fs_next)\n    {\n\ttypval_T    *stack = funcstack->fs_ga.ga_data;\n\tint\t    i;\n\n\tfor (i = 0; i < funcstack->fs_ga.ga_len; ++i)\n\t    if (set_ref_in_item(stack + i, copyID, NULL, NULL))\n\t\treturn TRUE;  // abort\n    }\n    return FALSE;\n}\n\n/*\n * Return from the current function.\n */\n    static int\nfunc_return(ectx_T *ectx)\n{\n    int\t\tidx;\n    int\t\tret_idx;\n    dfunc_T\t*dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t  + ectx->ec_dfunc_idx;\n    int\t\targcount = ufunc_argcount(dfunc->df_ufunc);\n    int\t\ttop = ectx->ec_frame_idx - argcount;\n    estack_T\t*entry;\n    int\t\tprev_dfunc_idx = STACK_TV(ectx->ec_frame_idx\n\t\t\t\t\t+ STACK_FRAME_FUNC_OFF)->vval.v_number;\n    funclocal_T\t*floc;\n#ifdef FEAT_PROFILE\n    dfunc_T\t*prev_dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t      + prev_dfunc_idx;\n\n    if (do_profiling == PROF_YES)\n    {\n\tufunc_T *caller = prev_dfunc->df_ufunc;\n\n\tif (dfunc->df_ufunc->uf_profiling\n\t\t\t\t   || (caller != NULL && caller->uf_profiling))\n\t{\n\t    profile_may_end_func(((profinfo_T *)profile_info_ga.ga_data)\n\t\t\t+ profile_info_ga.ga_len - 1, dfunc->df_ufunc, caller);\n\t    --profile_info_ga.ga_len;\n\t}\n    }\n#endif\n\n    // No check for uf_refcount being zero, cannot think of a way that would\n    // happen.\n    --dfunc->df_ufunc->uf_calls;\n\n    // execution context goes one level up\n    entry = estack_pop();\n    if (entry != NULL)\n\tcurrent_sctx = entry->es_save_sctx;\n\n    if (handle_closure_in_use(ectx, TRUE) == FAIL)\n\treturn FAIL;\n\n    // Clear the arguments.\n    for (idx = top; idx < ectx->ec_frame_idx; ++idx)\n\tclear_tv(STACK_TV(idx));\n\n    // Clear local variables and temp values, but not the return value.\n    for (idx = ectx->ec_frame_idx + STACK_FRAME_SIZE;\n\t\t\t\t\tidx < ectx->ec_stack.ga_len - 1; ++idx)\n\tclear_tv(STACK_TV(idx));\n\n    // The return value should be on top of the stack.  However, when aborting\n    // it may not be there and ec_frame_idx is the top of the stack.\n    ret_idx = ectx->ec_stack.ga_len - 1;\n    if (ret_idx == ectx->ec_frame_idx + STACK_FRAME_IDX_OFF)\n\tret_idx = 0;\n\n    if (ectx->ec_outer_ref != NULL)\n    {\n\tif (ectx->ec_outer_ref->or_outer_allocated)\n\t    vim_free(ectx->ec_outer_ref->or_outer);\n\tpartial_unref(ectx->ec_outer_ref->or_partial);\n\tvim_free(ectx->ec_outer_ref);\n    }\n\n    // Restore the previous frame.\n    ectx->ec_dfunc_idx = prev_dfunc_idx;\n    ectx->ec_iidx = STACK_TV(ectx->ec_frame_idx\n\t\t\t\t\t+ STACK_FRAME_IIDX_OFF)->vval.v_number;\n    ectx->ec_instr = (void *)STACK_TV(ectx->ec_frame_idx\n\t\t\t\t       + STACK_FRAME_INSTR_OFF)->vval.v_string;\n    ectx->ec_outer_ref = (void *)STACK_TV(ectx->ec_frame_idx\n\t\t\t\t       + STACK_FRAME_OUTER_OFF)->vval.v_string;\n    floc = (void *)STACK_TV(ectx->ec_frame_idx\n\t\t\t\t   + STACK_FRAME_FUNCLOCAL_OFF)->vval.v_string;\n    // restoring ec_frame_idx must be last\n    ectx->ec_frame_idx = STACK_TV(ectx->ec_frame_idx\n\t\t\t\t       + STACK_FRAME_IDX_OFF)->vval.v_number;\n\n    if (floc == NULL)\n\tectx->ec_funclocal.floc_restore_cmdmod = FALSE;\n    else\n    {\n\tectx->ec_funclocal = *floc;\n\tvim_free(floc);\n    }\n\n    if (ret_idx > 0)\n    {\n\t// Reset the stack to the position before the call, with a spot for the\n\t// return value, moved there from above the frame.\n\tectx->ec_stack.ga_len = top + 1;\n\t*STACK_TV_BOT(-1) = *STACK_TV(ret_idx);\n    }\n    else\n\t// Reset the stack to the position before the call.\n\tectx->ec_stack.ga_len = top;\n\n    funcdepth_decrement();\n    --ex_nesting_level;\n    return OK;\n}\n\n#undef STACK_TV\n\n/*\n * Prepare arguments and rettv for calling a builtin or user function.\n */\n    static int\ncall_prepare(int argcount, typval_T *argvars, ectx_T *ectx)\n{\n    int\t\tidx;\n    typval_T\t*tv;\n\n    // Move arguments from bottom of the stack to argvars[] and add terminator.\n    for (idx = 0; idx < argcount; ++idx)\n\targvars[idx] = *STACK_TV_BOT(idx - argcount);\n    argvars[argcount].v_type = VAR_UNKNOWN;\n\n    // Result replaces the arguments on the stack.\n    if (argcount > 0)\n\tectx->ec_stack.ga_len -= argcount - 1;\n    else if (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\treturn FAIL;\n    else\n\t++ectx->ec_stack.ga_len;\n\n    // Default return value is zero.\n    tv = STACK_TV_BOT(-1);\n    tv->v_type = VAR_NUMBER;\n    tv->vval.v_number = 0;\n\n    return OK;\n}\n\n// Ugly global to avoid passing the execution context around through many\n// layers.\nstatic ectx_T *current_ectx = NULL;\n\n/*\n * Call a builtin function by index.\n */\n    static int\ncall_bfunc(int func_idx, int argcount, ectx_T *ectx)\n{\n    typval_T\targvars[MAX_FUNC_ARGS];\n    int\t\tidx;\n    int\t\tdid_emsg_before = did_emsg;\n    ectx_T\t*prev_ectx = current_ectx;\n    char\t*save_func_name = ectx->ec_where.wt_func_name;\n\n    if (call_prepare(argcount, argvars, ectx) == FAIL)\n\treturn FAIL;\n    ectx->ec_where.wt_func_name = internal_func_name(func_idx);\n\n    // Call the builtin function.  Set \"current_ectx\" so that when it\n    // recursively invokes call_def_function() a closure context can be set.\n    current_ectx = ectx;\n    call_internal_func_by_idx(func_idx, argvars, STACK_TV_BOT(-1));\n    current_ectx = prev_ectx;\n    ectx->ec_where.wt_func_name = save_func_name;\n\n    // Clear the arguments.\n    for (idx = 0; idx < argcount; ++idx)\n\tclear_tv(&argvars[idx]);\n\n    if (did_emsg > did_emsg_before)\n\treturn FAIL;\n    return OK;\n}\n\n/*\n * Execute a user defined function.\n * If the function is compiled this will add a stack frame and set the\n * instruction pointer at the start of the function.\n * Otherwise the function is called here.\n * If \"pt\" is not null use \"pt->pt_outer\" for ec_outer_ref->or_outer.\n * \"iptr\" can be used to replace the instruction with a more efficient one.\n */\n    static int\ncall_ufunc(\n\tufunc_T\t    *ufunc,\n\tpartial_T   *pt,\n\tint\t    argcount,\n\tectx_T\t    *ectx,\n\tisn_T\t    *iptr,\n\tdict_T\t    *selfdict)\n{\n    typval_T\targvars[MAX_FUNC_ARGS];\n    funcexe_T   funcexe;\n    int\t\terror;\n    int\t\tidx;\n    int\t\tdid_emsg_before = did_emsg;\n    compiletype_T compile_type = COMPILE_TYPE(ufunc);\n\n    if (func_needs_compiling(ufunc, compile_type)\n\t\t&& compile_def_function(ufunc, FALSE, compile_type, NULL)\n\t\t\t\t\t\t\t\t       == FAIL)\n\treturn FAIL;\n    if (ufunc->uf_def_status == UF_COMPILED)\n    {\n\terror = check_user_func_argcount(ufunc, argcount);\n\tif (error != FCERR_UNKNOWN)\n\t{\n\t    if (error == FCERR_TOOMANY)\n\t\tsemsg(_(e_too_many_arguments_for_function_str), ufunc->uf_name);\n\t    else\n\t\tsemsg(_(e_not_enough_arguments_for_function_str),\n\t\t\t\t\t\t\t       ufunc->uf_name);\n\t    return FAIL;\n\t}\n\n\t// The function has been compiled, can call it quickly.  For a function\n\t// that was defined later: we can call it directly next time.\n\tif (iptr != NULL)\n\t{\n\t    delete_instr(iptr);\n\t    iptr->isn_type = ISN_DCALL;\n\t    iptr->isn_arg.dfunc.cdf_idx = ufunc->uf_dfunc_idx;\n\t    iptr->isn_arg.dfunc.cdf_argcount = argcount;\n\t}\n\treturn call_dfunc(ufunc->uf_dfunc_idx, pt, argcount, ectx);\n    }\n\n    if (call_prepare(argcount, argvars, ectx) == FAIL)\n\treturn FAIL;\n    CLEAR_FIELD(funcexe);\n    funcexe.fe_evaluate = TRUE;\n    funcexe.fe_selfdict = selfdict != NULL ? selfdict : dict_stack_get_dict();\n\n    // Call the user function.  Result goes in last position on the stack.\n    error = call_user_func_check(ufunc, argcount, argvars,\n\t\t\t      STACK_TV_BOT(-1), &funcexe, funcexe.fe_selfdict);\n\n    // Clear the arguments.\n    for (idx = 0; idx < argcount; ++idx)\n\tclear_tv(&argvars[idx]);\n\n    if (error != FCERR_NONE)\n    {\n\tuser_func_error(error, ufunc->uf_name, &funcexe);\n\treturn FAIL;\n    }\n    if (did_emsg > did_emsg_before)\n\t// Error other than from calling the function itself.\n\treturn FAIL;\n    return OK;\n}\n\n/*\n * If command modifiers were applied restore them.\n */\n    static void\nmay_restore_cmdmod(funclocal_T *funclocal)\n{\n    if (funclocal->floc_restore_cmdmod)\n    {\n\tcmdmod.cmod_filter_regmatch.regprog = NULL;\n\tundo_cmdmod(&cmdmod);\n\tcmdmod = funclocal->floc_save_cmdmod;\n\tfunclocal->floc_restore_cmdmod = FALSE;\n    }\n}\n\n/*\n * Return TRUE if an error was given (not caught in try/catch) or CTRL-C was\n * pressed.\n */\n    static int\nvim9_aborting(int prev_uncaught_emsg)\n{\n    return uncaught_emsg > prev_uncaught_emsg || got_int || did_throw;\n}\n\n/*\n * Execute a function by \"name\".\n * This can be a builtin function or a user function.\n * \"iptr\" can be used to replace the instruction with a more efficient one.\n * Returns FAIL if not found without an error message.\n */\n    static int\ncall_by_name(\n\tchar_u\t    *name,\n\tint\t    argcount,\n\tectx_T\t    *ectx,\n\tisn_T\t    *iptr,\n\tdict_T\t    *selfdict)\n{\n    ufunc_T *ufunc;\n\n    if (builtin_function(name, -1))\n    {\n\tint func_idx = find_internal_func(name);\n\n\tif (func_idx < 0)\n\t    return FAIL;\n\tif (check_internal_func(func_idx, argcount) < 0)\n\t    return FAIL;\n\treturn call_bfunc(func_idx, argcount, ectx);\n    }\n\n    ufunc = find_func(name, FALSE, NULL);\n\n    if (ufunc == NULL)\n    {\n\tint prev_uncaught_emsg = uncaught_emsg;\n\n\tif (script_autoload(name, TRUE))\n\t    // loaded a package, search for the function again\n\t    ufunc = find_func(name, FALSE, NULL);\n\n\tif (vim9_aborting(prev_uncaught_emsg))\n\t    return FAIL;  // bail out if loading the script caused an error\n    }\n\n    if (ufunc != NULL)\n    {\n\tif (ufunc->uf_arg_types != NULL || ufunc->uf_va_type != NULL)\n\t{\n\t    int i;\n\t    typval_T\t*argv = STACK_TV_BOT(0) - argcount;\n\n\t    // The function can change at runtime, check that the argument\n\t    // types are correct.\n\t    for (i = 0; i < argcount; ++i)\n\t    {\n\t\ttype_T *type = NULL;\n\n\t\tif (i < ufunc->uf_args.ga_len && ufunc->uf_arg_types != NULL)\n\t\t    type = ufunc->uf_arg_types[i];\n\t\telse if (ufunc->uf_va_type != NULL)\n\t\t    type = ufunc->uf_va_type->tt_member;\n\t\tif (type != NULL && check_typval_arg_type(type,\n\t\t\t\t\t\t&argv[i], NULL, i + 1) == FAIL)\n\t\t    return FAIL;\n\t    }\n\t}\n\n\treturn call_ufunc(ufunc, NULL, argcount, ectx, iptr, selfdict);\n    }\n\n    return FAIL;\n}\n\n    static int\ncall_partial(\n\ttypval_T    *tv,\n\tint\t    argcount_arg,\n\tectx_T\t    *ectx)\n{\n    int\t\targcount = argcount_arg;\n    char_u\t*name = NULL;\n    int\t\tcalled_emsg_before = called_emsg;\n    int\t\tres = FAIL;\n    dict_T\t*selfdict = NULL;\n\n    if (tv->v_type == VAR_PARTIAL)\n    {\n\tpartial_T   *pt = tv->vval.v_partial;\n\tint\t    i;\n\n\tif (pt->pt_argc > 0)\n\t{\n\t    // Make space for arguments from the partial, shift the \"argcount\"\n\t    // arguments up.\n\t    if (GA_GROW_FAILS(&ectx->ec_stack, pt->pt_argc))\n\t\treturn FAIL;\n\t    for (i = 1; i <= argcount; ++i)\n\t\t*STACK_TV_BOT(-i + pt->pt_argc) = *STACK_TV_BOT(-i);\n\t    ectx->ec_stack.ga_len += pt->pt_argc;\n\t    argcount += pt->pt_argc;\n\n\t    // copy the arguments from the partial onto the stack\n\t    for (i = 0; i < pt->pt_argc; ++i)\n\t\tcopy_tv(&pt->pt_argv[i], STACK_TV_BOT(-argcount + i));\n\t}\n\tselfdict = pt->pt_dict;\n\n\tif (pt->pt_func != NULL)\n\t    return call_ufunc(pt->pt_func, pt, argcount, ectx, NULL, selfdict);\n\n\tname = pt->pt_name;\n    }\n    else if (tv->v_type == VAR_FUNC)\n\tname = tv->vval.v_string;\n    if (name != NULL)\n    {\n\tchar_u\tfname_buf[FLEN_FIXED + 1];\n\tchar_u\t*tofree = NULL;\n\tint\terror = FCERR_NONE;\n\tchar_u\t*fname;\n\n\t// May need to translate <SNR>123_ to K_SNR.\n\tfname = fname_trans_sid(name, fname_buf, &tofree, &error);\n\tif (error != FCERR_NONE)\n\t    res = FAIL;\n\telse\n\t    res = call_by_name(fname, argcount, ectx, NULL, selfdict);\n\tvim_free(tofree);\n    }\n\n    if (res == FAIL)\n    {\n\tif (called_emsg == called_emsg_before)\n\t    semsg(_(e_unknown_function_str),\n\t\t\t\t  name == NULL ? (char_u *)\"[unknown]\" : name);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Check if \"lock\" is VAR_LOCKED or VAR_FIXED.  If so give an error and return\n * TRUE.\n */\n    static int\nerror_if_locked(int lock, char *error)\n{\n    if (lock & (VAR_LOCKED | VAR_FIXED))\n    {\n\temsg(_(error));\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Give an error if \"tv\" is not a number and return FAIL.\n */\n    static int\ncheck_for_number(typval_T *tv)\n{\n    if (tv->v_type != VAR_NUMBER)\n    {\n\tsemsg(_(e_expected_str_but_got_str),\n\t\tvartype_name(VAR_NUMBER), vartype_name(tv->v_type));\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Store \"tv\" in variable \"name\".\n * This is for s: and g: variables.\n */\n    static void\nstore_var(char_u *name, typval_T *tv)\n{\n    funccal_entry_T entry;\n    int\t\t    flags = ASSIGN_DECL;\n\n    if (tv->v_lock)\n\tflags |= ASSIGN_CONST;\n    save_funccal(&entry);\n    set_var_const(name, NULL, tv, FALSE, flags, 0);\n    restore_funccal();\n}\n\n/*\n * Convert \"tv\" to a string.\n * Return FAIL if not allowed.\n */\n    static int\ndo_2string(typval_T *tv, int is_2string_any, int tolerant)\n{\n    if (tv->v_type != VAR_STRING)\n    {\n\tchar_u *str;\n\n\tif (is_2string_any)\n\t{\n\t    switch (tv->v_type)\n\t    {\n\t\tcase VAR_SPECIAL:\n\t\tcase VAR_BOOL:\n\t\tcase VAR_NUMBER:\n\t\tcase VAR_FLOAT:\n\t\tcase VAR_BLOB:\tbreak;\n\n\t\tcase VAR_LIST:\n\t\t\t\tif (tolerant)\n\t\t\t\t{\n\t\t\t\t    char_u\t*s, *e, *p;\n\t\t\t\t    garray_T\tga;\n\n\t\t\t\t    ga_init2(&ga, sizeof(char_u *), 1);\n\n\t\t\t\t    // Convert to NL separated items, then\n\t\t\t\t    // escape the items and replace the NL with\n\t\t\t\t    // a space.\n\t\t\t\t    str = typval2string(tv, TRUE);\n\t\t\t\t    if (str == NULL)\n\t\t\t\t\treturn FAIL;\n\t\t\t\t    s = str;\n\t\t\t\t    while ((e = vim_strchr(s, '\\n')) != NULL)\n\t\t\t\t    {\n\t\t\t\t\t*e = NUL;\n\t\t\t\t\tp = vim_strsave_fnameescape(s,\n\t\t\t\t\t\t\t\t     VSE_NONE);\n\t\t\t\t\tif (p != NULL)\n\t\t\t\t\t{\n\t\t\t\t\t    ga_concat(&ga, p);\n\t\t\t\t\t    ga_concat(&ga, (char_u *)\" \");\n\t\t\t\t\t    vim_free(p);\n\t\t\t\t\t}\n\t\t\t\t\ts = e + 1;\n\t\t\t\t    }\n\t\t\t\t    vim_free(str);\n\t\t\t\t    clear_tv(tv);\n\t\t\t\t    tv->v_type = VAR_STRING;\n\t\t\t\t    tv->vval.v_string = ga.ga_data;\n\t\t\t\t    return OK;\n\t\t\t\t}\n\t\t\t\t// FALLTHROUGH\n\t\tdefault:\tto_string_error(tv->v_type);\n\t\t\t\treturn FAIL;\n\t    }\n\t}\n\tstr = typval_tostring(tv, TRUE);\n\tclear_tv(tv);\n\ttv->v_type = VAR_STRING;\n\ttv->vval.v_string = str;\n    }\n    return OK;\n}\n\n/*\n * When the value of \"sv\" is a null list of dict, allocate it.\n */\n    static void\nallocate_if_null(typval_T *tv)\n{\n    switch (tv->v_type)\n    {\n\tcase VAR_LIST:\n\t    if (tv->vval.v_list == NULL)\n\t\t(void)rettv_list_alloc(tv);\n\t    break;\n\tcase VAR_DICT:\n\t    if (tv->vval.v_dict == NULL)\n\t\t(void)rettv_dict_alloc(tv);\n\t    break;\n\tcase VAR_BLOB:\n\t    if (tv->vval.v_blob == NULL)\n\t\t(void)rettv_blob_alloc(tv);\n\t    break;\n\tdefault:\n\t    break;\n    }\n}\n\n/*\n * Return the character \"str[index]\" where \"index\" is the character index,\n * including composing characters.\n * If \"index\" is out of range NULL is returned.\n */\n    char_u *\nchar_from_string(char_u *str, varnumber_T index)\n{\n    size_t\t    nbyte = 0;\n    varnumber_T\t    nchar = index;\n    size_t\t    slen;\n\n    if (str == NULL)\n\treturn NULL;\n    slen = STRLEN(str);\n\n    // Do the same as for a list: a negative index counts from the end.\n    // Optimization to check the first byte to be below 0x80 (and no composing\n    // character follows) makes this a lot faster.\n    if (index < 0)\n    {\n\tint\tclen = 0;\n\n\tfor (nbyte = 0; nbyte < slen; ++clen)\n\t{\n\t    if (str[nbyte] < 0x80 && str[nbyte + 1] < 0x80)\n\t\t++nbyte;\n\t    else if (enc_utf8)\n\t\tnbyte += utfc_ptr2len(str + nbyte);\n\t    else\n\t\tnbyte += mb_ptr2len(str + nbyte);\n\t}\n\tnchar = clen + index;\n\tif (nchar < 0)\n\t    // unlike list: index out of range results in empty string\n\t    return NULL;\n    }\n\n    for (nbyte = 0; nchar > 0 && nbyte < slen; --nchar)\n    {\n\tif (str[nbyte] < 0x80 && str[nbyte + 1] < 0x80)\n\t    ++nbyte;\n\telse if (enc_utf8)\n\t    nbyte += utfc_ptr2len(str + nbyte);\n\telse\n\t    nbyte += mb_ptr2len(str + nbyte);\n    }\n    if (nbyte >= slen)\n\treturn NULL;\n    return vim_strnsave(str + nbyte, mb_ptr2len(str + nbyte));\n}\n\n/*\n * Get the byte index for character index \"idx\" in string \"str\" with length\n * \"str_len\".  Composing characters are included.\n * If going over the end return \"str_len\".\n * If \"idx\" is negative count from the end, -1 is the last character.\n * When going over the start return -1.\n */\n    static long\nchar_idx2byte(char_u *str, size_t str_len, varnumber_T idx)\n{\n    varnumber_T nchar = idx;\n    size_t\tnbyte = 0;\n\n    if (nchar >= 0)\n    {\n\twhile (nchar > 0 && nbyte < str_len)\n\t{\n\t    nbyte += mb_ptr2len(str + nbyte);\n\t    --nchar;\n\t}\n    }\n    else\n    {\n\tnbyte = str_len;\n\twhile (nchar < 0 && nbyte > 0)\n\t{\n\t    --nbyte;\n\t    nbyte -= mb_head_off(str, str + nbyte);\n\t    ++nchar;\n\t}\n\tif (nchar < 0)\n\t    return -1;\n    }\n    return (long)nbyte;\n}\n\n/*\n * Return the slice \"str[first : last]\" using character indexes.  Composing\n * characters are included.\n * \"exclusive\" is TRUE for slice().\n * Return NULL when the result is empty.\n */\n    char_u *\nstring_slice(char_u *str, varnumber_T first, varnumber_T last, int exclusive)\n{\n    long\tstart_byte, end_byte;\n    size_t\tslen;\n\n    if (str == NULL)\n\treturn NULL;\n    slen = STRLEN(str);\n    start_byte = char_idx2byte(str, slen, first);\n    if (start_byte < 0)\n\tstart_byte = 0; // first index very negative: use zero\n    if ((last == -1 && !exclusive) || last == VARNUM_MAX)\n\tend_byte = (long)slen;\n    else\n    {\n\tend_byte = char_idx2byte(str, slen, last);\n\tif (!exclusive && end_byte >= 0 && end_byte < (long)slen)\n\t    // end index is inclusive\n\t    end_byte += mb_ptr2len(str + end_byte);\n    }\n\n    if (start_byte >= (long)slen || end_byte <= start_byte)\n\treturn NULL;\n    return vim_strnsave(str + start_byte, end_byte - start_byte);\n}\n\n/*\n * Get a script variable for ISN_STORESCRIPT and ISN_LOADSCRIPT.\n * When \"dfunc_idx\" is negative don't give an error.\n * Returns NULL for an error.\n */\n    static svar_T *\nget_script_svar(scriptref_T *sref, int dfunc_idx)\n{\n    scriptitem_T    *si = SCRIPT_ITEM(sref->sref_sid);\n    dfunc_T\t    *dfunc = dfunc_idx < 0 ? NULL\n\t\t\t      : ((dfunc_T *)def_functions.ga_data) + dfunc_idx;\n    svar_T\t    *sv;\n\n    if (sref->sref_seq != si->sn_script_seq)\n    {\n\t// The script was reloaded after the function was compiled, the\n\t// script_idx may not be valid.\n\tif (dfunc != NULL)\n\t    semsg(_(e_script_variable_invalid_after_reload_in_function_str),\n\t\t\t\t\t printable_func_name(dfunc->df_ufunc));\n\treturn NULL;\n    }\n    sv = ((svar_T *)si->sn_var_vals.ga_data) + sref->sref_idx;\n    if (!equal_type(sv->sv_type, sref->sref_type, 0))\n    {\n\tif (dfunc != NULL)\n\t    emsg(_(e_script_variable_type_changed));\n\treturn NULL;\n    }\n    return sv;\n}\n\n/*\n * Function passed to do_cmdline() for splitting a script joined by NL\n * characters.\n */\n    static char_u *\nget_split_sourceline(\n\tint c UNUSED,\n\tvoid *cookie,\n\tint indent UNUSED,\n\tgetline_opt_T options UNUSED)\n{\n    source_cookie_T\t*sp = (source_cookie_T *)cookie;\n    char_u\t\t*p;\n    char_u\t\t*line;\n\n    if (*sp->nextline == NUL)\n\treturn NULL;\n    p = vim_strchr(sp->nextline, '\\n');\n    if (p == NULL)\n    {\n\tline = vim_strsave(sp->nextline);\n\tsp->nextline += STRLEN(sp->nextline);\n    }\n    else\n    {\n\tline = vim_strnsave(sp->nextline, p - sp->nextline);\n\tsp->nextline = p + 1;\n    }\n    return line;\n}\n\n/*\n * Execute a function by \"name\".\n * This can be a builtin function, user function or a funcref.\n * \"iptr\" can be used to replace the instruction with a more efficient one.\n */\n    static int\ncall_eval_func(\n\tchar_u\t    *name,\n\tint\t    argcount,\n\tectx_T\t    *ectx,\n\tisn_T\t    *iptr)\n{\n    int\t    called_emsg_before = called_emsg;\n    int\t    res;\n\n    res = call_by_name(name, argcount, ectx, iptr, NULL);\n    if (res == FAIL && called_emsg == called_emsg_before)\n    {\n\tdictitem_T\t*v;\n\n\tv = find_var(name, NULL, FALSE);\n\tif (v == NULL)\n\t{\n\t    semsg(_(e_unknown_function_str), name);\n\t    return FAIL;\n\t}\n\tif (v->di_tv.v_type != VAR_PARTIAL && v->di_tv.v_type != VAR_FUNC)\n\t{\n\t    semsg(_(e_unknown_function_str), name);\n\t    return FAIL;\n\t}\n\treturn call_partial(&v->di_tv, argcount, ectx);\n    }\n    return res;\n}\n\n/*\n * When a function reference is used, fill a partial with the information\n * needed, especially when it is used as a closure.\n */\n    int\nfill_partial_and_closure(partial_T *pt, ufunc_T *ufunc, ectx_T *ectx)\n{\n    pt->pt_func = ufunc;\n    pt->pt_refcount = 1;\n\n    if (ufunc->uf_flags & FC_CLOSURE)\n    {\n\tdfunc_T\t*dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t  + ectx->ec_dfunc_idx;\n\n\t// The closure may need to find arguments and local variables in the\n\t// current stack.\n\tpt->pt_outer.out_stack = &ectx->ec_stack;\n\tpt->pt_outer.out_frame_idx = ectx->ec_frame_idx;\n\tif (ectx->ec_outer_ref != NULL)\n\t{\n\t    // The current context already has a context, link to that one.\n\t    pt->pt_outer.out_up = ectx->ec_outer_ref->or_outer;\n\t    if (ectx->ec_outer_ref->or_partial != NULL)\n\t    {\n\t\tpt->pt_outer.out_up_partial = ectx->ec_outer_ref->or_partial;\n\t\t++pt->pt_outer.out_up_partial->pt_refcount;\n\t    }\n\t}\n\n\t// If this function returns and the closure is still being used, we\n\t// need to make a copy of the context (arguments and local variables).\n\t// Store a reference to the partial so we can handle that.\n\tif (GA_GROW_FAILS(&ectx->ec_funcrefs, 1))\n\t{\n\t    vim_free(pt);\n\t    return FAIL;\n\t}\n\t// Extra variable keeps the count of closures created in the current\n\t// function call.\n\t++(((typval_T *)ectx->ec_stack.ga_data) + ectx->ec_frame_idx\n\t\t       + STACK_FRAME_SIZE + dfunc->df_varcount)->vval.v_number;\n\n\t((partial_T **)ectx->ec_funcrefs.ga_data)\n\t\t\t       [ectx->ec_funcrefs.ga_len] = pt;\n\t++pt->pt_refcount;\n\t++ectx->ec_funcrefs.ga_len;\n    }\n    ++ufunc->uf_refcount;\n    return OK;\n}\n\n/*\n * Execute iptr->isn_arg.string as an Ex command.\n */\n    static int\nexec_command(isn_T *iptr)\n{\n    source_cookie_T cookie;\n\n    SOURCING_LNUM = iptr->isn_lnum;\n    // Pass getsourceline to get an error for a missing \":end\"\n    // command.\n    CLEAR_FIELD(cookie);\n    cookie.sourcing_lnum = iptr->isn_lnum - 1;\n    if (do_cmdline(iptr->isn_arg.string,\n\t\tgetsourceline, &cookie,\n\t\t\t     DOCMD_VERBOSE|DOCMD_NOWAIT|DOCMD_KEYTYPED) == FAIL\n\t\t|| did_emsg)\n\treturn FAIL;\n    return OK;\n}\n\n// used for v_instr of typval of VAR_INSTR\nstruct instr_S {\n    ectx_T\t*instr_ectx;\n    isn_T\t*instr_instr;\n};\n\n// used for substitute_instr\ntypedef struct subs_expr_S {\n    ectx_T\t*subs_ectx;\n    isn_T\t*subs_instr;\n    int\t\tsubs_status;\n} subs_expr_T;\n\n// Get pointer to item in the stack.\n#define STACK_TV(idx) (((typval_T *)ectx->ec_stack.ga_data) + idx)\n\n// Get pointer to item at the bottom of the stack, -1 is the bottom.\n#undef STACK_TV_BOT\n#define STACK_TV_BOT(idx) (((typval_T *)ectx->ec_stack.ga_data) + ectx->ec_stack.ga_len + idx)\n\n// Get pointer to a local variable on the stack.  Negative for arguments.\n#define STACK_TV_VAR(idx) (((typval_T *)ectx->ec_stack.ga_data) + ectx->ec_frame_idx + STACK_FRAME_SIZE + idx)\n\n// Set when calling do_debug().\nstatic ectx_T\t*debug_context = NULL;\nstatic int\tdebug_var_count;\n\n/*\n * When debugging lookup \"name\" and return the typeval.\n * When not found return NULL.\n */\n    typval_T *\nlookup_debug_var(char_u *name)\n{\n    int\t\t    idx;\n    dfunc_T\t    *dfunc;\n    ufunc_T\t    *ufunc;\n    ectx_T\t    *ectx = debug_context;\n    int\t\t    varargs_off;\n\n    if (ectx == NULL)\n\treturn NULL;\n    dfunc = ((dfunc_T *)def_functions.ga_data) + ectx->ec_dfunc_idx;\n\n    // Go through the local variable names, from last to first.\n    for (idx = debug_var_count - 1; idx >= 0; --idx)\n    {\n\tif (STRCMP(((char_u **)dfunc->df_var_names.ga_data)[idx], name) == 0)\n\t    return STACK_TV_VAR(idx);\n    }\n\n    // Go through argument names.\n    ufunc = dfunc->df_ufunc;\n    varargs_off = ufunc->uf_va_name == NULL ? 0 : 1;\n    for (idx = 0; idx < ufunc->uf_args.ga_len; ++idx)\n\tif (STRCMP(((char_u **)(ufunc->uf_args.ga_data))[idx], name) == 0)\n\t    return STACK_TV(ectx->ec_frame_idx - ufunc->uf_args.ga_len\n\t\t\t\t\t\t\t  - varargs_off + idx);\n    if (ufunc->uf_va_name != NULL && STRCMP(ufunc->uf_va_name, name) == 0)\n\treturn STACK_TV(ectx->ec_frame_idx - 1);\n\n    return NULL;\n}\n\n/*\n * Return TRUE if there might be a breakpoint in \"ufunc\", which is when a\n * breakpoint was set in that function or when there is any expression.\n */\n    int\nmay_break_in_function(ufunc_T *ufunc)\n{\n    return ufunc->uf_has_breakpoint || debug_has_expr_breakpoint();\n}\n\n    static void\nhandle_debug(isn_T *iptr, ectx_T *ectx)\n{\n    char_u\t*line;\n    ufunc_T\t*ufunc = (((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t       + ectx->ec_dfunc_idx)->df_ufunc;\n    isn_T\t*ni;\n    int\t\tend_lnum = iptr->isn_lnum;\n    garray_T\tga;\n    int\t\tlnum;\n\n    if (ex_nesting_level > debug_break_level)\n    {\n\tlinenr_T breakpoint;\n\n\tif (!may_break_in_function(ufunc))\n\t    return;\n\n\t// check for the next breakpoint if needed\n\tbreakpoint = dbg_find_breakpoint(FALSE, ufunc->uf_name,\n\t\t\t\t\t   iptr->isn_arg.debug.dbg_break_lnum);\n\tif (breakpoint <= 0 || breakpoint > iptr->isn_lnum)\n\t    return;\n    }\n\n    SOURCING_LNUM = iptr->isn_lnum;\n    debug_context = ectx;\n    debug_var_count = iptr->isn_arg.debug.dbg_var_names_len;\n\n    for (ni = iptr + 1; ni->isn_type != ISN_FINISH; ++ni)\n\tif (ni->isn_type == ISN_DEBUG\n\t\t  || ni->isn_type == ISN_RETURN\n\t\t  || ni->isn_type == ISN_RETURN_VOID)\n\t{\n\t    end_lnum = ni->isn_lnum + (ni->isn_type == ISN_DEBUG ? 0 : 1);\n\t    break;\n\t}\n\n    if (end_lnum > iptr->isn_lnum)\n    {\n\tga_init2(&ga, sizeof(char_u *), 10);\n\tfor (lnum = iptr->isn_lnum; lnum < end_lnum\n\t\t\t\t     && lnum <= ufunc->uf_lines.ga_len; ++lnum)\n\t{\n\t    char_u *p = ((char_u **)ufunc->uf_lines.ga_data)[lnum - 1];\n\n\t    if (p == NULL)\n\t\tcontinue;  // left over from continuation line\n\t    p = skipwhite(p);\n\t    if (*p == '#')\n\t\tbreak;\n\t    if (GA_GROW_OK(&ga, 1))\n\t\t((char_u **)(ga.ga_data))[ga.ga_len++] = p;\n\t    if (STRNCMP(p, \"def \", 4) == 0)\n\t\tbreak;\n\t}\n\tline = ga_concat_strings(&ga, \"  \");\n\tvim_free(ga.ga_data);\n    }\n    else\n\tline = ((char_u **)ufunc->uf_lines.ga_data)[iptr->isn_lnum - 1];\n\n    do_debug(line == NULL ? (char_u *)\"[empty]\" : line);\n    debug_context = NULL;\n\n    if (end_lnum > iptr->isn_lnum)\n\tvim_free(line);\n}\n\n/*\n * Execute instructions in execution context \"ectx\".\n * Return OK or FAIL;\n */\n    static int\nexec_instructions(ectx_T *ectx)\n{\n    int\t\tret = FAIL;\n    int\t\tsave_trylevel_at_start = ectx->ec_trylevel_at_start;\n    int\t\tdict_stack_len_at_start = dict_stack.ga_len;\n\n    // Start execution at the first instruction.\n    ectx->ec_iidx = 0;\n\n    // Only catch exceptions in this instruction list.\n    ectx->ec_trylevel_at_start = trylevel;\n\n    for (;;)\n    {\n\tstatic int  breakcheck_count = 0;  // using \"static\" makes it faster\n\tisn_T\t    *iptr;\n\ttypval_T    *tv;\n\n\tif (unlikely(++breakcheck_count >= 100))\n\t{\n\t    line_breakcheck();\n\t    breakcheck_count = 0;\n\t}\n\tif (unlikely(got_int))\n\t{\n\t    // Turn CTRL-C into an exception.\n\t    got_int = FALSE;\n\t    if (throw_exception(\"Vim:Interrupt\", ET_INTERRUPT, NULL) == FAIL)\n\t\tgoto theend;\n\t    did_throw = TRUE;\n\t}\n\n\tif (unlikely(did_emsg && msg_list != NULL && *msg_list != NULL))\n\t{\n\t    // Turn an error message into an exception.\n\t    did_emsg = FALSE;\n\t    if (throw_exception(*msg_list, ET_ERROR, NULL) == FAIL)\n\t\tgoto theend;\n\t    did_throw = TRUE;\n\t    *msg_list = NULL;\n\t}\n\n\tif (unlikely(did_throw))\n\t{\n\t    garray_T\t*trystack = &ectx->ec_trystack;\n\t    trycmd_T    *trycmd = NULL;\n\t    int\t\tindex = trystack->ga_len;\n\n\t    // An exception jumps to the first catch, finally, or returns from\n\t    // the current function.\n\t    while (index > 0)\n\t    {\n\t\ttrycmd = ((trycmd_T *)trystack->ga_data) + index - 1;\n\t\tif (!trycmd->tcd_in_catch || trycmd->tcd_finally_idx != 0)\n\t\t    break;\n\t\t// In the catch and finally block of this try we have to go up\n\t\t// one level.\n\t\t--index;\n\t\ttrycmd = NULL;\n\t    }\n\t    if (trycmd != NULL && trycmd->tcd_frame_idx == ectx->ec_frame_idx)\n\t    {\n\t\tif (trycmd->tcd_in_catch)\n\t\t{\n\t\t    // exception inside \":catch\", jump to \":finally\" once\n\t\t    ectx->ec_iidx = trycmd->tcd_finally_idx;\n\t\t    trycmd->tcd_finally_idx = 0;\n\t\t}\n\t\telse\n\t\t    // jump to first \":catch\"\n\t\t    ectx->ec_iidx = trycmd->tcd_catch_idx;\n\t\ttrycmd->tcd_in_catch = TRUE;\n\t\tdid_throw = FALSE;  // don't come back here until :endtry\n\t\ttrycmd->tcd_did_throw = TRUE;\n\t    }\n\t    else\n\t    {\n\t\t// Not inside try or need to return from current functions.\n\t\t// Push a dummy return value.\n\t\tif (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t    goto theend;\n\t\ttv = STACK_TV_BOT(0);\n\t\ttv->v_type = VAR_NUMBER;\n\t\ttv->vval.v_number = 0;\n\t\t++ectx->ec_stack.ga_len;\n\t\tif (ectx->ec_frame_idx == ectx->ec_initial_frame_idx)\n\t\t{\n\t\t    // At the toplevel we are done.\n\t\t    need_rethrow = TRUE;\n\t\t    if (handle_closure_in_use(ectx, FALSE) == FAIL)\n\t\t\tgoto theend;\n\t\t    goto done;\n\t\t}\n\n\t\tif (func_return(ectx) == FAIL)\n\t\t    goto theend;\n\t    }\n\t    continue;\n\t}\n\n\tiptr = &ectx->ec_instr[ectx->ec_iidx++];\n\tswitch (iptr->isn_type)\n\t{\n\t    // execute Ex command line\n\t    case ISN_EXEC:\n\t\tif (exec_command(iptr) == FAIL)\n\t\t    goto on_error;\n\t\tbreak;\n\n\t    // execute Ex command line split at NL characters.\n\t    case ISN_EXEC_SPLIT:\n\t\t{\n\t\t    source_cookie_T cookie;\n\t\t    char_u\t    *line;\n\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    CLEAR_FIELD(cookie);\n\t\t    cookie.sourcing_lnum = iptr->isn_lnum - 1;\n\t\t    cookie.nextline = iptr->isn_arg.string;\n\t\t    line = get_split_sourceline(0, &cookie, 0, 0);\n\t\t    if (do_cmdline(line,\n\t\t\t\tget_split_sourceline, &cookie,\n\t\t\t\t   DOCMD_VERBOSE|DOCMD_NOWAIT|DOCMD_KEYTYPED)\n\t\t\t\t\t\t\t\t\t== FAIL\n\t\t\t\t|| did_emsg)\n\t\t    {\n\t\t\tvim_free(line);\n\t\t\tgoto on_error;\n\t\t    }\n\t\t    vim_free(line);\n\t\t}\n\t\tbreak;\n\n\t    // execute Ex command line that is only a range\n\t    case ISN_EXECRANGE:\n\t\t{\n\t\t    exarg_T\tea;\n\t\t    char\t*error = NULL;\n\n\t\t    CLEAR_FIELD(ea);\n\t\t    ea.cmdidx = CMD_SIZE;\n\t\t    ea.addr_type = ADDR_LINES;\n\t\t    ea.cmd = iptr->isn_arg.string;\n\t\t    parse_cmd_address(&ea, &error, FALSE);\n\t\t    if (ea.cmd == NULL)\n\t\t\tgoto on_error;\n\t\t    if (error == NULL)\n\t\t\terror = ex_range_without_command(&ea);\n\t\t    if (error != NULL)\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\temsg(error);\n\t\t\tgoto on_error;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    // Evaluate an expression with legacy syntax, push it onto the\n\t    // stack.\n\t    case ISN_LEGACY_EVAL:\n\t\t{\n\t\t    char_u  *arg = iptr->isn_arg.string;\n\t\t    int\t    res;\n\t\t    int\t    save_flags = cmdmod.cmod_flags;\n\n\t\t    if (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t\tgoto theend;\n\t\t    tv = STACK_TV_BOT(0);\n\t\t    init_tv(tv);\n\t\t    cmdmod.cmod_flags |= CMOD_LEGACY;\n\t\t    res = eval0(arg, tv, NULL, &EVALARG_EVALUATE);\n\t\t    cmdmod.cmod_flags = save_flags;\n\t\t    if (res == FAIL)\n\t\t\tgoto on_error;\n\t\t    ++ectx->ec_stack.ga_len;\n\t\t}\n\t\tbreak;\n\n\t    // push typeval VAR_INSTR with instructions to be executed\n\t    case ISN_INSTR:\n\t\t{\n\t\t    if (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t\tgoto theend;\n\t\t    tv = STACK_TV_BOT(0);\n\t\t    tv->vval.v_instr = ALLOC_ONE(instr_T);\n\t\t    if (tv->vval.v_instr == NULL)\n\t\t\tgoto on_error;\n\t\t    ++ectx->ec_stack.ga_len;\n\n\t\t    tv->v_type = VAR_INSTR;\n\t\t    tv->vval.v_instr->instr_ectx = ectx;\n\t\t    tv->vval.v_instr->instr_instr = iptr->isn_arg.instr;\n\t\t}\n\t\tbreak;\n\n\t    // execute :substitute with an expression\n\t    case ISN_SUBSTITUTE:\n\t\t{\n\t\t    subs_T\t\t*subs = &iptr->isn_arg.subs;\n\t\t    source_cookie_T\tcookie;\n\t\t    struct subs_expr_S\t*save_instr = substitute_instr;\n\t\t    struct subs_expr_S\tsubs_instr;\n\t\t    int\t\t\tres;\n\n\t\t    subs_instr.subs_ectx = ectx;\n\t\t    subs_instr.subs_instr = subs->subs_instr;\n\t\t    subs_instr.subs_status = OK;\n\t\t    substitute_instr = &subs_instr;\n\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    // This is very much like ISN_EXEC\n\t\t    CLEAR_FIELD(cookie);\n\t\t    cookie.sourcing_lnum = iptr->isn_lnum - 1;\n\t\t    res = do_cmdline(subs->subs_cmd,\n\t\t\t\tgetsourceline, &cookie,\n\t\t\t\t   DOCMD_VERBOSE|DOCMD_NOWAIT|DOCMD_KEYTYPED);\n\t\t    substitute_instr = save_instr;\n\n\t\t    if (res == FAIL || did_emsg\n\t\t\t\t\t     || subs_instr.subs_status == FAIL)\n\t\t\tgoto on_error;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_FINISH:\n\t\tgoto done;\n\n\t    case ISN_REDIRSTART:\n\t\t// create a dummy entry for var_redir_str()\n\t\tif (alloc_redir_lval() == FAIL)\n\t\t    goto on_error;\n\n\t\t// The output is stored in growarray \"redir_ga\" until\n\t\t// redirection ends.\n\t\tinit_redir_ga();\n\t\tredir_vname = 1;\n\t\tbreak;\n\n\t    case ISN_REDIREND:\n\t\t{\n\t\t    char_u *res = get_clear_redir_ga();\n\n\t\t    // End redirection, put redirected text on the stack.\n\t\t    clear_redir_lval();\n\t\t    redir_vname = 0;\n\n\t\t    if (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t    {\n\t\t\tvim_free(res);\n\t\t\tgoto theend;\n\t\t    }\n\t\t    tv = STACK_TV_BOT(0);\n\t\t    tv->v_type = VAR_STRING;\n\t\t    tv->vval.v_string = res;\n\t\t    ++ectx->ec_stack.ga_len;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_CEXPR_AUCMD:\n#ifdef FEAT_QUICKFIX\n\t\tif (trigger_cexpr_autocmd(iptr->isn_arg.number) == FAIL)\n\t\t    goto on_error;\n#endif\n\t\tbreak;\n\n\t    case ISN_CEXPR_CORE:\n#ifdef FEAT_QUICKFIX\n\t\t{\n\t\t    exarg_T ea;\n\t\t    int\t    res;\n\n\t\t    CLEAR_FIELD(ea);\n\t\t    ea.cmdidx = iptr->isn_arg.cexpr.cexpr_ref->cer_cmdidx;\n\t\t    ea.forceit = iptr->isn_arg.cexpr.cexpr_ref->cer_forceit;\n\t\t    ea.cmdlinep = &iptr->isn_arg.cexpr.cexpr_ref->cer_cmdline;\n\t\t    --ectx->ec_stack.ga_len;\n\t\t    tv = STACK_TV_BOT(0);\n\t\t    res = cexpr_core(&ea, tv);\n\t\t    clear_tv(tv);\n\t\t    if (res == FAIL)\n\t\t\tgoto on_error;\n\t\t}\n#endif\n\t\tbreak;\n\n\t    // execute Ex command from pieces on the stack\n\t    case ISN_EXECCONCAT:\n\t\t{\n\t\t    int\t    count = iptr->isn_arg.number;\n\t\t    size_t  len = 0;\n\t\t    int\t    pass;\n\t\t    int\t    i;\n\t\t    char_u  *cmd = NULL;\n\t\t    char_u  *str;\n\n\t\t    for (pass = 1; pass <= 2; ++pass)\n\t\t    {\n\t\t\tfor (i = 0; i < count; ++i)\n\t\t\t{\n\t\t\t    tv = STACK_TV_BOT(i - count);\n\t\t\t    str = tv->vval.v_string;\n\t\t\t    if (str != NULL && *str != NUL)\n\t\t\t    {\n\t\t\t\tif (pass == 2)\n\t\t\t\t    STRCPY(cmd + len, str);\n\t\t\t\tlen += STRLEN(str);\n\t\t\t    }\n\t\t\t    if (pass == 2)\n\t\t\t\tclear_tv(tv);\n\t\t\t}\n\t\t\tif (pass == 1)\n\t\t\t{\n\t\t\t    cmd = alloc(len + 1);\n\t\t\t    if (unlikely(cmd == NULL))\n\t\t\t\tgoto theend;\n\t\t\t    len = 0;\n\t\t\t}\n\t\t    }\n\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    do_cmdline_cmd(cmd);\n\t\t    vim_free(cmd);\n\t\t}\n\t\tbreak;\n\n\t    // execute :echo {string} ...\n\t    case ISN_ECHO:\n\t\t{\n\t\t    int count = iptr->isn_arg.echo.echo_count;\n\t\t    int\tatstart = TRUE;\n\t\t    int needclr = TRUE;\n\t\t    int\tidx;\n\n\t\t    for (idx = 0; idx < count; ++idx)\n\t\t    {\n\t\t\ttv = STACK_TV_BOT(idx - count);\n\t\t\techo_one(tv, iptr->isn_arg.echo.echo_with_white,\n\t\t\t\t\t\t\t   &atstart, &needclr);\n\t\t\tclear_tv(tv);\n\t\t    }\n\t\t    if (needclr)\n\t\t\tmsg_clr_eos();\n\t\t    ectx->ec_stack.ga_len -= count;\n\t\t}\n\t\tbreak;\n\n\t    // :execute {string} ...\n\t    // :echomsg {string} ...\n\t    // :echoconsole {string} ...\n\t    // :echoerr {string} ...\n\t    case ISN_EXECUTE:\n\t    case ISN_ECHOMSG:\n\t    case ISN_ECHOCONSOLE:\n\t    case ISN_ECHOERR:\n\t\t{\n\t\t    int\t\tcount = iptr->isn_arg.number;\n\t\t    garray_T\tga;\n\t\t    char_u\tbuf[NUMBUFLEN];\n\t\t    char_u\t*p;\n\t\t    int\t\tlen;\n\t\t    int\t\tfailed = FALSE;\n\t\t    int\t\tidx;\n\n\t\t    ga_init2(&ga, 1, 80);\n\t\t    for (idx = 0; idx < count; ++idx)\n\t\t    {\n\t\t\ttv = STACK_TV_BOT(idx - count);\n\t\t\tif (iptr->isn_type == ISN_EXECUTE)\n\t\t\t{\n\t\t\t    if (tv->v_type == VAR_CHANNEL\n\t\t\t\t\t\t      || tv->v_type == VAR_JOB)\n\t\t\t    {\n\t\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\t\tsemsg(_(e_using_invalid_value_as_string_str),\n\t\t\t\t\t\t    vartype_name(tv->v_type));\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t    else\n\t\t\t\tp = tv_get_string_buf(tv, buf);\n\t\t\t}\n\t\t\telse\n\t\t\t    p = tv_stringify(tv, buf);\n\n\t\t\tlen = (int)STRLEN(p);\n\t\t\tif (GA_GROW_FAILS(&ga, len + 2))\n\t\t\t    failed = TRUE;\n\t\t\telse\n\t\t\t{\n\t\t\t    if (ga.ga_len > 0)\n\t\t\t\t((char_u *)(ga.ga_data))[ga.ga_len++] = ' ';\n\t\t\t    STRCPY((char_u *)(ga.ga_data) + ga.ga_len, p);\n\t\t\t    ga.ga_len += len;\n\t\t\t}\n\t\t\tclear_tv(tv);\n\t\t    }\n\t\t    ectx->ec_stack.ga_len -= count;\n\t\t    if (failed)\n\t\t    {\n\t\t\tga_clear(&ga);\n\t\t\tgoto on_error;\n\t\t    }\n\n\t\t    if (ga.ga_data != NULL)\n\t\t    {\n\t\t\tif (iptr->isn_type == ISN_EXECUTE)\n\t\t\t{\n\t\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t\t    do_cmdline_cmd((char_u *)ga.ga_data);\n\t\t\t    if (did_emsg)\n\t\t\t    {\n\t\t\t\tga_clear(&ga);\n\t\t\t\tgoto on_error;\n\t\t\t    }\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    msg_sb_eol();\n\t\t\t    if (iptr->isn_type == ISN_ECHOMSG)\n\t\t\t    {\n\t\t\t\tmsg_attr(ga.ga_data, echo_attr);\n\t\t\t\tout_flush();\n\t\t\t    }\n\t\t\t    else if (iptr->isn_type == ISN_ECHOCONSOLE)\n\t\t\t    {\n\t\t\t\tui_write(ga.ga_data, (int)STRLEN(ga.ga_data),\n\t\t\t\t\t\t\t\t\t TRUE);\n\t\t\t\tui_write((char_u *)\"\\r\\n\", 2, TRUE);\n\t\t\t    }\n\t\t\t    else\n\t\t\t    {\n\t\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\t\temsg(ga.ga_data);\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    ga_clear(&ga);\n\t\t}\n\t\tbreak;\n\n\t    // load local variable or argument\n\t    case ISN_LOAD:\n\t\tif (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t    goto theend;\n\t\tcopy_tv(STACK_TV_VAR(iptr->isn_arg.number), STACK_TV_BOT(0));\n\t\t++ectx->ec_stack.ga_len;\n\t\tbreak;\n\n\t    // load v: variable\n\t    case ISN_LOADV:\n\t\tif (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t    goto theend;\n\t\tcopy_tv(get_vim_var_tv(iptr->isn_arg.number), STACK_TV_BOT(0));\n\t\t++ectx->ec_stack.ga_len;\n\t\tbreak;\n\n\t    // load s: variable in Vim9 script\n\t    case ISN_LOADSCRIPT:\n\t\t{\n\t\t    scriptref_T\t*sref = iptr->isn_arg.script.scriptref;\n\t\t    svar_T\t *sv;\n\n\t\t    sv = get_script_svar(sref, ectx->ec_dfunc_idx);\n\t\t    if (sv == NULL)\n\t\t\tgoto theend;\n\t\t    allocate_if_null(sv->sv_tv);\n\t\t    if (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t\tgoto theend;\n\t\t    copy_tv(sv->sv_tv, STACK_TV_BOT(0));\n\t\t    ++ectx->ec_stack.ga_len;\n\t\t}\n\t\tbreak;\n\n\t    // load s: variable in old script\n\t    case ISN_LOADS:\n\t\t{\n\t\t    hashtab_T\t*ht = &SCRIPT_VARS(\n\t\t\t\t\t       iptr->isn_arg.loadstore.ls_sid);\n\t\t    char_u\t*name = iptr->isn_arg.loadstore.ls_name;\n\t\t    dictitem_T\t*di = find_var_in_ht(ht, 0, name, TRUE);\n\n\t\t    if (di == NULL)\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\tsemsg(_(e_undefined_variable_str), name);\n\t\t\tgoto on_error;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t\t    goto theend;\n\t\t\tcopy_tv(&di->di_tv, STACK_TV_BOT(0));\n\t\t\t++ectx->ec_stack.ga_len;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    // load g:/b:/w:/t: variable\n\t    case ISN_LOADG:\n\t    case ISN_LOADB:\n\t    case ISN_LOADW:\n\t    case ISN_LOADT:\n\t\t{\n\t\t    dictitem_T *di = NULL;\n\t\t    hashtab_T *ht = NULL;\n\t\t    char namespace;\n\n\t\t    switch (iptr->isn_type)\n\t\t    {\n\t\t\tcase ISN_LOADG:\n\t\t\t    ht = get_globvar_ht();\n\t\t\t    namespace = 'g';\n\t\t\t    break;\n\t\t\tcase ISN_LOADB:\n\t\t\t    ht = &curbuf->b_vars->dv_hashtab;\n\t\t\t    namespace = 'b';\n\t\t\t    break;\n\t\t\tcase ISN_LOADW:\n\t\t\t    ht = &curwin->w_vars->dv_hashtab;\n\t\t\t    namespace = 'w';\n\t\t\t    break;\n\t\t\tcase ISN_LOADT:\n\t\t\t    ht = &curtab->tp_vars->dv_hashtab;\n\t\t\t    namespace = 't';\n\t\t\t    break;\n\t\t\tdefault:  // Cannot reach here\n\t\t\t    goto theend;\n\t\t    }\n\t\t    di = find_var_in_ht(ht, 0, iptr->isn_arg.string, TRUE);\n\n\t\t    if (di == NULL)\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\tsemsg(_(e_undefined_variable_char_str),\n\t\t\t\t\t     namespace, iptr->isn_arg.string);\n\t\t\tgoto on_error;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t\t    goto theend;\n\t\t\tcopy_tv(&di->di_tv, STACK_TV_BOT(0));\n\t\t\t++ectx->ec_stack.ga_len;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    // load autoload variable\n\t    case ISN_LOADAUTO:\n\t\t{\n\t\t    char_u *name = iptr->isn_arg.string;\n\n\t\t    if (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t\tgoto theend;\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    if (eval_variable(name, (int)STRLEN(name),\n\t\t\t      STACK_TV_BOT(0), NULL, EVAL_VAR_VERBOSE) == FAIL)\n\t\t\tgoto on_error;\n\t\t    ++ectx->ec_stack.ga_len;\n\t\t}\n\t\tbreak;\n\n\t    // load g:/b:/w:/t: namespace\n\t    case ISN_LOADGDICT:\n\t    case ISN_LOADBDICT:\n\t    case ISN_LOADWDICT:\n\t    case ISN_LOADTDICT:\n\t\t{\n\t\t    dict_T *d = NULL;\n\n\t\t    switch (iptr->isn_type)\n\t\t    {\n\t\t\tcase ISN_LOADGDICT: d = get_globvar_dict(); break;\n\t\t\tcase ISN_LOADBDICT: d = curbuf->b_vars; break;\n\t\t\tcase ISN_LOADWDICT: d = curwin->w_vars; break;\n\t\t\tcase ISN_LOADTDICT: d = curtab->tp_vars; break;\n\t\t\tdefault:  // Cannot reach here\n\t\t\t    goto theend;\n\t\t    }\n\t\t    if (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t\tgoto theend;\n\t\t    tv = STACK_TV_BOT(0);\n\t\t    tv->v_type = VAR_DICT;\n\t\t    tv->v_lock = 0;\n\t\t    tv->vval.v_dict = d;\n\t\t    ++d->dv_refcount;\n\t\t    ++ectx->ec_stack.ga_len;\n\t\t}\n\t\tbreak;\n\n\t    // load &option\n\t    case ISN_LOADOPT:\n\t\t{\n\t\t    typval_T\toptval;\n\t\t    char_u\t*name = iptr->isn_arg.string;\n\n\t\t    // This is not expected to fail, name is checked during\n\t\t    // compilation: don't set SOURCING_LNUM.\n\t\t    if (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t\tgoto theend;\n\t\t    if (eval_option(&name, &optval, TRUE) == FAIL)\n\t\t\tgoto theend;\n\t\t    *STACK_TV_BOT(0) = optval;\n\t\t    ++ectx->ec_stack.ga_len;\n\t\t}\n\t\tbreak;\n\n\t    // load $ENV\n\t    case ISN_LOADENV:\n\t\t{\n\t\t    typval_T\toptval;\n\t\t    char_u\t*name = iptr->isn_arg.string;\n\n\t\t    if (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t\tgoto theend;\n\t\t    // name is always valid, checked when compiling\n\t\t    (void)eval_env_var(&name, &optval, TRUE);\n\t\t    *STACK_TV_BOT(0) = optval;\n\t\t    ++ectx->ec_stack.ga_len;\n\t\t}\n\t\tbreak;\n\n\t    // load @register\n\t    case ISN_LOADREG:\n\t\tif (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t    goto theend;\n\t\ttv = STACK_TV_BOT(0);\n\t\ttv->v_type = VAR_STRING;\n\t\ttv->v_lock = 0;\n\t\t// This may result in NULL, which should be equivalent to an\n\t\t// empty string.\n\t\ttv->vval.v_string = get_reg_contents(\n\t\t\t\t\t  iptr->isn_arg.number, GREG_EXPR_SRC);\n\t\t++ectx->ec_stack.ga_len;\n\t\tbreak;\n\n\t    // store local variable\n\t    case ISN_STORE:\n\t\t--ectx->ec_stack.ga_len;\n\t\ttv = STACK_TV_VAR(iptr->isn_arg.number);\n\t\tclear_tv(tv);\n\t\t*tv = *STACK_TV_BOT(0);\n\t\tbreak;\n\n\t    // store s: variable in old script\n\t    case ISN_STORES:\n\t\t{\n\t\t    hashtab_T\t*ht = &SCRIPT_VARS(\n\t\t\t\t\t       iptr->isn_arg.loadstore.ls_sid);\n\t\t    char_u\t*name = iptr->isn_arg.loadstore.ls_name;\n\t\t    dictitem_T\t*di = find_var_in_ht(ht, 0, name + 2, TRUE);\n\n\t\t    --ectx->ec_stack.ga_len;\n\t\t    if (di == NULL)\n\t\t\tstore_var(name, STACK_TV_BOT(0));\n\t\t    else\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\tif (var_check_permission(di, name) == FAIL)\n\t\t\t{\n\t\t\t    clear_tv(STACK_TV_BOT(0));\n\t\t\t    goto on_error;\n\t\t\t}\n\t\t\tclear_tv(&di->di_tv);\n\t\t\tdi->di_tv = *STACK_TV_BOT(0);\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    // store script-local variable in Vim9 script\n\t    case ISN_STORESCRIPT:\n\t\t{\n\t\t    scriptref_T\t    *sref = iptr->isn_arg.script.scriptref;\n\t\t    svar_T\t    *sv;\n\n\t\t    sv = get_script_svar(sref, ectx->ec_dfunc_idx);\n\t\t    if (sv == NULL)\n\t\t\tgoto theend;\n\t\t    --ectx->ec_stack.ga_len;\n\n\t\t    // \"const\" and \"final\" are checked at compile time, locking\n\t\t    // the value needs to be checked here.\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    if (value_check_lock(sv->sv_tv->v_lock, sv->sv_name, FALSE))\n\t\t    {\n\t\t\tclear_tv(STACK_TV_BOT(0));\n\t\t\tgoto on_error;\n\t\t    }\n\n\t\t    clear_tv(sv->sv_tv);\n\t\t    *sv->sv_tv = *STACK_TV_BOT(0);\n\t\t}\n\t\tbreak;\n\n\t    // store option\n\t    case ISN_STOREOPT:\n\t    case ISN_STOREFUNCOPT:\n\t\t{\n\t\t    char_u\t*opt_name = iptr->isn_arg.storeopt.so_name;\n\t\t    int\t\topt_flags = iptr->isn_arg.storeopt.so_flags;\n\t\t    long\tn = 0;\n\t\t    char_u\t*s = NULL;\n\t\t    char\t*msg;\n\t\t    char_u\tnumbuf[NUMBUFLEN];\n\t\t    char_u\t*tofree = NULL;\n\n\t\t    --ectx->ec_stack.ga_len;\n\t\t    tv = STACK_TV_BOT(0);\n\t\t    if (tv->v_type == VAR_STRING)\n\t\t    {\n\t\t\ts = tv->vval.v_string;\n\t\t\tif (s == NULL)\n\t\t\t    s = (char_u *)\"\";\n\t\t    }\n\t\t    else if (iptr->isn_type == ISN_STOREFUNCOPT)\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\t// If the option can be set to a function reference or\n\t\t\t// a lambda and the passed value is a function\n\t\t\t// reference, then convert it to the name (string) of\n\t\t\t// the function reference.\n\t\t\ts = tv2string(tv, &tofree, numbuf, 0);\n\t\t\tif (s == NULL || *s == NUL)\n\t\t\t{\n\t\t\t    clear_tv(tv);\n\t\t\t    goto on_error;\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t\t// must be VAR_NUMBER, CHECKTYPE makes sure\n\t\t\tn = tv->vval.v_number;\n\t\t    msg = set_option_value(opt_name, n, s, opt_flags);\n\t\t    clear_tv(tv);\n\t\t    vim_free(tofree);\n\t\t    if (msg != NULL)\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\temsg(_(msg));\n\t\t\tgoto on_error;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    // store $ENV\n\t    case ISN_STOREENV:\n\t\t--ectx->ec_stack.ga_len;\n\t\ttv = STACK_TV_BOT(0);\n\t\tvim_setenv_ext(iptr->isn_arg.string, tv_get_string(tv));\n\t\tclear_tv(tv);\n\t\tbreak;\n\n\t    // store @r\n\t    case ISN_STOREREG:\n\t\t{\n\t\t    int\treg = iptr->isn_arg.number;\n\n\t\t    --ectx->ec_stack.ga_len;\n\t\t    tv = STACK_TV_BOT(0);\n\t\t    write_reg_contents(reg, tv_get_string(tv), -1, FALSE);\n\t\t    clear_tv(tv);\n\t\t}\n\t\tbreak;\n\n\t    // store v: variable\n\t    case ISN_STOREV:\n\t\t--ectx->ec_stack.ga_len;\n\t\tif (set_vim_var_tv(iptr->isn_arg.number, STACK_TV_BOT(0))\n\t\t\t\t\t\t\t\t       == FAIL)\n\t\t    // should not happen, type is checked when compiling\n\t\t    goto on_error;\n\t\tbreak;\n\n\t    // store g:/b:/w:/t: variable\n\t    case ISN_STOREG:\n\t    case ISN_STOREB:\n\t    case ISN_STOREW:\n\t    case ISN_STORET:\n\t\t{\n\t\t    dictitem_T\t*di;\n\t\t    hashtab_T\t*ht;\n\t\t    char_u\t*name = iptr->isn_arg.string + 2;\n\n\t\t    switch (iptr->isn_type)\n\t\t    {\n\t\t\tcase ISN_STOREG:\n\t\t\t    ht = get_globvar_ht();\n\t\t\t    break;\n\t\t\tcase ISN_STOREB:\n\t\t\t    ht = &curbuf->b_vars->dv_hashtab;\n\t\t\t    break;\n\t\t\tcase ISN_STOREW:\n\t\t\t    ht = &curwin->w_vars->dv_hashtab;\n\t\t\t    break;\n\t\t\tcase ISN_STORET:\n\t\t\t    ht = &curtab->tp_vars->dv_hashtab;\n\t\t\t    break;\n\t\t\tdefault:  // Cannot reach here\n\t\t\t    goto theend;\n\t\t    }\n\n\t\t    --ectx->ec_stack.ga_len;\n\t\t    di = find_var_in_ht(ht, 0, name, TRUE);\n\t\t    if (di == NULL)\n\t\t\tstore_var(iptr->isn_arg.string, STACK_TV_BOT(0));\n\t\t    else\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\tif (var_check_permission(di, name) == FAIL)\n\t\t\t    goto on_error;\n\t\t\tclear_tv(&di->di_tv);\n\t\t\tdi->di_tv = *STACK_TV_BOT(0);\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    // store an autoload variable\n\t    case ISN_STOREAUTO:\n\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\tset_var(iptr->isn_arg.string, STACK_TV_BOT(-1), TRUE);\n\t\tclear_tv(STACK_TV_BOT(-1));\n\t\t--ectx->ec_stack.ga_len;\n\t\tbreak;\n\n\t    // store number in local variable\n\t    case ISN_STORENR:\n\t\ttv = STACK_TV_VAR(iptr->isn_arg.storenr.stnr_idx);\n\t\tclear_tv(tv);\n\t\ttv->v_type = VAR_NUMBER;\n\t\ttv->vval.v_number = iptr->isn_arg.storenr.stnr_val;\n\t\tbreak;\n\n\t    // store value in list or dict variable\n\t    case ISN_STOREINDEX:\n\t\t{\n\t\t    vartype_T\tdest_type = iptr->isn_arg.vartype;\n\t\t    typval_T\t*tv_idx = STACK_TV_BOT(-2);\n\t\t    typval_T\t*tv_dest = STACK_TV_BOT(-1);\n\t\t    int\t\tstatus = OK;\n\n\t\t    // Stack contains:\n\t\t    // -3 value to be stored\n\t\t    // -2 index\n\t\t    // -1 dict or list\n\t\t    tv = STACK_TV_BOT(-3);\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    if (dest_type == VAR_ANY)\n\t\t    {\n\t\t\tdest_type = tv_dest->v_type;\n\t\t\tif (dest_type == VAR_DICT)\n\t\t\t    status = do_2string(tv_idx, TRUE, FALSE);\n\t\t\telse if (dest_type == VAR_LIST\n\t\t\t\t\t       && tv_idx->v_type != VAR_NUMBER)\n\t\t\t{\n\t\t\t    emsg(_(e_number_expected));\n\t\t\t    status = FAIL;\n\t\t\t}\n\t\t    }\n\t\t    else if (dest_type != tv_dest->v_type)\n\t\t    {\n\t\t\t// just in case, should be OK\n\t\t\tsemsg(_(e_expected_str_but_got_str),\n\t\t\t\t    vartype_name(dest_type),\n\t\t\t\t    vartype_name(tv_dest->v_type));\n\t\t\tstatus = FAIL;\n\t\t    }\n\n\t\t    if (status == OK && dest_type == VAR_LIST)\n\t\t    {\n\t\t\tlong\t    lidx = (long)tv_idx->vval.v_number;\n\t\t\tlist_T\t    *list = tv_dest->vval.v_list;\n\n\t\t\tif (list == NULL)\n\t\t\t{\n\t\t\t    emsg(_(e_list_not_set));\n\t\t\t    goto on_error;\n\t\t\t}\n\t\t\tif (lidx < 0 && list->lv_len + lidx >= 0)\n\t\t\t    // negative index is relative to the end\n\t\t\t    lidx = list->lv_len + lidx;\n\t\t\tif (lidx < 0 || lidx > list->lv_len)\n\t\t\t{\n\t\t\t    semsg(_(e_listidx), lidx);\n\t\t\t    goto on_error;\n\t\t\t}\n\t\t\tif (lidx < list->lv_len)\n\t\t\t{\n\t\t\t    listitem_T *li = list_find(list, lidx);\n\n\t\t\t    if (error_if_locked(li->li_tv.v_lock,\n\t\t\t\t\t\t    e_cannot_change_list_item))\n\t\t\t\tgoto on_error;\n\t\t\t    // overwrite existing list item\n\t\t\t    clear_tv(&li->li_tv);\n\t\t\t    li->li_tv = *tv;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    if (error_if_locked(list->lv_lock,\n\t\t\t\t\t\t\t e_cannot_change_list))\n\t\t\t\tgoto on_error;\n\t\t\t    // append to list, only fails when out of memory\n\t\t\t    if (list_append_tv(list, tv) == FAIL)\n\t\t\t\tgoto theend;\n\t\t\t    clear_tv(tv);\n\t\t\t}\n\t\t    }\n\t\t    else if (status == OK && dest_type == VAR_DICT)\n\t\t    {\n\t\t\tchar_u\t\t*key = tv_idx->vval.v_string;\n\t\t\tdict_T\t\t*dict = tv_dest->vval.v_dict;\n\t\t\tdictitem_T\t*di;\n\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\tif (dict == NULL)\n\t\t\t{\n\t\t\t    emsg(_(e_dictionary_not_set));\n\t\t\t    goto on_error;\n\t\t\t}\n\t\t\tif (key == NULL)\n\t\t\t    key = (char_u *)\"\";\n\t\t\tdi = dict_find(dict, key, -1);\n\t\t\tif (di != NULL)\n\t\t\t{\n\t\t\t    if (error_if_locked(di->di_tv.v_lock,\n\t\t\t\t\t\t    e_cannot_change_dict_item))\n\t\t\t\tgoto on_error;\n\t\t\t    // overwrite existing value\n\t\t\t    clear_tv(&di->di_tv);\n\t\t\t    di->di_tv = *tv;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    if (error_if_locked(dict->dv_lock,\n\t\t\t\t\t\t\t e_cannot_change_dict))\n\t\t\t\tgoto on_error;\n\t\t\t    // add to dict, only fails when out of memory\n\t\t\t    if (dict_add_tv(dict, (char *)key, tv) == FAIL)\n\t\t\t\tgoto theend;\n\t\t\t    clear_tv(tv);\n\t\t\t}\n\t\t    }\n\t\t    else if (status == OK && dest_type == VAR_BLOB)\n\t\t    {\n\t\t\tlong\t    lidx = (long)tv_idx->vval.v_number;\n\t\t\tblob_T\t    *blob = tv_dest->vval.v_blob;\n\t\t\tvarnumber_T nr;\n\t\t\tint\t    error = FALSE;\n\t\t\tint\t    len;\n\n\t\t\tif (blob == NULL)\n\t\t\t{\n\t\t\t    emsg(_(e_blob_not_set));\n\t\t\t    goto on_error;\n\t\t\t}\n\t\t\tlen = blob_len(blob);\n\t\t\tif (lidx < 0 && len + lidx >= 0)\n\t\t\t    // negative index is relative to the end\n\t\t\t    lidx = len + lidx;\n\n\t\t\t// Can add one byte at the end.\n\t\t\tif (lidx < 0 || lidx > len)\n\t\t\t{\n\t\t\t    semsg(_(e_blobidx), lidx);\n\t\t\t    goto on_error;\n\t\t\t}\n\t\t\tif (value_check_lock(blob->bv_lock,\n\t\t\t\t\t\t      (char_u *)\"blob\", FALSE))\n\t\t\t    goto on_error;\n\t\t\tnr = tv_get_number_chk(tv, &error);\n\t\t\tif (error)\n\t\t\t    goto on_error;\n\t\t\tblob_set_append(blob, lidx, nr);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tstatus = FAIL;\n\t\t\tsemsg(_(e_cannot_index_str), vartype_name(dest_type));\n\t\t    }\n\n\t\t    clear_tv(tv_idx);\n\t\t    clear_tv(tv_dest);\n\t\t    ectx->ec_stack.ga_len -= 3;\n\t\t    if (status == FAIL)\n\t\t    {\n\t\t\tclear_tv(tv);\n\t\t\tgoto on_error;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    // store value in blob range\n\t    case ISN_STORERANGE:\n\t\t{\n\t\t    typval_T\t*tv_idx1 = STACK_TV_BOT(-3);\n\t\t    typval_T\t*tv_idx2 = STACK_TV_BOT(-2);\n\t\t    typval_T\t*tv_dest = STACK_TV_BOT(-1);\n\t\t    int\t\tstatus = OK;\n\n\t\t    // Stack contains:\n\t\t    // -4 value to be stored\n\t\t    // -3 first index or \"none\"\n\t\t    // -2 second index or \"none\"\n\t\t    // -1 destination list or blob\n\t\t    tv = STACK_TV_BOT(-4);\n\t\t    if (tv_dest->v_type == VAR_LIST)\n\t\t    {\n\t\t\tlong\tn1;\n\t\t\tlong\tn2;\n\t\t\tint\terror = FALSE;\n\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\tn1 = (long)tv_get_number_chk(tv_idx1, &error);\n\t\t\tif (error)\n\t\t\t    status = FAIL;\n\t\t\telse\n\t\t\t{\n\t\t\t    if (tv_idx2->v_type == VAR_SPECIAL\n\t\t\t\t\t&& tv_idx2->vval.v_number == VVAL_NONE)\n\t\t\t\tn2 = list_len(tv_dest->vval.v_list) - 1;\n\t\t\t    else\n\t\t\t\tn2 = (long)tv_get_number_chk(tv_idx2, &error);\n\t\t\t    if (error)\n\t\t\t\tstatus = FAIL;\n\t\t\t    else\n\t\t\t    {\n\t\t\t\tlistitem_T *li1 = check_range_index_one(\n\t\t\t\t\ttv_dest->vval.v_list, &n1, FALSE);\n\n\t\t\t\tif (li1 == NULL)\n\t\t\t\t    status = FAIL;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t    status = check_range_index_two(\n\t\t\t\t\t    tv_dest->vval.v_list,\n\t\t\t\t\t    &n1, li1, &n2, FALSE);\n\t\t\t\t    if (status != FAIL)\n\t\t\t\t\tstatus = list_assign_range(\n\t\t\t\t\t\ttv_dest->vval.v_list,\n\t\t\t\t\t\ttv->vval.v_list,\n\t\t\t\t\t\tn1,\n\t\t\t\t\t\tn2,\n\t\t\t\t\t\ttv_idx2->v_type == VAR_SPECIAL,\n\t\t\t\t\t\t(char_u *)\"=\",\n\t\t\t\t\t\t(char_u *)\"[unknown]\");\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    else if (tv_dest->v_type == VAR_BLOB)\n\t\t    {\n\t\t\tvarnumber_T n1;\n\t\t\tvarnumber_T n2;\n\t\t\tint\t    error = FALSE;\n\n\t\t\tn1 = tv_get_number_chk(tv_idx1, &error);\n\t\t\tif (error)\n\t\t\t    status = FAIL;\n\t\t\telse\n\t\t\t{\n\t\t\t    if (tv_idx2->v_type == VAR_SPECIAL\n\t\t\t\t\t&& tv_idx2->vval.v_number == VVAL_NONE)\n\t\t\t\tn2 = blob_len(tv_dest->vval.v_blob) - 1;\n\t\t\t    else\n\t\t\t\tn2 = tv_get_number_chk(tv_idx2, &error);\n\t\t\t    if (error)\n\t\t\t\tstatus = FAIL;\n\t\t\t    else\n\t\t\t    {\n\t\t\t\tlong  bloblen = blob_len(tv_dest->vval.v_blob);\n\n\t\t\t\tif (check_blob_index(bloblen,\n\t\t\t\t\t\t\t     n1, FALSE) == FAIL\n\t\t\t\t\t|| check_blob_range(bloblen,\n\t\t\t\t\t\t\tn1, n2, FALSE) == FAIL)\n\t\t\t\t    status = FAIL;\n\t\t\t\telse\n\t\t\t\t    status = blob_set_range(\n\t\t\t\t\t     tv_dest->vval.v_blob, n1, n2, tv);\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tstatus = FAIL;\n\t\t\temsg(_(e_blob_required));\n\t\t    }\n\n\t\t    clear_tv(tv_idx1);\n\t\t    clear_tv(tv_idx2);\n\t\t    clear_tv(tv_dest);\n\t\t    ectx->ec_stack.ga_len -= 4;\n\t\t    clear_tv(tv);\n\n\t\t    if (status == FAIL)\n\t\t\tgoto on_error;\n\t\t}\n\t\tbreak;\n\n\t    // load or store variable or argument from outer scope\n\t    case ISN_LOADOUTER:\n\t    case ISN_STOREOUTER:\n\t\t{\n\t\t    int\t\tdepth = iptr->isn_arg.outer.outer_depth;\n\t\t    outer_T\t*outer = ectx->ec_outer_ref == NULL ? NULL\n\t\t\t\t\t\t: ectx->ec_outer_ref->or_outer;\n\n\t\t    while (depth > 1 && outer != NULL)\n\t\t    {\n\t\t\touter = outer->out_up;\n\t\t\t--depth;\n\t\t    }\n\t\t    if (outer == NULL)\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\tif (ectx->ec_frame_idx == ectx->ec_initial_frame_idx\n\t\t\t\t\t\t || ectx->ec_outer_ref == NULL)\n\t\t\t    // Possibly :def function called from legacy\n\t\t\t    // context.\n\t\t\t    emsg(_(e_closure_called_from_invalid_context));\n\t\t\telse\n\t\t\t    iemsg(\"LOADOUTER depth more than scope levels\");\n\t\t\tgoto theend;\n\t\t    }\n\t\t    tv = ((typval_T *)outer->out_stack->ga_data)\n\t\t\t\t    + outer->out_frame_idx + STACK_FRAME_SIZE\n\t\t\t\t    + iptr->isn_arg.outer.outer_idx;\n\t\t    if (iptr->isn_type == ISN_LOADOUTER)\n\t\t    {\n\t\t\tif (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t\t    goto theend;\n\t\t\tcopy_tv(tv, STACK_TV_BOT(0));\n\t\t\t++ectx->ec_stack.ga_len;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t--ectx->ec_stack.ga_len;\n\t\t\tclear_tv(tv);\n\t\t\t*tv = *STACK_TV_BOT(0);\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    // unlet item in list or dict variable\n\t    case ISN_UNLETINDEX:\n\t\t{\n\t\t    typval_T\t*tv_idx = STACK_TV_BOT(-2);\n\t\t    typval_T\t*tv_dest = STACK_TV_BOT(-1);\n\t\t    int\t\tstatus = OK;\n\n\t\t    // Stack contains:\n\t\t    // -2 index\n\t\t    // -1 dict or list\n\t\t    if (tv_dest->v_type == VAR_DICT)\n\t\t    {\n\t\t\t// unlet a dict item, index must be a string\n\t\t\tif (tv_idx->v_type != VAR_STRING)\n\t\t\t{\n\t\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t\t    semsg(_(e_expected_str_but_got_str),\n\t\t\t\t\tvartype_name(VAR_STRING),\n\t\t\t\t\tvartype_name(tv_idx->v_type));\n\t\t\t    status = FAIL;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    dict_T\t*d = tv_dest->vval.v_dict;\n\t\t\t    char_u\t*key = tv_idx->vval.v_string;\n\t\t\t    dictitem_T  *di = NULL;\n\n\t\t\t    if (d != NULL && value_check_lock(\n\t\t\t\t\t\t      d->dv_lock, NULL, FALSE))\n\t\t\t\tstatus = FAIL;\n\t\t\t    else\n\t\t\t    {\n\t\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\t\tif (key == NULL)\n\t\t\t\t    key = (char_u *)\"\";\n\t\t\t\tif (d != NULL)\n\t\t\t\t    di = dict_find(d, key, (int)STRLEN(key));\n\t\t\t\tif (di == NULL)\n\t\t\t\t{\n\t\t\t\t    // NULL dict is equivalent to empty dict\n\t\t\t\t    semsg(_(e_dictkey), key);\n\t\t\t\t    status = FAIL;\n\t\t\t\t}\n\t\t\t\telse if (var_check_fixed(di->di_flags,\n\t\t\t\t\t\t\t\t   NULL, FALSE)\n\t\t\t\t\t|| var_check_ro(di->di_flags,\n\t\t\t\t\t\t\t\t  NULL, FALSE))\n\t\t\t\t    status = FAIL;\n\t\t\t\telse\n\t\t\t\t    dictitem_remove(d, di);\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    else if (tv_dest->v_type == VAR_LIST)\n\t\t    {\n\t\t\t// unlet a List item, index must be a number\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\tif (check_for_number(tv_idx) == FAIL)\n\t\t\t{\n\t\t\t    status = FAIL;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    list_T\t*l = tv_dest->vval.v_list;\n\t\t\t    long\tn = (long)tv_idx->vval.v_number;\n\n\t\t\t    if (l != NULL && value_check_lock(\n\t\t\t\t\t\t      l->lv_lock, NULL, FALSE))\n\t\t\t\tstatus = FAIL;\n\t\t\t    else\n\t\t\t    {\n\t\t\t\tlistitem_T\t*li = list_find(l, n);\n\n\t\t\t\tif (li == NULL)\n\t\t\t\t{\n\t\t\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t\t\t    semsg(_(e_listidx), n);\n\t\t\t\t    status = FAIL;\n\t\t\t\t}\n\t\t\t\telse if (value_check_lock(li->li_tv.v_lock,\n\t\t\t\t\t\t\t\t  NULL, FALSE))\n\t\t\t\t    status = FAIL;\n\t\t\t\telse\n\t\t\t\t    listitem_remove(l, li);\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tstatus = FAIL;\n\t\t\tsemsg(_(e_cannot_index_str),\n\t\t\t\t\t\tvartype_name(tv_dest->v_type));\n\t\t    }\n\n\t\t    clear_tv(tv_idx);\n\t\t    clear_tv(tv_dest);\n\t\t    ectx->ec_stack.ga_len -= 2;\n\t\t    if (status == FAIL)\n\t\t\tgoto on_error;\n\t\t}\n\t\tbreak;\n\n\t    // unlet range of items in list variable\n\t    case ISN_UNLETRANGE:\n\t\t{\n\t\t    // Stack contains:\n\t\t    // -3 index1\n\t\t    // -2 index2\n\t\t    // -1 dict or list\n\t\t    typval_T\t*tv_idx1 = STACK_TV_BOT(-3);\n\t\t    typval_T\t*tv_idx2 = STACK_TV_BOT(-2);\n\t\t    typval_T\t*tv_dest = STACK_TV_BOT(-1);\n\t\t    int\t\tstatus = OK;\n\n\t\t    if (tv_dest->v_type == VAR_LIST)\n\t\t    {\n\t\t\t// indexes must be a number\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\tif (check_for_number(tv_idx1) == FAIL\n\t\t\t\t|| (tv_idx2->v_type != VAR_SPECIAL\n\t\t\t\t\t && check_for_number(tv_idx2) == FAIL))\n\t\t\t{\n\t\t\t    status = FAIL;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    list_T\t*l = tv_dest->vval.v_list;\n\t\t\t    long\tn1 = (long)tv_idx1->vval.v_number;\n\t\t\t    long\tn2 = tv_idx2->v_type == VAR_SPECIAL\n\t\t\t\t\t    ? 0 : (long)tv_idx2->vval.v_number;\n\t\t\t    listitem_T\t*li;\n\n\t\t\t    li = list_find_index(l, &n1);\n\t\t\t    if (li == NULL)\n\t\t\t\tstatus = FAIL;\n\t\t\t    else\n\t\t\t    {\n\t\t\t\tif (n1 < 0)\n\t\t\t\t    n1 = list_idx_of_item(l, li);\n\t\t\t\tif (n2 < 0)\n\t\t\t\t{\n\t\t\t\t    listitem_T *li2 = list_find(l, n2);\n\n\t\t\t\t    if (li2 == NULL)\n\t\t\t\t\tstatus = FAIL;\n\t\t\t\t    else\n\t\t\t\t\tn2 = list_idx_of_item(l, li2);\n\t\t\t\t}\n\t\t\t\tif (status != FAIL\n\t\t\t\t\t&& tv_idx2->v_type != VAR_SPECIAL\n\t\t\t\t\t&& n2 < n1)\n\t\t\t\t{\n\t\t\t\t    semsg(_(e_listidx), n2);\n\t\t\t\t    status = FAIL;\n\t\t\t\t}\n\t\t\t\tif (status != FAIL\n\t\t\t\t\t&& list_unlet_range(l, li, NULL, n1,\n\t\t\t\t\t    tv_idx2->v_type != VAR_SPECIAL, n2)\n\t\t\t\t\t\t\t\t       == FAIL)\n\t\t\t\t    status = FAIL;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tstatus = FAIL;\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\tsemsg(_(e_cannot_index_str),\n\t\t\t\t\t\tvartype_name(tv_dest->v_type));\n\t\t    }\n\n\t\t    clear_tv(tv_idx1);\n\t\t    clear_tv(tv_idx2);\n\t\t    clear_tv(tv_dest);\n\t\t    ectx->ec_stack.ga_len -= 3;\n\t\t    if (status == FAIL)\n\t\t\tgoto on_error;\n\t\t}\n\t\tbreak;\n\n\t    // push constant\n\t    case ISN_PUSHNR:\n\t    case ISN_PUSHBOOL:\n\t    case ISN_PUSHSPEC:\n\t    case ISN_PUSHF:\n\t    case ISN_PUSHS:\n\t    case ISN_PUSHBLOB:\n\t    case ISN_PUSHFUNC:\n\t    case ISN_PUSHCHANNEL:\n\t    case ISN_PUSHJOB:\n\t\tif (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t    goto theend;\n\t\ttv = STACK_TV_BOT(0);\n\t\ttv->v_lock = 0;\n\t\t++ectx->ec_stack.ga_len;\n\t\tswitch (iptr->isn_type)\n\t\t{\n\t\t    case ISN_PUSHNR:\n\t\t\ttv->v_type = VAR_NUMBER;\n\t\t\ttv->vval.v_number = iptr->isn_arg.number;\n\t\t\tbreak;\n\t\t    case ISN_PUSHBOOL:\n\t\t\ttv->v_type = VAR_BOOL;\n\t\t\ttv->vval.v_number = iptr->isn_arg.number;\n\t\t\tbreak;\n\t\t    case ISN_PUSHSPEC:\n\t\t\ttv->v_type = VAR_SPECIAL;\n\t\t\ttv->vval.v_number = iptr->isn_arg.number;\n\t\t\tbreak;\n#ifdef FEAT_FLOAT\n\t\t    case ISN_PUSHF:\n\t\t\ttv->v_type = VAR_FLOAT;\n\t\t\ttv->vval.v_float = iptr->isn_arg.fnumber;\n\t\t\tbreak;\n#endif\n\t\t    case ISN_PUSHBLOB:\n\t\t\tblob_copy(iptr->isn_arg.blob, tv);\n\t\t\tbreak;\n\t\t    case ISN_PUSHFUNC:\n\t\t\ttv->v_type = VAR_FUNC;\n\t\t\tif (iptr->isn_arg.string == NULL)\n\t\t\t    tv->vval.v_string = NULL;\n\t\t\telse\n\t\t\t    tv->vval.v_string =\n\t\t\t\t\t     vim_strsave(iptr->isn_arg.string);\n\t\t\tbreak;\n\t\t    case ISN_PUSHCHANNEL:\n#ifdef FEAT_JOB_CHANNEL\n\t\t\ttv->v_type = VAR_CHANNEL;\n\t\t\ttv->vval.v_channel = iptr->isn_arg.channel;\n\t\t\tif (tv->vval.v_channel != NULL)\n\t\t\t    ++tv->vval.v_channel->ch_refcount;\n#endif\n\t\t\tbreak;\n\t\t    case ISN_PUSHJOB:\n#ifdef FEAT_JOB_CHANNEL\n\t\t\ttv->v_type = VAR_JOB;\n\t\t\ttv->vval.v_job = iptr->isn_arg.job;\n\t\t\tif (tv->vval.v_job != NULL)\n\t\t\t    ++tv->vval.v_job->jv_refcount;\n#endif\n\t\t\tbreak;\n\t\t    default:\n\t\t\ttv->v_type = VAR_STRING;\n\t\t\ttv->vval.v_string = vim_strsave(\n\t\t\t\tiptr->isn_arg.string == NULL\n\t\t\t\t\t? (char_u *)\"\" : iptr->isn_arg.string);\n\t\t}\n\t\tbreak;\n\n\t    case ISN_UNLET:\n\t\tif (do_unlet(iptr->isn_arg.unlet.ul_name,\n\t\t\t\t       iptr->isn_arg.unlet.ul_forceit) == FAIL)\n\t\t    goto on_error;\n\t\tbreak;\n\t    case ISN_UNLETENV:\n\t\tvim_unsetenv(iptr->isn_arg.unlet.ul_name);\n\t\tbreak;\n\n\t    case ISN_LOCKUNLOCK:\n\t\t{\n\t\t    typval_T\t*lval_root_save = lval_root;\n\t\t    int\t\tres;\n\n\t\t    // Stack has the local variable, argument the whole :lock\n\t\t    // or :unlock command, like ISN_EXEC.\n\t\t    --ectx->ec_stack.ga_len;\n\t\t    lval_root = STACK_TV_BOT(0);\n\t\t    res = exec_command(iptr);\n\t\t    clear_tv(lval_root);\n\t\t    lval_root = lval_root_save;\n\t\t    if (res == FAIL)\n\t\t\tgoto on_error;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_LOCKCONST:\n\t\titem_lock(STACK_TV_BOT(-1), 100, TRUE, TRUE);\n\t\tbreak;\n\n\t    // create a list from items on the stack; uses a single allocation\n\t    // for the list header and the items\n\t    case ISN_NEWLIST:\n\t\tif (exe_newlist(iptr->isn_arg.number, ectx) == FAIL)\n\t\t    goto theend;\n\t\tbreak;\n\n\t    // create a dict from items on the stack\n\t    case ISN_NEWDICT:\n\t\t{\n\t\t    int\t\tcount = iptr->isn_arg.number;\n\t\t    dict_T\t*dict = dict_alloc();\n\t\t    dictitem_T\t*item;\n\t\t    char_u\t*key;\n\t\t    int\t\tidx;\n\n\t\t    if (unlikely(dict == NULL))\n\t\t\tgoto theend;\n\t\t    for (idx = 0; idx < count; ++idx)\n\t\t    {\n\t\t\t// have already checked key type is VAR_STRING\n\t\t\ttv = STACK_TV_BOT(2 * (idx - count));\n\t\t\t// check key is unique\n\t\t\tkey = tv->vval.v_string == NULL\n\t\t\t\t\t    ? (char_u *)\"\" : tv->vval.v_string;\n\t\t\titem = dict_find(dict, key, -1);\n\t\t\tif (item != NULL)\n\t\t\t{\n\t\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t\t    semsg(_(e_duplicate_key), key);\n\t\t\t    dict_unref(dict);\n\t\t\t    goto on_error;\n\t\t\t}\n\t\t\titem = dictitem_alloc(key);\n\t\t\tclear_tv(tv);\n\t\t\tif (unlikely(item == NULL))\n\t\t\t{\n\t\t\t    dict_unref(dict);\n\t\t\t    goto theend;\n\t\t\t}\n\t\t\titem->di_tv = *STACK_TV_BOT(2 * (idx - count) + 1);\n\t\t\titem->di_tv.v_lock = 0;\n\t\t\tif (dict_add(dict, item) == FAIL)\n\t\t\t{\n\t\t\t    // can this ever happen?\n\t\t\t    dict_unref(dict);\n\t\t\t    goto theend;\n\t\t\t}\n\t\t    }\n\n\t\t    if (count > 0)\n\t\t\tectx->ec_stack.ga_len -= 2 * count - 1;\n\t\t    else if (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t\tgoto theend;\n\t\t    else\n\t\t\t++ectx->ec_stack.ga_len;\n\t\t    tv = STACK_TV_BOT(-1);\n\t\t    tv->v_type = VAR_DICT;\n\t\t    tv->v_lock = 0;\n\t\t    tv->vval.v_dict = dict;\n\t\t    ++dict->dv_refcount;\n\t\t}\n\t\tbreak;\n\n\t    // call a :def function\n\t    case ISN_DCALL:\n\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\tif (call_dfunc(iptr->isn_arg.dfunc.cdf_idx,\n\t\t\t\tNULL,\n\t\t\t\tiptr->isn_arg.dfunc.cdf_argcount,\n\t\t\t\tectx) == FAIL)\n\t\t    goto on_error;\n\t\tbreak;\n\n\t    // call a builtin function\n\t    case ISN_BCALL:\n\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\tif (call_bfunc(iptr->isn_arg.bfunc.cbf_idx,\n\t\t\t      iptr->isn_arg.bfunc.cbf_argcount,\n\t\t\t      ectx) == FAIL)\n\t\t    goto on_error;\n\t\tbreak;\n\n\t    // call a funcref or partial\n\t    case ISN_PCALL:\n\t\t{\n\t\t    cpfunc_T\t*pfunc = &iptr->isn_arg.pfunc;\n\t\t    int\t\tr;\n\t\t    typval_T\tpartial_tv;\n\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    if (pfunc->cpf_top)\n\t\t    {\n\t\t\t// funcref is above the arguments\n\t\t\ttv = STACK_TV_BOT(-pfunc->cpf_argcount - 1);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// Get the funcref from the stack.\n\t\t\t--ectx->ec_stack.ga_len;\n\t\t\tpartial_tv = *STACK_TV_BOT(0);\n\t\t\ttv = &partial_tv;\n\t\t    }\n\t\t    r = call_partial(tv, pfunc->cpf_argcount, ectx);\n\t\t    if (tv == &partial_tv)\n\t\t\tclear_tv(&partial_tv);\n\t\t    if (r == FAIL)\n\t\t\tgoto on_error;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_PCALL_END:\n\t\t// PCALL finished, arguments have been consumed and replaced by\n\t\t// the return value.  Now clear the funcref from the stack,\n\t\t// and move the return value in its place.\n\t\t--ectx->ec_stack.ga_len;\n\t\tclear_tv(STACK_TV_BOT(-1));\n\t\t*STACK_TV_BOT(-1) = *STACK_TV_BOT(0);\n\t\tbreak;\n\n\t    // call a user defined function or funcref/partial\n\t    case ISN_UCALL:\n\t\t{\n\t\t    cufunc_T\t*cufunc = &iptr->isn_arg.ufunc;\n\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    if (call_eval_func(cufunc->cuf_name, cufunc->cuf_argcount,\n\t\t\t\t\t\t\t   ectx, iptr) == FAIL)\n\t\t\tgoto on_error;\n\t\t}\n\t\tbreak;\n\n\t    // return from a :def function call without a value\n\t    case ISN_RETURN_VOID:\n\t\tif (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t    goto theend;\n\t\ttv = STACK_TV_BOT(0);\n\t\t++ectx->ec_stack.ga_len;\n\t\ttv->v_type = VAR_VOID;\n\t\ttv->vval.v_number = 0;\n\t\ttv->v_lock = 0;\n\t\t// FALLTHROUGH\n\n\t    // return from a :def function call with what is on the stack\n\t    case ISN_RETURN:\n\t\t{\n\t\t    garray_T\t*trystack = &ectx->ec_trystack;\n\t\t    trycmd_T    *trycmd = NULL;\n\n\t\t    if (trystack->ga_len > 0)\n\t\t\ttrycmd = ((trycmd_T *)trystack->ga_data)\n\t\t\t\t\t\t\t+ trystack->ga_len - 1;\n\t\t    if (trycmd != NULL\n\t\t\t\t && trycmd->tcd_frame_idx == ectx->ec_frame_idx)\n\t\t    {\n\t\t\t// jump to \":finally\" or \":endtry\"\n\t\t\tif (trycmd->tcd_finally_idx != 0)\n\t\t\t    ectx->ec_iidx = trycmd->tcd_finally_idx;\n\t\t\telse\n\t\t\t    ectx->ec_iidx = trycmd->tcd_endtry_idx;\n\t\t\ttrycmd->tcd_return = TRUE;\n\t\t    }\n\t\t    else\n\t\t\tgoto func_return;\n\t\t}\n\t\tbreak;\n\n\t    // push a partial, a reference to a compiled function\n\t    case ISN_FUNCREF:\n\t\t{\n\t\t    partial_T   *pt = ALLOC_CLEAR_ONE(partial_T);\n\t\t    ufunc_T\t*ufunc;\n\t\t    funcref_T\t*funcref = &iptr->isn_arg.funcref;\n\n\t\t    if (pt == NULL)\n\t\t\tgoto theend;\n\t\t    if (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t    {\n\t\t\tvim_free(pt);\n\t\t\tgoto theend;\n\t\t    }\n\t\t    if (funcref->fr_func_name == NULL)\n\t\t    {\n\t\t\tdfunc_T\t*pt_dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t       + funcref->fr_dfunc_idx;\n\n\t\t\tufunc = pt_dfunc->df_ufunc;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tufunc = find_func(funcref->fr_func_name, FALSE, NULL);\n\t\t    }\n\t\t    if (ufunc == NULL)\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\temsg(_(e_function_reference_invalid));\n\t\t\tgoto theend;\n\t\t    }\n\t\t    if (fill_partial_and_closure(pt, ufunc, ectx) == FAIL)\n\t\t\tgoto theend;\n\t\t    tv = STACK_TV_BOT(0);\n\t\t    ++ectx->ec_stack.ga_len;\n\t\t    tv->vval.v_partial = pt;\n\t\t    tv->v_type = VAR_PARTIAL;\n\t\t    tv->v_lock = 0;\n\t\t}\n\t\tbreak;\n\n\t    // Create a global function from a lambda.\n\t    case ISN_NEWFUNC:\n\t\t{\n\t\t    newfunc_T\t*newfunc = &iptr->isn_arg.newfunc;\n\n\t\t    if (copy_func(newfunc->nf_lambda, newfunc->nf_global,\n\t\t\t\t\t\t\t\t ectx) == FAIL)\n\t\t\tgoto theend;\n\t\t}\n\t\tbreak;\n\n\t    // List functions\n\t    case ISN_DEF:\n\t\tif (iptr->isn_arg.string == NULL)\n\t\t    list_functions(NULL);\n\t\telse\n\t\t{\n\t\t    exarg_T ea;\n\t\t    char_u  *line_to_free = NULL;\n\n\t\t    CLEAR_FIELD(ea);\n\t\t    ea.cmd = ea.arg = iptr->isn_arg.string;\n\t\t    define_function(&ea, NULL, &line_to_free);\n\t\t    vim_free(line_to_free);\n\t\t}\n\t\tbreak;\n\n\t    // jump if a condition is met\n\t    case ISN_JUMP:\n\t\t{\n\t\t    jumpwhen_T\twhen = iptr->isn_arg.jump.jump_when;\n\t\t    int\t\terror = FALSE;\n\t\t    int\t\tjump = TRUE;\n\n\t\t    if (when != JUMP_ALWAYS)\n\t\t    {\n\t\t\ttv = STACK_TV_BOT(-1);\n\t\t\tif (when == JUMP_IF_COND_FALSE\n\t\t\t\t|| when == JUMP_IF_FALSE\n\t\t\t\t|| when == JUMP_IF_COND_TRUE)\n\t\t\t{\n\t\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t\t    jump = tv_get_bool_chk(tv, &error);\n\t\t\t    if (error)\n\t\t\t\tgoto on_error;\n\t\t\t}\n\t\t\telse\n\t\t\t    jump = tv2bool(tv);\n\t\t\tif (when == JUMP_IF_FALSE\n\t\t\t\t\t     || when == JUMP_AND_KEEP_IF_FALSE\n\t\t\t\t\t     || when == JUMP_IF_COND_FALSE)\n\t\t\t    jump = !jump;\n\t\t\tif (when == JUMP_IF_FALSE || !jump)\n\t\t\t{\n\t\t\t    // drop the value from the stack\n\t\t\t    clear_tv(tv);\n\t\t\t    --ectx->ec_stack.ga_len;\n\t\t\t}\n\t\t    }\n\t\t    if (jump)\n\t\t\tectx->ec_iidx = iptr->isn_arg.jump.jump_where;\n\t\t}\n\t\tbreak;\n\n\t    // Jump if an argument with a default value was already set and not\n\t    // v:none.\n\t    case ISN_JUMP_IF_ARG_SET:\n\t\ttv = STACK_TV_VAR(iptr->isn_arg.jumparg.jump_arg_off);\n\t\tif (tv->v_type != VAR_UNKNOWN\n\t\t\t&& !(tv->v_type == VAR_SPECIAL\n\t\t\t\t\t    && tv->vval.v_number == VVAL_NONE))\n\t\t    ectx->ec_iidx = iptr->isn_arg.jumparg.jump_where;\n\t\tbreak;\n\n\t    // top of a for loop\n\t    case ISN_FOR:\n\t\t{\n\t\t    typval_T\t*ltv = STACK_TV_BOT(-1);\n\t\t    typval_T\t*idxtv =\n\t\t\t\t   STACK_TV_VAR(iptr->isn_arg.forloop.for_idx);\n\n\t\t    if (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t\tgoto theend;\n\t\t    if (ltv->v_type == VAR_LIST)\n\t\t    {\n\t\t\tlist_T *list = ltv->vval.v_list;\n\n\t\t\t// push the next item from the list\n\t\t\t++idxtv->vval.v_number;\n\t\t\tif (list == NULL\n\t\t\t\t       || idxtv->vval.v_number >= list->lv_len)\n\t\t\t{\n\t\t\t    // past the end of the list, jump to \"endfor\"\n\t\t\t    ectx->ec_iidx = iptr->isn_arg.forloop.for_end;\n\t\t\t    may_restore_cmdmod(&ectx->ec_funclocal);\n\t\t\t}\n\t\t\telse if (list->lv_first == &range_list_item)\n\t\t\t{\n\t\t\t    // non-materialized range() list\n\t\t\t    tv = STACK_TV_BOT(0);\n\t\t\t    tv->v_type = VAR_NUMBER;\n\t\t\t    tv->v_lock = 0;\n\t\t\t    tv->vval.v_number = list_find_nr(\n\t\t\t\t\t     list, idxtv->vval.v_number, NULL);\n\t\t\t    ++ectx->ec_stack.ga_len;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    listitem_T *li = list_find(list,\n\t\t\t\t\t\t\t idxtv->vval.v_number);\n\n\t\t\t    copy_tv(&li->li_tv, STACK_TV_BOT(0));\n\t\t\t    ++ectx->ec_stack.ga_len;\n\t\t\t}\n\t\t    }\n\t\t    else if (ltv->v_type == VAR_STRING)\n\t\t    {\n\t\t\tchar_u\t*str = ltv->vval.v_string;\n\n\t\t\t// The index is for the last byte of the previous\n\t\t\t// character.\n\t\t\t++idxtv->vval.v_number;\n\t\t\tif (str == NULL || str[idxtv->vval.v_number] == NUL)\n\t\t\t{\n\t\t\t    // past the end of the string, jump to \"endfor\"\n\t\t\t    ectx->ec_iidx = iptr->isn_arg.forloop.for_end;\n\t\t\t    may_restore_cmdmod(&ectx->ec_funclocal);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    int\tclen = mb_ptr2len(str + idxtv->vval.v_number);\n\n\t\t\t    // Push the next character from the string.\n\t\t\t    tv = STACK_TV_BOT(0);\n\t\t\t    tv->v_type = VAR_STRING;\n\t\t\t    tv->vval.v_string = vim_strnsave(\n\t\t\t\t\t     str + idxtv->vval.v_number, clen);\n\t\t\t    ++ectx->ec_stack.ga_len;\n\t\t\t    idxtv->vval.v_number += clen - 1;\n\t\t\t}\n\t\t    }\n\t\t    else if (ltv->v_type == VAR_BLOB)\n\t\t    {\n\t\t\tblob_T\t*blob = ltv->vval.v_blob;\n\n\t\t\t// When we get here the first time make a copy of the\n\t\t\t// blob, so that the iteration still works when it is\n\t\t\t// changed.\n\t\t\tif (idxtv->vval.v_number == -1 && blob != NULL)\n\t\t\t{\n\t\t\t    blob_copy(blob, ltv);\n\t\t\t    blob_unref(blob);\n\t\t\t    blob = ltv->vval.v_blob;\n\t\t\t}\n\n\t\t\t// The index is for the previous byte.\n\t\t\t++idxtv->vval.v_number;\n\t\t\tif (blob == NULL\n\t\t\t\t     || idxtv->vval.v_number >= blob_len(blob))\n\t\t\t{\n\t\t\t    // past the end of the blob, jump to \"endfor\"\n\t\t\t    ectx->ec_iidx = iptr->isn_arg.forloop.for_end;\n\t\t\t    may_restore_cmdmod(&ectx->ec_funclocal);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // Push the next byte from the blob.\n\t\t\t    tv = STACK_TV_BOT(0);\n\t\t\t    tv->v_type = VAR_NUMBER;\n\t\t\t    tv->vval.v_number = blob_get(blob,\n\t\t\t\t\t\t\t idxtv->vval.v_number);\n\t\t\t    ++ectx->ec_stack.ga_len;\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tsemsg(_(e_for_loop_on_str_not_supported),\n\t\t\t\t\t\t    vartype_name(ltv->v_type));\n\t\t\tgoto theend;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    // start of \":try\" block\n\t    case ISN_TRY:\n\t\t{\n\t\t    trycmd_T    *trycmd = NULL;\n\n\t\t    if (GA_GROW_FAILS(&ectx->ec_trystack, 1))\n\t\t\tgoto theend;\n\t\t    trycmd = ((trycmd_T *)ectx->ec_trystack.ga_data)\n\t\t\t\t\t\t     + ectx->ec_trystack.ga_len;\n\t\t    ++ectx->ec_trystack.ga_len;\n\t\t    ++trylevel;\n\t\t    CLEAR_POINTER(trycmd);\n\t\t    trycmd->tcd_frame_idx = ectx->ec_frame_idx;\n\t\t    trycmd->tcd_stack_len = ectx->ec_stack.ga_len;\n\t\t    trycmd->tcd_catch_idx =\n\t\t\t\t       iptr->isn_arg.tryref.try_ref->try_catch;\n\t\t    trycmd->tcd_finally_idx =\n\t\t\t\t     iptr->isn_arg.tryref.try_ref->try_finally;\n\t\t    trycmd->tcd_endtry_idx =\n\t\t\t\t      iptr->isn_arg.tryref.try_ref->try_endtry;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_PUSHEXC:\n\t\tif (current_exception == NULL)\n\t\t{\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    iemsg(\"Evaluating catch while current_exception is NULL\");\n\t\t    goto theend;\n\t\t}\n\t\tif (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t    goto theend;\n\t\ttv = STACK_TV_BOT(0);\n\t\t++ectx->ec_stack.ga_len;\n\t\ttv->v_type = VAR_STRING;\n\t\ttv->v_lock = 0;\n\t\ttv->vval.v_string = vim_strsave(\n\t\t\t\t\t   (char_u *)current_exception->value);\n\t\tbreak;\n\n\t    case ISN_CATCH:\n\t\t{\n\t\t    garray_T\t*trystack = &ectx->ec_trystack;\n\n\t\t    may_restore_cmdmod(&ectx->ec_funclocal);\n\t\t    if (trystack->ga_len > 0)\n\t\t    {\n\t\t\ttrycmd_T    *trycmd = ((trycmd_T *)trystack->ga_data)\n\t\t\t\t\t\t\t+ trystack->ga_len - 1;\n\t\t\ttrycmd->tcd_caught = TRUE;\n\t\t\ttrycmd->tcd_did_throw = FALSE;\n\t\t    }\n\t\t    did_emsg = got_int = did_throw = FALSE;\n\t\t    force_abort = need_rethrow = FALSE;\n\t\t    catch_exception(current_exception);\n\t\t}\n\t\tbreak;\n\n\t    case ISN_TRYCONT:\n\t\t{\n\t\t    garray_T\t*trystack = &ectx->ec_trystack;\n\t\t    trycont_T\t*trycont = &iptr->isn_arg.trycont;\n\t\t    int\t\ti;\n\t\t    trycmd_T    *trycmd;\n\t\t    int\t\tiidx = trycont->tct_where;\n\n\t\t    if (trystack->ga_len < trycont->tct_levels)\n\t\t    {\n\t\t\tsiemsg(\"TRYCONT: expected %d levels, found %d\",\n\t\t\t\t\ttrycont->tct_levels, trystack->ga_len);\n\t\t\tgoto theend;\n\t\t    }\n\t\t    // Make :endtry jump to any outer try block and the last\n\t\t    // :endtry inside the loop to the loop start.\n\t\t    for (i = trycont->tct_levels; i > 0; --i)\n\t\t    {\n\t\t\ttrycmd = ((trycmd_T *)trystack->ga_data)\n\t\t\t\t\t\t\t+ trystack->ga_len - i;\n\t\t\t// Add one to tcd_cont to be able to jump to\n\t\t\t// instruction with index zero.\n\t\t\ttrycmd->tcd_cont = iidx + 1;\n\t\t\tiidx = trycmd->tcd_finally_idx == 0\n\t\t\t    ? trycmd->tcd_endtry_idx : trycmd->tcd_finally_idx;\n\t\t    }\n\t\t    // jump to :finally or :endtry of current try statement\n\t\t    ectx->ec_iidx = iidx;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_FINALLY:\n\t\t{\n\t\t    garray_T\t*trystack = &ectx->ec_trystack;\n\t\t    trycmd_T    *trycmd = ((trycmd_T *)trystack->ga_data)\n\t\t\t\t\t\t\t+ trystack->ga_len - 1;\n\n\t\t    // Reset the index to avoid a return statement jumps here\n\t\t    // again.\n\t\t    trycmd->tcd_finally_idx = 0;\n\t\t    break;\n\t\t}\n\n\t    // end of \":try\" block\n\t    case ISN_ENDTRY:\n\t\t{\n\t\t    garray_T\t*trystack = &ectx->ec_trystack;\n\n\t\t    if (trystack->ga_len > 0)\n\t\t    {\n\t\t\ttrycmd_T    *trycmd;\n\n\t\t\t--trystack->ga_len;\n\t\t\t--trylevel;\n\t\t\ttrycmd = ((trycmd_T *)trystack->ga_data)\n\t\t\t\t\t\t\t    + trystack->ga_len;\n\t\t\tif (trycmd->tcd_did_throw)\n\t\t\t    did_throw = TRUE;\n\t\t\tif (trycmd->tcd_caught && current_exception != NULL)\n\t\t\t{\n\t\t\t    // discard the exception\n\t\t\t    if (caught_stack == current_exception)\n\t\t\t\tcaught_stack = caught_stack->caught;\n\t\t\t    discard_current_exception();\n\t\t\t}\n\n\t\t\tif (trycmd->tcd_return)\n\t\t\t    goto func_return;\n\n\t\t\twhile (ectx->ec_stack.ga_len > trycmd->tcd_stack_len)\n\t\t\t{\n\t\t\t    --ectx->ec_stack.ga_len;\n\t\t\t    clear_tv(STACK_TV_BOT(0));\n\t\t\t}\n\t\t\tif (trycmd->tcd_cont != 0)\n\t\t\t    // handling :continue: jump to outer try block or\n\t\t\t    // start of the loop\n\t\t\t    ectx->ec_iidx = trycmd->tcd_cont - 1;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    case ISN_THROW:\n\t\t{\n\t\t    garray_T\t*trystack = &ectx->ec_trystack;\n\n\t\t    if (trystack->ga_len == 0 && trylevel == 0 && emsg_silent)\n\t\t    {\n\t\t\t// throwing an exception while using \"silent!\" causes\n\t\t\t// the function to abort but not display an error.\n\t\t\ttv = STACK_TV_BOT(-1);\n\t\t\tclear_tv(tv);\n\t\t\ttv->v_type = VAR_NUMBER;\n\t\t\ttv->vval.v_number = 0;\n\t\t\tgoto done;\n\t\t    }\n\t\t    --ectx->ec_stack.ga_len;\n\t\t    tv = STACK_TV_BOT(0);\n\t\t    if (tv->vval.v_string == NULL\n\t\t\t\t       || *skipwhite(tv->vval.v_string) == NUL)\n\t\t    {\n\t\t\tvim_free(tv->vval.v_string);\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\temsg(_(e_throw_with_empty_string));\n\t\t\tgoto theend;\n\t\t    }\n\n\t\t    // Inside a \"catch\" we need to first discard the caught\n\t\t    // exception.\n\t\t    if (trystack->ga_len > 0)\n\t\t    {\n\t\t\ttrycmd_T    *trycmd = ((trycmd_T *)trystack->ga_data)\n\t\t\t\t\t\t\t+ trystack->ga_len - 1;\n\t\t\tif (trycmd->tcd_caught && current_exception != NULL)\n\t\t\t{\n\t\t\t    // discard the exception\n\t\t\t    if (caught_stack == current_exception)\n\t\t\t\tcaught_stack = caught_stack->caught;\n\t\t\t    discard_current_exception();\n\t\t\t    trycmd->tcd_caught = FALSE;\n\t\t\t}\n\t\t    }\n\n\t\t    if (throw_exception(tv->vval.v_string, ET_USER, NULL)\n\t\t\t\t\t\t\t\t       == FAIL)\n\t\t    {\n\t\t\tvim_free(tv->vval.v_string);\n\t\t\tgoto theend;\n\t\t    }\n\t\t    did_throw = TRUE;\n\t\t}\n\t\tbreak;\n\n\t    // compare with special values\n\t    case ISN_COMPAREBOOL:\n\t    case ISN_COMPARESPECIAL:\n\t\t{\n\t\t    typval_T\t*tv1 = STACK_TV_BOT(-2);\n\t\t    typval_T\t*tv2 = STACK_TV_BOT(-1);\n\t\t    varnumber_T arg1 = tv1->vval.v_number;\n\t\t    varnumber_T arg2 = tv2->vval.v_number;\n\t\t    int\t\tres;\n\n\t\t    switch (iptr->isn_arg.op.op_type)\n\t\t    {\n\t\t\tcase EXPR_EQUAL: res = arg1 == arg2; break;\n\t\t\tcase EXPR_NEQUAL: res = arg1 != arg2; break;\n\t\t\tdefault: res = 0; break;\n\t\t    }\n\n\t\t    --ectx->ec_stack.ga_len;\n\t\t    tv1->v_type = VAR_BOOL;\n\t\t    tv1->vval.v_number = res ? VVAL_TRUE : VVAL_FALSE;\n\t\t}\n\t\tbreak;\n\n\t    // Operation with two number arguments\n\t    case ISN_OPNR:\n\t    case ISN_COMPARENR:\n\t\t{\n\t\t    typval_T\t*tv1 = STACK_TV_BOT(-2);\n\t\t    typval_T\t*tv2 = STACK_TV_BOT(-1);\n\t\t    varnumber_T arg1 = tv1->vval.v_number;\n\t\t    varnumber_T arg2 = tv2->vval.v_number;\n\t\t    varnumber_T res = 0;\n\t\t    int\t\tdiv_zero = FALSE;\n\n\t\t    switch (iptr->isn_arg.op.op_type)\n\t\t    {\n\t\t\tcase EXPR_MULT: res = arg1 * arg2; break;\n\t\t\tcase EXPR_DIV:  if (arg2 == 0)\n\t\t\t\t\t    div_zero = TRUE;\n\t\t\t\t\telse\n\t\t\t\t\t    res = arg1 / arg2;\n\t\t\t\t\tbreak;\n\t\t\tcase EXPR_REM:  if (arg2 == 0)\n\t\t\t\t\t    div_zero = TRUE;\n\t\t\t\t\telse\n\t\t\t\t\t    res = arg1 % arg2;\n\t\t\t\t\tbreak;\n\t\t\tcase EXPR_SUB: res = arg1 - arg2; break;\n\t\t\tcase EXPR_ADD: res = arg1 + arg2; break;\n\n\t\t\tcase EXPR_EQUAL: res = arg1 == arg2; break;\n\t\t\tcase EXPR_NEQUAL: res = arg1 != arg2; break;\n\t\t\tcase EXPR_GREATER: res = arg1 > arg2; break;\n\t\t\tcase EXPR_GEQUAL: res = arg1 >= arg2; break;\n\t\t\tcase EXPR_SMALLER: res = arg1 < arg2; break;\n\t\t\tcase EXPR_SEQUAL: res = arg1 <= arg2; break;\n\t\t\tdefault: break;\n\t\t    }\n\n\t\t    --ectx->ec_stack.ga_len;\n\t\t    if (iptr->isn_type == ISN_COMPARENR)\n\t\t    {\n\t\t\ttv1->v_type = VAR_BOOL;\n\t\t\ttv1->vval.v_number = res ? VVAL_TRUE : VVAL_FALSE;\n\t\t    }\n\t\t    else\n\t\t\ttv1->vval.v_number = res;\n\t\t    if (div_zero)\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\temsg(_(e_divide_by_zero));\n\t\t\tgoto on_error;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    // Computation with two float arguments\n\t    case ISN_OPFLOAT:\n\t    case ISN_COMPAREFLOAT:\n#ifdef FEAT_FLOAT\n\t\t{\n\t\t    typval_T\t*tv1 = STACK_TV_BOT(-2);\n\t\t    typval_T\t*tv2 = STACK_TV_BOT(-1);\n\t\t    float_T\targ1 = tv1->vval.v_float;\n\t\t    float_T\targ2 = tv2->vval.v_float;\n\t\t    float_T\tres = 0;\n\t\t    int\t\tcmp = FALSE;\n\n\t\t    switch (iptr->isn_arg.op.op_type)\n\t\t    {\n\t\t\tcase EXPR_MULT: res = arg1 * arg2; break;\n\t\t\tcase EXPR_DIV: res = arg1 / arg2; break;\n\t\t\tcase EXPR_SUB: res = arg1 - arg2; break;\n\t\t\tcase EXPR_ADD: res = arg1 + arg2; break;\n\n\t\t\tcase EXPR_EQUAL: cmp = arg1 == arg2; break;\n\t\t\tcase EXPR_NEQUAL: cmp = arg1 != arg2; break;\n\t\t\tcase EXPR_GREATER: cmp = arg1 > arg2; break;\n\t\t\tcase EXPR_GEQUAL: cmp = arg1 >= arg2; break;\n\t\t\tcase EXPR_SMALLER: cmp = arg1 < arg2; break;\n\t\t\tcase EXPR_SEQUAL: cmp = arg1 <= arg2; break;\n\t\t\tdefault: cmp = 0; break;\n\t\t    }\n\t\t    --ectx->ec_stack.ga_len;\n\t\t    if (iptr->isn_type == ISN_COMPAREFLOAT)\n\t\t    {\n\t\t\ttv1->v_type = VAR_BOOL;\n\t\t\ttv1->vval.v_number = cmp ? VVAL_TRUE : VVAL_FALSE;\n\t\t    }\n\t\t    else\n\t\t\ttv1->vval.v_float = res;\n\t\t}\n#endif\n\t\tbreak;\n\n\t    case ISN_COMPARELIST:\n\t    case ISN_COMPAREDICT:\n\t    case ISN_COMPAREFUNC:\n\t    case ISN_COMPARESTRING:\n\t    case ISN_COMPAREBLOB:\n\t\t{\n\t\t    typval_T\t*tv1 = STACK_TV_BOT(-2);\n\t\t    typval_T\t*tv2 = STACK_TV_BOT(-1);\n\t\t    exprtype_T\texprtype = iptr->isn_arg.op.op_type;\n\t\t    int\t\tic = iptr->isn_arg.op.op_ic;\n\t\t    int\t\tres = FALSE;\n\t\t    int\t\tstatus = OK;\n\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    if (iptr->isn_type == ISN_COMPARELIST)\n\t\t    {\n\t\t\tstatus = typval_compare_list(tv1, tv2,\n\t\t\t\t\t\t\t   exprtype, ic, &res);\n\t\t    }\n\t\t    else if (iptr->isn_type == ISN_COMPAREDICT)\n\t\t    {\n\t\t\tstatus = typval_compare_dict(tv1, tv2,\n\t\t\t\t\t\t\t   exprtype, ic, &res);\n\t\t    }\n\t\t    else if (iptr->isn_type == ISN_COMPAREFUNC)\n\t\t    {\n\t\t\tstatus = typval_compare_func(tv1, tv2,\n\t\t\t\t\t\t\t   exprtype, ic, &res);\n\t\t    }\n\t\t    else if (iptr->isn_type == ISN_COMPARESTRING)\n\t\t    {\n\t\t\tstatus = typval_compare_string(tv1, tv2,\n\t\t\t\t\t\t\t   exprtype, ic, &res);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tstatus = typval_compare_blob(tv1, tv2, exprtype, &res);\n\t\t    }\n\t\t    --ectx->ec_stack.ga_len;\n\t\t    clear_tv(tv1);\n\t\t    clear_tv(tv2);\n\t\t    tv1->v_type = VAR_BOOL;\n\t\t    tv1->vval.v_number = res ? VVAL_TRUE : VVAL_FALSE;\n\t\t    if (status == FAIL)\n\t\t\tgoto theend;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_COMPAREANY:\n\t\t{\n\t\t    typval_T\t*tv1 = STACK_TV_BOT(-2);\n\t\t    typval_T\t*tv2 = STACK_TV_BOT(-1);\n\t\t    exprtype_T\texprtype = iptr->isn_arg.op.op_type;\n\t\t    int\t\tic = iptr->isn_arg.op.op_ic;\n\t\t    int\t\tstatus;\n\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    status = typval_compare(tv1, tv2, exprtype, ic);\n\t\t    clear_tv(tv2);\n\t\t    --ectx->ec_stack.ga_len;\n\t\t    if (status == FAIL)\n\t\t\tgoto theend;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_ADDLIST:\n\t    case ISN_ADDBLOB:\n\t\t{\n\t\t    typval_T *tv1 = STACK_TV_BOT(-2);\n\t\t    typval_T *tv2 = STACK_TV_BOT(-1);\n\n\t\t    // add two lists or blobs\n\t\t    if (iptr->isn_type == ISN_ADDLIST)\n\t\t    {\n\t\t\tif (iptr->isn_arg.op.op_type == EXPR_APPEND\n\t\t\t\t\t\t   && tv1->vval.v_list != NULL)\n\t\t\t    list_extend(tv1->vval.v_list, tv2->vval.v_list,\n\t\t\t\t\t\t\t\t\t NULL);\n\t\t\telse\n\t\t\t    eval_addlist(tv1, tv2);\n\t\t    }\n\t\t    else\n\t\t\teval_addblob(tv1, tv2);\n\t\t    clear_tv(tv2);\n\t\t    --ectx->ec_stack.ga_len;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_LISTAPPEND:\n\t\t{\n\t\t    typval_T\t*tv1 = STACK_TV_BOT(-2);\n\t\t    typval_T\t*tv2 = STACK_TV_BOT(-1);\n\t\t    list_T\t*l = tv1->vval.v_list;\n\n\t\t    // add an item to a list\n\t\t    if (l == NULL)\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\temsg(_(e_cannot_add_to_null_list));\n\t\t\tgoto on_error;\n\t\t    }\n\t\t    if (list_append_tv(l, tv2) == FAIL)\n\t\t\tgoto theend;\n\t\t    clear_tv(tv2);\n\t\t    --ectx->ec_stack.ga_len;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_BLOBAPPEND:\n\t\t{\n\t\t    typval_T\t*tv1 = STACK_TV_BOT(-2);\n\t\t    typval_T\t*tv2 = STACK_TV_BOT(-1);\n\t\t    blob_T\t*b = tv1->vval.v_blob;\n\t\t    int\t\terror = FALSE;\n\t\t    varnumber_T n;\n\n\t\t    // add a number to a blob\n\t\t    if (b == NULL)\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\temsg(_(e_cannot_add_to_null_blob));\n\t\t\tgoto on_error;\n\t\t    }\n\t\t    n = tv_get_number_chk(tv2, &error);\n\t\t    if (error)\n\t\t\tgoto on_error;\n\t\t    ga_append(&b->bv_ga, (int)n);\n\t\t    --ectx->ec_stack.ga_len;\n\t\t}\n\t\tbreak;\n\n\t    // Computation with two arguments of unknown type\n\t    case ISN_OPANY:\n\t\t{\n\t\t    typval_T\t*tv1 = STACK_TV_BOT(-2);\n\t\t    typval_T\t*tv2 = STACK_TV_BOT(-1);\n\t\t    varnumber_T\tn1, n2;\n#ifdef FEAT_FLOAT\n\t\t    float_T\tf1 = 0, f2 = 0;\n#endif\n\t\t    int\t\terror = FALSE;\n\n\t\t    if (iptr->isn_arg.op.op_type == EXPR_ADD)\n\t\t    {\n\t\t\tif (tv1->v_type == VAR_LIST && tv2->v_type == VAR_LIST)\n\t\t\t{\n\t\t\t    eval_addlist(tv1, tv2);\n\t\t\t    clear_tv(tv2);\n\t\t\t    --ectx->ec_stack.ga_len;\n\t\t\t    break;\n\t\t\t}\n\t\t\telse if (tv1->v_type == VAR_BLOB\n\t\t\t\t\t\t    && tv2->v_type == VAR_BLOB)\n\t\t\t{\n\t\t\t    eval_addblob(tv1, tv2);\n\t\t\t    clear_tv(tv2);\n\t\t\t    --ectx->ec_stack.ga_len;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n#ifdef FEAT_FLOAT\n\t\t    if (tv1->v_type == VAR_FLOAT)\n\t\t    {\n\t\t\tf1 = tv1->vval.v_float;\n\t\t\tn1 = 0;\n\t\t    }\n\t\t    else\n#endif\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\tn1 = tv_get_number_chk(tv1, &error);\n\t\t\tif (error)\n\t\t\t    goto on_error;\n#ifdef FEAT_FLOAT\n\t\t\tif (tv2->v_type == VAR_FLOAT)\n\t\t\t    f1 = n1;\n#endif\n\t\t    }\n#ifdef FEAT_FLOAT\n\t\t    if (tv2->v_type == VAR_FLOAT)\n\t\t    {\n\t\t\tf2 = tv2->vval.v_float;\n\t\t\tn2 = 0;\n\t\t    }\n\t\t    else\n#endif\n\t\t    {\n\t\t\tn2 = tv_get_number_chk(tv2, &error);\n\t\t\tif (error)\n\t\t\t    goto on_error;\n#ifdef FEAT_FLOAT\n\t\t\tif (tv1->v_type == VAR_FLOAT)\n\t\t\t    f2 = n2;\n#endif\n\t\t    }\n#ifdef FEAT_FLOAT\n\t\t    // if there is a float on either side the result is a float\n\t\t    if (tv1->v_type == VAR_FLOAT || tv2->v_type == VAR_FLOAT)\n\t\t    {\n\t\t\tswitch (iptr->isn_arg.op.op_type)\n\t\t\t{\n\t\t\t    case EXPR_MULT: f1 = f1 * f2; break;\n\t\t\t    case EXPR_DIV:  f1 = f1 / f2; break;\n\t\t\t    case EXPR_SUB:  f1 = f1 - f2; break;\n\t\t\t    case EXPR_ADD:  f1 = f1 + f2; break;\n\t\t\t    default: SOURCING_LNUM = iptr->isn_lnum;\n\t\t\t\t     emsg(_(e_modulus));\n\t\t\t\t     goto on_error;\n\t\t\t}\n\t\t\tclear_tv(tv1);\n\t\t\tclear_tv(tv2);\n\t\t\ttv1->v_type = VAR_FLOAT;\n\t\t\ttv1->vval.v_float = f1;\n\t\t\t--ectx->ec_stack.ga_len;\n\t\t    }\n\t\t    else\n#endif\n\t\t    {\n\t\t\tint failed = FALSE;\n\n\t\t\tswitch (iptr->isn_arg.op.op_type)\n\t\t\t{\n\t\t\t    case EXPR_MULT: n1 = n1 * n2; break;\n\t\t\t    case EXPR_DIV:  n1 = num_divide(n1, n2, &failed);\n\t\t\t\t\t    if (failed)\n\t\t\t\t\t\tgoto on_error;\n\t\t\t\t\t    break;\n\t\t\t    case EXPR_SUB:  n1 = n1 - n2; break;\n\t\t\t    case EXPR_ADD:  n1 = n1 + n2; break;\n\t\t\t    default:\t    n1 = num_modulus(n1, n2, &failed);\n\t\t\t\t\t    if (failed)\n\t\t\t\t\t\tgoto on_error;\n\t\t\t\t\t    break;\n\t\t\t}\n\t\t\tclear_tv(tv1);\n\t\t\tclear_tv(tv2);\n\t\t\ttv1->v_type = VAR_NUMBER;\n\t\t\ttv1->vval.v_number = n1;\n\t\t\t--ectx->ec_stack.ga_len;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    case ISN_CONCAT:\n\t\t{\n\t\t    char_u *str1 = STACK_TV_BOT(-2)->vval.v_string;\n\t\t    char_u *str2 = STACK_TV_BOT(-1)->vval.v_string;\n\t\t    char_u *res;\n\n\t\t    res = concat_str(str1, str2);\n\t\t    clear_tv(STACK_TV_BOT(-2));\n\t\t    clear_tv(STACK_TV_BOT(-1));\n\t\t    --ectx->ec_stack.ga_len;\n\t\t    STACK_TV_BOT(-1)->vval.v_string = res;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_STRINDEX:\n\t    case ISN_STRSLICE:\n\t\t{\n\t\t    int\t\tis_slice = iptr->isn_type == ISN_STRSLICE;\n\t\t    varnumber_T\tn1 = 0, n2;\n\t\t    char_u\t*res;\n\n\t\t    // string index: string is at stack-2, index at stack-1\n\t\t    // string slice: string is at stack-3, first index at\n\t\t    // stack-2, second index at stack-1\n\t\t    if (is_slice)\n\t\t    {\n\t\t\ttv = STACK_TV_BOT(-2);\n\t\t\tn1 = tv->vval.v_number;\n\t\t    }\n\n\t\t    tv = STACK_TV_BOT(-1);\n\t\t    n2 = tv->vval.v_number;\n\n\t\t    ectx->ec_stack.ga_len -= is_slice ? 2 : 1;\n\t\t    tv = STACK_TV_BOT(-1);\n\t\t    if (is_slice)\n\t\t\t// Slice: Select the characters from the string\n\t\t\tres = string_slice(tv->vval.v_string, n1, n2, FALSE);\n\t\t    else\n\t\t\t// Index: The resulting variable is a string of a\n\t\t\t// single character (including composing characters).\n\t\t\t// If the index is too big or negative the result is\n\t\t\t// empty.\n\t\t\tres = char_from_string(tv->vval.v_string, n2);\n\t\t    vim_free(tv->vval.v_string);\n\t\t    tv->vval.v_string = res;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_LISTINDEX:\n\t    case ISN_LISTSLICE:\n\t    case ISN_BLOBINDEX:\n\t    case ISN_BLOBSLICE:\n\t\t{\n\t\t    int\t\tis_slice = iptr->isn_type == ISN_LISTSLICE\n\t\t\t\t\t    || iptr->isn_type == ISN_BLOBSLICE;\n\t\t    int\t\tis_blob = iptr->isn_type == ISN_BLOBINDEX\n\t\t\t\t\t    || iptr->isn_type == ISN_BLOBSLICE;\n\t\t    varnumber_T\tn1, n2;\n\t\t    typval_T\t*val_tv;\n\n\t\t    // list index: list is at stack-2, index at stack-1\n\t\t    // list slice: list is at stack-3, indexes at stack-2 and\n\t\t    // stack-1\n\t\t    // Same for blob.\n\t\t    val_tv = is_slice ? STACK_TV_BOT(-3) : STACK_TV_BOT(-2);\n\n\t\t    tv = STACK_TV_BOT(-1);\n\t\t    n1 = n2 = tv->vval.v_number;\n\t\t    clear_tv(tv);\n\n\t\t    if (is_slice)\n\t\t    {\n\t\t\ttv = STACK_TV_BOT(-2);\n\t\t\tn1 = tv->vval.v_number;\n\t\t\tclear_tv(tv);\n\t\t    }\n\n\t\t    ectx->ec_stack.ga_len -= is_slice ? 2 : 1;\n\t\t    tv = STACK_TV_BOT(-1);\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    if (is_blob)\n\t\t    {\n\t\t\tif (blob_slice_or_index(val_tv->vval.v_blob, is_slice,\n\t\t\t\t\t\t    n1, n2, FALSE, tv) == FAIL)\n\t\t\t    goto on_error;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (list_slice_or_index(val_tv->vval.v_list, is_slice,\n\t\t\t\t\t      n1, n2, FALSE, tv, TRUE) == FAIL)\n\t\t\t    goto on_error;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    case ISN_ANYINDEX:\n\t    case ISN_ANYSLICE:\n\t\t{\n\t\t    int\t\tis_slice = iptr->isn_type == ISN_ANYSLICE;\n\t\t    typval_T\t*var1, *var2;\n\t\t    int\t\tres;\n\n\t\t    // index: composite is at stack-2, index at stack-1\n\t\t    // slice: composite is at stack-3, indexes at stack-2 and\n\t\t    // stack-1\n\t\t    tv = is_slice ? STACK_TV_BOT(-3) : STACK_TV_BOT(-2);\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    if (check_can_index(tv, TRUE, TRUE) == FAIL)\n\t\t\tgoto on_error;\n\t\t    var1 = is_slice ? STACK_TV_BOT(-2) : STACK_TV_BOT(-1);\n\t\t    var2 = is_slice ? STACK_TV_BOT(-1) : NULL;\n\t\t    res = eval_index_inner(tv, is_slice, var1, var2,\n\t\t\t\t\t\t\tFALSE, NULL, -1, TRUE);\n\t\t    clear_tv(var1);\n\t\t    if (is_slice)\n\t\t\tclear_tv(var2);\n\t\t    ectx->ec_stack.ga_len -= is_slice ? 2 : 1;\n\t\t    if (res == FAIL)\n\t\t\tgoto on_error;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_SLICE:\n\t\t{\n\t\t    list_T\t*list;\n\t\t    int\t\tcount = iptr->isn_arg.number;\n\n\t\t    // type will have been checked to be a list\n\t\t    tv = STACK_TV_BOT(-1);\n\t\t    list = tv->vval.v_list;\n\n\t\t    // no error for short list, expect it to be checked earlier\n\t\t    if (list != NULL && list->lv_len >= count)\n\t\t    {\n\t\t\tlist_T\t*newlist = list_slice(list,\n\t\t\t\t\t\t      count, list->lv_len - 1);\n\n\t\t\tif (newlist != NULL)\n\t\t\t{\n\t\t\t    list_unref(list);\n\t\t\t    tv->vval.v_list = newlist;\n\t\t\t    ++newlist->lv_refcount;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    case ISN_GETITEM:\n\t\t{\n\t\t    listitem_T\t*li;\n\t\t    getitem_T\t*gi = &iptr->isn_arg.getitem;\n\n\t\t    // Get list item: list is at stack-1, push item.\n\t\t    // List type and length is checked for when compiling.\n\t\t    tv = STACK_TV_BOT(-1 - gi->gi_with_op);\n\t\t    li = list_find(tv->vval.v_list, gi->gi_index);\n\n\t\t    if (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t\tgoto theend;\n\t\t    ++ectx->ec_stack.ga_len;\n\t\t    copy_tv(&li->li_tv, STACK_TV_BOT(-1));\n\n\t\t    // Useful when used in unpack assignment.  Reset at\n\t\t    // ISN_DROP.\n\t\t    ectx->ec_where.wt_index = gi->gi_index + 1;\n\t\t    ectx->ec_where.wt_variable = TRUE;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_MEMBER:\n\t\t{\n\t\t    dict_T\t*dict;\n\t\t    char_u\t*key;\n\t\t    dictitem_T\t*di;\n\n\t\t    // dict member: dict is at stack-2, key at stack-1\n\t\t    tv = STACK_TV_BOT(-2);\n\t\t    // no need to check for VAR_DICT, CHECKTYPE will check.\n\t\t    dict = tv->vval.v_dict;\n\n\t\t    tv = STACK_TV_BOT(-1);\n\t\t    // no need to check for VAR_STRING, 2STRING will check.\n\t\t    key = tv->vval.v_string;\n\t\t    if (key == NULL)\n\t\t\tkey = (char_u *)\"\";\n\n\t\t    if ((di = dict_find(dict, key, -1)) == NULL)\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\tsemsg(_(e_dictkey), key);\n\n\t\t\t// If :silent! is used we will continue, make sure the\n\t\t\t// stack contents makes sense and the dict stack is\n\t\t\t// updated.\n\t\t\tclear_tv(tv);\n\t\t\t--ectx->ec_stack.ga_len;\n\t\t\ttv = STACK_TV_BOT(-1);\n\t\t\t(void) dict_stack_save(tv);\n\t\t\ttv->v_type = VAR_NUMBER;\n\t\t\ttv->vval.v_number = 0;\n\t\t\tgoto on_fatal_error;\n\t\t    }\n\t\t    clear_tv(tv);\n\t\t    --ectx->ec_stack.ga_len;\n\t\t    // Put the dict used on the dict stack, it might be used by\n\t\t    // a dict function later.\n\t\t    tv = STACK_TV_BOT(-1);\n\t\t    if (dict_stack_save(tv) == FAIL)\n\t\t\tgoto on_fatal_error;\n\t\t    copy_tv(&di->di_tv, tv);\n\t\t}\n\t\tbreak;\n\n\t    // dict member with string key\n\t    case ISN_STRINGMEMBER:\n\t\t{\n\t\t    dict_T\t*dict;\n\t\t    dictitem_T\t*di;\n\n\t\t    tv = STACK_TV_BOT(-1);\n\t\t    if (tv->v_type != VAR_DICT || tv->vval.v_dict == NULL)\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\temsg(_(e_dictreq));\n\t\t\tgoto on_error;\n\t\t    }\n\t\t    dict = tv->vval.v_dict;\n\n\t\t    if ((di = dict_find(dict, iptr->isn_arg.string, -1))\n\t\t\t\t\t\t\t\t       == NULL)\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\tsemsg(_(e_dictkey), iptr->isn_arg.string);\n\t\t\tgoto on_error;\n\t\t    }\n\t\t    // Put the dict used on the dict stack, it might be used by\n\t\t    // a dict function later.\n\t\t    if (dict_stack_save(tv) == FAIL)\n\t\t\tgoto on_fatal_error;\n\n\t\t    copy_tv(&di->di_tv, tv);\n\t\t}\n\t\tbreak;\n\n\t    case ISN_CLEARDICT:\n\t\tdict_stack_drop();\n\t\tbreak;\n\n\t    case ISN_USEDICT:\n\t\t{\n\t\t    typval_T *dict_tv = dict_stack_get_tv();\n\n\t\t    // Turn \"dict.Func\" into a partial for \"Func\" bound to\n\t\t    // \"dict\".  Don't do this when \"Func\" is already a partial\n\t\t    // that was bound explicitly (pt_auto is FALSE).\n\t\t    tv = STACK_TV_BOT(-1);\n\t\t    if (dict_tv != NULL\n\t\t\t    && dict_tv->v_type == VAR_DICT\n\t\t\t    && dict_tv->vval.v_dict != NULL\n\t\t\t    && (tv->v_type == VAR_FUNC\n\t\t\t\t|| (tv->v_type == VAR_PARTIAL\n\t\t\t\t    && (tv->vval.v_partial->pt_auto\n\t\t\t\t     || tv->vval.v_partial->pt_dict == NULL))))\n\t\t    dict_tv->vval.v_dict =\n\t\t\t\t\tmake_partial(dict_tv->vval.v_dict, tv);\n\t\t    dict_stack_drop();\n\t\t}\n\t\tbreak;\n\n\t    case ISN_NEGATENR:\n\t\ttv = STACK_TV_BOT(-1);\n\t\tif (tv->v_type != VAR_NUMBER\n#ifdef FEAT_FLOAT\n\t\t\t&& tv->v_type != VAR_FLOAT\n#endif\n\t\t\t)\n\t\t{\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    emsg(_(e_number_expected));\n\t\t    goto on_error;\n\t\t}\n#ifdef FEAT_FLOAT\n\t\tif (tv->v_type == VAR_FLOAT)\n\t\t    tv->vval.v_float = -tv->vval.v_float;\n\t\telse\n#endif\n\t\t    tv->vval.v_number = -tv->vval.v_number;\n\t\tbreak;\n\n\t    case ISN_CHECKNR:\n\t\t{\n\t\t    int\t\terror = FALSE;\n\n\t\t    tv = STACK_TV_BOT(-1);\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    if (check_not_string(tv) == FAIL)\n\t\t\tgoto on_error;\n\t\t    (void)tv_get_number_chk(tv, &error);\n\t\t    if (error)\n\t\t\tgoto on_error;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_CHECKTYPE:\n\t\t{\n\t\t    checktype_T *ct = &iptr->isn_arg.type;\n\n\t\t    tv = STACK_TV_BOT((int)ct->ct_off);\n\t\t    SOURCING_LNUM = iptr->isn_lnum;\n\t\t    if (!ectx->ec_where.wt_variable)\n\t\t\tectx->ec_where.wt_index = ct->ct_arg_idx;\n\t\t    if (check_typval_type(ct->ct_type, tv, ectx->ec_where)\n\t\t\t\t\t\t\t\t       == FAIL)\n\t\t\tgoto on_error;\n\t\t    if (!ectx->ec_where.wt_variable)\n\t\t\tectx->ec_where.wt_index = 0;\n\n\t\t    // number 0 is FALSE, number 1 is TRUE\n\t\t    if (tv->v_type == VAR_NUMBER\n\t\t\t    && ct->ct_type->tt_type == VAR_BOOL\n\t\t\t    && (tv->vval.v_number == 0\n\t\t\t\t\t\t|| tv->vval.v_number == 1))\n\t\t    {\n\t\t\ttv->v_type = VAR_BOOL;\n\t\t\ttv->vval.v_number = tv->vval.v_number\n\t\t\t\t\t\t      ? VVAL_TRUE : VVAL_FALSE;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    case ISN_CHECKLEN:\n\t\t{\n\t\t    int\t    min_len = iptr->isn_arg.checklen.cl_min_len;\n\t\t    list_T  *list = NULL;\n\n\t\t    tv = STACK_TV_BOT(-1);\n\t\t    if (tv->v_type == VAR_LIST)\n\t\t\t    list = tv->vval.v_list;\n\t\t    if (list == NULL || list->lv_len < min_len\n\t\t\t    || (list->lv_len > min_len\n\t\t\t\t\t&& !iptr->isn_arg.checklen.cl_more_OK))\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\tsemsg(_(e_expected_nr_items_but_got_nr),\n\t\t\t\t     min_len, list == NULL ? 0 : list->lv_len);\n\t\t\tgoto on_error;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    case ISN_SETTYPE:\n\t\t{\n\t\t    checktype_T *ct = &iptr->isn_arg.type;\n\n\t\t    tv = STACK_TV_BOT(-1);\n\t\t    if (tv->v_type == VAR_DICT && tv->vval.v_dict != NULL)\n\t\t    {\n\t\t\tfree_type(tv->vval.v_dict->dv_type);\n\t\t\ttv->vval.v_dict->dv_type = alloc_type(ct->ct_type);\n\t\t    }\n\t\t    else if (tv->v_type == VAR_LIST && tv->vval.v_list != NULL)\n\t\t    {\n\t\t\tfree_type(tv->vval.v_list->lv_type);\n\t\t\ttv->vval.v_list->lv_type = alloc_type(ct->ct_type);\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    case ISN_2BOOL:\n\t    case ISN_COND2BOOL:\n\t\t{\n\t\t    int n;\n\t\t    int error = FALSE;\n\n\t\t    if (iptr->isn_type == ISN_2BOOL)\n\t\t    {\n\t\t\ttv = STACK_TV_BOT(iptr->isn_arg.tobool.offset);\n\t\t\tn = tv2bool(tv);\n\t\t\tif (iptr->isn_arg.tobool.invert)\n\t\t\t    n = !n;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\ttv = STACK_TV_BOT(-1);\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\tn = tv_get_bool_chk(tv, &error);\n\t\t\tif (error)\n\t\t\t    goto on_error;\n\t\t    }\n\t\t    clear_tv(tv);\n\t\t    tv->v_type = VAR_BOOL;\n\t\t    tv->vval.v_number = n ? VVAL_TRUE : VVAL_FALSE;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_2STRING:\n\t    case ISN_2STRING_ANY:\n\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\tif (do_2string(STACK_TV_BOT(iptr->isn_arg.tostring.offset),\n\t\t\t\tiptr->isn_type == ISN_2STRING_ANY,\n\t\t\t\t      iptr->isn_arg.tostring.tolerant) == FAIL)\n\t\t\t    goto on_error;\n\t\tbreak;\n\n\t    case ISN_RANGE:\n\t\t{\n\t\t    exarg_T\tea;\n\t\t    char\t*errormsg;\n\n\t\t    ea.line2 = 0;\n\t\t    ea.addr_count = 0;\n\t\t    ea.addr_type = ADDR_LINES;\n\t\t    ea.cmd = iptr->isn_arg.string;\n\t\t    ea.skip = FALSE;\n\t\t    if (parse_cmd_address(&ea, &errormsg, FALSE) == FAIL)\n\t\t\tgoto on_error;\n\n\t\t    if (GA_GROW_FAILS(&ectx->ec_stack, 1))\n\t\t\tgoto theend;\n\t\t    ++ectx->ec_stack.ga_len;\n\t\t    tv = STACK_TV_BOT(-1);\n\t\t    tv->v_type = VAR_NUMBER;\n\t\t    tv->v_lock = 0;\n\t\t    if (ea.addr_count == 0)\n\t\t\ttv->vval.v_number = curwin->w_cursor.lnum;\n\t\t    else\n\t\t\ttv->vval.v_number = ea.line2;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_PUT:\n\t\t{\n\t\t    int\t\tregname = iptr->isn_arg.put.put_regname;\n\t\t    linenr_T\tlnum = iptr->isn_arg.put.put_lnum;\n\t\t    char_u\t*expr = NULL;\n\t\t    int\t\tdir = FORWARD;\n\n\t\t    if (lnum < -2)\n\t\t    {\n\t\t\t// line number was put on the stack by ISN_RANGE\n\t\t\ttv = STACK_TV_BOT(-1);\n\t\t\tcurwin->w_cursor.lnum = tv->vval.v_number;\n\t\t\tif (lnum == LNUM_VARIABLE_RANGE_ABOVE)\n\t\t\t    dir = BACKWARD;\n\t\t\t--ectx->ec_stack.ga_len;\n\t\t    }\n\t\t    else if (lnum == -2)\n\t\t\t// :put! above cursor\n\t\t\tdir = BACKWARD;\n\t\t    else if (lnum >= 0)\n\t\t\tcurwin->w_cursor.lnum = iptr->isn_arg.put.put_lnum;\n\n\t\t    if (regname == '=')\n\t\t    {\n\t\t\ttv = STACK_TV_BOT(-1);\n\t\t\tif (tv->v_type == VAR_STRING)\n\t\t\t    expr = tv->vval.v_string;\n\t\t\telse\n\t\t\t{\n\t\t\t    expr = typval2string(tv, TRUE); // allocates value\n\t\t\t    clear_tv(tv);\n\t\t\t}\n\t\t\t--ectx->ec_stack.ga_len;\n\t\t    }\n\t\t    check_cursor();\n\t\t    do_put(regname, expr, dir, 1L, PUT_LINE|PUT_CURSLINE);\n\t\t    vim_free(expr);\n\t\t}\n\t\tbreak;\n\n\t    case ISN_CMDMOD:\n\t\tectx->ec_funclocal.floc_save_cmdmod = cmdmod;\n\t\tectx->ec_funclocal.floc_restore_cmdmod = TRUE;\n\t\tectx->ec_funclocal.floc_restore_cmdmod_stacklen =\n\t\t\t\t\t\t\t ectx->ec_stack.ga_len;\n\t\tcmdmod = *iptr->isn_arg.cmdmod.cf_cmdmod;\n\t\tapply_cmdmod(&cmdmod);\n\t\tbreak;\n\n\t    case ISN_CMDMOD_REV:\n\t\t// filter regprog is owned by the instruction, don't free it\n\t\tcmdmod.cmod_filter_regmatch.regprog = NULL;\n\t\tundo_cmdmod(&cmdmod);\n\t\tcmdmod = ectx->ec_funclocal.floc_save_cmdmod;\n\t\tectx->ec_funclocal.floc_restore_cmdmod = FALSE;\n\t\tbreak;\n\n\t    case ISN_UNPACK:\n\t\t{\n\t\t    int\t\tcount = iptr->isn_arg.unpack.unp_count;\n\t\t    int\t\tsemicolon = iptr->isn_arg.unpack.unp_semicolon;\n\t\t    list_T\t*l;\n\t\t    listitem_T\t*li;\n\t\t    int\t\ti;\n\n\t\t    // Check there is a valid list to unpack.\n\t\t    tv = STACK_TV_BOT(-1);\n\t\t    if (tv->v_type != VAR_LIST)\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\temsg(_(e_for_argument_must_be_sequence_of_lists));\n\t\t\tgoto on_error;\n\t\t    }\n\t\t    l = tv->vval.v_list;\n\t\t    if (l == NULL\n\t\t\t\t|| l->lv_len < (semicolon ? count - 1 : count))\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\temsg(_(e_list_value_does_not_have_enough_items));\n\t\t\tgoto on_error;\n\t\t    }\n\t\t    else if (!semicolon && l->lv_len > count)\n\t\t    {\n\t\t\tSOURCING_LNUM = iptr->isn_lnum;\n\t\t\temsg(_(e_list_value_has_more_items_than_targets));\n\t\t\tgoto on_error;\n\t\t    }\n\n\t\t    CHECK_LIST_MATERIALIZE(l);\n\t\t    if (GA_GROW_FAILS(&ectx->ec_stack, count - 1))\n\t\t\tgoto theend;\n\t\t    ectx->ec_stack.ga_len += count - 1;\n\n\t\t    // Variable after semicolon gets a list with the remaining\n\t\t    // items.\n\t\t    if (semicolon)\n\t\t    {\n\t\t\tlist_T\t*rem_list =\n\t\t\t\t  list_alloc_with_items(l->lv_len - count + 1);\n\n\t\t\tif (rem_list == NULL)\n\t\t\t    goto theend;\n\t\t\ttv = STACK_TV_BOT(-count);\n\t\t\ttv->vval.v_list = rem_list;\n\t\t\t++rem_list->lv_refcount;\n\t\t\ttv->v_lock = 0;\n\t\t\tli = l->lv_first;\n\t\t\tfor (i = 0; i < count - 1; ++i)\n\t\t\t    li = li->li_next;\n\t\t\tfor (i = 0; li != NULL; ++i)\n\t\t\t{\n\t\t\t    list_set_item(rem_list, i, &li->li_tv);\n\t\t\t    li = li->li_next;\n\t\t\t}\n\t\t\t--count;\n\t\t    }\n\n\t\t    // Produce the values in reverse order, first item last.\n\t\t    li = l->lv_first;\n\t\t    for (i = 0; i < count; ++i)\n\t\t    {\n\t\t\ttv = STACK_TV_BOT(-i - 1);\n\t\t\tcopy_tv(&li->li_tv, tv);\n\t\t\tli = li->li_next;\n\t\t    }\n\n\t\t    list_unref(l);\n\t\t}\n\t\tbreak;\n\n\t    case ISN_PROF_START:\n\t    case ISN_PROF_END:\n\t\t{\n#ifdef FEAT_PROFILE\n\t\t    funccall_T cookie;\n\t\t    ufunc_T\t    *cur_ufunc =\n\t\t\t\t    (((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t       + ectx->ec_dfunc_idx)->df_ufunc;\n\n\t\t    cookie.func = cur_ufunc;\n\t\t    if (iptr->isn_type == ISN_PROF_START)\n\t\t    {\n\t\t\tfunc_line_start(&cookie, iptr->isn_lnum);\n\t\t\t// if we get here the instruction is executed\n\t\t\tfunc_line_exec(&cookie);\n\t\t    }\n\t\t    else\n\t\t\tfunc_line_end(&cookie);\n#endif\n\t\t}\n\t\tbreak;\n\n\t    case ISN_DEBUG:\n\t\thandle_debug(iptr, ectx);\n\t\tbreak;\n\n\t    case ISN_SHUFFLE:\n\t\t{\n\t\t    typval_T\ttmp_tv;\n\t\t    int\t\titem = iptr->isn_arg.shuffle.shfl_item;\n\t\t    int\t\tup = iptr->isn_arg.shuffle.shfl_up;\n\n\t\t    tmp_tv = *STACK_TV_BOT(-item);\n\t\t    for ( ; up > 0 && item > 1; --up)\n\t\t    {\n\t\t\t*STACK_TV_BOT(-item) = *STACK_TV_BOT(-item + 1);\n\t\t\t--item;\n\t\t    }\n\t\t    *STACK_TV_BOT(-item) = tmp_tv;\n\t\t}\n\t\tbreak;\n\n\t    case ISN_DROP:\n\t\t--ectx->ec_stack.ga_len;\n\t\tclear_tv(STACK_TV_BOT(0));\n\t\tectx->ec_where.wt_index = 0;\n\t\tectx->ec_where.wt_variable = FALSE;\n\t\tbreak;\n\t}\n\tcontinue;\n\nfunc_return:\n\t// Restore previous function. If the frame pointer is where we started\n\t// then there is none and we are done.\n\tif (ectx->ec_frame_idx == ectx->ec_initial_frame_idx)\n\t    goto done;\n\n\tif (func_return(ectx) == FAIL)\n\t    // only fails when out of memory\n\t    goto theend;\n\tcontinue;\n\non_error:\n\t// Jump here for an error that does not require aborting execution.\n\t// If \"emsg_silent\" is set then ignore the error, unless it was set\n\t// when calling the function.\n\tif (did_emsg_cumul + did_emsg == ectx->ec_did_emsg_before\n\t\t\t\t\t   && emsg_silent && did_emsg_def == 0)\n\t{\n\t    // If a sequence of instructions causes an error while \":silent!\"\n\t    // was used, restore the stack length and jump ahead to restoring\n\t    // the cmdmod.\n\t    if (ectx->ec_funclocal.floc_restore_cmdmod)\n\t    {\n\t\twhile (ectx->ec_stack.ga_len\n\t\t\t     > ectx->ec_funclocal.floc_restore_cmdmod_stacklen)\n\t\t{\n\t\t    --ectx->ec_stack.ga_len;\n\t\t    clear_tv(STACK_TV_BOT(0));\n\t\t}\n\t\twhile (ectx->ec_instr[ectx->ec_iidx].isn_type != ISN_CMDMOD_REV)\n\t\t    ++ectx->ec_iidx;\n\t    }\n\t    continue;\n\t}\non_fatal_error:\n\t// Jump here for an error that messes up the stack.\n\t// If we are not inside a try-catch started here, abort execution.\n\tif (trylevel <= ectx->ec_trylevel_at_start)\n\t    goto theend;\n    }\n\ndone:\n    ret = OK;\ntheend:\n    dict_stack_clear(dict_stack_len_at_start);\n    ectx->ec_trylevel_at_start = save_trylevel_at_start;\n    return ret;\n}\n\n/*\n * Execute the instructions from a VAR_INSTR typeval and put the result in\n * \"rettv\".\n * Return OK or FAIL.\n */\n    int\nexe_typval_instr(typval_T *tv, typval_T *rettv)\n{\n    ectx_T\t*ectx = tv->vval.v_instr->instr_ectx;\n    isn_T\t*save_instr = ectx->ec_instr;\n    int\t\tsave_iidx = ectx->ec_iidx;\n    int\t\tres;\n\n    ectx->ec_instr = tv->vval.v_instr->instr_instr;\n    res = exec_instructions(ectx);\n    if (res == OK)\n    {\n\t*rettv = *STACK_TV_BOT(-1);\n\t--ectx->ec_stack.ga_len;\n    }\n\n    ectx->ec_instr = save_instr;\n    ectx->ec_iidx = save_iidx;\n\n    return res;\n}\n\n/*\n * Execute the instructions from an ISN_SUBSTITUTE command, which are in\n * \"substitute_instr\".\n */\n    char_u *\nexe_substitute_instr(void)\n{\n    ectx_T\t*ectx = substitute_instr->subs_ectx;\n    isn_T\t*save_instr = ectx->ec_instr;\n    int\t\tsave_iidx = ectx->ec_iidx;\n    char_u\t*res;\n\n    ectx->ec_instr = substitute_instr->subs_instr;\n    if (exec_instructions(ectx) == OK)\n    {\n\ttypval_T *tv = STACK_TV_BOT(-1);\n\n\tres = typval2string(tv, TRUE);\n\t--ectx->ec_stack.ga_len;\n\tclear_tv(tv);\n    }\n    else\n    {\n\tsubstitute_instr->subs_status = FAIL;\n\tres = vim_strsave((char_u *)\"\");\n    }\n\n    ectx->ec_instr = save_instr;\n    ectx->ec_iidx = save_iidx;\n\n    return res;\n}\n\n/*\n * Call a \"def\" function from old Vim script.\n * Return OK or FAIL.\n */\n    int\ncall_def_function(\n    ufunc_T\t*ufunc,\n    int\t\targc_arg,\t// nr of arguments\n    typval_T\t*argv,\t\t// arguments\n    partial_T\t*partial,\t// optional partial for context\n    typval_T\t*rettv)\t\t// return value\n{\n    ectx_T\tectx;\t\t// execution context\n    int\t\targc = argc_arg;\n    typval_T\t*tv;\n    int\t\tidx;\n    int\t\tret = FAIL;\n    int\t\tdefcount = ufunc->uf_args.ga_len - argc;\n    sctx_T\tsave_current_sctx = current_sctx;\n    int\t\tdid_emsg_before = did_emsg_cumul + did_emsg;\n    int\t\tsave_suppress_errthrow = suppress_errthrow;\n    msglist_T\t**saved_msg_list = NULL;\n    msglist_T\t*private_msg_list = NULL;\n    int\t\tsave_emsg_silent_def = emsg_silent_def;\n    int\t\tsave_did_emsg_def = did_emsg_def;\n    int\t\torig_funcdepth;\n    int\t\torig_nesting_level = ex_nesting_level;\n\n// Get pointer to item in the stack.\n#undef STACK_TV\n#define STACK_TV(idx) (((typval_T *)ectx.ec_stack.ga_data) + idx)\n\n// Get pointer to item at the bottom of the stack, -1 is the bottom.\n#undef STACK_TV_BOT\n#define STACK_TV_BOT(idx) (((typval_T *)ectx.ec_stack.ga_data) + ectx.ec_stack.ga_len + idx)\n\n// Get pointer to a local variable on the stack.  Negative for arguments.\n#undef STACK_TV_VAR\n#define STACK_TV_VAR(idx) (((typval_T *)ectx.ec_stack.ga_data) + ectx.ec_frame_idx + STACK_FRAME_SIZE + idx)\n\n    // Update uf_has_breakpoint if needed.\n    update_has_breakpoint(ufunc);\n\n    if (ufunc->uf_def_status == UF_NOT_COMPILED\n\t    || ufunc->uf_def_status == UF_COMPILE_ERROR\n\t    || (func_needs_compiling(ufunc, COMPILE_TYPE(ufunc))\n\t\t&& compile_def_function(ufunc, FALSE, COMPILE_TYPE(ufunc), NULL)\n\t\t\t\t\t\t\t\t      == FAIL))\n    {\n\tif (did_emsg_cumul + did_emsg == did_emsg_before)\n\t    semsg(_(e_function_is_not_compiled_str),\n\t\t\t\t\t\t   printable_func_name(ufunc));\n\treturn FAIL;\n    }\n\n    {\n\t// Check the function was really compiled.\n\tdfunc_T\t*dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t + ufunc->uf_dfunc_idx;\n\tif (INSTRUCTIONS(dfunc) == NULL)\n\t{\n\t    iemsg(\"using call_def_function() on not compiled function\");\n\t    return FAIL;\n\t}\n    }\n\n    // If depth of calling is getting too high, don't execute the function.\n    orig_funcdepth = funcdepth_get();\n    if (funcdepth_increment() == FAIL)\n\treturn FAIL;\n\n    CLEAR_FIELD(ectx);\n    ectx.ec_dfunc_idx = ufunc->uf_dfunc_idx;\n    ga_init2(&ectx.ec_stack, sizeof(typval_T), 500);\n    if (GA_GROW_FAILS(&ectx.ec_stack, 20))\n    {\n\tfuncdepth_decrement();\n\treturn FAIL;\n    }\n    ga_init2(&ectx.ec_trystack, sizeof(trycmd_T), 10);\n    ga_init2(&ectx.ec_funcrefs, sizeof(partial_T *), 10);\n    ectx.ec_did_emsg_before = did_emsg_before;\n    ++ex_nesting_level;\n\n    idx = argc - ufunc->uf_args.ga_len;\n    if (idx > 0 && ufunc->uf_va_name == NULL)\n    {\n\tif (idx == 1)\n\t    emsg(_(e_one_argument_too_many));\n\telse\n\t    semsg(_(e_nr_arguments_too_many), idx);\n\tgoto failed_early;\n    }\n    idx = argc - ufunc->uf_args.ga_len + ufunc->uf_def_args.ga_len;\n    if (idx < 0)\n    {\n\tif (idx == -1)\n\t    emsg(_(e_one_argument_too_few));\n\telse\n\t    semsg(_(e_nr_arguments_too_few), -idx);\n\tgoto failed_early;\n    }\n\n    // Put arguments on the stack, but no more than what the function expects.\n    // A lambda can be called with more arguments than it uses.\n    for (idx = 0; idx < argc\n\t    && (ufunc->uf_va_name != NULL || idx < ufunc->uf_args.ga_len);\n\t\t\t\t\t\t\t\t\t ++idx)\n    {\n\tif (idx >= ufunc->uf_args.ga_len - ufunc->uf_def_args.ga_len\n\t\t&& argv[idx].v_type == VAR_SPECIAL\n\t\t&& argv[idx].vval.v_number == VVAL_NONE)\n\t{\n\t    // Use the default value.\n\t    STACK_TV_BOT(0)->v_type = VAR_UNKNOWN;\n\t}\n\telse\n\t{\n\t    if (ufunc->uf_arg_types != NULL && idx < ufunc->uf_args.ga_len\n\t\t    && check_typval_arg_type(\n\t\t\tufunc->uf_arg_types[idx], &argv[idx],\n\t\t\t\t\t\t\tNULL, idx + 1) == FAIL)\n\t\tgoto failed_early;\n\t    copy_tv(&argv[idx], STACK_TV_BOT(0));\n\t}\n\t++ectx.ec_stack.ga_len;\n    }\n\n    // Turn varargs into a list.  Empty list if no args.\n    if (ufunc->uf_va_name != NULL)\n    {\n\tint vararg_count = argc - ufunc->uf_args.ga_len;\n\n\tif (vararg_count < 0)\n\t    vararg_count = 0;\n\telse\n\t    argc -= vararg_count;\n\tif (exe_newlist(vararg_count, &ectx) == FAIL)\n\t    goto failed_early;\n\n\t// Check the type of the list items.\n\ttv = STACK_TV_BOT(-1);\n\tif (ufunc->uf_va_type != NULL\n\t\t&& ufunc->uf_va_type != &t_list_any\n\t\t&& ufunc->uf_va_type->tt_member != &t_any\n\t\t&& tv->vval.v_list != NULL)\n\t{\n\t    type_T\t*expected = ufunc->uf_va_type->tt_member;\n\t    listitem_T\t*li = tv->vval.v_list->lv_first;\n\n\t    for (idx = 0; idx < vararg_count; ++idx)\n\t    {\n\t\tif (check_typval_arg_type(expected, &li->li_tv,\n\t\t\t\t\t\t NULL, argc + idx + 1) == FAIL)\n\t\t    goto failed_early;\n\t\tli = li->li_next;\n\t    }\n\t}\n\n\tif (defcount > 0)\n\t    // Move varargs list to below missing default arguments.\n\t    *STACK_TV_BOT(defcount - 1) = *STACK_TV_BOT(-1);\n\t--ectx.ec_stack.ga_len;\n    }\n\n    // Make space for omitted arguments, will store default value below.\n    // Any varargs list goes after them.\n    if (defcount > 0)\n\tfor (idx = 0; idx < defcount; ++idx)\n\t{\n\t    STACK_TV_BOT(0)->v_type = VAR_UNKNOWN;\n\t    ++ectx.ec_stack.ga_len;\n\t}\n    if (ufunc->uf_va_name != NULL)\n\t++ectx.ec_stack.ga_len;\n\n    // Frame pointer points to just after arguments.\n    ectx.ec_frame_idx = ectx.ec_stack.ga_len;\n    ectx.ec_initial_frame_idx = ectx.ec_frame_idx;\n\n    {\n\tdfunc_T\t*dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t + ufunc->uf_dfunc_idx;\n\tufunc_T *base_ufunc = dfunc->df_ufunc;\n\n\t// \"uf_partial\" is on the ufunc that \"df_ufunc\" points to, as is done\n\t// by copy_func().\n\tif (partial != NULL || base_ufunc->uf_partial != NULL)\n\t{\n\t    ectx.ec_outer_ref = ALLOC_CLEAR_ONE(outer_ref_T);\n\t    if (ectx.ec_outer_ref == NULL)\n\t\tgoto failed_early;\n\t    if (partial != NULL)\n\t    {\n\t\tif (partial->pt_outer.out_stack == NULL && current_ectx != NULL)\n\t\t{\n\t\t    if (current_ectx->ec_outer_ref != NULL\n\t\t\t    && current_ectx->ec_outer_ref->or_outer != NULL)\n\t\t\tectx.ec_outer_ref->or_outer =\n\t\t\t\t\t  current_ectx->ec_outer_ref->or_outer;\n\t\t}\n\t\telse\n\t\t{\n\t\t    ectx.ec_outer_ref->or_outer = &partial->pt_outer;\n\t\t    ++partial->pt_refcount;\n\t\t    ectx.ec_outer_ref->or_partial = partial;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tectx.ec_outer_ref->or_outer = &base_ufunc->uf_partial->pt_outer;\n\t\t++base_ufunc->uf_partial->pt_refcount;\n\t\tectx.ec_outer_ref->or_partial = base_ufunc->uf_partial;\n\t    }\n\t}\n    }\n\n    // dummy frame entries\n    for (idx = 0; idx < STACK_FRAME_SIZE; ++idx)\n    {\n\tSTACK_TV(ectx.ec_stack.ga_len)->v_type = VAR_UNKNOWN;\n\t++ectx.ec_stack.ga_len;\n    }\n\n    {\n\t// Reserve space for local variables and any closure reference count.\n\tdfunc_T\t*dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t + ufunc->uf_dfunc_idx;\n\n\t// Initialize variables to zero.  That avoids having to generate\n\t// initializing instructions for \"var nr: number\", \"var x: any\", etc.\n\tfor (idx = 0; idx < dfunc->df_varcount; ++idx)\n\t{\n\t    STACK_TV_VAR(idx)->v_type = VAR_NUMBER;\n\t    STACK_TV_VAR(idx)->vval.v_number = 0;\n\t}\n\tectx.ec_stack.ga_len += dfunc->df_varcount;\n\tif (dfunc->df_has_closure)\n\t{\n\t    STACK_TV_VAR(idx)->v_type = VAR_NUMBER;\n\t    STACK_TV_VAR(idx)->vval.v_number = 0;\n\t    ++ectx.ec_stack.ga_len;\n\t}\n\n\tectx.ec_instr = INSTRUCTIONS(dfunc);\n    }\n\n    // Following errors are in the function, not the caller.\n    // Commands behave like vim9script.\n    estack_push_ufunc(ufunc, 1);\n    current_sctx = ufunc->uf_script_ctx;\n    current_sctx.sc_version = SCRIPT_VERSION_VIM9;\n\n    // Use a specific location for storing error messages to be converted to an\n    // exception.\n    saved_msg_list = msg_list;\n    msg_list = &private_msg_list;\n\n    // Do turn errors into exceptions.\n    suppress_errthrow = FALSE;\n\n    // Do not delete the function while executing it.\n    ++ufunc->uf_calls;\n\n    // When \":silent!\" was used before calling then we still abort the\n    // function.  If \":silent!\" is used in the function then we don't.\n    emsg_silent_def = emsg_silent;\n    did_emsg_def = 0;\n\n    ectx.ec_where.wt_index = 0;\n    ectx.ec_where.wt_variable = FALSE;\n\n    // Execute the instructions until done.\n    ret = exec_instructions(&ectx);\n    if (ret == OK)\n    {\n\t// function finished, get result from the stack.\n\tif (ufunc->uf_ret_type == &t_void)\n\t{\n\t    rettv->v_type = VAR_VOID;\n\t}\n\telse\n\t{\n\t    tv = STACK_TV_BOT(-1);\n\t    *rettv = *tv;\n\t    tv->v_type = VAR_UNKNOWN;\n\t}\n    }\n\n    // When failed need to unwind the call stack.\n    while (ectx.ec_frame_idx != ectx.ec_initial_frame_idx)\n\tfunc_return(&ectx);\n\n    // Deal with any remaining closures, they may be in use somewhere.\n    if (ectx.ec_funcrefs.ga_len > 0)\n    {\n\thandle_closure_in_use(&ectx, FALSE);\n\tga_clear(&ectx.ec_funcrefs);\n    }\n\n    estack_pop();\n    current_sctx = save_current_sctx;\n\n    if (--ufunc->uf_calls <= 0 && ufunc->uf_refcount <= 0)\n\t// Function was unreferenced while being used, free it now.\n\tfunc_clear_free(ufunc, FALSE);\n\n    if (*msg_list != NULL && saved_msg_list != NULL)\n    {\n\tmsglist_T **plist = saved_msg_list;\n\n\t// Append entries from the current msg_list (uncaught exceptions) to\n\t// the saved msg_list.\n\twhile (*plist != NULL)\n\t    plist = &(*plist)->next;\n\n\t*plist = *msg_list;\n    }\n    msg_list = saved_msg_list;\n\n    if (ectx.ec_funclocal.floc_restore_cmdmod)\n    {\n\tcmdmod.cmod_filter_regmatch.regprog = NULL;\n\tundo_cmdmod(&cmdmod);\n\tcmdmod = ectx.ec_funclocal.floc_save_cmdmod;\n    }\n    emsg_silent_def = save_emsg_silent_def;\n    did_emsg_def += save_did_emsg_def;\n\nfailed_early:\n    // Free all local variables, but not arguments.\n    for (idx = 0; idx < ectx.ec_stack.ga_len; ++idx)\n\tclear_tv(STACK_TV(idx));\n    ex_nesting_level = orig_nesting_level;\n\n    vim_free(ectx.ec_stack.ga_data);\n    vim_free(ectx.ec_trystack.ga_data);\n    if (ectx.ec_outer_ref != NULL)\n    {\n\tif (ectx.ec_outer_ref->or_outer_allocated)\n\t    vim_free(ectx.ec_outer_ref->or_outer);\n\tpartial_unref(ectx.ec_outer_ref->or_partial);\n\tvim_free(ectx.ec_outer_ref);\n    }\n\n    // Not sure if this is necessary.\n    suppress_errthrow = save_suppress_errthrow;\n\n    if (ret != OK && did_emsg_cumul + did_emsg == did_emsg_before\n\t\t\t\t\t\t\t      && !need_rethrow)\n\tsemsg(_(e_unknown_error_while_executing_str),\n\t\t\t\t\t\t   printable_func_name(ufunc));\n    funcdepth_restore(orig_funcdepth);\n    return ret;\n}\n\n/*\n * List instructions \"instr\" up to \"instr_count\" or until ISN_FINISH.\n * \"ufunc\" has the source lines, NULL for the instructions of ISN_SUBSTITUTE.\n * \"pfx\" is prefixed to every line.\n */\n    static void\nlist_instructions(char *pfx, isn_T *instr, int instr_count, ufunc_T *ufunc)\n{\n    int\t\tline_idx = 0;\n    int\t\tprev_current = 0;\n    int\t\tcurrent;\n    int\t\tdef_arg_idx = 0;\n\n    for (current = 0; current < instr_count; ++current)\n    {\n\tisn_T\t    *iptr = &instr[current];\n\tchar\t    *line;\n\n\tif (ufunc != NULL)\n\t{\n\t    while (line_idx < iptr->isn_lnum\n\t\t\t\t\t  && line_idx < ufunc->uf_lines.ga_len)\n\t    {\n\t\tif (current > prev_current)\n\t\t{\n\t\t    msg_puts(\"\\n\\n\");\n\t\t    prev_current = current;\n\t\t}\n\t\tline = ((char **)ufunc->uf_lines.ga_data)[line_idx++];\n\t\tif (line != NULL)\n\t\t    msg(line);\n\t    }\n\t    if (iptr->isn_type == ISN_JUMP_IF_ARG_SET)\n\t    {\n\t\tint\tfirst_def_arg = ufunc->uf_args.ga_len\n\t\t\t\t\t\t   - ufunc->uf_def_args.ga_len;\n\n\t\tif (def_arg_idx > 0)\n\t\t    msg_puts(\"\\n\\n\");\n\t\tmsg_start();\n\t\tmsg_puts(\"  \");\n\t\tmsg_puts(((char **)(ufunc->uf_args.ga_data))[\n\t\t\t\t\t\t first_def_arg + def_arg_idx]);\n\t\tmsg_puts(\" = \");\n\t\tmsg_puts(((char **)(ufunc->uf_def_args.ga_data))[def_arg_idx++]);\n\t\tmsg_clr_eos();\n\t\tmsg_end();\n\t    }\n\t}\n\n\tswitch (iptr->isn_type)\n\t{\n\t    case ISN_EXEC:\n\t\tsmsg(\"%s%4d EXEC %s\", pfx, current, iptr->isn_arg.string);\n\t\tbreak;\n\t    case ISN_EXEC_SPLIT:\n\t\tsmsg(\"%s%4d EXEC_SPLIT %s\", pfx, current, iptr->isn_arg.string);\n\t\tbreak;\n\t    case ISN_EXECRANGE:\n\t\tsmsg(\"%s%4d EXECRANGE %s\", pfx, current, iptr->isn_arg.string);\n\t\tbreak;\n\t    case ISN_LEGACY_EVAL:\n\t\tsmsg(\"%s%4d EVAL legacy %s\", pfx, current,\n\t\t\t\t\t\t\t iptr->isn_arg.string);\n\t\tbreak;\n\t    case ISN_REDIRSTART:\n\t\tsmsg(\"%s%4d REDIR\", pfx, current);\n\t\tbreak;\n\t    case ISN_REDIREND:\n\t\tsmsg(\"%s%4d REDIR END%s\", pfx, current,\n\t\t\t\t\tiptr->isn_arg.number ? \" append\" : \"\");\n\t\tbreak;\n\t    case ISN_CEXPR_AUCMD:\n#ifdef FEAT_QUICKFIX\n\t\tsmsg(\"%s%4d CEXPR pre %s\", pfx, current,\n\t\t\t\t       cexpr_get_auname(iptr->isn_arg.number));\n#endif\n\t\tbreak;\n\t    case ISN_CEXPR_CORE:\n#ifdef FEAT_QUICKFIX\n\t\t{\n\t\t    cexprref_T\t    *cer = iptr->isn_arg.cexpr.cexpr_ref;\n\n\t\t    smsg(\"%s%4d CEXPR core %s%s \\\"%s\\\"\", pfx, current,\n\t\t\t\t       cexpr_get_auname(cer->cer_cmdidx),\n\t\t\t\t       cer->cer_forceit ? \"!\" : \"\",\n\t\t\t\t       cer->cer_cmdline);\n\t\t}\n#endif\n\t\tbreak;\n\t    case ISN_INSTR:\n\t\t{\n\t\t    smsg(\"%s%4d INSTR\", pfx, current);\n\t\t    list_instructions(\"    \", iptr->isn_arg.instr,\n\t\t\t\t\t\t\t\tINT_MAX, NULL);\n\t\t    msg(\"     -------------\");\n\t\t}\n\t\tbreak;\n\t    case ISN_SUBSTITUTE:\n\t\t{\n\t\t    subs_T *subs = &iptr->isn_arg.subs;\n\n\t\t    smsg(\"%s%4d SUBSTITUTE %s\", pfx, current, subs->subs_cmd);\n\t\t    list_instructions(\"    \", subs->subs_instr, INT_MAX, NULL);\n\t\t    msg(\"     -------------\");\n\t\t}\n\t\tbreak;\n\t    case ISN_EXECCONCAT:\n\t\tsmsg(\"%s%4d EXECCONCAT %lld\", pfx, current,\n\t\t\t\t\t      (varnumber_T)iptr->isn_arg.number);\n\t\tbreak;\n\t    case ISN_ECHO:\n\t\t{\n\t\t    echo_T *echo = &iptr->isn_arg.echo;\n\n\t\t    smsg(\"%s%4d %s %d\", pfx, current,\n\t\t\t    echo->echo_with_white ? \"ECHO\" : \"ECHON\",\n\t\t\t    echo->echo_count);\n\t\t}\n\t\tbreak;\n\t    case ISN_EXECUTE:\n\t\tsmsg(\"%s%4d EXECUTE %lld\", pfx, current,\n\t\t\t\t\t  (varnumber_T)(iptr->isn_arg.number));\n\t\tbreak;\n\t    case ISN_ECHOMSG:\n\t\tsmsg(\"%s%4d ECHOMSG %lld\", pfx, current,\n\t\t\t\t\t  (varnumber_T)(iptr->isn_arg.number));\n\t\tbreak;\n\t    case ISN_ECHOCONSOLE:\n\t\tsmsg(\"%s%4d ECHOCONSOLE %lld\", pfx, current,\n\t\t\t\t\t  (varnumber_T)(iptr->isn_arg.number));\n\t\tbreak;\n\t    case ISN_ECHOERR:\n\t\tsmsg(\"%s%4d ECHOERR %lld\", pfx, current,\n\t\t\t\t\t  (varnumber_T)(iptr->isn_arg.number));\n\t\tbreak;\n\t    case ISN_LOAD:\n\t\t{\n\t\t    if (iptr->isn_arg.number < 0)\n\t\t\tsmsg(\"%s%4d LOAD arg[%lld]\", pfx, current,\n\t\t\t\t(varnumber_T)(iptr->isn_arg.number\n\t\t\t\t\t\t\t  + STACK_FRAME_SIZE));\n\t\t    else\n\t\t\tsmsg(\"%s%4d LOAD $%lld\", pfx, current,\n\t\t\t\t\t  (varnumber_T)(iptr->isn_arg.number));\n\t\t}\n\t\tbreak;\n\t    case ISN_LOADOUTER:\n\t\t{\n\t\t    if (iptr->isn_arg.number < 0)\n\t\t\tsmsg(\"%s%4d LOADOUTER level %d arg[%d]\", pfx, current,\n\t\t\t\tiptr->isn_arg.outer.outer_depth,\n\t\t\t\tiptr->isn_arg.outer.outer_idx\n\t\t\t\t\t\t\t  + STACK_FRAME_SIZE);\n\t\t    else\n\t\t\tsmsg(\"%s%4d LOADOUTER level %d $%d\", pfx, current,\n\t\t\t\t\t      iptr->isn_arg.outer.outer_depth,\n\t\t\t\t\t      iptr->isn_arg.outer.outer_idx);\n\t\t}\n\t\tbreak;\n\t    case ISN_LOADV:\n\t\tsmsg(\"%s%4d LOADV v:%s\", pfx, current,\n\t\t\t\t       get_vim_var_name(iptr->isn_arg.number));\n\t\tbreak;\n\t    case ISN_LOADSCRIPT:\n\t\t{\n\t\t    scriptref_T\t    *sref = iptr->isn_arg.script.scriptref;\n\t\t    scriptitem_T    *si = SCRIPT_ITEM(sref->sref_sid);\n\t\t    svar_T\t    *sv;\n\n\t\t    sv = get_script_svar(sref, -1);\n\t\t    if (sv == NULL)\n\t\t\tsmsg(\"%s%4d LOADSCRIPT [deleted] from %s\",\n\t\t\t\t\t\t    pfx, current, si->sn_name);\n\t\t    else\n\t\t\tsmsg(\"%s%4d LOADSCRIPT %s-%d from %s\", pfx, current,\n\t\t\t\t\t    sv->sv_name,\n\t\t\t\t\t    sref->sref_idx,\n\t\t\t\t\t    si->sn_name);\n\t\t}\n\t\tbreak;\n\t    case ISN_LOADS:\n\t\t{\n\t\t    scriptitem_T *si = SCRIPT_ITEM(\n\t\t\t\t\t       iptr->isn_arg.loadstore.ls_sid);\n\n\t\t    smsg(\"%s%4d LOADS s:%s from %s\", pfx, current,\n\t\t\t\t iptr->isn_arg.loadstore.ls_name, si->sn_name);\n\t\t}\n\t\tbreak;\n\t    case ISN_LOADAUTO:\n\t\tsmsg(\"%s%4d LOADAUTO %s\", pfx, current, iptr->isn_arg.string);\n\t\tbreak;\n\t    case ISN_LOADG:\n\t\tsmsg(\"%s%4d LOADG g:%s\", pfx, current, iptr->isn_arg.string);\n\t\tbreak;\n\t    case ISN_LOADB:\n\t\tsmsg(\"%s%4d LOADB b:%s\", pfx, current, iptr->isn_arg.string);\n\t\tbreak;\n\t    case ISN_LOADW:\n\t\tsmsg(\"%s%4d LOADW w:%s\", pfx, current, iptr->isn_arg.string);\n\t\tbreak;\n\t    case ISN_LOADT:\n\t\tsmsg(\"%s%4d LOADT t:%s\", pfx, current, iptr->isn_arg.string);\n\t\tbreak;\n\t    case ISN_LOADGDICT:\n\t\tsmsg(\"%s%4d LOAD g:\", pfx, current);\n\t\tbreak;\n\t    case ISN_LOADBDICT:\n\t\tsmsg(\"%s%4d LOAD b:\", pfx, current);\n\t\tbreak;\n\t    case ISN_LOADWDICT:\n\t\tsmsg(\"%s%4d LOAD w:\", pfx, current);\n\t\tbreak;\n\t    case ISN_LOADTDICT:\n\t\tsmsg(\"%s%4d LOAD t:\", pfx, current);\n\t\tbreak;\n\t    case ISN_LOADOPT:\n\t\tsmsg(\"%s%4d LOADOPT %s\", pfx, current, iptr->isn_arg.string);\n\t\tbreak;\n\t    case ISN_LOADENV:\n\t\tsmsg(\"%s%4d LOADENV %s\", pfx, current, iptr->isn_arg.string);\n\t\tbreak;\n\t    case ISN_LOADREG:\n\t\tsmsg(\"%s%4d LOADREG @%c\", pfx, current,\n\t\t\t\t\t\t  (int)(iptr->isn_arg.number));\n\t\tbreak;\n\n\t    case ISN_STORE:\n\t\tif (iptr->isn_arg.number < 0)\n\t\t    smsg(\"%s%4d STORE arg[%lld]\", pfx, current,\n\t\t\t\t      iptr->isn_arg.number + STACK_FRAME_SIZE);\n\t\telse\n\t\t    smsg(\"%s%4d STORE $%lld\", pfx, current,\n\t\t\t\t\t\t\t iptr->isn_arg.number);\n\t\tbreak;\n\t    case ISN_STOREOUTER:\n\t\t{\n\t\tif (iptr->isn_arg.number < 0)\n\t\t    smsg(\"%s%4d STOREOUTEr level %d arg[%d]\", pfx, current,\n\t\t\t    iptr->isn_arg.outer.outer_depth,\n\t\t\t    iptr->isn_arg.outer.outer_idx + STACK_FRAME_SIZE);\n\t\telse\n\t\t    smsg(\"%s%4d STOREOUTER level %d $%d\", pfx, current,\n\t\t\t    iptr->isn_arg.outer.outer_depth,\n\t\t\t    iptr->isn_arg.outer.outer_idx);\n\t\t}\n\t\tbreak;\n\t    case ISN_STOREV:\n\t\tsmsg(\"%s%4d STOREV v:%s\", pfx, current,\n\t\t\t\t       get_vim_var_name(iptr->isn_arg.number));\n\t\tbreak;\n\t    case ISN_STOREAUTO:\n\t\tsmsg(\"%s%4d STOREAUTO %s\", pfx, current, iptr->isn_arg.string);\n\t\tbreak;\n\t    case ISN_STOREG:\n\t\tsmsg(\"%s%4d STOREG %s\", pfx, current, iptr->isn_arg.string);\n\t\tbreak;\n\t    case ISN_STOREB:\n\t\tsmsg(\"%s%4d STOREB %s\", pfx, current, iptr->isn_arg.string);\n\t\tbreak;\n\t    case ISN_STOREW:\n\t\tsmsg(\"%s%4d STOREW %s\", pfx, current, iptr->isn_arg.string);\n\t\tbreak;\n\t    case ISN_STORET:\n\t\tsmsg(\"%s%4d STORET %s\", pfx, current, iptr->isn_arg.string);\n\t\tbreak;\n\t    case ISN_STORES:\n\t\t{\n\t\t    scriptitem_T *si = SCRIPT_ITEM(\n\t\t\t\t\t       iptr->isn_arg.loadstore.ls_sid);\n\n\t\t    smsg(\"%s%4d STORES %s in %s\", pfx, current,\n\t\t\t\t iptr->isn_arg.loadstore.ls_name, si->sn_name);\n\t\t}\n\t\tbreak;\n\t    case ISN_STORESCRIPT:\n\t\t{\n\t\t    scriptref_T\t    *sref = iptr->isn_arg.script.scriptref;\n\t\t    scriptitem_T    *si = SCRIPT_ITEM(sref->sref_sid);\n\t\t    svar_T\t    *sv;\n\n\t\t    sv = get_script_svar(sref, -1);\n\t\t    if (sv == NULL)\n\t\t\tsmsg(\"%s%4d STORESCRIPT [deleted] in %s\",\n\t\t\t\t\t\t    pfx, current, si->sn_name);\n\t\t    else\n\t\t\tsmsg(\"%s%4d STORESCRIPT %s-%d in %s\", pfx, current,\n\t\t\t\t\t     sv->sv_name,\n\t\t\t\t\t     sref->sref_idx,\n\t\t\t\t\t     si->sn_name);\n\t\t}\n\t\tbreak;\n\t    case ISN_STOREOPT:\n\t    case ISN_STOREFUNCOPT:\n\t\tsmsg(\"%s%4d %s &%s\", pfx, current,\n\t\t  iptr->isn_type == ISN_STOREOPT ? \"STOREOPT\" : \"STOREFUNCOPT\",\n\t\t\t\t\t       iptr->isn_arg.storeopt.so_name);\n\t\tbreak;\n\t    case ISN_STOREENV:\n\t\tsmsg(\"%s%4d STOREENV $%s\", pfx, current, iptr->isn_arg.string);\n\t\tbreak;\n\t    case ISN_STOREREG:\n\t\tsmsg(\"%s%4d STOREREG @%c\", pfx, current,\n\t\t\t\t\t\t    (int)iptr->isn_arg.number);\n\t\tbreak;\n\t    case ISN_STORENR:\n\t\tsmsg(\"%s%4d STORE %lld in $%d\", pfx, current,\n\t\t\t\tiptr->isn_arg.storenr.stnr_val,\n\t\t\t\tiptr->isn_arg.storenr.stnr_idx);\n\t\tbreak;\n\n\t    case ISN_STOREINDEX:\n\t\tsmsg(\"%s%4d STOREINDEX %s\", pfx, current,\n\t\t\t\t\t  vartype_name(iptr->isn_arg.vartype));\n\t\tbreak;\n\n\t    case ISN_STORERANGE:\n\t\tsmsg(\"%s%4d STORERANGE\", pfx, current);\n\t\tbreak;\n\n\t    // constants\n\t    case ISN_PUSHNR:\n\t\tsmsg(\"%s%4d PUSHNR %lld\", pfx, current,\n\t\t\t\t\t    (varnumber_T)(iptr->isn_arg.number));\n\t\tbreak;\n\t    case ISN_PUSHBOOL:\n\t    case ISN_PUSHSPEC:\n\t\tsmsg(\"%s%4d PUSH %s\", pfx, current,\n\t\t\t\t   get_var_special_name(iptr->isn_arg.number));\n\t\tbreak;\n\t    case ISN_PUSHF:\n#ifdef FEAT_FLOAT\n\t\tsmsg(\"%s%4d PUSHF %g\", pfx, current, iptr->isn_arg.fnumber);\n#endif\n\t\tbreak;\n\t    case ISN_PUSHS:\n\t\tsmsg(\"%s%4d PUSHS \\\"%s\\\"\", pfx, current, iptr->isn_arg.string);\n\t\tbreak;\n\t    case ISN_PUSHBLOB:\n\t\t{\n\t\t    char_u\t*r;\n\t\t    char_u\tnumbuf[NUMBUFLEN];\n\t\t    char_u\t*tofree;\n\n\t\t    r = blob2string(iptr->isn_arg.blob, &tofree, numbuf);\n\t\t    smsg(\"%s%4d PUSHBLOB %s\", pfx, current, r);\n\t\t    vim_free(tofree);\n\t\t}\n\t\tbreak;\n\t    case ISN_PUSHFUNC:\n\t\t{\n\t\t    char *name = (char *)iptr->isn_arg.string;\n\n\t\t    smsg(\"%s%4d PUSHFUNC \\\"%s\\\"\", pfx, current,\n\t\t\t\t\t       name == NULL ? \"[none]\" : name);\n\t\t}\n\t\tbreak;\n\t    case ISN_PUSHCHANNEL:\n#ifdef FEAT_JOB_CHANNEL\n\t\t{\n\t\t    channel_T *channel = iptr->isn_arg.channel;\n\n\t\t    smsg(\"%s%4d PUSHCHANNEL %d\", pfx, current,\n\t\t\t\t\t channel == NULL ? 0 : channel->ch_id);\n\t\t}\n#endif\n\t\tbreak;\n\t    case ISN_PUSHJOB:\n#ifdef FEAT_JOB_CHANNEL\n\t\t{\n\t\t    typval_T\ttv;\n\t\t    char_u\t*name;\n\t\t    char_u\tbuf[NUMBUFLEN];\n\n\t\t    tv.v_type = VAR_JOB;\n\t\t    tv.vval.v_job = iptr->isn_arg.job;\n\t\t    name = job_to_string_buf(&tv, buf);\n\t\t    smsg(\"%s%4d PUSHJOB \\\"%s\\\"\", pfx, current, name);\n\t\t}\n#endif\n\t\tbreak;\n\t    case ISN_PUSHEXC:\n\t\tsmsg(\"%s%4d PUSH v:exception\", pfx, current);\n\t\tbreak;\n\t    case ISN_UNLET:\n\t\tsmsg(\"%s%4d UNLET%s %s\", pfx, current,\n\t\t\tiptr->isn_arg.unlet.ul_forceit ? \"!\" : \"\",\n\t\t\tiptr->isn_arg.unlet.ul_name);\n\t\tbreak;\n\t    case ISN_UNLETENV:\n\t\tsmsg(\"%s%4d UNLETENV%s $%s\", pfx, current,\n\t\t\tiptr->isn_arg.unlet.ul_forceit ? \"!\" : \"\",\n\t\t\tiptr->isn_arg.unlet.ul_name);\n\t\tbreak;\n\t    case ISN_UNLETINDEX:\n\t\tsmsg(\"%s%4d UNLETINDEX\", pfx, current);\n\t\tbreak;\n\t    case ISN_UNLETRANGE:\n\t\tsmsg(\"%s%4d UNLETRANGE\", pfx, current);\n\t\tbreak;\n\t    case ISN_LOCKUNLOCK:\n\t\tsmsg(\"%s%4d LOCKUNLOCK %s\", pfx, current, iptr->isn_arg.string);\n\t\tbreak;\n\t    case ISN_LOCKCONST:\n\t\tsmsg(\"%s%4d LOCKCONST\", pfx, current);\n\t\tbreak;\n\t    case ISN_NEWLIST:\n\t\tsmsg(\"%s%4d NEWLIST size %lld\", pfx, current,\n\t\t\t\t\t    (varnumber_T)(iptr->isn_arg.number));\n\t\tbreak;\n\t    case ISN_NEWDICT:\n\t\tsmsg(\"%s%4d NEWDICT size %lld\", pfx, current,\n\t\t\t\t\t    (varnumber_T)(iptr->isn_arg.number));\n\t\tbreak;\n\n\t    // function call\n\t    case ISN_BCALL:\n\t\t{\n\t\t    cbfunc_T\t*cbfunc = &iptr->isn_arg.bfunc;\n\n\t\t    smsg(\"%s%4d BCALL %s(argc %d)\", pfx, current,\n\t\t\t    internal_func_name(cbfunc->cbf_idx),\n\t\t\t    cbfunc->cbf_argcount);\n\t\t}\n\t\tbreak;\n\t    case ISN_DCALL:\n\t\t{\n\t\t    cdfunc_T\t*cdfunc = &iptr->isn_arg.dfunc;\n\t\t    dfunc_T\t*df = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t     + cdfunc->cdf_idx;\n\n\t\t    smsg(\"%s%4d DCALL %s(argc %d)\", pfx, current,\n\t\t\t\t\t    printable_func_name(df->df_ufunc),\n\t\t\t\t\t\t\t cdfunc->cdf_argcount);\n\t\t}\n\t\tbreak;\n\t    case ISN_UCALL:\n\t\t{\n\t\t    cufunc_T\t*cufunc = &iptr->isn_arg.ufunc;\n\n\t\t    smsg(\"%s%4d UCALL %s(argc %d)\", pfx, current,\n\t\t\t\t       cufunc->cuf_name, cufunc->cuf_argcount);\n\t\t}\n\t\tbreak;\n\t    case ISN_PCALL:\n\t\t{\n\t\t    cpfunc_T\t*cpfunc = &iptr->isn_arg.pfunc;\n\n\t\t    smsg(\"%s%4d PCALL%s (argc %d)\", pfx, current,\n\t\t\t   cpfunc->cpf_top ? \" top\" : \"\", cpfunc->cpf_argcount);\n\t\t}\n\t\tbreak;\n\t    case ISN_PCALL_END:\n\t\tsmsg(\"%s%4d PCALL end\", pfx, current);\n\t\tbreak;\n\t    case ISN_RETURN:\n\t\tsmsg(\"%s%4d RETURN\", pfx, current);\n\t\tbreak;\n\t    case ISN_RETURN_VOID:\n\t\tsmsg(\"%s%4d RETURN void\", pfx, current);\n\t\tbreak;\n\t    case ISN_FUNCREF:\n\t\t{\n\t\t    funcref_T\t*funcref = &iptr->isn_arg.funcref;\n\t\t    char_u\t*name;\n\n\t\t    if (funcref->fr_func_name == NULL)\n\t\t    {\n\t\t\tdfunc_T\t*df = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t       + funcref->fr_dfunc_idx;\n\t\t\tname = df->df_ufunc->uf_name;\n\t\t    }\n\t\t    else\n\t\t\tname = funcref->fr_func_name;\n\t\t    smsg(\"%s%4d FUNCREF %s\", pfx, current, name);\n\t\t}\n\t\tbreak;\n\n\t    case ISN_NEWFUNC:\n\t\t{\n\t\t    newfunc_T\t*newfunc = &iptr->isn_arg.newfunc;\n\n\t\t    smsg(\"%s%4d NEWFUNC %s %s\", pfx, current,\n\t\t\t\t       newfunc->nf_lambda, newfunc->nf_global);\n\t\t}\n\t\tbreak;\n\n\t    case ISN_DEF:\n\t\t{\n\t\t    char_u *name = iptr->isn_arg.string;\n\n\t\t    smsg(\"%s%4d DEF %s\", pfx, current,\n\t\t\t\t\t   name == NULL ? (char_u *)\"\" : name);\n\t\t}\n\t\tbreak;\n\n\t    case ISN_JUMP:\n\t\t{\n\t\t    char *when = \"?\";\n\n\t\t    switch (iptr->isn_arg.jump.jump_when)\n\t\t    {\n\t\t\tcase JUMP_ALWAYS:\n\t\t\t    when = \"JUMP\";\n\t\t\t    break;\n\t\t\tcase JUMP_NEVER:\n\t\t\t    iemsg(\"JUMP_NEVER should not be used\");\n\t\t\t    break;\n\t\t\tcase JUMP_AND_KEEP_IF_TRUE:\n\t\t\t    when = \"JUMP_AND_KEEP_IF_TRUE\";\n\t\t\t    break;\n\t\t\tcase JUMP_IF_FALSE:\n\t\t\t    when = \"JUMP_IF_FALSE\";\n\t\t\t    break;\n\t\t\tcase JUMP_AND_KEEP_IF_FALSE:\n\t\t\t    when = \"JUMP_AND_KEEP_IF_FALSE\";\n\t\t\t    break;\n\t\t\tcase JUMP_IF_COND_FALSE:\n\t\t\t    when = \"JUMP_IF_COND_FALSE\";\n\t\t\t    break;\n\t\t\tcase JUMP_IF_COND_TRUE:\n\t\t\t    when = \"JUMP_IF_COND_TRUE\";\n\t\t\t    break;\n\t\t    }\n\t\t    smsg(\"%s%4d %s -> %d\", pfx, current, when,\n\t\t\t\t\t\tiptr->isn_arg.jump.jump_where);\n\t\t}\n\t\tbreak;\n\n\t    case ISN_JUMP_IF_ARG_SET:\n\t\tsmsg(\"%s%4d JUMP_IF_ARG_SET arg[%d] -> %d\", pfx, current,\n\t\t\t iptr->isn_arg.jumparg.jump_arg_off + STACK_FRAME_SIZE,\n\t\t\t\t\t\tiptr->isn_arg.jump.jump_where);\n\t\tbreak;\n\n\t    case ISN_FOR:\n\t\t{\n\t\t    forloop_T *forloop = &iptr->isn_arg.forloop;\n\n\t\t    smsg(\"%s%4d FOR $%d -> %d\", pfx, current,\n\t\t\t\t\t   forloop->for_idx, forloop->for_end);\n\t\t}\n\t\tbreak;\n\n\t    case ISN_TRY:\n\t\t{\n\t\t    try_T *try = &iptr->isn_arg.tryref;\n\n\t\t    if (try->try_ref->try_finally == 0)\n\t\t\tsmsg(\"%s%4d TRY catch -> %d, endtry -> %d\",\n\t\t\t\tpfx, current,\n\t\t\t\ttry->try_ref->try_catch,\n\t\t\t\ttry->try_ref->try_endtry);\n\t\t    else\n\t\t\tsmsg(\"%s%4d TRY catch -> %d, finally -> %d, endtry -> %d\",\n\t\t\t\tpfx, current,\n\t\t\t\ttry->try_ref->try_catch,\n\t\t\t\ttry->try_ref->try_finally,\n\t\t\t\ttry->try_ref->try_endtry);\n\t\t}\n\t\tbreak;\n\t    case ISN_CATCH:\n\t\tsmsg(\"%s%4d CATCH\", pfx, current);\n\t\tbreak;\n\t    case ISN_TRYCONT:\n\t\t{\n\t\t    trycont_T *trycont = &iptr->isn_arg.trycont;\n\n\t\t    smsg(\"%s%4d TRY-CONTINUE %d level%s -> %d\", pfx, current,\n\t\t\t\t      trycont->tct_levels,\n\t\t\t\t      trycont->tct_levels == 1 ? \"\" : \"s\",\n\t\t\t\t      trycont->tct_where);\n\t\t}\n\t\tbreak;\n\t    case ISN_FINALLY:\n\t\tsmsg(\"%s%4d FINALLY\", pfx, current);\n\t\tbreak;\n\t    case ISN_ENDTRY:\n\t\tsmsg(\"%s%4d ENDTRY\", pfx, current);\n\t\tbreak;\n\t    case ISN_THROW:\n\t\tsmsg(\"%s%4d THROW\", pfx, current);\n\t\tbreak;\n\n\t    // expression operations on number\n\t    case ISN_OPNR:\n\t    case ISN_OPFLOAT:\n\t    case ISN_OPANY:\n\t\t{\n\t\t    char *what;\n\t\t    char *ins;\n\n\t\t    switch (iptr->isn_arg.op.op_type)\n\t\t    {\n\t\t\tcase EXPR_MULT: what = \"*\"; break;\n\t\t\tcase EXPR_DIV: what = \"/\"; break;\n\t\t\tcase EXPR_REM: what = \"%\"; break;\n\t\t\tcase EXPR_SUB: what = \"-\"; break;\n\t\t\tcase EXPR_ADD: what = \"+\"; break;\n\t\t\tdefault:       what = \"???\"; break;\n\t\t    }\n\t\t    switch (iptr->isn_type)\n\t\t    {\n\t\t\tcase ISN_OPNR: ins = \"OPNR\"; break;\n\t\t\tcase ISN_OPFLOAT: ins = \"OPFLOAT\"; break;\n\t\t\tcase ISN_OPANY: ins = \"OPANY\"; break;\n\t\t\tdefault: ins = \"???\"; break;\n\t\t    }\n\t\t    smsg(\"%s%4d %s %s\", pfx, current, ins, what);\n\t\t}\n\t\tbreak;\n\n\t    case ISN_COMPAREBOOL:\n\t    case ISN_COMPARESPECIAL:\n\t    case ISN_COMPARENR:\n\t    case ISN_COMPAREFLOAT:\n\t    case ISN_COMPARESTRING:\n\t    case ISN_COMPAREBLOB:\n\t    case ISN_COMPARELIST:\n\t    case ISN_COMPAREDICT:\n\t    case ISN_COMPAREFUNC:\n\t    case ISN_COMPAREANY:\n\t\t   {\n\t\t       char *p;\n\t\t       char buf[10];\n\t\t       char *type;\n\n\t\t       switch (iptr->isn_arg.op.op_type)\n\t\t       {\n\t\t\t   case EXPR_EQUAL:\t p = \"==\"; break;\n\t\t\t   case EXPR_NEQUAL:    p = \"!=\"; break;\n\t\t\t   case EXPR_GREATER:   p = \">\"; break;\n\t\t\t   case EXPR_GEQUAL:    p = \">=\"; break;\n\t\t\t   case EXPR_SMALLER:   p = \"<\"; break;\n\t\t\t   case EXPR_SEQUAL:    p = \"<=\"; break;\n\t\t\t   case EXPR_MATCH:\t p = \"=~\"; break;\n\t\t\t   case EXPR_IS:\t p = \"is\"; break;\n\t\t\t   case EXPR_ISNOT:\t p = \"isnot\"; break;\n\t\t\t   case EXPR_NOMATCH:\t p = \"!~\"; break;\n\t\t\t   default:  p = \"???\"; break;\n\t\t       }\n\t\t       STRCPY(buf, p);\n\t\t       if (iptr->isn_arg.op.op_ic == TRUE)\n\t\t\t   strcat(buf, \"?\");\n\t\t       switch(iptr->isn_type)\n\t\t       {\n\t\t\t   case ISN_COMPAREBOOL: type = \"COMPAREBOOL\"; break;\n\t\t\t   case ISN_COMPARESPECIAL:\n\t\t\t\t\t\t type = \"COMPARESPECIAL\"; break;\n\t\t\t   case ISN_COMPARENR: type = \"COMPARENR\"; break;\n\t\t\t   case ISN_COMPAREFLOAT: type = \"COMPAREFLOAT\"; break;\n\t\t\t   case ISN_COMPARESTRING:\n\t\t\t\t\t\t  type = \"COMPARESTRING\"; break;\n\t\t\t   case ISN_COMPAREBLOB: type = \"COMPAREBLOB\"; break;\n\t\t\t   case ISN_COMPARELIST: type = \"COMPARELIST\"; break;\n\t\t\t   case ISN_COMPAREDICT: type = \"COMPAREDICT\"; break;\n\t\t\t   case ISN_COMPAREFUNC: type = \"COMPAREFUNC\"; break;\n\t\t\t   case ISN_COMPAREANY: type = \"COMPAREANY\"; break;\n\t\t\t   default: type = \"???\"; break;\n\t\t       }\n\n\t\t       smsg(\"%s%4d %s %s\", pfx, current, type, buf);\n\t\t   }\n\t\t   break;\n\n\t    case ISN_ADDLIST: smsg(\"%s%4d ADDLIST\", pfx, current); break;\n\t    case ISN_ADDBLOB: smsg(\"%s%4d ADDBLOB\", pfx, current); break;\n\n\t    // expression operations\n\t    case ISN_CONCAT: smsg(\"%s%4d CONCAT\", pfx, current); break;\n\t    case ISN_STRINDEX: smsg(\"%s%4d STRINDEX\", pfx, current); break;\n\t    case ISN_STRSLICE: smsg(\"%s%4d STRSLICE\", pfx, current); break;\n\t    case ISN_BLOBINDEX: smsg(\"%s%4d BLOBINDEX\", pfx, current); break;\n\t    case ISN_BLOBSLICE: smsg(\"%s%4d BLOBSLICE\", pfx, current); break;\n\t    case ISN_LISTAPPEND: smsg(\"%s%4d LISTAPPEND\", pfx, current); break;\n\t    case ISN_BLOBAPPEND: smsg(\"%s%4d BLOBAPPEND\", pfx, current); break;\n\t    case ISN_LISTINDEX: smsg(\"%s%4d LISTINDEX\", pfx, current); break;\n\t    case ISN_LISTSLICE: smsg(\"%s%4d LISTSLICE\", pfx, current); break;\n\t    case ISN_ANYINDEX: smsg(\"%s%4d ANYINDEX\", pfx, current); break;\n\t    case ISN_ANYSLICE: smsg(\"%s%4d ANYSLICE\", pfx, current); break;\n\t    case ISN_SLICE: smsg(\"%s%4d SLICE %lld\",\n\t\t\t\t    pfx, current, iptr->isn_arg.number); break;\n\t    case ISN_GETITEM: smsg(\"%s%4d ITEM %lld%s\", pfx, current,\n\t\t\t\t\t iptr->isn_arg.getitem.gi_index,\n\t\t\t\t\t iptr->isn_arg.getitem.gi_with_op ?\n\t\t\t\t\t\t       \" with op\" : \"\"); break;\n\t    case ISN_MEMBER: smsg(\"%s%4d MEMBER\", pfx, current); break;\n\t    case ISN_STRINGMEMBER: smsg(\"%s%4d MEMBER %s\", pfx, current,\n\t\t\t\t\t\t  iptr->isn_arg.string); break;\n\t    case ISN_CLEARDICT: smsg(\"%s%4d CLEARDICT\", pfx, current); break;\n\t    case ISN_USEDICT: smsg(\"%s%4d USEDICT\", pfx, current); break;\n\n\t    case ISN_NEGATENR: smsg(\"%s%4d NEGATENR\", pfx, current); break;\n\n\t    case ISN_CHECKNR: smsg(\"%s%4d CHECKNR\", pfx, current); break;\n\t    case ISN_CHECKTYPE:\n\t\t  {\n\t\t      checktype_T *ct = &iptr->isn_arg.type;\n\t\t      char *tofree;\n\n\t\t      if (ct->ct_arg_idx == 0)\n\t\t\t  smsg(\"%s%4d CHECKTYPE %s stack[%d]\", pfx, current,\n\t\t\t\t\t  type_name(ct->ct_type, &tofree),\n\t\t\t\t\t  (int)ct->ct_off);\n\t\t      else\n\t\t\t  smsg(\"%s%4d CHECKTYPE %s stack[%d] arg %d\",\n\t\t\t\t\t  pfx, current,\n\t\t\t\t\t  type_name(ct->ct_type, &tofree),\n\t\t\t\t\t  (int)ct->ct_off,\n\t\t\t\t\t  (int)ct->ct_arg_idx);\n\t\t      vim_free(tofree);\n\t\t      break;\n\t\t  }\n\t    case ISN_CHECKLEN: smsg(\"%s%4d CHECKLEN %s%d\", pfx, current,\n\t\t\t\tiptr->isn_arg.checklen.cl_more_OK ? \">= \" : \"\",\n\t\t\t\tiptr->isn_arg.checklen.cl_min_len);\n\t\t\t       break;\n\t    case ISN_SETTYPE:\n\t\t  {\n\t\t      char *tofree;\n\n\t\t      smsg(\"%s%4d SETTYPE %s\", pfx, current,\n\t\t\t      type_name(iptr->isn_arg.type.ct_type, &tofree));\n\t\t      vim_free(tofree);\n\t\t      break;\n\t\t  }\n\t    case ISN_COND2BOOL: smsg(\"%s%4d COND2BOOL\", pfx, current); break;\n\t    case ISN_2BOOL: if (iptr->isn_arg.tobool.invert)\n\t\t\t\tsmsg(\"%s%4d INVERT %d (!val)\", pfx, current,\n\t\t\t\t\t iptr->isn_arg.tobool.offset);\n\t\t\t    else\n\t\t\t\tsmsg(\"%s%4d 2BOOL %d (!!val)\", pfx, current,\n\t\t\t\t\t iptr->isn_arg.tobool.offset);\n\t\t\t    break;\n\t    case ISN_2STRING: smsg(\"%s%4d 2STRING stack[%lld]\", pfx, current,\n\t\t\t\t (varnumber_T)(iptr->isn_arg.tostring.offset));\n\t\t\t      break;\n\t    case ISN_2STRING_ANY: smsg(\"%s%4d 2STRING_ANY stack[%lld]\",\n\t\t\t\t\t\t\t\t  pfx, current,\n\t\t\t\t (varnumber_T)(iptr->isn_arg.tostring.offset));\n\t\t\t      break;\n\t    case ISN_RANGE: smsg(\"%s%4d RANGE %s\", pfx, current,\n\t\t\t\t\t\t\t iptr->isn_arg.string);\n\t\t\t    break;\n\t    case ISN_PUT:\n\t        if (iptr->isn_arg.put.put_lnum == LNUM_VARIABLE_RANGE_ABOVE)\n\t\t    smsg(\"%s%4d PUT %c above range\",\n\t\t\t\t  pfx, current, iptr->isn_arg.put.put_regname);\n\t\telse if (iptr->isn_arg.put.put_lnum == LNUM_VARIABLE_RANGE)\n\t\t    smsg(\"%s%4d PUT %c range\",\n\t\t\t\t  pfx, current, iptr->isn_arg.put.put_regname);\n\t\telse\n\t\t    smsg(\"%s%4d PUT %c %ld\", pfx, current,\n\t\t\t\t\t\t iptr->isn_arg.put.put_regname,\n\t\t\t\t\t     (long)iptr->isn_arg.put.put_lnum);\n\t\tbreak;\n\n\t    case ISN_CMDMOD:\n\t\t{\n\t\t    char_u  *buf;\n\t\t    size_t  len = produce_cmdmods(\n\t\t\t\t  NULL, iptr->isn_arg.cmdmod.cf_cmdmod, FALSE);\n\n\t\t    buf = alloc(len + 1);\n\t\t    if (likely(buf != NULL))\n\t\t    {\n\t\t\t(void)produce_cmdmods(\n\t\t\t\t   buf, iptr->isn_arg.cmdmod.cf_cmdmod, FALSE);\n\t\t\tsmsg(\"%s%4d CMDMOD %s\", pfx, current, buf);\n\t\t\tvim_free(buf);\n\t\t    }\n\t\t    break;\n\t\t}\n\t    case ISN_CMDMOD_REV: smsg(\"%s%4d CMDMOD_REV\", pfx, current); break;\n\n\t    case ISN_PROF_START:\n\t\t smsg(\"%s%4d PROFILE START line %d\", pfx, current,\n\t\t\t\t\t\t\t       iptr->isn_lnum);\n\t\t break;\n\n\t    case ISN_PROF_END:\n\t\tsmsg(\"%s%4d PROFILE END\", pfx, current);\n\t\tbreak;\n\n\t    case ISN_DEBUG:\n\t\tsmsg(\"%s%4d DEBUG line %d-%d varcount %lld\", pfx, current,\n\t\t\tiptr->isn_arg.debug.dbg_break_lnum + 1,\n\t\t\tiptr->isn_lnum,\n\t\t\tiptr->isn_arg.debug.dbg_var_names_len);\n\t\tbreak;\n\n\t    case ISN_UNPACK: smsg(\"%s%4d UNPACK %d%s\", pfx, current,\n\t\t\tiptr->isn_arg.unpack.unp_count,\n\t\t\tiptr->isn_arg.unpack.unp_semicolon ? \" semicolon\" : \"\");\n\t\t\t      break;\n\t    case ISN_SHUFFLE: smsg(\"%s%4d SHUFFLE %d up %d\", pfx, current,\n\t\t\t\t\t iptr->isn_arg.shuffle.shfl_item,\n\t\t\t\t\t iptr->isn_arg.shuffle.shfl_up);\n\t\t\t      break;\n\t    case ISN_DROP: smsg(\"%s%4d DROP\", pfx, current); break;\n\n\t    case ISN_FINISH: // End of list of instructions for ISN_SUBSTITUTE.\n\t\t\t   return;\n\t}\n\n\tout_flush();\t    // output one line at a time\n\tui_breakcheck();\n\tif (got_int)\n\t    break;\n    }\n}\n\n/*\n * Handle command line completion for the :disassemble command.\n */\n    void\nset_context_in_disassemble_cmd(expand_T *xp, char_u *arg)\n{\n    char_u\t*p;\n\n    // Default: expand user functions, \"debug\" and \"profile\"\n    xp->xp_context = EXPAND_DISASSEMBLE;\n    xp->xp_pattern = arg;\n\n    // first argument already typed: only user function names\n    if (*arg != NUL && *(p = skiptowhite(arg)) != NUL)\n    {\n\txp->xp_context = EXPAND_USER_FUNC;\n\txp->xp_pattern = skipwhite(p);\n    }\n}\n\n/*\n * Function given to ExpandGeneric() to obtain the list of :disassemble\n * arguments.\n */\n    char_u *\nget_disassemble_argument(expand_T *xp, int idx)\n{\n    if (idx == 0)\n\treturn (char_u *)\"debug\";\n    if (idx == 1)\n\treturn (char_u *)\"profile\";\n    return get_user_func_name(xp, idx - 2);\n}\n\n/*\n * \":disassemble\".\n * We don't really need this at runtime, but we do have tests that require it,\n * so always include this.\n */\n    void\nex_disassemble(exarg_T *eap)\n{\n    char_u\t*arg = eap->arg;\n    char_u\t*fname;\n    ufunc_T\t*ufunc;\n    dfunc_T\t*dfunc;\n    isn_T\t*instr;\n    int\t\tinstr_count;\n    int\t\tis_global = FALSE;\n    compiletype_T compile_type = CT_NONE;\n\n    if (STRNCMP(arg, \"profile\", 7) == 0 && VIM_ISWHITE(arg[7]))\n    {\n\tcompile_type = CT_PROFILE;\n\targ = skipwhite(arg + 7);\n    }\n    else if (STRNCMP(arg, \"debug\", 5) == 0 && VIM_ISWHITE(arg[5]))\n    {\n\tcompile_type = CT_DEBUG;\n\targ = skipwhite(arg + 5);\n    }\n\n    if (STRNCMP(arg, \"<lambda>\", 8) == 0)\n    {\n\targ += 8;\n\t(void)getdigits(&arg);\n\tfname = vim_strnsave(eap->arg, arg - eap->arg);\n    }\n    else\n\tfname = trans_function_name(&arg, &is_global, FALSE,\n\t\t      TFN_INT | TFN_QUIET | TFN_NO_AUTOLOAD, NULL, NULL, NULL);\n    if (fname == NULL)\n    {\n\tsemsg(_(e_invarg2), eap->arg);\n\treturn;\n    }\n\n    ufunc = find_func(fname, is_global, NULL);\n    if (ufunc == NULL)\n    {\n\tchar_u *p = untrans_function_name(fname);\n\n\tif (p != NULL)\n\t    // Try again without making it script-local.\n\t    ufunc = find_func(p, FALSE, NULL);\n    }\n    vim_free(fname);\n    if (ufunc == NULL)\n    {\n\tsemsg(_(e_cannot_find_function_str), eap->arg);\n\treturn;\n    }\n    if (func_needs_compiling(ufunc, compile_type)\n\t    && compile_def_function(ufunc, FALSE, compile_type, NULL) == FAIL)\n\treturn;\n    if (ufunc->uf_def_status != UF_COMPILED)\n    {\n\tsemsg(_(e_function_is_not_compiled_str), eap->arg);\n\treturn;\n    }\n    msg((char *)printable_func_name(ufunc));\n\n    dfunc = ((dfunc_T *)def_functions.ga_data) + ufunc->uf_dfunc_idx;\n    switch (compile_type)\n    {\n\tcase CT_PROFILE:\n#ifdef FEAT_PROFILE\n\t    instr = dfunc->df_instr_prof;\n\t    instr_count = dfunc->df_instr_prof_count;\n\t    break;\n#endif\n\t    // FALLTHROUGH\n\tcase CT_NONE:\n\t    instr = dfunc->df_instr;\n\t    instr_count = dfunc->df_instr_count;\n\t    break;\n\tcase CT_DEBUG:\n\t    instr = dfunc->df_instr_debug;\n\t    instr_count = dfunc->df_instr_debug_count;\n\t    break;\n    }\n\n    list_instructions(\"\", instr, instr_count, ufunc);\n}\n\n/*\n * Return TRUE when \"tv\" is not falsy: non-zero, non-empty string, non-empty\n * list, etc.  Mostly like what JavaScript does, except that empty list and\n * empty dictionary are FALSE.\n */\n    int\ntv2bool(typval_T *tv)\n{\n    switch (tv->v_type)\n    {\n\tcase VAR_NUMBER:\n\t    return tv->vval.v_number != 0;\n\tcase VAR_FLOAT:\n#ifdef FEAT_FLOAT\n\t    return tv->vval.v_float != 0.0;\n#else\n\t    break;\n#endif\n\tcase VAR_PARTIAL:\n\t    return tv->vval.v_partial != NULL;\n\tcase VAR_FUNC:\n\tcase VAR_STRING:\n\t    return tv->vval.v_string != NULL && *tv->vval.v_string != NUL;\n\tcase VAR_LIST:\n\t    return tv->vval.v_list != NULL && tv->vval.v_list->lv_len > 0;\n\tcase VAR_DICT:\n\t    return tv->vval.v_dict != NULL\n\t\t\t\t    && tv->vval.v_dict->dv_hashtab.ht_used > 0;\n\tcase VAR_BOOL:\n\tcase VAR_SPECIAL:\n\t    return tv->vval.v_number == VVAL_TRUE ? TRUE : FALSE;\n\tcase VAR_JOB:\n#ifdef FEAT_JOB_CHANNEL\n\t    return tv->vval.v_job != NULL;\n#else\n\t    break;\n#endif\n\tcase VAR_CHANNEL:\n#ifdef FEAT_JOB_CHANNEL\n\t    return tv->vval.v_channel != NULL;\n#else\n\t    break;\n#endif\n\tcase VAR_BLOB:\n\t    return tv->vval.v_blob != NULL && tv->vval.v_blob->bv_ga.ga_len > 0;\n\tcase VAR_UNKNOWN:\n\tcase VAR_ANY:\n\tcase VAR_VOID:\n\tcase VAR_INSTR:\n\t    break;\n    }\n    return FALSE;\n}\n\n    void\nemsg_using_string_as(typval_T *tv, int as_number)\n{\n    semsg(_(as_number ? e_using_string_as_number_str\n\t\t\t\t\t\t : e_using_string_as_bool_str),\n\t\t       tv->vval.v_string == NULL\n\t\t\t\t\t   ? (char_u *)\"\" : tv->vval.v_string);\n}\n\n/*\n * If \"tv\" is a string give an error and return FAIL.\n */\n    int\ncheck_not_string(typval_T *tv)\n{\n    if (tv->v_type == VAR_STRING)\n    {\n\temsg_using_string_as(tv, TRUE);\n\tclear_tv(tv);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n\n#endif // FEAT_EVAL\n"], "filenames": ["src/proto/userfunc.pro", "src/testdir/test_vim9_func.vim", "src/userfunc.c", "src/version.c", "src/vim9compile.c", "src/vim9execute.c"], "buggy_code_start_loc": [41, 1669, 723, 751, 815, 3347], "buggy_code_end_loc": [42, 1669, 4680, 751, 2865, 3352], "fixing_code_start_loc": [41, 1670, 722, 752, 815, 3348], "fixing_code_end_loc": [42, 1690, 4686, 754, 2871, 3354], "type": "CWE-416", "message": "vim is vulnerable to Use After Free", "other": {"cve": {"id": "CVE-2021-4173", "sourceIdentifier": "security@huntr.dev", "published": "2021-12-27T13:15:07.653", "lastModified": "2022-11-02T13:18:35.983", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "vim is vulnerable to Use After Free"}, {"lang": "es", "value": "vim es vulnerable a un Uso de Memoria previamente Liberada"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:R/S:U/C:L/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 6.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.3, "impactScore": 5.5}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndExcluding": "8.2.3902", "matchCriteriaId": "59607316-4910-4A3D-8802-27C10D02886D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:apple:mac_os_x:10.15.7:*:*:*:*:*:*:*", "matchCriteriaId": "89161D20-EB9C-4EC0-8D82-75B27CE49264"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:mac_os_x:10.15.7:security_update_2020-001:*:*:*:*:*:*", "matchCriteriaId": "F1F4BF7F-90D4-4668-B4E6-B06F4070F448"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:mac_os_x:10.15.7:security_update_2021-001:*:*:*:*:*:*", "matchCriteriaId": "0F441A43-1669-478D-9EC8-E96882DE4F9F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:mac_os_x:10.15.7:security_update_2021-002:*:*:*:*:*:*", "matchCriteriaId": "D425C653-37A2-448C-BF2F-B684ADB08A26"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:mac_os_x:10.15.7:security_update_2021-003:*:*:*:*:*:*", "matchCriteriaId": "A54D63B7-B92B-47C3-B1C5-9892E5873A98"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:mac_os_x:10.15.7:security_update_2021-004:*:*:*:*:*:*", "matchCriteriaId": "3456176F-9185-4EE2-A8CE-3D989D674AB7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:mac_os_x:10.15.7:security_update_2021-005:*:*:*:*:*:*", "matchCriteriaId": "D337EE21-2F00-484D-9285-F2B0248D7A19"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:mac_os_x:10.15.7:security_update_2021-006:*:*:*:*:*:*", "matchCriteriaId": "012052B5-9AA7-4FD3-9C80-5F615330039D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:mac_os_x:10.15.7:security_update_2021-007:*:*:*:*:*:*", "matchCriteriaId": "50F21A3C-0AC3-48C5-A4F8-5A7B478875B4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:mac_os_x:10.15.7:security_update_2021-008:*:*:*:*:*:*", "matchCriteriaId": "8E974DC6-F7D9-4389-9AF9-863F6E419CE6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:mac_os_x:10.15.7:security_update_2022-001:*:*:*:*:*:*", "matchCriteriaId": "156A6382-2BD3-4882-90B2-8E7CF6659E17"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:mac_os_x:10.15.7:security_update_2022-002:*:*:*:*:*:*", "matchCriteriaId": "20A2FDB2-6712-406A-9896-C0B44508B07D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:mac_os_x:10.15.7:security_update_2022-003:*:*:*:*:*:*", "matchCriteriaId": "49F537A0-DC42-4176-B22F-C80D179DD99D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:macos:*:*:*:*:*:*:*:*", "versionEndExcluding": "12.3", "matchCriteriaId": "9060C1B6-F101-46AE-8B08-6D6951304916"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:macos:*:*:*:*:*:*:*:*", "versionStartIncluding": "11.0", "versionEndExcluding": "11.6.6", "matchCriteriaId": "09A6345C-D813-43BA-B12E-789C80653F86"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:macos:10.15.7:security_update_2022-004:*:*:*:*:*:*", "matchCriteriaId": "D99ACC65-B867-44CC-A6DD-53C7399CA344"}]}]}], "references": [{"url": "http://seclists.org/fulldisclosure/2022/Jul/14", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://seclists.org/fulldisclosure/2022/Mar/29", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://seclists.org/fulldisclosure/2022/May/35", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2022/01/15/1", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/vim/vim/commit/9c23f9bb5fe435b28245ba8ac65aa0ca6b902c04", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/a1b236b9-89fb-4ccf-9689-ba11b471e766", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/2EY2VFBU3YGGWI5BW4XKT3F37MYGEQUD/", "source": "security@huntr.dev", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/3FH2J57GDA2WMBS6J56F6QQRA6BXQQFZ/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202208-32", "source": "security@huntr.dev", "tags": ["Third Party Advisory"]}, {"url": "https://support.apple.com/kb/HT213183", "source": "security@huntr.dev", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://support.apple.com/kb/HT213256", "source": "security@huntr.dev", "tags": ["Third Party Advisory"]}, {"url": "https://support.apple.com/kb/HT213343", "source": "security@huntr.dev", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/vim/vim/commit/9c23f9bb5fe435b28245ba8ac65aa0ca6b902c04"}}