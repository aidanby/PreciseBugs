{"buggy_code": [" /*\n  *  Copyright (c) 2007, 2008, 2009 Andrea Bittau <a.bittau@cs.ucl.ac.uk>\n  *\n  *  This program is free software; you can redistribute it and/or modify\n  *  it under the terms of the GNU General Public License as published by\n  *  the Free Software Foundation; either version 2 of the License, or\n  *  (at your option) any later version.\n  *\n  *  This program is distributed in the hope that it will be useful,\n  *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  *  GNU General Public License for more details.\n  *\n  *  You should have received a copy of the GNU General Public License\n  *  along with this program; if not, write to the Free Software\n  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n  */\n\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <err.h>\n#include <unistd.h>\n#include <string.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <netinet/in_systm.h>\n#include <netinet/ip.h>\n#include <netinet/udp.h>\n#include <assert.h>\n#include <grp.h>\n#include <sys/utsname.h>\n\n#include \"easside.h\"\n#include \"version.h\"\n\nextern char * getVersion(char * progname, int maj, int min, int submin, int svnrev, int beta, int rc);\n\nunsigned char ids[8192];\nunsigned short last_id;\nint wrap;\n\nint is_dup(unsigned short id)\n{\n\tint idx = id/8;\n\tint bit = id % 8;\n\tunsigned char mask = (1 << bit);\n\n\tif (ids[idx] & mask)\n\t\treturn 1;\n\n\tids[idx] |= mask;\n\treturn 0;\n}\n\nint handle(int s, unsigned char* data, int len, struct sockaddr_in *s_in)\n{\n\tchar buf[2048];\n\tunsigned short *cmd = (unsigned short *)buf;\n\tint plen;\n\tstruct in_addr *addr = &s_in->sin_addr;\n\tunsigned short *pid = (unsigned short*) data;\n\n\t/* inet check */\n\tif (len == S_HELLO_LEN && memcmp(data, \"sorbo\", 5) == 0) {\n\t\tunsigned short *id = (unsigned short*) (data+5);\n\t\tint x = 2+4+2;\n\n\t\t*cmd = htons(S_CMD_INET_CHECK);\n\t\tmemcpy(cmd+1, addr, 4);\n\t\tmemcpy(cmd+1+2, id, 2);\n\n\t\tprintf(\"Inet check by %s %d\\n\",\n\t\t       inet_ntoa(*addr), ntohs(*id));\n\t\tif (send(s, buf, x, 0) != x)\n\t\t\treturn 1;\n\n\t\treturn 0;\n\t}\n\n\t*cmd++ = htons(S_CMD_PACKET);\n\t*cmd++ = *pid;\n\tplen = len - 2;\n\n\tlast_id = ntohs(*pid);\n\tif (last_id > 20000)\n\t\twrap = 1;\n\tif (wrap && last_id < 100) {\n\t\twrap = 0;\n\t\tmemset(ids, 0, sizeof(ids));\n\t}\n\n\tprintf(\"Got packet %d %d\", last_id, plen);\n\tif (is_dup(last_id)) {\n\t\tprintf(\" (DUP)\\n\");\n\t\treturn 0;\n\t}\n\tprintf(\"\\n\");\n\n\t*cmd++ = htons(plen);\n\tmemcpy(cmd, data+2, plen);\n\n\tplen += 2 + 2 + 2;\n\tassert(plen <= (int) sizeof(buf));\n\tif (send(s, buf, plen, 0) != plen)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nvoid handle_dude(int dude, int udp)\n{\n\tunsigned char buf[2048];\n\tint rc;\n\tfd_set rfds;\n\tint maxfd;\n\tstruct sockaddr_in s_in;\n\tsocklen_t len;\n\n\t/* handshake */\n\trc = recv(dude, buf, 5, 0);\n\tif (rc != 5) {\n\t\tclose(dude);\n\t\treturn;\n\t}\n\n\tif (memcmp(buf, \"sorbo\", 5) != 0) {\n\t\tclose(dude);\n\t\treturn;\n\t}\n\n\tif (send(dude, \"sorbox\", 6, 0) != 6) {\n\t\tclose(dude);\n\t\treturn;\n\t}\n\n\tprintf(\"Handshake complete\\n\");\n\tmemset(ids, 0, sizeof(ids));\n\tlast_id = 0;\n\twrap = 0;\n\n\twhile (1) {\n\t\tFD_ZERO(&rfds);\n\t\tFD_SET(udp, &rfds);\n\t\tFD_SET(dude, &rfds);\n\n\t\tif (dude > udp)\n\t\t\tmaxfd = dude;\n\t\telse\n\t\t\tmaxfd = udp;\n\n\t\tif (select(maxfd+1, &rfds, NULL, NULL, NULL) == -1)\n\t\t\terr(1, \"select()\");\n\n\t\tif (FD_ISSET(dude, &rfds))\n\t\t\tbreak;\n\n\t\tif (!FD_ISSET(udp, &rfds))\n\t\t\tcontinue;\n\n\t\tlen = sizeof(s_in);\n\t\trc = recvfrom(udp, buf, sizeof(buf), 0,\n\t\t\t      (struct sockaddr*) &s_in, &len);\n\t\tif (rc == -1)\n\t\t\terr(1, \"read()\");\n\n\t\tif (handle(dude, buf, rc, &s_in))\n\t\t\tbreak;\n\t}\n\tclose(dude);\n}\n\nvoid drop_privs()\n{\n\tif (chroot(\".\") == -1)\n\t\terr(1, \"chroot()\");\n\n\tif (setgroups(0, NULL) == -1)\n\t\terr(1, \"setgroups()\");\n\n\tif (setgid(69) == -1)\n\t\terr(1, \"setgid()\");\n\n\tif (setuid(69) == -1)\n\t\terr(1, \"setuid()\");\n}\n\nvoid usage()\n{\n\tprintf(\"\\n\"\n\t\t\"  %s - (C) 2007,2008 Andrea Bittau\\n\"\n\t\t\"  http://www.aircrack-ng.org\\n\"\n\t\t\"\\n\"\n\t\t\"  Usage: buddy-ng <options>\\n\"\n\t\t\"\\n\"\n\t\t\"  Options:\\n\"\n\t\t\"\\n\"\n\t\t\"       -h        : This help screen\\n\"\n\t\t\"       -p        : Don't drop privileges\\n\"\n\t\t\"\\n\",\n\t\tgetVersion(\"Buddy-ng\", _MAJ, _MIN, _SUB_MIN, _REVISION, _BETA, _RC));\n\n\texit(1);\n}\n\nint main(int argc, char *argv[])\n{\n\tstruct utsname utsName;\n\tstruct sockaddr_in s_in;\n\tstruct sockaddr_in dude_sin;\n\tint len, udp, ch, dude, s;\n\tint port = S_DEFAULT_PORT;\n\tint drop;\n\n\twhile ((ch = getopt(argc, argv, \"ph\")) != -1) {\n\t\tswitch (ch) {\n\t\tcase 'p':\n\t\t\tdrop = 0;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\tcase 'h':\n\t\t\tusage();\n\t\t\tbreak;\n\n\t\t}\n\t}\n\n\tmemset(&s_in, 0, sizeof(s_in));\n\ts_in.sin_family = PF_INET;\n\ts_in.sin_addr.s_addr = INADDR_ANY;\n\ts_in.sin_port = htons(S_DEFAULT_UDP_PORT);\n\n\tudp = socket(s_in.sin_family, SOCK_DGRAM, IPPROTO_UDP);\n\tif (udp == -1)\n\t\terr(1, \"socket(UDP)\");\n\tif (bind(udp, (struct sockaddr*) &s_in, sizeof(s_in)) == -1)\n\t\terr(1, \"bind()\");\n\n\ts = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);\n\tif (s == -1)\n\t\terr(1, \"socket(TCP)\");\n\n\tdrop = 1;\n\n\t// Do not drop privileges on Windows (doing it fails).\n\tif (uname(&utsName) == 0)\n\t{\n\t\tdrop = strncasecmp(utsName.sysname, \"cygwin\", 6);\n\t}\n\n\tif (drop)\n\t\tdrop_privs();\n\n\tmemset(&s_in, 0, sizeof(s_in));\n\ts_in.sin_family = PF_INET;\n\ts_in.sin_port = htons(port);\n\ts_in.sin_addr.s_addr = INADDR_ANY;\n\n\tlen = 1;\n\tif (setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &len, sizeof(len)) == -1)\n\t\terr(1, \"setsockopt(SO_REUSEADDR)\");\n\n\tif (bind(s, (struct sockaddr*) &s_in, sizeof(s_in)) == -1)\n\t\terr(1, \"bind()\");\n\n\tif (listen(s, 5) == -1)\n\t\terr(1, \"listen()\");\n\n\n\twhile (1) {\n\t\tlen = sizeof(dude_sin);\n\t\tprintf(\"Waiting for connexion\\n\");\n\t\tdude = accept(s, (struct sockaddr*) &dude_sin,\n\t\t\t      (socklen_t*) &len);\n\t\tif (dude == -1)\n\t\t\terr(1, \"accept()\");\n\n\t\tprintf(\"Got connection from %s\\n\",\n\t\t       inet_ntoa(dude_sin.sin_addr));\n\t\thandle_dude(dude, udp);\n\t\tprintf(\"That was it\\n\");\n\t}\n\texit(0);\n}\n"], "fixing_code": [" /*\n  *  Copyright (c) 2007, 2008, 2009 Andrea Bittau <a.bittau@cs.ucl.ac.uk>\n  *\n  *  This program is free software; you can redistribute it and/or modify\n  *  it under the terms of the GNU General Public License as published by\n  *  the Free Software Foundation; either version 2 of the License, or\n  *  (at your option) any later version.\n  *\n  *  This program is distributed in the hope that it will be useful,\n  *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  *  GNU General Public License for more details.\n  *\n  *  You should have received a copy of the GNU General Public License\n  *  along with this program; if not, write to the Free Software\n  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n  */\n\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <err.h>\n#include <unistd.h>\n#include <string.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <netinet/in_systm.h>\n#include <netinet/ip.h>\n#include <netinet/udp.h>\n#include <assert.h>\n#include <grp.h>\n#include <sys/utsname.h>\n\n#include \"easside.h\"\n#include \"version.h\"\n\nextern char * getVersion(char * progname, int maj, int min, int submin, int svnrev, int beta, int rc);\n\nunsigned char ids[8192];\nunsigned short last_id;\nint wrap;\n\nint is_dup(unsigned short id)\n{\n\tint idx = id/8;\n\tint bit = id % 8;\n\tunsigned char mask = (1 << bit);\n\n\tif (ids[idx] & mask)\n\t\treturn 1;\n\n\tids[idx] |= mask;\n\treturn 0;\n}\n\nint handle(int s, unsigned char* data, int len, struct sockaddr_in *s_in)\n{\n\tchar buf[2048];\n\tunsigned short *cmd = (unsigned short *)buf;\n\tint plen;\n\tstruct in_addr *addr = &s_in->sin_addr;\n\tunsigned short *pid = (unsigned short*) data;\n\n\t/* inet check */\n\tif (len == S_HELLO_LEN && memcmp(data, \"sorbo\", 5) == 0) {\n\t\tunsigned short *id = (unsigned short*) (data+5);\n\t\tint x = 2+4+2;\n\n\t\t*cmd = htons(S_CMD_INET_CHECK);\n\t\tmemcpy(cmd+1, addr, 4);\n\t\tmemcpy(cmd+1+2, id, 2);\n\n\t\tprintf(\"Inet check by %s %d\\n\",\n\t\t       inet_ntoa(*addr), ntohs(*id));\n\t\tif (send(s, buf, x, 0) != x)\n\t\t\treturn 1;\n\n\t\treturn 0;\n\t}\n\n\t*cmd++ = htons(S_CMD_PACKET);\n\t*cmd++ = *pid;\n\tplen = len - 2;\n    if (plen < 0)\n        return 0;\n\n\tlast_id = ntohs(*pid);\n\tif (last_id > 20000)\n\t\twrap = 1;\n\tif (wrap && last_id < 100) {\n\t\twrap = 0;\n\t\tmemset(ids, 0, sizeof(ids));\n\t}\n\n\tprintf(\"Got packet %d %d\", last_id, plen);\n\tif (is_dup(last_id)) {\n\t\tprintf(\" (DUP)\\n\");\n\t\treturn 0;\n\t}\n\tprintf(\"\\n\");\n\n\t*cmd++ = htons(plen);\n\tmemcpy(cmd, data+2, plen);\n\n\tplen += 2 + 2 + 2;\n\tassert(plen <= (int) sizeof(buf));\n\tif (send(s, buf, plen, 0) != plen)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nvoid handle_dude(int dude, int udp)\n{\n\tunsigned char buf[2048];\n\tint rc;\n\tfd_set rfds;\n\tint maxfd;\n\tstruct sockaddr_in s_in;\n\tsocklen_t len;\n\n\t/* handshake */\n\trc = recv(dude, buf, 5, 0);\n\tif (rc != 5) {\n\t\tclose(dude);\n\t\treturn;\n\t}\n\n\tif (memcmp(buf, \"sorbo\", 5) != 0) {\n\t\tclose(dude);\n\t\treturn;\n\t}\n\n\tif (send(dude, \"sorbox\", 6, 0) != 6) {\n\t\tclose(dude);\n\t\treturn;\n\t}\n\n\tprintf(\"Handshake complete\\n\");\n\tmemset(ids, 0, sizeof(ids));\n\tlast_id = 0;\n\twrap = 0;\n\n\twhile (1) {\n\t\tFD_ZERO(&rfds);\n\t\tFD_SET(udp, &rfds);\n\t\tFD_SET(dude, &rfds);\n\n\t\tif (dude > udp)\n\t\t\tmaxfd = dude;\n\t\telse\n\t\t\tmaxfd = udp;\n\n\t\tif (select(maxfd+1, &rfds, NULL, NULL, NULL) == -1)\n\t\t\terr(1, \"select()\");\n\n\t\tif (FD_ISSET(dude, &rfds))\n\t\t\tbreak;\n\n\t\tif (!FD_ISSET(udp, &rfds))\n\t\t\tcontinue;\n\n\t\tlen = sizeof(s_in);\n\t\trc = recvfrom(udp, buf, sizeof(buf), 0,\n\t\t\t      (struct sockaddr*) &s_in, &len);\n\t\tif (rc == -1)\n\t\t\terr(1, \"read()\");\n\n\t\tif (handle(dude, buf, rc, &s_in))\n\t\t\tbreak;\n\t}\n\tclose(dude);\n}\n\nvoid drop_privs()\n{\n\tif (chroot(\".\") == -1)\n\t\terr(1, \"chroot()\");\n\n\tif (setgroups(0, NULL) == -1)\n\t\terr(1, \"setgroups()\");\n\n\tif (setgid(69) == -1)\n\t\terr(1, \"setgid()\");\n\n\tif (setuid(69) == -1)\n\t\terr(1, \"setuid()\");\n}\n\nvoid usage()\n{\n\tprintf(\"\\n\"\n\t\t\"  %s - (C) 2007,2008 Andrea Bittau\\n\"\n\t\t\"  http://www.aircrack-ng.org\\n\"\n\t\t\"\\n\"\n\t\t\"  Usage: buddy-ng <options>\\n\"\n\t\t\"\\n\"\n\t\t\"  Options:\\n\"\n\t\t\"\\n\"\n\t\t\"       -h        : This help screen\\n\"\n\t\t\"       -p        : Don't drop privileges\\n\"\n\t\t\"\\n\",\n\t\tgetVersion(\"Buddy-ng\", _MAJ, _MIN, _SUB_MIN, _REVISION, _BETA, _RC));\n\n\texit(1);\n}\n\nint main(int argc, char *argv[])\n{\n\tstruct utsname utsName;\n\tstruct sockaddr_in s_in;\n\tstruct sockaddr_in dude_sin;\n\tint len, udp, ch, dude, s;\n\tint port = S_DEFAULT_PORT;\n\tint drop;\n\n\twhile ((ch = getopt(argc, argv, \"ph\")) != -1) {\n\t\tswitch (ch) {\n\t\tcase 'p':\n\t\t\tdrop = 0;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\tcase 'h':\n\t\t\tusage();\n\t\t\tbreak;\n\n\t\t}\n\t}\n\n\tmemset(&s_in, 0, sizeof(s_in));\n\ts_in.sin_family = PF_INET;\n\ts_in.sin_addr.s_addr = INADDR_ANY;\n\ts_in.sin_port = htons(S_DEFAULT_UDP_PORT);\n\n\tudp = socket(s_in.sin_family, SOCK_DGRAM, IPPROTO_UDP);\n\tif (udp == -1)\n\t\terr(1, \"socket(UDP)\");\n\tif (bind(udp, (struct sockaddr*) &s_in, sizeof(s_in)) == -1)\n\t\terr(1, \"bind()\");\n\n\ts = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);\n\tif (s == -1)\n\t\terr(1, \"socket(TCP)\");\n\n\tdrop = 1;\n\n\t// Do not drop privileges on Windows (doing it fails).\n\tif (uname(&utsName) == 0)\n\t{\n\t\tdrop = strncasecmp(utsName.sysname, \"cygwin\", 6);\n\t}\n\n\tif (drop)\n\t\tdrop_privs();\n\n\tmemset(&s_in, 0, sizeof(s_in));\n\ts_in.sin_family = PF_INET;\n\ts_in.sin_port = htons(port);\n\ts_in.sin_addr.s_addr = INADDR_ANY;\n\n\tlen = 1;\n\tif (setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &len, sizeof(len)) == -1)\n\t\terr(1, \"setsockopt(SO_REUSEADDR)\");\n\n\tif (bind(s, (struct sockaddr*) &s_in, sizeof(s_in)) == -1)\n\t\terr(1, \"bind()\");\n\n\tif (listen(s, 5) == -1)\n\t\terr(1, \"listen()\");\n\n\n\twhile (1) {\n\t\tlen = sizeof(dude_sin);\n\t\tprintf(\"Waiting for connexion\\n\");\n\t\tdude = accept(s, (struct sockaddr*) &dude_sin,\n\t\t\t      (socklen_t*) &len);\n\t\tif (dude == -1)\n\t\t\terr(1, \"accept()\");\n\n\t\tprintf(\"Got connection from %s\\n\",\n\t\t       inet_ntoa(dude_sin.sin_addr));\n\t\thandle_dude(dude, udp);\n\t\tprintf(\"That was it\\n\");\n\t}\n\texit(0);\n}\n"], "filenames": ["src/buddy-ng.c"], "buggy_code_start_loc": [85], "buggy_code_end_loc": [85], "fixing_code_start_loc": [86], "fixing_code_end_loc": [88], "type": "CWE-20", "message": "buddy-ng.c in Aircrack-ng before 1.2 Beta 3 allows remote attackers to cause a denial of service (segmentation fault) via a response with a crafted length parameter.", "other": {"cve": {"id": "CVE-2014-8323", "sourceIdentifier": "cve@mitre.org", "published": "2017-10-17T14:29:00.227", "lastModified": "2018-10-09T19:53:49.277", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "buddy-ng.c in Aircrack-ng before 1.2 Beta 3 allows remote attackers to cause a denial of service (segmentation fault) via a response with a crafted length parameter."}, {"lang": "es", "value": "buddy-ng.c en Aircrack-ng en versiones anteriores a la 1.2 Beta 3 permite a atacantes remotos provocar una denegaci\u00f3n de servicio (fallo de segmentaci\u00f3n) a trav\u00e9s de una respuesta con una longitud de par\u00e1metro manipulada."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:aircrack-ng:aircrack-ng:*:beta2:*:*:*:*:*:*", "versionEndIncluding": "1.2", "matchCriteriaId": "C1734B0A-A2E3-4064-A29C-FFB901C38465"}]}]}], "references": [{"url": "http://aircrack-ng.blogspot.com/2014/10/aircrack-ng-12-release-candidate-1.html", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Vendor Advisory"]}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2014-November/143216.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2014-November/143595.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2014-November/143606.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://packetstormsecurity.com/files/128943/Aircrack-ng-1.2-Beta-3-DoS-Code-Execution.html", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory", "VDB Entry"]}, {"url": "http://security.gentoo.org/glsa/glsa-201411-08.xml", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.securityfocus.com/archive/1/533869/100/0/threaded", "source": "cve@mitre.org"}, {"url": "http://www.securityfocus.com/bid/71085", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1159812", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/aircrack-ng/aircrack-ng/commit/da087238963c1239fdabd47dc1b65279605aca70", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/aircrack-ng/aircrack-ng/commit/da087238963c1239fdabd47dc1b65279605aca70"}}