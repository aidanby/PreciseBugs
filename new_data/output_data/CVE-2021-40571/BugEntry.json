{"buggy_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2012\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / MPEG-4 ObjectDescriptor sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/odf_dev.h>\n#include <gpac/constants.h>\n\n#include <gpac/avparse.h>\n\n#ifndef GPAC_DISABLE_AV_PARSERS\n#include <gpac/internal/media_dev.h>\n#endif\n\ns32 gf_odf_size_field_size(u32 size_desc)\n{\n\tif (size_desc < 0x00000080) {\n\t\treturn 1 + 1;\n\t} else if (size_desc < 0x00004000) {\n\t\treturn 2 + 1;\n\t} else if (size_desc < 0x00200000) {\n\t\treturn 3 + 1;\n\t} else if (size_desc < 0x10000000) {\n\t\treturn 4 + 1;\n\t} else {\n\t\treturn -1;\n\t}\n\n}\n\n\nGF_EXPORT\nGF_Err gf_odf_parse_descriptor(GF_BitStream *bs, GF_Descriptor **desc, u32 *desc_size)\n{\n\tu32 val, size, sizeHeader;\n\tu8 tag;\n\tGF_Err err;\n\tGF_Descriptor *newDesc;\n\tif (!bs) return GF_BAD_PARAM;\n\n\t*desc_size = 0;\n\n\t//tag\n\ttag = (u8) gf_bs_read_int(bs, 8);\n\tsizeHeader = 1;\n\n\t//size\n\tsize = 0;\n\tdo {\n\t\tval = gf_bs_read_int(bs, 8);\n\t\tsizeHeader++;\n\t\tif (sizeHeader > 5) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODEC, (\"[ODF] Descriptor size on more than 4 bytes\\n\"));\n\t\t\treturn GF_ODF_INVALID_DESCRIPTOR;\n\t\t}\n\t\tsize <<= 7;\n\t\tsize |= val & 0x7F;\n\t} while ( val & 0x80);\n\t*desc_size = size;\n\n\tif (gf_bs_available(bs) < size) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODEC, (\"[ODF] Not enough bytes (%d) to read descriptor (size=%d)\\n\", gf_bs_available(bs), size));\n\t\treturn GF_ODF_INVALID_DESCRIPTOR;\n\t}\n\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CODEC, (\"[ODF] Reading descriptor (tag %d size %d)\\n\", tag, size ));\n\n\tnewDesc = gf_odf_create_descriptor(tag);\n\tif (! newDesc) {\n\t\t*desc = NULL;\n\t\t*desc_size = sizeHeader;\n\t\tif ( (tag >= GF_ODF_ISO_RES_BEGIN_TAG) &&\n\t\t        (tag <= GF_ODF_ISO_RES_END_TAG) ) {\n\t\t\treturn GF_ODF_FORBIDDEN_DESCRIPTOR;\n\t\t}\n\t\telse if (!tag || (tag == 0xFF)) {\n\t\t\treturn GF_ODF_INVALID_DESCRIPTOR;\n\t\t}\n#ifndef GPAC_MINIMAL_ODF\n\t\treturn GF_OUT_OF_MEM;\n#else\n\t\tgf_bs_skip_bytes(bs, size);\n\t\t*desc_size = size + sizeHeader - gf_odf_size_field_size(*desc_size);\n\t\treturn GF_OK;\n#endif\n\t}\n\n\tnewDesc->tag = tag;\n\terr = gf_odf_read_descriptor(bs, newDesc, *desc_size);\n\n\t/*FFMPEG fix*/\n\tif ((tag==GF_ODF_SLC_TAG) && (((GF_SLConfig*)newDesc)->predefined==2)) {\n\t\tif (*desc_size==3) {\n\t\t\t*desc_size = 1;\n\t\t\terr = GF_OK;\n\t\t}\n\t}\n\n\t//little trick to handle lazy bitstreams that encode\n\t//SizeOfInstance on a fix number of bytes\n\t//This nb of bytes is added in Read methods\n\t*desc_size += sizeHeader - gf_odf_size_field_size(*desc_size);\n\t*desc = newDesc;\n\tif (err) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODEC, (\"[ODF] Error reading descriptor (tag %d size %d): %s\\n\", tag, size, gf_error_to_string(err) ));\n\t\tgf_odf_delete_descriptor(newDesc);\n\t\t*desc = NULL;\n\t}\n\treturn err;\n}\n\n\n\nGF_Err gf_odf_delete_descriptor_list(GF_List *descList)\n{\n\tGF_Err e;\n\tGF_Descriptor*tmp;\n\tu32 i;\n\t//no error if NULL chain...\n\tif (! descList) return GF_OK;\n\ti=0;\n\twhile ((tmp = (GF_Descriptor*)gf_list_enum(descList, &i))) {\n\t\te = gf_odf_delete_descriptor(tmp);\n\t\tif (e) return e;\n\t}\n\tgf_list_del(descList);\n\treturn GF_OK;\n}\n\nGF_Err gf_odf_write_base_descriptor(GF_BitStream *bs, u8 tag, u32 size)\n{\n\tu32 length;\n\tunsigned char vals[4];\n\n\tif (!tag ) return GF_BAD_PARAM;\n\n\tlength = size;\n\tvals[3] = (unsigned char) (length & 0x7f);\n\tlength >>= 7;\n\tvals[2] = (unsigned char) ((length & 0x7f) | 0x80);\n\tlength >>= 7;\n\tvals[1] = (unsigned char) ((length & 0x7f) | 0x80);\n\tlength >>= 7;\n\tvals[0] = (unsigned char) ((length & 0x7f) | 0x80);\n\n\tgf_bs_write_int(bs, tag, 8);\n\tif (size < 0x00000080) {\n\t\tgf_bs_write_int(bs, vals[3], 8);\n\t} else if (size < 0x00004000) {\n\t\tgf_bs_write_int(bs, vals[2], 8);\n\t\tgf_bs_write_int(bs, vals[3], 8);\n\t} else if (size < 0x00200000) {\n\t\tgf_bs_write_int(bs, vals[1], 8);\n\t\tgf_bs_write_int(bs, vals[2], 8);\n\t\tgf_bs_write_int(bs, vals[3], 8);\n\t} else if (size < 0x10000000) {\n\t\tgf_bs_write_int(bs, vals[0], 8);\n\t\tgf_bs_write_int(bs, vals[1], 8);\n\t\tgf_bs_write_int(bs, vals[2], 8);\n\t\tgf_bs_write_int(bs, vals[3], 8);\n\t} else {\n\t\treturn GF_ODF_INVALID_DESCRIPTOR;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err gf_odf_size_descriptor_list(GF_List *descList, u32 *outSize)\n{\n\tGF_Err e;\n\tu32 tmpSize, count, i;\n\tif (! descList) return GF_OK;\n\n\tcount = gf_list_count(descList);\n\tfor ( i = 0; i < count; i++ ) {\n\t\tGF_Descriptor *tmp = (GF_Descriptor*)gf_list_get(descList, i);\n\t\tif (tmp) {\n\t\t\te = gf_odf_size_descriptor(tmp, &tmpSize);\n\t\t\tif (e) return e;\n\t\t\tif (tmpSize) *outSize += tmpSize + gf_odf_size_field_size(tmpSize);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err gf_odf_write_descriptor_list(GF_BitStream *bs, GF_List *descList)\n{\n\tGF_Err e;\n\tu32 count, i;\n\n\tif (! descList) return GF_OK;\n\tcount = gf_list_count(descList);\n\tfor ( i = 0; i < count; i++ ) {\n\t\tGF_Descriptor *tmp = (GF_Descriptor*)gf_list_get(descList, i);\n\t\tif (tmp) {\n\t\t\te = gf_odf_write_descriptor(bs, tmp);\n\t\t\tif (e) return e;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err gf_odf_write_descriptor_list_filter(GF_BitStream *bs, GF_List *descList, u8 only_tag)\n{\n\tGF_Err e;\n\tu32 count, i;\n\n\tif (! descList) return GF_OK;\n\tcount = gf_list_count(descList);\n\tfor ( i = 0; i < count; i++ ) {\n\t\tGF_Descriptor *tmp = (GF_Descriptor*)gf_list_get(descList, i);\n\t\tif (tmp && (tmp->tag==only_tag) ) {\n\t\t\te = gf_odf_write_descriptor(bs, tmp);\n\t\t\tif (e) return e;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_MINIMAL_ODF\n\nu32 gf_ipmpx_array_size(GF_BitStream *bs, u32 *array_size)\n{\n\tu32 val, size, io_size;\n\n\tio_size = size = 0;\n\tdo {\n\t\tval = gf_bs_read_int(bs, 8);\n\t\tio_size ++;\n\t\tsize <<= 7;\n\t\tsize |= val & 0x7F;\n\t} while ( val & 0x80 );\n\t*array_size = size;\n\treturn io_size;\n}\n\nvoid gf_ipmpx_write_array(GF_BitStream *bs, u8 *data, u32 data_len)\n{\n\tu32 length;\n\tunsigned char vals[4];\n\n\tif (!data || !data_len) return;\n\n\tlength = data_len;\n\tvals[3] = (unsigned char) (length & 0x7f);\n\tlength >>= 7;\n\tvals[2] = (unsigned char) ((length & 0x7f) | 0x80);\n\tlength >>= 7;\n\tvals[1] = (unsigned char) ((length & 0x7f) | 0x80);\n\tlength >>= 7;\n\tvals[0] = (unsigned char) ((length & 0x7f) | 0x80);\n\n\tif (data_len < 0x00000080) {\n\t\tgf_bs_write_int(bs, vals[3], 8);\n\t} else if (data_len < 0x00004000) {\n\t\tgf_bs_write_int(bs, vals[2], 8);\n\t\tgf_bs_write_int(bs, vals[3], 8);\n\t} else if (data_len < 0x00200000) {\n\t\tgf_bs_write_int(bs, vals[1], 8);\n\t\tgf_bs_write_int(bs, vals[2], 8);\n\t\tgf_bs_write_int(bs, vals[3], 8);\n\t} else if (data_len < 0x10000000) {\n\t\tgf_bs_write_int(bs, vals[0], 8);\n\t\tgf_bs_write_int(bs, vals[1], 8);\n\t\tgf_bs_write_int(bs, vals[2], 8);\n\t\tgf_bs_write_int(bs, vals[3], 8);\n\t} else {\n\t\treturn;\n\t}\n\tgf_bs_write_data(bs, data, data_len);\n}\n\n\n#endif /*GPAC_MINIMAL_ODF*/\n\n/*special authoring functions*/\nGF_EXPORT\nGF_BIFSConfig *gf_odf_get_bifs_config(GF_DefaultDescriptor *dsi, u32 oti)\n{\n\tBool hasSize, cmd_stream;\n\tGF_BitStream *bs;\n\tGF_BIFSConfig *cfg;\n\n\tif (oti>=GF_CODECID_BIFS_EXTENDED) return NULL;\n\n\tif (!dsi || !dsi->data || !dsi->dataLength ) {\n\t\t/* Hack for T-DMB non compliant streams (OnTimeTek ?) */\n\t\tcfg = (GF_BIFSConfig *) gf_odf_desc_new(GF_ODF_BIFS_CFG_TAG);\n\t\tcfg->pixelMetrics = GF_TRUE;\n\t\tcfg->version = 1;\n\t\treturn cfg;\n\t}\n\tbs = gf_bs_new(dsi->data, dsi->dataLength, GF_BITSTREAM_READ);\n\n\tcfg = (GF_BIFSConfig *) gf_odf_desc_new(GF_ODF_BIFS_CFG_TAG);\n\tif (oti==2) {\n\t\t/*3D Mesh Coding*/\n\t\tgf_bs_read_int(bs, 1);\n\t\t/*PMF*/\n\t\tgf_bs_read_int(bs, 1);\n\t}\n\tcfg->nodeIDbits = gf_bs_read_int(bs, 5);\n\tcfg->routeIDbits = gf_bs_read_int(bs, 5);\n\tif (oti==2) cfg->protoIDbits = gf_bs_read_int(bs, 5);\n\n\tcmd_stream = (Bool)gf_bs_read_int(bs, 1);\n\tif (!cmd_stream) {\n\t\tcfg->elementaryMasks = gf_list_new();\n\t\twhile (1) {\n\t\t\tGF_ElementaryMask* em = (GF_ElementaryMask* ) gf_odf_New_ElemMask();\n\t\t\tem->node_id = gf_bs_read_int(bs, cfg->nodeIDbits);\n\t\t\tgf_list_add(cfg->elementaryMasks, em);\n\t\t\t/*this assumes only FDP, BDP and IFS2D (no elem mask)*/\n\t\t\tif (gf_bs_read_int(bs, 1) == 0) break;\n\t\t}\n\t\tgf_bs_align(bs);\n\t\tif (gf_bs_get_size(bs) != gf_bs_get_position(bs)) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODEC, (\"[ODF] Reading bifs config: shift in sizes (not supported)\\n\"));\n\t\t}\n\t} else {\n\t\tcfg->pixelMetrics = (Bool)gf_bs_read_int(bs, 1);\n\t\thasSize = (Bool)gf_bs_read_int(bs, 1);\n\t\tif (hasSize) {\n\t\t\tcfg->pixelWidth = gf_bs_read_int(bs, 16);\n\t\t\tcfg->pixelHeight = gf_bs_read_int(bs, 16);\n\t\t}\n\t\tgf_bs_align(bs);\n\t\tif (gf_bs_get_size(bs) != gf_bs_get_position(bs))\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODEC, (\"[ODF] Reading bifs config: shift in sizes (invalid descriptor)\\n\"));\n\t}\n\tgf_bs_del(bs);\n\treturn cfg;\n}\n\n/*special function for authoring - convert DSI to LASERConfig*/\nGF_EXPORT\nGF_Err gf_odf_get_laser_config(GF_DefaultDescriptor *dsi, GF_LASERConfig *cfg)\n{\n\tu32 to_skip;\n\tGF_BitStream *bs;\n\n\tif (!cfg) return GF_BAD_PARAM;\n\tmemset(cfg, 0, sizeof(GF_LASERConfig));\n\n\tif (!dsi || !dsi->data || !dsi->dataLength) return GF_BAD_PARAM;\n\tbs = gf_bs_new(dsi->data, dsi->dataLength, GF_BITSTREAM_READ);\n\tmemset(cfg, 0, sizeof(GF_LASERConfig));\n\tcfg->tag = GF_ODF_LASER_CFG_TAG;\n\tcfg->profile = gf_bs_read_int(bs, 8);\n\tcfg->level = gf_bs_read_int(bs, 8);\n\t/*cfg->reserved = */gf_bs_read_int(bs, 3);\n\tcfg->pointsCodec = gf_bs_read_int(bs, 2);\n\tcfg->pathComponents = gf_bs_read_int(bs, 4);\n\tcfg->fullRequestHost = gf_bs_read_int(bs, 1);\n\tif (gf_bs_read_int(bs, 1)) cfg->time_resolution = gf_bs_read_int(bs, 16);\n\telse cfg->time_resolution = 1000;\n\tcfg->colorComponentBits = 1 + gf_bs_read_int(bs, 4);\n\tcfg->resolution = gf_bs_read_int(bs, 4);\n\tif (cfg->resolution>7) cfg->resolution -= 16;\n\tcfg->coord_bits = gf_bs_read_int(bs, 5);\n\tcfg->scale_bits_minus_coord_bits = gf_bs_read_int(bs, 4);\n\tcfg->newSceneIndicator = gf_bs_read_int(bs, 1);\n\t/*reserved2*/ gf_bs_read_int(bs, 3);\n\tcfg->extensionIDBits = gf_bs_read_int(bs, 4);\n\t/*hasExtConfig - we just ignore it*/\n\tif (gf_bs_read_int(bs, 1)) {\n\t\tto_skip = gf_bs_read_vluimsbf5(bs);\n\t\twhile (to_skip) {\n\t\t\tgf_bs_read_int(bs, 8);\n\t\t\tto_skip--;\n\t\t}\n\t}\n\t/*hasExtension - we just ignore it*/\n\tif (gf_bs_read_int(bs, 1)) {\n\t\tto_skip = gf_bs_read_vluimsbf5(bs);\n\t\twhile (to_skip) {\n\t\t\tgf_bs_read_int(bs, 8);\n\t\t\tto_skip--;\n\t\t}\n\t}\n\tgf_bs_del(bs);\n\treturn GF_OK;\n}\n//unused\n#if 0\nGF_Err gf_odf_get_ui_config(GF_DefaultDescriptor *dsi, GF_UIConfig *cfg)\n{\n\tu32 len, i;\n\tGF_BitStream *bs;\n\tif (!dsi || !dsi->data || !dsi->dataLength || !cfg) return GF_BAD_PARAM;\n\tmemset(cfg, 0, sizeof(GF_UIConfig));\n\tcfg->tag = GF_ODF_UI_CFG_TAG;\n\tbs = gf_bs_new(dsi->data, dsi->dataLength, GF_BITSTREAM_READ);\n\tlen = gf_bs_read_int(bs, 8);\n\tcfg->deviceName = (char*)gf_malloc(sizeof(char) * (len+1));\n\tfor (i=0; i<len; i++) cfg->deviceName[i] = gf_bs_read_int(bs, 8);\n\tcfg->deviceName[i] = 0;\n\n\tif (!stricmp(cfg->deviceName, \"StringSensor\") && gf_bs_available(bs)) {\n\t\tcfg->termChar = gf_bs_read_int(bs, 8);\n\t\tcfg->delChar = gf_bs_read_int(bs, 8);\n\t}\n\tgf_bs_del(bs);\n\treturn GF_OK;\n}\n#endif\n\nGF_EXPORT\nGF_Err gf_odf_encode_ui_config(GF_UIConfig *cfg, GF_DefaultDescriptor **out_dsi)\n{\n\tu32 i, len;\n\tGF_BitStream *bs;\n\tGF_DefaultDescriptor *dsi;\n\tif (!out_dsi || (cfg->tag != GF_ODF_UI_CFG_TAG)) return GF_BAD_PARAM;\n\n\t*out_dsi = NULL;\n\tif (!cfg->deviceName) return GF_OK;\n\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tlen = (u32) strlen(cfg->deviceName);\n\tgf_bs_write_int(bs, len, 8);\n\tfor (i=0; i<len; i++) gf_bs_write_int(bs, cfg->deviceName[i], 8);\n\tif (!stricmp(cfg->deviceName, \"StringSensor\")) {\n\t\t/*fixme - this should be UTF-8 chars*/\n\t\tif (cfg->delChar || cfg->termChar) {\n\t\t\tgf_bs_write_int(bs, cfg->termChar, 8);\n\t\t\tgf_bs_write_int(bs, cfg->delChar, 8);\n\t\t}\n\t}\n\tif (cfg->ui_data) gf_bs_write_data(bs, cfg->ui_data, cfg->ui_data_length);\n\n\tdsi = (GF_DefaultDescriptor *) gf_odf_desc_new(GF_ODF_DSI_TAG);\n\tgf_bs_get_content(bs, &dsi->data, &dsi->dataLength);\n\tgf_bs_del(bs);\n\t*out_dsi = dsi;\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_AVCConfig *gf_odf_avc_cfg_new()\n{\n\tGF_AVCConfig *cfg;\n\tGF_SAFEALLOC(cfg, GF_AVCConfig);\n\tif (!cfg) return NULL;\n\tcfg->sequenceParameterSets = gf_list_new();\n\tcfg->pictureParameterSets = gf_list_new();\n\tcfg->AVCLevelIndication = 1;\n\tcfg->chroma_format = 1;\n\tcfg->chroma_bit_depth = 8;\n\tcfg->luma_bit_depth = 8;\n\treturn cfg;\n}\n\nGF_EXPORT\nvoid gf_odf_avc_cfg_del(GF_AVCConfig *cfg)\n{\n\tif (!cfg) return;\n\twhile (gf_list_count(cfg->sequenceParameterSets)) {\n\t\tGF_NALUFFParam *sl = (GF_NALUFFParam *)gf_list_get(cfg->sequenceParameterSets, 0);\n\t\tgf_list_rem(cfg->sequenceParameterSets, 0);\n\t\tif (sl->data) gf_free(sl->data);\n\t\tgf_free(sl);\n\t}\n\tgf_list_del(cfg->sequenceParameterSets);\n\tcfg->sequenceParameterSets = NULL;\n\n\twhile (gf_list_count(cfg->pictureParameterSets)) {\n\t\tGF_NALUFFParam *sl = (GF_NALUFFParam *)gf_list_get(cfg->pictureParameterSets, 0);\n\t\tgf_list_rem(cfg->pictureParameterSets, 0);\n\t\tif (sl->data) gf_free(sl->data);\n\t\tgf_free(sl);\n\t}\n\tgf_list_del(cfg->pictureParameterSets);\n\tcfg->pictureParameterSets = NULL;\n\n\tif (cfg->sequenceParameterSetExtensions) {\n\t\twhile (gf_list_count(cfg->sequenceParameterSetExtensions)) {\n\t\t\tGF_NALUFFParam *sl = (GF_NALUFFParam *)gf_list_get(cfg->sequenceParameterSetExtensions, 0);\n\t\t\tgf_list_rem(cfg->sequenceParameterSetExtensions, 0);\n\t\t\tif (sl->data) gf_free(sl->data);\n\t\t\tgf_free(sl);\n\t\t}\n\t\tgf_list_del(cfg->sequenceParameterSetExtensions);\n\t\tcfg->sequenceParameterSetExtensions = NULL;\n\t}\n\tgf_free(cfg);\n}\n\nGF_EXPORT\nGF_Err gf_odf_avc_cfg_write_bs(GF_AVCConfig *cfg, GF_BitStream *bs)\n{\n\tu32 i, count;\n\n\tif (!cfg) return GF_BAD_PARAM;\n\n\tcount = gf_list_count(cfg->sequenceParameterSets);\n\n\tif (!cfg->write_annex_b) {\n\t\tgf_bs_write_int(bs, cfg->configurationVersion, 8);\n\t\tgf_bs_write_int(bs, cfg->AVCProfileIndication , 8);\n\t\tgf_bs_write_int(bs, cfg->profile_compatibility, 8);\n\t\tgf_bs_write_int(bs, cfg->AVCLevelIndication, 8);\n\t\tgf_bs_write_int(bs, 0x3F, 6);\n\t\tgf_bs_write_int(bs, cfg->nal_unit_size - 1, 2);\n\t\tgf_bs_write_int(bs, 0x7, 3);\n\t\tgf_bs_write_int(bs, count, 5);\n\t}\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParam *sl = (GF_NALUFFParam *)gf_list_get(cfg->sequenceParameterSets, i);\n\t\tif (!cfg->write_annex_b) {\n\t\t\tgf_bs_write_u16(bs, sl->size);\n\t\t} else {\n\t\t\tgf_bs_write_u32(bs, 1);\n\t\t}\n\t\tgf_bs_write_data(bs, sl->data, sl->size);\n\t}\n\tcount = gf_list_count(cfg->pictureParameterSets);\n\tif (!cfg->write_annex_b) {\n\t\tgf_bs_write_int(bs, count, 8);\n\t}\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParam *sl = (GF_NALUFFParam *)gf_list_get(cfg->pictureParameterSets, i);\n\t\tif (!cfg->write_annex_b) {\n\t\t\tgf_bs_write_u16(bs, sl->size);\n\t\t} else {\n\t\t\tgf_bs_write_u32(bs, 1);\n\t\t}\n\t\tgf_bs_write_data(bs, sl->data, sl->size);\n\t}\n\tif (gf_avc_is_rext_profile(cfg->AVCProfileIndication)) {\n\t\tif (!cfg->write_annex_b) {\n\t\t\tgf_bs_write_int(bs, 0xFF, 6);\n\t\t\tgf_bs_write_int(bs, cfg->chroma_format, 2);\n\t\t\tgf_bs_write_int(bs, 0xFF, 5);\n\t\t\tgf_bs_write_int(bs, cfg->luma_bit_depth - 8, 3);\n\t\t\tgf_bs_write_int(bs, 0xFF, 5);\n\t\t\tgf_bs_write_int(bs, cfg->chroma_bit_depth - 8, 3);\n\t\t}\n\t\tcount = cfg->sequenceParameterSetExtensions ? gf_list_count(cfg->sequenceParameterSetExtensions) : 0;\n\t\tif (!cfg->write_annex_b) {\n\t\t\tgf_bs_write_u8(bs, count);\n\t\t}\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_NALUFFParam *sl = (GF_NALUFFParam *) gf_list_get(cfg->sequenceParameterSetExtensions, i);\n\t\t\tif (!cfg->write_annex_b) {\n\t\t\t\tgf_bs_write_u16(bs, sl->size);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_u32(bs, 1);\n\t\t\t}\n\t\t\tgf_bs_write_data(bs, sl->data, sl->size);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_odf_avc_cfg_write(GF_AVCConfig *cfg, u8 **outData, u32 *outSize)\n{\n\tGF_BitStream *bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tgf_odf_avc_cfg_write_bs(cfg, bs);\n\t*outSize = 0;\n\t*outData = NULL;\n\tgf_bs_get_content(bs, outData, outSize);\n\tgf_bs_del(bs);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_AVCConfig *gf_odf_avc_cfg_read(u8 *dsi, u32 dsi_size)\n{\n\tu32 i, count;\n\tGF_AVCConfig *avcc = gf_odf_avc_cfg_new();\n\tGF_BitStream *bs = gf_bs_new(dsi, dsi_size, GF_BITSTREAM_READ);\n\tavcc->configurationVersion = gf_bs_read_int(bs, 8);\n\tavcc->AVCProfileIndication  = gf_bs_read_int(bs, 8);\n\tavcc->profile_compatibility = gf_bs_read_int(bs, 8);\n\tavcc->AVCLevelIndication  = gf_bs_read_int(bs, 8);\n\tgf_bs_read_int(bs, 6);\n\tavcc->nal_unit_size = 1 + gf_bs_read_int(bs, 2);\n\tgf_bs_read_int(bs, 3);\n\tcount = gf_bs_read_int(bs, 5);\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParam *sl = (GF_NALUFFParam *)gf_malloc(sizeof(GF_NALUFFParam));\n\t\tsl->size = gf_bs_read_int(bs, 16);\n\t\tsl->data = (char*)gf_malloc(sizeof(char)*sl->size);\n\t\tgf_bs_read_data(bs, sl->data, sl->size);\n\t\tgf_list_add(avcc->sequenceParameterSets, sl);\n\t}\n\tcount = gf_bs_read_int(bs, 8);\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParam *sl = (GF_NALUFFParam *)gf_malloc(sizeof(GF_NALUFFParam));\n\t\tsl->size = gf_bs_read_int(bs, 16);\n\t\tsl->data = (char*)gf_malloc(sizeof(char)*sl->size);\n\t\tgf_bs_read_data(bs, sl->data, sl->size);\n\t\tgf_list_add(avcc->pictureParameterSets, sl);\n\t}\n\tif (gf_avc_is_rext_profile(avcc->AVCProfileIndication)) {\n\t\tgf_bs_read_int(bs, 6);\n\t\tavcc->chroma_format = gf_bs_read_int(bs, 2);\n\t\tgf_bs_read_int(bs, 5);\n\t\tavcc->luma_bit_depth = 8 + gf_bs_read_int(bs, 3);\n\t\tgf_bs_read_int(bs, 5);\n\t\tavcc->chroma_bit_depth = 8 + gf_bs_read_int(bs, 3);\n\n\t\tcount = gf_bs_read_int(bs, 8);\n\t\tif (count) {\n\t\t\tavcc->sequenceParameterSetExtensions = gf_list_new();\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tGF_NALUFFParam *sl = (GF_NALUFFParam *)gf_malloc(sizeof(GF_NALUFFParam));\n\t\t\t\tsl->size = gf_bs_read_u16(bs);\n\t\t\t\tsl->data = (char *)gf_malloc(sizeof(char) * sl->size);\n\t\t\t\tgf_bs_read_data(bs, sl->data, sl->size);\n\t\t\t\tgf_list_add(avcc->sequenceParameterSetExtensions, sl);\n\t\t\t}\n\t\t}\n\t}\n\n\n\tgf_bs_del(bs);\n\treturn avcc;\n}\n\n\nGF_Descriptor *gf_odf_new_tx3g()\n{\n\tGF_TextSampleDescriptor *newDesc = (GF_TextSampleDescriptor*) gf_malloc(sizeof(GF_TextSampleDescriptor));\n\tif (!newDesc) return NULL;\n\tmemset(newDesc, 0, sizeof(GF_TextSampleDescriptor));\n\tnewDesc->tag = GF_ODF_TX3G_TAG;\n\treturn (GF_Descriptor *) newDesc;\n}\nGF_Err gf_odf_del_tx3g(GF_TextSampleDescriptor *sd)\n{\n\tu32 i;\n\tfor (i=0; i<sd->font_count; i++)\n\t\tif (sd->fonts[i].fontName) gf_free(sd->fonts[i].fontName);\n\tgf_free(sd->fonts);\n\tgf_free(sd);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_TextSampleDescriptor *gf_odf_tx3g_read(u8 *dsi, u32 dsi_size)\n{\n\tu32 i;\n\tu32 gpp_read_rgba(GF_BitStream *bs);\n\tvoid gpp_read_style(GF_BitStream *bs, GF_StyleRecord *rec);\n\tvoid gpp_read_box(GF_BitStream *bs, GF_BoxRecord *rec);\n\n\tGF_TextSampleDescriptor *txtc = (GF_TextSampleDescriptor *) gf_odf_new_tx3g();\n\tGF_BitStream *bs = gf_bs_new(dsi, dsi_size, GF_BITSTREAM_READ);\n\n\ttxtc->horiz_justif = gf_bs_read_int(bs, 8);\n\ttxtc->vert_justif  = gf_bs_read_int(bs, 8);\n\ttxtc->back_color = gpp_read_rgba(bs);\n\tgpp_read_box(bs, &txtc->default_pos);\n\tgpp_read_style(bs, &txtc->default_style);\n\ttxtc->font_count = gf_bs_read_u16(bs);\n\ttxtc->fonts = gf_malloc(sizeof(GF_FontRecord)*txtc->font_count);\n\tfor (i=0; i<txtc->font_count; i++) {\n\t\tu8 len;\n\t\ttxtc->fonts[i].fontID = gf_bs_read_u16(bs);\n\t\tlen = gf_bs_read_u8(bs);\n\t\ttxtc->fonts[i].fontName = gf_malloc(sizeof(char)*(len+1));\n\t\tgf_bs_read_data(bs, txtc->fonts[i].fontName, len);\n\t\ttxtc->fonts[i].fontName[len] = 0;\n\t}\n\tgf_bs_del(bs);\n\treturn txtc;\n}\n\nGF_Err gf_odf_tx3g_write(GF_TextSampleDescriptor *a, u8 **outData, u32 *outSize)\n{\n\tu32 j;\n\tvoid gpp_write_rgba(GF_BitStream *bs, u32 col);\n\tvoid gpp_write_box(GF_BitStream *bs, GF_BoxRecord *rec);\n\tvoid gpp_write_style(GF_BitStream *bs, GF_StyleRecord *rec);\n\tGF_BitStream *bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\tgf_bs_write_u8(bs, a->horiz_justif);\n\tgf_bs_write_u8(bs, a->vert_justif);\n\tgpp_write_rgba(bs, a->back_color);\n\tgpp_write_box(bs, &a->default_pos);\n\tgpp_write_style(bs, &a->default_style);\n\n\tgf_bs_write_u16(bs, a->font_count);\n\tfor (j=0; j<a->font_count; j++) {\n\t\tgf_bs_write_u16(bs, a->fonts[j].fontID);\n\t\tif (a->fonts[j].fontName) {\n\t\t\tu32 len = (u32) strlen(a->fonts[j].fontName);\n\t\t\tgf_bs_write_u8(bs, len);\n\t\t\tgf_bs_write_data(bs, a->fonts[j].fontName, len);\n\t\t} else {\n\t\t\tgf_bs_write_u8(bs, 0);\n\t\t}\n\t}\n\tgf_bs_get_content(bs, outData, outSize);\n\tgf_bs_del(bs);\n\treturn GF_OK;\n}\n\n/*TextConfig*/\nGF_Descriptor *gf_odf_new_text_cfg()\n{\n\tGF_TextConfig *newDesc = (GF_TextConfig*) gf_malloc(sizeof(GF_TextConfig));\n\tif (!newDesc) return NULL;\n\tmemset(newDesc, 0, sizeof(GF_TextConfig));\n\tnewDesc->tag = GF_ODF_TEXT_CFG_TAG;\n\tnewDesc->sample_descriptions = gf_list_new();\n\tnewDesc->Base3GPPFormat = 0x10;\n\tnewDesc->MPEGExtendedFormat = 0x10;\n\tnewDesc->profileLevel = 0x10;\n\tnewDesc->timescale = 1000;\n\treturn (GF_Descriptor *) newDesc;\n}\n\nvoid ResetTextConfig(GF_TextConfig *desc)\n{\n\tGF_List *bck;\n\twhile (gf_list_count(desc->sample_descriptions)) {\n\t\tGF_TextSampleDescriptor *sd = (GF_TextSampleDescriptor *)gf_list_get(desc->sample_descriptions, 0);\n\t\tgf_list_rem(desc->sample_descriptions, 0);\n\t\tgf_odf_del_tx3g(sd);\n\t}\n\tbck = desc->sample_descriptions;\n\tmemset(desc, 0, sizeof(GF_TextConfig));\n\tdesc->tag = GF_ODF_TEXT_CFG_TAG;\n\tdesc->sample_descriptions = bck;\n}\n\nGF_Err gf_odf_del_text_cfg(GF_TextConfig *desc)\n{\n\tResetTextConfig(desc);\n\tgf_list_del(desc->sample_descriptions);\n\tgf_free(desc);\n\treturn GF_OK;\n}\n\n/*we need box parsing*/\n#include <gpac/internal/isomedia_dev.h>\nGF_EXPORT\nGF_Err gf_odf_get_text_config(u8 *data, u32 data_len, u32 codecid, GF_TextConfig *cfg)\n{\n\tu32 i;\n\tBool has_alt_format;\n#ifndef GPAC_DISABLE_ISOM\n\tBool has_sd;\n\tu32 j;\n#endif\n\tGF_Err e;\n\tGF_BitStream *bs;\n\tif (data || data_len || !cfg) return GF_BAD_PARAM;\n\tif (codecid != GF_CODECID_TEXT_MPEG4) return GF_NOT_SUPPORTED;\n\n\t/*reset*/\n\tResetTextConfig(cfg);\n\tbs = gf_bs_new(data, data_len, GF_BITSTREAM_READ);\n\n\te = GF_OK;\n\tcfg->Base3GPPFormat = gf_bs_read_int(bs, 8);\n\tcfg->MPEGExtendedFormat = gf_bs_read_int(bs, 8);\n\tcfg->profileLevel = gf_bs_read_int(bs, 8);\n\tcfg->timescale = gf_bs_read_int(bs, 24);\n\thas_alt_format = (Bool)gf_bs_read_int(bs, 1);\n\tcfg->sampleDescriptionFlags = gf_bs_read_int(bs, 2);\n#ifndef GPAC_DISABLE_ISOM\n\thas_sd = (Bool)gf_bs_read_int(bs, 1);\n#else\n\tgf_bs_read_int(bs, 1);\n#endif\n\tcfg->has_vid_info = (Bool)gf_bs_read_int(bs, 1);\n\tgf_bs_read_int(bs, 3);\n\tcfg->layer = gf_bs_read_int(bs, 8);\n\tcfg->text_width = gf_bs_read_int(bs, 16);\n\tcfg->text_height = gf_bs_read_int(bs, 16);\n\tif (has_alt_format) {\n\t\tcfg->nb_compatible_formats = gf_bs_read_int(bs, 8);\n\t\tfor (i=0; i<cfg->nb_compatible_formats; i++) cfg->compatible_formats[i] = gf_bs_read_int(bs, 8);\n\t}\n#ifndef GPAC_DISABLE_ISOM\n\tif (has_sd) {\n\t\tu8 sample_index;\n\t\tGF_TextSampleDescriptor *txdesc;\n\t\tGF_Tx3gSampleEntryBox *a;\n\t\ts64 avail;\n\t\tu32 nb_desc = gf_bs_read_int(bs, 8);\n\n\t\t/*parse TTU[5]s*/\n\t\tavail = (s64) gf_bs_available(bs);\n\t\tfor (i=0; i<nb_desc; i++) {\n\t\t\tsample_index = gf_bs_read_int(bs, 8);\n\t\t\tavail -= 1;\n\t\t\te = gf_isom_box_parse((GF_Box **) &a, bs);\n\t\t\tif (e) goto exit;\n\t\t\tavail -= (s32) a->size;\n\n\t\t\tif (avail<0) {\n\t\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\ttxdesc = (GF_TextSampleDescriptor *)gf_malloc(sizeof(GF_TextSampleDescriptor));\n\t\t\ttxdesc->sample_index = sample_index;\n\t\t\ttxdesc->displayFlags = a->displayFlags;\n\t\t\ttxdesc->back_color = a->back_color;\n\t\t\ttxdesc->default_pos = a->default_box;\n\t\t\ttxdesc->default_style = a->default_style;\n\t\t\ttxdesc->vert_justif = a->vertical_justification;\n\t\t\ttxdesc->horiz_justif = a->horizontal_justification;\n\t\t\ttxdesc->font_count = a->font_table ? a->font_table->entry_count : 0;\n\t\t\tif (txdesc->font_count) {\n\t\t\t\ttxdesc->fonts = (GF_FontRecord*)gf_malloc(sizeof(GF_FontRecord)*txdesc->font_count);\n\t\t\t\tfor (j=0; j<txdesc->font_count; j++) {\n\t\t\t\t\ttxdesc->fonts[j].fontID = a->font_table->fonts[j].fontID;\n\t\t\t\t\ttxdesc->fonts[j].fontName = a->font_table->fonts[j].fontName ? gf_strdup(a->font_table->fonts[j].fontName) : NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_list_add(cfg->sample_descriptions, txdesc);\n\t\t\tgf_isom_box_del((GF_Box *)a);\n\t\t}\n\t}\n#endif\n\n\tif (cfg->has_vid_info) {\n\t\tcfg->video_width = gf_bs_read_int(bs, 16);\n\t\tcfg->video_height = gf_bs_read_int(bs, 16);\n\t\tcfg->horiz_offset = gf_bs_read_int(bs, 16);\n\t\tcfg->vert_offset = gf_bs_read_int(bs, 16);\n\t}\n\n#ifndef GPAC_DISABLE_ISOM\nexit:\n#endif\n\tgf_bs_del(bs);\n\tif (e) ResetTextConfig(cfg);\n\treturn e;\n}\n\n\n\nGF_EXPORT\nGF_HEVCConfig *gf_odf_hevc_cfg_new()\n{\n\tGF_HEVCConfig *cfg;\n\tGF_SAFEALLOC(cfg, GF_HEVCConfig);\n\tif (!cfg) return NULL;\n\tcfg->param_array = gf_list_new();\n\tcfg->nal_unit_size = 4;\n\treturn cfg;\n}\n\nGF_EXPORT\nvoid gf_odf_hevc_cfg_del(GF_HEVCConfig *cfg)\n{\n\tif (!cfg) return;\n\twhile (gf_list_count(cfg->param_array)) {\n\t\tGF_NALUFFParamArray *pa = (GF_NALUFFParamArray*)gf_list_get(cfg->param_array, 0);\n\t\tgf_list_rem(cfg->param_array, 0);\n\n\t\twhile (gf_list_count(pa->nalus)) {\n\t\t\tGF_NALUFFParam *n = (GF_NALUFFParam*)gf_list_get(pa->nalus, 0);\n\t\t\tgf_list_rem(pa->nalus, 0);\n\t\t\tif (n->data) gf_free(n->data);\n\t\t\tgf_free(n);\n\t\t}\n\t\tgf_list_del(pa->nalus);\n\t\tgf_free(pa);\n\t}\n\tgf_list_del(cfg->param_array);\n\tgf_free(cfg);\n}\n\nGF_EXPORT\nGF_Err gf_odf_hevc_cfg_write_bs(GF_HEVCConfig *cfg, GF_BitStream *bs)\n{\n\tu32 i, count;\n\n\tcount = gf_list_count(cfg->param_array);\n\n\tif (!cfg->write_annex_b) {\n\t\tgf_bs_write_int(bs, cfg->configurationVersion, 8);\n\n\t\tif (!cfg->is_lhvc) {\n\t\t\tgf_bs_write_int(bs, cfg->profile_space, 2);\n\t\t\tgf_bs_write_int(bs, cfg->tier_flag, 1);\n\t\t\tgf_bs_write_int(bs, cfg->profile_idc, 5);\n\t\t\tgf_bs_write_int(bs, cfg->general_profile_compatibility_flags, 32);\n\t\t\tgf_bs_write_int(bs, cfg->progressive_source_flag, 1);\n\t\t\tgf_bs_write_int(bs, cfg->interlaced_source_flag, 1);\n\t\t\tgf_bs_write_int(bs, cfg->non_packed_constraint_flag, 1);\n\t\t\tgf_bs_write_int(bs, cfg->frame_only_constraint_flag, 1);\n\t\t\t/*only lowest 44 bits used*/\n\t\t\tgf_bs_write_long_int(bs, cfg->constraint_indicator_flags, 44);\n\t\t\tgf_bs_write_int(bs, cfg->level_idc, 8);\n\t\t}\n\n\t\tgf_bs_write_int(bs, 0xFF, 4);\n\t\tgf_bs_write_int(bs, cfg->min_spatial_segmentation_idc, 12);\n\n\t\tgf_bs_write_int(bs, 0xFF, 6);\n\t\tgf_bs_write_int(bs, cfg->parallelismType, 2);\n\n\t\tif (!cfg->is_lhvc) {\n\t\t\tgf_bs_write_int(bs, 0xFF, 6);\n\t\t\tgf_bs_write_int(bs, cfg->chromaFormat, 2);\n\t\t\tgf_bs_write_int(bs, 0xFF, 5);\n\t\t\tgf_bs_write_int(bs, cfg->luma_bit_depth-8, 3);\n\t\t\tgf_bs_write_int(bs, 0xFF, 5);\n\t\t\tgf_bs_write_int(bs, cfg->chroma_bit_depth-8, 3);\n\t\t\tgf_bs_write_int(bs, cfg->avgFrameRate, 16);\n\n\t\t\tgf_bs_write_int(bs, cfg->constantFrameRate, 2);\n\t\t} else {\n\t\t\tgf_bs_write_int(bs, 0xFF, 2);\n\t\t}\n\n\t\tgf_bs_write_int(bs, cfg->numTemporalLayers, 3);\n\t\tgf_bs_write_int(bs, cfg->temporalIdNested, 1);\n\t\tgf_bs_write_int(bs, cfg->nal_unit_size - 1, 2);\n\n\t\tgf_bs_write_int(bs, count, 8);\n\t}\n\n\tfor (i=0; i<count; i++) {\n\t\tu32 nalucount, j;\n\t\tGF_NALUFFParamArray *ar = (GF_NALUFFParamArray*)gf_list_get(cfg->param_array, i);\n\n\t\tnalucount = gf_list_count(ar->nalus);\n\t\tif (!cfg->write_annex_b) {\n\t\t\tgf_bs_write_int(bs, ar->array_completeness, 1);\n\t\t\tgf_bs_write_int(bs, 0, 1);\n\t\t\tgf_bs_write_int(bs, ar->type, 6);\n\t\t\tgf_bs_write_int(bs, nalucount, 16);\n\t\t}\n\n\t\tfor (j=0; j<nalucount; j++) {\n\t\t\tGF_NALUFFParam *sl = (GF_NALUFFParam *)gf_list_get(ar->nalus, j);\n\t\t\tif (!cfg->write_annex_b) {\n\t\t\t\tgf_bs_write_int(bs, sl->size, 16);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_u32(bs, 1);\n\t\t\t}\n\t\t\tgf_bs_write_data(bs, sl->data, sl->size);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_odf_hevc_cfg_write(GF_HEVCConfig *cfg, u8 **outData, u32 *outSize)\n{\n\tGF_Err e;\n\tGF_BitStream *bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t*outSize = 0;\n\t*outData = NULL;\n\te = gf_odf_hevc_cfg_write_bs(cfg, bs);\n\tif (e==GF_OK)\n\t\tgf_bs_get_content(bs, outData, outSize);\n\n\tgf_bs_del(bs);\n\treturn e;\n}\n\nGF_EXPORT\nGF_HEVCConfig *gf_odf_hevc_cfg_read_bs(GF_BitStream *bs, Bool is_lhvc)\n{\n\tu32 i, count;\n\tGF_HEVCConfig *cfg = gf_odf_hevc_cfg_new();\n\n\tcfg->is_lhvc = is_lhvc;\n\n\tcfg->configurationVersion = gf_bs_read_int(bs, 8);\n\n\tif (!is_lhvc) {\n\t\tcfg->profile_space = gf_bs_read_int(bs, 2);\n\t\tcfg->tier_flag = gf_bs_read_int(bs, 1);\n\t\tcfg->profile_idc = gf_bs_read_int(bs, 5);\n\t\tcfg->general_profile_compatibility_flags = gf_bs_read_int(bs, 32);\n\n\t\tcfg->progressive_source_flag = gf_bs_read_int(bs, 1);\n\t\tcfg->interlaced_source_flag = gf_bs_read_int(bs, 1);\n\t\tcfg->non_packed_constraint_flag = gf_bs_read_int(bs, 1);\n\t\tcfg->frame_only_constraint_flag = gf_bs_read_int(bs, 1);\n\t\t/*only lowest 44 bits used*/\n\t\tcfg->constraint_indicator_flags = gf_bs_read_long_int(bs, 44);\n\t\tcfg->level_idc = gf_bs_read_int(bs, 8);\n\t}\n\n\tgf_bs_read_int(bs, 4); //reserved\n\tcfg->min_spatial_segmentation_idc = gf_bs_read_int(bs, 12);\n\n\tgf_bs_read_int(bs, 6);//reserved\n\tcfg->parallelismType = gf_bs_read_int(bs, 2);\n\n\tif (!is_lhvc) {\n\t\tgf_bs_read_int(bs, 6);\n\t\tcfg->chromaFormat = gf_bs_read_int(bs, 2);\n\t\tgf_bs_read_int(bs, 5);\n\t\tcfg->luma_bit_depth = gf_bs_read_int(bs, 3) + 8;\n\t\tgf_bs_read_int(bs, 5);\n\t\tcfg->chroma_bit_depth = gf_bs_read_int(bs, 3) + 8;\n\t\tcfg->avgFrameRate = gf_bs_read_int(bs, 16);\n\n\t\tcfg->constantFrameRate = gf_bs_read_int(bs, 2);\n\t} else {\n\t\tgf_bs_read_int(bs, 2); //reserved\n\t}\n\n\tcfg->numTemporalLayers = gf_bs_read_int(bs, 3);\n\tcfg->temporalIdNested = gf_bs_read_int(bs, 1);\n\n\tcfg->nal_unit_size = 1 + gf_bs_read_int(bs, 2);\n\n\tcount = gf_bs_read_int(bs, 8);\n\tfor (i=0; i<count; i++) {\n\t\tu32 nalucount, j;\n\t\tGF_NALUFFParamArray *ar;\n\t\tGF_SAFEALLOC(ar, GF_NALUFFParamArray);\n\t\tif (!ar) {\n\t\t\tgf_odf_hevc_cfg_del(cfg);\n\t\t\treturn NULL;\n\t\t}\n\t\tar->nalus = gf_list_new();\n\t\tgf_list_add(cfg->param_array, ar);\n\n\t\tar->array_completeness = gf_bs_read_int(bs, 1);\n\t\tgf_bs_read_int(bs, 1);\n\t\tar->type = gf_bs_read_int(bs, 6);\n\t\tnalucount = gf_bs_read_int(bs, 16);\n\t\tfor (j=0; j<nalucount; j++) {\n\t\t\tGF_NALUFFParam *sl;\n\t\t\tu32 size = gf_bs_read_int(bs, 16);\n\t\t\tif (size>gf_bs_available(bs)) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Wrong param set size %d\\n\", size));\n\t\t\t\tgf_odf_hevc_cfg_del(cfg);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tGF_SAFEALLOC(sl, GF_NALUFFParam );\n\t\t\tif (!sl) {\n\t\t\t\tgf_odf_hevc_cfg_del(cfg);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\tsl->size = size;\n\t\t\tsl->data = (char *)gf_malloc(sizeof(char) * sl->size);\n\t\t\tgf_bs_read_data(bs, sl->data, sl->size);\n\t\t\tgf_list_add(ar->nalus, sl);\n\t\t}\n\t}\n\treturn cfg;\n}\n\nGF_EXPORT\nGF_HEVCConfig *gf_odf_hevc_cfg_read(u8 *dsi, u32 dsi_size, Bool is_lhvc)\n{\n\tGF_BitStream *bs = gf_bs_new(dsi, dsi_size, GF_BITSTREAM_READ);\n\tGF_HEVCConfig *cfg = gf_odf_hevc_cfg_read_bs(bs, is_lhvc);\n\tgf_bs_del(bs);\n\treturn cfg;\n}\n\nGF_EXPORT\nGF_VVCConfig *gf_odf_vvc_cfg_new()\n{\n\tGF_VVCConfig *cfg;\n\tGF_SAFEALLOC(cfg, GF_VVCConfig);\n\tif (!cfg) return NULL;\n\tcfg->param_array = gf_list_new();\n\tcfg->nal_unit_size = 4;\n\tcfg->chroma_format = 1;\n\tcfg->bit_depth = 8;\n\treturn cfg;\n}\n\nGF_EXPORT\nvoid gf_odf_vvc_cfg_del(GF_VVCConfig *cfg)\n{\n\tif (!cfg) return;\n\twhile (gf_list_count(cfg->param_array)) {\n\t\tGF_NALUFFParamArray *pa = (GF_NALUFFParamArray*)gf_list_get(cfg->param_array, 0);\n\t\tgf_list_rem(cfg->param_array, 0);\n\n\t\twhile (gf_list_count(pa->nalus)) {\n\t\t\tGF_NALUFFParam *n = (GF_NALUFFParam*)gf_list_get(pa->nalus, 0);\n\t\t\tgf_list_rem(pa->nalus, 0);\n\t\t\tif (n->data) gf_free(n->data);\n\t\t\tgf_free(n);\n\t\t}\n\t\tgf_list_del(pa->nalus);\n\t\tgf_free(pa);\n\t}\n\tgf_list_del(cfg->param_array);\n\tif (cfg->general_constraint_info)\n\t\tgf_free(cfg->general_constraint_info);\n\tif (cfg->sub_profiles_idc)\n\t\tgf_free(cfg->sub_profiles_idc);\n\tgf_free(cfg);\n}\n\nGF_EXPORT\nGF_Err gf_odf_vvc_cfg_write_bs(GF_VVCConfig *cfg, GF_BitStream *bs)\n{\n\tu32 i, count;\n\n\tcount = gf_list_count(cfg->param_array);\n\n\tif (!cfg->write_annex_b) {\n\n\t\tgf_bs_write_int(bs, 0xFF, 5);\n\t\tgf_bs_write_int(bs, cfg->nal_unit_size - 1, 2);\n\t\tgf_bs_write_int(bs, cfg->ptl_present, 1);\n\n\t\tif (cfg->ptl_present) {\n\t\t\ts32 idx;\n\n\t\t\tgf_bs_write_int(bs, cfg->ols_idx, 9);\n\t\t\tgf_bs_write_int(bs, cfg->numTemporalLayers, 3);\n\t\t\tgf_bs_write_int(bs, cfg->constantFrameRate, 2);\n\t\t\tgf_bs_write_int(bs, cfg->chroma_format, 2);\n\t\t\tgf_bs_write_int(bs, cfg->bit_depth - 8, 3);\n\t\t\tgf_bs_write_int(bs, 0xFF, 5);\n\n\t\t\tif (!cfg->general_constraint_info)\n\t\t\t\tcfg->num_constraint_info = 0;\n\n\t\t\t//write PTL\n\t\t\tgf_bs_write_int(bs, 0, 2);\n\t\t\tgf_bs_write_int(bs, cfg->num_constraint_info, 6);\n\t\t\tgf_bs_write_int(bs, cfg->general_profile_idc, 7);\n\t\t\tgf_bs_write_int(bs, cfg->general_tier_flag, 1);\n\t\t\tgf_bs_write_u8(bs, cfg->general_level_idc);\n\t\t\tgf_bs_write_int(bs, cfg->ptl_frame_only_constraint, 1);\n\t\t\tgf_bs_write_int(bs, cfg->ptl_multilayer_enabled, 1);\n\n\t\t\tif (cfg->num_constraint_info) {\n\t\t\t\tgf_bs_write_data(bs, cfg->general_constraint_info, cfg->num_constraint_info - 1);\n\t\t\t\tgf_bs_write_int(bs, cfg->general_constraint_info[cfg->num_constraint_info - 1], 6);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_int(bs, 0, 6);\n\t\t\t}\n\n\t\t\tfor (idx=cfg->numTemporalLayers-2; idx>=0; idx--) {\n\t\t\t\tu8 val = cfg->ptl_sublayer_present_mask & (1<<idx);\n\t\t\t\tgf_bs_write_int(bs, val ? 1 : 0, 1);\n\t\t\t}\n\t\t\tfor (idx=cfg->numTemporalLayers; idx<=8 && cfg->numTemporalLayers>1; idx++) {\n\t\t\t\tgf_bs_write_int(bs, 0, 1);\n\t\t\t}\n\t\t\tfor (idx=cfg->numTemporalLayers-2; idx>=0; idx--) {\n\t\t\t\tif (cfg->ptl_sublayer_present_mask & (1<<idx))\n\t\t\t\t\tgf_bs_write_u8(bs, cfg->sublayer_level_idc[idx]);\n\t\t\t}\n\t\t\tif (!cfg->sub_profiles_idc) cfg->num_sub_profiles = 0;\n\t\t\tgf_bs_write_u8(bs, cfg->num_sub_profiles);\n\t\t\tfor (idx=0; idx<cfg->num_sub_profiles; idx++) {\n\t\t\t\tgf_bs_write_u32(bs, cfg->sub_profiles_idc[idx]);\n\t\t\t}\n\t\t\t//end PTL\n\n\t\t\tgf_bs_write_u16(bs, cfg->maxPictureWidth);\n\t\t\tgf_bs_write_u16(bs, cfg->maxPictureHeight);\n\t\t\tgf_bs_write_u16(bs, cfg->avgFrameRate);\n\t\t}\n\t\tgf_bs_write_int(bs, count, 8);\n\t}\n\n\tfor (i=0; i<count; i++) {\n\t\tu32 nalucount, j;\n\t\tGF_NALUFFParamArray *ar = (GF_NALUFFParamArray*)gf_list_get(cfg->param_array, i);\n\n\t\tnalucount = gf_list_count(ar->nalus);\n\t\tif (!cfg->write_annex_b) {\n\t\t\tgf_bs_write_int(bs, ar->array_completeness, 1);\n\t\t\tgf_bs_write_int(bs, 0, 2);\n\t\t\tgf_bs_write_int(bs, ar->type, 5);\n\n\t\t\tif ((ar->type != GF_VVC_NALU_DEC_PARAM) && (ar->type != GF_VVC_NALU_OPI))\n\t\t\t\tgf_bs_write_int(bs, nalucount, 16);\n\t\t\telse\n\t\t\t\tnalucount = 1;\n\t\t}\n\n\t\tfor (j=0; j<nalucount; j++) {\n\t\t\tGF_NALUFFParam *sl = (GF_NALUFFParam *)gf_list_get(ar->nalus, j);\n\t\t\tif (!cfg->write_annex_b) {\n\t\t\t\tgf_bs_write_int(bs, sl->size, 16);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_u32(bs, 1);\n\t\t\t}\n\t\t\tgf_bs_write_data(bs, sl->data, sl->size);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_odf_vvc_cfg_write(GF_VVCConfig *cfg, u8 **outData, u32 *outSize)\n{\n\tGF_Err e;\n\tGF_BitStream *bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t*outSize = 0;\n\t*outData = NULL;\n\te = gf_odf_vvc_cfg_write_bs(cfg, bs);\n\tif (e==GF_OK)\n\t\tgf_bs_get_content(bs, outData, outSize);\n\n\tgf_bs_del(bs);\n\treturn e;\n}\n\nGF_EXPORT\nGF_VVCConfig *gf_odf_vvc_cfg_read_bs(GF_BitStream *bs)\n{\n\tu32 i, count;\n\tGF_VVCConfig *cfg = gf_odf_vvc_cfg_new();\n\n\tgf_bs_read_int(bs, 5);\n\tcfg->nal_unit_size = 1 + gf_bs_read_int(bs, 2);\n\tcfg->ptl_present = gf_bs_read_int(bs, 1);\n\n\tif (cfg->ptl_present) {\n\t\ts32 j;\n\n\t\tcfg->ols_idx = gf_bs_read_int(bs, 9);\n\t\tcfg->numTemporalLayers = gf_bs_read_int(bs, 3);\n\t\tcfg->constantFrameRate = gf_bs_read_int(bs, 2);\n\t\tcfg->chroma_format = gf_bs_read_int(bs, 2);\n\t\tcfg->bit_depth = 8 + gf_bs_read_int(bs, 3);\n\t\tgf_bs_read_int(bs, 5);\n\n\t\t//parse PTL\n\t\tgf_bs_read_int(bs, 2);\n\t\tcfg->num_constraint_info = gf_bs_read_int(bs, 6);\n\t\tcfg->general_profile_idc = gf_bs_read_int(bs, 7);\n\t\tcfg->general_tier_flag = gf_bs_read_int(bs, 1);\n\t\tcfg->general_level_idc = gf_bs_read_u8(bs);\n\t\tcfg->ptl_frame_only_constraint = gf_bs_read_int(bs, 1);\n\t\tcfg->ptl_multilayer_enabled = gf_bs_read_int(bs, 1);\n\n\t\tif (cfg->num_constraint_info) {\n\t\t\tcfg->general_constraint_info = gf_malloc(sizeof(u8)*cfg->num_constraint_info);\n\t\t\tif (!cfg->general_constraint_info) {\n\t\t\t\tgf_free(cfg);\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] alloc failed while parsing vvc config\\n\"));\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tgf_bs_read_data(bs, cfg->general_constraint_info, cfg->num_constraint_info - 1);\n\t\t\tcfg->general_constraint_info[cfg->num_constraint_info-1] =  gf_bs_read_int(bs, 6);\n\t\t} else {\n\t\t\t//forbidden in spec!\n\t\t\tgf_bs_read_int(bs, 6);\n\t\t}\n\n\t\tcfg->ptl_sublayer_present_mask = 0;\n\t\tfor (j=cfg->numTemporalLayers-2; j>=0; j--) {\n\t\t\tu32 val = gf_bs_read_int(bs, 1);\n\t\t\tcfg->ptl_sublayer_present_mask |= val << j;\n\t\t}\n\t\tfor (j=cfg->numTemporalLayers; j<=8 && cfg->numTemporalLayers>1; j++) {\n\t\t\tgf_bs_read_int(bs, 1);\n\t\t}\n\t\tfor (j=cfg->numTemporalLayers-2; j>=0; j--) {\n\t\t\tif (cfg->ptl_sublayer_present_mask & (1<<j)) {\n\t\t\t\tcfg->sublayer_level_idc[j] = gf_bs_read_u8(bs);\n\t\t\t}\n\t\t}\n\t\tcfg->num_sub_profiles = gf_bs_read_u8(bs);\n\t\tif (cfg->num_sub_profiles) {\n\t\t\tcfg->sub_profiles_idc = gf_malloc(sizeof(u32)*cfg->num_sub_profiles);\n\t\t\tif (!cfg->sub_profiles_idc) {\n\t\t\t\tgf_free(cfg->general_constraint_info);\n\t\t\t\tgf_free(cfg);\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] alloc failed while parsing vvc config\\n\"));\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t\tfor (i=0; i<cfg->num_sub_profiles; i++) {\n\t\t\tcfg->sub_profiles_idc[i] = gf_bs_read_u32(bs);\n\t\t}\n\n\t\t//end PTL\n\n\t\tcfg->maxPictureWidth = gf_bs_read_u16(bs);\n\t\tcfg->maxPictureHeight = gf_bs_read_u16(bs);\n\t\tcfg->avgFrameRate = gf_bs_read_u16(bs);\n\t}\n\n\tcount = gf_bs_read_int(bs, 8);\n\tfor (i=0; i<count; i++) {\n\t\tu32 nalucount, j;\n\t\tGF_NALUFFParamArray *ar;\n\t\tGF_SAFEALLOC(ar, GF_NALUFFParamArray);\n\t\tif (!ar) {\n\t\t\tgf_odf_vvc_cfg_del(cfg);\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] alloc failed while parsing vvc config\\n\"));\n\t\t\treturn NULL;\n\t\t}\n\t\tar->nalus = gf_list_new();\n\t\tgf_list_add(cfg->param_array, ar);\n\n\t\tar->array_completeness = gf_bs_read_int(bs, 1);\n\t\tgf_bs_read_int(bs, 2);\n\t\tar->type = gf_bs_read_int(bs, 5);\n\n\t\tif ((ar->type != GF_VVC_NALU_DEC_PARAM) && (ar->type != GF_VVC_NALU_OPI))\n\t\t\tnalucount = gf_bs_read_int(bs, 16);\n\t\telse\n\t\t\tnalucount = 1;\n\t\t\t\n\t\tfor (j=0; j<nalucount; j++) {\n\t\t\tGF_NALUFFParam *sl;\n\t\t\tu32 size = gf_bs_read_int(bs, 16);\n\t\t\tif (size>gf_bs_available(bs)) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Wrong param set size %d\\n\", size));\n\t\t\t\tgf_odf_vvc_cfg_del(cfg);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tGF_SAFEALLOC(sl, GF_NALUFFParam );\n\t\t\tif (!sl) {\n\t\t\t\tgf_odf_vvc_cfg_del(cfg);\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] alloc failed while parsing vvc config\\n\"));\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\tsl->size = size;\n\t\t\tsl->data = (char *)gf_malloc(sizeof(char) * sl->size);\n\t\t\tif (!sl->data) {\n\t\t\t\tgf_free(sl);\n\t\t\t\tgf_odf_vvc_cfg_del(cfg);\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] alloc failed while parsing vvc config\\n\"));\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tgf_bs_read_data(bs, sl->data, sl->size);\n\t\t\tgf_list_add(ar->nalus, sl);\n\t\t}\n\t}\n\treturn cfg;\n}\n\nGF_EXPORT\nGF_VVCConfig *gf_odf_vvc_cfg_read(u8 *dsi, u32 dsi_size)\n{\n\tGF_BitStream *bs = gf_bs_new(dsi, dsi_size, GF_BITSTREAM_READ);\n\tGF_VVCConfig *cfg = gf_odf_vvc_cfg_read_bs(bs);\n\tgf_bs_del(bs);\n\treturn cfg;\n}\n\nGF_EXPORT\nGF_AV1Config *gf_odf_av1_cfg_new()\n{\n\tGF_AV1Config *cfg;\n\tGF_SAFEALLOC(cfg, GF_AV1Config);\n\tif (!cfg) return NULL;\n\tcfg->marker = 1;\n\tcfg->version = 1;\n\tcfg->initial_presentation_delay_minus_one = 0;\n\tcfg->obu_array = gf_list_new();\n\treturn cfg;\n}\n\nGF_EXPORT\nvoid gf_odf_av1_cfg_del(GF_AV1Config *cfg)\n{\n\tif (!cfg) return;\n\twhile (gf_list_count(cfg->obu_array)) {\n\t\tGF_AV1_OBUArrayEntry *a = (GF_AV1_OBUArrayEntry*)gf_list_get(cfg->obu_array, 0);\n\t\tif (a->obu) gf_free(a->obu);\n\t\tgf_list_rem(cfg->obu_array, 0);\n\t\tgf_free(a);\n\t}\n\tgf_list_del(cfg->obu_array);\n\tgf_free(cfg);\n}\n\nGF_EXPORT\nGF_Err gf_odf_av1_cfg_write_bs(GF_AV1Config *cfg, GF_BitStream *bs)\n{\n\tu32 i = 0;\n\tgf_bs_write_int(bs, cfg->marker, 1); assert(cfg->marker == 1);\n\tgf_bs_write_int(bs, cfg->version, 7); assert(cfg->version == 1);\n\tgf_bs_write_int(bs, cfg->seq_profile, 3);\n\tgf_bs_write_int(bs, cfg->seq_level_idx_0, 5);\n\tgf_bs_write_int(bs, cfg->seq_tier_0, 1);\n\tgf_bs_write_int(bs, cfg->high_bitdepth, 1);\n\tgf_bs_write_int(bs, cfg->twelve_bit, 1);\n\tgf_bs_write_int(bs, cfg->monochrome, 1);\n\tgf_bs_write_int(bs, cfg->chroma_subsampling_x, 1);\n\tgf_bs_write_int(bs, cfg->chroma_subsampling_y, 1);\n\tgf_bs_write_int(bs, cfg->chroma_sample_position, 2);\n\tgf_bs_write_int(bs, 0, 3); /*reserved*/\n\tgf_bs_write_int(bs, cfg->initial_presentation_delay_present, 1);\n\tgf_bs_write_int(bs, cfg->initial_presentation_delay_minus_one, 4); /*TODO: compute initial_presentation_delay_minus_one*/\n\tfor (i = 0; i < gf_list_count(cfg->obu_array); ++i) {\n\t\tGF_AV1_OBUArrayEntry *a = gf_list_get(cfg->obu_array, i);\n\t\tgf_bs_write_data(bs, a->obu, (u32)a->obu_length); //TODO: we are supposed to omit the size on the last OBU...\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_odf_av1_cfg_write(GF_AV1Config *cfg, u8 **outData, u32 *outSize) {\n\tGF_Err e;\n\tGF_BitStream *bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t*outSize = 0;\n\t*outData = NULL;\n\te = gf_odf_av1_cfg_write_bs(cfg, bs);\n\tif (e == GF_OK)\n\t\tgf_bs_get_content(bs, outData, outSize);\n\n\tgf_bs_del(bs);\n\treturn e;\n}\n\nGF_EXPORT\nGF_VPConfig *gf_odf_vp_cfg_new()\n{\n\tGF_VPConfig *cfg;\n\tGF_SAFEALLOC(cfg, GF_VPConfig);\n\tif (!cfg) return NULL;\n\tcfg->codec_initdata_size = 0;\n\tcfg->codec_initdata = NULL;\n\treturn cfg;\n}\n\nGF_EXPORT\nvoid gf_odf_vp_cfg_del(GF_VPConfig *cfg)\n{\n\tif (!cfg) return;\n\n\tif (cfg->codec_initdata) {\n\t\tgf_free(cfg->codec_initdata);\n\t\tcfg->codec_initdata = NULL;\n\t}\n\n\tgf_free(cfg);\n}\n\nGF_EXPORT\nGF_Err gf_odf_vp_cfg_write_bs(GF_VPConfig *cfg, GF_BitStream *bs, Bool is_v0)\n{\n\tgf_bs_write_int(bs, cfg->profile, 8);\n\tgf_bs_write_int(bs, cfg->level, 8);\n\tgf_bs_write_int(bs, cfg->bit_depth, 4);\n\tgf_bs_write_int(bs, cfg->chroma_subsampling, 3);\n\tgf_bs_write_int(bs, cfg->video_fullRange_flag, 1);\n\tgf_bs_write_int(bs, cfg->colour_primaries, 8);\n\tgf_bs_write_int(bs, cfg->transfer_characteristics, 8);\n\tgf_bs_write_int(bs, cfg->matrix_coefficients, 8);\n\n\tif (!is_v0) {\n\t\tif (cfg->codec_initdata_size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] VP Configuration Box: invalid data, codec_initdata_size must be 0, was %d - ignoring\\n\", cfg->codec_initdata_size));\n\t\t}\n\n\t\tgf_bs_write_int(bs, (u16)0, 16);\n\t}\n\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_odf_vp_cfg_write(GF_VPConfig *cfg, u8 **outData, u32 *outSize, Bool is_v0)\n{\n\tGF_Err e;\n\tGF_BitStream *bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t*outSize = 0;\n\t*outData = NULL;\n\te = gf_odf_vp_cfg_write_bs(cfg, bs, is_v0);\n\tif (e==GF_OK)\n\t\tgf_bs_get_content(bs, outData, outSize);\n\n\tgf_bs_del(bs);\n\treturn e;\n}\n\nGF_EXPORT\nGF_VPConfig *gf_odf_vp_cfg_read_bs(GF_BitStream *bs, Bool is_v0)\n{\n\tGF_VPConfig *cfg = gf_odf_vp_cfg_new();\n\n\tcfg->profile = gf_bs_read_int(bs, 8);\n\tcfg->level = gf_bs_read_int(bs, 8);\n\n\tcfg->bit_depth = gf_bs_read_int(bs, 4);\n\tcfg->chroma_subsampling = gf_bs_read_int(bs, 3);\n\tcfg->video_fullRange_flag = gf_bs_read_int(bs, 1);\n\n\tcfg->colour_primaries = gf_bs_read_int(bs, 8);\n\tcfg->transfer_characteristics = gf_bs_read_int(bs, 8);\n\tcfg->matrix_coefficients = gf_bs_read_int(bs, 8);\n\n\tif (is_v0)\n\t\treturn cfg;\n\n\tcfg->codec_initdata_size = gf_bs_read_int(bs, 16);\n\n\t// must be 0 according to spec\n\tif (cfg->codec_initdata_size) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] VP Configuration Box: invalid data, codec_initdata_size must be 0, was %d\\n\", cfg->codec_initdata_size));\n\t\tgf_odf_vp_cfg_del(cfg);\n\t\treturn NULL;\n\t}\n\n\treturn cfg;\n}\n\nGF_EXPORT\nGF_VPConfig *gf_odf_vp_cfg_read(u8 *dsi, u32 dsi_size)\n{\n\tGF_BitStream *bs = gf_bs_new(dsi, dsi_size, GF_BITSTREAM_READ);\n\tGF_VPConfig *cfg = gf_odf_vp_cfg_read_bs(bs, GF_FALSE);\n\tgf_bs_del(bs);\n\treturn cfg;\n}\n\nGF_EXPORT\nGF_AV1Config *gf_odf_av1_cfg_read_bs_size(GF_BitStream *bs, u32 size)\n{\n#ifndef GPAC_DISABLE_AV_PARSERS\n\tAV1State state;\n\tu8 reserved;\n\tGF_AV1Config *cfg;\n\n\tif (!size) size = (u32) gf_bs_available(bs);\n\tif (!size) return NULL;\n\n\tcfg = gf_odf_av1_cfg_new();\n\tgf_av1_init_state(&state);\n\tstate.config = cfg;\n\n\tcfg->marker = gf_bs_read_int(bs, 1);\n\tcfg->version = gf_bs_read_int(bs, 7);\n\tcfg->seq_profile = gf_bs_read_int(bs, 3);\n\tcfg->seq_level_idx_0 = gf_bs_read_int(bs, 5);\n\tcfg->seq_tier_0 = gf_bs_read_int(bs, 1);\n\tcfg->high_bitdepth = gf_bs_read_int(bs, 1);\n\tcfg->twelve_bit = gf_bs_read_int(bs, 1);\n\tcfg->monochrome = gf_bs_read_int(bs, 1);\n\tcfg->chroma_subsampling_x = gf_bs_read_int(bs, 1);\n\tcfg->chroma_subsampling_y = gf_bs_read_int(bs, 1);\n\tcfg->chroma_sample_position = gf_bs_read_int(bs, 2);\n\n\treserved = gf_bs_read_int(bs, 3);\n\tif (reserved != 0 || cfg->marker != 1 || cfg->version != 1) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[AV1] wrong avcC reserved %d / marker %d / version %d expecting 0 1 1\\n\", reserved, cfg->marker, cfg->version));\n\t\tgf_odf_av1_cfg_del(cfg);\n\t\treturn NULL;\n\t}\n\tcfg->initial_presentation_delay_present = gf_bs_read_int(bs, 1);\n\tif (cfg->initial_presentation_delay_present) {\n\t\tcfg->initial_presentation_delay_minus_one = gf_bs_read_int(bs, 4);\n\t} else {\n\t\t/*reserved = */gf_bs_read_int(bs, 4);\n\t\tcfg->initial_presentation_delay_minus_one = 0;\n\t}\n\tsize -= 4;\n\n\twhile (size) {\n\t\tu64 pos, obu_size;\n\t\tObuType obu_type;\n\t\tGF_AV1_OBUArrayEntry *a;\n\n\t\tpos = gf_bs_get_position(bs);\n\t\tobu_size = 0;\n\t\tif (gf_av1_parse_obu(bs, &obu_type, &obu_size, NULL, &state) != GF_OK) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[AV1] could not parse AV1 OBU at position \"LLU\". Leaving parsing.\\n\", pos));\n\t\t\tbreak;\n\t\t}\n\t\tassert(obu_size == gf_bs_get_position(bs) - pos);\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[AV1] parsed AV1 OBU type=%u size=\"LLU\" at position \"LLU\".\\n\", obu_type, obu_size, pos));\n\n\t\tif (!av1_is_obu_header(obu_type)) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[AV1] AV1 unexpected OBU type=%u size=\"LLU\" found at position \"LLU\". Forwarding.\\n\", pos));\n\t\t}\n\t\tGF_SAFEALLOC(a, GF_AV1_OBUArrayEntry);\n\t\tif (!a) break;\n\t\ta->obu = gf_malloc((size_t)obu_size);\n\t\tif (!a->obu) {\n\t\t\tgf_free(a);\n\t\t\tbreak;\n\t\t}\n\t\tgf_bs_seek(bs, pos);\n\t\tgf_bs_read_data(bs, (char *) a->obu, (u32)obu_size);\n\t\ta->obu_length = obu_size;\n\t\ta->obu_type = obu_type;\n\t\tgf_list_add(cfg->obu_array, a);\n\n\t\tif (size<obu_size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[AV1] AV1 config misses %d bytes to fit the entire OBU\\n\", obu_size - size));\n\t\t\tbreak;\n\t\t}\n\t\tsize -= (u32) obu_size;\n\t}\n\tgf_av1_reset_state(& state, GF_TRUE);\n\treturn cfg;\n#else\n\treturn NULL;\n#endif\n}\n\nGF_EXPORT\nGF_AV1Config *gf_odf_av1_cfg_read_bs(GF_BitStream *bs)\n{\n\treturn gf_odf_av1_cfg_read_bs_size(bs, 0);\n\n}\nGF_EXPORT\nGF_AV1Config *gf_odf_av1_cfg_read(u8 *dsi, u32 dsi_size)\n{\n\tGF_BitStream *bs = gf_bs_new(dsi, dsi_size, GF_BITSTREAM_READ);\n\tGF_AV1Config *cfg = gf_odf_av1_cfg_read_bs(bs);\n\tgf_bs_del(bs);\n\treturn cfg;\n}\n\nGF_DOVIDecoderConfigurationRecord *gf_odf_dovi_cfg_read_bs(GF_BitStream *bs)\n{\n\tGF_DOVIDecoderConfigurationRecord *cfg;\n\tGF_SAFEALLOC(cfg, GF_DOVIDecoderConfigurationRecord);\n\n\tcfg->dv_version_major = gf_bs_read_u8(bs);\n\tcfg->dv_version_minor = gf_bs_read_u8(bs);\n\tcfg->dv_profile = gf_bs_read_int(bs, 7);\n\tcfg->dv_level = gf_bs_read_int(bs, 6);\n\tcfg->rpu_present_flag = gf_bs_read_int(bs, 1);\n\tcfg->el_present_flag = gf_bs_read_int(bs, 1);\n\tcfg->bl_present_flag = gf_bs_read_int(bs, 1);\n\t{\n\t\tint i = 0;\n\t\tu32 data[5];\n\t\tmemset(data, 0, sizeof(data));\n\t\tgf_bs_read_data(bs, (char*)data, 20);\n\t\tfor (i = 0; i < 5; ++i) {\n\t\t\tif (data[i] != 0) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[odf_cfg] dovi config reserved bytes are not zero\\n\"));\n\t\t\t}\n\t\t}\n\t}\n\treturn cfg;\n}\n\nvoid gf_odf_dovi_cfg_del(GF_DOVIDecoderConfigurationRecord *cfg)\n{\n\tgf_free(cfg);\n}\n\nGF_Err gf_odf_dovi_cfg_write_bs(GF_DOVIDecoderConfigurationRecord *cfg, GF_BitStream *bs)\n{\n\tgf_bs_write_u8(bs,  cfg->dv_version_major);\n\tgf_bs_write_u8(bs,  cfg->dv_version_minor);\n\tgf_bs_write_int(bs, cfg->dv_profile, 7);\n\tgf_bs_write_int(bs, cfg->dv_level, 6);\n\tgf_bs_write_int(bs, cfg->rpu_present_flag, 1);\n\tgf_bs_write_int(bs, cfg->el_present_flag, 1);\n\tgf_bs_write_int(bs, cfg->bl_present_flag, 1);\n    gf_bs_write_u32(bs, 0);\n    gf_bs_write_u32(bs, 0);\n    gf_bs_write_u32(bs, 0);\n    gf_bs_write_u32(bs, 0);\n    gf_bs_write_u32(bs, 0);\n\treturn GF_OK;\n}\n\n\nGF_Err gf_odf_ac3_cfg_write_bs(GF_AC3Config *cfg, GF_BitStream *bs)\n{\n\tif (!cfg || !bs) return GF_BAD_PARAM;\n\n\tif (cfg->is_ec3) {\n\t\tu32 i;\n\t\tgf_bs_write_int(bs, cfg->brcode, 13);\n\t\tgf_bs_write_int(bs, cfg->nb_streams - 1, 3);\n\t\tfor (i=0; i<cfg->nb_streams; i++) {\n\t\t\tgf_bs_write_int(bs, cfg->streams[i].fscod, 2);\n\t\t\tgf_bs_write_int(bs, cfg->streams[i].bsid, 5);\n\t\t\tgf_bs_write_int(bs, cfg->streams[i].bsmod, 5);\n\t\t\tgf_bs_write_int(bs, cfg->streams[i].acmod, 3);\n\t\t\tgf_bs_write_int(bs, cfg->streams[i].lfon, 1);\n\t\t\tgf_bs_write_int(bs, 0, 3);\n\t\t\tgf_bs_write_int(bs, cfg->streams[i].nb_dep_sub, 4);\n\t\t\tif (cfg->streams[i].nb_dep_sub) {\n\t\t\t\tgf_bs_write_int(bs, cfg->streams[i].chan_loc, 9);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_int(bs, 0, 1);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tgf_bs_write_int(bs, cfg->streams[0].fscod, 2);\n\t\tgf_bs_write_int(bs, cfg->streams[0].bsid, 5);\n\t\tgf_bs_write_int(bs, cfg->streams[0].bsmod, 3);\n\t\tgf_bs_write_int(bs, cfg->streams[0].acmod, 3);\n\t\tgf_bs_write_int(bs, cfg->streams[0].lfon, 1);\n\t\tgf_bs_write_int(bs, cfg->brcode, 5);\n\t\tgf_bs_write_int(bs, 0, 5);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err gf_odf_ac3_cfg_write(GF_AC3Config *cfg, u8 **data, u32 *size)\n{\n\tGF_BitStream *bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tGF_Err e = gf_odf_ac3_cfg_write_bs(cfg, bs);\n\n\tgf_bs_get_content(bs, data, size);\n\tgf_bs_del(bs);\n\treturn e;\n}\n\nGF_Err gf_odf_ac3_config_parse_bs(GF_BitStream *bs, Bool is_ec3, GF_AC3Config *cfg)\n{\n\tif (!cfg || !bs) return GF_BAD_PARAM;\n\tmemset(cfg, 0, sizeof(GF_AC3Config));\n\tcfg->is_ec3 = is_ec3;\n\tif (is_ec3) {\n\t\tu32 j;\n\t\tcfg->is_ec3 = 1;\n\t\tcfg->brcode = gf_bs_read_int(bs, 13);\n\t\tcfg->nb_streams = 1 + gf_bs_read_int(bs, 3);\n\t\tfor (j=0; j<cfg->nb_streams; j++) {\n\t\t\tcfg->streams[j].fscod = gf_bs_read_int(bs, 2);\n\t\t\tcfg->streams[j].bsid = gf_bs_read_int(bs, 5);\n\t\t\tgf_bs_read_int(bs, 1);\n\t\t\tcfg->streams[j].asvc = gf_bs_read_int(bs, 1);\n\t\t\tcfg->streams[j].bsmod = gf_bs_read_int(bs, 3);\n\t\t\tcfg->streams[j].acmod = gf_bs_read_int(bs, 3);\n\t\t\tcfg->streams[j].lfon = gf_bs_read_int(bs, 1);\n\t\t\tgf_bs_read_int(bs, 3);\n\t\t\tcfg->streams[j].nb_dep_sub = gf_bs_read_int(bs, 4);\n\t\t\tif (cfg->streams[j].nb_dep_sub) {\n\t\t\t\tcfg->streams[j].chan_loc = gf_bs_read_int(bs, 9);\n\t\t\t} else {\n\t\t\t\tgf_bs_read_int(bs, 1);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tcfg->nb_streams = 1;\n\t\tcfg->streams[0].fscod = gf_bs_read_int(bs, 2);\n\t\tcfg->streams[0].bsid = gf_bs_read_int(bs, 5);\n\t\tcfg->streams[0].bsmod = gf_bs_read_int(bs, 3);\n\t\tcfg->streams[0].acmod = gf_bs_read_int(bs, 3);\n\t\tcfg->streams[0].lfon = gf_bs_read_int(bs, 1);\n\t\tcfg->brcode = gf_bs_read_int(bs, 5);\n\t\tgf_bs_read_int(bs, 5);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err gf_odf_ac3_config_parse(u8 *dsi, u32 dsi_len, Bool is_ec3, GF_AC3Config *cfg)\n{\n\tGF_BitStream *bs;\n\tGF_Err e;\n\tif (!cfg || !dsi) return GF_BAD_PARAM;\n\tbs = gf_bs_new(dsi, dsi_len, GF_BITSTREAM_READ);\n\te = gf_odf_ac3_config_parse_bs(bs, is_ec3, cfg);\n\tgf_bs_del(bs);\n\treturn e;\n}\n"], "fixing_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2012\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / MPEG-4 ObjectDescriptor sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/odf_dev.h>\n#include <gpac/constants.h>\n\n#include <gpac/avparse.h>\n\n#ifndef GPAC_DISABLE_AV_PARSERS\n#include <gpac/internal/media_dev.h>\n#endif\n\ns32 gf_odf_size_field_size(u32 size_desc)\n{\n\tif (size_desc < 0x00000080) {\n\t\treturn 1 + 1;\n\t} else if (size_desc < 0x00004000) {\n\t\treturn 2 + 1;\n\t} else if (size_desc < 0x00200000) {\n\t\treturn 3 + 1;\n\t} else if (size_desc < 0x10000000) {\n\t\treturn 4 + 1;\n\t} else {\n\t\treturn -1;\n\t}\n\n}\n\n\nGF_EXPORT\nGF_Err gf_odf_parse_descriptor(GF_BitStream *bs, GF_Descriptor **desc, u32 *desc_size)\n{\n\tu32 val, size, sizeHeader;\n\tu8 tag;\n\tGF_Err err;\n\tGF_Descriptor *newDesc;\n\tif (!bs) return GF_BAD_PARAM;\n\n\t*desc_size = 0;\n\n\t//tag\n\ttag = (u8) gf_bs_read_int(bs, 8);\n\tsizeHeader = 1;\n\n\t//size\n\tsize = 0;\n\tdo {\n\t\tval = gf_bs_read_int(bs, 8);\n\t\tsizeHeader++;\n\t\tif (sizeHeader > 5) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODEC, (\"[ODF] Descriptor size on more than 4 bytes\\n\"));\n\t\t\treturn GF_ODF_INVALID_DESCRIPTOR;\n\t\t}\n\t\tsize <<= 7;\n\t\tsize |= val & 0x7F;\n\t} while ( val & 0x80);\n\t*desc_size = size;\n\n\tif (gf_bs_available(bs) < size) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODEC, (\"[ODF] Not enough bytes (%d) to read descriptor (size=%d)\\n\", gf_bs_available(bs), size));\n\t\treturn GF_ODF_INVALID_DESCRIPTOR;\n\t}\n\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CODEC, (\"[ODF] Reading descriptor (tag %d size %d)\\n\", tag, size ));\n\n\tnewDesc = gf_odf_create_descriptor(tag);\n\tif (! newDesc) {\n\t\t*desc = NULL;\n\t\t*desc_size = sizeHeader;\n\t\tif ( (tag >= GF_ODF_ISO_RES_BEGIN_TAG) &&\n\t\t        (tag <= GF_ODF_ISO_RES_END_TAG) ) {\n\t\t\treturn GF_ODF_FORBIDDEN_DESCRIPTOR;\n\t\t}\n\t\telse if (!tag || (tag == 0xFF)) {\n\t\t\treturn GF_ODF_INVALID_DESCRIPTOR;\n\t\t}\n#ifndef GPAC_MINIMAL_ODF\n\t\treturn GF_OUT_OF_MEM;\n#else\n\t\tgf_bs_skip_bytes(bs, size);\n\t\t*desc_size = size + sizeHeader - gf_odf_size_field_size(*desc_size);\n\t\treturn GF_OK;\n#endif\n\t}\n\n\tnewDesc->tag = tag;\n\terr = gf_odf_read_descriptor(bs, newDesc, *desc_size);\n\n\t/*FFMPEG fix*/\n\tif ((tag==GF_ODF_SLC_TAG) && (((GF_SLConfig*)newDesc)->predefined==2)) {\n\t\tif (*desc_size==3) {\n\t\t\t*desc_size = 1;\n\t\t\terr = GF_OK;\n\t\t}\n\t}\n\n\t//little trick to handle lazy bitstreams that encode\n\t//SizeOfInstance on a fix number of bytes\n\t//This nb of bytes is added in Read methods\n\t*desc_size += sizeHeader - gf_odf_size_field_size(*desc_size);\n\t*desc = newDesc;\n\tif (err) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODEC, (\"[ODF] Error reading descriptor (tag %d size %d): %s\\n\", tag, size, gf_error_to_string(err) ));\n\t\tgf_odf_delete_descriptor(newDesc);\n\t\t*desc = NULL;\n\t}\n\treturn err;\n}\n\n\n\nGF_Err gf_odf_delete_descriptor_list(GF_List *descList)\n{\n\tGF_Err e;\n\tGF_Descriptor*tmp;\n\tu32 i;\n\t//no error if NULL chain...\n\tif (! descList) return GF_OK;\n\ti=0;\n\twhile ((tmp = (GF_Descriptor*)gf_list_enum(descList, &i))) {\n\t\te = gf_odf_delete_descriptor(tmp);\n\t\tif (e) return e;\n\t}\n\tgf_list_del(descList);\n\treturn GF_OK;\n}\n\nGF_Err gf_odf_write_base_descriptor(GF_BitStream *bs, u8 tag, u32 size)\n{\n\tu32 length;\n\tunsigned char vals[4];\n\n\tif (!tag ) return GF_BAD_PARAM;\n\n\tlength = size;\n\tvals[3] = (unsigned char) (length & 0x7f);\n\tlength >>= 7;\n\tvals[2] = (unsigned char) ((length & 0x7f) | 0x80);\n\tlength >>= 7;\n\tvals[1] = (unsigned char) ((length & 0x7f) | 0x80);\n\tlength >>= 7;\n\tvals[0] = (unsigned char) ((length & 0x7f) | 0x80);\n\n\tgf_bs_write_int(bs, tag, 8);\n\tif (size < 0x00000080) {\n\t\tgf_bs_write_int(bs, vals[3], 8);\n\t} else if (size < 0x00004000) {\n\t\tgf_bs_write_int(bs, vals[2], 8);\n\t\tgf_bs_write_int(bs, vals[3], 8);\n\t} else if (size < 0x00200000) {\n\t\tgf_bs_write_int(bs, vals[1], 8);\n\t\tgf_bs_write_int(bs, vals[2], 8);\n\t\tgf_bs_write_int(bs, vals[3], 8);\n\t} else if (size < 0x10000000) {\n\t\tgf_bs_write_int(bs, vals[0], 8);\n\t\tgf_bs_write_int(bs, vals[1], 8);\n\t\tgf_bs_write_int(bs, vals[2], 8);\n\t\tgf_bs_write_int(bs, vals[3], 8);\n\t} else {\n\t\treturn GF_ODF_INVALID_DESCRIPTOR;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err gf_odf_size_descriptor_list(GF_List *descList, u32 *outSize)\n{\n\tGF_Err e;\n\tu32 tmpSize, count, i;\n\tif (! descList) return GF_OK;\n\n\tcount = gf_list_count(descList);\n\tfor ( i = 0; i < count; i++ ) {\n\t\tGF_Descriptor *tmp = (GF_Descriptor*)gf_list_get(descList, i);\n\t\tif (tmp) {\n\t\t\te = gf_odf_size_descriptor(tmp, &tmpSize);\n\t\t\tif (e) return e;\n\t\t\tif (tmpSize) *outSize += tmpSize + gf_odf_size_field_size(tmpSize);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err gf_odf_write_descriptor_list(GF_BitStream *bs, GF_List *descList)\n{\n\tGF_Err e;\n\tu32 count, i;\n\n\tif (! descList) return GF_OK;\n\tcount = gf_list_count(descList);\n\tfor ( i = 0; i < count; i++ ) {\n\t\tGF_Descriptor *tmp = (GF_Descriptor*)gf_list_get(descList, i);\n\t\tif (tmp) {\n\t\t\te = gf_odf_write_descriptor(bs, tmp);\n\t\t\tif (e) return e;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err gf_odf_write_descriptor_list_filter(GF_BitStream *bs, GF_List *descList, u8 only_tag)\n{\n\tGF_Err e;\n\tu32 count, i;\n\n\tif (! descList) return GF_OK;\n\tcount = gf_list_count(descList);\n\tfor ( i = 0; i < count; i++ ) {\n\t\tGF_Descriptor *tmp = (GF_Descriptor*)gf_list_get(descList, i);\n\t\tif (tmp && (tmp->tag==only_tag) ) {\n\t\t\te = gf_odf_write_descriptor(bs, tmp);\n\t\t\tif (e) return e;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_MINIMAL_ODF\n\nu32 gf_ipmpx_array_size(GF_BitStream *bs, u32 *array_size)\n{\n\tu32 val, size, io_size;\n\n\tio_size = size = 0;\n\tdo {\n\t\tval = gf_bs_read_int(bs, 8);\n\t\tio_size ++;\n\t\tsize <<= 7;\n\t\tsize |= val & 0x7F;\n\t} while ( val & 0x80 );\n\t*array_size = size;\n\treturn io_size;\n}\n\nvoid gf_ipmpx_write_array(GF_BitStream *bs, u8 *data, u32 data_len)\n{\n\tu32 length;\n\tunsigned char vals[4];\n\n\tif (!data || !data_len) return;\n\n\tlength = data_len;\n\tvals[3] = (unsigned char) (length & 0x7f);\n\tlength >>= 7;\n\tvals[2] = (unsigned char) ((length & 0x7f) | 0x80);\n\tlength >>= 7;\n\tvals[1] = (unsigned char) ((length & 0x7f) | 0x80);\n\tlength >>= 7;\n\tvals[0] = (unsigned char) ((length & 0x7f) | 0x80);\n\n\tif (data_len < 0x00000080) {\n\t\tgf_bs_write_int(bs, vals[3], 8);\n\t} else if (data_len < 0x00004000) {\n\t\tgf_bs_write_int(bs, vals[2], 8);\n\t\tgf_bs_write_int(bs, vals[3], 8);\n\t} else if (data_len < 0x00200000) {\n\t\tgf_bs_write_int(bs, vals[1], 8);\n\t\tgf_bs_write_int(bs, vals[2], 8);\n\t\tgf_bs_write_int(bs, vals[3], 8);\n\t} else if (data_len < 0x10000000) {\n\t\tgf_bs_write_int(bs, vals[0], 8);\n\t\tgf_bs_write_int(bs, vals[1], 8);\n\t\tgf_bs_write_int(bs, vals[2], 8);\n\t\tgf_bs_write_int(bs, vals[3], 8);\n\t} else {\n\t\treturn;\n\t}\n\tgf_bs_write_data(bs, data, data_len);\n}\n\n\n#endif /*GPAC_MINIMAL_ODF*/\n\n/*special authoring functions*/\nGF_EXPORT\nGF_BIFSConfig *gf_odf_get_bifs_config(GF_DefaultDescriptor *dsi, u32 oti)\n{\n\tBool hasSize, cmd_stream;\n\tGF_BitStream *bs;\n\tGF_BIFSConfig *cfg;\n\n\tif (oti>=GF_CODECID_BIFS_EXTENDED) return NULL;\n\n\tif (!dsi || !dsi->data || !dsi->dataLength ) {\n\t\t/* Hack for T-DMB non compliant streams (OnTimeTek ?) */\n\t\tcfg = (GF_BIFSConfig *) gf_odf_desc_new(GF_ODF_BIFS_CFG_TAG);\n\t\tcfg->pixelMetrics = GF_TRUE;\n\t\tcfg->version = 1;\n\t\treturn cfg;\n\t}\n\tbs = gf_bs_new(dsi->data, dsi->dataLength, GF_BITSTREAM_READ);\n\n\tcfg = (GF_BIFSConfig *) gf_odf_desc_new(GF_ODF_BIFS_CFG_TAG);\n\tif (oti==2) {\n\t\t/*3D Mesh Coding*/\n\t\tgf_bs_read_int(bs, 1);\n\t\t/*PMF*/\n\t\tgf_bs_read_int(bs, 1);\n\t}\n\tcfg->nodeIDbits = gf_bs_read_int(bs, 5);\n\tcfg->routeIDbits = gf_bs_read_int(bs, 5);\n\tif (oti==2) cfg->protoIDbits = gf_bs_read_int(bs, 5);\n\n\tcmd_stream = (Bool)gf_bs_read_int(bs, 1);\n\tif (!cmd_stream) {\n\t\tcfg->elementaryMasks = gf_list_new();\n\t\twhile (1) {\n\t\t\tGF_ElementaryMask* em = (GF_ElementaryMask* ) gf_odf_New_ElemMask();\n\t\t\tem->node_id = gf_bs_read_int(bs, cfg->nodeIDbits);\n\t\t\tgf_list_add(cfg->elementaryMasks, em);\n\t\t\t/*this assumes only FDP, BDP and IFS2D (no elem mask)*/\n\t\t\tif (gf_bs_read_int(bs, 1) == 0) break;\n\t\t}\n\t\tgf_bs_align(bs);\n\t\tif (gf_bs_get_size(bs) != gf_bs_get_position(bs)) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODEC, (\"[ODF] Reading bifs config: shift in sizes (not supported)\\n\"));\n\t\t}\n\t} else {\n\t\tcfg->pixelMetrics = (Bool)gf_bs_read_int(bs, 1);\n\t\thasSize = (Bool)gf_bs_read_int(bs, 1);\n\t\tif (hasSize) {\n\t\t\tcfg->pixelWidth = gf_bs_read_int(bs, 16);\n\t\t\tcfg->pixelHeight = gf_bs_read_int(bs, 16);\n\t\t}\n\t\tgf_bs_align(bs);\n\t\tif (gf_bs_get_size(bs) != gf_bs_get_position(bs))\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODEC, (\"[ODF] Reading bifs config: shift in sizes (invalid descriptor)\\n\"));\n\t}\n\tgf_bs_del(bs);\n\treturn cfg;\n}\n\n/*special function for authoring - convert DSI to LASERConfig*/\nGF_EXPORT\nGF_Err gf_odf_get_laser_config(GF_DefaultDescriptor *dsi, GF_LASERConfig *cfg)\n{\n\tu32 to_skip;\n\tGF_BitStream *bs;\n\n\tif (!cfg) return GF_BAD_PARAM;\n\tmemset(cfg, 0, sizeof(GF_LASERConfig));\n\n\tif (!dsi || !dsi->data || !dsi->dataLength) return GF_BAD_PARAM;\n\tbs = gf_bs_new(dsi->data, dsi->dataLength, GF_BITSTREAM_READ);\n\tmemset(cfg, 0, sizeof(GF_LASERConfig));\n\tcfg->tag = GF_ODF_LASER_CFG_TAG;\n\tcfg->profile = gf_bs_read_int(bs, 8);\n\tcfg->level = gf_bs_read_int(bs, 8);\n\t/*cfg->reserved = */gf_bs_read_int(bs, 3);\n\tcfg->pointsCodec = gf_bs_read_int(bs, 2);\n\tcfg->pathComponents = gf_bs_read_int(bs, 4);\n\tcfg->fullRequestHost = gf_bs_read_int(bs, 1);\n\tif (gf_bs_read_int(bs, 1)) cfg->time_resolution = gf_bs_read_int(bs, 16);\n\telse cfg->time_resolution = 1000;\n\tcfg->colorComponentBits = 1 + gf_bs_read_int(bs, 4);\n\tcfg->resolution = gf_bs_read_int(bs, 4);\n\tif (cfg->resolution>7) cfg->resolution -= 16;\n\tcfg->coord_bits = gf_bs_read_int(bs, 5);\n\tcfg->scale_bits_minus_coord_bits = gf_bs_read_int(bs, 4);\n\tcfg->newSceneIndicator = gf_bs_read_int(bs, 1);\n\t/*reserved2*/ gf_bs_read_int(bs, 3);\n\tcfg->extensionIDBits = gf_bs_read_int(bs, 4);\n\t/*hasExtConfig - we just ignore it*/\n\tif (gf_bs_read_int(bs, 1)) {\n\t\tto_skip = gf_bs_read_vluimsbf5(bs);\n\t\twhile (to_skip) {\n\t\t\tgf_bs_read_int(bs, 8);\n\t\t\tto_skip--;\n\t\t}\n\t}\n\t/*hasExtension - we just ignore it*/\n\tif (gf_bs_read_int(bs, 1)) {\n\t\tto_skip = gf_bs_read_vluimsbf5(bs);\n\t\twhile (to_skip) {\n\t\t\tgf_bs_read_int(bs, 8);\n\t\t\tto_skip--;\n\t\t}\n\t}\n\tgf_bs_del(bs);\n\treturn GF_OK;\n}\n//unused\n#if 0\nGF_Err gf_odf_get_ui_config(GF_DefaultDescriptor *dsi, GF_UIConfig *cfg)\n{\n\tu32 len, i;\n\tGF_BitStream *bs;\n\tif (!dsi || !dsi->data || !dsi->dataLength || !cfg) return GF_BAD_PARAM;\n\tmemset(cfg, 0, sizeof(GF_UIConfig));\n\tcfg->tag = GF_ODF_UI_CFG_TAG;\n\tbs = gf_bs_new(dsi->data, dsi->dataLength, GF_BITSTREAM_READ);\n\tlen = gf_bs_read_int(bs, 8);\n\tcfg->deviceName = (char*)gf_malloc(sizeof(char) * (len+1));\n\tfor (i=0; i<len; i++) cfg->deviceName[i] = gf_bs_read_int(bs, 8);\n\tcfg->deviceName[i] = 0;\n\n\tif (!stricmp(cfg->deviceName, \"StringSensor\") && gf_bs_available(bs)) {\n\t\tcfg->termChar = gf_bs_read_int(bs, 8);\n\t\tcfg->delChar = gf_bs_read_int(bs, 8);\n\t}\n\tgf_bs_del(bs);\n\treturn GF_OK;\n}\n#endif\n\nGF_EXPORT\nGF_Err gf_odf_encode_ui_config(GF_UIConfig *cfg, GF_DefaultDescriptor **out_dsi)\n{\n\tu32 i, len;\n\tGF_BitStream *bs;\n\tGF_DefaultDescriptor *dsi;\n\tif (!out_dsi || (cfg->tag != GF_ODF_UI_CFG_TAG)) return GF_BAD_PARAM;\n\n\t*out_dsi = NULL;\n\tif (!cfg->deviceName) return GF_OK;\n\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tlen = (u32) strlen(cfg->deviceName);\n\tgf_bs_write_int(bs, len, 8);\n\tfor (i=0; i<len; i++) gf_bs_write_int(bs, cfg->deviceName[i], 8);\n\tif (!stricmp(cfg->deviceName, \"StringSensor\")) {\n\t\t/*fixme - this should be UTF-8 chars*/\n\t\tif (cfg->delChar || cfg->termChar) {\n\t\t\tgf_bs_write_int(bs, cfg->termChar, 8);\n\t\t\tgf_bs_write_int(bs, cfg->delChar, 8);\n\t\t}\n\t}\n\tif (cfg->ui_data) gf_bs_write_data(bs, cfg->ui_data, cfg->ui_data_length);\n\n\tdsi = (GF_DefaultDescriptor *) gf_odf_desc_new(GF_ODF_DSI_TAG);\n\tgf_bs_get_content(bs, &dsi->data, &dsi->dataLength);\n\tgf_bs_del(bs);\n\t*out_dsi = dsi;\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_AVCConfig *gf_odf_avc_cfg_new()\n{\n\tGF_AVCConfig *cfg;\n\tGF_SAFEALLOC(cfg, GF_AVCConfig);\n\tif (!cfg) return NULL;\n\tcfg->sequenceParameterSets = gf_list_new();\n\tcfg->pictureParameterSets = gf_list_new();\n\tcfg->AVCLevelIndication = 1;\n\tcfg->chroma_format = 1;\n\tcfg->chroma_bit_depth = 8;\n\tcfg->luma_bit_depth = 8;\n\treturn cfg;\n}\n\nGF_EXPORT\nvoid gf_odf_avc_cfg_del(GF_AVCConfig *cfg)\n{\n\tif (!cfg) return;\n\twhile (gf_list_count(cfg->sequenceParameterSets)) {\n\t\tGF_NALUFFParam *sl = (GF_NALUFFParam *)gf_list_get(cfg->sequenceParameterSets, 0);\n\t\tgf_list_rem(cfg->sequenceParameterSets, 0);\n\t\tif (sl->data) gf_free(sl->data);\n\t\tgf_free(sl);\n\t}\n\tgf_list_del(cfg->sequenceParameterSets);\n\tcfg->sequenceParameterSets = NULL;\n\n\twhile (gf_list_count(cfg->pictureParameterSets)) {\n\t\tGF_NALUFFParam *sl = (GF_NALUFFParam *)gf_list_get(cfg->pictureParameterSets, 0);\n\t\tgf_list_rem(cfg->pictureParameterSets, 0);\n\t\tif (sl->data) gf_free(sl->data);\n\t\tgf_free(sl);\n\t}\n\tgf_list_del(cfg->pictureParameterSets);\n\tcfg->pictureParameterSets = NULL;\n\n\tif (cfg->sequenceParameterSetExtensions) {\n\t\twhile (gf_list_count(cfg->sequenceParameterSetExtensions)) {\n\t\t\tGF_NALUFFParam *sl = (GF_NALUFFParam *)gf_list_get(cfg->sequenceParameterSetExtensions, 0);\n\t\t\tgf_list_rem(cfg->sequenceParameterSetExtensions, 0);\n\t\t\tif (sl->data) gf_free(sl->data);\n\t\t\tgf_free(sl);\n\t\t}\n\t\tgf_list_del(cfg->sequenceParameterSetExtensions);\n\t\tcfg->sequenceParameterSetExtensions = NULL;\n\t}\n\tgf_free(cfg);\n}\n\nGF_EXPORT\nGF_Err gf_odf_avc_cfg_write_bs(GF_AVCConfig *cfg, GF_BitStream *bs)\n{\n\tu32 i, count;\n\n\tif (!cfg) return GF_BAD_PARAM;\n\n\tcount = gf_list_count(cfg->sequenceParameterSets);\n\n\tif (!cfg->write_annex_b) {\n\t\tgf_bs_write_int(bs, cfg->configurationVersion, 8);\n\t\tgf_bs_write_int(bs, cfg->AVCProfileIndication , 8);\n\t\tgf_bs_write_int(bs, cfg->profile_compatibility, 8);\n\t\tgf_bs_write_int(bs, cfg->AVCLevelIndication, 8);\n\t\tgf_bs_write_int(bs, 0x3F, 6);\n\t\tgf_bs_write_int(bs, cfg->nal_unit_size - 1, 2);\n\t\tgf_bs_write_int(bs, 0x7, 3);\n\t\tgf_bs_write_int(bs, count, 5);\n\t}\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParam *sl = (GF_NALUFFParam *)gf_list_get(cfg->sequenceParameterSets, i);\n\t\tif (!cfg->write_annex_b) {\n\t\t\tgf_bs_write_u16(bs, sl->size);\n\t\t} else {\n\t\t\tgf_bs_write_u32(bs, 1);\n\t\t}\n\t\tgf_bs_write_data(bs, sl->data, sl->size);\n\t}\n\tcount = gf_list_count(cfg->pictureParameterSets);\n\tif (!cfg->write_annex_b) {\n\t\tgf_bs_write_int(bs, count, 8);\n\t}\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParam *sl = (GF_NALUFFParam *)gf_list_get(cfg->pictureParameterSets, i);\n\t\tif (!cfg->write_annex_b) {\n\t\t\tgf_bs_write_u16(bs, sl->size);\n\t\t} else {\n\t\t\tgf_bs_write_u32(bs, 1);\n\t\t}\n\t\tgf_bs_write_data(bs, sl->data, sl->size);\n\t}\n\tif (gf_avc_is_rext_profile(cfg->AVCProfileIndication)) {\n\t\tif (!cfg->write_annex_b) {\n\t\t\tgf_bs_write_int(bs, 0xFF, 6);\n\t\t\tgf_bs_write_int(bs, cfg->chroma_format, 2);\n\t\t\tgf_bs_write_int(bs, 0xFF, 5);\n\t\t\tgf_bs_write_int(bs, cfg->luma_bit_depth - 8, 3);\n\t\t\tgf_bs_write_int(bs, 0xFF, 5);\n\t\t\tgf_bs_write_int(bs, cfg->chroma_bit_depth - 8, 3);\n\t\t}\n\t\tcount = cfg->sequenceParameterSetExtensions ? gf_list_count(cfg->sequenceParameterSetExtensions) : 0;\n\t\tif (!cfg->write_annex_b) {\n\t\t\tgf_bs_write_u8(bs, count);\n\t\t}\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_NALUFFParam *sl = (GF_NALUFFParam *) gf_list_get(cfg->sequenceParameterSetExtensions, i);\n\t\t\tif (!cfg->write_annex_b) {\n\t\t\t\tgf_bs_write_u16(bs, sl->size);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_u32(bs, 1);\n\t\t\t}\n\t\t\tgf_bs_write_data(bs, sl->data, sl->size);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_odf_avc_cfg_write(GF_AVCConfig *cfg, u8 **outData, u32 *outSize)\n{\n\tGF_BitStream *bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tgf_odf_avc_cfg_write_bs(cfg, bs);\n\t*outSize = 0;\n\t*outData = NULL;\n\tgf_bs_get_content(bs, outData, outSize);\n\tgf_bs_del(bs);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_AVCConfig *gf_odf_avc_cfg_read(u8 *dsi, u32 dsi_size)\n{\n\tu32 i, count;\n\tGF_AVCConfig *avcc = gf_odf_avc_cfg_new();\n\tGF_BitStream *bs = gf_bs_new(dsi, dsi_size, GF_BITSTREAM_READ);\n\tavcc->configurationVersion = gf_bs_read_int(bs, 8);\n\tavcc->AVCProfileIndication  = gf_bs_read_int(bs, 8);\n\tavcc->profile_compatibility = gf_bs_read_int(bs, 8);\n\tavcc->AVCLevelIndication  = gf_bs_read_int(bs, 8);\n\tgf_bs_read_int(bs, 6);\n\tavcc->nal_unit_size = 1 + gf_bs_read_int(bs, 2);\n\tgf_bs_read_int(bs, 3);\n\tcount = gf_bs_read_int(bs, 5);\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParam *sl = (GF_NALUFFParam *)gf_malloc(sizeof(GF_NALUFFParam));\n\t\tsl->size = gf_bs_read_int(bs, 16);\n\t\tsl->data = (char*)gf_malloc(sizeof(char)*sl->size);\n\t\tgf_bs_read_data(bs, sl->data, sl->size);\n\t\tgf_list_add(avcc->sequenceParameterSets, sl);\n\t}\n\tcount = gf_bs_read_int(bs, 8);\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParam *sl = (GF_NALUFFParam *)gf_malloc(sizeof(GF_NALUFFParam));\n\t\tsl->size = gf_bs_read_int(bs, 16);\n\t\tsl->data = (char*)gf_malloc(sizeof(char)*sl->size);\n\t\tgf_bs_read_data(bs, sl->data, sl->size);\n\t\tgf_list_add(avcc->pictureParameterSets, sl);\n\t}\n\tif (gf_avc_is_rext_profile(avcc->AVCProfileIndication)) {\n\t\tgf_bs_read_int(bs, 6);\n\t\tavcc->chroma_format = gf_bs_read_int(bs, 2);\n\t\tgf_bs_read_int(bs, 5);\n\t\tavcc->luma_bit_depth = 8 + gf_bs_read_int(bs, 3);\n\t\tgf_bs_read_int(bs, 5);\n\t\tavcc->chroma_bit_depth = 8 + gf_bs_read_int(bs, 3);\n\n\t\tcount = gf_bs_read_int(bs, 8);\n\t\tif (count) {\n\t\t\tavcc->sequenceParameterSetExtensions = gf_list_new();\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tGF_NALUFFParam *sl = (GF_NALUFFParam *)gf_malloc(sizeof(GF_NALUFFParam));\n\t\t\t\tsl->size = gf_bs_read_u16(bs);\n\t\t\t\tsl->data = (char *)gf_malloc(sizeof(char) * sl->size);\n\t\t\t\tgf_bs_read_data(bs, sl->data, sl->size);\n\t\t\t\tgf_list_add(avcc->sequenceParameterSetExtensions, sl);\n\t\t\t}\n\t\t}\n\t}\n\n\n\tgf_bs_del(bs);\n\treturn avcc;\n}\n\n\nGF_Descriptor *gf_odf_new_tx3g()\n{\n\tGF_TextSampleDescriptor *newDesc = (GF_TextSampleDescriptor*) gf_malloc(sizeof(GF_TextSampleDescriptor));\n\tif (!newDesc) return NULL;\n\tmemset(newDesc, 0, sizeof(GF_TextSampleDescriptor));\n\tnewDesc->tag = GF_ODF_TX3G_TAG;\n\treturn (GF_Descriptor *) newDesc;\n}\nGF_Err gf_odf_del_tx3g(GF_TextSampleDescriptor *sd)\n{\n\tu32 i;\n\tfor (i=0; i<sd->font_count; i++)\n\t\tif (sd->fonts[i].fontName) gf_free(sd->fonts[i].fontName);\n\tgf_free(sd->fonts);\n\tgf_free(sd);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_TextSampleDescriptor *gf_odf_tx3g_read(u8 *dsi, u32 dsi_size)\n{\n\tu32 i;\n\tu32 gpp_read_rgba(GF_BitStream *bs);\n\tvoid gpp_read_style(GF_BitStream *bs, GF_StyleRecord *rec);\n\tvoid gpp_read_box(GF_BitStream *bs, GF_BoxRecord *rec);\n\n\tGF_TextSampleDescriptor *txtc = (GF_TextSampleDescriptor *) gf_odf_new_tx3g();\n\tGF_BitStream *bs = gf_bs_new(dsi, dsi_size, GF_BITSTREAM_READ);\n\n\ttxtc->horiz_justif = gf_bs_read_int(bs, 8);\n\ttxtc->vert_justif  = gf_bs_read_int(bs, 8);\n\ttxtc->back_color = gpp_read_rgba(bs);\n\tgpp_read_box(bs, &txtc->default_pos);\n\tgpp_read_style(bs, &txtc->default_style);\n\ttxtc->font_count = gf_bs_read_u16(bs);\n\ttxtc->fonts = gf_malloc(sizeof(GF_FontRecord)*txtc->font_count);\n\tfor (i=0; i<txtc->font_count; i++) {\n\t\tu8 len;\n\t\ttxtc->fonts[i].fontID = gf_bs_read_u16(bs);\n\t\tlen = gf_bs_read_u8(bs);\n\t\ttxtc->fonts[i].fontName = gf_malloc(sizeof(char)*(len+1));\n\t\tgf_bs_read_data(bs, txtc->fonts[i].fontName, len);\n\t\ttxtc->fonts[i].fontName[len] = 0;\n\t}\n\tgf_bs_del(bs);\n\treturn txtc;\n}\n\nGF_Err gf_odf_tx3g_write(GF_TextSampleDescriptor *a, u8 **outData, u32 *outSize)\n{\n\tu32 j;\n\tvoid gpp_write_rgba(GF_BitStream *bs, u32 col);\n\tvoid gpp_write_box(GF_BitStream *bs, GF_BoxRecord *rec);\n\tvoid gpp_write_style(GF_BitStream *bs, GF_StyleRecord *rec);\n\tGF_BitStream *bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\tgf_bs_write_u8(bs, a->horiz_justif);\n\tgf_bs_write_u8(bs, a->vert_justif);\n\tgpp_write_rgba(bs, a->back_color);\n\tgpp_write_box(bs, &a->default_pos);\n\tgpp_write_style(bs, &a->default_style);\n\n\tgf_bs_write_u16(bs, a->font_count);\n\tfor (j=0; j<a->font_count; j++) {\n\t\tgf_bs_write_u16(bs, a->fonts[j].fontID);\n\t\tif (a->fonts[j].fontName) {\n\t\t\tu32 len = (u32) strlen(a->fonts[j].fontName);\n\t\t\tgf_bs_write_u8(bs, len);\n\t\t\tgf_bs_write_data(bs, a->fonts[j].fontName, len);\n\t\t} else {\n\t\t\tgf_bs_write_u8(bs, 0);\n\t\t}\n\t}\n\tgf_bs_get_content(bs, outData, outSize);\n\tgf_bs_del(bs);\n\treturn GF_OK;\n}\n\n/*TextConfig*/\nGF_Descriptor *gf_odf_new_text_cfg()\n{\n\tGF_TextConfig *newDesc = (GF_TextConfig*) gf_malloc(sizeof(GF_TextConfig));\n\tif (!newDesc) return NULL;\n\tmemset(newDesc, 0, sizeof(GF_TextConfig));\n\tnewDesc->tag = GF_ODF_TEXT_CFG_TAG;\n\tnewDesc->sample_descriptions = gf_list_new();\n\tnewDesc->Base3GPPFormat = 0x10;\n\tnewDesc->MPEGExtendedFormat = 0x10;\n\tnewDesc->profileLevel = 0x10;\n\tnewDesc->timescale = 1000;\n\treturn (GF_Descriptor *) newDesc;\n}\n\nvoid ResetTextConfig(GF_TextConfig *desc)\n{\n\tGF_List *bck;\n\twhile (gf_list_count(desc->sample_descriptions)) {\n\t\tGF_TextSampleDescriptor *sd = (GF_TextSampleDescriptor *)gf_list_get(desc->sample_descriptions, 0);\n\t\tgf_list_rem(desc->sample_descriptions, 0);\n\t\tgf_odf_del_tx3g(sd);\n\t}\n\tbck = desc->sample_descriptions;\n\tmemset(desc, 0, sizeof(GF_TextConfig));\n\tdesc->tag = GF_ODF_TEXT_CFG_TAG;\n\tdesc->sample_descriptions = bck;\n}\n\nGF_Err gf_odf_del_text_cfg(GF_TextConfig *desc)\n{\n\tResetTextConfig(desc);\n\tgf_list_del(desc->sample_descriptions);\n\tgf_free(desc);\n\treturn GF_OK;\n}\n\n/*we need box parsing*/\n#include <gpac/internal/isomedia_dev.h>\nGF_EXPORT\nGF_Err gf_odf_get_text_config(u8 *data, u32 data_len, u32 codecid, GF_TextConfig *cfg)\n{\n\tu32 i;\n\tBool has_alt_format;\n#ifndef GPAC_DISABLE_ISOM\n\tBool has_sd;\n\tu32 j;\n#endif\n\tGF_Err e;\n\tGF_BitStream *bs;\n\tif (data || data_len || !cfg) return GF_BAD_PARAM;\n\tif (codecid != GF_CODECID_TEXT_MPEG4) return GF_NOT_SUPPORTED;\n\n\t/*reset*/\n\tResetTextConfig(cfg);\n\tbs = gf_bs_new(data, data_len, GF_BITSTREAM_READ);\n\n\te = GF_OK;\n\tcfg->Base3GPPFormat = gf_bs_read_int(bs, 8);\n\tcfg->MPEGExtendedFormat = gf_bs_read_int(bs, 8);\n\tcfg->profileLevel = gf_bs_read_int(bs, 8);\n\tcfg->timescale = gf_bs_read_int(bs, 24);\n\thas_alt_format = (Bool)gf_bs_read_int(bs, 1);\n\tcfg->sampleDescriptionFlags = gf_bs_read_int(bs, 2);\n#ifndef GPAC_DISABLE_ISOM\n\thas_sd = (Bool)gf_bs_read_int(bs, 1);\n#else\n\tgf_bs_read_int(bs, 1);\n#endif\n\tcfg->has_vid_info = (Bool)gf_bs_read_int(bs, 1);\n\tgf_bs_read_int(bs, 3);\n\tcfg->layer = gf_bs_read_int(bs, 8);\n\tcfg->text_width = gf_bs_read_int(bs, 16);\n\tcfg->text_height = gf_bs_read_int(bs, 16);\n\tif (has_alt_format) {\n\t\tcfg->nb_compatible_formats = gf_bs_read_int(bs, 8);\n\t\tfor (i=0; i<cfg->nb_compatible_formats; i++) cfg->compatible_formats[i] = gf_bs_read_int(bs, 8);\n\t}\n#ifndef GPAC_DISABLE_ISOM\n\tif (has_sd) {\n\t\tu8 sample_index;\n\t\tGF_TextSampleDescriptor *txdesc;\n\t\tGF_Tx3gSampleEntryBox *a;\n\t\ts64 avail;\n\t\tu32 nb_desc = gf_bs_read_int(bs, 8);\n\n\t\t/*parse TTU[5]s*/\n\t\tavail = (s64) gf_bs_available(bs);\n\t\tfor (i=0; i<nb_desc; i++) {\n\t\t\tsample_index = gf_bs_read_int(bs, 8);\n\t\t\tavail -= 1;\n\t\t\te = gf_isom_box_parse((GF_Box **) &a, bs);\n\t\t\tif (e) goto exit;\n\t\t\tavail -= (s32) a->size;\n\n\t\t\tif (avail<0) {\n\t\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\ttxdesc = (GF_TextSampleDescriptor *)gf_malloc(sizeof(GF_TextSampleDescriptor));\n\t\t\ttxdesc->sample_index = sample_index;\n\t\t\ttxdesc->displayFlags = a->displayFlags;\n\t\t\ttxdesc->back_color = a->back_color;\n\t\t\ttxdesc->default_pos = a->default_box;\n\t\t\ttxdesc->default_style = a->default_style;\n\t\t\ttxdesc->vert_justif = a->vertical_justification;\n\t\t\ttxdesc->horiz_justif = a->horizontal_justification;\n\t\t\ttxdesc->font_count = a->font_table ? a->font_table->entry_count : 0;\n\t\t\tif (txdesc->font_count) {\n\t\t\t\ttxdesc->fonts = (GF_FontRecord*)gf_malloc(sizeof(GF_FontRecord)*txdesc->font_count);\n\t\t\t\tfor (j=0; j<txdesc->font_count; j++) {\n\t\t\t\t\ttxdesc->fonts[j].fontID = a->font_table->fonts[j].fontID;\n\t\t\t\t\ttxdesc->fonts[j].fontName = a->font_table->fonts[j].fontName ? gf_strdup(a->font_table->fonts[j].fontName) : NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_list_add(cfg->sample_descriptions, txdesc);\n\t\t\tgf_isom_box_del((GF_Box *)a);\n\t\t}\n\t}\n#endif\n\n\tif (cfg->has_vid_info) {\n\t\tcfg->video_width = gf_bs_read_int(bs, 16);\n\t\tcfg->video_height = gf_bs_read_int(bs, 16);\n\t\tcfg->horiz_offset = gf_bs_read_int(bs, 16);\n\t\tcfg->vert_offset = gf_bs_read_int(bs, 16);\n\t}\n\n#ifndef GPAC_DISABLE_ISOM\nexit:\n#endif\n\tgf_bs_del(bs);\n\tif (e) ResetTextConfig(cfg);\n\treturn e;\n}\n\n\n\nGF_EXPORT\nGF_HEVCConfig *gf_odf_hevc_cfg_new()\n{\n\tGF_HEVCConfig *cfg;\n\tGF_SAFEALLOC(cfg, GF_HEVCConfig);\n\tif (!cfg) return NULL;\n\tcfg->param_array = gf_list_new();\n\tcfg->nal_unit_size = 4;\n\treturn cfg;\n}\n\nGF_EXPORT\nvoid gf_odf_hevc_cfg_del(GF_HEVCConfig *cfg)\n{\n\tif (!cfg) return;\n\twhile (gf_list_count(cfg->param_array)) {\n\t\tGF_NALUFFParamArray *pa = (GF_NALUFFParamArray*)gf_list_get(cfg->param_array, 0);\n\t\tgf_list_rem(cfg->param_array, 0);\n\n\t\twhile (gf_list_count(pa->nalus)) {\n\t\t\tGF_NALUFFParam *n = (GF_NALUFFParam*)gf_list_get(pa->nalus, 0);\n\t\t\tgf_list_rem(pa->nalus, 0);\n\t\t\tif (n->data) gf_free(n->data);\n\t\t\tgf_free(n);\n\t\t}\n\t\tgf_list_del(pa->nalus);\n\t\tgf_free(pa);\n\t}\n\tgf_list_del(cfg->param_array);\n\tgf_free(cfg);\n}\n\nGF_EXPORT\nGF_Err gf_odf_hevc_cfg_write_bs(GF_HEVCConfig *cfg, GF_BitStream *bs)\n{\n\tu32 i, count;\n\n\tcount = gf_list_count(cfg->param_array);\n\n\tif (!cfg->write_annex_b) {\n\t\tgf_bs_write_int(bs, cfg->configurationVersion, 8);\n\n\t\tif (!cfg->is_lhvc) {\n\t\t\tgf_bs_write_int(bs, cfg->profile_space, 2);\n\t\t\tgf_bs_write_int(bs, cfg->tier_flag, 1);\n\t\t\tgf_bs_write_int(bs, cfg->profile_idc, 5);\n\t\t\tgf_bs_write_int(bs, cfg->general_profile_compatibility_flags, 32);\n\t\t\tgf_bs_write_int(bs, cfg->progressive_source_flag, 1);\n\t\t\tgf_bs_write_int(bs, cfg->interlaced_source_flag, 1);\n\t\t\tgf_bs_write_int(bs, cfg->non_packed_constraint_flag, 1);\n\t\t\tgf_bs_write_int(bs, cfg->frame_only_constraint_flag, 1);\n\t\t\t/*only lowest 44 bits used*/\n\t\t\tgf_bs_write_long_int(bs, cfg->constraint_indicator_flags, 44);\n\t\t\tgf_bs_write_int(bs, cfg->level_idc, 8);\n\t\t}\n\n\t\tgf_bs_write_int(bs, 0xFF, 4);\n\t\tgf_bs_write_int(bs, cfg->min_spatial_segmentation_idc, 12);\n\n\t\tgf_bs_write_int(bs, 0xFF, 6);\n\t\tgf_bs_write_int(bs, cfg->parallelismType, 2);\n\n\t\tif (!cfg->is_lhvc) {\n\t\t\tgf_bs_write_int(bs, 0xFF, 6);\n\t\t\tgf_bs_write_int(bs, cfg->chromaFormat, 2);\n\t\t\tgf_bs_write_int(bs, 0xFF, 5);\n\t\t\tgf_bs_write_int(bs, cfg->luma_bit_depth-8, 3);\n\t\t\tgf_bs_write_int(bs, 0xFF, 5);\n\t\t\tgf_bs_write_int(bs, cfg->chroma_bit_depth-8, 3);\n\t\t\tgf_bs_write_int(bs, cfg->avgFrameRate, 16);\n\n\t\t\tgf_bs_write_int(bs, cfg->constantFrameRate, 2);\n\t\t} else {\n\t\t\tgf_bs_write_int(bs, 0xFF, 2);\n\t\t}\n\n\t\tgf_bs_write_int(bs, cfg->numTemporalLayers, 3);\n\t\tgf_bs_write_int(bs, cfg->temporalIdNested, 1);\n\t\tgf_bs_write_int(bs, cfg->nal_unit_size - 1, 2);\n\n\t\tgf_bs_write_int(bs, count, 8);\n\t}\n\n\tfor (i=0; i<count; i++) {\n\t\tu32 nalucount, j;\n\t\tGF_NALUFFParamArray *ar = (GF_NALUFFParamArray*)gf_list_get(cfg->param_array, i);\n\n\t\tnalucount = gf_list_count(ar->nalus);\n\t\tif (!cfg->write_annex_b) {\n\t\t\tgf_bs_write_int(bs, ar->array_completeness, 1);\n\t\t\tgf_bs_write_int(bs, 0, 1);\n\t\t\tgf_bs_write_int(bs, ar->type, 6);\n\t\t\tgf_bs_write_int(bs, nalucount, 16);\n\t\t}\n\n\t\tfor (j=0; j<nalucount; j++) {\n\t\t\tGF_NALUFFParam *sl = (GF_NALUFFParam *)gf_list_get(ar->nalus, j);\n\t\t\tif (!cfg->write_annex_b) {\n\t\t\t\tgf_bs_write_int(bs, sl->size, 16);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_u32(bs, 1);\n\t\t\t}\n\t\t\tgf_bs_write_data(bs, sl->data, sl->size);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_odf_hevc_cfg_write(GF_HEVCConfig *cfg, u8 **outData, u32 *outSize)\n{\n\tGF_Err e;\n\tGF_BitStream *bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t*outSize = 0;\n\t*outData = NULL;\n\te = gf_odf_hevc_cfg_write_bs(cfg, bs);\n\tif (e==GF_OK)\n\t\tgf_bs_get_content(bs, outData, outSize);\n\n\tgf_bs_del(bs);\n\treturn e;\n}\n\nGF_EXPORT\nGF_HEVCConfig *gf_odf_hevc_cfg_read_bs(GF_BitStream *bs, Bool is_lhvc)\n{\n\tu32 i, count;\n\tGF_HEVCConfig *cfg = gf_odf_hevc_cfg_new();\n\n\tcfg->is_lhvc = is_lhvc;\n\n\tcfg->configurationVersion = gf_bs_read_int(bs, 8);\n\n\tif (!is_lhvc) {\n\t\tcfg->profile_space = gf_bs_read_int(bs, 2);\n\t\tcfg->tier_flag = gf_bs_read_int(bs, 1);\n\t\tcfg->profile_idc = gf_bs_read_int(bs, 5);\n\t\tcfg->general_profile_compatibility_flags = gf_bs_read_int(bs, 32);\n\n\t\tcfg->progressive_source_flag = gf_bs_read_int(bs, 1);\n\t\tcfg->interlaced_source_flag = gf_bs_read_int(bs, 1);\n\t\tcfg->non_packed_constraint_flag = gf_bs_read_int(bs, 1);\n\t\tcfg->frame_only_constraint_flag = gf_bs_read_int(bs, 1);\n\t\t/*only lowest 44 bits used*/\n\t\tcfg->constraint_indicator_flags = gf_bs_read_long_int(bs, 44);\n\t\tcfg->level_idc = gf_bs_read_int(bs, 8);\n\t}\n\n\tgf_bs_read_int(bs, 4); //reserved\n\tcfg->min_spatial_segmentation_idc = gf_bs_read_int(bs, 12);\n\n\tgf_bs_read_int(bs, 6);//reserved\n\tcfg->parallelismType = gf_bs_read_int(bs, 2);\n\n\tif (!is_lhvc) {\n\t\tgf_bs_read_int(bs, 6);\n\t\tcfg->chromaFormat = gf_bs_read_int(bs, 2);\n\t\tgf_bs_read_int(bs, 5);\n\t\tcfg->luma_bit_depth = gf_bs_read_int(bs, 3) + 8;\n\t\tgf_bs_read_int(bs, 5);\n\t\tcfg->chroma_bit_depth = gf_bs_read_int(bs, 3) + 8;\n\t\tcfg->avgFrameRate = gf_bs_read_int(bs, 16);\n\n\t\tcfg->constantFrameRate = gf_bs_read_int(bs, 2);\n\t} else {\n\t\tgf_bs_read_int(bs, 2); //reserved\n\t}\n\n\tcfg->numTemporalLayers = gf_bs_read_int(bs, 3);\n\tcfg->temporalIdNested = gf_bs_read_int(bs, 1);\n\n\tcfg->nal_unit_size = 1 + gf_bs_read_int(bs, 2);\n\n\tcount = gf_bs_read_int(bs, 8);\n\tfor (i=0; i<count; i++) {\n\t\tu32 nalucount, j;\n\t\tGF_NALUFFParamArray *ar;\n\t\tGF_SAFEALLOC(ar, GF_NALUFFParamArray);\n\t\tif (!ar) {\n\t\t\tgf_odf_hevc_cfg_del(cfg);\n\t\t\treturn NULL;\n\t\t}\n\t\tar->nalus = gf_list_new();\n\t\tgf_list_add(cfg->param_array, ar);\n\n\t\tar->array_completeness = gf_bs_read_int(bs, 1);\n\t\tgf_bs_read_int(bs, 1);\n\t\tar->type = gf_bs_read_int(bs, 6);\n\t\tnalucount = gf_bs_read_int(bs, 16);\n\t\tfor (j=0; j<nalucount; j++) {\n\t\t\tGF_NALUFFParam *sl;\n\t\t\tu32 size = gf_bs_read_int(bs, 16);\n\t\t\tif (size>gf_bs_available(bs)) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Wrong param set size %d\\n\", size));\n\t\t\t\tgf_odf_hevc_cfg_del(cfg);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tGF_SAFEALLOC(sl, GF_NALUFFParam );\n\t\t\tif (!sl) {\n\t\t\t\tgf_odf_hevc_cfg_del(cfg);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\tsl->size = size;\n\t\t\tsl->data = (char *)gf_malloc(sizeof(char) * sl->size);\n\t\t\tgf_bs_read_data(bs, sl->data, sl->size);\n\t\t\tgf_list_add(ar->nalus, sl);\n\t\t}\n\t}\n\treturn cfg;\n}\n\nGF_EXPORT\nGF_HEVCConfig *gf_odf_hevc_cfg_read(u8 *dsi, u32 dsi_size, Bool is_lhvc)\n{\n\tGF_BitStream *bs = gf_bs_new(dsi, dsi_size, GF_BITSTREAM_READ);\n\tGF_HEVCConfig *cfg = gf_odf_hevc_cfg_read_bs(bs, is_lhvc);\n\tgf_bs_del(bs);\n\treturn cfg;\n}\n\nGF_EXPORT\nGF_VVCConfig *gf_odf_vvc_cfg_new()\n{\n\tGF_VVCConfig *cfg;\n\tGF_SAFEALLOC(cfg, GF_VVCConfig);\n\tif (!cfg) return NULL;\n\tcfg->param_array = gf_list_new();\n\tcfg->nal_unit_size = 4;\n\tcfg->chroma_format = 1;\n\tcfg->bit_depth = 8;\n\treturn cfg;\n}\n\nGF_EXPORT\nvoid gf_odf_vvc_cfg_del(GF_VVCConfig *cfg)\n{\n\tif (!cfg) return;\n\twhile (gf_list_count(cfg->param_array)) {\n\t\tGF_NALUFFParamArray *pa = (GF_NALUFFParamArray*)gf_list_get(cfg->param_array, 0);\n\t\tgf_list_rem(cfg->param_array, 0);\n\n\t\twhile (gf_list_count(pa->nalus)) {\n\t\t\tGF_NALUFFParam *n = (GF_NALUFFParam*)gf_list_get(pa->nalus, 0);\n\t\t\tgf_list_rem(pa->nalus, 0);\n\t\t\tif (n->data) gf_free(n->data);\n\t\t\tgf_free(n);\n\t\t}\n\t\tgf_list_del(pa->nalus);\n\t\tgf_free(pa);\n\t}\n\tgf_list_del(cfg->param_array);\n\tif (cfg->general_constraint_info)\n\t\tgf_free(cfg->general_constraint_info);\n\tif (cfg->sub_profiles_idc)\n\t\tgf_free(cfg->sub_profiles_idc);\n\tgf_free(cfg);\n}\n\nGF_EXPORT\nGF_Err gf_odf_vvc_cfg_write_bs(GF_VVCConfig *cfg, GF_BitStream *bs)\n{\n\tu32 i, count;\n\n\tcount = gf_list_count(cfg->param_array);\n\n\tif (!cfg->write_annex_b) {\n\n\t\tgf_bs_write_int(bs, 0xFF, 5);\n\t\tgf_bs_write_int(bs, cfg->nal_unit_size - 1, 2);\n\t\tgf_bs_write_int(bs, cfg->ptl_present, 1);\n\n\t\tif (cfg->ptl_present) {\n\t\t\ts32 idx;\n\n\t\t\tgf_bs_write_int(bs, cfg->ols_idx, 9);\n\t\t\tgf_bs_write_int(bs, cfg->numTemporalLayers, 3);\n\t\t\tgf_bs_write_int(bs, cfg->constantFrameRate, 2);\n\t\t\tgf_bs_write_int(bs, cfg->chroma_format, 2);\n\t\t\tgf_bs_write_int(bs, cfg->bit_depth - 8, 3);\n\t\t\tgf_bs_write_int(bs, 0xFF, 5);\n\n\t\t\tif (!cfg->general_constraint_info)\n\t\t\t\tcfg->num_constraint_info = 0;\n\n\t\t\t//write PTL\n\t\t\tgf_bs_write_int(bs, 0, 2);\n\t\t\tgf_bs_write_int(bs, cfg->num_constraint_info, 6);\n\t\t\tgf_bs_write_int(bs, cfg->general_profile_idc, 7);\n\t\t\tgf_bs_write_int(bs, cfg->general_tier_flag, 1);\n\t\t\tgf_bs_write_u8(bs, cfg->general_level_idc);\n\t\t\tgf_bs_write_int(bs, cfg->ptl_frame_only_constraint, 1);\n\t\t\tgf_bs_write_int(bs, cfg->ptl_multilayer_enabled, 1);\n\n\t\t\tif (cfg->num_constraint_info) {\n\t\t\t\tgf_bs_write_data(bs, cfg->general_constraint_info, cfg->num_constraint_info - 1);\n\t\t\t\tgf_bs_write_int(bs, cfg->general_constraint_info[cfg->num_constraint_info - 1], 6);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_int(bs, 0, 6);\n\t\t\t}\n\n\t\t\tfor (idx=cfg->numTemporalLayers-2; idx>=0; idx--) {\n\t\t\t\tu8 val = cfg->ptl_sublayer_present_mask & (1<<idx);\n\t\t\t\tgf_bs_write_int(bs, val ? 1 : 0, 1);\n\t\t\t}\n\t\t\tfor (idx=cfg->numTemporalLayers; idx<=8 && cfg->numTemporalLayers>1; idx++) {\n\t\t\t\tgf_bs_write_int(bs, 0, 1);\n\t\t\t}\n\t\t\tfor (idx=cfg->numTemporalLayers-2; idx>=0; idx--) {\n\t\t\t\tif (cfg->ptl_sublayer_present_mask & (1<<idx))\n\t\t\t\t\tgf_bs_write_u8(bs, cfg->sublayer_level_idc[idx]);\n\t\t\t}\n\t\t\tif (!cfg->sub_profiles_idc) cfg->num_sub_profiles = 0;\n\t\t\tgf_bs_write_u8(bs, cfg->num_sub_profiles);\n\t\t\tfor (idx=0; idx<cfg->num_sub_profiles; idx++) {\n\t\t\t\tgf_bs_write_u32(bs, cfg->sub_profiles_idc[idx]);\n\t\t\t}\n\t\t\t//end PTL\n\n\t\t\tgf_bs_write_u16(bs, cfg->maxPictureWidth);\n\t\t\tgf_bs_write_u16(bs, cfg->maxPictureHeight);\n\t\t\tgf_bs_write_u16(bs, cfg->avgFrameRate);\n\t\t}\n\t\tgf_bs_write_int(bs, count, 8);\n\t}\n\n\tfor (i=0; i<count; i++) {\n\t\tu32 nalucount, j;\n\t\tGF_NALUFFParamArray *ar = (GF_NALUFFParamArray*)gf_list_get(cfg->param_array, i);\n\n\t\tnalucount = gf_list_count(ar->nalus);\n\t\tif (!cfg->write_annex_b) {\n\t\t\tgf_bs_write_int(bs, ar->array_completeness, 1);\n\t\t\tgf_bs_write_int(bs, 0, 2);\n\t\t\tgf_bs_write_int(bs, ar->type, 5);\n\n\t\t\tif ((ar->type != GF_VVC_NALU_DEC_PARAM) && (ar->type != GF_VVC_NALU_OPI))\n\t\t\t\tgf_bs_write_int(bs, nalucount, 16);\n\t\t\telse\n\t\t\t\tnalucount = 1;\n\t\t}\n\n\t\tfor (j=0; j<nalucount; j++) {\n\t\t\tGF_NALUFFParam *sl = (GF_NALUFFParam *)gf_list_get(ar->nalus, j);\n\t\t\tif (!cfg->write_annex_b) {\n\t\t\t\tgf_bs_write_int(bs, sl->size, 16);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_u32(bs, 1);\n\t\t\t}\n\t\t\tgf_bs_write_data(bs, sl->data, sl->size);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_odf_vvc_cfg_write(GF_VVCConfig *cfg, u8 **outData, u32 *outSize)\n{\n\tGF_Err e;\n\tGF_BitStream *bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t*outSize = 0;\n\t*outData = NULL;\n\te = gf_odf_vvc_cfg_write_bs(cfg, bs);\n\tif (e==GF_OK)\n\t\tgf_bs_get_content(bs, outData, outSize);\n\n\tgf_bs_del(bs);\n\treturn e;\n}\n\nGF_EXPORT\nGF_VVCConfig *gf_odf_vvc_cfg_read_bs(GF_BitStream *bs)\n{\n\tu32 i, count;\n\tGF_VVCConfig *cfg = gf_odf_vvc_cfg_new();\n\n\tgf_bs_read_int(bs, 5);\n\tcfg->nal_unit_size = 1 + gf_bs_read_int(bs, 2);\n\tcfg->ptl_present = gf_bs_read_int(bs, 1);\n\n\tif (cfg->ptl_present) {\n\t\ts32 j;\n\n\t\tcfg->ols_idx = gf_bs_read_int(bs, 9);\n\t\tcfg->numTemporalLayers = gf_bs_read_int(bs, 3);\n\t\tcfg->constantFrameRate = gf_bs_read_int(bs, 2);\n\t\tcfg->chroma_format = gf_bs_read_int(bs, 2);\n\t\tcfg->bit_depth = 8 + gf_bs_read_int(bs, 3);\n\t\tgf_bs_read_int(bs, 5);\n\n\t\t//parse PTL\n\t\tgf_bs_read_int(bs, 2);\n\t\tcfg->num_constraint_info = gf_bs_read_int(bs, 6);\n\t\tcfg->general_profile_idc = gf_bs_read_int(bs, 7);\n\t\tcfg->general_tier_flag = gf_bs_read_int(bs, 1);\n\t\tcfg->general_level_idc = gf_bs_read_u8(bs);\n\t\tcfg->ptl_frame_only_constraint = gf_bs_read_int(bs, 1);\n\t\tcfg->ptl_multilayer_enabled = gf_bs_read_int(bs, 1);\n\n\t\tif (cfg->num_constraint_info) {\n\t\t\tcfg->general_constraint_info = gf_malloc(sizeof(u8)*cfg->num_constraint_info);\n\t\t\tif (!cfg->general_constraint_info) {\n\t\t\t\tgf_free(cfg);\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] alloc failed while parsing vvc config\\n\"));\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tgf_bs_read_data(bs, cfg->general_constraint_info, cfg->num_constraint_info - 1);\n\t\t\tcfg->general_constraint_info[cfg->num_constraint_info-1] =  gf_bs_read_int(bs, 6);\n\t\t} else {\n\t\t\t//forbidden in spec!\n\t\t\tgf_bs_read_int(bs, 6);\n\t\t}\n\n\t\tcfg->ptl_sublayer_present_mask = 0;\n\t\tfor (j=cfg->numTemporalLayers-2; j>=0; j--) {\n\t\t\tu32 val = gf_bs_read_int(bs, 1);\n\t\t\tcfg->ptl_sublayer_present_mask |= val << j;\n\t\t}\n\t\tfor (j=cfg->numTemporalLayers; j<=8 && cfg->numTemporalLayers>1; j++) {\n\t\t\tgf_bs_read_int(bs, 1);\n\t\t}\n\t\tfor (j=cfg->numTemporalLayers-2; j>=0; j--) {\n\t\t\tif (cfg->ptl_sublayer_present_mask & (1<<j)) {\n\t\t\t\tcfg->sublayer_level_idc[j] = gf_bs_read_u8(bs);\n\t\t\t}\n\t\t}\n\t\tcfg->num_sub_profiles = gf_bs_read_u8(bs);\n\t\tif (cfg->num_sub_profiles) {\n\t\t\tcfg->sub_profiles_idc = gf_malloc(sizeof(u32)*cfg->num_sub_profiles);\n\t\t\tif (!cfg->sub_profiles_idc) {\n\t\t\t\tgf_free(cfg->general_constraint_info);\n\t\t\t\tgf_free(cfg);\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] alloc failed while parsing vvc config\\n\"));\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t\tfor (i=0; i<cfg->num_sub_profiles; i++) {\n\t\t\tcfg->sub_profiles_idc[i] = gf_bs_read_u32(bs);\n\t\t}\n\n\t\t//end PTL\n\n\t\tcfg->maxPictureWidth = gf_bs_read_u16(bs);\n\t\tcfg->maxPictureHeight = gf_bs_read_u16(bs);\n\t\tcfg->avgFrameRate = gf_bs_read_u16(bs);\n\t}\n\n\tcount = gf_bs_read_int(bs, 8);\n\tfor (i=0; i<count; i++) {\n\t\tu32 nalucount, j;\n\t\tGF_NALUFFParamArray *ar;\n\t\tGF_SAFEALLOC(ar, GF_NALUFFParamArray);\n\t\tif (!ar) {\n\t\t\tgf_odf_vvc_cfg_del(cfg);\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] alloc failed while parsing vvc config\\n\"));\n\t\t\treturn NULL;\n\t\t}\n\t\tar->nalus = gf_list_new();\n\t\tgf_list_add(cfg->param_array, ar);\n\n\t\tar->array_completeness = gf_bs_read_int(bs, 1);\n\t\tgf_bs_read_int(bs, 2);\n\t\tar->type = gf_bs_read_int(bs, 5);\n\n\t\tif ((ar->type != GF_VVC_NALU_DEC_PARAM) && (ar->type != GF_VVC_NALU_OPI))\n\t\t\tnalucount = gf_bs_read_int(bs, 16);\n\t\telse\n\t\t\tnalucount = 1;\n\t\t\t\n\t\tfor (j=0; j<nalucount; j++) {\n\t\t\tGF_NALUFFParam *sl;\n\t\t\tu32 size = gf_bs_read_int(bs, 16);\n\t\t\tif (size>gf_bs_available(bs)) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Wrong param set size %d\\n\", size));\n\t\t\t\tgf_odf_vvc_cfg_del(cfg);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tGF_SAFEALLOC(sl, GF_NALUFFParam );\n\t\t\tif (!sl) {\n\t\t\t\tgf_odf_vvc_cfg_del(cfg);\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] alloc failed while parsing vvc config\\n\"));\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\tsl->size = size;\n\t\t\tsl->data = (char *)gf_malloc(sizeof(char) * sl->size);\n\t\t\tif (!sl->data) {\n\t\t\t\tgf_free(sl);\n\t\t\t\tgf_odf_vvc_cfg_del(cfg);\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] alloc failed while parsing vvc config\\n\"));\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tgf_bs_read_data(bs, sl->data, sl->size);\n\t\t\tgf_list_add(ar->nalus, sl);\n\t\t}\n\t}\n\treturn cfg;\n}\n\nGF_EXPORT\nGF_VVCConfig *gf_odf_vvc_cfg_read(u8 *dsi, u32 dsi_size)\n{\n\tGF_BitStream *bs = gf_bs_new(dsi, dsi_size, GF_BITSTREAM_READ);\n\tGF_VVCConfig *cfg = gf_odf_vvc_cfg_read_bs(bs);\n\tgf_bs_del(bs);\n\treturn cfg;\n}\n\nGF_EXPORT\nGF_AV1Config *gf_odf_av1_cfg_new()\n{\n\tGF_AV1Config *cfg;\n\tGF_SAFEALLOC(cfg, GF_AV1Config);\n\tif (!cfg) return NULL;\n\tcfg->marker = 1;\n\tcfg->version = 1;\n\tcfg->initial_presentation_delay_minus_one = 0;\n\tcfg->obu_array = gf_list_new();\n\treturn cfg;\n}\n\nGF_EXPORT\nvoid gf_odf_av1_cfg_del(GF_AV1Config *cfg)\n{\n\tif (!cfg) return;\n\twhile (gf_list_count(cfg->obu_array)) {\n\t\tGF_AV1_OBUArrayEntry *a = (GF_AV1_OBUArrayEntry*)gf_list_get(cfg->obu_array, 0);\n\t\tif (a->obu) gf_free(a->obu);\n\t\tgf_list_rem(cfg->obu_array, 0);\n\t\tgf_free(a);\n\t}\n\tgf_list_del(cfg->obu_array);\n\tgf_free(cfg);\n}\n\nGF_EXPORT\nGF_Err gf_odf_av1_cfg_write_bs(GF_AV1Config *cfg, GF_BitStream *bs)\n{\n\tu32 i = 0;\n\tgf_bs_write_int(bs, cfg->marker, 1); assert(cfg->marker == 1);\n\tgf_bs_write_int(bs, cfg->version, 7); assert(cfg->version == 1);\n\tgf_bs_write_int(bs, cfg->seq_profile, 3);\n\tgf_bs_write_int(bs, cfg->seq_level_idx_0, 5);\n\tgf_bs_write_int(bs, cfg->seq_tier_0, 1);\n\tgf_bs_write_int(bs, cfg->high_bitdepth, 1);\n\tgf_bs_write_int(bs, cfg->twelve_bit, 1);\n\tgf_bs_write_int(bs, cfg->monochrome, 1);\n\tgf_bs_write_int(bs, cfg->chroma_subsampling_x, 1);\n\tgf_bs_write_int(bs, cfg->chroma_subsampling_y, 1);\n\tgf_bs_write_int(bs, cfg->chroma_sample_position, 2);\n\tgf_bs_write_int(bs, 0, 3); /*reserved*/\n\tgf_bs_write_int(bs, cfg->initial_presentation_delay_present, 1);\n\tgf_bs_write_int(bs, cfg->initial_presentation_delay_minus_one, 4); /*TODO: compute initial_presentation_delay_minus_one*/\n\tfor (i = 0; i < gf_list_count(cfg->obu_array); ++i) {\n\t\tGF_AV1_OBUArrayEntry *a = gf_list_get(cfg->obu_array, i);\n\t\tgf_bs_write_data(bs, a->obu, (u32)a->obu_length); //TODO: we are supposed to omit the size on the last OBU...\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_odf_av1_cfg_write(GF_AV1Config *cfg, u8 **outData, u32 *outSize) {\n\tGF_Err e;\n\tGF_BitStream *bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t*outSize = 0;\n\t*outData = NULL;\n\te = gf_odf_av1_cfg_write_bs(cfg, bs);\n\tif (e == GF_OK)\n\t\tgf_bs_get_content(bs, outData, outSize);\n\n\tgf_bs_del(bs);\n\treturn e;\n}\n\nGF_EXPORT\nGF_VPConfig *gf_odf_vp_cfg_new()\n{\n\tGF_VPConfig *cfg;\n\tGF_SAFEALLOC(cfg, GF_VPConfig);\n\tif (!cfg) return NULL;\n\tcfg->codec_initdata_size = 0;\n\tcfg->codec_initdata = NULL;\n\treturn cfg;\n}\n\nGF_EXPORT\nvoid gf_odf_vp_cfg_del(GF_VPConfig *cfg)\n{\n\tif (!cfg) return;\n\n\tif (cfg->codec_initdata) {\n\t\tgf_free(cfg->codec_initdata);\n\t\tcfg->codec_initdata = NULL;\n\t}\n\n\tgf_free(cfg);\n}\n\nGF_EXPORT\nGF_Err gf_odf_vp_cfg_write_bs(GF_VPConfig *cfg, GF_BitStream *bs, Bool is_v0)\n{\n\tgf_bs_write_int(bs, cfg->profile, 8);\n\tgf_bs_write_int(bs, cfg->level, 8);\n\tgf_bs_write_int(bs, cfg->bit_depth, 4);\n\tgf_bs_write_int(bs, cfg->chroma_subsampling, 3);\n\tgf_bs_write_int(bs, cfg->video_fullRange_flag, 1);\n\tgf_bs_write_int(bs, cfg->colour_primaries, 8);\n\tgf_bs_write_int(bs, cfg->transfer_characteristics, 8);\n\tgf_bs_write_int(bs, cfg->matrix_coefficients, 8);\n\n\tif (!is_v0) {\n\t\tif (cfg->codec_initdata_size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] VP Configuration Box: invalid data, codec_initdata_size must be 0, was %d - ignoring\\n\", cfg->codec_initdata_size));\n\t\t}\n\n\t\tgf_bs_write_int(bs, (u16)0, 16);\n\t}\n\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_odf_vp_cfg_write(GF_VPConfig *cfg, u8 **outData, u32 *outSize, Bool is_v0)\n{\n\tGF_Err e;\n\tGF_BitStream *bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t*outSize = 0;\n\t*outData = NULL;\n\te = gf_odf_vp_cfg_write_bs(cfg, bs, is_v0);\n\tif (e==GF_OK)\n\t\tgf_bs_get_content(bs, outData, outSize);\n\n\tgf_bs_del(bs);\n\treturn e;\n}\n\nGF_EXPORT\nGF_VPConfig *gf_odf_vp_cfg_read_bs(GF_BitStream *bs, Bool is_v0)\n{\n\tGF_VPConfig *cfg = gf_odf_vp_cfg_new();\n\n\tcfg->profile = gf_bs_read_int(bs, 8);\n\tcfg->level = gf_bs_read_int(bs, 8);\n\n\tcfg->bit_depth = gf_bs_read_int(bs, 4);\n\tcfg->chroma_subsampling = gf_bs_read_int(bs, 3);\n\tcfg->video_fullRange_flag = gf_bs_read_int(bs, 1);\n\n\tcfg->colour_primaries = gf_bs_read_int(bs, 8);\n\tcfg->transfer_characteristics = gf_bs_read_int(bs, 8);\n\tcfg->matrix_coefficients = gf_bs_read_int(bs, 8);\n\n\tif (is_v0)\n\t\treturn cfg;\n\n\tcfg->codec_initdata_size = gf_bs_read_int(bs, 16);\n\n\t// must be 0 according to spec\n\tif (cfg->codec_initdata_size) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] VP Configuration Box: invalid data, codec_initdata_size must be 0, was %d\\n\", cfg->codec_initdata_size));\n\t\tgf_odf_vp_cfg_del(cfg);\n\t\treturn NULL;\n\t}\n\n\treturn cfg;\n}\n\nGF_EXPORT\nGF_VPConfig *gf_odf_vp_cfg_read(u8 *dsi, u32 dsi_size)\n{\n\tGF_BitStream *bs = gf_bs_new(dsi, dsi_size, GF_BITSTREAM_READ);\n\tGF_VPConfig *cfg = gf_odf_vp_cfg_read_bs(bs, GF_FALSE);\n\tgf_bs_del(bs);\n\treturn cfg;\n}\n\nGF_EXPORT\nGF_AV1Config *gf_odf_av1_cfg_read_bs_size(GF_BitStream *bs, u32 size)\n{\n#ifndef GPAC_DISABLE_AV_PARSERS\n\tAV1State state;\n\tu8 reserved;\n\tGF_AV1Config *cfg;\n\n\tif (!size) size = (u32) gf_bs_available(bs);\n\tif (!size) return NULL;\n\n\tcfg = gf_odf_av1_cfg_new();\n\tgf_av1_init_state(&state);\n\tstate.config = cfg;\n\n\tcfg->marker = gf_bs_read_int(bs, 1);\n\tcfg->version = gf_bs_read_int(bs, 7);\n\tcfg->seq_profile = gf_bs_read_int(bs, 3);\n\tcfg->seq_level_idx_0 = gf_bs_read_int(bs, 5);\n\tcfg->seq_tier_0 = gf_bs_read_int(bs, 1);\n\tcfg->high_bitdepth = gf_bs_read_int(bs, 1);\n\tcfg->twelve_bit = gf_bs_read_int(bs, 1);\n\tcfg->monochrome = gf_bs_read_int(bs, 1);\n\tcfg->chroma_subsampling_x = gf_bs_read_int(bs, 1);\n\tcfg->chroma_subsampling_y = gf_bs_read_int(bs, 1);\n\tcfg->chroma_sample_position = gf_bs_read_int(bs, 2);\n\n\treserved = gf_bs_read_int(bs, 3);\n\tif (reserved != 0 || cfg->marker != 1 || cfg->version != 1) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[AV1] wrong avcC reserved %d / marker %d / version %d expecting 0 1 1\\n\", reserved, cfg->marker, cfg->version));\n\t\tgf_odf_av1_cfg_del(cfg);\n\t\treturn NULL;\n\t}\n\tcfg->initial_presentation_delay_present = gf_bs_read_int(bs, 1);\n\tif (cfg->initial_presentation_delay_present) {\n\t\tcfg->initial_presentation_delay_minus_one = gf_bs_read_int(bs, 4);\n\t} else {\n\t\t/*reserved = */gf_bs_read_int(bs, 4);\n\t\tcfg->initial_presentation_delay_minus_one = 0;\n\t}\n\tsize -= 4;\n\n\twhile (size) {\n\t\tu64 pos, obu_size;\n\t\tObuType obu_type;\n\t\tGF_AV1_OBUArrayEntry *a;\n\n\t\tpos = gf_bs_get_position(bs);\n\t\tobu_size = 0;\n\t\tif (gf_av1_parse_obu(bs, &obu_type, &obu_size, NULL, &state) != GF_OK) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[AV1] could not parse AV1 OBU at position \"LLU\". Leaving parsing.\\n\", pos));\n\t\t\tbreak;\n\t\t}\n\t\tassert(obu_size == gf_bs_get_position(bs) - pos);\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[AV1] parsed AV1 OBU type=%u size=\"LLU\" at position \"LLU\".\\n\", obu_type, obu_size, pos));\n\n\t\tif (!av1_is_obu_header(obu_type)) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[AV1] AV1 unexpected OBU type=%u size=\"LLU\" found at position \"LLU\". Forwarding.\\n\", pos));\n\t\t}\n\t\tGF_SAFEALLOC(a, GF_AV1_OBUArrayEntry);\n\t\tif (!a) break;\n\t\ta->obu = gf_malloc((size_t)obu_size);\n\t\tif (!a->obu) {\n\t\t\tgf_free(a);\n\t\t\tbreak;\n\t\t}\n\t\tgf_bs_seek(bs, pos);\n\t\tgf_bs_read_data(bs, (char *) a->obu, (u32)obu_size);\n\t\ta->obu_length = obu_size;\n\t\ta->obu_type = obu_type;\n\t\tgf_list_add(cfg->obu_array, a);\n\n\t\tif (size<obu_size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[AV1] AV1 config misses %d bytes to fit the entire OBU\\n\", obu_size - size));\n\t\t\tbreak;\n\t\t}\n\t\tsize -= (u32) obu_size;\n\t}\n\tgf_av1_reset_state(& state, GF_TRUE);\n\tgf_bs_align(bs);\n\treturn cfg;\n#else\n\treturn NULL;\n#endif\n}\n\nGF_EXPORT\nGF_AV1Config *gf_odf_av1_cfg_read_bs(GF_BitStream *bs)\n{\n\treturn gf_odf_av1_cfg_read_bs_size(bs, 0);\n\n}\nGF_EXPORT\nGF_AV1Config *gf_odf_av1_cfg_read(u8 *dsi, u32 dsi_size)\n{\n\tGF_BitStream *bs = gf_bs_new(dsi, dsi_size, GF_BITSTREAM_READ);\n\tGF_AV1Config *cfg = gf_odf_av1_cfg_read_bs(bs);\n\tgf_bs_del(bs);\n\treturn cfg;\n}\n\nGF_DOVIDecoderConfigurationRecord *gf_odf_dovi_cfg_read_bs(GF_BitStream *bs)\n{\n\tGF_DOVIDecoderConfigurationRecord *cfg;\n\tGF_SAFEALLOC(cfg, GF_DOVIDecoderConfigurationRecord);\n\n\tcfg->dv_version_major = gf_bs_read_u8(bs);\n\tcfg->dv_version_minor = gf_bs_read_u8(bs);\n\tcfg->dv_profile = gf_bs_read_int(bs, 7);\n\tcfg->dv_level = gf_bs_read_int(bs, 6);\n\tcfg->rpu_present_flag = gf_bs_read_int(bs, 1);\n\tcfg->el_present_flag = gf_bs_read_int(bs, 1);\n\tcfg->bl_present_flag = gf_bs_read_int(bs, 1);\n\t{\n\t\tint i = 0;\n\t\tu32 data[5];\n\t\tmemset(data, 0, sizeof(data));\n\t\tgf_bs_read_data(bs, (char*)data, 20);\n\t\tfor (i = 0; i < 5; ++i) {\n\t\t\tif (data[i] != 0) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[odf_cfg] dovi config reserved bytes are not zero\\n\"));\n\t\t\t}\n\t\t}\n\t}\n\treturn cfg;\n}\n\nvoid gf_odf_dovi_cfg_del(GF_DOVIDecoderConfigurationRecord *cfg)\n{\n\tgf_free(cfg);\n}\n\nGF_Err gf_odf_dovi_cfg_write_bs(GF_DOVIDecoderConfigurationRecord *cfg, GF_BitStream *bs)\n{\n\tgf_bs_write_u8(bs,  cfg->dv_version_major);\n\tgf_bs_write_u8(bs,  cfg->dv_version_minor);\n\tgf_bs_write_int(bs, cfg->dv_profile, 7);\n\tgf_bs_write_int(bs, cfg->dv_level, 6);\n\tgf_bs_write_int(bs, cfg->rpu_present_flag, 1);\n\tgf_bs_write_int(bs, cfg->el_present_flag, 1);\n\tgf_bs_write_int(bs, cfg->bl_present_flag, 1);\n    gf_bs_write_u32(bs, 0);\n    gf_bs_write_u32(bs, 0);\n    gf_bs_write_u32(bs, 0);\n    gf_bs_write_u32(bs, 0);\n    gf_bs_write_u32(bs, 0);\n\treturn GF_OK;\n}\n\n\nGF_Err gf_odf_ac3_cfg_write_bs(GF_AC3Config *cfg, GF_BitStream *bs)\n{\n\tif (!cfg || !bs) return GF_BAD_PARAM;\n\n\tif (cfg->is_ec3) {\n\t\tu32 i;\n\t\tgf_bs_write_int(bs, cfg->brcode, 13);\n\t\tgf_bs_write_int(bs, cfg->nb_streams - 1, 3);\n\t\tfor (i=0; i<cfg->nb_streams; i++) {\n\t\t\tgf_bs_write_int(bs, cfg->streams[i].fscod, 2);\n\t\t\tgf_bs_write_int(bs, cfg->streams[i].bsid, 5);\n\t\t\tgf_bs_write_int(bs, cfg->streams[i].bsmod, 5);\n\t\t\tgf_bs_write_int(bs, cfg->streams[i].acmod, 3);\n\t\t\tgf_bs_write_int(bs, cfg->streams[i].lfon, 1);\n\t\t\tgf_bs_write_int(bs, 0, 3);\n\t\t\tgf_bs_write_int(bs, cfg->streams[i].nb_dep_sub, 4);\n\t\t\tif (cfg->streams[i].nb_dep_sub) {\n\t\t\t\tgf_bs_write_int(bs, cfg->streams[i].chan_loc, 9);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_int(bs, 0, 1);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tgf_bs_write_int(bs, cfg->streams[0].fscod, 2);\n\t\tgf_bs_write_int(bs, cfg->streams[0].bsid, 5);\n\t\tgf_bs_write_int(bs, cfg->streams[0].bsmod, 3);\n\t\tgf_bs_write_int(bs, cfg->streams[0].acmod, 3);\n\t\tgf_bs_write_int(bs, cfg->streams[0].lfon, 1);\n\t\tgf_bs_write_int(bs, cfg->brcode, 5);\n\t\tgf_bs_write_int(bs, 0, 5);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err gf_odf_ac3_cfg_write(GF_AC3Config *cfg, u8 **data, u32 *size)\n{\n\tGF_BitStream *bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tGF_Err e = gf_odf_ac3_cfg_write_bs(cfg, bs);\n\n\tgf_bs_get_content(bs, data, size);\n\tgf_bs_del(bs);\n\treturn e;\n}\n\nGF_Err gf_odf_ac3_config_parse_bs(GF_BitStream *bs, Bool is_ec3, GF_AC3Config *cfg)\n{\n\tif (!cfg || !bs) return GF_BAD_PARAM;\n\tmemset(cfg, 0, sizeof(GF_AC3Config));\n\tcfg->is_ec3 = is_ec3;\n\tif (is_ec3) {\n\t\tu32 j;\n\t\tcfg->is_ec3 = 1;\n\t\tcfg->brcode = gf_bs_read_int(bs, 13);\n\t\tcfg->nb_streams = 1 + gf_bs_read_int(bs, 3);\n\t\tfor (j=0; j<cfg->nb_streams; j++) {\n\t\t\tcfg->streams[j].fscod = gf_bs_read_int(bs, 2);\n\t\t\tcfg->streams[j].bsid = gf_bs_read_int(bs, 5);\n\t\t\tgf_bs_read_int(bs, 1);\n\t\t\tcfg->streams[j].asvc = gf_bs_read_int(bs, 1);\n\t\t\tcfg->streams[j].bsmod = gf_bs_read_int(bs, 3);\n\t\t\tcfg->streams[j].acmod = gf_bs_read_int(bs, 3);\n\t\t\tcfg->streams[j].lfon = gf_bs_read_int(bs, 1);\n\t\t\tgf_bs_read_int(bs, 3);\n\t\t\tcfg->streams[j].nb_dep_sub = gf_bs_read_int(bs, 4);\n\t\t\tif (cfg->streams[j].nb_dep_sub) {\n\t\t\t\tcfg->streams[j].chan_loc = gf_bs_read_int(bs, 9);\n\t\t\t} else {\n\t\t\t\tgf_bs_read_int(bs, 1);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tcfg->nb_streams = 1;\n\t\tcfg->streams[0].fscod = gf_bs_read_int(bs, 2);\n\t\tcfg->streams[0].bsid = gf_bs_read_int(bs, 5);\n\t\tcfg->streams[0].bsmod = gf_bs_read_int(bs, 3);\n\t\tcfg->streams[0].acmod = gf_bs_read_int(bs, 3);\n\t\tcfg->streams[0].lfon = gf_bs_read_int(bs, 1);\n\t\tcfg->brcode = gf_bs_read_int(bs, 5);\n\t\tgf_bs_read_int(bs, 5);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err gf_odf_ac3_config_parse(u8 *dsi, u32 dsi_len, Bool is_ec3, GF_AC3Config *cfg)\n{\n\tGF_BitStream *bs;\n\tGF_Err e;\n\tif (!cfg || !dsi) return GF_BAD_PARAM;\n\tbs = gf_bs_new(dsi, dsi_len, GF_BITSTREAM_READ);\n\te = gf_odf_ac3_config_parse_bs(bs, is_ec3, cfg);\n\tgf_bs_del(bs);\n\treturn e;\n}\n"], "filenames": ["src/odf/descriptors.c"], "buggy_code_start_loc": [1615], "buggy_code_end_loc": [1615], "fixing_code_start_loc": [1616], "fixing_code_end_loc": [1617], "type": "CWE-415", "message": "The binary MP4Box in Gpac 1.0.1 has a double-free vulnerability in the ilst_box_read function in box_code_apple.c, which allows attackers to cause a denial of service, even code execution and escalation of privileges.", "other": {"cve": {"id": "CVE-2021-40571", "sourceIdentifier": "cve@mitre.org", "published": "2022-01-13T18:15:08.113", "lastModified": "2023-05-27T04:15:16.907", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The binary MP4Box in Gpac 1.0.1 has a double-free vulnerability in the ilst_box_read function in box_code_apple.c, which allows attackers to cause a denial of service, even code execution and escalation of privileges."}, {"lang": "es", "value": "El binario MP4Box en Gpac versi\u00f3n 1.0.1, presenta una vulnerabilidad de doble liberaci\u00f3n en la funci\u00f3n ilst_box_read en el archivo box_code_apple.c, que permite a atacantes causar una denegaci\u00f3n de servicio, incluso ejecuci\u00f3n de c\u00f3digo y escalada de privilegios"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-415"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gpac:gpac:1.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "82DD2D40-0A05-48FD-940D-32B4D8B51AB3"}]}]}], "references": [{"url": "https://github.com/gpac/gpac/commit/a69b567b8c95c72f9560c873c5ab348be058f340", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/gpac/gpac/issues/1895", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://www.debian.org/security/2023/dsa-5411", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/gpac/gpac/commit/a69b567b8c95c72f9560c873c5ab348be058f340"}}