{"buggy_code": ["/*\n * fs/f2fs/node.c\n *\n * Copyright (c) 2012 Samsung Electronics Co., Ltd.\n *             http://www.samsung.com/\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation.\n */\n#include <linux/fs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n\n#include \"f2fs.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"trace.h\"\n#include <trace/events/f2fs.h>\n\n#define on_build_free_nids(nmi) mutex_is_locked(&nm_i->build_lock)\n\nstatic struct kmem_cache *nat_entry_slab;\nstatic struct kmem_cache *free_nid_slab;\nstatic struct kmem_cache *nat_entry_set_slab;\n\nbool available_free_memory(struct f2fs_sb_info *sbi, int type)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct sysinfo val;\n\tunsigned long avail_ram;\n\tunsigned long mem_size = 0;\n\tbool res = false;\n\n\tsi_meminfo(&val);\n\n\t/* only uses low memory */\n\tavail_ram = val.totalram - val.totalhigh;\n\n\t/*\n\t * give 25%, 25%, 50%, 50%, 50% memory for each components respectively\n\t */\n\tif (type == FREE_NIDS) {\n\t\tmem_size = (nm_i->nid_cnt[FREE_NID_LIST] *\n\t\t\t\tsizeof(struct free_nid)) >> PAGE_SHIFT;\n\t\tres = mem_size < ((avail_ram * nm_i->ram_thresh / 100) >> 2);\n\t} else if (type == NAT_ENTRIES) {\n\t\tmem_size = (nm_i->nat_cnt * sizeof(struct nat_entry)) >>\n\t\t\t\t\t\t\tPAGE_SHIFT;\n\t\tres = mem_size < ((avail_ram * nm_i->ram_thresh / 100) >> 2);\n\t\tif (excess_cached_nats(sbi))\n\t\t\tres = false;\n\t} else if (type == DIRTY_DENTS) {\n\t\tif (sbi->sb->s_bdi->wb.dirty_exceeded)\n\t\t\treturn false;\n\t\tmem_size = get_pages(sbi, F2FS_DIRTY_DENTS);\n\t\tres = mem_size < ((avail_ram * nm_i->ram_thresh / 100) >> 1);\n\t} else if (type == INO_ENTRIES) {\n\t\tint i;\n\n\t\tfor (i = 0; i <= UPDATE_INO; i++)\n\t\t\tmem_size += sbi->im[i].ino_num *\n\t\t\t\t\t\tsizeof(struct ino_entry);\n\t\tmem_size >>= PAGE_SHIFT;\n\t\tres = mem_size < ((avail_ram * nm_i->ram_thresh / 100) >> 1);\n\t} else if (type == EXTENT_CACHE) {\n\t\tmem_size = (atomic_read(&sbi->total_ext_tree) *\n\t\t\t\tsizeof(struct extent_tree) +\n\t\t\t\tatomic_read(&sbi->total_ext_node) *\n\t\t\t\tsizeof(struct extent_node)) >> PAGE_SHIFT;\n\t\tres = mem_size < ((avail_ram * nm_i->ram_thresh / 100) >> 1);\n\t} else {\n\t\tif (!sbi->sb->s_bdi->wb.dirty_exceeded)\n\t\t\treturn true;\n\t}\n\treturn res;\n}\n\nstatic void clear_node_page_dirty(struct page *page)\n{\n\tstruct address_space *mapping = page->mapping;\n\tunsigned int long flags;\n\n\tif (PageDirty(page)) {\n\t\tspin_lock_irqsave(&mapping->tree_lock, flags);\n\t\tradix_tree_tag_clear(&mapping->page_tree,\n\t\t\t\tpage_index(page),\n\t\t\t\tPAGECACHE_TAG_DIRTY);\n\t\tspin_unlock_irqrestore(&mapping->tree_lock, flags);\n\n\t\tclear_page_dirty_for_io(page);\n\t\tdec_page_count(F2FS_M_SB(mapping), F2FS_DIRTY_NODES);\n\t}\n\tClearPageUptodate(page);\n}\n\nstatic struct page *get_current_nat_page(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tpgoff_t index = current_nat_addr(sbi, nid);\n\treturn get_meta_page(sbi, index);\n}\n\nstatic struct page *get_next_nat_page(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tstruct page *src_page;\n\tstruct page *dst_page;\n\tpgoff_t src_off;\n\tpgoff_t dst_off;\n\tvoid *src_addr;\n\tvoid *dst_addr;\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\n\tsrc_off = current_nat_addr(sbi, nid);\n\tdst_off = next_nat_addr(sbi, src_off);\n\n\t/* get current nat block page with lock */\n\tsrc_page = get_meta_page(sbi, src_off);\n\tdst_page = grab_meta_page(sbi, dst_off);\n\tf2fs_bug_on(sbi, PageDirty(src_page));\n\n\tsrc_addr = page_address(src_page);\n\tdst_addr = page_address(dst_page);\n\tmemcpy(dst_addr, src_addr, PAGE_SIZE);\n\tset_page_dirty(dst_page);\n\tf2fs_put_page(src_page, 1);\n\n\tset_to_next_nat(nm_i, nid);\n\n\treturn dst_page;\n}\n\nstatic struct nat_entry *__lookup_nat_cache(struct f2fs_nm_info *nm_i, nid_t n)\n{\n\treturn radix_tree_lookup(&nm_i->nat_root, n);\n}\n\nstatic unsigned int __gang_lookup_nat_cache(struct f2fs_nm_info *nm_i,\n\t\tnid_t start, unsigned int nr, struct nat_entry **ep)\n{\n\treturn radix_tree_gang_lookup(&nm_i->nat_root, (void **)ep, start, nr);\n}\n\nstatic void __del_from_nat_cache(struct f2fs_nm_info *nm_i, struct nat_entry *e)\n{\n\tlist_del(&e->list);\n\tradix_tree_delete(&nm_i->nat_root, nat_get_nid(e));\n\tnm_i->nat_cnt--;\n\tkmem_cache_free(nat_entry_slab, e);\n}\n\nstatic void __set_nat_cache_dirty(struct f2fs_nm_info *nm_i,\n\t\t\t\t\t\tstruct nat_entry *ne)\n{\n\tnid_t set = NAT_BLOCK_OFFSET(ne->ni.nid);\n\tstruct nat_entry_set *head;\n\n\tif (get_nat_flag(ne, IS_DIRTY))\n\t\treturn;\n\n\thead = radix_tree_lookup(&nm_i->nat_set_root, set);\n\tif (!head) {\n\t\thead = f2fs_kmem_cache_alloc(nat_entry_set_slab, GFP_NOFS);\n\n\t\tINIT_LIST_HEAD(&head->entry_list);\n\t\tINIT_LIST_HEAD(&head->set_list);\n\t\thead->set = set;\n\t\thead->entry_cnt = 0;\n\t\tf2fs_radix_tree_insert(&nm_i->nat_set_root, set, head);\n\t}\n\tlist_move_tail(&ne->list, &head->entry_list);\n\tnm_i->dirty_nat_cnt++;\n\thead->entry_cnt++;\n\tset_nat_flag(ne, IS_DIRTY, true);\n}\n\nstatic void __clear_nat_cache_dirty(struct f2fs_nm_info *nm_i,\n\t\tstruct nat_entry_set *set, struct nat_entry *ne)\n{\n\tlist_move_tail(&ne->list, &nm_i->nat_entries);\n\tset_nat_flag(ne, IS_DIRTY, false);\n\tset->entry_cnt--;\n\tnm_i->dirty_nat_cnt--;\n}\n\nstatic unsigned int __gang_lookup_nat_set(struct f2fs_nm_info *nm_i,\n\t\tnid_t start, unsigned int nr, struct nat_entry_set **ep)\n{\n\treturn radix_tree_gang_lookup(&nm_i->nat_set_root, (void **)ep,\n\t\t\t\t\t\t\tstart, nr);\n}\n\nint need_dentry_mark(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct nat_entry *e;\n\tbool need = false;\n\n\tdown_read(&nm_i->nat_tree_lock);\n\te = __lookup_nat_cache(nm_i, nid);\n\tif (e) {\n\t\tif (!get_nat_flag(e, IS_CHECKPOINTED) &&\n\t\t\t\t!get_nat_flag(e, HAS_FSYNCED_INODE))\n\t\t\tneed = true;\n\t}\n\tup_read(&nm_i->nat_tree_lock);\n\treturn need;\n}\n\nbool is_checkpointed_node(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct nat_entry *e;\n\tbool is_cp = true;\n\n\tdown_read(&nm_i->nat_tree_lock);\n\te = __lookup_nat_cache(nm_i, nid);\n\tif (e && !get_nat_flag(e, IS_CHECKPOINTED))\n\t\tis_cp = false;\n\tup_read(&nm_i->nat_tree_lock);\n\treturn is_cp;\n}\n\nbool need_inode_block_update(struct f2fs_sb_info *sbi, nid_t ino)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct nat_entry *e;\n\tbool need_update = true;\n\n\tdown_read(&nm_i->nat_tree_lock);\n\te = __lookup_nat_cache(nm_i, ino);\n\tif (e && get_nat_flag(e, HAS_LAST_FSYNC) &&\n\t\t\t(get_nat_flag(e, IS_CHECKPOINTED) ||\n\t\t\t get_nat_flag(e, HAS_FSYNCED_INODE)))\n\t\tneed_update = false;\n\tup_read(&nm_i->nat_tree_lock);\n\treturn need_update;\n}\n\nstatic struct nat_entry *grab_nat_entry(struct f2fs_nm_info *nm_i, nid_t nid,\n\t\t\t\t\t\t\t\tbool no_fail)\n{\n\tstruct nat_entry *new;\n\n\tif (no_fail) {\n\t\tnew = f2fs_kmem_cache_alloc(nat_entry_slab, GFP_NOFS);\n\t\tf2fs_radix_tree_insert(&nm_i->nat_root, nid, new);\n\t} else {\n\t\tnew = kmem_cache_alloc(nat_entry_slab, GFP_NOFS);\n\t\tif (!new)\n\t\t\treturn NULL;\n\t\tif (radix_tree_insert(&nm_i->nat_root, nid, new)) {\n\t\t\tkmem_cache_free(nat_entry_slab, new);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tmemset(new, 0, sizeof(struct nat_entry));\n\tnat_set_nid(new, nid);\n\tnat_reset_flag(new);\n\tlist_add_tail(&new->list, &nm_i->nat_entries);\n\tnm_i->nat_cnt++;\n\treturn new;\n}\n\nstatic void cache_nat_entry(struct f2fs_sb_info *sbi, nid_t nid,\n\t\t\t\t\t\tstruct f2fs_nat_entry *ne)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct nat_entry *e;\n\n\te = __lookup_nat_cache(nm_i, nid);\n\tif (!e) {\n\t\te = grab_nat_entry(nm_i, nid, false);\n\t\tif (e)\n\t\t\tnode_info_from_raw_nat(&e->ni, ne);\n\t} else {\n\t\tf2fs_bug_on(sbi, nat_get_ino(e) != le32_to_cpu(ne->ino) ||\n\t\t\t\tnat_get_blkaddr(e) !=\n\t\t\t\t\tle32_to_cpu(ne->block_addr) ||\n\t\t\t\tnat_get_version(e) != ne->version);\n\t}\n}\n\nstatic void set_node_addr(struct f2fs_sb_info *sbi, struct node_info *ni,\n\t\t\tblock_t new_blkaddr, bool fsync_done)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct nat_entry *e;\n\n\tdown_write(&nm_i->nat_tree_lock);\n\te = __lookup_nat_cache(nm_i, ni->nid);\n\tif (!e) {\n\t\te = grab_nat_entry(nm_i, ni->nid, true);\n\t\tcopy_node_info(&e->ni, ni);\n\t\tf2fs_bug_on(sbi, ni->blk_addr == NEW_ADDR);\n\t} else if (new_blkaddr == NEW_ADDR) {\n\t\t/*\n\t\t * when nid is reallocated,\n\t\t * previous nat entry can be remained in nat cache.\n\t\t * So, reinitialize it with new information.\n\t\t */\n\t\tcopy_node_info(&e->ni, ni);\n\t\tf2fs_bug_on(sbi, ni->blk_addr != NULL_ADDR);\n\t}\n\n\t/* sanity check */\n\tf2fs_bug_on(sbi, nat_get_blkaddr(e) != ni->blk_addr);\n\tf2fs_bug_on(sbi, nat_get_blkaddr(e) == NULL_ADDR &&\n\t\t\tnew_blkaddr == NULL_ADDR);\n\tf2fs_bug_on(sbi, nat_get_blkaddr(e) == NEW_ADDR &&\n\t\t\tnew_blkaddr == NEW_ADDR);\n\tf2fs_bug_on(sbi, nat_get_blkaddr(e) != NEW_ADDR &&\n\t\t\tnat_get_blkaddr(e) != NULL_ADDR &&\n\t\t\tnew_blkaddr == NEW_ADDR);\n\n\t/* increment version no as node is removed */\n\tif (nat_get_blkaddr(e) != NEW_ADDR && new_blkaddr == NULL_ADDR) {\n\t\tunsigned char version = nat_get_version(e);\n\t\tnat_set_version(e, inc_node_version(version));\n\n\t\t/* in order to reuse the nid */\n\t\tif (nm_i->next_scan_nid > ni->nid)\n\t\t\tnm_i->next_scan_nid = ni->nid;\n\t}\n\n\t/* change address */\n\tnat_set_blkaddr(e, new_blkaddr);\n\tif (new_blkaddr == NEW_ADDR || new_blkaddr == NULL_ADDR)\n\t\tset_nat_flag(e, IS_CHECKPOINTED, false);\n\t__set_nat_cache_dirty(nm_i, e);\n\n\t/* update fsync_mark if its inode nat entry is still alive */\n\tif (ni->nid != ni->ino)\n\t\te = __lookup_nat_cache(nm_i, ni->ino);\n\tif (e) {\n\t\tif (fsync_done && ni->nid == ni->ino)\n\t\t\tset_nat_flag(e, HAS_FSYNCED_INODE, true);\n\t\tset_nat_flag(e, HAS_LAST_FSYNC, fsync_done);\n\t}\n\tup_write(&nm_i->nat_tree_lock);\n}\n\nint try_to_free_nats(struct f2fs_sb_info *sbi, int nr_shrink)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tint nr = nr_shrink;\n\n\tif (!down_write_trylock(&nm_i->nat_tree_lock))\n\t\treturn 0;\n\n\twhile (nr_shrink && !list_empty(&nm_i->nat_entries)) {\n\t\tstruct nat_entry *ne;\n\t\tne = list_first_entry(&nm_i->nat_entries,\n\t\t\t\t\tstruct nat_entry, list);\n\t\t__del_from_nat_cache(nm_i, ne);\n\t\tnr_shrink--;\n\t}\n\tup_write(&nm_i->nat_tree_lock);\n\treturn nr - nr_shrink;\n}\n\n/*\n * This function always returns success\n */\nvoid get_node_info(struct f2fs_sb_info *sbi, nid_t nid, struct node_info *ni)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tstruct f2fs_journal *journal = curseg->journal;\n\tnid_t start_nid = START_NID(nid);\n\tstruct f2fs_nat_block *nat_blk;\n\tstruct page *page = NULL;\n\tstruct f2fs_nat_entry ne;\n\tstruct nat_entry *e;\n\tint i;\n\n\tni->nid = nid;\n\n\t/* Check nat cache */\n\tdown_read(&nm_i->nat_tree_lock);\n\te = __lookup_nat_cache(nm_i, nid);\n\tif (e) {\n\t\tni->ino = nat_get_ino(e);\n\t\tni->blk_addr = nat_get_blkaddr(e);\n\t\tni->version = nat_get_version(e);\n\t\tup_read(&nm_i->nat_tree_lock);\n\t\treturn;\n\t}\n\n\tmemset(&ne, 0, sizeof(struct f2fs_nat_entry));\n\n\t/* Check current segment summary */\n\tdown_read(&curseg->journal_rwsem);\n\ti = lookup_journal_in_cursum(journal, NAT_JOURNAL, nid, 0);\n\tif (i >= 0) {\n\t\tne = nat_in_journal(journal, i);\n\t\tnode_info_from_raw_nat(ni, &ne);\n\t}\n\tup_read(&curseg->journal_rwsem);\n\tif (i >= 0)\n\t\tgoto cache;\n\n\t/* Fill node_info from nat page */\n\tpage = get_current_nat_page(sbi, start_nid);\n\tnat_blk = (struct f2fs_nat_block *)page_address(page);\n\tne = nat_blk->entries[nid - start_nid];\n\tnode_info_from_raw_nat(ni, &ne);\n\tf2fs_put_page(page, 1);\ncache:\n\tup_read(&nm_i->nat_tree_lock);\n\t/* cache nat entry */\n\tdown_write(&nm_i->nat_tree_lock);\n\tcache_nat_entry(sbi, nid, &ne);\n\tup_write(&nm_i->nat_tree_lock);\n}\n\n/*\n * readahead MAX_RA_NODE number of node pages.\n */\nstatic void ra_node_pages(struct page *parent, int start, int n)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(parent);\n\tstruct blk_plug plug;\n\tint i, end;\n\tnid_t nid;\n\n\tblk_start_plug(&plug);\n\n\t/* Then, try readahead for siblings of the desired node */\n\tend = start + n;\n\tend = min(end, NIDS_PER_BLOCK);\n\tfor (i = start; i < end; i++) {\n\t\tnid = get_nid(parent, i, false);\n\t\tra_node_page(sbi, nid);\n\t}\n\n\tblk_finish_plug(&plug);\n}\n\npgoff_t get_next_page_offset(struct dnode_of_data *dn, pgoff_t pgofs)\n{\n\tconst long direct_index = ADDRS_PER_INODE(dn->inode);\n\tconst long direct_blks = ADDRS_PER_BLOCK;\n\tconst long indirect_blks = ADDRS_PER_BLOCK * NIDS_PER_BLOCK;\n\tunsigned int skipped_unit = ADDRS_PER_BLOCK;\n\tint cur_level = dn->cur_level;\n\tint max_level = dn->max_level;\n\tpgoff_t base = 0;\n\n\tif (!dn->max_level)\n\t\treturn pgofs + 1;\n\n\twhile (max_level-- > cur_level)\n\t\tskipped_unit *= NIDS_PER_BLOCK;\n\n\tswitch (dn->max_level) {\n\tcase 3:\n\t\tbase += 2 * indirect_blks;\n\tcase 2:\n\t\tbase += 2 * direct_blks;\n\tcase 1:\n\t\tbase += direct_index;\n\t\tbreak;\n\tdefault:\n\t\tf2fs_bug_on(F2FS_I_SB(dn->inode), 1);\n\t}\n\n\treturn ((pgofs - base) / skipped_unit + 1) * skipped_unit + base;\n}\n\n/*\n * The maximum depth is four.\n * Offset[0] will have raw inode offset.\n */\nstatic int get_node_path(struct inode *inode, long block,\n\t\t\t\tint offset[4], unsigned int noffset[4])\n{\n\tconst long direct_index = ADDRS_PER_INODE(inode);\n\tconst long direct_blks = ADDRS_PER_BLOCK;\n\tconst long dptrs_per_blk = NIDS_PER_BLOCK;\n\tconst long indirect_blks = ADDRS_PER_BLOCK * NIDS_PER_BLOCK;\n\tconst long dindirect_blks = indirect_blks * NIDS_PER_BLOCK;\n\tint n = 0;\n\tint level = 0;\n\n\tnoffset[0] = 0;\n\n\tif (block < direct_index) {\n\t\toffset[n] = block;\n\t\tgoto got;\n\t}\n\tblock -= direct_index;\n\tif (block < direct_blks) {\n\t\toffset[n++] = NODE_DIR1_BLOCK;\n\t\tnoffset[n] = 1;\n\t\toffset[n] = block;\n\t\tlevel = 1;\n\t\tgoto got;\n\t}\n\tblock -= direct_blks;\n\tif (block < direct_blks) {\n\t\toffset[n++] = NODE_DIR2_BLOCK;\n\t\tnoffset[n] = 2;\n\t\toffset[n] = block;\n\t\tlevel = 1;\n\t\tgoto got;\n\t}\n\tblock -= direct_blks;\n\tif (block < indirect_blks) {\n\t\toffset[n++] = NODE_IND1_BLOCK;\n\t\tnoffset[n] = 3;\n\t\toffset[n++] = block / direct_blks;\n\t\tnoffset[n] = 4 + offset[n - 1];\n\t\toffset[n] = block % direct_blks;\n\t\tlevel = 2;\n\t\tgoto got;\n\t}\n\tblock -= indirect_blks;\n\tif (block < indirect_blks) {\n\t\toffset[n++] = NODE_IND2_BLOCK;\n\t\tnoffset[n] = 4 + dptrs_per_blk;\n\t\toffset[n++] = block / direct_blks;\n\t\tnoffset[n] = 5 + dptrs_per_blk + offset[n - 1];\n\t\toffset[n] = block % direct_blks;\n\t\tlevel = 2;\n\t\tgoto got;\n\t}\n\tblock -= indirect_blks;\n\tif (block < dindirect_blks) {\n\t\toffset[n++] = NODE_DIND_BLOCK;\n\t\tnoffset[n] = 5 + (dptrs_per_blk * 2);\n\t\toffset[n++] = block / indirect_blks;\n\t\tnoffset[n] = 6 + (dptrs_per_blk * 2) +\n\t\t\t      offset[n - 1] * (dptrs_per_blk + 1);\n\t\toffset[n++] = (block / direct_blks) % dptrs_per_blk;\n\t\tnoffset[n] = 7 + (dptrs_per_blk * 2) +\n\t\t\t      offset[n - 2] * (dptrs_per_blk + 1) +\n\t\t\t      offset[n - 1];\n\t\toffset[n] = block % direct_blks;\n\t\tlevel = 3;\n\t\tgoto got;\n\t} else {\n\t\tBUG();\n\t}\ngot:\n\treturn level;\n}\n\n/*\n * Caller should call f2fs_put_dnode(dn).\n * Also, it should grab and release a rwsem by calling f2fs_lock_op() and\n * f2fs_unlock_op() only if ro is not set RDONLY_NODE.\n * In the case of RDONLY_NODE, we don't need to care about mutex.\n */\nint get_dnode_of_data(struct dnode_of_data *dn, pgoff_t index, int mode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct page *npage[4];\n\tstruct page *parent = NULL;\n\tint offset[4];\n\tunsigned int noffset[4];\n\tnid_t nids[4];\n\tint level, i = 0;\n\tint err = 0;\n\n\tlevel = get_node_path(dn->inode, index, offset, noffset);\n\n\tnids[0] = dn->inode->i_ino;\n\tnpage[0] = dn->inode_page;\n\n\tif (!npage[0]) {\n\t\tnpage[0] = get_node_page(sbi, nids[0]);\n\t\tif (IS_ERR(npage[0]))\n\t\t\treturn PTR_ERR(npage[0]);\n\t}\n\n\t/* if inline_data is set, should not report any block indices */\n\tif (f2fs_has_inline_data(dn->inode) && index) {\n\t\terr = -ENOENT;\n\t\tf2fs_put_page(npage[0], 1);\n\t\tgoto release_out;\n\t}\n\n\tparent = npage[0];\n\tif (level != 0)\n\t\tnids[1] = get_nid(parent, offset[0], true);\n\tdn->inode_page = npage[0];\n\tdn->inode_page_locked = true;\n\n\t/* get indirect or direct nodes */\n\tfor (i = 1; i <= level; i++) {\n\t\tbool done = false;\n\n\t\tif (!nids[i] && mode == ALLOC_NODE) {\n\t\t\t/* alloc new node */\n\t\t\tif (!alloc_nid(sbi, &(nids[i]))) {\n\t\t\t\terr = -ENOSPC;\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\n\t\t\tdn->nid = nids[i];\n\t\t\tnpage[i] = new_node_page(dn, noffset[i], NULL);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\talloc_nid_failed(sbi, nids[i]);\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\n\t\t\tset_nid(parent, offset[i - 1], nids[i], i == 1);\n\t\t\talloc_nid_done(sbi, nids[i]);\n\t\t\tdone = true;\n\t\t} else if (mode == LOOKUP_NODE_RA && i == level && level > 1) {\n\t\t\tnpage[i] = get_node_page_ra(parent, offset[i - 1]);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\t\t\tdone = true;\n\t\t}\n\t\tif (i == 1) {\n\t\t\tdn->inode_page_locked = false;\n\t\t\tunlock_page(parent);\n\t\t} else {\n\t\t\tf2fs_put_page(parent, 1);\n\t\t}\n\n\t\tif (!done) {\n\t\t\tnpage[i] = get_node_page(sbi, nids[i]);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tf2fs_put_page(npage[0], 0);\n\t\t\t\tgoto release_out;\n\t\t\t}\n\t\t}\n\t\tif (i < level) {\n\t\t\tparent = npage[i];\n\t\t\tnids[i + 1] = get_nid(parent, offset[i], false);\n\t\t}\n\t}\n\tdn->nid = nids[level];\n\tdn->ofs_in_node = offset[level];\n\tdn->node_page = npage[level];\n\tdn->data_blkaddr = datablock_addr(dn->node_page, dn->ofs_in_node);\n\treturn 0;\n\nrelease_pages:\n\tf2fs_put_page(parent, 1);\n\tif (i > 1)\n\t\tf2fs_put_page(npage[0], 0);\nrelease_out:\n\tdn->inode_page = NULL;\n\tdn->node_page = NULL;\n\tif (err == -ENOENT) {\n\t\tdn->cur_level = i;\n\t\tdn->max_level = level;\n\t\tdn->ofs_in_node = offset[level];\n\t}\n\treturn err;\n}\n\nstatic void truncate_node(struct dnode_of_data *dn)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct node_info ni;\n\n\tget_node_info(sbi, dn->nid, &ni);\n\tif (dn->inode->i_blocks == 0) {\n\t\tf2fs_bug_on(sbi, ni.blk_addr != NULL_ADDR);\n\t\tgoto invalidate;\n\t}\n\tf2fs_bug_on(sbi, ni.blk_addr == NULL_ADDR);\n\n\t/* Deallocate node address */\n\tinvalidate_blocks(sbi, ni.blk_addr);\n\tdec_valid_node_count(sbi, dn->inode);\n\tset_node_addr(sbi, &ni, NULL_ADDR, false);\n\n\tif (dn->nid == dn->inode->i_ino) {\n\t\tremove_orphan_inode(sbi, dn->nid);\n\t\tdec_valid_inode_count(sbi);\n\t\tf2fs_inode_synced(dn->inode);\n\t}\ninvalidate:\n\tclear_node_page_dirty(dn->node_page);\n\tset_sbi_flag(sbi, SBI_IS_DIRTY);\n\n\tf2fs_put_page(dn->node_page, 1);\n\n\tinvalidate_mapping_pages(NODE_MAPPING(sbi),\n\t\t\tdn->node_page->index, dn->node_page->index);\n\n\tdn->node_page = NULL;\n\ttrace_f2fs_truncate_node(dn->inode, dn->nid, ni.blk_addr);\n}\n\nstatic int truncate_dnode(struct dnode_of_data *dn)\n{\n\tstruct page *page;\n\n\tif (dn->nid == 0)\n\t\treturn 1;\n\n\t/* get direct node */\n\tpage = get_node_page(F2FS_I_SB(dn->inode), dn->nid);\n\tif (IS_ERR(page) && PTR_ERR(page) == -ENOENT)\n\t\treturn 1;\n\telse if (IS_ERR(page))\n\t\treturn PTR_ERR(page);\n\n\t/* Make dnode_of_data for parameter */\n\tdn->node_page = page;\n\tdn->ofs_in_node = 0;\n\ttruncate_data_blocks(dn);\n\ttruncate_node(dn);\n\treturn 1;\n}\n\nstatic int truncate_nodes(struct dnode_of_data *dn, unsigned int nofs,\n\t\t\t\t\t\tint ofs, int depth)\n{\n\tstruct dnode_of_data rdn = *dn;\n\tstruct page *page;\n\tstruct f2fs_node *rn;\n\tnid_t child_nid;\n\tunsigned int child_nofs;\n\tint freed = 0;\n\tint i, ret;\n\n\tif (dn->nid == 0)\n\t\treturn NIDS_PER_BLOCK + 1;\n\n\ttrace_f2fs_truncate_nodes_enter(dn->inode, dn->nid, dn->data_blkaddr);\n\n\tpage = get_node_page(F2FS_I_SB(dn->inode), dn->nid);\n\tif (IS_ERR(page)) {\n\t\ttrace_f2fs_truncate_nodes_exit(dn->inode, PTR_ERR(page));\n\t\treturn PTR_ERR(page);\n\t}\n\n\tra_node_pages(page, ofs, NIDS_PER_BLOCK);\n\n\trn = F2FS_NODE(page);\n\tif (depth < 3) {\n\t\tfor (i = ofs; i < NIDS_PER_BLOCK; i++, freed++) {\n\t\t\tchild_nid = le32_to_cpu(rn->in.nid[i]);\n\t\t\tif (child_nid == 0)\n\t\t\t\tcontinue;\n\t\t\trdn.nid = child_nid;\n\t\t\tret = truncate_dnode(&rdn);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out_err;\n\t\t\tif (set_nid(page, i, 0, false))\n\t\t\t\tdn->node_changed = true;\n\t\t}\n\t} else {\n\t\tchild_nofs = nofs + ofs * (NIDS_PER_BLOCK + 1) + 1;\n\t\tfor (i = ofs; i < NIDS_PER_BLOCK; i++) {\n\t\t\tchild_nid = le32_to_cpu(rn->in.nid[i]);\n\t\t\tif (child_nid == 0) {\n\t\t\t\tchild_nofs += NIDS_PER_BLOCK + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trdn.nid = child_nid;\n\t\t\tret = truncate_nodes(&rdn, child_nofs, 0, depth - 1);\n\t\t\tif (ret == (NIDS_PER_BLOCK + 1)) {\n\t\t\t\tif (set_nid(page, i, 0, false))\n\t\t\t\t\tdn->node_changed = true;\n\t\t\t\tchild_nofs += ret;\n\t\t\t} else if (ret < 0 && ret != -ENOENT) {\n\t\t\t\tgoto out_err;\n\t\t\t}\n\t\t}\n\t\tfreed = child_nofs;\n\t}\n\n\tif (!ofs) {\n\t\t/* remove current indirect node */\n\t\tdn->node_page = page;\n\t\ttruncate_node(dn);\n\t\tfreed++;\n\t} else {\n\t\tf2fs_put_page(page, 1);\n\t}\n\ttrace_f2fs_truncate_nodes_exit(dn->inode, freed);\n\treturn freed;\n\nout_err:\n\tf2fs_put_page(page, 1);\n\ttrace_f2fs_truncate_nodes_exit(dn->inode, ret);\n\treturn ret;\n}\n\nstatic int truncate_partial_nodes(struct dnode_of_data *dn,\n\t\t\tstruct f2fs_inode *ri, int *offset, int depth)\n{\n\tstruct page *pages[2];\n\tnid_t nid[3];\n\tnid_t child_nid;\n\tint err = 0;\n\tint i;\n\tint idx = depth - 2;\n\n\tnid[0] = le32_to_cpu(ri->i_nid[offset[0] - NODE_DIR1_BLOCK]);\n\tif (!nid[0])\n\t\treturn 0;\n\n\t/* get indirect nodes in the path */\n\tfor (i = 0; i < idx + 1; i++) {\n\t\t/* reference count'll be increased */\n\t\tpages[i] = get_node_page(F2FS_I_SB(dn->inode), nid[i]);\n\t\tif (IS_ERR(pages[i])) {\n\t\t\terr = PTR_ERR(pages[i]);\n\t\t\tidx = i - 1;\n\t\t\tgoto fail;\n\t\t}\n\t\tnid[i + 1] = get_nid(pages[i], offset[i + 1], false);\n\t}\n\n\tra_node_pages(pages[idx], offset[idx + 1], NIDS_PER_BLOCK);\n\n\t/* free direct nodes linked to a partial indirect node */\n\tfor (i = offset[idx + 1]; i < NIDS_PER_BLOCK; i++) {\n\t\tchild_nid = get_nid(pages[idx], i, false);\n\t\tif (!child_nid)\n\t\t\tcontinue;\n\t\tdn->nid = child_nid;\n\t\terr = truncate_dnode(dn);\n\t\tif (err < 0)\n\t\t\tgoto fail;\n\t\tif (set_nid(pages[idx], i, 0, false))\n\t\t\tdn->node_changed = true;\n\t}\n\n\tif (offset[idx + 1] == 0) {\n\t\tdn->node_page = pages[idx];\n\t\tdn->nid = nid[idx];\n\t\ttruncate_node(dn);\n\t} else {\n\t\tf2fs_put_page(pages[idx], 1);\n\t}\n\toffset[idx]++;\n\toffset[idx + 1] = 0;\n\tidx--;\nfail:\n\tfor (i = idx; i >= 0; i--)\n\t\tf2fs_put_page(pages[i], 1);\n\n\ttrace_f2fs_truncate_partial_nodes(dn->inode, nid, depth, err);\n\n\treturn err;\n}\n\n/*\n * All the block addresses of data and nodes should be nullified.\n */\nint truncate_inode_blocks(struct inode *inode, pgoff_t from)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tint err = 0, cont = 1;\n\tint level, offset[4], noffset[4];\n\tunsigned int nofs = 0;\n\tstruct f2fs_inode *ri;\n\tstruct dnode_of_data dn;\n\tstruct page *page;\n\n\ttrace_f2fs_truncate_inode_blocks_enter(inode, from);\n\n\tlevel = get_node_path(inode, from, offset, noffset);\n\n\tpage = get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(page)) {\n\t\ttrace_f2fs_truncate_inode_blocks_exit(inode, PTR_ERR(page));\n\t\treturn PTR_ERR(page);\n\t}\n\n\tset_new_dnode(&dn, inode, page, NULL, 0);\n\tunlock_page(page);\n\n\tri = F2FS_INODE(page);\n\tswitch (level) {\n\tcase 0:\n\tcase 1:\n\t\tnofs = noffset[1];\n\t\tbreak;\n\tcase 2:\n\t\tnofs = noffset[1];\n\t\tif (!offset[level - 1])\n\t\t\tgoto skip_partial;\n\t\terr = truncate_partial_nodes(&dn, ri, offset, level);\n\t\tif (err < 0 && err != -ENOENT)\n\t\t\tgoto fail;\n\t\tnofs += 1 + NIDS_PER_BLOCK;\n\t\tbreak;\n\tcase 3:\n\t\tnofs = 5 + 2 * NIDS_PER_BLOCK;\n\t\tif (!offset[level - 1])\n\t\t\tgoto skip_partial;\n\t\terr = truncate_partial_nodes(&dn, ri, offset, level);\n\t\tif (err < 0 && err != -ENOENT)\n\t\t\tgoto fail;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\nskip_partial:\n\twhile (cont) {\n\t\tdn.nid = le32_to_cpu(ri->i_nid[offset[0] - NODE_DIR1_BLOCK]);\n\t\tswitch (offset[0]) {\n\t\tcase NODE_DIR1_BLOCK:\n\t\tcase NODE_DIR2_BLOCK:\n\t\t\terr = truncate_dnode(&dn);\n\t\t\tbreak;\n\n\t\tcase NODE_IND1_BLOCK:\n\t\tcase NODE_IND2_BLOCK:\n\t\t\terr = truncate_nodes(&dn, nofs, offset[1], 2);\n\t\t\tbreak;\n\n\t\tcase NODE_DIND_BLOCK:\n\t\t\terr = truncate_nodes(&dn, nofs, offset[1], 3);\n\t\t\tcont = 0;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t\tif (err < 0 && err != -ENOENT)\n\t\t\tgoto fail;\n\t\tif (offset[1] == 0 &&\n\t\t\t\tri->i_nid[offset[0] - NODE_DIR1_BLOCK]) {\n\t\t\tlock_page(page);\n\t\t\tBUG_ON(page->mapping != NODE_MAPPING(sbi));\n\t\t\tf2fs_wait_on_page_writeback(page, NODE, true);\n\t\t\tri->i_nid[offset[0] - NODE_DIR1_BLOCK] = 0;\n\t\t\tset_page_dirty(page);\n\t\t\tunlock_page(page);\n\t\t}\n\t\toffset[1] = 0;\n\t\toffset[0]++;\n\t\tnofs += err;\n\t}\nfail:\n\tf2fs_put_page(page, 0);\n\ttrace_f2fs_truncate_inode_blocks_exit(inode, err);\n\treturn err > 0 ? 0 : err;\n}\n\nint truncate_xattr_node(struct inode *inode, struct page *page)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tnid_t nid = F2FS_I(inode)->i_xattr_nid;\n\tstruct dnode_of_data dn;\n\tstruct page *npage;\n\n\tif (!nid)\n\t\treturn 0;\n\n\tnpage = get_node_page(sbi, nid);\n\tif (IS_ERR(npage))\n\t\treturn PTR_ERR(npage);\n\n\tf2fs_i_xnid_write(inode, 0);\n\n\tset_new_dnode(&dn, inode, page, npage, nid);\n\n\tif (page)\n\t\tdn.inode_page_locked = true;\n\ttruncate_node(&dn);\n\treturn 0;\n}\n\n/*\n * Caller should grab and release a rwsem by calling f2fs_lock_op() and\n * f2fs_unlock_op().\n */\nint remove_inode_page(struct inode *inode)\n{\n\tstruct dnode_of_data dn;\n\tint err;\n\n\tset_new_dnode(&dn, inode, NULL, NULL, inode->i_ino);\n\terr = get_dnode_of_data(&dn, 0, LOOKUP_NODE);\n\tif (err)\n\t\treturn err;\n\n\terr = truncate_xattr_node(inode, dn.inode_page);\n\tif (err) {\n\t\tf2fs_put_dnode(&dn);\n\t\treturn err;\n\t}\n\n\t/* remove potential inline_data blocks */\n\tif (S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\t\t\tS_ISLNK(inode->i_mode))\n\t\ttruncate_data_blocks_range(&dn, 1);\n\n\t/* 0 is possible, after f2fs_new_inode() has failed */\n\tf2fs_bug_on(F2FS_I_SB(inode),\n\t\t\tinode->i_blocks != 0 && inode->i_blocks != 1);\n\n\t/* will put inode & node pages */\n\ttruncate_node(&dn);\n\treturn 0;\n}\n\nstruct page *new_inode_page(struct inode *inode)\n{\n\tstruct dnode_of_data dn;\n\n\t/* allocate inode page for new inode */\n\tset_new_dnode(&dn, inode, NULL, NULL, inode->i_ino);\n\n\t/* caller should f2fs_put_page(page, 1); */\n\treturn new_node_page(&dn, 0, NULL);\n}\n\nstruct page *new_node_page(struct dnode_of_data *dn,\n\t\t\t\tunsigned int ofs, struct page *ipage)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct node_info new_ni;\n\tstruct page *page;\n\tint err;\n\n\tif (unlikely(is_inode_flag_set(dn->inode, FI_NO_ALLOC)))\n\t\treturn ERR_PTR(-EPERM);\n\n\tpage = f2fs_grab_cache_page(NODE_MAPPING(sbi), dn->nid, false);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (unlikely(!inc_valid_node_count(sbi, dn->inode))) {\n\t\terr = -ENOSPC;\n\t\tgoto fail;\n\t}\n#ifdef CONFIG_F2FS_CHECK_FS\n\tget_node_info(sbi, dn->nid, &new_ni);\n\tf2fs_bug_on(sbi, new_ni.blk_addr != NULL_ADDR);\n#endif\n\tnew_ni.nid = dn->nid;\n\tnew_ni.ino = dn->inode->i_ino;\n\tnew_ni.blk_addr = NULL_ADDR;\n\tnew_ni.flag = 0;\n\tnew_ni.version = 0;\n\tset_node_addr(sbi, &new_ni, NEW_ADDR, false);\n\n\tf2fs_wait_on_page_writeback(page, NODE, true);\n\tfill_node_footer(page, dn->nid, dn->inode->i_ino, ofs, true);\n\tset_cold_node(dn->inode, page);\n\tif (!PageUptodate(page))\n\t\tSetPageUptodate(page);\n\tif (set_page_dirty(page))\n\t\tdn->node_changed = true;\n\n\tif (f2fs_has_xattr_block(ofs))\n\t\tf2fs_i_xnid_write(dn->inode, dn->nid);\n\n\tif (ofs == 0)\n\t\tinc_valid_inode_count(sbi);\n\treturn page;\n\nfail:\n\tclear_node_page_dirty(page);\n\tf2fs_put_page(page, 1);\n\treturn ERR_PTR(err);\n}\n\n/*\n * Caller should do after getting the following values.\n * 0: f2fs_put_page(page, 0)\n * LOCKED_PAGE or error: f2fs_put_page(page, 1)\n */\nstatic int read_node_page(struct page *page, int op_flags)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\tstruct node_info ni;\n\tstruct f2fs_io_info fio = {\n\t\t.sbi = sbi,\n\t\t.type = NODE,\n\t\t.op = REQ_OP_READ,\n\t\t.op_flags = op_flags,\n\t\t.page = page,\n\t\t.encrypted_page = NULL,\n\t};\n\n\tif (PageUptodate(page))\n\t\treturn LOCKED_PAGE;\n\n\tget_node_info(sbi, page->index, &ni);\n\n\tif (unlikely(ni.blk_addr == NULL_ADDR)) {\n\t\tClearPageUptodate(page);\n\t\treturn -ENOENT;\n\t}\n\n\tfio.new_blkaddr = fio.old_blkaddr = ni.blk_addr;\n\treturn f2fs_submit_page_bio(&fio);\n}\n\n/*\n * Readahead a node page\n */\nvoid ra_node_page(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tstruct page *apage;\n\tint err;\n\n\tif (!nid)\n\t\treturn;\n\tf2fs_bug_on(sbi, check_nid_range(sbi, nid));\n\n\trcu_read_lock();\n\tapage = radix_tree_lookup(&NODE_MAPPING(sbi)->page_tree, nid);\n\trcu_read_unlock();\n\tif (apage)\n\t\treturn;\n\n\tapage = f2fs_grab_cache_page(NODE_MAPPING(sbi), nid, false);\n\tif (!apage)\n\t\treturn;\n\n\terr = read_node_page(apage, REQ_RAHEAD);\n\tf2fs_put_page(apage, err ? 1 : 0);\n}\n\nstatic struct page *__get_node_page(struct f2fs_sb_info *sbi, pgoff_t nid,\n\t\t\t\t\tstruct page *parent, int start)\n{\n\tstruct page *page;\n\tint err;\n\n\tif (!nid)\n\t\treturn ERR_PTR(-ENOENT);\n\tf2fs_bug_on(sbi, check_nid_range(sbi, nid));\nrepeat:\n\tpage = f2fs_grab_cache_page(NODE_MAPPING(sbi), nid, false);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = read_node_page(page, 0);\n\tif (err < 0) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(err);\n\t} else if (err == LOCKED_PAGE) {\n\t\tgoto page_hit;\n\t}\n\n\tif (parent)\n\t\tra_node_pages(parent, start + 1, MAX_RA_NODE);\n\n\tlock_page(page);\n\n\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\n\n\tif (unlikely(!PageUptodate(page)))\n\t\tgoto out_err;\npage_hit:\n\tif(unlikely(nid != nid_of_node(page))) {\n\t\tf2fs_bug_on(sbi, 1);\n\t\tClearPageUptodate(page);\nout_err:\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}\n\nstruct page *get_node_page(struct f2fs_sb_info *sbi, pgoff_t nid)\n{\n\treturn __get_node_page(sbi, nid, NULL, 0);\n}\n\nstruct page *get_node_page_ra(struct page *parent, int start)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(parent);\n\tnid_t nid = get_nid(parent, start, false);\n\n\treturn __get_node_page(sbi, nid, parent, start);\n}\n\nstatic void flush_inline_data(struct f2fs_sb_info *sbi, nid_t ino)\n{\n\tstruct inode *inode;\n\tstruct page *page;\n\tint ret;\n\n\t/* should flush inline_data before evict_inode */\n\tinode = ilookup(sbi->sb, ino);\n\tif (!inode)\n\t\treturn;\n\n\tpage = pagecache_get_page(inode->i_mapping, 0, FGP_LOCK|FGP_NOWAIT, 0);\n\tif (!page)\n\t\tgoto iput_out;\n\n\tif (!PageUptodate(page))\n\t\tgoto page_out;\n\n\tif (!PageDirty(page))\n\t\tgoto page_out;\n\n\tif (!clear_page_dirty_for_io(page))\n\t\tgoto page_out;\n\n\tret = f2fs_write_inline_data(inode, page);\n\tinode_dec_dirty_pages(inode);\n\tremove_dirty_inode(inode);\n\tif (ret)\n\t\tset_page_dirty(page);\npage_out:\n\tf2fs_put_page(page, 1);\niput_out:\n\tiput(inode);\n}\n\nvoid move_node_page(struct page *node_page, int gc_type)\n{\n\tif (gc_type == FG_GC) {\n\t\tstruct f2fs_sb_info *sbi = F2FS_P_SB(node_page);\n\t\tstruct writeback_control wbc = {\n\t\t\t.sync_mode = WB_SYNC_ALL,\n\t\t\t.nr_to_write = 1,\n\t\t\t.for_reclaim = 0,\n\t\t};\n\n\t\tset_page_dirty(node_page);\n\t\tf2fs_wait_on_page_writeback(node_page, NODE, true);\n\n\t\tf2fs_bug_on(sbi, PageWriteback(node_page));\n\t\tif (!clear_page_dirty_for_io(node_page))\n\t\t\tgoto out_page;\n\n\t\tif (NODE_MAPPING(sbi)->a_ops->writepage(node_page, &wbc))\n\t\t\tunlock_page(node_page);\n\t\tgoto release_page;\n\t} else {\n\t\t/* set page dirty and write it */\n\t\tif (!PageWriteback(node_page))\n\t\t\tset_page_dirty(node_page);\n\t}\nout_page:\n\tunlock_page(node_page);\nrelease_page:\n\tf2fs_put_page(node_page, 0);\n}\n\nstatic struct page *last_fsync_dnode(struct f2fs_sb_info *sbi, nid_t ino)\n{\n\tpgoff_t index, end;\n\tstruct pagevec pvec;\n\tstruct page *last_page = NULL;\n\n\tpagevec_init(&pvec, 0);\n\tindex = 0;\n\tend = ULONG_MAX;\n\n\twhile (index <= end) {\n\t\tint i, nr_pages;\n\t\tnr_pages = pagevec_lookup_tag(&pvec, NODE_MAPPING(sbi), &index,\n\t\t\t\tPAGECACHE_TAG_DIRTY,\n\t\t\t\tmin(end - index, (pgoff_t)PAGEVEC_SIZE-1) + 1);\n\t\tif (nr_pages == 0)\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\tif (unlikely(f2fs_cp_error(sbi))) {\n\t\t\t\tf2fs_put_page(last_page, 0);\n\t\t\t\tpagevec_release(&pvec);\n\t\t\t\treturn ERR_PTR(-EIO);\n\t\t\t}\n\n\t\t\tif (!IS_DNODE(page) || !is_cold_node(page))\n\t\t\t\tcontinue;\n\t\t\tif (ino_of_node(page) != ino)\n\t\t\t\tcontinue;\n\n\t\t\tlock_page(page);\n\n\t\t\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\ncontinue_unlock:\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ino_of_node(page) != ino)\n\t\t\t\tgoto continue_unlock;\n\n\t\t\tif (!PageDirty(page)) {\n\t\t\t\t/* someone wrote it for us */\n\t\t\t\tgoto continue_unlock;\n\t\t\t}\n\n\t\t\tif (last_page)\n\t\t\t\tf2fs_put_page(last_page, 0);\n\n\t\t\tget_page(page);\n\t\t\tlast_page = page;\n\t\t\tunlock_page(page);\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t}\n\treturn last_page;\n}\n\nstatic int __write_node_page(struct page *page, bool atomic, bool *submitted,\n\t\t\t\tstruct writeback_control *wbc)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\tnid_t nid;\n\tstruct node_info ni;\n\tstruct f2fs_io_info fio = {\n\t\t.sbi = sbi,\n\t\t.type = NODE,\n\t\t.op = REQ_OP_WRITE,\n\t\t.op_flags = wbc_to_write_flags(wbc),\n\t\t.page = page,\n\t\t.encrypted_page = NULL,\n\t\t.submitted = false,\n\t};\n\n\ttrace_f2fs_writepage(page, NODE);\n\n\tif (unlikely(is_sbi_flag_set(sbi, SBI_POR_DOING)))\n\t\tgoto redirty_out;\n\tif (unlikely(f2fs_cp_error(sbi)))\n\t\tgoto redirty_out;\n\n\t/* get old block addr of this node page */\n\tnid = nid_of_node(page);\n\tf2fs_bug_on(sbi, page->index != nid);\n\n\tif (wbc->for_reclaim) {\n\t\tif (!down_read_trylock(&sbi->node_write))\n\t\t\tgoto redirty_out;\n\t} else {\n\t\tdown_read(&sbi->node_write);\n\t}\n\n\tget_node_info(sbi, nid, &ni);\n\n\t/* This page is already truncated */\n\tif (unlikely(ni.blk_addr == NULL_ADDR)) {\n\t\tClearPageUptodate(page);\n\t\tdec_page_count(sbi, F2FS_DIRTY_NODES);\n\t\tup_read(&sbi->node_write);\n\t\tunlock_page(page);\n\t\treturn 0;\n\t}\n\n\tif (atomic && !test_opt(sbi, NOBARRIER))\n\t\tfio.op_flags |= REQ_PREFLUSH | REQ_FUA;\n\n\tset_page_writeback(page);\n\tfio.old_blkaddr = ni.blk_addr;\n\twrite_node_page(nid, &fio);\n\tset_node_addr(sbi, &ni, fio.new_blkaddr, is_fsync_dnode(page));\n\tdec_page_count(sbi, F2FS_DIRTY_NODES);\n\tup_read(&sbi->node_write);\n\n\tif (wbc->for_reclaim) {\n\t\tf2fs_submit_merged_bio_cond(sbi, page->mapping->host, 0,\n\t\t\t\t\t\tpage->index, NODE, WRITE);\n\t\tsubmitted = NULL;\n\t}\n\n\tunlock_page(page);\n\n\tif (unlikely(f2fs_cp_error(sbi))) {\n\t\tf2fs_submit_merged_bio(sbi, NODE, WRITE);\n\t\tsubmitted = NULL;\n\t}\n\tif (submitted)\n\t\t*submitted = fio.submitted;\n\n\treturn 0;\n\nredirty_out:\n\tredirty_page_for_writepage(wbc, page);\n\treturn AOP_WRITEPAGE_ACTIVATE;\n}\n\nstatic int f2fs_write_node_page(struct page *page,\n\t\t\t\tstruct writeback_control *wbc)\n{\n\treturn __write_node_page(page, false, NULL, wbc);\n}\n\nint fsync_node_pages(struct f2fs_sb_info *sbi, struct inode *inode,\n\t\t\tstruct writeback_control *wbc, bool atomic)\n{\n\tpgoff_t index, end;\n\tpgoff_t last_idx = ULONG_MAX;\n\tstruct pagevec pvec;\n\tint ret = 0;\n\tstruct page *last_page = NULL;\n\tbool marked = false;\n\tnid_t ino = inode->i_ino;\n\n\tif (atomic) {\n\t\tlast_page = last_fsync_dnode(sbi, ino);\n\t\tif (IS_ERR_OR_NULL(last_page))\n\t\t\treturn PTR_ERR_OR_ZERO(last_page);\n\t}\nretry:\n\tpagevec_init(&pvec, 0);\n\tindex = 0;\n\tend = ULONG_MAX;\n\n\twhile (index <= end) {\n\t\tint i, nr_pages;\n\t\tnr_pages = pagevec_lookup_tag(&pvec, NODE_MAPPING(sbi), &index,\n\t\t\t\tPAGECACHE_TAG_DIRTY,\n\t\t\t\tmin(end - index, (pgoff_t)PAGEVEC_SIZE-1) + 1);\n\t\tif (nr_pages == 0)\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\t\t\tbool submitted = false;\n\n\t\t\tif (unlikely(f2fs_cp_error(sbi))) {\n\t\t\t\tf2fs_put_page(last_page, 0);\n\t\t\t\tpagevec_release(&pvec);\n\t\t\t\tret = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (!IS_DNODE(page) || !is_cold_node(page))\n\t\t\t\tcontinue;\n\t\t\tif (ino_of_node(page) != ino)\n\t\t\t\tcontinue;\n\n\t\t\tlock_page(page);\n\n\t\t\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\ncontinue_unlock:\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ino_of_node(page) != ino)\n\t\t\t\tgoto continue_unlock;\n\n\t\t\tif (!PageDirty(page) && page != last_page) {\n\t\t\t\t/* someone wrote it for us */\n\t\t\t\tgoto continue_unlock;\n\t\t\t}\n\n\t\t\tf2fs_wait_on_page_writeback(page, NODE, true);\n\t\t\tBUG_ON(PageWriteback(page));\n\n\t\t\tif (!atomic || page == last_page) {\n\t\t\t\tset_fsync_mark(page, 1);\n\t\t\t\tif (IS_INODE(page)) {\n\t\t\t\t\tif (is_inode_flag_set(inode,\n\t\t\t\t\t\t\t\tFI_DIRTY_INODE))\n\t\t\t\t\t\tupdate_inode(inode, page);\n\t\t\t\t\tset_dentry_mark(page,\n\t\t\t\t\t\tneed_dentry_mark(sbi, ino));\n\t\t\t\t}\n\t\t\t\t/*  may be written by other thread */\n\t\t\t\tif (!PageDirty(page))\n\t\t\t\t\tset_page_dirty(page);\n\t\t\t}\n\n\t\t\tif (!clear_page_dirty_for_io(page))\n\t\t\t\tgoto continue_unlock;\n\n\t\t\tret = __write_node_page(page, atomic &&\n\t\t\t\t\t\tpage == last_page,\n\t\t\t\t\t\t&submitted, wbc);\n\t\t\tif (ret) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tf2fs_put_page(last_page, 0);\n\t\t\t\tbreak;\n\t\t\t} else if (submitted) {\n\t\t\t\tlast_idx = page->index;\n\t\t\t}\n\n\t\t\tif (page == last_page) {\n\t\t\t\tf2fs_put_page(page, 0);\n\t\t\t\tmarked = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\n\t\tif (ret || marked)\n\t\t\tbreak;\n\t}\n\tif (!ret && atomic && !marked) {\n\t\tf2fs_msg(sbi->sb, KERN_DEBUG,\n\t\t\t\"Retry to write fsync mark: ino=%u, idx=%lx\",\n\t\t\t\t\tino, last_page->index);\n\t\tlock_page(last_page);\n\t\tf2fs_wait_on_page_writeback(last_page, NODE, true);\n\t\tset_page_dirty(last_page);\n\t\tunlock_page(last_page);\n\t\tgoto retry;\n\t}\nout:\n\tif (last_idx != ULONG_MAX)\n\t\tf2fs_submit_merged_bio_cond(sbi, NULL, ino, last_idx,\n\t\t\t\t\t\t\tNODE, WRITE);\n\treturn ret ? -EIO: 0;\n}\n\nint sync_node_pages(struct f2fs_sb_info *sbi, struct writeback_control *wbc)\n{\n\tpgoff_t index, end;\n\tstruct pagevec pvec;\n\tint step = 0;\n\tint nwritten = 0;\n\tint ret = 0;\n\n\tpagevec_init(&pvec, 0);\n\nnext_step:\n\tindex = 0;\n\tend = ULONG_MAX;\n\n\twhile (index <= end) {\n\t\tint i, nr_pages;\n\t\tnr_pages = pagevec_lookup_tag(&pvec, NODE_MAPPING(sbi), &index,\n\t\t\t\tPAGECACHE_TAG_DIRTY,\n\t\t\t\tmin(end - index, (pgoff_t)PAGEVEC_SIZE-1) + 1);\n\t\tif (nr_pages == 0)\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\t\t\tbool submitted = false;\n\n\t\t\tif (unlikely(f2fs_cp_error(sbi))) {\n\t\t\t\tpagevec_release(&pvec);\n\t\t\t\tret = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * flushing sequence with step:\n\t\t\t * 0. indirect nodes\n\t\t\t * 1. dentry dnodes\n\t\t\t * 2. file dnodes\n\t\t\t */\n\t\t\tif (step == 0 && IS_DNODE(page))\n\t\t\t\tcontinue;\n\t\t\tif (step == 1 && (!IS_DNODE(page) ||\n\t\t\t\t\t\tis_cold_node(page)))\n\t\t\t\tcontinue;\n\t\t\tif (step == 2 && (!IS_DNODE(page) ||\n\t\t\t\t\t\t!is_cold_node(page)))\n\t\t\t\tcontinue;\nlock_node:\n\t\t\tif (!trylock_page(page))\n\t\t\t\tcontinue;\n\n\t\t\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\ncontinue_unlock:\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!PageDirty(page)) {\n\t\t\t\t/* someone wrote it for us */\n\t\t\t\tgoto continue_unlock;\n\t\t\t}\n\n\t\t\t/* flush inline_data */\n\t\t\tif (is_inline_node(page)) {\n\t\t\t\tclear_inline_node(page);\n\t\t\t\tunlock_page(page);\n\t\t\t\tflush_inline_data(sbi, ino_of_node(page));\n\t\t\t\tgoto lock_node;\n\t\t\t}\n\n\t\t\tf2fs_wait_on_page_writeback(page, NODE, true);\n\n\t\t\tBUG_ON(PageWriteback(page));\n\t\t\tif (!clear_page_dirty_for_io(page))\n\t\t\t\tgoto continue_unlock;\n\n\t\t\tset_fsync_mark(page, 0);\n\t\t\tset_dentry_mark(page, 0);\n\n\t\t\tret = __write_node_page(page, false, &submitted, wbc);\n\t\t\tif (ret)\n\t\t\t\tunlock_page(page);\n\t\t\telse if (submitted)\n\t\t\t\tnwritten++;\n\n\t\t\tif (--wbc->nr_to_write == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\n\t\tif (wbc->nr_to_write == 0) {\n\t\t\tstep = 2;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (step < 2) {\n\t\tstep++;\n\t\tgoto next_step;\n\t}\nout:\n\tif (nwritten)\n\t\tf2fs_submit_merged_bio(sbi, NODE, WRITE);\n\treturn ret;\n}\n\nint wait_on_node_pages_writeback(struct f2fs_sb_info *sbi, nid_t ino)\n{\n\tpgoff_t index = 0, end = ULONG_MAX;\n\tstruct pagevec pvec;\n\tint ret2, ret = 0;\n\n\tpagevec_init(&pvec, 0);\n\n\twhile (index <= end) {\n\t\tint i, nr_pages;\n\t\tnr_pages = pagevec_lookup_tag(&pvec, NODE_MAPPING(sbi), &index,\n\t\t\t\tPAGECACHE_TAG_WRITEBACK,\n\t\t\t\tmin(end - index, (pgoff_t)PAGEVEC_SIZE-1) + 1);\n\t\tif (nr_pages == 0)\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\t/* until radix tree lookup accepts end_index */\n\t\t\tif (unlikely(page->index > end))\n\t\t\t\tcontinue;\n\n\t\t\tif (ino && ino_of_node(page) == ino) {\n\t\t\t\tf2fs_wait_on_page_writeback(page, NODE, true);\n\t\t\t\tif (TestClearPageError(page))\n\t\t\t\t\tret = -EIO;\n\t\t\t}\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t}\n\n\tret2 = filemap_check_errors(NODE_MAPPING(sbi));\n\tif (!ret)\n\t\tret = ret2;\n\treturn ret;\n}\n\nstatic int f2fs_write_node_pages(struct address_space *mapping,\n\t\t\t    struct writeback_control *wbc)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_M_SB(mapping);\n\tstruct blk_plug plug;\n\tlong diff;\n\n\t/* balancing f2fs's metadata in background */\n\tf2fs_balance_fs_bg(sbi);\n\n\t/* collect a number of dirty node pages and write together */\n\tif (get_pages(sbi, F2FS_DIRTY_NODES) < nr_pages_to_skip(sbi, NODE))\n\t\tgoto skip_write;\n\n\ttrace_f2fs_writepages(mapping->host, wbc, NODE);\n\n\tdiff = nr_pages_to_write(sbi, NODE, wbc);\n\twbc->sync_mode = WB_SYNC_NONE;\n\tblk_start_plug(&plug);\n\tsync_node_pages(sbi, wbc);\n\tblk_finish_plug(&plug);\n\twbc->nr_to_write = max((long)0, wbc->nr_to_write - diff);\n\treturn 0;\n\nskip_write:\n\twbc->pages_skipped += get_pages(sbi, F2FS_DIRTY_NODES);\n\ttrace_f2fs_writepages(mapping->host, wbc, NODE);\n\treturn 0;\n}\n\nstatic int f2fs_set_node_page_dirty(struct page *page)\n{\n\ttrace_f2fs_set_page_dirty(page, NODE);\n\n\tif (!PageUptodate(page))\n\t\tSetPageUptodate(page);\n\tif (!PageDirty(page)) {\n\t\tf2fs_set_page_dirty_nobuffers(page);\n\t\tinc_page_count(F2FS_P_SB(page), F2FS_DIRTY_NODES);\n\t\tSetPagePrivate(page);\n\t\tf2fs_trace_pid(page);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/*\n * Structure of the f2fs node operations\n */\nconst struct address_space_operations f2fs_node_aops = {\n\t.writepage\t= f2fs_write_node_page,\n\t.writepages\t= f2fs_write_node_pages,\n\t.set_page_dirty\t= f2fs_set_node_page_dirty,\n\t.invalidatepage\t= f2fs_invalidate_page,\n\t.releasepage\t= f2fs_release_page,\n#ifdef CONFIG_MIGRATION\n\t.migratepage    = f2fs_migrate_page,\n#endif\n};\n\nstatic struct free_nid *__lookup_free_nid_list(struct f2fs_nm_info *nm_i,\n\t\t\t\t\t\tnid_t n)\n{\n\treturn radix_tree_lookup(&nm_i->free_nid_root, n);\n}\n\nstatic int __insert_nid_to_list(struct f2fs_sb_info *sbi,\n\t\t\tstruct free_nid *i, enum nid_list list, bool new)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\n\tif (new) {\n\t\tint err = radix_tree_insert(&nm_i->free_nid_root, i->nid, i);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tf2fs_bug_on(sbi, list == FREE_NID_LIST ? i->state != NID_NEW :\n\t\t\t\t\t\ti->state != NID_ALLOC);\n\tnm_i->nid_cnt[list]++;\n\tlist_add_tail(&i->list, &nm_i->nid_list[list]);\n\treturn 0;\n}\n\nstatic void __remove_nid_from_list(struct f2fs_sb_info *sbi,\n\t\t\tstruct free_nid *i, enum nid_list list, bool reuse)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\n\tf2fs_bug_on(sbi, list == FREE_NID_LIST ? i->state != NID_NEW :\n\t\t\t\t\t\ti->state != NID_ALLOC);\n\tnm_i->nid_cnt[list]--;\n\tlist_del(&i->list);\n\tif (!reuse)\n\t\tradix_tree_delete(&nm_i->free_nid_root, i->nid);\n}\n\n/* return if the nid is recognized as free */\nstatic bool add_free_nid(struct f2fs_sb_info *sbi, nid_t nid, bool build)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i;\n\tstruct nat_entry *ne;\n\tint err;\n\n\t/* 0 nid should not be used */\n\tif (unlikely(nid == 0))\n\t\treturn false;\n\n\tif (build) {\n\t\t/* do not add allocated nids */\n\t\tne = __lookup_nat_cache(nm_i, nid);\n\t\tif (ne && (!get_nat_flag(ne, IS_CHECKPOINTED) ||\n\t\t\t\tnat_get_blkaddr(ne) != NULL_ADDR))\n\t\t\treturn false;\n\t}\n\n\ti = f2fs_kmem_cache_alloc(free_nid_slab, GFP_NOFS);\n\ti->nid = nid;\n\ti->state = NID_NEW;\n\n\tif (radix_tree_preload(GFP_NOFS)) {\n\t\tkmem_cache_free(free_nid_slab, i);\n\t\treturn true;\n\t}\n\n\tspin_lock(&nm_i->nid_list_lock);\n\terr = __insert_nid_to_list(sbi, i, FREE_NID_LIST, true);\n\tspin_unlock(&nm_i->nid_list_lock);\n\tradix_tree_preload_end();\n\tif (err) {\n\t\tkmem_cache_free(free_nid_slab, i);\n\t\treturn true;\n\t}\n\treturn true;\n}\n\nstatic void remove_free_nid(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i;\n\tbool need_free = false;\n\n\tspin_lock(&nm_i->nid_list_lock);\n\ti = __lookup_free_nid_list(nm_i, nid);\n\tif (i && i->state == NID_NEW) {\n\t\t__remove_nid_from_list(sbi, i, FREE_NID_LIST, false);\n\t\tneed_free = true;\n\t}\n\tspin_unlock(&nm_i->nid_list_lock);\n\n\tif (need_free)\n\t\tkmem_cache_free(free_nid_slab, i);\n}\n\nstatic void update_free_nid_bitmap(struct f2fs_sb_info *sbi, nid_t nid,\n\t\t\t\t\t\t\tbool set, bool build)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tunsigned int nat_ofs = NAT_BLOCK_OFFSET(nid);\n\tunsigned int nid_ofs = nid - START_NID(nid);\n\n\tif (!test_bit_le(nat_ofs, nm_i->nat_block_bitmap))\n\t\treturn;\n\n\tif (set)\n\t\t__set_bit_le(nid_ofs, nm_i->free_nid_bitmap[nat_ofs]);\n\telse\n\t\t__clear_bit_le(nid_ofs, nm_i->free_nid_bitmap[nat_ofs]);\n\n\tif (set)\n\t\tnm_i->free_nid_count[nat_ofs]++;\n\telse if (!build)\n\t\tnm_i->free_nid_count[nat_ofs]--;\n}\n\nstatic void scan_nat_page(struct f2fs_sb_info *sbi,\n\t\t\tstruct page *nat_page, nid_t start_nid)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct f2fs_nat_block *nat_blk = page_address(nat_page);\n\tblock_t blk_addr;\n\tunsigned int nat_ofs = NAT_BLOCK_OFFSET(start_nid);\n\tint i;\n\n\tif (test_bit_le(nat_ofs, nm_i->nat_block_bitmap))\n\t\treturn;\n\n\t__set_bit_le(nat_ofs, nm_i->nat_block_bitmap);\n\n\ti = start_nid % NAT_ENTRY_PER_BLOCK;\n\n\tfor (; i < NAT_ENTRY_PER_BLOCK; i++, start_nid++) {\n\t\tbool freed = false;\n\n\t\tif (unlikely(start_nid >= nm_i->max_nid))\n\t\t\tbreak;\n\n\t\tblk_addr = le32_to_cpu(nat_blk->entries[i].block_addr);\n\t\tf2fs_bug_on(sbi, blk_addr == NEW_ADDR);\n\t\tif (blk_addr == NULL_ADDR)\n\t\t\tfreed = add_free_nid(sbi, start_nid, true);\n\t\tspin_lock(&NM_I(sbi)->nid_list_lock);\n\t\tupdate_free_nid_bitmap(sbi, start_nid, freed, true);\n\t\tspin_unlock(&NM_I(sbi)->nid_list_lock);\n\t}\n}\n\nstatic void scan_free_nid_bits(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tstruct f2fs_journal *journal = curseg->journal;\n\tunsigned int i, idx;\n\n\tdown_read(&nm_i->nat_tree_lock);\n\n\tfor (i = 0; i < nm_i->nat_blocks; i++) {\n\t\tif (!test_bit_le(i, nm_i->nat_block_bitmap))\n\t\t\tcontinue;\n\t\tif (!nm_i->free_nid_count[i])\n\t\t\tcontinue;\n\t\tfor (idx = 0; idx < NAT_ENTRY_PER_BLOCK; idx++) {\n\t\t\tnid_t nid;\n\n\t\t\tif (!test_bit_le(idx, nm_i->free_nid_bitmap[i]))\n\t\t\t\tcontinue;\n\n\t\t\tnid = i * NAT_ENTRY_PER_BLOCK + idx;\n\t\t\tadd_free_nid(sbi, nid, true);\n\n\t\t\tif (nm_i->nid_cnt[FREE_NID_LIST] >= MAX_FREE_NIDS)\n\t\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\tdown_read(&curseg->journal_rwsem);\n\tfor (i = 0; i < nats_in_cursum(journal); i++) {\n\t\tblock_t addr;\n\t\tnid_t nid;\n\n\t\taddr = le32_to_cpu(nat_in_journal(journal, i).block_addr);\n\t\tnid = le32_to_cpu(nid_in_journal(journal, i));\n\t\tif (addr == NULL_ADDR)\n\t\t\tadd_free_nid(sbi, nid, true);\n\t\telse\n\t\t\tremove_free_nid(sbi, nid);\n\t}\n\tup_read(&curseg->journal_rwsem);\n\tup_read(&nm_i->nat_tree_lock);\n}\n\nstatic void __build_free_nids(struct f2fs_sb_info *sbi, bool sync, bool mount)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tstruct f2fs_journal *journal = curseg->journal;\n\tint i = 0;\n\tnid_t nid = nm_i->next_scan_nid;\n\n\t/* Enough entries */\n\tif (nm_i->nid_cnt[FREE_NID_LIST] >= NAT_ENTRY_PER_BLOCK)\n\t\treturn;\n\n\tif (!sync && !available_free_memory(sbi, FREE_NIDS))\n\t\treturn;\n\n\tif (!mount) {\n\t\t/* try to find free nids in free_nid_bitmap */\n\t\tscan_free_nid_bits(sbi);\n\n\t\tif (nm_i->nid_cnt[FREE_NID_LIST])\n\t\t\treturn;\n\t}\n\n\t/* readahead nat pages to be scanned */\n\tra_meta_pages(sbi, NAT_BLOCK_OFFSET(nid), FREE_NID_PAGES,\n\t\t\t\t\t\t\tMETA_NAT, true);\n\n\tdown_read(&nm_i->nat_tree_lock);\n\n\twhile (1) {\n\t\tstruct page *page = get_current_nat_page(sbi, nid);\n\n\t\tscan_nat_page(sbi, page, nid);\n\t\tf2fs_put_page(page, 1);\n\n\t\tnid += (NAT_ENTRY_PER_BLOCK - (nid % NAT_ENTRY_PER_BLOCK));\n\t\tif (unlikely(nid >= nm_i->max_nid))\n\t\t\tnid = 0;\n\n\t\tif (++i >= FREE_NID_PAGES)\n\t\t\tbreak;\n\t}\n\n\t/* go to the next free nat pages to find free nids abundantly */\n\tnm_i->next_scan_nid = nid;\n\n\t/* find free nids from current sum_pages */\n\tdown_read(&curseg->journal_rwsem);\n\tfor (i = 0; i < nats_in_cursum(journal); i++) {\n\t\tblock_t addr;\n\n\t\taddr = le32_to_cpu(nat_in_journal(journal, i).block_addr);\n\t\tnid = le32_to_cpu(nid_in_journal(journal, i));\n\t\tif (addr == NULL_ADDR)\n\t\t\tadd_free_nid(sbi, nid, true);\n\t\telse\n\t\t\tremove_free_nid(sbi, nid);\n\t}\n\tup_read(&curseg->journal_rwsem);\n\tup_read(&nm_i->nat_tree_lock);\n\n\tra_meta_pages(sbi, NAT_BLOCK_OFFSET(nm_i->next_scan_nid),\n\t\t\t\t\tnm_i->ra_nid_pages, META_NAT, false);\n}\n\nvoid build_free_nids(struct f2fs_sb_info *sbi, bool sync, bool mount)\n{\n\tmutex_lock(&NM_I(sbi)->build_lock);\n\t__build_free_nids(sbi, sync, mount);\n\tmutex_unlock(&NM_I(sbi)->build_lock);\n}\n\n/*\n * If this function returns success, caller can obtain a new nid\n * from second parameter of this function.\n * The returned nid could be used ino as well as nid when inode is created.\n */\nbool alloc_nid(struct f2fs_sb_info *sbi, nid_t *nid)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i = NULL;\nretry:\n#ifdef CONFIG_F2FS_FAULT_INJECTION\n\tif (time_to_inject(sbi, FAULT_ALLOC_NID)) {\n\t\tf2fs_show_injection_info(FAULT_ALLOC_NID);\n\t\treturn false;\n\t}\n#endif\n\tspin_lock(&nm_i->nid_list_lock);\n\n\tif (unlikely(nm_i->available_nids == 0)) {\n\t\tspin_unlock(&nm_i->nid_list_lock);\n\t\treturn false;\n\t}\n\n\t/* We should not use stale free nids created by build_free_nids */\n\tif (nm_i->nid_cnt[FREE_NID_LIST] && !on_build_free_nids(nm_i)) {\n\t\tf2fs_bug_on(sbi, list_empty(&nm_i->nid_list[FREE_NID_LIST]));\n\t\ti = list_first_entry(&nm_i->nid_list[FREE_NID_LIST],\n\t\t\t\t\tstruct free_nid, list);\n\t\t*nid = i->nid;\n\n\t\t__remove_nid_from_list(sbi, i, FREE_NID_LIST, true);\n\t\ti->state = NID_ALLOC;\n\t\t__insert_nid_to_list(sbi, i, ALLOC_NID_LIST, false);\n\t\tnm_i->available_nids--;\n\n\t\tupdate_free_nid_bitmap(sbi, *nid, false, false);\n\n\t\tspin_unlock(&nm_i->nid_list_lock);\n\t\treturn true;\n\t}\n\tspin_unlock(&nm_i->nid_list_lock);\n\n\t/* Let's scan nat pages and its caches to get free nids */\n\tbuild_free_nids(sbi, true, false);\n\tgoto retry;\n}\n\n/*\n * alloc_nid() should be called prior to this function.\n */\nvoid alloc_nid_done(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i;\n\n\tspin_lock(&nm_i->nid_list_lock);\n\ti = __lookup_free_nid_list(nm_i, nid);\n\tf2fs_bug_on(sbi, !i);\n\t__remove_nid_from_list(sbi, i, ALLOC_NID_LIST, false);\n\tspin_unlock(&nm_i->nid_list_lock);\n\n\tkmem_cache_free(free_nid_slab, i);\n}\n\n/*\n * alloc_nid() should be called prior to this function.\n */\nvoid alloc_nid_failed(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i;\n\tbool need_free = false;\n\n\tif (!nid)\n\t\treturn;\n\n\tspin_lock(&nm_i->nid_list_lock);\n\ti = __lookup_free_nid_list(nm_i, nid);\n\tf2fs_bug_on(sbi, !i);\n\n\tif (!available_free_memory(sbi, FREE_NIDS)) {\n\t\t__remove_nid_from_list(sbi, i, ALLOC_NID_LIST, false);\n\t\tneed_free = true;\n\t} else {\n\t\t__remove_nid_from_list(sbi, i, ALLOC_NID_LIST, true);\n\t\ti->state = NID_NEW;\n\t\t__insert_nid_to_list(sbi, i, FREE_NID_LIST, false);\n\t}\n\n\tnm_i->available_nids++;\n\n\tupdate_free_nid_bitmap(sbi, nid, true, false);\n\n\tspin_unlock(&nm_i->nid_list_lock);\n\n\tif (need_free)\n\t\tkmem_cache_free(free_nid_slab, i);\n}\n\nint try_to_free_nids(struct f2fs_sb_info *sbi, int nr_shrink)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i, *next;\n\tint nr = nr_shrink;\n\n\tif (nm_i->nid_cnt[FREE_NID_LIST] <= MAX_FREE_NIDS)\n\t\treturn 0;\n\n\tif (!mutex_trylock(&nm_i->build_lock))\n\t\treturn 0;\n\n\tspin_lock(&nm_i->nid_list_lock);\n\tlist_for_each_entry_safe(i, next, &nm_i->nid_list[FREE_NID_LIST],\n\t\t\t\t\t\t\t\t\tlist) {\n\t\tif (nr_shrink <= 0 ||\n\t\t\t\tnm_i->nid_cnt[FREE_NID_LIST] <= MAX_FREE_NIDS)\n\t\t\tbreak;\n\n\t\t__remove_nid_from_list(sbi, i, FREE_NID_LIST, false);\n\t\tkmem_cache_free(free_nid_slab, i);\n\t\tnr_shrink--;\n\t}\n\tspin_unlock(&nm_i->nid_list_lock);\n\tmutex_unlock(&nm_i->build_lock);\n\n\treturn nr - nr_shrink;\n}\n\nvoid recover_inline_xattr(struct inode *inode, struct page *page)\n{\n\tvoid *src_addr, *dst_addr;\n\tsize_t inline_size;\n\tstruct page *ipage;\n\tstruct f2fs_inode *ri;\n\n\tipage = get_node_page(F2FS_I_SB(inode), inode->i_ino);\n\tf2fs_bug_on(F2FS_I_SB(inode), IS_ERR(ipage));\n\n\tri = F2FS_INODE(page);\n\tif (!(ri->i_inline & F2FS_INLINE_XATTR)) {\n\t\tclear_inode_flag(inode, FI_INLINE_XATTR);\n\t\tgoto update_inode;\n\t}\n\n\tdst_addr = inline_xattr_addr(ipage);\n\tsrc_addr = inline_xattr_addr(page);\n\tinline_size = inline_xattr_size(inode);\n\n\tf2fs_wait_on_page_writeback(ipage, NODE, true);\n\tmemcpy(dst_addr, src_addr, inline_size);\nupdate_inode:\n\tupdate_inode(inode, ipage);\n\tf2fs_put_page(ipage, 1);\n}\n\nint recover_xattr_data(struct inode *inode, struct page *page, block_t blkaddr)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tnid_t prev_xnid = F2FS_I(inode)->i_xattr_nid;\n\tnid_t new_xnid = nid_of_node(page);\n\tstruct node_info ni;\n\tstruct page *xpage;\n\n\tif (!prev_xnid)\n\t\tgoto recover_xnid;\n\n\t/* 1: invalidate the previous xattr nid */\n\tget_node_info(sbi, prev_xnid, &ni);\n\tf2fs_bug_on(sbi, ni.blk_addr == NULL_ADDR);\n\tinvalidate_blocks(sbi, ni.blk_addr);\n\tdec_valid_node_count(sbi, inode);\n\tset_node_addr(sbi, &ni, NULL_ADDR, false);\n\nrecover_xnid:\n\t/* 2: update xattr nid in inode */\n\tremove_free_nid(sbi, new_xnid);\n\tf2fs_i_xnid_write(inode, new_xnid);\n\tif (unlikely(!inc_valid_node_count(sbi, inode)))\n\t\tf2fs_bug_on(sbi, 1);\n\tupdate_inode_page(inode);\n\n\t/* 3: update and set xattr node page dirty */\n\txpage = grab_cache_page(NODE_MAPPING(sbi), new_xnid);\n\tif (!xpage)\n\t\treturn -ENOMEM;\n\n\tmemcpy(F2FS_NODE(xpage), F2FS_NODE(page), PAGE_SIZE);\n\n\tget_node_info(sbi, new_xnid, &ni);\n\tni.ino = inode->i_ino;\n\tset_node_addr(sbi, &ni, NEW_ADDR, false);\n\tset_page_dirty(xpage);\n\tf2fs_put_page(xpage, 1);\n\n\treturn 0;\n}\n\nint recover_inode_page(struct f2fs_sb_info *sbi, struct page *page)\n{\n\tstruct f2fs_inode *src, *dst;\n\tnid_t ino = ino_of_node(page);\n\tstruct node_info old_ni, new_ni;\n\tstruct page *ipage;\n\n\tget_node_info(sbi, ino, &old_ni);\n\n\tif (unlikely(old_ni.blk_addr != NULL_ADDR))\n\t\treturn -EINVAL;\nretry:\n\tipage = f2fs_grab_cache_page(NODE_MAPPING(sbi), ino, false);\n\tif (!ipage) {\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t\tgoto retry;\n\t}\n\n\t/* Should not use this inode from free nid list */\n\tremove_free_nid(sbi, ino);\n\n\tif (!PageUptodate(ipage))\n\t\tSetPageUptodate(ipage);\n\tfill_node_footer(ipage, ino, ino, 0, true);\n\n\tsrc = F2FS_INODE(page);\n\tdst = F2FS_INODE(ipage);\n\n\tmemcpy(dst, src, (unsigned long)&src->i_ext - (unsigned long)src);\n\tdst->i_size = 0;\n\tdst->i_blocks = cpu_to_le64(1);\n\tdst->i_links = cpu_to_le32(1);\n\tdst->i_xattr_nid = 0;\n\tdst->i_inline = src->i_inline & F2FS_INLINE_XATTR;\n\n\tnew_ni = old_ni;\n\tnew_ni.ino = ino;\n\n\tif (unlikely(!inc_valid_node_count(sbi, NULL)))\n\t\tWARN_ON(1);\n\tset_node_addr(sbi, &new_ni, NEW_ADDR, false);\n\tinc_valid_inode_count(sbi);\n\tset_page_dirty(ipage);\n\tf2fs_put_page(ipage, 1);\n\treturn 0;\n}\n\nint restore_node_summary(struct f2fs_sb_info *sbi,\n\t\t\tunsigned int segno, struct f2fs_summary_block *sum)\n{\n\tstruct f2fs_node *rn;\n\tstruct f2fs_summary *sum_entry;\n\tblock_t addr;\n\tint i, idx, last_offset, nrpages;\n\n\t/* scan the node segment */\n\tlast_offset = sbi->blocks_per_seg;\n\taddr = START_BLOCK(sbi, segno);\n\tsum_entry = &sum->entries[0];\n\n\tfor (i = 0; i < last_offset; i += nrpages, addr += nrpages) {\n\t\tnrpages = min(last_offset - i, BIO_MAX_PAGES);\n\n\t\t/* readahead node pages */\n\t\tra_meta_pages(sbi, addr, nrpages, META_POR, true);\n\n\t\tfor (idx = addr; idx < addr + nrpages; idx++) {\n\t\t\tstruct page *page = get_tmp_page(sbi, idx);\n\n\t\t\trn = F2FS_NODE(page);\n\t\t\tsum_entry->nid = rn->footer.nid;\n\t\t\tsum_entry->version = 0;\n\t\t\tsum_entry->ofs_in_node = 0;\n\t\t\tsum_entry++;\n\t\t\tf2fs_put_page(page, 1);\n\t\t}\n\n\t\tinvalidate_mapping_pages(META_MAPPING(sbi), addr,\n\t\t\t\t\t\t\taddr + nrpages);\n\t}\n\treturn 0;\n}\n\nstatic void remove_nats_in_journal(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tstruct f2fs_journal *journal = curseg->journal;\n\tint i;\n\n\tdown_write(&curseg->journal_rwsem);\n\tfor (i = 0; i < nats_in_cursum(journal); i++) {\n\t\tstruct nat_entry *ne;\n\t\tstruct f2fs_nat_entry raw_ne;\n\t\tnid_t nid = le32_to_cpu(nid_in_journal(journal, i));\n\n\t\traw_ne = nat_in_journal(journal, i);\n\n\t\tne = __lookup_nat_cache(nm_i, nid);\n\t\tif (!ne) {\n\t\t\tne = grab_nat_entry(nm_i, nid, true);\n\t\t\tnode_info_from_raw_nat(&ne->ni, &raw_ne);\n\t\t}\n\n\t\t/*\n\t\t * if a free nat in journal has not been used after last\n\t\t * checkpoint, we should remove it from available nids,\n\t\t * since later we will add it again.\n\t\t */\n\t\tif (!get_nat_flag(ne, IS_DIRTY) &&\n\t\t\t\tle32_to_cpu(raw_ne.block_addr) == NULL_ADDR) {\n\t\t\tspin_lock(&nm_i->nid_list_lock);\n\t\t\tnm_i->available_nids--;\n\t\t\tspin_unlock(&nm_i->nid_list_lock);\n\t\t}\n\n\t\t__set_nat_cache_dirty(nm_i, ne);\n\t}\n\tupdate_nats_in_cursum(journal, -i);\n\tup_write(&curseg->journal_rwsem);\n}\n\nstatic void __adjust_nat_entry_set(struct nat_entry_set *nes,\n\t\t\t\t\t\tstruct list_head *head, int max)\n{\n\tstruct nat_entry_set *cur;\n\n\tif (nes->entry_cnt >= max)\n\t\tgoto add_out;\n\n\tlist_for_each_entry(cur, head, set_list) {\n\t\tif (cur->entry_cnt >= nes->entry_cnt) {\n\t\t\tlist_add(&nes->set_list, cur->set_list.prev);\n\t\t\treturn;\n\t\t}\n\t}\nadd_out:\n\tlist_add_tail(&nes->set_list, head);\n}\n\nstatic void __update_nat_bits(struct f2fs_sb_info *sbi, nid_t start_nid,\n\t\t\t\t\t\tstruct page *page)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tunsigned int nat_index = start_nid / NAT_ENTRY_PER_BLOCK;\n\tstruct f2fs_nat_block *nat_blk = page_address(page);\n\tint valid = 0;\n\tint i;\n\n\tif (!enabled_nat_bits(sbi, NULL))\n\t\treturn;\n\n\tfor (i = 0; i < NAT_ENTRY_PER_BLOCK; i++) {\n\t\tif (start_nid == 0 && i == 0)\n\t\t\tvalid++;\n\t\tif (nat_blk->entries[i].block_addr)\n\t\t\tvalid++;\n\t}\n\tif (valid == 0) {\n\t\t__set_bit_le(nat_index, nm_i->empty_nat_bits);\n\t\t__clear_bit_le(nat_index, nm_i->full_nat_bits);\n\t\treturn;\n\t}\n\n\t__clear_bit_le(nat_index, nm_i->empty_nat_bits);\n\tif (valid == NAT_ENTRY_PER_BLOCK)\n\t\t__set_bit_le(nat_index, nm_i->full_nat_bits);\n\telse\n\t\t__clear_bit_le(nat_index, nm_i->full_nat_bits);\n}\n\nstatic void __flush_nat_entry_set(struct f2fs_sb_info *sbi,\n\t\tstruct nat_entry_set *set, struct cp_control *cpc)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tstruct f2fs_journal *journal = curseg->journal;\n\tnid_t start_nid = set->set * NAT_ENTRY_PER_BLOCK;\n\tbool to_journal = true;\n\tstruct f2fs_nat_block *nat_blk;\n\tstruct nat_entry *ne, *cur;\n\tstruct page *page = NULL;\n\n\t/*\n\t * there are two steps to flush nat entries:\n\t * #1, flush nat entries to journal in current hot data summary block.\n\t * #2, flush nat entries to nat page.\n\t */\n\tif (enabled_nat_bits(sbi, cpc) ||\n\t\t!__has_cursum_space(journal, set->entry_cnt, NAT_JOURNAL))\n\t\tto_journal = false;\n\n\tif (to_journal) {\n\t\tdown_write(&curseg->journal_rwsem);\n\t} else {\n\t\tpage = get_next_nat_page(sbi, start_nid);\n\t\tnat_blk = page_address(page);\n\t\tf2fs_bug_on(sbi, !nat_blk);\n\t}\n\n\t/* flush dirty nats in nat entry set */\n\tlist_for_each_entry_safe(ne, cur, &set->entry_list, list) {\n\t\tstruct f2fs_nat_entry *raw_ne;\n\t\tnid_t nid = nat_get_nid(ne);\n\t\tint offset;\n\n\t\tif (nat_get_blkaddr(ne) == NEW_ADDR)\n\t\t\tcontinue;\n\n\t\tif (to_journal) {\n\t\t\toffset = lookup_journal_in_cursum(journal,\n\t\t\t\t\t\t\tNAT_JOURNAL, nid, 1);\n\t\t\tf2fs_bug_on(sbi, offset < 0);\n\t\t\traw_ne = &nat_in_journal(journal, offset);\n\t\t\tnid_in_journal(journal, offset) = cpu_to_le32(nid);\n\t\t} else {\n\t\t\traw_ne = &nat_blk->entries[nid - start_nid];\n\t\t}\n\t\traw_nat_from_node_info(raw_ne, &ne->ni);\n\t\tnat_reset_flag(ne);\n\t\t__clear_nat_cache_dirty(NM_I(sbi), set, ne);\n\t\tif (nat_get_blkaddr(ne) == NULL_ADDR) {\n\t\t\tadd_free_nid(sbi, nid, false);\n\t\t\tspin_lock(&NM_I(sbi)->nid_list_lock);\n\t\t\tNM_I(sbi)->available_nids++;\n\t\t\tupdate_free_nid_bitmap(sbi, nid, true, false);\n\t\t\tspin_unlock(&NM_I(sbi)->nid_list_lock);\n\t\t} else {\n\t\t\tspin_lock(&NM_I(sbi)->nid_list_lock);\n\t\t\tupdate_free_nid_bitmap(sbi, nid, false, false);\n\t\t\tspin_unlock(&NM_I(sbi)->nid_list_lock);\n\t\t}\n\t}\n\n\tif (to_journal) {\n\t\tup_write(&curseg->journal_rwsem);\n\t} else {\n\t\t__update_nat_bits(sbi, start_nid, page);\n\t\tf2fs_put_page(page, 1);\n\t}\n\n\tf2fs_bug_on(sbi, set->entry_cnt);\n\n\tradix_tree_delete(&NM_I(sbi)->nat_set_root, set->set);\n\tkmem_cache_free(nat_entry_set_slab, set);\n}\n\n/*\n * This function is called during the checkpointing process.\n */\nvoid flush_nat_entries(struct f2fs_sb_info *sbi, struct cp_control *cpc)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tstruct f2fs_journal *journal = curseg->journal;\n\tstruct nat_entry_set *setvec[SETVEC_SIZE];\n\tstruct nat_entry_set *set, *tmp;\n\tunsigned int found;\n\tnid_t set_idx = 0;\n\tLIST_HEAD(sets);\n\n\tif (!nm_i->dirty_nat_cnt)\n\t\treturn;\n\n\tdown_write(&nm_i->nat_tree_lock);\n\n\t/*\n\t * if there are no enough space in journal to store dirty nat\n\t * entries, remove all entries from journal and merge them\n\t * into nat entry set.\n\t */\n\tif (enabled_nat_bits(sbi, cpc) ||\n\t\t!__has_cursum_space(journal, nm_i->dirty_nat_cnt, NAT_JOURNAL))\n\t\tremove_nats_in_journal(sbi);\n\n\twhile ((found = __gang_lookup_nat_set(nm_i,\n\t\t\t\t\tset_idx, SETVEC_SIZE, setvec))) {\n\t\tunsigned idx;\n\t\tset_idx = setvec[found - 1]->set + 1;\n\t\tfor (idx = 0; idx < found; idx++)\n\t\t\t__adjust_nat_entry_set(setvec[idx], &sets,\n\t\t\t\t\t\tMAX_NAT_JENTRIES(journal));\n\t}\n\n\t/* flush dirty nats in nat entry set */\n\tlist_for_each_entry_safe(set, tmp, &sets, set_list)\n\t\t__flush_nat_entry_set(sbi, set, cpc);\n\n\tup_write(&nm_i->nat_tree_lock);\n\n\tf2fs_bug_on(sbi, nm_i->dirty_nat_cnt);\n}\n\nstatic int __get_nat_bitmaps(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tunsigned int nat_bits_bytes = nm_i->nat_blocks / BITS_PER_BYTE;\n\tunsigned int i;\n\t__u64 cp_ver = cur_cp_version(ckpt);\n\tblock_t nat_bits_addr;\n\n\tif (!enabled_nat_bits(sbi, NULL))\n\t\treturn 0;\n\n\tnm_i->nat_bits_blocks = F2FS_BYTES_TO_BLK((nat_bits_bytes << 1) + 8 +\n\t\t\t\t\t\tF2FS_BLKSIZE - 1);\n\tnm_i->nat_bits = kzalloc(nm_i->nat_bits_blocks << F2FS_BLKSIZE_BITS,\n\t\t\t\t\t\tGFP_KERNEL);\n\tif (!nm_i->nat_bits)\n\t\treturn -ENOMEM;\n\n\tnat_bits_addr = __start_cp_addr(sbi) + sbi->blocks_per_seg -\n\t\t\t\t\t\tnm_i->nat_bits_blocks;\n\tfor (i = 0; i < nm_i->nat_bits_blocks; i++) {\n\t\tstruct page *page = get_meta_page(sbi, nat_bits_addr++);\n\n\t\tmemcpy(nm_i->nat_bits + (i << F2FS_BLKSIZE_BITS),\n\t\t\t\t\tpage_address(page), F2FS_BLKSIZE);\n\t\tf2fs_put_page(page, 1);\n\t}\n\n\tcp_ver |= (cur_cp_crc(ckpt) << 32);\n\tif (cpu_to_le64(cp_ver) != *(__le64 *)nm_i->nat_bits) {\n\t\tdisable_nat_bits(sbi, true);\n\t\treturn 0;\n\t}\n\n\tnm_i->full_nat_bits = nm_i->nat_bits + 8;\n\tnm_i->empty_nat_bits = nm_i->full_nat_bits + nat_bits_bytes;\n\n\tf2fs_msg(sbi->sb, KERN_NOTICE, \"Found nat_bits in checkpoint\");\n\treturn 0;\n}\n\ninline void load_free_nid_bitmap(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tunsigned int i = 0;\n\tnid_t nid, last_nid;\n\n\tif (!enabled_nat_bits(sbi, NULL))\n\t\treturn;\n\n\tfor (i = 0; i < nm_i->nat_blocks; i++) {\n\t\ti = find_next_bit_le(nm_i->empty_nat_bits, nm_i->nat_blocks, i);\n\t\tif (i >= nm_i->nat_blocks)\n\t\t\tbreak;\n\n\t\t__set_bit_le(i, nm_i->nat_block_bitmap);\n\n\t\tnid = i * NAT_ENTRY_PER_BLOCK;\n\t\tlast_nid = (i + 1) * NAT_ENTRY_PER_BLOCK;\n\n\t\tspin_lock(&NM_I(sbi)->nid_list_lock);\n\t\tfor (; nid < last_nid; nid++)\n\t\t\tupdate_free_nid_bitmap(sbi, nid, true, true);\n\t\tspin_unlock(&NM_I(sbi)->nid_list_lock);\n\t}\n\n\tfor (i = 0; i < nm_i->nat_blocks; i++) {\n\t\ti = find_next_bit_le(nm_i->full_nat_bits, nm_i->nat_blocks, i);\n\t\tif (i >= nm_i->nat_blocks)\n\t\t\tbreak;\n\n\t\t__set_bit_le(i, nm_i->nat_block_bitmap);\n\t}\n}\n\nstatic int init_node_manager(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_super_block *sb_raw = F2FS_RAW_SUPER(sbi);\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tunsigned char *version_bitmap;\n\tunsigned int nat_segs;\n\tint err;\n\n\tnm_i->nat_blkaddr = le32_to_cpu(sb_raw->nat_blkaddr);\n\n\t/* segment_count_nat includes pair segment so divide to 2. */\n\tnat_segs = le32_to_cpu(sb_raw->segment_count_nat) >> 1;\n\tnm_i->nat_blocks = nat_segs << le32_to_cpu(sb_raw->log_blocks_per_seg);\n\tnm_i->max_nid = NAT_ENTRY_PER_BLOCK * nm_i->nat_blocks;\n\n\t/* not used nids: 0, node, meta, (and root counted as valid node) */\n\tnm_i->available_nids = nm_i->max_nid - sbi->total_valid_node_count -\n\t\t\t\t\t\t\tF2FS_RESERVED_NODE_NUM;\n\tnm_i->nid_cnt[FREE_NID_LIST] = 0;\n\tnm_i->nid_cnt[ALLOC_NID_LIST] = 0;\n\tnm_i->nat_cnt = 0;\n\tnm_i->ram_thresh = DEF_RAM_THRESHOLD;\n\tnm_i->ra_nid_pages = DEF_RA_NID_PAGES;\n\tnm_i->dirty_nats_ratio = DEF_DIRTY_NAT_RATIO_THRESHOLD;\n\n\tINIT_RADIX_TREE(&nm_i->free_nid_root, GFP_ATOMIC);\n\tINIT_LIST_HEAD(&nm_i->nid_list[FREE_NID_LIST]);\n\tINIT_LIST_HEAD(&nm_i->nid_list[ALLOC_NID_LIST]);\n\tINIT_RADIX_TREE(&nm_i->nat_root, GFP_NOIO);\n\tINIT_RADIX_TREE(&nm_i->nat_set_root, GFP_NOIO);\n\tINIT_LIST_HEAD(&nm_i->nat_entries);\n\n\tmutex_init(&nm_i->build_lock);\n\tspin_lock_init(&nm_i->nid_list_lock);\n\tinit_rwsem(&nm_i->nat_tree_lock);\n\n\tnm_i->next_scan_nid = le32_to_cpu(sbi->ckpt->next_free_nid);\n\tnm_i->bitmap_size = __bitmap_size(sbi, NAT_BITMAP);\n\tversion_bitmap = __bitmap_ptr(sbi, NAT_BITMAP);\n\tif (!version_bitmap)\n\t\treturn -EFAULT;\n\n\tnm_i->nat_bitmap = kmemdup(version_bitmap, nm_i->bitmap_size,\n\t\t\t\t\tGFP_KERNEL);\n\tif (!nm_i->nat_bitmap)\n\t\treturn -ENOMEM;\n\n\terr = __get_nat_bitmaps(sbi);\n\tif (err)\n\t\treturn err;\n\n#ifdef CONFIG_F2FS_CHECK_FS\n\tnm_i->nat_bitmap_mir = kmemdup(version_bitmap, nm_i->bitmap_size,\n\t\t\t\t\tGFP_KERNEL);\n\tif (!nm_i->nat_bitmap_mir)\n\t\treturn -ENOMEM;\n#endif\n\n\treturn 0;\n}\n\nstatic int init_free_nid_cache(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\n\tnm_i->free_nid_bitmap = f2fs_kvzalloc(nm_i->nat_blocks *\n\t\t\t\t\tNAT_ENTRY_BITMAP_SIZE, GFP_KERNEL);\n\tif (!nm_i->free_nid_bitmap)\n\t\treturn -ENOMEM;\n\n\tnm_i->nat_block_bitmap = f2fs_kvzalloc(nm_i->nat_blocks / 8,\n\t\t\t\t\t\t\t\tGFP_KERNEL);\n\tif (!nm_i->nat_block_bitmap)\n\t\treturn -ENOMEM;\n\n\tnm_i->free_nid_count = f2fs_kvzalloc(nm_i->nat_blocks *\n\t\t\t\t\tsizeof(unsigned short), GFP_KERNEL);\n\tif (!nm_i->free_nid_count)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nint build_node_manager(struct f2fs_sb_info *sbi)\n{\n\tint err;\n\n\tsbi->nm_info = kzalloc(sizeof(struct f2fs_nm_info), GFP_KERNEL);\n\tif (!sbi->nm_info)\n\t\treturn -ENOMEM;\n\n\terr = init_node_manager(sbi);\n\tif (err)\n\t\treturn err;\n\n\terr = init_free_nid_cache(sbi);\n\tif (err)\n\t\treturn err;\n\n\t/* load free nid status from nat_bits table */\n\tload_free_nid_bitmap(sbi);\n\n\tbuild_free_nids(sbi, true, true);\n\treturn 0;\n}\n\nvoid destroy_node_manager(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i, *next_i;\n\tstruct nat_entry *natvec[NATVEC_SIZE];\n\tstruct nat_entry_set *setvec[SETVEC_SIZE];\n\tnid_t nid = 0;\n\tunsigned int found;\n\n\tif (!nm_i)\n\t\treturn;\n\n\t/* destroy free nid list */\n\tspin_lock(&nm_i->nid_list_lock);\n\tlist_for_each_entry_safe(i, next_i, &nm_i->nid_list[FREE_NID_LIST],\n\t\t\t\t\t\t\t\t\tlist) {\n\t\t__remove_nid_from_list(sbi, i, FREE_NID_LIST, false);\n\t\tspin_unlock(&nm_i->nid_list_lock);\n\t\tkmem_cache_free(free_nid_slab, i);\n\t\tspin_lock(&nm_i->nid_list_lock);\n\t}\n\tf2fs_bug_on(sbi, nm_i->nid_cnt[FREE_NID_LIST]);\n\tf2fs_bug_on(sbi, nm_i->nid_cnt[ALLOC_NID_LIST]);\n\tf2fs_bug_on(sbi, !list_empty(&nm_i->nid_list[ALLOC_NID_LIST]));\n\tspin_unlock(&nm_i->nid_list_lock);\n\n\t/* destroy nat cache */\n\tdown_write(&nm_i->nat_tree_lock);\n\twhile ((found = __gang_lookup_nat_cache(nm_i,\n\t\t\t\t\tnid, NATVEC_SIZE, natvec))) {\n\t\tunsigned idx;\n\n\t\tnid = nat_get_nid(natvec[found - 1]) + 1;\n\t\tfor (idx = 0; idx < found; idx++)\n\t\t\t__del_from_nat_cache(nm_i, natvec[idx]);\n\t}\n\tf2fs_bug_on(sbi, nm_i->nat_cnt);\n\n\t/* destroy nat set cache */\n\tnid = 0;\n\twhile ((found = __gang_lookup_nat_set(nm_i,\n\t\t\t\t\tnid, SETVEC_SIZE, setvec))) {\n\t\tunsigned idx;\n\n\t\tnid = setvec[found - 1]->set + 1;\n\t\tfor (idx = 0; idx < found; idx++) {\n\t\t\t/* entry_cnt is not zero, when cp_error was occurred */\n\t\t\tf2fs_bug_on(sbi, !list_empty(&setvec[idx]->entry_list));\n\t\t\tradix_tree_delete(&nm_i->nat_set_root, setvec[idx]->set);\n\t\t\tkmem_cache_free(nat_entry_set_slab, setvec[idx]);\n\t\t}\n\t}\n\tup_write(&nm_i->nat_tree_lock);\n\n\tkvfree(nm_i->nat_block_bitmap);\n\tkvfree(nm_i->free_nid_bitmap);\n\tkvfree(nm_i->free_nid_count);\n\n\tkfree(nm_i->nat_bitmap);\n\tkfree(nm_i->nat_bits);\n#ifdef CONFIG_F2FS_CHECK_FS\n\tkfree(nm_i->nat_bitmap_mir);\n#endif\n\tsbi->nm_info = NULL;\n\tkfree(nm_i);\n}\n\nint __init create_node_manager_caches(void)\n{\n\tnat_entry_slab = f2fs_kmem_cache_create(\"nat_entry\",\n\t\t\tsizeof(struct nat_entry));\n\tif (!nat_entry_slab)\n\t\tgoto fail;\n\n\tfree_nid_slab = f2fs_kmem_cache_create(\"free_nid\",\n\t\t\tsizeof(struct free_nid));\n\tif (!free_nid_slab)\n\t\tgoto destroy_nat_entry;\n\n\tnat_entry_set_slab = f2fs_kmem_cache_create(\"nat_entry_set\",\n\t\t\tsizeof(struct nat_entry_set));\n\tif (!nat_entry_set_slab)\n\t\tgoto destroy_free_nid;\n\treturn 0;\n\ndestroy_free_nid:\n\tkmem_cache_destroy(free_nid_slab);\ndestroy_nat_entry:\n\tkmem_cache_destroy(nat_entry_slab);\nfail:\n\treturn -ENOMEM;\n}\n\nvoid destroy_node_manager_caches(void)\n{\n\tkmem_cache_destroy(nat_entry_set_slab);\n\tkmem_cache_destroy(free_nid_slab);\n\tkmem_cache_destroy(nat_entry_slab);\n}\n"], "fixing_code": ["/*\n * fs/f2fs/node.c\n *\n * Copyright (c) 2012 Samsung Electronics Co., Ltd.\n *             http://www.samsung.com/\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation.\n */\n#include <linux/fs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n\n#include \"f2fs.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"trace.h\"\n#include <trace/events/f2fs.h>\n\n#define on_build_free_nids(nmi) mutex_is_locked(&nm_i->build_lock)\n\nstatic struct kmem_cache *nat_entry_slab;\nstatic struct kmem_cache *free_nid_slab;\nstatic struct kmem_cache *nat_entry_set_slab;\n\nbool available_free_memory(struct f2fs_sb_info *sbi, int type)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct sysinfo val;\n\tunsigned long avail_ram;\n\tunsigned long mem_size = 0;\n\tbool res = false;\n\n\tsi_meminfo(&val);\n\n\t/* only uses low memory */\n\tavail_ram = val.totalram - val.totalhigh;\n\n\t/*\n\t * give 25%, 25%, 50%, 50%, 50% memory for each components respectively\n\t */\n\tif (type == FREE_NIDS) {\n\t\tmem_size = (nm_i->nid_cnt[FREE_NID_LIST] *\n\t\t\t\tsizeof(struct free_nid)) >> PAGE_SHIFT;\n\t\tres = mem_size < ((avail_ram * nm_i->ram_thresh / 100) >> 2);\n\t} else if (type == NAT_ENTRIES) {\n\t\tmem_size = (nm_i->nat_cnt * sizeof(struct nat_entry)) >>\n\t\t\t\t\t\t\tPAGE_SHIFT;\n\t\tres = mem_size < ((avail_ram * nm_i->ram_thresh / 100) >> 2);\n\t\tif (excess_cached_nats(sbi))\n\t\t\tres = false;\n\t} else if (type == DIRTY_DENTS) {\n\t\tif (sbi->sb->s_bdi->wb.dirty_exceeded)\n\t\t\treturn false;\n\t\tmem_size = get_pages(sbi, F2FS_DIRTY_DENTS);\n\t\tres = mem_size < ((avail_ram * nm_i->ram_thresh / 100) >> 1);\n\t} else if (type == INO_ENTRIES) {\n\t\tint i;\n\n\t\tfor (i = 0; i <= UPDATE_INO; i++)\n\t\t\tmem_size += sbi->im[i].ino_num *\n\t\t\t\t\t\tsizeof(struct ino_entry);\n\t\tmem_size >>= PAGE_SHIFT;\n\t\tres = mem_size < ((avail_ram * nm_i->ram_thresh / 100) >> 1);\n\t} else if (type == EXTENT_CACHE) {\n\t\tmem_size = (atomic_read(&sbi->total_ext_tree) *\n\t\t\t\tsizeof(struct extent_tree) +\n\t\t\t\tatomic_read(&sbi->total_ext_node) *\n\t\t\t\tsizeof(struct extent_node)) >> PAGE_SHIFT;\n\t\tres = mem_size < ((avail_ram * nm_i->ram_thresh / 100) >> 1);\n\t} else {\n\t\tif (!sbi->sb->s_bdi->wb.dirty_exceeded)\n\t\t\treturn true;\n\t}\n\treturn res;\n}\n\nstatic void clear_node_page_dirty(struct page *page)\n{\n\tstruct address_space *mapping = page->mapping;\n\tunsigned int long flags;\n\n\tif (PageDirty(page)) {\n\t\tspin_lock_irqsave(&mapping->tree_lock, flags);\n\t\tradix_tree_tag_clear(&mapping->page_tree,\n\t\t\t\tpage_index(page),\n\t\t\t\tPAGECACHE_TAG_DIRTY);\n\t\tspin_unlock_irqrestore(&mapping->tree_lock, flags);\n\n\t\tclear_page_dirty_for_io(page);\n\t\tdec_page_count(F2FS_M_SB(mapping), F2FS_DIRTY_NODES);\n\t}\n\tClearPageUptodate(page);\n}\n\nstatic struct page *get_current_nat_page(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tpgoff_t index = current_nat_addr(sbi, nid);\n\treturn get_meta_page(sbi, index);\n}\n\nstatic struct page *get_next_nat_page(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tstruct page *src_page;\n\tstruct page *dst_page;\n\tpgoff_t src_off;\n\tpgoff_t dst_off;\n\tvoid *src_addr;\n\tvoid *dst_addr;\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\n\tsrc_off = current_nat_addr(sbi, nid);\n\tdst_off = next_nat_addr(sbi, src_off);\n\n\t/* get current nat block page with lock */\n\tsrc_page = get_meta_page(sbi, src_off);\n\tdst_page = grab_meta_page(sbi, dst_off);\n\tf2fs_bug_on(sbi, PageDirty(src_page));\n\n\tsrc_addr = page_address(src_page);\n\tdst_addr = page_address(dst_page);\n\tmemcpy(dst_addr, src_addr, PAGE_SIZE);\n\tset_page_dirty(dst_page);\n\tf2fs_put_page(src_page, 1);\n\n\tset_to_next_nat(nm_i, nid);\n\n\treturn dst_page;\n}\n\nstatic struct nat_entry *__lookup_nat_cache(struct f2fs_nm_info *nm_i, nid_t n)\n{\n\treturn radix_tree_lookup(&nm_i->nat_root, n);\n}\n\nstatic unsigned int __gang_lookup_nat_cache(struct f2fs_nm_info *nm_i,\n\t\tnid_t start, unsigned int nr, struct nat_entry **ep)\n{\n\treturn radix_tree_gang_lookup(&nm_i->nat_root, (void **)ep, start, nr);\n}\n\nstatic void __del_from_nat_cache(struct f2fs_nm_info *nm_i, struct nat_entry *e)\n{\n\tlist_del(&e->list);\n\tradix_tree_delete(&nm_i->nat_root, nat_get_nid(e));\n\tnm_i->nat_cnt--;\n\tkmem_cache_free(nat_entry_slab, e);\n}\n\nstatic void __set_nat_cache_dirty(struct f2fs_nm_info *nm_i,\n\t\t\t\t\t\tstruct nat_entry *ne)\n{\n\tnid_t set = NAT_BLOCK_OFFSET(ne->ni.nid);\n\tstruct nat_entry_set *head;\n\n\tif (get_nat_flag(ne, IS_DIRTY))\n\t\treturn;\n\n\thead = radix_tree_lookup(&nm_i->nat_set_root, set);\n\tif (!head) {\n\t\thead = f2fs_kmem_cache_alloc(nat_entry_set_slab, GFP_NOFS);\n\n\t\tINIT_LIST_HEAD(&head->entry_list);\n\t\tINIT_LIST_HEAD(&head->set_list);\n\t\thead->set = set;\n\t\thead->entry_cnt = 0;\n\t\tf2fs_radix_tree_insert(&nm_i->nat_set_root, set, head);\n\t}\n\tlist_move_tail(&ne->list, &head->entry_list);\n\tnm_i->dirty_nat_cnt++;\n\thead->entry_cnt++;\n\tset_nat_flag(ne, IS_DIRTY, true);\n}\n\nstatic void __clear_nat_cache_dirty(struct f2fs_nm_info *nm_i,\n\t\tstruct nat_entry_set *set, struct nat_entry *ne)\n{\n\tlist_move_tail(&ne->list, &nm_i->nat_entries);\n\tset_nat_flag(ne, IS_DIRTY, false);\n\tset->entry_cnt--;\n\tnm_i->dirty_nat_cnt--;\n}\n\nstatic unsigned int __gang_lookup_nat_set(struct f2fs_nm_info *nm_i,\n\t\tnid_t start, unsigned int nr, struct nat_entry_set **ep)\n{\n\treturn radix_tree_gang_lookup(&nm_i->nat_set_root, (void **)ep,\n\t\t\t\t\t\t\tstart, nr);\n}\n\nint need_dentry_mark(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct nat_entry *e;\n\tbool need = false;\n\n\tdown_read(&nm_i->nat_tree_lock);\n\te = __lookup_nat_cache(nm_i, nid);\n\tif (e) {\n\t\tif (!get_nat_flag(e, IS_CHECKPOINTED) &&\n\t\t\t\t!get_nat_flag(e, HAS_FSYNCED_INODE))\n\t\t\tneed = true;\n\t}\n\tup_read(&nm_i->nat_tree_lock);\n\treturn need;\n}\n\nbool is_checkpointed_node(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct nat_entry *e;\n\tbool is_cp = true;\n\n\tdown_read(&nm_i->nat_tree_lock);\n\te = __lookup_nat_cache(nm_i, nid);\n\tif (e && !get_nat_flag(e, IS_CHECKPOINTED))\n\t\tis_cp = false;\n\tup_read(&nm_i->nat_tree_lock);\n\treturn is_cp;\n}\n\nbool need_inode_block_update(struct f2fs_sb_info *sbi, nid_t ino)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct nat_entry *e;\n\tbool need_update = true;\n\n\tdown_read(&nm_i->nat_tree_lock);\n\te = __lookup_nat_cache(nm_i, ino);\n\tif (e && get_nat_flag(e, HAS_LAST_FSYNC) &&\n\t\t\t(get_nat_flag(e, IS_CHECKPOINTED) ||\n\t\t\t get_nat_flag(e, HAS_FSYNCED_INODE)))\n\t\tneed_update = false;\n\tup_read(&nm_i->nat_tree_lock);\n\treturn need_update;\n}\n\nstatic struct nat_entry *grab_nat_entry(struct f2fs_nm_info *nm_i, nid_t nid,\n\t\t\t\t\t\t\t\tbool no_fail)\n{\n\tstruct nat_entry *new;\n\n\tif (no_fail) {\n\t\tnew = f2fs_kmem_cache_alloc(nat_entry_slab, GFP_NOFS);\n\t\tf2fs_radix_tree_insert(&nm_i->nat_root, nid, new);\n\t} else {\n\t\tnew = kmem_cache_alloc(nat_entry_slab, GFP_NOFS);\n\t\tif (!new)\n\t\t\treturn NULL;\n\t\tif (radix_tree_insert(&nm_i->nat_root, nid, new)) {\n\t\t\tkmem_cache_free(nat_entry_slab, new);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tmemset(new, 0, sizeof(struct nat_entry));\n\tnat_set_nid(new, nid);\n\tnat_reset_flag(new);\n\tlist_add_tail(&new->list, &nm_i->nat_entries);\n\tnm_i->nat_cnt++;\n\treturn new;\n}\n\nstatic void cache_nat_entry(struct f2fs_sb_info *sbi, nid_t nid,\n\t\t\t\t\t\tstruct f2fs_nat_entry *ne)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct nat_entry *e;\n\n\te = __lookup_nat_cache(nm_i, nid);\n\tif (!e) {\n\t\te = grab_nat_entry(nm_i, nid, false);\n\t\tif (e)\n\t\t\tnode_info_from_raw_nat(&e->ni, ne);\n\t} else {\n\t\tf2fs_bug_on(sbi, nat_get_ino(e) != le32_to_cpu(ne->ino) ||\n\t\t\t\tnat_get_blkaddr(e) !=\n\t\t\t\t\tle32_to_cpu(ne->block_addr) ||\n\t\t\t\tnat_get_version(e) != ne->version);\n\t}\n}\n\nstatic void set_node_addr(struct f2fs_sb_info *sbi, struct node_info *ni,\n\t\t\tblock_t new_blkaddr, bool fsync_done)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct nat_entry *e;\n\n\tdown_write(&nm_i->nat_tree_lock);\n\te = __lookup_nat_cache(nm_i, ni->nid);\n\tif (!e) {\n\t\te = grab_nat_entry(nm_i, ni->nid, true);\n\t\tcopy_node_info(&e->ni, ni);\n\t\tf2fs_bug_on(sbi, ni->blk_addr == NEW_ADDR);\n\t} else if (new_blkaddr == NEW_ADDR) {\n\t\t/*\n\t\t * when nid is reallocated,\n\t\t * previous nat entry can be remained in nat cache.\n\t\t * So, reinitialize it with new information.\n\t\t */\n\t\tcopy_node_info(&e->ni, ni);\n\t\tf2fs_bug_on(sbi, ni->blk_addr != NULL_ADDR);\n\t}\n\n\t/* sanity check */\n\tf2fs_bug_on(sbi, nat_get_blkaddr(e) != ni->blk_addr);\n\tf2fs_bug_on(sbi, nat_get_blkaddr(e) == NULL_ADDR &&\n\t\t\tnew_blkaddr == NULL_ADDR);\n\tf2fs_bug_on(sbi, nat_get_blkaddr(e) == NEW_ADDR &&\n\t\t\tnew_blkaddr == NEW_ADDR);\n\tf2fs_bug_on(sbi, nat_get_blkaddr(e) != NEW_ADDR &&\n\t\t\tnat_get_blkaddr(e) != NULL_ADDR &&\n\t\t\tnew_blkaddr == NEW_ADDR);\n\n\t/* increment version no as node is removed */\n\tif (nat_get_blkaddr(e) != NEW_ADDR && new_blkaddr == NULL_ADDR) {\n\t\tunsigned char version = nat_get_version(e);\n\t\tnat_set_version(e, inc_node_version(version));\n\n\t\t/* in order to reuse the nid */\n\t\tif (nm_i->next_scan_nid > ni->nid)\n\t\t\tnm_i->next_scan_nid = ni->nid;\n\t}\n\n\t/* change address */\n\tnat_set_blkaddr(e, new_blkaddr);\n\tif (new_blkaddr == NEW_ADDR || new_blkaddr == NULL_ADDR)\n\t\tset_nat_flag(e, IS_CHECKPOINTED, false);\n\t__set_nat_cache_dirty(nm_i, e);\n\n\t/* update fsync_mark if its inode nat entry is still alive */\n\tif (ni->nid != ni->ino)\n\t\te = __lookup_nat_cache(nm_i, ni->ino);\n\tif (e) {\n\t\tif (fsync_done && ni->nid == ni->ino)\n\t\t\tset_nat_flag(e, HAS_FSYNCED_INODE, true);\n\t\tset_nat_flag(e, HAS_LAST_FSYNC, fsync_done);\n\t}\n\tup_write(&nm_i->nat_tree_lock);\n}\n\nint try_to_free_nats(struct f2fs_sb_info *sbi, int nr_shrink)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tint nr = nr_shrink;\n\n\tif (!down_write_trylock(&nm_i->nat_tree_lock))\n\t\treturn 0;\n\n\twhile (nr_shrink && !list_empty(&nm_i->nat_entries)) {\n\t\tstruct nat_entry *ne;\n\t\tne = list_first_entry(&nm_i->nat_entries,\n\t\t\t\t\tstruct nat_entry, list);\n\t\t__del_from_nat_cache(nm_i, ne);\n\t\tnr_shrink--;\n\t}\n\tup_write(&nm_i->nat_tree_lock);\n\treturn nr - nr_shrink;\n}\n\n/*\n * This function always returns success\n */\nvoid get_node_info(struct f2fs_sb_info *sbi, nid_t nid, struct node_info *ni)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tstruct f2fs_journal *journal = curseg->journal;\n\tnid_t start_nid = START_NID(nid);\n\tstruct f2fs_nat_block *nat_blk;\n\tstruct page *page = NULL;\n\tstruct f2fs_nat_entry ne;\n\tstruct nat_entry *e;\n\tint i;\n\n\tni->nid = nid;\n\n\t/* Check nat cache */\n\tdown_read(&nm_i->nat_tree_lock);\n\te = __lookup_nat_cache(nm_i, nid);\n\tif (e) {\n\t\tni->ino = nat_get_ino(e);\n\t\tni->blk_addr = nat_get_blkaddr(e);\n\t\tni->version = nat_get_version(e);\n\t\tup_read(&nm_i->nat_tree_lock);\n\t\treturn;\n\t}\n\n\tmemset(&ne, 0, sizeof(struct f2fs_nat_entry));\n\n\t/* Check current segment summary */\n\tdown_read(&curseg->journal_rwsem);\n\ti = lookup_journal_in_cursum(journal, NAT_JOURNAL, nid, 0);\n\tif (i >= 0) {\n\t\tne = nat_in_journal(journal, i);\n\t\tnode_info_from_raw_nat(ni, &ne);\n\t}\n\tup_read(&curseg->journal_rwsem);\n\tif (i >= 0)\n\t\tgoto cache;\n\n\t/* Fill node_info from nat page */\n\tpage = get_current_nat_page(sbi, start_nid);\n\tnat_blk = (struct f2fs_nat_block *)page_address(page);\n\tne = nat_blk->entries[nid - start_nid];\n\tnode_info_from_raw_nat(ni, &ne);\n\tf2fs_put_page(page, 1);\ncache:\n\tup_read(&nm_i->nat_tree_lock);\n\t/* cache nat entry */\n\tdown_write(&nm_i->nat_tree_lock);\n\tcache_nat_entry(sbi, nid, &ne);\n\tup_write(&nm_i->nat_tree_lock);\n}\n\n/*\n * readahead MAX_RA_NODE number of node pages.\n */\nstatic void ra_node_pages(struct page *parent, int start, int n)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(parent);\n\tstruct blk_plug plug;\n\tint i, end;\n\tnid_t nid;\n\n\tblk_start_plug(&plug);\n\n\t/* Then, try readahead for siblings of the desired node */\n\tend = start + n;\n\tend = min(end, NIDS_PER_BLOCK);\n\tfor (i = start; i < end; i++) {\n\t\tnid = get_nid(parent, i, false);\n\t\tra_node_page(sbi, nid);\n\t}\n\n\tblk_finish_plug(&plug);\n}\n\npgoff_t get_next_page_offset(struct dnode_of_data *dn, pgoff_t pgofs)\n{\n\tconst long direct_index = ADDRS_PER_INODE(dn->inode);\n\tconst long direct_blks = ADDRS_PER_BLOCK;\n\tconst long indirect_blks = ADDRS_PER_BLOCK * NIDS_PER_BLOCK;\n\tunsigned int skipped_unit = ADDRS_PER_BLOCK;\n\tint cur_level = dn->cur_level;\n\tint max_level = dn->max_level;\n\tpgoff_t base = 0;\n\n\tif (!dn->max_level)\n\t\treturn pgofs + 1;\n\n\twhile (max_level-- > cur_level)\n\t\tskipped_unit *= NIDS_PER_BLOCK;\n\n\tswitch (dn->max_level) {\n\tcase 3:\n\t\tbase += 2 * indirect_blks;\n\tcase 2:\n\t\tbase += 2 * direct_blks;\n\tcase 1:\n\t\tbase += direct_index;\n\t\tbreak;\n\tdefault:\n\t\tf2fs_bug_on(F2FS_I_SB(dn->inode), 1);\n\t}\n\n\treturn ((pgofs - base) / skipped_unit + 1) * skipped_unit + base;\n}\n\n/*\n * The maximum depth is four.\n * Offset[0] will have raw inode offset.\n */\nstatic int get_node_path(struct inode *inode, long block,\n\t\t\t\tint offset[4], unsigned int noffset[4])\n{\n\tconst long direct_index = ADDRS_PER_INODE(inode);\n\tconst long direct_blks = ADDRS_PER_BLOCK;\n\tconst long dptrs_per_blk = NIDS_PER_BLOCK;\n\tconst long indirect_blks = ADDRS_PER_BLOCK * NIDS_PER_BLOCK;\n\tconst long dindirect_blks = indirect_blks * NIDS_PER_BLOCK;\n\tint n = 0;\n\tint level = 0;\n\n\tnoffset[0] = 0;\n\n\tif (block < direct_index) {\n\t\toffset[n] = block;\n\t\tgoto got;\n\t}\n\tblock -= direct_index;\n\tif (block < direct_blks) {\n\t\toffset[n++] = NODE_DIR1_BLOCK;\n\t\tnoffset[n] = 1;\n\t\toffset[n] = block;\n\t\tlevel = 1;\n\t\tgoto got;\n\t}\n\tblock -= direct_blks;\n\tif (block < direct_blks) {\n\t\toffset[n++] = NODE_DIR2_BLOCK;\n\t\tnoffset[n] = 2;\n\t\toffset[n] = block;\n\t\tlevel = 1;\n\t\tgoto got;\n\t}\n\tblock -= direct_blks;\n\tif (block < indirect_blks) {\n\t\toffset[n++] = NODE_IND1_BLOCK;\n\t\tnoffset[n] = 3;\n\t\toffset[n++] = block / direct_blks;\n\t\tnoffset[n] = 4 + offset[n - 1];\n\t\toffset[n] = block % direct_blks;\n\t\tlevel = 2;\n\t\tgoto got;\n\t}\n\tblock -= indirect_blks;\n\tif (block < indirect_blks) {\n\t\toffset[n++] = NODE_IND2_BLOCK;\n\t\tnoffset[n] = 4 + dptrs_per_blk;\n\t\toffset[n++] = block / direct_blks;\n\t\tnoffset[n] = 5 + dptrs_per_blk + offset[n - 1];\n\t\toffset[n] = block % direct_blks;\n\t\tlevel = 2;\n\t\tgoto got;\n\t}\n\tblock -= indirect_blks;\n\tif (block < dindirect_blks) {\n\t\toffset[n++] = NODE_DIND_BLOCK;\n\t\tnoffset[n] = 5 + (dptrs_per_blk * 2);\n\t\toffset[n++] = block / indirect_blks;\n\t\tnoffset[n] = 6 + (dptrs_per_blk * 2) +\n\t\t\t      offset[n - 1] * (dptrs_per_blk + 1);\n\t\toffset[n++] = (block / direct_blks) % dptrs_per_blk;\n\t\tnoffset[n] = 7 + (dptrs_per_blk * 2) +\n\t\t\t      offset[n - 2] * (dptrs_per_blk + 1) +\n\t\t\t      offset[n - 1];\n\t\toffset[n] = block % direct_blks;\n\t\tlevel = 3;\n\t\tgoto got;\n\t} else {\n\t\tBUG();\n\t}\ngot:\n\treturn level;\n}\n\n/*\n * Caller should call f2fs_put_dnode(dn).\n * Also, it should grab and release a rwsem by calling f2fs_lock_op() and\n * f2fs_unlock_op() only if ro is not set RDONLY_NODE.\n * In the case of RDONLY_NODE, we don't need to care about mutex.\n */\nint get_dnode_of_data(struct dnode_of_data *dn, pgoff_t index, int mode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct page *npage[4];\n\tstruct page *parent = NULL;\n\tint offset[4];\n\tunsigned int noffset[4];\n\tnid_t nids[4];\n\tint level, i = 0;\n\tint err = 0;\n\n\tlevel = get_node_path(dn->inode, index, offset, noffset);\n\n\tnids[0] = dn->inode->i_ino;\n\tnpage[0] = dn->inode_page;\n\n\tif (!npage[0]) {\n\t\tnpage[0] = get_node_page(sbi, nids[0]);\n\t\tif (IS_ERR(npage[0]))\n\t\t\treturn PTR_ERR(npage[0]);\n\t}\n\n\t/* if inline_data is set, should not report any block indices */\n\tif (f2fs_has_inline_data(dn->inode) && index) {\n\t\terr = -ENOENT;\n\t\tf2fs_put_page(npage[0], 1);\n\t\tgoto release_out;\n\t}\n\n\tparent = npage[0];\n\tif (level != 0)\n\t\tnids[1] = get_nid(parent, offset[0], true);\n\tdn->inode_page = npage[0];\n\tdn->inode_page_locked = true;\n\n\t/* get indirect or direct nodes */\n\tfor (i = 1; i <= level; i++) {\n\t\tbool done = false;\n\n\t\tif (!nids[i] && mode == ALLOC_NODE) {\n\t\t\t/* alloc new node */\n\t\t\tif (!alloc_nid(sbi, &(nids[i]))) {\n\t\t\t\terr = -ENOSPC;\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\n\t\t\tdn->nid = nids[i];\n\t\t\tnpage[i] = new_node_page(dn, noffset[i], NULL);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\talloc_nid_failed(sbi, nids[i]);\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\n\t\t\tset_nid(parent, offset[i - 1], nids[i], i == 1);\n\t\t\talloc_nid_done(sbi, nids[i]);\n\t\t\tdone = true;\n\t\t} else if (mode == LOOKUP_NODE_RA && i == level && level > 1) {\n\t\t\tnpage[i] = get_node_page_ra(parent, offset[i - 1]);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\t\t\tdone = true;\n\t\t}\n\t\tif (i == 1) {\n\t\t\tdn->inode_page_locked = false;\n\t\t\tunlock_page(parent);\n\t\t} else {\n\t\t\tf2fs_put_page(parent, 1);\n\t\t}\n\n\t\tif (!done) {\n\t\t\tnpage[i] = get_node_page(sbi, nids[i]);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tf2fs_put_page(npage[0], 0);\n\t\t\t\tgoto release_out;\n\t\t\t}\n\t\t}\n\t\tif (i < level) {\n\t\t\tparent = npage[i];\n\t\t\tnids[i + 1] = get_nid(parent, offset[i], false);\n\t\t}\n\t}\n\tdn->nid = nids[level];\n\tdn->ofs_in_node = offset[level];\n\tdn->node_page = npage[level];\n\tdn->data_blkaddr = datablock_addr(dn->node_page, dn->ofs_in_node);\n\treturn 0;\n\nrelease_pages:\n\tf2fs_put_page(parent, 1);\n\tif (i > 1)\n\t\tf2fs_put_page(npage[0], 0);\nrelease_out:\n\tdn->inode_page = NULL;\n\tdn->node_page = NULL;\n\tif (err == -ENOENT) {\n\t\tdn->cur_level = i;\n\t\tdn->max_level = level;\n\t\tdn->ofs_in_node = offset[level];\n\t}\n\treturn err;\n}\n\nstatic void truncate_node(struct dnode_of_data *dn)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct node_info ni;\n\n\tget_node_info(sbi, dn->nid, &ni);\n\tif (dn->inode->i_blocks == 0) {\n\t\tf2fs_bug_on(sbi, ni.blk_addr != NULL_ADDR);\n\t\tgoto invalidate;\n\t}\n\tf2fs_bug_on(sbi, ni.blk_addr == NULL_ADDR);\n\n\t/* Deallocate node address */\n\tinvalidate_blocks(sbi, ni.blk_addr);\n\tdec_valid_node_count(sbi, dn->inode);\n\tset_node_addr(sbi, &ni, NULL_ADDR, false);\n\n\tif (dn->nid == dn->inode->i_ino) {\n\t\tremove_orphan_inode(sbi, dn->nid);\n\t\tdec_valid_inode_count(sbi);\n\t\tf2fs_inode_synced(dn->inode);\n\t}\ninvalidate:\n\tclear_node_page_dirty(dn->node_page);\n\tset_sbi_flag(sbi, SBI_IS_DIRTY);\n\n\tf2fs_put_page(dn->node_page, 1);\n\n\tinvalidate_mapping_pages(NODE_MAPPING(sbi),\n\t\t\tdn->node_page->index, dn->node_page->index);\n\n\tdn->node_page = NULL;\n\ttrace_f2fs_truncate_node(dn->inode, dn->nid, ni.blk_addr);\n}\n\nstatic int truncate_dnode(struct dnode_of_data *dn)\n{\n\tstruct page *page;\n\n\tif (dn->nid == 0)\n\t\treturn 1;\n\n\t/* get direct node */\n\tpage = get_node_page(F2FS_I_SB(dn->inode), dn->nid);\n\tif (IS_ERR(page) && PTR_ERR(page) == -ENOENT)\n\t\treturn 1;\n\telse if (IS_ERR(page))\n\t\treturn PTR_ERR(page);\n\n\t/* Make dnode_of_data for parameter */\n\tdn->node_page = page;\n\tdn->ofs_in_node = 0;\n\ttruncate_data_blocks(dn);\n\ttruncate_node(dn);\n\treturn 1;\n}\n\nstatic int truncate_nodes(struct dnode_of_data *dn, unsigned int nofs,\n\t\t\t\t\t\tint ofs, int depth)\n{\n\tstruct dnode_of_data rdn = *dn;\n\tstruct page *page;\n\tstruct f2fs_node *rn;\n\tnid_t child_nid;\n\tunsigned int child_nofs;\n\tint freed = 0;\n\tint i, ret;\n\n\tif (dn->nid == 0)\n\t\treturn NIDS_PER_BLOCK + 1;\n\n\ttrace_f2fs_truncate_nodes_enter(dn->inode, dn->nid, dn->data_blkaddr);\n\n\tpage = get_node_page(F2FS_I_SB(dn->inode), dn->nid);\n\tif (IS_ERR(page)) {\n\t\ttrace_f2fs_truncate_nodes_exit(dn->inode, PTR_ERR(page));\n\t\treturn PTR_ERR(page);\n\t}\n\n\tra_node_pages(page, ofs, NIDS_PER_BLOCK);\n\n\trn = F2FS_NODE(page);\n\tif (depth < 3) {\n\t\tfor (i = ofs; i < NIDS_PER_BLOCK; i++, freed++) {\n\t\t\tchild_nid = le32_to_cpu(rn->in.nid[i]);\n\t\t\tif (child_nid == 0)\n\t\t\t\tcontinue;\n\t\t\trdn.nid = child_nid;\n\t\t\tret = truncate_dnode(&rdn);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out_err;\n\t\t\tif (set_nid(page, i, 0, false))\n\t\t\t\tdn->node_changed = true;\n\t\t}\n\t} else {\n\t\tchild_nofs = nofs + ofs * (NIDS_PER_BLOCK + 1) + 1;\n\t\tfor (i = ofs; i < NIDS_PER_BLOCK; i++) {\n\t\t\tchild_nid = le32_to_cpu(rn->in.nid[i]);\n\t\t\tif (child_nid == 0) {\n\t\t\t\tchild_nofs += NIDS_PER_BLOCK + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trdn.nid = child_nid;\n\t\t\tret = truncate_nodes(&rdn, child_nofs, 0, depth - 1);\n\t\t\tif (ret == (NIDS_PER_BLOCK + 1)) {\n\t\t\t\tif (set_nid(page, i, 0, false))\n\t\t\t\t\tdn->node_changed = true;\n\t\t\t\tchild_nofs += ret;\n\t\t\t} else if (ret < 0 && ret != -ENOENT) {\n\t\t\t\tgoto out_err;\n\t\t\t}\n\t\t}\n\t\tfreed = child_nofs;\n\t}\n\n\tif (!ofs) {\n\t\t/* remove current indirect node */\n\t\tdn->node_page = page;\n\t\ttruncate_node(dn);\n\t\tfreed++;\n\t} else {\n\t\tf2fs_put_page(page, 1);\n\t}\n\ttrace_f2fs_truncate_nodes_exit(dn->inode, freed);\n\treturn freed;\n\nout_err:\n\tf2fs_put_page(page, 1);\n\ttrace_f2fs_truncate_nodes_exit(dn->inode, ret);\n\treturn ret;\n}\n\nstatic int truncate_partial_nodes(struct dnode_of_data *dn,\n\t\t\tstruct f2fs_inode *ri, int *offset, int depth)\n{\n\tstruct page *pages[2];\n\tnid_t nid[3];\n\tnid_t child_nid;\n\tint err = 0;\n\tint i;\n\tint idx = depth - 2;\n\n\tnid[0] = le32_to_cpu(ri->i_nid[offset[0] - NODE_DIR1_BLOCK]);\n\tif (!nid[0])\n\t\treturn 0;\n\n\t/* get indirect nodes in the path */\n\tfor (i = 0; i < idx + 1; i++) {\n\t\t/* reference count'll be increased */\n\t\tpages[i] = get_node_page(F2FS_I_SB(dn->inode), nid[i]);\n\t\tif (IS_ERR(pages[i])) {\n\t\t\terr = PTR_ERR(pages[i]);\n\t\t\tidx = i - 1;\n\t\t\tgoto fail;\n\t\t}\n\t\tnid[i + 1] = get_nid(pages[i], offset[i + 1], false);\n\t}\n\n\tra_node_pages(pages[idx], offset[idx + 1], NIDS_PER_BLOCK);\n\n\t/* free direct nodes linked to a partial indirect node */\n\tfor (i = offset[idx + 1]; i < NIDS_PER_BLOCK; i++) {\n\t\tchild_nid = get_nid(pages[idx], i, false);\n\t\tif (!child_nid)\n\t\t\tcontinue;\n\t\tdn->nid = child_nid;\n\t\terr = truncate_dnode(dn);\n\t\tif (err < 0)\n\t\t\tgoto fail;\n\t\tif (set_nid(pages[idx], i, 0, false))\n\t\t\tdn->node_changed = true;\n\t}\n\n\tif (offset[idx + 1] == 0) {\n\t\tdn->node_page = pages[idx];\n\t\tdn->nid = nid[idx];\n\t\ttruncate_node(dn);\n\t} else {\n\t\tf2fs_put_page(pages[idx], 1);\n\t}\n\toffset[idx]++;\n\toffset[idx + 1] = 0;\n\tidx--;\nfail:\n\tfor (i = idx; i >= 0; i--)\n\t\tf2fs_put_page(pages[i], 1);\n\n\ttrace_f2fs_truncate_partial_nodes(dn->inode, nid, depth, err);\n\n\treturn err;\n}\n\n/*\n * All the block addresses of data and nodes should be nullified.\n */\nint truncate_inode_blocks(struct inode *inode, pgoff_t from)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tint err = 0, cont = 1;\n\tint level, offset[4], noffset[4];\n\tunsigned int nofs = 0;\n\tstruct f2fs_inode *ri;\n\tstruct dnode_of_data dn;\n\tstruct page *page;\n\n\ttrace_f2fs_truncate_inode_blocks_enter(inode, from);\n\n\tlevel = get_node_path(inode, from, offset, noffset);\n\n\tpage = get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(page)) {\n\t\ttrace_f2fs_truncate_inode_blocks_exit(inode, PTR_ERR(page));\n\t\treturn PTR_ERR(page);\n\t}\n\n\tset_new_dnode(&dn, inode, page, NULL, 0);\n\tunlock_page(page);\n\n\tri = F2FS_INODE(page);\n\tswitch (level) {\n\tcase 0:\n\tcase 1:\n\t\tnofs = noffset[1];\n\t\tbreak;\n\tcase 2:\n\t\tnofs = noffset[1];\n\t\tif (!offset[level - 1])\n\t\t\tgoto skip_partial;\n\t\terr = truncate_partial_nodes(&dn, ri, offset, level);\n\t\tif (err < 0 && err != -ENOENT)\n\t\t\tgoto fail;\n\t\tnofs += 1 + NIDS_PER_BLOCK;\n\t\tbreak;\n\tcase 3:\n\t\tnofs = 5 + 2 * NIDS_PER_BLOCK;\n\t\tif (!offset[level - 1])\n\t\t\tgoto skip_partial;\n\t\terr = truncate_partial_nodes(&dn, ri, offset, level);\n\t\tif (err < 0 && err != -ENOENT)\n\t\t\tgoto fail;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\nskip_partial:\n\twhile (cont) {\n\t\tdn.nid = le32_to_cpu(ri->i_nid[offset[0] - NODE_DIR1_BLOCK]);\n\t\tswitch (offset[0]) {\n\t\tcase NODE_DIR1_BLOCK:\n\t\tcase NODE_DIR2_BLOCK:\n\t\t\terr = truncate_dnode(&dn);\n\t\t\tbreak;\n\n\t\tcase NODE_IND1_BLOCK:\n\t\tcase NODE_IND2_BLOCK:\n\t\t\terr = truncate_nodes(&dn, nofs, offset[1], 2);\n\t\t\tbreak;\n\n\t\tcase NODE_DIND_BLOCK:\n\t\t\terr = truncate_nodes(&dn, nofs, offset[1], 3);\n\t\t\tcont = 0;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t\tif (err < 0 && err != -ENOENT)\n\t\t\tgoto fail;\n\t\tif (offset[1] == 0 &&\n\t\t\t\tri->i_nid[offset[0] - NODE_DIR1_BLOCK]) {\n\t\t\tlock_page(page);\n\t\t\tBUG_ON(page->mapping != NODE_MAPPING(sbi));\n\t\t\tf2fs_wait_on_page_writeback(page, NODE, true);\n\t\t\tri->i_nid[offset[0] - NODE_DIR1_BLOCK] = 0;\n\t\t\tset_page_dirty(page);\n\t\t\tunlock_page(page);\n\t\t}\n\t\toffset[1] = 0;\n\t\toffset[0]++;\n\t\tnofs += err;\n\t}\nfail:\n\tf2fs_put_page(page, 0);\n\ttrace_f2fs_truncate_inode_blocks_exit(inode, err);\n\treturn err > 0 ? 0 : err;\n}\n\nint truncate_xattr_node(struct inode *inode, struct page *page)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tnid_t nid = F2FS_I(inode)->i_xattr_nid;\n\tstruct dnode_of_data dn;\n\tstruct page *npage;\n\n\tif (!nid)\n\t\treturn 0;\n\n\tnpage = get_node_page(sbi, nid);\n\tif (IS_ERR(npage))\n\t\treturn PTR_ERR(npage);\n\n\tf2fs_i_xnid_write(inode, 0);\n\n\tset_new_dnode(&dn, inode, page, npage, nid);\n\n\tif (page)\n\t\tdn.inode_page_locked = true;\n\ttruncate_node(&dn);\n\treturn 0;\n}\n\n/*\n * Caller should grab and release a rwsem by calling f2fs_lock_op() and\n * f2fs_unlock_op().\n */\nint remove_inode_page(struct inode *inode)\n{\n\tstruct dnode_of_data dn;\n\tint err;\n\n\tset_new_dnode(&dn, inode, NULL, NULL, inode->i_ino);\n\terr = get_dnode_of_data(&dn, 0, LOOKUP_NODE);\n\tif (err)\n\t\treturn err;\n\n\terr = truncate_xattr_node(inode, dn.inode_page);\n\tif (err) {\n\t\tf2fs_put_dnode(&dn);\n\t\treturn err;\n\t}\n\n\t/* remove potential inline_data blocks */\n\tif (S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\t\t\tS_ISLNK(inode->i_mode))\n\t\ttruncate_data_blocks_range(&dn, 1);\n\n\t/* 0 is possible, after f2fs_new_inode() has failed */\n\tf2fs_bug_on(F2FS_I_SB(inode),\n\t\t\tinode->i_blocks != 0 && inode->i_blocks != 1);\n\n\t/* will put inode & node pages */\n\ttruncate_node(&dn);\n\treturn 0;\n}\n\nstruct page *new_inode_page(struct inode *inode)\n{\n\tstruct dnode_of_data dn;\n\n\t/* allocate inode page for new inode */\n\tset_new_dnode(&dn, inode, NULL, NULL, inode->i_ino);\n\n\t/* caller should f2fs_put_page(page, 1); */\n\treturn new_node_page(&dn, 0, NULL);\n}\n\nstruct page *new_node_page(struct dnode_of_data *dn,\n\t\t\t\tunsigned int ofs, struct page *ipage)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct node_info new_ni;\n\tstruct page *page;\n\tint err;\n\n\tif (unlikely(is_inode_flag_set(dn->inode, FI_NO_ALLOC)))\n\t\treturn ERR_PTR(-EPERM);\n\n\tpage = f2fs_grab_cache_page(NODE_MAPPING(sbi), dn->nid, false);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (unlikely(!inc_valid_node_count(sbi, dn->inode))) {\n\t\terr = -ENOSPC;\n\t\tgoto fail;\n\t}\n#ifdef CONFIG_F2FS_CHECK_FS\n\tget_node_info(sbi, dn->nid, &new_ni);\n\tf2fs_bug_on(sbi, new_ni.blk_addr != NULL_ADDR);\n#endif\n\tnew_ni.nid = dn->nid;\n\tnew_ni.ino = dn->inode->i_ino;\n\tnew_ni.blk_addr = NULL_ADDR;\n\tnew_ni.flag = 0;\n\tnew_ni.version = 0;\n\tset_node_addr(sbi, &new_ni, NEW_ADDR, false);\n\n\tf2fs_wait_on_page_writeback(page, NODE, true);\n\tfill_node_footer(page, dn->nid, dn->inode->i_ino, ofs, true);\n\tset_cold_node(dn->inode, page);\n\tif (!PageUptodate(page))\n\t\tSetPageUptodate(page);\n\tif (set_page_dirty(page))\n\t\tdn->node_changed = true;\n\n\tif (f2fs_has_xattr_block(ofs))\n\t\tf2fs_i_xnid_write(dn->inode, dn->nid);\n\n\tif (ofs == 0)\n\t\tinc_valid_inode_count(sbi);\n\treturn page;\n\nfail:\n\tclear_node_page_dirty(page);\n\tf2fs_put_page(page, 1);\n\treturn ERR_PTR(err);\n}\n\n/*\n * Caller should do after getting the following values.\n * 0: f2fs_put_page(page, 0)\n * LOCKED_PAGE or error: f2fs_put_page(page, 1)\n */\nstatic int read_node_page(struct page *page, int op_flags)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\tstruct node_info ni;\n\tstruct f2fs_io_info fio = {\n\t\t.sbi = sbi,\n\t\t.type = NODE,\n\t\t.op = REQ_OP_READ,\n\t\t.op_flags = op_flags,\n\t\t.page = page,\n\t\t.encrypted_page = NULL,\n\t};\n\n\tif (PageUptodate(page))\n\t\treturn LOCKED_PAGE;\n\n\tget_node_info(sbi, page->index, &ni);\n\n\tif (unlikely(ni.blk_addr == NULL_ADDR)) {\n\t\tClearPageUptodate(page);\n\t\treturn -ENOENT;\n\t}\n\n\tfio.new_blkaddr = fio.old_blkaddr = ni.blk_addr;\n\treturn f2fs_submit_page_bio(&fio);\n}\n\n/*\n * Readahead a node page\n */\nvoid ra_node_page(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tstruct page *apage;\n\tint err;\n\n\tif (!nid)\n\t\treturn;\n\tf2fs_bug_on(sbi, check_nid_range(sbi, nid));\n\n\trcu_read_lock();\n\tapage = radix_tree_lookup(&NODE_MAPPING(sbi)->page_tree, nid);\n\trcu_read_unlock();\n\tif (apage)\n\t\treturn;\n\n\tapage = f2fs_grab_cache_page(NODE_MAPPING(sbi), nid, false);\n\tif (!apage)\n\t\treturn;\n\n\terr = read_node_page(apage, REQ_RAHEAD);\n\tf2fs_put_page(apage, err ? 1 : 0);\n}\n\nstatic struct page *__get_node_page(struct f2fs_sb_info *sbi, pgoff_t nid,\n\t\t\t\t\tstruct page *parent, int start)\n{\n\tstruct page *page;\n\tint err;\n\n\tif (!nid)\n\t\treturn ERR_PTR(-ENOENT);\n\tf2fs_bug_on(sbi, check_nid_range(sbi, nid));\nrepeat:\n\tpage = f2fs_grab_cache_page(NODE_MAPPING(sbi), nid, false);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = read_node_page(page, 0);\n\tif (err < 0) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(err);\n\t} else if (err == LOCKED_PAGE) {\n\t\tgoto page_hit;\n\t}\n\n\tif (parent)\n\t\tra_node_pages(parent, start + 1, MAX_RA_NODE);\n\n\tlock_page(page);\n\n\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\n\n\tif (unlikely(!PageUptodate(page)))\n\t\tgoto out_err;\npage_hit:\n\tif(unlikely(nid != nid_of_node(page))) {\n\t\tf2fs_bug_on(sbi, 1);\n\t\tClearPageUptodate(page);\nout_err:\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}\n\nstruct page *get_node_page(struct f2fs_sb_info *sbi, pgoff_t nid)\n{\n\treturn __get_node_page(sbi, nid, NULL, 0);\n}\n\nstruct page *get_node_page_ra(struct page *parent, int start)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(parent);\n\tnid_t nid = get_nid(parent, start, false);\n\n\treturn __get_node_page(sbi, nid, parent, start);\n}\n\nstatic void flush_inline_data(struct f2fs_sb_info *sbi, nid_t ino)\n{\n\tstruct inode *inode;\n\tstruct page *page;\n\tint ret;\n\n\t/* should flush inline_data before evict_inode */\n\tinode = ilookup(sbi->sb, ino);\n\tif (!inode)\n\t\treturn;\n\n\tpage = pagecache_get_page(inode->i_mapping, 0, FGP_LOCK|FGP_NOWAIT, 0);\n\tif (!page)\n\t\tgoto iput_out;\n\n\tif (!PageUptodate(page))\n\t\tgoto page_out;\n\n\tif (!PageDirty(page))\n\t\tgoto page_out;\n\n\tif (!clear_page_dirty_for_io(page))\n\t\tgoto page_out;\n\n\tret = f2fs_write_inline_data(inode, page);\n\tinode_dec_dirty_pages(inode);\n\tremove_dirty_inode(inode);\n\tif (ret)\n\t\tset_page_dirty(page);\npage_out:\n\tf2fs_put_page(page, 1);\niput_out:\n\tiput(inode);\n}\n\nvoid move_node_page(struct page *node_page, int gc_type)\n{\n\tif (gc_type == FG_GC) {\n\t\tstruct f2fs_sb_info *sbi = F2FS_P_SB(node_page);\n\t\tstruct writeback_control wbc = {\n\t\t\t.sync_mode = WB_SYNC_ALL,\n\t\t\t.nr_to_write = 1,\n\t\t\t.for_reclaim = 0,\n\t\t};\n\n\t\tset_page_dirty(node_page);\n\t\tf2fs_wait_on_page_writeback(node_page, NODE, true);\n\n\t\tf2fs_bug_on(sbi, PageWriteback(node_page));\n\t\tif (!clear_page_dirty_for_io(node_page))\n\t\t\tgoto out_page;\n\n\t\tif (NODE_MAPPING(sbi)->a_ops->writepage(node_page, &wbc))\n\t\t\tunlock_page(node_page);\n\t\tgoto release_page;\n\t} else {\n\t\t/* set page dirty and write it */\n\t\tif (!PageWriteback(node_page))\n\t\t\tset_page_dirty(node_page);\n\t}\nout_page:\n\tunlock_page(node_page);\nrelease_page:\n\tf2fs_put_page(node_page, 0);\n}\n\nstatic struct page *last_fsync_dnode(struct f2fs_sb_info *sbi, nid_t ino)\n{\n\tpgoff_t index, end;\n\tstruct pagevec pvec;\n\tstruct page *last_page = NULL;\n\n\tpagevec_init(&pvec, 0);\n\tindex = 0;\n\tend = ULONG_MAX;\n\n\twhile (index <= end) {\n\t\tint i, nr_pages;\n\t\tnr_pages = pagevec_lookup_tag(&pvec, NODE_MAPPING(sbi), &index,\n\t\t\t\tPAGECACHE_TAG_DIRTY,\n\t\t\t\tmin(end - index, (pgoff_t)PAGEVEC_SIZE-1) + 1);\n\t\tif (nr_pages == 0)\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\tif (unlikely(f2fs_cp_error(sbi))) {\n\t\t\t\tf2fs_put_page(last_page, 0);\n\t\t\t\tpagevec_release(&pvec);\n\t\t\t\treturn ERR_PTR(-EIO);\n\t\t\t}\n\n\t\t\tif (!IS_DNODE(page) || !is_cold_node(page))\n\t\t\t\tcontinue;\n\t\t\tif (ino_of_node(page) != ino)\n\t\t\t\tcontinue;\n\n\t\t\tlock_page(page);\n\n\t\t\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\ncontinue_unlock:\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ino_of_node(page) != ino)\n\t\t\t\tgoto continue_unlock;\n\n\t\t\tif (!PageDirty(page)) {\n\t\t\t\t/* someone wrote it for us */\n\t\t\t\tgoto continue_unlock;\n\t\t\t}\n\n\t\t\tif (last_page)\n\t\t\t\tf2fs_put_page(last_page, 0);\n\n\t\t\tget_page(page);\n\t\t\tlast_page = page;\n\t\t\tunlock_page(page);\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t}\n\treturn last_page;\n}\n\nstatic int __write_node_page(struct page *page, bool atomic, bool *submitted,\n\t\t\t\tstruct writeback_control *wbc)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\tnid_t nid;\n\tstruct node_info ni;\n\tstruct f2fs_io_info fio = {\n\t\t.sbi = sbi,\n\t\t.type = NODE,\n\t\t.op = REQ_OP_WRITE,\n\t\t.op_flags = wbc_to_write_flags(wbc),\n\t\t.page = page,\n\t\t.encrypted_page = NULL,\n\t\t.submitted = false,\n\t};\n\n\ttrace_f2fs_writepage(page, NODE);\n\n\tif (unlikely(is_sbi_flag_set(sbi, SBI_POR_DOING)))\n\t\tgoto redirty_out;\n\tif (unlikely(f2fs_cp_error(sbi)))\n\t\tgoto redirty_out;\n\n\t/* get old block addr of this node page */\n\tnid = nid_of_node(page);\n\tf2fs_bug_on(sbi, page->index != nid);\n\n\tif (wbc->for_reclaim) {\n\t\tif (!down_read_trylock(&sbi->node_write))\n\t\t\tgoto redirty_out;\n\t} else {\n\t\tdown_read(&sbi->node_write);\n\t}\n\n\tget_node_info(sbi, nid, &ni);\n\n\t/* This page is already truncated */\n\tif (unlikely(ni.blk_addr == NULL_ADDR)) {\n\t\tClearPageUptodate(page);\n\t\tdec_page_count(sbi, F2FS_DIRTY_NODES);\n\t\tup_read(&sbi->node_write);\n\t\tunlock_page(page);\n\t\treturn 0;\n\t}\n\n\tif (atomic && !test_opt(sbi, NOBARRIER))\n\t\tfio.op_flags |= REQ_PREFLUSH | REQ_FUA;\n\n\tset_page_writeback(page);\n\tfio.old_blkaddr = ni.blk_addr;\n\twrite_node_page(nid, &fio);\n\tset_node_addr(sbi, &ni, fio.new_blkaddr, is_fsync_dnode(page));\n\tdec_page_count(sbi, F2FS_DIRTY_NODES);\n\tup_read(&sbi->node_write);\n\n\tif (wbc->for_reclaim) {\n\t\tf2fs_submit_merged_bio_cond(sbi, page->mapping->host, 0,\n\t\t\t\t\t\tpage->index, NODE, WRITE);\n\t\tsubmitted = NULL;\n\t}\n\n\tunlock_page(page);\n\n\tif (unlikely(f2fs_cp_error(sbi))) {\n\t\tf2fs_submit_merged_bio(sbi, NODE, WRITE);\n\t\tsubmitted = NULL;\n\t}\n\tif (submitted)\n\t\t*submitted = fio.submitted;\n\n\treturn 0;\n\nredirty_out:\n\tredirty_page_for_writepage(wbc, page);\n\treturn AOP_WRITEPAGE_ACTIVATE;\n}\n\nstatic int f2fs_write_node_page(struct page *page,\n\t\t\t\tstruct writeback_control *wbc)\n{\n\treturn __write_node_page(page, false, NULL, wbc);\n}\n\nint fsync_node_pages(struct f2fs_sb_info *sbi, struct inode *inode,\n\t\t\tstruct writeback_control *wbc, bool atomic)\n{\n\tpgoff_t index, end;\n\tpgoff_t last_idx = ULONG_MAX;\n\tstruct pagevec pvec;\n\tint ret = 0;\n\tstruct page *last_page = NULL;\n\tbool marked = false;\n\tnid_t ino = inode->i_ino;\n\n\tif (atomic) {\n\t\tlast_page = last_fsync_dnode(sbi, ino);\n\t\tif (IS_ERR_OR_NULL(last_page))\n\t\t\treturn PTR_ERR_OR_ZERO(last_page);\n\t}\nretry:\n\tpagevec_init(&pvec, 0);\n\tindex = 0;\n\tend = ULONG_MAX;\n\n\twhile (index <= end) {\n\t\tint i, nr_pages;\n\t\tnr_pages = pagevec_lookup_tag(&pvec, NODE_MAPPING(sbi), &index,\n\t\t\t\tPAGECACHE_TAG_DIRTY,\n\t\t\t\tmin(end - index, (pgoff_t)PAGEVEC_SIZE-1) + 1);\n\t\tif (nr_pages == 0)\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\t\t\tbool submitted = false;\n\n\t\t\tif (unlikely(f2fs_cp_error(sbi))) {\n\t\t\t\tf2fs_put_page(last_page, 0);\n\t\t\t\tpagevec_release(&pvec);\n\t\t\t\tret = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (!IS_DNODE(page) || !is_cold_node(page))\n\t\t\t\tcontinue;\n\t\t\tif (ino_of_node(page) != ino)\n\t\t\t\tcontinue;\n\n\t\t\tlock_page(page);\n\n\t\t\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\ncontinue_unlock:\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ino_of_node(page) != ino)\n\t\t\t\tgoto continue_unlock;\n\n\t\t\tif (!PageDirty(page) && page != last_page) {\n\t\t\t\t/* someone wrote it for us */\n\t\t\t\tgoto continue_unlock;\n\t\t\t}\n\n\t\t\tf2fs_wait_on_page_writeback(page, NODE, true);\n\t\t\tBUG_ON(PageWriteback(page));\n\n\t\t\tif (!atomic || page == last_page) {\n\t\t\t\tset_fsync_mark(page, 1);\n\t\t\t\tif (IS_INODE(page)) {\n\t\t\t\t\tif (is_inode_flag_set(inode,\n\t\t\t\t\t\t\t\tFI_DIRTY_INODE))\n\t\t\t\t\t\tupdate_inode(inode, page);\n\t\t\t\t\tset_dentry_mark(page,\n\t\t\t\t\t\tneed_dentry_mark(sbi, ino));\n\t\t\t\t}\n\t\t\t\t/*  may be written by other thread */\n\t\t\t\tif (!PageDirty(page))\n\t\t\t\t\tset_page_dirty(page);\n\t\t\t}\n\n\t\t\tif (!clear_page_dirty_for_io(page))\n\t\t\t\tgoto continue_unlock;\n\n\t\t\tret = __write_node_page(page, atomic &&\n\t\t\t\t\t\tpage == last_page,\n\t\t\t\t\t\t&submitted, wbc);\n\t\t\tif (ret) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tf2fs_put_page(last_page, 0);\n\t\t\t\tbreak;\n\t\t\t} else if (submitted) {\n\t\t\t\tlast_idx = page->index;\n\t\t\t}\n\n\t\t\tif (page == last_page) {\n\t\t\t\tf2fs_put_page(page, 0);\n\t\t\t\tmarked = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\n\t\tif (ret || marked)\n\t\t\tbreak;\n\t}\n\tif (!ret && atomic && !marked) {\n\t\tf2fs_msg(sbi->sb, KERN_DEBUG,\n\t\t\t\"Retry to write fsync mark: ino=%u, idx=%lx\",\n\t\t\t\t\tino, last_page->index);\n\t\tlock_page(last_page);\n\t\tf2fs_wait_on_page_writeback(last_page, NODE, true);\n\t\tset_page_dirty(last_page);\n\t\tunlock_page(last_page);\n\t\tgoto retry;\n\t}\nout:\n\tif (last_idx != ULONG_MAX)\n\t\tf2fs_submit_merged_bio_cond(sbi, NULL, ino, last_idx,\n\t\t\t\t\t\t\tNODE, WRITE);\n\treturn ret ? -EIO: 0;\n}\n\nint sync_node_pages(struct f2fs_sb_info *sbi, struct writeback_control *wbc)\n{\n\tpgoff_t index, end;\n\tstruct pagevec pvec;\n\tint step = 0;\n\tint nwritten = 0;\n\tint ret = 0;\n\n\tpagevec_init(&pvec, 0);\n\nnext_step:\n\tindex = 0;\n\tend = ULONG_MAX;\n\n\twhile (index <= end) {\n\t\tint i, nr_pages;\n\t\tnr_pages = pagevec_lookup_tag(&pvec, NODE_MAPPING(sbi), &index,\n\t\t\t\tPAGECACHE_TAG_DIRTY,\n\t\t\t\tmin(end - index, (pgoff_t)PAGEVEC_SIZE-1) + 1);\n\t\tif (nr_pages == 0)\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\t\t\tbool submitted = false;\n\n\t\t\tif (unlikely(f2fs_cp_error(sbi))) {\n\t\t\t\tpagevec_release(&pvec);\n\t\t\t\tret = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * flushing sequence with step:\n\t\t\t * 0. indirect nodes\n\t\t\t * 1. dentry dnodes\n\t\t\t * 2. file dnodes\n\t\t\t */\n\t\t\tif (step == 0 && IS_DNODE(page))\n\t\t\t\tcontinue;\n\t\t\tif (step == 1 && (!IS_DNODE(page) ||\n\t\t\t\t\t\tis_cold_node(page)))\n\t\t\t\tcontinue;\n\t\t\tif (step == 2 && (!IS_DNODE(page) ||\n\t\t\t\t\t\t!is_cold_node(page)))\n\t\t\t\tcontinue;\nlock_node:\n\t\t\tif (!trylock_page(page))\n\t\t\t\tcontinue;\n\n\t\t\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\ncontinue_unlock:\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!PageDirty(page)) {\n\t\t\t\t/* someone wrote it for us */\n\t\t\t\tgoto continue_unlock;\n\t\t\t}\n\n\t\t\t/* flush inline_data */\n\t\t\tif (is_inline_node(page)) {\n\t\t\t\tclear_inline_node(page);\n\t\t\t\tunlock_page(page);\n\t\t\t\tflush_inline_data(sbi, ino_of_node(page));\n\t\t\t\tgoto lock_node;\n\t\t\t}\n\n\t\t\tf2fs_wait_on_page_writeback(page, NODE, true);\n\n\t\t\tBUG_ON(PageWriteback(page));\n\t\t\tif (!clear_page_dirty_for_io(page))\n\t\t\t\tgoto continue_unlock;\n\n\t\t\tset_fsync_mark(page, 0);\n\t\t\tset_dentry_mark(page, 0);\n\n\t\t\tret = __write_node_page(page, false, &submitted, wbc);\n\t\t\tif (ret)\n\t\t\t\tunlock_page(page);\n\t\t\telse if (submitted)\n\t\t\t\tnwritten++;\n\n\t\t\tif (--wbc->nr_to_write == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\n\t\tif (wbc->nr_to_write == 0) {\n\t\t\tstep = 2;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (step < 2) {\n\t\tstep++;\n\t\tgoto next_step;\n\t}\nout:\n\tif (nwritten)\n\t\tf2fs_submit_merged_bio(sbi, NODE, WRITE);\n\treturn ret;\n}\n\nint wait_on_node_pages_writeback(struct f2fs_sb_info *sbi, nid_t ino)\n{\n\tpgoff_t index = 0, end = ULONG_MAX;\n\tstruct pagevec pvec;\n\tint ret2, ret = 0;\n\n\tpagevec_init(&pvec, 0);\n\n\twhile (index <= end) {\n\t\tint i, nr_pages;\n\t\tnr_pages = pagevec_lookup_tag(&pvec, NODE_MAPPING(sbi), &index,\n\t\t\t\tPAGECACHE_TAG_WRITEBACK,\n\t\t\t\tmin(end - index, (pgoff_t)PAGEVEC_SIZE-1) + 1);\n\t\tif (nr_pages == 0)\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\t/* until radix tree lookup accepts end_index */\n\t\t\tif (unlikely(page->index > end))\n\t\t\t\tcontinue;\n\n\t\t\tif (ino && ino_of_node(page) == ino) {\n\t\t\t\tf2fs_wait_on_page_writeback(page, NODE, true);\n\t\t\t\tif (TestClearPageError(page))\n\t\t\t\t\tret = -EIO;\n\t\t\t}\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t}\n\n\tret2 = filemap_check_errors(NODE_MAPPING(sbi));\n\tif (!ret)\n\t\tret = ret2;\n\treturn ret;\n}\n\nstatic int f2fs_write_node_pages(struct address_space *mapping,\n\t\t\t    struct writeback_control *wbc)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_M_SB(mapping);\n\tstruct blk_plug plug;\n\tlong diff;\n\n\t/* balancing f2fs's metadata in background */\n\tf2fs_balance_fs_bg(sbi);\n\n\t/* collect a number of dirty node pages and write together */\n\tif (get_pages(sbi, F2FS_DIRTY_NODES) < nr_pages_to_skip(sbi, NODE))\n\t\tgoto skip_write;\n\n\ttrace_f2fs_writepages(mapping->host, wbc, NODE);\n\n\tdiff = nr_pages_to_write(sbi, NODE, wbc);\n\twbc->sync_mode = WB_SYNC_NONE;\n\tblk_start_plug(&plug);\n\tsync_node_pages(sbi, wbc);\n\tblk_finish_plug(&plug);\n\twbc->nr_to_write = max((long)0, wbc->nr_to_write - diff);\n\treturn 0;\n\nskip_write:\n\twbc->pages_skipped += get_pages(sbi, F2FS_DIRTY_NODES);\n\ttrace_f2fs_writepages(mapping->host, wbc, NODE);\n\treturn 0;\n}\n\nstatic int f2fs_set_node_page_dirty(struct page *page)\n{\n\ttrace_f2fs_set_page_dirty(page, NODE);\n\n\tif (!PageUptodate(page))\n\t\tSetPageUptodate(page);\n\tif (!PageDirty(page)) {\n\t\tf2fs_set_page_dirty_nobuffers(page);\n\t\tinc_page_count(F2FS_P_SB(page), F2FS_DIRTY_NODES);\n\t\tSetPagePrivate(page);\n\t\tf2fs_trace_pid(page);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/*\n * Structure of the f2fs node operations\n */\nconst struct address_space_operations f2fs_node_aops = {\n\t.writepage\t= f2fs_write_node_page,\n\t.writepages\t= f2fs_write_node_pages,\n\t.set_page_dirty\t= f2fs_set_node_page_dirty,\n\t.invalidatepage\t= f2fs_invalidate_page,\n\t.releasepage\t= f2fs_release_page,\n#ifdef CONFIG_MIGRATION\n\t.migratepage    = f2fs_migrate_page,\n#endif\n};\n\nstatic struct free_nid *__lookup_free_nid_list(struct f2fs_nm_info *nm_i,\n\t\t\t\t\t\tnid_t n)\n{\n\treturn radix_tree_lookup(&nm_i->free_nid_root, n);\n}\n\nstatic int __insert_nid_to_list(struct f2fs_sb_info *sbi,\n\t\t\tstruct free_nid *i, enum nid_list list, bool new)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\n\tif (new) {\n\t\tint err = radix_tree_insert(&nm_i->free_nid_root, i->nid, i);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tf2fs_bug_on(sbi, list == FREE_NID_LIST ? i->state != NID_NEW :\n\t\t\t\t\t\ti->state != NID_ALLOC);\n\tnm_i->nid_cnt[list]++;\n\tlist_add_tail(&i->list, &nm_i->nid_list[list]);\n\treturn 0;\n}\n\nstatic void __remove_nid_from_list(struct f2fs_sb_info *sbi,\n\t\t\tstruct free_nid *i, enum nid_list list, bool reuse)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\n\tf2fs_bug_on(sbi, list == FREE_NID_LIST ? i->state != NID_NEW :\n\t\t\t\t\t\ti->state != NID_ALLOC);\n\tnm_i->nid_cnt[list]--;\n\tlist_del(&i->list);\n\tif (!reuse)\n\t\tradix_tree_delete(&nm_i->free_nid_root, i->nid);\n}\n\n/* return if the nid is recognized as free */\nstatic bool add_free_nid(struct f2fs_sb_info *sbi, nid_t nid, bool build)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i, *e;\n\tstruct nat_entry *ne;\n\tint err = -EINVAL;\n\tbool ret = false;\n\n\t/* 0 nid should not be used */\n\tif (unlikely(nid == 0))\n\t\treturn false;\n\n\ti = f2fs_kmem_cache_alloc(free_nid_slab, GFP_NOFS);\n\ti->nid = nid;\n\ti->state = NID_NEW;\n\n\tif (radix_tree_preload(GFP_NOFS))\n\t\tgoto err;\n\n\tspin_lock(&nm_i->nid_list_lock);\n\n\tif (build) {\n\t\t/*\n\t\t *   Thread A             Thread B\n\t\t *  - f2fs_create\n\t\t *   - f2fs_new_inode\n\t\t *    - alloc_nid\n\t\t *     - __insert_nid_to_list(ALLOC_NID_LIST)\n\t\t *                     - f2fs_balance_fs_bg\n\t\t *                      - build_free_nids\n\t\t *                       - __build_free_nids\n\t\t *                        - scan_nat_page\n\t\t *                         - add_free_nid\n\t\t *                          - __lookup_nat_cache\n\t\t *  - f2fs_add_link\n\t\t *   - init_inode_metadata\n\t\t *    - new_inode_page\n\t\t *     - new_node_page\n\t\t *      - set_node_addr\n\t\t *  - alloc_nid_done\n\t\t *   - __remove_nid_from_list(ALLOC_NID_LIST)\n\t\t *                         - __insert_nid_to_list(FREE_NID_LIST)\n\t\t */\n\t\tne = __lookup_nat_cache(nm_i, nid);\n\t\tif (ne && (!get_nat_flag(ne, IS_CHECKPOINTED) ||\n\t\t\t\tnat_get_blkaddr(ne) != NULL_ADDR))\n\t\t\tgoto err_out;\n\n\t\te = __lookup_free_nid_list(nm_i, nid);\n\t\tif (e) {\n\t\t\tif (e->state == NID_NEW)\n\t\t\t\tret = true;\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\tret = true;\n\terr = __insert_nid_to_list(sbi, i, FREE_NID_LIST, true);\nerr_out:\n\tspin_unlock(&nm_i->nid_list_lock);\n\tradix_tree_preload_end();\nerr:\n\tif (err)\n\t\tkmem_cache_free(free_nid_slab, i);\n\treturn ret;\n}\n\nstatic void remove_free_nid(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i;\n\tbool need_free = false;\n\n\tspin_lock(&nm_i->nid_list_lock);\n\ti = __lookup_free_nid_list(nm_i, nid);\n\tif (i && i->state == NID_NEW) {\n\t\t__remove_nid_from_list(sbi, i, FREE_NID_LIST, false);\n\t\tneed_free = true;\n\t}\n\tspin_unlock(&nm_i->nid_list_lock);\n\n\tif (need_free)\n\t\tkmem_cache_free(free_nid_slab, i);\n}\n\nstatic void update_free_nid_bitmap(struct f2fs_sb_info *sbi, nid_t nid,\n\t\t\t\t\t\t\tbool set, bool build)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tunsigned int nat_ofs = NAT_BLOCK_OFFSET(nid);\n\tunsigned int nid_ofs = nid - START_NID(nid);\n\n\tif (!test_bit_le(nat_ofs, nm_i->nat_block_bitmap))\n\t\treturn;\n\n\tif (set)\n\t\t__set_bit_le(nid_ofs, nm_i->free_nid_bitmap[nat_ofs]);\n\telse\n\t\t__clear_bit_le(nid_ofs, nm_i->free_nid_bitmap[nat_ofs]);\n\n\tif (set)\n\t\tnm_i->free_nid_count[nat_ofs]++;\n\telse if (!build)\n\t\tnm_i->free_nid_count[nat_ofs]--;\n}\n\nstatic void scan_nat_page(struct f2fs_sb_info *sbi,\n\t\t\tstruct page *nat_page, nid_t start_nid)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct f2fs_nat_block *nat_blk = page_address(nat_page);\n\tblock_t blk_addr;\n\tunsigned int nat_ofs = NAT_BLOCK_OFFSET(start_nid);\n\tint i;\n\n\tif (test_bit_le(nat_ofs, nm_i->nat_block_bitmap))\n\t\treturn;\n\n\t__set_bit_le(nat_ofs, nm_i->nat_block_bitmap);\n\n\ti = start_nid % NAT_ENTRY_PER_BLOCK;\n\n\tfor (; i < NAT_ENTRY_PER_BLOCK; i++, start_nid++) {\n\t\tbool freed = false;\n\n\t\tif (unlikely(start_nid >= nm_i->max_nid))\n\t\t\tbreak;\n\n\t\tblk_addr = le32_to_cpu(nat_blk->entries[i].block_addr);\n\t\tf2fs_bug_on(sbi, blk_addr == NEW_ADDR);\n\t\tif (blk_addr == NULL_ADDR)\n\t\t\tfreed = add_free_nid(sbi, start_nid, true);\n\t\tspin_lock(&NM_I(sbi)->nid_list_lock);\n\t\tupdate_free_nid_bitmap(sbi, start_nid, freed, true);\n\t\tspin_unlock(&NM_I(sbi)->nid_list_lock);\n\t}\n}\n\nstatic void scan_free_nid_bits(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tstruct f2fs_journal *journal = curseg->journal;\n\tunsigned int i, idx;\n\n\tdown_read(&nm_i->nat_tree_lock);\n\n\tfor (i = 0; i < nm_i->nat_blocks; i++) {\n\t\tif (!test_bit_le(i, nm_i->nat_block_bitmap))\n\t\t\tcontinue;\n\t\tif (!nm_i->free_nid_count[i])\n\t\t\tcontinue;\n\t\tfor (idx = 0; idx < NAT_ENTRY_PER_BLOCK; idx++) {\n\t\t\tnid_t nid;\n\n\t\t\tif (!test_bit_le(idx, nm_i->free_nid_bitmap[i]))\n\t\t\t\tcontinue;\n\n\t\t\tnid = i * NAT_ENTRY_PER_BLOCK + idx;\n\t\t\tadd_free_nid(sbi, nid, true);\n\n\t\t\tif (nm_i->nid_cnt[FREE_NID_LIST] >= MAX_FREE_NIDS)\n\t\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\tdown_read(&curseg->journal_rwsem);\n\tfor (i = 0; i < nats_in_cursum(journal); i++) {\n\t\tblock_t addr;\n\t\tnid_t nid;\n\n\t\taddr = le32_to_cpu(nat_in_journal(journal, i).block_addr);\n\t\tnid = le32_to_cpu(nid_in_journal(journal, i));\n\t\tif (addr == NULL_ADDR)\n\t\t\tadd_free_nid(sbi, nid, true);\n\t\telse\n\t\t\tremove_free_nid(sbi, nid);\n\t}\n\tup_read(&curseg->journal_rwsem);\n\tup_read(&nm_i->nat_tree_lock);\n}\n\nstatic void __build_free_nids(struct f2fs_sb_info *sbi, bool sync, bool mount)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tstruct f2fs_journal *journal = curseg->journal;\n\tint i = 0;\n\tnid_t nid = nm_i->next_scan_nid;\n\n\t/* Enough entries */\n\tif (nm_i->nid_cnt[FREE_NID_LIST] >= NAT_ENTRY_PER_BLOCK)\n\t\treturn;\n\n\tif (!sync && !available_free_memory(sbi, FREE_NIDS))\n\t\treturn;\n\n\tif (!mount) {\n\t\t/* try to find free nids in free_nid_bitmap */\n\t\tscan_free_nid_bits(sbi);\n\n\t\tif (nm_i->nid_cnt[FREE_NID_LIST])\n\t\t\treturn;\n\t}\n\n\t/* readahead nat pages to be scanned */\n\tra_meta_pages(sbi, NAT_BLOCK_OFFSET(nid), FREE_NID_PAGES,\n\t\t\t\t\t\t\tMETA_NAT, true);\n\n\tdown_read(&nm_i->nat_tree_lock);\n\n\twhile (1) {\n\t\tstruct page *page = get_current_nat_page(sbi, nid);\n\n\t\tscan_nat_page(sbi, page, nid);\n\t\tf2fs_put_page(page, 1);\n\n\t\tnid += (NAT_ENTRY_PER_BLOCK - (nid % NAT_ENTRY_PER_BLOCK));\n\t\tif (unlikely(nid >= nm_i->max_nid))\n\t\t\tnid = 0;\n\n\t\tif (++i >= FREE_NID_PAGES)\n\t\t\tbreak;\n\t}\n\n\t/* go to the next free nat pages to find free nids abundantly */\n\tnm_i->next_scan_nid = nid;\n\n\t/* find free nids from current sum_pages */\n\tdown_read(&curseg->journal_rwsem);\n\tfor (i = 0; i < nats_in_cursum(journal); i++) {\n\t\tblock_t addr;\n\n\t\taddr = le32_to_cpu(nat_in_journal(journal, i).block_addr);\n\t\tnid = le32_to_cpu(nid_in_journal(journal, i));\n\t\tif (addr == NULL_ADDR)\n\t\t\tadd_free_nid(sbi, nid, true);\n\t\telse\n\t\t\tremove_free_nid(sbi, nid);\n\t}\n\tup_read(&curseg->journal_rwsem);\n\tup_read(&nm_i->nat_tree_lock);\n\n\tra_meta_pages(sbi, NAT_BLOCK_OFFSET(nm_i->next_scan_nid),\n\t\t\t\t\tnm_i->ra_nid_pages, META_NAT, false);\n}\n\nvoid build_free_nids(struct f2fs_sb_info *sbi, bool sync, bool mount)\n{\n\tmutex_lock(&NM_I(sbi)->build_lock);\n\t__build_free_nids(sbi, sync, mount);\n\tmutex_unlock(&NM_I(sbi)->build_lock);\n}\n\n/*\n * If this function returns success, caller can obtain a new nid\n * from second parameter of this function.\n * The returned nid could be used ino as well as nid when inode is created.\n */\nbool alloc_nid(struct f2fs_sb_info *sbi, nid_t *nid)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i = NULL;\nretry:\n#ifdef CONFIG_F2FS_FAULT_INJECTION\n\tif (time_to_inject(sbi, FAULT_ALLOC_NID)) {\n\t\tf2fs_show_injection_info(FAULT_ALLOC_NID);\n\t\treturn false;\n\t}\n#endif\n\tspin_lock(&nm_i->nid_list_lock);\n\n\tif (unlikely(nm_i->available_nids == 0)) {\n\t\tspin_unlock(&nm_i->nid_list_lock);\n\t\treturn false;\n\t}\n\n\t/* We should not use stale free nids created by build_free_nids */\n\tif (nm_i->nid_cnt[FREE_NID_LIST] && !on_build_free_nids(nm_i)) {\n\t\tf2fs_bug_on(sbi, list_empty(&nm_i->nid_list[FREE_NID_LIST]));\n\t\ti = list_first_entry(&nm_i->nid_list[FREE_NID_LIST],\n\t\t\t\t\tstruct free_nid, list);\n\t\t*nid = i->nid;\n\n\t\t__remove_nid_from_list(sbi, i, FREE_NID_LIST, true);\n\t\ti->state = NID_ALLOC;\n\t\t__insert_nid_to_list(sbi, i, ALLOC_NID_LIST, false);\n\t\tnm_i->available_nids--;\n\n\t\tupdate_free_nid_bitmap(sbi, *nid, false, false);\n\n\t\tspin_unlock(&nm_i->nid_list_lock);\n\t\treturn true;\n\t}\n\tspin_unlock(&nm_i->nid_list_lock);\n\n\t/* Let's scan nat pages and its caches to get free nids */\n\tbuild_free_nids(sbi, true, false);\n\tgoto retry;\n}\n\n/*\n * alloc_nid() should be called prior to this function.\n */\nvoid alloc_nid_done(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i;\n\n\tspin_lock(&nm_i->nid_list_lock);\n\ti = __lookup_free_nid_list(nm_i, nid);\n\tf2fs_bug_on(sbi, !i);\n\t__remove_nid_from_list(sbi, i, ALLOC_NID_LIST, false);\n\tspin_unlock(&nm_i->nid_list_lock);\n\n\tkmem_cache_free(free_nid_slab, i);\n}\n\n/*\n * alloc_nid() should be called prior to this function.\n */\nvoid alloc_nid_failed(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i;\n\tbool need_free = false;\n\n\tif (!nid)\n\t\treturn;\n\n\tspin_lock(&nm_i->nid_list_lock);\n\ti = __lookup_free_nid_list(nm_i, nid);\n\tf2fs_bug_on(sbi, !i);\n\n\tif (!available_free_memory(sbi, FREE_NIDS)) {\n\t\t__remove_nid_from_list(sbi, i, ALLOC_NID_LIST, false);\n\t\tneed_free = true;\n\t} else {\n\t\t__remove_nid_from_list(sbi, i, ALLOC_NID_LIST, true);\n\t\ti->state = NID_NEW;\n\t\t__insert_nid_to_list(sbi, i, FREE_NID_LIST, false);\n\t}\n\n\tnm_i->available_nids++;\n\n\tupdate_free_nid_bitmap(sbi, nid, true, false);\n\n\tspin_unlock(&nm_i->nid_list_lock);\n\n\tif (need_free)\n\t\tkmem_cache_free(free_nid_slab, i);\n}\n\nint try_to_free_nids(struct f2fs_sb_info *sbi, int nr_shrink)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i, *next;\n\tint nr = nr_shrink;\n\n\tif (nm_i->nid_cnt[FREE_NID_LIST] <= MAX_FREE_NIDS)\n\t\treturn 0;\n\n\tif (!mutex_trylock(&nm_i->build_lock))\n\t\treturn 0;\n\n\tspin_lock(&nm_i->nid_list_lock);\n\tlist_for_each_entry_safe(i, next, &nm_i->nid_list[FREE_NID_LIST],\n\t\t\t\t\t\t\t\t\tlist) {\n\t\tif (nr_shrink <= 0 ||\n\t\t\t\tnm_i->nid_cnt[FREE_NID_LIST] <= MAX_FREE_NIDS)\n\t\t\tbreak;\n\n\t\t__remove_nid_from_list(sbi, i, FREE_NID_LIST, false);\n\t\tkmem_cache_free(free_nid_slab, i);\n\t\tnr_shrink--;\n\t}\n\tspin_unlock(&nm_i->nid_list_lock);\n\tmutex_unlock(&nm_i->build_lock);\n\n\treturn nr - nr_shrink;\n}\n\nvoid recover_inline_xattr(struct inode *inode, struct page *page)\n{\n\tvoid *src_addr, *dst_addr;\n\tsize_t inline_size;\n\tstruct page *ipage;\n\tstruct f2fs_inode *ri;\n\n\tipage = get_node_page(F2FS_I_SB(inode), inode->i_ino);\n\tf2fs_bug_on(F2FS_I_SB(inode), IS_ERR(ipage));\n\n\tri = F2FS_INODE(page);\n\tif (!(ri->i_inline & F2FS_INLINE_XATTR)) {\n\t\tclear_inode_flag(inode, FI_INLINE_XATTR);\n\t\tgoto update_inode;\n\t}\n\n\tdst_addr = inline_xattr_addr(ipage);\n\tsrc_addr = inline_xattr_addr(page);\n\tinline_size = inline_xattr_size(inode);\n\n\tf2fs_wait_on_page_writeback(ipage, NODE, true);\n\tmemcpy(dst_addr, src_addr, inline_size);\nupdate_inode:\n\tupdate_inode(inode, ipage);\n\tf2fs_put_page(ipage, 1);\n}\n\nint recover_xattr_data(struct inode *inode, struct page *page, block_t blkaddr)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tnid_t prev_xnid = F2FS_I(inode)->i_xattr_nid;\n\tnid_t new_xnid = nid_of_node(page);\n\tstruct node_info ni;\n\tstruct page *xpage;\n\n\tif (!prev_xnid)\n\t\tgoto recover_xnid;\n\n\t/* 1: invalidate the previous xattr nid */\n\tget_node_info(sbi, prev_xnid, &ni);\n\tf2fs_bug_on(sbi, ni.blk_addr == NULL_ADDR);\n\tinvalidate_blocks(sbi, ni.blk_addr);\n\tdec_valid_node_count(sbi, inode);\n\tset_node_addr(sbi, &ni, NULL_ADDR, false);\n\nrecover_xnid:\n\t/* 2: update xattr nid in inode */\n\tremove_free_nid(sbi, new_xnid);\n\tf2fs_i_xnid_write(inode, new_xnid);\n\tif (unlikely(!inc_valid_node_count(sbi, inode)))\n\t\tf2fs_bug_on(sbi, 1);\n\tupdate_inode_page(inode);\n\n\t/* 3: update and set xattr node page dirty */\n\txpage = grab_cache_page(NODE_MAPPING(sbi), new_xnid);\n\tif (!xpage)\n\t\treturn -ENOMEM;\n\n\tmemcpy(F2FS_NODE(xpage), F2FS_NODE(page), PAGE_SIZE);\n\n\tget_node_info(sbi, new_xnid, &ni);\n\tni.ino = inode->i_ino;\n\tset_node_addr(sbi, &ni, NEW_ADDR, false);\n\tset_page_dirty(xpage);\n\tf2fs_put_page(xpage, 1);\n\n\treturn 0;\n}\n\nint recover_inode_page(struct f2fs_sb_info *sbi, struct page *page)\n{\n\tstruct f2fs_inode *src, *dst;\n\tnid_t ino = ino_of_node(page);\n\tstruct node_info old_ni, new_ni;\n\tstruct page *ipage;\n\n\tget_node_info(sbi, ino, &old_ni);\n\n\tif (unlikely(old_ni.blk_addr != NULL_ADDR))\n\t\treturn -EINVAL;\nretry:\n\tipage = f2fs_grab_cache_page(NODE_MAPPING(sbi), ino, false);\n\tif (!ipage) {\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t\tgoto retry;\n\t}\n\n\t/* Should not use this inode from free nid list */\n\tremove_free_nid(sbi, ino);\n\n\tif (!PageUptodate(ipage))\n\t\tSetPageUptodate(ipage);\n\tfill_node_footer(ipage, ino, ino, 0, true);\n\n\tsrc = F2FS_INODE(page);\n\tdst = F2FS_INODE(ipage);\n\n\tmemcpy(dst, src, (unsigned long)&src->i_ext - (unsigned long)src);\n\tdst->i_size = 0;\n\tdst->i_blocks = cpu_to_le64(1);\n\tdst->i_links = cpu_to_le32(1);\n\tdst->i_xattr_nid = 0;\n\tdst->i_inline = src->i_inline & F2FS_INLINE_XATTR;\n\n\tnew_ni = old_ni;\n\tnew_ni.ino = ino;\n\n\tif (unlikely(!inc_valid_node_count(sbi, NULL)))\n\t\tWARN_ON(1);\n\tset_node_addr(sbi, &new_ni, NEW_ADDR, false);\n\tinc_valid_inode_count(sbi);\n\tset_page_dirty(ipage);\n\tf2fs_put_page(ipage, 1);\n\treturn 0;\n}\n\nint restore_node_summary(struct f2fs_sb_info *sbi,\n\t\t\tunsigned int segno, struct f2fs_summary_block *sum)\n{\n\tstruct f2fs_node *rn;\n\tstruct f2fs_summary *sum_entry;\n\tblock_t addr;\n\tint i, idx, last_offset, nrpages;\n\n\t/* scan the node segment */\n\tlast_offset = sbi->blocks_per_seg;\n\taddr = START_BLOCK(sbi, segno);\n\tsum_entry = &sum->entries[0];\n\n\tfor (i = 0; i < last_offset; i += nrpages, addr += nrpages) {\n\t\tnrpages = min(last_offset - i, BIO_MAX_PAGES);\n\n\t\t/* readahead node pages */\n\t\tra_meta_pages(sbi, addr, nrpages, META_POR, true);\n\n\t\tfor (idx = addr; idx < addr + nrpages; idx++) {\n\t\t\tstruct page *page = get_tmp_page(sbi, idx);\n\n\t\t\trn = F2FS_NODE(page);\n\t\t\tsum_entry->nid = rn->footer.nid;\n\t\t\tsum_entry->version = 0;\n\t\t\tsum_entry->ofs_in_node = 0;\n\t\t\tsum_entry++;\n\t\t\tf2fs_put_page(page, 1);\n\t\t}\n\n\t\tinvalidate_mapping_pages(META_MAPPING(sbi), addr,\n\t\t\t\t\t\t\taddr + nrpages);\n\t}\n\treturn 0;\n}\n\nstatic void remove_nats_in_journal(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tstruct f2fs_journal *journal = curseg->journal;\n\tint i;\n\n\tdown_write(&curseg->journal_rwsem);\n\tfor (i = 0; i < nats_in_cursum(journal); i++) {\n\t\tstruct nat_entry *ne;\n\t\tstruct f2fs_nat_entry raw_ne;\n\t\tnid_t nid = le32_to_cpu(nid_in_journal(journal, i));\n\n\t\traw_ne = nat_in_journal(journal, i);\n\n\t\tne = __lookup_nat_cache(nm_i, nid);\n\t\tif (!ne) {\n\t\t\tne = grab_nat_entry(nm_i, nid, true);\n\t\t\tnode_info_from_raw_nat(&ne->ni, &raw_ne);\n\t\t}\n\n\t\t/*\n\t\t * if a free nat in journal has not been used after last\n\t\t * checkpoint, we should remove it from available nids,\n\t\t * since later we will add it again.\n\t\t */\n\t\tif (!get_nat_flag(ne, IS_DIRTY) &&\n\t\t\t\tle32_to_cpu(raw_ne.block_addr) == NULL_ADDR) {\n\t\t\tspin_lock(&nm_i->nid_list_lock);\n\t\t\tnm_i->available_nids--;\n\t\t\tspin_unlock(&nm_i->nid_list_lock);\n\t\t}\n\n\t\t__set_nat_cache_dirty(nm_i, ne);\n\t}\n\tupdate_nats_in_cursum(journal, -i);\n\tup_write(&curseg->journal_rwsem);\n}\n\nstatic void __adjust_nat_entry_set(struct nat_entry_set *nes,\n\t\t\t\t\t\tstruct list_head *head, int max)\n{\n\tstruct nat_entry_set *cur;\n\n\tif (nes->entry_cnt >= max)\n\t\tgoto add_out;\n\n\tlist_for_each_entry(cur, head, set_list) {\n\t\tif (cur->entry_cnt >= nes->entry_cnt) {\n\t\t\tlist_add(&nes->set_list, cur->set_list.prev);\n\t\t\treturn;\n\t\t}\n\t}\nadd_out:\n\tlist_add_tail(&nes->set_list, head);\n}\n\nstatic void __update_nat_bits(struct f2fs_sb_info *sbi, nid_t start_nid,\n\t\t\t\t\t\tstruct page *page)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tunsigned int nat_index = start_nid / NAT_ENTRY_PER_BLOCK;\n\tstruct f2fs_nat_block *nat_blk = page_address(page);\n\tint valid = 0;\n\tint i;\n\n\tif (!enabled_nat_bits(sbi, NULL))\n\t\treturn;\n\n\tfor (i = 0; i < NAT_ENTRY_PER_BLOCK; i++) {\n\t\tif (start_nid == 0 && i == 0)\n\t\t\tvalid++;\n\t\tif (nat_blk->entries[i].block_addr)\n\t\t\tvalid++;\n\t}\n\tif (valid == 0) {\n\t\t__set_bit_le(nat_index, nm_i->empty_nat_bits);\n\t\t__clear_bit_le(nat_index, nm_i->full_nat_bits);\n\t\treturn;\n\t}\n\n\t__clear_bit_le(nat_index, nm_i->empty_nat_bits);\n\tif (valid == NAT_ENTRY_PER_BLOCK)\n\t\t__set_bit_le(nat_index, nm_i->full_nat_bits);\n\telse\n\t\t__clear_bit_le(nat_index, nm_i->full_nat_bits);\n}\n\nstatic void __flush_nat_entry_set(struct f2fs_sb_info *sbi,\n\t\tstruct nat_entry_set *set, struct cp_control *cpc)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tstruct f2fs_journal *journal = curseg->journal;\n\tnid_t start_nid = set->set * NAT_ENTRY_PER_BLOCK;\n\tbool to_journal = true;\n\tstruct f2fs_nat_block *nat_blk;\n\tstruct nat_entry *ne, *cur;\n\tstruct page *page = NULL;\n\n\t/*\n\t * there are two steps to flush nat entries:\n\t * #1, flush nat entries to journal in current hot data summary block.\n\t * #2, flush nat entries to nat page.\n\t */\n\tif (enabled_nat_bits(sbi, cpc) ||\n\t\t!__has_cursum_space(journal, set->entry_cnt, NAT_JOURNAL))\n\t\tto_journal = false;\n\n\tif (to_journal) {\n\t\tdown_write(&curseg->journal_rwsem);\n\t} else {\n\t\tpage = get_next_nat_page(sbi, start_nid);\n\t\tnat_blk = page_address(page);\n\t\tf2fs_bug_on(sbi, !nat_blk);\n\t}\n\n\t/* flush dirty nats in nat entry set */\n\tlist_for_each_entry_safe(ne, cur, &set->entry_list, list) {\n\t\tstruct f2fs_nat_entry *raw_ne;\n\t\tnid_t nid = nat_get_nid(ne);\n\t\tint offset;\n\n\t\tif (nat_get_blkaddr(ne) == NEW_ADDR)\n\t\t\tcontinue;\n\n\t\tif (to_journal) {\n\t\t\toffset = lookup_journal_in_cursum(journal,\n\t\t\t\t\t\t\tNAT_JOURNAL, nid, 1);\n\t\t\tf2fs_bug_on(sbi, offset < 0);\n\t\t\traw_ne = &nat_in_journal(journal, offset);\n\t\t\tnid_in_journal(journal, offset) = cpu_to_le32(nid);\n\t\t} else {\n\t\t\traw_ne = &nat_blk->entries[nid - start_nid];\n\t\t}\n\t\traw_nat_from_node_info(raw_ne, &ne->ni);\n\t\tnat_reset_flag(ne);\n\t\t__clear_nat_cache_dirty(NM_I(sbi), set, ne);\n\t\tif (nat_get_blkaddr(ne) == NULL_ADDR) {\n\t\t\tadd_free_nid(sbi, nid, false);\n\t\t\tspin_lock(&NM_I(sbi)->nid_list_lock);\n\t\t\tNM_I(sbi)->available_nids++;\n\t\t\tupdate_free_nid_bitmap(sbi, nid, true, false);\n\t\t\tspin_unlock(&NM_I(sbi)->nid_list_lock);\n\t\t} else {\n\t\t\tspin_lock(&NM_I(sbi)->nid_list_lock);\n\t\t\tupdate_free_nid_bitmap(sbi, nid, false, false);\n\t\t\tspin_unlock(&NM_I(sbi)->nid_list_lock);\n\t\t}\n\t}\n\n\tif (to_journal) {\n\t\tup_write(&curseg->journal_rwsem);\n\t} else {\n\t\t__update_nat_bits(sbi, start_nid, page);\n\t\tf2fs_put_page(page, 1);\n\t}\n\n\tf2fs_bug_on(sbi, set->entry_cnt);\n\n\tradix_tree_delete(&NM_I(sbi)->nat_set_root, set->set);\n\tkmem_cache_free(nat_entry_set_slab, set);\n}\n\n/*\n * This function is called during the checkpointing process.\n */\nvoid flush_nat_entries(struct f2fs_sb_info *sbi, struct cp_control *cpc)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tstruct f2fs_journal *journal = curseg->journal;\n\tstruct nat_entry_set *setvec[SETVEC_SIZE];\n\tstruct nat_entry_set *set, *tmp;\n\tunsigned int found;\n\tnid_t set_idx = 0;\n\tLIST_HEAD(sets);\n\n\tif (!nm_i->dirty_nat_cnt)\n\t\treturn;\n\n\tdown_write(&nm_i->nat_tree_lock);\n\n\t/*\n\t * if there are no enough space in journal to store dirty nat\n\t * entries, remove all entries from journal and merge them\n\t * into nat entry set.\n\t */\n\tif (enabled_nat_bits(sbi, cpc) ||\n\t\t!__has_cursum_space(journal, nm_i->dirty_nat_cnt, NAT_JOURNAL))\n\t\tremove_nats_in_journal(sbi);\n\n\twhile ((found = __gang_lookup_nat_set(nm_i,\n\t\t\t\t\tset_idx, SETVEC_SIZE, setvec))) {\n\t\tunsigned idx;\n\t\tset_idx = setvec[found - 1]->set + 1;\n\t\tfor (idx = 0; idx < found; idx++)\n\t\t\t__adjust_nat_entry_set(setvec[idx], &sets,\n\t\t\t\t\t\tMAX_NAT_JENTRIES(journal));\n\t}\n\n\t/* flush dirty nats in nat entry set */\n\tlist_for_each_entry_safe(set, tmp, &sets, set_list)\n\t\t__flush_nat_entry_set(sbi, set, cpc);\n\n\tup_write(&nm_i->nat_tree_lock);\n\n\tf2fs_bug_on(sbi, nm_i->dirty_nat_cnt);\n}\n\nstatic int __get_nat_bitmaps(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tunsigned int nat_bits_bytes = nm_i->nat_blocks / BITS_PER_BYTE;\n\tunsigned int i;\n\t__u64 cp_ver = cur_cp_version(ckpt);\n\tblock_t nat_bits_addr;\n\n\tif (!enabled_nat_bits(sbi, NULL))\n\t\treturn 0;\n\n\tnm_i->nat_bits_blocks = F2FS_BYTES_TO_BLK((nat_bits_bytes << 1) + 8 +\n\t\t\t\t\t\tF2FS_BLKSIZE - 1);\n\tnm_i->nat_bits = kzalloc(nm_i->nat_bits_blocks << F2FS_BLKSIZE_BITS,\n\t\t\t\t\t\tGFP_KERNEL);\n\tif (!nm_i->nat_bits)\n\t\treturn -ENOMEM;\n\n\tnat_bits_addr = __start_cp_addr(sbi) + sbi->blocks_per_seg -\n\t\t\t\t\t\tnm_i->nat_bits_blocks;\n\tfor (i = 0; i < nm_i->nat_bits_blocks; i++) {\n\t\tstruct page *page = get_meta_page(sbi, nat_bits_addr++);\n\n\t\tmemcpy(nm_i->nat_bits + (i << F2FS_BLKSIZE_BITS),\n\t\t\t\t\tpage_address(page), F2FS_BLKSIZE);\n\t\tf2fs_put_page(page, 1);\n\t}\n\n\tcp_ver |= (cur_cp_crc(ckpt) << 32);\n\tif (cpu_to_le64(cp_ver) != *(__le64 *)nm_i->nat_bits) {\n\t\tdisable_nat_bits(sbi, true);\n\t\treturn 0;\n\t}\n\n\tnm_i->full_nat_bits = nm_i->nat_bits + 8;\n\tnm_i->empty_nat_bits = nm_i->full_nat_bits + nat_bits_bytes;\n\n\tf2fs_msg(sbi->sb, KERN_NOTICE, \"Found nat_bits in checkpoint\");\n\treturn 0;\n}\n\ninline void load_free_nid_bitmap(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tunsigned int i = 0;\n\tnid_t nid, last_nid;\n\n\tif (!enabled_nat_bits(sbi, NULL))\n\t\treturn;\n\n\tfor (i = 0; i < nm_i->nat_blocks; i++) {\n\t\ti = find_next_bit_le(nm_i->empty_nat_bits, nm_i->nat_blocks, i);\n\t\tif (i >= nm_i->nat_blocks)\n\t\t\tbreak;\n\n\t\t__set_bit_le(i, nm_i->nat_block_bitmap);\n\n\t\tnid = i * NAT_ENTRY_PER_BLOCK;\n\t\tlast_nid = (i + 1) * NAT_ENTRY_PER_BLOCK;\n\n\t\tspin_lock(&NM_I(sbi)->nid_list_lock);\n\t\tfor (; nid < last_nid; nid++)\n\t\t\tupdate_free_nid_bitmap(sbi, nid, true, true);\n\t\tspin_unlock(&NM_I(sbi)->nid_list_lock);\n\t}\n\n\tfor (i = 0; i < nm_i->nat_blocks; i++) {\n\t\ti = find_next_bit_le(nm_i->full_nat_bits, nm_i->nat_blocks, i);\n\t\tif (i >= nm_i->nat_blocks)\n\t\t\tbreak;\n\n\t\t__set_bit_le(i, nm_i->nat_block_bitmap);\n\t}\n}\n\nstatic int init_node_manager(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_super_block *sb_raw = F2FS_RAW_SUPER(sbi);\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tunsigned char *version_bitmap;\n\tunsigned int nat_segs;\n\tint err;\n\n\tnm_i->nat_blkaddr = le32_to_cpu(sb_raw->nat_blkaddr);\n\n\t/* segment_count_nat includes pair segment so divide to 2. */\n\tnat_segs = le32_to_cpu(sb_raw->segment_count_nat) >> 1;\n\tnm_i->nat_blocks = nat_segs << le32_to_cpu(sb_raw->log_blocks_per_seg);\n\tnm_i->max_nid = NAT_ENTRY_PER_BLOCK * nm_i->nat_blocks;\n\n\t/* not used nids: 0, node, meta, (and root counted as valid node) */\n\tnm_i->available_nids = nm_i->max_nid - sbi->total_valid_node_count -\n\t\t\t\t\t\t\tF2FS_RESERVED_NODE_NUM;\n\tnm_i->nid_cnt[FREE_NID_LIST] = 0;\n\tnm_i->nid_cnt[ALLOC_NID_LIST] = 0;\n\tnm_i->nat_cnt = 0;\n\tnm_i->ram_thresh = DEF_RAM_THRESHOLD;\n\tnm_i->ra_nid_pages = DEF_RA_NID_PAGES;\n\tnm_i->dirty_nats_ratio = DEF_DIRTY_NAT_RATIO_THRESHOLD;\n\n\tINIT_RADIX_TREE(&nm_i->free_nid_root, GFP_ATOMIC);\n\tINIT_LIST_HEAD(&nm_i->nid_list[FREE_NID_LIST]);\n\tINIT_LIST_HEAD(&nm_i->nid_list[ALLOC_NID_LIST]);\n\tINIT_RADIX_TREE(&nm_i->nat_root, GFP_NOIO);\n\tINIT_RADIX_TREE(&nm_i->nat_set_root, GFP_NOIO);\n\tINIT_LIST_HEAD(&nm_i->nat_entries);\n\n\tmutex_init(&nm_i->build_lock);\n\tspin_lock_init(&nm_i->nid_list_lock);\n\tinit_rwsem(&nm_i->nat_tree_lock);\n\n\tnm_i->next_scan_nid = le32_to_cpu(sbi->ckpt->next_free_nid);\n\tnm_i->bitmap_size = __bitmap_size(sbi, NAT_BITMAP);\n\tversion_bitmap = __bitmap_ptr(sbi, NAT_BITMAP);\n\tif (!version_bitmap)\n\t\treturn -EFAULT;\n\n\tnm_i->nat_bitmap = kmemdup(version_bitmap, nm_i->bitmap_size,\n\t\t\t\t\tGFP_KERNEL);\n\tif (!nm_i->nat_bitmap)\n\t\treturn -ENOMEM;\n\n\terr = __get_nat_bitmaps(sbi);\n\tif (err)\n\t\treturn err;\n\n#ifdef CONFIG_F2FS_CHECK_FS\n\tnm_i->nat_bitmap_mir = kmemdup(version_bitmap, nm_i->bitmap_size,\n\t\t\t\t\tGFP_KERNEL);\n\tif (!nm_i->nat_bitmap_mir)\n\t\treturn -ENOMEM;\n#endif\n\n\treturn 0;\n}\n\nstatic int init_free_nid_cache(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\n\tnm_i->free_nid_bitmap = f2fs_kvzalloc(nm_i->nat_blocks *\n\t\t\t\t\tNAT_ENTRY_BITMAP_SIZE, GFP_KERNEL);\n\tif (!nm_i->free_nid_bitmap)\n\t\treturn -ENOMEM;\n\n\tnm_i->nat_block_bitmap = f2fs_kvzalloc(nm_i->nat_blocks / 8,\n\t\t\t\t\t\t\t\tGFP_KERNEL);\n\tif (!nm_i->nat_block_bitmap)\n\t\treturn -ENOMEM;\n\n\tnm_i->free_nid_count = f2fs_kvzalloc(nm_i->nat_blocks *\n\t\t\t\t\tsizeof(unsigned short), GFP_KERNEL);\n\tif (!nm_i->free_nid_count)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nint build_node_manager(struct f2fs_sb_info *sbi)\n{\n\tint err;\n\n\tsbi->nm_info = kzalloc(sizeof(struct f2fs_nm_info), GFP_KERNEL);\n\tif (!sbi->nm_info)\n\t\treturn -ENOMEM;\n\n\terr = init_node_manager(sbi);\n\tif (err)\n\t\treturn err;\n\n\terr = init_free_nid_cache(sbi);\n\tif (err)\n\t\treturn err;\n\n\t/* load free nid status from nat_bits table */\n\tload_free_nid_bitmap(sbi);\n\n\tbuild_free_nids(sbi, true, true);\n\treturn 0;\n}\n\nvoid destroy_node_manager(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i, *next_i;\n\tstruct nat_entry *natvec[NATVEC_SIZE];\n\tstruct nat_entry_set *setvec[SETVEC_SIZE];\n\tnid_t nid = 0;\n\tunsigned int found;\n\n\tif (!nm_i)\n\t\treturn;\n\n\t/* destroy free nid list */\n\tspin_lock(&nm_i->nid_list_lock);\n\tlist_for_each_entry_safe(i, next_i, &nm_i->nid_list[FREE_NID_LIST],\n\t\t\t\t\t\t\t\t\tlist) {\n\t\t__remove_nid_from_list(sbi, i, FREE_NID_LIST, false);\n\t\tspin_unlock(&nm_i->nid_list_lock);\n\t\tkmem_cache_free(free_nid_slab, i);\n\t\tspin_lock(&nm_i->nid_list_lock);\n\t}\n\tf2fs_bug_on(sbi, nm_i->nid_cnt[FREE_NID_LIST]);\n\tf2fs_bug_on(sbi, nm_i->nid_cnt[ALLOC_NID_LIST]);\n\tf2fs_bug_on(sbi, !list_empty(&nm_i->nid_list[ALLOC_NID_LIST]));\n\tspin_unlock(&nm_i->nid_list_lock);\n\n\t/* destroy nat cache */\n\tdown_write(&nm_i->nat_tree_lock);\n\twhile ((found = __gang_lookup_nat_cache(nm_i,\n\t\t\t\t\tnid, NATVEC_SIZE, natvec))) {\n\t\tunsigned idx;\n\n\t\tnid = nat_get_nid(natvec[found - 1]) + 1;\n\t\tfor (idx = 0; idx < found; idx++)\n\t\t\t__del_from_nat_cache(nm_i, natvec[idx]);\n\t}\n\tf2fs_bug_on(sbi, nm_i->nat_cnt);\n\n\t/* destroy nat set cache */\n\tnid = 0;\n\twhile ((found = __gang_lookup_nat_set(nm_i,\n\t\t\t\t\tnid, SETVEC_SIZE, setvec))) {\n\t\tunsigned idx;\n\n\t\tnid = setvec[found - 1]->set + 1;\n\t\tfor (idx = 0; idx < found; idx++) {\n\t\t\t/* entry_cnt is not zero, when cp_error was occurred */\n\t\t\tf2fs_bug_on(sbi, !list_empty(&setvec[idx]->entry_list));\n\t\t\tradix_tree_delete(&nm_i->nat_set_root, setvec[idx]->set);\n\t\t\tkmem_cache_free(nat_entry_set_slab, setvec[idx]);\n\t\t}\n\t}\n\tup_write(&nm_i->nat_tree_lock);\n\n\tkvfree(nm_i->nat_block_bitmap);\n\tkvfree(nm_i->free_nid_bitmap);\n\tkvfree(nm_i->free_nid_count);\n\n\tkfree(nm_i->nat_bitmap);\n\tkfree(nm_i->nat_bits);\n#ifdef CONFIG_F2FS_CHECK_FS\n\tkfree(nm_i->nat_bitmap_mir);\n#endif\n\tsbi->nm_info = NULL;\n\tkfree(nm_i);\n}\n\nint __init create_node_manager_caches(void)\n{\n\tnat_entry_slab = f2fs_kmem_cache_create(\"nat_entry\",\n\t\t\tsizeof(struct nat_entry));\n\tif (!nat_entry_slab)\n\t\tgoto fail;\n\n\tfree_nid_slab = f2fs_kmem_cache_create(\"free_nid\",\n\t\t\tsizeof(struct free_nid));\n\tif (!free_nid_slab)\n\t\tgoto destroy_nat_entry;\n\n\tnat_entry_set_slab = f2fs_kmem_cache_create(\"nat_entry_set\",\n\t\t\tsizeof(struct nat_entry_set));\n\tif (!nat_entry_set_slab)\n\t\tgoto destroy_free_nid;\n\treturn 0;\n\ndestroy_free_nid:\n\tkmem_cache_destroy(free_nid_slab);\ndestroy_nat_entry:\n\tkmem_cache_destroy(nat_entry_slab);\nfail:\n\treturn -ENOMEM;\n}\n\nvoid destroy_node_manager_caches(void)\n{\n\tkmem_cache_destroy(nat_entry_set_slab);\n\tkmem_cache_destroy(free_nid_slab);\n\tkmem_cache_destroy(nat_entry_slab);\n}\n"], "filenames": ["fs/f2fs/node.c"], "buggy_code_start_loc": [1764], "buggy_code_end_loc": [1798], "fixing_code_start_loc": [1764], "fixing_code_end_loc": [1825], "type": "CWE-362", "message": "The add_free_nid function in fs/f2fs/node.c in the Linux kernel before 4.12 does not properly track an allocated nid, which allows local users to cause a denial of service (race condition) or possibly have unspecified other impact via concurrent threads.", "other": {"cve": {"id": "CVE-2017-18249", "sourceIdentifier": "cve@mitre.org", "published": "2018-03-26T20:29:00.227", "lastModified": "2019-04-03T01:29:00.863", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The add_free_nid function in fs/f2fs/node.c in the Linux kernel before 4.12 does not properly track an allocated nid, which allows local users to cause a denial of service (race condition) or possibly have unspecified other impact via concurrent threads."}, {"lang": "es", "value": "La funci\u00f3n add_free_nid en fs/f2fs/noce.c en el kernel de Linux, en versiones anteriores a la 4.12, no rastrea correctamente un nid asignado, lo cual podr\u00eda permitir a los usuarios locales provocar una denegaci\u00f3n de servicio (condici\u00f3n de carrera) o, posiblemente, causar otro impacto sin especificar mediante hilos concurrentes."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.0, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.0, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.4, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-362"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.12", "matchCriteriaId": "D9BBDA7A-EA95-41C5-8F4C-CA458BCB7E1F"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=30a61ddf8117c26ac5b295e1233eaa9629a94ca3", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "http://www.securitytracker.com/id/1041432", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/torvalds/linux/commit/30a61ddf8117c26ac5b295e1233eaa9629a94ca3", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/03/msg00017.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3932-1/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/3932-2/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/30a61ddf8117c26ac5b295e1233eaa9629a94ca3"}}