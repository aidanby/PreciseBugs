{"buggy_code": ["'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst EventEmitter = require('events').EventEmitter;\nconst Kareem = require('kareem');\nconst MongooseError = require('./error/mongooseError');\nconst SchemaType = require('./schematype');\nconst SchemaTypeOptions = require('./options/SchemaTypeOptions');\nconst VirtualOptions = require('./options/VirtualOptions');\nconst VirtualType = require('./virtualtype');\nconst addAutoId = require('./helpers/schema/addAutoId');\nconst get = require('./helpers/get');\nconst getConstructorName = require('./helpers/getConstructorName');\nconst getIndexes = require('./helpers/schema/getIndexes');\nconst idGetter = require('./helpers/schema/idGetter');\nconst merge = require('./helpers/schema/merge');\nconst mpath = require('mpath');\nconst readPref = require('./driver').get().ReadPreference;\nconst setupTimestamps = require('./helpers/timestamps/setupTimestamps');\nconst utils = require('./utils');\nconst validateRef = require('./helpers/populate/validateRef');\nconst util = require('util');\n\nlet MongooseTypes;\n\nconst queryHooks = require('./helpers/query/applyQueryMiddleware').\n  middlewareFunctions;\nconst documentHooks = require('./helpers/model/applyHooks').middlewareFunctions;\nconst hookNames = queryHooks.concat(documentHooks).\n  reduce((s, hook) => s.add(hook), new Set());\n\nconst isPOJO = utils.isPOJO;\n\nlet id = 0;\n\n/**\n * Schema constructor.\n *\n * #### Example:\n *\n *     const child = new Schema({ name: String });\n *     const schema = new Schema({ name: String, age: Number, children: [child] });\n *     const Tree = mongoose.model('Tree', schema);\n *\n *     // setting schema options\n *     new Schema({ name: String }, { _id: false, autoIndex: false })\n *\n * #### Options:\n *\n * - [autoIndex](/docs/guide.html#autoIndex): bool - defaults to null (which means use the connection's autoIndex option)\n * - [autoCreate](/docs/guide.html#autoCreate): bool - defaults to null (which means use the connection's autoCreate option)\n * - [bufferCommands](/docs/guide.html#bufferCommands): bool - defaults to true\n * - [bufferTimeoutMS](/docs/guide.html#bufferTimeoutMS): number - defaults to 10000 (10 seconds). If `bufferCommands` is enabled, the amount of time Mongoose will wait for connectivity to be restablished before erroring out.\n * - [capped](/docs/guide.html#capped): bool | number | object - defaults to false\n * - [collection](/docs/guide.html#collection): string - no default\n * - [discriminatorKey](/docs/guide.html#discriminatorKey): string - defaults to `__t`\n * - [id](/docs/guide.html#id): bool - defaults to true\n * - [_id](/docs/guide.html#_id): bool - defaults to true\n * - [minimize](/docs/guide.html#minimize): bool - controls [document#toObject](#document_Document-toObject) behavior when called manually - defaults to true\n * - [read](/docs/guide.html#read): string\n * - [writeConcern](/docs/guide.html#writeConcern): object - defaults to null, use to override [the MongoDB server's default write concern settings](https://docs.mongodb.com/manual/reference/write-concern/)\n * - [shardKey](/docs/guide.html#shardKey): object - defaults to `null`\n * - [strict](/docs/guide.html#strict): bool - defaults to true\n * - [strictQuery](/docs/guide.html#strictQuery): bool - defaults to false\n * - [toJSON](/docs/guide.html#toJSON) - object - no default\n * - [toObject](/docs/guide.html#toObject) - object - no default\n * - [typeKey](/docs/guide.html#typeKey) - string - defaults to 'type'\n * - [validateBeforeSave](/docs/guide.html#validateBeforeSave) - bool - defaults to `true`\n * - [versionKey](/docs/guide.html#versionKey): string or object - defaults to \"__v\"\n * - [optimisticConcurrency](/docs/guide.html#optimisticConcurrency): bool - defaults to false. Set to true to enable [optimistic concurrency](https://thecodebarbarian.com/whats-new-in-mongoose-5-10-optimistic-concurrency.html).\n * - [collation](/docs/guide.html#collation): object - defaults to null (which means use no collation)\n * - [timeseries](/docs/guide.html#timeseries): object - defaults to null (which means this schema's collection won't be a timeseries collection)\n * - [selectPopulatedPaths](/docs/guide.html#selectPopulatedPaths): boolean - defaults to `true`\n * - [skipVersioning](/docs/guide.html#skipVersioning): object - paths to exclude from versioning\n * - [timestamps](/docs/guide.html#timestamps): object or boolean - defaults to `false`. If true, Mongoose adds `createdAt` and `updatedAt` properties to your schema and manages those properties for you.\n * - [pluginTags](/docs/guide.html#pluginTags): array of strings - defaults to `undefined`. If set and plugin called with `tags` option, will only apply that plugin to schemas with a matching tag.\n *\n * #### Options for Nested Schemas:\n *\n * - `excludeIndexes`: bool - defaults to `false`. If `true`, skip building indexes on this schema's paths.\n *\n * #### Note:\n *\n * _When nesting schemas, (`children` in the example above), always declare the child schema first before passing it into its parent._\n *\n * @param {Object|Schema|Array} [definition] Can be one of: object describing schema paths, or schema to copy, or array of objects and schemas\n * @param {Object} [options]\n * @inherits NodeJS EventEmitter https://nodejs.org/api/events.html#events_class_events_eventemitter\n * @event `init`: Emitted after the schema is compiled into a `Model`.\n * @api public\n */\n\nfunction Schema(obj, options) {\n  if (!(this instanceof Schema)) {\n    return new Schema(obj, options);\n  }\n\n  this.obj = obj;\n  this.paths = {};\n  this.aliases = {};\n  this.subpaths = {};\n  this.virtuals = {};\n  this.singleNestedPaths = {};\n  this.nested = {};\n  this.inherits = {};\n  this.callQueue = [];\n  this._indexes = [];\n  this.methods = (options && options.methods) || {};\n  this.methodOptions = {};\n  this.statics = (options && options.statics) || {};\n  this.tree = {};\n  this.query = (options && options.query) || {};\n  this.childSchemas = [];\n  this.plugins = [];\n  // For internal debugging. Do not use this to try to save a schema in MDB.\n  this.$id = ++id;\n  this.mapPaths = [];\n\n  this.s = {\n    hooks: new Kareem()\n  };\n  this.options = this.defaultOptions(options);\n\n  // build paths\n  if (Array.isArray(obj)) {\n    for (const definition of obj) {\n      this.add(definition);\n    }\n  } else if (obj) {\n    this.add(obj);\n  }\n\n  // check if _id's value is a subdocument (gh-2276)\n  const _idSubDoc = obj && obj._id && utils.isObject(obj._id);\n\n  // ensure the documents get an auto _id unless disabled\n  const auto_id = !this.paths['_id'] &&\n      (this.options._id) && !_idSubDoc;\n\n  if (auto_id) {\n    addAutoId(this);\n  }\n\n  this.setupTimestamp(this.options.timestamps);\n}\n\n/*!\n * Create virtual properties with alias field\n */\nfunction aliasFields(schema, paths) {\n  paths = paths || Object.keys(schema.paths);\n  for (const path of paths) {\n    const options = get(schema.paths[path], 'options');\n    if (options == null) {\n      continue;\n    }\n\n    const prop = schema.paths[path].path;\n    const alias = options.alias;\n\n    if (!alias) {\n      continue;\n    }\n\n    if (typeof alias !== 'string') {\n      throw new Error('Invalid value for alias option on ' + prop + ', got ' + alias);\n    }\n\n    schema.aliases[alias] = prop;\n\n    schema.\n      virtual(alias).\n      get((function(p) {\n        return function() {\n          if (typeof this.get === 'function') {\n            return this.get(p);\n          }\n          return this[p];\n        };\n      })(prop)).\n      set((function(p) {\n        return function(v) {\n          return this.$set(p, v);\n        };\n      })(prop));\n  }\n}\n\n/*!\n * Inherit from EventEmitter.\n */\nSchema.prototype = Object.create(EventEmitter.prototype);\nSchema.prototype.constructor = Schema;\nSchema.prototype.instanceOfSchema = true;\n\n/*!\n * ignore\n */\n\nObject.defineProperty(Schema.prototype, '$schemaType', {\n  configurable: false,\n  enumerable: false,\n  writable: true\n});\n\n/**\n * Array of child schemas (from document arrays and single nested subdocs)\n * and their corresponding compiled models. Each element of the array is\n * an object with 2 properties: `schema` and `model`.\n *\n * This property is typically only useful for plugin authors and advanced users.\n * You do not need to interact with this property at all to use mongoose.\n *\n * @api public\n * @property childSchemas\n * @memberOf Schema\n * @instance\n */\n\nObject.defineProperty(Schema.prototype, 'childSchemas', {\n  configurable: false,\n  enumerable: true,\n  writable: true\n});\n\n/**\n * Object containing all virtuals defined on this schema.\n * The objects' keys are the virtual paths and values are instances of `VirtualType`.\n *\n * This property is typically only useful for plugin authors and advanced users.\n * You do not need to interact with this property at all to use mongoose.\n *\n * #### Example:\n *\n *     const schema = new Schema({});\n *     schema.virtual('answer').get(() => 42);\n *\n *     console.log(schema.virtuals); // { answer: VirtualType { path: 'answer', ... } }\n *     console.log(schema.virtuals['answer'].getters[0].call()); // 42\n *\n * @api public\n * @property virtuals\n * @memberOf Schema\n * @instance\n */\n\nObject.defineProperty(Schema.prototype, 'virtuals', {\n  configurable: false,\n  enumerable: true,\n  writable: true\n});\n\n/**\n * The original object passed to the schema constructor\n *\n * #### Example:\n *\n *     const schema = new Schema({ a: String }).add({ b: String });\n *     schema.obj; // { a: String }\n *\n * @api public\n * @property obj\n * @memberOf Schema\n * @instance\n */\n\nSchema.prototype.obj;\n\n/**\n * The paths defined on this schema. The keys are the top-level paths\n * in this schema, and the values are instances of the SchemaType class.\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: String }, { _id: false });\n *     schema.paths; // { name: SchemaString { ... } }\n *\n *     schema.add({ age: Number });\n *     schema.paths; // { name: SchemaString { ... }, age: SchemaNumber { ... } }\n *\n * @api public\n * @property paths\n * @memberOf Schema\n * @instance\n */\n\nSchema.prototype.paths;\n\n/**\n * Schema as a tree\n *\n * #### Example:\n *\n *     {\n *         '_id'     : ObjectId\n *       , 'nested'  : {\n *             'key' : String\n *         }\n *     }\n *\n * @api private\n * @property tree\n * @memberOf Schema\n * @instance\n */\n\nSchema.prototype.tree;\n\n/**\n * Returns a deep copy of the schema\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: String });\n *     const clone = schema.clone();\n *     clone === schema; // false\n *     clone.path('name'); // SchemaString { ... }\n *\n * @return {Schema} the cloned schema\n * @api public\n * @memberOf Schema\n * @instance\n */\n\nSchema.prototype.clone = function() {\n  const s = this._clone();\n\n  // Bubble up `init` for backwards compat\n  s.on('init', v => this.emit('init', v));\n\n  return s;\n};\n\n/*!\n * ignore\n */\n\nSchema.prototype._clone = function _clone(Constructor) {\n  Constructor = Constructor || (this.base == null ? Schema : this.base.Schema);\n\n  const s = new Constructor({}, this._userProvidedOptions);\n  s.base = this.base;\n  s.obj = this.obj;\n  s.options = utils.clone(this.options);\n  s.callQueue = this.callQueue.map(function(f) { return f; });\n  s.methods = utils.clone(this.methods);\n  s.methodOptions = utils.clone(this.methodOptions);\n  s.statics = utils.clone(this.statics);\n  s.query = utils.clone(this.query);\n  s.plugins = Array.prototype.slice.call(this.plugins);\n  s._indexes = utils.clone(this._indexes);\n  s.s.hooks = this.s.hooks.clone();\n\n  s.tree = utils.clone(this.tree);\n  s.paths = utils.clone(this.paths);\n  s.nested = utils.clone(this.nested);\n  s.subpaths = utils.clone(this.subpaths);\n  s.singleNestedPaths = utils.clone(this.singleNestedPaths);\n  s.childSchemas = gatherChildSchemas(s);\n\n  s.virtuals = utils.clone(this.virtuals);\n  s.$globalPluginsApplied = this.$globalPluginsApplied;\n  s.$isRootDiscriminator = this.$isRootDiscriminator;\n  s.$implicitlyCreated = this.$implicitlyCreated;\n  s.$id = ++id;\n  s.$originalSchemaId = this.$id;\n  s.mapPaths = [].concat(this.mapPaths);\n\n  if (this.discriminatorMapping != null) {\n    s.discriminatorMapping = Object.assign({}, this.discriminatorMapping);\n  }\n  if (this.discriminators != null) {\n    s.discriminators = Object.assign({}, this.discriminators);\n  }\n  if (this._applyDiscriminators != null) {\n    s._applyDiscriminators = Object.assign({}, this._applyDiscriminators);\n  }\n\n  s.aliases = Object.assign({}, this.aliases);\n\n  return s;\n};\n\n/**\n * Returns a new schema that has the picked `paths` from this schema.\n *\n * This method is analagous to [Lodash's `pick()` function](https://lodash.com/docs/4.17.15#pick) for Mongoose schemas.\n *\n * #### Example:\n *\n *     const schema = Schema({ name: String, age: Number });\n *     // Creates a new schema with the same `name` path as `schema`,\n *     // but no `age` path.\n *     const newSchema = schema.pick(['name']);\n *\n *     newSchema.path('name'); // SchemaString { ... }\n *     newSchema.path('age'); // undefined\n *\n * @param {String[]} paths List of Paths to pick for the new Schema\n * @param {Object} [options] Options to pass to the new Schema Constructor (same as `new Schema(.., Options)`). Defaults to `this.options` if not set.\n * @return {Schema}\n * @api public\n */\n\nSchema.prototype.pick = function(paths, options) {\n  const newSchema = new Schema({}, options || this.options);\n  if (!Array.isArray(paths)) {\n    throw new MongooseError('Schema#pick() only accepts an array argument, ' +\n      'got \"' + typeof paths + '\"');\n  }\n\n  for (const path of paths) {\n    if (this.nested[path]) {\n      newSchema.add({ [path]: get(this.tree, path) });\n    } else {\n      const schematype = this.path(path);\n      if (schematype == null) {\n        throw new MongooseError('Path `' + path + '` is not in the schema');\n      }\n      newSchema.add({ [path]: schematype });\n    }\n  }\n\n  return newSchema;\n};\n\n/**\n * Returns default options for this schema, merged with `options`.\n *\n * @param {Object} [options] Options to overwrite the default options\n * @return {Object} The merged options of `options` and the default options\n * @api private\n */\n\nSchema.prototype.defaultOptions = function(options) {\n  this._userProvidedOptions = options == null ? {} : utils.clone(options);\n  const baseOptions = this.base && this.base.options || {};\n\n  const strict = 'strict' in baseOptions ? baseOptions.strict : true;\n  options = utils.options({\n    strict: strict,\n    strictQuery: 'strict' in this._userProvidedOptions ?\n      this._userProvidedOptions.strict :\n      'strictQuery' in baseOptions ?\n        baseOptions.strictQuery : strict,\n    bufferCommands: true,\n    capped: false, // { size, max, autoIndexId }\n    versionKey: '__v',\n    optimisticConcurrency: false,\n    minimize: true,\n    autoIndex: null,\n    discriminatorKey: '__t',\n    shardKey: null,\n    read: null,\n    validateBeforeSave: true,\n    // the following are only applied at construction time\n    _id: true,\n    id: true,\n    typeKey: 'type'\n  }, utils.clone(options));\n\n  if (options.read) {\n    options.read = readPref(options.read);\n  }\n\n  if (options.versionKey && typeof options.versionKey !== 'string') {\n    throw new MongooseError('`versionKey` must be falsy or string, got `' + (typeof options.versionKey) + '`');\n  }\n\n  if (options.optimisticConcurrency && !options.versionKey) {\n    throw new MongooseError('Must set `versionKey` if using `optimisticConcurrency`');\n  }\n\n  return options;\n};\n\n/**\n * Inherit a Schema by applying a discriminator on an existing Schema.\n *\n *\n * #### Example:\n *\n *     const options = { discriminatorKey: 'kind' };\n *\n *     const eventSchema = new mongoose.Schema({ time: Date }, options);\n *     const Event = mongoose.model('Event', eventSchema);\n *\n *     // ClickedLinkEvent is a special type of Event that has\n *     // a URL.\n *     const ClickedLinkEvent = Event.discriminator('ClickedLink',\n *     new mongoose.Schema({ url: String }, options));\n *\n *     // When you create a generic event, it can't have a URL field...\n *     const genericEvent = new Event({ time: Date.now(), url: 'google.com' });\n *     assert.ok(!genericEvent.url);\n *     // But a ClickedLinkEvent can\n *     const clickedEvent = new ClickedLinkEvent({ time: Date.now(), url: 'google.com' });\n *     assert.ok(clickedEvent.url);\n *\n * @param {String} name the name of the discriminator\n * @param {Schema} schema the Schema of the discriminated Schema\n * @return {Schema} the Schema instance\n * @api public\n */\n\nSchema.prototype.discriminator = function(name, schema) {\n  this._applyDiscriminators = Object.assign(this._applyDiscriminators || {}, { [name]: schema });\n\n  return this;\n};\n\n/**\n * Adds key path / schema type pairs to this schema.\n *\n * #### Example:\n *\n *     const ToySchema = new Schema();\n *     ToySchema.add({ name: 'string', color: 'string', price: 'number' });\n *\n *     const TurboManSchema = new Schema();\n *     // You can also `add()` another schema and copy over all paths, virtuals,\n *     // getters, setters, indexes, methods, and statics.\n *     TurboManSchema.add(ToySchema).add({ year: Number });\n *\n * @param {Object|Schema} obj plain object with paths to add, or another schema\n * @param {String} [prefix] path to prefix the newly added paths with\n * @return {Schema} the Schema instance\n * @api public\n */\n\nSchema.prototype.add = function add(obj, prefix) {\n  if (obj instanceof Schema || (obj != null && obj.instanceOfSchema)) {\n    merge(this, obj);\n\n    return this;\n  }\n\n  // Special case: setting top-level `_id` to false should convert to disabling\n  // the `_id` option. This behavior never worked before 5.4.11 but numerous\n  // codebases use it (see gh-7516, gh-7512).\n  if (obj._id === false && prefix == null) {\n    this.options._id = false;\n  }\n\n  prefix = prefix || '';\n  // avoid prototype pollution\n  if (prefix === '__proto__.' || prefix === 'constructor.' || prefix === 'prototype.') {\n    return this;\n  }\n\n  const keys = Object.keys(obj);\n  const typeKey = this.options.typeKey;\n  for (const key of keys) {\n    const fullPath = prefix + key;\n    const val = obj[key];\n\n    if (val == null) {\n      throw new TypeError('Invalid value for schema path `' + fullPath +\n        '`, got value \"' + val + '\"');\n    }\n    // Retain `_id: false` but don't set it as a path, re: gh-8274.\n    if (key === '_id' && val === false) {\n      continue;\n    }\n    if (val instanceof VirtualType || (val.constructor && val.constructor.name || null) === 'VirtualType') {\n      this.virtual(val);\n      continue;\n    }\n\n    if (Array.isArray(val) && val.length === 1 && val[0] == null) {\n      throw new TypeError('Invalid value for schema Array path `' + fullPath +\n        '`, got value \"' + val[0] + '\"');\n    }\n\n    if (!(isPOJO(val) || val instanceof SchemaTypeOptions)) {\n      // Special-case: Non-options definitely a path so leaf at this node\n      // Examples: Schema instances, SchemaType instances\n      if (prefix) {\n        this.nested[prefix.substring(0, prefix.length - 1)] = true;\n      }\n      this.path(prefix + key, val);\n      if (val[0] != null && !(val[0].instanceOfSchema) && utils.isPOJO(val[0].discriminators)) {\n        const schemaType = this.path(prefix + key);\n        for (const key in val[0].discriminators) {\n          schemaType.discriminator(key, val[0].discriminators[key]);\n        }\n      } else if (val[0] != null && val[0].instanceOfSchema && utils.isPOJO(val[0]._applyDiscriminators)) {\n        const applyDiscriminators = val[0]._applyDiscriminators || [];\n        const schemaType = this.path(prefix + key);\n        for (const disc in applyDiscriminators) {\n          schemaType.discriminator(disc, applyDiscriminators[disc]);\n        }\n      }\n      else if (val != null && val.instanceOfSchema && utils.isPOJO(val._applyDiscriminators)) {\n        const applyDiscriminators = val._applyDiscriminators || [];\n        const schemaType = this.path(prefix + key);\n        for (const disc in applyDiscriminators) {\n          schemaType.discriminator(disc, applyDiscriminators[disc]);\n        }\n      }\n    } else if (Object.keys(val).length < 1) {\n      // Special-case: {} always interpreted as Mixed path so leaf at this node\n      if (prefix) {\n        this.nested[prefix.substring(0, prefix.length - 1)] = true;\n      }\n      this.path(fullPath, val); // mixed type\n    } else if (!val[typeKey] || (typeKey === 'type' && isPOJO(val.type) && val.type.type)) {\n      // Special-case: POJO with no bona-fide type key - interpret as tree of deep paths so recurse\n      // nested object `{ last: { name: String } }`. Avoid functions with `.type` re: #10807 because\n      // NestJS sometimes adds `Date.type`.\n      this.nested[fullPath] = true;\n      this.add(val, fullPath + '.');\n    } else {\n      // There IS a bona-fide type key that may also be a POJO\n      const _typeDef = val[typeKey];\n      if (isPOJO(_typeDef) && Object.keys(_typeDef).length > 0) {\n        // If a POJO is the value of a type key, make it a subdocument\n        if (prefix) {\n          this.nested[prefix.substring(0, prefix.length - 1)] = true;\n        }\n        const _schema = new Schema(_typeDef);\n        const schemaWrappedPath = Object.assign({}, val, { type: _schema });\n        this.path(prefix + key, schemaWrappedPath);\n      } else {\n        // Either the type is non-POJO or we interpret it as Mixed anyway\n        if (prefix) {\n          this.nested[prefix.substring(0, prefix.length - 1)] = true;\n        }\n        this.path(prefix + key, val);\n        if (val != null && !(val.instanceOfSchema) && utils.isPOJO(val.discriminators)) {\n          const schemaType = this.path(prefix + key);\n          for (const key in val.discriminators) {\n            schemaType.discriminator(key, val.discriminators[key]);\n          }\n        }\n      }\n    }\n  }\n\n  const addedKeys = Object.keys(obj).\n    map(key => prefix ? prefix + key : key);\n  aliasFields(this, addedKeys);\n  return this;\n};\n\n/**\n * Remove an index by name or index specification.\n *\n * removeIndex only removes indexes from your schema object. Does **not** affect the indexes\n * in MongoDB.\n *\n * #### Example:\n *\n *     const ToySchema = new Schema({ name: String, color: String, price: Number });\n *\n *     // Add a new index on { name, color }\n *     ToySchema.index({ name: 1, color: 1 });\n *\n *     // Remove index on { name, color }\n *     // Keep in mind that order matters! `removeIndex({ color: 1, name: 1 })` won't remove the index\n *     ToySchema.removeIndex({ name: 1, color: 1 });\n *\n *     // Add an index with a custom name\n *     ToySchema.index({ color: 1 }, { name: 'my custom index name' });\n *     // Remove index by name\n *     ToySchema.removeIndex('my custom index name');\n *\n * @param {Object|string} index name or index specification\n * @return {Schema} the Schema instance\n * @api public\n */\n\nSchema.prototype.removeIndex = function removeIndex(index) {\n  if (arguments.length > 1) {\n    throw new Error('removeIndex() takes only 1 argument');\n  }\n\n  if (typeof index !== 'object' && typeof index !== 'string') {\n    throw new Error('removeIndex() may only take either an object or a string as an argument');\n  }\n\n  if (typeof index === 'object') {\n    for (let i = this._indexes.length - 1; i >= 0; --i) {\n      if (util.isDeepStrictEqual(this._indexes[i][0], index)) {\n        this._indexes.splice(i, 1);\n      }\n    }\n  } else {\n    for (let i = this._indexes.length - 1; i >= 0; --i) {\n      if (this._indexes[i][1] != null && this._indexes[i][1].name === index) {\n        this._indexes.splice(i, 1);\n      }\n    }\n  }\n\n  return this;\n};\n\n/**\n * Remove all indexes from this schema.\n *\n * clearIndexes only removes indexes from your schema object. Does **not** affect the indexes\n * in MongoDB.\n *\n * #### Example:\n *\n *     const ToySchema = new Schema({ name: String, color: String, price: Number });\n *     ToySchema.index({ name: 1 });\n *     ToySchema.index({ color: 1 });\n *\n *     // Remove all indexes on this schema\n *     ToySchema.clearIndexes();\n *\n *     ToySchema.indexes(); // []\n *\n * @return {Schema} the Schema instance\n * @api public\n */\n\nSchema.prototype.clearIndexes = function clearIndexes() {\n  this._indexes.length = 0;\n\n  return this;\n};\n\n/**\n * Reserved document keys.\n *\n * Keys in this object are names that are warned in schema declarations\n * because they have the potential to break Mongoose/ Mongoose plugins functionality. If you create a schema\n * using `new Schema()` with one of these property names, Mongoose will log a warning.\n *\n * - _posts\n * - _pres\n * - collection\n  * - emit\n * - errors\n * - get\n * - init\n * - isModified\n * - isNew\n * - listeners\n * - modelName\n * - on\n * - once\n * - populated\n * - prototype\n * - remove\n * - removeListener\n * - save\n * - schema\n * - toObject\n * - validate\n *\n * _NOTE:_ Use of these terms as method names is permitted, but play at your own risk, as they may be existing mongoose document methods you are stomping on.\n *\n *      const schema = new Schema(..);\n *      schema.methods.init = function () {} // potentially breaking\n *\n * @property reserved\n * @memberOf Schema\n * @static\n */\n\nSchema.reserved = Object.create(null);\nSchema.prototype.reserved = Schema.reserved;\n\nconst reserved = Schema.reserved;\n// Core object\nreserved['prototype'] =\n// EventEmitter\nreserved.emit =\nreserved.listeners =\nreserved.removeListener =\n\n// document properties and functions\nreserved.collection =\nreserved.errors =\nreserved.get =\nreserved.init =\nreserved.isModified =\nreserved.isNew =\nreserved.populated =\nreserved.remove =\nreserved.save =\nreserved.toObject =\nreserved.validate = 1;\nreserved.collection = 1;\n\n/**\n * Gets/sets schema paths.\n *\n * Sets a path (if arity 2)\n * Gets a path (if arity 1)\n *\n * #### Example:\n *\n *     schema.path('name') // returns a SchemaType\n *     schema.path('name', Number) // changes the schemaType of `name` to Number\n *\n * @param {String} path The name of the Path to get / set\n * @param {Object} [obj] The Type to set the path to, if provided the path will be SET, otherwise the path will be GET\n * @api public\n */\n\nSchema.prototype.path = function(path, obj) {\n  // Convert to '.$' to check subpaths re: gh-6405\n  const cleanPath = _pathToPositionalSyntax(path);\n  if (obj === undefined) {\n    let schematype = _getPath(this, path, cleanPath);\n    if (schematype != null) {\n      return schematype;\n    }\n\n    // Look for maps\n    const mapPath = getMapPath(this, path);\n    if (mapPath != null) {\n      return mapPath;\n    }\n\n    // Look if a parent of this path is mixed\n    schematype = this.hasMixedParent(cleanPath);\n    if (schematype != null) {\n      return schematype;\n    }\n\n    // subpaths?\n    return /\\.\\d+\\.?.*$/.test(path)\n      ? getPositionalPath(this, path)\n      : undefined;\n  }\n\n  // some path names conflict with document methods\n  const firstPieceOfPath = path.split('.')[0];\n  if (reserved[firstPieceOfPath] && !this.options.supressReservedKeysWarning) {\n    const errorMessage = `\\`${firstPieceOfPath}\\` is a reserved schema pathname and may break some functionality. ` +\n      'You are allowed to use it, but use at your own risk. ' +\n      'To disable this warning pass `supressReservedKeysWarning` as a schema option.';\n\n    utils.warn(errorMessage);\n  }\n\n  if (typeof obj === 'object' && utils.hasUserDefinedProperty(obj, 'ref')) {\n    validateRef(obj.ref, path);\n  }\n\n  // update the tree\n  const subpaths = path.split(/\\./);\n  const last = subpaths.pop();\n  let branch = this.tree;\n  let fullPath = '';\n\n  for (const sub of subpaths) {\n    fullPath = fullPath += (fullPath.length > 0 ? '.' : '') + sub;\n    if (!branch[sub]) {\n      this.nested[fullPath] = true;\n      branch[sub] = {};\n    }\n    if (typeof branch[sub] !== 'object') {\n      const msg = 'Cannot set nested path `' + path + '`. '\n          + 'Parent path `'\n          + fullPath\n          + '` already set to type ' + branch[sub].name\n          + '.';\n      throw new Error(msg);\n    }\n    branch = branch[sub];\n  }\n\n  branch[last] = utils.clone(obj);\n\n  this.paths[path] = this.interpretAsType(path, obj, this.options);\n  const schemaType = this.paths[path];\n\n  if (schemaType.$isSchemaMap) {\n    // Maps can have arbitrary keys, so `$*` is internal shorthand for \"any key\"\n    // The '$' is to imply this path should never be stored in MongoDB so we\n    // can easily build a regexp out of this path, and '*' to imply \"any key.\"\n    const mapPath = path + '.$*';\n\n    this.paths[mapPath] = schemaType.$__schemaType;\n    this.mapPaths.push(this.paths[mapPath]);\n  }\n\n  if (schemaType.$isSingleNested) {\n    for (const key of Object.keys(schemaType.schema.paths)) {\n      this.singleNestedPaths[path + '.' + key] = schemaType.schema.paths[key];\n    }\n    for (const key of Object.keys(schemaType.schema.singleNestedPaths)) {\n      this.singleNestedPaths[path + '.' + key] =\n        schemaType.schema.singleNestedPaths[key];\n    }\n    for (const key of Object.keys(schemaType.schema.subpaths)) {\n      this.singleNestedPaths[path + '.' + key] =\n        schemaType.schema.subpaths[key];\n    }\n    for (const key of Object.keys(schemaType.schema.nested)) {\n      this.singleNestedPaths[path + '.' + key] = 'nested';\n    }\n\n    Object.defineProperty(schemaType.schema, 'base', {\n      configurable: true,\n      enumerable: false,\n      writable: false,\n      value: this.base\n    });\n\n    schemaType.caster.base = this.base;\n    this.childSchemas.push({\n      schema: schemaType.schema,\n      model: schemaType.caster\n    });\n  } else if (schemaType.$isMongooseDocumentArray) {\n    Object.defineProperty(schemaType.schema, 'base', {\n      configurable: true,\n      enumerable: false,\n      writable: false,\n      value: this.base\n    });\n\n    schemaType.casterConstructor.base = this.base;\n    this.childSchemas.push({\n      schema: schemaType.schema,\n      model: schemaType.casterConstructor\n    });\n  }\n\n  if (schemaType.$isMongooseArray && schemaType.caster instanceof SchemaType) {\n    let arrayPath = path;\n    let _schemaType = schemaType;\n\n    const toAdd = [];\n    while (_schemaType.$isMongooseArray) {\n      arrayPath = arrayPath + '.$';\n\n      // Skip arrays of document arrays\n      if (_schemaType.$isMongooseDocumentArray) {\n        _schemaType.$embeddedSchemaType._arrayPath = arrayPath;\n        _schemaType.$embeddedSchemaType._arrayParentPath = path;\n        _schemaType = _schemaType.$embeddedSchemaType.clone();\n      } else {\n        _schemaType.caster._arrayPath = arrayPath;\n        _schemaType.caster._arrayParentPath = path;\n        _schemaType = _schemaType.caster.clone();\n      }\n\n      _schemaType.path = arrayPath;\n      toAdd.push(_schemaType);\n    }\n\n    for (const _schemaType of toAdd) {\n      this.subpaths[_schemaType.path] = _schemaType;\n    }\n  }\n\n  if (schemaType.$isMongooseDocumentArray) {\n    for (const key of Object.keys(schemaType.schema.paths)) {\n      const _schemaType = schemaType.schema.paths[key];\n      this.subpaths[path + '.' + key] = _schemaType;\n      if (typeof _schemaType === 'object' && _schemaType != null) {\n        _schemaType.$isUnderneathDocArray = true;\n      }\n    }\n    for (const key of Object.keys(schemaType.schema.subpaths)) {\n      const _schemaType = schemaType.schema.subpaths[key];\n      this.subpaths[path + '.' + key] = _schemaType;\n      if (typeof _schemaType === 'object' && _schemaType != null) {\n        _schemaType.$isUnderneathDocArray = true;\n      }\n    }\n    for (const key of Object.keys(schemaType.schema.singleNestedPaths)) {\n      const _schemaType = schemaType.schema.singleNestedPaths[key];\n      this.subpaths[path + '.' + key] = _schemaType;\n      if (typeof _schemaType === 'object' && _schemaType != null) {\n        _schemaType.$isUnderneathDocArray = true;\n      }\n    }\n  }\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nfunction gatherChildSchemas(schema) {\n  const childSchemas = [];\n\n  for (const path of Object.keys(schema.paths)) {\n    const schematype = schema.paths[path];\n    if (schematype.$isMongooseDocumentArray || schematype.$isSingleNested) {\n      childSchemas.push({ schema: schematype.schema, model: schematype.caster });\n    }\n  }\n\n  return childSchemas;\n}\n\n/*!\n * ignore\n */\n\nfunction _getPath(schema, path, cleanPath) {\n  if (schema.paths.hasOwnProperty(path)) {\n    return schema.paths[path];\n  }\n  if (schema.subpaths.hasOwnProperty(cleanPath)) {\n    return schema.subpaths[cleanPath];\n  }\n  if (schema.singleNestedPaths.hasOwnProperty(cleanPath) && typeof schema.singleNestedPaths[cleanPath] === 'object') {\n    return schema.singleNestedPaths[cleanPath];\n  }\n\n  return null;\n}\n\n/*!\n * ignore\n */\n\nfunction _pathToPositionalSyntax(path) {\n  if (!/\\.\\d+/.test(path)) {\n    return path;\n  }\n  return path.replace(/\\.\\d+\\./g, '.$.').replace(/\\.\\d+$/, '.$');\n}\n\n/*!\n * ignore\n */\n\nfunction getMapPath(schema, path) {\n  if (schema.mapPaths.length === 0) {\n    return null;\n  }\n  for (const val of schema.mapPaths) {\n    const _path = val.path;\n    const re = new RegExp('^' + _path.replace(/\\.\\$\\*/g, '\\\\.[^.]+') + '$');\n    if (re.test(path)) {\n      return schema.paths[_path];\n    }\n  }\n\n  return null;\n}\n\n/**\n * The Mongoose instance this schema is associated with\n *\n * @property base\n * @api private\n */\n\nObject.defineProperty(Schema.prototype, 'base', {\n  configurable: true,\n  enumerable: false,\n  writable: true,\n  value: null\n});\n\n/**\n * Converts type arguments into Mongoose Types.\n *\n * @param {String} path\n * @param {Object} obj constructor\n * @param {Object} options\n * @api private\n */\n\nSchema.prototype.interpretAsType = function(path, obj, options) {\n  if (obj instanceof SchemaType) {\n    if (obj.path === path) {\n      return obj;\n    }\n    const clone = obj.clone();\n    clone.path = path;\n    return clone;\n  }\n\n  // If this schema has an associated Mongoose object, use the Mongoose object's\n  // copy of SchemaTypes re: gh-7158 gh-6933\n  const MongooseTypes = this.base != null ? this.base.Schema.Types : Schema.Types;\n\n  if (!utils.isPOJO(obj) && !(obj instanceof SchemaTypeOptions)) {\n    const constructorName = utils.getFunctionName(obj.constructor);\n    if (constructorName !== 'Object') {\n      const oldObj = obj;\n      obj = {};\n      obj[options.typeKey] = oldObj;\n    }\n  }\n\n  // Get the type making sure to allow keys named \"type\"\n  // and default to mixed if not specified.\n  // { type: { type: String, default: 'freshcut' } }\n  let type = obj[options.typeKey] && (obj[options.typeKey] instanceof Function || options.typeKey !== 'type' || !obj.type.type)\n    ? obj[options.typeKey]\n    : {};\n  let name;\n\n  if (utils.isPOJO(type) || type === 'mixed') {\n    return new MongooseTypes.Mixed(path, obj);\n  }\n\n  if (Array.isArray(type) || type === Array || type === 'array' || type === MongooseTypes.Array) {\n    // if it was specified through { type } look for `cast`\n    let cast = (type === Array || type === 'array')\n      ? obj.cast || obj.of\n      : type[0];\n\n    // new Schema({ path: [new Schema({ ... })] })\n    if (cast && cast.instanceOfSchema) {\n      if (!(cast instanceof Schema)) {\n        throw new TypeError('Schema for array path `' + path +\n          '` is from a different copy of the Mongoose module. ' +\n          'Please make sure you\\'re using the same version ' +\n          'of Mongoose everywhere with `npm list mongoose`. If you are still ' +\n          'getting this error, please add `new Schema()` around the path: ' +\n          `${path}: new Schema(...)`);\n      }\n      return new MongooseTypes.DocumentArray(path, cast, obj);\n    }\n    if (cast &&\n        cast[options.typeKey] &&\n        cast[options.typeKey].instanceOfSchema) {\n      if (!(cast[options.typeKey] instanceof Schema)) {\n        throw new TypeError('Schema for array path `' + path +\n          '` is from a different copy of the Mongoose module. ' +\n          'Please make sure you\\'re using the same version ' +\n          'of Mongoose everywhere with `npm list mongoose`. If you are still ' +\n          'getting this error, please add `new Schema()` around the path: ' +\n          `${path}: new Schema(...)`);\n      }\n      return new MongooseTypes.DocumentArray(path, cast[options.typeKey], obj, cast);\n    }\n\n    if (Array.isArray(cast)) {\n      return new MongooseTypes.Array(path, this.interpretAsType(path, cast, options), obj);\n    }\n\n    // Handle both `new Schema({ arr: [{ subpath: String }] })` and `new Schema({ arr: [{ type: { subpath: string } }] })`\n    const castFromTypeKey = (cast != null && cast[options.typeKey] && (options.typeKey !== 'type' || !cast.type.type)) ?\n      cast[options.typeKey] :\n      cast;\n    if (typeof cast === 'string') {\n      cast = MongooseTypes[cast.charAt(0).toUpperCase() + cast.substring(1)];\n    } else if (utils.isPOJO(castFromTypeKey)) {\n      if (Object.keys(castFromTypeKey).length) {\n        // The `minimize` and `typeKey` options propagate to child schemas\n        // declared inline, like `{ arr: [{ val: { $type: String } }] }`.\n        // See gh-3560\n        const childSchemaOptions = { minimize: options.minimize };\n        if (options.typeKey) {\n          childSchemaOptions.typeKey = options.typeKey;\n        }\n        // propagate 'strict' option to child schema\n        if (options.hasOwnProperty('strict')) {\n          childSchemaOptions.strict = options.strict;\n        }\n\n        if (this._userProvidedOptions.hasOwnProperty('_id')) {\n          childSchemaOptions._id = this._userProvidedOptions._id;\n        } else if (Schema.Types.DocumentArray.defaultOptions._id != null) {\n          childSchemaOptions._id = Schema.Types.DocumentArray.defaultOptions._id;\n        }\n        const childSchema = new Schema(castFromTypeKey, childSchemaOptions);\n        childSchema.$implicitlyCreated = true;\n        return new MongooseTypes.DocumentArray(path, childSchema, obj);\n      } else {\n        // Special case: empty object becomes mixed\n        return new MongooseTypes.Array(path, MongooseTypes.Mixed, obj);\n      }\n    }\n\n    if (cast) {\n      type = cast[options.typeKey] && (options.typeKey !== 'type' || !cast.type.type)\n        ? cast[options.typeKey]\n        : cast;\n\n      if (Array.isArray(type)) {\n        return new MongooseTypes.Array(path, this.interpretAsType(path, type, options), obj);\n      }\n\n      name = typeof type === 'string'\n        ? type\n        : type.schemaName || utils.getFunctionName(type);\n\n      // For Jest 26+, see #10296\n      if (name === 'ClockDate') {\n        name = 'Date';\n      }\n\n      if (name === void 0) {\n        throw new TypeError('Invalid schema configuration: ' +\n          `Could not determine the embedded type for array \\`${path}\\`. ` +\n          'See https://mongoosejs.com/docs/guide.html#definition for more info on supported schema syntaxes.');\n      }\n      if (!MongooseTypes.hasOwnProperty(name)) {\n        throw new TypeError('Invalid schema configuration: ' +\n          `\\`${name}\\` is not a valid type within the array \\`${path}\\`.` +\n          'See https://bit.ly/mongoose-schematypes for a list of valid schema types.');\n      }\n    }\n\n    return new MongooseTypes.Array(path, cast || MongooseTypes.Mixed, obj, options);\n  }\n\n  if (type && type.instanceOfSchema) {\n\n    return new MongooseTypes.Subdocument(type, path, obj);\n  }\n\n  if (Buffer.isBuffer(type)) {\n    name = 'Buffer';\n  } else if (typeof type === 'function' || typeof type === 'object') {\n    name = type.schemaName || utils.getFunctionName(type);\n  } else {\n    name = type == null ? '' + type : type.toString();\n  }\n\n  if (name) {\n    name = name.charAt(0).toUpperCase() + name.substring(1);\n  }\n  // Special case re: gh-7049 because the bson `ObjectID` class' capitalization\n  // doesn't line up with Mongoose's.\n  if (name === 'ObjectID') {\n    name = 'ObjectId';\n  }\n  // For Jest 26+, see #10296\n  if (name === 'ClockDate') {\n    name = 'Date';\n  }\n\n  if (name === void 0) {\n    throw new TypeError(`Invalid schema configuration: \\`${path}\\` schematype definition is ` +\n      'invalid. See ' +\n      'https://mongoosejs.com/docs/guide.html#definition for more info on supported schema syntaxes.');\n  }\n  if (MongooseTypes[name] == null) {\n    throw new TypeError(`Invalid schema configuration: \\`${name}\\` is not ` +\n      `a valid type at path \\`${path}\\`. See ` +\n      'https://bit.ly/mongoose-schematypes for a list of valid schema types.');\n  }\n\n  const schemaType = new MongooseTypes[name](path, obj);\n\n  if (schemaType.$isSchemaMap) {\n    createMapNestedSchemaType(this, schemaType, path, obj, options);\n  }\n\n  return schemaType;\n};\n\n/*!\n * ignore\n */\n\nfunction createMapNestedSchemaType(schema, schemaType, path, obj, options) {\n  const mapPath = path + '.$*';\n  let _mapType = { type: {} };\n  if (utils.hasUserDefinedProperty(obj, 'of')) {\n    const isInlineSchema = utils.isPOJO(obj.of) &&\n      Object.keys(obj.of).length > 0 &&\n      !utils.hasUserDefinedProperty(obj.of, schema.options.typeKey);\n    if (isInlineSchema) {\n      _mapType = { [schema.options.typeKey]: new Schema(obj.of) };\n    } else if (utils.isPOJO(obj.of)) {\n      _mapType = Object.assign({}, obj.of);\n    } else {\n      _mapType = { [schema.options.typeKey]: obj.of };\n    }\n\n    if (_mapType[schema.options.typeKey] && _mapType[schema.options.typeKey].instanceOfSchema) {\n      const subdocumentSchema = _mapType[schema.options.typeKey];\n      subdocumentSchema.eachPath((subpath, type) => {\n        if (type.options.select === true || type.options.select === false) {\n          throw new MongooseError('Cannot use schema-level projections (`select: true` or `select: false`) within maps at path \"' + path + '.' + subpath + '\"');\n        }\n      });\n    }\n\n    if (utils.hasUserDefinedProperty(obj, 'ref')) {\n      _mapType.ref = obj.ref;\n    }\n  }\n  schemaType.$__schemaType = schema.interpretAsType(mapPath, _mapType, options);\n}\n\n/**\n * Iterates the schemas paths similar to Array#forEach.\n *\n * The callback is passed the pathname and the schemaType instance.\n *\n * #### Example:\n *\n *     const userSchema = new Schema({ name: String, registeredAt: Date });\n *     userSchema.eachPath((pathname, schematype) => {\n *       // Prints twice:\n *       // name SchemaString { ... }\n *       // registeredAt SchemaDate { ... }\n *       console.log(pathname, schematype);\n *     });\n *\n * @param {Function} fn callback function\n * @return {Schema} this\n * @api public\n */\n\nSchema.prototype.eachPath = function(fn) {\n  const keys = Object.keys(this.paths);\n  const len = keys.length;\n\n  for (let i = 0; i < len; ++i) {\n    fn(keys[i], this.paths[keys[i]]);\n  }\n\n  return this;\n};\n\n/**\n * Returns an Array of path strings that are required by this schema.\n *\n * #### Example:\n *\n *     const s = new Schema({\n *       name: { type: String, required: true },\n *       age: { type: String, required: true },\n *       notes: String\n *     });\n *     s.requiredPaths(); // [ 'age', 'name' ]\n *\n * @api public\n * @param {Boolean} invalidate Refresh the cache\n * @return {Array}\n */\n\nSchema.prototype.requiredPaths = function requiredPaths(invalidate) {\n  if (this._requiredpaths && !invalidate) {\n    return this._requiredpaths;\n  }\n\n  const paths = Object.keys(this.paths);\n  let i = paths.length;\n  const ret = [];\n\n  while (i--) {\n    const path = paths[i];\n    if (this.paths[path].isRequired) {\n      ret.push(path);\n    }\n  }\n  this._requiredpaths = ret;\n  return this._requiredpaths;\n};\n\n/**\n * Returns indexes from fields and schema-level indexes (cached).\n *\n * @api private\n * @return {Array}\n */\n\nSchema.prototype.indexedPaths = function indexedPaths() {\n  if (this._indexedpaths) {\n    return this._indexedpaths;\n  }\n  this._indexedpaths = this.indexes();\n  return this._indexedpaths;\n};\n\n/**\n * Returns the pathType of `path` for this schema.\n *\n * Given a path, returns whether it is a real, virtual, nested, or ad-hoc/undefined path.\n *\n * #### Example:\n *     const s = new Schema({ name: String, nested: { foo: String } });\n *     s.virtual('foo').get(() => 42);\n *     s.pathType('name'); // \"real\"\n *     s.pathType('nested'); // \"nested\"\n *     s.pathType('foo'); // \"virtual\"\n *     s.pathType('fail'); // \"adhocOrUndefined\"\n *\n * @param {String} path\n * @return {String}\n * @api public\n */\n\nSchema.prototype.pathType = function(path) {\n  // Convert to '.$' to check subpaths re: gh-6405\n  const cleanPath = _pathToPositionalSyntax(path);\n\n  if (this.paths.hasOwnProperty(path)) {\n    return 'real';\n  }\n  if (this.virtuals.hasOwnProperty(path)) {\n    return 'virtual';\n  }\n  if (this.nested.hasOwnProperty(path)) {\n    return 'nested';\n  }\n  if (this.subpaths.hasOwnProperty(cleanPath) || this.subpaths.hasOwnProperty(path)) {\n    return 'real';\n  }\n\n  const singleNestedPath = this.singleNestedPaths.hasOwnProperty(cleanPath) || this.singleNestedPaths.hasOwnProperty(path);\n  if (singleNestedPath) {\n    return singleNestedPath === 'nested' ? 'nested' : 'real';\n  }\n\n  // Look for maps\n  const mapPath = getMapPath(this, path);\n  if (mapPath != null) {\n    return 'real';\n  }\n\n  if (/\\.\\d+\\.|\\.\\d+$/.test(path)) {\n    return getPositionalPathType(this, path);\n  }\n  return 'adhocOrUndefined';\n};\n\n/**\n * Returns true iff this path is a child of a mixed schema.\n *\n * @param {String} path\n * @return {Boolean}\n * @api private\n */\n\nSchema.prototype.hasMixedParent = function(path) {\n  const subpaths = path.split(/\\./g);\n  path = '';\n  for (let i = 0; i < subpaths.length; ++i) {\n    path = i > 0 ? path + '.' + subpaths[i] : subpaths[i];\n    if (this.paths.hasOwnProperty(path) &&\n        this.paths[path] instanceof MongooseTypes.Mixed) {\n      return this.paths[path];\n    }\n  }\n\n  return null;\n};\n\n/**\n * Setup updatedAt and createdAt timestamps to documents if enabled\n *\n * @param {Boolean|Object} timestamps timestamps options\n * @api private\n */\nSchema.prototype.setupTimestamp = function(timestamps) {\n  return setupTimestamps(this, timestamps);\n};\n\n/*!\n * ignore. Deprecated re: #6405\n */\n\nfunction getPositionalPathType(self, path) {\n  const subpaths = path.split(/\\.(\\d+)\\.|\\.(\\d+)$/).filter(Boolean);\n  if (subpaths.length < 2) {\n    return self.paths.hasOwnProperty(subpaths[0]) ?\n      self.paths[subpaths[0]] :\n      'adhocOrUndefined';\n  }\n\n  let val = self.path(subpaths[0]);\n  let isNested = false;\n  if (!val) {\n    return 'adhocOrUndefined';\n  }\n\n  const last = subpaths.length - 1;\n\n  for (let i = 1; i < subpaths.length; ++i) {\n    isNested = false;\n    const subpath = subpaths[i];\n\n    if (i === last && val && !/\\D/.test(subpath)) {\n      if (val.$isMongooseDocumentArray) {\n        val = val.$embeddedSchemaType;\n      } else if (val instanceof MongooseTypes.Array) {\n        // StringSchema, NumberSchema, etc\n        val = val.caster;\n      } else {\n        val = undefined;\n      }\n      break;\n    }\n\n    // ignore if its just a position segment: path.0.subpath\n    if (!/\\D/.test(subpath)) {\n      // Nested array\n      if (val instanceof MongooseTypes.Array && i !== last) {\n        val = val.caster;\n      }\n      continue;\n    }\n\n    if (!(val && val.schema)) {\n      val = undefined;\n      break;\n    }\n\n    const type = val.schema.pathType(subpath);\n    isNested = (type === 'nested');\n    val = val.schema.path(subpath);\n  }\n\n  self.subpaths[path] = val;\n  if (val) {\n    return 'real';\n  }\n  if (isNested) {\n    return 'nested';\n  }\n  return 'adhocOrUndefined';\n}\n\n\n/*!\n * ignore\n */\n\nfunction getPositionalPath(self, path) {\n  getPositionalPathType(self, path);\n  return self.subpaths[path];\n}\n\n/**\n * Adds a method call to the queue.\n *\n * #### Example:\n *\n *     schema.methods.print = function() { console.log(this); };\n *     schema.queue('print', []); // Print the doc every one is instantiated\n *\n *     const Model = mongoose.model('Test', schema);\n *     new Model({ name: 'test' }); // Prints '{\"_id\": ..., \"name\": \"test\" }'\n *\n * @param {String} name name of the document method to call later\n * @param {Array} args arguments to pass to the method\n * @api public\n */\n\nSchema.prototype.queue = function(name, args) {\n  this.callQueue.push([name, args]);\n  return this;\n};\n\n/**\n * Defines a pre hook for the model.\n *\n * #### Example:\n *\n *     const toySchema = new Schema({ name: String, created: Date });\n *\n *     toySchema.pre('save', function(next) {\n *       if (!this.created) this.created = new Date;\n *       next();\n *     });\n *\n *     toySchema.pre('validate', function(next) {\n *       if (this.name !== 'Woody') this.name = 'Woody';\n *       next();\n *     });\n *\n *     // Equivalent to calling `pre()` on `find`, `findOne`, `findOneAndUpdate`.\n *     toySchema.pre(/^find/, function(next) {\n *       console.log(this.getFilter());\n *     });\n *\n *     // Equivalent to calling `pre()` on `updateOne`, `findOneAndUpdate`.\n *     toySchema.pre(['updateOne', 'findOneAndUpdate'], function(next) {\n *       console.log(this.getFilter());\n *     });\n *\n *     toySchema.pre('deleteOne', function() {\n *       // Runs when you call `Toy.deleteOne()`\n *     });\n *\n *     toySchema.pre('deleteOne', { document: true }, function() {\n *       // Runs when you call `doc.deleteOne()`\n *     });\n *\n * @param {String|RegExp|String[]} methodName The method name or regular expression to match method name\n * @param {Object} [options]\n * @param {Boolean} [options.document] If `name` is a hook for both document and query middleware, set to `true` to run on document middleware. For example, set `options.document` to `true` to apply this hook to `Document#deleteOne()` rather than `Query#deleteOne()`.\n * @param {Boolean} [options.query] If `name` is a hook for both document and query middleware, set to `true` to run on query middleware.\n * @param {Function} callback\n * @api public\n */\n\nSchema.prototype.pre = function(name) {\n  if (name instanceof RegExp) {\n    const remainingArgs = Array.prototype.slice.call(arguments, 1);\n    for (const fn of hookNames) {\n      if (name.test(fn)) {\n        this.pre.apply(this, [fn].concat(remainingArgs));\n      }\n    }\n    return this;\n  }\n  if (Array.isArray(name)) {\n    const remainingArgs = Array.prototype.slice.call(arguments, 1);\n    for (const el of name) {\n      this.pre.apply(this, [el].concat(remainingArgs));\n    }\n    return this;\n  }\n  this.s.hooks.pre.apply(this.s.hooks, arguments);\n  return this;\n};\n\n/**\n * Defines a post hook for the document\n *\n *     const schema = new Schema(..);\n *     schema.post('save', function (doc) {\n *       console.log('this fired after a document was saved');\n *     });\n *\n *     schema.post('find', function(docs) {\n *       console.log('this fired after you ran a find query');\n *     });\n *\n *     schema.post(/Many$/, function(res) {\n *       console.log('this fired after you ran `updateMany()` or `deleteMany()`');\n *     });\n *\n *     const Model = mongoose.model('Model', schema);\n *\n *     const m = new Model(..);\n *     m.save(function(err) {\n *       console.log('this fires after the `post` hook');\n *     });\n *\n *     m.find(function(err, docs) {\n *       console.log('this fires after the post find hook');\n *     });\n *\n * @param {String|RegExp|String[]} methodName The method name or regular expression to match method name\n * @param {Object} [options]\n * @param {Boolean} [options.document] If `name` is a hook for both document and query middleware, set to `true` to run on document middleware.\n * @param {Boolean} [options.query] If `name` is a hook for both document and query middleware, set to `true` to run on query middleware.\n * @param {Function} fn callback\n * @see middleware https://mongoosejs.com/docs/middleware.html\n * @see kareem https://npmjs.org/package/kareem\n * @api public\n */\n\nSchema.prototype.post = function(name) {\n  if (name instanceof RegExp) {\n    const remainingArgs = Array.prototype.slice.call(arguments, 1);\n    for (const fn of hookNames) {\n      if (name.test(fn)) {\n        this.post.apply(this, [fn].concat(remainingArgs));\n      }\n    }\n    return this;\n  }\n  if (Array.isArray(name)) {\n    const remainingArgs = Array.prototype.slice.call(arguments, 1);\n    for (const el of name) {\n      this.post.apply(this, [el].concat(remainingArgs));\n    }\n    return this;\n  }\n  this.s.hooks.post.apply(this.s.hooks, arguments);\n  return this;\n};\n\n/**\n * Registers a plugin for this schema.\n *\n * #### Example:\n *\n *     const s = new Schema({ name: String });\n *     s.plugin(schema => console.log(schema.path('name').path));\n *     mongoose.model('Test', s); // Prints 'name'\n *\n * Or with Options:\n *\n *     const s = new Schema({ name: String });\n *     s.plugin((schema, opts) => console.log(opts.text, schema.path('name').path), { text: \"Schema Path Name:\" });\n *     mongoose.model('Test', s); // Prints 'Schema Path Name: name'\n *\n * @param {Function} plugin The Plugin's callback\n * @param {Object} [opts] Options to pass to the plugin\n * @see plugins\n * @api public\n */\n\nSchema.prototype.plugin = function(fn, opts) {\n  if (typeof fn !== 'function') {\n    throw new Error('First param to `schema.plugin()` must be a function, ' +\n      'got \"' + (typeof fn) + '\"');\n  }\n\n  if (opts && opts.deduplicate) {\n    for (const plugin of this.plugins) {\n      if (plugin.fn === fn) {\n        return this;\n      }\n    }\n  }\n  this.plugins.push({ fn: fn, opts: opts });\n\n  fn(this, opts);\n  return this;\n};\n\n/**\n * Adds an instance method to documents constructed from Models compiled from this schema.\n *\n * #### Example:\n *\n *     const schema = kittySchema = new Schema(..);\n *\n *     schema.method('meow', function () {\n *       console.log('meeeeeoooooooooooow');\n *     })\n *\n *     const Kitty = mongoose.model('Kitty', schema);\n *\n *     const fizz = new Kitty;\n *     fizz.meow(); // meeeeeooooooooooooow\n *\n * If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as methods.\n *\n *     schema.method({\n *         purr: function () {}\n *       , scratch: function () {}\n *     });\n *\n *     // later\n *     const fizz = new Kitty;\n *     fizz.purr();\n *     fizz.scratch();\n *\n * NOTE: `Schema.method()` adds instance methods to the `Schema.methods` object. You can also add instance methods directly to the `Schema.methods` object as seen in the [guide](/docs/guide.html#methods)\n *\n * @param {String|Object} name The Method Name for a single function, or a Object of \"string-function\" pairs.\n * @param {Function} [fn] The Function in a single-function definition.\n * @api public\n */\n\nSchema.prototype.method = function(name, fn, options) {\n  if (typeof name !== 'string') {\n    for (const i in name) {\n      this.methods[i] = name[i];\n      this.methodOptions[i] = utils.clone(options);\n    }\n  } else {\n    this.methods[name] = fn;\n    this.methodOptions[name] = utils.clone(options);\n  }\n  return this;\n};\n\n/**\n * Adds static \"class\" methods to Models compiled from this schema.\n *\n * #### Example:\n *\n *     const schema = new Schema(..);\n *     // Equivalent to `schema.statics.findByName = function(name) {}`;\n *     schema.static('findByName', function(name) {\n *       return this.find({ name: name });\n *     });\n *\n *     const Drink = mongoose.model('Drink', schema);\n *     await Drink.findByName('LaCroix');\n *\n * If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as methods.\n *\n *     schema.static({\n *         findByName: function () {..}\n *       , findByCost: function () {..}\n *     });\n *\n *     const Drink = mongoose.model('Drink', schema);\n *     await Drink.findByName('LaCroix');\n *     await Drink.findByCost(3);\n *\n * If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as statics.\n *\n * @param {String|Object} name The Method Name for a single function, or a Object of \"string-function\" pairs.\n * @param {Function} [fn] The Function in a single-function definition.\n * @api public\n * @see Statics /docs/guide.html#statics\n */\n\nSchema.prototype.static = function(name, fn) {\n  if (typeof name !== 'string') {\n    for (const i in name) {\n      this.statics[i] = name[i];\n    }\n  } else {\n    this.statics[name] = fn;\n  }\n  return this;\n};\n\n/**\n * Defines an index (most likely compound) for this schema.\n *\n * #### Example:\n *\n *     schema.index({ first: 1, last: -1 })\n *\n * @param {Object} fields The Fields to index, with the order, available values: `1 | -1 | '2d' | '2dsphere' | 'geoHaystack' | 'hashed' | 'text'`\n * @param {Object} [options] Options to pass to [MongoDB driver's `createIndex()` function](https://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#createIndex)\n * @param {String | number} [options.expires=null] Mongoose-specific syntactic sugar, uses [ms](https://www.npmjs.com/package/ms) to convert `expires` option into seconds for the `expireAfterSeconds` in the above link.\n * @api public\n */\n\nSchema.prototype.index = function(fields, options) {\n  fields || (fields = {});\n  options || (options = {});\n\n  if (options.expires) {\n    utils.expires(options);\n  }\n\n  this._indexes.push([fields, options]);\n  return this;\n};\n\n/**\n * Sets a schema option.\n *\n * #### Example:\n *\n *     schema.set('strict'); // 'true' by default\n *     schema.set('strict', false); // Sets 'strict' to false\n *     schema.set('strict'); // 'false'\n *\n * @param {String} key The name of the option to set the value to\n * @param {Object} [value] The value to set the option to, if not passed, the option will be reset to default\n * @see Schema ./\n * @api public\n */\n\nSchema.prototype.set = function(key, value, _tags) {\n  if (arguments.length === 1) {\n    return this.options[key];\n  }\n\n  switch (key) {\n    case 'read':\n      this.options[key] = readPref(value, _tags);\n      this._userProvidedOptions[key] = this.options[key];\n      break;\n    case 'timestamps':\n      this.setupTimestamp(value);\n      this.options[key] = value;\n      this._userProvidedOptions[key] = this.options[key];\n      break;\n    case '_id':\n      this.options[key] = value;\n      this._userProvidedOptions[key] = this.options[key];\n\n      if (value && !this.paths['_id']) {\n        addAutoId(this);\n      } else if (!value && this.paths['_id'] != null && this.paths['_id'].auto) {\n        this.remove('_id');\n      }\n      break;\n    default:\n      this.options[key] = value;\n      this._userProvidedOptions[key] = this.options[key];\n      break;\n  }\n\n  return this;\n};\n\n/**\n * Gets a schema option.\n *\n * #### Example:\n *\n *     schema.get('strict'); // true\n *     schema.set('strict', false);\n *     schema.get('strict'); // false\n *\n * @param {String} key The name of the Option to get the current value for\n * @api public\n * @return {Any} the option's value\n */\n\nSchema.prototype.get = function(key) {\n  return this.options[key];\n};\n\nconst indexTypes = '2d 2dsphere hashed text'.split(' ');\n\n/**\n * The allowed index types\n *\n * @property {String[]} indexTypes\n * @memberOf Schema\n * @static\n * @api public\n */\n\nObject.defineProperty(Schema, 'indexTypes', {\n  get: function() {\n    return indexTypes;\n  },\n  set: function() {\n    throw new Error('Cannot overwrite Schema.indexTypes');\n  }\n});\n\n/**\n * Returns a list of indexes that this schema declares, via `schema.index()` or by `index: true` in a path's options.\n * Indexes are expressed as an array `[spec, options]`.\n *\n * #### Example:\n *\n *     const userSchema = new Schema({\n *       email: { type: String, required: true, unique: true },\n *       registeredAt: { type: Date, index: true }\n *     });\n *\n *     // [ [ { email: 1 }, { unique: true, background: true } ],\n *     //   [ { registeredAt: 1 }, { background: true } ] ]\n *     userSchema.indexes();\n *\n * [Plugins](/docs/plugins.html) can use the return value of this function to modify a schema's indexes.\n * For example, the below plugin makes every index unique by default.\n *\n *     function myPlugin(schema) {\n *       for (const index of schema.indexes()) {\n *         if (index[1].unique === undefined) {\n *           index[1].unique = true;\n *         }\n *       }\n *     }\n *\n * @api public\n * @return {Array} list of indexes defined in the schema\n */\n\nSchema.prototype.indexes = function() {\n  return getIndexes(this);\n};\n\n/**\n * Creates a virtual type with the given name.\n *\n * @param {String} name The name of the Virtual\n * @param {Object} [options]\n * @param {String|Model} [options.ref] model name or model instance. Marks this as a [populate virtual](/docs/populate.html#populate-virtuals).\n * @param {String|Function} [options.localField] Required for populate virtuals. See [populate virtual docs](/docs/populate.html#populate-virtuals) for more information.\n * @param {String|Function} [options.foreignField] Required for populate virtuals. See [populate virtual docs](/docs/populate.html#populate-virtuals) for more information.\n * @param {Boolean|Function} [options.justOne=false] Only works with populate virtuals. If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), will be a single doc or `null`. Otherwise, the populate virtual will be an array.\n * @param {Boolean} [options.count=false] Only works with populate virtuals. If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), this populate virtual will contain the number of documents rather than the documents themselves when you `populate()`.\n * @param {Function|null} [options.get=null] Adds a [getter](/docs/tutorials/getters-setters.html) to this virtual to transform the populated doc.\n * @return {VirtualType}\n */\n\nSchema.prototype.virtual = function(name, options) {\n  if (name instanceof VirtualType || getConstructorName(name) === 'VirtualType') {\n    return this.virtual(name.path, name.options);\n  }\n\n  options = new VirtualOptions(options);\n\n  if (utils.hasUserDefinedProperty(options, ['ref', 'refPath'])) {\n    if (options.localField == null) {\n      throw new Error('Reference virtuals require `localField` option');\n    }\n\n    if (options.foreignField == null) {\n      throw new Error('Reference virtuals require `foreignField` option');\n    }\n\n    this.pre('init', function(obj) {\n      if (mpath.has(name, obj)) {\n        const _v = mpath.get(name, obj);\n        if (!this.$$populatedVirtuals) {\n          this.$$populatedVirtuals = {};\n        }\n\n        if (options.justOne || options.count) {\n          this.$$populatedVirtuals[name] = Array.isArray(_v) ?\n            _v[0] :\n            _v;\n        } else {\n          this.$$populatedVirtuals[name] = Array.isArray(_v) ?\n            _v :\n            _v == null ? [] : [_v];\n        }\n\n        mpath.unset(name, obj);\n      }\n    });\n\n    const virtual = this.virtual(name);\n    virtual.options = options;\n\n    virtual.\n      set(function(_v) {\n        if (!this.$$populatedVirtuals) {\n          this.$$populatedVirtuals = {};\n        }\n\n        if (options.justOne || options.count) {\n          this.$$populatedVirtuals[name] = Array.isArray(_v) ?\n            _v[0] :\n            _v;\n\n          if (typeof this.$$populatedVirtuals[name] !== 'object') {\n            this.$$populatedVirtuals[name] = options.count ? _v : null;\n          }\n        } else {\n          this.$$populatedVirtuals[name] = Array.isArray(_v) ?\n            _v :\n            _v == null ? [] : [_v];\n\n          this.$$populatedVirtuals[name] = this.$$populatedVirtuals[name].filter(function(doc) {\n            return doc && typeof doc === 'object';\n          });\n        }\n      });\n\n    if (typeof options.get === 'function') {\n      virtual.get(options.get);\n    }\n\n    // Workaround for gh-8198: if virtual is under document array, make a fake\n    // virtual. See gh-8210\n    const parts = name.split('.');\n    let cur = parts[0];\n    for (let i = 0; i < parts.length - 1; ++i) {\n      if (this.paths[cur] != null && this.paths[cur].$isMongooseDocumentArray) {\n        const remnant = parts.slice(i + 1).join('.');\n        this.paths[cur].schema.virtual(remnant, options);\n        break;\n      }\n\n      cur += '.' + parts[i + 1];\n    }\n\n    return virtual;\n  }\n\n  const virtuals = this.virtuals;\n  const parts = name.split('.');\n\n  if (this.pathType(name) === 'real') {\n    throw new Error('Virtual path \"' + name + '\"' +\n      ' conflicts with a real path in the schema');\n  }\n\n  virtuals[name] = parts.reduce(function(mem, part, i) {\n    mem[part] || (mem[part] = (i === parts.length - 1)\n      ? new VirtualType(options, name)\n      : {});\n    return mem[part];\n  }, this.tree);\n\n  return virtuals[name];\n};\n\n/**\n * Returns the virtual type with the given `name`.\n *\n * @param {String} name The name of the Virtual to get\n * @return {VirtualType|null}\n */\n\nSchema.prototype.virtualpath = function(name) {\n  return this.virtuals.hasOwnProperty(name) ? this.virtuals[name] : null;\n};\n\n/**\n * Removes the given `path` (or [`paths`]).\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: String, age: Number });\n *     schema.remove('name');\n *     schema.path('name'); // Undefined\n *     schema.path('age'); // SchemaNumber { ... }\n *\n * Or as a Array:\n *\n *     schema.remove(['name', 'age']);\n *     schema.path('name'); // Undefined\n *     schema.path('age'); // Undefined\n *\n * @param {String|Array} path The Path(s) to remove\n * @return {Schema} the Schema instance\n * @api public\n */\nSchema.prototype.remove = function(path) {\n  if (typeof path === 'string') {\n    path = [path];\n  }\n  if (Array.isArray(path)) {\n    path.forEach(function(name) {\n      if (this.path(name) == null && !this.nested[name]) {\n        return;\n      }\n      if (this.nested[name]) {\n        const allKeys = Object.keys(this.paths).\n          concat(Object.keys(this.nested));\n        for (const path of allKeys) {\n          if (path.startsWith(name + '.')) {\n            delete this.paths[path];\n            delete this.nested[path];\n            _deletePath(this, path);\n          }\n        }\n\n        delete this.nested[name];\n        _deletePath(this, name);\n        return;\n      }\n\n      delete this.paths[name];\n      _deletePath(this, name);\n    }, this);\n  }\n  return this;\n};\n\n/*!\n * ignore\n */\n\nfunction _deletePath(schema, name) {\n  const pieces = name.split('.');\n  const last = pieces.pop();\n\n  let branch = schema.tree;\n\n  for (const piece of pieces) {\n    branch = branch[piece];\n  }\n\n  delete branch[last];\n}\n\n/**\n * Loads an ES6 class into a schema. Maps [setters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set) + [getters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get), [static methods](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/static),\n * and [instance methods](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#Class_body_and_method_definitions)\n * to schema [virtuals](/docs/guide.html#virtuals),\n * [statics](/docs/guide.html#statics), and\n * [methods](/docs/guide.html#methods).\n *\n * #### Example:\n *\n * ```javascript\n * const md5 = require('md5');\n * const userSchema = new Schema({ email: String });\n * class UserClass {\n *   // `gravatarImage` becomes a virtual\n *   get gravatarImage() {\n *     const hash = md5(this.email.toLowerCase());\n *     return `https://www.gravatar.com/avatar/${hash}`;\n *   }\n *\n *   // `getProfileUrl()` becomes a document method\n *   getProfileUrl() {\n *     return `https://mysite.com/${this.email}`;\n *   }\n *\n *   // `findByEmail()` becomes a static\n *   static findByEmail(email) {\n *     return this.findOne({ email });\n *   }\n * }\n *\n * // `schema` will now have a `gravatarImage` virtual, a `getProfileUrl()` method,\n * // and a `findByEmail()` static\n * userSchema.loadClass(UserClass);\n * ```\n *\n * @param {Function} model The Class to load\n * @param {Boolean} [virtualsOnly] if truthy, only pulls virtuals from the class, not methods or statics\n */\nSchema.prototype.loadClass = function(model, virtualsOnly) {\n  if (model === Object.prototype ||\n      model === Function.prototype ||\n      model.prototype.hasOwnProperty('$isMongooseModelPrototype')) {\n    return this;\n  }\n\n  this.loadClass(Object.getPrototypeOf(model), virtualsOnly);\n\n  // Add static methods\n  if (!virtualsOnly) {\n    Object.getOwnPropertyNames(model).forEach(function(name) {\n      if (name.match(/^(length|name|prototype|constructor|__proto__)$/)) {\n        return;\n      }\n      const prop = Object.getOwnPropertyDescriptor(model, name);\n      if (prop.hasOwnProperty('value')) {\n        this.static(name, prop.value);\n      }\n    }, this);\n  }\n\n  // Add methods and virtuals\n  Object.getOwnPropertyNames(model.prototype).forEach(function(name) {\n    if (name.match(/^(constructor)$/)) {\n      return;\n    }\n    const method = Object.getOwnPropertyDescriptor(model.prototype, name);\n    if (!virtualsOnly) {\n      if (typeof method.value === 'function') {\n        this.method(name, method.value);\n      }\n    }\n    if (typeof method.get === 'function') {\n      if (this.virtuals[name]) {\n        this.virtuals[name].getters = [];\n      }\n      this.virtual(name).get(method.get);\n    }\n    if (typeof method.set === 'function') {\n      if (this.virtuals[name]) {\n        this.virtuals[name].setters = [];\n      }\n      this.virtual(name).set(method.set);\n    }\n  }, this);\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nSchema.prototype._getSchema = function(path) {\n  const _this = this;\n  const pathschema = _this.path(path);\n  const resultPath = [];\n\n  if (pathschema) {\n    pathschema.$fullPath = path;\n    return pathschema;\n  }\n\n  function search(parts, schema) {\n    let p = parts.length + 1;\n    let foundschema;\n    let trypath;\n\n    while (p--) {\n      trypath = parts.slice(0, p).join('.');\n      foundschema = schema.path(trypath);\n      if (foundschema) {\n        resultPath.push(trypath);\n\n        if (foundschema.caster) {\n          // array of Mixed?\n          if (foundschema.caster instanceof MongooseTypes.Mixed) {\n            foundschema.caster.$fullPath = resultPath.join('.');\n            return foundschema.caster;\n          }\n\n          // Now that we found the array, we need to check if there\n          // are remaining document paths to look up for casting.\n          // Also we need to handle array.$.path since schema.path\n          // doesn't work for that.\n          // If there is no foundschema.schema we are dealing with\n          // a path like array.$\n          if (p !== parts.length) {\n            if (foundschema.schema) {\n              let ret;\n              if (parts[p] === '$' || isArrayFilter(parts[p])) {\n                if (p + 1 === parts.length) {\n                  // comments.$\n                  return foundschema;\n                }\n                // comments.$.comments.$.title\n                ret = search(parts.slice(p + 1), foundschema.schema);\n                if (ret) {\n                  ret.$isUnderneathDocArray = ret.$isUnderneathDocArray ||\n                    !foundschema.schema.$isSingleNested;\n                }\n                return ret;\n              }\n              // this is the last path of the selector\n              ret = search(parts.slice(p), foundschema.schema);\n              if (ret) {\n                ret.$isUnderneathDocArray = ret.$isUnderneathDocArray ||\n                  !foundschema.schema.$isSingleNested;\n              }\n              return ret;\n            }\n          }\n        } else if (foundschema.$isSchemaMap) {\n          if (p >= parts.length) {\n            return foundschema;\n          }\n          // Any path in the map will be an instance of the map's embedded schematype\n          if (p + 1 >= parts.length) {\n            return foundschema.$__schemaType;\n          }\n          const ret = search(parts.slice(p + 1), foundschema.$__schemaType.schema);\n          return ret;\n        }\n\n        foundschema.$fullPath = resultPath.join('.');\n\n        return foundschema;\n      }\n    }\n  }\n\n  // look for arrays\n  const parts = path.split('.');\n  for (let i = 0; i < parts.length; ++i) {\n    if (parts[i] === '$' || isArrayFilter(parts[i])) {\n      // Re: gh-5628, because `schema.path()` doesn't take $ into account.\n      parts[i] = '0';\n    }\n  }\n  return search(parts, _this);\n};\n\n/*!\n * ignore\n */\n\nSchema.prototype._getPathType = function(path) {\n  const _this = this;\n  const pathschema = _this.path(path);\n\n  if (pathschema) {\n    return 'real';\n  }\n\n  function search(parts, schema) {\n    let p = parts.length + 1,\n        foundschema,\n        trypath;\n\n    while (p--) {\n      trypath = parts.slice(0, p).join('.');\n      foundschema = schema.path(trypath);\n      if (foundschema) {\n        if (foundschema.caster) {\n          // array of Mixed?\n          if (foundschema.caster instanceof MongooseTypes.Mixed) {\n            return { schema: foundschema, pathType: 'mixed' };\n          }\n\n          // Now that we found the array, we need to check if there\n          // are remaining document paths to look up for casting.\n          // Also we need to handle array.$.path since schema.path\n          // doesn't work for that.\n          // If there is no foundschema.schema we are dealing with\n          // a path like array.$\n          if (p !== parts.length && foundschema.schema) {\n            if (parts[p] === '$' || isArrayFilter(parts[p])) {\n              if (p === parts.length - 1) {\n                return { schema: foundschema, pathType: 'nested' };\n              }\n              // comments.$.comments.$.title\n              return search(parts.slice(p + 1), foundschema.schema);\n            }\n            // this is the last path of the selector\n            return search(parts.slice(p), foundschema.schema);\n          }\n          return {\n            schema: foundschema,\n            pathType: foundschema.$isSingleNested ? 'nested' : 'array'\n          };\n        }\n        return { schema: foundschema, pathType: 'real' };\n      } else if (p === parts.length && schema.nested[trypath]) {\n        return { schema: schema, pathType: 'nested' };\n      }\n    }\n    return { schema: foundschema || schema, pathType: 'undefined' };\n  }\n\n  // look for arrays\n  return search(path.split('.'), _this);\n};\n\n/*!\n * ignore\n */\n\nfunction isArrayFilter(piece) {\n  return piece.startsWith('$[') && piece.endsWith(']');\n}\n\n/*!\n * Called by `compile()` _right before_ compiling. Good for making any changes to\n * the schema that should respect options set by plugins, like `id`\n */\n\nSchema.prototype._preCompile = function _preCompile() {\n  idGetter(this);\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = exports = Schema;\n\n// require down here because of reference issues\n\n/**\n * The various built-in Mongoose Schema Types.\n *\n * #### Example:\n *\n *     const mongoose = require('mongoose');\n *     const ObjectId = mongoose.Schema.Types.ObjectId;\n *\n * #### Types:\n *\n * - [String](/docs/schematypes.html#strings)\n * - [Number](/docs/schematypes.html#numbers)\n * - [Boolean](/docs/schematypes.html#booleans) | Bool\n * - [Array](/docs/schematypes.html#arrays)\n * - [Buffer](/docs/schematypes.html#buffers)\n * - [Date](/docs/schematypes.html#dates)\n * - [ObjectId](/docs/schematypes.html#objectids) | Oid\n * - [Mixed](/docs/schematypes.html#mixed)\n *\n * Using this exposed access to the `Mixed` SchemaType, we can use them in our schema.\n *\n *     const Mixed = mongoose.Schema.Types.Mixed;\n *     new mongoose.Schema({ _user: Mixed })\n *\n * @api public\n */\n\nSchema.Types = MongooseTypes = require('./schema/index');\n\n/*!\n * ignore\n */\n\nexports.ObjectId = MongooseTypes.ObjectId;\n", "'use strict';\n\n/**\n * Module dependencies.\n */\n\nconst start = require('./common');\n\nconst mongoose = start.mongoose;\nconst assert = require('assert');\nconst sinon = require('sinon');\nconst Schema = mongoose.Schema;\nconst Document = mongoose.Document;\nconst VirtualType = mongoose.VirtualType;\nconst SchemaTypes = Schema.Types;\nconst ObjectId = SchemaTypes.ObjectId;\nconst Mixed = SchemaTypes.Mixed;\nconst DocumentObjectId = mongoose.Types.ObjectId;\nconst ReadPref = mongoose.mongo.ReadPreference;\nconst vm = require('vm');\nconst idGetter = require('../lib/helpers/schema/idGetter');\nconst applyPlugins = require('../lib/helpers/schema/applyPlugins');\n\n/**\n * Test Document constructor.\n */\n\nfunction TestDocument() {\n  Document.apply(this, arguments);\n}\n\n/**\n * Inherits from Document.\n */\n\nTestDocument.prototype.__proto__ = Document.prototype;\n\n/**\n * Test.\n */\n\ndescribe('schema', function() {\n  let db;\n\n  before(function() {\n    db = start();\n  });\n\n  after(async function() {\n    await db.close();\n  });\n\n  before(function() {\n    TestDocument.prototype.$__setSchema(new Schema({\n      test: String\n    }));\n  });\n\n  beforeEach(() => db.deleteModel(/.*/));\n  afterEach(() => require('./util').clearTestData(db));\n  afterEach(() => require('./util').stopRemainingOps(db));\n\n  describe('nested fields with same name', function() {\n    let NestedModel;\n\n    before(function() {\n      const NestedSchema = new Schema({\n        a: {\n          b: {\n            c: { $type: String },\n            d: { $type: String }\n          }\n        },\n        b: { $type: String }\n      }, { typeKey: '$type' });\n      NestedModel = db.model('Test', NestedSchema);\n    });\n\n    it('don\\'t disappear', function(done) {\n      const n = new NestedModel({\n        a: {\n          b: {\n            c: 'foo',\n            d: 'bar'\n          }\n        }, b: 'foobar'\n      });\n\n      n.save(function(err) {\n        assert.ifError(err);\n        NestedModel.findOne({ _id: n._id }, function(err, nm) {\n          assert.ifError(err);\n\n          // make sure no field has disappeared\n          assert.ok(nm.a);\n          assert.ok(nm.a.b);\n          assert.ok(nm.a.b.c);\n          assert.ok(nm.a.b.d);\n          assert.equal(nm.a.b.c, n.a.b.c);\n          assert.equal(nm.a.b.d, n.a.b.d);\n\n          done();\n        });\n      });\n    });\n  });\n\n\n  it('can be created without the \"new\" keyword', function(done) {\n    const schema = new Schema({ name: String });\n    assert.ok(schema instanceof Schema);\n    done();\n  });\n\n  it('does expose a property for duck-typing instanceof', function(done) {\n    const schema = new Schema({ name: String });\n    assert.ok(schema.instanceOfSchema);\n    done();\n  });\n\n  it('supports different schematypes', function(done) {\n    const Checkin = new Schema({\n      date: Date,\n      location: {\n        lat: Number,\n        lng: Number\n      }\n    });\n\n    const Ferret = new Schema({\n      name: String,\n      owner: ObjectId,\n      fur: String,\n      color: { type: String },\n      age: Number,\n      checkins: [Checkin],\n      friends: [ObjectId],\n      likes: Array,\n      alive: Boolean,\n      extra: Mixed\n    });\n\n    assert.ok(Ferret.path('name') instanceof SchemaTypes.String);\n    assert.ok(Ferret.path('owner') instanceof SchemaTypes.ObjectId);\n    assert.ok(Ferret.path('fur') instanceof SchemaTypes.String);\n    assert.ok(Ferret.path('color') instanceof SchemaTypes.String);\n    assert.ok(Ferret.path('age') instanceof SchemaTypes.Number);\n    assert.ok(Ferret.path('checkins') instanceof SchemaTypes.DocumentArray);\n    assert.ok(Ferret.path('friends') instanceof SchemaTypes.Array);\n    assert.ok(Ferret.path('likes') instanceof SchemaTypes.Array);\n    assert.ok(Ferret.path('alive') instanceof SchemaTypes.Boolean);\n    assert.ok(Ferret.path('extra') instanceof SchemaTypes.Mixed);\n\n    assert.strictEqual(Ferret.path('unexistent'), undefined);\n\n    assert.ok(Checkin.path('date') instanceof SchemaTypes.Date);\n\n    // check strings\n    const Checkin1 = new Schema({\n      date: 'date',\n      location: {\n        lat: 'number',\n        lng: 'Number'\n      }\n    });\n\n    assert.ok(Checkin1.path('date') instanceof SchemaTypes.Date);\n    assert.ok(Checkin1.path('location.lat') instanceof SchemaTypes.Number);\n    assert.ok(Checkin1.path('location.lng') instanceof SchemaTypes.Number);\n\n    const Ferret1 = new Schema({\n      name: 'string',\n      owner: 'oid',\n      fur: { type: 'string' },\n      color: { type: 'String' },\n      checkins: [Checkin],\n      friends: Array,\n      likes: 'array',\n      alive: 'Bool',\n      alive1: 'bool',\n      alive2: 'boolean',\n      extra: 'mixed',\n      obj: 'object',\n      buf: 'buffer',\n      Buf: 'Buffer'\n    });\n\n    assert.ok(Ferret1.path('name') instanceof SchemaTypes.String);\n    assert.ok(Ferret1.path('owner') instanceof SchemaTypes.ObjectId);\n    assert.ok(Ferret1.path('fur') instanceof SchemaTypes.String);\n    assert.ok(Ferret1.path('color') instanceof SchemaTypes.String);\n    assert.ok(Ferret1.path('checkins') instanceof SchemaTypes.DocumentArray);\n    assert.ok(Ferret1.path('friends') instanceof SchemaTypes.Array);\n    assert.ok(Ferret1.path('likes') instanceof SchemaTypes.Array);\n    assert.ok(Ferret1.path('alive') instanceof SchemaTypes.Boolean);\n    assert.ok(Ferret1.path('alive1') instanceof SchemaTypes.Boolean);\n    assert.ok(Ferret1.path('alive2') instanceof SchemaTypes.Boolean);\n    assert.ok(Ferret1.path('extra') instanceof SchemaTypes.Mixed);\n    assert.ok(Ferret1.path('obj') instanceof SchemaTypes.Mixed);\n    assert.ok(Ferret1.path('buf') instanceof SchemaTypes.Buffer);\n    assert.ok(Ferret1.path('Buf') instanceof SchemaTypes.Buffer);\n    done();\n  });\n\n  it('supports dot notation for path accessors', function(done) {\n    const Racoon = new Schema({\n      name: { type: String, enum: ['Edwald', 'Tobi'] },\n      age: Number\n    });\n\n    // check for global variable leak\n    assert.equal(typeof errorMessage, 'undefined');\n\n    const Person = new Schema({\n      name: String,\n      raccoons: [Racoon],\n      location: {\n        city: String,\n        state: String\n      }\n    });\n\n    assert.ok(Person.path('name') instanceof SchemaTypes.String);\n    assert.ok(Person.path('raccoons') instanceof SchemaTypes.DocumentArray);\n    assert.ok(Person.path('location.city') instanceof SchemaTypes.String);\n    assert.ok(Person.path('location.state') instanceof SchemaTypes.String);\n\n    assert.strictEqual(Person.path('location.unexistent'), undefined);\n    done();\n  });\n\n  it('allows paths nested > 2 levels', function(done) {\n    const Nested = new Schema({\n      first: {\n        second: {\n          third: String\n        }\n      }\n    });\n    assert.ok(Nested.path('first.second.third') instanceof SchemaTypes.String);\n    done();\n  });\n\n  it('default definition', function(done) {\n    const Test = new Schema({\n      simple: { $type: String, default: 'a' },\n      array: { $type: Array, default: [1, 2, 3, 4, 5] },\n      arrayX: { $type: Array, default: 9 },\n      arrayFn: {\n        $type: Array, default: function() {\n          return [8];\n        }\n      },\n      callback: {\n        $type: Number, default: function() {\n          assert.equal(this.a, 'b');\n          return '3';\n        }\n      }\n    }, { typeKey: '$type' });\n\n    assert.equal(Test.path('simple').defaultValue, 'a');\n    assert.equal(typeof Test.path('callback').defaultValue, 'function');\n\n    assert.equal(Test.path('simple').getDefault(), 'a');\n    assert.equal((+Test.path('callback').getDefault({ a: 'b' })), 3);\n    assert.equal(typeof Test.path('array').defaultValue, 'function');\n    assert.equal(Test.path('array').getDefault(new TestDocument())[3], 4);\n    assert.equal(Test.path('arrayX').getDefault(new TestDocument())[0], 9);\n    assert.equal(typeof Test.path('arrayFn').defaultValue, 'function');\n    assert.ok(Test.path('arrayFn').getDefault(new TestDocument()).isMongooseArray);\n    assert.ok(Test.path('arrayX').getDefault(new TestDocument()).isMongooseArray);\n    assert.equal(Test.path('arrayX').getDefault(new TestDocument())[0], 9);\n    done();\n  });\n\n  it('Mixed defaults can be empty arrays', function(done) {\n    const Test = new Schema({\n      mixed1: { type: Mixed, default: [] },\n      mixed2: { type: Mixed, default: Array }\n    });\n\n    assert.ok(Test.path('mixed1').getDefault() instanceof Array);\n    assert.equal(Test.path('mixed1').getDefault().length, 0);\n    assert.ok(Test.path('mixed2').getDefault() instanceof Array);\n    assert.equal(Test.path('mixed2').getDefault().length, 0);\n    done();\n  });\n\n  describe('casting', function() {\n    it('number', function(done) {\n      const Tobi = new Schema({\n        age: Number\n      });\n\n      // test String -> Number cast\n      assert.equal(typeof Tobi.path('age').cast('0'), 'number');\n      assert.equal((+Tobi.path('age').cast('0')), 0);\n\n      assert.equal(typeof Tobi.path('age').cast(0), 'number');\n      assert.equal((+Tobi.path('age').cast(0)), 0);\n      done();\n    });\n\n    describe('string', function() {\n      it('works', function(done) {\n        const Tobi = new Schema({\n          nickname: String\n        });\n\n        function Test() {\n        }\n\n        Test.prototype.toString = function() {\n          return 'woot';\n        };\n\n        // test Number -> String cast\n        assert.equal(typeof Tobi.path('nickname').cast(0), 'string');\n        assert.equal(Tobi.path('nickname').cast(0), '0');\n\n        // test any object that implements toString\n        assert.equal(typeof Tobi.path('nickname').cast(new Test()), 'string');\n        assert.equal(Tobi.path('nickname').cast(new Test()), 'woot');\n        done();\n      });\n    });\n\n    it('date', function(done) {\n      const Loki = new Schema({\n        birth_date: { type: Date }\n      });\n\n      assert.ok(Loki.path('birth_date').cast(1294525628301) instanceof Date);\n      assert.ok(Loki.path('birth_date').cast('8/24/2000') instanceof Date);\n      assert.ok(Loki.path('birth_date').cast(new Date()) instanceof Date);\n      assert.ok(Loki.path('birth_date').cast('') === null);\n      assert.ok(Loki.path('birth_date').cast(null) === null);\n      done();\n    });\n\n    it('objectid', function(done) {\n      const Loki = new Schema({\n        owner: { type: ObjectId }\n      });\n\n      const doc = new TestDocument();\n      const id = doc._id.toString();\n\n      assert.ok(Loki.path('owner').cast('4c54f3453e688c000000001a') instanceof DocumentObjectId);\n\n      assert.ok(Loki.path('owner').cast(new DocumentObjectId()) instanceof DocumentObjectId);\n\n      assert.ok(Loki.path('owner').cast(doc) instanceof DocumentObjectId);\n\n      assert.equal(Loki.path('owner').cast(doc).toString(), id);\n      done();\n    });\n\n    it('array', function(done) {\n      const Loki = new Schema({\n        oids: [ObjectId],\n        dates: [Date],\n        numbers: [Number],\n        strings: [String],\n        buffers: [Buffer],\n        nocast: [],\n        mixed: [Mixed]\n      });\n\n      const oids = Loki.path('oids').cast(['4c54f3453e688c000000001a', new DocumentObjectId()]);\n\n      assert.ok(oids[0] instanceof DocumentObjectId);\n      assert.ok(oids[1] instanceof DocumentObjectId);\n\n      const dates = Loki.path('dates').cast(['8/24/2010', 1294541504958]);\n\n      assert.ok(dates[0] instanceof Date);\n      assert.ok(dates[1] instanceof Date);\n\n      const numbers = Loki.path('numbers').cast([152, '31']);\n\n      assert.equal(typeof numbers[0], 'number');\n      assert.equal(typeof numbers[1], 'number');\n\n      const strings = Loki.path('strings').cast(['test', 123]);\n\n      assert.equal(typeof strings[0], 'string');\n      assert.equal(strings[0], 'test');\n\n      assert.equal(typeof strings[1], 'string');\n      assert.equal(strings[1], '123');\n\n      const buffers = Loki.path('buffers').cast(['\\0\\0\\0', Buffer.from('abc')]);\n\n      assert.ok(buffers[0] instanceof Buffer);\n      assert.ok(buffers[1] instanceof Buffer);\n\n      const nocasts = Loki.path('nocast').cast(['test', 123]);\n\n      assert.equal(typeof nocasts[0], 'string');\n      assert.equal(nocasts[0], 'test');\n\n      assert.equal(typeof nocasts[1], 'number');\n      assert.equal(nocasts[1], 123);\n\n      const mixed = Loki.path('mixed').cast(['test', 123, '123', {}, new Date(), new DocumentObjectId()]);\n\n      assert.equal(typeof mixed[0], 'string');\n      assert.equal(typeof mixed[1], 'number');\n      assert.equal(typeof mixed[2], 'string');\n      assert.equal(typeof mixed[3], 'object');\n      assert.ok(mixed[4] instanceof Date);\n      assert.ok(mixed[5] instanceof DocumentObjectId);\n\n      // gh-6405\n      assert.ok(Loki.path('dates.$') instanceof SchemaTypes.Date);\n      assert.ok(Loki.path('numbers.$') instanceof SchemaTypes.Number);\n      assert.ok(Loki.path('strings.$') instanceof SchemaTypes.String);\n      assert.ok(Loki.path('buffers.$') instanceof SchemaTypes.Buffer);\n      assert.ok(Loki.path('mixed.$') instanceof SchemaTypes.Mixed);\n\n      done();\n    });\n\n    it('array of arrays', function(done) {\n      const test = new Schema({\n        nums: [[Number]],\n        strings: [{ type: [String] }]\n      });\n      let nums = test.path('nums').cast([['1', '2']]);\n      assert.equal(nums.length, 1);\n      assert.deepEqual(nums[0].toObject(), [1, 2]);\n\n      nums = test.path('nums').cast(1);\n      assert.equal(nums.length, 1);\n      assert.deepEqual(nums[0].toObject(), [1]);\n\n      let threw = false;\n      try {\n        test.path('nums').cast([['abcd']]);\n      } catch (error) {\n        threw = true;\n        assert.equal(error.name, 'CastError');\n        assert.ok(error.message.includes('Cast to [[Number]] failed'), error.message);\n      }\n      assert.ok(threw);\n\n      const strs = test.path('strings').cast('test');\n      assert.equal(strs.length, 1);\n      assert.deepEqual(strs[0].toObject(), ['test']);\n\n      done();\n    });\n\n    it('boolean', function(done) {\n      const Animal = new Schema({\n        isFerret: { type: Boolean, required: true }\n      });\n\n      assert.strictEqual(Animal.path('isFerret').cast(null), null);\n      assert.strictEqual(Animal.path('isFerret').cast(undefined), undefined);\n\n      assert.equal(Animal.path('isFerret').cast(false), false);\n      assert.equal(Animal.path('isFerret').cast(0), false);\n      assert.equal(Animal.path('isFerret').cast('0'), false);\n      assert.equal(Animal.path('isFerret').cast('false'), false);\n      assert.equal(Animal.path('isFerret').cast(true), true);\n      assert.equal(Animal.path('isFerret').cast(1), true);\n      assert.equal(Animal.path('isFerret').cast('1'), true);\n      assert.equal(Animal.path('isFerret').cast('true'), true);\n      done();\n    });\n  });\n\n  it('methods declaration', function(done) {\n    const a = new Schema();\n    a.method('test', function() {\n    });\n    a.method({\n      a: function() {\n      },\n      b: function() {\n      }\n    });\n    assert.equal(Object.keys(a.methods).length, 3);\n    done();\n  });\n\n  it('static declaration', function(done) {\n    const a = new Schema();\n    a.static('test', function() {\n    });\n    a.static({\n      a: function() {\n      },\n      b: function() {\n      },\n      c: function() {\n      }\n    });\n\n    assert.equal(Object.keys(a.statics).length, 4);\n    done();\n  });\n\n  describe('setters', function() {\n    it('work', function(done) {\n      function lowercase(v) {\n        return v.toLowerCase();\n      }\n\n      const Tobi = new Schema({\n        name: { type: String, set: lowercase }\n      });\n\n      assert.equal(Tobi.path('name').applySetters('WOOT'), 'woot');\n      assert.equal(Tobi.path('name').setters.length, 1);\n\n      Tobi.path('name').set(function(v) {\n        return v + 'WOOT';\n      });\n\n      assert.equal(Tobi.path('name').applySetters('WOOT'), 'wootwoot');\n      assert.equal(Tobi.path('name').setters.length, 2);\n      done();\n    });\n\n    it('order', function(done) {\n      function extract(v) {\n        return (v && v._id)\n          ? v._id\n          : v;\n      }\n\n      const Tobi = new Schema({\n        name: { type: Schema.ObjectId, set: extract }\n      });\n\n      const id = new DocumentObjectId();\n      const sid = id.toString();\n      const _id = { _id: id };\n\n      assert.equal(Tobi.path('name').applySetters(sid, { a: 'b' }).toString(), sid);\n      assert.equal(Tobi.path('name').applySetters(_id, { a: 'b' }).toString(), sid);\n      assert.equal(Tobi.path('name').applySetters(id, { a: 'b' }).toString(), sid);\n      done();\n    });\n\n    it('scope', function(done) {\n      function lowercase(v, cur, self) {\n        assert.equal(this.a, 'b');\n        assert.equal(self.path, 'name');\n        return v.toLowerCase();\n      }\n\n      const Tobi = new Schema({\n        name: { type: String, set: lowercase }\n      });\n\n      assert.equal(Tobi.path('name').applySetters('WHAT', { a: 'b' }), 'what');\n      done();\n    });\n\n    it('casting', function(done) {\n      function last(v) {\n        assert.equal(typeof v, 'number');\n        assert.equal(v, 0);\n        return 'last';\n      }\n\n      function first() {\n        return 0;\n      }\n\n      const Tobi = new Schema({\n        name: { type: String, set: last }\n      });\n\n      Tobi.path('name').set(first);\n      assert.equal(Tobi.path('name').applySetters('woot'), 'last');\n      done();\n    });\n\n    describe('array', function() {\n      it('object setters will be applied for each object in array', function(done) {\n        const Tobi = new Schema({\n          names: [{ type: String, lowercase: true, trim: true }]\n        });\n        assert.equal(typeof Tobi.path('names').applySetters(['   whaT', 'WoOt  '])[0], 'string');\n        assert.equal(typeof Tobi.path('names').applySetters(['   whaT', 'WoOt  '])[1], 'string');\n        assert.equal(Tobi.path('names').applySetters(['   whaT', 'WoOt  '])[0], 'what');\n        assert.equal(Tobi.path('names').applySetters(['   whaT', 'WoOt  '])[1], 'woot');\n        done();\n      });\n    });\n\n    describe('string', function() {\n      it('lowercase', function(done) {\n        const Tobi = new Schema({\n          name: { type: String, lowercase: true }\n        });\n\n        assert.equal(Tobi.path('name').applySetters('WHAT'), 'what');\n        assert.equal(Tobi.path('name').applySetters(1977), '1977');\n        done();\n      });\n      it('uppercase', function(done) {\n        const Tobi = new Schema({\n          name: { type: String, uppercase: true }\n        });\n\n        assert.equal(Tobi.path('name').applySetters('what'), 'WHAT');\n        assert.equal(Tobi.path('name').applySetters(1977), '1977');\n        done();\n      });\n      it('trim', function(done) {\n        const Tobi = new Schema({\n          name: { type: String, uppercase: true, trim: true }\n        });\n\n        assert.equal(Tobi.path('name').applySetters('  what   '), 'WHAT');\n        assert.equal(Tobi.path('name').applySetters(1977), '1977');\n        done();\n      });\n    });\n\n    it('applying when none have been defined', function(done) {\n      const Tobi = new Schema({\n        name: String\n      });\n\n      assert.equal(Tobi.path('name').applySetters('woot'), 'woot');\n      done();\n    });\n\n    it('assignment of non-functions throw', function(done) {\n      const schema = new Schema({ fun: String });\n      let g;\n\n      try {\n        schema.path('fun').set(4);\n      } catch (err_) {\n        g = err_;\n      }\n\n      assert.ok(g);\n      assert.equal(g.message, 'A setter must be a function.');\n      done();\n    });\n  });\n\n  describe('getters', function() {\n    it('work', function(done) {\n      function woot(v) {\n        return v + ' woot';\n      }\n\n      const Tobi = new Schema({\n        name: { type: String, get: woot }\n      });\n\n      assert.equal(Tobi.path('name').getters.length, 1);\n      assert.equal(Tobi.path('name').applyGetters('test'), 'test woot');\n      done();\n    });\n    it('order', function(done) {\n      function format(v) {\n        return v\n          ? '$' + v\n          : v;\n      }\n\n      const Tobi = new Schema({\n        name: { type: Number, get: format }\n      });\n\n      assert.equal(Tobi.path('name').applyGetters(30, { a: 'b' }), '$30');\n      done();\n    });\n    it('scope', function(done) {\n      function woot(v, self) {\n        assert.equal(this.a, 'b');\n        assert.equal(self.path, 'name');\n        return v.toLowerCase();\n      }\n\n      const Tobi = new Schema({\n        name: { type: String, get: woot }\n      });\n\n      assert.equal(Tobi.path('name').applyGetters('YEP', { a: 'b' }), 'yep');\n      done();\n    });\n    it('casting', function(done) {\n      function last(v) {\n        assert.equal(typeof v, 'number');\n        assert.equal(v, 0);\n        return 'last';\n      }\n\n      function first() {\n        return 0;\n      }\n\n      const Tobi = new Schema({\n        name: { type: String, get: first }\n      });\n\n      Tobi.path('name').get(last);\n      assert.equal(Tobi.path('name').applyGetters('woot'), 'last');\n      done();\n    });\n    it('applying when none have been defined', function(done) {\n      const Tobi = new Schema({\n        name: String\n      });\n\n      assert.equal(Tobi.path('name').applyGetters('woot'), 'woot');\n      done();\n    });\n    it('assignment of non-functions throw', function(done) {\n      const schema = new Schema({ fun: String });\n      let g;\n\n      try {\n        schema.path('fun').get(true);\n      } catch (err_) {\n        g = err_;\n      }\n\n      assert.ok(g);\n      assert.equal(g.message, 'A getter must be a function.');\n      done();\n    });\n    it('auto _id', function(done) {\n      let schema = new Schema({\n        name: String\n      });\n      assert.ok(schema.path('_id') instanceof Schema.ObjectId);\n\n      schema = new Schema({\n        name: String\n      }, { _id: true });\n      assert.ok(schema.path('_id') instanceof Schema.ObjectId);\n\n      schema.set('_id', false);\n      assert.ok(schema.path('_id') == null);\n\n      schema = new Schema({\n        name: String\n      }, { _id: false });\n      assert.equal(schema.path('_id'), undefined);\n\n      schema.set('_id', true);\n      assert.ok(schema.path('_id') instanceof Schema.ObjectId);\n      done();\n    });\n  });\n\n  describe('indexes', function() {\n    describe('definition', function() {\n      it('basic', function(done) {\n        const Tobi = new Schema({\n          name: { type: String, index: true }\n        });\n\n        assert.equal(Tobi.path('name')._index, true);\n        Tobi.path('name').index({ unique: true });\n        assert.deepEqual(Tobi.path('name')._index, { unique: true });\n        Tobi.path('name').unique(false);\n        assert.deepEqual(Tobi.path('name')._index, { unique: false });\n\n        let T, i;\n\n        T = new Schema({\n          name: { type: String, sparse: true }\n        });\n        assert.deepEqual(T.path('name')._index, { sparse: true });\n\n        T = new Schema({\n          name: { type: String, unique: true }\n        });\n        assert.deepEqual(T.path('name')._index, { unique: true });\n\n        T = new Schema({\n          name: { type: Date, expires: '1.5m' }\n        });\n        assert.deepEqual(T.path('name')._index, { expireAfterSeconds: 90 });\n\n        T = new Schema({\n          name: { type: Date, expires: 200 }\n        });\n        assert.deepEqual(T.path('name')._index, { expireAfterSeconds: 200 });\n\n        T = new Schema({\n          name: { type: String, sparse: true, unique: true }\n        });\n        assert.deepEqual(T.path('name')._index, { sparse: true, unique: true });\n\n        T = new Schema({\n          name: { type: String, unique: true, sparse: true }\n        });\n        i = T.path('name')._index;\n        assert.equal(i.unique, true);\n        assert.equal(i.sparse, true);\n\n        T = new Schema({\n          name: { type: String, index: { sparse: true, unique: true, expireAfterSeconds: 65 } }\n        });\n        i = T.path('name')._index;\n        assert.equal(i.unique, true);\n        assert.equal(i.sparse, true);\n        assert.equal(i.expireAfterSeconds, 65);\n\n        T = new Schema({\n          name: { type: Date, index: { sparse: true, unique: true, expires: '24h' } }\n        });\n        i = T.path('name')._index;\n        assert.equal(i.unique, true);\n        assert.equal(i.sparse, true);\n        assert.equal(i.expireAfterSeconds, 60 * 60 * 24);\n\n        T = new Schema({\n          name: { type: String, index: false, unique: false }\n        });\n        assert.equal(T.path('name')._index, false);\n        assert.equal(T.indexes().length, 0);\n\n        done();\n      });\n      it('compound', function(done) {\n        const Tobi = new Schema({\n          name: { type: String, index: true },\n          last: { type: Number, sparse: true },\n          nope: { type: String, index: { background: false } }\n        });\n\n        Tobi.index({ firstname: 1, last: 1 }, { unique: true, expires: '1h' });\n        Tobi.index({ firstname: 1, nope: 1 }, { unique: true, background: false });\n\n        assert.deepEqual(Tobi.indexes(), [\n          [{ name: 1 }, { background: true }],\n          [{ last: 1 }, { sparse: true, background: true }],\n          [{ nope: 1 }, { background: false }],\n          [{ firstname: 1, last: 1 }, { unique: true, expireAfterSeconds: 60 * 60, background: true }],\n          [{ firstname: 1, nope: 1 }, { unique: true, background: false }]\n        ]);\n\n        done();\n      });\n\n      it('compound based on name (gh-6499)', function() {\n        const testSchema = new Schema({\n          prop1: { type: String, index: { name: 'test1' } },\n          prop2: { type: Number, index: true },\n          prop3: { type: String, index: { name: 'test1' } }\n        });\n\n        const indexes = testSchema.indexes();\n        assert.equal(indexes.length, 2);\n        assert.deepEqual(indexes[0][0], { prop1: 1, prop3: 1 });\n        assert.deepEqual(indexes[1][0], { prop2: 1 });\n      });\n\n      it('with single nested doc (gh-6113)', function(done) {\n        const pointSchema = new Schema({\n          type: {\n            type: String,\n            default: 'Point',\n            validate: v => v === 'Point'\n          },\n          coordinates: [[Number]]\n        });\n\n        const schema = new Schema({\n          point: { type: pointSchema, index: '2dsphere' }\n        });\n\n        assert.deepEqual(schema.indexes(), [\n          [{ point: '2dsphere' }, { background: true }]\n        ]);\n\n        done();\n      });\n\n      it('with embedded discriminator (gh-6485)', function() {\n        const eventSchema = new Schema({\n          message: { type: String, index: true }\n        }, { discriminatorKey: 'kind', _id: false });\n\n        const batchSchema = new Schema({\n          events: [eventSchema]\n        });\n\n        const docArray = batchSchema.path('events');\n\n        docArray.discriminator('gh6485_Clicked', new Schema({\n          element: { type: String, index: true }\n        }, { _id: false }));\n\n        docArray.discriminator('gh6485_Purchased', Schema({\n          product: { type: String, index: true }\n        }, { _id: false }));\n\n        assert.deepEqual(batchSchema.indexes().map(v => v[0]), [\n          { 'events.message': 1 },\n          { 'events.element': 1 },\n          { 'events.product': 1 }\n        ]);\n      });\n    });\n  });\n\n  describe('plugins', function() {\n    it('work', function() {\n      const Tobi = new Schema();\n      let called = false;\n\n      Tobi.plugin(function(schema) {\n        assert.equal(schema, Tobi);\n        called = true;\n      });\n\n      assert.equal(called, true);\n    });\n  });\n\n  describe('options', function() {\n    it('defaults are set', function() {\n      const Tobi = new Schema();\n\n      assert.equal(typeof Tobi.options, 'object');\n      assert.equal(Tobi.options.safe, undefined);\n      assert.equal(Tobi.options.strict, true);\n      assert.equal(Tobi.options.capped, false);\n      assert.equal(Tobi.options.versionKey, '__v');\n      assert.equal(Tobi.options.discriminatorKey, '__t');\n      assert.equal(Tobi.options.shardKey, null);\n      assert.equal(Tobi.options.read, null);\n      assert.equal(Tobi.options._id, true);\n    });\n\n    it('setting', function(done) {\n      let Tobi = new Schema({}, { collection: 'users' });\n\n      Tobi.set('a', 'b');\n      Tobi.set('writeConcern', { w: 0 });\n      assert.equal(Tobi.options.collection, 'users');\n\n      assert.equal(Tobi.options.a, 'b');\n      assert.deepEqual(Tobi.options.writeConcern, { w: 0 });\n      assert.equal(Tobi.options.read, null);\n\n      const tags = [{ x: 1 }];\n\n      Tobi.set('read', 'n');\n      assert.ok(Tobi.options.read instanceof ReadPref);\n      assert.equal(Tobi.options.read.mode, 'nearest');\n\n      Tobi.set('read', 'n', tags);\n      assert.equal(Tobi.options.read.mode, 'nearest');\n      assert.ok(Array.isArray(Tobi.options.read.tags));\n      assert.equal(Tobi.options.read.tags.length, 1);\n      assert.equal(Tobi.options.read.tags[0].x, 1);\n\n      Tobi.set('read', ['n', tags]);\n      assert.equal(Tobi.options.read.mode, 'nearest');\n      assert.ok(Array.isArray(Tobi.options.read.tags));\n      assert.equal(Tobi.options.read.tags.length, 1);\n      assert.equal(Tobi.options.read.tags[0].x, 1);\n\n      Tobi = new Schema({}, { read: 'p' });\n      assert.ok(Tobi.options.read instanceof ReadPref);\n      assert.equal(Tobi.options.read.mode, 'primary');\n\n      Tobi = new Schema({}, { read: ['s', tags] });\n      assert.ok(Tobi.options.read instanceof ReadPref);\n      assert.equal(Tobi.options.read.mode, 'secondary');\n      assert.ok(Array.isArray(Tobi.options.read.tags));\n      assert.equal(Tobi.options.read.tags.length, 1);\n      assert.equal(Tobi.options.read.tags[0].x, 1);\n\n      Tobi = new Schema({}, { read: 'primary' });\n      assert.ok(Tobi.options.read instanceof ReadPref);\n      assert.equal(Tobi.options.read.mode, 'primary');\n\n      Tobi = new Schema({}, { read: ['secondary', tags] });\n      assert.ok(Tobi.options.read instanceof ReadPref);\n      assert.equal(Tobi.options.read.mode, 'secondary');\n      assert.ok(Array.isArray(Tobi.options.read.tags));\n      assert.equal(Tobi.options.read.tags.length, 1);\n      assert.equal(Tobi.options.read.tags[0].x, 1);\n\n      Tobi = new Schema({}, { read: 's' });\n      assert.ok(Tobi.options.read instanceof ReadPref);\n      assert.equal(Tobi.options.read.mode, 'secondary');\n\n      Tobi = new Schema({}, { read: ['s', tags] });\n      assert.ok(Tobi.options.read instanceof ReadPref);\n      assert.equal(Tobi.options.read.mode, 'secondary');\n      assert.ok(Array.isArray(Tobi.options.read.tags));\n      assert.equal(Tobi.options.read.tags.length, 1);\n      assert.equal(Tobi.options.read.tags[0].x, 1);\n\n      Tobi = new Schema({}, { read: 'secondary' });\n      assert.ok(Tobi.options.read instanceof ReadPref);\n      assert.equal(Tobi.options.read.mode, 'secondary');\n\n      Tobi = new Schema({}, { read: ['secondary', tags] });\n      assert.ok(Tobi.options.read instanceof ReadPref);\n      assert.equal(Tobi.options.read.mode, 'secondary');\n      assert.ok(Array.isArray(Tobi.options.read.tags));\n      assert.equal(Tobi.options.read.tags.length, 1);\n      assert.equal(Tobi.options.read.tags[0].x, 1);\n\n      Tobi = new Schema({}, { read: 'pp' });\n      assert.ok(Tobi.options.read instanceof ReadPref);\n      assert.ok(Tobi.options.read.isValid());\n      assert.equal(Tobi.options.read.mode, 'primaryPreferred');\n\n      Tobi = new Schema({}, { read: ['pp', tags] });\n      assert.ok(Tobi.options.read instanceof ReadPref);\n      assert.ok(Tobi.options.read.isValid());\n      assert.equal(Tobi.options.read.mode, 'primaryPreferred');\n      assert.ok(Array.isArray(Tobi.options.read.tags));\n      assert.equal(Tobi.options.read.tags.length, 1);\n      assert.equal(Tobi.options.read.tags[0].x, 1);\n\n      Tobi = new Schema({}, { read: 'primaryPreferred' });\n      assert.ok(Tobi.options.read instanceof ReadPref);\n      assert.ok(Tobi.options.read.isValid());\n      assert.equal(Tobi.options.read.mode, 'primaryPreferred');\n\n      Tobi = new Schema({}, { read: ['primaryPreferred', tags] });\n      assert.ok(Tobi.options.read instanceof ReadPref);\n      assert.ok(Tobi.options.read.isValid());\n      assert.equal(Tobi.options.read.mode, 'primaryPreferred');\n      assert.ok(Array.isArray(Tobi.options.read.tags));\n      assert.equal(Tobi.options.read.tags.length, 1);\n      assert.equal(Tobi.options.read.tags[0].x, 1);\n\n      Tobi = new Schema({}, { read: 'sp' });\n      assert.ok(Tobi.options.read instanceof ReadPref);\n      assert.ok(Tobi.options.read.isValid());\n      assert.equal(Tobi.options.read.mode, 'secondaryPreferred');\n\n      Tobi = new Schema({}, { read: ['sp', tags] });\n      assert.ok(Tobi.options.read instanceof ReadPref);\n      assert.ok(Tobi.options.read.isValid());\n      assert.equal(Tobi.options.read.mode, 'secondaryPreferred');\n      assert.ok(Array.isArray(Tobi.options.read.tags));\n      assert.equal(Tobi.options.read.tags.length, 1);\n      assert.equal(Tobi.options.read.tags[0].x, 1);\n\n      Tobi = new Schema({}, { read: 'secondaryPreferred' });\n      assert.ok(Tobi.options.read instanceof ReadPref);\n      assert.ok(Tobi.options.read.isValid());\n      assert.equal(Tobi.options.read.mode, 'secondaryPreferred');\n\n      Tobi = new Schema({}, { read: ['secondaryPreferred', tags] });\n      assert.ok(Tobi.options.read instanceof ReadPref);\n      assert.ok(Tobi.options.read.isValid());\n      assert.equal(Tobi.options.read.mode, 'secondaryPreferred');\n      assert.ok(Array.isArray(Tobi.options.read.tags));\n      assert.equal(Tobi.options.read.tags.length, 1);\n      assert.equal(Tobi.options.read.tags[0].x, 1);\n\n      Tobi = new Schema({}, { read: 'n' });\n      assert.ok(Tobi.options.read instanceof ReadPref);\n      assert.ok(Tobi.options.read.isValid());\n      assert.equal(Tobi.options.read.mode, 'nearest');\n\n      Tobi = new Schema({}, { read: ['n', tags] });\n      assert.ok(Tobi.options.read instanceof ReadPref);\n      assert.ok(Tobi.options.read.isValid());\n      assert.equal(Tobi.options.read.mode, 'nearest');\n      assert.ok(Array.isArray(Tobi.options.read.tags));\n      assert.equal(Tobi.options.read.tags.length, 1);\n      assert.equal(Tobi.options.read.tags[0].x, 1);\n\n      Tobi = new Schema({}, { read: 'nearest' });\n      assert.ok(Tobi.options.read instanceof ReadPref);\n      assert.ok(Tobi.options.read.isValid());\n      assert.equal(Tobi.options.read.mode, 'nearest');\n\n      Tobi = new Schema({}, { read: ['nearest', tags] });\n      assert.ok(Tobi.options.read instanceof ReadPref);\n      assert.ok(Tobi.options.read.isValid());\n      assert.equal(Tobi.options.read.mode, 'nearest');\n      assert.ok(Array.isArray(Tobi.options.read.tags));\n      assert.equal(Tobi.options.read.tags.length, 1);\n      assert.equal(Tobi.options.read.tags[0].x, 1);\n\n      done();\n    });\n  });\n\n  describe('virtuals', function() {\n    it('works', function(done) {\n      const Contact = new Schema({\n        firstName: String,\n        lastName: String\n      });\n\n      Contact\n        .virtual('fullName')\n        .get(function() {\n          return this.get('firstName') + ' ' + this.get('lastName');\n        })\n        .set(function(fullName) {\n          const split = fullName.split(' ');\n          this.set('firstName', split[0]);\n          this.set('lastName', split[1]);\n        });\n\n      assert.ok(Contact.virtualpath('fullName') instanceof VirtualType);\n      done();\n    });\n\n    describe('id', function() {\n      it('default creation of id can be overridden (gh-298)', function(done) {\n        assert.doesNotThrow(function() {\n          new Schema({ id: String });\n        });\n        done();\n      });\n      it('disabling', function(done) {\n        const schema = new Schema({ name: String });\n        assert.strictEqual(undefined, schema.virtuals.id);\n        done();\n      });\n    });\n\n    describe('getter', function() {\n      it('scope', function(done) {\n        const Tobi = new Schema();\n\n        Tobi.virtual('name').get(function(v, self) {\n          assert.equal(this.a, 'b');\n          assert.equal(self.path, 'name');\n          return v.toLowerCase();\n        });\n\n        assert.equal(Tobi.virtualpath('name').applyGetters('YEP', { a: 'b' }), 'yep');\n        done();\n      });\n    });\n\n    describe('setter', function() {\n      it('scope', function(done) {\n        const Tobi = new Schema();\n\n        Tobi.virtual('name').set(function(v, self) {\n          assert.equal(this.a, 'b');\n          assert.equal(self.path, 'name');\n          return v.toLowerCase();\n        });\n\n        assert.equal(Tobi.virtualpath('name').applySetters('YEP', { a: 'b' }), 'yep');\n        done();\n      });\n    });\n  });\n\n  describe('other contexts', function() {\n    it('work', function(done) {\n      const str = 'code = {' +\n        '  name: String' +\n        ', arr1: Array ' +\n        ', arr2: { type: [] }' +\n        ', date: Date  ' +\n        ', num: { type: Number }' +\n        ', bool: Boolean' +\n        ', nest: { sub: { type: {}, required: true }}' +\n        '}';\n\n      const script = vm.createScript(str, 'testSchema.vm');\n      const sandbox = { code: null };\n      script.runInNewContext(sandbox);\n\n      const Ferret = new Schema(sandbox.code);\n      assert.ok(Ferret.path('nest.sub') instanceof SchemaTypes.Mixed);\n      assert.ok(Ferret.path('name') instanceof SchemaTypes.String);\n      assert.ok(Ferret.path('arr1') instanceof SchemaTypes.Array);\n      assert.ok(Ferret.path('arr2') instanceof SchemaTypes.Array);\n      assert.ok(Ferret.path('date') instanceof SchemaTypes.Date);\n      assert.ok(Ferret.path('num') instanceof SchemaTypes.Number);\n      assert.ok(Ferret.path('bool') instanceof SchemaTypes.Boolean);\n      done();\n    });\n  });\n\n  describe('#add()', function() {\n    it('does not pollute existing paths', function(done) {\n      let o = { name: String };\n      let s = new Schema(o);\n\n      assert.throws(function() {\n        s.add({ age: Number }, 'name.');\n      }, /Cannot set nested path/);\n\n      assert.throws(function() {\n        s.add({ age: { x: Number } }, 'name.');\n      }, /Cannot set nested path/);\n      assert.equal(('age' in o.name), false);\n\n      o = { name: 'string' };\n      s = new Schema(o);\n\n      assert.throws(function() {\n        s.add({ age: Number }, 'name.');\n      }, /Cannot set nested path/);\n\n      assert.throws(function() {\n        s.add({ age: { x: Number } }, 'name.');\n      }, /Cannot set nested path/);\n\n      assert.equal(o.name, 'string');\n      done();\n    });\n\n    it('returns the schema instance', function() {\n      const schema = new Schema({ name: String });\n      const ret = schema.add({ age: Number });\n      assert.strictEqual(ret, schema);\n    });\n\n    it('returns the schema instance when schema instance is passed', function() {\n      const schemaA = new Schema({ name: String });\n      const schemaB = new Schema({ age: Number });\n      const ret = schemaB.add(schemaA);\n      assert.strictEqual(ret, schemaB);\n    });\n\n    it('merging nested objects (gh-662)', function(done) {\n      const MergedSchema = new Schema({\n        a: {\n          foo: String\n        }\n      });\n\n      MergedSchema.add({\n        a: {\n          b: {\n            bar: String\n          }\n        }\n      });\n\n      db.deleteModel(/Test/);\n      const Merged = db.model('Test', MergedSchema);\n\n      const merged = new Merged({\n        a: {\n          foo: 'baz',\n          b: {\n            bar: 'qux'\n          }\n        }\n      });\n\n      merged.save(function(err) {\n        assert.ifError(err);\n        Merged.findById(merged.id, function(err, found) {\n          assert.ifError(err);\n          assert.equal(found.a.foo, 'baz');\n          assert.equal(found.a.b.bar, 'qux');\n          done();\n        });\n      });\n    });\n\n    it('prefix (gh-1730)', function(done) {\n      const s = new Schema({});\n\n      s.add({ n: Number }, 'prefix.');\n\n      assert.equal(s.pathType('prefix.n'), 'real');\n      assert.equal(s.pathType('prefix'), 'nested');\n      done();\n    });\n\n    it('adds another schema (gh-6897)', function(done) {\n      const s = new Schema({ name: String });\n\n      const s2 = new Schema({ age: Number });\n\n      s2.statics.foo = function() { return 42; };\n      s2.pre('save', function() {\n        throw new Error('oops!');\n      });\n\n      s.add(s2);\n\n      assert.ok(s.paths.age);\n      assert.strictEqual(s.statics.foo, s2.statics.foo);\n      assert.ok(s.s.hooks._pres.get('save'));\n\n      done();\n    });\n\n    it('overwrites existing paths (gh-10203)', function() {\n      const baseSchema = new Schema({\n        username: {\n          type: String,\n          required: false\n        }\n      });\n\n      const userSchema = new Schema({\n        email: {\n          type: String,\n          required: true\n        },\n        username: {\n          type: String,\n          required: true\n        }\n      });\n\n      const realSchema = baseSchema.clone();\n      realSchema.add(userSchema);\n\n      assert.ok(realSchema.path('username').isRequired);\n    });\n  });\n\n  it('debugging msgs', function(done) {\n    let err;\n    try {\n      new Schema({ name: { first: null } });\n    } catch (e) {\n      err = e;\n    }\n    assert.ok(err.message.indexOf('Invalid value for schema path `name.first`') !== -1, err.message);\n    try {\n      new Schema({ age: undefined });\n    } catch (e) {\n      err = e;\n    }\n    assert.ok(err.message.indexOf('Invalid value for schema path `age`') !== -1, err.message);\n    done();\n  });\n\n  describe('construction', function() {\n    it('array of object literal missing a type is interpreted as DocumentArray', function(done) {\n      const goose = new mongoose.Mongoose();\n      const s = new Schema({\n        arr: [\n          { something: { type: String } }\n        ]\n      });\n      assert.ok(s.path('arr') instanceof SchemaTypes.DocumentArray);\n      const M = goose.model('objectliteralschema', s);\n      const m = new M({ arr: [{ something: 'wicked this way comes' }] });\n      assert.equal(m.arr[0].something, 'wicked this way comes');\n      assert.ok(m.arr[0]._id);\n      done();\n    });\n\n    it('array of object literal with type.type is interpreted as DocumentArray', function(done) {\n      const goose = new mongoose.Mongoose();\n      const s = new Schema({\n        arr: [\n          { type: { type: String } }\n        ]\n      });\n      assert.ok(s.path('arr') instanceof SchemaTypes.DocumentArray);\n      const M = goose.model('objectliteralschema2', s);\n      const m = new M({ arr: [{ type: 'works' }] });\n      assert.equal(m.arr[0].type, 'works');\n      assert.ok(m.arr[0]._id);\n      done();\n    });\n\n    it('does not alter original argument (gh-1364)', function(done) {\n      const schema = {\n        ids: [{ type: Schema.ObjectId, ref: 'something' }],\n        a: { type: Array },\n        b: Array,\n        c: [Date],\n        d: { type: 'Boolean' },\n        e: [{ a: String, b: [{ type: { type: Buffer }, x: Number }] }]\n      };\n\n      new Schema(schema);\n      assert.equal(Object.keys(schema).length, 6);\n      assert.deepEqual([{ type: Schema.ObjectId, ref: 'something' }], schema.ids);\n      assert.deepEqual({ type: Array }, schema.a);\n      assert.deepEqual(Array, schema.b);\n      assert.deepEqual([Date], schema.c);\n      assert.deepEqual({ type: 'Boolean' }, schema.d);\n      assert.deepEqual([{ a: String, b: [{ type: { type: Buffer }, x: Number }] }], schema.e);\n\n      done();\n    });\n\n    it('properly gets value of plain objects when dealing with refs (gh-1606)', function(done) {\n      const el = new Schema({ title: String });\n      const so = new Schema({\n        title: String,\n        obj: { type: Schema.Types.ObjectId, ref: 'Test' }\n      });\n\n      const Element = db.model('Test', el);\n      const Some = db.model('Test1', so);\n\n      const ele = new Element({ title: 'thing' });\n\n      ele.save(function(err) {\n        assert.ifError(err);\n        const s = new Some({ obj: ele.toObject() });\n        s.save(function(err) {\n          assert.ifError(err);\n          Some.findOne({ _id: s.id }, function(err, ss) {\n            assert.ifError(err);\n            assert.equal(ss.obj, ele.id);\n            done();\n          });\n        });\n      });\n    });\n\n    it('array of of schemas and objects (gh-7218)', function(done) {\n      const baseSchema = new Schema({ created: Date }, { id: true });\n      const s = new Schema([baseSchema, { name: String }], { id: false });\n\n      assert.ok(s.path('created'));\n      assert.ok(s.path('name'));\n      assert.ok(!s.options.id);\n\n      done();\n    });\n  });\n\n  describe('property names', function() {\n    describe('reserved keys are log a warning (gh-9010)', () => {\n      this.afterEach(() => sinon.restore());\n      const reservedProperties = [\n        'emit', 'listeners', 'removeListener', /* 'collection', */ // TODO: add `collection`\n        'errors', 'get', 'init', 'isModified', 'isNew', 'populated',\n        'remove', 'save', 'toObject', 'validate'\n      ];\n\n      for (const reservedProperty of reservedProperties) {\n        it(`\\`${reservedProperty}\\` when used as a schema path logs a warning`, async() => {\n          // Arrange\n          const emitWarningStub = sinon.stub(process, 'emitWarning').returns();\n\n          // Act\n          new Schema({ [reservedProperty]: String });\n\n          // Assert\n          const lastWarnMessage = emitWarningStub.args[0][0];\n          assert.ok(lastWarnMessage.includes(`\\`${reservedProperty}\\` is a reserved schema pathname`), lastWarnMessage);\n        });\n\n        it(`\\`${reservedProperty}\\` when used as a schema path doesn't log a warning if \\`supressReservedKeysWarning\\` is true`, async() => {\n          // Arrange\n          const emitWarningStub = sinon.stub(process, 'emitWarning').returns();\n\n\n          // Act\n          new Schema(\n            { [reservedProperty]: String },\n            { supressReservedKeysWarning: true }\n          );\n\n          const lastWarnMessage = emitWarningStub.args[0] && emitWarningStub.args[0][0];\n\n          // Assert\n          assert.strictEqual(lastWarnMessage, undefined);\n        });\n      }\n    });\n\n\n    it('that do not conflict do not throw', function() {\n      assert.doesNotThrow(function() {\n        new Schema({\n          model: String\n        });\n      });\n\n      assert.doesNotThrow(function() {\n        Schema({ child: [{ parent: String }] });\n      });\n\n      assert.doesNotThrow(function() {\n        Schema({ child: [{ parentArray: String }] });\n      });\n\n      assert.doesNotThrow(function() {\n        const s = new Schema({ docs: [{ path: String }] });\n        const M = mongoose.model('gh-1245', s);\n        new M({ docs: [{ path: 'works' }] });\n      });\n\n      assert.doesNotThrow(function() {\n        const s = new Schema({ setMaxListeners: String });\n        const M = mongoose.model('setMaxListeners-as-property-name', s);\n        new M({ setMaxListeners: 'works' });\n      });\n    });\n\n    it('permit _scope to be used (gh-1184)', function(done) {\n      const child = new Schema({ _scope: Schema.ObjectId });\n      const C = db.model('Test', child);\n      const c = new C();\n      c.save(function(err) {\n        assert.ifError(err);\n        try {\n          c._scope;\n        } catch (e) {\n          err = e;\n        }\n        assert.ifError(err);\n        done();\n      });\n    });\n  });\n\n  describe('pathType()', function() {\n    let schema;\n\n    before(function() {\n      schema = new Schema({\n        n: String,\n        nest: { thing: { nests: Boolean } },\n        docs: [{ x: [{ y: String }] }],\n        mixed: {}\n      });\n      schema.virtual('myVirtual').get(function() { return 42; });\n    });\n\n    describe('when called on an explicit real path', function() {\n      it('returns \"real\"', function(done) {\n        assert.equal(schema.pathType('n'), 'real');\n        assert.equal(schema.pathType('nest.thing.nests'), 'real');\n        assert.equal(schema.pathType('docs'), 'real');\n        assert.equal(schema.pathType('docs.0.x'), 'real');\n        assert.equal(schema.pathType('docs.0.x.3.y'), 'real');\n        assert.equal(schema.pathType('mixed'), 'real');\n        done();\n      });\n    });\n    describe('when called on a virtual', function() {\n      it('returns virtual', function(done) {\n        assert.equal(schema.pathType('myVirtual'), 'virtual');\n        done();\n      });\n    });\n    describe('when called on nested structure', function() {\n      it('returns nested', function(done) {\n        assert.equal(schema.pathType('nest'), 'nested');\n        assert.equal(schema.pathType('nest.thing'), 'nested');\n        done();\n      });\n    });\n    describe('when called on undefined path', function() {\n      it('returns adHocOrUndefined', function(done) {\n        assert.equal(schema.pathType('mixed.what'), 'adhocOrUndefined');\n        assert.equal(schema.pathType('mixed.4'), 'adhocOrUndefined');\n        assert.equal(schema.pathType('mixed.4.thing'), 'adhocOrUndefined');\n        assert.equal(schema.pathType('mixed.4a.thing'), 'adhocOrUndefined');\n        assert.equal(schema.pathType('mixed.4.9.thing'), 'adhocOrUndefined');\n        assert.equal(schema.pathType('n.3'), 'adhocOrUndefined');\n        assert.equal(schema.pathType('n.3a'), 'adhocOrUndefined');\n        assert.equal(schema.pathType('n.3.four'), 'adhocOrUndefined');\n        assert.equal(schema.pathType('n.3.4'), 'adhocOrUndefined');\n        assert.equal(schema.pathType('n.3.4a'), 'adhocOrUndefined');\n        assert.equal(schema.pathType('nest.x'), 'adhocOrUndefined');\n        assert.equal(schema.pathType('nest.thing.x'), 'adhocOrUndefined');\n        assert.equal(schema.pathType('nest.thing.nests.9'), 'adhocOrUndefined');\n        assert.equal(schema.pathType('nest.thing.nests.9a'), 'adhocOrUndefined');\n        assert.equal(schema.pathType('nest.thing.nests.a'), 'adhocOrUndefined');\n        done();\n      });\n    });\n\n    it('handles maps (gh-7448) (gh-7464)', function() {\n      const schema = new Schema({ map: { type: Map, of: String } });\n\n      assert.equal(schema.pathType('map.foo'), 'real');\n      assert.equal(schema.pathType('map'), 'real');\n      assert.equal(schema.pathType('mapfoo'), 'adhocOrUndefined');\n      assert.equal(schema.pathType('fake'), 'adhocOrUndefined');\n\n      return Promise.resolve();\n    });\n  });\n\n  it('required() with doc arrays (gh-3199)', function(done) {\n    const schema = new Schema({\n      test: [{ x: String }]\n    });\n\n    schema.path('test').schema.path('x').required(true);\n    const M = mongoose.model('gh3199', schema);\n    const m = new M({ test: [{}] });\n\n    assert.equal(m.validateSync().errors['test.0.x'].kind, 'required');\n    done();\n  });\n\n  it('custom typeKey in doc arrays (gh-3560)', function(done) {\n    const schema = new Schema({\n      test: [{\n        name: { $type: String }\n      }]\n    }, { typeKey: '$type' });\n\n    schema.path('test').schema.path('name').required(true);\n    const M = mongoose.model('gh3560', schema);\n    const m = new M({ test: [{ name: 'Val' }] });\n\n    assert.ifError(m.validateSync());\n    assert.equal(m.test[0].name, 'Val');\n    done();\n  });\n\n  it('required for single nested schemas (gh-3562)', function(done) {\n    const personSchema = new Schema({\n      name: { type: String, required: true }\n    });\n\n    const bandSchema = new Schema({\n      name: String,\n      guitarist: { type: personSchema, required: true }\n    });\n\n    const Band = mongoose.model('gh3562', bandSchema);\n    const band = new Band({ name: 'Guns N\\' Roses' });\n\n    assert.ok(band.validateSync());\n    assert.ok(band.validateSync().errors.guitarist);\n    band.guitarist = { name: 'Slash' };\n    assert.ifError(band.validateSync());\n\n    done();\n  });\n\n  it('booleans cause cast error for date (gh-3935)', function(done) {\n    const testSchema = new Schema({\n      test: Date\n    });\n\n    const Test = mongoose.model('gh3935', testSchema);\n    const test = new Test({ test: true });\n\n    assert.ok(test.validateSync());\n    assert.equal(test.validateSync().errors.test.name, 'CastError');\n\n    done();\n  });\n\n  it('trim: false works with strings (gh-4042)', function(done) {\n    const testSchema = new Schema({\n      test: { type: String, trim: false }\n    });\n\n    const Test = mongoose.model('gh4042', testSchema);\n    const test = new Test({ test: ' test ' });\n    assert.equal(test.test, ' test ');\n    done();\n  });\n\n  it('arrays with typeKey (gh-4548)', function(done) {\n    const testSchema = new Schema({\n      test: [{ $type: String }]\n    }, { typeKey: '$type' });\n\n    assert.equal(testSchema.paths.test.caster.instance, 'String');\n\n    const Test = mongoose.model('gh4548', testSchema);\n    const test = new Test({ test: [123] });\n    assert.strictEqual(test.test[0], '123');\n    done();\n  });\n\n  it('arrays of mixed arrays (gh-5416)', function(done) {\n    const testSchema = new Schema({\n      test: [Array]\n    });\n\n    assert.ok(testSchema.paths.test.casterConstructor !== Array);\n    assert.equal(testSchema.paths.test.casterConstructor,\n      mongoose.Schema.Types.Array);\n\n    done();\n  });\n\n  describe('remove()', function() {\n    before(function() {\n      this.schema = new Schema({\n        a: String,\n        b: {\n          c: {\n            d: String\n          }\n        },\n        e: Number,\n        f: String,\n        g: [String]\n      });\n    });\n\n    it('returns the schema instance', function() {\n      const ret = this.schema.clone().remove('g');\n      assert.ok(ret instanceof Schema);\n    });\n\n    it('removes a single path', function(done) {\n      assert.ok(this.schema.paths.a);\n      this.schema.remove('a');\n      assert.strictEqual(this.schema.path('a'), undefined);\n      assert.strictEqual(this.schema.paths.a, void 0);\n      done();\n    });\n\n    it('removes a nested path', function(done) {\n      this.schema.remove('b.c.d');\n      assert.strictEqual(this.schema.path('b'), undefined);\n      assert.strictEqual(this.schema.path('b.c'), undefined);\n      assert.strictEqual(this.schema.path('b.c.d'), undefined);\n      done();\n    });\n\n    it('removes all children of a nested path (gh-2398)', function(done) {\n      this.schema.remove('b');\n      assert.strictEqual(this.schema.nested['b'], undefined);\n      assert.strictEqual(this.schema.nested['b.c'], undefined);\n      assert.strictEqual(this.schema.path('b.c.d'), undefined);\n      done();\n    });\n\n    it('removes an array of paths', function(done) {\n      this.schema.remove(['e', 'f', 'g']);\n      assert.strictEqual(this.schema.path('e'), undefined);\n      assert.strictEqual(this.schema.path('f'), undefined);\n      assert.strictEqual(this.schema.path('g'), undefined);\n      done();\n    });\n\n    it('works properly with virtuals (gh-2398)', function(done) {\n      this.schema.remove('a');\n      this.schema.virtual('a').get(function() { return 42; });\n      const Test = mongoose.model('gh2398', this.schema);\n      const t = new Test();\n      assert.equal(t.a, 42);\n      done();\n    });\n\n    it('methods named toString (gh-4551)', function() {\n      this.schema.methods.toString = function() {\n        return 'test';\n      };\n      assert.doesNotThrow(() => {\n        mongoose.model('gh4551', this.schema);\n      });\n    });\n\n    it('handles default value = 0 (gh-4620)', function(done) {\n      const schema = new Schema({\n        tags: { type: [Number], default: 0 }\n      });\n      assert.deepEqual(schema.path('tags').getDefault().toObject(), [0]);\n      done();\n    });\n\n    it('type: childSchema (gh-5521)', function(done) {\n      const childSchema = new mongoose.Schema({\n        name: String\n      }, { _id: false });\n\n      const schema = new mongoose.Schema({\n        children: [{ type: childSchema }]\n      });\n\n      const Model = mongoose.model('gh5521', schema);\n\n      const doc = new Model({ children: [{ name: 'test' }] });\n      assert.deepEqual(doc.toObject().children, [{ name: 'test' }]);\n      done();\n    });\n\n    it('Decimal128 type (gh-4759)', function(done) {\n      const Decimal128 = mongoose.Schema.Types.Decimal128;\n      const schema = new Schema({\n        num: Decimal128,\n        nums: ['Decimal128']\n      });\n      assert.ok(schema.path('num') instanceof Decimal128);\n      assert.ok(schema.path('nums').caster instanceof Decimal128);\n\n      const casted = schema.path('num').cast('6.2e+23');\n      assert.ok(casted instanceof mongoose.Types.Decimal128);\n      assert.equal(casted.toString(), '6.2E+23');\n      done();\n    });\n\n    describe('clone()', function() {\n      it('copies methods, statics, and query helpers (gh-5752)', function(done) {\n        const schema = new Schema({});\n\n        schema.methods.fakeMethod = function() { return 'fakeMethod'; };\n        schema.statics.fakeStatic = function() { return 'fakeStatic'; };\n        schema.query.fakeQueryHelper = function() { return 'fakeQueryHelper'; };\n\n        const clone = schema.clone();\n        assert.equal(clone.methods.fakeMethod, schema.methods.fakeMethod);\n        assert.equal(clone.statics.fakeStatic, schema.statics.fakeStatic);\n        assert.equal(clone.query.fakeQueryHelper, schema.query.fakeQueryHelper);\n        done();\n      });\n\n      it('copies validators declared with validate() (gh-5607)', function(done) {\n        const schema = new Schema({\n          num: Number\n        });\n\n        schema.path('num').validate(function(v) {\n          return v === 42;\n        });\n\n        const clone = schema.clone();\n        assert.equal(clone.path('num').validators.length, 1);\n        assert.ok(clone.path('num').validators[0].validator(42));\n        assert.ok(!clone.path('num').validators[0].validator(41));\n        done();\n      });\n\n      it('copies virtuals (gh-6133)', function(done) {\n        const userSchema = new Schema({\n          firstName: { type: String, required: true },\n          lastName: { type: String, required: true }\n        });\n\n        userSchema.virtual('fullName').get(function() {\n          return this.firstName + ' ' + this.lastName;\n        });\n\n        assert.ok(userSchema.virtuals.fullName);\n        const clonedUserSchema = userSchema.clone();\n        assert.ok(clonedUserSchema.virtuals.fullName);\n\n        done();\n      });\n\n      it('with nested virtuals (gh-6274)', function(done) {\n        const PersonSchema = new Schema({\n          name: {\n            first: String,\n            last: String\n          }\n        });\n\n        PersonSchema.\n          virtual('name.full').\n          get(function() {\n            return this.get('name.first') + ' ' + this.get('name.last');\n          }).\n          set(function(fullName) {\n            const split = fullName.split(' ');\n            this.set('name.first', split[0]);\n            this.set('name.last', split[1]);\n          });\n\n        const M = db.model('Test', PersonSchema.clone());\n\n        const doc = new M({ name: { first: 'Axl', last: 'Rose' } });\n        assert.equal(doc.name.full, 'Axl Rose');\n\n        done();\n      });\n\n      it('with alternative option syntaxes (gh-6274)', function(done) {\n        const TestSchema = new Schema({}, { _id: false, id: false });\n\n        TestSchema.virtual('test').get(() => 42);\n\n        TestSchema.set('toJSON', { virtuals: true });\n        TestSchema.options.toObject = { virtuals: true };\n\n        const clone = TestSchema.clone();\n        assert.deepEqual(clone._userProvidedOptions, {\n          toJSON: { virtuals: true },\n          _id: false,\n          id: false\n        });\n        const M = db.model('Test', clone);\n\n        const doc = new M({});\n\n        assert.deepEqual(doc.toJSON(), { test: 42 });\n        assert.deepEqual(doc.toObject(), { test: 42 });\n\n        done();\n      });\n\n      it('copies base for using custom types after cloning (gh-7377)', function() {\n        const db = new mongoose.Mongoose();\n\n        class MyType extends mongoose.SchemaType {}\n        db.Schema.Types.MyType = MyType;\n\n        const schema = new db.Schema({ name: MyType });\n        const otherSchema = schema.clone();\n\n        assert.doesNotThrow(function() {\n          otherSchema.add({ name2: MyType });\n        });\n      });\n\n      it('clones schema types (gh-7537)', function() {\n        const schema = new Schema({ name: String });\n\n        assert.equal(schema.path('name').validators.length, 0);\n        const otherSchema = schema.clone();\n\n        otherSchema.path('name').required();\n\n        assert.equal(otherSchema.path('name').validators.length, 1);\n        assert.equal(schema.path('name').validators.length, 0);\n      });\n\n      it('correctly copies all child schemas (gh-7537)', function() {\n        const l3Schema = new Schema({ name: String });\n        const l2Schema = new Schema({ l3: l3Schema });\n        const l1Schema = new Schema({ l2: l2Schema });\n\n        assert.equal(l1Schema.childSchemas.length, 1);\n        assert.ok(l1Schema.childSchemas[0].schema.path('l3'));\n\n        const otherSchema = l1Schema.clone();\n\n        assert.equal(otherSchema.childSchemas.length, 1);\n        assert.ok(otherSchema.childSchemas[0].schema.path('l3'));\n      });\n\n      it('copies single embedded discriminators (gh-7894)', function() {\n        const colorSchema = new Schema({}, { discriminatorKey: 'type' });\n        colorSchema.methods.isYellow = () => false;\n\n        const yellowSchema = new Schema();\n        yellowSchema.methods.isYellow = () => true;\n\n        const fruitSchema = new Schema({}, { discriminatorKey: 'type' });\n\n        const bananaSchema = new Schema({ color: { type: colorSchema } });\n        bananaSchema.path('color').discriminator('yellow', yellowSchema);\n        bananaSchema.methods.isYellow = function() { return this.color.isYellow(); };\n\n        const schema = new Schema({ fruits: [fruitSchema] });\n\n        const clone = bananaSchema.clone();\n        schema.path('fruits').discriminator('banana', clone);\n        assert.ok(clone.path('color').caster.discriminators);\n\n        const Basket = db.model('Test', schema);\n        const b = new Basket({\n          fruits: [\n            {\n              type: 'banana',\n              color: { type: 'yellow' }\n            }\n          ]\n        });\n\n        assert.ok(b.fruits[0].isYellow());\n      });\n\n      it('copies array discriminators (gh-7954)', function() {\n        const eventSchema = Schema({ message: String }, {\n          discriminatorKey: 'kind',\n          _id: false\n        });\n\n        const batchSchema = Schema({ events: [eventSchema] }, {\n          _id: false\n        });\n\n        const docArray = batchSchema.path('events');\n        docArray.discriminator('gh7954_Clicked',\n          Schema({ element: String }, { _id: false }));\n        docArray.discriminator('gh7954_Purchased',\n          Schema({ product: String }, { _id: false }));\n\n        const clone = batchSchema.clone();\n        assert.ok(clone.path('events').Constructor.discriminators);\n        assert.ok(clone.path('events').Constructor.discriminators['gh7954_Clicked']);\n        assert.ok(clone.path('events').Constructor.discriminators['gh7954_Purchased']);\n      });\n\n      it('uses Mongoose instance\\'s Schema constructor (gh-9426)', function() {\n        const db = new mongoose.Mongoose();\n        db.Schema.prototype.localTest = function() {\n          return 42;\n        };\n        const test = new db.Schema({});\n        assert.equal(test.localTest(), 42);\n\n        const test2 = test.clone();\n        assert.equal(test2.localTest(), 42);\n      });\n    });\n\n    it('childSchemas prop (gh-5695)', function(done) {\n      const schema1 = new Schema({ name: String });\n      const schema2 = new Schema({ test: String });\n      let schema = new Schema({\n        arr: [schema1],\n        single: schema2\n      });\n\n      assert.equal(schema.childSchemas.length, 2);\n      assert.strictEqual(schema.childSchemas[0].schema, schema1);\n      assert.strictEqual(schema.childSchemas[1].schema, schema2);\n\n      schema = schema.clone();\n      assert.equal(schema.childSchemas.length, 2);\n      assert.strictEqual(schema.childSchemas[0].schema, schema1);\n      assert.strictEqual(schema.childSchemas[1].schema, schema2);\n\n      done();\n    });\n  });\n\n  it('throws a sane error if passing a schema to `ref` (gh-6915)', function() {\n    const testSchema = new Schema({ name: String });\n\n    assert.throws(function() {\n      new Schema({ badRef: { type: String, ref: testSchema } });\n    }, /Invalid ref at path \"badRef\"/);\n\n    const parentSchema = new Schema({ name: String });\n    assert.throws(function() {\n      parentSchema.add({ badRef2: { type: String, ref: testSchema } });\n    }, /Invalid ref at path \"badRef2\"/);\n\n    assert.ok(!parentSchema.tree.badRef2);\n    assert.deepEqual(Object.keys(parentSchema.paths).sort(), ['_id', 'name']);\n\n    return Promise.resolve();\n  });\n\n  it('allows using ObjectId type as schema path (gh-7049)', function() {\n    const testSchema = new Schema({\n      p1: mongoose.Types.ObjectId,\n      p2: require('mongodb').ObjectId\n    });\n\n    assert.ok(testSchema.path('p1') instanceof mongoose.ObjectId);\n    assert.ok(testSchema.path('p2') instanceof mongoose.ObjectId);\n\n    return Promise.resolve();\n  });\n\n  it('throws error if invalid type (gh-7303)', function() {\n    assert.throws(() => {\n      new Schema({\n        bad: true\n      });\n    }, /invalid.*true.*bad/i);\n\n    return Promise.resolve();\n  });\n\n  it('supports _id: false in paths definition (gh-7480) (gh-7524)', function() {\n    const schema = new Schema({ _id: false, name: String });\n    assert.ok(schema.path('_id') == null);\n    assert.equal(schema.options._id, false);\n\n    const otherSchema = new Schema({ name: String, nested: { _id: false, name: String } });\n    assert.ok(otherSchema.path('_id'));\n    assert.equal(otherSchema.options._id, true);\n\n    return Promise.resolve();\n  });\n\n  it('schema.pathType() with positional path that isnt in schema (gh-7935)', function() {\n    const subdocSchema = Schema({\n      list: { type: [String], default: ['a'] }\n    }, { minimize: false });\n    const testSchema = Schema({\n      lists: subdocSchema\n    });\n\n    assert.strictEqual(testSchema.pathType('subpaths.list.0.options'),\n      'adhocOrUndefined');\n  });\n\n  it('supports pre(Array, Function) and post(Array, Function) (gh-7803)', function() {\n    const schema = Schema({ name: String });\n    schema.pre(['save', 'remove'], testMiddleware);\n    function testMiddleware() {\n      console.log('foo');\n    }\n\n    assert.equal(schema.s.hooks._pres.get('save').length, 1);\n    assert.equal(schema.s.hooks._pres.get('save')[0].fn, testMiddleware);\n    assert.equal(schema.s.hooks._pres.get('remove').length, 1);\n    assert.equal(schema.s.hooks._pres.get('remove')[0].fn, testMiddleware);\n\n    schema.post(['save', 'remove'], testMiddleware);\n    assert.equal(schema.s.hooks._posts.get('save').length, 1);\n    assert.equal(schema.s.hooks._posts.get('save')[0].fn, testMiddleware);\n    assert.equal(schema.s.hooks._posts.get('remove').length, 1);\n    assert.equal(schema.s.hooks._posts.get('remove')[0].fn, testMiddleware);\n  });\n\n  it('supports array with { type: ObjectID } (gh-8034)', function() {\n    const schema = Schema({ testId: [{ type: 'ObjectID' }] });\n    const path = schema.path('testId');\n    assert.ok(path);\n    assert.ok(path.caster instanceof Schema.ObjectId);\n  });\n\n  it('supports getting path under array (gh-8057)', function() {\n    const schema = new Schema({ arr: [{ name: String }] });\n    assert.ok(schema.path('arr.name') instanceof SchemaTypes.String);\n    assert.ok(schema.path('arr.0.name') instanceof SchemaTypes.String);\n  });\n\n  it('required paths with clone() (gh-8111)', function() {\n    const schema = Schema({ field: { type: String, required: true } });\n    const Model = db.model('Test', schema.clone());\n\n    const doc = new Model({});\n\n    return doc.validate().then(() => assert.ok(false), err => {\n      assert.ok(err);\n      assert.ok(err.errors['field']);\n    });\n  });\n\n  it('getters/setters with clone() (gh-8124)', function() {\n    const schema = new mongoose.Schema({\n      field: { type: String, required: true }\n    });\n\n    schema.path('field').set(value => value ? value.toUpperCase() : value);\n\n    const TestKo = db.model('Test', schema.clone());\n\n    const testKo = new TestKo({ field: 'upper' });\n    assert.equal(testKo.field, 'UPPER');\n  });\n\n  it('required with nullish value (gh-8219)', function() {\n    const schema = Schema({\n      name: { type: String, required: void 0 },\n      age: { type: Number, required: null }\n    });\n    assert.strictEqual(schema.path('name').isRequired, false);\n    assert.strictEqual(schema.path('age').isRequired, false);\n  });\n\n  it('SchemaStringOptions line up with schema/string (gh-8256)', function() {\n    const SchemaStringOptions = require('../lib/options/SchemaStringOptions');\n    const keys = Object.keys(SchemaStringOptions.prototype).\n      filter(key => key !== 'constructor' && key !== 'populate');\n    const functions = Object.keys(Schema.Types.String.prototype).\n      filter(key => ['constructor', 'cast', 'castForQuery', 'checkRequired'].indexOf(key) === -1);\n    assert.deepEqual(keys.sort(), functions.sort());\n  });\n\n  it('supports passing schema options to `Schema#path()` (gh-8292)', function() {\n    const schema = Schema({ title: String });\n    const path = schema.path('title');\n\n    const newSchema = Schema({});\n    newSchema.add({ title: path.options });\n\n    assert.equal(newSchema.path('title').options.type, String);\n  });\n\n  it('supports defining `_id: false` on single nested paths (gh-8137)', function() {\n    let childSchema = Schema({ name: String });\n    let parentSchema = Schema({\n      child: {\n        type: childSchema,\n        _id: false\n      }\n    });\n\n    assert.ok(!parentSchema.path('child').schema.options._id);\n    assert.ok(childSchema.options._id);\n\n    let Parent = mongoose.model('gh8137', parentSchema);\n    let doc = new Parent({ child: { name: 'test' } });\n    assert.equal(doc.child._id, null);\n\n    childSchema = Schema({ name: String }, { _id: false });\n    parentSchema = Schema({\n      child: {\n        type: childSchema,\n        _id: true\n      }\n    });\n\n    assert.ok(parentSchema.path('child').schema.options._id);\n    assert.ok(parentSchema.path('child').schema.paths['_id']);\n    assert.ok(!childSchema.options._id);\n    assert.ok(!childSchema.paths['_id']);\n\n    mongoose.deleteModel(/gh8137/);\n    Parent = mongoose.model('gh8137', parentSchema);\n    doc = new Parent({ child: { name: 'test' } });\n    assert.ok(doc.child._id);\n  });\n\n  it('supports defining `_id: false` on document arrays (gh-8450)', function() {\n    const nestedSchema = Schema({ some: String });\n    let parentSchema = Schema({\n      arrayed: {\n        type: [{\n          type: nestedSchema,\n          _id: false\n        }]\n      }\n    });\n\n    assert.ok(!parentSchema.path('arrayed').schema.path('_id'));\n\n    parentSchema = Schema({\n      arrayed: {\n        type: [{\n          type: nestedSchema\n        }],\n        _id: false\n      }\n    });\n\n    assert.ok(!parentSchema.path('arrayed').schema.path('_id'));\n\n    parentSchema = Schema({\n      arrayed: {\n        type: [{\n          type: nestedSchema\n        }]\n      }\n    });\n\n    assert.ok(parentSchema.path('arrayed').schema.path('_id').auto);\n  });\n\n  describe('pick() (gh-8207)', function() {\n    it('works with nested paths', function() {\n      const schema = Schema({\n        name: {\n          first: {\n            type: String,\n            required: true\n          },\n          last: {\n            type: String,\n            required: true\n          }\n        },\n        age: {\n          type: Number,\n          index: true\n        }\n      });\n      assert.ok(schema.path('name.first'));\n      assert.ok(schema.path('name.last'));\n\n      let newSchema = schema.pick(['age']);\n      assert.ok(!newSchema.path('name.first'));\n      assert.ok(newSchema.path('age'));\n      assert.ok(newSchema.path('age').index);\n\n      newSchema = schema.pick(['name']);\n      assert.ok(newSchema.path('name.first'));\n      assert.ok(newSchema.path('name.first').required);\n      assert.ok(newSchema.path('name.last'));\n      assert.ok(newSchema.path('name.last').required);\n      assert.ok(!newSchema.path('age'));\n\n      newSchema = schema.pick(['name.first']);\n      assert.ok(newSchema.path('name.first'));\n      assert.ok(newSchema.path('name.first').required);\n      assert.ok(!newSchema.path('name.last'));\n      assert.ok(!newSchema.path('age'));\n    });\n\n    it('with single nested paths', function() {\n      const schema = Schema({\n        name: Schema({\n          first: {\n            type: String,\n            required: true\n          },\n          last: {\n            type: String,\n            required: true\n          }\n        }),\n        age: {\n          type: Number,\n          index: true\n        }\n      });\n      assert.ok(schema.path('name.first'));\n      assert.ok(schema.path('name.last'));\n\n      let newSchema = schema.pick(['name']);\n      assert.ok(newSchema.path('name.first'));\n      assert.ok(newSchema.path('name.first').required);\n      assert.ok(newSchema.path('name.last'));\n      assert.ok(newSchema.path('name.last').required);\n      assert.ok(!newSchema.path('age'));\n\n      newSchema = schema.pick(['name.first']);\n      assert.ok(newSchema.path('name.first'));\n      assert.ok(newSchema.path('name.first').required);\n      assert.ok(!newSchema.path('name.last'));\n      assert.ok(!newSchema.path('age'));\n    });\n  });\n\n  describe('path-level custom cast (gh-8300)', function() {\n    it('with numbers', function() {\n      const schema = Schema({\n        num: {\n          type: Number,\n          cast: '{VALUE} is not a number'\n        }\n      });\n\n      let threw = false;\n      try {\n        schema.path('num').cast('horseradish');\n      } catch (err) {\n        threw = true;\n        assert.equal(err.name, 'CastError');\n        assert.equal(err.message, '\"horseradish\" is not a number');\n      }\n      assert.ok(threw);\n    });\n\n    it('with objectids', function() {\n      const schema = Schema({\n        userId: {\n          type: mongoose.ObjectId,\n          cast: 'Invalid user ID'\n        }\n      });\n\n      let threw = false;\n      try {\n        schema.path('userId').cast('foo');\n      } catch (err) {\n        threw = true;\n        assert.equal(err.name, 'CastError');\n        assert.equal(err.message, 'Invalid user ID');\n      }\n      assert.ok(threw);\n    });\n\n    it('with boolean', function() {\n      const schema = Schema({\n        vote: {\n          type: Boolean,\n          cast: '{VALUE} is invalid at path {PATH}'\n        }\n      });\n\n      let threw = false;\n      try {\n        schema.path('vote').cast('nay');\n      } catch (err) {\n        threw = true;\n        assert.equal(err.name, 'CastError');\n        assert.equal(err.message, '\"nay\" is invalid at path vote');\n      }\n      assert.ok(threw);\n    });\n  });\n\n  it('copies `.add()`-ed paths when calling `.add()` with a schema argument (gh-8429)', function() {\n    const ToySchema = Schema();\n    ToySchema.add({ name: String, color: String, price: Number });\n\n    const TurboManSchema = Schema();\n    TurboManSchema.add(ToySchema).add({ year: Number });\n\n    assert.equal(TurboManSchema.path('name').instance, 'String');\n    assert.equal(TurboManSchema.path('color').instance, 'String');\n    assert.equal(TurboManSchema.path('price').instance, 'Number');\n    assert.equal(TurboManSchema.path('year').instance, 'Number');\n  });\n\n  describe('gh-8849', function() {\n    it('treats `select: undefined` as not specifying `select` option', async function() {\n      const userSchema = new Schema({ name: { type: String, select: undefined } });\n      const User = db.model('User', userSchema);\n\n\n      await User.create({ name: 'Hafez' });\n      const user = await User.findOne();\n\n      assert.equal(user.name, 'Hafez');\n    });\n\n    it('treats `select: null` as not specifying `select` option', async function() {\n      const userSchema = new Schema({ name: { type: String, select: null } });\n      const User = db.model('User', userSchema);\n\n\n      await User.create({ name: 'Hafez' });\n      const user = await User.findOne();\n\n      assert.equal(user.name, 'Hafez');\n    });\n  });\n\n  it('disables `id` virtual if no `_id` path (gh-3936)', function() {\n    const schema = Schema({ name: String }, { _id: false });\n    applyPlugins(schema, [[idGetter]]);\n    assert.ok(!schema.paths._id);\n    assert.ok(!schema.virtuals.id);\n  });\n\n  describe('mongoose.set(`strictQuery`, value); (gh-6658)', function() {\n    let strictQueryOriginalValue;\n\n    this.beforeEach(() => strictQueryOriginalValue = mongoose.get('strictQuery'));\n    this.afterEach(() => mongoose.set('strictQuery', strictQueryOriginalValue));\n\n    it('setting `strictQuery` on base sets strictQuery to schema (gh-6658)', function() {\n      // Arrange\n      mongoose.set('strictQuery', 'some value');\n\n      // Act\n      const schema = new Schema();\n\n      // Assert\n      assert.equal(schema.get('strictQuery'), 'some value');\n    });\n\n    it('`strictQuery` set on base gets overwritten by option set on schema (gh-6658)', function() {\n      // Arrange\n      mongoose.set('strictQuery', 'base option');\n\n      // Act\n      const schema = new Schema({}, { strictQuery: 'schema option' });\n\n      // Assert\n      assert.equal(schema.get('strictQuery'), 'schema option');\n    });\n  });\n\n  it('treats dotted paths with no parent as a nested path (gh-9020)', function() {\n    const customerSchema = new Schema({\n      'card.brand': String,\n      'card.last4': String\n    });\n\n    assert.ok(customerSchema.nested['card']);\n  });\n\n  it('allows using `mongoose.Schema.Types.Array` as type (gh-9194)', function() {\n    const schema = new Schema({\n      arr: mongoose.Schema.Types.Array\n    });\n\n    assert.equal(schema.path('arr').caster.instance, 'Mixed');\n  });\n\n  it('handles using a schematype when defining a path (gh-9370)', function() {\n    const schema1 = Schema({\n      foo: {\n        type: Number,\n        min: 4,\n        get: get\n      }\n    });\n\n    function get(v) {\n      return Math.floor(v);\n    }\n\n    const schema2 = Schema({\n      bar: schema1.path('foo')\n    });\n\n    const schematype = schema2.path('bar');\n    assert.equal(schematype.path, 'bar');\n    assert.equal(schematype.options.type, Number);\n    assert.equal(schematype.options.min, 4);\n    assert.equal(schematype.options.get, get);\n  });\n\n  it('applies correct schema to nested primitive arrays (gh-9429)', function() {\n    const schema = new Schema({\n      ids: [[{ type: 'ObjectId', required: true }]]\n    });\n\n    const casted = schema.path('ids').cast([[]]);\n    assert.equal(casted[0].$path(), 'ids.$');\n  });\n\n  describe('cast option (gh-8407)', function() {\n    it('disable casting using `false`', function() {\n      const schema = Schema({\n        myId: { type: 'ObjectId', cast: false },\n        myNum: { type: 'number', cast: false },\n        myDate: { type: Date, cast: false },\n        myBool: { type: Boolean, cast: false },\n        myStr: { type: String, cast: false }\n      });\n\n      assert.throws(() => schema.path('myId').cast('12charstring'), /Cast to ObjectId failed/);\n      assert.throws(() => schema.path('myNum').cast('foo'), /Cast to Number failed/);\n      assert.throws(() => schema.path('myDate').cast('2012'), /Cast to date failed/);\n      assert.throws(() => schema.path('myBool').cast('true'), /Cast to Boolean failed/);\n      assert.throws(() => schema.path('myStr').cast(55), /Cast to string failed/);\n\n      schema.path('myId').cast(new mongoose.Types.ObjectId());\n      schema.path('myNum').cast(42);\n      schema.path('myDate').cast(new Date());\n      schema.path('myBool').cast(false);\n      schema.path('myStr').cast('Hello, World');\n    });\n\n    it('custom casters', function() {\n      const schema = Schema({\n        myId: {\n          type: 'ObjectId',\n          cast: v => new mongoose.Types.ObjectId(v)\n        },\n        myNum: {\n          type: 'number',\n          cast: v => Math.ceil(v)\n        },\n        myDate: { type: Date, cast: v => new Date(v) },\n        myBool: { type: Boolean, cast: v => !!v },\n        myStr: { type: String, cast: v => '' + v }\n      });\n\n      assert.equal(schema.path('myId').cast('12charstring').toHexString(), '313263686172737472696e67');\n      assert.equal(schema.path('myNum').cast(3.14), 4);\n      assert.equal(schema.path('myDate').cast('2012-06-01').getFullYear(), 2012);\n      assert.equal(schema.path('myBool').cast('hello'), true);\n      assert.equal(schema.path('myStr').cast(42), '42');\n\n      assert.throws(() => schema.path('myId').cast('bad'), /Cast to ObjectId failed/);\n    });\n  });\n\n  it('supports `of` for array type definition (gh-9564)', function() {\n    const schema = new Schema({\n      nums: { type: Array, of: Number },\n      tags: { type: 'array', of: String },\n      subdocs: { type: Array, of: Schema({ name: String }) }\n    });\n\n    assert.equal(schema.path('nums').caster.instance, 'Number');\n    assert.equal(schema.path('tags').caster.instance, 'String');\n    assert.equal(schema.path('subdocs').casterConstructor.schema.path('name').instance, 'String');\n  });\n\n  it('should use the top-most class\\'s getter/setter gh-8892', function() {\n    class C1 {\n      get hello() {\n        return 1;\n      }\n    }\n\n    class C2 extends C1 {\n      get hello() {\n        return 2;\n      }\n    }\n\n    const C1Schema = new mongoose.Schema({});\n    C1Schema.loadClass(C1);\n    const C1Model = db.model('C1', C1Schema);\n\n    const C2Schema = new mongoose.Schema({});\n    C2Schema.loadClass(C2);\n    const C2Model = db.model('C2', C2Schema);\n\n    assert.equal((new C1Model()).hello, 1);\n    assert.equal((new C2Model()).hello, 2);\n  });\n\n  it('handles loadClass with inheritted getters (gh-9975)', function() {\n    class User {\n      get displayAs() {\n        return null;\n      }\n    }\n\n    class TechnicalUser extends User {\n      get displayAs() {\n        return this.name;\n      }\n    }\n\n    const schema = new Schema({ name: String }).loadClass(TechnicalUser);\n\n    assert.equal(schema.virtuals.displayAs.applyGetters(null, { name: 'test' }), 'test');\n  });\n\n  it('loadClass with static getter (gh-10436)', function() {\n    const schema = new mongoose.Schema({\n      firstName: String,\n      lastName: String\n    });\n\n    class UserClass extends mongoose.Model {\n      get fullName() {\n        return `${this.firstName} ${this.lastName}`;\n      }\n\n      static get greeting() {\n        return 'Hello World';\n      }\n    }\n\n    const User = mongoose.model(UserClass, schema);\n\n    assert.equal(User.greeting, 'Hello World');\n  });\n\n  it('supports setting `ref` on array SchemaType (gh-10029)', function() {\n    const testSchema = new mongoose.Schema({\n      doesntpopulate: {\n        type: [mongoose.Schema.Types.ObjectId],\n        ref: 'features'\n      },\n      populatescorrectly: [{\n        type: mongoose.Schema.Types.ObjectId,\n        ref: 'features'\n      }]\n    });\n\n    assert.equal(testSchema.path('doesntpopulate.$').options.ref, 'features');\n    assert.equal(testSchema.path('populatescorrectly.$').options.ref, 'features');\n  });\n\n  it('path() gets single nested paths within document arrays (gh-10164)', function() {\n    const schema = mongoose.Schema({\n      field1: [mongoose.Schema({\n        field2: mongoose.Schema({\n          field3: Boolean\n        })\n      })]\n    });\n\n    assert.equal(schema.path('field1').instance, 'Array');\n    assert.equal(schema.path('field1.field2').instance, 'Embedded');\n    assert.equal(schema.path('field1.field2.field3').instance, 'Boolean');\n  });\n\n  it('supports creating nested paths underneath document arrays (gh-10193)', function() {\n    const DynamicTextMatchFeaturesSchema = new Schema({ css: { color: String } });\n\n    const ElementSchema = new Schema({\n      image: { type: String },\n      possibleElements: [{\n        textMatchFeatures: {\n          dynamic: DynamicTextMatchFeaturesSchema\n        }\n      }]\n    });\n\n    assert.ok(ElementSchema.path('possibleElements').schema.path('textMatchFeatures.dynamic').schema.nested['css']);\n  });\n\n  it('propagates map `ref` down to individual map elements (gh-10329)', function() {\n    const TestSchema = new mongoose.Schema({\n      testprop: {\n        type: Map,\n        of: Number,\n        ref: 'OtherModel'\n      }\n    });\n\n    assert.equal(TestSchema.path('testprop.$*').instance, 'Number');\n    assert.equal(TestSchema.path('testprop.$*').options.ref, 'OtherModel');\n  });\n\n  it('handles maps of maps (gh-10644)', function() {\n    const schema = new mongoose.Schema({\n      myMap: {\n        type: Map,\n        of: {\n          type: Map,\n          of: String\n        }\n      }\n    });\n    assert.equal(schema.path('myMap').$__schemaType.$__schemaType.instance, 'String');\n  });\n\n  it('handles `type: { subpath: String }` in document array definitions (gh-10750)', function() {\n    const schema = new mongoose.Schema({\n      something: [{ type: { somePath: String } }],\n      // also, same error message when doing:\n      somethingElse: { type: [{ type: { somePath: String } }] }\n    });\n\n    assert.equal(schema.path('something').caster.schema.path('somePath').instance, 'String');\n    assert.equal(schema.path('somethingElse').caster.schema.path('somePath').instance, 'String');\n  });\n\n  it('handles `Date` with `type` (gh-10807)', function() {\n    Date.type = Date;\n    const schema = new mongoose.Schema({\n      something: Date,\n      somethingElse: { type: Date, immutable: true }\n    });\n\n    assert.equal(schema.path('something').instance, 'Date');\n    assert.equal(schema.path('somethingElse').instance, 'Date');\n    delete Date.type;\n  });\n  it('setting path with `Mixed` type to an array after number (gh-11417)', async() => {\n    const userSchema = new Schema({ data: {} });\n    const User = db.model('User', userSchema);\n\n    const user = await User.create({ data: 2 });\n    user.set({ data: [] });\n    await user.save();\n    assert.ok(Array.isArray(user.data));\n\n    const foundUser = await User.findOne({ _id: user._id });\n    assert.ok(Array.isArray(foundUser.data));\n  });\n\n  it('sets an _applyDiscriminators property on the schema and add discriminator to appropriate model (gh-7971)', async() => {\n    const eventSchema = new mongoose.Schema({ message: String },\n      { discriminatorKey: 'kind' });\n    const batchSchema = new mongoose.Schema({ name: String }, { discriminatorKey: 'kind' });\n    batchSchema.discriminator('event', eventSchema);\n    assert(batchSchema._applyDiscriminators);\n    assert.ok(!eventSchema._applyDiscriminators);\n\n    const arraySchema = new mongoose.Schema({ array: [batchSchema] });\n    const arrayModel = db.model('array', arraySchema);\n    const array = await arrayModel.create({\n      array: [{ name: 'Array Test', message: 'Please work', kind: 'event' }]\n    });\n    assert(array.array[0].message);\n\n    const parentSchema = new mongoose.Schema({ sub: batchSchema });\n    const Parent = db.model('Parent', parentSchema);\n    const parent = await Parent.create({\n      sub: { name: 'Sub Test', message: 'I hope I worked!', kind: 'event' }\n    });\n    assert(parent.sub.message);\n\n    const Batch = db.model('Batch', batchSchema);\n    const batch = await Batch.create({\n      name: 'Test Testerson',\n      message: 'Hello World!',\n      kind: 'event'\n    });\n    assert(batch.message);\n  });\n\n  it('can use on as a schema property (gh-11580)', async() => {\n    const testSchema = new mongoose.Schema({\n      on: String\n    });\n    const Test = db.model('gh11580', testSchema);\n    await Test.create({\n      on: 'Test'\n    });\n    const result = await Test.findOne();\n    assert.ok(result);\n    assert.ok(result.on);\n  });\n\n  it('disallows using schemas with schema-level projections with map subdocuments (gh-11698)', async function() {\n    const subSchema = new Schema({\n      selected: { type: Number },\n      not_selected: { type: Number, select: false }\n    });\n\n    assert.throws(() => {\n      new Schema({\n        subdocument_mapping: {\n          type: Map,\n          of: subSchema\n        }\n      });\n    }, /Cannot use schema-level projections.*subdocument_mapping.not_selected/);\n  });\n});\n"], "fixing_code": ["'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst EventEmitter = require('events').EventEmitter;\nconst Kareem = require('kareem');\nconst MongooseError = require('./error/mongooseError');\nconst SchemaType = require('./schematype');\nconst SchemaTypeOptions = require('./options/SchemaTypeOptions');\nconst VirtualOptions = require('./options/VirtualOptions');\nconst VirtualType = require('./virtualtype');\nconst addAutoId = require('./helpers/schema/addAutoId');\nconst get = require('./helpers/get');\nconst getConstructorName = require('./helpers/getConstructorName');\nconst getIndexes = require('./helpers/schema/getIndexes');\nconst idGetter = require('./helpers/schema/idGetter');\nconst merge = require('./helpers/schema/merge');\nconst mpath = require('mpath');\nconst readPref = require('./driver').get().ReadPreference;\nconst setupTimestamps = require('./helpers/timestamps/setupTimestamps');\nconst utils = require('./utils');\nconst validateRef = require('./helpers/populate/validateRef');\nconst util = require('util');\n\nlet MongooseTypes;\n\nconst queryHooks = require('./helpers/query/applyQueryMiddleware').\n  middlewareFunctions;\nconst documentHooks = require('./helpers/model/applyHooks').middlewareFunctions;\nconst hookNames = queryHooks.concat(documentHooks).\n  reduce((s, hook) => s.add(hook), new Set());\n\nconst isPOJO = utils.isPOJO;\n\nlet id = 0;\n\n/**\n * Schema constructor.\n *\n * #### Example:\n *\n *     const child = new Schema({ name: String });\n *     const schema = new Schema({ name: String, age: Number, children: [child] });\n *     const Tree = mongoose.model('Tree', schema);\n *\n *     // setting schema options\n *     new Schema({ name: String }, { _id: false, autoIndex: false })\n *\n * #### Options:\n *\n * - [autoIndex](/docs/guide.html#autoIndex): bool - defaults to null (which means use the connection's autoIndex option)\n * - [autoCreate](/docs/guide.html#autoCreate): bool - defaults to null (which means use the connection's autoCreate option)\n * - [bufferCommands](/docs/guide.html#bufferCommands): bool - defaults to true\n * - [bufferTimeoutMS](/docs/guide.html#bufferTimeoutMS): number - defaults to 10000 (10 seconds). If `bufferCommands` is enabled, the amount of time Mongoose will wait for connectivity to be restablished before erroring out.\n * - [capped](/docs/guide.html#capped): bool | number | object - defaults to false\n * - [collection](/docs/guide.html#collection): string - no default\n * - [discriminatorKey](/docs/guide.html#discriminatorKey): string - defaults to `__t`\n * - [id](/docs/guide.html#id): bool - defaults to true\n * - [_id](/docs/guide.html#_id): bool - defaults to true\n * - [minimize](/docs/guide.html#minimize): bool - controls [document#toObject](#document_Document-toObject) behavior when called manually - defaults to true\n * - [read](/docs/guide.html#read): string\n * - [writeConcern](/docs/guide.html#writeConcern): object - defaults to null, use to override [the MongoDB server's default write concern settings](https://docs.mongodb.com/manual/reference/write-concern/)\n * - [shardKey](/docs/guide.html#shardKey): object - defaults to `null`\n * - [strict](/docs/guide.html#strict): bool - defaults to true\n * - [strictQuery](/docs/guide.html#strictQuery): bool - defaults to false\n * - [toJSON](/docs/guide.html#toJSON) - object - no default\n * - [toObject](/docs/guide.html#toObject) - object - no default\n * - [typeKey](/docs/guide.html#typeKey) - string - defaults to 'type'\n * - [validateBeforeSave](/docs/guide.html#validateBeforeSave) - bool - defaults to `true`\n * - [versionKey](/docs/guide.html#versionKey): string or object - defaults to \"__v\"\n * - [optimisticConcurrency](/docs/guide.html#optimisticConcurrency): bool - defaults to false. Set to true to enable [optimistic concurrency](https://thecodebarbarian.com/whats-new-in-mongoose-5-10-optimistic-concurrency.html).\n * - [collation](/docs/guide.html#collation): object - defaults to null (which means use no collation)\n * - [timeseries](/docs/guide.html#timeseries): object - defaults to null (which means this schema's collection won't be a timeseries collection)\n * - [selectPopulatedPaths](/docs/guide.html#selectPopulatedPaths): boolean - defaults to `true`\n * - [skipVersioning](/docs/guide.html#skipVersioning): object - paths to exclude from versioning\n * - [timestamps](/docs/guide.html#timestamps): object or boolean - defaults to `false`. If true, Mongoose adds `createdAt` and `updatedAt` properties to your schema and manages those properties for you.\n * - [pluginTags](/docs/guide.html#pluginTags): array of strings - defaults to `undefined`. If set and plugin called with `tags` option, will only apply that plugin to schemas with a matching tag.\n *\n * #### Options for Nested Schemas:\n *\n * - `excludeIndexes`: bool - defaults to `false`. If `true`, skip building indexes on this schema's paths.\n *\n * #### Note:\n *\n * _When nesting schemas, (`children` in the example above), always declare the child schema first before passing it into its parent._\n *\n * @param {Object|Schema|Array} [definition] Can be one of: object describing schema paths, or schema to copy, or array of objects and schemas\n * @param {Object} [options]\n * @inherits NodeJS EventEmitter https://nodejs.org/api/events.html#events_class_events_eventemitter\n * @event `init`: Emitted after the schema is compiled into a `Model`.\n * @api public\n */\n\nfunction Schema(obj, options) {\n  if (!(this instanceof Schema)) {\n    return new Schema(obj, options);\n  }\n\n  this.obj = obj;\n  this.paths = {};\n  this.aliases = {};\n  this.subpaths = {};\n  this.virtuals = {};\n  this.singleNestedPaths = {};\n  this.nested = {};\n  this.inherits = {};\n  this.callQueue = [];\n  this._indexes = [];\n  this.methods = (options && options.methods) || {};\n  this.methodOptions = {};\n  this.statics = (options && options.statics) || {};\n  this.tree = {};\n  this.query = (options && options.query) || {};\n  this.childSchemas = [];\n  this.plugins = [];\n  // For internal debugging. Do not use this to try to save a schema in MDB.\n  this.$id = ++id;\n  this.mapPaths = [];\n\n  this.s = {\n    hooks: new Kareem()\n  };\n  this.options = this.defaultOptions(options);\n\n  // build paths\n  if (Array.isArray(obj)) {\n    for (const definition of obj) {\n      this.add(definition);\n    }\n  } else if (obj) {\n    this.add(obj);\n  }\n\n  // check if _id's value is a subdocument (gh-2276)\n  const _idSubDoc = obj && obj._id && utils.isObject(obj._id);\n\n  // ensure the documents get an auto _id unless disabled\n  const auto_id = !this.paths['_id'] &&\n      (this.options._id) && !_idSubDoc;\n\n  if (auto_id) {\n    addAutoId(this);\n  }\n\n  this.setupTimestamp(this.options.timestamps);\n}\n\n/*!\n * Create virtual properties with alias field\n */\nfunction aliasFields(schema, paths) {\n  paths = paths || Object.keys(schema.paths);\n  for (const path of paths) {\n    const options = get(schema.paths[path], 'options');\n    if (options == null) {\n      continue;\n    }\n\n    const prop = schema.paths[path].path;\n    const alias = options.alias;\n\n    if (!alias) {\n      continue;\n    }\n\n    if (typeof alias !== 'string') {\n      throw new Error('Invalid value for alias option on ' + prop + ', got ' + alias);\n    }\n\n    schema.aliases[alias] = prop;\n\n    schema.\n      virtual(alias).\n      get((function(p) {\n        return function() {\n          if (typeof this.get === 'function') {\n            return this.get(p);\n          }\n          return this[p];\n        };\n      })(prop)).\n      set((function(p) {\n        return function(v) {\n          return this.$set(p, v);\n        };\n      })(prop));\n  }\n}\n\n/*!\n * Inherit from EventEmitter.\n */\nSchema.prototype = Object.create(EventEmitter.prototype);\nSchema.prototype.constructor = Schema;\nSchema.prototype.instanceOfSchema = true;\n\n/*!\n * ignore\n */\n\nObject.defineProperty(Schema.prototype, '$schemaType', {\n  configurable: false,\n  enumerable: false,\n  writable: true\n});\n\n/**\n * Array of child schemas (from document arrays and single nested subdocs)\n * and their corresponding compiled models. Each element of the array is\n * an object with 2 properties: `schema` and `model`.\n *\n * This property is typically only useful for plugin authors and advanced users.\n * You do not need to interact with this property at all to use mongoose.\n *\n * @api public\n * @property childSchemas\n * @memberOf Schema\n * @instance\n */\n\nObject.defineProperty(Schema.prototype, 'childSchemas', {\n  configurable: false,\n  enumerable: true,\n  writable: true\n});\n\n/**\n * Object containing all virtuals defined on this schema.\n * The objects' keys are the virtual paths and values are instances of `VirtualType`.\n *\n * This property is typically only useful for plugin authors and advanced users.\n * You do not need to interact with this property at all to use mongoose.\n *\n * #### Example:\n *\n *     const schema = new Schema({});\n *     schema.virtual('answer').get(() => 42);\n *\n *     console.log(schema.virtuals); // { answer: VirtualType { path: 'answer', ... } }\n *     console.log(schema.virtuals['answer'].getters[0].call()); // 42\n *\n * @api public\n * @property virtuals\n * @memberOf Schema\n * @instance\n */\n\nObject.defineProperty(Schema.prototype, 'virtuals', {\n  configurable: false,\n  enumerable: true,\n  writable: true\n});\n\n/**\n * The original object passed to the schema constructor\n *\n * #### Example:\n *\n *     const schema = new Schema({ a: String }).add({ b: String });\n *     schema.obj; // { a: String }\n *\n * @api public\n * @property obj\n * @memberOf Schema\n * @instance\n */\n\nSchema.prototype.obj;\n\n/**\n * The paths defined on this schema. The keys are the top-level paths\n * in this schema, and the values are instances of the SchemaType class.\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: String }, { _id: false });\n *     schema.paths; // { name: SchemaString { ... } }\n *\n *     schema.add({ age: Number });\n *     schema.paths; // { name: SchemaString { ... }, age: SchemaNumber { ... } }\n *\n * @api public\n * @property paths\n * @memberOf Schema\n * @instance\n */\n\nSchema.prototype.paths;\n\n/**\n * Schema as a tree\n *\n * #### Example:\n *\n *     {\n *         '_id'     : ObjectId\n *       , 'nested'  : {\n *             'key' : String\n *         }\n *     }\n *\n * @api private\n * @property tree\n * @memberOf Schema\n * @instance\n */\n\nSchema.prototype.tree;\n\n/**\n * Returns a deep copy of the schema\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: String });\n *     const clone = schema.clone();\n *     clone === schema; // false\n *     clone.path('name'); // SchemaString { ... }\n *\n * @return {Schema} the cloned schema\n * @api public\n * @memberOf Schema\n * @instance\n */\n\nSchema.prototype.clone = function() {\n  const s = this._clone();\n\n  // Bubble up `init` for backwards compat\n  s.on('init', v => this.emit('init', v));\n\n  return s;\n};\n\n/*!\n * ignore\n */\n\nSchema.prototype._clone = function _clone(Constructor) {\n  Constructor = Constructor || (this.base == null ? Schema : this.base.Schema);\n\n  const s = new Constructor({}, this._userProvidedOptions);\n  s.base = this.base;\n  s.obj = this.obj;\n  s.options = utils.clone(this.options);\n  s.callQueue = this.callQueue.map(function(f) { return f; });\n  s.methods = utils.clone(this.methods);\n  s.methodOptions = utils.clone(this.methodOptions);\n  s.statics = utils.clone(this.statics);\n  s.query = utils.clone(this.query);\n  s.plugins = Array.prototype.slice.call(this.plugins);\n  s._indexes = utils.clone(this._indexes);\n  s.s.hooks = this.s.hooks.clone();\n\n  s.tree = utils.clone(this.tree);\n  s.paths = utils.clone(this.paths);\n  s.nested = utils.clone(this.nested);\n  s.subpaths = utils.clone(this.subpaths);\n  s.singleNestedPaths = utils.clone(this.singleNestedPaths);\n  s.childSchemas = gatherChildSchemas(s);\n\n  s.virtuals = utils.clone(this.virtuals);\n  s.$globalPluginsApplied = this.$globalPluginsApplied;\n  s.$isRootDiscriminator = this.$isRootDiscriminator;\n  s.$implicitlyCreated = this.$implicitlyCreated;\n  s.$id = ++id;\n  s.$originalSchemaId = this.$id;\n  s.mapPaths = [].concat(this.mapPaths);\n\n  if (this.discriminatorMapping != null) {\n    s.discriminatorMapping = Object.assign({}, this.discriminatorMapping);\n  }\n  if (this.discriminators != null) {\n    s.discriminators = Object.assign({}, this.discriminators);\n  }\n  if (this._applyDiscriminators != null) {\n    s._applyDiscriminators = Object.assign({}, this._applyDiscriminators);\n  }\n\n  s.aliases = Object.assign({}, this.aliases);\n\n  return s;\n};\n\n/**\n * Returns a new schema that has the picked `paths` from this schema.\n *\n * This method is analagous to [Lodash's `pick()` function](https://lodash.com/docs/4.17.15#pick) for Mongoose schemas.\n *\n * #### Example:\n *\n *     const schema = Schema({ name: String, age: Number });\n *     // Creates a new schema with the same `name` path as `schema`,\n *     // but no `age` path.\n *     const newSchema = schema.pick(['name']);\n *\n *     newSchema.path('name'); // SchemaString { ... }\n *     newSchema.path('age'); // undefined\n *\n * @param {String[]} paths List of Paths to pick for the new Schema\n * @param {Object} [options] Options to pass to the new Schema Constructor (same as `new Schema(.., Options)`). Defaults to `this.options` if not set.\n * @return {Schema}\n * @api public\n */\n\nSchema.prototype.pick = function(paths, options) {\n  const newSchema = new Schema({}, options || this.options);\n  if (!Array.isArray(paths)) {\n    throw new MongooseError('Schema#pick() only accepts an array argument, ' +\n      'got \"' + typeof paths + '\"');\n  }\n\n  for (const path of paths) {\n    if (this.nested[path]) {\n      newSchema.add({ [path]: get(this.tree, path) });\n    } else {\n      const schematype = this.path(path);\n      if (schematype == null) {\n        throw new MongooseError('Path `' + path + '` is not in the schema');\n      }\n      newSchema.add({ [path]: schematype });\n    }\n  }\n\n  return newSchema;\n};\n\n/**\n * Returns default options for this schema, merged with `options`.\n *\n * @param {Object} [options] Options to overwrite the default options\n * @return {Object} The merged options of `options` and the default options\n * @api private\n */\n\nSchema.prototype.defaultOptions = function(options) {\n  this._userProvidedOptions = options == null ? {} : utils.clone(options);\n  const baseOptions = this.base && this.base.options || {};\n\n  const strict = 'strict' in baseOptions ? baseOptions.strict : true;\n  options = utils.options({\n    strict: strict,\n    strictQuery: 'strict' in this._userProvidedOptions ?\n      this._userProvidedOptions.strict :\n      'strictQuery' in baseOptions ?\n        baseOptions.strictQuery : strict,\n    bufferCommands: true,\n    capped: false, // { size, max, autoIndexId }\n    versionKey: '__v',\n    optimisticConcurrency: false,\n    minimize: true,\n    autoIndex: null,\n    discriminatorKey: '__t',\n    shardKey: null,\n    read: null,\n    validateBeforeSave: true,\n    // the following are only applied at construction time\n    _id: true,\n    id: true,\n    typeKey: 'type'\n  }, utils.clone(options));\n\n  if (options.read) {\n    options.read = readPref(options.read);\n  }\n\n  if (options.versionKey && typeof options.versionKey !== 'string') {\n    throw new MongooseError('`versionKey` must be falsy or string, got `' + (typeof options.versionKey) + '`');\n  }\n\n  if (options.optimisticConcurrency && !options.versionKey) {\n    throw new MongooseError('Must set `versionKey` if using `optimisticConcurrency`');\n  }\n\n  return options;\n};\n\n/**\n * Inherit a Schema by applying a discriminator on an existing Schema.\n *\n *\n * #### Example:\n *\n *     const options = { discriminatorKey: 'kind' };\n *\n *     const eventSchema = new mongoose.Schema({ time: Date }, options);\n *     const Event = mongoose.model('Event', eventSchema);\n *\n *     // ClickedLinkEvent is a special type of Event that has\n *     // a URL.\n *     const ClickedLinkEvent = Event.discriminator('ClickedLink',\n *     new mongoose.Schema({ url: String }, options));\n *\n *     // When you create a generic event, it can't have a URL field...\n *     const genericEvent = new Event({ time: Date.now(), url: 'google.com' });\n *     assert.ok(!genericEvent.url);\n *     // But a ClickedLinkEvent can\n *     const clickedEvent = new ClickedLinkEvent({ time: Date.now(), url: 'google.com' });\n *     assert.ok(clickedEvent.url);\n *\n * @param {String} name the name of the discriminator\n * @param {Schema} schema the Schema of the discriminated Schema\n * @return {Schema} the Schema instance\n * @api public\n */\n\nSchema.prototype.discriminator = function(name, schema) {\n  this._applyDiscriminators = Object.assign(this._applyDiscriminators || {}, { [name]: schema });\n\n  return this;\n};\n\n/**\n * Adds key path / schema type pairs to this schema.\n *\n * #### Example:\n *\n *     const ToySchema = new Schema();\n *     ToySchema.add({ name: 'string', color: 'string', price: 'number' });\n *\n *     const TurboManSchema = new Schema();\n *     // You can also `add()` another schema and copy over all paths, virtuals,\n *     // getters, setters, indexes, methods, and statics.\n *     TurboManSchema.add(ToySchema).add({ year: Number });\n *\n * @param {Object|Schema} obj plain object with paths to add, or another schema\n * @param {String} [prefix] path to prefix the newly added paths with\n * @return {Schema} the Schema instance\n * @api public\n */\n\nSchema.prototype.add = function add(obj, prefix) {\n  if (obj instanceof Schema || (obj != null && obj.instanceOfSchema)) {\n    merge(this, obj);\n\n    return this;\n  }\n\n  // Special case: setting top-level `_id` to false should convert to disabling\n  // the `_id` option. This behavior never worked before 5.4.11 but numerous\n  // codebases use it (see gh-7516, gh-7512).\n  if (obj._id === false && prefix == null) {\n    this.options._id = false;\n  }\n\n  prefix = prefix || '';\n  // avoid prototype pollution\n  if (prefix === '__proto__.' || prefix === 'constructor.' || prefix === 'prototype.') {\n    return this;\n  }\n\n  const keys = Object.keys(obj);\n  const typeKey = this.options.typeKey;\n  for (const key of keys) {\n    if (utils.specialProperties.has(key)) {\n      continue;\n    }\n\n    const fullPath = prefix + key;\n    const val = obj[key];\n\n    if (val == null) {\n      throw new TypeError('Invalid value for schema path `' + fullPath +\n        '`, got value \"' + val + '\"');\n    }\n    // Retain `_id: false` but don't set it as a path, re: gh-8274.\n    if (key === '_id' && val === false) {\n      continue;\n    }\n    if (val instanceof VirtualType || (val.constructor && val.constructor.name || null) === 'VirtualType') {\n      this.virtual(val);\n      continue;\n    }\n\n    if (Array.isArray(val) && val.length === 1 && val[0] == null) {\n      throw new TypeError('Invalid value for schema Array path `' + fullPath +\n        '`, got value \"' + val[0] + '\"');\n    }\n\n    if (!(isPOJO(val) || val instanceof SchemaTypeOptions)) {\n      // Special-case: Non-options definitely a path so leaf at this node\n      // Examples: Schema instances, SchemaType instances\n      if (prefix) {\n        this.nested[prefix.substring(0, prefix.length - 1)] = true;\n      }\n      this.path(prefix + key, val);\n      if (val[0] != null && !(val[0].instanceOfSchema) && utils.isPOJO(val[0].discriminators)) {\n        const schemaType = this.path(prefix + key);\n        for (const key in val[0].discriminators) {\n          schemaType.discriminator(key, val[0].discriminators[key]);\n        }\n      } else if (val[0] != null && val[0].instanceOfSchema && utils.isPOJO(val[0]._applyDiscriminators)) {\n        const applyDiscriminators = val[0]._applyDiscriminators || [];\n        const schemaType = this.path(prefix + key);\n        for (const disc in applyDiscriminators) {\n          schemaType.discriminator(disc, applyDiscriminators[disc]);\n        }\n      }\n      else if (val != null && val.instanceOfSchema && utils.isPOJO(val._applyDiscriminators)) {\n        const applyDiscriminators = val._applyDiscriminators || [];\n        const schemaType = this.path(prefix + key);\n        for (const disc in applyDiscriminators) {\n          schemaType.discriminator(disc, applyDiscriminators[disc]);\n        }\n      }\n    } else if (Object.keys(val).length < 1) {\n      // Special-case: {} always interpreted as Mixed path so leaf at this node\n      if (prefix) {\n        this.nested[prefix.substring(0, prefix.length - 1)] = true;\n      }\n      this.path(fullPath, val); // mixed type\n    } else if (!val[typeKey] || (typeKey === 'type' && isPOJO(val.type) && val.type.type)) {\n      // Special-case: POJO with no bona-fide type key - interpret as tree of deep paths so recurse\n      // nested object `{ last: { name: String } }`. Avoid functions with `.type` re: #10807 because\n      // NestJS sometimes adds `Date.type`.\n      this.nested[fullPath] = true;\n      this.add(val, fullPath + '.');\n    } else {\n      // There IS a bona-fide type key that may also be a POJO\n      const _typeDef = val[typeKey];\n      if (isPOJO(_typeDef) && Object.keys(_typeDef).length > 0) {\n        // If a POJO is the value of a type key, make it a subdocument\n        if (prefix) {\n          this.nested[prefix.substring(0, prefix.length - 1)] = true;\n        }\n        const _schema = new Schema(_typeDef);\n        const schemaWrappedPath = Object.assign({}, val, { type: _schema });\n        this.path(prefix + key, schemaWrappedPath);\n      } else {\n        // Either the type is non-POJO or we interpret it as Mixed anyway\n        if (prefix) {\n          this.nested[prefix.substring(0, prefix.length - 1)] = true;\n        }\n        this.path(prefix + key, val);\n        if (val != null && !(val.instanceOfSchema) && utils.isPOJO(val.discriminators)) {\n          const schemaType = this.path(prefix + key);\n          for (const key in val.discriminators) {\n            schemaType.discriminator(key, val.discriminators[key]);\n          }\n        }\n      }\n    }\n  }\n\n  const addedKeys = Object.keys(obj).\n    map(key => prefix ? prefix + key : key);\n  aliasFields(this, addedKeys);\n  return this;\n};\n\n/**\n * Remove an index by name or index specification.\n *\n * removeIndex only removes indexes from your schema object. Does **not** affect the indexes\n * in MongoDB.\n *\n * #### Example:\n *\n *     const ToySchema = new Schema({ name: String, color: String, price: Number });\n *\n *     // Add a new index on { name, color }\n *     ToySchema.index({ name: 1, color: 1 });\n *\n *     // Remove index on { name, color }\n *     // Keep in mind that order matters! `removeIndex({ color: 1, name: 1 })` won't remove the index\n *     ToySchema.removeIndex({ name: 1, color: 1 });\n *\n *     // Add an index with a custom name\n *     ToySchema.index({ color: 1 }, { name: 'my custom index name' });\n *     // Remove index by name\n *     ToySchema.removeIndex('my custom index name');\n *\n * @param {Object|string} index name or index specification\n * @return {Schema} the Schema instance\n * @api public\n */\n\nSchema.prototype.removeIndex = function removeIndex(index) {\n  if (arguments.length > 1) {\n    throw new Error('removeIndex() takes only 1 argument');\n  }\n\n  if (typeof index !== 'object' && typeof index !== 'string') {\n    throw new Error('removeIndex() may only take either an object or a string as an argument');\n  }\n\n  if (typeof index === 'object') {\n    for (let i = this._indexes.length - 1; i >= 0; --i) {\n      if (util.isDeepStrictEqual(this._indexes[i][0], index)) {\n        this._indexes.splice(i, 1);\n      }\n    }\n  } else {\n    for (let i = this._indexes.length - 1; i >= 0; --i) {\n      if (this._indexes[i][1] != null && this._indexes[i][1].name === index) {\n        this._indexes.splice(i, 1);\n      }\n    }\n  }\n\n  return this;\n};\n\n/**\n * Remove all indexes from this schema.\n *\n * clearIndexes only removes indexes from your schema object. Does **not** affect the indexes\n * in MongoDB.\n *\n * #### Example:\n *\n *     const ToySchema = new Schema({ name: String, color: String, price: Number });\n *     ToySchema.index({ name: 1 });\n *     ToySchema.index({ color: 1 });\n *\n *     // Remove all indexes on this schema\n *     ToySchema.clearIndexes();\n *\n *     ToySchema.indexes(); // []\n *\n * @return {Schema} the Schema instance\n * @api public\n */\n\nSchema.prototype.clearIndexes = function clearIndexes() {\n  this._indexes.length = 0;\n\n  return this;\n};\n\n/**\n * Reserved document keys.\n *\n * Keys in this object are names that are warned in schema declarations\n * because they have the potential to break Mongoose/ Mongoose plugins functionality. If you create a schema\n * using `new Schema()` with one of these property names, Mongoose will log a warning.\n *\n * - _posts\n * - _pres\n * - collection\n  * - emit\n * - errors\n * - get\n * - init\n * - isModified\n * - isNew\n * - listeners\n * - modelName\n * - on\n * - once\n * - populated\n * - prototype\n * - remove\n * - removeListener\n * - save\n * - schema\n * - toObject\n * - validate\n *\n * _NOTE:_ Use of these terms as method names is permitted, but play at your own risk, as they may be existing mongoose document methods you are stomping on.\n *\n *      const schema = new Schema(..);\n *      schema.methods.init = function () {} // potentially breaking\n *\n * @property reserved\n * @memberOf Schema\n * @static\n */\n\nSchema.reserved = Object.create(null);\nSchema.prototype.reserved = Schema.reserved;\n\nconst reserved = Schema.reserved;\n// Core object\nreserved['prototype'] =\n// EventEmitter\nreserved.emit =\nreserved.listeners =\nreserved.removeListener =\n\n// document properties and functions\nreserved.collection =\nreserved.errors =\nreserved.get =\nreserved.init =\nreserved.isModified =\nreserved.isNew =\nreserved.populated =\nreserved.remove =\nreserved.save =\nreserved.toObject =\nreserved.validate = 1;\nreserved.collection = 1;\n\n/**\n * Gets/sets schema paths.\n *\n * Sets a path (if arity 2)\n * Gets a path (if arity 1)\n *\n * #### Example:\n *\n *     schema.path('name') // returns a SchemaType\n *     schema.path('name', Number) // changes the schemaType of `name` to Number\n *\n * @param {String} path The name of the Path to get / set\n * @param {Object} [obj] The Type to set the path to, if provided the path will be SET, otherwise the path will be GET\n * @api public\n */\n\nSchema.prototype.path = function(path, obj) {\n  // Convert to '.$' to check subpaths re: gh-6405\n  const cleanPath = _pathToPositionalSyntax(path);\n  if (obj === undefined) {\n    let schematype = _getPath(this, path, cleanPath);\n    if (schematype != null) {\n      return schematype;\n    }\n\n    // Look for maps\n    const mapPath = getMapPath(this, path);\n    if (mapPath != null) {\n      return mapPath;\n    }\n\n    // Look if a parent of this path is mixed\n    schematype = this.hasMixedParent(cleanPath);\n    if (schematype != null) {\n      return schematype;\n    }\n\n    // subpaths?\n    return /\\.\\d+\\.?.*$/.test(path)\n      ? getPositionalPath(this, path)\n      : undefined;\n  }\n\n  // some path names conflict with document methods\n  const firstPieceOfPath = path.split('.')[0];\n  if (reserved[firstPieceOfPath] && !this.options.supressReservedKeysWarning) {\n    const errorMessage = `\\`${firstPieceOfPath}\\` is a reserved schema pathname and may break some functionality. ` +\n      'You are allowed to use it, but use at your own risk. ' +\n      'To disable this warning pass `supressReservedKeysWarning` as a schema option.';\n\n    utils.warn(errorMessage);\n  }\n\n  if (typeof obj === 'object' && utils.hasUserDefinedProperty(obj, 'ref')) {\n    validateRef(obj.ref, path);\n  }\n\n  // update the tree\n  const subpaths = path.split(/\\./);\n  const last = subpaths.pop();\n  let branch = this.tree;\n  let fullPath = '';\n\n  for (const sub of subpaths) {\n    if (utils.specialProperties.has(sub)) {\n      throw new Error('Cannot set special property `' + sub + '` on a schema');\n    }\n    fullPath = fullPath += (fullPath.length > 0 ? '.' : '') + sub;\n    if (!branch[sub]) {\n      this.nested[fullPath] = true;\n      branch[sub] = {};\n    }\n    if (typeof branch[sub] !== 'object') {\n      const msg = 'Cannot set nested path `' + path + '`. '\n          + 'Parent path `'\n          + fullPath\n          + '` already set to type ' + branch[sub].name\n          + '.';\n      throw new Error(msg);\n    }\n    branch = branch[sub];\n  }\n\n  branch[last] = utils.clone(obj);\n\n  this.paths[path] = this.interpretAsType(path, obj, this.options);\n  const schemaType = this.paths[path];\n\n  if (schemaType.$isSchemaMap) {\n    // Maps can have arbitrary keys, so `$*` is internal shorthand for \"any key\"\n    // The '$' is to imply this path should never be stored in MongoDB so we\n    // can easily build a regexp out of this path, and '*' to imply \"any key.\"\n    const mapPath = path + '.$*';\n\n    this.paths[mapPath] = schemaType.$__schemaType;\n    this.mapPaths.push(this.paths[mapPath]);\n  }\n\n  if (schemaType.$isSingleNested) {\n    for (const key of Object.keys(schemaType.schema.paths)) {\n      this.singleNestedPaths[path + '.' + key] = schemaType.schema.paths[key];\n    }\n    for (const key of Object.keys(schemaType.schema.singleNestedPaths)) {\n      this.singleNestedPaths[path + '.' + key] =\n        schemaType.schema.singleNestedPaths[key];\n    }\n    for (const key of Object.keys(schemaType.schema.subpaths)) {\n      this.singleNestedPaths[path + '.' + key] =\n        schemaType.schema.subpaths[key];\n    }\n    for (const key of Object.keys(schemaType.schema.nested)) {\n      this.singleNestedPaths[path + '.' + key] = 'nested';\n    }\n\n    Object.defineProperty(schemaType.schema, 'base', {\n      configurable: true,\n      enumerable: false,\n      writable: false,\n      value: this.base\n    });\n\n    schemaType.caster.base = this.base;\n    this.childSchemas.push({\n      schema: schemaType.schema,\n      model: schemaType.caster\n    });\n  } else if (schemaType.$isMongooseDocumentArray) {\n    Object.defineProperty(schemaType.schema, 'base', {\n      configurable: true,\n      enumerable: false,\n      writable: false,\n      value: this.base\n    });\n\n    schemaType.casterConstructor.base = this.base;\n    this.childSchemas.push({\n      schema: schemaType.schema,\n      model: schemaType.casterConstructor\n    });\n  }\n\n  if (schemaType.$isMongooseArray && schemaType.caster instanceof SchemaType) {\n    let arrayPath = path;\n    let _schemaType = schemaType;\n\n    const toAdd = [];\n    while (_schemaType.$isMongooseArray) {\n      arrayPath = arrayPath + '.$';\n\n      // Skip arrays of document arrays\n      if (_schemaType.$isMongooseDocumentArray) {\n        _schemaType.$embeddedSchemaType._arrayPath = arrayPath;\n        _schemaType.$embeddedSchemaType._arrayParentPath = path;\n        _schemaType = _schemaType.$embeddedSchemaType.clone();\n      } else {\n        _schemaType.caster._arrayPath = arrayPath;\n        _schemaType.caster._arrayParentPath = path;\n        _schemaType = _schemaType.caster.clone();\n      }\n\n      _schemaType.path = arrayPath;\n      toAdd.push(_schemaType);\n    }\n\n    for (const _schemaType of toAdd) {\n      this.subpaths[_schemaType.path] = _schemaType;\n    }\n  }\n\n  if (schemaType.$isMongooseDocumentArray) {\n    for (const key of Object.keys(schemaType.schema.paths)) {\n      const _schemaType = schemaType.schema.paths[key];\n      this.subpaths[path + '.' + key] = _schemaType;\n      if (typeof _schemaType === 'object' && _schemaType != null) {\n        _schemaType.$isUnderneathDocArray = true;\n      }\n    }\n    for (const key of Object.keys(schemaType.schema.subpaths)) {\n      const _schemaType = schemaType.schema.subpaths[key];\n      this.subpaths[path + '.' + key] = _schemaType;\n      if (typeof _schemaType === 'object' && _schemaType != null) {\n        _schemaType.$isUnderneathDocArray = true;\n      }\n    }\n    for (const key of Object.keys(schemaType.schema.singleNestedPaths)) {\n      const _schemaType = schemaType.schema.singleNestedPaths[key];\n      this.subpaths[path + '.' + key] = _schemaType;\n      if (typeof _schemaType === 'object' && _schemaType != null) {\n        _schemaType.$isUnderneathDocArray = true;\n      }\n    }\n  }\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nfunction gatherChildSchemas(schema) {\n  const childSchemas = [];\n\n  for (const path of Object.keys(schema.paths)) {\n    const schematype = schema.paths[path];\n    if (schematype.$isMongooseDocumentArray || schematype.$isSingleNested) {\n      childSchemas.push({ schema: schematype.schema, model: schematype.caster });\n    }\n  }\n\n  return childSchemas;\n}\n\n/*!\n * ignore\n */\n\nfunction _getPath(schema, path, cleanPath) {\n  if (schema.paths.hasOwnProperty(path)) {\n    return schema.paths[path];\n  }\n  if (schema.subpaths.hasOwnProperty(cleanPath)) {\n    return schema.subpaths[cleanPath];\n  }\n  if (schema.singleNestedPaths.hasOwnProperty(cleanPath) && typeof schema.singleNestedPaths[cleanPath] === 'object') {\n    return schema.singleNestedPaths[cleanPath];\n  }\n\n  return null;\n}\n\n/*!\n * ignore\n */\n\nfunction _pathToPositionalSyntax(path) {\n  if (!/\\.\\d+/.test(path)) {\n    return path;\n  }\n  return path.replace(/\\.\\d+\\./g, '.$.').replace(/\\.\\d+$/, '.$');\n}\n\n/*!\n * ignore\n */\n\nfunction getMapPath(schema, path) {\n  if (schema.mapPaths.length === 0) {\n    return null;\n  }\n  for (const val of schema.mapPaths) {\n    const _path = val.path;\n    const re = new RegExp('^' + _path.replace(/\\.\\$\\*/g, '\\\\.[^.]+') + '$');\n    if (re.test(path)) {\n      return schema.paths[_path];\n    }\n  }\n\n  return null;\n}\n\n/**\n * The Mongoose instance this schema is associated with\n *\n * @property base\n * @api private\n */\n\nObject.defineProperty(Schema.prototype, 'base', {\n  configurable: true,\n  enumerable: false,\n  writable: true,\n  value: null\n});\n\n/**\n * Converts type arguments into Mongoose Types.\n *\n * @param {String} path\n * @param {Object} obj constructor\n * @param {Object} options\n * @api private\n */\n\nSchema.prototype.interpretAsType = function(path, obj, options) {\n  if (obj instanceof SchemaType) {\n    if (obj.path === path) {\n      return obj;\n    }\n    const clone = obj.clone();\n    clone.path = path;\n    return clone;\n  }\n\n  // If this schema has an associated Mongoose object, use the Mongoose object's\n  // copy of SchemaTypes re: gh-7158 gh-6933\n  const MongooseTypes = this.base != null ? this.base.Schema.Types : Schema.Types;\n\n  if (!utils.isPOJO(obj) && !(obj instanceof SchemaTypeOptions)) {\n    const constructorName = utils.getFunctionName(obj.constructor);\n    if (constructorName !== 'Object') {\n      const oldObj = obj;\n      obj = {};\n      obj[options.typeKey] = oldObj;\n    }\n  }\n\n  // Get the type making sure to allow keys named \"type\"\n  // and default to mixed if not specified.\n  // { type: { type: String, default: 'freshcut' } }\n  let type = obj[options.typeKey] && (obj[options.typeKey] instanceof Function || options.typeKey !== 'type' || !obj.type.type)\n    ? obj[options.typeKey]\n    : {};\n  let name;\n\n  if (utils.isPOJO(type) || type === 'mixed') {\n    return new MongooseTypes.Mixed(path, obj);\n  }\n\n  if (Array.isArray(type) || type === Array || type === 'array' || type === MongooseTypes.Array) {\n    // if it was specified through { type } look for `cast`\n    let cast = (type === Array || type === 'array')\n      ? obj.cast || obj.of\n      : type[0];\n\n    // new Schema({ path: [new Schema({ ... })] })\n    if (cast && cast.instanceOfSchema) {\n      if (!(cast instanceof Schema)) {\n        throw new TypeError('Schema for array path `' + path +\n          '` is from a different copy of the Mongoose module. ' +\n          'Please make sure you\\'re using the same version ' +\n          'of Mongoose everywhere with `npm list mongoose`. If you are still ' +\n          'getting this error, please add `new Schema()` around the path: ' +\n          `${path}: new Schema(...)`);\n      }\n      return new MongooseTypes.DocumentArray(path, cast, obj);\n    }\n    if (cast &&\n        cast[options.typeKey] &&\n        cast[options.typeKey].instanceOfSchema) {\n      if (!(cast[options.typeKey] instanceof Schema)) {\n        throw new TypeError('Schema for array path `' + path +\n          '` is from a different copy of the Mongoose module. ' +\n          'Please make sure you\\'re using the same version ' +\n          'of Mongoose everywhere with `npm list mongoose`. If you are still ' +\n          'getting this error, please add `new Schema()` around the path: ' +\n          `${path}: new Schema(...)`);\n      }\n      return new MongooseTypes.DocumentArray(path, cast[options.typeKey], obj, cast);\n    }\n\n    if (Array.isArray(cast)) {\n      return new MongooseTypes.Array(path, this.interpretAsType(path, cast, options), obj);\n    }\n\n    // Handle both `new Schema({ arr: [{ subpath: String }] })` and `new Schema({ arr: [{ type: { subpath: string } }] })`\n    const castFromTypeKey = (cast != null && cast[options.typeKey] && (options.typeKey !== 'type' || !cast.type.type)) ?\n      cast[options.typeKey] :\n      cast;\n    if (typeof cast === 'string') {\n      cast = MongooseTypes[cast.charAt(0).toUpperCase() + cast.substring(1)];\n    } else if (utils.isPOJO(castFromTypeKey)) {\n      if (Object.keys(castFromTypeKey).length) {\n        // The `minimize` and `typeKey` options propagate to child schemas\n        // declared inline, like `{ arr: [{ val: { $type: String } }] }`.\n        // See gh-3560\n        const childSchemaOptions = { minimize: options.minimize };\n        if (options.typeKey) {\n          childSchemaOptions.typeKey = options.typeKey;\n        }\n        // propagate 'strict' option to child schema\n        if (options.hasOwnProperty('strict')) {\n          childSchemaOptions.strict = options.strict;\n        }\n\n        if (this._userProvidedOptions.hasOwnProperty('_id')) {\n          childSchemaOptions._id = this._userProvidedOptions._id;\n        } else if (Schema.Types.DocumentArray.defaultOptions._id != null) {\n          childSchemaOptions._id = Schema.Types.DocumentArray.defaultOptions._id;\n        }\n        const childSchema = new Schema(castFromTypeKey, childSchemaOptions);\n        childSchema.$implicitlyCreated = true;\n        return new MongooseTypes.DocumentArray(path, childSchema, obj);\n      } else {\n        // Special case: empty object becomes mixed\n        return new MongooseTypes.Array(path, MongooseTypes.Mixed, obj);\n      }\n    }\n\n    if (cast) {\n      type = cast[options.typeKey] && (options.typeKey !== 'type' || !cast.type.type)\n        ? cast[options.typeKey]\n        : cast;\n\n      if (Array.isArray(type)) {\n        return new MongooseTypes.Array(path, this.interpretAsType(path, type, options), obj);\n      }\n\n      name = typeof type === 'string'\n        ? type\n        : type.schemaName || utils.getFunctionName(type);\n\n      // For Jest 26+, see #10296\n      if (name === 'ClockDate') {\n        name = 'Date';\n      }\n\n      if (name === void 0) {\n        throw new TypeError('Invalid schema configuration: ' +\n          `Could not determine the embedded type for array \\`${path}\\`. ` +\n          'See https://mongoosejs.com/docs/guide.html#definition for more info on supported schema syntaxes.');\n      }\n      if (!MongooseTypes.hasOwnProperty(name)) {\n        throw new TypeError('Invalid schema configuration: ' +\n          `\\`${name}\\` is not a valid type within the array \\`${path}\\`.` +\n          'See https://bit.ly/mongoose-schematypes for a list of valid schema types.');\n      }\n    }\n\n    return new MongooseTypes.Array(path, cast || MongooseTypes.Mixed, obj, options);\n  }\n\n  if (type && type.instanceOfSchema) {\n\n    return new MongooseTypes.Subdocument(type, path, obj);\n  }\n\n  if (Buffer.isBuffer(type)) {\n    name = 'Buffer';\n  } else if (typeof type === 'function' || typeof type === 'object') {\n    name = type.schemaName || utils.getFunctionName(type);\n  } else {\n    name = type == null ? '' + type : type.toString();\n  }\n\n  if (name) {\n    name = name.charAt(0).toUpperCase() + name.substring(1);\n  }\n  // Special case re: gh-7049 because the bson `ObjectID` class' capitalization\n  // doesn't line up with Mongoose's.\n  if (name === 'ObjectID') {\n    name = 'ObjectId';\n  }\n  // For Jest 26+, see #10296\n  if (name === 'ClockDate') {\n    name = 'Date';\n  }\n\n  if (name === void 0) {\n    throw new TypeError(`Invalid schema configuration: \\`${path}\\` schematype definition is ` +\n      'invalid. See ' +\n      'https://mongoosejs.com/docs/guide.html#definition for more info on supported schema syntaxes.');\n  }\n  if (MongooseTypes[name] == null) {\n    throw new TypeError(`Invalid schema configuration: \\`${name}\\` is not ` +\n      `a valid type at path \\`${path}\\`. See ` +\n      'https://bit.ly/mongoose-schematypes for a list of valid schema types.');\n  }\n\n  const schemaType = new MongooseTypes[name](path, obj);\n\n  if (schemaType.$isSchemaMap) {\n    createMapNestedSchemaType(this, schemaType, path, obj, options);\n  }\n\n  return schemaType;\n};\n\n/*!\n * ignore\n */\n\nfunction createMapNestedSchemaType(schema, schemaType, path, obj, options) {\n  const mapPath = path + '.$*';\n  let _mapType = { type: {} };\n  if (utils.hasUserDefinedProperty(obj, 'of')) {\n    const isInlineSchema = utils.isPOJO(obj.of) &&\n      Object.keys(obj.of).length > 0 &&\n      !utils.hasUserDefinedProperty(obj.of, schema.options.typeKey);\n    if (isInlineSchema) {\n      _mapType = { [schema.options.typeKey]: new Schema(obj.of) };\n    } else if (utils.isPOJO(obj.of)) {\n      _mapType = Object.assign({}, obj.of);\n    } else {\n      _mapType = { [schema.options.typeKey]: obj.of };\n    }\n\n    if (_mapType[schema.options.typeKey] && _mapType[schema.options.typeKey].instanceOfSchema) {\n      const subdocumentSchema = _mapType[schema.options.typeKey];\n      subdocumentSchema.eachPath((subpath, type) => {\n        if (type.options.select === true || type.options.select === false) {\n          throw new MongooseError('Cannot use schema-level projections (`select: true` or `select: false`) within maps at path \"' + path + '.' + subpath + '\"');\n        }\n      });\n    }\n\n    if (utils.hasUserDefinedProperty(obj, 'ref')) {\n      _mapType.ref = obj.ref;\n    }\n  }\n  schemaType.$__schemaType = schema.interpretAsType(mapPath, _mapType, options);\n}\n\n/**\n * Iterates the schemas paths similar to Array#forEach.\n *\n * The callback is passed the pathname and the schemaType instance.\n *\n * #### Example:\n *\n *     const userSchema = new Schema({ name: String, registeredAt: Date });\n *     userSchema.eachPath((pathname, schematype) => {\n *       // Prints twice:\n *       // name SchemaString { ... }\n *       // registeredAt SchemaDate { ... }\n *       console.log(pathname, schematype);\n *     });\n *\n * @param {Function} fn callback function\n * @return {Schema} this\n * @api public\n */\n\nSchema.prototype.eachPath = function(fn) {\n  const keys = Object.keys(this.paths);\n  const len = keys.length;\n\n  for (let i = 0; i < len; ++i) {\n    fn(keys[i], this.paths[keys[i]]);\n  }\n\n  return this;\n};\n\n/**\n * Returns an Array of path strings that are required by this schema.\n *\n * #### Example:\n *\n *     const s = new Schema({\n *       name: { type: String, required: true },\n *       age: { type: String, required: true },\n *       notes: String\n *     });\n *     s.requiredPaths(); // [ 'age', 'name' ]\n *\n * @api public\n * @param {Boolean} invalidate Refresh the cache\n * @return {Array}\n */\n\nSchema.prototype.requiredPaths = function requiredPaths(invalidate) {\n  if (this._requiredpaths && !invalidate) {\n    return this._requiredpaths;\n  }\n\n  const paths = Object.keys(this.paths);\n  let i = paths.length;\n  const ret = [];\n\n  while (i--) {\n    const path = paths[i];\n    if (this.paths[path].isRequired) {\n      ret.push(path);\n    }\n  }\n  this._requiredpaths = ret;\n  return this._requiredpaths;\n};\n\n/**\n * Returns indexes from fields and schema-level indexes (cached).\n *\n * @api private\n * @return {Array}\n */\n\nSchema.prototype.indexedPaths = function indexedPaths() {\n  if (this._indexedpaths) {\n    return this._indexedpaths;\n  }\n  this._indexedpaths = this.indexes();\n  return this._indexedpaths;\n};\n\n/**\n * Returns the pathType of `path` for this schema.\n *\n * Given a path, returns whether it is a real, virtual, nested, or ad-hoc/undefined path.\n *\n * #### Example:\n *     const s = new Schema({ name: String, nested: { foo: String } });\n *     s.virtual('foo').get(() => 42);\n *     s.pathType('name'); // \"real\"\n *     s.pathType('nested'); // \"nested\"\n *     s.pathType('foo'); // \"virtual\"\n *     s.pathType('fail'); // \"adhocOrUndefined\"\n *\n * @param {String} path\n * @return {String}\n * @api public\n */\n\nSchema.prototype.pathType = function(path) {\n  // Convert to '.$' to check subpaths re: gh-6405\n  const cleanPath = _pathToPositionalSyntax(path);\n\n  if (this.paths.hasOwnProperty(path)) {\n    return 'real';\n  }\n  if (this.virtuals.hasOwnProperty(path)) {\n    return 'virtual';\n  }\n  if (this.nested.hasOwnProperty(path)) {\n    return 'nested';\n  }\n  if (this.subpaths.hasOwnProperty(cleanPath) || this.subpaths.hasOwnProperty(path)) {\n    return 'real';\n  }\n\n  const singleNestedPath = this.singleNestedPaths.hasOwnProperty(cleanPath) || this.singleNestedPaths.hasOwnProperty(path);\n  if (singleNestedPath) {\n    return singleNestedPath === 'nested' ? 'nested' : 'real';\n  }\n\n  // Look for maps\n  const mapPath = getMapPath(this, path);\n  if (mapPath != null) {\n    return 'real';\n  }\n\n  if (/\\.\\d+\\.|\\.\\d+$/.test(path)) {\n    return getPositionalPathType(this, path);\n  }\n  return 'adhocOrUndefined';\n};\n\n/**\n * Returns true iff this path is a child of a mixed schema.\n *\n * @param {String} path\n * @return {Boolean}\n * @api private\n */\n\nSchema.prototype.hasMixedParent = function(path) {\n  const subpaths = path.split(/\\./g);\n  path = '';\n  for (let i = 0; i < subpaths.length; ++i) {\n    path = i > 0 ? path + '.' + subpaths[i] : subpaths[i];\n    if (this.paths.hasOwnProperty(path) &&\n        this.paths[path] instanceof MongooseTypes.Mixed) {\n      return this.paths[path];\n    }\n  }\n\n  return null;\n};\n\n/**\n * Setup updatedAt and createdAt timestamps to documents if enabled\n *\n * @param {Boolean|Object} timestamps timestamps options\n * @api private\n */\nSchema.prototype.setupTimestamp = function(timestamps) {\n  return setupTimestamps(this, timestamps);\n};\n\n/*!\n * ignore. Deprecated re: #6405\n */\n\nfunction getPositionalPathType(self, path) {\n  const subpaths = path.split(/\\.(\\d+)\\.|\\.(\\d+)$/).filter(Boolean);\n  if (subpaths.length < 2) {\n    return self.paths.hasOwnProperty(subpaths[0]) ?\n      self.paths[subpaths[0]] :\n      'adhocOrUndefined';\n  }\n\n  let val = self.path(subpaths[0]);\n  let isNested = false;\n  if (!val) {\n    return 'adhocOrUndefined';\n  }\n\n  const last = subpaths.length - 1;\n\n  for (let i = 1; i < subpaths.length; ++i) {\n    isNested = false;\n    const subpath = subpaths[i];\n\n    if (i === last && val && !/\\D/.test(subpath)) {\n      if (val.$isMongooseDocumentArray) {\n        val = val.$embeddedSchemaType;\n      } else if (val instanceof MongooseTypes.Array) {\n        // StringSchema, NumberSchema, etc\n        val = val.caster;\n      } else {\n        val = undefined;\n      }\n      break;\n    }\n\n    // ignore if its just a position segment: path.0.subpath\n    if (!/\\D/.test(subpath)) {\n      // Nested array\n      if (val instanceof MongooseTypes.Array && i !== last) {\n        val = val.caster;\n      }\n      continue;\n    }\n\n    if (!(val && val.schema)) {\n      val = undefined;\n      break;\n    }\n\n    const type = val.schema.pathType(subpath);\n    isNested = (type === 'nested');\n    val = val.schema.path(subpath);\n  }\n\n  self.subpaths[path] = val;\n  if (val) {\n    return 'real';\n  }\n  if (isNested) {\n    return 'nested';\n  }\n  return 'adhocOrUndefined';\n}\n\n\n/*!\n * ignore\n */\n\nfunction getPositionalPath(self, path) {\n  getPositionalPathType(self, path);\n  return self.subpaths[path];\n}\n\n/**\n * Adds a method call to the queue.\n *\n * #### Example:\n *\n *     schema.methods.print = function() { console.log(this); };\n *     schema.queue('print', []); // Print the doc every one is instantiated\n *\n *     const Model = mongoose.model('Test', schema);\n *     new Model({ name: 'test' }); // Prints '{\"_id\": ..., \"name\": \"test\" }'\n *\n * @param {String} name name of the document method to call later\n * @param {Array} args arguments to pass to the method\n * @api public\n */\n\nSchema.prototype.queue = function(name, args) {\n  this.callQueue.push([name, args]);\n  return this;\n};\n\n/**\n * Defines a pre hook for the model.\n *\n * #### Example:\n *\n *     const toySchema = new Schema({ name: String, created: Date });\n *\n *     toySchema.pre('save', function(next) {\n *       if (!this.created) this.created = new Date;\n *       next();\n *     });\n *\n *     toySchema.pre('validate', function(next) {\n *       if (this.name !== 'Woody') this.name = 'Woody';\n *       next();\n *     });\n *\n *     // Equivalent to calling `pre()` on `find`, `findOne`, `findOneAndUpdate`.\n *     toySchema.pre(/^find/, function(next) {\n *       console.log(this.getFilter());\n *     });\n *\n *     // Equivalent to calling `pre()` on `updateOne`, `findOneAndUpdate`.\n *     toySchema.pre(['updateOne', 'findOneAndUpdate'], function(next) {\n *       console.log(this.getFilter());\n *     });\n *\n *     toySchema.pre('deleteOne', function() {\n *       // Runs when you call `Toy.deleteOne()`\n *     });\n *\n *     toySchema.pre('deleteOne', { document: true }, function() {\n *       // Runs when you call `doc.deleteOne()`\n *     });\n *\n * @param {String|RegExp|String[]} methodName The method name or regular expression to match method name\n * @param {Object} [options]\n * @param {Boolean} [options.document] If `name` is a hook for both document and query middleware, set to `true` to run on document middleware. For example, set `options.document` to `true` to apply this hook to `Document#deleteOne()` rather than `Query#deleteOne()`.\n * @param {Boolean} [options.query] If `name` is a hook for both document and query middleware, set to `true` to run on query middleware.\n * @param {Function} callback\n * @api public\n */\n\nSchema.prototype.pre = function(name) {\n  if (name instanceof RegExp) {\n    const remainingArgs = Array.prototype.slice.call(arguments, 1);\n    for (const fn of hookNames) {\n      if (name.test(fn)) {\n        this.pre.apply(this, [fn].concat(remainingArgs));\n      }\n    }\n    return this;\n  }\n  if (Array.isArray(name)) {\n    const remainingArgs = Array.prototype.slice.call(arguments, 1);\n    for (const el of name) {\n      this.pre.apply(this, [el].concat(remainingArgs));\n    }\n    return this;\n  }\n  this.s.hooks.pre.apply(this.s.hooks, arguments);\n  return this;\n};\n\n/**\n * Defines a post hook for the document\n *\n *     const schema = new Schema(..);\n *     schema.post('save', function (doc) {\n *       console.log('this fired after a document was saved');\n *     });\n *\n *     schema.post('find', function(docs) {\n *       console.log('this fired after you ran a find query');\n *     });\n *\n *     schema.post(/Many$/, function(res) {\n *       console.log('this fired after you ran `updateMany()` or `deleteMany()`');\n *     });\n *\n *     const Model = mongoose.model('Model', schema);\n *\n *     const m = new Model(..);\n *     m.save(function(err) {\n *       console.log('this fires after the `post` hook');\n *     });\n *\n *     m.find(function(err, docs) {\n *       console.log('this fires after the post find hook');\n *     });\n *\n * @param {String|RegExp|String[]} methodName The method name or regular expression to match method name\n * @param {Object} [options]\n * @param {Boolean} [options.document] If `name` is a hook for both document and query middleware, set to `true` to run on document middleware.\n * @param {Boolean} [options.query] If `name` is a hook for both document and query middleware, set to `true` to run on query middleware.\n * @param {Function} fn callback\n * @see middleware https://mongoosejs.com/docs/middleware.html\n * @see kareem https://npmjs.org/package/kareem\n * @api public\n */\n\nSchema.prototype.post = function(name) {\n  if (name instanceof RegExp) {\n    const remainingArgs = Array.prototype.slice.call(arguments, 1);\n    for (const fn of hookNames) {\n      if (name.test(fn)) {\n        this.post.apply(this, [fn].concat(remainingArgs));\n      }\n    }\n    return this;\n  }\n  if (Array.isArray(name)) {\n    const remainingArgs = Array.prototype.slice.call(arguments, 1);\n    for (const el of name) {\n      this.post.apply(this, [el].concat(remainingArgs));\n    }\n    return this;\n  }\n  this.s.hooks.post.apply(this.s.hooks, arguments);\n  return this;\n};\n\n/**\n * Registers a plugin for this schema.\n *\n * #### Example:\n *\n *     const s = new Schema({ name: String });\n *     s.plugin(schema => console.log(schema.path('name').path));\n *     mongoose.model('Test', s); // Prints 'name'\n *\n * Or with Options:\n *\n *     const s = new Schema({ name: String });\n *     s.plugin((schema, opts) => console.log(opts.text, schema.path('name').path), { text: \"Schema Path Name:\" });\n *     mongoose.model('Test', s); // Prints 'Schema Path Name: name'\n *\n * @param {Function} plugin The Plugin's callback\n * @param {Object} [opts] Options to pass to the plugin\n * @see plugins\n * @api public\n */\n\nSchema.prototype.plugin = function(fn, opts) {\n  if (typeof fn !== 'function') {\n    throw new Error('First param to `schema.plugin()` must be a function, ' +\n      'got \"' + (typeof fn) + '\"');\n  }\n\n  if (opts && opts.deduplicate) {\n    for (const plugin of this.plugins) {\n      if (plugin.fn === fn) {\n        return this;\n      }\n    }\n  }\n  this.plugins.push({ fn: fn, opts: opts });\n\n  fn(this, opts);\n  return this;\n};\n\n/**\n * Adds an instance method to documents constructed from Models compiled from this schema.\n *\n * #### Example:\n *\n *     const schema = kittySchema = new Schema(..);\n *\n *     schema.method('meow', function () {\n *       console.log('meeeeeoooooooooooow');\n *     })\n *\n *     const Kitty = mongoose.model('Kitty', schema);\n *\n *     const fizz = new Kitty;\n *     fizz.meow(); // meeeeeooooooooooooow\n *\n * If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as methods.\n *\n *     schema.method({\n *         purr: function () {}\n *       , scratch: function () {}\n *     });\n *\n *     // later\n *     const fizz = new Kitty;\n *     fizz.purr();\n *     fizz.scratch();\n *\n * NOTE: `Schema.method()` adds instance methods to the `Schema.methods` object. You can also add instance methods directly to the `Schema.methods` object as seen in the [guide](/docs/guide.html#methods)\n *\n * @param {String|Object} name The Method Name for a single function, or a Object of \"string-function\" pairs.\n * @param {Function} [fn] The Function in a single-function definition.\n * @api public\n */\n\nSchema.prototype.method = function(name, fn, options) {\n  if (typeof name !== 'string') {\n    for (const i in name) {\n      this.methods[i] = name[i];\n      this.methodOptions[i] = utils.clone(options);\n    }\n  } else {\n    this.methods[name] = fn;\n    this.methodOptions[name] = utils.clone(options);\n  }\n  return this;\n};\n\n/**\n * Adds static \"class\" methods to Models compiled from this schema.\n *\n * #### Example:\n *\n *     const schema = new Schema(..);\n *     // Equivalent to `schema.statics.findByName = function(name) {}`;\n *     schema.static('findByName', function(name) {\n *       return this.find({ name: name });\n *     });\n *\n *     const Drink = mongoose.model('Drink', schema);\n *     await Drink.findByName('LaCroix');\n *\n * If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as methods.\n *\n *     schema.static({\n *         findByName: function () {..}\n *       , findByCost: function () {..}\n *     });\n *\n *     const Drink = mongoose.model('Drink', schema);\n *     await Drink.findByName('LaCroix');\n *     await Drink.findByCost(3);\n *\n * If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as statics.\n *\n * @param {String|Object} name The Method Name for a single function, or a Object of \"string-function\" pairs.\n * @param {Function} [fn] The Function in a single-function definition.\n * @api public\n * @see Statics /docs/guide.html#statics\n */\n\nSchema.prototype.static = function(name, fn) {\n  if (typeof name !== 'string') {\n    for (const i in name) {\n      this.statics[i] = name[i];\n    }\n  } else {\n    this.statics[name] = fn;\n  }\n  return this;\n};\n\n/**\n * Defines an index (most likely compound) for this schema.\n *\n * #### Example:\n *\n *     schema.index({ first: 1, last: -1 })\n *\n * @param {Object} fields The Fields to index, with the order, available values: `1 | -1 | '2d' | '2dsphere' | 'geoHaystack' | 'hashed' | 'text'`\n * @param {Object} [options] Options to pass to [MongoDB driver's `createIndex()` function](https://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#createIndex)\n * @param {String | number} [options.expires=null] Mongoose-specific syntactic sugar, uses [ms](https://www.npmjs.com/package/ms) to convert `expires` option into seconds for the `expireAfterSeconds` in the above link.\n * @api public\n */\n\nSchema.prototype.index = function(fields, options) {\n  fields || (fields = {});\n  options || (options = {});\n\n  if (options.expires) {\n    utils.expires(options);\n  }\n\n  this._indexes.push([fields, options]);\n  return this;\n};\n\n/**\n * Sets a schema option.\n *\n * #### Example:\n *\n *     schema.set('strict'); // 'true' by default\n *     schema.set('strict', false); // Sets 'strict' to false\n *     schema.set('strict'); // 'false'\n *\n * @param {String} key The name of the option to set the value to\n * @param {Object} [value] The value to set the option to, if not passed, the option will be reset to default\n * @see Schema ./\n * @api public\n */\n\nSchema.prototype.set = function(key, value, _tags) {\n  if (arguments.length === 1) {\n    return this.options[key];\n  }\n\n  switch (key) {\n    case 'read':\n      this.options[key] = readPref(value, _tags);\n      this._userProvidedOptions[key] = this.options[key];\n      break;\n    case 'timestamps':\n      this.setupTimestamp(value);\n      this.options[key] = value;\n      this._userProvidedOptions[key] = this.options[key];\n      break;\n    case '_id':\n      this.options[key] = value;\n      this._userProvidedOptions[key] = this.options[key];\n\n      if (value && !this.paths['_id']) {\n        addAutoId(this);\n      } else if (!value && this.paths['_id'] != null && this.paths['_id'].auto) {\n        this.remove('_id');\n      }\n      break;\n    default:\n      this.options[key] = value;\n      this._userProvidedOptions[key] = this.options[key];\n      break;\n  }\n\n  return this;\n};\n\n/**\n * Gets a schema option.\n *\n * #### Example:\n *\n *     schema.get('strict'); // true\n *     schema.set('strict', false);\n *     schema.get('strict'); // false\n *\n * @param {String} key The name of the Option to get the current value for\n * @api public\n * @return {Any} the option's value\n */\n\nSchema.prototype.get = function(key) {\n  return this.options[key];\n};\n\nconst indexTypes = '2d 2dsphere hashed text'.split(' ');\n\n/**\n * The allowed index types\n *\n * @property {String[]} indexTypes\n * @memberOf Schema\n * @static\n * @api public\n */\n\nObject.defineProperty(Schema, 'indexTypes', {\n  get: function() {\n    return indexTypes;\n  },\n  set: function() {\n    throw new Error('Cannot overwrite Schema.indexTypes');\n  }\n});\n\n/**\n * Returns a list of indexes that this schema declares, via `schema.index()` or by `index: true` in a path's options.\n * Indexes are expressed as an array `[spec, options]`.\n *\n * #### Example:\n *\n *     const userSchema = new Schema({\n *       email: { type: String, required: true, unique: true },\n *       registeredAt: { type: Date, index: true }\n *     });\n *\n *     // [ [ { email: 1 }, { unique: true, background: true } ],\n *     //   [ { registeredAt: 1 }, { background: true } ] ]\n *     userSchema.indexes();\n *\n * [Plugins](/docs/plugins.html) can use the return value of this function to modify a schema's indexes.\n * For example, the below plugin makes every index unique by default.\n *\n *     function myPlugin(schema) {\n *       for (const index of schema.indexes()) {\n *         if (index[1].unique === undefined) {\n *           index[1].unique = true;\n *         }\n *       }\n *     }\n *\n * @api public\n * @return {Array} list of indexes defined in the schema\n */\n\nSchema.prototype.indexes = function() {\n  return getIndexes(this);\n};\n\n/**\n * Creates a virtual type with the given name.\n *\n * @param {String} name The name of the Virtual\n * @param {Object} [options]\n * @param {String|Model} [options.ref] model name or model instance. Marks this as a [populate virtual](/docs/populate.html#populate-virtuals).\n * @param {String|Function} [options.localField] Required for populate virtuals. See [populate virtual docs](/docs/populate.html#populate-virtuals) for more information.\n * @param {String|Function} [options.foreignField] Required for populate virtuals. See [populate virtual docs](/docs/populate.html#populate-virtuals) for more information.\n * @param {Boolean|Function} [options.justOne=false] Only works with populate virtuals. If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), will be a single doc or `null`. Otherwise, the populate virtual will be an array.\n * @param {Boolean} [options.count=false] Only works with populate virtuals. If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), this populate virtual will contain the number of documents rather than the documents themselves when you `populate()`.\n * @param {Function|null} [options.get=null] Adds a [getter](/docs/tutorials/getters-setters.html) to this virtual to transform the populated doc.\n * @return {VirtualType}\n */\n\nSchema.prototype.virtual = function(name, options) {\n  if (name instanceof VirtualType || getConstructorName(name) === 'VirtualType') {\n    return this.virtual(name.path, name.options);\n  }\n\n  options = new VirtualOptions(options);\n\n  if (utils.hasUserDefinedProperty(options, ['ref', 'refPath'])) {\n    if (options.localField == null) {\n      throw new Error('Reference virtuals require `localField` option');\n    }\n\n    if (options.foreignField == null) {\n      throw new Error('Reference virtuals require `foreignField` option');\n    }\n\n    this.pre('init', function(obj) {\n      if (mpath.has(name, obj)) {\n        const _v = mpath.get(name, obj);\n        if (!this.$$populatedVirtuals) {\n          this.$$populatedVirtuals = {};\n        }\n\n        if (options.justOne || options.count) {\n          this.$$populatedVirtuals[name] = Array.isArray(_v) ?\n            _v[0] :\n            _v;\n        } else {\n          this.$$populatedVirtuals[name] = Array.isArray(_v) ?\n            _v :\n            _v == null ? [] : [_v];\n        }\n\n        mpath.unset(name, obj);\n      }\n    });\n\n    const virtual = this.virtual(name);\n    virtual.options = options;\n\n    virtual.\n      set(function(_v) {\n        if (!this.$$populatedVirtuals) {\n          this.$$populatedVirtuals = {};\n        }\n\n        if (options.justOne || options.count) {\n          this.$$populatedVirtuals[name] = Array.isArray(_v) ?\n            _v[0] :\n            _v;\n\n          if (typeof this.$$populatedVirtuals[name] !== 'object') {\n            this.$$populatedVirtuals[name] = options.count ? _v : null;\n          }\n        } else {\n          this.$$populatedVirtuals[name] = Array.isArray(_v) ?\n            _v :\n            _v == null ? [] : [_v];\n\n          this.$$populatedVirtuals[name] = this.$$populatedVirtuals[name].filter(function(doc) {\n            return doc && typeof doc === 'object';\n          });\n        }\n      });\n\n    if (typeof options.get === 'function') {\n      virtual.get(options.get);\n    }\n\n    // Workaround for gh-8198: if virtual is under document array, make a fake\n    // virtual. See gh-8210\n    const parts = name.split('.');\n    let cur = parts[0];\n    for (let i = 0; i < parts.length - 1; ++i) {\n      if (this.paths[cur] != null && this.paths[cur].$isMongooseDocumentArray) {\n        const remnant = parts.slice(i + 1).join('.');\n        this.paths[cur].schema.virtual(remnant, options);\n        break;\n      }\n\n      cur += '.' + parts[i + 1];\n    }\n\n    return virtual;\n  }\n\n  const virtuals = this.virtuals;\n  const parts = name.split('.');\n\n  if (this.pathType(name) === 'real') {\n    throw new Error('Virtual path \"' + name + '\"' +\n      ' conflicts with a real path in the schema');\n  }\n\n  virtuals[name] = parts.reduce(function(mem, part, i) {\n    mem[part] || (mem[part] = (i === parts.length - 1)\n      ? new VirtualType(options, name)\n      : {});\n    return mem[part];\n  }, this.tree);\n\n  return virtuals[name];\n};\n\n/**\n * Returns the virtual type with the given `name`.\n *\n * @param {String} name The name of the Virtual to get\n * @return {VirtualType|null}\n */\n\nSchema.prototype.virtualpath = function(name) {\n  return this.virtuals.hasOwnProperty(name) ? this.virtuals[name] : null;\n};\n\n/**\n * Removes the given `path` (or [`paths`]).\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: String, age: Number });\n *     schema.remove('name');\n *     schema.path('name'); // Undefined\n *     schema.path('age'); // SchemaNumber { ... }\n *\n * Or as a Array:\n *\n *     schema.remove(['name', 'age']);\n *     schema.path('name'); // Undefined\n *     schema.path('age'); // Undefined\n *\n * @param {String|Array} path The Path(s) to remove\n * @return {Schema} the Schema instance\n * @api public\n */\nSchema.prototype.remove = function(path) {\n  if (typeof path === 'string') {\n    path = [path];\n  }\n  if (Array.isArray(path)) {\n    path.forEach(function(name) {\n      if (this.path(name) == null && !this.nested[name]) {\n        return;\n      }\n      if (this.nested[name]) {\n        const allKeys = Object.keys(this.paths).\n          concat(Object.keys(this.nested));\n        for (const path of allKeys) {\n          if (path.startsWith(name + '.')) {\n            delete this.paths[path];\n            delete this.nested[path];\n            _deletePath(this, path);\n          }\n        }\n\n        delete this.nested[name];\n        _deletePath(this, name);\n        return;\n      }\n\n      delete this.paths[name];\n      _deletePath(this, name);\n    }, this);\n  }\n  return this;\n};\n\n/*!\n * ignore\n */\n\nfunction _deletePath(schema, name) {\n  const pieces = name.split('.');\n  const last = pieces.pop();\n\n  let branch = schema.tree;\n\n  for (const piece of pieces) {\n    branch = branch[piece];\n  }\n\n  delete branch[last];\n}\n\n/**\n * Loads an ES6 class into a schema. Maps [setters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set) + [getters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get), [static methods](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/static),\n * and [instance methods](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#Class_body_and_method_definitions)\n * to schema [virtuals](/docs/guide.html#virtuals),\n * [statics](/docs/guide.html#statics), and\n * [methods](/docs/guide.html#methods).\n *\n * #### Example:\n *\n * ```javascript\n * const md5 = require('md5');\n * const userSchema = new Schema({ email: String });\n * class UserClass {\n *   // `gravatarImage` becomes a virtual\n *   get gravatarImage() {\n *     const hash = md5(this.email.toLowerCase());\n *     return `https://www.gravatar.com/avatar/${hash}`;\n *   }\n *\n *   // `getProfileUrl()` becomes a document method\n *   getProfileUrl() {\n *     return `https://mysite.com/${this.email}`;\n *   }\n *\n *   // `findByEmail()` becomes a static\n *   static findByEmail(email) {\n *     return this.findOne({ email });\n *   }\n * }\n *\n * // `schema` will now have a `gravatarImage` virtual, a `getProfileUrl()` method,\n * // and a `findByEmail()` static\n * userSchema.loadClass(UserClass);\n * ```\n *\n * @param {Function} model The Class to load\n * @param {Boolean} [virtualsOnly] if truthy, only pulls virtuals from the class, not methods or statics\n */\nSchema.prototype.loadClass = function(model, virtualsOnly) {\n  if (model === Object.prototype ||\n      model === Function.prototype ||\n      model.prototype.hasOwnProperty('$isMongooseModelPrototype')) {\n    return this;\n  }\n\n  this.loadClass(Object.getPrototypeOf(model), virtualsOnly);\n\n  // Add static methods\n  if (!virtualsOnly) {\n    Object.getOwnPropertyNames(model).forEach(function(name) {\n      if (name.match(/^(length|name|prototype|constructor|__proto__)$/)) {\n        return;\n      }\n      const prop = Object.getOwnPropertyDescriptor(model, name);\n      if (prop.hasOwnProperty('value')) {\n        this.static(name, prop.value);\n      }\n    }, this);\n  }\n\n  // Add methods and virtuals\n  Object.getOwnPropertyNames(model.prototype).forEach(function(name) {\n    if (name.match(/^(constructor)$/)) {\n      return;\n    }\n    const method = Object.getOwnPropertyDescriptor(model.prototype, name);\n    if (!virtualsOnly) {\n      if (typeof method.value === 'function') {\n        this.method(name, method.value);\n      }\n    }\n    if (typeof method.get === 'function') {\n      if (this.virtuals[name]) {\n        this.virtuals[name].getters = [];\n      }\n      this.virtual(name).get(method.get);\n    }\n    if (typeof method.set === 'function') {\n      if (this.virtuals[name]) {\n        this.virtuals[name].setters = [];\n      }\n      this.virtual(name).set(method.set);\n    }\n  }, this);\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nSchema.prototype._getSchema = function(path) {\n  const _this = this;\n  const pathschema = _this.path(path);\n  const resultPath = [];\n\n  if (pathschema) {\n    pathschema.$fullPath = path;\n    return pathschema;\n  }\n\n  function search(parts, schema) {\n    let p = parts.length + 1;\n    let foundschema;\n    let trypath;\n\n    while (p--) {\n      trypath = parts.slice(0, p).join('.');\n      foundschema = schema.path(trypath);\n      if (foundschema) {\n        resultPath.push(trypath);\n\n        if (foundschema.caster) {\n          // array of Mixed?\n          if (foundschema.caster instanceof MongooseTypes.Mixed) {\n            foundschema.caster.$fullPath = resultPath.join('.');\n            return foundschema.caster;\n          }\n\n          // Now that we found the array, we need to check if there\n          // are remaining document paths to look up for casting.\n          // Also we need to handle array.$.path since schema.path\n          // doesn't work for that.\n          // If there is no foundschema.schema we are dealing with\n          // a path like array.$\n          if (p !== parts.length) {\n            if (foundschema.schema) {\n              let ret;\n              if (parts[p] === '$' || isArrayFilter(parts[p])) {\n                if (p + 1 === parts.length) {\n                  // comments.$\n                  return foundschema;\n                }\n                // comments.$.comments.$.title\n                ret = search(parts.slice(p + 1), foundschema.schema);\n                if (ret) {\n                  ret.$isUnderneathDocArray = ret.$isUnderneathDocArray ||\n                    !foundschema.schema.$isSingleNested;\n                }\n                return ret;\n              }\n              // this is the last path of the selector\n              ret = search(parts.slice(p), foundschema.schema);\n              if (ret) {\n                ret.$isUnderneathDocArray = ret.$isUnderneathDocArray ||\n                  !foundschema.schema.$isSingleNested;\n              }\n              return ret;\n            }\n          }\n        } else if (foundschema.$isSchemaMap) {\n          if (p >= parts.length) {\n            return foundschema;\n          }\n          // Any path in the map will be an instance of the map's embedded schematype\n          if (p + 1 >= parts.length) {\n            return foundschema.$__schemaType;\n          }\n          const ret = search(parts.slice(p + 1), foundschema.$__schemaType.schema);\n          return ret;\n        }\n\n        foundschema.$fullPath = resultPath.join('.');\n\n        return foundschema;\n      }\n    }\n  }\n\n  // look for arrays\n  const parts = path.split('.');\n  for (let i = 0; i < parts.length; ++i) {\n    if (parts[i] === '$' || isArrayFilter(parts[i])) {\n      // Re: gh-5628, because `schema.path()` doesn't take $ into account.\n      parts[i] = '0';\n    }\n  }\n  return search(parts, _this);\n};\n\n/*!\n * ignore\n */\n\nSchema.prototype._getPathType = function(path) {\n  const _this = this;\n  const pathschema = _this.path(path);\n\n  if (pathschema) {\n    return 'real';\n  }\n\n  function search(parts, schema) {\n    let p = parts.length + 1,\n        foundschema,\n        trypath;\n\n    while (p--) {\n      trypath = parts.slice(0, p).join('.');\n      foundschema = schema.path(trypath);\n      if (foundschema) {\n        if (foundschema.caster) {\n          // array of Mixed?\n          if (foundschema.caster instanceof MongooseTypes.Mixed) {\n            return { schema: foundschema, pathType: 'mixed' };\n          }\n\n          // Now that we found the array, we need to check if there\n          // are remaining document paths to look up for casting.\n          // Also we need to handle array.$.path since schema.path\n          // doesn't work for that.\n          // If there is no foundschema.schema we are dealing with\n          // a path like array.$\n          if (p !== parts.length && foundschema.schema) {\n            if (parts[p] === '$' || isArrayFilter(parts[p])) {\n              if (p === parts.length - 1) {\n                return { schema: foundschema, pathType: 'nested' };\n              }\n              // comments.$.comments.$.title\n              return search(parts.slice(p + 1), foundschema.schema);\n            }\n            // this is the last path of the selector\n            return search(parts.slice(p), foundschema.schema);\n          }\n          return {\n            schema: foundschema,\n            pathType: foundschema.$isSingleNested ? 'nested' : 'array'\n          };\n        }\n        return { schema: foundschema, pathType: 'real' };\n      } else if (p === parts.length && schema.nested[trypath]) {\n        return { schema: schema, pathType: 'nested' };\n      }\n    }\n    return { schema: foundschema || schema, pathType: 'undefined' };\n  }\n\n  // look for arrays\n  return search(path.split('.'), _this);\n};\n\n/*!\n * ignore\n */\n\nfunction isArrayFilter(piece) {\n  return piece.startsWith('$[') && piece.endsWith(']');\n}\n\n/*!\n * Called by `compile()` _right before_ compiling. Good for making any changes to\n * the schema that should respect options set by plugins, like `id`\n */\n\nSchema.prototype._preCompile = function _preCompile() {\n  idGetter(this);\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = exports = Schema;\n\n// require down here because of reference issues\n\n/**\n * The various built-in Mongoose Schema Types.\n *\n * #### Example:\n *\n *     const mongoose = require('mongoose');\n *     const ObjectId = mongoose.Schema.Types.ObjectId;\n *\n * #### Types:\n *\n * - [String](/docs/schematypes.html#strings)\n * - [Number](/docs/schematypes.html#numbers)\n * - [Boolean](/docs/schematypes.html#booleans) | Bool\n * - [Array](/docs/schematypes.html#arrays)\n * - [Buffer](/docs/schematypes.html#buffers)\n * - [Date](/docs/schematypes.html#dates)\n * - [ObjectId](/docs/schematypes.html#objectids) | Oid\n * - [Mixed](/docs/schematypes.html#mixed)\n *\n * Using this exposed access to the `Mixed` SchemaType, we can use them in our schema.\n *\n *     const Mixed = mongoose.Schema.Types.Mixed;\n *     new mongoose.Schema({ _user: Mixed })\n *\n * @api public\n */\n\nSchema.Types = MongooseTypes = require('./schema/index');\n\n/*!\n * ignore\n */\n\nexports.ObjectId = MongooseTypes.ObjectId;\n", "'use strict';\n\n/**\n * Module dependencies.\n */\n\nconst start = require('./common');\n\nconst mongoose = start.mongoose;\nconst assert = require('assert');\nconst sinon = require('sinon');\nconst Schema = mongoose.Schema;\nconst Document = mongoose.Document;\nconst VirtualType = mongoose.VirtualType;\nconst SchemaTypes = Schema.Types;\nconst ObjectId = SchemaTypes.ObjectId;\nconst Mixed = SchemaTypes.Mixed;\nconst DocumentObjectId = mongoose.Types.ObjectId;\nconst ReadPref = mongoose.mongo.ReadPreference;\nconst vm = require('vm');\nconst idGetter = require('../lib/helpers/schema/idGetter');\nconst applyPlugins = require('../lib/helpers/schema/applyPlugins');\n\n/**\n * Test Document constructor.\n */\n\nfunction TestDocument() {\n  Document.apply(this, arguments);\n}\n\n/**\n * Inherits from Document.\n */\n\nTestDocument.prototype.__proto__ = Document.prototype;\n\n/**\n * Test.\n */\n\ndescribe('schema', function() {\n  let db;\n\n  before(function() {\n    db = start();\n  });\n\n  after(async function() {\n    await db.close();\n  });\n\n  before(function() {\n    TestDocument.prototype.$__setSchema(new Schema({\n      test: String\n    }));\n  });\n\n  beforeEach(() => db.deleteModel(/.*/));\n  afterEach(() => require('./util').clearTestData(db));\n  afterEach(() => require('./util').stopRemainingOps(db));\n\n  describe('nested fields with same name', function() {\n    let NestedModel;\n\n    before(function() {\n      const NestedSchema = new Schema({\n        a: {\n          b: {\n            c: { $type: String },\n            d: { $type: String }\n          }\n        },\n        b: { $type: String }\n      }, { typeKey: '$type' });\n      NestedModel = db.model('Test', NestedSchema);\n    });\n\n    it('don\\'t disappear', function(done) {\n      const n = new NestedModel({\n        a: {\n          b: {\n            c: 'foo',\n            d: 'bar'\n          }\n        }, b: 'foobar'\n      });\n\n      n.save(function(err) {\n        assert.ifError(err);\n        NestedModel.findOne({ _id: n._id }, function(err, nm) {\n          assert.ifError(err);\n\n          // make sure no field has disappeared\n          assert.ok(nm.a);\n          assert.ok(nm.a.b);\n          assert.ok(nm.a.b.c);\n          assert.ok(nm.a.b.d);\n          assert.equal(nm.a.b.c, n.a.b.c);\n          assert.equal(nm.a.b.d, n.a.b.d);\n\n          done();\n        });\n      });\n    });\n  });\n\n\n  it('can be created without the \"new\" keyword', function(done) {\n    const schema = new Schema({ name: String });\n    assert.ok(schema instanceof Schema);\n    done();\n  });\n\n  it('does expose a property for duck-typing instanceof', function(done) {\n    const schema = new Schema({ name: String });\n    assert.ok(schema.instanceOfSchema);\n    done();\n  });\n\n  it('supports different schematypes', function(done) {\n    const Checkin = new Schema({\n      date: Date,\n      location: {\n        lat: Number,\n        lng: Number\n      }\n    });\n\n    const Ferret = new Schema({\n      name: String,\n      owner: ObjectId,\n      fur: String,\n      color: { type: String },\n      age: Number,\n      checkins: [Checkin],\n      friends: [ObjectId],\n      likes: Array,\n      alive: Boolean,\n      extra: Mixed\n    });\n\n    assert.ok(Ferret.path('name') instanceof SchemaTypes.String);\n    assert.ok(Ferret.path('owner') instanceof SchemaTypes.ObjectId);\n    assert.ok(Ferret.path('fur') instanceof SchemaTypes.String);\n    assert.ok(Ferret.path('color') instanceof SchemaTypes.String);\n    assert.ok(Ferret.path('age') instanceof SchemaTypes.Number);\n    assert.ok(Ferret.path('checkins') instanceof SchemaTypes.DocumentArray);\n    assert.ok(Ferret.path('friends') instanceof SchemaTypes.Array);\n    assert.ok(Ferret.path('likes') instanceof SchemaTypes.Array);\n    assert.ok(Ferret.path('alive') instanceof SchemaTypes.Boolean);\n    assert.ok(Ferret.path('extra') instanceof SchemaTypes.Mixed);\n\n    assert.strictEqual(Ferret.path('unexistent'), undefined);\n\n    assert.ok(Checkin.path('date') instanceof SchemaTypes.Date);\n\n    // check strings\n    const Checkin1 = new Schema({\n      date: 'date',\n      location: {\n        lat: 'number',\n        lng: 'Number'\n      }\n    });\n\n    assert.ok(Checkin1.path('date') instanceof SchemaTypes.Date);\n    assert.ok(Checkin1.path('location.lat') instanceof SchemaTypes.Number);\n    assert.ok(Checkin1.path('location.lng') instanceof SchemaTypes.Number);\n\n    const Ferret1 = new Schema({\n      name: 'string',\n      owner: 'oid',\n      fur: { type: 'string' },\n      color: { type: 'String' },\n      checkins: [Checkin],\n      friends: Array,\n      likes: 'array',\n      alive: 'Bool',\n      alive1: 'bool',\n      alive2: 'boolean',\n      extra: 'mixed',\n      obj: 'object',\n      buf: 'buffer',\n      Buf: 'Buffer'\n    });\n\n    assert.ok(Ferret1.path('name') instanceof SchemaTypes.String);\n    assert.ok(Ferret1.path('owner') instanceof SchemaTypes.ObjectId);\n    assert.ok(Ferret1.path('fur') instanceof SchemaTypes.String);\n    assert.ok(Ferret1.path('color') instanceof SchemaTypes.String);\n    assert.ok(Ferret1.path('checkins') instanceof SchemaTypes.DocumentArray);\n    assert.ok(Ferret1.path('friends') instanceof SchemaTypes.Array);\n    assert.ok(Ferret1.path('likes') instanceof SchemaTypes.Array);\n    assert.ok(Ferret1.path('alive') instanceof SchemaTypes.Boolean);\n    assert.ok(Ferret1.path('alive1') instanceof SchemaTypes.Boolean);\n    assert.ok(Ferret1.path('alive2') instanceof SchemaTypes.Boolean);\n    assert.ok(Ferret1.path('extra') instanceof SchemaTypes.Mixed);\n    assert.ok(Ferret1.path('obj') instanceof SchemaTypes.Mixed);\n    assert.ok(Ferret1.path('buf') instanceof SchemaTypes.Buffer);\n    assert.ok(Ferret1.path('Buf') instanceof SchemaTypes.Buffer);\n    done();\n  });\n\n  it('supports dot notation for path accessors', function(done) {\n    const Racoon = new Schema({\n      name: { type: String, enum: ['Edwald', 'Tobi'] },\n      age: Number\n    });\n\n    // check for global variable leak\n    assert.equal(typeof errorMessage, 'undefined');\n\n    const Person = new Schema({\n      name: String,\n      raccoons: [Racoon],\n      location: {\n        city: String,\n        state: String\n      }\n    });\n\n    assert.ok(Person.path('name') instanceof SchemaTypes.String);\n    assert.ok(Person.path('raccoons') instanceof SchemaTypes.DocumentArray);\n    assert.ok(Person.path('location.city') instanceof SchemaTypes.String);\n    assert.ok(Person.path('location.state') instanceof SchemaTypes.String);\n\n    assert.strictEqual(Person.path('location.unexistent'), undefined);\n    done();\n  });\n\n  it('allows paths nested > 2 levels', function(done) {\n    const Nested = new Schema({\n      first: {\n        second: {\n          third: String\n        }\n      }\n    });\n    assert.ok(Nested.path('first.second.third') instanceof SchemaTypes.String);\n    done();\n  });\n\n  it('default definition', function(done) {\n    const Test = new Schema({\n      simple: { $type: String, default: 'a' },\n      array: { $type: Array, default: [1, 2, 3, 4, 5] },\n      arrayX: { $type: Array, default: 9 },\n      arrayFn: {\n        $type: Array, default: function() {\n          return [8];\n        }\n      },\n      callback: {\n        $type: Number, default: function() {\n          assert.equal(this.a, 'b');\n          return '3';\n        }\n      }\n    }, { typeKey: '$type' });\n\n    assert.equal(Test.path('simple').defaultValue, 'a');\n    assert.equal(typeof Test.path('callback').defaultValue, 'function');\n\n    assert.equal(Test.path('simple').getDefault(), 'a');\n    assert.equal((+Test.path('callback').getDefault({ a: 'b' })), 3);\n    assert.equal(typeof Test.path('array').defaultValue, 'function');\n    assert.equal(Test.path('array').getDefault(new TestDocument())[3], 4);\n    assert.equal(Test.path('arrayX').getDefault(new TestDocument())[0], 9);\n    assert.equal(typeof Test.path('arrayFn').defaultValue, 'function');\n    assert.ok(Test.path('arrayFn').getDefault(new TestDocument()).isMongooseArray);\n    assert.ok(Test.path('arrayX').getDefault(new TestDocument()).isMongooseArray);\n    assert.equal(Test.path('arrayX').getDefault(new TestDocument())[0], 9);\n    done();\n  });\n\n  it('Mixed defaults can be empty arrays', function(done) {\n    const Test = new Schema({\n      mixed1: { type: Mixed, default: [] },\n      mixed2: { type: Mixed, default: Array }\n    });\n\n    assert.ok(Test.path('mixed1').getDefault() instanceof Array);\n    assert.equal(Test.path('mixed1').getDefault().length, 0);\n    assert.ok(Test.path('mixed2').getDefault() instanceof Array);\n    assert.equal(Test.path('mixed2').getDefault().length, 0);\n    done();\n  });\n\n  describe('casting', function() {\n    it('number', function(done) {\n      const Tobi = new Schema({\n        age: Number\n      });\n\n      // test String -> Number cast\n      assert.equal(typeof Tobi.path('age').cast('0'), 'number');\n      assert.equal((+Tobi.path('age').cast('0')), 0);\n\n      assert.equal(typeof Tobi.path('age').cast(0), 'number');\n      assert.equal((+Tobi.path('age').cast(0)), 0);\n      done();\n    });\n\n    describe('string', function() {\n      it('works', function(done) {\n        const Tobi = new Schema({\n          nickname: String\n        });\n\n        function Test() {\n        }\n\n        Test.prototype.toString = function() {\n          return 'woot';\n        };\n\n        // test Number -> String cast\n        assert.equal(typeof Tobi.path('nickname').cast(0), 'string');\n        assert.equal(Tobi.path('nickname').cast(0), '0');\n\n        // test any object that implements toString\n        assert.equal(typeof Tobi.path('nickname').cast(new Test()), 'string');\n        assert.equal(Tobi.path('nickname').cast(new Test()), 'woot');\n        done();\n      });\n    });\n\n    it('date', function(done) {\n      const Loki = new Schema({\n        birth_date: { type: Date }\n      });\n\n      assert.ok(Loki.path('birth_date').cast(1294525628301) instanceof Date);\n      assert.ok(Loki.path('birth_date').cast('8/24/2000') instanceof Date);\n      assert.ok(Loki.path('birth_date').cast(new Date()) instanceof Date);\n      assert.ok(Loki.path('birth_date').cast('') === null);\n      assert.ok(Loki.path('birth_date').cast(null) === null);\n      done();\n    });\n\n    it('objectid', function(done) {\n      const Loki = new Schema({\n        owner: { type: ObjectId }\n      });\n\n      const doc = new TestDocument();\n      const id = doc._id.toString();\n\n      assert.ok(Loki.path('owner').cast('4c54f3453e688c000000001a') instanceof DocumentObjectId);\n\n      assert.ok(Loki.path('owner').cast(new DocumentObjectId()) instanceof DocumentObjectId);\n\n      assert.ok(Loki.path('owner').cast(doc) instanceof DocumentObjectId);\n\n      assert.equal(Loki.path('owner').cast(doc).toString(), id);\n      done();\n    });\n\n    it('array', function(done) {\n      const Loki = new Schema({\n        oids: [ObjectId],\n        dates: [Date],\n        numbers: [Number],\n        strings: [String],\n        buffers: [Buffer],\n        nocast: [],\n        mixed: [Mixed]\n      });\n\n      const oids = Loki.path('oids').cast(['4c54f3453e688c000000001a', new DocumentObjectId()]);\n\n      assert.ok(oids[0] instanceof DocumentObjectId);\n      assert.ok(oids[1] instanceof DocumentObjectId);\n\n      const dates = Loki.path('dates').cast(['8/24/2010', 1294541504958]);\n\n      assert.ok(dates[0] instanceof Date);\n      assert.ok(dates[1] instanceof Date);\n\n      const numbers = Loki.path('numbers').cast([152, '31']);\n\n      assert.equal(typeof numbers[0], 'number');\n      assert.equal(typeof numbers[1], 'number');\n\n      const strings = Loki.path('strings').cast(['test', 123]);\n\n      assert.equal(typeof strings[0], 'string');\n      assert.equal(strings[0], 'test');\n\n      assert.equal(typeof strings[1], 'string');\n      assert.equal(strings[1], '123');\n\n      const buffers = Loki.path('buffers').cast(['\\0\\0\\0', Buffer.from('abc')]);\n\n      assert.ok(buffers[0] instanceof Buffer);\n      assert.ok(buffers[1] instanceof Buffer);\n\n      const nocasts = Loki.path('nocast').cast(['test', 123]);\n\n      assert.equal(typeof nocasts[0], 'string');\n      assert.equal(nocasts[0], 'test');\n\n      assert.equal(typeof nocasts[1], 'number');\n      assert.equal(nocasts[1], 123);\n\n      const mixed = Loki.path('mixed').cast(['test', 123, '123', {}, new Date(), new DocumentObjectId()]);\n\n      assert.equal(typeof mixed[0], 'string');\n      assert.equal(typeof mixed[1], 'number');\n      assert.equal(typeof mixed[2], 'string');\n      assert.equal(typeof mixed[3], 'object');\n      assert.ok(mixed[4] instanceof Date);\n      assert.ok(mixed[5] instanceof DocumentObjectId);\n\n      // gh-6405\n      assert.ok(Loki.path('dates.$') instanceof SchemaTypes.Date);\n      assert.ok(Loki.path('numbers.$') instanceof SchemaTypes.Number);\n      assert.ok(Loki.path('strings.$') instanceof SchemaTypes.String);\n      assert.ok(Loki.path('buffers.$') instanceof SchemaTypes.Buffer);\n      assert.ok(Loki.path('mixed.$') instanceof SchemaTypes.Mixed);\n\n      done();\n    });\n\n    it('array of arrays', function(done) {\n      const test = new Schema({\n        nums: [[Number]],\n        strings: [{ type: [String] }]\n      });\n      let nums = test.path('nums').cast([['1', '2']]);\n      assert.equal(nums.length, 1);\n      assert.deepEqual(nums[0].toObject(), [1, 2]);\n\n      nums = test.path('nums').cast(1);\n      assert.equal(nums.length, 1);\n      assert.deepEqual(nums[0].toObject(), [1]);\n\n      let threw = false;\n      try {\n        test.path('nums').cast([['abcd']]);\n      } catch (error) {\n        threw = true;\n        assert.equal(error.name, 'CastError');\n        assert.ok(error.message.includes('Cast to [[Number]] failed'), error.message);\n      }\n      assert.ok(threw);\n\n      const strs = test.path('strings').cast('test');\n      assert.equal(strs.length, 1);\n      assert.deepEqual(strs[0].toObject(), ['test']);\n\n      done();\n    });\n\n    it('boolean', function(done) {\n      const Animal = new Schema({\n        isFerret: { type: Boolean, required: true }\n      });\n\n      assert.strictEqual(Animal.path('isFerret').cast(null), null);\n      assert.strictEqual(Animal.path('isFerret').cast(undefined), undefined);\n\n      assert.equal(Animal.path('isFerret').cast(false), false);\n      assert.equal(Animal.path('isFerret').cast(0), false);\n      assert.equal(Animal.path('isFerret').cast('0'), false);\n      assert.equal(Animal.path('isFerret').cast('false'), false);\n      assert.equal(Animal.path('isFerret').cast(true), true);\n      assert.equal(Animal.path('isFerret').cast(1), true);\n      assert.equal(Animal.path('isFerret').cast('1'), true);\n      assert.equal(Animal.path('isFerret').cast('true'), true);\n      done();\n    });\n  });\n\n  it('methods declaration', function(done) {\n    const a = new Schema();\n    a.method('test', function() {\n    });\n    a.method({\n      a: function() {\n      },\n      b: function() {\n      }\n    });\n    assert.equal(Object.keys(a.methods).length, 3);\n    done();\n  });\n\n  it('static declaration', function(done) {\n    const a = new Schema();\n    a.static('test', function() {\n    });\n    a.static({\n      a: function() {\n      },\n      b: function() {\n      },\n      c: function() {\n      }\n    });\n\n    assert.equal(Object.keys(a.statics).length, 4);\n    done();\n  });\n\n  describe('setters', function() {\n    it('work', function(done) {\n      function lowercase(v) {\n        return v.toLowerCase();\n      }\n\n      const Tobi = new Schema({\n        name: { type: String, set: lowercase }\n      });\n\n      assert.equal(Tobi.path('name').applySetters('WOOT'), 'woot');\n      assert.equal(Tobi.path('name').setters.length, 1);\n\n      Tobi.path('name').set(function(v) {\n        return v + 'WOOT';\n      });\n\n      assert.equal(Tobi.path('name').applySetters('WOOT'), 'wootwoot');\n      assert.equal(Tobi.path('name').setters.length, 2);\n      done();\n    });\n\n    it('order', function(done) {\n      function extract(v) {\n        return (v && v._id)\n          ? v._id\n          : v;\n      }\n\n      const Tobi = new Schema({\n        name: { type: Schema.ObjectId, set: extract }\n      });\n\n      const id = new DocumentObjectId();\n      const sid = id.toString();\n      const _id = { _id: id };\n\n      assert.equal(Tobi.path('name').applySetters(sid, { a: 'b' }).toString(), sid);\n      assert.equal(Tobi.path('name').applySetters(_id, { a: 'b' }).toString(), sid);\n      assert.equal(Tobi.path('name').applySetters(id, { a: 'b' }).toString(), sid);\n      done();\n    });\n\n    it('scope', function(done) {\n      function lowercase(v, cur, self) {\n        assert.equal(this.a, 'b');\n        assert.equal(self.path, 'name');\n        return v.toLowerCase();\n      }\n\n      const Tobi = new Schema({\n        name: { type: String, set: lowercase }\n      });\n\n      assert.equal(Tobi.path('name').applySetters('WHAT', { a: 'b' }), 'what');\n      done();\n    });\n\n    it('casting', function(done) {\n      function last(v) {\n        assert.equal(typeof v, 'number');\n        assert.equal(v, 0);\n        return 'last';\n      }\n\n      function first() {\n        return 0;\n      }\n\n      const Tobi = new Schema({\n        name: { type: String, set: last }\n      });\n\n      Tobi.path('name').set(first);\n      assert.equal(Tobi.path('name').applySetters('woot'), 'last');\n      done();\n    });\n\n    describe('array', function() {\n      it('object setters will be applied for each object in array', function(done) {\n        const Tobi = new Schema({\n          names: [{ type: String, lowercase: true, trim: true }]\n        });\n        assert.equal(typeof Tobi.path('names').applySetters(['   whaT', 'WoOt  '])[0], 'string');\n        assert.equal(typeof Tobi.path('names').applySetters(['   whaT', 'WoOt  '])[1], 'string');\n        assert.equal(Tobi.path('names').applySetters(['   whaT', 'WoOt  '])[0], 'what');\n        assert.equal(Tobi.path('names').applySetters(['   whaT', 'WoOt  '])[1], 'woot');\n        done();\n      });\n    });\n\n    describe('string', function() {\n      it('lowercase', function(done) {\n        const Tobi = new Schema({\n          name: { type: String, lowercase: true }\n        });\n\n        assert.equal(Tobi.path('name').applySetters('WHAT'), 'what');\n        assert.equal(Tobi.path('name').applySetters(1977), '1977');\n        done();\n      });\n      it('uppercase', function(done) {\n        const Tobi = new Schema({\n          name: { type: String, uppercase: true }\n        });\n\n        assert.equal(Tobi.path('name').applySetters('what'), 'WHAT');\n        assert.equal(Tobi.path('name').applySetters(1977), '1977');\n        done();\n      });\n      it('trim', function(done) {\n        const Tobi = new Schema({\n          name: { type: String, uppercase: true, trim: true }\n        });\n\n        assert.equal(Tobi.path('name').applySetters('  what   '), 'WHAT');\n        assert.equal(Tobi.path('name').applySetters(1977), '1977');\n        done();\n      });\n    });\n\n    it('applying when none have been defined', function(done) {\n      const Tobi = new Schema({\n        name: String\n      });\n\n      assert.equal(Tobi.path('name').applySetters('woot'), 'woot');\n      done();\n    });\n\n    it('assignment of non-functions throw', function(done) {\n      const schema = new Schema({ fun: String });\n      let g;\n\n      try {\n        schema.path('fun').set(4);\n      } catch (err_) {\n        g = err_;\n      }\n\n      assert.ok(g);\n      assert.equal(g.message, 'A setter must be a function.');\n      done();\n    });\n  });\n\n  describe('getters', function() {\n    it('work', function(done) {\n      function woot(v) {\n        return v + ' woot';\n      }\n\n      const Tobi = new Schema({\n        name: { type: String, get: woot }\n      });\n\n      assert.equal(Tobi.path('name').getters.length, 1);\n      assert.equal(Tobi.path('name').applyGetters('test'), 'test woot');\n      done();\n    });\n    it('order', function(done) {\n      function format(v) {\n        return v\n          ? '$' + v\n          : v;\n      }\n\n      const Tobi = new Schema({\n        name: { type: Number, get: format }\n      });\n\n      assert.equal(Tobi.path('name').applyGetters(30, { a: 'b' }), '$30');\n      done();\n    });\n    it('scope', function(done) {\n      function woot(v, self) {\n        assert.equal(this.a, 'b');\n        assert.equal(self.path, 'name');\n        return v.toLowerCase();\n      }\n\n      const Tobi = new Schema({\n        name: { type: String, get: woot }\n      });\n\n      assert.equal(Tobi.path('name').applyGetters('YEP', { a: 'b' }), 'yep');\n      done();\n    });\n    it('casting', function(done) {\n      function last(v) {\n        assert.equal(typeof v, 'number');\n        assert.equal(v, 0);\n        return 'last';\n      }\n\n      function first() {\n        return 0;\n      }\n\n      const Tobi = new Schema({\n        name: { type: String, get: first }\n      });\n\n      Tobi.path('name').get(last);\n      assert.equal(Tobi.path('name').applyGetters('woot'), 'last');\n      done();\n    });\n    it('applying when none have been defined', function(done) {\n      const Tobi = new Schema({\n        name: String\n      });\n\n      assert.equal(Tobi.path('name').applyGetters('woot'), 'woot');\n      done();\n    });\n    it('assignment of non-functions throw', function(done) {\n      const schema = new Schema({ fun: String });\n      let g;\n\n      try {\n        schema.path('fun').get(true);\n      } catch (err_) {\n        g = err_;\n      }\n\n      assert.ok(g);\n      assert.equal(g.message, 'A getter must be a function.');\n      done();\n    });\n    it('auto _id', function(done) {\n      let schema = new Schema({\n        name: String\n      });\n      assert.ok(schema.path('_id') instanceof Schema.ObjectId);\n\n      schema = new Schema({\n        name: String\n      }, { _id: true });\n      assert.ok(schema.path('_id') instanceof Schema.ObjectId);\n\n      schema.set('_id', false);\n      assert.ok(schema.path('_id') == null);\n\n      schema = new Schema({\n        name: String\n      }, { _id: false });\n      assert.equal(schema.path('_id'), undefined);\n\n      schema.set('_id', true);\n      assert.ok(schema.path('_id') instanceof Schema.ObjectId);\n      done();\n    });\n  });\n\n  describe('indexes', function() {\n    describe('definition', function() {\n      it('basic', function(done) {\n        const Tobi = new Schema({\n          name: { type: String, index: true }\n        });\n\n        assert.equal(Tobi.path('name')._index, true);\n        Tobi.path('name').index({ unique: true });\n        assert.deepEqual(Tobi.path('name')._index, { unique: true });\n        Tobi.path('name').unique(false);\n        assert.deepEqual(Tobi.path('name')._index, { unique: false });\n\n        let T, i;\n\n        T = new Schema({\n          name: { type: String, sparse: true }\n        });\n        assert.deepEqual(T.path('name')._index, { sparse: true });\n\n        T = new Schema({\n          name: { type: String, unique: true }\n        });\n        assert.deepEqual(T.path('name')._index, { unique: true });\n\n        T = new Schema({\n          name: { type: Date, expires: '1.5m' }\n        });\n        assert.deepEqual(T.path('name')._index, { expireAfterSeconds: 90 });\n\n        T = new Schema({\n          name: { type: Date, expires: 200 }\n        });\n        assert.deepEqual(T.path('name')._index, { expireAfterSeconds: 200 });\n\n        T = new Schema({\n          name: { type: String, sparse: true, unique: true }\n        });\n        assert.deepEqual(T.path('name')._index, { sparse: true, unique: true });\n\n        T = new Schema({\n          name: { type: String, unique: true, sparse: true }\n        });\n        i = T.path('name')._index;\n        assert.equal(i.unique, true);\n        assert.equal(i.sparse, true);\n\n        T = new Schema({\n          name: { type: String, index: { sparse: true, unique: true, expireAfterSeconds: 65 } }\n        });\n        i = T.path('name')._index;\n        assert.equal(i.unique, true);\n        assert.equal(i.sparse, true);\n        assert.equal(i.expireAfterSeconds, 65);\n\n        T = new Schema({\n          name: { type: Date, index: { sparse: true, unique: true, expires: '24h' } }\n        });\n        i = T.path('name')._index;\n        assert.equal(i.unique, true);\n        assert.equal(i.sparse, true);\n        assert.equal(i.expireAfterSeconds, 60 * 60 * 24);\n\n        T = new Schema({\n          name: { type: String, index: false, unique: false }\n        });\n        assert.equal(T.path('name')._index, false);\n        assert.equal(T.indexes().length, 0);\n\n        done();\n      });\n      it('compound', function(done) {\n        const Tobi = new Schema({\n          name: { type: String, index: true },\n          last: { type: Number, sparse: true },\n          nope: { type: String, index: { background: false } }\n        });\n\n        Tobi.index({ firstname: 1, last: 1 }, { unique: true, expires: '1h' });\n        Tobi.index({ firstname: 1, nope: 1 }, { unique: true, background: false });\n\n        assert.deepEqual(Tobi.indexes(), [\n          [{ name: 1 }, { background: true }],\n          [{ last: 1 }, { sparse: true, background: true }],\n          [{ nope: 1 }, { background: false }],\n          [{ firstname: 1, last: 1 }, { unique: true, expireAfterSeconds: 60 * 60, background: true }],\n          [{ firstname: 1, nope: 1 }, { unique: true, background: false }]\n        ]);\n\n        done();\n      });\n\n      it('compound based on name (gh-6499)', function() {\n        const testSchema = new Schema({\n          prop1: { type: String, index: { name: 'test1' } },\n          prop2: { type: Number, index: true },\n          prop3: { type: String, index: { name: 'test1' } }\n        });\n\n        const indexes = testSchema.indexes();\n        assert.equal(indexes.length, 2);\n        assert.deepEqual(indexes[0][0], { prop1: 1, prop3: 1 });\n        assert.deepEqual(indexes[1][0], { prop2: 1 });\n      });\n\n      it('with single nested doc (gh-6113)', function(done) {\n        const pointSchema = new Schema({\n          type: {\n            type: String,\n            default: 'Point',\n            validate: v => v === 'Point'\n          },\n          coordinates: [[Number]]\n        });\n\n        const schema = new Schema({\n          point: { type: pointSchema, index: '2dsphere' }\n        });\n\n        assert.deepEqual(schema.indexes(), [\n          [{ point: '2dsphere' }, { background: true }]\n        ]);\n\n        done();\n      });\n\n      it('with embedded discriminator (gh-6485)', function() {\n        const eventSchema = new Schema({\n          message: { type: String, index: true }\n        }, { discriminatorKey: 'kind', _id: false });\n\n        const batchSchema = new Schema({\n          events: [eventSchema]\n        });\n\n        const docArray = batchSchema.path('events');\n\n        docArray.discriminator('gh6485_Clicked', new Schema({\n          element: { type: String, index: true }\n        }, { _id: false }));\n\n        docArray.discriminator('gh6485_Purchased', Schema({\n          product: { type: String, index: true }\n        }, { _id: false }));\n\n        assert.deepEqual(batchSchema.indexes().map(v => v[0]), [\n          { 'events.message': 1 },\n          { 'events.element': 1 },\n          { 'events.product': 1 }\n        ]);\n      });\n    });\n  });\n\n  describe('plugins', function() {\n    it('work', function() {\n      const Tobi = new Schema();\n      let called = false;\n\n      Tobi.plugin(function(schema) {\n        assert.equal(schema, Tobi);\n        called = true;\n      });\n\n      assert.equal(called, true);\n    });\n  });\n\n  describe('options', function() {\n    it('defaults are set', function() {\n      const Tobi = new Schema();\n\n      assert.equal(typeof Tobi.options, 'object');\n      assert.equal(Tobi.options.safe, undefined);\n      assert.equal(Tobi.options.strict, true);\n      assert.equal(Tobi.options.capped, false);\n      assert.equal(Tobi.options.versionKey, '__v');\n      assert.equal(Tobi.options.discriminatorKey, '__t');\n      assert.equal(Tobi.options.shardKey, null);\n      assert.equal(Tobi.options.read, null);\n      assert.equal(Tobi.options._id, true);\n    });\n\n    it('setting', function(done) {\n      let Tobi = new Schema({}, { collection: 'users' });\n\n      Tobi.set('a', 'b');\n      Tobi.set('writeConcern', { w: 0 });\n      assert.equal(Tobi.options.collection, 'users');\n\n      assert.equal(Tobi.options.a, 'b');\n      assert.deepEqual(Tobi.options.writeConcern, { w: 0 });\n      assert.equal(Tobi.options.read, null);\n\n      const tags = [{ x: 1 }];\n\n      Tobi.set('read', 'n');\n      assert.ok(Tobi.options.read instanceof ReadPref);\n      assert.equal(Tobi.options.read.mode, 'nearest');\n\n      Tobi.set('read', 'n', tags);\n      assert.equal(Tobi.options.read.mode, 'nearest');\n      assert.ok(Array.isArray(Tobi.options.read.tags));\n      assert.equal(Tobi.options.read.tags.length, 1);\n      assert.equal(Tobi.options.read.tags[0].x, 1);\n\n      Tobi.set('read', ['n', tags]);\n      assert.equal(Tobi.options.read.mode, 'nearest');\n      assert.ok(Array.isArray(Tobi.options.read.tags));\n      assert.equal(Tobi.options.read.tags.length, 1);\n      assert.equal(Tobi.options.read.tags[0].x, 1);\n\n      Tobi = new Schema({}, { read: 'p' });\n      assert.ok(Tobi.options.read instanceof ReadPref);\n      assert.equal(Tobi.options.read.mode, 'primary');\n\n      Tobi = new Schema({}, { read: ['s', tags] });\n      assert.ok(Tobi.options.read instanceof ReadPref);\n      assert.equal(Tobi.options.read.mode, 'secondary');\n      assert.ok(Array.isArray(Tobi.options.read.tags));\n      assert.equal(Tobi.options.read.tags.length, 1);\n      assert.equal(Tobi.options.read.tags[0].x, 1);\n\n      Tobi = new Schema({}, { read: 'primary' });\n      assert.ok(Tobi.options.read instanceof ReadPref);\n      assert.equal(Tobi.options.read.mode, 'primary');\n\n      Tobi = new Schema({}, { read: ['secondary', tags] });\n      assert.ok(Tobi.options.read instanceof ReadPref);\n      assert.equal(Tobi.options.read.mode, 'secondary');\n      assert.ok(Array.isArray(Tobi.options.read.tags));\n      assert.equal(Tobi.options.read.tags.length, 1);\n      assert.equal(Tobi.options.read.tags[0].x, 1);\n\n      Tobi = new Schema({}, { read: 's' });\n      assert.ok(Tobi.options.read instanceof ReadPref);\n      assert.equal(Tobi.options.read.mode, 'secondary');\n\n      Tobi = new Schema({}, { read: ['s', tags] });\n      assert.ok(Tobi.options.read instanceof ReadPref);\n      assert.equal(Tobi.options.read.mode, 'secondary');\n      assert.ok(Array.isArray(Tobi.options.read.tags));\n      assert.equal(Tobi.options.read.tags.length, 1);\n      assert.equal(Tobi.options.read.tags[0].x, 1);\n\n      Tobi = new Schema({}, { read: 'secondary' });\n      assert.ok(Tobi.options.read instanceof ReadPref);\n      assert.equal(Tobi.options.read.mode, 'secondary');\n\n      Tobi = new Schema({}, { read: ['secondary', tags] });\n      assert.ok(Tobi.options.read instanceof ReadPref);\n      assert.equal(Tobi.options.read.mode, 'secondary');\n      assert.ok(Array.isArray(Tobi.options.read.tags));\n      assert.equal(Tobi.options.read.tags.length, 1);\n      assert.equal(Tobi.options.read.tags[0].x, 1);\n\n      Tobi = new Schema({}, { read: 'pp' });\n      assert.ok(Tobi.options.read instanceof ReadPref);\n      assert.ok(Tobi.options.read.isValid());\n      assert.equal(Tobi.options.read.mode, 'primaryPreferred');\n\n      Tobi = new Schema({}, { read: ['pp', tags] });\n      assert.ok(Tobi.options.read instanceof ReadPref);\n      assert.ok(Tobi.options.read.isValid());\n      assert.equal(Tobi.options.read.mode, 'primaryPreferred');\n      assert.ok(Array.isArray(Tobi.options.read.tags));\n      assert.equal(Tobi.options.read.tags.length, 1);\n      assert.equal(Tobi.options.read.tags[0].x, 1);\n\n      Tobi = new Schema({}, { read: 'primaryPreferred' });\n      assert.ok(Tobi.options.read instanceof ReadPref);\n      assert.ok(Tobi.options.read.isValid());\n      assert.equal(Tobi.options.read.mode, 'primaryPreferred');\n\n      Tobi = new Schema({}, { read: ['primaryPreferred', tags] });\n      assert.ok(Tobi.options.read instanceof ReadPref);\n      assert.ok(Tobi.options.read.isValid());\n      assert.equal(Tobi.options.read.mode, 'primaryPreferred');\n      assert.ok(Array.isArray(Tobi.options.read.tags));\n      assert.equal(Tobi.options.read.tags.length, 1);\n      assert.equal(Tobi.options.read.tags[0].x, 1);\n\n      Tobi = new Schema({}, { read: 'sp' });\n      assert.ok(Tobi.options.read instanceof ReadPref);\n      assert.ok(Tobi.options.read.isValid());\n      assert.equal(Tobi.options.read.mode, 'secondaryPreferred');\n\n      Tobi = new Schema({}, { read: ['sp', tags] });\n      assert.ok(Tobi.options.read instanceof ReadPref);\n      assert.ok(Tobi.options.read.isValid());\n      assert.equal(Tobi.options.read.mode, 'secondaryPreferred');\n      assert.ok(Array.isArray(Tobi.options.read.tags));\n      assert.equal(Tobi.options.read.tags.length, 1);\n      assert.equal(Tobi.options.read.tags[0].x, 1);\n\n      Tobi = new Schema({}, { read: 'secondaryPreferred' });\n      assert.ok(Tobi.options.read instanceof ReadPref);\n      assert.ok(Tobi.options.read.isValid());\n      assert.equal(Tobi.options.read.mode, 'secondaryPreferred');\n\n      Tobi = new Schema({}, { read: ['secondaryPreferred', tags] });\n      assert.ok(Tobi.options.read instanceof ReadPref);\n      assert.ok(Tobi.options.read.isValid());\n      assert.equal(Tobi.options.read.mode, 'secondaryPreferred');\n      assert.ok(Array.isArray(Tobi.options.read.tags));\n      assert.equal(Tobi.options.read.tags.length, 1);\n      assert.equal(Tobi.options.read.tags[0].x, 1);\n\n      Tobi = new Schema({}, { read: 'n' });\n      assert.ok(Tobi.options.read instanceof ReadPref);\n      assert.ok(Tobi.options.read.isValid());\n      assert.equal(Tobi.options.read.mode, 'nearest');\n\n      Tobi = new Schema({}, { read: ['n', tags] });\n      assert.ok(Tobi.options.read instanceof ReadPref);\n      assert.ok(Tobi.options.read.isValid());\n      assert.equal(Tobi.options.read.mode, 'nearest');\n      assert.ok(Array.isArray(Tobi.options.read.tags));\n      assert.equal(Tobi.options.read.tags.length, 1);\n      assert.equal(Tobi.options.read.tags[0].x, 1);\n\n      Tobi = new Schema({}, { read: 'nearest' });\n      assert.ok(Tobi.options.read instanceof ReadPref);\n      assert.ok(Tobi.options.read.isValid());\n      assert.equal(Tobi.options.read.mode, 'nearest');\n\n      Tobi = new Schema({}, { read: ['nearest', tags] });\n      assert.ok(Tobi.options.read instanceof ReadPref);\n      assert.ok(Tobi.options.read.isValid());\n      assert.equal(Tobi.options.read.mode, 'nearest');\n      assert.ok(Array.isArray(Tobi.options.read.tags));\n      assert.equal(Tobi.options.read.tags.length, 1);\n      assert.equal(Tobi.options.read.tags[0].x, 1);\n\n      done();\n    });\n  });\n\n  describe('virtuals', function() {\n    it('works', function(done) {\n      const Contact = new Schema({\n        firstName: String,\n        lastName: String\n      });\n\n      Contact\n        .virtual('fullName')\n        .get(function() {\n          return this.get('firstName') + ' ' + this.get('lastName');\n        })\n        .set(function(fullName) {\n          const split = fullName.split(' ');\n          this.set('firstName', split[0]);\n          this.set('lastName', split[1]);\n        });\n\n      assert.ok(Contact.virtualpath('fullName') instanceof VirtualType);\n      done();\n    });\n\n    describe('id', function() {\n      it('default creation of id can be overridden (gh-298)', function(done) {\n        assert.doesNotThrow(function() {\n          new Schema({ id: String });\n        });\n        done();\n      });\n      it('disabling', function(done) {\n        const schema = new Schema({ name: String });\n        assert.strictEqual(undefined, schema.virtuals.id);\n        done();\n      });\n    });\n\n    describe('getter', function() {\n      it('scope', function(done) {\n        const Tobi = new Schema();\n\n        Tobi.virtual('name').get(function(v, self) {\n          assert.equal(this.a, 'b');\n          assert.equal(self.path, 'name');\n          return v.toLowerCase();\n        });\n\n        assert.equal(Tobi.virtualpath('name').applyGetters('YEP', { a: 'b' }), 'yep');\n        done();\n      });\n    });\n\n    describe('setter', function() {\n      it('scope', function(done) {\n        const Tobi = new Schema();\n\n        Tobi.virtual('name').set(function(v, self) {\n          assert.equal(this.a, 'b');\n          assert.equal(self.path, 'name');\n          return v.toLowerCase();\n        });\n\n        assert.equal(Tobi.virtualpath('name').applySetters('YEP', { a: 'b' }), 'yep');\n        done();\n      });\n    });\n  });\n\n  describe('other contexts', function() {\n    it('work', function(done) {\n      const str = 'code = {' +\n        '  name: String' +\n        ', arr1: Array ' +\n        ', arr2: { type: [] }' +\n        ', date: Date  ' +\n        ', num: { type: Number }' +\n        ', bool: Boolean' +\n        ', nest: { sub: { type: {}, required: true }}' +\n        '}';\n\n      const script = vm.createScript(str, 'testSchema.vm');\n      const sandbox = { code: null };\n      script.runInNewContext(sandbox);\n\n      const Ferret = new Schema(sandbox.code);\n      assert.ok(Ferret.path('nest.sub') instanceof SchemaTypes.Mixed);\n      assert.ok(Ferret.path('name') instanceof SchemaTypes.String);\n      assert.ok(Ferret.path('arr1') instanceof SchemaTypes.Array);\n      assert.ok(Ferret.path('arr2') instanceof SchemaTypes.Array);\n      assert.ok(Ferret.path('date') instanceof SchemaTypes.Date);\n      assert.ok(Ferret.path('num') instanceof SchemaTypes.Number);\n      assert.ok(Ferret.path('bool') instanceof SchemaTypes.Boolean);\n      done();\n    });\n  });\n\n  describe('#add()', function() {\n    it('does not pollute existing paths', function(done) {\n      let o = { name: String };\n      let s = new Schema(o);\n\n      assert.throws(function() {\n        s.add({ age: Number }, 'name.');\n      }, /Cannot set nested path/);\n\n      assert.throws(function() {\n        s.add({ age: { x: Number } }, 'name.');\n      }, /Cannot set nested path/);\n      assert.equal(('age' in o.name), false);\n\n      o = { name: 'string' };\n      s = new Schema(o);\n\n      assert.throws(function() {\n        s.add({ age: Number }, 'name.');\n      }, /Cannot set nested path/);\n\n      assert.throws(function() {\n        s.add({ age: { x: Number } }, 'name.');\n      }, /Cannot set nested path/);\n\n      assert.equal(o.name, 'string');\n      done();\n    });\n\n    it('returns the schema instance', function() {\n      const schema = new Schema({ name: String });\n      const ret = schema.add({ age: Number });\n      assert.strictEqual(ret, schema);\n    });\n\n    it('returns the schema instance when schema instance is passed', function() {\n      const schemaA = new Schema({ name: String });\n      const schemaB = new Schema({ age: Number });\n      const ret = schemaB.add(schemaA);\n      assert.strictEqual(ret, schemaB);\n    });\n\n    it('merging nested objects (gh-662)', function(done) {\n      const MergedSchema = new Schema({\n        a: {\n          foo: String\n        }\n      });\n\n      MergedSchema.add({\n        a: {\n          b: {\n            bar: String\n          }\n        }\n      });\n\n      db.deleteModel(/Test/);\n      const Merged = db.model('Test', MergedSchema);\n\n      const merged = new Merged({\n        a: {\n          foo: 'baz',\n          b: {\n            bar: 'qux'\n          }\n        }\n      });\n\n      merged.save(function(err) {\n        assert.ifError(err);\n        Merged.findById(merged.id, function(err, found) {\n          assert.ifError(err);\n          assert.equal(found.a.foo, 'baz');\n          assert.equal(found.a.b.bar, 'qux');\n          done();\n        });\n      });\n    });\n\n    it('prefix (gh-1730)', function(done) {\n      const s = new Schema({});\n\n      s.add({ n: Number }, 'prefix.');\n\n      assert.equal(s.pathType('prefix.n'), 'real');\n      assert.equal(s.pathType('prefix'), 'nested');\n      done();\n    });\n\n    it('adds another schema (gh-6897)', function(done) {\n      const s = new Schema({ name: String });\n\n      const s2 = new Schema({ age: Number });\n\n      s2.statics.foo = function() { return 42; };\n      s2.pre('save', function() {\n        throw new Error('oops!');\n      });\n\n      s.add(s2);\n\n      assert.ok(s.paths.age);\n      assert.strictEqual(s.statics.foo, s2.statics.foo);\n      assert.ok(s.s.hooks._pres.get('save'));\n\n      done();\n    });\n\n    it('overwrites existing paths (gh-10203)', function() {\n      const baseSchema = new Schema({\n        username: {\n          type: String,\n          required: false\n        }\n      });\n\n      const userSchema = new Schema({\n        email: {\n          type: String,\n          required: true\n        },\n        username: {\n          type: String,\n          required: true\n        }\n      });\n\n      const realSchema = baseSchema.clone();\n      realSchema.add(userSchema);\n\n      assert.ok(realSchema.path('username').isRequired);\n    });\n  });\n\n  it('debugging msgs', function(done) {\n    let err;\n    try {\n      new Schema({ name: { first: null } });\n    } catch (e) {\n      err = e;\n    }\n    assert.ok(err.message.indexOf('Invalid value for schema path `name.first`') !== -1, err.message);\n    try {\n      new Schema({ age: undefined });\n    } catch (e) {\n      err = e;\n    }\n    assert.ok(err.message.indexOf('Invalid value for schema path `age`') !== -1, err.message);\n    done();\n  });\n\n  describe('construction', function() {\n    it('array of object literal missing a type is interpreted as DocumentArray', function(done) {\n      const goose = new mongoose.Mongoose();\n      const s = new Schema({\n        arr: [\n          { something: { type: String } }\n        ]\n      });\n      assert.ok(s.path('arr') instanceof SchemaTypes.DocumentArray);\n      const M = goose.model('objectliteralschema', s);\n      const m = new M({ arr: [{ something: 'wicked this way comes' }] });\n      assert.equal(m.arr[0].something, 'wicked this way comes');\n      assert.ok(m.arr[0]._id);\n      done();\n    });\n\n    it('array of object literal with type.type is interpreted as DocumentArray', function(done) {\n      const goose = new mongoose.Mongoose();\n      const s = new Schema({\n        arr: [\n          { type: { type: String } }\n        ]\n      });\n      assert.ok(s.path('arr') instanceof SchemaTypes.DocumentArray);\n      const M = goose.model('objectliteralschema2', s);\n      const m = new M({ arr: [{ type: 'works' }] });\n      assert.equal(m.arr[0].type, 'works');\n      assert.ok(m.arr[0]._id);\n      done();\n    });\n\n    it('does not alter original argument (gh-1364)', function(done) {\n      const schema = {\n        ids: [{ type: Schema.ObjectId, ref: 'something' }],\n        a: { type: Array },\n        b: Array,\n        c: [Date],\n        d: { type: 'Boolean' },\n        e: [{ a: String, b: [{ type: { type: Buffer }, x: Number }] }]\n      };\n\n      new Schema(schema);\n      assert.equal(Object.keys(schema).length, 6);\n      assert.deepEqual([{ type: Schema.ObjectId, ref: 'something' }], schema.ids);\n      assert.deepEqual({ type: Array }, schema.a);\n      assert.deepEqual(Array, schema.b);\n      assert.deepEqual([Date], schema.c);\n      assert.deepEqual({ type: 'Boolean' }, schema.d);\n      assert.deepEqual([{ a: String, b: [{ type: { type: Buffer }, x: Number }] }], schema.e);\n\n      done();\n    });\n\n    it('properly gets value of plain objects when dealing with refs (gh-1606)', function(done) {\n      const el = new Schema({ title: String });\n      const so = new Schema({\n        title: String,\n        obj: { type: Schema.Types.ObjectId, ref: 'Test' }\n      });\n\n      const Element = db.model('Test', el);\n      const Some = db.model('Test1', so);\n\n      const ele = new Element({ title: 'thing' });\n\n      ele.save(function(err) {\n        assert.ifError(err);\n        const s = new Some({ obj: ele.toObject() });\n        s.save(function(err) {\n          assert.ifError(err);\n          Some.findOne({ _id: s.id }, function(err, ss) {\n            assert.ifError(err);\n            assert.equal(ss.obj, ele.id);\n            done();\n          });\n        });\n      });\n    });\n\n    it('array of of schemas and objects (gh-7218)', function(done) {\n      const baseSchema = new Schema({ created: Date }, { id: true });\n      const s = new Schema([baseSchema, { name: String }], { id: false });\n\n      assert.ok(s.path('created'));\n      assert.ok(s.path('name'));\n      assert.ok(!s.options.id);\n\n      done();\n    });\n  });\n\n  describe('property names', function() {\n    describe('reserved keys are log a warning (gh-9010)', () => {\n      this.afterEach(() => sinon.restore());\n      const reservedProperties = [\n        'emit', 'listeners', 'removeListener', /* 'collection', */ // TODO: add `collection`\n        'errors', 'get', 'init', 'isModified', 'isNew', 'populated',\n        'remove', 'save', 'toObject', 'validate'\n      ];\n\n      for (const reservedProperty of reservedProperties) {\n        it(`\\`${reservedProperty}\\` when used as a schema path logs a warning`, async() => {\n          // Arrange\n          const emitWarningStub = sinon.stub(process, 'emitWarning').returns();\n\n          // Act\n          new Schema({ [reservedProperty]: String });\n\n          // Assert\n          const lastWarnMessage = emitWarningStub.args[0][0];\n          assert.ok(lastWarnMessage.includes(`\\`${reservedProperty}\\` is a reserved schema pathname`), lastWarnMessage);\n        });\n\n        it(`\\`${reservedProperty}\\` when used as a schema path doesn't log a warning if \\`supressReservedKeysWarning\\` is true`, async() => {\n          // Arrange\n          const emitWarningStub = sinon.stub(process, 'emitWarning').returns();\n\n\n          // Act\n          new Schema(\n            { [reservedProperty]: String },\n            { supressReservedKeysWarning: true }\n          );\n\n          const lastWarnMessage = emitWarningStub.args[0] && emitWarningStub.args[0][0];\n\n          // Assert\n          assert.strictEqual(lastWarnMessage, undefined);\n        });\n      }\n    });\n\n\n    it('that do not conflict do not throw', function() {\n      assert.doesNotThrow(function() {\n        new Schema({\n          model: String\n        });\n      });\n\n      assert.doesNotThrow(function() {\n        Schema({ child: [{ parent: String }] });\n      });\n\n      assert.doesNotThrow(function() {\n        Schema({ child: [{ parentArray: String }] });\n      });\n\n      assert.doesNotThrow(function() {\n        const s = new Schema({ docs: [{ path: String }] });\n        const M = mongoose.model('gh-1245', s);\n        new M({ docs: [{ path: 'works' }] });\n      });\n\n      assert.doesNotThrow(function() {\n        const s = new Schema({ setMaxListeners: String });\n        const M = mongoose.model('setMaxListeners-as-property-name', s);\n        new M({ setMaxListeners: 'works' });\n      });\n    });\n\n    it('permit _scope to be used (gh-1184)', function(done) {\n      const child = new Schema({ _scope: Schema.ObjectId });\n      const C = db.model('Test', child);\n      const c = new C();\n      c.save(function(err) {\n        assert.ifError(err);\n        try {\n          c._scope;\n        } catch (e) {\n          err = e;\n        }\n        assert.ifError(err);\n        done();\n      });\n    });\n  });\n\n  describe('pathType()', function() {\n    let schema;\n\n    before(function() {\n      schema = new Schema({\n        n: String,\n        nest: { thing: { nests: Boolean } },\n        docs: [{ x: [{ y: String }] }],\n        mixed: {}\n      });\n      schema.virtual('myVirtual').get(function() { return 42; });\n    });\n\n    describe('when called on an explicit real path', function() {\n      it('returns \"real\"', function(done) {\n        assert.equal(schema.pathType('n'), 'real');\n        assert.equal(schema.pathType('nest.thing.nests'), 'real');\n        assert.equal(schema.pathType('docs'), 'real');\n        assert.equal(schema.pathType('docs.0.x'), 'real');\n        assert.equal(schema.pathType('docs.0.x.3.y'), 'real');\n        assert.equal(schema.pathType('mixed'), 'real');\n        done();\n      });\n    });\n    describe('when called on a virtual', function() {\n      it('returns virtual', function(done) {\n        assert.equal(schema.pathType('myVirtual'), 'virtual');\n        done();\n      });\n    });\n    describe('when called on nested structure', function() {\n      it('returns nested', function(done) {\n        assert.equal(schema.pathType('nest'), 'nested');\n        assert.equal(schema.pathType('nest.thing'), 'nested');\n        done();\n      });\n    });\n    describe('when called on undefined path', function() {\n      it('returns adHocOrUndefined', function(done) {\n        assert.equal(schema.pathType('mixed.what'), 'adhocOrUndefined');\n        assert.equal(schema.pathType('mixed.4'), 'adhocOrUndefined');\n        assert.equal(schema.pathType('mixed.4.thing'), 'adhocOrUndefined');\n        assert.equal(schema.pathType('mixed.4a.thing'), 'adhocOrUndefined');\n        assert.equal(schema.pathType('mixed.4.9.thing'), 'adhocOrUndefined');\n        assert.equal(schema.pathType('n.3'), 'adhocOrUndefined');\n        assert.equal(schema.pathType('n.3a'), 'adhocOrUndefined');\n        assert.equal(schema.pathType('n.3.four'), 'adhocOrUndefined');\n        assert.equal(schema.pathType('n.3.4'), 'adhocOrUndefined');\n        assert.equal(schema.pathType('n.3.4a'), 'adhocOrUndefined');\n        assert.equal(schema.pathType('nest.x'), 'adhocOrUndefined');\n        assert.equal(schema.pathType('nest.thing.x'), 'adhocOrUndefined');\n        assert.equal(schema.pathType('nest.thing.nests.9'), 'adhocOrUndefined');\n        assert.equal(schema.pathType('nest.thing.nests.9a'), 'adhocOrUndefined');\n        assert.equal(schema.pathType('nest.thing.nests.a'), 'adhocOrUndefined');\n        done();\n      });\n    });\n\n    it('handles maps (gh-7448) (gh-7464)', function() {\n      const schema = new Schema({ map: { type: Map, of: String } });\n\n      assert.equal(schema.pathType('map.foo'), 'real');\n      assert.equal(schema.pathType('map'), 'real');\n      assert.equal(schema.pathType('mapfoo'), 'adhocOrUndefined');\n      assert.equal(schema.pathType('fake'), 'adhocOrUndefined');\n\n      return Promise.resolve();\n    });\n  });\n\n  it('required() with doc arrays (gh-3199)', function(done) {\n    const schema = new Schema({\n      test: [{ x: String }]\n    });\n\n    schema.path('test').schema.path('x').required(true);\n    const M = mongoose.model('gh3199', schema);\n    const m = new M({ test: [{}] });\n\n    assert.equal(m.validateSync().errors['test.0.x'].kind, 'required');\n    done();\n  });\n\n  it('custom typeKey in doc arrays (gh-3560)', function(done) {\n    const schema = new Schema({\n      test: [{\n        name: { $type: String }\n      }]\n    }, { typeKey: '$type' });\n\n    schema.path('test').schema.path('name').required(true);\n    const M = mongoose.model('gh3560', schema);\n    const m = new M({ test: [{ name: 'Val' }] });\n\n    assert.ifError(m.validateSync());\n    assert.equal(m.test[0].name, 'Val');\n    done();\n  });\n\n  it('required for single nested schemas (gh-3562)', function(done) {\n    const personSchema = new Schema({\n      name: { type: String, required: true }\n    });\n\n    const bandSchema = new Schema({\n      name: String,\n      guitarist: { type: personSchema, required: true }\n    });\n\n    const Band = mongoose.model('gh3562', bandSchema);\n    const band = new Band({ name: 'Guns N\\' Roses' });\n\n    assert.ok(band.validateSync());\n    assert.ok(band.validateSync().errors.guitarist);\n    band.guitarist = { name: 'Slash' };\n    assert.ifError(band.validateSync());\n\n    done();\n  });\n\n  it('booleans cause cast error for date (gh-3935)', function(done) {\n    const testSchema = new Schema({\n      test: Date\n    });\n\n    const Test = mongoose.model('gh3935', testSchema);\n    const test = new Test({ test: true });\n\n    assert.ok(test.validateSync());\n    assert.equal(test.validateSync().errors.test.name, 'CastError');\n\n    done();\n  });\n\n  it('trim: false works with strings (gh-4042)', function(done) {\n    const testSchema = new Schema({\n      test: { type: String, trim: false }\n    });\n\n    const Test = mongoose.model('gh4042', testSchema);\n    const test = new Test({ test: ' test ' });\n    assert.equal(test.test, ' test ');\n    done();\n  });\n\n  it('arrays with typeKey (gh-4548)', function(done) {\n    const testSchema = new Schema({\n      test: [{ $type: String }]\n    }, { typeKey: '$type' });\n\n    assert.equal(testSchema.paths.test.caster.instance, 'String');\n\n    const Test = mongoose.model('gh4548', testSchema);\n    const test = new Test({ test: [123] });\n    assert.strictEqual(test.test[0], '123');\n    done();\n  });\n\n  it('arrays of mixed arrays (gh-5416)', function(done) {\n    const testSchema = new Schema({\n      test: [Array]\n    });\n\n    assert.ok(testSchema.paths.test.casterConstructor !== Array);\n    assert.equal(testSchema.paths.test.casterConstructor,\n      mongoose.Schema.Types.Array);\n\n    done();\n  });\n\n  describe('remove()', function() {\n    before(function() {\n      this.schema = new Schema({\n        a: String,\n        b: {\n          c: {\n            d: String\n          }\n        },\n        e: Number,\n        f: String,\n        g: [String]\n      });\n    });\n\n    it('returns the schema instance', function() {\n      const ret = this.schema.clone().remove('g');\n      assert.ok(ret instanceof Schema);\n    });\n\n    it('removes a single path', function(done) {\n      assert.ok(this.schema.paths.a);\n      this.schema.remove('a');\n      assert.strictEqual(this.schema.path('a'), undefined);\n      assert.strictEqual(this.schema.paths.a, void 0);\n      done();\n    });\n\n    it('removes a nested path', function(done) {\n      this.schema.remove('b.c.d');\n      assert.strictEqual(this.schema.path('b'), undefined);\n      assert.strictEqual(this.schema.path('b.c'), undefined);\n      assert.strictEqual(this.schema.path('b.c.d'), undefined);\n      done();\n    });\n\n    it('removes all children of a nested path (gh-2398)', function(done) {\n      this.schema.remove('b');\n      assert.strictEqual(this.schema.nested['b'], undefined);\n      assert.strictEqual(this.schema.nested['b.c'], undefined);\n      assert.strictEqual(this.schema.path('b.c.d'), undefined);\n      done();\n    });\n\n    it('removes an array of paths', function(done) {\n      this.schema.remove(['e', 'f', 'g']);\n      assert.strictEqual(this.schema.path('e'), undefined);\n      assert.strictEqual(this.schema.path('f'), undefined);\n      assert.strictEqual(this.schema.path('g'), undefined);\n      done();\n    });\n\n    it('works properly with virtuals (gh-2398)', function(done) {\n      this.schema.remove('a');\n      this.schema.virtual('a').get(function() { return 42; });\n      const Test = mongoose.model('gh2398', this.schema);\n      const t = new Test();\n      assert.equal(t.a, 42);\n      done();\n    });\n\n    it('methods named toString (gh-4551)', function() {\n      this.schema.methods.toString = function() {\n        return 'test';\n      };\n      assert.doesNotThrow(() => {\n        mongoose.model('gh4551', this.schema);\n      });\n    });\n\n    it('handles default value = 0 (gh-4620)', function(done) {\n      const schema = new Schema({\n        tags: { type: [Number], default: 0 }\n      });\n      assert.deepEqual(schema.path('tags').getDefault().toObject(), [0]);\n      done();\n    });\n\n    it('type: childSchema (gh-5521)', function(done) {\n      const childSchema = new mongoose.Schema({\n        name: String\n      }, { _id: false });\n\n      const schema = new mongoose.Schema({\n        children: [{ type: childSchema }]\n      });\n\n      const Model = mongoose.model('gh5521', schema);\n\n      const doc = new Model({ children: [{ name: 'test' }] });\n      assert.deepEqual(doc.toObject().children, [{ name: 'test' }]);\n      done();\n    });\n\n    it('Decimal128 type (gh-4759)', function(done) {\n      const Decimal128 = mongoose.Schema.Types.Decimal128;\n      const schema = new Schema({\n        num: Decimal128,\n        nums: ['Decimal128']\n      });\n      assert.ok(schema.path('num') instanceof Decimal128);\n      assert.ok(schema.path('nums').caster instanceof Decimal128);\n\n      const casted = schema.path('num').cast('6.2e+23');\n      assert.ok(casted instanceof mongoose.Types.Decimal128);\n      assert.equal(casted.toString(), '6.2E+23');\n      done();\n    });\n\n    describe('clone()', function() {\n      it('copies methods, statics, and query helpers (gh-5752)', function(done) {\n        const schema = new Schema({});\n\n        schema.methods.fakeMethod = function() { return 'fakeMethod'; };\n        schema.statics.fakeStatic = function() { return 'fakeStatic'; };\n        schema.query.fakeQueryHelper = function() { return 'fakeQueryHelper'; };\n\n        const clone = schema.clone();\n        assert.equal(clone.methods.fakeMethod, schema.methods.fakeMethod);\n        assert.equal(clone.statics.fakeStatic, schema.statics.fakeStatic);\n        assert.equal(clone.query.fakeQueryHelper, schema.query.fakeQueryHelper);\n        done();\n      });\n\n      it('copies validators declared with validate() (gh-5607)', function(done) {\n        const schema = new Schema({\n          num: Number\n        });\n\n        schema.path('num').validate(function(v) {\n          return v === 42;\n        });\n\n        const clone = schema.clone();\n        assert.equal(clone.path('num').validators.length, 1);\n        assert.ok(clone.path('num').validators[0].validator(42));\n        assert.ok(!clone.path('num').validators[0].validator(41));\n        done();\n      });\n\n      it('copies virtuals (gh-6133)', function(done) {\n        const userSchema = new Schema({\n          firstName: { type: String, required: true },\n          lastName: { type: String, required: true }\n        });\n\n        userSchema.virtual('fullName').get(function() {\n          return this.firstName + ' ' + this.lastName;\n        });\n\n        assert.ok(userSchema.virtuals.fullName);\n        const clonedUserSchema = userSchema.clone();\n        assert.ok(clonedUserSchema.virtuals.fullName);\n\n        done();\n      });\n\n      it('with nested virtuals (gh-6274)', function(done) {\n        const PersonSchema = new Schema({\n          name: {\n            first: String,\n            last: String\n          }\n        });\n\n        PersonSchema.\n          virtual('name.full').\n          get(function() {\n            return this.get('name.first') + ' ' + this.get('name.last');\n          }).\n          set(function(fullName) {\n            const split = fullName.split(' ');\n            this.set('name.first', split[0]);\n            this.set('name.last', split[1]);\n          });\n\n        const M = db.model('Test', PersonSchema.clone());\n\n        const doc = new M({ name: { first: 'Axl', last: 'Rose' } });\n        assert.equal(doc.name.full, 'Axl Rose');\n\n        done();\n      });\n\n      it('with alternative option syntaxes (gh-6274)', function(done) {\n        const TestSchema = new Schema({}, { _id: false, id: false });\n\n        TestSchema.virtual('test').get(() => 42);\n\n        TestSchema.set('toJSON', { virtuals: true });\n        TestSchema.options.toObject = { virtuals: true };\n\n        const clone = TestSchema.clone();\n        assert.deepEqual(clone._userProvidedOptions, {\n          toJSON: { virtuals: true },\n          _id: false,\n          id: false\n        });\n        const M = db.model('Test', clone);\n\n        const doc = new M({});\n\n        assert.deepEqual(doc.toJSON(), { test: 42 });\n        assert.deepEqual(doc.toObject(), { test: 42 });\n\n        done();\n      });\n\n      it('copies base for using custom types after cloning (gh-7377)', function() {\n        const db = new mongoose.Mongoose();\n\n        class MyType extends mongoose.SchemaType {}\n        db.Schema.Types.MyType = MyType;\n\n        const schema = new db.Schema({ name: MyType });\n        const otherSchema = schema.clone();\n\n        assert.doesNotThrow(function() {\n          otherSchema.add({ name2: MyType });\n        });\n      });\n\n      it('clones schema types (gh-7537)', function() {\n        const schema = new Schema({ name: String });\n\n        assert.equal(schema.path('name').validators.length, 0);\n        const otherSchema = schema.clone();\n\n        otherSchema.path('name').required();\n\n        assert.equal(otherSchema.path('name').validators.length, 1);\n        assert.equal(schema.path('name').validators.length, 0);\n      });\n\n      it('correctly copies all child schemas (gh-7537)', function() {\n        const l3Schema = new Schema({ name: String });\n        const l2Schema = new Schema({ l3: l3Schema });\n        const l1Schema = new Schema({ l2: l2Schema });\n\n        assert.equal(l1Schema.childSchemas.length, 1);\n        assert.ok(l1Schema.childSchemas[0].schema.path('l3'));\n\n        const otherSchema = l1Schema.clone();\n\n        assert.equal(otherSchema.childSchemas.length, 1);\n        assert.ok(otherSchema.childSchemas[0].schema.path('l3'));\n      });\n\n      it('copies single embedded discriminators (gh-7894)', function() {\n        const colorSchema = new Schema({}, { discriminatorKey: 'type' });\n        colorSchema.methods.isYellow = () => false;\n\n        const yellowSchema = new Schema();\n        yellowSchema.methods.isYellow = () => true;\n\n        const fruitSchema = new Schema({}, { discriminatorKey: 'type' });\n\n        const bananaSchema = new Schema({ color: { type: colorSchema } });\n        bananaSchema.path('color').discriminator('yellow', yellowSchema);\n        bananaSchema.methods.isYellow = function() { return this.color.isYellow(); };\n\n        const schema = new Schema({ fruits: [fruitSchema] });\n\n        const clone = bananaSchema.clone();\n        schema.path('fruits').discriminator('banana', clone);\n        assert.ok(clone.path('color').caster.discriminators);\n\n        const Basket = db.model('Test', schema);\n        const b = new Basket({\n          fruits: [\n            {\n              type: 'banana',\n              color: { type: 'yellow' }\n            }\n          ]\n        });\n\n        assert.ok(b.fruits[0].isYellow());\n      });\n\n      it('copies array discriminators (gh-7954)', function() {\n        const eventSchema = Schema({ message: String }, {\n          discriminatorKey: 'kind',\n          _id: false\n        });\n\n        const batchSchema = Schema({ events: [eventSchema] }, {\n          _id: false\n        });\n\n        const docArray = batchSchema.path('events');\n        docArray.discriminator('gh7954_Clicked',\n          Schema({ element: String }, { _id: false }));\n        docArray.discriminator('gh7954_Purchased',\n          Schema({ product: String }, { _id: false }));\n\n        const clone = batchSchema.clone();\n        assert.ok(clone.path('events').Constructor.discriminators);\n        assert.ok(clone.path('events').Constructor.discriminators['gh7954_Clicked']);\n        assert.ok(clone.path('events').Constructor.discriminators['gh7954_Purchased']);\n      });\n\n      it('uses Mongoose instance\\'s Schema constructor (gh-9426)', function() {\n        const db = new mongoose.Mongoose();\n        db.Schema.prototype.localTest = function() {\n          return 42;\n        };\n        const test = new db.Schema({});\n        assert.equal(test.localTest(), 42);\n\n        const test2 = test.clone();\n        assert.equal(test2.localTest(), 42);\n      });\n    });\n\n    it('childSchemas prop (gh-5695)', function(done) {\n      const schema1 = new Schema({ name: String });\n      const schema2 = new Schema({ test: String });\n      let schema = new Schema({\n        arr: [schema1],\n        single: schema2\n      });\n\n      assert.equal(schema.childSchemas.length, 2);\n      assert.strictEqual(schema.childSchemas[0].schema, schema1);\n      assert.strictEqual(schema.childSchemas[1].schema, schema2);\n\n      schema = schema.clone();\n      assert.equal(schema.childSchemas.length, 2);\n      assert.strictEqual(schema.childSchemas[0].schema, schema1);\n      assert.strictEqual(schema.childSchemas[1].schema, schema2);\n\n      done();\n    });\n  });\n\n  it('throws a sane error if passing a schema to `ref` (gh-6915)', function() {\n    const testSchema = new Schema({ name: String });\n\n    assert.throws(function() {\n      new Schema({ badRef: { type: String, ref: testSchema } });\n    }, /Invalid ref at path \"badRef\"/);\n\n    const parentSchema = new Schema({ name: String });\n    assert.throws(function() {\n      parentSchema.add({ badRef2: { type: String, ref: testSchema } });\n    }, /Invalid ref at path \"badRef2\"/);\n\n    assert.ok(!parentSchema.tree.badRef2);\n    assert.deepEqual(Object.keys(parentSchema.paths).sort(), ['_id', 'name']);\n\n    return Promise.resolve();\n  });\n\n  it('allows using ObjectId type as schema path (gh-7049)', function() {\n    const testSchema = new Schema({\n      p1: mongoose.Types.ObjectId,\n      p2: require('mongodb').ObjectId\n    });\n\n    assert.ok(testSchema.path('p1') instanceof mongoose.ObjectId);\n    assert.ok(testSchema.path('p2') instanceof mongoose.ObjectId);\n\n    return Promise.resolve();\n  });\n\n  it('throws error if invalid type (gh-7303)', function() {\n    assert.throws(() => {\n      new Schema({\n        bad: true\n      });\n    }, /invalid.*true.*bad/i);\n\n    return Promise.resolve();\n  });\n\n  it('supports _id: false in paths definition (gh-7480) (gh-7524)', function() {\n    const schema = new Schema({ _id: false, name: String });\n    assert.ok(schema.path('_id') == null);\n    assert.equal(schema.options._id, false);\n\n    const otherSchema = new Schema({ name: String, nested: { _id: false, name: String } });\n    assert.ok(otherSchema.path('_id'));\n    assert.equal(otherSchema.options._id, true);\n\n    return Promise.resolve();\n  });\n\n  it('schema.pathType() with positional path that isnt in schema (gh-7935)', function() {\n    const subdocSchema = Schema({\n      list: { type: [String], default: ['a'] }\n    }, { minimize: false });\n    const testSchema = Schema({\n      lists: subdocSchema\n    });\n\n    assert.strictEqual(testSchema.pathType('subpaths.list.0.options'),\n      'adhocOrUndefined');\n  });\n\n  it('supports pre(Array, Function) and post(Array, Function) (gh-7803)', function() {\n    const schema = Schema({ name: String });\n    schema.pre(['save', 'remove'], testMiddleware);\n    function testMiddleware() {\n      console.log('foo');\n    }\n\n    assert.equal(schema.s.hooks._pres.get('save').length, 1);\n    assert.equal(schema.s.hooks._pres.get('save')[0].fn, testMiddleware);\n    assert.equal(schema.s.hooks._pres.get('remove').length, 1);\n    assert.equal(schema.s.hooks._pres.get('remove')[0].fn, testMiddleware);\n\n    schema.post(['save', 'remove'], testMiddleware);\n    assert.equal(schema.s.hooks._posts.get('save').length, 1);\n    assert.equal(schema.s.hooks._posts.get('save')[0].fn, testMiddleware);\n    assert.equal(schema.s.hooks._posts.get('remove').length, 1);\n    assert.equal(schema.s.hooks._posts.get('remove')[0].fn, testMiddleware);\n  });\n\n  it('supports array with { type: ObjectID } (gh-8034)', function() {\n    const schema = Schema({ testId: [{ type: 'ObjectID' }] });\n    const path = schema.path('testId');\n    assert.ok(path);\n    assert.ok(path.caster instanceof Schema.ObjectId);\n  });\n\n  it('supports getting path under array (gh-8057)', function() {\n    const schema = new Schema({ arr: [{ name: String }] });\n    assert.ok(schema.path('arr.name') instanceof SchemaTypes.String);\n    assert.ok(schema.path('arr.0.name') instanceof SchemaTypes.String);\n  });\n\n  it('required paths with clone() (gh-8111)', function() {\n    const schema = Schema({ field: { type: String, required: true } });\n    const Model = db.model('Test', schema.clone());\n\n    const doc = new Model({});\n\n    return doc.validate().then(() => assert.ok(false), err => {\n      assert.ok(err);\n      assert.ok(err.errors['field']);\n    });\n  });\n\n  it('getters/setters with clone() (gh-8124)', function() {\n    const schema = new mongoose.Schema({\n      field: { type: String, required: true }\n    });\n\n    schema.path('field').set(value => value ? value.toUpperCase() : value);\n\n    const TestKo = db.model('Test', schema.clone());\n\n    const testKo = new TestKo({ field: 'upper' });\n    assert.equal(testKo.field, 'UPPER');\n  });\n\n  it('required with nullish value (gh-8219)', function() {\n    const schema = Schema({\n      name: { type: String, required: void 0 },\n      age: { type: Number, required: null }\n    });\n    assert.strictEqual(schema.path('name').isRequired, false);\n    assert.strictEqual(schema.path('age').isRequired, false);\n  });\n\n  it('SchemaStringOptions line up with schema/string (gh-8256)', function() {\n    const SchemaStringOptions = require('../lib/options/SchemaStringOptions');\n    const keys = Object.keys(SchemaStringOptions.prototype).\n      filter(key => key !== 'constructor' && key !== 'populate');\n    const functions = Object.keys(Schema.Types.String.prototype).\n      filter(key => ['constructor', 'cast', 'castForQuery', 'checkRequired'].indexOf(key) === -1);\n    assert.deepEqual(keys.sort(), functions.sort());\n  });\n\n  it('supports passing schema options to `Schema#path()` (gh-8292)', function() {\n    const schema = Schema({ title: String });\n    const path = schema.path('title');\n\n    const newSchema = Schema({});\n    newSchema.add({ title: path.options });\n\n    assert.equal(newSchema.path('title').options.type, String);\n  });\n\n  it('supports defining `_id: false` on single nested paths (gh-8137)', function() {\n    let childSchema = Schema({ name: String });\n    let parentSchema = Schema({\n      child: {\n        type: childSchema,\n        _id: false\n      }\n    });\n\n    assert.ok(!parentSchema.path('child').schema.options._id);\n    assert.ok(childSchema.options._id);\n\n    let Parent = mongoose.model('gh8137', parentSchema);\n    let doc = new Parent({ child: { name: 'test' } });\n    assert.equal(doc.child._id, null);\n\n    childSchema = Schema({ name: String }, { _id: false });\n    parentSchema = Schema({\n      child: {\n        type: childSchema,\n        _id: true\n      }\n    });\n\n    assert.ok(parentSchema.path('child').schema.options._id);\n    assert.ok(parentSchema.path('child').schema.paths['_id']);\n    assert.ok(!childSchema.options._id);\n    assert.ok(!childSchema.paths['_id']);\n\n    mongoose.deleteModel(/gh8137/);\n    Parent = mongoose.model('gh8137', parentSchema);\n    doc = new Parent({ child: { name: 'test' } });\n    assert.ok(doc.child._id);\n  });\n\n  it('supports defining `_id: false` on document arrays (gh-8450)', function() {\n    const nestedSchema = Schema({ some: String });\n    let parentSchema = Schema({\n      arrayed: {\n        type: [{\n          type: nestedSchema,\n          _id: false\n        }]\n      }\n    });\n\n    assert.ok(!parentSchema.path('arrayed').schema.path('_id'));\n\n    parentSchema = Schema({\n      arrayed: {\n        type: [{\n          type: nestedSchema\n        }],\n        _id: false\n      }\n    });\n\n    assert.ok(!parentSchema.path('arrayed').schema.path('_id'));\n\n    parentSchema = Schema({\n      arrayed: {\n        type: [{\n          type: nestedSchema\n        }]\n      }\n    });\n\n    assert.ok(parentSchema.path('arrayed').schema.path('_id').auto);\n  });\n\n  describe('pick() (gh-8207)', function() {\n    it('works with nested paths', function() {\n      const schema = Schema({\n        name: {\n          first: {\n            type: String,\n            required: true\n          },\n          last: {\n            type: String,\n            required: true\n          }\n        },\n        age: {\n          type: Number,\n          index: true\n        }\n      });\n      assert.ok(schema.path('name.first'));\n      assert.ok(schema.path('name.last'));\n\n      let newSchema = schema.pick(['age']);\n      assert.ok(!newSchema.path('name.first'));\n      assert.ok(newSchema.path('age'));\n      assert.ok(newSchema.path('age').index);\n\n      newSchema = schema.pick(['name']);\n      assert.ok(newSchema.path('name.first'));\n      assert.ok(newSchema.path('name.first').required);\n      assert.ok(newSchema.path('name.last'));\n      assert.ok(newSchema.path('name.last').required);\n      assert.ok(!newSchema.path('age'));\n\n      newSchema = schema.pick(['name.first']);\n      assert.ok(newSchema.path('name.first'));\n      assert.ok(newSchema.path('name.first').required);\n      assert.ok(!newSchema.path('name.last'));\n      assert.ok(!newSchema.path('age'));\n    });\n\n    it('with single nested paths', function() {\n      const schema = Schema({\n        name: Schema({\n          first: {\n            type: String,\n            required: true\n          },\n          last: {\n            type: String,\n            required: true\n          }\n        }),\n        age: {\n          type: Number,\n          index: true\n        }\n      });\n      assert.ok(schema.path('name.first'));\n      assert.ok(schema.path('name.last'));\n\n      let newSchema = schema.pick(['name']);\n      assert.ok(newSchema.path('name.first'));\n      assert.ok(newSchema.path('name.first').required);\n      assert.ok(newSchema.path('name.last'));\n      assert.ok(newSchema.path('name.last').required);\n      assert.ok(!newSchema.path('age'));\n\n      newSchema = schema.pick(['name.first']);\n      assert.ok(newSchema.path('name.first'));\n      assert.ok(newSchema.path('name.first').required);\n      assert.ok(!newSchema.path('name.last'));\n      assert.ok(!newSchema.path('age'));\n    });\n  });\n\n  describe('path-level custom cast (gh-8300)', function() {\n    it('with numbers', function() {\n      const schema = Schema({\n        num: {\n          type: Number,\n          cast: '{VALUE} is not a number'\n        }\n      });\n\n      let threw = false;\n      try {\n        schema.path('num').cast('horseradish');\n      } catch (err) {\n        threw = true;\n        assert.equal(err.name, 'CastError');\n        assert.equal(err.message, '\"horseradish\" is not a number');\n      }\n      assert.ok(threw);\n    });\n\n    it('with objectids', function() {\n      const schema = Schema({\n        userId: {\n          type: mongoose.ObjectId,\n          cast: 'Invalid user ID'\n        }\n      });\n\n      let threw = false;\n      try {\n        schema.path('userId').cast('foo');\n      } catch (err) {\n        threw = true;\n        assert.equal(err.name, 'CastError');\n        assert.equal(err.message, 'Invalid user ID');\n      }\n      assert.ok(threw);\n    });\n\n    it('with boolean', function() {\n      const schema = Schema({\n        vote: {\n          type: Boolean,\n          cast: '{VALUE} is invalid at path {PATH}'\n        }\n      });\n\n      let threw = false;\n      try {\n        schema.path('vote').cast('nay');\n      } catch (err) {\n        threw = true;\n        assert.equal(err.name, 'CastError');\n        assert.equal(err.message, '\"nay\" is invalid at path vote');\n      }\n      assert.ok(threw);\n    });\n  });\n\n  it('copies `.add()`-ed paths when calling `.add()` with a schema argument (gh-8429)', function() {\n    const ToySchema = Schema();\n    ToySchema.add({ name: String, color: String, price: Number });\n\n    const TurboManSchema = Schema();\n    TurboManSchema.add(ToySchema).add({ year: Number });\n\n    assert.equal(TurboManSchema.path('name').instance, 'String');\n    assert.equal(TurboManSchema.path('color').instance, 'String');\n    assert.equal(TurboManSchema.path('price').instance, 'Number');\n    assert.equal(TurboManSchema.path('year').instance, 'Number');\n  });\n\n  describe('gh-8849', function() {\n    it('treats `select: undefined` as not specifying `select` option', async function() {\n      const userSchema = new Schema({ name: { type: String, select: undefined } });\n      const User = db.model('User', userSchema);\n\n\n      await User.create({ name: 'Hafez' });\n      const user = await User.findOne();\n\n      assert.equal(user.name, 'Hafez');\n    });\n\n    it('treats `select: null` as not specifying `select` option', async function() {\n      const userSchema = new Schema({ name: { type: String, select: null } });\n      const User = db.model('User', userSchema);\n\n\n      await User.create({ name: 'Hafez' });\n      const user = await User.findOne();\n\n      assert.equal(user.name, 'Hafez');\n    });\n  });\n\n  it('disables `id` virtual if no `_id` path (gh-3936)', function() {\n    const schema = Schema({ name: String }, { _id: false });\n    applyPlugins(schema, [[idGetter]]);\n    assert.ok(!schema.paths._id);\n    assert.ok(!schema.virtuals.id);\n  });\n\n  describe('mongoose.set(`strictQuery`, value); (gh-6658)', function() {\n    let strictQueryOriginalValue;\n\n    this.beforeEach(() => strictQueryOriginalValue = mongoose.get('strictQuery'));\n    this.afterEach(() => mongoose.set('strictQuery', strictQueryOriginalValue));\n\n    it('setting `strictQuery` on base sets strictQuery to schema (gh-6658)', function() {\n      // Arrange\n      mongoose.set('strictQuery', 'some value');\n\n      // Act\n      const schema = new Schema();\n\n      // Assert\n      assert.equal(schema.get('strictQuery'), 'some value');\n    });\n\n    it('`strictQuery` set on base gets overwritten by option set on schema (gh-6658)', function() {\n      // Arrange\n      mongoose.set('strictQuery', 'base option');\n\n      // Act\n      const schema = new Schema({}, { strictQuery: 'schema option' });\n\n      // Assert\n      assert.equal(schema.get('strictQuery'), 'schema option');\n    });\n  });\n\n  it('treats dotted paths with no parent as a nested path (gh-9020)', function() {\n    const customerSchema = new Schema({\n      'card.brand': String,\n      'card.last4': String\n    });\n\n    assert.ok(customerSchema.nested['card']);\n  });\n\n  it('allows using `mongoose.Schema.Types.Array` as type (gh-9194)', function() {\n    const schema = new Schema({\n      arr: mongoose.Schema.Types.Array\n    });\n\n    assert.equal(schema.path('arr').caster.instance, 'Mixed');\n  });\n\n  it('handles using a schematype when defining a path (gh-9370)', function() {\n    const schema1 = Schema({\n      foo: {\n        type: Number,\n        min: 4,\n        get: get\n      }\n    });\n\n    function get(v) {\n      return Math.floor(v);\n    }\n\n    const schema2 = Schema({\n      bar: schema1.path('foo')\n    });\n\n    const schematype = schema2.path('bar');\n    assert.equal(schematype.path, 'bar');\n    assert.equal(schematype.options.type, Number);\n    assert.equal(schematype.options.min, 4);\n    assert.equal(schematype.options.get, get);\n  });\n\n  it('applies correct schema to nested primitive arrays (gh-9429)', function() {\n    const schema = new Schema({\n      ids: [[{ type: 'ObjectId', required: true }]]\n    });\n\n    const casted = schema.path('ids').cast([[]]);\n    assert.equal(casted[0].$path(), 'ids.$');\n  });\n\n  describe('cast option (gh-8407)', function() {\n    it('disable casting using `false`', function() {\n      const schema = Schema({\n        myId: { type: 'ObjectId', cast: false },\n        myNum: { type: 'number', cast: false },\n        myDate: { type: Date, cast: false },\n        myBool: { type: Boolean, cast: false },\n        myStr: { type: String, cast: false }\n      });\n\n      assert.throws(() => schema.path('myId').cast('12charstring'), /Cast to ObjectId failed/);\n      assert.throws(() => schema.path('myNum').cast('foo'), /Cast to Number failed/);\n      assert.throws(() => schema.path('myDate').cast('2012'), /Cast to date failed/);\n      assert.throws(() => schema.path('myBool').cast('true'), /Cast to Boolean failed/);\n      assert.throws(() => schema.path('myStr').cast(55), /Cast to string failed/);\n\n      schema.path('myId').cast(new mongoose.Types.ObjectId());\n      schema.path('myNum').cast(42);\n      schema.path('myDate').cast(new Date());\n      schema.path('myBool').cast(false);\n      schema.path('myStr').cast('Hello, World');\n    });\n\n    it('custom casters', function() {\n      const schema = Schema({\n        myId: {\n          type: 'ObjectId',\n          cast: v => new mongoose.Types.ObjectId(v)\n        },\n        myNum: {\n          type: 'number',\n          cast: v => Math.ceil(v)\n        },\n        myDate: { type: Date, cast: v => new Date(v) },\n        myBool: { type: Boolean, cast: v => !!v },\n        myStr: { type: String, cast: v => '' + v }\n      });\n\n      assert.equal(schema.path('myId').cast('12charstring').toHexString(), '313263686172737472696e67');\n      assert.equal(schema.path('myNum').cast(3.14), 4);\n      assert.equal(schema.path('myDate').cast('2012-06-01').getFullYear(), 2012);\n      assert.equal(schema.path('myBool').cast('hello'), true);\n      assert.equal(schema.path('myStr').cast(42), '42');\n\n      assert.throws(() => schema.path('myId').cast('bad'), /Cast to ObjectId failed/);\n    });\n  });\n\n  it('supports `of` for array type definition (gh-9564)', function() {\n    const schema = new Schema({\n      nums: { type: Array, of: Number },\n      tags: { type: 'array', of: String },\n      subdocs: { type: Array, of: Schema({ name: String }) }\n    });\n\n    assert.equal(schema.path('nums').caster.instance, 'Number');\n    assert.equal(schema.path('tags').caster.instance, 'String');\n    assert.equal(schema.path('subdocs').casterConstructor.schema.path('name').instance, 'String');\n  });\n\n  it('should use the top-most class\\'s getter/setter gh-8892', function() {\n    class C1 {\n      get hello() {\n        return 1;\n      }\n    }\n\n    class C2 extends C1 {\n      get hello() {\n        return 2;\n      }\n    }\n\n    const C1Schema = new mongoose.Schema({});\n    C1Schema.loadClass(C1);\n    const C1Model = db.model('C1', C1Schema);\n\n    const C2Schema = new mongoose.Schema({});\n    C2Schema.loadClass(C2);\n    const C2Model = db.model('C2', C2Schema);\n\n    assert.equal((new C1Model()).hello, 1);\n    assert.equal((new C2Model()).hello, 2);\n  });\n\n  it('handles loadClass with inheritted getters (gh-9975)', function() {\n    class User {\n      get displayAs() {\n        return null;\n      }\n    }\n\n    class TechnicalUser extends User {\n      get displayAs() {\n        return this.name;\n      }\n    }\n\n    const schema = new Schema({ name: String }).loadClass(TechnicalUser);\n\n    assert.equal(schema.virtuals.displayAs.applyGetters(null, { name: 'test' }), 'test');\n  });\n\n  it('loadClass with static getter (gh-10436)', function() {\n    const schema = new mongoose.Schema({\n      firstName: String,\n      lastName: String\n    });\n\n    class UserClass extends mongoose.Model {\n      get fullName() {\n        return `${this.firstName} ${this.lastName}`;\n      }\n\n      static get greeting() {\n        return 'Hello World';\n      }\n    }\n\n    const User = mongoose.model(UserClass, schema);\n\n    assert.equal(User.greeting, 'Hello World');\n  });\n\n  it('supports setting `ref` on array SchemaType (gh-10029)', function() {\n    const testSchema = new mongoose.Schema({\n      doesntpopulate: {\n        type: [mongoose.Schema.Types.ObjectId],\n        ref: 'features'\n      },\n      populatescorrectly: [{\n        type: mongoose.Schema.Types.ObjectId,\n        ref: 'features'\n      }]\n    });\n\n    assert.equal(testSchema.path('doesntpopulate.$').options.ref, 'features');\n    assert.equal(testSchema.path('populatescorrectly.$').options.ref, 'features');\n  });\n\n  it('path() gets single nested paths within document arrays (gh-10164)', function() {\n    const schema = mongoose.Schema({\n      field1: [mongoose.Schema({\n        field2: mongoose.Schema({\n          field3: Boolean\n        })\n      })]\n    });\n\n    assert.equal(schema.path('field1').instance, 'Array');\n    assert.equal(schema.path('field1.field2').instance, 'Embedded');\n    assert.equal(schema.path('field1.field2.field3').instance, 'Boolean');\n  });\n\n  it('supports creating nested paths underneath document arrays (gh-10193)', function() {\n    const DynamicTextMatchFeaturesSchema = new Schema({ css: { color: String } });\n\n    const ElementSchema = new Schema({\n      image: { type: String },\n      possibleElements: [{\n        textMatchFeatures: {\n          dynamic: DynamicTextMatchFeaturesSchema\n        }\n      }]\n    });\n\n    assert.ok(ElementSchema.path('possibleElements').schema.path('textMatchFeatures.dynamic').schema.nested['css']);\n  });\n\n  it('propagates map `ref` down to individual map elements (gh-10329)', function() {\n    const TestSchema = new mongoose.Schema({\n      testprop: {\n        type: Map,\n        of: Number,\n        ref: 'OtherModel'\n      }\n    });\n\n    assert.equal(TestSchema.path('testprop.$*').instance, 'Number');\n    assert.equal(TestSchema.path('testprop.$*').options.ref, 'OtherModel');\n  });\n\n  it('handles maps of maps (gh-10644)', function() {\n    const schema = new mongoose.Schema({\n      myMap: {\n        type: Map,\n        of: {\n          type: Map,\n          of: String\n        }\n      }\n    });\n    assert.equal(schema.path('myMap').$__schemaType.$__schemaType.instance, 'String');\n  });\n\n  it('handles `type: { subpath: String }` in document array definitions (gh-10750)', function() {\n    const schema = new mongoose.Schema({\n      something: [{ type: { somePath: String } }],\n      // also, same error message when doing:\n      somethingElse: { type: [{ type: { somePath: String } }] }\n    });\n\n    assert.equal(schema.path('something').caster.schema.path('somePath').instance, 'String');\n    assert.equal(schema.path('somethingElse').caster.schema.path('somePath').instance, 'String');\n  });\n\n  it('handles `Date` with `type` (gh-10807)', function() {\n    Date.type = Date;\n    const schema = new mongoose.Schema({\n      something: Date,\n      somethingElse: { type: Date, immutable: true }\n    });\n\n    assert.equal(schema.path('something').instance, 'Date');\n    assert.equal(schema.path('somethingElse').instance, 'Date');\n    delete Date.type;\n  });\n  it('setting path with `Mixed` type to an array after number (gh-11417)', async() => {\n    const userSchema = new Schema({ data: {} });\n    const User = db.model('User', userSchema);\n\n    const user = await User.create({ data: 2 });\n    user.set({ data: [] });\n    await user.save();\n    assert.ok(Array.isArray(user.data));\n\n    const foundUser = await User.findOne({ _id: user._id });\n    assert.ok(Array.isArray(foundUser.data));\n  });\n\n  it('sets an _applyDiscriminators property on the schema and add discriminator to appropriate model (gh-7971)', async() => {\n    const eventSchema = new mongoose.Schema({ message: String },\n      { discriminatorKey: 'kind' });\n    const batchSchema = new mongoose.Schema({ name: String }, { discriminatorKey: 'kind' });\n    batchSchema.discriminator('event', eventSchema);\n    assert(batchSchema._applyDiscriminators);\n    assert.ok(!eventSchema._applyDiscriminators);\n\n    const arraySchema = new mongoose.Schema({ array: [batchSchema] });\n    const arrayModel = db.model('array', arraySchema);\n    const array = await arrayModel.create({\n      array: [{ name: 'Array Test', message: 'Please work', kind: 'event' }]\n    });\n    assert(array.array[0].message);\n\n    const parentSchema = new mongoose.Schema({ sub: batchSchema });\n    const Parent = db.model('Parent', parentSchema);\n    const parent = await Parent.create({\n      sub: { name: 'Sub Test', message: 'I hope I worked!', kind: 'event' }\n    });\n    assert(parent.sub.message);\n\n    const Batch = db.model('Batch', batchSchema);\n    const batch = await Batch.create({\n      name: 'Test Testerson',\n      message: 'Hello World!',\n      kind: 'event'\n    });\n    assert(batch.message);\n  });\n\n  it('can use on as a schema property (gh-11580)', async() => {\n    const testSchema = new mongoose.Schema({\n      on: String\n    });\n    const Test = db.model('gh11580', testSchema);\n    await Test.create({\n      on: 'Test'\n    });\n    const result = await Test.findOne();\n    assert.ok(result);\n    assert.ok(result.on);\n  });\n\n  it('disallows using schemas with schema-level projections with map subdocuments (gh-11698)', async function() {\n    const subSchema = new Schema({\n      selected: { type: Number },\n      not_selected: { type: Number, select: false }\n    });\n\n    assert.throws(() => {\n      new Schema({\n        subdocument_mapping: {\n          type: Map,\n          of: subSchema\n        }\n      });\n    }, /Cannot use schema-level projections.*subdocument_mapping.not_selected/);\n  });\n\n  it('disallows setting special properties with `add()` or constructor (gh-12085)', async function() {\n    const maliciousPayload = '{\"__proto__.toString\": \"Number\"}';\n\n    assert.throws(() => {\n      mongoose.Schema(JSON.parse(maliciousPayload));\n    }, /__proto__/);\n\n    assert.ok({}.toString());\n  });\n});\n"], "filenames": ["lib/schema.js", "test/schema.test.js"], "buggy_code_start_loc": [556, 2794], "buggy_code_end_loc": [856, 2794], "fixing_code_start_loc": [557, 2795], "fixing_code_end_loc": [864, 2805], "type": "CWE-1321", "message": "Prototype Pollution in GitHub repository automattic/mongoose prior to 6.4.6.", "other": {"cve": {"id": "CVE-2022-2564", "sourceIdentifier": "security@huntr.dev", "published": "2022-07-28T20:15:11.187", "lastModified": "2022-10-27T17:10:19.337", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Prototype Pollution in GitHub repository automattic/mongoose prior to 6.4.6."}, {"lang": "es", "value": "Una Contaminaci\u00f3n de Prototipo en el repositorio de GitHub automattic/mongoose versiones anteriores a 6.4.6"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:L/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "HIGH", "baseScore": 7.0, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.2, "impactScore": 4.7}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-1321"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-1321"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mongoosejs:mongoose:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "6.4.6", "matchCriteriaId": "5E1D066A-FC87-4890-B5AE-944876C9DBD5"}]}]}], "references": [{"url": "https://github.com/Automattic/mongoose/blob/51e758541763b6f14569744ced15cc23ab8b50c6/lib/schema.js#L88-L141", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/Automattic/mongoose/compare/6.4.5...6.4.6", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/automattic/mongoose/commit/a45cfb6b0ce0067ae9794cfa80f7917e1fb3c6f8", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/055be524-9296-4b2f-b68d-6d5b810d1ddd", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/automattic/mongoose/commit/a45cfb6b0ce0067ae9794cfa80f7917e1fb3c6f8"}}