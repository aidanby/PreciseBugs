{"buggy_code": ["/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include <errno.h>\n#include <fcntl.h>\n#include <stdbool.h>\n#include <stddef.h>\n#include <unistd.h>\n\n#include \"alloc-util.h\"\n#include \"btrfs-util.h\"\n#include \"cgroup-util.h\"\n#include \"dirent-util.h\"\n#include \"fd-util.h\"\n#include \"log.h\"\n#include \"macro.h\"\n#include \"mountpoint-util.h\"\n#include \"path-util.h\"\n#include \"rm-rf.h\"\n#include \"stat-util.h\"\n#include \"string-util.h\"\n\n/* We treat tmpfs/ramfs + cgroupfs as non-physical file systems. cgroupfs is similar to tmpfs in a way\n * after all: we can create arbitrary directory hierarchies in it, and hence can also use rm_rf() on it\n * to remove those again. */\nstatic bool is_physical_fs(const struct statfs *sfs) {\n        return !is_temporary_fs(sfs) && !is_cgroup_fs(sfs);\n}\n\nstatic int patch_dirfd_mode(\n                int dfd,\n                mode_t *ret_old_mode) {\n\n        struct stat st;\n\n        assert(dfd >= 0);\n        assert(ret_old_mode);\n\n        if (fstat(dfd, &st) < 0)\n                return -errno;\n        if (!S_ISDIR(st.st_mode))\n                return -ENOTDIR;\n        if (FLAGS_SET(st.st_mode, 0700)) /* Already set? */\n                return -EACCES; /* original error */\n        if (st.st_uid != geteuid())  /* this only works if the UID matches ours */\n                return -EACCES;\n\n        if (fchmod(dfd, (st.st_mode | 0700) & 07777) < 0)\n                return -errno;\n\n        *ret_old_mode = st.st_mode;\n        return 0;\n}\n\nint unlinkat_harder(int dfd, const char *filename, int unlink_flags, RemoveFlags remove_flags) {\n\n        mode_t old_mode;\n        int r;\n\n        /* Like unlinkat(), but tries harder: if we get EACCESS we'll try to set the r/w/x bits on the\n         * directory. This is useful if we run unprivileged and have some files where the w bit is\n         * missing. */\n\n        if (unlinkat(dfd, filename, unlink_flags) >= 0)\n                return 0;\n        if (errno != EACCES || !FLAGS_SET(remove_flags, REMOVE_CHMOD))\n                return -errno;\n\n        r = patch_dirfd_mode(dfd, &old_mode);\n        if (r < 0)\n                return r;\n\n        if (unlinkat(dfd, filename, unlink_flags) < 0) {\n                r = -errno;\n                /* Try to restore the original access mode if this didn't work */\n                (void) fchmod(dfd, old_mode);\n                return r;\n        }\n\n        if (FLAGS_SET(remove_flags, REMOVE_CHMOD_RESTORE) && fchmod(dfd, old_mode) < 0)\n                return -errno;\n\n        /* If this worked, we won't reset the old mode by default, since we'll need it for other entries too,\n         * and we should destroy the whole thing */\n        return 0;\n}\n\nint fstatat_harder(int dfd,\n                const char *filename,\n                struct stat *ret,\n                int fstatat_flags,\n                RemoveFlags remove_flags) {\n\n        mode_t old_mode;\n        int r;\n\n        /* Like unlink_harder() but does the same for fstatat() */\n\n        if (fstatat(dfd, filename, ret, fstatat_flags) >= 0)\n                return 0;\n        if (errno != EACCES || !FLAGS_SET(remove_flags, REMOVE_CHMOD))\n                return -errno;\n\n        r = patch_dirfd_mode(dfd, &old_mode);\n        if (r < 0)\n                return r;\n\n        if (fstatat(dfd, filename, ret, fstatat_flags) < 0) {\n                r = -errno;\n                (void) fchmod(dfd, old_mode);\n                return r;\n        }\n\n        if (FLAGS_SET(remove_flags, REMOVE_CHMOD_RESTORE) && fchmod(dfd, old_mode) < 0)\n                return -errno;\n\n        return 0;\n}\n\nstatic int rm_rf_children_inner(\n                int fd,\n                const char *fname,\n                int is_dir,\n                RemoveFlags flags,\n                const struct stat *root_dev) {\n\n        struct stat st;\n        int r, q = 0;\n\n        assert(fd >= 0);\n        assert(fname);\n\n        if (is_dir < 0 ||\n            root_dev ||\n            (is_dir > 0 && (root_dev || (flags & REMOVE_SUBVOLUME)))) {\n\n                r = fstatat_harder(fd, fname, &st, AT_SYMLINK_NOFOLLOW, flags);\n                if (r < 0)\n                        return r;\n\n                is_dir = S_ISDIR(st.st_mode);\n        }\n\n        if (is_dir) {\n                _cleanup_close_ int subdir_fd = -1;\n\n                /* if root_dev is set, remove subdirectories only if device is same */\n                if (root_dev && st.st_dev != root_dev->st_dev)\n                        return 0;\n\n                /* Stop at mount points */\n                r = fd_is_mount_point(fd, fname, 0);\n                if (r < 0)\n                        return r;\n                if (r > 0)\n                        return 0;\n\n                if ((flags & REMOVE_SUBVOLUME) && btrfs_might_be_subvol(&st)) {\n\n                        /* This could be a subvolume, try to remove it */\n\n                        r = btrfs_subvol_remove_fd(fd, fname, BTRFS_REMOVE_RECURSIVE|BTRFS_REMOVE_QUOTA);\n                        if (r < 0) {\n                                if (!IN_SET(r, -ENOTTY, -EINVAL))\n                                        return r;\n\n                                /* ENOTTY, then it wasn't a btrfs subvolume, continue below. */\n                        } else\n                                /* It was a subvolume, done. */\n                                return 1;\n                }\n\n                subdir_fd = openat(fd, fname, O_RDONLY|O_NONBLOCK|O_DIRECTORY|O_CLOEXEC|O_NOFOLLOW|O_NOATIME);\n                if (subdir_fd < 0)\n                        return -errno;\n\n                /* We pass REMOVE_PHYSICAL here, to avoid doing the fstatfs() to check the file system type\n                 * again for each directory */\n                q = rm_rf_children(TAKE_FD(subdir_fd), flags | REMOVE_PHYSICAL, root_dev);\n\n        } else if (flags & REMOVE_ONLY_DIRECTORIES)\n                return 0;\n\n        r = unlinkat_harder(fd, fname, is_dir ? AT_REMOVEDIR : 0, flags);\n        if (r < 0)\n                return r;\n        if (q < 0)\n                return q;\n        return 1;\n}\n\nint rm_rf_children(\n                int fd,\n                RemoveFlags flags,\n                const struct stat *root_dev) {\n\n        _cleanup_closedir_ DIR *d = NULL;\n        int ret = 0, r;\n\n        assert(fd >= 0);\n\n        /* This returns the first error we run into, but nevertheless tries to go on. This closes the passed\n         * fd, in all cases, including on failure. */\n\n        d = fdopendir(fd);\n        if (!d) {\n                safe_close(fd);\n                return -errno;\n        }\n\n        if (!(flags & REMOVE_PHYSICAL)) {\n                struct statfs sfs;\n\n                if (fstatfs(dirfd(d), &sfs) < 0)\n                        return -errno;\n\n                if (is_physical_fs(&sfs)) {\n                        /* We refuse to clean physical file systems with this call, unless explicitly\n                         * requested. This is extra paranoia just to be sure we never ever remove non-state\n                         * data. */\n\n                        _cleanup_free_ char *path = NULL;\n\n                        (void) fd_get_path(fd, &path);\n                        return log_error_errno(SYNTHETIC_ERRNO(EPERM),\n                                               \"Attempted to remove disk file system under \\\"%s\\\", and we can't allow that.\",\n                                               strna(path));\n                }\n        }\n\n        FOREACH_DIRENT_ALL(de, d, return -errno) {\n                int is_dir;\n\n                if (dot_or_dot_dot(de->d_name))\n                        continue;\n\n                is_dir =\n                        de->d_type == DT_UNKNOWN ? -1 :\n                        de->d_type == DT_DIR;\n\n                r = rm_rf_children_inner(dirfd(d), de->d_name, is_dir, flags, root_dev);\n                if (r < 0 && r != -ENOENT && ret == 0)\n                        ret = r;\n        }\n\n        if (FLAGS_SET(flags, REMOVE_SYNCFS) && syncfs(dirfd(d)) < 0 && ret >= 0)\n                ret = -errno;\n\n        return ret;\n}\n\nint rm_rf(const char *path, RemoveFlags flags) {\n        int fd, r, q = 0;\n\n        assert(path);\n\n        /* For now, don't support dropping subvols when also only dropping directories, since we can't do\n         * this race-freely. */\n        if (FLAGS_SET(flags, REMOVE_ONLY_DIRECTORIES|REMOVE_SUBVOLUME))\n                return -EINVAL;\n\n        /* We refuse to clean the root file system with this call. This is extra paranoia to never cause a\n         * really seriously broken system. */\n        if (path_equal_or_files_same(path, \"/\", AT_SYMLINK_NOFOLLOW))\n                return log_error_errno(SYNTHETIC_ERRNO(EPERM),\n                                       \"Attempted to remove entire root file system (\\\"%s\\\"), and we can't allow that.\",\n                                       path);\n\n        if (FLAGS_SET(flags, REMOVE_SUBVOLUME | REMOVE_ROOT | REMOVE_PHYSICAL)) {\n                /* Try to remove as subvolume first */\n                r = btrfs_subvol_remove(path, BTRFS_REMOVE_RECURSIVE|BTRFS_REMOVE_QUOTA);\n                if (r >= 0)\n                        return r;\n\n                if (FLAGS_SET(flags, REMOVE_MISSING_OK) && r == -ENOENT)\n                        return 0;\n\n                if (!IN_SET(r, -ENOTTY, -EINVAL, -ENOTDIR))\n                        return r;\n\n                /* Not btrfs or not a subvolume */\n        }\n\n        fd = open(path, O_RDONLY|O_NONBLOCK|O_DIRECTORY|O_CLOEXEC|O_NOFOLLOW|O_NOATIME);\n        if (fd >= 0) {\n                /* We have a dir */\n                r = rm_rf_children(fd, flags, NULL);\n\n                if (FLAGS_SET(flags, REMOVE_ROOT))\n                        q = RET_NERRNO(rmdir(path));\n        } else {\n                if (FLAGS_SET(flags, REMOVE_MISSING_OK) && errno == ENOENT)\n                        return 0;\n\n                if (!IN_SET(errno, ENOTDIR, ELOOP))\n                        return -errno;\n\n                if (FLAGS_SET(flags, REMOVE_ONLY_DIRECTORIES) || !FLAGS_SET(flags, REMOVE_ROOT))\n                        return 0;\n\n                if (!FLAGS_SET(flags, REMOVE_PHYSICAL)) {\n                        struct statfs s;\n\n                        if (statfs(path, &s) < 0)\n                                return -errno;\n                        if (is_physical_fs(&s))\n                                return log_error_errno(SYNTHETIC_ERRNO(EPERM),\n                                                       \"Attempted to remove files from a disk file system under \\\"%s\\\", refusing.\",\n                                                       path);\n                }\n\n                r = 0;\n                q = RET_NERRNO(unlink(path));\n        }\n\n        if (r < 0)\n                return r;\n        if (q < 0 && (q != -ENOENT || !FLAGS_SET(flags, REMOVE_MISSING_OK)))\n                return q;\n        return 0;\n}\n\nint rm_rf_child(int fd, const char *name, RemoveFlags flags) {\n\n        /* Removes one specific child of the specified directory */\n\n        if (fd < 0)\n                return -EBADF;\n\n        if (!filename_is_valid(name))\n                return -EINVAL;\n\n        if ((flags & (REMOVE_ROOT|REMOVE_MISSING_OK)) != 0) /* Doesn't really make sense here, we are not supposed to remove 'fd' anyway */\n                return -EINVAL;\n\n        if (FLAGS_SET(flags, REMOVE_ONLY_DIRECTORIES|REMOVE_SUBVOLUME))\n                return -EINVAL;\n\n        return rm_rf_children_inner(fd, name, -1, flags, NULL);\n}\n"], "fixing_code": ["/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include <errno.h>\n#include <fcntl.h>\n#include <stdbool.h>\n#include <stddef.h>\n#include <unistd.h>\n\n#include \"alloc-util.h\"\n#include \"btrfs-util.h\"\n#include \"cgroup-util.h\"\n#include \"dirent-util.h\"\n#include \"fd-util.h\"\n#include \"log.h\"\n#include \"macro.h\"\n#include \"mountpoint-util.h\"\n#include \"path-util.h\"\n#include \"rm-rf.h\"\n#include \"stat-util.h\"\n#include \"string-util.h\"\n\n/* We treat tmpfs/ramfs + cgroupfs as non-physical file systems. cgroupfs is similar to tmpfs in a way\n * after all: we can create arbitrary directory hierarchies in it, and hence can also use rm_rf() on it\n * to remove those again. */\nstatic bool is_physical_fs(const struct statfs *sfs) {\n        return !is_temporary_fs(sfs) && !is_cgroup_fs(sfs);\n}\n\nstatic int patch_dirfd_mode(\n                int dfd,\n                mode_t *ret_old_mode) {\n\n        struct stat st;\n\n        assert(dfd >= 0);\n        assert(ret_old_mode);\n\n        if (fstat(dfd, &st) < 0)\n                return -errno;\n        if (!S_ISDIR(st.st_mode))\n                return -ENOTDIR;\n        if (FLAGS_SET(st.st_mode, 0700)) /* Already set? */\n                return -EACCES; /* original error */\n        if (st.st_uid != geteuid())  /* this only works if the UID matches ours */\n                return -EACCES;\n\n        if (fchmod(dfd, (st.st_mode | 0700) & 07777) < 0)\n                return -errno;\n\n        *ret_old_mode = st.st_mode;\n        return 0;\n}\n\nint unlinkat_harder(int dfd, const char *filename, int unlink_flags, RemoveFlags remove_flags) {\n        mode_t old_mode;\n        int r;\n\n        /* Like unlinkat(), but tries harder: if we get EACCESS we'll try to set the r/w/x bits on the\n         * directory. This is useful if we run unprivileged and have some files where the w bit is\n         * missing. */\n\n        if (unlinkat(dfd, filename, unlink_flags) >= 0)\n                return 0;\n        if (errno != EACCES || !FLAGS_SET(remove_flags, REMOVE_CHMOD))\n                return -errno;\n\n        r = patch_dirfd_mode(dfd, &old_mode);\n        if (r < 0)\n                return r;\n\n        if (unlinkat(dfd, filename, unlink_flags) < 0) {\n                r = -errno;\n                /* Try to restore the original access mode if this didn't work */\n                (void) fchmod(dfd, old_mode);\n                return r;\n        }\n\n        if (FLAGS_SET(remove_flags, REMOVE_CHMOD_RESTORE) && fchmod(dfd, old_mode) < 0)\n                return -errno;\n\n        /* If this worked, we won't reset the old mode by default, since we'll need it for other entries too,\n         * and we should destroy the whole thing */\n        return 0;\n}\n\nint fstatat_harder(int dfd,\n                const char *filename,\n                struct stat *ret,\n                int fstatat_flags,\n                RemoveFlags remove_flags) {\n\n        mode_t old_mode;\n        int r;\n\n        /* Like unlink_harder() but does the same for fstatat() */\n\n        if (fstatat(dfd, filename, ret, fstatat_flags) >= 0)\n                return 0;\n        if (errno != EACCES || !FLAGS_SET(remove_flags, REMOVE_CHMOD))\n                return -errno;\n\n        r = patch_dirfd_mode(dfd, &old_mode);\n        if (r < 0)\n                return r;\n\n        if (fstatat(dfd, filename, ret, fstatat_flags) < 0) {\n                r = -errno;\n                (void) fchmod(dfd, old_mode);\n                return r;\n        }\n\n        if (FLAGS_SET(remove_flags, REMOVE_CHMOD_RESTORE) && fchmod(dfd, old_mode) < 0)\n                return -errno;\n\n        return 0;\n}\n\nstatic int rm_rf_inner_child(\n                int fd,\n                const char *fname,\n                int is_dir,\n                RemoveFlags flags,\n                const struct stat *root_dev,\n                bool allow_recursion) {\n\n        struct stat st;\n        int r, q = 0;\n\n        assert(fd >= 0);\n        assert(fname);\n\n        if (is_dir < 0 ||\n            root_dev ||\n            (is_dir > 0 && (root_dev || (flags & REMOVE_SUBVOLUME)))) {\n\n                r = fstatat_harder(fd, fname, &st, AT_SYMLINK_NOFOLLOW, flags);\n                if (r < 0)\n                        return r;\n\n                is_dir = S_ISDIR(st.st_mode);\n        }\n\n        if (is_dir) {\n                /* If root_dev is set, remove subdirectories only if device is same */\n                if (root_dev && st.st_dev != root_dev->st_dev)\n                        return 0;\n\n                /* Stop at mount points */\n                r = fd_is_mount_point(fd, fname, 0);\n                if (r < 0)\n                        return r;\n                if (r > 0)\n                        return 0;\n\n                if ((flags & REMOVE_SUBVOLUME) && btrfs_might_be_subvol(&st)) {\n                        /* This could be a subvolume, try to remove it */\n\n                        r = btrfs_subvol_remove_fd(fd, fname, BTRFS_REMOVE_RECURSIVE|BTRFS_REMOVE_QUOTA);\n                        if (r < 0) {\n                                if (!IN_SET(r, -ENOTTY, -EINVAL))\n                                        return r;\n\n                                /* ENOTTY, then it wasn't a btrfs subvolume, continue below. */\n                        } else\n                                /* It was a subvolume, done. */\n                                return 1;\n                }\n\n                if (!allow_recursion)\n                        return -EISDIR;\n\n                int subdir_fd = openat(fd, fname, O_RDONLY|O_NONBLOCK|O_DIRECTORY|O_CLOEXEC|O_NOFOLLOW|O_NOATIME);\n                if (subdir_fd < 0)\n                        return -errno;\n\n                /* We pass REMOVE_PHYSICAL here, to avoid doing the fstatfs() to check the file system type\n                 * again for each directory */\n                q = rm_rf_children(subdir_fd, flags | REMOVE_PHYSICAL, root_dev);\n\n        } else if (flags & REMOVE_ONLY_DIRECTORIES)\n                return 0;\n\n        r = unlinkat_harder(fd, fname, is_dir ? AT_REMOVEDIR : 0, flags);\n        if (r < 0)\n                return r;\n        if (q < 0)\n                return q;\n        return 1;\n}\n\ntypedef struct TodoEntry {\n        DIR *dir;         /* A directory that we were operating on. */\n        char *dirname;    /* The filename of that directory itself. */\n} TodoEntry;\n\nstatic void free_todo_entries(TodoEntry **todos) {\n        for (TodoEntry *x = *todos; x && x->dir; x++) {\n                closedir(x->dir);\n                free(x->dirname);\n        }\n\n        freep(todos);\n}\n\nint rm_rf_children(\n                int fd,\n                RemoveFlags flags,\n                const struct stat *root_dev) {\n\n        _cleanup_(free_todo_entries) TodoEntry *todos = NULL;\n        size_t n_todo = 0;\n        _cleanup_free_ char *dirname = NULL; /* Set when we are recursing and want to delete ourselves */\n        int ret = 0, r;\n\n        /* Return the first error we run into, but nevertheless try to go on.\n         * The passed fd is closed in all cases, including on failure. */\n\n        for (;;) {  /* This loop corresponds to the directory nesting level. */\n                _cleanup_closedir_ DIR *d = NULL;\n\n                if (n_todo > 0) {\n                        /* We know that we are in recursion here, because n_todo is set.\n                         * We need to remove the inner directory we were operating on. */\n                        assert(dirname);\n                        r = unlinkat_harder(dirfd(todos[n_todo-1].dir), dirname, AT_REMOVEDIR, flags);\n                        if (r < 0 && r != -ENOENT && ret == 0)\n                                ret = r;\n                        dirname = mfree(dirname);\n\n                        /* And now let's back out one level up */\n                        n_todo --;\n                        d = TAKE_PTR(todos[n_todo].dir);\n                        dirname = TAKE_PTR(todos[n_todo].dirname);\n\n                        assert(d);\n                        fd = dirfd(d); /* Retrieve the file descriptor from the DIR object */\n                        assert(fd >= 0);\n                } else {\n        next_fd:\n                        assert(fd >= 0);\n                        d = fdopendir(fd);\n                        if (!d) {\n                                safe_close(fd);\n                                return -errno;\n                        }\n                        fd = dirfd(d); /* We donated the fd to fdopendir(). Let's make sure we sure we have\n                                        * the right descriptor even if it were to internally invalidate the\n                                        * one we passed. */\n\n                        if (!(flags & REMOVE_PHYSICAL)) {\n                                struct statfs sfs;\n\n                                if (fstatfs(fd, &sfs) < 0)\n                                        return -errno;\n\n                                if (is_physical_fs(&sfs)) {\n                                        /* We refuse to clean physical file systems with this call, unless\n                                         * explicitly requested. This is extra paranoia just to be sure we\n                                         * never ever remove non-state data. */\n\n                                        _cleanup_free_ char *path = NULL;\n\n                                        (void) fd_get_path(fd, &path);\n                                        return log_error_errno(SYNTHETIC_ERRNO(EPERM),\n                                                               \"Attempted to remove disk file system under \\\"%s\\\", and we can't allow that.\",\n                                                               strna(path));\n                                }\n                        }\n                }\n\n                FOREACH_DIRENT_ALL(de, d, return -errno) {\n                        int is_dir;\n\n                        if (dot_or_dot_dot(de->d_name))\n                                continue;\n\n                        is_dir = de->d_type == DT_UNKNOWN ? -1 : de->d_type == DT_DIR;\n\n                        r = rm_rf_inner_child(fd, de->d_name, is_dir, flags, root_dev, false);\n                        if (r == -EISDIR) {\n                                /* Push the current working state onto the todo list */\n\n                                 if (!GREEDY_REALLOC0(todos, n_todo + 2))\n                                         return log_oom();\n\n                                 _cleanup_free_ char *newdirname = strdup(de->d_name);\n                                 if (!newdirname)\n                                         return log_oom();\n\n                                 int newfd = openat(fd, de->d_name,\n                                                    O_RDONLY|O_NONBLOCK|O_DIRECTORY|O_CLOEXEC|O_NOFOLLOW|O_NOATIME);\n                                 if (newfd >= 0) {\n                                         todos[n_todo++] = (TodoEntry) { TAKE_PTR(d), TAKE_PTR(dirname) };\n                                         fd = newfd;\n                                         dirname = TAKE_PTR(newdirname);\n\n                                         goto next_fd;\n\n                                 } else if (errno != -ENOENT && ret == 0)\n                                         ret = -errno;\n\n                        } else if (r < 0 && r != -ENOENT && ret == 0)\n                                ret = r;\n                }\n\n                if (FLAGS_SET(flags, REMOVE_SYNCFS) && syncfs(fd) < 0 && ret >= 0)\n                        ret = -errno;\n\n                if (n_todo == 0)\n                        break;\n        }\n\n        return ret;\n}\n\nint rm_rf(const char *path, RemoveFlags flags) {\n        int fd, r, q = 0;\n\n        assert(path);\n\n        /* For now, don't support dropping subvols when also only dropping directories, since we can't do\n         * this race-freely. */\n        if (FLAGS_SET(flags, REMOVE_ONLY_DIRECTORIES|REMOVE_SUBVOLUME))\n                return -EINVAL;\n\n        /* We refuse to clean the root file system with this call. This is extra paranoia to never cause a\n         * really seriously broken system. */\n        if (path_equal_or_files_same(path, \"/\", AT_SYMLINK_NOFOLLOW))\n                return log_error_errno(SYNTHETIC_ERRNO(EPERM),\n                                       \"Attempted to remove entire root file system (\\\"%s\\\"), and we can't allow that.\",\n                                       path);\n\n        if (FLAGS_SET(flags, REMOVE_SUBVOLUME | REMOVE_ROOT | REMOVE_PHYSICAL)) {\n                /* Try to remove as subvolume first */\n                r = btrfs_subvol_remove(path, BTRFS_REMOVE_RECURSIVE|BTRFS_REMOVE_QUOTA);\n                if (r >= 0)\n                        return r;\n\n                if (FLAGS_SET(flags, REMOVE_MISSING_OK) && r == -ENOENT)\n                        return 0;\n\n                if (!IN_SET(r, -ENOTTY, -EINVAL, -ENOTDIR))\n                        return r;\n\n                /* Not btrfs or not a subvolume */\n        }\n\n        fd = open(path, O_RDONLY|O_NONBLOCK|O_DIRECTORY|O_CLOEXEC|O_NOFOLLOW|O_NOATIME);\n        if (fd >= 0) {\n                /* We have a dir */\n                r = rm_rf_children(fd, flags, NULL);\n\n                if (FLAGS_SET(flags, REMOVE_ROOT))\n                        q = RET_NERRNO(rmdir(path));\n        } else {\n                if (FLAGS_SET(flags, REMOVE_MISSING_OK) && errno == ENOENT)\n                        return 0;\n\n                if (!IN_SET(errno, ENOTDIR, ELOOP))\n                        return -errno;\n\n                if (FLAGS_SET(flags, REMOVE_ONLY_DIRECTORIES) || !FLAGS_SET(flags, REMOVE_ROOT))\n                        return 0;\n\n                if (!FLAGS_SET(flags, REMOVE_PHYSICAL)) {\n                        struct statfs s;\n\n                        if (statfs(path, &s) < 0)\n                                return -errno;\n                        if (is_physical_fs(&s))\n                                return log_error_errno(SYNTHETIC_ERRNO(EPERM),\n                                                       \"Attempted to remove files from a disk file system under \\\"%s\\\", refusing.\",\n                                                       path);\n                }\n\n                r = 0;\n                q = RET_NERRNO(unlink(path));\n        }\n\n        if (r < 0)\n                return r;\n        if (q < 0 && (q != -ENOENT || !FLAGS_SET(flags, REMOVE_MISSING_OK)))\n                return q;\n        return 0;\n}\n\nint rm_rf_child(int fd, const char *name, RemoveFlags flags) {\n\n        /* Removes one specific child of the specified directory */\n\n        if (fd < 0)\n                return -EBADF;\n\n        if (!filename_is_valid(name))\n                return -EINVAL;\n\n        if ((flags & (REMOVE_ROOT|REMOVE_MISSING_OK)) != 0) /* Doesn't really make sense here, we are not supposed to remove 'fd' anyway */\n                return -EINVAL;\n\n        if (FLAGS_SET(flags, REMOVE_ONLY_DIRECTORIES|REMOVE_SUBVOLUME))\n                return -EINVAL;\n\n        return rm_rf_inner_child(fd, name, -1, flags, NULL, true);\n}\n"], "filenames": ["src/shared/rm-rf.c"], "buggy_code_start_loc": [55], "buggy_code_end_loc": [340], "fixing_code_start_loc": [54], "fixing_code_end_loc": [405], "type": "CWE-674", "message": "A flaw was found in systemd. An uncontrolled recursion in systemd-tmpfiles may lead to a denial of service at boot time when too many nested directories are created in /tmp.", "other": {"cve": {"id": "CVE-2021-3997", "sourceIdentifier": "secalert@redhat.com", "published": "2022-08-23T20:15:08.670", "lastModified": "2023-05-03T12:15:15.950", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "A flaw was found in systemd. An uncontrolled recursion in systemd-tmpfiles may lead to a denial of service at boot time when too many nested directories are created in /tmp."}, {"lang": "es", "value": "Se ha encontrado un fallo en systemd. Una recursi\u00f3n no controlada en systemd-tmpfiles puede conllevar a una denegaci\u00f3n de servicio en el momento del arranque cuando son creados demasiados directorios anidados en /tmp."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-674"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-674"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:systemd_project:systemd:*:*:*:*:*:*:*:*", "versionStartIncluding": "240", "versionEndExcluding": "250.2", "matchCriteriaId": "0D5DB179-3322-4645-BF16-007AE6A8378D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "142AD0DD-4CF3-4D74-9442-459CE3347E3A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "F4CFF558-3C47-480D-A2F0-BABF26042943"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "7F6FB57C-2BC7-487C-96DD-132683AEB35D"}]}]}], "references": [{"url": "https://access.redhat.com/security/cve/CVE-2021-3997", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=2024639", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/systemd/systemd/commit/5b1cf7a9be37e20133c0208005274ce4a5b5c6a1", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202305-15", "source": "secalert@redhat.com"}, {"url": "https://www.openwall.com/lists/oss-security/2022/01/10/2", "source": "secalert@redhat.com", "tags": ["Exploit", "Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/systemd/systemd/commit/5b1cf7a9be37e20133c0208005274ce4a5b5c6a1"}}