{"buggy_code": ["\"\"\"Tornado handlers for logging into the Jupyter Server.\"\"\"\n# Copyright (c) Jupyter Development Team.\n# Distributed under the terms of the Modified BSD License.\nimport os\nimport re\nimport uuid\nfrom urllib.parse import urlparse\n\nfrom tornado.escape import url_escape\n\nfrom ..base.handlers import JupyterHandler\nfrom .security import passwd_check, set_password\n\n\nclass LoginFormHandler(JupyterHandler):\n    \"\"\"The basic tornado login handler\n\n    accepts login form, passed to IdentityProvider.process_login_form.\n    \"\"\"\n\n    def _render(self, message=None):\n        \"\"\"Render the login form.\"\"\"\n        self.write(\n            self.render_template(\n                \"login.html\",\n                next=url_escape(self.get_argument(\"next\", default=self.base_url)),\n                message=message,\n            )\n        )\n\n    def _redirect_safe(self, url, default=None):\n        \"\"\"Redirect if url is on our PATH\n\n        Full-domain redirects are allowed if they pass our CORS origin checks.\n\n        Otherwise use default (self.base_url if unspecified).\n        \"\"\"\n        if default is None:\n            default = self.base_url\n        # protect chrome users from mishandling unescaped backslashes.\n        # \\ is not valid in urls, but some browsers treat it as /\n        # instead of %5C, causing `\\\\` to behave as `//`\n        url = url.replace(\"\\\\\", \"%5C\")\n        parsed = urlparse(url)\n        if parsed.netloc or not (parsed.path + \"/\").startswith(self.base_url):\n            # require that next_url be absolute path within our path\n            allow = False\n            # OR pass our cross-origin check\n            if parsed.netloc:\n                # if full URL, run our cross-origin check:\n                origin = f\"{parsed.scheme}://{parsed.netloc}\"\n                origin = origin.lower()\n                if self.allow_origin:\n                    allow = self.allow_origin == origin\n                elif self.allow_origin_pat:\n                    allow = bool(re.match(self.allow_origin_pat, origin))\n            if not allow:\n                # not allowed, use default\n                self.log.warning(\"Not allowing login redirect to %r\" % url)\n                url = default\n        self.redirect(url)\n\n    def get(self):\n        \"\"\"Get the login form.\"\"\"\n        if self.current_user:\n            next_url = self.get_argument(\"next\", default=self.base_url)\n            self._redirect_safe(next_url)\n        else:\n            self._render()\n\n    def post(self):\n        \"\"\"Post a login.\"\"\"\n        user = self.current_user = self.identity_provider.process_login_form(self)\n        if user is None:\n            self.set_status(401)\n            self._render(message={\"error\": \"Invalid credentials\"})\n            return\n\n        self.log.info(f\"User {user.username} logged in.\")\n        self.identity_provider.set_login_cookie(self, user)\n        next_url = self.get_argument(\"next\", default=self.base_url)\n        self._redirect_safe(next_url)\n\n\nclass LegacyLoginHandler(LoginFormHandler):\n    \"\"\"Legacy LoginHandler, implementing most custom auth configuration.\n\n    Deprecated in jupyter-server 2.0.\n    Login configuration has moved to IdentityProvider.\n    \"\"\"\n\n    @property\n    def hashed_password(self):\n        return self.password_from_settings(self.settings)\n\n    def passwd_check(self, a, b):\n        \"\"\"Check a passwd.\"\"\"\n        return passwd_check(a, b)\n\n    def post(self):\n        \"\"\"Post a login form.\"\"\"\n        typed_password = self.get_argument(\"password\", default=\"\")\n        new_password = self.get_argument(\"new_password\", default=\"\")\n\n        if self.get_login_available(self.settings):\n            if self.passwd_check(self.hashed_password, typed_password) and not new_password:\n                self.set_login_cookie(self, uuid.uuid4().hex)\n            elif self.token and self.token == typed_password:\n                self.set_login_cookie(self, uuid.uuid4().hex)\n                if new_password and getattr(self.identity_provider, \"allow_password_change\", False):\n                    config_dir = self.settings.get(\"config_dir\", \"\")\n                    config_file = os.path.join(config_dir, \"jupyter_server_config.json\")\n                    self.identity_provider.hashed_password = self.settings[\n                        \"password\"\n                    ] = set_password(new_password, config_file=config_file)\n                    self.log.info(\"Wrote hashed password to %s\" % config_file)\n            else:\n                self.set_status(401)\n                self._render(message={\"error\": \"Invalid credentials\"})\n                return\n\n        next_url = self.get_argument(\"next\", default=self.base_url)\n        self._redirect_safe(next_url)\n\n    @classmethod\n    def set_login_cookie(cls, handler, user_id=None):\n        \"\"\"Call this on handlers to set the login cookie for success\"\"\"\n        cookie_options = handler.settings.get(\"cookie_options\", {})\n        cookie_options.setdefault(\"httponly\", True)\n        # tornado <4.2 has a bug that considers secure==True as soon as\n        # 'secure' kwarg is passed to set_secure_cookie\n        if handler.settings.get(\"secure_cookie\", handler.request.protocol == \"https\"):\n            cookie_options.setdefault(\"secure\", True)\n        cookie_options.setdefault(\"path\", handler.base_url)\n        handler.set_secure_cookie(handler.cookie_name, user_id, **cookie_options)\n        return user_id\n\n    auth_header_pat = re.compile(r\"token\\s+(.+)\", re.IGNORECASE)\n\n    @classmethod\n    def get_token(cls, handler):\n        \"\"\"Get the user token from a request\n\n        Default:\n\n        - in URL parameters: ?token=<token>\n        - in header: Authorization: token <token>\n        \"\"\"\n\n        user_token = handler.get_argument(\"token\", \"\")\n        if not user_token:\n            # get it from Authorization header\n            m = cls.auth_header_pat.match(handler.request.headers.get(\"Authorization\", \"\"))\n            if m:\n                user_token = m.group(1)\n        return user_token\n\n    @classmethod\n    def should_check_origin(cls, handler):\n        \"\"\"DEPRECATED in 2.0, use IdentityProvider API\"\"\"\n        return not cls.is_token_authenticated(handler)\n\n    @classmethod\n    def is_token_authenticated(cls, handler):\n        \"\"\"DEPRECATED in 2.0, use IdentityProvider API\"\"\"\n        if getattr(handler, \"_user_id\", None) is None:\n            # ensure get_user has been called, so we know if we're token-authenticated\n            handler.current_user  # noqa\n        return getattr(handler, \"_token_authenticated\", False)\n\n    @classmethod\n    def get_user(cls, handler):\n        \"\"\"DEPRECATED in 2.0, use IdentityProvider API\"\"\"\n        # Can't call this get_current_user because it will collide when\n        # called on LoginHandler itself.\n        if getattr(handler, \"_user_id\", None):\n            return handler._user_id\n        token_user_id = cls.get_user_token(handler)\n        cookie_user_id = cls.get_user_cookie(handler)\n        # prefer token to cookie if both given,\n        # because token is always explicit\n        user_id = token_user_id or cookie_user_id\n        if token_user_id:\n            # if token-authenticated, persist user_id in cookie\n            # if it hasn't already been stored there\n            if user_id != cookie_user_id:\n                cls.set_login_cookie(handler, user_id)\n            # Record that the current request has been authenticated with a token.\n            # Used in is_token_authenticated above.\n            handler._token_authenticated = True\n\n        if user_id is None:\n            # If an invalid cookie was sent, clear it to prevent unnecessary\n            # extra warnings. But don't do this on a request with *no* cookie,\n            # because that can erroneously log you out (see gh-3365)\n            if handler.get_cookie(handler.cookie_name) is not None:\n                handler.log.warning(\"Clearing invalid/expired login cookie %s\", handler.cookie_name)\n                handler.clear_login_cookie()\n            if not handler.login_available:\n                # Completely insecure! No authentication at all.\n                # No need to warn here, though; validate_security will have already done that.\n                user_id = \"anonymous\"\n\n        # cache value for future retrievals on the same request\n        handler._user_id = user_id\n        return user_id\n\n    @classmethod\n    def get_user_cookie(cls, handler):\n        \"\"\"DEPRECATED in 2.0, use IdentityProvider API\"\"\"\n        get_secure_cookie_kwargs = handler.settings.get(\"get_secure_cookie_kwargs\", {})\n        user_id = handler.get_secure_cookie(handler.cookie_name, **get_secure_cookie_kwargs)\n        if user_id:\n            user_id = user_id.decode()\n        return user_id\n\n    @classmethod\n    def get_user_token(cls, handler):\n        \"\"\"DEPRECATED in 2.0, use IdentityProvider API\"\"\"\n        token = handler.token\n        if not token:\n            return\n        # check login token from URL argument or Authorization header\n        user_token = cls.get_token(handler)\n        authenticated = False\n        if user_token == token:\n            # token-authenticated, set the login cookie\n            handler.log.debug(\n                \"Accepting token-authenticated connection from %s\",\n                handler.request.remote_ip,\n            )\n            authenticated = True\n\n        if authenticated:\n            # token does not correspond to user-id,\n            # which is stored in a cookie.\n            # still check the cookie for the user id\n            user_id = cls.get_user_cookie(handler)\n            if user_id is None:\n                # no cookie, generate new random user_id\n                user_id = uuid.uuid4().hex\n                handler.log.info(\n                    f\"Generating new user_id for token-authenticated request: {user_id}\"\n                )\n            return user_id\n        else:\n            return None\n\n    @classmethod\n    def validate_security(cls, app, ssl_options=None):\n        \"\"\"DEPRECATED in 2.0, use IdentityProvider API\"\"\"\n        if not app.ip:\n            warning = \"WARNING: The Jupyter server is listening on all IP addresses\"\n            if ssl_options is None:\n                app.log.warning(f\"{warning} and not using encryption. This is not recommended.\")\n            if not app.password and not app.token:\n                app.log.warning(\n                    f\"{warning} and not using authentication. \"\n                    \"This is highly insecure and not recommended.\"\n                )\n        elif not app.password and not app.token:\n            app.log.warning(\n                \"All authentication is disabled.\"\n                \"  Anyone who can connect to this server will be able to run code.\"\n            )\n\n    @classmethod\n    def password_from_settings(cls, settings):\n        \"\"\"DEPRECATED in 2.0, use IdentityProvider API\"\"\"\n        return settings.get(\"password\", \"\")\n\n    @classmethod\n    def get_login_available(cls, settings):\n        \"\"\"DEPRECATED in 2.0, use IdentityProvider API\"\"\"\n\n        return bool(cls.password_from_settings(settings) or settings.get(\"token\"))\n\n\n# deprecated import, so deprecated implementations get the Legacy class instead\nLoginHandler = LegacyLoginHandler\n", "\"\"\"Tests for login redirects\"\"\"\nimport json\nfrom functools import partial\nfrom urllib.parse import urlencode\n\nimport pytest\nfrom tornado.httpclient import HTTPClientError\nfrom tornado.httputil import parse_cookie, url_concat\n\nfrom jupyter_server.utils import url_path_join\n\n\n# override default config to ensure a non-empty base url is used\n@pytest.fixture\ndef jp_base_url():\n    return \"/a%40b/\"\n\n\n@pytest.fixture\ndef jp_server_config(jp_base_url):\n    return {\n        \"ServerApp\": {\n            \"base_url\": jp_base_url,\n        },\n    }\n\n\nasync def _login(\n    jp_serverapp,\n    http_server_client,\n    jp_base_url,\n    login_headers,\n    next=\"/\",\n    password=None,\n    new_password=None,\n):\n    # first: request login page with no creds\n    login_url = url_path_join(jp_base_url, \"login\")\n    first = await http_server_client.fetch(login_url)\n    cookie_header = first.headers[\"Set-Cookie\"]\n    cookies = parse_cookie(cookie_header)\n    form = {\"_xsrf\": cookies.get(\"_xsrf\")}\n    if password is None:\n        password = jp_serverapp.identity_provider.token\n    if password:\n        form[\"password\"] = password\n    if new_password:\n        form[\"new_password\"] = new_password\n\n    # second, submit login form with credentials\n    try:\n        resp = await http_server_client.fetch(\n            url_concat(login_url, {\"next\": next}),\n            method=\"POST\",\n            body=urlencode(form),\n            headers={\"Cookie\": cookie_header},\n            follow_redirects=False,\n        )\n    except HTTPClientError as e:\n        if e.code != 302:\n            raise\n        assert e.response is not None\n        resp = e.response\n    else:\n        assert resp.code == 302, \"Should have returned a redirect!\"\n    return resp\n\n\n@pytest.fixture\ndef login_headers():\n    \"\"\"Extra headers to pass to login\n\n    Fixture so it can be overridden\n    \"\"\"\n    return {}\n\n\n@pytest.fixture\ndef login(jp_serverapp, http_server_client, jp_base_url, login_headers):\n    \"\"\"Fixture to return a function to login to a Jupyter server\n\n    by submitting the login page form\n    \"\"\"\n    yield partial(_login, jp_serverapp, http_server_client, jp_base_url, login_headers)\n\n\n@pytest.mark.parametrize(\n    \"bad_next\",\n    (\n        r\"\\\\tree\",\n        \"//some-host\",\n        \"//host{base_url}tree\",\n        \"https://google.com\",\n        \"/absolute/not/base_url\",\n    ),\n)\nasync def test_next_bad(login, jp_base_url, bad_next):\n    bad_next = bad_next.format(base_url=jp_base_url)\n    resp = await login(bad_next)\n    url = resp.headers[\"Location\"]\n    assert url == jp_base_url\n\n\n@pytest.mark.parametrize(\n    \"next_path\",\n    (\n        \"tree/\",\n        \"//{base_url}tree\",\n        \"notebooks/notebook.ipynb\",\n        \"tree//something\",\n    ),\n)\nasync def test_next_ok(login, jp_base_url, next_path):\n    next_path = next_path.format(base_url=jp_base_url)\n    expected = jp_base_url + next_path\n    resp = await login(next=expected)\n    actual = resp.headers[\"Location\"]\n    assert actual == expected\n\n\nasync def test_login_cookie(login, jp_serverapp, jp_fetch, login_headers):\n    resp = await login()\n    assert \"Set-Cookie\" in resp.headers\n    cookie = resp.headers[\"Set-Cookie\"]\n    headers = {\"Cookie\": cookie}\n    headers.update(login_headers)\n    id_resp = await jp_fetch(\"/api/me\", headers=headers)\n    assert id_resp.code == 200\n    model = json.loads(id_resp.body.decode(\"utf8\"))\n    assert model[\"identity\"][\"username\"]\n    with pytest.raises(HTTPClientError) as exc:\n        resp = await login(password=\"incorrect\")\n    assert exc.value.code == 401\n\n\n@pytest.mark.parametrize(\"allow_password_change\", [True, False])\nasync def test_change_password(login, jp_serverapp, jp_base_url, jp_fetch, allow_password_change):\n    new_password = \"super-new-pass\"\n    jp_serverapp.identity_provider.allow_password_change = allow_password_change\n    resp = await login(new_password=new_password)\n\n    # second request\n    if allow_password_change:\n        resp = await login(password=new_password)\n        assert resp.code == 302\n    else:\n        with pytest.raises(HTTPClientError) as exc_info:\n            resp = await login(password=new_password)\n        assert exc_info.value.code == 401\n\n\nasync def test_logout(jp_serverapp, login, http_server_client, jp_base_url):\n    jp_serverapp.identity_provider.cookie_name = \"test-cookie\"\n    expected = jp_base_url\n    resp = await login(next=jp_base_url)\n    cookie_header = resp.headers[\"Set-Cookie\"]\n    cookies = parse_cookie(cookie_header)\n    assert cookies.get(\"test-cookie\")\n\n    resp = await http_server_client.fetch(jp_base_url + \"logout\", headers={\"Cookie\": cookie_header})\n    assert resp.code == 200\n    cookie_header = resp.headers[\"Set-Cookie\"]\n    cookies = parse_cookie(cookie_header)\n    assert not cookies.get(\"test-cookie\")\n    assert \"Successfully logged out\" in resp.body.decode(\"utf8\")\n\n\nasync def test_token_cookie_user_id(jp_serverapp, jp_fetch):\n    token = jp_serverapp.identity_provider.token\n\n    # first request with token, sets cookie with user-id\n    resp = await jp_fetch(\"/\")\n    assert resp.code == 200\n    set_cookie = resp.headers[\"set-cookie\"]\n    headers = {\"Cookie\": set_cookie}\n\n    # subsequent requests with cookie and no token\n    # receive same user-id\n    resp = await jp_fetch(\"/api/me\", headers=headers)\n    user_id = json.loads(resp.body.decode(\"utf8\"))\n    resp = await jp_fetch(\"/api/me\", headers=headers)\n    user_id2 = json.loads(resp.body.decode(\"utf8\"))\n    assert user_id[\"identity\"] == user_id2[\"identity\"]\n\n    # new request, just token -> new user_id\n    resp = await jp_fetch(\"/api/me\")\n    user_id3 = json.loads(resp.body.decode(\"utf8\"))\n    assert user_id[\"identity\"] != user_id3[\"identity\"]\n"], "fixing_code": ["\"\"\"Tornado handlers for logging into the Jupyter Server.\"\"\"\n# Copyright (c) Jupyter Development Team.\n# Distributed under the terms of the Modified BSD License.\nimport os\nimport re\nimport uuid\nfrom urllib.parse import urlparse\n\nfrom tornado.escape import url_escape\n\nfrom ..base.handlers import JupyterHandler\nfrom .security import passwd_check, set_password\n\n\nclass LoginFormHandler(JupyterHandler):\n    \"\"\"The basic tornado login handler\n\n    accepts login form, passed to IdentityProvider.process_login_form.\n    \"\"\"\n\n    def _render(self, message=None):\n        \"\"\"Render the login form.\"\"\"\n        self.write(\n            self.render_template(\n                \"login.html\",\n                next=url_escape(self.get_argument(\"next\", default=self.base_url)),\n                message=message,\n            )\n        )\n\n    def _redirect_safe(self, url, default=None):\n        \"\"\"Redirect if url is on our PATH\n\n        Full-domain redirects are allowed if they pass our CORS origin checks.\n\n        Otherwise use default (self.base_url if unspecified).\n        \"\"\"\n        if default is None:\n            default = self.base_url\n        # protect chrome users from mishandling unescaped backslashes.\n        # \\ is not valid in urls, but some browsers treat it as /\n        # instead of %5C, causing `\\\\` to behave as `//`\n        url = url.replace(\"\\\\\", \"%5C\")\n        # urllib and browsers interpret extra '/' in the scheme separator (`scheme:///host/path`)\n        # differently.\n        # urllib gives scheme=scheme, netloc='', path='/host/path', while\n        # browsers get scheme=scheme, netloc='host', path='/path'\n        # so make sure ':///*' collapses to '://' by splitting and stripping any additional leading slash\n        # don't allow any kind of `:/` shenanigans by splitting on ':' only\n        # and replacing `:/*` with exactly `://`\n        if \":\" in url:\n            scheme, _, rest = url.partition(\":\")\n            url = f\"{scheme}://{rest.lstrip('/')}\"\n        parsed = urlparse(url)\n        # full url may be `//host/path` (empty scheme == same scheme as request)\n        # or `https://host/path`\n        # or even `https:///host/path` (invalid, but accepted and ambiguously interpreted)\n        if (parsed.scheme or parsed.netloc) or not (parsed.path + \"/\").startswith(self.base_url):\n            # require that next_url be absolute path within our path\n            allow = False\n            # OR pass our cross-origin check\n            if parsed.scheme or parsed.netloc:\n                # if full URL, run our cross-origin check:\n                origin = f\"{parsed.scheme}://{parsed.netloc}\"\n                origin = origin.lower()\n                if self.allow_origin:\n                    allow = self.allow_origin == origin\n                elif self.allow_origin_pat:\n                    allow = bool(re.match(self.allow_origin_pat, origin))\n            if not allow:\n                # not allowed, use default\n                self.log.warning(\"Not allowing login redirect to %r\" % url)\n                url = default\n        self.redirect(url)\n\n    def get(self):\n        \"\"\"Get the login form.\"\"\"\n        if self.current_user:\n            next_url = self.get_argument(\"next\", default=self.base_url)\n            self._redirect_safe(next_url)\n        else:\n            self._render()\n\n    def post(self):\n        \"\"\"Post a login.\"\"\"\n        user = self.current_user = self.identity_provider.process_login_form(self)\n        if user is None:\n            self.set_status(401)\n            self._render(message={\"error\": \"Invalid credentials\"})\n            return\n\n        self.log.info(f\"User {user.username} logged in.\")\n        self.identity_provider.set_login_cookie(self, user)\n        next_url = self.get_argument(\"next\", default=self.base_url)\n        self._redirect_safe(next_url)\n\n\nclass LegacyLoginHandler(LoginFormHandler):\n    \"\"\"Legacy LoginHandler, implementing most custom auth configuration.\n\n    Deprecated in jupyter-server 2.0.\n    Login configuration has moved to IdentityProvider.\n    \"\"\"\n\n    @property\n    def hashed_password(self):\n        return self.password_from_settings(self.settings)\n\n    def passwd_check(self, a, b):\n        \"\"\"Check a passwd.\"\"\"\n        return passwd_check(a, b)\n\n    def post(self):\n        \"\"\"Post a login form.\"\"\"\n        typed_password = self.get_argument(\"password\", default=\"\")\n        new_password = self.get_argument(\"new_password\", default=\"\")\n\n        if self.get_login_available(self.settings):\n            if self.passwd_check(self.hashed_password, typed_password) and not new_password:\n                self.set_login_cookie(self, uuid.uuid4().hex)\n            elif self.token and self.token == typed_password:\n                self.set_login_cookie(self, uuid.uuid4().hex)\n                if new_password and getattr(self.identity_provider, \"allow_password_change\", False):\n                    config_dir = self.settings.get(\"config_dir\", \"\")\n                    config_file = os.path.join(config_dir, \"jupyter_server_config.json\")\n                    self.identity_provider.hashed_password = self.settings[\n                        \"password\"\n                    ] = set_password(new_password, config_file=config_file)\n                    self.log.info(\"Wrote hashed password to %s\" % config_file)\n            else:\n                self.set_status(401)\n                self._render(message={\"error\": \"Invalid credentials\"})\n                return\n\n        next_url = self.get_argument(\"next\", default=self.base_url)\n        self._redirect_safe(next_url)\n\n    @classmethod\n    def set_login_cookie(cls, handler, user_id=None):\n        \"\"\"Call this on handlers to set the login cookie for success\"\"\"\n        cookie_options = handler.settings.get(\"cookie_options\", {})\n        cookie_options.setdefault(\"httponly\", True)\n        # tornado <4.2 has a bug that considers secure==True as soon as\n        # 'secure' kwarg is passed to set_secure_cookie\n        if handler.settings.get(\"secure_cookie\", handler.request.protocol == \"https\"):\n            cookie_options.setdefault(\"secure\", True)\n        cookie_options.setdefault(\"path\", handler.base_url)\n        handler.set_secure_cookie(handler.cookie_name, user_id, **cookie_options)\n        return user_id\n\n    auth_header_pat = re.compile(r\"token\\s+(.+)\", re.IGNORECASE)\n\n    @classmethod\n    def get_token(cls, handler):\n        \"\"\"Get the user token from a request\n\n        Default:\n\n        - in URL parameters: ?token=<token>\n        - in header: Authorization: token <token>\n        \"\"\"\n\n        user_token = handler.get_argument(\"token\", \"\")\n        if not user_token:\n            # get it from Authorization header\n            m = cls.auth_header_pat.match(handler.request.headers.get(\"Authorization\", \"\"))\n            if m:\n                user_token = m.group(1)\n        return user_token\n\n    @classmethod\n    def should_check_origin(cls, handler):\n        \"\"\"DEPRECATED in 2.0, use IdentityProvider API\"\"\"\n        return not cls.is_token_authenticated(handler)\n\n    @classmethod\n    def is_token_authenticated(cls, handler):\n        \"\"\"DEPRECATED in 2.0, use IdentityProvider API\"\"\"\n        if getattr(handler, \"_user_id\", None) is None:\n            # ensure get_user has been called, so we know if we're token-authenticated\n            handler.current_user  # noqa\n        return getattr(handler, \"_token_authenticated\", False)\n\n    @classmethod\n    def get_user(cls, handler):\n        \"\"\"DEPRECATED in 2.0, use IdentityProvider API\"\"\"\n        # Can't call this get_current_user because it will collide when\n        # called on LoginHandler itself.\n        if getattr(handler, \"_user_id\", None):\n            return handler._user_id\n        token_user_id = cls.get_user_token(handler)\n        cookie_user_id = cls.get_user_cookie(handler)\n        # prefer token to cookie if both given,\n        # because token is always explicit\n        user_id = token_user_id or cookie_user_id\n        if token_user_id:\n            # if token-authenticated, persist user_id in cookie\n            # if it hasn't already been stored there\n            if user_id != cookie_user_id:\n                cls.set_login_cookie(handler, user_id)\n            # Record that the current request has been authenticated with a token.\n            # Used in is_token_authenticated above.\n            handler._token_authenticated = True\n\n        if user_id is None:\n            # If an invalid cookie was sent, clear it to prevent unnecessary\n            # extra warnings. But don't do this on a request with *no* cookie,\n            # because that can erroneously log you out (see gh-3365)\n            if handler.get_cookie(handler.cookie_name) is not None:\n                handler.log.warning(\"Clearing invalid/expired login cookie %s\", handler.cookie_name)\n                handler.clear_login_cookie()\n            if not handler.login_available:\n                # Completely insecure! No authentication at all.\n                # No need to warn here, though; validate_security will have already done that.\n                user_id = \"anonymous\"\n\n        # cache value for future retrievals on the same request\n        handler._user_id = user_id\n        return user_id\n\n    @classmethod\n    def get_user_cookie(cls, handler):\n        \"\"\"DEPRECATED in 2.0, use IdentityProvider API\"\"\"\n        get_secure_cookie_kwargs = handler.settings.get(\"get_secure_cookie_kwargs\", {})\n        user_id = handler.get_secure_cookie(handler.cookie_name, **get_secure_cookie_kwargs)\n        if user_id:\n            user_id = user_id.decode()\n        return user_id\n\n    @classmethod\n    def get_user_token(cls, handler):\n        \"\"\"DEPRECATED in 2.0, use IdentityProvider API\"\"\"\n        token = handler.token\n        if not token:\n            return\n        # check login token from URL argument or Authorization header\n        user_token = cls.get_token(handler)\n        authenticated = False\n        if user_token == token:\n            # token-authenticated, set the login cookie\n            handler.log.debug(\n                \"Accepting token-authenticated connection from %s\",\n                handler.request.remote_ip,\n            )\n            authenticated = True\n\n        if authenticated:\n            # token does not correspond to user-id,\n            # which is stored in a cookie.\n            # still check the cookie for the user id\n            user_id = cls.get_user_cookie(handler)\n            if user_id is None:\n                # no cookie, generate new random user_id\n                user_id = uuid.uuid4().hex\n                handler.log.info(\n                    f\"Generating new user_id for token-authenticated request: {user_id}\"\n                )\n            return user_id\n        else:\n            return None\n\n    @classmethod\n    def validate_security(cls, app, ssl_options=None):\n        \"\"\"DEPRECATED in 2.0, use IdentityProvider API\"\"\"\n        if not app.ip:\n            warning = \"WARNING: The Jupyter server is listening on all IP addresses\"\n            if ssl_options is None:\n                app.log.warning(f\"{warning} and not using encryption. This is not recommended.\")\n            if not app.password and not app.token:\n                app.log.warning(\n                    f\"{warning} and not using authentication. \"\n                    \"This is highly insecure and not recommended.\"\n                )\n        elif not app.password and not app.token:\n            app.log.warning(\n                \"All authentication is disabled.\"\n                \"  Anyone who can connect to this server will be able to run code.\"\n            )\n\n    @classmethod\n    def password_from_settings(cls, settings):\n        \"\"\"DEPRECATED in 2.0, use IdentityProvider API\"\"\"\n        return settings.get(\"password\", \"\")\n\n    @classmethod\n    def get_login_available(cls, settings):\n        \"\"\"DEPRECATED in 2.0, use IdentityProvider API\"\"\"\n\n        return bool(cls.password_from_settings(settings) or settings.get(\"token\"))\n\n\n# deprecated import, so deprecated implementations get the Legacy class instead\nLoginHandler = LegacyLoginHandler\n", "\"\"\"Tests for login redirects\"\"\"\nimport json\nfrom functools import partial\nfrom urllib.parse import urlencode\n\nimport pytest\nfrom tornado.httpclient import HTTPClientError\nfrom tornado.httputil import parse_cookie, url_concat\n\nfrom jupyter_server.utils import url_path_join\n\n\n# override default config to ensure a non-empty base url is used\n@pytest.fixture\ndef jp_base_url():\n    return \"/a%40b/\"\n\n\n@pytest.fixture\ndef jp_server_config(jp_base_url):\n    return {\n        \"ServerApp\": {\n            \"base_url\": jp_base_url,\n        },\n    }\n\n\nasync def _login(\n    jp_serverapp,\n    http_server_client,\n    jp_base_url,\n    login_headers,\n    next=\"/\",\n    password=None,\n    new_password=None,\n):\n    # first: request login page with no creds\n    login_url = url_path_join(jp_base_url, \"login\")\n    first = await http_server_client.fetch(login_url)\n    cookie_header = first.headers[\"Set-Cookie\"]\n    cookies = parse_cookie(cookie_header)\n    form = {\"_xsrf\": cookies.get(\"_xsrf\")}\n    if password is None:\n        password = jp_serverapp.identity_provider.token\n    if password:\n        form[\"password\"] = password\n    if new_password:\n        form[\"new_password\"] = new_password\n\n    # second, submit login form with credentials\n    try:\n        resp = await http_server_client.fetch(\n            url_concat(login_url, {\"next\": next}),\n            method=\"POST\",\n            body=urlencode(form),\n            headers={\"Cookie\": cookie_header},\n            follow_redirects=False,\n        )\n    except HTTPClientError as e:\n        if e.code != 302:\n            raise\n        assert e.response is not None\n        resp = e.response\n    else:\n        assert resp.code == 302, \"Should have returned a redirect!\"\n    return resp\n\n\n@pytest.fixture\ndef login_headers():\n    \"\"\"Extra headers to pass to login\n\n    Fixture so it can be overridden\n    \"\"\"\n    return {}\n\n\n@pytest.fixture\ndef login(jp_serverapp, http_server_client, jp_base_url, login_headers):\n    \"\"\"Fixture to return a function to login to a Jupyter server\n\n    by submitting the login page form\n    \"\"\"\n    yield partial(_login, jp_serverapp, http_server_client, jp_base_url, login_headers)\n\n\n@pytest.mark.parametrize(\n    \"bad_next\",\n    (\n        r\"\\\\tree\",\n        \"//some-host\",\n        \"//host{base_url}tree\",\n        \"https://google.com\",\n        \"/absolute/not/base_url\",\n        \"https:///a%40b/extra/slash\",\n    ),\n)\nasync def test_next_bad(login, jp_base_url, bad_next):\n    bad_next = bad_next.format(base_url=jp_base_url)\n    resp = await login(bad_next)\n    url = resp.headers[\"Location\"]\n    assert url == jp_base_url\n\n\n@pytest.mark.parametrize(\n    \"next_path\",\n    (\n        \"tree/\",\n        \"//{base_url}tree\",\n        \"notebooks/notebook.ipynb\",\n        \"tree//something\",\n    ),\n)\nasync def test_next_ok(login, jp_base_url, next_path):\n    next_path = next_path.format(base_url=jp_base_url)\n    expected = jp_base_url + next_path\n    resp = await login(next=expected)\n    actual = resp.headers[\"Location\"]\n    assert actual == expected\n\n\nasync def test_login_cookie(login, jp_serverapp, jp_fetch, login_headers):\n    resp = await login()\n    assert \"Set-Cookie\" in resp.headers\n    cookie = resp.headers[\"Set-Cookie\"]\n    headers = {\"Cookie\": cookie}\n    headers.update(login_headers)\n    id_resp = await jp_fetch(\"/api/me\", headers=headers)\n    assert id_resp.code == 200\n    model = json.loads(id_resp.body.decode(\"utf8\"))\n    assert model[\"identity\"][\"username\"]\n    with pytest.raises(HTTPClientError) as exc:\n        resp = await login(password=\"incorrect\")\n    assert exc.value.code == 401\n\n\n@pytest.mark.parametrize(\"allow_password_change\", [True, False])\nasync def test_change_password(login, jp_serverapp, jp_base_url, jp_fetch, allow_password_change):\n    new_password = \"super-new-pass\"\n    jp_serverapp.identity_provider.allow_password_change = allow_password_change\n    resp = await login(new_password=new_password)\n\n    # second request\n    if allow_password_change:\n        resp = await login(password=new_password)\n        assert resp.code == 302\n    else:\n        with pytest.raises(HTTPClientError) as exc_info:\n            resp = await login(password=new_password)\n        assert exc_info.value.code == 401\n\n\nasync def test_logout(jp_serverapp, login, http_server_client, jp_base_url):\n    jp_serverapp.identity_provider.cookie_name = \"test-cookie\"\n    expected = jp_base_url\n    resp = await login(next=jp_base_url)\n    cookie_header = resp.headers[\"Set-Cookie\"]\n    cookies = parse_cookie(cookie_header)\n    assert cookies.get(\"test-cookie\")\n\n    resp = await http_server_client.fetch(jp_base_url + \"logout\", headers={\"Cookie\": cookie_header})\n    assert resp.code == 200\n    cookie_header = resp.headers[\"Set-Cookie\"]\n    cookies = parse_cookie(cookie_header)\n    assert not cookies.get(\"test-cookie\")\n    assert \"Successfully logged out\" in resp.body.decode(\"utf8\")\n\n\nasync def test_token_cookie_user_id(jp_serverapp, jp_fetch):\n    token = jp_serverapp.identity_provider.token\n\n    # first request with token, sets cookie with user-id\n    resp = await jp_fetch(\"/\")\n    assert resp.code == 200\n    set_cookie = resp.headers[\"set-cookie\"]\n    headers = {\"Cookie\": set_cookie}\n\n    # subsequent requests with cookie and no token\n    # receive same user-id\n    resp = await jp_fetch(\"/api/me\", headers=headers)\n    user_id = json.loads(resp.body.decode(\"utf8\"))\n    resp = await jp_fetch(\"/api/me\", headers=headers)\n    user_id2 = json.loads(resp.body.decode(\"utf8\"))\n    assert user_id[\"identity\"] == user_id2[\"identity\"]\n\n    # new request, just token -> new user_id\n    resp = await jp_fetch(\"/api/me\")\n    user_id3 = json.loads(resp.body.decode(\"utf8\"))\n    assert user_id[\"identity\"] != user_id3[\"identity\"]\n"], "filenames": ["jupyter_server/auth/login.py", "tests/auth/test_login.py"], "buggy_code_start_loc": [43, 94], "buggy_code_end_loc": [50, 94], "fixing_code_start_loc": [44, 95], "fixing_code_end_loc": [63, 96], "type": "CWE-601", "message": "jupyter-server is the backend for Jupyter web applications. Open Redirect Vulnerability. Maliciously crafted login links to known Jupyter Servers can cause successful login or an already logged-in session to be redirected to arbitrary sites, which should be restricted to Jupyter Server-served URLs. This issue has been addressed in commit `29036259` which is included in release 2.7.2. Users are advised to upgrade. There are no known workarounds for this vulnerability.", "other": {"cve": {"id": "CVE-2023-39968", "sourceIdentifier": "security-advisories@github.com", "published": "2023-08-28T21:15:07.777", "lastModified": "2023-09-15T22:15:14.217", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "jupyter-server is the backend for Jupyter web applications. Open Redirect Vulnerability. Maliciously crafted login links to known Jupyter Servers can cause successful login or an already logged-in session to be redirected to arbitrary sites, which should be restricted to Jupyter Server-served URLs. This issue has been addressed in commit `29036259` which is included in release 2.7.2. Users are advised to upgrade. There are no known workarounds for this vulnerability."}, {"lang": "es", "value": "jupyter-server es el backend de las aplicaciones web de Jupyter. Vulnerabilidad de Redireccionamiento Abierto. Los enlaces de inicio de sesi\u00f3n creados maliciosamente a servidores Jupyter conocidos pueden provocar que un inicio de sesi\u00f3n exitoso o una sesi\u00f3n ya iniciada sea redirigida a sitios arbitrarios, que deben restringirse a las URL servidas por Jupyter Server. Este problema se solucion\u00f3 en el commit \"29036259\", que se incluye en la versi\u00f3n 2.7.2. Se recomienda a los usuarios que actualicen. No se conocen workarounds para esta vulnerabilidad."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-601"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:jupyter:jupyter_server:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.7.2", "matchCriteriaId": "B83A20E2-B301-47B0-AE30-3363B1FE64F3"}]}]}], "references": [{"url": "https://github.com/jupyter-server/jupyter_server/commit/290362593b2ffb23c59f8114d76f77875de4b925", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/jupyter-server/jupyter_server/security/advisories/GHSA-r726-vmfq-j9j3", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/NRP7DNZYVOIA4ZB3U3ZWKTFZEPYWNGCQ/", "source": "security-advisories@github.com"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/XDKQAWQN6SQTOVACZNXYKEHWQXGG4DOF/", "source": "security-advisories@github.com"}]}, "github_commit_url": "https://github.com/jupyter-server/jupyter_server/commit/290362593b2ffb23c59f8114d76f77875de4b925"}}