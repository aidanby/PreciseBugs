{"buggy_code": ["/*\r\nqpress - portable high-speed file archiver\r\nCopyright Lasse Reinhold 2006-2010\r\nGPL 1, 2 and 3 licensed.\r\n\r\nAn archive file consists of \"D\" and \"U\" characters which instruct the decompressor to traverse up and down in\r\ndirectories to create a directory three. The \"F\" character instructs it to create a file:\r\n\r\nARCHIVE =        ARCHIVEHEADER + (1 or more of UPDIR | DOWNDIR | FILE)\r\nARCHIVEHEADER =  \"qpress10\" + (ui64)(chunk size of decompressed packets)\r\nDOWNDIR =        \"D\" + (ui32)(size of directory name) + (directory name) + (char)0\r\nUPDIR =          \"U\"\r\nFILE =           FILEHEADER + (0 or more of DATABLOCK) + FILETRAILER\r\nFILEHEADER =     \"F\" + (ui32)(size of file name) + (file name) + (char)0\r\nDATABLOCK =      \"NEWBNEWB\" + (ui64)(recovery information) + (ui32)(adler32 of compressed block) + (compressed packet)\r\nFILETRAILER =    \"ENDSENDS\" + (ui64)(recovery information)\r\n\r\nThe values (ui32) and (ui64) are stored in little endian format. Example of compressing following directory structure:\r\n\r\nFOO             directory\r\n\tc.txt       file containing \"hello\"\r\n\tBAR         empty directory\r\nd.txt           file containing \"there\"\r\n\r\nTwo digit values are in hexadecimal, remaining values are printable and represented by their character:\r\n\r\n          0   1   2   3   4   5   6   7   8   9   a   b   c   d   e   f\r\n000000    q   p   r   e   s   s   1   0  00  00  01  00  00  00  00  00\r\n000010    F  05  00  00  00   c   .   t   x   t  00   N   E   W   B   N\r\n000020    E   W   B  00  00  00  00  00  00  00  00  eb  02   %  0d   E\r\n000030   0c  05  00  00  00  80   h   e   l   l   o   E   N   D   S   E\r\n000040    N   D   S  00  00  00  00  00  00  00  00   D  03  00  00  00\r\n000050    F   O   O  00   D  03  00  00  00   B   A   R  00   F  05  00\r\n000060   00  00   d   .   t   x   t  00   N   E   W   B   N   E   W   B\r\n000070   00  00  00  00  00  00  00  00  ef  02   Z  0d   E  0c  05  00\r\n000080   00  00  80   t   h   e   r   e   E   N   D   S   E   N   D   S\r\n000090   00  00  00  00  00  00  00  00   U   U\r\n\r\nOffsets 2f - 3a and 7c - 87 are compressed packets. You see \"hello\" and \"there\" in plaintext because input is too small\r\nto compress.\r\n\r\nWhen decompressing, decompress_directory() takes the user given destination path as argument and begins extracting\r\nfiles into it. When a DOWNDIR is read it appends its sub directory to the path. When an UPDIR is read it removes the\r\ndeepest sub directory from the path. When a FILE is read, it calls decompress_file() which starts threads that each, in\r\na loop, reads a chunk, decompresses and writes to destination file:\r\n\r\ndecompress_directory() --> decompress_file() --> decompress_file_thread()\r\n                                             +-> decompress_file_thread()\r\n                                             +-> decompress_file_thread()\r\n\r\nWhen compressing, compress_directory() searches for files in the path given as argument. For each file found, it calls\r\ncompress_file(). When a directory is found, it appends it to the path, outputs a DOWNDIR, calls itself with the new path\r\nand finally outputs an UPDIR:\r\n\r\n+-> compress_directory() +-> compress_file() --> compress_file_thread()\r\n|                        |                   +-> compress_file_thread()\r\n+------------------------+                   +-> compress_file_thread()\r\n\r\n*/\r\n\r\n// Larger chunk size gives better compression ratio. However, on Windows Vista, 64 KiB or smaller\r\n// improves parallel disk I/O when data is both read and written.\r\n#define DEFAULT_COMPRESS_CHUNK_SIZE (64*1024)\r\n\r\n// Data compressed with a specific chunk size requires 2 * (chunk size) * (thread count) memory to\r\n// decompress (32 MiB requires 128 MiB with the default 2 threads), so we should limit it for\r\n// archives to be able to decompress on systems with little memory\r\n#define MAX_COMPRESS_CHUNK_SIZE (32*1024*1024)\r\n\r\n// Can be increased to any value - we just need this constant for some static arrays\r\n#define MAX_THREAD_COUNT 256\r\n\r\n// Too many threads can decrease throughput because of overheads and can also starve other processes\r\n#define DEFAULT_THREAD_COUNT 2\r\n#define DEFAULT_COMPRESSION_LEVEL 1\r\n\r\n#define BLANK_LINE \"\\r                                                          \\r\"\r\n\r\n// How much qlz_compress() can expand input data with (some incompressible data may grow in size). This\r\n// is 400 bytes regardless of input size, even for gigabyte range.\r\n#define QLZ_SIZE_OVERHEAD 400\r\n\r\n// Benchmark with -m flag uses 18.2 timer and must be executed in a loop for a large BENCHMARK_MILLISECONDS\r\n// to be accurate. To avoid interruptions and disturbions from OS and other applications, do it BENCHMARK_BESTOF\r\n// times and pick the best.\r\n#define BENCHMARK_MILLISECONDS 3000\r\n#define BENCHMARK_BESTOF 3\r\n\r\n#include <sys/stat.h>\r\n#include <stdlib.h>\r\n#include <stdio.h>\r\n#include \"aio.hpp\"\r\n#include <stdarg.h>\r\n#include <string>\r\n#include \"levels.c\"\r\n#include \"utilities.hpp\"\r\n\r\n#if defined(__APPLE__) || defined(__linux__)\r\n    #include <unistd.h>\r\n#endif\r\n\r\nusing namespace std;\r\n\r\n#ifdef WINDOWS\r\n  #include <fcntl.h>\r\n  #include <time.h>\r\n  #include <windows.h>\r\n  #include <io.h>\r\n  #include \"dirent_win.h\"\r\n  #include \"pthread.h\"\r\n#else\r\n  #include \"dirent.h\"\r\n  #include <pthread.h>\r\n#endif\r\n\r\n#if QLZ_STREAMING_BUFFER != 0\r\n#error QLZ_STREAMING_BUFFER must be 0\r\n#endif\r\n\r\n#ifdef WINDOWS\r\n\t#define CURDIR \".\\\\\"\r\n    #define DELIM_STR \"\\\\\"\r\n    #define DELIM_CHAR '\\\\'\r\n    #define LONGLONG \"%I64d\"\r\n\t#ifndef PROCESS_MODE_BACKGROUND_BEGIN\r\n\t    #define PROCESS_MODE_BACKGROUND_BEGIN   0x00100000\r\n    #endif\r\n#else\r\n\t#define CURDIR \"./\"\r\n    #define DELIM_STR \"/\"\r\n    #define DELIM_CHAR '/'\r\n    #define LONGLONG \"%lld\"\r\n#endif\r\n\r\ntypedef struct\r\n{\r\n    string path;\r\n    string pattern;\r\n} search_type;\r\n\r\n// command line flags\r\nbool continue_flag = false;\r\nbool cache_flag = true;\r\nbool force_flag = false;\r\nbool recursive_flag = false;\r\nbool decompress_flag = false;\r\nbool recover_flag = false;\r\nbool benchmark_flag = false;\r\nunsigned long long compress_chunk_size = DEFAULT_COMPRESS_CHUNK_SIZE;\r\nunsigned int compression_level = DEFAULT_COMPRESSION_LEVEL;\r\nunsigned int threads = DEFAULT_THREAD_COUNT;\r\nbool verbose_flag = false;\r\nbool flags_exist = false;\r\nbool tty_stderr;\r\nbool input_pipe;\r\nbool output_pipe;\r\n\r\n// QuickLZ compression, decompression and scratch buffers\r\nchar *src[MAX_THREAD_COUNT];\r\nchar *dst[MAX_THREAD_COUNT];\r\nchar *scratch[MAX_THREAD_COUNT];\r\n\r\n// statistics to show to user\r\nunsigned int files = 0;\r\nunsigned long long payload_counter = 0;\r\n\r\n// threaded disk i/o scheduling\r\npthread_mutex_t disk_read_mutex = PTHREAD_MUTEX_INITIALIZER;\r\npthread_mutex_t disk_write_mutex = PTHREAD_MUTEX_INITIALIZER;\r\npthread_mutex_t disk_order_mutex = PTHREAD_MUTEX_INITIALIZER;\r\npthread_cond_t disk_order_cond;\r\nunsigned long long chunks_read;\r\nunsigned long long chunks_written;\r\nbool end_of_file;\r\n\r\n// destination file during compression\r\nstring destination_file;\r\n\r\n// hack to pass file length to threads during benchmark\r\nunsigned long long bench_size;\r\n\r\n// various\r\nunsigned long long recovery_file_written;\r\nunsigned long long recovery_bad_bytes = 0;\r\nunsigned long long current_file_payload;\r\nchar tmp[200000];\r\n\r\nenum {FATAL_ERROR, COUNTER_UPDATE, FILES_PROCESSED, RESULT, WARNING};\r\n\r\nvoid PRINT(int MESSAGE_TYPE, const char *fmt, ...)\r\n{\r\n    va_list arg;\r\n    va_start(arg, fmt);\r\n\r\n    if(MESSAGE_TYPE == FATAL_ERROR)\r\n    {\r\n        vfprintf(stderr, fmt, arg);\r\n    }\r\n    else if(MESSAGE_TYPE == COUNTER_UPDATE)\r\n    {\r\n        // && tty_stderr to avoid flooding log files with 'xx MiB/s' lines\r\n        if(verbose_flag && tty_stderr)\r\n            vfprintf(stderr, fmt, arg);\r\n    }\r\n    else if(MESSAGE_TYPE == FILES_PROCESSED)\r\n    {\r\n        if(verbose_flag)\r\n            vfprintf(stderr, fmt, arg);\r\n    }\r\n    else if(MESSAGE_TYPE == RESULT)\r\n    {\r\n        if(verbose_flag)\r\n\t        vfprintf(stderr, fmt, arg);\r\n    }\r\n    else if(MESSAGE_TYPE == WARNING)\r\n    {\r\n        vfprintf(stderr, fmt, arg);\r\n    }\r\n    va_end(arg);\r\n}\r\n\r\nvoid abort(const char *fmt, ...)\r\n{\r\n    va_list arg;\r\n    va_start(arg, fmt);\r\n    PRINT(FATAL_ERROR, \"\\r%s\\r%s: \", BLANK_LINE, \"qpress\");\r\n    vfprintf(stderr, fmt, arg); // todo: use PRINT instead, when found out how to pass fmt\r\n    va_end(arg);\r\n    PRINT(FATAL_ERROR, \"\\n\");\r\n    adelete_write();\r\n    exit(-1);\r\n}\r\n\r\n\r\nint int_flag(string arg, string flag)\r\n{\r\n    int r;\r\n    size_t s0 = arg.find_first_of(flag);\r\n    if (s0 != string::npos)\r\n    {\r\n        string s1 = arg.substr(s0);\r\n        r = atoi(s1.substr(1, s1.find_first_not_of(\"0123456789\", 1) - 1).c_str());\r\n        if(r == 0)\r\n            abort(\"Invalid value for -%s flag\", flag.c_str());\r\n        else\r\n            return r;\r\n    }\r\n    return -1;\r\n}\r\n\r\nvoid parse_flags(int argc, char* argv[])\r\n{\r\n    string *arg = new string[argc];\r\n\r\n    for(int i = 0; i < argc; i++)\r\n        arg[i] = argv[i];\r\n\r\n    if(argc > 1 && arg[1].substr(0, 1) == \"-\")\r\n    {\r\n        size_t o = 0;\r\n\r\n        flags_exist = true;\r\n        size_t e = arg[1].find_first_not_of(\"-iodrvcmRfKCBPLT0123456789\");\r\n        if(e != string::npos)\r\n            abort(\"Unknown flag -%s\", arg[1].substr(e, 1).c_str());\r\n\r\n        // abort if argument matches [^LPTK][1-9] (but for source/compilation simplicity we don't include a regex lib)\r\n        do\r\n        {\r\n            string c = \"-\";\r\n            o = arg[1].find_first_of(\"0123456789\", o + 1);\r\n            if(o != string::npos)\r\n                c = arg[1].substr(o - 1, 1);\r\n            if(c != \"-\" && c != \"L\" && c != \"P\" && c != \"T\" && c != \"K\" && (c < \"0\" || c > \"9\"))\r\n                abort(\"Numeric values must be preceded by L, P, T or K\");\r\n        } while (o != string::npos);\r\n\r\n        decompress_flag = arg[1].find_first_of(\"d\") != string::npos ? true : false;\r\n        recursive_flag = arg[1].find_first_of(\"r\") != string::npos ? true : false;\r\n        verbose_flag = arg[1].find_first_of(\"v\") != string::npos ? true : false;\r\n        output_pipe = arg[1].find_first_of(\"o\") != string::npos ? true : false;\r\n        benchmark_flag = arg[1].find_first_of(\"m\") != string::npos ? true : false;\r\n        recover_flag = arg[1].find_first_of(\"R\") != string::npos ? true : false;\r\n        force_flag = arg[1].find_first_of(\"f\") != string::npos ? true : false;\r\n        continue_flag = arg[1].find_first_of(\"C\") != string::npos ? true : false;\r\n        cache_flag = arg[1].find_first_of(\"B\") != string::npos ? false : true;\r\n        input_pipe = arg[1].find_first_of(\"i\") != string::npos ? true : false;\r\n        output_pipe = arg[1].find_first_of(\"o\") != string::npos ? true : false;\r\n\r\n#ifdef WINDOWS\r\n        if(int_flag(arg[1], \"P\") != -1)\r\n        {\r\n            switch(int_flag(arg[1], \"P\"))\r\n            {\r\n                case 1:\r\n\t\t\t\t\tif (!SetPriorityClass(GetCurrentProcess(), PROCESS_MODE_BACKGROUND_BEGIN))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tPRINT(WARNING, \"%s%s: -P1 not supported by this OS - using -P2 instead\\n\", BLANK_LINE, \"qpress\");\r\n\t\t\t\t\t\tSetPriorityClass(GetCurrentProcess(), IDLE_PRIORITY_CLASS);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n                case 2: SetPriorityClass(GetCurrentProcess(), IDLE_PRIORITY_CLASS); break;\r\n                case 3: SetPriorityClass(GetCurrentProcess(), NORMAL_PRIORITY_CLASS); break;\r\n                case 4: SetPriorityClass(GetCurrentProcess(), ABOVE_NORMAL_PRIORITY_CLASS); break;\r\n                default: abort(\"Invalid -P flag value\");\r\n            }\r\n        }\r\n\r\n#endif\r\n        if(int_flag(arg[1], \"L\") != -1)\r\n        {\r\n            if (int_flag(arg[1], \"L\") > 0 && int_flag(arg[1], \"L\") < 4)\r\n                if(decompress_flag || recover_flag)\r\n                    abort(\"-d or -R flag cannot be used with -L flag\");\r\n                else\r\n                    compression_level = int_flag(arg[1], \"L\");\r\n            else\r\n                abort(\"Invalid -L flag value\");\r\n        }\r\n\r\n        if(int_flag(arg[1], \"T\") != -1)\r\n        {\r\n            if (int_flag(arg[1], \"T\") >= 1 && int_flag(arg[1], \"T\") <= MAX_THREAD_COUNT)\r\n                    threads = int_flag(arg[1], \"T\");\r\n            else\r\n                abort(\"Invalid -T flag value\");\r\n        }\r\n\r\n        if(int_flag(arg[1], \"K\") != -1)\r\n        {\r\n            if (1024*int_flag(arg[1], \"K\") >= AIO_MAX_SECTOR_SIZE && 1024*int_flag(arg[1], \"K\") <= MAX_COMPRESS_CHUNK_SIZE)\r\n                if(decompress_flag || benchmark_flag || recover_flag )\r\n                    abort(\"-d, -m or -R flag cannot be used with -K flag\");\r\n                else\r\n                    compress_chunk_size = (1024*int_flag(arg[1], \"K\"));\r\n            else\r\n                abort(\"Invalid -K flag value\");\r\n        }\r\n    }\r\n\r\n    if((decompress_flag && (recursive_flag || benchmark_flag || recover_flag || continue_flag)) ||\r\n       (benchmark_flag && (recursive_flag || verbose_flag || output_pipe || recover_flag || continue_flag)) ||\r\n       (recover_flag && (recursive_flag || continue_flag)))\r\n            abort(\"Flag combination does not make sense\");\r\n}\r\n\r\nvoid print_usage()\r\n{\r\n    string usage =\r\n    \"Compression:\\n\"\r\n    \"    qpress [-rovfCBPLKT] <source file/dir search pattern> <destination file>\\n\"\r\n    \"    qpress -i[ovfBPLKT] <filename to give stdin data> <destination file>\\n\\n\"\r\n    \"Decompression:\\n\"\r\n    \"    qpress -d[ovfBPTn] <source file> <destination directory>\\n\\n\"\r\n    \"Benchmark and recovery:\\n\"\r\n    \"    qpress -m[LT] <source file>\\n\"\r\n    \"    qpress -R <corrupted compressed file> <destination directory>\\n\\n\"\r\n    \"Flags:\\n\"\r\n    \"    -d   Decompress\\n\"\r\n    \"    -Ln  Set compression level to n where n = 1, 2 or 3 (default = 1)\\n\"\r\n    \"    -r   Include sub directories during compression\\n\"\r\n    \"    -v   Show progress information during compression and decompression\\n\"\r\n\t\"    -i   Read from stdin (omit source file or file/dir search pattern)\\n\"\r\n\t\"    -o   Write to stdout (omit destination file or directory)\\n\"\r\n    \"    -f   Overwrite existing files during compression and decompression (default\\n\"\r\n    \"         is to abort)\\n\"\r\n    \"    -C   Continue if a source file cannot be opened during compression (default\\n\"\r\n    \"         is to abort)\\n\"\r\n    \"    -Tn  Use n threads/cores where n = 1 to \" + str(MAX_THREAD_COUNT) + \" (default = \" + str(DEFAULT_THREAD_COUNT) + \"). Be aware of\\n\"\r\n    \"         memory usage with large n\\n\"\r\n    \"    -Kn  Read from disk in n KiB chunks during compression where n = \" + str(AIO_MAX_SECTOR_SIZE >> 10) + \" to\\n\" +\r\n    \"         \" + str(MAX_COMPRESS_CHUNK_SIZE >> 10) + \" (default = \" + str(DEFAULT_COMPRESS_CHUNK_SIZE >> 10) + \"). Be aware of memory usage with large n\\n\"\r\n\t//  \"================================================================================\\n\"\r\n    \"    -B   Windows only: Disable file system caching (FILE_FLAG_NO_BUFFERING) to\\n\"\r\n    \"         prevent cache of other applications from being be flushed. Keep\\n\"\r\n    \"         enabled if files are small and need further processing\\n\"\r\n    \"    -Pn  Windows only: Set CPU and disk I/O priority to n where 1 = BACKGORUND\\n\"\r\n\t\"         (Vista, 7, 2008 only), 2 = IDLE, 3 = NORMAL or 4 = ABOVE (default = 3)\\n\\n\"\r\n    \"Examples of compression:\\n\"\r\n#ifdef WINDOWS\r\n    \"    qpress -rv d:\\\\dir\\\\* database.qp\\n\"\r\n    \"    qpress -vfK4096T2 ../dir/*.xml database.qp 2> log.txt\\n\"\r\n    \"    qpress -ovL3K *.xml > database.qp\\n\"\r\n    \"    type database.xml | qpress -io database.xml > database.qp\\n\"\r\n    \"    type database.xml | qpress -i database.xml database.qp\\n\\n\"\r\n    \"Examples of decompression:\\n\"\r\n    \"    qpress -d database.qp d:\\\\dir\\n\"\r\n    \"    qpress -do database.qp > database.xml\\n\"\r\n    \"    type database.qp | qpress -di .\\n\\n\"\r\n#else\r\n    \"    qpress -v file1.xml file2.xml file3.xml database.qp\\n\"\r\n    \"    qpress -vfK4096T2 *.xml database.qp 2> log.txt\\n\"\r\n    \"    qpress -ovL3K *.xml > database.qp\\n\"\r\n    \"    cat database.xml | qpress -i database.xml database.qp\\n\"\r\n    \"    cat database.xml | qpress -io database.xml > database.qp\\n\\n\"\r\n    \"Examples of decompression:\\n\"\r\n    \"    qpress -d database.qp ./dir\\n\"\r\n    \"    qpress -do database.qp > database.xml\\n\"\r\n    \"    cat database.qp | qpress -di .\\n\\n\"\r\n#endif\r\n    \"Notes:\\n\"\r\n    \"When compressing on *nix with -r flag, file/dir search pattern only filters in\\n\"\r\n\t\"top level directory (directories matching in top level will be included fully).\\n\\n\"\r\n//  \"================================================================================\\n\" // 80 chars of \"=\"\r\n    \"If a compressed file contains multiple files and is decompressed to stdout, all\\n\"\r\n    \"files will be concatenated in a continuous stream.\\n\\n\"\r\n    \"It's recommended to use .qp as filename suffix.\\n\";\r\n    PRINT(FATAL_ERROR, \"qpress 1.1 - Copyright 2006-2010 Lasse Reinhold - www.quicklz.com\\n\");\r\n    PRINT(FATAL_ERROR, \"Using QuickLZ 1.4.1 compression library\\n\");\r\n\r\n\tPRINT(FATAL_ERROR, \"Compiled for: \");\r\n\t#ifdef WINDOWS\r\n\t\tPRINT(FATAL_ERROR, \"[Windows] *nix    \");\r\n\t#else\r\n\t\tPRINT(FATAL_ERROR, \"Windows [*nix]    \");\r\n\t#endif\r\n\r\n\t#ifdef X86X64\r\n\t\tPRINT(FATAL_ERROR, \"[x86/x64] RISC    \");\r\n\t#else\r\n\t\tPRINT(FATAL_ERROR, \"x86/x64 [RISC]    \");\r\n\t#endif\r\n\r\n\tif(sizeof(size_t) == 8)\r\n\t\tPRINT(FATAL_ERROR, \"32-bit [64-bit]\");\r\n\telse\r\n\t\tPRINT(FATAL_ERROR, \"[32-bit] 64-bit\");\r\n\r\n    PRINT(FATAL_ERROR, \"\\n\\n%s\", usage.c_str());\r\n\texit(-1);\r\n}\r\n\r\n\r\n\r\nvoid try_aopen(const char *file, char mode)\r\n{\r\n    if(mode == 'w')\r\n    {\r\n        if (!aopen_write(file))\r\n            abort(\"Error creating destination file '%s' - aborted\", file);\r\n    }\r\n    else\r\n    {\r\n        if (!aopen_read(file))\r\n            abort(\"Error opening source file '%s' - aborted\", file);\r\n    }\r\n}\r\n\r\nvoid mem_init(size_t chunk_size)\r\n{\r\n    for(unsigned int i = 0; i < threads; i++)\r\n    {\r\n        scratch[i] = (char *)malloc(QLZ_SCRATCH_COMPRESS());\r\n        src[i] = (char *)malloc((size_t)chunk_size + QLZ_SIZE_OVERHEAD);\r\n        dst[i] = (char *)malloc((size_t)chunk_size + QLZ_SIZE_OVERHEAD);\r\n        if(dst[i] == 0 || src[i] == 0 || scratch[i] == 0)\r\n            abort(\"Error allocating memory - decrease -T and -K flags\");\r\n    }\r\n}\r\n\r\nvoid *benchmark_compress_thread(void *arg)\r\n{\r\n    unsigned long long y = 0;\r\n    size_t id = (size_t)arg;\r\n    double t = GetTickCount();\r\n\twhile(GetTickCount() == t) {};\r\n    t = GetTickCount();\r\n\r\n\twhile(GetTickCount() - t < BENCHMARK_MILLISECONDS)\r\n    {\r\n        QLZ_COMPRESS(src[id], dst[id], bench_size / threads, compression_level, scratch[id]);\r\n        y += bench_size / threads;\r\n    }\r\n\tt = GetTickCount() - t;\r\n\ty = (unsigned long long)(y / t * 1000. / 1024.);\r\n    return (void *)(size_t)y;\r\n}\r\n\r\nvoid *benchmark_decompress_thread(void *arg)\r\n{\r\n    unsigned long long y = 0;\r\n    size_t id = (size_t)arg;\r\n    double t = GetTickCount();\r\n\twhile(GetTickCount() == t) {};\r\n    t = GetTickCount();\r\n\r\n\twhile(GetTickCount() - t < BENCHMARK_MILLISECONDS)\r\n    {\r\n        QLZ_DECOMPRESS(dst[id], src[id], scratch[id]);\r\n        y += QLZ_SIZE_DECOMPRESSED(dst[id]);\r\n    }\r\n\r\n\tt = GetTickCount() - t;\r\n\ty = (unsigned long long)(y / t * 1000. / 1024.);\r\n    return (void *)(size_t)y;\r\n}\r\n\r\nvoid benchmark(char *source_file)\r\n{\r\n    unsigned long long y = 0, u = 0;\r\n    double speed = 0.0;\r\n    void *status[MAX_THREAD_COUNT];\r\n    pthread_t thread[MAX_THREAD_COUNT];\r\n    FILE *ifile = fopen(source_file, \"rb\");\r\n\r\n\tif((ifile) == 0)\r\n        abort(\"Error opening source file '%s' - aborted\", source_file);\r\n\r\n    fseek(ifile, 0, SEEK_END);\r\n    size_t file_len = ftell(ifile);\r\n    fseek(ifile, 0, SEEK_SET);\r\n\r\n    if(file_len == 0 || file_len > 512*1024*1024)\r\n        abort(\"File too large for benchmark\");\r\n\r\n    if(file_len < 256*1024)\r\n        PRINT(WARNING, \"Note: File size should be at least 256 KiB for accurate results.\\n\");\r\n\r\n    mem_init(file_len / threads);\r\n\r\n    if(src[0] == 0 || dst[0] == 0 || scratch[0] == 0)\r\n        abort(\"Error allocating memory - file too large\");\r\n\r\n    PRINT(FATAL_ERROR, \"Using %d threads/cores (change with -T flag). Please wait...\\n\", threads);\r\n\r\n    for(size_t i = 0; i < threads; i++)\r\n    {\r\n        size_t t = fread(src[i], 1, file_len / threads, ifile);\r\n        if(t != file_len / threads)\r\n            abort(\"Error reading source file '%s'\", source_file);\r\n    }\r\n\r\n    bench_size = file_len;\r\n\r\n\tfor(int j = 0; j < BENCHMARK_BESTOF; j++)\r\n\t{\r\n\t\tdouble tmp_speed = 0.;\r\n\t\tfor(size_t i = 0; i < threads; i++)\r\n\t\t\tpthread_create(&thread[i], NULL, benchmark_compress_thread, (void*)i);\r\n\t\ty = 0;\r\n\t\tu = 0;\r\n\t\tfor(size_t i = 0; i < threads; i++)\r\n\t\t{\r\n\t\t\tpthread_join(thread[i], &status[i]);\r\n\t\t\ty += (size_t)status[i];\r\n\t\t\tu += QLZ_SIZE_COMPRESSED(dst[i]);\r\n\t\t}\r\n\t\ttmp_speed = (double)y / 1024.;\r\n\t\tif (tmp_speed > speed)\r\n\t\t\tspeed = tmp_speed;\r\n\t}\r\n\r\n\tPRINT(FATAL_ERROR, \"Compressed %s bytes into %s (%.1f%%) at %.1f MiB/s\\n\", delimiter(file_len).c_str(), delimiter(u).c_str(), (double)u/(double)file_len*100., speed);\r\n\r\n\tfor(int j = 0; j < BENCHMARK_BESTOF; j++)\r\n\t{\r\n\t\tdouble tmp_speed = 0.;\r\n\t\tfor(size_t i = 0; i < threads; i++)\r\n\t\t\tpthread_create(&thread[i], NULL, benchmark_decompress_thread, (void*)i);\r\n\t\ty = 0;\r\n\t\tfor(size_t i = 0; i < threads; i++)\r\n\t\t{\r\n\t\t\tpthread_join(thread[i], &status[i]);\r\n\t\t\ty += (size_t)status[i];\r\n\t\t}\r\n\t\ttmp_speed = (double)y / 1024.;\r\n\t\tif (tmp_speed > speed)\r\n\t\t\tspeed = tmp_speed;\r\n\t}\r\n\r\n\tPRINT(FATAL_ERROR, \"Decompressed at %.1f MiB/s\\n\", speed);\r\n}\r\n\r\nvoid update_statusbar(string description, bool force_update)\r\n{\r\n    static unsigned int last_tick = 0, last_speed_tick = 0, speed = 0;\r\n    static long long last_payload_counter_mbs = 0;\r\n    static pthread_mutex_t mu = PTHREAD_MUTEX_INITIALIZER;\r\n    unsigned int t = GetTickCount() - last_tick;\r\n    unsigned int s = GetTickCount() - last_speed_tick;\r\n\r\n    pthread_mutex_lock(&mu);\r\n\r\n    if (s > 3000)\r\n    {\r\n        // update speed each 3'rd second\r\n        speed = (unsigned int)((payload_counter - last_payload_counter_mbs) / (s == 0 ? 1 : s));\r\n        last_payload_counter_mbs = payload_counter;\r\n        last_speed_tick = GetTickCount();\r\n    }\r\n\r\n    if (force_update || t > 400)\r\n    {\r\n        // draw status bar each 0.4 second\r\n        last_tick = GetTickCount();\r\n        if(description == \"c\")\r\n            PRINT(COUNTER_UPDATE, \"%s    Compressed %s MiB (%d MiB/s) into %s MiB\\r\", BLANK_LINE, delimiter(payload_counter >> 20).c_str(), speed >> 10, delimiter(awritten() >> 20).c_str());\r\n        else\r\n            PRINT(COUNTER_UPDATE, \"%s    Wrote %s MiB (%d MiB/s)\\r\", BLANK_LINE, delimiter(payload_counter >> 20).c_str(), speed >> 10);\r\n    }\r\n\r\n    pthread_mutex_unlock(&mu);\r\n}\r\n\r\nvoid recover(void)\r\n{\r\n    if(recover_flag)\r\n    {\r\n        char search[9] = {0, 0, 0, 0, 0, 0, 0, 0, 0};\r\n        unsigned long long p;\r\n        do\r\n        {\r\n            memmove(search, search + 1, 8);\r\n            size_t y = aread(search + 8, 1);\r\n            if (y == 0)\r\n            {\r\n                aclose_write();\r\n                abort(\"Unexpected end of source file - destination data and/or files missing\");\r\n            }\r\n        } while (strncmp(search + 1, \"NEWBNEWB\", 8) != 0);\r\n\r\n        p = fread64(); // read pos\r\n        if(p - recovery_file_written < 1024*1024*1024) // improbable chunksize, probably overwrap\r\n        {\r\n            for(unsigned long long g = 0; g < p - recovery_file_written; g++)\r\n                try_awrite(\"!\", 1);\r\n            PRINT(WARNING, \"%s%s bytes at offset %s bad - replaced with '!'\\n\\n\", BLANK_LINE, delimiter(p - recovery_file_written).c_str(), delimiter(recovery_file_written).c_str());\r\n            recovery_bad_bytes += (p - recovery_file_written);\r\n            recovery_file_written = p;\r\n        }\r\n        else\r\n        {\r\n            PRINT(WARNING, \"%sData from other files may be appended to this file\\n\\n\", BLANK_LINE);\r\n            recovery_file_written = p; // ?  todo\r\n        }\r\n    }\r\n    else\r\n        abort(\"Source file is corrupted - try the -R flag to recover\");\r\n}\r\n\r\nvoid *decompress_file_thread(void *arg)\r\n{\r\n    size_t thread_id = (size_t)arg;\r\n    bool just_recovered_block = false;\r\n    recovery_file_written = 0;\r\n\r\n    update_statusbar(\"d\", true);\r\n\r\n    for(;;)\r\n    {\r\n        unsigned long long my_chunk;\r\n        unsigned int crc_r, crc_original;\r\n        size_t decomp_size;\r\n\r\n        pthread_mutex_lock(&disk_read_mutex);\r\n        update_statusbar(\"d\", false);\r\n\r\n        if (end_of_file)\r\n        {\r\n            pthread_mutex_unlock(&disk_read_mutex);\r\n            break;\r\n        }\r\n\r\n        if(!just_recovered_block)\r\n        {\r\n            // read NEWBNEWB or ENDSENDS\r\n            try_aread(src[thread_id], 1);\r\n            try_aread(tmp, 7);\r\n        }\r\n\r\n        if (*src[thread_id] == 'N') // NEWBNEWB\r\n        {\r\n            fread64(); // reset pos\r\n        }\r\n        else if(*src[thread_id] == 'E') // ENDSENDS\r\n        {\r\n            end_of_file = true;\r\n            try_aread(tmp, 8); // reset pos\r\n            files++;\r\n            pthread_mutex_unlock(&disk_read_mutex);\r\n            break;\r\n        }\r\n        else if(just_recovered_block)\r\n            just_recovered_block = false;\r\n        else\r\n            abort(\"Data error, not recoverable\"); // todo, it is recoverable, but code is not implemented yet\r\n\r\n        crc_original = fread32();\r\n        try_aread(src[thread_id], 9);\r\n        if (QLZ_SIZE_COMPRESSED(src[thread_id]) > compress_chunk_size + QLZ_SIZE_OVERHEAD)\r\n            abort(\"Data error, not recoverable\"); // todo, it is recoverable, but code is not implemented yet\r\n\r\n        try_aread(src[thread_id] + 9, QLZ_SIZE_COMPRESSED(src[thread_id]) - 9);\r\n\r\n        my_chunk = chunks_read;\r\n        chunks_read++;\r\n        pthread_mutex_unlock(&disk_read_mutex);\r\n\r\n        crc_r = adler((unsigned char *)src[thread_id], QLZ_SIZE_COMPRESSED(src[thread_id]), 0x00010000);\r\n        if (crc_r != crc_original)\r\n        {\r\n            just_recovered_block = true;\r\n            recover();\r\n        }\r\n        decomp_size = QLZ_DECOMPRESS(src[thread_id], dst[thread_id], scratch[thread_id]);\r\n\r\n        // Could be beautified into not using yield. Schedules writes to occur in correct order.\r\n        for(;;)\r\n        {\r\n            pthread_mutex_lock(&disk_write_mutex);\r\n            if(my_chunk == chunks_written)\r\n                break;\r\n            else\r\n            {\r\n                pthread_mutex_unlock(&disk_write_mutex);\r\n                utils_yield();\r\n            }\r\n        }\r\n        chunks_written++;\r\n        if(!just_recovered_block)\r\n        {\r\n            payload_counter += decomp_size;\r\n            recovery_file_written += decomp_size;\r\n            try_awrite(dst[thread_id], decomp_size);\r\n        }\r\n        pthread_mutex_unlock(&disk_write_mutex);\r\n    }\r\n    return 0;\r\n}\r\n\r\n\r\nvoid decompress_file(string dest_file)\r\n{\r\n    pthread_t thread[MAX_THREAD_COUNT];\r\n    size_t i;\r\n    end_of_file = false;\r\n    chunks_read = 0;\r\n    chunks_written = 0;\r\n    void *status;\r\n\r\n\ttry_aopen(dest_file.c_str(), 'w');\r\n\r\n    for(i = 0; i < threads; i++)\r\n    {\r\n        pthread_create(&thread[i], NULL, decompress_file_thread, (void *)i);\r\n    }\r\n\r\n    for(i = 0; i < threads; i++)\r\n    {\r\n        pthread_join(thread[i], &status);\r\n    }\r\n\r\n\tif(dest_file != \"<stdout>\")\r\n\t\taclose_write();\r\n}\r\n\r\nvoid *compress_file_thread(void *arg)\r\n{\r\n    size_t read;\r\n    do\r\n    {\r\n        size_t u, thread_id = (size_t)arg;\r\n        unsigned int crc_r;\r\n        unsigned long long my_chunk;\r\n\r\n        update_statusbar(\"c\", false);\r\n\r\n        pthread_mutex_lock(&disk_write_mutex);\r\n        my_chunk = chunks_read;\r\n        chunks_read++;\r\n\r\n        pthread_mutex_lock(&disk_read_mutex);\r\n        pthread_mutex_unlock(&disk_write_mutex);\r\n        read = aread(src[thread_id], compress_chunk_size);\r\n        pthread_mutex_unlock(&disk_read_mutex);\r\n\r\n        if (read == 0)\r\n            return 0;\r\n\r\n        u = QLZ_COMPRESS(src[thread_id], dst[thread_id], read, compression_level, scratch[thread_id]);\r\n        crc_r = adler((unsigned char *)dst[thread_id], u, 0x00010000);\r\n\r\n        // Could be beautified into not using yield. Schedules writes to occur in correct order.\r\n        for(;;)\r\n        {\r\n            pthread_mutex_lock(&disk_write_mutex);\r\n            if(my_chunk == chunks_written)\r\n                break;\r\n            else\r\n            {\r\n                pthread_mutex_unlock(&disk_write_mutex);\r\n                utils_yield();\r\n            }\r\n        }\r\n\r\n        try_awrite(\"NEWBNEWB\", 8);\r\n        fwrite64(current_file_payload);\r\n        payload_counter += read;\r\n        current_file_payload += read;\r\n        fwrite32(crc_r);\r\n        chunks_written++;\r\n        try_awrite(dst[thread_id], u);\r\n        pthread_mutex_unlock(&disk_write_mutex);\r\n    } while (read == compress_chunk_size);\r\n\r\n    return 0;\r\n}\r\n\r\nvoid compress_file(string input_file, string filename)\r\n{\r\n    pthread_t thread[MAX_THREAD_COUNT];\r\n    unsigned long long bytes_written = 0;\r\n    void *status;\r\n\r\n\tif(aopen_read(input_file.c_str()))\r\n\t{\r\n\t\tPRINT(FILES_PROCESSED, \"%s    %s\\n\", BLANK_LINE, filename.c_str());\r\n\t\tupdate_statusbar(\"c\", true);\r\n\t\ttry_awrite(\"F\", 1);\r\n\t\tfwrite32((unsigned int)filename.length());\r\n\t\ttry_awrite(filename.c_str(), filename.length());\r\n\t\ttry_awrite(\"\\0\", 1);\r\n\r\n\t\tfiles++;\r\n\t\tchunks_read = 0;\r\n\t\tchunks_written = 0;\r\n\t\tcurrent_file_payload = 0;\r\n\r\n\t\tfor(size_t i = 0; i < threads; i++)\r\n\t\t\tpthread_create(&thread[i], NULL, compress_file_thread, (void*)i);\r\n\r\n\t\tfor(size_t i = 0; i < threads; i++)\r\n\t\t\tpthread_join(thread[i], &status);\r\n\r\n\t\ttry_awrite(\"ENDSENDS\", 8);\r\n\t\tfwrite64(bytes_written);\r\n\t\taclose_read(); // closes input_file\r\n\t}\r\n\telse if (continue_flag && input_file != \"<stdin>\")\r\n\t\tPRINT(WARNING, \"%s%s: Error opening source file '%s' - skipped\\n\", BLANK_LINE, \"qpress\", input_file.c_str());\r\n\telse\r\n\t\tabort(\"Error opening source file '%s' - aborted\", input_file.c_str());\r\n}\r\n\r\nstring void2curdir(string path)\r\n{\r\n\treturn path == \"\" ? CURDIR : path;\r\n}\r\n\r\nvoid godown(const char *dir)\r\n{\r\n\tsize_t chunk_size = strlen(dir);\r\n\ttry_awrite(\"D\", 1);\r\n\tfwrite32((unsigned int)chunk_size);\r\n\ttry_awrite(dir, strlen(dir));\r\n\ttry_awrite(\"\\0\", 1);\r\n}\r\n\r\nvoid goup(void)\r\n{\r\n\ttry_awrite(\"U\", 1);\r\n}\r\n\r\n\r\nstring remove_curdir(string dir)\r\n{\r\n\tif(dir.length() >= 2 && dir.substr(0, 2) == CURDIR)\r\n\t\treturn dir.substr(2, dir.length() - 2);\r\n\telse\r\n\t\treturn dir;\r\n}\r\n\r\nvoid compress_directory(string base_dir, string pattern)\r\n{\r\n    string path;\r\n    struct dirent *entry;\r\n\tDIR *dir;\r\n\r\n\tbase_dir = remove_curdir(base_dir);\r\n\r\n\tstring api_path = (base_dir == \"\" ? \"\" : remove_delimitor(base_dir) + DELIM_STR);\r\n\r\n\tif(base_dir != \"\")\r\n\t\tPRINT(FILES_PROCESSED, \"%s%s%s\\n\", BLANK_LINE, base_dir.c_str(), DELIM_STR);\r\n\r\n\t// process files\r\n\tif((dir = opendir(void2curdir(api_path).c_str())))\r\n\t{\r\n#ifdef WINDOWS\r\n        while((entry = readdir_wildcard(dir, (char *)pattern.c_str())))\r\n#else\r\n        while((entry = readdir(dir)))\r\n#endif\r\n\t\t{\r\n\t\t\tif(string(entry->d_name) != \".\" && string(entry->d_name) != \"..\")\r\n\t\t\t{\r\n\t\t\t\tpath = api_path + string(entry->d_name);\r\n\t\t\t\tif (!is_dir(path))\r\n\t\t\t\t{\r\n\t\t\t\t\t// we must avoid including destination file when compressing. Note that *nix is case sensitive.\r\n\t\t\t\t\tabsolute_path((char *)path.c_str(), tmp);\r\n#ifdef WINDOWS\r\n\t\t\t\t\tif(lcase(string(tmp)) != lcase(destination_file))\r\n#else\r\n\t\t\t\t\tif(string(tmp) != destination_file)\r\n#endif\r\n\t\t\t\t\t\tcompress_file(path, string(entry->d_name));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t    closedir(dir);\r\n\t}\r\n\r\n\r\n\r\n\t// process directories\r\n    if(recursive_flag && (dir = opendir(void2curdir(api_path).c_str())))\r\n\t{\r\n#ifdef WINDOWS\r\n        while((entry = readdir_wildcard(dir, \"*\")))\r\n#else\r\n        while((entry = readdir(dir)))\r\n#endif\r\n\t\t{\r\n\t\t\tpath = api_path + string(entry->d_name);\r\n\r\n\t\t\tif(is_dir(path) && string(entry->d_name) != \".\" && string(entry->d_name) != \"..\")\r\n\t\t\t{\r\n\t\t\t\tgodown(entry->d_name);\r\n\t\t\t\tcompress_directory(path, pattern);\r\n\t\t\t\tgoup();\r\n\t\t\t}\r\n\t\t}\r\n\t\tclosedir(dir);\r\n\t}\r\n }\r\n\r\n\r\nvoid decompress_directory(string extract_dir, bool std_out)\r\n{\r\n    char c;\r\n    string curdir;\r\n    size_t r = 0;\r\n    unsigned int chunk_size;\r\n\r\n    curdir = string(extract_dir);\r\n\r\n    for(;;)\r\n    {\r\n        r = aread(&c, 1);\r\n        if (r == 0)\r\n            return;\r\n\r\n        if(c == 'D')\r\n        {\r\n\t\t\t// read directory name, append it to current path and create the directory\r\n            chunk_size = fread32();\r\n            try_aread(tmp, chunk_size + 1);\r\n            curdir = curdir + DELIM_STR + tmp;\r\n            PRINT(FILES_PROCESSED, \"%s%s%s\\n\", BLANK_LINE, remove_leading_curdir(curdir).c_str(), DELIM_STR);\r\n            if(!std_out)\r\n            {\r\n#ifdef WINDOWS\r\n                CreateDirectory(curdir.c_str(), 0);\r\n#else\r\n                mkdir(curdir.c_str(), 509);\r\n#endif\r\n            }\r\n        }\r\n        else if(c == 'U')\r\n            curdir = curdir.substr(0, curdir.find_last_of(DELIM_STR)); // remove last sub dir from current path\r\n        else if(c == 'F')\r\n        {\r\n            chunk_size = fread32(); // read length of file name\r\n            try_aread(tmp, chunk_size + 1); // read file name\r\n            string buf2 = curdir + DELIM_STR + tmp;\r\n            PRINT(FILES_PROCESSED, \"%s    %s\\n\", BLANK_LINE, tmp);\r\n            if(!std_out)\r\n            {\r\n                if(exists(buf2) && !force_flag)\r\n                    abort(\"Destination file '%s' already exists - aborted\", buf2.c_str());\r\n                else\r\n                    decompress_file(buf2);\r\n            }\r\n            else\r\n                decompress_file(\"<stdout>\");\r\n        }\r\n        else\r\n            abort(\"Source file is corrupted - try the -R flag to recover\");\r\n    }\r\n}\r\n\r\nstring filenamepart(string filenamepath)\r\n{\r\n    size_t r = filenamepath.find_last_of(\"/\\\\\");\r\n    if(r == string::npos)\r\n        return filenamepath;\r\n    else\r\n        return filenamepath.substr(r + 1);\r\n}\r\n\r\n\r\nsearch_type split(string source)\r\n{\r\n    search_type ret;\r\n\r\n\tif(is_dir(source))\r\n\t{\r\n\t\tret.path = source;\r\n\t\tret.pattern = \"\";\r\n\t\treturn ret;\r\n\t}\r\n\r\n\tsource = remove_leading_curdir(source);\r\n\r\n    size_t r = source.find_last_of(\"/\\\\\");\r\n\r\n    if(r == string::npos)\r\n    {\r\n\t\tret.path = \"\";\r\n\t\tret.pattern = source;\r\n\t\treturn ret;\r\n\t}\r\n\telse\r\n\t{\r\n\t\t/* .\\dir\\*.hej?j */\r\n\t\tret.path = source.substr(0, r);\r\n\t\tret.pattern = source.substr(r + 1);\r\n\t\treturn ret;\r\n\t}\r\n}\r\n\r\nint main(int argc, char* argv[])\r\n{\r\n    string *arg = new string[argc];\r\n    for(int i = 0; i < argc; i++)\r\n        arg[i] = argv[i];\r\n\r\n    parse_flags(argc, argv);\r\n\r\n    tty_stderr = isatty(fileno(stderr));\r\n\r\n\r\n\r\n#ifdef WINDOWS\r\n    setmode(fileno(stdin), _O_BINARY);\r\n    setmode(fileno(stdout), _O_BINARY);\r\n    pthread_win32_process_attach_np ();\r\n#endif\r\n\r\n// In-memory benchmark\r\n// =================================================================================================\r\n    if (benchmark_flag && (!input_pipe) && argc == 3)\r\n    {\r\n        benchmark(argv[2]);\r\n    }\r\n\r\n// Decompress and Recover\r\n// =================================================================================================\r\n    else if ((decompress_flag || recover_flag) && argc == 2 + (!input_pipe) + (1 - output_pipe))\r\n    {\r\n        if(recover_flag)\r\n            threads = 1;\r\n\r\n        aio_init(compress_chunk_size + QLZ_SIZE_OVERHEAD, cache_flag);\r\n        if(!input_pipe)\r\n        {\r\n            try_aopen(arg[2].c_str(), 'r');\r\n            aread(tmp, 8);\r\n            compress_chunk_size = fread64();\r\n            aclose_read();\r\n            aio_init(compress_chunk_size + QLZ_SIZE_OVERHEAD, cache_flag);\r\n            try_aopen(arg[2].c_str(), 'r');\r\n            aread(tmp, 16);\r\n        }\r\n        else\r\n        {\r\n            try_aopen(\"<stdin>\", 'r');\r\n            aread(tmp, 8);\r\n            compress_chunk_size = fread64();\r\n            aio_init(compress_chunk_size + QLZ_SIZE_OVERHEAD, cache_flag);\r\n        }\r\n\r\n        if(strncmp(tmp, \"qpress\", 6) != 0)\r\n            abort(\"Source file was not compressed with qpress\");\r\n\r\n        if(tmp[6] != '1')\r\n            abort(\"Version %d.x.x is required to decompress this file\", tmp[6] - 48);\r\n\r\n        if(compress_chunk_size > 512*1024*1024)\r\n            abort(\"Source file is corrupted - try the -R flag to recover\");\r\n\r\n        mem_init(compress_chunk_size);\r\n\r\n        if(output_pipe)\r\n            decompress_directory(\"\", true);\r\n        else\r\n        {\r\n            string s = remove_delimitor(arg[2 + (!input_pipe)]);\r\n            decompress_directory(s, false);\r\n        }\r\n\r\n        aclose_read();\r\n        if(recover_flag)\r\n        {\r\n            PRINT(RESULT, \"%sWrote %s bytes in %s file(s) of which %s bytes are bad\\n\", BLANK_LINE, delimiter(payload_counter + recovery_bad_bytes).c_str(), delimiter(files).c_str(), delimiter(recovery_bad_bytes).c_str());\r\n            PRINT(RESULT, \"\\nNote: There may be more errors than listed. Files may be missing or placed\\nin wrong directories and files may contain fragments of other files.\");\r\n        }\r\n        else\r\n            PRINT(RESULT, \"%sWrote %s bytes in %s file(s).\", BLANK_LINE, delimiter(payload_counter).c_str(), delimiter(files).c_str());\r\n    }\r\n\r\n// Compress\r\n// =================================================================================================\r\n    else if(!decompress_flag && argc >= 2 + flags_exist + (1 - output_pipe))\r\n    {\r\n        string output_file;\r\n\r\n        mem_init(compress_chunk_size);\r\n        aio_init(compress_chunk_size + QLZ_SIZE_OVERHEAD, cache_flag);\r\n\r\n        if(output_pipe)\r\n            try_aopen(\"<stdout>\", 'w');\r\n        else\r\n        {\r\n\t\t\toutput_file = arg[argc - 1];\r\n            if(exists(output_file) && !force_flag)\r\n                abort(\"Destination file '%s' already exists\", output_file.c_str());\r\n\r\n            try_aopen(output_file.c_str(), 'w');\r\n        }\r\n\r\n        try_awrite(\"qpress10\", 8);\r\n\t\tfwrite64(compress_chunk_size);\r\n\r\n        if(!input_pipe)\r\n        {\r\n\t\t\tabsolute_path((char *)output_file.c_str(), tmp);\r\n\t\t\tdestination_file = string(tmp);\r\n#ifdef WINDOWS\r\n\t\t\tif(split(arg[1 + flags_exist]).pattern != \"\")\r\n\t\t\t\tcompress_directory(split(arg[1 + flags_exist]).path, split(arg[1 + flags_exist]).pattern);\r\n#else\r\n\t\t\tfor(int i = 1 + flags_exist; i < argc - ((!output_pipe) == true ? 1 : 0); i++)\r\n\t\t\t{\r\n\t\t\t\tif (!is_dir(arg[i]))\r\n\t\t\t\t\tcompress_file(arg[i], filenamepart(arg[i]));\r\n\t\t\t}\r\n\r\n\t\t\tif(recursive_flag)\r\n\t\t\t{\r\n\t\t\t\tfor(int i = 1 + flags_exist; i < argc - ((!output_pipe)== true ? 1 : 0); i++)\r\n\t\t\t\t{\r\n\t\t\t\t\tif(is_dir(arg[i]))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\targ[i] = remove_delimitor(arg[i]);\r\n\t\t\t\t\t\tif(filenamepart(arg[i]) == \".\" || filenamepart(arg[i]) == \"..\")\r\n\t\t\t\t\t\t\tcompress_directory(arg[i], \"*\");\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tgodown(filenamepart(arg[i]).c_str());\r\n\t\t\t\t\t\t\tcompress_directory(arg[i], \"*\");\r\n\t\t\t\t\t\t\tgoup();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n#endif\r\n        }\r\n        else\r\n        {\r\n            compress_file(\"<stdin>\", arg[1 + flags_exist]);\r\n        }\r\n\r\n\t\tif(files == 0)\r\n\t\t\tabort(\"0 files found. Are you missing a search pattern such as '*'?\");\r\n\t\telse\r\n\t\t{\r\n\t        PRINT(RESULT, \"%sCompressed %s bytes in %s file(s) into %s bytes\", BLANK_LINE, delimiter(payload_counter).c_str(), delimiter(files).c_str(), delimiter(awritten()).c_str());\r\n\t\t    aclose_write();\r\n\t\t}\r\n    }\r\n    else\r\n        print_usage();\r\n\r\n    PRINT(RESULT, \"\\n\");\r\n}\r\n\r\n"], "fixing_code": ["/*\r\nqpress - portable high-speed file archiver\r\nCopyright Lasse Reinhold 2006-2010\r\nGPL 1, 2 and 3 licensed.\r\n\r\nAn archive file consists of \"D\" and \"U\" characters which instruct the decompressor to traverse up and down in\r\ndirectories to create a directory three. The \"F\" character instructs it to create a file:\r\n\r\nARCHIVE =        ARCHIVEHEADER + (1 or more of UPDIR | DOWNDIR | FILE)\r\nARCHIVEHEADER =  \"qpress10\" + (ui64)(chunk size of decompressed packets)\r\nDOWNDIR =        \"D\" + (ui32)(size of directory name) + (directory name) + (char)0\r\nUPDIR =          \"U\"\r\nFILE =           FILEHEADER + (0 or more of DATABLOCK) + FILETRAILER\r\nFILEHEADER =     \"F\" + (ui32)(size of file name) + (file name) + (char)0\r\nDATABLOCK =      \"NEWBNEWB\" + (ui64)(recovery information) + (ui32)(adler32 of compressed block) + (compressed packet)\r\nFILETRAILER =    \"ENDSENDS\" + (ui64)(recovery information)\r\n\r\nThe values (ui32) and (ui64) are stored in little endian format. Example of compressing following directory structure:\r\n\r\nFOO             directory\r\n\tc.txt       file containing \"hello\"\r\n\tBAR         empty directory\r\nd.txt           file containing \"there\"\r\n\r\nTwo digit values are in hexadecimal, remaining values are printable and represented by their character:\r\n\r\n          0   1   2   3   4   5   6   7   8   9   a   b   c   d   e   f\r\n000000    q   p   r   e   s   s   1   0  00  00  01  00  00  00  00  00\r\n000010    F  05  00  00  00   c   .   t   x   t  00   N   E   W   B   N\r\n000020    E   W   B  00  00  00  00  00  00  00  00  eb  02   %  0d   E\r\n000030   0c  05  00  00  00  80   h   e   l   l   o   E   N   D   S   E\r\n000040    N   D   S  00  00  00  00  00  00  00  00   D  03  00  00  00\r\n000050    F   O   O  00   D  03  00  00  00   B   A   R  00   F  05  00\r\n000060   00  00   d   .   t   x   t  00   N   E   W   B   N   E   W   B\r\n000070   00  00  00  00  00  00  00  00  ef  02   Z  0d   E  0c  05  00\r\n000080   00  00  80   t   h   e   r   e   E   N   D   S   E   N   D   S\r\n000090   00  00  00  00  00  00  00  00   U   U\r\n\r\nOffsets 2f - 3a and 7c - 87 are compressed packets. You see \"hello\" and \"there\" in plaintext because input is too small\r\nto compress.\r\n\r\nWhen decompressing, decompress_directory() takes the user given destination path as argument and begins extracting\r\nfiles into it. When a DOWNDIR is read it appends its sub directory to the path. When an UPDIR is read it removes the\r\ndeepest sub directory from the path. When a FILE is read, it calls decompress_file() which starts threads that each, in\r\na loop, reads a chunk, decompresses and writes to destination file:\r\n\r\ndecompress_directory() --> decompress_file() --> decompress_file_thread()\r\n                                             +-> decompress_file_thread()\r\n                                             +-> decompress_file_thread()\r\n\r\nWhen compressing, compress_directory() searches for files in the path given as argument. For each file found, it calls\r\ncompress_file(). When a directory is found, it appends it to the path, outputs a DOWNDIR, calls itself with the new path\r\nand finally outputs an UPDIR:\r\n\r\n+-> compress_directory() +-> compress_file() --> compress_file_thread()\r\n|                        |                   +-> compress_file_thread()\r\n+------------------------+                   +-> compress_file_thread()\r\n\r\n*/\r\n\r\n// Larger chunk size gives better compression ratio. However, on Windows Vista, 64 KiB or smaller\r\n// improves parallel disk I/O when data is both read and written.\r\n#define DEFAULT_COMPRESS_CHUNK_SIZE (64*1024)\r\n\r\n// Data compressed with a specific chunk size requires 2 * (chunk size) * (thread count) memory to\r\n// decompress (32 MiB requires 128 MiB with the default 2 threads), so we should limit it for\r\n// archives to be able to decompress on systems with little memory\r\n#define MAX_COMPRESS_CHUNK_SIZE (32*1024*1024)\r\n\r\n// Can be increased to any value - we just need this constant for some static arrays\r\n#define MAX_THREAD_COUNT 256\r\n\r\n// Too many threads can decrease throughput because of overheads and can also starve other processes\r\n#define DEFAULT_THREAD_COUNT 2\r\n#define DEFAULT_COMPRESSION_LEVEL 1\r\n\r\n#define BLANK_LINE \"\\r                                                          \\r\"\r\n\r\n// How much qlz_compress() can expand input data with (some incompressible data may grow in size). This\r\n// is 400 bytes regardless of input size, even for gigabyte range.\r\n#define QLZ_SIZE_OVERHEAD 400\r\n\r\n// Benchmark with -m flag uses 18.2 timer and must be executed in a loop for a large BENCHMARK_MILLISECONDS\r\n// to be accurate. To avoid interruptions and disturbions from OS and other applications, do it BENCHMARK_BESTOF\r\n// times and pick the best.\r\n#define BENCHMARK_MILLISECONDS 3000\r\n#define BENCHMARK_BESTOF 3\r\n\r\n#include <sys/stat.h>\r\n#include <stdlib.h>\r\n#include <stdio.h>\r\n#include \"aio.hpp\"\r\n#include <stdarg.h>\r\n#include <string>\r\n#include \"levels.c\"\r\n#include \"utilities.hpp\"\r\n\r\n#if defined(__APPLE__) || defined(__linux__)\r\n    #include <unistd.h>\r\n#endif\r\n\r\nusing namespace std;\r\n\r\n#ifdef WINDOWS\r\n  #include <fcntl.h>\r\n  #include <time.h>\r\n  #include <windows.h>\r\n  #include <io.h>\r\n  #include \"dirent_win.h\"\r\n  #include \"pthread.h\"\r\n#else\r\n  #include \"dirent.h\"\r\n  #include <pthread.h>\r\n#endif\r\n\r\n#if QLZ_STREAMING_BUFFER != 0\r\n#error QLZ_STREAMING_BUFFER must be 0\r\n#endif\r\n\r\n#ifdef WINDOWS\r\n\t#define CURDIR \".\\\\\"\r\n    #define DELIM_STR \"\\\\\"\r\n    #define DELIM_CHAR '\\\\'\r\n    #define LONGLONG \"%I64d\"\r\n\t#ifndef PROCESS_MODE_BACKGROUND_BEGIN\r\n\t    #define PROCESS_MODE_BACKGROUND_BEGIN   0x00100000\r\n    #endif\r\n#else\r\n\t#define CURDIR \"./\"\r\n    #define DELIM_STR \"/\"\r\n    #define DELIM_CHAR '/'\r\n    #define LONGLONG \"%lld\"\r\n#endif\r\n\r\ntypedef struct\r\n{\r\n    string path;\r\n    string pattern;\r\n} search_type;\r\n\r\n// command line flags\r\nbool continue_flag = false;\r\nbool cache_flag = true;\r\nbool force_flag = false;\r\nbool recursive_flag = false;\r\nbool decompress_flag = false;\r\nbool recover_flag = false;\r\nbool benchmark_flag = false;\r\nunsigned long long compress_chunk_size = DEFAULT_COMPRESS_CHUNK_SIZE;\r\nunsigned int compression_level = DEFAULT_COMPRESSION_LEVEL;\r\nunsigned int threads = DEFAULT_THREAD_COUNT;\r\nbool verbose_flag = false;\r\nbool flags_exist = false;\r\nbool tty_stderr;\r\nbool input_pipe;\r\nbool output_pipe;\r\n\r\n// QuickLZ compression, decompression and scratch buffers\r\nchar *src[MAX_THREAD_COUNT];\r\nchar *dst[MAX_THREAD_COUNT];\r\nchar *scratch[MAX_THREAD_COUNT];\r\n\r\n// statistics to show to user\r\nunsigned int files = 0;\r\nunsigned long long payload_counter = 0;\r\n\r\n// threaded disk i/o scheduling\r\npthread_mutex_t disk_read_mutex = PTHREAD_MUTEX_INITIALIZER;\r\npthread_mutex_t disk_write_mutex = PTHREAD_MUTEX_INITIALIZER;\r\npthread_mutex_t disk_order_mutex = PTHREAD_MUTEX_INITIALIZER;\r\npthread_cond_t disk_order_cond;\r\nunsigned long long chunks_read;\r\nunsigned long long chunks_written;\r\nbool end_of_file;\r\n\r\n// destination file during compression\r\nstring destination_file;\r\n\r\n// hack to pass file length to threads during benchmark\r\nunsigned long long bench_size;\r\n\r\n// various\r\nunsigned long long recovery_file_written;\r\nunsigned long long recovery_bad_bytes = 0;\r\nunsigned long long current_file_payload;\r\nconst long NAME_BUFFER_SIZE = 200000;\r\nchar tmp[NAME_BUFFER_SIZE];\r\n\r\n\r\nenum {FATAL_ERROR, COUNTER_UPDATE, FILES_PROCESSED, RESULT, WARNING};\r\n\r\nvoid PRINT(int MESSAGE_TYPE, const char *fmt, ...)\r\n{\r\n    va_list arg;\r\n    va_start(arg, fmt);\r\n\r\n    if(MESSAGE_TYPE == FATAL_ERROR)\r\n    {\r\n        vfprintf(stderr, fmt, arg);\r\n    }\r\n    else if(MESSAGE_TYPE == COUNTER_UPDATE)\r\n    {\r\n        // && tty_stderr to avoid flooding log files with 'xx MiB/s' lines\r\n        if(verbose_flag && tty_stderr)\r\n            vfprintf(stderr, fmt, arg);\r\n    }\r\n    else if(MESSAGE_TYPE == FILES_PROCESSED)\r\n    {\r\n        if(verbose_flag)\r\n            vfprintf(stderr, fmt, arg);\r\n    }\r\n    else if(MESSAGE_TYPE == RESULT)\r\n    {\r\n        if(verbose_flag)\r\n\t        vfprintf(stderr, fmt, arg);\r\n    }\r\n    else if(MESSAGE_TYPE == WARNING)\r\n    {\r\n        vfprintf(stderr, fmt, arg);\r\n    }\r\n    va_end(arg);\r\n}\r\n\r\nvoid abort(const char *fmt, ...)\r\n{\r\n    va_list arg;\r\n    va_start(arg, fmt);\r\n    PRINT(FATAL_ERROR, \"\\r%s\\r%s: \", BLANK_LINE, \"qpress\");\r\n    vfprintf(stderr, fmt, arg); // todo: use PRINT instead, when found out how to pass fmt\r\n    va_end(arg);\r\n    PRINT(FATAL_ERROR, \"\\n\");\r\n    adelete_write();\r\n    exit(-1);\r\n}\r\n\r\n\r\nint int_flag(string arg, string flag)\r\n{\r\n    int r;\r\n    size_t s0 = arg.find_first_of(flag);\r\n    if (s0 != string::npos)\r\n    {\r\n        string s1 = arg.substr(s0);\r\n        r = atoi(s1.substr(1, s1.find_first_not_of(\"0123456789\", 1) - 1).c_str());\r\n        if(r == 0)\r\n            abort(\"Invalid value for -%s flag\", flag.c_str());\r\n        else\r\n            return r;\r\n    }\r\n    return -1;\r\n}\r\n\r\nvoid parse_flags(int argc, char* argv[])\r\n{\r\n    string *arg = new string[argc];\r\n\r\n    for(int i = 0; i < argc; i++)\r\n        arg[i] = argv[i];\r\n\r\n    if(argc > 1 && arg[1].substr(0, 1) == \"-\")\r\n    {\r\n        size_t o = 0;\r\n\r\n        flags_exist = true;\r\n        size_t e = arg[1].find_first_not_of(\"-iodrvcmRfKCBPLT0123456789\");\r\n        if(e != string::npos)\r\n            abort(\"Unknown flag -%s\", arg[1].substr(e, 1).c_str());\r\n\r\n        // abort if argument matches [^LPTK][1-9] (but for source/compilation simplicity we don't include a regex lib)\r\n        do\r\n        {\r\n            string c = \"-\";\r\n            o = arg[1].find_first_of(\"0123456789\", o + 1);\r\n            if(o != string::npos)\r\n                c = arg[1].substr(o - 1, 1);\r\n            if(c != \"-\" && c != \"L\" && c != \"P\" && c != \"T\" && c != \"K\" && (c < \"0\" || c > \"9\"))\r\n                abort(\"Numeric values must be preceded by L, P, T or K\");\r\n        } while (o != string::npos);\r\n\r\n        decompress_flag = arg[1].find_first_of(\"d\") != string::npos ? true : false;\r\n        recursive_flag = arg[1].find_first_of(\"r\") != string::npos ? true : false;\r\n        verbose_flag = arg[1].find_first_of(\"v\") != string::npos ? true : false;\r\n        output_pipe = arg[1].find_first_of(\"o\") != string::npos ? true : false;\r\n        benchmark_flag = arg[1].find_first_of(\"m\") != string::npos ? true : false;\r\n        recover_flag = arg[1].find_first_of(\"R\") != string::npos ? true : false;\r\n        force_flag = arg[1].find_first_of(\"f\") != string::npos ? true : false;\r\n        continue_flag = arg[1].find_first_of(\"C\") != string::npos ? true : false;\r\n        cache_flag = arg[1].find_first_of(\"B\") != string::npos ? false : true;\r\n        input_pipe = arg[1].find_first_of(\"i\") != string::npos ? true : false;\r\n        output_pipe = arg[1].find_first_of(\"o\") != string::npos ? true : false;\r\n\r\n#ifdef WINDOWS\r\n        if(int_flag(arg[1], \"P\") != -1)\r\n        {\r\n            switch(int_flag(arg[1], \"P\"))\r\n            {\r\n                case 1:\r\n\t\t\t\t\tif (!SetPriorityClass(GetCurrentProcess(), PROCESS_MODE_BACKGROUND_BEGIN))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tPRINT(WARNING, \"%s%s: -P1 not supported by this OS - using -P2 instead\\n\", BLANK_LINE, \"qpress\");\r\n\t\t\t\t\t\tSetPriorityClass(GetCurrentProcess(), IDLE_PRIORITY_CLASS);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n                case 2: SetPriorityClass(GetCurrentProcess(), IDLE_PRIORITY_CLASS); break;\r\n                case 3: SetPriorityClass(GetCurrentProcess(), NORMAL_PRIORITY_CLASS); break;\r\n                case 4: SetPriorityClass(GetCurrentProcess(), ABOVE_NORMAL_PRIORITY_CLASS); break;\r\n                default: abort(\"Invalid -P flag value\");\r\n            }\r\n        }\r\n\r\n#endif\r\n        if(int_flag(arg[1], \"L\") != -1)\r\n        {\r\n            if (int_flag(arg[1], \"L\") > 0 && int_flag(arg[1], \"L\") < 4)\r\n                if(decompress_flag || recover_flag)\r\n                    abort(\"-d or -R flag cannot be used with -L flag\");\r\n                else\r\n                    compression_level = int_flag(arg[1], \"L\");\r\n            else\r\n                abort(\"Invalid -L flag value\");\r\n        }\r\n\r\n        if(int_flag(arg[1], \"T\") != -1)\r\n        {\r\n            if (int_flag(arg[1], \"T\") >= 1 && int_flag(arg[1], \"T\") <= MAX_THREAD_COUNT)\r\n                    threads = int_flag(arg[1], \"T\");\r\n            else\r\n                abort(\"Invalid -T flag value\");\r\n        }\r\n\r\n        if(int_flag(arg[1], \"K\") != -1)\r\n        {\r\n            if (1024*int_flag(arg[1], \"K\") >= AIO_MAX_SECTOR_SIZE && 1024*int_flag(arg[1], \"K\") <= MAX_COMPRESS_CHUNK_SIZE)\r\n                if(decompress_flag || benchmark_flag || recover_flag )\r\n                    abort(\"-d, -m or -R flag cannot be used with -K flag\");\r\n                else\r\n                    compress_chunk_size = (1024*int_flag(arg[1], \"K\"));\r\n            else\r\n                abort(\"Invalid -K flag value\");\r\n        }\r\n    }\r\n\r\n    if((decompress_flag && (recursive_flag || benchmark_flag || recover_flag || continue_flag)) ||\r\n       (benchmark_flag && (recursive_flag || verbose_flag || output_pipe || recover_flag || continue_flag)) ||\r\n       (recover_flag && (recursive_flag || continue_flag)))\r\n            abort(\"Flag combination does not make sense\");\r\n}\r\n\r\nvoid print_usage()\r\n{\r\n    string usage =\r\n    \"Compression:\\n\"\r\n    \"    qpress [-rovfCBPLKT] <source file/dir search pattern> <destination file>\\n\"\r\n    \"    qpress -i[ovfBPLKT] <filename to give stdin data> <destination file>\\n\\n\"\r\n    \"Decompression:\\n\"\r\n    \"    qpress -d[ovfBPTn] <source file> <destination directory>\\n\\n\"\r\n    \"Benchmark and recovery:\\n\"\r\n    \"    qpress -m[LT] <source file>\\n\"\r\n    \"    qpress -R <corrupted compressed file> <destination directory>\\n\\n\"\r\n    \"Flags:\\n\"\r\n    \"    -d   Decompress\\n\"\r\n    \"    -Ln  Set compression level to n where n = 1, 2 or 3 (default = 1)\\n\"\r\n    \"    -r   Include sub directories during compression\\n\"\r\n    \"    -v   Show progress information during compression and decompression\\n\"\r\n\t\"    -i   Read from stdin (omit source file or file/dir search pattern)\\n\"\r\n\t\"    -o   Write to stdout (omit destination file or directory)\\n\"\r\n    \"    -f   Overwrite existing files during compression and decompression (default\\n\"\r\n    \"         is to abort)\\n\"\r\n    \"    -C   Continue if a source file cannot be opened during compression (default\\n\"\r\n    \"         is to abort)\\n\"\r\n    \"    -Tn  Use n threads/cores where n = 1 to \" + str(MAX_THREAD_COUNT) + \" (default = \" + str(DEFAULT_THREAD_COUNT) + \"). Be aware of\\n\"\r\n    \"         memory usage with large n\\n\"\r\n    \"    -Kn  Read from disk in n KiB chunks during compression where n = \" + str(AIO_MAX_SECTOR_SIZE >> 10) + \" to\\n\" +\r\n    \"         \" + str(MAX_COMPRESS_CHUNK_SIZE >> 10) + \" (default = \" + str(DEFAULT_COMPRESS_CHUNK_SIZE >> 10) + \"). Be aware of memory usage with large n\\n\"\r\n\t//  \"================================================================================\\n\"\r\n    \"    -B   Windows only: Disable file system caching (FILE_FLAG_NO_BUFFERING) to\\n\"\r\n    \"         prevent cache of other applications from being be flushed. Keep\\n\"\r\n    \"         enabled if files are small and need further processing\\n\"\r\n    \"    -Pn  Windows only: Set CPU and disk I/O priority to n where 1 = BACKGORUND\\n\"\r\n\t\"         (Vista, 7, 2008 only), 2 = IDLE, 3 = NORMAL or 4 = ABOVE (default = 3)\\n\\n\"\r\n    \"Examples of compression:\\n\"\r\n#ifdef WINDOWS\r\n    \"    qpress -rv d:\\\\dir\\\\* database.qp\\n\"\r\n    \"    qpress -vfK4096T2 ../dir/*.xml database.qp 2> log.txt\\n\"\r\n    \"    qpress -ovL3K *.xml > database.qp\\n\"\r\n    \"    type database.xml | qpress -io database.xml > database.qp\\n\"\r\n    \"    type database.xml | qpress -i database.xml database.qp\\n\\n\"\r\n    \"Examples of decompression:\\n\"\r\n    \"    qpress -d database.qp d:\\\\dir\\n\"\r\n    \"    qpress -do database.qp > database.xml\\n\"\r\n    \"    type database.qp | qpress -di .\\n\\n\"\r\n#else\r\n    \"    qpress -v file1.xml file2.xml file3.xml database.qp\\n\"\r\n    \"    qpress -vfK4096T2 *.xml database.qp 2> log.txt\\n\"\r\n    \"    qpress -ovL3K *.xml > database.qp\\n\"\r\n    \"    cat database.xml | qpress -i database.xml database.qp\\n\"\r\n    \"    cat database.xml | qpress -io database.xml > database.qp\\n\\n\"\r\n    \"Examples of decompression:\\n\"\r\n    \"    qpress -d database.qp ./dir\\n\"\r\n    \"    qpress -do database.qp > database.xml\\n\"\r\n    \"    cat database.qp | qpress -di .\\n\\n\"\r\n#endif\r\n    \"Notes:\\n\"\r\n    \"When compressing on *nix with -r flag, file/dir search pattern only filters in\\n\"\r\n\t\"top level directory (directories matching in top level will be included fully).\\n\\n\"\r\n//  \"================================================================================\\n\" // 80 chars of \"=\"\r\n    \"If a compressed file contains multiple files and is decompressed to stdout, all\\n\"\r\n    \"files will be concatenated in a continuous stream.\\n\\n\"\r\n    \"It's recommended to use .qp as filename suffix.\\n\";\r\n    PRINT(FATAL_ERROR, \"qpress 1.1 - Copyright 2006-2010 Lasse Reinhold - www.quicklz.com\\n\");\r\n    PRINT(FATAL_ERROR, \"Using QuickLZ 1.4.1 compression library\\n\");\r\n\r\n\tPRINT(FATAL_ERROR, \"Compiled for: \");\r\n\t#ifdef WINDOWS\r\n\t\tPRINT(FATAL_ERROR, \"[Windows] *nix    \");\r\n\t#else\r\n\t\tPRINT(FATAL_ERROR, \"Windows [*nix]    \");\r\n\t#endif\r\n\r\n\t#ifdef X86X64\r\n\t\tPRINT(FATAL_ERROR, \"[x86/x64] RISC    \");\r\n\t#else\r\n\t\tPRINT(FATAL_ERROR, \"x86/x64 [RISC]    \");\r\n\t#endif\r\n\r\n\tif(sizeof(size_t) == 8)\r\n\t\tPRINT(FATAL_ERROR, \"32-bit [64-bit]\");\r\n\telse\r\n\t\tPRINT(FATAL_ERROR, \"[32-bit] 64-bit\");\r\n\r\n    PRINT(FATAL_ERROR, \"\\n\\n%s\", usage.c_str());\r\n\texit(-1);\r\n}\r\n\r\n\r\n\r\nvoid try_aopen(const char *file, char mode)\r\n{\r\n    if(mode == 'w')\r\n    {\r\n        if (!aopen_write(file))\r\n            abort(\"Error creating destination file '%s' - aborted\", file);\r\n    }\r\n    else\r\n    {\r\n        if (!aopen_read(file))\r\n            abort(\"Error opening source file '%s' - aborted\", file);\r\n    }\r\n}\r\n\r\nvoid mem_init(size_t chunk_size)\r\n{\r\n    for(unsigned int i = 0; i < threads; i++)\r\n    {\r\n        scratch[i] = (char *)malloc(QLZ_SCRATCH_COMPRESS());\r\n        src[i] = (char *)malloc((size_t)chunk_size + QLZ_SIZE_OVERHEAD);\r\n        dst[i] = (char *)malloc((size_t)chunk_size + QLZ_SIZE_OVERHEAD);\r\n        if(dst[i] == 0 || src[i] == 0 || scratch[i] == 0)\r\n            abort(\"Error allocating memory - decrease -T and -K flags\");\r\n    }\r\n}\r\n\r\nvoid *benchmark_compress_thread(void *arg)\r\n{\r\n    unsigned long long y = 0;\r\n    size_t id = (size_t)arg;\r\n    double t = GetTickCount();\r\n\twhile(GetTickCount() == t) {};\r\n    t = GetTickCount();\r\n\r\n\twhile(GetTickCount() - t < BENCHMARK_MILLISECONDS)\r\n    {\r\n        QLZ_COMPRESS(src[id], dst[id], bench_size / threads, compression_level, scratch[id]);\r\n        y += bench_size / threads;\r\n    }\r\n\tt = GetTickCount() - t;\r\n\ty = (unsigned long long)(y / t * 1000. / 1024.);\r\n    return (void *)(size_t)y;\r\n}\r\n\r\nvoid *benchmark_decompress_thread(void *arg)\r\n{\r\n    unsigned long long y = 0;\r\n    size_t id = (size_t)arg;\r\n    double t = GetTickCount();\r\n\twhile(GetTickCount() == t) {};\r\n    t = GetTickCount();\r\n\r\n\twhile(GetTickCount() - t < BENCHMARK_MILLISECONDS)\r\n    {\r\n        QLZ_DECOMPRESS(dst[id], src[id], scratch[id]);\r\n        y += QLZ_SIZE_DECOMPRESSED(dst[id]);\r\n    }\r\n\r\n\tt = GetTickCount() - t;\r\n\ty = (unsigned long long)(y / t * 1000. / 1024.);\r\n    return (void *)(size_t)y;\r\n}\r\n\r\nvoid benchmark(char *source_file)\r\n{\r\n    unsigned long long y = 0, u = 0;\r\n    double speed = 0.0;\r\n    void *status[MAX_THREAD_COUNT];\r\n    pthread_t thread[MAX_THREAD_COUNT];\r\n    FILE *ifile = fopen(source_file, \"rb\");\r\n\r\n\tif((ifile) == 0)\r\n        abort(\"Error opening source file '%s' - aborted\", source_file);\r\n\r\n    fseek(ifile, 0, SEEK_END);\r\n    size_t file_len = ftell(ifile);\r\n    fseek(ifile, 0, SEEK_SET);\r\n\r\n    if(file_len == 0 || file_len > 512*1024*1024)\r\n        abort(\"File too large for benchmark\");\r\n\r\n    if(file_len < 256*1024)\r\n        PRINT(WARNING, \"Note: File size should be at least 256 KiB for accurate results.\\n\");\r\n\r\n    mem_init(file_len / threads);\r\n\r\n    if(src[0] == 0 || dst[0] == 0 || scratch[0] == 0)\r\n        abort(\"Error allocating memory - file too large\");\r\n\r\n    PRINT(FATAL_ERROR, \"Using %d threads/cores (change with -T flag). Please wait...\\n\", threads);\r\n\r\n    for(size_t i = 0; i < threads; i++)\r\n    {\r\n        size_t t = fread(src[i], 1, file_len / threads, ifile);\r\n        if(t != file_len / threads)\r\n            abort(\"Error reading source file '%s'\", source_file);\r\n    }\r\n\r\n    bench_size = file_len;\r\n\r\n\tfor(int j = 0; j < BENCHMARK_BESTOF; j++)\r\n\t{\r\n\t\tdouble tmp_speed = 0.;\r\n\t\tfor(size_t i = 0; i < threads; i++)\r\n\t\t\tpthread_create(&thread[i], NULL, benchmark_compress_thread, (void*)i);\r\n\t\ty = 0;\r\n\t\tu = 0;\r\n\t\tfor(size_t i = 0; i < threads; i++)\r\n\t\t{\r\n\t\t\tpthread_join(thread[i], &status[i]);\r\n\t\t\ty += (size_t)status[i];\r\n\t\t\tu += QLZ_SIZE_COMPRESSED(dst[i]);\r\n\t\t}\r\n\t\ttmp_speed = (double)y / 1024.;\r\n\t\tif (tmp_speed > speed)\r\n\t\t\tspeed = tmp_speed;\r\n\t}\r\n\r\n\tPRINT(FATAL_ERROR, \"Compressed %s bytes into %s (%.1f%%) at %.1f MiB/s\\n\", delimiter(file_len).c_str(), delimiter(u).c_str(), (double)u/(double)file_len*100., speed);\r\n\r\n\tfor(int j = 0; j < BENCHMARK_BESTOF; j++)\r\n\t{\r\n\t\tdouble tmp_speed = 0.;\r\n\t\tfor(size_t i = 0; i < threads; i++)\r\n\t\t\tpthread_create(&thread[i], NULL, benchmark_decompress_thread, (void*)i);\r\n\t\ty = 0;\r\n\t\tfor(size_t i = 0; i < threads; i++)\r\n\t\t{\r\n\t\t\tpthread_join(thread[i], &status[i]);\r\n\t\t\ty += (size_t)status[i];\r\n\t\t}\r\n\t\ttmp_speed = (double)y / 1024.;\r\n\t\tif (tmp_speed > speed)\r\n\t\t\tspeed = tmp_speed;\r\n\t}\r\n\r\n\tPRINT(FATAL_ERROR, \"Decompressed at %.1f MiB/s\\n\", speed);\r\n}\r\n\r\nvoid update_statusbar(string description, bool force_update)\r\n{\r\n    static unsigned int last_tick = 0, last_speed_tick = 0, speed = 0;\r\n    static long long last_payload_counter_mbs = 0;\r\n    static pthread_mutex_t mu = PTHREAD_MUTEX_INITIALIZER;\r\n    unsigned int t = GetTickCount() - last_tick;\r\n    unsigned int s = GetTickCount() - last_speed_tick;\r\n\r\n    pthread_mutex_lock(&mu);\r\n\r\n    if (s > 3000)\r\n    {\r\n        // update speed each 3'rd second\r\n        speed = (unsigned int)((payload_counter - last_payload_counter_mbs) / (s == 0 ? 1 : s));\r\n        last_payload_counter_mbs = payload_counter;\r\n        last_speed_tick = GetTickCount();\r\n    }\r\n\r\n    if (force_update || t > 400)\r\n    {\r\n        // draw status bar each 0.4 second\r\n        last_tick = GetTickCount();\r\n        if(description == \"c\")\r\n            PRINT(COUNTER_UPDATE, \"%s    Compressed %s MiB (%d MiB/s) into %s MiB\\r\", BLANK_LINE, delimiter(payload_counter >> 20).c_str(), speed >> 10, delimiter(awritten() >> 20).c_str());\r\n        else\r\n            PRINT(COUNTER_UPDATE, \"%s    Wrote %s MiB (%d MiB/s)\\r\", BLANK_LINE, delimiter(payload_counter >> 20).c_str(), speed >> 10);\r\n    }\r\n\r\n    pthread_mutex_unlock(&mu);\r\n}\r\n\r\nvoid recover(void)\r\n{\r\n    if(recover_flag)\r\n    {\r\n        char search[9] = {0, 0, 0, 0, 0, 0, 0, 0, 0};\r\n        unsigned long long p;\r\n        do\r\n        {\r\n            memmove(search, search + 1, 8);\r\n            size_t y = aread(search + 8, 1);\r\n            if (y == 0)\r\n            {\r\n                aclose_write();\r\n                abort(\"Unexpected end of source file - destination data and/or files missing\");\r\n            }\r\n        } while (strncmp(search + 1, \"NEWBNEWB\", 8) != 0);\r\n\r\n        p = fread64(); // read pos\r\n        if(p - recovery_file_written < 1024*1024*1024) // improbable chunksize, probably overwrap\r\n        {\r\n            for(unsigned long long g = 0; g < p - recovery_file_written; g++)\r\n                try_awrite(\"!\", 1);\r\n            PRINT(WARNING, \"%s%s bytes at offset %s bad - replaced with '!'\\n\\n\", BLANK_LINE, delimiter(p - recovery_file_written).c_str(), delimiter(recovery_file_written).c_str());\r\n            recovery_bad_bytes += (p - recovery_file_written);\r\n            recovery_file_written = p;\r\n        }\r\n        else\r\n        {\r\n            PRINT(WARNING, \"%sData from other files may be appended to this file\\n\\n\", BLANK_LINE);\r\n            recovery_file_written = p; // ?  todo\r\n        }\r\n    }\r\n    else\r\n        abort(\"Source file is corrupted - try the -R flag to recover\");\r\n}\r\n\r\nvoid *decompress_file_thread(void *arg)\r\n{\r\n    size_t thread_id = (size_t)arg;\r\n    bool just_recovered_block = false;\r\n    recovery_file_written = 0;\r\n\r\n    update_statusbar(\"d\", true);\r\n\r\n    for(;;)\r\n    {\r\n        unsigned long long my_chunk;\r\n        unsigned int crc_r, crc_original;\r\n        size_t decomp_size;\r\n\r\n        pthread_mutex_lock(&disk_read_mutex);\r\n        update_statusbar(\"d\", false);\r\n\r\n        if (end_of_file)\r\n        {\r\n            pthread_mutex_unlock(&disk_read_mutex);\r\n            break;\r\n        }\r\n\r\n        if(!just_recovered_block)\r\n        {\r\n            // read NEWBNEWB or ENDSENDS\r\n            try_aread(src[thread_id], 1);\r\n            try_aread(tmp, 7);\r\n        }\r\n\r\n        if (*src[thread_id] == 'N') // NEWBNEWB\r\n        {\r\n            fread64(); // reset pos\r\n        }\r\n        else if(*src[thread_id] == 'E') // ENDSENDS\r\n        {\r\n            end_of_file = true;\r\n            try_aread(tmp, 8); // reset pos\r\n            files++;\r\n            pthread_mutex_unlock(&disk_read_mutex);\r\n            break;\r\n        }\r\n        else if(just_recovered_block)\r\n            just_recovered_block = false;\r\n        else\r\n            abort(\"Data error, not recoverable\"); // todo, it is recoverable, but code is not implemented yet\r\n\r\n        crc_original = fread32();\r\n        try_aread(src[thread_id], 9);\r\n        if (QLZ_SIZE_COMPRESSED(src[thread_id]) > compress_chunk_size + QLZ_SIZE_OVERHEAD)\r\n            abort(\"Data error, not recoverable\"); // todo, it is recoverable, but code is not implemented yet\r\n\r\n        try_aread(src[thread_id] + 9, QLZ_SIZE_COMPRESSED(src[thread_id]) - 9);\r\n\r\n        my_chunk = chunks_read;\r\n        chunks_read++;\r\n        pthread_mutex_unlock(&disk_read_mutex);\r\n\r\n        crc_r = adler((unsigned char *)src[thread_id], QLZ_SIZE_COMPRESSED(src[thread_id]), 0x00010000);\r\n        if (crc_r != crc_original)\r\n        {\r\n            just_recovered_block = true;\r\n            recover();\r\n        }\r\n        decomp_size = QLZ_DECOMPRESS(src[thread_id], dst[thread_id], scratch[thread_id]);\r\n\r\n        // Could be beautified into not using yield. Schedules writes to occur in correct order.\r\n        for(;;)\r\n        {\r\n            pthread_mutex_lock(&disk_write_mutex);\r\n            if(my_chunk == chunks_written)\r\n                break;\r\n            else\r\n            {\r\n                pthread_mutex_unlock(&disk_write_mutex);\r\n                utils_yield();\r\n            }\r\n        }\r\n        chunks_written++;\r\n        if(!just_recovered_block)\r\n        {\r\n            payload_counter += decomp_size;\r\n            recovery_file_written += decomp_size;\r\n            try_awrite(dst[thread_id], decomp_size);\r\n        }\r\n        pthread_mutex_unlock(&disk_write_mutex);\r\n    }\r\n    return 0;\r\n}\r\n\r\n\r\nvoid decompress_file(string dest_file)\r\n{\r\n    pthread_t thread[MAX_THREAD_COUNT];\r\n    size_t i;\r\n    end_of_file = false;\r\n    chunks_read = 0;\r\n    chunks_written = 0;\r\n    void *status;\r\n\r\n\ttry_aopen(dest_file.c_str(), 'w');\r\n\r\n    for(i = 0; i < threads; i++)\r\n    {\r\n        pthread_create(&thread[i], NULL, decompress_file_thread, (void *)i);\r\n    }\r\n\r\n    for(i = 0; i < threads; i++)\r\n    {\r\n        pthread_join(thread[i], &status);\r\n    }\r\n\r\n\tif(dest_file != \"<stdout>\")\r\n\t\taclose_write();\r\n}\r\n\r\nvoid *compress_file_thread(void *arg)\r\n{\r\n    size_t read;\r\n    do\r\n    {\r\n        size_t u, thread_id = (size_t)arg;\r\n        unsigned int crc_r;\r\n        unsigned long long my_chunk;\r\n\r\n        update_statusbar(\"c\", false);\r\n\r\n        pthread_mutex_lock(&disk_write_mutex);\r\n        my_chunk = chunks_read;\r\n        chunks_read++;\r\n\r\n        pthread_mutex_lock(&disk_read_mutex);\r\n        pthread_mutex_unlock(&disk_write_mutex);\r\n        read = aread(src[thread_id], compress_chunk_size);\r\n        pthread_mutex_unlock(&disk_read_mutex);\r\n\r\n        if (read == 0)\r\n            return 0;\r\n\r\n        u = QLZ_COMPRESS(src[thread_id], dst[thread_id], read, compression_level, scratch[thread_id]);\r\n        crc_r = adler((unsigned char *)dst[thread_id], u, 0x00010000);\r\n\r\n        // Could be beautified into not using yield. Schedules writes to occur in correct order.\r\n        for(;;)\r\n        {\r\n            pthread_mutex_lock(&disk_write_mutex);\r\n            if(my_chunk == chunks_written)\r\n                break;\r\n            else\r\n            {\r\n                pthread_mutex_unlock(&disk_write_mutex);\r\n                utils_yield();\r\n            }\r\n        }\r\n\r\n        try_awrite(\"NEWBNEWB\", 8);\r\n        fwrite64(current_file_payload);\r\n        payload_counter += read;\r\n        current_file_payload += read;\r\n        fwrite32(crc_r);\r\n        chunks_written++;\r\n        try_awrite(dst[thread_id], u);\r\n        pthread_mutex_unlock(&disk_write_mutex);\r\n    } while (read == compress_chunk_size);\r\n\r\n    return 0;\r\n}\r\n\r\nvoid compress_file(string input_file, string filename)\r\n{\r\n    pthread_t thread[MAX_THREAD_COUNT];\r\n    unsigned long long bytes_written = 0;\r\n    void *status;\r\n\r\n\tif(aopen_read(input_file.c_str()))\r\n\t{\r\n\t\tPRINT(FILES_PROCESSED, \"%s    %s\\n\", BLANK_LINE, filename.c_str());\r\n\t\tupdate_statusbar(\"c\", true);\r\n\t\ttry_awrite(\"F\", 1);\r\n\t\tfwrite32((unsigned int)filename.length());\r\n\t\ttry_awrite(filename.c_str(), filename.length());\r\n\t\ttry_awrite(\"\\0\", 1);\r\n\r\n\t\tfiles++;\r\n\t\tchunks_read = 0;\r\n\t\tchunks_written = 0;\r\n\t\tcurrent_file_payload = 0;\r\n\r\n\t\tfor(size_t i = 0; i < threads; i++)\r\n\t\t\tpthread_create(&thread[i], NULL, compress_file_thread, (void*)i);\r\n\r\n\t\tfor(size_t i = 0; i < threads; i++)\r\n\t\t\tpthread_join(thread[i], &status);\r\n\r\n\t\ttry_awrite(\"ENDSENDS\", 8);\r\n\t\tfwrite64(bytes_written);\r\n\t\taclose_read(); // closes input_file\r\n\t}\r\n\telse if (continue_flag && input_file != \"<stdin>\")\r\n\t\tPRINT(WARNING, \"%s%s: Error opening source file '%s' - skipped\\n\", BLANK_LINE, \"qpress\", input_file.c_str());\r\n\telse\r\n\t\tabort(\"Error opening source file '%s' - aborted\", input_file.c_str());\r\n}\r\n\r\nstring void2curdir(string path)\r\n{\r\n\treturn path == \"\" ? CURDIR : path;\r\n}\r\n\r\nvoid godown(const char *dir)\r\n{\r\n\tsize_t chunk_size = strlen(dir);\r\n\ttry_awrite(\"D\", 1);\r\n\tfwrite32((unsigned int)chunk_size);\r\n\ttry_awrite(dir, strlen(dir));\r\n\ttry_awrite(\"\\0\", 1);\r\n}\r\n\r\nvoid goup(void)\r\n{\r\n\ttry_awrite(\"U\", 1);\r\n}\r\n\r\n\r\nstring remove_curdir(string dir)\r\n{\r\n\tif(dir.length() >= 2 && dir.substr(0, 2) == CURDIR)\r\n\t\treturn dir.substr(2, dir.length() - 2);\r\n\telse\r\n\t\treturn dir;\r\n}\r\n\r\nvoid compress_directory(string base_dir, string pattern)\r\n{\r\n    string path;\r\n    struct dirent *entry;\r\n\tDIR *dir;\r\n\r\n\tbase_dir = remove_curdir(base_dir);\r\n\r\n\tstring api_path = (base_dir == \"\" ? \"\" : remove_delimitor(base_dir) + DELIM_STR);\r\n\r\n\tif(base_dir != \"\")\r\n\t\tPRINT(FILES_PROCESSED, \"%s%s%s\\n\", BLANK_LINE, base_dir.c_str(), DELIM_STR);\r\n\r\n\t// process files\r\n\tif((dir = opendir(void2curdir(api_path).c_str())))\r\n\t{\r\n#ifdef WINDOWS\r\n        while((entry = readdir_wildcard(dir, (char *)pattern.c_str())))\r\n#else\r\n        while((entry = readdir(dir)))\r\n#endif\r\n\t\t{\r\n\t\t\tif(string(entry->d_name) != \".\" && string(entry->d_name) != \"..\")\r\n\t\t\t{\r\n\t\t\t\tpath = api_path + string(entry->d_name);\r\n\t\t\t\tif (!is_dir(path))\r\n\t\t\t\t{\r\n\t\t\t\t\t// we must avoid including destination file when compressing. Note that *nix is case sensitive.\r\n\t\t\t\t\tabsolute_path((char *)path.c_str(), tmp);\r\n#ifdef WINDOWS\r\n\t\t\t\t\tif(lcase(string(tmp)) != lcase(destination_file))\r\n#else\r\n\t\t\t\t\tif(string(tmp) != destination_file)\r\n#endif\r\n\t\t\t\t\t\tcompress_file(path, string(entry->d_name));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t    closedir(dir);\r\n\t}\r\n\r\n\r\n\r\n\t// process directories\r\n    if(recursive_flag && (dir = opendir(void2curdir(api_path).c_str())))\r\n\t{\r\n#ifdef WINDOWS\r\n        while((entry = readdir_wildcard(dir, \"*\")))\r\n#else\r\n        while((entry = readdir(dir)))\r\n#endif\r\n\t\t{\r\n\t\t\tpath = api_path + string(entry->d_name);\r\n\r\n\t\t\tif(is_dir(path) && string(entry->d_name) != \".\" && string(entry->d_name) != \"..\")\r\n\t\t\t{\r\n\t\t\t\tgodown(entry->d_name);\r\n\t\t\t\tcompress_directory(path, pattern);\r\n\t\t\t\tgoup();\r\n\t\t\t}\r\n\t\t}\r\n\t\tclosedir(dir);\r\n\t}\r\n }\r\n\r\nbool check_if_path_has_dir_traversal(char * new_path)\r\n{\r\n    bool ret_val = false;\r\n    char *found_template1 = NULL;\r\n\tfound_template1 = strstr (new_path,\"../\");\r\n\t#ifdef WINDOWS \r\n\t    char *found_template2 = NULL;\r\n\t    found_template2 = strstr (new_path,\"..\\\\\");\r\n\t    ret_val = (found_template1 !=  NULL) || (found_template2 != NULL);\r\n\t#else\r\n\t    ret_val = found_template1 !=  NULL;\r\n\t#endif\r\n    \r\n    return ret_val;\r\n}\r\n\r\nvoid decompress_directory(string extract_dir, bool std_out)\r\n{\r\n    char c;\r\n    string curdir;\r\n    size_t r = 0;\r\n    unsigned int chunk_size;\r\n\r\n    curdir = string(extract_dir);\r\n\r\n    for(;;)\r\n    {\r\n        r = aread(&c, 1);\r\n        if (r == 0)\r\n            return;\r\n\r\n        if(c == 'D')\r\n        {\r\n\t\t\t// read directory name, append it to current path and create the directory\r\n            chunk_size = fread32();\r\n\t\t\tif(NAME_BUFFER_SIZE < chunk_size + 1)\r\n            {\r\n                abort(\"File path string is bigger than buffer size\");\r\n            }\r\n            try_aread(tmp, chunk_size + 1);\r\n            curdir = curdir + DELIM_STR + tmp;\r\n            PRINT(FILES_PROCESSED, \"%s%s%s\\n\", BLANK_LINE, remove_leading_curdir(curdir).c_str(), DELIM_STR);\r\n\t\t\t/* RDS security fix: https://rds-jira.amazon.com/browse/MMCP-231\r\n\t \t\tNeed to check if we try to decompress file or directory outside working directory\r\n\t \t\t*/\r\n\t        if(true == check_if_path_has_dir_traversal(tmp)) \r\n            {\r\n\t            abort(\"Directory path contains directory traversal which is not allowed.\");\r\n\t        }\r\n\t        /* End of RDS security fix*/\r\n            if(!std_out)\r\n            {\r\n#ifdef WINDOWS\r\n                CreateDirectory(curdir.c_str(), 0);\r\n#else\r\n                mkdir(curdir.c_str(), 509);\r\n#endif\r\n            }\r\n        }\r\n        else if(c == 'U')\r\n            curdir = curdir.substr(0, curdir.find_last_of(DELIM_STR)); // remove last sub dir from current path\r\n        else if(c == 'F')\r\n        {\r\n            chunk_size = fread32(); // read length of file name\r\n            if(NAME_BUFFER_SIZE < chunk_size + 1)\r\n\t             {\r\n\t                 abort(\"File path string is bigger than buffer size\");\r\n\t             }\r\n\t             try_aread(tmp, chunk_size + 1); // read file name to 'tmp' with size 'chunk_size + 1'\r\n\t         /* RDS security fix: https://rds-jira.amazon.com/browse/MMCP-231\r\n\t \t\t   Need to check if we try to decompress file or directory outside working directory\r\n\t \t\t*/\r\n\t         if(true == check_if_path_has_dir_traversal(tmp)) \r\n\t         {\r\n\t             abort(\"File path contains directory traversal which is not allowed.\");\r\n\t         }\r\n\t         /* End of RDS security fix*/\r\n            string buf2 = curdir + DELIM_STR + tmp;\r\n            PRINT(FILES_PROCESSED, \"%s    %s\\n\", BLANK_LINE, tmp);\r\n            if(!std_out)\r\n            {\r\n                if(exists(buf2) && !force_flag)\r\n                    abort(\"Destination file '%s' already exists - aborted\", buf2.c_str());\r\n                else\r\n                    decompress_file(buf2);\r\n            }\r\n            else\r\n                decompress_file(\"<stdout>\");\r\n        }\r\n        else\r\n            abort(\"Source file is corrupted - try the -R flag to recover\");\r\n    }\r\n}\r\n\r\nstring filenamepart(string filenamepath)\r\n{\r\n    size_t r = filenamepath.find_last_of(\"/\\\\\");\r\n    if(r == string::npos)\r\n        return filenamepath;\r\n    else\r\n        return filenamepath.substr(r + 1);\r\n}\r\n\r\n\r\nsearch_type split(string source)\r\n{\r\n    search_type ret;\r\n\r\n\tif(is_dir(source))\r\n\t{\r\n\t\tret.path = source;\r\n\t\tret.pattern = \"\";\r\n\t\treturn ret;\r\n\t}\r\n\r\n\tsource = remove_leading_curdir(source);\r\n\r\n    size_t r = source.find_last_of(\"/\\\\\");\r\n\r\n    if(r == string::npos)\r\n    {\r\n\t\tret.path = \"\";\r\n\t\tret.pattern = source;\r\n\t\treturn ret;\r\n\t}\r\n\telse\r\n\t{\r\n\t\t/* .\\dir\\*.hej?j */\r\n\t\tret.path = source.substr(0, r);\r\n\t\tret.pattern = source.substr(r + 1);\r\n\t\treturn ret;\r\n\t}\r\n}\r\n\r\nint main(int argc, char* argv[])\r\n{\r\n    string *arg = new string[argc];\r\n    for(int i = 0; i < argc; i++)\r\n        arg[i] = argv[i];\r\n\r\n    parse_flags(argc, argv);\r\n\r\n    tty_stderr = isatty(fileno(stderr));\r\n\r\n\r\n\r\n#ifdef WINDOWS\r\n    setmode(fileno(stdin), _O_BINARY);\r\n    setmode(fileno(stdout), _O_BINARY);\r\n    pthread_win32_process_attach_np ();\r\n#endif\r\n\r\n// In-memory benchmark\r\n// =================================================================================================\r\n    if (benchmark_flag && (!input_pipe) && argc == 3)\r\n    {\r\n        benchmark(argv[2]);\r\n    }\r\n\r\n// Decompress and Recover\r\n// =================================================================================================\r\n    else if ((decompress_flag || recover_flag) && argc == 2 + (!input_pipe) + (1 - output_pipe))\r\n    {\r\n        if(recover_flag)\r\n            threads = 1;\r\n\r\n        aio_init(compress_chunk_size + QLZ_SIZE_OVERHEAD, cache_flag);\r\n        if(!input_pipe)\r\n        {\r\n            try_aopen(arg[2].c_str(), 'r');\r\n            aread(tmp, 8);\r\n            compress_chunk_size = fread64();\r\n            aclose_read();\r\n            aio_init(compress_chunk_size + QLZ_SIZE_OVERHEAD, cache_flag);\r\n            try_aopen(arg[2].c_str(), 'r');\r\n            aread(tmp, 16);\r\n        }\r\n        else\r\n        {\r\n            try_aopen(\"<stdin>\", 'r');\r\n            aread(tmp, 8);\r\n            compress_chunk_size = fread64();\r\n            aio_init(compress_chunk_size + QLZ_SIZE_OVERHEAD, cache_flag);\r\n        }\r\n\r\n        if(strncmp(tmp, \"qpress\", 6) != 0)\r\n            abort(\"Source file was not compressed with qpress\");\r\n\r\n        if(tmp[6] != '1')\r\n            abort(\"Version %d.x.x is required to decompress this file\", tmp[6] - 48);\r\n\r\n        if(compress_chunk_size > 512*1024*1024)\r\n            abort(\"Source file is corrupted - try the -R flag to recover\");\r\n\r\n        mem_init(compress_chunk_size);\r\n\r\n        if(output_pipe)\r\n            decompress_directory(\"\", true);\r\n        else\r\n        {\r\n            string s = remove_delimitor(arg[2 + (!input_pipe)]);\r\n            decompress_directory(s, false);\r\n        }\r\n\r\n        aclose_read();\r\n        if(recover_flag)\r\n        {\r\n            PRINT(RESULT, \"%sWrote %s bytes in %s file(s) of which %s bytes are bad\\n\", BLANK_LINE, delimiter(payload_counter + recovery_bad_bytes).c_str(), delimiter(files).c_str(), delimiter(recovery_bad_bytes).c_str());\r\n            PRINT(RESULT, \"\\nNote: There may be more errors than listed. Files may be missing or placed\\nin wrong directories and files may contain fragments of other files.\");\r\n        }\r\n        else\r\n            PRINT(RESULT, \"%sWrote %s bytes in %s file(s).\", BLANK_LINE, delimiter(payload_counter).c_str(), delimiter(files).c_str());\r\n    }\r\n\r\n// Compress\r\n// =================================================================================================\r\n    else if(!decompress_flag && argc >= 2 + flags_exist + (1 - output_pipe))\r\n    {\r\n        string output_file;\r\n\r\n        mem_init(compress_chunk_size);\r\n        aio_init(compress_chunk_size + QLZ_SIZE_OVERHEAD, cache_flag);\r\n\r\n        if(output_pipe)\r\n            try_aopen(\"<stdout>\", 'w');\r\n        else\r\n        {\r\n\t\t\toutput_file = arg[argc - 1];\r\n            if(exists(output_file) && !force_flag)\r\n                abort(\"Destination file '%s' already exists\", output_file.c_str());\r\n\r\n            try_aopen(output_file.c_str(), 'w');\r\n        }\r\n\r\n        try_awrite(\"qpress10\", 8);\r\n\t\tfwrite64(compress_chunk_size);\r\n\r\n        if(!input_pipe)\r\n        {\r\n\t\t\tabsolute_path((char *)output_file.c_str(), tmp);\r\n\t\t\tdestination_file = string(tmp);\r\n#ifdef WINDOWS\r\n\t\t\tif(split(arg[1 + flags_exist]).pattern != \"\")\r\n\t\t\t\tcompress_directory(split(arg[1 + flags_exist]).path, split(arg[1 + flags_exist]).pattern);\r\n#else\r\n\t\t\tfor(int i = 1 + flags_exist; i < argc - ((!output_pipe) == true ? 1 : 0); i++)\r\n\t\t\t{\r\n\t\t\t\tif (!is_dir(arg[i]))\r\n\t\t\t\t\tcompress_file(arg[i], filenamepart(arg[i]));\r\n\t\t\t}\r\n\r\n\t\t\tif(recursive_flag)\r\n\t\t\t{\r\n\t\t\t\tfor(int i = 1 + flags_exist; i < argc - ((!output_pipe)== true ? 1 : 0); i++)\r\n\t\t\t\t{\r\n\t\t\t\t\tif(is_dir(arg[i]))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\targ[i] = remove_delimitor(arg[i]);\r\n\t\t\t\t\t\tif(filenamepart(arg[i]) == \".\" || filenamepart(arg[i]) == \"..\")\r\n\t\t\t\t\t\t\tcompress_directory(arg[i], \"*\");\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tgodown(filenamepart(arg[i]).c_str());\r\n\t\t\t\t\t\t\tcompress_directory(arg[i], \"*\");\r\n\t\t\t\t\t\t\tgoup();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n#endif\r\n        }\r\n        else\r\n        {\r\n            compress_file(\"<stdin>\", arg[1 + flags_exist]);\r\n        }\r\n\r\n\t\tif(files == 0)\r\n\t\t\tabort(\"0 files found. Are you missing a search pattern such as '*'?\");\r\n\t\telse\r\n\t\t{\r\n\t        PRINT(RESULT, \"%sCompressed %s bytes in %s file(s) into %s bytes\", BLANK_LINE, delimiter(payload_counter).c_str(), delimiter(files).c_str(), delimiter(awritten()).c_str());\r\n\t\t    aclose_write();\r\n\t\t}\r\n    }\r\n    else\r\n        print_usage();\r\n\r\n    PRINT(RESULT, \"\\n\");\r\n}\r\n\r\n"], "filenames": ["qpress.cpp"], "buggy_code_start_loc": [186], "buggy_code_end_loc": [976], "fixing_code_start_loc": [186], "fixing_code_end_loc": [1017], "type": "CWE-22", "message": "qpress before PierreLvx/qpress 20220819 and before version 11.3, as used in Percona XtraBackup and other products, allows directory traversal via ../ in a .qp file.", "other": {"cve": {"id": "CVE-2022-45866", "sourceIdentifier": "cve@mitre.org", "published": "2022-11-23T20:15:10.380", "lastModified": "2023-02-01T15:59:56.603", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "qpress before PierreLvx/qpress 20220819 and before version 11.3, as used in Percona XtraBackup and other products, allows directory traversal via ../ in a .qp file."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:qpress_project:qpress:*:*:*:*:*:*:*:*", "versionEndExcluding": "11.3", "matchCriteriaId": "841A0F47-DE8B-4FC7-BF54-3F5962B84F6F"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:37:*:*:*:*:*:*:*", "matchCriteriaId": "E30D0E6F-4AE8-4284-8716-991DFA48CC5D"}]}]}], "references": [{"url": "https://github.com/EvgeniyPatlan/qpress/commit/ddb312090ebd5794e81bc6fb1dfb4e79eda48761", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/PierreLvx/qpress/compare/20170415...20220819", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/PierreLvx/qpress/pull/6", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/percona/percona-xtrabackup/pull/1366", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/BQWF7635AJSDKEIGLB73XAH643POGTFY/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/G4RXO3VYIFRTNIFHWIAZWND6ZXQ5OYOB/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/UUZ73XT2FXLHC7I4ODLOVB4O4QN7Q7JB/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://pkgs.org/download/qpress", "source": "cve@mitre.org", "tags": ["Product"]}]}, "github_commit_url": "https://github.com/EvgeniyPatlan/qpress/commit/ddb312090ebd5794e81bc6fb1dfb4e79eda48761"}}