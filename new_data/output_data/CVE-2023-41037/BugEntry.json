{"buggy_code": ["// GPG4Browsers - An OpenPGP implementation in javascript\n// Copyright (C) 2011 Recurity Labs GmbH\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 3.0 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n\nimport { armor, unarmor } from './encoding/armor';\nimport enums from './enums';\nimport util from './util';\nimport { PacketList, LiteralDataPacket, SignaturePacket } from './packet';\nimport { Signature } from './signature';\nimport { createVerificationObjects, createSignaturePackets } from './message';\nimport defaultConfig from './config';\n\n// A Cleartext message can contain the following packets\nconst allowedPackets = /*#__PURE__*/ util.constructAllowedPackets([SignaturePacket]);\n\n/**\n * Class that represents an OpenPGP cleartext signed message.\n * See {@link https://tools.ietf.org/html/rfc4880#section-7}\n */\nexport class CleartextMessage {\n  /**\n   * @param {String} text - The cleartext of the signed message\n   * @param {Signature} signature - The detached signature or an empty signature for unsigned messages\n   */\n  constructor(text, signature) {\n    // remove trailing whitespace and normalize EOL to canonical form <CR><LF>\n    this.text = util.removeTrailingSpaces(text).replace(/\\r?\\n/g, '\\r\\n');\n    if (signature && !(signature instanceof Signature)) {\n      throw new Error('Invalid signature input');\n    }\n    this.signature = signature || new Signature(new PacketList());\n  }\n\n  /**\n   * Returns the key IDs of the keys that signed the cleartext message\n   * @returns {Array<module:type/keyid~KeyID>} Array of keyID objects.\n   */\n  getSigningKeyIDs() {\n    const keyIDs = [];\n    const signatureList = this.signature.packets;\n    signatureList.forEach(function(packet) {\n      keyIDs.push(packet.issuerKeyID);\n    });\n    return keyIDs;\n  }\n\n  /**\n   * Sign the cleartext message\n   * @param {Array<Key>} privateKeys - private keys with decrypted secret key data for signing\n   * @param {Signature} [signature] - Any existing detached signature\n   * @param {Array<module:type/keyid~KeyID>} [signingKeyIDs] - Array of key IDs to use for signing. Each signingKeyIDs[i] corresponds to privateKeys[i]\n   * @param {Date} [date] - The creation time of the signature that should be created\n   * @param {Array} [userIDs] - User IDs to sign with, e.g. [{ name:'Steve Sender', email:'steve@openpgp.org' }]\n   * @param {Array} [notations] - Notation Data to add to the signatures, e.g. [{ name: 'test@example.org', value: new TextEncoder().encode('test'), humanReadable: true, critical: false }]\n   * @param {Object} [config] - Full configuration, defaults to openpgp.config\n   * @returns {Promise<CleartextMessage>} New cleartext message with signed content.\n   * @async\n   */\n  async sign(privateKeys, signature = null, signingKeyIDs = [], date = new Date(), userIDs = [], notations = [], config = defaultConfig) {\n    const literalDataPacket = new LiteralDataPacket();\n    literalDataPacket.setText(this.text);\n    const newSignature = new Signature(await createSignaturePackets(literalDataPacket, privateKeys, signature, signingKeyIDs, date, userIDs, notations, true, config));\n    return new CleartextMessage(this.text, newSignature);\n  }\n\n  /**\n   * Verify signatures of cleartext signed message\n   * @param {Array<Key>} keys - Array of keys to verify signatures\n   * @param {Date} [date] - Verify the signature against the given date, i.e. check signature creation time < date < expiration time\n   * @param {Object} [config] - Full configuration, defaults to openpgp.config\n   * @returns {Promise<Array<{\n   *   keyID: module:type/keyid~KeyID,\n   *   signature: Promise<Signature>,\n   *   verified: Promise<true>\n   * }>>} List of signer's keyID and validity of signature.\n   * @async\n   */\n  verify(keys, date = new Date(), config = defaultConfig) {\n    const signatureList = this.signature.packets.filterByTag(enums.packet.signature); // drop UnparsablePackets\n    const literalDataPacket = new LiteralDataPacket();\n    // we assume that cleartext signature is generated based on UTF8 cleartext\n    literalDataPacket.setText(this.text);\n    return createVerificationObjects(signatureList, [literalDataPacket], keys, date, true, config);\n  }\n\n  /**\n   * Get cleartext\n   * @returns {String} Cleartext of message.\n   */\n  getText() {\n    // normalize end of line to \\n\n    return this.text.replace(/\\r\\n/g, '\\n');\n  }\n\n  /**\n   * Returns ASCII armored text of cleartext signed message\n   * @param {Object} [config] - Full configuration, defaults to openpgp.config\n   * @returns {String | ReadableStream<String>} ASCII armor.\n   */\n  armor(config = defaultConfig) {\n    let hashes = this.signature.packets.map(function(packet) {\n      return enums.read(enums.hash, packet.hashAlgorithm).toUpperCase();\n    });\n    hashes = hashes.filter(function(item, i, ar) { return ar.indexOf(item) === i; });\n    const body = {\n      hash: hashes.join(),\n      text: this.text,\n      data: this.signature.packets.write()\n    };\n    return armor(enums.armor.signed, body, undefined, undefined, undefined, config);\n  }\n}\n\n/**\n * Reads an OpenPGP cleartext signed message and returns a CleartextMessage object\n * @param {Object} options\n * @param {String} options.cleartextMessage - Text to be parsed\n * @param {Object} [options.config] - Custom configuration settings to overwrite those in [config]{@link module:config}\n * @returns {Promise<CleartextMessage>} New cleartext message object.\n * @async\n * @static\n */\nexport async function readCleartextMessage({ cleartextMessage, config, ...rest }) {\n  config = { ...defaultConfig, ...config };\n  if (!cleartextMessage) {\n    throw new Error('readCleartextMessage: must pass options object containing `cleartextMessage`');\n  }\n  if (!util.isString(cleartextMessage)) {\n    throw new Error('readCleartextMessage: options.cleartextMessage must be a string');\n  }\n  const unknownOptions = Object.keys(rest); if (unknownOptions.length > 0) throw new Error(`Unknown option: ${unknownOptions.join(', ')}`);\n\n  const input = await unarmor(cleartextMessage);\n  if (input.type !== enums.armor.signed) {\n    throw new Error('No cleartext signed message.');\n  }\n  const packetlist = await PacketList.fromBinary(input.data, allowedPackets, config);\n  verifyHeaders(input.headers, packetlist);\n  const signature = new Signature(packetlist);\n  return new CleartextMessage(input.text, signature);\n}\n\n/**\n * Compare hash algorithm specified in the armor header with signatures\n * @param {Array<String>} headers - Armor headers\n * @param {PacketList} packetlist - The packetlist with signature packets\n * @private\n */\nfunction verifyHeaders(headers, packetlist) {\n  const checkHashAlgos = function(hashAlgos) {\n    const check = packet => algo => packet.hashAlgorithm === algo;\n\n    for (let i = 0; i < packetlist.length; i++) {\n      if (packetlist[i].constructor.tag === enums.packet.signature && !hashAlgos.some(check(packetlist[i]))) {\n        return false;\n      }\n    }\n    return true;\n  };\n\n  let oneHeader = null;\n  let hashAlgos = [];\n  headers.forEach(function(header) {\n    oneHeader = header.match(/Hash: (.+)/); // get header value\n    if (oneHeader) {\n      oneHeader = oneHeader[1].replace(/\\s/g, ''); // remove whitespace\n      oneHeader = oneHeader.split(',');\n      oneHeader = oneHeader.map(function(hash) {\n        hash = hash.toLowerCase();\n        try {\n          return enums.write(enums.hash, hash);\n        } catch (e) {\n          throw new Error('Unknown hash algorithm in armor header: ' + hash);\n        }\n      });\n      hashAlgos = hashAlgos.concat(oneHeader);\n    } else {\n      throw new Error('Only \"Hash\" header allowed in cleartext signed message');\n    }\n  });\n\n  if (!hashAlgos.length && !checkHashAlgos([enums.hash.md5])) {\n    throw new Error('If no \"Hash\" header in cleartext signed message, then only MD5 signatures allowed');\n  } else if (hashAlgos.length && !checkHashAlgos(hashAlgos)) {\n    throw new Error('Hash algorithm mismatch in armor header and signature');\n  }\n}\n\n/**\n * Creates a new CleartextMessage object from text\n * @param {Object} options\n * @param {String} options.text\n * @static\n * @async\n */\nexport async function createCleartextMessage({ text, ...rest }) {\n  if (!text) {\n    throw new Error('createCleartextMessage: must pass options object containing `text`');\n  }\n  if (!util.isString(text)) {\n    throw new Error('createCleartextMessage: options.text must be a string');\n  }\n  const unknownOptions = Object.keys(rest); if (unknownOptions.length > 0) throw new Error(`Unknown option: ${unknownOptions.join(', ')}`);\n\n  return new CleartextMessage(text);\n}\n", "/* eslint-disable max-lines */\n/* globals tryTests: true */\nconst stream = require('@openpgp/web-stream-tools');\nconst { use: chaiUse, expect } = require('chai');\nchaiUse(require('chai-as-promised'));\n\nconst openpgp = typeof window !== 'undefined' && window.openpgp ? window.openpgp : require('../..');\n\nconst util = require('../../src/util');\n\nmodule.exports = () => describe('Signature', function() {\n  const priv_key_arm1 =\n    ['-----BEGIN PGP PRIVATE KEY BLOCK-----',\n      'Version: GnuPG v1.4.11 (GNU/Linux)',\n      '',\n      'lQHhBFERnrMRBADmM0hIfkI3yosjgbWo9v0Lnr3CCE+8KsMszgVS+hBu0XfGraKm',\n      'ivcA2aaJimHqVYOP7gEnwFAxHBBpeTJcu5wzCFyJwEYqVeS3nnaIhBPplSF14Duf',\n      'i6bB9RV7KxVAg6aunmM2tAutqC+a0y2rDaf7jkJoZ9gWJe2zI+vraD6fiwCgxvHo',\n      '3IgULB9RqIqpLoMgXfcjC+cD/1jeJlKRm+n71ryYwT/ECKsspFz7S36z6q3XyS8Q',\n      'QfrsUz2p1fbFicvJwIOJ8B20J/N2/nit4P0gBUTUxv3QEa7XCM/56/xrGkyBzscW',\n      'AzBoy/AK9K7GN6z13RozuAS60F1xO7MQc6Yi2VU3eASDQEKiyL/Ubf/s/rkZ+sGj',\n      'yJizBACtwCbQzA+z9XBZNUat5NPgcZz5Qeh1nwF9Nxnr6pyBv7tkrLh/3gxRGHqG',\n      '063dMbUk8pmUcJzBUyRsNiIPDoEUsLjY5zmZZmp/waAhpREsnK29WLCbqLdpUors',\n      'c1JJBsObkA1IM8TZY8YUmvsMEvBLCCanuKpclZZXqeRAeOHJ0v4DAwK8WfuTe5B+',\n      'M2BOOeZbN8BpfiA1l//fMMHLRS3UvbLBv4P1+4SyvhyYTR7M76Q0xPc03MFOWHL+',\n      'S9VumbQWVGVzdDIgPHRlc3QyQHRlc3QuY29tPohiBBMRAgAiBQJREZ6zAhsDBgsJ',\n      'CAcDAgYVCAIJCgsEFgIDAQIeAQIXgAAKCRARJ5QDyxae+MXNAKCzWSDR3tMrTrDb',\n      'TAri73N1Xb3j1ACfSl9y+SAah2q7GvmiR1+6+/ekqJGdAVgEURGesxAEANlpMZjW',\n      '33jMxlKHDdyRFXtKOq8RreXhq00plorHbgz9zFEWm4VF53+E/KGnmHGyY5Cy8TKy',\n      'ZjaueZZ9XuG0huZg5If68irFfNZtxdA26jv8//PdZ0Uj+X6J3RVa2peMLDDswTYL',\n      'OL1ZO1fxdtDD40fdAiIZ1QyjwEG0APtz41EfAAMFBAC5/dtgBBPtHe8UjDBaUe4n',\n      'NzHuUBBp6XE+H7eqHNFCuZAJ7yqJLGVHNIaQR419cNy08/OO/+YUQ7rg78LxjFiv',\n      'CH7IzhfU+6yvELSbgRMicY6EnAP2GT+b1+MtFNa3lBGtBHcJla52c2rTAHthYZWk',\n      'fT5R5DnJuQ2cJHBMS9HWyP4DAwK8WfuTe5B+M2C7a/YJSUv6SexdGCaiaTcAm6g/',\n      'PvA6hw/FLzIEP67QcQSSTmhftQIwnddt4S4MyJJH3U4fJaFfYQ1zCniYJohJBBgR',\n      'AgAJBQJREZ6zAhsMAAoJEBEnlAPLFp74QbMAn3V4857xwnO9/+vzIVnL93W3k0/8',\n      'AKC8omYPPomN1E/UJFfXdLDIMi5LoA==',\n      '=LSrW',\n      '-----END PGP PRIVATE KEY BLOCK-----'].join('\\n');\n\n  const pub_key_arm1 =\n    ['-----BEGIN PGP PUBLIC KEY BLOCK-----',\n      'Version: GnuPG v1.4.11 (GNU/Linux)',\n      '',\n      'mQGiBFERlw4RBAD6Bmcf2w1dtUmtCLkdxeqZLArk3vYoQAjdibxA3gXVyur7fsWb',\n      'ro0jVbBHqOCtC6jDxE2l52NP9+tTlWeVMaqqNvUE47LSaPq2DGI8Wx1Rj6bF3mTs',\n      'obYEwhGbGh/MhJnME9AHODarvk8AZbzo0+k1EwrBWF6dTUBPfqO7rGU2ewCg80WV',\n      'x5pt3evj8rRK3jQ8SMKTNRsD/1PhTdxdZTdXARAFzcW1VaaruWW0Rr1+XHKKwDCz',\n      'i7HE76SO9qjnQfZCZG75CdQxI0h8GFeN3zsDqmhob2iSz2aJ1krtjM+iZ1FBFd57',\n      'OqCV6wmk5IT0RBN12ZzMS19YvzN/ONXHrmTZlKExd9Mh9RKLeVNw+bf6JsKQEzcY',\n      'JzFkBACX9X+hDYchO/2hiTwx4iOO9Fhsuh7eIWumB3gt+aUpm1jrSbas/QLTymmk',\n      'uZuQVXI4NtnlvzlNgWv4L5s5RU5WqNGG7WSaKNdcrvJZRC2dgbUJt04J5CKrWp6R',\n      'aIYal/81Ut1778lU01PEt563TcQnUBlnjU5OR25KhfSeN5CZY7QUVGVzdCA8dGVz',\n      'dEB0ZXN0LmNvbT6IYgQTEQIAIgUCURGXDgIbAwYLCQgHAwIGFQgCCQoLBBYCAwEC',\n      'HgECF4AACgkQikDlZK/UvLSspgCfcNaOpTg1W2ucR1JwBbBGvaERfuMAnRgt3/rs',\n      'EplqEakMckCtikEnpxYe',\n      '=b2Ln',\n      '-----END PGP PUBLIC KEY BLOCK-----'].join('\\n');\n\n  const msg_arm1 =\n    ['-----BEGIN PGP MESSAGE-----',\n      'Version: GnuPG v1.4.11 (GNU/Linux)',\n      '',\n      'hQEOA1N4OCSSjECBEAP/diDJCQn4e88193PgqhbfAkohk9RQ0v0MPnXpJbCRTHKO',\n      '8r9nxiAr/TQv4ZOingXdAp2JZEoE9pXxZ3r1UWew04czxmgJ8FP1ztZYWVFAWFVi',\n      'Tj930TBD7L1fY/MD4fK6xjEG7z5GT8k4tn4mLm/PpWMbarIglfMopTy1M/py2cID',\n      '/2Sj7Ikh3UFiG+zm4sViYc5roNbMy8ixeoKixxi99Mx8INa2cxNfqbabjblFyc0Z',\n      'BwmbIc+ZiY2meRNI5y/tk0gRD7hT84IXGGl6/mH00bsX/kkWdKGeTvz8s5G8RDHa',\n      'Za4HgLbXItkX/QarvRS9kvkD01ujHfj+1ZvgmOBttNfP0p8BQLIICqvg1eYD9aPB',\n      '+GtOZ2F3+k5VyBL5yIn/s65SBjNO8Fqs3aL0x+p7s1cfUzx8J8a8nWpqq/qIQIqg',\n      'ZJH6MZRKuQwscwH6NWgsSVwcnVCAXnYOpbHxFQ+j7RbF/+uiuqU+DFH/Rd5pik8b',\n      '0Dqnp0yfefrkjQ0nuvubgB6Rv89mHpnvuJfFJRInpg4lrHwLvRwdpN2HDozFHcKK',\n      'aOU=',\n      '=4iGt',\n      '-----END PGP MESSAGE-----'].join('\\n');\n\n  const priv_key_arm2 =\n    ['-----BEGIN PGP PRIVATE KEY BLOCK-----',\n      'Version: GnuPG v2.0.19 (GNU/Linux)',\n      '',\n      'lQH+BFJhL04BBADclrUEDDsm0PSZbQ6pml9FpzTyXiyCyDN+rMOsy9J300Oc10kt',\n      '/nyBej9vZSRcaW5VpNNj0iA+c1/w2FPf84zNsTzvDmuMaNHFUzky4/vkYuZra//3',\n      '+Ri7CF8RawSYQ/4IRbC9zqdBlzniyfQOW7Dp/LYe8eibnDSrmkQem0G0jwARAQAB',\n      '/gMDAu7L//czBpE40p1ZqO8K3k7UejemjsQqc7kOqnlDYd1Z6/3NEA/UM30Siipr',\n      'KjdIFY5+hp0hcs6EiiNq0PDfm/W2j+7HfrZ5kpeQVxDek4irezYZrl7JS2xezaLv',\n      'k0Fv/6fxasnFtjOM6Qbstu67s5Gpl9y06ZxbP3VpT62+Xeibn/swWrfiJjuGEEhM',\n      'bgnsMpHtzAz/L8y6KSzViG/05hBaqrvk3/GeEA6nE+o0+0a6r0LYLTemmq6FbaA1',\n      'PHo+x7k7oFcBFUUeSzgx78GckuPwqr2mNfeF+IuSRnrlpZl3kcbHASPAOfEkyMXS',\n      'sWGE7grCAjbyQyM3OEXTSyqnehvGS/1RdB6kDDxGwgE/QFbwNyEh6K4eaaAThW2j',\n      'IEEI0WEnRkPi9fXyxhFsCLSI1XhqTaq7iDNqJTxE+AX2b9ZuZXAxI3Tc/7++vEyL',\n      '3p18N/MB2kt1Wb1azmXWL2EKlT1BZ5yDaJuBQ8BhphM3tCRUZXN0IE1jVGVzdGlu',\n      'Z3RvbiA8dGVzdEBleGFtcGxlLmNvbT6IuQQTAQIAIwUCUmEvTgIbLwcLCQgHAwIB',\n      'BhUIAgkKCwQWAgMBAh4BAheAAAoJEEpjYTpNbkCUMAwD+gIK08qpEZSVas9qW+Ok',\n      '32wzNkwxe6PQgZwcyBqMQYZUcKagC8+89pMQQ5sKUGvpIgat42Tf1KLGPcvG4cDA',\n      'JZ6w2PYz9YHQqPh9LA+PAnV8m25TcGmKcKgvFUqQ3U53X/Y9sBP8HooRqfwwHcv9',\n      'pMgQmojmNbI4VHydRqIBePawnQH+BFJhL04BBADpH8+0EVolpPiOrXTKoBKTiyrB',\n      'UyxzodyJ8zmVJ3HMTEU/vidpQwzISwoc/ndDFMXQauq6xqBCD9m2BPQI3UdQzXnb',\n      'LsAI52nWCIqOkzM5NAKWoKhyXK9Y4UH4v9LAYQgl/stIISvCgG4mJ8lzzEBWvRdf',\n      'Qm2Ghb64/3V5NDdemwARAQAB/gMDAu7L//czBpE40iPcpLzL7GwBbWFhSWgSLy53',\n      'Md99Kxw3cApWCok2E8R9/4VS0490xKZIa5y2I/K8thVhqk96Z8Kbt7MRMC1WLHgC',\n      'qJvkeQCI6PrFM0PUIPLHAQtDJYKtaLXxYuexcAdKzZj3FHdtLNWCooK6n3vJlL1c',\n      'WjZcHJ1PH7USlj1jup4XfxsbziuysRUSyXkjn92GZLm+64vCIiwhqAYoizF2NHHG',\n      'hRTN4gQzxrxgkeVchl+ag7DkQUDANIIVI+A63JeLJgWJiH1fbYlwESByHW+zBFNt',\n      'qStjfIOhjrfNIc3RvsggbDdWQLcbxmLZj4sB0ydPSgRKoaUdRHJY0S4vp9ouKOtl',\n      '2au/P1BP3bhD0fDXl91oeheYth+MSmsJFDg/vZJzCJhFaQ9dp+2EnjN5auNCNbaI',\n      'beFJRHFf9cha8p3hh+AK54NRCT++B2MXYf+TPwqX88jYMBv8kk8vYUgo8128r1zQ',\n      'EzjviQE9BBgBAgAJBQJSYS9OAhsuAKgJEEpjYTpNbkCUnSAEGQECAAYFAlJhL04A',\n      'CgkQ4IT3RGwgLJe6ogQA2aaJEIBIXtgrs+8WSJ4k3DN4rRXcXaUZf667pjdD9nF2',\n      '3BzjFH6Z78JIGaxRHJdM7b05aE8YuzM8f3NIlT0F0OLq/TI2muYU9f/U2DQBuf+w',\n      'KTB62+PELVgi9MsXC1Qv/u/o1LZtmmxTFFOD35xKsxZZI2OJj2pQpqObW27M8Nlc',\n      'BQQAw2YA3fFc38qPK+PY4rZyTRdbvjyyX+1zeqIo8wn7QCQwXs+OGaH2fGoT35AI',\n      'SXuqKcWqoEuO7OBSEFThCXBfUYMC01OrqKEswPm/V3zZkLu01q12UMwZach28QwK',\n      '/YZly4ioND2tdazj17u2rU2dwtiHPe1iMqGgVMoQirfLc+k=',\n      '=lw5e',\n      '-----END PGP PRIVATE KEY BLOCK-----'].join('\\n');\n\n  const pub_key_arm2 =\n    ['-----BEGIN PGP PUBLIC KEY BLOCK-----',\n      'Version: GnuPG v2.0.19 (GNU/Linux)',\n      '',\n      'mI0EUmEvTgEEANyWtQQMOybQ9JltDqmaX0WnNPJeLILIM36sw6zL0nfTQ5zXSS3+',\n      'fIF6P29lJFxpblWk02PSID5zX/DYU9/zjM2xPO8Oa4xo0cVTOTLj++Ri5mtr//f5',\n      'GLsIXxFrBJhD/ghFsL3Op0GXOeLJ9A5bsOn8th7x6JucNKuaRB6bQbSPABEBAAG0',\n      'JFRlc3QgTWNUZXN0aW5ndG9uIDx0ZXN0QGV4YW1wbGUuY29tPoi5BBMBAgAjBQJS',\n      'YS9OAhsvBwsJCAcDAgEGFQgCCQoLBBYCAwECHgECF4AACgkQSmNhOk1uQJQwDAP6',\n      'AgrTyqkRlJVqz2pb46TfbDM2TDF7o9CBnBzIGoxBhlRwpqALz7z2kxBDmwpQa+ki',\n      'Bq3jZN/UosY9y8bhwMAlnrDY9jP1gdCo+H0sD48CdXybblNwaYpwqC8VSpDdTndf',\n      '9j2wE/weihGp/DAdy/2kyBCaiOY1sjhUfJ1GogF49rC4jQRSYS9OAQQA6R/PtBFa',\n      'JaT4jq10yqASk4sqwVMsc6HcifM5lSdxzExFP74naUMMyEsKHP53QxTF0Grqusag',\n      'Qg/ZtgT0CN1HUM152y7ACOdp1giKjpMzOTQClqCoclyvWOFB+L/SwGEIJf7LSCEr',\n      'woBuJifJc8xAVr0XX0JthoW+uP91eTQ3XpsAEQEAAYkBPQQYAQIACQUCUmEvTgIb',\n      'LgCoCRBKY2E6TW5AlJ0gBBkBAgAGBQJSYS9OAAoJEOCE90RsICyXuqIEANmmiRCA',\n      'SF7YK7PvFkieJNwzeK0V3F2lGX+uu6Y3Q/Zxdtwc4xR+me/CSBmsURyXTO29OWhP',\n      'GLszPH9zSJU9BdDi6v0yNprmFPX/1Ng0Abn/sCkwetvjxC1YIvTLFwtUL/7v6NS2',\n      'bZpsUxRTg9+cSrMWWSNjiY9qUKajm1tuzPDZXAUEAMNmAN3xXN/Kjyvj2OK2ck0X',\n      'W748sl/tc3qiKPMJ+0AkMF7Pjhmh9nxqE9+QCEl7qinFqqBLjuzgUhBU4QlwX1GD',\n      'AtNTq6ihLMD5v1d82ZC7tNatdlDMGWnIdvEMCv2GZcuIqDQ9rXWs49e7tq1NncLY',\n      'hz3tYjKhoFTKEIq3y3Pp',\n      '=h/aX',\n      '-----END PGP PUBLIC KEY BLOCK-----'].join('\\n');\n\n  const pub_key_arm3 =\n    ['-----BEGIN PGP PUBLIC KEY BLOCK-----',\n      'Version: GnuPG v2.0.19 (GNU/Linux)',\n      '',\n      'mQENBFKV0FUBCACtZliApy01KBGbGNB36YGH4lpr+5KoqF1I8A5IT0YeNjyGisOk',\n      'WsDsUzOqaNvgzQ82I3MY/jQV5rLBhH/6LiRmCA16WkKcqBrHfNGIxJ+Q+ofVBHUb',\n      'aS9ClXYI88j747QgWzirnLuEA0GfilRZcewII1pDA/G7+m1HwV4qHsPataYLeboq',\n      'hPA3h1EVVQFMAcwlqjOuS8+weHQRfNVRGQdRMm6H7166PseDVRUHdkJpVaKFhptg',\n      'rDoNI0lO+UujdqeF1o5tVZ0j/s7RbyBvdLTXNuBbcpq93ceSWuJPZmi1XztQXKYe',\n      'y0f+ltgVtZDEc7TGV5WDX9erRECCcA3+s7J3ABEBAAG0G0pTIENyeXB0byA8ZGlm',\n      'ZmllQGhvbWUub3JnPokBPwQTAQIAKQUCUpXQVQIbAwUJCWYBgAcLCQgHAwIBBhUI',\n      'AgkKCwQWAgMBAh4BAheAAAoJENvyI+hwU030yRAIAKX/mGEgi/miqasbbQoyK/CS',\n      'a7sRxgZwOWQLdi2xxpE5V4W4HJIDNLJs5vGpRN4mmcNK2fmJAh74w0PskmVgJEhP',\n      'dFJ14UC3fFPq5nbqkBl7hU0tDP5jZxo9ruQZfDOWpHKxOCz5guYJ0CW97bz4fChZ',\n      'NFDyfU7VsJQwRIoViVcMCipP0fVZQkIhhwpzQpmVmN8E0a6jWezTZv1YpMdlzbEf',\n      'H79l3StaOh9/Un9CkIyqEWdYiKvIYms9nENyehN7r/OKYN3SW+qlt5GaL+ws+N1w',\n      '6kEZjPFwnsr+Y4A3oHcAwXq7nfOz71USojSmmo8pgdN8je16CP98vw3/k6TncLS5',\n      'AQ0EUpXQVQEIAMEjHMeqg7B04FliUFWr/8C6sJDb492MlGAWgghIbnuJfXAnUGdN',\n      'oAzn0S+n93Y/qHbW6YcjHD4/G+kK3MuxthAFqcVjdHZQXK0rkhXO/u1co7v1cdtk',\n      'OTEcyOpyLXolM/1S2UYImhrml7YulTHMnWVja7xu6QIRso+7HBFT/u9D47L/xXrX',\n      'MzXFVZfBtVY+yoeTrOY3OX9cBMOAu0kuN9eT18Yv2yi6XMzP3iONVHtl6HfFrAA7',\n      'kAtx4ne0jgAPWZ+a8hMy59on2ZFs/AvSpJtSc1kw/vMTWkyVP1Ky20vAPHQ6Ej5q',\n      '1NGJ/JbcFgolvEeI/3uDueLjj4SdSIbLOXMAEQEAAYkBJQQYAQIADwUCUpXQVQIb',\n      'DAUJCWYBgAAKCRDb8iPocFNN9NLkB/wO4iRxia0zf4Kw2RLVZG8qcuo3Bw9UTXYY',\n      'lI0AutoLNnSURMLLCq6rcJ0BCXGj/2iZ0NBxZq3t5vbRh6uUv+hpiSxK1nF7AheN',\n      '4aAAzhbWx0UDTF04ebG/neE4uDklRIJLhif6+Bwu+EUeTlGbDj7fqGSsNe8g92w7',\n      '1e41rF/9CMoOswrKgIjXAou3aexogWcHvKY2D+1q9exORe1rIa1+sUGl5PG2wsEs',\n      'znN6qtN5gMlGY1ofWDY+I02gO4qzaZ/FxRZfittCw7v5dmQYKot9qRi2Kx3Fvw+h',\n      'ivFBpC4TWgppFBnJJnAsFXZJQcejMW4nEmOViRQXY8N8PepQmgsu',\n      '=ummy',\n      '-----END PGP PUBLIC KEY BLOCK-----'].join('\\n');\n\n  const pub_revoked =\n    ['-----BEGIN PGP PUBLIC KEY BLOCK-----',\n      'Version: GnuPG v2.0.19 (GNU/Linux)',\n      '',\n      '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',\n      'pMiJM+NJAQ==',\n      '=ok+o',\n      '-----END PGP PUBLIC KEY BLOCK-----'].join('\\n');\n\n  const pub_latin1_msg = `-----BEGIN PGP PUBLIC KEY BLOCK-----\n\n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\neGlmAABNTQAqAAAACAAFARIAAwAAAAEAAQAAARoABQAAAAEAAABKARsABQAAAAEA\nAABSASgAAwAAAAEAAgAAh2kABAAAAAEAAABaAAAAAAAAAEgAAAABAAAASAAAAAEA\nAqACAAQAAAABAAAAfaADAAQAAAABAAAAlgAAAAD/4QkhaHR0cDovL25zLmFkb2Jl\nLmNvbS94YXAvMS4wLwA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENl\naGlIenJlU3pOVGN6a2M5ZCI/PiA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5z\nOm1ldGEvIiB4OnhtcHRrPSJYTVAgQ29yZSA1LjQuMCI+IDxyZGY6UkRGIHhtbG5z\nOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5z\nIyI+IDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiLz4gPC9yZGY6UkRGPiA8\nL3g6eG1wbWV0YT4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8P3hw\nYWNrZXQgZW5kPSJ3Ij8+AP/tADhQaG90b3Nob3AgMy4wADhCSU0EBAAAAAAAADhC\nSU0EJQAAAAAAENQdjNmPALIE6YAJmOz4Qn7/4gzgSUNDX1BST0ZJTEUAAQEAAAzQ\nYXBwbAIQAABtbnRyUkdCIFhZWiAH3wABAAEACwA7AC1hY3NwQVBQTAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAA9tYAAQAAAADTLWFwcGwAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABFkZXNjAAABUAAAAGJkc2Nt\nAAABtAAAAbhjcHJ0AAADbAAAACN3dHB0AAADkAAAABRyWFlaAAADpAAAABRnWFla\nAAADuAAAABRiWFlaAAADzAAAABRyVFJDAAAD4AAACAxhYXJnAAAL7AAAACB2Y2d0\nAAAMDAAAADBuZGluAAAMPAAAAD5jaGFkAAAMfAAAACxtbW9kAAAMqAAAAChiVFJD\nAAAD4AAACAxnVFJDAAAD4AAACAxhYWJnAAAL7AAAACBhYWdnAAAL7AAAACBkZXNj\nAAAAAAAAAAhEaXNwbGF5AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nbWx1YwAAAAAAAAAiAAAADGhySFIAAAAQAAABqGtvS1IAAAAQAAABqG5iTk8AAAAQ\nAAABqGlkAAAAAAAQAAABqGh1SFUAAAAQAAABqGNzQ1oAAAAQAAABqGRhREsAAAAQ\nAAABqHVrVUEAAAAQAAABqGFyAAAAAAAQAAABqGl0SVQAAAAQAAABqHJvUk8AAAAQ\nAAABqGVzRVMAAAAQAAABqGhlSUwAAAAQAAABqG5sTkwAAAAQAAABqGZpRkkAAAAQ\nAAABqHpoVFcAAAAQAAABqHZpVk4AAAAQAAABqHNrU0sAAAAQAAABqHpoQ04AAAAQ\nAAABqHJ1UlUAAAAQAAABqGZyRlIAAAAQAAABqG1zAAAAAAAQAAABqGNhRVMAAAAQ\nAAABqHRoVEgAAAAQAAABqGVzWEwAAAAQAAABqGRlREUAAAAQAAABqGVuVVMAAAAQ\nAAABqHB0QlIAAAAQAAABqHBsUEwAAAAQAAABqGVsR1IAAAAQAAABqHN2U0UAAAAQ\nAAABqHRyVFIAAAAQAAABqGphSlAAAAAQAAABqHB0UFQAAAAQAAABqABTAE0AQgAx\nADkANAAwAFd0ZXh0AAAAAENvcHlyaWdodCBBcHBsZSBJbmMuLCAyMDE1AABYWVog\nAAAAAAAA89gAAQAAAAEWCFhZWiAAAAAAAABwAAAAOREAAAPCWFlaIAAAAAAAAGI3\nAAC3mgAAGRFYWVogAAAAAAAAJJ8AAA9VAAC2WmN1cnYAAAAAAAAEAAAAAAUACgAP\nABQAGQAeACMAKAAtADIANgA7AEAARQBKAE8AVABZAF4AYwBoAG0AcgB3AHwAgQCG\nAIsAkACVAJoAnwCjAKgArQCyALcAvADBAMYAywDQANUA2wDgAOUA6wDwAPYA+wEB\nAQcBDQETARkBHwElASsBMgE4AT4BRQFMAVIBWQFgAWcBbgF1AXwBgwGLAZIBmgGh\nAakBsQG5AcEByQHRAdkB4QHpAfIB+gIDAgwCFAIdAiYCLwI4AkECSwJUAl0CZwJx\nAnoChAKOApgCogKsArYCwQLLAtUC4ALrAvUDAAMLAxYDIQMtAzgDQwNPA1oDZgNy\nA34DigOWA6IDrgO6A8cD0wPgA+wD+QQGBBMEIAQtBDsESARVBGMEcQR+BIwEmgSo\nBLYExATTBOEE8AT+BQ0FHAUrBToFSQVYBWcFdwWGBZYFpgW1BcUF1QXlBfYGBgYW\nBicGNwZIBlkGagZ7BowGnQavBsAG0QbjBvUHBwcZBysHPQdPB2EHdAeGB5kHrAe/\nB9IH5Qf4CAsIHwgyCEYIWghuCIIIlgiqCL4I0gjnCPsJEAklCToJTwlkCXkJjwmk\nCboJzwnlCfsKEQonCj0KVApqCoEKmAquCsUK3ArzCwsLIgs5C1ELaQuAC5gLsAvI\nC+EL+QwSDCoMQwxcDHUMjgynDMAM2QzzDQ0NJg1ADVoNdA2ODakNww3eDfgOEw4u\nDkkOZA5/DpsOtg7SDu4PCQ8lD0EPXg96D5YPsw/PD+wQCRAmEEMQYRB+EJsQuRDX\nEPURExExEU8RbRGMEaoRyRHoEgcSJhJFEmQShBKjEsMS4xMDEyMTQxNjE4MTpBPF\nE+UUBhQnFEkUahSLFK0UzhTwFRIVNBVWFXgVmxW9FeAWAxYmFkkWbBaPFrIW1hb6\nFx0XQRdlF4kXrhfSF/cYGxhAGGUYihivGNUY+hkgGUUZaxmRGbcZ3RoEGioaURp3\nGp4axRrsGxQbOxtjG4obshvaHAIcKhxSHHscoxzMHPUdHh1HHXAdmR3DHeweFh5A\nHmoelB6+HukfEx8+H2kflB+/H+ogFSBBIGwgmCDEIPAhHCFIIXUhoSHOIfsiJyJV\nIoIiryLdIwojOCNmI5QjwiPwJB8kTSR8JKsk2iUJJTglaCWXJccl9yYnJlcmhya3\nJugnGCdJJ3onqyfcKA0oPyhxKKIo1CkGKTgpaymdKdAqAio1KmgqmyrPKwIrNitp\nK50r0SwFLDksbiyiLNctDC1BLXYtqy3hLhYuTC6CLrcu7i8kL1ovkS/HL/4wNTBs\nMKQw2zESMUoxgjG6MfIyKjJjMpsy1DMNM0YzfzO4M/E0KzRlNJ402DUTNU01hzXC\nNf02NzZyNq426TckN2A3nDfXOBQ4UDiMOMg5BTlCOX85vDn5OjY6dDqyOu87LTtr\nO6o76DwnPGU8pDzjPSI9YT2hPeA+ID5gPqA+4D8hP2E/oj/iQCNAZECmQOdBKUFq\nQaxB7kIwQnJCtUL3QzpDfUPARANER0SKRM5FEkVVRZpF3kYiRmdGq0bwRzVHe0fA\nSAVIS0iRSNdJHUljSalJ8Eo3Sn1KxEsMS1NLmkviTCpMcky6TQJNSk2TTdxOJU5u\nTrdPAE9JT5NP3VAnUHFQu1EGUVBRm1HmUjFSfFLHUxNTX1OqU/ZUQlSPVNtVKFV1\nVcJWD1ZcVqlW91dEV5JX4FgvWH1Yy1kaWWlZuFoHWlZaplr1W0VblVvlXDVchlzW\nXSddeF3JXhpebF69Xw9fYV+zYAVgV2CqYPxhT2GiYfViSWKcYvBjQ2OXY+tkQGSU\nZOllPWWSZedmPWaSZuhnPWeTZ+loP2iWaOxpQ2maafFqSGqfavdrT2una/9sV2yv\nbQhtYG25bhJua27Ebx5veG/RcCtwhnDgcTpxlXHwcktypnMBc11zuHQUdHB0zHUo\ndYV14XY+dpt2+HdWd7N4EXhueMx5KnmJeed6RnqlewR7Y3vCfCF8gXzhfUF9oX4B\nfmJ+wn8jf4R/5YBHgKiBCoFrgc2CMIKSgvSDV4O6hB2EgITjhUeFq4YOhnKG14c7\nh5+IBIhpiM6JM4mZif6KZIrKizCLlov8jGOMyo0xjZiN/45mjs6PNo+ekAaQbpDW\nkT+RqJIRknqS45NNk7aUIJSKlPSVX5XJljSWn5cKl3WX4JhMmLiZJJmQmfyaaJrV\nm0Kbr5wcnImc951kndKeQJ6unx2fi5/6oGmg2KFHobaiJqKWowajdqPmpFakx6U4\npammGqaLpv2nbqfgqFKoxKk3qamqHKqPqwKrdavprFys0K1ErbiuLa6hrxavi7AA\nsHWw6rFgsdayS7LCszizrrQltJy1E7WKtgG2ebbwt2i34LhZuNG5SrnCuju6tbsu\nu6e8IbybvRW9j74KvoS+/796v/XAcMDswWfB48JfwtvDWMPUxFHEzsVLxcjGRsbD\nx0HHv8g9yLzJOsm5yjjKt8s2y7bMNcy1zTXNtc42zrbPN8+40DnQutE80b7SP9LB\n00TTxtRJ1MvVTtXR1lXW2Ndc1+DYZNjo2WzZ8dp22vvbgNwF3IrdEN2W3hzeot8p\n36/gNuC94UThzOJT4tvjY+Pr5HPk/OWE5g3mlucf56noMui86Ubp0Opb6uXrcOv7\n7IbtEe2c7ijutO9A78zwWPDl8XLx//KM8xnzp/Q09ML1UPXe9m32+/eK+Bn4qPk4\n+cf6V/rn+3f8B/yY/Sn9uv5L/tz/bf//cGFyYQAAAAAAAwAAAAJmZgAA8qcAAA1Z\nAAAT0AAACg52Y2d0AAAAAAAAAAEAAQAAAAAAAAABAAAAAQAAAAAAAAABAAAAAQAA\nAAAAAAABAABuZGluAAAAAAAAADYAAKPAAABUQAAATMAAAJmAAAAmgAAAD0AAAFBA\nAABUQAACMzMAAjMzAAIzMwAAAAAAAAAAc2YzMgAAAAAAAQu3AAAFlv//81cAAAcp\nAAD91///+7f///2mAAAD2gAAwPZtbW9kAAAAAAAATC0AAAaVVjg5RchujAAAAAAA\nAAAAAAAAAAAAAAAA/8AAEQgAlgB9AwEiAAIRAQMRAf/EAB8AAAEFAQEBAQEBAAAA\nAAAAAAABAgMEBQYHCAkKC//EALUQAAIBAwMCBAMFBQQEAAABfQECAwAEEQUSITFB\nBhNRYQcicRQygZGhCCNCscEVUtHwJDNicoIJChYXGBkaJSYnKCkqNDU2Nzg5OkNE\nRUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6g4SFhoeIiYqSk5SVlpeYmZqi\no6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2drh4uPk5ebn6Onq8fLz\n9PX29/j5+v/EAB8BAAMBAQEBAQEBAQEAAAAAAAABAgMEBQYHCAkKC//EALURAAIB\nAgQEAwQHBQQEAAECdwABAgMRBAUhMQYSQVEHYXETIjKBCBRCkaGxwQkjM1LwFWJy\n0QoWJDThJfEXGBkaJicoKSo1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpz\ndHV2d3h5eoKDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXG\nx8jJytLT1NXW19jZ2uLj5OXm5+jp6vLz9PX29/j5+v/bAEMAAgICAgICAwICAwQD\nAwMEBQQEBAQFBwUFBQUFBwgHBwcHBwcICAgICAgICAoKCgoKCgsLCwsLDQ0NDQ0N\nDQ0NDf/bAEMBAgICAwMDBgMDBg0JBwkNDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0N\n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\nBlk+CJ7ytHy6En8542bB/yC+Z9/zWbVuhg==\n=jmT1\n-----END PGP PUBLIC KEY BLOCK-----`;\n\n  const keyExpiredBindingSig = `-----BEGIN PGP PUBLIC KEY BLOCK-----\n\n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\nhW1Hj9AO8lzggBQ=\n=Nt+N\n-----END PGP PUBLIC KEY BLOCK-----`;\n\n  const sequoiaBobPublicKey = `-----BEGIN PGP PUBLIC KEY BLOCK-----\nComment: Bob's OpenPGP certificate\n\n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\nNEJd3XZRzaXZE2aAMQ==\n=NXei\n-----END PGP PUBLIC KEY BLOCK-----`;\n\n  const signature_with_critical_notation = `-----BEGIN PGP MESSAGE-----\n\nowGbwMvMwMH4oOW7S46CznTG09xJDDE3Wl1KUotLuDousDAwcjBYiSmyXL+48d6x\nU1PSGUxcj8IUszKBVMpMaWAAAgEGZpAeh9SKxNyCnFS95PzcytRiBi5OAZjyXXzM\nf8WYLqv7TXP61Sa4rqT12CI3xaN73YS2pt089f96odCKaEPnWJ3iSGmzJaW/ug10\n2Zo8Wj2k4s7t8wt4H3HtTu+y5UZfV3VOO+l//sdE/o+Lsub8FZH7/eOq7OnbNp4n\nvwjE8mqJXetNMfj8r2SCyvkEnlVRYR+/mnge+ib56FdJ8uKtqSxyvgA=\n=fRXs\n-----END PGP MESSAGE-----`;\n\n  const signature_with_non_human_readable_notations = `-----BEGIN PGP SIGNATURE-----\n\nwncEARYKAB8FAl2TS9MYFAAAAAAADAADdGVzdEBrZXkuY29tAQIDAAoJEGZ9\ngtV/iL8hrhMBAOQ/UgqRTbx1Z8inGmRdUx1cJU1SR4Pnq/eJNH/CFk5DAP0Q\nhUhMKMuiM3pRwdIyDOItkUWQmjEEw7/XmhgInkXsCw==\n=ZGXr\n-----END PGP SIGNATURE-----\n`;\n\n  it('Retrieve the issuer Key ID of a signature', async function () {\n    const publicKey = await openpgp.readKey({ armoredKey: pub_key_arm2 });\n    const privateKey = await openpgp.decryptKey({\n      privateKey: await openpgp.readKey({ armoredKey: priv_key_arm2 }),\n      passphrase: 'hello world'\n    });\n    const message = await openpgp.createMessage({ text: 'test' });\n    const armoredSignature = await openpgp.sign({\n      message,\n      signingKeys: privateKey,\n      signingKeyIDs: privateKey.getKeyID(),\n      detached: true,\n      config: { minRSABits: 1024 }\n    });\n    const signature = await openpgp.readSignature({ armoredSignature });\n    expect(signature.getSigningKeyIDs).to.exist;\n    expect(signature.getSigningKeyIDs().map(x => x.toHex())).to.include(publicKey.getKeyID().toHex());\n  });\n\n  it('Throws when reading a signature missing the creation time', async function () {\n    const armoredSignature = `-----BEGIN PGP SIGNATURE-----\n\nwsDtBAABCAAXFiEE0aZuGiOxgsmYD3iM+/zIKgFeczAACgkQ+/zIKgFeczDjiwv+\nLFUWJohCYtauaVDHBDHWF+tojls+ducY6uuU6iUTBb1969okh2sjUmvPwIjrVXuk\ncfPl616xRqVWolEU9T5sG6MjRlAaG31Oo/FVAVFXZn30ldEtuDss12+/IhES3Wfx\nM1jGdJZ1ZMZJpRsNBJXBegEBFKbPleEd66seuuFfvoIUbgsdj7IT/ZlEMlixelWW\nigXPVY1C05oPbkC8oo0lVSxwdq6gDvm8a52k3GCtXJELrYGH29C+eDqmyLP1zJOt\nNBoZBAqMd9XYVrJtuip436D9pdo5pbg4zCE6uPf2zzx4taK7jGkk6nn7LqVDxvQm\n3dAXUnIxw4V9eL3V8SFAKwmouUmHPRbjfnQ70hxYQxDXUcIwu1aYn13QS1s/F/jf\nDVRZWaAhNdL9BfHfhEsRVsmjMhe0zwRpaepvXnERbnA/lAUHEmEvgfPFz/2GsAo/\nkCNcH9WI6idSzFjuYegECf+ZA1xOCjS9oLTGbSeT7jNfC8dH5+E92qlBLq4Ctt7k\n=lMU7\n-----END PGP SIGNATURE-----`;\n\n    await expect(openpgp.readSignature({ armoredSignature })).to.be.rejectedWith(/Missing signature creation time/);\n  });\n\n  it('Ignores marker packets when verifying signatures', async function () {\n    const signatureWithMarkerPacket = `-----BEGIN PGP SIGNATURE-----\n\nygNQR1DCwPMEAAEKAAYFgl8831AAIQkQ+/zIKgFeczAWIQTRpm4aI7GCyZgPeIz7\n/MgqAV5zMLckDACWiDbasKMTX/+czxHXyVcFJ/+ZeYqKEjYq6LueHy11XjJ0NZAM\nLG9TqsXpWOsHrwE6wUQ7RvKQYtfIAeMUZtD87/XomIj6B/rQC5dHuQTb0b8lrRJb\nOuW1sz6AYwceqkSvN3T5+KKNMXkaFw/DzWGPfqQQJDOqfgKxf5uO7GPVzaIU6aXn\n76iKHQ7wowT2qHoFhd+t4S11iGr6XJef6QqIW2kTetZMf2Dp/rr7228VJJ1S0RdD\nxxKJEbNrmdMNgE8/U+pkWjMQyVOOxWyPKlG3kv2Cu/naj4Lg2io3RhOAuNW5xEJF\ngAId3WUNl3/PCu/PcTS1yS/Nj0ptwjKHwG0Zg8Dk5Jey8lUVyVhjxrV5tb6NLoAG\nRlyTajZ3Sjhsg4mXHopjSF2w30saN64L5VAfGF1afFu7yzNYC+Fn6GL5yTJfKs4j\nPNo4zCwOCumsVP0jWp09yUNflE6MTd21miBgbmPxyLyuwP2YrvT4+rCl+meNZ98a\ncJRRGJPL16wINuk=\n=VNoM\n-----END PGP SIGNATURE-----`;\n\n    const key = await openpgp.readKey({ armoredKey: sequoiaBobPublicKey });\n    const message = await openpgp.createMessage({ text: 'Marker + Detached signature' });\n    const signature = await openpgp.readSignature({ armoredSignature: signatureWithMarkerPacket });\n    const { signatures: [sigInfo] } = await openpgp.verify({ message, signature, verificationKeys: key });\n    expect(await sigInfo.verified).to.be.true;\n  });\n\n\n  it('Testing signature checking on CAST5-enciphered message', async function() {\n    const publicKey = await openpgp.readKey({ armoredKey: pub_key_arm1 });\n    const privateKey = await openpgp.decryptKey({\n      privateKey: await openpgp.readKey({ armoredKey: priv_key_arm1 }),\n      passphrase: 'abcd'\n    });\n    const message = await openpgp.readMessage({ armoredMessage: msg_arm1 });\n    const config = {\n      rejectMessageHashAlgorithms: new Set([openpgp.enums.hash.md5, openpgp.enums.hash.ripemd]),\n      rejectPublicKeyAlgorithms: new Set()\n    };\n    const { data, signatures } = await openpgp.decrypt({ decryptionKeys: privateKey, verificationKeys: publicKey, message, config });\n    expect(data).to.exist;\n    expect(await signatures[0].verified).to.be.true;\n    expect((await signatures[0].signature).packets.length).to.equal(1);\n  });\n\n  it('Consider signature expired at the expiration time', async function() {\n    const key = await openpgp.readKey({ armoredKey: keyExpiredBindingSig });\n    const { embeddedSignature } = key.subkeys[0].bindingSignatures[0];\n    expect(embeddedSignature.isExpired(embeddedSignature.created)).to.be.false;\n    expect(embeddedSignature.isExpired(new Date(embeddedSignature.getExpirationTime() - 1))).to.be.false;\n    expect(embeddedSignature.isExpired(embeddedSignature.getExpirationTime())).to.be.true;\n  });\n\n  it('Signing fails if primary key is expired', async function() {\n    const armoredExpiredKey = `-----BEGIN PGP PRIVATE KEY BLOCK-----\n\nxVgEYKKPDRYJKwYBBAHaRw8BAQdAwJcSQMkHVnZPesPJP1JaB9ptV+wG8Io1\nvxRKvXQe0wMAAP0fdn6gvpVwFUE4bIRcn9hx6eDxSxUu+tg/t959Oo+iahF1\nzRB0ZXN0IDx0ZXN0QGEuaXQ+wpIEEBYKACMFAmCijw0FCQAAAAEECwkHCAMV\nCAoEFgACAQIZAQIbAwIeAQAhCRD16pevybCusRYhBHjm9svlAjmgVWL4wvXq\nl6/JsK6xGUQBAPzxKS2Qs+vWGpxPT2N2T+PLHIgCOxVJVngj4fzREFH1AP9t\nwP+fn3eSsik+vFGy93REmlD1xdu7nW/sHuxY4roqBcddBGCijw0SCisGAQQB\nl1UBBQEBB0Cl1lr+aHfy6V4ePmZUULK6VKTCTPTMaPpR2TzKNIJQBQMBCAcA\nAP9DZWRqQLCIkF38Q0UC/YXLCDdBEQdnlwpHgA0W1bSWmA3uwn4EGBYIAA8F\nAmCijw0FCQAAAAECGwwAIQkQ9eqXr8mwrrEWIQR45vbL5QI5oFVi+ML16pev\nybCusYE4AQCYbXw8ZWoMevbOM7lAttkwyrG3V/nTW6BVo7/M9Pr9swEA0mDI\nDQmhI0SZoTKy4EGhS0bNJ+g2+dJ8Y22fKzLWXwo=\n=qiIN\n-----END PGP PRIVATE KEY BLOCK-----`;\n    const key = await openpgp.readKey({ armoredKey: armoredExpiredKey });\n    await expect(openpgp.sign({\n      signingKeys: key,\n      message: await openpgp.createMessage({ text: 'Hello World' })\n    })).to.be.rejectedWith(/key is expired/);\n  });\n\n  it('Signing fails if the signing date is before the key creation date', async function() {\n    const key = await openpgp.decryptKey({\n      privateKey: await openpgp.readKey({ armoredKey: priv_key_arm2 }),\n      passphrase: 'hello world'\n    });\n    await expect(openpgp.sign({\n      signingKeys: key,\n      date: new Date(key.keyPacket.created - 3600),\n      message: await openpgp.createMessage({ text: 'Hello World' })\n    })).to.be.rejectedWith(/Signature creation time is in the future/);\n  });\n\n  it('Verification fails if primary key binding signature is expired', async function() {\n    const armoredSignature = `-----BEGIN PGP SIGNATURE-----\n\nwsDzBAABCgAGBYJfLAFsACEJEHwvqk35PDeyFiEEHdzhXwkhfO4vOzdgfC+qTfk8\nN7KiqwwAts4QGB7v9bABCC2qkTxJhmStC0wQMcHRcjL/qAiVnmasQWmvE9KVsdm3\nAaXd8mIx4a37/RRvr9dYrY2eE4uw72cMqPxNja2tvVXkHQvk1oEUqfkvbXs4ypKI\nNyeTWjXNOTZEbg0hbm3nMy+Wv7zgB1CEvAsEboLDJlhGqPcD+X8a6CJGrBGUBUrv\nKVmZr3U6vEzClz3DBLpoddCQseJRhT4YM1nKmBlZ5quh2LFgTSpajv5OsZheqt9y\nEZAPbqmLhDmWRQwGzkWHKceKS7nZ/ox2WK6OS7Ob8ZGZkM64iPo6/EGj5Yc19vQN\nAGiIaPEGszBBWlOpHTPhNm0LB0nMWqqaT87oNYwP8CQuuxDb6rKJ2lffCmZH27Lb\nUbQZcH8J+0UhpeaiadPZxH5ATJAcenmVtVVMLVOFnm+eIlxzov9ntpgGYt8hLdXB\nITEG9mMgp3TGS9ZzSifMZ8UGtHdp9QdBg8NEVPFzDOMGxpc/Bftav7RRRuPiAER+\n7A5CBid5\n=aQkm\n-----END PGP SIGNATURE-----`;\n    const key = await openpgp.readKey({ armoredKey: keyExpiredBindingSig });\n    const signature = await openpgp.readSignature({ armoredSignature });\n    const { signatures: [sigInfo] } = await openpgp.verify({\n      verificationKeys: key,\n      message: await openpgp.createMessage({ text: 'Hello World :)' }),\n      signature\n    });\n    await expect(sigInfo.verified).to.be.rejectedWith(/Signature is expired/);\n  });\n\n  it('Verification fails if signing key\\'s self-sig were created after the time of signing, unless config allows it', async function() {\n    const armoredReformattedKey = `-----BEGIN PGP PRIVATE KEY BLOCK-----\n\nxVgEYWmlshYJKwYBBAHaRw8BAQdAAxpFNPiHxz9q4HBzWqveHdP/knjwlgv8\npEQCMHDpIZIAAP9WFlwHDuVlvNb7CyoikwmG01nmdMDe9wXQRWA5vasWKA+g\nzSV0ZXN0QHJlZm9ybWF0LmNvbSA8dGVzdEByZWZvcm1hdC5jb20+wowEEBYK\nAB0FAmFppjQECwkHCAMVCAoEFgACAQIZAQIbAwIeAQAhCRAOZNKOg+/XQxYh\nBGqP/hIaYCSJsZ4TrQ5k0o6D79dD+c8BAIXdh2hrC+l49WPN/KZF+ZzvWCWa\nW5n+ozbp/sOGXvODAP4oGEj0RUDDA33b6x7fhQysBZxdrrnHxP9AXEdOTQC3\nCsddBGFppbISCisGAQQBl1UBBQEBB0Cjy8Z2K7rl6J6AK1lCfVozmyLE0Gbv\n1cspce6oCF6oCwMBCAcAAP9OL5V80EaYm2ic19aM+NtTj4UNOqKqIt10AaH9\nSlcdMBDgwngEGBYIAAkFAmFppjQCGwwAIQkQDmTSjoPv10MWIQRqj/4SGmAk\nibGeE60OZNKOg+/XQx/EAQCM0UYrObp60YbOCxu07Dm6XjCVylbOcsaxCnE7\n2eMU4AD+OkgajZgbqSIdAR1ud76FW+W+3xlDi/SMFdU7D49SbQI=\n=ASQu\n-----END PGP PRIVATE KEY BLOCK-----\n\n`;\n    const armoredMessage = `-----BEGIN PGP MESSAGE-----\n\nxA0DAQoWDmTSjoPv10MByw91AGFpplFwbGFpbnRleHTCdQQBFgoABgUCYWml\nsgAhCRAOZNKOg+/XQxYhBGqP/hIaYCSJsZ4TrQ5k0o6D79dDDWwBAKUnRWXj\nP3HTW521iD/DngK54mYS3feQzhDokhkYjO3UAP0ZlsYShKaJvXh+JgvR5BPP\ngjVcn04JVVlxqgVnMqeVBw==\n=eyO7\n-----END PGP MESSAGE-----`;\n    // the key was reformatted and the message signature date preceeds the key self-signature creation date\n    const key = await openpgp.readKey({ armoredKey: armoredReformattedKey });\n    const { signatures: [sigInfoRejected] } = await openpgp.verify({\n      verificationKeys: key,\n      message: await openpgp.readMessage({ armoredMessage })\n    });\n    await expect(sigInfoRejected.verified).to.be.rejectedWith(/Signature creation time is in the future/);\n\n    // since the key is valid at the current time, the message should be verifiable if the `config` allows it\n    const { signatures: [sigInfoValid] } = await openpgp.verify({\n      verificationKeys: key,\n      message: await openpgp.readMessage({ armoredMessage }),\n      config: { allowInsecureVerificationWithReformattedKeys: true }\n    });\n    expect(await sigInfoValid.verified).to.be.true;\n  });\n\n  it('Verification fails if signing key was already expired at the time of signing (one-pass signature, streamed)', async function() {\n    const armoredMessage = `-----BEGIN PGP MESSAGE-----\n\nxA0DAQgB4IT3RGwgLJcByxR1AGCc8BxIZWxsbyBXb3JsZCA6KcKzBAEBCAAG\nBQJgnPAcACEJEOCE90RsICyXFiEE19Gx3sbKlGcANEXF4IT3RGwgLJdssAP+\nKpyVi30z5iMckULAQ3Q34IB29Gxa1/99ABSld6iIVGRCfmZZlS5UGcxJJGoL\nvZ1RAL4YQx/GLV1dBcKWFwzb5G2/ip4coDMCDGTAwnwjcPwjHpfMQ9gX59mG\nAkLaG/AkATpuH+DMkYDmKbDLGgD+N4yuxXBJmBfC2IBe4J1S2Gg=\n=zvNP\n-----END PGP MESSAGE-----`;\n    const key = await openpgp.decryptKey({\n      privateKey: await openpgp.readKey({ armoredKey: priv_key_arm2 }),\n      passphrase: 'hello world'\n    });\n    const { privateKey: expiredKey } = await openpgp.reformatKey({\n      privateKey: key,\n      userIDs: key.users.map(user => user.userID),\n      keyExpirationTime: 1,\n      date: key.keyPacket.created,\n      format: 'object'\n    });\n    await stream.loadStreamsPonyfill();\n    const { signatures: [sigInfo] } = await openpgp.verify({\n      verificationKeys: expiredKey,\n      message: await openpgp.readMessage({ armoredMessage: stream.toStream(armoredMessage) }),\n      config: { minRSABits: 1024 }\n\n    });\n    await expect(sigInfo.verified).to.be.rejectedWith(/Primary key is expired/);\n  });\n\n  it('Verification fails if signing key was already expired at the time of signing (standard signature)', async function() {\n    const armoredMessage = `-----BEGIN PGP MESSAGE-----\n\nwrMEAQEIAAYFAmCc8BwAIQkQ4IT3RGwgLJcWIQTX0bHexsqUZwA0RcXghPdE\nbCAsl2ywA/4qnJWLfTPmIxyRQsBDdDfggHb0bFrX/30AFKV3qIhUZEJ+ZlmV\nLlQZzEkkagu9nVEAvhhDH8YtXV0FwpYXDNvkbb+KnhygMwIMZMDCfCNw/CMe\nl8xD2Bfn2YYCQtob8CQBOm4f4MyRgOYpsMsaAP43jK7FcEmYF8LYgF7gnVLY\naMsUdQBgnPAcSGVsbG8gV29ybGQgOik=\n=s9xh\n-----END PGP MESSAGE-----`;\n    const key = await openpgp.decryptKey({\n      privateKey: await openpgp.readKey({ armoredKey: priv_key_arm2 }),\n      passphrase: 'hello world'\n    });\n    const { privateKey: expiredKey } = await openpgp.reformatKey({\n      privateKey: key,\n      userIDs: key.users.map(user => user.userID),\n      keyExpirationTime: 1,\n      date: key.keyPacket.created,\n      format: 'object'\n    });\n    await stream.loadStreamsPonyfill();\n    const { signatures: [sigInfo] } = await openpgp.verify({\n      verificationKeys: expiredKey,\n      message: await openpgp.readMessage({ armoredMessage: stream.toStream(armoredMessage) }),\n      config: { minRSABits: 1024 }\n    });\n    await expect(sigInfo.verified).to.be.rejectedWith(/Primary key is expired/);\n  });\n\n  it('Verification succeeds if an expired signing key was valid at the time of signing (with streaming)', async function() {\n    const armoredMessage = `-----BEGIN PGP MESSAGE-----\n\nxA0DAQgB4IT3RGwgLJcByxF1AGCdJvJoZWxsbyB3b3JsZMKzBAEBCAAGBQJS\nYS9OACEJEOCE90RsICyXFiEE19Gx3sbKlGcANEXF4IT3RGwgLJcPBQP/csZd\n9AhZQ3+dPkwlqlsXqYMlVEagYDavlUDI2CEJ2cn1rqHBuMlRkmYs7UqODku4\nFhJ6WvghiEKx8vqghDuaUXmcKuXhYe+PomD4XBmpbURBXCdPnojTINUj7GPK\neSvSZutLuKKbidSYMLhWROPlwKc2GU2ws6PrLZAyCAel/lU=\n=xDib\n-----END PGP MESSAGE-----`;\n    const key = await openpgp.decryptKey({\n      privateKey: await openpgp.readKey({ armoredKey: priv_key_arm2 }),\n      passphrase: 'hello world'\n    });\n    const { privateKey: expiredKey } = await openpgp.reformatKey({\n      privateKey: key,\n      userIDs: key.users.map(user => user.userID),\n      keyExpirationTime: 1,\n      date: key.keyPacket.created,\n      format: 'object'\n    });\n    await stream.loadStreamsPonyfill();\n    const { signatures: [sigInfo] } = await openpgp.verify({\n      verificationKeys: expiredKey,\n      message: await openpgp.readMessage({ armoredMessage: stream.toStream(armoredMessage) }),\n      config: { minRSABits: 1024 }\n    });\n    expect(await sigInfo.verified).to.be.true;\n  });\n\n  it('Verification succeeds if an expired signing key was valid at the time of signing (without streaming)', async function() {\n    const armoredMessage = `-----BEGIN PGP MESSAGE-----\n\nxA0DAQgB4IT3RGwgLJcByxF1AGCdJvJoZWxsbyB3b3JsZMKzBAEBCAAGBQJS\nYS9OACEJEOCE90RsICyXFiEE19Gx3sbKlGcANEXF4IT3RGwgLJcPBQP/csZd\n9AhZQ3+dPkwlqlsXqYMlVEagYDavlUDI2CEJ2cn1rqHBuMlRkmYs7UqODku4\nFhJ6WvghiEKx8vqghDuaUXmcKuXhYe+PomD4XBmpbURBXCdPnojTINUj7GPK\neSvSZutLuKKbidSYMLhWROPlwKc2GU2ws6PrLZAyCAel/lU=\n=xDib\n-----END PGP MESSAGE-----`;\n    const key = await openpgp.decryptKey({\n      privateKey: await openpgp.readKey({ armoredKey: priv_key_arm2 }),\n      passphrase: 'hello world'\n    });\n    const { privateKey: expiredKey } = await openpgp.reformatKey({\n      privateKey: key,\n      userIDs: key.users.map(user => user.userID),\n      keyExpirationTime: 1,\n      date: key.keyPacket.created,\n      format: 'object'\n    });\n    const { signatures: [sigInfo] } = await openpgp.verify({\n      verificationKeys: expiredKey,\n      message: await openpgp.readMessage({ armoredMessage }),\n      config: { minRSABits: 1024 }\n    });\n    expect(await sigInfo.verified).to.be.true;\n  });\n\n  it('Supports non-human-readable notations', async function() {\n    const { packets: [signature] } = await openpgp.readSignature({ armoredSignature: signature_with_non_human_readable_notations });\n    // There are no human-readable notations so `notations` property does not\n    // expose the `test@key.com` notation.\n    expect(Object.keys(signature.notations).length).to.equal(0);\n    expect(signature.notations['test@key.com']).to.equal(undefined);\n\n    // The notation is readable through `rawNotations` property:\n    expect(signature.rawNotations.length).to.equal(1);\n    const notation = signature.rawNotations[0];\n    expect(notation.name).to.equal('test@key.com');\n    expect(notation.value).to.deep.equal(new Uint8Array([0x01, 0x02, 0x03]));\n    expect(notation.humanReadable).to.equal(false);\n  });\n\n  it('Verify V4 signature. Hash: SHA1. PK: RSA. Signature Type: 0x00 (binary document)', async function() {\n    const { rejectMessageHashAlgorithms, minRSABits } = openpgp.config;\n    Object.assign(openpgp.config, {\n      rejectMessageHashAlgorithms: new Set([openpgp.enums.hash.md5, openpgp.enums.hash.ripemd]),\n      minRSABits: 1024\n    });\n    try {\n      const signedArmor =\n        ['-----BEGIN PGP MESSAGE-----',\n          'Version: GnuPG v2.0.19 (GNU/Linux)',\n          '',\n          'owGbwMvMwMT4oOW7S46CznTGNeZJLCWpFSVBU3ZGF2fkF5Uo5KYWFyemp3LlAUUV',\n          'cjLzUrneTp3zauvaN9O26L9ZuOFNy4LXyydwcXXMYWFgZGJgY2UCaWXg4hSAmblK',\n          'nPmfsXYxd58Ka9eVrEnSpzilr520fXBrJsf2P/oTqzTj3hzyLG0o3TTzxFfrtOXf',\n          'cw6U57n3/Z4X0pEZ68C5/o/6NpPICD7fuEOz3936raZ6wXGzueY8pfPnVjY0ajAc',\n          'PtJzvvqj+ubYaT1sK9wWhd9lL3/V+9Zuua9QjOWC22buchsCroh8fLoZAA==',\n          '=VH8F',\n          '-----END PGP MESSAGE-----'].join('\\n');\n\n      const sMsg = await openpgp.readMessage({ armoredMessage: signedArmor });\n      const pub_key = await openpgp.readKey({ armoredKey: pub_key_arm2 });\n      const verified = await sMsg.verify([pub_key]);\n      stream.readToEnd(sMsg.getLiteralData());\n      expect(verified).to.exist;\n      expect(verified).to.have.length(1);\n      expect(await verified[0].verified).to.be.true;\n      expect((await verified[0].signature).packets.length).to.equal(1);\n    } finally {\n      Object.assign(openpgp.config, { rejectMessageHashAlgorithms, minRSABits });\n    }\n  });\n\n  it('Verify signature of signed and encrypted message from GPG2 with openpgp.decrypt', async function() {\n    const msg_armor =\n      ['-----BEGIN PGP MESSAGE-----',\n        'Version: GnuPG v2.0.19 (GNU/Linux)',\n        '',\n        'hIwD4IT3RGwgLJcBBADEBdm+GEW7IV1K/Bykg0nB0WYO08ai7/8/+Y/O9xu6RiU0',\n        'q7/jWuKms7kSjw9gxMCjf2dGnAuT4Cg505Kj5WfeBuHh618ovO8qo4h0qHyp1/y3',\n        'o1P0IXPAb+LGJOeO7DyM9Xp2AOBiIKOVWzFTg+MBZOc+XZEVx3FioHfm9SSDudLA',\n        'WAEkDakCG6MRFj/7SmOiV8mQKH+YPMKT69eDZW7hjINabrpM2pdRU7c9lC7CMUBx',\n        'Vj7wZsQBMASSC8f2rhpGA2iKvYMsmW3g9R1xkvj1MXWftSPUS4jeNTAgEwvvF6Af',\n        'cP+OYSXKlTbwfEr73ES2O3/IFE9sHRjPqWaxWuv4DDQ5YfIxE54C1aE8Aq5/QaIH',\n        'v38TUSia0yEMCc/tJd58DikkT07AF162tcx9Ro0ZjhudyuvUyXIfPfxA+XWR2pdz',\n        'ifxyV4zia9RvaCUY8vXGM+gQJ3NNXx2LkZA3kWUEyxFVL1Vl/XUQY0M6U+uccSk4',\n        'eMXm6eyEWDcj0lBRckqKoKo1w/uan11jPuHsnRz6jO9DsuKEz79UDgI=',\n        '=cFi7',\n        '-----END PGP MESSAGE-----'].join('\\n');\n\n    const plaintext = 'short message\\nnext line\\n\ud55c\uad6d\uc5b4/\uc870\uc120\ub9d0';\n    const message = await openpgp.readMessage({ armoredMessage: msg_armor });\n    const pubKey = await openpgp.readKey({ armoredKey: pub_key_arm2 });\n    const privKey = await openpgp.decryptKey({\n      privateKey: await openpgp.readKey({ armoredKey: priv_key_arm2 }),\n      passphrase: 'hello world'\n    });\n\n    return openpgp.decrypt({\n      decryptionKeys: privKey, verificationKeys: pubKey , message, config: { minRSABits: 1024 }\n    }).then(async ({ signatures, data }) => {\n      expect(data).to.exist;\n      expect(data).to.equal(plaintext);\n      expect(signatures).to.have.length(1);\n      expect(await signatures[0].verified).to.be.true;\n      expect((await signatures[0].signature).packets.length).to.equal(1);\n    });\n  });\n\n  it('Verify signed message with two one pass signatures', async function() {\n    const msg_armor =\n      ['-----BEGIN PGP MESSAGE-----',\n        'Version: GnuPG v2.0.19 (GNU/Linux)',\n        '',\n        'owGbwMvMwMF4+5Pyi4Jg3y8ME8DcBy3fXXIUdKYzrjFNYilJrSgJmsXDXJyRX1Si',\n        'kJtaXJyYnsqVBxRVyMnMS+V6O3XOq61r30zbov9m4YY3LQteL5/QMYeFgZGDgY2V',\n        'CaSRgYtTAGZiYxYLwySbQk07ptZel6gmjrKyBWsyWdkOG3oscLBdIpXXfDdb6fNv',\n        '8ULN5L1ed+xNo79P2dBotWud6vn7e9dtLJ7o12PunnvEz8gyyvP4/As/los0xsnZ',\n        'H+8ublrhvGtLxJUZuUKZO6QdHq2Nepuw8OrfiMXPBDQXXpV2q11Ze+rD3lndgv/C',\n        'bJQNOhll0J0H839jFvt/16m20h/ZmDoWqJywapnypjdIjcXr+7rJFess40yenV7Q',\n        '2LSu/EX6Aq29x+dv+GPUMfuhTNE3viWWUR4PD6T7XfmdViUwmSf8fkRNUn/t3a2n',\n        'cq46Xr36seCor/OLp0atSZwHrjx2SU5zPLheZn+zw/0d1/YZnD7AEeP9s/Cuycyv',\n        'CZ5HZNKufvB8fsh+dfdSXW0GfqkPfxk36Vw8ufpjaoZDyt2nxxg/6D4KS3UvZzv3',\n        'axdLZ9yd0OJNZv4P501If24W4vTGz6nI7Ser8Yd2PiOvE5MWMT0wLZQ+zPX1sv0/',\n        's8PvkyWmVM0O0fB/ZSHovHNNPffDg/rWhzOmXQ9/7vTn477F+aWm5sYzJ75/BQA=',\n        '=+L0S',\n        '-----END PGP MESSAGE-----'].join('\\n');\n    const plaintext = 'short message\\nnext line\\n\ud55c\uad6d\uc5b4/\uc870\uc120\ub9d0';\n    const sMsg = await openpgp.readMessage({ armoredMessage: msg_armor });\n    const pubKey2 = await openpgp.readKey({ armoredKey: pub_key_arm2 });\n    const pubKey3 = await openpgp.readKey({ armoredKey: pub_key_arm3 });\n\n    const keyIDs = sMsg.getSigningKeyIDs();\n    expect(pubKey2.getKeys(keyIDs[1])).to.not.be.empty;\n    expect(pubKey3.getKeys(keyIDs[0])).to.not.be.empty;\n\n    const { data, signatures } = await openpgp.verify({ message: sMsg, verificationKeys: [pubKey2, pubKey3], config: { minRSABits: 1024 } });\n    expect(data).to.equal(plaintext);\n    expect(signatures).to.exist;\n    expect(signatures).to.have.length(2);\n    expect(await signatures[0].verified).to.be.true;\n    expect(await signatures[1].verified).to.be.true;\n    expect((await signatures[0].signature).packets.length).to.equal(1);\n    expect((await signatures[1].signature).packets.length).to.equal(1);\n  });\n\n  it('Verify fails with signed message with critical notations', async function() {\n    const message = await openpgp.readMessage({ armoredMessage: signature_with_critical_notation });\n    const key = await openpgp.readKey({ armoredKey: pub_key_arm2 });\n    const { signatures: [sig] } = await openpgp.verify({ message, verificationKeys: key, config: { minRSABits: 1024 } });\n    await expect(sig.verified).to.be.rejectedWith(/Unknown critical notation: test@example.com/);\n  });\n\n  it('Verify succeeds with known signed message with critical notations', async function() {\n    const message = await openpgp.readMessage({ armoredMessage: signature_with_critical_notation });\n    const key = await openpgp.readKey({ armoredKey: pub_key_arm2 });\n\n    const config = { knownNotations: ['test@example.com'], minRSABits: 1024 };\n    const { signatures: [sig] } = await openpgp.verify({ message, verificationKeys: key, config });\n    expect(await sig.verified).to.be.true;\n  });\n\n  it('Can create notations', async function() {\n    const privKey = await openpgp.decryptKey({\n      privateKey: await openpgp.readKey({ armoredKey: priv_key_arm2 }),\n      passphrase: 'hello world'\n    });\n\n    const config = { minRSABits: 1024 };\n    const message_with_notation = await openpgp.encrypt({\n      message: await openpgp.createMessage({ text: 'test' }),\n      encryptionKeys: privKey,\n      signingKeys: privKey,\n      signatureNotations: [\n        {\n          name: 'test@example.com',\n          value: new TextEncoder().encode('test'),\n          humanReadable: true,\n          critical: true\n        },\n        {\n          name: 's\u00e9paration-de-domaine@proton.ch',\n          value: new Uint8Array([0, 1, 2, 3]),\n          humanReadable: false,\n          critical: false\n        }\n      ],\n      config\n    });\n    expect(openpgp.decrypt({\n      message: await openpgp.readMessage({ armoredMessage: message_with_notation }),\n      decryptionKeys: privKey,\n      verificationKeys: privKey,\n      expectSigned: true,\n      config\n    })).to.be.rejectedWith('Unknown critical notation: test@example.com');\n    const { signatures: [sig] } = await openpgp.decrypt({\n      message: await openpgp.readMessage({ armoredMessage: message_with_notation }),\n      decryptionKeys: privKey,\n      verificationKeys: privKey,\n      config: {\n        knownNotations: ['test@example.com'],\n        ...config\n      }\n    });\n    expect(await sig.verified).to.be.true;\n    const { packets: [{ rawNotations: notations }] } = await sig.signature;\n    expect(notations).to.have.length(2);\n    expect(notations[0].name).to.equal('test@example.com');\n    expect(notations[0].value).to.deep.equal(new Uint8Array([116, 101, 115, 116]));\n    expect(notations[0].humanReadable).to.be.true;\n    expect(notations[0].critical).to.be.true;\n    expect(notations[1].name).to.equal('s\u00e9paration-de-domaine@proton.ch');\n    expect(notations[1].value).to.deep.equal(new Uint8Array([0, 1, 2, 3]));\n    expect(notations[1].humanReadable).to.be.false;\n    expect(notations[1].critical).to.be.false;\n  });\n\n  it('Verify cleartext signed message with two signatures with openpgp.verify', async function() {\n    const cleartextMessage =\n      ['-----BEGIN PGP SIGNED MESSAGE-----',\n        'Hash: SHA256',\n        '',\n        'short message',\n        'next line',\n        '\ud55c\uad6d\uc5b4/\uc870\uc120\ub9d0',\n        '-----BEGIN PGP SIGNATURE-----',\n        'Version: GnuPG v2.0.19 (GNU/Linux)',\n        '',\n        'iJwEAQEIAAYFAlKcju8ACgkQ4IT3RGwgLJci6gP/dCmIraUa6AGpJxzGfK+jYpjl',\n        'G0KunFyGmyPxeJVnPi2bBp3EPIbiayQ71CcDe9DKpF046tora07AA9eo+/YbvJ9P',\n        'PWeScw3oj/ejsmKQoDBGzyDMFUphevnhgc5lENjovJqmiu6FKjNmADTxcZ/qFTOq',\n        '44EWTgdW3IqXFkNpKjeJARwEAQEIAAYFAlKcju8ACgkQ2/Ij6HBTTfQi6gf9HxhE',\n        'ycLDhQ8iyC090TaYwsDytScU2vOMiI5rJCy2tfDV0pfn+UekYGMnKxZTpwtmno1j',\n        'mVOlieENszz5IcehS5TYwk4lmRFjoba+Z8qwPEYhYxP29GMbmRIsH811sQHFTigo',\n        'LI2t4pSSSUpAiXd9y6KtvkWcGGn8IfkNHCEHPh1ov28QvH0+ByIiKYK5N6ZB8hEo',\n        '0uMYhKQPVJdPCvMkAxQCRPw84EvmxuJ0HMCeSB9tHQXpz5un2m8D9yiGpBQPnqlW',\n        'vCCq7fgaUz8ksxvQ9bSwv0iIIbbBdTP7Z8y2c1Oof6NDl7irH+QCeNT7IIGs8Smn',\n        'BEzv/FqkQAhjy3Krxg==',\n        '=3Pkl',\n        '-----END PGP SIGNATURE-----'].join('\\n');\n\n    const plaintext = 'short message\\nnext line\\n\ud55c\uad6d\uc5b4/\uc870\uc120\ub9d0';\n    const message = await openpgp.readCleartextMessage({ cleartextMessage });\n    const pubKey2 = await openpgp.readKey({ armoredKey: pub_key_arm2 });\n    const pubKey3 = await openpgp.readKey({ armoredKey: pub_key_arm3 });\n\n    const keyIDs = message.getSigningKeyIDs();\n\n    expect(pubKey2.getKeys(keyIDs[0])).to.not.be.empty;\n    expect(pubKey3.getKeys(keyIDs[1])).to.not.be.empty;\n\n    return openpgp.verify({ verificationKeys:[pubKey2, pubKey3], message, config: { minRSABits: 1024 } }).then(async function({ signatures, data }) {\n      expect(data).to.equal(plaintext);\n      expect(signatures).to.have.length(2);\n      expect(await signatures[0].verified).to.be.true;\n      expect(await signatures[1].verified).to.be.true;\n      expect((await signatures[0].signature).packets.length).to.equal(1);\n      expect((await signatures[1].signature).packets.length).to.equal(1);\n    });\n  });\n\n  it('Verify latin-1 signed message', async function() {\n    const latin1Binary = util.hexToUint8Array('48e46c6cf62057e86c74');\n    const message = await openpgp.createMessage({ binary: latin1Binary });\n\n    message.appendSignature(`-----BEGIN PGP SIGNATURE-----\n\niQIzBAEBCAAdFiEET5+J9VBawdGiYGMc2xGHud1faTsFAl5lE/AACgkQ2xGHud1f\naTtIuw//YWrVaXLyP8sGBc0uUSLxQbmfQQYV8Oq8Vsg+jV4orc73wmEy8+Nj5m2g\nfFEPaWy07dfDBtv874XCsZmCM+ZhwkGaT9lwcCxkxNZeywTE5JRS1/6Ky3G4gDZ/\nQozTXr/ZNPXF6bBENqhfqeO2xkD577bjiPu5wLcu3/RR39YnWp5zQu9ynJbpwobz\nHHQW5TgSUgi/9tInQ+cc7vMkHzfe2Zg45HkyaStBW1x7Fm9FLv8GNw1R2jVbUlsX\nSEL7yPrsZAmgyu1ifMrTTY4vunuUNUFiGZN9UC75b7s4tjKkvJ0sfdQusC0vmcE0\nWq7dAoeX72B94TITuXldDGIfL01smycm+mEvf/kXxQg81wj4la72IzhdWeC6r4PF\n558QDEtZy984iL8RJKpbjwgsxyvfM9zf9qtmuNdscbZaZsx9LRe21uaKhX8yJsAU\njCgyjM5e7CMdvBUyxrpGzS+mP/rh77r2TXkg6u2+8Nj4osxwkfxvDIGpJfaIWl2a\nsNQ4Bsgm6rcNYaxUVbOsBFJddBb503KpTX5aK8TuC6AINg6bV6rmfj2Jc/QX4eHb\nXgm6EyJo74z5R7YvA3XdUZf1sfwfoMLbbUqpeHEZOcWy4vrS79Omx1MyPxKHPiXU\nPAAeuQTUrcJdZeJ86eQ9cCUB216HCwSKOWTQRzL+hBWKXij4WD4=\n=ZEFm\n-----END PGP SIGNATURE-----`);\n\n    const pubKey = await openpgp.readKey({ armoredKey: pub_latin1_msg });\n\n    return message.verify([pubKey]).then(async verifiedSig => {\n      expect(await stream.readToEnd(message.getLiteralData())).to.equal(latin1Binary);\n      expect(verifiedSig).to.exist;\n      expect(verifiedSig).to.have.length(1);\n      expect(await verifiedSig[0].verified).to.be.true;\n      expect((await verifiedSig[0].signature).packets.length).to.equal(1);\n    });\n  });\n\n\n  it('Verify cleartext signed message with trailing spaces from GPG', async function() {\n    const cleartextMessage =\n      `-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA1\n\nspace: \nspace and tab: \\t\nno trailing space\n\ntab:\\t\ntab and space:\\t \n-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niJwEAQECAAYFAlrZzCQACgkQ4IT3RGwgLJeWggP+Pb33ubbELIzg9/imM+zlR063\ng0FbG4B+RGZNFSbaDArUgh9fdVqBy8M9vvbbDMBalSiQxY09Lrasfb+tsomrygbN\nNisuPRa5phPhn1bB4hZDb2ed/iK41CNyU7QHuv4AAvLC0mMamRnEg0FW2M2jZLGh\nzmuVOdNuWQqxT9Sqa84=\n=bqAR\n-----END PGP SIGNATURE-----`;\n\n    const plaintext = 'space: \\nspace and tab: \\t\\nno trailing space\\n  \\ntab:\\t\\ntab and space:\\t ';\n    const message = await openpgp.readCleartextMessage({ cleartextMessage });\n    const pubKey = await openpgp.readKey({ armoredKey: pub_key_arm2 });\n\n    const keyIDs = message.getSigningKeyIDs();\n\n    expect(pubKey.getKeys(keyIDs[0])).to.not.be.empty;\n\n    const { signatures, data } = await openpgp.verify({\n      verificationKeys:[pubKey],\n      message,\n      config: { minRSABits: 1024, rejectMessageHashAlgorithms: new Set() }\n    });\n    expect(data).to.equal(plaintext.replace(/[ \\t]+$/mg, ''));\n    expect(signatures).to.have.length(1);\n    expect(await signatures[0].verified).to.be.true;\n    expect((await signatures[0].signature).packets.length).to.equal(1);\n  });\n\n  it('Verify cleartext signed message with trailing spaces incorrectly normalised (from OpenPGP.js v3.0.9-v5.3.1)', async function() {\n    // We used to not strip trailing whitespace with \\r\\n line endings when signing cleartext messages\n    const armoredSignature = `-----BEGIN PGP SIGNATURE-----\nVersion: OpenPGP.js v5.3.1\n\nwrMEAQEIAAYFAmLjqsQAIQkQ4IT3RGwgLJcWIQTX0bHexsqUZwA0RcXghPdE\nbCAsl2TvBADLOHYXevDSc3LtLRYR1HteijL/MssCCoZIfuGihd5AzJpD2h2j\nL8UuxlfERJn15RlFsDzlkMNMefJp5ltC8kKcf+HTuBUi+xf2t2nvlf8CrdjY\nvcEqswjkODDxxZ842h0sC0ZtbzWuMXIvODEdzZxBjhlmZmv9VKQ5uyb0oD/5\nWQ==\n=o2gq\n-----END PGP SIGNATURE-----`;\n    const cleartextMessage = `\n-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA256\n\nthis text    \nused to be incorrectly normalised\n${armoredSignature}\n`;\n\n    const signedText = 'this text    \\r\\nused to be incorrectly normalised';\n    const message = await openpgp.readCleartextMessage({ cleartextMessage });\n    const pubKey = await openpgp.readKey({ armoredKey: pub_key_arm2 });\n\n    // Direct verification won't work since the signed data was not stripped of the trailing whitespaces,\n    // as required for cleartext messages. Verification would always fail also in the affected OpenPGP.js versions.\n    await expect(openpgp.verify({\n      verificationKeys:[pubKey],\n      message,\n      config: { minRSABits: 1024 },\n      expectSigned: true\n    })).to.be.rejectedWith(/Signed digest did not match/);\n\n    // The signature should be verifiable over non-normalised text\n    const { signatures, data } = await openpgp.verify({\n      verificationKeys:[pubKey],\n      message: await openpgp.createMessage({ text: signedText }),\n      signature: await openpgp.readSignature({ armoredSignature }),\n      config: { minRSABits: 1024 },\n      expectSigned: true\n    });\n    expect(data).to.equal(signedText);\n    expect(signatures).to.have.length(1);\n    expect(await signatures[0].verified).to.be.true;\n  });\n\n  it('Sign and verify cleartext signed message with trailing spaces correctly normalised', async function() {\n    const pubKey = await openpgp.readKey({ armoredKey: pub_key_arm2 });\n    const privKey = await openpgp.decryptKey({\n      privateKey: await openpgp.readKey({ armoredKey: priv_key_arm2 }),\n      passphrase: 'hello world'\n    });\n    const config = { minRSABits: 1024 };\n\n    const message = await openpgp.createCleartextMessage({\n      text: 'this text    \\r\\nused to be incorrectly normalised'\n    });\n    const expectedText = 'this text\\nused to be incorrectly normalised';\n    expect(message.getText()).to.equal(expectedText);\n    const cleartextMessage = await openpgp.sign({ message, signingKeys: privKey, config, format: 'armored' });\n    const { signatures, data } = await openpgp.verify({\n      message: await openpgp.readCleartextMessage({ cleartextMessage }),\n      verificationKeys:[pubKey],\n      config\n    });\n    expect(data).to.equal(expectedText);\n    expect(signatures).to.have.length(1);\n    expect(await signatures[0].verified).to.be.true;\n  });\n\n  function tests() {\n    it('Verify signed message with trailing spaces from GPG', async function() {\n      const armoredMessage =\n        `-----BEGIN PGP MESSAGE-----\nVersion: GnuPG v1\n\nowGbwMvMyMT4oOW7S46CznTG01El3MUFicmpxbolqcUlUTev14K5Vgq8XGCGQmJe\nikJJYpKVAicvV16+QklRYmZOZl66AliWl0sBqBAkzQmmwKohBnAqdMxhYWRkYmBj\nZQIZy8DFKQCztusM8z+Vt/svG80IS/etn90utv/T16jquk69zPvp6t9F16ryrwpb\nkfVlS5Xl38KnVYxWvIor0nao6WUczA4vvZX9TXPWnnW3tt1vbZoiqWUjYjjjhuKG\n4DtmMTuL3TW6/zNzVfWp/Q11+71O8RGnXMsBvWM6mSqX75uLiPo6HRaUDHnvrfCP\nyYDnCgA=\n=15ki\n-----END PGP MESSAGE-----`;\n\n      const plaintext = 'space: \\nspace and tab: \\t\\nno trailing space\\n  \\ntab:\\t\\ntab and space:\\t ';\n      const message = await openpgp.readMessage({ armoredMessage });\n      const pubKey = await openpgp.readKey({ armoredKey: pub_key_arm2 });\n\n      const keyIDs = message.getSigningKeyIDs();\n      expect(pubKey.getKeys(keyIDs[0])).to.not.be.empty;\n\n      return openpgp.verify({ verificationKeys: [pubKey], message, config: { minRSABits: 1024 } }).then(async ({ data, signatures }) => {\n        expect(data).to.equal(plaintext);\n        expect(signatures).to.have.length(1);\n        if (openpgp.config.rejectMessageHashAlgorithms.has(openpgp.enums.hash.sha1)) {\n          await expect(signatures[0].verified).to.be.rejected;\n        } else {\n          expect(await signatures[0].verified).to.be.true;\n        }\n        expect((await signatures[0].signature).packets.length).to.equal(1);\n      });\n    });\n\n    it('Streaming verify signed message with trailing spaces from GPG', async function() {\n      const armoredMessage =\n        `-----BEGIN PGP MESSAGE-----\nVersion: GnuPG v1\n\nowGbwMvMyMT4oOW7S46CznTG01El3MUFicmpxbolqcUlUTev14K5Vgq8XGCGQmJe\nikJJYpKVAicvV16+QklRYmZOZl66AliWl0sBqBAkzQmmwKohBnAqdMxhYWRkYmBj\nZQIZy8DFKQCztusM8z+Vt/svG80IS/etn90utv/T16jquk69zPvp6t9F16ryrwpb\nkfVlS5Xl38KnVYxWvIor0nao6WUczA4vvZX9TXPWnnW3tt1vbZoiqWUjYjjjhuKG\n4DtmMTuL3TW6/zNzVfWp/Q11+71O8RGnXMsBvWM6mSqX75uLiPo6HRaUDHnvrfCP\nyYDnCgA=\n=15ki\n-----END PGP MESSAGE-----`.split('');\n\n      const plaintext = 'space: \\nspace and tab: \\t\\nno trailing space\\n  \\ntab:\\t\\ntab and space:\\t ';\n      await stream.loadStreamsPonyfill();\n      const message = await openpgp.readMessage({\n        armoredMessage: new stream.ReadableStream({\n          async pull(controller) {\n            await new Promise(setTimeout);\n            controller.enqueue(armoredMessage.shift());\n            if (!armoredMessage.length) controller.close();\n          }\n        })\n      });\n      const pubKey = await openpgp.readKey({ armoredKey: pub_key_arm2 });\n\n      const keyIDs = message.getSigningKeyIDs();\n      expect(pubKey.getKeys(keyIDs[0])).to.not.be.empty;\n\n      return openpgp.verify({ verificationKeys: [pubKey], message, config: { minRSABits: 1024 } }).then(async function(cleartextSig) {\n        expect(cleartextSig).to.exist;\n        expect(await stream.readToEnd(cleartextSig.data)).to.equal(plaintext);\n        expect(cleartextSig.signatures).to.have.length(1);\n        if (!openpgp.config.rejectMessageHashAlgorithms.has(openpgp.enums.hash.sha1)) {\n          expect(await cleartextSig.signatures[0].verified).to.be.true;\n        } else {\n          await expect(cleartextSig.signatures[0].verified).to.be.rejectedWith('Insecure message hash algorithm: SHA1');\n        }\n        expect((await cleartextSig.signatures[0].signature).packets.length).to.equal(1);\n      });\n    });\n\n    it('Verify signed message with missing signature packet', async function() {\n      const armoredMessage =\n        `-----BEGIN PGP MESSAGE-----\nVersion: OpenPGP.js v3.1.3\nComment: https://openpgpjs.org\n\nyFgBO8LLzMjE+KDlu0uOgs50xtNRJdzFBYnJqcW6JanFJVE3r9eCuVYKvFxg\nhkJiXopCSWKSlQInL1devkJJUWJmTmZeugJYlpdLAagQJM0JpsCqIQZwKgAA\n\n=D6TZ\n-----END PGP MESSAGE-----`;\n\n      const plaintext = 'space: \\nspace and tab: \\t\\nno trailing space\\n  \\ntab:\\t\\ntab and space:\\t ';\n      const message = await openpgp.readMessage({ armoredMessage });\n      const pubKey = await openpgp.readKey({ armoredKey: pub_key_arm2 });\n\n      const keyIDs = message.getSigningKeyIDs();\n      expect(pubKey.getKeys(keyIDs[0])).to.not.be.empty;\n\n      return openpgp.verify({ verificationKeys: [pubKey], message, config: { minRSABits: 1024 } }).then(async ({ data, signatures }) => {\n        expect(data).to.equal(plaintext);\n        expect(signatures).to.have.length(0);\n      });\n    });\n\n    it('Streaming verify signed message with missing signature packet', async function() {\n      const armoredMessage =\n        `-----BEGIN PGP MESSAGE-----\nVersion: OpenPGP.js v3.1.3\nComment: https://openpgpjs.org\n\nyFgBO8LLzMjE+KDlu0uOgs50xtNRJdzFBYnJqcW6JanFJVE3r9eCuVYKvFxg\nhkJiXopCSWKSlQInL1devkJJUWJmTmZeugJYlpdLAagQJM0JpsCqIQZwKgAA\n\n=D6TZ\n-----END PGP MESSAGE-----`.split('');\n\n      const plaintext = 'space: \\nspace and tab: \\t\\nno trailing space\\n  \\ntab:\\t\\ntab and space:\\t ';\n      await stream.loadStreamsPonyfill();\n      const message = await openpgp.readMessage({\n        armoredMessage: new stream.ReadableStream({\n          async pull(controller) {\n            await new Promise(setTimeout);\n            controller.enqueue(armoredMessage.shift());\n            if (!armoredMessage.length) controller.close();\n          }\n        })\n      });\n      const pubKey = await openpgp.readKey({ armoredKey: pub_key_arm2 });\n\n      const keyIDs = message.getSigningKeyIDs();\n      expect(pubKey.getKeys(keyIDs[0])).to.not.be.empty;\n\n      return openpgp.verify({ verificationKeys: [pubKey], message, config: { minRSABits: 1024 } }).then(async ({ data, signatures }) => {\n        expect(await stream.readToEnd(data)).to.equal(plaintext);\n        expect(signatures).to.have.length(1);\n        await expect(signatures[0].verified).to.be.rejectedWith('Corresponding signature packet missing');\n        expect((await signatures[0].signature).packets.length).to.equal(0);\n      });\n    });\n  }\n\n  tests();\n\n  let rejectMessageHashAlgorithms;\n  tryTests('Accept SHA-1 signatures', tests, {\n    if: true,\n    before: function() {\n      ({ rejectMessageHashAlgorithms } = openpgp.config);\n      Object.assign(openpgp.config, { rejectMessageHashAlgorithms: new Set([openpgp.enums.hash.md5, openpgp.enums.hash.ripemd]) });\n    },\n    after: function() {\n      Object.assign(openpgp.config, { rejectMessageHashAlgorithms });\n    }\n  });\n\n  it('Sign text with openpgp.sign and verify with openpgp.verify leads to same string cleartext and valid signatures', async function() {\n    const plaintext = 'short message\\nnext line \\n\ud55c\uad6d\uc5b4/\uc870\uc120\ub9d0';\n    const pubKey = await openpgp.readKey({ armoredKey: pub_key_arm2 });\n    const privKey = await openpgp.decryptKey({\n      privateKey: await openpgp.readKey({ armoredKey: priv_key_arm2 }),\n      passphrase: 'hello world'\n    });\n\n    const config = { minRSABits: 1024 };\n    return openpgp.sign({ signingKeys: privKey, message: await openpgp.createCleartextMessage({ text: plaintext }), config }).then(async signed => {\n\n      const message = await openpgp.readCleartextMessage({ cleartextMessage: signed });\n      return openpgp.verify({ verificationKeys:[pubKey], message, config });\n\n    }).then(async function({ data, signatures }) {\n      expect(data).to.equal(plaintext.replace(/[ \\t\\r]+$/mg, ''));\n      expect(signatures).to.have.length(1);\n      expect(await signatures[0].verified).to.be.true;\n      expect((await signatures[0].signature).packets.length).to.equal(1);\n    });\n  });\n\n  it('Sign text with openpgp.sign and verify with openpgp.verify leads to same string cleartext and valid signatures -- escape armored message', async function() {\n    const plaintext = pub_key_arm2;\n    const pubKey = await openpgp.readKey({ armoredKey: pub_key_arm2 });\n    const privKey = await openpgp.decryptKey({\n      privateKey: await openpgp.readKey({ armoredKey: priv_key_arm2 }),\n      passphrase: 'hello world'\n    });\n\n    const config = { minRSABits: 1024 };\n    return openpgp.sign({ signingKeys: privKey, message: await openpgp.createCleartextMessage({ text: plaintext }), config }).then(async signed => {\n\n      const message = await openpgp.readCleartextMessage({ cleartextMessage: signed });\n      return openpgp.verify({ verificationKeys: pubKey, message, config });\n\n    }).then(async function({ data, signatures }) {\n      expect(data).to.equal(plaintext);\n      expect(signatures).to.have.length(1);\n      expect(await signatures[0].verified).to.be.true;\n      expect((await signatures[0].signature).packets.length).to.equal(1);\n    });\n  });\n\n  it('Sign text with openpgp.sign and verify with openpgp.verify leads to same string cleartext and valid signatures -- trailing spaces', async function() {\n    const plaintext = 'space: \\nspace and tab: \\t\\nno trailing space\\n  \\ntab:\\t\\ntab and space:\\t ';\n    const pubKey = await openpgp.readKey({ armoredKey: pub_key_arm2 });\n    const privKey = await openpgp.decryptKey({\n      privateKey: await openpgp.readKey({ armoredKey: priv_key_arm2 }),\n      passphrase: 'hello world'\n    });\n\n    const config = { minRSABits: 1024 };\n    return openpgp.sign({ signingKeys: privKey, message: await openpgp.createCleartextMessage({ text: plaintext }), config }).then(async signed => {\n\n      const message = await openpgp.readCleartextMessage({ cleartextMessage: signed });\n      return openpgp.verify({ verificationKeys: pubKey, message, config });\n\n    }).then(async function({ data, signatures }) {\n      expect(data).to.equal(plaintext.replace(/[ \\t]+$/mg, ''));\n      expect(signatures).to.have.length(1);\n      expect(await signatures[0].verified).to.be.true;\n      expect((await signatures[0].signature).packets.length).to.equal(1);\n    });\n  });\n\n  it('Sign text with openpgp.sign and verify with openpgp.verify leads to same bytes cleartext and valid signatures - armored', async function() {\n    const plaintext = util.stringToUint8Array('short message\\nnext line \\n\ud55c\uad6d\uc5b4/\uc870\uc120\ub9d0');\n    const pubKey = await openpgp.readKey({ armoredKey: pub_key_arm2 });\n    const privKey = await openpgp.decryptKey({\n      privateKey: await openpgp.readKey({ armoredKey: priv_key_arm2 }),\n      passphrase: 'hello world'\n    });\n\n    const config = { minRSABits: 1024 };\n    return openpgp.sign({ signingKeys: privKey, message: await openpgp.createMessage({ binary: plaintext }), config }).then(async signed => {\n\n      const message = await openpgp.readMessage({ armoredMessage: signed });\n      return openpgp.verify({ verificationKeys: pubKey, message, format: 'binary', config });\n\n    }).then(async function({ data, signatures }) {\n      expect(data).to.deep.equal(plaintext);\n      expect(signatures).to.have.length(1);\n      expect(await signatures[0].verified).to.be.true;\n      expect((await signatures[0].signature).packets.length).to.equal(1);\n    });\n  });\n\n  it('Sign text with openpgp.sign and verify with openpgp.verify leads to same bytes cleartext and valid signatures - not armored', async function() {\n    const plaintext = util.stringToUint8Array('short message\\nnext line \\n\ud55c\uad6d\uc5b4/\uc870\uc120\ub9d0');\n    const pubKey = await openpgp.readKey({ armoredKey: pub_key_arm2 });\n    const privKey = await openpgp.decryptKey({\n      privateKey: await openpgp.readKey({ armoredKey: priv_key_arm2 }),\n      passphrase: 'hello world'\n    });\n\n    const config = { minRSABits: 1024 };\n    return openpgp.sign({ signingKeys: privKey, message: await openpgp.createMessage({ binary: plaintext }), format: 'binary', config }).then(async signed => {\n\n      const message = await openpgp.readMessage({ binaryMessage: signed });\n      return openpgp.verify({ verificationKeys: pubKey, message, format: 'binary', config });\n\n    }).then(async function({ data, signatures }) {\n      expect(data).to.deep.equal(plaintext);\n      expect(signatures).to.have.length(1);\n      expect(await signatures[0].verified).to.be.true;\n      expect((await signatures[0].signature).packets.length).to.equal(1);\n    });\n  });\n\n  it('Should verify detached signature with some unknown versions of Signature packets', async function () {\n    // Test from openpgp-interoperability-test-suite to ensure forward compatibility: https://tests.sequoia-pgp.org/?q=forward-compat\n    const plaintext = 'hello world';\n\n    // This signature includes two Signature packets: a v4 one (verifiable) and a 'dummy' v23 one.\n    const signatureUnknownTrailingPacketVersion = `-----BEGIN PGP SIGNATURE-----\n\nwnUEARYKACcFgmSVpTQJkHEwNzxPuQajFiEE2KiARjeh+fU3dy+5cTA3PE+5\nBqMAAKZNAP0fhECUqrE2Ts7Ho8/fuLFT+9jsGIGo0EviIEmW77vyhQEAtOBa\nN77tTSawgDqnjIRH5RyI6YNC1LNz01VHCYWwegfCwTsXAAEKAG8FgmSVZN4J\nEPv8yCoBXnMwRxQAAAAAAB4AIHNhbHRAbm90YXRpb25zLnNlcXVvaWEtcGdw\nLm9yZ8jF+epDaQ8yqg9h1mb0LcDLKC71kHyESC8fqFt9fNFsFiEE0aZuGiOx\ngsmYD3iM+/zIKgFeczAAADLxDACKH0qwrZW+Eu3McHHfKojqlHoJ+Ofqotui\nGtcyx3HrE86xQHQl6346Joweomlzo2A6cjhT/nxL88sfy9yTQyUyKaON0wHz\n4WI+Onu8rSaG99J/u34dDIPqFu5DzhwCrkv0IQwGYfDxG6Lrxg7gsxui2KAt\n4rJqlbaeRGOTeNmew6aH74foUp86LWjdasanZ3RXxjk3yP+R/7nquQjkVGqE\njElkMwFh44TwTHlrXfI90Ki4gNrFQfbQCQm2v66rT0t3BSgVrL+FZIyXjjOh\ndp83PCrkcvOcbBalvtbYPd5+23cGAylm5hkC9bxQUwUJrcJezdwSpxF5+Vgj\nIkeanKfU2BhKry3Hpn3PL6vLfVkK/w0wUEbDMkFRbGAmW1sPCJWDSX6Zy75/\nLi0CQ3u6tg3/m9VHUdwN5iNVk3g7AtV2eLinv4fKIuVUxUIyvacro+RBxGNc\nEnZwTO2p2I0xifnoRizITFXclUc9J4vK+whpi9PHH5uoqRGcoer72rtjIIs=\n=nReB\n-----END PGP SIGNATURE-----`;\n\n    const publicKey = `-----BEGIN PGP PUBLIC KEY BLOCK-----\n\nxjMEZJWk4RYJKwYBBAHaRw8BAQdA7p5RuL+Z05qld6xRz6tbJ+9pmDowaCYr\ntMOW8MXHAx3NFW5hbWUgPGVtYWlsQHRlc3QuY29tPsKMBBAWCgA+BYJklaTh\nBAsJBwgJkHEwNzxPuQajAxUICgQWAAIBAhkBApsDAh4BFiEE2KiARjeh+fU3\ndy+5cTA3PE+5BqMAAB5pAQDUHdYs3HRK6yJZ6IrK8lfmLzeqSgW2j9wLG/zF\nTXIARQEAj0PdOzSy3q75VIQraDSHWpBAue8QNEKV4Q8hlkJvmgPOOARklaTh\nEgorBgEEAZdVAQUBAQdAR9bBkzKzh24TB6gJVHR49BWnhTmeF5+vA3PXtX/b\nRHkDAQgHwngEGBYIACoFgmSVpOEJkHEwNzxPuQajApsMFiEE2KiARjeh+fU3\ndy+5cTA3PE+5BqMAAFjVAQDKqKwFLKX+N7le3cDLHAYSqc4AWpksKS4eSBLa\nuDvEBgD+LCEUOPejUTCMqPyd04ssdOq1AlMJOmUGUwLk7kFP7Aw=\n=Q9Px\n-----END PGP PUBLIC KEY BLOCK-----`;\n\n    const { signatures, data } = await openpgp.verify({\n      message: await openpgp.createMessage({ text: plaintext }),\n      signature: await openpgp.readSignature({ armoredSignature: signatureUnknownTrailingPacketVersion }),\n      verificationKeys: await openpgp.readKey({ armoredKey: publicKey })\n    });\n    expect(data).to.equal(plaintext);\n    expect(signatures).to.have.length(1);\n    expect(await signatures[0].verified).to.be.true;\n    expect((await signatures[0].signature).packets.length).to.equal(1);\n  });\n\n  it('Should verify cleartext signature with some unknown versions of Signature packets', async function () {\n    // Test to ensure forward compatibility:\n    // this signature includes two Signature packets: a v4 one (verifiable) and a 'dummy' v23 one.\n    const signatureUnknownTrailingPacketVersion = `-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA512\n\nhello world\n-----BEGIN PGP SIGNATURE-----\n\nwnUEARYKACcFgmSVpTQJkHEwNzxPuQajFiEE2KiARjeh+fU3dy+5cTA3PE+5\nBqMAAKZNAP0fhECUqrE2Ts7Ho8/fuLFT+9jsGIGo0EviIEmW77vyhQEAtOBa\nN77tTSawgDqnjIRH5RyI6YNC1LNz01VHCYWwegfCwTsXAAEKAG8FgmSVZN4J\nEPv8yCoBXnMwRxQAAAAAAB4AIHNhbHRAbm90YXRpb25zLnNlcXVvaWEtcGdw\nLm9yZ8jF+epDaQ8yqg9h1mb0LcDLKC71kHyESC8fqFt9fNFsFiEE0aZuGiOx\ngsmYD3iM+/zIKgFeczAAADLxDACKH0qwrZW+Eu3McHHfKojqlHoJ+Ofqotui\nGtcyx3HrE86xQHQl6346Joweomlzo2A6cjhT/nxL88sfy9yTQyUyKaON0wHz\n4WI+Onu8rSaG99J/u34dDIPqFu5DzhwCrkv0IQwGYfDxG6Lrxg7gsxui2KAt\n4rJqlbaeRGOTeNmew6aH74foUp86LWjdasanZ3RXxjk3yP+R/7nquQjkVGqE\njElkMwFh44TwTHlrXfI90Ki4gNrFQfbQCQm2v66rT0t3BSgVrL+FZIyXjjOh\ndp83PCrkcvOcbBalvtbYPd5+23cGAylm5hkC9bxQUwUJrcJezdwSpxF5+Vgj\nIkeanKfU2BhKry3Hpn3PL6vLfVkK/w0wUEbDMkFRbGAmW1sPCJWDSX6Zy75/\nLi0CQ3u6tg3/m9VHUdwN5iNVk3g7AtV2eLinv4fKIuVUxUIyvacro+RBxGNc\nEnZwTO2p2I0xifnoRizITFXclUc9J4vK+whpi9PHH5uoqRGcoer72rtjIIs=\n=nReB\n-----END PGP SIGNATURE-----`;\n\n    const publicKey = `-----BEGIN PGP PUBLIC KEY BLOCK-----\n\nxjMEZJWk4RYJKwYBBAHaRw8BAQdA7p5RuL+Z05qld6xRz6tbJ+9pmDowaCYr\ntMOW8MXHAx3NFW5hbWUgPGVtYWlsQHRlc3QuY29tPsKMBBAWCgA+BYJklaTh\nBAsJBwgJkHEwNzxPuQajAxUICgQWAAIBAhkBApsDAh4BFiEE2KiARjeh+fU3\ndy+5cTA3PE+5BqMAAB5pAQDUHdYs3HRK6yJZ6IrK8lfmLzeqSgW2j9wLG/zF\nTXIARQEAj0PdOzSy3q75VIQraDSHWpBAue8QNEKV4Q8hlkJvmgPOOARklaTh\nEgorBgEEAZdVAQUBAQdAR9bBkzKzh24TB6gJVHR49BWnhTmeF5+vA3PXtX/b\nRHkDAQgHwngEGBYIACoFgmSVpOEJkHEwNzxPuQajApsMFiEE2KiARjeh+fU3\ndy+5cTA3PE+5BqMAAFjVAQDKqKwFLKX+N7le3cDLHAYSqc4AWpksKS4eSBLa\nuDvEBgD+LCEUOPejUTCMqPyd04ssdOq1AlMJOmUGUwLk7kFP7Aw=\n=Q9Px\n-----END PGP PUBLIC KEY BLOCK-----`;\n\n    const { signatures } = await openpgp.verify({\n      message: await openpgp.readCleartextMessage({ cleartextMessage: signatureUnknownTrailingPacketVersion }),\n      verificationKeys: await openpgp.readKey({ armoredKey: publicKey })\n    });\n    expect(signatures).to.have.length(1);\n    expect(await signatures[0].verified).to.be.true;\n    expect((await signatures[0].signature).packets.length).to.equal(1);\n  });\n\n  it('Should verify cleartext message correctly when using a detached cleartext signature and binary literal data', async function () {\n    const plaintext = 'short message\\nnext line \\n\ud55c\uad6d\uc5b4/\uc870\uc120\ub9d0';\n    const pubKey = await openpgp.readKey({ armoredKey: pub_key_arm2 });\n    const privKey = await openpgp.decryptKey({\n      privateKey: await openpgp.readKey({ armoredKey: priv_key_arm2 }),\n      passphrase: 'hello world'\n    });\n\n    const config = { minRSABits: 1024 };\n    return openpgp.sign({ signingKeys: privKey, message: await openpgp.createMessage({ text: plaintext }), detached: true, config }).then(async armoredSignature => {\n      const signature = await openpgp.readSignature({ armoredSignature });\n      return openpgp.verify({ verificationKeys: pubKey, message: await openpgp.createMessage({ binary: util.encodeUTF8(plaintext) }), signature, config });\n    }).then(async function({ data, signatures }) {\n      expect(data).to.equal(plaintext);\n      expect(signatures).to.have.length(1);\n      expect(await signatures[0].verified).to.be.true;\n      expect((await signatures[0].signature).packets.length).to.equal(1);\n    });\n  });\n\n  it('Should verify cleartext message correctly when using a detached binary signature and text literal data', async function () {\n    const plaintext = 'short message\\nnext line \\n\ud55c\uad6d\uc5b4/\uc870\uc120\ub9d0';\n    const binaryPlaintext = util.encodeUTF8(plaintext);\n    const pubKey = await openpgp.readKey({ armoredKey: pub_key_arm2 });\n    const privKey = await openpgp.decryptKey({\n      privateKey: await openpgp.readKey({ armoredKey: priv_key_arm2 }),\n      passphrase: 'hello world'\n    });\n\n    const config = { minRSABits: 1024 };\n    return openpgp.sign({ signingKeys: privKey, message:await openpgp.createMessage({ binary: binaryPlaintext }), detached: true, config }).then(async armoredSignature => {\n      const signature = await openpgp.readSignature({ armoredSignature });\n      return openpgp.verify({ verificationKeys: pubKey, message: await openpgp.createMessage({ text: plaintext }), signature, config });\n\n    }).then(async function({ data, signatures }) {\n      expect(data).to.equal(plaintext);\n      expect(signatures).to.have.length(1);\n      expect(await signatures[0].verified).to.be.true;\n      expect((await signatures[0].signature).packets.length).to.equal(1);\n    });\n  });\n\n  it('Should verify encrypted cleartext message correctly when encrypting binary literal data with a canonical text signature', async function () {\n    const plaintext = 'short message\\nnext line \\n\ud55c\uad6d\uc5b4/\uc870\uc120\ub9d0';\n    const pubKey = await openpgp.readKey({ armoredKey: pub_key_arm2 });\n    const privKey = await openpgp.decryptKey({\n      privateKey: await openpgp.readKey({ armoredKey: priv_key_arm2 }),\n      passphrase: 'hello world'\n    });\n\n    const config = { minRSABits: 1024 };\n    return openpgp.sign({ signingKeys: privKey, message: await openpgp.createMessage({ text: plaintext }), detached: true, config }).then(async armoredSignature => {\n      const signature = await openpgp.readSignature({ armoredSignature });\n      return openpgp.encrypt({ message: await openpgp.createMessage({ binary: util.encodeUTF8(plaintext) }), encryptionKeys: [pubKey], signature, config });\n\n    }).then(async armoredMessage => {\n      const message = await openpgp.readMessage({ armoredMessage });\n      return openpgp.decrypt({ message, decryptionKeys: [privKey], verificationKeys: [pubKey], config });\n\n    }).then(async function({ data, signatures }) {\n      expect(data).to.equal(plaintext);\n      expect(signatures).to.have.length(1);\n      expect(await signatures[0].verified).to.be.true;\n      expect((await signatures[0].signature).packets.length).to.equal(1);\n    });\n  });\n\n  // TODO add test with multiple revocation signatures\n  it('Verify primary key revocation signatures', async function() {\n    const pubKey = await openpgp.readKey({ armoredKey: pub_revoked });\n    await pubKey.revocationSignatures[0].verify(\n      pubKey.keyPacket, openpgp.enums.signature.keyRevocation, { key: pubKey.keyPacket }\n    );\n  });\n\n  // TODO add test with multiple revocation signatures\n  it('Verify subkey revocation signatures', async function() {\n    const pubKey = await openpgp.readKey({ armoredKey: pub_revoked });\n    const revSig = pubKey.subkeys[0].revocationSignatures[0];\n    await revSig.verify(\n      pubKey.keyPacket, openpgp.enums.signature.subkeyRevocation, { key: pubKey.keyPacket, bind: pubKey.subkeys[0].keyPacket }\n    );\n  });\n\n  it('Verify key expiration date', async function() {\n    const pubKey = await openpgp.readKey({ armoredKey: pub_revoked });\n\n    expect(pubKey).to.exist;\n    expect(pubKey.users[0].selfCertifications[0].keyNeverExpires).to.be.false;\n    expect(pubKey.users[0].selfCertifications[0].keyExpirationTime).to.equal(5 * 365 * 24 * 60 * 60);\n  });\n\n  it('Write unhashed subpackets', async function() {\n    let pubKey = await openpgp.readKey({ armoredKey: pub_key_arm2 });\n    expect(pubKey.users[0].selfCertifications).to.exist;\n    pubKey = await openpgp.readKey({ armoredKey: pubKey.armor() });\n    expect(pubKey.users[0].selfCertifications).to.exist;\n  });\n\n  it('Write V4 signatures', async function() {\n    const pubKey = await openpgp.readKey({ armoredKey: pub_key_arm2 });\n    const pubKey2 = await openpgp.readKey({ armoredKey: pubKey.armor() });\n    expect(pubKey2).to.exist;\n    expect(pubKey.users[0].selfCertifications).to.eql(pubKey2.users[0].selfCertifications);\n  });\n\n  it('Verify a detached signature using appendSignature', async function() {\n    const detachedSig = ['-----BEGIN PGP SIGNATURE-----',\n      'Version: GnuPG v1.4.13 (Darwin)',\n      'Comment: GPGTools - https://gpgtools.org',\n      'Comment: Using GnuPG with Thunderbird - https://www.enigmail.net/',\n      '',\n      'iQEcBAEBCgAGBQJTqH5OAAoJENf7k/zfv8I8oFoH/R6EFTw2CYUQoOKSAQstWIHp',\n      'fVVseLOkFbByUV5eLuGVBNI3DM4GQ6C7dGntKAn34a1iTGcAIZH+fIhaZ2WtNdtA',\n      'R+Ijn8xDjbF/BWvcTBOaRvgw9b8viPxhkVYa3PioHYz6krt/LmFqFdp/phWZcqR4',\n      'jzWMX55h4FOw3YBNGiz2NuIg+iGrFRWPYgd8NVUmJKReZHs8C/6HGz7F4/A24k6Y',\n      '7xms9D6Er+MhspSl+1dlRdHjtXiRqC5Ld1hi2KBKc6YzgOLpVw5l9sffbnH+aRG4',\n      'dH+2J5U3elqBDK1i3GyG8ixLSB0FGW9+lhYNosZne2xy8SbQKdgsnTBnWSGevP0=',\n      '=xiih',\n      '-----END PGP SIGNATURE-----'].join('\\r\\n');\n\n    const content = ['Content-Type: multipart/mixed;',\n      ' boundary=\"------------070307080002050009010403\"',\n      '',\n      'This is a multi-part message in MIME format.',\n      '--------------070307080002050009010403',\n      'Content-Type: text/plain; charset=ISO-8859-1',\n      'Content-Transfer-Encoding: quoted-printable',\n      '',\n      'test11',\n      '',\n      '--------------070307080002050009010403',\n      'Content-Type: application/macbinary;',\n      ' name=\"test.bin\"',\n      'Content-Transfer-Encoding: base64',\n      'Content-Disposition: attachment;',\n      ' filename=\"test.bin\"',\n      '',\n      'dGVzdGF0dGFjaG1lbnQ=',\n      '--------------070307080002050009010403--',\n      ''].join('\\r\\n');\n\n    const publicKeyArmored = '-----BEGIN PGP PUBLIC KEY BLOCK-----\\r\\nVersion: OpenPGP.js v.1.20131116\\r\\nComment: Whiteout Mail - https://whiteout.io\\r\\n\\r\\nxsBNBFKODs4BB/9iOF4THsjQMY+WEpT7ShgKxj4bHzRRaQkqczS4nZvP0U3g\\r\\nqeqCnbpagyeKXA+bhWFQW4GmXtgAoeD5PXs6AZYrw3tWNxLKu2Oe6Tp9K/XI\\r\\nxTMQ2wl4qZKDXHvuPsJ7cmgaWqpPyXtxA4zHHS3WrkI/6VzHAcI/y6x4szSB\\r\\nKgSuhI3hjh3s7TybUC1U6AfoQGx/S7e3WwlCOrK8GTClirN/2mCPRC5wuIft\\r\\nnkoMfA6jK8d2OPrJ63shy5cgwHOjQg/xuk46dNS7tkvGmbaa+X0PgqSKB+Hf\\r\\nYPPNS/ylg911DH9qa8BqYU2QpNh9jUKXSF+HbaOM+plWkCSAL7czV+R3ABEB\\r\\nAAHNLVdoaXRlb3V0IFVzZXIgPHNhZmV3aXRobWUudGVzdHVzZXJAZ21haWwu\\r\\nY29tPsLAXAQQAQgAEAUCUo4O2gkQ1/uT/N+/wjwAAN2cB/9gFRmAfvEQ2qz+\\r\\nWubmT2EsSSnjPMxzG4uyykFoa+TaZCWo2Xa2tQghmU103kEkQb1OEjRjpgwJ\\r\\nYX9Kghnl8DByM686L5AXnRyHP78qRJCLXSXl0AGicboUDp5sovaa4rswQceH\\r\\nvcdWgZ/mgHTRoiQeJddy9k+H6MPFiyFaVcFwegVsmpc+dCcC8yT+qh8ZIbyG\\r\\nRJU60PmKKN7LUusP+8DbSv39zCGJCBlVVKyA4MzdF5uM+sqTdXbKzOrT5DGd\\r\\nCZaox4s+w16Sq1rHzZKFWfQPfKLDB9pyA0ufCVRA3AF6BUi7G3ZqhZiHNhMP\\r\\nNvE45V/hS1PbZcfPVoUjE2qc1Ix1\\r\\n=7Wpe\\r\\n-----END PGP PUBLIC KEY BLOCK-----';\n    const publicKey = await openpgp.readKey({ armoredKey: publicKeyArmored });\n\n    const message = await openpgp.createMessage({ text: content });\n    await message.appendSignature(detachedSig);\n    const { data, signatures } = await openpgp.verify({ verificationKeys:[publicKey], message, config: { minRSABits: 1024 } });\n    expect(data).to.equal(content);\n    expect(signatures).to.have.length(1);\n    expect(await signatures[0].verified).to.be.true;\n    expect((await signatures[0].signature).packets.length).to.equal(1);\n    expect(await signatures[0].verified).to.be.true;\n  });\n\n  it('Detached signature signing and verification', async function() {\n    const message = await openpgp.createMessage({ text: 'hello' });\n    const pubKey = await openpgp.readKey({ armoredKey: pub_key_arm2 });\n    const privKey = await openpgp.decryptKey({\n      privateKey: await openpgp.readKey({ armoredKey: priv_key_arm2 }),\n      passphrase: 'hello world'\n    });\n\n    const opt = { userIDs: { name:'test', email:'a@b.com' }, format: 'object' };\n    const { privateKey: generatedKey } = await openpgp.generateKey(opt);\n    const armoredSignature = await openpgp.sign({ signingKeys: [generatedKey, privKey], message, detached: true, config: { minRSABits: 1024 } });\n    const signature = await openpgp.readSignature({ armoredSignature });\n    const { data, signatures } = await openpgp.verify({ verificationKeys: [generatedKey.toPublic(), pubKey], message, signature, config: { minRSABits: 1024 } });\n    expect(data).to.equal('hello');\n    expect(await signatures[0].verified).to.be.true;\n    expect(await signatures[1].verified).to.be.true;\n  });\n\n  it('Sign message with key without password', function() {\n    const opt = { userIDs: { name:'test', email:'a@b.com' }, passphrase: null, format: 'object' };\n    return openpgp.generateKey(opt).then(async function({ privateKey: key }) {\n      const message = await openpgp.createMessage({ text: 'hello world' });\n      return message.sign([key]);\n    });\n  });\n\n  it('Verify signed key', async function() {\n    const signedArmor = [\n      '-----BEGIN PGP PUBLIC KEY BLOCK-----',\n      'Version: GnuPG v1',\n      '',\n      'mI0EUmEvTgEEANyWtQQMOybQ9JltDqmaX0WnNPJeLILIM36sw6zL0nfTQ5zXSS3+',\n      'fIF6P29lJFxpblWk02PSID5zX/DYU9/zjM2xPO8Oa4xo0cVTOTLj++Ri5mtr//f5',\n      'GLsIXxFrBJhD/ghFsL3Op0GXOeLJ9A5bsOn8th7x6JucNKuaRB6bQbSPABEBAAG0',\n      'JFRlc3QgTWNUZXN0aW5ndG9uIDx0ZXN0QGV4YW1wbGUuY29tPoi5BBMBAgAjBQJS',\n      'YS9OAhsvBwsJCAcDAgEGFQgCCQoLBBYCAwECHgECF4AACgkQSmNhOk1uQJQwDAP6',\n      'AgrTyqkRlJVqz2pb46TfbDM2TDF7o9CBnBzIGoxBhlRwpqALz7z2kxBDmwpQa+ki',\n      'Bq3jZN/UosY9y8bhwMAlnrDY9jP1gdCo+H0sD48CdXybblNwaYpwqC8VSpDdTndf',\n      '9j2wE/weihGp/DAdy/2kyBCaiOY1sjhUfJ1GogF49rCIRgQQEQIABgUCVuXBfQAK',\n      'CRARJ5QDyxae+O0fAJ9hUQPejXvZv6VW1Q3/Pm3+x2wfJACgwFg9NlrPPfejoC1w',\n      'P+z+vE5NFA24jQRSYS9OAQQA6R/PtBFaJaT4jq10yqASk4sqwVMsc6HcifM5lSdx',\n      'zExFP74naUMMyEsKHP53QxTF0GrqusagQg/ZtgT0CN1HUM152y7ACOdp1giKjpMz',\n      'OTQClqCoclyvWOFB+L/SwGEIJf7LSCErwoBuJifJc8xAVr0XX0JthoW+uP91eTQ3',\n      'XpsAEQEAAYkBPQQYAQIACQUCUmEvTgIbLgCoCRBKY2E6TW5AlJ0gBBkBAgAGBQJS',\n      'YS9OAAoJEOCE90RsICyXuqIEANmmiRCASF7YK7PvFkieJNwzeK0V3F2lGX+uu6Y3',\n      'Q/Zxdtwc4xR+me/CSBmsURyXTO29OWhPGLszPH9zSJU9BdDi6v0yNprmFPX/1Ng0',\n      'Abn/sCkwetvjxC1YIvTLFwtUL/7v6NS2bZpsUxRTg9+cSrMWWSNjiY9qUKajm1tu',\n      'zPDZXAUEAMNmAN3xXN/Kjyvj2OK2ck0XW748sl/tc3qiKPMJ+0AkMF7Pjhmh9nxq',\n      'E9+QCEl7qinFqqBLjuzgUhBU4QlwX1GDAtNTq6ihLMD5v1d82ZC7tNatdlDMGWnI',\n      'dvEMCv2GZcuIqDQ9rXWs49e7tq1NncLYhz3tYjKhoFTKEIq3y3Pp',\n      '=fvK7',\n      '-----END PGP PUBLIC KEY BLOCK-----'\n    ].join('\\n');\n\n    const signedKey = await openpgp.readKey({ armoredKey: signedArmor });\n    const signerKey = await openpgp.readKey({ armoredKey: priv_key_arm1 });\n    return signedKey.verifyPrimaryUser([signerKey], undefined, undefined, { ...openpgp.config, rejectPublicKeyAlgorithms: new Set() }).then(signatures => {\n      expect(signatures[0].valid).to.be.null;\n      expect(signatures[0].keyID.toHex()).to.equal(signedKey.getKeyID().toHex());\n      expect(signatures[1].valid).to.be.true;\n      expect(signatures[1].keyID.toHex()).to.equal(signerKey.getKeyID().toHex());\n    });\n  });\n\n  it('Verify signed UserIDs and User Attributes', async function() {\n    const armoredKeyWithPhoto = `-----BEGIN PGP PUBLIC KEY BLOCK-----\n\nmI0EW1CJGAEEAM+BzuFzcYk9HttmDbjGexQ8dfme074Q5PuHas3PBISPm0AwmnDM\ntzjlcrrg2VGuLqHvNF600w2ZgOo2gElNYCOas1q/fVFuIgJ4SUduNOEe/JnIW4uP\niEGU9l6zOVVgTc/nGVpZdvHgvOL8nl9BKHtWEnMD3Du7UYAm+Avshu9jABEBAAG0\nAViI1AQTAQoAPhYhBKcH118Rrg0wLBrTk5IyMikCym+4BQJbUIkYAhsDBQkDwmcA\nBQsJCAcDBRUKCQgLBRYDAgEAAh4BAheAAAoJEJIyMikCym+4K8oEAJc7YFiNau6V\nHTVK4cTvWU5MuYiejejFZai4ELUJy+WF6cZYrLuF/z/kRt8B7hpumXChPCUlT0q7\nFWypQtA3leu83DGMXqhfS80h2S1+VLmDVVWKQXOwgOb44jT9F08bDU5QK08SkjF8\n/EirIy8ANzdwCA4rHytIS2yx6tLlthvX0cBwwG4BEAABAQAAAAAAAAAAAAAAAP/Y\n/+AAEEpGSUYAAQEAAAEAAQAA/9sAQwABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEB\nAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEB/9sAQwEBAQEB\nAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEB\nAQEBAQEBAQEBAQEB/8AAEQgAAQABAwEiAAIRAQMRAf/EABUAAQEAAAAAAAAAAAAA\nAAAAAAAK/8QAFBABAAAAAAAAAAAAAAAAAAAAAP/EABQBAQAAAAAAAAAAAAAAAAAA\nAAD/xAAUEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwC/gAH/2YjUBBMB\nCgA+FiEEpwfXXxGuDTAsGtOTkjIyKQLKb7gFAltQimUCGwMFCQPCZwAFCwkIBwMF\nFQoJCAsFFgMCAQACHgECF4AACgkQkjIyKQLKb7gm/wQAiyZF89qr8hf3XQNJ6Ir/\nQtaniPcesjrYCIE47ZfeDYpBTPeiMm295o2dZXVJS4ItllYsplASw5DJiIMnQKlJ\nmbXakYFzzclTa/JrKzFYCy/DPT95xK+633omgrIUgJodizoKJE7XeB2U6aRUJJ4O\niTuGu4fEU1UligAXSrZmCdE=\n=VK6I\n-----END PGP PUBLIC KEY BLOCK-----`;\n\n    const key = await openpgp.readKey({ armoredKey: armoredKeyWithPhoto });\n    await Promise.all(key.users.map(async user => {\n      await user.verify(undefined, openpgp.config);\n    }));\n  });\n\n  it('should verify a shorter RSA signature', async function () {\n    const encrypted = `-----BEGIN PGP MESSAGE-----\n\nwYwD4IT3RGwgLJcBBACmH+a2c2yieZJ3wFchKeTVqzWkoltiidWgHHNE5v5x\n8aZGNzZFBd02v80VS23P9oxeJOpqKX2IZyuD36SniNoi+eXdT3zraqIe9x5p\n0RY9OrTP9pl58iogFBi1ARls41j7ui8KKDt2/iyQDCWHW1LoOVstiEb5/Xi3\nEWI+34EbNNTBMgEJAQAwEXImkOPmhYhE7bB3FnXe9rb7Fo3GZYA4/8B9YVf7\nGGZRLGwbICGu8E0MolmzLYW9hRThEfusAsNPGSgB+Yaqp0drsk01N4JJj3FT\nRKEUvd5EcL3u+Z5EoUUW6GpUL5p8Hvy2thqQfeem7XUbDBY6V3wqydOjbN9u\nc4CWB5Zu3GjDGDOvXFsy6cgdQvd/B9xbugKvUbAIsecTPlLtjZwfQklIu63T\nDA/3Pz/+zTAknBCsuIM0m7U/ZP3N6AGQIp4To7RJk0I6AxthHF5LbU11MjDZ\niB7+vmhqlrPyIS11g25UNijottJm13f84glVwBdWTJCiEqjh3KbcnTQCckCY\nV39DDLtbZG/XIx1ktqp765O9D/9xp2IA4zTyZzH4TuDbYs1j+JRdMsAq254k\n1m+wtW5gxJGcD5nh2T2T+ABL0n3jW0G504kR0LNBAQOZhVSKnSLn+F0GkjmI\niGw8+BOy8p2pX/WCLOf776ppSL77TpzhpG6wSE2oQxDrudazmRgVkZpyGzFE\nfDjspLTJHOhZ5zlLuoiKS9qEARGp39ysQnElR4dsx7tyVZz0uJvIrVzrQBlB\nekoD0DH0bhfqiwDrqeTJT2ORk8I/Q3jWnhQ3MnRN+q9d0yf1LWApMCwA7xU2\nC4KUFRC/wuF2TR9NvA==\n=v3WS\n-----END PGP MESSAGE-----`;\n    const armoredKey = `-----BEGIN PGP PRIVATE KEY BLOCK-----\n\n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\noaBUyhCKt8tz6Q==\n=52k1\n-----END PGP PRIVATE KEY BLOCK-----`;\n    const key = await openpgp.readKey({ armoredKey });\n    const decrypted = await openpgp.decrypt({\n      message: await openpgp.readMessage({ armoredMessage: encrypted }),\n      verificationKeys: key,\n      decryptionKeys: key,\n      config: { minRSABits: 1024 }\n    });\n    expect(await decrypted.signatures[0].verified).to.be.true;\n  });\n\n  it('should verify a shorter EdDSA signature', async function() {\n    const key = await openpgp.readKey({\n      armoredKey: `-----BEGIN PGP PRIVATE KEY BLOCK-----\n\nxVgEX8+jfBYJKwYBBAHaRw8BAQdA9GbdDjprR0sWf0R5a5IpulUauc0FsmzJ\nmOYCfoowt8EAAP9UwaqC0LWWQ5RlX7mps3728vFa/If1KBVwAjk7Uqhi2BKL\nzQ90ZXN0MiA8YkBhLmNvbT7CjAQQFgoAHQUCX8+jfAQLCQcIAxUICgQWAgEA\nAhkBAhsDAh4BACEJEG464aV2od77FiEEIcg441MtKnyJnPDRbjrhpXah3vuR\ngQD+Il6Gw2oIok4/ANyDDLBYZtKqRrMv4NcfF9DHYuAFcP4BAPhFOffyP3qU\nAEZb7QPrWdLfhn8/FeSFZxJvnmupQ9sDx10EX8+jfBIKKwYBBAGXVQEFAQEH\nQOSzo9cX1U2esGFClprOt0QWXNJ97228R5tKFxo6/0NoAwEIBwAA/0n4sq2i\nN6/jE+6rVO4o/7LW0xahxpV1tTA6qv1Op9TwFIDCeAQYFggACQUCX8+jfAIb\nDAAhCRBuOuGldqHe+xYhBCHIOONTLSp8iZzw0W464aV2od773XcA/jlmX8/c\n1/zIotEkyMZB4mI+GAg3FQ6bIACFBH1sz0MzAP9Snri0P4FRZ8D5THRCJoUm\nGBgpBmrf6IVv484jBswGDA==\n=8rBO\n-----END PGP PRIVATE KEY BLOCK-----`\n    });\n    const encrypted = `-----BEGIN PGP MESSAGE-----\n\nwV4DWlRRjuYiLSsSAQdAWwDKQLN4ZUS5fqiwFtAMrRfZZe9J4SgClhG6avEe\nAEowkSZwWRT+8Hy8aBIb4oPehYUFXXZ7BtlJCyd7LOTUtqyc00OE0721PC3M\nv0+zird60sACATlDmTwweR5GFtEAjHVheIL5rbkOBRD+oSqB8z+IovNg83Pz\nFVwsFZnCLtECoYgpF2MJdopuC/bPHcrvf4ndwmD11uXtms4Rq4y25QyqApbn\nHj/hljufk0OkavUXxrNKjGQtxLHMpa3Nsi0MHWY8JguxOKFKpAIMP32CD1e+\nj+GItrR+QbbN13ODlcR3hf66cwjLLsJCx5VcBaRspKF05O3ix/u9KVjJqtbi\nIe6jnY0zP2ldtS4JmhKBa43qmOHCxHc=\n=7B58\n-----END PGP MESSAGE-----`;\n    const decrypted = await openpgp.decrypt({ message: await openpgp.readMessage({ armoredMessage: encrypted }), decryptionKeys: key, verificationKeys: key.toPublic() });\n    expect(await decrypted.signatures[0].verified).to.be.true;\n  });\n\n  it('should verify a shorter ECDSA signature', async function() {\n    const key = await openpgp.readKey({\n      armoredKey: `-----BEGIN PGP PRIVATE KEY BLOCK-----\n\nxYAFX9JrLRMAAABMCCqGSM49AwEHAgMErtQdX4vh7ng/ut+k1mooYNh3Ywqt\nwr0tSS8hxZMvQRIFQ53Weq0e97ioZKXGimprEL571yvAN7I19wtQtqi61AAA\nAAAAJAEAjWdW+qlMFaKwXCls3O/X8I1rbZ0OdFgeE3TnRP3YETAP5s0KYSA8\nYUBhLml0PsKSBRATCAAhBQJf0mstBAsJBwgDFQgKBBYCAQACGQECGwMCHgcD\nIgECACMiIQUee6Tb+GlhTk/ozKrt7RhInCyR6w3OJb/tYAN1+qbIoYUqAP9S\nXmJCmSMrq6KfAD1aWSTBhtmujh+6y/pYTaf6VJVBYQEAt18zK0tw5EihHASY\nFXbfdFHBzrMmPJ4UV6UiBvH6k2zHhAVf0mstEgAAAFAIKoZIzj0DAQcCAwQx\nqnVPmWex365Nx8X8BGuMNI2TITXzTh9+AuPftZjPm09dhxdT9xmrCstPu/U1\ncpacIp0LIq13ngLgeZWcGFcnAwEIBwAAAAAAJAEAsTvBsKk/XoCz2mi8sz5q\nEYaN9YdDOU2jF+HOaSNaJAsPF8J6BRgTCAAJBQJf0mstAhsMACMiIQUee6Tb\n+GlhTk/ozKrt7RhInCyR6w3OJb/tYAN1+qbIoVutAP9GHPLn7D9Uahm81lhK\nAcvDfr9a0Cp4WAVzKDKLUzrRMgEAozi0VyjiBo1U2LcwTPJkA4PEQqQRVW1D\nKZTMSAH7JEo=\n=tqWy\n-----END PGP PRIVATE KEY BLOCK-----`\n    });\n    const signed = `-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA256\n\nshort message\n-----BEGIN PGP SIGNATURE-----\n\nwnYFARMIAAYFAl/Say0AIyIhBR57pNv4aWFOT+jMqu3tGEicLJHrDc4lv+1g\nA3X6psihFkcA+Nuog2qpAq20Zc2lzVjDZzQosb8MLvKMg3UFCX12Oc0BAJwd\nJImeZLY02MctIpGZULbqgcUGK0P/yqrPL8Pe4lQM\n=Pacb\n-----END PGP SIGNATURE-----`;\n    const message = await openpgp.readCleartextMessage({ cleartextMessage: signed });\n    const verified = await openpgp.verify({ verificationKeys: key, message });\n    expect(await verified.signatures[0].verified).to.be.true;\n  });\n});\n"], "fixing_code": ["// GPG4Browsers - An OpenPGP implementation in javascript\n// Copyright (C) 2011 Recurity Labs GmbH\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 3.0 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n\nimport { armor, unarmor } from './encoding/armor';\nimport enums from './enums';\nimport util from './util';\nimport { PacketList, LiteralDataPacket, SignaturePacket } from './packet';\nimport { Signature } from './signature';\nimport { createVerificationObjects, createSignaturePackets } from './message';\nimport defaultConfig from './config';\n\n// A Cleartext message can contain the following packets\nconst allowedPackets = /*#__PURE__*/ util.constructAllowedPackets([SignaturePacket]);\n\n/**\n * Class that represents an OpenPGP cleartext signed message.\n * See {@link https://tools.ietf.org/html/rfc4880#section-7}\n */\nexport class CleartextMessage {\n  /**\n   * @param {String} text - The cleartext of the signed message\n   * @param {Signature} signature - The detached signature or an empty signature for unsigned messages\n   */\n  constructor(text, signature) {\n    // remove trailing whitespace and normalize EOL to canonical form <CR><LF>\n    this.text = util.removeTrailingSpaces(text).replace(/\\r?\\n/g, '\\r\\n');\n    if (signature && !(signature instanceof Signature)) {\n      throw new Error('Invalid signature input');\n    }\n    this.signature = signature || new Signature(new PacketList());\n  }\n\n  /**\n   * Returns the key IDs of the keys that signed the cleartext message\n   * @returns {Array<module:type/keyid~KeyID>} Array of keyID objects.\n   */\n  getSigningKeyIDs() {\n    const keyIDs = [];\n    const signatureList = this.signature.packets;\n    signatureList.forEach(function(packet) {\n      keyIDs.push(packet.issuerKeyID);\n    });\n    return keyIDs;\n  }\n\n  /**\n   * Sign the cleartext message\n   * @param {Array<Key>} privateKeys - private keys with decrypted secret key data for signing\n   * @param {Signature} [signature] - Any existing detached signature\n   * @param {Array<module:type/keyid~KeyID>} [signingKeyIDs] - Array of key IDs to use for signing. Each signingKeyIDs[i] corresponds to privateKeys[i]\n   * @param {Date} [date] - The creation time of the signature that should be created\n   * @param {Array} [userIDs] - User IDs to sign with, e.g. [{ name:'Steve Sender', email:'steve@openpgp.org' }]\n   * @param {Array} [notations] - Notation Data to add to the signatures, e.g. [{ name: 'test@example.org', value: new TextEncoder().encode('test'), humanReadable: true, critical: false }]\n   * @param {Object} [config] - Full configuration, defaults to openpgp.config\n   * @returns {Promise<CleartextMessage>} New cleartext message with signed content.\n   * @async\n   */\n  async sign(privateKeys, signature = null, signingKeyIDs = [], date = new Date(), userIDs = [], notations = [], config = defaultConfig) {\n    const literalDataPacket = new LiteralDataPacket();\n    literalDataPacket.setText(this.text);\n    const newSignature = new Signature(await createSignaturePackets(literalDataPacket, privateKeys, signature, signingKeyIDs, date, userIDs, notations, true, config));\n    return new CleartextMessage(this.text, newSignature);\n  }\n\n  /**\n   * Verify signatures of cleartext signed message\n   * @param {Array<Key>} keys - Array of keys to verify signatures\n   * @param {Date} [date] - Verify the signature against the given date, i.e. check signature creation time < date < expiration time\n   * @param {Object} [config] - Full configuration, defaults to openpgp.config\n   * @returns {Promise<Array<{\n   *   keyID: module:type/keyid~KeyID,\n   *   signature: Promise<Signature>,\n   *   verified: Promise<true>\n   * }>>} List of signer's keyID and validity of signature.\n   * @async\n   */\n  verify(keys, date = new Date(), config = defaultConfig) {\n    const signatureList = this.signature.packets.filterByTag(enums.packet.signature); // drop UnparsablePackets\n    const literalDataPacket = new LiteralDataPacket();\n    // we assume that cleartext signature is generated based on UTF8 cleartext\n    literalDataPacket.setText(this.text);\n    return createVerificationObjects(signatureList, [literalDataPacket], keys, date, true, config);\n  }\n\n  /**\n   * Get cleartext\n   * @returns {String} Cleartext of message.\n   */\n  getText() {\n    // normalize end of line to \\n\n    return this.text.replace(/\\r\\n/g, '\\n');\n  }\n\n  /**\n   * Returns ASCII armored text of cleartext signed message\n   * @param {Object} [config] - Full configuration, defaults to openpgp.config\n   * @returns {String | ReadableStream<String>} ASCII armor.\n   */\n  armor(config = defaultConfig) {\n    let hashes = this.signature.packets.map(function(packet) {\n      return enums.read(enums.hash, packet.hashAlgorithm).toUpperCase();\n    });\n    hashes = hashes.filter(function(item, i, ar) { return ar.indexOf(item) === i; });\n    const body = {\n      hash: hashes.join(),\n      text: this.text,\n      data: this.signature.packets.write()\n    };\n    return armor(enums.armor.signed, body, undefined, undefined, undefined, config);\n  }\n}\n\n/**\n * Reads an OpenPGP cleartext signed message and returns a CleartextMessage object\n * @param {Object} options\n * @param {String} options.cleartextMessage - Text to be parsed\n * @param {Object} [options.config] - Custom configuration settings to overwrite those in [config]{@link module:config}\n * @returns {Promise<CleartextMessage>} New cleartext message object.\n * @async\n * @static\n */\nexport async function readCleartextMessage({ cleartextMessage, config, ...rest }) {\n  config = { ...defaultConfig, ...config };\n  if (!cleartextMessage) {\n    throw new Error('readCleartextMessage: must pass options object containing `cleartextMessage`');\n  }\n  if (!util.isString(cleartextMessage)) {\n    throw new Error('readCleartextMessage: options.cleartextMessage must be a string');\n  }\n  const unknownOptions = Object.keys(rest); if (unknownOptions.length > 0) throw new Error(`Unknown option: ${unknownOptions.join(', ')}`);\n\n  const input = await unarmor(cleartextMessage);\n  if (input.type !== enums.armor.signed) {\n    throw new Error('No cleartext signed message.');\n  }\n  const packetlist = await PacketList.fromBinary(input.data, allowedPackets, config);\n  verifyHeaders(input.headers, packetlist);\n  const signature = new Signature(packetlist);\n  return new CleartextMessage(input.text, signature);\n}\n\n/**\n * Compare hash algorithm specified in the armor header with signatures\n * @param {Array<String>} headers - Armor headers\n * @param {PacketList} packetlist - The packetlist with signature packets\n * @private\n */\nfunction verifyHeaders(headers, packetlist) {\n  const checkHashAlgos = function(hashAlgos) {\n    const check = packet => algo => packet.hashAlgorithm === algo;\n\n    for (let i = 0; i < packetlist.length; i++) {\n      if (packetlist[i].constructor.tag === enums.packet.signature && !hashAlgos.some(check(packetlist[i]))) {\n        return false;\n      }\n    }\n    return true;\n  };\n\n  let oneHeader = null;\n  let hashAlgos = [];\n  headers.forEach(function(header) {\n    oneHeader = header.match(/^Hash: (.+)$/); // get header value\n    if (oneHeader) {\n      oneHeader = oneHeader[1].replace(/\\s/g, ''); // remove whitespace\n      oneHeader = oneHeader.split(',');\n      oneHeader = oneHeader.map(function(hash) {\n        hash = hash.toLowerCase();\n        try {\n          return enums.write(enums.hash, hash);\n        } catch (e) {\n          throw new Error('Unknown hash algorithm in armor header: ' + hash);\n        }\n      });\n      hashAlgos = hashAlgos.concat(oneHeader);\n    } else {\n      throw new Error('Only \"Hash\" header allowed in cleartext signed message');\n    }\n  });\n\n  if (!hashAlgos.length && !checkHashAlgos([enums.hash.md5])) {\n    throw new Error('If no \"Hash\" header in cleartext signed message, then only MD5 signatures allowed');\n  } else if (hashAlgos.length && !checkHashAlgos(hashAlgos)) {\n    throw new Error('Hash algorithm mismatch in armor header and signature');\n  }\n}\n\n/**\n * Creates a new CleartextMessage object from text\n * @param {Object} options\n * @param {String} options.text\n * @static\n * @async\n */\nexport async function createCleartextMessage({ text, ...rest }) {\n  if (!text) {\n    throw new Error('createCleartextMessage: must pass options object containing `text`');\n  }\n  if (!util.isString(text)) {\n    throw new Error('createCleartextMessage: options.text must be a string');\n  }\n  const unknownOptions = Object.keys(rest); if (unknownOptions.length > 0) throw new Error(`Unknown option: ${unknownOptions.join(', ')}`);\n\n  return new CleartextMessage(text);\n}\n", "/* eslint-disable max-lines */\n/* globals tryTests: true */\nconst stream = require('@openpgp/web-stream-tools');\nconst { use: chaiUse, expect } = require('chai');\nchaiUse(require('chai-as-promised'));\n\nconst openpgp = typeof window !== 'undefined' && window.openpgp ? window.openpgp : require('../..');\n\nconst util = require('../../src/util');\n\nmodule.exports = () => describe('Signature', function() {\n  const priv_key_arm1 =\n    ['-----BEGIN PGP PRIVATE KEY BLOCK-----',\n      'Version: GnuPG v1.4.11 (GNU/Linux)',\n      '',\n      'lQHhBFERnrMRBADmM0hIfkI3yosjgbWo9v0Lnr3CCE+8KsMszgVS+hBu0XfGraKm',\n      'ivcA2aaJimHqVYOP7gEnwFAxHBBpeTJcu5wzCFyJwEYqVeS3nnaIhBPplSF14Duf',\n      'i6bB9RV7KxVAg6aunmM2tAutqC+a0y2rDaf7jkJoZ9gWJe2zI+vraD6fiwCgxvHo',\n      '3IgULB9RqIqpLoMgXfcjC+cD/1jeJlKRm+n71ryYwT/ECKsspFz7S36z6q3XyS8Q',\n      'QfrsUz2p1fbFicvJwIOJ8B20J/N2/nit4P0gBUTUxv3QEa7XCM/56/xrGkyBzscW',\n      'AzBoy/AK9K7GN6z13RozuAS60F1xO7MQc6Yi2VU3eASDQEKiyL/Ubf/s/rkZ+sGj',\n      'yJizBACtwCbQzA+z9XBZNUat5NPgcZz5Qeh1nwF9Nxnr6pyBv7tkrLh/3gxRGHqG',\n      '063dMbUk8pmUcJzBUyRsNiIPDoEUsLjY5zmZZmp/waAhpREsnK29WLCbqLdpUors',\n      'c1JJBsObkA1IM8TZY8YUmvsMEvBLCCanuKpclZZXqeRAeOHJ0v4DAwK8WfuTe5B+',\n      'M2BOOeZbN8BpfiA1l//fMMHLRS3UvbLBv4P1+4SyvhyYTR7M76Q0xPc03MFOWHL+',\n      'S9VumbQWVGVzdDIgPHRlc3QyQHRlc3QuY29tPohiBBMRAgAiBQJREZ6zAhsDBgsJ',\n      'CAcDAgYVCAIJCgsEFgIDAQIeAQIXgAAKCRARJ5QDyxae+MXNAKCzWSDR3tMrTrDb',\n      'TAri73N1Xb3j1ACfSl9y+SAah2q7GvmiR1+6+/ekqJGdAVgEURGesxAEANlpMZjW',\n      '33jMxlKHDdyRFXtKOq8RreXhq00plorHbgz9zFEWm4VF53+E/KGnmHGyY5Cy8TKy',\n      'ZjaueZZ9XuG0huZg5If68irFfNZtxdA26jv8//PdZ0Uj+X6J3RVa2peMLDDswTYL',\n      'OL1ZO1fxdtDD40fdAiIZ1QyjwEG0APtz41EfAAMFBAC5/dtgBBPtHe8UjDBaUe4n',\n      'NzHuUBBp6XE+H7eqHNFCuZAJ7yqJLGVHNIaQR419cNy08/OO/+YUQ7rg78LxjFiv',\n      'CH7IzhfU+6yvELSbgRMicY6EnAP2GT+b1+MtFNa3lBGtBHcJla52c2rTAHthYZWk',\n      'fT5R5DnJuQ2cJHBMS9HWyP4DAwK8WfuTe5B+M2C7a/YJSUv6SexdGCaiaTcAm6g/',\n      'PvA6hw/FLzIEP67QcQSSTmhftQIwnddt4S4MyJJH3U4fJaFfYQ1zCniYJohJBBgR',\n      'AgAJBQJREZ6zAhsMAAoJEBEnlAPLFp74QbMAn3V4857xwnO9/+vzIVnL93W3k0/8',\n      'AKC8omYPPomN1E/UJFfXdLDIMi5LoA==',\n      '=LSrW',\n      '-----END PGP PRIVATE KEY BLOCK-----'].join('\\n');\n\n  const pub_key_arm1 =\n    ['-----BEGIN PGP PUBLIC KEY BLOCK-----',\n      'Version: GnuPG v1.4.11 (GNU/Linux)',\n      '',\n      'mQGiBFERlw4RBAD6Bmcf2w1dtUmtCLkdxeqZLArk3vYoQAjdibxA3gXVyur7fsWb',\n      'ro0jVbBHqOCtC6jDxE2l52NP9+tTlWeVMaqqNvUE47LSaPq2DGI8Wx1Rj6bF3mTs',\n      'obYEwhGbGh/MhJnME9AHODarvk8AZbzo0+k1EwrBWF6dTUBPfqO7rGU2ewCg80WV',\n      'x5pt3evj8rRK3jQ8SMKTNRsD/1PhTdxdZTdXARAFzcW1VaaruWW0Rr1+XHKKwDCz',\n      'i7HE76SO9qjnQfZCZG75CdQxI0h8GFeN3zsDqmhob2iSz2aJ1krtjM+iZ1FBFd57',\n      'OqCV6wmk5IT0RBN12ZzMS19YvzN/ONXHrmTZlKExd9Mh9RKLeVNw+bf6JsKQEzcY',\n      'JzFkBACX9X+hDYchO/2hiTwx4iOO9Fhsuh7eIWumB3gt+aUpm1jrSbas/QLTymmk',\n      'uZuQVXI4NtnlvzlNgWv4L5s5RU5WqNGG7WSaKNdcrvJZRC2dgbUJt04J5CKrWp6R',\n      'aIYal/81Ut1778lU01PEt563TcQnUBlnjU5OR25KhfSeN5CZY7QUVGVzdCA8dGVz',\n      'dEB0ZXN0LmNvbT6IYgQTEQIAIgUCURGXDgIbAwYLCQgHAwIGFQgCCQoLBBYCAwEC',\n      'HgECF4AACgkQikDlZK/UvLSspgCfcNaOpTg1W2ucR1JwBbBGvaERfuMAnRgt3/rs',\n      'EplqEakMckCtikEnpxYe',\n      '=b2Ln',\n      '-----END PGP PUBLIC KEY BLOCK-----'].join('\\n');\n\n  const msg_arm1 =\n    ['-----BEGIN PGP MESSAGE-----',\n      'Version: GnuPG v1.4.11 (GNU/Linux)',\n      '',\n      'hQEOA1N4OCSSjECBEAP/diDJCQn4e88193PgqhbfAkohk9RQ0v0MPnXpJbCRTHKO',\n      '8r9nxiAr/TQv4ZOingXdAp2JZEoE9pXxZ3r1UWew04czxmgJ8FP1ztZYWVFAWFVi',\n      'Tj930TBD7L1fY/MD4fK6xjEG7z5GT8k4tn4mLm/PpWMbarIglfMopTy1M/py2cID',\n      '/2Sj7Ikh3UFiG+zm4sViYc5roNbMy8ixeoKixxi99Mx8INa2cxNfqbabjblFyc0Z',\n      'BwmbIc+ZiY2meRNI5y/tk0gRD7hT84IXGGl6/mH00bsX/kkWdKGeTvz8s5G8RDHa',\n      'Za4HgLbXItkX/QarvRS9kvkD01ujHfj+1ZvgmOBttNfP0p8BQLIICqvg1eYD9aPB',\n      '+GtOZ2F3+k5VyBL5yIn/s65SBjNO8Fqs3aL0x+p7s1cfUzx8J8a8nWpqq/qIQIqg',\n      'ZJH6MZRKuQwscwH6NWgsSVwcnVCAXnYOpbHxFQ+j7RbF/+uiuqU+DFH/Rd5pik8b',\n      '0Dqnp0yfefrkjQ0nuvubgB6Rv89mHpnvuJfFJRInpg4lrHwLvRwdpN2HDozFHcKK',\n      'aOU=',\n      '=4iGt',\n      '-----END PGP MESSAGE-----'].join('\\n');\n\n  const priv_key_arm2 =\n    ['-----BEGIN PGP PRIVATE KEY BLOCK-----',\n      'Version: GnuPG v2.0.19 (GNU/Linux)',\n      '',\n      'lQH+BFJhL04BBADclrUEDDsm0PSZbQ6pml9FpzTyXiyCyDN+rMOsy9J300Oc10kt',\n      '/nyBej9vZSRcaW5VpNNj0iA+c1/w2FPf84zNsTzvDmuMaNHFUzky4/vkYuZra//3',\n      '+Ri7CF8RawSYQ/4IRbC9zqdBlzniyfQOW7Dp/LYe8eibnDSrmkQem0G0jwARAQAB',\n      '/gMDAu7L//czBpE40p1ZqO8K3k7UejemjsQqc7kOqnlDYd1Z6/3NEA/UM30Siipr',\n      'KjdIFY5+hp0hcs6EiiNq0PDfm/W2j+7HfrZ5kpeQVxDek4irezYZrl7JS2xezaLv',\n      'k0Fv/6fxasnFtjOM6Qbstu67s5Gpl9y06ZxbP3VpT62+Xeibn/swWrfiJjuGEEhM',\n      'bgnsMpHtzAz/L8y6KSzViG/05hBaqrvk3/GeEA6nE+o0+0a6r0LYLTemmq6FbaA1',\n      'PHo+x7k7oFcBFUUeSzgx78GckuPwqr2mNfeF+IuSRnrlpZl3kcbHASPAOfEkyMXS',\n      'sWGE7grCAjbyQyM3OEXTSyqnehvGS/1RdB6kDDxGwgE/QFbwNyEh6K4eaaAThW2j',\n      'IEEI0WEnRkPi9fXyxhFsCLSI1XhqTaq7iDNqJTxE+AX2b9ZuZXAxI3Tc/7++vEyL',\n      '3p18N/MB2kt1Wb1azmXWL2EKlT1BZ5yDaJuBQ8BhphM3tCRUZXN0IE1jVGVzdGlu',\n      'Z3RvbiA8dGVzdEBleGFtcGxlLmNvbT6IuQQTAQIAIwUCUmEvTgIbLwcLCQgHAwIB',\n      'BhUIAgkKCwQWAgMBAh4BAheAAAoJEEpjYTpNbkCUMAwD+gIK08qpEZSVas9qW+Ok',\n      '32wzNkwxe6PQgZwcyBqMQYZUcKagC8+89pMQQ5sKUGvpIgat42Tf1KLGPcvG4cDA',\n      'JZ6w2PYz9YHQqPh9LA+PAnV8m25TcGmKcKgvFUqQ3U53X/Y9sBP8HooRqfwwHcv9',\n      'pMgQmojmNbI4VHydRqIBePawnQH+BFJhL04BBADpH8+0EVolpPiOrXTKoBKTiyrB',\n      'UyxzodyJ8zmVJ3HMTEU/vidpQwzISwoc/ndDFMXQauq6xqBCD9m2BPQI3UdQzXnb',\n      'LsAI52nWCIqOkzM5NAKWoKhyXK9Y4UH4v9LAYQgl/stIISvCgG4mJ8lzzEBWvRdf',\n      'Qm2Ghb64/3V5NDdemwARAQAB/gMDAu7L//czBpE40iPcpLzL7GwBbWFhSWgSLy53',\n      'Md99Kxw3cApWCok2E8R9/4VS0490xKZIa5y2I/K8thVhqk96Z8Kbt7MRMC1WLHgC',\n      'qJvkeQCI6PrFM0PUIPLHAQtDJYKtaLXxYuexcAdKzZj3FHdtLNWCooK6n3vJlL1c',\n      'WjZcHJ1PH7USlj1jup4XfxsbziuysRUSyXkjn92GZLm+64vCIiwhqAYoizF2NHHG',\n      'hRTN4gQzxrxgkeVchl+ag7DkQUDANIIVI+A63JeLJgWJiH1fbYlwESByHW+zBFNt',\n      'qStjfIOhjrfNIc3RvsggbDdWQLcbxmLZj4sB0ydPSgRKoaUdRHJY0S4vp9ouKOtl',\n      '2au/P1BP3bhD0fDXl91oeheYth+MSmsJFDg/vZJzCJhFaQ9dp+2EnjN5auNCNbaI',\n      'beFJRHFf9cha8p3hh+AK54NRCT++B2MXYf+TPwqX88jYMBv8kk8vYUgo8128r1zQ',\n      'EzjviQE9BBgBAgAJBQJSYS9OAhsuAKgJEEpjYTpNbkCUnSAEGQECAAYFAlJhL04A',\n      'CgkQ4IT3RGwgLJe6ogQA2aaJEIBIXtgrs+8WSJ4k3DN4rRXcXaUZf667pjdD9nF2',\n      '3BzjFH6Z78JIGaxRHJdM7b05aE8YuzM8f3NIlT0F0OLq/TI2muYU9f/U2DQBuf+w',\n      'KTB62+PELVgi9MsXC1Qv/u/o1LZtmmxTFFOD35xKsxZZI2OJj2pQpqObW27M8Nlc',\n      'BQQAw2YA3fFc38qPK+PY4rZyTRdbvjyyX+1zeqIo8wn7QCQwXs+OGaH2fGoT35AI',\n      'SXuqKcWqoEuO7OBSEFThCXBfUYMC01OrqKEswPm/V3zZkLu01q12UMwZach28QwK',\n      '/YZly4ioND2tdazj17u2rU2dwtiHPe1iMqGgVMoQirfLc+k=',\n      '=lw5e',\n      '-----END PGP PRIVATE KEY BLOCK-----'].join('\\n');\n\n  const pub_key_arm2 =\n    ['-----BEGIN PGP PUBLIC KEY BLOCK-----',\n      'Version: GnuPG v2.0.19 (GNU/Linux)',\n      '',\n      'mI0EUmEvTgEEANyWtQQMOybQ9JltDqmaX0WnNPJeLILIM36sw6zL0nfTQ5zXSS3+',\n      'fIF6P29lJFxpblWk02PSID5zX/DYU9/zjM2xPO8Oa4xo0cVTOTLj++Ri5mtr//f5',\n      'GLsIXxFrBJhD/ghFsL3Op0GXOeLJ9A5bsOn8th7x6JucNKuaRB6bQbSPABEBAAG0',\n      'JFRlc3QgTWNUZXN0aW5ndG9uIDx0ZXN0QGV4YW1wbGUuY29tPoi5BBMBAgAjBQJS',\n      'YS9OAhsvBwsJCAcDAgEGFQgCCQoLBBYCAwECHgECF4AACgkQSmNhOk1uQJQwDAP6',\n      'AgrTyqkRlJVqz2pb46TfbDM2TDF7o9CBnBzIGoxBhlRwpqALz7z2kxBDmwpQa+ki',\n      'Bq3jZN/UosY9y8bhwMAlnrDY9jP1gdCo+H0sD48CdXybblNwaYpwqC8VSpDdTndf',\n      '9j2wE/weihGp/DAdy/2kyBCaiOY1sjhUfJ1GogF49rC4jQRSYS9OAQQA6R/PtBFa',\n      'JaT4jq10yqASk4sqwVMsc6HcifM5lSdxzExFP74naUMMyEsKHP53QxTF0Grqusag',\n      'Qg/ZtgT0CN1HUM152y7ACOdp1giKjpMzOTQClqCoclyvWOFB+L/SwGEIJf7LSCEr',\n      'woBuJifJc8xAVr0XX0JthoW+uP91eTQ3XpsAEQEAAYkBPQQYAQIACQUCUmEvTgIb',\n      'LgCoCRBKY2E6TW5AlJ0gBBkBAgAGBQJSYS9OAAoJEOCE90RsICyXuqIEANmmiRCA',\n      'SF7YK7PvFkieJNwzeK0V3F2lGX+uu6Y3Q/Zxdtwc4xR+me/CSBmsURyXTO29OWhP',\n      'GLszPH9zSJU9BdDi6v0yNprmFPX/1Ng0Abn/sCkwetvjxC1YIvTLFwtUL/7v6NS2',\n      'bZpsUxRTg9+cSrMWWSNjiY9qUKajm1tuzPDZXAUEAMNmAN3xXN/Kjyvj2OK2ck0X',\n      'W748sl/tc3qiKPMJ+0AkMF7Pjhmh9nxqE9+QCEl7qinFqqBLjuzgUhBU4QlwX1GD',\n      'AtNTq6ihLMD5v1d82ZC7tNatdlDMGWnIdvEMCv2GZcuIqDQ9rXWs49e7tq1NncLY',\n      'hz3tYjKhoFTKEIq3y3Pp',\n      '=h/aX',\n      '-----END PGP PUBLIC KEY BLOCK-----'].join('\\n');\n\n  const pub_key_arm3 =\n    ['-----BEGIN PGP PUBLIC KEY BLOCK-----',\n      'Version: GnuPG v2.0.19 (GNU/Linux)',\n      '',\n      'mQENBFKV0FUBCACtZliApy01KBGbGNB36YGH4lpr+5KoqF1I8A5IT0YeNjyGisOk',\n      'WsDsUzOqaNvgzQ82I3MY/jQV5rLBhH/6LiRmCA16WkKcqBrHfNGIxJ+Q+ofVBHUb',\n      'aS9ClXYI88j747QgWzirnLuEA0GfilRZcewII1pDA/G7+m1HwV4qHsPataYLeboq',\n      'hPA3h1EVVQFMAcwlqjOuS8+weHQRfNVRGQdRMm6H7166PseDVRUHdkJpVaKFhptg',\n      'rDoNI0lO+UujdqeF1o5tVZ0j/s7RbyBvdLTXNuBbcpq93ceSWuJPZmi1XztQXKYe',\n      'y0f+ltgVtZDEc7TGV5WDX9erRECCcA3+s7J3ABEBAAG0G0pTIENyeXB0byA8ZGlm',\n      'ZmllQGhvbWUub3JnPokBPwQTAQIAKQUCUpXQVQIbAwUJCWYBgAcLCQgHAwIBBhUI',\n      'AgkKCwQWAgMBAh4BAheAAAoJENvyI+hwU030yRAIAKX/mGEgi/miqasbbQoyK/CS',\n      'a7sRxgZwOWQLdi2xxpE5V4W4HJIDNLJs5vGpRN4mmcNK2fmJAh74w0PskmVgJEhP',\n      'dFJ14UC3fFPq5nbqkBl7hU0tDP5jZxo9ruQZfDOWpHKxOCz5guYJ0CW97bz4fChZ',\n      'NFDyfU7VsJQwRIoViVcMCipP0fVZQkIhhwpzQpmVmN8E0a6jWezTZv1YpMdlzbEf',\n      'H79l3StaOh9/Un9CkIyqEWdYiKvIYms9nENyehN7r/OKYN3SW+qlt5GaL+ws+N1w',\n      '6kEZjPFwnsr+Y4A3oHcAwXq7nfOz71USojSmmo8pgdN8je16CP98vw3/k6TncLS5',\n      'AQ0EUpXQVQEIAMEjHMeqg7B04FliUFWr/8C6sJDb492MlGAWgghIbnuJfXAnUGdN',\n      'oAzn0S+n93Y/qHbW6YcjHD4/G+kK3MuxthAFqcVjdHZQXK0rkhXO/u1co7v1cdtk',\n      'OTEcyOpyLXolM/1S2UYImhrml7YulTHMnWVja7xu6QIRso+7HBFT/u9D47L/xXrX',\n      'MzXFVZfBtVY+yoeTrOY3OX9cBMOAu0kuN9eT18Yv2yi6XMzP3iONVHtl6HfFrAA7',\n      'kAtx4ne0jgAPWZ+a8hMy59on2ZFs/AvSpJtSc1kw/vMTWkyVP1Ky20vAPHQ6Ej5q',\n      '1NGJ/JbcFgolvEeI/3uDueLjj4SdSIbLOXMAEQEAAYkBJQQYAQIADwUCUpXQVQIb',\n      'DAUJCWYBgAAKCRDb8iPocFNN9NLkB/wO4iRxia0zf4Kw2RLVZG8qcuo3Bw9UTXYY',\n      'lI0AutoLNnSURMLLCq6rcJ0BCXGj/2iZ0NBxZq3t5vbRh6uUv+hpiSxK1nF7AheN',\n      '4aAAzhbWx0UDTF04ebG/neE4uDklRIJLhif6+Bwu+EUeTlGbDj7fqGSsNe8g92w7',\n      '1e41rF/9CMoOswrKgIjXAou3aexogWcHvKY2D+1q9exORe1rIa1+sUGl5PG2wsEs',\n      'znN6qtN5gMlGY1ofWDY+I02gO4qzaZ/FxRZfittCw7v5dmQYKot9qRi2Kx3Fvw+h',\n      'ivFBpC4TWgppFBnJJnAsFXZJQcejMW4nEmOViRQXY8N8PepQmgsu',\n      '=ummy',\n      '-----END PGP PUBLIC KEY BLOCK-----'].join('\\n');\n\n  const pub_revoked =\n    ['-----BEGIN PGP PUBLIC KEY BLOCK-----',\n      'Version: GnuPG v2.0.19 (GNU/Linux)',\n      '',\n      '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',\n      'pMiJM+NJAQ==',\n      '=ok+o',\n      '-----END PGP PUBLIC KEY BLOCK-----'].join('\\n');\n\n  const pub_latin1_msg = `-----BEGIN PGP PUBLIC KEY BLOCK-----\n\n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\neGlmAABNTQAqAAAACAAFARIAAwAAAAEAAQAAARoABQAAAAEAAABKARsABQAAAAEA\nAABSASgAAwAAAAEAAgAAh2kABAAAAAEAAABaAAAAAAAAAEgAAAABAAAASAAAAAEA\nAqACAAQAAAABAAAAfaADAAQAAAABAAAAlgAAAAD/4QkhaHR0cDovL25zLmFkb2Jl\nLmNvbS94YXAvMS4wLwA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENl\naGlIenJlU3pOVGN6a2M5ZCI/PiA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5z\nOm1ldGEvIiB4OnhtcHRrPSJYTVAgQ29yZSA1LjQuMCI+IDxyZGY6UkRGIHhtbG5z\nOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5z\nIyI+IDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiLz4gPC9yZGY6UkRGPiA8\nL3g6eG1wbWV0YT4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8P3hw\nYWNrZXQgZW5kPSJ3Ij8+AP/tADhQaG90b3Nob3AgMy4wADhCSU0EBAAAAAAAADhC\nSU0EJQAAAAAAENQdjNmPALIE6YAJmOz4Qn7/4gzgSUNDX1BST0ZJTEUAAQEAAAzQ\nYXBwbAIQAABtbnRyUkdCIFhZWiAH3wABAAEACwA7AC1hY3NwQVBQTAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAA9tYAAQAAAADTLWFwcGwAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABFkZXNjAAABUAAAAGJkc2Nt\nAAABtAAAAbhjcHJ0AAADbAAAACN3dHB0AAADkAAAABRyWFlaAAADpAAAABRnWFla\nAAADuAAAABRiWFlaAAADzAAAABRyVFJDAAAD4AAACAxhYXJnAAAL7AAAACB2Y2d0\nAAAMDAAAADBuZGluAAAMPAAAAD5jaGFkAAAMfAAAACxtbW9kAAAMqAAAAChiVFJD\nAAAD4AAACAxnVFJDAAAD4AAACAxhYWJnAAAL7AAAACBhYWdnAAAL7AAAACBkZXNj\nAAAAAAAAAAhEaXNwbGF5AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nbWx1YwAAAAAAAAAiAAAADGhySFIAAAAQAAABqGtvS1IAAAAQAAABqG5iTk8AAAAQ\nAAABqGlkAAAAAAAQAAABqGh1SFUAAAAQAAABqGNzQ1oAAAAQAAABqGRhREsAAAAQ\nAAABqHVrVUEAAAAQAAABqGFyAAAAAAAQAAABqGl0SVQAAAAQAAABqHJvUk8AAAAQ\nAAABqGVzRVMAAAAQAAABqGhlSUwAAAAQAAABqG5sTkwAAAAQAAABqGZpRkkAAAAQ\nAAABqHpoVFcAAAAQAAABqHZpVk4AAAAQAAABqHNrU0sAAAAQAAABqHpoQ04AAAAQ\nAAABqHJ1UlUAAAAQAAABqGZyRlIAAAAQAAABqG1zAAAAAAAQAAABqGNhRVMAAAAQ\nAAABqHRoVEgAAAAQAAABqGVzWEwAAAAQAAABqGRlREUAAAAQAAABqGVuVVMAAAAQ\nAAABqHB0QlIAAAAQAAABqHBsUEwAAAAQAAABqGVsR1IAAAAQAAABqHN2U0UAAAAQ\nAAABqHRyVFIAAAAQAAABqGphSlAAAAAQAAABqHB0UFQAAAAQAAABqABTAE0AQgAx\nADkANAAwAFd0ZXh0AAAAAENvcHlyaWdodCBBcHBsZSBJbmMuLCAyMDE1AABYWVog\nAAAAAAAA89gAAQAAAAEWCFhZWiAAAAAAAABwAAAAOREAAAPCWFlaIAAAAAAAAGI3\nAAC3mgAAGRFYWVogAAAAAAAAJJ8AAA9VAAC2WmN1cnYAAAAAAAAEAAAAAAUACgAP\nABQAGQAeACMAKAAtADIANgA7AEAARQBKAE8AVABZAF4AYwBoAG0AcgB3AHwAgQCG\nAIsAkACVAJoAnwCjAKgArQCyALcAvADBAMYAywDQANUA2wDgAOUA6wDwAPYA+wEB\nAQcBDQETARkBHwElASsBMgE4AT4BRQFMAVIBWQFgAWcBbgF1AXwBgwGLAZIBmgGh\nAakBsQG5AcEByQHRAdkB4QHpAfIB+gIDAgwCFAIdAiYCLwI4AkECSwJUAl0CZwJx\nAnoChAKOApgCogKsArYCwQLLAtUC4ALrAvUDAAMLAxYDIQMtAzgDQwNPA1oDZgNy\nA34DigOWA6IDrgO6A8cD0wPgA+wD+QQGBBMEIAQtBDsESARVBGMEcQR+BIwEmgSo\nBLYExATTBOEE8AT+BQ0FHAUrBToFSQVYBWcFdwWGBZYFpgW1BcUF1QXlBfYGBgYW\nBicGNwZIBlkGagZ7BowGnQavBsAG0QbjBvUHBwcZBysHPQdPB2EHdAeGB5kHrAe/\nB9IH5Qf4CAsIHwgyCEYIWghuCIIIlgiqCL4I0gjnCPsJEAklCToJTwlkCXkJjwmk\nCboJzwnlCfsKEQonCj0KVApqCoEKmAquCsUK3ArzCwsLIgs5C1ELaQuAC5gLsAvI\nC+EL+QwSDCoMQwxcDHUMjgynDMAM2QzzDQ0NJg1ADVoNdA2ODakNww3eDfgOEw4u\nDkkOZA5/DpsOtg7SDu4PCQ8lD0EPXg96D5YPsw/PD+wQCRAmEEMQYRB+EJsQuRDX\nEPURExExEU8RbRGMEaoRyRHoEgcSJhJFEmQShBKjEsMS4xMDEyMTQxNjE4MTpBPF\nE+UUBhQnFEkUahSLFK0UzhTwFRIVNBVWFXgVmxW9FeAWAxYmFkkWbBaPFrIW1hb6\nFx0XQRdlF4kXrhfSF/cYGxhAGGUYihivGNUY+hkgGUUZaxmRGbcZ3RoEGioaURp3\nGp4axRrsGxQbOxtjG4obshvaHAIcKhxSHHscoxzMHPUdHh1HHXAdmR3DHeweFh5A\nHmoelB6+HukfEx8+H2kflB+/H+ogFSBBIGwgmCDEIPAhHCFIIXUhoSHOIfsiJyJV\nIoIiryLdIwojOCNmI5QjwiPwJB8kTSR8JKsk2iUJJTglaCWXJccl9yYnJlcmhya3\nJugnGCdJJ3onqyfcKA0oPyhxKKIo1CkGKTgpaymdKdAqAio1KmgqmyrPKwIrNitp\nK50r0SwFLDksbiyiLNctDC1BLXYtqy3hLhYuTC6CLrcu7i8kL1ovkS/HL/4wNTBs\nMKQw2zESMUoxgjG6MfIyKjJjMpsy1DMNM0YzfzO4M/E0KzRlNJ402DUTNU01hzXC\nNf02NzZyNq426TckN2A3nDfXOBQ4UDiMOMg5BTlCOX85vDn5OjY6dDqyOu87LTtr\nO6o76DwnPGU8pDzjPSI9YT2hPeA+ID5gPqA+4D8hP2E/oj/iQCNAZECmQOdBKUFq\nQaxB7kIwQnJCtUL3QzpDfUPARANER0SKRM5FEkVVRZpF3kYiRmdGq0bwRzVHe0fA\nSAVIS0iRSNdJHUljSalJ8Eo3Sn1KxEsMS1NLmkviTCpMcky6TQJNSk2TTdxOJU5u\nTrdPAE9JT5NP3VAnUHFQu1EGUVBRm1HmUjFSfFLHUxNTX1OqU/ZUQlSPVNtVKFV1\nVcJWD1ZcVqlW91dEV5JX4FgvWH1Yy1kaWWlZuFoHWlZaplr1W0VblVvlXDVchlzW\nXSddeF3JXhpebF69Xw9fYV+zYAVgV2CqYPxhT2GiYfViSWKcYvBjQ2OXY+tkQGSU\nZOllPWWSZedmPWaSZuhnPWeTZ+loP2iWaOxpQ2maafFqSGqfavdrT2una/9sV2yv\nbQhtYG25bhJua27Ebx5veG/RcCtwhnDgcTpxlXHwcktypnMBc11zuHQUdHB0zHUo\ndYV14XY+dpt2+HdWd7N4EXhueMx5KnmJeed6RnqlewR7Y3vCfCF8gXzhfUF9oX4B\nfmJ+wn8jf4R/5YBHgKiBCoFrgc2CMIKSgvSDV4O6hB2EgITjhUeFq4YOhnKG14c7\nh5+IBIhpiM6JM4mZif6KZIrKizCLlov8jGOMyo0xjZiN/45mjs6PNo+ekAaQbpDW\nkT+RqJIRknqS45NNk7aUIJSKlPSVX5XJljSWn5cKl3WX4JhMmLiZJJmQmfyaaJrV\nm0Kbr5wcnImc951kndKeQJ6unx2fi5/6oGmg2KFHobaiJqKWowajdqPmpFakx6U4\npammGqaLpv2nbqfgqFKoxKk3qamqHKqPqwKrdavprFys0K1ErbiuLa6hrxavi7AA\nsHWw6rFgsdayS7LCszizrrQltJy1E7WKtgG2ebbwt2i34LhZuNG5SrnCuju6tbsu\nu6e8IbybvRW9j74KvoS+/796v/XAcMDswWfB48JfwtvDWMPUxFHEzsVLxcjGRsbD\nx0HHv8g9yLzJOsm5yjjKt8s2y7bMNcy1zTXNtc42zrbPN8+40DnQutE80b7SP9LB\n00TTxtRJ1MvVTtXR1lXW2Ndc1+DYZNjo2WzZ8dp22vvbgNwF3IrdEN2W3hzeot8p\n36/gNuC94UThzOJT4tvjY+Pr5HPk/OWE5g3mlucf56noMui86Ubp0Opb6uXrcOv7\n7IbtEe2c7ijutO9A78zwWPDl8XLx//KM8xnzp/Q09ML1UPXe9m32+/eK+Bn4qPk4\n+cf6V/rn+3f8B/yY/Sn9uv5L/tz/bf//cGFyYQAAAAAAAwAAAAJmZgAA8qcAAA1Z\nAAAT0AAACg52Y2d0AAAAAAAAAAEAAQAAAAAAAAABAAAAAQAAAAAAAAABAAAAAQAA\nAAAAAAABAABuZGluAAAAAAAAADYAAKPAAABUQAAATMAAAJmAAAAmgAAAD0AAAFBA\nAABUQAACMzMAAjMzAAIzMwAAAAAAAAAAc2YzMgAAAAAAAQu3AAAFlv//81cAAAcp\nAAD91///+7f///2mAAAD2gAAwPZtbW9kAAAAAAAATC0AAAaVVjg5RchujAAAAAAA\nAAAAAAAAAAAAAAAA/8AAEQgAlgB9AwEiAAIRAQMRAf/EAB8AAAEFAQEBAQEBAAAA\nAAAAAAABAgMEBQYHCAkKC//EALUQAAIBAwMCBAMFBQQEAAABfQECAwAEEQUSITFB\nBhNRYQcicRQygZGhCCNCscEVUtHwJDNicoIJChYXGBkaJSYnKCkqNDU2Nzg5OkNE\nRUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6g4SFhoeIiYqSk5SVlpeYmZqi\no6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2drh4uPk5ebn6Onq8fLz\n9PX29/j5+v/EAB8BAAMBAQEBAQEBAQEAAAAAAAABAgMEBQYHCAkKC//EALURAAIB\nAgQEAwQHBQQEAAECdwABAgMRBAUhMQYSQVEHYXETIjKBCBRCkaGxwQkjM1LwFWJy\n0QoWJDThJfEXGBkaJicoKSo1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpz\ndHV2d3h5eoKDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXG\nx8jJytLT1NXW19jZ2uLj5OXm5+jp6vLz9PX29/j5+v/bAEMAAgICAgICAwICAwQD\nAwMEBQQEBAQFBwUFBQUFBwgHBwcHBwcICAgICAgICAoKCgoKCgsLCwsLDQ0NDQ0N\nDQ0NDf/bAEMBAgICAwMDBgMDBg0JBwkNDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0N\n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\nBlk+CJ7ytHy6En8542bB/yC+Z9/zWbVuhg==\n=jmT1\n-----END PGP PUBLIC KEY BLOCK-----`;\n\n  const keyExpiredBindingSig = `-----BEGIN PGP PUBLIC KEY BLOCK-----\n\n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\nhW1Hj9AO8lzggBQ=\n=Nt+N\n-----END PGP PUBLIC KEY BLOCK-----`;\n\n  const sequoiaBobPublicKey = `-----BEGIN PGP PUBLIC KEY BLOCK-----\nComment: Bob's OpenPGP certificate\n\n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\nNEJd3XZRzaXZE2aAMQ==\n=NXei\n-----END PGP PUBLIC KEY BLOCK-----`;\n\n  const signature_with_critical_notation = `-----BEGIN PGP MESSAGE-----\n\nowGbwMvMwMH4oOW7S46CznTG09xJDDE3Wl1KUotLuDousDAwcjBYiSmyXL+48d6x\nU1PSGUxcj8IUszKBVMpMaWAAAgEGZpAeh9SKxNyCnFS95PzcytRiBi5OAZjyXXzM\nf8WYLqv7TXP61Sa4rqT12CI3xaN73YS2pt089f96odCKaEPnWJ3iSGmzJaW/ug10\n2Zo8Wj2k4s7t8wt4H3HtTu+y5UZfV3VOO+l//sdE/o+Lsub8FZH7/eOq7OnbNp4n\nvwjE8mqJXetNMfj8r2SCyvkEnlVRYR+/mnge+ib56FdJ8uKtqSxyvgA=\n=fRXs\n-----END PGP MESSAGE-----`;\n\n  const signature_with_non_human_readable_notations = `-----BEGIN PGP SIGNATURE-----\n\nwncEARYKAB8FAl2TS9MYFAAAAAAADAADdGVzdEBrZXkuY29tAQIDAAoJEGZ9\ngtV/iL8hrhMBAOQ/UgqRTbx1Z8inGmRdUx1cJU1SR4Pnq/eJNH/CFk5DAP0Q\nhUhMKMuiM3pRwdIyDOItkUWQmjEEw7/XmhgInkXsCw==\n=ZGXr\n-----END PGP SIGNATURE-----\n`;\n\n  it('Retrieve the issuer Key ID of a signature', async function () {\n    const publicKey = await openpgp.readKey({ armoredKey: pub_key_arm2 });\n    const privateKey = await openpgp.decryptKey({\n      privateKey: await openpgp.readKey({ armoredKey: priv_key_arm2 }),\n      passphrase: 'hello world'\n    });\n    const message = await openpgp.createMessage({ text: 'test' });\n    const armoredSignature = await openpgp.sign({\n      message,\n      signingKeys: privateKey,\n      signingKeyIDs: privateKey.getKeyID(),\n      detached: true,\n      config: { minRSABits: 1024 }\n    });\n    const signature = await openpgp.readSignature({ armoredSignature });\n    expect(signature.getSigningKeyIDs).to.exist;\n    expect(signature.getSigningKeyIDs().map(x => x.toHex())).to.include(publicKey.getKeyID().toHex());\n  });\n\n  it('Throws when reading a signature missing the creation time', async function () {\n    const armoredSignature = `-----BEGIN PGP SIGNATURE-----\n\nwsDtBAABCAAXFiEE0aZuGiOxgsmYD3iM+/zIKgFeczAACgkQ+/zIKgFeczDjiwv+\nLFUWJohCYtauaVDHBDHWF+tojls+ducY6uuU6iUTBb1969okh2sjUmvPwIjrVXuk\ncfPl616xRqVWolEU9T5sG6MjRlAaG31Oo/FVAVFXZn30ldEtuDss12+/IhES3Wfx\nM1jGdJZ1ZMZJpRsNBJXBegEBFKbPleEd66seuuFfvoIUbgsdj7IT/ZlEMlixelWW\nigXPVY1C05oPbkC8oo0lVSxwdq6gDvm8a52k3GCtXJELrYGH29C+eDqmyLP1zJOt\nNBoZBAqMd9XYVrJtuip436D9pdo5pbg4zCE6uPf2zzx4taK7jGkk6nn7LqVDxvQm\n3dAXUnIxw4V9eL3V8SFAKwmouUmHPRbjfnQ70hxYQxDXUcIwu1aYn13QS1s/F/jf\nDVRZWaAhNdL9BfHfhEsRVsmjMhe0zwRpaepvXnERbnA/lAUHEmEvgfPFz/2GsAo/\nkCNcH9WI6idSzFjuYegECf+ZA1xOCjS9oLTGbSeT7jNfC8dH5+E92qlBLq4Ctt7k\n=lMU7\n-----END PGP SIGNATURE-----`;\n\n    await expect(openpgp.readSignature({ armoredSignature })).to.be.rejectedWith(/Missing signature creation time/);\n  });\n\n  it('Ignores marker packets when verifying signatures', async function () {\n    const signatureWithMarkerPacket = `-----BEGIN PGP SIGNATURE-----\n\nygNQR1DCwPMEAAEKAAYFgl8831AAIQkQ+/zIKgFeczAWIQTRpm4aI7GCyZgPeIz7\n/MgqAV5zMLckDACWiDbasKMTX/+czxHXyVcFJ/+ZeYqKEjYq6LueHy11XjJ0NZAM\nLG9TqsXpWOsHrwE6wUQ7RvKQYtfIAeMUZtD87/XomIj6B/rQC5dHuQTb0b8lrRJb\nOuW1sz6AYwceqkSvN3T5+KKNMXkaFw/DzWGPfqQQJDOqfgKxf5uO7GPVzaIU6aXn\n76iKHQ7wowT2qHoFhd+t4S11iGr6XJef6QqIW2kTetZMf2Dp/rr7228VJJ1S0RdD\nxxKJEbNrmdMNgE8/U+pkWjMQyVOOxWyPKlG3kv2Cu/naj4Lg2io3RhOAuNW5xEJF\ngAId3WUNl3/PCu/PcTS1yS/Nj0ptwjKHwG0Zg8Dk5Jey8lUVyVhjxrV5tb6NLoAG\nRlyTajZ3Sjhsg4mXHopjSF2w30saN64L5VAfGF1afFu7yzNYC+Fn6GL5yTJfKs4j\nPNo4zCwOCumsVP0jWp09yUNflE6MTd21miBgbmPxyLyuwP2YrvT4+rCl+meNZ98a\ncJRRGJPL16wINuk=\n=VNoM\n-----END PGP SIGNATURE-----`;\n\n    const key = await openpgp.readKey({ armoredKey: sequoiaBobPublicKey });\n    const message = await openpgp.createMessage({ text: 'Marker + Detached signature' });\n    const signature = await openpgp.readSignature({ armoredSignature: signatureWithMarkerPacket });\n    const { signatures: [sigInfo] } = await openpgp.verify({ message, signature, verificationKeys: key });\n    expect(await sigInfo.verified).to.be.true;\n  });\n\n\n  it('Testing signature checking on CAST5-enciphered message', async function() {\n    const publicKey = await openpgp.readKey({ armoredKey: pub_key_arm1 });\n    const privateKey = await openpgp.decryptKey({\n      privateKey: await openpgp.readKey({ armoredKey: priv_key_arm1 }),\n      passphrase: 'abcd'\n    });\n    const message = await openpgp.readMessage({ armoredMessage: msg_arm1 });\n    const config = {\n      rejectMessageHashAlgorithms: new Set([openpgp.enums.hash.md5, openpgp.enums.hash.ripemd]),\n      rejectPublicKeyAlgorithms: new Set()\n    };\n    const { data, signatures } = await openpgp.decrypt({ decryptionKeys: privateKey, verificationKeys: publicKey, message, config });\n    expect(data).to.exist;\n    expect(await signatures[0].verified).to.be.true;\n    expect((await signatures[0].signature).packets.length).to.equal(1);\n  });\n\n  it('Consider signature expired at the expiration time', async function() {\n    const key = await openpgp.readKey({ armoredKey: keyExpiredBindingSig });\n    const { embeddedSignature } = key.subkeys[0].bindingSignatures[0];\n    expect(embeddedSignature.isExpired(embeddedSignature.created)).to.be.false;\n    expect(embeddedSignature.isExpired(new Date(embeddedSignature.getExpirationTime() - 1))).to.be.false;\n    expect(embeddedSignature.isExpired(embeddedSignature.getExpirationTime())).to.be.true;\n  });\n\n  it('Signing fails if primary key is expired', async function() {\n    const armoredExpiredKey = `-----BEGIN PGP PRIVATE KEY BLOCK-----\n\nxVgEYKKPDRYJKwYBBAHaRw8BAQdAwJcSQMkHVnZPesPJP1JaB9ptV+wG8Io1\nvxRKvXQe0wMAAP0fdn6gvpVwFUE4bIRcn9hx6eDxSxUu+tg/t959Oo+iahF1\nzRB0ZXN0IDx0ZXN0QGEuaXQ+wpIEEBYKACMFAmCijw0FCQAAAAEECwkHCAMV\nCAoEFgACAQIZAQIbAwIeAQAhCRD16pevybCusRYhBHjm9svlAjmgVWL4wvXq\nl6/JsK6xGUQBAPzxKS2Qs+vWGpxPT2N2T+PLHIgCOxVJVngj4fzREFH1AP9t\nwP+fn3eSsik+vFGy93REmlD1xdu7nW/sHuxY4roqBcddBGCijw0SCisGAQQB\nl1UBBQEBB0Cl1lr+aHfy6V4ePmZUULK6VKTCTPTMaPpR2TzKNIJQBQMBCAcA\nAP9DZWRqQLCIkF38Q0UC/YXLCDdBEQdnlwpHgA0W1bSWmA3uwn4EGBYIAA8F\nAmCijw0FCQAAAAECGwwAIQkQ9eqXr8mwrrEWIQR45vbL5QI5oFVi+ML16pev\nybCusYE4AQCYbXw8ZWoMevbOM7lAttkwyrG3V/nTW6BVo7/M9Pr9swEA0mDI\nDQmhI0SZoTKy4EGhS0bNJ+g2+dJ8Y22fKzLWXwo=\n=qiIN\n-----END PGP PRIVATE KEY BLOCK-----`;\n    const key = await openpgp.readKey({ armoredKey: armoredExpiredKey });\n    await expect(openpgp.sign({\n      signingKeys: key,\n      message: await openpgp.createMessage({ text: 'Hello World' })\n    })).to.be.rejectedWith(/key is expired/);\n  });\n\n  it('Signing fails if the signing date is before the key creation date', async function() {\n    const key = await openpgp.decryptKey({\n      privateKey: await openpgp.readKey({ armoredKey: priv_key_arm2 }),\n      passphrase: 'hello world'\n    });\n    await expect(openpgp.sign({\n      signingKeys: key,\n      date: new Date(key.keyPacket.created - 3600),\n      message: await openpgp.createMessage({ text: 'Hello World' })\n    })).to.be.rejectedWith(/Signature creation time is in the future/);\n  });\n\n  it('Verification fails if primary key binding signature is expired', async function() {\n    const armoredSignature = `-----BEGIN PGP SIGNATURE-----\n\nwsDzBAABCgAGBYJfLAFsACEJEHwvqk35PDeyFiEEHdzhXwkhfO4vOzdgfC+qTfk8\nN7KiqwwAts4QGB7v9bABCC2qkTxJhmStC0wQMcHRcjL/qAiVnmasQWmvE9KVsdm3\nAaXd8mIx4a37/RRvr9dYrY2eE4uw72cMqPxNja2tvVXkHQvk1oEUqfkvbXs4ypKI\nNyeTWjXNOTZEbg0hbm3nMy+Wv7zgB1CEvAsEboLDJlhGqPcD+X8a6CJGrBGUBUrv\nKVmZr3U6vEzClz3DBLpoddCQseJRhT4YM1nKmBlZ5quh2LFgTSpajv5OsZheqt9y\nEZAPbqmLhDmWRQwGzkWHKceKS7nZ/ox2WK6OS7Ob8ZGZkM64iPo6/EGj5Yc19vQN\nAGiIaPEGszBBWlOpHTPhNm0LB0nMWqqaT87oNYwP8CQuuxDb6rKJ2lffCmZH27Lb\nUbQZcH8J+0UhpeaiadPZxH5ATJAcenmVtVVMLVOFnm+eIlxzov9ntpgGYt8hLdXB\nITEG9mMgp3TGS9ZzSifMZ8UGtHdp9QdBg8NEVPFzDOMGxpc/Bftav7RRRuPiAER+\n7A5CBid5\n=aQkm\n-----END PGP SIGNATURE-----`;\n    const key = await openpgp.readKey({ armoredKey: keyExpiredBindingSig });\n    const signature = await openpgp.readSignature({ armoredSignature });\n    const { signatures: [sigInfo] } = await openpgp.verify({\n      verificationKeys: key,\n      message: await openpgp.createMessage({ text: 'Hello World :)' }),\n      signature\n    });\n    await expect(sigInfo.verified).to.be.rejectedWith(/Signature is expired/);\n  });\n\n  it('Verification fails if signing key\\'s self-sig were created after the time of signing, unless config allows it', async function() {\n    const armoredReformattedKey = `-----BEGIN PGP PRIVATE KEY BLOCK-----\n\nxVgEYWmlshYJKwYBBAHaRw8BAQdAAxpFNPiHxz9q4HBzWqveHdP/knjwlgv8\npEQCMHDpIZIAAP9WFlwHDuVlvNb7CyoikwmG01nmdMDe9wXQRWA5vasWKA+g\nzSV0ZXN0QHJlZm9ybWF0LmNvbSA8dGVzdEByZWZvcm1hdC5jb20+wowEEBYK\nAB0FAmFppjQECwkHCAMVCAoEFgACAQIZAQIbAwIeAQAhCRAOZNKOg+/XQxYh\nBGqP/hIaYCSJsZ4TrQ5k0o6D79dD+c8BAIXdh2hrC+l49WPN/KZF+ZzvWCWa\nW5n+ozbp/sOGXvODAP4oGEj0RUDDA33b6x7fhQysBZxdrrnHxP9AXEdOTQC3\nCsddBGFppbISCisGAQQBl1UBBQEBB0Cjy8Z2K7rl6J6AK1lCfVozmyLE0Gbv\n1cspce6oCF6oCwMBCAcAAP9OL5V80EaYm2ic19aM+NtTj4UNOqKqIt10AaH9\nSlcdMBDgwngEGBYIAAkFAmFppjQCGwwAIQkQDmTSjoPv10MWIQRqj/4SGmAk\nibGeE60OZNKOg+/XQx/EAQCM0UYrObp60YbOCxu07Dm6XjCVylbOcsaxCnE7\n2eMU4AD+OkgajZgbqSIdAR1ud76FW+W+3xlDi/SMFdU7D49SbQI=\n=ASQu\n-----END PGP PRIVATE KEY BLOCK-----\n\n`;\n    const armoredMessage = `-----BEGIN PGP MESSAGE-----\n\nxA0DAQoWDmTSjoPv10MByw91AGFpplFwbGFpbnRleHTCdQQBFgoABgUCYWml\nsgAhCRAOZNKOg+/XQxYhBGqP/hIaYCSJsZ4TrQ5k0o6D79dDDWwBAKUnRWXj\nP3HTW521iD/DngK54mYS3feQzhDokhkYjO3UAP0ZlsYShKaJvXh+JgvR5BPP\ngjVcn04JVVlxqgVnMqeVBw==\n=eyO7\n-----END PGP MESSAGE-----`;\n    // the key was reformatted and the message signature date preceeds the key self-signature creation date\n    const key = await openpgp.readKey({ armoredKey: armoredReformattedKey });\n    const { signatures: [sigInfoRejected] } = await openpgp.verify({\n      verificationKeys: key,\n      message: await openpgp.readMessage({ armoredMessage })\n    });\n    await expect(sigInfoRejected.verified).to.be.rejectedWith(/Signature creation time is in the future/);\n\n    // since the key is valid at the current time, the message should be verifiable if the `config` allows it\n    const { signatures: [sigInfoValid] } = await openpgp.verify({\n      verificationKeys: key,\n      message: await openpgp.readMessage({ armoredMessage }),\n      config: { allowInsecureVerificationWithReformattedKeys: true }\n    });\n    expect(await sigInfoValid.verified).to.be.true;\n  });\n\n  it('Verification fails if signing key was already expired at the time of signing (one-pass signature, streamed)', async function() {\n    const armoredMessage = `-----BEGIN PGP MESSAGE-----\n\nxA0DAQgB4IT3RGwgLJcByxR1AGCc8BxIZWxsbyBXb3JsZCA6KcKzBAEBCAAG\nBQJgnPAcACEJEOCE90RsICyXFiEE19Gx3sbKlGcANEXF4IT3RGwgLJdssAP+\nKpyVi30z5iMckULAQ3Q34IB29Gxa1/99ABSld6iIVGRCfmZZlS5UGcxJJGoL\nvZ1RAL4YQx/GLV1dBcKWFwzb5G2/ip4coDMCDGTAwnwjcPwjHpfMQ9gX59mG\nAkLaG/AkATpuH+DMkYDmKbDLGgD+N4yuxXBJmBfC2IBe4J1S2Gg=\n=zvNP\n-----END PGP MESSAGE-----`;\n    const key = await openpgp.decryptKey({\n      privateKey: await openpgp.readKey({ armoredKey: priv_key_arm2 }),\n      passphrase: 'hello world'\n    });\n    const { privateKey: expiredKey } = await openpgp.reformatKey({\n      privateKey: key,\n      userIDs: key.users.map(user => user.userID),\n      keyExpirationTime: 1,\n      date: key.keyPacket.created,\n      format: 'object'\n    });\n    await stream.loadStreamsPonyfill();\n    const { signatures: [sigInfo] } = await openpgp.verify({\n      verificationKeys: expiredKey,\n      message: await openpgp.readMessage({ armoredMessage: stream.toStream(armoredMessage) }),\n      config: { minRSABits: 1024 }\n\n    });\n    await expect(sigInfo.verified).to.be.rejectedWith(/Primary key is expired/);\n  });\n\n  it('Verification fails if signing key was already expired at the time of signing (standard signature)', async function() {\n    const armoredMessage = `-----BEGIN PGP MESSAGE-----\n\nwrMEAQEIAAYFAmCc8BwAIQkQ4IT3RGwgLJcWIQTX0bHexsqUZwA0RcXghPdE\nbCAsl2ywA/4qnJWLfTPmIxyRQsBDdDfggHb0bFrX/30AFKV3qIhUZEJ+ZlmV\nLlQZzEkkagu9nVEAvhhDH8YtXV0FwpYXDNvkbb+KnhygMwIMZMDCfCNw/CMe\nl8xD2Bfn2YYCQtob8CQBOm4f4MyRgOYpsMsaAP43jK7FcEmYF8LYgF7gnVLY\naMsUdQBgnPAcSGVsbG8gV29ybGQgOik=\n=s9xh\n-----END PGP MESSAGE-----`;\n    const key = await openpgp.decryptKey({\n      privateKey: await openpgp.readKey({ armoredKey: priv_key_arm2 }),\n      passphrase: 'hello world'\n    });\n    const { privateKey: expiredKey } = await openpgp.reformatKey({\n      privateKey: key,\n      userIDs: key.users.map(user => user.userID),\n      keyExpirationTime: 1,\n      date: key.keyPacket.created,\n      format: 'object'\n    });\n    await stream.loadStreamsPonyfill();\n    const { signatures: [sigInfo] } = await openpgp.verify({\n      verificationKeys: expiredKey,\n      message: await openpgp.readMessage({ armoredMessage: stream.toStream(armoredMessage) }),\n      config: { minRSABits: 1024 }\n    });\n    await expect(sigInfo.verified).to.be.rejectedWith(/Primary key is expired/);\n  });\n\n  it('Verification succeeds if an expired signing key was valid at the time of signing (with streaming)', async function() {\n    const armoredMessage = `-----BEGIN PGP MESSAGE-----\n\nxA0DAQgB4IT3RGwgLJcByxF1AGCdJvJoZWxsbyB3b3JsZMKzBAEBCAAGBQJS\nYS9OACEJEOCE90RsICyXFiEE19Gx3sbKlGcANEXF4IT3RGwgLJcPBQP/csZd\n9AhZQ3+dPkwlqlsXqYMlVEagYDavlUDI2CEJ2cn1rqHBuMlRkmYs7UqODku4\nFhJ6WvghiEKx8vqghDuaUXmcKuXhYe+PomD4XBmpbURBXCdPnojTINUj7GPK\neSvSZutLuKKbidSYMLhWROPlwKc2GU2ws6PrLZAyCAel/lU=\n=xDib\n-----END PGP MESSAGE-----`;\n    const key = await openpgp.decryptKey({\n      privateKey: await openpgp.readKey({ armoredKey: priv_key_arm2 }),\n      passphrase: 'hello world'\n    });\n    const { privateKey: expiredKey } = await openpgp.reformatKey({\n      privateKey: key,\n      userIDs: key.users.map(user => user.userID),\n      keyExpirationTime: 1,\n      date: key.keyPacket.created,\n      format: 'object'\n    });\n    await stream.loadStreamsPonyfill();\n    const { signatures: [sigInfo] } = await openpgp.verify({\n      verificationKeys: expiredKey,\n      message: await openpgp.readMessage({ armoredMessage: stream.toStream(armoredMessage) }),\n      config: { minRSABits: 1024 }\n    });\n    expect(await sigInfo.verified).to.be.true;\n  });\n\n  it('Verification succeeds if an expired signing key was valid at the time of signing (without streaming)', async function() {\n    const armoredMessage = `-----BEGIN PGP MESSAGE-----\n\nxA0DAQgB4IT3RGwgLJcByxF1AGCdJvJoZWxsbyB3b3JsZMKzBAEBCAAGBQJS\nYS9OACEJEOCE90RsICyXFiEE19Gx3sbKlGcANEXF4IT3RGwgLJcPBQP/csZd\n9AhZQ3+dPkwlqlsXqYMlVEagYDavlUDI2CEJ2cn1rqHBuMlRkmYs7UqODku4\nFhJ6WvghiEKx8vqghDuaUXmcKuXhYe+PomD4XBmpbURBXCdPnojTINUj7GPK\neSvSZutLuKKbidSYMLhWROPlwKc2GU2ws6PrLZAyCAel/lU=\n=xDib\n-----END PGP MESSAGE-----`;\n    const key = await openpgp.decryptKey({\n      privateKey: await openpgp.readKey({ armoredKey: priv_key_arm2 }),\n      passphrase: 'hello world'\n    });\n    const { privateKey: expiredKey } = await openpgp.reformatKey({\n      privateKey: key,\n      userIDs: key.users.map(user => user.userID),\n      keyExpirationTime: 1,\n      date: key.keyPacket.created,\n      format: 'object'\n    });\n    const { signatures: [sigInfo] } = await openpgp.verify({\n      verificationKeys: expiredKey,\n      message: await openpgp.readMessage({ armoredMessage }),\n      config: { minRSABits: 1024 }\n    });\n    expect(await sigInfo.verified).to.be.true;\n  });\n\n  it('Reject cleartext message with arbitrary text added around hash headers (spoofed cleartext message)', async function() {\n    await expect(openpgp.readCleartextMessage({ cleartextMessage: `-----BEGIN PGP SIGNED MESSAGE-----\nThis is not signed but you might think it is Hash: SHA512\n\nThis is signed\n-----BEGIN PGP SIGNATURE-----\n\nwnUEARYKACcFgmTsqxgJkEhlqJkkhIfRFiEEUA/OS4xZ3EwNC5l8SGWomSSE\nh9EAALyPAQDDR0IYwq/5XMVSYPWojBamM4NhcP5arA656ALIq9cJYAEAlw0H\nFk7EflUZzngwY4lBzYAfnNBjEjc30xD/ddo+rwE=\n=O7mt\n-----END PGP SIGNATURE-----` })).to.be.rejectedWith(/Only \"Hash\" header allowed/);\n\n    await expect(openpgp.readCleartextMessage({ cleartextMessage: `-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA512\\vThis is not signed but you might think it is \n\nThis is signed\n-----BEGIN PGP SIGNATURE-----\n\nwnUEARYKACcFgmTsqxgJkEhlqJkkhIfRFiEEUA/OS4xZ3EwNC5l8SGWomSSE\nh9EAALyPAQDDR0IYwq/5XMVSYPWojBamM4NhcP5arA656ALIq9cJYAEAlw0H\nFk7EflUZzngwY4lBzYAfnNBjEjc30xD/ddo+rwE=\n=O7mt\n-----END PGP SIGNATURE-----` })).to.be.rejectedWith(/Unknown hash algorithm in armor header/);\n  });\n\n  it('Supports non-human-readable notations', async function() {\n    const { packets: [signature] } = await openpgp.readSignature({ armoredSignature: signature_with_non_human_readable_notations });\n    // There are no human-readable notations so `notations` property does not\n    // expose the `test@key.com` notation.\n    expect(Object.keys(signature.notations).length).to.equal(0);\n    expect(signature.notations['test@key.com']).to.equal(undefined);\n\n    // The notation is readable through `rawNotations` property:\n    expect(signature.rawNotations.length).to.equal(1);\n    const notation = signature.rawNotations[0];\n    expect(notation.name).to.equal('test@key.com');\n    expect(notation.value).to.deep.equal(new Uint8Array([0x01, 0x02, 0x03]));\n    expect(notation.humanReadable).to.equal(false);\n  });\n\n  it('Verify V4 signature. Hash: SHA1. PK: RSA. Signature Type: 0x00 (binary document)', async function() {\n    const { rejectMessageHashAlgorithms, minRSABits } = openpgp.config;\n    Object.assign(openpgp.config, {\n      rejectMessageHashAlgorithms: new Set([openpgp.enums.hash.md5, openpgp.enums.hash.ripemd]),\n      minRSABits: 1024\n    });\n    try {\n      const signedArmor =\n        ['-----BEGIN PGP MESSAGE-----',\n          'Version: GnuPG v2.0.19 (GNU/Linux)',\n          '',\n          'owGbwMvMwMT4oOW7S46CznTGNeZJLCWpFSVBU3ZGF2fkF5Uo5KYWFyemp3LlAUUV',\n          'cjLzUrneTp3zauvaN9O26L9ZuOFNy4LXyydwcXXMYWFgZGJgY2UCaWXg4hSAmblK',\n          'nPmfsXYxd58Ka9eVrEnSpzilr520fXBrJsf2P/oTqzTj3hzyLG0o3TTzxFfrtOXf',\n          'cw6U57n3/Z4X0pEZ68C5/o/6NpPICD7fuEOz3936raZ6wXGzueY8pfPnVjY0ajAc',\n          'PtJzvvqj+ubYaT1sK9wWhd9lL3/V+9Zuua9QjOWC22buchsCroh8fLoZAA==',\n          '=VH8F',\n          '-----END PGP MESSAGE-----'].join('\\n');\n\n      const sMsg = await openpgp.readMessage({ armoredMessage: signedArmor });\n      const pub_key = await openpgp.readKey({ armoredKey: pub_key_arm2 });\n      const verified = await sMsg.verify([pub_key]);\n      stream.readToEnd(sMsg.getLiteralData());\n      expect(verified).to.exist;\n      expect(verified).to.have.length(1);\n      expect(await verified[0].verified).to.be.true;\n      expect((await verified[0].signature).packets.length).to.equal(1);\n    } finally {\n      Object.assign(openpgp.config, { rejectMessageHashAlgorithms, minRSABits });\n    }\n  });\n\n  it('Verify signature of signed and encrypted message from GPG2 with openpgp.decrypt', async function() {\n    const msg_armor =\n      ['-----BEGIN PGP MESSAGE-----',\n        'Version: GnuPG v2.0.19 (GNU/Linux)',\n        '',\n        'hIwD4IT3RGwgLJcBBADEBdm+GEW7IV1K/Bykg0nB0WYO08ai7/8/+Y/O9xu6RiU0',\n        'q7/jWuKms7kSjw9gxMCjf2dGnAuT4Cg505Kj5WfeBuHh618ovO8qo4h0qHyp1/y3',\n        'o1P0IXPAb+LGJOeO7DyM9Xp2AOBiIKOVWzFTg+MBZOc+XZEVx3FioHfm9SSDudLA',\n        'WAEkDakCG6MRFj/7SmOiV8mQKH+YPMKT69eDZW7hjINabrpM2pdRU7c9lC7CMUBx',\n        'Vj7wZsQBMASSC8f2rhpGA2iKvYMsmW3g9R1xkvj1MXWftSPUS4jeNTAgEwvvF6Af',\n        'cP+OYSXKlTbwfEr73ES2O3/IFE9sHRjPqWaxWuv4DDQ5YfIxE54C1aE8Aq5/QaIH',\n        'v38TUSia0yEMCc/tJd58DikkT07AF162tcx9Ro0ZjhudyuvUyXIfPfxA+XWR2pdz',\n        'ifxyV4zia9RvaCUY8vXGM+gQJ3NNXx2LkZA3kWUEyxFVL1Vl/XUQY0M6U+uccSk4',\n        'eMXm6eyEWDcj0lBRckqKoKo1w/uan11jPuHsnRz6jO9DsuKEz79UDgI=',\n        '=cFi7',\n        '-----END PGP MESSAGE-----'].join('\\n');\n\n    const plaintext = 'short message\\nnext line\\n\ud55c\uad6d\uc5b4/\uc870\uc120\ub9d0';\n    const message = await openpgp.readMessage({ armoredMessage: msg_armor });\n    const pubKey = await openpgp.readKey({ armoredKey: pub_key_arm2 });\n    const privKey = await openpgp.decryptKey({\n      privateKey: await openpgp.readKey({ armoredKey: priv_key_arm2 }),\n      passphrase: 'hello world'\n    });\n\n    return openpgp.decrypt({\n      decryptionKeys: privKey, verificationKeys: pubKey , message, config: { minRSABits: 1024 }\n    }).then(async ({ signatures, data }) => {\n      expect(data).to.exist;\n      expect(data).to.equal(plaintext);\n      expect(signatures).to.have.length(1);\n      expect(await signatures[0].verified).to.be.true;\n      expect((await signatures[0].signature).packets.length).to.equal(1);\n    });\n  });\n\n  it('Verify signed message with two one pass signatures', async function() {\n    const msg_armor =\n      ['-----BEGIN PGP MESSAGE-----',\n        'Version: GnuPG v2.0.19 (GNU/Linux)',\n        '',\n        'owGbwMvMwMF4+5Pyi4Jg3y8ME8DcBy3fXXIUdKYzrjFNYilJrSgJmsXDXJyRX1Si',\n        'kJtaXJyYnsqVBxRVyMnMS+V6O3XOq61r30zbov9m4YY3LQteL5/QMYeFgZGDgY2V',\n        'CaSRgYtTAGZiYxYLwySbQk07ptZel6gmjrKyBWsyWdkOG3oscLBdIpXXfDdb6fNv',\n        '8ULN5L1ed+xNo79P2dBotWud6vn7e9dtLJ7o12PunnvEz8gyyvP4/As/los0xsnZ',\n        'H+8ublrhvGtLxJUZuUKZO6QdHq2Nepuw8OrfiMXPBDQXXpV2q11Ze+rD3lndgv/C',\n        'bJQNOhll0J0H839jFvt/16m20h/ZmDoWqJywapnypjdIjcXr+7rJFess40yenV7Q',\n        '2LSu/EX6Aq29x+dv+GPUMfuhTNE3viWWUR4PD6T7XfmdViUwmSf8fkRNUn/t3a2n',\n        'cq46Xr36seCor/OLp0atSZwHrjx2SU5zPLheZn+zw/0d1/YZnD7AEeP9s/Cuycyv',\n        'CZ5HZNKufvB8fsh+dfdSXW0GfqkPfxk36Vw8ufpjaoZDyt2nxxg/6D4KS3UvZzv3',\n        'axdLZ9yd0OJNZv4P501If24W4vTGz6nI7Ser8Yd2PiOvE5MWMT0wLZQ+zPX1sv0/',\n        's8PvkyWmVM0O0fB/ZSHovHNNPffDg/rWhzOmXQ9/7vTn477F+aWm5sYzJ75/BQA=',\n        '=+L0S',\n        '-----END PGP MESSAGE-----'].join('\\n');\n    const plaintext = 'short message\\nnext line\\n\ud55c\uad6d\uc5b4/\uc870\uc120\ub9d0';\n    const sMsg = await openpgp.readMessage({ armoredMessage: msg_armor });\n    const pubKey2 = await openpgp.readKey({ armoredKey: pub_key_arm2 });\n    const pubKey3 = await openpgp.readKey({ armoredKey: pub_key_arm3 });\n\n    const keyIDs = sMsg.getSigningKeyIDs();\n    expect(pubKey2.getKeys(keyIDs[1])).to.not.be.empty;\n    expect(pubKey3.getKeys(keyIDs[0])).to.not.be.empty;\n\n    const { data, signatures } = await openpgp.verify({ message: sMsg, verificationKeys: [pubKey2, pubKey3], config: { minRSABits: 1024 } });\n    expect(data).to.equal(plaintext);\n    expect(signatures).to.exist;\n    expect(signatures).to.have.length(2);\n    expect(await signatures[0].verified).to.be.true;\n    expect(await signatures[1].verified).to.be.true;\n    expect((await signatures[0].signature).packets.length).to.equal(1);\n    expect((await signatures[1].signature).packets.length).to.equal(1);\n  });\n\n  it('Verify fails with signed message with critical notations', async function() {\n    const message = await openpgp.readMessage({ armoredMessage: signature_with_critical_notation });\n    const key = await openpgp.readKey({ armoredKey: pub_key_arm2 });\n    const { signatures: [sig] } = await openpgp.verify({ message, verificationKeys: key, config: { minRSABits: 1024 } });\n    await expect(sig.verified).to.be.rejectedWith(/Unknown critical notation: test@example.com/);\n  });\n\n  it('Verify succeeds with known signed message with critical notations', async function() {\n    const message = await openpgp.readMessage({ armoredMessage: signature_with_critical_notation });\n    const key = await openpgp.readKey({ armoredKey: pub_key_arm2 });\n\n    const config = { knownNotations: ['test@example.com'], minRSABits: 1024 };\n    const { signatures: [sig] } = await openpgp.verify({ message, verificationKeys: key, config });\n    expect(await sig.verified).to.be.true;\n  });\n\n  it('Can create notations', async function() {\n    const privKey = await openpgp.decryptKey({\n      privateKey: await openpgp.readKey({ armoredKey: priv_key_arm2 }),\n      passphrase: 'hello world'\n    });\n\n    const config = { minRSABits: 1024 };\n    const message_with_notation = await openpgp.encrypt({\n      message: await openpgp.createMessage({ text: 'test' }),\n      encryptionKeys: privKey,\n      signingKeys: privKey,\n      signatureNotations: [\n        {\n          name: 'test@example.com',\n          value: new TextEncoder().encode('test'),\n          humanReadable: true,\n          critical: true\n        },\n        {\n          name: 's\u00e9paration-de-domaine@proton.ch',\n          value: new Uint8Array([0, 1, 2, 3]),\n          humanReadable: false,\n          critical: false\n        }\n      ],\n      config\n    });\n    expect(openpgp.decrypt({\n      message: await openpgp.readMessage({ armoredMessage: message_with_notation }),\n      decryptionKeys: privKey,\n      verificationKeys: privKey,\n      expectSigned: true,\n      config\n    })).to.be.rejectedWith('Unknown critical notation: test@example.com');\n    const { signatures: [sig] } = await openpgp.decrypt({\n      message: await openpgp.readMessage({ armoredMessage: message_with_notation }),\n      decryptionKeys: privKey,\n      verificationKeys: privKey,\n      config: {\n        knownNotations: ['test@example.com'],\n        ...config\n      }\n    });\n    expect(await sig.verified).to.be.true;\n    const { packets: [{ rawNotations: notations }] } = await sig.signature;\n    expect(notations).to.have.length(2);\n    expect(notations[0].name).to.equal('test@example.com');\n    expect(notations[0].value).to.deep.equal(new Uint8Array([116, 101, 115, 116]));\n    expect(notations[0].humanReadable).to.be.true;\n    expect(notations[0].critical).to.be.true;\n    expect(notations[1].name).to.equal('s\u00e9paration-de-domaine@proton.ch');\n    expect(notations[1].value).to.deep.equal(new Uint8Array([0, 1, 2, 3]));\n    expect(notations[1].humanReadable).to.be.false;\n    expect(notations[1].critical).to.be.false;\n  });\n\n  it('Verify cleartext signed message with two signatures with openpgp.verify', async function() {\n    const cleartextMessage =\n      ['-----BEGIN PGP SIGNED MESSAGE-----',\n        'Hash: SHA256',\n        '',\n        'short message',\n        'next line',\n        '\ud55c\uad6d\uc5b4/\uc870\uc120\ub9d0',\n        '-----BEGIN PGP SIGNATURE-----',\n        'Version: GnuPG v2.0.19 (GNU/Linux)',\n        '',\n        'iJwEAQEIAAYFAlKcju8ACgkQ4IT3RGwgLJci6gP/dCmIraUa6AGpJxzGfK+jYpjl',\n        'G0KunFyGmyPxeJVnPi2bBp3EPIbiayQ71CcDe9DKpF046tora07AA9eo+/YbvJ9P',\n        'PWeScw3oj/ejsmKQoDBGzyDMFUphevnhgc5lENjovJqmiu6FKjNmADTxcZ/qFTOq',\n        '44EWTgdW3IqXFkNpKjeJARwEAQEIAAYFAlKcju8ACgkQ2/Ij6HBTTfQi6gf9HxhE',\n        'ycLDhQ8iyC090TaYwsDytScU2vOMiI5rJCy2tfDV0pfn+UekYGMnKxZTpwtmno1j',\n        'mVOlieENszz5IcehS5TYwk4lmRFjoba+Z8qwPEYhYxP29GMbmRIsH811sQHFTigo',\n        'LI2t4pSSSUpAiXd9y6KtvkWcGGn8IfkNHCEHPh1ov28QvH0+ByIiKYK5N6ZB8hEo',\n        '0uMYhKQPVJdPCvMkAxQCRPw84EvmxuJ0HMCeSB9tHQXpz5un2m8D9yiGpBQPnqlW',\n        'vCCq7fgaUz8ksxvQ9bSwv0iIIbbBdTP7Z8y2c1Oof6NDl7irH+QCeNT7IIGs8Smn',\n        'BEzv/FqkQAhjy3Krxg==',\n        '=3Pkl',\n        '-----END PGP SIGNATURE-----'].join('\\n');\n\n    const plaintext = 'short message\\nnext line\\n\ud55c\uad6d\uc5b4/\uc870\uc120\ub9d0';\n    const message = await openpgp.readCleartextMessage({ cleartextMessage });\n    const pubKey2 = await openpgp.readKey({ armoredKey: pub_key_arm2 });\n    const pubKey3 = await openpgp.readKey({ armoredKey: pub_key_arm3 });\n\n    const keyIDs = message.getSigningKeyIDs();\n\n    expect(pubKey2.getKeys(keyIDs[0])).to.not.be.empty;\n    expect(pubKey3.getKeys(keyIDs[1])).to.not.be.empty;\n\n    return openpgp.verify({ verificationKeys:[pubKey2, pubKey3], message, config: { minRSABits: 1024 } }).then(async function({ signatures, data }) {\n      expect(data).to.equal(plaintext);\n      expect(signatures).to.have.length(2);\n      expect(await signatures[0].verified).to.be.true;\n      expect(await signatures[1].verified).to.be.true;\n      expect((await signatures[0].signature).packets.length).to.equal(1);\n      expect((await signatures[1].signature).packets.length).to.equal(1);\n    });\n  });\n\n  it('Verify latin-1 signed message', async function() {\n    const latin1Binary = util.hexToUint8Array('48e46c6cf62057e86c74');\n    const message = await openpgp.createMessage({ binary: latin1Binary });\n\n    message.appendSignature(`-----BEGIN PGP SIGNATURE-----\n\niQIzBAEBCAAdFiEET5+J9VBawdGiYGMc2xGHud1faTsFAl5lE/AACgkQ2xGHud1f\naTtIuw//YWrVaXLyP8sGBc0uUSLxQbmfQQYV8Oq8Vsg+jV4orc73wmEy8+Nj5m2g\nfFEPaWy07dfDBtv874XCsZmCM+ZhwkGaT9lwcCxkxNZeywTE5JRS1/6Ky3G4gDZ/\nQozTXr/ZNPXF6bBENqhfqeO2xkD577bjiPu5wLcu3/RR39YnWp5zQu9ynJbpwobz\nHHQW5TgSUgi/9tInQ+cc7vMkHzfe2Zg45HkyaStBW1x7Fm9FLv8GNw1R2jVbUlsX\nSEL7yPrsZAmgyu1ifMrTTY4vunuUNUFiGZN9UC75b7s4tjKkvJ0sfdQusC0vmcE0\nWq7dAoeX72B94TITuXldDGIfL01smycm+mEvf/kXxQg81wj4la72IzhdWeC6r4PF\n558QDEtZy984iL8RJKpbjwgsxyvfM9zf9qtmuNdscbZaZsx9LRe21uaKhX8yJsAU\njCgyjM5e7CMdvBUyxrpGzS+mP/rh77r2TXkg6u2+8Nj4osxwkfxvDIGpJfaIWl2a\nsNQ4Bsgm6rcNYaxUVbOsBFJddBb503KpTX5aK8TuC6AINg6bV6rmfj2Jc/QX4eHb\nXgm6EyJo74z5R7YvA3XdUZf1sfwfoMLbbUqpeHEZOcWy4vrS79Omx1MyPxKHPiXU\nPAAeuQTUrcJdZeJ86eQ9cCUB216HCwSKOWTQRzL+hBWKXij4WD4=\n=ZEFm\n-----END PGP SIGNATURE-----`);\n\n    const pubKey = await openpgp.readKey({ armoredKey: pub_latin1_msg });\n\n    return message.verify([pubKey]).then(async verifiedSig => {\n      expect(await stream.readToEnd(message.getLiteralData())).to.equal(latin1Binary);\n      expect(verifiedSig).to.exist;\n      expect(verifiedSig).to.have.length(1);\n      expect(await verifiedSig[0].verified).to.be.true;\n      expect((await verifiedSig[0].signature).packets.length).to.equal(1);\n    });\n  });\n\n\n  it('Verify cleartext signed message with trailing spaces from GPG', async function() {\n    const cleartextMessage =\n      `-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA1\n\nspace: \nspace and tab: \\t\nno trailing space\n\ntab:\\t\ntab and space:\\t \n-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niJwEAQECAAYFAlrZzCQACgkQ4IT3RGwgLJeWggP+Pb33ubbELIzg9/imM+zlR063\ng0FbG4B+RGZNFSbaDArUgh9fdVqBy8M9vvbbDMBalSiQxY09Lrasfb+tsomrygbN\nNisuPRa5phPhn1bB4hZDb2ed/iK41CNyU7QHuv4AAvLC0mMamRnEg0FW2M2jZLGh\nzmuVOdNuWQqxT9Sqa84=\n=bqAR\n-----END PGP SIGNATURE-----`;\n\n    const plaintext = 'space: \\nspace and tab: \\t\\nno trailing space\\n  \\ntab:\\t\\ntab and space:\\t ';\n    const message = await openpgp.readCleartextMessage({ cleartextMessage });\n    const pubKey = await openpgp.readKey({ armoredKey: pub_key_arm2 });\n\n    const keyIDs = message.getSigningKeyIDs();\n\n    expect(pubKey.getKeys(keyIDs[0])).to.not.be.empty;\n\n    const { signatures, data } = await openpgp.verify({\n      verificationKeys:[pubKey],\n      message,\n      config: { minRSABits: 1024, rejectMessageHashAlgorithms: new Set() }\n    });\n    expect(data).to.equal(plaintext.replace(/[ \\t]+$/mg, ''));\n    expect(signatures).to.have.length(1);\n    expect(await signatures[0].verified).to.be.true;\n    expect((await signatures[0].signature).packets.length).to.equal(1);\n  });\n\n  it('Verify cleartext signed message with trailing spaces incorrectly normalised (from OpenPGP.js v3.0.9-v5.3.1)', async function() {\n    // We used to not strip trailing whitespace with \\r\\n line endings when signing cleartext messages\n    const armoredSignature = `-----BEGIN PGP SIGNATURE-----\nVersion: OpenPGP.js v5.3.1\n\nwrMEAQEIAAYFAmLjqsQAIQkQ4IT3RGwgLJcWIQTX0bHexsqUZwA0RcXghPdE\nbCAsl2TvBADLOHYXevDSc3LtLRYR1HteijL/MssCCoZIfuGihd5AzJpD2h2j\nL8UuxlfERJn15RlFsDzlkMNMefJp5ltC8kKcf+HTuBUi+xf2t2nvlf8CrdjY\nvcEqswjkODDxxZ842h0sC0ZtbzWuMXIvODEdzZxBjhlmZmv9VKQ5uyb0oD/5\nWQ==\n=o2gq\n-----END PGP SIGNATURE-----`;\n    const cleartextMessage = `\n-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA256\n\nthis text    \nused to be incorrectly normalised\n${armoredSignature}\n`;\n\n    const signedText = 'this text    \\r\\nused to be incorrectly normalised';\n    const message = await openpgp.readCleartextMessage({ cleartextMessage });\n    const pubKey = await openpgp.readKey({ armoredKey: pub_key_arm2 });\n\n    // Direct verification won't work since the signed data was not stripped of the trailing whitespaces,\n    // as required for cleartext messages. Verification would always fail also in the affected OpenPGP.js versions.\n    await expect(openpgp.verify({\n      verificationKeys:[pubKey],\n      message,\n      config: { minRSABits: 1024 },\n      expectSigned: true\n    })).to.be.rejectedWith(/Signed digest did not match/);\n\n    // The signature should be verifiable over non-normalised text\n    const { signatures, data } = await openpgp.verify({\n      verificationKeys:[pubKey],\n      message: await openpgp.createMessage({ text: signedText }),\n      signature: await openpgp.readSignature({ armoredSignature }),\n      config: { minRSABits: 1024 },\n      expectSigned: true\n    });\n    expect(data).to.equal(signedText);\n    expect(signatures).to.have.length(1);\n    expect(await signatures[0].verified).to.be.true;\n  });\n\n  it('Sign and verify cleartext signed message with trailing spaces correctly normalised', async function() {\n    const pubKey = await openpgp.readKey({ armoredKey: pub_key_arm2 });\n    const privKey = await openpgp.decryptKey({\n      privateKey: await openpgp.readKey({ armoredKey: priv_key_arm2 }),\n      passphrase: 'hello world'\n    });\n    const config = { minRSABits: 1024 };\n\n    const message = await openpgp.createCleartextMessage({\n      text: 'this text    \\r\\nused to be incorrectly normalised'\n    });\n    const expectedText = 'this text\\nused to be incorrectly normalised';\n    expect(message.getText()).to.equal(expectedText);\n    const cleartextMessage = await openpgp.sign({ message, signingKeys: privKey, config, format: 'armored' });\n    const { signatures, data } = await openpgp.verify({\n      message: await openpgp.readCleartextMessage({ cleartextMessage }),\n      verificationKeys:[pubKey],\n      config\n    });\n    expect(data).to.equal(expectedText);\n    expect(signatures).to.have.length(1);\n    expect(await signatures[0].verified).to.be.true;\n  });\n\n  function tests() {\n    it('Verify signed message with trailing spaces from GPG', async function() {\n      const armoredMessage =\n        `-----BEGIN PGP MESSAGE-----\nVersion: GnuPG v1\n\nowGbwMvMyMT4oOW7S46CznTG01El3MUFicmpxbolqcUlUTev14K5Vgq8XGCGQmJe\nikJJYpKVAicvV16+QklRYmZOZl66AliWl0sBqBAkzQmmwKohBnAqdMxhYWRkYmBj\nZQIZy8DFKQCztusM8z+Vt/svG80IS/etn90utv/T16jquk69zPvp6t9F16ryrwpb\nkfVlS5Xl38KnVYxWvIor0nao6WUczA4vvZX9TXPWnnW3tt1vbZoiqWUjYjjjhuKG\n4DtmMTuL3TW6/zNzVfWp/Q11+71O8RGnXMsBvWM6mSqX75uLiPo6HRaUDHnvrfCP\nyYDnCgA=\n=15ki\n-----END PGP MESSAGE-----`;\n\n      const plaintext = 'space: \\nspace and tab: \\t\\nno trailing space\\n  \\ntab:\\t\\ntab and space:\\t ';\n      const message = await openpgp.readMessage({ armoredMessage });\n      const pubKey = await openpgp.readKey({ armoredKey: pub_key_arm2 });\n\n      const keyIDs = message.getSigningKeyIDs();\n      expect(pubKey.getKeys(keyIDs[0])).to.not.be.empty;\n\n      return openpgp.verify({ verificationKeys: [pubKey], message, config: { minRSABits: 1024 } }).then(async ({ data, signatures }) => {\n        expect(data).to.equal(plaintext);\n        expect(signatures).to.have.length(1);\n        if (openpgp.config.rejectMessageHashAlgorithms.has(openpgp.enums.hash.sha1)) {\n          await expect(signatures[0].verified).to.be.rejected;\n        } else {\n          expect(await signatures[0].verified).to.be.true;\n        }\n        expect((await signatures[0].signature).packets.length).to.equal(1);\n      });\n    });\n\n    it('Streaming verify signed message with trailing spaces from GPG', async function() {\n      const armoredMessage =\n        `-----BEGIN PGP MESSAGE-----\nVersion: GnuPG v1\n\nowGbwMvMyMT4oOW7S46CznTG01El3MUFicmpxbolqcUlUTev14K5Vgq8XGCGQmJe\nikJJYpKVAicvV16+QklRYmZOZl66AliWl0sBqBAkzQmmwKohBnAqdMxhYWRkYmBj\nZQIZy8DFKQCztusM8z+Vt/svG80IS/etn90utv/T16jquk69zPvp6t9F16ryrwpb\nkfVlS5Xl38KnVYxWvIor0nao6WUczA4vvZX9TXPWnnW3tt1vbZoiqWUjYjjjhuKG\n4DtmMTuL3TW6/zNzVfWp/Q11+71O8RGnXMsBvWM6mSqX75uLiPo6HRaUDHnvrfCP\nyYDnCgA=\n=15ki\n-----END PGP MESSAGE-----`.split('');\n\n      const plaintext = 'space: \\nspace and tab: \\t\\nno trailing space\\n  \\ntab:\\t\\ntab and space:\\t ';\n      await stream.loadStreamsPonyfill();\n      const message = await openpgp.readMessage({\n        armoredMessage: new stream.ReadableStream({\n          async pull(controller) {\n            await new Promise(setTimeout);\n            controller.enqueue(armoredMessage.shift());\n            if (!armoredMessage.length) controller.close();\n          }\n        })\n      });\n      const pubKey = await openpgp.readKey({ armoredKey: pub_key_arm2 });\n\n      const keyIDs = message.getSigningKeyIDs();\n      expect(pubKey.getKeys(keyIDs[0])).to.not.be.empty;\n\n      return openpgp.verify({ verificationKeys: [pubKey], message, config: { minRSABits: 1024 } }).then(async function(cleartextSig) {\n        expect(cleartextSig).to.exist;\n        expect(await stream.readToEnd(cleartextSig.data)).to.equal(plaintext);\n        expect(cleartextSig.signatures).to.have.length(1);\n        if (!openpgp.config.rejectMessageHashAlgorithms.has(openpgp.enums.hash.sha1)) {\n          expect(await cleartextSig.signatures[0].verified).to.be.true;\n        } else {\n          await expect(cleartextSig.signatures[0].verified).to.be.rejectedWith('Insecure message hash algorithm: SHA1');\n        }\n        expect((await cleartextSig.signatures[0].signature).packets.length).to.equal(1);\n      });\n    });\n\n    it('Verify signed message with missing signature packet', async function() {\n      const armoredMessage =\n        `-----BEGIN PGP MESSAGE-----\nVersion: OpenPGP.js v3.1.3\nComment: https://openpgpjs.org\n\nyFgBO8LLzMjE+KDlu0uOgs50xtNRJdzFBYnJqcW6JanFJVE3r9eCuVYKvFxg\nhkJiXopCSWKSlQInL1devkJJUWJmTmZeugJYlpdLAagQJM0JpsCqIQZwKgAA\n\n=D6TZ\n-----END PGP MESSAGE-----`;\n\n      const plaintext = 'space: \\nspace and tab: \\t\\nno trailing space\\n  \\ntab:\\t\\ntab and space:\\t ';\n      const message = await openpgp.readMessage({ armoredMessage });\n      const pubKey = await openpgp.readKey({ armoredKey: pub_key_arm2 });\n\n      const keyIDs = message.getSigningKeyIDs();\n      expect(pubKey.getKeys(keyIDs[0])).to.not.be.empty;\n\n      return openpgp.verify({ verificationKeys: [pubKey], message, config: { minRSABits: 1024 } }).then(async ({ data, signatures }) => {\n        expect(data).to.equal(plaintext);\n        expect(signatures).to.have.length(0);\n      });\n    });\n\n    it('Streaming verify signed message with missing signature packet', async function() {\n      const armoredMessage =\n        `-----BEGIN PGP MESSAGE-----\nVersion: OpenPGP.js v3.1.3\nComment: https://openpgpjs.org\n\nyFgBO8LLzMjE+KDlu0uOgs50xtNRJdzFBYnJqcW6JanFJVE3r9eCuVYKvFxg\nhkJiXopCSWKSlQInL1devkJJUWJmTmZeugJYlpdLAagQJM0JpsCqIQZwKgAA\n\n=D6TZ\n-----END PGP MESSAGE-----`.split('');\n\n      const plaintext = 'space: \\nspace and tab: \\t\\nno trailing space\\n  \\ntab:\\t\\ntab and space:\\t ';\n      await stream.loadStreamsPonyfill();\n      const message = await openpgp.readMessage({\n        armoredMessage: new stream.ReadableStream({\n          async pull(controller) {\n            await new Promise(setTimeout);\n            controller.enqueue(armoredMessage.shift());\n            if (!armoredMessage.length) controller.close();\n          }\n        })\n      });\n      const pubKey = await openpgp.readKey({ armoredKey: pub_key_arm2 });\n\n      const keyIDs = message.getSigningKeyIDs();\n      expect(pubKey.getKeys(keyIDs[0])).to.not.be.empty;\n\n      return openpgp.verify({ verificationKeys: [pubKey], message, config: { minRSABits: 1024 } }).then(async ({ data, signatures }) => {\n        expect(await stream.readToEnd(data)).to.equal(plaintext);\n        expect(signatures).to.have.length(1);\n        await expect(signatures[0].verified).to.be.rejectedWith('Corresponding signature packet missing');\n        expect((await signatures[0].signature).packets.length).to.equal(0);\n      });\n    });\n  }\n\n  tests();\n\n  let rejectMessageHashAlgorithms;\n  tryTests('Accept SHA-1 signatures', tests, {\n    if: true,\n    before: function() {\n      ({ rejectMessageHashAlgorithms } = openpgp.config);\n      Object.assign(openpgp.config, { rejectMessageHashAlgorithms: new Set([openpgp.enums.hash.md5, openpgp.enums.hash.ripemd]) });\n    },\n    after: function() {\n      Object.assign(openpgp.config, { rejectMessageHashAlgorithms });\n    }\n  });\n\n  it('Sign text with openpgp.sign and verify with openpgp.verify leads to same string cleartext and valid signatures', async function() {\n    const plaintext = 'short message\\nnext line \\n\ud55c\uad6d\uc5b4/\uc870\uc120\ub9d0';\n    const pubKey = await openpgp.readKey({ armoredKey: pub_key_arm2 });\n    const privKey = await openpgp.decryptKey({\n      privateKey: await openpgp.readKey({ armoredKey: priv_key_arm2 }),\n      passphrase: 'hello world'\n    });\n\n    const config = { minRSABits: 1024 };\n    return openpgp.sign({ signingKeys: privKey, message: await openpgp.createCleartextMessage({ text: plaintext }), config }).then(async signed => {\n\n      const message = await openpgp.readCleartextMessage({ cleartextMessage: signed });\n      return openpgp.verify({ verificationKeys:[pubKey], message, config });\n\n    }).then(async function({ data, signatures }) {\n      expect(data).to.equal(plaintext.replace(/[ \\t\\r]+$/mg, ''));\n      expect(signatures).to.have.length(1);\n      expect(await signatures[0].verified).to.be.true;\n      expect((await signatures[0].signature).packets.length).to.equal(1);\n    });\n  });\n\n  it('Sign text with openpgp.sign and verify with openpgp.verify leads to same string cleartext and valid signatures -- escape armored message', async function() {\n    const plaintext = pub_key_arm2;\n    const pubKey = await openpgp.readKey({ armoredKey: pub_key_arm2 });\n    const privKey = await openpgp.decryptKey({\n      privateKey: await openpgp.readKey({ armoredKey: priv_key_arm2 }),\n      passphrase: 'hello world'\n    });\n\n    const config = { minRSABits: 1024 };\n    return openpgp.sign({ signingKeys: privKey, message: await openpgp.createCleartextMessage({ text: plaintext }), config }).then(async signed => {\n\n      const message = await openpgp.readCleartextMessage({ cleartextMessage: signed });\n      return openpgp.verify({ verificationKeys: pubKey, message, config });\n\n    }).then(async function({ data, signatures }) {\n      expect(data).to.equal(plaintext);\n      expect(signatures).to.have.length(1);\n      expect(await signatures[0].verified).to.be.true;\n      expect((await signatures[0].signature).packets.length).to.equal(1);\n    });\n  });\n\n  it('Sign text with openpgp.sign and verify with openpgp.verify leads to same string cleartext and valid signatures -- trailing spaces', async function() {\n    const plaintext = 'space: \\nspace and tab: \\t\\nno trailing space\\n  \\ntab:\\t\\ntab and space:\\t ';\n    const pubKey = await openpgp.readKey({ armoredKey: pub_key_arm2 });\n    const privKey = await openpgp.decryptKey({\n      privateKey: await openpgp.readKey({ armoredKey: priv_key_arm2 }),\n      passphrase: 'hello world'\n    });\n\n    const config = { minRSABits: 1024 };\n    return openpgp.sign({ signingKeys: privKey, message: await openpgp.createCleartextMessage({ text: plaintext }), config }).then(async signed => {\n\n      const message = await openpgp.readCleartextMessage({ cleartextMessage: signed });\n      return openpgp.verify({ verificationKeys: pubKey, message, config });\n\n    }).then(async function({ data, signatures }) {\n      expect(data).to.equal(plaintext.replace(/[ \\t]+$/mg, ''));\n      expect(signatures).to.have.length(1);\n      expect(await signatures[0].verified).to.be.true;\n      expect((await signatures[0].signature).packets.length).to.equal(1);\n    });\n  });\n\n  it('Sign text with openpgp.sign and verify with openpgp.verify leads to same bytes cleartext and valid signatures - armored', async function() {\n    const plaintext = util.stringToUint8Array('short message\\nnext line \\n\ud55c\uad6d\uc5b4/\uc870\uc120\ub9d0');\n    const pubKey = await openpgp.readKey({ armoredKey: pub_key_arm2 });\n    const privKey = await openpgp.decryptKey({\n      privateKey: await openpgp.readKey({ armoredKey: priv_key_arm2 }),\n      passphrase: 'hello world'\n    });\n\n    const config = { minRSABits: 1024 };\n    return openpgp.sign({ signingKeys: privKey, message: await openpgp.createMessage({ binary: plaintext }), config }).then(async signed => {\n\n      const message = await openpgp.readMessage({ armoredMessage: signed });\n      return openpgp.verify({ verificationKeys: pubKey, message, format: 'binary', config });\n\n    }).then(async function({ data, signatures }) {\n      expect(data).to.deep.equal(plaintext);\n      expect(signatures).to.have.length(1);\n      expect(await signatures[0].verified).to.be.true;\n      expect((await signatures[0].signature).packets.length).to.equal(1);\n    });\n  });\n\n  it('Sign text with openpgp.sign and verify with openpgp.verify leads to same bytes cleartext and valid signatures - not armored', async function() {\n    const plaintext = util.stringToUint8Array('short message\\nnext line \\n\ud55c\uad6d\uc5b4/\uc870\uc120\ub9d0');\n    const pubKey = await openpgp.readKey({ armoredKey: pub_key_arm2 });\n    const privKey = await openpgp.decryptKey({\n      privateKey: await openpgp.readKey({ armoredKey: priv_key_arm2 }),\n      passphrase: 'hello world'\n    });\n\n    const config = { minRSABits: 1024 };\n    return openpgp.sign({ signingKeys: privKey, message: await openpgp.createMessage({ binary: plaintext }), format: 'binary', config }).then(async signed => {\n\n      const message = await openpgp.readMessage({ binaryMessage: signed });\n      return openpgp.verify({ verificationKeys: pubKey, message, format: 'binary', config });\n\n    }).then(async function({ data, signatures }) {\n      expect(data).to.deep.equal(plaintext);\n      expect(signatures).to.have.length(1);\n      expect(await signatures[0].verified).to.be.true;\n      expect((await signatures[0].signature).packets.length).to.equal(1);\n    });\n  });\n\n  it('Should verify detached signature with some unknown versions of Signature packets', async function () {\n    // Test from openpgp-interoperability-test-suite to ensure forward compatibility: https://tests.sequoia-pgp.org/?q=forward-compat\n    const plaintext = 'hello world';\n\n    // This signature includes two Signature packets: a v4 one (verifiable) and a 'dummy' v23 one.\n    const signatureUnknownTrailingPacketVersion = `-----BEGIN PGP SIGNATURE-----\n\nwnUEARYKACcFgmSVpTQJkHEwNzxPuQajFiEE2KiARjeh+fU3dy+5cTA3PE+5\nBqMAAKZNAP0fhECUqrE2Ts7Ho8/fuLFT+9jsGIGo0EviIEmW77vyhQEAtOBa\nN77tTSawgDqnjIRH5RyI6YNC1LNz01VHCYWwegfCwTsXAAEKAG8FgmSVZN4J\nEPv8yCoBXnMwRxQAAAAAAB4AIHNhbHRAbm90YXRpb25zLnNlcXVvaWEtcGdw\nLm9yZ8jF+epDaQ8yqg9h1mb0LcDLKC71kHyESC8fqFt9fNFsFiEE0aZuGiOx\ngsmYD3iM+/zIKgFeczAAADLxDACKH0qwrZW+Eu3McHHfKojqlHoJ+Ofqotui\nGtcyx3HrE86xQHQl6346Joweomlzo2A6cjhT/nxL88sfy9yTQyUyKaON0wHz\n4WI+Onu8rSaG99J/u34dDIPqFu5DzhwCrkv0IQwGYfDxG6Lrxg7gsxui2KAt\n4rJqlbaeRGOTeNmew6aH74foUp86LWjdasanZ3RXxjk3yP+R/7nquQjkVGqE\njElkMwFh44TwTHlrXfI90Ki4gNrFQfbQCQm2v66rT0t3BSgVrL+FZIyXjjOh\ndp83PCrkcvOcbBalvtbYPd5+23cGAylm5hkC9bxQUwUJrcJezdwSpxF5+Vgj\nIkeanKfU2BhKry3Hpn3PL6vLfVkK/w0wUEbDMkFRbGAmW1sPCJWDSX6Zy75/\nLi0CQ3u6tg3/m9VHUdwN5iNVk3g7AtV2eLinv4fKIuVUxUIyvacro+RBxGNc\nEnZwTO2p2I0xifnoRizITFXclUc9J4vK+whpi9PHH5uoqRGcoer72rtjIIs=\n=nReB\n-----END PGP SIGNATURE-----`;\n\n    const publicKey = `-----BEGIN PGP PUBLIC KEY BLOCK-----\n\nxjMEZJWk4RYJKwYBBAHaRw8BAQdA7p5RuL+Z05qld6xRz6tbJ+9pmDowaCYr\ntMOW8MXHAx3NFW5hbWUgPGVtYWlsQHRlc3QuY29tPsKMBBAWCgA+BYJklaTh\nBAsJBwgJkHEwNzxPuQajAxUICgQWAAIBAhkBApsDAh4BFiEE2KiARjeh+fU3\ndy+5cTA3PE+5BqMAAB5pAQDUHdYs3HRK6yJZ6IrK8lfmLzeqSgW2j9wLG/zF\nTXIARQEAj0PdOzSy3q75VIQraDSHWpBAue8QNEKV4Q8hlkJvmgPOOARklaTh\nEgorBgEEAZdVAQUBAQdAR9bBkzKzh24TB6gJVHR49BWnhTmeF5+vA3PXtX/b\nRHkDAQgHwngEGBYIACoFgmSVpOEJkHEwNzxPuQajApsMFiEE2KiARjeh+fU3\ndy+5cTA3PE+5BqMAAFjVAQDKqKwFLKX+N7le3cDLHAYSqc4AWpksKS4eSBLa\nuDvEBgD+LCEUOPejUTCMqPyd04ssdOq1AlMJOmUGUwLk7kFP7Aw=\n=Q9Px\n-----END PGP PUBLIC KEY BLOCK-----`;\n\n    const { signatures, data } = await openpgp.verify({\n      message: await openpgp.createMessage({ text: plaintext }),\n      signature: await openpgp.readSignature({ armoredSignature: signatureUnknownTrailingPacketVersion }),\n      verificationKeys: await openpgp.readKey({ armoredKey: publicKey })\n    });\n    expect(data).to.equal(plaintext);\n    expect(signatures).to.have.length(1);\n    expect(await signatures[0].verified).to.be.true;\n    expect((await signatures[0].signature).packets.length).to.equal(1);\n  });\n\n  it('Should verify cleartext signature with some unknown versions of Signature packets', async function () {\n    // Test to ensure forward compatibility:\n    // this signature includes two Signature packets: a v4 one (verifiable) and a 'dummy' v23 one.\n    const signatureUnknownTrailingPacketVersion = `-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA512\n\nhello world\n-----BEGIN PGP SIGNATURE-----\n\nwnUEARYKACcFgmSVpTQJkHEwNzxPuQajFiEE2KiARjeh+fU3dy+5cTA3PE+5\nBqMAAKZNAP0fhECUqrE2Ts7Ho8/fuLFT+9jsGIGo0EviIEmW77vyhQEAtOBa\nN77tTSawgDqnjIRH5RyI6YNC1LNz01VHCYWwegfCwTsXAAEKAG8FgmSVZN4J\nEPv8yCoBXnMwRxQAAAAAAB4AIHNhbHRAbm90YXRpb25zLnNlcXVvaWEtcGdw\nLm9yZ8jF+epDaQ8yqg9h1mb0LcDLKC71kHyESC8fqFt9fNFsFiEE0aZuGiOx\ngsmYD3iM+/zIKgFeczAAADLxDACKH0qwrZW+Eu3McHHfKojqlHoJ+Ofqotui\nGtcyx3HrE86xQHQl6346Joweomlzo2A6cjhT/nxL88sfy9yTQyUyKaON0wHz\n4WI+Onu8rSaG99J/u34dDIPqFu5DzhwCrkv0IQwGYfDxG6Lrxg7gsxui2KAt\n4rJqlbaeRGOTeNmew6aH74foUp86LWjdasanZ3RXxjk3yP+R/7nquQjkVGqE\njElkMwFh44TwTHlrXfI90Ki4gNrFQfbQCQm2v66rT0t3BSgVrL+FZIyXjjOh\ndp83PCrkcvOcbBalvtbYPd5+23cGAylm5hkC9bxQUwUJrcJezdwSpxF5+Vgj\nIkeanKfU2BhKry3Hpn3PL6vLfVkK/w0wUEbDMkFRbGAmW1sPCJWDSX6Zy75/\nLi0CQ3u6tg3/m9VHUdwN5iNVk3g7AtV2eLinv4fKIuVUxUIyvacro+RBxGNc\nEnZwTO2p2I0xifnoRizITFXclUc9J4vK+whpi9PHH5uoqRGcoer72rtjIIs=\n=nReB\n-----END PGP SIGNATURE-----`;\n\n    const publicKey = `-----BEGIN PGP PUBLIC KEY BLOCK-----\n\nxjMEZJWk4RYJKwYBBAHaRw8BAQdA7p5RuL+Z05qld6xRz6tbJ+9pmDowaCYr\ntMOW8MXHAx3NFW5hbWUgPGVtYWlsQHRlc3QuY29tPsKMBBAWCgA+BYJklaTh\nBAsJBwgJkHEwNzxPuQajAxUICgQWAAIBAhkBApsDAh4BFiEE2KiARjeh+fU3\ndy+5cTA3PE+5BqMAAB5pAQDUHdYs3HRK6yJZ6IrK8lfmLzeqSgW2j9wLG/zF\nTXIARQEAj0PdOzSy3q75VIQraDSHWpBAue8QNEKV4Q8hlkJvmgPOOARklaTh\nEgorBgEEAZdVAQUBAQdAR9bBkzKzh24TB6gJVHR49BWnhTmeF5+vA3PXtX/b\nRHkDAQgHwngEGBYIACoFgmSVpOEJkHEwNzxPuQajApsMFiEE2KiARjeh+fU3\ndy+5cTA3PE+5BqMAAFjVAQDKqKwFLKX+N7le3cDLHAYSqc4AWpksKS4eSBLa\nuDvEBgD+LCEUOPejUTCMqPyd04ssdOq1AlMJOmUGUwLk7kFP7Aw=\n=Q9Px\n-----END PGP PUBLIC KEY BLOCK-----`;\n\n    const { signatures } = await openpgp.verify({\n      message: await openpgp.readCleartextMessage({ cleartextMessage: signatureUnknownTrailingPacketVersion }),\n      verificationKeys: await openpgp.readKey({ armoredKey: publicKey })\n    });\n    expect(signatures).to.have.length(1);\n    expect(await signatures[0].verified).to.be.true;\n    expect((await signatures[0].signature).packets.length).to.equal(1);\n  });\n\n  it('Should verify cleartext message correctly when using a detached cleartext signature and binary literal data', async function () {\n    const plaintext = 'short message\\nnext line \\n\ud55c\uad6d\uc5b4/\uc870\uc120\ub9d0';\n    const pubKey = await openpgp.readKey({ armoredKey: pub_key_arm2 });\n    const privKey = await openpgp.decryptKey({\n      privateKey: await openpgp.readKey({ armoredKey: priv_key_arm2 }),\n      passphrase: 'hello world'\n    });\n\n    const config = { minRSABits: 1024 };\n    return openpgp.sign({ signingKeys: privKey, message: await openpgp.createMessage({ text: plaintext }), detached: true, config }).then(async armoredSignature => {\n      const signature = await openpgp.readSignature({ armoredSignature });\n      return openpgp.verify({ verificationKeys: pubKey, message: await openpgp.createMessage({ binary: util.encodeUTF8(plaintext) }), signature, config });\n    }).then(async function({ data, signatures }) {\n      expect(data).to.equal(plaintext);\n      expect(signatures).to.have.length(1);\n      expect(await signatures[0].verified).to.be.true;\n      expect((await signatures[0].signature).packets.length).to.equal(1);\n    });\n  });\n\n  it('Should verify cleartext message correctly when using a detached binary signature and text literal data', async function () {\n    const plaintext = 'short message\\nnext line \\n\ud55c\uad6d\uc5b4/\uc870\uc120\ub9d0';\n    const binaryPlaintext = util.encodeUTF8(plaintext);\n    const pubKey = await openpgp.readKey({ armoredKey: pub_key_arm2 });\n    const privKey = await openpgp.decryptKey({\n      privateKey: await openpgp.readKey({ armoredKey: priv_key_arm2 }),\n      passphrase: 'hello world'\n    });\n\n    const config = { minRSABits: 1024 };\n    return openpgp.sign({ signingKeys: privKey, message:await openpgp.createMessage({ binary: binaryPlaintext }), detached: true, config }).then(async armoredSignature => {\n      const signature = await openpgp.readSignature({ armoredSignature });\n      return openpgp.verify({ verificationKeys: pubKey, message: await openpgp.createMessage({ text: plaintext }), signature, config });\n\n    }).then(async function({ data, signatures }) {\n      expect(data).to.equal(plaintext);\n      expect(signatures).to.have.length(1);\n      expect(await signatures[0].verified).to.be.true;\n      expect((await signatures[0].signature).packets.length).to.equal(1);\n    });\n  });\n\n  it('Should verify encrypted cleartext message correctly when encrypting binary literal data with a canonical text signature', async function () {\n    const plaintext = 'short message\\nnext line \\n\ud55c\uad6d\uc5b4/\uc870\uc120\ub9d0';\n    const pubKey = await openpgp.readKey({ armoredKey: pub_key_arm2 });\n    const privKey = await openpgp.decryptKey({\n      privateKey: await openpgp.readKey({ armoredKey: priv_key_arm2 }),\n      passphrase: 'hello world'\n    });\n\n    const config = { minRSABits: 1024 };\n    return openpgp.sign({ signingKeys: privKey, message: await openpgp.createMessage({ text: plaintext }), detached: true, config }).then(async armoredSignature => {\n      const signature = await openpgp.readSignature({ armoredSignature });\n      return openpgp.encrypt({ message: await openpgp.createMessage({ binary: util.encodeUTF8(plaintext) }), encryptionKeys: [pubKey], signature, config });\n\n    }).then(async armoredMessage => {\n      const message = await openpgp.readMessage({ armoredMessage });\n      return openpgp.decrypt({ message, decryptionKeys: [privKey], verificationKeys: [pubKey], config });\n\n    }).then(async function({ data, signatures }) {\n      expect(data).to.equal(plaintext);\n      expect(signatures).to.have.length(1);\n      expect(await signatures[0].verified).to.be.true;\n      expect((await signatures[0].signature).packets.length).to.equal(1);\n    });\n  });\n\n  // TODO add test with multiple revocation signatures\n  it('Verify primary key revocation signatures', async function() {\n    const pubKey = await openpgp.readKey({ armoredKey: pub_revoked });\n    await pubKey.revocationSignatures[0].verify(\n      pubKey.keyPacket, openpgp.enums.signature.keyRevocation, { key: pubKey.keyPacket }\n    );\n  });\n\n  // TODO add test with multiple revocation signatures\n  it('Verify subkey revocation signatures', async function() {\n    const pubKey = await openpgp.readKey({ armoredKey: pub_revoked });\n    const revSig = pubKey.subkeys[0].revocationSignatures[0];\n    await revSig.verify(\n      pubKey.keyPacket, openpgp.enums.signature.subkeyRevocation, { key: pubKey.keyPacket, bind: pubKey.subkeys[0].keyPacket }\n    );\n  });\n\n  it('Verify key expiration date', async function() {\n    const pubKey = await openpgp.readKey({ armoredKey: pub_revoked });\n\n    expect(pubKey).to.exist;\n    expect(pubKey.users[0].selfCertifications[0].keyNeverExpires).to.be.false;\n    expect(pubKey.users[0].selfCertifications[0].keyExpirationTime).to.equal(5 * 365 * 24 * 60 * 60);\n  });\n\n  it('Write unhashed subpackets', async function() {\n    let pubKey = await openpgp.readKey({ armoredKey: pub_key_arm2 });\n    expect(pubKey.users[0].selfCertifications).to.exist;\n    pubKey = await openpgp.readKey({ armoredKey: pubKey.armor() });\n    expect(pubKey.users[0].selfCertifications).to.exist;\n  });\n\n  it('Write V4 signatures', async function() {\n    const pubKey = await openpgp.readKey({ armoredKey: pub_key_arm2 });\n    const pubKey2 = await openpgp.readKey({ armoredKey: pubKey.armor() });\n    expect(pubKey2).to.exist;\n    expect(pubKey.users[0].selfCertifications).to.eql(pubKey2.users[0].selfCertifications);\n  });\n\n  it('Verify a detached signature using appendSignature', async function() {\n    const detachedSig = ['-----BEGIN PGP SIGNATURE-----',\n      'Version: GnuPG v1.4.13 (Darwin)',\n      'Comment: GPGTools - https://gpgtools.org',\n      'Comment: Using GnuPG with Thunderbird - https://www.enigmail.net/',\n      '',\n      'iQEcBAEBCgAGBQJTqH5OAAoJENf7k/zfv8I8oFoH/R6EFTw2CYUQoOKSAQstWIHp',\n      'fVVseLOkFbByUV5eLuGVBNI3DM4GQ6C7dGntKAn34a1iTGcAIZH+fIhaZ2WtNdtA',\n      'R+Ijn8xDjbF/BWvcTBOaRvgw9b8viPxhkVYa3PioHYz6krt/LmFqFdp/phWZcqR4',\n      'jzWMX55h4FOw3YBNGiz2NuIg+iGrFRWPYgd8NVUmJKReZHs8C/6HGz7F4/A24k6Y',\n      '7xms9D6Er+MhspSl+1dlRdHjtXiRqC5Ld1hi2KBKc6YzgOLpVw5l9sffbnH+aRG4',\n      'dH+2J5U3elqBDK1i3GyG8ixLSB0FGW9+lhYNosZne2xy8SbQKdgsnTBnWSGevP0=',\n      '=xiih',\n      '-----END PGP SIGNATURE-----'].join('\\r\\n');\n\n    const content = ['Content-Type: multipart/mixed;',\n      ' boundary=\"------------070307080002050009010403\"',\n      '',\n      'This is a multi-part message in MIME format.',\n      '--------------070307080002050009010403',\n      'Content-Type: text/plain; charset=ISO-8859-1',\n      'Content-Transfer-Encoding: quoted-printable',\n      '',\n      'test11',\n      '',\n      '--------------070307080002050009010403',\n      'Content-Type: application/macbinary;',\n      ' name=\"test.bin\"',\n      'Content-Transfer-Encoding: base64',\n      'Content-Disposition: attachment;',\n      ' filename=\"test.bin\"',\n      '',\n      'dGVzdGF0dGFjaG1lbnQ=',\n      '--------------070307080002050009010403--',\n      ''].join('\\r\\n');\n\n    const publicKeyArmored = '-----BEGIN PGP PUBLIC KEY BLOCK-----\\r\\nVersion: OpenPGP.js v.1.20131116\\r\\nComment: Whiteout Mail - https://whiteout.io\\r\\n\\r\\nxsBNBFKODs4BB/9iOF4THsjQMY+WEpT7ShgKxj4bHzRRaQkqczS4nZvP0U3g\\r\\nqeqCnbpagyeKXA+bhWFQW4GmXtgAoeD5PXs6AZYrw3tWNxLKu2Oe6Tp9K/XI\\r\\nxTMQ2wl4qZKDXHvuPsJ7cmgaWqpPyXtxA4zHHS3WrkI/6VzHAcI/y6x4szSB\\r\\nKgSuhI3hjh3s7TybUC1U6AfoQGx/S7e3WwlCOrK8GTClirN/2mCPRC5wuIft\\r\\nnkoMfA6jK8d2OPrJ63shy5cgwHOjQg/xuk46dNS7tkvGmbaa+X0PgqSKB+Hf\\r\\nYPPNS/ylg911DH9qa8BqYU2QpNh9jUKXSF+HbaOM+plWkCSAL7czV+R3ABEB\\r\\nAAHNLVdoaXRlb3V0IFVzZXIgPHNhZmV3aXRobWUudGVzdHVzZXJAZ21haWwu\\r\\nY29tPsLAXAQQAQgAEAUCUo4O2gkQ1/uT/N+/wjwAAN2cB/9gFRmAfvEQ2qz+\\r\\nWubmT2EsSSnjPMxzG4uyykFoa+TaZCWo2Xa2tQghmU103kEkQb1OEjRjpgwJ\\r\\nYX9Kghnl8DByM686L5AXnRyHP78qRJCLXSXl0AGicboUDp5sovaa4rswQceH\\r\\nvcdWgZ/mgHTRoiQeJddy9k+H6MPFiyFaVcFwegVsmpc+dCcC8yT+qh8ZIbyG\\r\\nRJU60PmKKN7LUusP+8DbSv39zCGJCBlVVKyA4MzdF5uM+sqTdXbKzOrT5DGd\\r\\nCZaox4s+w16Sq1rHzZKFWfQPfKLDB9pyA0ufCVRA3AF6BUi7G3ZqhZiHNhMP\\r\\nNvE45V/hS1PbZcfPVoUjE2qc1Ix1\\r\\n=7Wpe\\r\\n-----END PGP PUBLIC KEY BLOCK-----';\n    const publicKey = await openpgp.readKey({ armoredKey: publicKeyArmored });\n\n    const message = await openpgp.createMessage({ text: content });\n    await message.appendSignature(detachedSig);\n    const { data, signatures } = await openpgp.verify({ verificationKeys:[publicKey], message, config: { minRSABits: 1024 } });\n    expect(data).to.equal(content);\n    expect(signatures).to.have.length(1);\n    expect(await signatures[0].verified).to.be.true;\n    expect((await signatures[0].signature).packets.length).to.equal(1);\n    expect(await signatures[0].verified).to.be.true;\n  });\n\n  it('Detached signature signing and verification', async function() {\n    const message = await openpgp.createMessage({ text: 'hello' });\n    const pubKey = await openpgp.readKey({ armoredKey: pub_key_arm2 });\n    const privKey = await openpgp.decryptKey({\n      privateKey: await openpgp.readKey({ armoredKey: priv_key_arm2 }),\n      passphrase: 'hello world'\n    });\n\n    const opt = { userIDs: { name:'test', email:'a@b.com' }, format: 'object' };\n    const { privateKey: generatedKey } = await openpgp.generateKey(opt);\n    const armoredSignature = await openpgp.sign({ signingKeys: [generatedKey, privKey], message, detached: true, config: { minRSABits: 1024 } });\n    const signature = await openpgp.readSignature({ armoredSignature });\n    const { data, signatures } = await openpgp.verify({ verificationKeys: [generatedKey.toPublic(), pubKey], message, signature, config: { minRSABits: 1024 } });\n    expect(data).to.equal('hello');\n    expect(await signatures[0].verified).to.be.true;\n    expect(await signatures[1].verified).to.be.true;\n  });\n\n  it('Sign message with key without password', function() {\n    const opt = { userIDs: { name:'test', email:'a@b.com' }, passphrase: null, format: 'object' };\n    return openpgp.generateKey(opt).then(async function({ privateKey: key }) {\n      const message = await openpgp.createMessage({ text: 'hello world' });\n      return message.sign([key]);\n    });\n  });\n\n  it('Verify signed key', async function() {\n    const signedArmor = [\n      '-----BEGIN PGP PUBLIC KEY BLOCK-----',\n      'Version: GnuPG v1',\n      '',\n      'mI0EUmEvTgEEANyWtQQMOybQ9JltDqmaX0WnNPJeLILIM36sw6zL0nfTQ5zXSS3+',\n      'fIF6P29lJFxpblWk02PSID5zX/DYU9/zjM2xPO8Oa4xo0cVTOTLj++Ri5mtr//f5',\n      'GLsIXxFrBJhD/ghFsL3Op0GXOeLJ9A5bsOn8th7x6JucNKuaRB6bQbSPABEBAAG0',\n      'JFRlc3QgTWNUZXN0aW5ndG9uIDx0ZXN0QGV4YW1wbGUuY29tPoi5BBMBAgAjBQJS',\n      'YS9OAhsvBwsJCAcDAgEGFQgCCQoLBBYCAwECHgECF4AACgkQSmNhOk1uQJQwDAP6',\n      'AgrTyqkRlJVqz2pb46TfbDM2TDF7o9CBnBzIGoxBhlRwpqALz7z2kxBDmwpQa+ki',\n      'Bq3jZN/UosY9y8bhwMAlnrDY9jP1gdCo+H0sD48CdXybblNwaYpwqC8VSpDdTndf',\n      '9j2wE/weihGp/DAdy/2kyBCaiOY1sjhUfJ1GogF49rCIRgQQEQIABgUCVuXBfQAK',\n      'CRARJ5QDyxae+O0fAJ9hUQPejXvZv6VW1Q3/Pm3+x2wfJACgwFg9NlrPPfejoC1w',\n      'P+z+vE5NFA24jQRSYS9OAQQA6R/PtBFaJaT4jq10yqASk4sqwVMsc6HcifM5lSdx',\n      'zExFP74naUMMyEsKHP53QxTF0GrqusagQg/ZtgT0CN1HUM152y7ACOdp1giKjpMz',\n      'OTQClqCoclyvWOFB+L/SwGEIJf7LSCErwoBuJifJc8xAVr0XX0JthoW+uP91eTQ3',\n      'XpsAEQEAAYkBPQQYAQIACQUCUmEvTgIbLgCoCRBKY2E6TW5AlJ0gBBkBAgAGBQJS',\n      'YS9OAAoJEOCE90RsICyXuqIEANmmiRCASF7YK7PvFkieJNwzeK0V3F2lGX+uu6Y3',\n      'Q/Zxdtwc4xR+me/CSBmsURyXTO29OWhPGLszPH9zSJU9BdDi6v0yNprmFPX/1Ng0',\n      'Abn/sCkwetvjxC1YIvTLFwtUL/7v6NS2bZpsUxRTg9+cSrMWWSNjiY9qUKajm1tu',\n      'zPDZXAUEAMNmAN3xXN/Kjyvj2OK2ck0XW748sl/tc3qiKPMJ+0AkMF7Pjhmh9nxq',\n      'E9+QCEl7qinFqqBLjuzgUhBU4QlwX1GDAtNTq6ihLMD5v1d82ZC7tNatdlDMGWnI',\n      'dvEMCv2GZcuIqDQ9rXWs49e7tq1NncLYhz3tYjKhoFTKEIq3y3Pp',\n      '=fvK7',\n      '-----END PGP PUBLIC KEY BLOCK-----'\n    ].join('\\n');\n\n    const signedKey = await openpgp.readKey({ armoredKey: signedArmor });\n    const signerKey = await openpgp.readKey({ armoredKey: priv_key_arm1 });\n    return signedKey.verifyPrimaryUser([signerKey], undefined, undefined, { ...openpgp.config, rejectPublicKeyAlgorithms: new Set() }).then(signatures => {\n      expect(signatures[0].valid).to.be.null;\n      expect(signatures[0].keyID.toHex()).to.equal(signedKey.getKeyID().toHex());\n      expect(signatures[1].valid).to.be.true;\n      expect(signatures[1].keyID.toHex()).to.equal(signerKey.getKeyID().toHex());\n    });\n  });\n\n  it('Verify signed UserIDs and User Attributes', async function() {\n    const armoredKeyWithPhoto = `-----BEGIN PGP PUBLIC KEY BLOCK-----\n\nmI0EW1CJGAEEAM+BzuFzcYk9HttmDbjGexQ8dfme074Q5PuHas3PBISPm0AwmnDM\ntzjlcrrg2VGuLqHvNF600w2ZgOo2gElNYCOas1q/fVFuIgJ4SUduNOEe/JnIW4uP\niEGU9l6zOVVgTc/nGVpZdvHgvOL8nl9BKHtWEnMD3Du7UYAm+Avshu9jABEBAAG0\nAViI1AQTAQoAPhYhBKcH118Rrg0wLBrTk5IyMikCym+4BQJbUIkYAhsDBQkDwmcA\nBQsJCAcDBRUKCQgLBRYDAgEAAh4BAheAAAoJEJIyMikCym+4K8oEAJc7YFiNau6V\nHTVK4cTvWU5MuYiejejFZai4ELUJy+WF6cZYrLuF/z/kRt8B7hpumXChPCUlT0q7\nFWypQtA3leu83DGMXqhfS80h2S1+VLmDVVWKQXOwgOb44jT9F08bDU5QK08SkjF8\n/EirIy8ANzdwCA4rHytIS2yx6tLlthvX0cBwwG4BEAABAQAAAAAAAAAAAAAAAP/Y\n/+AAEEpGSUYAAQEAAAEAAQAA/9sAQwABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEB\nAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEB/9sAQwEBAQEB\nAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEB\nAQEBAQEBAQEBAQEB/8AAEQgAAQABAwEiAAIRAQMRAf/EABUAAQEAAAAAAAAAAAAA\nAAAAAAAK/8QAFBABAAAAAAAAAAAAAAAAAAAAAP/EABQBAQAAAAAAAAAAAAAAAAAA\nAAD/xAAUEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwC/gAH/2YjUBBMB\nCgA+FiEEpwfXXxGuDTAsGtOTkjIyKQLKb7gFAltQimUCGwMFCQPCZwAFCwkIBwMF\nFQoJCAsFFgMCAQACHgECF4AACgkQkjIyKQLKb7gm/wQAiyZF89qr8hf3XQNJ6Ir/\nQtaniPcesjrYCIE47ZfeDYpBTPeiMm295o2dZXVJS4ItllYsplASw5DJiIMnQKlJ\nmbXakYFzzclTa/JrKzFYCy/DPT95xK+633omgrIUgJodizoKJE7XeB2U6aRUJJ4O\niTuGu4fEU1UligAXSrZmCdE=\n=VK6I\n-----END PGP PUBLIC KEY BLOCK-----`;\n\n    const key = await openpgp.readKey({ armoredKey: armoredKeyWithPhoto });\n    await Promise.all(key.users.map(async user => {\n      await user.verify(undefined, openpgp.config);\n    }));\n  });\n\n  it('should verify a shorter RSA signature', async function () {\n    const encrypted = `-----BEGIN PGP MESSAGE-----\n\nwYwD4IT3RGwgLJcBBACmH+a2c2yieZJ3wFchKeTVqzWkoltiidWgHHNE5v5x\n8aZGNzZFBd02v80VS23P9oxeJOpqKX2IZyuD36SniNoi+eXdT3zraqIe9x5p\n0RY9OrTP9pl58iogFBi1ARls41j7ui8KKDt2/iyQDCWHW1LoOVstiEb5/Xi3\nEWI+34EbNNTBMgEJAQAwEXImkOPmhYhE7bB3FnXe9rb7Fo3GZYA4/8B9YVf7\nGGZRLGwbICGu8E0MolmzLYW9hRThEfusAsNPGSgB+Yaqp0drsk01N4JJj3FT\nRKEUvd5EcL3u+Z5EoUUW6GpUL5p8Hvy2thqQfeem7XUbDBY6V3wqydOjbN9u\nc4CWB5Zu3GjDGDOvXFsy6cgdQvd/B9xbugKvUbAIsecTPlLtjZwfQklIu63T\nDA/3Pz/+zTAknBCsuIM0m7U/ZP3N6AGQIp4To7RJk0I6AxthHF5LbU11MjDZ\niB7+vmhqlrPyIS11g25UNijottJm13f84glVwBdWTJCiEqjh3KbcnTQCckCY\nV39DDLtbZG/XIx1ktqp765O9D/9xp2IA4zTyZzH4TuDbYs1j+JRdMsAq254k\n1m+wtW5gxJGcD5nh2T2T+ABL0n3jW0G504kR0LNBAQOZhVSKnSLn+F0GkjmI\niGw8+BOy8p2pX/WCLOf776ppSL77TpzhpG6wSE2oQxDrudazmRgVkZpyGzFE\nfDjspLTJHOhZ5zlLuoiKS9qEARGp39ysQnElR4dsx7tyVZz0uJvIrVzrQBlB\nekoD0DH0bhfqiwDrqeTJT2ORk8I/Q3jWnhQ3MnRN+q9d0yf1LWApMCwA7xU2\nC4KUFRC/wuF2TR9NvA==\n=v3WS\n-----END PGP MESSAGE-----`;\n    const armoredKey = `-----BEGIN PGP PRIVATE KEY BLOCK-----\n\n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\noaBUyhCKt8tz6Q==\n=52k1\n-----END PGP PRIVATE KEY BLOCK-----`;\n    const key = await openpgp.readKey({ armoredKey });\n    const decrypted = await openpgp.decrypt({\n      message: await openpgp.readMessage({ armoredMessage: encrypted }),\n      verificationKeys: key,\n      decryptionKeys: key,\n      config: { minRSABits: 1024 }\n    });\n    expect(await decrypted.signatures[0].verified).to.be.true;\n  });\n\n  it('should verify a shorter EdDSA signature', async function() {\n    const key = await openpgp.readKey({\n      armoredKey: `-----BEGIN PGP PRIVATE KEY BLOCK-----\n\nxVgEX8+jfBYJKwYBBAHaRw8BAQdA9GbdDjprR0sWf0R5a5IpulUauc0FsmzJ\nmOYCfoowt8EAAP9UwaqC0LWWQ5RlX7mps3728vFa/If1KBVwAjk7Uqhi2BKL\nzQ90ZXN0MiA8YkBhLmNvbT7CjAQQFgoAHQUCX8+jfAQLCQcIAxUICgQWAgEA\nAhkBAhsDAh4BACEJEG464aV2od77FiEEIcg441MtKnyJnPDRbjrhpXah3vuR\ngQD+Il6Gw2oIok4/ANyDDLBYZtKqRrMv4NcfF9DHYuAFcP4BAPhFOffyP3qU\nAEZb7QPrWdLfhn8/FeSFZxJvnmupQ9sDx10EX8+jfBIKKwYBBAGXVQEFAQEH\nQOSzo9cX1U2esGFClprOt0QWXNJ97228R5tKFxo6/0NoAwEIBwAA/0n4sq2i\nN6/jE+6rVO4o/7LW0xahxpV1tTA6qv1Op9TwFIDCeAQYFggACQUCX8+jfAIb\nDAAhCRBuOuGldqHe+xYhBCHIOONTLSp8iZzw0W464aV2od773XcA/jlmX8/c\n1/zIotEkyMZB4mI+GAg3FQ6bIACFBH1sz0MzAP9Snri0P4FRZ8D5THRCJoUm\nGBgpBmrf6IVv484jBswGDA==\n=8rBO\n-----END PGP PRIVATE KEY BLOCK-----`\n    });\n    const encrypted = `-----BEGIN PGP MESSAGE-----\n\nwV4DWlRRjuYiLSsSAQdAWwDKQLN4ZUS5fqiwFtAMrRfZZe9J4SgClhG6avEe\nAEowkSZwWRT+8Hy8aBIb4oPehYUFXXZ7BtlJCyd7LOTUtqyc00OE0721PC3M\nv0+zird60sACATlDmTwweR5GFtEAjHVheIL5rbkOBRD+oSqB8z+IovNg83Pz\nFVwsFZnCLtECoYgpF2MJdopuC/bPHcrvf4ndwmD11uXtms4Rq4y25QyqApbn\nHj/hljufk0OkavUXxrNKjGQtxLHMpa3Nsi0MHWY8JguxOKFKpAIMP32CD1e+\nj+GItrR+QbbN13ODlcR3hf66cwjLLsJCx5VcBaRspKF05O3ix/u9KVjJqtbi\nIe6jnY0zP2ldtS4JmhKBa43qmOHCxHc=\n=7B58\n-----END PGP MESSAGE-----`;\n    const decrypted = await openpgp.decrypt({ message: await openpgp.readMessage({ armoredMessage: encrypted }), decryptionKeys: key, verificationKeys: key.toPublic() });\n    expect(await decrypted.signatures[0].verified).to.be.true;\n  });\n\n  it('should verify a shorter ECDSA signature', async function() {\n    const key = await openpgp.readKey({\n      armoredKey: `-----BEGIN PGP PRIVATE KEY BLOCK-----\n\nxYAFX9JrLRMAAABMCCqGSM49AwEHAgMErtQdX4vh7ng/ut+k1mooYNh3Ywqt\nwr0tSS8hxZMvQRIFQ53Weq0e97ioZKXGimprEL571yvAN7I19wtQtqi61AAA\nAAAAJAEAjWdW+qlMFaKwXCls3O/X8I1rbZ0OdFgeE3TnRP3YETAP5s0KYSA8\nYUBhLml0PsKSBRATCAAhBQJf0mstBAsJBwgDFQgKBBYCAQACGQECGwMCHgcD\nIgECACMiIQUee6Tb+GlhTk/ozKrt7RhInCyR6w3OJb/tYAN1+qbIoYUqAP9S\nXmJCmSMrq6KfAD1aWSTBhtmujh+6y/pYTaf6VJVBYQEAt18zK0tw5EihHASY\nFXbfdFHBzrMmPJ4UV6UiBvH6k2zHhAVf0mstEgAAAFAIKoZIzj0DAQcCAwQx\nqnVPmWex365Nx8X8BGuMNI2TITXzTh9+AuPftZjPm09dhxdT9xmrCstPu/U1\ncpacIp0LIq13ngLgeZWcGFcnAwEIBwAAAAAAJAEAsTvBsKk/XoCz2mi8sz5q\nEYaN9YdDOU2jF+HOaSNaJAsPF8J6BRgTCAAJBQJf0mstAhsMACMiIQUee6Tb\n+GlhTk/ozKrt7RhInCyR6w3OJb/tYAN1+qbIoVutAP9GHPLn7D9Uahm81lhK\nAcvDfr9a0Cp4WAVzKDKLUzrRMgEAozi0VyjiBo1U2LcwTPJkA4PEQqQRVW1D\nKZTMSAH7JEo=\n=tqWy\n-----END PGP PRIVATE KEY BLOCK-----`\n    });\n    const signed = `-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA256\n\nshort message\n-----BEGIN PGP SIGNATURE-----\n\nwnYFARMIAAYFAl/Say0AIyIhBR57pNv4aWFOT+jMqu3tGEicLJHrDc4lv+1g\nA3X6psihFkcA+Nuog2qpAq20Zc2lzVjDZzQosb8MLvKMg3UFCX12Oc0BAJwd\nJImeZLY02MctIpGZULbqgcUGK0P/yqrPL8Pe4lQM\n=Pacb\n-----END PGP SIGNATURE-----`;\n    const message = await openpgp.readCleartextMessage({ cleartextMessage: signed });\n    const verified = await openpgp.verify({ verificationKeys: key, message });\n    expect(await verified.signatures[0].verified).to.be.true;\n  });\n});\n"], "filenames": ["src/cleartext.js", "test/general/signature.js"], "buggy_code_start_loc": [177, 1001], "buggy_code_end_loc": [178, 1001], "fixing_code_start_loc": [177, 1002], "fixing_code_end_loc": [178, 1028], "type": "CWE-347", "message": "OpenPGP.js is a JavaScript implementation of the OpenPGP protocol. In affected versions OpenPGP Cleartext Signed Messages are cryptographically signed messages where the signed text is readable without special tools. These messages typically contain a \"Hash: ...\" header declaring the hash algorithm used to compute the signature digest. OpenPGP.js up to v5.9.0 ignored any data preceding the \"Hash: ...\" texts when verifying the signature. As a result, malicious parties could add arbitrary text to a third-party Cleartext Signed Message, to lead the victim to believe that the arbitrary text was signed. A user or application is vulnerable to said attack vector if it verifies the CleartextMessage by only checking the returned `verified` property, discarding the associated `data` information, and instead _visually trusting_ the contents of the original message. Since `verificationResult.data` would always contain the actual signed data, users and apps that check this information are not vulnerable. Similarly, given a CleartextMessage object, retrieving the data using `getText()` or the `text` field returns only the contents that are considered when verifying the signature. Finally, re-armoring a CleartextMessage object (using `armor()` will also result in a \"sanitised\" version, with the extraneous text being removed. This issue has been addressed in version 5.10.1 (current stable version) which will reject messages when calling `openpgp.readCleartextMessage()` and in version 4.10.11 (legacy version) which will will reject messages when calling `openpgp.cleartext.readArmored()`. Users are advised to upgrade. Users unable to upgrade should check the contents of `verificationResult.data` to see what data was actually signed, rather than visually trusting the contents of the armored message.", "other": {"cve": {"id": "CVE-2023-41037", "sourceIdentifier": "security-advisories@github.com", "published": "2023-08-29T17:15:13.003", "lastModified": "2023-09-08T14:01:40.800", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "OpenPGP.js is a JavaScript implementation of the OpenPGP protocol. In affected versions OpenPGP Cleartext Signed Messages are cryptographically signed messages where the signed text is readable without special tools. These messages typically contain a \"Hash: ...\" header declaring the hash algorithm used to compute the signature digest. OpenPGP.js up to v5.9.0 ignored any data preceding the \"Hash: ...\" texts when verifying the signature. As a result, malicious parties could add arbitrary text to a third-party Cleartext Signed Message, to lead the victim to believe that the arbitrary text was signed. A user or application is vulnerable to said attack vector if it verifies the CleartextMessage by only checking the returned `verified` property, discarding the associated `data` information, and instead _visually trusting_ the contents of the original message. Since `verificationResult.data` would always contain the actual signed data, users and apps that check this information are not vulnerable. Similarly, given a CleartextMessage object, retrieving the data using `getText()` or the `text` field returns only the contents that are considered when verifying the signature. Finally, re-armoring a CleartextMessage object (using `armor()` will also result in a \"sanitised\" version, with the extraneous text being removed. This issue has been addressed in version 5.10.1 (current stable version) which will reject messages when calling `openpgp.readCleartextMessage()` and in version 4.10.11 (legacy version) which will will reject messages when calling `openpgp.cleartext.readArmored()`. Users are advised to upgrade. Users unable to upgrade should check the contents of `verificationResult.data` to see what data was actually signed, rather than visually trusting the contents of the armored message."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-347"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:openpgpjs:openpgpjs:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.10.11", "matchCriteriaId": "EE3685F7-C06B-487D-8D10-E192DC1D1589"}, {"vulnerable": true, "criteria": "cpe:2.3:a:openpgpjs:openpgpjs:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.0.0", "versionEndExcluding": "5.10.0", "matchCriteriaId": "FF849E0F-852A-48C8-8F9B-15DFE8DD0EBB"}]}]}], "references": [{"url": "https://github.com/openpgpjs/openpgpjs/commit/6b43e02a254853f5ff508ebd1b07541f78b7c566", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/openpgpjs/openpgpjs/security/advisories/GHSA-ch3c-v47x-4pgp", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/openpgpjs/openpgpjs/commit/6b43e02a254853f5ff508ebd1b07541f78b7c566"}}