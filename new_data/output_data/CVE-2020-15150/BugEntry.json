{"buggy_code": ["# Paginator\n\n[![Build Status](https://travis-ci.org/duffelhq/paginator.svg?branch=master)](https://travis-ci.org/duffelhq/paginator)\n[![Inline docs](http://inch-ci.org/github/duffelhq/paginator.svg)](http://inch-ci.org/github/duffelhq/paginator)\n\n[Cursor based pagination](http://use-the-index-luke.com/no-offset) for Elixir [Ecto](https://github.com/elixir-ecto/ecto).\n\n[Documentation](https://hexdocs.pm/paginator)\n\n## Why?\n\nThere are several ways to implement pagination in a project and they all have pros and cons depending on your situation.\n\n### Limit-offset\n\nThis is the easiest method to use and implement: you just have to set `LIMIT` and `OFFSET` on your queries and the\ndatabase will return records based on this two parameters. Unfortunately, it has two major drawbacks:\n\n* Inconsistent results: if the dataset changes while you are querying, the results in the page will shift and your user\nmight end seeing records they have already seen and missing new ones.\n\n* Inefficiency: `OFFSET N` instructs the database to skip the first N results of a query. However, the database must still\nfetch these rows from disk and order them before it can returns the ones requested. If the dataset you are querying is\nlarge this will result in significant slowdowns.\n\n### Cursor-based (a.k.a keyset pagination)\n\nThis method relies on opaque cursor to figure out where to start selecting records. It is more performant than\n`LIMIT-OFFSET` because it can filter records without traversing all of them.\n\nIt's also consistent, any insertions/deletions before the current page will leave results unaffected.\n\nIt has some limitations though: for instance you can't jump directly to a specific page. This may\nnot be an issue for an API or if you use infinite scrolling on your website.\n\n### Learn more\n\n* http://use-the-index-luke.com/no-offset\n* http://use-the-index-luke.com/sql/partial-results/fetch-next-page\n* https://www.citusdata.com/blog/2016/03/30/five-ways-to-paginate/\n* https://developer.twitter.com/en/docs/tweets/timelines/guides/working-with-timelines\n\n## Getting started\n\n```elixir\ndefmodule MyApp.Repo do\n  use Ecto.Repo,\n    otp_app: :my_app,\n    adapter: Ecto.Adapters.Postgres\n\n  use Paginator\nend\n\nquery = from(p in Post, order_by: [asc: p.inserted_at, asc: p.id])\n\npage = MyApp.Repo.paginate(query, cursor_fields: [:inserted_at, :id], limit: 50)\n\n# `page.entries` contains all the entries for this page.\n# `page.metadata` contains the metadata associated with this page (cursors, limit, total count)\n```\n\n## Install\n\nAdd `paginator` to your list of dependencies in `mix.exs`:\n\n```elixir\ndef deps do\n  [{:paginator, \"~> 0.6\"}]\nend\n```\n\n## Usage\n\n1. Add `Paginator` to your repo.\n\n    ```elixir\n    defmodule MyApp.Repo do\n      use Ecto.Repo,\n        otp_app: :my_app,\n        adapter: Ecto.Adapters.Postgres\n\n      use Paginator\n    end\n    ```\n\n2. Use the `paginate` function to paginate your queries.\n\n    ```elixir\n    query = from(p in Post, order_by: [asc: p.inserted_at, asc: p.id])\n\n    # return the first 50 posts\n    %{entries: entries, metadata: metadata} = Repo.paginate(query, cursor_fields: [:inserted_at, :id], limit: 50)\n\n    # assign the `after` cursor to a variable\n    cursor_after = metadata.after\n\n    # return the next 50 posts\n    %{entries: entries, metadata: metadata} = Repo.paginate(query, after: cursor_after, cursor_fields: [{inserted_at: :asc}, {:id, :asc}], limit: 50)\n\n    # assign the `before` cursor to a variable\n    cursor_before = metadata.before\n\n    # return the previous 50 posts (if no post was created in between it should be the same list as in our first call to `paginate`)\n    %{entries: entries, metadata: metadata} = Repo.paginate(query, before: cursor_before, cursor_fields: [:inserted_at, :id], limit: 50)\n\n    # return total count\n    # NOTE: this will issue a separate `SELECT COUNT(*) FROM table` query to the database.\n    %{entries: entries, metadata: metadata} = Repo.paginate(query, include_total_count: true, cursor_fields: [:inserted_at, :id], limit: 50)\n\n    IO.puts \"total count: #{metadata.total_count}\"\n    ```\n\n## Indexes\n\nIf you want to reap all the benefits of this method it is better that you create indexes on the columns you are using as\ncursor fields.\n\n### Example\n\n```elixir\n# If your cursor fields are: [:inserted_at, :id]\n# Add the following in a migration\n\ncreate index(\"posts\", [:inserted_at, :id])\n```\n\n## Caveats\n\n* This method requires a deterministic sort order. If the columns you are currently using for sorting don't match that\ndefinition, just add any unique column and extend your index accordingly.\n* You need to add order_by clauses yourself before passing your query to `paginate/2`. In the future we might do that\nfor you automatically based on the fields specified in `:cursor_fields`.\n* There is an outstanding issue where Postgrex fails to properly builds the query if it includes custom PostgreSQL types.\n* This library has only be tested with PostgreSQL.\n\n## Documentation\n\nDocumentation is written into the library, you will find it in the source code, accessible from `iex` and of course, it\nall gets published to [hexdocs](http://hexdocs.pm/paginator).\n\n## Contributing\n\n### Running tests\n\nClone the repo and fetch its dependencies:\n\n```\n$ git clone https://github.com/duffelhq/paginator.git\n$ cd paginator\n$ mix deps.get\n$ mix test\n```\n\n### Building docs\n\n```\n$ mix docs\n```\n\n## LICENSE\n\nSee [LICENSE](https://github.com/duffelhq/paginator/blob/master/LICENSE.txt)\n", "defmodule Paginator.Cursor do\n  @moduledoc false\n\n  def decode(nil), do: nil\n\n  def decode(encoded_cursor) do\n    encoded_cursor\n    |> Base.url_decode64!()\n    |> :erlang.binary_to_term([:safe])\n  end\n\n  def encode(values) when is_map(values) do\n    values\n    |> :erlang.term_to_binary()\n    |> Base.url_encode64()\n  end\nend\n", "defmodule Paginator.Mixfile do\n  use Mix.Project\n\n  @version \"0.6.0\"\n\n  def project do\n    [\n      app: :paginator,\n      version: @version,\n      elixir: \"~> 1.4\",\n      elixirc_paths: elixirc_paths(Mix.env()),\n      build_embedded: Mix.env() == :prod,\n      start_permanent: Mix.env() == :prod,\n      deps: deps(),\n\n      # Hex\n      description: description(),\n      package: package(),\n\n      # Docs\n      name: \"Paginator\",\n      source_url: \"https://github.com/duffelhq/paginator\",\n      homepage_url: \"https://github.com/duffelhq/paginator\",\n      docs: [\n        source_ref: \"v#{@version}\",\n        main: \"Paginator\",\n        canonical: \"http://hexdocs.pm/paginator\",\n        source_url: \"https://github.com/duffelhq/paginator\"\n      ]\n    ]\n  end\n\n  def application do\n    [extra_applications: [:logger]]\n  end\n\n  defp elixirc_paths(:test), do: [\"lib\", \"test/support\"]\n  defp elixirc_paths(_), do: [\"lib\"]\n\n  defp deps do\n    [\n      {:calendar, \"~> 0.17.4\", only: :test},\n      {:ecto, \"~> 3.0\"},\n      {:ecto_sql, \"~> 3.0\"},\n      {:ex_doc, \"~> 0.18\", only: :dev, runtime: false},\n      {:ex_machina, \"~> 2.1\", only: :test},\n      {:inch_ex, \"~> 1.0\", only: [:dev, :test]},\n      {:postgrex, \"~> 0.13\", optional: true}\n    ]\n  end\n\n  defp description do\n    \"\"\"\n    Cursor based pagination for Elixir Ecto.\n    \"\"\"\n  end\n\n  defp package do\n    [\n      maintainers: [\"Steve Domin\"],\n      licenses: [\"MIT\"],\n      links: %{\"GitHub\" => \"https://github.com/duffelhq/paginator\"}\n    ]\n  end\nend\n", "%{\n  \"calendar\": {:hex, :calendar, \"0.17.4\", \"22c5e8d98a4db9494396e5727108dffb820ee0d18fed4b0aa8ab76e4f5bc32f1\", [:mix], [{:tzdata, \"~> 0.5.8 or ~> 0.1.201603\", [hex: :tzdata, repo: \"hexpm\", optional: false]}], \"hexpm\"},\n  \"certifi\": {:hex, :certifi, \"2.3.1\", \"d0f424232390bf47d82da8478022301c561cf6445b5b5fb6a84d49a9e76d2639\", [:rebar3], [{:parse_trans, \"3.2.0\", [hex: :parse_trans, repo: \"hexpm\", optional: false]}], \"hexpm\"},\n  \"connection\": {:hex, :connection, \"1.0.4\", \"a1cae72211f0eef17705aaededacac3eb30e6625b04a6117c1b2db6ace7d5976\", [:mix], [], \"hexpm\"},\n  \"db_connection\": {:hex, :db_connection, \"2.0.3\", \"b4e8aa43c100e16f122ccd6798cd51c48c79fd391c39d411f42b3cd765daccb0\", [:mix], [{:connection, \"~> 1.0.2\", [hex: :connection, repo: \"hexpm\", optional: false]}], \"hexpm\"},\n  \"decimal\": {:hex, :decimal, \"1.6.0\", \"bfd84d90ff966e1f5d4370bdd3943432d8f65f07d3bab48001aebd7030590dcc\", [:mix], [], \"hexpm\"},\n  \"earmark\": {:hex, :earmark, \"1.3.1\", \"73812f447f7a42358d3ba79283cfa3075a7580a3a2ed457616d6517ac3738cb9\", [:mix], [], \"hexpm\"},\n  \"ecto\": {:hex, :ecto, \"3.0.6\", \"d33ab5b3f7553a41507d4b0ad5bf192d533119c4ad08f3a5d63d85aa12117dc9\", [:mix], [{:decimal, \"~> 1.6\", [hex: :decimal, repo: \"hexpm\", optional: false]}, {:jason, \"~> 1.0\", [hex: :jason, repo: \"hexpm\", optional: true]}, {:poison, \"~> 2.2 or ~> 3.0\", [hex: :poison, repo: \"hexpm\", optional: true]}], \"hexpm\"},\n  \"ecto_sql\": {:hex, :ecto_sql, \"3.0.4\", \"e7a0feb0b2484b90981c56d5cd03c52122c1c31ded0b95ed213b7c5c07ae6737\", [:mix], [{:db_connection, \"~> 2.0\", [hex: :db_connection, repo: \"hexpm\", optional: false]}, {:ecto, \"~> 3.0.6\", [hex: :ecto, repo: \"hexpm\", optional: false]}, {:mariaex, \"~> 0.9.1\", [hex: :mariaex, repo: \"hexpm\", optional: true]}, {:postgrex, \"~> 0.14.0\", [hex: :postgrex, repo: \"hexpm\", optional: true]}, {:telemetry, \"~> 0.3.0\", [hex: :telemetry, repo: \"hexpm\", optional: false]}], \"hexpm\"},\n  \"ex_doc\": {:hex, :ex_doc, \"0.19.3\", \"3c7b0f02851f5fc13b040e8e925051452e41248f685e40250d7e40b07b9f8c10\", [:mix], [{:earmark, \"~> 1.2\", [hex: :earmark, repo: \"hexpm\", optional: false]}, {:makeup_elixir, \"~> 0.10\", [hex: :makeup_elixir, repo: \"hexpm\", optional: false]}], \"hexpm\"},\n  \"ex_machina\": {:hex, :ex_machina, \"2.2.2\", \"d84217a6fb7840ff771d2561b8aa6d74a0d8968e4b10ecc0d7e9890dc8fb1c6a\", [:mix], [{:ecto, \"~> 2.2 or ~> 3.0\", [hex: :ecto, repo: \"hexpm\", optional: true]}, {:ecto_sql, \"~> 3.0\", [hex: :ecto_sql, repo: \"hexpm\", optional: true]}], \"hexpm\"},\n  \"hackney\": {:hex, :hackney, \"1.13.0\", \"24edc8cd2b28e1c652593833862435c80661834f6c9344e84b6a2255e7aeef03\", [:rebar3], [{:certifi, \"2.3.1\", [hex: :certifi, repo: \"hexpm\", optional: false]}, {:idna, \"5.1.2\", [hex: :idna, repo: \"hexpm\", optional: false]}, {:metrics, \"1.0.1\", [hex: :metrics, repo: \"hexpm\", optional: false]}, {:mimerl, \"1.0.2\", [hex: :mimerl, repo: \"hexpm\", optional: false]}, {:ssl_verify_fun, \"1.1.1\", [hex: :ssl_verify_fun, repo: \"hexpm\", optional: false]}], \"hexpm\"},\n  \"idna\": {:hex, :idna, \"5.1.2\", \"e21cb58a09f0228a9e0b95eaa1217f1bcfc31a1aaa6e1fdf2f53a33f7dbd9494\", [:rebar3], [{:unicode_util_compat, \"0.3.1\", [hex: :unicode_util_compat, repo: \"hexpm\", optional: false]}], \"hexpm\"},\n  \"inch_ex\": {:hex, :inch_ex, \"1.0.1\", \"1f0af1a83cec8e56f6fc91738a09c838e858db3d78ef5f2ec040fe4d5a62dabf\", [:mix], [{:poison, \"~> 1.5 or ~> 2.0 or ~> 3.0\", [hex: :poison, repo: \"hexpm\", optional: false]}], \"hexpm\"},\n  \"makeup\": {:hex, :makeup, \"0.8.0\", \"9cf32aea71c7fe0a4b2e9246c2c4978f9070257e5c9ce6d4a28ec450a839b55f\", [:mix], [{:nimble_parsec, \"~> 0.5.0\", [hex: :nimble_parsec, repo: \"hexpm\", optional: false]}], \"hexpm\"},\n  \"makeup_elixir\": {:hex, :makeup_elixir, \"0.13.0\", \"be7a477997dcac2e48a9d695ec730b2d22418292675c75aa2d34ba0909dcdeda\", [:mix], [{:makeup, \"~> 0.8\", [hex: :makeup, repo: \"hexpm\", optional: false]}], \"hexpm\"},\n  \"metrics\": {:hex, :metrics, \"1.0.1\", \"25f094dea2cda98213cecc3aeff09e940299d950904393b2a29d191c346a8486\", [:rebar3], [], \"hexpm\"},\n  \"mimerl\": {:hex, :mimerl, \"1.0.2\", \"993f9b0e084083405ed8252b99460c4f0563e41729ab42d9074fd5e52439be88\", [:rebar3], [], \"hexpm\"},\n  \"nimble_parsec\": {:hex, :nimble_parsec, \"0.5.0\", \"90e2eca3d0266e5c53f8fbe0079694740b9c91b6747f2b7e3c5d21966bba8300\", [:mix], [], \"hexpm\"},\n  \"parse_trans\": {:hex, :parse_trans, \"3.2.0\", \"2adfa4daf80c14dc36f522cf190eb5c4ee3e28008fc6394397c16f62a26258c2\", [:rebar3], [], \"hexpm\"},\n  \"poison\": {:hex, :poison, \"3.1.0\", \"d9eb636610e096f86f25d9a46f35a9facac35609a7591b3be3326e99a0484665\", [:mix], [], \"hexpm\"},\n  \"poolboy\": {:hex, :poolboy, \"1.5.1\", \"6b46163901cfd0a1b43d692657ed9d7e599853b3b21b95ae5ae0a777cf9b6ca8\", [:rebar], [], \"hexpm\"},\n  \"postgrex\": {:hex, :postgrex, \"0.14.1\", \"63247d4a5ad6b9de57a0bac5d807e1c32d41e39c04b8a4156a26c63bcd8a2e49\", [:mix], [{:connection, \"~> 1.0\", [hex: :connection, repo: \"hexpm\", optional: false]}, {:db_connection, \"~> 2.0\", [hex: :db_connection, repo: \"hexpm\", optional: false]}, {:decimal, \"~> 1.5\", [hex: :decimal, repo: \"hexpm\", optional: false]}, {:jason, \"~> 1.0\", [hex: :jason, repo: \"hexpm\", optional: true]}], \"hexpm\"},\n  \"ssl_verify_fun\": {:hex, :ssl_verify_fun, \"1.1.1\", \"28a4d65b7f59893bc2c7de786dec1e1555bd742d336043fe644ae956c3497fbe\", [:make, :rebar], [], \"hexpm\"},\n  \"telemetry\": {:hex, :telemetry, \"0.3.0\", \"099a7f3ce31e4780f971b4630a3c22ec66d22208bc090fe33a2a3a6a67754a73\", [:rebar3], [], \"hexpm\"},\n  \"tzdata\": {:hex, :tzdata, \"0.5.17\", \"50793e3d85af49736701da1a040c415c97dc1caf6464112fd9bd18f425d3053b\", [:mix], [{:hackney, \"~> 1.0\", [hex: :hackney, repo: \"hexpm\", optional: false]}], \"hexpm\"},\n  \"unicode_util_compat\": {:hex, :unicode_util_compat, \"0.3.1\", \"a1f612a7b512638634a603c8f401892afbf99b8ce93a45041f8aaca99cadb85e\", [:rebar3], [], \"hexpm\"},\n}\n", "defmodule PaginatorTest do\n  use Paginator.DataCase\n  doctest Paginator\n\n  alias Calendar.DateTime, as: DT\n\n  alias Paginator.Cursor\n\n  setup :create_customers_and_payments\n\n  test \"paginates forward\", %{\n    payments: {p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12}\n  } do\n    opts = [cursor_fields: [:charged_at, :id], sort_direction: :asc, limit: 4]\n\n    page = payments_by_charged_at() |> Repo.paginate(opts)\n    assert to_ids(page.entries) == to_ids([p5, p4, p1, p6])\n    assert page.metadata.after == encode_cursor(%{charged_at: p6.charged_at, id: p6.id})\n\n    page = payments_by_charged_at() |> Repo.paginate(opts ++ [after: page.metadata.after])\n    assert to_ids(page.entries) == to_ids([p7, p3, p10, p2])\n    assert page.metadata.after == encode_cursor(%{charged_at: p2.charged_at, id: p2.id})\n\n    page = payments_by_charged_at() |> Repo.paginate(opts ++ [after: page.metadata.after])\n    assert to_ids(page.entries) == to_ids([p12, p8, p9, p11])\n    assert page.metadata.after == nil\n  end\n\n  test \"paginates forward with legacy cursor\", %{\n    payments: {p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12}\n  } do\n    opts = [cursor_fields: [:charged_at, :id], sort_direction: :asc, limit: 4]\n\n    page = payments_by_charged_at() |> Repo.paginate(opts)\n    assert to_ids(page.entries) == to_ids([p5, p4, p1, p6])\n    assert %{charged_at: charged_at, id: id} = Cursor.decode(page.metadata.after)\n    assert charged_at == p6.charged_at\n    assert id == p6.id\n\n    legacy_cursor = encode_legacy_cursor([charged_at, id])\n\n    page = payments_by_charged_at() |> Repo.paginate(opts ++ [after: legacy_cursor])\n    assert to_ids(page.entries) == to_ids([p7, p3, p10, p2])\n    assert %{charged_at: charged_at, id: id} = Cursor.decode(page.metadata.after)\n    assert charged_at == p2.charged_at\n    assert id == p2.id\n\n    legacy_cursor = encode_legacy_cursor([charged_at, id])\n\n    page = payments_by_charged_at() |> Repo.paginate(opts ++ [after: legacy_cursor])\n    assert to_ids(page.entries) == to_ids([p12, p8, p9, p11])\n    assert page.metadata.after == nil\n  end\n\n  test \"paginates backward\", %{\n    payments: {p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12}\n  } do\n    opts = [cursor_fields: [:charged_at, :id], sort_direction: :asc, limit: 4]\n\n    page =\n      payments_by_charged_at()\n      |> Repo.paginate(opts ++ [before: encode_cursor(%{charged_at: p11.charged_at, id: p11.id})])\n\n    assert to_ids(page.entries) == to_ids([p2, p12, p8, p9])\n    assert page.metadata.before == encode_cursor(%{charged_at: p2.charged_at, id: p2.id})\n\n    page = payments_by_charged_at() |> Repo.paginate(opts ++ [before: page.metadata.before])\n    assert to_ids(page.entries) == to_ids([p6, p7, p3, p10])\n    assert page.metadata.before == encode_cursor(%{charged_at: p6.charged_at, id: p6.id})\n\n    page = payments_by_charged_at() |> Repo.paginate(opts ++ [before: page.metadata.before])\n    assert to_ids(page.entries) == to_ids([p5, p4, p1])\n    assert page.metadata.after == encode_cursor(%{charged_at: p1.charged_at, id: p1.id})\n    assert page.metadata.before == nil\n  end\n\n  test \"returns an empty page when there are no results\" do\n    page =\n      payments_by_status(\"failed\")\n      |> Repo.paginate(cursor_fields: [:charged_at, :id], limit: 10)\n\n    assert page.entries == []\n    assert page.metadata.after == nil\n    assert page.metadata.before == nil\n  end\n\n  describe \"paginate a collection of payments, sorting by charged_at\" do\n    test \"sorts ascending without cursors\", %{\n      payments: {p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12}\n    } do\n      %Page{entries: entries, metadata: metadata} =\n        payments_by_charged_at()\n        |> Repo.paginate(cursor_fields: [:charged_at, :id], sort_direction: :asc, limit: 50)\n\n      assert to_ids(entries) == to_ids([p5, p4, p1, p6, p7, p3, p10, p2, p12, p8, p9, p11])\n      assert metadata == %Metadata{after: nil, before: nil, limit: 50}\n    end\n\n    test \"sorts ascending with before cursor\", %{\n      payments: {p1, p2, p3, _p4, _p5, p6, p7, p8, p9, p10, _p11, p12}\n    } do\n      %Page{entries: entries, metadata: metadata} =\n        payments_by_charged_at()\n        |> Repo.paginate(\n          cursor_fields: [:charged_at, :id],\n          sort_direction: :asc,\n          before: encode_cursor(%{charged_at: p9.charged_at, id: p9.id}),\n          limit: 8\n        )\n\n      assert to_ids(entries) == to_ids([p1, p6, p7, p3, p10, p2, p12, p8])\n\n      assert metadata == %Metadata{\n               after: encode_cursor(%{charged_at: p8.charged_at, id: p8.id}),\n               before: encode_cursor(%{charged_at: p1.charged_at, id: p1.id}),\n               limit: 8\n             }\n    end\n\n    test \"sorts ascending with after cursor\", %{\n      payments: {_p1, p2, p3, _p4, _p5, _p6, _p7, p8, p9, p10, p11, p12}\n    } do\n      %Page{entries: entries, metadata: metadata} =\n        payments_by_charged_at()\n        |> Repo.paginate(\n          cursor_fields: [:charged_at, :id],\n          sort_direction: :asc,\n          after: encode_cursor(%{charged_at: p3.charged_at, id: p3.id}),\n          limit: 8\n        )\n\n      assert to_ids(entries) == to_ids([p10, p2, p12, p8, p9, p11])\n\n      assert metadata == %Metadata{\n               after: nil,\n               before: encode_cursor(%{charged_at: p10.charged_at, id: p10.id}),\n               limit: 8\n             }\n    end\n\n    test \"sorts ascending with before and after cursor\", %{\n      payments: {_p1, p2, p3, _p4, _p5, _p6, _p7, p8, _p9, p10, _p11, p12}\n    } do\n      %Page{entries: entries, metadata: metadata} =\n        payments_by_charged_at()\n        |> Repo.paginate(\n          cursor_fields: [:charged_at, :id],\n          sort_direction: :asc,\n          after: encode_cursor(%{charged_at: p3.charged_at, id: p3.id}),\n          before: encode_cursor(%{charged_at: p8.charged_at, id: p8.id}),\n          limit: 8\n        )\n\n      assert to_ids(entries) == to_ids([p10, p2, p12])\n\n      assert metadata == %Metadata{\n               after: encode_cursor(%{charged_at: p12.charged_at, id: p12.id}),\n               before: encode_cursor(%{charged_at: p10.charged_at, id: p10.id}),\n               limit: 8\n             }\n    end\n\n    test \"sorts descending without cursors\", %{\n      payments: {p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12}\n    } do\n      %Page{entries: entries, metadata: metadata} =\n        payments_by_charged_at(:desc)\n        |> Repo.paginate(cursor_fields: [:charged_at, :id], sort_direction: :desc, limit: 50)\n\n      assert to_ids(entries) == to_ids([p11, p9, p8, p12, p2, p10, p3, p7, p6, p1, p4, p5])\n      assert metadata == %Metadata{after: nil, before: nil, limit: 50}\n    end\n\n    test \"sorts descending with before cursor\", %{\n      payments: {_p1, _p2, _p3, _p4, _p5, _p6, _p7, _p8, p9, _p10, p11, _p12}\n    } do\n      %Page{entries: entries, metadata: metadata} =\n        payments_by_charged_at(:desc)\n        |> Repo.paginate(\n          cursor_fields: [:charged_at, :id],\n          sort_direction: :desc,\n          before: encode_cursor(%{charged_at: p9.charged_at, id: p9.id}),\n          limit: 8\n        )\n\n      assert to_ids(entries) == to_ids([p11])\n\n      assert metadata == %Metadata{\n               after: encode_cursor(%{charged_at: p11.charged_at, id: p11.id}),\n               before: nil,\n               limit: 8\n             }\n    end\n\n    test \"sorts descending with after cursor\", %{\n      payments: {p1, p2, p3, _p4, _p5, p6, p7, p8, p9, p10, _p11, p12}\n    } do\n      %Page{entries: entries, metadata: metadata} =\n        payments_by_charged_at(:desc)\n        |> Repo.paginate(\n          cursor_fields: [:charged_at, :id],\n          sort_direction: :desc,\n          after: encode_cursor(%{charged_at: p9.charged_at, id: p9.id}),\n          limit: 8\n        )\n\n      assert to_ids(entries) == to_ids([p8, p12, p2, p10, p3, p7, p6, p1])\n\n      assert metadata == %Metadata{\n               after: encode_cursor(%{charged_at: p1.charged_at, id: p1.id}),\n               before: encode_cursor(%{charged_at: p8.charged_at, id: p8.id}),\n               limit: 8\n             }\n    end\n\n    test \"sorts descending with before and after cursor\", %{\n      payments: {_p1, p2, p3, _p4, _p5, _p6, _p7, p8, p9, p10, _p11, p12}\n    } do\n      %Page{entries: entries, metadata: metadata} =\n        payments_by_charged_at(:desc)\n        |> Repo.paginate(\n          cursor_fields: [:charged_at, :id],\n          sort_direction: :desc,\n          after: encode_cursor(%{charged_at: p9.charged_at, id: p9.id}),\n          before: encode_cursor(%{charged_at: p3.charged_at, id: p3.id}),\n          limit: 8\n        )\n\n      assert to_ids(entries) == to_ids([p8, p12, p2, p10])\n\n      assert metadata == %Metadata{\n               after: encode_cursor(%{charged_at: p10.charged_at, id: p10.id}),\n               before: encode_cursor(%{charged_at: p8.charged_at, id: p8.id}),\n               limit: 8\n             }\n    end\n\n    test \"sorts ascending with before cursor at beginning of collection\", %{\n      payments: {_p1, _p2, _p3, _p4, p5, _p6, _p7, _p8, _p9, _p10, _p11, _p12}\n    } do\n      %Page{entries: entries, metadata: metadata} =\n        payments_by_charged_at()\n        |> Repo.paginate(\n          cursor_fields: [:charged_at, :id],\n          sort_direction: :asc,\n          before: encode_cursor(%{charged_at: p5.charged_at, id: p5.id}),\n          limit: 8\n        )\n\n      assert to_ids(entries) == to_ids([])\n      assert metadata == %Metadata{after: nil, before: nil, limit: 8}\n    end\n\n    test \"sorts ascending with after cursor at end of collection\", %{\n      payments: {_p1, _p2, _p3, _p4, _p5, _p6, _p7, _p8, _p9, _p10, p11, _p12}\n    } do\n      %Page{entries: entries, metadata: metadata} =\n        payments_by_charged_at()\n        |> Repo.paginate(\n          cursor_fields: [:charged_at, :id],\n          sort_direction: :asc,\n          after: encode_cursor(%{charged_at: p11.charged_at, id: p11.id}),\n          limit: 8\n        )\n\n      assert to_ids(entries) == to_ids([])\n      assert metadata == %Metadata{after: nil, before: nil, limit: 8}\n    end\n\n    test \"sorts descending with before cursor at beginning of collection\", %{\n      payments: {_p1, _p2, _p3, _p4, _p5, _p6, _p7, _p8, _p9, _p10, p11, _p12}\n    } do\n      %Page{entries: entries, metadata: metadata} =\n        payments_by_charged_at(:desc)\n        |> Repo.paginate(\n          cursor_fields: [:charged_at, :id],\n          sort_direction: :desc,\n          before: encode_cursor(%{charged_at: p11.charged_at, id: p11.id}),\n          limit: 8\n        )\n\n      assert to_ids(entries) == to_ids([])\n      assert metadata == %Metadata{after: nil, before: nil, limit: 8}\n    end\n\n    test \"sorts descending with after cursor at end of collection\", %{\n      payments: {_p1, _p2, _p3, _p4, p5, _p6, _p7, _p8, _p9, _p10, _p11, _p12}\n    } do\n      %Page{entries: entries, metadata: metadata} =\n        payments_by_charged_at(:desc)\n        |> Repo.paginate(\n          cursor_fields: [:charged_at, :id],\n          sort_direction: :desc,\n          after: encode_cursor(%{charged_at: p5.charged_at, id: p5.id}),\n          limit: 8\n        )\n\n      assert to_ids(entries) == to_ids([])\n      assert metadata == %Metadata{after: nil, before: nil, limit: 8}\n    end\n  end\n\n  describe \"paginate a collection of payments with customer filter, sorting by amount, charged_at\" do\n    test \"multiple cursor_fields with pre-existing where filter in query\", %{\n      customers: {c1, _c2, _c3},\n      payments: {_p1, _p2, _p3, _p4, p5, p6, p7, p8, _p9, _p10, _p11, _p12}\n    } do\n      %Page{entries: entries, metadata: _metadata} =\n        customer_payments_by_amount(c1)\n        |> Repo.paginate(cursor_fields: [:amount, :charged_at, :id], limit: 50)\n\n      assert to_ids(entries) == to_ids([p6, p5, p7, p8])\n    end\n\n    test \"before cursor with multiple cursor_fields and pre-existing where filter in query\", %{\n      customers: {c1, _c2, _c3},\n      payments: {_p1, _p2, _p3, _p4, _p5, p6, _p7, _p8, _p9, _p10, _p11, _p12}\n    } do\n      assert %Page{entries: [], metadata: _metadata} =\n               customer_payments_by_amount(c1)\n               |> Repo.paginate(\n                 cursor_fields: [:amount, :charged_at, :id],\n                 before:\n                   encode_cursor(%{amount: p6.amount, charged_at: p6.charged_at, id: p6.id}),\n                 limit: 1\n               )\n    end\n  end\n\n  describe \"paginate a collection of payments, sorting by customer name\" do\n    test \"raises error when binding not found\", %{\n      payments: {_p1, _p2, _p3, _p4, _p5, _p6, _p7, _p8, _p9, _p10, p11, _p12}\n    } do\n      assert_raise ArgumentError,\n                   \"Could not find binding `bogus_binding` in query aliases: %{customer: 1, payments: 0}\",\n                   fn ->\n                     %Page{} =\n                       payments_by_customer_name()\n                       |> Repo.paginate(\n                         cursor_fields: [\n                           {{:bogus_binding, :id}, :asc},\n                           {{:bogus_binding, :name}, :asc}\n                         ],\n                         limit: 50,\n                         before:\n                           encode_cursor(%{\n                             {:bogus_binding, :id} => p11.id,\n                             {:bogus_binding, :name} => p11.customer.name\n                           })\n                       )\n                   end\n    end\n\n    test \"sorts with mixed bindingless, bound columns\", %{\n      payments: {_p1, _p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, _p12}\n    } do\n      %Page{entries: entries, metadata: metadata} =\n        payments_by_customer_name()\n        |> Repo.paginate(\n          cursor_fields: [{:id, :asc}, {{:customer, :name}, :asc}],\n          before: encode_cursor(%{:id => p11.id, {:customer, :name} => p11.customer.name}),\n          limit: 8\n        )\n\n      assert to_ids(entries) == to_ids([p3, p4, p5, p6, p7, p8, p9, p10])\n\n      assert metadata == %Metadata{\n               after: encode_cursor(%{:id => p10.id, {:customer, :name} => p10.customer.name}),\n               before: encode_cursor(%{:id => p3.id, {:customer, :name} => p3.customer.name}),\n               limit: 8\n             }\n    end\n\n    test \"sorts with mixed columns without direction and bound columns\", %{\n      payments: {_p1, _p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, _p12}\n    } do\n      %Page{entries: entries, metadata: metadata} =\n        payments_by_customer_name()\n        |> Repo.paginate(\n          cursor_fields: [:id, {{:customer, :name}, :asc}],\n          before: encode_cursor(%{:id => p11.id, {:customer, :name} => p11.customer.name}),\n          limit: 8\n        )\n\n      assert to_ids(entries) == to_ids([p3, p4, p5, p6, p7, p8, p9, p10])\n\n      assert metadata == %Metadata{\n               after: encode_cursor(%{:id => p10.id, {:customer, :name} => p10.customer.name}),\n               before: encode_cursor(%{:id => p3.id, {:customer, :name} => p3.customer.name}),\n               limit: 8\n             }\n    end\n\n    test \"sorts ascending without cursors\", %{\n      payments: {p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12}\n    } do\n      %Page{entries: entries, metadata: metadata} =\n        payments_by_customer_name()\n        |> Repo.paginate(\n          cursor_fields: [{{:payments, :id}, :asc}, {{:customer, :name}, :asc}],\n          limit: 50\n        )\n\n      assert to_ids(entries) == to_ids([p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12])\n      assert metadata == %Metadata{after: nil, before: nil, limit: 50}\n    end\n\n    test \"sorts ascending with before cursor\", %{\n      payments: {_p1, _p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, _p12}\n    } do\n      %Page{entries: entries, metadata: metadata} =\n        payments_by_customer_name()\n        |> Repo.paginate(\n          cursor_fields: [{{:payments, :id}, :asc}, {{:customer, :name}, :asc}],\n          before:\n            encode_cursor(%{{:payments, :id} => p11.id, {:customer, :name} => p11.customer.name}),\n          limit: 8\n        )\n\n      assert to_ids(entries) == to_ids([p3, p4, p5, p6, p7, p8, p9, p10])\n\n      assert metadata == %Metadata{\n               after:\n                 encode_cursor(%{\n                   {:payments, :id} => p10.id,\n                   {:customer, :name} => p10.customer.name\n                 }),\n               before:\n                 encode_cursor(%{\n                   {:payments, :id} => p3.id,\n                   {:customer, :name} => p3.customer.name\n                 }),\n               limit: 8\n             }\n    end\n\n    test \"sorts ascending with after cursor\", %{\n      payments: {_p1, _p2, _p3, _p4, _p5, p6, p7, p8, p9, p10, p11, p12}\n    } do\n      %Page{entries: entries, metadata: metadata} =\n        payments_by_customer_name()\n        |> Repo.paginate(\n          cursor_fields: [{{:payments, :id}, :asc}, {{:customer, :name}, :asc}],\n          after:\n            encode_cursor(%{{:payments, :id} => p6.id, {:customer, :name} => p6.customer.name}),\n          limit: 8\n        )\n\n      assert to_ids(entries) == to_ids([p7, p8, p9, p10, p11, p12])\n\n      assert metadata == %Metadata{\n               after: nil,\n               before:\n                 encode_cursor(%{\n                   {:payments, :id} => p7.id,\n                   {:customer, :name} => p7.customer.name\n                 }),\n               limit: 8\n             }\n    end\n\n    test \"sorts ascending with before and after cursor\", %{\n      payments: {_p1, _p2, _p3, _p4, _p5, p6, p7, p8, p9, p10, _p11, _p12}\n    } do\n      %Page{entries: entries, metadata: metadata} =\n        payments_by_customer_name()\n        |> Repo.paginate(\n          cursor_fields: [{{:payments, :id}, :asc}, {{:customer, :name}, :asc}],\n          after:\n            encode_cursor(%{{:payments, :id} => p6.id, {:customer, :name} => p6.customer.name}),\n          before:\n            encode_cursor(%{{:payments, :id} => p10.id, {:customer, :name} => p10.customer.name}),\n          limit: 8\n        )\n\n      assert to_ids(entries) == to_ids([p7, p8, p9])\n\n      assert metadata == %Metadata{\n               after:\n                 encode_cursor(%{\n                   {:payments, :id} => p9.id,\n                   {:customer, :name} => p9.customer.name\n                 }),\n               before:\n                 encode_cursor(%{\n                   {:payments, :id} => p7.id,\n                   {:customer, :name} => p7.customer.name\n                 }),\n               limit: 8\n             }\n    end\n\n    test \"sorts descending without cursors\", %{\n      payments: {p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12}\n    } do\n      %Page{entries: entries, metadata: metadata} =\n        payments_by_customer_name(:desc, :desc)\n        |> Repo.paginate(\n          cursor_fields: [{{:payments, :id}, :desc}, {{:customer, :name}, :desc}],\n          limit: 50\n        )\n\n      assert to_ids(entries) == to_ids([p12, p11, p10, p9, p8, p7, p6, p5, p4, p3, p2, p1])\n      assert metadata == %Metadata{after: nil, before: nil, limit: 50}\n    end\n\n    test \"sorts descending with before cursor\", %{\n      payments: {_p1, _p2, _p3, _p4, _p5, _p6, _p7, _p8, _p9, _p10, p11, p12}\n    } do\n      %Page{entries: entries, metadata: metadata} =\n        payments_by_customer_name(:desc)\n        |> Repo.paginate(\n          cursor_fields: [{{:payments, :id}, :desc}, {{:customer, :name}, :desc}],\n          before:\n            encode_cursor(%{{:payments, :id} => p11.id, {:customer, :name} => p11.customer.name}),\n          limit: 8\n        )\n\n      assert to_ids(entries) == to_ids([p12])\n\n      assert metadata == %Metadata{\n               after:\n                 encode_cursor(%{\n                   {:payments, :id} => p12.id,\n                   {:customer, :name} => p12.customer.name\n                 }),\n               before: nil,\n               limit: 8\n             }\n    end\n\n    test \"sorts descending with after cursor\", %{\n      payments: {_p1, _p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, _p12}\n    } do\n      %Page{entries: entries, metadata: metadata} =\n        payments_by_customer_name(:desc, :desc)\n        |> Repo.paginate(\n          cursor_fields: [{{:payments, :id}, :desc}, {{:customer, :name}, :desc}],\n          sort_direction: :desc,\n          after:\n            encode_cursor(%{{:payments, :id} => p11.id, {:customer, :name} => p11.customer.name}),\n          limit: 8\n        )\n\n      assert to_ids(entries) == to_ids([p10, p9, p8, p7, p6, p5, p4, p3])\n\n      assert metadata == %Metadata{\n               after:\n                 encode_cursor(%{\n                   {:payments, :id} => p3.id,\n                   {:customer, :name} => p3.customer.name\n                 }),\n               before:\n                 encode_cursor(%{\n                   {:payments, :id} => p10.id,\n                   {:customer, :name} => p10.customer.name\n                 }),\n               limit: 8\n             }\n    end\n\n    test \"sorts descending with before and after cursor\", %{\n      payments: {_p1, _p2, _p3, _p4, _p5, p6, p7, p8, p9, p10, p11, _p12}\n    } do\n      %Page{entries: entries, metadata: metadata} =\n        payments_by_customer_name(:desc, :desc)\n        |> Repo.paginate(\n          cursor_fields: [{{:payments, :id}, :desc}, {{:customer, :name}, :desc}],\n          after:\n            encode_cursor(%{{:payments, :id} => p11.id, {:customer, :name} => p11.customer.name}),\n          before:\n            encode_cursor(%{{:payments, :id} => p6.id, {:customer, :name} => p6.customer.name}),\n          limit: 8\n        )\n\n      assert to_ids(entries) == to_ids([p10, p9, p8, p7])\n\n      assert metadata == %Metadata{\n               after:\n                 encode_cursor(%{\n                   {:payments, :id} => p7.id,\n                   {:customer, :name} => p7.customer.name\n                 }),\n               before:\n                 encode_cursor(%{\n                   {:payments, :id} => p10.id,\n                   {:customer, :name} => p10.customer.name\n                 }),\n               limit: 8\n             }\n    end\n\n    test \"sorts ascending with before cursor at beginning of collection\", %{\n      payments: {p1, _p2, _p3, _p4, _p5, _p6, _p7, _p8, _p9, _p10, _p11, _p12}\n    } do\n      %Page{entries: entries, metadata: metadata} =\n        payments_by_customer_name()\n        |> Repo.paginate(\n          cursor_fields: [{{:payments, :id}, :asc}, {{:customer, :name}, :asc}],\n          before:\n            encode_cursor(%{{:payments, :id} => p1.id, {:customer, :name} => p1.customer.name}),\n          limit: 8\n        )\n\n      assert to_ids(entries) == to_ids([])\n      assert metadata == %Metadata{after: nil, before: nil, limit: 8}\n    end\n\n    test \"sorts ascending with after cursor at end of collection\", %{\n      payments: {_p1, _p2, _p3, _p4, _p5, _p6, _p7, _p8, _p9, _p10, _p11, p12}\n    } do\n      %Page{entries: entries, metadata: metadata} =\n        payments_by_customer_name()\n        |> Repo.paginate(\n          cursor_fields: [{{:payments, :id}, :asc}, {{:customer, :name}, :asc}],\n          after:\n            encode_cursor(%{{:payments, :id} => p12.id, {:customer, :name} => p12.customer.name}),\n          limit: 8\n        )\n\n      assert to_ids(entries) == to_ids([])\n      assert metadata == %Metadata{after: nil, before: nil, limit: 8}\n    end\n\n    test \"sorts descending with before cursor at beginning of collection\", %{\n      payments: {_p1, _p2, _p3, _p4, _p5, _p6, _p7, _p8, _p9, _p10, _p11, p12}\n    } do\n      %Page{entries: entries, metadata: metadata} =\n        payments_by_customer_name(:desc, :desc)\n        |> Repo.paginate(\n          cursor_fields: [{{:payments, :id}, :desc}, {{:customer, :name}, :desc}],\n          before:\n            encode_cursor(%{{:payments, :id} => p12.id, {:customer, :name} => p12.customer.name}),\n          limit: 8\n        )\n\n      assert to_ids(entries) == to_ids([])\n      assert metadata == %Metadata{after: nil, before: nil, limit: 8}\n    end\n\n    test \"sorts descending with after cursor at end of collection\", %{\n      payments: {p1, _p2, _p3, _p4, _p5, _p6, _p7, _p8, _p9, _p10, _p11, _p12}\n    } do\n      %Page{entries: entries, metadata: metadata} =\n        payments_by_customer_name(:desc, :desc)\n        |> Repo.paginate(\n          cursor_fields: [{{:payments, :id}, :desc}, {{:customer, :name}, :desc}],\n          after:\n            encode_cursor(%{{:payments, :id} => p1.id, {:customer, :name} => p1.customer.name}),\n          limit: 8\n        )\n\n      assert to_ids(entries) == to_ids([])\n      assert metadata == %Metadata{after: nil, before: nil, limit: 8}\n    end\n\n    test \"sorts on 2nd level join column with a custom cursor value function\", %{\n      payments: {_p1, _p2, _p3, _p4, p5, p6, p7, _p8, _p9, _p10, _p11, _p12}\n    } do\n      %Page{entries: entries, metadata: metadata} =\n        payments_by_address_city()\n        |> Repo.paginate(\n          cursor_fields: [{{:address, :city}, :asc}, id: :asc],\n          before: nil,\n          limit: 3,\n          fetch_cursor_value_fun: fn\n            schema, {:address, :city} ->\n              schema.customer.address.city\n\n            schema, field ->\n              Paginator.default_fetch_cursor_value(schema, field)\n          end\n        )\n\n      assert to_ids(entries) == to_ids([p5, p6, p7])\n\n      p7 = Repo.preload(p7, customer: :address)\n\n      assert metadata == %Metadata{\n               after:\n                 encode_cursor(%{{:address, :city} => p7.customer.address.city, :id => p7.id}),\n               before: nil,\n               limit: 3\n             }\n    end\n\n    test \"sorts with respect to nil values\", %{\n      payments: {_p1, _p2, _p3, _p4, _p5, _p6, p7, _p8, _p9, _p10, p11, _p12}\n    } do\n      %Page{entries: entries, metadata: metadata} =\n        payments_by_charged_at(:desc)\n        |> Repo.paginate(\n          cursor_fields: [:charged_at, :id],\n          sort_direction: :desc,\n          after: encode_cursor(%{charged_at: nil, id: nil}),\n          limit: 8\n        )\n\n      assert Enum.count(entries) == 8\n\n      assert metadata == %Metadata{\n               before: encode_cursor(%{charged_at: p11.charged_at, id: p11.id}),\n               limit: 8,\n               after: encode_cursor(%{charged_at: p7.charged_at, id: p7.id})\n             }\n    end\n  end\n\n  test \"applies a default limit if none is provided\", %{\n    payments: {p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12}\n  } do\n    %Page{entries: entries, metadata: metadata} =\n      payments_by_customer_name()\n      |> Repo.paginate(cursor_fields: [:id], sort_direction: :asc)\n\n    assert to_ids(entries) == to_ids([p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12])\n    assert metadata == %Metadata{after: nil, before: nil, limit: 50}\n  end\n\n  test \"enforces the minimum limit\", %{\n    payments: {p1, _p2, _p3, _p4, _p5, _p6, _p7, _p8, _p9, _p10, _p11, _p12}\n  } do\n    %Page{entries: entries, metadata: metadata} =\n      payments_by_customer_name()\n      |> Repo.paginate(cursor_fields: [:id], sort_direction: :asc, limit: 0)\n\n    assert to_ids(entries) == to_ids([p1])\n    assert metadata == %Metadata{after: encode_cursor(%{id: p1.id}), before: nil, limit: 1}\n  end\n\n  describe \"with include_total_count\" do\n    test \"when set to :infinity\", %{\n      payments: {_p1, _p2, _p3, _p4, p5, _p6, _p7, _p8, _p9, _p10, _p11, _p12}\n    } do\n      %Page{metadata: metadata} =\n        payments_by_customer_name()\n        |> Repo.paginate(\n          cursor_fields: [:id],\n          sort_direction: :asc,\n          limit: 5,\n          total_count_limit: :infinity,\n          include_total_count: true\n        )\n\n      assert metadata == %Metadata{\n               after: encode_cursor(%{id: p5.id}),\n               before: nil,\n               limit: 5,\n               total_count: 12,\n               total_count_cap_exceeded: false\n             }\n    end\n\n    test \"when cap not exceeded\", %{\n      payments: {_p1, _p2, _p3, _p4, p5, _p6, _p7, _p8, _p9, _p10, _p11, _p12}\n    } do\n      %Page{metadata: metadata} =\n        payments_by_customer_name()\n        |> Repo.paginate(\n          cursor_fields: [:id],\n          sort_direction: :asc,\n          limit: 5,\n          include_total_count: true\n        )\n\n      assert metadata == %Metadata{\n               after: encode_cursor(%{id: p5.id}),\n               before: nil,\n               limit: 5,\n               total_count: 12,\n               total_count_cap_exceeded: false\n             }\n    end\n\n    test \"when cap exceeded\", %{\n      payments: {_p1, _p2, _p3, _p4, p5, _p6, _p7, _p8, _p9, _p10, _p11, _p12}\n    } do\n      %Page{metadata: metadata} =\n        payments_by_customer_name()\n        |> Repo.paginate(\n          cursor_fields: [:id],\n          sort_direction: :asc,\n          limit: 5,\n          include_total_count: true,\n          total_count_limit: 10\n        )\n\n      assert metadata == %Metadata{\n               after: encode_cursor(%{id: p5.id}),\n               before: nil,\n               limit: 5,\n               total_count: 10,\n               total_count_cap_exceeded: true\n             }\n    end\n\n    test \"when custom total_count_primary_key_field\", %{\n      addresses: {_a1, a2, _a3}\n    } do\n      %Page{metadata: metadata} =\n        from(a in Address, select: a)\n        |> Repo.paginate(\n          cursor_fields: [:city],\n          sort_direction: :asc,\n          limit: 2,\n          include_total_count: true,\n          total_count_primary_key_field: :city\n        )\n\n      assert metadata == %Metadata{\n               after: encode_cursor(%{city: a2.city}),\n               before: nil,\n               limit: 2,\n               total_count: 3,\n               total_count_cap_exceeded: false\n             }\n    end\n  end\n\n  test \"per-record cursor generation\", %{\n    payments: {p1, _p2, _p3, _p4, _p5, _p6, p7, _p8, _p9, _p10, _p11, _p12}\n  } do\n    assert Paginator.cursor_for_record(p1, charged_at: :asc, id: :asc) ==\n             encode_cursor(%{charged_at: p1.charged_at, id: p1.id})\n\n    assert Paginator.cursor_for_record(p7, amount: :asc) == encode_cursor(%{amount: p7.amount})\n  end\n\n  test \"per-record cursor generation with custom cursor value function\", %{\n    payments: {p1, _p2, _p3, _p4, _p5, _p6, _p7, _p8, _p9, _p10, _p11, _p12}\n  } do\n    assert Paginator.cursor_for_record(p1, [charged_at: :asc, id: :asc], fn schema, field ->\n             case field do\n               :id -> Map.get(schema, :id)\n               _ -> \"10\"\n             end\n           end) == encode_cursor(%{charged_at: \"10\", id: p1.id})\n  end\n\n  test \"sorts on two different directions with before cursor\", %{\n    payments: {_p1, _p2, _p3, p4, p5, p6, p7, _p8, _p9, _p10, _p11, _p12}\n  } do\n    %Page{entries: entries, metadata: metadata} =\n      payments_by_amount_and_charged_at(:asc, :desc)\n      |> Repo.paginate(\n        cursor_fields: [amount: :asc, charged_at: :desc, id: :asc],\n        before: encode_cursor(%{amount: p7.amount, charged_at: p7.charged_at, id: p7.id}),\n        limit: 3\n      )\n\n    assert to_ids(entries) == to_ids([p6, p4, p5])\n\n    assert metadata == %Metadata{\n             after: encode_cursor(%{amount: p5.amount, charged_at: p5.charged_at, id: p5.id}),\n             before: nil,\n             limit: 3\n           }\n  end\n\n  test \"sorts on two different directions with after cursor\", %{\n    payments: {_p1, _p2, _p3, p4, p5, _p6, p7, p8, _p9, _p10, _p11, _p12}\n  } do\n    %Page{entries: entries, metadata: metadata} =\n      payments_by_amount_and_charged_at(:asc, :desc)\n      |> Repo.paginate(\n        cursor_fields: [amount: :asc, charged_at: :desc, id: :asc],\n        after: encode_cursor(%{amount: p4.amount, charged_at: p4.charged_at, id: p4.id}),\n        limit: 3\n      )\n\n    assert to_ids(entries) == to_ids([p5, p7, p8])\n\n    assert metadata == %Metadata{\n             after: encode_cursor(%{amount: p8.amount, charged_at: p8.charged_at, id: p8.id}),\n             before: encode_cursor(%{amount: p5.amount, charged_at: p5.charged_at, id: p5.id}),\n             limit: 3\n           }\n  end\n\n  test \"sorts on two different directions with before and after cursor\", %{\n    payments: {_p1, _p2, _p3, p4, p5, p6, p7, p8, _p9, _p10, _p11, _p12}\n  } do\n    %Page{entries: entries, metadata: metadata} =\n      payments_by_amount_and_charged_at(:desc, :asc)\n      |> Repo.paginate(\n        cursor_fields: [amount: :desc, charged_at: :asc, id: :asc],\n        after: encode_cursor(%{amount: p8.amount, charged_at: p8.charged_at, id: p8.id}),\n        before: encode_cursor(%{amount: p6.amount, charged_at: p6.charged_at, id: p6.id}),\n        limit: 8\n      )\n\n    assert to_ids(entries) == to_ids([p7, p5, p4])\n\n    assert metadata == %Metadata{\n             after: encode_cursor(%{amount: p4.amount, charged_at: p4.charged_at, id: p4.id}),\n             before: encode_cursor(%{amount: p7.amount, charged_at: p7.charged_at, id: p7.id}),\n             limit: 8\n           }\n  end\n\n  defp to_ids(entries), do: Enum.map(entries, & &1.id)\n\n  defp create_customers_and_payments(_context) do\n    c1 = insert(:customer, %{name: \"Bob\"})\n    c2 = insert(:customer, %{name: \"Alice\"})\n    c3 = insert(:customer, %{name: \"Charlie\"})\n\n    a1 = insert(:address, city: \"London\", customer: c1)\n    a2 = insert(:address, city: \"New York\", customer: c2)\n    a3 = insert(:address, city: \"Tokyo\", customer: c3)\n\n    p1 = insert(:payment, customer: c2, charged_at: days_ago(11))\n    p2 = insert(:payment, customer: c2, charged_at: days_ago(6))\n    p3 = insert(:payment, customer: c2, charged_at: days_ago(8))\n    p4 = insert(:payment, customer: c2, amount: 2, charged_at: days_ago(12))\n\n    p5 = insert(:payment, customer: c1, amount: 3, charged_at: days_ago(13))\n    p6 = insert(:payment, customer: c1, amount: 2, charged_at: days_ago(10))\n    p7 = insert(:payment, customer: c1, amount: 4, charged_at: days_ago(9))\n    p8 = insert(:payment, customer: c1, amount: 5, charged_at: days_ago(4))\n\n    p9 = insert(:payment, customer: c3, charged_at: days_ago(3))\n    p10 = insert(:payment, customer: c3, charged_at: days_ago(7))\n    p11 = insert(:payment, customer: c3, charged_at: days_ago(2))\n    p12 = insert(:payment, customer: c3, charged_at: days_ago(5))\n\n    {:ok,\n     customers: {c1, c2, c3},\n     addresses: {a1, a2, a3},\n     payments: {p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12}}\n  end\n\n  defp payments_by_status(status, direction \\\\ :asc) do\n    from(\n      p in Payment,\n      where: p.status == ^status,\n      order_by: [{^direction, p.charged_at}, {^direction, p.id}],\n      select: p\n    )\n  end\n\n  defp payments_by_amount_and_charged_at(amount_direction, charged_at_direction) do\n    from(\n      p in Payment,\n      order_by: [\n        {^amount_direction, p.amount},\n        {^charged_at_direction, p.charged_at},\n        {:asc, p.id}\n      ],\n      select: p\n    )\n  end\n\n  defp payments_by_charged_at(direction \\\\ :asc) do\n    from(\n      p in Payment,\n      order_by: [{^direction, p.charged_at}, {^direction, p.id}],\n      select: p\n    )\n  end\n\n  defp payments_by_customer_name(payment_id_direction \\\\ :asc, customer_name_direction \\\\ :asc) do\n    from(\n      p in Payment,\n      as: :payments,\n      join: c in assoc(p, :customer),\n      as: :customer,\n      preload: [customer: c],\n      select: p,\n      order_by: [\n        {^customer_name_direction, c.name},\n        {^payment_id_direction, p.id}\n      ]\n    )\n  end\n\n  defp payments_by_address_city(payment_id_direction \\\\ :asc, address_city_direction \\\\ :asc) do\n    from(\n      p in Payment,\n      as: :payments,\n      join: c in assoc(p, :customer),\n      as: :customer,\n      join: a in assoc(c, :address),\n      as: :address,\n      preload: [customer: {c, address: a}],\n      select: p,\n      order_by: [\n        {^address_city_direction, a.city},\n        {^payment_id_direction, p.id}\n      ]\n    )\n  end\n\n  defp customer_payments_by_amount(customer, direction \\\\ :asc) do\n    from(\n      p in Payment,\n      where: p.customer_id == ^customer.id,\n      order_by: [{^direction, p.amount}, {^direction, p.charged_at}, {^direction, p.id}]\n    )\n  end\n\n  defp encode_cursor(value) do\n    Cursor.encode(value)\n  end\n\n  defp encode_legacy_cursor(value) when is_list(value) do\n    value\n    |> :erlang.term_to_binary()\n    |> Base.url_encode64()\n  end\n\n  defp days_ago(days) do\n    DT.add!(DateTime.utc_now(), -(days * 86400))\n  end\nend\n"], "fixing_code": ["# Paginator\n\n[![Build Status](https://travis-ci.org/duffelhq/paginator.svg?branch=master)](https://travis-ci.org/duffelhq/paginator)\n[![Inline docs](http://inch-ci.org/github/duffelhq/paginator.svg)](http://inch-ci.org/github/duffelhq/paginator)\n\n[Cursor based pagination](http://use-the-index-luke.com/no-offset) for Elixir [Ecto](https://github.com/elixir-ecto/ecto).\n\n[Documentation](https://hexdocs.pm/paginator)\n\n## Why?\n\nThere are several ways to implement pagination in a project and they all have pros and cons depending on your situation.\n\n### Limit-offset\n\nThis is the easiest method to use and implement: you just have to set `LIMIT` and `OFFSET` on your queries and the\ndatabase will return records based on this two parameters. Unfortunately, it has two major drawbacks:\n\n* Inconsistent results: if the dataset changes while you are querying, the results in the page will shift and your user\nmight end seeing records they have already seen and missing new ones.\n\n* Inefficiency: `OFFSET N` instructs the database to skip the first N results of a query. However, the database must still\nfetch these rows from disk and order them before it can returns the ones requested. If the dataset you are querying is\nlarge this will result in significant slowdowns.\n\n### Cursor-based (a.k.a keyset pagination)\n\nThis method relies on opaque cursor to figure out where to start selecting records. It is more performant than\n`LIMIT-OFFSET` because it can filter records without traversing all of them.\n\nIt's also consistent, any insertions/deletions before the current page will leave results unaffected.\n\nIt has some limitations though: for instance you can't jump directly to a specific page. This may\nnot be an issue for an API or if you use infinite scrolling on your website.\n\n### Learn more\n\n* http://use-the-index-luke.com/no-offset\n* http://use-the-index-luke.com/sql/partial-results/fetch-next-page\n* https://www.citusdata.com/blog/2016/03/30/five-ways-to-paginate/\n* https://developer.twitter.com/en/docs/tweets/timelines/guides/working-with-timelines\n\n## Getting started\n\n```elixir\ndefmodule MyApp.Repo do\n  use Ecto.Repo,\n    otp_app: :my_app,\n    adapter: Ecto.Adapters.Postgres\n\n  use Paginator\nend\n\nquery = from(p in Post, order_by: [asc: p.inserted_at, asc: p.id])\n\npage = MyApp.Repo.paginate(query, cursor_fields: [:inserted_at, :id], limit: 50)\n\n# `page.entries` contains all the entries for this page.\n# `page.metadata` contains the metadata associated with this page (cursors, limit, total count)\n```\n\n## Install\n\nAdd `paginator` to your list of dependencies in `mix.exs`:\n\n```elixir\ndef deps do\n  [{:paginator, \"~> 0.6\"}]\nend\n```\n\n## Usage\n\n1. Add `Paginator` to your repo.\n\n    ```elixir\n    defmodule MyApp.Repo do\n      use Ecto.Repo,\n        otp_app: :my_app,\n        adapter: Ecto.Adapters.Postgres\n\n      use Paginator\n    end\n    ```\n\n2. Use the `paginate` function to paginate your queries.\n\n    ```elixir\n    query = from(p in Post, order_by: [asc: p.inserted_at, asc: p.id])\n\n    # return the first 50 posts\n    %{entries: entries, metadata: metadata} = Repo.paginate(query, cursor_fields: [:inserted_at, :id], limit: 50)\n\n    # assign the `after` cursor to a variable\n    cursor_after = metadata.after\n\n    # return the next 50 posts\n    %{entries: entries, metadata: metadata} = Repo.paginate(query, after: cursor_after, cursor_fields: [{inserted_at: :asc}, {:id, :asc}], limit: 50)\n\n    # assign the `before` cursor to a variable\n    cursor_before = metadata.before\n\n    # return the previous 50 posts (if no post was created in between it should be the same list as in our first call to `paginate`)\n    %{entries: entries, metadata: metadata} = Repo.paginate(query, before: cursor_before, cursor_fields: [:inserted_at, :id], limit: 50)\n\n    # return total count\n    # NOTE: this will issue a separate `SELECT COUNT(*) FROM table` query to the database.\n    %{entries: entries, metadata: metadata} = Repo.paginate(query, include_total_count: true, cursor_fields: [:inserted_at, :id], limit: 50)\n\n    IO.puts \"total count: #{metadata.total_count}\"\n    ```\n## Security Considerations\n\n`Repo.paginate/4 will throw an ArgumentError should it detect an executable term in the cursor parameters passed to it (`before`, `after`).\nThis is done to protect you from potential side-effects of malicious user input, see [paginator_test.exs](https://github.com/duffelhq/paginator/blob/master/test/paginator_test.exs#L820).\n\n## Indexes\n\nIf you want to reap all the benefits of this method it is better that you create indexes on the columns you are using as\ncursor fields.\n\n### Example\n\n```elixir\n# If your cursor fields are: [:inserted_at, :id]\n# Add the following in a migration\n\ncreate index(\"posts\", [:inserted_at, :id])\n```\n\n## Caveats\n\n* This method requires a deterministic sort order. If the columns you are currently using for sorting don't match that\ndefinition, just add any unique column and extend your index accordingly.\n* You need to add order_by clauses yourself before passing your query to `paginate/2`. In the future we might do that\nfor you automatically based on the fields specified in `:cursor_fields`.\n* There is an outstanding issue where Postgrex fails to properly builds the query if it includes custom PostgreSQL types.\n* This library has only be tested with PostgreSQL.\n\n## Documentation\n\nDocumentation is written into the library, you will find it in the source code, accessible from `iex` and of course, it\nall gets published to [hexdocs](http://hexdocs.pm/paginator).\n\n## Contributing\n\n### Running tests\n\nClone the repo and fetch its dependencies:\n\n```\n$ git clone https://github.com/duffelhq/paginator.git\n$ cd paginator\n$ mix deps.get\n$ mix test\n```\n\n### Building docs\n\n```\n$ mix docs\n```\n\n## LICENSE\n\nSee [LICENSE](https://github.com/duffelhq/paginator/blob/master/LICENSE.txt)\n", "defmodule Paginator.Cursor do\n  @moduledoc false\n\n  def decode(nil), do: nil\n\n  def decode(encoded_cursor) do\n    encoded_cursor\n    |> Base.url_decode64!()\n    |> Plug.Crypto.non_executable_binary_to_term([:safe])\n  end\n\n  def encode(values) when is_map(values) do\n    values\n    |> :erlang.term_to_binary()\n    |> Base.url_encode64()\n  end\nend\n", "defmodule Paginator.Mixfile do\n  use Mix.Project\n\n  @version \"0.6.0\"\n\n  def project do\n    [\n      app: :paginator,\n      version: @version,\n      elixir: \"~> 1.4\",\n      elixirc_paths: elixirc_paths(Mix.env()),\n      build_embedded: Mix.env() == :prod,\n      start_permanent: Mix.env() == :prod,\n      deps: deps(),\n\n      # Hex\n      description: description(),\n      package: package(),\n\n      # Docs\n      name: \"Paginator\",\n      source_url: \"https://github.com/duffelhq/paginator\",\n      homepage_url: \"https://github.com/duffelhq/paginator\",\n      docs: [\n        source_ref: \"v#{@version}\",\n        main: \"Paginator\",\n        canonical: \"http://hexdocs.pm/paginator\",\n        source_url: \"https://github.com/duffelhq/paginator\"\n      ]\n    ]\n  end\n\n  def application do\n    [extra_applications: [:logger]]\n  end\n\n  defp elixirc_paths(:test), do: [\"lib\", \"test/support\"]\n  defp elixirc_paths(_), do: [\"lib\"]\n\n  defp deps do\n    [\n      {:calendar, \"~> 0.17.4\", only: :test},\n      {:ecto, \"~> 3.0\"},\n      {:ecto_sql, \"~> 3.0\"},\n      {:ex_doc, \"~> 0.18\", only: :dev, runtime: false},\n      {:ex_machina, \"~> 2.1\", only: :test},\n      {:inch_ex, \"~> 1.0\", only: [:dev, :test]},\n      {:postgrex, \"~> 0.13\", optional: true},\n      {:plug_crypto, \"~> 1.1.2\"}\n    ]\n  end\n\n  defp description do\n    \"\"\"\n    Cursor based pagination for Elixir Ecto.\n    \"\"\"\n  end\n\n  defp package do\n    [\n      maintainers: [\"Steve Domin\"],\n      licenses: [\"MIT\"],\n      links: %{\"GitHub\" => \"https://github.com/duffelhq/paginator\"}\n    ]\n  end\nend\n", "%{\n  \"calendar\": {:hex, :calendar, \"0.17.4\", \"22c5e8d98a4db9494396e5727108dffb820ee0d18fed4b0aa8ab76e4f5bc32f1\", [:mix], [{:tzdata, \"~> 0.5.8 or ~> 0.1.201603\", [hex: :tzdata, repo: \"hexpm\", optional: false]}], \"hexpm\", \"5a060b05a869a4acfc7678e3521143b39165a78ee2ccd69850a6b92a526af58a\"},\n  \"certifi\": {:hex, :certifi, \"2.3.1\", \"d0f424232390bf47d82da8478022301c561cf6445b5b5fb6a84d49a9e76d2639\", [:rebar3], [{:parse_trans, \"3.2.0\", [hex: :parse_trans, repo: \"hexpm\", optional: false]}], \"hexpm\", \"e12d667d042c11d130594bae2b0097e63836fe8b1e6d6b2cc48f8bb7a2cf7d68\"},\n  \"connection\": {:hex, :connection, \"1.0.4\", \"a1cae72211f0eef17705aaededacac3eb30e6625b04a6117c1b2db6ace7d5976\", [:mix], [], \"hexpm\", \"4a0850c9be22a43af9920a71ab17c051f5f7d45c209e40269a1938832510e4d9\"},\n  \"db_connection\": {:hex, :db_connection, \"2.0.3\", \"b4e8aa43c100e16f122ccd6798cd51c48c79fd391c39d411f42b3cd765daccb0\", [:mix], [{:connection, \"~> 1.0.2\", [hex: :connection, repo: \"hexpm\", optional: false]}], \"hexpm\", \"1e123d79599809ca3775fd71b40574f3592a2acd85d3c41d49f5843426021f9b\"},\n  \"decimal\": {:hex, :decimal, \"1.6.0\", \"bfd84d90ff966e1f5d4370bdd3943432d8f65f07d3bab48001aebd7030590dcc\", [:mix], [], \"hexpm\", \"bbd124e240e3ff40f407d50fced3736049e72a73d547f69201484d3a624ab569\"},\n  \"earmark\": {:hex, :earmark, \"1.3.1\", \"73812f447f7a42358d3ba79283cfa3075a7580a3a2ed457616d6517ac3738cb9\", [:mix], [], \"hexpm\", \"000aaeff08919e95e7aea13e4af7b2b9734577b3e6a7c50ee31ee88cab6ec4fb\"},\n  \"ecto\": {:hex, :ecto, \"3.0.6\", \"d33ab5b3f7553a41507d4b0ad5bf192d533119c4ad08f3a5d63d85aa12117dc9\", [:mix], [{:decimal, \"~> 1.6\", [hex: :decimal, repo: \"hexpm\", optional: false]}, {:jason, \"~> 1.0\", [hex: :jason, repo: \"hexpm\", optional: true]}, {:poison, \"~> 2.2 or ~> 3.0\", [hex: :poison, repo: \"hexpm\", optional: true]}], \"hexpm\", \"0e3761e75c87affe9f5e7735d285185c2942ccb0808ca82fb35963f55c31c7b5\"},\n  \"ecto_sql\": {:hex, :ecto_sql, \"3.0.4\", \"e7a0feb0b2484b90981c56d5cd03c52122c1c31ded0b95ed213b7c5c07ae6737\", [:mix], [{:db_connection, \"~> 2.0\", [hex: :db_connection, repo: \"hexpm\", optional: false]}, {:ecto, \"~> 3.0.6\", [hex: :ecto, repo: \"hexpm\", optional: false]}, {:mariaex, \"~> 0.9.1\", [hex: :mariaex, repo: \"hexpm\", optional: true]}, {:postgrex, \"~> 0.14.0\", [hex: :postgrex, repo: \"hexpm\", optional: true]}, {:telemetry, \"~> 0.3.0\", [hex: :telemetry, repo: \"hexpm\", optional: false]}], \"hexpm\", \"7b49acc82d34fc1e020dbf8bebaff8f1dff40b550d778743943beba4190e4db5\"},\n  \"ex_doc\": {:hex, :ex_doc, \"0.19.3\", \"3c7b0f02851f5fc13b040e8e925051452e41248f685e40250d7e40b07b9f8c10\", [:mix], [{:earmark, \"~> 1.2\", [hex: :earmark, repo: \"hexpm\", optional: false]}, {:makeup_elixir, \"~> 0.10\", [hex: :makeup_elixir, repo: \"hexpm\", optional: false]}], \"hexpm\", \"0e11d67e662142fc3945b0ee410c73c8c956717fbeae4ad954b418747c734973\"},\n  \"ex_machina\": {:hex, :ex_machina, \"2.2.2\", \"d84217a6fb7840ff771d2561b8aa6d74a0d8968e4b10ecc0d7e9890dc8fb1c6a\", [:mix], [{:ecto, \"~> 2.2 or ~> 3.0\", [hex: :ecto, repo: \"hexpm\", optional: true]}, {:ecto_sql, \"~> 3.0\", [hex: :ecto_sql, repo: \"hexpm\", optional: true]}], \"hexpm\", \"0d718f9b2dc1b952eab6223fd5fbe1698be7b6012a5717c66efe8a7920c43ac9\"},\n  \"hackney\": {:hex, :hackney, \"1.13.0\", \"24edc8cd2b28e1c652593833862435c80661834f6c9344e84b6a2255e7aeef03\", [:rebar3], [{:certifi, \"2.3.1\", [hex: :certifi, repo: \"hexpm\", optional: false]}, {:idna, \"5.1.2\", [hex: :idna, repo: \"hexpm\", optional: false]}, {:metrics, \"1.0.1\", [hex: :metrics, repo: \"hexpm\", optional: false]}, {:mimerl, \"1.0.2\", [hex: :mimerl, repo: \"hexpm\", optional: false]}, {:ssl_verify_fun, \"1.1.1\", [hex: :ssl_verify_fun, repo: \"hexpm\", optional: false]}], \"hexpm\", \"4d605d33dd07ee1b82b105033cccb02379515105fceb1850746591814b00c205\"},\n  \"idna\": {:hex, :idna, \"5.1.2\", \"e21cb58a09f0228a9e0b95eaa1217f1bcfc31a1aaa6e1fdf2f53a33f7dbd9494\", [:rebar3], [{:unicode_util_compat, \"0.3.1\", [hex: :unicode_util_compat, repo: \"hexpm\", optional: false]}], \"hexpm\", \"8fddb3aec4692c71647d67de72536254bce9069851754e370a99f2aae69fbdf4\"},\n  \"inch_ex\": {:hex, :inch_ex, \"1.0.1\", \"1f0af1a83cec8e56f6fc91738a09c838e858db3d78ef5f2ec040fe4d5a62dabf\", [:mix], [{:poison, \"~> 1.5 or ~> 2.0 or ~> 3.0\", [hex: :poison, repo: \"hexpm\", optional: false]}], \"hexpm\", \"08fd8a9205d3e1aefad9d7cb2a7f6b346e4a3e6ff09e139f6ec978f3a479ba14\"},\n  \"makeup\": {:hex, :makeup, \"0.8.0\", \"9cf32aea71c7fe0a4b2e9246c2c4978f9070257e5c9ce6d4a28ec450a839b55f\", [:mix], [{:nimble_parsec, \"~> 0.5.0\", [hex: :nimble_parsec, repo: \"hexpm\", optional: false]}], \"hexpm\", \"5fbc8e549aa9afeea2847c0769e3970537ed302f93a23ac612602e805d9d1e7f\"},\n  \"makeup_elixir\": {:hex, :makeup_elixir, \"0.13.0\", \"be7a477997dcac2e48a9d695ec730b2d22418292675c75aa2d34ba0909dcdeda\", [:mix], [{:makeup, \"~> 0.8\", [hex: :makeup, repo: \"hexpm\", optional: false]}], \"hexpm\", \"adf0218695e22caeda2820eaba703fa46c91820d53813a2223413da3ef4ba515\"},\n  \"metrics\": {:hex, :metrics, \"1.0.1\", \"25f094dea2cda98213cecc3aeff09e940299d950904393b2a29d191c346a8486\", [:rebar3], [], \"hexpm\", \"69b09adddc4f74a40716ae54d140f93beb0fb8978d8636eaded0c31b6f099f16\"},\n  \"mimerl\": {:hex, :mimerl, \"1.0.2\", \"993f9b0e084083405ed8252b99460c4f0563e41729ab42d9074fd5e52439be88\", [:rebar3], [], \"hexpm\", \"7a4c8e1115a2732a67d7624e28cf6c9f30c66711a9e92928e745c255887ba465\"},\n  \"nimble_parsec\": {:hex, :nimble_parsec, \"0.5.0\", \"90e2eca3d0266e5c53f8fbe0079694740b9c91b6747f2b7e3c5d21966bba8300\", [:mix], [], \"hexpm\", \"5c040b8469c1ff1b10093d3186e2e10dbe483cd73d79ec017993fb3985b8a9b3\"},\n  \"parse_trans\": {:hex, :parse_trans, \"3.2.0\", \"2adfa4daf80c14dc36f522cf190eb5c4ee3e28008fc6394397c16f62a26258c2\", [:rebar3], [], \"hexpm\", \"578b1d484720749499db5654091ddac818ea0b6d568f2c99c562d2a6dd4aa117\"},\n  \"plug_crypto\": {:hex, :plug_crypto, \"1.1.2\", \"bdd187572cc26dbd95b87136290425f2b580a116d3fb1f564216918c9730d227\", [:mix], [], \"hexpm\", \"6b8b608f895b6ffcfad49c37c7883e8df98ae19c6a28113b02aa1e9c5b22d6b5\"},\n  \"poison\": {:hex, :poison, \"3.1.0\", \"d9eb636610e096f86f25d9a46f35a9facac35609a7591b3be3326e99a0484665\", [:mix], [], \"hexpm\", \"fec8660eb7733ee4117b85f55799fd3833eb769a6df71ccf8903e8dc5447cfce\"},\n  \"poolboy\": {:hex, :poolboy, \"1.5.1\", \"6b46163901cfd0a1b43d692657ed9d7e599853b3b21b95ae5ae0a777cf9b6ca8\", [:rebar], [], \"hexpm\"},\n  \"postgrex\": {:hex, :postgrex, \"0.14.1\", \"63247d4a5ad6b9de57a0bac5d807e1c32d41e39c04b8a4156a26c63bcd8a2e49\", [:mix], [{:connection, \"~> 1.0\", [hex: :connection, repo: \"hexpm\", optional: false]}, {:db_connection, \"~> 2.0\", [hex: :db_connection, repo: \"hexpm\", optional: false]}, {:decimal, \"~> 1.5\", [hex: :decimal, repo: \"hexpm\", optional: false]}, {:jason, \"~> 1.0\", [hex: :jason, repo: \"hexpm\", optional: true]}], \"hexpm\", \"a20f189bdd5a219c484818fde18e09ace20cd15fe630a828fde70bd6efdeb23b\"},\n  \"ssl_verify_fun\": {:hex, :ssl_verify_fun, \"1.1.1\", \"28a4d65b7f59893bc2c7de786dec1e1555bd742d336043fe644ae956c3497fbe\", [:make, :rebar], [], \"hexpm\", \"4f8805eb5c8a939cf2359367cb651a3180b27dfb48444846be2613d79355d65e\"},\n  \"telemetry\": {:hex, :telemetry, \"0.3.0\", \"099a7f3ce31e4780f971b4630a3c22ec66d22208bc090fe33a2a3a6a67754a73\", [:rebar3], [], \"hexpm\", \"63d9f37d319ff331a51f6221310deb5aac8ea3dcf5e0369d689121b5e52f72d4\"},\n  \"tzdata\": {:hex, :tzdata, \"0.5.17\", \"50793e3d85af49736701da1a040c415c97dc1caf6464112fd9bd18f425d3053b\", [:mix], [{:hackney, \"~> 1.0\", [hex: :hackney, repo: \"hexpm\", optional: false]}], \"hexpm\", \"35407ed377f7c07ce47ac20a437ca0d97d950086413228a66171193b03d574ed\"},\n  \"unicode_util_compat\": {:hex, :unicode_util_compat, \"0.3.1\", \"a1f612a7b512638634a603c8f401892afbf99b8ce93a45041f8aaca99cadb85e\", [:rebar3], [], \"hexpm\", \"da1d9bef8a092cc7e1e51f1298037a5ddfb0f657fe862dfe7ba4c5807b551c29\"},\n}\n", "defmodule PaginatorTest do\n  use Paginator.DataCase\n  doctest Paginator\n\n  alias Calendar.DateTime, as: DT\n\n  alias Paginator.Cursor\n\n  setup :create_customers_and_payments\n\n  test \"paginates forward\", %{\n    payments: {p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12}\n  } do\n    opts = [cursor_fields: [:charged_at, :id], sort_direction: :asc, limit: 4]\n\n    page = payments_by_charged_at() |> Repo.paginate(opts)\n    assert to_ids(page.entries) == to_ids([p5, p4, p1, p6])\n    assert page.metadata.after == encode_cursor(%{charged_at: p6.charged_at, id: p6.id})\n\n    page = payments_by_charged_at() |> Repo.paginate(opts ++ [after: page.metadata.after])\n    assert to_ids(page.entries) == to_ids([p7, p3, p10, p2])\n    assert page.metadata.after == encode_cursor(%{charged_at: p2.charged_at, id: p2.id})\n\n    page = payments_by_charged_at() |> Repo.paginate(opts ++ [after: page.metadata.after])\n    assert to_ids(page.entries) == to_ids([p12, p8, p9, p11])\n    assert page.metadata.after == nil\n  end\n\n  test \"paginates forward with legacy cursor\", %{\n    payments: {p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12}\n  } do\n    opts = [cursor_fields: [:charged_at, :id], sort_direction: :asc, limit: 4]\n\n    page = payments_by_charged_at() |> Repo.paginate(opts)\n    assert to_ids(page.entries) == to_ids([p5, p4, p1, p6])\n    assert %{charged_at: charged_at, id: id} = Cursor.decode(page.metadata.after)\n    assert charged_at == p6.charged_at\n    assert id == p6.id\n\n    legacy_cursor = encode_legacy_cursor([charged_at, id])\n\n    page = payments_by_charged_at() |> Repo.paginate(opts ++ [after: legacy_cursor])\n    assert to_ids(page.entries) == to_ids([p7, p3, p10, p2])\n    assert %{charged_at: charged_at, id: id} = Cursor.decode(page.metadata.after)\n    assert charged_at == p2.charged_at\n    assert id == p2.id\n\n    legacy_cursor = encode_legacy_cursor([charged_at, id])\n\n    page = payments_by_charged_at() |> Repo.paginate(opts ++ [after: legacy_cursor])\n    assert to_ids(page.entries) == to_ids([p12, p8, p9, p11])\n    assert page.metadata.after == nil\n  end\n\n  test \"paginates backward\", %{\n    payments: {p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12}\n  } do\n    opts = [cursor_fields: [:charged_at, :id], sort_direction: :asc, limit: 4]\n\n    page =\n      payments_by_charged_at()\n      |> Repo.paginate(opts ++ [before: encode_cursor(%{charged_at: p11.charged_at, id: p11.id})])\n\n    assert to_ids(page.entries) == to_ids([p2, p12, p8, p9])\n    assert page.metadata.before == encode_cursor(%{charged_at: p2.charged_at, id: p2.id})\n\n    page = payments_by_charged_at() |> Repo.paginate(opts ++ [before: page.metadata.before])\n    assert to_ids(page.entries) == to_ids([p6, p7, p3, p10])\n    assert page.metadata.before == encode_cursor(%{charged_at: p6.charged_at, id: p6.id})\n\n    page = payments_by_charged_at() |> Repo.paginate(opts ++ [before: page.metadata.before])\n    assert to_ids(page.entries) == to_ids([p5, p4, p1])\n    assert page.metadata.after == encode_cursor(%{charged_at: p1.charged_at, id: p1.id})\n    assert page.metadata.before == nil\n  end\n\n  test \"returns an empty page when there are no results\" do\n    page =\n      payments_by_status(\"failed\")\n      |> Repo.paginate(cursor_fields: [:charged_at, :id], limit: 10)\n\n    assert page.entries == []\n    assert page.metadata.after == nil\n    assert page.metadata.before == nil\n  end\n\n  describe \"paginate a collection of payments, sorting by charged_at\" do\n    test \"sorts ascending without cursors\", %{\n      payments: {p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12}\n    } do\n      %Page{entries: entries, metadata: metadata} =\n        payments_by_charged_at()\n        |> Repo.paginate(cursor_fields: [:charged_at, :id], sort_direction: :asc, limit: 50)\n\n      assert to_ids(entries) == to_ids([p5, p4, p1, p6, p7, p3, p10, p2, p12, p8, p9, p11])\n      assert metadata == %Metadata{after: nil, before: nil, limit: 50}\n    end\n\n    test \"sorts ascending with before cursor\", %{\n      payments: {p1, p2, p3, _p4, _p5, p6, p7, p8, p9, p10, _p11, p12}\n    } do\n      %Page{entries: entries, metadata: metadata} =\n        payments_by_charged_at()\n        |> Repo.paginate(\n          cursor_fields: [:charged_at, :id],\n          sort_direction: :asc,\n          before: encode_cursor(%{charged_at: p9.charged_at, id: p9.id}),\n          limit: 8\n        )\n\n      assert to_ids(entries) == to_ids([p1, p6, p7, p3, p10, p2, p12, p8])\n\n      assert metadata == %Metadata{\n               after: encode_cursor(%{charged_at: p8.charged_at, id: p8.id}),\n               before: encode_cursor(%{charged_at: p1.charged_at, id: p1.id}),\n               limit: 8\n             }\n    end\n\n    test \"sorts ascending with after cursor\", %{\n      payments: {_p1, p2, p3, _p4, _p5, _p6, _p7, p8, p9, p10, p11, p12}\n    } do\n      %Page{entries: entries, metadata: metadata} =\n        payments_by_charged_at()\n        |> Repo.paginate(\n          cursor_fields: [:charged_at, :id],\n          sort_direction: :asc,\n          after: encode_cursor(%{charged_at: p3.charged_at, id: p3.id}),\n          limit: 8\n        )\n\n      assert to_ids(entries) == to_ids([p10, p2, p12, p8, p9, p11])\n\n      assert metadata == %Metadata{\n               after: nil,\n               before: encode_cursor(%{charged_at: p10.charged_at, id: p10.id}),\n               limit: 8\n             }\n    end\n\n    test \"sorts ascending with before and after cursor\", %{\n      payments: {_p1, p2, p3, _p4, _p5, _p6, _p7, p8, _p9, p10, _p11, p12}\n    } do\n      %Page{entries: entries, metadata: metadata} =\n        payments_by_charged_at()\n        |> Repo.paginate(\n          cursor_fields: [:charged_at, :id],\n          sort_direction: :asc,\n          after: encode_cursor(%{charged_at: p3.charged_at, id: p3.id}),\n          before: encode_cursor(%{charged_at: p8.charged_at, id: p8.id}),\n          limit: 8\n        )\n\n      assert to_ids(entries) == to_ids([p10, p2, p12])\n\n      assert metadata == %Metadata{\n               after: encode_cursor(%{charged_at: p12.charged_at, id: p12.id}),\n               before: encode_cursor(%{charged_at: p10.charged_at, id: p10.id}),\n               limit: 8\n             }\n    end\n\n    test \"sorts descending without cursors\", %{\n      payments: {p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12}\n    } do\n      %Page{entries: entries, metadata: metadata} =\n        payments_by_charged_at(:desc)\n        |> Repo.paginate(cursor_fields: [:charged_at, :id], sort_direction: :desc, limit: 50)\n\n      assert to_ids(entries) == to_ids([p11, p9, p8, p12, p2, p10, p3, p7, p6, p1, p4, p5])\n      assert metadata == %Metadata{after: nil, before: nil, limit: 50}\n    end\n\n    test \"sorts descending with before cursor\", %{\n      payments: {_p1, _p2, _p3, _p4, _p5, _p6, _p7, _p8, p9, _p10, p11, _p12}\n    } do\n      %Page{entries: entries, metadata: metadata} =\n        payments_by_charged_at(:desc)\n        |> Repo.paginate(\n          cursor_fields: [:charged_at, :id],\n          sort_direction: :desc,\n          before: encode_cursor(%{charged_at: p9.charged_at, id: p9.id}),\n          limit: 8\n        )\n\n      assert to_ids(entries) == to_ids([p11])\n\n      assert metadata == %Metadata{\n               after: encode_cursor(%{charged_at: p11.charged_at, id: p11.id}),\n               before: nil,\n               limit: 8\n             }\n    end\n\n    test \"sorts descending with after cursor\", %{\n      payments: {p1, p2, p3, _p4, _p5, p6, p7, p8, p9, p10, _p11, p12}\n    } do\n      %Page{entries: entries, metadata: metadata} =\n        payments_by_charged_at(:desc)\n        |> Repo.paginate(\n          cursor_fields: [:charged_at, :id],\n          sort_direction: :desc,\n          after: encode_cursor(%{charged_at: p9.charged_at, id: p9.id}),\n          limit: 8\n        )\n\n      assert to_ids(entries) == to_ids([p8, p12, p2, p10, p3, p7, p6, p1])\n\n      assert metadata == %Metadata{\n               after: encode_cursor(%{charged_at: p1.charged_at, id: p1.id}),\n               before: encode_cursor(%{charged_at: p8.charged_at, id: p8.id}),\n               limit: 8\n             }\n    end\n\n    test \"sorts descending with before and after cursor\", %{\n      payments: {_p1, p2, p3, _p4, _p5, _p6, _p7, p8, p9, p10, _p11, p12}\n    } do\n      %Page{entries: entries, metadata: metadata} =\n        payments_by_charged_at(:desc)\n        |> Repo.paginate(\n          cursor_fields: [:charged_at, :id],\n          sort_direction: :desc,\n          after: encode_cursor(%{charged_at: p9.charged_at, id: p9.id}),\n          before: encode_cursor(%{charged_at: p3.charged_at, id: p3.id}),\n          limit: 8\n        )\n\n      assert to_ids(entries) == to_ids([p8, p12, p2, p10])\n\n      assert metadata == %Metadata{\n               after: encode_cursor(%{charged_at: p10.charged_at, id: p10.id}),\n               before: encode_cursor(%{charged_at: p8.charged_at, id: p8.id}),\n               limit: 8\n             }\n    end\n\n    test \"sorts ascending with before cursor at beginning of collection\", %{\n      payments: {_p1, _p2, _p3, _p4, p5, _p6, _p7, _p8, _p9, _p10, _p11, _p12}\n    } do\n      %Page{entries: entries, metadata: metadata} =\n        payments_by_charged_at()\n        |> Repo.paginate(\n          cursor_fields: [:charged_at, :id],\n          sort_direction: :asc,\n          before: encode_cursor(%{charged_at: p5.charged_at, id: p5.id}),\n          limit: 8\n        )\n\n      assert to_ids(entries) == to_ids([])\n      assert metadata == %Metadata{after: nil, before: nil, limit: 8}\n    end\n\n    test \"sorts ascending with after cursor at end of collection\", %{\n      payments: {_p1, _p2, _p3, _p4, _p5, _p6, _p7, _p8, _p9, _p10, p11, _p12}\n    } do\n      %Page{entries: entries, metadata: metadata} =\n        payments_by_charged_at()\n        |> Repo.paginate(\n          cursor_fields: [:charged_at, :id],\n          sort_direction: :asc,\n          after: encode_cursor(%{charged_at: p11.charged_at, id: p11.id}),\n          limit: 8\n        )\n\n      assert to_ids(entries) == to_ids([])\n      assert metadata == %Metadata{after: nil, before: nil, limit: 8}\n    end\n\n    test \"sorts descending with before cursor at beginning of collection\", %{\n      payments: {_p1, _p2, _p3, _p4, _p5, _p6, _p7, _p8, _p9, _p10, p11, _p12}\n    } do\n      %Page{entries: entries, metadata: metadata} =\n        payments_by_charged_at(:desc)\n        |> Repo.paginate(\n          cursor_fields: [:charged_at, :id],\n          sort_direction: :desc,\n          before: encode_cursor(%{charged_at: p11.charged_at, id: p11.id}),\n          limit: 8\n        )\n\n      assert to_ids(entries) == to_ids([])\n      assert metadata == %Metadata{after: nil, before: nil, limit: 8}\n    end\n\n    test \"sorts descending with after cursor at end of collection\", %{\n      payments: {_p1, _p2, _p3, _p4, p5, _p6, _p7, _p8, _p9, _p10, _p11, _p12}\n    } do\n      %Page{entries: entries, metadata: metadata} =\n        payments_by_charged_at(:desc)\n        |> Repo.paginate(\n          cursor_fields: [:charged_at, :id],\n          sort_direction: :desc,\n          after: encode_cursor(%{charged_at: p5.charged_at, id: p5.id}),\n          limit: 8\n        )\n\n      assert to_ids(entries) == to_ids([])\n      assert metadata == %Metadata{after: nil, before: nil, limit: 8}\n    end\n  end\n\n  describe \"paginate a collection of payments with customer filter, sorting by amount, charged_at\" do\n    test \"multiple cursor_fields with pre-existing where filter in query\", %{\n      customers: {c1, _c2, _c3},\n      payments: {_p1, _p2, _p3, _p4, p5, p6, p7, p8, _p9, _p10, _p11, _p12}\n    } do\n      %Page{entries: entries, metadata: _metadata} =\n        customer_payments_by_amount(c1)\n        |> Repo.paginate(cursor_fields: [:amount, :charged_at, :id], limit: 50)\n\n      assert to_ids(entries) == to_ids([p6, p5, p7, p8])\n    end\n\n    test \"before cursor with multiple cursor_fields and pre-existing where filter in query\", %{\n      customers: {c1, _c2, _c3},\n      payments: {_p1, _p2, _p3, _p4, _p5, p6, _p7, _p8, _p9, _p10, _p11, _p12}\n    } do\n      assert %Page{entries: [], metadata: _metadata} =\n               customer_payments_by_amount(c1)\n               |> Repo.paginate(\n                 cursor_fields: [:amount, :charged_at, :id],\n                 before:\n                   encode_cursor(%{amount: p6.amount, charged_at: p6.charged_at, id: p6.id}),\n                 limit: 1\n               )\n    end\n  end\n\n  describe \"paginate a collection of payments, sorting by customer name\" do\n    test \"raises error when binding not found\", %{\n      payments: {_p1, _p2, _p3, _p4, _p5, _p6, _p7, _p8, _p9, _p10, p11, _p12}\n    } do\n      assert_raise ArgumentError,\n                   \"Could not find binding `bogus_binding` in query aliases: %{customer: 1, payments: 0}\",\n                   fn ->\n                     %Page{} =\n                       payments_by_customer_name()\n                       |> Repo.paginate(\n                         cursor_fields: [\n                           {{:bogus_binding, :id}, :asc},\n                           {{:bogus_binding, :name}, :asc}\n                         ],\n                         limit: 50,\n                         before:\n                           encode_cursor(%{\n                             {:bogus_binding, :id} => p11.id,\n                             {:bogus_binding, :name} => p11.customer.name\n                           })\n                       )\n                   end\n    end\n\n    test \"sorts with mixed bindingless, bound columns\", %{\n      payments: {_p1, _p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, _p12}\n    } do\n      %Page{entries: entries, metadata: metadata} =\n        payments_by_customer_name()\n        |> Repo.paginate(\n          cursor_fields: [{:id, :asc}, {{:customer, :name}, :asc}],\n          before: encode_cursor(%{:id => p11.id, {:customer, :name} => p11.customer.name}),\n          limit: 8\n        )\n\n      assert to_ids(entries) == to_ids([p3, p4, p5, p6, p7, p8, p9, p10])\n\n      assert metadata == %Metadata{\n               after: encode_cursor(%{:id => p10.id, {:customer, :name} => p10.customer.name}),\n               before: encode_cursor(%{:id => p3.id, {:customer, :name} => p3.customer.name}),\n               limit: 8\n             }\n    end\n\n    test \"sorts with mixed columns without direction and bound columns\", %{\n      payments: {_p1, _p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, _p12}\n    } do\n      %Page{entries: entries, metadata: metadata} =\n        payments_by_customer_name()\n        |> Repo.paginate(\n          cursor_fields: [:id, {{:customer, :name}, :asc}],\n          before: encode_cursor(%{:id => p11.id, {:customer, :name} => p11.customer.name}),\n          limit: 8\n        )\n\n      assert to_ids(entries) == to_ids([p3, p4, p5, p6, p7, p8, p9, p10])\n\n      assert metadata == %Metadata{\n               after: encode_cursor(%{:id => p10.id, {:customer, :name} => p10.customer.name}),\n               before: encode_cursor(%{:id => p3.id, {:customer, :name} => p3.customer.name}),\n               limit: 8\n             }\n    end\n\n    test \"sorts ascending without cursors\", %{\n      payments: {p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12}\n    } do\n      %Page{entries: entries, metadata: metadata} =\n        payments_by_customer_name()\n        |> Repo.paginate(\n          cursor_fields: [{{:payments, :id}, :asc}, {{:customer, :name}, :asc}],\n          limit: 50\n        )\n\n      assert to_ids(entries) == to_ids([p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12])\n      assert metadata == %Metadata{after: nil, before: nil, limit: 50}\n    end\n\n    test \"sorts ascending with before cursor\", %{\n      payments: {_p1, _p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, _p12}\n    } do\n      %Page{entries: entries, metadata: metadata} =\n        payments_by_customer_name()\n        |> Repo.paginate(\n          cursor_fields: [{{:payments, :id}, :asc}, {{:customer, :name}, :asc}],\n          before:\n            encode_cursor(%{{:payments, :id} => p11.id, {:customer, :name} => p11.customer.name}),\n          limit: 8\n        )\n\n      assert to_ids(entries) == to_ids([p3, p4, p5, p6, p7, p8, p9, p10])\n\n      assert metadata == %Metadata{\n               after:\n                 encode_cursor(%{\n                   {:payments, :id} => p10.id,\n                   {:customer, :name} => p10.customer.name\n                 }),\n               before:\n                 encode_cursor(%{\n                   {:payments, :id} => p3.id,\n                   {:customer, :name} => p3.customer.name\n                 }),\n               limit: 8\n             }\n    end\n\n    test \"sorts ascending with after cursor\", %{\n      payments: {_p1, _p2, _p3, _p4, _p5, p6, p7, p8, p9, p10, p11, p12}\n    } do\n      %Page{entries: entries, metadata: metadata} =\n        payments_by_customer_name()\n        |> Repo.paginate(\n          cursor_fields: [{{:payments, :id}, :asc}, {{:customer, :name}, :asc}],\n          after:\n            encode_cursor(%{{:payments, :id} => p6.id, {:customer, :name} => p6.customer.name}),\n          limit: 8\n        )\n\n      assert to_ids(entries) == to_ids([p7, p8, p9, p10, p11, p12])\n\n      assert metadata == %Metadata{\n               after: nil,\n               before:\n                 encode_cursor(%{\n                   {:payments, :id} => p7.id,\n                   {:customer, :name} => p7.customer.name\n                 }),\n               limit: 8\n             }\n    end\n\n    test \"sorts ascending with before and after cursor\", %{\n      payments: {_p1, _p2, _p3, _p4, _p5, p6, p7, p8, p9, p10, _p11, _p12}\n    } do\n      %Page{entries: entries, metadata: metadata} =\n        payments_by_customer_name()\n        |> Repo.paginate(\n          cursor_fields: [{{:payments, :id}, :asc}, {{:customer, :name}, :asc}],\n          after:\n            encode_cursor(%{{:payments, :id} => p6.id, {:customer, :name} => p6.customer.name}),\n          before:\n            encode_cursor(%{{:payments, :id} => p10.id, {:customer, :name} => p10.customer.name}),\n          limit: 8\n        )\n\n      assert to_ids(entries) == to_ids([p7, p8, p9])\n\n      assert metadata == %Metadata{\n               after:\n                 encode_cursor(%{\n                   {:payments, :id} => p9.id,\n                   {:customer, :name} => p9.customer.name\n                 }),\n               before:\n                 encode_cursor(%{\n                   {:payments, :id} => p7.id,\n                   {:customer, :name} => p7.customer.name\n                 }),\n               limit: 8\n             }\n    end\n\n    test \"sorts descending without cursors\", %{\n      payments: {p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12}\n    } do\n      %Page{entries: entries, metadata: metadata} =\n        payments_by_customer_name(:desc, :desc)\n        |> Repo.paginate(\n          cursor_fields: [{{:payments, :id}, :desc}, {{:customer, :name}, :desc}],\n          limit: 50\n        )\n\n      assert to_ids(entries) == to_ids([p12, p11, p10, p9, p8, p7, p6, p5, p4, p3, p2, p1])\n      assert metadata == %Metadata{after: nil, before: nil, limit: 50}\n    end\n\n    test \"sorts descending with before cursor\", %{\n      payments: {_p1, _p2, _p3, _p4, _p5, _p6, _p7, _p8, _p9, _p10, p11, p12}\n    } do\n      %Page{entries: entries, metadata: metadata} =\n        payments_by_customer_name(:desc)\n        |> Repo.paginate(\n          cursor_fields: [{{:payments, :id}, :desc}, {{:customer, :name}, :desc}],\n          before:\n            encode_cursor(%{{:payments, :id} => p11.id, {:customer, :name} => p11.customer.name}),\n          limit: 8\n        )\n\n      assert to_ids(entries) == to_ids([p12])\n\n      assert metadata == %Metadata{\n               after:\n                 encode_cursor(%{\n                   {:payments, :id} => p12.id,\n                   {:customer, :name} => p12.customer.name\n                 }),\n               before: nil,\n               limit: 8\n             }\n    end\n\n    test \"sorts descending with after cursor\", %{\n      payments: {_p1, _p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, _p12}\n    } do\n      %Page{entries: entries, metadata: metadata} =\n        payments_by_customer_name(:desc, :desc)\n        |> Repo.paginate(\n          cursor_fields: [{{:payments, :id}, :desc}, {{:customer, :name}, :desc}],\n          sort_direction: :desc,\n          after:\n            encode_cursor(%{{:payments, :id} => p11.id, {:customer, :name} => p11.customer.name}),\n          limit: 8\n        )\n\n      assert to_ids(entries) == to_ids([p10, p9, p8, p7, p6, p5, p4, p3])\n\n      assert metadata == %Metadata{\n               after:\n                 encode_cursor(%{\n                   {:payments, :id} => p3.id,\n                   {:customer, :name} => p3.customer.name\n                 }),\n               before:\n                 encode_cursor(%{\n                   {:payments, :id} => p10.id,\n                   {:customer, :name} => p10.customer.name\n                 }),\n               limit: 8\n             }\n    end\n\n    test \"sorts descending with before and after cursor\", %{\n      payments: {_p1, _p2, _p3, _p4, _p5, p6, p7, p8, p9, p10, p11, _p12}\n    } do\n      %Page{entries: entries, metadata: metadata} =\n        payments_by_customer_name(:desc, :desc)\n        |> Repo.paginate(\n          cursor_fields: [{{:payments, :id}, :desc}, {{:customer, :name}, :desc}],\n          after:\n            encode_cursor(%{{:payments, :id} => p11.id, {:customer, :name} => p11.customer.name}),\n          before:\n            encode_cursor(%{{:payments, :id} => p6.id, {:customer, :name} => p6.customer.name}),\n          limit: 8\n        )\n\n      assert to_ids(entries) == to_ids([p10, p9, p8, p7])\n\n      assert metadata == %Metadata{\n               after:\n                 encode_cursor(%{\n                   {:payments, :id} => p7.id,\n                   {:customer, :name} => p7.customer.name\n                 }),\n               before:\n                 encode_cursor(%{\n                   {:payments, :id} => p10.id,\n                   {:customer, :name} => p10.customer.name\n                 }),\n               limit: 8\n             }\n    end\n\n    test \"sorts ascending with before cursor at beginning of collection\", %{\n      payments: {p1, _p2, _p3, _p4, _p5, _p6, _p7, _p8, _p9, _p10, _p11, _p12}\n    } do\n      %Page{entries: entries, metadata: metadata} =\n        payments_by_customer_name()\n        |> Repo.paginate(\n          cursor_fields: [{{:payments, :id}, :asc}, {{:customer, :name}, :asc}],\n          before:\n            encode_cursor(%{{:payments, :id} => p1.id, {:customer, :name} => p1.customer.name}),\n          limit: 8\n        )\n\n      assert to_ids(entries) == to_ids([])\n      assert metadata == %Metadata{after: nil, before: nil, limit: 8}\n    end\n\n    test \"sorts ascending with after cursor at end of collection\", %{\n      payments: {_p1, _p2, _p3, _p4, _p5, _p6, _p7, _p8, _p9, _p10, _p11, p12}\n    } do\n      %Page{entries: entries, metadata: metadata} =\n        payments_by_customer_name()\n        |> Repo.paginate(\n          cursor_fields: [{{:payments, :id}, :asc}, {{:customer, :name}, :asc}],\n          after:\n            encode_cursor(%{{:payments, :id} => p12.id, {:customer, :name} => p12.customer.name}),\n          limit: 8\n        )\n\n      assert to_ids(entries) == to_ids([])\n      assert metadata == %Metadata{after: nil, before: nil, limit: 8}\n    end\n\n    test \"sorts descending with before cursor at beginning of collection\", %{\n      payments: {_p1, _p2, _p3, _p4, _p5, _p6, _p7, _p8, _p9, _p10, _p11, p12}\n    } do\n      %Page{entries: entries, metadata: metadata} =\n        payments_by_customer_name(:desc, :desc)\n        |> Repo.paginate(\n          cursor_fields: [{{:payments, :id}, :desc}, {{:customer, :name}, :desc}],\n          before:\n            encode_cursor(%{{:payments, :id} => p12.id, {:customer, :name} => p12.customer.name}),\n          limit: 8\n        )\n\n      assert to_ids(entries) == to_ids([])\n      assert metadata == %Metadata{after: nil, before: nil, limit: 8}\n    end\n\n    test \"sorts descending with after cursor at end of collection\", %{\n      payments: {p1, _p2, _p3, _p4, _p5, _p6, _p7, _p8, _p9, _p10, _p11, _p12}\n    } do\n      %Page{entries: entries, metadata: metadata} =\n        payments_by_customer_name(:desc, :desc)\n        |> Repo.paginate(\n          cursor_fields: [{{:payments, :id}, :desc}, {{:customer, :name}, :desc}],\n          after:\n            encode_cursor(%{{:payments, :id} => p1.id, {:customer, :name} => p1.customer.name}),\n          limit: 8\n        )\n\n      assert to_ids(entries) == to_ids([])\n      assert metadata == %Metadata{after: nil, before: nil, limit: 8}\n    end\n\n    test \"sorts on 2nd level join column with a custom cursor value function\", %{\n      payments: {_p1, _p2, _p3, _p4, p5, p6, p7, _p8, _p9, _p10, _p11, _p12}\n    } do\n      %Page{entries: entries, metadata: metadata} =\n        payments_by_address_city()\n        |> Repo.paginate(\n          cursor_fields: [{{:address, :city}, :asc}, id: :asc],\n          before: nil,\n          limit: 3,\n          fetch_cursor_value_fun: fn\n            schema, {:address, :city} ->\n              schema.customer.address.city\n\n            schema, field ->\n              Paginator.default_fetch_cursor_value(schema, field)\n          end\n        )\n\n      assert to_ids(entries) == to_ids([p5, p6, p7])\n\n      p7 = Repo.preload(p7, customer: :address)\n\n      assert metadata == %Metadata{\n               after:\n                 encode_cursor(%{{:address, :city} => p7.customer.address.city, :id => p7.id}),\n               before: nil,\n               limit: 3\n             }\n    end\n\n    test \"sorts with respect to nil values\", %{\n      payments: {_p1, _p2, _p3, _p4, _p5, _p6, p7, _p8, _p9, _p10, p11, _p12}\n    } do\n      %Page{entries: entries, metadata: metadata} =\n        payments_by_charged_at(:desc)\n        |> Repo.paginate(\n          cursor_fields: [:charged_at, :id],\n          sort_direction: :desc,\n          after: encode_cursor(%{charged_at: nil, id: nil}),\n          limit: 8\n        )\n\n      assert Enum.count(entries) == 8\n\n      assert metadata == %Metadata{\n               before: encode_cursor(%{charged_at: p11.charged_at, id: p11.id}),\n               limit: 8,\n               after: encode_cursor(%{charged_at: p7.charged_at, id: p7.id})\n             }\n    end\n  end\n\n  test \"applies a default limit if none is provided\", %{\n    payments: {p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12}\n  } do\n    %Page{entries: entries, metadata: metadata} =\n      payments_by_customer_name()\n      |> Repo.paginate(cursor_fields: [:id], sort_direction: :asc)\n\n    assert to_ids(entries) == to_ids([p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12])\n    assert metadata == %Metadata{after: nil, before: nil, limit: 50}\n  end\n\n  test \"enforces the minimum limit\", %{\n    payments: {p1, _p2, _p3, _p4, _p5, _p6, _p7, _p8, _p9, _p10, _p11, _p12}\n  } do\n    %Page{entries: entries, metadata: metadata} =\n      payments_by_customer_name()\n      |> Repo.paginate(cursor_fields: [:id], sort_direction: :asc, limit: 0)\n\n    assert to_ids(entries) == to_ids([p1])\n    assert metadata == %Metadata{after: encode_cursor(%{id: p1.id}), before: nil, limit: 1}\n  end\n\n  describe \"with include_total_count\" do\n    test \"when set to :infinity\", %{\n      payments: {_p1, _p2, _p3, _p4, p5, _p6, _p7, _p8, _p9, _p10, _p11, _p12}\n    } do\n      %Page{metadata: metadata} =\n        payments_by_customer_name()\n        |> Repo.paginate(\n          cursor_fields: [:id],\n          sort_direction: :asc,\n          limit: 5,\n          total_count_limit: :infinity,\n          include_total_count: true\n        )\n\n      assert metadata == %Metadata{\n               after: encode_cursor(%{id: p5.id}),\n               before: nil,\n               limit: 5,\n               total_count: 12,\n               total_count_cap_exceeded: false\n             }\n    end\n\n    test \"when cap not exceeded\", %{\n      payments: {_p1, _p2, _p3, _p4, p5, _p6, _p7, _p8, _p9, _p10, _p11, _p12}\n    } do\n      %Page{metadata: metadata} =\n        payments_by_customer_name()\n        |> Repo.paginate(\n          cursor_fields: [:id],\n          sort_direction: :asc,\n          limit: 5,\n          include_total_count: true\n        )\n\n      assert metadata == %Metadata{\n               after: encode_cursor(%{id: p5.id}),\n               before: nil,\n               limit: 5,\n               total_count: 12,\n               total_count_cap_exceeded: false\n             }\n    end\n\n    test \"when cap exceeded\", %{\n      payments: {_p1, _p2, _p3, _p4, p5, _p6, _p7, _p8, _p9, _p10, _p11, _p12}\n    } do\n      %Page{metadata: metadata} =\n        payments_by_customer_name()\n        |> Repo.paginate(\n          cursor_fields: [:id],\n          sort_direction: :asc,\n          limit: 5,\n          include_total_count: true,\n          total_count_limit: 10\n        )\n\n      assert metadata == %Metadata{\n               after: encode_cursor(%{id: p5.id}),\n               before: nil,\n               limit: 5,\n               total_count: 10,\n               total_count_cap_exceeded: true\n             }\n    end\n\n    test \"when custom total_count_primary_key_field\", %{\n      addresses: {_a1, a2, _a3}\n    } do\n      %Page{metadata: metadata} =\n        from(a in Address, select: a)\n        |> Repo.paginate(\n          cursor_fields: [:city],\n          sort_direction: :asc,\n          limit: 2,\n          include_total_count: true,\n          total_count_primary_key_field: :city\n        )\n\n      assert metadata == %Metadata{\n               after: encode_cursor(%{city: a2.city}),\n               before: nil,\n               limit: 2,\n               total_count: 3,\n               total_count_cap_exceeded: false\n             }\n    end\n  end\n\n  test \"when before parameter is erlang term, we do not execute the code\", %{} do\n    # before and after, are user inputs, we need to make sure that they are\n    # handled safely.\n\n    test_pid = self()\n\n    exploit = fn _, _ ->\n      send(test_pid, :rce)\n      {:cont, []}\n    end\n\n    payload =\n      exploit\n      |> :erlang.term_to_binary()\n      |> Base.url_encode64()\n\n    assert_raise(ArgumentError, ~r/^cannot deserialize.+/, fn ->\n      payments_by_amount_and_charged_at(:asc, :desc)\n      |> Repo.paginate(\n        cursor_fields: [amount: :asc, charged_at: :desc, id: :asc],\n        before: payload,\n        limit: 3\n      )\n    end)\n\n    refute_receive :rce, 1000, \"Remote Code Execution Detected\"\n  end\n\n  test \"per-record cursor generation\", %{\n    payments: {p1, _p2, _p3, _p4, _p5, _p6, p7, _p8, _p9, _p10, _p11, _p12}\n  } do\n    assert Paginator.cursor_for_record(p1, charged_at: :asc, id: :asc) ==\n             encode_cursor(%{charged_at: p1.charged_at, id: p1.id})\n\n    assert Paginator.cursor_for_record(p7, amount: :asc) == encode_cursor(%{amount: p7.amount})\n  end\n\n  test \"per-record cursor generation with custom cursor value function\", %{\n    payments: {p1, _p2, _p3, _p4, _p5, _p6, _p7, _p8, _p9, _p10, _p11, _p12}\n  } do\n    assert Paginator.cursor_for_record(p1, [charged_at: :asc, id: :asc], fn schema, field ->\n             case field do\n               :id -> Map.get(schema, :id)\n               _ -> \"10\"\n             end\n           end) == encode_cursor(%{charged_at: \"10\", id: p1.id})\n  end\n\n  test \"sorts on two different directions with before cursor\", %{\n    payments: {_p1, _p2, _p3, p4, p5, p6, p7, _p8, _p9, _p10, _p11, _p12}\n  } do\n    %Page{entries: entries, metadata: metadata} =\n      payments_by_amount_and_charged_at(:asc, :desc)\n      |> Repo.paginate(\n        cursor_fields: [amount: :asc, charged_at: :desc, id: :asc],\n        before: encode_cursor(%{amount: p7.amount, charged_at: p7.charged_at, id: p7.id}),\n        limit: 3\n      )\n\n    assert to_ids(entries) == to_ids([p6, p4, p5])\n\n    assert metadata == %Metadata{\n             after: encode_cursor(%{amount: p5.amount, charged_at: p5.charged_at, id: p5.id}),\n             before: nil,\n             limit: 3\n           }\n  end\n\n  test \"sorts on two different directions with after cursor\", %{\n    payments: {_p1, _p2, _p3, p4, p5, _p6, p7, p8, _p9, _p10, _p11, _p12}\n  } do\n    %Page{entries: entries, metadata: metadata} =\n      payments_by_amount_and_charged_at(:asc, :desc)\n      |> Repo.paginate(\n        cursor_fields: [amount: :asc, charged_at: :desc, id: :asc],\n        after: encode_cursor(%{amount: p4.amount, charged_at: p4.charged_at, id: p4.id}),\n        limit: 3\n      )\n\n    assert to_ids(entries) == to_ids([p5, p7, p8])\n\n    assert metadata == %Metadata{\n             after: encode_cursor(%{amount: p8.amount, charged_at: p8.charged_at, id: p8.id}),\n             before: encode_cursor(%{amount: p5.amount, charged_at: p5.charged_at, id: p5.id}),\n             limit: 3\n           }\n  end\n\n  test \"sorts on two different directions with before and after cursor\", %{\n    payments: {_p1, _p2, _p3, p4, p5, p6, p7, p8, _p9, _p10, _p11, _p12}\n  } do\n    %Page{entries: entries, metadata: metadata} =\n      payments_by_amount_and_charged_at(:desc, :asc)\n      |> Repo.paginate(\n        cursor_fields: [amount: :desc, charged_at: :asc, id: :asc],\n        after: encode_cursor(%{amount: p8.amount, charged_at: p8.charged_at, id: p8.id}),\n        before: encode_cursor(%{amount: p6.amount, charged_at: p6.charged_at, id: p6.id}),\n        limit: 8\n      )\n\n    assert to_ids(entries) == to_ids([p7, p5, p4])\n\n    assert metadata == %Metadata{\n             after: encode_cursor(%{amount: p4.amount, charged_at: p4.charged_at, id: p4.id}),\n             before: encode_cursor(%{amount: p7.amount, charged_at: p7.charged_at, id: p7.id}),\n             limit: 8\n           }\n  end\n\n  defp to_ids(entries), do: Enum.map(entries, & &1.id)\n\n  defp create_customers_and_payments(_context) do\n    c1 = insert(:customer, %{name: \"Bob\"})\n    c2 = insert(:customer, %{name: \"Alice\"})\n    c3 = insert(:customer, %{name: \"Charlie\"})\n\n    a1 = insert(:address, city: \"London\", customer: c1)\n    a2 = insert(:address, city: \"New York\", customer: c2)\n    a3 = insert(:address, city: \"Tokyo\", customer: c3)\n\n    p1 = insert(:payment, customer: c2, charged_at: days_ago(11))\n    p2 = insert(:payment, customer: c2, charged_at: days_ago(6))\n    p3 = insert(:payment, customer: c2, charged_at: days_ago(8))\n    p4 = insert(:payment, customer: c2, amount: 2, charged_at: days_ago(12))\n\n    p5 = insert(:payment, customer: c1, amount: 3, charged_at: days_ago(13))\n    p6 = insert(:payment, customer: c1, amount: 2, charged_at: days_ago(10))\n    p7 = insert(:payment, customer: c1, amount: 4, charged_at: days_ago(9))\n    p8 = insert(:payment, customer: c1, amount: 5, charged_at: days_ago(4))\n\n    p9 = insert(:payment, customer: c3, charged_at: days_ago(3))\n    p10 = insert(:payment, customer: c3, charged_at: days_ago(7))\n    p11 = insert(:payment, customer: c3, charged_at: days_ago(2))\n    p12 = insert(:payment, customer: c3, charged_at: days_ago(5))\n\n    {:ok,\n     customers: {c1, c2, c3},\n     addresses: {a1, a2, a3},\n     payments: {p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12}}\n  end\n\n  defp payments_by_status(status, direction \\\\ :asc) do\n    from(\n      p in Payment,\n      where: p.status == ^status,\n      order_by: [{^direction, p.charged_at}, {^direction, p.id}],\n      select: p\n    )\n  end\n\n  defp payments_by_amount_and_charged_at(amount_direction, charged_at_direction) do\n    from(\n      p in Payment,\n      order_by: [\n        {^amount_direction, p.amount},\n        {^charged_at_direction, p.charged_at},\n        {:asc, p.id}\n      ],\n      select: p\n    )\n  end\n\n  defp payments_by_charged_at(direction \\\\ :asc) do\n    from(\n      p in Payment,\n      order_by: [{^direction, p.charged_at}, {^direction, p.id}],\n      select: p\n    )\n  end\n\n  defp payments_by_customer_name(payment_id_direction \\\\ :asc, customer_name_direction \\\\ :asc) do\n    from(\n      p in Payment,\n      as: :payments,\n      join: c in assoc(p, :customer),\n      as: :customer,\n      preload: [customer: c],\n      select: p,\n      order_by: [\n        {^customer_name_direction, c.name},\n        {^payment_id_direction, p.id}\n      ]\n    )\n  end\n\n  defp payments_by_address_city(payment_id_direction \\\\ :asc, address_city_direction \\\\ :asc) do\n    from(\n      p in Payment,\n      as: :payments,\n      join: c in assoc(p, :customer),\n      as: :customer,\n      join: a in assoc(c, :address),\n      as: :address,\n      preload: [customer: {c, address: a}],\n      select: p,\n      order_by: [\n        {^address_city_direction, a.city},\n        {^payment_id_direction, p.id}\n      ]\n    )\n  end\n\n  defp customer_payments_by_amount(customer, direction \\\\ :asc) do\n    from(\n      p in Payment,\n      where: p.customer_id == ^customer.id,\n      order_by: [{^direction, p.amount}, {^direction, p.charged_at}, {^direction, p.id}]\n    )\n  end\n\n  defp encode_cursor(value) do\n    Cursor.encode(value)\n  end\n\n  defp encode_legacy_cursor(value) when is_list(value) do\n    value\n    |> :erlang.term_to_binary()\n    |> Base.url_encode64()\n  end\n\n  defp days_ago(days) do\n    DT.add!(DateTime.utc_now(), -(days * 86400))\n  end\nend\n"], "filenames": ["README.md", "lib/paginator/cursor.ex", "mix.exs", "mix.lock", "test/paginator_test.exs"], "buggy_code_start_loc": [111, 9, 48, 2, 819], "buggy_code_end_loc": [111, 10, 49, 28, 819], "fixing_code_start_loc": [112, 9, 48, 2, 820], "fixing_code_end_loc": [116, 10, 50, 29, 848], "type": "CWE-94", "message": "There is a vulnerability in Paginator (Elixir/Hex package) which makes it susceptible to Remote Code Execution (RCE) attacks via input parameters to the paginate() function. This will potentially affect all current users of Paginator prior to version 1.0.0. The vulnerability has been patched in version 1.0.0 and all users should upgrade to this version immediately. Note that this patched version uses a dependency that requires an Elixir version >=1.5.", "other": {"cve": {"id": "CVE-2020-15150", "sourceIdentifier": "security-advisories@github.com", "published": "2020-09-01T17:15:11.840", "lastModified": "2020-09-11T14:34:02.573", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "There is a vulnerability in Paginator (Elixir/Hex package) which makes it susceptible to Remote Code Execution (RCE) attacks via input parameters to the paginate() function. This will potentially affect all current users of Paginator prior to version 1.0.0. The vulnerability has been patched in version 1.0.0 and all users should upgrade to this version immediately. Note that this patched version uses a dependency that requires an Elixir version >=1.5."}, {"lang": "es", "value": "Se presenta una vulnerabilidad en Paginator (paquete Elixir/Hex) que lo hace susceptible a ataques de Ejecuci\u00f3n de C\u00f3digo Remota (RCE) por medio de par\u00e1metros de entrada a la funci\u00f3n paginate().&#xa0;Esto afectar\u00e1 potencialmente a todos los usuarios actuales de Paginator versiones anteriores a 1.0.0.&#xa0;La vulnerabilidad ha sido parcheada en la versi\u00f3n 1.0.0 y todos los usuarios deben actualizar a esta versi\u00f3n de inmediato.&#xa0;Tome en cuenta que esta versi\u00f3n parcheada usa una dependencia que requiere una versi\u00f3n de Elixir posterior a 1.5 incluy\u00e9ndola"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.0, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 2.2, "impactScore": 6.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-94"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:duffel:paginator:*:*:*:*:*:elixir:*:*", "versionEndExcluding": "1.0.0", "matchCriteriaId": "533F934A-92A9-4407-9EBF-519DDCD86EB1"}]}]}], "references": [{"url": "https://github.com/duffelhq/paginator/blob/ccf0f37fa96347cc8c8a7e9eb2c64462cec4b2dc/README.md#security-considerations", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/duffelhq/paginator/commit/bf45e92602e517c75aea0465efc35cd661d9ebf8", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/duffelhq/paginator/security/advisories/GHSA-w98m-2xqg-9cvj", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://hex.pm/packages/paginator", "source": "security-advisories@github.com", "tags": ["Product"]}]}, "github_commit_url": "https://github.com/duffelhq/paginator/commit/bf45e92602e517c75aea0465efc35cd661d9ebf8"}}