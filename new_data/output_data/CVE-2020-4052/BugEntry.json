{"buggy_code": ["const _ = require('lodash')\nconst cheerio = require('cheerio')\nconst uslug = require('uslug')\nconst pageHelper = require('../../../helpers/page')\nconst URL = require('url').URL\n\n/* global WIKI */\n\nmodule.exports = {\n  async render() {\n    const $ = cheerio.load(this.input, {\n      decodeEntities: true\n    })\n\n    if ($.root().children().length < 1) {\n      return ''\n    }\n\n    // --------------------------------\n    // STEP: PRE\n    // --------------------------------\n\n    for (let child of _.reject(this.children, ['step', 'post'])) {\n      const renderer = require(`../${_.kebabCase(child.key)}/renderer.js`)\n      renderer.init($, child.config)\n    }\n\n    // --------------------------------\n    // Detect internal / external links\n    // --------------------------------\n\n    let internalRefs = []\n    const reservedPrefixes = /^\\/[a-z]\\//i\n    const exactReservedPaths = /^\\/[a-z]$/i\n\n    const isHostSet = WIKI.config.host.length > 7 && WIKI.config.host !== 'http://'\n    if (!isHostSet) {\n      WIKI.logger.warn('Host is not set. You must set the Site Host under General in the Administration Area!')\n    }\n\n    $('a').each((i, elm) => {\n      let href = $(elm).attr('href')\n\n      // -> Ignore empty / anchor links, e-mail addresses, and telephone numbers\n      if (!href || href.length < 1 || href.indexOf('#') === 0 ||\n        href.indexOf('mailto:') === 0 || href.indexOf('tel:') === 0) {\n        return\n      }\n\n      // -> Strip host from local links\n      if (isHostSet && href.indexOf(WIKI.config.host) === 0) {\n        href = href.replace(WIKI.config.host, '')\n      }\n\n      // -> Assign local / external tag\n      if (href.indexOf('://') < 0) {\n        // -> Remove trailing slash\n        if (_.endsWith('/')) {\n          href = href.slice(0, -1)\n        }\n\n        // -> Check for system prefix\n        if (reservedPrefixes.test(href) || exactReservedPaths.test(href)) {\n          $(elm).addClass(`is-system-link`)\n        } else if (href.indexOf('.') >= 0) {\n          $(elm).addClass(`is-asset-link`)\n        } else {\n          let pagePath = null\n\n          // -> Add locale prefix if using namespacing\n          if (WIKI.config.lang.namespacing) {\n            // -> Reformat paths\n            if (href.indexOf('/') !== 0) {\n              if (this.config.absoluteLinks) {\n                href = `/${this.page.localeCode}/${href}`\n              } else {\n                href = (this.page.path === 'home') ? `/${this.page.localeCode}/${href}` : `/${this.page.localeCode}/${this.page.path}/${href}`\n              }\n            } else if (href.charAt(3) !== '/') {\n              href = `/${this.page.localeCode}${href}`\n            }\n\n            try {\n              const parsedUrl = new URL(`http://x${href}`)\n              pagePath = pageHelper.parsePath(parsedUrl.pathname)\n            } catch (err) {\n              return\n            }\n          } else {\n            // -> Reformat paths\n            if (href.indexOf('/') !== 0) {\n              if (this.config.absoluteLinks) {\n                href = `/${href}`\n              } else {\n                href = (this.page.path === 'home') ? `/${href}` : `/${this.page.path}/${href}`\n              }\n            }\n\n            try {\n              const parsedUrl = new URL(`http://x${href}`)\n              pagePath = pageHelper.parsePath(parsedUrl.pathname)\n            } catch (err) {\n              return\n            }\n          }\n          // -> Save internal references\n          internalRefs.push({\n            localeCode: pagePath.locale,\n            path: pagePath.path\n          })\n\n          $(elm).addClass(`is-internal-link`)\n        }\n      } else {\n        $(elm).addClass(`is-external-link`)\n        if (this.config.openExternalLinkNewTab) {\n          $(elm).attr('target', '_blank')\n          $(elm).attr('rel', this.config.relAttributeExternalLink)\n        }\n      }\n\n      // -> Update element\n      $(elm).attr('href', href)\n    })\n\n    // --------------------------------\n    // Detect internal link states\n    // --------------------------------\n\n    const pastLinks = await this.page.$relatedQuery('links')\n\n    if (internalRefs.length > 0) {\n      // -> Find matching pages\n      const results = await WIKI.models.pages.query().column('id', 'path', 'localeCode').where(builder => {\n        internalRefs.forEach((ref, idx) => {\n          if (idx < 1) {\n            builder.where(ref)\n          } else {\n            builder.orWhere(ref)\n          }\n        })\n      })\n\n      // -> Apply tag to internal links for found pages\n      $('a.is-internal-link').each((i, elm) => {\n        const href = $(elm).attr('href')\n        let hrefObj = {}\n        try {\n          const parsedUrl = new URL(`http://x${href}`)\n          hrefObj = pageHelper.parsePath(parsedUrl.pathname)\n        } catch (err) {\n          return\n        }\n        if (_.some(results, r => {\n          return r.localeCode === hrefObj.locale && r.path === hrefObj.path\n        })) {\n          $(elm).addClass(`is-valid-page`)\n        } else {\n          $(elm).addClass(`is-invalid-page`)\n        }\n      })\n\n      // -> Add missing links\n      const missingLinks = _.differenceWith(internalRefs, pastLinks, (nLink, pLink) => {\n        return nLink.localeCode === pLink.localeCode && nLink.path === pLink.path\n      })\n      if (missingLinks.length > 0) {\n        if (WIKI.config.db.type === 'postgres') {\n          await WIKI.models.pageLinks.query().insert(missingLinks.map(lnk => ({\n            pageId: this.page.id,\n            path: lnk.path,\n            localeCode: lnk.localeCode\n          })))\n        } else {\n          for (const lnk of missingLinks) {\n            await WIKI.models.pageLinks.query().insert({\n              pageId: this.page.id,\n              path: lnk.path,\n              localeCode: lnk.localeCode\n            })\n          }\n        }\n      }\n    }\n\n    // -> Remove outdated links\n    if (pastLinks) {\n      const outdatedLinks = _.differenceWith(pastLinks, internalRefs, (nLink, pLink) => {\n        return nLink.localeCode === pLink.localeCode && nLink.path === pLink.path\n      })\n      if (outdatedLinks.length > 0) {\n        await WIKI.models.pageLinks.query().delete().whereIn('id', _.map(outdatedLinks, 'id'))\n      }\n    }\n\n    // --------------------------------\n    // Add header handles\n    // --------------------------------\n\n    let headers = []\n    $('h1,h2,h3,h4,h5,h6').each((i, elm) => {\n      if ($(elm).attr('id')) {\n        return\n      }\n      let headerSlug = uslug($(elm).text())\n\n      // -> Cannot start with a number (CSS selector limitation)\n      if (headerSlug.match(/^\\d/)) {\n        headerSlug = `h-${headerSlug}`\n      }\n\n      // -> Make sure header is unique\n      if (headers.indexOf(headerSlug) >= 0) {\n        let isUnique = false\n        let hIdx = 1\n        while (!isUnique) {\n          const headerSlugTry = `${headerSlug}-${hIdx}`\n          if (headers.indexOf(headerSlugTry) < 0) {\n            isUnique = true\n            headerSlug = headerSlugTry\n          }\n          hIdx++\n        }\n      }\n\n      // -> Add anchor\n      $(elm).attr('id', headerSlug).addClass('toc-header')\n      $(elm).prepend(`<a class=\"toc-anchor\" href=\"#${headerSlug}\">&#xB6;</a> `)\n\n      headers.push(headerSlug)\n    })\n\n    // --------------------------------\n    // Escape mustache expresions\n    // --------------------------------\n\n    function iterateMustacheNode (node) {\n      const list = $(node).contents().toArray()\n      list.forEach(item => {\n        if (item.type === 'text') {\n          const rawText = $(item).text()\n          if (rawText.indexOf('{{') >= 0 && rawText.indexOf('}}') > 1) {\n            $(item).parent().attr('v-pre', true)\n          }\n        } else {\n          iterateMustacheNode(item)\n        }\n      })\n    }\n    iterateMustacheNode($.root())\n\n    // --------------------------------\n    // STEP: POST\n    // --------------------------------\n\n    let output = decodeEscape($.html('body').replace('<body>', '').replace('</body>', ''))\n\n    for (let child of _.sortBy(_.filter(this.children, ['step', 'post']), ['order'])) {\n      const renderer = require(`../${_.kebabCase(child.key)}/renderer.js`)\n      output = await renderer.init(output, child.config)\n    }\n\n    return output\n  }\n}\n\nfunction decodeEscape (string) {\n  return string.replace(/&#x([0-9a-f]{1,6});/ig, (entity, code) => {\n    code = parseInt(code, 16)\n\n    // Don't unescape ASCII characters, assuming they're encoded for a good reason\n    if (code < 0x80) return entity\n\n    return String.fromCodePoint(code)\n  })\n}\n"], "fixing_code": ["const _ = require('lodash')\nconst cheerio = require('cheerio')\nconst uslug = require('uslug')\nconst pageHelper = require('../../../helpers/page')\nconst URL = require('url').URL\n\nconst mustacheRegExp = /(\\{|&#x7b;?){2}(.+?)(\\}|&#x7d;?){2}/i\n\n/* global WIKI */\n\nmodule.exports = {\n  async render() {\n    const $ = cheerio.load(this.input, {\n      decodeEntities: true\n    })\n\n    if ($.root().children().length < 1) {\n      return ''\n    }\n\n    // --------------------------------\n    // STEP: PRE\n    // --------------------------------\n\n    for (let child of _.reject(this.children, ['step', 'post'])) {\n      const renderer = require(`../${_.kebabCase(child.key)}/renderer.js`)\n      renderer.init($, child.config)\n    }\n\n    // --------------------------------\n    // Detect internal / external links\n    // --------------------------------\n\n    let internalRefs = []\n    const reservedPrefixes = /^\\/[a-z]\\//i\n    const exactReservedPaths = /^\\/[a-z]$/i\n\n    const isHostSet = WIKI.config.host.length > 7 && WIKI.config.host !== 'http://'\n    if (!isHostSet) {\n      WIKI.logger.warn('Host is not set. You must set the Site Host under General in the Administration Area!')\n    }\n\n    $('a').each((i, elm) => {\n      let href = $(elm).attr('href')\n\n      // -> Ignore empty / anchor links, e-mail addresses, and telephone numbers\n      if (!href || href.length < 1 || href.indexOf('#') === 0 ||\n        href.indexOf('mailto:') === 0 || href.indexOf('tel:') === 0) {\n        return\n      }\n\n      // -> Strip host from local links\n      if (isHostSet && href.indexOf(WIKI.config.host) === 0) {\n        href = href.replace(WIKI.config.host, '')\n      }\n\n      // -> Assign local / external tag\n      if (href.indexOf('://') < 0) {\n        // -> Remove trailing slash\n        if (_.endsWith('/')) {\n          href = href.slice(0, -1)\n        }\n\n        // -> Check for system prefix\n        if (reservedPrefixes.test(href) || exactReservedPaths.test(href)) {\n          $(elm).addClass(`is-system-link`)\n        } else if (href.indexOf('.') >= 0) {\n          $(elm).addClass(`is-asset-link`)\n        } else {\n          let pagePath = null\n\n          // -> Add locale prefix if using namespacing\n          if (WIKI.config.lang.namespacing) {\n            // -> Reformat paths\n            if (href.indexOf('/') !== 0) {\n              if (this.config.absoluteLinks) {\n                href = `/${this.page.localeCode}/${href}`\n              } else {\n                href = (this.page.path === 'home') ? `/${this.page.localeCode}/${href}` : `/${this.page.localeCode}/${this.page.path}/${href}`\n              }\n            } else if (href.charAt(3) !== '/') {\n              href = `/${this.page.localeCode}${href}`\n            }\n\n            try {\n              const parsedUrl = new URL(`http://x${href}`)\n              pagePath = pageHelper.parsePath(parsedUrl.pathname)\n            } catch (err) {\n              return\n            }\n          } else {\n            // -> Reformat paths\n            if (href.indexOf('/') !== 0) {\n              if (this.config.absoluteLinks) {\n                href = `/${href}`\n              } else {\n                href = (this.page.path === 'home') ? `/${href}` : `/${this.page.path}/${href}`\n              }\n            }\n\n            try {\n              const parsedUrl = new URL(`http://x${href}`)\n              pagePath = pageHelper.parsePath(parsedUrl.pathname)\n            } catch (err) {\n              return\n            }\n          }\n          // -> Save internal references\n          internalRefs.push({\n            localeCode: pagePath.locale,\n            path: pagePath.path\n          })\n\n          $(elm).addClass(`is-internal-link`)\n        }\n      } else {\n        $(elm).addClass(`is-external-link`)\n        if (this.config.openExternalLinkNewTab) {\n          $(elm).attr('target', '_blank')\n          $(elm).attr('rel', this.config.relAttributeExternalLink)\n        }\n      }\n\n      // -> Update element\n      $(elm).attr('href', href)\n    })\n\n    // --------------------------------\n    // Detect internal link states\n    // --------------------------------\n\n    const pastLinks = await this.page.$relatedQuery('links')\n\n    if (internalRefs.length > 0) {\n      // -> Find matching pages\n      const results = await WIKI.models.pages.query().column('id', 'path', 'localeCode').where(builder => {\n        internalRefs.forEach((ref, idx) => {\n          if (idx < 1) {\n            builder.where(ref)\n          } else {\n            builder.orWhere(ref)\n          }\n        })\n      })\n\n      // -> Apply tag to internal links for found pages\n      $('a.is-internal-link').each((i, elm) => {\n        const href = $(elm).attr('href')\n        let hrefObj = {}\n        try {\n          const parsedUrl = new URL(`http://x${href}`)\n          hrefObj = pageHelper.parsePath(parsedUrl.pathname)\n        } catch (err) {\n          return\n        }\n        if (_.some(results, r => {\n          return r.localeCode === hrefObj.locale && r.path === hrefObj.path\n        })) {\n          $(elm).addClass(`is-valid-page`)\n        } else {\n          $(elm).addClass(`is-invalid-page`)\n        }\n      })\n\n      // -> Add missing links\n      const missingLinks = _.differenceWith(internalRefs, pastLinks, (nLink, pLink) => {\n        return nLink.localeCode === pLink.localeCode && nLink.path === pLink.path\n      })\n      if (missingLinks.length > 0) {\n        if (WIKI.config.db.type === 'postgres') {\n          await WIKI.models.pageLinks.query().insert(missingLinks.map(lnk => ({\n            pageId: this.page.id,\n            path: lnk.path,\n            localeCode: lnk.localeCode\n          })))\n        } else {\n          for (const lnk of missingLinks) {\n            await WIKI.models.pageLinks.query().insert({\n              pageId: this.page.id,\n              path: lnk.path,\n              localeCode: lnk.localeCode\n            })\n          }\n        }\n      }\n    }\n\n    // -> Remove outdated links\n    if (pastLinks) {\n      const outdatedLinks = _.differenceWith(pastLinks, internalRefs, (nLink, pLink) => {\n        return nLink.localeCode === pLink.localeCode && nLink.path === pLink.path\n      })\n      if (outdatedLinks.length > 0) {\n        await WIKI.models.pageLinks.query().delete().whereIn('id', _.map(outdatedLinks, 'id'))\n      }\n    }\n\n    // --------------------------------\n    // Add header handles\n    // --------------------------------\n\n    let headers = []\n    $('h1,h2,h3,h4,h5,h6').each((i, elm) => {\n      if ($(elm).attr('id')) {\n        return\n      }\n      let headerSlug = uslug($(elm).text())\n\n      // -> Cannot start with a number (CSS selector limitation)\n      if (headerSlug.match(/^\\d/)) {\n        headerSlug = `h-${headerSlug}`\n      }\n\n      // -> Make sure header is unique\n      if (headers.indexOf(headerSlug) >= 0) {\n        let isUnique = false\n        let hIdx = 1\n        while (!isUnique) {\n          const headerSlugTry = `${headerSlug}-${hIdx}`\n          if (headers.indexOf(headerSlugTry) < 0) {\n            isUnique = true\n            headerSlug = headerSlugTry\n          }\n          hIdx++\n        }\n      }\n\n      // -> Add anchor\n      $(elm).attr('id', headerSlug).addClass('toc-header')\n      $(elm).prepend(`<a class=\"toc-anchor\" href=\"#${headerSlug}\">&#xB6;</a> `)\n\n      headers.push(headerSlug)\n    })\n\n    // --------------------------------\n    // Wrap root text nodes\n    // --------------------------------\n\n    $('body').contents().toArray().forEach(item => {\n      if (item.type === 'text' && item.parent.name === 'body') {\n        $(item).wrap('<div></div>')\n      }\n    })\n\n    // --------------------------------\n    // Escape mustache expresions\n    // --------------------------------\n\n    function iterateMustacheNode (node) {\n      const list = $(node).contents().toArray()\n      list.forEach(item => {\n        if (item.type === 'text') {\n          const rawText = $(item).text()\n          if (mustacheRegExp.test(rawText)) {\n            $(item).parent().attr('v-pre', true)\n          }\n        } else {\n          iterateMustacheNode(item)\n        }\n      })\n    }\n    iterateMustacheNode($.root())\n\n    // --------------------------------\n    // STEP: POST\n    // --------------------------------\n\n    let output = decodeEscape($.html('body').replace('<body>', '').replace('</body>', ''))\n\n    for (let child of _.sortBy(_.filter(this.children, ['step', 'post']), ['order'])) {\n      const renderer = require(`../${_.kebabCase(child.key)}/renderer.js`)\n      output = await renderer.init(output, child.config)\n    }\n\n    return output\n  }\n}\n\nfunction decodeEscape (string) {\n  return string.replace(/&#x([0-9a-f]{1,6});/ig, (entity, code) => {\n    code = parseInt(code, 16)\n\n    // Don't unescape ASCII characters, assuming they're encoded for a good reason\n    if (code < 0x80) return entity\n\n    return String.fromCodePoint(code)\n  })\n}\n"], "filenames": ["server/modules/rendering/html-core/renderer.js"], "buggy_code_start_loc": [5], "buggy_code_end_loc": [243], "fixing_code_start_loc": [6], "fixing_code_end_loc": [255], "type": "CWE-79", "message": "In Wiki.js before 2.4.107, there is a stored cross-site scripting through template injection. This vulnerability exists due to an insecure validation mechanism intended to insert v-pre tags into rendered HTML elements which contain curly-braces. By creating a crafted wiki page, a malicious Wiki.js user may stage a stored cross-site scripting attack. This allows the attacker to execute malicious JavaScript when the page is viewed by other users. This has been patched in 2.4.107.", "other": {"cve": {"id": "CVE-2020-4052", "sourceIdentifier": "security-advisories@github.com", "published": "2020-06-16T22:15:10.503", "lastModified": "2020-06-22T20:45:01.727", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In Wiki.js before 2.4.107, there is a stored cross-site scripting through template injection. This vulnerability exists due to an insecure validation mechanism intended to insert v-pre tags into rendered HTML elements which contain curly-braces. By creating a crafted wiki page, a malicious Wiki.js user may stage a stored cross-site scripting attack. This allows the attacker to execute malicious JavaScript when the page is viewed by other users. This has been patched in 2.4.107."}, {"lang": "es", "value": "En Wiki.js anterior a 2.4.107, se presenta un ataque de tipo cross-site scripting almacenado mediante una inyecci\u00f3n de plantilla. Esta vulnerabilidad se presenta debido a un mecanismo de comprobaci\u00f3n no seguro destinado a insertar etiquetas v-pre en elementos HTML renderizados que contienen llaves rizadas. Al crear una p\u00e1gina wiki dise\u00f1ada, un usuario malicioso de Wiki.js puede organizar un ataque de tipo cross-site scripting almacenado. Esto permite al atacante ejecutar JavaScript malicioso cuando otros usuarios visualizan la p\u00e1gina. Esto se ha parcheado en 2.4.107"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 6.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:requarks:wiki.js:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.4.107", "matchCriteriaId": "A21CABF1-D47E-47A8-A1BC-5299FB1145F5"}]}]}], "references": [{"url": "https://github.com/Requarks/wiki/commit/9e08718ee904046f8b2294ef6ac79e8a75a451e3", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/Requarks/wiki/security/advisories/GHSA-9jgg-4xj2-vjjj", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Requarks/wiki/commit/9e08718ee904046f8b2294ef6ac79e8a75a451e3"}}