{"buggy_code": ["# frozen_string_literal: true\n\nclass ArticlesController < ContentController\n  before_action :login_required, only: [:preview, :preview_page]\n  before_action :auto_discovery_feed, only: [:show, :index]\n  before_action :verify_config\n\n  layout :theme_layout, except: [:trackback]\n\n  helper :'admin/base'\n\n  def index\n    wanted_types = this_blog.statuses_in_timeline ? [\"Article\", \"Note\"] : [\"Article\"]\n\n    limit = this_blog.per_page(params[:format])\n    articles_base = if params[:year].blank?\n                      this_blog.contents.published\n                    else\n                      this_blog.contents.published_at(params.values_at(:year, :month, :day))\n                    end\n    @articles = articles_base.includes(:user, :resources, :tags).\n      where(type: wanted_types).page(params[:page]).per(limit)\n\n    respond_to do |format|\n      format.html do\n        set_index_title_and_description(this_blog, params)\n        @keywords = this_blog.meta_keywords\n\n        render_paginated_index\n      end\n      format.atom do\n        render_articles_feed(\"atom\")\n      end\n      format.rss do\n        auto_discovery_feed(only_path: false)\n        render_articles_feed(\"rss\")\n      end\n    end\n  end\n\n  def search\n    @articles = this_blog.articles_matching(params[:q],\n                                            page: params[:page],\n                                            per_page: this_blog.per_page(params[:format]))\n    return error! if @articles.empty?\n\n    @page_title = this_blog.search_title_template.to_title(@articles, this_blog, params)\n    @description = this_blog.search_desc_template.to_title(@articles, this_blog, params)\n    respond_to do |format|\n      format.html { render \"search\" }\n      format.rss { render_articles_feed \"rss\" }\n      format.atom { render_articles_feed \"atom\" }\n    end\n  end\n\n  def live_search\n    @search = params[:q]\n    @articles = Article.search(@search)\n    render :live_search, layout: false\n  end\n\n  def preview\n    @article = Article.last_draft(params[:id])\n    @page_title = this_blog.article_title_template.to_title(@article, this_blog, params)\n    render \"read\"\n  end\n\n  def check_password\n    return unless request.xhr?\n\n    @article = Article.find(params[:article][:id])\n    if @article.password == params[:article][:password]\n      render partial: \"articles/full_article_content\", locals: { article: @article }\n    else\n      render partial: \"articles/password_form\", locals: { article: @article }\n    end\n  end\n\n  def redirect\n    from = extract_feed_format(params[:from])\n    factory = Article::Factory.new(this_blog, current_user)\n\n    @article = factory.match_permalink_format(from, this_blog.permalink_format)\n    return show_article if @article\n\n    # Redirect old version with /:year/:month/:day/:title to new format,\n    # because it's changed\n    [\"%year%/%month%/%day%/%title%\", \"articles/%year%/%month%/%day%/%title%\"].each do |part|\n      @article = factory.match_permalink_format(from, part)\n      if @article\n        return redirect_to URI.parse(@article.permalink_url).path,\n                           status: :moved_permanently\n      end\n    end\n\n    r = Redirect.find_by!(from_path: from)\n    # TODO: If linked to article, directly redirect to the article.\n    # Let redirection made outside of the blog on purpose (deal with it, Brakeman!)\n    redirect_to r.full_to_path, status: :moved_permanently if r\n  end\n\n  def archives\n    limit = this_blog.limit_archives_display\n    @articles = this_blog.published_articles.includes(:tags).page(params[:page]).per(limit)\n    @page_title = this_blog.archives_title_template.to_title(@articles, this_blog, params)\n    @keywords = this_blog.meta_keywords\n    @description = this_blog.archives_desc_template.to_title(@articles, this_blog, params)\n  end\n\n  def tag\n    redirect_to tags_path, status: :moved_permanently\n  end\n\n  def preview_page\n    @page = Page.find(params[:id])\n    render \"view_page\"\n  end\n\n  def view_page\n    @page = Page.published.find_by!(name: Array(params[:name]).join(\"/\"))\n    @page_title = @page.title\n    @description = this_blog.meta_description\n    @keywords = this_blog.meta_keywords\n  end\n\n  # TODO: Move to TextfilterController\n  def markup_help\n    filter = TextFilter.make_filter(params[:id])\n    if filter\n      render html: filter.commenthelp\n    else\n      render plain: \"Unknown filter\"\n    end\n  end\n\n  private\n\n  def set_index_title_and_description(blog, parameters)\n    @page_title = blog.home_title_template\n    @description = blog.home_desc_template\n    if parameters[:year]\n      @page_title = blog.archives_title_template\n      @description = blog.archives_desc_template\n    elsif parameters[:page]\n      @page_title = blog.paginated_title_template\n      @description = blog.paginated_desc_template\n    end\n    @page_title = @page_title.to_title(@articles, blog, parameters)\n    @description = @description.to_title(@articles, blog, parameters)\n  end\n\n  def verify_config\n    if !this_blog.configured?\n      redirect_to controller: \"setup\", action: \"index\"\n    elsif User.count == 0\n      redirect_to new_user_registration_path\n    else\n      true\n    end\n  end\n\n  # See an article We need define @article before\n  def show_article\n    auto_discovery_feed\n    respond_to do |format|\n      format.html do\n        @comment = Comment.new\n        @page_title = this_blog.article_title_template.to_title(@article, this_blog, params)\n        @description = this_blog.article_desc_template.to_title(@article, this_blog, params)\n\n        @keywords = @article.tags.map(&:name).join(\", \")\n        render \"articles/#{@article.post_type}\"\n      end\n      format.atom { render_feedback_feed(\"atom\") }\n      format.rss { render_feedback_feed(\"rss\") }\n      format.xml { render_feedback_feed(\"atom\") }\n    end\n  rescue ActiveRecord::RecordNotFound\n    error!\n  end\n\n  def render_articles_feed(format)\n    render_cached_xml(\"index_#{format}_feed\", @articles)\n  end\n\n  def render_feedback_feed(format)\n    render_cached_xml(\"feedback_#{format}_feed\", @article)\n  end\n\n  def render_paginated_index\n    return error! if @articles.empty?\n\n    auto_discovery_feed(only_path: false)\n    render \"index\"\n  end\n\n  def extract_feed_format(from)\n    case from\n    when /^.*\\.rss$/\n      request.format = \"rss\"\n      from = from.gsub(/\\.rss/, \"\")\n    when /^.*\\.atom$/\n      request.format = \"atom\"\n      from = from.gsub(/\\.atom$/, \"\")\n    end\n    from\n  end\n\n  def error!\n    @message = I18n.t(\"errors.no_posts_found\")\n    render \"articles/error\", status: :ok\n  end\nend\n", "# frozen_string_literal: true\n\nrequire \"rails_helper\"\n\nRSpec.describe ArticlesController, type: :controller do\n  describe \"#tag\" do\n    let!(:blog) { create(:blog) }\n    let!(:user) { create :user }\n\n    it \"redirects to TagsContoller#index\" do\n      get :tag\n\n      expect(response).to redirect_to(tags_path)\n    end\n  end\n\n  describe \"#index\" do\n    let!(:blog) { create(:blog) }\n    let!(:user) { create :user }\n\n    context \"without any parameters\" do\n      let!(:article) { create(:article) }\n      let!(:note) { create(:note) }\n\n      before do\n        get :index\n      end\n\n      it { expect(response).to render_template(:index) }\n      it { expect(assigns[:articles]).not_to be_empty }\n\n      it \"has no meta keywords for a blog without keywords\" do\n        expect(assigns(:keywords)).to eq(\"\")\n      end\n    end\n\n    context \"for a month\" do\n      before do\n        create(:article, published_at: Time.utc(2004, 4, 23))\n        get \"index\", params: { year: 2004, month: 4 }\n      end\n\n      it \"renders template index\" do\n        expect(response).to render_template(:index)\n      end\n\n      it \"contains some articles\" do\n        expect(assigns[:articles]).not_to be_nil\n        expect(assigns[:articles]).not_to be_empty\n      end\n    end\n\n    context \"for feeds\" do\n      let!(:article1) { create(:article, created_at: 1.day.ago) }\n      let!(:article2) { create(:article, published_at: \"2004-04-01 12:00:00\") }\n\n      let(:trackback) { create(:trackback, article: article1, published_at: 1.day.ago) }\n\n      specify \"/articles.atom => an atom feed\" do\n        get \"index\", params: { format: \"atom\" }\n        expect(response).to be_successful\n        expect(response).to render_template(\"index_atom_feed\", layout: false)\n        expect(assigns(:articles)).to eq([article1, article2])\n      end\n\n      specify \"/articles.rss => an RSS 2.0 feed\" do\n        get \"index\", params: { format: \"rss\" }\n        expect(response).to be_successful\n        expect(response).to render_template(\"index_rss_feed\", layout: false)\n        expect(assigns(:articles)).to eq([article1, article2])\n      end\n\n      specify \"atom feed for archive should be valid\" do\n        get \"index\", params: { year: 2004, month: 4, format: \"atom\" }\n        expect(response).to render_template(\"index_atom_feed\", layout: false)\n        expect(assigns(:articles)).to eq([article2])\n      end\n\n      specify \"RSS feed for archive should be valid\" do\n        get \"index\", params: { year: 2004, month: 4, format: \"rss\" }\n        expect(response).to render_template(\"index_rss_feed\", layout: false)\n        expect(assigns(:articles)).to eq([article2])\n      end\n    end\n\n    context \"with an accept header\" do\n      before do\n        create(:article)\n      end\n\n      it \"ignores the HTTP Accept: header\" do\n        request.env[\"HTTP_ACCEPT\"] = \"application/atom+xml\"\n        get \"index\"\n        expect(response).to render_template(\"index\")\n      end\n    end\n\n    context \"with blog meta keywords to 'publify, is, amazing'\" do\n      let!(:blog) { create(:blog, meta_keywords: \"publify, is, amazing\") }\n\n      it \"index without option but with blog keywords should have meta keywords\" do\n        get \"index\"\n        expect(assigns(:keywords)).to eq(\"publify, is, amazing\")\n      end\n    end\n\n    context \"when blog settings is empty\" do\n      let!(:blog) { create(:blog, settings: {}) }\n\n      it \"redirects to setup\" do\n        get \"index\"\n        expect(response).to redirect_to(controller: \"setup\", action: \"index\")\n      end\n    end\n\n    context \"when there are no users\" do\n      before do\n        User.destroy_all\n      end\n\n      it \"redirects to signup\" do\n        get \"index\"\n        expect(response).to redirect_to new_user_registration_path\n      end\n    end\n  end\n\n  describe \"#search\" do\n    render_views\n\n    let!(:blog) { create(:blog) }\n    let!(:user) { create :user }\n    let!(:matching_article) { create(:article, body: \"public foobar\") }\n    let!(:not_matching_article) { create(:article, body: \"barbaz\") }\n    let!(:protected_article) do\n      create(:article, body: \"protected foobar\", password: \"secret!\")\n    end\n\n    it \"renders result with only matching articles\" do\n      get :search, params: { q: \"oba\" }\n\n      aggregate_failures do\n        expect(response).to render_template(:search)\n        expect(assigns[:articles]).to match_array [matching_article, protected_article]\n        expect(response.body).to have_text \"public foobar\"\n        expect(response.body).not_to have_text \"protected foobar\"\n      end\n    end\n\n    it \"renders feed rss by search\" do\n      get \"search\", params: { q: \"oba\", format: \"rss\" }\n      aggregate_failures do\n        expect(response).to be_successful\n        expect(response).to render_template(\"index_rss_feed\", layout: false)\n        expect(response.body).to have_text \"public foobar\"\n        expect(response.body).not_to have_text \"protected foobar\"\n      end\n    end\n\n    it \"renders feed atom by search\" do\n      get \"search\", params: { q: \"oba\", format: \"atom\" }\n      aggregate_failures do\n        expect(response).to be_successful\n        expect(response).to render_template(\"index_atom_feed\", layout: false)\n        expect(response.body).to have_text \"public foobar\"\n        expect(response.body).not_to have_text \"protected foobar\"\n      end\n    end\n\n    it \"search with empty result\" do\n      get \"search\", params: { q: \"abcdefghijklmnopqrstuvwxyz\" }\n      expect(response).to render_template(\"articles/error\", layout: false)\n      expect(assigns[:articles]).to eq []\n    end\n  end\n\n  describe \"#livesearch\" do\n    context \"with a query with several words\" do\n      before do\n        create(:article, body: \"hello world and im herer\")\n        create(:article, title: \"hello\", body: \"worldwide\")\n        create(:article)\n        get :live_search, params: { q: \"hello world\" }\n      end\n\n      it \"is valid\" do\n        expect(assigns(:articles).size).to eq(2)\n      end\n\n      it \"renders without layout\" do\n        expect(response).to render_template(layout: nil)\n      end\n\n      it \"renders template live_search\" do\n        expect(response).to render_template(\"live_search\")\n      end\n\n      it \"assigns @search the search string\" do\n        expect(assigns[:search]).to be_equal(controller.params[:q])\n      end\n    end\n  end\n\n  describe \"#archives\" do\n    let(:blog) { create :blog }\n\n    context \"for an archive with several articles\" do\n      let!(:articles) { create_list :article, 3 }\n\n      before do\n        get \"archives\"\n      end\n\n      it \"renders the correct template\" do\n        expect(response).to render_template(:archives)\n      end\n\n      it \"assigns the articles\" do\n        expect(assigns[:articles]).to match_array articles\n      end\n    end\n  end\n\n  describe \"#preview\" do\n    let!(:blog) { create(:blog) }\n\n    context \"with non logged user\" do\n      before do\n        get :preview, params: { id: create(:article).id }\n      end\n\n      it \"redirects to login\" do\n        expect(response).to redirect_to new_user_session_path\n      end\n    end\n\n    context \"with logged user\" do\n      let(:admin) { create(:user, :as_admin) }\n      let(:article) { create(:article, user: admin) }\n\n      before do\n        sign_in admin\n      end\n\n      it \"assignes article define with id\" do\n        get :preview, params: { id: article.id }\n        expect(assigns[:article]).to eq(article)\n      end\n\n      it \"assignes last article with id like parent_id\" do\n        draft = create(:article, parent_id: article.id)\n        get :preview, params: { id: article.id }\n        expect(assigns[:article]).to eq(draft)\n      end\n    end\n  end\n\n  describe \"#redirect\" do\n    describe \"with explicit redirects\" do\n      describe \"with empty relative_url_root\" do\n        it \"redirects from known URL\" do\n          create(:blog, base_url: \"http://test.host\")\n          create(:user)\n          create(:redirect)\n          get :redirect, params: { from: \"foo/bar\" }\n          expect(response).to redirect_to(\"http://test.host/someplace/else\")\n        end\n\n        it \"does not redirect from unknown URL\" do\n          create(:blog, base_url: \"http://test.host\")\n          create(:user)\n          create(:redirect)\n          expect { get :redirect, params: { from: \"something/that/isnt/there\" } }.\n            to raise_error ActiveRecord::RecordNotFound\n        end\n      end\n\n      # FIXME: Due to the changes in Rails 3 (no relative_url_root), this\n      # does not work anymore when the accessed URL does not match the blog's\n      # base_url at least partly. Do we still want to allow acces to the blog\n      # through non-standard URLs? What was the original purpose of these\n      # redirects?\n      describe \"and non-empty relative_url_root\" do\n        before do\n          create(:blog, base_url: \"http://test.host/blog\")\n          create(:user)\n        end\n\n        it \"redirects\" do\n          create(:redirect, from_path: \"foo/bar\", to_path: \"/someplace/else\")\n          get :redirect, params: { from: \"foo/bar\" }\n          assert_response 301\n          expect(response).to redirect_to(\"http://test.host/blog/someplace/else\")\n        end\n\n        it \"redirects if to_path includes relative_url_root\" do\n          create(:redirect, from_path: \"bar/foo\", to_path: \"/blog/someplace/else\")\n          get :redirect, params: { from: \"bar/foo\" }\n          assert_response 301\n          expect(response).to redirect_to(\"http://test.host/blog/someplace/else\")\n        end\n\n        it \"ignores the blog base_url if the to_path is a full uri\" do\n          create(:redirect, from_path: \"foo\", to_path: \"http://some.where/else\")\n          get :redirect, params: { from: \"foo\" }\n          assert_response 301\n          expect(response).to redirect_to(\"http://some.where/else\")\n        end\n      end\n    end\n\n    it \"gets good article with utf8 slug\" do\n      build_stubbed(:blog)\n      article = create(:article, title: \"\u30eb\u30d3\u30fc\",\n                                 published_at: Time.utc(2004, 6, 2))\n      get :redirect, params: { from: \"2004/06/02/\u30eb\u30d3\u30fc\" }\n      expect(assigns(:article)).to eq(article)\n    end\n\n    it \"gets good article with title with spaces\" do\n      build_stubbed(:blog)\n      article = create(:article, title: \"foo bar\",\n                                 published_at: Time.utc(2004, 6, 2))\n      get :redirect, params: { from: \"2004/06/02/foo-bar\" }\n      expect(assigns(:article)).to eq(article)\n    end\n\n    it \"gets good article with title with plus sign\" do\n      build_stubbed(:blog)\n      article = create(:article, title: \"foo+bar\",\n                                 published_at: Time.utc(2004, 6, 2))\n      get :redirect, params: { from: \"2004/06/02/foo-bar\" }\n      expect(assigns(:article)).to eq(article)\n    end\n\n    # NOTE: This is needed because Rails over-unescapes glob parameters.\n    it \"gets good article with pre-escaped utf8 slug using unescaped slug\" do\n      build_stubbed(:blog)\n      article = create(:article, permalink: \"%E3%83%AB%E3%83%93%E3%83%BC\",\n                                 published_at: Time.utc(2004, 6, 2))\n      get :redirect, params: { from: \"2004/06/02/\u30eb\u30d3\u30fc\" }\n      expect(assigns(:article)).to eq(article)\n    end\n\n    describe 'accessing old-style URL with \"articles\" as the first part' do\n      it \"redirects to article without url_root\" do\n        create(:blog, base_url: \"http://test.host\")\n        article = create(:article, permalink: \"second-blog-article\",\n                                   published_at: Time.utc(2004, 4, 1))\n        get :redirect, params: { from: \"articles/2004/04/01/second-blog-article\" }\n        assert_response 301\n        expect(response).to redirect_to article.permalink_url\n      end\n\n      it \"redirects to article with url_root\" do\n        create(:blog, base_url: \"http://test.host/blog\")\n        create(:article, permalink: \"second-blog-article\", published_at: Time.utc(2004, 4,\n                                                                                  1))\n        get :redirect, params: { from: \"articles/2004/04/01/second-blog-article\" }\n        assert_response 301\n        expect(response).\n          to redirect_to(\"http://test.host/blog/2004/04/01/second-blog-article\")\n      end\n\n      it \"redirects to article with articles in url_root\" do\n        create(:blog, base_url: \"http://test.host/aaa/articles/bbb\")\n        create(:article, permalink: \"second-blog-article\", published_at: Time.utc(2004, 4,\n                                                                                  1))\n        get :redirect, params: { from: \"articles/2004/04/01/second-blog-article\" }\n        assert_response 301\n        expect(response).\n          to redirect_to(\"http://test.host/aaa/articles/bbb/2004/04/01/second-blog-article\")\n      end\n\n      it \"should not redirect to an article from another blog\"\n    end\n\n    describe \"with permalink_format like %title%.html\" do\n      let!(:blog) { create(:blog, permalink_format: \"/%title%.html\") }\n      let!(:admin) { create(:user, :as_admin) }\n\n      before do\n        sign_in admin\n      end\n\n      context \"with an article\" do\n        let!(:article) do\n          create(:article, permalink: \"second-blog-article\", published_at: Time.utc(2004, 4,\n                                                                                    1))\n        end\n\n        context \"try redirect to an unknown location\" do\n          it \"raises RecordNotFound\" do\n            expect { get :redirect, params: { from: \"#{article.permalink}/foo/bar\" } }.\n              to raise_error ActiveRecord::RecordNotFound\n          end\n        end\n\n        describe \"accessing legacy URLs\" do\n          it \"redirects from default URL format\" do\n            get :redirect, params: { from: \"2004/04/01/second-blog-article\" }\n            expect(response).to redirect_to article.permalink_url\n          end\n\n          it 'redirects from old-style URL format with \"articles\" part' do\n            get :redirect, params: { from: \"articles/2004/04/01/second-blog-article\" }\n            expect(response).to redirect_to article.permalink_url\n          end\n        end\n      end\n\n      describe \"accessing an article\" do\n        let!(:article) do\n          create(:article, permalink: \"second-blog-article\",\n                           published_at: Time.utc(2004, 4, 1))\n        end\n\n        before do\n          get :redirect, params: { from: \"#{article.permalink}.html\" }\n        end\n\n        it \"renders template read to article\" do\n          expect(response).to render_template(\"articles/read\")\n        end\n\n        it \"assigns article1 to @article\" do\n          expect(assigns(:article)).to eq(article)\n        end\n\n        it \"article without tags should not have meta keywords\" do\n          article = create(:article)\n          get :redirect, params: { from: \"#{article.permalink}.html\" }\n          expect(assigns(:keywords)).to eq(\"\")\n        end\n      end\n\n      describe \"rendering as atom feed\" do\n        let!(:article) do\n          create(:article, permalink: \"second-blog-article\",\n                           published_at: Time.utc(2004, 4, 1))\n        end\n        let!(:trackback1) { create(:trackback, article: article, created_at: 1.day.ago) }\n\n        before do\n          get :redirect, params: { from: \"#{article.permalink}.html.atom\" }\n        end\n\n        it \"renders feedback atom feed for the article\" do\n          expect(assigns(:article)).to eq article\n          expect(response).to render_template(\"feedback_atom_feed\", layout: false)\n        end\n      end\n\n      describe \"rendering as rss feed\" do\n        let!(:article) do\n          create(:article, permalink: \"second-blog-article\",\n                           published_at: Time.utc(2004, 4, 1))\n        end\n        let!(:trackback1) { create(:trackback, article: article, created_at: 1.day.ago) }\n\n        before do\n          get :redirect, params: { from: \"#{article.permalink}.html.rss\" }\n        end\n\n        it \"renders feedback rss feed for the article\" do\n          expect(assigns(:article)).to eq article\n          expect(response).to render_template(\"feedback_rss_feed\", layout: false)\n        end\n      end\n    end\n\n    describe \"with a format containing a fixed component\" do\n      let!(:blog) { create(:blog, permalink_format: \"/foo/%title%\") }\n      let!(:article) { create(:article) }\n\n      it \"finds the article if the url matches all components\" do\n        get :redirect, params: { from: \"foo/#{article.permalink}\" }\n        expect(response).to be_successful\n      end\n\n      it \"does not find the article if the url does not match the fixed component\" do\n        expect { get :redirect, params: { from: \"bar/#{article.permalink}\" } }.\n          to raise_error ActiveRecord::RecordNotFound\n      end\n    end\n  end\n\n  describe \"#check_password\" do\n    render_views\n    let!(:article) { create(:article, password: \"password\") }\n\n    it \"shows article when given correct password\" do\n      post :check_password, xhr: true,\n                            params: { article: { id: article.id,\n                                                 password: article.password } }\n      expect(response.body).not_to have_selector('input[id=\"article_password\"]')\n    end\n\n    it \"shows password form when given incorrect password\" do\n      post :check_password, xhr: true,\n                            params: { article: { id: article.id,\n                                                 password: \"wrong password\" } }\n      expect(response.body).to have_selector('input[id=\"article_password\"]')\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire \"rails_helper\"\n\n# Test article rendering for installed themes\nRSpec.describe ArticlesController, type: :controller do\n  render_views\n\n  let(:blog) { create :blog }\n\n  with_each_theme do |theme, _view_path|\n    context \"with theme #{theme}\" do\n      before do\n        blog.theme = theme\n        blog.save!\n      end\n\n      describe \"#redirect\" do\n        let(:article) { create :article }\n        let(:from_param) { article.permalink_url.sub(%r{#{blog.base_url}/}, \"\") }\n\n        it \"successfully renders an article\" do\n          get :redirect, params: { from: from_param }\n          expect(response).to be_successful\n        end\n\n        context \"when the article has an excerpt\" do\n          let(:article) { create :article, excerpt: \"foo\", body: \"bar\" }\n\n          it \"does not render a continue reading link\" do\n            get :redirect, params: { from: from_param }\n\n            aggregate_failures do\n              expect(response.body).to have_text \"bar\"\n              expect(response.body).not_to have_text \"foo\"\n              expect(response.body).\n                not_to have_text I18n.t!(\"articles.article_excerpt.continue_reading\")\n            end\n          end\n        end\n\n        describe \"accessing an article\" do\n          let!(:article) { create(:article) }\n\n          before do\n            get :redirect, params: { from: from_param }\n          end\n\n          it \"has good rss feed link\" do\n            expect(response.body).\n              to have_selector(\"head>link[href=\\\"#{article.permalink_url}.rss\\\"]\",\n                               visible: :all)\n          end\n\n          it \"has good atom feed link\" do\n            expect(response.body).\n              to have_selector(\"head>link[href=\\\"#{article.permalink_url}.atom\\\"]\",\n                               visible: :all)\n          end\n\n          it \"has a canonical url\" do\n            expect(response.body).\n              to have_selector(\"head>link[href='#{article.permalink_url}']\",\n                               visible: :all)\n          end\n\n          it \"has a good title\" do\n            expect(response.body).\n              to have_selector(\"title\", text: \"A big article | test blog\",\n                                        visible: :all)\n          end\n        end\n\n        describe \"theme rendering\" do\n          let!(:article) { create(:article) }\n\n          it \"renders without errors when no comments or trackbacks are present\" do\n            get :redirect, params: { from: from_param }\n            expect(response).to be_successful\n          end\n\n          it \"renders without errors when recaptcha is enabled\" do\n            Recaptcha.configure do |config|\n              config.site_key = \"YourAPIkeysHere_yyyyyyyyyyyyyyyyy\"\n              config.secret_key = \"YourAPIkeysHere_xxxxxxxxxxxxxxxxx\"\n            end\n            blog.use_recaptcha = true\n            blog.save!\n            get :redirect, params: { from: from_param }\n            expect(response).to be_successful\n          end\n\n          it \"renders without errors when comments and trackbacks are present\" do\n            create :trackback, article: article\n            create :comment, article: article\n            get :redirect, params: { from: from_param }\n            expect(response).to be_successful\n          end\n        end\n\n        context \"when the article is password protected\" do\n          let(:article) { create(:article, password: \"password\") }\n\n          it \"article alone should be password protected\" do\n            get :redirect, params: { from: from_param }\n            expect(response.body).to have_selector('input[id=\"article_password\"]', count: 1)\n          end\n        end\n      end\n\n      describe \"#index\" do\n        let!(:user) { create :user }\n\n        context \"without any parameters\" do\n          let!(:article) { create(:article) }\n          let!(:note) { create(:note) }\n\n          before do\n            get :index\n          end\n\n          it \"has good link feed rss\" do\n            expect(response.body).\n              to have_selector('head>link[href=\"http://test.host/articles.rss\"]',\n                               visible: :all)\n          end\n\n          it \"has good link feed atom\" do\n            expect(response.body).\n              to have_selector('head>link[href=\"http://test.host/articles.atom\"]',\n                               visible: :all)\n          end\n\n          it \"has a canonical url\" do\n            expect(response.body).\n              to have_selector(\"head>link[href='#{blog.base_url}/']\", visible: :all)\n          end\n\n          it \"has good title\" do\n            expect(response.body).\n              to have_selector(\"title\", text: \"test blog | test subtitle\", visible: :all)\n          end\n        end\n\n        context \"when an article has an excerpt\" do\n          let!(:article) { create :article, excerpt: \"foo\", body: \"bar\" }\n\n          it \"renders a continue reading link\" do\n            get :index\n\n            aggregate_failures do\n              expect(response.body).not_to have_text \"bar\"\n              expect(response.body).to have_text \"foo\"\n              expect(response.body).\n                to have_text I18n.t!(\"articles.article_excerpt.continue_reading\")\n            end\n          end\n        end\n\n        context \"when requesting archives for a month\" do\n          before do\n            create(:article, published_at: Time.utc(2004, 4, 23))\n            get \"index\", params: { year: 2004, month: 4 }\n          end\n\n          it \"has a canonical url\" do\n            expect(response.body).\n              to have_selector(\"head>link[href='#{blog.base_url}/2004/4']\",\n                               visible: :all)\n          end\n\n          it \"has a good title\" do\n            expect(response.body).\n              to have_selector(\"title\", text: \"Archives for test blog\", visible: :all)\n          end\n        end\n      end\n\n      describe \"#search\" do\n        let!(:user) { create :user }\n\n        before do\n          create(:article,\n                 body: <<~MARKDOWN,\n                   in markdown format\n\n                    * we\n                    * use\n                   [ok](http://blog.ok.com) to define a link\n                 MARKDOWN\n                 text_filter_name: \"markdown\")\n          create(:article, body: \"xyz\")\n          get :search, params: { q: \"a\" }\n        end\n\n        it \"has good feed rss link\" do\n          expect(response.body).\n            to have_selector('head>link[href=\"http://test.host/search/a.rss\"]',\n                             visible: :all)\n        end\n\n        it \"has good feed atom link\" do\n          expect(response.body).\n            to have_selector('head>link[href=\"http://test.host/search/a.atom\"]',\n                             visible: :all)\n        end\n\n        it \"has a canonical url\" do\n          expect(response.body).\n            to have_selector(\"head>link[href='#{blog.base_url}/search/a']\",\n                             visible: :all)\n        end\n\n        it \"has a good title\" do\n          expect(response.body).\n            to have_selector(\"title\", text: \"Results for a | test blog\",\n                                      visible: :all)\n        end\n\n        it \"has content markdown interpret and without html tag\" do\n          expect(response.body).to have_selector(\"div\") do |div|\n            expect(div).\n              to match(\"in markdown format * we * use [ok](http://blog.ok.com)\" \\\n                       \" to define a link\")\n          end\n        end\n      end\n\n      describe \"#livesearch\" do\n        before do\n          create(:article, body: \"hello world and im herer\")\n          create(:article, title: \"hello\", body: \"worldwide\")\n          create(:article)\n          get :live_search, params: { q: \"hello world\" }\n        end\n\n        it \"does not have h3 tag\" do\n          expect(response.body).to have_selector(\"h3\")\n        end\n      end\n\n      describe \"#archives\" do\n        context \"with several articles\" do\n          let!(:articles) { create_list :article, 3 }\n\n          before do\n            get \"archives\"\n          end\n\n          it \"has the correct self-link and title\" do\n            expect(response.body).\n              to have_selector(\"head>link[href='#{blog.base_url}/archives']\",\n                               visible: :all).\n              and have_selector(\"title\", text: \"Archives for test blog\", visible: :all)\n          end\n\n          it \"shows the current month only once\" do\n            expect(response.body).\n              to have_css(\"h3\", count: 1).\n              and have_text I18n.l(articles.first.published_at,\n                                   format: :letters_month_with_year)\n          end\n        end\n\n        context \"with an article with tags\" do\n          it \"renders correctly\" do\n            create :article, keywords: \"foo, bar\"\n            get \"archives\"\n\n            expect(response.body).to have_text \"foo\"\n            expect(response.body).to have_text \"bar\"\n          end\n        end\n      end\n\n      describe \"#preview\" do\n        context \"with logged user\" do\n          let(:admin) { create(:user, :as_admin) }\n          let(:article) { create(:article, user: admin) }\n\n          before do\n            sign_in admin\n          end\n\n          it \"renders the regular read template\" do\n            get :preview, params: { id: article.id }\n            expect(response).to render_template(\"articles/read\")\n          end\n\n          context \"when the article has an excerpt\" do\n            let(:article) { create :article, excerpt: \"foo\", body: \"bar\", user: admin }\n\n            it \"does not render a continue reading link\" do\n              get :preview, params: { id: article.id }\n\n              aggregate_failures do\n                expect(response.body).to have_text \"bar\"\n                expect(response.body).not_to have_text \"foo\"\n                expect(response.body).\n                  not_to have_text I18n.t!(\"articles.article_excerpt.continue_reading\")\n              end\n            end\n          end\n        end\n      end\n\n      describe \"#check_password\" do\n        let!(:article) { create(:article, password: \"password\") }\n\n        it \"shows article when given correct password\" do\n          post :check_password, xhr: true,\n                                params: { article: { id: article.id,\n                                                     password: article.password } }\n          expect(response.body).not_to have_selector('input[id=\"article_password\"]')\n        end\n\n        it \"shows password form when given incorrect password\" do\n          post :check_password, xhr: true,\n                                params: { article: { id: article.id,\n                                                     password: \"wrong password\" } }\n          expect(response.body).to have_selector('input[id=\"article_password\"]')\n        end\n      end\n    end\n  end\nend\n"], "fixing_code": ["# frozen_string_literal: true\n\nclass ArticlesController < ContentController\n  before_action :login_required, only: [:preview, :preview_page]\n  before_action :auto_discovery_feed, only: [:show, :index]\n  before_action :verify_config\n\n  layout :theme_layout, except: [:trackback]\n\n  helper :'admin/base'\n\n  def index\n    wanted_types = this_blog.statuses_in_timeline ? [\"Article\", \"Note\"] : [\"Article\"]\n\n    limit = this_blog.per_page(params[:format])\n    articles_base = if params[:year].blank?\n                      this_blog.contents.published\n                    else\n                      this_blog.contents.published_at(params.values_at(:year, :month, :day))\n                    end\n    @articles = articles_base.includes(:user, :resources, :tags).\n      where(type: wanted_types).page(params[:page]).per(limit)\n\n    respond_to do |format|\n      format.html do\n        set_index_title_and_description(this_blog, params)\n        @keywords = this_blog.meta_keywords\n\n        render_paginated_index\n      end\n      format.atom do\n        render_articles_feed(\"atom\")\n      end\n      format.rss do\n        auto_discovery_feed(only_path: false)\n        render_articles_feed(\"rss\")\n      end\n    end\n  end\n\n  def search\n    @articles = this_blog.articles_matching(params[:q],\n                                            page: params[:page],\n                                            per_page: this_blog.per_page(params[:format]))\n    return error! if @articles.empty?\n\n    @page_title = this_blog.search_title_template.to_title(@articles, this_blog, params)\n    @description = this_blog.search_desc_template.to_title(@articles, this_blog, params)\n    respond_to do |format|\n      format.html { render \"search\" }\n      format.rss { render_articles_feed \"rss\" }\n      format.atom { render_articles_feed \"atom\" }\n    end\n  end\n\n  def live_search\n    @search = params[:q]\n    @articles = Article.search(@search)\n    render :live_search, layout: false\n  end\n\n  def preview\n    @article = Article.last_draft(params[:id])\n    @page_title = this_blog.article_title_template.to_title(@article, this_blog, params)\n    render \"read\"\n  end\n\n  def check_password\n    return unless request.xhr?\n\n    @article = Article.find(params[:article][:id])\n    if @article.password == params[:article][:password]\n      render partial: \"articles/full_article_content\", locals: { article: @article }\n    else\n      render partial: \"articles/password_form\", locals: { article: @article }\n    end\n  end\n\n  def redirect\n    from = extract_feed_format(params[:from])\n    factory = Article::Factory.new(this_blog, current_user)\n\n    @article = factory.match_permalink_format(from, this_blog.permalink_format)\n    return show_article if @article\n\n    # Redirect old version with /:year/:month/:day/:title to new format,\n    # because it's changed\n    [\"%year%/%month%/%day%/%title%\", \"articles/%year%/%month%/%day%/%title%\"].each do |part|\n      @article = factory.match_permalink_format(from, part)\n      if @article\n        return redirect_to URI.parse(@article.permalink_url).path,\n                           status: :moved_permanently\n      end\n    end\n\n    r = Redirect.find_by!(from_path: from)\n    # TODO: If linked to article, directly redirect to the article.\n    # Let redirection made outside of the blog on purpose (deal with it, Brakeman!)\n    redirect_to r.full_to_path, status: :moved_permanently if r\n  end\n\n  def archives\n    limit = this_blog.limit_archives_display\n    @articles = this_blog.published_articles.includes(:tags).page(params[:page]).per(limit)\n    @page_title = this_blog.archives_title_template.to_title(@articles, this_blog, params)\n    @keywords = this_blog.meta_keywords\n    @description = this_blog.archives_desc_template.to_title(@articles, this_blog, params)\n  end\n\n  def tag\n    redirect_to tags_path, status: :moved_permanently\n  end\n\n  def preview_page\n    @page = Page.find(params[:id])\n    render \"view_page\"\n  end\n\n  def view_page\n    @page = Page.published.find_by!(name: Array(params[:name]).join(\"/\"))\n    @page_title = @page.title\n    @description = this_blog.meta_description\n    @keywords = this_blog.meta_keywords\n  end\n\n  # TODO: Move to TextfilterController\n  def markup_help\n    filter = TextFilter.make_filter(params[:id])\n    if filter\n      render html: filter.commenthelp\n    else\n      render plain: \"Unknown filter\"\n    end\n  end\n\n  private\n\n  def set_index_title_and_description(blog, parameters)\n    @page_title = blog.home_title_template\n    @description = blog.home_desc_template\n    if parameters[:year]\n      @page_title = blog.archives_title_template\n      @description = blog.archives_desc_template\n    elsif parameters[:page]\n      @page_title = blog.paginated_title_template\n      @description = blog.paginated_desc_template\n    end\n    @page_title = @page_title.to_title(@articles, blog, parameters)\n    @description = @description.to_title(@articles, blog, parameters)\n  end\n\n  def verify_config\n    if !this_blog.configured?\n      redirect_to controller: \"setup\", action: \"index\"\n    elsif User.count == 0\n      redirect_to new_user_registration_path\n    else\n      true\n    end\n  end\n\n  # See an article We need define @article before\n  def show_article\n    auto_discovery_feed\n    respond_to do |format|\n      format.html do\n        @comment = Comment.new\n        @page_title = this_blog.article_title_template.to_title(@article, this_blog, params)\n        if @article.password.blank?\n          @description = this_blog.article_desc_template.\n            to_title(@article, this_blog, params)\n        end\n\n        @keywords = @article.tags.map(&:name).join(\", \")\n        render \"articles/#{@article.post_type}\"\n      end\n      format.atom { render_feedback_feed(\"atom\") }\n      format.rss { render_feedback_feed(\"rss\") }\n      format.xml { render_feedback_feed(\"atom\") }\n    end\n  rescue ActiveRecord::RecordNotFound\n    error!\n  end\n\n  def render_articles_feed(format)\n    render_cached_xml(\"index_#{format}_feed\", @articles)\n  end\n\n  def render_feedback_feed(format)\n    render_cached_xml(\"feedback_#{format}_feed\", @article)\n  end\n\n  def render_paginated_index\n    return error! if @articles.empty?\n\n    auto_discovery_feed(only_path: false)\n    render \"index\"\n  end\n\n  def extract_feed_format(from)\n    case from\n    when /^.*\\.rss$/\n      request.format = \"rss\"\n      from = from.gsub(/\\.rss/, \"\")\n    when /^.*\\.atom$/\n      request.format = \"atom\"\n      from = from.gsub(/\\.atom$/, \"\")\n    end\n    from\n  end\n\n  def error!\n    @message = I18n.t(\"errors.no_posts_found\")\n    render \"articles/error\", status: :ok\n  end\nend\n", "# frozen_string_literal: true\n\nrequire \"rails_helper\"\n\nRSpec.describe ArticlesController, type: :controller do\n  describe \"#tag\" do\n    let!(:blog) { create(:blog) }\n    let!(:user) { create :user }\n\n    it \"redirects to TagsContoller#index\" do\n      get :tag\n\n      expect(response).to redirect_to(tags_path)\n    end\n  end\n\n  describe \"#index\" do\n    let!(:blog) { create(:blog) }\n    let!(:user) { create :user }\n\n    context \"without any parameters\" do\n      let!(:article) { create(:article) }\n      let!(:note) { create(:note) }\n\n      before do\n        get :index\n      end\n\n      it { expect(response).to render_template(:index) }\n      it { expect(assigns[:articles]).not_to be_empty }\n\n      it \"has no meta keywords for a blog without keywords\" do\n        expect(assigns(:keywords)).to eq(\"\")\n      end\n    end\n\n    context \"for a month\" do\n      before do\n        create(:article, published_at: Time.utc(2004, 4, 23))\n        get \"index\", params: { year: 2004, month: 4 }\n      end\n\n      it \"renders template index\" do\n        expect(response).to render_template(:index)\n      end\n\n      it \"contains some articles\" do\n        expect(assigns[:articles]).not_to be_nil\n        expect(assigns[:articles]).not_to be_empty\n      end\n    end\n\n    context \"for feeds\" do\n      let!(:article1) { create(:article, created_at: 1.day.ago) }\n      let!(:article2) { create(:article, published_at: \"2004-04-01 12:00:00\") }\n\n      let(:trackback) { create(:trackback, article: article1, published_at: 1.day.ago) }\n\n      specify \"/articles.atom => an atom feed\" do\n        get \"index\", params: { format: \"atom\" }\n        expect(response).to be_successful\n        expect(response).to render_template(\"index_atom_feed\", layout: false)\n        expect(assigns(:articles)).to eq([article1, article2])\n      end\n\n      specify \"/articles.rss => an RSS 2.0 feed\" do\n        get \"index\", params: { format: \"rss\" }\n        expect(response).to be_successful\n        expect(response).to render_template(\"index_rss_feed\", layout: false)\n        expect(assigns(:articles)).to eq([article1, article2])\n      end\n\n      specify \"atom feed for archive should be valid\" do\n        get \"index\", params: { year: 2004, month: 4, format: \"atom\" }\n        expect(response).to render_template(\"index_atom_feed\", layout: false)\n        expect(assigns(:articles)).to eq([article2])\n      end\n\n      specify \"RSS feed for archive should be valid\" do\n        get \"index\", params: { year: 2004, month: 4, format: \"rss\" }\n        expect(response).to render_template(\"index_rss_feed\", layout: false)\n        expect(assigns(:articles)).to eq([article2])\n      end\n    end\n\n    context \"with an accept header\" do\n      before do\n        create(:article)\n      end\n\n      it \"ignores the HTTP Accept: header\" do\n        request.env[\"HTTP_ACCEPT\"] = \"application/atom+xml\"\n        get \"index\"\n        expect(response).to render_template(\"index\")\n      end\n    end\n\n    context \"with blog meta keywords to 'publify, is, amazing'\" do\n      let!(:blog) { create(:blog, meta_keywords: \"publify, is, amazing\") }\n\n      it \"index without option but with blog keywords should have meta keywords\" do\n        get \"index\"\n        expect(assigns(:keywords)).to eq(\"publify, is, amazing\")\n      end\n    end\n\n    context \"when blog settings is empty\" do\n      let!(:blog) { create(:blog, settings: {}) }\n\n      it \"redirects to setup\" do\n        get \"index\"\n        expect(response).to redirect_to(controller: \"setup\", action: \"index\")\n      end\n    end\n\n    context \"when there are no users\" do\n      before do\n        User.destroy_all\n      end\n\n      it \"redirects to signup\" do\n        get \"index\"\n        expect(response).to redirect_to new_user_registration_path\n      end\n    end\n  end\n\n  describe \"#search\" do\n    render_views\n\n    let!(:blog) { create(:blog) }\n    let!(:user) { create :user }\n    let!(:matching_article) { create(:article, body: \"public foobar\") }\n    let!(:not_matching_article) { create(:article, body: \"barbaz\") }\n    let!(:protected_article) do\n      create(:article, body: \"protected foobar\", password: \"secret!\")\n    end\n\n    it \"renders result with only matching articles\" do\n      get :search, params: { q: \"oba\" }\n\n      aggregate_failures do\n        expect(response).to render_template(:search)\n        expect(assigns[:articles]).to match_array [matching_article, protected_article]\n        expect(response.body).to have_text \"public foobar\"\n        expect(response.body).not_to have_text \"protected foobar\"\n      end\n    end\n\n    it \"renders feed rss by search\" do\n      get \"search\", params: { q: \"oba\", format: \"rss\" }\n      aggregate_failures do\n        expect(response).to be_successful\n        expect(response).to render_template(\"index_rss_feed\", layout: false)\n        expect(response.body).to have_text \"public foobar\"\n        expect(response.body).not_to have_text \"protected foobar\"\n      end\n    end\n\n    it \"renders feed atom by search\" do\n      get \"search\", params: { q: \"oba\", format: \"atom\" }\n      aggregate_failures do\n        expect(response).to be_successful\n        expect(response).to render_template(\"index_atom_feed\", layout: false)\n        expect(response.body).to have_text \"public foobar\"\n        expect(response.body).not_to have_text \"protected foobar\"\n      end\n    end\n\n    it \"search with empty result\" do\n      get \"search\", params: { q: \"abcdefghijklmnopqrstuvwxyz\" }\n      expect(response).to render_template(\"articles/error\", layout: false)\n      expect(assigns[:articles]).to eq []\n    end\n  end\n\n  describe \"#livesearch\" do\n    context \"with a query with several words\" do\n      before do\n        create(:article, body: \"hello world and im herer\")\n        create(:article, title: \"hello\", body: \"worldwide\")\n        create(:article)\n        get :live_search, params: { q: \"hello world\" }\n      end\n\n      it \"is valid\" do\n        expect(assigns(:articles).size).to eq(2)\n      end\n\n      it \"renders without layout\" do\n        expect(response).to render_template(layout: nil)\n      end\n\n      it \"renders template live_search\" do\n        expect(response).to render_template(\"live_search\")\n      end\n\n      it \"assigns @search the search string\" do\n        expect(assigns[:search]).to be_equal(controller.params[:q])\n      end\n    end\n  end\n\n  describe \"#archives\" do\n    let(:blog) { create :blog }\n\n    context \"for an archive with several articles\" do\n      let!(:articles) { create_list :article, 3 }\n\n      before do\n        get \"archives\"\n      end\n\n      it \"renders the correct template\" do\n        expect(response).to render_template(:archives)\n      end\n\n      it \"assigns the articles\" do\n        expect(assigns[:articles]).to match_array articles\n      end\n    end\n  end\n\n  describe \"#preview\" do\n    let!(:blog) { create(:blog) }\n\n    context \"with non logged user\" do\n      before do\n        get :preview, params: { id: create(:article).id }\n      end\n\n      it \"redirects to login\" do\n        expect(response).to redirect_to new_user_session_path\n      end\n    end\n\n    context \"with logged user\" do\n      let(:admin) { create(:user, :as_admin) }\n      let(:article) { create(:article, user: admin) }\n\n      before do\n        sign_in admin\n      end\n\n      it \"assignes article define with id\" do\n        get :preview, params: { id: article.id }\n        expect(assigns[:article]).to eq(article)\n      end\n\n      it \"assignes last article with id like parent_id\" do\n        draft = create(:article, parent_id: article.id)\n        get :preview, params: { id: article.id }\n        expect(assigns[:article]).to eq(draft)\n      end\n    end\n  end\n\n  describe \"#redirect\" do\n    describe \"with explicit redirects\" do\n      describe \"with empty relative_url_root\" do\n        it \"redirects from known URL\" do\n          create(:blog, base_url: \"http://test.host\")\n          create(:user)\n          create(:redirect)\n          get :redirect, params: { from: \"foo/bar\" }\n          expect(response).to redirect_to(\"http://test.host/someplace/else\")\n        end\n\n        it \"does not redirect from unknown URL\" do\n          create(:blog, base_url: \"http://test.host\")\n          create(:user)\n          create(:redirect)\n          expect { get :redirect, params: { from: \"something/that/isnt/there\" } }.\n            to raise_error ActiveRecord::RecordNotFound\n        end\n      end\n\n      # FIXME: Due to the changes in Rails 3 (no relative_url_root), this\n      # does not work anymore when the accessed URL does not match the blog's\n      # base_url at least partly. Do we still want to allow acces to the blog\n      # through non-standard URLs? What was the original purpose of these\n      # redirects?\n      describe \"and non-empty relative_url_root\" do\n        before do\n          create(:blog, base_url: \"http://test.host/blog\")\n          create(:user)\n        end\n\n        it \"redirects\" do\n          create(:redirect, from_path: \"foo/bar\", to_path: \"/someplace/else\")\n          get :redirect, params: { from: \"foo/bar\" }\n          assert_response 301\n          expect(response).to redirect_to(\"http://test.host/blog/someplace/else\")\n        end\n\n        it \"redirects if to_path includes relative_url_root\" do\n          create(:redirect, from_path: \"bar/foo\", to_path: \"/blog/someplace/else\")\n          get :redirect, params: { from: \"bar/foo\" }\n          assert_response 301\n          expect(response).to redirect_to(\"http://test.host/blog/someplace/else\")\n        end\n\n        it \"ignores the blog base_url if the to_path is a full uri\" do\n          create(:redirect, from_path: \"foo\", to_path: \"http://some.where/else\")\n          get :redirect, params: { from: \"foo\" }\n          assert_response 301\n          expect(response).to redirect_to(\"http://some.where/else\")\n        end\n      end\n    end\n\n    it \"gets good article with utf8 slug\" do\n      build_stubbed(:blog)\n      article = create(:article, title: \"\u30eb\u30d3\u30fc\",\n                                 published_at: Time.utc(2004, 6, 2))\n      get :redirect, params: { from: \"2004/06/02/\u30eb\u30d3\u30fc\" }\n      expect(assigns(:article)).to eq(article)\n    end\n\n    it \"gets good article with title with spaces\" do\n      build_stubbed(:blog)\n      article = create(:article, title: \"foo bar\",\n                                 published_at: Time.utc(2004, 6, 2))\n      get :redirect, params: { from: \"2004/06/02/foo-bar\" }\n      expect(assigns(:article)).to eq(article)\n    end\n\n    it \"gets good article with title with plus sign\" do\n      build_stubbed(:blog)\n      article = create(:article, title: \"foo+bar\",\n                                 published_at: Time.utc(2004, 6, 2))\n      get :redirect, params: { from: \"2004/06/02/foo-bar\" }\n      expect(assigns(:article)).to eq(article)\n    end\n\n    # NOTE: This is needed because Rails over-unescapes glob parameters.\n    it \"gets good article with pre-escaped utf8 slug using unescaped slug\" do\n      build_stubbed(:blog)\n      article = create(:article, permalink: \"%E3%83%AB%E3%83%93%E3%83%BC\",\n                                 published_at: Time.utc(2004, 6, 2))\n      get :redirect, params: { from: \"2004/06/02/\u30eb\u30d3\u30fc\" }\n      expect(assigns(:article)).to eq(article)\n    end\n\n    describe 'accessing old-style URL with \"articles\" as the first part' do\n      it \"redirects to article without url_root\" do\n        create(:blog, base_url: \"http://test.host\")\n        article = create(:article, permalink: \"second-blog-article\",\n                                   published_at: Time.utc(2004, 4, 1))\n        get :redirect, params: { from: \"articles/2004/04/01/second-blog-article\" }\n        assert_response 301\n        expect(response).to redirect_to article.permalink_url\n      end\n\n      it \"redirects to article with url_root\" do\n        create(:blog, base_url: \"http://test.host/blog\")\n        create(:article, permalink: \"second-blog-article\", published_at: Time.utc(2004, 4,\n                                                                                  1))\n        get :redirect, params: { from: \"articles/2004/04/01/second-blog-article\" }\n        assert_response 301\n        expect(response).\n          to redirect_to(\"http://test.host/blog/2004/04/01/second-blog-article\")\n      end\n\n      it \"redirects to article with articles in url_root\" do\n        create(:blog, base_url: \"http://test.host/aaa/articles/bbb\")\n        create(:article, permalink: \"second-blog-article\", published_at: Time.utc(2004, 4,\n                                                                                  1))\n        get :redirect, params: { from: \"articles/2004/04/01/second-blog-article\" }\n        assert_response 301\n        expect(response).\n          to redirect_to(\"http://test.host/aaa/articles/bbb/2004/04/01/second-blog-article\")\n      end\n\n      it \"should not redirect to an article from another blog\"\n    end\n\n    describe \"with permalink_format like %title%.html\" do\n      let!(:blog) { create(:blog, permalink_format: \"/%title%.html\") }\n      let!(:admin) { create(:user, :as_admin) }\n\n      before do\n        sign_in admin\n      end\n\n      context \"with an article\" do\n        let!(:article) do\n          create(:article, permalink: \"second-blog-article\", published_at: Time.utc(2004, 4,\n                                                                                    1))\n        end\n\n        context \"try redirect to an unknown location\" do\n          it \"raises RecordNotFound\" do\n            expect { get :redirect, params: { from: \"#{article.permalink}/foo/bar\" } }.\n              to raise_error ActiveRecord::RecordNotFound\n          end\n        end\n\n        describe \"accessing legacy URLs\" do\n          it \"redirects from default URL format\" do\n            get :redirect, params: { from: \"2004/04/01/second-blog-article\" }\n            expect(response).to redirect_to article.permalink_url\n          end\n\n          it 'redirects from old-style URL format with \"articles\" part' do\n            get :redirect, params: { from: \"articles/2004/04/01/second-blog-article\" }\n            expect(response).to redirect_to article.permalink_url\n          end\n        end\n      end\n\n      describe \"accessing an article\" do\n        let!(:article) do\n          create(:article, permalink: \"second-blog-article\",\n                           published_at: Time.utc(2004, 4, 1))\n        end\n\n        before do\n          get :redirect, params: { from: \"#{article.permalink}.html\" }\n        end\n\n        it \"renders template read to article\" do\n          expect(response).to render_template(\"articles/read\")\n        end\n\n        it \"assigns article1 to @article\" do\n          expect(assigns(:article)).to eq(article)\n        end\n\n        it \"article without tags should not have meta keywords\" do\n          article = create(:article)\n          get :redirect, params: { from: \"#{article.permalink}.html\" }\n          expect(assigns(:keywords)).to eq(\"\")\n        end\n      end\n\n      describe \"rendering as atom feed\" do\n        let!(:article) do\n          create(:article, permalink: \"second-blog-article\",\n                           published_at: Time.utc(2004, 4, 1))\n        end\n        let!(:trackback1) { create(:trackback, article: article, created_at: 1.day.ago) }\n\n        before do\n          get :redirect, params: { from: \"#{article.permalink}.html.atom\" }\n        end\n\n        it \"renders feedback atom feed for the article\" do\n          expect(assigns(:article)).to eq article\n          expect(response).to render_template(\"feedback_atom_feed\", layout: false)\n        end\n      end\n\n      describe \"rendering as rss feed\" do\n        let!(:article) do\n          create(:article, permalink: \"second-blog-article\",\n                           published_at: Time.utc(2004, 4, 1))\n        end\n        let!(:trackback1) { create(:trackback, article: article, created_at: 1.day.ago) }\n\n        before do\n          get :redirect, params: { from: \"#{article.permalink}.html.rss\" }\n        end\n\n        it \"renders feedback rss feed for the article\" do\n          expect(assigns(:article)).to eq article\n          expect(response).to render_template(\"feedback_rss_feed\", layout: false)\n        end\n      end\n    end\n\n    describe \"with a format containing a fixed component\" do\n      let!(:blog) { create(:blog, permalink_format: \"/foo/%title%\") }\n      let!(:article) { create(:article) }\n\n      it \"finds the article if the url matches all components\" do\n        get :redirect, params: { from: \"foo/#{article.permalink}\" }\n        expect(response).to be_successful\n      end\n\n      it \"does not find the article if the url does not match the fixed component\" do\n        expect { get :redirect, params: { from: \"bar/#{article.permalink}\" } }.\n          to raise_error ActiveRecord::RecordNotFound\n      end\n    end\n\n    context \"when the article is password protected\" do\n      render_views\n\n      let!(:blog) { create(:blog, permalink_format: \"/%title%.html\") }\n      let!(:article) do\n        create(:article, title: \"Secretive\", body: \"protected foobar\", password: \"password\")\n      end\n\n      it \"shows a password form for the article\" do\n        get :redirect, params: { from: \"secretive.html\" }\n        expect(response.body).to have_selector('input[id=\"article_password\"]', count: 1)\n      end\n\n      it \"does not include the article body anywhere\" do\n        get :redirect, params: { from: \"secretive.html\" }\n        expect(response.body).not_to include article.body\n      end\n    end\n  end\n\n  describe \"#check_password\" do\n    render_views\n    let!(:article) { create(:article, password: \"password\") }\n\n    it \"shows article when given correct password\" do\n      post :check_password, xhr: true,\n                            params: { article: { id: article.id,\n                                                 password: article.password } }\n      expect(response.body).not_to have_selector('input[id=\"article_password\"]')\n    end\n\n    it \"shows password form when given incorrect password\" do\n      post :check_password, xhr: true,\n                            params: { article: { id: article.id,\n                                                 password: \"wrong password\" } }\n      expect(response.body).to have_selector('input[id=\"article_password\"]')\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire \"rails_helper\"\n\n# Test article rendering for installed themes\nRSpec.describe ArticlesController, type: :controller do\n  render_views\n\n  let(:blog) { create :blog }\n\n  with_each_theme do |theme, _view_path|\n    context \"with theme #{theme}\" do\n      before do\n        blog.theme = theme\n        blog.save!\n      end\n\n      describe \"#redirect\" do\n        let(:article) { create :article }\n        let(:from_param) { article.permalink_url.sub(%r{#{blog.base_url}/}, \"\") }\n\n        it \"successfully renders an article\" do\n          get :redirect, params: { from: from_param }\n          expect(response).to be_successful\n        end\n\n        context \"when the article has an excerpt\" do\n          let(:article) { create :article, excerpt: \"foo\", body: \"bar\" }\n\n          it \"does not render a continue reading link\" do\n            get :redirect, params: { from: from_param }\n\n            aggregate_failures do\n              expect(response.body).to have_text \"bar\"\n              expect(response.body).not_to have_text \"foo\"\n              expect(response.body).\n                not_to have_text I18n.t!(\"articles.article_excerpt.continue_reading\")\n            end\n          end\n        end\n\n        describe \"accessing an article\" do\n          let!(:article) { create(:article) }\n\n          before do\n            get :redirect, params: { from: from_param }\n          end\n\n          it \"has good rss feed link\" do\n            expect(response.body).\n              to have_selector(\"head>link[href=\\\"#{article.permalink_url}.rss\\\"]\",\n                               visible: :all)\n          end\n\n          it \"has good atom feed link\" do\n            expect(response.body).\n              to have_selector(\"head>link[href=\\\"#{article.permalink_url}.atom\\\"]\",\n                               visible: :all)\n          end\n\n          it \"has a canonical url\" do\n            expect(response.body).\n              to have_selector(\"head>link[href='#{article.permalink_url}']\",\n                               visible: :all)\n          end\n\n          it \"has a good title\" do\n            expect(response.body).\n              to have_selector(\"title\", text: \"A big article | test blog\",\n                                        visible: :all)\n          end\n        end\n\n        describe \"theme rendering\" do\n          let!(:article) { create(:article) }\n\n          it \"renders without errors when no comments or trackbacks are present\" do\n            get :redirect, params: { from: from_param }\n            expect(response).to be_successful\n          end\n\n          it \"renders without errors when recaptcha is enabled\" do\n            Recaptcha.configure do |config|\n              config.site_key = \"YourAPIkeysHere_yyyyyyyyyyyyyyyyy\"\n              config.secret_key = \"YourAPIkeysHere_xxxxxxxxxxxxxxxxx\"\n            end\n            blog.use_recaptcha = true\n            blog.save!\n            get :redirect, params: { from: from_param }\n            expect(response).to be_successful\n          end\n\n          it \"renders without errors when comments and trackbacks are present\" do\n            create :trackback, article: article\n            create :comment, article: article\n            get :redirect, params: { from: from_param }\n            expect(response).to be_successful\n          end\n        end\n\n        context \"when the article is password protected\" do\n          let(:article) do\n            create(:article, title: \"Secretive\", body: \"protected foobar\",\n                             password: \"password\")\n          end\n\n          it \"shows a password form for the article\" do\n            get :redirect, params: { from: from_param }\n            expect(response.body).to have_selector('input[id=\"article_password\"]', count: 1)\n          end\n\n          it \"does not include the article body anywhere\" do\n            get :redirect, params: { from: from_param }\n            expect(response.body).not_to include article.body\n          end\n        end\n      end\n\n      describe \"#index\" do\n        let!(:user) { create :user }\n\n        context \"without any parameters\" do\n          let!(:article) { create(:article) }\n          let!(:note) { create(:note) }\n\n          before do\n            get :index\n          end\n\n          it \"has good link feed rss\" do\n            expect(response.body).\n              to have_selector('head>link[href=\"http://test.host/articles.rss\"]',\n                               visible: :all)\n          end\n\n          it \"has good link feed atom\" do\n            expect(response.body).\n              to have_selector('head>link[href=\"http://test.host/articles.atom\"]',\n                               visible: :all)\n          end\n\n          it \"has a canonical url\" do\n            expect(response.body).\n              to have_selector(\"head>link[href='#{blog.base_url}/']\", visible: :all)\n          end\n\n          it \"has good title\" do\n            expect(response.body).\n              to have_selector(\"title\", text: \"test blog | test subtitle\", visible: :all)\n          end\n        end\n\n        context \"when an article has an excerpt\" do\n          let!(:article) { create :article, excerpt: \"foo\", body: \"bar\" }\n\n          it \"renders a continue reading link\" do\n            get :index\n\n            aggregate_failures do\n              expect(response.body).not_to have_text \"bar\"\n              expect(response.body).to have_text \"foo\"\n              expect(response.body).\n                to have_text I18n.t!(\"articles.article_excerpt.continue_reading\")\n            end\n          end\n        end\n\n        context \"when requesting archives for a month\" do\n          before do\n            create(:article, published_at: Time.utc(2004, 4, 23))\n            get \"index\", params: { year: 2004, month: 4 }\n          end\n\n          it \"has a canonical url\" do\n            expect(response.body).\n              to have_selector(\"head>link[href='#{blog.base_url}/2004/4']\",\n                               visible: :all)\n          end\n\n          it \"has a good title\" do\n            expect(response.body).\n              to have_selector(\"title\", text: \"Archives for test blog\", visible: :all)\n          end\n        end\n      end\n\n      describe \"#search\" do\n        let!(:user) { create :user }\n\n        before do\n          create(:article,\n                 body: <<~MARKDOWN,\n                   in markdown format\n\n                    * we\n                    * use\n                   [ok](http://blog.ok.com) to define a link\n                 MARKDOWN\n                 text_filter_name: \"markdown\")\n          create(:article, body: \"xyz\")\n          get :search, params: { q: \"a\" }\n        end\n\n        it \"has good feed rss link\" do\n          expect(response.body).\n            to have_selector('head>link[href=\"http://test.host/search/a.rss\"]',\n                             visible: :all)\n        end\n\n        it \"has good feed atom link\" do\n          expect(response.body).\n            to have_selector('head>link[href=\"http://test.host/search/a.atom\"]',\n                             visible: :all)\n        end\n\n        it \"has a canonical url\" do\n          expect(response.body).\n            to have_selector(\"head>link[href='#{blog.base_url}/search/a']\",\n                             visible: :all)\n        end\n\n        it \"has a good title\" do\n          expect(response.body).\n            to have_selector(\"title\", text: \"Results for a | test blog\",\n                                      visible: :all)\n        end\n\n        it \"has content markdown interpret and without html tag\" do\n          expect(response.body).to have_selector(\"div\") do |div|\n            expect(div).\n              to match(\"in markdown format * we * use [ok](http://blog.ok.com)\" \\\n                       \" to define a link\")\n          end\n        end\n      end\n\n      describe \"#livesearch\" do\n        before do\n          create(:article, body: \"hello world and im herer\")\n          create(:article, title: \"hello\", body: \"worldwide\")\n          create(:article)\n          get :live_search, params: { q: \"hello world\" }\n        end\n\n        it \"does not have h3 tag\" do\n          expect(response.body).to have_selector(\"h3\")\n        end\n      end\n\n      describe \"#archives\" do\n        context \"with several articles\" do\n          let!(:articles) { create_list :article, 3 }\n\n          before do\n            get \"archives\"\n          end\n\n          it \"has the correct self-link and title\" do\n            expect(response.body).\n              to have_selector(\"head>link[href='#{blog.base_url}/archives']\",\n                               visible: :all).\n              and have_selector(\"title\", text: \"Archives for test blog\", visible: :all)\n          end\n\n          it \"shows the current month only once\" do\n            expect(response.body).\n              to have_css(\"h3\", count: 1).\n              and have_text I18n.l(articles.first.published_at,\n                                   format: :letters_month_with_year)\n          end\n        end\n\n        context \"with an article with tags\" do\n          it \"renders correctly\" do\n            create :article, keywords: \"foo, bar\"\n            get \"archives\"\n\n            expect(response.body).to have_text \"foo\"\n            expect(response.body).to have_text \"bar\"\n          end\n        end\n      end\n\n      describe \"#preview\" do\n        context \"with logged user\" do\n          let(:admin) { create(:user, :as_admin) }\n          let(:article) { create(:article, user: admin) }\n\n          before do\n            sign_in admin\n          end\n\n          it \"renders the regular read template\" do\n            get :preview, params: { id: article.id }\n            expect(response).to render_template(\"articles/read\")\n          end\n\n          context \"when the article has an excerpt\" do\n            let(:article) { create :article, excerpt: \"foo\", body: \"bar\", user: admin }\n\n            it \"does not render a continue reading link\" do\n              get :preview, params: { id: article.id }\n\n              aggregate_failures do\n                expect(response.body).to have_text \"bar\"\n                expect(response.body).not_to have_text \"foo\"\n                expect(response.body).\n                  not_to have_text I18n.t!(\"articles.article_excerpt.continue_reading\")\n              end\n            end\n          end\n        end\n      end\n\n      describe \"#check_password\" do\n        let!(:article) { create(:article, password: \"password\") }\n\n        it \"shows article when given correct password\" do\n          post :check_password, xhr: true,\n                                params: { article: { id: article.id,\n                                                     password: article.password } }\n          expect(response.body).not_to have_selector('input[id=\"article_password\"]')\n        end\n\n        it \"shows password form when given incorrect password\" do\n          post :check_password, xhr: true,\n                                params: { article: { id: article.id,\n                                                     password: \"wrong password\" } }\n          expect(response.body).to have_selector('input[id=\"article_password\"]')\n        end\n      end\n    end\n  end\nend\n"], "filenames": ["publify_core/app/controllers/articles_controller.rb", "publify_core/spec/controllers/articles_controller_spec.rb", "spec/controllers/articles_controller_spec.rb"], "buggy_code_start_loc": [169, 485, 102], "buggy_code_end_loc": [170, 485, 106], "fixing_code_start_loc": [169, 486, 102], "fixing_code_end_loc": [173, 505, 115], "type": "CWE-863", "message": "Leaking password protected articles content due to improper access control in GitHub repository publify/publify prior to 9.2.8. Attackers can leverage this vulnerability to view the contents of any password-protected article present on the publify website, compromising confidentiality and integrity of users.", "other": {"cve": {"id": "CVE-2022-1553", "sourceIdentifier": "security@huntr.dev", "published": "2022-05-16T15:15:09.977", "lastModified": "2022-05-25T17:42:51.933", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Leaking password protected articles content due to improper access control in GitHub repository publify/publify prior to 9.2.8. Attackers can leverage this vulnerability to view the contents of any password-protected article present on the publify website, compromising confidentiality and integrity of users."}, {"lang": "es", "value": "Un Filtrado del contenido de los art\u00edculos protegidos por contrase\u00f1a debido a un control de acceso inapropiado en el repositorio GitHub publify/publify versiones anteriores a 9.2.8. Los atacantes pueden aprovechar esta vulnerabilidad para visualizar el contenido de cualquier art\u00edculo protegido por contrase\u00f1a presente en el sitio web de publify, comprometiendo la confidencialidad e integridad de los usuarios"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.2, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-863"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-284"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:publify_project:publify:*:*:*:*:*:*:*:*", "versionEndExcluding": "9.2.8", "matchCriteriaId": "3310B9A3-CF26-460A-8F77-9D245D34243B"}]}]}], "references": [{"url": "https://github.com/publify/publify/commit/1a78f16f460847274265a12a9555b3524892d7db", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/b398e4c9-6cdf-4973-ad86-da796cde221f", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/publify/publify/commit/1a78f16f460847274265a12a9555b3524892d7db"}}