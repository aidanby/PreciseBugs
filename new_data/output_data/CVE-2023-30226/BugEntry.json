{"buggy_code": ["// SPDX-FileCopyrightText: 2021 08A <08A@riseup.net>\n// SPDX-FileCopyrightText: 2008-2020 nibble <nibble.ds@gmail.com>\n// SPDX-FileCopyrightText: 2008-2020 pancake <pancake@nopcode.org>\n// SPDX-FileCopyrightText: 2008-2020 alvaro_fe <alvaro.felipe91@gmail.com>\n// SPDX-License-Identifier: LGPL-3.0-only\n\n#include \"elf.h\"\n\n#define EF_MIPS_ABI_O32 0x00001000 /* O32 ABI.  */\n#define EF_MIPS_ABI_O64 0x00002000 /* O32 extended for 64 bit.  */\n#define EF_MIPS_ABI     0x0000f000\n\n#define VERSYM_VERSION 0x7fff\n\nstruct mips_bits_translation {\n\tElf_(Word) type;\n\tint bits;\n};\n\nstruct section_note_osabi_translation {\n\tconst char *note_name;\n\tconst char *os_name;\n};\n\nstruct machine_name_translation {\n\tElf_(Half) machine;\n\tconst char *name;\n};\n\nstruct class_translation {\n\tunsigned char class;\n\tconst char *name;\n};\n\nstruct cpu_mips_translation {\n\tElf_(Word) arch;\n\tconst char *name;\n};\n\nstruct arch_translation {\n\tElf_(Half) arch;\n\tconst char *name;\n};\n\nstruct ver_flags_translation {\n\tut32 flag;\n\tconst char *name;\n};\n\nstatic const struct mips_bits_translation mips_bits_translation_table[] = {\n\t{ EF_MIPS_ARCH_1, 32 },\n\t{ EF_MIPS_ARCH_2, 32 },\n\t{ EF_MIPS_ARCH_3, 32 },\n\t{ EF_MIPS_ARCH_4, 32 },\n\t{ EF_MIPS_ARCH_5, 32 },\n\t{ EF_MIPS_ARCH_32, 32 },\n\t{ EF_MIPS_ARCH_64, 64 },\n\t{ EF_MIPS_ARCH_32R2, 32 },\n\t{ EF_MIPS_ARCH_64R2, 64 }\n};\n\nstatic const struct section_note_osabi_translation section_note_osabi_translation_table[] = {\n\t{ \".note.openbsd.ident\", \"openbsd\" },\n\t{ \".note.minix.ident\", \"minix\" },\n\t{ \".note.netbsd.ident\", \"netbsd\" },\n\t{ \".note.android.ident\", \"android\" }\n};\n\nstatic const struct machine_name_translation machine_name_translation_table[] = {\n\t{ EM_NONE, \"No machine\" },\n\t{ EM_M32, \"AT&T WE 32100\" },\n\t{ EM_SPARC, \"SUN SPARC\" },\n\t{ EM_386, \"Intel 80386\" },\n\t{ EM_68K, \"Motorola m68k family\" },\n\t{ EM_88K, \"Motorola m88k family\" },\n\t{ EM_860, \"Intel 80860\" },\n\t{ EM_MIPS, \"MIPS R3000\" },\n\t{ EM_S370, \"IBM System/370\" },\n\t{ EM_MIPS_RS3_LE, \"MIPS R3000 little-endian\" },\n\t{ EM_PARISC, \"HPPA\" },\n\t{ EM_VPP500, \"Fujitsu VPP500\" },\n\t{ EM_SPARC32PLUS, \"Sun's \\\"v8plus\\\"\" },\n\t{ EM_960, \"Intel 80960\" },\n\t{ EM_PPC, \"PowerPC\" },\n\t{ EM_PPC64, \"PowerPC 64-bit\" },\n\t{ EM_S390, \"IBM S390\" },\n\t{ EM_V800, \"NEC V800 series\" },\n\t{ EM_FR20, \"Fujitsu FR20\" },\n\t{ EM_RH32, \"TRW RH-32\" },\n\t{ EM_RCE, \"Motorola RCE\" },\n\t{ EM_ARM, \"ARM\" },\n\t{ EM_BLACKFIN, \"Analog Devices Blackfin\" },\n\t{ EM_FAKE_ALPHA, \"Digital Alpha\" },\n\t{ EM_SH, \"Hitachi SH\" },\n\t{ EM_SPARCV9, \"SPARC v9 64-bit\" },\n\t{ EM_TRICORE, \"Siemens Tricore\" },\n\t{ EM_ARC, \"Argonaut RISC Core\" },\n\t{ EM_H8_300, \"Hitachi H8/300\" },\n\t{ EM_H8_300H, \"Hitachi H8/300H\" },\n\t{ EM_H8S, \"Hitachi H8S\" },\n\t{ EM_H8_500, \"Hitachi H8/500\" },\n\t{ EM_IA_64, \"Intel Merced\" },\n\t{ EM_MIPS_X, \"Stanford MIPS-X\" },\n\t{ EM_COLDFIRE, \"Motorola Coldfire\" },\n\t{ EM_68HC12, \"Motorola M68HC12\" },\n\t{ EM_MMA, \"Fujitsu MMA Multimedia Accelerator\" },\n\t{ EM_PCP, \"Siemens PCP\" },\n\t{ EM_NCPU, \"Sony nCPU embeeded RISC\" },\n\t{ EM_NDR1, \"Denso NDR1 microprocessor\" },\n\t{ EM_STARCORE, \"Motorola Start*Core processor\" },\n\t{ EM_ME16, \"Toyota ME16 processor\" },\n\t{ EM_ST100, \"STMicroelectronic ST100 processor\" },\n\t{ EM_TINYJ, \"Advanced Logic Corp. Tinyj emb.fam\" },\n\t{ EM_X86_64, \"AMD x86-64 architecture\" },\n\t{ EM_LANAI, \"32bit LANAI architecture\" },\n\t{ EM_PDSP, \"Sony DSP Processor\" },\n\t{ EM_PDP10, \"Digital Equipment Corp. PDP-10\" },\n\t{ EM_PDP11, \"Digital Equipment Corp. PDP-11\" },\n\t{ EM_FX66, \"Siemens FX66 microcontroller\" },\n\t{ EM_ST9PLUS, \"STMicroelectronics ST9+ 8/16 mc\" },\n\t{ EM_ST7, \"STmicroelectronics ST7 8 bit mc\" },\n\t{ EM_68HC16, \"Motorola MC68HC16 microcontroller\" },\n\t{ EM_68HC11, \"Motorola MC68HC11 microcontroller\" },\n\t{ EM_68HC08, \"Motorola MC68HC08 microcontroller\" },\n\t{ EM_68HC05, \"Motorola MC68HC05 microcontroller\" },\n\t{ EM_SVX, \"Silicon Graphics SVx\" },\n\t{ EM_ST19, \"STMicroelectronics ST19 8 bit mc\" },\n\t{ EM_VAX, \"Digital VAX\" },\n\t{ EM_CRIS, \"Axis Communications 32-bit embedded processor\" },\n\t{ EM_JAVELIN, \"Infineon Technologies 32-bit embedded processor\" },\n\t{ EM_FIREPATH, \"Element 14 64-bit DSP Processor\" },\n\t{ EM_ZSP, \"LSI Logic 16-bit DSP Processor\" },\n\t{ EM_MMIX, \"Donald Knuth's educational 64-bit processor\" },\n\t{ EM_HUANY, \"Harvard University machine-independent object files\" },\n\t{ EM_PRISM, \"SiTera Prism\" },\n\t{ EM_AVR, \"Atmel AVR 8-bit microcontroller\" },\n\t{ EM_FR30, \"Fujitsu FR30\" },\n\t{ EM_D10V, \"Mitsubishi D10V\" },\n\t{ EM_D30V, \"Mitsubishi D30V\" },\n\t{ EM_V850, \"NEC v850\" },\n\t{ EM_M32R, \"Mitsubishi M32R\" },\n\t{ EM_MN10300, \"Matsushita MN10300\" },\n\t{ EM_MN10200, \"Matsushita MN10200\" },\n\t{ EM_PJ, \"picoJava\" },\n\t{ EM_OPENRISC, \"OpenRISC 32-bit embedded processor\" },\n\t{ EM_ARC_A5, \"ARC Cores Tangent-A5\" },\n\t{ EM_XTENSA, \"Tensilica Xtensa Architecture\" },\n\t{ EM_AARCH64, \"ARM aarch64\" },\n\t{ EM_PROPELLER, \"Parallax Propeller\" },\n\t{ EM_MICROBLAZE, \"Xilinx MicroBlaze\" },\n\t{ EM_RISCV, \"RISC V\" },\n\t{ EM_VIDEOCORE3, \"VideoCore III\" },\n\t{ EM_VIDEOCORE4, \"VideoCore IV\" },\n\t{ EM_LATTICEMICO32, \"RISC processor for Lattice FPGA architecture\" },\n\t{ EM_SE_C17, \"Seiko Epson C17 family\" },\n\t{ EM_TI_C6000, \"The Texas Instruments TMS320C6000 DSP family\" },\n\t{ EM_TI_C2000, \"The Texas Instruments TMS320C2000 DSP family\" },\n\t{ EM_TI_C5500, \"The Texas Instruments TMS320C55x DSP family\" },\n\t{ EM_TI_ARP32, \"Texas Instruments Application Specific RISC Processor, 32bit fetch\" },\n\t{ EM_TI_PRU, \"Texas Instruments Programmable Realtime Unit\" },\n\t{ EM_MMDSP_PLUS, \"STMicroelectronics 64bit VLIW Data Signal Processor\" },\n\t{ EM_CYPRESS_M8C, \"Cypress M8C microprocessor\" },\n\t{ EM_R32C, \"Renesas R32C series microprocessors\" },\n\t{ EM_TRIMEDIA, \"NXP Semiconductors TriMedia architecture family\" },\n\t{ EM_QDSP6, \"QUALCOMM DSP6 Processor\" }, // Nonstandard\n\t{ EM_8051, \"Intel 8051 and variants\" },\n\t{ EM_STXP7X, \"STMicroelectronics STxP7x family of configurable and extensible RISC processors\" },\n\t{ EM_NDS32, \"Andes Technology compact code size embedded RISC processor family\" },\n\t{ EM_ECOG1, \"Cyan Technology eCOG1X family\" },\n\t{ EM_MAXQ30, \"Dallas Semiconductor MAXQ30 Core Micro-controllers\" },\n\t{ EM_XIMO16, \"New Japan Radio (NJR) 16-bit DSP Processor\" },\n\t{ EM_MANIK, \"M2000 Reconfigurable RISC Microprocessor\" },\n\t{ EM_CRAYNV2, \"Cray Inc. NV2 vector architecture\" },\n\t{ EM_RX, \"Renesas RX family\" },\n\t{ EM_METAG, \"Imagination Technologies META processor architecture\" },\n\t{ EM_MCST_ELBRUS, \"MCST Elbrus general purpose hardware architecture\" },\n\t{ EM_ECOG16, \"Cyan Technology eCOG16 family\" },\n\t{ EM_CR16, \"National Semiconductor CompactRISC CR16 16-bit microprocessor\" },\n\t{ EM_ETPU, \"Freescale Extended Time Processing Unit\" },\n\t{ EM_SLE9X, \"Infineon Technologies SLE9X core\" },\n\t{ EM_L10M, \"Intel L10M\" },\n\t{ EM_K10M, \"Intel K10M\" },\n\t{ EM_AVR32, \"Atmel Corporation 32-bit microprocessor family\" },\n\t{ EM_STM8, \"STMicroeletronics STM8 8-bit microcontroller\" },\n\t{ EM_TILE64, \"Tilera TILE64 multicore architecture family\" },\n\t{ EM_TILEPRO, \"Tilera TILEPro multicore architecture family\" },\n\t{ EM_CUDA, \"NVIDIA CUDA architecture\" },\n\t{ EM_TILEGX, \"Tilera TILE-Gx multicore architecture family\" },\n\t{ EM_CLOUDSHIELD, \"CloudShield architecture family\" },\n\t{ EM_COREA_1ST, \"KIPO-KAIST Core-A 1st generation processor family\" },\n\t{ EM_COREA_2ND, \"KIPO-KAIST Core-A 2nd generation processor family\" },\n\t{ EM_ARC_COMPACT2, \"Synopsys ARCompact V2\" },\n\t{ EM_OPEN8, \"Open8 8-bit RISC soft processor core\" },\n\t{ EM_RL78, \"Renesas RL78 family\" },\n\t{ EM_VIDEOCORE5, \"Broadcom VideoCore V processor\" },\n\t{ EM_78KOR, \"Renesas 78KOR family\" },\n\t{ EM_BA1, \"Beyond BA1 CPU architecture\" },\n\t{ EM_BA2_NON_STANDARD, \"Beyond BA2 CPU architecture\" },\n\t{ EM_BA2, \"Beyond BA2 CPU architecture\" },\n\t{ EM_XCORE, \"XMOS xCORE processor family\" },\n\t{ EM_MCHP_PIC, \"Microchip 8-bit PIC(r) family\" },\n\t{ EM_INTEL205, \"Reserved by Intel\" },\n\t{ EM_INTEL206, \"Reserved by Intel\" },\n\t{ EM_INTEL207, \"Reserved by Intel\" },\n\t{ EM_INTEL208, \"Reserved by Intel\" },\n\t{ EM_INTEL209, \"Reserved by Intel\" },\n\t{ EM_KM32, \"KM211 KM32 32-bit processor\" },\n\t{ EM_KMX32, \"KM211 KMX32 32-bit processor\" },\n\t{ EM_KMX16, \"KM211 KMX16 16-bit processor\" },\n\t{ EM_KMX8, \"KM211 KMX8 8-bit processor\" },\n\t{ EM_KVARC, \"KM211 KVARC processor\" },\n\t{ EM_CDP, \"Paneve CDP architecture family\" },\n\t{ EM_COGE, \"Cognitive Smart Memory Processor\" },\n\t{ EM_COOL, \"Bluechip Systems CoolEngine\" },\n\t{ EM_NORC, \"Nanoradio Optimized RISC\" },\n\t{ EM_CSR_KALIMBA, \"CSR Kalimba architecture family\" },\n\t{ EM_Z80, \"Zilog Z80\" },\n\t{ EM_VISIUM, \"Controls and Data Services VISIUMcore processor\" },\n\t{ EM_FT32, \"FTDI Chip FT32 high performance 32-bit RISC architecture\" },\n\t{ EM_MOXIE, \"Moxie processor family\" },\n\t{ EM_AMDGPU, \"AMD GPU architecture\" },\n\t{ EM_BPF, \"Linux BPF\" },\n\t{ EM_KVX, \"Kalray VLIW core of the MPPA processor family\" },\n};\n\nstatic const struct class_translation class_translation_table[] = {\n\t{ ELFCLASSNONE, \"none\" },\n\t{ ELFCLASS32, \"ELF32\" },\n\t{ ELFCLASS64, \"ELF64\" }\n};\n\nstatic const struct cpu_mips_translation cpu_mips_translation_table[] = {\n\t{ EF_MIPS_ARCH_1, \"mips1\" },\n\t{ EF_MIPS_ARCH_2, \"mips2\" },\n\t{ EF_MIPS_ARCH_3, \"mips3\" },\n\t{ EF_MIPS_ARCH_4, \"mips4\" },\n\t{ EF_MIPS_ARCH_5, \"mips5\" },\n\t{ EF_MIPS_ARCH_32, \"mips32\" },\n\t{ EF_MIPS_ARCH_64, \"mips64\" },\n\t{ EF_MIPS_ARCH_32R2, \"mips32r2\" },\n\t{ EF_MIPS_ARCH_64R2, \"mips64r2\" },\n};\n\nstatic const struct arch_translation arch_translation_table[] = {\n\t{ EM_ARC, \"arc\" },\n\t{ EM_ARC_A5, \"arc\" },\n\t{ EM_AVR, \"avr\" },\n\t{ EM_BA2_NON_STANDARD, \"ba2\" },\n\t{ EM_BA2, \"ba2\" },\n\t{ EM_CRIS, \"cris\" },\n\t{ EM_68K, \"m68k\" },\n\t{ EM_MIPS, \"mips\" },\n\t{ EM_MIPS_RS3_LE, \"mips\" },\n\t{ EM_MIPS_X, \"mips\" },\n\t{ EM_MCST_ELBRUS, \"elbrus\" },\n\t{ EM_TRICORE, \"tricore\" },\n\t{ EM_RCE, \"mcore\" },\n\t{ EM_ARM, \"arm\" },\n\t{ EM_AARCH64, \"arm\" },\n\t{ EM_QDSP6, \"hexagon\" },\n\t{ EM_BLACKFIN, \"blackfin\" },\n\t{ EM_SPARC, \"sparc\" },\n\t{ EM_SPARC32PLUS, \"sparc\" },\n\t{ EM_SPARCV9, \"sparc\" },\n\t{ EM_PPC, \"ppc\" },\n\t{ EM_PPC64, \"ppc\" },\n\t{ EM_PARISC, \"hppa\" },\n\t{ EM_PROPELLER, \"propeller\" },\n\t{ EM_MICROBLAZE, \"microblaze.gnu\" },\n\t{ EM_RISCV, \"riscv\" },\n\t{ EM_VAX, \"vax\" },\n\t{ EM_XTENSA, \"xtensa\" },\n\t{ EM_LANAI, \"lanai\" },\n\t{ EM_VIDEOCORE3, \"vc4\" },\n\t{ EM_VIDEOCORE4, \"vc4\" },\n\t{ EM_MSP430, \"msp430\" },\n\t{ EM_SH, \"sh\" },\n\t{ EM_V800, \"v850\" },\n\t{ EM_V850, \"v850\" },\n\t{ EM_IA_64, \"ia64\" },\n\t{ EM_S390, \"sysz\" },\n\t{ EM_386, \"x86\" },\n\t{ EM_X86_64, \"x86\" },\n\t{ EM_NONE, \"null\" },\n\t{ EM_BPF, \"bpf\" },\n\t{ EM_KVX, \"kvx\" },\n};\n\nstatic const struct ver_flags_translation ver_flags_translation_table[] = {\n\t{ VER_FLG_BASE, \"BASE \" },\n\t{ VER_FLG_BASE | VER_FLG_WEAK, \"| \" },\n\t{ VER_FLG_WEAK, \"WEAK \" },\n\t{ ~(VER_FLG_BASE | VER_FLG_WEAK), \"| <unknown>\" }\n};\n\nstatic ut64 get_main_offset_from_symbol(ELFOBJ *bin) {\n\tRzBinElfSymbol *symbol;\n\trz_bin_elf_foreach_symbols(bin, symbol) {\n\t\tif (symbol->name && !strcmp(symbol->name, \"main\")) {\n\t\t\tif (symbol->paddr != UT64_MAX) {\n\t\t\t\treturn symbol->paddr;\n\t\t\t}\n\n\t\t\treturn symbol->vaddr;\n\t\t}\n\t}\n\n\treturn UT64_MAX;\n}\n\nstatic ut64 get_main_offset_linux_64_pie(ELFOBJ *bin, ut64 entry, ut8 *buf) {\n\t/* linux64 pie main -- probably buggy in some cases */\n\tint bo = 29; // Begin offset may vary depending on the entry prelude\n\t// endbr64 - fedora bins have this\n\tif (buf[0] == 0xf3 && buf[1] == 0x0f && buf[2] == 0x1e && buf[3] == 0xfa) {\n\t\t// Change begin offset if binary starts with 'endbr64'\n\t\tbo = 33;\n\t\t// double xor for init and fini\n\t\tif (!memcmp(buf + 19, \"\\x45\\x31\\xc0\\x31\\xc9\", 5)) {\n\t\t\tbo = 24;\n\t\t}\n\t}\n\tif (buf[bo] == 0x48) {\n\t\tut8 ch = buf[bo + 1];\n\t\tif (ch == 0x8d) { // lea rdi, qword [rip + MAINDELTA]\n\t\t\tut8 *p = buf + bo + 3;\n\t\t\tst32 maindelta = (st32)rz_read_le32(p);\n\t\t\tut64 ventry = Elf_(rz_bin_elf_p2v)(bin, entry);\n\t\t\tif (ventry == UT64_MAX) {\n\t\t\t\treturn UT64_MAX;\n\t\t\t}\n\t\t\tut64 vmain = (ut64)(ventry + bo + maindelta) + 7;\n\t\t\treturn Elf_(rz_bin_elf_v2p)(bin, vmain);\n\t\t} else if (ch == 0xc7) { // mov rdi, 0xADDR\n\t\t\tut8 *p = buf + bo + 3;\n\t\t\tut64 addr = (ut64)rz_read_le32(p);\n\t\t\treturn Elf_(rz_bin_elf_v2p)(bin, addr);\n\t\t}\n\t}\n\n\treturn UT64_MAX;\n}\n\nstatic ut64 get_main_offset_x86_non_pie(ELFOBJ *bin, ut64 entry, ut8 *buf) {\n\t// X86-NONPIE\n#if RZ_BIN_ELF64\n\tif (!memcmp(buf, \"\\x49\\x89\\xd9\", 3) && buf[156] == 0xe8) { // openbsd\n\t\treturn rz_read_le32(buf + 157) + entry + 156 + 5;\n\t}\n\tif (!memcmp(buf + 29, \"\\x48\\xc7\\xc7\", 3)) { // linux\n\t\tut64 addr = (ut64)rz_read_le32(buf + 29 + 3);\n\t\treturn Elf_(rz_bin_elf_v2p)(bin, addr);\n\t}\n#else\n\tif (buf[23] == '\\x68') {\n\t\tut64 addr = (ut64)rz_read_le32(buf + 23 + 1);\n\t\treturn Elf_(rz_bin_elf_v2p)(bin, addr);\n\t}\n#endif\n\n\treturn UT64_MAX;\n}\n\nstatic ut64 get_main_offset_x86_pie(ELFOBJ *bin, ut64 entry, ut8 *buf) {\n\t// X86-PIE\n\tif (buf[0x00] == 0x48 && buf[0x1e] == 0x8d && buf[0x11] == 0xe8) {\n\t\tut32 *pmain = (ut32 *)(buf + 0x30);\n\t\tut64 vmain = Elf_(rz_bin_elf_p2v)(bin, (ut64)*pmain);\n\t\tut64 ventry = Elf_(rz_bin_elf_p2v)(bin, entry);\n\t\tif (vmain >> 16 == ventry >> 16) {\n\t\t\treturn vmain;\n\t\t}\n\t}\n\t// X86-PIE\n\tif (buf[0x1d] == 0x48 && buf[0x1e] == 0x8b) {\n\t\tif (!memcmp(buf, \"\\x31\\xed\\x49\\x89\", 4)) { // linux\n\t\t\tut64 maddr, baddr;\n\t\t\tut8 n32s[sizeof(ut32)] = { 0 };\n\t\t\tmaddr = entry + 0x24 + rz_read_le32(buf + 0x20);\n\t\t\tif (rz_buf_read_at(bin->b, maddr, n32s, sizeof(ut32)) == -1) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tmaddr = (ut64)rz_read_le32(&n32s[0]);\n\t\t\tbaddr = (bin->ehdr.e_entry >> 16) << 16;\n\t\t\tif (Elf_(rz_bin_elf_has_segments)(bin)) {\n\t\t\t\tbaddr = Elf_(rz_bin_elf_get_baddr)(bin);\n\t\t\t}\n\t\t\tmaddr += baddr;\n\t\t\treturn maddr;\n\t\t}\n\t}\n\n\treturn UT64_MAX;\n}\n\nstatic ut64 get_main_offset_x86_gcc(ELFOBJ *bin, ut64 entry, ut8 *buf) {\n\tif (buf[0] != 0xe8 && memcmp(buf + 5, \"\\x50\\xe8\\x00\\x00\\x00\\x00\\xb8\\x01\\x00\\x00\\x00\\x53\", 12)) {\n\t\treturn UT64_MAX;\n\t}\n\n\tsize_t SIZEOF_CALL = 5;\n\tut64 rel_addr = (ut64)(buf[1] + (buf[2] << 8) + (buf[3] << 16) + (buf[4] << 24));\n\tut64 addr = Elf_(rz_bin_elf_p2v)(bin, entry + SIZEOF_CALL);\n\taddr += rel_addr;\n\treturn Elf_(rz_bin_elf_v2p)(bin, addr);\n}\n\nstatic ut64 get_main_offset_mips(ELFOBJ *bin, ut64 entry, ut8 *buf, size_t size) {\n\t/* get .got, calculate offset of main symbol */\n\tif (memcmp(buf, \"\\x21\\x00\\xe0\\x03\\x01\\x00\\x11\\x04\", 8)) {\n\t\treturn UT64_MAX;\n\t}\n\n\t/*\n\t   assuming the startup code looks like\n\t   got = gp-0x7ff0\n\t   got[index__libc_start_main] ( got[index_main] );\n\n\t   looking for the instruction generating the first argument to find main\n\t   lw a0, offset(gp)\n\t   */\n\tut64 got_addr;\n\n\tif (!Elf_(rz_bin_elf_get_dt_info)(bin, DT_PLTGOT, &got_addr)) {\n\t\treturn 0;\n\t}\n\n\tut64 got_offset = Elf_(rz_bin_elf_v2p)(bin, got_addr);\n\tut64 gp = got_offset + 0x7ff0;\n\n\tfor (size_t i = 0; i < size; i += 4) {\n\t\tconst ut32 instr = rz_read_le32(buf + i);\n\t\tif ((instr & 0xffff0000) == 0x8f840000) { // lw a0, offset(gp)\n\t\t\tconst short delta = instr & 0x0000ffff;\n\t\t\trz_buf_read_at(bin->b, /* got_entry_offset = */ gp + delta, buf, 4);\n\t\t\treturn Elf_(rz_bin_elf_v2p)(bin, rz_read_le32(buf));\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic ut64 get_main_offset_arm_glibc_thumb(ELFOBJ *bin, ut64 entry, ut8 *buf) {\n\tsize_t delta = 0;\n\n\tif (!memcmp(buf, \"\\xf0\\x00\\x0b\\x4f\\xf0\\x00\\x0e\\x02\\xbc\\x6a\\x46\", 11)) {\n\t\t/* newer versions of gcc use push/pop */\n\t\tdelta = 0x28;\n\t} else if (!memcmp(buf, \"\\xf0\\x00\\x0b\\x4f\\xf0\\x00\\x0e\\x5d\\xf8\\x04\\x1b\", 11)) {\n\t\t/* older versions of gcc (4.5.x) use ldr/str */\n\t\tdelta = 0x30;\n\t}\n\n\tif (delta) {\n\t\tut64 tmp = rz_read_le32(buf + delta - 1) & ~1;\n\t\tut64 pa = Elf_(rz_bin_elf_v2p)(bin, tmp);\n\t\tif (pa < rz_buf_size(bin->b)) {\n\t\t\treturn pa;\n\t\t}\n\t}\n\n\treturn UT64_MAX;\n}\n\nstatic ut64 get_main_offset_arm_glibc_non_thumb(ELFOBJ *bin, ut64 entry, ut8 *buf) {\n\tif (!memcmp(buf, \"\\x00\\xb0\\xa0\\xe3\\x00\\xe0\\xa0\\xe3\", 8)) {\n\t\treturn Elf_(rz_bin_elf_v2p)(bin, rz_read_le32(buf + 0x34) & ~1);\n\t}\n\n\tif (!memcmp(buf, \"\\x24\\xc0\\x9f\\xe5\\x00\\xb0\\xa0\\xe3\", 8)) {\n\t\treturn Elf_(rz_bin_elf_v2p)(bin, rz_read_le32(buf + 0x30) & ~1);\n\t}\n\n\treturn UT64_MAX;\n}\n\nstatic ut64 get_main_offset_arm_glibc(ELFOBJ *bin, ut64 entry, ut8 *buf) {\n\t// ARM Glibc\n\tif (Elf_(rz_bin_elf_is_thumb_addr)(entry)) {\n\t\treturn get_main_offset_arm_glibc_thumb(bin, entry, buf);\n\t} else {\n\t\treturn get_main_offset_arm_glibc_non_thumb(bin, entry, buf);\n\t}\n\n\treturn UT64_MAX;\n}\n\nstatic ut64 get_main_offset_arm64(ELFOBJ *bin, ut64 entry, ut8 *buf) {\n\tif (buf[0x18 + 3] != 0x58 || buf[0x2f] != 0x00) {\n\t\treturn UT64_MAX;\n\t}\n\n\tut64 entry_vaddr = Elf_(rz_bin_elf_p2v)(bin, entry);\n\tif (entry_vaddr == UT64_MAX) {\n\t\treturn UT64_MAX;\n\t}\n\n\tut64 main_addr = rz_read_le32(buf + 0x30);\n\n\tif (main_addr >> 16 == entry_vaddr >> 16) {\n\t\treturn Elf_(rz_bin_elf_v2p)(bin, main_addr);\n\t}\n\n\treturn UT64_MAX;\n}\n\nstatic ut64 get_entry_offset_from_shdr(ELFOBJ *bin) {\n\tRzBinElfSection *section = Elf_(rz_bin_elf_get_section_with_name)(bin, \".init.text\");\n\tif (section) {\n\t\treturn section->offset;\n\t}\n\n\tsection = Elf_(rz_bin_elf_get_section_with_name)(bin, \".text\");\n\tif (section) {\n\t\treturn section->offset;\n\t}\n\n\tsection = Elf_(rz_bin_elf_get_section_with_name)(bin, \".init\");\n\tif (section) {\n\t\treturn section->offset;\n\t}\n\n\treturn UT64_MAX;\n}\n\nstatic ut64 compute_boffset_from_phdr(ELFOBJ *bin) {\n\tut64 base = UT64_MAX;\n\n\tRzBinElfSegment *iter;\n\trz_bin_elf_foreach_segments(bin, iter) {\n\t\tif (iter->data.p_type == PT_LOAD) {\n\t\t\tbase = RZ_MIN(base, iter->data.p_offset);\n\t\t}\n\t}\n\n\treturn base == UT64_MAX ? 0 : base;\n}\n\nstatic ut64 compute_baddr_from_phdr(ELFOBJ *bin) {\n\tut64 base = UT64_MAX;\n\n\tRzBinElfSegment *iter;\n\trz_bin_elf_foreach_segments(bin, iter) {\n\t\tif (iter->data.p_type == PT_LOAD) {\n\t\t\tbase = RZ_MIN(base, iter->data.p_vaddr);\n\t\t}\n\t}\n\n\treturn base == UT64_MAX ? 0 : base;\n}\n\nstatic bool elf_is_bind_now(ELFOBJ *bin) {\n\tut64 flags_1;\n\n\tif (Elf_(rz_bin_elf_get_dt_info)(bin, DT_BIND_NOW, NULL)) {\n\t\treturn true;\n\t}\n\n\tif (Elf_(rz_bin_elf_get_dt_info)(bin, DT_FLAGS_1, &flags_1)) {\n\t\treturn flags_1 & DF_1_NOW;\n\t}\n\n\treturn false;\n}\n\nstatic bool elf_has_gnu_relro(ELFOBJ *bin) {\n\tif (!Elf_(rz_bin_elf_has_segments)(bin)) {\n\t\treturn false;\n\t}\n\n\tRzBinElfSegment *segment = Elf_(rz_bin_elf_get_segment_with_type)(bin, PT_GNU_RELRO);\n\treturn segment && segment->is_valid;\n}\n\nstatic int get_bits_common(ELFOBJ *bin) {\n\tswitch (bin->ehdr.e_ident[EI_CLASS]) {\n\tcase ELFCLASS32:\n\t\treturn 32;\n\tcase ELFCLASS64:\n\t\treturn 64;\n\tcase ELFCLASSNONE:\n\tdefault:\n\t\treturn 32;\n\t}\n}\n\nstatic bool has_thumb_symbol(ELFOBJ *bin) {\n\tRzBinElfSymbol *symbol;\n\trz_bin_elf_foreach_symbols(bin, symbol) {\n\t\tif (Elf_(rz_bin_elf_is_thumb_addr)(symbol->paddr) || Elf_(rz_bin_elf_is_thumb_addr)(symbol->vaddr)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic int get_bits_mips_common(Elf_(Word) mips_type) {\n\tfor (size_t i = 0; i < RZ_ARRAY_SIZE(mips_bits_translation_table); i++) {\n\t\tif (mips_type == mips_bits_translation_table[i].type) {\n\t\t\treturn mips_bits_translation_table[i].bits;\n\t\t}\n\t}\n\n\treturn 32;\n}\n\nstatic int is_playstation_hack(ELFOBJ *bin, Elf_(Word) mips_type) {\n\treturn Elf_(rz_bin_elf_is_executable)(bin) && Elf_(rz_bin_elf_is_static)(bin) && mips_type == EF_MIPS_ARCH_3;\n}\n\nstatic int get_bits_mips(ELFOBJ *bin) {\n\tconst Elf_(Word) mips_type = bin->ehdr.e_flags & EF_MIPS_ARCH;\n\n\tif (is_playstation_hack(bin, mips_type)) {\n\t\treturn 64;\n\t}\n\n\treturn get_bits_mips_common(mips_type);\n}\n\nstatic bool arch_is_mips(ELFOBJ *bin) {\n\treturn Elf_(rz_bin_elf_has_segments)(bin) && bin->ehdr.e_machine == EM_MIPS;\n}\n\nstatic bool arch_is_arcompact(ELFOBJ *bin) {\n\treturn bin->ehdr.e_machine == EM_ARC_A5;\n}\n\nstatic char *read_elf_intrp(ELFOBJ *bin, ut64 addr, size_t size) {\n\tchar *str = malloc(size + 1);\n\tif (!str) {\n\t\treturn NULL;\n\t}\n\n\tif (rz_buf_read_at(bin->b, addr, (ut8 *)str, size) < 0) {\n\t\tfree(str);\n\t\treturn NULL;\n\t}\n\n\tstr[size] = 0;\n\n\treturn str;\n}\n\nstatic char *get_elf_intrp(ELFOBJ *bin, RzBinElfSegment *segment) {\n\tut64 addr = segment->data.p_offset;\n\tsize_t size = segment->data.p_filesz;\n\n\tif (!sdb_num_set(bin->kv, \"elf_header.intrp_addr\", addr, 0) ||\n\t\t!sdb_num_set(bin->kv, \"elf_header.intrp_size\", size, 0)) {\n\t\treturn NULL;\n\t}\n\n\tif (size < 1 || size > rz_buf_size(bin->b)) {\n\t\treturn NULL;\n\t}\n\n\tchar *str = read_elf_intrp(bin, addr, size);\n\tif (!str) {\n\t\treturn NULL;\n\t}\n\n\tif (!sdb_set(bin->kv, \"elf_header.intrp\", str, 0)) {\n\t\tfree(str);\n\t\treturn NULL;\n\t}\n\n\treturn str;\n}\n\nstatic Elf_(Xword) get_dt_rpath(ELFOBJ *bin) {\n\tut64 path;\n\n\tif (Elf_(rz_bin_elf_get_dt_info)(bin, DT_RPATH, &path)) {\n\t\treturn path;\n\t}\n\n\tif (Elf_(rz_bin_elf_get_dt_info)(bin, DT_RUNPATH, &path)) {\n\t\treturn path;\n\t}\n\n\treturn 0;\n}\n\nstatic char *get_ver_flags(ut32 flags) {\n\tchar *result = NULL;\n\n\tif (!flags) {\n\t\treturn strdup(\"none\");\n\t}\n\n\tfor (size_t i = 0; i < RZ_ARRAY_SIZE(ver_flags_translation_table); i++) {\n\t\tif (flags & ver_flags_translation_table[i].flag) {\n\t\t\tresult = rz_str_append(result, ver_flags_translation_table[i].name);\n\t\t}\n\t}\n\n\treturn result;\n}\n\nstatic bool has_dt_rpath_entry(ELFOBJ *bin) {\n\treturn Elf_(rz_bin_elf_get_dt_info)(bin, DT_RPATH, NULL) || Elf_(rz_bin_elf_get_dt_info)(bin, DT_RUNPATH, NULL);\n}\n\nstatic char *get_osabi_name_from_section_note(ELFOBJ *bin, RzBinElfSection *section) {\n\tif (section->type != SHT_NOTE) {\n\t\treturn NULL;\n\t}\n\n\tfor (size_t i = 0; i < RZ_ARRAY_SIZE(section_note_osabi_translation_table); i++) {\n\t\tif (!strcmp(section->name, section_note_osabi_translation_table[i].note_name)) {\n\t\t\treturn strdup(section_note_osabi_translation_table[i].os_name);\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic char *get_osabi_name_from_shdr(ELFOBJ *bin) {\n\tif (!bin->shstrtab) {\n\t\treturn NULL;\n\t}\n\n\tRzBinElfSection *section;\n\trz_bin_elf_foreach_sections(bin, section) {\n\t\tif (!section->is_valid) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tchar *tmp = get_osabi_name_from_section_note(bin, section);\n\t\tif (tmp) {\n\t\t\treturn tmp;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic char *get_osabi_name_from_ehdr(ELFOBJ *bin) {\n\tswitch (bin->ehdr.e_ident[EI_OSABI]) {\n\tcase ELFOSABI_LINUX:\n\t\treturn strdup(\"linux\");\n\tcase ELFOSABI_SOLARIS:\n\t\treturn strdup(\"solaris\");\n\tcase ELFOSABI_FREEBSD:\n\t\treturn strdup(\"freebsd\");\n\tcase ELFOSABI_HPUX:\n\t\treturn strdup(\"hpux\");\n\t}\n\n\treturn NULL;\n}\n\nstatic char *add_abi_info(ELFOBJ *bin, char *head_flag) {\n\tchar *str = Elf_(rz_bin_elf_get_abi)(bin);\n\n\tif (str) {\n\t\thead_flag = rz_str_appendf(head_flag, \" %s\", str);\n\t\tfree(str);\n\t}\n\n\treturn head_flag;\n}\n\nstatic char *add_cpu_info(ELFOBJ *bin, char *head_flag) {\n\tchar *str = Elf_(rz_bin_elf_get_cpu)(bin);\n\n\tif (str) {\n\t\thead_flag = rz_str_append_owned(head_flag, str);\n\t}\n\n\treturn head_flag;\n}\n\nstatic char *get_head_flag(ELFOBJ *bin) {\n\tchar *head_flag = NULL;\n\n\thead_flag = add_cpu_info(bin, head_flag);\n\thead_flag = add_abi_info(bin, head_flag);\n\n\treturn head_flag;\n}\n\nstatic bool file_type_is_processor_specific(ELFOBJ *bin) {\n\treturn bin->ehdr.e_type >= ET_LOPROC && bin->ehdr.e_type <= ET_HIPROC;\n}\n\nstatic bool file_type_is_os_specific(ELFOBJ *bin) {\n\treturn bin->ehdr.e_type >= ET_LOOS && bin->ehdr.e_type <= ET_HIOS;\n}\n\nstatic char *get_file_type_basic(RZ_NONNULL ELFOBJ *bin) {\n\tswitch (bin->ehdr.e_type) {\n\tcase ET_NONE:\n\t\treturn strdup(\"NONE (None)\");\n\tcase ET_REL:\n\t\treturn strdup(\"REL (Relocatable file)\");\n\tcase ET_EXEC:\n\t\treturn strdup(\"EXEC (Executable file)\");\n\tcase ET_DYN:\n\t\treturn strdup(\"DYN (Shared object file)\");\n\tcase ET_CORE:\n\t\treturn strdup(\"CORE (Core file)\");\n\t}\n\n\treturn NULL;\n}\n\nstatic char *get_cpu_mips(ELFOBJ *bin) {\n\tElf_(Word) mips_arch = bin->ehdr.e_flags & EF_MIPS_ARCH;\n\n\tfor (size_t i = 0; i < RZ_ARRAY_SIZE(cpu_mips_translation_table); i++) {\n\t\tif (mips_arch == cpu_mips_translation_table[i].arch) {\n\t\t\treturn strdup(cpu_mips_translation_table[i].name);\n\t\t}\n\t}\n\n\treturn strdup(\" Unknown mips ISA\");\n}\n\nstatic bool is_elf_class64(ELFOBJ *bin) {\n\treturn bin->ehdr.e_ident[EI_CLASS] == ELFCLASS64;\n}\n\nstatic bool is_mips_o32(ELFOBJ *bin) {\n\tif (bin->ehdr.e_ident[EI_CLASS] != ELFCLASS32) {\n\t\treturn false;\n\t}\n\n\tif ((bin->ehdr.e_flags & EF_MIPS_ABI2) != 0) {\n\t\treturn false;\n\t}\n\n\tif ((bin->ehdr.e_flags & EF_MIPS_ABI) != 0 && (bin->ehdr.e_flags & EF_MIPS_ABI) != EF_MIPS_ABI_O32) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool is_mips_n32(ELFOBJ *bin) {\n\tif (bin->ehdr.e_ident[EI_CLASS] != ELFCLASS32) {\n\t\treturn false;\n\t}\n\n\tif ((bin->ehdr.e_flags & EF_MIPS_ABI2) == 0 || (bin->ehdr.e_flags & EF_MIPS_ABI) != 0) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic char *get_abi_mips(ELFOBJ *bin) {\n\tif (is_elf_class64(bin)) {\n\t\treturn strdup(\"n64\");\n\t}\n\n\tif (is_mips_n32(bin)) {\n\t\treturn strdup(\"n32\");\n\t}\n\n\tif (is_mips_o32(bin)) {\n\t\treturn strdup(\"o32\");\n\t}\n\n\treturn NULL;\n}\n\n/**\n * \\brief List all imported lib\n * \\param elf binary\n * \\return an allocated list of char*\n *\n * Use dynamic information (dt_needed) to generate a list of imported lib\n */\nRZ_OWN RzList /*<char *>*/ *Elf_(rz_bin_elf_get_libs)(RZ_NONNULL ELFOBJ *bin) {\n\trz_return_val_if_fail(bin, NULL);\n\n\tif (!Elf_(rz_bin_elf_has_dt_dynamic)(bin) || !bin->dynstr) {\n\t\treturn NULL;\n\t}\n\n\tRzVector *dt_needed = Elf_(rz_bin_elf_get_dt_needed)(bin);\n\tif (!dt_needed) {\n\t\treturn NULL;\n\t}\n\n\tRzList *result = rz_list_newf(free);\n\tif (!result) {\n\t\treturn NULL;\n\t}\n\n\tut64 *iter = NULL;\n\trz_vector_foreach(dt_needed, iter) {\n\t\tchar *tmp = Elf_(rz_bin_elf_strtab_get_dup)(bin->dynstr, *iter);\n\t\tif (!tmp) {\n\t\t\trz_list_free(result);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (!rz_list_append(result, tmp)) {\n\t\t\trz_list_free(result);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn result;\n}\n\nstatic bool get_verdaux_entry_aux(ELFOBJ *bin, ut64 offset, Elf_(Verdaux) * entry) {\n\treturn Elf_(rz_bin_elf_read_word)(bin, &offset, &entry->vda_name) &&\n\t\tElf_(rz_bin_elf_read_word)(bin, &offset, &entry->vda_next);\n}\n\nstatic bool get_verdaux_entry(ELFOBJ *bin, ut64 offset, Elf_(Verdaux) * entry) {\n\tif (!get_verdaux_entry_aux(bin, offset, entry)) {\n\t\tRZ_LOG_WARN(\"Failed to read verdaux entry at 0x%\" PFMT64x \".\\n\", offset);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool get_verdef_entry_aux(ELFOBJ *bin, ut64 offset, Elf_(Verdef) * entry) {\n\treturn Elf_(rz_bin_elf_read_half)(bin, &offset, &entry->vd_version) &&\n\t\tElf_(rz_bin_elf_read_half)(bin, &offset, &entry->vd_flags) &&\n\t\tElf_(rz_bin_elf_read_half)(bin, &offset, &entry->vd_ndx) &&\n\t\tElf_(rz_bin_elf_read_half)(bin, &offset, &entry->vd_cnt) &&\n\t\tElf_(rz_bin_elf_read_word)(bin, &offset, &entry->vd_hash) &&\n\t\tElf_(rz_bin_elf_read_word)(bin, &offset, &entry->vd_aux) &&\n\t\tElf_(rz_bin_elf_read_word)(bin, &offset, &entry->vd_next);\n}\n\nstatic bool get_verdef_entry(ELFOBJ *bin, ut64 offset, Elf_(Verdef) * entry) {\n\tif (!get_verdef_entry_aux(bin, offset, entry)) {\n\t\tRZ_LOG_WARN(\"Failed to read verdef entry at 0x%\" PFMT64x \".\\n\", offset);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool get_vernaux_entry_aux(ELFOBJ *bin, ut64 offset, Elf_(Vernaux) * entry) {\n\treturn Elf_(rz_bin_elf_read_word)(bin, &offset, &entry->vna_hash) &&\n\t\tElf_(rz_bin_elf_read_half)(bin, &offset, &entry->vna_flags) &&\n\t\tElf_(rz_bin_elf_read_half)(bin, &offset, &entry->vna_other) &&\n\t\tElf_(rz_bin_elf_read_word)(bin, &offset, &entry->vna_name) &&\n\t\tElf_(rz_bin_elf_read_word)(bin, &offset, &entry->vna_next);\n}\n\nstatic bool get_vernaux_entry(ELFOBJ *bin, ut64 offset, Elf_(Vernaux) * entry) {\n\tif (!get_vernaux_entry_aux(bin, offset, entry)) {\n\t\tRZ_LOG_WARN(\"Failed to read vernaux entry at 0x%\" PFMT64x \".\\n\", offset);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\nstatic bool get_verneed_entry_aux(ELFOBJ *bin, ut64 offset, Elf_(Verneed) * entry) {\n\treturn Elf_(rz_bin_elf_read_half)(bin, &offset, &entry->vn_version) &&\n\t\tElf_(rz_bin_elf_read_half)(bin, &offset, &entry->vn_cnt) &&\n\t\tElf_(rz_bin_elf_read_word)(bin, &offset, &entry->vn_file) &&\n\t\tElf_(rz_bin_elf_read_word)(bin, &offset, &entry->vn_aux) &&\n\t\tElf_(rz_bin_elf_read_word)(bin, &offset, &entry->vn_next);\n}\n\nstatic bool get_verneed_entry(ELFOBJ *bin, ut64 offset, Elf_(Verneed) * entry) {\n\tif (!get_verneed_entry_aux(bin, offset, entry)) {\n\t\tRZ_LOG_WARN(\"Failed to read verneed entry at 0x%\" PFMT64x \".\\n\", offset);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool get_versym_entry_sdb_from_verneed(ELFOBJ *bin, Sdb *sdb, const char *key, Elf_(Versym) versym) {\n\tut64 verneed_addr;\n\tut64 verneed_num;\n\n\tif (!Elf_(rz_bin_elf_get_dt_info)(bin, DT_VERNEED, &verneed_addr) || !Elf_(rz_bin_elf_get_dt_info)(bin, DT_VERNEEDNUM, &verneed_num)) {\n\t\treturn false;\n\t}\n\n\tut64 verneed_offset = Elf_(rz_bin_elf_v2p(bin, verneed_addr));\n\n\tif (verneed_offset == UT64_MAX) {\n\t\treturn false;\n\t}\n\n\tut64 verneed_entry_offset = verneed_offset;\n\n\tfor (size_t i = 0; i < verneed_num; i++) {\n\t\tElf_(Verneed) verneed_entry;\n\t\tif (!get_verneed_entry(bin, verneed_entry_offset, &verneed_entry)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tut64 vernaux_entry_offset = verneed_entry_offset + verneed_entry.vn_aux;\n\n\t\tfor (size_t j = 0; j < verneed_entry.vn_cnt; j++) {\n\t\t\tElf_(Vernaux) vernaux_entry;\n\t\t\tif (!get_vernaux_entry(bin, vernaux_entry_offset, &vernaux_entry)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (vernaux_entry.vna_other != versym) {\n\t\t\t\tvernaux_entry_offset += vernaux_entry.vna_next;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst char *tmp = Elf_(rz_bin_elf_strtab_get)(bin->dynstr, vernaux_entry.vna_name);\n\t\t\tif (!tmp) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tchar *value = rz_str_newf(\"%u (%s)\", versym & VERSYM_VERSION, tmp);\n\t\t\tif (!value) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (!sdb_set_owned(sdb, key, value, 0)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\tverneed_entry_offset += verneed_entry.vn_next;\n\t}\n\n\treturn false;\n}\n\nstatic bool get_versym_entry_sdb_from_verdef(ELFOBJ *bin, Sdb *sdb, const char *key, Elf_(Versym) versym) {\n\tut64 verdef_addr;\n\tut64 verdef_num;\n\n\tif (!Elf_(rz_bin_elf_get_dt_info)(bin, DT_VERDEF, &verdef_addr) || !Elf_(rz_bin_elf_get_dt_info)(bin, DT_VERDEFNUM, &verdef_num)) {\n\t\treturn false;\n\t}\n\n\tut64 verdef_offset = Elf_(rz_bin_elf_v2p(bin, verdef_addr));\n\n\tif (verdef_offset == UT64_MAX) {\n\t\treturn false;\n\t}\n\n\tut64 verdef_entry_offset = verdef_offset;\n\n\tfor (size_t i = 0; i < verdef_num; i++) {\n\t\tElf_(Verdef) verdef_entry;\n\t\tif (!get_verdef_entry(bin, verdef_entry_offset, &verdef_entry)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!verdef_entry.vd_cnt || verdef_entry.vd_ndx != (versym & VERSYM_VERSION)) {\n\t\t\tverdef_entry_offset += verdef_entry.vd_next;\n\t\t\tcontinue;\n\t\t}\n\n\t\tut64 verdaux_entry_offset = verdef_entry_offset + verdef_entry.vd_aux;\n\n\t\tElf_(Verdaux) verdaux_entry;\n\t\tif (!get_verdaux_entry(bin, verdaux_entry_offset, &verdaux_entry)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst char *tmp = Elf_(rz_bin_elf_strtab_get)(bin->dynstr, verdaux_entry.vda_name);\n\t\tif (!tmp) {\n\t\t\treturn false;\n\t\t}\n\n\t\tchar *value = rz_str_newf(\"%u (%s)\", versym & VERSYM_VERSION, tmp);\n\t\tif (!value) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!sdb_set_owned(sdb, key, value, 0)) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic Sdb *get_gnu_versym(ELFOBJ *bin) {\n\tut64 versym_addr;\n\n\tif (!Elf_(rz_bin_elf_get_dt_info)(bin, DT_VERSYM, &versym_addr)) {\n\t\treturn false;\n\t}\n\n\tut64 versym_offset = Elf_(rz_bin_elf_v2p(bin, versym_addr));\n\n\tif (versym_offset == UT64_MAX) {\n\t\treturn NULL;\n\t}\n\n\tut64 number_of_symbols = Elf_(rz_bin_elf_get_number_of_dynamic_symbols)(bin);\n\tif (!number_of_symbols) {\n\t\treturn NULL;\n\t}\n\n\tSdb *sdb = sdb_new0();\n\tif (!sdb) {\n\t\treturn NULL;\n\t}\n\n\tif (!sdb_num_set(sdb, \"num_entries\", number_of_symbols, 0) ||\n\t\t!sdb_num_set(sdb, \"addr\", versym_addr, 0) ||\n\t\t!sdb_num_set(sdb, \"offset\", versym_offset, 0)) {\n\t\tsdb_free(sdb);\n\t\treturn NULL;\n\t}\n\n\tut64 versym_entry_offset = versym_offset;\n\n\tfor (size_t i = 0; i < number_of_symbols; i++) {\n\t\tchar key[32];\n\t\tif (rz_strf(key, \"entry%zu\", i) == NULL) {\n\t\t\tsdb_free(sdb);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tElf_(Versym) versym_entry;\n\t\tif (!Elf_(rz_bin_elf_read_versym)(bin, &versym_entry_offset, &versym_entry)) {\n\t\t\tsdb_free(sdb);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tswitch (versym_entry) {\n\t\tcase VER_NDX_LOCAL:\n\t\t\tif (!sdb_set(sdb, key, \"0 (*local*)\", 0)) {\n\t\t\t\tsdb_free(sdb);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase VER_NDX_GLOBAL:\n\t\t\tif (!sdb_set(sdb, key, \"1 (*global*)\", 0)) {\n\t\t\t\tsdb_free(sdb);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (get_versym_entry_sdb_from_verneed(bin, sdb, key, versym_entry)) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!get_versym_entry_sdb_from_verdef(bin, sdb, key, versym_entry)) {\n\t\t\t\tsdb_free(sdb);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sdb;\n}\n\nstatic Sdb *get_vernaux_entry_sdb(ELFOBJ *bin, Elf_(Vernaux) vernaux_entry, size_t index) {\n\tconst char *tmp = Elf_(rz_bin_elf_strtab_get)(bin->dynstr, vernaux_entry.vna_name);\n\tif (!tmp) {\n\t\treturn NULL;\n\t}\n\n\tSdb *sdb_vernaux = sdb_new0();\n\tif (!sdb_vernaux) {\n\t\treturn NULL;\n\t}\n\n\tchar *flags = get_ver_flags(vernaux_entry.vna_flags);\n\tif (!sdb_set_owned(sdb_vernaux, \"flags\", flags, 0)) {\n\t\tsdb_free(sdb_vernaux);\n\t\treturn NULL;\n\t}\n\n\tif (!sdb_num_set(sdb_vernaux, \"idx\", index, 0) ||\n\t\t!sdb_num_set(sdb_vernaux, \"version\", vernaux_entry.vna_other, 0) ||\n\t\t!sdb_set(sdb_vernaux, \"name\", tmp, 0)) {\n\t\tsdb_free(sdb_vernaux);\n\t\treturn NULL;\n\t}\n\n\treturn sdb_vernaux;\n}\n\nstatic Sdb *get_verneed_entry_sdb_aux(ELFOBJ *bin, Elf_(Verneed) verneed_entry, size_t index) {\n\tconst char *tmp = Elf_(rz_bin_elf_strtab_get)(bin->dynstr, verneed_entry.vn_file);\n\tif (!tmp) {\n\t\treturn NULL;\n\t}\n\n\tSdb *sdb_version = sdb_new0();\n\tif (!sdb_version) {\n\t\treturn NULL;\n\t}\n\n\tif (!sdb_num_set(sdb_version, \"cnt\", verneed_entry.vn_cnt, 0) ||\n\t\t!sdb_num_set(sdb_version, \"idx\", index, 0) ||\n\t\t!sdb_num_set(sdb_version, \"vn_version\", verneed_entry.vn_version, 0) ||\n\t\t!sdb_set(sdb_version, \"file_name\", tmp, 0)) {\n\t\tsdb_free(sdb_version);\n\t\treturn NULL;\n\t}\n\n\treturn sdb_version;\n}\n\nstatic Sdb *get_verneed_entry_sdb(ELFOBJ *bin, Elf_(Verneed) verneed_entry, size_t offset) {\n\tSdb *sdb_version = get_verneed_entry_sdb_aux(bin, verneed_entry, offset);\n\tif (!sdb_version) {\n\t\treturn NULL;\n\t}\n\n\tut64 vernaux_entry_offset = offset + verneed_entry.vn_aux;\n\n\tfor (size_t i = 0; i < verneed_entry.vn_cnt; i++) {\n\t\tElf_(Vernaux) vernaux_entry;\n\t\tif (!get_vernaux_entry(bin, vernaux_entry_offset, &vernaux_entry)) {\n\t\t\tsdb_free(sdb_version);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tSdb *sdb_vernaux = get_vernaux_entry_sdb(bin, vernaux_entry, vernaux_entry_offset);\n\t\tif (!sdb_vernaux) {\n\t\t\tsdb_free(sdb_version);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tchar key[32];\n\t\tif (!sdb_ns_set(sdb_version, rz_strf(key, \"vernaux%zu\", i), sdb_vernaux)) {\n\t\t\tsdb_free(sdb_vernaux);\n\t\t\tsdb_free(sdb_version);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tsdb_free(sdb_vernaux);\n\n\t\tvernaux_entry_offset += vernaux_entry.vna_next;\n\t}\n\n\treturn sdb_version;\n}\n\nstatic Sdb *get_gnu_verneed(ELFOBJ *bin) {\n\tut64 verneed_addr;\n\tut64 verneed_num;\n\n\tif (!Elf_(rz_bin_elf_get_dt_info)(bin, DT_VERNEED, &verneed_addr) || !Elf_(rz_bin_elf_get_dt_info)(bin, DT_VERNEEDNUM, &verneed_num)) {\n\t\treturn NULL;\n\t}\n\n\tut64 verneed_offset = Elf_(rz_bin_elf_v2p(bin, verneed_addr));\n\tif (verneed_offset == UT64_MAX) {\n\t\tRZ_LOG_WARN(\"Failed to convert verneed virtual address to physical address.\\n\");\n\t\treturn NULL;\n\t}\n\n\tSdb *sdb = sdb_new0();\n\tif (!sdb) {\n\t\treturn NULL;\n\t}\n\n\tif (!sdb_num_set(sdb, \"num_entries\", verneed_num, 0) ||\n\t\t!sdb_num_set(sdb, \"addr\", verneed_addr, 0) ||\n\t\t!sdb_num_set(sdb, \"offset\", verneed_offset, 0)) {\n\t\tsdb_free(sdb);\n\t\treturn NULL;\n\t}\n\n\tfor (size_t i = 0; i < verneed_num; i++) {\n\t\tElf_(Verneed) verneed_entry;\n\t\tif (!get_verneed_entry(bin, verneed_offset, &verneed_entry)) {\n\t\t\tsdb_free(sdb);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tSdb *sdb_version = get_verneed_entry_sdb(bin, verneed_entry, verneed_offset);\n\t\tif (!sdb_version) {\n\t\t\tsdb_free(sdb);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tchar key[32];\n\t\tif (!sdb_ns_set(sdb, rz_strf(key, \"version%zu\", i), sdb_version)) {\n\t\t\tsdb_free(sdb_version);\n\t\t\tsdb_free(sdb);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tsdb_free(sdb_version);\n\n\t\tverneed_offset += verneed_entry.vn_next;\n\t}\n\n\treturn sdb;\n}\n\nRZ_IPI RZ_OWN Sdb *Elf_(rz_bin_elf_get_symbols_info)(RZ_NONNULL ELFOBJ *bin) {\n\trz_return_val_if_fail(bin, false);\n\n\tif (!Elf_(rz_bin_elf_is_executable)(bin)) {\n\t\treturn NULL;\n\t}\n\n\tSdb *res = sdb_new0();\n\tif (!res) {\n\t\treturn NULL;\n\t}\n\n\tSdb *sdb = get_gnu_verneed(bin);\n\tif (sdb && !sdb_ns_set(res, \"verneed\", sdb)) {\n\t\tsdb_free(res);\n\t\tsdb_free(sdb);\n\t\treturn NULL;\n\t}\n\tsdb_free(sdb);\n\n\tsdb = get_gnu_versym(bin);\n\tif (sdb && !sdb_ns_set(res, \"versym\", sdb)) {\n\t\tsdb_free(res);\n\t\tsdb_free(sdb);\n\t\treturn NULL;\n\t}\n\tsdb_free(sdb);\n\n\treturn res;\n}\n\n/**\n * \\brief Get the compiler info from the .comment section\n * \\param elf binary\n * \\return a ptr to an allocated string\n *\n * ...\n */\nRZ_OWN char *Elf_(rz_bin_elf_get_compiler)(RZ_NONNULL ELFOBJ *bin) {\n\trz_return_val_if_fail(bin, NULL);\n\n\tRzBinElfSection *section = Elf_(rz_bin_elf_get_section_with_name)(bin, \".comment\");\n\tif (!section) {\n\t\treturn NULL;\n\t}\n\n\tut64 offset = section->offset;\n\tut64 size = RZ_MIN(section->size, 128);\n\tif (size < 1) {\n\t\treturn NULL;\n\t}\n\n\tchar *result = malloc(size + 1);\n\tif (!result) {\n\t\treturn NULL;\n\t}\n\n\tif (rz_buf_read_at(bin->b, offset, (ut8 *)result, size) < 1) {\n\t\tfree(result);\n\t\treturn NULL;\n\t}\n\tresult[size] = 0;\n\n\tsize_t result_len = strlen(result);\n\tchar *end = result + result_len;\n\n\tif (result_len != size && end[1]) {\n\t\tend[0] = ' ';\n\t}\n\n\trz_str_trim(result);\n\tchar *res = rz_str_escape(result);\n\n\tfree(result);\n\treturn res;\n}\n\n/**\n * \\brief Return a string representing the application binary interface\n * \\param elf type\n * \\return allocated string\n *\n * Only work on mips right now. Use the elf header to deduce the application\n * binary interface\n */\nRZ_OWN char *Elf_(rz_bin_elf_get_abi)(RZ_NONNULL ELFOBJ *bin) {\n\trz_return_val_if_fail(bin, NULL);\n\n\tif (bin->ehdr.e_machine == EM_MIPS) {\n\t\treturn get_abi_mips(bin);\n\t}\n\n\treturn NULL;\n}\n\n/**\n * \\brief Get the elf binary architecture\n * \\param elf binary\n * \\return an allocated string\n *\n * With the elf header (e_machine) deduce the elf architecture\n */\nRZ_OWN char *Elf_(rz_bin_elf_get_arch)(RZ_NONNULL ELFOBJ *bin) {\n\trz_return_val_if_fail(bin, NULL);\n\n\tfor (size_t i = 0; i < RZ_ARRAY_SIZE(arch_translation_table); i++) {\n\t\tif (bin->ehdr.e_machine == arch_translation_table[i].arch) {\n\t\t\treturn strdup(arch_translation_table[i].name);\n\t\t}\n\t}\n\n\treturn strdup(\"\");\n}\n\n/**\n * \\brief Return a string representing the cpu\n * \\param elf type\n * \\return allocated string\n *\n * Only work on mips right now. Use the elf header to deduce the cpu\n */\nRZ_OWN char *Elf_(rz_bin_elf_get_cpu)(RZ_NONNULL ELFOBJ *bin) {\n\trz_return_val_if_fail(bin, NULL);\n\n\tif (!Elf_(rz_bin_elf_has_segments)(bin)) {\n\t\treturn NULL;\n\t}\n\n\tif (bin->ehdr.e_machine == EM_MIPS) {\n\t\treturn get_cpu_mips(bin);\n\t}\n\n\treturn NULL;\n}\n\n/**\n * \\brief Return a string representing the elf class\n * \\param elf binary\n * \\return allocated string\n *\n * Check the elf header (e_ident) to deduce the elf class\n */\nRZ_OWN char *Elf_(rz_bin_elf_get_elf_class)(RZ_NONNULL ELFOBJ *bin) {\n\trz_return_val_if_fail(bin, NULL);\n\n\tfor (size_t i = 0; i < RZ_ARRAY_SIZE(class_translation_table); i++) {\n\t\tif (bin->ehdr.e_ident[EI_CLASS] == class_translation_table[i].class) {\n\t\t\treturn strdup(class_translation_table[i].name);\n\t\t}\n\t}\n\n\treturn rz_str_newf(\"<unknown: %x>\", bin->ehdr.e_ident[EI_CLASS]);\n}\n\n/**\n * \\brief Return a string representing the file type\n * \\param elf binary\n * \\return allocated string\n *\n * Use the elf header (e_type) to deduce the file type\n */\nRZ_OWN char *Elf_(rz_bin_elf_get_file_type)(RZ_NONNULL ELFOBJ *bin) {\n\trz_return_val_if_fail(bin, NULL);\n\n\tchar *result = get_file_type_basic(bin);\n\tif (result) {\n\t\treturn result;\n\t}\n\n\tif (file_type_is_processor_specific(bin)) {\n\t\treturn rz_str_newf(\"Processor Specific: %x\", bin->ehdr.e_type);\n\t}\n\n\tif (file_type_is_os_specific(bin)) {\n\t\treturn rz_str_newf(\"OS Specific: %x\", bin->ehdr.e_type);\n\t}\n\n\treturn rz_str_newf(\"<unknown>: %x\", bin->ehdr.e_type);\n}\n\n/**\n * \\brief Return the head flag\n * \\return allocated string\n *\n * ...\n */\nRZ_OWN char *Elf_(rz_bin_elf_get_head_flag)(RZ_NONNULL ELFOBJ *bin) {\n\trz_return_val_if_fail(bin, NULL);\n\n\tchar *head_flag = get_head_flag(bin);\n\n\tif (RZ_STR_ISEMPTY(head_flag)) {\n\t\tfree(head_flag);\n\t\treturn strdup(\"unknown_flag\");\n\t}\n\n\treturn head_flag;\n}\n\n/**\n * \\brief Return a string representing the machine name\n * \\param elf type\n * \\return allocated string\n *\n * Use http://www.sco.com/developers/gabi/latest/ch4.eheader.html and the elf\n * header (e_machine)\n */\nRZ_OWN char *Elf_(rz_bin_elf_get_machine_name)(RZ_NONNULL ELFOBJ *bin) {\n\trz_return_val_if_fail(bin, NULL);\n\n\tfor (size_t i = 0; i < RZ_ARRAY_SIZE(machine_name_translation_table); i++) {\n\t\tif (bin->ehdr.e_machine == machine_name_translation_table[i].machine) {\n\t\t\treturn strdup(machine_name_translation_table[i].name);\n\t\t}\n\t}\n\n\treturn rz_str_newf(\"<unknown>: 0x%x\", bin->ehdr.e_machine);\n}\n\n/**\n * \\brief Return the os application binary interface name\n * \\param elf binary\n * \\return an allocated string\n *\n * Check the ehdr or the shdr to get the os name\n */\nRZ_OWN char *Elf_(rz_bin_elf_get_osabi_name)(RZ_NONNULL ELFOBJ *bin) {\n\trz_return_val_if_fail(bin, NULL);\n\n\tchar *name = get_osabi_name_from_ehdr(bin);\n\tif (name) {\n\t\treturn name;\n\t}\n\n\tname = get_osabi_name_from_shdr(bin);\n\tif (name) {\n\t\treturn name;\n\t}\n\n\treturn strdup(\"linux\");\n}\n\n/**\n * \\brief Get the rpath\n * \\param elf binary\n * \\return allocated string\n *\n * Use DT_RPATH or DT_RUNPATH to return the string\n */\nRZ_OWN char *Elf_(rz_bin_elf_get_rpath)(RZ_NONNULL ELFOBJ *bin) {\n\trz_return_val_if_fail(bin, NULL);\n\n\tif (!Elf_(rz_bin_elf_has_segments)(bin) || !bin->dynstr || !has_dt_rpath_entry(bin)) {\n\t\treturn NULL;\n\t}\n\n\tElf_(Xword) val = get_dt_rpath(bin);\n\treturn Elf_(rz_bin_elf_strtab_get_dup)(bin->dynstr, val);\n}\n\n/**\n * \\brief Get the program interpreter\n * \\param elf binary\n * \\return an allocated string\n *\n * Get the program interpreter from the phdr\n */\nRZ_OWN char *Elf_(rz_bin_elf_get_intrp)(RZ_NONNULL ELFOBJ *bin) {\n\trz_return_val_if_fail(bin, NULL);\n\n\tif (!Elf_(rz_bin_elf_has_segments)(bin)) {\n\t\treturn NULL;\n\t}\n\n\tRzBinElfSegment *segment = Elf_(rz_bin_elf_get_segment_with_type)(bin, PT_INTERP);\n\tif (!segment || !segment->is_valid) {\n\t\treturn NULL;\n\t}\n\n\treturn get_elf_intrp(bin, segment);\n}\n\n/**\n * \\brief Check if the binary is stripped\n * \\param elf binary\n * \\param is_stripped ?\n * \\return a ptr to a new allocated RzBinSymbol\n *\n * Use the shdr to check if the binary is stripped\n */\nbool Elf_(rz_bin_elf_is_stripped)(RZ_NONNULL ELFOBJ *bin) {\n\trz_return_val_if_fail(bin, false);\n\n\tif (!Elf_(rz_bin_elf_has_sections)(bin)) {\n\t\treturn false;\n\t}\n\n\tRzBinElfSection *section;\n\trz_bin_elf_foreach_sections(bin, section) {\n\t\tif (section->type == SHT_SYMTAB) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/**\n * \\brief Check if the stack is not executable\n * \\param elf binary\n * \\return true, false\n *\n * Check p_flags from the segment PT_GNU_STACK\n */\nbool Elf_(rz_bin_elf_has_nx)(RZ_NONNULL ELFOBJ *bin) {\n\trz_return_val_if_fail(bin, false);\n\n\tif (!Elf_(rz_bin_elf_has_segments)(bin)) {\n\t\treturn false;\n\t}\n\n\tRzBinElfSegment *segment = Elf_(rz_bin_elf_get_segment_with_type)(bin, PT_GNU_STACK);\n\tif (!segment || !segment->is_valid) {\n\t\treturn false;\n\t}\n\n\treturn !(segment->data.p_flags & PF_X);\n}\n\n/**\n * \\brief Check if the elf use virtual address\n * \\param elf binary\n * \\return always true\n *\n * Return always true\n */\nbool Elf_(rz_bin_elf_has_va)(ELFOBJ *bin) {\n\treturn true;\n}\n\n/**\n * \\brief Check if the elf binary is executable\n * \\param elf binary\n * \\return is_executable ?\n *\n * Use the elf header entry e_type to deduct if the elf is executable.\n */\nbool Elf_(rz_bin_elf_is_executable)(RZ_NONNULL ELFOBJ *bin) {\n\trz_return_val_if_fail(bin, false);\n\n\tconst Elf_(Half) type = bin->ehdr.e_type;\n\treturn type == ET_EXEC || type == ET_DYN;\n}\n\n/**\n * \\brief Check if the elf binary is relocatable\n * \\param elf binary\n * \\return is_relocatable ?\n *\n * Use the elf header entry e_type to deduct if the elf is relocatable.\n */\nbool Elf_(rz_bin_elf_is_relocatable)(RZ_NONNULL ELFOBJ *bin) {\n\trz_return_val_if_fail(bin, false);\n\treturn bin->ehdr.e_type == ET_REL;\n}\n\n/**\n * \\brief Check if the binary is statically-linked library\n * \\param elf binary\n * \\return is_static ?\n *\n * Check the presence of PT_INTERP or PT_DYNAMIC in the program header\n */\nbool Elf_(rz_bin_elf_is_static)(RZ_NONNULL ELFOBJ *bin) {\n\trz_return_val_if_fail(bin, false);\n\n\tRzBinElfSegment *segment = Elf_(rz_bin_elf_get_segment_with_type)(bin, PT_INTERP);\n\tif (segment && segment->is_valid) {\n\t\treturn false;\n\t}\n\n\tsegment = Elf_(rz_bin_elf_get_segment_with_type)(bin, PT_DYNAMIC);\n\tif (segment && segment->is_valid) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n/**\n * \\brief Return the elf bits\n * \\param elf binary\n * \\return the number of bits\n *\n * ...\n */\nint Elf_(rz_bin_elf_get_bits)(RZ_NONNULL ELFOBJ *bin) {\n\trz_return_val_if_fail(bin, 0);\n\n\t/* Hack for ARCompact */\n\tif (arch_is_arcompact(bin)) {\n\t\treturn 16;\n\t}\n\n\t/* Hack for Ps2 */\n\tif (arch_is_mips(bin)) {\n\t\treturn get_bits_mips(bin);\n\t}\n\n\t/* Hack for Thumb */\n\tif (Elf_(rz_bin_elf_is_arm_binary_supporting_thumb)(bin)) {\n\t\tif (!Elf_(rz_bin_elf_is_static)(bin) && has_thumb_symbol(bin)) {\n\t\t\treturn 16;\n\t\t}\n\n\t\tut64 entry = Elf_(rz_bin_elf_get_entry_offset)(bin);\n\t\tif (Elf_(rz_bin_elf_is_thumb_addr)(entry)) {\n\t\t\treturn 16;\n\t\t}\n\t}\n\n\treturn get_bits_common(bin);\n}\n\n/**\n * \\brief Analyse if the elf binary has relro or partial relro\n * \\param elf binary\n * \\return RZ_BIN_ELF_NO_RELRO, RZ_BIN_ELF_PART_RELRO or RZ_BIN_ELF_FULL_RELRO\n *\n * Check if the elf has bind now enable and with PT_GNU_RELRO can deduct the\n * relro type\n */\nint Elf_(rz_bin_elf_has_relro)(RZ_NONNULL ELFOBJ *bin) {\n\trz_return_val_if_fail(bin, RZ_BIN_ELF_NO_RELRO);\n\n\tbool is_bind_now = elf_is_bind_now(bin);\n\tbool has_gnu_relro = elf_has_gnu_relro(bin);\n\n\tif (has_gnu_relro) {\n\t\tif (is_bind_now) {\n\t\t\treturn RZ_BIN_ELF_FULL_RELRO;\n\t\t}\n\n\t\treturn RZ_BIN_ELF_PART_RELRO;\n\t}\n\n\treturn RZ_BIN_ELF_NO_RELRO;\n}\n\n/**\n * \\brief Check the binary endianness\n * \\param elf type\n * \\return is_big_endian ?\n *\n * Use the elf header (e_ident[EI_DATA]) to check the binary endianness\n */\nbool Elf_(rz_bin_elf_is_big_endian)(RZ_NONNULL ELFOBJ *bin) {\n\trz_return_val_if_fail(bin, false);\n\n\treturn bin->ehdr.e_ident[EI_DATA] == ELFDATA2MSB;\n}\n\n/**\n * \\brief Compute the base address of the binary\n * \\param elf binary\n * \\return the base address\n *\n * To compute the base address, one determines the memory\n * address associated with the lowest p_vaddr value for a\n * PT_LOAD segment.\n */\nut64 Elf_(rz_bin_elf_get_baddr)(RZ_NONNULL ELFOBJ *bin) {\n\trz_return_val_if_fail(bin, 0);\n\n\tif (Elf_(rz_bin_elf_is_relocatable)(bin)) {\n\t\treturn 0x08000000;\n\t}\n\n\tif (Elf_(rz_bin_elf_has_segments)(bin)) {\n\t\treturn compute_baddr_from_phdr(bin);\n\t}\n\n\treturn 0;\n}\n\n/**\n * \\brief Compute the base offset of the binary\n * \\param elf binary\n * \\return the base offset\n *\n * To compute the base address, one determines the memory\n * address associated with the lowest p_offset value for a\n * PT_LOAD segment.\n */\nut64 Elf_(rz_bin_elf_get_boffset)(RZ_NONNULL ELFOBJ *bin) {\n\trz_return_val_if_fail(bin, 0);\n\n\tif (Elf_(rz_bin_elf_has_segments)(bin)) {\n\t\treturn compute_boffset_from_phdr(bin);\n\t}\n\n\treturn 0;\n}\n\n/**\n * \\brief Get the entry offset\n * \\param elf binary\n * \\return the entry offset\n *\n * Get the entry offset from the elf header (e_entry), and if the information\n * isn't defined section header will be used.\n */\nut64 Elf_(rz_bin_elf_get_entry_offset)(RZ_NONNULL ELFOBJ *bin) {\n\trz_return_val_if_fail(bin, UT64_MAX);\n\n\tif (!Elf_(rz_bin_elf_is_executable)(bin)) {\n\t\treturn UT64_MAX;\n\t}\n\n\tut64 entry = bin->ehdr.e_entry;\n\tif (entry) {\n\t\tut64 tmp = Elf_(rz_bin_elf_v2p)(bin, entry);\n\t\tif (tmp == UT64_MAX) {\n\t\t\treturn entry;\n\t\t}\n\n\t\treturn tmp;\n\t}\n\n\treturn get_entry_offset_from_shdr(bin);\n}\n\n/**\n * \\brief Compute the fini offset of the binary\n * \\param elf binary\n * \\return the init offset\n *\n * Get the offset from the vaddr store in the dynamic section (dt_fini)\n */\nut64 Elf_(rz_bin_elf_get_fini_offset)(RZ_NONNULL ELFOBJ *bin) {\n\trz_return_val_if_fail(bin, 0);\n\n\tut64 addr;\n\n\tif (!Elf_(rz_bin_elf_has_dt_dynamic)(bin)) {\n\t\treturn 0;\n\t}\n\n\tif (!Elf_(rz_bin_elf_get_dt_info)(bin, DT_FINI, &addr)) {\n\t\treturn 0;\n\t}\n\n\treturn Elf_(rz_bin_elf_v2p)(bin, addr);\n}\n\n/**\n * \\brief Compute the init offset of the binary\n * \\param elf binary\n * \\return the init offset\n *\n * Get the offset from the vaddr store in the dynamic section (dt_init)\n */\nut64 Elf_(rz_bin_elf_get_init_offset)(RZ_NONNULL ELFOBJ *bin) {\n\trz_return_val_if_fail(bin, 0);\n\n\tut64 addr;\n\n\tif (!Elf_(rz_bin_elf_has_dt_dynamic)(bin)) {\n\t\treturn 0;\n\t}\n\n\tif (!Elf_(rz_bin_elf_get_dt_info)(bin, DT_INIT, &addr)) {\n\t\treturn 0;\n\t}\n\n\treturn Elf_(rz_bin_elf_v2p)(bin, addr);\n}\n\n/**\n * \\brief Compute the main offset of the binary\n * \\param elf binary\n * \\return the main offset\n *\n * ...\n */\nut64 Elf_(rz_bin_elf_get_main_offset)(RZ_NONNULL ELFOBJ *bin) {\n\trz_return_val_if_fail(bin, UT64_MAX);\n\n\tut8 buf[256] = { 0 };\n\tut64 entry = Elf_(rz_bin_elf_get_entry_offset)(bin);\n\tut64 main_addr;\n\n\tif (entry == UT64_MAX || entry > bin->size || (entry + sizeof(buf)) > bin->size) {\n\t\treturn UT64_MAX;\n\t}\n\n\tif (rz_buf_read_at(bin->b, entry, buf, sizeof(buf)) < 0) {\n\t\treturn UT64_MAX;\n\t}\n\n\tmain_addr = get_main_offset_arm64(bin, entry, buf);\n\tif (main_addr != UT64_MAX) {\n\t\treturn main_addr;\n\t}\n\n\tmain_addr = get_main_offset_arm_glibc(bin, entry, buf);\n\tif (main_addr != UT64_MAX) {\n\t\treturn main_addr;\n\t}\n\n\tmain_addr = get_main_offset_mips(bin, entry, buf, RZ_ARRAY_SIZE(buf));\n\tif (main_addr != UT64_MAX) {\n\t\treturn main_addr;\n\t}\n\n\tmain_addr = get_main_offset_x86_gcc(bin, entry, buf);\n\tif (main_addr != UT64_MAX) {\n\t\treturn main_addr;\n\t}\n\n\tmain_addr = get_main_offset_x86_pie(bin, entry, buf);\n\tif (main_addr != UT64_MAX) {\n\t\treturn main_addr;\n\t}\n\n\tmain_addr = get_main_offset_x86_non_pie(bin, entry, buf);\n\tif (main_addr != UT64_MAX) {\n\t\treturn main_addr;\n\t}\n\n\tmain_addr = get_main_offset_linux_64_pie(bin, entry, buf);\n\tif (main_addr != UT64_MAX) {\n\t\treturn main_addr;\n\t}\n\n\treturn get_main_offset_from_symbol(bin);\n}\n"], "fixing_code": ["// SPDX-FileCopyrightText: 2021 08A <08A@riseup.net>\n// SPDX-FileCopyrightText: 2008-2020 nibble <nibble.ds@gmail.com>\n// SPDX-FileCopyrightText: 2008-2020 pancake <pancake@nopcode.org>\n// SPDX-FileCopyrightText: 2008-2020 alvaro_fe <alvaro.felipe91@gmail.com>\n// SPDX-License-Identifier: LGPL-3.0-only\n\n#include \"elf.h\"\n\n#define EF_MIPS_ABI_O32 0x00001000 /* O32 ABI.  */\n#define EF_MIPS_ABI_O64 0x00002000 /* O32 extended for 64 bit.  */\n#define EF_MIPS_ABI     0x0000f000\n\n#define VERSYM_VERSION 0x7fff\n\nstruct mips_bits_translation {\n\tElf_(Word) type;\n\tint bits;\n};\n\nstruct section_note_osabi_translation {\n\tconst char *note_name;\n\tconst char *os_name;\n};\n\nstruct machine_name_translation {\n\tElf_(Half) machine;\n\tconst char *name;\n};\n\nstruct class_translation {\n\tunsigned char class;\n\tconst char *name;\n};\n\nstruct cpu_mips_translation {\n\tElf_(Word) arch;\n\tconst char *name;\n};\n\nstruct arch_translation {\n\tElf_(Half) arch;\n\tconst char *name;\n};\n\nstruct ver_flags_translation {\n\tut32 flag;\n\tconst char *name;\n};\n\nstatic const struct mips_bits_translation mips_bits_translation_table[] = {\n\t{ EF_MIPS_ARCH_1, 32 },\n\t{ EF_MIPS_ARCH_2, 32 },\n\t{ EF_MIPS_ARCH_3, 32 },\n\t{ EF_MIPS_ARCH_4, 32 },\n\t{ EF_MIPS_ARCH_5, 32 },\n\t{ EF_MIPS_ARCH_32, 32 },\n\t{ EF_MIPS_ARCH_64, 64 },\n\t{ EF_MIPS_ARCH_32R2, 32 },\n\t{ EF_MIPS_ARCH_64R2, 64 }\n};\n\nstatic const struct section_note_osabi_translation section_note_osabi_translation_table[] = {\n\t{ \".note.openbsd.ident\", \"openbsd\" },\n\t{ \".note.minix.ident\", \"minix\" },\n\t{ \".note.netbsd.ident\", \"netbsd\" },\n\t{ \".note.android.ident\", \"android\" }\n};\n\nstatic const struct machine_name_translation machine_name_translation_table[] = {\n\t{ EM_NONE, \"No machine\" },\n\t{ EM_M32, \"AT&T WE 32100\" },\n\t{ EM_SPARC, \"SUN SPARC\" },\n\t{ EM_386, \"Intel 80386\" },\n\t{ EM_68K, \"Motorola m68k family\" },\n\t{ EM_88K, \"Motorola m88k family\" },\n\t{ EM_860, \"Intel 80860\" },\n\t{ EM_MIPS, \"MIPS R3000\" },\n\t{ EM_S370, \"IBM System/370\" },\n\t{ EM_MIPS_RS3_LE, \"MIPS R3000 little-endian\" },\n\t{ EM_PARISC, \"HPPA\" },\n\t{ EM_VPP500, \"Fujitsu VPP500\" },\n\t{ EM_SPARC32PLUS, \"Sun's \\\"v8plus\\\"\" },\n\t{ EM_960, \"Intel 80960\" },\n\t{ EM_PPC, \"PowerPC\" },\n\t{ EM_PPC64, \"PowerPC 64-bit\" },\n\t{ EM_S390, \"IBM S390\" },\n\t{ EM_V800, \"NEC V800 series\" },\n\t{ EM_FR20, \"Fujitsu FR20\" },\n\t{ EM_RH32, \"TRW RH-32\" },\n\t{ EM_RCE, \"Motorola RCE\" },\n\t{ EM_ARM, \"ARM\" },\n\t{ EM_BLACKFIN, \"Analog Devices Blackfin\" },\n\t{ EM_FAKE_ALPHA, \"Digital Alpha\" },\n\t{ EM_SH, \"Hitachi SH\" },\n\t{ EM_SPARCV9, \"SPARC v9 64-bit\" },\n\t{ EM_TRICORE, \"Siemens Tricore\" },\n\t{ EM_ARC, \"Argonaut RISC Core\" },\n\t{ EM_H8_300, \"Hitachi H8/300\" },\n\t{ EM_H8_300H, \"Hitachi H8/300H\" },\n\t{ EM_H8S, \"Hitachi H8S\" },\n\t{ EM_H8_500, \"Hitachi H8/500\" },\n\t{ EM_IA_64, \"Intel Merced\" },\n\t{ EM_MIPS_X, \"Stanford MIPS-X\" },\n\t{ EM_COLDFIRE, \"Motorola Coldfire\" },\n\t{ EM_68HC12, \"Motorola M68HC12\" },\n\t{ EM_MMA, \"Fujitsu MMA Multimedia Accelerator\" },\n\t{ EM_PCP, \"Siemens PCP\" },\n\t{ EM_NCPU, \"Sony nCPU embeeded RISC\" },\n\t{ EM_NDR1, \"Denso NDR1 microprocessor\" },\n\t{ EM_STARCORE, \"Motorola Start*Core processor\" },\n\t{ EM_ME16, \"Toyota ME16 processor\" },\n\t{ EM_ST100, \"STMicroelectronic ST100 processor\" },\n\t{ EM_TINYJ, \"Advanced Logic Corp. Tinyj emb.fam\" },\n\t{ EM_X86_64, \"AMD x86-64 architecture\" },\n\t{ EM_LANAI, \"32bit LANAI architecture\" },\n\t{ EM_PDSP, \"Sony DSP Processor\" },\n\t{ EM_PDP10, \"Digital Equipment Corp. PDP-10\" },\n\t{ EM_PDP11, \"Digital Equipment Corp. PDP-11\" },\n\t{ EM_FX66, \"Siemens FX66 microcontroller\" },\n\t{ EM_ST9PLUS, \"STMicroelectronics ST9+ 8/16 mc\" },\n\t{ EM_ST7, \"STmicroelectronics ST7 8 bit mc\" },\n\t{ EM_68HC16, \"Motorola MC68HC16 microcontroller\" },\n\t{ EM_68HC11, \"Motorola MC68HC11 microcontroller\" },\n\t{ EM_68HC08, \"Motorola MC68HC08 microcontroller\" },\n\t{ EM_68HC05, \"Motorola MC68HC05 microcontroller\" },\n\t{ EM_SVX, \"Silicon Graphics SVx\" },\n\t{ EM_ST19, \"STMicroelectronics ST19 8 bit mc\" },\n\t{ EM_VAX, \"Digital VAX\" },\n\t{ EM_CRIS, \"Axis Communications 32-bit embedded processor\" },\n\t{ EM_JAVELIN, \"Infineon Technologies 32-bit embedded processor\" },\n\t{ EM_FIREPATH, \"Element 14 64-bit DSP Processor\" },\n\t{ EM_ZSP, \"LSI Logic 16-bit DSP Processor\" },\n\t{ EM_MMIX, \"Donald Knuth's educational 64-bit processor\" },\n\t{ EM_HUANY, \"Harvard University machine-independent object files\" },\n\t{ EM_PRISM, \"SiTera Prism\" },\n\t{ EM_AVR, \"Atmel AVR 8-bit microcontroller\" },\n\t{ EM_FR30, \"Fujitsu FR30\" },\n\t{ EM_D10V, \"Mitsubishi D10V\" },\n\t{ EM_D30V, \"Mitsubishi D30V\" },\n\t{ EM_V850, \"NEC v850\" },\n\t{ EM_M32R, \"Mitsubishi M32R\" },\n\t{ EM_MN10300, \"Matsushita MN10300\" },\n\t{ EM_MN10200, \"Matsushita MN10200\" },\n\t{ EM_PJ, \"picoJava\" },\n\t{ EM_OPENRISC, \"OpenRISC 32-bit embedded processor\" },\n\t{ EM_ARC_A5, \"ARC Cores Tangent-A5\" },\n\t{ EM_XTENSA, \"Tensilica Xtensa Architecture\" },\n\t{ EM_AARCH64, \"ARM aarch64\" },\n\t{ EM_PROPELLER, \"Parallax Propeller\" },\n\t{ EM_MICROBLAZE, \"Xilinx MicroBlaze\" },\n\t{ EM_RISCV, \"RISC V\" },\n\t{ EM_VIDEOCORE3, \"VideoCore III\" },\n\t{ EM_VIDEOCORE4, \"VideoCore IV\" },\n\t{ EM_LATTICEMICO32, \"RISC processor for Lattice FPGA architecture\" },\n\t{ EM_SE_C17, \"Seiko Epson C17 family\" },\n\t{ EM_TI_C6000, \"The Texas Instruments TMS320C6000 DSP family\" },\n\t{ EM_TI_C2000, \"The Texas Instruments TMS320C2000 DSP family\" },\n\t{ EM_TI_C5500, \"The Texas Instruments TMS320C55x DSP family\" },\n\t{ EM_TI_ARP32, \"Texas Instruments Application Specific RISC Processor, 32bit fetch\" },\n\t{ EM_TI_PRU, \"Texas Instruments Programmable Realtime Unit\" },\n\t{ EM_MMDSP_PLUS, \"STMicroelectronics 64bit VLIW Data Signal Processor\" },\n\t{ EM_CYPRESS_M8C, \"Cypress M8C microprocessor\" },\n\t{ EM_R32C, \"Renesas R32C series microprocessors\" },\n\t{ EM_TRIMEDIA, \"NXP Semiconductors TriMedia architecture family\" },\n\t{ EM_QDSP6, \"QUALCOMM DSP6 Processor\" }, // Nonstandard\n\t{ EM_8051, \"Intel 8051 and variants\" },\n\t{ EM_STXP7X, \"STMicroelectronics STxP7x family of configurable and extensible RISC processors\" },\n\t{ EM_NDS32, \"Andes Technology compact code size embedded RISC processor family\" },\n\t{ EM_ECOG1, \"Cyan Technology eCOG1X family\" },\n\t{ EM_MAXQ30, \"Dallas Semiconductor MAXQ30 Core Micro-controllers\" },\n\t{ EM_XIMO16, \"New Japan Radio (NJR) 16-bit DSP Processor\" },\n\t{ EM_MANIK, \"M2000 Reconfigurable RISC Microprocessor\" },\n\t{ EM_CRAYNV2, \"Cray Inc. NV2 vector architecture\" },\n\t{ EM_RX, \"Renesas RX family\" },\n\t{ EM_METAG, \"Imagination Technologies META processor architecture\" },\n\t{ EM_MCST_ELBRUS, \"MCST Elbrus general purpose hardware architecture\" },\n\t{ EM_ECOG16, \"Cyan Technology eCOG16 family\" },\n\t{ EM_CR16, \"National Semiconductor CompactRISC CR16 16-bit microprocessor\" },\n\t{ EM_ETPU, \"Freescale Extended Time Processing Unit\" },\n\t{ EM_SLE9X, \"Infineon Technologies SLE9X core\" },\n\t{ EM_L10M, \"Intel L10M\" },\n\t{ EM_K10M, \"Intel K10M\" },\n\t{ EM_AVR32, \"Atmel Corporation 32-bit microprocessor family\" },\n\t{ EM_STM8, \"STMicroeletronics STM8 8-bit microcontroller\" },\n\t{ EM_TILE64, \"Tilera TILE64 multicore architecture family\" },\n\t{ EM_TILEPRO, \"Tilera TILEPro multicore architecture family\" },\n\t{ EM_CUDA, \"NVIDIA CUDA architecture\" },\n\t{ EM_TILEGX, \"Tilera TILE-Gx multicore architecture family\" },\n\t{ EM_CLOUDSHIELD, \"CloudShield architecture family\" },\n\t{ EM_COREA_1ST, \"KIPO-KAIST Core-A 1st generation processor family\" },\n\t{ EM_COREA_2ND, \"KIPO-KAIST Core-A 2nd generation processor family\" },\n\t{ EM_ARC_COMPACT2, \"Synopsys ARCompact V2\" },\n\t{ EM_OPEN8, \"Open8 8-bit RISC soft processor core\" },\n\t{ EM_RL78, \"Renesas RL78 family\" },\n\t{ EM_VIDEOCORE5, \"Broadcom VideoCore V processor\" },\n\t{ EM_78KOR, \"Renesas 78KOR family\" },\n\t{ EM_BA1, \"Beyond BA1 CPU architecture\" },\n\t{ EM_BA2_NON_STANDARD, \"Beyond BA2 CPU architecture\" },\n\t{ EM_BA2, \"Beyond BA2 CPU architecture\" },\n\t{ EM_XCORE, \"XMOS xCORE processor family\" },\n\t{ EM_MCHP_PIC, \"Microchip 8-bit PIC(r) family\" },\n\t{ EM_INTEL205, \"Reserved by Intel\" },\n\t{ EM_INTEL206, \"Reserved by Intel\" },\n\t{ EM_INTEL207, \"Reserved by Intel\" },\n\t{ EM_INTEL208, \"Reserved by Intel\" },\n\t{ EM_INTEL209, \"Reserved by Intel\" },\n\t{ EM_KM32, \"KM211 KM32 32-bit processor\" },\n\t{ EM_KMX32, \"KM211 KMX32 32-bit processor\" },\n\t{ EM_KMX16, \"KM211 KMX16 16-bit processor\" },\n\t{ EM_KMX8, \"KM211 KMX8 8-bit processor\" },\n\t{ EM_KVARC, \"KM211 KVARC processor\" },\n\t{ EM_CDP, \"Paneve CDP architecture family\" },\n\t{ EM_COGE, \"Cognitive Smart Memory Processor\" },\n\t{ EM_COOL, \"Bluechip Systems CoolEngine\" },\n\t{ EM_NORC, \"Nanoradio Optimized RISC\" },\n\t{ EM_CSR_KALIMBA, \"CSR Kalimba architecture family\" },\n\t{ EM_Z80, \"Zilog Z80\" },\n\t{ EM_VISIUM, \"Controls and Data Services VISIUMcore processor\" },\n\t{ EM_FT32, \"FTDI Chip FT32 high performance 32-bit RISC architecture\" },\n\t{ EM_MOXIE, \"Moxie processor family\" },\n\t{ EM_AMDGPU, \"AMD GPU architecture\" },\n\t{ EM_BPF, \"Linux BPF\" },\n\t{ EM_KVX, \"Kalray VLIW core of the MPPA processor family\" },\n};\n\nstatic const struct class_translation class_translation_table[] = {\n\t{ ELFCLASSNONE, \"none\" },\n\t{ ELFCLASS32, \"ELF32\" },\n\t{ ELFCLASS64, \"ELF64\" }\n};\n\nstatic const struct cpu_mips_translation cpu_mips_translation_table[] = {\n\t{ EF_MIPS_ARCH_1, \"mips1\" },\n\t{ EF_MIPS_ARCH_2, \"mips2\" },\n\t{ EF_MIPS_ARCH_3, \"mips3\" },\n\t{ EF_MIPS_ARCH_4, \"mips4\" },\n\t{ EF_MIPS_ARCH_5, \"mips5\" },\n\t{ EF_MIPS_ARCH_32, \"mips32\" },\n\t{ EF_MIPS_ARCH_64, \"mips64\" },\n\t{ EF_MIPS_ARCH_32R2, \"mips32r2\" },\n\t{ EF_MIPS_ARCH_64R2, \"mips64r2\" },\n};\n\nstatic const struct arch_translation arch_translation_table[] = {\n\t{ EM_ARC, \"arc\" },\n\t{ EM_ARC_A5, \"arc\" },\n\t{ EM_AVR, \"avr\" },\n\t{ EM_BA2_NON_STANDARD, \"ba2\" },\n\t{ EM_BA2, \"ba2\" },\n\t{ EM_CRIS, \"cris\" },\n\t{ EM_68K, \"m68k\" },\n\t{ EM_MIPS, \"mips\" },\n\t{ EM_MIPS_RS3_LE, \"mips\" },\n\t{ EM_MIPS_X, \"mips\" },\n\t{ EM_MCST_ELBRUS, \"elbrus\" },\n\t{ EM_TRICORE, \"tricore\" },\n\t{ EM_RCE, \"mcore\" },\n\t{ EM_ARM, \"arm\" },\n\t{ EM_AARCH64, \"arm\" },\n\t{ EM_QDSP6, \"hexagon\" },\n\t{ EM_BLACKFIN, \"blackfin\" },\n\t{ EM_SPARC, \"sparc\" },\n\t{ EM_SPARC32PLUS, \"sparc\" },\n\t{ EM_SPARCV9, \"sparc\" },\n\t{ EM_PPC, \"ppc\" },\n\t{ EM_PPC64, \"ppc\" },\n\t{ EM_PARISC, \"hppa\" },\n\t{ EM_PROPELLER, \"propeller\" },\n\t{ EM_MICROBLAZE, \"microblaze.gnu\" },\n\t{ EM_RISCV, \"riscv\" },\n\t{ EM_VAX, \"vax\" },\n\t{ EM_XTENSA, \"xtensa\" },\n\t{ EM_LANAI, \"lanai\" },\n\t{ EM_VIDEOCORE3, \"vc4\" },\n\t{ EM_VIDEOCORE4, \"vc4\" },\n\t{ EM_MSP430, \"msp430\" },\n\t{ EM_SH, \"sh\" },\n\t{ EM_V800, \"v850\" },\n\t{ EM_V850, \"v850\" },\n\t{ EM_IA_64, \"ia64\" },\n\t{ EM_S390, \"sysz\" },\n\t{ EM_386, \"x86\" },\n\t{ EM_X86_64, \"x86\" },\n\t{ EM_NONE, \"null\" },\n\t{ EM_BPF, \"bpf\" },\n\t{ EM_KVX, \"kvx\" },\n};\n\nstatic const struct ver_flags_translation ver_flags_translation_table[] = {\n\t{ VER_FLG_BASE, \"BASE \" },\n\t{ VER_FLG_BASE | VER_FLG_WEAK, \"| \" },\n\t{ VER_FLG_WEAK, \"WEAK \" },\n\t{ ~(VER_FLG_BASE | VER_FLG_WEAK), \"| <unknown>\" }\n};\n\nstatic ut64 get_main_offset_from_symbol(ELFOBJ *bin) {\n\tRzBinElfSymbol *symbol;\n\trz_bin_elf_foreach_symbols(bin, symbol) {\n\t\tif (symbol->name && !strcmp(symbol->name, \"main\")) {\n\t\t\tif (symbol->paddr != UT64_MAX) {\n\t\t\t\treturn symbol->paddr;\n\t\t\t}\n\n\t\t\treturn symbol->vaddr;\n\t\t}\n\t}\n\n\treturn UT64_MAX;\n}\n\nstatic ut64 get_main_offset_linux_64_pie(ELFOBJ *bin, ut64 entry, ut8 *buf) {\n\t/* linux64 pie main -- probably buggy in some cases */\n\tint bo = 29; // Begin offset may vary depending on the entry prelude\n\t// endbr64 - fedora bins have this\n\tif (buf[0] == 0xf3 && buf[1] == 0x0f && buf[2] == 0x1e && buf[3] == 0xfa) {\n\t\t// Change begin offset if binary starts with 'endbr64'\n\t\tbo = 33;\n\t\t// double xor for init and fini\n\t\tif (!memcmp(buf + 19, \"\\x45\\x31\\xc0\\x31\\xc9\", 5)) {\n\t\t\tbo = 24;\n\t\t}\n\t}\n\tif (buf[bo] == 0x48) {\n\t\tut8 ch = buf[bo + 1];\n\t\tif (ch == 0x8d) { // lea rdi, qword [rip + MAINDELTA]\n\t\t\tut8 *p = buf + bo + 3;\n\t\t\tst32 maindelta = (st32)rz_read_le32(p);\n\t\t\tut64 ventry = Elf_(rz_bin_elf_p2v)(bin, entry);\n\t\t\tif (ventry == UT64_MAX) {\n\t\t\t\treturn UT64_MAX;\n\t\t\t}\n\t\t\tut64 vmain = (ut64)(ventry + bo + maindelta) + 7;\n\t\t\treturn Elf_(rz_bin_elf_v2p)(bin, vmain);\n\t\t} else if (ch == 0xc7) { // mov rdi, 0xADDR\n\t\t\tut8 *p = buf + bo + 3;\n\t\t\tut64 addr = (ut64)rz_read_le32(p);\n\t\t\treturn Elf_(rz_bin_elf_v2p)(bin, addr);\n\t\t}\n\t}\n\n\treturn UT64_MAX;\n}\n\nstatic ut64 get_main_offset_x86_non_pie(ELFOBJ *bin, ut64 entry, ut8 *buf) {\n\t// X86-NONPIE\n#if RZ_BIN_ELF64\n\tif (!memcmp(buf, \"\\x49\\x89\\xd9\", 3) && buf[156] == 0xe8) { // openbsd\n\t\treturn rz_read_le32(buf + 157) + entry + 156 + 5;\n\t}\n\tif (!memcmp(buf + 29, \"\\x48\\xc7\\xc7\", 3)) { // linux\n\t\tut64 addr = (ut64)rz_read_le32(buf + 29 + 3);\n\t\treturn Elf_(rz_bin_elf_v2p)(bin, addr);\n\t}\n#else\n\tif (buf[23] == '\\x68') {\n\t\tut64 addr = (ut64)rz_read_le32(buf + 23 + 1);\n\t\treturn Elf_(rz_bin_elf_v2p)(bin, addr);\n\t}\n#endif\n\n\treturn UT64_MAX;\n}\n\nstatic ut64 get_main_offset_x86_pie(ELFOBJ *bin, ut64 entry, ut8 *buf) {\n\t// X86-PIE\n\tif (buf[0x00] == 0x48 && buf[0x1e] == 0x8d && buf[0x11] == 0xe8) {\n\t\tut32 *pmain = (ut32 *)(buf + 0x30);\n\t\tut64 vmain = Elf_(rz_bin_elf_p2v)(bin, (ut64)*pmain);\n\t\tut64 ventry = Elf_(rz_bin_elf_p2v)(bin, entry);\n\t\tif (vmain >> 16 == ventry >> 16) {\n\t\t\treturn vmain;\n\t\t}\n\t}\n\t// X86-PIE\n\tif (buf[0x1d] == 0x48 && buf[0x1e] == 0x8b) {\n\t\tif (!memcmp(buf, \"\\x31\\xed\\x49\\x89\", 4)) { // linux\n\t\t\tut64 maddr, baddr;\n\t\t\tut8 n32s[sizeof(ut32)] = { 0 };\n\t\t\tmaddr = entry + 0x24 + rz_read_le32(buf + 0x20);\n\t\t\tif (rz_buf_read_at(bin->b, maddr, n32s, sizeof(ut32)) == -1) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tmaddr = (ut64)rz_read_le32(&n32s[0]);\n\t\t\tbaddr = (bin->ehdr.e_entry >> 16) << 16;\n\t\t\tif (Elf_(rz_bin_elf_has_segments)(bin)) {\n\t\t\t\tbaddr = Elf_(rz_bin_elf_get_baddr)(bin);\n\t\t\t}\n\t\t\tmaddr += baddr;\n\t\t\treturn maddr;\n\t\t}\n\t}\n\n\treturn UT64_MAX;\n}\n\nstatic ut64 get_main_offset_x86_gcc(ELFOBJ *bin, ut64 entry, ut8 *buf) {\n\tif (buf[0] != 0xe8 && memcmp(buf + 5, \"\\x50\\xe8\\x00\\x00\\x00\\x00\\xb8\\x01\\x00\\x00\\x00\\x53\", 12)) {\n\t\treturn UT64_MAX;\n\t}\n\n\tsize_t SIZEOF_CALL = 5;\n\tut64 rel_addr = (ut64)(buf[1] + (buf[2] << 8) + (buf[3] << 16) + (buf[4] << 24));\n\tut64 addr = Elf_(rz_bin_elf_p2v)(bin, entry + SIZEOF_CALL);\n\taddr += rel_addr;\n\treturn Elf_(rz_bin_elf_v2p)(bin, addr);\n}\n\nstatic ut64 get_main_offset_mips(ELFOBJ *bin, ut64 entry, ut8 *buf, size_t size) {\n\t/* get .got, calculate offset of main symbol */\n\tif (memcmp(buf, \"\\x21\\x00\\xe0\\x03\\x01\\x00\\x11\\x04\", 8)) {\n\t\treturn UT64_MAX;\n\t}\n\n\t/*\n\t   assuming the startup code looks like\n\t   got = gp-0x7ff0\n\t   got[index__libc_start_main] ( got[index_main] );\n\n\t   looking for the instruction generating the first argument to find main\n\t   lw a0, offset(gp)\n\t   */\n\tut64 got_addr;\n\n\tif (!Elf_(rz_bin_elf_get_dt_info)(bin, DT_PLTGOT, &got_addr)) {\n\t\treturn 0;\n\t}\n\n\tut64 got_offset = Elf_(rz_bin_elf_v2p)(bin, got_addr);\n\tut64 gp = got_offset + 0x7ff0;\n\n\tfor (size_t i = 0; i < size; i += 4) {\n\t\tconst ut32 instr = rz_read_le32(buf + i);\n\t\tif ((instr & 0xffff0000) == 0x8f840000) { // lw a0, offset(gp)\n\t\t\tconst short delta = instr & 0x0000ffff;\n\t\t\trz_buf_read_at(bin->b, /* got_entry_offset = */ gp + delta, buf, 4);\n\t\t\treturn Elf_(rz_bin_elf_v2p)(bin, rz_read_le32(buf));\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic ut64 get_main_offset_arm_glibc_thumb(ELFOBJ *bin, ut64 entry, ut8 *buf) {\n\tsize_t delta = 0;\n\n\tif (!memcmp(buf, \"\\xf0\\x00\\x0b\\x4f\\xf0\\x00\\x0e\\x02\\xbc\\x6a\\x46\", 11)) {\n\t\t/* newer versions of gcc use push/pop */\n\t\tdelta = 0x28;\n\t} else if (!memcmp(buf, \"\\xf0\\x00\\x0b\\x4f\\xf0\\x00\\x0e\\x5d\\xf8\\x04\\x1b\", 11)) {\n\t\t/* older versions of gcc (4.5.x) use ldr/str */\n\t\tdelta = 0x30;\n\t}\n\n\tif (delta) {\n\t\tut64 tmp = rz_read_le32(buf + delta - 1) & ~1;\n\t\tut64 pa = Elf_(rz_bin_elf_v2p)(bin, tmp);\n\t\tif (pa < rz_buf_size(bin->b)) {\n\t\t\treturn pa;\n\t\t}\n\t}\n\n\treturn UT64_MAX;\n}\n\nstatic ut64 get_main_offset_arm_glibc_non_thumb(ELFOBJ *bin, ut64 entry, ut8 *buf) {\n\tif (!memcmp(buf, \"\\x00\\xb0\\xa0\\xe3\\x00\\xe0\\xa0\\xe3\", 8)) {\n\t\treturn Elf_(rz_bin_elf_v2p)(bin, rz_read_le32(buf + 0x34) & ~1);\n\t}\n\n\tif (!memcmp(buf, \"\\x24\\xc0\\x9f\\xe5\\x00\\xb0\\xa0\\xe3\", 8)) {\n\t\treturn Elf_(rz_bin_elf_v2p)(bin, rz_read_le32(buf + 0x30) & ~1);\n\t}\n\n\treturn UT64_MAX;\n}\n\nstatic ut64 get_main_offset_arm_glibc(ELFOBJ *bin, ut64 entry, ut8 *buf) {\n\t// ARM Glibc\n\tif (Elf_(rz_bin_elf_is_thumb_addr)(entry)) {\n\t\treturn get_main_offset_arm_glibc_thumb(bin, entry, buf);\n\t} else {\n\t\treturn get_main_offset_arm_glibc_non_thumb(bin, entry, buf);\n\t}\n\n\treturn UT64_MAX;\n}\n\nstatic ut64 get_main_offset_arm64(ELFOBJ *bin, ut64 entry, ut8 *buf) {\n\tif (buf[0x18 + 3] != 0x58 || buf[0x2f] != 0x00) {\n\t\treturn UT64_MAX;\n\t}\n\n\tut64 entry_vaddr = Elf_(rz_bin_elf_p2v)(bin, entry);\n\tif (entry_vaddr == UT64_MAX) {\n\t\treturn UT64_MAX;\n\t}\n\n\tut64 main_addr = rz_read_le32(buf + 0x30);\n\n\tif (main_addr >> 16 == entry_vaddr >> 16) {\n\t\treturn Elf_(rz_bin_elf_v2p)(bin, main_addr);\n\t}\n\n\treturn UT64_MAX;\n}\n\nstatic ut64 get_entry_offset_from_shdr(ELFOBJ *bin) {\n\tRzBinElfSection *section = Elf_(rz_bin_elf_get_section_with_name)(bin, \".init.text\");\n\tif (section) {\n\t\treturn section->offset;\n\t}\n\n\tsection = Elf_(rz_bin_elf_get_section_with_name)(bin, \".text\");\n\tif (section) {\n\t\treturn section->offset;\n\t}\n\n\tsection = Elf_(rz_bin_elf_get_section_with_name)(bin, \".init\");\n\tif (section) {\n\t\treturn section->offset;\n\t}\n\n\treturn UT64_MAX;\n}\n\nstatic ut64 compute_boffset_from_phdr(ELFOBJ *bin) {\n\tut64 base = UT64_MAX;\n\n\tRzBinElfSegment *iter;\n\trz_bin_elf_foreach_segments(bin, iter) {\n\t\tif (iter->data.p_type == PT_LOAD) {\n\t\t\tbase = RZ_MIN(base, iter->data.p_offset);\n\t\t}\n\t}\n\n\treturn base == UT64_MAX ? 0 : base;\n}\n\nstatic ut64 compute_baddr_from_phdr(ELFOBJ *bin) {\n\tut64 base = UT64_MAX;\n\n\tRzBinElfSegment *iter;\n\trz_bin_elf_foreach_segments(bin, iter) {\n\t\tif (iter->data.p_type == PT_LOAD) {\n\t\t\tbase = RZ_MIN(base, iter->data.p_vaddr);\n\t\t}\n\t}\n\n\treturn base == UT64_MAX ? 0 : base;\n}\n\nstatic bool elf_is_bind_now(ELFOBJ *bin) {\n\tut64 flags_1;\n\n\tif (Elf_(rz_bin_elf_get_dt_info)(bin, DT_BIND_NOW, NULL)) {\n\t\treturn true;\n\t}\n\n\tif (Elf_(rz_bin_elf_get_dt_info)(bin, DT_FLAGS_1, &flags_1)) {\n\t\treturn flags_1 & DF_1_NOW;\n\t}\n\n\treturn false;\n}\n\nstatic bool elf_has_gnu_relro(ELFOBJ *bin) {\n\tif (!Elf_(rz_bin_elf_has_segments)(bin)) {\n\t\treturn false;\n\t}\n\n\tRzBinElfSegment *segment = Elf_(rz_bin_elf_get_segment_with_type)(bin, PT_GNU_RELRO);\n\treturn segment && segment->is_valid;\n}\n\nstatic int get_bits_common(ELFOBJ *bin) {\n\tswitch (bin->ehdr.e_ident[EI_CLASS]) {\n\tcase ELFCLASS32:\n\t\treturn 32;\n\tcase ELFCLASS64:\n\t\treturn 64;\n\tcase ELFCLASSNONE:\n\tdefault:\n\t\treturn 32;\n\t}\n}\n\nstatic bool has_thumb_symbol(ELFOBJ *bin) {\n\tRzBinElfSymbol *symbol;\n\trz_bin_elf_foreach_symbols(bin, symbol) {\n\t\tif (Elf_(rz_bin_elf_is_thumb_addr)(symbol->paddr) || Elf_(rz_bin_elf_is_thumb_addr)(symbol->vaddr)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic int get_bits_mips_common(Elf_(Word) mips_type) {\n\tfor (size_t i = 0; i < RZ_ARRAY_SIZE(mips_bits_translation_table); i++) {\n\t\tif (mips_type == mips_bits_translation_table[i].type) {\n\t\t\treturn mips_bits_translation_table[i].bits;\n\t\t}\n\t}\n\n\treturn 32;\n}\n\nstatic int is_playstation_hack(ELFOBJ *bin, Elf_(Word) mips_type) {\n\treturn Elf_(rz_bin_elf_is_executable)(bin) && Elf_(rz_bin_elf_is_static)(bin) && mips_type == EF_MIPS_ARCH_3;\n}\n\nstatic int get_bits_mips(ELFOBJ *bin) {\n\tconst Elf_(Word) mips_type = bin->ehdr.e_flags & EF_MIPS_ARCH;\n\n\tif (is_playstation_hack(bin, mips_type)) {\n\t\treturn 64;\n\t}\n\n\treturn get_bits_mips_common(mips_type);\n}\n\nstatic bool arch_is_mips(ELFOBJ *bin) {\n\treturn Elf_(rz_bin_elf_has_segments)(bin) && bin->ehdr.e_machine == EM_MIPS;\n}\n\nstatic bool arch_is_arcompact(ELFOBJ *bin) {\n\treturn bin->ehdr.e_machine == EM_ARC_A5;\n}\n\nstatic char *read_elf_intrp(ELFOBJ *bin, ut64 addr, size_t size) {\n\tchar *str = malloc(size + 1);\n\tif (!str) {\n\t\treturn NULL;\n\t}\n\n\tif (rz_buf_read_at(bin->b, addr, (ut8 *)str, size) < 0) {\n\t\tfree(str);\n\t\treturn NULL;\n\t}\n\n\tstr[size] = 0;\n\n\treturn str;\n}\n\nstatic char *get_elf_intrp(ELFOBJ *bin, RzBinElfSegment *segment) {\n\tut64 addr = segment->data.p_offset;\n\tsize_t size = segment->data.p_filesz;\n\n\tif (!sdb_num_set(bin->kv, \"elf_header.intrp_addr\", addr, 0) ||\n\t\t!sdb_num_set(bin->kv, \"elf_header.intrp_size\", size, 0)) {\n\t\treturn NULL;\n\t}\n\n\tif (size < 1 || size > rz_buf_size(bin->b)) {\n\t\treturn NULL;\n\t}\n\n\tchar *str = read_elf_intrp(bin, addr, size);\n\tif (!str) {\n\t\treturn NULL;\n\t}\n\n\tif (!sdb_set(bin->kv, \"elf_header.intrp\", str, 0)) {\n\t\tfree(str);\n\t\treturn NULL;\n\t}\n\n\treturn str;\n}\n\nstatic Elf_(Xword) get_dt_rpath(ELFOBJ *bin) {\n\tut64 path;\n\n\tif (Elf_(rz_bin_elf_get_dt_info)(bin, DT_RPATH, &path)) {\n\t\treturn path;\n\t}\n\n\tif (Elf_(rz_bin_elf_get_dt_info)(bin, DT_RUNPATH, &path)) {\n\t\treturn path;\n\t}\n\n\treturn 0;\n}\n\nstatic char *get_ver_flags(ut32 flags) {\n\tchar *result = NULL;\n\n\tif (!flags) {\n\t\treturn strdup(\"none\");\n\t}\n\n\tfor (size_t i = 0; i < RZ_ARRAY_SIZE(ver_flags_translation_table); i++) {\n\t\tif (flags & ver_flags_translation_table[i].flag) {\n\t\t\tresult = rz_str_append(result, ver_flags_translation_table[i].name);\n\t\t}\n\t}\n\n\treturn result;\n}\n\nstatic bool has_dt_rpath_entry(ELFOBJ *bin) {\n\treturn Elf_(rz_bin_elf_get_dt_info)(bin, DT_RPATH, NULL) || Elf_(rz_bin_elf_get_dt_info)(bin, DT_RUNPATH, NULL);\n}\n\nstatic char *get_osabi_name_from_section_note(ELFOBJ *bin, RzBinElfSection *section) {\n\tif (section->type != SHT_NOTE) {\n\t\treturn NULL;\n\t}\n\n\tfor (size_t i = 0; i < RZ_ARRAY_SIZE(section_note_osabi_translation_table); i++) {\n\t\tif (!strcmp(section->name, section_note_osabi_translation_table[i].note_name)) {\n\t\t\treturn strdup(section_note_osabi_translation_table[i].os_name);\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic char *get_osabi_name_from_shdr(ELFOBJ *bin) {\n\tif (!bin->shstrtab) {\n\t\treturn NULL;\n\t}\n\n\tRzBinElfSection *section;\n\trz_bin_elf_foreach_sections(bin, section) {\n\t\tif (!section->is_valid) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tchar *tmp = get_osabi_name_from_section_note(bin, section);\n\t\tif (tmp) {\n\t\t\treturn tmp;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic char *get_osabi_name_from_ehdr(ELFOBJ *bin) {\n\tswitch (bin->ehdr.e_ident[EI_OSABI]) {\n\tcase ELFOSABI_LINUX:\n\t\treturn strdup(\"linux\");\n\tcase ELFOSABI_SOLARIS:\n\t\treturn strdup(\"solaris\");\n\tcase ELFOSABI_FREEBSD:\n\t\treturn strdup(\"freebsd\");\n\tcase ELFOSABI_HPUX:\n\t\treturn strdup(\"hpux\");\n\t}\n\n\treturn NULL;\n}\n\nstatic char *add_abi_info(ELFOBJ *bin, char *head_flag) {\n\tchar *str = Elf_(rz_bin_elf_get_abi)(bin);\n\n\tif (str) {\n\t\thead_flag = rz_str_appendf(head_flag, \" %s\", str);\n\t\tfree(str);\n\t}\n\n\treturn head_flag;\n}\n\nstatic char *add_cpu_info(ELFOBJ *bin, char *head_flag) {\n\tchar *str = Elf_(rz_bin_elf_get_cpu)(bin);\n\n\tif (str) {\n\t\thead_flag = rz_str_append_owned(head_flag, str);\n\t}\n\n\treturn head_flag;\n}\n\nstatic char *get_head_flag(ELFOBJ *bin) {\n\tchar *head_flag = NULL;\n\n\thead_flag = add_cpu_info(bin, head_flag);\n\thead_flag = add_abi_info(bin, head_flag);\n\n\treturn head_flag;\n}\n\nstatic bool file_type_is_processor_specific(ELFOBJ *bin) {\n\treturn bin->ehdr.e_type >= ET_LOPROC && bin->ehdr.e_type <= ET_HIPROC;\n}\n\nstatic bool file_type_is_os_specific(ELFOBJ *bin) {\n\treturn bin->ehdr.e_type >= ET_LOOS && bin->ehdr.e_type <= ET_HIOS;\n}\n\nstatic char *get_file_type_basic(RZ_NONNULL ELFOBJ *bin) {\n\tswitch (bin->ehdr.e_type) {\n\tcase ET_NONE:\n\t\treturn strdup(\"NONE (None)\");\n\tcase ET_REL:\n\t\treturn strdup(\"REL (Relocatable file)\");\n\tcase ET_EXEC:\n\t\treturn strdup(\"EXEC (Executable file)\");\n\tcase ET_DYN:\n\t\treturn strdup(\"DYN (Shared object file)\");\n\tcase ET_CORE:\n\t\treturn strdup(\"CORE (Core file)\");\n\t}\n\n\treturn NULL;\n}\n\nstatic char *get_cpu_mips(ELFOBJ *bin) {\n\tElf_(Word) mips_arch = bin->ehdr.e_flags & EF_MIPS_ARCH;\n\n\tfor (size_t i = 0; i < RZ_ARRAY_SIZE(cpu_mips_translation_table); i++) {\n\t\tif (mips_arch == cpu_mips_translation_table[i].arch) {\n\t\t\treturn strdup(cpu_mips_translation_table[i].name);\n\t\t}\n\t}\n\n\treturn strdup(\" Unknown mips ISA\");\n}\n\nstatic bool is_elf_class64(ELFOBJ *bin) {\n\treturn bin->ehdr.e_ident[EI_CLASS] == ELFCLASS64;\n}\n\nstatic bool is_mips_o32(ELFOBJ *bin) {\n\tif (bin->ehdr.e_ident[EI_CLASS] != ELFCLASS32) {\n\t\treturn false;\n\t}\n\n\tif ((bin->ehdr.e_flags & EF_MIPS_ABI2) != 0) {\n\t\treturn false;\n\t}\n\n\tif ((bin->ehdr.e_flags & EF_MIPS_ABI) != 0 && (bin->ehdr.e_flags & EF_MIPS_ABI) != EF_MIPS_ABI_O32) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool is_mips_n32(ELFOBJ *bin) {\n\tif (bin->ehdr.e_ident[EI_CLASS] != ELFCLASS32) {\n\t\treturn false;\n\t}\n\n\tif ((bin->ehdr.e_flags & EF_MIPS_ABI2) == 0 || (bin->ehdr.e_flags & EF_MIPS_ABI) != 0) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic char *get_abi_mips(ELFOBJ *bin) {\n\tif (is_elf_class64(bin)) {\n\t\treturn strdup(\"n64\");\n\t}\n\n\tif (is_mips_n32(bin)) {\n\t\treturn strdup(\"n32\");\n\t}\n\n\tif (is_mips_o32(bin)) {\n\t\treturn strdup(\"o32\");\n\t}\n\n\treturn NULL;\n}\n\n/**\n * \\brief List all imported lib\n * \\param elf binary\n * \\return an allocated list of char*\n *\n * Use dynamic information (dt_needed) to generate a list of imported lib\n */\nRZ_OWN RzList /*<char *>*/ *Elf_(rz_bin_elf_get_libs)(RZ_NONNULL ELFOBJ *bin) {\n\trz_return_val_if_fail(bin, NULL);\n\n\tif (!Elf_(rz_bin_elf_has_dt_dynamic)(bin) || !bin->dynstr) {\n\t\treturn NULL;\n\t}\n\n\tRzVector *dt_needed = Elf_(rz_bin_elf_get_dt_needed)(bin);\n\tif (!dt_needed) {\n\t\treturn NULL;\n\t}\n\n\tRzList *result = rz_list_newf(free);\n\tif (!result) {\n\t\treturn NULL;\n\t}\n\n\tut64 *iter = NULL;\n\trz_vector_foreach(dt_needed, iter) {\n\t\tchar *tmp = Elf_(rz_bin_elf_strtab_get_dup)(bin->dynstr, *iter);\n\t\tif (!tmp) {\n\t\t\trz_list_free(result);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (!rz_list_append(result, tmp)) {\n\t\t\trz_list_free(result);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn result;\n}\n\nstatic bool get_verdaux_entry_aux(ELFOBJ *bin, ut64 offset, Elf_(Verdaux) * entry) {\n\treturn Elf_(rz_bin_elf_read_word)(bin, &offset, &entry->vda_name) &&\n\t\tElf_(rz_bin_elf_read_word)(bin, &offset, &entry->vda_next);\n}\n\nstatic bool get_verdaux_entry(ELFOBJ *bin, ut64 offset, Elf_(Verdaux) * entry) {\n\tif (!get_verdaux_entry_aux(bin, offset, entry)) {\n\t\tRZ_LOG_WARN(\"Failed to read verdaux entry at 0x%\" PFMT64x \".\\n\", offset);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool get_verdef_entry_aux(ELFOBJ *bin, ut64 offset, Elf_(Verdef) * entry) {\n\treturn Elf_(rz_bin_elf_read_half)(bin, &offset, &entry->vd_version) &&\n\t\tElf_(rz_bin_elf_read_half)(bin, &offset, &entry->vd_flags) &&\n\t\tElf_(rz_bin_elf_read_half)(bin, &offset, &entry->vd_ndx) &&\n\t\tElf_(rz_bin_elf_read_half)(bin, &offset, &entry->vd_cnt) &&\n\t\tElf_(rz_bin_elf_read_word)(bin, &offset, &entry->vd_hash) &&\n\t\tElf_(rz_bin_elf_read_word)(bin, &offset, &entry->vd_aux) &&\n\t\tElf_(rz_bin_elf_read_word)(bin, &offset, &entry->vd_next);\n}\n\nstatic bool get_verdef_entry(ELFOBJ *bin, ut64 offset, Elf_(Verdef) * entry) {\n\tif (!get_verdef_entry_aux(bin, offset, entry)) {\n\t\tRZ_LOG_WARN(\"Failed to read verdef entry at 0x%\" PFMT64x \".\\n\", offset);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool get_vernaux_entry_aux(ELFOBJ *bin, ut64 offset, Elf_(Vernaux) * entry) {\n\treturn Elf_(rz_bin_elf_read_word)(bin, &offset, &entry->vna_hash) &&\n\t\tElf_(rz_bin_elf_read_half)(bin, &offset, &entry->vna_flags) &&\n\t\tElf_(rz_bin_elf_read_half)(bin, &offset, &entry->vna_other) &&\n\t\tElf_(rz_bin_elf_read_word)(bin, &offset, &entry->vna_name) &&\n\t\tElf_(rz_bin_elf_read_word)(bin, &offset, &entry->vna_next);\n}\n\nstatic bool get_vernaux_entry(ELFOBJ *bin, ut64 offset, Elf_(Vernaux) * entry) {\n\tif (!get_vernaux_entry_aux(bin, offset, entry)) {\n\t\tRZ_LOG_WARN(\"Failed to read vernaux entry at 0x%\" PFMT64x \".\\n\", offset);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\nstatic bool get_verneed_entry_aux(ELFOBJ *bin, ut64 offset, Elf_(Verneed) * entry) {\n\treturn Elf_(rz_bin_elf_read_half)(bin, &offset, &entry->vn_version) &&\n\t\tElf_(rz_bin_elf_read_half)(bin, &offset, &entry->vn_cnt) &&\n\t\tElf_(rz_bin_elf_read_word)(bin, &offset, &entry->vn_file) &&\n\t\tElf_(rz_bin_elf_read_word)(bin, &offset, &entry->vn_aux) &&\n\t\tElf_(rz_bin_elf_read_word)(bin, &offset, &entry->vn_next);\n}\n\nstatic bool get_verneed_entry(ELFOBJ *bin, ut64 offset, Elf_(Verneed) * entry) {\n\tif (!get_verneed_entry_aux(bin, offset, entry)) {\n\t\tRZ_LOG_WARN(\"Failed to read verneed entry at 0x%\" PFMT64x \".\\n\", offset);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool get_versym_entry_sdb_from_verneed(ELFOBJ *bin, Sdb *sdb, const char *key, Elf_(Versym) versym) {\n\tut64 verneed_addr;\n\tut64 verneed_num;\n\n\tif (!Elf_(rz_bin_elf_get_dt_info)(bin, DT_VERNEED, &verneed_addr) || !Elf_(rz_bin_elf_get_dt_info)(bin, DT_VERNEEDNUM, &verneed_num)) {\n\t\treturn false;\n\t}\n\n\tut64 verneed_offset = Elf_(rz_bin_elf_v2p(bin, verneed_addr));\n\n\tif (verneed_offset == UT64_MAX) {\n\t\treturn false;\n\t}\n\n\tut64 verneed_entry_offset = verneed_offset;\n\n\tfor (size_t i = 0; i < verneed_num; i++) {\n\t\tElf_(Verneed) verneed_entry;\n\t\tif (!get_verneed_entry(bin, verneed_entry_offset, &verneed_entry)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tut64 vernaux_entry_offset = verneed_entry_offset + verneed_entry.vn_aux;\n\n\t\tfor (size_t j = 0; j < verneed_entry.vn_cnt; j++) {\n\t\t\tElf_(Vernaux) vernaux_entry;\n\t\t\tif (!get_vernaux_entry(bin, vernaux_entry_offset, &vernaux_entry)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (vernaux_entry.vna_other != versym) {\n\t\t\t\tvernaux_entry_offset += vernaux_entry.vna_next;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst char *tmp = Elf_(rz_bin_elf_strtab_get)(bin->dynstr, vernaux_entry.vna_name);\n\t\t\tif (!tmp) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tchar *value = rz_str_newf(\"%u (%s)\", versym & VERSYM_VERSION, tmp);\n\t\t\tif (!value) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (!sdb_set_owned(sdb, key, value, 0)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\tverneed_entry_offset += verneed_entry.vn_next;\n\t}\n\n\treturn false;\n}\n\nstatic bool get_versym_entry_sdb_from_verdef(ELFOBJ *bin, Sdb *sdb, const char *key, Elf_(Versym) versym) {\n\tut64 verdef_addr;\n\tut64 verdef_num;\n\n\tif (!Elf_(rz_bin_elf_get_dt_info)(bin, DT_VERDEF, &verdef_addr) || !Elf_(rz_bin_elf_get_dt_info)(bin, DT_VERDEFNUM, &verdef_num)) {\n\t\treturn false;\n\t}\n\n\tut64 verdef_offset = Elf_(rz_bin_elf_v2p(bin, verdef_addr));\n\n\tif (verdef_offset == UT64_MAX) {\n\t\treturn false;\n\t}\n\n\tut64 verdef_entry_offset = verdef_offset;\n\n\tfor (size_t i = 0; i < verdef_num; i++) {\n\t\tElf_(Verdef) verdef_entry;\n\t\tif (!get_verdef_entry(bin, verdef_entry_offset, &verdef_entry)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!verdef_entry.vd_cnt || verdef_entry.vd_ndx != (versym & VERSYM_VERSION)) {\n\t\t\tverdef_entry_offset += verdef_entry.vd_next;\n\t\t\tcontinue;\n\t\t}\n\n\t\tut64 verdaux_entry_offset = verdef_entry_offset + verdef_entry.vd_aux;\n\n\t\tElf_(Verdaux) verdaux_entry;\n\t\tif (!get_verdaux_entry(bin, verdaux_entry_offset, &verdaux_entry)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst char *tmp = Elf_(rz_bin_elf_strtab_get)(bin->dynstr, verdaux_entry.vda_name);\n\t\tif (!tmp) {\n\t\t\treturn false;\n\t\t}\n\n\t\tchar *value = rz_str_newf(\"%u (%s)\", versym & VERSYM_VERSION, tmp);\n\t\tif (!value) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!sdb_set_owned(sdb, key, value, 0)) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic Sdb *get_gnu_versym(ELFOBJ *bin) {\n\tut64 versym_addr;\n\n\tif (!Elf_(rz_bin_elf_get_dt_info)(bin, DT_VERSYM, &versym_addr)) {\n\t\treturn false;\n\t}\n\n\tut64 versym_offset = Elf_(rz_bin_elf_v2p(bin, versym_addr));\n\n\tif (versym_offset == UT64_MAX) {\n\t\treturn NULL;\n\t}\n\n\tut64 number_of_symbols = Elf_(rz_bin_elf_get_number_of_dynamic_symbols)(bin);\n\tif (!number_of_symbols) {\n\t\treturn NULL;\n\t}\n\n\tSdb *sdb = sdb_new0();\n\tif (!sdb) {\n\t\treturn NULL;\n\t}\n\n\tif (!sdb_num_set(sdb, \"num_entries\", number_of_symbols, 0) ||\n\t\t!sdb_num_set(sdb, \"addr\", versym_addr, 0) ||\n\t\t!sdb_num_set(sdb, \"offset\", versym_offset, 0)) {\n\t\tsdb_free(sdb);\n\t\treturn NULL;\n\t}\n\n\tut64 versym_entry_offset = versym_offset;\n\n\tfor (size_t i = 0; i < number_of_symbols; i++) {\n\t\tchar key[32];\n\t\tif (rz_strf(key, \"entry%zu\", i) == NULL) {\n\t\t\tsdb_free(sdb);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tElf_(Versym) versym_entry;\n\t\tif (!Elf_(rz_bin_elf_read_versym)(bin, &versym_entry_offset, &versym_entry)) {\n\t\t\tsdb_free(sdb);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tswitch (versym_entry) {\n\t\tcase VER_NDX_LOCAL:\n\t\t\tif (!sdb_set(sdb, key, \"0 (*local*)\", 0)) {\n\t\t\t\tsdb_free(sdb);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase VER_NDX_GLOBAL:\n\t\t\tif (!sdb_set(sdb, key, \"1 (*global*)\", 0)) {\n\t\t\t\tsdb_free(sdb);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (get_versym_entry_sdb_from_verneed(bin, sdb, key, versym_entry)) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!get_versym_entry_sdb_from_verdef(bin, sdb, key, versym_entry)) {\n\t\t\t\tsdb_free(sdb);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sdb;\n}\n\nstatic Sdb *get_vernaux_entry_sdb(ELFOBJ *bin, Elf_(Vernaux) vernaux_entry, size_t index) {\n\tconst char *tmp = Elf_(rz_bin_elf_strtab_get)(bin->dynstr, vernaux_entry.vna_name);\n\tif (!tmp) {\n\t\treturn NULL;\n\t}\n\n\tSdb *sdb_vernaux = sdb_new0();\n\tif (!sdb_vernaux) {\n\t\treturn NULL;\n\t}\n\n\tchar *flags = get_ver_flags(vernaux_entry.vna_flags);\n\tif (!sdb_set_owned(sdb_vernaux, \"flags\", flags, 0)) {\n\t\tsdb_free(sdb_vernaux);\n\t\treturn NULL;\n\t}\n\n\tif (!sdb_num_set(sdb_vernaux, \"idx\", index, 0) ||\n\t\t!sdb_num_set(sdb_vernaux, \"version\", vernaux_entry.vna_other, 0) ||\n\t\t!sdb_set(sdb_vernaux, \"name\", tmp, 0)) {\n\t\tsdb_free(sdb_vernaux);\n\t\treturn NULL;\n\t}\n\n\treturn sdb_vernaux;\n}\n\nstatic Sdb *get_verneed_entry_sdb_aux(ELFOBJ *bin, Elf_(Verneed) verneed_entry, size_t index) {\n\tconst char *tmp = Elf_(rz_bin_elf_strtab_get)(bin->dynstr, verneed_entry.vn_file);\n\tif (!tmp) {\n\t\treturn NULL;\n\t}\n\n\tSdb *sdb_version = sdb_new0();\n\tif (!sdb_version) {\n\t\treturn NULL;\n\t}\n\n\tif (!sdb_num_set(sdb_version, \"cnt\", verneed_entry.vn_cnt, 0) ||\n\t\t!sdb_num_set(sdb_version, \"idx\", index, 0) ||\n\t\t!sdb_num_set(sdb_version, \"vn_version\", verneed_entry.vn_version, 0) ||\n\t\t!sdb_set(sdb_version, \"file_name\", tmp, 0)) {\n\t\tsdb_free(sdb_version);\n\t\treturn NULL;\n\t}\n\n\treturn sdb_version;\n}\n\nstatic Sdb *get_verneed_entry_sdb(ELFOBJ *bin, Elf_(Verneed) verneed_entry, size_t offset) {\n\tSdb *sdb_version = get_verneed_entry_sdb_aux(bin, verneed_entry, offset);\n\tif (!sdb_version) {\n\t\treturn NULL;\n\t}\n\n\tut64 vernaux_entry_offset = offset + verneed_entry.vn_aux;\n\n\tfor (size_t i = 0; i < verneed_entry.vn_cnt; i++) {\n\t\tElf_(Vernaux) vernaux_entry;\n\t\tif (!get_vernaux_entry(bin, vernaux_entry_offset, &vernaux_entry)) {\n\t\t\tsdb_free(sdb_version);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tSdb *sdb_vernaux = get_vernaux_entry_sdb(bin, vernaux_entry, vernaux_entry_offset);\n\t\tif (!sdb_vernaux) {\n\t\t\tsdb_free(sdb_version);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tchar key[32];\n\t\tif (!sdb_ns_set(sdb_version, rz_strf(key, \"vernaux%zu\", i), sdb_vernaux)) {\n\t\t\tsdb_free(sdb_vernaux);\n\t\t\tsdb_free(sdb_version);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tsdb_free(sdb_vernaux);\n\n\t\tvernaux_entry_offset += vernaux_entry.vna_next;\n\t}\n\n\treturn sdb_version;\n}\n\nstatic Sdb *get_gnu_verneed(ELFOBJ *bin) {\n\tut64 verneed_addr;\n\tut64 verneed_num;\n\n\tif (!Elf_(rz_bin_elf_get_dt_info)(bin, DT_VERNEED, &verneed_addr) || !Elf_(rz_bin_elf_get_dt_info)(bin, DT_VERNEEDNUM, &verneed_num)) {\n\t\treturn NULL;\n\t}\n\n\tut64 verneed_offset = Elf_(rz_bin_elf_v2p(bin, verneed_addr));\n\tif (verneed_offset == UT64_MAX) {\n\t\tRZ_LOG_WARN(\"Failed to convert verneed virtual address to physical address.\\n\");\n\t\treturn NULL;\n\t}\n\n\tSdb *sdb = sdb_new0();\n\tif (!sdb) {\n\t\treturn NULL;\n\t}\n\n\tif (!sdb_num_set(sdb, \"num_entries\", verneed_num, 0) ||\n\t\t!sdb_num_set(sdb, \"addr\", verneed_addr, 0) ||\n\t\t!sdb_num_set(sdb, \"offset\", verneed_offset, 0)) {\n\t\tsdb_free(sdb);\n\t\treturn NULL;\n\t}\n\n\tfor (size_t i = 0; i < verneed_num; i++) {\n\t\tElf_(Verneed) verneed_entry;\n\t\tif (!get_verneed_entry(bin, verneed_offset, &verneed_entry)) {\n\t\t\tsdb_free(sdb);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tSdb *sdb_version = get_verneed_entry_sdb(bin, verneed_entry, verneed_offset);\n\t\tif (!sdb_version) {\n\t\t\tsdb_free(sdb);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tchar key[32];\n\t\tif (!sdb_ns_set(sdb, rz_strf(key, \"version%zu\", i), sdb_version)) {\n\t\t\tsdb_free(sdb_version);\n\t\t\tsdb_free(sdb);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tsdb_free(sdb_version);\n\n\t\tif (!verneed_entry.vn_next) {\n\t\t\tbreak;\n\t\t}\n\n\t\tverneed_offset += verneed_entry.vn_next;\n\t}\n\n\treturn sdb;\n}\n\nRZ_IPI RZ_OWN Sdb *Elf_(rz_bin_elf_get_symbols_info)(RZ_NONNULL ELFOBJ *bin) {\n\trz_return_val_if_fail(bin, false);\n\n\tif (!Elf_(rz_bin_elf_is_executable)(bin)) {\n\t\treturn NULL;\n\t}\n\n\tSdb *res = sdb_new0();\n\tif (!res) {\n\t\treturn NULL;\n\t}\n\n\tSdb *sdb = get_gnu_verneed(bin);\n\tif (sdb && !sdb_ns_set(res, \"verneed\", sdb)) {\n\t\tsdb_free(res);\n\t\tsdb_free(sdb);\n\t\treturn NULL;\n\t}\n\tsdb_free(sdb);\n\n\tsdb = get_gnu_versym(bin);\n\tif (sdb && !sdb_ns_set(res, \"versym\", sdb)) {\n\t\tsdb_free(res);\n\t\tsdb_free(sdb);\n\t\treturn NULL;\n\t}\n\tsdb_free(sdb);\n\n\treturn res;\n}\n\n/**\n * \\brief Get the compiler info from the .comment section\n * \\param elf binary\n * \\return a ptr to an allocated string\n *\n * ...\n */\nRZ_OWN char *Elf_(rz_bin_elf_get_compiler)(RZ_NONNULL ELFOBJ *bin) {\n\trz_return_val_if_fail(bin, NULL);\n\n\tRzBinElfSection *section = Elf_(rz_bin_elf_get_section_with_name)(bin, \".comment\");\n\tif (!section) {\n\t\treturn NULL;\n\t}\n\n\tut64 offset = section->offset;\n\tut64 size = RZ_MIN(section->size, 128);\n\tif (size < 1) {\n\t\treturn NULL;\n\t}\n\n\tchar *result = malloc(size + 1);\n\tif (!result) {\n\t\treturn NULL;\n\t}\n\n\tif (rz_buf_read_at(bin->b, offset, (ut8 *)result, size) < 1) {\n\t\tfree(result);\n\t\treturn NULL;\n\t}\n\tresult[size] = 0;\n\n\tsize_t result_len = strlen(result);\n\tchar *end = result + result_len;\n\n\tif (result_len != size && end[1]) {\n\t\tend[0] = ' ';\n\t}\n\n\trz_str_trim(result);\n\tchar *res = rz_str_escape(result);\n\n\tfree(result);\n\treturn res;\n}\n\n/**\n * \\brief Return a string representing the application binary interface\n * \\param elf type\n * \\return allocated string\n *\n * Only work on mips right now. Use the elf header to deduce the application\n * binary interface\n */\nRZ_OWN char *Elf_(rz_bin_elf_get_abi)(RZ_NONNULL ELFOBJ *bin) {\n\trz_return_val_if_fail(bin, NULL);\n\n\tif (bin->ehdr.e_machine == EM_MIPS) {\n\t\treturn get_abi_mips(bin);\n\t}\n\n\treturn NULL;\n}\n\n/**\n * \\brief Get the elf binary architecture\n * \\param elf binary\n * \\return an allocated string\n *\n * With the elf header (e_machine) deduce the elf architecture\n */\nRZ_OWN char *Elf_(rz_bin_elf_get_arch)(RZ_NONNULL ELFOBJ *bin) {\n\trz_return_val_if_fail(bin, NULL);\n\n\tfor (size_t i = 0; i < RZ_ARRAY_SIZE(arch_translation_table); i++) {\n\t\tif (bin->ehdr.e_machine == arch_translation_table[i].arch) {\n\t\t\treturn strdup(arch_translation_table[i].name);\n\t\t}\n\t}\n\n\treturn strdup(\"\");\n}\n\n/**\n * \\brief Return a string representing the cpu\n * \\param elf type\n * \\return allocated string\n *\n * Only work on mips right now. Use the elf header to deduce the cpu\n */\nRZ_OWN char *Elf_(rz_bin_elf_get_cpu)(RZ_NONNULL ELFOBJ *bin) {\n\trz_return_val_if_fail(bin, NULL);\n\n\tif (!Elf_(rz_bin_elf_has_segments)(bin)) {\n\t\treturn NULL;\n\t}\n\n\tif (bin->ehdr.e_machine == EM_MIPS) {\n\t\treturn get_cpu_mips(bin);\n\t}\n\n\treturn NULL;\n}\n\n/**\n * \\brief Return a string representing the elf class\n * \\param elf binary\n * \\return allocated string\n *\n * Check the elf header (e_ident) to deduce the elf class\n */\nRZ_OWN char *Elf_(rz_bin_elf_get_elf_class)(RZ_NONNULL ELFOBJ *bin) {\n\trz_return_val_if_fail(bin, NULL);\n\n\tfor (size_t i = 0; i < RZ_ARRAY_SIZE(class_translation_table); i++) {\n\t\tif (bin->ehdr.e_ident[EI_CLASS] == class_translation_table[i].class) {\n\t\t\treturn strdup(class_translation_table[i].name);\n\t\t}\n\t}\n\n\treturn rz_str_newf(\"<unknown: %x>\", bin->ehdr.e_ident[EI_CLASS]);\n}\n\n/**\n * \\brief Return a string representing the file type\n * \\param elf binary\n * \\return allocated string\n *\n * Use the elf header (e_type) to deduce the file type\n */\nRZ_OWN char *Elf_(rz_bin_elf_get_file_type)(RZ_NONNULL ELFOBJ *bin) {\n\trz_return_val_if_fail(bin, NULL);\n\n\tchar *result = get_file_type_basic(bin);\n\tif (result) {\n\t\treturn result;\n\t}\n\n\tif (file_type_is_processor_specific(bin)) {\n\t\treturn rz_str_newf(\"Processor Specific: %x\", bin->ehdr.e_type);\n\t}\n\n\tif (file_type_is_os_specific(bin)) {\n\t\treturn rz_str_newf(\"OS Specific: %x\", bin->ehdr.e_type);\n\t}\n\n\treturn rz_str_newf(\"<unknown>: %x\", bin->ehdr.e_type);\n}\n\n/**\n * \\brief Return the head flag\n * \\return allocated string\n *\n * ...\n */\nRZ_OWN char *Elf_(rz_bin_elf_get_head_flag)(RZ_NONNULL ELFOBJ *bin) {\n\trz_return_val_if_fail(bin, NULL);\n\n\tchar *head_flag = get_head_flag(bin);\n\n\tif (RZ_STR_ISEMPTY(head_flag)) {\n\t\tfree(head_flag);\n\t\treturn strdup(\"unknown_flag\");\n\t}\n\n\treturn head_flag;\n}\n\n/**\n * \\brief Return a string representing the machine name\n * \\param elf type\n * \\return allocated string\n *\n * Use http://www.sco.com/developers/gabi/latest/ch4.eheader.html and the elf\n * header (e_machine)\n */\nRZ_OWN char *Elf_(rz_bin_elf_get_machine_name)(RZ_NONNULL ELFOBJ *bin) {\n\trz_return_val_if_fail(bin, NULL);\n\n\tfor (size_t i = 0; i < RZ_ARRAY_SIZE(machine_name_translation_table); i++) {\n\t\tif (bin->ehdr.e_machine == machine_name_translation_table[i].machine) {\n\t\t\treturn strdup(machine_name_translation_table[i].name);\n\t\t}\n\t}\n\n\treturn rz_str_newf(\"<unknown>: 0x%x\", bin->ehdr.e_machine);\n}\n\n/**\n * \\brief Return the os application binary interface name\n * \\param elf binary\n * \\return an allocated string\n *\n * Check the ehdr or the shdr to get the os name\n */\nRZ_OWN char *Elf_(rz_bin_elf_get_osabi_name)(RZ_NONNULL ELFOBJ *bin) {\n\trz_return_val_if_fail(bin, NULL);\n\n\tchar *name = get_osabi_name_from_ehdr(bin);\n\tif (name) {\n\t\treturn name;\n\t}\n\n\tname = get_osabi_name_from_shdr(bin);\n\tif (name) {\n\t\treturn name;\n\t}\n\n\treturn strdup(\"linux\");\n}\n\n/**\n * \\brief Get the rpath\n * \\param elf binary\n * \\return allocated string\n *\n * Use DT_RPATH or DT_RUNPATH to return the string\n */\nRZ_OWN char *Elf_(rz_bin_elf_get_rpath)(RZ_NONNULL ELFOBJ *bin) {\n\trz_return_val_if_fail(bin, NULL);\n\n\tif (!Elf_(rz_bin_elf_has_segments)(bin) || !bin->dynstr || !has_dt_rpath_entry(bin)) {\n\t\treturn NULL;\n\t}\n\n\tElf_(Xword) val = get_dt_rpath(bin);\n\treturn Elf_(rz_bin_elf_strtab_get_dup)(bin->dynstr, val);\n}\n\n/**\n * \\brief Get the program interpreter\n * \\param elf binary\n * \\return an allocated string\n *\n * Get the program interpreter from the phdr\n */\nRZ_OWN char *Elf_(rz_bin_elf_get_intrp)(RZ_NONNULL ELFOBJ *bin) {\n\trz_return_val_if_fail(bin, NULL);\n\n\tif (!Elf_(rz_bin_elf_has_segments)(bin)) {\n\t\treturn NULL;\n\t}\n\n\tRzBinElfSegment *segment = Elf_(rz_bin_elf_get_segment_with_type)(bin, PT_INTERP);\n\tif (!segment || !segment->is_valid) {\n\t\treturn NULL;\n\t}\n\n\treturn get_elf_intrp(bin, segment);\n}\n\n/**\n * \\brief Check if the binary is stripped\n * \\param elf binary\n * \\param is_stripped ?\n * \\return a ptr to a new allocated RzBinSymbol\n *\n * Use the shdr to check if the binary is stripped\n */\nbool Elf_(rz_bin_elf_is_stripped)(RZ_NONNULL ELFOBJ *bin) {\n\trz_return_val_if_fail(bin, false);\n\n\tif (!Elf_(rz_bin_elf_has_sections)(bin)) {\n\t\treturn false;\n\t}\n\n\tRzBinElfSection *section;\n\trz_bin_elf_foreach_sections(bin, section) {\n\t\tif (section->type == SHT_SYMTAB) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/**\n * \\brief Check if the stack is not executable\n * \\param elf binary\n * \\return true, false\n *\n * Check p_flags from the segment PT_GNU_STACK\n */\nbool Elf_(rz_bin_elf_has_nx)(RZ_NONNULL ELFOBJ *bin) {\n\trz_return_val_if_fail(bin, false);\n\n\tif (!Elf_(rz_bin_elf_has_segments)(bin)) {\n\t\treturn false;\n\t}\n\n\tRzBinElfSegment *segment = Elf_(rz_bin_elf_get_segment_with_type)(bin, PT_GNU_STACK);\n\tif (!segment || !segment->is_valid) {\n\t\treturn false;\n\t}\n\n\treturn !(segment->data.p_flags & PF_X);\n}\n\n/**\n * \\brief Check if the elf use virtual address\n * \\param elf binary\n * \\return always true\n *\n * Return always true\n */\nbool Elf_(rz_bin_elf_has_va)(ELFOBJ *bin) {\n\treturn true;\n}\n\n/**\n * \\brief Check if the elf binary is executable\n * \\param elf binary\n * \\return is_executable ?\n *\n * Use the elf header entry e_type to deduct if the elf is executable.\n */\nbool Elf_(rz_bin_elf_is_executable)(RZ_NONNULL ELFOBJ *bin) {\n\trz_return_val_if_fail(bin, false);\n\n\tconst Elf_(Half) type = bin->ehdr.e_type;\n\treturn type == ET_EXEC || type == ET_DYN;\n}\n\n/**\n * \\brief Check if the elf binary is relocatable\n * \\param elf binary\n * \\return is_relocatable ?\n *\n * Use the elf header entry e_type to deduct if the elf is relocatable.\n */\nbool Elf_(rz_bin_elf_is_relocatable)(RZ_NONNULL ELFOBJ *bin) {\n\trz_return_val_if_fail(bin, false);\n\treturn bin->ehdr.e_type == ET_REL;\n}\n\n/**\n * \\brief Check if the binary is statically-linked library\n * \\param elf binary\n * \\return is_static ?\n *\n * Check the presence of PT_INTERP or PT_DYNAMIC in the program header\n */\nbool Elf_(rz_bin_elf_is_static)(RZ_NONNULL ELFOBJ *bin) {\n\trz_return_val_if_fail(bin, false);\n\n\tRzBinElfSegment *segment = Elf_(rz_bin_elf_get_segment_with_type)(bin, PT_INTERP);\n\tif (segment && segment->is_valid) {\n\t\treturn false;\n\t}\n\n\tsegment = Elf_(rz_bin_elf_get_segment_with_type)(bin, PT_DYNAMIC);\n\tif (segment && segment->is_valid) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n/**\n * \\brief Return the elf bits\n * \\param elf binary\n * \\return the number of bits\n *\n * ...\n */\nint Elf_(rz_bin_elf_get_bits)(RZ_NONNULL ELFOBJ *bin) {\n\trz_return_val_if_fail(bin, 0);\n\n\t/* Hack for ARCompact */\n\tif (arch_is_arcompact(bin)) {\n\t\treturn 16;\n\t}\n\n\t/* Hack for Ps2 */\n\tif (arch_is_mips(bin)) {\n\t\treturn get_bits_mips(bin);\n\t}\n\n\t/* Hack for Thumb */\n\tif (Elf_(rz_bin_elf_is_arm_binary_supporting_thumb)(bin)) {\n\t\tif (!Elf_(rz_bin_elf_is_static)(bin) && has_thumb_symbol(bin)) {\n\t\t\treturn 16;\n\t\t}\n\n\t\tut64 entry = Elf_(rz_bin_elf_get_entry_offset)(bin);\n\t\tif (Elf_(rz_bin_elf_is_thumb_addr)(entry)) {\n\t\t\treturn 16;\n\t\t}\n\t}\n\n\treturn get_bits_common(bin);\n}\n\n/**\n * \\brief Analyse if the elf binary has relro or partial relro\n * \\param elf binary\n * \\return RZ_BIN_ELF_NO_RELRO, RZ_BIN_ELF_PART_RELRO or RZ_BIN_ELF_FULL_RELRO\n *\n * Check if the elf has bind now enable and with PT_GNU_RELRO can deduct the\n * relro type\n */\nint Elf_(rz_bin_elf_has_relro)(RZ_NONNULL ELFOBJ *bin) {\n\trz_return_val_if_fail(bin, RZ_BIN_ELF_NO_RELRO);\n\n\tbool is_bind_now = elf_is_bind_now(bin);\n\tbool has_gnu_relro = elf_has_gnu_relro(bin);\n\n\tif (has_gnu_relro) {\n\t\tif (is_bind_now) {\n\t\t\treturn RZ_BIN_ELF_FULL_RELRO;\n\t\t}\n\n\t\treturn RZ_BIN_ELF_PART_RELRO;\n\t}\n\n\treturn RZ_BIN_ELF_NO_RELRO;\n}\n\n/**\n * \\brief Check the binary endianness\n * \\param elf type\n * \\return is_big_endian ?\n *\n * Use the elf header (e_ident[EI_DATA]) to check the binary endianness\n */\nbool Elf_(rz_bin_elf_is_big_endian)(RZ_NONNULL ELFOBJ *bin) {\n\trz_return_val_if_fail(bin, false);\n\n\treturn bin->ehdr.e_ident[EI_DATA] == ELFDATA2MSB;\n}\n\n/**\n * \\brief Compute the base address of the binary\n * \\param elf binary\n * \\return the base address\n *\n * To compute the base address, one determines the memory\n * address associated with the lowest p_vaddr value for a\n * PT_LOAD segment.\n */\nut64 Elf_(rz_bin_elf_get_baddr)(RZ_NONNULL ELFOBJ *bin) {\n\trz_return_val_if_fail(bin, 0);\n\n\tif (Elf_(rz_bin_elf_is_relocatable)(bin)) {\n\t\treturn 0x08000000;\n\t}\n\n\tif (Elf_(rz_bin_elf_has_segments)(bin)) {\n\t\treturn compute_baddr_from_phdr(bin);\n\t}\n\n\treturn 0;\n}\n\n/**\n * \\brief Compute the base offset of the binary\n * \\param elf binary\n * \\return the base offset\n *\n * To compute the base address, one determines the memory\n * address associated with the lowest p_offset value for a\n * PT_LOAD segment.\n */\nut64 Elf_(rz_bin_elf_get_boffset)(RZ_NONNULL ELFOBJ *bin) {\n\trz_return_val_if_fail(bin, 0);\n\n\tif (Elf_(rz_bin_elf_has_segments)(bin)) {\n\t\treturn compute_boffset_from_phdr(bin);\n\t}\n\n\treturn 0;\n}\n\n/**\n * \\brief Get the entry offset\n * \\param elf binary\n * \\return the entry offset\n *\n * Get the entry offset from the elf header (e_entry), and if the information\n * isn't defined section header will be used.\n */\nut64 Elf_(rz_bin_elf_get_entry_offset)(RZ_NONNULL ELFOBJ *bin) {\n\trz_return_val_if_fail(bin, UT64_MAX);\n\n\tif (!Elf_(rz_bin_elf_is_executable)(bin)) {\n\t\treturn UT64_MAX;\n\t}\n\n\tut64 entry = bin->ehdr.e_entry;\n\tif (entry) {\n\t\tut64 tmp = Elf_(rz_bin_elf_v2p)(bin, entry);\n\t\tif (tmp == UT64_MAX) {\n\t\t\treturn entry;\n\t\t}\n\n\t\treturn tmp;\n\t}\n\n\treturn get_entry_offset_from_shdr(bin);\n}\n\n/**\n * \\brief Compute the fini offset of the binary\n * \\param elf binary\n * \\return the init offset\n *\n * Get the offset from the vaddr store in the dynamic section (dt_fini)\n */\nut64 Elf_(rz_bin_elf_get_fini_offset)(RZ_NONNULL ELFOBJ *bin) {\n\trz_return_val_if_fail(bin, 0);\n\n\tut64 addr;\n\n\tif (!Elf_(rz_bin_elf_has_dt_dynamic)(bin)) {\n\t\treturn 0;\n\t}\n\n\tif (!Elf_(rz_bin_elf_get_dt_info)(bin, DT_FINI, &addr)) {\n\t\treturn 0;\n\t}\n\n\treturn Elf_(rz_bin_elf_v2p)(bin, addr);\n}\n\n/**\n * \\brief Compute the init offset of the binary\n * \\param elf binary\n * \\return the init offset\n *\n * Get the offset from the vaddr store in the dynamic section (dt_init)\n */\nut64 Elf_(rz_bin_elf_get_init_offset)(RZ_NONNULL ELFOBJ *bin) {\n\trz_return_val_if_fail(bin, 0);\n\n\tut64 addr;\n\n\tif (!Elf_(rz_bin_elf_has_dt_dynamic)(bin)) {\n\t\treturn 0;\n\t}\n\n\tif (!Elf_(rz_bin_elf_get_dt_info)(bin, DT_INIT, &addr)) {\n\t\treturn 0;\n\t}\n\n\treturn Elf_(rz_bin_elf_v2p)(bin, addr);\n}\n\n/**\n * \\brief Compute the main offset of the binary\n * \\param elf binary\n * \\return the main offset\n *\n * ...\n */\nut64 Elf_(rz_bin_elf_get_main_offset)(RZ_NONNULL ELFOBJ *bin) {\n\trz_return_val_if_fail(bin, UT64_MAX);\n\n\tut8 buf[256] = { 0 };\n\tut64 entry = Elf_(rz_bin_elf_get_entry_offset)(bin);\n\tut64 main_addr;\n\n\tif (entry == UT64_MAX || entry > bin->size || (entry + sizeof(buf)) > bin->size) {\n\t\treturn UT64_MAX;\n\t}\n\n\tif (rz_buf_read_at(bin->b, entry, buf, sizeof(buf)) < 0) {\n\t\treturn UT64_MAX;\n\t}\n\n\tmain_addr = get_main_offset_arm64(bin, entry, buf);\n\tif (main_addr != UT64_MAX) {\n\t\treturn main_addr;\n\t}\n\n\tmain_addr = get_main_offset_arm_glibc(bin, entry, buf);\n\tif (main_addr != UT64_MAX) {\n\t\treturn main_addr;\n\t}\n\n\tmain_addr = get_main_offset_mips(bin, entry, buf, RZ_ARRAY_SIZE(buf));\n\tif (main_addr != UT64_MAX) {\n\t\treturn main_addr;\n\t}\n\n\tmain_addr = get_main_offset_x86_gcc(bin, entry, buf);\n\tif (main_addr != UT64_MAX) {\n\t\treturn main_addr;\n\t}\n\n\tmain_addr = get_main_offset_x86_pie(bin, entry, buf);\n\tif (main_addr != UT64_MAX) {\n\t\treturn main_addr;\n\t}\n\n\tmain_addr = get_main_offset_x86_non_pie(bin, entry, buf);\n\tif (main_addr != UT64_MAX) {\n\t\treturn main_addr;\n\t}\n\n\tmain_addr = get_main_offset_linux_64_pie(bin, entry, buf);\n\tif (main_addr != UT64_MAX) {\n\t\treturn main_addr;\n\t}\n\n\treturn get_main_offset_from_symbol(bin);\n}\n"], "filenames": ["librz/bin/format/elf/elf_info.c"], "buggy_code_start_loc": [1294], "buggy_code_end_loc": [1294], "fixing_code_start_loc": [1295], "fixing_code_end_loc": [1299], "type": "CWE-834", "message": "An issue was discovered in function get_gnu_verneed in rizinorg Rizin prior to 0.5.0 verneed_entry allows attackers to cause a denial of service via crafted elf file.", "other": {"cve": {"id": "CVE-2023-30226", "sourceIdentifier": "cve@mitre.org", "published": "2023-07-12T02:15:09.090", "lastModified": "2023-07-18T20:32:10.273", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in function get_gnu_verneed in rizinorg Rizin prior to 0.5.0 verneed_entry allows attackers to cause a denial of service via crafted elf file."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-834"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:rizin:rizin:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.5.0", "matchCriteriaId": "84DE2A31-2C4F-48E9-A715-75C7E5754610"}]}]}], "references": [{"url": "https://github.com/ifyGecko/CVE-2023-30226", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/rizinorg/rizin/commit/a6d89de0d44e776f9bccc3a168fdc79f604e14ed", "source": "cve@mitre.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/rizinorg/rizin/commit/a6d89de0d44e776f9bccc3a168fdc79f604e14ed"}}