{"buggy_code": ["/*\n** $Id: ldo.c $\n** Stack and Call structure of Lua\n** See Copyright Notice in lua.h\n*/\n\n#define ldo_c\n#define LUA_CORE\n\n#include \"lprefix.h\"\n\n\n#include <setjmp.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"lua.h\"\n\n#include \"lapi.h\"\n#include \"ldebug.h\"\n#include \"ldo.h\"\n#include \"lfunc.h\"\n#include \"lgc.h\"\n#include \"lmem.h\"\n#include \"lobject.h\"\n#include \"lopcodes.h\"\n#include \"lparser.h\"\n#include \"lstate.h\"\n#include \"lstring.h\"\n#include \"ltable.h\"\n#include \"ltm.h\"\n#include \"lundump.h\"\n#include \"lvm.h\"\n#include \"lzio.h\"\n\n\n\n#define errorstatus(s)\t((s) > LUA_YIELD)\n\n\n/*\n** {======================================================\n** Error-recovery functions\n** =======================================================\n*/\n\n/*\n** LUAI_THROW/LUAI_TRY define how Lua does exception handling. By\n** default, Lua handles errors with exceptions when compiling as\n** C++ code, with _longjmp/_setjmp when asked to use them, and with\n** longjmp/setjmp otherwise.\n*/\n#if !defined(LUAI_THROW)\t\t\t\t/* { */\n\n#if defined(__cplusplus) && !defined(LUA_USE_LONGJMP)\t/* { */\n\n/* C++ exceptions */\n#define LUAI_THROW(L,c)\t\tthrow(c)\n#define LUAI_TRY(L,c,a) \\\n\ttry { a } catch(...) { if ((c)->status == 0) (c)->status = -1; }\n#define luai_jmpbuf\t\tint  /* dummy variable */\n\n#elif defined(LUA_USE_POSIX)\t\t\t\t/* }{ */\n\n/* in POSIX, try _longjmp/_setjmp (more efficient) */\n#define LUAI_THROW(L,c)\t\t_longjmp((c)->b, 1)\n#define LUAI_TRY(L,c,a)\t\tif (_setjmp((c)->b) == 0) { a }\n#define luai_jmpbuf\t\tjmp_buf\n\n#else\t\t\t\t\t\t\t/* }{ */\n\n/* ISO C handling with long jumps */\n#define LUAI_THROW(L,c)\t\tlongjmp((c)->b, 1)\n#define LUAI_TRY(L,c,a)\t\tif (setjmp((c)->b) == 0) { a }\n#define luai_jmpbuf\t\tjmp_buf\n\n#endif\t\t\t\t\t\t\t/* } */\n\n#endif\t\t\t\t\t\t\t/* } */\n\n\n\n/* chain list of long jump buffers */\nstruct lua_longjmp {\n  struct lua_longjmp *previous;\n  luai_jmpbuf b;\n  volatile int status;  /* error code */\n};\n\n\nvoid luaD_seterrorobj (lua_State *L, int errcode, StkId oldtop) {\n  switch (errcode) {\n    case LUA_ERRMEM: {  /* memory error? */\n      setsvalue2s(L, oldtop, G(L)->memerrmsg); /* reuse preregistered msg. */\n      break;\n    }\n    case LUA_ERRERR: {\n      setsvalue2s(L, oldtop, luaS_newliteral(L, \"error in error handling\"));\n      break;\n    }\n    case LUA_OK: {  /* special case only for closing upvalues */\n      setnilvalue(s2v(oldtop));  /* no error message */\n      break;\n    }\n    default: {\n      lua_assert(errorstatus(errcode));  /* real error */\n      setobjs2s(L, oldtop, L->top - 1);  /* error message on current top */\n      break;\n    }\n  }\n  L->top = oldtop + 1;\n}\n\n\nl_noret luaD_throw (lua_State *L, int errcode) {\n  if (L->errorJmp) {  /* thread has an error handler? */\n    L->errorJmp->status = errcode;  /* set status */\n    LUAI_THROW(L, L->errorJmp);  /* jump to it */\n  }\n  else {  /* thread has no error handler */\n    global_State *g = G(L);\n    errcode = luaE_resetthread(L, errcode);  /* close all upvalues */\n    if (g->mainthread->errorJmp) {  /* main thread has a handler? */\n      setobjs2s(L, g->mainthread->top++, L->top - 1);  /* copy error obj. */\n      luaD_throw(g->mainthread, errcode);  /* re-throw in main thread */\n    }\n    else {  /* no handler at all; abort */\n      if (g->panic) {  /* panic function? */\n        lua_unlock(L);\n        g->panic(L);  /* call panic function (last chance to jump out) */\n      }\n      abort();\n    }\n  }\n}\n\n\nint luaD_rawrunprotected (lua_State *L, Pfunc f, void *ud) {\n  l_uint32 oldnCcalls = L->nCcalls;\n  struct lua_longjmp lj;\n  lj.status = LUA_OK;\n  lj.previous = L->errorJmp;  /* chain new error handler */\n  L->errorJmp = &lj;\n  LUAI_TRY(L, &lj,\n    (*f)(L, ud);\n  );\n  L->errorJmp = lj.previous;  /* restore old error handler */\n  L->nCcalls = oldnCcalls;\n  return lj.status;\n}\n\n/* }====================================================== */\n\n\n/*\n** {==================================================================\n** Stack reallocation\n** ===================================================================\n*/\nstatic void correctstack (lua_State *L, StkId oldstack, StkId newstack) {\n  CallInfo *ci;\n  UpVal *up;\n  L->top = (L->top - oldstack) + newstack;\n  L->tbclist = (L->tbclist - oldstack) + newstack;\n  for (up = L->openupval; up != NULL; up = up->u.open.next)\n    up->v = s2v((uplevel(up) - oldstack) + newstack);\n  for (ci = L->ci; ci != NULL; ci = ci->previous) {\n    ci->top = (ci->top - oldstack) + newstack;\n    ci->func = (ci->func - oldstack) + newstack;\n    if (isLua(ci))\n      ci->u.l.trap = 1;  /* signal to update 'trap' in 'luaV_execute' */\n  }\n}\n\n\n/* some space for error handling */\n#define ERRORSTACKSIZE\t(LUAI_MAXSTACK + 200)\n\n\n/*\n** Reallocate the stack to a new size, correcting all pointers into\n** it. (There are pointers to a stack from its upvalues, from its list\n** of call infos, plus a few individual pointers.) The reallocation is\n** done in two steps (allocation + free) because the correction must be\n** done while both addresses (the old stack and the new one) are valid.\n** (In ISO C, any pointer use after the pointer has been deallocated is\n** undefined behavior.)\n** In case of allocation error, raise an error or return false according\n** to 'raiseerror'.\n*/\nint luaD_reallocstack (lua_State *L, int newsize, int raiseerror) {\n  int oldsize = stacksize(L);\n  int i;\n  StkId newstack = luaM_reallocvector(L, NULL, 0,\n                                      newsize + EXTRA_STACK, StackValue);\n  lua_assert(newsize <= LUAI_MAXSTACK || newsize == ERRORSTACKSIZE);\n  if (l_unlikely(newstack == NULL)) {  /* reallocation failed? */\n    if (raiseerror)\n      luaM_error(L);\n    else return 0;  /* do not raise an error */\n  }\n  /* number of elements to be copied to the new stack */\n  i = ((oldsize <= newsize) ? oldsize : newsize) + EXTRA_STACK;\n  memcpy(newstack, L->stack, i * sizeof(StackValue));\n  for (; i < newsize + EXTRA_STACK; i++)\n    setnilvalue(s2v(newstack + i)); /* erase new segment */\n  correctstack(L, L->stack, newstack);\n  luaM_freearray(L, L->stack, oldsize + EXTRA_STACK);\n  L->stack = newstack;\n  L->stack_last = L->stack + newsize;\n  return 1;\n}\n\n\n/*\n** Try to grow the stack by at least 'n' elements. when 'raiseerror'\n** is true, raises any error; otherwise, return 0 in case of errors.\n*/\nint luaD_growstack (lua_State *L, int n, int raiseerror) {\n  int size = stacksize(L);\n  if (l_unlikely(size > LUAI_MAXSTACK)) {\n    /* if stack is larger than maximum, thread is already using the\n       extra space reserved for errors, that is, thread is handling\n       a stack error; cannot grow further than that. */\n    lua_assert(stacksize(L) == ERRORSTACKSIZE);\n    if (raiseerror)\n      luaD_throw(L, LUA_ERRERR);  /* error inside message handler */\n    return 0;  /* if not 'raiseerror', just signal it */\n  }\n  else {\n    int newsize = 2 * size;  /* tentative new size */\n    int needed = cast_int(L->top - L->stack) + n;\n    if (newsize > LUAI_MAXSTACK)  /* cannot cross the limit */\n      newsize = LUAI_MAXSTACK;\n    if (newsize < needed)  /* but must respect what was asked for */\n      newsize = needed;\n    if (l_likely(newsize <= LUAI_MAXSTACK))\n      return luaD_reallocstack(L, newsize, raiseerror);\n    else {  /* stack overflow */\n      /* add extra size to be able to handle the error message */\n      luaD_reallocstack(L, ERRORSTACKSIZE, raiseerror);\n      if (raiseerror)\n        luaG_runerror(L, \"stack overflow\");\n      return 0;\n    }\n  }\n}\n\n\nstatic int stackinuse (lua_State *L) {\n  CallInfo *ci;\n  int res;\n  StkId lim = L->top;\n  for (ci = L->ci; ci != NULL; ci = ci->previous) {\n    if (lim < ci->top) lim = ci->top;\n  }\n  lua_assert(lim <= L->stack_last);\n  res = cast_int(lim - L->stack) + 1;  /* part of stack in use */\n  if (res < LUA_MINSTACK)\n    res = LUA_MINSTACK;  /* ensure a minimum size */\n  return res;\n}\n\n\n/*\n** If stack size is more than 3 times the current use, reduce that size\n** to twice the current use. (So, the final stack size is at most 2/3 the\n** previous size, and half of its entries are empty.)\n** As a particular case, if stack was handling a stack overflow and now\n** it is not, 'max' (limited by LUAI_MAXSTACK) will be smaller than\n** stacksize (equal to ERRORSTACKSIZE in this case), and so the stack\n** will be reduced to a \"regular\" size.\n*/\nvoid luaD_shrinkstack (lua_State *L) {\n  int inuse = stackinuse(L);\n  int nsize = inuse * 2;  /* proposed new size */\n  int max = inuse * 3;  /* maximum \"reasonable\" size */\n  if (max > LUAI_MAXSTACK) {\n    max = LUAI_MAXSTACK;  /* respect stack limit */\n    if (nsize > LUAI_MAXSTACK)\n      nsize = LUAI_MAXSTACK;\n  }\n  /* if thread is currently not handling a stack overflow and its\n     size is larger than maximum \"reasonable\" size, shrink it */\n  if (inuse <= LUAI_MAXSTACK && stacksize(L) > max)\n    luaD_reallocstack(L, nsize, 0);  /* ok if that fails */\n  else  /* don't change stack */\n    condmovestack(L,{},{});  /* (change only for debugging) */\n  luaE_shrinkCI(L);  /* shrink CI list */\n}\n\n\nvoid luaD_inctop (lua_State *L) {\n  luaD_checkstack(L, 1);\n  L->top++;\n}\n\n/* }================================================================== */\n\n\n/*\n** Call a hook for the given event. Make sure there is a hook to be\n** called. (Both 'L->hook' and 'L->hookmask', which trigger this\n** function, can be changed asynchronously by signals.)\n*/\nvoid luaD_hook (lua_State *L, int event, int line,\n                              int ftransfer, int ntransfer) {\n  lua_Hook hook = L->hook;\n  if (hook && L->allowhook) {  /* make sure there is a hook */\n    int mask = CIST_HOOKED;\n    CallInfo *ci = L->ci;\n    ptrdiff_t top = savestack(L, L->top);  /* preserve original 'top' */\n    ptrdiff_t ci_top = savestack(L, ci->top);  /* idem for 'ci->top' */\n    lua_Debug ar;\n    ar.event = event;\n    ar.currentline = line;\n    ar.i_ci = ci;\n    if (ntransfer != 0) {\n      mask |= CIST_TRAN;  /* 'ci' has transfer information */\n      ci->u2.transferinfo.ftransfer = ftransfer;\n      ci->u2.transferinfo.ntransfer = ntransfer;\n    }\n    if (isLua(ci) && L->top < ci->top)\n      L->top = ci->top;  /* protect entire activation register */\n    luaD_checkstack(L, LUA_MINSTACK);  /* ensure minimum stack size */\n    if (ci->top < L->top + LUA_MINSTACK)\n      ci->top = L->top + LUA_MINSTACK;\n    L->allowhook = 0;  /* cannot call hooks inside a hook */\n    ci->callstatus |= mask;\n    lua_unlock(L);\n    (*hook)(L, &ar);\n    lua_lock(L);\n    lua_assert(!L->allowhook);\n    L->allowhook = 1;\n    ci->top = restorestack(L, ci_top);\n    L->top = restorestack(L, top);\n    ci->callstatus &= ~mask;\n  }\n}\n\n\n/*\n** Executes a call hook for Lua functions. This function is called\n** whenever 'hookmask' is not zero, so it checks whether call hooks are\n** active.\n*/\nvoid luaD_hookcall (lua_State *L, CallInfo *ci) {\n  L->oldpc = 0;  /* set 'oldpc' for new function */\n  if (L->hookmask & LUA_MASKCALL) {  /* is call hook on? */\n    int event = (ci->callstatus & CIST_TAIL) ? LUA_HOOKTAILCALL\n                                             : LUA_HOOKCALL;\n    Proto *p = ci_func(ci)->p;\n    ci->u.l.savedpc++;  /* hooks assume 'pc' is already incremented */\n    luaD_hook(L, event, -1, 1, p->numparams);\n    ci->u.l.savedpc--;  /* correct 'pc' */\n  }\n}\n\n\n/*\n** Executes a return hook for Lua and C functions and sets/corrects\n** 'oldpc'. (Note that this correction is needed by the line hook, so it\n** is done even when return hooks are off.)\n*/\nstatic void rethook (lua_State *L, CallInfo *ci, int nres) {\n  if (L->hookmask & LUA_MASKRET) {  /* is return hook on? */\n    StkId firstres = L->top - nres;  /* index of first result */\n    int delta = 0;  /* correction for vararg functions */\n    int ftransfer;\n    if (isLua(ci)) {\n      Proto *p = ci_func(ci)->p;\n      if (p->is_vararg)\n        delta = ci->u.l.nextraargs + p->numparams + 1;\n    }\n    ci->func += delta;  /* if vararg, back to virtual 'func' */\n    ftransfer = cast(unsigned short, firstres - ci->func);\n    luaD_hook(L, LUA_HOOKRET, -1, ftransfer, nres);  /* call it */\n    ci->func -= delta;\n  }\n  if (isLua(ci = ci->previous))\n    L->oldpc = pcRel(ci->u.l.savedpc, ci_func(ci)->p);  /* set 'oldpc' */\n}\n\n\n/*\n** Check whether 'func' has a '__call' metafield. If so, put it in the\n** stack, below original 'func', so that 'luaD_precall' can call it. Raise\n** an error if there is no '__call' metafield.\n*/\nStkId luaD_tryfuncTM (lua_State *L, StkId func) {\n  const TValue *tm;\n  StkId p;\n  checkstackGCp(L, 1, func);  /* space for metamethod */\n  tm = luaT_gettmbyobj(L, s2v(func), TM_CALL);  /* (after previous GC) */\n  if (l_unlikely(ttisnil(tm)))\n    luaG_callerror(L, s2v(func));  /* nothing to call */\n  for (p = L->top; p > func; p--)  /* open space for metamethod */\n    setobjs2s(L, p, p-1);\n  L->top++;  /* stack space pre-allocated by the caller */\n  setobj2s(L, func, tm);  /* metamethod is the new function to be called */\n  return func;\n}\n\n\n/*\n** Given 'nres' results at 'firstResult', move 'wanted' of them to 'res'.\n** Handle most typical cases (zero results for commands, one result for\n** expressions, multiple results for tail calls/single parameters)\n** separated.\n*/\nl_sinline void moveresults (lua_State *L, StkId res, int nres, int wanted) {\n  StkId firstresult;\n  int i;\n  switch (wanted) {  /* handle typical cases separately */\n    case 0:  /* no values needed */\n      L->top = res;\n      return;\n    case 1:  /* one value needed */\n      if (nres == 0)   /* no results? */\n        setnilvalue(s2v(res));  /* adjust with nil */\n      else  /* at least one result */\n        setobjs2s(L, res, L->top - nres);  /* move it to proper place */\n      L->top = res + 1;\n      return;\n    case LUA_MULTRET:\n      wanted = nres;  /* we want all results */\n      break;\n    default:  /* two/more results and/or to-be-closed variables */\n      if (hastocloseCfunc(wanted)) {  /* to-be-closed variables? */\n        ptrdiff_t savedres = savestack(L, res);\n        L->ci->callstatus |= CIST_CLSRET;  /* in case of yields */\n        L->ci->u2.nres = nres;\n        luaF_close(L, res, CLOSEKTOP, 1);\n        L->ci->callstatus &= ~CIST_CLSRET;\n        if (L->hookmask)  /* if needed, call hook after '__close's */\n          rethook(L, L->ci, nres);\n        res = restorestack(L, savedres);  /* close and hook can move stack */\n        wanted = decodeNresults(wanted);\n        if (wanted == LUA_MULTRET)\n          wanted = nres;  /* we want all results */\n      }\n      break;\n  }\n  /* generic case */\n  firstresult = L->top - nres;  /* index of first result */\n  if (nres > wanted)  /* extra results? */\n    nres = wanted;  /* don't need them */\n  for (i = 0; i < nres; i++)  /* move all results to correct place */\n    setobjs2s(L, res + i, firstresult + i);\n  for (; i < wanted; i++)  /* complete wanted number of results */\n    setnilvalue(s2v(res + i));\n  L->top = res + wanted;  /* top points after the last result */\n}\n\n\n/*\n** Finishes a function call: calls hook if necessary, moves current\n** number of results to proper place, and returns to previous call\n** info. If function has to close variables, hook must be called after\n** that.\n*/\nvoid luaD_poscall (lua_State *L, CallInfo *ci, int nres) {\n  int wanted = ci->nresults;\n  if (l_unlikely(L->hookmask && !hastocloseCfunc(wanted)))\n    rethook(L, ci, nres);\n  /* move results to proper place */\n  moveresults(L, ci->func, nres, wanted);\n  /* function cannot be in any of these cases when returning */\n  lua_assert(!(ci->callstatus &\n        (CIST_HOOKED | CIST_YPCALL | CIST_FIN | CIST_TRAN | CIST_CLSRET)));\n  L->ci = ci->previous;  /* back to caller (after closing variables) */\n}\n\n\n\n#define next_ci(L)  (L->ci->next ? L->ci->next : luaE_extendCI(L))\n\n\nl_sinline CallInfo *prepCallInfo (lua_State *L, StkId func, int nret,\n                                                int mask, StkId top) {\n  CallInfo *ci = L->ci = next_ci(L);  /* new frame */\n  ci->func = func;\n  ci->nresults = nret;\n  ci->callstatus = mask;\n  ci->top = top;\n  return ci;\n}\n\n\n/*\n** precall for C functions\n*/\nl_sinline int precallC (lua_State *L, StkId func, int nresults,\n                                            lua_CFunction f) {\n  int n;  /* number of returns */\n  CallInfo *ci;\n  checkstackGCp(L, LUA_MINSTACK, func);  /* ensure minimum stack size */\n  L->ci = ci = prepCallInfo(L, func, nresults, CIST_C,\n                               L->top + LUA_MINSTACK);\n  lua_assert(ci->top <= L->stack_last);\n  if (l_unlikely(L->hookmask & LUA_MASKCALL)) {\n    int narg = cast_int(L->top - func) - 1;\n    luaD_hook(L, LUA_HOOKCALL, -1, 1, narg);\n  }\n  lua_unlock(L);\n  n = (*f)(L);  /* do the actual call */\n  lua_lock(L);\n  api_checknelems(L, n);\n  luaD_poscall(L, ci, n);\n  return n;\n}\n\n\n/*\n** Prepare a function for a tail call, building its call info on top\n** of the current call info. 'narg1' is the number of arguments plus 1\n** (so that it includes the function itself). Return the number of\n** results, if it was a C function, or -1 for a Lua function.\n*/\nint luaD_pretailcall (lua_State *L, CallInfo *ci, StkId func,\n                                    int narg1, int delta) {\n retry:\n  switch (ttypetag(s2v(func))) {\n    case LUA_VCCL:  /* C closure */\n      return precallC(L, func, LUA_MULTRET, clCvalue(s2v(func))->f);\n    case LUA_VLCF:  /* light C function */\n      return precallC(L, func, LUA_MULTRET, fvalue(s2v(func)));\n    case LUA_VLCL: {  /* Lua function */\n      Proto *p = clLvalue(s2v(func))->p;\n      int fsize = p->maxstacksize;  /* frame size */\n      int nfixparams = p->numparams;\n      int i;\n      ci->func -= delta;  /* restore 'func' (if vararg) */\n      for (i = 0; i < narg1; i++)  /* move down function and arguments */\n        setobjs2s(L, ci->func + i, func + i);\n      checkstackGC(L, fsize);\n      func = ci->func;  /* moved-down function */\n      for (; narg1 <= nfixparams; narg1++)\n        setnilvalue(s2v(func + narg1));  /* complete missing arguments */\n      ci->top = func + 1 + fsize;  /* top for new function */\n      lua_assert(ci->top <= L->stack_last);\n      ci->u.l.savedpc = p->code;  /* starting point */\n      ci->callstatus |= CIST_TAIL;\n      L->top = func + narg1;  /* set top */\n      return -1;\n    }\n    default: {  /* not a function */\n      func = luaD_tryfuncTM(L, func);  /* try to get '__call' metamethod */\n      /* return luaD_pretailcall(L, ci, func, narg1 + 1, delta); */\n      narg1++;\n      goto retry;  /* try again */\n    }\n  }\n}\n\n\n/*\n** Prepares the call to a function (C or Lua). For C functions, also do\n** the call. The function to be called is at '*func'.  The arguments\n** are on the stack, right after the function.  Returns the CallInfo\n** to be executed, if it was a Lua function. Otherwise (a C function)\n** returns NULL, with all the results on the stack, starting at the\n** original function position.\n*/\nCallInfo *luaD_precall (lua_State *L, StkId func, int nresults) {\n retry:\n  switch (ttypetag(s2v(func))) {\n    case LUA_VCCL:  /* C closure */\n      precallC(L, func, nresults, clCvalue(s2v(func))->f);\n      return NULL;\n    case LUA_VLCF:  /* light C function */\n      precallC(L, func, nresults, fvalue(s2v(func)));\n      return NULL;\n    case LUA_VLCL: {  /* Lua function */\n      CallInfo *ci;\n      Proto *p = clLvalue(s2v(func))->p;\n      int narg = cast_int(L->top - func) - 1;  /* number of real arguments */\n      int nfixparams = p->numparams;\n      int fsize = p->maxstacksize;  /* frame size */\n      checkstackGCp(L, fsize, func);\n      L->ci = ci = prepCallInfo(L, func, nresults, 0, func + 1 + fsize);\n      ci->u.l.savedpc = p->code;  /* starting point */\n      for (; narg < nfixparams; narg++)\n        setnilvalue(s2v(L->top++));  /* complete missing arguments */\n      lua_assert(ci->top <= L->stack_last);\n      return ci;\n    }\n    default: {  /* not a function */\n      func = luaD_tryfuncTM(L, func);  /* try to get '__call' metamethod */\n      /* return luaD_precall(L, func, nresults); */\n      goto retry;  /* try again with metamethod */\n    }\n  }\n}\n\n\n/*\n** Call a function (C or Lua) through C. 'inc' can be 1 (increment\n** number of recursive invocations in the C stack) or nyci (the same\n** plus increment number of non-yieldable calls).\n*/\nl_sinline void ccall (lua_State *L, StkId func, int nResults, int inc) {\n  CallInfo *ci;\n  L->nCcalls += inc;\n  if (l_unlikely(getCcalls(L) >= LUAI_MAXCCALLS))\n    luaE_checkcstack(L);\n  if ((ci = luaD_precall(L, func, nResults)) != NULL) {  /* Lua function? */\n    ci->callstatus = CIST_FRESH;  /* mark that it is a \"fresh\" execute */\n    luaV_execute(L, ci);  /* call it */\n  }\n  L->nCcalls -= inc;\n}\n\n\n/*\n** External interface for 'ccall'\n*/\nvoid luaD_call (lua_State *L, StkId func, int nResults) {\n  ccall(L, func, nResults, 1);\n}\n\n\n/*\n** Similar to 'luaD_call', but does not allow yields during the call.\n*/\nvoid luaD_callnoyield (lua_State *L, StkId func, int nResults) {\n  ccall(L, func, nResults, nyci);\n}\n\n\n/*\n** Finish the job of 'lua_pcallk' after it was interrupted by an yield.\n** (The caller, 'finishCcall', does the final call to 'adjustresults'.)\n** The main job is to complete the 'luaD_pcall' called by 'lua_pcallk'.\n** If a '__close' method yields here, eventually control will be back\n** to 'finishCcall' (when that '__close' method finally returns) and\n** 'finishpcallk' will run again and close any still pending '__close'\n** methods. Similarly, if a '__close' method errs, 'precover' calls\n** 'unroll' which calls ''finishCcall' and we are back here again, to\n** close any pending '__close' methods.\n** Note that, up to the call to 'luaF_close', the corresponding\n** 'CallInfo' is not modified, so that this repeated run works like the\n** first one (except that it has at least one less '__close' to do). In\n** particular, field CIST_RECST preserves the error status across these\n** multiple runs, changing only if there is a new error.\n*/\nstatic int finishpcallk (lua_State *L,  CallInfo *ci) {\n  int status = getcistrecst(ci);  /* get original status */\n  if (l_likely(status == LUA_OK))  /* no error? */\n    status = LUA_YIELD;  /* was interrupted by an yield */\n  else {  /* error */\n    StkId func = restorestack(L, ci->u2.funcidx);\n    L->allowhook = getoah(ci->callstatus);  /* restore 'allowhook' */\n    luaF_close(L, func, status, 1);  /* can yield or raise an error */\n    func = restorestack(L, ci->u2.funcidx);  /* stack may be moved */\n    luaD_seterrorobj(L, status, func);\n    luaD_shrinkstack(L);   /* restore stack size in case of overflow */\n    setcistrecst(ci, LUA_OK);  /* clear original status */\n  }\n  ci->callstatus &= ~CIST_YPCALL;\n  L->errfunc = ci->u.c.old_errfunc;\n  /* if it is here, there were errors or yields; unlike 'lua_pcallk',\n     do not change status */\n  return status;\n}\n\n\n/*\n** Completes the execution of a C function interrupted by an yield.\n** The interruption must have happened while the function was either\n** closing its tbc variables in 'moveresults' or executing\n** 'lua_callk'/'lua_pcallk'. In the first case, it just redoes\n** 'luaD_poscall'. In the second case, the call to 'finishpcallk'\n** finishes the interrupted execution of 'lua_pcallk'.  After that, it\n** calls the continuation of the interrupted function and finally it\n** completes the job of the 'luaD_call' that called the function.  In\n** the call to 'adjustresults', we do not know the number of results\n** of the function called by 'lua_callk'/'lua_pcallk', so we are\n** conservative and use LUA_MULTRET (always adjust).\n*/\nstatic void finishCcall (lua_State *L, CallInfo *ci) {\n  int n;  /* actual number of results from C function */\n  if (ci->callstatus & CIST_CLSRET) {  /* was returning? */\n    lua_assert(hastocloseCfunc(ci->nresults));\n    n = ci->u2.nres;  /* just redo 'luaD_poscall' */\n    /* don't need to reset CIST_CLSRET, as it will be set again anyway */\n  }\n  else {\n    int status = LUA_YIELD;  /* default if there were no errors */\n    /* must have a continuation and must be able to call it */\n    lua_assert(ci->u.c.k != NULL && yieldable(L));\n    if (ci->callstatus & CIST_YPCALL)   /* was inside a 'lua_pcallk'? */\n      status = finishpcallk(L, ci);  /* finish it */\n    adjustresults(L, LUA_MULTRET);  /* finish 'lua_callk' */\n    lua_unlock(L);\n    n = (*ci->u.c.k)(L, status, ci->u.c.ctx);  /* call continuation */\n    lua_lock(L);\n    api_checknelems(L, n);\n  }\n  luaD_poscall(L, ci, n);  /* finish 'luaD_call' */\n}\n\n\n/*\n** Executes \"full continuation\" (everything in the stack) of a\n** previously interrupted coroutine until the stack is empty (or another\n** interruption long-jumps out of the loop).\n*/\nstatic void unroll (lua_State *L, void *ud) {\n  CallInfo *ci;\n  UNUSED(ud);\n  while ((ci = L->ci) != &L->base_ci) {  /* something in the stack */\n    if (!isLua(ci))  /* C function? */\n      finishCcall(L, ci);  /* complete its execution */\n    else {  /* Lua function */\n      luaV_finishOp(L);  /* finish interrupted instruction */\n      luaV_execute(L, ci);  /* execute down to higher C 'boundary' */\n    }\n  }\n}\n\n\n/*\n** Try to find a suspended protected call (a \"recover point\") for the\n** given thread.\n*/\nstatic CallInfo *findpcall (lua_State *L) {\n  CallInfo *ci;\n  for (ci = L->ci; ci != NULL; ci = ci->previous) {  /* search for a pcall */\n    if (ci->callstatus & CIST_YPCALL)\n      return ci;\n  }\n  return NULL;  /* no pending pcall */\n}\n\n\n/*\n** Signal an error in the call to 'lua_resume', not in the execution\n** of the coroutine itself. (Such errors should not be handled by any\n** coroutine error handler and should not kill the coroutine.)\n*/\nstatic int resume_error (lua_State *L, const char *msg, int narg) {\n  L->top -= narg;  /* remove args from the stack */\n  setsvalue2s(L, L->top, luaS_new(L, msg));  /* push error message */\n  api_incr_top(L);\n  lua_unlock(L);\n  return LUA_ERRRUN;\n}\n\n\n/*\n** Do the work for 'lua_resume' in protected mode. Most of the work\n** depends on the status of the coroutine: initial state, suspended\n** inside a hook, or regularly suspended (optionally with a continuation\n** function), plus erroneous cases: non-suspended coroutine or dead\n** coroutine.\n*/\nstatic void resume (lua_State *L, void *ud) {\n  int n = *(cast(int*, ud));  /* number of arguments */\n  StkId firstArg = L->top - n;  /* first argument */\n  CallInfo *ci = L->ci;\n  if (L->status == LUA_OK)  /* starting a coroutine? */\n    ccall(L, firstArg - 1, LUA_MULTRET, 0);  /* just call its body */\n  else {  /* resuming from previous yield */\n    lua_assert(L->status == LUA_YIELD);\n    L->status = LUA_OK;  /* mark that it is running (again) */\n    if (isLua(ci)) {  /* yielded inside a hook? */\n      L->top = firstArg;  /* discard arguments */\n      luaV_execute(L, ci);  /* just continue running Lua code */\n    }\n    else {  /* 'common' yield */\n      if (ci->u.c.k != NULL) {  /* does it have a continuation function? */\n        lua_unlock(L);\n        n = (*ci->u.c.k)(L, LUA_YIELD, ci->u.c.ctx); /* call continuation */\n        lua_lock(L);\n        api_checknelems(L, n);\n      }\n      luaD_poscall(L, ci, n);  /* finish 'luaD_call' */\n    }\n    unroll(L, NULL);  /* run continuation */\n  }\n}\n\n\n/*\n** Unrolls a coroutine in protected mode while there are recoverable\n** errors, that is, errors inside a protected call. (Any error\n** interrupts 'unroll', and this loop protects it again so it can\n** continue.) Stops with a normal end (status == LUA_OK), an yield\n** (status == LUA_YIELD), or an unprotected error ('findpcall' doesn't\n** find a recover point).\n*/\nstatic int precover (lua_State *L, int status) {\n  CallInfo *ci;\n  while (errorstatus(status) && (ci = findpcall(L)) != NULL) {\n    L->ci = ci;  /* go down to recovery functions */\n    setcistrecst(ci, status);  /* status to finish 'pcall' */\n    status = luaD_rawrunprotected(L, unroll, NULL);\n  }\n  return status;\n}\n\n\nLUA_API int lua_resume (lua_State *L, lua_State *from, int nargs,\n                                      int *nresults) {\n  int status;\n  lua_lock(L);\n  if (L->status == LUA_OK) {  /* may be starting a coroutine */\n    if (L->ci != &L->base_ci)  /* not in base level? */\n      return resume_error(L, \"cannot resume non-suspended coroutine\", nargs);\n    else if (L->top - (L->ci->func + 1) == nargs)  /* no function? */\n      return resume_error(L, \"cannot resume dead coroutine\", nargs);\n  }\n  else if (L->status != LUA_YIELD)  /* ended with errors? */\n    return resume_error(L, \"cannot resume dead coroutine\", nargs);\n  L->nCcalls = (from) ? getCcalls(from) : 0;\n  if (getCcalls(L) >= LUAI_MAXCCALLS)\n    return resume_error(L, \"C stack overflow\", nargs);\n  L->nCcalls++;\n  luai_userstateresume(L, nargs);\n  api_checknelems(L, (L->status == LUA_OK) ? nargs + 1 : nargs);\n  status = luaD_rawrunprotected(L, resume, &nargs);\n   /* continue running after recoverable errors */\n  status = precover(L, status);\n  if (l_likely(!errorstatus(status)))\n    lua_assert(status == L->status);  /* normal end or yield */\n  else {  /* unrecoverable error */\n    L->status = cast_byte(status);  /* mark thread as 'dead' */\n    luaD_seterrorobj(L, status, L->top);  /* push error message */\n    L->ci->top = L->top;\n  }\n  *nresults = (status == LUA_YIELD) ? L->ci->u2.nyield\n                                    : cast_int(L->top - (L->ci->func + 1));\n  lua_unlock(L);\n  return status;\n}\n\n\nLUA_API int lua_isyieldable (lua_State *L) {\n  return yieldable(L);\n}\n\n\nLUA_API int lua_yieldk (lua_State *L, int nresults, lua_KContext ctx,\n                        lua_KFunction k) {\n  CallInfo *ci;\n  luai_userstateyield(L, nresults);\n  lua_lock(L);\n  ci = L->ci;\n  api_checknelems(L, nresults);\n  if (l_unlikely(!yieldable(L))) {\n    if (L != G(L)->mainthread)\n      luaG_runerror(L, \"attempt to yield across a C-call boundary\");\n    else\n      luaG_runerror(L, \"attempt to yield from outside a coroutine\");\n  }\n  L->status = LUA_YIELD;\n  ci->u2.nyield = nresults;  /* save number of results */\n  if (isLua(ci)) {  /* inside a hook? */\n    lua_assert(!isLuacode(ci));\n    api_check(L, nresults == 0, \"hooks cannot yield values\");\n    api_check(L, k == NULL, \"hooks cannot continue after yielding\");\n  }\n  else {\n    if ((ci->u.c.k = k) != NULL)  /* is there a continuation? */\n      ci->u.c.ctx = ctx;  /* save context */\n    luaD_throw(L, LUA_YIELD);\n  }\n  lua_assert(ci->callstatus & CIST_HOOKED);  /* must be inside a hook */\n  lua_unlock(L);\n  return 0;  /* return to 'luaD_hook' */\n}\n\n\n/*\n** Auxiliary structure to call 'luaF_close' in protected mode.\n*/\nstruct CloseP {\n  StkId level;\n  int status;\n};\n\n\n/*\n** Auxiliary function to call 'luaF_close' in protected mode.\n*/\nstatic void closepaux (lua_State *L, void *ud) {\n  struct CloseP *pcl = cast(struct CloseP *, ud);\n  luaF_close(L, pcl->level, pcl->status, 0);\n}\n\n\n/*\n** Calls 'luaF_close' in protected mode. Return the original status\n** or, in case of errors, the new status.\n*/\nint luaD_closeprotected (lua_State *L, ptrdiff_t level, int status) {\n  CallInfo *old_ci = L->ci;\n  lu_byte old_allowhooks = L->allowhook;\n  for (;;) {  /* keep closing upvalues until no more errors */\n    struct CloseP pcl;\n    pcl.level = restorestack(L, level); pcl.status = status;\n    status = luaD_rawrunprotected(L, &closepaux, &pcl);\n    if (l_likely(status == LUA_OK))  /* no more errors? */\n      return pcl.status;\n    else {  /* an error occurred; restore saved state and repeat */\n      L->ci = old_ci;\n      L->allowhook = old_allowhooks;\n    }\n  }\n}\n\n\n/*\n** Call the C function 'func' in protected mode, restoring basic\n** thread information ('allowhook', etc.) and in particular\n** its stack level in case of errors.\n*/\nint luaD_pcall (lua_State *L, Pfunc func, void *u,\n                ptrdiff_t old_top, ptrdiff_t ef) {\n  int status;\n  CallInfo *old_ci = L->ci;\n  lu_byte old_allowhooks = L->allowhook;\n  ptrdiff_t old_errfunc = L->errfunc;\n  L->errfunc = ef;\n  status = luaD_rawrunprotected(L, func, u);\n  if (l_unlikely(status != LUA_OK)) {  /* an error occurred? */\n    L->ci = old_ci;\n    L->allowhook = old_allowhooks;\n    status = luaD_closeprotected(L, old_top, status);\n    luaD_seterrorobj(L, status, restorestack(L, old_top));\n    luaD_shrinkstack(L);   /* restore stack size in case of overflow */\n  }\n  L->errfunc = old_errfunc;\n  return status;\n}\n\n\n\n/*\n** Execute a protected parser.\n*/\nstruct SParser {  /* data to 'f_parser' */\n  ZIO *z;\n  Mbuffer buff;  /* dynamic structure used by the scanner */\n  Dyndata dyd;  /* dynamic structures used by the parser */\n  const char *mode;\n  const char *name;\n};\n\n\nstatic void checkmode (lua_State *L, const char *mode, const char *x) {\n  if (mode && strchr(mode, x[0]) == NULL) {\n    luaO_pushfstring(L,\n       \"attempt to load a %s chunk (mode is '%s')\", x, mode);\n    luaD_throw(L, LUA_ERRSYNTAX);\n  }\n}\n\n\nstatic void f_parser (lua_State *L, void *ud) {\n  LClosure *cl;\n  struct SParser *p = cast(struct SParser *, ud);\n  int c = zgetc(p->z);  /* read first character */\n  if (c == LUA_SIGNATURE[0]) {\n    checkmode(L, p->mode, \"binary\");\n    cl = luaU_undump(L, p->z, p->name);\n  }\n  else {\n    checkmode(L, p->mode, \"text\");\n    cl = luaY_parser(L, p->z, &p->buff, &p->dyd, p->name, c);\n  }\n  lua_assert(cl->nupvalues == cl->p->sizeupvalues);\n  luaF_initupvals(L, cl);\n}\n\n\nint luaD_protectedparser (lua_State *L, ZIO *z, const char *name,\n                                        const char *mode) {\n  struct SParser p;\n  int status;\n  incnny(L);  /* cannot yield during parsing */\n  p.z = z; p.name = name; p.mode = mode;\n  p.dyd.actvar.arr = NULL; p.dyd.actvar.size = 0;\n  p.dyd.gt.arr = NULL; p.dyd.gt.size = 0;\n  p.dyd.label.arr = NULL; p.dyd.label.size = 0;\n  luaZ_initbuffer(L, &p.buff);\n  status = luaD_pcall(L, f_parser, &p, savestack(L, L->top), L->errfunc);\n  luaZ_freebuffer(L, &p.buff);\n  luaM_freearray(L, p.dyd.actvar.arr, p.dyd.actvar.size);\n  luaM_freearray(L, p.dyd.gt.arr, p.dyd.gt.size);\n  luaM_freearray(L, p.dyd.label.arr, p.dyd.label.size);\n  decnny(L);\n  return status;\n}\n\n\n"], "fixing_code": ["/*\n** $Id: ldo.c $\n** Stack and Call structure of Lua\n** See Copyright Notice in lua.h\n*/\n\n#define ldo_c\n#define LUA_CORE\n\n#include \"lprefix.h\"\n\n\n#include <setjmp.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"lua.h\"\n\n#include \"lapi.h\"\n#include \"ldebug.h\"\n#include \"ldo.h\"\n#include \"lfunc.h\"\n#include \"lgc.h\"\n#include \"lmem.h\"\n#include \"lobject.h\"\n#include \"lopcodes.h\"\n#include \"lparser.h\"\n#include \"lstate.h\"\n#include \"lstring.h\"\n#include \"ltable.h\"\n#include \"ltm.h\"\n#include \"lundump.h\"\n#include \"lvm.h\"\n#include \"lzio.h\"\n\n\n\n#define errorstatus(s)\t((s) > LUA_YIELD)\n\n\n/*\n** {======================================================\n** Error-recovery functions\n** =======================================================\n*/\n\n/*\n** LUAI_THROW/LUAI_TRY define how Lua does exception handling. By\n** default, Lua handles errors with exceptions when compiling as\n** C++ code, with _longjmp/_setjmp when asked to use them, and with\n** longjmp/setjmp otherwise.\n*/\n#if !defined(LUAI_THROW)\t\t\t\t/* { */\n\n#if defined(__cplusplus) && !defined(LUA_USE_LONGJMP)\t/* { */\n\n/* C++ exceptions */\n#define LUAI_THROW(L,c)\t\tthrow(c)\n#define LUAI_TRY(L,c,a) \\\n\ttry { a } catch(...) { if ((c)->status == 0) (c)->status = -1; }\n#define luai_jmpbuf\t\tint  /* dummy variable */\n\n#elif defined(LUA_USE_POSIX)\t\t\t\t/* }{ */\n\n/* in POSIX, try _longjmp/_setjmp (more efficient) */\n#define LUAI_THROW(L,c)\t\t_longjmp((c)->b, 1)\n#define LUAI_TRY(L,c,a)\t\tif (_setjmp((c)->b) == 0) { a }\n#define luai_jmpbuf\t\tjmp_buf\n\n#else\t\t\t\t\t\t\t/* }{ */\n\n/* ISO C handling with long jumps */\n#define LUAI_THROW(L,c)\t\tlongjmp((c)->b, 1)\n#define LUAI_TRY(L,c,a)\t\tif (setjmp((c)->b) == 0) { a }\n#define luai_jmpbuf\t\tjmp_buf\n\n#endif\t\t\t\t\t\t\t/* } */\n\n#endif\t\t\t\t\t\t\t/* } */\n\n\n\n/* chain list of long jump buffers */\nstruct lua_longjmp {\n  struct lua_longjmp *previous;\n  luai_jmpbuf b;\n  volatile int status;  /* error code */\n};\n\n\nvoid luaD_seterrorobj (lua_State *L, int errcode, StkId oldtop) {\n  switch (errcode) {\n    case LUA_ERRMEM: {  /* memory error? */\n      setsvalue2s(L, oldtop, G(L)->memerrmsg); /* reuse preregistered msg. */\n      break;\n    }\n    case LUA_ERRERR: {\n      setsvalue2s(L, oldtop, luaS_newliteral(L, \"error in error handling\"));\n      break;\n    }\n    case LUA_OK: {  /* special case only for closing upvalues */\n      setnilvalue(s2v(oldtop));  /* no error message */\n      break;\n    }\n    default: {\n      lua_assert(errorstatus(errcode));  /* real error */\n      setobjs2s(L, oldtop, L->top - 1);  /* error message on current top */\n      break;\n    }\n  }\n  L->top = oldtop + 1;\n}\n\n\nl_noret luaD_throw (lua_State *L, int errcode) {\n  if (L->errorJmp) {  /* thread has an error handler? */\n    L->errorJmp->status = errcode;  /* set status */\n    LUAI_THROW(L, L->errorJmp);  /* jump to it */\n  }\n  else {  /* thread has no error handler */\n    global_State *g = G(L);\n    errcode = luaE_resetthread(L, errcode);  /* close all upvalues */\n    if (g->mainthread->errorJmp) {  /* main thread has a handler? */\n      setobjs2s(L, g->mainthread->top++, L->top - 1);  /* copy error obj. */\n      luaD_throw(g->mainthread, errcode);  /* re-throw in main thread */\n    }\n    else {  /* no handler at all; abort */\n      if (g->panic) {  /* panic function? */\n        lua_unlock(L);\n        g->panic(L);  /* call panic function (last chance to jump out) */\n      }\n      abort();\n    }\n  }\n}\n\n\nint luaD_rawrunprotected (lua_State *L, Pfunc f, void *ud) {\n  l_uint32 oldnCcalls = L->nCcalls;\n  struct lua_longjmp lj;\n  lj.status = LUA_OK;\n  lj.previous = L->errorJmp;  /* chain new error handler */\n  L->errorJmp = &lj;\n  LUAI_TRY(L, &lj,\n    (*f)(L, ud);\n  );\n  L->errorJmp = lj.previous;  /* restore old error handler */\n  L->nCcalls = oldnCcalls;\n  return lj.status;\n}\n\n/* }====================================================== */\n\n\n/*\n** {==================================================================\n** Stack reallocation\n** ===================================================================\n*/\nstatic void correctstack (lua_State *L, StkId oldstack, StkId newstack) {\n  CallInfo *ci;\n  UpVal *up;\n  L->top = (L->top - oldstack) + newstack;\n  L->tbclist = (L->tbclist - oldstack) + newstack;\n  for (up = L->openupval; up != NULL; up = up->u.open.next)\n    up->v = s2v((uplevel(up) - oldstack) + newstack);\n  for (ci = L->ci; ci != NULL; ci = ci->previous) {\n    ci->top = (ci->top - oldstack) + newstack;\n    ci->func = (ci->func - oldstack) + newstack;\n    if (isLua(ci))\n      ci->u.l.trap = 1;  /* signal to update 'trap' in 'luaV_execute' */\n  }\n}\n\n\n/* some space for error handling */\n#define ERRORSTACKSIZE\t(LUAI_MAXSTACK + 200)\n\n\n/*\n** Reallocate the stack to a new size, correcting all pointers into\n** it. (There are pointers to a stack from its upvalues, from its list\n** of call infos, plus a few individual pointers.) The reallocation is\n** done in two steps (allocation + free) because the correction must be\n** done while both addresses (the old stack and the new one) are valid.\n** (In ISO C, any pointer use after the pointer has been deallocated is\n** undefined behavior.)\n** In case of allocation error, raise an error or return false according\n** to 'raiseerror'.\n*/\nint luaD_reallocstack (lua_State *L, int newsize, int raiseerror) {\n  int oldsize = stacksize(L);\n  int i;\n  StkId newstack = luaM_reallocvector(L, NULL, 0,\n                                      newsize + EXTRA_STACK, StackValue);\n  lua_assert(newsize <= LUAI_MAXSTACK || newsize == ERRORSTACKSIZE);\n  if (l_unlikely(newstack == NULL)) {  /* reallocation failed? */\n    if (raiseerror)\n      luaM_error(L);\n    else return 0;  /* do not raise an error */\n  }\n  /* number of elements to be copied to the new stack */\n  i = ((oldsize <= newsize) ? oldsize : newsize) + EXTRA_STACK;\n  memcpy(newstack, L->stack, i * sizeof(StackValue));\n  for (; i < newsize + EXTRA_STACK; i++)\n    setnilvalue(s2v(newstack + i)); /* erase new segment */\n  correctstack(L, L->stack, newstack);\n  luaM_freearray(L, L->stack, oldsize + EXTRA_STACK);\n  L->stack = newstack;\n  L->stack_last = L->stack + newsize;\n  return 1;\n}\n\n\n/*\n** Try to grow the stack by at least 'n' elements. when 'raiseerror'\n** is true, raises any error; otherwise, return 0 in case of errors.\n*/\nint luaD_growstack (lua_State *L, int n, int raiseerror) {\n  int size = stacksize(L);\n  if (l_unlikely(size > LUAI_MAXSTACK)) {\n    /* if stack is larger than maximum, thread is already using the\n       extra space reserved for errors, that is, thread is handling\n       a stack error; cannot grow further than that. */\n    lua_assert(stacksize(L) == ERRORSTACKSIZE);\n    if (raiseerror)\n      luaD_throw(L, LUA_ERRERR);  /* error inside message handler */\n    return 0;  /* if not 'raiseerror', just signal it */\n  }\n  else {\n    int newsize = 2 * size;  /* tentative new size */\n    int needed = cast_int(L->top - L->stack) + n;\n    if (newsize > LUAI_MAXSTACK)  /* cannot cross the limit */\n      newsize = LUAI_MAXSTACK;\n    if (newsize < needed)  /* but must respect what was asked for */\n      newsize = needed;\n    if (l_likely(newsize <= LUAI_MAXSTACK))\n      return luaD_reallocstack(L, newsize, raiseerror);\n    else {  /* stack overflow */\n      /* add extra size to be able to handle the error message */\n      luaD_reallocstack(L, ERRORSTACKSIZE, raiseerror);\n      if (raiseerror)\n        luaG_runerror(L, \"stack overflow\");\n      return 0;\n    }\n  }\n}\n\n\nstatic int stackinuse (lua_State *L) {\n  CallInfo *ci;\n  int res;\n  StkId lim = L->top;\n  for (ci = L->ci; ci != NULL; ci = ci->previous) {\n    if (lim < ci->top) lim = ci->top;\n  }\n  lua_assert(lim <= L->stack_last);\n  res = cast_int(lim - L->stack) + 1;  /* part of stack in use */\n  if (res < LUA_MINSTACK)\n    res = LUA_MINSTACK;  /* ensure a minimum size */\n  return res;\n}\n\n\n/*\n** If stack size is more than 3 times the current use, reduce that size\n** to twice the current use. (So, the final stack size is at most 2/3 the\n** previous size, and half of its entries are empty.)\n** As a particular case, if stack was handling a stack overflow and now\n** it is not, 'max' (limited by LUAI_MAXSTACK) will be smaller than\n** stacksize (equal to ERRORSTACKSIZE in this case), and so the stack\n** will be reduced to a \"regular\" size.\n*/\nvoid luaD_shrinkstack (lua_State *L) {\n  int inuse = stackinuse(L);\n  int nsize = inuse * 2;  /* proposed new size */\n  int max = inuse * 3;  /* maximum \"reasonable\" size */\n  if (max > LUAI_MAXSTACK) {\n    max = LUAI_MAXSTACK;  /* respect stack limit */\n    if (nsize > LUAI_MAXSTACK)\n      nsize = LUAI_MAXSTACK;\n  }\n  /* if thread is currently not handling a stack overflow and its\n     size is larger than maximum \"reasonable\" size, shrink it */\n  if (inuse <= LUAI_MAXSTACK && stacksize(L) > max)\n    luaD_reallocstack(L, nsize, 0);  /* ok if that fails */\n  else  /* don't change stack */\n    condmovestack(L,{},{});  /* (change only for debugging) */\n  luaE_shrinkCI(L);  /* shrink CI list */\n}\n\n\nvoid luaD_inctop (lua_State *L) {\n  luaD_checkstack(L, 1);\n  L->top++;\n}\n\n/* }================================================================== */\n\n\n/*\n** Call a hook for the given event. Make sure there is a hook to be\n** called. (Both 'L->hook' and 'L->hookmask', which trigger this\n** function, can be changed asynchronously by signals.)\n*/\nvoid luaD_hook (lua_State *L, int event, int line,\n                              int ftransfer, int ntransfer) {\n  lua_Hook hook = L->hook;\n  if (hook && L->allowhook) {  /* make sure there is a hook */\n    int mask = CIST_HOOKED;\n    CallInfo *ci = L->ci;\n    ptrdiff_t top = savestack(L, L->top);  /* preserve original 'top' */\n    ptrdiff_t ci_top = savestack(L, ci->top);  /* idem for 'ci->top' */\n    lua_Debug ar;\n    ar.event = event;\n    ar.currentline = line;\n    ar.i_ci = ci;\n    if (ntransfer != 0) {\n      mask |= CIST_TRAN;  /* 'ci' has transfer information */\n      ci->u2.transferinfo.ftransfer = ftransfer;\n      ci->u2.transferinfo.ntransfer = ntransfer;\n    }\n    if (isLua(ci) && L->top < ci->top)\n      L->top = ci->top;  /* protect entire activation register */\n    luaD_checkstack(L, LUA_MINSTACK);  /* ensure minimum stack size */\n    if (ci->top < L->top + LUA_MINSTACK)\n      ci->top = L->top + LUA_MINSTACK;\n    L->allowhook = 0;  /* cannot call hooks inside a hook */\n    ci->callstatus |= mask;\n    lua_unlock(L);\n    (*hook)(L, &ar);\n    lua_lock(L);\n    lua_assert(!L->allowhook);\n    L->allowhook = 1;\n    ci->top = restorestack(L, ci_top);\n    L->top = restorestack(L, top);\n    ci->callstatus &= ~mask;\n  }\n}\n\n\n/*\n** Executes a call hook for Lua functions. This function is called\n** whenever 'hookmask' is not zero, so it checks whether call hooks are\n** active.\n*/\nvoid luaD_hookcall (lua_State *L, CallInfo *ci) {\n  L->oldpc = 0;  /* set 'oldpc' for new function */\n  if (L->hookmask & LUA_MASKCALL) {  /* is call hook on? */\n    int event = (ci->callstatus & CIST_TAIL) ? LUA_HOOKTAILCALL\n                                             : LUA_HOOKCALL;\n    Proto *p = ci_func(ci)->p;\n    ci->u.l.savedpc++;  /* hooks assume 'pc' is already incremented */\n    luaD_hook(L, event, -1, 1, p->numparams);\n    ci->u.l.savedpc--;  /* correct 'pc' */\n  }\n}\n\n\n/*\n** Executes a return hook for Lua and C functions and sets/corrects\n** 'oldpc'. (Note that this correction is needed by the line hook, so it\n** is done even when return hooks are off.)\n*/\nstatic void rethook (lua_State *L, CallInfo *ci, int nres) {\n  if (L->hookmask & LUA_MASKRET) {  /* is return hook on? */\n    StkId firstres = L->top - nres;  /* index of first result */\n    int delta = 0;  /* correction for vararg functions */\n    int ftransfer;\n    if (isLua(ci)) {\n      Proto *p = ci_func(ci)->p;\n      if (p->is_vararg)\n        delta = ci->u.l.nextraargs + p->numparams + 1;\n    }\n    ci->func += delta;  /* if vararg, back to virtual 'func' */\n    ftransfer = cast(unsigned short, firstres - ci->func);\n    luaD_hook(L, LUA_HOOKRET, -1, ftransfer, nres);  /* call it */\n    ci->func -= delta;\n  }\n  if (isLua(ci = ci->previous))\n    L->oldpc = pcRel(ci->u.l.savedpc, ci_func(ci)->p);  /* set 'oldpc' */\n}\n\n\n/*\n** Check whether 'func' has a '__call' metafield. If so, put it in the\n** stack, below original 'func', so that 'luaD_precall' can call it. Raise\n** an error if there is no '__call' metafield.\n*/\nStkId luaD_tryfuncTM (lua_State *L, StkId func) {\n  const TValue *tm;\n  StkId p;\n  checkstackGCp(L, 1, func);  /* space for metamethod */\n  tm = luaT_gettmbyobj(L, s2v(func), TM_CALL);  /* (after previous GC) */\n  if (l_unlikely(ttisnil(tm)))\n    luaG_callerror(L, s2v(func));  /* nothing to call */\n  for (p = L->top; p > func; p--)  /* open space for metamethod */\n    setobjs2s(L, p, p-1);\n  L->top++;  /* stack space pre-allocated by the caller */\n  setobj2s(L, func, tm);  /* metamethod is the new function to be called */\n  return func;\n}\n\n\n/*\n** Given 'nres' results at 'firstResult', move 'wanted' of them to 'res'.\n** Handle most typical cases (zero results for commands, one result for\n** expressions, multiple results for tail calls/single parameters)\n** separated.\n*/\nl_sinline void moveresults (lua_State *L, StkId res, int nres, int wanted) {\n  StkId firstresult;\n  int i;\n  switch (wanted) {  /* handle typical cases separately */\n    case 0:  /* no values needed */\n      L->top = res;\n      return;\n    case 1:  /* one value needed */\n      if (nres == 0)   /* no results? */\n        setnilvalue(s2v(res));  /* adjust with nil */\n      else  /* at least one result */\n        setobjs2s(L, res, L->top - nres);  /* move it to proper place */\n      L->top = res + 1;\n      return;\n    case LUA_MULTRET:\n      wanted = nres;  /* we want all results */\n      break;\n    default:  /* two/more results and/or to-be-closed variables */\n      if (hastocloseCfunc(wanted)) {  /* to-be-closed variables? */\n        ptrdiff_t savedres = savestack(L, res);\n        L->ci->callstatus |= CIST_CLSRET;  /* in case of yields */\n        L->ci->u2.nres = nres;\n        luaF_close(L, res, CLOSEKTOP, 1);\n        L->ci->callstatus &= ~CIST_CLSRET;\n        if (L->hookmask)  /* if needed, call hook after '__close's */\n          rethook(L, L->ci, nres);\n        res = restorestack(L, savedres);  /* close and hook can move stack */\n        wanted = decodeNresults(wanted);\n        if (wanted == LUA_MULTRET)\n          wanted = nres;  /* we want all results */\n      }\n      break;\n  }\n  /* generic case */\n  firstresult = L->top - nres;  /* index of first result */\n  if (nres > wanted)  /* extra results? */\n    nres = wanted;  /* don't need them */\n  for (i = 0; i < nres; i++)  /* move all results to correct place */\n    setobjs2s(L, res + i, firstresult + i);\n  for (; i < wanted; i++)  /* complete wanted number of results */\n    setnilvalue(s2v(res + i));\n  L->top = res + wanted;  /* top points after the last result */\n}\n\n\n/*\n** Finishes a function call: calls hook if necessary, moves current\n** number of results to proper place, and returns to previous call\n** info. If function has to close variables, hook must be called after\n** that.\n*/\nvoid luaD_poscall (lua_State *L, CallInfo *ci, int nres) {\n  int wanted = ci->nresults;\n  if (l_unlikely(L->hookmask && !hastocloseCfunc(wanted)))\n    rethook(L, ci, nres);\n  /* move results to proper place */\n  moveresults(L, ci->func, nres, wanted);\n  /* function cannot be in any of these cases when returning */\n  lua_assert(!(ci->callstatus &\n        (CIST_HOOKED | CIST_YPCALL | CIST_FIN | CIST_TRAN | CIST_CLSRET)));\n  L->ci = ci->previous;  /* back to caller (after closing variables) */\n}\n\n\n\n#define next_ci(L)  (L->ci->next ? L->ci->next : luaE_extendCI(L))\n\n\nl_sinline CallInfo *prepCallInfo (lua_State *L, StkId func, int nret,\n                                                int mask, StkId top) {\n  CallInfo *ci = L->ci = next_ci(L);  /* new frame */\n  ci->func = func;\n  ci->nresults = nret;\n  ci->callstatus = mask;\n  ci->top = top;\n  return ci;\n}\n\n\n/*\n** precall for C functions\n*/\nl_sinline int precallC (lua_State *L, StkId func, int nresults,\n                                            lua_CFunction f) {\n  int n;  /* number of returns */\n  CallInfo *ci;\n  checkstackGCp(L, LUA_MINSTACK, func);  /* ensure minimum stack size */\n  L->ci = ci = prepCallInfo(L, func, nresults, CIST_C,\n                               L->top + LUA_MINSTACK);\n  lua_assert(ci->top <= L->stack_last);\n  if (l_unlikely(L->hookmask & LUA_MASKCALL)) {\n    int narg = cast_int(L->top - func) - 1;\n    luaD_hook(L, LUA_HOOKCALL, -1, 1, narg);\n  }\n  lua_unlock(L);\n  n = (*f)(L);  /* do the actual call */\n  lua_lock(L);\n  api_checknelems(L, n);\n  luaD_poscall(L, ci, n);\n  return n;\n}\n\n\n/*\n** Prepare a function for a tail call, building its call info on top\n** of the current call info. 'narg1' is the number of arguments plus 1\n** (so that it includes the function itself). Return the number of\n** results, if it was a C function, or -1 for a Lua function.\n*/\nint luaD_pretailcall (lua_State *L, CallInfo *ci, StkId func,\n                                    int narg1, int delta) {\n retry:\n  switch (ttypetag(s2v(func))) {\n    case LUA_VCCL:  /* C closure */\n      return precallC(L, func, LUA_MULTRET, clCvalue(s2v(func))->f);\n    case LUA_VLCF:  /* light C function */\n      return precallC(L, func, LUA_MULTRET, fvalue(s2v(func)));\n    case LUA_VLCL: {  /* Lua function */\n      Proto *p = clLvalue(s2v(func))->p;\n      int fsize = p->maxstacksize;  /* frame size */\n      int nfixparams = p->numparams;\n      int i;\n      checkstackGCp(L, fsize - delta, func);\n      ci->func -= delta;  /* restore 'func' (if vararg) */\n      for (i = 0; i < narg1; i++)  /* move down function and arguments */\n        setobjs2s(L, ci->func + i, func + i);\n      func = ci->func;  /* moved-down function */\n      for (; narg1 <= nfixparams; narg1++)\n        setnilvalue(s2v(func + narg1));  /* complete missing arguments */\n      ci->top = func + 1 + fsize;  /* top for new function */\n      lua_assert(ci->top <= L->stack_last);\n      ci->u.l.savedpc = p->code;  /* starting point */\n      ci->callstatus |= CIST_TAIL;\n      L->top = func + narg1;  /* set top */\n      return -1;\n    }\n    default: {  /* not a function */\n      func = luaD_tryfuncTM(L, func);  /* try to get '__call' metamethod */\n      /* return luaD_pretailcall(L, ci, func, narg1 + 1, delta); */\n      narg1++;\n      goto retry;  /* try again */\n    }\n  }\n}\n\n\n/*\n** Prepares the call to a function (C or Lua). For C functions, also do\n** the call. The function to be called is at '*func'.  The arguments\n** are on the stack, right after the function.  Returns the CallInfo\n** to be executed, if it was a Lua function. Otherwise (a C function)\n** returns NULL, with all the results on the stack, starting at the\n** original function position.\n*/\nCallInfo *luaD_precall (lua_State *L, StkId func, int nresults) {\n retry:\n  switch (ttypetag(s2v(func))) {\n    case LUA_VCCL:  /* C closure */\n      precallC(L, func, nresults, clCvalue(s2v(func))->f);\n      return NULL;\n    case LUA_VLCF:  /* light C function */\n      precallC(L, func, nresults, fvalue(s2v(func)));\n      return NULL;\n    case LUA_VLCL: {  /* Lua function */\n      CallInfo *ci;\n      Proto *p = clLvalue(s2v(func))->p;\n      int narg = cast_int(L->top - func) - 1;  /* number of real arguments */\n      int nfixparams = p->numparams;\n      int fsize = p->maxstacksize;  /* frame size */\n      checkstackGCp(L, fsize, func);\n      L->ci = ci = prepCallInfo(L, func, nresults, 0, func + 1 + fsize);\n      ci->u.l.savedpc = p->code;  /* starting point */\n      for (; narg < nfixparams; narg++)\n        setnilvalue(s2v(L->top++));  /* complete missing arguments */\n      lua_assert(ci->top <= L->stack_last);\n      return ci;\n    }\n    default: {  /* not a function */\n      func = luaD_tryfuncTM(L, func);  /* try to get '__call' metamethod */\n      /* return luaD_precall(L, func, nresults); */\n      goto retry;  /* try again with metamethod */\n    }\n  }\n}\n\n\n/*\n** Call a function (C or Lua) through C. 'inc' can be 1 (increment\n** number of recursive invocations in the C stack) or nyci (the same\n** plus increment number of non-yieldable calls).\n*/\nl_sinline void ccall (lua_State *L, StkId func, int nResults, int inc) {\n  CallInfo *ci;\n  L->nCcalls += inc;\n  if (l_unlikely(getCcalls(L) >= LUAI_MAXCCALLS))\n    luaE_checkcstack(L);\n  if ((ci = luaD_precall(L, func, nResults)) != NULL) {  /* Lua function? */\n    ci->callstatus = CIST_FRESH;  /* mark that it is a \"fresh\" execute */\n    luaV_execute(L, ci);  /* call it */\n  }\n  L->nCcalls -= inc;\n}\n\n\n/*\n** External interface for 'ccall'\n*/\nvoid luaD_call (lua_State *L, StkId func, int nResults) {\n  ccall(L, func, nResults, 1);\n}\n\n\n/*\n** Similar to 'luaD_call', but does not allow yields during the call.\n*/\nvoid luaD_callnoyield (lua_State *L, StkId func, int nResults) {\n  ccall(L, func, nResults, nyci);\n}\n\n\n/*\n** Finish the job of 'lua_pcallk' after it was interrupted by an yield.\n** (The caller, 'finishCcall', does the final call to 'adjustresults'.)\n** The main job is to complete the 'luaD_pcall' called by 'lua_pcallk'.\n** If a '__close' method yields here, eventually control will be back\n** to 'finishCcall' (when that '__close' method finally returns) and\n** 'finishpcallk' will run again and close any still pending '__close'\n** methods. Similarly, if a '__close' method errs, 'precover' calls\n** 'unroll' which calls ''finishCcall' and we are back here again, to\n** close any pending '__close' methods.\n** Note that, up to the call to 'luaF_close', the corresponding\n** 'CallInfo' is not modified, so that this repeated run works like the\n** first one (except that it has at least one less '__close' to do). In\n** particular, field CIST_RECST preserves the error status across these\n** multiple runs, changing only if there is a new error.\n*/\nstatic int finishpcallk (lua_State *L,  CallInfo *ci) {\n  int status = getcistrecst(ci);  /* get original status */\n  if (l_likely(status == LUA_OK))  /* no error? */\n    status = LUA_YIELD;  /* was interrupted by an yield */\n  else {  /* error */\n    StkId func = restorestack(L, ci->u2.funcidx);\n    L->allowhook = getoah(ci->callstatus);  /* restore 'allowhook' */\n    luaF_close(L, func, status, 1);  /* can yield or raise an error */\n    func = restorestack(L, ci->u2.funcidx);  /* stack may be moved */\n    luaD_seterrorobj(L, status, func);\n    luaD_shrinkstack(L);   /* restore stack size in case of overflow */\n    setcistrecst(ci, LUA_OK);  /* clear original status */\n  }\n  ci->callstatus &= ~CIST_YPCALL;\n  L->errfunc = ci->u.c.old_errfunc;\n  /* if it is here, there were errors or yields; unlike 'lua_pcallk',\n     do not change status */\n  return status;\n}\n\n\n/*\n** Completes the execution of a C function interrupted by an yield.\n** The interruption must have happened while the function was either\n** closing its tbc variables in 'moveresults' or executing\n** 'lua_callk'/'lua_pcallk'. In the first case, it just redoes\n** 'luaD_poscall'. In the second case, the call to 'finishpcallk'\n** finishes the interrupted execution of 'lua_pcallk'.  After that, it\n** calls the continuation of the interrupted function and finally it\n** completes the job of the 'luaD_call' that called the function.  In\n** the call to 'adjustresults', we do not know the number of results\n** of the function called by 'lua_callk'/'lua_pcallk', so we are\n** conservative and use LUA_MULTRET (always adjust).\n*/\nstatic void finishCcall (lua_State *L, CallInfo *ci) {\n  int n;  /* actual number of results from C function */\n  if (ci->callstatus & CIST_CLSRET) {  /* was returning? */\n    lua_assert(hastocloseCfunc(ci->nresults));\n    n = ci->u2.nres;  /* just redo 'luaD_poscall' */\n    /* don't need to reset CIST_CLSRET, as it will be set again anyway */\n  }\n  else {\n    int status = LUA_YIELD;  /* default if there were no errors */\n    /* must have a continuation and must be able to call it */\n    lua_assert(ci->u.c.k != NULL && yieldable(L));\n    if (ci->callstatus & CIST_YPCALL)   /* was inside a 'lua_pcallk'? */\n      status = finishpcallk(L, ci);  /* finish it */\n    adjustresults(L, LUA_MULTRET);  /* finish 'lua_callk' */\n    lua_unlock(L);\n    n = (*ci->u.c.k)(L, status, ci->u.c.ctx);  /* call continuation */\n    lua_lock(L);\n    api_checknelems(L, n);\n  }\n  luaD_poscall(L, ci, n);  /* finish 'luaD_call' */\n}\n\n\n/*\n** Executes \"full continuation\" (everything in the stack) of a\n** previously interrupted coroutine until the stack is empty (or another\n** interruption long-jumps out of the loop).\n*/\nstatic void unroll (lua_State *L, void *ud) {\n  CallInfo *ci;\n  UNUSED(ud);\n  while ((ci = L->ci) != &L->base_ci) {  /* something in the stack */\n    if (!isLua(ci))  /* C function? */\n      finishCcall(L, ci);  /* complete its execution */\n    else {  /* Lua function */\n      luaV_finishOp(L);  /* finish interrupted instruction */\n      luaV_execute(L, ci);  /* execute down to higher C 'boundary' */\n    }\n  }\n}\n\n\n/*\n** Try to find a suspended protected call (a \"recover point\") for the\n** given thread.\n*/\nstatic CallInfo *findpcall (lua_State *L) {\n  CallInfo *ci;\n  for (ci = L->ci; ci != NULL; ci = ci->previous) {  /* search for a pcall */\n    if (ci->callstatus & CIST_YPCALL)\n      return ci;\n  }\n  return NULL;  /* no pending pcall */\n}\n\n\n/*\n** Signal an error in the call to 'lua_resume', not in the execution\n** of the coroutine itself. (Such errors should not be handled by any\n** coroutine error handler and should not kill the coroutine.)\n*/\nstatic int resume_error (lua_State *L, const char *msg, int narg) {\n  L->top -= narg;  /* remove args from the stack */\n  setsvalue2s(L, L->top, luaS_new(L, msg));  /* push error message */\n  api_incr_top(L);\n  lua_unlock(L);\n  return LUA_ERRRUN;\n}\n\n\n/*\n** Do the work for 'lua_resume' in protected mode. Most of the work\n** depends on the status of the coroutine: initial state, suspended\n** inside a hook, or regularly suspended (optionally with a continuation\n** function), plus erroneous cases: non-suspended coroutine or dead\n** coroutine.\n*/\nstatic void resume (lua_State *L, void *ud) {\n  int n = *(cast(int*, ud));  /* number of arguments */\n  StkId firstArg = L->top - n;  /* first argument */\n  CallInfo *ci = L->ci;\n  if (L->status == LUA_OK)  /* starting a coroutine? */\n    ccall(L, firstArg - 1, LUA_MULTRET, 0);  /* just call its body */\n  else {  /* resuming from previous yield */\n    lua_assert(L->status == LUA_YIELD);\n    L->status = LUA_OK;  /* mark that it is running (again) */\n    if (isLua(ci)) {  /* yielded inside a hook? */\n      L->top = firstArg;  /* discard arguments */\n      luaV_execute(L, ci);  /* just continue running Lua code */\n    }\n    else {  /* 'common' yield */\n      if (ci->u.c.k != NULL) {  /* does it have a continuation function? */\n        lua_unlock(L);\n        n = (*ci->u.c.k)(L, LUA_YIELD, ci->u.c.ctx); /* call continuation */\n        lua_lock(L);\n        api_checknelems(L, n);\n      }\n      luaD_poscall(L, ci, n);  /* finish 'luaD_call' */\n    }\n    unroll(L, NULL);  /* run continuation */\n  }\n}\n\n\n/*\n** Unrolls a coroutine in protected mode while there are recoverable\n** errors, that is, errors inside a protected call. (Any error\n** interrupts 'unroll', and this loop protects it again so it can\n** continue.) Stops with a normal end (status == LUA_OK), an yield\n** (status == LUA_YIELD), or an unprotected error ('findpcall' doesn't\n** find a recover point).\n*/\nstatic int precover (lua_State *L, int status) {\n  CallInfo *ci;\n  while (errorstatus(status) && (ci = findpcall(L)) != NULL) {\n    L->ci = ci;  /* go down to recovery functions */\n    setcistrecst(ci, status);  /* status to finish 'pcall' */\n    status = luaD_rawrunprotected(L, unroll, NULL);\n  }\n  return status;\n}\n\n\nLUA_API int lua_resume (lua_State *L, lua_State *from, int nargs,\n                                      int *nresults) {\n  int status;\n  lua_lock(L);\n  if (L->status == LUA_OK) {  /* may be starting a coroutine */\n    if (L->ci != &L->base_ci)  /* not in base level? */\n      return resume_error(L, \"cannot resume non-suspended coroutine\", nargs);\n    else if (L->top - (L->ci->func + 1) == nargs)  /* no function? */\n      return resume_error(L, \"cannot resume dead coroutine\", nargs);\n  }\n  else if (L->status != LUA_YIELD)  /* ended with errors? */\n    return resume_error(L, \"cannot resume dead coroutine\", nargs);\n  L->nCcalls = (from) ? getCcalls(from) : 0;\n  if (getCcalls(L) >= LUAI_MAXCCALLS)\n    return resume_error(L, \"C stack overflow\", nargs);\n  L->nCcalls++;\n  luai_userstateresume(L, nargs);\n  api_checknelems(L, (L->status == LUA_OK) ? nargs + 1 : nargs);\n  status = luaD_rawrunprotected(L, resume, &nargs);\n   /* continue running after recoverable errors */\n  status = precover(L, status);\n  if (l_likely(!errorstatus(status)))\n    lua_assert(status == L->status);  /* normal end or yield */\n  else {  /* unrecoverable error */\n    L->status = cast_byte(status);  /* mark thread as 'dead' */\n    luaD_seterrorobj(L, status, L->top);  /* push error message */\n    L->ci->top = L->top;\n  }\n  *nresults = (status == LUA_YIELD) ? L->ci->u2.nyield\n                                    : cast_int(L->top - (L->ci->func + 1));\n  lua_unlock(L);\n  return status;\n}\n\n\nLUA_API int lua_isyieldable (lua_State *L) {\n  return yieldable(L);\n}\n\n\nLUA_API int lua_yieldk (lua_State *L, int nresults, lua_KContext ctx,\n                        lua_KFunction k) {\n  CallInfo *ci;\n  luai_userstateyield(L, nresults);\n  lua_lock(L);\n  ci = L->ci;\n  api_checknelems(L, nresults);\n  if (l_unlikely(!yieldable(L))) {\n    if (L != G(L)->mainthread)\n      luaG_runerror(L, \"attempt to yield across a C-call boundary\");\n    else\n      luaG_runerror(L, \"attempt to yield from outside a coroutine\");\n  }\n  L->status = LUA_YIELD;\n  ci->u2.nyield = nresults;  /* save number of results */\n  if (isLua(ci)) {  /* inside a hook? */\n    lua_assert(!isLuacode(ci));\n    api_check(L, nresults == 0, \"hooks cannot yield values\");\n    api_check(L, k == NULL, \"hooks cannot continue after yielding\");\n  }\n  else {\n    if ((ci->u.c.k = k) != NULL)  /* is there a continuation? */\n      ci->u.c.ctx = ctx;  /* save context */\n    luaD_throw(L, LUA_YIELD);\n  }\n  lua_assert(ci->callstatus & CIST_HOOKED);  /* must be inside a hook */\n  lua_unlock(L);\n  return 0;  /* return to 'luaD_hook' */\n}\n\n\n/*\n** Auxiliary structure to call 'luaF_close' in protected mode.\n*/\nstruct CloseP {\n  StkId level;\n  int status;\n};\n\n\n/*\n** Auxiliary function to call 'luaF_close' in protected mode.\n*/\nstatic void closepaux (lua_State *L, void *ud) {\n  struct CloseP *pcl = cast(struct CloseP *, ud);\n  luaF_close(L, pcl->level, pcl->status, 0);\n}\n\n\n/*\n** Calls 'luaF_close' in protected mode. Return the original status\n** or, in case of errors, the new status.\n*/\nint luaD_closeprotected (lua_State *L, ptrdiff_t level, int status) {\n  CallInfo *old_ci = L->ci;\n  lu_byte old_allowhooks = L->allowhook;\n  for (;;) {  /* keep closing upvalues until no more errors */\n    struct CloseP pcl;\n    pcl.level = restorestack(L, level); pcl.status = status;\n    status = luaD_rawrunprotected(L, &closepaux, &pcl);\n    if (l_likely(status == LUA_OK))  /* no more errors? */\n      return pcl.status;\n    else {  /* an error occurred; restore saved state and repeat */\n      L->ci = old_ci;\n      L->allowhook = old_allowhooks;\n    }\n  }\n}\n\n\n/*\n** Call the C function 'func' in protected mode, restoring basic\n** thread information ('allowhook', etc.) and in particular\n** its stack level in case of errors.\n*/\nint luaD_pcall (lua_State *L, Pfunc func, void *u,\n                ptrdiff_t old_top, ptrdiff_t ef) {\n  int status;\n  CallInfo *old_ci = L->ci;\n  lu_byte old_allowhooks = L->allowhook;\n  ptrdiff_t old_errfunc = L->errfunc;\n  L->errfunc = ef;\n  status = luaD_rawrunprotected(L, func, u);\n  if (l_unlikely(status != LUA_OK)) {  /* an error occurred? */\n    L->ci = old_ci;\n    L->allowhook = old_allowhooks;\n    status = luaD_closeprotected(L, old_top, status);\n    luaD_seterrorobj(L, status, restorestack(L, old_top));\n    luaD_shrinkstack(L);   /* restore stack size in case of overflow */\n  }\n  L->errfunc = old_errfunc;\n  return status;\n}\n\n\n\n/*\n** Execute a protected parser.\n*/\nstruct SParser {  /* data to 'f_parser' */\n  ZIO *z;\n  Mbuffer buff;  /* dynamic structure used by the scanner */\n  Dyndata dyd;  /* dynamic structures used by the parser */\n  const char *mode;\n  const char *name;\n};\n\n\nstatic void checkmode (lua_State *L, const char *mode, const char *x) {\n  if (mode && strchr(mode, x[0]) == NULL) {\n    luaO_pushfstring(L,\n       \"attempt to load a %s chunk (mode is '%s')\", x, mode);\n    luaD_throw(L, LUA_ERRSYNTAX);\n  }\n}\n\n\nstatic void f_parser (lua_State *L, void *ud) {\n  LClosure *cl;\n  struct SParser *p = cast(struct SParser *, ud);\n  int c = zgetc(p->z);  /* read first character */\n  if (c == LUA_SIGNATURE[0]) {\n    checkmode(L, p->mode, \"binary\");\n    cl = luaU_undump(L, p->z, p->name);\n  }\n  else {\n    checkmode(L, p->mode, \"text\");\n    cl = luaY_parser(L, p->z, &p->buff, &p->dyd, p->name, c);\n  }\n  lua_assert(cl->nupvalues == cl->p->sizeupvalues);\n  luaF_initupvals(L, cl);\n}\n\n\nint luaD_protectedparser (lua_State *L, ZIO *z, const char *name,\n                                        const char *mode) {\n  struct SParser p;\n  int status;\n  incnny(L);  /* cannot yield during parsing */\n  p.z = z; p.name = name; p.mode = mode;\n  p.dyd.actvar.arr = NULL; p.dyd.actvar.size = 0;\n  p.dyd.gt.arr = NULL; p.dyd.gt.size = 0;\n  p.dyd.label.arr = NULL; p.dyd.label.size = 0;\n  luaZ_initbuffer(L, &p.buff);\n  status = luaD_pcall(L, f_parser, &p, savestack(L, L->top), L->errfunc);\n  luaZ_freebuffer(L, &p.buff);\n  luaM_freearray(L, p.dyd.actvar.arr, p.dyd.actvar.size);\n  luaM_freearray(L, p.dyd.gt.arr, p.dyd.gt.size);\n  luaM_freearray(L, p.dyd.label.arr, p.dyd.label.size);\n  decnny(L);\n  return status;\n}\n\n\n"], "filenames": ["ldo.c"], "buggy_code_start_loc": [532], "buggy_code_end_loc": [537], "fixing_code_start_loc": [533], "fixing_code_end_loc": [536], "type": "CWE-787", "message": "In Lua 5.4.3, an erroneous finalizer called during a tail call leads to a heap-based buffer over-read.", "other": {"cve": {"id": "CVE-2021-45985", "sourceIdentifier": "cve@mitre.org", "published": "2023-04-10T09:15:07.250", "lastModified": "2023-04-14T03:51:34.040", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In Lua 5.4.3, an erroneous finalizer called during a tail call leads to a heap-based buffer over-read."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:lua:lua:5.4.3:*:*:*:*:*:*:*", "matchCriteriaId": "9255844F-00EF-4D50-9292-3A12FD1FB3A7"}]}]}], "references": [{"url": "http://lua-users.org/lists/lua-l/2021-12/msg00019.html", "source": "cve@mitre.org", "tags": ["Exploit", "Mailing List", "Vendor Advisory"]}, {"url": "https://github.com/lua/lua/commit/cf613cdc6fa367257fc61c256f63d917350858b5", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://www.lua.org/bugs.html#5.4.3-11", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/lua/lua/commit/cf613cdc6fa367257fc61c256f63d917350858b5"}}