{"buggy_code": ["/* Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n// See docs in ../ops/io_ops.cc.\n\n#include <string>\n#include <vector>\n\n#include \"tensorflow/core/framework/bounds_check.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/framework/types.pb.h\"\n#include \"tensorflow/core/kernels/save_restore_tensor.h\"\n#include \"tensorflow/core/lib/core/status.h\"\n#include \"tensorflow/core/lib/io/path.h\"\n#include \"tensorflow/core/platform/env.h\"\n#include \"tensorflow/core/platform/logging.h\"\n#include \"tensorflow/core/platform/types.h\"\n#include \"tensorflow/core/util/saved_tensor_slice_util.h\"\n#include \"tensorflow/core/util/tensor_bundle/tensor_bundle.h\"\n#include \"tensorflow/core/util/tensor_slice_reader.h\"\n\nnamespace tensorflow {\n\nnamespace {\n\n// Shared validations of the inputs to the SaveV2 and RestoreV2 ops.\nvoid ValidateInputs(bool is_save_op, OpKernelContext* context,\n                    const Tensor& prefix, const Tensor& tensor_names,\n                    const Tensor& shape_and_slices) {\n  const int kFixedInputs = 3;  // Prefix, tensor names, shape_and_slices.\n  const int num_tensors = static_cast<int>(tensor_names.NumElements());\n  OP_REQUIRES(\n      context, prefix.NumElements() == 1,\n      errors::InvalidArgument(\"Input prefix should have a single element, got \",\n                              prefix.NumElements(), \" instead.\"));\n  OP_REQUIRES(context,\n              TensorShapeUtils::IsVector(tensor_names.shape()) &&\n                  TensorShapeUtils::IsVector(shape_and_slices.shape()),\n              errors::InvalidArgument(\n                  \"Input tensor_names and shape_and_slices \"\n                  \"should be an 1-D tensors, got \",\n                  tensor_names.shape().DebugString(), \" and \",\n                  shape_and_slices.shape().DebugString(), \" instead.\"));\n  OP_REQUIRES(context,\n              tensor_names.NumElements() == shape_and_slices.NumElements(),\n              errors::InvalidArgument(\"tensor_names and shape_and_slices \"\n                                      \"have different number of elements: \",\n                                      tensor_names.NumElements(), \" vs. \",\n                                      shape_and_slices.NumElements()));\n  OP_REQUIRES(context,\n              FastBoundsCheck(tensor_names.NumElements() + kFixedInputs,\n                              std::numeric_limits<int>::max()),\n              errors::InvalidArgument(\"Too many inputs to the op\"));\n  OP_REQUIRES(\n      context, shape_and_slices.NumElements() == num_tensors,\n      errors::InvalidArgument(\"Expected \", num_tensors,\n                              \" elements in shapes_and_slices, but got \",\n                              context->input(2).NumElements()));\n  if (is_save_op) {\n    OP_REQUIRES(context, context->num_inputs() == num_tensors + kFixedInputs,\n                errors::InvalidArgument(\n                    \"Got \", num_tensors, \" tensor names but \",\n                    context->num_inputs() - kFixedInputs, \" tensors.\"));\n    OP_REQUIRES(context, context->num_inputs() == num_tensors + kFixedInputs,\n                errors::InvalidArgument(\n                    \"Expected a total of \", num_tensors + kFixedInputs,\n                    \" inputs as input #1 (which is a string \"\n                    \"tensor of saved names) contains \",\n                    num_tensors, \" names, but received \", context->num_inputs(),\n                    \" inputs\"));\n  }\n}\n\n}  // namespace\n\n// Saves a list of named tensors using the tensor bundle library.\nclass SaveV2 : public OpKernel {\n public:\n  explicit SaveV2(OpKernelConstruction* context) : OpKernel(context) {}\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& prefix = context->input(0);\n    const Tensor& tensor_names = context->input(1);\n    const Tensor& shape_and_slices = context->input(2);\n    ValidateInputs(true /* is save op */, context, prefix, tensor_names,\n                   shape_and_slices);\n\n    const int kFixedInputs = 3;  // Prefix, tensor names, shape_and_slices.\n    const int num_tensors = static_cast<int>(tensor_names.NumElements());\n    const string& prefix_string = prefix.scalar<tstring>()();\n    const auto& tensor_names_flat = tensor_names.flat<tstring>();\n    const auto& shape_and_slices_flat = shape_and_slices.flat<tstring>();\n\n    BundleWriter writer(Env::Default(), prefix_string);\n    OP_REQUIRES_OK(context, writer.status());\n    VLOG(1) << \"BundleWriter, prefix_string: \" << prefix_string;\n\n    for (int i = 0; i < num_tensors; ++i) {\n      const string& tensor_name = tensor_names_flat(i);\n      const Tensor& tensor = context->input(i + kFixedInputs);\n      VLOG(2) << \"Starting save of \" << tensor_name;\n\n      if (!shape_and_slices_flat(i).empty()) {\n        const string& shape_spec = shape_and_slices_flat(i);\n        TensorShape shape;\n        TensorSlice slice(tensor.dims());\n        TensorShape slice_shape;\n\n        OP_REQUIRES_OK(context, checkpoint::ParseShapeAndSlice(\n                                    shape_spec, &shape, &slice, &slice_shape));\n        OP_REQUIRES(context, slice_shape.IsSameSize(tensor.shape()),\n                    errors::InvalidArgument(\"Slice in shape_and_slice \"\n                                            \"specification does not match the \"\n                                            \"shape of the tensor to  save: \",\n                                            shape_spec, \", tensor: \",\n                                            tensor.shape().DebugString()));\n\n        OP_REQUIRES_OK(context,\n                       writer.AddSlice(tensor_name, shape, slice, tensor));\n      } else {\n        OP_REQUIRES_OK(context, writer.Add(tensor_name, tensor));\n      }\n\n      if (VLOG_IS_ON(5)) {\n        if (tensor.dtype() == DT_FLOAT) {\n          const float* t_data = tensor.flat<float>().data();\n          float min = std::numeric_limits<float>::infinity();\n          float max = -std::numeric_limits<float>::infinity();\n          double avg = 0.0;\n          for (int i = 0; i < tensor.NumElements(); ++i) {\n            if (t_data[i] < min) min = t_data[i];\n            if (t_data[i] > max) max = t_data[i];\n            avg += t_data[i];\n          }\n          VLOG(5) << \" min \" << min << \" max \" << max << \" avg \"\n                  << avg / tensor.NumElements() << \" total elts \"\n                  << tensor.NumElements();\n        }\n      }\n\n      VLOG(2) << \"Done save of \" << tensor_name;\n    }\n    OP_REQUIRES_OK(context, writer.Finish());\n    VLOG(1) << \"Done BundleWriter, prefix_string: \" << prefix_string;\n  }\n};\nREGISTER_KERNEL_BUILDER(Name(\"SaveV2\").Device(DEVICE_CPU), SaveV2);\n\n// Restores a list of named tensors from a tensor bundle (V2 checkpoint format).\nclass RestoreV2 : public OpKernel {\n public:\n  explicit RestoreV2(OpKernelConstruction* context) : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"dtypes\", &dtypes_));\n  }\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& prefix = context->input(0);\n    const Tensor& tensor_names = context->input(1);\n    const Tensor& shape_and_slices = context->input(2);\n    OP_REQUIRES(context, tensor_names.NumElements() == dtypes_.size(),\n                errors::InvalidArgument(\"Got \", tensor_names.NumElements(),\n                                        \" tensor names, but \", dtypes_.size(),\n                                        \" expected dtypes.\"));\n    ValidateInputs(false /* not save op */, context, prefix, tensor_names,\n                   shape_and_slices);\n\n    const string& prefix_string = prefix.scalar<tstring>()();\n\n    // Intention: we plan to use the RestoreV2 op as a backward-compatible\n    // reader as we upgrade to the V2 format.  This allows transparent upgrade.\n    // We here attempt to read a V1 checkpoint, if \"prefix_string\" does not\n    // refer to a V2 checkpoint.\n    Env* env = Env::Default();\n    std::vector<string> paths;\n    if (!env->GetMatchingPaths(MetaFilename(prefix_string), &paths).ok() ||\n        paths.empty()) {\n      // Cannot find V2's metadata file, so \"prefix_string\" does not point to a\n      // V2 checkpoint.  Invokes the V1 read path instead.\n      for (size_t i = 0; i < tensor_names.NumElements(); ++i) {\n        RestoreTensor(context, &checkpoint::OpenTableTensorSliceReader,\n                      /* preferred_shard */ -1, /* restore_slice */ true,\n                      /* restore_index */ i);\n        if (!context->status().ok()) {\n          return;\n        }\n      }\n      return;\n    }\n    // If found, invokes the V2 reader.\n    OP_REQUIRES_OK(context, RestoreTensorsV2(context, prefix, tensor_names,\n                                             shape_and_slices, dtypes_));\n  }\n\n private:\n  // Expected dtypes of the to-restore tensors.\n  std::vector<DataType> dtypes_;\n};\nREGISTER_KERNEL_BUILDER(Name(\"RestoreV2\").Device(DEVICE_CPU), RestoreV2);\n\n// The final step in saving sharded V2 checkpoints: merges metadata files.\nclass MergeV2Checkpoints : public OpKernel {\n public:\n  explicit MergeV2Checkpoints(OpKernelConstruction* context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context,\n                   context->GetAttr(\"delete_old_dirs\", &delete_old_dirs_));\n  }\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& checkpoint_prefixes = context->input(0);\n    const Tensor& destination_prefix = context->input(1);\n    OP_REQUIRES(context,\n                TensorShapeUtils::IsVector(checkpoint_prefixes.shape()),\n                errors::InvalidArgument(\n                    \"Input checkpoint_prefixes should be an 1-D tensor, got \",\n                    checkpoint_prefixes.shape().DebugString(), \" instead.\"));\n    OP_REQUIRES(context, TensorShapeUtils::IsScalar(destination_prefix.shape()),\n                errors::InvalidArgument(\n                    \"Input destination_prefix should be a scalar tensor, got \",\n                    destination_prefix.shape().DebugString(), \" instead.\"));\n\n    const gtl::ArraySlice<tstring> input_prefixes =\n        gtl::ArraySlice<tstring>(checkpoint_prefixes.flat<tstring>());\n    Env* env = Env::Default();\n    const string& merged_prefix = destination_prefix.scalar<tstring>()();\n    OP_REQUIRES_OK(\n        context, tensorflow::MergeBundles(env, input_prefixes, merged_prefix));\n\n    if (delete_old_dirs_) {\n      const string merged_dir(io::Dirname(merged_prefix));\n      for (const string& input_prefix : input_prefixes) {\n        const string dirname(io::Dirname(input_prefix));\n        if (dirname == merged_dir) continue;\n        Status status = env->DeleteDir(dirname);\n        // For sharded save, only the first delete will go through and all\n        // others will hit NotFound.  Use vlog to be less verbose.\n        if (!status.ok()) VLOG(1) << status;\n      }\n    }\n  }\n\n private:\n  // On merge, whether or not to delete the input (temporary) directories.\n  bool delete_old_dirs_;\n};\nREGISTER_KERNEL_BUILDER(Name(\"MergeV2Checkpoints\").Device(DEVICE_CPU),\n                        MergeV2Checkpoints);\n\n}  // namespace tensorflow\n"], "fixing_code": ["/* Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n// See docs in ../ops/io_ops.cc.\n\n#include <string>\n#include <vector>\n\n#include \"tensorflow/core/framework/bounds_check.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/framework/types.pb.h\"\n#include \"tensorflow/core/kernels/save_restore_tensor.h\"\n#include \"tensorflow/core/lib/core/status.h\"\n#include \"tensorflow/core/lib/io/path.h\"\n#include \"tensorflow/core/platform/env.h\"\n#include \"tensorflow/core/platform/logging.h\"\n#include \"tensorflow/core/platform/types.h\"\n#include \"tensorflow/core/util/saved_tensor_slice_util.h\"\n#include \"tensorflow/core/util/tensor_bundle/tensor_bundle.h\"\n#include \"tensorflow/core/util/tensor_slice_reader.h\"\n\nnamespace tensorflow {\n\nnamespace {\n\n// Shared validations of the inputs to the SaveV2 and RestoreV2 ops.\nvoid ValidateInputs(bool is_save_op, OpKernelContext* context,\n                    const Tensor& prefix, const Tensor& tensor_names,\n                    const Tensor& shape_and_slices) {\n  const int kFixedInputs = 3;  // Prefix, tensor names, shape_and_slices.\n  const int num_tensors = static_cast<int>(tensor_names.NumElements());\n  OP_REQUIRES(\n      context, prefix.NumElements() == 1,\n      errors::InvalidArgument(\"Input prefix should have a single element, got \",\n                              prefix.NumElements(), \" instead.\"));\n  OP_REQUIRES(context,\n              TensorShapeUtils::IsVector(tensor_names.shape()) &&\n                  TensorShapeUtils::IsVector(shape_and_slices.shape()),\n              errors::InvalidArgument(\n                  \"Input tensor_names and shape_and_slices \"\n                  \"should be an 1-D tensors, got \",\n                  tensor_names.shape().DebugString(), \" and \",\n                  shape_and_slices.shape().DebugString(), \" instead.\"));\n  OP_REQUIRES(context,\n              tensor_names.NumElements() == shape_and_slices.NumElements(),\n              errors::InvalidArgument(\"tensor_names and shape_and_slices \"\n                                      \"have different number of elements: \",\n                                      tensor_names.NumElements(), \" vs. \",\n                                      shape_and_slices.NumElements()));\n  OP_REQUIRES(context,\n              FastBoundsCheck(tensor_names.NumElements() + kFixedInputs,\n                              std::numeric_limits<int>::max()),\n              errors::InvalidArgument(\"Too many inputs to the op\"));\n  OP_REQUIRES(\n      context, shape_and_slices.NumElements() == num_tensors,\n      errors::InvalidArgument(\"Expected \", num_tensors,\n                              \" elements in shapes_and_slices, but got \",\n                              context->input(2).NumElements()));\n  if (is_save_op) {\n    OP_REQUIRES(context, context->num_inputs() == num_tensors + kFixedInputs,\n                errors::InvalidArgument(\n                    \"Got \", num_tensors, \" tensor names but \",\n                    context->num_inputs() - kFixedInputs, \" tensors.\"));\n    OP_REQUIRES(context, context->num_inputs() == num_tensors + kFixedInputs,\n                errors::InvalidArgument(\n                    \"Expected a total of \", num_tensors + kFixedInputs,\n                    \" inputs as input #1 (which is a string \"\n                    \"tensor of saved names) contains \",\n                    num_tensors, \" names, but received \", context->num_inputs(),\n                    \" inputs\"));\n  }\n}\n\n}  // namespace\n\n// Saves a list of named tensors using the tensor bundle library.\nclass SaveV2 : public OpKernel {\n public:\n  explicit SaveV2(OpKernelConstruction* context) : OpKernel(context) {}\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& prefix = context->input(0);\n    const Tensor& tensor_names = context->input(1);\n    const Tensor& shape_and_slices = context->input(2);\n    ValidateInputs(true /* is save op */, context, prefix, tensor_names,\n                   shape_and_slices);\n    if (!context->status().ok()) return;\n\n    const int kFixedInputs = 3;  // Prefix, tensor names, shape_and_slices.\n    const int num_tensors = static_cast<int>(tensor_names.NumElements());\n    const string& prefix_string = prefix.scalar<tstring>()();\n    const auto& tensor_names_flat = tensor_names.flat<tstring>();\n    const auto& shape_and_slices_flat = shape_and_slices.flat<tstring>();\n\n    BundleWriter writer(Env::Default(), prefix_string);\n    OP_REQUIRES_OK(context, writer.status());\n    VLOG(1) << \"BundleWriter, prefix_string: \" << prefix_string;\n\n    for (int i = 0; i < num_tensors; ++i) {\n      const string& tensor_name = tensor_names_flat(i);\n      const Tensor& tensor = context->input(i + kFixedInputs);\n      VLOG(2) << \"Starting save of \" << tensor_name;\n\n      if (!shape_and_slices_flat(i).empty()) {\n        const string& shape_spec = shape_and_slices_flat(i);\n        TensorShape shape;\n        TensorSlice slice(tensor.dims());\n        TensorShape slice_shape;\n\n        OP_REQUIRES_OK(context, checkpoint::ParseShapeAndSlice(\n                                    shape_spec, &shape, &slice, &slice_shape));\n        OP_REQUIRES(context, slice_shape.IsSameSize(tensor.shape()),\n                    errors::InvalidArgument(\"Slice in shape_and_slice \"\n                                            \"specification does not match the \"\n                                            \"shape of the tensor to  save: \",\n                                            shape_spec, \", tensor: \",\n                                            tensor.shape().DebugString()));\n\n        OP_REQUIRES_OK(context,\n                       writer.AddSlice(tensor_name, shape, slice, tensor));\n      } else {\n        OP_REQUIRES_OK(context, writer.Add(tensor_name, tensor));\n      }\n\n      if (VLOG_IS_ON(5)) {\n        if (tensor.dtype() == DT_FLOAT) {\n          const float* t_data = tensor.flat<float>().data();\n          float min = std::numeric_limits<float>::infinity();\n          float max = -std::numeric_limits<float>::infinity();\n          double avg = 0.0;\n          for (int i = 0; i < tensor.NumElements(); ++i) {\n            if (t_data[i] < min) min = t_data[i];\n            if (t_data[i] > max) max = t_data[i];\n            avg += t_data[i];\n          }\n          VLOG(5) << \" min \" << min << \" max \" << max << \" avg \"\n                  << avg / tensor.NumElements() << \" total elts \"\n                  << tensor.NumElements();\n        }\n      }\n\n      VLOG(2) << \"Done save of \" << tensor_name;\n    }\n    OP_REQUIRES_OK(context, writer.Finish());\n    VLOG(1) << \"Done BundleWriter, prefix_string: \" << prefix_string;\n  }\n};\nREGISTER_KERNEL_BUILDER(Name(\"SaveV2\").Device(DEVICE_CPU), SaveV2);\n\n// Restores a list of named tensors from a tensor bundle (V2 checkpoint format).\nclass RestoreV2 : public OpKernel {\n public:\n  explicit RestoreV2(OpKernelConstruction* context) : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"dtypes\", &dtypes_));\n  }\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& prefix = context->input(0);\n    const Tensor& tensor_names = context->input(1);\n    const Tensor& shape_and_slices = context->input(2);\n    OP_REQUIRES(context, tensor_names.NumElements() == dtypes_.size(),\n                errors::InvalidArgument(\"Got \", tensor_names.NumElements(),\n                                        \" tensor names, but \", dtypes_.size(),\n                                        \" expected dtypes.\"));\n    ValidateInputs(false /* not save op */, context, prefix, tensor_names,\n                   shape_and_slices);\n    if (!context->status().ok()) return;\n\n    const string& prefix_string = prefix.scalar<tstring>()();\n\n    // Intention: we plan to use the RestoreV2 op as a backward-compatible\n    // reader as we upgrade to the V2 format.  This allows transparent upgrade.\n    // We here attempt to read a V1 checkpoint, if \"prefix_string\" does not\n    // refer to a V2 checkpoint.\n    Env* env = Env::Default();\n    std::vector<string> paths;\n    if (!env->GetMatchingPaths(MetaFilename(prefix_string), &paths).ok() ||\n        paths.empty()) {\n      // Cannot find V2's metadata file, so \"prefix_string\" does not point to a\n      // V2 checkpoint.  Invokes the V1 read path instead.\n      for (size_t i = 0; i < tensor_names.NumElements(); ++i) {\n        RestoreTensor(context, &checkpoint::OpenTableTensorSliceReader,\n                      /* preferred_shard */ -1, /* restore_slice */ true,\n                      /* restore_index */ i);\n        if (!context->status().ok()) {\n          return;\n        }\n      }\n      return;\n    }\n    // If found, invokes the V2 reader.\n    OP_REQUIRES_OK(context, RestoreTensorsV2(context, prefix, tensor_names,\n                                             shape_and_slices, dtypes_));\n  }\n\n private:\n  // Expected dtypes of the to-restore tensors.\n  std::vector<DataType> dtypes_;\n};\nREGISTER_KERNEL_BUILDER(Name(\"RestoreV2\").Device(DEVICE_CPU), RestoreV2);\n\n// The final step in saving sharded V2 checkpoints: merges metadata files.\nclass MergeV2Checkpoints : public OpKernel {\n public:\n  explicit MergeV2Checkpoints(OpKernelConstruction* context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context,\n                   context->GetAttr(\"delete_old_dirs\", &delete_old_dirs_));\n  }\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& checkpoint_prefixes = context->input(0);\n    const Tensor& destination_prefix = context->input(1);\n    OP_REQUIRES(context,\n                TensorShapeUtils::IsVector(checkpoint_prefixes.shape()),\n                errors::InvalidArgument(\n                    \"Input checkpoint_prefixes should be an 1-D tensor, got \",\n                    checkpoint_prefixes.shape().DebugString(), \" instead.\"));\n    OP_REQUIRES(context, TensorShapeUtils::IsScalar(destination_prefix.shape()),\n                errors::InvalidArgument(\n                    \"Input destination_prefix should be a scalar tensor, got \",\n                    destination_prefix.shape().DebugString(), \" instead.\"));\n\n    const gtl::ArraySlice<tstring> input_prefixes =\n        gtl::ArraySlice<tstring>(checkpoint_prefixes.flat<tstring>());\n    Env* env = Env::Default();\n    const string& merged_prefix = destination_prefix.scalar<tstring>()();\n    OP_REQUIRES_OK(\n        context, tensorflow::MergeBundles(env, input_prefixes, merged_prefix));\n\n    if (delete_old_dirs_) {\n      const string merged_dir(io::Dirname(merged_prefix));\n      for (const string& input_prefix : input_prefixes) {\n        const string dirname(io::Dirname(input_prefix));\n        if (dirname == merged_dir) continue;\n        Status status = env->DeleteDir(dirname);\n        // For sharded save, only the first delete will go through and all\n        // others will hit NotFound.  Use vlog to be less verbose.\n        if (!status.ok()) VLOG(1) << status;\n      }\n    }\n  }\n\n private:\n  // On merge, whether or not to delete the input (temporary) directories.\n  bool delete_old_dirs_;\n};\nREGISTER_KERNEL_BUILDER(Name(\"MergeV2Checkpoints\").Device(DEVICE_CPU),\n                        MergeV2Checkpoints);\n\n}  // namespace tensorflow\n"], "filenames": ["tensorflow/core/kernels/save_restore_v2_ops.cc"], "buggy_code_start_loc": [100], "buggy_code_end_loc": [179], "fixing_code_start_loc": [101], "fixing_code_end_loc": [182], "type": "CWE-476", "message": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the code for `tf.raw_ops.SaveV2` does not properly validate the inputs and an attacker can trigger a null pointer dereference. The [implementation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/save_restore_v2_ops.cc) uses `ValidateInputs` to check that the input arguments are valid. This validation would have caught the illegal state represented by the reproducer above. However, the validation uses `OP_REQUIRES` which translates to setting the `Status` object of the current `OpKernelContext` to an error status, followed by an empty `return` statement which just terminates the execution of the function it is present in. However, this does not mean that the kernel execution is finalized: instead, execution continues from the next line in `Compute` that follows the call to `ValidateInputs`. This is equivalent to lacking the validation. We have patched the issue in GitHub commit 9728c60e136912a12d99ca56e106b7cce7af5986. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.", "other": {"cve": {"id": "CVE-2021-37648", "sourceIdentifier": "security-advisories@github.com", "published": "2021-08-12T22:15:08.027", "lastModified": "2021-08-18T20:57:02.080", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the code for `tf.raw_ops.SaveV2` does not properly validate the inputs and an attacker can trigger a null pointer dereference. The [implementation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/save_restore_v2_ops.cc) uses `ValidateInputs` to check that the input arguments are valid. This validation would have caught the illegal state represented by the reproducer above. However, the validation uses `OP_REQUIRES` which translates to setting the `Status` object of the current `OpKernelContext` to an error status, followed by an empty `return` statement which just terminates the execution of the function it is present in. However, this does not mean that the kernel execution is finalized: instead, execution continues from the next line in `Compute` that follows the call to `ValidateInputs`. This is equivalent to lacking the validation. We have patched the issue in GitHub commit 9728c60e136912a12d99ca56e106b7cce7af5986. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range."}, {"lang": "es", "value": "TensorFlow es una plataforma de c\u00f3digo abierto de extremo a extremo para el aprendizaje autom\u00e1tico. En las versiones afectadas el c\u00f3digo para \"tf.raw_ops.SaveV2\" no comprueba correctamente las entradas y un atacante puede desencadenar una desreferencia de puntero null. La [implementaci\u00f3n](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/save_restore_v2_ops.cc) usa \"ValidateInputs\" para comprobar que los argumentos de entrada son v\u00e1lidos. Esta comprobaci\u00f3n habr\u00eda comprendido el estado ilegal representado por el reproductor anterior. Sin embargo, la comprobaci\u00f3n usa \"OP_REQUIRES\" que se traduce en establecer el objeto \"Status\" del actual \"OpKernelContext\" a un estado de error, seguido de una sentencia \"return\" vac\u00eda que simplemente termina la ejecuci\u00f3n de la funci\u00f3n en la que est\u00e1 presente. Sin embargo, esto no significa que la ejecuci\u00f3n del kernel haya finalizado: en su lugar, la ejecuci\u00f3n contin\u00faa a partir de la siguiente l\u00ednea en \"Compute\" que sigue a la llamada a \"ValidateInputs\". Esto equivale a que la comprobaci\u00f3n no se lleve a cabo. Hemos parcheado el problema en el commit 9728c60e136912a12d99ca56e106b7cce7af5986 de GitHub. La correcci\u00f3n ser\u00e1 incluida en TensorFlow versi\u00f3n 2.6.0. Tambi\u00e9n seleccionaremos este commit en TensorFlow versi\u00f3n 2.5.1, TensorFlow versi\u00f3n 2.4.3 y TensorFlow versi\u00f3n 2.3.4, ya que estos tambi\u00e9n est\u00e1n afectados y todav\u00eda est\u00e1n en el rango de soporte."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.6}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.3.0", "versionEndExcluding": "2.3.4", "matchCriteriaId": "0F83C081-51CC-415F-A8C0-0A44C75E2CD6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.4.0", "versionEndExcluding": "2.4.3", "matchCriteriaId": "BD3F2BF8-EBA9-42BF-8F9B-D918B880B15A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.5.0:*:*:*:*:*:*:*", "matchCriteriaId": "D03E99A7-4E3D-427D-A156-C0713E9FB02A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.6.0:rc0:*:*:*:*:*:*", "matchCriteriaId": "70FA6E48-6C57-40CA-809F-4E3D07CBF348"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.6.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "42187561-E491-434D-828C-F36701446634"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.6.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "C66B61C8-450A-4C5E-9174-F970D6DEE778"}]}]}], "references": [{"url": "https://github.com/tensorflow/tensorflow/commit/9728c60e136912a12d99ca56e106b7cce7af5986", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/security/advisories/GHSA-wp77-4gmm-7cq8", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/tensorflow/tensorflow/commit/9728c60e136912a12d99ca56e106b7cce7af5986"}}