{"buggy_code": ["/* \n * Copyright 2014, 2015, 2016 Internet Corporation for Assigned Names and Numbers.\n * \n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, you can obtain one at https://mozilla.org/MPL/2.0/.\n */\n\n/*\n * Developed by Sinodun IT (www.sinodun.com)\n */\n\n/* \n * File:   xml_files.cpp\n */\n\n#define BOOST_FILESYSTEM_NO_DEPRECATED\n\n#include <exception>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <exception>\n#include <time.h>\n\n#include <boost/property_tree/ptree.hpp>\n#include <boost/property_tree/xml_parser.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem.hpp>\n\n#include <pqxx/pqxx>\n\n#include \"DSCIOManager.h\"\n#include \"DSCDataManager.h\"\n#include \"dsc_types.h\"\n#include \"DSCStrategyFactory.h\"\n\n#include \"config.h\"\n\nusing namespace std;\nnamespace bfs = boost::filesystem;\n\n// Helper function\n// Get current date/time, format is YYYY-MM-DD HH:mm:ss time-zone\nconst std::string currentDateTime() {\n\n    time_t     now = time(0);\n    struct tm  tstruct;\n    char       buf[80];\n    tstruct = *localtime(&now);\n    strftime(buf, sizeof(buf), \"%Y-%m-%d %X %Z\", &tstruct);\n\n    return buf;\n\n}\n\nvoid replace_string(std::string& str, const std::string& from, const std::string& to) {\n    if(from.empty())\n        return;\n    size_t start_pos = 0;\n    while((start_pos = str.find(from, start_pos)) != std::string::npos) {\n        str.replace(start_pos, from.length(), to);\n        start_pos += to.length(); // In case 'to' contains 'from', like replacing 'x' with 'yx'\n    }\n}\n\n\nDSCIOManager::DSCIOManager(const enum INPUT_OUTPUT input, const enum INPUT_OUTPUT output, const string& conn_string, const string& processing_start_date_string, bool rssac) {\n\n    input_ = input;\n    output_ = output;\n    conn_string_ = conn_string;\n    pg_db_conn_ = NULL;\n    pg_db_trans_ = NULL;\n    processing_start_date_ = NULL;\n    rssac_=rssac;\n\n    cout << endl << endl << \"----------------------- \" << currentDateTime() << \" ----------------------\" << endl;\n    // work out if we have a valid start date\n    struct tm p_start_date  = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NULL };\n    if ( ! processing_start_date_string.empty() ) {\n       cout << \"Processing start date defined as \" << processing_start_date_string << endl; \n       if ( strptime(processing_start_date_string.c_str(), \"%Y-%m-%d\", &p_start_date) != NULL ) {   \n                processing_start_date_ = new time_t(mktime(&p_start_date));\n                //cout << \"Time is: \" << p_start_date.tm_year << \" \" << p_start_date.tm_mon << \" \" << p_start_date.tm_mday << \" \" << p_start_date.tm_hour << \" \" << p_start_date.tm_min << \" \" << p_start_date.tm_sec << endl;   \n       } else {\n           cerr << \"Error: Invalid processing start date \\'\" << processing_start_date_string << \"\\' provided. Must be YYYY-MM-DD format. Exiting.\" << endl;\n           exit(1);\n       }\n    } \n}\n\nDSCIOManager::~DSCIOManager() {\n    \n    cout << \"----------------------- \" << currentDateTime() << \" -----------------------\" << endl << endl;\n    if ( processing_start_date_ != NULL ) {\n        delete processing_start_date_;\n    }\n}\n    \nint\nDSCIOManager::dsc_connect_pg_db() {\n    pg_db_conn_ = new pqxx::connection( conn_string_ );\n    if ( pg_db_conn_ == NULL ) {\n        cerr << \"Error connecting to database.\" << endl;\n        exit(1);\n    }\n    pg_db_conn_->activate();\n    \n    /* Check Database version */\n    int db_version = 0;\n    try {\n        pg_db_trans_ = new pqxx::work( *pg_db_conn_ );\n        if ( pg_db_trans_ == NULL ) {\n            cerr << \"Error starting transaction.\" << endl;\n            exit(1);\n        }\n        const pqxx::result R = pg_db_trans_->exec(\"select version from version;\");\n        pqxx::result::const_iterator row;\n        for (row = R.begin(); row != R.end(); ++row) {\n            row[\"version\"].to(db_version);\n        }\n        if ( db_version != DB_SCHEMA_VERSION ) {\n            cout << \"Database version is not supported. Expected: \" << DB_SCHEMA_VERSION << \" Found: \" << db_version << endl;\n            exit( EXIT_FAILURE);\n        }\n        if ( pg_db_trans_ != NULL ) {\n            pg_db_trans_->commit();\n            delete pg_db_trans_;\n            pg_db_trans_ = NULL;\n        }\n    }\n    catch ( pqxx::unique_violation & e )\n    {\n        cerr << \"Unique_violation error: \" << e.what() << endl;\n        exit( EXIT_FAILURE);\n    }\n    catch( runtime_error & e )\n    {\n        cerr << \"Runtime error: \" << e.what() << endl;\n        exit( EXIT_FAILURE );\n    }\n    catch( std::exception & e )\n    {\n        cerr << \"Exception: \" << e.what() << \" select version from version;\" << endl;\n        exit( EXIT_FAILURE );\n    }\n    catch( ... )\n    {\n        cerr << \"Unknown exception caught\" << endl;\n        exit( EXIT_FAILURE );\n    }\n    \n    return 0;\n\n}\n\nint\nDSCIOManager::dsc_disconnect_pg_db() {\n\n    pg_db_conn_->disconnect();\n    delete pg_db_conn_;\n    // TODO Errors\n    return 0;\n\n}\n\nvoid\nDSCIOManager::dsc_activate_ouput_destination() {\n\n    switch (output_) {\n        case DAT:\n            // Nothing to do\n            break;\n        case PG_DB:\n            dsc_connect_pg_db();\n            cout << \"*** Database connected\" << endl;\n            break;\n        default:\n            // Should never get here!\n            cerr << \"Error: Unknown output destination.\" << endl;\n            exit(1);\n            break;\n    }\n}\n\nvoid\nDSCIOManager::dsc_deactivate_ouput_destination() {\n    switch (output_) {\n        case DAT:\n            // Nothing to do\n            break;\n        case PG_DB:\n            dsc_disconnect_pg_db();\n            cout << \"*** Database disconnected\" << endl;\n            break;\n        default:\n            // Should never get here!\n            cerr << \"Error: Unknown output destination.\" << endl;\n            exit(1);\n            break;\n    }\n\n}\n\nvoid\nDSCIOManager::dsc_import_input_from_source() {\n\n    dsc_populate_files_vector();\n    int file_counter=file_vector_.size();\n    int file_failures = 0;\n    int file_commit_status = 0;  // status of transaction commit\n    int data_process_status = 0; // status of data processing\n    \n    string node = bfs::initial_path().filename().generic_string();\n    string server = bfs::initial_path().parent_path().filename().generic_string();\n    //transform to 'internal' name\n    replace(server.begin(), server.end(), '-', '_');\n    replace_string(server, \".\", \"__\");\n    transform(server.begin(), server.end(), server.begin(), ::tolower);\n    \n    cout << \"*** Processing server: \" << server << endl;\n    cout << \"*** Processing node:   \" << node << endl;\n    cout << \"*** Found:             \" << file_counter << \" \" <<  file_extension_ << \" files to process.\" << endl;\n    \n    for (std::vector<bfs::path>::const_iterator file_vector_it (file_vector_.begin()); file_vector_it != file_vector_.end(); ++file_vector_it) {\n        if ( pg_db_conn_ != NULL ) {\n            pg_db_trans_ = new pqxx::work( *pg_db_conn_ );\n            if ( pg_db_trans_ == NULL ) {\n                cerr << \"Error starting transaction.\" << endl;\n                exit(1);\n            }\n        }\n        cout << endl << currentDateTime() << \": Starting:  \" << (*file_vector_it).string() << endl;\n        DSCDataManager* dsc_data_manager = new DSCDataManager(server, node, pg_db_trans_);\n        file_commit_status = 0;\n        \n        switch (input_) {\n            case XML: {\n                // Partially read the xml. This is done using a policy tree,\n                // which uses rapidxml to do the parsing. There is no validation\n                // performed. Each array element is a \"data unit\" to send to the\n                // data manager load function.\n                dsc_xml_ = new boost::property_tree::ptree();\n                // If reading fails, exception is thrown.\n                try {\n                  boost::property_tree::read_xml((*file_vector_it).string(), *dsc_xml_);\n                  // We can't validate the XML but make this call the check that the file \n                  // at least has the correct top level node\n                  try {\n                    dsc_xml_->get_child(\"dscdata\");\n                  }\n                  catch( std::exception & e ) {\n                    cerr << \"Error: XML file has no content: \" << e.what() << endl;\n                    data_process_status = 1;\n                    break;\t\t\t\t\t\n                  }\n                }\n                catch( std::exception & e )\n                {\n                    cerr << \"Exception reading XML file: \" << e.what() << endl;\n                    data_process_status = 1;\n                    break;\n                }\n                catch( ... )\n                {\n                    cerr << \"Unknown exception caught\" << endl;\n                    data_process_status = 1;\n                    break;\n                }\n                // Get each array element and process it\n                BOOST_FOREACH(boost::property_tree::ptree::value_type &array_element, dsc_xml_->get_child(\"dscdata\")) {\n                    data_process_status = dsc_data_manager->load(array_element, rssac_);\n                    if (data_process_status) break;\n                    data_process_status = dsc_data_manager->process();\n                    if (data_process_status) break;\n                }\n                delete dsc_xml_;\n            }\n            break;\n            case DAT: {\n                // Call out to strategies to find out how this dat file \n                // needs to be processed.\n                // F1, F2 and F3a dat files contain multiple \"data units\"\n                vector<DSCStrategy*>::iterator strategy_it;\n                string name = (*file_vector_it).filename().string();\n                std::vector<DSCStrategy*> strategies_vector = DSCStrategyFactory::createStrategyDat(server, name);\n                bool multi;\n                \n                if (strategies_vector.size() != 1 ) { \n                    cerr << \"Error: Failed to find a single strategy for loading dat file \" << (*file_vector_it).string() << \" (found: \" << strategies_vector.size() << \")\" << endl;\n                    // exit(1);\n                    break;\n                }\n                \n                strategy_it = strategies_vector.begin();\n                multi = (*strategy_it)->is_dat_file_multi_unit();\n\n                if ( multi ) {\n                    // read the file one line at a time\n                    bfs::fstream dat_file;\n                    string dat_line;\n                    dat_file.open((*file_vector_it), ios_base::in);\n                    while (getline(dat_file, dat_line)) {\n                        if ( dsc_data_manager->load(dat_line, strategy_it) !=0 ) continue;\n                        data_process_status = dsc_data_manager->process(strategy_it);\n                        if (data_process_status) break;\n                    }\n                } else {\n                    // The entire file is one \"data unit\"\n                    dsc_data_manager->load((*file_vector_it), strategy_it);\n                    data_process_status = dsc_data_manager->process(strategy_it);\n                    if (data_process_status) break;\n                }\n            }\n            break;\n            default:\n                // Should never get here!\n                cerr << \"Error: Unknown input source\" << endl;\n                exit(1);\n        }\n        \n        if ( pg_db_trans_ != NULL ) {  \n                if ( data_process_status == 0 ) {\n                    try {\n                        pg_db_trans_->commit();\n                    }             \n                    catch( std::exception & e ) {\n                        cerr << \"Commit failed with exception message: \" << e.what() << endl;    \n                        file_commit_status = 1;             \n                    }\n                    catch( ... ) {\n                        cerr << \"Commit failed with general error\" << endl;\n                        file_commit_status = 1;\n                    }\n                }\n                // Tidy up. If the processing was not successful the transaction will implicitly rollback\n                delete pg_db_trans_;\n                pg_db_trans_ = NULL;         \n        }      \n        \n        delete dsc_data_manager;        \n        \n        // move the file to the done directory if all is well\n        if (file_commit_status == 0 && data_process_status == 0 ) {\n             dsc_move_file_to_done((*file_vector_it));        \n        } else {\n              dsc_handle_failed_file((*file_vector_it), data_process_status);\n            file_failures++;\n        }\n                \n        // Display helpful message. Flush to ensure that it is seen.\n        file_counter--;\n        cout << currentDateTime() << \": Completed: \" << setw(50) << left << (*file_vector_it).string() << \"\\t\" << file_counter << \" remaining (\" << file_failures << \" failures).\"<< endl;\n\n        std::flush(cout);\n    }\n    \n    // clear the file vector\n    file_vector_.clear();\n    \n    // endl since the previous cout used \\r\n    cout << endl;\n\n}\n\nvoid\nDSCIOManager::dsc_populate_files_vector() {\n    \n    std::string start_of_search_path;\n    switch (input_) {\n        case XML: \n            start_of_search_path = \"./incoming\";\n            file_extension_ = \".xml\";\n            break;\n        case DAT:\n            start_of_search_path = \".\";\n            file_extension_ = \".dat\";\n            break;\n        default:\n            // Should never get here!\n            cerr << \"Error: Unknown input source\" << endl;\n            exit(1);\n            break;\n    }\n    \n    bfs::path p_start (start_of_search_path);\n    bfs::path::iterator path_it;\n\n    // iterators for iterating over all the paths/files in the data directory\n    bfs::recursive_directory_iterator it(p_start), end_it;\n    try {\n        if (bfs::exists(p_start)) {\n            if (bfs::is_directory(p_start)) {\n                BOOST_FOREACH( bfs::path const &p_search, make_pair(it, end_it) ) {                 \n                    if ( p_search.string().find(\"done\") == string::npos ) {\n                        if ( ! bfs::is_directory(p_search) ) {\n                            if ( p_search.extension() == file_extension_ ) {\n                                if (! exclude_file(p_search, start_of_search_path) ) {\n                                        file_vector_.push_back(p_search);                                   \n                                }\n                            }\n                        }\n                    }\n                }\n                sort(file_vector_.begin(), file_vector_.end());\n            } else {\n                cout << p_start << \" exists, but is not a directory\\n\";\n                exit(1);\n            }\n        } else {\n            cout << p_start << \" does not exist\\n\";\n            exit(1);\n        }\n    }\n    catch (const bfs::filesystem_error& ex) {\n        cout << \"FS Error: \" << ex.what() << endl;\n        exit(1);\n    }\n    catch (std::exception &e) {\n        cerr << \"Error creating file vector: \" << e.what() << endl;\n        exit(1);\n    }\n    \n}\n\nvoid\nDSCIOManager::dsc_move_file_to_done(bfs::path path_src) {\n    \n    bfs::path path_done (\"./done\");\n    std::string done_sub_dir;\n    bfs::path path_date;\n    bfs::path path_done_date;\n    bfs::path path_newfile;\n    \n    try {\n        switch (input_) {\n            case XML: \n                done_sub_dir = \"dscdata\";\n                path_date = path_src.parent_path().stem(); //./incoming/yyyymmdd/*.xml --> yyyymmdd\n                break;\n            case DAT:\n                done_sub_dir = \"dat\";\n                path_date = path_src.parent_path().stem(); // ./yyyymmdd/*.dat --> yyyymmdd\n                break;\n            default:\n                // Should never get here!\n                cerr << \"Error: Unknown input source\" << endl;\n                exit(1);\n                break;\n        }\n        path_done_date = path_done/path_date/done_sub_dir;\n        if (!bfs::exists(path_done_date)) {\n                bfs::create_directories(path_done_date);\n        }\n        path_newfile = path_done_date/path_src.filename();\n        bfs::rename(path_src, path_newfile);\n        cout << currentDateTime() << \": Moved:     \" << path_src.string() << \" to \" <<  path_newfile.string() << endl;\n    }\n    catch (const bfs::filesystem_error& ex) {\n        cout << \"FS Error: \" << ex.what() << endl;\n        exit(1);\n    }\n    catch (std::exception &e) {\n        cerr << \"Error moving file to done: \" << e.what() << endl;\n        exit(1);\n    }\n \n}\n\nvoid\nDSCIOManager::dsc_handle_failed_file(bfs::path path_src, int process) {\n    \n    bfs::path path_newfile;  \n    std::string failed = \".failed.\";\n    std::string reason_string = process ? \" Failed to process data \" : \"Failed to commit data to DB\";\n    \n    try {\n        path_newfile = path_src.string() + failed + bfs::unique_path().string();\n        bfs::rename(path_src, path_newfile);\n        cout << currentDateTime() << \": Error: failed to process: \" << path_src.string() << \"Reason: \" << reason_string << endl;\n        cout << currentDateTime() << \": File renamed to:          \" << path_newfile.string() << endl;\n    }\n    catch (const bfs::filesystem_error& ex) {\n        cout << \"FS Error: \" << ex.what() << endl;\n        exit(1);\n    }\n    catch (std::exception &e) {\n        cerr << \"Error handling failed file: \" << e.what() << endl;\n        exit(1);\n    }\n \n}\n\nbool \nDSCIOManager::exclude_file(bfs::path path_src, const string& start_of_search_path) {\n\n    if ( input_ != XML || processing_start_date_ == NULL ) {\n        return false;\n    }\n\n    // Only do this test on files under './incoming'\n    if ( path_src.parent_path().parent_path().string().compare(start_of_search_path) == 0 ) {\n        struct tm tm  = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NULL };\n        if ( strptime(path_src.parent_path().filename().string().c_str(), \"%Y-%m-%d\", &tm) != NULL ) {\n            time_t dir_time = mktime(&tm);\n            //cout << \"Diff time is \" << difftime(*processing_start_date_, dir_time) << endl ;\n            if ( difftime(*processing_start_date_, dir_time) > 0 )  {\n                cout << \"File \" << path_src.string() << \" excluded from processing as it is earlier than the processing start date\" << endl;\n                return true;\n            } else {\n                return false;\n            }\n        }                     \n    }\n    return false;\n\n}"], "fixing_code": ["/* \n * Copyright 2014, 2015, 2016 Internet Corporation for Assigned Names and Numbers.\n * \n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, you can obtain one at https://mozilla.org/MPL/2.0/.\n */\n\n/*\n * Developed by Sinodun IT (www.sinodun.com)\n */\n\n/* \n * File:   xml_files.cpp\n */\n\n#define BOOST_FILESYSTEM_NO_DEPRECATED\n\n#include <exception>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <exception>\n#include <time.h>\n\n#include <boost/property_tree/ptree.hpp>\n#include <boost/property_tree/xml_parser.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem.hpp>\n\n#include <pqxx/pqxx>\n\n#include \"DSCIOManager.h\"\n#include \"DSCDataManager.h\"\n#include \"dsc_types.h\"\n#include \"DSCStrategyFactory.h\"\n\n#include \"config.h\"\n\nusing namespace std;\nnamespace bfs = boost::filesystem;\n\n// Helper function\n// Get current date/time, format is YYYY-MM-DD HH:mm:ss time-zone\nconst std::string currentDateTime() {\n\n    time_t     now = time(0);\n    struct tm  tstruct;\n    char       buf[80];\n    tstruct = *localtime(&now);\n    strftime(buf, sizeof(buf), \"%Y-%m-%d %X %Z\", &tstruct);\n\n    return buf;\n\n}\n\nvoid replace_string(std::string& str, const std::string& from, const std::string& to) {\n    if(from.empty())\n        return;\n    size_t start_pos = 0;\n    while((start_pos = str.find(from, start_pos)) != std::string::npos) {\n        str.replace(start_pos, from.length(), to);\n        start_pos += to.length(); // In case 'to' contains 'from', like replacing 'x' with 'yx'\n    }\n}\n\n\nDSCIOManager::DSCIOManager(const enum INPUT_OUTPUT input, const enum INPUT_OUTPUT output, const string& conn_string, const string& processing_start_date_string, bool rssac) {\n\n    input_ = input;\n    output_ = output;\n    conn_string_ = conn_string;\n    pg_db_conn_ = NULL;\n    pg_db_trans_ = NULL;\n    processing_start_date_ = NULL;\n    rssac_=rssac;\n\n    cout << endl << endl << \"----------------------- \" << currentDateTime() << \" ----------------------\" << endl;\n    // work out if we have a valid start date\n    struct tm p_start_date  = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NULL };\n    if ( ! processing_start_date_string.empty() ) {\n       cout << \"Processing start date defined as \" << processing_start_date_string << endl; \n       if ( strptime(processing_start_date_string.c_str(), \"%Y-%m-%d\", &p_start_date) != NULL ) {   \n                processing_start_date_ = new time_t(mktime(&p_start_date));\n                //cout << \"Time is: \" << p_start_date.tm_year << \" \" << p_start_date.tm_mon << \" \" << p_start_date.tm_mday << \" \" << p_start_date.tm_hour << \" \" << p_start_date.tm_min << \" \" << p_start_date.tm_sec << endl;   \n       } else {\n           cerr << \"Error: Invalid processing start date \\'\" << processing_start_date_string << \"\\' provided. Must be YYYY-MM-DD format. Exiting.\" << endl;\n           exit(1);\n       }\n    } \n}\n\nDSCIOManager::~DSCIOManager() {\n    \n    cout << \"----------------------- \" << currentDateTime() << \" -----------------------\" << endl << endl;\n    if ( processing_start_date_ != NULL ) {\n        delete processing_start_date_;\n    }\n}\n    \nint\nDSCIOManager::dsc_connect_pg_db() {\n    pg_db_conn_ = new pqxx::connection( conn_string_ );\n    if ( pg_db_conn_ == NULL ) {\n        cerr << \"Error connecting to database.\" << endl;\n        exit(1);\n    }\n    pg_db_conn_->activate();\n    \n    /* Check Database version */\n    int db_version = 0;\n    try {\n        pg_db_trans_ = new pqxx::work( *pg_db_conn_ );\n        if ( pg_db_trans_ == NULL ) {\n            cerr << \"Error starting transaction.\" << endl;\n            exit(1);\n        }\n        const pqxx::result R = pg_db_trans_->exec(\"select version from version;\");\n        pqxx::result::const_iterator row;\n        for (row = R.begin(); row != R.end(); ++row) {\n            row[\"version\"].to(db_version);\n        }\n        if ( db_version != DB_SCHEMA_VERSION ) {\n            cout << \"Database version is not supported. Expected: \" << DB_SCHEMA_VERSION << \" Found: \" << db_version << endl;\n            exit( EXIT_FAILURE);\n        }\n        if ( pg_db_trans_ != NULL ) {\n            pg_db_trans_->commit();\n            delete pg_db_trans_;\n            pg_db_trans_ = NULL;\n        }\n    }\n    catch ( pqxx::unique_violation & e )\n    {\n        cerr << \"Unique_violation error: \" << e.what() << endl;\n        exit( EXIT_FAILURE);\n    }\n    catch( runtime_error & e )\n    {\n        cerr << \"Runtime error: \" << e.what() << endl;\n        exit( EXIT_FAILURE );\n    }\n    catch( std::exception & e )\n    {\n        cerr << \"Exception: \" << e.what() << \" select version from version;\" << endl;\n        exit( EXIT_FAILURE );\n    }\n    catch( ... )\n    {\n        cerr << \"Unknown exception caught\" << endl;\n        exit( EXIT_FAILURE );\n    }\n    \n    return 0;\n\n}\n\nint\nDSCIOManager::dsc_disconnect_pg_db() {\n\n    pg_db_conn_->disconnect();\n    delete pg_db_conn_;\n    // TODO Errors\n    return 0;\n\n}\n\nvoid\nDSCIOManager::dsc_activate_ouput_destination() {\n\n    switch (output_) {\n        case DAT:\n            // Nothing to do\n            break;\n        case PG_DB:\n            dsc_connect_pg_db();\n            cout << \"*** Database connected\" << endl;\n            break;\n        default:\n            // Should never get here!\n            cerr << \"Error: Unknown output destination.\" << endl;\n            exit(1);\n            break;\n    }\n}\n\nvoid\nDSCIOManager::dsc_deactivate_ouput_destination() {\n    switch (output_) {\n        case DAT:\n            // Nothing to do\n            break;\n        case PG_DB:\n            dsc_disconnect_pg_db();\n            cout << \"*** Database disconnected\" << endl;\n            break;\n        default:\n            // Should never get here!\n            cerr << \"Error: Unknown output destination.\" << endl;\n            exit(1);\n            break;\n    }\n\n}\n\nvoid\nDSCIOManager::dsc_import_input_from_source() {\n\n    dsc_populate_files_vector();\n    int file_counter=file_vector_.size();\n    int file_failures = 0;\n    int file_commit_status = 0;  // status of transaction commit\n    int data_process_status = 0; // status of data processing\n    \n    string node = bfs::initial_path().filename().generic_string();\n    string server = bfs::initial_path().parent_path().filename().generic_string();\n    //fix potential sql injection\n    replace(node.begin(), node.end(), '\\'', '_');\n    replace(server.begin(), server.end(), '\\'', '_');\n    //transform to 'internal' name\n    replace(server.begin(), server.end(), '-', '_');\n    replace_string(server, \".\", \"__\");\n    transform(server.begin(), server.end(), server.begin(), ::tolower);\n    \n    cout << \"*** Processing server: \" << server << endl;\n    cout << \"*** Processing node:   \" << node << endl;\n    cout << \"*** Found:             \" << file_counter << \" \" <<  file_extension_ << \" files to process.\" << endl;\n    \n    for (std::vector<bfs::path>::const_iterator file_vector_it (file_vector_.begin()); file_vector_it != file_vector_.end(); ++file_vector_it) {\n        if ( pg_db_conn_ != NULL ) {\n            pg_db_trans_ = new pqxx::work( *pg_db_conn_ );\n            if ( pg_db_trans_ == NULL ) {\n                cerr << \"Error starting transaction.\" << endl;\n                exit(1);\n            }\n        }\n        cout << endl << currentDateTime() << \": Starting:  \" << (*file_vector_it).string() << endl;\n        DSCDataManager* dsc_data_manager = new DSCDataManager(server, node, pg_db_trans_);\n        file_commit_status = 0;\n        \n        switch (input_) {\n            case XML: {\n                // Partially read the xml. This is done using a policy tree,\n                // which uses rapidxml to do the parsing. There is no validation\n                // performed. Each array element is a \"data unit\" to send to the\n                // data manager load function.\n                dsc_xml_ = new boost::property_tree::ptree();\n                // If reading fails, exception is thrown.\n                try {\n                  boost::property_tree::read_xml((*file_vector_it).string(), *dsc_xml_);\n                  // We can't validate the XML but make this call the check that the file \n                  // at least has the correct top level node\n                  try {\n                    dsc_xml_->get_child(\"dscdata\");\n                  }\n                  catch( std::exception & e ) {\n                    cerr << \"Error: XML file has no content: \" << e.what() << endl;\n                    data_process_status = 1;\n                    break;\t\t\t\t\t\n                  }\n                }\n                catch( std::exception & e )\n                {\n                    cerr << \"Exception reading XML file: \" << e.what() << endl;\n                    data_process_status = 1;\n                    break;\n                }\n                catch( ... )\n                {\n                    cerr << \"Unknown exception caught\" << endl;\n                    data_process_status = 1;\n                    break;\n                }\n                // Get each array element and process it\n                BOOST_FOREACH(boost::property_tree::ptree::value_type &array_element, dsc_xml_->get_child(\"dscdata\")) {\n                    data_process_status = dsc_data_manager->load(array_element, rssac_);\n                    if (data_process_status) break;\n                    data_process_status = dsc_data_manager->process();\n                    if (data_process_status) break;\n                }\n                delete dsc_xml_;\n            }\n            break;\n            case DAT: {\n                // Call out to strategies to find out how this dat file \n                // needs to be processed.\n                // F1, F2 and F3a dat files contain multiple \"data units\"\n                vector<DSCStrategy*>::iterator strategy_it;\n                string name = (*file_vector_it).filename().string();\n                std::vector<DSCStrategy*> strategies_vector = DSCStrategyFactory::createStrategyDat(server, name);\n                bool multi;\n                \n                if (strategies_vector.size() != 1 ) { \n                    cerr << \"Error: Failed to find a single strategy for loading dat file \" << (*file_vector_it).string() << \" (found: \" << strategies_vector.size() << \")\" << endl;\n                    // exit(1);\n                    break;\n                }\n                \n                strategy_it = strategies_vector.begin();\n                multi = (*strategy_it)->is_dat_file_multi_unit();\n\n                if ( multi ) {\n                    // read the file one line at a time\n                    bfs::fstream dat_file;\n                    string dat_line;\n                    dat_file.open((*file_vector_it), ios_base::in);\n                    while (getline(dat_file, dat_line)) {\n                        if ( dsc_data_manager->load(dat_line, strategy_it) !=0 ) continue;\n                        data_process_status = dsc_data_manager->process(strategy_it);\n                        if (data_process_status) break;\n                    }\n                } else {\n                    // The entire file is one \"data unit\"\n                    dsc_data_manager->load((*file_vector_it), strategy_it);\n                    data_process_status = dsc_data_manager->process(strategy_it);\n                    if (data_process_status) break;\n                }\n            }\n            break;\n            default:\n                // Should never get here!\n                cerr << \"Error: Unknown input source\" << endl;\n                exit(1);\n        }\n        \n        if ( pg_db_trans_ != NULL ) {  \n                if ( data_process_status == 0 ) {\n                    try {\n                        pg_db_trans_->commit();\n                    }             \n                    catch( std::exception & e ) {\n                        cerr << \"Commit failed with exception message: \" << e.what() << endl;    \n                        file_commit_status = 1;             \n                    }\n                    catch( ... ) {\n                        cerr << \"Commit failed with general error\" << endl;\n                        file_commit_status = 1;\n                    }\n                }\n                // Tidy up. If the processing was not successful the transaction will implicitly rollback\n                delete pg_db_trans_;\n                pg_db_trans_ = NULL;         \n        }      \n        \n        delete dsc_data_manager;        \n        \n        // move the file to the done directory if all is well\n        if (file_commit_status == 0 && data_process_status == 0 ) {\n             dsc_move_file_to_done((*file_vector_it));        \n        } else {\n              dsc_handle_failed_file((*file_vector_it), data_process_status);\n            file_failures++;\n        }\n                \n        // Display helpful message. Flush to ensure that it is seen.\n        file_counter--;\n        cout << currentDateTime() << \": Completed: \" << setw(50) << left << (*file_vector_it).string() << \"\\t\" << file_counter << \" remaining (\" << file_failures << \" failures).\"<< endl;\n\n        std::flush(cout);\n    }\n    \n    // clear the file vector\n    file_vector_.clear();\n    \n    // endl since the previous cout used \\r\n    cout << endl;\n\n}\n\nvoid\nDSCIOManager::dsc_populate_files_vector() {\n    \n    std::string start_of_search_path;\n    switch (input_) {\n        case XML: \n            start_of_search_path = \"./incoming\";\n            file_extension_ = \".xml\";\n            break;\n        case DAT:\n            start_of_search_path = \".\";\n            file_extension_ = \".dat\";\n            break;\n        default:\n            // Should never get here!\n            cerr << \"Error: Unknown input source\" << endl;\n            exit(1);\n            break;\n    }\n    \n    bfs::path p_start (start_of_search_path);\n    bfs::path::iterator path_it;\n\n    // iterators for iterating over all the paths/files in the data directory\n    bfs::recursive_directory_iterator it(p_start), end_it;\n    try {\n        if (bfs::exists(p_start)) {\n            if (bfs::is_directory(p_start)) {\n                BOOST_FOREACH( bfs::path const &p_search, make_pair(it, end_it) ) {                 \n                    if ( p_search.string().find(\"done\") == string::npos ) {\n                        if ( ! bfs::is_directory(p_search) ) {\n                            if ( p_search.extension() == file_extension_ ) {\n                                if (! exclude_file(p_search, start_of_search_path) ) {\n                                        file_vector_.push_back(p_search);                                   \n                                }\n                            }\n                        }\n                    }\n                }\n                sort(file_vector_.begin(), file_vector_.end());\n            } else {\n                cout << p_start << \" exists, but is not a directory\\n\";\n                exit(1);\n            }\n        } else {\n            cout << p_start << \" does not exist\\n\";\n            exit(1);\n        }\n    }\n    catch (const bfs::filesystem_error& ex) {\n        cout << \"FS Error: \" << ex.what() << endl;\n        exit(1);\n    }\n    catch (std::exception &e) {\n        cerr << \"Error creating file vector: \" << e.what() << endl;\n        exit(1);\n    }\n    \n}\n\nvoid\nDSCIOManager::dsc_move_file_to_done(bfs::path path_src) {\n    \n    bfs::path path_done (\"./done\");\n    std::string done_sub_dir;\n    bfs::path path_date;\n    bfs::path path_done_date;\n    bfs::path path_newfile;\n    \n    try {\n        switch (input_) {\n            case XML: \n                done_sub_dir = \"dscdata\";\n                path_date = path_src.parent_path().stem(); //./incoming/yyyymmdd/*.xml --> yyyymmdd\n                break;\n            case DAT:\n                done_sub_dir = \"dat\";\n                path_date = path_src.parent_path().stem(); // ./yyyymmdd/*.dat --> yyyymmdd\n                break;\n            default:\n                // Should never get here!\n                cerr << \"Error: Unknown input source\" << endl;\n                exit(1);\n                break;\n        }\n        path_done_date = path_done/path_date/done_sub_dir;\n        if (!bfs::exists(path_done_date)) {\n                bfs::create_directories(path_done_date);\n        }\n        path_newfile = path_done_date/path_src.filename();\n        bfs::rename(path_src, path_newfile);\n        cout << currentDateTime() << \": Moved:     \" << path_src.string() << \" to \" <<  path_newfile.string() << endl;\n    }\n    catch (const bfs::filesystem_error& ex) {\n        cout << \"FS Error: \" << ex.what() << endl;\n        exit(1);\n    }\n    catch (std::exception &e) {\n        cerr << \"Error moving file to done: \" << e.what() << endl;\n        exit(1);\n    }\n \n}\n\nvoid\nDSCIOManager::dsc_handle_failed_file(bfs::path path_src, int process) {\n    \n    bfs::path path_newfile;  \n    std::string failed = \".failed.\";\n    std::string reason_string = process ? \" Failed to process data \" : \"Failed to commit data to DB\";\n    \n    try {\n        path_newfile = path_src.string() + failed + bfs::unique_path().string();\n        bfs::rename(path_src, path_newfile);\n        cout << currentDateTime() << \": Error: failed to process: \" << path_src.string() << \"Reason: \" << reason_string << endl;\n        cout << currentDateTime() << \": File renamed to:          \" << path_newfile.string() << endl;\n    }\n    catch (const bfs::filesystem_error& ex) {\n        cout << \"FS Error: \" << ex.what() << endl;\n        exit(1);\n    }\n    catch (std::exception &e) {\n        cerr << \"Error handling failed file: \" << e.what() << endl;\n        exit(1);\n    }\n \n}\n\nbool \nDSCIOManager::exclude_file(bfs::path path_src, const string& start_of_search_path) {\n\n    if ( input_ != XML || processing_start_date_ == NULL ) {\n        return false;\n    }\n\n    // Only do this test on files under './incoming'\n    if ( path_src.parent_path().parent_path().string().compare(start_of_search_path) == 0 ) {\n        struct tm tm  = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NULL };\n        if ( strptime(path_src.parent_path().filename().string().c_str(), \"%Y-%m-%d\", &tm) != NULL ) {\n            time_t dir_time = mktime(&tm);\n            //cout << \"Diff time is \" << difftime(*processing_start_date_, dir_time) << endl ;\n            if ( difftime(*processing_start_date_, dir_time) > 0 )  {\n                cout << \"File \" << path_src.string() << \" excluded from processing as it is earlier than the processing start date\" << endl;\n                return true;\n            } else {\n                return false;\n            }\n        }                     \n    }\n    return false;\n\n}"], "filenames": ["src/DSCIOManager.cpp"], "buggy_code_start_loc": [216], "buggy_code_end_loc": [216], "fixing_code_start_loc": [217], "fixing_code_end_loc": [220], "type": "CWE-89", "message": "A vulnerability was found in dns-stats hedgehog. It has been rated as problematic. Affected by this issue is the function DSCIOManager::dsc_import_input_from_source of the file src/DSCIOManager.cpp. The manipulation leads to sql injection. The attack may be launched remotely. The exploit has been disclosed to the public and may be used. The real existence of this vulnerability is still doubted at the moment. The name of the patch is 58922c345d3d1fe89bb2020111873a3e07ca93ac. It is recommended to apply a patch to fix this issue. VDB-216746 is the identifier assigned to this vulnerability. NOTE: This vulnerability only affects products that are no longer supported by the maintainer. NOTE: We do assume that the Data Manager server can only be accessed by authorised users. Because of this, we don\u2019t believe this specific attack is possible without such a compromise of the Data Manager server.", "other": {"cve": {"id": "CVE-2021-4276", "sourceIdentifier": "cna@vuldb.com", "published": "2022-12-25T11:15:10.940", "lastModified": "2023-01-09T19:57:27.933", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability was found in dns-stats hedgehog. It has been rated as problematic. Affected by this issue is the function DSCIOManager::dsc_import_input_from_source of the file src/DSCIOManager.cpp. The manipulation leads to sql injection. The attack may be launched remotely. The exploit has been disclosed to the public and may be used. The real existence of this vulnerability is still doubted at the moment. The name of the patch is 58922c345d3d1fe89bb2020111873a3e07ca93ac. It is recommended to apply a patch to fix this issue. VDB-216746 is the identifier assigned to this vulnerability. NOTE: This vulnerability only affects products that are no longer supported by the maintainer. NOTE: We do assume that the Data Manager server can only be accessed by authorised users. Because of this, we don\u2019t believe this specific attack is possible without such a compromise of the Data Manager server."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:H/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 4.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.7, "impactScore": 3.4}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:dns-stats:hedgehog:*:*:*:*:*:*:*:*", "versionEndExcluding": "2021-05-13", "matchCriteriaId": "B2C630CD-6B44-4C3D-9257-0F63C7A904FF"}]}]}], "references": [{"url": "https://github.com/dns-stats/hedgehog/commit/58922c345d3d1fe89bb2020111873a3e07ca93ac", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/dns-stats/hedgehog/pull/190", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://vuldb.com/?id.216746", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/dns-stats/hedgehog/commit/58922c345d3d1fe89bb2020111873a3e07ca93ac"}}