{"buggy_code": ["/*\n  Copyright (C) 2000,2002,2004,2005 Silicon Graphics, Inc. All Rights Reserved.\n  Portions Copyright 2007-2010 Sun Microsystems, Inc. All rights reserved.\n  Portions Copyright 2008-2021 David Anderson. All rights reserved.\n  Portions Copyright 2010-2012 SN Systems Ltd. All rights reserved.\n\n  This program is free software; you can redistribute it\n  and/or modify it under the terms of version 2.1 of the\n  GNU Lesser General Public License as published by the Free\n  Software Foundation.\n\n  This program is distributed in the hope that it would be\n  useful, but WITHOUT ANY WARRANTY; without even the implied\n  warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n  PURPOSE.\n\n  Further, this software is distributed without any warranty\n  that it is free of the rightful claim of any third person\n  regarding infringement or the like.  Any license provided\n  herein, whether implied or otherwise, applies only to this\n  software file.  Patent licenses, if any, provided herein\n  do not apply to combinations of this program with other\n  software, or any other product whatsoever.\n\n  You should have received a copy of the GNU Lesser General\n  Public License along with this program; if not, write the\n  Free Software Foundation, Inc., 51 Franklin Street - Fifth\n  Floor, Boston MA 02110-1301, USA.\n\n*/\n\n#include <config.h>\n\n#include <string.h>  /* memcpy() memset() */\n\n#if defined(_WIN32) && defined(HAVE_STDAFX_H)\n#include \"stdafx.h\"\n#endif /* HAVE_STDAFX_H */\n\n#include \"dwarf.h\"\n#include \"libdwarf.h\"\n#include \"libdwarf_private.h\"\n#include \"dwarf_base_types.h\"\n#include \"dwarf_opaque.h\"\n#include \"dwarf_alloc.h\"\n#include \"dwarf_string.h\"\n#include \"dwarf_error.h\"\n#include \"dwarf_util.h\"\n#include \"dwarf_die_deliv.h\"\n#include \"dwarf_str_offsets.h\"\n#include \"dwarf_string.h\"\n\n/*  It is necessary at times to cause errors of this sort\n    in determining what we really have.  So best to avoid\n    too much malloc and free, hence the static constructor\n    dwarfstring will use malloc if we guess too-small\n    for the size of mbuf. */\nstatic void\ngenerate_form_error(Dwarf_Debug dbg,\n    Dwarf_Error *error,\n    unsigned form,\n    int err_code,\n    const char *errname,\n    const char *funcname)\n{\n    dwarfstring m;\n    char mbuf[DWARFSTRING_ALLOC_SIZE];\n    const char * defaultname = \"<unknown form>\";\n\n    dwarfstring_constructor_static(&m,mbuf,\n        sizeof(mbuf));\n    dwarfstring_append(&m,(char *)errname);\n    dwarfstring_append(&m,\": In function \");\n    dwarfstring_append(&m,(char *)funcname);\n    dwarfstring_append_printf_u(&m,\n        \" on seeing form  0x%x \",form);\n    dwarf_get_FORM_name(form,&defaultname);\n    dwarfstring_append_printf_s(&m,\n        \" (%s)\",(char *)defaultname);\n    _dwarf_error_string(dbg,error,err_code,\n        dwarfstring_string(&m));\n    dwarfstring_destructor(&m);\n}\n\n/*  This code was repeated many times, now it\n    is all in one place.\n    Never returns DW_DLV_NO_ENTRY  */\nstatic int\nget_attr_dbg(Dwarf_Debug *dbg_out,\n    Dwarf_CU_Context * cu_context_out,\n    Dwarf_Attribute attr,\n    Dwarf_Error *error)\n{\n    Dwarf_CU_Context cup = 0;\n    Dwarf_Debug dbg = 0;\n\n    if (!attr) {\n        _dwarf_error(NULL, error, DW_DLE_ATTR_NULL);\n        return DW_DLV_ERROR;\n    }\n    cup = attr->ar_cu_context;\n    if (!cup) {\n        _dwarf_error(NULL, error, DW_DLE_ATTR_NO_CU_CONTEXT);\n        return DW_DLV_ERROR;\n    }\n    dbg = cup->cc_dbg;\n    if (!dbg  || dbg->de_magic != DBG_IS_VALID) {\n        _dwarf_error_string(NULL, error, DW_DLE_ATTR_DBG_NULL,\n            \"DW_DLE_ATTR_DBG_NULL: Stale or null Dwarf_Debug\"\n            \"in a Dwarf_CU_Context\" );\n        return DW_DLV_ERROR;\n    }\n    if (dbg != attr->ar_dbg) {\n        _dwarf_error_string(NULL, error, DW_DLE_ATTR_DBG_NULL,\n            \"DW_DLE_ATTR_DBG_NULL: an attribute and its \"\n            \"cu_context do not have the same Dwarf_Debug\" );\n        return DW_DLV_ERROR;\n    }\n    *cu_context_out = cup;\n    *dbg_out        = dbg;\n    return DW_DLV_OK;\n\n}\n\nint\ndwarf_hasform(Dwarf_Attribute attr,\n    Dwarf_Half form,\n    Dwarf_Bool * return_bool, Dwarf_Error * error)\n{\n    Dwarf_Debug dbg = 0;\n    Dwarf_CU_Context cu_context = 0;\n\n    int res  =get_attr_dbg(&dbg,&cu_context, attr,error);\n    if (res != DW_DLV_OK) {\n        return res;\n    }\n    *return_bool = (attr->ar_attribute_form == form);\n    return DW_DLV_OK;\n}\n\n/* Not often called, we do not worry about efficiency here.\n   The dwarf_whatform() call does the sanity checks for us.\n*/\nint\ndwarf_whatform_direct(Dwarf_Attribute attr,\n    Dwarf_Half * return_form, Dwarf_Error * error)\n{\n    int res = dwarf_whatform(attr, return_form, error);\n\n    if (res != DW_DLV_OK) {\n        return res;\n    }\n\n    *return_form = attr->ar_attribute_form_direct;\n    return DW_DLV_OK;\n}\n\n/*  This code was contributed around 2007.\n    As of 2021 it is not clear that Sun Sparc\n    compilers are in current use, nor whether\n    there is a reason to make reads of\n    this data format safe from corrupted object files.\n\n    Pass in the content of a block and the length of that\n    content. On success return DW_DLV_OK and set *value_count\n    to the size of the array returned through value_array. */\nint\ndwarf_uncompress_integer_block_a(Dwarf_Debug dbg,\n    Dwarf_Unsigned     input_length_in_bytes,\n    void             * input_block,\n    Dwarf_Unsigned   * value_count,\n    Dwarf_Signed    ** value_array,\n    Dwarf_Error      * error)\n{\n    Dwarf_Unsigned output_length_in_units = 0;\n    Dwarf_Signed * output_block = 0;\n    unsigned i = 0;\n    char * ptr = 0;\n    int remain = 0;\n    Dwarf_Signed * array = 0;\n    Dwarf_Byte_Ptr endptr = (Dwarf_Byte_Ptr)input_block+\n        input_length_in_bytes;\n\n    output_length_in_units = 0;\n    remain = input_length_in_bytes;\n    ptr = input_block;\n    while (remain > 0) {\n        Dwarf_Unsigned len = 0;\n        Dwarf_Signed value = 0;\n        int rres = 0;\n\n        rres = dwarf_decode_signed_leb128((char *)ptr,\n            &len, &value,(char *)endptr);\n        if (rres != DW_DLV_OK) {\n            _dwarf_error(NULL, error, DW_DLE_LEB_IMPROPER);\n            return DW_DLV_ERROR;\n        }\n        ptr += len;\n        remain -= len;\n        output_length_in_units++;\n    }\n    if (remain != 0) {\n        _dwarf_error(NULL, error, DW_DLE_ALLOC_FAIL);\n        return DW_DLV_ERROR;\n    }\n\n    output_block = (Dwarf_Signed*)\n        _dwarf_get_alloc(dbg,\n            DW_DLA_STRING,\n            output_length_in_units * sizeof(Dwarf_Signed));\n    if (!output_block) {\n        _dwarf_error(dbg, error, DW_DLE_ALLOC_FAIL);\n        return DW_DLV_ERROR;\n    }\n    array = output_block;\n    remain = input_length_in_bytes;\n    ptr = input_block;\n    for (i=0; i<output_length_in_units && remain>0; i++) {\n        Dwarf_Signed num;\n        Dwarf_Unsigned len;\n        int sres = 0;\n\n        sres = dwarf_decode_signed_leb128((char *)ptr,\n            &len, &num,(char *)endptr);\n        if (sres != DW_DLV_OK) {\n            dwarf_dealloc(dbg,output_block,DW_DLA_STRING);\n            _dwarf_error(NULL, error, DW_DLE_LEB_IMPROPER);\n            return DW_DLV_ERROR;\n        }\n        ptr += len;\n        remain -= len;\n        array[i] = num;\n    }\n\n    if (remain != 0) {\n        dwarf_dealloc(dbg, (unsigned char *)output_block,\n            DW_DLA_STRING);\n        _dwarf_error(dbg, error, DW_DLE_ALLOC_FAIL);\n        return DW_DLV_ERROR;\n    }\n\n    *value_count = output_length_in_units;\n    *value_array = output_block;\n    return DW_DLV_OK;\n}\n\n/*  This code was contributed around 2007\n    and the return value is in the wrong form.\n    See dwarf_uncompress_integer_block_a() above.\n\n    As of 2019 it is not clear that Sun Sparc\n    compilers are in current use, nor whether\n    there is a reason to make reads of\n    this data format safe from corrupted object files.\n*/\n\nvoid\ndwarf_dealloc_uncompressed_block(Dwarf_Debug dbg, void * space)\n{\n    dwarf_dealloc(dbg, space, DW_DLA_STRING);\n}\n\n/*  Never returns DW_DLV_NO_ENTRY */\nint\ndwarf_whatform(Dwarf_Attribute attr,\n    Dwarf_Half * return_form, Dwarf_Error * error)\n{\n    Dwarf_CU_Context cu_context = 0;\n    Dwarf_Debug dbg = 0;\n\n    int res  =get_attr_dbg(&dbg,&cu_context, attr,error);\n    if (res != DW_DLV_OK) {\n        return res;\n    }\n    *return_form = attr->ar_attribute_form;\n    return DW_DLV_OK;\n}\n\n/*\n    This function is analogous to dwarf_whatform.\n    It returns the attribute in attr instead of\n    the form.\n*/\nint\ndwarf_whatattr(Dwarf_Attribute attr,\n    Dwarf_Half * return_attr, Dwarf_Error * error)\n{\n    Dwarf_CU_Context cu_context = 0;\n    Dwarf_Debug dbg = 0;\n\n    int res  =get_attr_dbg(&dbg,&cu_context, attr,error);\n    if (res != DW_DLV_OK) {\n        return res;\n    }\n    *return_attr = (attr->ar_attribute);\n    return DW_DLV_OK;\n}\n\n/*  Convert an offset within the local CU into a section-relative\n    debug_info (or debug_types) offset.\n    See dwarf_global_formref() and dwarf_formref()\n    for additional information on conversion rules.\n*/\nint\ndwarf_convert_to_global_offset(Dwarf_Attribute attr,\n    Dwarf_Off offset,\n    Dwarf_Off * ret_offset,\n    Dwarf_Error * error)\n{\n    Dwarf_Debug dbg = 0;\n    Dwarf_CU_Context cu_context = 0;\n    int res = 0;\n\n    res  = get_attr_dbg(&dbg,&cu_context,attr,error);\n    if (res != DW_DLV_OK) {\n        return res;\n    }\n    switch (attr->ar_attribute_form) {\n    case DW_FORM_ref1:\n    case DW_FORM_ref2:\n    case DW_FORM_ref4:\n    case DW_FORM_ref8:\n    case DW_FORM_ref_udata:\n        /*  It is a cu-local offset. Convert to section-global. */\n        /*  It would be nice to put some code to check\n            legality of the offset */\n        /*  cc_debug_offset always has any DWP Package File\n            offset included (when the cu_context created)\n            so there is no extra work for DWP.\n            Globalize the offset */\n        offset += cu_context->cc_debug_offset;\n\n        break;\n\n    case DW_FORM_ref_addr:\n        /*  This offset is defined to be debug_info global already, so\n            use this value unaltered.\n\n            Since a DWP package file is not relocated there\n            is no way that this reference offset to an address in\n            any other CU can be correct for a DWP Package File offset\n            */\n        break;\n    default: {\n        dwarfstring m;\n\n        dwarfstring_constructor(&m);\n        dwarfstring_append_printf_u(&m,\n            \"DW_DLE_BAD_REF_FORM. The form \"\n            \"code is 0x%x which cannot be converted to a global \"\n            \" offset by \"\n            \"dwarf_convert_to_global_offset()\",\n            attr->ar_attribute_form);\n        _dwarf_error_string(dbg, error, DW_DLE_BAD_REF_FORM,\n            dwarfstring_string(&m));\n        dwarfstring_destructor(&m);\n        return DW_DLV_ERROR;\n        }\n    }\n\n    *ret_offset = (offset);\n    return DW_DLV_OK;\n}\n\n/*  A global offset cannot be returned by this interface:\n    see dwarf_global_formref().\n\n    DW_FORM_ref_addr is considered an incorrect form\n    for this call because DW_FORM_ref_addr is a global-offset into\n    the debug_info section.\n\n    For the same reason DW_FORM_data4/data8 are not returned\n    from this function.\n\n    For the same reason DW_FORM_sec_offset is not returned\n    from this function, DW_FORM_sec_offset is a global offset\n    (to various sections, not a CU relative offset.\n\n    DW_FORM_ref_addr has a value which was documented in\n    DWARF2 as address-size but which was always an offset\n    so should have always been offset size (wording\n    corrected in DWARF3).\n    The dwarfstd.org FAQ \"How big is a DW_FORM_ref_addr?\"\n    suggested all should use offset-size, but that suggestion\n    seems to have been ignored in favor of doing what the\n    DWARF2 and 3 standards actually say.\n\n    November, 2010: *ret_offset is always set now.\n    Even in case of error.\n    Set to zero for most errors, but for\n        DW_DLE_ATTR_FORM_OFFSET_BAD\n    *ret_offset is set to the bad offset.\n\n    DW_FORM_addrx\n    DW_FORM_strx\n    DW_FORM_LLVM_addrx_offset\n    DW_FORM_rnglistx\n    DW_FORM_GNU_addr_index\n    DW_FORM_GNU_str_index\n    are not references to .debug_info/.debug_types,\n    so they are not allowed here. */\n\nint\ndwarf_formref(Dwarf_Attribute attr,\n    Dwarf_Off * ret_offset,\n    Dwarf_Bool * ret_is_info,\n    Dwarf_Error * error)\n{\n    Dwarf_Debug dbg = 0;\n    Dwarf_Unsigned offset = 0;\n    Dwarf_CU_Context cu_context = 0;\n    Dwarf_Unsigned maximumoffset = 0;\n    int res = DW_DLV_ERROR;\n    Dwarf_Byte_Ptr section_end = 0;\n    Dwarf_Bool is_info = TRUE;\n\n    *ret_offset = 0;\n    res  = get_attr_dbg(&dbg,&cu_context,attr,error);\n    if (res != DW_DLV_OK) {\n        return res;\n    }\n    section_end =\n        _dwarf_calculate_info_section_end_ptr(cu_context);\n    is_info = cu_context->cc_is_info;\n\n    switch (attr->ar_attribute_form) {\n\n    case DW_FORM_ref1:\n        offset = *(Dwarf_Small *) attr->ar_debug_ptr;\n        break;\n\n    case DW_FORM_ref2:\n        READ_UNALIGNED_CK(dbg, offset, Dwarf_Unsigned,\n            attr->ar_debug_ptr, DWARF_HALF_SIZE,\n            error,section_end);\n        break;\n\n    case DW_FORM_ref4:\n        READ_UNALIGNED_CK(dbg, offset, Dwarf_Unsigned,\n            attr->ar_debug_ptr, DWARF_32BIT_SIZE,\n            error,section_end);\n        break;\n\n    case DW_FORM_ref8:\n        READ_UNALIGNED_CK(dbg, offset, Dwarf_Unsigned,\n            attr->ar_debug_ptr, DWARF_64BIT_SIZE,\n            error,section_end);\n        break;\n\n    case DW_FORM_ref_udata: {\n        Dwarf_Byte_Ptr ptr = attr->ar_debug_ptr;\n        Dwarf_Unsigned localoffset = 0;\n\n        DECODE_LEB128_UWORD_CK(ptr,localoffset,\n            dbg,error,section_end);\n        offset = localoffset;\n        break;\n    }\n    case DW_FORM_ref_sig8: {\n        /*  We need to look for a local reference here.\n            The function we are in is only CU_local\n            offsets returned. */\n#if 0\n        Dwarf_Sig8 sig8;\n        memcpy(&sig8,ptr,sizeof(Dwarf_Sig8));\n        res = dwarf_find_die_given_sig8(dbg,\n            &sig8, ...\n        We could look, then determine if\n        resulting offset is actually local.\n#endif /*0*/\n\n        /*  We cannot handle this here.\n            The reference could be to .debug_types\n            or another CU!\n            not a .debug_info CU local offset. */\n        _dwarf_error(dbg, error, DW_DLE_REF_SIG8_NOT_HANDLED);\n        return DW_DLV_ERROR;\n    }\n    default: {\n        dwarfstring m;\n\n        dwarfstring_constructor(&m);\n        dwarfstring_append_printf_u(&m,\n            \"DW_DLE_BAD_REF_FORM. The form \"\n            \"code is 0x%x which does not have an offset \"\n            \" for \"\n            \"dwarf_formref() to return.\",\n            attr->ar_attribute_form);\n        _dwarf_error_string(dbg, error, DW_DLE_BAD_REF_FORM,\n            dwarfstring_string(&m));\n        dwarfstring_destructor(&m);\n        return DW_DLV_ERROR;\n        }\n    }\n\n    /*  Check that offset is within current\n        cu portion of .debug_info. */\n\n    maximumoffset = cu_context->cc_length +\n        cu_context->cc_length_size +\n        cu_context->cc_extension_size;\n    if (offset >= maximumoffset) {\n        /*  For the DW_TAG_compile_unit is legal to have the\n            DW_AT_sibling attribute outside the current cu portion of\n            .debug_info.\n            In other words, sibling points to the end of the CU.\n            It is used for precompiled headers.\n            The valid condition will be: 'offset == maximumoffset'. */\n        Dwarf_Half tag = 0;\n        int tres = dwarf_tag(attr->ar_die,&tag,error);\n        if (tres != DW_DLV_OK) {\n            if (tres == DW_DLV_NO_ENTRY) {\n                _dwarf_error(dbg, error, DW_DLE_NO_TAG_FOR_DIE);\n                return DW_DLV_ERROR;\n            }\n            return DW_DLV_ERROR;\n        }\n\n        if (DW_TAG_compile_unit != tag &&\n            DW_AT_sibling != attr->ar_attribute &&\n            offset > maximumoffset) {\n            _dwarf_error(dbg, error, DW_DLE_ATTR_FORM_OFFSET_BAD);\n            /*  Return the incorrect offset for better\n                error reporting */\n            *ret_offset = (offset);\n            return DW_DLV_ERROR;\n        }\n    }\n    *ret_is_info = is_info;\n    *ret_offset = (offset);\n    return DW_DLV_OK;\n}\n\nstatic int\n_dwarf_formsig8_internal(Dwarf_Attribute attr,\n    int formexpected,\n    Dwarf_Sig8 * returned_sig_bytes,\n    Dwarf_Error*     error)\n{\n    Dwarf_Debug dbg = 0;\n    Dwarf_CU_Context cu_context = 0;\n    Dwarf_Byte_Ptr  field_end = 0;\n    Dwarf_Byte_Ptr  section_end = 0;\n\n    int res  = get_attr_dbg(&dbg,&cu_context,attr,error);\n    if (res != DW_DLV_OK) {\n        return res;\n    }\n\n    if (attr->ar_attribute_form != formexpected) {\n        return DW_DLV_NO_ENTRY;\n    }\n    section_end =\n        _dwarf_calculate_info_section_end_ptr(cu_context);\n    field_end = attr->ar_debug_ptr + sizeof(Dwarf_Sig8);\n    if (field_end > section_end) {\n        _dwarf_error(dbg, error, DW_DLE_ATTR_FORM_OFFSET_BAD);\n        return DW_DLV_ERROR;\n    }\n\n    memcpy(returned_sig_bytes, attr->ar_debug_ptr,\n        sizeof(*returned_sig_bytes));\n    return DW_DLV_OK;\n}\n\nint\ndwarf_formsig8_const(Dwarf_Attribute attr,\n    Dwarf_Sig8 * returned_sig_bytes,\n    Dwarf_Error* error)\n{\n    int res  =_dwarf_formsig8_internal(attr, DW_FORM_data8,\n        returned_sig_bytes,error);\n    return res;\n}\n\n/*  dwarf_formsig8 returns in the caller-provided 8 byte area\n    the 8 bytes of a DW_FORM_ref_sig8 (copying the bytes\n    directly to the caller).  Not a string, an 8 byte\n    MD5 hash or a signature.\n    This function is new in DWARF4 libdwarf and used in\n    more places in DWARF5.\n*/\nint\ndwarf_formsig8(Dwarf_Attribute attr,\n    Dwarf_Sig8 * returned_sig_bytes,\n    Dwarf_Error* error)\n{\n    int res  = _dwarf_formsig8_internal(attr, DW_FORM_ref_sig8,\n        returned_sig_bytes,error);\n    return res;\n}\n\n/*  This finds a target via a sig8 and if\n    DWARF4 is likely finding a reference from .debug_info\n    to .debug_types.  So the offset may or may not be\n    in the same section if DWARF4. */\nstatic int\nfind_sig8_target_as_global_offset(Dwarf_Attribute attr,\n    Dwarf_Sig8  *sig8,\n    Dwarf_Bool  *is_info,\n    Dwarf_Off   *targoffset,\n    Dwarf_Error *error)\n{\n    Dwarf_Die  targdie = 0;\n    Dwarf_Bool targ_is_info = 0;\n    Dwarf_Off  localoff = 0;\n    int res = 0;\n\n    targ_is_info = attr->ar_cu_context->cc_is_info;\n    memcpy(sig8,attr->ar_debug_ptr,sizeof(*sig8));\n    res = dwarf_find_die_given_sig8(attr->ar_dbg,\n        sig8,&targdie,&targ_is_info,error);\n    if (res != DW_DLV_OK) {\n        return res;\n    }\n    res = dwarf_die_offsets(targdie,targoffset,&localoff,error);\n    if (res != DW_DLV_OK) {\n        dwarf_dealloc_die(targdie);\n        return res;\n    }\n    *is_info = targdie->di_cu_context->cc_is_info;\n    dwarf_dealloc_die(targdie);\n    return DW_DLV_OK;\n}\n\n/*  Since this returns section-relative debug_info offsets,\n    this can represent all REFERENCE forms correctly\n    and allows all applicable forms.\n\n    DW_FORM_ref_addr has a value which was documented in\n    DWARF2 as address-size but which was always an offset\n    so should have always been offset size (wording\n    corrected in DWARF3).\n        gcc and Go and libdwarf producer code\n    define the length of the value of DW_FORM_ref_addr\n    per the version. So for V2 it is address-size and V3 and later\n    it is offset-size.\n\n    See the DWARF4 document for the 3 cases fitting\n    reference forms.  The caller must determine which section the\n    reference 'points' to.  The function added in November 2009,\n    dwarf_get_form_class(), helps in this regard.\n\n    unlike dwarf_formref(), this allows references to\n    sections other than just .debug_info/.debug_types.\n    See case DW_FORM_sec_offset:\n    case DW_FORM_GNU_ref_alt:   2013 GNU extension\n    case DW_FORM_GNU_strp_alt:  2013 GNU extension\n    case DW_FORM_strp_sup:      DWARF5, sup string section\n    case DW_FORM_line_strp:     DWARF5, .debug_line_str section\n*/\n\n/*  This follows DW_FORM_ref_sig8 so could got\n    to any CU and from debug_info to debug_types\n    (or vice versa?)\n    dwarf_global_formref_b is aimed at for DIE references.\n    Only the DW_FORM_ref_sig8 form can change\n    from a cu_context in .debug_info\n    to one in .debug_types (DWARF4 only).\n    For references to other sections it is simpler\n    to call the original: dwarf_global_formref.\n*/\nint\ndwarf_global_formref(Dwarf_Attribute attr,\n    Dwarf_Off * ret_offset,\n    Dwarf_Error * error)\n{\n    Dwarf_Bool is_info = 0;\n    int res = 0;\n\n    res = dwarf_global_formref_b(attr,ret_offset,\n        &is_info,error);\n    return res;\n}\nint\ndwarf_global_formref_b(Dwarf_Attribute attr,\n    Dwarf_Off * ret_offset,\n    Dwarf_Bool * offset_is_info,\n    Dwarf_Error * error)\n{\n    Dwarf_Debug dbg = 0;\n    Dwarf_Unsigned offset = 0;\n    Dwarf_CU_Context cu_context = 0;\n    Dwarf_Half context_version = 0;\n    Dwarf_Byte_Ptr section_end = 0;\n    Dwarf_Bool is_info = TRUE;\n\n    int res  = get_attr_dbg(&dbg,&cu_context,attr,error);\n    if (res != DW_DLV_OK) {\n        return res;\n    }\n    section_end =\n        _dwarf_calculate_info_section_end_ptr(cu_context);\n    context_version = cu_context->cc_version_stamp;\n    is_info = cu_context->cc_is_info;\n    switch (attr->ar_attribute_form) {\n\n    case DW_FORM_ref1:\n        offset = *(Dwarf_Small *) attr->ar_debug_ptr;\n        goto fixoffset;\n\n    case DW_FORM_ref2:\n        READ_UNALIGNED_CK(dbg, offset, Dwarf_Unsigned,\n            attr->ar_debug_ptr, DWARF_HALF_SIZE,\n            error,section_end);\n        goto fixoffset;\n\n    case DW_FORM_ref4:\n        READ_UNALIGNED_CK(dbg, offset, Dwarf_Unsigned,\n            attr->ar_debug_ptr, DWARF_32BIT_SIZE,\n            error,section_end);\n        goto fixoffset;\n\n    case DW_FORM_ref8:\n        READ_UNALIGNED_CK(dbg, offset, Dwarf_Unsigned,\n            attr->ar_debug_ptr, DWARF_64BIT_SIZE,\n            error,section_end);\n        goto fixoffset;\n\n    case DW_FORM_ref_udata:\n        {\n        Dwarf_Byte_Ptr ptr = attr->ar_debug_ptr;\n        Dwarf_Unsigned localoffset = 0;\n\n        DECODE_LEB128_UWORD_CK(ptr,localoffset,\n            dbg,error,section_end);\n        offset = localoffset;\n\n        fixoffset: /* we have a local offset, make it global */\n\n        /* check legality of offset */\n        if (offset >= cu_context->cc_length +\n            cu_context->cc_length_size +\n            cu_context->cc_extension_size) {\n            _dwarf_error(dbg, error, DW_DLE_ATTR_FORM_OFFSET_BAD);\n            return DW_DLV_ERROR;\n        }\n\n        /* globalize the offset */\n        offset += cu_context->cc_debug_offset;\n        }\n        break;\n\n    /*  The DWARF2 document did not make clear that\n        DW_FORM_data4( and 8) were references with\n        global offsets to some section.\n        That was first clearly documented in DWARF3.\n        In DWARF4 these two forms are no longer references. */\n    case DW_FORM_data4:\n        if (context_version >= DW_CU_VERSION4) {\n            _dwarf_error(dbg, error, DW_DLE_NOT_REF_FORM);\n            return DW_DLV_ERROR;\n        }\n        READ_UNALIGNED_CK(dbg, offset, Dwarf_Unsigned,\n            attr->ar_debug_ptr, DWARF_32BIT_SIZE,\n            error, section_end);\n        /* The offset is global. */\n        break;\n    case DW_FORM_data8:\n        if (context_version >= DW_CU_VERSION4) {\n            _dwarf_error(dbg, error, DW_DLE_NOT_REF_FORM);\n            return DW_DLV_ERROR;\n        }\n        READ_UNALIGNED_CK(dbg, offset, Dwarf_Unsigned,\n            attr->ar_debug_ptr, DWARF_64BIT_SIZE,\n            error,section_end);\n        /* The offset is global. */\n        break;\n    case DW_FORM_ref_addr:\n        {\n            /*  In Dwarf V2 DW_FORM_ref_addr was defined\n                as address-size even though it is a .debug_info\n                offset.  Fixed in Dwarf V3 to be offset-size.\n                */\n            unsigned length_size = 0;\n            if (context_version == 2) {\n                length_size = cu_context->cc_address_size;\n            } else {\n                length_size = cu_context->cc_length_size;\n            }\n            if (length_size == 4) {\n                READ_UNALIGNED_CK(dbg, offset, Dwarf_Unsigned,\n                    attr->ar_debug_ptr, DWARF_32BIT_SIZE,\n                    error,section_end);\n            } else if (length_size == 8) {\n                READ_UNALIGNED_CK(dbg, offset, Dwarf_Unsigned,\n                    attr->ar_debug_ptr, DWARF_64BIT_SIZE,\n                    error,section_end);\n            } else {\n                _dwarf_error(dbg, error,\n                    DW_DLE_FORM_SEC_OFFSET_LENGTH_BAD);\n                return DW_DLV_ERROR;\n            }\n        }\n        break;\n    /*  Index into .debug_rnglists/.debug_loclists section.\n        Return the index itself. */\n    case DW_FORM_loclistx:\n    case DW_FORM_rnglistx: {\n        unsigned length_size = cu_context->cc_length_size;\n        READ_UNALIGNED_CK(dbg, offset, Dwarf_Unsigned,\n            attr->ar_debug_ptr, length_size,\n            error,section_end);\n        }\n        break;\n    case DW_FORM_sec_offset:\n    case DW_FORM_GNU_ref_alt:  /* 2013 GNU extension */\n    case DW_FORM_GNU_strp_alt: /* 2013 GNU extension */\n    case DW_FORM_strp_sup:     /* DWARF5, sup string section */\n    case DW_FORM_line_strp:    /* DWARF5, .debug_line_str section */\n        {\n            /*  DW_FORM_sec_offset first exists in DWARF4.*/\n            /*  It is up to the caller to know what the offset\n                of DW_FORM_sec_offset, DW_FORM_strp_sup\n                or DW_FORM_GNU_strp_alt etc refer to,\n                the offset is not going to refer to .debug_info! */\n            unsigned length_size = cu_context->cc_length_size;\n            if (length_size == 4) {\n                READ_UNALIGNED_CK(dbg, offset, Dwarf_Unsigned,\n                    attr->ar_debug_ptr, DWARF_32BIT_SIZE,\n                    error,section_end);\n            } else if (length_size == 8) {\n                READ_UNALIGNED_CK(dbg, offset, Dwarf_Unsigned,\n                    attr->ar_debug_ptr, DWARF_64BIT_SIZE,\n                    error,section_end);\n            } else {\n                _dwarf_error(dbg, error,\n                    DW_DLE_FORM_SEC_OFFSET_LENGTH_BAD);\n                return DW_DLV_ERROR;\n            }\n        }\n        break;\n    case DW_FORM_ref_sig8: {\n        /*  This, in DWARF4, is how\n            .debug_info refers to .debug_types. */\n        Dwarf_Sig8 sig8;\n        Dwarf_Bool t_is_info = TRUE;\n        Dwarf_Unsigned t_offset = 0;\n\n        memcpy(&sig8,attr->ar_debug_ptr,sizeof(Dwarf_Sig8));\n        res = find_sig8_target_as_global_offset(attr,\n            &sig8,&t_is_info,&t_offset,error);\n        if (res == DW_DLV_ERROR) {\n            _dwarf_error_string(dbg, error,\n                DW_DLE_REF_SIG8_NOT_HANDLED,\n                \"DW_DLE_REF_SIG8_NOT_HANDLED: \"\n                \" problem finding target\");\n            return DW_DLV_ERROR;\n        }\n        if (res == DW_DLV_NO_ENTRY) {\n            return res;\n        }\n        is_info = t_is_info;\n        offset = t_offset;\n        break;\n    }\n    default: {\n        dwarfstring m;\n        int formcode = attr->ar_attribute_form;\n        int fcres = 0;\n        const char *name = 0;\n\n        dwarfstring_constructor(&m);\n        dwarfstring_append_printf_u(&m,\n            \"DW_DLE_BAD_REF_FORM: The form code is 0x%x \",\n            formcode);\n        fcres  = dwarf_get_FORM_name (formcode,&name);\n        if (fcres != DW_DLV_OK) {\n            name=\"<UnknownFormCode>\";\n        }\n        dwarfstring_append_printf_s(&m,\n            \" %s.\",(char *)name);\n        _dwarf_error_string(dbg, error, DW_DLE_BAD_REF_FORM,\n            dwarfstring_string(&m));\n        dwarfstring_destructor(&m);\n        return DW_DLV_ERROR;\n        }\n    }\n\n    *offset_is_info = is_info;\n    *ret_offset = offset;\n    return DW_DLV_OK;\n}\n\n/*  Part of DebugFission.  So a consumer can get the index when\n    the object with the actual debug_addr  is\n    elsewhere.  New May 2014*/\n\nint\n_dwarf_get_addr_index_itself(int theform,\n    Dwarf_Small *info_ptr,\n    Dwarf_Debug dbg,\n    Dwarf_CU_Context cu_context,\n    Dwarf_Unsigned *val_out,\n    Dwarf_Error * error)\n{\n    Dwarf_Unsigned index = 0;\n    Dwarf_Byte_Ptr section_end = 0;\n\n    section_end =\n        _dwarf_calculate_info_section_end_ptr(cu_context);\n    switch(theform){\n    case DW_FORM_LLVM_addrx_offset: {\n        Dwarf_Unsigned tmp = 0;\n        Dwarf_Unsigned tmp2 = 0;\n        DECODE_LEB128_UWORD_CK(info_ptr,tmp,\n            dbg,error,section_end);\n        READ_UNALIGNED_CK(dbg, tmp2, Dwarf_Unsigned,\n            info_ptr, SIZEOFT32,\n            error,section_end);\n        index = (tmp<<32) | tmp2;\n        break;\n    }\n    case DW_FORM_GNU_addr_index:\n    case DW_FORM_addrx:\n        DECODE_LEB128_UWORD_CK(info_ptr,index,\n            dbg,error,section_end);\n        break;\n    case DW_FORM_addrx1:\n        READ_UNALIGNED_CK(dbg, index, Dwarf_Unsigned,\n            info_ptr, 1,\n            error,section_end);\n        break;\n    case DW_FORM_addrx2:\n        READ_UNALIGNED_CK(dbg, index, Dwarf_Unsigned,\n            info_ptr, 2,\n            error,section_end);\n        break;\n    case DW_FORM_addrx3:\n        READ_UNALIGNED_CK(dbg, index, Dwarf_Unsigned,\n            info_ptr, 3,\n            error,section_end);\n        break;\n    case DW_FORM_addrx4:\n        READ_UNALIGNED_CK(dbg, index, Dwarf_Unsigned,\n            info_ptr, 4,\n            error,section_end);\n        break;\n    default:\n        _dwarf_error(dbg, error, DW_DLE_ATTR_FORM_NOT_ADDR_INDEX);\n        return DW_DLV_ERROR;\n    }\n    *val_out = index;\n    return DW_DLV_OK;\n}\n\nint\ndwarf_get_debug_addr_index(Dwarf_Attribute attr,\n    Dwarf_Unsigned * return_index,\n    Dwarf_Error * error)\n{\n    int theform = 0;\n    Dwarf_CU_Context cu_context = 0;\n    Dwarf_Debug dbg = 0;\n\n    int res  = get_attr_dbg(&dbg,&cu_context,attr,error);\n    if (res != DW_DLV_OK) {\n        return res;\n    }\n    theform = attr->ar_attribute_form;\n    if (dwarf_addr_form_is_indexed(theform)) {\n        Dwarf_Unsigned index = 0;\n\n        res = _dwarf_get_addr_index_itself(theform,\n            attr->ar_debug_ptr,dbg,cu_context,&index,error);\n        *return_index = index;\n        return res;\n    }\n\n    _dwarf_error(dbg, error, DW_DLE_ATTR_FORM_NOT_ADDR_INDEX);\n    return DW_DLV_ERROR;\n}\n\nstatic int\ndw_read_str_index_val_itself(Dwarf_Debug dbg,\n    unsigned theform,\n    Dwarf_Small *info_ptr,\n    Dwarf_Small *section_end,\n    Dwarf_Unsigned *return_index,\n    Dwarf_Error *error)\n{\n    Dwarf_Unsigned index = 0;\n\n    switch(theform) {\n    case DW_FORM_strx:\n    case DW_FORM_GNU_str_index:\n        DECODE_LEB128_UWORD_CK(info_ptr,index,\n            dbg,error,section_end);\n        break;\n    case DW_FORM_strx1:\n        READ_UNALIGNED_CK(dbg, index, Dwarf_Unsigned,\n            info_ptr, 1,\n            error,section_end);\n        break;\n    case DW_FORM_strx2:\n        READ_UNALIGNED_CK(dbg, index, Dwarf_Unsigned,\n            info_ptr, 2,\n            error,section_end);\n        break;\n    case DW_FORM_strx3:\n        READ_UNALIGNED_CK(dbg, index, Dwarf_Unsigned,\n            info_ptr, 3,\n            error,section_end);\n        break;\n    case DW_FORM_strx4:\n        READ_UNALIGNED_CK(dbg, index, Dwarf_Unsigned,\n            info_ptr, 4,\n            error,section_end);\n        break;\n    default:\n        _dwarf_error(dbg, error, DW_DLE_ATTR_FORM_NOT_STR_INDEX);\n        return DW_DLV_ERROR;\n    }\n    *return_index = index;\n    return DW_DLV_OK;\n}\n\n/*  Part of DebugFission.  So a dwarf dumper application\n    can get the index and print it for the user.\n    A convenience function.  New May 2014\n    Also used with DWARF5 forms.  */\nint\ndwarf_get_debug_str_index(Dwarf_Attribute attr,\n    Dwarf_Unsigned *return_index,\n    Dwarf_Error *error)\n{\n    int theform = attr->ar_attribute_form;\n    Dwarf_CU_Context cu_context = 0;\n    Dwarf_Debug dbg = 0;\n    int res  = 0;\n    Dwarf_Byte_Ptr section_end =  0;\n    Dwarf_Unsigned index = 0;\n    Dwarf_Small *info_ptr = 0;\n    int indxres = 0;\n\n    res = get_attr_dbg(&dbg,&cu_context,attr,error);\n    if (res != DW_DLV_OK) {\n        return res;\n    }\n    section_end =\n        _dwarf_calculate_info_section_end_ptr(cu_context);\n    info_ptr = attr->ar_debug_ptr;\n\n    indxres = dw_read_str_index_val_itself(dbg, theform, info_ptr,\n        section_end, &index,error);\n    if (indxres == DW_DLV_OK) {\n        *return_index = index;\n        return indxres;\n    }\n    return indxres;\n}\n\nint\n_dwarf_extract_data16(Dwarf_Debug dbg,\n    Dwarf_Small *data,\n    Dwarf_Small *section_start,\n    Dwarf_Small *section_end,\n    Dwarf_Form_Data16  * returned_val,\n    Dwarf_Error *error)\n{\n    Dwarf_Small *data16end = 0;\n\n    data16end = data + sizeof(Dwarf_Form_Data16);\n    if (data  < section_start ||\n        section_end < data16end) {\n        _dwarf_error(dbg, error,DW_DLE_DATA16_OUTSIDE_SECTION);\n        return DW_DLV_ERROR;\n    }\n    memcpy(returned_val, data, sizeof(*returned_val));\n    return DW_DLV_OK;\n\n}\n\nint\ndwarf_formdata16(Dwarf_Attribute attr,\n    Dwarf_Form_Data16  * returned_val,\n    Dwarf_Error*     error)\n{\n    Dwarf_Half attrform = 0;\n    Dwarf_CU_Context cu_context = 0;\n    Dwarf_Debug dbg = 0;\n    int res  = 0;\n    Dwarf_Small *section_end = 0;\n    Dwarf_Unsigned section_length = 0;\n    Dwarf_Small *section_start = 0;\n\n    if (!attr) {\n        _dwarf_error(NULL, error, DW_DLE_ATTR_NULL);\n        return DW_DLV_ERROR;\n    }\n    if (!returned_val ) {\n        _dwarf_error(NULL, error, DW_DLE_ATTR_NULL);\n        return DW_DLV_ERROR;\n    }\n    res  = get_attr_dbg(&dbg,&cu_context,attr,error);\n    if (res != DW_DLV_OK) {\n        return res;\n    }\n    attrform = attr->ar_attribute_form;\n    if (attrform != DW_FORM_data16) {\n        generate_form_error(dbg,error,attrform,\n            DW_DLE_ATTR_FORM_BAD,\n            \"DW_DLE_ATTR_FORM_BAD\",\n            \"dwarf_formdata16\");\n        return DW_DLV_ERROR;\n    }\n    section_start = _dwarf_calculate_info_section_start_ptr(\n        cu_context,&section_length);\n    section_end = section_start + section_length;\n\n    res = _dwarf_extract_data16(dbg, attr->ar_debug_ptr,\n        section_start, section_end,\n        returned_val,  error);\n    return res;\n}\n\n/*  The *addrx are DWARF5 standard.\n    The GNU form is non-standard gcc DWARF4\n    The LLVM form is the newest. */\nDwarf_Bool\ndwarf_addr_form_is_indexed(int form)\n{\n    switch(form) {\n    case DW_FORM_addrx:\n    case DW_FORM_addrx1:\n    case DW_FORM_addrx2:\n    case DW_FORM_addrx3:\n    case DW_FORM_addrx4:\n    case DW_FORM_GNU_addr_index:\n    case DW_FORM_LLVM_addrx_offset:\n        return TRUE;\n    default: break;\n    }\n    return FALSE;\n}\n\nint\ndwarf_formaddr(Dwarf_Attribute attr,\n    Dwarf_Addr * return_addr, Dwarf_Error * error)\n{\n    Dwarf_Debug dbg = 0;\n    Dwarf_Addr ret_addr = 0;\n    Dwarf_CU_Context cu_context = 0;\n    Dwarf_Half attrform = 0;\n    int res = 0;\n\n    res  = get_attr_dbg(&dbg,&cu_context,attr,error);\n    if (res != DW_DLV_OK) {\n        return res;\n    }\n    attrform = attr->ar_attribute_form;\n    if (dwarf_addr_form_is_indexed(attrform)) {\n        res = _dwarf_look_in_local_and_tied(\n            attrform,\n            cu_context,\n            attr->ar_debug_ptr,\n            return_addr,\n            error);\n        return res;\n    }\n    if (attrform == DW_FORM_addr\n        /*  || attrform == DW_FORM_ref_addr Allowance of\n            DW_FORM_ref_addr was a mistake. The value returned in that\n            case is NOT an address it is a global debug_info\n            offset (ie, not CU-relative offset within the CU\n            in debug_info).\n            The DWARF2 document refers to it as an address\n            (misleadingly) in sec 6.5.4 where it describes\n            the reference form. It is\n            address-sized so that the linker can easily update it, but\n            it is a reference inside the debug_info section. No longer\n            allowed. */\n        ) {\n        Dwarf_Small *section_end =\n            _dwarf_calculate_info_section_end_ptr(cu_context);\n\n        READ_UNALIGNED_CK(dbg, ret_addr, Dwarf_Addr,\n            attr->ar_debug_ptr,\n            cu_context->cc_address_size,\n            error,section_end);\n        *return_addr = ret_addr;\n        return DW_DLV_OK;\n    }\n    generate_form_error(dbg,error,attrform,\n        DW_DLE_ATTR_FORM_BAD,\n        \"DW_DLE_ATTR_FORM_BAD\",\n        \"dwarf_formaddr\");\n    return DW_DLV_ERROR;\n}\n\nint\ndwarf_formflag(Dwarf_Attribute attr,\n    Dwarf_Bool * ret_bool, Dwarf_Error * error)\n{\n    Dwarf_CU_Context cu_context = 0;\n    Dwarf_Debug dbg = 0;\n\n    if (!attr) {\n        _dwarf_error(NULL, error, DW_DLE_ATTR_NULL);\n        return DW_DLV_ERROR;\n    }\n    cu_context = attr->ar_cu_context;\n    if (!cu_context) {\n        _dwarf_error(NULL, error, DW_DLE_ATTR_NO_CU_CONTEXT);\n        return DW_DLV_ERROR;\n    }\n    dbg = cu_context->cc_dbg;\n    if (!dbg || dbg->de_magic != DBG_IS_VALID) {\n        _dwarf_error_string(NULL, error, DW_DLE_ATTR_DBG_NULL,\n            \"DW_DLE_ATTR_DBG_NULL: dwarf_formflag() attribute\"\n            \" passed in has NULL or stale Dwarf_Debug pointer\");\n        return DW_DLV_ERROR;\n    }\n    if (dbg != attr->ar_dbg) {\n        _dwarf_error_string(NULL, error, DW_DLE_ATTR_DBG_NULL,\n            \"DW_DLE_ATTR_DBG_NULL: an attribute and its \"\n            \"cu_context do not have the same Dwarf_Debug\" );\n        return DW_DLV_ERROR;\n    }\n    if (attr->ar_attribute_form == DW_FORM_flag_present) {\n        /*  Implicit means we don't read any data at all. Just\n            the existence of the Form does it. DWARF4. */\n        *ret_bool = 1;\n        return DW_DLV_OK;\n    }\n\n    if (attr->ar_attribute_form == DW_FORM_flag) {\n        *ret_bool = *(Dwarf_Small *)(attr->ar_debug_ptr);\n        return DW_DLV_OK;\n    }\n    generate_form_error(dbg,error,attr->ar_attribute_form,\n        DW_DLE_ATTR_FORM_BAD,\n        \"DW_DLE_ATTR_FORM_BAD\",\n        \"dwarf_formflat\");\n    return DW_DLV_ERROR;\n}\n\nDwarf_Bool\n_dwarf_allow_formudata(unsigned form)\n{\n    switch(form) {\n    case DW_FORM_data1:\n    case DW_FORM_data2:\n    case DW_FORM_data4:\n    case DW_FORM_data8:\n    case DW_FORM_udata:\n    case DW_FORM_loclistx:\n    case DW_FORM_rnglistx:\n        return TRUE;\n    default:\n        break;\n    }\n    return FALSE;\n}\n/*  If the form is DW_FORM_constx and the .debug_addr section\n    is missing, this returns DW_DLV_ERROR and the error number\n    in the Dwarf_Error is  DW_DLE_MISSING_NEEDED_DEBUG_ADDR_SECTION.\n    When that arises, a consumer should call\n    dwarf_get_debug_addr_index() and use that on the appropriate\n    .debug_addr section in the executable or another object.\n\n    Since this accept some signed values, callers\n    must not assume a DW_DLV_OK means\n    the value is unsigned. The form is the first clue here.\n    If DW_FORM_sdata, then signed. Else unknown sign or\n    is unsigned.\n*/\n\nint\n_dwarf_formudata_internal(Dwarf_Debug dbg,\n    Dwarf_Attribute attr,\n    unsigned form,\n    Dwarf_Byte_Ptr data,\n    Dwarf_Byte_Ptr section_end,\n    Dwarf_Unsigned *return_uval,\n    Dwarf_Unsigned *bytes_read,\n    Dwarf_Error *error)\n{\n    Dwarf_Unsigned ret_value = 0;\n\n    switch (form) {\n    case DW_FORM_data1:\n        READ_UNALIGNED_CK(dbg, ret_value, Dwarf_Unsigned,\n            data, sizeof(Dwarf_Small),\n            error,section_end);\n        *return_uval = ret_value;\n        *bytes_read = 1;\n        return DW_DLV_OK;\n\n    /*  READ_UNALIGNED does the right thing as it reads\n        the right number bits and generates host order.\n        So we can just assign to *return_uval. */\n    case DW_FORM_data2:{\n        READ_UNALIGNED_CK(dbg, ret_value, Dwarf_Unsigned,\n            data, DWARF_HALF_SIZE,\n            error,section_end);\n        *return_uval = ret_value;\n        *bytes_read = DWARF_HALF_SIZE;\n        return DW_DLV_OK;\n        }\n\n    case DW_FORM_data4:{\n        READ_UNALIGNED_CK(dbg, ret_value, Dwarf_Unsigned,\n            data,\n            DWARF_32BIT_SIZE,\n            error,section_end);\n        *return_uval = ret_value;\n        *bytes_read = DWARF_32BIT_SIZE;;\n        return DW_DLV_OK;\n        }\n\n    case DW_FORM_data8:{\n        READ_UNALIGNED_CK(dbg, ret_value, Dwarf_Unsigned,\n            data,\n            DWARF_64BIT_SIZE,\n            error,section_end);\n        *return_uval = ret_value;\n        *bytes_read = DWARF_64BIT_SIZE;\n        return DW_DLV_OK;\n        }\n        break;\n    /* real udata */\n    case DW_FORM_loclistx:\n    case DW_FORM_rnglistx:\n    case DW_FORM_udata: {\n        Dwarf_Unsigned leblen = 0;\n        DECODE_LEB128_UWORD_LEN_CK(data, ret_value,leblen,\n            dbg,error,section_end);\n        *return_uval = ret_value;\n        *bytes_read = leblen;\n        return DW_DLV_OK;\n    }\n    /*  IRIX bug 583450. We do not allow reading\n        sdata from a udata\n        value. Caller can retry, calling sdata */\n    default:\n        break;\n    }\n    if (attr) {\n        int res = 0;\n        Dwarf_Signed s = 0;\n        res = dwarf_formsdata(attr,&s,error);\n        if (res != DW_DLV_OK) {\n            return res;\n        }\n        if (s < 0 ) {\n            _dwarf_error(dbg, error, DW_DLE_UDATA_VALUE_NEGATIVE);\n            return DW_DLV_ERROR;\n        }\n        *return_uval = (Dwarf_Unsigned)s;\n        *bytes_read = 0;\n        return DW_DLV_OK;\n    }\n    generate_form_error(dbg,error,form,\n        DW_DLE_ATTR_FORM_BAD,\n        \"DW_DLE_ATTR_FORM_BAD\",\n        \"formudata (internal function)\");\n    return DW_DLV_ERROR;\n}\n\nint\ndwarf_formudata(Dwarf_Attribute attr,\n    Dwarf_Unsigned * return_uval, Dwarf_Error * error)\n{\n    Dwarf_Debug dbg = 0;\n    Dwarf_CU_Context cu_context = 0;\n    Dwarf_Byte_Ptr section_end = 0;\n    Dwarf_Unsigned bytes_read = 0;\n    Dwarf_Byte_Ptr data =  attr->ar_debug_ptr;\n    unsigned form = 0;\n\n    int res  = get_attr_dbg(&dbg,&cu_context,attr,error);\n    if (res != DW_DLV_OK) {\n        return res;\n    }\n    section_end =\n        _dwarf_calculate_info_section_end_ptr(cu_context);\n    form = attr->ar_attribute_form;\n\n    res = _dwarf_formudata_internal(dbg,\n        attr,\n        form, data, section_end, return_uval,\n        &bytes_read, error);\n    return res;\n}\n\nint\ndwarf_formsdata(Dwarf_Attribute attr,\n    Dwarf_Signed * return_sval, Dwarf_Error * error)\n{\n    Dwarf_Signed ret_value = 0;\n    Dwarf_Debug dbg = 0;\n    Dwarf_CU_Context cu_context = 0;\n    Dwarf_Byte_Ptr section_end = 0;\n\n    int res  = get_attr_dbg(&dbg,&cu_context,attr,error);\n    if (res != DW_DLV_OK) {\n        return res;\n    }\n    section_end =\n        _dwarf_calculate_info_section_end_ptr(cu_context);\n    switch (attr->ar_attribute_form) {\n\n    case DW_FORM_data1:\n        if ( attr->ar_debug_ptr >= section_end) {\n            _dwarf_error(dbg, error, DW_DLE_DIE_BAD);\n            return DW_DLV_ERROR;\n        }\n        *return_sval = (*(Dwarf_Sbyte *) attr->ar_debug_ptr);\n        return DW_DLV_OK;\n\n    /*  READ_UNALIGNED does not sign extend.\n        So we have to use a cast to get the\n        value sign extended in the right way for each case. */\n    case DW_FORM_data2:{\n        READ_UNALIGNED_CK(dbg, ret_value, Dwarf_Signed,\n            attr->ar_debug_ptr,\n            DWARF_HALF_SIZE,\n            error,section_end);\n        *return_sval = (Dwarf_Shalf) ret_value;\n        return DW_DLV_OK;\n\n        }\n\n    case DW_FORM_data4:{\n        READ_UNALIGNED_CK(dbg, ret_value, Dwarf_Signed,\n            attr->ar_debug_ptr,\n            DWARF_32BIT_SIZE,\n            error,section_end);\n        SIGN_EXTEND(ret_value,DWARF_32BIT_SIZE);\n        *return_sval = (Dwarf_Signed) ret_value;\n        return DW_DLV_OK;\n        }\n\n    case DW_FORM_data8:{\n        READ_UNALIGNED_CK(dbg, ret_value, Dwarf_Signed,\n            attr->ar_debug_ptr,\n            DWARF_64BIT_SIZE,\n            error,section_end);\n        /* No SIGN_EXTEND needed, we are filling all bytes already.*/\n        *return_sval = (Dwarf_Signed) ret_value;\n        return DW_DLV_OK;\n        }\n\n    /*  DW_FORM_implicit_const  is a value in the\n        abbreviations, not in the DIEs. */\n    case DW_FORM_implicit_const:\n        *return_sval = attr->ar_implicit_const;\n        return DW_DLV_OK;\n\n    case DW_FORM_sdata: {\n        Dwarf_Byte_Ptr tmp = attr->ar_debug_ptr;\n\n        DECODE_LEB128_SWORD_CK(tmp, ret_value,\n            dbg,error,section_end);\n        *return_sval = ret_value;\n        return DW_DLV_OK;\n\n    }\n\n        /* IRIX bug 583450. We do not allow reading sdata from a udata\n            value. Caller can retry, calling udata */\n\n    default:\n        break;\n    }\n    generate_form_error(dbg,error,attr->ar_attribute_form,\n        DW_DLE_ATTR_FORM_BAD,\n        \"DW_DLE_ATTR_FORM_BAD\",\n        \"dwarf_formsdata\");\n    return DW_DLV_ERROR;\n}\n\nint\n_dwarf_formblock_internal(Dwarf_Debug dbg,\n    Dwarf_Attribute attr,\n    Dwarf_CU_Context cu_context,\n    Dwarf_Block * return_block,\n    Dwarf_Error * error)\n{\n    Dwarf_Small *section_start = 0;\n    Dwarf_Small *section_end = 0;\n    Dwarf_Unsigned section_length = 0;\n    Dwarf_Unsigned length = 0;\n    Dwarf_Small *data = 0;\n\n    section_end =\n        _dwarf_calculate_info_section_end_ptr(cu_context);\n    section_start =\n        _dwarf_calculate_info_section_start_ptr(cu_context,\n        &section_length);\n\n    switch (attr->ar_attribute_form) {\n\n    case DW_FORM_block1:\n        length = *(Dwarf_Small *) attr->ar_debug_ptr;\n        data = attr->ar_debug_ptr + sizeof(Dwarf_Small);\n        break;\n\n    case DW_FORM_block2:\n        READ_UNALIGNED_CK(dbg, length, Dwarf_Unsigned,\n            attr->ar_debug_ptr, DWARF_HALF_SIZE,\n            error,section_end);\n        data = attr->ar_debug_ptr + DWARF_HALF_SIZE;\n        break;\n\n    case DW_FORM_block4:\n        READ_UNALIGNED_CK(dbg, length, Dwarf_Unsigned,\n            attr->ar_debug_ptr, DWARF_32BIT_SIZE,\n            error,section_end);\n        data = attr->ar_debug_ptr + DWARF_32BIT_SIZE;\n        break;\n\n    case DW_FORM_exprloc:\n    case DW_FORM_block: {\n        Dwarf_Byte_Ptr tmp = attr->ar_debug_ptr;\n        Dwarf_Unsigned leblen = 0;\n\n        DECODE_LEB128_UWORD_LEN_CK(tmp, length, leblen,\n            dbg,error,section_end);\n        data = attr->ar_debug_ptr + leblen;\n        break;\n        }\n    default:\n        generate_form_error(dbg,error,attr->ar_attribute_form,\n            DW_DLE_ATTR_FORM_BAD,\n            \"DW_DLE_ATTR_FORM_BAD\",\n            \"dwarf_formblock\");\n        return DW_DLV_ERROR;\n    }\n    /*  We have the data. Check for errors. */\n    if (length >= section_length) {\n        /*  Sanity test looking for wraparound:\n            when length actually added in\n            it would not be caught.\n            Test could be just >, but >= ok here too.*/\n        _dwarf_error_string(dbg, error,\n            DW_DLE_FORM_BLOCK_LENGTH_ERROR,\n            \"DW_DLE_FORM_BLOCK_LENGTH_ERROR: \"\n            \"The length of the block is greater \"\n            \"than the section length! Corrupt Dwarf.\");\n        return DW_DLV_ERROR;\n    }\n    if ((attr->ar_debug_ptr + length) > section_end) {\n        _dwarf_error_string(dbg, error,\n            DW_DLE_FORM_BLOCK_LENGTH_ERROR,\n            \"DW_DLE_FORM_BLOCK_LENGTH_ERROR: \"\n            \"The block length means the block \"\n            \"runs off the end of the section length!\"\n            \" Corrupt Dwarf.\");\n        return DW_DLV_ERROR;\n    }\n    if (data > section_end) {\n        _dwarf_error_string(dbg, error,\n            DW_DLE_FORM_BLOCK_LENGTH_ERROR,\n            \"DW_DLE_FORM_BLOCK_LENGTH_ERROR: \"\n            \"The block content is \"\n            \"past the end of the section!\"\n            \" Corrupt Dwarf.\");\n        _dwarf_error(dbg, error, DW_DLE_FORM_BLOCK_LENGTH_ERROR);\n        return DW_DLV_ERROR;\n    }\n    if ((data + length) > section_end) {\n        _dwarf_error_string(dbg, error,\n            DW_DLE_FORM_BLOCK_LENGTH_ERROR,\n            \"DW_DLE_FORM_BLOCK_LENGTH_ERROR: \"\n            \"The end of the block content is \"\n            \"past the end of the section!\"\n            \" Corrupt Dwarf.\");\n        return DW_DLV_ERROR;\n    }\n    return_block->bl_len = length;\n    return_block->bl_data = data;\n    /*  This struct is public so use the old name instead\n        of what we now would call it:  bl_kind  */\n    return_block->bl_from_loclist =  DW_LKIND_expression;\n    return_block->bl_section_offset =  data - section_start;\n    return DW_DLV_OK;\n}\n\nint\ndwarf_formblock(Dwarf_Attribute attr,\n    Dwarf_Block ** return_block, Dwarf_Error * error)\n{\n    Dwarf_CU_Context cu_context = 0;\n    Dwarf_Debug dbg = 0;\n    Dwarf_Block local_block;\n    Dwarf_Block *out_block = 0;\n    int res = 0;\n\n    memset(&local_block,0,sizeof(local_block));\n    res  = get_attr_dbg(&dbg,&cu_context,attr,error);\n    if (res != DW_DLV_OK) {\n        return res;\n    }\n    res = _dwarf_formblock_internal(dbg,attr,\n        cu_context, &local_block, error);\n    if (res != DW_DLV_OK) {\n        return res;\n    }\n    out_block = (Dwarf_Block *)\n        _dwarf_get_alloc(dbg, DW_DLA_BLOCK, 1);\n    if (!out_block) {\n        _dwarf_error(dbg, error, DW_DLE_ALLOC_FAIL);\n        return DW_DLV_ERROR;\n    }\n    *out_block = local_block;\n    *return_block = out_block;\n    return DW_DLV_OK;\n}\n\nint\n_dwarf_extract_string_offset_via_str_offsets(Dwarf_Debug dbg,\n    Dwarf_Small *data_ptr,\n    Dwarf_Small *end_data_ptr,\n    Dwarf_Half   attrnum UNUSEDARG,\n    Dwarf_Half   attrform,\n    Dwarf_CU_Context cu_context,\n    Dwarf_Unsigned *str_sect_offset_out,\n    Dwarf_Error *error)\n{\n    Dwarf_Unsigned index_to_offset_entry = 0;\n    Dwarf_Unsigned offsetintable = 0;\n    Dwarf_Unsigned end_offsetintable = 0;\n    Dwarf_Unsigned indexoffset = 0;\n    Dwarf_Unsigned baseoffset = 0;\n    int res = 0;\n    int idxres = 0;\n    Dwarf_Small *sof_start = 0;\n    Dwarf_Unsigned sof_len = 0;\n    Dwarf_Small   *sof_end = 0;\n\n    res = _dwarf_load_section(dbg, &dbg->de_debug_str_offsets,error);\n    if (res != DW_DLV_OK) {\n        return res;\n    }\n    /*  If this is a dwp we look there, but I suppose\n        we could also look for the section in the tied\n        file it is not here. */\n    sof_start = dbg->de_debug_str_offsets.dss_data;\n    sof_len = dbg->de_debug_str_offsets.dss_size;\n    sof_end = sof_start+sof_len;\n    idxres = dw_read_str_index_val_itself(dbg,\n        attrform,data_ptr,end_data_ptr,&index_to_offset_entry,error);\n    if ( idxres != DW_DLV_OK) {\n        return idxres;\n    }\n\n    if (cu_context->cc_str_offsets_base_present) {\n        baseoffset = cu_context->cc_str_offsets_base;\n    }\n    indexoffset = index_to_offset_entry*\n        cu_context->cc_length_size;\n    baseoffset = cu_context->cc_str_offsets_base;\n    if (!baseoffset) {\n        if (cu_context->cc_version_stamp ==  DW_CU_VERSION5 ) {\n            /*  A base offset of 0 isnormally never correct for\n                DWARF5. but some early GNU compilers emitted\n                DWARF4 .debug_str_offsets, so lets check\n                the first table.  */\n            Dwarf_Small * ststart =\n                dbg->de_debug_str_offsets.dss_data;\n            Dwarf_Small * stend = 0;\n            Dwarf_Unsigned  stsize =\n                dbg->de_debug_str_offsets.dss_size;\n            Dwarf_Unsigned length            = 0;\n            Dwarf_Half local_offset_size = 0;\n            Dwarf_Half local_extension_size = 0;\n            Dwarf_Half version               = 0;\n            Dwarf_Half padding               = 0;\n\n            stend = ststart + stsize;\n            res = _dwarf_trial_read_dwarf_five_hdr(dbg,\n                ststart,stsize,stend,\n                &length, &local_offset_size,\n                &local_extension_size,\n                &version,\n                &padding,\n                error);\n            if (res == DW_DLV_OK) {\n                baseoffset = local_extension_size +\n                    local_offset_size +\n                    2*DWARF_HALF_SIZE;\n            } else {\n                if (res == DW_DLV_ERROR) {\n                    dwarf_dealloc_error(dbg,*error);\n                    *error = 0;\n                } else {}\n            }\n        }\n    }\n    offsetintable = baseoffset +indexoffset;\n    end_offsetintable = offsetintable +\n        cu_context->cc_str_offsets_offset_size;\n    /*  The offsets table is a series of offset-size entries.\n        The == case in the test applies when we are at the last table\n        entry, so == is not an error, hence only test >\n    */\n    if (end_offsetintable > dbg->de_debug_str_offsets.dss_size ) {\n        dwarfstring m;\n\n        dwarfstring_constructor(&m);\n        dwarfstring_append_printf_u(&m,\n            \"DW_DLE_ATTR_FORM_SIZE_BAD: The end offset of \"\n            \"a .debug_str_offsets table is 0x%x \",\n            end_offsetintable);\n        dwarfstring_append_printf_u(&m,\n            \"but the object section is just 0x%x \"\n            \"bytes long\",\n            dbg->de_debug_str_offsets.dss_size);\n        _dwarf_error_string(dbg, error,\n            DW_DLE_ATTR_FORM_SIZE_BAD,\n            dwarfstring_string(&m));\n        dwarfstring_destructor(&m);\n        return DW_DLV_ERROR;\n    }\n\n    {\n        Dwarf_Unsigned offsettostr = baseoffset+offsetintable;\n\n        /* Now read the string offset from the offset table. */\n        READ_UNALIGNED_CK(dbg,offsettostr,Dwarf_Unsigned,\n            sof_start+ offsetintable,\n            cu_context->cc_length_size,error,sof_end);\n        *str_sect_offset_out = offsettostr;\n    }\n    return DW_DLV_OK;\n}\n\nint\n_dwarf_extract_local_debug_str_string_given_offset(Dwarf_Debug dbg,\n    unsigned attrform,\n    Dwarf_Unsigned offset,\n    char ** return_str,\n    Dwarf_Error * error)\n{\n    if (attrform == DW_FORM_strp ||\n        attrform == DW_FORM_line_strp ||\n        attrform == DW_FORM_GNU_str_index ||\n        attrform == DW_FORM_strx1 ||\n        attrform == DW_FORM_strx2 ||\n        attrform == DW_FORM_strx3 ||\n        attrform == DW_FORM_strx4 ||\n        attrform == DW_FORM_strx) {\n        /*  The 'offset' into .debug_str or .debug_line_str is given,\n            here we turn that into a pointer. */\n        Dwarf_Small   *secend = 0;\n        Dwarf_Small   *secbegin = 0;\n        Dwarf_Small   *strbegin = 0;\n        Dwarf_Unsigned secsize = 0;\n        int errcode = 0;\n        const char *errname = 0;\n        int res = 0;\n\n        if (attrform == DW_FORM_line_strp) {\n            res = _dwarf_load_section(dbg,\n                &dbg->de_debug_line_str,error);\n            if (res != DW_DLV_OK) {\n                return res;\n            }\n            errcode = DW_DLE_STRP_OFFSET_BAD;\n            errname = \"DW_DLE_STRP_OFFSET_BAD\";\n            secsize = dbg->de_debug_line_str.dss_size;\n            secbegin = dbg->de_debug_line_str.dss_data;\n            strbegin= dbg->de_debug_line_str.dss_data + offset;\n            secend = dbg->de_debug_line_str.dss_data + secsize;\n        } else {\n            /* DW_FORM_strp  etc */\n            res = _dwarf_load_section(dbg, &dbg->de_debug_str,error);\n            if (res != DW_DLV_OK) {\n                return res;\n            }\n            errcode = DW_DLE_STRING_OFFSET_BAD;\n            errname = \"DW_DLE_STRING_OFFSET_BAD\";\n            secsize = dbg->de_debug_str.dss_size;\n            secbegin = dbg->de_debug_str.dss_data;\n            strbegin= dbg->de_debug_str.dss_data + offset;\n            secend = dbg->de_debug_str.dss_data + secsize;\n        }\n        if (offset >= secsize) {\n            dwarfstring m;\n            const char *name = \"<unknownform>\";\n\n            dwarf_get_FORM_name(attrform,&name);\n\n            dwarfstring_constructor(&m);\n            dwarfstring_append(&m,(char *)errname);\n            dwarfstring_append_printf_s(&m,\n                \" Form %s \",(char *)name);\n            dwarfstring_append_printf_u(&m,\n                \"string offset of 0x%\" DW_PR_DUx \" \",\n                offset);\n            dwarfstring_append_printf_u(&m,\n                \"is larger than the string section \"\n                \"size of  0x%\" DW_PR_DUx,\n                secsize);\n            _dwarf_error_string(dbg, error, errcode,\n                dwarfstring_string(&m));\n            dwarfstring_destructor(&m);\n            /*  Badly damaged DWARF here. */\n            return DW_DLV_ERROR;\n        }\n        res= _dwarf_check_string_valid(dbg,secbegin,strbegin, secend,\n            errcode,error);\n        if (res != DW_DLV_OK) {\n            return res;\n        }\n\n        *return_str = (char *)strbegin;\n        return DW_DLV_OK;\n    }\n    generate_form_error(dbg,error,attrform,\n        DW_DLE_ATTR_FORM_BAD,\n        \"DW_DLE_ATTR_FORM_BAD\",\n        \"extract debug_str string\");\n    return DW_DLV_ERROR;\n}\n\n/* Contrary to pre-2005 documentation,\n   The string pointer returned thru return_str must\n   never have dwarf_dealloc() applied to it.\n   Documentation fixed July 2005.\n*/\nint\ndwarf_formstring(Dwarf_Attribute attr,\n    char **return_str, Dwarf_Error * error)\n{\n    Dwarf_CU_Context cu_context = 0;\n    Dwarf_Debug dbg = 0;\n    Dwarf_Unsigned offset = 0;\n    int res = DW_DLV_ERROR;\n    Dwarf_Small *secdataptr = 0;\n    Dwarf_Small *secend = 0;\n    Dwarf_Unsigned secdatalen = 0;\n    Dwarf_Small *infoptr = attr->ar_debug_ptr;\n    Dwarf_Small *contextend = 0;\n\n    res  = get_attr_dbg(&dbg,&cu_context,attr,error);\n    if (res != DW_DLV_OK) {\n        return res;\n    }\n    if (cu_context->cc_is_info) {\n        secdataptr = (Dwarf_Small *)dbg->de_debug_info.dss_data;\n        secdatalen = dbg->de_debug_info.dss_size;\n    } else {\n        secdataptr = (Dwarf_Small *)dbg->de_debug_types.dss_data;\n        secdatalen = dbg->de_debug_types.dss_size;\n    }\n    contextend = secdataptr +\n        cu_context->cc_debug_offset +\n        cu_context->cc_length +\n        cu_context->cc_length_size +\n        cu_context->cc_extension_size;\n    secend = secdataptr + secdatalen;\n    if (contextend < secend) {\n        secend = contextend;\n    }\n    switch(attr->ar_attribute_form) {\n    case DW_FORM_string: {\n        Dwarf_Small *begin = attr->ar_debug_ptr;\n\n        res= _dwarf_check_string_valid(dbg,secdataptr,begin, secend,\n            DW_DLE_FORM_STRING_BAD_STRING,error);\n        if (res != DW_DLV_OK) {\n            return res;\n        }\n        *return_str = (char *) (begin);\n        return DW_DLV_OK;\n    }\n    case DW_FORM_GNU_strp_alt:\n    case DW_FORM_strp_sup:  {\n        Dwarf_Error alterr = 0;\n        Dwarf_Bool is_info = TRUE;\n        /*  See dwarfstd.org issue 120604.1\n            This is the offset in the .debug_str section\n            of another object file.\n            The 'tied' file notion should apply.\n            It is not clear whether both a supplementary\n            and a split object might be needed at the same time\n            (hence two 'tied' files simultaneously). */\n        Dwarf_Off soffset = 0;\n\n        res = dwarf_global_formref_b(attr, &soffset,\n            &is_info,error);\n        if (res != DW_DLV_OK) {\n            return res;\n        }\n        res = _dwarf_get_string_from_tied(dbg, soffset,\n            return_str, &alterr);\n        if (res == DW_DLV_ERROR) {\n            if (dwarf_errno(alterr) ==\n                DW_DLE_NO_TIED_FILE_AVAILABLE) {\n                dwarf_dealloc(dbg,alterr,DW_DLA_ERROR);\n                if ( attr->ar_attribute_form ==\n                    DW_FORM_GNU_strp_alt) {\n                    *return_str =\n                        (char *)\"<DW_FORM_GNU_strp_alt-no-tied-file>\";\n                } else {\n                    *return_str =\n                        (char *)\"<DW_FORM_strp_sup-no-tied-file>\";\n                }\n                return DW_DLV_OK;\n            }\n            if (error) {\n                *error = alterr;\n            } else {\n                dwarf_dealloc_error(dbg,alterr);\n                alterr = 0;\n            }\n            return res;\n        }\n        if (res == DW_DLV_NO_ENTRY) {\n            if ( attr->ar_attribute_form == DW_FORM_GNU_strp_alt) {\n                *return_str =\n                    (char *)\"<DW_FORM_GNU_strp_alt-no-tied-file>\";\n            }else {\n                *return_str =\n                    (char *)\"<DW_FORM_strp_sup-no-tied-file>\";\n            }\n        }\n        return res;\n    }\n    case DW_FORM_GNU_str_index:\n    case DW_FORM_strx:\n    case DW_FORM_strx1:\n    case DW_FORM_strx2:\n    case DW_FORM_strx3:\n    case DW_FORM_strx4: {\n        Dwarf_Unsigned offsettostr= 0;\n\n        res = _dwarf_extract_string_offset_via_str_offsets(dbg,\n            infoptr,\n            secend,\n            attr->ar_attribute,\n            attr->ar_attribute_form,\n            cu_context,\n            &offsettostr,\n            error);\n        if (res != DW_DLV_OK) {\n            return res;\n        }\n        offset = offsettostr;\n        break;\n    }\n    case DW_FORM_strp:\n    case DW_FORM_line_strp:{\n        READ_UNALIGNED_CK(dbg, offset, Dwarf_Unsigned,\n            infoptr,\n            cu_context->cc_length_size,error,secend);\n        break;\n    }\n    default:\n        _dwarf_error(dbg, error, DW_DLE_STRING_FORM_IMPROPER);\n        return DW_DLV_ERROR;\n    }\n    /*  Now we have offset so read the string from\n        debug_str or debug_line_str. */\n    res = _dwarf_extract_local_debug_str_string_given_offset(dbg,\n        attr->ar_attribute_form,\n        offset,\n        return_str,\n        error);\n    return res;\n}\n\nint\n_dwarf_get_string_from_tied(Dwarf_Debug dbg,\n    Dwarf_Unsigned offset,\n    char **return_str,\n    Dwarf_Error*error)\n{\n    Dwarf_Debug tieddbg = 0;\n    Dwarf_Small *secend = 0;\n    Dwarf_Small *secbegin = 0;\n    Dwarf_Small *strbegin = 0;\n    int res = DW_DLV_ERROR;\n    Dwarf_Error localerror = 0;\n\n    /* Attach errors to dbg, not tieddbg. */\n    tieddbg = dbg->de_tied_data.td_tied_object;\n    if (!tieddbg) {\n        _dwarf_error(dbg, error, DW_DLE_NO_TIED_FILE_AVAILABLE);\n        return  DW_DLV_ERROR;\n    }\n    /* The 'offset' into .debug_str is set. */\n    res = _dwarf_load_section(tieddbg, &tieddbg->de_debug_str,\n        &localerror);\n    if (res == DW_DLV_ERROR) {\n        Dwarf_Unsigned lerrno = dwarf_errno(localerror);\n        dwarf_dealloc(tieddbg,localerror,DW_DLA_ERROR);\n        _dwarf_error(dbg,error,lerrno);\n        return res;\n    }\n    if (res == DW_DLV_NO_ENTRY) {\n        return res;\n    }\n    if (offset >= tieddbg->de_debug_str.dss_size) {\n        /*  Badly damaged DWARF here. */\n        _dwarf_error(dbg, error,  DW_DLE_NO_TIED_STRING_AVAILABLE);\n        return DW_DLV_ERROR;\n    }\n    secbegin = tieddbg->de_debug_str.dss_data;\n    strbegin= tieddbg->de_debug_str.dss_data + offset;\n    secend = tieddbg->de_debug_str.dss_data +\n        tieddbg->de_debug_str.dss_size;\n\n    /*  Ensure the offset lies within the .debug_str */\n    if (offset >= tieddbg->de_debug_str.dss_size) {\n        _dwarf_error(dbg, error,  DW_DLE_NO_TIED_STRING_AVAILABLE);\n        return DW_DLV_ERROR;\n    }\n    res= _dwarf_check_string_valid(tieddbg,secbegin,strbegin, secend,\n        DW_DLE_NO_TIED_STRING_AVAILABLE,\n        &localerror);\n    if (res == DW_DLV_ERROR) {\n        Dwarf_Unsigned lerrno = dwarf_errno(localerror);\n        dwarf_dealloc(tieddbg,localerror,DW_DLA_ERROR);\n        _dwarf_error(dbg,error,lerrno);\n        return res;\n    }\n    if (res == DW_DLV_NO_ENTRY) {\n        return res;\n    }\n    *return_str = (char *) (tieddbg->de_debug_str.dss_data + offset);\n    return DW_DLV_OK;\n}\n\nint\ndwarf_formexprloc(Dwarf_Attribute attr,\n    Dwarf_Unsigned * return_exprlen,\n    Dwarf_Ptr  * block_ptr,\n    Dwarf_Error * error)\n{\n    Dwarf_Debug dbg = 0;\n    Dwarf_CU_Context cu_context = 0;\n\n    int res  = get_attr_dbg(&dbg,&cu_context,attr,error);\n    if (res != DW_DLV_OK) {\n        return res;\n    }\n    if (attr->ar_attribute_form == DW_FORM_exprloc ) {\n        Dwarf_Die die = 0;\n        Dwarf_Unsigned leb_len = 0;\n        Dwarf_Byte_Ptr section_start = 0;\n        Dwarf_Unsigned section_len = 0;\n        Dwarf_Byte_Ptr section_end = 0;\n        Dwarf_Byte_Ptr info_ptr = 0;\n        Dwarf_Unsigned exprlen = 0;\n        Dwarf_Small * addr = attr->ar_debug_ptr;\n\n        info_ptr = addr;\n        section_start =\n            _dwarf_calculate_info_section_start_ptr(cu_context,\n            &section_len);\n        section_end = section_start + section_len;\n\n        DECODE_LEB128_UWORD_LEN_CK(info_ptr, exprlen, leb_len,\n            dbg,error,section_end);\n        if (exprlen > section_len) {\n            /* Corrupted dwarf!  */\n            dwarfstring m;\n\n            dwarfstring_constructor(&m);\n            dwarfstring_append_printf_u(&m,\n                \"DW_DLE_ATTR_OUTSIDE_SECTION: \"\n                \"The expression length is %u,\",exprlen);\n            dwarfstring_append_printf_u(&m,\n                \" but the section length is just %u. \"\n                \"Corrupt Dwarf.\",section_len);\n            _dwarf_error_string(dbg, error,\n                DW_DLE_ATTR_OUTSIDE_SECTION,\n                dwarfstring_string(&m));\n            dwarfstring_destructor(&m);\n            return DW_DLV_ERROR;\n        }\n        die = attr->ar_die;\n        /*  Is the block entirely in the section, or is\n            there bug somewhere?\n            Here the final addr may be 1 past end of section. */\n        if (_dwarf_reference_outside_section(die,\n            (Dwarf_Small *)addr,\n            ((Dwarf_Small *)addr)+exprlen +leb_len)) {\n            dwarfstring m;\n\n            dwarfstring_constructor(&m);\n            dwarfstring_append_printf_u(&m,\n                \"DW_DLE_ATTR_OUTSIDE_SECTION: \"\n                \"The expression length %u,\",exprlen);\n            dwarfstring_append_printf_u(&m,\n                \" plus the leb value length of \"\n                \"%u \",leb_len);\n            dwarfstring_append(&m,\n                \" runs past the end of the section. \"\n                \"Corrupt Dwarf.\");\n            _dwarf_error_string(dbg, error,\n                DW_DLE_ATTR_OUTSIDE_SECTION,\n                dwarfstring_string(&m));\n            dwarfstring_destructor(&m);\n            return DW_DLV_ERROR;\n        }\n        *return_exprlen = exprlen;\n        *block_ptr = addr + leb_len;\n        return DW_DLV_OK;\n\n    }\n    {\n        dwarfstring m;\n        const char *name = \"<name not known>\";\n        unsigned  mform = attr->ar_attribute_form;\n\n        dwarfstring_constructor(&m);\n\n        dwarf_get_FORM_name (mform,&name);\n        dwarfstring_append_printf_u(&m,\n            \"DW_DLE_ATTR_EXPRLOC_FORM_BAD: \"\n            \"The form is 0x%x \", mform);\n        dwarfstring_append_printf_s(&m,\n            \"(%s) but should be DW_FORM_exprloc. \"\n            \"Corrupt Dwarf.\",(char *)name);\n        _dwarf_error_string(dbg, error, DW_DLE_ATTR_EXPRLOC_FORM_BAD,\n            dwarfstring_string(&m));\n        dwarfstring_destructor(&m);\n    }\n    return DW_DLV_ERROR;\n}\n"], "fixing_code": ["/*\n  Copyright (C) 2000,2002,2004,2005 Silicon Graphics, Inc. All Rights Reserved.\n  Portions Copyright 2007-2010 Sun Microsystems, Inc. All rights reserved.\n  Portions Copyright 2008-2021 David Anderson. All rights reserved.\n  Portions Copyright 2010-2012 SN Systems Ltd. All rights reserved.\n\n  This program is free software; you can redistribute it\n  and/or modify it under the terms of version 2.1 of the\n  GNU Lesser General Public License as published by the Free\n  Software Foundation.\n\n  This program is distributed in the hope that it would be\n  useful, but WITHOUT ANY WARRANTY; without even the implied\n  warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n  PURPOSE.\n\n  Further, this software is distributed without any warranty\n  that it is free of the rightful claim of any third person\n  regarding infringement or the like.  Any license provided\n  herein, whether implied or otherwise, applies only to this\n  software file.  Patent licenses, if any, provided herein\n  do not apply to combinations of this program with other\n  software, or any other product whatsoever.\n\n  You should have received a copy of the GNU Lesser General\n  Public License along with this program; if not, write the\n  Free Software Foundation, Inc., 51 Franklin Street - Fifth\n  Floor, Boston MA 02110-1301, USA.\n\n*/\n\n#include <config.h>\n\n#include <string.h>  /* memcpy() memset() */\n\n#if defined(_WIN32) && defined(HAVE_STDAFX_H)\n#include \"stdafx.h\"\n#endif /* HAVE_STDAFX_H */\n\n#include \"dwarf.h\"\n#include \"libdwarf.h\"\n#include \"libdwarf_private.h\"\n#include \"dwarf_base_types.h\"\n#include \"dwarf_opaque.h\"\n#include \"dwarf_alloc.h\"\n#include \"dwarf_string.h\"\n#include \"dwarf_error.h\"\n#include \"dwarf_util.h\"\n#include \"dwarf_die_deliv.h\"\n#include \"dwarf_str_offsets.h\"\n#include \"dwarf_string.h\"\n\n/*  It is necessary at times to cause errors of this sort\n    in determining what we really have.  So best to avoid\n    too much malloc and free, hence the static constructor\n    dwarfstring will use malloc if we guess too-small\n    for the size of mbuf. */\nstatic void\ngenerate_form_error(Dwarf_Debug dbg,\n    Dwarf_Error *error,\n    unsigned form,\n    int err_code,\n    const char *errname,\n    const char *funcname)\n{\n    dwarfstring m;\n    char mbuf[DWARFSTRING_ALLOC_SIZE];\n    const char * defaultname = \"<unknown form>\";\n\n    dwarfstring_constructor_static(&m,mbuf,\n        sizeof(mbuf));\n    dwarfstring_append(&m,(char *)errname);\n    dwarfstring_append(&m,\": In function \");\n    dwarfstring_append(&m,(char *)funcname);\n    dwarfstring_append_printf_u(&m,\n        \" on seeing form  0x%x \",form);\n    dwarf_get_FORM_name(form,&defaultname);\n    dwarfstring_append_printf_s(&m,\n        \" (%s)\",(char *)defaultname);\n    _dwarf_error_string(dbg,error,err_code,\n        dwarfstring_string(&m));\n    dwarfstring_destructor(&m);\n}\n\n/*  This code was repeated many times, now it\n    is all in one place.\n    Never returns DW_DLV_NO_ENTRY  */\nstatic int\nget_attr_dbg(Dwarf_Debug *dbg_out,\n    Dwarf_CU_Context * cu_context_out,\n    Dwarf_Attribute attr,\n    Dwarf_Error *error)\n{\n    Dwarf_CU_Context cup = 0;\n    Dwarf_Debug dbg = 0;\n\n    if (!attr) {\n        _dwarf_error(NULL, error, DW_DLE_ATTR_NULL);\n        return DW_DLV_ERROR;\n    }\n    cup = attr->ar_cu_context;\n    if (!cup) {\n        _dwarf_error(NULL, error, DW_DLE_ATTR_NO_CU_CONTEXT);\n        return DW_DLV_ERROR;\n    }\n    dbg = cup->cc_dbg;\n    if (!dbg  || dbg->de_magic != DBG_IS_VALID) {\n        _dwarf_error_string(NULL, error, DW_DLE_ATTR_DBG_NULL,\n            \"DW_DLE_ATTR_DBG_NULL: Stale or null Dwarf_Debug\"\n            \"in a Dwarf_CU_Context\" );\n        return DW_DLV_ERROR;\n    }\n    if (dbg != attr->ar_dbg) {\n        _dwarf_error_string(NULL, error, DW_DLE_ATTR_DBG_NULL,\n            \"DW_DLE_ATTR_DBG_NULL: an attribute and its \"\n            \"cu_context do not have the same Dwarf_Debug\" );\n        return DW_DLV_ERROR;\n    }\n    *cu_context_out = cup;\n    *dbg_out        = dbg;\n    return DW_DLV_OK;\n\n}\n\nint\ndwarf_hasform(Dwarf_Attribute attr,\n    Dwarf_Half form,\n    Dwarf_Bool * return_bool, Dwarf_Error * error)\n{\n    Dwarf_Debug dbg = 0;\n    Dwarf_CU_Context cu_context = 0;\n\n    int res  =get_attr_dbg(&dbg,&cu_context, attr,error);\n    if (res != DW_DLV_OK) {\n        return res;\n    }\n    *return_bool = (attr->ar_attribute_form == form);\n    return DW_DLV_OK;\n}\n\n/* Not often called, we do not worry about efficiency here.\n   The dwarf_whatform() call does the sanity checks for us.\n*/\nint\ndwarf_whatform_direct(Dwarf_Attribute attr,\n    Dwarf_Half * return_form, Dwarf_Error * error)\n{\n    int res = dwarf_whatform(attr, return_form, error);\n\n    if (res != DW_DLV_OK) {\n        return res;\n    }\n\n    *return_form = attr->ar_attribute_form_direct;\n    return DW_DLV_OK;\n}\n\n/*  This code was contributed around 2007.\n    As of 2021 it is not clear that Sun Sparc\n    compilers are in current use, nor whether\n    there is a reason to make reads of\n    this data format safe from corrupted object files.\n\n    Pass in the content of a block and the length of that\n    content. On success return DW_DLV_OK and set *value_count\n    to the size of the array returned through value_array. */\nint\ndwarf_uncompress_integer_block_a(Dwarf_Debug dbg,\n    Dwarf_Unsigned     input_length_in_bytes,\n    void             * input_block,\n    Dwarf_Unsigned   * value_count,\n    Dwarf_Signed    ** value_array,\n    Dwarf_Error      * error)\n{\n    Dwarf_Unsigned output_length_in_units = 0;\n    Dwarf_Signed * output_block = 0;\n    unsigned i = 0;\n    char * ptr = 0;\n    int remain = 0;\n    Dwarf_Signed * array = 0;\n    Dwarf_Byte_Ptr endptr = (Dwarf_Byte_Ptr)input_block+\n        input_length_in_bytes;\n\n    output_length_in_units = 0;\n    remain = input_length_in_bytes;\n    ptr = input_block;\n    while (remain > 0) {\n        Dwarf_Unsigned len = 0;\n        Dwarf_Signed value = 0;\n        int rres = 0;\n\n        rres = dwarf_decode_signed_leb128((char *)ptr,\n            &len, &value,(char *)endptr);\n        if (rres != DW_DLV_OK) {\n            _dwarf_error(NULL, error, DW_DLE_LEB_IMPROPER);\n            return DW_DLV_ERROR;\n        }\n        ptr += len;\n        remain -= len;\n        output_length_in_units++;\n    }\n    if (remain != 0) {\n        _dwarf_error(NULL, error, DW_DLE_ALLOC_FAIL);\n        return DW_DLV_ERROR;\n    }\n\n    output_block = (Dwarf_Signed*)\n        _dwarf_get_alloc(dbg,\n            DW_DLA_STRING,\n            output_length_in_units * sizeof(Dwarf_Signed));\n    if (!output_block) {\n        _dwarf_error(dbg, error, DW_DLE_ALLOC_FAIL);\n        return DW_DLV_ERROR;\n    }\n    array = output_block;\n    remain = input_length_in_bytes;\n    ptr = input_block;\n    for (i=0; i<output_length_in_units && remain>0; i++) {\n        Dwarf_Signed num;\n        Dwarf_Unsigned len;\n        int sres = 0;\n\n        sres = dwarf_decode_signed_leb128((char *)ptr,\n            &len, &num,(char *)endptr);\n        if (sres != DW_DLV_OK) {\n            dwarf_dealloc(dbg,output_block,DW_DLA_STRING);\n            _dwarf_error(NULL, error, DW_DLE_LEB_IMPROPER);\n            return DW_DLV_ERROR;\n        }\n        ptr += len;\n        remain -= len;\n        array[i] = num;\n    }\n\n    if (remain != 0) {\n        dwarf_dealloc(dbg, (unsigned char *)output_block,\n            DW_DLA_STRING);\n        _dwarf_error(dbg, error, DW_DLE_ALLOC_FAIL);\n        return DW_DLV_ERROR;\n    }\n\n    *value_count = output_length_in_units;\n    *value_array = output_block;\n    return DW_DLV_OK;\n}\n\n/*  This code was contributed around 2007\n    and the return value is in the wrong form.\n    See dwarf_uncompress_integer_block_a() above.\n\n    As of 2019 it is not clear that Sun Sparc\n    compilers are in current use, nor whether\n    there is a reason to make reads of\n    this data format safe from corrupted object files.\n*/\n\nvoid\ndwarf_dealloc_uncompressed_block(Dwarf_Debug dbg, void * space)\n{\n    dwarf_dealloc(dbg, space, DW_DLA_STRING);\n}\n\n/*  Never returns DW_DLV_NO_ENTRY */\nint\ndwarf_whatform(Dwarf_Attribute attr,\n    Dwarf_Half * return_form, Dwarf_Error * error)\n{\n    Dwarf_CU_Context cu_context = 0;\n    Dwarf_Debug dbg = 0;\n\n    int res  =get_attr_dbg(&dbg,&cu_context, attr,error);\n    if (res != DW_DLV_OK) {\n        return res;\n    }\n    *return_form = attr->ar_attribute_form;\n    return DW_DLV_OK;\n}\n\n/*\n    This function is analogous to dwarf_whatform.\n    It returns the attribute in attr instead of\n    the form.\n*/\nint\ndwarf_whatattr(Dwarf_Attribute attr,\n    Dwarf_Half * return_attr, Dwarf_Error * error)\n{\n    Dwarf_CU_Context cu_context = 0;\n    Dwarf_Debug dbg = 0;\n\n    int res  =get_attr_dbg(&dbg,&cu_context, attr,error);\n    if (res != DW_DLV_OK) {\n        return res;\n    }\n    *return_attr = (attr->ar_attribute);\n    return DW_DLV_OK;\n}\n\n/*  Convert an offset within the local CU into a section-relative\n    debug_info (or debug_types) offset.\n    See dwarf_global_formref() and dwarf_formref()\n    for additional information on conversion rules.\n*/\nint\ndwarf_convert_to_global_offset(Dwarf_Attribute attr,\n    Dwarf_Off offset,\n    Dwarf_Off * ret_offset,\n    Dwarf_Error * error)\n{\n    Dwarf_Debug dbg = 0;\n    Dwarf_CU_Context cu_context = 0;\n    int res = 0;\n\n    res  = get_attr_dbg(&dbg,&cu_context,attr,error);\n    if (res != DW_DLV_OK) {\n        return res;\n    }\n    switch (attr->ar_attribute_form) {\n    case DW_FORM_ref1:\n    case DW_FORM_ref2:\n    case DW_FORM_ref4:\n    case DW_FORM_ref8:\n    case DW_FORM_ref_udata:\n        /*  It is a cu-local offset. Convert to section-global. */\n        /*  It would be nice to put some code to check\n            legality of the offset */\n        /*  cc_debug_offset always has any DWP Package File\n            offset included (when the cu_context created)\n            so there is no extra work for DWP.\n            Globalize the offset */\n        offset += cu_context->cc_debug_offset;\n\n        break;\n\n    case DW_FORM_ref_addr:\n        /*  This offset is defined to be debug_info global already, so\n            use this value unaltered.\n\n            Since a DWP package file is not relocated there\n            is no way that this reference offset to an address in\n            any other CU can be correct for a DWP Package File offset\n            */\n        break;\n    default: {\n        dwarfstring m;\n\n        dwarfstring_constructor(&m);\n        dwarfstring_append_printf_u(&m,\n            \"DW_DLE_BAD_REF_FORM. The form \"\n            \"code is 0x%x which cannot be converted to a global \"\n            \" offset by \"\n            \"dwarf_convert_to_global_offset()\",\n            attr->ar_attribute_form);\n        _dwarf_error_string(dbg, error, DW_DLE_BAD_REF_FORM,\n            dwarfstring_string(&m));\n        dwarfstring_destructor(&m);\n        return DW_DLV_ERROR;\n        }\n    }\n\n    *ret_offset = (offset);\n    return DW_DLV_OK;\n}\n\n/*  A global offset cannot be returned by this interface:\n    see dwarf_global_formref().\n\n    DW_FORM_ref_addr is considered an incorrect form\n    for this call because DW_FORM_ref_addr is a global-offset into\n    the debug_info section.\n\n    For the same reason DW_FORM_data4/data8 are not returned\n    from this function.\n\n    For the same reason DW_FORM_sec_offset is not returned\n    from this function, DW_FORM_sec_offset is a global offset\n    (to various sections, not a CU relative offset.\n\n    DW_FORM_ref_addr has a value which was documented in\n    DWARF2 as address-size but which was always an offset\n    so should have always been offset size (wording\n    corrected in DWARF3).\n    The dwarfstd.org FAQ \"How big is a DW_FORM_ref_addr?\"\n    suggested all should use offset-size, but that suggestion\n    seems to have been ignored in favor of doing what the\n    DWARF2 and 3 standards actually say.\n\n    November, 2010: *ret_offset is always set now.\n    Even in case of error.\n    Set to zero for most errors, but for\n        DW_DLE_ATTR_FORM_OFFSET_BAD\n    *ret_offset is set to the bad offset.\n\n    DW_FORM_addrx\n    DW_FORM_strx\n    DW_FORM_LLVM_addrx_offset\n    DW_FORM_rnglistx\n    DW_FORM_GNU_addr_index\n    DW_FORM_GNU_str_index\n    are not references to .debug_info/.debug_types,\n    so they are not allowed here. */\n\nint\ndwarf_formref(Dwarf_Attribute attr,\n    Dwarf_Off * ret_offset,\n    Dwarf_Bool * ret_is_info,\n    Dwarf_Error * error)\n{\n    Dwarf_Debug dbg = 0;\n    Dwarf_Unsigned offset = 0;\n    Dwarf_CU_Context cu_context = 0;\n    Dwarf_Unsigned maximumoffset = 0;\n    int res = DW_DLV_ERROR;\n    Dwarf_Byte_Ptr section_end = 0;\n    Dwarf_Bool is_info = TRUE;\n\n    *ret_offset = 0;\n    res  = get_attr_dbg(&dbg,&cu_context,attr,error);\n    if (res != DW_DLV_OK) {\n        return res;\n    }\n    section_end =\n        _dwarf_calculate_info_section_end_ptr(cu_context);\n    is_info = cu_context->cc_is_info;\n\n    switch (attr->ar_attribute_form) {\n\n    case DW_FORM_ref1:\n        offset = *(Dwarf_Small *) attr->ar_debug_ptr;\n        break;\n\n    case DW_FORM_ref2:\n        READ_UNALIGNED_CK(dbg, offset, Dwarf_Unsigned,\n            attr->ar_debug_ptr, DWARF_HALF_SIZE,\n            error,section_end);\n        break;\n\n    case DW_FORM_ref4:\n        READ_UNALIGNED_CK(dbg, offset, Dwarf_Unsigned,\n            attr->ar_debug_ptr, DWARF_32BIT_SIZE,\n            error,section_end);\n        break;\n\n    case DW_FORM_ref8:\n        READ_UNALIGNED_CK(dbg, offset, Dwarf_Unsigned,\n            attr->ar_debug_ptr, DWARF_64BIT_SIZE,\n            error,section_end);\n        break;\n\n    case DW_FORM_ref_udata: {\n        Dwarf_Byte_Ptr ptr = attr->ar_debug_ptr;\n        Dwarf_Unsigned localoffset = 0;\n\n        DECODE_LEB128_UWORD_CK(ptr,localoffset,\n            dbg,error,section_end);\n        offset = localoffset;\n        break;\n    }\n    case DW_FORM_ref_sig8: {\n        /*  We need to look for a local reference here.\n            The function we are in is only CU_local\n            offsets returned. */\n#if 0\n        Dwarf_Sig8 sig8;\n        memcpy(&sig8,ptr,sizeof(Dwarf_Sig8));\n        res = dwarf_find_die_given_sig8(dbg,\n            &sig8, ...\n        We could look, then determine if\n        resulting offset is actually local.\n#endif /*0*/\n\n        /*  We cannot handle this here.\n            The reference could be to .debug_types\n            or another CU!\n            not a .debug_info CU local offset. */\n        _dwarf_error(dbg, error, DW_DLE_REF_SIG8_NOT_HANDLED);\n        return DW_DLV_ERROR;\n    }\n    default: {\n        dwarfstring m;\n\n        dwarfstring_constructor(&m);\n        dwarfstring_append_printf_u(&m,\n            \"DW_DLE_BAD_REF_FORM. The form \"\n            \"code is 0x%x which does not have an offset \"\n            \" for \"\n            \"dwarf_formref() to return.\",\n            attr->ar_attribute_form);\n        _dwarf_error_string(dbg, error, DW_DLE_BAD_REF_FORM,\n            dwarfstring_string(&m));\n        dwarfstring_destructor(&m);\n        return DW_DLV_ERROR;\n        }\n    }\n\n    /*  Check that offset is within current\n        cu portion of .debug_info. */\n\n    maximumoffset = cu_context->cc_length +\n        cu_context->cc_length_size +\n        cu_context->cc_extension_size;\n    if (offset >= maximumoffset) {\n        /*  For the DW_TAG_compile_unit is legal to have the\n            DW_AT_sibling attribute outside the current cu portion of\n            .debug_info.\n            In other words, sibling points to the end of the CU.\n            It is used for precompiled headers.\n            The valid condition will be: 'offset == maximumoffset'. */\n        Dwarf_Half tag = 0;\n        int tres = dwarf_tag(attr->ar_die,&tag,error);\n        if (tres != DW_DLV_OK) {\n            if (tres == DW_DLV_NO_ENTRY) {\n                _dwarf_error(dbg, error, DW_DLE_NO_TAG_FOR_DIE);\n                return DW_DLV_ERROR;\n            }\n            return DW_DLV_ERROR;\n        }\n\n        if (DW_TAG_compile_unit != tag &&\n            DW_AT_sibling != attr->ar_attribute &&\n            offset > maximumoffset) {\n            _dwarf_error(dbg, error, DW_DLE_ATTR_FORM_OFFSET_BAD);\n            /*  Return the incorrect offset for better\n                error reporting */\n            *ret_offset = (offset);\n            return DW_DLV_ERROR;\n        }\n    }\n    *ret_is_info = is_info;\n    *ret_offset = (offset);\n    return DW_DLV_OK;\n}\n\nstatic int\n_dwarf_formsig8_internal(Dwarf_Attribute attr,\n    int formexpected,\n    Dwarf_Sig8 * returned_sig_bytes,\n    Dwarf_Error*     error)\n{\n    Dwarf_Debug dbg = 0;\n    Dwarf_CU_Context cu_context = 0;\n    Dwarf_Byte_Ptr  field_end = 0;\n    Dwarf_Byte_Ptr  section_end = 0;\n\n    int res  = get_attr_dbg(&dbg,&cu_context,attr,error);\n    if (res != DW_DLV_OK) {\n        return res;\n    }\n\n    if (attr->ar_attribute_form != formexpected) {\n        return DW_DLV_NO_ENTRY;\n    }\n    section_end =\n        _dwarf_calculate_info_section_end_ptr(cu_context);\n    field_end = attr->ar_debug_ptr + sizeof(Dwarf_Sig8);\n    if (field_end > section_end) {\n        _dwarf_error(dbg, error, DW_DLE_ATTR_FORM_OFFSET_BAD);\n        return DW_DLV_ERROR;\n    }\n\n    memcpy(returned_sig_bytes, attr->ar_debug_ptr,\n        sizeof(*returned_sig_bytes));\n    return DW_DLV_OK;\n}\n\nint\ndwarf_formsig8_const(Dwarf_Attribute attr,\n    Dwarf_Sig8 * returned_sig_bytes,\n    Dwarf_Error* error)\n{\n    int res  =_dwarf_formsig8_internal(attr, DW_FORM_data8,\n        returned_sig_bytes,error);\n    return res;\n}\n\n/*  dwarf_formsig8 returns in the caller-provided 8 byte area\n    the 8 bytes of a DW_FORM_ref_sig8 (copying the bytes\n    directly to the caller).  Not a string, an 8 byte\n    MD5 hash or a signature.\n    This function is new in DWARF4 libdwarf and used in\n    more places in DWARF5.\n*/\nint\ndwarf_formsig8(Dwarf_Attribute attr,\n    Dwarf_Sig8 * returned_sig_bytes,\n    Dwarf_Error* error)\n{\n    int res  = _dwarf_formsig8_internal(attr, DW_FORM_ref_sig8,\n        returned_sig_bytes,error);\n    return res;\n}\n\n/*  This finds a target via a sig8 and if\n    DWARF4 is likely finding a reference from .debug_info\n    to .debug_types.  So the offset may or may not be\n    in the same section if DWARF4. */\nstatic int\nfind_sig8_target_as_global_offset(Dwarf_Attribute attr,\n    Dwarf_Sig8  *sig8,\n    Dwarf_Bool  *is_info,\n    Dwarf_Off   *targoffset,\n    Dwarf_Error *error)\n{\n    Dwarf_Die  targdie = 0;\n    Dwarf_Bool targ_is_info = 0;\n    Dwarf_Off  localoff = 0;\n    int res = 0;\n    targ_is_info = attr->ar_cu_context->cc_is_info;\n    memcpy(sig8,attr->ar_debug_ptr,sizeof(*sig8));\n    res = dwarf_find_die_given_sig8(attr->ar_dbg,\n        sig8,&targdie,&targ_is_info,error);\n    if (res != DW_DLV_OK) {\n        return res;\n    }\n    res = dwarf_die_offsets(targdie,targoffset,&localoff,error);\n    if (res != DW_DLV_OK) {\n        dwarf_dealloc_die(targdie);\n        return res;\n    }\n    *is_info = targdie->di_cu_context->cc_is_info;\n    dwarf_dealloc_die(targdie);\n    return DW_DLV_OK;\n}\n\n/*  Since this returns section-relative debug_info offsets,\n    this can represent all REFERENCE forms correctly\n    and allows all applicable forms.\n\n    DW_FORM_ref_addr has a value which was documented in\n    DWARF2 as address-size but which was always an offset\n    so should have always been offset size (wording\n    corrected in DWARF3).\n        gcc and Go and libdwarf producer code\n    define the length of the value of DW_FORM_ref_addr\n    per the version. So for V2 it is address-size and V3 and later\n    it is offset-size.\n\n    See the DWARF4 document for the 3 cases fitting\n    reference forms.  The caller must determine which section the\n    reference 'points' to.  The function added in November 2009,\n    dwarf_get_form_class(), helps in this regard.\n\n    unlike dwarf_formref(), this allows references to\n    sections other than just .debug_info/.debug_types.\n    See case DW_FORM_sec_offset:\n    case DW_FORM_GNU_ref_alt:   2013 GNU extension\n    case DW_FORM_GNU_strp_alt:  2013 GNU extension\n    case DW_FORM_strp_sup:      DWARF5, sup string section\n    case DW_FORM_line_strp:     DWARF5, .debug_line_str section\n*/\n\n/*  This follows DW_FORM_ref_sig8 so could got\n    to any CU and from debug_info to debug_types\n    (or vice versa?)\n    dwarf_global_formref_b is aimed at for DIE references.\n    Only the DW_FORM_ref_sig8 form can change\n    from a cu_context in .debug_info\n    to one in .debug_types (DWARF4 only).\n    For references to other sections it is simpler\n    to call the original: dwarf_global_formref.\n*/\nint\ndwarf_global_formref(Dwarf_Attribute attr,\n    Dwarf_Off * ret_offset,\n    Dwarf_Error * error)\n{\n    Dwarf_Bool is_info = 0;\n    int res = 0;\n\n    res = dwarf_global_formref_b(attr,ret_offset,\n        &is_info,error);\n    return res;\n}\nint\ndwarf_global_formref_b(Dwarf_Attribute attr,\n    Dwarf_Off * ret_offset,\n    Dwarf_Bool * offset_is_info,\n    Dwarf_Error * error)\n{\n    Dwarf_Debug dbg = 0;\n    Dwarf_Unsigned offset = 0;\n    Dwarf_CU_Context cu_context = 0;\n    Dwarf_Half context_version = 0;\n    Dwarf_Byte_Ptr section_end = 0;\n    Dwarf_Bool is_info = TRUE;\n\n    int res  = get_attr_dbg(&dbg,&cu_context,attr,error);\n    if (res != DW_DLV_OK) {\n        return res;\n    }\n    section_end =\n        _dwarf_calculate_info_section_end_ptr(cu_context);\n    context_version = cu_context->cc_version_stamp;\n    is_info = cu_context->cc_is_info;\n    switch (attr->ar_attribute_form) {\n\n    case DW_FORM_ref1:\n        offset = *(Dwarf_Small *) attr->ar_debug_ptr;\n        goto fixoffset;\n\n    case DW_FORM_ref2:\n        READ_UNALIGNED_CK(dbg, offset, Dwarf_Unsigned,\n            attr->ar_debug_ptr, DWARF_HALF_SIZE,\n            error,section_end);\n        goto fixoffset;\n\n    case DW_FORM_ref4:\n        READ_UNALIGNED_CK(dbg, offset, Dwarf_Unsigned,\n            attr->ar_debug_ptr, DWARF_32BIT_SIZE,\n            error,section_end);\n        goto fixoffset;\n\n    case DW_FORM_ref8:\n        READ_UNALIGNED_CK(dbg, offset, Dwarf_Unsigned,\n            attr->ar_debug_ptr, DWARF_64BIT_SIZE,\n            error,section_end);\n        goto fixoffset;\n\n    case DW_FORM_ref_udata:\n        {\n        Dwarf_Byte_Ptr ptr = attr->ar_debug_ptr;\n        Dwarf_Unsigned localoffset = 0;\n\n        DECODE_LEB128_UWORD_CK(ptr,localoffset,\n            dbg,error,section_end);\n        offset = localoffset;\n\n        fixoffset: /* we have a local offset, make it global */\n\n        /* check legality of offset */\n        if (offset >= cu_context->cc_length +\n            cu_context->cc_length_size +\n            cu_context->cc_extension_size) {\n            _dwarf_error(dbg, error, DW_DLE_ATTR_FORM_OFFSET_BAD);\n            return DW_DLV_ERROR;\n        }\n\n        /* globalize the offset */\n        offset += cu_context->cc_debug_offset;\n        }\n        break;\n\n    /*  The DWARF2 document did not make clear that\n        DW_FORM_data4( and 8) were references with\n        global offsets to some section.\n        That was first clearly documented in DWARF3.\n        In DWARF4 these two forms are no longer references. */\n    case DW_FORM_data4:\n        if (context_version >= DW_CU_VERSION4) {\n            _dwarf_error(dbg, error, DW_DLE_NOT_REF_FORM);\n            return DW_DLV_ERROR;\n        }\n        READ_UNALIGNED_CK(dbg, offset, Dwarf_Unsigned,\n            attr->ar_debug_ptr, DWARF_32BIT_SIZE,\n            error, section_end);\n        /* The offset is global. */\n        break;\n    case DW_FORM_data8:\n        if (context_version >= DW_CU_VERSION4) {\n            _dwarf_error(dbg, error, DW_DLE_NOT_REF_FORM);\n            return DW_DLV_ERROR;\n        }\n        READ_UNALIGNED_CK(dbg, offset, Dwarf_Unsigned,\n            attr->ar_debug_ptr, DWARF_64BIT_SIZE,\n            error,section_end);\n        /* The offset is global. */\n        break;\n    case DW_FORM_ref_addr:\n        {\n            /*  In Dwarf V2 DW_FORM_ref_addr was defined\n                as address-size even though it is a .debug_info\n                offset.  Fixed in Dwarf V3 to be offset-size.\n                */\n            unsigned length_size = 0;\n            if (context_version == 2) {\n                length_size = cu_context->cc_address_size;\n            } else {\n                length_size = cu_context->cc_length_size;\n            }\n            if (length_size == 4) {\n                READ_UNALIGNED_CK(dbg, offset, Dwarf_Unsigned,\n                    attr->ar_debug_ptr, DWARF_32BIT_SIZE,\n                    error,section_end);\n            } else if (length_size == 8) {\n                READ_UNALIGNED_CK(dbg, offset, Dwarf_Unsigned,\n                    attr->ar_debug_ptr, DWARF_64BIT_SIZE,\n                    error,section_end);\n            } else {\n                _dwarf_error(dbg, error,\n                    DW_DLE_FORM_SEC_OFFSET_LENGTH_BAD);\n                return DW_DLV_ERROR;\n            }\n        }\n        break;\n    /*  Index into .debug_rnglists/.debug_loclists section.\n        Return the index itself. */\n    case DW_FORM_loclistx:\n    case DW_FORM_rnglistx: {\n        unsigned length_size = cu_context->cc_length_size;\n        READ_UNALIGNED_CK(dbg, offset, Dwarf_Unsigned,\n            attr->ar_debug_ptr, length_size,\n            error,section_end);\n        }\n        break;\n    case DW_FORM_sec_offset:\n    case DW_FORM_GNU_ref_alt:  /* 2013 GNU extension */\n    case DW_FORM_GNU_strp_alt: /* 2013 GNU extension */\n    case DW_FORM_strp_sup:     /* DWARF5, sup string section */\n    case DW_FORM_line_strp:    /* DWARF5, .debug_line_str section */\n        {\n            /*  DW_FORM_sec_offset first exists in DWARF4.*/\n            /*  It is up to the caller to know what the offset\n                of DW_FORM_sec_offset, DW_FORM_strp_sup\n                or DW_FORM_GNU_strp_alt etc refer to,\n                the offset is not going to refer to .debug_info! */\n            unsigned length_size = cu_context->cc_length_size;\n            if (length_size == 4) {\n                READ_UNALIGNED_CK(dbg, offset, Dwarf_Unsigned,\n                    attr->ar_debug_ptr, DWARF_32BIT_SIZE,\n                    error,section_end);\n            } else if (length_size == 8) {\n                READ_UNALIGNED_CK(dbg, offset, Dwarf_Unsigned,\n                    attr->ar_debug_ptr, DWARF_64BIT_SIZE,\n                    error,section_end);\n            } else {\n                _dwarf_error(dbg, error,\n                    DW_DLE_FORM_SEC_OFFSET_LENGTH_BAD);\n                return DW_DLV_ERROR;\n            }\n        }\n        break;\n    case DW_FORM_ref_sig8: {\n        /*  This, in DWARF4, is how\n            .debug_info refers to .debug_types. */\n        Dwarf_Sig8 sig8;\n        Dwarf_Bool t_is_info = TRUE;\n        Dwarf_Unsigned t_offset = 0;\n\n        if ((attr->ar_debug_ptr + sizeof(Dwarf_Sig8)) > section_end) {\n            _dwarf_error_string(dbg, error,\n                DW_DLE_REF_SIG8_NOT_HANDLED,\n                \"DW_DLE_REF_SIG8_NOT_HANDLED: \"\n                \" Dwarf_Sig8 content runs off the end of its section\");\n            return DW_DLV_ERROR;\n        }\n        memcpy(&sig8,attr->ar_debug_ptr,sizeof(Dwarf_Sig8));\n        res = find_sig8_target_as_global_offset(attr,\n            &sig8,&t_is_info,&t_offset,error);\n        if (res == DW_DLV_ERROR) {\n            _dwarf_error_string(dbg, error,\n                DW_DLE_REF_SIG8_NOT_HANDLED,\n                \"DW_DLE_REF_SIG8_NOT_HANDLED: \"\n                \" problem finding target\");\n            return DW_DLV_ERROR;\n        }\n        if (res == DW_DLV_NO_ENTRY) {\n            return res;\n        }\n        is_info = t_is_info;\n        offset = t_offset;\n        break;\n    }\n    default: {\n        dwarfstring m;\n        int formcode = attr->ar_attribute_form;\n        int fcres = 0;\n        const char *name = 0;\n\n        dwarfstring_constructor(&m);\n        dwarfstring_append_printf_u(&m,\n            \"DW_DLE_BAD_REF_FORM: The form code is 0x%x \",\n            formcode);\n        fcres  = dwarf_get_FORM_name (formcode,&name);\n        if (fcres != DW_DLV_OK) {\n            name=\"<UnknownFormCode>\";\n        }\n        dwarfstring_append_printf_s(&m,\n            \" %s.\",(char *)name);\n        _dwarf_error_string(dbg, error, DW_DLE_BAD_REF_FORM,\n            dwarfstring_string(&m));\n        dwarfstring_destructor(&m);\n        return DW_DLV_ERROR;\n        }\n    }\n\n    *offset_is_info = is_info;\n    *ret_offset = offset;\n    return DW_DLV_OK;\n}\n\n/*  Part of DebugFission.  So a consumer can get the index when\n    the object with the actual debug_addr  is\n    elsewhere.  New May 2014*/\n\nint\n_dwarf_get_addr_index_itself(int theform,\n    Dwarf_Small *info_ptr,\n    Dwarf_Debug dbg,\n    Dwarf_CU_Context cu_context,\n    Dwarf_Unsigned *val_out,\n    Dwarf_Error * error)\n{\n    Dwarf_Unsigned index = 0;\n    Dwarf_Byte_Ptr section_end = 0;\n\n    section_end =\n        _dwarf_calculate_info_section_end_ptr(cu_context);\n    switch(theform){\n    case DW_FORM_LLVM_addrx_offset: {\n        Dwarf_Unsigned tmp = 0;\n        Dwarf_Unsigned tmp2 = 0;\n        DECODE_LEB128_UWORD_CK(info_ptr,tmp,\n            dbg,error,section_end);\n        READ_UNALIGNED_CK(dbg, tmp2, Dwarf_Unsigned,\n            info_ptr, SIZEOFT32,\n            error,section_end);\n        index = (tmp<<32) | tmp2;\n        break;\n    }\n    case DW_FORM_GNU_addr_index:\n    case DW_FORM_addrx:\n        DECODE_LEB128_UWORD_CK(info_ptr,index,\n            dbg,error,section_end);\n        break;\n    case DW_FORM_addrx1:\n        READ_UNALIGNED_CK(dbg, index, Dwarf_Unsigned,\n            info_ptr, 1,\n            error,section_end);\n        break;\n    case DW_FORM_addrx2:\n        READ_UNALIGNED_CK(dbg, index, Dwarf_Unsigned,\n            info_ptr, 2,\n            error,section_end);\n        break;\n    case DW_FORM_addrx3:\n        READ_UNALIGNED_CK(dbg, index, Dwarf_Unsigned,\n            info_ptr, 3,\n            error,section_end);\n        break;\n    case DW_FORM_addrx4:\n        READ_UNALIGNED_CK(dbg, index, Dwarf_Unsigned,\n            info_ptr, 4,\n            error,section_end);\n        break;\n    default:\n        _dwarf_error(dbg, error, DW_DLE_ATTR_FORM_NOT_ADDR_INDEX);\n        return DW_DLV_ERROR;\n    }\n    *val_out = index;\n    return DW_DLV_OK;\n}\n\nint\ndwarf_get_debug_addr_index(Dwarf_Attribute attr,\n    Dwarf_Unsigned * return_index,\n    Dwarf_Error * error)\n{\n    int theform = 0;\n    Dwarf_CU_Context cu_context = 0;\n    Dwarf_Debug dbg = 0;\n\n    int res  = get_attr_dbg(&dbg,&cu_context,attr,error);\n    if (res != DW_DLV_OK) {\n        return res;\n    }\n    theform = attr->ar_attribute_form;\n    if (dwarf_addr_form_is_indexed(theform)) {\n        Dwarf_Unsigned index = 0;\n\n        res = _dwarf_get_addr_index_itself(theform,\n            attr->ar_debug_ptr,dbg,cu_context,&index,error);\n        *return_index = index;\n        return res;\n    }\n\n    _dwarf_error(dbg, error, DW_DLE_ATTR_FORM_NOT_ADDR_INDEX);\n    return DW_DLV_ERROR;\n}\n\nstatic int\ndw_read_str_index_val_itself(Dwarf_Debug dbg,\n    unsigned theform,\n    Dwarf_Small *info_ptr,\n    Dwarf_Small *section_end,\n    Dwarf_Unsigned *return_index,\n    Dwarf_Error *error)\n{\n    Dwarf_Unsigned index = 0;\n\n    switch(theform) {\n    case DW_FORM_strx:\n    case DW_FORM_GNU_str_index:\n        DECODE_LEB128_UWORD_CK(info_ptr,index,\n            dbg,error,section_end);\n        break;\n    case DW_FORM_strx1:\n        READ_UNALIGNED_CK(dbg, index, Dwarf_Unsigned,\n            info_ptr, 1,\n            error,section_end);\n        break;\n    case DW_FORM_strx2:\n        READ_UNALIGNED_CK(dbg, index, Dwarf_Unsigned,\n            info_ptr, 2,\n            error,section_end);\n        break;\n    case DW_FORM_strx3:\n        READ_UNALIGNED_CK(dbg, index, Dwarf_Unsigned,\n            info_ptr, 3,\n            error,section_end);\n        break;\n    case DW_FORM_strx4:\n        READ_UNALIGNED_CK(dbg, index, Dwarf_Unsigned,\n            info_ptr, 4,\n            error,section_end);\n        break;\n    default:\n        _dwarf_error(dbg, error, DW_DLE_ATTR_FORM_NOT_STR_INDEX);\n        return DW_DLV_ERROR;\n    }\n    *return_index = index;\n    return DW_DLV_OK;\n}\n\n/*  Part of DebugFission.  So a dwarf dumper application\n    can get the index and print it for the user.\n    A convenience function.  New May 2014\n    Also used with DWARF5 forms.  */\nint\ndwarf_get_debug_str_index(Dwarf_Attribute attr,\n    Dwarf_Unsigned *return_index,\n    Dwarf_Error *error)\n{\n    int theform = attr->ar_attribute_form;\n    Dwarf_CU_Context cu_context = 0;\n    Dwarf_Debug dbg = 0;\n    int res  = 0;\n    Dwarf_Byte_Ptr section_end =  0;\n    Dwarf_Unsigned index = 0;\n    Dwarf_Small *info_ptr = 0;\n    int indxres = 0;\n\n    res = get_attr_dbg(&dbg,&cu_context,attr,error);\n    if (res != DW_DLV_OK) {\n        return res;\n    }\n    section_end =\n        _dwarf_calculate_info_section_end_ptr(cu_context);\n    info_ptr = attr->ar_debug_ptr;\n\n    indxres = dw_read_str_index_val_itself(dbg, theform, info_ptr,\n        section_end, &index,error);\n    if (indxres == DW_DLV_OK) {\n        *return_index = index;\n        return indxres;\n    }\n    return indxres;\n}\n\nint\n_dwarf_extract_data16(Dwarf_Debug dbg,\n    Dwarf_Small *data,\n    Dwarf_Small *section_start,\n    Dwarf_Small *section_end,\n    Dwarf_Form_Data16  * returned_val,\n    Dwarf_Error *error)\n{\n    Dwarf_Small *data16end = 0;\n\n    data16end = data + sizeof(Dwarf_Form_Data16);\n    if (data  < section_start ||\n        section_end < data16end) {\n        _dwarf_error(dbg, error,DW_DLE_DATA16_OUTSIDE_SECTION);\n        return DW_DLV_ERROR;\n    }\n    memcpy(returned_val, data, sizeof(*returned_val));\n    return DW_DLV_OK;\n\n}\n\nint\ndwarf_formdata16(Dwarf_Attribute attr,\n    Dwarf_Form_Data16  * returned_val,\n    Dwarf_Error*     error)\n{\n    Dwarf_Half attrform = 0;\n    Dwarf_CU_Context cu_context = 0;\n    Dwarf_Debug dbg = 0;\n    int res  = 0;\n    Dwarf_Small *section_end = 0;\n    Dwarf_Unsigned section_length = 0;\n    Dwarf_Small *section_start = 0;\n\n    if (!attr) {\n        _dwarf_error(NULL, error, DW_DLE_ATTR_NULL);\n        return DW_DLV_ERROR;\n    }\n    if (!returned_val ) {\n        _dwarf_error(NULL, error, DW_DLE_ATTR_NULL);\n        return DW_DLV_ERROR;\n    }\n    res  = get_attr_dbg(&dbg,&cu_context,attr,error);\n    if (res != DW_DLV_OK) {\n        return res;\n    }\n    attrform = attr->ar_attribute_form;\n    if (attrform != DW_FORM_data16) {\n        generate_form_error(dbg,error,attrform,\n            DW_DLE_ATTR_FORM_BAD,\n            \"DW_DLE_ATTR_FORM_BAD\",\n            \"dwarf_formdata16\");\n        return DW_DLV_ERROR;\n    }\n    section_start = _dwarf_calculate_info_section_start_ptr(\n        cu_context,&section_length);\n    section_end = section_start + section_length;\n\n    res = _dwarf_extract_data16(dbg, attr->ar_debug_ptr,\n        section_start, section_end,\n        returned_val,  error);\n    return res;\n}\n\n/*  The *addrx are DWARF5 standard.\n    The GNU form is non-standard gcc DWARF4\n    The LLVM form is the newest. */\nDwarf_Bool\ndwarf_addr_form_is_indexed(int form)\n{\n    switch(form) {\n    case DW_FORM_addrx:\n    case DW_FORM_addrx1:\n    case DW_FORM_addrx2:\n    case DW_FORM_addrx3:\n    case DW_FORM_addrx4:\n    case DW_FORM_GNU_addr_index:\n    case DW_FORM_LLVM_addrx_offset:\n        return TRUE;\n    default: break;\n    }\n    return FALSE;\n}\n\nint\ndwarf_formaddr(Dwarf_Attribute attr,\n    Dwarf_Addr * return_addr, Dwarf_Error * error)\n{\n    Dwarf_Debug dbg = 0;\n    Dwarf_Addr ret_addr = 0;\n    Dwarf_CU_Context cu_context = 0;\n    Dwarf_Half attrform = 0;\n    int res = 0;\n\n    res  = get_attr_dbg(&dbg,&cu_context,attr,error);\n    if (res != DW_DLV_OK) {\n        return res;\n    }\n    attrform = attr->ar_attribute_form;\n    if (dwarf_addr_form_is_indexed(attrform)) {\n        res = _dwarf_look_in_local_and_tied(\n            attrform,\n            cu_context,\n            attr->ar_debug_ptr,\n            return_addr,\n            error);\n        return res;\n    }\n    if (attrform == DW_FORM_addr\n        /*  || attrform == DW_FORM_ref_addr Allowance of\n            DW_FORM_ref_addr was a mistake. The value returned in that\n            case is NOT an address it is a global debug_info\n            offset (ie, not CU-relative offset within the CU\n            in debug_info).\n            The DWARF2 document refers to it as an address\n            (misleadingly) in sec 6.5.4 where it describes\n            the reference form. It is\n            address-sized so that the linker can easily update it, but\n            it is a reference inside the debug_info section. No longer\n            allowed. */\n        ) {\n        Dwarf_Small *section_end =\n            _dwarf_calculate_info_section_end_ptr(cu_context);\n\n        READ_UNALIGNED_CK(dbg, ret_addr, Dwarf_Addr,\n            attr->ar_debug_ptr,\n            cu_context->cc_address_size,\n            error,section_end);\n        *return_addr = ret_addr;\n        return DW_DLV_OK;\n    }\n    generate_form_error(dbg,error,attrform,\n        DW_DLE_ATTR_FORM_BAD,\n        \"DW_DLE_ATTR_FORM_BAD\",\n        \"dwarf_formaddr\");\n    return DW_DLV_ERROR;\n}\n\nint\ndwarf_formflag(Dwarf_Attribute attr,\n    Dwarf_Bool * ret_bool, Dwarf_Error * error)\n{\n    Dwarf_CU_Context cu_context = 0;\n    Dwarf_Debug dbg = 0;\n\n    if (!attr) {\n        _dwarf_error(NULL, error, DW_DLE_ATTR_NULL);\n        return DW_DLV_ERROR;\n    }\n    cu_context = attr->ar_cu_context;\n    if (!cu_context) {\n        _dwarf_error(NULL, error, DW_DLE_ATTR_NO_CU_CONTEXT);\n        return DW_DLV_ERROR;\n    }\n    dbg = cu_context->cc_dbg;\n    if (!dbg || dbg->de_magic != DBG_IS_VALID) {\n        _dwarf_error_string(NULL, error, DW_DLE_ATTR_DBG_NULL,\n            \"DW_DLE_ATTR_DBG_NULL: dwarf_formflag() attribute\"\n            \" passed in has NULL or stale Dwarf_Debug pointer\");\n        return DW_DLV_ERROR;\n    }\n    if (dbg != attr->ar_dbg) {\n        _dwarf_error_string(NULL, error, DW_DLE_ATTR_DBG_NULL,\n            \"DW_DLE_ATTR_DBG_NULL: an attribute and its \"\n            \"cu_context do not have the same Dwarf_Debug\" );\n        return DW_DLV_ERROR;\n    }\n    if (attr->ar_attribute_form == DW_FORM_flag_present) {\n        /*  Implicit means we don't read any data at all. Just\n            the existence of the Form does it. DWARF4. */\n        *ret_bool = 1;\n        return DW_DLV_OK;\n    }\n\n    if (attr->ar_attribute_form == DW_FORM_flag) {\n        *ret_bool = *(Dwarf_Small *)(attr->ar_debug_ptr);\n        return DW_DLV_OK;\n    }\n    generate_form_error(dbg,error,attr->ar_attribute_form,\n        DW_DLE_ATTR_FORM_BAD,\n        \"DW_DLE_ATTR_FORM_BAD\",\n        \"dwarf_formflat\");\n    return DW_DLV_ERROR;\n}\n\nDwarf_Bool\n_dwarf_allow_formudata(unsigned form)\n{\n    switch(form) {\n    case DW_FORM_data1:\n    case DW_FORM_data2:\n    case DW_FORM_data4:\n    case DW_FORM_data8:\n    case DW_FORM_udata:\n    case DW_FORM_loclistx:\n    case DW_FORM_rnglistx:\n        return TRUE;\n    default:\n        break;\n    }\n    return FALSE;\n}\n/*  If the form is DW_FORM_constx and the .debug_addr section\n    is missing, this returns DW_DLV_ERROR and the error number\n    in the Dwarf_Error is  DW_DLE_MISSING_NEEDED_DEBUG_ADDR_SECTION.\n    When that arises, a consumer should call\n    dwarf_get_debug_addr_index() and use that on the appropriate\n    .debug_addr section in the executable or another object.\n\n    Since this accept some signed values, callers\n    must not assume a DW_DLV_OK means\n    the value is unsigned. The form is the first clue here.\n    If DW_FORM_sdata, then signed. Else unknown sign or\n    is unsigned.\n*/\n\nint\n_dwarf_formudata_internal(Dwarf_Debug dbg,\n    Dwarf_Attribute attr,\n    unsigned form,\n    Dwarf_Byte_Ptr data,\n    Dwarf_Byte_Ptr section_end,\n    Dwarf_Unsigned *return_uval,\n    Dwarf_Unsigned *bytes_read,\n    Dwarf_Error *error)\n{\n    Dwarf_Unsigned ret_value = 0;\n\n    switch (form) {\n    case DW_FORM_data1:\n        READ_UNALIGNED_CK(dbg, ret_value, Dwarf_Unsigned,\n            data, sizeof(Dwarf_Small),\n            error,section_end);\n        *return_uval = ret_value;\n        *bytes_read = 1;\n        return DW_DLV_OK;\n\n    /*  READ_UNALIGNED does the right thing as it reads\n        the right number bits and generates host order.\n        So we can just assign to *return_uval. */\n    case DW_FORM_data2:{\n        READ_UNALIGNED_CK(dbg, ret_value, Dwarf_Unsigned,\n            data, DWARF_HALF_SIZE,\n            error,section_end);\n        *return_uval = ret_value;\n        *bytes_read = DWARF_HALF_SIZE;\n        return DW_DLV_OK;\n        }\n\n    case DW_FORM_data4:{\n        READ_UNALIGNED_CK(dbg, ret_value, Dwarf_Unsigned,\n            data,\n            DWARF_32BIT_SIZE,\n            error,section_end);\n        *return_uval = ret_value;\n        *bytes_read = DWARF_32BIT_SIZE;;\n        return DW_DLV_OK;\n        }\n\n    case DW_FORM_data8:{\n        READ_UNALIGNED_CK(dbg, ret_value, Dwarf_Unsigned,\n            data,\n            DWARF_64BIT_SIZE,\n            error,section_end);\n        *return_uval = ret_value;\n        *bytes_read = DWARF_64BIT_SIZE;\n        return DW_DLV_OK;\n        }\n        break;\n    /* real udata */\n    case DW_FORM_loclistx:\n    case DW_FORM_rnglistx:\n    case DW_FORM_udata: {\n        Dwarf_Unsigned leblen = 0;\n        DECODE_LEB128_UWORD_LEN_CK(data, ret_value,leblen,\n            dbg,error,section_end);\n        *return_uval = ret_value;\n        *bytes_read = leblen;\n        return DW_DLV_OK;\n    }\n    /*  IRIX bug 583450. We do not allow reading\n        sdata from a udata\n        value. Caller can retry, calling sdata */\n    default:\n        break;\n    }\n    if (attr) {\n        int res = 0;\n        Dwarf_Signed s = 0;\n        res = dwarf_formsdata(attr,&s,error);\n        if (res != DW_DLV_OK) {\n            return res;\n        }\n        if (s < 0 ) {\n            _dwarf_error(dbg, error, DW_DLE_UDATA_VALUE_NEGATIVE);\n            return DW_DLV_ERROR;\n        }\n        *return_uval = (Dwarf_Unsigned)s;\n        *bytes_read = 0;\n        return DW_DLV_OK;\n    }\n    generate_form_error(dbg,error,form,\n        DW_DLE_ATTR_FORM_BAD,\n        \"DW_DLE_ATTR_FORM_BAD\",\n        \"formudata (internal function)\");\n    return DW_DLV_ERROR;\n}\n\nint\ndwarf_formudata(Dwarf_Attribute attr,\n    Dwarf_Unsigned * return_uval, Dwarf_Error * error)\n{\n    Dwarf_Debug dbg = 0;\n    Dwarf_CU_Context cu_context = 0;\n    Dwarf_Byte_Ptr section_end = 0;\n    Dwarf_Unsigned bytes_read = 0;\n    Dwarf_Byte_Ptr data =  attr->ar_debug_ptr;\n    unsigned form = 0;\n\n    int res  = get_attr_dbg(&dbg,&cu_context,attr,error);\n    if (res != DW_DLV_OK) {\n        return res;\n    }\n    section_end =\n        _dwarf_calculate_info_section_end_ptr(cu_context);\n    form = attr->ar_attribute_form;\n\n    res = _dwarf_formudata_internal(dbg,\n        attr,\n        form, data, section_end, return_uval,\n        &bytes_read, error);\n    return res;\n}\n\nint\ndwarf_formsdata(Dwarf_Attribute attr,\n    Dwarf_Signed * return_sval, Dwarf_Error * error)\n{\n    Dwarf_Signed ret_value = 0;\n    Dwarf_Debug dbg = 0;\n    Dwarf_CU_Context cu_context = 0;\n    Dwarf_Byte_Ptr section_end = 0;\n\n    int res  = get_attr_dbg(&dbg,&cu_context,attr,error);\n    if (res != DW_DLV_OK) {\n        return res;\n    }\n    section_end =\n        _dwarf_calculate_info_section_end_ptr(cu_context);\n    switch (attr->ar_attribute_form) {\n\n    case DW_FORM_data1:\n        if ( attr->ar_debug_ptr >= section_end) {\n            _dwarf_error(dbg, error, DW_DLE_DIE_BAD);\n            return DW_DLV_ERROR;\n        }\n        *return_sval = (*(Dwarf_Sbyte *) attr->ar_debug_ptr);\n        return DW_DLV_OK;\n\n    /*  READ_UNALIGNED does not sign extend.\n        So we have to use a cast to get the\n        value sign extended in the right way for each case. */\n    case DW_FORM_data2:{\n        READ_UNALIGNED_CK(dbg, ret_value, Dwarf_Signed,\n            attr->ar_debug_ptr,\n            DWARF_HALF_SIZE,\n            error,section_end);\n        *return_sval = (Dwarf_Shalf) ret_value;\n        return DW_DLV_OK;\n\n        }\n\n    case DW_FORM_data4:{\n        READ_UNALIGNED_CK(dbg, ret_value, Dwarf_Signed,\n            attr->ar_debug_ptr,\n            DWARF_32BIT_SIZE,\n            error,section_end);\n        SIGN_EXTEND(ret_value,DWARF_32BIT_SIZE);\n        *return_sval = (Dwarf_Signed) ret_value;\n        return DW_DLV_OK;\n        }\n\n    case DW_FORM_data8:{\n        READ_UNALIGNED_CK(dbg, ret_value, Dwarf_Signed,\n            attr->ar_debug_ptr,\n            DWARF_64BIT_SIZE,\n            error,section_end);\n        /* No SIGN_EXTEND needed, we are filling all bytes already.*/\n        *return_sval = (Dwarf_Signed) ret_value;\n        return DW_DLV_OK;\n        }\n\n    /*  DW_FORM_implicit_const  is a value in the\n        abbreviations, not in the DIEs. */\n    case DW_FORM_implicit_const:\n        *return_sval = attr->ar_implicit_const;\n        return DW_DLV_OK;\n\n    case DW_FORM_sdata: {\n        Dwarf_Byte_Ptr tmp = attr->ar_debug_ptr;\n\n        DECODE_LEB128_SWORD_CK(tmp, ret_value,\n            dbg,error,section_end);\n        *return_sval = ret_value;\n        return DW_DLV_OK;\n\n    }\n\n        /* IRIX bug 583450. We do not allow reading sdata from a udata\n            value. Caller can retry, calling udata */\n\n    default:\n        break;\n    }\n    generate_form_error(dbg,error,attr->ar_attribute_form,\n        DW_DLE_ATTR_FORM_BAD,\n        \"DW_DLE_ATTR_FORM_BAD\",\n        \"dwarf_formsdata\");\n    return DW_DLV_ERROR;\n}\n\nint\n_dwarf_formblock_internal(Dwarf_Debug dbg,\n    Dwarf_Attribute attr,\n    Dwarf_CU_Context cu_context,\n    Dwarf_Block * return_block,\n    Dwarf_Error * error)\n{\n    Dwarf_Small *section_start = 0;\n    Dwarf_Small *section_end = 0;\n    Dwarf_Unsigned section_length = 0;\n    Dwarf_Unsigned length = 0;\n    Dwarf_Small *data = 0;\n\n    section_end =\n        _dwarf_calculate_info_section_end_ptr(cu_context);\n    section_start =\n        _dwarf_calculate_info_section_start_ptr(cu_context,\n        &section_length);\n\n    switch (attr->ar_attribute_form) {\n\n    case DW_FORM_block1:\n        length = *(Dwarf_Small *) attr->ar_debug_ptr;\n        data = attr->ar_debug_ptr + sizeof(Dwarf_Small);\n        break;\n\n    case DW_FORM_block2:\n        READ_UNALIGNED_CK(dbg, length, Dwarf_Unsigned,\n            attr->ar_debug_ptr, DWARF_HALF_SIZE,\n            error,section_end);\n        data = attr->ar_debug_ptr + DWARF_HALF_SIZE;\n        break;\n\n    case DW_FORM_block4:\n        READ_UNALIGNED_CK(dbg, length, Dwarf_Unsigned,\n            attr->ar_debug_ptr, DWARF_32BIT_SIZE,\n            error,section_end);\n        data = attr->ar_debug_ptr + DWARF_32BIT_SIZE;\n        break;\n\n    case DW_FORM_exprloc:\n    case DW_FORM_block: {\n        Dwarf_Byte_Ptr tmp = attr->ar_debug_ptr;\n        Dwarf_Unsigned leblen = 0;\n\n        DECODE_LEB128_UWORD_LEN_CK(tmp, length, leblen,\n            dbg,error,section_end);\n        data = attr->ar_debug_ptr + leblen;\n        break;\n        }\n    default:\n        generate_form_error(dbg,error,attr->ar_attribute_form,\n            DW_DLE_ATTR_FORM_BAD,\n            \"DW_DLE_ATTR_FORM_BAD\",\n            \"dwarf_formblock\");\n        return DW_DLV_ERROR;\n    }\n    /*  We have the data. Check for errors. */\n    if (length >= section_length) {\n        /*  Sanity test looking for wraparound:\n            when length actually added in\n            it would not be caught.\n            Test could be just >, but >= ok here too.*/\n        _dwarf_error_string(dbg, error,\n            DW_DLE_FORM_BLOCK_LENGTH_ERROR,\n            \"DW_DLE_FORM_BLOCK_LENGTH_ERROR: \"\n            \"The length of the block is greater \"\n            \"than the section length! Corrupt Dwarf.\");\n        return DW_DLV_ERROR;\n    }\n    if ((attr->ar_debug_ptr + length) > section_end) {\n        _dwarf_error_string(dbg, error,\n            DW_DLE_FORM_BLOCK_LENGTH_ERROR,\n            \"DW_DLE_FORM_BLOCK_LENGTH_ERROR: \"\n            \"The block length means the block \"\n            \"runs off the end of the section length!\"\n            \" Corrupt Dwarf.\");\n        return DW_DLV_ERROR;\n    }\n    if (data > section_end) {\n        _dwarf_error_string(dbg, error,\n            DW_DLE_FORM_BLOCK_LENGTH_ERROR,\n            \"DW_DLE_FORM_BLOCK_LENGTH_ERROR: \"\n            \"The block content is \"\n            \"past the end of the section!\"\n            \" Corrupt Dwarf.\");\n        _dwarf_error(dbg, error, DW_DLE_FORM_BLOCK_LENGTH_ERROR);\n        return DW_DLV_ERROR;\n    }\n    if ((data + length) > section_end) {\n        _dwarf_error_string(dbg, error,\n            DW_DLE_FORM_BLOCK_LENGTH_ERROR,\n            \"DW_DLE_FORM_BLOCK_LENGTH_ERROR: \"\n            \"The end of the block content is \"\n            \"past the end of the section!\"\n            \" Corrupt Dwarf.\");\n        return DW_DLV_ERROR;\n    }\n    return_block->bl_len = length;\n    return_block->bl_data = data;\n    /*  This struct is public so use the old name instead\n        of what we now would call it:  bl_kind  */\n    return_block->bl_from_loclist =  DW_LKIND_expression;\n    return_block->bl_section_offset =  data - section_start;\n    return DW_DLV_OK;\n}\n\nint\ndwarf_formblock(Dwarf_Attribute attr,\n    Dwarf_Block ** return_block, Dwarf_Error * error)\n{\n    Dwarf_CU_Context cu_context = 0;\n    Dwarf_Debug dbg = 0;\n    Dwarf_Block local_block;\n    Dwarf_Block *out_block = 0;\n    int res = 0;\n\n    memset(&local_block,0,sizeof(local_block));\n    res  = get_attr_dbg(&dbg,&cu_context,attr,error);\n    if (res != DW_DLV_OK) {\n        return res;\n    }\n    res = _dwarf_formblock_internal(dbg,attr,\n        cu_context, &local_block, error);\n    if (res != DW_DLV_OK) {\n        return res;\n    }\n    out_block = (Dwarf_Block *)\n        _dwarf_get_alloc(dbg, DW_DLA_BLOCK, 1);\n    if (!out_block) {\n        _dwarf_error(dbg, error, DW_DLE_ALLOC_FAIL);\n        return DW_DLV_ERROR;\n    }\n    *out_block = local_block;\n    *return_block = out_block;\n    return DW_DLV_OK;\n}\n\nint\n_dwarf_extract_string_offset_via_str_offsets(Dwarf_Debug dbg,\n    Dwarf_Small *data_ptr,\n    Dwarf_Small *end_data_ptr,\n    Dwarf_Half   attrnum UNUSEDARG,\n    Dwarf_Half   attrform,\n    Dwarf_CU_Context cu_context,\n    Dwarf_Unsigned *str_sect_offset_out,\n    Dwarf_Error *error)\n{\n    Dwarf_Unsigned index_to_offset_entry = 0;\n    Dwarf_Unsigned offsetintable = 0;\n    Dwarf_Unsigned end_offsetintable = 0;\n    Dwarf_Unsigned indexoffset = 0;\n    Dwarf_Unsigned baseoffset = 0;\n    int res = 0;\n    int idxres = 0;\n    Dwarf_Small *sof_start = 0;\n    Dwarf_Unsigned sof_len = 0;\n    Dwarf_Small   *sof_end = 0;\n\n    res = _dwarf_load_section(dbg, &dbg->de_debug_str_offsets,error);\n    if (res != DW_DLV_OK) {\n        return res;\n    }\n    /*  If this is a dwp we look there, but I suppose\n        we could also look for the section in the tied\n        file it is not here. */\n    sof_start = dbg->de_debug_str_offsets.dss_data;\n    sof_len = dbg->de_debug_str_offsets.dss_size;\n    sof_end = sof_start+sof_len;\n    idxres = dw_read_str_index_val_itself(dbg,\n        attrform,data_ptr,end_data_ptr,&index_to_offset_entry,error);\n    if ( idxres != DW_DLV_OK) {\n        return idxres;\n    }\n\n    if (cu_context->cc_str_offsets_base_present) {\n        baseoffset = cu_context->cc_str_offsets_base;\n    }\n    indexoffset = index_to_offset_entry*\n        cu_context->cc_length_size;\n    baseoffset = cu_context->cc_str_offsets_base;\n    if (!baseoffset) {\n        if (cu_context->cc_version_stamp ==  DW_CU_VERSION5 ) {\n            /*  A base offset of 0 isnormally never correct for\n                DWARF5. but some early GNU compilers emitted\n                DWARF4 .debug_str_offsets, so lets check\n                the first table.  */\n            Dwarf_Small * ststart =\n                dbg->de_debug_str_offsets.dss_data;\n            Dwarf_Small * stend = 0;\n            Dwarf_Unsigned  stsize =\n                dbg->de_debug_str_offsets.dss_size;\n            Dwarf_Unsigned length            = 0;\n            Dwarf_Half local_offset_size = 0;\n            Dwarf_Half local_extension_size = 0;\n            Dwarf_Half version               = 0;\n            Dwarf_Half padding               = 0;\n\n            stend = ststart + stsize;\n            res = _dwarf_trial_read_dwarf_five_hdr(dbg,\n                ststart,stsize,stend,\n                &length, &local_offset_size,\n                &local_extension_size,\n                &version,\n                &padding,\n                error);\n            if (res == DW_DLV_OK) {\n                baseoffset = local_extension_size +\n                    local_offset_size +\n                    2*DWARF_HALF_SIZE;\n            } else {\n                if (res == DW_DLV_ERROR) {\n                    dwarf_dealloc_error(dbg,*error);\n                    *error = 0;\n                } else {}\n            }\n        }\n    }\n    offsetintable = baseoffset +indexoffset;\n    end_offsetintable = offsetintable +\n        cu_context->cc_str_offsets_offset_size;\n    /*  The offsets table is a series of offset-size entries.\n        The == case in the test applies when we are at the last table\n        entry, so == is not an error, hence only test >\n    */\n    if (end_offsetintable > dbg->de_debug_str_offsets.dss_size ) {\n        dwarfstring m;\n\n        dwarfstring_constructor(&m);\n        dwarfstring_append_printf_u(&m,\n            \"DW_DLE_ATTR_FORM_SIZE_BAD: The end offset of \"\n            \"a .debug_str_offsets table is 0x%x \",\n            end_offsetintable);\n        dwarfstring_append_printf_u(&m,\n            \"but the object section is just 0x%x \"\n            \"bytes long\",\n            dbg->de_debug_str_offsets.dss_size);\n        _dwarf_error_string(dbg, error,\n            DW_DLE_ATTR_FORM_SIZE_BAD,\n            dwarfstring_string(&m));\n        dwarfstring_destructor(&m);\n        return DW_DLV_ERROR;\n    }\n\n    {\n        Dwarf_Unsigned offsettostr = baseoffset+offsetintable;\n\n        /* Now read the string offset from the offset table. */\n        READ_UNALIGNED_CK(dbg,offsettostr,Dwarf_Unsigned,\n            sof_start+ offsetintable,\n            cu_context->cc_length_size,error,sof_end);\n        *str_sect_offset_out = offsettostr;\n    }\n    return DW_DLV_OK;\n}\n\nint\n_dwarf_extract_local_debug_str_string_given_offset(Dwarf_Debug dbg,\n    unsigned attrform,\n    Dwarf_Unsigned offset,\n    char ** return_str,\n    Dwarf_Error * error)\n{\n    if (attrform == DW_FORM_strp ||\n        attrform == DW_FORM_line_strp ||\n        attrform == DW_FORM_GNU_str_index ||\n        attrform == DW_FORM_strx1 ||\n        attrform == DW_FORM_strx2 ||\n        attrform == DW_FORM_strx3 ||\n        attrform == DW_FORM_strx4 ||\n        attrform == DW_FORM_strx) {\n        /*  The 'offset' into .debug_str or .debug_line_str is given,\n            here we turn that into a pointer. */\n        Dwarf_Small   *secend = 0;\n        Dwarf_Small   *secbegin = 0;\n        Dwarf_Small   *strbegin = 0;\n        Dwarf_Unsigned secsize = 0;\n        int errcode = 0;\n        const char *errname = 0;\n        int res = 0;\n\n        if (attrform == DW_FORM_line_strp) {\n            res = _dwarf_load_section(dbg,\n                &dbg->de_debug_line_str,error);\n            if (res != DW_DLV_OK) {\n                return res;\n            }\n            errcode = DW_DLE_STRP_OFFSET_BAD;\n            errname = \"DW_DLE_STRP_OFFSET_BAD\";\n            secsize = dbg->de_debug_line_str.dss_size;\n            secbegin = dbg->de_debug_line_str.dss_data;\n            strbegin= dbg->de_debug_line_str.dss_data + offset;\n            secend = dbg->de_debug_line_str.dss_data + secsize;\n        } else {\n            /* DW_FORM_strp  etc */\n            res = _dwarf_load_section(dbg, &dbg->de_debug_str,error);\n            if (res != DW_DLV_OK) {\n                return res;\n            }\n            errcode = DW_DLE_STRING_OFFSET_BAD;\n            errname = \"DW_DLE_STRING_OFFSET_BAD\";\n            secsize = dbg->de_debug_str.dss_size;\n            secbegin = dbg->de_debug_str.dss_data;\n            strbegin= dbg->de_debug_str.dss_data + offset;\n            secend = dbg->de_debug_str.dss_data + secsize;\n        }\n        if (offset >= secsize) {\n            dwarfstring m;\n            const char *name = \"<unknownform>\";\n\n            dwarf_get_FORM_name(attrform,&name);\n\n            dwarfstring_constructor(&m);\n            dwarfstring_append(&m,(char *)errname);\n            dwarfstring_append_printf_s(&m,\n                \" Form %s \",(char *)name);\n            dwarfstring_append_printf_u(&m,\n                \"string offset of 0x%\" DW_PR_DUx \" \",\n                offset);\n            dwarfstring_append_printf_u(&m,\n                \"is larger than the string section \"\n                \"size of  0x%\" DW_PR_DUx,\n                secsize);\n            _dwarf_error_string(dbg, error, errcode,\n                dwarfstring_string(&m));\n            dwarfstring_destructor(&m);\n            /*  Badly damaged DWARF here. */\n            return DW_DLV_ERROR;\n        }\n        res= _dwarf_check_string_valid(dbg,secbegin,strbegin, secend,\n            errcode,error);\n        if (res != DW_DLV_OK) {\n            return res;\n        }\n\n        *return_str = (char *)strbegin;\n        return DW_DLV_OK;\n    }\n    generate_form_error(dbg,error,attrform,\n        DW_DLE_ATTR_FORM_BAD,\n        \"DW_DLE_ATTR_FORM_BAD\",\n        \"extract debug_str string\");\n    return DW_DLV_ERROR;\n}\n\n/* Contrary to pre-2005 documentation,\n   The string pointer returned thru return_str must\n   never have dwarf_dealloc() applied to it.\n   Documentation fixed July 2005.\n*/\nint\ndwarf_formstring(Dwarf_Attribute attr,\n    char **return_str, Dwarf_Error * error)\n{\n    Dwarf_CU_Context cu_context = 0;\n    Dwarf_Debug dbg = 0;\n    Dwarf_Unsigned offset = 0;\n    int res = DW_DLV_ERROR;\n    Dwarf_Small *secdataptr = 0;\n    Dwarf_Small *secend = 0;\n    Dwarf_Unsigned secdatalen = 0;\n    Dwarf_Small *infoptr = attr->ar_debug_ptr;\n    Dwarf_Small *contextend = 0;\n\n    res  = get_attr_dbg(&dbg,&cu_context,attr,error);\n    if (res != DW_DLV_OK) {\n        return res;\n    }\n    if (cu_context->cc_is_info) {\n        secdataptr = (Dwarf_Small *)dbg->de_debug_info.dss_data;\n        secdatalen = dbg->de_debug_info.dss_size;\n    } else {\n        secdataptr = (Dwarf_Small *)dbg->de_debug_types.dss_data;\n        secdatalen = dbg->de_debug_types.dss_size;\n    }\n    contextend = secdataptr +\n        cu_context->cc_debug_offset +\n        cu_context->cc_length +\n        cu_context->cc_length_size +\n        cu_context->cc_extension_size;\n    secend = secdataptr + secdatalen;\n    if (contextend < secend) {\n        secend = contextend;\n    }\n    switch(attr->ar_attribute_form) {\n    case DW_FORM_string: {\n        Dwarf_Small *begin = attr->ar_debug_ptr;\n\n        res= _dwarf_check_string_valid(dbg,secdataptr,begin, secend,\n            DW_DLE_FORM_STRING_BAD_STRING,error);\n        if (res != DW_DLV_OK) {\n            return res;\n        }\n        *return_str = (char *) (begin);\n        return DW_DLV_OK;\n    }\n    case DW_FORM_GNU_strp_alt:\n    case DW_FORM_strp_sup:  {\n        Dwarf_Error alterr = 0;\n        Dwarf_Bool is_info = TRUE;\n        /*  See dwarfstd.org issue 120604.1\n            This is the offset in the .debug_str section\n            of another object file.\n            The 'tied' file notion should apply.\n            It is not clear whether both a supplementary\n            and a split object might be needed at the same time\n            (hence two 'tied' files simultaneously). */\n        Dwarf_Off soffset = 0;\n\n        res = dwarf_global_formref_b(attr, &soffset,\n            &is_info,error);\n        if (res != DW_DLV_OK) {\n            return res;\n        }\n        res = _dwarf_get_string_from_tied(dbg, soffset,\n            return_str, &alterr);\n        if (res == DW_DLV_ERROR) {\n            if (dwarf_errno(alterr) ==\n                DW_DLE_NO_TIED_FILE_AVAILABLE) {\n                dwarf_dealloc(dbg,alterr,DW_DLA_ERROR);\n                if ( attr->ar_attribute_form ==\n                    DW_FORM_GNU_strp_alt) {\n                    *return_str =\n                        (char *)\"<DW_FORM_GNU_strp_alt-no-tied-file>\";\n                } else {\n                    *return_str =\n                        (char *)\"<DW_FORM_strp_sup-no-tied-file>\";\n                }\n                return DW_DLV_OK;\n            }\n            if (error) {\n                *error = alterr;\n            } else {\n                dwarf_dealloc_error(dbg,alterr);\n                alterr = 0;\n            }\n            return res;\n        }\n        if (res == DW_DLV_NO_ENTRY) {\n            if ( attr->ar_attribute_form == DW_FORM_GNU_strp_alt) {\n                *return_str =\n                    (char *)\"<DW_FORM_GNU_strp_alt-no-tied-file>\";\n            }else {\n                *return_str =\n                    (char *)\"<DW_FORM_strp_sup-no-tied-file>\";\n            }\n        }\n        return res;\n    }\n    case DW_FORM_GNU_str_index:\n    case DW_FORM_strx:\n    case DW_FORM_strx1:\n    case DW_FORM_strx2:\n    case DW_FORM_strx3:\n    case DW_FORM_strx4: {\n        Dwarf_Unsigned offsettostr= 0;\n\n        res = _dwarf_extract_string_offset_via_str_offsets(dbg,\n            infoptr,\n            secend,\n            attr->ar_attribute,\n            attr->ar_attribute_form,\n            cu_context,\n            &offsettostr,\n            error);\n        if (res != DW_DLV_OK) {\n            return res;\n        }\n        offset = offsettostr;\n        break;\n    }\n    case DW_FORM_strp:\n    case DW_FORM_line_strp:{\n        READ_UNALIGNED_CK(dbg, offset, Dwarf_Unsigned,\n            infoptr,\n            cu_context->cc_length_size,error,secend);\n        break;\n    }\n    default:\n        _dwarf_error(dbg, error, DW_DLE_STRING_FORM_IMPROPER);\n        return DW_DLV_ERROR;\n    }\n    /*  Now we have offset so read the string from\n        debug_str or debug_line_str. */\n    res = _dwarf_extract_local_debug_str_string_given_offset(dbg,\n        attr->ar_attribute_form,\n        offset,\n        return_str,\n        error);\n    return res;\n}\n\nint\n_dwarf_get_string_from_tied(Dwarf_Debug dbg,\n    Dwarf_Unsigned offset,\n    char **return_str,\n    Dwarf_Error*error)\n{\n    Dwarf_Debug tieddbg = 0;\n    Dwarf_Small *secend = 0;\n    Dwarf_Small *secbegin = 0;\n    Dwarf_Small *strbegin = 0;\n    int res = DW_DLV_ERROR;\n    Dwarf_Error localerror = 0;\n\n    /* Attach errors to dbg, not tieddbg. */\n    tieddbg = dbg->de_tied_data.td_tied_object;\n    if (!tieddbg) {\n        _dwarf_error(dbg, error, DW_DLE_NO_TIED_FILE_AVAILABLE);\n        return  DW_DLV_ERROR;\n    }\n    /* The 'offset' into .debug_str is set. */\n    res = _dwarf_load_section(tieddbg, &tieddbg->de_debug_str,\n        &localerror);\n    if (res == DW_DLV_ERROR) {\n        Dwarf_Unsigned lerrno = dwarf_errno(localerror);\n        dwarf_dealloc(tieddbg,localerror,DW_DLA_ERROR);\n        _dwarf_error(dbg,error,lerrno);\n        return res;\n    }\n    if (res == DW_DLV_NO_ENTRY) {\n        return res;\n    }\n    if (offset >= tieddbg->de_debug_str.dss_size) {\n        /*  Badly damaged DWARF here. */\n        _dwarf_error(dbg, error,  DW_DLE_NO_TIED_STRING_AVAILABLE);\n        return DW_DLV_ERROR;\n    }\n    secbegin = tieddbg->de_debug_str.dss_data;\n    strbegin= tieddbg->de_debug_str.dss_data + offset;\n    secend = tieddbg->de_debug_str.dss_data +\n        tieddbg->de_debug_str.dss_size;\n\n    /*  Ensure the offset lies within the .debug_str */\n    if (offset >= tieddbg->de_debug_str.dss_size) {\n        _dwarf_error(dbg, error,  DW_DLE_NO_TIED_STRING_AVAILABLE);\n        return DW_DLV_ERROR;\n    }\n    res= _dwarf_check_string_valid(tieddbg,secbegin,strbegin, secend,\n        DW_DLE_NO_TIED_STRING_AVAILABLE,\n        &localerror);\n    if (res == DW_DLV_ERROR) {\n        Dwarf_Unsigned lerrno = dwarf_errno(localerror);\n        dwarf_dealloc(tieddbg,localerror,DW_DLA_ERROR);\n        _dwarf_error(dbg,error,lerrno);\n        return res;\n    }\n    if (res == DW_DLV_NO_ENTRY) {\n        return res;\n    }\n    *return_str = (char *) (tieddbg->de_debug_str.dss_data + offset);\n    return DW_DLV_OK;\n}\n\nint\ndwarf_formexprloc(Dwarf_Attribute attr,\n    Dwarf_Unsigned * return_exprlen,\n    Dwarf_Ptr  * block_ptr,\n    Dwarf_Error * error)\n{\n    Dwarf_Debug dbg = 0;\n    Dwarf_CU_Context cu_context = 0;\n\n    int res  = get_attr_dbg(&dbg,&cu_context,attr,error);\n    if (res != DW_DLV_OK) {\n        return res;\n    }\n    if (attr->ar_attribute_form == DW_FORM_exprloc ) {\n        Dwarf_Die die = 0;\n        Dwarf_Unsigned leb_len = 0;\n        Dwarf_Byte_Ptr section_start = 0;\n        Dwarf_Unsigned section_len = 0;\n        Dwarf_Byte_Ptr section_end = 0;\n        Dwarf_Byte_Ptr info_ptr = 0;\n        Dwarf_Unsigned exprlen = 0;\n        Dwarf_Small * addr = attr->ar_debug_ptr;\n\n        info_ptr = addr;\n        section_start =\n            _dwarf_calculate_info_section_start_ptr(cu_context,\n            &section_len);\n        section_end = section_start + section_len;\n\n        DECODE_LEB128_UWORD_LEN_CK(info_ptr, exprlen, leb_len,\n            dbg,error,section_end);\n        if (exprlen > section_len) {\n            /* Corrupted dwarf!  */\n            dwarfstring m;\n\n            dwarfstring_constructor(&m);\n            dwarfstring_append_printf_u(&m,\n                \"DW_DLE_ATTR_OUTSIDE_SECTION: \"\n                \"The expression length is %u,\",exprlen);\n            dwarfstring_append_printf_u(&m,\n                \" but the section length is just %u. \"\n                \"Corrupt Dwarf.\",section_len);\n            _dwarf_error_string(dbg, error,\n                DW_DLE_ATTR_OUTSIDE_SECTION,\n                dwarfstring_string(&m));\n            dwarfstring_destructor(&m);\n            return DW_DLV_ERROR;\n        }\n        die = attr->ar_die;\n        /*  Is the block entirely in the section, or is\n            there bug somewhere?\n            Here the final addr may be 1 past end of section. */\n        if (_dwarf_reference_outside_section(die,\n            (Dwarf_Small *)addr,\n            ((Dwarf_Small *)addr)+exprlen +leb_len)) {\n            dwarfstring m;\n\n            dwarfstring_constructor(&m);\n            dwarfstring_append_printf_u(&m,\n                \"DW_DLE_ATTR_OUTSIDE_SECTION: \"\n                \"The expression length %u,\",exprlen);\n            dwarfstring_append_printf_u(&m,\n                \" plus the leb value length of \"\n                \"%u \",leb_len);\n            dwarfstring_append(&m,\n                \" runs past the end of the section. \"\n                \"Corrupt Dwarf.\");\n            _dwarf_error_string(dbg, error,\n                DW_DLE_ATTR_OUTSIDE_SECTION,\n                dwarfstring_string(&m));\n            dwarfstring_destructor(&m);\n            return DW_DLV_ERROR;\n        }\n        *return_exprlen = exprlen;\n        *block_ptr = addr + leb_len;\n        return DW_DLV_OK;\n\n    }\n    {\n        dwarfstring m;\n        const char *name = \"<name not known>\";\n        unsigned  mform = attr->ar_attribute_form;\n\n        dwarfstring_constructor(&m);\n\n        dwarf_get_FORM_name (mform,&name);\n        dwarfstring_append_printf_u(&m,\n            \"DW_DLE_ATTR_EXPRLOC_FORM_BAD: \"\n            \"The form is 0x%x \", mform);\n        dwarfstring_append_printf_s(&m,\n            \"(%s) but should be DW_FORM_exprloc. \"\n            \"Corrupt Dwarf.\",(char *)name);\n        _dwarf_error_string(dbg, error, DW_DLE_ATTR_EXPRLOC_FORM_BAD,\n            dwarfstring_string(&m));\n        dwarfstring_destructor(&m);\n    }\n    return DW_DLV_ERROR;\n}\n"], "filenames": ["src/lib/libdwarf/dwarf_form.c"], "buggy_code_start_loc": [608], "buggy_code_end_loc": [839], "fixing_code_start_loc": [607], "fixing_code_end_loc": [846], "type": "CWE-125", "message": "There is a heap-based buffer over-read in libdwarf 0.4.0. This issue is related to dwarf_global_formref_b.", "other": {"cve": {"id": "CVE-2022-34299", "sourceIdentifier": "cve@mitre.org", "published": "2022-06-23T17:15:18.410", "lastModified": "2022-06-29T22:13:03.497", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "There is a heap-based buffer over-read in libdwarf 0.4.0. This issue is related to dwarf_global_formref_b."}, {"lang": "es", "value": "Se presenta una lectura excesiva del b\u00fafer en la regi\u00f3n heap de la memoria en libdwarf versi\u00f3n 0.4.0. Este problema est\u00e1 relacionado con dwarf_global_formref_b"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libdwarf_project:libdwarf:0.4.0:*:*:*:*:*:*:*", "matchCriteriaId": "448D8623-0083-42B9-A9D1-60A5BF2F6DE5"}]}]}], "references": [{"url": "https://github.com/davea42/libdwarf-code/commit/7ef09e1fc9ba07653dd078edb2408631c7969162", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/davea42/libdwarf-code/issues/119", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/davea42/libdwarf-code/commit/7ef09e1fc9ba07653dd078edb2408631c7969162"}}