{"buggy_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * register.c: functions for managing registers\n */\n\n#include \"vim.h\"\n\n/*\n * Registers:\n *\t0 = unnamed register, for normal yanks and puts\n *   1..9 = registers '1' to '9', for deletes\n * 10..35 = registers 'a' to 'z' ('A' to 'Z' for appending)\n *     36 = delete register '-'\n *     37 = Selection register '*'. Only if FEAT_CLIPBOARD defined\n *     38 = Clipboard register '+'. Only if FEAT_CLIPBOARD and FEAT_X11 defined\n */\nstatic yankreg_T\ty_regs[NUM_REGISTERS];\n\nstatic yankreg_T\t*y_current;\t    // ptr to current yankreg\nstatic int\t\ty_append;\t    // TRUE when appending\nstatic yankreg_T\t*y_previous = NULL; // ptr to last written yankreg\n\nstatic int\tstuff_yank(int, char_u *);\nstatic void\tput_reedit_in_typebuf(int silent);\nstatic int\tput_in_typebuf(char_u *s, int esc, int colon,\n\t\t\t\t\t\t\t\t int silent);\nstatic int\tyank_copy_line(struct block_def *bd, long y_idx, int exclude_trailing_space);\n#ifdef FEAT_CLIPBOARD\nstatic void\tcopy_yank_reg(yankreg_T *reg);\n#endif\nstatic void\tdis_msg(char_u *p, int skip_esc);\n\n#if defined(FEAT_VIMINFO) || defined(PROTO)\n    yankreg_T *\nget_y_regs(void)\n{\n    return y_regs;\n}\n#endif\n\n#if defined(FEAT_CLIPBOARD) || defined(PROTO)\n    yankreg_T *\nget_y_register(int reg)\n{\n    return &y_regs[reg];\n}\n#endif\n\n    yankreg_T *\nget_y_current(void)\n{\n    return y_current;\n}\n\n    yankreg_T *\nget_y_previous(void)\n{\n    return y_previous;\n}\n\n    void\nset_y_current(yankreg_T *yreg)\n{\n    y_current = yreg;\n}\n\n    void\nset_y_previous(yankreg_T *yreg)\n{\n    y_previous = yreg;\n}\n\n    void\nreset_y_append(void)\n{\n    y_append = FALSE;\n}\n\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Keep the last expression line here, for repeating.\n */\nstatic char_u\t*expr_line = NULL;\nstatic exarg_T\t*expr_eap = NULL;\n\n/*\n * Get an expression for the \"\\\"=expr1\" or \"CTRL-R =expr1\"\n * Returns '=' when OK, NUL otherwise.\n */\n    int\nget_expr_register(void)\n{\n    char_u\t*new_line;\n\n    new_line = getcmdline('=', 0L, 0, 0);\n    if (new_line == NULL)\n\treturn NUL;\n    if (*new_line == NUL)\t// use previous line\n\tvim_free(new_line);\n    else\n\tset_expr_line(new_line, NULL);\n    return '=';\n}\n\n/*\n * Set the expression for the '=' register.\n * Argument must be an allocated string.\n * \"eap\" may be used if the next line needs to be checked when evaluating the\n * expression.\n */\n    void\nset_expr_line(char_u *new_line, exarg_T *eap)\n{\n    vim_free(expr_line);\n    expr_line = new_line;\n    expr_eap = eap;\n}\n\n/*\n * Get the result of the '=' register expression.\n * Returns a pointer to allocated memory, or NULL for failure.\n */\n    char_u *\nget_expr_line(void)\n{\n    char_u\t*expr_copy;\n    char_u\t*rv;\n    static int\tnested = 0;\n\n    if (expr_line == NULL)\n\treturn NULL;\n\n    // Make a copy of the expression, because evaluating it may cause it to be\n    // changed.\n    expr_copy = vim_strsave(expr_line);\n    if (expr_copy == NULL)\n\treturn NULL;\n\n    // When we are invoked recursively limit the evaluation to 10 levels.\n    // Then return the string as-is.\n    if (nested >= 10)\n\treturn expr_copy;\n\n    ++nested;\n    rv = eval_to_string_eap(expr_copy, TRUE, expr_eap);\n    --nested;\n    vim_free(expr_copy);\n    return rv;\n}\n\n/*\n * Get the '=' register expression itself, without evaluating it.\n */\n    static char_u *\nget_expr_line_src(void)\n{\n    if (expr_line == NULL)\n\treturn NULL;\n    return vim_strsave(expr_line);\n}\n#endif // FEAT_EVAL\n\n/*\n * Check if 'regname' is a valid name of a yank register.\n * Note: There is no check for 0 (default register), caller should do this\n */\n    int\nvalid_yank_reg(\n    int\t    regname,\n    int\t    writing)\t    // if TRUE check for writable registers\n{\n    if (       (regname > 0 && ASCII_ISALNUM(regname))\n\t    || (!writing && vim_strchr((char_u *)\n#ifdef FEAT_EVAL\n\t\t\t\t    \"/.%:=\"\n#else\n\t\t\t\t    \"/.%:\"\n#endif\n\t\t\t\t\t, regname) != NULL)\n\t    || regname == '#'\n\t    || regname == '\"'\n\t    || regname == '-'\n\t    || regname == '_'\n#ifdef FEAT_CLIPBOARD\n\t    || regname == '*'\n\t    || regname == '+'\n#endif\n#ifdef FEAT_DND\n\t    || (!writing && regname == '~')\n#endif\n\t\t\t\t\t\t\t)\n\treturn TRUE;\n    return FALSE;\n}\n\n/*\n * Set y_current and y_append, according to the value of \"regname\".\n * Cannot handle the '_' register.\n * Must only be called with a valid register name!\n *\n * If regname is 0 and writing, use register 0\n * If regname is 0 and reading, use previous register\n *\n * Return TRUE when the register should be inserted literally (selection or\n * clipboard).\n */\n    int\nget_yank_register(int regname, int writing)\n{\n    int\t    i;\n    int\t    ret = FALSE;\n\n    y_append = FALSE;\n    if ((regname == 0 || regname == '\"') && !writing && y_previous != NULL)\n    {\n\ty_current = y_previous;\n\treturn ret;\n    }\n    i = regname;\n    if (VIM_ISDIGIT(i))\n\ti -= '0';\n    else if (ASCII_ISLOWER(i))\n\ti = CharOrdLow(i) + 10;\n    else if (ASCII_ISUPPER(i))\n    {\n\ti = CharOrdUp(i) + 10;\n\ty_append = TRUE;\n    }\n    else if (regname == '-')\n\ti = DELETION_REGISTER;\n#ifdef FEAT_CLIPBOARD\n    // When selection is not available, use register 0 instead of '*'\n    else if (clip_star.available && regname == '*')\n    {\n\ti = STAR_REGISTER;\n\tret = TRUE;\n    }\n    // When clipboard is not available, use register 0 instead of '+'\n    else if (clip_plus.available && regname == '+')\n    {\n\ti = PLUS_REGISTER;\n\tret = TRUE;\n    }\n#endif\n#ifdef FEAT_DND\n    else if (!writing && regname == '~')\n\ti = TILDE_REGISTER;\n#endif\n    else\t\t// not 0-9, a-z, A-Z or '-': use register 0\n\ti = 0;\n    y_current = &(y_regs[i]);\n    if (writing)\t// remember the register we write into for do_put()\n\ty_previous = y_current;\n    return ret;\n}\n\n/*\n * Obtain the contents of a \"normal\" register. The register is made empty.\n * The returned pointer has allocated memory, use put_register() later.\n */\n    void *\nget_register(\n    int\t\tname,\n    int\t\tcopy)\t// make a copy, if FALSE make register empty.\n{\n    yankreg_T\t*reg;\n    int\t\ti;\n\n#ifdef FEAT_CLIPBOARD\n    // When Visual area changed, may have to update selection.  Obtain the\n    // selection too.\n    if (name == '*' && clip_star.available)\n    {\n\tif (clip_isautosel_star())\n\t    clip_update_selection(&clip_star);\n\tmay_get_selection(name);\n    }\n    if (name == '+' && clip_plus.available)\n    {\n\tif (clip_isautosel_plus())\n\t    clip_update_selection(&clip_plus);\n\tmay_get_selection(name);\n    }\n#endif\n\n    get_yank_register(name, 0);\n    reg = ALLOC_ONE(yankreg_T);\n    if (reg != NULL)\n    {\n\t*reg = *y_current;\n\tif (copy)\n\t{\n\t    // If we run out of memory some or all of the lines are empty.\n\t    if (reg->y_size == 0)\n\t\treg->y_array = NULL;\n\t    else\n\t\treg->y_array = ALLOC_MULT(char_u *, reg->y_size);\n\t    if (reg->y_array != NULL)\n\t    {\n\t\tfor (i = 0; i < reg->y_size; ++i)\n\t\t    reg->y_array[i] = vim_strsave(y_current->y_array[i]);\n\t    }\n\t}\n\telse\n\t    y_current->y_array = NULL;\n    }\n    return (void *)reg;\n}\n\n/*\n * Put \"reg\" into register \"name\".  Free any previous contents and \"reg\".\n */\n    void\nput_register(int name, void *reg)\n{\n    get_yank_register(name, 0);\n    free_yank_all();\n    *y_current = *(yankreg_T *)reg;\n    vim_free(reg);\n\n#ifdef FEAT_CLIPBOARD\n    // Send text written to clipboard register to the clipboard.\n    may_set_selection();\n#endif\n}\n\n#if defined(FEAT_CLIPBOARD) || defined(PROTO)\n    void\nfree_register(void *reg)\n{\n    yankreg_T tmp;\n\n    tmp = *y_current;\n    *y_current = *(yankreg_T *)reg;\n    free_yank_all();\n    vim_free(reg);\n    *y_current = tmp;\n}\n#endif\n\n/*\n * return TRUE if the current yank register has type MLINE\n */\n    int\nyank_register_mline(int regname)\n{\n    if (regname != 0 && !valid_yank_reg(regname, FALSE))\n\treturn FALSE;\n    if (regname == '_')\t\t// black hole is always empty\n\treturn FALSE;\n    get_yank_register(regname, FALSE);\n    return (y_current->y_type == MLINE);\n}\n\n/*\n * Start or stop recording into a yank register.\n *\n * Return FAIL for failure, OK otherwise.\n */\n    int\ndo_record(int c)\n{\n    char_u\t    *p;\n    static int\t    regname;\n    yankreg_T\t    *old_y_previous, *old_y_current;\n    int\t\t    retval;\n\n    if (reg_recording == 0)\t    // start recording\n    {\n\t// registers 0-9, a-z and \" are allowed\n\tif (c < 0 || (!ASCII_ISALNUM(c) && c != '\"'))\n\t    retval = FAIL;\n\telse\n\t{\n\t    reg_recording = c;\n\t    showmode();\n\t    regname = c;\n\t    retval = OK;\n\t}\n    }\n    else\t\t\t    // stop recording\n    {\n\t// Get the recorded key hits.  K_SPECIAL and CSI will be escaped, this\n\t// needs to be removed again to put it in a register.  exec_reg then\n\t// adds the escaping back later.\n\treg_recording = 0;\n\tmsg(\"\");\n\tp = get_recorded();\n\tif (p == NULL)\n\t    retval = FAIL;\n\telse\n\t{\n\t    // Remove escaping for CSI and K_SPECIAL in multi-byte chars.\n\t    vim_unescape_csi(p);\n\n\t    // We don't want to change the default register here, so save and\n\t    // restore the current register name.\n\t    old_y_previous = y_previous;\n\t    old_y_current = y_current;\n\n\t    retval = stuff_yank(regname, p);\n\n\t    y_previous = old_y_previous;\n\t    y_current = old_y_current;\n\t}\n    }\n    return retval;\n}\n\n/*\n * Stuff string \"p\" into yank register \"regname\" as a single line (append if\n * uppercase).\t\"p\" must have been alloced.\n *\n * return FAIL for failure, OK otherwise\n */\n    static int\nstuff_yank(int regname, char_u *p)\n{\n    char_u\t*lp;\n    char_u\t**pp;\n\n    // check for read-only register\n    if (regname != 0 && !valid_yank_reg(regname, TRUE))\n    {\n\tvim_free(p);\n\treturn FAIL;\n    }\n    if (regname == '_')\t\t    // black hole: don't do anything\n    {\n\tvim_free(p);\n\treturn OK;\n    }\n    get_yank_register(regname, TRUE);\n    if (y_append && y_current->y_array != NULL)\n    {\n\tpp = &(y_current->y_array[y_current->y_size - 1]);\n\tlp = alloc(STRLEN(*pp) + STRLEN(p) + 1);\n\tif (lp == NULL)\n\t{\n\t    vim_free(p);\n\t    return FAIL;\n\t}\n\tSTRCPY(lp, *pp);\n\tSTRCAT(lp, p);\n\tvim_free(p);\n\tvim_free(*pp);\n\t*pp = lp;\n    }\n    else\n    {\n\tfree_yank_all();\n\tif ((y_current->y_array = ALLOC_ONE(char_u *)) == NULL)\n\t{\n\t    vim_free(p);\n\t    return FAIL;\n\t}\n\ty_current->y_array[0] = p;\n\ty_current->y_size = 1;\n\ty_current->y_type = MCHAR;  // used to be MLINE, why?\n#ifdef FEAT_VIMINFO\n\ty_current->y_time_set = vim_time();\n#endif\n    }\n    return OK;\n}\n\n/*\n * Last executed register (@ command)\n */\nstatic int execreg_lastc = NUL;\n\n#if defined(FEAT_VIMINFO) || defined(PROTO)\n    int\nget_execreg_lastc(void)\n{\n    return execreg_lastc;\n}\n\n    void\nset_execreg_lastc(int lastc)\n{\n    execreg_lastc = lastc;\n}\n#endif\n\n/*\n * When executing a register as a series of ex-commands, if the\n * line-continuation character is used for a line, then join it with one or\n * more previous lines. Note that lines are processed backwards starting from\n * the last line in the register.\n *\n * Arguments:\n *   lines - list of lines in the register\n *   idx - index of the line starting with \\ or \"\\. Join this line with all the\n *\t   immediate predecessor lines that start with a \\ and the first line\n *\t   that doesn't start with a \\. Lines that start with a comment \"\\\n *\t   character are ignored.\n *\n * Returns the concatenated line. The index of the line that should be\n * processed next is returned in idx.\n */\n    static char_u *\nexecreg_line_continuation(char_u **lines, long *idx)\n{\n    garray_T\tga;\n    long\ti = *idx;\n    char_u\t*p;\n    int\t\tcmd_start;\n    int\t\tcmd_end = i;\n    int\t\tj;\n    char_u\t*str;\n\n    ga_init2(&ga, sizeof(char_u), 400);\n\n    // search backwards to find the first line of this command.\n    // Any line not starting with \\ or \"\\ is the start of the\n    // command.\n    while (--i > 0)\n    {\n\tp = skipwhite(lines[i]);\n\tif (*p != '\\\\' && (p[0] != '\"' || p[1] != '\\\\' || p[2] != ' '))\n\t    break;\n    }\n    cmd_start = i;\n\n    // join all the lines\n    ga_concat(&ga, lines[cmd_start]);\n    for (j = cmd_start + 1; j <= cmd_end; j++)\n    {\n\tp = skipwhite(lines[j]);\n\tif (*p == '\\\\')\n\t{\n\t    // Adjust the growsize to the current length to\n\t    // speed up concatenating many lines.\n\t    if (ga.ga_len > 400)\n\t    {\n\t\tif (ga.ga_len > 8000)\n\t\t    ga.ga_growsize = 8000;\n\t\telse\n\t\t    ga.ga_growsize = ga.ga_len;\n\t    }\n\t    ga_concat(&ga, p + 1);\n\t}\n    }\n    ga_append(&ga, NUL);\n    str = vim_strsave(ga.ga_data);\n    ga_clear(&ga);\n\n    *idx = i;\n    return str;\n}\n\n/*\n * Execute a yank register: copy it into the stuff buffer.\n *\n * Return FAIL for failure, OK otherwise.\n */\n    int\ndo_execreg(\n    int\t    regname,\n    int\t    colon,\t\t// insert ':' before each line\n    int\t    addcr,\t\t// always add '\\n' to end of line\n    int\t    silent)\t\t// set \"silent\" flag in typeahead buffer\n{\n    long\ti;\n    char_u\t*p;\n    int\t\tretval = OK;\n    int\t\tremap;\n\n    // repeat previous one\n    if (regname == '@')\n    {\n\tif (execreg_lastc == NUL)\n\t{\n\t    emsg(_(e_no_previously_used_register));\n\t    return FAIL;\n\t}\n\tregname = execreg_lastc;\n    }\n    // check for valid regname\n    if (regname == '%' || regname == '#' || !valid_yank_reg(regname, FALSE))\n    {\n\temsg_invreg(regname);\n\treturn FAIL;\n    }\n    execreg_lastc = regname;\n\n#ifdef FEAT_CLIPBOARD\n    regname = may_get_selection(regname);\n#endif\n\n    // black hole: don't stuff anything\n    if (regname == '_')\n\treturn OK;\n\n    // use last command line\n    if (regname == ':')\n    {\n\tif (last_cmdline == NULL)\n\t{\n\t    emsg(_(e_no_previous_command_line));\n\t    return FAIL;\n\t}\n\t// don't keep the cmdline containing @:\n\tVIM_CLEAR(new_last_cmdline);\n\t// Escape all control characters with a CTRL-V\n\tp = vim_strsave_escaped_ext(last_cmdline,\n\t\t    (char_u *)\"\\001\\002\\003\\004\\005\\006\\007\"\n\t\t\t  \"\\010\\011\\012\\013\\014\\015\\016\\017\"\n\t\t\t  \"\\020\\021\\022\\023\\024\\025\\026\\027\"\n\t\t\t  \"\\030\\031\\032\\033\\034\\035\\036\\037\",\n\t\t    Ctrl_V, FALSE);\n\tif (p != NULL)\n\t{\n\t    // When in Visual mode \"'<,'>\" will be prepended to the command.\n\t    // Remove it when it's already there.\n\t    if (VIsual_active && STRNCMP(p, \"'<,'>\", 5) == 0)\n\t\tretval = put_in_typebuf(p + 5, TRUE, TRUE, silent);\n\t    else\n\t\tretval = put_in_typebuf(p, TRUE, TRUE, silent);\n\t}\n\tvim_free(p);\n    }\n#ifdef FEAT_EVAL\n    else if (regname == '=')\n    {\n\tp = get_expr_line();\n\tif (p == NULL)\n\t    return FAIL;\n\tretval = put_in_typebuf(p, TRUE, colon, silent);\n\tvim_free(p);\n    }\n#endif\n    else if (regname == '.')\t\t// use last inserted text\n    {\n\tp = get_last_insert_save();\n\tif (p == NULL)\n\t{\n\t    emsg(_(e_no_inserted_text_yet));\n\t    return FAIL;\n\t}\n\tretval = put_in_typebuf(p, FALSE, colon, silent);\n\tvim_free(p);\n    }\n    else\n    {\n\tget_yank_register(regname, FALSE);\n\tif (y_current->y_array == NULL)\n\t    return FAIL;\n\n\t// Disallow remapping for \":@r\".\n\tremap = colon ? REMAP_NONE : REMAP_YES;\n\n\t// Insert lines into typeahead buffer, from last one to first one.\n\tput_reedit_in_typebuf(silent);\n\tfor (i = y_current->y_size; --i >= 0; )\n\t{\n\t    char_u *escaped;\n\t    char_u *str;\n\t    int\t    free_str = FALSE;\n\n\t    // insert NL between lines and after last line if type is MLINE\n\t    if (y_current->y_type == MLINE || i < y_current->y_size - 1\n\t\t\t\t\t\t\t\t     || addcr)\n\t    {\n\t\tif (ins_typebuf((char_u *)\"\\n\", remap, 0, TRUE, silent) == FAIL)\n\t\t    return FAIL;\n\t    }\n\n\t    // Handle line-continuation for :@<register>\n\t    str = y_current->y_array[i];\n\t    if (colon && i > 0)\n\t    {\n\t\tp = skipwhite(str);\n\t\tif (*p == '\\\\' || (p[0] == '\"' && p[1] == '\\\\' && p[2] == ' '))\n\t\t{\n\t\t    str = execreg_line_continuation(y_current->y_array, &i);\n\t\t    if (str == NULL)\n\t\t\treturn FAIL;\n\t\t    free_str = TRUE;\n\t\t}\n\t    }\n\t    escaped = vim_strsave_escape_csi(str);\n\t    if (free_str)\n\t\tvim_free(str);\n\t    if (escaped == NULL)\n\t\treturn FAIL;\n\t    retval = ins_typebuf(escaped, remap, 0, TRUE, silent);\n\t    vim_free(escaped);\n\t    if (retval == FAIL)\n\t\treturn FAIL;\n\t    if (colon && ins_typebuf((char_u *)\":\", remap, 0, TRUE, silent)\n\t\t\t\t\t\t\t\t      == FAIL)\n\t\treturn FAIL;\n\t}\n\treg_executing = regname == 0 ? '\"' : regname; // disable \"q\" command\n    }\n    return retval;\n}\n\n/*\n * If \"restart_edit\" is not zero, put it in the typeahead buffer, so that it's\n * used only after other typeahead has been processed.\n */\n    static void\nput_reedit_in_typebuf(int silent)\n{\n    char_u\tbuf[3];\n\n    if (restart_edit != NUL)\n    {\n\tif (restart_edit == 'V')\n\t{\n\t    buf[0] = 'g';\n\t    buf[1] = 'R';\n\t    buf[2] = NUL;\n\t}\n\telse\n\t{\n\t    buf[0] = restart_edit == 'I' ? 'i' : restart_edit;\n\t    buf[1] = NUL;\n\t}\n\tif (ins_typebuf(buf, REMAP_NONE, 0, TRUE, silent) == OK)\n\t    restart_edit = NUL;\n    }\n}\n\n/*\n * Insert register contents \"s\" into the typeahead buffer, so that it will be\n * executed again.\n * When \"esc\" is TRUE it is to be taken literally: Escape CSI characters and\n * no remapping.\n */\n    static int\nput_in_typebuf(\n    char_u\t*s,\n    int\t\tesc,\n    int\t\tcolon,\t    // add ':' before the line\n    int\t\tsilent)\n{\n    int\t\tretval = OK;\n\n    put_reedit_in_typebuf(silent);\n    if (colon)\n\tretval = ins_typebuf((char_u *)\"\\n\", REMAP_NONE, 0, TRUE, silent);\n    if (retval == OK)\n    {\n\tchar_u\t*p;\n\n\tif (esc)\n\t    p = vim_strsave_escape_csi(s);\n\telse\n\t    p = s;\n\tif (p == NULL)\n\t    retval = FAIL;\n\telse\n\t    retval = ins_typebuf(p, esc ? REMAP_NONE : REMAP_YES,\n\t\t\t\t\t\t\t     0, TRUE, silent);\n\tif (esc)\n\t    vim_free(p);\n    }\n    if (colon && retval == OK)\n\tretval = ins_typebuf((char_u *)\":\", REMAP_NONE, 0, TRUE, silent);\n    return retval;\n}\n\n/*\n * Insert a yank register: copy it into the Read buffer.\n * Used by CTRL-R command and middle mouse button in insert mode.\n *\n * return FAIL for failure, OK otherwise\n */\n    int\ninsert_reg(\n    int\t\tregname,\n    int\t\tliterally_arg)\t// insert literally, not as if typed\n{\n    long\ti;\n    int\t\tretval = OK;\n    char_u\t*arg;\n    int\t\tallocated;\n    int\t\tliterally = literally_arg;\n\n    // It is possible to get into an endless loop by having CTRL-R a in\n    // register a and then, in insert mode, doing CTRL-R a.\n    // If you hit CTRL-C, the loop will be broken here.\n    ui_breakcheck();\n    if (got_int)\n\treturn FAIL;\n\n    // check for valid regname\n    if (regname != NUL && !valid_yank_reg(regname, FALSE))\n\treturn FAIL;\n\n#ifdef FEAT_CLIPBOARD\n    regname = may_get_selection(regname);\n#endif\n\n    if (regname == '.')\t\t\t// insert last inserted text\n\tretval = stuff_inserted(NUL, 1L, TRUE);\n    else if (get_spec_reg(regname, &arg, &allocated, TRUE))\n    {\n\tif (arg == NULL)\n\t    return FAIL;\n\tstuffescaped(arg, literally);\n\tif (allocated)\n\t    vim_free(arg);\n    }\n    else\t\t\t\t// name or number register\n    {\n\tif (get_yank_register(regname, FALSE))\n\t    literally = TRUE;\n\tif (y_current->y_array == NULL)\n\t    retval = FAIL;\n\telse\n\t{\n\t    for (i = 0; i < y_current->y_size; ++i)\n\t    {\n\t\tif (regname == '-')\n\t\t{\n\t\t    AppendCharToRedobuff(Ctrl_R);\n\t\t    AppendCharToRedobuff(regname);\n\t\t    do_put(regname, NULL, BACKWARD, 1L, PUT_CURSEND);\n\t\t}\n\t\telse\n\t\t    stuffescaped(y_current->y_array[i], literally);\n\t\t// Insert a newline between lines and after last line if\n\t\t// y_type is MLINE.\n\t\tif (y_current->y_type == MLINE || i < y_current->y_size - 1)\n\t\t    stuffcharReadbuff('\\n');\n\t    }\n\t}\n    }\n\n    return retval;\n}\n\n/*\n * If \"regname\" is a special register, return TRUE and store a pointer to its\n * value in \"argp\".\n */\n    int\nget_spec_reg(\n    int\t\tregname,\n    char_u\t**argp,\n    int\t\t*allocated,\t// return: TRUE when value was allocated\n    int\t\terrmsg)\t\t// give error message when failing\n{\n    int\t\tcnt;\n\n    *argp = NULL;\n    *allocated = FALSE;\n    switch (regname)\n    {\n\tcase '%':\t\t// file name\n\t    if (errmsg)\n\t\tcheck_fname();\t// will give emsg if not set\n\t    *argp = curbuf->b_fname;\n\t    return TRUE;\n\n\tcase '#':\t\t// alternate file name\n\t    *argp = getaltfname(errmsg);\t// may give emsg if not set\n\t    return TRUE;\n\n#ifdef FEAT_EVAL\n\tcase '=':\t\t// result of expression\n\t    *argp = get_expr_line();\n\t    *allocated = TRUE;\n\t    return TRUE;\n#endif\n\n\tcase ':':\t\t// last command line\n\t    if (last_cmdline == NULL && errmsg)\n\t\temsg(_(e_no_previous_command_line));\n\t    *argp = last_cmdline;\n\t    return TRUE;\n\n\tcase '/':\t\t// last search-pattern\n\t    if (last_search_pat() == NULL && errmsg)\n\t\temsg(_(e_no_previous_regular_expression));\n\t    *argp = last_search_pat();\n\t    return TRUE;\n\n\tcase '.':\t\t// last inserted text\n\t    *argp = get_last_insert_save();\n\t    *allocated = TRUE;\n\t    if (*argp == NULL && errmsg)\n\t\temsg(_(e_no_inserted_text_yet));\n\t    return TRUE;\n\n#ifdef FEAT_SEARCHPATH\n\tcase Ctrl_F:\t\t// Filename under cursor\n\tcase Ctrl_P:\t\t// Path under cursor, expand via \"path\"\n\t    if (!errmsg)\n\t\treturn FALSE;\n\t    *argp = file_name_at_cursor(FNAME_MESS | FNAME_HYP\n\t\t\t    | (regname == Ctrl_P ? FNAME_EXP : 0), 1L, NULL);\n\t    *allocated = TRUE;\n\t    return TRUE;\n#endif\n\n\tcase Ctrl_W:\t\t// word under cursor\n\tcase Ctrl_A:\t\t// WORD (mnemonic All) under cursor\n\t    if (!errmsg)\n\t\treturn FALSE;\n\t    cnt = find_ident_under_cursor(argp, regname == Ctrl_W\n\t\t\t\t   ?  (FIND_IDENT|FIND_STRING) : FIND_STRING);\n\t    *argp = cnt ? vim_strnsave(*argp, cnt) : NULL;\n\t    *allocated = TRUE;\n\t    return TRUE;\n\n\tcase Ctrl_L:\t\t// Line under cursor\n\t    if (!errmsg)\n\t\treturn FALSE;\n\n\t    *argp = ml_get_buf(curwin->w_buffer,\n\t\t\tcurwin->w_cursor.lnum, FALSE);\n\t    return TRUE;\n\n\tcase '_':\t\t// black hole: always empty\n\t    *argp = (char_u *)\"\";\n\t    return TRUE;\n    }\n\n    return FALSE;\n}\n\n/*\n * Paste a yank register into the command line.\n * Only for non-special registers.\n * Used by CTRL-R command in command-line mode\n * insert_reg() can't be used here, because special characters from the\n * register contents will be interpreted as commands.\n *\n * return FAIL for failure, OK otherwise\n */\n    int\ncmdline_paste_reg(\n    int regname,\n    int literally_arg,\t// Insert text literally instead of \"as typed\"\n    int remcr)\t\t// don't add CR characters\n{\n    long\ti;\n    int\t\tliterally = literally_arg;\n\n    if (get_yank_register(regname, FALSE))\n\tliterally = TRUE;\n    if (y_current->y_array == NULL)\n\treturn FAIL;\n\n    for (i = 0; i < y_current->y_size; ++i)\n    {\n\tcmdline_paste_str(y_current->y_array[i], literally);\n\n\t// Insert ^M between lines and after last line if type is MLINE.\n\t// Don't do this when \"remcr\" is TRUE.\n\tif ((y_current->y_type == MLINE || i < y_current->y_size - 1) && !remcr)\n\t    cmdline_paste_str((char_u *)\"\\r\", literally);\n\n\t// Check for CTRL-C, in case someone tries to paste a few thousand\n\t// lines and gets bored.\n\tui_breakcheck();\n\tif (got_int)\n\t    return FAIL;\n    }\n    return OK;\n}\n\n/*\n * Shift the delete registers: \"9 is cleared, \"8 becomes \"9, etc.\n */\n    void\nshift_delete_registers()\n{\n    int\t\tn;\n\n    y_current = &y_regs[9];\n    free_yank_all();\t\t\t// free register nine\n    for (n = 9; n > 1; --n)\n\ty_regs[n] = y_regs[n - 1];\n    y_current = &y_regs[1];\n    if (!y_append)\n\ty_previous = y_current;\n    y_regs[1].y_array = NULL;\t\t// set register one to empty\n}\n\n#if defined(FEAT_EVAL)\n    void\nyank_do_autocmd(oparg_T *oap, yankreg_T *reg)\n{\n    static int\t    recursive = FALSE;\n    dict_T\t    *v_event;\n    list_T\t    *list;\n    int\t\t    n;\n    char_u\t    buf[NUMBUFLEN + 2];\n    long\t    reglen = 0;\n    save_v_event_T  save_v_event;\n\n    if (recursive)\n\treturn;\n\n    v_event = get_v_event(&save_v_event);\n\n    list = list_alloc();\n    if (list == NULL)\n\treturn;\n\n    // yanked text contents\n    for (n = 0; n < reg->y_size; n++)\n\tlist_append_string(list, reg->y_array[n], -1);\n    list->lv_lock = VAR_FIXED;\n    (void)dict_add_list(v_event, \"regcontents\", list);\n\n    // register name or empty string for unnamed operation\n    buf[0] = (char_u)oap->regname;\n    buf[1] = NUL;\n    (void)dict_add_string(v_event, \"regname\", buf);\n\n    // motion type: inclusive or exclusive\n    (void)dict_add_bool(v_event, \"inclusive\", oap->inclusive);\n\n    // kind of operation (yank, delete, change)\n    buf[0] = get_op_char(oap->op_type);\n    buf[1] = get_extra_op_char(oap->op_type);\n    buf[2] = NUL;\n    (void)dict_add_string(v_event, \"operator\", buf);\n\n    // register type\n    buf[0] = NUL;\n    buf[1] = NUL;\n    switch (get_reg_type(oap->regname, &reglen))\n    {\n\tcase MLINE: buf[0] = 'V'; break;\n\tcase MCHAR: buf[0] = 'v'; break;\n\tcase MBLOCK:\n\t\tvim_snprintf((char *)buf, sizeof(buf), \"%c%ld\", Ctrl_V,\n\t\t\t     reglen + 1);\n\t\tbreak;\n    }\n    (void)dict_add_string(v_event, \"regtype\", buf);\n\n    // selection type - visual or not\n    (void)dict_add_bool(v_event, \"visual\", oap->is_VIsual);\n\n    // Lock the dictionary and its keys\n    dict_set_items_ro(v_event);\n\n    recursive = TRUE;\n    textlock++;\n    apply_autocmds(EVENT_TEXTYANKPOST, NULL, NULL, FALSE, curbuf);\n    textlock--;\n    recursive = FALSE;\n\n    // Empty the dictionary, v:event is still valid\n    restore_v_event(v_event, &save_v_event);\n}\n#endif\n\n/*\n * set all the yank registers to empty (called from main())\n */\n    void\ninit_yank(void)\n{\n    int\t\ti;\n\n    for (i = 0; i < NUM_REGISTERS; ++i)\n\ty_regs[i].y_array = NULL;\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nclear_registers(void)\n{\n    int\t\ti;\n\n    for (i = 0; i < NUM_REGISTERS; ++i)\n    {\n\ty_current = &y_regs[i];\n\tif (y_current->y_array != NULL)\n\t    free_yank_all();\n    }\n}\n#endif\n\n/*\n * Free \"n\" lines from the current yank register.\n * Called for normal freeing and in case of error.\n */\n    static void\nfree_yank(long n)\n{\n    if (y_current->y_array != NULL)\n    {\n\tlong\t    i;\n\n\tfor (i = n; --i >= 0; )\n\t    vim_free(y_current->y_array[i]);\n\tVIM_CLEAR(y_current->y_array);\n    }\n}\n\n    void\nfree_yank_all(void)\n{\n    free_yank(y_current->y_size);\n}\n\n/*\n * Yank the text between \"oap->start\" and \"oap->end\" into a yank register.\n * If we are to append (uppercase register), we first yank into a new yank\n * register and then concatenate the old and the new one (so we keep the old\n * one in case of out-of-memory).\n *\n * Return FAIL for failure, OK otherwise.\n */\n    int\nop_yank(oparg_T *oap, int deleting, int mess)\n{\n    long\t\ty_idx;\t\t// index in y_array[]\n    yankreg_T\t\t*curr;\t\t// copy of y_current\n    yankreg_T\t\tnewreg;\t\t// new yank register when appending\n    char_u\t\t**new_ptr;\n    linenr_T\t\tlnum;\t\t// current line number\n    long\t\tj;\n    int\t\t\tyanktype = oap->motion_type;\n    long\t\tyanklines = oap->line_count;\n    linenr_T\t\tyankendlnum = oap->end.lnum;\n    char_u\t\t*p;\n    char_u\t\t*pnew;\n    struct block_def\tbd;\n#if defined(FEAT_CLIPBOARD) && defined(FEAT_X11)\n    int\t\t\tdid_star = FALSE;\n#endif\n\n\t\t\t\t    // check for read-only register\n    if (oap->regname != 0 && !valid_yank_reg(oap->regname, TRUE))\n    {\n\tbeep_flush();\n\treturn FAIL;\n    }\n    if (oap->regname == '_')\t    // black hole: nothing to do\n\treturn OK;\n\n#ifdef FEAT_CLIPBOARD\n    if (!clip_star.available && oap->regname == '*')\n\toap->regname = 0;\n    else if (!clip_plus.available && oap->regname == '+')\n\toap->regname = 0;\n#endif\n\n    if (!deleting)\t\t    // op_delete() already set y_current\n\tget_yank_register(oap->regname, TRUE);\n\n    curr = y_current;\n\t\t\t\t    // append to existing contents\n    if (y_append && y_current->y_array != NULL)\n\ty_current = &newreg;\n    else\n\tfree_yank_all();\t    // free previously yanked lines\n\n    // If the cursor was in column 1 before and after the movement, and the\n    // operator is not inclusive, the yank is always linewise.\n    if (       oap->motion_type == MCHAR\n\t    && oap->start.col == 0\n\t    && !oap->inclusive\n\t    && (!oap->is_VIsual || *p_sel == 'o')\n\t    && !oap->block_mode\n\t    && oap->end.col == 0\n\t    && yanklines > 1)\n    {\n\tyanktype = MLINE;\n\t--yankendlnum;\n\t--yanklines;\n    }\n\n    y_current->y_size = yanklines;\n    y_current->y_type = yanktype;   // set the yank register type\n    y_current->y_width = 0;\n    y_current->y_array = lalloc_clear(sizeof(char_u *) * yanklines, TRUE);\n    if (y_current->y_array == NULL)\n    {\n\ty_current = curr;\n\treturn FAIL;\n    }\n#ifdef FEAT_VIMINFO\n    y_current->y_time_set = vim_time();\n#endif\n\n    y_idx = 0;\n    lnum = oap->start.lnum;\n\n    if (oap->block_mode)\n    {\n\t// Visual block mode\n\ty_current->y_type = MBLOCK;\t    // set the yank register type\n\ty_current->y_width = oap->end_vcol - oap->start_vcol;\n\n\tif (curwin->w_curswant == MAXCOL && y_current->y_width > 0)\n\t    y_current->y_width--;\n    }\n\n    for ( ; lnum <= yankendlnum; lnum++, y_idx++)\n    {\n\tswitch (y_current->y_type)\n\t{\n\t    case MBLOCK:\n\t\tblock_prep(oap, &bd, lnum, FALSE);\n\t\tif (yank_copy_line(&bd, y_idx, oap->excl_tr_ws) == FAIL)\n\t\t    goto fail;\n\t\tbreak;\n\n\t    case MLINE:\n\t\tif ((y_current->y_array[y_idx] =\n\t\t\t\t\t    vim_strsave(ml_get(lnum))) == NULL)\n\t\t    goto fail;\n\t\tbreak;\n\n\t    case MCHAR:\n\t\t{\n\t\t    colnr_T startcol = 0, endcol = MAXCOL;\n\t\t    int\t    is_oneChar = FALSE;\n\t\t    colnr_T cs, ce;\n\n\t\t    p = ml_get(lnum);\n\t\t    bd.startspaces = 0;\n\t\t    bd.endspaces = 0;\n\n\t\t    if (lnum == oap->start.lnum)\n\t\t    {\n\t\t\tstartcol = oap->start.col;\n\t\t\tif (virtual_op)\n\t\t\t{\n\t\t\t    getvcol(curwin, &oap->start, &cs, NULL, &ce);\n\t\t\t    if (ce != cs && oap->start.coladd > 0)\n\t\t\t    {\n\t\t\t\t// Part of a tab selected -- but don't\n\t\t\t\t// double-count it.\n\t\t\t\tbd.startspaces = (ce - cs + 1)\n\t\t\t\t\t\t\t  - oap->start.coladd;\n\t\t\t\tstartcol++;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\n\t\t    if (lnum == oap->end.lnum)\n\t\t    {\n\t\t\tendcol = oap->end.col;\n\t\t\tif (virtual_op)\n\t\t\t{\n\t\t\t    getvcol(curwin, &oap->end, &cs, NULL, &ce);\n\t\t\t    if (p[endcol] == NUL || (cs + oap->end.coladd < ce\n\t\t\t\t\t// Don't add space for double-wide\n\t\t\t\t\t// char; endcol will be on last byte\n\t\t\t\t\t// of multi-byte char.\n\t\t\t\t\t&& (*mb_head_off)(p, p + endcol) == 0))\n\t\t\t    {\n\t\t\t\tif (oap->start.lnum == oap->end.lnum\n\t\t\t\t\t    && oap->start.col == oap->end.col)\n\t\t\t\t{\n\t\t\t\t    // Special case: inside a single char\n\t\t\t\t    is_oneChar = TRUE;\n\t\t\t\t    bd.startspaces = oap->end.coladd\n\t\t\t\t\t - oap->start.coladd + oap->inclusive;\n\t\t\t\t    endcol = startcol;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t    bd.endspaces = oap->end.coladd\n\t\t\t\t\t\t\t     + oap->inclusive;\n\t\t\t\t    endcol -= oap->inclusive;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    if (endcol == MAXCOL)\n\t\t\tendcol = (colnr_T)STRLEN(p);\n\t\t    if (startcol > endcol || is_oneChar)\n\t\t\tbd.textlen = 0;\n\t\t    else\n\t\t\tbd.textlen = endcol - startcol + oap->inclusive;\n\t\t    bd.textstart = p + startcol;\n\t\t    if (yank_copy_line(&bd, y_idx, FALSE) == FAIL)\n\t\t\tgoto fail;\n\t\t    break;\n\t\t}\n\t\t// NOTREACHED\n\t}\n    }\n\n    if (curr != y_current)\t// append the new block to the old block\n    {\n\tnew_ptr = ALLOC_MULT(char_u *, curr->y_size + y_current->y_size);\n\tif (new_ptr == NULL)\n\t    goto fail;\n\tfor (j = 0; j < curr->y_size; ++j)\n\t    new_ptr[j] = curr->y_array[j];\n\tvim_free(curr->y_array);\n\tcurr->y_array = new_ptr;\n#ifdef FEAT_VIMINFO\n\tcurr->y_time_set = vim_time();\n#endif\n\n\tif (yanktype == MLINE)\t// MLINE overrides MCHAR and MBLOCK\n\t    curr->y_type = MLINE;\n\n\t// Concatenate the last line of the old block with the first line of\n\t// the new block, unless being Vi compatible.\n\tif (curr->y_type == MCHAR && vim_strchr(p_cpo, CPO_REGAPPEND) == NULL)\n\t{\n\t    pnew = alloc(STRLEN(curr->y_array[curr->y_size - 1])\n\t\t\t\t\t  + STRLEN(y_current->y_array[0]) + 1);\n\t    if (pnew == NULL)\n\t    {\n\t\ty_idx = y_current->y_size - 1;\n\t\tgoto fail;\n\t    }\n\t    STRCPY(pnew, curr->y_array[--j]);\n\t    STRCAT(pnew, y_current->y_array[0]);\n\t    vim_free(curr->y_array[j]);\n\t    vim_free(y_current->y_array[0]);\n\t    curr->y_array[j++] = pnew;\n\t    y_idx = 1;\n\t}\n\telse\n\t    y_idx = 0;\n\twhile (y_idx < y_current->y_size)\n\t    curr->y_array[j++] = y_current->y_array[y_idx++];\n\tcurr->y_size = j;\n\tvim_free(y_current->y_array);\n\ty_current = curr;\n    }\n\n    if (mess)\t\t\t// Display message about yank?\n    {\n\tif (yanktype == MCHAR\n\t\t&& !oap->block_mode\n\t\t&& yanklines == 1)\n\t    yanklines = 0;\n\t// Some versions of Vi use \">=\" here, some don't...\n\tif (yanklines > p_report)\n\t{\n\t    char namebuf[100];\n\n\t    if (oap->regname == NUL)\n\t\t*namebuf = NUL;\n\t    else\n\t\tvim_snprintf(namebuf, sizeof(namebuf),\n\t\t\t\t\t\t_(\" into \\\"%c\"), oap->regname);\n\n\t    // redisplay now, so message is not deleted\n\t    update_topline_redraw();\n\t    if (oap->block_mode)\n\t    {\n\t\tsmsg(NGETTEXT(\"block of %ld line yanked%s\",\n\t\t\t\t     \"block of %ld lines yanked%s\", yanklines),\n\t\t\tyanklines, namebuf);\n\t    }\n\t    else\n\t    {\n\t\tsmsg(NGETTEXT(\"%ld line yanked%s\",\n\t\t\t\t\t      \"%ld lines yanked%s\", yanklines),\n\t\t\tyanklines, namebuf);\n\t    }\n\t}\n    }\n\n    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n    {\n\t// Set \"'[\" and \"']\" marks.\n\tcurbuf->b_op_start = oap->start;\n\tcurbuf->b_op_end = oap->end;\n\tif (yanktype == MLINE && !oap->block_mode)\n\t{\n\t    curbuf->b_op_start.col = 0;\n\t    curbuf->b_op_end.col = MAXCOL;\n\t}\n    }\n\n#ifdef FEAT_CLIPBOARD\n    // If we were yanking to the '*' register, send result to clipboard.\n    // If no register was specified, and \"unnamed\" in 'clipboard', make a copy\n    // to the '*' register.\n    if (clip_star.available\n\t    && (curr == &(y_regs[STAR_REGISTER])\n\t\t|| (!deleting && oap->regname == 0\n\t\t   && ((clip_unnamed | clip_unnamed_saved) & CLIP_UNNAMED))))\n    {\n\tif (curr != &(y_regs[STAR_REGISTER]))\n\t    // Copy the text from register 0 to the clipboard register.\n\t    copy_yank_reg(&(y_regs[STAR_REGISTER]));\n\n\tclip_own_selection(&clip_star);\n\tclip_gen_set_selection(&clip_star);\n# ifdef FEAT_X11\n\tdid_star = TRUE;\n# endif\n    }\n\n# ifdef FEAT_X11\n    // If we were yanking to the '+' register, send result to selection.\n    // Also copy to the '*' register, in case auto-select is off.  But not when\n    // 'clipboard' has \"unnamedplus\" and not \"unnamed\".\n    if (clip_plus.available\n\t    && (curr == &(y_regs[PLUS_REGISTER])\n\t\t|| (!deleting && oap->regname == 0\n\t\t  && ((clip_unnamed | clip_unnamed_saved) &\n\t\t\t\t\t\t\t  CLIP_UNNAMED_PLUS))))\n    {\n\tif (curr != &(y_regs[PLUS_REGISTER]))\n\t    // Copy the text from register 0 to the clipboard register.\n\t    copy_yank_reg(&(y_regs[PLUS_REGISTER]));\n\n\tclip_own_selection(&clip_plus);\n\tclip_gen_set_selection(&clip_plus);\n\tif (!clip_isautosel_star()\n\t\t&& !clip_isautosel_plus()\n\t\t&& !((clip_unnamed | clip_unnamed_saved) == CLIP_UNNAMED_PLUS)\n\t\t&& !did_star\n\t\t&& curr == &(y_regs[PLUS_REGISTER]))\n\t{\n\t    copy_yank_reg(&(y_regs[STAR_REGISTER]));\n\t    clip_own_selection(&clip_star);\n\t    clip_gen_set_selection(&clip_star);\n\t}\n    }\n# endif\n#endif\n\n#if defined(FEAT_EVAL)\n    if (!deleting && has_textyankpost())\n\tyank_do_autocmd(oap, y_current);\n#endif\n\n    return OK;\n\nfail:\t\t// free the allocated lines\n    free_yank(y_idx + 1);\n    y_current = curr;\n    return FAIL;\n}\n\n/*\n * Copy a block range into a register.\n * If \"exclude_trailing_space\" is set, do not copy trailing whitespaces.\n */\n    static int\nyank_copy_line(struct block_def *bd, long y_idx, int exclude_trailing_space)\n{\n    char_u\t*pnew;\n\n    if (exclude_trailing_space)\n\tbd->endspaces = 0;\n    if ((pnew = alloc(bd->startspaces + bd->endspaces + bd->textlen + 1))\n\t\t\t\t\t\t\t\t      == NULL)\n\treturn FAIL;\n    y_current->y_array[y_idx] = pnew;\n    vim_memset(pnew, ' ', (size_t)bd->startspaces);\n    pnew += bd->startspaces;\n    mch_memmove(pnew, bd->textstart, (size_t)bd->textlen);\n    pnew += bd->textlen;\n    vim_memset(pnew, ' ', (size_t)bd->endspaces);\n    pnew += bd->endspaces;\n    if (exclude_trailing_space)\n    {\n\tint s = bd->textlen + bd->endspaces;\n\n\twhile (s > 0 && VIM_ISWHITE(*(bd->textstart + s - 1)))\n\t{\n\t    s = s - (*mb_head_off)(bd->textstart, bd->textstart + s - 1) - 1;\n\t    pnew--;\n\t}\n    }\n    *pnew = NUL;\n    return OK;\n}\n\n#ifdef FEAT_CLIPBOARD\n/*\n * Make a copy of the y_current register to register \"reg\".\n */\n    static void\ncopy_yank_reg(yankreg_T *reg)\n{\n    yankreg_T\t*curr = y_current;\n    long\tj;\n\n    y_current = reg;\n    free_yank_all();\n    *y_current = *curr;\n    y_current->y_array = lalloc_clear(\n\t\t\t\t    sizeof(char_u *) * y_current->y_size, TRUE);\n    if (y_current->y_array == NULL)\n\ty_current->y_size = 0;\n    else\n\tfor (j = 0; j < y_current->y_size; ++j)\n\t    if ((y_current->y_array[j] = vim_strsave(curr->y_array[j])) == NULL)\n\t    {\n\t\tfree_yank(j);\n\t\ty_current->y_size = 0;\n\t\tbreak;\n\t    }\n    y_current = curr;\n}\n#endif\n\n/*\n * Put contents of register \"regname\" into the text.\n * Caller must check \"regname\" to be valid!\n * \"flags\": PUT_FIXINDENT\tmake indent look nice\n *\t    PUT_CURSEND\t\tleave cursor after end of new text\n *\t    PUT_LINE\t\tforce linewise put (\":put\")\n *\t    PUT_BLOCK_INNER     in block mode, do not add trailing spaces\n */\n    void\ndo_put(\n    int\t\tregname,\n    char_u\t*expr_result,\t// result for regname \"=\" when compiled\n    int\t\tdir,\t\t// BACKWARD for 'P', FORWARD for 'p'\n    long\tcount,\n    int\t\tflags)\n{\n    char_u\t*ptr;\n    char_u\t*newp, *oldp;\n    int\t\tyanklen;\n    int\t\ttotlen = 0;\t\t// init for gcc\n    linenr_T\tlnum;\n    colnr_T\tcol;\n    long\ti;\t\t\t// index in y_array[]\n    int\t\ty_type;\n    long\ty_size;\n    int\t\toldlen;\n    long\ty_width = 0;\n    colnr_T\tvcol;\n    int\t\tdelcount;\n    int\t\tincr = 0;\n    long\tj;\n    struct block_def bd;\n    char_u\t**y_array = NULL;\n    yankreg_T\t*y_current_used = NULL;\n    long\tnr_lines = 0;\n    pos_T\tnew_cursor;\n    int\t\tindent;\n    int\t\torig_indent = 0;\t// init for gcc\n    int\t\tindent_diff = 0;\t// init for gcc\n    int\t\tfirst_indent = TRUE;\n    int\t\tlendiff = 0;\n    pos_T\told_pos;\n    char_u\t*insert_string = NULL;\n    int\t\tallocated = FALSE;\n    long\tcnt;\n    pos_T\torig_start = curbuf->b_op_start;\n    pos_T\torig_end = curbuf->b_op_end;\n    unsigned int cur_ve_flags = get_ve_flags();\n\n#ifdef FEAT_CLIPBOARD\n    // Adjust register name for \"unnamed\" in 'clipboard'.\n    adjust_clip_reg(&regname);\n    (void)may_get_selection(regname);\n#endif\n\n    if (flags & PUT_FIXINDENT)\n\torig_indent = get_indent();\n\n    curbuf->b_op_start = curwin->w_cursor;\t// default for '[ mark\n    curbuf->b_op_end = curwin->w_cursor;\t// default for '] mark\n\n    // Using inserted text works differently, because the register includes\n    // special characters (newlines, etc.).\n    if (regname == '.')\n    {\n\tif (VIsual_active)\n\t    stuffcharReadbuff(VIsual_mode);\n\t(void)stuff_inserted((dir == FORWARD ? (count == -1 ? 'o' : 'a') :\n\t\t\t\t    (count == -1 ? 'O' : 'i')), count, FALSE);\n\t// Putting the text is done later, so can't really move the cursor to\n\t// the next character.  Use \"l\" to simulate it.\n\tif ((flags & PUT_CURSEND) && gchar_cursor() != NUL)\n\t    stuffcharReadbuff('l');\n\treturn;\n    }\n\n    // For special registers '%' (file name), '#' (alternate file name) and\n    // ':' (last command line), etc. we have to create a fake yank register.\n    // For compiled code \"expr_result\" holds the expression result.\n    if (regname == '=' && expr_result != NULL)\n\tinsert_string = expr_result;\n    else if (get_spec_reg(regname, &insert_string, &allocated, TRUE)\n\t\t&& insert_string == NULL)\n\treturn;\n\n    // Autocommands may be executed when saving lines for undo.  This might\n    // make \"y_array\" invalid, so we start undo now to avoid that.\n    if (u_save(curwin->w_cursor.lnum, curwin->w_cursor.lnum + 1) == FAIL)\n\tgoto end;\n\n    if (insert_string != NULL)\n    {\n\ty_type = MCHAR;\n#ifdef FEAT_EVAL\n\tif (regname == '=')\n\t{\n\t    // For the = register we need to split the string at NL\n\t    // characters.\n\t    // Loop twice: count the number of lines and save them.\n\t    for (;;)\n\t    {\n\t\ty_size = 0;\n\t\tptr = insert_string;\n\t\twhile (ptr != NULL)\n\t\t{\n\t\t    if (y_array != NULL)\n\t\t\ty_array[y_size] = ptr;\n\t\t    ++y_size;\n\t\t    ptr = vim_strchr(ptr, '\\n');\n\t\t    if (ptr != NULL)\n\t\t    {\n\t\t\tif (y_array != NULL)\n\t\t\t    *ptr = NUL;\n\t\t\t++ptr;\n\t\t\t// A trailing '\\n' makes the register linewise.\n\t\t\tif (*ptr == NUL)\n\t\t\t{\n\t\t\t    y_type = MLINE;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tif (y_array != NULL)\n\t\t    break;\n\t\ty_array = ALLOC_MULT(char_u *, y_size);\n\t\tif (y_array == NULL)\n\t\t    goto end;\n\t    }\n\t}\n\telse\n#endif\n\t{\n\t    y_size = 1;\t\t// use fake one-line yank register\n\t    y_array = &insert_string;\n\t}\n    }\n    else\n    {\n\tget_yank_register(regname, FALSE);\n\n\ty_type = y_current->y_type;\n\ty_width = y_current->y_width;\n\ty_size = y_current->y_size;\n\ty_array = y_current->y_array;\n\ty_current_used = y_current;\n    }\n\n    if (y_type == MLINE)\n    {\n\tif (flags & PUT_LINE_SPLIT)\n\t{\n\t    char_u *p;\n\n\t    // \"p\" or \"P\" in Visual mode: split the lines to put the text in\n\t    // between.\n\t    if (u_save_cursor() == FAIL)\n\t\tgoto end;\n\t    p = ml_get_cursor();\n\t    if (dir == FORWARD && *p != NUL)\n\t\tMB_PTR_ADV(p);\n\t    ptr = vim_strsave(p);\n\t    if (ptr == NULL)\n\t\tgoto end;\n\t    ml_append(curwin->w_cursor.lnum, ptr, (colnr_T)0, FALSE);\n\t    vim_free(ptr);\n\n\t    oldp = ml_get_curline();\n\t    p = oldp + curwin->w_cursor.col;\n\t    if (dir == FORWARD && *p != NUL)\n\t\tMB_PTR_ADV(p);\n\t    ptr = vim_strnsave(oldp, p - oldp);\n\t    if (ptr == NULL)\n\t\tgoto end;\n\t    ml_replace(curwin->w_cursor.lnum, ptr, FALSE);\n\t    ++nr_lines;\n\t    dir = FORWARD;\n\t}\n\tif (flags & PUT_LINE_FORWARD)\n\t{\n\t    // Must be \"p\" for a Visual block, put lines below the block.\n\t    curwin->w_cursor = curbuf->b_visual.vi_end;\n\t    dir = FORWARD;\n\t}\n\tcurbuf->b_op_start = curwin->w_cursor;\t// default for '[ mark\n\tcurbuf->b_op_end = curwin->w_cursor;\t// default for '] mark\n    }\n\n    if (flags & PUT_LINE)\t// :put command or \"p\" in Visual line mode.\n\ty_type = MLINE;\n\n    if (y_size == 0 || y_array == NULL)\n    {\n\tsemsg(_(e_nothing_in_register_str),\n\t\t  regname == 0 ? (char_u *)\"\\\"\" : transchar(regname));\n\tgoto end;\n    }\n\n    if (y_type == MBLOCK)\n    {\n\tlnum = curwin->w_cursor.lnum + y_size + 1;\n\tif (lnum > curbuf->b_ml.ml_line_count)\n\t    lnum = curbuf->b_ml.ml_line_count + 1;\n\tif (u_save(curwin->w_cursor.lnum - 1, lnum) == FAIL)\n\t    goto end;\n    }\n    else if (y_type == MLINE)\n    {\n\tlnum = curwin->w_cursor.lnum;\n#ifdef FEAT_FOLDING\n\t// Correct line number for closed fold.  Don't move the cursor yet,\n\t// u_save() uses it.\n\tif (dir == BACKWARD)\n\t    (void)hasFolding(lnum, &lnum, NULL);\n\telse\n\t    (void)hasFolding(lnum, NULL, &lnum);\n#endif\n\tif (dir == FORWARD)\n\t    ++lnum;\n\t// In an empty buffer the empty line is going to be replaced, include\n\t// it in the saved lines.\n\tif ((BUFEMPTY() ? u_save(0, 2) : u_save(lnum - 1, lnum)) == FAIL)\n\t    goto end;\n#ifdef FEAT_FOLDING\n\tif (dir == FORWARD)\n\t    curwin->w_cursor.lnum = lnum - 1;\n\telse\n\t    curwin->w_cursor.lnum = lnum;\n\tcurbuf->b_op_start = curwin->w_cursor;\t// for mark_adjust()\n#endif\n    }\n    else if (u_save_cursor() == FAIL)\n\tgoto end;\n\n    yanklen = (int)STRLEN(y_array[0]);\n\n    if (cur_ve_flags == VE_ALL && y_type == MCHAR)\n    {\n\tif (gchar_cursor() == TAB)\n\t{\n\t    int viscol = getviscol();\n\t    int ts = curbuf->b_p_ts;\n\n\t    // Don't need to insert spaces when \"p\" on the last position of a\n\t    // tab or \"P\" on the first position.\n\t    if (dir == FORWARD ?\n#ifdef FEAT_VARTABS\n\t\t    tabstop_padding(viscol, ts, curbuf->b_p_vts_array) != 1\n#else\n\t\t    ts - (viscol % ts) != 1\n#endif\n\t\t    : curwin->w_cursor.coladd > 0)\n\t\tcoladvance_force(viscol);\n\t    else\n\t\tcurwin->w_cursor.coladd = 0;\n\t}\n\telse if (curwin->w_cursor.coladd > 0 || gchar_cursor() == NUL)\n\t    coladvance_force(getviscol() + (dir == FORWARD));\n    }\n\n    lnum = curwin->w_cursor.lnum;\n    col = curwin->w_cursor.col;\n\n    // Block mode\n    if (y_type == MBLOCK)\n    {\n\tint\tc = gchar_cursor();\n\tcolnr_T\tendcol2 = 0;\n\n\tif (dir == FORWARD && c != NUL)\n\t{\n\t    if (cur_ve_flags == VE_ALL)\n\t\tgetvcol(curwin, &curwin->w_cursor, &col, NULL, &endcol2);\n\t    else\n\t\tgetvcol(curwin, &curwin->w_cursor, NULL, NULL, &col);\n\n\t    if (has_mbyte)\n\t\t// move to start of next multi-byte character\n\t\tcurwin->w_cursor.col += (*mb_ptr2len)(ml_get_cursor());\n\t    else\n\t    if (c != TAB || cur_ve_flags != VE_ALL)\n\t\t++curwin->w_cursor.col;\n\t    ++col;\n\t}\n\telse\n\t    getvcol(curwin, &curwin->w_cursor, &col, NULL, &endcol2);\n\n\tcol += curwin->w_cursor.coladd;\n\tif (cur_ve_flags == VE_ALL\n\t\t&& (curwin->w_cursor.coladd > 0\n\t\t    || endcol2 == curwin->w_cursor.col))\n\t{\n\t    if (dir == FORWARD && c == NUL)\n\t\t++col;\n\t    if (dir != FORWARD && c != NUL && curwin->w_cursor.coladd > 0)\n\t\t++curwin->w_cursor.col;\n\t    if (c == TAB)\n\t    {\n\t\tif (dir == BACKWARD && curwin->w_cursor.col)\n\t\t    curwin->w_cursor.col--;\n\t\tif (dir == FORWARD && col - 1 == endcol2)\n\t\t    curwin->w_cursor.col++;\n\t    }\n\t}\n\tcurwin->w_cursor.coladd = 0;\n\tbd.textcol = 0;\n\tfor (i = 0; i < y_size; ++i)\n\t{\n\t    int spaces = 0;\n\t    char shortline;\n\n\t    bd.startspaces = 0;\n\t    bd.endspaces = 0;\n\t    vcol = 0;\n\t    delcount = 0;\n\n\t    // add a new line\n\t    if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t    {\n\t\tif (ml_append(curbuf->b_ml.ml_line_count, (char_u *)\"\",\n\t\t\t\t\t\t   (colnr_T)1, FALSE) == FAIL)\n\t\t    break;\n\t\t++nr_lines;\n\t    }\n\t    // get the old line and advance to the position to insert at\n\t    oldp = ml_get_curline();\n\t    oldlen = (int)STRLEN(oldp);\n\t    for (ptr = oldp; vcol < col && *ptr; )\n\t    {\n\t\t// Count a tab for what it's worth (if list mode not on)\n\t\tincr = lbr_chartabsize_adv(oldp, &ptr, vcol);\n\t\tvcol += incr;\n\t    }\n\t    bd.textcol = (colnr_T)(ptr - oldp);\n\n\t    shortline = (vcol < col) || (vcol == col && !*ptr) ;\n\n\t    if (vcol < col) // line too short, padd with spaces\n\t\tbd.startspaces = col - vcol;\n\t    else if (vcol > col)\n\t    {\n\t\tbd.endspaces = vcol - col;\n\t\tbd.startspaces = incr - bd.endspaces;\n\t\t--bd.textcol;\n\t\tdelcount = 1;\n\t\tif (has_mbyte)\n\t\t    bd.textcol -= (*mb_head_off)(oldp, oldp + bd.textcol);\n\t\tif (oldp[bd.textcol] != TAB)\n\t\t{\n\t\t    // Only a Tab can be split into spaces.  Other\n\t\t    // characters will have to be moved to after the\n\t\t    // block, causing misalignment.\n\t\t    delcount = 0;\n\t\t    bd.endspaces = 0;\n\t\t}\n\t    }\n\n\t    yanklen = (int)STRLEN(y_array[i]);\n\n\t    if ((flags & PUT_BLOCK_INNER) == 0)\n\t    {\n\t\t// calculate number of spaces required to fill right side of\n\t\t// block\n\t\tspaces = y_width + 1;\n\t\tfor (j = 0; j < yanklen; j++)\n\t\t    spaces -= lbr_chartabsize(NULL, &y_array[i][j], 0);\n\t\tif (spaces < 0)\n\t\t    spaces = 0;\n\t    }\n\n\t    // Insert the new text.\n\t    // First check for multiplication overflow.\n\t    if (yanklen + spaces != 0\n\t\t     && count > ((INT_MAX - (bd.startspaces + bd.endspaces))\n\t\t\t\t\t\t\t/ (yanklen + spaces)))\n\t    {\n\t\temsg(_(e_resulting_text_too_long));\n\t\tbreak;\n\t    }\n\n\t    totlen = count * (yanklen + spaces) + bd.startspaces + bd.endspaces;\n\t    newp = alloc(totlen + oldlen + 1);\n\t    if (newp == NULL)\n\t\tbreak;\n\n\t    // copy part up to cursor to new line\n\t    ptr = newp;\n\t    mch_memmove(ptr, oldp, (size_t)bd.textcol);\n\t    ptr += bd.textcol;\n\n\t    // may insert some spaces before the new text\n\t    vim_memset(ptr, ' ', (size_t)bd.startspaces);\n\t    ptr += bd.startspaces;\n\n\t    // insert the new text\n\t    for (j = 0; j < count; ++j)\n\t    {\n\t\tmch_memmove(ptr, y_array[i], (size_t)yanklen);\n\t\tptr += yanklen;\n\n\t\t// insert block's trailing spaces only if there's text behind\n\t\tif ((j < count - 1 || !shortline) && spaces)\n\t\t{\n\t\t    vim_memset(ptr, ' ', (size_t)spaces);\n\t\t    ptr += spaces;\n\t\t}\n\t    }\n\n\t    // may insert some spaces after the new text\n\t    vim_memset(ptr, ' ', (size_t)bd.endspaces);\n\t    ptr += bd.endspaces;\n\n\t    // move the text after the cursor to the end of the line.\n\t    mch_memmove(ptr, oldp + bd.textcol + delcount,\n\t\t\t\t(size_t)(oldlen - bd.textcol - delcount + 1));\n\t    ml_replace(curwin->w_cursor.lnum, newp, FALSE);\n\n\t    ++curwin->w_cursor.lnum;\n\t    if (i == 0)\n\t\tcurwin->w_cursor.col += bd.startspaces;\n\t}\n\n\tchanged_lines(lnum, 0, curwin->w_cursor.lnum, nr_lines);\n\n\t// Set '[ mark.\n\tcurbuf->b_op_start = curwin->w_cursor;\n\tcurbuf->b_op_start.lnum = lnum;\n\n\t// adjust '] mark\n\tcurbuf->b_op_end.lnum = curwin->w_cursor.lnum - 1;\n\tcurbuf->b_op_end.col = bd.textcol + totlen - 1;\n\tcurbuf->b_op_end.coladd = 0;\n\tif (flags & PUT_CURSEND)\n\t{\n\t    colnr_T len;\n\n\t    curwin->w_cursor = curbuf->b_op_end;\n\t    curwin->w_cursor.col++;\n\n\t    // in Insert mode we might be after the NUL, correct for that\n\t    len = (colnr_T)STRLEN(ml_get_curline());\n\t    if (curwin->w_cursor.col > len)\n\t\tcurwin->w_cursor.col = len;\n\t}\n\telse\n\t    curwin->w_cursor.lnum = lnum;\n    }\n    else\n    {\n\t// Character or Line mode\n\tif (y_type == MCHAR)\n\t{\n\t    // if type is MCHAR, FORWARD is the same as BACKWARD on the next\n\t    // char\n\t    if (dir == FORWARD && gchar_cursor() != NUL)\n\t    {\n\t\tif (has_mbyte)\n\t\t{\n\t\t    int bytelen = (*mb_ptr2len)(ml_get_cursor());\n\n\t\t    // put it on the next of the multi-byte character.\n\t\t    col += bytelen;\n\t\t    if (yanklen)\n\t\t    {\n\t\t\tcurwin->w_cursor.col += bytelen;\n\t\t\tcurbuf->b_op_end.col += bytelen;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    ++col;\n\t\t    if (yanklen)\n\t\t    {\n\t\t\t++curwin->w_cursor.col;\n\t\t\t++curbuf->b_op_end.col;\n\t\t    }\n\t\t}\n\t    }\n\t    curbuf->b_op_start = curwin->w_cursor;\n\t}\n\t// Line mode: BACKWARD is the same as FORWARD on the previous line\n\telse if (dir == BACKWARD)\n\t    --lnum;\n\tnew_cursor = curwin->w_cursor;\n\n\t// simple case: insert into one line at a time\n\tif (y_type == MCHAR && y_size == 1)\n\t{\n\t    linenr_T\tend_lnum = 0; // init for gcc\n\t    linenr_T\tstart_lnum = lnum;\n\t    int\t\tfirst_byte_off = 0;\n\n\t    if (VIsual_active)\n\t    {\n\t\tend_lnum = curbuf->b_visual.vi_end.lnum;\n\t\tif (end_lnum < curbuf->b_visual.vi_start.lnum)\n\t\t    end_lnum = curbuf->b_visual.vi_start.lnum;\n\t\tif (end_lnum > start_lnum)\n\t\t{\n\t\t    pos_T   pos;\n\n\t\t    // \"col\" is valid for the first line, in following lines\n\t\t    // the virtual column needs to be used.  Matters for\n\t\t    // multi-byte characters.\n\t\t    pos.lnum = lnum;\n\t\t    pos.col = col;\n\t\t    pos.coladd = 0;\n\t\t    getvcol(curwin, &pos, NULL, &vcol, NULL);\n\t\t}\n\t    }\n\n\t    if (count == 0 || yanklen == 0)\n\t    {\n\t\tif (VIsual_active)\n\t\t    lnum = end_lnum;\n\t    }\n\t    else if (count > INT_MAX / yanklen)\n\t\t// multiplication overflow\n\t\temsg(_(e_resulting_text_too_long));\n\t    else\n\t    {\n\t\ttotlen = count * yanklen;\n\t\tdo {\n\t\t    oldp = ml_get(lnum);\n\t\t    oldlen = (int)STRLEN(oldp);\n\t\t    if (lnum > start_lnum)\n\t\t    {\n\t\t\tpos_T   pos;\n\n\t\t\tpos.lnum = lnum;\n\t\t\tif (getvpos(&pos, vcol) == OK)\n\t\t\t    col = pos.col;\n\t\t\telse\n\t\t\t    col = MAXCOL;\n\t\t    }\n\t\t    if (VIsual_active && col > oldlen)\n\t\t    {\n\t\t\tlnum++;\n\t\t\tcontinue;\n\t\t    }\n\t\t    newp = alloc(totlen + oldlen + 1);\n\t\t    if (newp == NULL)\n\t\t\tgoto end;\t// alloc() gave an error message\n\t\t    mch_memmove(newp, oldp, (size_t)col);\n\t\t    ptr = newp + col;\n\t\t    for (i = 0; i < count; ++i)\n\t\t    {\n\t\t\tmch_memmove(ptr, y_array[0], (size_t)yanklen);\n\t\t\tptr += yanklen;\n\t\t    }\n\t\t    STRMOVE(ptr, oldp + col);\n\t\t    ml_replace(lnum, newp, FALSE);\n\n\t\t    // compute the byte offset for the last character\n\t\t    first_byte_off = mb_head_off(newp, ptr - 1);\n\n\t\t    // Place cursor on last putted char.\n\t\t    if (lnum == curwin->w_cursor.lnum)\n\t\t    {\n\t\t\t// make sure curwin->w_virtcol is updated\n\t\t\tchanged_cline_bef_curs();\n\t\t\tcurwin->w_cursor.col += (colnr_T)(totlen - 1);\n\t\t    }\n\t\t    if (VIsual_active)\n\t\t\tlnum++;\n\t\t} while (VIsual_active && lnum <= end_lnum);\n\n\t\tif (VIsual_active) // reset lnum to the last visual line\n\t\t    lnum--;\n\t    }\n\n\t    // put '] at the first byte of the last character\n\t    curbuf->b_op_end = curwin->w_cursor;\n\t    curbuf->b_op_end.col -= first_byte_off;\n\n\t    // For \"CTRL-O p\" in Insert mode, put cursor after last char\n\t    if (totlen && (restart_edit != 0 || (flags & PUT_CURSEND)))\n\t\t++curwin->w_cursor.col;\n\t    else\n\t\tcurwin->w_cursor.col -= first_byte_off;\n\t    changed_bytes(lnum, col);\n\t}\n\telse\n\t{\n\t    linenr_T\tnew_lnum = new_cursor.lnum;\n\t    size_t\tlen;\n\n\t    // Insert at least one line.  When y_type is MCHAR, break the first\n\t    // line in two.\n\t    for (cnt = 1; cnt <= count; ++cnt)\n\t    {\n\t\ti = 0;\n\t\tif (y_type == MCHAR)\n\t\t{\n\t\t    // Split the current line in two at the insert position.\n\t\t    // First insert y_array[size - 1] in front of second line.\n\t\t    // Then append y_array[0] to first line.\n\t\t    lnum = new_cursor.lnum;\n\t\t    ptr = ml_get(lnum) + col;\n\t\t    totlen = (int)STRLEN(y_array[y_size - 1]);\n\t\t    newp = alloc(STRLEN(ptr) + totlen + 1);\n\t\t    if (newp == NULL)\n\t\t\tgoto error;\n\t\t    STRCPY(newp, y_array[y_size - 1]);\n\t\t    STRCAT(newp, ptr);\n\t\t    // insert second line\n\t\t    ml_append(lnum, newp, (colnr_T)0, FALSE);\n\t\t    ++new_lnum;\n\t\t    vim_free(newp);\n\n\t\t    oldp = ml_get(lnum);\n\t\t    newp = alloc(col + yanklen + 1);\n\t\t    if (newp == NULL)\n\t\t\tgoto error;\n\t\t\t\t\t    // copy first part of line\n\t\t    mch_memmove(newp, oldp, (size_t)col);\n\t\t\t\t\t    // append to first line\n\t\t    mch_memmove(newp + col, y_array[0], (size_t)(yanklen + 1));\n\t\t    ml_replace(lnum, newp, FALSE);\n\n\t\t    curwin->w_cursor.lnum = lnum;\n\t\t    i = 1;\n\t\t}\n\n\t\tfor (; i < y_size; ++i)\n\t\t{\n\t\t    if (y_type != MCHAR || i < y_size - 1)\n\t\t    {\n\t\t\tif (ml_append(lnum, y_array[i], (colnr_T)0, FALSE)\n\t\t\t\t\t\t\t\t      == FAIL)\n\t\t\t    goto error;\n\t\t\tnew_lnum++;\n\t\t    }\n\t\t    lnum++;\n\t\t    ++nr_lines;\n\t\t    if (flags & PUT_FIXINDENT)\n\t\t    {\n\t\t\told_pos = curwin->w_cursor;\n\t\t\tcurwin->w_cursor.lnum = lnum;\n\t\t\tptr = ml_get(lnum);\n\t\t\tif (cnt == count && i == y_size - 1)\n\t\t\t    lendiff = (int)STRLEN(ptr);\n\t\t\tif (*ptr == '#' && preprocs_left())\n\t\t\t    indent = 0;     // Leave # lines at start\n\t\t\telse\n\t\t\t     if (*ptr == NUL)\n\t\t\t    indent = 0;     // Ignore empty lines\n\t\t\telse if (first_indent)\n\t\t\t{\n\t\t\t    indent_diff = orig_indent - get_indent();\n\t\t\t    indent = orig_indent;\n\t\t\t    first_indent = FALSE;\n\t\t\t}\n\t\t\telse if ((indent = get_indent() + indent_diff) < 0)\n\t\t\t    indent = 0;\n\t\t\t(void)set_indent(indent, 0);\n\t\t\tcurwin->w_cursor = old_pos;\n\t\t\t// remember how many chars were removed\n\t\t\tif (cnt == count && i == y_size - 1)\n\t\t\t    lendiff -= (int)STRLEN(ml_get(lnum));\n\t\t    }\n\t\t}\n\t\tif (cnt == 1)\n\t\t    new_lnum = lnum;\n\t    }\n\nerror:\n\t    // Adjust marks.\n\t    if (y_type == MLINE)\n\t    {\n\t\tcurbuf->b_op_start.col = 0;\n\t\tif (dir == FORWARD)\n\t\t    curbuf->b_op_start.lnum++;\n\t    }\n\t    // Skip mark_adjust when adding lines after the last one, there\n\t    // can't be marks there. But still needed in diff mode.\n\t    if (curbuf->b_op_start.lnum + (y_type == MCHAR) - 1 + nr_lines\n\t\t\t\t\t\t < curbuf->b_ml.ml_line_count\n#ifdef FEAT_DIFF\n\t\t\t\t\t\t || curwin->w_p_diff\n#endif\n\t\t\t\t\t\t )\n\t\tmark_adjust(curbuf->b_op_start.lnum + (y_type == MCHAR),\n\t\t\t\t\t     (linenr_T)MAXLNUM, nr_lines, 0L);\n\n\t    // note changed text for displaying and folding\n\t    if (y_type == MCHAR)\n\t\tchanged_lines(curwin->w_cursor.lnum, col,\n\t\t\t\t\t curwin->w_cursor.lnum + 1, nr_lines);\n\t    else\n\t\tchanged_lines(curbuf->b_op_start.lnum, 0,\n\t\t\t\t\t   curbuf->b_op_start.lnum, nr_lines);\n\t    if (y_current_used != NULL && (y_current_used != y_current\n\t\t\t\t\t     || y_current->y_array != y_array))\n\t    {\n\t\t// Something invoked through changed_lines() has changed the\n\t\t// yank buffer, e.g. a GUI clipboard callback.\n\t\temsg(_(e_yank_register_changed_while_using_it));\n\t\tgoto end;\n\t    }\n\n\t    // Put the '] mark on the first byte of the last inserted character.\n\t    // Correct the length for change in indent.\n\t    curbuf->b_op_end.lnum = new_lnum;\n\t    len = STRLEN(y_array[y_size - 1]);\n\t    col = (colnr_T)len - lendiff;\n\t    if (col > 1)\n\t    {\n\t\tcurbuf->b_op_end.col = col - 1;\n\t\tif (len > 0)\n\t\t    curbuf->b_op_end.col -= mb_head_off(y_array[y_size - 1],\n\t\t\t\t\t\ty_array[y_size - 1] + len - 1);\n\t    }\n\t    else\n\t\tcurbuf->b_op_end.col = 0;\n\n\t    if (flags & PUT_CURSLINE)\n\t    {\n\t\t// \":put\": put cursor on last inserted line\n\t\tcurwin->w_cursor.lnum = lnum;\n\t\tbeginline(BL_WHITE | BL_FIX);\n\t    }\n\t    else if (flags & PUT_CURSEND)\n\t    {\n\t\t// put cursor after inserted text\n\t\tif (y_type == MLINE)\n\t\t{\n\t\t    if (lnum >= curbuf->b_ml.ml_line_count)\n\t\t\tcurwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t\t    else\n\t\t\tcurwin->w_cursor.lnum = lnum + 1;\n\t\t    curwin->w_cursor.col = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t    curwin->w_cursor.lnum = new_lnum;\n\t\t    curwin->w_cursor.col = col;\n\t\t    curbuf->b_op_end = curwin->w_cursor;\n\t\t    if (col > 1)\n\t\t\tcurbuf->b_op_end.col = col - 1;\n\t\t}\n\t    }\n\t    else if (y_type == MLINE)\n\t    {\n\t\t// put cursor on first non-blank in first inserted line\n\t\tcurwin->w_cursor.col = 0;\n\t\tif (dir == FORWARD)\n\t\t    ++curwin->w_cursor.lnum;\n\t\tbeginline(BL_WHITE | BL_FIX);\n\t    }\n\t    else\t// put cursor on first inserted character\n\t\tcurwin->w_cursor = new_cursor;\n\t}\n    }\n\n    msgmore(nr_lines);\n    curwin->w_set_curswant = TRUE;\n\nend:\n    if (cmdmod.cmod_flags & CMOD_LOCKMARKS)\n    {\n\tcurbuf->b_op_start = orig_start;\n\tcurbuf->b_op_end = orig_end;\n    }\n    if (allocated)\n\tvim_free(insert_string);\n    if (regname == '=')\n\tvim_free(y_array);\n\n    VIsual_active = FALSE;\n\n    // If the cursor is past the end of the line put it at the end.\n    adjust_cursor_eol();\n}\n\n/*\n * Return the character name of the register with the given number.\n */\n    int\nget_register_name(int num)\n{\n    if (num == -1)\n\treturn '\"';\n    else if (num < 10)\n\treturn num + '0';\n    else if (num == DELETION_REGISTER)\n\treturn '-';\n#ifdef FEAT_CLIPBOARD\n    else if (num == STAR_REGISTER)\n\treturn '*';\n    else if (num == PLUS_REGISTER)\n\treturn '+';\n#endif\n    else\n\treturn num + 'a' - 10;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return the index of the register \"\" points to.\n */\n    int\nget_unname_register()\n{\n    return y_previous == NULL ? -1 : y_previous - &y_regs[0];\n}\n#endif\n\n/*\n * \":dis\" and \":registers\": Display the contents of the yank registers.\n */\n    void\nex_display(exarg_T *eap)\n{\n    int\t\ti, n;\n    long\tj;\n    char_u\t*p;\n    yankreg_T\t*yb;\n    int\t\tname;\n    int\t\tattr;\n    char_u\t*arg = eap->arg;\n    int\t\tclen;\n    int\t\ttype;\n\n    if (arg != NULL && *arg == NUL)\n\targ = NULL;\n    attr = HL_ATTR(HLF_8);\n\n    // Highlight title\n    msg_puts_title(_(\"\\nType Name Content\"));\n    for (i = -1; i < NUM_REGISTERS && !got_int; ++i)\n    {\n\tname = get_register_name(i);\n\tswitch (get_reg_type(name, NULL))\n\t{\n\t    case MLINE: type = 'l'; break;\n\t    case MCHAR: type = 'c'; break;\n\t    default:\ttype = 'b'; break;\n\t}\n\tif (arg != NULL && vim_strchr(arg, name) == NULL\n#ifdef ONE_CLIPBOARD\n\t    // Star register and plus register contain the same thing.\n\t\t&& (name != '*' || vim_strchr(arg, '+') == NULL)\n#endif\n\t\t)\n\t    continue;\t    // did not ask for this register\n\n#ifdef FEAT_CLIPBOARD\n\t// Adjust register name for \"unnamed\" in 'clipboard'.\n\t// When it's a clipboard register, fill it with the current contents\n\t// of the clipboard.\n\tadjust_clip_reg(&name);\n\t(void)may_get_selection(name);\n#endif\n\n\tif (i == -1)\n\t{\n\t    if (y_previous != NULL)\n\t\tyb = y_previous;\n\t    else\n\t\tyb = &(y_regs[0]);\n\t}\n\telse\n\t    yb = &(y_regs[i]);\n\n#ifdef FEAT_EVAL\n\tif (name == MB_TOLOWER(redir_reg)\n\t\t|| (redir_reg == '\"' && yb == y_previous))\n\t    continue;\t    // do not list register being written to, the\n\t\t\t    // pointer can be freed\n#endif\n\n\tif (yb->y_array != NULL)\n\t{\n\t    int do_show = FALSE;\n\n\t    for (j = 0; !do_show && j < yb->y_size; ++j)\n\t\tdo_show = !message_filtered(yb->y_array[j]);\n\n\t    if (do_show || yb->y_size == 0)\n\t    {\n\t\tmsg_putchar('\\n');\n\t\tmsg_puts(\"  \");\n\t\tmsg_putchar(type);\n\t\tmsg_puts(\"  \");\n\t\tmsg_putchar('\"');\n\t\tmsg_putchar(name);\n\t\tmsg_puts(\"   \");\n\n\t\tn = (int)Columns - 11;\n\t\tfor (j = 0; j < yb->y_size && n > 1; ++j)\n\t\t{\n\t\t    if (j)\n\t\t    {\n\t\t\tmsg_puts_attr(\"^J\", attr);\n\t\t\tn -= 2;\n\t\t    }\n\t\t    for (p = yb->y_array[j];\n\t\t\t\t    *p != NUL && (n -= ptr2cells(p)) >= 0; ++p)\n\t\t    {\n\t\t\tclen = (*mb_ptr2len)(p);\n\t\t\tmsg_outtrans_len(p, clen);\n\t\t\tp += clen - 1;\n\t\t    }\n\t\t}\n\t\tif (n > 1 && yb->y_type == MLINE)\n\t\t    msg_puts_attr(\"^J\", attr);\n\t\tout_flush();\t\t    // show one line at a time\n\t    }\n\t    ui_breakcheck();\n\t}\n    }\n\n    // display last inserted text\n    if ((p = get_last_insert()) != NULL\n\t\t  && (arg == NULL || vim_strchr(arg, '.') != NULL) && !got_int\n\t\t\t\t\t\t      && !message_filtered(p))\n    {\n\tmsg_puts(\"\\n  c  \\\".   \");\n\tdis_msg(p, TRUE);\n    }\n\n    // display last command line\n    if (last_cmdline != NULL && (arg == NULL || vim_strchr(arg, ':') != NULL)\n\t\t\t       && !got_int && !message_filtered(last_cmdline))\n    {\n\tmsg_puts(\"\\n  c  \\\":   \");\n\tdis_msg(last_cmdline, FALSE);\n    }\n\n    // display current file name\n    if (curbuf->b_fname != NULL\n\t    && (arg == NULL || vim_strchr(arg, '%') != NULL) && !got_int\n\t\t\t\t\t&& !message_filtered(curbuf->b_fname))\n    {\n\tmsg_puts(\"\\n  c  \\\"%   \");\n\tdis_msg(curbuf->b_fname, FALSE);\n    }\n\n    // display alternate file name\n    if ((arg == NULL || vim_strchr(arg, '%') != NULL) && !got_int)\n    {\n\tchar_u\t    *fname;\n\tlinenr_T    dummy;\n\n\tif (buflist_name_nr(0, &fname, &dummy) != FAIL\n\t\t\t\t\t\t  && !message_filtered(fname))\n\t{\n\t    msg_puts(\"\\n  c  \\\"#   \");\n\t    dis_msg(fname, FALSE);\n\t}\n    }\n\n    // display last search pattern\n    if (last_search_pat() != NULL\n\t\t && (arg == NULL || vim_strchr(arg, '/') != NULL) && !got_int\n\t\t\t\t      && !message_filtered(last_search_pat()))\n    {\n\tmsg_puts(\"\\n  c  \\\"/   \");\n\tdis_msg(last_search_pat(), FALSE);\n    }\n\n#ifdef FEAT_EVAL\n    // display last used expression\n    if (expr_line != NULL && (arg == NULL || vim_strchr(arg, '=') != NULL)\n\t\t\t\t  && !got_int && !message_filtered(expr_line))\n    {\n\tmsg_puts(\"\\n  c  \\\"=   \");\n\tdis_msg(expr_line, FALSE);\n    }\n#endif\n}\n\n/*\n * display a string for do_dis()\n * truncate at end of screen line\n */\n    static void\ndis_msg(\n    char_u\t*p,\n    int\t\tskip_esc)\t    // if TRUE, ignore trailing ESC\n{\n    int\t\tn;\n    int\t\tl;\n\n    n = (int)Columns - 6;\n    while (*p != NUL\n\t    && !(*p == ESC && skip_esc && *(p + 1) == NUL)\n\t    && (n -= ptr2cells(p)) >= 0)\n    {\n\tif (has_mbyte && (l = (*mb_ptr2len)(p)) > 1)\n\t{\n\t    msg_outtrans_len(p, l);\n\t    p += l;\n\t}\n\telse\n\t    msg_outtrans_len(p++, 1);\n    }\n    ui_breakcheck();\n}\n\n#if defined(FEAT_DND) || defined(PROTO)\n/*\n * Replace the contents of the '~' register with str.\n */\n    void\ndnd_yank_drag_data(char_u *str, long len)\n{\n    yankreg_T *curr;\n\n    curr = y_current;\n    y_current = &y_regs[TILDE_REGISTER];\n    free_yank_all();\n    str_to_reg(y_current, MCHAR, str, len, 0L, FALSE);\n    y_current = curr;\n}\n#endif\n\n\n/*\n * Return the type of a register.\n * Used for getregtype()\n * Returns MAUTO for error.\n */\n    char_u\nget_reg_type(int regname, long *reglen)\n{\n    switch (regname)\n    {\n\tcase '%':\t\t// file name\n\tcase '#':\t\t// alternate file name\n\tcase '=':\t\t// expression\n\tcase ':':\t\t// last command line\n\tcase '/':\t\t// last search-pattern\n\tcase '.':\t\t// last inserted text\n# ifdef FEAT_SEARCHPATH\n\tcase Ctrl_F:\t\t// Filename under cursor\n\tcase Ctrl_P:\t\t// Path under cursor, expand via \"path\"\n# endif\n\tcase Ctrl_W:\t\t// word under cursor\n\tcase Ctrl_A:\t\t// WORD (mnemonic All) under cursor\n\tcase '_':\t\t// black hole: always empty\n\t    return MCHAR;\n    }\n\n# ifdef FEAT_CLIPBOARD\n    regname = may_get_selection(regname);\n# endif\n\n    if (regname != NUL && !valid_yank_reg(regname, FALSE))\n\treturn MAUTO;\n\n    get_yank_register(regname, FALSE);\n\n    if (y_current->y_array != NULL)\n    {\n\tif (reglen != NULL && y_current->y_type == MBLOCK)\n\t    *reglen = y_current->y_width;\n\treturn y_current->y_type;\n    }\n    return MAUTO;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * When \"flags\" has GREG_LIST return a list with text \"s\".\n * Otherwise just return \"s\".\n */\n    static char_u *\ngetreg_wrap_one_line(char_u *s, int flags)\n{\n    if (flags & GREG_LIST)\n    {\n\tlist_T *list = list_alloc();\n\n\tif (list != NULL)\n\t{\n\t    if (list_append_string(list, NULL, -1) == FAIL)\n\t    {\n\t\tlist_free(list);\n\t\treturn NULL;\n\t    }\n\t    list->lv_first->li_tv.vval.v_string = s;\n\t}\n\treturn (char_u *)list;\n    }\n    return s;\n}\n\n/*\n * Return the contents of a register as a single allocated string or as a list.\n * Used for \"@r\" in expressions and for getreg().\n * Returns NULL for error.\n * Flags:\n *\tGREG_NO_EXPR\tDo not allow expression register\n *\tGREG_EXPR_SRC\tFor the expression register: return expression itself,\n *\t\t\tnot the result of its evaluation.\n *\tGREG_LIST\tReturn a list of lines instead of a single string.\n */\n    char_u *\nget_reg_contents(int regname, int flags)\n{\n    long\ti;\n    char_u\t*retval;\n    int\t\tallocated;\n    long\tlen;\n\n    // Don't allow using an expression register inside an expression\n    if (regname == '=')\n    {\n\tif (flags & GREG_NO_EXPR)\n\t    return NULL;\n\tif (flags & GREG_EXPR_SRC)\n\t    return getreg_wrap_one_line(get_expr_line_src(), flags);\n\treturn getreg_wrap_one_line(get_expr_line(), flags);\n    }\n\n    if (regname == '@')\t    // \"@@\" is used for unnamed register\n\tregname = '\"';\n\n    // check for valid regname\n    if (regname != NUL && !valid_yank_reg(regname, FALSE))\n\treturn NULL;\n\n# ifdef FEAT_CLIPBOARD\n    regname = may_get_selection(regname);\n# endif\n\n    if (get_spec_reg(regname, &retval, &allocated, FALSE))\n    {\n\tif (retval == NULL)\n\t    return NULL;\n\tif (allocated)\n\t    return getreg_wrap_one_line(retval, flags);\n\treturn getreg_wrap_one_line(vim_strsave(retval), flags);\n    }\n\n    get_yank_register(regname, FALSE);\n    if (y_current->y_array == NULL)\n\treturn NULL;\n\n    if (flags & GREG_LIST)\n    {\n\tlist_T\t*list = list_alloc();\n\tint\terror = FALSE;\n\n\tif (list == NULL)\n\t    return NULL;\n\tfor (i = 0; i < y_current->y_size; ++i)\n\t    if (list_append_string(list, y_current->y_array[i], -1) == FAIL)\n\t\terror = TRUE;\n\tif (error)\n\t{\n\t    list_free(list);\n\t    return NULL;\n\t}\n\treturn (char_u *)list;\n    }\n\n    // Compute length of resulting string.\n    len = 0;\n    for (i = 0; i < y_current->y_size; ++i)\n    {\n\tlen += (long)STRLEN(y_current->y_array[i]);\n\t// Insert a newline between lines and after last line if\n\t// y_type is MLINE.\n\tif (y_current->y_type == MLINE || i < y_current->y_size - 1)\n\t    ++len;\n    }\n\n    retval = alloc(len + 1);\n\n    // Copy the lines of the yank register into the string.\n    if (retval != NULL)\n    {\n\tlen = 0;\n\tfor (i = 0; i < y_current->y_size; ++i)\n\t{\n\t    STRCPY(retval + len, y_current->y_array[i]);\n\t    len += (long)STRLEN(retval + len);\n\n\t    // Insert a NL between lines and after the last line if y_type is\n\t    // MLINE.\n\t    if (y_current->y_type == MLINE || i < y_current->y_size - 1)\n\t\tretval[len++] = '\\n';\n\t}\n\tretval[len] = NUL;\n    }\n\n    return retval;\n}\n\n    static int\ninit_write_reg(\n    int\t\tname,\n    yankreg_T\t**old_y_previous,\n    yankreg_T\t**old_y_current,\n    int\t\tmust_append,\n    int\t\t*yank_type UNUSED)\n{\n    if (!valid_yank_reg(name, TRUE))\t    // check for valid reg name\n    {\n\temsg_invreg(name);\n\treturn FAIL;\n    }\n\n    // Don't want to change the current (unnamed) register\n    *old_y_previous = y_previous;\n    *old_y_current = y_current;\n\n    get_yank_register(name, TRUE);\n    if (!y_append && !must_append)\n\tfree_yank_all();\n    return OK;\n}\n\n    static void\nfinish_write_reg(\n    int\t\tname,\n    yankreg_T\t*old_y_previous,\n    yankreg_T\t*old_y_current)\n{\n# ifdef FEAT_CLIPBOARD\n    // Send text of clipboard register to the clipboard.\n    may_set_selection();\n# endif\n\n    // ':let @\" = \"val\"' should change the meaning of the \"\" register\n    if (name != '\"')\n\ty_previous = old_y_previous;\n    y_current = old_y_current;\n}\n\n/*\n * Store string \"str\" in register \"name\".\n * \"maxlen\" is the maximum number of bytes to use, -1 for all bytes.\n * If \"must_append\" is TRUE, always append to the register.  Otherwise append\n * if \"name\" is an uppercase letter.\n * Note: \"maxlen\" and \"must_append\" don't work for the \"/\" register.\n * Careful: 'str' is modified, you may have to use a copy!\n * If \"str\" ends in '\\n' or '\\r', use linewise, otherwise use characterwise.\n */\n    void\nwrite_reg_contents(\n    int\t\tname,\n    char_u\t*str,\n    int\t\tmaxlen,\n    int\t\tmust_append)\n{\n    write_reg_contents_ex(name, str, maxlen, must_append, MAUTO, 0L);\n}\n\n    void\nwrite_reg_contents_lst(\n    int\t\tname,\n    char_u\t**strings,\n    int\t\tmaxlen UNUSED,\n    int\t\tmust_append,\n    int\t\tyank_type,\n    long\tblock_len)\n{\n    yankreg_T  *old_y_previous, *old_y_current;\n\n    if (name == '/' || name == '=')\n    {\n\tchar_u\t*s;\n\n\tif (strings[0] == NULL)\n\t    s = (char_u *)\"\";\n\telse if (strings[1] != NULL)\n\t{\n\t    emsg(_(e_search_pattern_and_expression_register_may_not_contain_two_or_more_lines));\n\t    return;\n\t}\n\telse\n\t    s = strings[0];\n\twrite_reg_contents_ex(name, s, -1, must_append, yank_type, block_len);\n\treturn;\n    }\n\n    if (name == '_')\t    // black hole: nothing to do\n\treturn;\n\n    if (init_write_reg(name, &old_y_previous, &old_y_current, must_append,\n\t\t&yank_type) == FAIL)\n\treturn;\n\n    str_to_reg(y_current, yank_type, (char_u *)strings, -1, block_len, TRUE);\n\n    finish_write_reg(name, old_y_previous, old_y_current);\n}\n\n    void\nwrite_reg_contents_ex(\n    int\t\tname,\n    char_u\t*str,\n    int\t\tmaxlen,\n    int\t\tmust_append,\n    int\t\tyank_type,\n    long\tblock_len)\n{\n    yankreg_T\t*old_y_previous, *old_y_current;\n    long\tlen;\n\n    if (maxlen >= 0)\n\tlen = maxlen;\n    else\n\tlen = (long)STRLEN(str);\n\n    // Special case: '/' search pattern\n    if (name == '/')\n    {\n\tset_last_search_pat(str, RE_SEARCH, TRUE, TRUE);\n\treturn;\n    }\n\n    if (name == '#')\n    {\n\tbuf_T\t*buf;\n\n\tif (VIM_ISDIGIT(*str))\n\t{\n\t    int\tnum = atoi((char *)str);\n\n\t    buf = buflist_findnr(num);\n\t    if (buf == NULL)\n\t\tsemsg(_(e_buffer_nr_does_not_exist), (long)num);\n\t}\n\telse\n\t    buf = buflist_findnr(buflist_findpat(str, str + STRLEN(str),\n\t\t\t\t\t\t\t TRUE, FALSE, FALSE));\n\tif (buf == NULL)\n\t    return;\n\tcurwin->w_alt_fnum = buf->b_fnum;\n\treturn;\n    }\n\n    if (name == '=')\n    {\n\tchar_u\t    *p, *s;\n\n\tp = vim_strnsave(str, len);\n\tif (p == NULL)\n\t    return;\n\tif (must_append && expr_line != NULL)\n\t{\n\t    s = concat_str(expr_line, p);\n\t    vim_free(p);\n\t    p = s;\n\t}\n\tset_expr_line(p, NULL);\n\treturn;\n    }\n\n    if (name == '_')\t    // black hole: nothing to do\n\treturn;\n\n    if (init_write_reg(name, &old_y_previous, &old_y_current, must_append,\n\t\t&yank_type) == FAIL)\n\treturn;\n\n    str_to_reg(y_current, yank_type, str, len, block_len, FALSE);\n\n    finish_write_reg(name, old_y_previous, old_y_current);\n}\n#endif\t// FEAT_EVAL\n\n#if defined(FEAT_CLIPBOARD) || defined(FEAT_EVAL)\n/*\n * Put a string into a register.  When the register is not empty, the string\n * is appended.\n */\n    void\nstr_to_reg(\n    yankreg_T\t*y_ptr,\t\t// pointer to yank register\n    int\t\tyank_type,\t// MCHAR, MLINE, MBLOCK, MAUTO\n    char_u\t*str,\t\t// string to put in register\n    long\tlen,\t\t// length of string\n    long\tblocklen,\t// width of Visual block\n    int\t\tstr_list)\t// TRUE if str is char_u **\n{\n    int\t\ttype;\t\t\t// MCHAR, MLINE or MBLOCK\n    int\t\tlnum;\n    long\tstart;\n    long\ti;\n    int\t\textra;\n    int\t\tnewlines;\t\t// number of lines added\n    int\t\textraline = 0;\t\t// extra line at the end\n    int\t\tappend = FALSE;\t\t// append to last line in register\n    char_u\t*s;\n    char_u\t**ss;\n    char_u\t**pp;\n    long\tmaxlen;\n\n    if (y_ptr->y_array == NULL)\t\t// NULL means empty register\n\ty_ptr->y_size = 0;\n\n    if (yank_type == MAUTO)\n\ttype = ((str_list || (len > 0 && (str[len - 1] == NL\n\t\t\t\t\t    || str[len - 1] == CAR)))\n\t\t\t\t\t\t\t     ? MLINE : MCHAR);\n    else\n\ttype = yank_type;\n\n    // Count the number of lines within the string\n    newlines = 0;\n    if (str_list)\n    {\n\tfor (ss = (char_u **) str; *ss != NULL; ++ss)\n\t    ++newlines;\n    }\n    else\n    {\n\tfor (i = 0; i < len; i++)\n\t    if (str[i] == '\\n')\n\t\t++newlines;\n\tif (type == MCHAR || len == 0 || str[len - 1] != '\\n')\n\t{\n\t    extraline = 1;\n\t    ++newlines;\t// count extra newline at the end\n\t}\n\tif (y_ptr->y_size > 0 && y_ptr->y_type == MCHAR)\n\t{\n\t    append = TRUE;\n\t    --newlines;\t// uncount newline when appending first line\n\t}\n    }\n\n    // Without any lines make the register empty.\n    if (y_ptr->y_size + newlines == 0)\n    {\n\tVIM_CLEAR(y_ptr->y_array);\n\treturn;\n    }\n\n    // Allocate an array to hold the pointers to the new register lines.\n    // If the register was not empty, move the existing lines to the new array.\n    pp = lalloc_clear((y_ptr->y_size + newlines) * sizeof(char_u *), TRUE);\n    if (pp == NULL)\t// out of memory\n\treturn;\n    for (lnum = 0; lnum < y_ptr->y_size; ++lnum)\n\tpp[lnum] = y_ptr->y_array[lnum];\n    vim_free(y_ptr->y_array);\n    y_ptr->y_array = pp;\n    maxlen = 0;\n\n    // Find the end of each line and save it into the array.\n    if (str_list)\n    {\n\tfor (ss = (char_u **) str; *ss != NULL; ++ss, ++lnum)\n\t{\n\t    pp[lnum] = vim_strsave(*ss);\n\t    if (type == MBLOCK)\n\t    {\n\t\tint charlen = mb_string2cells(*ss, -1);\n\n\t\tif (charlen > maxlen)\n\t\t    maxlen = charlen;\n\t    }\n\t}\n    }\n    else\n    {\n\tfor (start = 0; start < len + extraline; start += i + 1)\n\t{\n\t    int charlen = 0;\n\n\t    for (i = start; i < len; ++i)\t// find the end of the line\n\t    {\n\t\tif (str[i] == '\\n')\n\t\t    break;\n\t\tif (type == MBLOCK)\n\t\t    charlen += mb_ptr2cells_len(str + i, len - i);\n\t    }\n\t    i -= start;\t\t\t// i is now length of line\n\t    if (charlen > maxlen)\n\t\tmaxlen = charlen;\n\t    if (append)\n\t    {\n\t\t--lnum;\n\t\textra = (int)STRLEN(y_ptr->y_array[lnum]);\n\t    }\n\t    else\n\t\textra = 0;\n\t    s = alloc(i + extra + 1);\n\t    if (s == NULL)\n\t\tbreak;\n\t    if (extra)\n\t\tmch_memmove(s, y_ptr->y_array[lnum], (size_t)extra);\n\t    if (append)\n\t\tvim_free(y_ptr->y_array[lnum]);\n\t    if (i > 0)\n\t\tmch_memmove(s + extra, str + start, (size_t)i);\n\t    extra += i;\n\t    s[extra] = NUL;\n\t    y_ptr->y_array[lnum++] = s;\n\t    while (--extra >= 0)\n\t    {\n\t\tif (*s == NUL)\n\t\t    *s = '\\n';\t    // replace NUL with newline\n\t\t++s;\n\t    }\n\t    append = FALSE;\t\t    // only first line is appended\n\t}\n    }\n    y_ptr->y_type = type;\n    y_ptr->y_size = lnum;\n    if (type == MBLOCK)\n\ty_ptr->y_width = (blocklen < 0 ? maxlen - 1 : blocklen);\n    else\n\ty_ptr->y_width = 0;\n# ifdef FEAT_VIMINFO\n    y_ptr->y_time_set = vim_time();\n# endif\n}\n#endif // FEAT_CLIPBOARD || FEAT_EVAL || PROTO\n", "\" Tests for put commands, e.g. \":put\", \"p\", \"gp\", \"P\", \"gP\", etc.\n\nsource check.vim\n\nfunc Test_put_block()\n  new\n  call feedkeys(\"i\\<C-V>u2500\\<CR>x\\<ESC>\", 'x')\n  call feedkeys(\"\\<C-V>y\", 'x')\n  call feedkeys(\"gg0p\", 'x')\n  call assert_equal(\"\\u2500x\", getline(1))\n  bwipe!\nendfunc\n\nfunc Test_put_char_block()\n  new\n  call setline(1, ['Line 1', 'Line 2'])\n  f Xfile_put\n  \" visually select both lines and put the cursor at the top of the visual\n  \" selection and then put the buffer name over it\n  exe \"norm! G0\\<c-v>ke\\\"%p\"\n  call assert_equal(['Xfile_put 1', 'Xfile_put 2'], getline(1,2))\n  bw!\nendfunc\n\nfunc Test_put_char_block2()\n  new\n  call setreg('a', ' one ', 'v')\n  call setline(1, ['Line 1', '', 'Line 3', ''])\n  \" visually select the first 3 lines and put register a over it\n  exe \"norm! ggl\\<c-v>2j2l\\\"ap\"\n  call assert_equal(['L one  1', '', 'L one  3', ''], getline(1, 4))\n  \" clean up\n  bw!\nendfunc\n\nfunc Test_put_lines()\n  new\n  let a = [ getreg('a'), getregtype('a') ]\n  call setline(1, ['Line 1', 'Line2', 'Line 3', ''])\n  exe 'norm! gg\"add\"AddG\"\"p'\n  call assert_equal(['Line 3', '', 'Line 1', 'Line2'], getline(1, '$'))\n  \" clean up\n  bw!\n  eval a[0]->setreg('a', a[1])\nendfunc\n\nfunc Test_put_expr()\n  new\n  call setline(1, repeat(['A'], 6))\n  exec \"1norm! \\\"=line('.')\\<cr>p\"\n  norm! j0.\n  norm! j0.\n  exec \"4norm! \\\"=\\<cr>P\"\n  norm! j0.\n  norm! j0.\n  call assert_equal(['A1','A2','A3','4A','5A','6A'], getline(1, '$'))\n  bw!\nendfunc\n\nfunc Test_put_fails_when_nomodifiable()\n  new\n  setlocal nomodifiable\n\n  normal! yy\n  call assert_fails(':put', 'E21:')\n  call assert_fails(':put!', 'E21:')\n  call assert_fails(':normal! p', 'E21:')\n  call assert_fails(':normal! gp', 'E21:')\n  call assert_fails(':normal! P', 'E21:')\n  call assert_fails(':normal! gP', 'E21:')\n\n  if has('mouse')\n    set mouse=n\n    call assert_fails('execute \"normal! \\<MiddleMouse>\"', 'E21:')\n    set mouse&\n  endif\n\n  bwipeout!\nendfunc\n\n\" A bug was discovered where the Normal mode put commands (e.g., \"p\") would\n\" output duplicate error messages when invoked in a non-modifiable buffer.\nfunc Test_put_p_errmsg_nodup()\n  new\n  setlocal nomodifiable\n\n  normal! yy\n\n  func Capture_p_error()\n    redir => s:p_err\n    normal! p\n    redir END\n  endfunc\n\n  silent! call Capture_p_error()\n\n  \" Error message output within a function should be three lines (the function\n  \" name, the line number, and the error message).\n  call assert_equal(3, count(s:p_err, \"\\n\"))\n\n  delfunction Capture_p_error\n  bwipeout!\nendfunc\n\nfunc Test_put_p_indent_visual()\n  new\n  call setline(1, ['select this text', 'select that text'])\n  \" yank \"that\" from the second line\n  normal 2Gwvey\n  \" select \"this\" in the first line and put\n  normal k0wve[p\n  call assert_equal('select that text', getline(1))\n  call assert_equal('select that text', getline(2))\n  bwipe!\nendfunc\n\n\" Test for deleting all the contents of a buffer with a put\nfunc Test_put_visual_delete_all_lines()\n  new\n  call setline(1, ['one', 'two', 'three'])\n  let @r = ''\n  normal! VG\"rgp\n  call assert_equal(1, line('$'))\n  close!\nendfunc\n\nfunc Test_gp_with_count_leaves_cursor_at_end()\n  new\n  call setline(1, '<---->')\n  call setreg('@', \"foo\\nbar\", 'c')\n  normal 1G3|3gp\n  call assert_equal([0, 4, 4, 0], getpos(\".\"))\n  call assert_equal(['<--foo', 'barfoo', 'barfoo', 'bar-->'], getline(1, '$'))\n  call assert_equal([0, 4, 3, 0], getpos(\"']\"))\n\n  bwipe!\nendfunc\n\nfunc Test_p_with_count_leaves_mark_at_end()\n  new\n  call setline(1, '<---->')\n  call setreg('@', \"start\\nend\", 'c')\n  normal 1G3|3p\n  call assert_equal([0, 1, 4, 0], getpos(\".\"))\n  call assert_equal(['<--start', 'endstart', 'endstart', 'end-->'], getline(1, '$'))\n  call assert_equal([0, 4, 3, 0], getpos(\"']\"))\n\n  bwipe!\nendfunc\n\nfunc Test_very_large_count()\n  new\n  \" total put-length (21474837 * 100) brings 32 bit int overflow\n  let @\" = repeat('x', 100)\n  call assert_fails('norm 21474837p', 'E1240:')\n  bwipe!\nendfunc\n\nfunc Test_very_large_count_64bit()\n  if v:sizeoflong < 8\n    throw 'Skipped: only works with 64 bit long ints'\n  endif\n\n  new\n  let @\" = repeat('x', 100)\n  call assert_fails('norm 999999999p', 'E1240:')\n  bwipe!\nendfunc\n\nfunc Test_very_large_count_block()\n  new\n  \" total put-length (21474837 * 100) brings 32 bit int overflow\n  call setline(1, repeat('x', 100))\n  exe \"norm \\<C-V>99ly\"\n  call assert_fails('norm 21474837p', 'E1240:')\n  bwipe!\nendfunc\n\nfunc Test_very_large_count_block_64bit()\n  if v:sizeoflong < 8\n    throw 'Skipped: only works with 64 bit long ints'\n  endif\n\n  new\n  call setline(1, repeat('x', 100))\n  exe \"norm \\<C-V>$y\"\n  call assert_fails('norm 999999999p', 'E1240:')\n  bwipe!\nendfunc\n\nfunc Test_put_above_first_line()\n  new\n  let @\" = 'text'\n  silent! normal 0o00\n  0put\n  call assert_equal('text', getline(1))\n  bwipe!\nendfunc\n\nfunc Test_multibyte_op_end_mark()\n  new\n  call setline(1, '\u0442\u0435\u0441\u0442')\n  normal viwdp\n  call assert_equal([0, 1, 7, 0], getpos(\"'>\"))\n  call assert_equal([0, 1, 7, 0], getpos(\"']\"))\n\n  normal Vyp\n  call assert_equal([0, 1, v:maxcol, 0], getpos(\"'>\"))\n  call assert_equal([0, 2, 7, 0], getpos(\"']\"))\n  bwipe!\nendfunc\n\n\" this was putting a mark before the start of a line\nfunc Test_put_empty_register()\n  new\n  norm yy\n  norm [Pi00\u0014\u0014\u0003ggv)s0\n  sil! norm [P\n  bwipe!\nendfunc\n\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_BIG)\n    msg_puts(_(\"\\nBig version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#elif defined(FEAT_SMALL)\n    msg_puts(_(\"\\nSmall version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "fixing_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * register.c: functions for managing registers\n */\n\n#include \"vim.h\"\n\n/*\n * Registers:\n *\t0 = unnamed register, for normal yanks and puts\n *   1..9 = registers '1' to '9', for deletes\n * 10..35 = registers 'a' to 'z' ('A' to 'Z' for appending)\n *     36 = delete register '-'\n *     37 = Selection register '*'. Only if FEAT_CLIPBOARD defined\n *     38 = Clipboard register '+'. Only if FEAT_CLIPBOARD and FEAT_X11 defined\n */\nstatic yankreg_T\ty_regs[NUM_REGISTERS];\n\nstatic yankreg_T\t*y_current;\t    // ptr to current yankreg\nstatic int\t\ty_append;\t    // TRUE when appending\nstatic yankreg_T\t*y_previous = NULL; // ptr to last written yankreg\n\nstatic int\tstuff_yank(int, char_u *);\nstatic void\tput_reedit_in_typebuf(int silent);\nstatic int\tput_in_typebuf(char_u *s, int esc, int colon,\n\t\t\t\t\t\t\t\t int silent);\nstatic int\tyank_copy_line(struct block_def *bd, long y_idx, int exclude_trailing_space);\n#ifdef FEAT_CLIPBOARD\nstatic void\tcopy_yank_reg(yankreg_T *reg);\n#endif\nstatic void\tdis_msg(char_u *p, int skip_esc);\n\n#if defined(FEAT_VIMINFO) || defined(PROTO)\n    yankreg_T *\nget_y_regs(void)\n{\n    return y_regs;\n}\n#endif\n\n#if defined(FEAT_CLIPBOARD) || defined(PROTO)\n    yankreg_T *\nget_y_register(int reg)\n{\n    return &y_regs[reg];\n}\n#endif\n\n    yankreg_T *\nget_y_current(void)\n{\n    return y_current;\n}\n\n    yankreg_T *\nget_y_previous(void)\n{\n    return y_previous;\n}\n\n    void\nset_y_current(yankreg_T *yreg)\n{\n    y_current = yreg;\n}\n\n    void\nset_y_previous(yankreg_T *yreg)\n{\n    y_previous = yreg;\n}\n\n    void\nreset_y_append(void)\n{\n    y_append = FALSE;\n}\n\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Keep the last expression line here, for repeating.\n */\nstatic char_u\t*expr_line = NULL;\nstatic exarg_T\t*expr_eap = NULL;\n\n/*\n * Get an expression for the \"\\\"=expr1\" or \"CTRL-R =expr1\"\n * Returns '=' when OK, NUL otherwise.\n */\n    int\nget_expr_register(void)\n{\n    char_u\t*new_line;\n\n    new_line = getcmdline('=', 0L, 0, 0);\n    if (new_line == NULL)\n\treturn NUL;\n    if (*new_line == NUL)\t// use previous line\n\tvim_free(new_line);\n    else\n\tset_expr_line(new_line, NULL);\n    return '=';\n}\n\n/*\n * Set the expression for the '=' register.\n * Argument must be an allocated string.\n * \"eap\" may be used if the next line needs to be checked when evaluating the\n * expression.\n */\n    void\nset_expr_line(char_u *new_line, exarg_T *eap)\n{\n    vim_free(expr_line);\n    expr_line = new_line;\n    expr_eap = eap;\n}\n\n/*\n * Get the result of the '=' register expression.\n * Returns a pointer to allocated memory, or NULL for failure.\n */\n    char_u *\nget_expr_line(void)\n{\n    char_u\t*expr_copy;\n    char_u\t*rv;\n    static int\tnested = 0;\n\n    if (expr_line == NULL)\n\treturn NULL;\n\n    // Make a copy of the expression, because evaluating it may cause it to be\n    // changed.\n    expr_copy = vim_strsave(expr_line);\n    if (expr_copy == NULL)\n\treturn NULL;\n\n    // When we are invoked recursively limit the evaluation to 10 levels.\n    // Then return the string as-is.\n    if (nested >= 10)\n\treturn expr_copy;\n\n    ++nested;\n    rv = eval_to_string_eap(expr_copy, TRUE, expr_eap);\n    --nested;\n    vim_free(expr_copy);\n    return rv;\n}\n\n/*\n * Get the '=' register expression itself, without evaluating it.\n */\n    static char_u *\nget_expr_line_src(void)\n{\n    if (expr_line == NULL)\n\treturn NULL;\n    return vim_strsave(expr_line);\n}\n#endif // FEAT_EVAL\n\n/*\n * Check if 'regname' is a valid name of a yank register.\n * Note: There is no check for 0 (default register), caller should do this\n */\n    int\nvalid_yank_reg(\n    int\t    regname,\n    int\t    writing)\t    // if TRUE check for writable registers\n{\n    if (       (regname > 0 && ASCII_ISALNUM(regname))\n\t    || (!writing && vim_strchr((char_u *)\n#ifdef FEAT_EVAL\n\t\t\t\t    \"/.%:=\"\n#else\n\t\t\t\t    \"/.%:\"\n#endif\n\t\t\t\t\t, regname) != NULL)\n\t    || regname == '#'\n\t    || regname == '\"'\n\t    || regname == '-'\n\t    || regname == '_'\n#ifdef FEAT_CLIPBOARD\n\t    || regname == '*'\n\t    || regname == '+'\n#endif\n#ifdef FEAT_DND\n\t    || (!writing && regname == '~')\n#endif\n\t\t\t\t\t\t\t)\n\treturn TRUE;\n    return FALSE;\n}\n\n/*\n * Set y_current and y_append, according to the value of \"regname\".\n * Cannot handle the '_' register.\n * Must only be called with a valid register name!\n *\n * If regname is 0 and writing, use register 0\n * If regname is 0 and reading, use previous register\n *\n * Return TRUE when the register should be inserted literally (selection or\n * clipboard).\n */\n    int\nget_yank_register(int regname, int writing)\n{\n    int\t    i;\n    int\t    ret = FALSE;\n\n    y_append = FALSE;\n    if ((regname == 0 || regname == '\"') && !writing && y_previous != NULL)\n    {\n\ty_current = y_previous;\n\treturn ret;\n    }\n    i = regname;\n    if (VIM_ISDIGIT(i))\n\ti -= '0';\n    else if (ASCII_ISLOWER(i))\n\ti = CharOrdLow(i) + 10;\n    else if (ASCII_ISUPPER(i))\n    {\n\ti = CharOrdUp(i) + 10;\n\ty_append = TRUE;\n    }\n    else if (regname == '-')\n\ti = DELETION_REGISTER;\n#ifdef FEAT_CLIPBOARD\n    // When selection is not available, use register 0 instead of '*'\n    else if (clip_star.available && regname == '*')\n    {\n\ti = STAR_REGISTER;\n\tret = TRUE;\n    }\n    // When clipboard is not available, use register 0 instead of '+'\n    else if (clip_plus.available && regname == '+')\n    {\n\ti = PLUS_REGISTER;\n\tret = TRUE;\n    }\n#endif\n#ifdef FEAT_DND\n    else if (!writing && regname == '~')\n\ti = TILDE_REGISTER;\n#endif\n    else\t\t// not 0-9, a-z, A-Z or '-': use register 0\n\ti = 0;\n    y_current = &(y_regs[i]);\n    if (writing)\t// remember the register we write into for do_put()\n\ty_previous = y_current;\n    return ret;\n}\n\n/*\n * Obtain the contents of a \"normal\" register. The register is made empty.\n * The returned pointer has allocated memory, use put_register() later.\n */\n    void *\nget_register(\n    int\t\tname,\n    int\t\tcopy)\t// make a copy, if FALSE make register empty.\n{\n    yankreg_T\t*reg;\n    int\t\ti;\n\n#ifdef FEAT_CLIPBOARD\n    // When Visual area changed, may have to update selection.  Obtain the\n    // selection too.\n    if (name == '*' && clip_star.available)\n    {\n\tif (clip_isautosel_star())\n\t    clip_update_selection(&clip_star);\n\tmay_get_selection(name);\n    }\n    if (name == '+' && clip_plus.available)\n    {\n\tif (clip_isautosel_plus())\n\t    clip_update_selection(&clip_plus);\n\tmay_get_selection(name);\n    }\n#endif\n\n    get_yank_register(name, 0);\n    reg = ALLOC_ONE(yankreg_T);\n    if (reg != NULL)\n    {\n\t*reg = *y_current;\n\tif (copy)\n\t{\n\t    // If we run out of memory some or all of the lines are empty.\n\t    if (reg->y_size == 0)\n\t\treg->y_array = NULL;\n\t    else\n\t\treg->y_array = ALLOC_MULT(char_u *, reg->y_size);\n\t    if (reg->y_array != NULL)\n\t    {\n\t\tfor (i = 0; i < reg->y_size; ++i)\n\t\t    reg->y_array[i] = vim_strsave(y_current->y_array[i]);\n\t    }\n\t}\n\telse\n\t    y_current->y_array = NULL;\n    }\n    return (void *)reg;\n}\n\n/*\n * Put \"reg\" into register \"name\".  Free any previous contents and \"reg\".\n */\n    void\nput_register(int name, void *reg)\n{\n    get_yank_register(name, 0);\n    free_yank_all();\n    *y_current = *(yankreg_T *)reg;\n    vim_free(reg);\n\n#ifdef FEAT_CLIPBOARD\n    // Send text written to clipboard register to the clipboard.\n    may_set_selection();\n#endif\n}\n\n#if defined(FEAT_CLIPBOARD) || defined(PROTO)\n    void\nfree_register(void *reg)\n{\n    yankreg_T tmp;\n\n    tmp = *y_current;\n    *y_current = *(yankreg_T *)reg;\n    free_yank_all();\n    vim_free(reg);\n    *y_current = tmp;\n}\n#endif\n\n/*\n * return TRUE if the current yank register has type MLINE\n */\n    int\nyank_register_mline(int regname)\n{\n    if (regname != 0 && !valid_yank_reg(regname, FALSE))\n\treturn FALSE;\n    if (regname == '_')\t\t// black hole is always empty\n\treturn FALSE;\n    get_yank_register(regname, FALSE);\n    return (y_current->y_type == MLINE);\n}\n\n/*\n * Start or stop recording into a yank register.\n *\n * Return FAIL for failure, OK otherwise.\n */\n    int\ndo_record(int c)\n{\n    char_u\t    *p;\n    static int\t    regname;\n    yankreg_T\t    *old_y_previous, *old_y_current;\n    int\t\t    retval;\n\n    if (reg_recording == 0)\t    // start recording\n    {\n\t// registers 0-9, a-z and \" are allowed\n\tif (c < 0 || (!ASCII_ISALNUM(c) && c != '\"'))\n\t    retval = FAIL;\n\telse\n\t{\n\t    reg_recording = c;\n\t    showmode();\n\t    regname = c;\n\t    retval = OK;\n\t}\n    }\n    else\t\t\t    // stop recording\n    {\n\t// Get the recorded key hits.  K_SPECIAL and CSI will be escaped, this\n\t// needs to be removed again to put it in a register.  exec_reg then\n\t// adds the escaping back later.\n\treg_recording = 0;\n\tmsg(\"\");\n\tp = get_recorded();\n\tif (p == NULL)\n\t    retval = FAIL;\n\telse\n\t{\n\t    // Remove escaping for CSI and K_SPECIAL in multi-byte chars.\n\t    vim_unescape_csi(p);\n\n\t    // We don't want to change the default register here, so save and\n\t    // restore the current register name.\n\t    old_y_previous = y_previous;\n\t    old_y_current = y_current;\n\n\t    retval = stuff_yank(regname, p);\n\n\t    y_previous = old_y_previous;\n\t    y_current = old_y_current;\n\t}\n    }\n    return retval;\n}\n\n/*\n * Stuff string \"p\" into yank register \"regname\" as a single line (append if\n * uppercase).\t\"p\" must have been alloced.\n *\n * return FAIL for failure, OK otherwise\n */\n    static int\nstuff_yank(int regname, char_u *p)\n{\n    char_u\t*lp;\n    char_u\t**pp;\n\n    // check for read-only register\n    if (regname != 0 && !valid_yank_reg(regname, TRUE))\n    {\n\tvim_free(p);\n\treturn FAIL;\n    }\n    if (regname == '_')\t\t    // black hole: don't do anything\n    {\n\tvim_free(p);\n\treturn OK;\n    }\n    get_yank_register(regname, TRUE);\n    if (y_append && y_current->y_array != NULL)\n    {\n\tpp = &(y_current->y_array[y_current->y_size - 1]);\n\tlp = alloc(STRLEN(*pp) + STRLEN(p) + 1);\n\tif (lp == NULL)\n\t{\n\t    vim_free(p);\n\t    return FAIL;\n\t}\n\tSTRCPY(lp, *pp);\n\tSTRCAT(lp, p);\n\tvim_free(p);\n\tvim_free(*pp);\n\t*pp = lp;\n    }\n    else\n    {\n\tfree_yank_all();\n\tif ((y_current->y_array = ALLOC_ONE(char_u *)) == NULL)\n\t{\n\t    vim_free(p);\n\t    return FAIL;\n\t}\n\ty_current->y_array[0] = p;\n\ty_current->y_size = 1;\n\ty_current->y_type = MCHAR;  // used to be MLINE, why?\n#ifdef FEAT_VIMINFO\n\ty_current->y_time_set = vim_time();\n#endif\n    }\n    return OK;\n}\n\n/*\n * Last executed register (@ command)\n */\nstatic int execreg_lastc = NUL;\n\n#if defined(FEAT_VIMINFO) || defined(PROTO)\n    int\nget_execreg_lastc(void)\n{\n    return execreg_lastc;\n}\n\n    void\nset_execreg_lastc(int lastc)\n{\n    execreg_lastc = lastc;\n}\n#endif\n\n/*\n * When executing a register as a series of ex-commands, if the\n * line-continuation character is used for a line, then join it with one or\n * more previous lines. Note that lines are processed backwards starting from\n * the last line in the register.\n *\n * Arguments:\n *   lines - list of lines in the register\n *   idx - index of the line starting with \\ or \"\\. Join this line with all the\n *\t   immediate predecessor lines that start with a \\ and the first line\n *\t   that doesn't start with a \\. Lines that start with a comment \"\\\n *\t   character are ignored.\n *\n * Returns the concatenated line. The index of the line that should be\n * processed next is returned in idx.\n */\n    static char_u *\nexecreg_line_continuation(char_u **lines, long *idx)\n{\n    garray_T\tga;\n    long\ti = *idx;\n    char_u\t*p;\n    int\t\tcmd_start;\n    int\t\tcmd_end = i;\n    int\t\tj;\n    char_u\t*str;\n\n    ga_init2(&ga, sizeof(char_u), 400);\n\n    // search backwards to find the first line of this command.\n    // Any line not starting with \\ or \"\\ is the start of the\n    // command.\n    while (--i > 0)\n    {\n\tp = skipwhite(lines[i]);\n\tif (*p != '\\\\' && (p[0] != '\"' || p[1] != '\\\\' || p[2] != ' '))\n\t    break;\n    }\n    cmd_start = i;\n\n    // join all the lines\n    ga_concat(&ga, lines[cmd_start]);\n    for (j = cmd_start + 1; j <= cmd_end; j++)\n    {\n\tp = skipwhite(lines[j]);\n\tif (*p == '\\\\')\n\t{\n\t    // Adjust the growsize to the current length to\n\t    // speed up concatenating many lines.\n\t    if (ga.ga_len > 400)\n\t    {\n\t\tif (ga.ga_len > 8000)\n\t\t    ga.ga_growsize = 8000;\n\t\telse\n\t\t    ga.ga_growsize = ga.ga_len;\n\t    }\n\t    ga_concat(&ga, p + 1);\n\t}\n    }\n    ga_append(&ga, NUL);\n    str = vim_strsave(ga.ga_data);\n    ga_clear(&ga);\n\n    *idx = i;\n    return str;\n}\n\n/*\n * Execute a yank register: copy it into the stuff buffer.\n *\n * Return FAIL for failure, OK otherwise.\n */\n    int\ndo_execreg(\n    int\t    regname,\n    int\t    colon,\t\t// insert ':' before each line\n    int\t    addcr,\t\t// always add '\\n' to end of line\n    int\t    silent)\t\t// set \"silent\" flag in typeahead buffer\n{\n    long\ti;\n    char_u\t*p;\n    int\t\tretval = OK;\n    int\t\tremap;\n\n    // repeat previous one\n    if (regname == '@')\n    {\n\tif (execreg_lastc == NUL)\n\t{\n\t    emsg(_(e_no_previously_used_register));\n\t    return FAIL;\n\t}\n\tregname = execreg_lastc;\n    }\n    // check for valid regname\n    if (regname == '%' || regname == '#' || !valid_yank_reg(regname, FALSE))\n    {\n\temsg_invreg(regname);\n\treturn FAIL;\n    }\n    execreg_lastc = regname;\n\n#ifdef FEAT_CLIPBOARD\n    regname = may_get_selection(regname);\n#endif\n\n    // black hole: don't stuff anything\n    if (regname == '_')\n\treturn OK;\n\n    // use last command line\n    if (regname == ':')\n    {\n\tif (last_cmdline == NULL)\n\t{\n\t    emsg(_(e_no_previous_command_line));\n\t    return FAIL;\n\t}\n\t// don't keep the cmdline containing @:\n\tVIM_CLEAR(new_last_cmdline);\n\t// Escape all control characters with a CTRL-V\n\tp = vim_strsave_escaped_ext(last_cmdline,\n\t\t    (char_u *)\"\\001\\002\\003\\004\\005\\006\\007\"\n\t\t\t  \"\\010\\011\\012\\013\\014\\015\\016\\017\"\n\t\t\t  \"\\020\\021\\022\\023\\024\\025\\026\\027\"\n\t\t\t  \"\\030\\031\\032\\033\\034\\035\\036\\037\",\n\t\t    Ctrl_V, FALSE);\n\tif (p != NULL)\n\t{\n\t    // When in Visual mode \"'<,'>\" will be prepended to the command.\n\t    // Remove it when it's already there.\n\t    if (VIsual_active && STRNCMP(p, \"'<,'>\", 5) == 0)\n\t\tretval = put_in_typebuf(p + 5, TRUE, TRUE, silent);\n\t    else\n\t\tretval = put_in_typebuf(p, TRUE, TRUE, silent);\n\t}\n\tvim_free(p);\n    }\n#ifdef FEAT_EVAL\n    else if (regname == '=')\n    {\n\tp = get_expr_line();\n\tif (p == NULL)\n\t    return FAIL;\n\tretval = put_in_typebuf(p, TRUE, colon, silent);\n\tvim_free(p);\n    }\n#endif\n    else if (regname == '.')\t\t// use last inserted text\n    {\n\tp = get_last_insert_save();\n\tif (p == NULL)\n\t{\n\t    emsg(_(e_no_inserted_text_yet));\n\t    return FAIL;\n\t}\n\tretval = put_in_typebuf(p, FALSE, colon, silent);\n\tvim_free(p);\n    }\n    else\n    {\n\tget_yank_register(regname, FALSE);\n\tif (y_current->y_array == NULL)\n\t    return FAIL;\n\n\t// Disallow remapping for \":@r\".\n\tremap = colon ? REMAP_NONE : REMAP_YES;\n\n\t// Insert lines into typeahead buffer, from last one to first one.\n\tput_reedit_in_typebuf(silent);\n\tfor (i = y_current->y_size; --i >= 0; )\n\t{\n\t    char_u *escaped;\n\t    char_u *str;\n\t    int\t    free_str = FALSE;\n\n\t    // insert NL between lines and after last line if type is MLINE\n\t    if (y_current->y_type == MLINE || i < y_current->y_size - 1\n\t\t\t\t\t\t\t\t     || addcr)\n\t    {\n\t\tif (ins_typebuf((char_u *)\"\\n\", remap, 0, TRUE, silent) == FAIL)\n\t\t    return FAIL;\n\t    }\n\n\t    // Handle line-continuation for :@<register>\n\t    str = y_current->y_array[i];\n\t    if (colon && i > 0)\n\t    {\n\t\tp = skipwhite(str);\n\t\tif (*p == '\\\\' || (p[0] == '\"' && p[1] == '\\\\' && p[2] == ' '))\n\t\t{\n\t\t    str = execreg_line_continuation(y_current->y_array, &i);\n\t\t    if (str == NULL)\n\t\t\treturn FAIL;\n\t\t    free_str = TRUE;\n\t\t}\n\t    }\n\t    escaped = vim_strsave_escape_csi(str);\n\t    if (free_str)\n\t\tvim_free(str);\n\t    if (escaped == NULL)\n\t\treturn FAIL;\n\t    retval = ins_typebuf(escaped, remap, 0, TRUE, silent);\n\t    vim_free(escaped);\n\t    if (retval == FAIL)\n\t\treturn FAIL;\n\t    if (colon && ins_typebuf((char_u *)\":\", remap, 0, TRUE, silent)\n\t\t\t\t\t\t\t\t      == FAIL)\n\t\treturn FAIL;\n\t}\n\treg_executing = regname == 0 ? '\"' : regname; // disable \"q\" command\n    }\n    return retval;\n}\n\n/*\n * If \"restart_edit\" is not zero, put it in the typeahead buffer, so that it's\n * used only after other typeahead has been processed.\n */\n    static void\nput_reedit_in_typebuf(int silent)\n{\n    char_u\tbuf[3];\n\n    if (restart_edit != NUL)\n    {\n\tif (restart_edit == 'V')\n\t{\n\t    buf[0] = 'g';\n\t    buf[1] = 'R';\n\t    buf[2] = NUL;\n\t}\n\telse\n\t{\n\t    buf[0] = restart_edit == 'I' ? 'i' : restart_edit;\n\t    buf[1] = NUL;\n\t}\n\tif (ins_typebuf(buf, REMAP_NONE, 0, TRUE, silent) == OK)\n\t    restart_edit = NUL;\n    }\n}\n\n/*\n * Insert register contents \"s\" into the typeahead buffer, so that it will be\n * executed again.\n * When \"esc\" is TRUE it is to be taken literally: Escape CSI characters and\n * no remapping.\n */\n    static int\nput_in_typebuf(\n    char_u\t*s,\n    int\t\tesc,\n    int\t\tcolon,\t    // add ':' before the line\n    int\t\tsilent)\n{\n    int\t\tretval = OK;\n\n    put_reedit_in_typebuf(silent);\n    if (colon)\n\tretval = ins_typebuf((char_u *)\"\\n\", REMAP_NONE, 0, TRUE, silent);\n    if (retval == OK)\n    {\n\tchar_u\t*p;\n\n\tif (esc)\n\t    p = vim_strsave_escape_csi(s);\n\telse\n\t    p = s;\n\tif (p == NULL)\n\t    retval = FAIL;\n\telse\n\t    retval = ins_typebuf(p, esc ? REMAP_NONE : REMAP_YES,\n\t\t\t\t\t\t\t     0, TRUE, silent);\n\tif (esc)\n\t    vim_free(p);\n    }\n    if (colon && retval == OK)\n\tretval = ins_typebuf((char_u *)\":\", REMAP_NONE, 0, TRUE, silent);\n    return retval;\n}\n\n/*\n * Insert a yank register: copy it into the Read buffer.\n * Used by CTRL-R command and middle mouse button in insert mode.\n *\n * return FAIL for failure, OK otherwise\n */\n    int\ninsert_reg(\n    int\t\tregname,\n    int\t\tliterally_arg)\t// insert literally, not as if typed\n{\n    long\ti;\n    int\t\tretval = OK;\n    char_u\t*arg;\n    int\t\tallocated;\n    int\t\tliterally = literally_arg;\n\n    // It is possible to get into an endless loop by having CTRL-R a in\n    // register a and then, in insert mode, doing CTRL-R a.\n    // If you hit CTRL-C, the loop will be broken here.\n    ui_breakcheck();\n    if (got_int)\n\treturn FAIL;\n\n    // check for valid regname\n    if (regname != NUL && !valid_yank_reg(regname, FALSE))\n\treturn FAIL;\n\n#ifdef FEAT_CLIPBOARD\n    regname = may_get_selection(regname);\n#endif\n\n    if (regname == '.')\t\t\t// insert last inserted text\n\tretval = stuff_inserted(NUL, 1L, TRUE);\n    else if (get_spec_reg(regname, &arg, &allocated, TRUE))\n    {\n\tif (arg == NULL)\n\t    return FAIL;\n\tstuffescaped(arg, literally);\n\tif (allocated)\n\t    vim_free(arg);\n    }\n    else\t\t\t\t// name or number register\n    {\n\tif (get_yank_register(regname, FALSE))\n\t    literally = TRUE;\n\tif (y_current->y_array == NULL)\n\t    retval = FAIL;\n\telse\n\t{\n\t    for (i = 0; i < y_current->y_size; ++i)\n\t    {\n\t\tif (regname == '-')\n\t\t{\n\t\t    AppendCharToRedobuff(Ctrl_R);\n\t\t    AppendCharToRedobuff(regname);\n\t\t    do_put(regname, NULL, BACKWARD, 1L, PUT_CURSEND);\n\t\t}\n\t\telse\n\t\t    stuffescaped(y_current->y_array[i], literally);\n\t\t// Insert a newline between lines and after last line if\n\t\t// y_type is MLINE.\n\t\tif (y_current->y_type == MLINE || i < y_current->y_size - 1)\n\t\t    stuffcharReadbuff('\\n');\n\t    }\n\t}\n    }\n\n    return retval;\n}\n\n/*\n * If \"regname\" is a special register, return TRUE and store a pointer to its\n * value in \"argp\".\n */\n    int\nget_spec_reg(\n    int\t\tregname,\n    char_u\t**argp,\n    int\t\t*allocated,\t// return: TRUE when value was allocated\n    int\t\terrmsg)\t\t// give error message when failing\n{\n    int\t\tcnt;\n\n    *argp = NULL;\n    *allocated = FALSE;\n    switch (regname)\n    {\n\tcase '%':\t\t// file name\n\t    if (errmsg)\n\t\tcheck_fname();\t// will give emsg if not set\n\t    *argp = curbuf->b_fname;\n\t    return TRUE;\n\n\tcase '#':\t\t// alternate file name\n\t    *argp = getaltfname(errmsg);\t// may give emsg if not set\n\t    return TRUE;\n\n#ifdef FEAT_EVAL\n\tcase '=':\t\t// result of expression\n\t    *argp = get_expr_line();\n\t    *allocated = TRUE;\n\t    return TRUE;\n#endif\n\n\tcase ':':\t\t// last command line\n\t    if (last_cmdline == NULL && errmsg)\n\t\temsg(_(e_no_previous_command_line));\n\t    *argp = last_cmdline;\n\t    return TRUE;\n\n\tcase '/':\t\t// last search-pattern\n\t    if (last_search_pat() == NULL && errmsg)\n\t\temsg(_(e_no_previous_regular_expression));\n\t    *argp = last_search_pat();\n\t    return TRUE;\n\n\tcase '.':\t\t// last inserted text\n\t    *argp = get_last_insert_save();\n\t    *allocated = TRUE;\n\t    if (*argp == NULL && errmsg)\n\t\temsg(_(e_no_inserted_text_yet));\n\t    return TRUE;\n\n#ifdef FEAT_SEARCHPATH\n\tcase Ctrl_F:\t\t// Filename under cursor\n\tcase Ctrl_P:\t\t// Path under cursor, expand via \"path\"\n\t    if (!errmsg)\n\t\treturn FALSE;\n\t    *argp = file_name_at_cursor(FNAME_MESS | FNAME_HYP\n\t\t\t    | (regname == Ctrl_P ? FNAME_EXP : 0), 1L, NULL);\n\t    *allocated = TRUE;\n\t    return TRUE;\n#endif\n\n\tcase Ctrl_W:\t\t// word under cursor\n\tcase Ctrl_A:\t\t// WORD (mnemonic All) under cursor\n\t    if (!errmsg)\n\t\treturn FALSE;\n\t    cnt = find_ident_under_cursor(argp, regname == Ctrl_W\n\t\t\t\t   ?  (FIND_IDENT|FIND_STRING) : FIND_STRING);\n\t    *argp = cnt ? vim_strnsave(*argp, cnt) : NULL;\n\t    *allocated = TRUE;\n\t    return TRUE;\n\n\tcase Ctrl_L:\t\t// Line under cursor\n\t    if (!errmsg)\n\t\treturn FALSE;\n\n\t    *argp = ml_get_buf(curwin->w_buffer,\n\t\t\tcurwin->w_cursor.lnum, FALSE);\n\t    return TRUE;\n\n\tcase '_':\t\t// black hole: always empty\n\t    *argp = (char_u *)\"\";\n\t    return TRUE;\n    }\n\n    return FALSE;\n}\n\n/*\n * Paste a yank register into the command line.\n * Only for non-special registers.\n * Used by CTRL-R command in command-line mode\n * insert_reg() can't be used here, because special characters from the\n * register contents will be interpreted as commands.\n *\n * return FAIL for failure, OK otherwise\n */\n    int\ncmdline_paste_reg(\n    int regname,\n    int literally_arg,\t// Insert text literally instead of \"as typed\"\n    int remcr)\t\t// don't add CR characters\n{\n    long\ti;\n    int\t\tliterally = literally_arg;\n\n    if (get_yank_register(regname, FALSE))\n\tliterally = TRUE;\n    if (y_current->y_array == NULL)\n\treturn FAIL;\n\n    for (i = 0; i < y_current->y_size; ++i)\n    {\n\tcmdline_paste_str(y_current->y_array[i], literally);\n\n\t// Insert ^M between lines and after last line if type is MLINE.\n\t// Don't do this when \"remcr\" is TRUE.\n\tif ((y_current->y_type == MLINE || i < y_current->y_size - 1) && !remcr)\n\t    cmdline_paste_str((char_u *)\"\\r\", literally);\n\n\t// Check for CTRL-C, in case someone tries to paste a few thousand\n\t// lines and gets bored.\n\tui_breakcheck();\n\tif (got_int)\n\t    return FAIL;\n    }\n    return OK;\n}\n\n/*\n * Shift the delete registers: \"9 is cleared, \"8 becomes \"9, etc.\n */\n    void\nshift_delete_registers()\n{\n    int\t\tn;\n\n    y_current = &y_regs[9];\n    free_yank_all();\t\t\t// free register nine\n    for (n = 9; n > 1; --n)\n\ty_regs[n] = y_regs[n - 1];\n    y_current = &y_regs[1];\n    if (!y_append)\n\ty_previous = y_current;\n    y_regs[1].y_array = NULL;\t\t// set register one to empty\n}\n\n#if defined(FEAT_EVAL)\n    void\nyank_do_autocmd(oparg_T *oap, yankreg_T *reg)\n{\n    static int\t    recursive = FALSE;\n    dict_T\t    *v_event;\n    list_T\t    *list;\n    int\t\t    n;\n    char_u\t    buf[NUMBUFLEN + 2];\n    long\t    reglen = 0;\n    save_v_event_T  save_v_event;\n\n    if (recursive)\n\treturn;\n\n    v_event = get_v_event(&save_v_event);\n\n    list = list_alloc();\n    if (list == NULL)\n\treturn;\n\n    // yanked text contents\n    for (n = 0; n < reg->y_size; n++)\n\tlist_append_string(list, reg->y_array[n], -1);\n    list->lv_lock = VAR_FIXED;\n    (void)dict_add_list(v_event, \"regcontents\", list);\n\n    // register name or empty string for unnamed operation\n    buf[0] = (char_u)oap->regname;\n    buf[1] = NUL;\n    (void)dict_add_string(v_event, \"regname\", buf);\n\n    // motion type: inclusive or exclusive\n    (void)dict_add_bool(v_event, \"inclusive\", oap->inclusive);\n\n    // kind of operation (yank, delete, change)\n    buf[0] = get_op_char(oap->op_type);\n    buf[1] = get_extra_op_char(oap->op_type);\n    buf[2] = NUL;\n    (void)dict_add_string(v_event, \"operator\", buf);\n\n    // register type\n    buf[0] = NUL;\n    buf[1] = NUL;\n    switch (get_reg_type(oap->regname, &reglen))\n    {\n\tcase MLINE: buf[0] = 'V'; break;\n\tcase MCHAR: buf[0] = 'v'; break;\n\tcase MBLOCK:\n\t\tvim_snprintf((char *)buf, sizeof(buf), \"%c%ld\", Ctrl_V,\n\t\t\t     reglen + 1);\n\t\tbreak;\n    }\n    (void)dict_add_string(v_event, \"regtype\", buf);\n\n    // selection type - visual or not\n    (void)dict_add_bool(v_event, \"visual\", oap->is_VIsual);\n\n    // Lock the dictionary and its keys\n    dict_set_items_ro(v_event);\n\n    recursive = TRUE;\n    textlock++;\n    apply_autocmds(EVENT_TEXTYANKPOST, NULL, NULL, FALSE, curbuf);\n    textlock--;\n    recursive = FALSE;\n\n    // Empty the dictionary, v:event is still valid\n    restore_v_event(v_event, &save_v_event);\n}\n#endif\n\n/*\n * set all the yank registers to empty (called from main())\n */\n    void\ninit_yank(void)\n{\n    int\t\ti;\n\n    for (i = 0; i < NUM_REGISTERS; ++i)\n\ty_regs[i].y_array = NULL;\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nclear_registers(void)\n{\n    int\t\ti;\n\n    for (i = 0; i < NUM_REGISTERS; ++i)\n    {\n\ty_current = &y_regs[i];\n\tif (y_current->y_array != NULL)\n\t    free_yank_all();\n    }\n}\n#endif\n\n/*\n * Free \"n\" lines from the current yank register.\n * Called for normal freeing and in case of error.\n */\n    static void\nfree_yank(long n)\n{\n    if (y_current->y_array != NULL)\n    {\n\tlong\t    i;\n\n\tfor (i = n; --i >= 0; )\n\t    vim_free(y_current->y_array[i]);\n\tVIM_CLEAR(y_current->y_array);\n    }\n}\n\n    void\nfree_yank_all(void)\n{\n    free_yank(y_current->y_size);\n}\n\n/*\n * Yank the text between \"oap->start\" and \"oap->end\" into a yank register.\n * If we are to append (uppercase register), we first yank into a new yank\n * register and then concatenate the old and the new one (so we keep the old\n * one in case of out-of-memory).\n *\n * Return FAIL for failure, OK otherwise.\n */\n    int\nop_yank(oparg_T *oap, int deleting, int mess)\n{\n    long\t\ty_idx;\t\t// index in y_array[]\n    yankreg_T\t\t*curr;\t\t// copy of y_current\n    yankreg_T\t\tnewreg;\t\t// new yank register when appending\n    char_u\t\t**new_ptr;\n    linenr_T\t\tlnum;\t\t// current line number\n    long\t\tj;\n    int\t\t\tyanktype = oap->motion_type;\n    long\t\tyanklines = oap->line_count;\n    linenr_T\t\tyankendlnum = oap->end.lnum;\n    char_u\t\t*p;\n    char_u\t\t*pnew;\n    struct block_def\tbd;\n#if defined(FEAT_CLIPBOARD) && defined(FEAT_X11)\n    int\t\t\tdid_star = FALSE;\n#endif\n\n\t\t\t\t    // check for read-only register\n    if (oap->regname != 0 && !valid_yank_reg(oap->regname, TRUE))\n    {\n\tbeep_flush();\n\treturn FAIL;\n    }\n    if (oap->regname == '_')\t    // black hole: nothing to do\n\treturn OK;\n\n#ifdef FEAT_CLIPBOARD\n    if (!clip_star.available && oap->regname == '*')\n\toap->regname = 0;\n    else if (!clip_plus.available && oap->regname == '+')\n\toap->regname = 0;\n#endif\n\n    if (!deleting)\t\t    // op_delete() already set y_current\n\tget_yank_register(oap->regname, TRUE);\n\n    curr = y_current;\n\t\t\t\t    // append to existing contents\n    if (y_append && y_current->y_array != NULL)\n\ty_current = &newreg;\n    else\n\tfree_yank_all();\t    // free previously yanked lines\n\n    // If the cursor was in column 1 before and after the movement, and the\n    // operator is not inclusive, the yank is always linewise.\n    if (       oap->motion_type == MCHAR\n\t    && oap->start.col == 0\n\t    && !oap->inclusive\n\t    && (!oap->is_VIsual || *p_sel == 'o')\n\t    && !oap->block_mode\n\t    && oap->end.col == 0\n\t    && yanklines > 1)\n    {\n\tyanktype = MLINE;\n\t--yankendlnum;\n\t--yanklines;\n    }\n\n    y_current->y_size = yanklines;\n    y_current->y_type = yanktype;   // set the yank register type\n    y_current->y_width = 0;\n    y_current->y_array = lalloc_clear(sizeof(char_u *) * yanklines, TRUE);\n    if (y_current->y_array == NULL)\n    {\n\ty_current = curr;\n\treturn FAIL;\n    }\n#ifdef FEAT_VIMINFO\n    y_current->y_time_set = vim_time();\n#endif\n\n    y_idx = 0;\n    lnum = oap->start.lnum;\n\n    if (oap->block_mode)\n    {\n\t// Visual block mode\n\ty_current->y_type = MBLOCK;\t    // set the yank register type\n\ty_current->y_width = oap->end_vcol - oap->start_vcol;\n\n\tif (curwin->w_curswant == MAXCOL && y_current->y_width > 0)\n\t    y_current->y_width--;\n    }\n\n    for ( ; lnum <= yankendlnum; lnum++, y_idx++)\n    {\n\tswitch (y_current->y_type)\n\t{\n\t    case MBLOCK:\n\t\tblock_prep(oap, &bd, lnum, FALSE);\n\t\tif (yank_copy_line(&bd, y_idx, oap->excl_tr_ws) == FAIL)\n\t\t    goto fail;\n\t\tbreak;\n\n\t    case MLINE:\n\t\tif ((y_current->y_array[y_idx] =\n\t\t\t\t\t    vim_strsave(ml_get(lnum))) == NULL)\n\t\t    goto fail;\n\t\tbreak;\n\n\t    case MCHAR:\n\t\t{\n\t\t    colnr_T startcol = 0, endcol = MAXCOL;\n\t\t    int\t    is_oneChar = FALSE;\n\t\t    colnr_T cs, ce;\n\n\t\t    p = ml_get(lnum);\n\t\t    bd.startspaces = 0;\n\t\t    bd.endspaces = 0;\n\n\t\t    if (lnum == oap->start.lnum)\n\t\t    {\n\t\t\tstartcol = oap->start.col;\n\t\t\tif (virtual_op)\n\t\t\t{\n\t\t\t    getvcol(curwin, &oap->start, &cs, NULL, &ce);\n\t\t\t    if (ce != cs && oap->start.coladd > 0)\n\t\t\t    {\n\t\t\t\t// Part of a tab selected -- but don't\n\t\t\t\t// double-count it.\n\t\t\t\tbd.startspaces = (ce - cs + 1)\n\t\t\t\t\t\t\t  - oap->start.coladd;\n\t\t\t\tstartcol++;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\n\t\t    if (lnum == oap->end.lnum)\n\t\t    {\n\t\t\tendcol = oap->end.col;\n\t\t\tif (virtual_op)\n\t\t\t{\n\t\t\t    getvcol(curwin, &oap->end, &cs, NULL, &ce);\n\t\t\t    if (p[endcol] == NUL || (cs + oap->end.coladd < ce\n\t\t\t\t\t// Don't add space for double-wide\n\t\t\t\t\t// char; endcol will be on last byte\n\t\t\t\t\t// of multi-byte char.\n\t\t\t\t\t&& (*mb_head_off)(p, p + endcol) == 0))\n\t\t\t    {\n\t\t\t\tif (oap->start.lnum == oap->end.lnum\n\t\t\t\t\t    && oap->start.col == oap->end.col)\n\t\t\t\t{\n\t\t\t\t    // Special case: inside a single char\n\t\t\t\t    is_oneChar = TRUE;\n\t\t\t\t    bd.startspaces = oap->end.coladd\n\t\t\t\t\t - oap->start.coladd + oap->inclusive;\n\t\t\t\t    endcol = startcol;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t    bd.endspaces = oap->end.coladd\n\t\t\t\t\t\t\t     + oap->inclusive;\n\t\t\t\t    endcol -= oap->inclusive;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    if (endcol == MAXCOL)\n\t\t\tendcol = (colnr_T)STRLEN(p);\n\t\t    if (startcol > endcol || is_oneChar)\n\t\t\tbd.textlen = 0;\n\t\t    else\n\t\t\tbd.textlen = endcol - startcol + oap->inclusive;\n\t\t    bd.textstart = p + startcol;\n\t\t    if (yank_copy_line(&bd, y_idx, FALSE) == FAIL)\n\t\t\tgoto fail;\n\t\t    break;\n\t\t}\n\t\t// NOTREACHED\n\t}\n    }\n\n    if (curr != y_current)\t// append the new block to the old block\n    {\n\tnew_ptr = ALLOC_MULT(char_u *, curr->y_size + y_current->y_size);\n\tif (new_ptr == NULL)\n\t    goto fail;\n\tfor (j = 0; j < curr->y_size; ++j)\n\t    new_ptr[j] = curr->y_array[j];\n\tvim_free(curr->y_array);\n\tcurr->y_array = new_ptr;\n#ifdef FEAT_VIMINFO\n\tcurr->y_time_set = vim_time();\n#endif\n\n\tif (yanktype == MLINE)\t// MLINE overrides MCHAR and MBLOCK\n\t    curr->y_type = MLINE;\n\n\t// Concatenate the last line of the old block with the first line of\n\t// the new block, unless being Vi compatible.\n\tif (curr->y_type == MCHAR && vim_strchr(p_cpo, CPO_REGAPPEND) == NULL)\n\t{\n\t    pnew = alloc(STRLEN(curr->y_array[curr->y_size - 1])\n\t\t\t\t\t  + STRLEN(y_current->y_array[0]) + 1);\n\t    if (pnew == NULL)\n\t    {\n\t\ty_idx = y_current->y_size - 1;\n\t\tgoto fail;\n\t    }\n\t    STRCPY(pnew, curr->y_array[--j]);\n\t    STRCAT(pnew, y_current->y_array[0]);\n\t    vim_free(curr->y_array[j]);\n\t    vim_free(y_current->y_array[0]);\n\t    curr->y_array[j++] = pnew;\n\t    y_idx = 1;\n\t}\n\telse\n\t    y_idx = 0;\n\twhile (y_idx < y_current->y_size)\n\t    curr->y_array[j++] = y_current->y_array[y_idx++];\n\tcurr->y_size = j;\n\tvim_free(y_current->y_array);\n\ty_current = curr;\n    }\n\n    if (mess)\t\t\t// Display message about yank?\n    {\n\tif (yanktype == MCHAR\n\t\t&& !oap->block_mode\n\t\t&& yanklines == 1)\n\t    yanklines = 0;\n\t// Some versions of Vi use \">=\" here, some don't...\n\tif (yanklines > p_report)\n\t{\n\t    char namebuf[100];\n\n\t    if (oap->regname == NUL)\n\t\t*namebuf = NUL;\n\t    else\n\t\tvim_snprintf(namebuf, sizeof(namebuf),\n\t\t\t\t\t\t_(\" into \\\"%c\"), oap->regname);\n\n\t    // redisplay now, so message is not deleted\n\t    update_topline_redraw();\n\t    if (oap->block_mode)\n\t    {\n\t\tsmsg(NGETTEXT(\"block of %ld line yanked%s\",\n\t\t\t\t     \"block of %ld lines yanked%s\", yanklines),\n\t\t\tyanklines, namebuf);\n\t    }\n\t    else\n\t    {\n\t\tsmsg(NGETTEXT(\"%ld line yanked%s\",\n\t\t\t\t\t      \"%ld lines yanked%s\", yanklines),\n\t\t\tyanklines, namebuf);\n\t    }\n\t}\n    }\n\n    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n    {\n\t// Set \"'[\" and \"']\" marks.\n\tcurbuf->b_op_start = oap->start;\n\tcurbuf->b_op_end = oap->end;\n\tif (yanktype == MLINE && !oap->block_mode)\n\t{\n\t    curbuf->b_op_start.col = 0;\n\t    curbuf->b_op_end.col = MAXCOL;\n\t}\n    }\n\n#ifdef FEAT_CLIPBOARD\n    // If we were yanking to the '*' register, send result to clipboard.\n    // If no register was specified, and \"unnamed\" in 'clipboard', make a copy\n    // to the '*' register.\n    if (clip_star.available\n\t    && (curr == &(y_regs[STAR_REGISTER])\n\t\t|| (!deleting && oap->regname == 0\n\t\t   && ((clip_unnamed | clip_unnamed_saved) & CLIP_UNNAMED))))\n    {\n\tif (curr != &(y_regs[STAR_REGISTER]))\n\t    // Copy the text from register 0 to the clipboard register.\n\t    copy_yank_reg(&(y_regs[STAR_REGISTER]));\n\n\tclip_own_selection(&clip_star);\n\tclip_gen_set_selection(&clip_star);\n# ifdef FEAT_X11\n\tdid_star = TRUE;\n# endif\n    }\n\n# ifdef FEAT_X11\n    // If we were yanking to the '+' register, send result to selection.\n    // Also copy to the '*' register, in case auto-select is off.  But not when\n    // 'clipboard' has \"unnamedplus\" and not \"unnamed\".\n    if (clip_plus.available\n\t    && (curr == &(y_regs[PLUS_REGISTER])\n\t\t|| (!deleting && oap->regname == 0\n\t\t  && ((clip_unnamed | clip_unnamed_saved) &\n\t\t\t\t\t\t\t  CLIP_UNNAMED_PLUS))))\n    {\n\tif (curr != &(y_regs[PLUS_REGISTER]))\n\t    // Copy the text from register 0 to the clipboard register.\n\t    copy_yank_reg(&(y_regs[PLUS_REGISTER]));\n\n\tclip_own_selection(&clip_plus);\n\tclip_gen_set_selection(&clip_plus);\n\tif (!clip_isautosel_star()\n\t\t&& !clip_isautosel_plus()\n\t\t&& !((clip_unnamed | clip_unnamed_saved) == CLIP_UNNAMED_PLUS)\n\t\t&& !did_star\n\t\t&& curr == &(y_regs[PLUS_REGISTER]))\n\t{\n\t    copy_yank_reg(&(y_regs[STAR_REGISTER]));\n\t    clip_own_selection(&clip_star);\n\t    clip_gen_set_selection(&clip_star);\n\t}\n    }\n# endif\n#endif\n\n#if defined(FEAT_EVAL)\n    if (!deleting && has_textyankpost())\n\tyank_do_autocmd(oap, y_current);\n#endif\n\n    return OK;\n\nfail:\t\t// free the allocated lines\n    free_yank(y_idx + 1);\n    y_current = curr;\n    return FAIL;\n}\n\n/*\n * Copy a block range into a register.\n * If \"exclude_trailing_space\" is set, do not copy trailing whitespaces.\n */\n    static int\nyank_copy_line(struct block_def *bd, long y_idx, int exclude_trailing_space)\n{\n    char_u\t*pnew;\n\n    if (exclude_trailing_space)\n\tbd->endspaces = 0;\n    if ((pnew = alloc(bd->startspaces + bd->endspaces + bd->textlen + 1))\n\t\t\t\t\t\t\t\t      == NULL)\n\treturn FAIL;\n    y_current->y_array[y_idx] = pnew;\n    vim_memset(pnew, ' ', (size_t)bd->startspaces);\n    pnew += bd->startspaces;\n    mch_memmove(pnew, bd->textstart, (size_t)bd->textlen);\n    pnew += bd->textlen;\n    vim_memset(pnew, ' ', (size_t)bd->endspaces);\n    pnew += bd->endspaces;\n    if (exclude_trailing_space)\n    {\n\tint s = bd->textlen + bd->endspaces;\n\n\twhile (s > 0 && VIM_ISWHITE(*(bd->textstart + s - 1)))\n\t{\n\t    s = s - (*mb_head_off)(bd->textstart, bd->textstart + s - 1) - 1;\n\t    pnew--;\n\t}\n    }\n    *pnew = NUL;\n    return OK;\n}\n\n#ifdef FEAT_CLIPBOARD\n/*\n * Make a copy of the y_current register to register \"reg\".\n */\n    static void\ncopy_yank_reg(yankreg_T *reg)\n{\n    yankreg_T\t*curr = y_current;\n    long\tj;\n\n    y_current = reg;\n    free_yank_all();\n    *y_current = *curr;\n    y_current->y_array = lalloc_clear(\n\t\t\t\t    sizeof(char_u *) * y_current->y_size, TRUE);\n    if (y_current->y_array == NULL)\n\ty_current->y_size = 0;\n    else\n\tfor (j = 0; j < y_current->y_size; ++j)\n\t    if ((y_current->y_array[j] = vim_strsave(curr->y_array[j])) == NULL)\n\t    {\n\t\tfree_yank(j);\n\t\ty_current->y_size = 0;\n\t\tbreak;\n\t    }\n    y_current = curr;\n}\n#endif\n\n/*\n * Put contents of register \"regname\" into the text.\n * Caller must check \"regname\" to be valid!\n * \"flags\": PUT_FIXINDENT\tmake indent look nice\n *\t    PUT_CURSEND\t\tleave cursor after end of new text\n *\t    PUT_LINE\t\tforce linewise put (\":put\")\n *\t    PUT_BLOCK_INNER     in block mode, do not add trailing spaces\n */\n    void\ndo_put(\n    int\t\tregname,\n    char_u\t*expr_result,\t// result for regname \"=\" when compiled\n    int\t\tdir,\t\t// BACKWARD for 'P', FORWARD for 'p'\n    long\tcount,\n    int\t\tflags)\n{\n    char_u\t*ptr;\n    char_u\t*newp, *oldp;\n    int\t\tyanklen;\n    int\t\ttotlen = 0;\t\t// init for gcc\n    linenr_T\tlnum;\n    colnr_T\tcol;\n    long\ti;\t\t\t// index in y_array[]\n    int\t\ty_type;\n    long\ty_size;\n    int\t\toldlen;\n    long\ty_width = 0;\n    colnr_T\tvcol;\n    int\t\tdelcount;\n    int\t\tincr = 0;\n    long\tj;\n    struct block_def bd;\n    char_u\t**y_array = NULL;\n    yankreg_T\t*y_current_used = NULL;\n    long\tnr_lines = 0;\n    pos_T\tnew_cursor;\n    int\t\tindent;\n    int\t\torig_indent = 0;\t// init for gcc\n    int\t\tindent_diff = 0;\t// init for gcc\n    int\t\tfirst_indent = TRUE;\n    int\t\tlendiff = 0;\n    pos_T\told_pos;\n    char_u\t*insert_string = NULL;\n    int\t\tallocated = FALSE;\n    long\tcnt;\n    pos_T\torig_start = curbuf->b_op_start;\n    pos_T\torig_end = curbuf->b_op_end;\n    unsigned int cur_ve_flags = get_ve_flags();\n\n#ifdef FEAT_CLIPBOARD\n    // Adjust register name for \"unnamed\" in 'clipboard'.\n    adjust_clip_reg(&regname);\n    (void)may_get_selection(regname);\n#endif\n\n    if (flags & PUT_FIXINDENT)\n\torig_indent = get_indent();\n\n    curbuf->b_op_start = curwin->w_cursor;\t// default for '[ mark\n    curbuf->b_op_end = curwin->w_cursor;\t// default for '] mark\n\n    // Using inserted text works differently, because the register includes\n    // special characters (newlines, etc.).\n    if (regname == '.')\n    {\n\tif (VIsual_active)\n\t    stuffcharReadbuff(VIsual_mode);\n\t(void)stuff_inserted((dir == FORWARD ? (count == -1 ? 'o' : 'a') :\n\t\t\t\t    (count == -1 ? 'O' : 'i')), count, FALSE);\n\t// Putting the text is done later, so can't really move the cursor to\n\t// the next character.  Use \"l\" to simulate it.\n\tif ((flags & PUT_CURSEND) && gchar_cursor() != NUL)\n\t    stuffcharReadbuff('l');\n\treturn;\n    }\n\n    // For special registers '%' (file name), '#' (alternate file name) and\n    // ':' (last command line), etc. we have to create a fake yank register.\n    // For compiled code \"expr_result\" holds the expression result.\n    if (regname == '=' && expr_result != NULL)\n\tinsert_string = expr_result;\n    else if (get_spec_reg(regname, &insert_string, &allocated, TRUE)\n\t\t&& insert_string == NULL)\n\treturn;\n\n    // Autocommands may be executed when saving lines for undo.  This might\n    // make \"y_array\" invalid, so we start undo now to avoid that.\n    if (u_save(curwin->w_cursor.lnum, curwin->w_cursor.lnum + 1) == FAIL)\n\tgoto end;\n\n    if (insert_string != NULL)\n    {\n\ty_type = MCHAR;\n#ifdef FEAT_EVAL\n\tif (regname == '=')\n\t{\n\t    // For the = register we need to split the string at NL\n\t    // characters.\n\t    // Loop twice: count the number of lines and save them.\n\t    for (;;)\n\t    {\n\t\ty_size = 0;\n\t\tptr = insert_string;\n\t\twhile (ptr != NULL)\n\t\t{\n\t\t    if (y_array != NULL)\n\t\t\ty_array[y_size] = ptr;\n\t\t    ++y_size;\n\t\t    ptr = vim_strchr(ptr, '\\n');\n\t\t    if (ptr != NULL)\n\t\t    {\n\t\t\tif (y_array != NULL)\n\t\t\t    *ptr = NUL;\n\t\t\t++ptr;\n\t\t\t// A trailing '\\n' makes the register linewise.\n\t\t\tif (*ptr == NUL)\n\t\t\t{\n\t\t\t    y_type = MLINE;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tif (y_array != NULL)\n\t\t    break;\n\t\ty_array = ALLOC_MULT(char_u *, y_size);\n\t\tif (y_array == NULL)\n\t\t    goto end;\n\t    }\n\t}\n\telse\n#endif\n\t{\n\t    y_size = 1;\t\t// use fake one-line yank register\n\t    y_array = &insert_string;\n\t}\n    }\n    else\n    {\n\tget_yank_register(regname, FALSE);\n\n\ty_type = y_current->y_type;\n\ty_width = y_current->y_width;\n\ty_size = y_current->y_size;\n\ty_array = y_current->y_array;\n\ty_current_used = y_current;\n    }\n\n    if (y_type == MLINE)\n    {\n\tif (flags & PUT_LINE_SPLIT)\n\t{\n\t    char_u *p;\n\n\t    // \"p\" or \"P\" in Visual mode: split the lines to put the text in\n\t    // between.\n\t    if (u_save_cursor() == FAIL)\n\t\tgoto end;\n\t    p = ml_get_cursor();\n\t    if (dir == FORWARD && *p != NUL)\n\t\tMB_PTR_ADV(p);\n\t    ptr = vim_strsave(p);\n\t    if (ptr == NULL)\n\t\tgoto end;\n\t    ml_append(curwin->w_cursor.lnum, ptr, (colnr_T)0, FALSE);\n\t    vim_free(ptr);\n\n\t    oldp = ml_get_curline();\n\t    p = oldp + curwin->w_cursor.col;\n\t    if (dir == FORWARD && *p != NUL)\n\t\tMB_PTR_ADV(p);\n\t    ptr = vim_strnsave(oldp, p - oldp);\n\t    if (ptr == NULL)\n\t\tgoto end;\n\t    ml_replace(curwin->w_cursor.lnum, ptr, FALSE);\n\t    ++nr_lines;\n\t    dir = FORWARD;\n\t}\n\tif (flags & PUT_LINE_FORWARD)\n\t{\n\t    // Must be \"p\" for a Visual block, put lines below the block.\n\t    curwin->w_cursor = curbuf->b_visual.vi_end;\n\t    dir = FORWARD;\n\t}\n\tcurbuf->b_op_start = curwin->w_cursor;\t// default for '[ mark\n\tcurbuf->b_op_end = curwin->w_cursor;\t// default for '] mark\n    }\n\n    if (flags & PUT_LINE)\t// :put command or \"p\" in Visual line mode.\n\ty_type = MLINE;\n\n    if (y_size == 0 || y_array == NULL)\n    {\n\tsemsg(_(e_nothing_in_register_str),\n\t\t  regname == 0 ? (char_u *)\"\\\"\" : transchar(regname));\n\tgoto end;\n    }\n\n    if (y_type == MBLOCK)\n    {\n\tlnum = curwin->w_cursor.lnum + y_size + 1;\n\tif (lnum > curbuf->b_ml.ml_line_count)\n\t    lnum = curbuf->b_ml.ml_line_count + 1;\n\tif (u_save(curwin->w_cursor.lnum - 1, lnum) == FAIL)\n\t    goto end;\n    }\n    else if (y_type == MLINE)\n    {\n\tlnum = curwin->w_cursor.lnum;\n#ifdef FEAT_FOLDING\n\t// Correct line number for closed fold.  Don't move the cursor yet,\n\t// u_save() uses it.\n\tif (dir == BACKWARD)\n\t    (void)hasFolding(lnum, &lnum, NULL);\n\telse\n\t    (void)hasFolding(lnum, NULL, &lnum);\n#endif\n\tif (dir == FORWARD)\n\t    ++lnum;\n\t// In an empty buffer the empty line is going to be replaced, include\n\t// it in the saved lines.\n\tif ((BUFEMPTY() ? u_save(0, 2) : u_save(lnum - 1, lnum)) == FAIL)\n\t    goto end;\n#ifdef FEAT_FOLDING\n\tif (dir == FORWARD)\n\t    curwin->w_cursor.lnum = lnum - 1;\n\telse\n\t    curwin->w_cursor.lnum = lnum;\n\tcurbuf->b_op_start = curwin->w_cursor;\t// for mark_adjust()\n#endif\n    }\n    else if (u_save_cursor() == FAIL)\n\tgoto end;\n\n    yanklen = (int)STRLEN(y_array[0]);\n\n    if (cur_ve_flags == VE_ALL && y_type == MCHAR)\n    {\n\tif (gchar_cursor() == TAB)\n\t{\n\t    int viscol = getviscol();\n\t    int ts = curbuf->b_p_ts;\n\n\t    // Don't need to insert spaces when \"p\" on the last position of a\n\t    // tab or \"P\" on the first position.\n\t    if (dir == FORWARD ?\n#ifdef FEAT_VARTABS\n\t\t    tabstop_padding(viscol, ts, curbuf->b_p_vts_array) != 1\n#else\n\t\t    ts - (viscol % ts) != 1\n#endif\n\t\t    : curwin->w_cursor.coladd > 0)\n\t\tcoladvance_force(viscol);\n\t    else\n\t\tcurwin->w_cursor.coladd = 0;\n\t}\n\telse if (curwin->w_cursor.coladd > 0 || gchar_cursor() == NUL)\n\t    coladvance_force(getviscol() + (dir == FORWARD));\n    }\n\n    lnum = curwin->w_cursor.lnum;\n    col = curwin->w_cursor.col;\n\n    // Block mode\n    if (y_type == MBLOCK)\n    {\n\tint\tc = gchar_cursor();\n\tcolnr_T\tendcol2 = 0;\n\n\tif (dir == FORWARD && c != NUL)\n\t{\n\t    if (cur_ve_flags == VE_ALL)\n\t\tgetvcol(curwin, &curwin->w_cursor, &col, NULL, &endcol2);\n\t    else\n\t\tgetvcol(curwin, &curwin->w_cursor, NULL, NULL, &col);\n\n\t    if (has_mbyte)\n\t\t// move to start of next multi-byte character\n\t\tcurwin->w_cursor.col += (*mb_ptr2len)(ml_get_cursor());\n\t    else\n\t    if (c != TAB || cur_ve_flags != VE_ALL)\n\t\t++curwin->w_cursor.col;\n\t    ++col;\n\t}\n\telse\n\t    getvcol(curwin, &curwin->w_cursor, &col, NULL, &endcol2);\n\n\tcol += curwin->w_cursor.coladd;\n\tif (cur_ve_flags == VE_ALL\n\t\t&& (curwin->w_cursor.coladd > 0\n\t\t    || endcol2 == curwin->w_cursor.col))\n\t{\n\t    if (dir == FORWARD && c == NUL)\n\t\t++col;\n\t    if (dir != FORWARD && c != NUL && curwin->w_cursor.coladd > 0)\n\t\t++curwin->w_cursor.col;\n\t    if (c == TAB)\n\t    {\n\t\tif (dir == BACKWARD && curwin->w_cursor.col)\n\t\t    curwin->w_cursor.col--;\n\t\tif (dir == FORWARD && col - 1 == endcol2)\n\t\t    curwin->w_cursor.col++;\n\t    }\n\t}\n\tcurwin->w_cursor.coladd = 0;\n\tbd.textcol = 0;\n\tfor (i = 0; i < y_size; ++i)\n\t{\n\t    int spaces = 0;\n\t    char shortline;\n\n\t    bd.startspaces = 0;\n\t    bd.endspaces = 0;\n\t    vcol = 0;\n\t    delcount = 0;\n\n\t    // add a new line\n\t    if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t    {\n\t\tif (ml_append(curbuf->b_ml.ml_line_count, (char_u *)\"\",\n\t\t\t\t\t\t   (colnr_T)1, FALSE) == FAIL)\n\t\t    break;\n\t\t++nr_lines;\n\t    }\n\t    // get the old line and advance to the position to insert at\n\t    oldp = ml_get_curline();\n\t    oldlen = (int)STRLEN(oldp);\n\t    for (ptr = oldp; vcol < col && *ptr; )\n\t    {\n\t\t// Count a tab for what it's worth (if list mode not on)\n\t\tincr = lbr_chartabsize_adv(oldp, &ptr, vcol);\n\t\tvcol += incr;\n\t    }\n\t    bd.textcol = (colnr_T)(ptr - oldp);\n\n\t    shortline = (vcol < col) || (vcol == col && !*ptr) ;\n\n\t    if (vcol < col) // line too short, padd with spaces\n\t\tbd.startspaces = col - vcol;\n\t    else if (vcol > col)\n\t    {\n\t\tbd.endspaces = vcol - col;\n\t\tbd.startspaces = incr - bd.endspaces;\n\t\t--bd.textcol;\n\t\tdelcount = 1;\n\t\tif (has_mbyte)\n\t\t    bd.textcol -= (*mb_head_off)(oldp, oldp + bd.textcol);\n\t\tif (oldp[bd.textcol] != TAB)\n\t\t{\n\t\t    // Only a Tab can be split into spaces.  Other\n\t\t    // characters will have to be moved to after the\n\t\t    // block, causing misalignment.\n\t\t    delcount = 0;\n\t\t    bd.endspaces = 0;\n\t\t}\n\t    }\n\n\t    yanklen = (int)STRLEN(y_array[i]);\n\n\t    if ((flags & PUT_BLOCK_INNER) == 0)\n\t    {\n\t\t// calculate number of spaces required to fill right side of\n\t\t// block\n\t\tspaces = y_width + 1;\n\t\tfor (j = 0; j < yanklen; j++)\n\t\t    spaces -= lbr_chartabsize(NULL, &y_array[i][j], 0);\n\t\tif (spaces < 0)\n\t\t    spaces = 0;\n\t    }\n\n\t    // Insert the new text.\n\t    // First check for multiplication overflow.\n\t    if (yanklen + spaces != 0\n\t\t     && count > ((INT_MAX - (bd.startspaces + bd.endspaces))\n\t\t\t\t\t\t\t/ (yanklen + spaces)))\n\t    {\n\t\temsg(_(e_resulting_text_too_long));\n\t\tbreak;\n\t    }\n\n\t    totlen = count * (yanklen + spaces) + bd.startspaces + bd.endspaces;\n\t    newp = alloc(totlen + oldlen + 1);\n\t    if (newp == NULL)\n\t\tbreak;\n\n\t    // copy part up to cursor to new line\n\t    ptr = newp;\n\t    mch_memmove(ptr, oldp, (size_t)bd.textcol);\n\t    ptr += bd.textcol;\n\n\t    // may insert some spaces before the new text\n\t    vim_memset(ptr, ' ', (size_t)bd.startspaces);\n\t    ptr += bd.startspaces;\n\n\t    // insert the new text\n\t    for (j = 0; j < count; ++j)\n\t    {\n\t\tmch_memmove(ptr, y_array[i], (size_t)yanklen);\n\t\tptr += yanklen;\n\n\t\t// insert block's trailing spaces only if there's text behind\n\t\tif ((j < count - 1 || !shortline) && spaces)\n\t\t{\n\t\t    vim_memset(ptr, ' ', (size_t)spaces);\n\t\t    ptr += spaces;\n\t\t}\n\t\telse\n\t\t    totlen -= spaces;  // didn't use these spaces\n\t    }\n\n\t    // may insert some spaces after the new text\n\t    vim_memset(ptr, ' ', (size_t)bd.endspaces);\n\t    ptr += bd.endspaces;\n\n\t    // move the text after the cursor to the end of the line.\n\t    mch_memmove(ptr, oldp + bd.textcol + delcount,\n\t\t\t\t(size_t)(oldlen - bd.textcol - delcount + 1));\n\t    ml_replace(curwin->w_cursor.lnum, newp, FALSE);\n\n\t    ++curwin->w_cursor.lnum;\n\t    if (i == 0)\n\t\tcurwin->w_cursor.col += bd.startspaces;\n\t}\n\n\tchanged_lines(lnum, 0, curwin->w_cursor.lnum, nr_lines);\n\n\t// Set '[ mark.\n\tcurbuf->b_op_start = curwin->w_cursor;\n\tcurbuf->b_op_start.lnum = lnum;\n\n\t// adjust '] mark\n\tcurbuf->b_op_end.lnum = curwin->w_cursor.lnum - 1;\n\tcurbuf->b_op_end.col = bd.textcol + totlen - 1;\n\tcurbuf->b_op_end.coladd = 0;\n\tif (flags & PUT_CURSEND)\n\t{\n\t    colnr_T len;\n\n\t    curwin->w_cursor = curbuf->b_op_end;\n\t    curwin->w_cursor.col++;\n\n\t    // in Insert mode we might be after the NUL, correct for that\n\t    len = (colnr_T)STRLEN(ml_get_curline());\n\t    if (curwin->w_cursor.col > len)\n\t\tcurwin->w_cursor.col = len;\n\t}\n\telse\n\t    curwin->w_cursor.lnum = lnum;\n    }\n    else\n    {\n\t// Character or Line mode\n\tif (y_type == MCHAR)\n\t{\n\t    // if type is MCHAR, FORWARD is the same as BACKWARD on the next\n\t    // char\n\t    if (dir == FORWARD && gchar_cursor() != NUL)\n\t    {\n\t\tif (has_mbyte)\n\t\t{\n\t\t    int bytelen = (*mb_ptr2len)(ml_get_cursor());\n\n\t\t    // put it on the next of the multi-byte character.\n\t\t    col += bytelen;\n\t\t    if (yanklen)\n\t\t    {\n\t\t\tcurwin->w_cursor.col += bytelen;\n\t\t\tcurbuf->b_op_end.col += bytelen;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    ++col;\n\t\t    if (yanklen)\n\t\t    {\n\t\t\t++curwin->w_cursor.col;\n\t\t\t++curbuf->b_op_end.col;\n\t\t    }\n\t\t}\n\t    }\n\t    curbuf->b_op_start = curwin->w_cursor;\n\t}\n\t// Line mode: BACKWARD is the same as FORWARD on the previous line\n\telse if (dir == BACKWARD)\n\t    --lnum;\n\tnew_cursor = curwin->w_cursor;\n\n\t// simple case: insert into one line at a time\n\tif (y_type == MCHAR && y_size == 1)\n\t{\n\t    linenr_T\tend_lnum = 0; // init for gcc\n\t    linenr_T\tstart_lnum = lnum;\n\t    int\t\tfirst_byte_off = 0;\n\n\t    if (VIsual_active)\n\t    {\n\t\tend_lnum = curbuf->b_visual.vi_end.lnum;\n\t\tif (end_lnum < curbuf->b_visual.vi_start.lnum)\n\t\t    end_lnum = curbuf->b_visual.vi_start.lnum;\n\t\tif (end_lnum > start_lnum)\n\t\t{\n\t\t    pos_T   pos;\n\n\t\t    // \"col\" is valid for the first line, in following lines\n\t\t    // the virtual column needs to be used.  Matters for\n\t\t    // multi-byte characters.\n\t\t    pos.lnum = lnum;\n\t\t    pos.col = col;\n\t\t    pos.coladd = 0;\n\t\t    getvcol(curwin, &pos, NULL, &vcol, NULL);\n\t\t}\n\t    }\n\n\t    if (count == 0 || yanklen == 0)\n\t    {\n\t\tif (VIsual_active)\n\t\t    lnum = end_lnum;\n\t    }\n\t    else if (count > INT_MAX / yanklen)\n\t\t// multiplication overflow\n\t\temsg(_(e_resulting_text_too_long));\n\t    else\n\t    {\n\t\ttotlen = count * yanklen;\n\t\tdo {\n\t\t    oldp = ml_get(lnum);\n\t\t    oldlen = (int)STRLEN(oldp);\n\t\t    if (lnum > start_lnum)\n\t\t    {\n\t\t\tpos_T   pos;\n\n\t\t\tpos.lnum = lnum;\n\t\t\tif (getvpos(&pos, vcol) == OK)\n\t\t\t    col = pos.col;\n\t\t\telse\n\t\t\t    col = MAXCOL;\n\t\t    }\n\t\t    if (VIsual_active && col > oldlen)\n\t\t    {\n\t\t\tlnum++;\n\t\t\tcontinue;\n\t\t    }\n\t\t    newp = alloc(totlen + oldlen + 1);\n\t\t    if (newp == NULL)\n\t\t\tgoto end;\t// alloc() gave an error message\n\t\t    mch_memmove(newp, oldp, (size_t)col);\n\t\t    ptr = newp + col;\n\t\t    for (i = 0; i < count; ++i)\n\t\t    {\n\t\t\tmch_memmove(ptr, y_array[0], (size_t)yanklen);\n\t\t\tptr += yanklen;\n\t\t    }\n\t\t    STRMOVE(ptr, oldp + col);\n\t\t    ml_replace(lnum, newp, FALSE);\n\n\t\t    // compute the byte offset for the last character\n\t\t    first_byte_off = mb_head_off(newp, ptr - 1);\n\n\t\t    // Place cursor on last putted char.\n\t\t    if (lnum == curwin->w_cursor.lnum)\n\t\t    {\n\t\t\t// make sure curwin->w_virtcol is updated\n\t\t\tchanged_cline_bef_curs();\n\t\t\tcurwin->w_cursor.col += (colnr_T)(totlen - 1);\n\t\t    }\n\t\t    if (VIsual_active)\n\t\t\tlnum++;\n\t\t} while (VIsual_active && lnum <= end_lnum);\n\n\t\tif (VIsual_active) // reset lnum to the last visual line\n\t\t    lnum--;\n\t    }\n\n\t    // put '] at the first byte of the last character\n\t    curbuf->b_op_end = curwin->w_cursor;\n\t    curbuf->b_op_end.col -= first_byte_off;\n\n\t    // For \"CTRL-O p\" in Insert mode, put cursor after last char\n\t    if (totlen && (restart_edit != 0 || (flags & PUT_CURSEND)))\n\t\t++curwin->w_cursor.col;\n\t    else\n\t\tcurwin->w_cursor.col -= first_byte_off;\n\t    changed_bytes(lnum, col);\n\t}\n\telse\n\t{\n\t    linenr_T\tnew_lnum = new_cursor.lnum;\n\t    size_t\tlen;\n\n\t    // Insert at least one line.  When y_type is MCHAR, break the first\n\t    // line in two.\n\t    for (cnt = 1; cnt <= count; ++cnt)\n\t    {\n\t\ti = 0;\n\t\tif (y_type == MCHAR)\n\t\t{\n\t\t    // Split the current line in two at the insert position.\n\t\t    // First insert y_array[size - 1] in front of second line.\n\t\t    // Then append y_array[0] to first line.\n\t\t    lnum = new_cursor.lnum;\n\t\t    ptr = ml_get(lnum) + col;\n\t\t    totlen = (int)STRLEN(y_array[y_size - 1]);\n\t\t    newp = alloc(STRLEN(ptr) + totlen + 1);\n\t\t    if (newp == NULL)\n\t\t\tgoto error;\n\t\t    STRCPY(newp, y_array[y_size - 1]);\n\t\t    STRCAT(newp, ptr);\n\t\t    // insert second line\n\t\t    ml_append(lnum, newp, (colnr_T)0, FALSE);\n\t\t    ++new_lnum;\n\t\t    vim_free(newp);\n\n\t\t    oldp = ml_get(lnum);\n\t\t    newp = alloc(col + yanklen + 1);\n\t\t    if (newp == NULL)\n\t\t\tgoto error;\n\t\t\t\t\t    // copy first part of line\n\t\t    mch_memmove(newp, oldp, (size_t)col);\n\t\t\t\t\t    // append to first line\n\t\t    mch_memmove(newp + col, y_array[0], (size_t)(yanklen + 1));\n\t\t    ml_replace(lnum, newp, FALSE);\n\n\t\t    curwin->w_cursor.lnum = lnum;\n\t\t    i = 1;\n\t\t}\n\n\t\tfor (; i < y_size; ++i)\n\t\t{\n\t\t    if (y_type != MCHAR || i < y_size - 1)\n\t\t    {\n\t\t\tif (ml_append(lnum, y_array[i], (colnr_T)0, FALSE)\n\t\t\t\t\t\t\t\t      == FAIL)\n\t\t\t    goto error;\n\t\t\tnew_lnum++;\n\t\t    }\n\t\t    lnum++;\n\t\t    ++nr_lines;\n\t\t    if (flags & PUT_FIXINDENT)\n\t\t    {\n\t\t\told_pos = curwin->w_cursor;\n\t\t\tcurwin->w_cursor.lnum = lnum;\n\t\t\tptr = ml_get(lnum);\n\t\t\tif (cnt == count && i == y_size - 1)\n\t\t\t    lendiff = (int)STRLEN(ptr);\n\t\t\tif (*ptr == '#' && preprocs_left())\n\t\t\t    indent = 0;     // Leave # lines at start\n\t\t\telse\n\t\t\t     if (*ptr == NUL)\n\t\t\t    indent = 0;     // Ignore empty lines\n\t\t\telse if (first_indent)\n\t\t\t{\n\t\t\t    indent_diff = orig_indent - get_indent();\n\t\t\t    indent = orig_indent;\n\t\t\t    first_indent = FALSE;\n\t\t\t}\n\t\t\telse if ((indent = get_indent() + indent_diff) < 0)\n\t\t\t    indent = 0;\n\t\t\t(void)set_indent(indent, 0);\n\t\t\tcurwin->w_cursor = old_pos;\n\t\t\t// remember how many chars were removed\n\t\t\tif (cnt == count && i == y_size - 1)\n\t\t\t    lendiff -= (int)STRLEN(ml_get(lnum));\n\t\t    }\n\t\t}\n\t\tif (cnt == 1)\n\t\t    new_lnum = lnum;\n\t    }\n\nerror:\n\t    // Adjust marks.\n\t    if (y_type == MLINE)\n\t    {\n\t\tcurbuf->b_op_start.col = 0;\n\t\tif (dir == FORWARD)\n\t\t    curbuf->b_op_start.lnum++;\n\t    }\n\t    // Skip mark_adjust when adding lines after the last one, there\n\t    // can't be marks there. But still needed in diff mode.\n\t    if (curbuf->b_op_start.lnum + (y_type == MCHAR) - 1 + nr_lines\n\t\t\t\t\t\t < curbuf->b_ml.ml_line_count\n#ifdef FEAT_DIFF\n\t\t\t\t\t\t || curwin->w_p_diff\n#endif\n\t\t\t\t\t\t )\n\t\tmark_adjust(curbuf->b_op_start.lnum + (y_type == MCHAR),\n\t\t\t\t\t     (linenr_T)MAXLNUM, nr_lines, 0L);\n\n\t    // note changed text for displaying and folding\n\t    if (y_type == MCHAR)\n\t\tchanged_lines(curwin->w_cursor.lnum, col,\n\t\t\t\t\t curwin->w_cursor.lnum + 1, nr_lines);\n\t    else\n\t\tchanged_lines(curbuf->b_op_start.lnum, 0,\n\t\t\t\t\t   curbuf->b_op_start.lnum, nr_lines);\n\t    if (y_current_used != NULL && (y_current_used != y_current\n\t\t\t\t\t     || y_current->y_array != y_array))\n\t    {\n\t\t// Something invoked through changed_lines() has changed the\n\t\t// yank buffer, e.g. a GUI clipboard callback.\n\t\temsg(_(e_yank_register_changed_while_using_it));\n\t\tgoto end;\n\t    }\n\n\t    // Put the '] mark on the first byte of the last inserted character.\n\t    // Correct the length for change in indent.\n\t    curbuf->b_op_end.lnum = new_lnum;\n\t    len = STRLEN(y_array[y_size - 1]);\n\t    col = (colnr_T)len - lendiff;\n\t    if (col > 1)\n\t    {\n\t\tcurbuf->b_op_end.col = col - 1;\n\t\tif (len > 0)\n\t\t    curbuf->b_op_end.col -= mb_head_off(y_array[y_size - 1],\n\t\t\t\t\t\ty_array[y_size - 1] + len - 1);\n\t    }\n\t    else\n\t\tcurbuf->b_op_end.col = 0;\n\n\t    if (flags & PUT_CURSLINE)\n\t    {\n\t\t// \":put\": put cursor on last inserted line\n\t\tcurwin->w_cursor.lnum = lnum;\n\t\tbeginline(BL_WHITE | BL_FIX);\n\t    }\n\t    else if (flags & PUT_CURSEND)\n\t    {\n\t\t// put cursor after inserted text\n\t\tif (y_type == MLINE)\n\t\t{\n\t\t    if (lnum >= curbuf->b_ml.ml_line_count)\n\t\t\tcurwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t\t    else\n\t\t\tcurwin->w_cursor.lnum = lnum + 1;\n\t\t    curwin->w_cursor.col = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t    curwin->w_cursor.lnum = new_lnum;\n\t\t    curwin->w_cursor.col = col;\n\t\t    curbuf->b_op_end = curwin->w_cursor;\n\t\t    if (col > 1)\n\t\t\tcurbuf->b_op_end.col = col - 1;\n\t\t}\n\t    }\n\t    else if (y_type == MLINE)\n\t    {\n\t\t// put cursor on first non-blank in first inserted line\n\t\tcurwin->w_cursor.col = 0;\n\t\tif (dir == FORWARD)\n\t\t    ++curwin->w_cursor.lnum;\n\t\tbeginline(BL_WHITE | BL_FIX);\n\t    }\n\t    else\t// put cursor on first inserted character\n\t\tcurwin->w_cursor = new_cursor;\n\t}\n    }\n\n    msgmore(nr_lines);\n    curwin->w_set_curswant = TRUE;\n\nend:\n    if (cmdmod.cmod_flags & CMOD_LOCKMARKS)\n    {\n\tcurbuf->b_op_start = orig_start;\n\tcurbuf->b_op_end = orig_end;\n    }\n    if (allocated)\n\tvim_free(insert_string);\n    if (regname == '=')\n\tvim_free(y_array);\n\n    VIsual_active = FALSE;\n\n    // If the cursor is past the end of the line put it at the end.\n    adjust_cursor_eol();\n}\n\n/*\n * Return the character name of the register with the given number.\n */\n    int\nget_register_name(int num)\n{\n    if (num == -1)\n\treturn '\"';\n    else if (num < 10)\n\treturn num + '0';\n    else if (num == DELETION_REGISTER)\n\treturn '-';\n#ifdef FEAT_CLIPBOARD\n    else if (num == STAR_REGISTER)\n\treturn '*';\n    else if (num == PLUS_REGISTER)\n\treturn '+';\n#endif\n    else\n\treturn num + 'a' - 10;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return the index of the register \"\" points to.\n */\n    int\nget_unname_register()\n{\n    return y_previous == NULL ? -1 : y_previous - &y_regs[0];\n}\n#endif\n\n/*\n * \":dis\" and \":registers\": Display the contents of the yank registers.\n */\n    void\nex_display(exarg_T *eap)\n{\n    int\t\ti, n;\n    long\tj;\n    char_u\t*p;\n    yankreg_T\t*yb;\n    int\t\tname;\n    int\t\tattr;\n    char_u\t*arg = eap->arg;\n    int\t\tclen;\n    int\t\ttype;\n\n    if (arg != NULL && *arg == NUL)\n\targ = NULL;\n    attr = HL_ATTR(HLF_8);\n\n    // Highlight title\n    msg_puts_title(_(\"\\nType Name Content\"));\n    for (i = -1; i < NUM_REGISTERS && !got_int; ++i)\n    {\n\tname = get_register_name(i);\n\tswitch (get_reg_type(name, NULL))\n\t{\n\t    case MLINE: type = 'l'; break;\n\t    case MCHAR: type = 'c'; break;\n\t    default:\ttype = 'b'; break;\n\t}\n\tif (arg != NULL && vim_strchr(arg, name) == NULL\n#ifdef ONE_CLIPBOARD\n\t    // Star register and plus register contain the same thing.\n\t\t&& (name != '*' || vim_strchr(arg, '+') == NULL)\n#endif\n\t\t)\n\t    continue;\t    // did not ask for this register\n\n#ifdef FEAT_CLIPBOARD\n\t// Adjust register name for \"unnamed\" in 'clipboard'.\n\t// When it's a clipboard register, fill it with the current contents\n\t// of the clipboard.\n\tadjust_clip_reg(&name);\n\t(void)may_get_selection(name);\n#endif\n\n\tif (i == -1)\n\t{\n\t    if (y_previous != NULL)\n\t\tyb = y_previous;\n\t    else\n\t\tyb = &(y_regs[0]);\n\t}\n\telse\n\t    yb = &(y_regs[i]);\n\n#ifdef FEAT_EVAL\n\tif (name == MB_TOLOWER(redir_reg)\n\t\t|| (redir_reg == '\"' && yb == y_previous))\n\t    continue;\t    // do not list register being written to, the\n\t\t\t    // pointer can be freed\n#endif\n\n\tif (yb->y_array != NULL)\n\t{\n\t    int do_show = FALSE;\n\n\t    for (j = 0; !do_show && j < yb->y_size; ++j)\n\t\tdo_show = !message_filtered(yb->y_array[j]);\n\n\t    if (do_show || yb->y_size == 0)\n\t    {\n\t\tmsg_putchar('\\n');\n\t\tmsg_puts(\"  \");\n\t\tmsg_putchar(type);\n\t\tmsg_puts(\"  \");\n\t\tmsg_putchar('\"');\n\t\tmsg_putchar(name);\n\t\tmsg_puts(\"   \");\n\n\t\tn = (int)Columns - 11;\n\t\tfor (j = 0; j < yb->y_size && n > 1; ++j)\n\t\t{\n\t\t    if (j)\n\t\t    {\n\t\t\tmsg_puts_attr(\"^J\", attr);\n\t\t\tn -= 2;\n\t\t    }\n\t\t    for (p = yb->y_array[j];\n\t\t\t\t    *p != NUL && (n -= ptr2cells(p)) >= 0; ++p)\n\t\t    {\n\t\t\tclen = (*mb_ptr2len)(p);\n\t\t\tmsg_outtrans_len(p, clen);\n\t\t\tp += clen - 1;\n\t\t    }\n\t\t}\n\t\tif (n > 1 && yb->y_type == MLINE)\n\t\t    msg_puts_attr(\"^J\", attr);\n\t\tout_flush();\t\t    // show one line at a time\n\t    }\n\t    ui_breakcheck();\n\t}\n    }\n\n    // display last inserted text\n    if ((p = get_last_insert()) != NULL\n\t\t  && (arg == NULL || vim_strchr(arg, '.') != NULL) && !got_int\n\t\t\t\t\t\t      && !message_filtered(p))\n    {\n\tmsg_puts(\"\\n  c  \\\".   \");\n\tdis_msg(p, TRUE);\n    }\n\n    // display last command line\n    if (last_cmdline != NULL && (arg == NULL || vim_strchr(arg, ':') != NULL)\n\t\t\t       && !got_int && !message_filtered(last_cmdline))\n    {\n\tmsg_puts(\"\\n  c  \\\":   \");\n\tdis_msg(last_cmdline, FALSE);\n    }\n\n    // display current file name\n    if (curbuf->b_fname != NULL\n\t    && (arg == NULL || vim_strchr(arg, '%') != NULL) && !got_int\n\t\t\t\t\t&& !message_filtered(curbuf->b_fname))\n    {\n\tmsg_puts(\"\\n  c  \\\"%   \");\n\tdis_msg(curbuf->b_fname, FALSE);\n    }\n\n    // display alternate file name\n    if ((arg == NULL || vim_strchr(arg, '%') != NULL) && !got_int)\n    {\n\tchar_u\t    *fname;\n\tlinenr_T    dummy;\n\n\tif (buflist_name_nr(0, &fname, &dummy) != FAIL\n\t\t\t\t\t\t  && !message_filtered(fname))\n\t{\n\t    msg_puts(\"\\n  c  \\\"#   \");\n\t    dis_msg(fname, FALSE);\n\t}\n    }\n\n    // display last search pattern\n    if (last_search_pat() != NULL\n\t\t && (arg == NULL || vim_strchr(arg, '/') != NULL) && !got_int\n\t\t\t\t      && !message_filtered(last_search_pat()))\n    {\n\tmsg_puts(\"\\n  c  \\\"/   \");\n\tdis_msg(last_search_pat(), FALSE);\n    }\n\n#ifdef FEAT_EVAL\n    // display last used expression\n    if (expr_line != NULL && (arg == NULL || vim_strchr(arg, '=') != NULL)\n\t\t\t\t  && !got_int && !message_filtered(expr_line))\n    {\n\tmsg_puts(\"\\n  c  \\\"=   \");\n\tdis_msg(expr_line, FALSE);\n    }\n#endif\n}\n\n/*\n * display a string for do_dis()\n * truncate at end of screen line\n */\n    static void\ndis_msg(\n    char_u\t*p,\n    int\t\tskip_esc)\t    // if TRUE, ignore trailing ESC\n{\n    int\t\tn;\n    int\t\tl;\n\n    n = (int)Columns - 6;\n    while (*p != NUL\n\t    && !(*p == ESC && skip_esc && *(p + 1) == NUL)\n\t    && (n -= ptr2cells(p)) >= 0)\n    {\n\tif (has_mbyte && (l = (*mb_ptr2len)(p)) > 1)\n\t{\n\t    msg_outtrans_len(p, l);\n\t    p += l;\n\t}\n\telse\n\t    msg_outtrans_len(p++, 1);\n    }\n    ui_breakcheck();\n}\n\n#if defined(FEAT_DND) || defined(PROTO)\n/*\n * Replace the contents of the '~' register with str.\n */\n    void\ndnd_yank_drag_data(char_u *str, long len)\n{\n    yankreg_T *curr;\n\n    curr = y_current;\n    y_current = &y_regs[TILDE_REGISTER];\n    free_yank_all();\n    str_to_reg(y_current, MCHAR, str, len, 0L, FALSE);\n    y_current = curr;\n}\n#endif\n\n\n/*\n * Return the type of a register.\n * Used for getregtype()\n * Returns MAUTO for error.\n */\n    char_u\nget_reg_type(int regname, long *reglen)\n{\n    switch (regname)\n    {\n\tcase '%':\t\t// file name\n\tcase '#':\t\t// alternate file name\n\tcase '=':\t\t// expression\n\tcase ':':\t\t// last command line\n\tcase '/':\t\t// last search-pattern\n\tcase '.':\t\t// last inserted text\n# ifdef FEAT_SEARCHPATH\n\tcase Ctrl_F:\t\t// Filename under cursor\n\tcase Ctrl_P:\t\t// Path under cursor, expand via \"path\"\n# endif\n\tcase Ctrl_W:\t\t// word under cursor\n\tcase Ctrl_A:\t\t// WORD (mnemonic All) under cursor\n\tcase '_':\t\t// black hole: always empty\n\t    return MCHAR;\n    }\n\n# ifdef FEAT_CLIPBOARD\n    regname = may_get_selection(regname);\n# endif\n\n    if (regname != NUL && !valid_yank_reg(regname, FALSE))\n\treturn MAUTO;\n\n    get_yank_register(regname, FALSE);\n\n    if (y_current->y_array != NULL)\n    {\n\tif (reglen != NULL && y_current->y_type == MBLOCK)\n\t    *reglen = y_current->y_width;\n\treturn y_current->y_type;\n    }\n    return MAUTO;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * When \"flags\" has GREG_LIST return a list with text \"s\".\n * Otherwise just return \"s\".\n */\n    static char_u *\ngetreg_wrap_one_line(char_u *s, int flags)\n{\n    if (flags & GREG_LIST)\n    {\n\tlist_T *list = list_alloc();\n\n\tif (list != NULL)\n\t{\n\t    if (list_append_string(list, NULL, -1) == FAIL)\n\t    {\n\t\tlist_free(list);\n\t\treturn NULL;\n\t    }\n\t    list->lv_first->li_tv.vval.v_string = s;\n\t}\n\treturn (char_u *)list;\n    }\n    return s;\n}\n\n/*\n * Return the contents of a register as a single allocated string or as a list.\n * Used for \"@r\" in expressions and for getreg().\n * Returns NULL for error.\n * Flags:\n *\tGREG_NO_EXPR\tDo not allow expression register\n *\tGREG_EXPR_SRC\tFor the expression register: return expression itself,\n *\t\t\tnot the result of its evaluation.\n *\tGREG_LIST\tReturn a list of lines instead of a single string.\n */\n    char_u *\nget_reg_contents(int regname, int flags)\n{\n    long\ti;\n    char_u\t*retval;\n    int\t\tallocated;\n    long\tlen;\n\n    // Don't allow using an expression register inside an expression\n    if (regname == '=')\n    {\n\tif (flags & GREG_NO_EXPR)\n\t    return NULL;\n\tif (flags & GREG_EXPR_SRC)\n\t    return getreg_wrap_one_line(get_expr_line_src(), flags);\n\treturn getreg_wrap_one_line(get_expr_line(), flags);\n    }\n\n    if (regname == '@')\t    // \"@@\" is used for unnamed register\n\tregname = '\"';\n\n    // check for valid regname\n    if (regname != NUL && !valid_yank_reg(regname, FALSE))\n\treturn NULL;\n\n# ifdef FEAT_CLIPBOARD\n    regname = may_get_selection(regname);\n# endif\n\n    if (get_spec_reg(regname, &retval, &allocated, FALSE))\n    {\n\tif (retval == NULL)\n\t    return NULL;\n\tif (allocated)\n\t    return getreg_wrap_one_line(retval, flags);\n\treturn getreg_wrap_one_line(vim_strsave(retval), flags);\n    }\n\n    get_yank_register(regname, FALSE);\n    if (y_current->y_array == NULL)\n\treturn NULL;\n\n    if (flags & GREG_LIST)\n    {\n\tlist_T\t*list = list_alloc();\n\tint\terror = FALSE;\n\n\tif (list == NULL)\n\t    return NULL;\n\tfor (i = 0; i < y_current->y_size; ++i)\n\t    if (list_append_string(list, y_current->y_array[i], -1) == FAIL)\n\t\terror = TRUE;\n\tif (error)\n\t{\n\t    list_free(list);\n\t    return NULL;\n\t}\n\treturn (char_u *)list;\n    }\n\n    // Compute length of resulting string.\n    len = 0;\n    for (i = 0; i < y_current->y_size; ++i)\n    {\n\tlen += (long)STRLEN(y_current->y_array[i]);\n\t// Insert a newline between lines and after last line if\n\t// y_type is MLINE.\n\tif (y_current->y_type == MLINE || i < y_current->y_size - 1)\n\t    ++len;\n    }\n\n    retval = alloc(len + 1);\n\n    // Copy the lines of the yank register into the string.\n    if (retval != NULL)\n    {\n\tlen = 0;\n\tfor (i = 0; i < y_current->y_size; ++i)\n\t{\n\t    STRCPY(retval + len, y_current->y_array[i]);\n\t    len += (long)STRLEN(retval + len);\n\n\t    // Insert a NL between lines and after the last line if y_type is\n\t    // MLINE.\n\t    if (y_current->y_type == MLINE || i < y_current->y_size - 1)\n\t\tretval[len++] = '\\n';\n\t}\n\tretval[len] = NUL;\n    }\n\n    return retval;\n}\n\n    static int\ninit_write_reg(\n    int\t\tname,\n    yankreg_T\t**old_y_previous,\n    yankreg_T\t**old_y_current,\n    int\t\tmust_append,\n    int\t\t*yank_type UNUSED)\n{\n    if (!valid_yank_reg(name, TRUE))\t    // check for valid reg name\n    {\n\temsg_invreg(name);\n\treturn FAIL;\n    }\n\n    // Don't want to change the current (unnamed) register\n    *old_y_previous = y_previous;\n    *old_y_current = y_current;\n\n    get_yank_register(name, TRUE);\n    if (!y_append && !must_append)\n\tfree_yank_all();\n    return OK;\n}\n\n    static void\nfinish_write_reg(\n    int\t\tname,\n    yankreg_T\t*old_y_previous,\n    yankreg_T\t*old_y_current)\n{\n# ifdef FEAT_CLIPBOARD\n    // Send text of clipboard register to the clipboard.\n    may_set_selection();\n# endif\n\n    // ':let @\" = \"val\"' should change the meaning of the \"\" register\n    if (name != '\"')\n\ty_previous = old_y_previous;\n    y_current = old_y_current;\n}\n\n/*\n * Store string \"str\" in register \"name\".\n * \"maxlen\" is the maximum number of bytes to use, -1 for all bytes.\n * If \"must_append\" is TRUE, always append to the register.  Otherwise append\n * if \"name\" is an uppercase letter.\n * Note: \"maxlen\" and \"must_append\" don't work for the \"/\" register.\n * Careful: 'str' is modified, you may have to use a copy!\n * If \"str\" ends in '\\n' or '\\r', use linewise, otherwise use characterwise.\n */\n    void\nwrite_reg_contents(\n    int\t\tname,\n    char_u\t*str,\n    int\t\tmaxlen,\n    int\t\tmust_append)\n{\n    write_reg_contents_ex(name, str, maxlen, must_append, MAUTO, 0L);\n}\n\n    void\nwrite_reg_contents_lst(\n    int\t\tname,\n    char_u\t**strings,\n    int\t\tmaxlen UNUSED,\n    int\t\tmust_append,\n    int\t\tyank_type,\n    long\tblock_len)\n{\n    yankreg_T  *old_y_previous, *old_y_current;\n\n    if (name == '/' || name == '=')\n    {\n\tchar_u\t*s;\n\n\tif (strings[0] == NULL)\n\t    s = (char_u *)\"\";\n\telse if (strings[1] != NULL)\n\t{\n\t    emsg(_(e_search_pattern_and_expression_register_may_not_contain_two_or_more_lines));\n\t    return;\n\t}\n\telse\n\t    s = strings[0];\n\twrite_reg_contents_ex(name, s, -1, must_append, yank_type, block_len);\n\treturn;\n    }\n\n    if (name == '_')\t    // black hole: nothing to do\n\treturn;\n\n    if (init_write_reg(name, &old_y_previous, &old_y_current, must_append,\n\t\t&yank_type) == FAIL)\n\treturn;\n\n    str_to_reg(y_current, yank_type, (char_u *)strings, -1, block_len, TRUE);\n\n    finish_write_reg(name, old_y_previous, old_y_current);\n}\n\n    void\nwrite_reg_contents_ex(\n    int\t\tname,\n    char_u\t*str,\n    int\t\tmaxlen,\n    int\t\tmust_append,\n    int\t\tyank_type,\n    long\tblock_len)\n{\n    yankreg_T\t*old_y_previous, *old_y_current;\n    long\tlen;\n\n    if (maxlen >= 0)\n\tlen = maxlen;\n    else\n\tlen = (long)STRLEN(str);\n\n    // Special case: '/' search pattern\n    if (name == '/')\n    {\n\tset_last_search_pat(str, RE_SEARCH, TRUE, TRUE);\n\treturn;\n    }\n\n    if (name == '#')\n    {\n\tbuf_T\t*buf;\n\n\tif (VIM_ISDIGIT(*str))\n\t{\n\t    int\tnum = atoi((char *)str);\n\n\t    buf = buflist_findnr(num);\n\t    if (buf == NULL)\n\t\tsemsg(_(e_buffer_nr_does_not_exist), (long)num);\n\t}\n\telse\n\t    buf = buflist_findnr(buflist_findpat(str, str + STRLEN(str),\n\t\t\t\t\t\t\t TRUE, FALSE, FALSE));\n\tif (buf == NULL)\n\t    return;\n\tcurwin->w_alt_fnum = buf->b_fnum;\n\treturn;\n    }\n\n    if (name == '=')\n    {\n\tchar_u\t    *p, *s;\n\n\tp = vim_strnsave(str, len);\n\tif (p == NULL)\n\t    return;\n\tif (must_append && expr_line != NULL)\n\t{\n\t    s = concat_str(expr_line, p);\n\t    vim_free(p);\n\t    p = s;\n\t}\n\tset_expr_line(p, NULL);\n\treturn;\n    }\n\n    if (name == '_')\t    // black hole: nothing to do\n\treturn;\n\n    if (init_write_reg(name, &old_y_previous, &old_y_current, must_append,\n\t\t&yank_type) == FAIL)\n\treturn;\n\n    str_to_reg(y_current, yank_type, str, len, block_len, FALSE);\n\n    finish_write_reg(name, old_y_previous, old_y_current);\n}\n#endif\t// FEAT_EVAL\n\n#if defined(FEAT_CLIPBOARD) || defined(FEAT_EVAL)\n/*\n * Put a string into a register.  When the register is not empty, the string\n * is appended.\n */\n    void\nstr_to_reg(\n    yankreg_T\t*y_ptr,\t\t// pointer to yank register\n    int\t\tyank_type,\t// MCHAR, MLINE, MBLOCK, MAUTO\n    char_u\t*str,\t\t// string to put in register\n    long\tlen,\t\t// length of string\n    long\tblocklen,\t// width of Visual block\n    int\t\tstr_list)\t// TRUE if str is char_u **\n{\n    int\t\ttype;\t\t\t// MCHAR, MLINE or MBLOCK\n    int\t\tlnum;\n    long\tstart;\n    long\ti;\n    int\t\textra;\n    int\t\tnewlines;\t\t// number of lines added\n    int\t\textraline = 0;\t\t// extra line at the end\n    int\t\tappend = FALSE;\t\t// append to last line in register\n    char_u\t*s;\n    char_u\t**ss;\n    char_u\t**pp;\n    long\tmaxlen;\n\n    if (y_ptr->y_array == NULL)\t\t// NULL means empty register\n\ty_ptr->y_size = 0;\n\n    if (yank_type == MAUTO)\n\ttype = ((str_list || (len > 0 && (str[len - 1] == NL\n\t\t\t\t\t    || str[len - 1] == CAR)))\n\t\t\t\t\t\t\t     ? MLINE : MCHAR);\n    else\n\ttype = yank_type;\n\n    // Count the number of lines within the string\n    newlines = 0;\n    if (str_list)\n    {\n\tfor (ss = (char_u **) str; *ss != NULL; ++ss)\n\t    ++newlines;\n    }\n    else\n    {\n\tfor (i = 0; i < len; i++)\n\t    if (str[i] == '\\n')\n\t\t++newlines;\n\tif (type == MCHAR || len == 0 || str[len - 1] != '\\n')\n\t{\n\t    extraline = 1;\n\t    ++newlines;\t// count extra newline at the end\n\t}\n\tif (y_ptr->y_size > 0 && y_ptr->y_type == MCHAR)\n\t{\n\t    append = TRUE;\n\t    --newlines;\t// uncount newline when appending first line\n\t}\n    }\n\n    // Without any lines make the register empty.\n    if (y_ptr->y_size + newlines == 0)\n    {\n\tVIM_CLEAR(y_ptr->y_array);\n\treturn;\n    }\n\n    // Allocate an array to hold the pointers to the new register lines.\n    // If the register was not empty, move the existing lines to the new array.\n    pp = lalloc_clear((y_ptr->y_size + newlines) * sizeof(char_u *), TRUE);\n    if (pp == NULL)\t// out of memory\n\treturn;\n    for (lnum = 0; lnum < y_ptr->y_size; ++lnum)\n\tpp[lnum] = y_ptr->y_array[lnum];\n    vim_free(y_ptr->y_array);\n    y_ptr->y_array = pp;\n    maxlen = 0;\n\n    // Find the end of each line and save it into the array.\n    if (str_list)\n    {\n\tfor (ss = (char_u **) str; *ss != NULL; ++ss, ++lnum)\n\t{\n\t    pp[lnum] = vim_strsave(*ss);\n\t    if (type == MBLOCK)\n\t    {\n\t\tint charlen = mb_string2cells(*ss, -1);\n\n\t\tif (charlen > maxlen)\n\t\t    maxlen = charlen;\n\t    }\n\t}\n    }\n    else\n    {\n\tfor (start = 0; start < len + extraline; start += i + 1)\n\t{\n\t    int charlen = 0;\n\n\t    for (i = start; i < len; ++i)\t// find the end of the line\n\t    {\n\t\tif (str[i] == '\\n')\n\t\t    break;\n\t\tif (type == MBLOCK)\n\t\t    charlen += mb_ptr2cells_len(str + i, len - i);\n\t    }\n\t    i -= start;\t\t\t// i is now length of line\n\t    if (charlen > maxlen)\n\t\tmaxlen = charlen;\n\t    if (append)\n\t    {\n\t\t--lnum;\n\t\textra = (int)STRLEN(y_ptr->y_array[lnum]);\n\t    }\n\t    else\n\t\textra = 0;\n\t    s = alloc(i + extra + 1);\n\t    if (s == NULL)\n\t\tbreak;\n\t    if (extra)\n\t\tmch_memmove(s, y_ptr->y_array[lnum], (size_t)extra);\n\t    if (append)\n\t\tvim_free(y_ptr->y_array[lnum]);\n\t    if (i > 0)\n\t\tmch_memmove(s + extra, str + start, (size_t)i);\n\t    extra += i;\n\t    s[extra] = NUL;\n\t    y_ptr->y_array[lnum++] = s;\n\t    while (--extra >= 0)\n\t    {\n\t\tif (*s == NUL)\n\t\t    *s = '\\n';\t    // replace NUL with newline\n\t\t++s;\n\t    }\n\t    append = FALSE;\t\t    // only first line is appended\n\t}\n    }\n    y_ptr->y_type = type;\n    y_ptr->y_size = lnum;\n    if (type == MBLOCK)\n\ty_ptr->y_width = (blocklen < 0 ? maxlen - 1 : blocklen);\n    else\n\ty_ptr->y_width = 0;\n# ifdef FEAT_VIMINFO\n    y_ptr->y_time_set = vim_time();\n# endif\n}\n#endif // FEAT_CLIPBOARD || FEAT_EVAL || PROTO\n", "\" Tests for put commands, e.g. \":put\", \"p\", \"gp\", \"P\", \"gP\", etc.\n\nsource check.vim\n\nfunc Test_put_block()\n  new\n  call feedkeys(\"i\\<C-V>u2500\\<CR>x\\<ESC>\", 'x')\n  call feedkeys(\"\\<C-V>y\", 'x')\n  call feedkeys(\"gg0p\", 'x')\n  call assert_equal(\"\\u2500x\", getline(1))\n  bwipe!\nendfunc\n\nfunc Test_put_char_block()\n  new\n  call setline(1, ['Line 1', 'Line 2'])\n  f Xfile_put\n  \" visually select both lines and put the cursor at the top of the visual\n  \" selection and then put the buffer name over it\n  exe \"norm! G0\\<c-v>ke\\\"%p\"\n  call assert_equal(['Xfile_put 1', 'Xfile_put 2'], getline(1,2))\n  bw!\nendfunc\n\nfunc Test_put_char_block2()\n  new\n  call setreg('a', ' one ', 'v')\n  call setline(1, ['Line 1', '', 'Line 3', ''])\n  \" visually select the first 3 lines and put register a over it\n  exe \"norm! ggl\\<c-v>2j2l\\\"ap\"\n  call assert_equal(['L one  1', '', 'L one  3', ''], getline(1, 4))\n  \" clean up\n  bw!\nendfunc\n\nfunc Test_put_lines()\n  new\n  let a = [ getreg('a'), getregtype('a') ]\n  call setline(1, ['Line 1', 'Line2', 'Line 3', ''])\n  exe 'norm! gg\"add\"AddG\"\"p'\n  call assert_equal(['Line 3', '', 'Line 1', 'Line2'], getline(1, '$'))\n  \" clean up\n  bw!\n  eval a[0]->setreg('a', a[1])\nendfunc\n\nfunc Test_put_expr()\n  new\n  call setline(1, repeat(['A'], 6))\n  exec \"1norm! \\\"=line('.')\\<cr>p\"\n  norm! j0.\n  norm! j0.\n  exec \"4norm! \\\"=\\<cr>P\"\n  norm! j0.\n  norm! j0.\n  call assert_equal(['A1','A2','A3','4A','5A','6A'], getline(1, '$'))\n  bw!\nendfunc\n\nfunc Test_put_fails_when_nomodifiable()\n  new\n  setlocal nomodifiable\n\n  normal! yy\n  call assert_fails(':put', 'E21:')\n  call assert_fails(':put!', 'E21:')\n  call assert_fails(':normal! p', 'E21:')\n  call assert_fails(':normal! gp', 'E21:')\n  call assert_fails(':normal! P', 'E21:')\n  call assert_fails(':normal! gP', 'E21:')\n\n  if has('mouse')\n    set mouse=n\n    call assert_fails('execute \"normal! \\<MiddleMouse>\"', 'E21:')\n    set mouse&\n  endif\n\n  bwipeout!\nendfunc\n\n\" A bug was discovered where the Normal mode put commands (e.g., \"p\") would\n\" output duplicate error messages when invoked in a non-modifiable buffer.\nfunc Test_put_p_errmsg_nodup()\n  new\n  setlocal nomodifiable\n\n  normal! yy\n\n  func Capture_p_error()\n    redir => s:p_err\n    normal! p\n    redir END\n  endfunc\n\n  silent! call Capture_p_error()\n\n  \" Error message output within a function should be three lines (the function\n  \" name, the line number, and the error message).\n  call assert_equal(3, count(s:p_err, \"\\n\"))\n\n  delfunction Capture_p_error\n  bwipeout!\nendfunc\n\nfunc Test_put_p_indent_visual()\n  new\n  call setline(1, ['select this text', 'select that text'])\n  \" yank \"that\" from the second line\n  normal 2Gwvey\n  \" select \"this\" in the first line and put\n  normal k0wve[p\n  call assert_equal('select that text', getline(1))\n  call assert_equal('select that text', getline(2))\n  bwipe!\nendfunc\n\n\" Test for deleting all the contents of a buffer with a put\nfunc Test_put_visual_delete_all_lines()\n  new\n  call setline(1, ['one', 'two', 'three'])\n  let @r = ''\n  normal! VG\"rgp\n  call assert_equal(1, line('$'))\n  close!\nendfunc\n\nfunc Test_gp_with_count_leaves_cursor_at_end()\n  new\n  call setline(1, '<---->')\n  call setreg('@', \"foo\\nbar\", 'c')\n  normal 1G3|3gp\n  call assert_equal([0, 4, 4, 0], getpos(\".\"))\n  call assert_equal(['<--foo', 'barfoo', 'barfoo', 'bar-->'], getline(1, '$'))\n  call assert_equal([0, 4, 3, 0], getpos(\"']\"))\n\n  bwipe!\nendfunc\n\nfunc Test_p_with_count_leaves_mark_at_end()\n  new\n  call setline(1, '<---->')\n  call setreg('@', \"start\\nend\", 'c')\n  normal 1G3|3p\n  call assert_equal([0, 1, 4, 0], getpos(\".\"))\n  call assert_equal(['<--start', 'endstart', 'endstart', 'end-->'], getline(1, '$'))\n  call assert_equal([0, 4, 3, 0], getpos(\"']\"))\n\n  bwipe!\nendfunc\n\nfunc Test_very_large_count()\n  new\n  \" total put-length (21474837 * 100) brings 32 bit int overflow\n  let @\" = repeat('x', 100)\n  call assert_fails('norm 21474837p', 'E1240:')\n  bwipe!\nendfunc\n\nfunc Test_very_large_count_64bit()\n  if v:sizeoflong < 8\n    throw 'Skipped: only works with 64 bit long ints'\n  endif\n\n  new\n  let @\" = repeat('x', 100)\n  call assert_fails('norm 999999999p', 'E1240:')\n  bwipe!\nendfunc\n\nfunc Test_very_large_count_block()\n  new\n  \" total put-length (21474837 * 100) brings 32 bit int overflow\n  call setline(1, repeat('x', 100))\n  exe \"norm \\<C-V>99ly\"\n  call assert_fails('norm 21474837p', 'E1240:')\n  bwipe!\nendfunc\n\nfunc Test_very_large_count_block_64bit()\n  if v:sizeoflong < 8\n    throw 'Skipped: only works with 64 bit long ints'\n  endif\n\n  new\n  call setline(1, repeat('x', 100))\n  exe \"norm \\<C-V>$y\"\n  call assert_fails('norm 999999999p', 'E1240:')\n  bwipe!\nendfunc\n\nfunc Test_put_above_first_line()\n  new\n  let @\" = 'text'\n  silent! normal 0o00\n  0put\n  call assert_equal('text', getline(1))\n  bwipe!\nendfunc\n\nfunc Test_multibyte_op_end_mark()\n  new\n  call setline(1, '\u0442\u0435\u0441\u0442')\n  normal viwdp\n  call assert_equal([0, 1, 7, 0], getpos(\"'>\"))\n  call assert_equal([0, 1, 7, 0], getpos(\"']\"))\n\n  normal Vyp\n  call assert_equal([0, 1, v:maxcol, 0], getpos(\"'>\"))\n  call assert_equal([0, 2, 7, 0], getpos(\"']\"))\n  bwipe!\nendfunc\n\n\" this was putting a mark before the start of a line\nfunc Test_put_empty_register()\n  new\n  norm yy\n  norm [Pi00\u0014\u0014\u0003ggv)s0\n  sil! norm [P\n  bwipe!\nendfunc\n\n\" this was putting the end mark after the end of the line\nfunc Test_put_visual_mode()\n  edit! SomeNewBuffer\n  set selection=exclusive\n  exe \"norm o\\t\"\n  m0\n  sil! norm \u0011\rp\u0011\rp\n\n  bwipe!\n  set selection&\nendfunc\n\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_BIG)\n    msg_puts(_(\"\\nBig version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#elif defined(FEAT_SMALL)\n    msg_puts(_(\"\\nSmall version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "filenames": ["src/register.c", "src/testdir/test_put.vim", "src/version.c"], "buggy_code_start_loc": [1920, 221, 737], "buggy_code_end_loc": [1920, 221, 737], "fixing_code_start_loc": [1921, 222, 738], "fixing_code_end_loc": [1923, 236, 740], "type": "CWE-122", "message": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.", "other": {"cve": {"id": "CVE-2022-2264", "sourceIdentifier": "security@huntr.dev", "published": "2022-07-01T11:15:07.833", "lastModified": "2023-05-03T12:15:51.663", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0."}, {"lang": "es", "value": "Un Desbordamiento de B\u00fafer en la Regi\u00f3n Heap de la Memoria en el repositorio GitHub vim/vim versiones anteriores a 9.0"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-122"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndExcluding": "9.0.0011", "matchCriteriaId": "03E44ABF-6AA7-4EF2-A041-FC491CC8BFBE"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}]}]}], "references": [{"url": "https://github.com/vim/vim/commit/d25f003342aca9889067f2e839963dfeccf1fe05", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/2241c773-02c9-4708-b63e-54aef99afa6c", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/43Y3VJPOTTY3NTREDIFUPITM2POG4ZLP/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/UXPO5EHDV6J4B27E65DOQGZFELUFPRSK/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202208-32", "source": "security@huntr.dev", "tags": ["Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202305-16", "source": "security@huntr.dev"}]}, "github_commit_url": "https://github.com/vim/vim/commit/d25f003342aca9889067f2e839963dfeccf1fe05"}}