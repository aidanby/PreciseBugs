{"buggy_code": ["/* radare - LGPL - Copyright 2017 - pancake, cgvwzq */\n\n// http://webassembly.org/docs/binary-encoding/#module-structure\n\n#include <stdio.h>\n#include <string.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"../../bin/format/wasm/wasm.h\"\n\ntypedef enum {\n\t// Control flow operators\n\tWASM_OP_TRAP = 0x00,\n\tWASM_OP_NOP,\n\tWASM_OP_BLOCK,\n\tWASM_OP_LOOP,\n\tWASM_OP_IF,\n\tWASM_OP_ELSE,\n\tWASM_OP_END = 0x0b,\n\tWASM_OP_BR,\n\tWASM_OP_BRIF,\n\tWASM_OP_BRTABLE,\n\tWASM_OP_RETURN,\n\n\t// Call operators\n\tWASM_OP_CALL = 0x10,\n\tWASM_OP_CALLINDIRECT,\n\n\t// Parametric operators\n\tWASM_OP_DROP = 0x1a,\n\tWASM_OP_SELECT,\n\n\t// Variable access\n\tWASM_OP_GETLOCAL = 0x20,\n\tWASM_OP_SETLOCAL,\n\tWASM_OP_TEELOCAL,\n\tWASM_OP_GETGLOBAL,\n\tWASM_OP_SETGLOBAL,\n\n\t// Memory-related operators\n\tWASM_OP_I32LOAD = 0x28,\n\tWASM_OP_I64LOAD,\n\tWASM_OP_F32LOAD,\n\tWASM_OP_F64LOAD,\n\tWASM_OP_I32LOAD8S,\n\tWASM_OP_I32LOAD8U,\n\tWASM_OP_I32LOAD16S,\n\tWASM_OP_I32LOAD16U,\n\tWASM_OP_I64LOAD8S,\n\tWASM_OP_I64LOAD8U,\n\tWASM_OP_I64LOAD16S,\n\tWASM_OP_I64LOAD16U,\n\tWASM_OP_I64LOAD32S,\n\tWASM_OP_I64LOAD32U,\n\tWASM_OP_I32STORE,\n\tWASM_OP_I64STORE,\n\tWASM_OP_F32STORE,\n\tWASM_OP_F64STORE,\n\tWASM_OP_I32STORE8,\n\tWASM_OP_I32STORE16,\n\tWASM_OP_I64STORE8,\n\tWASM_OP_I64STORE16,\n\tWASM_OP_I64STORE32,\n\tWASM_OP_CURRENTMEMORY,\n\tWASM_OP_GROWMEMORY,\n\n\t// Constants\n\tWASM_OP_I32CONST,\n\tWASM_OP_I64CONST,\n\tWASM_OP_F32CONST,\n\tWASM_OP_F64CONST,\n\n\t// Comparison operators\n\tWASM_OP_I32EQZ,\n\tWASM_OP_I32EQ,\n\tWASM_OP_I32NE,\n\tWASM_OP_I32LTS,\n\tWASM_OP_I32LTU,\n\tWASM_OP_I32GTS,\n\tWASM_OP_I32GTU,\n\tWASM_OP_I32LES,\n\tWASM_OP_I32LEU,\n\tWASM_OP_I32GES,\n\tWASM_OP_I32GEU,\n\tWASM_OP_I64EQZ,\n\tWASM_OP_I64EQ,\n\tWASM_OP_I64NE,\n\tWASM_OP_I64LTS,\n\tWASM_OP_I64LTU,\n\tWASM_OP_I64GTS,\n\tWASM_OP_I64GTU,\n\tWASM_OP_I64LES,\n\tWASM_OP_I64LEU,\n\tWASM_OP_I64GES,\n\tWASM_OP_I64GEU,\n\tWASM_OP_F32EQ,\n\tWASM_OP_F32NE,\n\tWASM_OP_F32LT,\n\tWASM_OP_F32GT,\n\tWASM_OP_F32LE,\n\tWASM_OP_F32GE,\n\tWASM_OP_F64EQ,\n\tWASM_OP_F64NE,\n\tWASM_OP_F64LT,\n\tWASM_OP_F64GT,\n\tWASM_OP_F64LE,\n\tWASM_OP_F64GE,\n\n\t// Numeric operators\n\tWASM_OP_I32CLZ,\n\tWASM_OP_I32CTZ,\n\tWASM_OP_I32POPCNT,\n\tWASM_OP_I32ADD,\n\tWASM_OP_I32SUB,\n\tWASM_OP_I32MUL,\n\tWASM_OP_I32DIVS,\n\tWASM_OP_I32DIVU,\n\tWASM_OP_I32REMS,\n\tWASM_OP_I32REMU,\n\tWASM_OP_I32AND,\n\tWASM_OP_I32OR,\n\tWASM_OP_I32XOR,\n\tWASM_OP_I32SHL,\n\tWASM_OP_I32SHRS,\n\tWASM_OP_I32SHRU,\n\tWASM_OP_I32ROTL,\n\tWASM_OP_I32ROTR,\n\tWASM_OP_I64CLZ,\n\tWASM_OP_I64CTZ,\n\tWASM_OP_I64POPCNT,\n\tWASM_OP_I64ADD,\n\tWASM_OP_I64SUB,\n\tWASM_OP_I64MUL,\n\tWASM_OP_I64DIVS,\n\tWASM_OP_I64DIVU,\n\tWASM_OP_I64REMS,\n\tWASM_OP_I64REMU,\n\tWASM_OP_I64AND,\n\tWASM_OP_I64OR,\n\tWASM_OP_I64XOR,\n\tWASM_OP_I64SHL,\n\tWASM_OP_I64SHRS,\n\tWASM_OP_I64SHRU,\n\tWASM_OP_I64ROTL,\n\tWASM_OP_I64ROTR,\n\tWASM_OP_F32ABS,\n\tWASM_OP_F32NEG,\n\tWASM_OP_F32CEIL,\n\tWASM_OP_F32FLOOR,\n\tWASM_OP_F32TRUNC,\n\tWASM_OP_F32NEAREST,\n\tWASM_OP_F32SQRT,\n\tWASM_OP_F32ADD,\n\tWASM_OP_F32SUB,\n\tWASM_OP_F32MUL,\n\tWASM_OP_F32DIV,\n\tWASM_OP_F32MIN,\n\tWASM_OP_F32MAX,\n\tWASM_OP_F32COPYSIGN,\n\tWASM_OP_F64ABS,\n\tWASM_OP_F64NEG,\n\tWASM_OP_F64CEIL,\n\tWASM_OP_F64FLOOR,\n\tWASM_OP_F64TRUNC,\n\tWASM_OP_F64NEAREST,\n\tWASM_OP_F64SQRT,\n\tWASM_OP_F64ADD,\n\tWASM_OP_F64SUB,\n\tWASM_OP_F64MUL,\n\tWASM_OP_F64DIV,\n\tWASM_OP_F64MIN,\n\tWASM_OP_F64MAX,\n\tWASM_OP_F64COPYSIGN,\n\n\t// Conversions\n\tWASM_OP_I32WRAPI64,\n\tWASM_OP_I32TRUNCSF32,\n\tWASM_OP_I32TRUNCUF32,\n\tWASM_OP_I32TRUNCSF64,\n\tWASM_OP_I32TRUNCUF64,\n\tWASM_OP_I64EXTENDSI32,\n\tWASM_OP_I64EXTENDUI32,\n\tWASM_OP_I64TRUNCSF32,\n\tWASM_OP_I64TRUNCUF32,\n\tWASM_OP_I64TRUNCSF64,\n\tWASM_OP_I64TRUNCUF64,\n\tWASM_OP_F32CONVERTSI32,\n\tWASM_OP_F32CONVERTUI32,\n\tWASM_OP_F32CONVERTSI64,\n\tWASM_OP_F32CONVERTUI64,\n\tWASM_OP_F32DEMOTEF64,\n\tWASM_OP_F64CONVERTSI32,\n\tWASM_OP_F64CONVERTUI32,\n\tWASM_OP_F64CONVERTSI64,\n\tWASM_OP_F64CONVERTUI64,\n\tWASM_OP_F64PROMOTEF32,\n\n\t// Reinterpretations\n\tWASM_OP_I32REINTERPRETF32,\n\tWASM_OP_I64REINTERPRETF64,\n\tWASM_OP_F32REINTERPRETI32,\n\tWASM_OP_F64REINTERPRETI64,\n\n\t// Extensions\n\t// ...\n} WasmOpCodes;\n\ntypedef struct {\n\tWasmOpCodes op;\n\tint len;\n\tchar txt[R_ASM_BUFSIZE];\n} WasmOp;\n\ntypedef struct {\n\tconst char *txt;\n\tsize_t min, max;\n} WasmOpDef;\n\nstatic WasmOpDef opcodes[256] = {\n\t[WASM_OP_TRAP] = { \"trap\", 1, 1 },\n\t[WASM_OP_NOP] = { \"nop\", 1, 1 },\n\t[WASM_OP_BLOCK] = { \"block\", 2, 2 },\n\t[WASM_OP_LOOP] = { \"loop\", 2, 2 },\n\t[WASM_OP_IF] = { \"if\", 2, 2 },\n\t[WASM_OP_ELSE] = { \"else\", 1, 1 },\n\t[WASM_OP_END] = { \"end\", 1, 1 },\n\t[WASM_OP_BR] = { \"br\", 2, 2 },\n\t[WASM_OP_BRIF] = { \"br_if\", 2, 2 },\n\t[WASM_OP_BRTABLE] = { \"brtable\", 3, 0 },\n\t[WASM_OP_RETURN] = { \"return\", 1, 1 },\n\t[WASM_OP_CALL] = { \"call\" , 2, 2 },\n\t[WASM_OP_CALLINDIRECT] = { \"call_indirect\", 3, 3 },\n\t[WASM_OP_DROP] = { \"drop\", 1, 1 },\n\t[WASM_OP_SELECT] = { \"select\", 1, 1 },\n\t[WASM_OP_GETLOCAL] = { \"get_local\", 2, 2 },\n\t[WASM_OP_SETLOCAL] = { \"set_local\", 2, 2 },\n\t[WASM_OP_TEELOCAL] = { \"tee_local\", 2, 2 },\n\t[WASM_OP_GETGLOBAL] = { \"get_global\", 2, 2 },\n\t[WASM_OP_SETGLOBAL] = { \"set_global\", 2, 2 },\n\t[WASM_OP_I32LOAD] = { \"i32.load\", 3, 3 },\n\t[WASM_OP_I64LOAD] = { \"i64.load\", 3, 3 },\n\t[WASM_OP_F32LOAD] = { \"f32.load\", 3, 3 },\n\t[WASM_OP_F64LOAD] = { \"f64.load\", 3, 3 },\n\t[WASM_OP_I32LOAD8S] = { \"i32.load8_s\", 3, 3 },\n\t[WASM_OP_I32LOAD8U] = { \"i32.load8_u\", 3, 3 },\n\t[WASM_OP_I32LOAD16S] = { \"i32.load16_s\", 3, 3 },\n\t[WASM_OP_I32LOAD16U] = { \"i32.load_16_u\", 3, 3 },\n\t[WASM_OP_I64LOAD8S] = { \"i64.load8_s\", 3, 3 },\n\t[WASM_OP_I64LOAD8U] = { \"i64.load8_u\", 3, 3 },\n\t[WASM_OP_I64LOAD16S] = { \"i64.load16_s\", 3, 3 },\n\t[WASM_OP_I64LOAD16U] = { \"i64.load16_u\", 3, 3 },\n\t[WASM_OP_I64LOAD32S] = { \"i64.load32_s\", 3, 3 },\n\t[WASM_OP_I64LOAD32U] = { \"i64.load32_u\", 3, 3 },\n\t[WASM_OP_I32STORE] = { \"i32.store\", 3, 3 },\n\t[WASM_OP_I64STORE] = { \"i64.store\", 3, 3 },\n\t[WASM_OP_F32STORE] = { \"f32.store\", 3, 3 },\n\t[WASM_OP_F64STORE] = { \"f64.store\", 3, 3 },\n\t[WASM_OP_I32STORE8] = { \"i32.store8\", 3, 3 },\n\t[WASM_OP_I32STORE16] = { \"i32.store16\", 3, 3 },\n\t[WASM_OP_I64STORE8] = { \"i64.store8\", 3, 3 },\n\t[WASM_OP_I64STORE16] = { \"i64.store16\", 3, 3 },\n\t[WASM_OP_I64STORE32] = { \"i64.store32\", 3, 3 },\n\t[WASM_OP_CURRENTMEMORY] = { \"current_memory\", 2, 2 },\n\t[WASM_OP_GROWMEMORY] = { \"grow_memory\", 2, 2 },\n\t[WASM_OP_I32CONST] = { \"i32.const\", 2, 2 },\n\t[WASM_OP_I64CONST] = { \"i64.const\", 2, 2 },\n\t[WASM_OP_F32CONST] = { \"f32.const\", 2, 2 },\n\t[WASM_OP_F64CONST] = { \"f64.const\", 2, 2 },\n\t[WASM_OP_I32EQZ] = { \"i32.eqz\", 1, 1 },\n\t[WASM_OP_I32EQ] = { \"i32.eq\", 1, 1 },\n\t[WASM_OP_I32NE] = { \"i32.ne\", 1, 1},\n\t[WASM_OP_I32LTS] = { \"i32.lt_s\", 1, 1 },\n\t[WASM_OP_I32LTU] = { \"i32.lt_u\", 1, 1 },\n\t[WASM_OP_I32GTS] = { \"i32.gt_s\", 1, 1 },\n\t[WASM_OP_I32GTU] = { \"i32.gt_u\", 1, 1 },\n\t[WASM_OP_I32LES] = { \"i32.le_s\", 1, 1 },\n\t[WASM_OP_I32LEU] = { \"i32.le_u\", 1, 1 },\n\t[WASM_OP_I32GES] = { \"i32.ge_s\", 1, 1 },\n\t[WASM_OP_I32GEU] = { \"i32.ge_u\", 1, 1 },\n\t[WASM_OP_I64EQZ] = { \"i64.eqz\", 1, 1 },\n\t[WASM_OP_I64EQ] = {\" i64.eq\", 1, 1 },\n\t[WASM_OP_I64NE] = {\" i64.ne\", 1, 1 },\n\t[WASM_OP_I64LTS] = { \"i64.lt_s\", 1, 1 },\n\t[WASM_OP_I64LTU] = { \"i64.lt_u\", 1, 1 },\n\t[WASM_OP_I64GTS] = { \"i64.gt_s\", 1, 1 },\n\t[WASM_OP_I64GTU] = { \"i64.gt_u\", 1, 1 },\n\t[WASM_OP_I64LES] = { \"i64.le_s\", 1, 1 },\n\t[WASM_OP_I64LEU] = { \"i64.le_u\", 1, 1 },\n\t[WASM_OP_I64GES] = { \"i64.ge_s\", 1, 1 },\n\t[WASM_OP_I64GEU] = { \"i64.ge_u\", 1, 1 },\n\t[WASM_OP_F32EQ] = { \"f32.eq\", 1, 1 },\n\t[WASM_OP_F32NE] = { \"f32.ne\", 1, 1 },\n\t[WASM_OP_F32LT] = { \"f32.lt\", 1, 1 },\n\t[WASM_OP_F32GT] = { \"f32.gt\", 1, 1 },\n\t[WASM_OP_F32LE] = { \"f32.le\", 1, 1 },\n\t[WASM_OP_F32GE] = { \"f32.ge\", 1, 1 },\n\t[WASM_OP_F64EQ] = { \"f64.eq\", 1, 1 },\n\t[WASM_OP_F64NE] = { \"f64.ne\", 1, 1 },\n\t[WASM_OP_F64LT] = { \"f64.lt\", 1, 1 },\n\t[WASM_OP_F64GT] = { \"f64.gt\", 1, 1 },\n\t[WASM_OP_F64LE] = { \"f64.le\", 1, 1 },\n\t[WASM_OP_F64GE] = { \"f64.ge\", 1, 1 },\n\t[WASM_OP_I32CLZ] = { \"i32.clz\", 1, 1 },\n\t[WASM_OP_I32CTZ] = { \"i32.ctz\", 1, 1 },\n\t[WASM_OP_I32POPCNT] = { \"i32.popcnt\", 1, 1 },\n\t[WASM_OP_I32ADD] = { \"i32.add\", 1, 1 },\n\t[WASM_OP_I32SUB] = { \"i32.sub\", 1, 1 },\n\t[WASM_OP_I32MUL] = { \"i32.mul\", 1, 1 },\n\t[WASM_OP_I32DIVS] = { \"i32.div_s\", 1, 1 },\n\t[WASM_OP_I32DIVU] = { \"i32.div_u\", 1, 1 },\n\t[WASM_OP_I32REMS] = { \"i32.rem_s\", 1, 1 },\n\t[WASM_OP_I32REMU] = { \"i32.rem_u\", 1, 1 },\n\t[WASM_OP_I32AND] = { \"i32.and\", 1, 1 },\n\t[WASM_OP_I32OR] = { \"i32.or\", 1, 1 },\n\t[WASM_OP_I32XOR] = { \"i32.xor\", 1, 1 },\n\t[WASM_OP_I32SHL] = { \"i32.shl\", 1, 1 },\n\t[WASM_OP_I32SHRS] = { \"i32.shr_s\", 1, 1 },\n\t[WASM_OP_I32SHRU] = { \"i32.shr_u\", 1, 1 },\n\t[WASM_OP_I32ROTL] = { \"i32.rotl\", 1, 1 },\n\t[WASM_OP_I32ROTR] = { \"i32.rotr\", 1, 1 },\n\t[WASM_OP_I64CLZ] = { \"i64.clz\", 1, 1 },\n\t[WASM_OP_I64CTZ] = { \"i64.ctz\", 1, 1 },\n\t[WASM_OP_I64POPCNT] = { \"i64.popcnt\", 1, 1 },\n\t[WASM_OP_I64ADD] = { \"i64.add\", 1, 1 },\n\t[WASM_OP_I64SUB] = { \"i64.sub\", 1, 1 },\n\t[WASM_OP_I64MUL] = { \"i64.mul\", 1, 1 },\n\t[WASM_OP_I64DIVS] = { \"i64.div_s\", 1, 1 },\n\t[WASM_OP_I64DIVU] = { \"i64.div_u\", 1, 1 },\n\t[WASM_OP_I64REMS] = { \"i64.rem_s\", 1, 1 },\n\t[WASM_OP_I64REMU] = { \"i64.rem_u\", 1, 1 },\n\t[WASM_OP_I64AND] = { \"i64.and\", 1, 1 },\n\t[WASM_OP_I64OR] = { \"i64.or\", 1, 1 },\n\t[WASM_OP_I64XOR] = { \"i64.xor\", 1, 1 },\n\t[WASM_OP_I64SHL] = { \"i64.shl\", 1, 1 },\n\t[WASM_OP_I64SHRS] = { \"i64.shr_s\", 1, 1 },\n\t[WASM_OP_I64SHRU] = { \"i64.shr_u\", 1, 1 },\n\t[WASM_OP_I64ROTL] = { \"i64.rotl\", 1, 1 },\n\t[WASM_OP_I64ROTR] = { \"i64.rotr\", 1, 1 },\n\t[WASM_OP_F32ABS] = { \"f32.abs\", 1, 1 },\n\t[WASM_OP_F32NEG] = { \"f32.neg\", 1, 1 },\n\t[WASM_OP_F32CEIL] = { \"f32.ceil\", 1, 1 },\n\t[WASM_OP_F32FLOOR] = { \"f32.floor\", 1, 1 },\n\t[WASM_OP_F32TRUNC] = { \"f32.trunc\", 1, 1 },\n\t[WASM_OP_F32NEAREST] = { \"f32.nearest\", 1, 1 },\n\t[WASM_OP_F32SQRT] = { \"f32.sqrt\", 1, 1 },\n\t[WASM_OP_F32ADD] = { \"f32.add\", 1, 1 },\n\t[WASM_OP_F32SUB] =  { \"f32.sub\", 1, 1 },\n\t[WASM_OP_F32MUL] = { \"f32.mul\", 1, 1 },\n\t[WASM_OP_F32DIV] = { \"f32.div\", 1, 1 },\n\t[WASM_OP_F32MIN] = { \"f32.min\", 1, 1 },\n\t[WASM_OP_F32MAX] = { \"f32.max\", 1, 1 },\n\t[WASM_OP_F32COPYSIGN] = {\" f32.copysign\", 1, 1 },\n\t[WASM_OP_F64ABS] = { \"f64.abs\", 1, 1 },\n\t[WASM_OP_F64NEG] = { \"f64.neg\", 1, 1 },\n\t[WASM_OP_F64CEIL] = { \"f64.ceil\", 1, 1 },\n\t[WASM_OP_F64FLOOR] = { \"f64.floor\", 1, 1 },\n\t[WASM_OP_F64TRUNC] = { \"f64.trunc\", 1, 1 },\n\t[WASM_OP_F64NEAREST] = { \"f64.nearest\", 1, 1 },\n\t[WASM_OP_F64SQRT] = { \"f64.sqrt\", 1, 1 },\n\t[WASM_OP_F64ADD] = { \"f64.add\", 1, 1 },\n\t[WASM_OP_F64SUB] = { \"f64.sub\", 1, 1 },\n\t[WASM_OP_F64MUL] = { \"f64.mul\", 1, 1 },\n\t[WASM_OP_F64DIV] = { \"f64.div\", 1, 1 },\n\t[WASM_OP_F64MIN] = { \"f64.min\", 1, 1 },\n\t[WASM_OP_F64MAX] = { \"f64.max\", 1, 1 },\n\t[WASM_OP_F64COPYSIGN] = { \"f64.copysign\", 1, 1 },\n\t[WASM_OP_I32WRAPI64] = { \"i32.wrap/i64\", 1, 1 },\n\t[WASM_OP_I32TRUNCSF32] = { \"i32.trunc_s/f32\", 1, 1 },\n\t[WASM_OP_I32TRUNCUF32] = { \"i32.trunc_u/f32\", 1, 1 },\n\t[WASM_OP_I32TRUNCSF64] = { \"i32.trunc_s/f64\", 1, 1 },\n\t[WASM_OP_I32TRUNCUF64] = { \"i32.trunc_u/f64\", 1, 1 },\n\t[WASM_OP_I64EXTENDSI32] = { \"i64.extend_s/i32\", 1, 1 },\n\t[WASM_OP_I64EXTENDUI32] = { \"i64.extend_u/i32\", 1, 1 },\n\t[WASM_OP_I64TRUNCSF32] = { \"i64.trunc_s/f32\", 1, 1 },\n\t[WASM_OP_I64TRUNCUF32] = { \"i64.trunc_u/f32\", 1, 1 },\n\t[WASM_OP_I64TRUNCSF64] = { \"i64.trunc_s/f64\", 1, 1 },\n\t[WASM_OP_I64TRUNCUF64] = { \"i64.trunc_u/f64\", 1, 1 },\n\t[WASM_OP_F32CONVERTSI32] = { \"f32.convert_s/i32\", 1, 1 },\n\t[WASM_OP_F32CONVERTUI32] = { \"f32.convert_u/i32\", 1, 1 },\n\t[WASM_OP_F32CONVERTSI64] = { \"f32.convert_s/i64\", 1, 1 },\n\t[WASM_OP_F32CONVERTUI64] = { \"f32.convert_u/i64\", 1, 1 },\n\t[WASM_OP_F32DEMOTEF64] = { \"f32.demote/f64\", 1, 1 },\n\t[WASM_OP_F64CONVERTSI32] = { \"f64.convert_s/i32\", 1, 1 },\n\t[WASM_OP_F64CONVERTUI32] = { \"f64.convert_u/i32\", 1, 1 },\n\t[WASM_OP_F64CONVERTSI64] = { \"f64.convert_s/i64\", 1, 1 },\n\t[WASM_OP_F64CONVERTUI64] = { \"f64.convert_u/i64\", 1, 1 },\n\t[WASM_OP_F64PROMOTEF32] = { \"f64.promote/f32\", 1, 1 },\n\t[WASM_OP_I32REINTERPRETF32] = { \"i32.reinterpret/f32\", 1, 1 },\n\t[WASM_OP_I64REINTERPRETF64] = { \"i64.reinterpret/f64\", 1, 1 },\n\t[WASM_OP_F32REINTERPRETI32] = { \"f32.reinterpret/i32\", 1, 1 },\n\t[WASM_OP_F64REINTERPRETI64] = { \"f64/reinterpret/i64\", 1, 1 }\n};\n\nint wasm_asm(const char *str, unsigned char *buf, int buf_len) {\n\t// TODO: add immediates assembly\n\tint i = 0, len = -1;\n\tchar tmp[R_ASM_BUFSIZE];\n\twhile (str[i] != ' ' && i < buf_len) {\n\t\ttmp[i] = str[i];\n\t\ti++;\n\t}\n\ttmp[i] = 0;\n\tfor (i = 0; i < 0xff; i++) {\n\t\tWasmOpDef *opdef = &opcodes[i];\n\t\tif (opdef->txt) {\n\t\t\tif (!strcmp (opdef->txt, tmp)) {\n\t\t\t\tbuf[0] = i;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn len;\n}\n\nint wasm_dis(WasmOp *op, const unsigned char *buf, int buf_len) {\n\top->len = 1;\n\top->op = buf[0];\n\tif (op->op > 0xbf) return 1;\n\t// add support for extension opcodes (SIMD + atomics)\n\tWasmOpDef *opdef = &opcodes[op->op];\n\tswitch (op->op) {\n\tcase WASM_OP_TRAP:\n\tcase WASM_OP_NOP:\n\tcase WASM_OP_ELSE:\n\tcase WASM_OP_RETURN:\n\tcase WASM_OP_DROP:\n\tcase WASM_OP_SELECT:\n\tcase WASM_OP_I32EQZ: \n\tcase WASM_OP_I32EQ: \n\tcase WASM_OP_I32NE: \n\tcase WASM_OP_I32LTS: \n\tcase WASM_OP_I32LTU: \n\tcase WASM_OP_I32GTS: \n\tcase WASM_OP_I32GTU: \n\tcase WASM_OP_I32LES: \n\tcase WASM_OP_I32LEU: \n\tcase WASM_OP_I32GES: \n\tcase WASM_OP_I32GEU: \n\tcase WASM_OP_I64EQZ: \n\tcase WASM_OP_I64EQ: \n\tcase WASM_OP_I64NE: \n\tcase WASM_OP_I64LTS: \n\tcase WASM_OP_I64LTU: \n\tcase WASM_OP_I64GTS: \n\tcase WASM_OP_I64GTU: \n\tcase WASM_OP_I64LES: \n\tcase WASM_OP_I64LEU: \n\tcase WASM_OP_I64GES: \n\tcase WASM_OP_I64GEU: \n\tcase WASM_OP_F32EQ: \n\tcase WASM_OP_F32NE: \n\tcase WASM_OP_F32LT: \n\tcase WASM_OP_F32GT: \n\tcase WASM_OP_F32LE: \n\tcase WASM_OP_F32GE: \n\tcase WASM_OP_F64EQ: \n\tcase WASM_OP_F64NE: \n\tcase WASM_OP_F64LT: \n\tcase WASM_OP_F64GT: \n\tcase WASM_OP_F64LE: \n\tcase WASM_OP_F64GE: \n\tcase WASM_OP_I32CLZ: \n\tcase WASM_OP_I32CTZ: \n\tcase WASM_OP_I32POPCNT: \n\tcase WASM_OP_I32ADD: \n\tcase WASM_OP_I32SUB: \n\tcase WASM_OP_I32MUL: \n\tcase WASM_OP_I32DIVS: \n\tcase WASM_OP_I32DIVU: \n\tcase WASM_OP_I32REMS: \n\tcase WASM_OP_I32REMU: \n\tcase WASM_OP_I32AND: \n\tcase WASM_OP_I32OR: \n\tcase WASM_OP_I32XOR: \n\tcase WASM_OP_I32SHL: \n\tcase WASM_OP_I32SHRS: \n\tcase WASM_OP_I32SHRU: \n\tcase WASM_OP_I32ROTL: \n\tcase WASM_OP_I32ROTR: \n\tcase WASM_OP_I64CLZ: \n\tcase WASM_OP_I64CTZ: \n\tcase WASM_OP_I64POPCNT: \n\tcase WASM_OP_I64ADD: \n\tcase WASM_OP_I64SUB: \n\tcase WASM_OP_I64MUL: \n\tcase WASM_OP_I64DIVS: \n\tcase WASM_OP_I64DIVU: \n\tcase WASM_OP_I64REMS: \n\tcase WASM_OP_I64REMU: \n\tcase WASM_OP_I64AND: \n\tcase WASM_OP_I64OR: \n\tcase WASM_OP_I64XOR: \n\tcase WASM_OP_I64SHL: \n\tcase WASM_OP_I64SHRS: \n\tcase WASM_OP_I64SHRU: \n\tcase WASM_OP_I64ROTL: \n\tcase WASM_OP_I64ROTR: \n\tcase WASM_OP_F32ABS: \n\tcase WASM_OP_F32NEG: \n\tcase WASM_OP_F32CEIL: \n\tcase WASM_OP_F32FLOOR: \n\tcase WASM_OP_F32TRUNC: \n\tcase WASM_OP_F32NEAREST: \n\tcase WASM_OP_F32SQRT: \n\tcase WASM_OP_F32ADD: \n\tcase WASM_OP_F32SUB: \n\tcase WASM_OP_F32MUL: \n\tcase WASM_OP_F32DIV: \n\tcase WASM_OP_F32MIN: \n\tcase WASM_OP_F32MAX: \n\tcase WASM_OP_F32COPYSIGN: \n\tcase WASM_OP_F64ABS: \n\tcase WASM_OP_F64NEG: \n\tcase WASM_OP_F64CEIL: \n\tcase WASM_OP_F64FLOOR: \n\tcase WASM_OP_F64TRUNC: \n\tcase WASM_OP_F64NEAREST: \n\tcase WASM_OP_F64SQRT: \n\tcase WASM_OP_F64ADD: \n\tcase WASM_OP_F64SUB: \n\tcase WASM_OP_F64MUL: \n\tcase WASM_OP_F64DIV: \n\tcase WASM_OP_F64MIN: \n\tcase WASM_OP_F64MAX: \n\tcase WASM_OP_F64COPYSIGN: \n\tcase WASM_OP_I32WRAPI64: \n\tcase WASM_OP_I32TRUNCSF32: \n\tcase WASM_OP_I32TRUNCUF32: \n\tcase WASM_OP_I32TRUNCSF64: \n\tcase WASM_OP_I32TRUNCUF64: \n\tcase WASM_OP_I64EXTENDSI32: \n\tcase WASM_OP_I64EXTENDUI32: \n\tcase WASM_OP_I64TRUNCSF32: \n\tcase WASM_OP_I64TRUNCUF32: \n\tcase WASM_OP_I64TRUNCSF64: \n\tcase WASM_OP_I64TRUNCUF64: \n\tcase WASM_OP_F32CONVERTSI32: \n\tcase WASM_OP_F32CONVERTUI32: \n\tcase WASM_OP_F32CONVERTSI64: \n\tcase WASM_OP_F32CONVERTUI64: \n\tcase WASM_OP_F32DEMOTEF64: \n\tcase WASM_OP_F64CONVERTSI32: \n\tcase WASM_OP_F64CONVERTUI32: \n\tcase WASM_OP_F64CONVERTSI64: \n\tcase WASM_OP_F64CONVERTUI64: \n\tcase WASM_OP_F64PROMOTEF32: \n\tcase WASM_OP_I32REINTERPRETF32: \n\tcase WASM_OP_I64REINTERPRETF64: \n\tcase WASM_OP_F32REINTERPRETI32: \n\tcase WASM_OP_F64REINTERPRETI64:\n\tcase WASM_OP_END:\n\t\t{\n\t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s\", opdef->txt);\n\t\t}\n\t\tbreak;\n\tcase WASM_OP_BLOCK:\n\tcase WASM_OP_LOOP:\n\tcase WASM_OP_IF:\n\t\t{\n\t\t\tst32 val = 0;\n\t\t\tsize_t n = read_i32_leb128 (buf + 1, buf + buf_len, &val);\n\t\t\tif (!(n > 0 && n < buf_len)) goto err;\n\t\t\tswitch (0x80 - val) {\n\t\t\tcase R_BIN_WASM_VALUETYPE_EMPTY:\n\t\t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s\", opdef->txt);\n\t\t\t\tbreak;\n\t\t\tcase R_BIN_WASM_VALUETYPE_i32:\n\t\t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s (result i32)\", opdef->txt);\n\t\t\t\tbreak;\n\t\t\tcase R_BIN_WASM_VALUETYPE_i64:\n\t\t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s (result i64)\", opdef->txt);\n\t\t\t\tbreak;\n\t\t\tcase R_BIN_WASM_VALUETYPE_f32:\n\t\t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s (result f32)\", opdef->txt);\n\t\t\t\tbreak;\n\t\t\tcase R_BIN_WASM_VALUETYPE_f64:\n\t\t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s (result f64)\", opdef->txt);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s (result ?)\", opdef->txt);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\top->len += n;\n\t\t}\n\t\tbreak;\n\tcase WASM_OP_BR:\n\tcase WASM_OP_BRIF:\n\tcase WASM_OP_CALL:\n\t\t{\n\t\t\tut32 val = 0;\n\t\t\tsize_t n = read_u32_leb128 (buf + 1, buf + buf_len, &val);\n\t\t\tif (!(n > 0 && n < buf_len)) goto err;\n\t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s %d\", opdef->txt, val);\n\t\t\top->len += n;\n\t\t}\n\t\tbreak;\n\tcase WASM_OP_BRTABLE:\n\t\t{\n\t\t\tut32 count = 0, *table = NULL, def = 0;\n\t\t\tsize_t n = read_u32_leb128 (buf + 1, buf + buf_len, &count);\n\t\t\tif (!(n > 0 && n < buf_len)) goto err;\n\t\t\tif (!(table = calloc (count, sizeof (ut32)))) goto err;\n\t\t\tint i = 0;\n\t\t\top->len += n;\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tn = read_u32_leb128 (buf + op->len, buf + buf_len, &table[i]);\n\t\t\t\tif (!(op->len + n <= buf_len)) goto beach;\n\t\t\t\top->len += n;\n\t\t\t}\n\t\t\tn = read_u32_leb128 (buf + op->len, buf + buf_len, &def);\n\t\t\tif (!(n > 0 && n + op->len < buf_len)) goto beach;\n\t\t\top->len += n;\n\t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s %d \", opdef->txt, count);\n\t\t\tfor (i = 0; i < count && strlen (op->txt) < R_ASM_BUFSIZE; i++) {\n\t\t\t\tsnprintf (op->txt + strlen (op->txt), R_ASM_BUFSIZE, \"%d \", table[i]);\n\t\t\t}\t\n\t\t\tsnprintf (op->txt + strlen (op->txt), R_ASM_BUFSIZE, \"%d\", def);\n\t\t\tfree (table);\n\t\t\tbreak;\n\t\t\tbeach:\n\t\t\t\tfree (table);\n\t\t\t\tgoto err;\n\t\t}\n\t\tbreak;\n\tcase WASM_OP_CALLINDIRECT:\n\t\t{\n\t\t\tut32 val = 0, reserved = 0;\n\t\t\tsize_t n = read_u32_leb128 (buf + 1, buf + buf_len, &val);\n\t\t\tif (!(n > 0 && n < buf_len)) goto err;\n\t\t\top->len += n;\n\t\t\tn = read_u32_leb128 (buf + op->len, buf + buf_len, &reserved);\n\t\t\tif (!(n == 1 && op->len + n <= buf_len)) goto err;\n\t\t\treserved &= 0x1;\n\t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s %d %d\", opdef->txt, val, reserved);\n\t\t\top->len += n;\n\t\t}\n\t\tbreak;\n\tcase WASM_OP_GETLOCAL:\n\tcase WASM_OP_SETLOCAL:\n\tcase WASM_OP_TEELOCAL:\n\tcase WASM_OP_GETGLOBAL:\n\tcase WASM_OP_SETGLOBAL:\n\t\t{\n\t\t\tut32 val = 0;\n\t\t\tsize_t n = read_u32_leb128 (buf + 1, buf + buf_len, &val);\n\t\t\tif (!(n > 0 && n < buf_len)) goto err;\n\t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s %d\", opdef->txt, val);\n\t\t\top->len += n;\n\t\t}\n\t\tbreak;\n\tcase WASM_OP_I32LOAD:\n\tcase WASM_OP_I64LOAD: \n\tcase WASM_OP_F32LOAD: \n\tcase WASM_OP_F64LOAD: \n\tcase WASM_OP_I32LOAD8S: \n\tcase WASM_OP_I32LOAD8U: \n\tcase WASM_OP_I32LOAD16S: \n\tcase WASM_OP_I32LOAD16U: \n\tcase WASM_OP_I64LOAD8S: \n\tcase WASM_OP_I64LOAD8U: \n\tcase WASM_OP_I64LOAD16S: \n\tcase WASM_OP_I64LOAD16U: \n\tcase WASM_OP_I64LOAD32S: \n\tcase WASM_OP_I64LOAD32U: \n\tcase WASM_OP_I32STORE: \n\tcase WASM_OP_I64STORE: \n\tcase WASM_OP_F32STORE: \n\tcase WASM_OP_F64STORE: \n\tcase WASM_OP_I32STORE8: \n\tcase WASM_OP_I32STORE16: \n\tcase WASM_OP_I64STORE8: \n\tcase WASM_OP_I64STORE16: \n\tcase WASM_OP_I64STORE32: \n\t\t{\n\t\t\tut32 flag = 0, offset = 0;\n\t\t\tsize_t n = read_u32_leb128 (buf + 1, buf + buf_len, &flag);\n\t\t\tif (!(n > 0 && n < buf_len)) goto err;\n\t\t\top->len += n;\n\t\t\tn = read_u32_leb128 (buf + op->len, buf + buf_len, &offset);\n\t\t\tif (!(n > 0 && op->len + n <= buf_len)) goto err;\n\t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s %d %d\", opdef->txt, flag, offset);\n\t\t\top->len += n;\n\t\t}\n\t\tbreak;\n\tcase WASM_OP_CURRENTMEMORY:\n\tcase WASM_OP_GROWMEMORY:\n\t\t{\n\t\t\tut32 reserved = 0;\n\t\t\tsize_t n = read_u32_leb128 (buf + 1, buf + buf_len, &reserved);\n\t\t\tif (!(n == 1 && n < buf_len)) goto err;\n\t\t\treserved &= 0x1;\n\t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s %d\", opdef->txt, reserved); \n\t\t\top->len += n;\n\t\t}\n\t\tbreak;\n\n\tcase WASM_OP_I32CONST:\n\t\t{\n\t\t\tst32 val = 0;\n\t\t\tsize_t n = read_i32_leb128 (buf + 1, buf + buf_len, &val);\n\t\t\tif (!(n > 0 && n < buf_len)) goto err;\n\t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s %\" PFMT32d, opdef->txt, val);\n\t\t\top->len += n;\n\t\t}\n\t\tbreak;\n\tcase WASM_OP_I64CONST:\n\t\t{\n\t\t\tst64 val = 0;\n\t\t\tsize_t n = read_i64_leb128 (buf + 1, buf + buf_len, &val);\n\t\t\tif (!(n > 0 && n < buf_len)) goto err;\n\t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s %\" PFMT64d, opdef->txt, val);\n\t\t\top->len += n;\n\t\t}\n\t\tbreak;\n\tcase WASM_OP_F32CONST:\n\t\t{\n\t\t\tut32 val = 0;\n\t\t\tsize_t n = read_u32_leb128 (buf + 1, buf + buf_len, &val);\n\t\t\tif (!(n > 0 && n < buf_len)) goto err;\n\t\t\tlong double d =  (long double)val;\n\t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s %\" LDBLFMT, opdef->txt, d);\n\t\t\top->len += n;\n\t\t}\n\t\tbreak;\n\tcase WASM_OP_F64CONST:\n\t\t{\n\t\t\tut64 val = 0;\n\t\t\tsize_t n = read_u64_leb128 (buf + 1, buf + buf_len, &val);\n\t\t\tif (!(n > 0 && n < buf_len)) goto err;\n\t\t\tlong double d =  (long double)val;\n\t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s %\" LDBLFMT, opdef->txt, d);\n\t\t\top->len += n;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tgoto err;\n\t}\n\n\treturn op->len;\n\nerr:\n\top->len = 1;\n\tsnprintf (op->txt, R_ASM_BUFSIZE, \"invalid\");\n\treturn op->len;\n}\n\n", "/* radare - LGPL - Copyright 2007-2017 - pancake */\n\n#include <r_flag.h>\n#include <r_util.h>\n#include <r_cons.h>\n#include <stdio.h>\n\nR_LIB_VERSION(r_flag);\n\n#define ISNULLSTR(x) (!(x) || !*(x))\n#define IS_IN_SPACE(f, i) ((f)->space_idx != -1 && (i)->space != (f)->space_idx)\n\nstatic const char *str_callback(RNum *user, ut64 off, int *ok) {\n\tconst RList *list;\n\tRFlag *f = (RFlag*)user;\n\tRFlagItem *item;\n\tif (ok) {\n\t\t*ok = 0;\n\t}\n\tif (f) {\n\t\tlist = r_flag_get_list (f, off);\n\t\titem = r_list_get_top (list);\n\t\tif (item) {\n\t\t\tif (ok) {\n\t\t\t\t*ok = true;\n\t\t\t}\n\t\t\treturn item->name;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic void flag_free_kv(HtKv *kv) {\n\tfree (kv->key);\n\t//we do not free kv->value since there is a reference in other list\n\tfree (kv);\n}\n\nstatic void flag_skiplist_free(void *data) {\n\tRFlagsAtOffset *item = (RFlagsAtOffset *)data;\n\tr_list_free (item->flags);\n\tfree (data);\n}\n\nstatic int flag_skiplist_cmp(const void *va, const void *vb) {\n\tconst RFlagsAtOffset *a = (RFlagsAtOffset *)va, *b = (RFlagsAtOffset *)vb;\n\tif (a->off == b->off) {\n\t\treturn 0;\n\t}\n\treturn a->off < b->off ? -1 : 1;\n}\n\nstatic ut64 num_callback(RNum *user, const char *name, int *ok) {\n\tRFlag *f = (RFlag*)user;\n\tRFlagItem *item;\n\tif (ok) {\n\t\t*ok = 0;\n\t}\n\titem = ht_find (f->ht_name, name, NULL);\n\tif (item) {\n\t\t// NOTE: to avoid warning infinite loop here we avoid recursivity\n\t\tif (item->alias) {\n\t\t\treturn 0LL;\n\t\t}\n\t\tif (ok) {\n\t\t\t*ok = 1;\n\t\t}\n\t\treturn item->offset;\n\t}\n\treturn 0LL;\n}\n\n/* return the list of flag at the nearest position.\n\tdir == -1 -> result <= off\n\tdir == 0 ->  result == off\n\tdir == 1 ->  result >= off*/\nstatic  RFlagsAtOffset* r_flag_get_nearest_list(RFlag *f, ut64 off, int dir) {\n\tRFlagsAtOffset *flags = NULL;\n\tRFlagsAtOffset key;\n\tkey.off = off;\n\tif (dir >= 0) {\n\t\tflags = r_skiplist_get_geq (f->by_off, &key);\n\t} else {\n\t\tflags = r_skiplist_get_leq (f->by_off, &key);\n\t}\n\tif (dir == 0 && flags && flags->off != off) {\n\t\treturn NULL;\n\t}\n\treturn flags;\n}\n\nstatic void remove_offsetmap(RFlag *f, RFlagItem *item) {\n\tRFlagsAtOffset *flags = r_flag_get_nearest_list (f, item->offset, 0);\n\tif (flags) {\n\t\tr_list_delete_data (flags->flags, item);\n\t\tif (r_list_empty (flags->flags)) {\n\t\t\tr_skiplist_delete (f->by_off, flags);\n\t\t}\n\t}\n}\n\nstatic int set_name(RFlagItem *item, const char *name) {\n\tif (item->name != item->realname) {\n\t\tfree (item->name);\n\t}\n\titem->name = strdup (name);\n\tif (!item->name) {\n\t\treturn false;\n\t}\n\tr_str_chop (item->name);\n\tr_name_filter (item->name, 0); // TODO: name_filter should be chopping already\n\tfree (item->realname);\n\titem->realname = item->name;\n\treturn true;\n}\n\nR_API RFlag * r_flag_new() {\n\tint i;\n\tRFlag *f = R_NEW0 (RFlag);\n\tif (!f) return NULL;\n\tf->num = r_num_new (&num_callback, &str_callback, f);\n\tif (!f->num) {\n\t\tr_flag_free (f);\n\t\treturn NULL;\n\t}\n\tf->base = 0;\n\tf->cb_printf = (PrintfCallback)printf;\n#if R_FLAG_ZONE_USE_SDB\n\tf->zones = sdb_new0 ();\n#else\n\tf->zones = NULL;\n#endif\n\tf->flags = r_list_new ();\n\tif (!f->flags) {\n\t\tr_flag_free (f);\n\t\treturn NULL;\n\t}\n\tf->flags->free = (RListFree) r_flag_item_free;\n\tf->space_idx = -1;\n\tf->spacestack = r_list_newf (NULL);\n\tif (!f->spacestack) {\n\t\tr_flag_free (f);\n\t\treturn NULL;\n\t}\n\tf->ht_name = ht_new (NULL, flag_free_kv, NULL);\n\tf->by_off = r_skiplist_new (flag_skiplist_free, flag_skiplist_cmp);\n#if R_FLAG_ZONE_USE_SDB\n\tsdb_free (f->zones);\n#else\n\tr_list_free (f->zones);\n#endif\n\tfor (i = 0; i < R_FLAG_SPACES_MAX; i++) {\n\t\tf->spaces[i] = NULL;\n\t}\n\treturn f;\n}\n\nR_API void r_flag_item_free(RFlagItem *item) {\n\tif (item) {\n\t\tfree (item->color);\n\t\tfree (item->comment);\n\t\tfree (item->alias);\n\t\t/* release only one of the two pointers if they are the same */\n\t\tif (item->name != item->realname) {\n\t\t\tfree (item->name);\n\t\t}\n\t\tfree (item->realname);\n\t\tfree (item);\n\t}\n}\n\nR_API RFlag *r_flag_free(RFlag *f) {\n\tint i;\n\tfor (i = 0; i < R_FLAG_SPACES_MAX; i++) {\n\t\tfree (f->spaces[i]);\n\t}\n\tr_skiplist_free (f->by_off);\n\tht_free (f->ht_name);\n\n\tr_list_free (f->flags);\n\tr_list_free (f->spacestack);\n\tr_num_free (f->num);\n\tfree (f);\n\treturn NULL;\n}\n\n/* print with r_cons the flag items in the flag f, given as a parameter */\nR_API void r_flag_list(RFlag *f, int rad, const char *pfx) {\n\tbool in_range = false;\n\tut64 range_from = UT64_MAX;\n\tut64 range_to = UT64_MAX;\n\tint fs = -1;\n\tRListIter *iter;\n\tRFlagItem *flag;\n\tif (rad == 'i') {\n\t\tchar *sp, *arg = strdup (pfx + 1);\n\t\tsp = strchr (arg,  ' ');\n\t\tif (sp) {\n\t\t\t*sp++ = 0;\n\t\t\trange_from = r_num_math (f->num, arg);\n\t\t\trange_to = r_num_math (f->num, sp);\n\t\t} else {\n\t\t\tconst int bsize = 4096;\n\t\t\trange_from = r_num_math (f->num, arg);\n\t\t\trange_to = range_from + bsize;\n\t\t}\n\t\tin_range = true;\n\t\tfree (arg);\n\t\trad = pfx[0];\n\t\tpfx = NULL;\n\t}\n\n\tif (pfx && !*pfx) {\n\t\tpfx = NULL;\n\t}\n\n\tswitch (rad) {\n\tcase 'j': {\n\t\tint first = 1;\n\t\tf->cb_printf (\"[\");\n\t\tr_list_foreach (f->flags, iter, flag) {\n\t\t\tif (IS_IN_SPACE (f, flag)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (in_range && (flag->offset < range_from || flag->offset >= range_to)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tf->cb_printf (\"%s{\\\"name\\\":\\\"%s\\\",\\\"size\\\":%\"PFMT64d\",\",\n\t\t\t\tfirst?\"\":\",\", flag->name, flag->size);\n\t\t\tif (flag->alias) {\n\t\t\t\tf->cb_printf (\"\\\"alias\\\":\\\"%s\\\"\", flag->alias);\n\t\t\t} else {\n\t\t\t\tf->cb_printf (\"\\\"offset\\\":%\"PFMT64d, flag->offset);\n\t\t\t}\n\t\t\tif (flag->comment)\n\t\t\t\tf->cb_printf (\",\\\"comment\\\":\\\"}\");\n\t\t\telse f->cb_printf (\"}\");\n\t\t\tfirst = 0;\n\t\t}\n\t\tf->cb_printf (\"]\\n\");\n\t\t}\n\t\tbreak;\n\tcase 1:\n\tcase '*':\n\t\tr_list_foreach (f->flags, iter, flag) {\n\t\t\tif (IS_IN_SPACE (f, flag)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (in_range && (flag->offset < range_from || flag->offset >= range_to)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (fs == -1 || flag->space != fs) {\n\t\t\t\tconst char *flagspace;\n\t\t\t\tfs = flag->space;\n\t\t\t\tflagspace = r_flag_space_get_i (f, fs);\n\t\t\t\tif (!flagspace || !*flagspace)\n\t\t\t\t\tflagspace = \"*\";\n\t\t\t\tf->cb_printf (\"fs %s\\n\", flagspace);\n\t\t\t}\n\t\t\tif (flag->alias) {\n\t\t\t\tf->cb_printf (\"fa %s %s\\n\", flag->name, flag->alias);\n\t\t\t\tif (flag->comment && *flag->comment)\n\t\t\t\t\tf->cb_printf (\"\\\"fC %s %s\\\"\\n\",\n\t\t\t\t\t\tflag->name, flag->comment);\n\t\t\t} else {\n\t\t\t\tf->cb_printf (\"f %s %\"PFMT64d\" 0x%08\"PFMT64x\"%s%s %s\\n\",\n\t\t\t\t\tflag->name, flag->size, flag->offset,\n\t\t\t\t\tpfx?\"+\":\"\", pfx?pfx:\"\",\n\t\t\t\t\tflag->comment? flag->comment:\"\");\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'n': // show original name\n\t\tr_list_foreach (f->flags, iter, flag) {\n\t\t\tif (IS_IN_SPACE (f, flag)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (in_range && (flag->offset < range_from || flag->offset >= range_to)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (flag->alias) {\n\t\t\t\tf->cb_printf (\"%s %\"PFMT64d\" %s\\n\",\n\t\t\t\t\t\tflag->alias, flag->size, flag->realname);\n\t\t\t} else {\n\t\t\t\tf->cb_printf (\"0x%08\"PFMT64x\" %\"PFMT64d\" %s\\n\",\n\t\t\t\t\t\tflag->offset, flag->size, flag->realname);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tr_list_foreach (f->flags, iter, flag) {\n\t\t\tif (IS_IN_SPACE (f, flag)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (in_range && (flag->offset < range_from || flag->offset >= range_to)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (flag->alias) {\n\t\t\t\tf->cb_printf (\"%s %\"PFMT64d\" %s\\n\",\n\t\t\t\t\tflag->alias, flag->size, flag->name);\n\t\t\t} else {\n\t\t\t\tf->cb_printf (\"0x%08\"PFMT64x\" %\"PFMT64d\" %s\\n\",\n\t\t\t\t\tflag->offset, flag->size, flag->name);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic RFlagItem *evalFlag(RFlag *f, RFlagItem *item) {\n\tif (item && item->alias) {\n\t\titem->offset = r_num_math (f->num, item->alias);\n\t}\n\treturn item;\n}\n\n/* return true if flag.* exist at offset. Otherwise, false is returned.\n * For example (f, \"sym\", 3, 0x1000)*/\nR_API bool r_flag_exist_at(RFlag *f, const char *flag_prefix, ut16 fp_size, ut64 off) {\n\tRListIter *iter = NULL;\n\tRFlagItem *item = NULL;\n\tif (!f) {\n\t\treturn false;\n\t}\n\tconst RList *list = r_flag_get_list (f, off);\n\tif (!list) {\n\t\treturn false;\n\t}\n\tr_list_foreach (list, iter, item) {\n\t\tif (item->name && !strncmp (item->name, flag_prefix, fp_size)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n/* return the flag item with name \"name\" in the RFlag \"f\", if it exists.\n * Otherwise, NULL is returned. */\nR_API RFlagItem *r_flag_get(RFlag *f, const char *name) {\n\tRFlagItem *r;\n\tif (!f) {\n\t\treturn NULL;\n\t}\n\tr = ht_find (f->ht_name, name, NULL);\n\treturn evalFlag (f, r);\n}\n\n/* return the first flag item that can be found at offset \"off\", or NULL otherwise */\nR_API RFlagItem *r_flag_get_i(RFlag *f, ut64 off) {\n\tconst RList *list;\n\tif (!f) {\n\t\treturn NULL;\n\t}\n\tlist = r_flag_get_list (f, off);\n\treturn list ? evalFlag (f, r_list_get_top (list)) : NULL;\n}\n\n/* return the first flag item at offset \"off\" that doesn't start with \"loc.\",\n * \"fcn.\", \"section.\" or NULL if such a flag doesn't exist.\n *\n * XXX: this function is buggy and it's not really clear what's the purpose */\nR_API RFlagItem *r_flag_get_i2(RFlag *f, ut64 off) {\n\tRFlagItem *oitem = NULL, *item = NULL;\n\tRListIter *iter;\n\tconst RList *list = r_flag_get_list (f, off);\n\tif (!list) {\n\t\treturn NULL;\n\t}\n\tr_list_foreach (list, iter, item) {\n\t\tif (!item->name) {\n\t\t\tcontinue;\n\t\t}\n\t\t/* catch sym. first */\n\t\tif (!strncmp (item->name, \"loc.\", 4)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strncmp (item->name, \"fcn.\", 4)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strncmp (item->name, \"section.\", 8)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strncmp (item->name, \"section_end.\", 12)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (r_str_nlen (item->name, 5) > 4 &&\n\t\t    item->name[3] == '.') {\n\t\t\toitem = item;\n\t\t\tbreak;\n\t\t}\n\t\toitem = item;\n\t\tif (strlen (item->name) < 5 || item->name[3]!='.') continue;\n\t\toitem = item;\n\t}\n\treturn evalFlag (f, oitem);\n}\n\nstatic bool isFunctionFlag(const char *n) {\n\treturn (!strncmp (n, \"sym.func.\", 9)\n\t|| !strncmp (n, \"method.\", 7)\n\t|| !strncmp (n, \"sym.\", 7)\n\t|| !strncmp (n, \"func.\", 5)\n\t|| !strncmp (n, \"fcn.0\", 5));\n}\n\n/* returns the last flag item defined before or at the given offset.\n * NULL is returned if such a item is not found. */\nR_API RFlagItem *r_flag_get_at(RFlag *f, ut64 off, bool closest) {\n\tRFlagItem *item, *nice = NULL;\n\tRListIter *iter;\n\tconst RFlagsAtOffset *flags_at = r_flag_get_nearest_list (f, off, -1);\n\tif (!flags_at) {\n\t\treturn NULL;\n\t}\n\tif (flags_at->off == off) {\n\t\tr_list_foreach (flags_at->flags, iter, item) {\n\t\t\tif (f->space_idx != -1 && item->space != f->space_idx) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (nice) {\n\t\t\t\tif (isFunctionFlag (nice->name)) {\n\t\t\t\t\tnice = item;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnice = item;\n\t\t\t}\n\t\t}\n\t\treturn nice;\n\t}\n\n\tif (!closest) {\n\t\treturn NULL;\n\t}\n\twhile (!nice && flags_at) {\n\t\tr_list_foreach (flags_at->flags, iter, item) {\n\t\t\tif (f->space_strict && IS_IN_SPACE (f, item)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (item->offset == off) {\n\t\t\t\teprintf (\"XXX Should never happend\\n\");\n\t\t\t\treturn evalFlag (f, item);\n\t\t\t}\n\t\t\tnice = item;\n\t\t\tbreak;\n\t\t}\n\t\tif (flags_at->off) {\n\t\t\tflags_at = r_flag_get_nearest_list (f, flags_at->off - 1, -1);\n\t\t} else {\n\t\t\tflags_at = NULL;\n\t\t}\n\t}\n\treturn evalFlag (f, nice);\n}\n\n/* return the list of flag items that are associated with a given offset */\nR_API const RList* /*<RFlagItem*>*/ r_flag_get_list(RFlag *f, ut64 off) {\n\tconst RFlagsAtOffset *item = r_flag_get_nearest_list (f, off, 0);\n\treturn item ? item->flags : NULL;\n}\n\nR_API char *r_flag_get_liststr(RFlag *f, ut64 off) {\n\tRFlagItem *fi;\n\tRListIter *iter;\n\tconst RList *list = r_flag_get_list (f, off);\n\tchar *p = NULL;\n\tr_list_foreach (list, iter, fi) {\n\t\tp = r_str_appendf (p, \"%s%s\",\n\t\t\tfi->realname, iter->n ? \",\" : \":\");\n\t}\n\treturn p;\n}\n\nR_API RFlagItem *r_flag_set_next(RFlag *f, const char *name, ut64 off, ut32 size) {\n\tif (!r_flag_get (f, name)) {\n\t\treturn r_flag_set (f, name, off, size);\n\t}\n\tint i, newNameSize = strlen (name);\n\tchar *newName = malloc (newNameSize + 16);\n\tstrcpy (newName, name);\n\tfor (i = 0; ; i++) {\n\t\tsnprintf (newName + newNameSize, 15, \".%d\", i);\n\t\tif (!r_flag_get (f, newName)) {\n\t\t\tRFlagItem *fi = r_flag_set (f, newName, off, size);\n\t\t\tfree (newName);\n\t\t\treturn fi;\n\t\t}\n\t}\n\treturn NULL;\n}\n\n/* create or modify an existing flag item with the given name and parameters.\n * The realname of the item will be the same as the name.\n * NULL is returned in case of any errors during the process. */\nR_API RFlagItem *r_flag_set(RFlag *f, const char *name, ut64 off, ut32 size) {\n\tRFlagItem *item = NULL;\n\tRList *list;\n\n\t/* contract fail */\n\tif (!name || !*name) {\n\t\treturn NULL;\n\t}\n\n\titem = r_flag_get (f, name);\n\tif (item) {\n\t\tif (item->offset == off) {\n\t\t\titem->size = size;\n\t\t\treturn item;\n\t\t}\n\t\tremove_offsetmap (f, item);\n\t} else {\n\t\titem = R_NEW0 (RFlagItem);\n\t\tif (!item) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (!set_name (item, name)) {\n\t\t\teprintf (\"Invalid flag name '%s'.\\n\", name);\n\t\t\tr_flag_item_free (item);\n\t\t\treturn NULL;\n\t\t}\n\t\t//item share ownership prone to uaf, that is why only\n\t\t//f->flags has set up free pointer\n\t\tht_insert (f->ht_name, item->name, item);\n\t\tr_list_append (f->flags, item);\n\t}\n\n\titem->space = f->space_idx;\n\titem->offset = off + f->base;\n\titem->size = size;\n\n\tlist = (RList *)r_flag_get_list (f, off);\n\tif (!list) {\n\t\tRFlagsAtOffset *flagsAtOffset = R_NEW (RFlagsAtOffset);\n\t\tlist = r_list_new ();\n\t\tflagsAtOffset->flags = list;\n\t\tflagsAtOffset->off = off;\n\t\t// CID 1378268:  Resource leaks  (RESOURCE_LEAK)\n\t\t// Ignoring storage allocated by \"r_skiplist_insert(f->by_off, flagsAtOffset)\" leaks it.\n\t\tr_skiplist_insert (f->by_off, flagsAtOffset);\n\t}\n\tr_list_append (list, item);\n\treturn item;\n}\n\n/* add/replace/remove the alias of a flag item */\nR_API void r_flag_item_set_alias(RFlagItem *item, const char *alias) {\n\tif (item) {\n\t\tfree (item->alias);\n\t\titem->alias = ISNULLSTR (alias)? NULL: strdup (alias);\n\t}\n}\n\n/* add/replace/remove the comment of a flag item */\nR_API void r_flag_item_set_comment(RFlagItem *item, const char *comment) {\n\tif (item) {\n\t\tfree (item->comment);\n\t\titem->comment = ISNULLSTR (comment) ? NULL : strdup (comment);\n\t}\n}\n\n/* add/replace/remove the realname of a flag item */\nR_API void r_flag_item_set_realname(RFlagItem *item, const char *realname) {\n\tif (item) {\n\t\tif (item->name != item->realname) {\n\t\t\tfree (item->realname);\n\t\t}\n\t\titem->realname = ISNULLSTR (realname) ? NULL : strdup (realname);\n\t}\n}\n\n/* change the name of a flag item, if the new name is available.\n * true is returned if everything works well, false otherwise */\nR_API int r_flag_rename(RFlag *f, RFlagItem *item, const char *name) {\n\tif (!f || !item || !name || !*name) {\n\t\treturn false;\n\t}\n#if 0\n\tut64 off = item->offset;\n\tint size = item->size;\n\tr_flag_unset (f, item);\n\tr_flag_set (f, name, off, size);\n\treturn true;\n#else\n\tht_delete (f->ht_name, item->name);\n\tif (!set_name (item, name)) {\n\t\treturn false;\n\t}\n\tht_insert (f->ht_name, item->name, item);\n#endif\n\treturn true;\n}\n\n/* unset the given flag item.\n * returns true if the item is successfully unset, false otherwise.\n *\n * NOTE: the item is freed. */\nR_API int r_flag_unset(RFlag *f, RFlagItem *item) {\n\tremove_offsetmap (f, item);\n\tht_delete (f->ht_name, item->name);\n\tr_list_delete_data (f->flags, item);\n\treturn true;\n}\n\n/* unset the first flag item found at offset off.\n * return true if such a flag is found and unset, false otherwise. */\nR_API int r_flag_unset_off(RFlag *f, ut64 off) {\n\tRFlagItem *item = r_flag_get_i (f, off);\n\tif (item && r_flag_unset (f, item)) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n/* unset all the flag items that satisfy the given glob.\n * return the number of unset items. */\nR_API int r_flag_unset_glob(RFlag *f, const char *glob) {\n\tRListIter it, *iter;\n\tRFlagItem *flag;\n\tint n = 0;\n\n\tr_list_foreach (f->flags, iter, flag) {\n\t\tif (IS_IN_SPACE (f, flag)) continue;\n\t\tif (!glob || r_str_glob (flag->name, glob)) {\n\t\t\tit.n = iter->n;\n\t\t\tr_flag_unset (f, flag);\n\t\t\titer = &it;\n\t\t\tn++;\n\t\t}\n\t}\n\treturn n;\n}\n\n/* unset the flag item with the given name.\n * returns true if the item is found and unset, false otherwise. */\nR_API int r_flag_unset_name(RFlag *f, const char *name) {\n\tRFlagItem *item = ht_find (f->ht_name, name, NULL);\n\treturn item && r_flag_unset (f, item);\n}\n\n/* unset all flag items in the RFlag f */\nR_API void r_flag_unset_all(RFlag *f) {\n\tf->space_idx = -1;\n\tr_list_free (f->flags);\n\tf->flags = r_list_newf ((RListFree)r_flag_item_free);\n\tif (!f->flags) {\n\t\treturn;\n\t}\n\tht_free (f->ht_name);\n\t//don't set free since f->flags will free up items when needed avoiding uaf\n\tf->ht_name = ht_new (NULL, flag_free_kv, NULL);\n\tr_skiplist_purge (f->by_off);\n\tr_flag_space_unset (f, NULL);\n}\n\nR_API int r_flag_relocate(RFlag *f, ut64 off, ut64 off_mask, ut64 to) {\n\tut64 neg_mask = ~(off_mask);\n\tRFlagItem *item;\n\tRListIter *iter;\n\tint n = 0;\n\n\tr_list_foreach (f->flags, iter, item) {\n\t\tut64 fn = item->offset & neg_mask;\n\t\tut64 on = off & neg_mask;\n\t\tif (fn == on) {\n\t\t\tut64 fm = item->offset & off_mask;\n\t\t\tut64 om = to & off_mask;\n\t\t\titem->offset = (to&neg_mask) + fm + om;\n\t\t\tn++;\n\t\t}\n\t}\n\treturn n;\n}\n\nR_API int r_flag_move(RFlag *f, ut64 at, ut64 to) {\n\tRFlagItem *item = r_flag_get_i (f, at);\n\tif (item) {\n\t\tr_flag_set (f, item->name, to, item->size);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n#ifdef MYTEST\nint main () {\n\tRFlagItem *i;\n\tRFlag *f = r_flag_new ();\n\tr_flag_set (f, \"rip\", 0xfff333999000LL, 1);\n\tr_flag_set (f, \"rip\", 0xfff333999002LL, 1);\n\tr_flag_unset (f, \"rip\", NULL);\n\tr_flag_set (f, \"rip\", 3, 4);\n\tr_flag_set (f, \"rip\", 4, 4);\n\tr_flag_set (f, \"corwp\", 300, 4);\n\tr_flag_set (f, \"barp\", 300, 4);\n\tr_flag_set (f, \"rip\", 3, 4);\n\tr_flag_set (f, \"rip\", 4, 4);\n\n\ti = r_flag_get (f, \"rip\");\n\tif (i) printf (\"nRIP: %p %llx\\n\", i, i->offset);\n\telse printf (\"nRIP: null\\n\");\n\n\ti = r_flag_get_i (f, 0xfff333999000LL);\n\tif (i) printf (\"iRIP: %p %llx\\n\", i, i->offset);\n\telse printf (\"iRIP: null\\n\");\n}\n#endif\n\nR_API const char *r_flag_color(RFlag *f, RFlagItem *it, const char *color) {\n\tif (!f || !it) return NULL;\n\tif (!color) return it->color;\n\tfree (it->color);\n\tit->color = *color ? strdup (color) : NULL;\n\treturn it->color;\n}\n\n// BIND\nR_API int r_flag_bind(RFlag *f, RFlagBind *fb) {\n\tfb->f = f;\n\tfb->exist_at = r_flag_exist_at;\n\tfb->get = r_flag_get;\n\tfb->get_at = r_flag_get_at;\n\tfb->set = r_flag_set;\n\tfb->set_fs = r_flag_space_set;\n\treturn 0;\n}\n\nR_API int r_flag_count(RFlag *f, const char *glob) {\n\tint count = 0;\n\tRFlagItem *flag;\n\tRListIter *iter;\n\tr_list_foreach (f->flags, iter, flag) {\n\t\tif (r_str_glob (flag->name, glob))\n\t\t\tcount ++;\n\t}\n\treturn count;\n}\n"], "fixing_code": ["/* radare - LGPL - Copyright 2017 - pancake, cgvwzq */\n\n// http://webassembly.org/docs/binary-encoding/#module-structure\n\n#include <stdio.h>\n#include <string.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"../../bin/format/wasm/wasm.h\"\n\ntypedef enum {\n\t// Control flow operators\n\tWASM_OP_TRAP = 0x00,\n\tWASM_OP_NOP,\n\tWASM_OP_BLOCK,\n\tWASM_OP_LOOP,\n\tWASM_OP_IF,\n\tWASM_OP_ELSE,\n\tWASM_OP_END = 0x0b,\n\tWASM_OP_BR,\n\tWASM_OP_BRIF,\n\tWASM_OP_BRTABLE,\n\tWASM_OP_RETURN,\n\n\t// Call operators\n\tWASM_OP_CALL = 0x10,\n\tWASM_OP_CALLINDIRECT,\n\n\t// Parametric operators\n\tWASM_OP_DROP = 0x1a,\n\tWASM_OP_SELECT,\n\n\t// Variable access\n\tWASM_OP_GETLOCAL = 0x20,\n\tWASM_OP_SETLOCAL,\n\tWASM_OP_TEELOCAL,\n\tWASM_OP_GETGLOBAL,\n\tWASM_OP_SETGLOBAL,\n\n\t// Memory-related operators\n\tWASM_OP_I32LOAD = 0x28,\n\tWASM_OP_I64LOAD,\n\tWASM_OP_F32LOAD,\n\tWASM_OP_F64LOAD,\n\tWASM_OP_I32LOAD8S,\n\tWASM_OP_I32LOAD8U,\n\tWASM_OP_I32LOAD16S,\n\tWASM_OP_I32LOAD16U,\n\tWASM_OP_I64LOAD8S,\n\tWASM_OP_I64LOAD8U,\n\tWASM_OP_I64LOAD16S,\n\tWASM_OP_I64LOAD16U,\n\tWASM_OP_I64LOAD32S,\n\tWASM_OP_I64LOAD32U,\n\tWASM_OP_I32STORE,\n\tWASM_OP_I64STORE,\n\tWASM_OP_F32STORE,\n\tWASM_OP_F64STORE,\n\tWASM_OP_I32STORE8,\n\tWASM_OP_I32STORE16,\n\tWASM_OP_I64STORE8,\n\tWASM_OP_I64STORE16,\n\tWASM_OP_I64STORE32,\n\tWASM_OP_CURRENTMEMORY,\n\tWASM_OP_GROWMEMORY,\n\n\t// Constants\n\tWASM_OP_I32CONST,\n\tWASM_OP_I64CONST,\n\tWASM_OP_F32CONST,\n\tWASM_OP_F64CONST,\n\n\t// Comparison operators\n\tWASM_OP_I32EQZ,\n\tWASM_OP_I32EQ,\n\tWASM_OP_I32NE,\n\tWASM_OP_I32LTS,\n\tWASM_OP_I32LTU,\n\tWASM_OP_I32GTS,\n\tWASM_OP_I32GTU,\n\tWASM_OP_I32LES,\n\tWASM_OP_I32LEU,\n\tWASM_OP_I32GES,\n\tWASM_OP_I32GEU,\n\tWASM_OP_I64EQZ,\n\tWASM_OP_I64EQ,\n\tWASM_OP_I64NE,\n\tWASM_OP_I64LTS,\n\tWASM_OP_I64LTU,\n\tWASM_OP_I64GTS,\n\tWASM_OP_I64GTU,\n\tWASM_OP_I64LES,\n\tWASM_OP_I64LEU,\n\tWASM_OP_I64GES,\n\tWASM_OP_I64GEU,\n\tWASM_OP_F32EQ,\n\tWASM_OP_F32NE,\n\tWASM_OP_F32LT,\n\tWASM_OP_F32GT,\n\tWASM_OP_F32LE,\n\tWASM_OP_F32GE,\n\tWASM_OP_F64EQ,\n\tWASM_OP_F64NE,\n\tWASM_OP_F64LT,\n\tWASM_OP_F64GT,\n\tWASM_OP_F64LE,\n\tWASM_OP_F64GE,\n\n\t// Numeric operators\n\tWASM_OP_I32CLZ,\n\tWASM_OP_I32CTZ,\n\tWASM_OP_I32POPCNT,\n\tWASM_OP_I32ADD,\n\tWASM_OP_I32SUB,\n\tWASM_OP_I32MUL,\n\tWASM_OP_I32DIVS,\n\tWASM_OP_I32DIVU,\n\tWASM_OP_I32REMS,\n\tWASM_OP_I32REMU,\n\tWASM_OP_I32AND,\n\tWASM_OP_I32OR,\n\tWASM_OP_I32XOR,\n\tWASM_OP_I32SHL,\n\tWASM_OP_I32SHRS,\n\tWASM_OP_I32SHRU,\n\tWASM_OP_I32ROTL,\n\tWASM_OP_I32ROTR,\n\tWASM_OP_I64CLZ,\n\tWASM_OP_I64CTZ,\n\tWASM_OP_I64POPCNT,\n\tWASM_OP_I64ADD,\n\tWASM_OP_I64SUB,\n\tWASM_OP_I64MUL,\n\tWASM_OP_I64DIVS,\n\tWASM_OP_I64DIVU,\n\tWASM_OP_I64REMS,\n\tWASM_OP_I64REMU,\n\tWASM_OP_I64AND,\n\tWASM_OP_I64OR,\n\tWASM_OP_I64XOR,\n\tWASM_OP_I64SHL,\n\tWASM_OP_I64SHRS,\n\tWASM_OP_I64SHRU,\n\tWASM_OP_I64ROTL,\n\tWASM_OP_I64ROTR,\n\tWASM_OP_F32ABS,\n\tWASM_OP_F32NEG,\n\tWASM_OP_F32CEIL,\n\tWASM_OP_F32FLOOR,\n\tWASM_OP_F32TRUNC,\n\tWASM_OP_F32NEAREST,\n\tWASM_OP_F32SQRT,\n\tWASM_OP_F32ADD,\n\tWASM_OP_F32SUB,\n\tWASM_OP_F32MUL,\n\tWASM_OP_F32DIV,\n\tWASM_OP_F32MIN,\n\tWASM_OP_F32MAX,\n\tWASM_OP_F32COPYSIGN,\n\tWASM_OP_F64ABS,\n\tWASM_OP_F64NEG,\n\tWASM_OP_F64CEIL,\n\tWASM_OP_F64FLOOR,\n\tWASM_OP_F64TRUNC,\n\tWASM_OP_F64NEAREST,\n\tWASM_OP_F64SQRT,\n\tWASM_OP_F64ADD,\n\tWASM_OP_F64SUB,\n\tWASM_OP_F64MUL,\n\tWASM_OP_F64DIV,\n\tWASM_OP_F64MIN,\n\tWASM_OP_F64MAX,\n\tWASM_OP_F64COPYSIGN,\n\n\t// Conversions\n\tWASM_OP_I32WRAPI64,\n\tWASM_OP_I32TRUNCSF32,\n\tWASM_OP_I32TRUNCUF32,\n\tWASM_OP_I32TRUNCSF64,\n\tWASM_OP_I32TRUNCUF64,\n\tWASM_OP_I64EXTENDSI32,\n\tWASM_OP_I64EXTENDUI32,\n\tWASM_OP_I64TRUNCSF32,\n\tWASM_OP_I64TRUNCUF32,\n\tWASM_OP_I64TRUNCSF64,\n\tWASM_OP_I64TRUNCUF64,\n\tWASM_OP_F32CONVERTSI32,\n\tWASM_OP_F32CONVERTUI32,\n\tWASM_OP_F32CONVERTSI64,\n\tWASM_OP_F32CONVERTUI64,\n\tWASM_OP_F32DEMOTEF64,\n\tWASM_OP_F64CONVERTSI32,\n\tWASM_OP_F64CONVERTUI32,\n\tWASM_OP_F64CONVERTSI64,\n\tWASM_OP_F64CONVERTUI64,\n\tWASM_OP_F64PROMOTEF32,\n\n\t// Reinterpretations\n\tWASM_OP_I32REINTERPRETF32,\n\tWASM_OP_I64REINTERPRETF64,\n\tWASM_OP_F32REINTERPRETI32,\n\tWASM_OP_F64REINTERPRETI64,\n\n\t// Extensions\n\t// ...\n} WasmOpCodes;\n\ntypedef struct {\n\tWasmOpCodes op;\n\tint len;\n\tchar txt[R_ASM_BUFSIZE];\n} WasmOp;\n\ntypedef struct {\n\tconst char *txt;\n\tsize_t min, max;\n} WasmOpDef;\n\nstatic WasmOpDef opcodes[256] = {\n\t[WASM_OP_TRAP] = { \"trap\", 1, 1 },\n\t[WASM_OP_NOP] = { \"nop\", 1, 1 },\n\t[WASM_OP_BLOCK] = { \"block\", 2, 2 },\n\t[WASM_OP_LOOP] = { \"loop\", 2, 2 },\n\t[WASM_OP_IF] = { \"if\", 2, 2 },\n\t[WASM_OP_ELSE] = { \"else\", 1, 1 },\n\t[WASM_OP_END] = { \"end\", 1, 1 },\n\t[WASM_OP_BR] = { \"br\", 2, 2 },\n\t[WASM_OP_BRIF] = { \"br_if\", 2, 2 },\n\t[WASM_OP_BRTABLE] = { \"brtable\", 3, 0 },\n\t[WASM_OP_RETURN] = { \"return\", 1, 1 },\n\t[WASM_OP_CALL] = { \"call\" , 2, 2 },\n\t[WASM_OP_CALLINDIRECT] = { \"call_indirect\", 3, 3 },\n\t[WASM_OP_DROP] = { \"drop\", 1, 1 },\n\t[WASM_OP_SELECT] = { \"select\", 1, 1 },\n\t[WASM_OP_GETLOCAL] = { \"get_local\", 2, 2 },\n\t[WASM_OP_SETLOCAL] = { \"set_local\", 2, 2 },\n\t[WASM_OP_TEELOCAL] = { \"tee_local\", 2, 2 },\n\t[WASM_OP_GETGLOBAL] = { \"get_global\", 2, 2 },\n\t[WASM_OP_SETGLOBAL] = { \"set_global\", 2, 2 },\n\t[WASM_OP_I32LOAD] = { \"i32.load\", 3, 3 },\n\t[WASM_OP_I64LOAD] = { \"i64.load\", 3, 3 },\n\t[WASM_OP_F32LOAD] = { \"f32.load\", 3, 3 },\n\t[WASM_OP_F64LOAD] = { \"f64.load\", 3, 3 },\n\t[WASM_OP_I32LOAD8S] = { \"i32.load8_s\", 3, 3 },\n\t[WASM_OP_I32LOAD8U] = { \"i32.load8_u\", 3, 3 },\n\t[WASM_OP_I32LOAD16S] = { \"i32.load16_s\", 3, 3 },\n\t[WASM_OP_I32LOAD16U] = { \"i32.load_16_u\", 3, 3 },\n\t[WASM_OP_I64LOAD8S] = { \"i64.load8_s\", 3, 3 },\n\t[WASM_OP_I64LOAD8U] = { \"i64.load8_u\", 3, 3 },\n\t[WASM_OP_I64LOAD16S] = { \"i64.load16_s\", 3, 3 },\n\t[WASM_OP_I64LOAD16U] = { \"i64.load16_u\", 3, 3 },\n\t[WASM_OP_I64LOAD32S] = { \"i64.load32_s\", 3, 3 },\n\t[WASM_OP_I64LOAD32U] = { \"i64.load32_u\", 3, 3 },\n\t[WASM_OP_I32STORE] = { \"i32.store\", 3, 3 },\n\t[WASM_OP_I64STORE] = { \"i64.store\", 3, 3 },\n\t[WASM_OP_F32STORE] = { \"f32.store\", 3, 3 },\n\t[WASM_OP_F64STORE] = { \"f64.store\", 3, 3 },\n\t[WASM_OP_I32STORE8] = { \"i32.store8\", 3, 3 },\n\t[WASM_OP_I32STORE16] = { \"i32.store16\", 3, 3 },\n\t[WASM_OP_I64STORE8] = { \"i64.store8\", 3, 3 },\n\t[WASM_OP_I64STORE16] = { \"i64.store16\", 3, 3 },\n\t[WASM_OP_I64STORE32] = { \"i64.store32\", 3, 3 },\n\t[WASM_OP_CURRENTMEMORY] = { \"current_memory\", 2, 2 },\n\t[WASM_OP_GROWMEMORY] = { \"grow_memory\", 2, 2 },\n\t[WASM_OP_I32CONST] = { \"i32.const\", 2, 2 },\n\t[WASM_OP_I64CONST] = { \"i64.const\", 2, 2 },\n\t[WASM_OP_F32CONST] = { \"f32.const\", 2, 2 },\n\t[WASM_OP_F64CONST] = { \"f64.const\", 2, 2 },\n\t[WASM_OP_I32EQZ] = { \"i32.eqz\", 1, 1 },\n\t[WASM_OP_I32EQ] = { \"i32.eq\", 1, 1 },\n\t[WASM_OP_I32NE] = { \"i32.ne\", 1, 1},\n\t[WASM_OP_I32LTS] = { \"i32.lt_s\", 1, 1 },\n\t[WASM_OP_I32LTU] = { \"i32.lt_u\", 1, 1 },\n\t[WASM_OP_I32GTS] = { \"i32.gt_s\", 1, 1 },\n\t[WASM_OP_I32GTU] = { \"i32.gt_u\", 1, 1 },\n\t[WASM_OP_I32LES] = { \"i32.le_s\", 1, 1 },\n\t[WASM_OP_I32LEU] = { \"i32.le_u\", 1, 1 },\n\t[WASM_OP_I32GES] = { \"i32.ge_s\", 1, 1 },\n\t[WASM_OP_I32GEU] = { \"i32.ge_u\", 1, 1 },\n\t[WASM_OP_I64EQZ] = { \"i64.eqz\", 1, 1 },\n\t[WASM_OP_I64EQ] = {\" i64.eq\", 1, 1 },\n\t[WASM_OP_I64NE] = {\" i64.ne\", 1, 1 },\n\t[WASM_OP_I64LTS] = { \"i64.lt_s\", 1, 1 },\n\t[WASM_OP_I64LTU] = { \"i64.lt_u\", 1, 1 },\n\t[WASM_OP_I64GTS] = { \"i64.gt_s\", 1, 1 },\n\t[WASM_OP_I64GTU] = { \"i64.gt_u\", 1, 1 },\n\t[WASM_OP_I64LES] = { \"i64.le_s\", 1, 1 },\n\t[WASM_OP_I64LEU] = { \"i64.le_u\", 1, 1 },\n\t[WASM_OP_I64GES] = { \"i64.ge_s\", 1, 1 },\n\t[WASM_OP_I64GEU] = { \"i64.ge_u\", 1, 1 },\n\t[WASM_OP_F32EQ] = { \"f32.eq\", 1, 1 },\n\t[WASM_OP_F32NE] = { \"f32.ne\", 1, 1 },\n\t[WASM_OP_F32LT] = { \"f32.lt\", 1, 1 },\n\t[WASM_OP_F32GT] = { \"f32.gt\", 1, 1 },\n\t[WASM_OP_F32LE] = { \"f32.le\", 1, 1 },\n\t[WASM_OP_F32GE] = { \"f32.ge\", 1, 1 },\n\t[WASM_OP_F64EQ] = { \"f64.eq\", 1, 1 },\n\t[WASM_OP_F64NE] = { \"f64.ne\", 1, 1 },\n\t[WASM_OP_F64LT] = { \"f64.lt\", 1, 1 },\n\t[WASM_OP_F64GT] = { \"f64.gt\", 1, 1 },\n\t[WASM_OP_F64LE] = { \"f64.le\", 1, 1 },\n\t[WASM_OP_F64GE] = { \"f64.ge\", 1, 1 },\n\t[WASM_OP_I32CLZ] = { \"i32.clz\", 1, 1 },\n\t[WASM_OP_I32CTZ] = { \"i32.ctz\", 1, 1 },\n\t[WASM_OP_I32POPCNT] = { \"i32.popcnt\", 1, 1 },\n\t[WASM_OP_I32ADD] = { \"i32.add\", 1, 1 },\n\t[WASM_OP_I32SUB] = { \"i32.sub\", 1, 1 },\n\t[WASM_OP_I32MUL] = { \"i32.mul\", 1, 1 },\n\t[WASM_OP_I32DIVS] = { \"i32.div_s\", 1, 1 },\n\t[WASM_OP_I32DIVU] = { \"i32.div_u\", 1, 1 },\n\t[WASM_OP_I32REMS] = { \"i32.rem_s\", 1, 1 },\n\t[WASM_OP_I32REMU] = { \"i32.rem_u\", 1, 1 },\n\t[WASM_OP_I32AND] = { \"i32.and\", 1, 1 },\n\t[WASM_OP_I32OR] = { \"i32.or\", 1, 1 },\n\t[WASM_OP_I32XOR] = { \"i32.xor\", 1, 1 },\n\t[WASM_OP_I32SHL] = { \"i32.shl\", 1, 1 },\n\t[WASM_OP_I32SHRS] = { \"i32.shr_s\", 1, 1 },\n\t[WASM_OP_I32SHRU] = { \"i32.shr_u\", 1, 1 },\n\t[WASM_OP_I32ROTL] = { \"i32.rotl\", 1, 1 },\n\t[WASM_OP_I32ROTR] = { \"i32.rotr\", 1, 1 },\n\t[WASM_OP_I64CLZ] = { \"i64.clz\", 1, 1 },\n\t[WASM_OP_I64CTZ] = { \"i64.ctz\", 1, 1 },\n\t[WASM_OP_I64POPCNT] = { \"i64.popcnt\", 1, 1 },\n\t[WASM_OP_I64ADD] = { \"i64.add\", 1, 1 },\n\t[WASM_OP_I64SUB] = { \"i64.sub\", 1, 1 },\n\t[WASM_OP_I64MUL] = { \"i64.mul\", 1, 1 },\n\t[WASM_OP_I64DIVS] = { \"i64.div_s\", 1, 1 },\n\t[WASM_OP_I64DIVU] = { \"i64.div_u\", 1, 1 },\n\t[WASM_OP_I64REMS] = { \"i64.rem_s\", 1, 1 },\n\t[WASM_OP_I64REMU] = { \"i64.rem_u\", 1, 1 },\n\t[WASM_OP_I64AND] = { \"i64.and\", 1, 1 },\n\t[WASM_OP_I64OR] = { \"i64.or\", 1, 1 },\n\t[WASM_OP_I64XOR] = { \"i64.xor\", 1, 1 },\n\t[WASM_OP_I64SHL] = { \"i64.shl\", 1, 1 },\n\t[WASM_OP_I64SHRS] = { \"i64.shr_s\", 1, 1 },\n\t[WASM_OP_I64SHRU] = { \"i64.shr_u\", 1, 1 },\n\t[WASM_OP_I64ROTL] = { \"i64.rotl\", 1, 1 },\n\t[WASM_OP_I64ROTR] = { \"i64.rotr\", 1, 1 },\n\t[WASM_OP_F32ABS] = { \"f32.abs\", 1, 1 },\n\t[WASM_OP_F32NEG] = { \"f32.neg\", 1, 1 },\n\t[WASM_OP_F32CEIL] = { \"f32.ceil\", 1, 1 },\n\t[WASM_OP_F32FLOOR] = { \"f32.floor\", 1, 1 },\n\t[WASM_OP_F32TRUNC] = { \"f32.trunc\", 1, 1 },\n\t[WASM_OP_F32NEAREST] = { \"f32.nearest\", 1, 1 },\n\t[WASM_OP_F32SQRT] = { \"f32.sqrt\", 1, 1 },\n\t[WASM_OP_F32ADD] = { \"f32.add\", 1, 1 },\n\t[WASM_OP_F32SUB] =  { \"f32.sub\", 1, 1 },\n\t[WASM_OP_F32MUL] = { \"f32.mul\", 1, 1 },\n\t[WASM_OP_F32DIV] = { \"f32.div\", 1, 1 },\n\t[WASM_OP_F32MIN] = { \"f32.min\", 1, 1 },\n\t[WASM_OP_F32MAX] = { \"f32.max\", 1, 1 },\n\t[WASM_OP_F32COPYSIGN] = {\" f32.copysign\", 1, 1 },\n\t[WASM_OP_F64ABS] = { \"f64.abs\", 1, 1 },\n\t[WASM_OP_F64NEG] = { \"f64.neg\", 1, 1 },\n\t[WASM_OP_F64CEIL] = { \"f64.ceil\", 1, 1 },\n\t[WASM_OP_F64FLOOR] = { \"f64.floor\", 1, 1 },\n\t[WASM_OP_F64TRUNC] = { \"f64.trunc\", 1, 1 },\n\t[WASM_OP_F64NEAREST] = { \"f64.nearest\", 1, 1 },\n\t[WASM_OP_F64SQRT] = { \"f64.sqrt\", 1, 1 },\n\t[WASM_OP_F64ADD] = { \"f64.add\", 1, 1 },\n\t[WASM_OP_F64SUB] = { \"f64.sub\", 1, 1 },\n\t[WASM_OP_F64MUL] = { \"f64.mul\", 1, 1 },\n\t[WASM_OP_F64DIV] = { \"f64.div\", 1, 1 },\n\t[WASM_OP_F64MIN] = { \"f64.min\", 1, 1 },\n\t[WASM_OP_F64MAX] = { \"f64.max\", 1, 1 },\n\t[WASM_OP_F64COPYSIGN] = { \"f64.copysign\", 1, 1 },\n\t[WASM_OP_I32WRAPI64] = { \"i32.wrap/i64\", 1, 1 },\n\t[WASM_OP_I32TRUNCSF32] = { \"i32.trunc_s/f32\", 1, 1 },\n\t[WASM_OP_I32TRUNCUF32] = { \"i32.trunc_u/f32\", 1, 1 },\n\t[WASM_OP_I32TRUNCSF64] = { \"i32.trunc_s/f64\", 1, 1 },\n\t[WASM_OP_I32TRUNCUF64] = { \"i32.trunc_u/f64\", 1, 1 },\n\t[WASM_OP_I64EXTENDSI32] = { \"i64.extend_s/i32\", 1, 1 },\n\t[WASM_OP_I64EXTENDUI32] = { \"i64.extend_u/i32\", 1, 1 },\n\t[WASM_OP_I64TRUNCSF32] = { \"i64.trunc_s/f32\", 1, 1 },\n\t[WASM_OP_I64TRUNCUF32] = { \"i64.trunc_u/f32\", 1, 1 },\n\t[WASM_OP_I64TRUNCSF64] = { \"i64.trunc_s/f64\", 1, 1 },\n\t[WASM_OP_I64TRUNCUF64] = { \"i64.trunc_u/f64\", 1, 1 },\n\t[WASM_OP_F32CONVERTSI32] = { \"f32.convert_s/i32\", 1, 1 },\n\t[WASM_OP_F32CONVERTUI32] = { \"f32.convert_u/i32\", 1, 1 },\n\t[WASM_OP_F32CONVERTSI64] = { \"f32.convert_s/i64\", 1, 1 },\n\t[WASM_OP_F32CONVERTUI64] = { \"f32.convert_u/i64\", 1, 1 },\n\t[WASM_OP_F32DEMOTEF64] = { \"f32.demote/f64\", 1, 1 },\n\t[WASM_OP_F64CONVERTSI32] = { \"f64.convert_s/i32\", 1, 1 },\n\t[WASM_OP_F64CONVERTUI32] = { \"f64.convert_u/i32\", 1, 1 },\n\t[WASM_OP_F64CONVERTSI64] = { \"f64.convert_s/i64\", 1, 1 },\n\t[WASM_OP_F64CONVERTUI64] = { \"f64.convert_u/i64\", 1, 1 },\n\t[WASM_OP_F64PROMOTEF32] = { \"f64.promote/f32\", 1, 1 },\n\t[WASM_OP_I32REINTERPRETF32] = { \"i32.reinterpret/f32\", 1, 1 },\n\t[WASM_OP_I64REINTERPRETF64] = { \"i64.reinterpret/f64\", 1, 1 },\n\t[WASM_OP_F32REINTERPRETI32] = { \"f32.reinterpret/i32\", 1, 1 },\n\t[WASM_OP_F64REINTERPRETI64] = { \"f64/reinterpret/i64\", 1, 1 }\n};\n\nint wasm_asm(const char *str, unsigned char *buf, int buf_len) {\n\t// TODO: add immediates assembly\n\tint i = 0, len = -1;\n\tchar tmp[R_ASM_BUFSIZE];\n\twhile (str[i] != ' ' && i < buf_len) {\n\t\ttmp[i] = str[i];\n\t\ti++;\n\t}\n\ttmp[i] = 0;\n\tfor (i = 0; i < 0xff; i++) {\n\t\tWasmOpDef *opdef = &opcodes[i];\n\t\tif (opdef->txt) {\n\t\t\tif (!strcmp (opdef->txt, tmp)) {\n\t\t\t\tbuf[0] = i;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn len;\n}\n\nint wasm_dis(WasmOp *op, const unsigned char *buf, int buf_len) {\n\top->len = 1;\n\top->op = buf[0];\n\tif (op->op > 0xbf) {\n\t\treturn 1;\n\t}\n\t// add support for extension opcodes (SIMD + atomics)\n\tWasmOpDef *opdef = &opcodes[op->op];\n\tswitch (op->op) {\n\tcase WASM_OP_TRAP:\n\tcase WASM_OP_NOP:\n\tcase WASM_OP_ELSE:\n\tcase WASM_OP_RETURN:\n\tcase WASM_OP_DROP:\n\tcase WASM_OP_SELECT:\n\tcase WASM_OP_I32EQZ: \n\tcase WASM_OP_I32EQ: \n\tcase WASM_OP_I32NE: \n\tcase WASM_OP_I32LTS: \n\tcase WASM_OP_I32LTU: \n\tcase WASM_OP_I32GTS: \n\tcase WASM_OP_I32GTU: \n\tcase WASM_OP_I32LES: \n\tcase WASM_OP_I32LEU: \n\tcase WASM_OP_I32GES: \n\tcase WASM_OP_I32GEU: \n\tcase WASM_OP_I64EQZ: \n\tcase WASM_OP_I64EQ: \n\tcase WASM_OP_I64NE: \n\tcase WASM_OP_I64LTS: \n\tcase WASM_OP_I64LTU: \n\tcase WASM_OP_I64GTS: \n\tcase WASM_OP_I64GTU: \n\tcase WASM_OP_I64LES: \n\tcase WASM_OP_I64LEU: \n\tcase WASM_OP_I64GES: \n\tcase WASM_OP_I64GEU: \n\tcase WASM_OP_F32EQ: \n\tcase WASM_OP_F32NE: \n\tcase WASM_OP_F32LT: \n\tcase WASM_OP_F32GT: \n\tcase WASM_OP_F32LE: \n\tcase WASM_OP_F32GE: \n\tcase WASM_OP_F64EQ: \n\tcase WASM_OP_F64NE: \n\tcase WASM_OP_F64LT: \n\tcase WASM_OP_F64GT: \n\tcase WASM_OP_F64LE: \n\tcase WASM_OP_F64GE: \n\tcase WASM_OP_I32CLZ: \n\tcase WASM_OP_I32CTZ: \n\tcase WASM_OP_I32POPCNT: \n\tcase WASM_OP_I32ADD: \n\tcase WASM_OP_I32SUB: \n\tcase WASM_OP_I32MUL: \n\tcase WASM_OP_I32DIVS: \n\tcase WASM_OP_I32DIVU: \n\tcase WASM_OP_I32REMS: \n\tcase WASM_OP_I32REMU: \n\tcase WASM_OP_I32AND: \n\tcase WASM_OP_I32OR: \n\tcase WASM_OP_I32XOR: \n\tcase WASM_OP_I32SHL: \n\tcase WASM_OP_I32SHRS: \n\tcase WASM_OP_I32SHRU: \n\tcase WASM_OP_I32ROTL: \n\tcase WASM_OP_I32ROTR: \n\tcase WASM_OP_I64CLZ: \n\tcase WASM_OP_I64CTZ: \n\tcase WASM_OP_I64POPCNT: \n\tcase WASM_OP_I64ADD: \n\tcase WASM_OP_I64SUB: \n\tcase WASM_OP_I64MUL: \n\tcase WASM_OP_I64DIVS: \n\tcase WASM_OP_I64DIVU: \n\tcase WASM_OP_I64REMS: \n\tcase WASM_OP_I64REMU: \n\tcase WASM_OP_I64AND: \n\tcase WASM_OP_I64OR: \n\tcase WASM_OP_I64XOR: \n\tcase WASM_OP_I64SHL: \n\tcase WASM_OP_I64SHRS: \n\tcase WASM_OP_I64SHRU: \n\tcase WASM_OP_I64ROTL: \n\tcase WASM_OP_I64ROTR: \n\tcase WASM_OP_F32ABS: \n\tcase WASM_OP_F32NEG: \n\tcase WASM_OP_F32CEIL: \n\tcase WASM_OP_F32FLOOR: \n\tcase WASM_OP_F32TRUNC: \n\tcase WASM_OP_F32NEAREST: \n\tcase WASM_OP_F32SQRT: \n\tcase WASM_OP_F32ADD: \n\tcase WASM_OP_F32SUB: \n\tcase WASM_OP_F32MUL: \n\tcase WASM_OP_F32DIV: \n\tcase WASM_OP_F32MIN: \n\tcase WASM_OP_F32MAX: \n\tcase WASM_OP_F32COPYSIGN: \n\tcase WASM_OP_F64ABS: \n\tcase WASM_OP_F64NEG: \n\tcase WASM_OP_F64CEIL: \n\tcase WASM_OP_F64FLOOR: \n\tcase WASM_OP_F64TRUNC: \n\tcase WASM_OP_F64NEAREST: \n\tcase WASM_OP_F64SQRT: \n\tcase WASM_OP_F64ADD: \n\tcase WASM_OP_F64SUB: \n\tcase WASM_OP_F64MUL: \n\tcase WASM_OP_F64DIV: \n\tcase WASM_OP_F64MIN: \n\tcase WASM_OP_F64MAX: \n\tcase WASM_OP_F64COPYSIGN: \n\tcase WASM_OP_I32WRAPI64: \n\tcase WASM_OP_I32TRUNCSF32: \n\tcase WASM_OP_I32TRUNCUF32: \n\tcase WASM_OP_I32TRUNCSF64: \n\tcase WASM_OP_I32TRUNCUF64: \n\tcase WASM_OP_I64EXTENDSI32: \n\tcase WASM_OP_I64EXTENDUI32: \n\tcase WASM_OP_I64TRUNCSF32: \n\tcase WASM_OP_I64TRUNCUF32: \n\tcase WASM_OP_I64TRUNCSF64: \n\tcase WASM_OP_I64TRUNCUF64: \n\tcase WASM_OP_F32CONVERTSI32: \n\tcase WASM_OP_F32CONVERTUI32: \n\tcase WASM_OP_F32CONVERTSI64: \n\tcase WASM_OP_F32CONVERTUI64: \n\tcase WASM_OP_F32DEMOTEF64: \n\tcase WASM_OP_F64CONVERTSI32: \n\tcase WASM_OP_F64CONVERTUI32: \n\tcase WASM_OP_F64CONVERTSI64: \n\tcase WASM_OP_F64CONVERTUI64: \n\tcase WASM_OP_F64PROMOTEF32: \n\tcase WASM_OP_I32REINTERPRETF32: \n\tcase WASM_OP_I64REINTERPRETF64: \n\tcase WASM_OP_F32REINTERPRETI32: \n\tcase WASM_OP_F64REINTERPRETI64:\n\tcase WASM_OP_END:\n\t\t{\n\t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s\", opdef->txt);\n\t\t}\n\t\tbreak;\n\tcase WASM_OP_BLOCK:\n\tcase WASM_OP_LOOP:\n\tcase WASM_OP_IF:\n\t\t{\n\t\t\tst32 val = 0;\n\t\t\tsize_t n = read_i32_leb128 (buf + 1, buf + buf_len, &val);\n\t\t\tif (!(n > 0 && n < buf_len)) goto err;\n\t\t\tswitch (0x80 - val) {\n\t\t\tcase R_BIN_WASM_VALUETYPE_EMPTY:\n\t\t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s\", opdef->txt);\n\t\t\t\tbreak;\n\t\t\tcase R_BIN_WASM_VALUETYPE_i32:\n\t\t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s (result i32)\", opdef->txt);\n\t\t\t\tbreak;\n\t\t\tcase R_BIN_WASM_VALUETYPE_i64:\n\t\t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s (result i64)\", opdef->txt);\n\t\t\t\tbreak;\n\t\t\tcase R_BIN_WASM_VALUETYPE_f32:\n\t\t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s (result f32)\", opdef->txt);\n\t\t\t\tbreak;\n\t\t\tcase R_BIN_WASM_VALUETYPE_f64:\n\t\t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s (result f64)\", opdef->txt);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s (result ?)\", opdef->txt);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\top->len += n;\n\t\t}\n\t\tbreak;\n\tcase WASM_OP_BR:\n\tcase WASM_OP_BRIF:\n\tcase WASM_OP_CALL:\n\t\t{\n\t\t\tut32 val = 0;\n\t\t\tsize_t n = read_u32_leb128 (buf + 1, buf + buf_len, &val);\n\t\t\tif (!(n > 0 && n < buf_len)) goto err;\n\t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s %d\", opdef->txt, val);\n\t\t\top->len += n;\n\t\t}\n\t\tbreak;\n\tcase WASM_OP_BRTABLE:\n\t\t{\n\t\t\tut32 count = 0, *table = NULL, def = 0;\n\t\t\tsize_t n = read_u32_leb128 (buf + 1, buf + buf_len, &count);\n\t\t\tif (!(n > 0 && n < buf_len)) {\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tif (!(table = calloc (count, sizeof (ut32)))) {\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tint i = 0;\n\t\t\top->len += n;\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tn = read_u32_leb128 (buf + op->len, buf + buf_len, &table[i]);\n\t\t\t\tif (!(op->len + n <= buf_len)) {\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t\top->len += n;\n\t\t\t}\n\t\t\tn = read_u32_leb128 (buf + op->len, buf + buf_len, &def);\n\t\t\tif (!(n > 0 && n + op->len < buf_len)) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\top->len += n;\n\t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s %d \", opdef->txt, count);\n\t\t\tfor (i = 0; i < count && strlen (op->txt) + 10 < R_ASM_BUFSIZE; i++) {\n\t\t\t\tint optxtlen = strlen (op->txt);\n\t\t\t\tsnprintf (op->txt + optxtlen, R_ASM_BUFSIZE - optxtlen, \"%d \", table[i]);\n\t\t\t}\t\n\t\t\tsnprintf (op->txt + strlen (op->txt), R_ASM_BUFSIZE, \"%d\", def);\n\t\t\tfree (table);\n\t\t\tbreak;\n\t\t\tbeach:\n\t\t\tfree (table);\n\t\t\tgoto err;\n\t\t}\n\t\tbreak;\n\tcase WASM_OP_CALLINDIRECT:\n\t\t{\n\t\t\tut32 val = 0, reserved = 0;\n\t\t\tsize_t n = read_u32_leb128 (buf + 1, buf + buf_len, &val);\n\t\t\tif (!(n > 0 && n < buf_len)) goto err;\n\t\t\top->len += n;\n\t\t\tn = read_u32_leb128 (buf + op->len, buf + buf_len, &reserved);\n\t\t\tif (!(n == 1 && op->len + n <= buf_len)) goto err;\n\t\t\treserved &= 0x1;\n\t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s %d %d\", opdef->txt, val, reserved);\n\t\t\top->len += n;\n\t\t}\n\t\tbreak;\n\tcase WASM_OP_GETLOCAL:\n\tcase WASM_OP_SETLOCAL:\n\tcase WASM_OP_TEELOCAL:\n\tcase WASM_OP_GETGLOBAL:\n\tcase WASM_OP_SETGLOBAL:\n\t\t{\n\t\t\tut32 val = 0;\n\t\t\tsize_t n = read_u32_leb128 (buf + 1, buf + buf_len, &val);\n\t\t\tif (!(n > 0 && n < buf_len)) goto err;\n\t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s %d\", opdef->txt, val);\n\t\t\top->len += n;\n\t\t}\n\t\tbreak;\n\tcase WASM_OP_I32LOAD:\n\tcase WASM_OP_I64LOAD: \n\tcase WASM_OP_F32LOAD: \n\tcase WASM_OP_F64LOAD: \n\tcase WASM_OP_I32LOAD8S: \n\tcase WASM_OP_I32LOAD8U: \n\tcase WASM_OP_I32LOAD16S: \n\tcase WASM_OP_I32LOAD16U: \n\tcase WASM_OP_I64LOAD8S: \n\tcase WASM_OP_I64LOAD8U: \n\tcase WASM_OP_I64LOAD16S: \n\tcase WASM_OP_I64LOAD16U: \n\tcase WASM_OP_I64LOAD32S: \n\tcase WASM_OP_I64LOAD32U: \n\tcase WASM_OP_I32STORE: \n\tcase WASM_OP_I64STORE: \n\tcase WASM_OP_F32STORE: \n\tcase WASM_OP_F64STORE: \n\tcase WASM_OP_I32STORE8: \n\tcase WASM_OP_I32STORE16: \n\tcase WASM_OP_I64STORE8: \n\tcase WASM_OP_I64STORE16: \n\tcase WASM_OP_I64STORE32: \n\t\t{\n\t\t\tut32 flag = 0, offset = 0;\n\t\t\tsize_t n = read_u32_leb128 (buf + 1, buf + buf_len, &flag);\n\t\t\tif (!(n > 0 && n < buf_len)) goto err;\n\t\t\top->len += n;\n\t\t\tn = read_u32_leb128 (buf + op->len, buf + buf_len, &offset);\n\t\t\tif (!(n > 0 && op->len + n <= buf_len)) goto err;\n\t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s %d %d\", opdef->txt, flag, offset);\n\t\t\top->len += n;\n\t\t}\n\t\tbreak;\n\tcase WASM_OP_CURRENTMEMORY:\n\tcase WASM_OP_GROWMEMORY:\n\t\t{\n\t\t\tut32 reserved = 0;\n\t\t\tsize_t n = read_u32_leb128 (buf + 1, buf + buf_len, &reserved);\n\t\t\tif (!(n == 1 && n < buf_len)) goto err;\n\t\t\treserved &= 0x1;\n\t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s %d\", opdef->txt, reserved); \n\t\t\top->len += n;\n\t\t}\n\t\tbreak;\n\n\tcase WASM_OP_I32CONST:\n\t\t{\n\t\t\tst32 val = 0;\n\t\t\tsize_t n = read_i32_leb128 (buf + 1, buf + buf_len, &val);\n\t\t\tif (!(n > 0 && n < buf_len)) goto err;\n\t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s %\" PFMT32d, opdef->txt, val);\n\t\t\top->len += n;\n\t\t}\n\t\tbreak;\n\tcase WASM_OP_I64CONST:\n\t\t{\n\t\t\tst64 val = 0;\n\t\t\tsize_t n = read_i64_leb128 (buf + 1, buf + buf_len, &val);\n\t\t\tif (!(n > 0 && n < buf_len)) goto err;\n\t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s %\" PFMT64d, opdef->txt, val);\n\t\t\top->len += n;\n\t\t}\n\t\tbreak;\n\tcase WASM_OP_F32CONST:\n\t\t{\n\t\t\tut32 val = 0;\n\t\t\tsize_t n = read_u32_leb128 (buf + 1, buf + buf_len, &val);\n\t\t\tif (!(n > 0 && n < buf_len)) goto err;\n\t\t\tlong double d =  (long double)val;\n\t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s %\" LDBLFMT, opdef->txt, d);\n\t\t\top->len += n;\n\t\t}\n\t\tbreak;\n\tcase WASM_OP_F64CONST:\n\t\t{\n\t\t\tut64 val = 0;\n\t\t\tsize_t n = read_u64_leb128 (buf + 1, buf + buf_len, &val);\n\t\t\tif (!(n > 0 && n < buf_len)) goto err;\n\t\t\tlong double d =  (long double)val;\n\t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s %\" LDBLFMT, opdef->txt, d);\n\t\t\top->len += n;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tgoto err;\n\t}\n\n\treturn op->len;\n\nerr:\n\top->len = 1;\n\tsnprintf (op->txt, R_ASM_BUFSIZE, \"invalid\");\n\treturn op->len;\n}\n", "/* radare - LGPL - Copyright 2007-2017 - pancake */\n\n#include <r_flag.h>\n#include <r_util.h>\n#include <r_cons.h>\n#include <stdio.h>\n\nR_LIB_VERSION(r_flag);\n\n#define ISNULLSTR(x) (!(x) || !*(x))\n#define IS_IN_SPACE(f, i) ((f)->space_idx != -1 && (i)->space != (f)->space_idx)\n\nstatic const char *str_callback(RNum *user, ut64 off, int *ok) {\n\tconst RList *list;\n\tRFlag *f = (RFlag*)user;\n\tRFlagItem *item;\n\tif (ok) {\n\t\t*ok = 0;\n\t}\n\tif (f) {\n\t\tlist = r_flag_get_list (f, off);\n\t\titem = r_list_get_top (list);\n\t\tif (item) {\n\t\t\tif (ok) {\n\t\t\t\t*ok = true;\n\t\t\t}\n\t\t\treturn item->name;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic void flag_free_kv(HtKv *kv) {\n\tfree (kv->key);\n\t//we do not free kv->value since there is a reference in other list\n\tfree (kv);\n}\n\nstatic void flag_skiplist_free(void *data) {\n\tRFlagsAtOffset *item = (RFlagsAtOffset *)data;\n\tr_list_free (item->flags);\n\tfree (data);\n}\n\nstatic int flag_skiplist_cmp(const void *va, const void *vb) {\n\tconst RFlagsAtOffset *a = (RFlagsAtOffset *)va, *b = (RFlagsAtOffset *)vb;\n\tif (a->off == b->off) {\n\t\treturn 0;\n\t}\n\treturn a->off < b->off ? -1 : 1;\n}\n\nstatic ut64 num_callback(RNum *user, const char *name, int *ok) {\n\tRFlag *f = (RFlag*)user;\n\tRFlagItem *item;\n\tif (ok) {\n\t\t*ok = 0;\n\t}\n\titem = ht_find (f->ht_name, name, NULL);\n\tif (item) {\n\t\t// NOTE: to avoid warning infinite loop here we avoid recursivity\n\t\tif (item->alias) {\n\t\t\treturn 0LL;\n\t\t}\n\t\tif (ok) {\n\t\t\t*ok = 1;\n\t\t}\n\t\treturn item->offset;\n\t}\n\treturn 0LL;\n}\n\n/* return the list of flag at the nearest position.\n\tdir == -1 -> result <= off\n\tdir == 0 ->  result == off\n\tdir == 1 ->  result >= off*/\nstatic RFlagsAtOffset* r_flag_get_nearest_list(RFlag *f, ut64 off, int dir) {\n\tRFlagsAtOffset *flags = NULL;\n\tRFlagsAtOffset key;\n\tkey.off = off;\n\tif (dir >= 0) {\n\t\tflags = r_skiplist_get_geq (f->by_off, &key);\n\t} else {\n\t\tflags = r_skiplist_get_leq (f->by_off, &key);\n\t}\n\tif (dir == 0 && flags && flags->off != off) {\n\t\treturn NULL;\n\t}\n\treturn flags;\n}\n\nstatic void remove_offsetmap(RFlag *f, RFlagItem *item) {\n\tRFlagsAtOffset *flags = r_flag_get_nearest_list (f, item->offset, 0);\n\tif (flags) {\n\t\tr_list_delete_data (flags->flags, item);\n\t\tif (r_list_empty (flags->flags)) {\n\t\t\tr_skiplist_delete (f->by_off, flags);\n\t\t}\n\t}\n}\n\nstatic int set_name(RFlagItem *item, const char *name) {\n\tif (item->name != item->realname) {\n\t\tfree (item->name);\n\t}\n\titem->name = strdup (name);\n\tif (!item->name) {\n\t\treturn false;\n\t}\n\tr_str_chop (item->name);\n\tr_name_filter (item->name, 0); // TODO: name_filter should be chopping already\n\tfree (item->realname);\n\titem->realname = item->name;\n\treturn true;\n}\n\nR_API RFlag * r_flag_new() {\n\tint i;\n\tRFlag *f = R_NEW0 (RFlag);\n\tif (!f) return NULL;\n\tf->num = r_num_new (&num_callback, &str_callback, f);\n\tif (!f->num) {\n\t\tr_flag_free (f);\n\t\treturn NULL;\n\t}\n\tf->base = 0;\n\tf->cb_printf = (PrintfCallback)printf;\n#if R_FLAG_ZONE_USE_SDB\n\tf->zones = sdb_new0 ();\n#else\n\tf->zones = NULL;\n#endif\n\tf->flags = r_list_new ();\n\tif (!f->flags) {\n\t\tr_flag_free (f);\n\t\treturn NULL;\n\t}\n\tf->flags->free = (RListFree) r_flag_item_free;\n\tf->space_idx = -1;\n\tf->spacestack = r_list_newf (NULL);\n\tif (!f->spacestack) {\n\t\tr_flag_free (f);\n\t\treturn NULL;\n\t}\n\tf->ht_name = ht_new (NULL, flag_free_kv, NULL);\n\tf->by_off = r_skiplist_new (flag_skiplist_free, flag_skiplist_cmp);\n#if R_FLAG_ZONE_USE_SDB\n\tsdb_free (f->zones);\n#else\n\tr_list_free (f->zones);\n#endif\n\tfor (i = 0; i < R_FLAG_SPACES_MAX; i++) {\n\t\tf->spaces[i] = NULL;\n\t}\n\treturn f;\n}\n\nR_API void r_flag_item_free(RFlagItem *item) {\n\tif (item) {\n\t\tfree (item->color);\n\t\tfree (item->comment);\n\t\tfree (item->alias);\n\t\t/* release only one of the two pointers if they are the same */\n\t\tif (item->name != item->realname) {\n\t\t\tfree (item->name);\n\t\t}\n\t\tfree (item->realname);\n\t\tfree (item);\n\t}\n}\n\nR_API RFlag *r_flag_free(RFlag *f) {\n\tint i;\n\tfor (i = 0; i < R_FLAG_SPACES_MAX; i++) {\n\t\tfree (f->spaces[i]);\n\t}\n\tr_skiplist_free (f->by_off);\n\tht_free (f->ht_name);\n\n\tr_list_free (f->flags);\n\tr_list_free (f->spacestack);\n\tr_num_free (f->num);\n\tfree (f);\n\treturn NULL;\n}\n\n/* print with r_cons the flag items in the flag f, given as a parameter */\nR_API void r_flag_list(RFlag *f, int rad, const char *pfx) {\n\tbool in_range = false;\n\tut64 range_from = UT64_MAX;\n\tut64 range_to = UT64_MAX;\n\tint fs = -1;\n\tRListIter *iter;\n\tRFlagItem *flag;\n\tif (rad == 'i') {\n\t\tchar *sp, *arg = strdup (pfx + 1);\n\t\tsp = strchr (arg,  ' ');\n\t\tif (sp) {\n\t\t\t*sp++ = 0;\n\t\t\trange_from = r_num_math (f->num, arg);\n\t\t\trange_to = r_num_math (f->num, sp);\n\t\t} else {\n\t\t\tconst int bsize = 4096;\n\t\t\trange_from = r_num_math (f->num, arg);\n\t\t\trange_to = range_from + bsize;\n\t\t}\n\t\tin_range = true;\n\t\tfree (arg);\n\t\trad = pfx[0];\n\t\tpfx = NULL;\n\t}\n\n\tif (pfx && !*pfx) {\n\t\tpfx = NULL;\n\t}\n\n\tswitch (rad) {\n\tcase 'j': {\n\t\tint first = 1;\n\t\tf->cb_printf (\"[\");\n\t\tr_list_foreach (f->flags, iter, flag) {\n\t\t\tif (IS_IN_SPACE (f, flag)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (in_range && (flag->offset < range_from || flag->offset >= range_to)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tf->cb_printf (\"%s{\\\"name\\\":\\\"%s\\\",\\\"size\\\":%\"PFMT64d\",\",\n\t\t\t\tfirst?\"\":\",\", flag->name, flag->size);\n\t\t\tif (flag->alias) {\n\t\t\t\tf->cb_printf (\"\\\"alias\\\":\\\"%s\\\"\", flag->alias);\n\t\t\t} else {\n\t\t\t\tf->cb_printf (\"\\\"offset\\\":%\"PFMT64d, flag->offset);\n\t\t\t}\n\t\t\tif (flag->comment)\n\t\t\t\tf->cb_printf (\",\\\"comment\\\":\\\"}\");\n\t\t\telse f->cb_printf (\"}\");\n\t\t\tfirst = 0;\n\t\t}\n\t\tf->cb_printf (\"]\\n\");\n\t\t}\n\t\tbreak;\n\tcase 1:\n\tcase '*':\n\t\tr_list_foreach (f->flags, iter, flag) {\n\t\t\tif (IS_IN_SPACE (f, flag)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (in_range && (flag->offset < range_from || flag->offset >= range_to)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (fs == -1 || flag->space != fs) {\n\t\t\t\tconst char *flagspace;\n\t\t\t\tfs = flag->space;\n\t\t\t\tflagspace = r_flag_space_get_i (f, fs);\n\t\t\t\tif (!flagspace || !*flagspace)\n\t\t\t\t\tflagspace = \"*\";\n\t\t\t\tf->cb_printf (\"fs %s\\n\", flagspace);\n\t\t\t}\n\t\t\tif (flag->alias) {\n\t\t\t\tf->cb_printf (\"fa %s %s\\n\", flag->name, flag->alias);\n\t\t\t\tif (flag->comment && *flag->comment)\n\t\t\t\t\tf->cb_printf (\"\\\"fC %s %s\\\"\\n\",\n\t\t\t\t\t\tflag->name, flag->comment);\n\t\t\t} else {\n\t\t\t\tf->cb_printf (\"f %s %\"PFMT64d\" 0x%08\"PFMT64x\"%s%s %s\\n\",\n\t\t\t\t\tflag->name, flag->size, flag->offset,\n\t\t\t\t\tpfx?\"+\":\"\", pfx?pfx:\"\",\n\t\t\t\t\tflag->comment? flag->comment:\"\");\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'n': // show original name\n\t\tr_list_foreach (f->flags, iter, flag) {\n\t\t\tif (IS_IN_SPACE (f, flag)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (in_range && (flag->offset < range_from || flag->offset >= range_to)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (flag->alias) {\n\t\t\t\tf->cb_printf (\"%s %\"PFMT64d\" %s\\n\",\n\t\t\t\t\t\tflag->alias, flag->size, flag->realname);\n\t\t\t} else {\n\t\t\t\tf->cb_printf (\"0x%08\"PFMT64x\" %\"PFMT64d\" %s\\n\",\n\t\t\t\t\t\tflag->offset, flag->size, flag->realname);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tr_list_foreach (f->flags, iter, flag) {\n\t\t\tif (IS_IN_SPACE (f, flag)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (in_range && (flag->offset < range_from || flag->offset >= range_to)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (flag->alias) {\n\t\t\t\tf->cb_printf (\"%s %\"PFMT64d\" %s\\n\",\n\t\t\t\t\tflag->alias, flag->size, flag->name);\n\t\t\t} else {\n\t\t\t\tf->cb_printf (\"0x%08\"PFMT64x\" %\"PFMT64d\" %s\\n\",\n\t\t\t\t\tflag->offset, flag->size, flag->name);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic RFlagItem *evalFlag(RFlag *f, RFlagItem *item) {\n\tif (item && item->alias) {\n\t\titem->offset = r_num_math (f->num, item->alias);\n\t}\n\treturn item;\n}\n\n/* return true if flag.* exist at offset. Otherwise, false is returned.\n * For example (f, \"sym\", 3, 0x1000)*/\nR_API bool r_flag_exist_at(RFlag *f, const char *flag_prefix, ut16 fp_size, ut64 off) {\n\tRListIter *iter = NULL;\n\tRFlagItem *item = NULL;\n\tif (!f) {\n\t\treturn false;\n\t}\n\tconst RList *list = r_flag_get_list (f, off);\n\tif (!list) {\n\t\treturn false;\n\t}\n\tr_list_foreach (list, iter, item) {\n\t\tif (item->name && !strncmp (item->name, flag_prefix, fp_size)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n/* return the flag item with name \"name\" in the RFlag \"f\", if it exists.\n * Otherwise, NULL is returned. */\nR_API RFlagItem *r_flag_get(RFlag *f, const char *name) {\n\tRFlagItem *r;\n\tif (!f) {\n\t\treturn NULL;\n\t}\n\tr = ht_find (f->ht_name, name, NULL);\n\treturn evalFlag (f, r);\n}\n\n/* return the first flag item that can be found at offset \"off\", or NULL otherwise */\nR_API RFlagItem *r_flag_get_i(RFlag *f, ut64 off) {\n\tconst RList *list;\n\tif (!f) {\n\t\treturn NULL;\n\t}\n\tlist = r_flag_get_list (f, off);\n\treturn list ? evalFlag (f, r_list_get_top (list)) : NULL;\n}\n\n/* return the first flag item at offset \"off\" that doesn't start with \"loc.\",\n * \"fcn.\", \"section.\" or NULL if such a flag doesn't exist.\n *\n * XXX: this function is buggy and it's not really clear what's the purpose */\nR_API RFlagItem *r_flag_get_i2(RFlag *f, ut64 off) {\n\tRFlagItem *oitem = NULL, *item = NULL;\n\tRListIter *iter;\n\tconst RList *list = r_flag_get_list (f, off);\n\tif (!list) {\n\t\treturn NULL;\n\t}\n\tr_list_foreach (list, iter, item) {\n\t\tif (!item->name) {\n\t\t\tcontinue;\n\t\t}\n\t\t/* catch sym. first */\n\t\tif (!strncmp (item->name, \"loc.\", 4)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strncmp (item->name, \"fcn.\", 4)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strncmp (item->name, \"section.\", 8)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strncmp (item->name, \"section_end.\", 12)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (r_str_nlen (item->name, 5) > 4 &&\n\t\t    item->name[3] == '.') {\n\t\t\toitem = item;\n\t\t\tbreak;\n\t\t}\n\t\toitem = item;\n\t\tif (strlen (item->name) < 5 || item->name[3]!='.') continue;\n\t\toitem = item;\n\t}\n\treturn evalFlag (f, oitem);\n}\n\nstatic bool isFunctionFlag(const char *n) {\n\treturn (!strncmp (n, \"sym.func.\", 9)\n\t|| !strncmp (n, \"method.\", 7)\n\t|| !strncmp (n, \"sym.\", 7)\n\t|| !strncmp (n, \"func.\", 5)\n\t|| !strncmp (n, \"fcn.0\", 5));\n}\n\n/* returns the last flag item defined before or at the given offset.\n * NULL is returned if such a item is not found. */\nR_API RFlagItem *r_flag_get_at(RFlag *f, ut64 off, bool closest) {\n\tRFlagItem *item, *nice = NULL;\n\tRListIter *iter;\n\tconst RFlagsAtOffset *flags_at = r_flag_get_nearest_list (f, off, -1);\n\tif (!flags_at) {\n\t\treturn NULL;\n\t}\n\tif (flags_at->off == off) {\n\t\tr_list_foreach (flags_at->flags, iter, item) {\n\t\t\tif (f->space_idx != -1 && item->space != f->space_idx) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (nice) {\n\t\t\t\tif (isFunctionFlag (nice->name)) {\n\t\t\t\t\tnice = item;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnice = item;\n\t\t\t}\n\t\t}\n\t\treturn nice;\n\t}\n\n\tif (!closest) {\n\t\treturn NULL;\n\t}\n\twhile (!nice && flags_at) {\n\t\tr_list_foreach (flags_at->flags, iter, item) {\n\t\t\tif (f->space_strict && IS_IN_SPACE (f, item)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (item->offset == off) {\n\t\t\t\teprintf (\"XXX Should never happend\\n\");\n\t\t\t\treturn evalFlag (f, item);\n\t\t\t}\n\t\t\tnice = item;\n\t\t\tbreak;\n\t\t}\n\t\tif (flags_at->off) {\n\t\t\tflags_at = r_flag_get_nearest_list (f, flags_at->off - 1, -1);\n\t\t} else {\n\t\t\tflags_at = NULL;\n\t\t}\n\t}\n\treturn evalFlag (f, nice);\n}\n\n/* return the list of flag items that are associated with a given offset */\nR_API const RList* /*<RFlagItem*>*/ r_flag_get_list(RFlag *f, ut64 off) {\n\tconst RFlagsAtOffset *item = r_flag_get_nearest_list (f, off, 0);\n\treturn item ? item->flags : NULL;\n}\n\nR_API char *r_flag_get_liststr(RFlag *f, ut64 off) {\n\tRFlagItem *fi;\n\tRListIter *iter;\n\tconst RList *list = r_flag_get_list (f, off);\n\tchar *p = NULL;\n\tr_list_foreach (list, iter, fi) {\n\t\tp = r_str_appendf (p, \"%s%s\",\n\t\t\tfi->realname, iter->n ? \",\" : \":\");\n\t}\n\treturn p;\n}\n\nR_API RFlagItem *r_flag_set_next(RFlag *f, const char *name, ut64 off, ut32 size) {\n\tif (!r_flag_get (f, name)) {\n\t\treturn r_flag_set (f, name, off, size);\n\t}\n\tint i, newNameSize = strlen (name);\n\tchar *newName = malloc (newNameSize + 16);\n\tstrcpy (newName, name);\n\tfor (i = 0; ; i++) {\n\t\tsnprintf (newName + newNameSize, 15, \".%d\", i);\n\t\tif (!r_flag_get (f, newName)) {\n\t\t\tRFlagItem *fi = r_flag_set (f, newName, off, size);\n\t\t\tfree (newName);\n\t\t\treturn fi;\n\t\t}\n\t}\n\treturn NULL;\n}\n\n/* create or modify an existing flag item with the given name and parameters.\n * The realname of the item will be the same as the name.\n * NULL is returned in case of any errors during the process. */\nR_API RFlagItem *r_flag_set(RFlag *f, const char *name, ut64 off, ut32 size) {\n\tRFlagItem *item = NULL;\n\tRList *list;\n\n\t/* contract fail */\n\tif (!name || !*name) {\n\t\treturn NULL;\n\t}\n\n\titem = r_flag_get (f, name);\n\tif (item) {\n\t\tif (item->offset == off) {\n\t\t\titem->size = size;\n\t\t\treturn item;\n\t\t}\n\t\tremove_offsetmap (f, item);\n\t} else {\n\t\titem = R_NEW0 (RFlagItem);\n\t\tif (!item) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (!set_name (item, name)) {\n\t\t\teprintf (\"Invalid flag name '%s'.\\n\", name);\n\t\t\tr_flag_item_free (item);\n\t\t\treturn NULL;\n\t\t}\n\t\t//item share ownership prone to uaf, that is why only\n\t\t//f->flags has set up free pointer\n\t\tht_insert (f->ht_name, item->name, item);\n\t\tr_list_append (f->flags, item);\n\t}\n\n\titem->space = f->space_idx;\n\titem->offset = off + f->base;\n\titem->size = size;\n\n\tlist = (RList *)r_flag_get_list (f, off);\n\tif (!list) {\n\t\tRFlagsAtOffset *flagsAtOffset = R_NEW (RFlagsAtOffset);\n\t\tlist = r_list_new ();\n\t\tflagsAtOffset->flags = list;\n\t\tflagsAtOffset->off = off;\n\t\t// CID 1378268:  Resource leaks  (RESOURCE_LEAK)\n\t\t// Ignoring storage allocated by \"r_skiplist_insert(f->by_off, flagsAtOffset)\" leaks it.\n\t\tr_skiplist_insert (f->by_off, flagsAtOffset);\n\t}\n\tr_list_append (list, item);\n\treturn item;\n}\n\n/* add/replace/remove the alias of a flag item */\nR_API void r_flag_item_set_alias(RFlagItem *item, const char *alias) {\n\tif (item) {\n\t\tfree (item->alias);\n\t\titem->alias = ISNULLSTR (alias)? NULL: strdup (alias);\n\t}\n}\n\n/* add/replace/remove the comment of a flag item */\nR_API void r_flag_item_set_comment(RFlagItem *item, const char *comment) {\n\tif (item) {\n\t\tfree (item->comment);\n\t\titem->comment = ISNULLSTR (comment) ? NULL : strdup (comment);\n\t}\n}\n\n/* add/replace/remove the realname of a flag item */\nR_API void r_flag_item_set_realname(RFlagItem *item, const char *realname) {\n\tif (item) {\n\t\tif (item->name != item->realname) {\n\t\t\tfree (item->realname);\n\t\t}\n\t\titem->realname = ISNULLSTR (realname) ? NULL : strdup (realname);\n\t}\n}\n\n/* change the name of a flag item, if the new name is available.\n * true is returned if everything works well, false otherwise */\nR_API int r_flag_rename(RFlag *f, RFlagItem *item, const char *name) {\n\tif (!f || !item || !name || !*name) {\n\t\treturn false;\n\t}\n#if 0\n\tut64 off = item->offset;\n\tint size = item->size;\n\tr_flag_unset (f, item);\n\tr_flag_set (f, name, off, size);\n\treturn true;\n#else\n\tht_delete (f->ht_name, item->name);\n\tif (!set_name (item, name)) {\n\t\treturn false;\n\t}\n\tht_insert (f->ht_name, item->name, item);\n#endif\n\treturn true;\n}\n\n/* unset the given flag item.\n * returns true if the item is successfully unset, false otherwise.\n *\n * NOTE: the item is freed. */\nR_API int r_flag_unset(RFlag *f, RFlagItem *item) {\n\tremove_offsetmap (f, item);\n\tht_delete (f->ht_name, item->name);\n\tr_list_delete_data (f->flags, item);\n\treturn true;\n}\n\n/* unset the first flag item found at offset off.\n * return true if such a flag is found and unset, false otherwise. */\nR_API int r_flag_unset_off(RFlag *f, ut64 off) {\n\tRFlagItem *item = r_flag_get_i (f, off);\n\tif (item && r_flag_unset (f, item)) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n/* unset all the flag items that satisfy the given glob.\n * return the number of unset items. */\nR_API int r_flag_unset_glob(RFlag *f, const char *glob) {\n\tRListIter it, *iter;\n\tRFlagItem *flag;\n\tint n = 0;\n\n\tr_list_foreach (f->flags, iter, flag) {\n\t\tif (IS_IN_SPACE (f, flag)) continue;\n\t\tif (!glob || r_str_glob (flag->name, glob)) {\n\t\t\tit.n = iter->n;\n\t\t\tr_flag_unset (f, flag);\n\t\t\titer = &it;\n\t\t\tn++;\n\t\t}\n\t}\n\treturn n;\n}\n\n/* unset the flag item with the given name.\n * returns true if the item is found and unset, false otherwise. */\nR_API int r_flag_unset_name(RFlag *f, const char *name) {\n\tRFlagItem *item = ht_find (f->ht_name, name, NULL);\n\treturn item && r_flag_unset (f, item);\n}\n\n/* unset all flag items in the RFlag f */\nR_API void r_flag_unset_all(RFlag *f) {\n\tf->space_idx = -1;\n\tr_list_free (f->flags);\n\tf->flags = r_list_newf ((RListFree)r_flag_item_free);\n\tif (!f->flags) {\n\t\treturn;\n\t}\n\tht_free (f->ht_name);\n\t//don't set free since f->flags will free up items when needed avoiding uaf\n\tf->ht_name = ht_new (NULL, flag_free_kv, NULL);\n\tr_skiplist_purge (f->by_off);\n\tr_flag_space_unset (f, NULL);\n}\n\nR_API int r_flag_relocate(RFlag *f, ut64 off, ut64 off_mask, ut64 to) {\n\tut64 neg_mask = ~(off_mask);\n\tRFlagItem *item;\n\tRListIter *iter;\n\tint n = 0;\n\n\tr_list_foreach (f->flags, iter, item) {\n\t\tut64 fn = item->offset & neg_mask;\n\t\tut64 on = off & neg_mask;\n\t\tif (fn == on) {\n\t\t\tut64 fm = item->offset & off_mask;\n\t\t\tut64 om = to & off_mask;\n\t\t\titem->offset = (to&neg_mask) + fm + om;\n\t\t\tn++;\n\t\t}\n\t}\n\treturn n;\n}\n\nR_API int r_flag_move(RFlag *f, ut64 at, ut64 to) {\n\tRFlagItem *item = r_flag_get_i (f, at);\n\tif (item) {\n\t\tr_flag_set (f, item->name, to, item->size);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n#ifdef MYTEST\nint main () {\n\tRFlagItem *i;\n\tRFlag *f = r_flag_new ();\n\tr_flag_set (f, \"rip\", 0xfff333999000LL, 1);\n\tr_flag_set (f, \"rip\", 0xfff333999002LL, 1);\n\tr_flag_unset (f, \"rip\", NULL);\n\tr_flag_set (f, \"rip\", 3, 4);\n\tr_flag_set (f, \"rip\", 4, 4);\n\tr_flag_set (f, \"corwp\", 300, 4);\n\tr_flag_set (f, \"barp\", 300, 4);\n\tr_flag_set (f, \"rip\", 3, 4);\n\tr_flag_set (f, \"rip\", 4, 4);\n\n\ti = r_flag_get (f, \"rip\");\n\tif (i) printf (\"nRIP: %p %llx\\n\", i, i->offset);\n\telse printf (\"nRIP: null\\n\");\n\n\ti = r_flag_get_i (f, 0xfff333999000LL);\n\tif (i) printf (\"iRIP: %p %llx\\n\", i, i->offset);\n\telse printf (\"iRIP: null\\n\");\n}\n#endif\n\nR_API const char *r_flag_color(RFlag *f, RFlagItem *it, const char *color) {\n\tif (!f || !it) return NULL;\n\tif (!color) return it->color;\n\tfree (it->color);\n\tit->color = *color ? strdup (color) : NULL;\n\treturn it->color;\n}\n\n// BIND\nR_API int r_flag_bind(RFlag *f, RFlagBind *fb) {\n\tfb->f = f;\n\tfb->exist_at = r_flag_exist_at;\n\tfb->get = r_flag_get;\n\tfb->get_at = r_flag_get_at;\n\tfb->set = r_flag_set;\n\tfb->set_fs = r_flag_space_set;\n\treturn 0;\n}\n\nR_API int r_flag_count(RFlag *f, const char *glob) {\n\tint count = 0;\n\tRFlagItem *flag;\n\tRListIter *iter;\n\tr_list_foreach (f->flags, iter, flag) {\n\t\tif (r_str_glob (flag->name, glob))\n\t\t\tcount ++;\n\t}\n\treturn count;\n}\n"], "filenames": ["libr/asm/arch/wasm/wasm.c", "libr/flag/flag.c"], "buggy_code_start_loc": [419, 77], "buggy_code_end_loc": [748, 78], "fixing_code_start_loc": [419, 77], "fixing_code_end_loc": [757, 78], "type": "CWE-125", "message": "The wasm_dis function in libr/asm/arch/wasm/wasm.c in radare2 2.0.0 allows remote attackers to cause a denial of service (stack-based buffer over-read and application crash) or possibly have unspecified other impact via a crafted WASM file that triggers an incorrect r_hex_bin2str call.", "other": {"cve": {"id": "CVE-2017-15368", "sourceIdentifier": "cve@mitre.org", "published": "2017-10-16T01:29:01.030", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The wasm_dis function in libr/asm/arch/wasm/wasm.c in radare2 2.0.0 allows remote attackers to cause a denial of service (stack-based buffer over-read and application crash) or possibly have unspecified other impact via a crafted WASM file that triggers an incorrect r_hex_bin2str call."}, {"lang": "es", "value": "La funci\u00f3n wasm_dis en libr/asm/arch/wasm/wasm.c en radare2 2.0.0 permite que atacantes remotos provoquen una denegaci\u00f3n de servicio (sobrelectura de b\u00fafer basado en pila y cierre inesperado de la aplicaci\u00f3n) o, probablemente, causar cualquier otro tipo de impacto mediante un archivo WASM manipulado que realiza una llamada r_hex_bin2str incorrecta."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:radare:radare2:2.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "4C49AD01-18A2-44A6-BA89-2C8280EF719C"}]}]}], "references": [{"url": "https://github.com/radare/radare2/commit/52b1526443c1f433087928291d1c3d37a5600515", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/radare/radare2/issues/8673", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/radare/radare2/commit/52b1526443c1f433087928291d1c3d37a5600515"}}