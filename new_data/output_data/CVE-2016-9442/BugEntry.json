{"buggy_code": ["/* $Id: Str.c,v 1.8 2002/12/24 17:20:46 ukai Exp $ */\n/* \n * String manipulation library for Boehm GC\n *\n * (C) Copyright 1998-1999 by Akinori Ito\n *\n * This software may be redistributed freely for this purpose, in full \n * or in part, provided that this entire copyright notice is included \n * on any copies of this software and applications and derivations thereof.\n *\n * This software is provided on an \"as is\" basis, without warranty of any\n * kind, either expressed or implied, as to any matter including, but not\n * limited to warranty of fitness of purpose, or merchantability, or\n * results obtained from use of this software.\n */\n#include <stdio.h>\n#include <stdlib.h>\n#include <gc.h>\n#include <stdarg.h>\n#include <string.h>\n#ifdef __EMX__\t\t\t/* or include \"fm.h\" for HAVE_BCOPY? */\n#include <strings.h>\n#endif\n#include \"Str.h\"\n#include \"myctype.h\"\n\n#define INITIAL_STR_SIZE 32\n\n#ifdef STR_DEBUG\n/* This is obsolete, because \"Str\" can handle a '\\0' character now. */\n#define STR_LENGTH_CHECK(x) if (((x)->ptr==0&&(x)->length!=0)||(strlen((x)->ptr)!=(x)->length))abort();\n#else\t\t\t\t/* not STR_DEBUG */\n#define STR_LENGTH_CHECK(x)\n#endif\t\t\t\t/* not STR_DEBUG */\n\nStr\nStrnew()\n{\n    Str x = GC_MALLOC(sizeof(struct _Str));\n    x->ptr = GC_MALLOC_ATOMIC(INITIAL_STR_SIZE);\n    x->ptr[0] = '\\0';\n    x->area_size = INITIAL_STR_SIZE;\n    x->length = 0;\n    return x;\n}\n\nStr\nStrnew_size(int n)\n{\n    Str x = GC_MALLOC(sizeof(struct _Str));\n    x->ptr = GC_MALLOC_ATOMIC(n + 1);\n    x->ptr[0] = '\\0';\n    x->area_size = n + 1;\n    x->length = 0;\n    return x;\n}\n\nStr\nStrnew_charp(const char *p)\n{\n    Str x;\n    int n;\n\n    if (p == NULL)\n\treturn Strnew();\n    x = GC_MALLOC(sizeof(struct _Str));\n    n = strlen(p) + 1;\n    x->ptr = GC_MALLOC_ATOMIC(n);\n    x->area_size = n;\n    x->length = n - 1;\n    bcopy((void *)p, (void *)x->ptr, n);\n    return x;\n}\n\nStr\nStrnew_m_charp(const char *p, ...)\n{\n    va_list ap;\n    Str r = Strnew();\n\n    va_start(ap, p);\n    while (p != NULL) {\n\tStrcat_charp(r, p);\n\tp = va_arg(ap, char *);\n    }\n    return r;\n}\n\nStr\nStrnew_charp_n(const char *p, int n)\n{\n    Str x;\n\n    if (p == NULL)\n\treturn Strnew_size(n);\n    x = GC_MALLOC(sizeof(struct _Str));\n    x->ptr = GC_MALLOC_ATOMIC(n + 1);\n    x->area_size = n + 1;\n    x->length = n;\n    bcopy((void *)p, (void *)x->ptr, n);\n    x->ptr[n] = '\\0';\n    return x;\n}\n\nStr\nStrdup(Str s)\n{\n    Str n = Strnew_size(s->length);\n    STR_LENGTH_CHECK(s);\n    Strcopy(n, s);\n    return n;\n}\n\nvoid\nStrclear(Str s)\n{\n    s->length = 0;\n    s->ptr[0] = '\\0';\n}\n\nvoid\nStrfree(Str x)\n{\n    GC_free(x->ptr);\n    GC_free(x);\n}\n\nvoid\nStrcopy(Str x, Str y)\n{\n    STR_LENGTH_CHECK(x);\n    STR_LENGTH_CHECK(y);\n    if (x->area_size < y->length + 1) {\n\tGC_free(x->ptr);\n\tx->ptr = GC_MALLOC_ATOMIC(y->length + 1);\n\tx->area_size = y->length + 1;\n    }\n    bcopy((void *)y->ptr, (void *)x->ptr, y->length + 1);\n    x->length = y->length;\n}\n\nvoid\nStrcopy_charp(Str x, const char *y)\n{\n    int len;\n\n    STR_LENGTH_CHECK(x);\n    if (y == NULL) {\n\tx->length = 0;\n\treturn;\n    }\n    len = strlen(y);\n    if (x->area_size < len + 1) {\n\tGC_free(x->ptr);\n\tx->ptr = GC_MALLOC_ATOMIC(len + 1);\n\tx->area_size = len + 1;\n    }\n    bcopy((void *)y, (void *)x->ptr, len + 1);\n    x->length = len;\n}\n\nvoid\nStrcopy_charp_n(Str x, const char *y, int n)\n{\n    int len = n;\n\n    STR_LENGTH_CHECK(x);\n    if (y == NULL) {\n\tx->length = 0;\n\treturn;\n    }\n    if (x->area_size < len + 1) {\n\tGC_free(x->ptr);\n\tx->ptr = GC_MALLOC_ATOMIC(len + 1);\n\tx->area_size = len + 1;\n    }\n    bcopy((void *)y, (void *)x->ptr, n);\n    x->ptr[n] = '\\0';\n    x->length = n;\n}\n\nvoid\nStrcat_charp_n(Str x, const char *y, int n)\n{\n    int newlen;\n\n    STR_LENGTH_CHECK(x);\n    if (y == NULL)\n\treturn;\n    newlen = x->length + n + 1;\n    if (x->area_size < newlen) {\n\tchar *old = x->ptr;\n\tnewlen = newlen * 3 / 2;\n\tx->ptr = GC_MALLOC_ATOMIC(newlen);\n\tx->area_size = newlen;\n\tbcopy((void *)old, (void *)x->ptr, x->length);\n\tGC_free(old);\n    }\n    bcopy((void *)y, (void *)&x->ptr[x->length], n);\n    x->length += n;\n    x->ptr[x->length] = '\\0';\n}\n\nvoid\nStrcat(Str x, Str y)\n{\n    STR_LENGTH_CHECK(y);\n    Strcat_charp_n(x, y->ptr, y->length);\n}\n\nvoid\nStrcat_charp(Str x, const char *y)\n{\n    if (y == NULL)\n\treturn;\n    Strcat_charp_n(x, y, strlen(y));\n}\n\nvoid\nStrcat_m_charp(Str x, ...)\n{\n    va_list ap;\n    char *p;\n\n    va_start(ap, x);\n    while ((p = va_arg(ap, char *)) != NULL)\n\t Strcat_charp_n(x, p, strlen(p));\n}\n\nvoid\nStrgrow(Str x)\n{\n    char *old = x->ptr;\n    int newlen;\n    newlen = x->length * 6 / 5;\n    if (newlen == x->length)\n\tnewlen += 2;\n    x->ptr = GC_MALLOC_ATOMIC(newlen);\n    x->area_size = newlen;\n    bcopy((void *)old, (void *)x->ptr, x->length);\n    GC_free(old);\n}\n\nStr\nStrsubstr(Str s, int beg, int len)\n{\n    Str new_s;\n    int i;\n\n    STR_LENGTH_CHECK(s);\n    new_s = Strnew();\n    if (beg >= s->length)\n\treturn new_s;\n    for (i = 0; i < len && beg + i < s->length; i++)\n\tStrcat_char(new_s, s->ptr[beg + i]);\n    return new_s;\n}\n\nvoid\nStrlower(Str s)\n{\n    int i;\n    STR_LENGTH_CHECK(s);\n    for (i = 0; i < s->length; i++)\n\ts->ptr[i] = TOLOWER(s->ptr[i]);\n}\n\nvoid\nStrupper(Str s)\n{\n    int i;\n    STR_LENGTH_CHECK(s);\n    for (i = 0; i < s->length; i++)\n\ts->ptr[i] = TOUPPER(s->ptr[i]);\n}\n\nvoid\nStrchop(Str s)\n{\n    STR_LENGTH_CHECK(s);\n    while (s->length > 0 &&\n\t   (s->ptr[s->length - 1] == '\\n' || s->ptr[s->length - 1] == '\\r')) {\n\ts->length--;\n    }\n    s->ptr[s->length] = '\\0';\n}\n\nvoid\nStrinsert_char(Str s, int pos, char c)\n{\n    int i;\n    STR_LENGTH_CHECK(s);\n    if (pos < 0 || s->length < pos)\n\treturn;\n    if (s->length + 2 > s->area_size)\n\tStrgrow(s);\n    for (i = s->length; i > pos; i--)\n\ts->ptr[i] = s->ptr[i - 1];\n    s->ptr[++s->length] = '\\0';\n    s->ptr[pos] = c;\n}\n\nvoid\nStrinsert_charp(Str s, int pos, const char *p)\n{\n    STR_LENGTH_CHECK(s);\n    while (*p)\n\tStrinsert_char(s, pos++, *(p++));\n}\n\nvoid\nStrdelete(Str s, int pos, int n)\n{\n    int i;\n    STR_LENGTH_CHECK(s);\n    if (s->length <= pos + n) {\n\ts->ptr[pos] = '\\0';\n\ts->length = pos;\n\treturn;\n    }\n    for (i = pos; i < s->length - n; i++)\n\ts->ptr[i] = s->ptr[i + n];\n    s->ptr[i] = '\\0';\n    s->length = i;\n}\n\nvoid\nStrtruncate(Str s, int pos)\n{\n    STR_LENGTH_CHECK(s);\n    s->ptr[pos] = '\\0';\n    s->length = pos;\n}\n\nvoid\nStrshrink(Str s, int n)\n{\n    STR_LENGTH_CHECK(s);\n    if (n >= s->length) {\n\ts->length = 0;\n\ts->ptr[0] = '\\0';\n    }\n    else {\n\ts->length -= n;\n\ts->ptr[s->length] = '\\0';\n    }\n}\n\nvoid\nStrremovefirstspaces(Str s)\n{\n    int i;\n\n    STR_LENGTH_CHECK(s);\n    for (i = 0; i < s->length && IS_SPACE(s->ptr[i]); i++) ;\n    if (i == 0)\n\treturn;\n    Strdelete(s, 0, i);\n}\n\nvoid\nStrremovetrailingspaces(Str s)\n{\n    int i;\n\n    STR_LENGTH_CHECK(s);\n    for (i = s->length - 1; i >= 0 && IS_SPACE(s->ptr[i]); i--) ;\n    s->length = i + 1;\n    s->ptr[i + 1] = '\\0';\n}\n\nStr\nStralign_left(Str s, int width)\n{\n    Str n;\n    int i;\n\n    STR_LENGTH_CHECK(s);\n    if (s->length >= width)\n\treturn Strdup(s);\n    n = Strnew_size(width);\n    Strcopy(n, s);\n    for (i = s->length; i < width; i++)\n\tStrcat_char(n, ' ');\n    return n;\n}\n\nStr\nStralign_right(Str s, int width)\n{\n    Str n;\n    int i;\n\n    STR_LENGTH_CHECK(s);\n    if (s->length >= width)\n\treturn Strdup(s);\n    n = Strnew_size(width);\n    for (i = s->length; i < width; i++)\n\tStrcat_char(n, ' ');\n    Strcat(n, s);\n    return n;\n}\n\nStr\nStralign_center(Str s, int width)\n{\n    Str n;\n    int i, w;\n\n    STR_LENGTH_CHECK(s);\n    if (s->length >= width)\n\treturn Strdup(s);\n    n = Strnew_size(width);\n    w = (width - s->length) / 2;\n    for (i = 0; i < w; i++)\n\tStrcat_char(n, ' ');\n    Strcat(n, s);\n    for (i = w + s->length; i < width; i++)\n\tStrcat_char(n, ' ');\n    return n;\n}\n\n#define SP_NORMAL 0\n#define SP_PREC   1\n#define SP_PREC2  2\n\nStr\nSprintf(char *fmt, ...)\n{\n    int len = 0;\n    int status = SP_NORMAL;\n    int p = 0;\n    char *f;\n    Str s;\n    va_list ap;\n\n    va_start(ap, fmt);\n    for (f = fmt; *f; f++) {\n      redo:\n\tswitch (status) {\n\tcase SP_NORMAL:\n\t    if (*f == '%') {\n\t\tstatus = SP_PREC;\n\t\tp = 0;\n\t    }\n\t    else\n\t\tlen++;\n\t    break;\n\tcase SP_PREC:\n\t    if (IS_ALPHA(*f)) {\n\t\t/* conversion char. */\n\t\tdouble vd;\n\t\tint vi;\n\t\tchar *vs;\n\t\tvoid *vp;\n\n\t\tswitch (*f) {\n\t\tcase 'l':\n\t\tcase 'h':\n\t\tcase 'L':\n\t\tcase 'w':\n\t\t    continue;\n\t\tcase 'd':\n\t\tcase 'i':\n\t\tcase 'o':\n\t\tcase 'x':\n\t\tcase 'X':\n\t\tcase 'u':\n\t\t    vi = va_arg(ap, int);\n\t\t    len += (p > 0) ? p : 10;\n\t\t    break;\n\t\tcase 'f':\n\t\tcase 'g':\n\t\tcase 'e':\n\t\tcase 'G':\n\t\tcase 'E':\n\t\t    vd = va_arg(ap, double);\n\t\t    len += (p > 0) ? p : 15;\n\t\t    break;\n\t\tcase 'c':\n\t\t    len += 1;\n\t\t    vi = va_arg(ap, int);\n\t\t    break;\n\t\tcase 's':\n\t\t    vs = va_arg(ap, char *);\n\t\t    vi = strlen(vs);\n\t\t    len += (p > vi) ? p : vi;\n\t\t    break;\n\t\tcase 'p':\n\t\t    vp = va_arg(ap, void *);\n\t\t    len += 10;\n\t\t    break;\n\t\tcase 'n':\n\t\t    vp = va_arg(ap, void *);\n\t\t    break;\n\t\t}\n\t\tstatus = SP_NORMAL;\n\t    }\n\t    else if (IS_DIGIT(*f))\n\t\tp = p * 10 + *f - '0';\n\t    else if (*f == '.')\n\t\tstatus = SP_PREC2;\n\t    else if (*f == '%') {\n\t\tstatus = SP_NORMAL;\n\t\tlen++;\n\t    }\n\t    break;\n\tcase SP_PREC2:\n\t    if (IS_ALPHA(*f)) {\n\t\tstatus = SP_PREC;\n\t\tgoto redo;\n\t    }\n\t    break;\n\t}\n    }\n    va_end(ap);\n    s = Strnew_size(len * 2);\n    va_start(ap, fmt);\n    vsprintf(s->ptr, fmt, ap);\n    va_end(ap);\n    s->length = strlen(s->ptr);\n    if (s->length > len * 2) {\n\tfprintf(stderr, \"Sprintf: string too long\\n\");\n\texit(1);\n    }\n    return s;\n}\n\nStr\nStrfgets(FILE * f)\n{\n    Str s = Strnew();\n    int c;\n    while ((c = fgetc(f)) != EOF) {\n\tStrcat_char(s, c);\n\tif (c == '\\n')\n\t    break;\n    }\n    return s;\n}\n\nStr\nStrfgetall(FILE * f)\n{\n    Str s = Strnew();\n    int c;\n    while ((c = fgetc(f)) != EOF) {\n\tStrcat_char(s, c);\n    }\n    return s;\n}\n"], "fixing_code": ["/* $Id: Str.c,v 1.8 2002/12/24 17:20:46 ukai Exp $ */\n/* \n * String manipulation library for Boehm GC\n *\n * (C) Copyright 1998-1999 by Akinori Ito\n *\n * This software may be redistributed freely for this purpose, in full \n * or in part, provided that this entire copyright notice is included \n * on any copies of this software and applications and derivations thereof.\n *\n * This software is provided on an \"as is\" basis, without warranty of any\n * kind, either expressed or implied, as to any matter including, but not\n * limited to warranty of fitness of purpose, or merchantability, or\n * results obtained from use of this software.\n */\n#include <stdio.h>\n#include <stdlib.h>\n#include <gc.h>\n#include <stdarg.h>\n#include <string.h>\n#ifdef __EMX__\t\t\t/* or include \"fm.h\" for HAVE_BCOPY? */\n#include <strings.h>\n#endif\n#include \"Str.h\"\n#include \"myctype.h\"\n\n#define INITIAL_STR_SIZE 32\n\n#ifdef STR_DEBUG\n/* This is obsolete, because \"Str\" can handle a '\\0' character now. */\n#define STR_LENGTH_CHECK(x) if (((x)->ptr==0&&(x)->length!=0)||(strlen((x)->ptr)!=(x)->length))abort();\n#else\t\t\t\t/* not STR_DEBUG */\n#define STR_LENGTH_CHECK(x)\n#endif\t\t\t\t/* not STR_DEBUG */\n\nStr\nStrnew()\n{\n    Str x = GC_MALLOC(sizeof(struct _Str));\n    x->ptr = GC_MALLOC_ATOMIC(INITIAL_STR_SIZE);\n    x->ptr[0] = '\\0';\n    x->area_size = INITIAL_STR_SIZE;\n    x->length = 0;\n    return x;\n}\n\nStr\nStrnew_size(int n)\n{\n    Str x = GC_MALLOC(sizeof(struct _Str));\n    x->ptr = GC_MALLOC_ATOMIC(n + 1);\n    x->ptr[0] = '\\0';\n    x->area_size = n + 1;\n    x->length = 0;\n    return x;\n}\n\nStr\nStrnew_charp(const char *p)\n{\n    Str x;\n    int n;\n\n    if (p == NULL)\n\treturn Strnew();\n    x = GC_MALLOC(sizeof(struct _Str));\n    n = strlen(p) + 1;\n    x->ptr = GC_MALLOC_ATOMIC(n);\n    x->area_size = n;\n    x->length = n - 1;\n    bcopy((void *)p, (void *)x->ptr, n);\n    return x;\n}\n\nStr\nStrnew_m_charp(const char *p, ...)\n{\n    va_list ap;\n    Str r = Strnew();\n\n    va_start(ap, p);\n    while (p != NULL) {\n\tStrcat_charp(r, p);\n\tp = va_arg(ap, char *);\n    }\n    return r;\n}\n\nStr\nStrnew_charp_n(const char *p, int n)\n{\n    Str x;\n\n    if (p == NULL)\n\treturn Strnew_size(n);\n    x = GC_MALLOC(sizeof(struct _Str));\n    x->ptr = GC_MALLOC_ATOMIC(n + 1);\n    x->area_size = n + 1;\n    x->length = n;\n    bcopy((void *)p, (void *)x->ptr, n);\n    x->ptr[n] = '\\0';\n    return x;\n}\n\nStr\nStrdup(Str s)\n{\n    Str n = Strnew_size(s->length);\n    STR_LENGTH_CHECK(s);\n    Strcopy(n, s);\n    return n;\n}\n\nvoid\nStrclear(Str s)\n{\n    s->length = 0;\n    s->ptr[0] = '\\0';\n}\n\nvoid\nStrfree(Str x)\n{\n    GC_free(x->ptr);\n    GC_free(x);\n}\n\nvoid\nStrcopy(Str x, Str y)\n{\n    STR_LENGTH_CHECK(x);\n    STR_LENGTH_CHECK(y);\n    if (x->area_size < y->length + 1) {\n\tGC_free(x->ptr);\n\tx->ptr = GC_MALLOC_ATOMIC(y->length + 1);\n\tx->area_size = y->length + 1;\n    }\n    bcopy((void *)y->ptr, (void *)x->ptr, y->length + 1);\n    x->length = y->length;\n}\n\nvoid\nStrcopy_charp(Str x, const char *y)\n{\n    int len;\n\n    STR_LENGTH_CHECK(x);\n    if (y == NULL) {\n\tx->length = 0;\n\treturn;\n    }\n    len = strlen(y);\n    if (x->area_size < len + 1) {\n\tGC_free(x->ptr);\n\tx->ptr = GC_MALLOC_ATOMIC(len + 1);\n\tx->area_size = len + 1;\n    }\n    bcopy((void *)y, (void *)x->ptr, len + 1);\n    x->length = len;\n}\n\nvoid\nStrcopy_charp_n(Str x, const char *y, int n)\n{\n    int len = n;\n\n    STR_LENGTH_CHECK(x);\n    if (y == NULL) {\n\tx->length = 0;\n\treturn;\n    }\n    if (x->area_size < len + 1) {\n\tGC_free(x->ptr);\n\tx->ptr = GC_MALLOC_ATOMIC(len + 1);\n\tx->area_size = len + 1;\n    }\n    bcopy((void *)y, (void *)x->ptr, n);\n    x->ptr[n] = '\\0';\n    x->length = n;\n}\n\nvoid\nStrcat_charp_n(Str x, const char *y, int n)\n{\n    int newlen;\n\n    STR_LENGTH_CHECK(x);\n    if (y == NULL)\n\treturn;\n    newlen = x->length + n + 1;\n    if (x->area_size < newlen) {\n\tchar *old = x->ptr;\n\tnewlen = newlen * 3 / 2;\n\tx->ptr = GC_MALLOC_ATOMIC(newlen);\n\tx->area_size = newlen;\n\tbcopy((void *)old, (void *)x->ptr, x->length);\n\tGC_free(old);\n    }\n    bcopy((void *)y, (void *)&x->ptr[x->length], n);\n    x->length += n;\n    x->ptr[x->length] = '\\0';\n}\n\nvoid\nStrcat(Str x, Str y)\n{\n    STR_LENGTH_CHECK(y);\n    Strcat_charp_n(x, y->ptr, y->length);\n}\n\nvoid\nStrcat_charp(Str x, const char *y)\n{\n    if (y == NULL)\n\treturn;\n    Strcat_charp_n(x, y, strlen(y));\n}\n\nvoid\nStrcat_m_charp(Str x, ...)\n{\n    va_list ap;\n    char *p;\n\n    va_start(ap, x);\n    while ((p = va_arg(ap, char *)) != NULL)\n\t Strcat_charp_n(x, p, strlen(p));\n}\n\nvoid\nStrgrow(Str x)\n{\n    char *old = x->ptr;\n    int newlen;\n    newlen = x->area_size * 6 / 5;\n    if (newlen == x->area_size)\n\tnewlen += 2;\n    x->ptr = GC_MALLOC_ATOMIC(newlen);\n    x->area_size = newlen;\n    bcopy((void *)old, (void *)x->ptr, x->length);\n    GC_free(old);\n}\n\nStr\nStrsubstr(Str s, int beg, int len)\n{\n    Str new_s;\n    int i;\n\n    STR_LENGTH_CHECK(s);\n    new_s = Strnew();\n    if (beg >= s->length)\n\treturn new_s;\n    for (i = 0; i < len && beg + i < s->length; i++)\n\tStrcat_char(new_s, s->ptr[beg + i]);\n    return new_s;\n}\n\nvoid\nStrlower(Str s)\n{\n    int i;\n    STR_LENGTH_CHECK(s);\n    for (i = 0; i < s->length; i++)\n\ts->ptr[i] = TOLOWER(s->ptr[i]);\n}\n\nvoid\nStrupper(Str s)\n{\n    int i;\n    STR_LENGTH_CHECK(s);\n    for (i = 0; i < s->length; i++)\n\ts->ptr[i] = TOUPPER(s->ptr[i]);\n}\n\nvoid\nStrchop(Str s)\n{\n    STR_LENGTH_CHECK(s);\n    while (s->length > 0 &&\n\t   (s->ptr[s->length - 1] == '\\n' || s->ptr[s->length - 1] == '\\r')) {\n\ts->length--;\n    }\n    s->ptr[s->length] = '\\0';\n}\n\nvoid\nStrinsert_char(Str s, int pos, char c)\n{\n    int i;\n    STR_LENGTH_CHECK(s);\n    if (pos < 0 || s->length < pos)\n\treturn;\n    if (s->length + 2 > s->area_size)\n\tStrgrow(s);\n    for (i = s->length; i > pos; i--)\n\ts->ptr[i] = s->ptr[i - 1];\n    s->ptr[++s->length] = '\\0';\n    s->ptr[pos] = c;\n}\n\nvoid\nStrinsert_charp(Str s, int pos, const char *p)\n{\n    STR_LENGTH_CHECK(s);\n    while (*p)\n\tStrinsert_char(s, pos++, *(p++));\n}\n\nvoid\nStrdelete(Str s, int pos, int n)\n{\n    int i;\n    STR_LENGTH_CHECK(s);\n    if (s->length <= pos + n) {\n\ts->ptr[pos] = '\\0';\n\ts->length = pos;\n\treturn;\n    }\n    for (i = pos; i < s->length - n; i++)\n\ts->ptr[i] = s->ptr[i + n];\n    s->ptr[i] = '\\0';\n    s->length = i;\n}\n\nvoid\nStrtruncate(Str s, int pos)\n{\n    STR_LENGTH_CHECK(s);\n    s->ptr[pos] = '\\0';\n    s->length = pos;\n}\n\nvoid\nStrshrink(Str s, int n)\n{\n    STR_LENGTH_CHECK(s);\n    if (n >= s->length) {\n\ts->length = 0;\n\ts->ptr[0] = '\\0';\n    }\n    else {\n\ts->length -= n;\n\ts->ptr[s->length] = '\\0';\n    }\n}\n\nvoid\nStrremovefirstspaces(Str s)\n{\n    int i;\n\n    STR_LENGTH_CHECK(s);\n    for (i = 0; i < s->length && IS_SPACE(s->ptr[i]); i++) ;\n    if (i == 0)\n\treturn;\n    Strdelete(s, 0, i);\n}\n\nvoid\nStrremovetrailingspaces(Str s)\n{\n    int i;\n\n    STR_LENGTH_CHECK(s);\n    for (i = s->length - 1; i >= 0 && IS_SPACE(s->ptr[i]); i--) ;\n    s->length = i + 1;\n    s->ptr[i + 1] = '\\0';\n}\n\nStr\nStralign_left(Str s, int width)\n{\n    Str n;\n    int i;\n\n    STR_LENGTH_CHECK(s);\n    if (s->length >= width)\n\treturn Strdup(s);\n    n = Strnew_size(width);\n    Strcopy(n, s);\n    for (i = s->length; i < width; i++)\n\tStrcat_char(n, ' ');\n    return n;\n}\n\nStr\nStralign_right(Str s, int width)\n{\n    Str n;\n    int i;\n\n    STR_LENGTH_CHECK(s);\n    if (s->length >= width)\n\treturn Strdup(s);\n    n = Strnew_size(width);\n    for (i = s->length; i < width; i++)\n\tStrcat_char(n, ' ');\n    Strcat(n, s);\n    return n;\n}\n\nStr\nStralign_center(Str s, int width)\n{\n    Str n;\n    int i, w;\n\n    STR_LENGTH_CHECK(s);\n    if (s->length >= width)\n\treturn Strdup(s);\n    n = Strnew_size(width);\n    w = (width - s->length) / 2;\n    for (i = 0; i < w; i++)\n\tStrcat_char(n, ' ');\n    Strcat(n, s);\n    for (i = w + s->length; i < width; i++)\n\tStrcat_char(n, ' ');\n    return n;\n}\n\n#define SP_NORMAL 0\n#define SP_PREC   1\n#define SP_PREC2  2\n\nStr\nSprintf(char *fmt, ...)\n{\n    int len = 0;\n    int status = SP_NORMAL;\n    int p = 0;\n    char *f;\n    Str s;\n    va_list ap;\n\n    va_start(ap, fmt);\n    for (f = fmt; *f; f++) {\n      redo:\n\tswitch (status) {\n\tcase SP_NORMAL:\n\t    if (*f == '%') {\n\t\tstatus = SP_PREC;\n\t\tp = 0;\n\t    }\n\t    else\n\t\tlen++;\n\t    break;\n\tcase SP_PREC:\n\t    if (IS_ALPHA(*f)) {\n\t\t/* conversion char. */\n\t\tdouble vd;\n\t\tint vi;\n\t\tchar *vs;\n\t\tvoid *vp;\n\n\t\tswitch (*f) {\n\t\tcase 'l':\n\t\tcase 'h':\n\t\tcase 'L':\n\t\tcase 'w':\n\t\t    continue;\n\t\tcase 'd':\n\t\tcase 'i':\n\t\tcase 'o':\n\t\tcase 'x':\n\t\tcase 'X':\n\t\tcase 'u':\n\t\t    vi = va_arg(ap, int);\n\t\t    len += (p > 0) ? p : 10;\n\t\t    break;\n\t\tcase 'f':\n\t\tcase 'g':\n\t\tcase 'e':\n\t\tcase 'G':\n\t\tcase 'E':\n\t\t    vd = va_arg(ap, double);\n\t\t    len += (p > 0) ? p : 15;\n\t\t    break;\n\t\tcase 'c':\n\t\t    len += 1;\n\t\t    vi = va_arg(ap, int);\n\t\t    break;\n\t\tcase 's':\n\t\t    vs = va_arg(ap, char *);\n\t\t    vi = strlen(vs);\n\t\t    len += (p > vi) ? p : vi;\n\t\t    break;\n\t\tcase 'p':\n\t\t    vp = va_arg(ap, void *);\n\t\t    len += 10;\n\t\t    break;\n\t\tcase 'n':\n\t\t    vp = va_arg(ap, void *);\n\t\t    break;\n\t\t}\n\t\tstatus = SP_NORMAL;\n\t    }\n\t    else if (IS_DIGIT(*f))\n\t\tp = p * 10 + *f - '0';\n\t    else if (*f == '.')\n\t\tstatus = SP_PREC2;\n\t    else if (*f == '%') {\n\t\tstatus = SP_NORMAL;\n\t\tlen++;\n\t    }\n\t    break;\n\tcase SP_PREC2:\n\t    if (IS_ALPHA(*f)) {\n\t\tstatus = SP_PREC;\n\t\tgoto redo;\n\t    }\n\t    break;\n\t}\n    }\n    va_end(ap);\n    s = Strnew_size(len * 2);\n    va_start(ap, fmt);\n    vsprintf(s->ptr, fmt, ap);\n    va_end(ap);\n    s->length = strlen(s->ptr);\n    if (s->length > len * 2) {\n\tfprintf(stderr, \"Sprintf: string too long\\n\");\n\texit(1);\n    }\n    return s;\n}\n\nStr\nStrfgets(FILE * f)\n{\n    Str s = Strnew();\n    int c;\n    while ((c = fgetc(f)) != EOF) {\n\tStrcat_char(s, c);\n\tif (c == '\\n')\n\t    break;\n    }\n    return s;\n}\n\nStr\nStrfgetall(FILE * f)\n{\n    Str s = Strnew();\n    int c;\n    while ((c = fgetc(f)) != EOF) {\n\tStrcat_char(s, c);\n    }\n    return s;\n}\n"], "filenames": ["Str.c"], "buggy_code_start_loc": [235], "buggy_code_end_loc": [237], "fixing_code_start_loc": [235], "fixing_code_end_loc": [237], "type": "CWE-119", "message": "An issue was discovered in the Tatsuya Kinoshita w3m fork before 0.5.3-31. w3m allows remote attackers to cause memory corruption in certain conditions via a crafted HTML page.", "other": {"cve": {"id": "CVE-2016-9442", "sourceIdentifier": "cve@mitre.org", "published": "2016-12-12T02:59:34.347", "lastModified": "2017-07-01T01:30:14.437", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "An issue was discovered in the Tatsuya Kinoshita w3m fork before 0.5.3-31. w3m allows remote attackers to cause memory corruption in certain conditions via a crafted HTML page."}, {"lang": "es", "value": "Se descubri\u00f3 un problema en el fork de Tatsuya Kinoshita w3m en versiones anteriores a 0.5.3-31. w3m permite a atacantes remotos provocar corrupci\u00f3n de memoria en ciertas condiciones a trav\u00e9s de una p\u00e1gina HTML manipulada."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:w3m_project:w3m:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.5.3-30", "matchCriteriaId": "6B0931C0-2169-4D94-B5A8-7477EA42D870"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2016/11/18/3", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/94407", "source": "cve@mitre.org"}, {"url": "https://github.com/tats/w3m/blob/master/ChangeLog", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://github.com/tats/w3m/commit/d43527cfa0dbb3ccefec4a6f7b32c1434739aa29", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://security.gentoo.org/glsa/201701-08", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/tats/w3m/commit/d43527cfa0dbb3ccefec4a6f7b32c1434739aa29"}}