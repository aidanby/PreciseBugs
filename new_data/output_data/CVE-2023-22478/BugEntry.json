{"buggy_code": ["package v1\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"strings\"\n\n\t\"github.com/KubeOperator/kubepi/internal/api/v1/mfa\"\n\t\"github.com/KubeOperator/kubepi/internal/server\"\n\n\t\"github.com/KubeOperator/kubepi/internal/api/v1/file\"\n\t\"github.com/kataras/iris/v12/middleware/jwt\"\n\n\t\"github.com/KubeOperator/kubepi/internal/api/v1/chart\"\n\t\"github.com/KubeOperator/kubepi/internal/api/v1/cluster\"\n\t\"github.com/KubeOperator/kubepi/internal/api/v1/imagerepo\"\n\t\"github.com/KubeOperator/kubepi/internal/api/v1/ldap\"\n\t\"github.com/KubeOperator/kubepi/internal/api/v1/proxy\"\n\t\"github.com/KubeOperator/kubepi/internal/api/v1/role\"\n\t\"github.com/KubeOperator/kubepi/internal/api/v1/session\"\n\t\"github.com/KubeOperator/kubepi/internal/api/v1/system\"\n\t\"github.com/KubeOperator/kubepi/internal/api/v1/user\"\n\t\"github.com/KubeOperator/kubepi/internal/api/v1/webkubectl\"\n\t\"github.com/KubeOperator/kubepi/internal/api/v1/ws\"\n\tv1 \"github.com/KubeOperator/kubepi/internal/model/v1\"\n\tv1Role \"github.com/KubeOperator/kubepi/internal/model/v1/role\"\n\tv1System \"github.com/KubeOperator/kubepi/internal/model/v1/system\"\n\t\"github.com/KubeOperator/kubepi/internal/service/v1/common\"\n\tv1RoleService \"github.com/KubeOperator/kubepi/internal/service/v1/role\"\n\tv1RoleBindingService \"github.com/KubeOperator/kubepi/internal/service/v1/rolebinding\"\n\tv1SystemService \"github.com/KubeOperator/kubepi/internal/service/v1/system\"\n\tpkgV1 \"github.com/KubeOperator/kubepi/pkg/api/v1\"\n\t\"github.com/KubeOperator/kubepi/pkg/collectons\"\n\t\"github.com/KubeOperator/kubepi/pkg/i18n\"\n\t\"github.com/asdine/storm/v3\"\n\t\"github.com/kataras/iris/v12\"\n\t\"github.com/kataras/iris/v12/context\"\n\t\"github.com/kataras/iris/v12/core/router\"\n)\n\nvar resourceWhiteList = WhiteList{\"sessions\", \"proxy\", \"ws\", \"charts\", \"webkubectl\", \"apps\", \"mfa\", \"pod\"}\n\ntype WhiteList []string\n\nfunc (w WhiteList) In(name string) bool {\n\tfor i := range w {\n\t\tif w[i] == name {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc authHandler() iris.Handler {\n\treturn func(ctx *context.Context) {\n\t\tvar p session.UserProfile\n\t\tif ctx.GetHeader(\"Authorization\") != \"\" {\n\t\t\tpr := jwt.Get(ctx).(*session.UserProfile)\n\t\t\tp = *pr\n\n\t\t} else {\n\t\t\tp = server.SessionMgr.Start(ctx).Get(\"profile\").(session.UserProfile)\n\t\t}\n\t\tif p.Name == \"\" {\n\t\t\tctx.Values().Set(\"message\", \"please login\")\n\t\t\tctx.StopWithStatus(iris.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tctx.Values().Set(\"profile\", p)\n\t\tctx.Next()\n\t}\n}\n\nfunc langHandler() iris.Handler {\n\treturn func(ctx *context.Context) {\n\t\tp := ctx.Values().Get(\"profile\")\n\t\tu, ok := p.(session.UserProfile)\n\t\tlang := i18n.LanguageZhCN\n\t\tif ok {\n\t\t\tlang = u.Language\n\t\t}\n\t\tctx.Values().Set(\"language\", lang)\n\t\tctx.Next()\n\t}\n}\n\nfunc pageHandler() iris.Handler {\n\treturn func(ctx *context.Context) {\n\t\tif ctx.URLParamExists(pkgV1.PageSize) && ctx.URLParamExists(pkgV1.PageNum) {\n\t\t\tpageNum, err := ctx.URLParamInt(pkgV1.PageNum)\n\t\t\tif err != nil {\n\t\t\t\tctx.Values().Set(\"message\", fmt.Sprintf(\"page num format err %s\", err.Error()))\n\t\t\t\tctx.StopWithStatus(iris.StatusBadRequest)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tpageSize, err := ctx.URLParamInt(pkgV1.PageSize)\n\t\t\tif err != nil {\n\t\t\t\tctx.Values().Set(\"message\", fmt.Sprintf(\"page size format err %s\", err.Error()))\n\t\t\t\tctx.StopWithStatus(iris.StatusBadRequest)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tctx.Values().Set(pkgV1.PageNum, pageNum)\n\t\t\tctx.Values().Set(pkgV1.PageSize, pageSize)\n\t\t}\n\t\tctx.Next()\n\t}\n}\n\ntype logHelper struct {\n\tName     string `json:\"name\"`\n\tMetadata v1.Metadata\n}\n\nfunc logHandler() iris.Handler {\n\treturn func(ctx *context.Context) {\n\t\tmethod := strings.ToLower(ctx.Method())\n\t\tif method != \"post\" && method != \"delete\" && method != \"put\" {\n\t\t\tctx.Next()\n\t\t\treturn\n\t\t}\n\n\t\tresourceName := ctx.Values().GetString(\"resource\")\n\t\tif resourceName == \"\" || resourceWhiteList.In(resourceName) {\n\t\t\tctx.Next()\n\t\t\treturn\n\t\t}\n\n\t\tcurrentPath := ctx.GetCurrentRoute().Path()\n\t\tpath := strings.Replace(ctx.Request().URL.Path, \"/kubepi/api/v1/\", \"\", 1)\n\t\tcurrentPath = strings.Replace(currentPath, \"/kubepi/api/v1/\", \"\", 1)\n\t\tif strings.HasSuffix(path, \"search\") {\n\t\t\tctx.Next()\n\t\t\treturn\n\t\t}\n\n\t\tu := ctx.Values().Get(\"profile\")\n\t\tprofile := u.(session.UserProfile)\n\t\tvar log v1System.OperationLog\n\t\tlog.Operator = profile.Name\n\t\tlog.Operation = method\n\n\t\t//handle ldap operate\n\t\tif strings.Contains(path, \"ldap\") {\n\t\t\tif strings.Contains(path, \"import\") {\n\t\t\t\tlog.Operation = \"import\"\n\t\t\t}\n\t\t\tif strings.Contains(path, \"sync\") {\n\t\t\t\tlog.Operation = \"sync\"\n\t\t\t}\n\t\t\tif strings.Contains(path, \"connect\") {\n\t\t\t\tlog.Operation = \"testConnect\"\n\t\t\t}\n\t\t\tif strings.Contains(path, \"login\") {\n\t\t\t\tlog.Operation = \"testLogin\"\n\t\t\t}\n\t\t}\n\n\t\tpathResource := strings.Split(path, \"/\")\n\t\tif strings.HasPrefix(currentPath, \"clusters/:name\") {\n\t\t\tif len(pathResource) < 3 {\n\t\t\t\tlog.OperationDomain = pathResource[0]\n\t\t\t\tif method != \"post\" {\n\t\t\t\t\tlog.SpecificInformation = pathResource[1]\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlog.OperationDomain = fmt.Sprintf(\"%s_%s\", pathResource[0], pathResource[2])\n\t\t\t\tif method != \"post\" {\n\t\t\t\t\tif len(pathResource) > 3 {\n\t\t\t\t\t\tlog.SpecificInformation = fmt.Sprintf(\"[%s] %s\", pathResource[1], pathResource[3])\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlog.SpecificInformation = fmt.Sprintf(\"[%s] %s\", pathResource[1], \"-\")\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tlog.OperationDomain = strings.Split(currentPath, \"/\")[0]\n\t\t\tif method != \"post\" {\n\t\t\t\tif len(pathResource) > 1 {\n\t\t\t\t\tlog.SpecificInformation = pathResource[1]\n\t\t\t\t} else {\n\t\t\t\t\tlog.SpecificInformation = \"-\"\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif !strings.Contains(currentPath, \"upload\") {\n\t\t\tif method == \"post\" {\n\t\t\t\tvar req logHelper\n\t\t\t\tdata, _ := ctx.GetBody()\n\t\t\t\tif err := json.Unmarshal(data, &req); err != nil {\n\t\t\t\t\tctx.Next()\n\t\t\t\t}\n\t\t\t\tif len(req.Name) == 0 {\n\t\t\t\t\treq.Name = req.Metadata.Name\n\t\t\t\t}\n\t\t\t\tif strings.HasPrefix(currentPath, \"clusters/:name\") {\n\t\t\t\t\tlog.SpecificInformation = fmt.Sprintf(\"[%s] %s\", pathResource[1], req.Name)\n\t\t\t\t} else {\n\t\t\t\t\tlog.SpecificInformation = req.Name\n\t\t\t\t}\n\t\t\t\tctx.Request().Body = ioutil.NopCloser(bytes.NewBuffer(data))\n\t\t\t}\n\t\t}\n\t\tsystemService := v1SystemService.NewService()\n\t\tgo systemService.CreateOperationLog(&log, common.DBOptions{})\n\t\tctx.Next()\n\t}\n}\n\nfunc resourceExtractHandler() iris.Handler {\n\treturn func(ctx *context.Context) {\n\t\tpath := ctx.Request().URL.Path\n\t\tss := strings.Split(path, \"/\")\n\t\t// \"\" \"api\" \"v1\" \"resource\"\n\t\tif len(ss) >= 5 {\n\t\t\tctx.Values().Set(\"resource\", ss[4])\n\t\t}\n\t\tctx.Next()\n\t}\n}\n\nfunc roleHandler() iris.Handler {\n\treturn func(ctx *context.Context) {\n\t\t// \u67e5\u8be2\u5f53\u524d\u7528\u6237\u7684\u89d2\u8272\n\t\t// \u67e5\u8be2\u89d2\u8272\u7684 rolebinding \u83b7\u53d6 roles\n\t\tp := ctx.Values().Get(\"profile\")\n\t\tu := p.(session.UserProfile)\n\n\t\tif u.IsAdministrator {\n\t\t\tctx.Next()\n\t\t\treturn\n\t\t}\n\t\troleBindingService := v1RoleBindingService.NewService()\n\t\trbs, err := roleBindingService.GetRoleBindingBySubject(v1Role.Subject{\n\t\t\tKind: \"User\",\n\t\t\tName: u.Name,\n\t\t}, common.DBOptions{})\n\t\tif err != nil {\n\t\t\tif !errors.As(err, &storm.ErrNotFound) {\n\t\t\t\tctx.StatusCode(iris.StatusInternalServerError)\n\t\t\t\tctx.Values().Set(\"message\", err.Error())\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\troleNameHash := map[string]struct{}{}\n\t\tfor i := range rbs {\n\t\t\troleName := rbs[i].RoleRef\n\t\t\troleNameHash[roleName] = struct{}{}\n\t\t}\n\t\tvar roleNames []string\n\t\tfor key := range roleNameHash {\n\t\t\troleNames = append(roleNames, key)\n\t\t}\n\n\t\troleService := v1RoleService.NewService()\n\t\trs, err := roleService.GetByNames(roleNames, common.DBOptions{})\n\t\tif err != nil {\n\t\t\tctx.StatusCode(iris.StatusInternalServerError)\n\t\t\tctx.Values().Set(\"message\", err.Error())\n\t\t\treturn\n\t\t}\n\n\t\tctx.Values().Set(\"roles\", rs)\n\t\tctx.Next()\n\t}\n}\n\nfunc getVerbByRoute(path, method string) string {\n\tswitch strings.ToLower(method) {\n\tcase \"put\":\n\t\treturn \"update\"\n\tcase \"delete\":\n\t\treturn \"delete\"\n\tcase \"get\":\n\t\tif strings.Contains(path, \"/:name\") {\n\t\t\treturn \"get\"\n\t\t} else {\n\t\t\treturn \"list\"\n\t\t}\n\tcase \"post\":\n\t\tif strings.HasSuffix(path, \"search\") {\n\t\t\treturn \"list\"\n\t\t}\n\t\treturn \"create\"\n\n\t}\n\treturn \"\"\n}\n\nfunc apiResourceHandler(party iris.Party) iris.Handler {\n\treturn func(ctx *context.Context) {\n\t\t//1. \u786e\u5b9a\u6240\u6709\u7684api\u8d44\u6e90\u6709\u54ea\u4e9b\n\t\tapiBuilder := party.(*router.APIBuilder)\n\t\troutes := apiBuilder.GetRoutes()\n\t\tresourceMap := map[string]*collectons.StringSet{}\n\t\tfor i := range routes {\n\t\t\tif strings.HasPrefix(routes[i].Path, \"/kubepi/api/v1/\") {\n\t\t\t\tss := strings.Split(routes[i].Path, \"/\")\n\t\t\t\tif len(ss) >= 5 {\n\t\t\t\t\tresourceName := ss[4]\n\t\t\t\t\t//\u8fc7\u6ee4session\u8d44\u6e90\n\t\t\t\t\tif resourceWhiteList.In(resourceName) {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tif _, ok := resourceMap[resourceName]; !ok {\n\t\t\t\t\t\tresourceMap[resourceName] = collectons.NewStringSet()\n\t\t\t\t\t}\n\t\t\t\t\tresourceMap[resourceName].Add(getVerbByRoute(routes[i].Path, routes[i].Method))\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdisplayMap := map[string][]string{}\n\t\tfor k := range resourceMap {\n\t\t\tverbs := resourceMap[k]\n\t\t\tif len(verbs.ToSlice()) > 0 {\n\t\t\t\tdisplayMap[k] = verbs.ToSlice()\n\t\t\t}\n\t\t}\n\t\tif ops, ok := displayMap[\"clusters\"]; ok {\n\t\t\tops = append(ops, \"authorization\")\n\t\t\tdisplayMap[\"clusters\"] = ops\n\t\t}\n\t\tctx.Values().Set(\"data\", displayMap)\n\t}\n}\n\nfunc roleAccessHandler() iris.Handler {\n\treturn func(ctx *context.Context) {\n\t\t//// \u67e5\u8be2\u89d2\u8272\u7684 resources\n\t\t//// \u901a\u8fc7api resource \u8fc7\u6ee4\u51fa\u6765\u8d44\u6e90\u4e3b\u4f53,method \u8fc7\u6ee4\u64cd\u4f5c\n\t\tp := ctx.Values().Get(\"profile\")\n\t\tu := p.(session.UserProfile)\n\t\tisInWhiteList := false\n\t\tfor _, path := range resourceWhiteList {\n\t\t\tif strings.Contains(ctx.Request().URL.Path, fmt.Sprintf(\"/%s\", path)) && path != \"sessions\" {\n\t\t\t\tisInWhiteList = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isInWhiteList {\n\t\t\t// \u653e\u901aadmin\u6743\u9650\n\t\t\tif u.IsAdministrator {\n\t\t\t\tctx.Next()\n\t\t\t\treturn\n\t\t\t}\n\t\t\trs := ctx.Values().Get(\"roles\")\n\t\t\troles := rs.([]v1Role.Role)\n\t\t\trequestResource := ctx.Values().GetString(\"resource\")\n\t\t\tif requestResource != \"\" {\n\t\t\t\tcurrentRoute := ctx.GetCurrentRoute()\n\t\t\t\trequestVerb := getVerbByRoute(currentRoute.Path(), currentRoute.Method())\n\t\t\t\tresourceMatched, methodMatch := matchRoles(requestResource, requestVerb, roles)\n\t\t\t\tif !(resourceMatched && methodMatch) {\n\t\t\t\t\tctx.StopWithStatus(iris.StatusForbidden)\n\t\t\t\t\tctx.Values().Set(\"message\", []string{\"user %s can not access resource %s %s\", u.Name, requestResource, requestVerb})\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tctx.Next()\n\t}\n}\n\nfunc matchRoles(requestResource, requestMethod string, rs []v1Role.Role) (bool, bool) {\n\tresourceMatch := false\n\tmethodMatch := false\n\tfor i := range rs {\n\t\tfor j := range rs[i].Rules {\n\t\t\tfor k := range rs[i].Rules[j].Resource {\n\t\t\t\tif rs[i].Rules[j].Resource[k] == requestResource || rs[i].Rules[j].Resource[k] == \"*\" {\n\t\t\t\t\tresourceMatch = true\n\t\t\t\t\tfor x := range rs[i].Rules[j].Verbs {\n\t\t\t\t\t\tif rs[i].Rules[j].Verbs[x] == requestMethod || rs[i].Rules[j].Verbs[x] == \"*\" {\n\t\t\t\t\t\t\tmethodMatch = true\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn resourceMatch, methodMatch\n}\n\nfunc resourceNameInvalidHandler() iris.Handler {\n\treturn func(ctx *context.Context) {\n\t\tr := ctx.GetCurrentRoute()\n\t\tif strings.Contains(r.Path(), \"/:name\") {\n\t\t\tresourceName := ctx.Params().GetString(\"name\")\n\t\t\tif resourceName == \"\" {\n\t\t\t\tctx.StatusCode(iris.StatusBadRequest)\n\t\t\t\tctx.Values().Set(\"message\", fmt.Sprintf(\"invalid resource name %s\", resourceName))\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tctx.Next()\n\t}\n}\n\nfunc WarpedJwtHandler() iris.Handler {\n\tverifier := jwt.NewVerifier(jwt.HS256, server.Config().Spec.Jwt.Key)\n\tverifier.WithDefaultBlocklist()\n\tverifyMiddleware := verifier.Verify(func() interface{} {\n\t\treturn new(session.UserProfile)\n\t})\n\treturn func(ctx *context.Context) {\n\t\tsess := server.SessionMgr.Start(ctx)\n\t\tif sess.Get(\"profile\") != nil {\n\t\t\tctx.Next()\n\t\t\treturn\n\t\t}\n\t\tverifyMiddleware(ctx)\n\t}\n}\n\nfunc AddV1Route(app iris.Party) {\n\n\tv1Party := app.Party(\"/v1\")\n\tv1Party.Use(langHandler())\n\tv1Party.Use(pageHandler())\n\tsession.Install(v1Party)\n\tmfa.Install(v1Party)\n\tauthParty := v1Party.Party(\"\")\n\n\tauthParty.Use(WarpedJwtHandler())\n\tauthParty.Use(authHandler())\n\tauthParty.Use(resourceExtractHandler())\n\tauthParty.Use(roleHandler())\n\tauthParty.Use(roleAccessHandler())\n\tauthParty.Use(resourceNameInvalidHandler())\n\tauthParty.Use(logHandler())\n\tauthParty.Get(\"/\", apiResourceHandler(authParty))\n\tuser.Install(authParty)\n\tcluster.Install(authParty)\n\trole.Install(authParty)\n\tsystem.Install(v1Party)\n\tproxy.Install(authParty)\n\tws.Install(authParty)\n\tchart.Install(authParty)\n\twebkubectl.Install(authParty, v1Party)\n\tldap.Install(authParty)\n\timagerepo.Install(authParty)\n\tfile.Install(authParty)\n}\n"], "fixing_code": ["package v1\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"strings\"\n\n\t\"github.com/KubeOperator/kubepi/internal/api/v1/mfa\"\n\t\"github.com/KubeOperator/kubepi/internal/server\"\n\n\t\"github.com/KubeOperator/kubepi/internal/api/v1/file\"\n\t\"github.com/kataras/iris/v12/middleware/jwt\"\n\n\t\"github.com/KubeOperator/kubepi/internal/api/v1/chart\"\n\t\"github.com/KubeOperator/kubepi/internal/api/v1/cluster\"\n\t\"github.com/KubeOperator/kubepi/internal/api/v1/imagerepo\"\n\t\"github.com/KubeOperator/kubepi/internal/api/v1/ldap\"\n\t\"github.com/KubeOperator/kubepi/internal/api/v1/proxy\"\n\t\"github.com/KubeOperator/kubepi/internal/api/v1/role\"\n\t\"github.com/KubeOperator/kubepi/internal/api/v1/session\"\n\t\"github.com/KubeOperator/kubepi/internal/api/v1/system\"\n\t\"github.com/KubeOperator/kubepi/internal/api/v1/user\"\n\t\"github.com/KubeOperator/kubepi/internal/api/v1/webkubectl\"\n\t\"github.com/KubeOperator/kubepi/internal/api/v1/ws\"\n\tv1 \"github.com/KubeOperator/kubepi/internal/model/v1\"\n\tv1Role \"github.com/KubeOperator/kubepi/internal/model/v1/role\"\n\tv1System \"github.com/KubeOperator/kubepi/internal/model/v1/system\"\n\t\"github.com/KubeOperator/kubepi/internal/service/v1/common\"\n\tv1RoleService \"github.com/KubeOperator/kubepi/internal/service/v1/role\"\n\tv1RoleBindingService \"github.com/KubeOperator/kubepi/internal/service/v1/rolebinding\"\n\tv1SystemService \"github.com/KubeOperator/kubepi/internal/service/v1/system\"\n\tpkgV1 \"github.com/KubeOperator/kubepi/pkg/api/v1\"\n\t\"github.com/KubeOperator/kubepi/pkg/collectons\"\n\t\"github.com/KubeOperator/kubepi/pkg/i18n\"\n\t\"github.com/asdine/storm/v3\"\n\t\"github.com/kataras/iris/v12\"\n\t\"github.com/kataras/iris/v12/context\"\n\t\"github.com/kataras/iris/v12/core/router\"\n)\n\nvar resourceWhiteList = WhiteList{\"sessions\", \"proxy\", \"ws\", \"charts\", \"webkubectl\", \"apps\", \"mfa\", \"pod\"}\n\ntype WhiteList []string\n\nfunc (w WhiteList) In(name string) bool {\n\tfor i := range w {\n\t\tif w[i] == name {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc authHandler() iris.Handler {\n\treturn func(ctx *context.Context) {\n\t\tvar p session.UserProfile\n\t\tif ctx.GetHeader(\"Authorization\") != \"\" {\n\t\t\tpr := jwt.Get(ctx).(*session.UserProfile)\n\t\t\tp = *pr\n\n\t\t} else {\n\t\t\tp = server.SessionMgr.Start(ctx).Get(\"profile\").(session.UserProfile)\n\t\t}\n\t\tif p.Name == \"\" {\n\t\t\tctx.Values().Set(\"message\", \"please login\")\n\t\t\tctx.StopWithStatus(iris.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tctx.Values().Set(\"profile\", p)\n\t\tctx.Next()\n\t}\n}\n\nfunc langHandler() iris.Handler {\n\treturn func(ctx *context.Context) {\n\t\tp := ctx.Values().Get(\"profile\")\n\t\tu, ok := p.(session.UserProfile)\n\t\tlang := i18n.LanguageZhCN\n\t\tif ok {\n\t\t\tlang = u.Language\n\t\t}\n\t\tctx.Values().Set(\"language\", lang)\n\t\tctx.Next()\n\t}\n}\n\nfunc pageHandler() iris.Handler {\n\treturn func(ctx *context.Context) {\n\t\tif ctx.URLParamExists(pkgV1.PageSize) && ctx.URLParamExists(pkgV1.PageNum) {\n\t\t\tpageNum, err := ctx.URLParamInt(pkgV1.PageNum)\n\t\t\tif err != nil {\n\t\t\t\tctx.Values().Set(\"message\", fmt.Sprintf(\"page num format err %s\", err.Error()))\n\t\t\t\tctx.StopWithStatus(iris.StatusBadRequest)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tpageSize, err := ctx.URLParamInt(pkgV1.PageSize)\n\t\t\tif err != nil {\n\t\t\t\tctx.Values().Set(\"message\", fmt.Sprintf(\"page size format err %s\", err.Error()))\n\t\t\t\tctx.StopWithStatus(iris.StatusBadRequest)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tctx.Values().Set(pkgV1.PageNum, pageNum)\n\t\t\tctx.Values().Set(pkgV1.PageSize, pageSize)\n\t\t}\n\t\tctx.Next()\n\t}\n}\n\ntype logHelper struct {\n\tName     string `json:\"name\"`\n\tMetadata v1.Metadata\n}\n\nfunc logHandler() iris.Handler {\n\treturn func(ctx *context.Context) {\n\t\tmethod := strings.ToLower(ctx.Method())\n\t\tif method != \"post\" && method != \"delete\" && method != \"put\" {\n\t\t\tctx.Next()\n\t\t\treturn\n\t\t}\n\n\t\tresourceName := ctx.Values().GetString(\"resource\")\n\t\tif resourceName == \"\" || resourceWhiteList.In(resourceName) {\n\t\t\tctx.Next()\n\t\t\treturn\n\t\t}\n\n\t\tcurrentPath := ctx.GetCurrentRoute().Path()\n\t\tpath := strings.Replace(ctx.Request().URL.Path, \"/kubepi/api/v1/\", \"\", 1)\n\t\tcurrentPath = strings.Replace(currentPath, \"/kubepi/api/v1/\", \"\", 1)\n\t\tif strings.HasSuffix(path, \"search\") {\n\t\t\tctx.Next()\n\t\t\treturn\n\t\t}\n\n\t\tu := ctx.Values().Get(\"profile\")\n\t\tprofile := u.(session.UserProfile)\n\t\tvar log v1System.OperationLog\n\t\tlog.Operator = profile.Name\n\t\tlog.Operation = method\n\n\t\t//handle ldap operate\n\t\tif strings.Contains(path, \"ldap\") {\n\t\t\tif strings.Contains(path, \"import\") {\n\t\t\t\tlog.Operation = \"import\"\n\t\t\t}\n\t\t\tif strings.Contains(path, \"sync\") {\n\t\t\t\tlog.Operation = \"sync\"\n\t\t\t}\n\t\t\tif strings.Contains(path, \"connect\") {\n\t\t\t\tlog.Operation = \"testConnect\"\n\t\t\t}\n\t\t\tif strings.Contains(path, \"login\") {\n\t\t\t\tlog.Operation = \"testLogin\"\n\t\t\t}\n\t\t}\n\n\t\tpathResource := strings.Split(path, \"/\")\n\t\tif strings.HasPrefix(currentPath, \"clusters/:name\") {\n\t\t\tif len(pathResource) < 3 {\n\t\t\t\tlog.OperationDomain = pathResource[0]\n\t\t\t\tif method != \"post\" {\n\t\t\t\t\tlog.SpecificInformation = pathResource[1]\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlog.OperationDomain = fmt.Sprintf(\"%s_%s\", pathResource[0], pathResource[2])\n\t\t\t\tif method != \"post\" {\n\t\t\t\t\tif len(pathResource) > 3 {\n\t\t\t\t\t\tlog.SpecificInformation = fmt.Sprintf(\"[%s] %s\", pathResource[1], pathResource[3])\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlog.SpecificInformation = fmt.Sprintf(\"[%s] %s\", pathResource[1], \"-\")\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tlog.OperationDomain = strings.Split(currentPath, \"/\")[0]\n\t\t\tif method != \"post\" {\n\t\t\t\tif len(pathResource) > 1 {\n\t\t\t\t\tlog.SpecificInformation = pathResource[1]\n\t\t\t\t} else {\n\t\t\t\t\tlog.SpecificInformation = \"-\"\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif !strings.Contains(currentPath, \"upload\") {\n\t\t\tif method == \"post\" {\n\t\t\t\tvar req logHelper\n\t\t\t\tdata, _ := ctx.GetBody()\n\t\t\t\tif err := json.Unmarshal(data, &req); err != nil {\n\t\t\t\t\tctx.Next()\n\t\t\t\t}\n\t\t\t\tif len(req.Name) == 0 {\n\t\t\t\t\treq.Name = req.Metadata.Name\n\t\t\t\t}\n\t\t\t\tif strings.HasPrefix(currentPath, \"clusters/:name\") {\n\t\t\t\t\tlog.SpecificInformation = fmt.Sprintf(\"[%s] %s\", pathResource[1], req.Name)\n\t\t\t\t} else {\n\t\t\t\t\tlog.SpecificInformation = req.Name\n\t\t\t\t}\n\t\t\t\tctx.Request().Body = ioutil.NopCloser(bytes.NewBuffer(data))\n\t\t\t}\n\t\t}\n\t\tsystemService := v1SystemService.NewService()\n\t\tgo systemService.CreateOperationLog(&log, common.DBOptions{})\n\t\tctx.Next()\n\t}\n}\n\nfunc resourceExtractHandler() iris.Handler {\n\treturn func(ctx *context.Context) {\n\t\tpath := ctx.Request().URL.Path\n\t\tss := strings.Split(path, \"/\")\n\t\t// \"\" \"api\" \"v1\" \"resource\"\n\t\tif len(ss) >= 5 {\n\t\t\tctx.Values().Set(\"resource\", ss[4])\n\t\t}\n\t\tctx.Next()\n\t}\n}\n\nfunc roleHandler() iris.Handler {\n\treturn func(ctx *context.Context) {\n\t\t// \u67e5\u8be2\u5f53\u524d\u7528\u6237\u7684\u89d2\u8272\n\t\t// \u67e5\u8be2\u89d2\u8272\u7684 rolebinding \u83b7\u53d6 roles\n\t\tp := ctx.Values().Get(\"profile\")\n\t\tu := p.(session.UserProfile)\n\n\t\tif u.IsAdministrator {\n\t\t\tctx.Next()\n\t\t\treturn\n\t\t}\n\t\troleBindingService := v1RoleBindingService.NewService()\n\t\trbs, err := roleBindingService.GetRoleBindingBySubject(v1Role.Subject{\n\t\t\tKind: \"User\",\n\t\t\tName: u.Name,\n\t\t}, common.DBOptions{})\n\t\tif err != nil {\n\t\t\tif !errors.As(err, &storm.ErrNotFound) {\n\t\t\t\tctx.StatusCode(iris.StatusInternalServerError)\n\t\t\t\tctx.Values().Set(\"message\", err.Error())\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\troleNameHash := map[string]struct{}{}\n\t\tfor i := range rbs {\n\t\t\troleName := rbs[i].RoleRef\n\t\t\troleNameHash[roleName] = struct{}{}\n\t\t}\n\t\tvar roleNames []string\n\t\tfor key := range roleNameHash {\n\t\t\troleNames = append(roleNames, key)\n\t\t}\n\n\t\troleService := v1RoleService.NewService()\n\t\trs, err := roleService.GetByNames(roleNames, common.DBOptions{})\n\t\tif err != nil {\n\t\t\tctx.StatusCode(iris.StatusInternalServerError)\n\t\t\tctx.Values().Set(\"message\", err.Error())\n\t\t\treturn\n\t\t}\n\n\t\tctx.Values().Set(\"roles\", rs)\n\t\tctx.Next()\n\t}\n}\n\nfunc getVerbByRoute(path, method string) string {\n\tswitch strings.ToLower(method) {\n\tcase \"put\":\n\t\treturn \"update\"\n\tcase \"delete\":\n\t\treturn \"delete\"\n\tcase \"get\":\n\t\tif strings.Contains(path, \"/:name\") {\n\t\t\treturn \"get\"\n\t\t} else {\n\t\t\treturn \"list\"\n\t\t}\n\tcase \"post\":\n\t\tif strings.HasSuffix(path, \"search\") {\n\t\t\treturn \"list\"\n\t\t}\n\t\treturn \"create\"\n\n\t}\n\treturn \"\"\n}\n\nfunc apiResourceHandler(party iris.Party) iris.Handler {\n\treturn func(ctx *context.Context) {\n\t\t//1. \u786e\u5b9a\u6240\u6709\u7684api\u8d44\u6e90\u6709\u54ea\u4e9b\n\t\tapiBuilder := party.(*router.APIBuilder)\n\t\troutes := apiBuilder.GetRoutes()\n\t\tresourceMap := map[string]*collectons.StringSet{}\n\t\tfor i := range routes {\n\t\t\tif strings.HasPrefix(routes[i].Path, \"/kubepi/api/v1/\") {\n\t\t\t\tss := strings.Split(routes[i].Path, \"/\")\n\t\t\t\tif len(ss) >= 5 {\n\t\t\t\t\tresourceName := ss[4]\n\t\t\t\t\t//\u8fc7\u6ee4session\u8d44\u6e90\n\t\t\t\t\tif resourceWhiteList.In(resourceName) {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tif _, ok := resourceMap[resourceName]; !ok {\n\t\t\t\t\t\tresourceMap[resourceName] = collectons.NewStringSet()\n\t\t\t\t\t}\n\t\t\t\t\tresourceMap[resourceName].Add(getVerbByRoute(routes[i].Path, routes[i].Method))\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdisplayMap := map[string][]string{}\n\t\tfor k := range resourceMap {\n\t\t\tverbs := resourceMap[k]\n\t\t\tif len(verbs.ToSlice()) > 0 {\n\t\t\t\tdisplayMap[k] = verbs.ToSlice()\n\t\t\t}\n\t\t}\n\t\tif ops, ok := displayMap[\"clusters\"]; ok {\n\t\t\tops = append(ops, \"authorization\")\n\t\t\tdisplayMap[\"clusters\"] = ops\n\t\t}\n\t\tctx.Values().Set(\"data\", displayMap)\n\t}\n}\n\nfunc roleAccessHandler() iris.Handler {\n\treturn func(ctx *context.Context) {\n\t\t//// \u67e5\u8be2\u89d2\u8272\u7684 resources\n\t\t//// \u901a\u8fc7api resource \u8fc7\u6ee4\u51fa\u6765\u8d44\u6e90\u4e3b\u4f53,method \u8fc7\u6ee4\u64cd\u4f5c\n\t\tp := ctx.Values().Get(\"profile\")\n\t\tu := p.(session.UserProfile)\n\t\tisInWhiteList := false\n\t\tfor _, path := range resourceWhiteList {\n\t\t\tif strings.Contains(ctx.Request().URL.Path, fmt.Sprintf(\"/%s\", path)) && path != \"sessions\" {\n\t\t\t\tisInWhiteList = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isInWhiteList {\n\t\t\t// \u653e\u901aadmin\u6743\u9650\n\t\t\tif u.IsAdministrator {\n\t\t\t\tctx.Next()\n\t\t\t\treturn\n\t\t\t}\n\t\t\trs := ctx.Values().Get(\"roles\")\n\t\t\troles := rs.([]v1Role.Role)\n\t\t\trequestResource := ctx.Values().GetString(\"resource\")\n\t\t\tif requestResource != \"\" {\n\t\t\t\tcurrentRoute := ctx.GetCurrentRoute()\n\t\t\t\trequestVerb := getVerbByRoute(currentRoute.Path(), currentRoute.Method())\n\t\t\t\tresourceMatched, methodMatch := matchRoles(requestResource, requestVerb, roles)\n\t\t\t\tif !(resourceMatched && methodMatch) {\n\t\t\t\t\tctx.StopWithStatus(iris.StatusForbidden)\n\t\t\t\t\tctx.Values().Set(\"message\", []string{\"user %s can not access resource %s %s\", u.Name, requestResource, requestVerb})\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tctx.Next()\n\t}\n}\n\nfunc matchRoles(requestResource, requestMethod string, rs []v1Role.Role) (bool, bool) {\n\tresourceMatch := false\n\tmethodMatch := false\n\tfor i := range rs {\n\t\tfor j := range rs[i].Rules {\n\t\t\tfor k := range rs[i].Rules[j].Resource {\n\t\t\t\tif rs[i].Rules[j].Resource[k] == requestResource || rs[i].Rules[j].Resource[k] == \"*\" {\n\t\t\t\t\tresourceMatch = true\n\t\t\t\t\tfor x := range rs[i].Rules[j].Verbs {\n\t\t\t\t\t\tif rs[i].Rules[j].Verbs[x] == requestMethod || rs[i].Rules[j].Verbs[x] == \"*\" {\n\t\t\t\t\t\t\tmethodMatch = true\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn resourceMatch, methodMatch\n}\n\nfunc resourceNameInvalidHandler() iris.Handler {\n\treturn func(ctx *context.Context) {\n\t\tr := ctx.GetCurrentRoute()\n\t\tif strings.Contains(r.Path(), \"/:name\") {\n\t\t\tresourceName := ctx.Params().GetString(\"name\")\n\t\t\tif resourceName == \"\" {\n\t\t\t\tctx.StatusCode(iris.StatusBadRequest)\n\t\t\t\tctx.Values().Set(\"message\", fmt.Sprintf(\"invalid resource name %s\", resourceName))\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tctx.Next()\n\t}\n}\n\nfunc WarpedJwtHandler() iris.Handler {\n\tverifier := jwt.NewVerifier(jwt.HS256, server.Config().Spec.Jwt.Key)\n\tverifier.WithDefaultBlocklist()\n\tverifyMiddleware := verifier.Verify(func() interface{} {\n\t\treturn new(session.UserProfile)\n\t})\n\treturn func(ctx *context.Context) {\n\t\tsess := server.SessionMgr.Start(ctx)\n\t\tif sess.Get(\"profile\") != nil {\n\t\t\tctx.Next()\n\t\t\treturn\n\t\t}\n\t\tverifyMiddleware(ctx)\n\t}\n}\n\nfunc AddV1Route(app iris.Party) {\n\n\tv1Party := app.Party(\"/v1\")\n\n\tsession.Install(v1Party)\n\tmfa.Install(v1Party)\n\tauthParty := v1Party.Party(\"\")\n\tv1Party.Use(langHandler())\n\tv1Party.Use(pageHandler())\n\n\tauthParty.Use(WarpedJwtHandler())\n\tauthParty.Use(authHandler())\n\tauthParty.Use(resourceExtractHandler())\n\tauthParty.Use(roleHandler())\n\tauthParty.Use(roleAccessHandler())\n\tauthParty.Use(resourceNameInvalidHandler())\n\tauthParty.Use(logHandler())\n\tauthParty.Get(\"/\", apiResourceHandler(authParty))\n\tuser.Install(authParty)\n\tcluster.Install(authParty)\n\trole.Install(authParty)\n\tsystem.Install(authParty)\n\tproxy.Install(authParty)\n\tws.Install(authParty)\n\tchart.Install(authParty)\n\twebkubectl.Install(authParty, v1Party)\n\tldap.Install(authParty)\n\timagerepo.Install(authParty)\n\tfile.Install(authParty)\n}\n"], "filenames": ["internal/api/v1/v1.go"], "buggy_code_start_loc": [422], "buggy_code_end_loc": [440], "fixing_code_start_loc": [422], "fixing_code_end_loc": [441], "type": "CWE-862", "message": "KubePi is a modern Kubernetes panel. The API interfaces with unauthorized entities and may leak sensitive information. This issue has been patched in version 1.6.4. There are currently no known workarounds.", "other": {"cve": {"id": "CVE-2023-22478", "sourceIdentifier": "security-advisories@github.com", "published": "2023-01-14T01:15:14.637", "lastModified": "2023-01-24T18:39:23.020", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "KubePi is a modern Kubernetes panel. The API interfaces with unauthorized entities and may leak sensitive information. This issue has been patched in version 1.6.4. There are currently no known workarounds."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 7.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.4}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-862"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:fit2cloud:kubepi:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.6.4", "matchCriteriaId": "A6B7CC4D-D5A0-4221-854C-2F37D2BB873C"}]}]}], "references": [{"url": "https://github.com/KubeOperator/KubePi/commit/0c6774bf5d9003ae4d60257a3f207c131ff4a6d6", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/KubeOperator/KubePi/releases/tag/v1.6.4", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/KubeOperator/KubePi/security/advisories/GHSA-gqx8-hxmv-c4v4", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/KubeOperator/KubePi/commit/0c6774bf5d9003ae4d60257a3f207c131ff4a6d6"}}