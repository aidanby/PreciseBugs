{"buggy_code": ["# frozen_string_literal: true\n\nmodule DiscourseJira\n  class IssuesController < ::ApplicationController\n    requires_plugin DiscourseJira::PLUGIN_NAME\n\n    before_action :ensure_logged_in, except: [:webhook]\n    before_action :ensure_can_create_jira_issue, except: [:webhook]\n    before_action :ensure_can_add_jira_issue_to_post, only: %i[create attach]\n\n    skip_before_action :check_xhr,\n                       :verify_authenticity_token,\n                       :redirect_to_login_if_required,\n                       :preload_json,\n                       only: [:webhook]\n\n    def preflight\n      render json: {\n               projects:\n                 ActiveModel::ArraySerializer.new(\n                   Project.all,\n                   each_serializer: JiraProjectSerializer,\n                 ).as_json,\n               email: current_user.email,\n             }\n    end\n\n    def fields\n      params.require(:project_id)\n      params.require(:issue_type_id)\n\n      fields =\n        ProjectIssueType.find_by(\n          project_id: params[:project_id].to_i,\n          issue_type_id: params[:issue_type_id].to_i,\n        ).fetch_fields\n\n      render json: { fields: fields }\n    end\n\n    def create\n      params.require(:project_id)\n      summary = I18n.t(\"discourse_jira.issue_title\", title: params[:title])\n      issue_type = IssueType.find_by(id: params[:issue_type_id])\n      raise Discourse::NotFound if issue_type.blank?\n\n      fields = {\n        project: {\n          key: project.key,\n        },\n        summary: summary,\n        description: params[:description],\n        issuetype: {\n          id: issue_type.uid,\n        },\n      }\n\n      (params[:fields] || []).each do |_, data|\n        next if data.blank?\n        next if data[:value].blank? && data[:required] != \"true\"\n\n        case data[:field_type]\n        when \"array\"\n          fields[data[:key]] = data[:value].map { |v| { id: v } }\n        when \"option\"\n          fields[data[:key]] = { id: data[:value] }\n        else\n          fields[data[:key]] = data[:value]\n        end\n      end\n      log(fields.inspect)\n\n      hijack(\n        info:\n          \"creating Jira issue for topic #{params[:topic_id]} and post_number #{params[:post_number]}\",\n      ) do\n        response = Api.post(\"issue\", { fields: fields })\n        json =\n          begin\n            JSON.parse(response.body, symbolize_names: true)\n          rescue StandardError\n            {}\n          end\n        log(json.inspect)\n\n        if response.code != \"201\"\n          log(\"Bad Jira response: #{response.body}\")\n          errors = (json[:errors] || {}).values.join(\" \")\n          error_message =\n            (\n              if errors.present?\n                I18n.t(\"discourse_jira.error_message\", errors: errors)\n              else\n                I18n.t(\"discourse_jira.bad_api_response\", status_code: response.code)\n              end\n            )\n          render_json_error(error_message, status: 422)\n          break\n        end\n\n        result =\n          success_json.merge(\n            {\n              issue_key: json[:key],\n              issue_url: URI.join(SiteSetting.discourse_jira_url, \"browse/#{json[:key]}\").to_s,\n            },\n          )\n\n        post.jira_issue_key = result[:issue_key]\n\n        if topic = Topic.find_by(id: params[:topic_id])\n          if current_user.guardian.can_create_post_on_topic?(topic)\n            topic.add_moderator_post(\n              current_user,\n              I18n.t(\"discourse_jira.small_action\", title: summary, url: result[:issue_url]),\n              post_type: Post.types[:whisper],\n              action_code: \"jira_issue\",\n            )\n          end\n        end\n\n        response = Api.get(json[:self])\n        post.custom_fields[\"jira_issue\"] = response.body\n        post.save_custom_fields\n\n        render json: result\n      end\n    end\n\n    def attach\n      raise Discourse::InvalidAccess if !SiteSetting.discourse_jira_enabled\n\n      hijack(\n        info:\n          \"attaching Jira issue for topic #{params[:topic_id]} and post_number #{params[:post_number]}\",\n      ) do\n        response = Api.get(\"issue/#{params[:issue_key]}\")\n\n        if response.code != \"200\"\n          log(\"Bad Jira response: #{response.body}\")\n          render_json_error(\n            I18n.t(\"discourse_jira.bad_api_response\", status_code: response.code),\n            status: 422,\n          )\n          break\n        end\n\n        json = JSON.parse(response.body, symbolize_names: true)\n\n        result =\n          success_json.merge(\n            {\n              issue_key: json[:key],\n              issue_url: URI.join(SiteSetting.discourse_jira_url, \"browse/#{json[:key]}\").to_s,\n            },\n          )\n\n        post.jira_issue_key = result[:issue_key]\n\n        if topic = Topic.find_by(id: params[:topic_id])\n          if current_user.guardian.can_create_post_on_topic?(topic)\n            topic.add_moderator_post(\n              current_user,\n              I18n.t(\n                \"discourse_jira.small_action\",\n                title: json[:fields][:summary],\n                url: result[:issue_url],\n              ),\n              post_type: Post.types[:whisper],\n              action_code: \"jira_issue\",\n            )\n          end\n        end\n\n        response = Api.get(json[:self])\n        post.custom_fields[\"jira_issue\"] = response.body\n        post.save_custom_fields\n\n        render json: result\n      end\n    end\n\n    def webhook\n      log(params.inspect)\n\n      if SiteSetting.discourse_jira_webhook_token.present?\n        params.require(:t)\n        if !ActiveSupport::SecurityUtils.secure_compare(\n             params[:t],\n             SiteSetting.discourse_jira_webhook_token,\n           )\n          raise Discourse::InvalidAccess\n        end\n      else\n        Rails.logger.warn(\n          \"discourse_jira_webhook_token is empty. Set a token to ensure malicious requests are not handled.\",\n        )\n      end\n\n      event = params[:webhookEvent]\n      issue_event = params[:issue_event_type_name]\n\n      if event == \"jira:issue_updated\"\n        issue = params[:issue]\n        post =\n          Post.joins(:_custom_fields).find_by(\n            _custom_fields: {\n              name: \"jira_issue_key\",\n              value: issue[:key],\n            },\n          )\n        raise Discourse::NotFound if post.blank?\n\n        post.custom_fields[\"jira_issue\"] = issue.to_json\n        post.save_custom_fields\n\n        if SiteSetting.discourse_jira_close_topic_on_resolve && issue[:fields][:resolution].present?\n          topic = post.topic\n          if post.post_number == 1 && topic&.open?\n            topic.update_status(\"closed\", true, Discourse.system_user)\n          end\n        end\n\n        if SiteSetting.discourse_jira_sync_issue_comments && issue_event == \"issue_commented\" &&\n             post.is_first_post?\n          topic = post.topic\n          comment = params[:comment]\n\n          PostCreator.create!(\n            Discourse.system_user,\n            topic_id: topic.id,\n            raw: comment[:body],\n            skip_validations: true,\n            custom_fields: {\n              \"jira_comment_id\" => comment[:id],\n            },\n          )\n        end\n      end\n\n      render json: success_json\n    end\n\n    private\n\n    def project\n      @project ||= Project.find_by(id: params[:project_id])\n    end\n\n    def ensure_can_create_jira_issue\n      guardian.ensure_can_create_jira_issue!\n    end\n\n    def ensure_can_add_jira_issue_to_post\n      if post.blank?\n        raise Discourse::NotFound\n      elsif post.has_jira_issue?\n        log \"Post #{post.id} already has a Jira issue\"\n        raise Discourse::InvalidAccess\n      end\n    end\n\n    def post\n      params.require(:topic_id)\n      params.require(:post_number)\n      @post ||= Post.find_by(topic_id: params[:topic_id], post_number: params[:post_number])\n    end\n\n    def log(message)\n      Rails.logger.warn(\"Jira verbose log:\\n #{message}\") if SiteSetting.discourse_jira_verbose_log\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nmodule DiscourseJira\n  class InvalidApiResponse < ::StandardError\n  end\n\n  class Api\n    INVALID_RESPONSE = \"Invalid response from Jira API server\"\n\n    def self.get_version!\n      if SiteSetting.discourse_jira_api_version == 0\n        data = JSON.parse(get(\"serverInfo\").body)\n        SiteSetting.discourse_jira_api_version = data[\"versionNumbers\"][0]\n      end\n\n      SiteSetting.discourse_jira_api_version\n    end\n\n    def self.createmeta_restricted?\n      api_version = get_version!\n      api_version >= 9 && api_version < 1000\n    end\n\n    def self.make_request(endpoint)\n      if endpoint.start_with?(\"https://\")\n        uri = URI(endpoint)\n      else\n        endpoint = \"rest/api/2/#{endpoint}\" unless endpoint.start_with?(\"rest/api/2/\")\n        uri = URI.join(SiteSetting.discourse_jira_url, endpoint)\n      end\n\n      Net::HTTP.start(uri.host, uri.port, use_ssl: uri.scheme == \"https\") do |http|\n        headers = {\n          \"Content-Type\" => \"application/json\",\n          \"Accept\" => \"application/json\",\n          \"Authorization\" =>\n            \"Basic \" +\n              Base64.strict_encode64(\n                \"#{SiteSetting.discourse_jira_username}:#{SiteSetting.discourse_jira_password}\",\n              ),\n        }\n\n        request = yield(uri, headers)\n        http.request(request)\n      end\n    end\n\n    def self.get(endpoint)\n      make_request(endpoint) { |uri, headers| Net::HTTP::Get.new(uri, headers) }\n    end\n\n    def self.getJSON(endpoint)\n      response = get(endpoint)\n\n      if response.code != \"200\"\n        e = InvalidApiResponse.new(response.body.presence || \"\")\n        e.set_backtrace(caller)\n        Discourse.warn_exception(e, message: INVALID_RESPONSE, env: { endpoint: endpoint })\n        return { error: INVALID_RESPONSE }\n      end\n\n      JSON.parse(response.body, symbolize_names: true)\n    end\n\n    def self.post(endpoint, body)\n      make_request(endpoint) do |uri, headers|\n        request = Net::HTTP::Post.new(uri, headers)\n        request.body = body.to_json\n\n        request\n      end\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire \"rails_helper\"\n\nRSpec.describe ::DiscourseJira::Api do\n  before do\n    SiteSetting.discourse_jira_enabled = true\n    SiteSetting.discourse_jira_url = \"https://jira.example.com\"\n    SiteSetting.discourse_jira_username = \"jira\"\n    SiteSetting.discourse_jira_password = \"password\"\n  end\n\n  describe \".get_version!\" do\n    it \"returns the API version\" do\n      stub_request(:get, \"https://jira.example.com/rest/api/2/serverInfo\").to_return(\n        status: 200,\n        body: {\n          baseUrl: \"https://jira.common.bluescape.com\",\n          version: \"9.4.3\",\n          versionNumbers: [9, 4, 3],\n          deploymentType: \"Server\",\n          buildNumber: 940_003,\n          buildDate: \"2023-02-14T00:00:00.000+0000\",\n          databaseBuildNumber: 940_003,\n          serverTime: \"2023-04-20T09:37:42.687+0000\",\n          scmInfo: \"274jf279485112dfg846632b627916e8cd84833fe47f7e7\",\n          serverTitle: \"Provider\",\n        }.to_json,\n      )\n\n      expect(described_class.get_version!).to eq(9)\n      expect(described_class.createmeta_restricted?).to be_truthy\n      expect(SiteSetting.discourse_jira_api_version).to eq(9)\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire \"rails_helper\"\nrequire \"json\"\nrequire_relative \"../spec_helper\"\n\ndescribe DiscourseJira::IssuesController do\n  let(:admin) { Fabricate(:admin) }\n  let(:issue_response) do\n    '{\"expand\":\"renderedFields,names,schema,operations,editmeta,changelog,versionedRepresentations,customfield_10010.requestTypePractice\",\"id\":\"10041\",\"self\":\"https://example.com/rest/api/2/issue/10041\",\"key\":\"DIS-42\",\"fields\":{\"statuscategorychangedate\":\"2022-04-04T21:15:11.247+0300\",\"issuetype\":{\"self\":\"https://example.com/rest/api/2/issuetype/10001\",\"id\":\"10001\",\"description\":\"Tasks track small, distinct pieces of work.\",\"iconUrl\":\"https://example.com/rest/api/2/universal_avatar/view/type/issuetype/avatar/10318?size=medium\",\"name\":\"Task\",\"subtask\":false,\"avatarId\":10318,\"entityId\":\"3c4b5100-26b0-4392-867c-d9aa0a27975f\",\"hierarchyLevel\":0},\"timespent\":null,\"project\":{\"self\":\"https://example.com/rest/api/2/project/10000\",\"id\":\"10000\",\"key\":\"DIS\",\"name\":\"Discourse\",\"projectTypeKey\":\"software\",\"simplified\":true,\"avatarUrls\":{\"48x48\":\"https://example.com/rest/api/2/universal_avatar/view/type/project/avatar/10400\",\"24x24\":\"https://example.com/rest/api/2/universal_avatar/view/type/project/avatar/10400?size=small\",\"16x16\":\"https://example.com/rest/api/2/universal_avatar/view/type/project/avatar/10400?size=xsmall\",\"32x32\":\"https://example.com/rest/api/2/universal_avatar/view/type/project/avatar/10400?size=medium\"}},\"fixVersions\":[],\"aggregatetimespent\":null,\"resolution\":null,\"resolutiondate\":null,\"workratio\":-1,\"lastViewed\":null,\"watches\":{\"self\":\"https://example.com/rest/api/2/issue/DIS-42/watchers\",\"watchCount\":1,\"isWatching\":true},\"issuerestriction\":{\"issuerestrictions\":{},\"shouldDisplay\":true},\"created\":\"2022-04-04T21:15:10.881+0300\",\"customfield_10020\":null,\"customfield_10021\":null,\"customfield_10022\":null,\"priority\":{\"self\":\"https://example.com/rest/api/2/priority/3\",\"iconUrl\":\"https://example.com/images/icons/priorities/medium.svg\",\"name\":\"Medium\",\"id\":\"3\"},\"customfield_10023\":null,\"customfield_10024\":null,\"customfield_10025\":null,\"labels\":[],\"customfield_10016\":null,\"customfield_10017\":null,\"customfield_10018\":{\"hasEpicLinkFieldDependency\":false,\"showField\":false,\"nonEditableReason\":{\"reason\":\"PLUGIN_LICENSE_ERROR\",\"message\":\"The Parent Link is only available to Jira Premium users.\"}},\"customfield_10019\":\"0|i0000n:\",\"aggregatetimeoriginalestimate\":null,\"timeestimate\":null,\"versions\":[],\"issuelinks\":[],\"assignee\":null,\"updated\":\"2022-04-04T21:15:10.881+0300\",\"status\":{\"self\":\"https://example.com/rest/api/2/status/10000\",\"description\":\"\",\"iconUrl\":\"https://example.com/\",\"name\":\"To Do\",\"id\":\"10000\",\"statusCategory\":{\"self\":\"https://example.com/rest/api/2/statuscategory/2\",\"id\":2,\"key\":\"new\",\"colorName\":\"blue-gray\",\"name\":\"To Do\"}},\"components\":[],\"timeoriginalestimate\":null,\"description\":\"Originally from: http://127.0.0.1:4200/t/welcome-to-the-lounge/8\\n\\n-------------------------\\nPost from: system @ 2022-04-04 16:33:17 UTC\\n\\nCongratulations! :confetti_ball: \\nIf you can see this topic, you were recently promoted to regular (trust level 3). \\nYou can now \u2026 \\n\\nEdit the title of any topic\\nChange the category of any topic\\nHave all your links followed (automatic nofollow is removed)\\nAccess a private Lounge category only visible to users at trust level 3 and higher\\nHide spam with a single flag\\n\\nHere\u2019s the current list of fellow regulars. Be sure to say hi. \\nThanks for being an important part of this community! \\n(For more information on trust levels, see this topic. Please note that only members who continue to meet the requirements over time will remain regulars.)\",\"customfield_10010\":null,\"customfield_10014\":null,\"customfield_10015\":null,\"timetracking\":{},\"customfield_10005\":null,\"customfield_10006\":null,\"customfield_10007\":null,\"security\":null,\"customfield_10008\":null,\"attachment\":[],\"customfield_10009\":null,\"aggregatetimeestimate\":null,\"summary\":\"[Discourse] Welcome to the Lounge\",\"creator\":{\"self\":\"https://example.com/rest/api/2/user?accountId=70121%3A40a02bc7-6a81-4445-9b9e-8d49951a4ebd\",\"accountId\":\"70121:40a02bc7-6a81-4445-9b9e-8d49951a4ebd\",\"emailAddress\":\"foo@example.com\",\"avatarUrls\":{\"48x48\":\"https://secure.gravatar.com/avatar/93ca0545f57bae0ef29f8545a8389d54?d=https%3A%2F%2Favatar-management--avatars.us-west-2.prod.public.atl-paas.net%2Finitials%2FDU-6.png\",\"24x24\":\"https://secure.gravatar.com/avatar/93ca0545f57bae0ef29f8545a8389d54?d=https%3A%2F%2Favatar-management--avatars.us-west-2.prod.public.atl-paas.net%2Finitials%2FDU-6.png\",\"16x16\":\"https://secure.gravatar.com/avatar/93ca0545f57bae0ef29f8545a8389d54?d=https%3A%2F%2Favatar-management--avatars.us-west-2.prod.public.atl-paas.net%2Finitials%2FDU-6.png\",\"32x32\":\"https://secure.gravatar.com/avatar/93ca0545f57bae0ef29f8545a8389d54?d=https%3A%2F%2Favatar-management--avatars.us-west-2.prod.public.atl-paas.net%2Finitials%2FDU-6.png\"},\"displayName\":\"Foo Bar\",\"active\":true,\"timeZone\":\"Europe/Bucharest\",\"accountType\":\"atlassian\"},\"subtasks\":[],\"reporter\":{\"self\":\"https://example.com/rest/api/2/user?accountId=70121%3A40a02bc7-6a81-4445-9b9e-8d49951a4ebd\",\"accountId\":\"70121:40a02bc7-6a81-4445-9b9e-8d49951a4ebd\",\"emailAddress\":\"foo@example.com\",\"avatarUrls\":{\"48x48\":\"https://secure.gravatar.com/avatar/93ca0545f57bae0ef29f8545a8389d54?d=https%3A%2F%2Favatar-management--avatars.us-west-2.prod.public.atl-paas.net%2Finitials%2FDU-6.png\",\"24x24\":\"https://secure.gravatar.com/avatar/93ca0545f57bae0ef29f8545a8389d54?d=https%3A%2F%2Favatar-management--avatars.us-west-2.prod.public.atl-paas.net%2Finitials%2FDU-6.png\",\"16x16\":\"https://secure.gravatar.com/avatar/93ca0545f57bae0ef29f8545a8389d54?d=https%3A%2F%2Favatar-management--avatars.us-west-2.prod.public.atl-paas.net%2Finitials%2FDU-6.png\",\"32x32\":\"https://secure.gravatar.com/avatar/93ca0545f57bae0ef29f8545a8389d54?d=https%3A%2F%2Favatar-management--avatars.us-west-2.prod.public.atl-paas.net%2Finitials%2FDU-6.png\"},\"displayName\":\"Foo Bar\",\"active\":true,\"timeZone\":\"Europe/Bucharest\",\"accountType\":\"atlassian\"},\"aggregateprogress\":{\"progress\":0,\"total\":0},\"customfield_10000\":\"{}\",\"customfield_10001\":null,\"customfield_10002\":null,\"customfield_10003\":null,\"customfield_10004\":null,\"environment\":null,\"duedate\":null,\"progress\":{\"progress\":0,\"total\":0},\"votes\":{\"self\":\"https://example.com/rest/api/2/issue/DIS-42/votes\",\"votes\":0,\"hasVoted\":false},\"comment\":{\"comments\":[],\"self\":\"https://example.com/rest/api/2/issue/10041/comment\",\"maxResults\":0,\"total\":0,\"startAt\":0},\"worklog\":{\"startAt\":0,\"maxResults\":20,\"total\":0,\"worklogs\":[]}}}'\n  end\n\n  before do\n    SiteSetting.discourse_jira_enabled = true\n    SiteSetting.discourse_jira_url = \"https://example.com/\"\n    SiteSetting.discourse_jira_api_version = 8\n  end\n\n  describe \"#preflight\" do\n    it \"should return a list of projects and issue types\" do\n      sign_in(admin)\n\n      project = DiscourseJira::Project.create!(uid: 1, key: \"DIS\", name: \"Discourse\")\n      issue_type_1 = project.issue_types.create!(id: 10_001, uid: 2001, name: \"Task\")\n      issue_type_2 = project.issue_types.create!(id: 10_002, uid: 2002, name: \"Epic\")\n\n      get \"/jira/issues/preflight.json\"\n      expect(response.parsed_body).to eq(\n        {\n          \"email\" => admin.email,\n          \"projects\" => [\n            {\n              \"id\" => project.id,\n              \"name\" => project.name,\n              \"key\" => project.key,\n              \"issue_types\" => [\n                { \"id\" => issue_type_1.id, \"name\" => issue_type_1.name },\n                { \"id\" => issue_type_2.id, \"name\" => issue_type_2.name },\n              ],\n            },\n          ],\n        },\n      )\n    end\n  end\n\n  describe \"#create\" do\n    let(:issue_type) { Fabricate(:jira_issue_type) }\n    let(:project) { Fabricate(:jira_project) }\n\n    it \"requires user to be signed in\" do\n      post \"/jira/issues.json\"\n      expect(response.status).to eq(403)\n    end\n\n    it \"must be enabled\" do\n      SiteSetting.discourse_jira_enabled = false\n      sign_in(admin)\n\n      post \"/jira/issues.json\"\n      expect(response.status).to eq(404)\n    end\n\n    it \"create a Jira issue and \" do\n      sign_in(admin)\n      post = Fabricate(:post)\n\n      stub_request(:post, \"https://example.com/rest/api/2/issue\").with(\n        body:\n          \"{\\\"fields\\\":{\\\"project\\\":{\\\"key\\\":\\\"#{project.key}\\\"},\\\"summary\\\":\\\"[Discourse] \\\",\\\"description\\\":\\\"This is a bug\\\",\\\"issuetype\\\":{\\\"id\\\":#{issue_type.uid}},\\\"software\\\":\\\"value\\\",\\\"platform\\\":{\\\"id\\\":\\\"windows\\\"}}}\",\n      ).to_return(\n        status: 201,\n        body: '{\"id\":\"10041\",\"key\":\"DIS-42\",\"self\":\"https://example.com/rest/api/2/issue/10041\"}',\n        headers: {\n        },\n      )\n\n      stub_request(:get, \"https://example.com/rest/api/2/issue/10041\").to_return(\n        status: 200,\n        body: issue_response,\n      )\n\n      expect do\n        post \"/jira/issues.json\",\n             params: {\n               project_id: project.id,\n               description: \"This is a bug\",\n               issue_type_id: issue_type.id,\n               topic_id: post.topic_id,\n               post_number: post.post_number,\n               fields: {\n                 \"0\": {\n                   key: \"software\",\n                   value: \"value\",\n                 },\n                 \"1\": {\n                   key: \"platform\",\n                   value: \"windows\",\n                   field_type: \"option\",\n                 },\n                 \"2\": {\n                   key: \"customfield_10010\",\n                   field_type: \"array\",\n                   required: \"false\",\n                 },\n               },\n             }\n      end.to change { Post.count }.by(1)\n      expect(response.parsed_body[\"issue_key\"]).to eq(\"DIS-42\")\n      expect(response.parsed_body[\"issue_url\"]).to eq(\"https://example.com/browse/DIS-42\")\n      expect(post.reload.custom_fields[\"jira_issue_key\"]).to eq(\"DIS-42\")\n      expect(Post.last.post_type).to eq(Post.types[:whisper])\n    end\n\n    it \"responds with proper error message\" do\n      sign_in(admin)\n      post = Fabricate(:post)\n\n      stub_request(:post, \"https://example.com/rest/api/2/issue\").to_return(\n        status: 400,\n        body:\n          '{\"errorMessages\":[],\"errors\":{\"versions\":\"Affects Version/s is required.\",\"components\":\"Component/s is required.\"}}',\n        headers: {\n        },\n      )\n\n      post \"/jira/issues.json\",\n           params: {\n             project_id: project.id,\n             description: \"This is a bug\",\n             issue_type_id: issue_type.id,\n             topic_id: post.topic_id,\n             post_number: post.post_number,\n             fields: [],\n           }\n\n      expect(response.parsed_body[\"errors\"][0]).to eq(\n        I18n.t(\n          \"discourse_jira.error_message\",\n          errors: \"Affects Version/s is required. Component/s is required.\",\n        ),\n      )\n    end\n  end\n\n  describe \"#fields\" do\n    fab!(:project) { Fabricate(:jira_project, uid: 2) }\n    fab!(:issue_type) { Fabricate(:jira_issue_type, uid: 7) }\n\n    it \"returns a list of fields for a given issue type\" do\n      sign_in(admin)\n\n      DiscourseJira::ProjectIssueType.create!(project: project, issue_type: issue_type)\n      stub_request(\n        :get,\n        \"https://example.com/rest/api/2/issue/createmeta?expand=projects.issuetypes.fields&issuetypeIds=#{issue_type.uid}&projectIds=#{project.uid}\",\n      ).to_return(\n        status: 200,\n        body: {\n          projects: [\n            {\n              issuetypes: [\n                {\n                  fields: {\n                    software: {\n                      required: true,\n                      schema: {\n                        type: \"string\",\n                      },\n                      name: \"Software\",\n                      operations: [\"set\"],\n                    },\n                    platform: {\n                      required: false,\n                      schema: {\n                        type: \"option\",\n                      },\n                      name: \"Platform\",\n                      allowedValues: [{ id: 5, value: \"Windows\" }, { id: 6, value: \"Mac\" }],\n                      operations: [\"set\"],\n                    },\n                  },\n                },\n              ],\n            },\n          ],\n        }.to_json,\n      )\n\n      get \"/jira/issue/createmeta.json?project_id=#{project.id}&issue_type_id=#{issue_type.id}\"\n      expect(response.parsed_body[\"fields\"]).to eq(\n        [\n          {\n            \"field_type\" => \"string\",\n            \"key\" => \"software\",\n            \"name\" => \"Software\",\n            \"options\" => nil,\n            \"required\" => true,\n          },\n          {\n            \"field_type\" => \"option\",\n            \"key\" => \"platform\",\n            \"name\" => \"Platform\",\n            \"options\" => [{ \"id\" => 5, \"value\" => \"Windows\" }, { \"id\" => 6, \"value\" => \"Mac\" }],\n            \"required\" => false,\n          },\n        ],\n      )\n    end\n  end\n\n  describe \"#attach\" do\n    it \"requires user to be signed in\" do\n      post \"/jira/issues/attach.json\"\n      expect(response.status).to eq(403)\n    end\n\n    it \"must be enabled\" do\n      SiteSetting.discourse_jira_enabled = false\n      sign_in(admin)\n\n      post \"/jira/issues/attach.json\"\n      expect(response.status).to eq(404)\n    end\n\n    it \"attach an existing Jira issue to post\" do\n      sign_in(admin)\n      post = Fabricate(:post)\n\n      stub_request(:get, \"https://example.com/rest/api/2/issue/10041\").to_return(\n        status: 200,\n        body: issue_response,\n      )\n      stub_request(:get, \"https://example.com/rest/api/2/issue/DIS-42\").to_return(\n        status: 200,\n        body: issue_response,\n      )\n\n      expect do\n        post \"/jira/issues/attach.json\",\n             params: {\n               issue_key: \"DIS-42\",\n               topic_id: post.topic_id,\n               post_number: post.post_number,\n             }\n      end.to change { Post.count }.by(1)\n      expect(response.parsed_body[\"issue_key\"]).to eq(\"DIS-42\")\n      expect(response.parsed_body[\"issue_url\"]).to eq(\"https://example.com/browse/DIS-42\")\n      expect(post.reload.custom_fields[\"jira_issue_key\"]).to eq(\"DIS-42\")\n      expect(Post.last.post_type).to eq(Post.types[:whisper])\n    end\n  end\n\n  describe \"#webhook\" do\n    fab!(:topic) { Fabricate(:topic) }\n    fab!(:post2) { Fabricate(:post, topic: topic, post_number: 1) }\n\n    before do\n      post2.jira_issue_key = \"DIS-42\"\n      SiteSetting.discourse_jira_webhook_token = \"secret\"\n    end\n\n    it \"closes the topic when the issue has resolution\" do\n      SiteSetting.discourse_jira_close_topic_on_resolve = true\n      post \"/jira/issues/webhook.json\",\n           params: {\n             t: \"secret\",\n             issue_event_type_name: \"issue_generic\",\n             timestamp: \"1536083559131\",\n             webhookEvent: \"jira:issue_updated\",\n             issue: {\n               id: \"10041\",\n               key: \"DIS-42\",\n               fields: {\n                 resolution: {\n                   name: \"Fixed\",\n                 },\n               },\n             },\n           }\n\n      expect(topic.reload.closed).to eq(true)\n    end\n\n    it \"creates reply to topic when the issue is commented\" do\n      SiteSetting.discourse_jira_sync_issue_comments = true\n\n      expect {\n        post \"/jira/issues/webhook.json\",\n             params: {\n               t: \"secret\",\n               issue_event_type_name: \"issue_commented\",\n               timestamp: \"1536083559131\",\n               webhookEvent: \"jira:issue_updated\",\n               issue: {\n                 id: \"10041\",\n                 key: \"DIS-42\",\n               },\n               comment: {\n                 id: \"10041\",\n                 body: \"This is a comment\",\n               },\n             }\n      }.to change { topic.reload.posts.count }.by(1)\n\n      expect(topic.posts.last.raw).to eq(\"This is a comment\")\n    end\n  end\nend\n"], "fixing_code": ["# frozen_string_literal: true\n\nmodule DiscourseJira\n  class IssuesController < ::ApplicationController\n    requires_plugin DiscourseJira::PLUGIN_NAME\n\n    before_action :ensure_logged_in, except: [:webhook]\n    before_action :ensure_can_create_jira_issue, except: [:webhook]\n    before_action :ensure_can_add_jira_issue_to_post, only: %i[create attach]\n\n    skip_before_action :check_xhr,\n                       :verify_authenticity_token,\n                       :redirect_to_login_if_required,\n                       :preload_json,\n                       only: [:webhook]\n\n    def preflight\n      render json: {\n               projects:\n                 ActiveModel::ArraySerializer.new(\n                   Project.all,\n                   each_serializer: JiraProjectSerializer,\n                 ).as_json,\n               email: current_user.email,\n             }\n    end\n\n    def fields\n      params.require(:project_id)\n      params.require(:issue_type_id)\n\n      fields =\n        ProjectIssueType.find_by(\n          project_id: params[:project_id].to_i,\n          issue_type_id: params[:issue_type_id].to_i,\n        ).fetch_fields\n\n      render json: { fields: fields }\n    end\n\n    def create\n      params.require(:project_id)\n      summary = I18n.t(\"discourse_jira.issue_title\", title: params[:title])\n      issue_type = IssueType.find_by(id: params[:issue_type_id])\n      raise Discourse::NotFound if issue_type.blank?\n\n      fields = {\n        project: {\n          key: project.key,\n        },\n        summary: summary,\n        description: params[:description],\n        issuetype: {\n          id: issue_type.uid,\n        },\n      }\n\n      (params[:fields] || []).each do |_, data|\n        next if data.blank?\n        next if data[:value].blank? && data[:required] != \"true\"\n\n        case data[:field_type]\n        when \"array\"\n          fields[data[:key]] = data[:value].map { |v| { id: v } }\n        when \"option\"\n          fields[data[:key]] = { id: data[:value] }\n        else\n          fields[data[:key]] = data[:value]\n        end\n      end\n      log(fields.inspect)\n\n      hijack(\n        info:\n          \"creating Jira issue for topic #{params[:topic_id]} and post_number #{params[:post_number]}\",\n      ) do\n        response = Api.post(\"issue\", { fields: fields })\n        json =\n          begin\n            JSON.parse(response.body, symbolize_names: true)\n          rescue StandardError\n            {}\n          end\n        log(json.inspect)\n\n        if response.code != \"201\"\n          log(\"Bad Jira response: #{response.body}\")\n          errors = (json[:errors] || {}).values.join(\" \")\n          error_message =\n            (\n              if errors.present?\n                I18n.t(\"discourse_jira.error_message\", errors: errors)\n              else\n                I18n.t(\"discourse_jira.bad_api_response\", status_code: response.code)\n              end\n            )\n          render_json_error(error_message, status: 422)\n          break\n        end\n\n        result =\n          success_json.merge(\n            {\n              issue_key: json[:key],\n              issue_url: URI.join(SiteSetting.discourse_jira_url, \"browse/#{json[:key]}\").to_s,\n            },\n          )\n\n        post.jira_issue_key = result[:issue_key]\n\n        if topic = Topic.find_by(id: params[:topic_id])\n          if current_user.guardian.can_create_post_on_topic?(topic)\n            topic.add_moderator_post(\n              current_user,\n              I18n.t(\"discourse_jira.small_action\", title: summary, url: result[:issue_url]),\n              post_type: Post.types[:whisper],\n              action_code: \"jira_issue\",\n            )\n          end\n        end\n\n        response = Api.get(json[:self])\n        post.custom_fields[\"jira_issue\"] = response.body\n        post.save_custom_fields\n\n        render json: result\n      end\n    end\n\n    def attach\n      raise Discourse::InvalidAccess if !SiteSetting.discourse_jira_enabled\n\n      params.require(:issue_key)\n      issue_key = params[:issue_key]\n      raise Discourse::InvalidParameters.new(:issue_key) if issue_key.include?(\"/\")\n\n      hijack(\n        info:\n          \"attaching Jira issue for topic #{params[:topic_id]} and post_number #{params[:post_number]}\",\n      ) do\n        response = Api.get(\"issue/#{issue_key}\")\n\n        if response.code != \"200\"\n          log(\"Bad Jira response: #{response.body}\")\n          render_json_error(\n            I18n.t(\"discourse_jira.bad_api_response\", status_code: response.code),\n            status: 422,\n          )\n          break\n        end\n\n        json = JSON.parse(response.body, symbolize_names: true)\n\n        result =\n          success_json.merge(\n            {\n              issue_key: issue_key,\n              issue_url: URI.join(SiteSetting.discourse_jira_url, \"browse/#{issue_key}\").to_s,\n            },\n          )\n\n        post.jira_issue_key = issue_key\n\n        if topic = Topic.find_by(id: params[:topic_id])\n          if current_user.guardian.can_create_post_on_topic?(topic)\n            topic.add_moderator_post(\n              current_user,\n              I18n.t(\n                \"discourse_jira.small_action\",\n                title: json[:fields][:summary],\n                url: result[:issue_url],\n              ),\n              post_type: Post.types[:whisper],\n              action_code: \"jira_issue\",\n            )\n          end\n        end\n\n        response = Api.get(json[:self])\n        post.custom_fields[\"jira_issue\"] = response.body\n        post.save_custom_fields\n\n        render json: result\n      end\n    end\n\n    def webhook\n      log(params.inspect)\n\n      if SiteSetting.discourse_jira_webhook_token.present?\n        params.require(:t)\n        if !ActiveSupport::SecurityUtils.secure_compare(\n             params[:t],\n             SiteSetting.discourse_jira_webhook_token,\n           )\n          raise Discourse::InvalidAccess\n        end\n      else\n        Rails.logger.warn(\n          \"discourse_jira_webhook_token is empty. Set a token to ensure malicious requests are not handled.\",\n        )\n      end\n\n      event = params[:webhookEvent]\n      issue_event = params[:issue_event_type_name]\n\n      if event == \"jira:issue_updated\"\n        issue = params[:issue]\n        post =\n          Post.joins(:_custom_fields).find_by(\n            _custom_fields: {\n              name: \"jira_issue_key\",\n              value: issue[:key],\n            },\n          )\n        raise Discourse::NotFound if post.blank?\n\n        post.custom_fields[\"jira_issue\"] = issue.to_json\n        post.save_custom_fields\n\n        if SiteSetting.discourse_jira_close_topic_on_resolve && issue[:fields][:resolution].present?\n          topic = post.topic\n          if post.post_number == 1 && topic&.open?\n            topic.update_status(\"closed\", true, Discourse.system_user)\n          end\n        end\n\n        if SiteSetting.discourse_jira_sync_issue_comments && issue_event == \"issue_commented\" &&\n             post.is_first_post?\n          topic = post.topic\n          comment = params[:comment]\n\n          PostCreator.create!(\n            Discourse.system_user,\n            topic_id: topic.id,\n            raw: comment[:body],\n            skip_validations: true,\n            custom_fields: {\n              \"jira_comment_id\" => comment[:id],\n            },\n          )\n        end\n      end\n\n      render json: success_json\n    end\n\n    private\n\n    def project\n      @project ||= Project.find_by(id: params[:project_id])\n    end\n\n    def ensure_can_create_jira_issue\n      guardian.ensure_can_create_jira_issue!\n    end\n\n    def ensure_can_add_jira_issue_to_post\n      if post.blank?\n        raise Discourse::NotFound\n      elsif post.has_jira_issue?\n        log \"Post #{post.id} already has a Jira issue\"\n        raise Discourse::InvalidAccess\n      end\n    end\n\n    def post\n      params.require(:topic_id)\n      params.require(:post_number)\n      @post ||= Post.find_by(topic_id: params[:topic_id], post_number: params[:post_number])\n    end\n\n    def log(message)\n      Rails.logger.warn(\"Jira verbose log:\\n #{message}\") if SiteSetting.discourse_jira_verbose_log\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nmodule DiscourseJira\n  class InvalidApiResponse < ::StandardError\n  end\n  class InvalidURI < StandardError\n  end\n\n  class Api\n    INVALID_RESPONSE = \"Invalid response from Jira API server\"\n\n    def self.get_version!\n      if SiteSetting.discourse_jira_api_version == 0\n        data = JSON.parse(get(\"serverInfo\").body)\n        SiteSetting.discourse_jira_api_version = data[\"versionNumbers\"][0]\n      end\n\n      SiteSetting.discourse_jira_api_version\n    end\n\n    def self.createmeta_restricted?\n      api_version = get_version!\n      api_version >= 9 && api_version < 1000\n    end\n\n    def self.make_request(endpoint)\n      if endpoint.start_with?(\"https://\")\n        uri = URI(endpoint)\n      else\n        endpoint = \"rest/api/2/#{endpoint}\" unless endpoint.start_with?(\"rest/api/2/\")\n        uri = URI.join(SiteSetting.discourse_jira_url, endpoint)\n      end\n\n      FinalDestination::HTTP.start(uri.host, uri.port, use_ssl: uri.scheme == \"https\") do |http|\n        headers = {\n          \"Content-Type\" => \"application/json\",\n          \"Accept\" => \"application/json\",\n          \"Authorization\" =>\n            \"Basic \" +\n              Base64.strict_encode64(\n                \"#{SiteSetting.discourse_jira_username}:#{SiteSetting.discourse_jira_password}\",\n              ),\n        }\n\n        request = yield(uri, headers)\n        http.request(request)\n      end\n    rescue FinalDestination::SSRFDetector::DisallowedIpError => e\n      Discourse.warn_exception(e, message: \"SSRF detected\", env: { url: uri.to_s })\n      raise InvalidURI\n    rescue SocketError, Timeout::Error\n      raise InvalidURI\n    end\n\n    def self.get(endpoint)\n      make_request(endpoint) { |uri, headers| FinalDestination::HTTP::Get.new(uri, headers) }\n    end\n\n    def self.getJSON(endpoint)\n      response = get(endpoint)\n\n      if response.code != \"200\"\n        e = InvalidApiResponse.new(response.body.presence || \"\")\n        e.set_backtrace(caller)\n        Discourse.warn_exception(e, message: INVALID_RESPONSE, env: { endpoint: endpoint })\n        return { error: INVALID_RESPONSE }\n      end\n\n      JSON.parse(response.body, symbolize_names: true)\n    end\n\n    def self.post(endpoint, body)\n      make_request(endpoint) do |uri, headers|\n        request = FinalDestination::HTTP::Post.new(uri, headers)\n        request.body = body.to_json\n\n        request\n      end\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire \"rails_helper\"\n\nRSpec.describe ::DiscourseJira::Api do\n  before do\n    SiteSetting.discourse_jira_enabled = true\n    SiteSetting.discourse_jira_url = \"https://jira.example.com\"\n    SiteSetting.discourse_jira_username = \"jira\"\n    SiteSetting.discourse_jira_password = \"password\"\n  end\n\n  describe \".get_version!\" do\n    it \"raises error for internal hosts\" do\n      WebMock.enable!(except: [:final_destination])\n      FinalDestination::SSRFDetector.stubs(:lookup_ips).returns([\"192.168.1.1\"])\n      Discourse.expects(:warn_exception).with(\n        instance_of(FinalDestination::SSRFDetector::DisallowedIpError),\n        message: \"SSRF detected\",\n        env: {\n          url: \"https://jira.example.com/rest/api/2/serverInfo\",\n        },\n      )\n      expect { described_class.get_version! }.to raise_error(DiscourseJira::InvalidURI)\n    ensure\n      WebMock.enable!\n    end\n\n    it \"returns the API version\" do\n      FinalDestination::SSRFDetector.stubs(:lookup_ips).returns([\"1.2.3.4\"])\n      stub_request(:get, \"https://jira.example.com/rest/api/2/serverInfo\").to_return(\n        status: 200,\n        body: {\n          baseUrl: \"https://jira.common.bluescape.com\",\n          version: \"9.4.3\",\n          versionNumbers: [9, 4, 3],\n          deploymentType: \"Server\",\n          buildNumber: 940_003,\n          buildDate: \"2023-02-14T00:00:00.000+0000\",\n          databaseBuildNumber: 940_003,\n          serverTime: \"2023-04-20T09:37:42.687+0000\",\n          scmInfo: \"274jf279485112dfg846632b627916e8cd84833fe47f7e7\",\n          serverTitle: \"Provider\",\n        }.to_json,\n      )\n\n      expect(described_class.get_version!).to eq(9)\n      expect(described_class.createmeta_restricted?).to be_truthy\n      expect(SiteSetting.discourse_jira_api_version).to eq(9)\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire \"rails_helper\"\nrequire \"json\"\nrequire_relative \"../spec_helper\"\n\ndescribe DiscourseJira::IssuesController do\n  let(:admin) { Fabricate(:admin) }\n  let(:issue_response) do\n    '{\"expand\":\"renderedFields,names,schema,operations,editmeta,changelog,versionedRepresentations,customfield_10010.requestTypePractice\",\"id\":\"10041\",\"self\":\"https://example.com/rest/api/2/issue/10041\",\"key\":\"DIS-42\",\"fields\":{\"statuscategorychangedate\":\"2022-04-04T21:15:11.247+0300\",\"issuetype\":{\"self\":\"https://example.com/rest/api/2/issuetype/10001\",\"id\":\"10001\",\"description\":\"Tasks track small, distinct pieces of work.\",\"iconUrl\":\"https://example.com/rest/api/2/universal_avatar/view/type/issuetype/avatar/10318?size=medium\",\"name\":\"Task\",\"subtask\":false,\"avatarId\":10318,\"entityId\":\"3c4b5100-26b0-4392-867c-d9aa0a27975f\",\"hierarchyLevel\":0},\"timespent\":null,\"project\":{\"self\":\"https://example.com/rest/api/2/project/10000\",\"id\":\"10000\",\"key\":\"DIS\",\"name\":\"Discourse\",\"projectTypeKey\":\"software\",\"simplified\":true,\"avatarUrls\":{\"48x48\":\"https://example.com/rest/api/2/universal_avatar/view/type/project/avatar/10400\",\"24x24\":\"https://example.com/rest/api/2/universal_avatar/view/type/project/avatar/10400?size=small\",\"16x16\":\"https://example.com/rest/api/2/universal_avatar/view/type/project/avatar/10400?size=xsmall\",\"32x32\":\"https://example.com/rest/api/2/universal_avatar/view/type/project/avatar/10400?size=medium\"}},\"fixVersions\":[],\"aggregatetimespent\":null,\"resolution\":null,\"resolutiondate\":null,\"workratio\":-1,\"lastViewed\":null,\"watches\":{\"self\":\"https://example.com/rest/api/2/issue/DIS-42/watchers\",\"watchCount\":1,\"isWatching\":true},\"issuerestriction\":{\"issuerestrictions\":{},\"shouldDisplay\":true},\"created\":\"2022-04-04T21:15:10.881+0300\",\"customfield_10020\":null,\"customfield_10021\":null,\"customfield_10022\":null,\"priority\":{\"self\":\"https://example.com/rest/api/2/priority/3\",\"iconUrl\":\"https://example.com/images/icons/priorities/medium.svg\",\"name\":\"Medium\",\"id\":\"3\"},\"customfield_10023\":null,\"customfield_10024\":null,\"customfield_10025\":null,\"labels\":[],\"customfield_10016\":null,\"customfield_10017\":null,\"customfield_10018\":{\"hasEpicLinkFieldDependency\":false,\"showField\":false,\"nonEditableReason\":{\"reason\":\"PLUGIN_LICENSE_ERROR\",\"message\":\"The Parent Link is only available to Jira Premium users.\"}},\"customfield_10019\":\"0|i0000n:\",\"aggregatetimeoriginalestimate\":null,\"timeestimate\":null,\"versions\":[],\"issuelinks\":[],\"assignee\":null,\"updated\":\"2022-04-04T21:15:10.881+0300\",\"status\":{\"self\":\"https://example.com/rest/api/2/status/10000\",\"description\":\"\",\"iconUrl\":\"https://example.com/\",\"name\":\"To Do\",\"id\":\"10000\",\"statusCategory\":{\"self\":\"https://example.com/rest/api/2/statuscategory/2\",\"id\":2,\"key\":\"new\",\"colorName\":\"blue-gray\",\"name\":\"To Do\"}},\"components\":[],\"timeoriginalestimate\":null,\"description\":\"Originally from: http://127.0.0.1:4200/t/welcome-to-the-lounge/8\\n\\n-------------------------\\nPost from: system @ 2022-04-04 16:33:17 UTC\\n\\nCongratulations! :confetti_ball: \\nIf you can see this topic, you were recently promoted to regular (trust level 3). \\nYou can now \u2026 \\n\\nEdit the title of any topic\\nChange the category of any topic\\nHave all your links followed (automatic nofollow is removed)\\nAccess a private Lounge category only visible to users at trust level 3 and higher\\nHide spam with a single flag\\n\\nHere\u2019s the current list of fellow regulars. Be sure to say hi. \\nThanks for being an important part of this community! \\n(For more information on trust levels, see this topic. Please note that only members who continue to meet the requirements over time will remain regulars.)\",\"customfield_10010\":null,\"customfield_10014\":null,\"customfield_10015\":null,\"timetracking\":{},\"customfield_10005\":null,\"customfield_10006\":null,\"customfield_10007\":null,\"security\":null,\"customfield_10008\":null,\"attachment\":[],\"customfield_10009\":null,\"aggregatetimeestimate\":null,\"summary\":\"[Discourse] Welcome to the Lounge\",\"creator\":{\"self\":\"https://example.com/rest/api/2/user?accountId=70121%3A40a02bc7-6a81-4445-9b9e-8d49951a4ebd\",\"accountId\":\"70121:40a02bc7-6a81-4445-9b9e-8d49951a4ebd\",\"emailAddress\":\"foo@example.com\",\"avatarUrls\":{\"48x48\":\"https://secure.gravatar.com/avatar/93ca0545f57bae0ef29f8545a8389d54?d=https%3A%2F%2Favatar-management--avatars.us-west-2.prod.public.atl-paas.net%2Finitials%2FDU-6.png\",\"24x24\":\"https://secure.gravatar.com/avatar/93ca0545f57bae0ef29f8545a8389d54?d=https%3A%2F%2Favatar-management--avatars.us-west-2.prod.public.atl-paas.net%2Finitials%2FDU-6.png\",\"16x16\":\"https://secure.gravatar.com/avatar/93ca0545f57bae0ef29f8545a8389d54?d=https%3A%2F%2Favatar-management--avatars.us-west-2.prod.public.atl-paas.net%2Finitials%2FDU-6.png\",\"32x32\":\"https://secure.gravatar.com/avatar/93ca0545f57bae0ef29f8545a8389d54?d=https%3A%2F%2Favatar-management--avatars.us-west-2.prod.public.atl-paas.net%2Finitials%2FDU-6.png\"},\"displayName\":\"Foo Bar\",\"active\":true,\"timeZone\":\"Europe/Bucharest\",\"accountType\":\"atlassian\"},\"subtasks\":[],\"reporter\":{\"self\":\"https://example.com/rest/api/2/user?accountId=70121%3A40a02bc7-6a81-4445-9b9e-8d49951a4ebd\",\"accountId\":\"70121:40a02bc7-6a81-4445-9b9e-8d49951a4ebd\",\"emailAddress\":\"foo@example.com\",\"avatarUrls\":{\"48x48\":\"https://secure.gravatar.com/avatar/93ca0545f57bae0ef29f8545a8389d54?d=https%3A%2F%2Favatar-management--avatars.us-west-2.prod.public.atl-paas.net%2Finitials%2FDU-6.png\",\"24x24\":\"https://secure.gravatar.com/avatar/93ca0545f57bae0ef29f8545a8389d54?d=https%3A%2F%2Favatar-management--avatars.us-west-2.prod.public.atl-paas.net%2Finitials%2FDU-6.png\",\"16x16\":\"https://secure.gravatar.com/avatar/93ca0545f57bae0ef29f8545a8389d54?d=https%3A%2F%2Favatar-management--avatars.us-west-2.prod.public.atl-paas.net%2Finitials%2FDU-6.png\",\"32x32\":\"https://secure.gravatar.com/avatar/93ca0545f57bae0ef29f8545a8389d54?d=https%3A%2F%2Favatar-management--avatars.us-west-2.prod.public.atl-paas.net%2Finitials%2FDU-6.png\"},\"displayName\":\"Foo Bar\",\"active\":true,\"timeZone\":\"Europe/Bucharest\",\"accountType\":\"atlassian\"},\"aggregateprogress\":{\"progress\":0,\"total\":0},\"customfield_10000\":\"{}\",\"customfield_10001\":null,\"customfield_10002\":null,\"customfield_10003\":null,\"customfield_10004\":null,\"environment\":null,\"duedate\":null,\"progress\":{\"progress\":0,\"total\":0},\"votes\":{\"self\":\"https://example.com/rest/api/2/issue/DIS-42/votes\",\"votes\":0,\"hasVoted\":false},\"comment\":{\"comments\":[],\"self\":\"https://example.com/rest/api/2/issue/10041/comment\",\"maxResults\":0,\"total\":0,\"startAt\":0},\"worklog\":{\"startAt\":0,\"maxResults\":20,\"total\":0,\"worklogs\":[]}}}'\n  end\n\n  before do\n    SiteSetting.discourse_jira_enabled = true\n    SiteSetting.discourse_jira_url = \"https://example.com/\"\n    SiteSetting.discourse_jira_api_version = 8\n  end\n\n  describe \"#preflight\" do\n    it \"should return a list of projects and issue types\" do\n      sign_in(admin)\n\n      project = DiscourseJira::Project.create!(uid: 1, key: \"DIS\", name: \"Discourse\")\n      issue_type_1 = project.issue_types.create!(id: 10_001, uid: 2001, name: \"Task\")\n      issue_type_2 = project.issue_types.create!(id: 10_002, uid: 2002, name: \"Epic\")\n\n      get \"/jira/issues/preflight.json\"\n      expect(response.parsed_body).to eq(\n        {\n          \"email\" => admin.email,\n          \"projects\" => [\n            {\n              \"id\" => project.id,\n              \"name\" => project.name,\n              \"key\" => project.key,\n              \"issue_types\" => [\n                { \"id\" => issue_type_1.id, \"name\" => issue_type_1.name },\n                { \"id\" => issue_type_2.id, \"name\" => issue_type_2.name },\n              ],\n            },\n          ],\n        },\n      )\n    end\n  end\n\n  describe \"#create\" do\n    let(:issue_type) { Fabricate(:jira_issue_type) }\n    let(:project) { Fabricate(:jira_project) }\n\n    it \"requires user to be signed in\" do\n      post \"/jira/issues.json\"\n      expect(response.status).to eq(403)\n    end\n\n    it \"must be enabled\" do\n      SiteSetting.discourse_jira_enabled = false\n      sign_in(admin)\n\n      post \"/jira/issues.json\"\n      expect(response.status).to eq(404)\n    end\n\n    it \"create a Jira issue and \" do\n      sign_in(admin)\n      post = Fabricate(:post)\n\n      stub_request(:post, \"https://example.com/rest/api/2/issue\").with(\n        body:\n          \"{\\\"fields\\\":{\\\"project\\\":{\\\"key\\\":\\\"#{project.key}\\\"},\\\"summary\\\":\\\"[Discourse] \\\",\\\"description\\\":\\\"This is a bug\\\",\\\"issuetype\\\":{\\\"id\\\":#{issue_type.uid}},\\\"software\\\":\\\"value\\\",\\\"platform\\\":{\\\"id\\\":\\\"windows\\\"}}}\",\n      ).to_return(\n        status: 201,\n        body: '{\"id\":\"10041\",\"key\":\"DIS-42\",\"self\":\"https://example.com/rest/api/2/issue/10041\"}',\n        headers: {\n        },\n      )\n\n      stub_request(:get, \"https://example.com/rest/api/2/issue/10041\").to_return(\n        status: 200,\n        body: issue_response,\n      )\n\n      expect do\n        post \"/jira/issues.json\",\n             params: {\n               project_id: project.id,\n               description: \"This is a bug\",\n               issue_type_id: issue_type.id,\n               topic_id: post.topic_id,\n               post_number: post.post_number,\n               fields: {\n                 \"0\": {\n                   key: \"software\",\n                   value: \"value\",\n                 },\n                 \"1\": {\n                   key: \"platform\",\n                   value: \"windows\",\n                   field_type: \"option\",\n                 },\n                 \"2\": {\n                   key: \"customfield_10010\",\n                   field_type: \"array\",\n                   required: \"false\",\n                 },\n               },\n             }\n      end.to change { Post.count }.by(1)\n      expect(response.parsed_body[\"issue_key\"]).to eq(\"DIS-42\")\n      expect(response.parsed_body[\"issue_url\"]).to eq(\"https://example.com/browse/DIS-42\")\n      expect(post.reload.custom_fields[\"jira_issue_key\"]).to eq(\"DIS-42\")\n      expect(Post.last.post_type).to eq(Post.types[:whisper])\n    end\n\n    it \"responds with proper error message\" do\n      sign_in(admin)\n      post = Fabricate(:post)\n\n      stub_request(:post, \"https://example.com/rest/api/2/issue\").to_return(\n        status: 400,\n        body:\n          '{\"errorMessages\":[],\"errors\":{\"versions\":\"Affects Version/s is required.\",\"components\":\"Component/s is required.\"}}',\n        headers: {\n        },\n      )\n\n      post \"/jira/issues.json\",\n           params: {\n             project_id: project.id,\n             description: \"This is a bug\",\n             issue_type_id: issue_type.id,\n             topic_id: post.topic_id,\n             post_number: post.post_number,\n             fields: [],\n           }\n\n      expect(response.parsed_body[\"errors\"][0]).to eq(\n        I18n.t(\n          \"discourse_jira.error_message\",\n          errors: \"Affects Version/s is required. Component/s is required.\",\n        ),\n      )\n    end\n  end\n\n  describe \"#fields\" do\n    fab!(:project) { Fabricate(:jira_project, uid: 2) }\n    fab!(:issue_type) { Fabricate(:jira_issue_type, uid: 7) }\n\n    it \"returns a list of fields for a given issue type\" do\n      sign_in(admin)\n\n      DiscourseJira::ProjectIssueType.create!(project: project, issue_type: issue_type)\n      stub_request(\n        :get,\n        \"https://example.com/rest/api/2/issue/createmeta?expand=projects.issuetypes.fields&issuetypeIds=#{issue_type.uid}&projectIds=#{project.uid}\",\n      ).to_return(\n        status: 200,\n        body: {\n          projects: [\n            {\n              issuetypes: [\n                {\n                  fields: {\n                    software: {\n                      required: true,\n                      schema: {\n                        type: \"string\",\n                      },\n                      name: \"Software\",\n                      operations: [\"set\"],\n                    },\n                    platform: {\n                      required: false,\n                      schema: {\n                        type: \"option\",\n                      },\n                      name: \"Platform\",\n                      allowedValues: [{ id: 5, value: \"Windows\" }, { id: 6, value: \"Mac\" }],\n                      operations: [\"set\"],\n                    },\n                  },\n                },\n              ],\n            },\n          ],\n        }.to_json,\n      )\n\n      get \"/jira/issue/createmeta.json?project_id=#{project.id}&issue_type_id=#{issue_type.id}\"\n      expect(response.parsed_body[\"fields\"]).to eq(\n        [\n          {\n            \"field_type\" => \"string\",\n            \"key\" => \"software\",\n            \"name\" => \"Software\",\n            \"options\" => nil,\n            \"required\" => true,\n          },\n          {\n            \"field_type\" => \"option\",\n            \"key\" => \"platform\",\n            \"name\" => \"Platform\",\n            \"options\" => [{ \"id\" => 5, \"value\" => \"Windows\" }, { \"id\" => 6, \"value\" => \"Mac\" }],\n            \"required\" => false,\n          },\n        ],\n      )\n    end\n  end\n\n  describe \"#attach\" do\n    it \"requires user to be signed in\" do\n      post \"/jira/issues/attach.json\"\n      expect(response.status).to eq(403)\n    end\n\n    it \"must be enabled\" do\n      SiteSetting.discourse_jira_enabled = false\n      sign_in(admin)\n\n      post \"/jira/issues/attach.json\"\n      expect(response.status).to eq(404)\n    end\n\n    it \"requires issue key in correct format\" do\n      sign_in(admin)\n      post = Fabricate(:post)\n\n      post \"/jira/issues/attach.json\",\n           params: {\n             issue_key: \"../DIS/42\",\n             topic_id: post.topic_id,\n             post_number: post.post_number,\n           }\n\n      expect(response.status).to eq(400)\n      expect(response.parsed_body[\"errors\"][0]).to eq(\n        I18n.t(\"invalid_params\", message: \"issue_key\"),\n      )\n    end\n\n    it \"attach an existing Jira issue to post\" do\n      sign_in(admin)\n      post = Fabricate(:post)\n\n      stub_request(:get, \"https://example.com/rest/api/2/issue/10041\").to_return(\n        status: 200,\n        body: issue_response,\n      )\n      stub_request(:get, \"https://example.com/rest/api/2/issue/DIS-42\").to_return(\n        status: 200,\n        body: issue_response,\n      )\n\n      expect do\n        post \"/jira/issues/attach.json\",\n             params: {\n               issue_key: \"DIS-42\",\n               topic_id: post.topic_id,\n               post_number: post.post_number,\n             }\n      end.to change { Post.count }.by(1)\n      expect(response.parsed_body[\"issue_key\"]).to eq(\"DIS-42\")\n      expect(response.parsed_body[\"issue_url\"]).to eq(\"https://example.com/browse/DIS-42\")\n      expect(post.reload.custom_fields[\"jira_issue_key\"]).to eq(\"DIS-42\")\n      expect(Post.last.post_type).to eq(Post.types[:whisper])\n    end\n  end\n\n  describe \"#webhook\" do\n    fab!(:topic) { Fabricate(:topic) }\n    fab!(:post2) { Fabricate(:post, topic: topic, post_number: 1) }\n\n    before do\n      post2.jira_issue_key = \"DIS-42\"\n      SiteSetting.discourse_jira_webhook_token = \"secret\"\n    end\n\n    it \"closes the topic when the issue has resolution\" do\n      SiteSetting.discourse_jira_close_topic_on_resolve = true\n      post \"/jira/issues/webhook.json\",\n           params: {\n             t: \"secret\",\n             issue_event_type_name: \"issue_generic\",\n             timestamp: \"1536083559131\",\n             webhookEvent: \"jira:issue_updated\",\n             issue: {\n               id: \"10041\",\n               key: \"DIS-42\",\n               fields: {\n                 resolution: {\n                   name: \"Fixed\",\n                 },\n               },\n             },\n           }\n\n      expect(topic.reload.closed).to eq(true)\n    end\n\n    it \"creates reply to topic when the issue is commented\" do\n      SiteSetting.discourse_jira_sync_issue_comments = true\n\n      expect {\n        post \"/jira/issues/webhook.json\",\n             params: {\n               t: \"secret\",\n               issue_event_type_name: \"issue_commented\",\n               timestamp: \"1536083559131\",\n               webhookEvent: \"jira:issue_updated\",\n               issue: {\n                 id: \"10041\",\n                 key: \"DIS-42\",\n               },\n               comment: {\n                 id: \"10041\",\n                 body: \"This is a comment\",\n               },\n             }\n      }.to change { topic.reload.posts.count }.by(1)\n\n      expect(topic.posts.last.raw).to eq(\"This is a comment\")\n    end\n  end\nend\n"], "filenames": ["app/controllers/discourse_jira/issues_controller.rb", "lib/discourse_jira/api.rb", "spec/lib/api_spec.rb", "spec/requests/issues_controller_spec.rb"], "buggy_code_start_loc": [132, 4, 13, 225], "buggy_code_end_loc": [159, 68, 14, 225], "fixing_code_start_loc": [133, 5, 14, 226], "fixing_code_end_loc": [163, 75, 31, 243], "type": "CWE-918", "message": "Discourse-jira is a Discourse plugin allows Jira projects, issue types, fields and field options will be synced automatically. An administrator user can make an SSRF attack by setting the Jira URL to an arbitrary location and enabling the `discourse_jira_verbose_log` site setting. A moderator user could manipulate the request path to the Jira API, allowing them to perform arbitrary GET requests using the Jira API credentials, potentially with elevated permissions, used by the application. ", "other": {"cve": {"id": "CVE-2023-44384", "sourceIdentifier": "security-advisories@github.com", "published": "2023-10-06T18:15:12.247", "lastModified": "2023-10-11T17:49:49.353", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Discourse-jira is a Discourse plugin allows Jira projects, issue types, fields and field options will be synced automatically. An administrator user can make an SSRF attack by setting the Jira URL to an arbitrary location and enabling the `discourse_jira_verbose_log` site setting. A moderator user could manipulate the request path to the Jira API, allowing them to perform arbitrary GET requests using the Jira API credentials, potentially with elevated permissions, used by the application. "}, {"lang": "es", "value": "Discourse-jira es un complemento de Discourse que permite que los proyectos, tipos de problemas, campos y opciones de campos de Jira se sincronicen autom\u00e1ticamente. Un usuario administrador puede realizar un ataque SSRF configurando la URL de Jira en una ubicaci\u00f3n arbitraria y habilitando la configuraci\u00f3n del sitio `discourse_jira_verbose_log`. Un usuario moderador podr\u00eda manipular la ruta de solicitud a la API de Jira, permiti\u00e9ndole realizar solicitudes GET arbitrarias utilizando las credenciales de la API de Jira, potencialmente con permisos elevados, utilizadas por la aplicaci\u00f3n."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:C/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:C/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 1.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-918"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-691"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse_jira:*:*:*:*:*:discourse:*:*", "versionEndIncluding": "2023-10-01", "matchCriteriaId": "B59C681F-DB07-4BC1-B845-B7276FC47759"}]}]}], "references": [{"url": "https://github.com/discourse/discourse-jira/commit/8a2d3ad228883199fd5f081cc93d173c88e2e48f", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/discourse/discourse-jira/pull/50", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/discourse/discourse-jira/security/advisories/GHSA-pmv5-h2x6-35fh", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/discourse/discourse-jira/commit/8a2d3ad228883199fd5f081cc93d173c88e2e48f"}}