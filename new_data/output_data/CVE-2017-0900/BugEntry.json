{"buggy_code": ["# frozen_string_literal: true\nrequire 'rubygems/command'\nrequire 'rubygems/local_remote_options'\nrequire 'rubygems/spec_fetcher'\nrequire 'rubygems/version_option'\nrequire 'rubygems/text'\n\nclass Gem::Commands::QueryCommand < Gem::Command\n\n  include Gem::Text\n  include Gem::LocalRemoteOptions\n  include Gem::VersionOption\n\n  def initialize(name = 'query',\n                 summary = 'Query gem information in local or remote repositories')\n    super name, summary,\n         :name => //, :domain => :local, :details => false, :versions => true,\n         :installed => nil, :version => Gem::Requirement.default\n\n    add_option('-i', '--[no-]installed',\n               'Check for installed gem') do |value, options|\n      options[:installed] = value\n    end\n\n    add_option('-I', 'Equivalent to --no-installed') do |value, options|\n      options[:installed] = false\n    end\n\n    add_version_option command, \"for use with --installed\"\n\n    add_option('-n', '--name-matches REGEXP',\n               'Name of gem(s) to query on matches the',\n               'provided REGEXP') do |value, options|\n      options[:name] = /#{value}/i\n    end\n\n    add_option('-d', '--[no-]details',\n               'Display detailed information of gem(s)') do |value, options|\n      options[:details] = value\n    end\n\n    add_option(      '--[no-]versions',\n               'Display only gem names') do |value, options|\n      options[:versions] = value\n      options[:details] = false unless value\n    end\n\n    add_option('-a', '--all',\n               'Display all gem versions') do |value, options|\n      options[:all] = value\n    end\n\n    add_option('-e', '--exact',\n               'Name of gem(s) to query on matches the',\n               'provided STRING') do |value, options|\n      options[:exact] = value\n    end\n\n    add_option(      '--[no-]prerelease',\n               'Display prerelease versions') do |value, options|\n      options[:prerelease] = value\n    end\n\n    add_local_remote_options\n  end\n\n  def defaults_str # :nodoc:\n    \"--local --name-matches // --no-details --versions --no-installed\"\n  end\n\n  def description # :nodoc:\n    <<-EOF\nThe query command is the basis for the list and search commands.\n\nYou should really use the list and search commands instead.  This command\nis too hard to use.\n    EOF\n  end\n\n  def execute\n    exit_code = 0\n    if options[:args].to_a.empty? and options[:name].source.empty?\n      name = options[:name]\n      no_name = true\n    elsif !options[:name].source.empty?\n      name = Array(options[:name])\n    else\n      args = options[:args].to_a\n      name = options[:exact] ? args.map{|arg| /\\A#{Regexp.escape(arg)}\\Z/ } : args.map{|arg| /#{arg}/i }\n    end\n\n    prerelease = options[:prerelease]\n\n    unless options[:installed].nil? then\n      if no_name then\n        alert_error \"You must specify a gem name\"\n        exit_code |= 4\n      elsif name.count > 1\n        alert_error \"You must specify only ONE gem!\"\n        exit_code |= 4\n      else\n        installed = installed? name.first, options[:version]\n        installed = !installed unless options[:installed]\n\n        if installed then\n          say \"true\"\n        else\n          say \"false\"\n          exit_code |= 1\n        end\n      end\n\n      terminate_interaction exit_code\n    end\n\n    names = Array(name)\n    names.each { |n| show_gems n, prerelease }\n  end\n\n  private\n\n  def display_header type\n    if (ui.outs.tty? and Gem.configuration.verbose) or both? then\n      say\n      say \"*** #{type} GEMS ***\"\n      say\n    end\n  end\n\n  #Guts of original execute\n  def show_gems name, prerelease\n    req = Gem::Requirement.default\n    # TODO: deprecate for real\n    dep = Gem::Deprecate.skip_during { Gem::Dependency.new name, req }\n    dep.prerelease = prerelease\n\n    if local? then\n      if prerelease and not both? then\n        alert_warning \"prereleases are always shown locally\"\n      end\n\n      display_header 'LOCAL'\n\n      specs = Gem::Specification.find_all { |s|\n        s.name =~ name and req =~ s.version\n      }\n\n      spec_tuples = specs.map do |spec|\n        [spec.name_tuple, spec]\n      end\n\n      output_query_results spec_tuples\n    end\n\n    if remote? then\n      display_header 'REMOTE'\n\n      fetcher = Gem::SpecFetcher.fetcher\n\n      type = if options[:all]\n               if options[:prerelease]\n                 :complete\n               else\n                 :released\n               end\n             elsif options[:prerelease]\n               :prerelease\n             else\n               :latest\n             end\n\n      if name.respond_to?(:source) && name.source.empty?\n        spec_tuples = fetcher.detect(type) { true }\n      else\n        spec_tuples = fetcher.detect(type) do |name_tuple|\n          name === name_tuple.name\n        end\n      end\n\n      output_query_results spec_tuples\n    end\n  end\n\n  ##\n  # Check if gem +name+ version +version+ is installed.\n\n  def installed?(name, req = Gem::Requirement.default)\n    Gem::Specification.any? { |s| s.name =~ name and req =~ s.version }\n  end\n\n  def output_query_results(spec_tuples)\n    output = []\n    versions = Hash.new { |h,name| h[name] = [] }\n\n    spec_tuples.each do |spec_tuple, source|\n      versions[spec_tuple.name] << [spec_tuple, source]\n    end\n\n    versions = versions.sort_by do |(n,_),_|\n      n.downcase\n    end\n\n    output_versions output, versions\n\n    say output.join(options[:details] ? \"\\n\\n\" : \"\\n\")\n  end\n\n  def output_versions output, versions\n    versions.each do |gem_name, matching_tuples|\n      matching_tuples = matching_tuples.sort_by { |n,_| n.version }.reverse\n\n      platforms = Hash.new { |h,version| h[version] = [] }\n\n      matching_tuples.each do |n, _|\n        platforms[n.version] << n.platform if n.platform\n      end\n\n      seen = {}\n\n      matching_tuples.delete_if do |n,_|\n        if seen[n.version] then\n          true\n        else\n          seen[n.version] = true\n          false\n        end\n      end\n\n      output << clean_text(make_entry(matching_tuples, platforms))\n    end\n  end\n\n  def entry_details entry, detail_tuple, specs, platforms\n    return unless options[:details]\n\n    name_tuple, spec = detail_tuple\n\n    spec = spec.fetch_spec name_tuple if spec.respond_to? :fetch_spec\n\n    entry << \"\\n\"\n\n    spec_platforms   entry, platforms\n    spec_authors     entry, spec\n    spec_homepage    entry, spec\n    spec_license     entry, spec\n    spec_loaded_from entry, spec, specs\n    spec_summary     entry, spec\n  end\n\n  def entry_versions entry, name_tuples, platforms, specs\n    return unless options[:versions]\n\n    list =\n      if platforms.empty? or options[:details] then\n        name_tuples.map { |n| n.version }.uniq\n      else\n        platforms.sort.reverse.map do |version, pls|\n          if pls == [Gem::Platform::RUBY] then\n            if options[:domain] == :remote || specs.all? { |spec| spec.is_a? Gem::Source }\n              version\n            else\n              spec = specs.select { |s| s.version == version }\n              if spec.first.default_gem?\n                \"default: #{version}\"\n              else\n                version\n              end\n            end\n          else\n            ruby = pls.delete Gem::Platform::RUBY\n            platform_list = [ruby, *pls.sort].compact\n            \"#{version} #{platform_list.join ' '}\"\n          end\n        end\n      end\n\n    entry << \" (#{list.join ', '})\"\n  end\n\n  def make_entry entry_tuples, platforms\n    detail_tuple = entry_tuples.first\n\n    name_tuples, specs = entry_tuples.flatten.partition do |item|\n      Gem::NameTuple === item\n    end\n\n    entry = [name_tuples.first.name]\n\n    entry_versions entry, name_tuples, platforms, specs\n    entry_details  entry, detail_tuple, specs, platforms\n\n    entry.join\n  end\n\n  def spec_authors entry, spec\n    authors = \"Author#{spec.authors.length > 1 ? 's' : ''}: \".dup\n    authors << spec.authors.join(', ')\n    entry << format_text(authors, 68, 4)\n  end\n\n  def spec_homepage entry, spec\n    return if spec.homepage.nil? or spec.homepage.empty?\n\n    entry << \"\\n\" << format_text(\"Homepage: #{spec.homepage}\", 68, 4)\n  end\n\n  def spec_license entry, spec\n    return if spec.license.nil? or spec.license.empty?\n\n    licenses = \"License#{spec.licenses.length > 1 ? 's' : ''}: \".dup\n    licenses << spec.licenses.join(', ')\n    entry << \"\\n\" << format_text(licenses, 68, 4)\n  end\n\n  def spec_loaded_from entry, spec, specs\n    return unless spec.loaded_from\n\n    if specs.length == 1 then\n      default = spec.default_gem? ? ' (default)' : nil\n      entry << \"\\n\" << \"    Installed at#{default}: #{spec.base_dir}\"\n    else\n      label = 'Installed at'\n      specs.each do |s|\n        version = s.version.to_s\n        version << ', default' if s.default_gem?\n        entry << \"\\n\" << \"    #{label} (#{version}): #{s.base_dir}\"\n        label = ' ' * label.length\n      end\n    end\n  end\n\n  def spec_platforms entry, platforms\n    non_ruby = platforms.any? do |_, pls|\n      pls.any? { |pl| pl != Gem::Platform::RUBY }\n    end\n\n    return unless non_ruby\n\n    if platforms.length == 1 then\n      title = platforms.values.length == 1 ? 'Platform' : 'Platforms'\n      entry << \"    #{title}: #{platforms.values.sort.join ', '}\\n\"\n    else\n      entry << \"    Platforms:\\n\"\n      platforms.sort_by do |version,|\n        version\n      end.each do |version, pls|\n        label = \"        #{version}: \"\n        data = format_text pls.sort.join(', '), 68, label.length\n        data[0, label.length] = label\n        entry << data << \"\\n\"\n      end\n    end\n  end\n\n  def spec_summary entry, spec\n    entry << \"\\n\\n\" << format_text(spec.summary, 68, 4)\n  end\n\nend\n", "# frozen_string_literal: true\nrequire 'rubygems'\n\n##\n# A collection of text-wrangling methods\n\nmodule Gem::Text\n\n  ##\n  # Remove any non-printable characters and make the text suitable for\n  # printing.\n  def clean_text(text)\n    text.gsub(/[\\000-\\b\\v-\\f\\016-\\037\\177]/, \".\".freeze)\n  end\n\n  ##\n  # Wraps +text+ to +wrap+ characters and optionally indents by +indent+\n  # characters\n\n  def format_text(text, wrap, indent=0)\n    result = []\n    work = clean_text(text)\n\n    while work.length > wrap do\n      if work =~ /^(.{0,#{wrap}})[ \\n]/ then\n        result << $1.rstrip\n        work.slice!(0, $&.length)\n      else\n        result << work.slice!(0, wrap)\n      end\n    end\n\n    result << work if work.length.nonzero?\n    result.join(\"\\n\").gsub(/^/, \" \" * indent)\n  end\n\n  def min3 a, b, c # :nodoc:\n    if a < b && a < c then\n      a\n    elsif b < c then\n      b\n    else\n      c\n    end\n  end\n\n  # This code is based directly on the Text gem implementation\n  # Returns a value representing the \"cost\" of transforming str1 into str2\n  def levenshtein_distance str1, str2\n    s = str1\n    t = str2\n    n = s.length\n    m = t.length\n\n    return m if (0 == n)\n    return n if (0 == m)\n\n    d = (0..m).to_a\n    x = nil\n\n    str1.each_char.each_with_index do |char1,i|\n      e = i+1\n\n      str2.each_char.each_with_index do |char2,j|\n        cost = (char1 == char2) ? 0 : 1\n        x = min3(\n             d[j+1] + 1, # insertion\n             e + 1,      # deletion\n             d[j] + cost # substitution\n            )\n        d[j] = e\n        e = x\n      end\n\n      d[m] = x\n    end\n\n    return x\n  end\nend\n", "# frozen_string_literal: true\nrequire 'rubygems/test_case'\nrequire 'rubygems/commands/query_command'\n\nmodule TestGemCommandsQueryCommandSetup\n  def setup\n    super\n\n    @cmd = Gem::Commands::QueryCommand.new\n\n    @specs = add_gems_to_fetcher\n\n    @fetcher.data[\"#{@gem_repo}Marshal.#{Gem.marshal_version}\"] = proc do\n      raise Gem::RemoteFetcher::FetchError\n    end\n  end\nend\n\nclass TestGemCommandsQueryCommandWithInstalledGems < Gem::TestCase\n  include TestGemCommandsQueryCommandSetup\n\n  def test_execute\n    spec_fetcher do |fetcher|\n      fetcher.legacy_platform\n    end\n\n    @cmd.handle_options %w[-r]\n\n    use_ui @ui do\n      @cmd.execute\n    end\n\n    expected = <<-EOF\n\n*** REMOTE GEMS ***\n\na (2)\npl (1 i386-linux)\n    EOF\n\n    assert_equal expected, @ui.output\n    assert_equal '', @ui.error\n  end\n\n  def test_execute_all\n    spec_fetcher do |fetcher|\n      fetcher.legacy_platform\n    end\n\n    @cmd.handle_options %w[-r --all]\n\n    use_ui @ui do\n      @cmd.execute\n    end\n\n    expected = <<-EOF\n\n*** REMOTE GEMS ***\n\na (2, 1)\npl (1 i386-linux)\n    EOF\n\n    assert_equal expected, @ui.output\n    assert_equal '', @ui.error\n  end\n\n  def test_execute_all_prerelease\n    spec_fetcher do |fetcher|\n      fetcher.legacy_platform\n    end\n\n    @cmd.handle_options %w[-r --all --prerelease]\n\n    use_ui @ui do\n      @cmd.execute\n    end\n\n    expected = <<-EOF\n\n*** REMOTE GEMS ***\n\na (3.a, 2, 1)\npl (1 i386-linux)\n    EOF\n\n    assert_equal expected, @ui.output\n    assert_equal '', @ui.error\n  end\n\n  def test_execute_details\n    spec_fetcher do |fetcher|\n      fetcher.spec 'a', 2 do |s|\n        s.summary = 'This is a lot of text. ' * 4\n        s.authors = ['Abraham Lincoln', 'Hirohito']\n        s.homepage = 'http://a.example.com/'\n      end\n\n      fetcher.legacy_platform\n    end\n\n    @cmd.handle_options %w[-r -d]\n\n    use_ui @ui do\n      @cmd.execute\n    end\n\n    expected = <<-EOF\n\n*** REMOTE GEMS ***\n\na (2)\n    Authors: Abraham Lincoln, Hirohito\n    Homepage: http://a.example.com/\n\n    This is a lot of text. This is a lot of text. This is a lot of text.\n    This is a lot of text.\n\npl (1)\n    Platform: i386-linux\n    Author: A User\n    Homepage: http://example.com\n\n    this is a summary\n    EOF\n\n    assert_equal expected, @ui.output\n    assert_equal '', @ui.error\n  end\n\n  def test_execute_details_cleans_text\n    spec_fetcher do |fetcher|\n      fetcher.spec 'a', 2 do |s|\n        s.summary = 'This is a lot of text. ' * 4\n        s.authors = [\"Abraham Lincoln \\x01\", \"\\x02 Hirohito\"]\n        s.homepage = \"http://a.example.com/\\x03\"\n      end\n\n      fetcher.legacy_platform\n    end\n\n    @cmd.handle_options %w[-r -d]\n\n    use_ui @ui do\n      @cmd.execute\n    end\n\n    expected = <<-EOF\n\n*** REMOTE GEMS ***\n\na (2)\n    Authors: Abraham Lincoln ., . Hirohito\n    Homepage: http://a.example.com/.\n\n    This is a lot of text. This is a lot of text. This is a lot of text.\n    This is a lot of text.\n\npl (1)\n    Platform: i386-linux\n    Author: A User\n    Homepage: http://example.com\n\n    this is a summary\n    EOF\n\n    assert_equal expected, @ui.output\n    assert_equal '', @ui.error\n  end\n\n  def test_execute_installed\n    @cmd.handle_options %w[-n a --installed]\n\n    assert_raises Gem::MockGemUi::SystemExitException do\n      use_ui @ui do\n        @cmd.execute\n      end\n    end\n\n    assert_equal \"true\\n\", @ui.output\n    assert_equal '', @ui.error\n  end\n\n  def test_execute_installed_inverse\n    @cmd.handle_options %w[-n a --no-installed]\n\n    e = assert_raises Gem::MockGemUi::TermError do\n      use_ui @ui do\n        @cmd.execute\n      end\n    end\n\n    assert_equal \"false\\n\", @ui.output\n    assert_equal '', @ui.error\n\n    assert_equal 1, e.exit_code\n  end\n\n  def test_execute_installed_inverse_not_installed\n    @cmd.handle_options %w[-n not_installed --no-installed]\n\n    assert_raises Gem::MockGemUi::SystemExitException do\n      use_ui @ui do\n        @cmd.execute\n      end\n    end\n\n    assert_equal \"true\\n\", @ui.output\n    assert_equal '', @ui.error\n  end\n\n  def test_execute_installed_no_name\n    @cmd.handle_options %w[--installed]\n\n    e = assert_raises Gem::MockGemUi::TermError do\n      use_ui @ui do\n        @cmd.execute\n      end\n    end\n\n    assert_equal '', @ui.output\n    assert_equal \"ERROR:  You must specify a gem name\\n\", @ui.error\n\n    assert_equal 4, e.exit_code\n  end\n\n  def test_execute_installed_not_installed\n    @cmd.handle_options %w[-n not_installed --installed]\n\n    e = assert_raises Gem::MockGemUi::TermError do\n      use_ui @ui do\n        @cmd.execute\n      end\n    end\n\n    assert_equal \"false\\n\", @ui.output\n    assert_equal '', @ui.error\n\n    assert_equal 1, e.exit_code\n  end\n\n  def test_execute_installed_version\n    @cmd.handle_options %w[-n a --installed --version 2]\n\n    assert_raises Gem::MockGemUi::SystemExitException do\n      use_ui @ui do\n        @cmd.execute\n      end\n    end\n\n    assert_equal \"true\\n\", @ui.output\n    assert_equal '', @ui.error\n  end\n\n  def test_execute_installed_version_not_installed\n    @cmd.handle_options %w[-n c --installed --version 2]\n\n    e = assert_raises Gem::MockGemUi::TermError do\n      use_ui @ui do\n        @cmd.execute\n      end\n    end\n\n    assert_equal \"false\\n\", @ui.output\n    assert_equal '', @ui.error\n\n    assert_equal 1, e.exit_code\n  end\n\n  def test_execute_local\n    spec_fetcher do |fetcher|\n      fetcher.legacy_platform\n    end\n\n    @cmd.options[:domain] = :local\n\n    use_ui @ui do\n      @cmd.execute\n    end\n\n    expected = <<-EOF\n\n*** LOCAL GEMS ***\n\na (3.a, 2, 1)\npl (1 i386-linux)\n    EOF\n\n    assert_equal expected, @ui.output\n    assert_equal '', @ui.error\n  end\n\n  def test_execute_local_notty\n    spec_fetcher do |fetcher|\n      fetcher.legacy_platform\n    end\n\n    @cmd.handle_options %w[]\n\n    @ui.outs.tty = false\n\n    use_ui @ui do\n      @cmd.execute\n    end\n\n    expected = <<-EOF\na (3.a, 2, 1)\npl (1 i386-linux)\n    EOF\n\n    assert_equal expected, @ui.output\n    assert_equal '', @ui.error\n  end\n\n  def test_execute_local_quiet\n    spec_fetcher do |fetcher|\n      fetcher.legacy_platform\n    end\n\n    @cmd.options[:domain] = :local\n    Gem.configuration.verbose = false\n\n    use_ui @ui do\n      @cmd.execute\n    end\n\n    expected = <<-EOF\na (3.a, 2, 1)\npl (1 i386-linux)\n    EOF\n\n    assert_equal expected, @ui.output\n    assert_equal '', @ui.error\n  end\n\n  def test_execute_no_versions\n    spec_fetcher do |fetcher|\n      fetcher.legacy_platform\n    end\n\n    @cmd.handle_options %w[-r --no-versions]\n\n    use_ui @ui do\n      @cmd.execute\n    end\n\n    expected = <<-EOF\n\n*** REMOTE GEMS ***\n\na\npl\n    EOF\n\n    assert_equal expected, @ui.output\n    assert_equal '', @ui.error\n  end\n\n  def test_execute_notty\n    spec_fetcher do |fetcher|\n      fetcher.legacy_platform\n    end\n\n    @cmd.handle_options %w[-r]\n\n    @ui.outs.tty = false\n\n    use_ui @ui do\n      @cmd.execute\n    end\n\n    expected = <<-EOF\na (2)\npl (1 i386-linux)\n    EOF\n\n    assert_equal expected, @ui.output\n    assert_equal '', @ui.error\n  end\n\n  def test_execute_prerelease\n    @cmd.handle_options %w[-r --prerelease]\n\n    use_ui @ui do\n      @cmd.execute\n    end\n\n    expected = <<-EOF\n\n*** REMOTE GEMS ***\n\na (3.a)\n    EOF\n\n    assert_equal expected, @ui.output\n    assert_equal '', @ui.error\n  end\n\n  def test_execute_prerelease_local\n    spec_fetcher do |fetcher|\n      fetcher.legacy_platform\n    end\n\n    @cmd.handle_options %w[-l --prerelease]\n\n    use_ui @ui do\n      @cmd.execute\n    end\n\n    expected = <<-EOF\n\n*** LOCAL GEMS ***\n\na (3.a, 2, 1)\npl (1 i386-linux)\n    EOF\n\n    assert_equal expected, @ui.output\n    assert_equal \"WARNING:  prereleases are always shown locally\\n\", @ui.error\n  end\n\n  def test_execute_remote\n    spec_fetcher do |fetcher|\n      fetcher.legacy_platform\n    end\n\n    @cmd.options[:domain] = :remote\n\n    use_ui @ui do\n      @cmd.execute\n    end\n\n    expected = <<-EOF\n\n*** REMOTE GEMS ***\n\na (2)\npl (1 i386-linux)\n    EOF\n\n    assert_equal expected, @ui.output\n    assert_equal '', @ui.error\n  end\n\n  def test_execute_remote_notty\n    spec_fetcher do |fetcher|\n      fetcher.legacy_platform\n    end\n\n    @cmd.handle_options %w[]\n\n    @ui.outs.tty = false\n\n    use_ui @ui do\n      @cmd.execute\n    end\n\n    expected = <<-EOF\na (3.a, 2, 1)\npl (1 i386-linux)\n    EOF\n\n    assert_equal expected, @ui.output\n    assert_equal '', @ui.error\n  end\n\n  def test_execute_remote_quiet\n    spec_fetcher do |fetcher|\n      fetcher.legacy_platform\n    end\n\n    @cmd.options[:domain] = :remote\n    Gem.configuration.verbose = false\n\n    use_ui @ui do\n      @cmd.execute\n    end\n\n    expected = <<-EOF\na (2)\npl (1 i386-linux)\n    EOF\n\n    assert_equal expected, @ui.output\n    assert_equal '', @ui.error\n  end\n\n  def test_make_entry\n    a_2_name = @specs['a-2'].original_name\n\n    @fetcher.data.delete \\\n      \"#{@gem_repo}quick/Marshal.#{Gem.marshal_version}/#{a_2_name}.gemspec.rz\"\n\n    a2 = @specs['a-2']\n    entry_tuples = [\n      [Gem::NameTuple.new(a2.name, a2.version, a2.platform),\n       Gem.sources.first],\n    ]\n\n    platforms = { a2.version => [a2.platform] }\n\n    entry = @cmd.send :make_entry, entry_tuples, platforms\n\n    assert_equal 'a (2)', entry\n  end\n\n  # Test for multiple args handling!\n  def test_execute_multiple_args\n    spec_fetcher do |fetcher|\n      fetcher.legacy_platform\n    end\n\n    @cmd.handle_options %w[a pl]\n\n    use_ui @ui do\n      @cmd.execute\n    end\n\n    assert_match %r%^a %, @ui.output\n    assert_match %r%^pl %, @ui.output\n    assert_equal '', @ui.error\n  end\n\n  def test_show_gems\n    @cmd.options[:name] = //\n    @cmd.options[:domain] = :remote\n\n    use_ui @ui do\n      @cmd.send :show_gems, /a/i, false\n    end\n\n    assert_match %r%^a %,  @ui.output\n    refute_match %r%^pl %, @ui.output\n    assert_empty @ui.error\n  end\n\n  private\n\n  def add_gems_to_fetcher\n    spec_fetcher do |fetcher|\n      fetcher.spec 'a', 1\n      fetcher.spec 'a', 2\n      fetcher.spec 'a', '3.a'\n    end\n  end\nend\n\nclass TestGemCommandsQueryCommandWithoutInstalledGems < Gem::TestCase\n  include TestGemCommandsQueryCommandSetup\n\n  def test_execute_platform\n    spec_fetcher do |fetcher|\n      fetcher.spec 'a', 1\n      fetcher.spec 'a', 1 do |s|\n        s.platform = 'x86-linux'\n      end\n\n      fetcher.spec 'a', 2 do |s|\n        s.platform = 'universal-darwin'\n      end\n    end\n\n    @cmd.handle_options %w[-r -a]\n\n    use_ui @ui do\n      @cmd.execute\n    end\n\n    expected = <<-EOF\n\n*** REMOTE GEMS ***\n\na (2 universal-darwin, 1 ruby x86-linux)\n    EOF\n\n    assert_equal expected, @ui.output\n    assert_equal '', @ui.error\n  end\n\n  def test_execute_show_default_gems\n    spec_fetcher { |fetcher| fetcher.spec 'a', 2 }\n\n    a1 = new_default_spec 'a', 1\n    install_default_specs a1\n\n    use_ui @ui do\n      @cmd.execute\n    end\n\n    expected = <<-EOF\n\n*** LOCAL GEMS ***\n\na (2, default: 1)\nEOF\n\n    assert_equal expected, @ui.output\n  end\n\n  def test_execute_default_details\n    spec_fetcher do |fetcher|\n      fetcher.spec 'a', 2\n    end\n\n    a1 = new_default_spec 'a', 1\n    install_default_specs a1\n\n    @cmd.handle_options %w[-l -d]\n\n    use_ui @ui do\n      @cmd.execute\n    end\n\n    expected = <<-EOF\n\n*** LOCAL GEMS ***\n\na (2, 1)\n    Author: A User\n    Homepage: http://example.com\n    Installed at (2): #{@gemhome}\n                 (1, default): #{a1.base_dir}\n\n    this is a summary\n    EOF\n\n    assert_equal expected, @ui.output\n  end\n\n  def test_execute_local_details\n    spec_fetcher do |fetcher|\n      fetcher.spec 'a', 1 do |s|\n        s.platform = 'x86-linux'\n      end\n\n      fetcher.spec 'a', 2 do |s|\n        s.summary = 'This is a lot of text. ' * 4\n        s.authors = ['Abraham Lincoln', 'Hirohito']\n        s.homepage = 'http://a.example.com/'\n        s.platform = 'universal-darwin'\n      end\n\n      fetcher.legacy_platform\n    end\n\n    @cmd.handle_options %w[-l -d]\n\n    use_ui @ui do\n      @cmd.execute\n    end\n\n    str = @ui.output\n\n    str.gsub!(/\\(\\d\\): [^\\n]*/, \"-\")\n    str.gsub!(/at: [^\\n]*/, \"at: -\")\n\n    expected = <<-EOF\n\n*** LOCAL GEMS ***\n\na (2, 1)\n    Platforms:\n        1: x86-linux\n        2: universal-darwin\n    Authors: Abraham Lincoln, Hirohito\n    Homepage: http://a.example.com/\n    Installed at -\n                 -\n\n    This is a lot of text. This is a lot of text. This is a lot of text.\n    This is a lot of text.\n\npl (1)\n    Platform: i386-linux\n    Author: A User\n    Homepage: http://example.com\n    Installed at: -\n\n    this is a summary\n    EOF\n\n    assert_equal expected, @ui.output\n  end\n\n  def test_execute_exact_remote\n    spec_fetcher do |fetcher|\n      fetcher.spec 'coolgem-omg', 3\n      fetcher.spec 'coolgem', '4.2.1'\n      fetcher.spec 'wow_coolgem', 1\n    end\n\n    @cmd.handle_options %w[--remote --exact coolgem]\n\n    use_ui @ui do\n      @cmd.execute\n    end\n\n    expected = <<-EOF\n\n*** REMOTE GEMS ***\n\ncoolgem (4.2.1)\n    EOF\n\n    assert_equal expected, @ui.output\n  end\n\n  def test_execute_exact_local\n    spec_fetcher do |fetcher|\n      fetcher.spec 'coolgem-omg', 3\n      fetcher.spec 'coolgem', '4.2.1'\n      fetcher.spec 'wow_coolgem', 1\n    end\n\n    @cmd.handle_options %w[--exact coolgem]\n\n    use_ui @ui do\n      @cmd.execute\n    end\n\n    expected = <<-EOF\n\n*** LOCAL GEMS ***\n\ncoolgem (4.2.1)\n    EOF\n\n    assert_equal expected, @ui.output\n  end\n\n  def test_execute_exact_multiple\n    spec_fetcher do |fetcher|\n      fetcher.spec 'coolgem-omg', 3\n      fetcher.spec 'coolgem', '4.2.1'\n      fetcher.spec 'wow_coolgem', 1\n\n      fetcher.spec 'othergem-omg', 3\n      fetcher.spec 'othergem', '1.2.3'\n      fetcher.spec 'wow_othergem', 1\n    end\n\n    @cmd.handle_options %w[--exact coolgem othergem]\n\n    use_ui @ui do\n      @cmd.execute\n    end\n\n    expected = <<-EOF\n\n*** LOCAL GEMS ***\n\ncoolgem (4.2.1)\n\n*** LOCAL GEMS ***\n\nothergem (1.2.3)\n    EOF\n\n    assert_equal expected, @ui.output\n  end\n\n  private\n\n  def add_gems_to_fetcher\n    spec_fetcher do |fetcher|\n      fetcher.download 'a', 1\n      fetcher.download 'a', 2\n      fetcher.download 'a', '3.a'\n    end\n  end\nend\n", "# frozen_string_literal: true\nrequire 'rubygems/test_case'\nrequire \"rubygems/text\"\n\nclass TestGemText < Gem::TestCase\n  include Gem::Text\n\n  def test_format_text\n    assert_equal \"text to\\nwrap\",     format_text(\"text to wrap\", 8)\n  end\n\n  def test_format_text_indent\n    assert_equal \"  text to\\n  wrap\", format_text(\"text to wrap\", 8, 2)\n  end\n\n  def test_format_text_none\n    assert_equal \"text to wrap\",      format_text(\"text to wrap\", 40)\n  end\n\n  def test_format_text_none_indent\n    assert_equal \"  text to wrap\",    format_text(\"text to wrap\", 40, 2)\n  end\n\n  def test_format_text_trailing # for two spaces after .\n    text = <<-TEXT\nThis line is really, really long.  So long, in fact, that it is more than eighty characters long!  The purpose of this line is for testing wrapping behavior because sometimes people don't wrap their text to eighty characters.  Without the wrapping, the text might not look good in the RSS feed.\n    TEXT\n\n    expected = <<-EXPECTED\nThis line is really, really long.  So long, in fact, that it is more than\neighty characters long!  The purpose of this line is for testing wrapping\nbehavior because sometimes people don't wrap their text to eighty characters.\nWithout the wrapping, the text might not look good in the RSS feed.\n    EXPECTED\n\n    assert_equal expected, format_text(text, 78)\n  end\n\n  def test_format_removes_nonprintable_characters\n    assert_equal \"text with weird .. stuff .\", format_text(\"text with weird \\x1b\\x02 stuff \\x7f\", 40)\n  end\n\n  def test_min3\n    assert_equal 1, min3(1, 1, 1)\n    assert_equal 1, min3(1, 1, 2)\n    assert_equal 1, min3(1, 2, 1)\n    assert_equal 1, min3(2, 1, 1)\n    assert_equal 1, min3(1, 2, 2)\n    assert_equal 1, min3(2, 1, 2)\n    assert_equal 1, min3(2, 2, 1)\n    assert_equal 1, min3(1, 2, 3)\n    assert_equal 1, min3(1, 3, 2)\n    assert_equal 1, min3(2, 1, 3)\n    assert_equal 1, min3(2, 3, 1)\n    assert_equal 1, min3(3, 1, 2)\n    assert_equal 1, min3(3, 2, 1)\n  end\n\n  def test_levenshtein_distance_add\n    assert_equal 2, levenshtein_distance(\"zentest\", \"zntst\")\n    assert_equal 2, levenshtein_distance(\"zntst\", \"zentest\")\n  end\n\n  def test_levenshtein_distance_empty\n    assert_equal 5, levenshtein_distance(\"abcde\", \"\")\n    assert_equal 5, levenshtein_distance(\"\", \"abcde\")\n  end\n\n  def test_levenshtein_distance_remove\n    assert_equal 3, levenshtein_distance(\"zentest\", \"zentestxxx\")\n    assert_equal 3, levenshtein_distance(\"zentestxxx\", \"zentest\")\n    assert_equal 13, levenshtein_distance(\"cat\", \"thundercatsarego\")\n    assert_equal 13, levenshtein_distance(\"thundercatsarego\", \"cat\")\n  end\n\n  def test_levenshtein_distance_replace\n    assert_equal 2, levenshtein_distance(\"zentest\", \"ZenTest\")\n    assert_equal 7, levenshtein_distance(\"xxxxxxx\", \"ZenTest\")\n    assert_equal 7, levenshtein_distance(\"zentest\", \"xxxxxxx\")\n  end\nend\n"], "fixing_code": ["# frozen_string_literal: true\nrequire 'rubygems/command'\nrequire 'rubygems/local_remote_options'\nrequire 'rubygems/spec_fetcher'\nrequire 'rubygems/version_option'\nrequire 'rubygems/text'\n\nclass Gem::Commands::QueryCommand < Gem::Command\n\n  include Gem::Text\n  include Gem::LocalRemoteOptions\n  include Gem::VersionOption\n\n  def initialize(name = 'query',\n                 summary = 'Query gem information in local or remote repositories')\n    super name, summary,\n         :name => //, :domain => :local, :details => false, :versions => true,\n         :installed => nil, :version => Gem::Requirement.default\n\n    add_option('-i', '--[no-]installed',\n               'Check for installed gem') do |value, options|\n      options[:installed] = value\n    end\n\n    add_option('-I', 'Equivalent to --no-installed') do |value, options|\n      options[:installed] = false\n    end\n\n    add_version_option command, \"for use with --installed\"\n\n    add_option('-n', '--name-matches REGEXP',\n               'Name of gem(s) to query on matches the',\n               'provided REGEXP') do |value, options|\n      options[:name] = /#{value}/i\n    end\n\n    add_option('-d', '--[no-]details',\n               'Display detailed information of gem(s)') do |value, options|\n      options[:details] = value\n    end\n\n    add_option(      '--[no-]versions',\n               'Display only gem names') do |value, options|\n      options[:versions] = value\n      options[:details] = false unless value\n    end\n\n    add_option('-a', '--all',\n               'Display all gem versions') do |value, options|\n      options[:all] = value\n    end\n\n    add_option('-e', '--exact',\n               'Name of gem(s) to query on matches the',\n               'provided STRING') do |value, options|\n      options[:exact] = value\n    end\n\n    add_option(      '--[no-]prerelease',\n               'Display prerelease versions') do |value, options|\n      options[:prerelease] = value\n    end\n\n    add_local_remote_options\n  end\n\n  def defaults_str # :nodoc:\n    \"--local --name-matches // --no-details --versions --no-installed\"\n  end\n\n  def description # :nodoc:\n    <<-EOF\nThe query command is the basis for the list and search commands.\n\nYou should really use the list and search commands instead.  This command\nis too hard to use.\n    EOF\n  end\n\n  def execute\n    exit_code = 0\n    if options[:args].to_a.empty? and options[:name].source.empty?\n      name = options[:name]\n      no_name = true\n    elsif !options[:name].source.empty?\n      name = Array(options[:name])\n    else\n      args = options[:args].to_a\n      name = options[:exact] ? args.map{|arg| /\\A#{Regexp.escape(arg)}\\Z/ } : args.map{|arg| /#{arg}/i }\n    end\n\n    prerelease = options[:prerelease]\n\n    unless options[:installed].nil? then\n      if no_name then\n        alert_error \"You must specify a gem name\"\n        exit_code |= 4\n      elsif name.count > 1\n        alert_error \"You must specify only ONE gem!\"\n        exit_code |= 4\n      else\n        installed = installed? name.first, options[:version]\n        installed = !installed unless options[:installed]\n\n        if installed then\n          say \"true\"\n        else\n          say \"false\"\n          exit_code |= 1\n        end\n      end\n\n      terminate_interaction exit_code\n    end\n\n    names = Array(name)\n    names.each { |n| show_gems n, prerelease }\n  end\n\n  private\n\n  def display_header type\n    if (ui.outs.tty? and Gem.configuration.verbose) or both? then\n      say\n      say \"*** #{type} GEMS ***\"\n      say\n    end\n  end\n\n  #Guts of original execute\n  def show_gems name, prerelease\n    req = Gem::Requirement.default\n    # TODO: deprecate for real\n    dep = Gem::Deprecate.skip_during { Gem::Dependency.new name, req }\n    dep.prerelease = prerelease\n\n    if local? then\n      if prerelease and not both? then\n        alert_warning \"prereleases are always shown locally\"\n      end\n\n      display_header 'LOCAL'\n\n      specs = Gem::Specification.find_all { |s|\n        s.name =~ name and req =~ s.version\n      }\n\n      spec_tuples = specs.map do |spec|\n        [spec.name_tuple, spec]\n      end\n\n      output_query_results spec_tuples\n    end\n\n    if remote? then\n      display_header 'REMOTE'\n\n      fetcher = Gem::SpecFetcher.fetcher\n\n      type = if options[:all]\n               if options[:prerelease]\n                 :complete\n               else\n                 :released\n               end\n             elsif options[:prerelease]\n               :prerelease\n             else\n               :latest\n             end\n\n      if name.respond_to?(:source) && name.source.empty?\n        spec_tuples = fetcher.detect(type) { true }\n      else\n        spec_tuples = fetcher.detect(type) do |name_tuple|\n          name === name_tuple.name\n        end\n      end\n\n      output_query_results spec_tuples\n    end\n  end\n\n  ##\n  # Check if gem +name+ version +version+ is installed.\n\n  def installed?(name, req = Gem::Requirement.default)\n    Gem::Specification.any? { |s| s.name =~ name and req =~ s.version }\n  end\n\n  def output_query_results(spec_tuples)\n    output = []\n    versions = Hash.new { |h,name| h[name] = [] }\n\n    spec_tuples.each do |spec_tuple, source|\n      versions[spec_tuple.name] << [spec_tuple, source]\n    end\n\n    versions = versions.sort_by do |(n,_),_|\n      n.downcase\n    end\n\n    output_versions output, versions\n\n    say output.join(options[:details] ? \"\\n\\n\" : \"\\n\")\n  end\n\n  def output_versions output, versions\n    versions.each do |gem_name, matching_tuples|\n      matching_tuples = matching_tuples.sort_by { |n,_| n.version }.reverse\n\n      platforms = Hash.new { |h,version| h[version] = [] }\n\n      matching_tuples.each do |n, _|\n        platforms[n.version] << n.platform if n.platform\n      end\n\n      seen = {}\n\n      matching_tuples.delete_if do |n,_|\n        if seen[n.version] then\n          true\n        else\n          seen[n.version] = true\n          false\n        end\n      end\n\n      output << clean_text(make_entry(matching_tuples, platforms))\n    end\n  end\n\n  def entry_details entry, detail_tuple, specs, platforms\n    return unless options[:details]\n\n    name_tuple, spec = detail_tuple\n\n    spec = spec.fetch_spec name_tuple if spec.respond_to? :fetch_spec\n\n    entry << \"\\n\"\n\n    spec_platforms   entry, platforms\n    spec_authors     entry, spec\n    spec_homepage    entry, spec\n    spec_license     entry, spec\n    spec_loaded_from entry, spec, specs\n    spec_summary     entry, spec\n  end\n\n  def entry_versions entry, name_tuples, platforms, specs\n    return unless options[:versions]\n\n    list =\n      if platforms.empty? or options[:details] then\n        name_tuples.map { |n| n.version }.uniq\n      else\n        platforms.sort.reverse.map do |version, pls|\n          if pls == [Gem::Platform::RUBY] then\n            if options[:domain] == :remote || specs.all? { |spec| spec.is_a? Gem::Source }\n              version\n            else\n              spec = specs.select { |s| s.version == version }\n              if spec.first.default_gem?\n                \"default: #{version}\"\n              else\n                version\n              end\n            end\n          else\n            ruby = pls.delete Gem::Platform::RUBY\n            platform_list = [ruby, *pls.sort].compact\n            \"#{version} #{platform_list.join ' '}\"\n          end\n        end\n      end\n\n    entry << \" (#{list.join ', '})\"\n  end\n\n  def make_entry entry_tuples, platforms\n    detail_tuple = entry_tuples.first\n\n    name_tuples, specs = entry_tuples.flatten.partition do |item|\n      Gem::NameTuple === item\n    end\n\n    entry = [name_tuples.first.name]\n\n    entry_versions entry, name_tuples, platforms, specs\n    entry_details  entry, detail_tuple, specs, platforms\n\n    entry.join\n  end\n\n  def spec_authors entry, spec\n    authors = \"Author#{spec.authors.length > 1 ? 's' : ''}: \".dup\n    authors << spec.authors.join(', ')\n    entry << format_text(authors, 68, 4)\n  end\n\n  def spec_homepage entry, spec\n    return if spec.homepage.nil? or spec.homepage.empty?\n\n    entry << \"\\n\" << format_text(\"Homepage: #{spec.homepage}\", 68, 4)\n  end\n\n  def spec_license entry, spec\n    return if spec.license.nil? or spec.license.empty?\n\n    licenses = \"License#{spec.licenses.length > 1 ? 's' : ''}: \".dup\n    licenses << spec.licenses.join(', ')\n    entry << \"\\n\" << format_text(licenses, 68, 4)\n  end\n\n  def spec_loaded_from entry, spec, specs\n    return unless spec.loaded_from\n\n    if specs.length == 1 then\n      default = spec.default_gem? ? ' (default)' : nil\n      entry << \"\\n\" << \"    Installed at#{default}: #{spec.base_dir}\"\n    else\n      label = 'Installed at'\n      specs.each do |s|\n        version = s.version.to_s\n        version << ', default' if s.default_gem?\n        entry << \"\\n\" << \"    #{label} (#{version}): #{s.base_dir}\"\n        label = ' ' * label.length\n      end\n    end\n  end\n\n  def spec_platforms entry, platforms\n    non_ruby = platforms.any? do |_, pls|\n      pls.any? { |pl| pl != Gem::Platform::RUBY }\n    end\n\n    return unless non_ruby\n\n    if platforms.length == 1 then\n      title = platforms.values.length == 1 ? 'Platform' : 'Platforms'\n      entry << \"    #{title}: #{platforms.values.sort.join ', '}\\n\"\n    else\n      entry << \"    Platforms:\\n\"\n      platforms.sort_by do |version,|\n        version\n      end.each do |version, pls|\n        label = \"        #{version}: \"\n        data = format_text pls.sort.join(', '), 68, label.length\n        data[0, label.length] = label\n        entry << data << \"\\n\"\n      end\n    end\n  end\n\n  def spec_summary entry, spec\n    summary = truncate_text(spec.summary, \"the summary for #{spec.full_name}\")\n    entry << \"\\n\\n\" << format_text(summary, 68, 4)\n  end\n\nend\n", "# frozen_string_literal: true\nrequire 'rubygems'\n\n##\n# A collection of text-wrangling methods\n\nmodule Gem::Text\n\n  ##\n  # Remove any non-printable characters and make the text suitable for\n  # printing.\n  def clean_text(text)\n    text.gsub(/[\\000-\\b\\v-\\f\\016-\\037\\177]/, \".\".freeze)\n  end\n\n  def truncate_text(text, description, max_length = 100_000)\n    raise ArgumentError, \"max_length must be positive\" unless max_length > 0\n    return text if text.size <= max_length\n    \"Truncating #{description} to #{max_length.to_s.reverse.gsub(/...(?=.)/,'\\&,').reverse} characters:\\n\" + text[0, max_length]\n  end\n\n  ##\n  # Wraps +text+ to +wrap+ characters and optionally indents by +indent+\n  # characters\n\n  def format_text(text, wrap, indent=0)\n    result = []\n    work = clean_text(text)\n\n    while work.length > wrap do\n      if work =~ /^(.{0,#{wrap}})[ \\n]/ then\n        result << $1.rstrip\n        work.slice!(0, $&.length)\n      else\n        result << work.slice!(0, wrap)\n      end\n    end\n\n    result << work if work.length.nonzero?\n    result.join(\"\\n\").gsub(/^/, \" \" * indent)\n  end\n\n  def min3 a, b, c # :nodoc:\n    if a < b && a < c then\n      a\n    elsif b < c then\n      b\n    else\n      c\n    end\n  end\n\n  # This code is based directly on the Text gem implementation\n  # Returns a value representing the \"cost\" of transforming str1 into str2\n  def levenshtein_distance str1, str2\n    s = str1\n    t = str2\n    n = s.length\n    m = t.length\n\n    return m if (0 == n)\n    return n if (0 == m)\n\n    d = (0..m).to_a\n    x = nil\n\n    str1.each_char.each_with_index do |char1,i|\n      e = i+1\n\n      str2.each_char.each_with_index do |char2,j|\n        cost = (char1 == char2) ? 0 : 1\n        x = min3(\n             d[j+1] + 1, # insertion\n             e + 1,      # deletion\n             d[j] + cost # substitution\n            )\n        d[j] = e\n        e = x\n      end\n\n      d[m] = x\n    end\n\n    return x\n  end\nend\n", "# frozen_string_literal: true\nrequire 'rubygems/test_case'\nrequire 'rubygems/commands/query_command'\n\nmodule TestGemCommandsQueryCommandSetup\n  def setup\n    super\n\n    @cmd = Gem::Commands::QueryCommand.new\n\n    @specs = add_gems_to_fetcher\n\n    @fetcher.data[\"#{@gem_repo}Marshal.#{Gem.marshal_version}\"] = proc do\n      raise Gem::RemoteFetcher::FetchError\n    end\n  end\nend\n\nclass TestGemCommandsQueryCommandWithInstalledGems < Gem::TestCase\n  include TestGemCommandsQueryCommandSetup\n\n  def test_execute\n    spec_fetcher do |fetcher|\n      fetcher.legacy_platform\n    end\n\n    @cmd.handle_options %w[-r]\n\n    use_ui @ui do\n      @cmd.execute\n    end\n\n    expected = <<-EOF\n\n*** REMOTE GEMS ***\n\na (2)\npl (1 i386-linux)\n    EOF\n\n    assert_equal expected, @ui.output\n    assert_equal '', @ui.error\n  end\n\n  def test_execute_all\n    spec_fetcher do |fetcher|\n      fetcher.legacy_platform\n    end\n\n    @cmd.handle_options %w[-r --all]\n\n    use_ui @ui do\n      @cmd.execute\n    end\n\n    expected = <<-EOF\n\n*** REMOTE GEMS ***\n\na (2, 1)\npl (1 i386-linux)\n    EOF\n\n    assert_equal expected, @ui.output\n    assert_equal '', @ui.error\n  end\n\n  def test_execute_all_prerelease\n    spec_fetcher do |fetcher|\n      fetcher.legacy_platform\n    end\n\n    @cmd.handle_options %w[-r --all --prerelease]\n\n    use_ui @ui do\n      @cmd.execute\n    end\n\n    expected = <<-EOF\n\n*** REMOTE GEMS ***\n\na (3.a, 2, 1)\npl (1 i386-linux)\n    EOF\n\n    assert_equal expected, @ui.output\n    assert_equal '', @ui.error\n  end\n\n  def test_execute_details\n    spec_fetcher do |fetcher|\n      fetcher.spec 'a', 2 do |s|\n        s.summary = 'This is a lot of text. ' * 4\n        s.authors = ['Abraham Lincoln', 'Hirohito']\n        s.homepage = 'http://a.example.com/'\n      end\n\n      fetcher.legacy_platform\n    end\n\n    @cmd.handle_options %w[-r -d]\n\n    use_ui @ui do\n      @cmd.execute\n    end\n\n    expected = <<-EOF\n\n*** REMOTE GEMS ***\n\na (2)\n    Authors: Abraham Lincoln, Hirohito\n    Homepage: http://a.example.com/\n\n    This is a lot of text. This is a lot of text. This is a lot of text.\n    This is a lot of text.\n\npl (1)\n    Platform: i386-linux\n    Author: A User\n    Homepage: http://example.com\n\n    this is a summary\n    EOF\n\n    assert_equal expected, @ui.output\n    assert_equal '', @ui.error\n  end\n\n  def test_execute_details_cleans_text\n    spec_fetcher do |fetcher|\n      fetcher.spec 'a', 2 do |s|\n        s.summary = 'This is a lot of text. ' * 4\n        s.authors = [\"Abraham Lincoln \\x01\", \"\\x02 Hirohito\"]\n        s.homepage = \"http://a.example.com/\\x03\"\n      end\n\n      fetcher.legacy_platform\n    end\n\n    @cmd.handle_options %w[-r -d]\n\n    use_ui @ui do\n      @cmd.execute\n    end\n\n    expected = <<-EOF\n\n*** REMOTE GEMS ***\n\na (2)\n    Authors: Abraham Lincoln ., . Hirohito\n    Homepage: http://a.example.com/.\n\n    This is a lot of text. This is a lot of text. This is a lot of text.\n    This is a lot of text.\n\npl (1)\n    Platform: i386-linux\n    Author: A User\n    Homepage: http://example.com\n\n    this is a summary\n    EOF\n\n    assert_equal expected, @ui.output\n    assert_equal '', @ui.error\n  end\n\n  def test_execute_details_truncates_summary\n    spec_fetcher do |fetcher|\n      fetcher.spec 'a', 2 do |s|\n        s.summary = 'This is a lot of text. ' * 10_000\n        s.authors = [\"Abraham Lincoln \\x01\", \"\\x02 Hirohito\"]\n        s.homepage = \"http://a.example.com/\\x03\"\n      end\n\n      fetcher.legacy_platform\n    end\n\n    @cmd.handle_options %w[-r -d]\n\n    use_ui @ui do\n      @cmd.execute\n    end\n\n    expected = <<-EOF\n\n*** REMOTE GEMS ***\n\na (2)\n    Authors: Abraham Lincoln ., . Hirohito\n    Homepage: http://a.example.com/.\n\n    Truncating the summary for a-2 to 100,000 characters:\n#{\"    This is a lot of text. This is a lot of text. This is a lot of text.\\n\" * 1449}    This is a lot of te\n\npl (1)\n    Platform: i386-linux\n    Author: A User\n    Homepage: http://example.com\n\n    this is a summary\n    EOF\n\n    assert_equal expected, @ui.output\n    assert_equal '', @ui.error\n  end\n\n  def test_execute_installed\n    @cmd.handle_options %w[-n a --installed]\n\n    assert_raises Gem::MockGemUi::SystemExitException do\n      use_ui @ui do\n        @cmd.execute\n      end\n    end\n\n    assert_equal \"true\\n\", @ui.output\n    assert_equal '', @ui.error\n  end\n\n  def test_execute_installed_inverse\n    @cmd.handle_options %w[-n a --no-installed]\n\n    e = assert_raises Gem::MockGemUi::TermError do\n      use_ui @ui do\n        @cmd.execute\n      end\n    end\n\n    assert_equal \"false\\n\", @ui.output\n    assert_equal '', @ui.error\n\n    assert_equal 1, e.exit_code\n  end\n\n  def test_execute_installed_inverse_not_installed\n    @cmd.handle_options %w[-n not_installed --no-installed]\n\n    assert_raises Gem::MockGemUi::SystemExitException do\n      use_ui @ui do\n        @cmd.execute\n      end\n    end\n\n    assert_equal \"true\\n\", @ui.output\n    assert_equal '', @ui.error\n  end\n\n  def test_execute_installed_no_name\n    @cmd.handle_options %w[--installed]\n\n    e = assert_raises Gem::MockGemUi::TermError do\n      use_ui @ui do\n        @cmd.execute\n      end\n    end\n\n    assert_equal '', @ui.output\n    assert_equal \"ERROR:  You must specify a gem name\\n\", @ui.error\n\n    assert_equal 4, e.exit_code\n  end\n\n  def test_execute_installed_not_installed\n    @cmd.handle_options %w[-n not_installed --installed]\n\n    e = assert_raises Gem::MockGemUi::TermError do\n      use_ui @ui do\n        @cmd.execute\n      end\n    end\n\n    assert_equal \"false\\n\", @ui.output\n    assert_equal '', @ui.error\n\n    assert_equal 1, e.exit_code\n  end\n\n  def test_execute_installed_version\n    @cmd.handle_options %w[-n a --installed --version 2]\n\n    assert_raises Gem::MockGemUi::SystemExitException do\n      use_ui @ui do\n        @cmd.execute\n      end\n    end\n\n    assert_equal \"true\\n\", @ui.output\n    assert_equal '', @ui.error\n  end\n\n  def test_execute_installed_version_not_installed\n    @cmd.handle_options %w[-n c --installed --version 2]\n\n    e = assert_raises Gem::MockGemUi::TermError do\n      use_ui @ui do\n        @cmd.execute\n      end\n    end\n\n    assert_equal \"false\\n\", @ui.output\n    assert_equal '', @ui.error\n\n    assert_equal 1, e.exit_code\n  end\n\n  def test_execute_local\n    spec_fetcher do |fetcher|\n      fetcher.legacy_platform\n    end\n\n    @cmd.options[:domain] = :local\n\n    use_ui @ui do\n      @cmd.execute\n    end\n\n    expected = <<-EOF\n\n*** LOCAL GEMS ***\n\na (3.a, 2, 1)\npl (1 i386-linux)\n    EOF\n\n    assert_equal expected, @ui.output\n    assert_equal '', @ui.error\n  end\n\n  def test_execute_local_notty\n    spec_fetcher do |fetcher|\n      fetcher.legacy_platform\n    end\n\n    @cmd.handle_options %w[]\n\n    @ui.outs.tty = false\n\n    use_ui @ui do\n      @cmd.execute\n    end\n\n    expected = <<-EOF\na (3.a, 2, 1)\npl (1 i386-linux)\n    EOF\n\n    assert_equal expected, @ui.output\n    assert_equal '', @ui.error\n  end\n\n  def test_execute_local_quiet\n    spec_fetcher do |fetcher|\n      fetcher.legacy_platform\n    end\n\n    @cmd.options[:domain] = :local\n    Gem.configuration.verbose = false\n\n    use_ui @ui do\n      @cmd.execute\n    end\n\n    expected = <<-EOF\na (3.a, 2, 1)\npl (1 i386-linux)\n    EOF\n\n    assert_equal expected, @ui.output\n    assert_equal '', @ui.error\n  end\n\n  def test_execute_no_versions\n    spec_fetcher do |fetcher|\n      fetcher.legacy_platform\n    end\n\n    @cmd.handle_options %w[-r --no-versions]\n\n    use_ui @ui do\n      @cmd.execute\n    end\n\n    expected = <<-EOF\n\n*** REMOTE GEMS ***\n\na\npl\n    EOF\n\n    assert_equal expected, @ui.output\n    assert_equal '', @ui.error\n  end\n\n  def test_execute_notty\n    spec_fetcher do |fetcher|\n      fetcher.legacy_platform\n    end\n\n    @cmd.handle_options %w[-r]\n\n    @ui.outs.tty = false\n\n    use_ui @ui do\n      @cmd.execute\n    end\n\n    expected = <<-EOF\na (2)\npl (1 i386-linux)\n    EOF\n\n    assert_equal expected, @ui.output\n    assert_equal '', @ui.error\n  end\n\n  def test_execute_prerelease\n    @cmd.handle_options %w[-r --prerelease]\n\n    use_ui @ui do\n      @cmd.execute\n    end\n\n    expected = <<-EOF\n\n*** REMOTE GEMS ***\n\na (3.a)\n    EOF\n\n    assert_equal expected, @ui.output\n    assert_equal '', @ui.error\n  end\n\n  def test_execute_prerelease_local\n    spec_fetcher do |fetcher|\n      fetcher.legacy_platform\n    end\n\n    @cmd.handle_options %w[-l --prerelease]\n\n    use_ui @ui do\n      @cmd.execute\n    end\n\n    expected = <<-EOF\n\n*** LOCAL GEMS ***\n\na (3.a, 2, 1)\npl (1 i386-linux)\n    EOF\n\n    assert_equal expected, @ui.output\n    assert_equal \"WARNING:  prereleases are always shown locally\\n\", @ui.error\n  end\n\n  def test_execute_remote\n    spec_fetcher do |fetcher|\n      fetcher.legacy_platform\n    end\n\n    @cmd.options[:domain] = :remote\n\n    use_ui @ui do\n      @cmd.execute\n    end\n\n    expected = <<-EOF\n\n*** REMOTE GEMS ***\n\na (2)\npl (1 i386-linux)\n    EOF\n\n    assert_equal expected, @ui.output\n    assert_equal '', @ui.error\n  end\n\n  def test_execute_remote_notty\n    spec_fetcher do |fetcher|\n      fetcher.legacy_platform\n    end\n\n    @cmd.handle_options %w[]\n\n    @ui.outs.tty = false\n\n    use_ui @ui do\n      @cmd.execute\n    end\n\n    expected = <<-EOF\na (3.a, 2, 1)\npl (1 i386-linux)\n    EOF\n\n    assert_equal expected, @ui.output\n    assert_equal '', @ui.error\n  end\n\n  def test_execute_remote_quiet\n    spec_fetcher do |fetcher|\n      fetcher.legacy_platform\n    end\n\n    @cmd.options[:domain] = :remote\n    Gem.configuration.verbose = false\n\n    use_ui @ui do\n      @cmd.execute\n    end\n\n    expected = <<-EOF\na (2)\npl (1 i386-linux)\n    EOF\n\n    assert_equal expected, @ui.output\n    assert_equal '', @ui.error\n  end\n\n  def test_make_entry\n    a_2_name = @specs['a-2'].original_name\n\n    @fetcher.data.delete \\\n      \"#{@gem_repo}quick/Marshal.#{Gem.marshal_version}/#{a_2_name}.gemspec.rz\"\n\n    a2 = @specs['a-2']\n    entry_tuples = [\n      [Gem::NameTuple.new(a2.name, a2.version, a2.platform),\n       Gem.sources.first],\n    ]\n\n    platforms = { a2.version => [a2.platform] }\n\n    entry = @cmd.send :make_entry, entry_tuples, platforms\n\n    assert_equal 'a (2)', entry\n  end\n\n  # Test for multiple args handling!\n  def test_execute_multiple_args\n    spec_fetcher do |fetcher|\n      fetcher.legacy_platform\n    end\n\n    @cmd.handle_options %w[a pl]\n\n    use_ui @ui do\n      @cmd.execute\n    end\n\n    assert_match %r%^a %, @ui.output\n    assert_match %r%^pl %, @ui.output\n    assert_equal '', @ui.error\n  end\n\n  def test_show_gems\n    @cmd.options[:name] = //\n    @cmd.options[:domain] = :remote\n\n    use_ui @ui do\n      @cmd.send :show_gems, /a/i, false\n    end\n\n    assert_match %r%^a %,  @ui.output\n    refute_match %r%^pl %, @ui.output\n    assert_empty @ui.error\n  end\n\n  private\n\n  def add_gems_to_fetcher\n    spec_fetcher do |fetcher|\n      fetcher.spec 'a', 1\n      fetcher.spec 'a', 2\n      fetcher.spec 'a', '3.a'\n    end\n  end\nend\n\nclass TestGemCommandsQueryCommandWithoutInstalledGems < Gem::TestCase\n  include TestGemCommandsQueryCommandSetup\n\n  def test_execute_platform\n    spec_fetcher do |fetcher|\n      fetcher.spec 'a', 1\n      fetcher.spec 'a', 1 do |s|\n        s.platform = 'x86-linux'\n      end\n\n      fetcher.spec 'a', 2 do |s|\n        s.platform = 'universal-darwin'\n      end\n    end\n\n    @cmd.handle_options %w[-r -a]\n\n    use_ui @ui do\n      @cmd.execute\n    end\n\n    expected = <<-EOF\n\n*** REMOTE GEMS ***\n\na (2 universal-darwin, 1 ruby x86-linux)\n    EOF\n\n    assert_equal expected, @ui.output\n    assert_equal '', @ui.error\n  end\n\n  def test_execute_show_default_gems\n    spec_fetcher { |fetcher| fetcher.spec 'a', 2 }\n\n    a1 = new_default_spec 'a', 1\n    install_default_specs a1\n\n    use_ui @ui do\n      @cmd.execute\n    end\n\n    expected = <<-EOF\n\n*** LOCAL GEMS ***\n\na (2, default: 1)\nEOF\n\n    assert_equal expected, @ui.output\n  end\n\n  def test_execute_default_details\n    spec_fetcher do |fetcher|\n      fetcher.spec 'a', 2\n    end\n\n    a1 = new_default_spec 'a', 1\n    install_default_specs a1\n\n    @cmd.handle_options %w[-l -d]\n\n    use_ui @ui do\n      @cmd.execute\n    end\n\n    expected = <<-EOF\n\n*** LOCAL GEMS ***\n\na (2, 1)\n    Author: A User\n    Homepage: http://example.com\n    Installed at (2): #{@gemhome}\n                 (1, default): #{a1.base_dir}\n\n    this is a summary\n    EOF\n\n    assert_equal expected, @ui.output\n  end\n\n  def test_execute_local_details\n    spec_fetcher do |fetcher|\n      fetcher.spec 'a', 1 do |s|\n        s.platform = 'x86-linux'\n      end\n\n      fetcher.spec 'a', 2 do |s|\n        s.summary = 'This is a lot of text. ' * 4\n        s.authors = ['Abraham Lincoln', 'Hirohito']\n        s.homepage = 'http://a.example.com/'\n        s.platform = 'universal-darwin'\n      end\n\n      fetcher.legacy_platform\n    end\n\n    @cmd.handle_options %w[-l -d]\n\n    use_ui @ui do\n      @cmd.execute\n    end\n\n    str = @ui.output\n\n    str.gsub!(/\\(\\d\\): [^\\n]*/, \"-\")\n    str.gsub!(/at: [^\\n]*/, \"at: -\")\n\n    expected = <<-EOF\n\n*** LOCAL GEMS ***\n\na (2, 1)\n    Platforms:\n        1: x86-linux\n        2: universal-darwin\n    Authors: Abraham Lincoln, Hirohito\n    Homepage: http://a.example.com/\n    Installed at -\n                 -\n\n    This is a lot of text. This is a lot of text. This is a lot of text.\n    This is a lot of text.\n\npl (1)\n    Platform: i386-linux\n    Author: A User\n    Homepage: http://example.com\n    Installed at: -\n\n    this is a summary\n    EOF\n\n    assert_equal expected, @ui.output\n  end\n\n  def test_execute_exact_remote\n    spec_fetcher do |fetcher|\n      fetcher.spec 'coolgem-omg', 3\n      fetcher.spec 'coolgem', '4.2.1'\n      fetcher.spec 'wow_coolgem', 1\n    end\n\n    @cmd.handle_options %w[--remote --exact coolgem]\n\n    use_ui @ui do\n      @cmd.execute\n    end\n\n    expected = <<-EOF\n\n*** REMOTE GEMS ***\n\ncoolgem (4.2.1)\n    EOF\n\n    assert_equal expected, @ui.output\n  end\n\n  def test_execute_exact_local\n    spec_fetcher do |fetcher|\n      fetcher.spec 'coolgem-omg', 3\n      fetcher.spec 'coolgem', '4.2.1'\n      fetcher.spec 'wow_coolgem', 1\n    end\n\n    @cmd.handle_options %w[--exact coolgem]\n\n    use_ui @ui do\n      @cmd.execute\n    end\n\n    expected = <<-EOF\n\n*** LOCAL GEMS ***\n\ncoolgem (4.2.1)\n    EOF\n\n    assert_equal expected, @ui.output\n  end\n\n  def test_execute_exact_multiple\n    spec_fetcher do |fetcher|\n      fetcher.spec 'coolgem-omg', 3\n      fetcher.spec 'coolgem', '4.2.1'\n      fetcher.spec 'wow_coolgem', 1\n\n      fetcher.spec 'othergem-omg', 3\n      fetcher.spec 'othergem', '1.2.3'\n      fetcher.spec 'wow_othergem', 1\n    end\n\n    @cmd.handle_options %w[--exact coolgem othergem]\n\n    use_ui @ui do\n      @cmd.execute\n    end\n\n    expected = <<-EOF\n\n*** LOCAL GEMS ***\n\ncoolgem (4.2.1)\n\n*** LOCAL GEMS ***\n\nothergem (1.2.3)\n    EOF\n\n    assert_equal expected, @ui.output\n  end\n\n  private\n\n  def add_gems_to_fetcher\n    spec_fetcher do |fetcher|\n      fetcher.download 'a', 1\n      fetcher.download 'a', 2\n      fetcher.download 'a', '3.a'\n    end\n  end\nend\n", "# frozen_string_literal: true\nrequire 'rubygems/test_case'\nrequire \"rubygems/text\"\n\nclass TestGemText < Gem::TestCase\n  include Gem::Text\n\n  def test_format_text\n    assert_equal \"text to\\nwrap\",     format_text(\"text to wrap\", 8)\n  end\n\n  def test_format_text_indent\n    assert_equal \"  text to\\n  wrap\", format_text(\"text to wrap\", 8, 2)\n  end\n\n  def test_format_text_none\n    assert_equal \"text to wrap\",      format_text(\"text to wrap\", 40)\n  end\n\n  def test_format_text_none_indent\n    assert_equal \"  text to wrap\",    format_text(\"text to wrap\", 40, 2)\n  end\n\n  def test_format_text_trailing # for two spaces after .\n    text = <<-TEXT\nThis line is really, really long.  So long, in fact, that it is more than eighty characters long!  The purpose of this line is for testing wrapping behavior because sometimes people don't wrap their text to eighty characters.  Without the wrapping, the text might not look good in the RSS feed.\n    TEXT\n\n    expected = <<-EXPECTED\nThis line is really, really long.  So long, in fact, that it is more than\neighty characters long!  The purpose of this line is for testing wrapping\nbehavior because sometimes people don't wrap their text to eighty characters.\nWithout the wrapping, the text might not look good in the RSS feed.\n    EXPECTED\n\n    assert_equal expected, format_text(text, 78)\n  end\n\n  def test_format_removes_nonprintable_characters\n    assert_equal \"text with weird .. stuff .\", format_text(\"text with weird \\x1b\\x02 stuff \\x7f\", 40)\n  end\n\n  def test_min3\n    assert_equal 1, min3(1, 1, 1)\n    assert_equal 1, min3(1, 1, 2)\n    assert_equal 1, min3(1, 2, 1)\n    assert_equal 1, min3(2, 1, 1)\n    assert_equal 1, min3(1, 2, 2)\n    assert_equal 1, min3(2, 1, 2)\n    assert_equal 1, min3(2, 2, 1)\n    assert_equal 1, min3(1, 2, 3)\n    assert_equal 1, min3(1, 3, 2)\n    assert_equal 1, min3(2, 1, 3)\n    assert_equal 1, min3(2, 3, 1)\n    assert_equal 1, min3(3, 1, 2)\n    assert_equal 1, min3(3, 2, 1)\n  end\n\n  def test_levenshtein_distance_add\n    assert_equal 2, levenshtein_distance(\"zentest\", \"zntst\")\n    assert_equal 2, levenshtein_distance(\"zntst\", \"zentest\")\n  end\n\n  def test_levenshtein_distance_empty\n    assert_equal 5, levenshtein_distance(\"abcde\", \"\")\n    assert_equal 5, levenshtein_distance(\"\", \"abcde\")\n  end\n\n  def test_levenshtein_distance_remove\n    assert_equal 3, levenshtein_distance(\"zentest\", \"zentestxxx\")\n    assert_equal 3, levenshtein_distance(\"zentestxxx\", \"zentest\")\n    assert_equal 13, levenshtein_distance(\"cat\", \"thundercatsarego\")\n    assert_equal 13, levenshtein_distance(\"thundercatsarego\", \"cat\")\n  end\n\n  def test_levenshtein_distance_replace\n    assert_equal 2, levenshtein_distance(\"zentest\", \"ZenTest\")\n    assert_equal 7, levenshtein_distance(\"xxxxxxx\", \"ZenTest\")\n    assert_equal 7, levenshtein_distance(\"zentest\", \"xxxxxxx\")\n  end\n\n  def test_truncate_text\n    assert_equal \"abc\", truncate_text(\"abc\", \"desc\")\n    assert_equal \"Truncating desc to 2 characters:\\nab\", truncate_text(\"abc\", \"desc\", 2)\n    s = \"ab\" * 500_001\n    assert_equal \"Truncating desc to 1,000,000 characters:\\n#{s[0, 1_000_000]}\", truncate_text(s, \"desc\", 1_000_000)\n  end\nend\n"], "filenames": ["lib/rubygems/commands/query_command.rb", "lib/rubygems/text.rb", "test/rubygems/test_gem_commands_query_command.rb", "test/rubygems/test_gem_text.rb"], "buggy_code_start_loc": [356, 13, 157, 80], "buggy_code_end_loc": [357, 13, 157, 80], "fixing_code_start_loc": [356, 14, 158, 81], "fixing_code_end_loc": [358, 20, 198, 88], "type": "CWE-20", "message": "RubyGems version 2.6.12 and earlier is vulnerable to maliciously crafted gem specifications to cause a denial of service attack against RubyGems clients who have issued a `query` command.", "other": {"cve": {"id": "CVE-2017-0900", "sourceIdentifier": "support@hackerone.com", "published": "2017-08-31T20:29:00.510", "lastModified": "2019-05-13T14:31:40.837", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "RubyGems version 2.6.12 and earlier is vulnerable to maliciously crafted gem specifications to cause a denial of service attack against RubyGems clients who have issued a `query` command."}, {"lang": "es", "value": "RubyGems 2.6.12 y anteriores es vulnerable a especificaciones de gemas manipuladas maliciosamente para provocar ataques de denegaci\u00f3n de servicio contra clientes RubyGems que hayan enviado un comando query."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:rubygems:rubygems:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.6.12", "matchCriteriaId": "1161B0D8-43B3-4123-BD4F-87F260AB8947"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_desktop:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "33C068A4-3780-4EAB-A937-6082DF847564"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "51EF4996-72F4-4FA4-814F-F5991E7A8318"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.4:*:*:*:*:*:*:*", "matchCriteriaId": "D99A687E-EAE6-417E-A88E-D0082BC194CD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "B353CE99-D57C-465B-AAB0-73EF581127D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:7.4:*:*:*:*:*:*:*", "matchCriteriaId": "9EC0D196-F7B8-4BDD-9050-779F7A7FBEE4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:7.5:*:*:*:*:*:*:*", "matchCriteriaId": "A4E9DD8A-A68B-4A69-8B01-BFF92A2020A8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "BF77CDCF-B9C9-427D-B2BF-36650FB2148C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:7.4:*:*:*:*:*:*:*", "matchCriteriaId": "D5F7E11E-FB34-4467-8919-2B6BEAABF665"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "B76AA310-FEC7-497F-AF04-C3EC1E76C4CC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_workstation:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "825ECE2D-E232-46E0-A047-074B34DB1E97"}]}]}], "references": [{"url": "http://blog.rubygems.org/2017/08/27/2.6.13-released.html", "source": "support@hackerone.com", "tags": ["Patch", "Vendor Advisory"]}, {"url": "http://www.securityfocus.com/bid/100579", "source": "support@hackerone.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securitytracker.com/id/1039249", "source": "support@hackerone.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:3485", "source": "support@hackerone.com", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:0378", "source": "support@hackerone.com", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:0583", "source": "support@hackerone.com", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:0585", "source": "support@hackerone.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/rubygems/rubygems/commit/8a38a4fc24c6591e6c8f43d1fadab6efeb4d6251", "source": "support@hackerone.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://hackerone.com/reports/243003", "source": "support@hackerone.com", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/07/msg00012.html", "source": "support@hackerone.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201710-01", "source": "support@hackerone.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2017/dsa-3966", "source": "support@hackerone.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/rubygems/rubygems/commit/8a38a4fc24c6591e6c8f43d1fadab6efeb4d6251"}}