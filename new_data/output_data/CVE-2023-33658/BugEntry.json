{"buggy_code": ["//\n// Copyright 2022 NanoMQ Team, Inc. <jaylin@emqx.io>\n//\n// This software is supplied under the terms of the MIT License, a\n// copy of which should be located in the distribution where this\n// file was obtained (LICENSE.txt).  A copy of the license may also be\n// found online at https://opensource.org/licenses/MIT.\n//\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"core/nng_impl.h\"\n#include \"nng/mqtt/mqtt_client.h\"\n#include \"nng/supplemental/tls/tls.h\"\n#include \"supplemental/mqtt/mqtt_msg.h\"\n#include \"nng/protocol/mqtt/mqtt_parser.h\"\n\n// TLS Over TCP transport.   Platform specific TLS Over TCP operations must be\n// supplied as well.\n\ntypedef struct mqtts_tcptran_pipe mqtts_tcptran_pipe;\ntypedef struct mqtts_tcptran_ep   mqtts_tcptran_ep;\n\n// tcp_pipe is one end of a TCP connection.\nstruct mqtts_tcptran_pipe {\n\tnng_stream *      conn;\n\tnni_pipe *        npipe;\n\tuint32_t          packmax; // MQTT Maximum Packet Size (Max length)\n\tuint16_t          peer;    // broker info\n\tuint16_t          proto;   // MQTT version\n\tuint16_t          keepalive;\n\tuint16_t          sndmax; // MQTT Receive Maximum (QoS 1/2 packet)\n\tuint8_t           pingcnt; // pingreq counter\n\tuint8_t           qosmax;\n\tsize_t            rcvmax;\n\tbool              closed;\n\tnni_list_node     node;\n\tmqtts_tcptran_ep *ep;\n\tnni_atomic_flag   reaped;\n\tnni_reap_node     reap;\n\tuint8_t           txlen[sizeof(uint64_t)];\n\tuint8_t           rxlen[sizeof(uint64_t)]; // fixed header\n\tsize_t            gottxhead;\n\tsize_t            gotrxhead;\n\tsize_t            wanttxhead;\n\tsize_t            wantrxhead;\n\tnni_list          recvq;\n\tnni_list          sendq;\n\tnni_aio           tmaio;\n\tnni_aio *         txaio;\n\tnni_aio *         rxaio;\n\tnni_aio *         rpaio;\n\tnni_aio *         qsaio;\n\tnni_lmq           rslmq;\n\tnni_aio *         negoaio;\n\tnni_msg *         rxmsg;\n\tnni_msg *         smsg;\n\tnni_mtx           mtx;\n\tbool              busy;\n#ifdef NNG_HAVE_MQTT_BROKER\n\tnni_msg *   connack;\n\tconn_param *cparam;\n#endif\n};\n\nstruct mqtts_tcptran_ep {\n\tnni_mtx              mtx;\n\tuint16_t             proto;\n\tsize_t               rcvmax;\n\tbool                 fini;\n\tbool                 started;\n\tbool                 closed;\n\tnng_url *            url;\n\tconst char *         host; // for dialers\n\tnng_sockaddr         src;\n\tnng_sockaddr         sa;\n\tint                  refcnt; // active pipes\n\tint                  authmode;\n\treason_code          reason_code;\n\tnni_aio *            useraio;\n\tnni_aio *            connaio;\n\tnni_aio *            timeaio;\n\tnni_list             busypipes; // busy pipes -- ones passed to socket\n\tnni_list             waitpipes; // pipes waiting to match to socket\n\tnni_list             negopipes; // pipes busy negotiating\n\tnni_reap_node        reap;\n\tnng_stream_dialer *  dialer;\n\tnng_stream_listener *listener;\n\tnni_dialer *         ndialer;\n\tvoid *               property;  // property\n\tvoid *               connmsg;\n\n#ifdef NNG_ENABLE_STATS\n\tnni_stat_item st_rcv_max;\n#endif\n};\n\nstatic void     mqtts_tcptran_pipe_send_start(mqtts_tcptran_pipe *);\nstatic void     mqtts_tcptran_pipe_recv_start(mqtts_tcptran_pipe *);\nstatic void     mqtts_tcptran_pipe_send_cb(void *);\nstatic void     mqtts_tcptran_pipe_qos_send_cb(void *);\nstatic void     mqtts_tcptran_pipe_recv_cb(void *);\nstatic void     mqtts_tcptran_pipe_nego_cb(void *);\nstatic void     mqtts_tcptran_ep_fini(void *);\nstatic void     mqtts_tcptran_pipe_fini(void *);\n\nstatic nni_reap_list tcptran_ep_reap_list = {\n\t.rl_offset = offsetof(mqtts_tcptran_ep, reap),\n\t.rl_func   = mqtts_tcptran_ep_fini,\n};\n\nstatic nni_reap_list tcptran_pipe_reap_list = {\n\t.rl_offset = offsetof(mqtts_tcptran_pipe, reap),\n\t.rl_func   = mqtts_tcptran_pipe_fini,\n};\n\nstatic void\nmqtts_tcptran_init(void)\n{\n}\n\nstatic void\nmqtts_tcptran_fini(void)\n{\n}\n\nstatic void\nmqtts_tcptran_pipe_close(void *arg)\n{\n\tmqtts_tcptran_pipe *p = arg;\n\n\tnni_mtx_lock(&p->mtx);\n\tp->closed = true;\n\tnni_lmq_flush(&p->rslmq);\n\tnni_mtx_unlock(&p->mtx);\n\n\tnni_aio_close(p->rxaio);\n\tnni_aio_close(p->qsaio);\n\tnni_aio_close(p->txaio);\n\tnni_aio_close(&p->tmaio);\n\tnni_aio_close(p->negoaio);\n\tnni_aio_close(p->rpaio);\n\tnng_stream_close(p->conn);\n}\n\nstatic void\nmqtts_pipe_timer_cb(void *arg)\n{\n\tmqtts_tcptran_pipe *p = arg;\n\tuint8_t             buf[2];\n\n\tif (nng_aio_result(&p->tmaio) != 0) {\n\t\treturn;\n\t}\n\n\tif (p->pingcnt > 1) {\n\t\tmqtts_tcptran_pipe_close(p);\n\t\treturn;\n\t}\n\t// send PINGREQ with tmaio itself?\n\t// nng_msleep(p->keepalive);\n\tnni_mtx_lock(&p->mtx);\n\tif (!p->busy && !nni_aio_busy(p->qsaio)) {\n\t\t// send pingreq\n\t\tbuf[0] = 0xC0;\n\t\tbuf[1] = 0x00;\n\n\t\tnni_iov iov;\n\t\tiov.iov_len = 2;\n\t\tiov.iov_buf = &buf;\n\t\t// send it down...\n\t\tnni_aio_set_iov(p->qsaio, 1, &iov);\n\t\tnng_stream_send(p->conn, p->qsaio);\n\t\tp->pingcnt ++;\n\t}\n\tnni_mtx_unlock(&p->mtx);\n\tnni_sleep_aio(p->keepalive, &p->tmaio);\n}\n\nstatic void\nmqtts_tcptran_pipe_stop(void *arg)\n{\n\tmqtts_tcptran_pipe *p = arg;\n\n\tnni_aio_stop(p->rxaio);\n\tnni_aio_stop(p->qsaio);\n\tnni_aio_stop(p->txaio);\n\tnni_aio_stop(p->negoaio);\n\tnni_aio_stop(p->rpaio);\n\tnni_aio_stop(&p->tmaio);\n}\n\nstatic int\nmqtts_tcptran_pipe_init(void *arg, nni_pipe *npipe)\n{\n\tmqtts_tcptran_pipe *p = arg;\n\tnni_pipe_set_conn_param(npipe, p->cparam);\n\n\tp->npipe              = npipe;\n\n\tnni_lmq_init(&p->rslmq, 16);\n\tp->busy = false;\n\tp->packmax = 0xFFFF;\n\tp->qosmax  = 2;\n\tp->pingcnt = 0;\n\tnni_sleep_aio(p->keepalive, &p->tmaio);\n\treturn (0);\n}\n\nstatic void\nmqtts_tcptran_pipe_fini(void *arg)\n{\n\tmqtts_tcptran_pipe *p = arg;\n\tmqtts_tcptran_ep *  ep;\n\n\tmqtts_tcptran_pipe_stop(p);\n\tif ((ep = p->ep) != NULL) {\n\t\tnni_mtx_lock(&ep->mtx);\n\t\tnni_list_node_remove(&p->node);\n\t\tep->refcnt--;\n\t\tif (ep->fini && (ep->refcnt == 0)) {\n\t\t\tnni_reap(&tcptran_ep_reap_list, ep);\n\t\t}\n\t\tnni_mtx_unlock(&ep->mtx);\n\t}\n\n\tnni_aio_free(p->rxaio);\n\tnni_aio_free(p->txaio);\n\tnni_aio_free(p->qsaio);\n\tnni_aio_free(p->negoaio);\n\tnni_aio_free(p->rpaio);\n\tnng_stream_free(p->conn);\n\tnni_msg_free(p->rxmsg);\n\tnni_lmq_fini(&p->rslmq);\n\tnni_mtx_fini(&p->mtx);\n\tnni_aio_fini(&p->tmaio);\n#ifdef NNG_HAVE_MQTT_BROKER\n\tconn_param_free(p->cparam);\n#endif\n\tNNI_FREE_STRUCT(p);\n}\n\nstatic void\nmqtts_tcptran_pipe_reap(mqtts_tcptran_pipe *p)\n{\n\tif (!nni_atomic_flag_test_and_set(&p->reaped)) {\n\t\tif (p->conn != NULL) {\n\t\t\tnng_stream_close(p->conn);\n\t\t}\n\t\tnni_reap(&tcptran_pipe_reap_list, p);\n\t}\n}\n\nstatic int\nmqtts_tcptran_pipe_alloc(mqtts_tcptran_pipe **pipep)\n{\n\tmqtts_tcptran_pipe *p;\n\tint                 rv;\n\n\tif ((p = NNI_ALLOC_STRUCT(p)) == NULL) {\n\t\treturn (NNG_ENOMEM);\n\t}\n\tnni_mtx_init(&p->mtx);\n\tnni_aio_init(&p->tmaio, mqtts_pipe_timer_cb, p);\n\tif (((rv = nni_aio_alloc(&p->txaio, mqtts_tcptran_pipe_send_cb, p)) !=\n\t        0) ||\n\t    ((rv = nni_aio_alloc(&p->rxaio, mqtts_tcptran_pipe_recv_cb, p)) !=\n\t        0) ||\n\t    ((rv = nni_aio_alloc(\n\t          &p->qsaio, mqtts_tcptran_pipe_qos_send_cb, p)) != 0) ||\n\t    ((rv = nni_aio_alloc(&p->rpaio, NULL, p)) != 0) ||\n\t    ((rv = nni_aio_alloc(\n\t          &p->negoaio, mqtts_tcptran_pipe_nego_cb, p)) != 0)) {\n\t\tmqtts_tcptran_pipe_fini(p);\n\t\treturn (rv);\n\t}\n\tnni_aio_list_init(&p->recvq);\n\tnni_aio_list_init(&p->sendq);\n\tnni_atomic_flag_reset(&p->reaped);\n\n\t*pipep = p;\n\n\treturn (0);\n}\n\nstatic void\nmqtts_tcptran_ep_match(mqtts_tcptran_ep *ep)\n{\n\tnni_aio *           aio;\n\tmqtts_tcptran_pipe *p;\n\n\tif (((aio = ep->useraio) == NULL) ||\n\t    ((p = nni_list_first(&ep->waitpipes)) == NULL)) {\n\t\treturn;\n\t}\n\tnni_list_remove(&ep->waitpipes, p);\n\tnni_list_append(&ep->busypipes, p);\n\tep->useraio = NULL;\n#ifdef NNG_HAVE_MQTT_BROKER\n\tif (p->cparam == NULL) {\n\t\tp->cparam = nni_get_conn_param_from_msg(ep->connmsg);\n\t}\n#endif\n\tnni_aio_set_output(aio, 0, p);\n\tnni_aio_finish(aio, 0, 0);\n}\n\nstatic void\nmqtts_tcptran_pipe_nego_cb(void *arg)\n{\n\tmqtts_tcptran_pipe *p   = arg;\n\tmqtts_tcptran_ep *  ep  = p->ep;\n\tnni_aio *           aio = p->negoaio;\n\tnni_aio *           uaio;\n\tint                 rv;\n\tuint8_t             pos = 0;\n\tint                 var_int;\n\n\tnni_mtx_lock(&ep->mtx);\n\n\tif ((rv = nni_aio_result(aio)) != 0) {\n\t\trv = SERVER_UNAVAILABLE;\n\t\tgoto error;\n\t}\n\t// We start transmitting before we receive.\n\tif (p->gottxhead < p->wanttxhead) {\n\t\tp->gottxhead += nni_aio_count(aio);\n\t} else if (p->gotrxhead < p->wantrxhead) {\n\t\tp->gotrxhead += nni_aio_count(aio);\n\t}\n\n\tif (p->gottxhead < p->wanttxhead) {\n\t\tnni_iov iov;\n\t\tiov.iov_len = p->wanttxhead - p->gottxhead;\n\t\tiov.iov_buf = &p->txlen[p->gottxhead];\n\t\t// send it down...\n\t\tnni_aio_set_iov(aio, 1, &iov);\n\t\tnng_stream_send(p->conn, aio);\n\t\tnni_mtx_unlock(&ep->mtx);\n\t\treturn;\n\t}\n\n\t// receving fixed header\n\tif (p->gotrxhead == 0 ||\n\t    (p->gotrxhead <= 5 && p->rxlen[p->gotrxhead - 1] > 0x7f &&\n\t        p->rxmsg == NULL)) {\n\t\tnni_iov iov;\n\t\tiov.iov_buf = &p->rxlen[p->gotrxhead];\n\t\tif (p->gotrxhead == 0) {\n\t\t\tiov.iov_len = p->wantrxhead - p->gotrxhead;\n\t\t} else {\n\t\t\tiov.iov_len = 1;\n\t\t}\n\t\tnni_aio_set_iov(aio, 1, &iov);\n\t\tnng_stream_recv(p->conn, aio);\n\t\tnni_mtx_unlock(&ep->mtx);\n\t\treturn;\n\t}\n\t// only accept CONNACK msg\n\tif ((p->rxlen[0] & CMD_CONNACK) != CMD_CONNACK) {\n\t\trv = PROTOCOL_ERROR;\n\t\tgoto error;\n\t}\n\t// finish recevied fixed header\n\tif (p->rxmsg == NULL) {\n\t\tpos = 0;\n\t\tif ((rv = mqtt_get_remaining_length(p->rxlen, p->gotrxhead,\n\t\t         (uint32_t *) &var_int, &pos)) != 0) {\n\t\t\trv = PAYLOAD_FORMAT_INVALID;\n\t\t\tgoto error;\n\t\t}\n\n\t\tif ((rv = nni_mqtt_msg_alloc(&p->rxmsg, var_int)) != 0) {\n\t\t\trv = NNG_ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\n\t\tnni_msg_header_append(p->rxmsg, p->rxlen, pos + 1);\n\n\t\tp->wantrxhead = var_int + 1 + pos;\n\t\tif (p->proto == MQTT_PROTOCOL_VERSION_v311 &&\n\t\t    ((rv = (p->wantrxhead <= 4) ? 0 : NNG_EPROTO) != 0)) {\n\t\t\t// Broker send a invalid CONNACK!\n\t\t\trv = PROTOCOL_ERROR;\n\t\t\tgoto error;\n\t\t}\n\t}\n\t// remaining length\n\tif (p->gotrxhead < p->wantrxhead) {\n\t\tnni_iov iov;\n\t\tiov.iov_len = p->wantrxhead - p->gotrxhead;\n\t\tiov.iov_buf = nni_msg_body(p->rxmsg);\n\t\tnni_aio_set_iov(aio, 1, &iov);\n\t\tnng_stream_recv(p->conn, aio);\n\t\tnni_mtx_unlock(&ep->mtx);\n\t\treturn;\n\t}\n\t// Connack\n\tif (p->gotrxhead >= p->wantrxhead) {\n\t\tif (p->proto == MQTT_PROTOCOL_VERSION_v5) {\n\t\t\trv              = nni_mqttv5_msg_decode(p->rxmsg);\n\t\t\tep->reason_code = rv;\n\t\t\tif (rv != 0)\n\t\t\t\tgoto mqtt_error;\n\t\t\tproperty_free(ep->property);\n\t\t\tproperty *prop =\n\t\t\t    (void *) nni_mqtt_msg_get_connack_property(\n\t\t\t        p->rxmsg);\n\t\t\tproperty_dup((property **) &ep->property, prop);\n\t\t\tproperty_data *data;\n\t\t\tdata =\n\t\t\t    property_get_value(ep->property, RECEIVE_MAXIMUM);\n\t\t\tif (data) {\n\t\t\t\tif (data->p_value.u16 == 0) {\n\t\t\t\t\trv              = MQTT_ERR_PROTOCOL;\n\t\t\t\t\tep->reason_code = rv;\n\t\t\t\t\tgoto mqtt_error;\n\t\t\t\t} else {\n\t\t\t\t\tp->sndmax = data->p_value.u16;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdata = property_get_value(\n\t\t\t    ep->property, MAXIMUM_PACKET_SIZE);\n\t\t\tif (data) {\n\t\t\t\tif (data->p_value.u32 == 0) {\n\t\t\t\t\trv              = MQTT_ERR_PROTOCOL;\n\t\t\t\t\tep->reason_code = rv;\n\t\t\t\t\tgoto mqtt_error;\n\t\t\t\t} else {\n\t\t\t\t\tp->packmax = data->p_value.u32;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdata = property_get_value(\n\t\t\t    ep->property, PUBLISH_MAXIMUM_QOS);\n\t\t\tif (data) {\n\t\t\t\tp->qosmax = data->p_value.u8;\n\t\t\t}\n\t\t} else {\n\t\t\tif ((rv = nni_mqtt_msg_decode(p->rxmsg)) !=\n\t\t\t    MQTT_SUCCESS) {\n\t\t\t\tep->reason_code = rv;\n\t\t\t\tgoto mqtt_error;\n\t\t\t}\n\t\t\tep->property = NULL;\n\t\t}\n\t\tep->reason_code =\n\t\t    nni_mqtt_msg_get_connack_return_code(p->rxmsg);\n\t}\n\t// put \n#ifdef NNG_HAVE_MQTT_BROKER\n\tnni_msg_clone(p->rxmsg);\n\tp->connack = p->rxmsg;\n#endif\n\nmqtt_error:\n\t// We are ready now.  We put this in the wait list, and\n\t// then try to run the matcher.\n\tnni_list_remove(&ep->negopipes, p);\n\tnni_list_append(&ep->waitpipes, p);\n\n\tnni_msg_free(p->rxmsg);\n\tp->rxmsg = NULL;\n\n\tif (rv == MQTT_SUCCESS) {\n\t\tmqtts_tcptran_ep_match(ep);\n\t} else {\n\t\t// Fail but still match to let user know ack has arrived\n\t\tmqtts_tcptran_ep_match(ep);\n\t\t// send DISCONNECT\n\t\tnni_iov iov;\n\t\tp->txlen[0] = CMD_DISCONNECT;\n\t\tif (p->proto == MQTT_PROTOCOL_VERSION_v5) {\n\t\t\tp->txlen[1] = 0x02;\n\t\t\tp->txlen[2] = ep->reason_code;\n\t\t\tp->txlen[3] = 0; // length of property\n\t\t\tiov.iov_len = 4;\n\t\t} else {\n\t\t\tp->txlen[1] = 0x00;\n\t\t\tiov.iov_len = 2;\n\t\t}\n\t\tiov.iov_buf = p->txlen;\n\t\tnni_aio_set_iov(p->rpaio, 1, &iov);\n\t\tnng_stream_send(p->conn, p->rpaio);\n\t}\n\tnni_mtx_unlock(&ep->mtx);\n\n\treturn;\n\nerror:\n\t// If the connection is closed, we need to pass back a different\n\t// error code.  This is necessary to avoid a problem where the\n\t// closed status is confused with the accept file descriptor\n\t// being closed.\n\tif (rv == NNG_ECLOSED) {\n\t\trv = SERVER_SHUTTING_DOWN;\n\t}\n\tnng_stream_close(p->conn);\n\n\tif (p->rxmsg != NULL) {\n\t\tnni_msg_free(p->rxmsg);\n\t\tp->rxmsg = NULL;\n\t}\n\n\tif ((uaio = ep->useraio) != NULL) {\n\t\tep->useraio = NULL;\n\t\tnni_aio_finish_error(uaio, rv);\n\t}\n\tnni_mtx_unlock(&ep->mtx);\n\tmqtts_tcptran_pipe_reap(p);\n}\n\nstatic void\nmqtts_tcptran_pipe_qos_send_cb(void *arg)\n{\n\tmqtts_tcptran_pipe *p = arg;\n\tnni_msg *           msg;\n\tnni_aio *           qsaio = p->qsaio;\n\n\tif (nni_aio_result(qsaio) != 0) {\n\t\tnni_msg_free(nni_aio_get_msg(qsaio));\n\t\tnni_aio_set_msg(qsaio, NULL);\n\t\tmqtts_tcptran_pipe_close(p);\n\t\treturn;\n\t}\n\tnni_mtx_lock(&p->mtx);\n\n\tmsg = nni_aio_get_msg(p->qsaio);\n\tnni_msg_free(msg);\n\tif (nni_lmq_get(&p->rslmq, &msg) == 0) {\n\t\tnni_iov iov;\n\t\tiov.iov_len = 4;\n\t\tiov.iov_buf = nni_msg_header(msg);\n\t\tnni_aio_set_msg(p->qsaio, msg);\n\t\t// send it down...\n\t\tnni_aio_set_iov(p->qsaio, 1, &iov);\n\t\tnng_stream_send(p->conn, p->qsaio);\n\t\tp->busy = true;\n\t\tnni_mtx_unlock(&p->mtx);\n\t\treturn;\n\t}\n\tp->busy = false;\n\tnni_aio_set_msg(qsaio, NULL);\n\tnni_mtx_unlock(&p->mtx);\n\treturn;\n}\n\nstatic void\nmqtts_tcptran_pipe_send_cb(void *arg)\n{\n\tmqtts_tcptran_pipe *p = arg;\n\tint                 rv;\n\tnni_aio *           aio;\n\tsize_t              n;\n\tnni_msg *           msg;\n\tnni_aio *           txaio = p->txaio;\n\n\tnni_mtx_lock(&p->mtx);\n\taio = nni_list_first(&p->sendq);\n\n\tif ((rv = nni_aio_result(txaio)) != 0) {\n\t\t// Intentionally we do not queue up another transfer.\n\t\t// There's an excellent chance that the pipe is no longer\n\t\t// usable, with a partial transfer.\n\t\t// The protocol should see this error, and close the\n\t\t// pipe itself, we hope.\n\t\tnni_aio_list_remove(aio);\n\t\tnni_mtx_unlock(&p->mtx);\n\t\tnni_aio_finish_error(aio, rv);\n\t\tnni_pipe_bump_error(p->npipe, rv);\n\t\treturn;\n\t}\n\n\tn = nni_aio_count(txaio);\n\tnni_aio_iov_advance(txaio, n);\n\tif (nni_aio_iov_count(txaio) > 0) {\n\t\tnng_stream_send(p->conn, txaio);\n\t\tnni_mtx_unlock(&p->mtx);\n\t\treturn;\n\t}\n\n\tnni_aio_list_remove(aio);\n\tmqtts_tcptran_pipe_send_start(p);\n\n\tmsg = nni_aio_get_msg(aio);\n\tn   = nni_msg_len(msg);\n\tnni_pipe_bump_tx(p->npipe, n);\n\tnni_mtx_unlock(&p->mtx);\n\n\tnni_aio_set_msg(aio, NULL);\n\tnni_msg_free(msg);\n\tnni_aio_finish_sync(aio, 0, n);\n}\n\nstatic void\nmqtts_tcptran_pipe_recv_cb(void *arg)\n{\n\tnni_aio *           aio;\n\tnni_iov             iov;\n\tuint8_t             type, pos, flags;\n\tuint32_t            len = 0, rv;\n\tsize_t              n;\n\tnni_msg *           msg, *qmsg;\n\tmqtts_tcptran_pipe *p     = arg;\n\tnni_aio *           rxaio = p->rxaio;\n\tbool                ack   = false;\n\tnni_mtx_lock(&p->mtx);\n\n\taio = nni_list_first(&p->recvq);\n\n\tif ((rv = nni_aio_result(rxaio)) != 0) {\n\t\trv = SERVER_UNAVAILABLE;\n\t\tgoto recv_error;\n\t}\n\n\tn = nni_aio_count(rxaio);\n\tp->gotrxhead += n;\n\n\t// in case one aio is not enough for handling whole buffer\n\tnni_aio_iov_advance(rxaio, n);\n\tif (nni_aio_iov_count(rxaio) > 0) {\n\t\tnng_stream_recv(p->conn, rxaio);\n\t\tnni_mtx_unlock(&p->mtx);\n\t\treturn;\n\t}\n\n\trv = mqtt_get_remaining_length(p->rxlen, p->gotrxhead, &len, &pos);\n\tp->wantrxhead = len + 1 + pos;\n\tif (p->gotrxhead <= 5 && p->rxlen[p->gotrxhead - 1] > 0x7f) {\n\t\tif (p->gotrxhead == NNI_NANO_MAX_HEADER_SIZE) {\n\t\t\trv = PACKET_TOO_LARGE;\n\t\t\tgoto recv_error;\n\t\t}\n\t\t// same packet, continue receving next byte of remaining length\n\t\tiov.iov_buf = &p->rxlen[p->gotrxhead];\n\t\tiov.iov_len = 1;\n\t\tnni_aio_set_iov(rxaio, 1, &iov);\n\t\tnng_stream_recv(p->conn, rxaio);\n\t\tnni_mtx_unlock(&p->mtx);\n\t\treturn;\n\t}\n\n\t// fixed header finished\n\tif (NULL == p->rxmsg) {\n\t\t// Make sure the message payload is not too big.  If it is\n\t\t// the caller will shut down the pipe.\n\t\tif ((len > p->rcvmax) && (p->rcvmax > 0)) {\n\t\t\trv = PACKET_TOO_LARGE;\n\t\t\tgoto recv_error;\n\t\t}\n\t\tif ((rv = nni_msg_alloc(&p->rxmsg, (size_t) len)) != 0) {\n\t\t\trv = UNSPECIFIED_ERROR;\n\t\t\tgoto recv_error;\n\t\t}\n\t\tnni_msg_set_remaining_len(p->rxmsg, len);\n\n\t\t// Submit the rest of the data for a read -- seperate Fixed\n\t\t// header with variable header and so on\n\t\t//  we want to read the entire message now.\n\t\tif (len != 0) {\n\t\t\tiov.iov_buf = nni_msg_body(p->rxmsg);\n\t\t\tiov.iov_len = (size_t) len;\n\n\t\t\tnni_aio_set_iov(rxaio, 1, &iov);\n\t\t\t// second recv action\n\t\t\tnng_stream_recv(p->conn, rxaio);\n\t\t\tnni_mtx_unlock(&p->mtx);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// We read a message completely.  Let the user know the good news. use\n\t// as application message callback of users\n\tnni_aio_list_remove(aio);\n\tnni_msg_header_append(p->rxmsg, p->rxlen, pos + 1);\n\tmsg      = p->rxmsg;\n\tp->rxmsg = NULL;\n\tn        = nni_msg_len(msg);\n\ttype     = p->rxlen[0] & 0xf0;\n\tflags    = p->rxlen[0] & 0x0f;\n\t// set the payload pointer of msg according to packet_type\n\tuint8_t   qos_pac;\n\tuint16_t  packet_id   = 0;\n\tuint8_t   reason_code = 0;\n\tproperty *prop        = NULL;\n\tuint8_t   ack_cmd     = 0;\n\tswitch (type) {\n\tcase CMD_PUBLISH:\n\t\t// should we seperate the 2 phase work of QoS into 2 aios?\n\t\t// TODO MQTT v5 qos\n\t\tqos_pac = nni_msg_get_pub_qos(msg);\n\t\tif (qos_pac > 0) {\n\t\t\tif (qos_pac == 1) {\n\t\t\t\tack_cmd = CMD_PUBACK;\n\t\t\t} else if (qos_pac == 2) {\n\t\t\t\tack_cmd = CMD_PUBREC;\n\t\t\t}\n\t\t\tpacket_id = nni_msg_get_pub_pid(msg);\n\t\t\tack = true;\n\t\t}\n\t\tbreak;\n\tcase CMD_PUBREC:\n\t\tif (nni_mqtt_pubres_decode(msg, &packet_id, &reason_code, &prop,\n\t\t        p->proto) != 0) {\n\t\t\trv = PROTOCOL_ERROR;\n\t\t\tgoto recv_error;\n\t\t}\n\t\tack_cmd = CMD_PUBREL;\n\t\tack     = true;\n\t\tbreak;\n\tcase CMD_PUBREL:\n\t\tif (flags == 0x02) {\n\t\t\tif (nni_mqtt_pubres_decode(msg, &packet_id, &reason_code,\n\t\t\t        &prop, p->proto) != 0) {\n\t\t\t\trv = PROTOCOL_ERROR;\n\t\t\t\tgoto recv_error;\n\t\t\t}\n\t\t\tack_cmd = CMD_PUBCOMP;\n\t\t\tack     = true;\n\t\t\tbreak;\n\t\t} else {\n\t\t\trv = PROTOCOL_ERROR;\n\t\t\tgoto recv_error;\n\t\t}\n\tcase CMD_PUBACK:\n\t\t// TODO set property for user callback\n\tcase CMD_PUBCOMP:\n\t\tif (nni_mqtt_pubres_decode(\n\t\t        msg, &packet_id, &reason_code, &prop, p->proto) != 0) {\n\t\t\trv = PROTOCOL_ERROR;\n\t\t\tgoto recv_error;\n\t\t}\n\t\tif (p->proto == MQTT_PROTOCOL_VERSION_v5) {\n\t\t\tp->sndmax++;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (ack == true) {\n\t\t// alloc a msg here costs memory. However we must do it for the\n\t\t// sake of compatibility with nng.\n\t\tif ((rv = nni_msg_alloc(&qmsg, 0)) != 0) {\n\t\t\tack = false;\n\t\t\trv  = UNSPECIFIED_ERROR;\n\t\t\tgoto recv_error;\n\t\t}\n\t\t// TODO set reason code or property here if necessary\n\t\tnni_mqtt_msgack_encode(\n\t\t    qmsg, packet_id, reason_code, prop, p->proto);\n\t\tnni_mqtt_pubres_header_encode(qmsg, ack_cmd);\n\t\tif (p->proto == MQTT_PROTOCOL_VERSION_v5) {\n\t\t\tproperty_free(prop);\n\t\t}\n\t\t// aio_begin?\n\t\tif (p->busy == false) {\n\t\t\tnni_msg_insert(qmsg, nni_msg_header(qmsg),\n\t\t\t    nni_msg_header_len(qmsg));\n\t\t\tiov.iov_len    = nni_msg_len(qmsg);\n\t\t\tiov.iov_buf    = nni_msg_body(qmsg);\n\t\t\tp->busy        = true;\n\t\t\tnni_aio_set_msg(p->qsaio, qmsg);\n\t\t\t// send ACK down...\n\t\t\tnni_aio_set_iov(p->qsaio, 1, &iov);\n\t\t\tnng_stream_send(p->conn, p->qsaio);\n\t\t} else {\n\t\t\tif (nni_lmq_full(&p->rslmq)) {\n\t\t\t\t// Make space for the new message. TODO add max\n\t\t\t\t// limit of msgq len in conf\n\t\t\t\tif (nni_lmq_cap(&p->rslmq) <=\n\t\t\t\t    NNG_TRAN_MAX_LMQ_SIZE) {\n\t\t\t\t\tif ((rv = nni_lmq_resize(&p->rslmq,\n\t\t\t\t\t         nni_lmq_cap(&p->rslmq) *\n\t\t\t\t\t             2)) == 0) {\n\t\t\t\t\t\tnni_lmq_put(&p->rslmq, qmsg);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// memory error.\n\t\t\t\t\t\tnni_msg_free(qmsg);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tnni_msg *old;\n\t\t\t\t\t(void) nni_lmq_get(&p->rslmq, &old);\n\t\t\t\t\tnni_msg_free(old);\n\t\t\t\t\tnni_lmq_put(&p->rslmq, qmsg);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnni_lmq_put(&p->rslmq, qmsg);\n\t\t\t}\n\t\t}\n\t\tack = false;\n\t}\n\n\t// keep connection & Schedule next receive\n\tnni_pipe_bump_rx(p->npipe, n);\n\tif (!nni_list_empty(&p->recvq)) {\n\t\tmqtts_tcptran_pipe_recv_start(p);\n\t}\n#ifdef NNG_HAVE_MQTT_BROKER\n\tnni_msg_set_conn_param(msg, p->cparam);\n#endif\n\tnni_aio_set_msg(aio, msg);\n\tp->pingcnt = 0;\n\tnni_mtx_unlock(&p->mtx);\n\tnni_aio_finish_sync(aio, 0, n);\n\treturn;\n\nrecv_error:\n\tnni_aio_list_remove(aio);\n\tmsg      = p->rxmsg;\n\tp->rxmsg = NULL;\n\tnni_pipe_bump_error(p->npipe, rv);\n\tnni_mtx_unlock(&p->mtx);\n\n\tnni_msg_free(msg);\n\tnni_aio_finish_error(aio, rv);\n}\n\nstatic void\nmqtts_tcptran_pipe_send_cancel(nni_aio *aio, void *arg, int rv)\n{\n\tmqtts_tcptran_pipe *p = arg;\n\n\tnni_mtx_lock(&p->mtx);\n\tif (!nni_aio_list_active(aio)) {\n\t\tnni_mtx_unlock(&p->mtx);\n\t\treturn;\n\t}\n\t// If this is being sent, then cancel the pending transfer.\n\t// The callback on the txaio will cause the user aio to\n\t// be canceled too.\n\tif (nni_list_first(&p->sendq) == aio) {\n\t\tnni_aio_abort(p->txaio, rv);\n\t\tnni_mtx_unlock(&p->mtx);\n\t\treturn;\n\t}\n\tnni_aio_list_remove(aio);\n\tnni_mtx_unlock(&p->mtx);\n\n\tnni_aio_finish_error(aio, rv);\n}\n\nstatic void\nmqtts_tcptran_pipe_send_start(mqtts_tcptran_pipe *p)\n{\n\tnni_aio *aio;\n\tnni_aio *txaio;\n\tnni_msg *msg;\n\tint      niov;\n\tnni_iov  iov[3];\n\n\tif (p->closed) {\n\t\twhile ((aio = nni_list_first(&p->sendq)) != NULL) {\n\t\t\tnni_list_remove(&p->sendq, aio);\n\t\t\tnni_aio_finish_error(aio, NNG_ECLOSED);\n\t\t}\n\t\treturn;\n\t}\n\n\tif ((aio = nni_list_first(&p->sendq)) == NULL) {\n\t\treturn;\n\t}\n\n\t// This runs to send the message.\n\tmsg = nni_aio_get_msg(aio);\n\n\tif (msg != NULL && p->proto == MQTT_PROTOCOL_VERSION_v5) {\n\t\tuint8_t *header = nni_msg_header(msg);\n\t\tif ((*header & 0XF0) == CMD_PUBLISH) {\n\t\t\t// check max qos\n\t\t\tuint8_t qos = nni_mqtt_msg_get_publish_qos(msg);\n\t\t\tif (qos > 0)\n\t\t\t\tp->sndmax --;\n\t\t\tif (qos > p->qosmax) {\n\t\t\t\tp->qosmax == 1? (*header &= 0XF9) & (*header |= 0X02):*header;\n\t\t\t\tp->qosmax == 0? *header &= 0XF9:*header;\n\t\t\t}\n\n\t\t}\n\t\t// check max packet size\n\t\tif (nni_msg_header_len(msg) + nni_msg_len(msg) > p->packmax) {\n\t\t\ttxaio = p->txaio;\n\t\t\tnni_aio_finish_error(txaio, UNSPECIFIED_ERROR);\n\t\t\treturn;\n\t\t}\n\t}\n\n\ttxaio = p->txaio;\n\tniov  = 0;\n\n\tif (nni_msg_header_len(msg) > 0) {\n\t\tiov[niov].iov_buf = nni_msg_header(msg);\n\t\tiov[niov].iov_len = nni_msg_header_len(msg);\n\t\tniov++;\n\t}\n\tif (nni_msg_len(msg) > 0) {\n\t\tiov[niov].iov_buf = nni_msg_body(msg);\n\t\tiov[niov].iov_len = nni_msg_len(msg);\n\t\tniov++;\n\t}\n\tnni_aio_set_iov(txaio, niov, iov);\n\tnng_stream_send(p->conn, txaio);\n}\n\nstatic void\nmqtts_tcptran_pipe_send(void *arg, nni_aio *aio)\n{\n\tmqtts_tcptran_pipe *p = arg;\n\tint                 rv;\n\n\tif (nni_aio_begin(aio) != 0) {\n\t\treturn;\n\t}\n\tnni_mtx_lock(&p->mtx);\n\tif ((rv = nni_aio_schedule(aio, mqtts_tcptran_pipe_send_cancel, p)) !=\n\t    0) {\n\t\tnni_mtx_unlock(&p->mtx);\n\t\tnni_aio_finish_error(aio, rv);\n\t\treturn;\n\t}\n\tnni_list_append(&p->sendq, aio);\n\tif (nni_list_first(&p->sendq) == aio) {\n\t\tmqtts_tcptran_pipe_send_start(p);\n\t}\n\tnni_mtx_unlock(&p->mtx);\n}\n\nstatic void\nmqtts_tcptran_pipe_recv_cancel(nni_aio *aio, void *arg, int rv)\n{\n\tmqtts_tcptran_pipe *p = arg;\n\n\tnni_mtx_lock(&p->mtx);\n\tif (!nni_aio_list_active(aio)) {\n\t\tnni_mtx_unlock(&p->mtx);\n\t\treturn;\n\t}\n\t// If receive in progress, then cancel the pending transfer.\n\t// The callback on the rxaio will cause the user aio to\n\t// be canceled too.\n\tif (nni_list_first(&p->recvq) == aio) {\n\t\tnni_aio_abort(p->rxaio, rv);\n\t\tnni_mtx_unlock(&p->mtx);\n\t\treturn;\n\t}\n\tnni_aio_list_remove(aio);\n\tnni_mtx_unlock(&p->mtx);\n\tnni_aio_finish_error(aio, rv);\n}\n\nstatic void\nmqtts_tcptran_pipe_recv_start(mqtts_tcptran_pipe *p)\n{\n\tnni_aio *rxaio;\n\tnni_iov  iov;\n\n\tif (p->closed) {\n\t\tnni_aio *aio;\n\t\twhile ((aio = nni_list_first(&p->recvq)) != NULL) {\n\t\t\tnni_list_remove(&p->recvq, aio);\n\t\t\tnni_aio_finish_error(aio, NNG_ECLOSED);\n\t\t}\n\t\treturn;\n\t}\n\tif (nni_list_empty(&p->recvq)) {\n\t\treturn;\n\t}\n\n\t// Schedule a read of the header.\n\trxaio         = p->rxaio;\n\tp->gotrxhead  = 0;\n\tp->wantrxhead = 2;\n\tiov.iov_buf   = p->rxlen;\n\tiov.iov_len   = 2;\n\tnni_aio_set_iov(rxaio, 1, &iov);\n\tnng_stream_recv(p->conn, rxaio);\n}\n\nstatic void\nmqtts_tcptran_pipe_recv(void *arg, nni_aio *aio)\n{\n\tmqtts_tcptran_pipe *p = arg;\n\tint                 rv;\n\n\tif (nni_aio_begin(aio) != 0) {\n\t\treturn;\n\t}\n\tnni_mtx_lock(&p->mtx);\n\tif ((rv = nni_aio_schedule(aio, mqtts_tcptran_pipe_recv_cancel, p)) !=\n\t    0) {\n\t\tnni_mtx_unlock(&p->mtx);\n\t\tnni_aio_finish_error(aio, rv);\n\t\treturn;\n\t}\n#ifdef NNG_HAVE_MQTT_BROKER\n\tif (p->connack != NULL) {\n\t\tnni_aio_set_msg(aio, p->connack);\n\t\tnni_msg_set_conn_param(p->connack, p->cparam);\n\t\tp->connack = NULL;\n\t\tnni_mtx_unlock(&p->mtx);\n\t\tnni_aio_finish(aio, 0, 0);\n\t\treturn;\n\t}\n#endif\n\tnni_list_append(&p->recvq, aio);\n\tif (nni_list_first(&p->recvq) == aio) {\n\t\tmqtts_tcptran_pipe_recv_start(p);\n\t}\n\tnni_mtx_unlock(&p->mtx);\n}\n\nstatic uint16_t\nmqtts_tcptran_pipe_peer(void *arg)\n{\n\tmqtts_tcptran_pipe *p = arg;\n\n\treturn (p->peer);\n}\n\nstatic int\nmqtts_tcptran_pipe_getopt(\n    void *arg, const char *name, void *buf, size_t *szp, nni_type t)\n{\n\tmqtts_tcptran_pipe *p = arg;\n\treturn (nni_stream_get(p->conn, name, buf, szp, t));\n}\n\nstatic void\nmqtts_tcptran_pipe_start(\n    mqtts_tcptran_pipe *p, nng_stream *conn, mqtts_tcptran_ep *ep)\n{\n\tnni_iov  iov[2];\n\tnni_msg *connmsg = NULL;\n\tuint8_t mqtt_version;\n\tint      niov = 0;\n\tint      rv;\n\n\tep->refcnt++;\n\n\tp->conn   = conn;\n\tp->ep     = ep;\n\tp->rcvmax = 0;\n\tp->sndmax = 65535;\n#ifdef NNG_HAVE_MQTT_BROKER\n\tp->cparam = NULL;\n#endif\n\tnni_dialer_getopt(ep->ndialer, NNG_OPT_MQTT_CONNMSG, &connmsg, NULL,\n\t    NNI_TYPE_POINTER);\n\n\tif (connmsg == NULL) {\n\t\tmqtt_version = 0;\n\t}\n\n\tmqtt_version = nni_mqtt_msg_get_connect_proto_version(connmsg);\n\n\tif (mqtt_version == MQTT_PROTOCOL_VERSION_v311)\n\t\trv = nni_mqtt_msg_encode(connmsg);\n\telse if (mqtt_version == MQTT_PROTOCOL_VERSION_v5) {\n\t\tproperty *prop = nni_mqtt_msg_get_connect_property(connmsg);\n\t\tproperty_data *data;\n\t\tdata = property_get_value(prop, MAXIMUM_PACKET_SIZE);\n\t\tif (data)\n\t\t\tp->rcvmax = data->p_value.u32;\n\t\trv = nni_mqttv5_msg_encode(connmsg);\n\t} else {\n\t\tnni_plat_printf(\"Warning. MQTT protocol version is not specificed.\\n\");\n\t\trv = 1;\n\t}\n\n\tif (rv != MQTT_SUCCESS ||\n\t   (mqtt_version != MQTT_PROTOCOL_VERSION_v311 &&\n\t    mqtt_version != MQTT_PROTOCOL_VERSION_v5)) {\n\t\t// Free the msg from user\n\t\tnni_msg_free(connmsg);\n\t\tnni_plat_printf(\"Warning. Cancelled a illegal connnect msg from user.\\n\");\n\t\t// Using MQTT V311 as default protocol version\n\t\tmqtt_version = 4; // Default TODO Notify user as a warning\n\t\tnni_mqtt_msg_alloc(&connmsg, 0);\n\t\tnni_mqtt_msg_set_packet_type(connmsg, NNG_MQTT_CONNECT);\n\t\tnni_mqtt_msg_set_connect_proto_version(\n\t\t    connmsg, MQTT_PROTOCOL_VERSION_v311);\n\t\tnni_mqtt_msg_set_connect_keep_alive(connmsg, 60);\n\t\tnni_mqtt_msg_set_connect_clean_session(connmsg, true);\n\t}\n\n\tp->gotrxhead  = 0;\n\tp->gottxhead  = 0;\n\tp->wantrxhead = 2;\n\tp->wanttxhead = nni_msg_header_len(connmsg) + nni_msg_len(connmsg);\n\tp->rxmsg      = NULL;\n\tp->keepalive  = nni_mqtt_msg_get_connect_keep_alive(connmsg) * 1000;\n\tp->proto      = mqtt_version;\n\n\tif (nni_msg_len(connmsg) > 0) {\n\t\tnni_msg_insert(connmsg, nni_msg_header(connmsg),\n\t\t    nni_msg_header_len(connmsg));\n\t\tiov[niov].iov_buf = nni_msg_body(connmsg);\n\t\tiov[niov].iov_len = nni_msg_len(connmsg);\n\t\tniov++;\n\t}\n\tnni_aio_set_iov(p->negoaio, niov, iov);\n\tnni_list_append(&ep->negopipes, p);\n\n\tnni_aio_set_timeout(p->negoaio, 10000); // 10 sec timeout to negotiate\n\tnng_stream_send(p->conn, p->negoaio);\n}\n\nstatic void\nmqtts_tcptran_ep_fini(void *arg)\n{\n\tmqtts_tcptran_ep *ep = arg;\n\n\tnni_mtx_lock(&ep->mtx);\n\tep->fini = true;\n\tif (ep->refcnt != 0) {\n\t\tnni_mtx_unlock(&ep->mtx);\n\t\treturn;\n\t}\n\tnni_mtx_unlock(&ep->mtx);\n\tnni_aio_stop(ep->timeaio);\n\tnni_aio_stop(ep->connaio);\n\tnng_stream_dialer_free(ep->dialer);\n\tnng_stream_listener_free(ep->listener);\n\tnni_aio_free(ep->timeaio);\n\tnni_aio_free(ep->connaio);\n\tproperty_free(ep->property);\n\n\tnni_mtx_fini(&ep->mtx);\n\tNNI_FREE_STRUCT(ep);\n}\n\nstatic void\nmqtts_tcptran_ep_close(void *arg)\n{\n\tmqtts_tcptran_ep *  ep = arg;\n\tmqtts_tcptran_pipe *p;\n\n\tnni_mtx_lock(&ep->mtx);\n\n\tep->closed = true;\n\tnni_aio_close(ep->timeaio);\n\tif (ep->dialer != NULL) {\n\t\tnng_stream_dialer_close(ep->dialer);\n\t}\n\tif (ep->listener != NULL) {\n\t\tnng_stream_listener_close(ep->listener);\n\t}\n\tNNI_LIST_FOREACH (&ep->negopipes, p) {\n\t\tmqtts_tcptran_pipe_close(p);\n\t}\n\tNNI_LIST_FOREACH (&ep->waitpipes, p) {\n\t\tmqtts_tcptran_pipe_close(p);\n\t}\n\tNNI_LIST_FOREACH (&ep->busypipes, p) {\n\t\tmqtts_tcptran_pipe_close(p);\n\t}\n\tif (ep->useraio != NULL) {\n\t\tnni_aio_finish_error(ep->useraio, NNG_ECLOSED);\n\t\tep->useraio = NULL;\n\t}\n\n\tnni_mtx_unlock(&ep->mtx);\n}\n\n// This parses off the optional source address that this transport\n// uses. The special handling of this URL format is quite honestly an\n// historical mistake, which we would remove if we could.\nstatic int\nmqtts_tcptran_url_parse_source(\n    nng_url *url, nng_sockaddr *sa, const nng_url *surl)\n{\n\tint      af;\n\tchar *   semi;\n\tchar *   src;\n\tsize_t   len;\n\tint      rv;\n\tnni_aio *aio;\n\n\t// We modify the URL.  This relies on the fact that the\n\t// underlying transport does not free this, so we can just use\n\t// references.\n\n\turl->u_scheme   = surl->u_scheme;\n\turl->u_port     = surl->u_port;\n\turl->u_hostname = surl->u_hostname;\n\n\tif ((semi = strchr(url->u_hostname, ';')) == NULL) {\n\t\tmemset(sa, 0, sizeof(*sa));\n\t\treturn (0);\n\t}\n\n\tlen             = (size_t) (semi - url->u_hostname);\n\turl->u_hostname = semi + 1;\n\n\tif (strcmp(surl->u_scheme, \"tls+tcp\") == 0) {\n\t\taf = NNG_AF_UNSPEC;\n\t} else if (strcmp(surl->u_scheme, \"tls+tcp4\") == 0) {\n\t\taf = NNG_AF_INET;\n\t} else if (strcmp(surl->u_scheme, \"tls+tcp6\") == 0) {\n\t\taf = NNG_AF_INET6;\n\t} else {\n\t\treturn (NNG_EADDRINVAL);\n\t}\n\n\tif ((src = nni_alloc(len + 1)) == NULL) {\n\t\treturn (NNG_ENOMEM);\n\t}\n\tmemcpy(src, surl->u_hostname, len);\n\tsrc[len] = '\\0';\n\n\tif ((rv = nni_aio_alloc(&aio, NULL, NULL)) != 0) {\n\t\tnni_free(src, len + 1);\n\t\treturn (rv);\n\t}\n\n\tnni_resolv_ip(src, \"0\", af, true, sa, aio);\n\tnni_aio_wait(aio);\n\trv = nni_aio_result(aio);\n\tnni_aio_free(aio);\n\tnni_free(src, len + 1);\n\treturn (rv);\n}\n\nstatic void\nmqtts_tcptran_timer_cb(void *arg)\n{\n\tmqtts_tcptran_ep *ep = arg;\n\tif (nni_aio_result(ep->timeaio) == 0) {\n\t\tnng_stream_listener_accept(ep->listener, ep->connaio);\n\t}\n}\n\nstatic void\nmqtts_tcptran_accept_cb(void *arg)\n{\n\tmqtts_tcptran_ep *  ep  = arg;\n\tnni_aio *           aio = ep->connaio;\n\tmqtts_tcptran_pipe *p;\n\tint                 rv;\n\tnng_stream *        conn;\n\n\tnni_mtx_lock(&ep->mtx);\n\n\tif ((rv = nni_aio_result(aio)) != 0) {\n\t\tgoto error;\n\t}\n\n\tconn = nni_aio_get_output(aio, 0);\n\tif ((rv = mqtts_tcptran_pipe_alloc(&p)) != 0) {\n\t\tnng_stream_free(conn);\n\t\tgoto error;\n\t}\n\n\tif (ep->closed) {\n\t\tmqtts_tcptran_pipe_fini(p);\n\t\tnng_stream_free(conn);\n\t\trv = NNG_ECLOSED;\n\t\tgoto error;\n\t}\n\tmqtts_tcptran_pipe_start(p, conn, ep);\n\tnng_stream_listener_accept(ep->listener, ep->connaio);\n\tnni_mtx_unlock(&ep->mtx);\n\treturn;\n\nerror:\n\t// When an error here occurs, let's send a notice up to the\n\t// consumer. That way it can be reported properly.\n\tif ((aio = ep->useraio) != NULL) {\n\t\tep->useraio = NULL;\n\t\tnni_aio_finish_error(aio, rv);\n\t}\n\tswitch (rv) {\n\n\tcase NNG_ENOMEM:\n\tcase NNG_ENOFILES:\n\t\tnng_sleep_aio(10, ep->timeaio);\n\t\tbreak;\n\n\tdefault:\n\t\tif (!ep->closed) {\n\t\t\tnng_stream_listener_accept(ep->listener, ep->connaio);\n\t\t}\n\t\tbreak;\n\t}\n\tnni_mtx_unlock(&ep->mtx);\n}\n\nstatic void\nmqtts_tcptran_dial_cb(void *arg)\n{\n\tmqtts_tcptran_ep *  ep  = arg;\n\tnni_aio *           aio = ep->connaio;\n\tmqtts_tcptran_pipe *p;\n\tint                 rv;\n\tnng_stream *        conn;\n\n\tif ((rv = nni_aio_result(aio)) != 0) {\n\t\tgoto error;\n\t}\n\n\tconn = nni_aio_get_output(aio, 0);\n\tif ((rv = mqtts_tcptran_pipe_alloc(&p)) != 0) {\n\t\tnng_stream_free(conn);\n\t\tgoto error;\n\t}\n\tnni_mtx_lock(&ep->mtx);\n\tif (ep->closed) {\n\t\tmqtts_tcptran_pipe_fini(p);\n\t\tnng_stream_free(conn);\n\t\trv = NNG_ECLOSED;\n\t\tnni_mtx_unlock(&ep->mtx);\n\t\tgoto error;\n\t} else {\n\t\tmqtts_tcptran_pipe_start(p, conn, ep);\n\t}\n\tnni_mtx_unlock(&ep->mtx);\n\treturn;\n\nerror:\n\t// Error connecting.  We need to pass this straight back\n\t// to the user.\n\tnni_mtx_lock(&ep->mtx);\n\tif ((aio = ep->useraio) != NULL) {\n\t\tep->useraio = NULL;\n\t\tnni_aio_finish_error(aio, rv);\n\t}\n\tnni_mtx_unlock(&ep->mtx);\n}\n\nstatic int\nmqtts_tcptran_ep_init(mqtts_tcptran_ep **epp, nng_url *url, nni_sock *sock)\n{\n\tmqtts_tcptran_ep *ep;\n\n\tif ((ep = NNI_ALLOC_STRUCT(ep)) == NULL) {\n\t\treturn (NNG_ENOMEM);\n\t}\n\tnni_mtx_init(&ep->mtx);\n\tNNI_LIST_INIT(&ep->busypipes, mqtts_tcptran_pipe, node);\n\tNNI_LIST_INIT(&ep->waitpipes, mqtts_tcptran_pipe, node);\n\tNNI_LIST_INIT(&ep->negopipes, mqtts_tcptran_pipe, node);\n\n\tep->proto       = nni_sock_proto_id(sock);\n\tep->url         = url;\n\tep->connmsg     = NULL;\n\tep->reason_code = 0;\n\tep->property    = NULL;\n\n#ifdef NNG_ENABLE_STATS\n\tstatic const nni_stat_info rcv_max_info = {\n\t\t.si_name   = \"rcv_max\",\n\t\t.si_desc   = \"maximum receive size\",\n\t\t.si_type   = NNG_STAT_LEVEL,\n\t\t.si_unit   = NNG_UNIT_BYTES,\n\t\t.si_atomic = true,\n\t};\n\tnni_stat_init(&ep->st_rcv_max, &rcv_max_info);\n#endif\n\n\t*epp = ep;\n\treturn (0);\n}\n\nstatic int\nmqtts_tcptran_dialer_init(void **dp, nng_url *url, nni_dialer *ndialer)\n{\n\tmqtts_tcptran_ep *ep;\n\tint               rv;\n\tnng_sockaddr      srcsa;\n\tnni_sock *        sock = nni_dialer_sock(ndialer);\n\tnng_url           myurl;\n\n\t// Check for invalid URL components. only one dialer is allowed\n\tif ((strlen(url->u_path) != 0) && (strcmp(url->u_path, \"/\") != 0)) {\n\t\treturn (NNG_EADDRINVAL);\n\t}\n\tif ((url->u_fragment != NULL) || (url->u_userinfo != NULL) ||\n\t    (url->u_query != NULL) || (strlen(url->u_hostname) == 0) ||\n\t    (strlen(url->u_port) == 0)) {\n\t\treturn (NNG_EADDRINVAL);\n\t}\n\n\tif ((rv = mqtts_tcptran_url_parse_source(&myurl, &srcsa, url)) != 0) {\n\t\treturn (rv);\n\t}\n\n\tif (((rv = mqtts_tcptran_ep_init(&ep, url, sock)) != 0) ||\n\t    ((rv = nni_aio_alloc(&ep->connaio, mqtts_tcptran_dial_cb, ep)) !=\n\t        0)) {\n\t\treturn (rv);\n\t}\n\tep->ndialer  = ndialer;\n\tep->authmode = NNG_TLS_AUTH_MODE_REQUIRED;\n\n\tif ((rv != 0) ||\n\t    ((rv = nng_stream_dialer_alloc_url(&ep->dialer, &myurl)) != 0)) {\n\t\tmqtts_tcptran_ep_fini(ep);\n\t\treturn (rv);\n\t}\n\tif ((srcsa.s_family != NNG_AF_UNSPEC) &&\n\t    ((rv = nni_stream_dialer_set(ep->dialer, NNG_OPT_LOCADDR, &srcsa,\n\t          sizeof(srcsa), NNI_TYPE_SOCKADDR)) != 0)) {\n\t\tmqtts_tcptran_ep_fini(ep);\n\t\treturn (rv);\n\t}\n#ifdef NNG_ENABLE_STATS\n#endif\n\t*dp = ep;\n\treturn (0);\n}\n\nstatic int\nmqtts_tcptran_listener_init(void **lp, nng_url *url, nni_listener *nlistener)\n{\n\tmqtts_tcptran_ep *ep;\n\tuint16_t          af;\n\tchar *            host = url->u_hostname;\n\tnni_aio *         aio;\n\tint               rv;\n\tnni_sock *        sock = nni_listener_sock(nlistener);\n\n\tif (strcmp(url->u_scheme, \"tls+tcp\") == 0) {\n\t\taf = NNG_AF_UNSPEC;\n\t} else if (strcmp(url->u_scheme, \"tls+tcp4\") == 0) {\n\t\taf = NNG_AF_INET;\n\t} else if (strcmp(url->u_scheme, \"tls+tcp6\") == 0) {\n\t\taf = NNG_AF_INET6;\n\t} else {\n\t\treturn (NNG_EADDRINVAL);\n\t}\n\n\t// Check for invalid URL components.\n\tif ((strlen(url->u_path) != 0) && (strcmp(url->u_path, \"/\") != 0)) {\n\t\treturn (NNG_EADDRINVAL);\n\t}\n\tif ((url->u_fragment != NULL) || (url->u_userinfo != NULL) ||\n\t    (url->u_query != NULL)) {\n\t\treturn (NNG_EADDRINVAL);\n\t}\n\n\tif (((rv = mqtts_tcptran_ep_init(&ep, url, sock)) != 0) ||\n\t    ((rv = nni_aio_alloc(&ep->connaio, mqtts_tcptran_accept_cb, ep)) !=\n\t        0) ||\n\t    ((rv = nni_aio_alloc(&ep->timeaio, mqtts_tcptran_timer_cb, ep)) !=\n\t        0)) {\n\t\treturn (rv);\n\t}\n\n\tep->authmode = NNG_TLS_AUTH_MODE_NONE;\n\n\tif (strlen(host) == 0) {\n\t\thost = NULL;\n\t}\n\n\t// XXX: We are doing lookup at listener initialization.  There\n\t// is a valid argument that this should be done at bind time,\n\t// but that would require making bind asynchronous.  In some\n\t// ways this would be worse than the cost of just waiting here.\n\t// We always recommend using local IP addresses rather than\n\t// names when possible.\n\n\tif ((rv = nni_aio_alloc(&aio, NULL, NULL)) != 0) {\n\t\tmqtts_tcptran_ep_fini(ep);\n\t\treturn (rv);\n\t}\n\tnni_resolv_ip(host, url->u_port, af, true, &ep->sa, aio);\n\tnni_aio_wait(aio);\n\trv = nni_aio_result(aio);\n\tnni_aio_free(aio);\n\n\tif (((rv = nng_stream_listener_alloc_url(&ep->listener, url)) != 0) ||\n\t    ((rv = nni_stream_listener_set(ep->listener, NNG_OPT_TLS_AUTH_MODE,\n\t          &ep->authmode, sizeof(ep->authmode), NNI_TYPE_INT32)) !=\n\t        0)) {\n\t\tmqtts_tcptran_ep_fini(ep);\n\t\treturn (rv);\n\t}\n#ifdef NNG_ENABLE_STATS\n\tnni_listener_add_stat(nlistener, &ep->st_rcv_max);\n#endif\n\n\t*lp = ep;\n\treturn (0);\n}\n\nstatic void\nmqtts_tcptran_ep_cancel(nni_aio *aio, void *arg, int rv)\n{\n\tmqtts_tcptran_ep *ep = arg;\n\tnni_mtx_lock(&ep->mtx);\n\tif (ep->useraio == aio) {\n\t\tep->useraio = NULL;\n\t\tnni_aio_finish_error(aio, rv);\n\t}\n\tnni_mtx_unlock(&ep->mtx);\n}\n\nstatic void\nmqtts_tcptran_ep_connect(void *arg, nni_aio *aio)\n{\n\tmqtts_tcptran_ep *ep = arg;\n\tint               rv;\n\n\tif (nni_aio_begin(aio) != 0) {\n\t\treturn;\n\t}\n\tnni_mtx_lock(&ep->mtx);\n\tif (ep->closed) {\n\t\tnni_mtx_unlock(&ep->mtx);\n\t\tnni_aio_finish_error(aio, NNG_ECLOSED);\n\t\treturn;\n\t}\n\tif (ep->useraio != NULL) {\n\t\tnni_mtx_unlock(&ep->mtx);\n\t\tnni_aio_finish_error(aio, NNG_EBUSY);\n\t\treturn;\n\t}\n\tif ((rv = nni_aio_schedule(aio, mqtts_tcptran_ep_cancel, ep)) != 0) {\n\t\tnni_mtx_unlock(&ep->mtx);\n\t\tnni_aio_finish_error(aio, rv);\n\t\treturn;\n\t}\n\tep->useraio = aio;\n\n\tnng_stream_dialer_dial(ep->dialer, ep->connaio);\n\tnni_mtx_unlock(&ep->mtx);\n}\n\nstatic int\nmqtts_tcptran_ep_get_url(void *arg, void *v, size_t *szp, nni_opt_type t)\n{\n\tmqtts_tcptran_ep *ep = arg;\n\tchar *            s;\n\tint               rv;\n\tint               port = 0;\n\n\tif (ep->listener != NULL) {\n\t\t(void) nng_stream_listener_get_int(\n\t\t    ep->listener, NNG_OPT_TCP_BOUND_PORT, &port);\n\t}\n\n\tif ((rv = nni_url_asprintf_port(&s, ep->url, port)) == 0) {\n\t\trv = nni_copyout_str(s, v, szp, t);\n\t\tnni_strfree(s);\n\t}\n\treturn (rv);\n}\n\nstatic int\nmqtts_tcptran_ep_get_connmsg(void *arg, void *v, size_t *szp, nni_opt_type t)\n{\n\tmqtts_tcptran_ep *ep = arg;\n\tint               rv;\n\n\tnni_copyout_ptr(ep->connmsg, v, szp, t);\n\trv = 0;\n\n\treturn (rv);\n}\n\nstatic int\nmqtts_tcptran_ep_set_connmsg(\n    void *arg, const void *v, size_t sz, nni_opt_type t)\n{\n\tmqtts_tcptran_ep *ep = arg;\n\tint              rv;\n\n\tnni_mtx_lock(&ep->mtx);\n\trv = nni_copyin_ptr(&ep->connmsg, v, sz, t);\n\tnni_mtx_unlock(&ep->mtx);\n\n\treturn (rv);\n}\n\nstatic int\nmqtts_tcptran_ep_get_reasoncode(void *arg, void *v, size_t *sz, nni_opt_type t)\n{\n\tNNI_ARG_UNUSED(sz);\n\tmqtts_tcptran_ep *ep = arg;\n\tint              rv;\n\n\tnni_mtx_lock(&ep->mtx);\n\trv = nni_copyin_int(v, &ep->reason_code, sizeof(ep->reason_code), 0, 256, t);\n\tnni_mtx_unlock(&ep->mtx);\n\treturn (rv);\n}\n\nstatic int\nmqtts_tcptran_ep_get_property(void *arg, void *v, size_t *szp, nni_opt_type t)\n{\n\tmqtts_tcptran_ep *ep = arg;\n\tint              rv;\n\n\trv = nni_copyout_ptr(ep->property, v, szp, t);\n\treturn (rv);\n}\n\nstatic int\nmqtts_tcptran_ep_bind(void *arg)\n{\n\tmqtts_tcptran_ep *ep = arg;\n\tint               rv;\n\n\tnni_mtx_lock(&ep->mtx);\n\trv = nng_stream_listener_listen(ep->listener);\n\tnni_mtx_unlock(&ep->mtx);\n\n\treturn (rv);\n}\n\nstatic void\nmqtts_tcptran_ep_accept(void *arg, nni_aio *aio)\n{\n\tmqtts_tcptran_ep *ep = arg;\n\tint               rv;\n\n\tif (nni_aio_begin(aio) != 0) {\n\t\treturn;\n\t}\n\tnni_mtx_lock(&ep->mtx);\n\tif (ep->closed) {\n\t\tnni_mtx_unlock(&ep->mtx);\n\t\tnni_aio_finish_error(aio, NNG_ECLOSED);\n\t\treturn;\n\t}\n\tif (ep->useraio != NULL) {\n\t\tnni_mtx_unlock(&ep->mtx);\n\t\tnni_aio_finish_error(aio, NNG_EBUSY);\n\t\treturn;\n\t}\n\tif ((rv = nni_aio_schedule(aio, mqtts_tcptran_ep_cancel, ep)) != 0) {\n\t\tnni_mtx_unlock(&ep->mtx);\n\t\tnni_aio_finish_error(aio, rv);\n\t\treturn;\n\t}\n\tep->useraio = aio;\n\tif (!ep->started) {\n\t\tep->started = true;\n\t\tnng_stream_listener_accept(ep->listener, ep->connaio);\n\t} else {\n\t\tmqtts_tcptran_ep_match(ep);\n\t}\n\tnni_mtx_unlock(&ep->mtx);\n}\n\nstatic nni_sp_pipe_ops mqtts_tcptran_pipe_ops = {\n\t.p_init   = mqtts_tcptran_pipe_init,\n\t.p_fini   = mqtts_tcptran_pipe_fini,\n\t.p_stop   = mqtts_tcptran_pipe_stop,\n\t.p_send   = mqtts_tcptran_pipe_send,\n\t.p_recv   = mqtts_tcptran_pipe_recv,\n\t.p_close  = mqtts_tcptran_pipe_close,\n\t.p_peer   = mqtts_tcptran_pipe_peer,\n\t.p_getopt = mqtts_tcptran_pipe_getopt,\n};\n\nstatic const nni_option mqtts_tcptran_ep_opts[] = {\n\t{\n\t    .o_name = NNG_OPT_MQTT_CONNECT_REASON,\n\t    .o_get  = mqtts_tcptran_ep_get_reasoncode,\n\t},\n\t{\n\t    .o_name = NNG_OPT_MQTT_CONNECT_PROPERTY,\n\t    .o_get  = mqtts_tcptran_ep_get_property,\n\t},\n\t{\n\t    .o_name = NNG_OPT_MQTT_CONNMSG,\n\t    .o_get  = mqtts_tcptran_ep_get_connmsg,\n\t    .o_set  = mqtts_tcptran_ep_set_connmsg,\n\t},\n\t{\n\t    .o_name = NNG_OPT_URL,\n\t    .o_get  = mqtts_tcptran_ep_get_url,\n\t},\n\t// terminate list\n\t{\n\t    .o_name = NULL,\n\t},\n};\n\nstatic int\nmqtts_tcptran_dialer_getopt(\n    void *arg, const char *name, void *buf, size_t *szp, nni_type t)\n{\n\tmqtts_tcptran_ep *ep = arg;\n\tint               rv;\n\n\trv = nni_stream_dialer_get(ep->dialer, name, buf, szp, t);\n\tif (rv == NNG_ENOTSUP) {\n\t\trv = nni_getopt(mqtts_tcptran_ep_opts, name, ep, buf, szp, t);\n\t}\n\treturn (rv);\n}\n\nstatic int\nmqtts_tcptran_dialer_setopt(\n    void *arg, const char *name, const void *buf, size_t sz, nni_type t)\n{\n\tmqtts_tcptran_ep *ep = arg;\n\tint               rv;\n\n\t// TODO get mqtts dialer's option\n\trv = nni_stream_dialer_set(ep->dialer, name, buf, sz, t);\n\tif (rv == NNG_ENOTSUP) {\n\t\trv = nni_setopt(mqtts_tcptran_ep_opts, name, ep, buf, sz, t);\n\t}\n\treturn (rv);\n}\n\nstatic int\nmqtts_tcptran_listener_getopt(\n    void *arg, const char *name, void *buf, size_t *szp, nni_type t)\n{\n\tmqtts_tcptran_ep *ep = arg;\n\tint               rv;\n\n\trv = nni_stream_listener_get(ep->listener, name, buf, szp, t);\n\tif (rv == NNG_ENOTSUP) {\n\t\trv = nni_getopt(mqtts_tcptran_ep_opts, name, ep, buf, szp, t);\n\t}\n\treturn (rv);\n}\n\nstatic int\nmqtts_tcptran_listener_setopt(\n    void *arg, const char *name, const void *buf, size_t sz, nni_type t)\n{\n\tmqtts_tcptran_ep *ep = arg;\n\tint               rv;\n\n\trv = nni_stream_listener_set(ep->listener, name, buf, sz, t);\n\tif (rv == NNG_ENOTSUP) {\n\t\trv = nni_setopt(mqtts_tcptran_ep_opts, name, ep, buf, sz, t);\n\t}\n\treturn (rv);\n}\n\nstatic nni_sp_dialer_ops mqtts_tcptran_dialer_ops = {\n\t.d_init    = mqtts_tcptran_dialer_init,\n\t.d_fini    = mqtts_tcptran_ep_fini,\n\t.d_connect = mqtts_tcptran_ep_connect,\n\t.d_close   = mqtts_tcptran_ep_close,\n\t.d_getopt  = mqtts_tcptran_dialer_getopt,\n\t.d_setopt  = mqtts_tcptran_dialer_setopt,\n};\n\nstatic nni_sp_listener_ops mqtts_tcptran_listener_ops = {\n\t.l_init   = mqtts_tcptran_listener_init,\n\t.l_fini   = mqtts_tcptran_ep_fini,\n\t.l_bind   = mqtts_tcptran_ep_bind,\n\t.l_accept = mqtts_tcptran_ep_accept,\n\t.l_close  = mqtts_tcptran_ep_close,\n\t.l_getopt = mqtts_tcptran_listener_getopt,\n\t.l_setopt = mqtts_tcptran_listener_setopt,\n};\n\nstatic nni_sp_tran mqtts_tcp_tran = {\n\t.tran_scheme   = \"tls+mqtt-tcp\",\n\t.tran_dialer   = &mqtts_tcptran_dialer_ops,\n\t.tran_listener = &mqtts_tcptran_listener_ops,\n\t.tran_pipe     = &mqtts_tcptran_pipe_ops,\n\t.tran_init     = mqtts_tcptran_init,\n\t.tran_fini     = mqtts_tcptran_fini,\n};\n\nstatic nni_sp_tran mqtts_tcp4_tran = {\n\t.tran_scheme   = \"tls+mqtt-tcp4\",\n\t.tran_dialer   = &mqtts_tcptran_dialer_ops,\n\t.tran_listener = &mqtts_tcptran_listener_ops,\n\t.tran_pipe     = &mqtts_tcptran_pipe_ops,\n\t.tran_init     = mqtts_tcptran_init,\n\t.tran_fini     = mqtts_tcptran_fini,\n};\n\nstatic nni_sp_tran mqtts_tcp6_tran = {\n\t.tran_scheme   = \"tls+mqtt-tcp6\",\n\t.tran_dialer   = &mqtts_tcptran_dialer_ops,\n\t.tran_listener = &mqtts_tcptran_listener_ops,\n\t.tran_pipe     = &mqtts_tcptran_pipe_ops,\n\t.tran_init     = mqtts_tcptran_init,\n\t.tran_fini     = mqtts_tcptran_fini,\n};\n\n#ifndef NNG_ELIDE_DEPRECATED\nint\nnng_mqtts_tcp_register(void)\n{\n\treturn (nni_init());\n}\n#endif\n\nvoid\nnni_mqtts_tcp_register(void)\n{\n\tnni_mqtt_tran_register(&mqtts_tcp_tran);\n\tnni_mqtt_tran_register(&mqtts_tcp4_tran);\n\tnni_mqtt_tran_register(&mqtts_tcp6_tran);\n}\n", "//\n// Copyright 2022 NanoMQ Team, Inc. <jaylin@emqx.io>\n//\n// This software is supplied under the terms of the MIT License, a\n// copy of which should be located in the distribution where this\n// file was obtained (LICENSE.txt).  A copy of the license may also be\n// found online at https://opensource.org/licenses/MIT.\n//\n#include \"nng/supplemental/nanolib/conf.h\"\n#include \"nng/supplemental/nanolib/conf.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"core/nng_impl.h\"\n#include \"core/sockimpl.h\"\n\n#include \"nng/protocol/mqtt/mqtt.h\"\n#include \"nng/protocol/mqtt/mqtt_parser.h\"\n#include \"nng/supplemental/tls/tls.h\"\n#include \"supplemental/mqtt/mqtt_qos_db_api.h\"\n#include \"supplemental/mqtt/mqtt_msg.h\"\n\n// TLS over TCP transport.   Platform specific TLS Over TCP operations must be\n// supplied as well.\n\ntypedef struct tlstran_pipe tlstran_pipe;\ntypedef struct tlstran_ep   tlstran_ep;\n\nstatic inline void\ntlstran_pipe_send_start_v4(tlstran_pipe *p, nni_msg *msg, nni_aio *aio);\nstatic inline void\ntlstran_pipe_send_start_v5(tlstran_pipe *p, nni_msg *msg, nni_aio *aio);\n\n// tcp_pipe is one end of a TCP connection.\nstruct tlstran_pipe {\n\tnng_stream *conn;\n\tnni_pipe   *npipe; // for statitical\n\tconf       *conf;\n\t// uint16_t        peer;\t\t//reserved for MQTT sdk version\n\t// uint16_t        proto;\n\tsize_t          rcvmax;\n\tsize_t          gotrxhead;\n\tsize_t          wantrxhead;\n\tbool            closed;\n\tbool            busy; // indicator for qos ack & aio\n\tuint8_t         txlen[NANO_MIN_PACKET_LEN];\n\tuint8_t         rxlen[NNI_NANO_MAX_HEADER_SIZE];\n\tuint8_t        *conn_buf;\n\tuint8_t        *qos_buf;\n\tnni_aio        *txaio;\n\tnni_aio        *rxaio;\n\tnni_aio        *qsaio;\n\tnni_aio        *rpaio;\n\tnni_aio        *negoaio;\n\tnni_lmq         rslmq;\n\tnni_msg        *rxmsg, *cnmsg;\n\tnni_mtx         mtx;\n\tconn_param     *tcp_cparam;\n\tnni_list        recvq;\n\tnni_list        sendq;\n\tnni_list_node   node;\n\ttlstran_ep     *ep;\n\tnni_atomic_flag reaped;\n\tnni_reap_node   reap;\n\t// uint8_t       sli_win[5];\t//use aio multiple times instead of\n\t// seperating 2 packets manually\n\t// MQTT V5\n\tuint16_t qrecv_quota;\n\tuint32_t qsend_quota;\n};\n\nstruct tlstran_ep {\n\tnni_mtx mtx;\n\t// uint16_t             proto;\n\tsize_t               rcvmax;\n\tconf *               conf;\n\tbool                 fini;\n\tbool                 started;\n\tbool                 closed;\n\tnng_url *            url;\n\tnng_sockaddr         src;\n\tnng_sockaddr         sa;\n\tint                  refcnt; // active pipes\n\tint                  authmode;\n\tnni_aio *            useraio;\n\tnni_aio *            connaio;\n\tnni_aio *            timeaio;\n\tnni_list             busypipes; // busy pipes -- ones passed to socket\n\tnni_list             waitpipes; // pipes waiting to match to socket\n\tnni_list             negopipes; // pipes busy negotiating\n\tnni_reap_node        reap;\n\tnng_stream_listener *listener;\n#ifdef NNG_ENABLE_STATS\n\tnni_stat_item st_rcv_max;\n#endif\n};\n\nstatic void tlstran_pipe_send_start(tlstran_pipe *);\nstatic void tlstran_pipe_recv_start(tlstran_pipe *);\nstatic void tlstran_pipe_qos_send_cb(void *);\nstatic void tlstran_pipe_send_cb(void *);\nstatic void tlstran_pipe_recv_cb(void *);\nstatic void tlstran_pipe_nego_cb(void *);\nstatic void tlstran_ep_fini(void *);\nstatic void tlstran_pipe_fini(void *);\n\nstatic inline void\ntlstran_pipe_send_start_v5(tlstran_pipe *p, nni_msg *msg, nni_aio *aio);\n\nstatic nni_reap_list tlstran_ep_reap_list = {\n\t.rl_offset = offsetof(tlstran_ep, reap),\n\t.rl_func   = tlstran_ep_fini,\n};\n\nstatic nni_reap_list tlstran_pipe_reap_list = {\n\t.rl_offset = offsetof(tlstran_pipe, reap),\n\t.rl_func   = tlstran_pipe_fini,\n};\n\nstatic void\ntlstran_init(void)\n{\n}\n\nstatic void\ntlstran_fini(void)\n{\n}\n\nstatic void\ntlstran_pipe_close(void *arg)\n{\n\ttlstran_pipe *p = arg;\n\t// nni_pipe *    npipe = p->npipe;\n\n\tnni_mtx_lock(&p->mtx);\n\tp->closed = true;\n\tlog_trace(\" ###### tlstran_pipe_close ###### \");\n\t// p->closed = true;\n\n\tnni_lmq_flush(&p->rslmq);\n\tnni_mtx_unlock(&p->mtx);\n\n\tnni_aio_close(p->rxaio);\n\tnni_aio_close(p->rpaio);\n\tnni_aio_close(p->txaio);\n\tnni_aio_close(p->qsaio);\n\tnni_aio_close(p->negoaio);\n\n\tnng_stream_close(p->conn);\n}\n\nstatic void\ntlstran_pipe_stop(void *arg)\n{\n\ttlstran_pipe *p = arg;\n\tlog_trace(\" ###### tlstran_pipe_stop ###### \");\n\tp->tcp_cparam = NULL;\n\tnni_aio_stop(p->qsaio);\n\tnni_aio_stop(p->rpaio);\n\tnni_aio_stop(p->rxaio);\n\tnni_aio_stop(p->txaio);\n\tnni_aio_stop(p->negoaio);\n}\n\nstatic int\ntlstran_pipe_init(void *arg, nni_pipe *npipe)\n{\n\tlog_trace(\"************tlstran_pipe_init************\");\n\ttlstran_pipe *p = arg;\n\n\tnni_pipe_set_conn_param(npipe, p->tcp_cparam);\n\tp->npipe    = npipe;\n\n\tif (!p->conf->sqlite.enable) {\n\t\tnni_qos_db_init_id_hash(npipe->nano_qos_db);\n\t}\n\n\tp->conn_buf = NULL;\n\tp->busy     = false;\n\n\tnni_lmq_init(&p->rslmq, 16);\n\tp->qos_buf = nng_zalloc(16 + NNI_NANO_MAX_PACKET_SIZE);\n\treturn (0);\n}\n\nstatic void\ntlstran_pipe_fini(void *arg)\n{\n\ttlstran_pipe *p = arg;\n\ttlstran_ep *  ep;\n\n\ttlstran_pipe_stop(p);\n\tif ((ep = p->ep) != NULL) {\n\t\tnni_mtx_lock(&ep->mtx);\n\t\tnni_list_node_remove(&p->node);\n\t\tep->refcnt--;\n\t\tif (ep->fini && (ep->refcnt == 0)) {\n\t\t\tnni_reap(&tlstran_ep_reap_list, ep);\n\t\t}\n\t\tnni_mtx_unlock(&ep->mtx);\n\t}\n\n\tnng_free(p->qos_buf, 16 + NNI_NANO_MAX_PACKET_SIZE);\n\tnni_aio_free(p->qsaio);\n\tnni_aio_free(p->rpaio);\n\tnni_aio_free(p->rxaio);\n\tnni_aio_free(p->txaio);\n\tnni_aio_free(p->negoaio);\n\tnng_stream_free(p->conn);\n\tif (p->rxmsg != NULL)\n\t\tnni_msg_free(p->rxmsg);\n\tnni_lmq_fini(&p->rslmq);\n\t// nni_mtx_fini(&p->mtx);\n\tNNI_FREE_STRUCT(p);\n}\n\nstatic void\ntlstran_pipe_reap(tlstran_pipe *p)\n{\n\tif (!nni_atomic_flag_test_and_set(&p->reaped)) {\n\t\tif (p->conn != NULL) {\n\t\t\tnng_stream_close(p->conn);\n\t\t}\n\t\tnni_reap(&tlstran_pipe_reap_list, p);\n\t}\n}\n\nstatic int\ntlstran_pipe_alloc(tlstran_pipe **pipep)\n{\n\ttlstran_pipe *p;\n\tint           rv;\n\n\tif ((p = NNI_ALLOC_STRUCT(p)) == NULL) {\n\t\treturn (NNG_ENOMEM);\n\t}\n\tnni_mtx_init(&p->mtx);\n\tif (((rv = nni_aio_alloc(&p->txaio, tlstran_pipe_send_cb, p)) != 0) ||\n\t    ((rv = nni_aio_alloc(&p->qsaio, tlstran_pipe_qos_send_cb, p)) != 0) ||\n\t    ((rv = nni_aio_alloc(&p->rpaio, NULL, p)) != 0) ||\n\t    ((rv = nni_aio_alloc(&p->rxaio, tlstran_pipe_recv_cb, p)) != 0) ||\n\t    ((rv = nni_aio_alloc(&p->negoaio, tlstran_pipe_nego_cb, p)) !=\n\t        0)) {\n\t\ttlstran_pipe_fini(p);\n\t\treturn (rv);\n\t}\n\tnni_aio_list_init(&p->recvq);\n\tnni_aio_list_init(&p->sendq);\n\tnni_atomic_flag_reset(&p->reaped);\n\n\t*pipep = p;\n\n\treturn (0);\n}\n\nstatic void\ntlstran_ep_match(tlstran_ep *ep)\n{\n\tnni_aio *     aio;\n\ttlstran_pipe *p;\n\n\tif (((aio = ep->useraio) == NULL) ||\n\t    ((p = nni_list_first(&ep->waitpipes)) == NULL)) {\n\t\treturn;\n\t}\n\tnni_list_remove(&ep->waitpipes, p);\n\tnni_list_append(&ep->busypipes, p);\n\tep->useraio = NULL;\n\tp->rcvmax   = ep->rcvmax;\n\tp->conf     = ep->conf;\n\tnni_aio_set_output(aio, 0, p);\n\tnni_aio_finish(aio, 0, 0);\n}\n\n/**\n * MQTT protocal negotiate\n * deal with CONNECT packet\n * Fixed header to variable header\n * receive multiple times for complete data packet then reply ACK in protocol\n * layer iov_len limits the length readv reads\n * TODO independent with nng SP\n */\nstatic void\ntlstran_pipe_nego_cb(void *arg)\n{\n\ttlstran_pipe *p   = arg;\n\ttlstran_ep *  ep  = p->ep;\n\tnni_aio *     aio = p->negoaio;\n\tnni_aio *     uaio;\n\tnni_iov       iov;\n\tuint32_t      len;\n\tint           rv, len_of_varint = 0;\n\n\tlog_trace(\"start tlstran_pipe_nego_cb max len %ld pipe_addr %p\\n\",\n\t    NANO_CONNECT_PACKET_LEN, p);\n\tnni_mtx_lock(&ep->mtx);\n\n\tif ((rv = nni_aio_result(aio)) != 0) {\n\t\tlog_warn(\" nego aio error %s\", nng_strerror(rv));\n\t\tgoto error;\n\t}\n\n\t// calculate number of bytes received\n\tif (p->gotrxhead < p->wantrxhead) {\n\t\tp->gotrxhead += nni_aio_count(aio);\n\t}\n\n\t// recv fixed header\n\tif (p->gotrxhead < NNI_NANO_MAX_HEADER_SIZE) {\n\t\tnni_iov iov;\n\t\tiov.iov_len = NNI_NANO_MAX_HEADER_SIZE - p->gotrxhead;\n\t\tiov.iov_buf = &p->rxlen[p->gotrxhead];\n\t\tnni_aio_set_iov(aio, 1, &iov);\n\t\tnng_stream_recv(p->conn, aio);\n\t\tnni_mtx_unlock(&ep->mtx);\n\t\treturn;\n\t}\n\tif (p->gotrxhead == NNI_NANO_MAX_HEADER_SIZE) {\n\t\tif (p->rxlen[0] != CMD_CONNECT) {\n\t\t\tlog_warn(\"CMD TYPE %x\", p->rxlen[0]);\n\t\t\trv = NNG_EPROTO;\n\t\t\tgoto error;\n\t\t}\n\t\tlen =\n\t\t    get_var_integer(p->rxlen + 1, (uint32_t *) &len_of_varint);\n\t\tp->wantrxhead = len + 1 + len_of_varint;\n\t\trv            = (p->wantrxhead >= NANO_CONNECT_PACKET_LEN) ? 0\n\t\t                                                           : NNG_EPROTO;\n\t\tif (rv != 0) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t// we have finished the fixed header\n\tif (p->gotrxhead < p->wantrxhead) {\n\t\tnni_iov iov;\n\t\tiov.iov_len = p->wantrxhead - p->gotrxhead;\n\t\tif (p->conn_buf == NULL) {\n\t\t\tp->conn_buf = nng_alloc(p->wantrxhead);\n\t\t\tmemcpy(p->conn_buf, p->rxlen, p->gotrxhead);\n\t\t}\n\t\tiov.iov_buf = &p->conn_buf[p->gotrxhead];\n\t\tnni_aio_set_iov(aio, 1, &iov);\n\t\tnng_stream_recv(p->conn, aio);\n\t\tnni_mtx_unlock(&ep->mtx);\n\t\treturn;\n\t}\n\n\t// We have both sent and received the CONNECT headers.\n\t// CONNECT packet serialization\n\n\tif (p->gotrxhead >= p->wantrxhead) {\n\t\tif (p->tcp_cparam == NULL) {\n\t\t\tconn_param_alloc(&p->tcp_cparam);\n\t\t}\n\t\tif (conn_handler(p->conn_buf, p->tcp_cparam, p->wantrxhead) == 0) {\n\t\t\tnng_free(p->conn_buf, p->wantrxhead);\n\t\t\tp->conn_buf = NULL;\n\t\t\t// we don't need to alloc a new msg, just use pipe.\n\t\t\t// We are all ready now.  We put this in the wait list,\n\t\t\t// and then try to run the matcher.\n\n\t\t\t// Connection is accepted.\n\t\t\tif (p->tcp_cparam->pro_ver == 5) {\n\t\t\t\tp->qsend_quota = p->tcp_cparam->rx_max;\n\t\t\t}\n\t\t\tnni_list_remove(&ep->negopipes, p);\n\t\t\tnni_list_append(&ep->waitpipes, p);\n\t\t\ttlstran_ep_match(ep);\n\t\t\tif (p->tcp_cparam->max_packet_size == 0) {\n\t\t\t\t// set default max packet size for client\n\t\t\t\tp->tcp_cparam->max_packet_size = p->conf == NULL?\n\t\t\t\tNANO_MAX_RECV_PACKET_SIZE : p->conf->client_max_packet_size;\n\t\t\t}\n\t\t\tnni_mtx_unlock(&ep->mtx);\n\t\t\treturn;\n\t\t} else {\n\t\t\tnng_free(p->conn_buf, p->wantrxhead);\n\t\t\tif (p->tcp_cparam->pro_ver == 5) {\n\t\t\t\tgoto close;\n\t\t\t} else {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\tnni_mtx_unlock(&ep->mtx);\n\tlog_trace(\"^^^^^^^^^^end of tlstran_pipe_nego_cb^^^^^^^^^^\\n\");\n\treturn;\n\nclose:\n\t// if a malformated CONNECT packet is received\n\t// reply CONNACK here for MQTT V5\n\t// otherwise deal with it in protocol layer\n\tp->txlen[0] = CMD_CONNACK;\n\tp->txlen[1] = 0x03;\n\tp->txlen[2] = 0x00;\n\tp->txlen[3] = rv;\n\tp->txlen[4] = 0x00;\n\tiov.iov_len = 5;\n\tiov.iov_buf = &p->txlen;\n\t// send connack down...\n\tnni_aio_set_iov(p->rpaio, 1, &iov);\n\tnng_stream_send(p->conn, p->rpaio);\n\tnng_aio_wait(p->rpaio);\nerror:\n\t// If the connection is closed, we need to pass back a different\n\t// error code.  This is necessary to avoid a problem where the\n\t// closed status is confused with the accept file descriptor\n\t// being closed.\n\tconn_param_free(p->tcp_cparam);\n\tif (rv == NNG_ECLOSED) {\n\t\trv = NNG_ECONNSHUT;\n\t}\n\tnng_stream_close(p->conn);\n\n\tif ((uaio = ep->useraio) != NULL) {\n\t\tep->useraio = NULL;\n\t\tnni_aio_finish_error(uaio, rv);\n\t}\n\tnni_mtx_unlock(&ep->mtx);\n\ttlstran_pipe_reap(p);\n\tlog_error(\"connect nego error rv: %s(%d)\", nng_strerror(rv), rv);\n}\n\nstatic void\ntlstran_pipe_qos_send_cb(void *arg)\n{\n\ttlstran_pipe *p = arg;\n\tnni_msg      *msg;\n\tnni_aio      *qsaio = p->qsaio;\n\tuint8_t       type;\n\tsize_t        n;\n\n\tif (nni_aio_result(qsaio) != 0) {\n\t\tnni_msg_free(nni_aio_get_msg(qsaio));\n\t\tnni_aio_set_msg(qsaio, NULL);\n\t\ttlstran_pipe_close(p);\n\t\treturn;\n\t}\n\tnni_mtx_lock(&p->mtx);\n\tn = nni_aio_count(qsaio);\n\tnni_aio_iov_advance(qsaio, n);\n\tif (nni_aio_iov_count(qsaio) > 0) {\n\t\tnng_stream_send(p->conn, qsaio);\n\t\tnni_mtx_unlock(&p->mtx);\n\t\treturn;\n\t}\n\tmsg  = nni_aio_get_msg(p->qsaio);\n\ttype = nni_msg_cmd_type(msg);\n\n\tif (p->tcp_cparam->pro_ver == 5) {\n\t\t(type == CMD_PUBCOMP || type == PUBACK) ? p->qrecv_quota++\n\t\t                                        : p->qrecv_quota;\n\t}\n\tnni_msg_free(msg);\n\tif (nni_lmq_get(&p->rslmq, &msg) == 0) {\n\t\tnni_iov iov;\n\t\tnni_msg_insert(\n\t\t    msg, nni_msg_header(msg), nni_msg_header_len(msg));\n\t\tiov.iov_len = nni_msg_len(msg);\n\t\tiov.iov_buf = nni_msg_body(msg);\n\t\tnni_aio_set_msg(p->qsaio, msg);\n\t\t// send it down...\n\t\tnni_aio_set_iov(p->qsaio, 1, &iov);\n\t\tnng_stream_send(p->conn, p->qsaio);\n\t\tp->busy = true;\n\t\tnni_mtx_unlock(&p->mtx);\n\t\tnni_aio_set_msg(qsaio, NULL);\n\t\treturn;\n\t}\n\tp->busy = false;\n\tnni_mtx_unlock(&p->mtx);\n\tnni_aio_set_msg(qsaio, NULL);\n\treturn;\n}\n\nstatic void\ntlstran_pipe_send_cb(void *arg)\n{\n\ttlstran_pipe *p = arg;\n\tint           rv;\n\tnni_aio *     aio;\n\tuint8_t *     header;\n\tuint8_t       flag = 0, cmd;\n\tsize_t        n;\n\tnni_msg *     msg;\n\tnni_aio *     txaio = p->txaio;\n\n\tnni_mtx_lock(&p->mtx);\n\taio = nni_list_first(&p->sendq);\n\n\tlog_trace(\"############### tlstran_pipe_send_cb ################\");\n\n\tif ((rv = nni_aio_result(txaio)) != 0) {\n\t\tlog_warn(\" send aio error %s\", nng_strerror(rv));\n\t\tnni_pipe_bump_error(p->npipe, rv);\n\t\tnni_aio_list_remove(aio);\n\t\tnni_mtx_unlock(&p->mtx);\n\t\tnni_aio_finish_error(aio, rv);\n\t\treturn;\n\t}\n\n\tn = nni_aio_count(txaio);\n\tnni_aio_iov_advance(txaio, n);\n\tlog_trace(\"tls over tcp socket sent %ld bytes iov %ld\", n,\n\t    nni_aio_iov_count(txaio));\n\n\tif (nni_aio_iov_count(txaio) > 0) {\n\t\tnng_stream_send(p->conn, txaio);\n\t\tnni_mtx_unlock(&p->mtx);\n\t\treturn;\n\t}\n\tmsg = nni_aio_get_msg(txaio);\n\tnni_aio_set_msg(txaio, NULL);\n\tif (msg != NULL) {\n\t\tnni_msg_free(msg);\n\t}\n\tmsg = nni_aio_get_msg(aio);\n\n\tif (nni_aio_get_prov_data(txaio) != NULL) {\n\t\t// msgs left behind due to multiple topics matched\n\t\tif (p->tcp_cparam->pro_ver == 4)\n\t\t\ttlstran_pipe_send_start_v4(p, msg, txaio);\n\t\telse if (p->tcp_cparam->pro_ver == 5)\n\t\t\ttlstran_pipe_send_start_v5(p, msg, txaio);\n\t\tnni_mtx_unlock(&p->mtx);\n\t\treturn;\n\t}\n\n\tnni_aio_list_remove(aio);\n\ttlstran_pipe_send_start(p);\n\n\tif (msg == NULL) {\n\t\tnni_mtx_unlock(&p->mtx);\n\t\t// msg is lost due to flow control\n\t\tnni_aio_set_msg(aio, NULL);\n\t\tnni_aio_finish_sync(aio, 0, 0);\n\t\treturn;\n\t}\n\n\tn   = nni_msg_len(msg);\n\tcmd = nni_msg_cmd_type(msg);\n\tif (cmd == CMD_CONNACK) {\n\t\theader = nni_msg_header(msg);\n\t\t// parse result code TODO verify bug\n\t\tflag = header[3];\n\t}\n\t// nni_pipe_bump_tx(p->npipe, n);\n\tnni_mtx_unlock(&p->mtx);\n\n\tnni_aio_set_msg(aio, NULL);\n\tnni_msg_free(msg);\n\tif (cmd == CMD_CONNACK && flag != 0x00) {\n\t\tnni_aio_finish_error(aio, flag);\n\t} else if (cmd == CMD_DISCONNECT) {\n\t\tnni_aio_finish_error(aio, NNG_ECLOSED);\n\t} else {\n\t\tnni_aio_finish_sync(aio, 0, n);\n\t}\n}\n\n/*\n * deal with MQTT protocol\n * insure read complete MQTT packet from socket\n */\nstatic void\ntlstran_pipe_recv_cb(void *arg)\n{\n\tnni_aio *     aio;\n\tnni_iov       iov[2];\n\tuint8_t       type;\n\tuint8_t       rv;\n\tuint32_t      pos = 1;\n\tuint64_t      len = 0;\n\tsize_t        n;\n\tnni_msg      *msg, *qmsg;\n\ttlstran_pipe *p     = arg;\n\tnni_aio *     rxaio = p->rxaio;\n\tconn_param *  cparam;\n\tbool          ack   = false;\n\n\tlog_trace(\"tlstran_pipe_recv_cb %p\\n\", p);\n\tnni_mtx_lock(&p->mtx);\n\n\taio = nni_list_first(&p->recvq);\n\n\tif ((rv = nni_aio_result(rxaio)) != 0) {\n\t\tlog_warn(\" recv aio error %s\", nng_strerror(rv));\n\t\trv = NMQ_SERVER_BUSY;\n\t\tgoto recv_error;\n\t}\n\n\tn = nni_aio_count(rxaio);\n\tp->gotrxhead += n;\n\n\tnni_aio_iov_advance(rxaio, n);\n\t// not receive enough bytes, deal with remaining length\n\tlen = get_var_integer(p->rxlen, &pos);\n\tlog_trace(\"new %ld recevied %ld header %x %d pos: %d len : %d\", n,\n\t    p->gotrxhead, p->rxlen[0], p->rxlen[1], pos, len);\n\tlog_trace(\"still need byte count:%ld > 0\\n\", nni_aio_iov_count(rxaio));\n\n\tif (nni_aio_iov_count(rxaio) > 0) {\n\t\tlog_trace(\"got: %x %x, %ld!!\\n\", p->rxlen[0], p->rxlen[1],\n\t\t    strlen((char *) p->rxlen));\n\t\tnng_stream_recv(p->conn, rxaio);\n\t\tnni_mtx_unlock(&p->mtx);\n\t\treturn;\n\t} else if (p->gotrxhead <= NNI_NANO_MAX_HEADER_SIZE &&\n\t    p->rxlen[p->gotrxhead - 1] > 0x7f) {\n\t\t// length error\n\t\tif (p->gotrxhead == NNI_NANO_MAX_HEADER_SIZE) {\n\t\t\trv = NNG_EMSGSIZE;\n\t\t\tgoto recv_error;\n\t\t}\n\t\t// same packet, continue receving next byte of remaining length\n\t\tiov[0].iov_buf = &p->rxlen[p->gotrxhead];\n\t\tiov[0].iov_len = 1;\n\t\tnni_aio_set_iov(rxaio, 1, iov);\n\t\tnng_stream_recv(p->conn, rxaio);\n\t\tnni_mtx_unlock(&p->mtx);\n\t\treturn;\n\t} else if (len == 0 && n == 2) {\n\t\tif ((p->rxlen[0] & 0XFF) == CMD_PINGREQ) {\n\t\t\tnng_aio_wait(p->rpaio);\n\t\t\tp->txlen[0] = CMD_PINGRESP;\n\t\t\tp->txlen[1] = 0x00;\n\t\t\tiov[0].iov_len = 2;\n\t\t\tiov[0].iov_buf = &p->txlen;\n\t\t\t// send it down...\n\t\t\tnni_aio_set_iov(p->rpaio, 1, iov);\n\t\t\tnng_stream_send(p->conn, p->rpaio);\n\t\t\tgoto notify;\n\t\t}\n\t}\n\n\t// finish fixed header\n\tp->wantrxhead = len + p->gotrxhead;\n\tcparam        = p->tcp_cparam;\n\n\tif (p->rxmsg == NULL) {\n\t\t// We should have gotten a message header. len -> remaining\n\t\t// length to define how many bytes left\n\t\tlog_trace(\"pipe %p header got: %x %x %x %x %x, %ld!!\\n\", p,\n\t\t    p->rxlen[0], p->rxlen[1], p->rxlen[2], p->rxlen[3],\n\t\t    p->rxlen[4], p->wantrxhead);\n\t\t// Make sure the message payload is not too big.  If it is\n\t\t// the caller will shut down the pipe.\n\t\tif (len > p->conf->max_packet_size) {\n\t\t\tlog_error(\"size error 0x95\\n\");\n\t\t\trv = NMQ_PACKET_TOO_LARGE;\n\t\t\tgoto recv_error;\n\t\t}\n\n\t\tif ((rv = nni_msg_alloc(&p->rxmsg, (size_t) len)) != 0) {\n\t\t\tlog_error(\"mem error %ld\\n\", (size_t) len);\n\t\t\trv = NMQ_SERVER_UNAVAILABLE;\n\t\t\tgoto recv_error;\n\t\t}\n\n\t\t// Submit the rest of the data for a read -- seperate Fixed\n\t\t// header with variable header and so on\n\t\t//  we want to read the entire message now.\n\t\tif (len != 0) {\n\t\t\tiov[0].iov_buf = nni_msg_body(p->rxmsg);\n\t\t\tiov[0].iov_len = (size_t) len;\n\n\t\t\tnni_aio_set_iov(rxaio, 1, iov);\n\t\t\t// second recv action\n\t\t\tnng_stream_recv(p->conn, rxaio);\n\t\t\tnni_mtx_unlock(&p->mtx);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// We read a message completely.  Let the user know the good news. use\n\t// as application message callback of users\n\tnni_aio_list_remove(aio);\n\tmsg      = p->rxmsg;\n\tp->rxmsg = NULL;\n\tn        = nni_msg_len(msg);\n\ttype     = p->rxlen[0] & 0xf0;\n\n\tfixed_header_adaptor(p->rxlen, msg);\n\tnni_msg_set_conn_param(msg, cparam);\n\t// duplicated with fixed_header_adaptor\n\tnni_msg_set_remaining_len(msg, len);\n\tnni_msg_set_cmd_type(msg, type);\n\tlog_trace(\"remain_len %d cparam %p clientid %s username %s proto %d\\n\",\n\t    len, cparam, cparam->clientid.body, cparam->username.body,\n\t    cparam->pro_ver);\n\n\t// set the payload pointer of msg according to packet_type\n\tlog_trace(\"The type of msg is %x\", type);\n\tuint16_t  packet_id   = 0;\n\tuint8_t   reason_code = 0;\n\tproperty *prop        = NULL;\n\tuint8_t   ack_cmd     = 0;\n\tif (type == CMD_PUBLISH) {\n\t\tnni_msg_set_timestamp(msg, nng_clock());\n\t\tuint8_t qos_pac = nni_msg_get_pub_qos(msg);\n\t\tif (qos_pac > 0) {\n\t\t\t// flow control, check rx_max\n\t\t\t// recv_quota as length of lmq\n\t\t\tif (p->tcp_cparam->pro_ver == 5) {\n\t\t\t\tif (p->qrecv_quota > 0) {\n\t\t\t\t\tp->qrecv_quota--;\n\t\t\t\t} else {\n\t\t\t\t\trv = NMQ_RECEIVE_MAXIMUM_EXCEEDED;\n\t\t\t\t\tgoto recv_error;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (qos_pac == 1) {\n\t\t\t\tack_cmd = CMD_PUBACK;\n\t\t\t} else if (qos_pac == 2) {\n\t\t\t\tack_cmd = CMD_PUBREC;\n\t\t\t}\n\t\t\tpacket_id = nni_msg_get_pub_pid(msg);\n\t\t\tack       = true;\n\t\t}\n\t} else if (type == CMD_PUBREC) {\n\t\tif (nni_mqtt_pubres_decode(msg, &packet_id, &reason_code, &prop,\n\t\t        cparam->pro_ver) != 0) {\n\t\t\tlog_error(\"decode PUBREC variable header failed!\");\n\t\t}\n\t\tack_cmd = CMD_PUBREL;\n\t\tack     = true;\n\t} else if (type == CMD_PUBREL) {\n\t\tif (nni_mqtt_pubres_decode(msg, &packet_id, &reason_code, &prop,\n\t\t        cparam->pro_ver) != 0) {\n\t\t\tlog_error(\"decode PUBREL variable header failed!\");\n\t\t}\n\t\tack_cmd = CMD_PUBCOMP;\n\t\tack     = true;\n\t} else if (type == CMD_PUBACK || type == CMD_PUBCOMP) {\n\t\tif (nni_mqtt_pubres_decode(msg, &packet_id, &reason_code, &prop,\n\t\t        cparam->pro_ver) != 0) {\n\t\t\tlog_error(\"decode PUBACK or PUBCOMP variable header \"\n\t\t\t          \"failed!\");\n\t\t}\n\t\t// MQTT V5 flow control\n\t\tif (p->tcp_cparam->pro_ver == 5) {\n\t\t\tproperty_free(prop);\n\t\t\tp->qsend_quota++;\n\t\t}\n\t}\n\tif (ack == true) {\n\t\t// alloc a msg here costs memory. However we must do it for the\n\t\t// sake of compatibility with nng.\n\t\tif ((rv = nni_msg_alloc(&qmsg, 0)) != 0) {\n\t\t\tack = false;\n\t\t\trv  = NMQ_SERVER_BUSY;\n\t\t\tgoto recv_error;\n\t\t}\n\t\t// TODO set reason code or property here if necessary\n\n\t\tnni_msg_set_cmd_type(qmsg, ack_cmd);\n\t\tnni_mqtt_msgack_encode(\n\t\t    qmsg, packet_id, reason_code, prop, cparam->pro_ver);\n\t\tnni_mqtt_pubres_header_encode(qmsg, ack_cmd);\n\t\t// if (prop != NULL) {\n\t\t// nni_msg_proto_set_property(qmsg, prop);\n\t\t// }\n\t\t// aio_begin?\n\t\tif (p->busy == false) {\n\t\t\t// nni_msg_insert(qmsg, nni_msg_header(qmsg),\n\t\t\t//     nni_msg_header_len(qmsg));\n\t\t\tif (nni_aio_begin(aio) != 0) {\n\t\t\t\tlog_error(\"ACK aio error!!\");\n\t\t\t}\n\t\t\tnni_msg_insert(qmsg, nni_msg_header(qmsg),\n\t\t\t    nni_msg_header_len(qmsg));\n\t\t\tiov[0].iov_len = nni_msg_len(qmsg);\n\t\t\tiov[0].iov_buf = nni_msg_body(qmsg);\n\t\t\tp->busy        = true;\n\t\t\tnni_aio_set_msg(p->qsaio, qmsg);\n\t\t\t// send ACK down...\n\t\t\tnni_aio_set_iov(p->qsaio, 1, iov);\n\t\t\tnng_stream_send(p->conn, p->qsaio);\n\t\t\tlog_trace(\"QoS ACK msg sent!\");\n\t\t} else {\n\t\t\tif (nni_lmq_full(&p->rslmq)) {\n\t\t\t\t// Make space for the new message. TODO add max\n\t\t\t\t// limit of msgq len in conf\n\t\t\t\tif (nni_lmq_cap(&p->rslmq) <=\n\t\t\t\t    NANO_MAX_QOS_PACKET) {\n\t\t\t\t\tif ((rv = nni_lmq_resize(&p->rslmq,\n\t\t\t\t\t         nni_lmq_cap(&p->rslmq) *\n\t\t\t\t\t             2)) == 0) {\n\t\t\t\t\t\tnni_lmq_put(&p->rslmq, qmsg);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// memory error.\n\t\t\t\t\t\tnni_msg_free(qmsg);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tnni_msg *old;\n\t\t\t\t\t(void) nni_lmq_get(&p->rslmq, &old);\n\t\t\t\t\tnni_msg_free(old);\n\t\t\t\t\tnni_lmq_put(&p->rslmq, qmsg);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnni_lmq_put(&p->rslmq, qmsg);\n\t\t\t}\n\t\t}\n\t\tack = false;\n\t}\n\n\t// keep connection & Schedule next receive\n\t// nni_pipe_bump_rx(p->npipe, n);\n\tif (!nni_list_empty(&p->recvq)) {\n\t\ttlstran_pipe_recv_start(p);\n\t}\n\tnni_pipe_bump_rx(p->npipe, n);\n\tnni_mtx_unlock(&p->mtx);\n\n\tnni_aio_set_msg(aio, msg);\n\tnni_aio_finish_sync(aio, 0, n);\n\tlog_trace(\"end of tlstran_pipe_recv_cb: synch! %p\\n\", p);\n\treturn;\n\nrecv_error:\n\tnni_aio_list_remove(aio);\n\tmsg      = p->rxmsg;\n\tp->rxmsg = NULL;\n\tnni_pipe_bump_error(p->npipe, rv);\n\tnni_mtx_unlock(&p->mtx);\n\n\tnni_msg_free(msg);\n\tnni_aio_finish_error(aio, rv);\n\tlog_trace(\"tlstran_pipe_recv_cb: recv error rv: %d\\n\", rv);\n\treturn;\nnotify:\n\t// nni_pipe_bump_rx(p->npipe, n);\n\tnni_aio_list_remove(aio);\n\t// tlstran_pipe_recv_start(p);\n\tnni_mtx_unlock(&p->mtx);\n\tnni_aio_set_msg(aio, NULL);\n\tnni_aio_finish(aio, 0, 0);\n\treturn;\n}\n\nstatic void\ntlstran_pipe_send_cancel(nni_aio *aio, void *arg, int rv)\n{\n\ttlstran_pipe *p = arg;\n\n\tnni_mtx_lock(&p->mtx);\n\tif (!nni_aio_list_active(aio)) {\n\t\tnni_mtx_unlock(&p->mtx);\n\t\treturn;\n\t}\n\t// If this is being sent, then cancel the pending transfer.\n\t// The callback on the txaio will cause the user aio to\n\t// be canceled too.\n\tif (nni_list_first(&p->sendq) == aio) {\n\t\tnni_aio_abort(p->txaio, rv);\n\t\tnni_mtx_unlock(&p->mtx);\n\t\treturn;\n\t}\n\tnni_aio_list_remove(aio);\n\tnni_mtx_unlock(&p->mtx);\n\n\tnni_aio_finish_error(aio, rv);\n}\n\n/**\n * @brief send msg to V4 client\n * \n * @param p \n * @param msg \n */\nstatic inline void\ntlstran_pipe_send_start_v4(tlstran_pipe *p, nni_msg *msg, nni_aio *aio)\n{\n\tnni_aio *txaio;\n\tnni_iov  iov[8];\n\tint      niov = 0;\n\tnni_msg  *tmsg;\n\t// qos default to 0 if the msg is not PUBLISH\n\tuint8_t  qos = 0;\n\n\tif (nni_msg_header_len(msg) <= 0 ||\n\t    nni_msg_get_type(msg) != CMD_PUBLISH) {\n\t\tgoto send;\n\t}\n\n\tbool      is_sqlite = p->conf->sqlite.enable;\n\tint       qlen = 0, topic_len = 0;\n\tsubinfo * tinfo = NULL, *info = NULL;\n\tnni_list *subinfol = p->npipe->subinfol;\n\tchar *    topic    = nni_msg_get_pub_topic(msg, &topic_len);\n\n\ttxaio = p->txaio;\n\ttinfo = nni_aio_get_prov_data(txaio);\n\tnni_aio_set_prov_data(txaio, NULL);\n\n\t// Recomposing for each msg\n\t// never modify the original msg\n\tNNI_LIST_FOREACH(subinfol, info) {\n\t\tif (tinfo != NULL && info != tinfo)\n\t\t\tcontinue;\n\n\t\ttinfo = NULL;\n\n\t\tchar *sub_topic = info->topic;\n\t\tif (sub_topic[0] == '$') {\n\t\t\tif (0 == strncmp(sub_topic, \"$share/\", strlen(\"$share/\"))) {\n\t\t\t\tsub_topic = strchr(sub_topic, '/');\n\t\t\t\tsub_topic++;\n\t\t\t\tsub_topic = strchr(sub_topic, '/');\n\t\t\t\tsub_topic++;\n\t\t\t}\n\t\t}\n\t\tif (false == topic_filtern(sub_topic, topic, topic_len))\n\t\t\tcontinue;\n\t\tif (niov > 4) {\n\t\t\t// donot send too many msgs at a time\n\t\t\tnni_aio_set_prov_data(txaio, info);\n\t\t\tbreak;\n\t\t}\n\n\t\tuint8_t * body, *header, qos_pac;\n\t\tuint8_t   var_extra[2], fixheader, tmp[4] = { 0 };\n\t\tint       len_offset = 0;\n\t\tuint32_t  pos        = 1;\n\t\tnni_pipe *pipe;\n\t\tuint16_t  pid;\n\t\tuint32_t  property_bytes = 0, property_len = 0;\n\t\tsize_t    tlen, rlen, mlen, plength;\n\n\t\tpipe    = p->npipe;\n\t\tbody    = nni_msg_body(msg);\n\t\theader  = nni_msg_header(msg);\n\n\t\tplength = 0;\n\t\tmlen    = nni_msg_len(msg);\n\t\tqos_pac = nni_msg_get_pub_qos(msg);\n\t\tNNI_GET16(body, tlen);\n\n\t\tif (nni_msg_cmd_type(msg) == CMD_PUBLISH_V5) {\n\t\t\t// V5 to V4 shrink msg, remove property length\n\t\t\t// APP layer must give topic name even if topic\n\t\t\t// alias is set\n\t\t\tif (qos_pac > 0) {\n\t\t\t\tproperty_len = get_var_integer(\n\t\t\t\t    body + 4 + tlen, &property_bytes);\n\n\t\t\t} else {\n\t\t\t\tproperty_len = get_var_integer(\n\t\t\t\t    body + 2 + tlen, &property_bytes);\n\t\t\t}\n\t\t\t// V5 msg sent to V4 client\n\t\t\t// caculate property length and delete it\n\n\t\t\tplength = property_len + property_bytes;\n\t\t} else if (nni_msg_cmd_type(msg) == CMD_PUBLISH) {\n\n\t\t\tif (qos_pac == 0) {\n\t\t\t\tif (nni_msg_header_len(msg) > 0) {\n\t\t\t\t\tiov[niov].iov_buf = nni_msg_header(msg);\n\t\t\t\t\tiov[niov].iov_len = nni_msg_header_len(msg);\n\t\t\t\t\tniov++;\n\t\t\t\t}\n\t\t\t\tif (nni_msg_len(msg) > 0) {\n\t\t\t\t\tiov[niov].iov_buf = nni_msg_body(msg);\n\t\t\t\t\tiov[niov].iov_len = nni_msg_len(msg);\n\t\t\t\t\tniov++;\n\t\t\t\t}\n\t\t\t\t// save time & space for QoS 0 publish\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tqos = info->qos;\n\t\tlog_trace(\"qos_pac %d sub %d\\n\", qos_pac, qos);\n\t\tfixheader = *header;\n\t\t// get final qos\n\t\tqos = qos_pac > qos ? qos : qos_pac;\n\n\t\t// alter qos according to sub qos\n\t\tif (qos_pac > qos) {\n\t\t\tif (qos == 1) {\n\t\t\t\t// set qos to 1\n\t\t\t\tfixheader = fixheader & 0xF9;\n\t\t\t\tfixheader = fixheader | 0x02;\n\t\t\t} else {\n\t\t\t\t// set qos to 0\n\t\t\t\tfixheader = fixheader & 0xF9;\n\t\t\t\tlen_offset   = len_offset - 2;\n\t\t\t}\n\t\t}\n\t\t// copy remaining length\n\t\trlen = put_var_integer(\n\t\t    tmp, get_var_integer(header, &pos) + len_offset - plength);\n\t\t*(p->qos_buf + qlen) = fixheader;\n\t\t//rlen : max 4 bytes\n\t\tmemcpy(p->qos_buf+1+qlen, tmp, rlen);\n\n\t\t// 1st part of variable header: topic\n\t\tlen_offset = 0;      // now use it to indicates the pid length\n\t\t// packet id\n\t\tif (qos > 0) {\n\t\t\t// set pid\n\t\t\tlen_offset = 2;\n\t\t\tnni_msg *old;\n\t\t\t// to differ resend msg\n\t\t\tpid = (uint16_t)(size_t) nni_aio_get_prov_data(aio);\n\t\t\tif (pid == 0) {\n\t\t\t\t// first time send this msg\n\t\t\t\tpid = nni_pipe_inc_packetid(pipe);\n\t\t\t\t// store msg for qos retrying\n\t\t\t\tnni_msg_clone(msg);\n\t\t\t\tif ((old = nni_qos_db_get(is_sqlite,\n\t\t\t\t         pipe->nano_qos_db, pipe->p_id,\n\t\t\t\t         pid)) != NULL) {\n\t\t\t\t\t// TODO packetid already exists.\n\t\t\t\t\t// do we need to replace old with new\n\t\t\t\t\t// one ? print warning to users\n\t\t\t\t\tlog_error(\"packet id duplicates in \"\n\t\t\t\t\t          \"nano_qos_db\");\n\n\t\t\t\t\tnni_qos_db_remove_msg(is_sqlite,\n\t\t\t\t\t    pipe->nano_qos_db, old);\n\t\t\t\t}\n\t\t\t\told = msg;\n\t\t\t\tnni_qos_db_set(is_sqlite, pipe->nano_qos_db,\n\t\t\t\t    pipe->p_id, pid, old);\n\t\t\t\tnni_qos_db_remove_oldest(is_sqlite,\n\t\t\t\t    pipe->nano_qos_db,\n\t\t\t\t    p->conf->sqlite.disk_cache_size);\n\t\t\t}\n\t\t\tNNI_PUT16(var_extra, pid);\n\t\t} else if (qos_pac > 0) {\n\t\t\tlen_offset += 2;\n\t\t}\n\t\t// fixed header\n\t\tiov[niov].iov_buf = p->qos_buf+qlen;\n\t\tiov[niov].iov_len = 1+rlen;\n\t\tniov++;\n\t\tqlen += rlen + 1;\n\t\t// topic + tlen\n\t\tiov[niov].iov_buf = body;\n\t\tiov[niov].iov_len = 2+tlen;\n\t\tniov++;\n\t\t// packet id if any\n\t\tif (qos > 0) {\n\t\t\t// copy packet id\n\t\t\tmemcpy(p->qos_buf + 5 + qlen, var_extra, 2);\n\t\t\tiov[niov].iov_buf = p->qos_buf + 5 + qlen;\n\t\t\tiov[niov].iov_len = 2;\n\t\t\tniov++;\n\t\t\tqlen += 2;\n\t\t}\n\t\t// variable header + payload\n\t\tif (mlen > 0) {\n\t\t\t// determine if it needs to skip packet id field\n\t\t\tiov[niov].iov_buf =\n\t\t\t    body + 2 + tlen + len_offset + plength;\n\t\t\tiov[niov].iov_len =\n\t\t\t    mlen - 2 - len_offset - tlen - plength;\n\t\t\tniov++;\n\t\t}\n\t}\n\n\tnni_msg_alloc(&tmsg, 0);\n\t// apending directly\n\tfor (int i = 0; i < niov; i++) {\n\t\tnni_msg_append(tmsg, iov[i].iov_buf, iov[i].iov_len);\n\t}\n\t// tls_common only send 1 iov each time\n\t// to avoid of racing we alloc a new msg for tls\n\tiov[0].iov_buf = nni_msg_body(tmsg);\n\tiov[0].iov_len = nni_msg_len(tmsg);\n\tnni_aio_set_msg(txaio, tmsg);\n\tnni_aio_set_iov(txaio, 1, iov);\n\n\tnng_stream_send(p->conn, txaio);\n\treturn;\n\nsend:\n\t// have to alloc new msg due to TLS doesn't support scatter\n\tnni_msg_alloc(&tmsg, 0);\n\ttxaio = p->txaio;\n\tniov  = 0;\n\n\tif (nni_msg_header_len(msg) > 0) {\n\t\tnni_msg_append(\n\t\t    tmsg, nni_msg_header(msg), nni_msg_header_len(msg));\n\t}\n\tif (nni_msg_len(msg) > 0) {\n\t\tnni_msg_append(tmsg, nni_msg_body(msg), nni_msg_len(msg));\n\t}\n\tiov[0].iov_buf = nni_msg_body(tmsg);\n\tiov[0].iov_len = nni_msg_len(tmsg);\n\tnni_aio_set_msg(txaio, tmsg);\n\tnni_aio_set_iov(txaio, 1, iov);\n\tnng_stream_send(p->conn, txaio);\n}\n\n/**\n * @brief we consider memory saving is prior to performance due\n * \t  to the requirement of our boss. so we use fragmented iov.\n * \n * @param p \n * @param msg \n * @param aio \n */\nstatic inline void\ntlstran_pipe_send_start_v5(tlstran_pipe *p, nni_msg *msg, nni_aio *aio)\n{\n\tnni_aio  *txaio;\n\tnni_pipe *pipe = p->npipe;\n\tint       niov;\n\tnni_iov   iov[8];\n\tnni_msg  *tmsg;\n\n\tif (nni_msg_get_type(msg) != CMD_PUBLISH)\n\t\tgoto send;\n\t// never modify the original msg\n\n\tuint8_t *     body, *header, qos_pac;\n\ttarget_prover target_prover;\n\tint           len_offset = 0, sub_id = 0, qos = 0;\n\tuint16_t      pid;\n\tuint32_t tprop_bytes, prop_bytes = 0, id_bytes = 0, property_len = 0;\n\tsize_t   tlen, rlen, mlen, hlen, qlength, plength;\n\n\tbool is_sqlite = p->conf->sqlite.enable;\n\n\ttxaio   = p->txaio;\n\tbody    = nni_msg_body(msg);\n\theader  = nni_msg_header(msg);\n\tniov    = 0;\n\tqlength = 0;\n\tplength = 0;\n\tmlen    = nni_msg_len(msg);\n\thlen    = nni_msg_header_len(msg);\n\tqos_pac = nni_msg_get_pub_qos(msg);\n\tNNI_GET16(body, tlen);\n\n\t// check max packet size for this client/msg\n\tuint32_t total_len = mlen + hlen;\n\tif (total_len > p->tcp_cparam->max_packet_size) {\n\t\t// drop msg and finish aio\n\t\t// pretend it has been sent\n\t\tlog_warn(\"msg dropped due to overceed max packet size!\");\n\t\tnni_msg_free(msg);\n\t\tnni_aio_set_msg(aio, NULL);\n\t\tnni_aio_finish(aio, 0, 0);\n\t\treturn;\n\t}\n\tif (nni_msg_cmd_type(msg) == CMD_PUBLISH_V5) {\n\t\tif (qos_pac > 0) {\n\t\t\tproperty_len =\n\t\t\t    get_var_integer(body + 4 + tlen, &prop_bytes);\n\t\t} else {\n\t\t\tproperty_len =\n\t\t\t    get_var_integer(body + 2 + tlen, &prop_bytes);\n\t\t}\n\t\ttarget_prover = MQTTV5;\n\t\ttprop_bytes = prop_bytes;\n\t}\n\t// subid\n\tsubinfo *info, *tinfo;\n\ttinfo = nni_aio_get_prov_data(txaio);\n\tnni_aio_set_prov_data(txaio, NULL);\n\tNNI_LIST_FOREACH (p->npipe->subinfol, info) {\n\t\tif (tinfo != NULL && info != tinfo ) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (info->no_local == 1 && p->npipe->p_id == nni_msg_get_pipe(msg)) {\n\t\t\tcontinue;\n\t\t}\n\t\ttinfo = NULL;\n\t\tlen_offset=0;\n\t\tchar *sub_topic = info->topic;\n\t\tif (sub_topic[0] == '$') {\n\t\t\tif (0 == strncmp(sub_topic, \"$share/\", strlen(\"$share/\"))) {\n\t\t\t\tsub_topic = strchr(sub_topic, '/');\n\t\t\t\tsub_topic++;\n\t\t\t\tsub_topic = strchr(sub_topic, '/');\n\t\t\t\tsub_topic++;\n\t\t\t}\n\t\t}\n\t\tif (topic_filtern(sub_topic, (char*)(body + 2), tlen)) {\n\t\t\tif (niov >= 8) {\n\t\t\t\t// nng aio only allow 2 msgs at a time\n\t\t\t\tnni_aio_set_prov_data(txaio, info);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tuint8_t  var_extra[2], fixheader, tmp[4] = { 0 };\n\t\t\tuint8_t  proplen[4] = { 0 }, var_subid[5] = { 0 };\n\t\t\tuint32_t pos = 1;\n\t\t\tsub_id       = info->subid;\n\t\t\tqos          = info->qos;\n\n\t\t\tfixheader = *header;\n\t\t\tif (nni_msg_cmd_type(msg) == CMD_PUBLISH) {\n\t\t\t\t// V4 to V5 add 0 property length\n\t\t\t\ttarget_prover = MQTTV4_V5;\n\t\t\t\tprop_bytes    = 1;\n\t\t\t\ttprop_bytes   = 1;\n\t\t\t\tlen_offset    = 1;\n\t\t\t}\n\t\t\tif (info->rap == 0) {\n\t\t\t\tfixheader = fixheader & 0xFE;\n\t\t\t}\n\t\t\tif (sub_id != 0) {\n\t\t\t\tvar_subid[0] = 0x0B;\n\t\t\t\tid_bytes = put_var_integer(var_subid+1, sub_id);\n\t\t\t\ttprop_bytes = put_var_integer(proplen, property_len+1+id_bytes);\n\t\t\t\tlen_offset += (tprop_bytes - prop_bytes + 1 + id_bytes);\n\t\t\t}\n\t\t\t// get final qos\n\t\t\tqos = qos_pac > qos ? qos : qos_pac;\n\n\t\t\t// alter qos according to sub qos\n\t\t\tif (qos_pac > qos) {\n\t\t\t\tif (qos == 1) {\n\t\t\t\t\t// set qos to 1\n\t\t\t\t\tfixheader = fixheader & 0xF9;\n\t\t\t\t\tfixheader = fixheader | 0x02;\n\t\t\t\t} else {\n\t\t\t\t\t// set qos to 0\n\t\t\t\t\tfixheader = fixheader & 0xF9;\n\t\t\t\t\tlen_offset   = len_offset - 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// fixed header + remaining length\n\t\t\tpos=1;\n\t\t\trlen = put_var_integer(\n\t\t\t    tmp, get_var_integer(header, &pos) + len_offset);\n\t\t\t// or just copy to qosbuf directly?\n\t\t\t*(p->qos_buf + qlength) = fixheader;\n\t\t\tmemcpy(p->qos_buf + qlength + 1, tmp, rlen);\n\t\t\tiov[niov].iov_buf = p->qos_buf + qlength;\n\t\t\tiov[niov].iov_len = rlen + 1;\n\t\t\tniov++;\n\t\t\tqlength += rlen + 1;\n\t\t\t// 1st part of variable header: topic + topic len\n\t\t\tiov[niov].iov_buf = body;\n\t\t\tiov[niov].iov_len = tlen+2;\n\t\t\tniov++;\n\t\t\t// len to indicate the offset in packet\n\t\t\tlen_offset = 0;\n\t\t\tplength = 0;\n\t\t\tif (qos > 0) {\n\t\t\t\t// set pid\n\t\t\t\tlen_offset = 2;\n\t\t\t\tnni_msg *old;\n\t\t\t\t// packetid in aio to differ resend msg\n\t\t\t\t// TODO replace it with set prov data/pipe\n\t\t\t\tpid = (uint16_t)(size_t) nni_aio_get_prov_data(aio);\n\t\t\t\tif (pid == 0) {\n\t\t\t\t\t// first time send this msg\n\t\t\t\t\tpid = nni_pipe_inc_packetid(pipe);\n\t\t\t\t\t// store msg for qos retrying\n\t\t\t\t\tnni_msg_clone(msg);\n\t\t\t\t\tif ((old = nni_qos_db_get(is_sqlite,\n\t\t\t\t\t         pipe->nano_qos_db, pipe->p_id,\n\t\t\t\t\t         pid)) != NULL) {\n\t\t\t\t\t\t// TODO packetid already\n\t\t\t\t\t\t// exists. do we need to\n\t\t\t\t\t\t// replace old with new one ?\n\t\t\t\t\t\t// print warning to users\n\t\t\t\t\t\tnni_println(\"ERROR: packet id \"\n\t\t\t\t\t\t            \"duplicates in \"\n\t\t\t\t\t\t            \"nano_qos_db\");\n\n\t\t\t\t\t\tnni_qos_db_remove_msg(\n\t\t\t\t\t\t    is_sqlite,\n\t\t\t\t\t\t    pipe->nano_qos_db, old);\n\t\t\t\t\t}\n\t\t\t\t\told = msg;\n\t\t\t\t\tnni_qos_db_set(is_sqlite,\n\t\t\t\t\t    pipe->nano_qos_db, pipe->p_id, pid,\n\t\t\t\t\t    old);\n\t\t\t\t\tnni_qos_db_remove_oldest(is_sqlite,\n\t\t\t\t\t    pipe->nano_qos_db,\n\t\t\t\t\t    p->conf->sqlite.disk_cache_size);\n\t\t\t\t}\n\t\t\t\tNNI_PUT16(var_extra, pid);\n\t\t\t\t// copy packet id\n\t\t\t\tmemcpy(p->qos_buf + qlength, var_extra, 2);\n\t\t\t\tqlength += 2;\n\t\t\t\tplength += 2;\n\t\t\t} else if (qos_pac > 0) {\n\t\t\t\t//ignore the packet id of original packet\n\t\t\t\tlen_offset += 2;\n\t\t\t}\n\t\t\t// prop len + sub id if any\n\t\t\tif (sub_id != 0) {\n\t\t\t\tmemcpy(p->qos_buf + qlength, proplen,\n\t\t\t\t    tprop_bytes);\n\t\t\t\tqlength += tprop_bytes;\n\t\t\t\tplength += tprop_bytes;\n\t\t\t\tmemcpy(p->qos_buf + qlength, var_subid,\n\t\t\t\t    id_bytes + 1);\n\t\t\t\tqlength += id_bytes + 1;\n\t\t\t\tplength += id_bytes + 1;\n\t\t\t\tif (target_prover == MQTTV5)\n\t\t\t\t\tlen_offset += prop_bytes;\n\t\t\t} else {\n\t\t\t\t//need to add 0 len for V4 msg\n\t\t\t\tif (target_prover == MQTTV4_V5) {\n\t\t\t\t\t// add proplen even 0\n\t\t\t\t\tmemcpy(p->qos_buf + qlength, proplen,\n\t\t\t\t\t    tprop_bytes);\n\t\t\t\t\tqlength += tprop_bytes;\n\t\t\t\t\tplength += tprop_bytes;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 2nd part of variable header: pid + proplen+0x0B+subid\n\t\t\tiov[niov].iov_buf = p->qos_buf+qlength-plength;\n\t\t\tiov[niov].iov_len = plength;\n\t\t\tniov++;\n\t\t\t// prop + body\n\t\t\tiov[niov].iov_buf = body + 2 + tlen + len_offset;\n\t\t\tiov[niov].iov_len = mlen - 2 - len_offset - tlen;\n\t\t\tniov++;\n\t\t}\n\t}\n\n\t// MQTT V5 flow control\n\tif (qos > 0) {\n\t\tif (p->qsend_quota > 0) {\n\t\t\tp->qsend_quota--;\n\t\t} else {\n\t\t\t// what should broker does when exceed\n\t\t\t// max_recv? msg lost, make it look like a\n\t\t\t// normal send. qos msg will be resend\n\t\t\t// afterwards\n\t\t\tnni_msg_free(msg);\n\t\t\tnni_aio_set_prov_data(txaio, NULL);\n\t\t\tnni_list_remove(&p->sendq, aio);\n\t\t\tnni_aio_set_msg(aio, NULL);\n\t\t\tnni_aio_finish(aio, 0, 0);\n\t\t\treturn;\n\t\t}\n\t}\n\tif (niov == 0) {\n\t\t// No content to send\n\t\tnni_msg_free(msg);\n\t\tnni_aio_set_prov_data(txaio, NULL);\n\t\tnni_list_remove(&p->sendq, aio);\n\t\tnni_aio_set_msg(aio, NULL);\n\t\tnni_aio_finish(aio, 0, 0);\n\t\treturn;\n\t}\n\tnni_msg_alloc(&tmsg, 0);\n\t// apending directly\n\tfor (int i = 0; i < niov; i++) {\n\t\tnni_msg_append(tmsg, iov[i].iov_buf, iov[i].iov_len);\n\t}\n\t// tls_common only send 1 iov each time\n\t// to avoid of racing we alloc a new msg for tls\n\tiov[0].iov_buf = nni_msg_body(tmsg);\n\tiov[0].iov_len = nni_msg_len(tmsg);\n\tnni_aio_set_msg(txaio, tmsg);\n\tnni_aio_set_iov(txaio, 1, iov);\n\n\tnng_stream_send(p->conn, txaio);\n\treturn;\n\nsend:\n\t// have to alloc new msg due to TLS doesn't support scatter\n\tnni_msg_alloc(&tmsg, 0);\n\ttxaio = p->txaio;\n\tniov  = 0;\n\n\tif (nni_msg_header_len(msg) > 0) {\n\t\tnni_msg_append(\n\t\t    tmsg, nni_msg_header(msg), nni_msg_header_len(msg));\n\t}\n\tif (nni_msg_len(msg) > 0) {\n\t\tnni_msg_append(tmsg, nni_msg_body(msg), nni_msg_len(msg));\n\t}\n\tiov[0].iov_buf = nni_msg_body(tmsg);\n\tiov[0].iov_len = nni_msg_len(tmsg);\n\tnni_aio_set_msg(txaio, tmsg);\n\tnni_aio_set_iov(txaio, 1, iov);\n\tnng_stream_send(p->conn, txaio);\n}\n\n/**\n * @brief this is the func that responsible for sending msg while\n *        keeping zero-copy feature, doing all the jobs neccesary\n *        for each unique client (it means ugly)\n * //TODO break it into 2 pieces V4 / V5\n *\n * @param p tcptran_pipe\n */\nstatic void\ntlstran_pipe_send_start(tlstran_pipe *p)\n{\n\tnni_aio *aio;\n\tnni_msg *msg;\n\n\tlog_trace(\"########### tlstran_pipe_send_start ###########\");\n\tif (p->closed) {\n\t\twhile ((aio = nni_list_first(&p->sendq)) != NULL) {\n\t\t\tnni_list_remove(&p->sendq, aio);\n\t\t\tnni_aio_finish_error(aio, NNG_ECLOSED);\n\t\t}\n\t\treturn;\n\t}\n\n\tif ((aio = nni_list_first(&p->sendq)) == NULL) {\n\t\tlog_trace(\"aio not functioning\");\n\t\treturn;\n\t}\n\n\t// This runs to send the message.\n\tmsg = nni_aio_get_msg(aio);\n\tif (msg == NULL || p->tcp_cparam == NULL) {\n\t\t// TODO error handler\n\t\tnni_println(\"ERROR: sending NULL msg or pipe is invalid!\");\n\t\tnni_aio_finish(aio, NNG_ECANCELED, 0);\n\t\treturn;\n\t}\n\tif (p->tcp_cparam->pro_ver == 4) {\n\t\ttlstran_pipe_send_start_v4(p, msg, aio);\n\t} else if (p->tcp_cparam->pro_ver == 5) {\n\t\ttlstran_pipe_send_start_v5(p, msg, aio);\n\t}\n\treturn;\n}\n\nstatic void\ntlstran_pipe_send(void *arg, nni_aio *aio)\n{\n\ttlstran_pipe *p = arg;\n\tint           rv;\n\n\tlog_trace(\"####################tlstran_pipe_send###########\");\n\tif (nni_aio_begin(aio) != 0) {\n\t\treturn;\n\t}\n\tnni_mtx_lock(&p->mtx);\n\tif ((rv = nni_aio_schedule(aio, tlstran_pipe_send_cancel, p)) != 0) {\n\t\tnni_mtx_unlock(&p->mtx);\n\t\tnni_aio_finish_error(aio, rv);\n\t\treturn;\n\t}\n\tnni_list_append(&p->sendq, aio);\n\tif (nni_list_first(&p->sendq) == aio) {\n\t\t// send publish msg or send others\n\t\ttlstran_pipe_send_start(p);\n\t}\n\tnni_mtx_unlock(&p->mtx);\n}\n\nstatic void\ntlstran_pipe_recv_cancel(nni_aio *aio, void *arg, int rv)\n{\n\ttlstran_pipe *p = arg;\n\n\tnni_mtx_lock(&p->mtx);\n\tif (!nni_aio_list_active(aio)) {\n\t\tnni_mtx_unlock(&p->mtx);\n\t\treturn;\n\t}\n\t// If receive in progress, then cancel the pending transfer.\n\t// The callback on the rxaio will cause the user aio to\n\t// be canceled too.\n\tif (nni_list_first(&p->recvq) == aio) {\n\t\tnni_aio_abort(p->rxaio, rv);\n\t\tnni_mtx_unlock(&p->mtx);\n\t\treturn;\n\t}\n\tnni_aio_list_remove(aio);\n\tnni_mtx_unlock(&p->mtx);\n\tnni_aio_finish_error(aio, rv);\n}\n\nstatic void\ntlstran_pipe_recv(void *arg, nni_aio *aio)\n{\n\ttlstran_pipe *p = arg;\n\tint           rv;\n\n\tif (nni_aio_begin(aio) != 0) {\n\t\treturn;\n\t}\n\tnni_mtx_lock(&p->mtx);\n\tif ((rv = nni_aio_schedule(aio, tlstran_pipe_recv_cancel, p)) != 0) {\n\t\tnni_mtx_unlock(&p->mtx);\n\t\tnni_aio_finish_error(aio, rv);\n\t\treturn;\n\t}\n\n\t// if (nni_aio_list_active(aio) == 0) {\n\tnni_list_append(&p->recvq, aio);\n\t// }\n\n\tif (nni_list_first(&p->recvq) == aio) {\n\t\ttlstran_pipe_recv_start(p);\n\t}\n\tnni_mtx_unlock(&p->mtx);\n}\n\nstatic int\ntlstran_pipe_getopt(\n    void *arg, const char *name, void *buf, size_t *szp, nni_type t)\n{\n\ttlstran_pipe *p = arg;\n\treturn (nni_stream_get(p->conn, name, buf, szp, t));\n}\n\nstatic void\ntlstran_pipe_recv_start(tlstran_pipe *p)\n{\n\tnni_aio *rxaio;\n\tnni_iov  iov;\n\tlog_trace(\"*** tlstran_pipe_recv_start ***\\n\");\n\n\tif (p->closed) {\n\t\tnni_aio *aio;\n\t\twhile ((aio = nni_list_first(&p->recvq)) != NULL) {\n\t\t\tnni_list_remove(&p->recvq, aio);\n\t\t\tnni_aio_finish_error(aio, NNG_ECLOSED);\n\t\t}\n\t\treturn;\n\t}\n\tif (nni_list_empty(&p->recvq)) {\n\t\treturn;\n\t}\n\n\t// Schedule a read of the fixed header.\n\trxaio         = p->rxaio;\n\tp->gotrxhead  = 0;\n\tp->wantrxhead = NANO_MIN_FIXED_HEADER_LEN;\n\tiov.iov_buf   = p->rxlen;\n\tiov.iov_len   = NANO_MIN_FIXED_HEADER_LEN;\n\tnni_aio_set_iov(rxaio, 1, &iov);\n\tnng_stream_recv(p->conn, rxaio);\n}\n\n// DEAL WITH CONNECT when PIPE INIT\nstatic void\ntlstran_pipe_start(tlstran_pipe *p, nng_stream *conn, tlstran_ep *ep)\n{\n\tnni_iov iov;\n\t// nni_tcp_conn *c;\n\n\tep->refcnt++;\n\n\tp->conn = conn;\n\tp->ep   = ep;\n\tp->conf = ep->conf;\n\t// p->proto = ep->proto;\n\n\tlog_trace(\"tlstran_pipe_start!\");\n\tp->qrecv_quota = NANO_MAX_QOS_PACKET;\n\tp->gotrxhead  = 0;\n\tp->wantrxhead = NANO_CONNECT_PACKET_LEN; // packet type 1 + remaining\n\t                                         // length 1 + protocal name 7\n\t                                         // + flag 1 + keepalive 2 = 12\n\tiov.iov_len = NNI_NANO_MAX_HEADER_SIZE;  // dynamic\n\tiov.iov_buf = p->rxlen;\n\n\tnni_aio_set_iov(p->negoaio, 1, &iov);\n\tnni_list_append(&ep->negopipes, p);\n\n\tnni_aio_set_timeout(p->negoaio,\n\t    15 * 1000); // 15 sec timeout to negotiate abide with emqx\n\tnng_stream_recv(p->conn, p->negoaio);\n}\n\nstatic void\ntlstran_ep_fini(void *arg)\n{\n\ttlstran_ep *ep = arg;\n\n\tnni_mtx_lock(&ep->mtx);\n\tep->fini = true;\n\tif (ep->refcnt != 0) {\n\t\tnni_mtx_unlock(&ep->mtx);\n\t\treturn;\n\t}\n\tnni_mtx_unlock(&ep->mtx);\n\tnni_aio_stop(ep->timeaio);\n\tnni_aio_stop(ep->connaio);\n\tnng_stream_listener_free(ep->listener);\n\tnni_aio_free(ep->timeaio);\n\tnni_aio_free(ep->connaio);\n\n\tnni_mtx_fini(&ep->mtx);\n\tNNI_FREE_STRUCT(ep);\n}\n\nstatic void\ntlstran_ep_close(void *arg)\n{\n\ttlstran_ep *  ep = arg;\n\ttlstran_pipe *p;\n\n\tnni_mtx_lock(&ep->mtx);\n\n\tlog_trace(\"tlstran_ep_close\");\n\tep->closed = true;\n\tnni_aio_close(ep->timeaio);\n\tif (ep->listener != NULL) {\n\t\tnng_stream_listener_close(ep->listener);\n\t}\n\tNNI_LIST_FOREACH (&ep->negopipes, p) {\n\t\ttlstran_pipe_close(p);\n\t}\n\tNNI_LIST_FOREACH (&ep->waitpipes, p) {\n\t\ttlstran_pipe_close(p);\n\t}\n\tNNI_LIST_FOREACH (&ep->busypipes, p) {\n\t\ttlstran_pipe_close(p);\n\t}\n\tif (ep->useraio != NULL) {\n\t\tnni_aio_finish_error(ep->useraio, NNG_ECLOSED);\n\t\tep->useraio = NULL;\n\t}\n\n\tnni_mtx_unlock(&ep->mtx);\n}\n\n// This parses off the optional source address that this transport uses.\n// The special handling of this URL format is quite honestly an historical\n// mistake, which we would remove if we could.static int\nint\ntlstran_url_parse_source(nng_url *url, nng_sockaddr *sa, const nng_url *surl)\n{\n\tint      af;\n\tchar *   semi;\n\tchar *   src;\n\tsize_t   len;\n\tint      rv;\n\tnni_aio *aio;\n\n\t// We modify the URL.  This relies on the fact that the underlying\n\t// transport does not free this, so we can just use references.\n\n\turl->u_scheme   = surl->u_scheme;\n\turl->u_port     = surl->u_port;\n\turl->u_hostname = surl->u_hostname;\n\n\tif ((semi = strchr(url->u_hostname, ';')) == NULL) {\n\t\tmemset(sa, 0, sizeof(*sa));\n\t\treturn (0);\n\t}\n\n\tlen             = (size_t)(semi - url->u_hostname);\n\turl->u_hostname = semi + 1;\n\n\tif (strcmp(surl->u_scheme, \"tls+tcp\") == 0) {\n\t\taf = NNG_AF_UNSPEC;\n\t} else if (strcmp(surl->u_scheme, \"tls+tcp4\") == 0) {\n\t\taf = NNG_AF_INET;\n\t} else if (strcmp(surl->u_scheme, \"tls+tcp6\") == 0) {\n\t\taf = NNG_AF_INET6;\n\t} else {\n\t\treturn (NNG_EADDRINVAL);\n\t}\n\n\tif ((src = nni_alloc(len + 1)) == NULL) {\n\t\treturn (NNG_ENOMEM);\n\t}\n\tmemcpy(src, surl->u_hostname, len);\n\tsrc[len] = '\\0';\n\n\tif ((rv = nni_aio_alloc(&aio, NULL, NULL)) != 0) {\n\t\tnni_free(src, len + 1);\n\t\treturn (rv);\n\t}\n\n\tnni_resolv_ip(src, \"0\", af, true, sa, aio);\n\tnni_aio_wait(aio);\n\trv = nni_aio_result(aio);\n\tnni_aio_free(aio);\n\tnni_free(src, len + 1);\n\treturn (rv);\n}\n\nstatic void\ntlstran_timer_cb(void *arg)\n{\n\ttlstran_ep *ep = arg;\n\tif (nni_aio_result(ep->timeaio) == 0) {\n\t\tnng_stream_listener_accept(ep->listener, ep->connaio);\n\t}\n}\n\n// TLS accpet trigger\nstatic void\ntlstran_accept_cb(void *arg)\n{\n\ttlstran_ep *  ep  = arg;\n\tnni_aio *     aio = ep->connaio;\n\ttlstran_pipe *p;\n\tint           rv;\n\tnng_stream *  conn;\n\n\tnni_mtx_lock(&ep->mtx);\n\n\tif ((rv = nni_aio_result(aio)) != 0) {\n\t\tlog_warn(\" send aio error %s\", nng_strerror(rv));\n\t\tgoto error;\n\t}\n\n\tconn = nni_aio_get_output(aio, 0);\n\tif ((rv = tlstran_pipe_alloc(&p)) != 0) {\n\t\tnng_stream_free(conn);\n\t\tgoto error;\n\t}\n\n\tif (ep->closed) {\n\t\ttlstran_pipe_fini(p);\n\t\tnng_stream_free(conn);\n\t\trv = NNG_ECLOSED;\n\t\tgoto error;\n\t}\n\ttlstran_pipe_start(p, conn, ep);\n\tnng_stream_listener_accept(ep->listener, ep->connaio);\n\tnni_mtx_unlock(&ep->mtx);\n\treturn;\n\nerror:\n\t// When an error here occurs, let's send a notice up to the consumer.\n\t// That way it can be reported properly.\n\tif ((aio = ep->useraio) != NULL) {\n\t\tep->useraio = NULL;\n\t\tnni_aio_finish_error(aio, rv);\n\t}\n\tswitch (rv) {\n\n\tcase NNG_ENOMEM:\n\tcase NNG_ENOFILES:\n\t\tnng_sleep_aio(10, ep->timeaio);\n\t\tbreak;\n\n\tdefault:\n\t\tif (!ep->closed) {\n\t\t\tnng_stream_listener_accept(ep->listener, ep->connaio);\n\t\t}\n\t\tbreak;\n\t}\n\tnni_mtx_unlock(&ep->mtx);\n}\n\nstatic int\ntlstran_ep_init(tlstran_ep **epp, nng_url *url, nni_sock *sock)\n{\n\ttlstran_ep *ep;\n\tNNI_ARG_UNUSED(sock);\n\n\tif ((ep = NNI_ALLOC_STRUCT(ep)) == NULL) {\n\t\treturn (NNG_ENOMEM);\n\t}\n\tnni_mtx_init(&ep->mtx);\n\tNNI_LIST_INIT(&ep->busypipes, tlstran_pipe, node);\n\tNNI_LIST_INIT(&ep->waitpipes, tlstran_pipe, node);\n\tNNI_LIST_INIT(&ep->negopipes, tlstran_pipe, node);\n\n\t// ep->proto = nni_sock_proto_id(sock);\n\tep->url = url;\n#ifdef NNG_ENABLE_STATS\n\tstatic const nni_stat_info rcv_max_info = {\n\t\t.si_name   = \"rcv_max\",\n\t\t.si_desc   = \"maximum receive size\",\n\t\t.si_type   = NNG_STAT_LEVEL,\n\t\t.si_unit   = NNG_UNIT_BYTES,\n\t\t.si_atomic = true,\n\t};\n\tnni_stat_init(&ep->st_rcv_max, &rcv_max_info);\n#endif\n\n\t*epp = ep;\n\treturn (0);\n}\n\nstatic int\ntlstran_ep_init_listener(void **lp, nng_url *url, nni_listener *nlistener)\n{\n\ttlstran_ep *ep;\n\tuint16_t    af;\n\tchar *      host = url->u_hostname;\n\tnni_aio *   aio;\n\tint         rv;\n\tnni_sock *  sock = nni_listener_sock(nlistener);\n\n\tif (strcmp(url->u_scheme, \"tls+nmq-tcp\") == 0) {\n\t\taf = NNG_AF_UNSPEC;\n\t} else if (strcmp(url->u_scheme, \"tls+nmq-tcp4\") == 0) {\n\t\taf = NNG_AF_INET;\n\t} else if (strcmp(url->u_scheme, \"tls+nmq-tcp6\") == 0) {\n\t\taf = NNG_AF_INET6;\n\t} else {\n\t\treturn (NNG_EADDRINVAL);\n\t}\n\t// Check for invalid URL components.\n\tif ((strlen(url->u_path) != 0) && (strcmp(url->u_path, \"/\") != 0)) {\n\t\treturn (NNG_EADDRINVAL);\n\t}\n\tif ((url->u_fragment != NULL) || (url->u_userinfo != NULL) ||\n\t    (url->u_query != NULL)) {\n\t\treturn (NNG_EADDRINVAL);\n\t}\n\n\tif (((rv = tlstran_ep_init(&ep, url, sock)) != 0) ||\n\t    ((rv = nni_aio_alloc(&ep->connaio, tlstran_accept_cb, ep)) != 0) ||\n\t    ((rv = nni_aio_alloc(&ep->timeaio, tlstran_timer_cb, ep)) != 0)) {\n\t\treturn (rv);\n\t}\n\n\tep->authmode = NNG_TLS_AUTH_MODE_NONE;\n\n\tif (strlen(host) == 0) {\n\t\thost = NULL;\n\t}\n\n\t// XXX: We are doing lookup at listener initialization.  There\n\t// is a valid argument that this should be done at bind time,\n\t// but that would require making bind asynchronous.  In some\n\t// ways this would be worse than the cost of just waiting here.\n\t// We always recommend using local IP addresses rather than\n\t// names when possible.\n\n\tif ((rv = nni_aio_alloc(&aio, NULL, NULL)) != 0) {\n\t\ttlstran_ep_fini(ep);\n\t\treturn (rv);\n\t}\n\tnni_resolv_ip(host, url->u_port, af, true, &ep->sa, aio);\n\tnni_aio_wait(aio);\n\trv = nni_aio_result(aio);\n\tnni_aio_free(aio);\n\n\tif ((rv != 0) ||\n\t    ((rv = nng_stream_listener_alloc_url(&ep->listener, url)) != 0) ||\n\t    ((rv = nni_stream_listener_set(ep->listener, NNG_OPT_TLS_AUTH_MODE,\n\t          &ep->authmode, sizeof(ep->authmode), NNI_TYPE_INT32)) !=\n\t        0)) {\n\t\ttlstran_ep_fini(ep);\n\t\treturn (rv);\n\t}\n\n#ifdef NNG_ENABLE_STATS\n\tnni_listener_add_stat(nlistener, &ep->st_rcv_max);\n#endif\n\t*lp = ep;\n\treturn (0);\n}\n\nstatic void\ntlstran_ep_cancel(nni_aio *aio, void *arg, int rv)\n{\n\ttlstran_ep *ep = arg;\n\tnni_mtx_lock(&ep->mtx);\n\tif (ep->useraio == aio) {\n\t\tep->useraio = NULL;\n\t\tnni_aio_finish_error(aio, rv);\n\t}\n\tnni_mtx_unlock(&ep->mtx);\n}\n\n// TODO network interface bind\nstatic int\ntlstran_ep_get_url(void *arg, void *v, size_t *szp, nni_opt_type t)\n{\n\ttlstran_ep *ep = arg;\n\tchar *      s;\n\tint         rv;\n\tint         port = 0;\n\n\tif (ep->listener != NULL) {\n\t\t(void) nng_stream_listener_get_int(\n\t\t    ep->listener, NNG_OPT_TCP_BOUND_PORT, &port);\n\t}\n\n\tif ((rv = nni_url_asprintf_port(&s, ep->url, port)) == 0) {\n\t\trv = nni_copyout_str(s, v, szp, t);\n\t\tnni_strfree(s);\n\t}\n\treturn (rv);\n}\n\nstatic int\ntlstran_ep_set_conf(void *arg, const void *v, size_t sz, nni_opt_type t)\n{\n\ttlstran_ep *ep = arg;\n\tNNI_ARG_UNUSED(sz);\n\tNNI_ARG_UNUSED(t);\n\tnni_mtx_lock(&ep->mtx);\n\tep->conf = (conf *) v;\n\tnni_mtx_unlock(&ep->mtx);\n\treturn 0;\n}\n\nstatic int\ntlstran_ep_get_recvmaxsz(void *arg, void *v, size_t *szp, nni_opt_type t)\n{\n\ttlstran_ep *ep = arg;\n\tint         rv;\n\n\tnni_mtx_lock(&ep->mtx);\n\trv = nni_copyout_size(ep->rcvmax, v, szp, t);\n\tnni_mtx_unlock(&ep->mtx);\n\treturn (rv);\n}\n\nstatic int\ntlstran_ep_set_recvmaxsz(void *arg, const void *v, size_t sz, nni_opt_type t)\n{\n\ttlstran_ep *ep = arg;\n\tsize_t      val;\n\tint         rv;\n\tif ((rv = nni_copyin_size(&val, v, sz, 0, NNI_MAXSZ, t)) == 0) {\n\t\ttlstran_pipe *p;\n\t\tnni_mtx_lock(&ep->mtx);\n\t\tep->rcvmax = val;\n\t\tNNI_LIST_FOREACH (&ep->waitpipes, p) {\n\t\t\tp->rcvmax = val;\n\t\t}\n\t\tNNI_LIST_FOREACH (&ep->negopipes, p) {\n\t\t\tp->rcvmax = val;\n\t\t}\n\t\tNNI_LIST_FOREACH (&ep->busypipes, p) {\n\t\t\tp->rcvmax = val;\n\t\t}\n\t\tnni_mtx_unlock(&ep->mtx);\n#ifdef NNG_ENABLE_STATS\n\t\tnni_stat_set_value(&ep->st_rcv_max, val);\n#endif\n\t}\n\treturn (rv);\n}\n\nstatic int\ntlstran_ep_bind(void *arg)\n{\n\ttlstran_ep *ep = arg;\n\tint         rv;\n\n\tnni_mtx_lock(&ep->mtx);\n\trv = nng_stream_listener_listen(ep->listener);\n\tnni_mtx_unlock(&ep->mtx);\n\n\treturn (rv);\n}\n\nstatic void\ntlstran_ep_accept(void *arg, nni_aio *aio)\n{\n\ttlstran_ep *ep = arg;\n\tint         rv;\n\n\tif (nni_aio_begin(aio) != 0) {\n\t\treturn;\n\t}\n\tnni_mtx_lock(&ep->mtx);\n\tif (ep->closed) {\n\t\tnni_mtx_unlock(&ep->mtx);\n\t\tnni_aio_finish_error(aio, NNG_ECLOSED);\n\t\treturn;\n\t}\n\tif (ep->useraio != NULL) {\n\t\tnni_mtx_unlock(&ep->mtx);\n\t\tnni_aio_finish_error(aio, NNG_EBUSY);\n\t\treturn;\n\t}\n\tif ((rv = nni_aio_schedule(aio, tlstran_ep_cancel, ep)) != 0) {\n\t\tnni_mtx_unlock(&ep->mtx);\n\t\tnni_aio_finish_error(aio, rv);\n\t\treturn;\n\t}\n\tep->useraio = aio;\n\tif (!ep->started) {\n\t\tep->started = true;\n\t\tnng_stream_listener_accept(ep->listener, ep->connaio);\n\t} else {\n\t\ttlstran_ep_match(ep);\n\t}\n\tnni_mtx_unlock(&ep->mtx);\n}\n\n\nstatic nni_sp_pipe_ops tlstran_pipe_ops = {\n\t.p_init  = tlstran_pipe_init,\n\t.p_fini  = tlstran_pipe_fini,\n\t.p_stop  = tlstran_pipe_stop,\n\t.p_send  = tlstran_pipe_send,\n\t.p_recv  = tlstran_pipe_recv,\n\t.p_close = tlstran_pipe_close,\n\t//.p_peer   = tlstran_pipe_peer,\n\t.p_getopt = tlstran_pipe_getopt,\n};\n\nstatic const nni_option tlstran_ep_opts[] = {\n\t{\n\t    .o_name = NNG_OPT_RECVMAXSZ,\n\t    .o_get  = tlstran_ep_get_recvmaxsz,\n\t    .o_set  = tlstran_ep_set_recvmaxsz,\n\t},\n\t{\n\t    .o_name = NNG_OPT_URL,\n\t    .o_get  = tlstran_ep_get_url,\n\t},\n\t{\n\t    .o_name = NANO_CONF,\n\t    .o_set  = tlstran_ep_set_conf,\n\t},\n\t// terminate list\n\t{\n\t    .o_name = NULL,\n\t},\n};\n\nstatic int\ntlstran_listener_get(\n    void *arg, const char *name, void *buf, size_t *szp, nni_type t)\n{\n\ttlstran_ep *ep = arg;\n\tint         rv;\n\n\trv = nni_stream_listener_get(ep->listener, name, buf, szp, t);\n\tif (rv == NNG_ENOTSUP) {\n\t\trv = nni_getopt(tlstran_ep_opts, name, ep, buf, szp, t);\n\t}\n\treturn (rv);\n}\n\nstatic int\ntlstran_listener_set(\n    void *arg, const char *name, const void *buf, size_t sz, nni_type t)\n{\n\ttlstran_ep *ep = arg;\n\tint         rv;\n\n\trv = nni_stream_listener_set(\n\t    ep != NULL ? ep->listener : NULL, name, buf, sz, t);\n\tif (rv == NNG_ENOTSUP) {\n\t\trv = nni_setopt(tlstran_ep_opts, name, ep, buf, sz, t);\n\t}\n\treturn (rv);\n}\n\nstatic nni_sp_listener_ops tlstran_listener_ops = {\n\t.l_init   = tlstran_ep_init_listener,\n\t.l_fini   = tlstran_ep_fini,\n\t.l_bind   = tlstran_ep_bind,\n\t.l_accept = tlstran_ep_accept,\n\t.l_close  = tlstran_ep_close,\n\t.l_getopt = tlstran_listener_get,\n\t.l_setopt = tlstran_listener_set,\n};\n\nstatic nni_sp_tran tlstran_mqtt = {\n\t.tran_scheme   = \"tls+nmq-tcp\",\n\t.tran_listener = &tlstran_listener_ops,\n\t.tran_pipe     = &tlstran_pipe_ops,\n\t.tran_init     = tlstran_init,\n\t.tran_fini     = tlstran_fini,\n};\n\nstatic nni_sp_tran tls_tcp4_tran_mqtt = {\n\t.tran_scheme   = \"tls+nmq-tcp4\",\n\t.tran_listener = &tlstran_listener_ops,\n\t.tran_pipe     = &tlstran_pipe_ops,\n\t.tran_init     = tlstran_init,\n\t.tran_fini     = tlstran_fini,\n};\n\nstatic nni_sp_tran tls_tcp6_tran_mqtt = {\n\t.tran_scheme   = \"tls+nmq-tcp6\",\n\t.tran_listener = &tlstran_listener_ops,\n\t.tran_pipe     = &tlstran_pipe_ops,\n\t.tran_init     = tlstran_init,\n\t.tran_fini     = tlstran_fini,\n};\n\n#ifndef NNG_ELIDE_DEPRECATED\nint\nnmq_mqtt_tls_register(void)\n{\n\treturn (nni_init());\n}\n#endif\n\nvoid\nnni_nmq_broker_tls_register(void)\n{\n\tnni_sp_tran_register(&tlstran_mqtt);\n\tnni_sp_tran_register(&tls_tcp4_tran_mqtt);\n\tnni_sp_tran_register(&tls_tcp6_tran_mqtt);\n}\n", "//\n// Copyright 2022 NanoMQ Team, Inc. <jaylin@emqx.io>\n//\n// This software is supplied under the terms of the MIT License, a\n// copy of which should be located in the distribution where this\n// file was obtained (LICENSE.txt).  A copy of the license may also be\n// found online at https://opensource.org/licenses/MIT.\n//\n\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <string.h>\n\n#include \"core/nng_impl.h\"\n#include \"core/sockimpl.h\"\n#include \"supplemental/websocket/websocket.h\"\n\n#include \"nng/supplemental/tls/tls.h\"\n#include \"nng/transport/mqttws/nmq_websocket.h\"\n\n#include \"nng/protocol/mqtt/mqtt.h\"\n#include \"nng/protocol/mqtt/mqtt_parser.h\"\n#include \"nng/supplemental/nanolib/mqtt_db.h\"\n#include \"nng/supplemental/nanolib/conf.h\"\n#include \"supplemental/mqtt/mqtt_qos_db_api.h\"\n#include \"supplemental/mqtt/mqtt_msg.h\"\n\ntypedef struct ws_listener ws_listener;\ntypedef struct ws_pipe     ws_pipe;\n\nstruct ws_listener {\n\tuint16_t             peer; // remote protocol\n\tconf                *conf;\n\tnni_list             aios;\n\tnni_mtx              mtx;\n\tnni_aio             *accaio;\n\tnng_stream_listener *listener;\n\tbool                 started;\n};\n\nstruct ws_pipe {\n\tnni_mtx     mtx;\n\tbool        closed;\n\tuint8_t     txlen[NANO_MIN_PACKET_LEN];\n\tuint16_t    peer;\n\tsize_t      gotrxhead;\n\tsize_t      wantrxhead;\n\tconf       *conf;\n\tnni_msg    *tmp_msg;\n\tnni_aio    *user_txaio;\n\tnni_aio    *user_rxaio;\n\tnni_aio    *ep_aio;\n\tnni_aio    *txaio;\n\tnni_aio    *rxaio;\n\tnni_aio    *qsaio;\n\tnni_pipe   *npipe;\n\tconn_param *ws_param;\n\tnng_stream *ws;\n\tuint8_t    *qos_buf; // msg trunk for qos & V4/V5 conversion\n\tsize_t      qlength; // length of qos_buf\n\t// MQTT V5\n\tuint16_t qrecv_quota;\n\tuint32_t qsend_quota;\n};\n\nstatic void\nwstran_pipe_send_cb(void *arg)\n{\n\tws_pipe *p = arg;\n\tnni_aio *taio;\n\tnni_aio *uaio;\n\n\tnni_mtx_lock(&p->mtx);\n\ttaio          = p->txaio;\n\tuaio          = p->user_txaio;\n\tp->user_txaio = NULL;\n\n\tif (uaio != NULL) {\n\t\tint rv;\n\t\tif ((rv = nni_aio_result(taio)) != 0) {\n\t\t\tnni_aio_finish_error(uaio, rv);\n\t\t} else {\n\t\t\tnni_aio_finish(uaio, 0, 0);\n\t\t}\n\t}\n\tnni_mtx_unlock(&p->mtx);\n}\n\nstatic void\nwstran_pipe_qos_send_cb(void *arg)\n{\n\tws_pipe *p = arg;\n\tnni_aio *qsaio;\n\n\tlog_trace(\" wstran_pipe_qos_send_cb \");\n\tqsaio          = p->qsaio;\n\n\tnni_msg *msg = nni_aio_get_msg(qsaio);\n\tif (msg != NULL) {\n\t\tnni_msg_free(msg);\n\t}\n}\n\nstatic void\nwstran_pipe_recv_cb(void *arg)\n{\n\tws_pipe *p = arg;\n\tnni_iov  iov[2];\n\tuint8_t  rv;\n\tuint32_t pos = 1;\n\tuint64_t len = 0;\n\tuint8_t *ptr;\n\tnni_msg *smsg = NULL, *msg = NULL;\n\tnni_aio *raio = p->rxaio;\n\tnni_aio *uaio = NULL;\n\tbool     ack  = false;\n\n\tnni_mtx_lock(&p->mtx);\n\t// only sets uaio at first time\n\tif (p->user_rxaio != NULL) {\n\t\tuaio = p->user_rxaio;\n\t}\n\t// process scatterd msgs\n\tif ((rv = nni_aio_result(raio)) != 0) {\n\t\tlog_warn(\" recv aio error %s\", nng_strerror(rv));\n\t\tgoto reset;\n\t}\n\tmsg = nni_aio_get_msg(raio);\n\tif (nni_msg_header_len(msg) == 0 && nni_msg_len(msg) == 0) {\n\t\tlog_trace(\"empty msg received! continue next receive\");\n\t\tgoto recv;\n\t}\n\tptr = nni_msg_body(msg);\n\tp->gotrxhead += nni_msg_len(msg);\n\tlog_trace(\"#### wstran_pipe_recv_cb got %ld msg: %p %x %ld\",\n\t    p->gotrxhead, ptr, *ptr, nni_msg_len(msg));\n\t// first we collect complete Fixheader\n\tif (p->tmp_msg == NULL && p->gotrxhead > 0) {\n\t\tif ((rv = nni_msg_alloc(&p->tmp_msg, 0)) != 0) {\n\t\t\tlog_error(\"mem error %ld\\n\", (size_t) len);\n\t\t\tgoto reset;\n\t\t}\n\t}\n\t// TODO use IOV instead of appending msg\n\tnni_msg_append(p->tmp_msg, ptr, nni_msg_len(msg));\n\tptr = nni_msg_body(p->tmp_msg); // packet might be sticky?\n\n\tif (p->wantrxhead == 0) {\n\t\tif (p->gotrxhead == 1) {\n\t\t\tgoto recv;\n\t\t}\n\t\tlen = get_var_integer(ptr, &pos);\n\t\tif (*(ptr + pos - 1) > 0x7f) {\n\t\t\t// continue to next byte of remaining length\n\t\t\tif (p->gotrxhead >= NNI_NANO_MAX_HEADER_SIZE) {\n\t\t\t\t// length error\n\t\t\t\trv = NNG_EMSGSIZE;\n\t\t\t\tgoto reset;\n\t\t\t}\n\t\t} else {\n\t\t\t// Fixed header finished\n\t\t\tp->wantrxhead = len + pos;\n\t\t\tnni_msg_set_cmd_type(p->tmp_msg, *ptr & 0xf0);\n\t\t}\n\t}\n\tif (p->gotrxhead >= p->wantrxhead) {\n\t\tgoto done;\n\t}\n\nrecv:\n\tnni_msg_free(msg);\n\tnng_stream_recv(p->ws, raio);\n\tnni_mtx_unlock(&p->mtx);\n\treturn;\ndone:\n\tif (uaio == NULL) {\n\t\tuaio = p->ep_aio;\n\t}\n\tif (uaio != NULL) {\n\t\tif (p->gotrxhead+p->wantrxhead > p->conf->max_packet_size) {\n\t\t\tlog_trace(\"size error 0x95\\n\");\n\t\t\trv = NMQ_PACKET_TOO_LARGE;\n\t\t\tgoto recv_error;\n\t\t}\n\t\tp->gotrxhead  = 0;\n\t\tp->wantrxhead = 0;\n\t\tnni_msg_free(msg);\n\t\tif (nni_msg_cmd_type(p->tmp_msg) == CMD_CONNECT) {\n\t\t\t// end of nego\n\t\t\tif (p->ws_param == NULL) {\n\t\t\t\tconn_param_alloc(&p->ws_param);\n\t\t\t}\n\t\t\tif (conn_handler(nni_msg_body(p->tmp_msg), p->ws_param,\n\t\t\t        nni_msg_len(p->tmp_msg)) != 0) {\n\t\t\t\tconn_param_free(p->ws_param);\n\t\t\t\trv = NNG_ECONNRESET;\n\t\t\t\tgoto reset;\n\t\t\t}\n\t\t\tif (p->ws_param->pro_ver == 5) {\n\t\t\t\tp->qsend_quota = p->ws_param->rx_max;\n\t\t\t}\n\t\t\tif (p->ws_param->max_packet_size == 0) {\n\t\t\t\t// set default max packet size for client\n\t\t\t\tp->ws_param->max_packet_size =\n\t\t\t\t    p->conf->client_max_packet_size;\n\t\t\t}\n\t\t\tnni_msg_free(p->tmp_msg);\n\t\t\tp->tmp_msg = NULL;\n\t\t\tnni_aio_set_output(uaio, 0, p);\n\t\t\t// pipe_start_cb send CONNACK\n\t\t\tnni_aio_finish(uaio, 0, 0);\n\t\t\tnni_mtx_unlock(&p->mtx);\n\t\t\treturn;\n\t\t} else {\n\t\t\tif (nni_msg_alloc(&smsg, 0) != 0) {\n\t\t\t\tgoto reset;\n\t\t\t}\n\t\t\t// parse fixed header\n\t\t\tws_msg_adaptor(ptr, smsg);\n\t\t\t// msg = p->tmp_msg;\n\t\t\tnni_msg_free(p->tmp_msg);\n\t\t\tp->tmp_msg = NULL;\n\t\t\tnni_msg_set_conn_param(smsg, p->ws_param);\n\t\t}\n\n\t\tuint8_t   qos_pac;\n\t\tproperty *prop        = NULL;\n\t\tuint8_t   reason_code = 0;\n\t\tuint8_t   ack_cmd     = 0;\n\n\t\tuint16_t packet_id = 0;\n\t\tnni_msg *qmsg;\n\t\tuint8_t  cmd = nni_msg_cmd_type(smsg);\n\t\tif (cmd == CMD_PUBLISH) {\n\t\t\tqos_pac = nni_msg_get_pub_qos(smsg);\n\t\t\tif (qos_pac > 0) {\n\t\t\t\t// flow control, check rx_max\n\t\t\t\t// recv_quota as length of lmq\n\t\t\t\tif (p->ws_param->pro_ver == 5) {\n\t\t\t\t\tif (p->qrecv_quota > 0) {\n\t\t\t\t\t\tp->qrecv_quota--;\n\t\t\t\t\t} else {\n\t\t\t\t\t\trv = NMQ_RECEIVE_MAXIMUM_EXCEEDED;\n\t\t\t\t\t\tgoto recv_error;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (qos_pac == 1) {\n\t\t\t\t\tack_cmd = CMD_PUBACK;\n\t\t\t\t} else if (qos_pac == 2) {\n\t\t\t\t\tack_cmd = CMD_PUBREC;\n\t\t\t\t}\n\t\t\t\tpacket_id = nni_msg_get_pub_pid(smsg);\n\t\t\t\tack       = true;\n\t\t\t}\n\t\t} else if (cmd == CMD_PUBREC) {\n\t\t\tif (nni_mqtt_pubres_decode(smsg, &packet_id, &reason_code, &prop,\n\t\t\t        p->ws_param->pro_ver) != 0) {\n\t\t\t\tlog_trace(\"decode PUBREC variable header failed!\");\n\t\t\t}\n\t\t\tack_cmd = CMD_PUBREL;\n\t\t\tack     = true;\n\t\t} else if (cmd == CMD_PUBREL) {\n\t\t\tif (nni_mqtt_pubres_decode(smsg, &packet_id, &reason_code, &prop,\n\t\t\t        p->ws_param->pro_ver) != 0) {\n\t\t\t\tlog_trace(\"decode PUBREL variable header failed!\");\n\t\t\t}\n\t\t\tack_cmd = CMD_PUBCOMP;\n\t\t\tack     = true;\n\t\t} else if (cmd == CMD_PUBACK || cmd == CMD_PUBCOMP) {\n\t\t\tif (nni_mqtt_pubres_decode(smsg, &packet_id, &reason_code, &prop,\n\t\t\t        p->ws_param->pro_ver) != 0) {\n\t\t\t\tlog_trace(\"decode PUBACK or PUBCOMP variable header \"\n\t\t\t\t          \"failed!\");\n\t\t\t}\n\t\t\t// MQTT V5 flow control\n\t\t\tif (p->ws_param->pro_ver == 5) {\n\t\t\t\tproperty_free(prop);\n\t\t\t\tp->qsend_quota++;\n\t\t\t}\n\t\t} else if (cmd == CMD_PINGREQ) {\n\t\t\t// reply PINGRESP\n\t\t\tack = true;\n\t\t}\n\n\t\tif (ack == true) {\n\t\t\t// alloc a msg here costs memory. However we must do it for the\n\t\t\t// sake of compatibility with nng.\n\t\t\tif ((rv = nni_msg_alloc(&qmsg, 0)) != 0) {\n\t\t\t\tack = false;\n\t\t\t\trv  = NMQ_SERVER_BUSY;\n\t\t\t\tlog_error(\"ERROR: OOM in WebSocket\");\n\t\t\t\tgoto recv_error;\n\t\t\t}\n\t\t\tif (cmd == CMD_PINGREQ) {\n\t\t\t\tuint8_t buf[2] = { CMD_PINGRESP, 0x00 };\n\t\t\t\tnni_msg_set_cmd_type(qmsg, CMD_PINGRESP);\n\t\t\t\tnni_msg_header_append(qmsg, buf, 2);\n\t\t\t\tnng_aio_wait(p->qsaio);\n\t\t\t\tiov[0].iov_len = nni_msg_header_len(qmsg);\n\t\t\t\tiov[0].iov_buf = nni_msg_header(qmsg);\n\t\t\t\tnni_aio_set_msg(p->qsaio, qmsg);\n\t\t\t\t// send ACK down...\n\t\t\t\tnni_aio_set_iov(p->qsaio, 1, iov);\n\t\t\t\tnng_stream_send(p->ws, p->qsaio);\n\t\t\t\t//ignore PING msg, only notify\n\t\t\t} else {\n\t\t\t\t// TODO set reason code or property here if\n\t\t\t\t// necessary\n\t\t\t\tnni_msg_set_cmd_type(qmsg, ack_cmd);\n\t\t\t\tnni_mqtt_msgack_encode(qmsg, packet_id, reason_code,\n\t\t\t\t    prop, p->ws_param->pro_ver);\n\t\t\t\tnni_mqtt_pubres_header_encode(qmsg, ack_cmd);\n\t\t\t\tnng_aio_wait(p->qsaio);\n\t\t\t\tiov[0].iov_len = nni_msg_header_len(qmsg);\n\t\t\t\tiov[0].iov_buf = nni_msg_header(qmsg);\n\t\t\t\tiov[1].iov_len = nni_msg_len(qmsg);\n\t\t\t\tiov[1].iov_buf = nni_msg_body(qmsg);\n\t\t\t\tnni_aio_set_msg(p->qsaio, qmsg);\n\t\t\t\t// send ACK down...\n\t\t\t\tnni_aio_set_iov(p->qsaio, 2, iov);\n\t\t\t\tnng_stream_send(p->ws, p->qsaio);\n\t\t\t}\n\t\t}\n\t\tnni_aio_set_msg(uaio, smsg);\n\t\tnni_aio_set_output(uaio, 0, p);\n\t} else {\n\t\tgoto reset;\n\t}\n\tnni_mtx_unlock(&p->mtx);\n\tnni_aio_finish(uaio, 0, nni_msg_len(smsg));\n\treturn;\nreset:\n\tp->gotrxhead  = 0;\n\tp->wantrxhead = 0;\n\tnng_stream_close(p->ws);\n\tif (uaio != NULL) {\n\t\tnni_aio_finish_error(uaio, rv);\n\t} else if (p->ep_aio != NULL) {\n\t\tnni_aio_finish_error(p->ep_aio, rv);\n\t}\n\tif (p->tmp_msg != NULL) {\n\t\tsmsg = p->tmp_msg;\n\t\tnni_msg_free(smsg);\n\t\tp->tmp_msg = NULL;\n\t}\n\tnni_mtx_unlock(&p->mtx);\n\treturn;\n\nrecv_error:\n\t//TODO fixme\n\t// nni_aio_list_remove(aio);\n\t// msg      = p->rxmsg;\n\t// p->rxmsg = NULL;\n\tnni_pipe_bump_error(p->npipe, rv);\n\tnni_mtx_unlock(&p->mtx);\n\tnni_msg_free(msg);\n\t// nni_aio_finish_error(aio, rv);\n\tlog_error(\"tcptran_pipe_recv_cb: recv error rv: %d\\n\", rv);\n\treturn;\n}\n\nstatic void\nwstran_pipe_recv_cancel(nni_aio *aio, void *arg, int rv)\n{\n\tws_pipe *p = arg;\n\tnni_mtx_lock(&p->mtx);\n\tif (p->user_rxaio != aio) {\n\t\tnni_mtx_unlock(&p->mtx);\n\t\treturn;\n\t}\n\tp->user_rxaio = NULL;\n\tnni_aio_abort(p->rxaio, rv);\n\tnni_aio_finish_error(aio, rv);\n\tnni_mtx_unlock(&p->mtx);\n}\n\nstatic void\nwstran_pipe_recv(void *arg, nni_aio *aio)\n{\n\tws_pipe *p = arg;\n\tint      rv;\n\n\tif (nni_aio_begin(aio) != 0) {\n\t\treturn;\n\t}\n\tnni_mtx_lock(&p->mtx);\n\tif ((rv = nni_aio_schedule(aio, wstran_pipe_recv_cancel, p)) != 0) {\n\t\tnni_mtx_unlock(&p->mtx);\n\t\tnni_aio_finish_error(aio, rv);\n\t\treturn;\n\t}\n\tp->user_rxaio = aio;\n\tnng_stream_recv(p->ws, p->rxaio);\n\tnni_mtx_unlock(&p->mtx);\n}\n\nstatic void\nwstran_pipe_send_cancel(nni_aio *aio, void *arg, int rv)\n{\n\tws_pipe *p = arg;\n\tnni_mtx_lock(&p->mtx);\n\tif (p->user_txaio != aio) {\n\t\tnni_mtx_unlock(&p->mtx);\n\t\treturn;\n\t}\n\tp->user_txaio = NULL;\n\tnni_aio_abort(p->txaio, rv);\n\tnni_aio_finish_error(aio, rv);\n\tnni_mtx_unlock(&p->mtx);\n}\n\nstatic inline void\nwstran_pipe_send_start_v4(ws_pipe *p, nni_msg *msg, nni_aio *aio)\n{\n\tnni_msg *smsg;\n\tint       niov;\n\tnni_iov   iov[8];\n\tnni_pipe *pipe = p->npipe;\n\tuint8_t   qos;\n\n\n\tif (nni_msg_get_type(msg) != CMD_PUBLISH)\n\t\tgoto send;\n\n\t// never modify the original msg\n\tuint8_t *     body, *header, qos_pac;\n\tint           len_offset = 0;\n\tuint16_t      pid;\n\tuint32_t      prop_bytes = 0, property_len = 0;\n\tsize_t        tlen, rlen, mlen, qlength, plength;\n\tbool          is_sqlite = p->conf->sqlite.enable;\n\n\tbody    = nni_msg_body(msg);\n\theader  = nni_msg_header(msg);\n\tniov    = 0;\n\tqlength = 0;\n\tplength = 0;\n\tmlen    = nni_msg_len(msg);\n\tqos_pac = nni_msg_get_pub_qos(msg);\n\tNNI_GET16(body, tlen);\n\n\tsubinfo *info, *tinfo=NULL;\n\tnni_msg_alloc(&smsg, 0);\n\tif (nni_msg_cmd_type(msg) == CMD_PUBLISH_V5) {\n\t\t// V5 to V4 shrink msg, remove property length\n\t\t// APP layer must give topic name even if topic\n\t\t// alias is set\n\t\tif (qos_pac > 0) {\n\t\t\tproperty_len =\n\t\t\t    get_var_integer(body + 4 + tlen, &prop_bytes);\n\n\t\t} else {\n\t\t\tproperty_len =\n\t\t\t    get_var_integer(body + 2 + tlen, &prop_bytes);\n\t\t}\n\t\tplength       = property_len + prop_bytes;\n\t}\n\n\tNNI_LIST_FOREACH (p->npipe->subinfol, info) {\n\t\tif (tinfo != NULL && info != tinfo ) {\n\t\t\tcontinue;\n\t\t}\n\t\ttinfo = NULL;\n\t\tlen_offset=0;\n\t\tchar *sub_topic = info->topic;\n\t\tif (sub_topic[0] == '$') {\n\t\t\tif (0 == strncmp(sub_topic, \"$share/\", strlen(\"$share/\"))) {\n\t\t\t\tsub_topic = strchr(sub_topic, '/');\n\t\t\t\tsub_topic++;\n\t\t\t\tsub_topic = strchr(sub_topic, '/');\n\t\t\t\tsub_topic++;\n\t\t\t}\n\t\t}\n\t\tif (topic_filtern(sub_topic, (char*)(body + 2), tlen)) {\n\t\t\tuint8_t  var_extra[2], fixheader, tmp[4] = { 0 };\n\t\t\tuint32_t pos = 1;\n\t\t\tqos          = info->qos;\n\t\t\tfixheader    = *header;\n\n\t\t\t// get final qos\n\t\t\tqos = qos_pac > qos ? qos : qos_pac;\n\n\t\t\t// alter qos according to sub qos\n\t\t\tif (qos_pac > qos) {\n\t\t\t\tif (qos == 1) {\n\t\t\t\t\t// set qos to 1\n\t\t\t\t\tfixheader = fixheader & 0xF9;\n\t\t\t\t\tfixheader = fixheader | 0x02;\n\t\t\t\t} else {\n\t\t\t\t\t// set qos to 0\n\t\t\t\t\tfixheader = fixheader & 0xF9;\n\t\t\t\t\tlen_offset   = len_offset - 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// fixed header + remaining length\n\t\t\trlen = put_var_integer(tmp,\n\t\t\t    get_var_integer(header, &pos) + len_offset -\n\t\t\t        plength);\n\t\t\t*(p->qos_buf + qlength) = fixheader;\n\t\t\t// copy remaining length\n\t\t\tmemcpy(p->qos_buf + qlength + 1, tmp, rlen);\n\t\t\tiov[niov].iov_buf = p->qos_buf + qlength;\n\t\t\tiov[niov].iov_len = rlen + 1;\n\t\t\tniov++;\n\t\t\tqlength += rlen + 1;\n\t\t\t// 1st part of variable header: topic + topic len\n\t\t\tiov[niov].iov_buf = body;\n\t\t\tiov[niov].iov_len = tlen+2;\n\t\t\tniov++;\n\t\t\t// len to indicate the offset in packet\n\t\t\tlen_offset = 0;\n\t\t\tif (qos > 0) {\n\t\t\t\t// set pid\n\t\t\t\tlen_offset = 2;\n\t\t\t\tnni_msg *old;\n\t\t\t\t// packetid in aio to differ resend msg\n\t\t\t\t// TODO replace it with set prov data\n\t\t\t\tpid = (uint16_t)(size_t) nni_aio_get_prov_data(aio);\n\t\t\t\tif (pid == 0) {\n\t\t\t\t\t// first time send this msg\n\t\t\t\t\tpid = nni_pipe_inc_packetid(pipe);\n\t\t\t\t\t// store msg for qos retrying\n\t\t\t\t\tnni_msg_clone(msg);\n\t\t\t\t\tif ((old = nni_qos_db_get(is_sqlite,\n\t\t\t\t\t         pipe->nano_qos_db, pipe->p_id,\n\t\t\t\t\t         pid)) != NULL) {\n\t\t\t\t\t\t// TODO packetid already\n\t\t\t\t\t\t// exists. we need to\n\t\t\t\t\t\t// replace old with new one\n\t\t\t\t\t\t// print warning to users\n\t\t\t\t\t\tnni_println(\"ERROR: packet id \"\n\t\t\t\t\t\t            \"duplicates in \"\n\t\t\t\t\t\t            \"nano_qos_db\");\n\t\t\t\t\t\tnni_qos_db_remove_msg(\n\t\t\t\t\t\t    is_sqlite,\n\t\t\t\t\t\t    pipe->nano_qos_db, old);\n\t\t\t\t\t}\n\t\t\t\t\told = msg;\n\t\t\t\t\tnni_qos_db_set(is_sqlite,\n\t\t\t\t\t    pipe->nano_qos_db, pipe->p_id, pid,\n\t\t\t\t\t    old);\n\t\t\t\t\tnni_qos_db_remove_oldest(is_sqlite,\n\t\t\t\t\t    pipe->nano_qos_db,\n\t\t\t\t\t    p->conf->sqlite.disk_cache_size);\n\t\t\t\t}\n\t\t\t\tNNI_PUT16(var_extra, pid);\n\t\t\t\t// copy packet id\n\t\t\t\tmemcpy(p->qos_buf + qlength, var_extra, 2);\n\t\t\t} else if (qos_pac > 0) {\n\t\t\t\t//ignore the packet id of original packet\n\t\t\t\tlen_offset += 2;\n\t\t\t}\n\t\t\t// 2nd part of variable header: pid\n\t\t\tiov[niov].iov_buf = p->qos_buf + qlength;\n\t\t\tiov[niov].iov_len = qos > 0 ? 2 : 0;\n\t\t\tniov++;\n\t\t\tqlength += qos > 0 ? 2 : 0;\n\t\t\t// body\n\t\t\tiov[niov].iov_buf = body + 2 + tlen + len_offset + plength;\n\t\t\tiov[niov].iov_len = mlen - 2 - len_offset - tlen - plength;\n\t\t\tniov++;\n\t\t\t// apending directly\n\t\t\tfor (int i = 0; i < niov; i++) {\n\t\t\t\tnni_msg_append(\n\t\t\t\t    smsg, iov[i].iov_buf, iov[i].iov_len);\n\t\t\t}\n\t\t\tniov = 0;\n\t\t}\n\t}\n\n\t// duplicated msg is gonna be freed by http. so we free old one\n\t// here\n\tnni_msg_free(msg);\n\tmsg = smsg;\n\n// normal sending if it is not PUBLISH\nsend:\n\tnni_aio_set_msg(aio, msg);\n\tnni_aio_set_msg(p->txaio, msg);\n\tnni_aio_set_msg(aio, NULL);\n\t// verify connect\n\t// for websocket, cmd type is 0x00 for PUBLISH\n\tif (nni_msg_cmd_type(msg) == CMD_CONNACK) {\n\t\tuint8_t *header = nni_msg_header(msg);\n\t\tif (*(header + 3) != 0x00) {\n\t\t\tnni_pipe_close(p->npipe);\n\t\t}\n\t}\n\tnng_stream_send(p->ws, p->txaio);\n}\n\n\n\nstatic inline void\nwstran_pipe_send_start_v5(ws_pipe *p, nni_msg *msg, nni_aio *aio)\n{\n\tnni_msg *smsg;\n\tint       niov;\n\tnni_iov   iov[8];\n\tnni_pipe *pipe = p->npipe;\n\tuint8_t   qos = 0;\n\n\n\tif (nni_msg_get_type(msg) != CMD_PUBLISH)\n\t\tgoto send;\n\n\t// never modify the original msg\n\tuint8_t *     body, *header, qos_pac;\n\ttarget_prover target_prover;\n\tint           len_offset = 0, sub_id = 0;\n\tuint16_t      pid;\n\tuint32_t tprop_bytes = 0, prop_bytes = 0, id_bytes = 0, property_len = 0;\n\tsize_t        tlen, rlen, mlen, hlen, qlength, plength;\n\tbool          is_sqlite = p->conf->sqlite.enable;\n\n\tbody    = nni_msg_body(msg);\n\theader  = nni_msg_header(msg);\n\tniov    = 0;\n\tqlength = 0;\n\tplength = 0;\n\tmlen    = nni_msg_len(msg);\n\thlen    = nni_msg_header_len(msg);\n\tqos_pac = nni_msg_get_pub_qos(msg);\n\tNNI_GET16(body, tlen);\n\n\t// check max packet size for this client/msg\n\tuint32_t total_len = mlen + hlen;\n\tif (total_len > p->ws_param->max_packet_size) {\n\t\t// drop msg and finish aio\n\t\t// pretend it has been sent\n\t\tlog_warn(\"msg dropped due to overceed max packet size!\");\n\t\tnni_msg_free(msg);\n\t\tnni_aio_set_msg(aio, NULL);\n\t\tnni_aio_finish(aio, 0, 0);\n\t\treturn;\n\t}\n\n\tif (nni_msg_cmd_type(msg) == CMD_PUBLISH_V5) {\n\t\t// V5 to V4 shrink msg, remove property length\n\t\t// APP layer must give topic name even if topic\n\t\t// alias is set\n\t\tif (qos_pac > 0) {\n\t\t\tproperty_len = get_var_integer(\n\t\t\t    body + 4 + tlen, &prop_bytes);\n\n\t\t} else {\n\t\t\tproperty_len = get_var_integer(\n\t\t\t    body + 2 + tlen, &prop_bytes);\n\t\t}\n\t\ttarget_prover = MQTTV5;\n\t\tplength = property_len + prop_bytes;\n\t}\n\n\t// subid\n\tsubinfo *info = NULL;\n\tnni_msg_alloc(&smsg, 0);\n\n\tNNI_LIST_FOREACH (p->npipe->subinfol, info) {\n\t\tif (info->no_local == 1 &&\n\t\t    p->npipe->p_id == nni_msg_get_pipe(msg)) {\n\t\t\tcontinue;\n\t\t}\n\t\tlen_offset      = 0;\n\t\tchar *sub_topic = info->topic;\n\t\tif (sub_topic[0] == '$') {\n\t\t\tif (0 ==\n\t\t\t    strncmp(sub_topic, \"$share/\", strlen(\"$share/\"))) {\n\t\t\t\tsub_topic = strchr(sub_topic, '/');\n\t\t\t\tsub_topic++;\n\t\t\t\tsub_topic = strchr(sub_topic, '/');\n\t\t\t\tsub_topic++;\n\t\t\t}\n\t\t}\n\t\tif (topic_filtern(sub_topic, (char *) (body + 2), tlen)) {\n\t\t\tuint8_t  var_extra[2], fixheader, tmp[4] = { 0 };\n\t\t\tuint8_t  proplen[4] = { 0 }, var_subid[5] = { 0 };\n\t\t\tuint32_t pos = 1;\n\t\t\tsub_id       = info->subid;\n\t\t\tqos          = info->qos;\n\n\t\t\t//else use original var payload & pid\n\t\t\tfixheader = *header;\n\t\t\tif (nni_msg_cmd_type(msg) == CMD_PUBLISH) {\n\t\t\t\t// V4 to V5 add 0 property length\n\t\t\t\ttarget_prover = MQTTV4_V5;\n\t\t\t\tprop_bytes    = 1;\n\t\t\t\ttprop_bytes   = 1;\n\t\t\t\tlen_offset    = 1;\n\t\t\t}\n\t\t\tif (info->rap == 0) {\n\t\t\t\tfixheader = fixheader & 0xFE;\n\t\t\t}\n\t\t\tif (sub_id != 0) {\n\t\t\t\tvar_subid[0] = 0x0B;\n\t\t\t\tid_bytes = put_var_integer(var_subid+1, sub_id);\n\t\t\t\ttprop_bytes = put_var_integer(proplen, property_len+1+id_bytes);\n\t\t\t\tlen_offset += (tprop_bytes - prop_bytes + 1 + id_bytes);\n\t\t\t}\n\n\t\t\t// get final qos\n\t\t\tqos = qos_pac > qos ? qos : qos_pac;\n\n\t\t\t// alter qos according to sub qos\n\t\t\tif (qos_pac > qos) {\n\t\t\t\tif (qos == 1) {\n\t\t\t\t\t// set qos to 1\n\t\t\t\t\tfixheader = fixheader & 0xF9;\n\t\t\t\t\tfixheader = fixheader | 0x02;\n\t\t\t\t} else {\n\t\t\t\t\t// set qos to 0\n\t\t\t\t\tfixheader = fixheader & 0xF9;\n\t\t\t\t\tlen_offset   = len_offset - 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// fixed header + remaining length\n\t\t\trlen = put_var_integer(\n\t\t\t    tmp, get_var_integer(header, &pos) + len_offset);\n\t\t\t// or just copy to qosbuf directly?\n\t\t\t*(p->qos_buf + qlength) = fixheader;\n\t\t\tmemcpy(p->qos_buf + qlength + 1, tmp, rlen);\n\t\t\tiov[niov].iov_buf = p->qos_buf + qlength;\n\t\t\tiov[niov].iov_len = rlen + 1;\n\t\t\tniov++;\n\t\t\tqlength += rlen + 1;\n\t\t\t// 1st part of variable header: topic + topic len\n\t\t\tiov[niov].iov_buf = body;\n\t\t\tiov[niov].iov_len = tlen+2;\n\t\t\tniov++;\n\t\t\t// len to indicate the offset in packet\n\t\t\tlen_offset = 0;\n\t\t\tplength = 0;\n\t\t\tif (qos > 0) {\n\t\t\t\t// set pid\n\t\t\t\tlen_offset = 2;\n\t\t\t\tnni_msg *old;\n\t\t\t\t// packetid in aio to differ resend msg\n\t\t\t\t// TODO replace it with set prov data\n\t\t\t\tpid = (uint16_t)(size_t) nni_aio_get_prov_data(\n\t\t\t\t    aio);\n\t\t\t\tif (pid == 0) {\n\t\t\t\t\t// first time send this msg\n\t\t\t\t\tpid = nni_pipe_inc_packetid(pipe);\n\t\t\t\t\t// store msg for qos retrying\n\t\t\t\t\tnni_msg_clone(msg);\n\t\t\t\t\tif ((old = nni_qos_db_get(is_sqlite,\n\t\t\t\t\t         pipe->nano_qos_db, pipe->p_id,\n\t\t\t\t\t         pid)) != NULL) {\n\t\t\t\t\t\t// TODO packetid already\n\t\t\t\t\t\t// exists. we need to\n\t\t\t\t\t\t// replace old with new one\n\t\t\t\t\t\t// print warning to users\n\t\t\t\t\t\tnni_println(\"ERROR: packet id \"\n\t\t\t\t\t\t            \"duplicates in \"\n\t\t\t\t\t\t            \"nano_qos_db\");\n\t\t\t\t\t\tnni_qos_db_remove_msg(\n\t\t\t\t\t\t    is_sqlite,\n\t\t\t\t\t\t    pipe->nano_qos_db, old);\n\t\t\t\t\t}\n\t\t\t\t\told = msg;\n\t\t\t\t\tnni_qos_db_set(is_sqlite,\n\t\t\t\t\t    pipe->nano_qos_db, pipe->p_id, pid,\n\t\t\t\t\t    old);\n\t\t\t\t\tnni_qos_db_remove_oldest(is_sqlite,\n\t\t\t\t\t    pipe->nano_qos_db,\n\t\t\t\t\t    p->conf->sqlite.disk_cache_size);\n\t\t\t\t}\n\t\t\t\tNNI_PUT16(var_extra, pid);\n\t\t\t\t// copy packet id\n\t\t\t\tmemcpy(p->qos_buf + qlength, var_extra, 2);\n\t\t\t\tqlength += 2;\n\t\t\t\tplength += 2;\n\t\t\t} else if (qos_pac > 0) {\n\t\t\t\t//ignore the packet id of original packet\n\t\t\t\tlen_offset += 2;\n\t\t\t}\n\t\t\t// prop len + sub id if any\n\t\t\tif (sub_id != 0) {\n\t\t\t\tmemcpy(p->qos_buf + qlength, proplen,\n\t\t\t\t    tprop_bytes);\n\t\t\t\tqlength += tprop_bytes;\n\t\t\t\tplength += tprop_bytes;\n\t\t\t\tmemcpy(p->qos_buf + qlength, var_subid,\n\t\t\t\t    id_bytes + 1);\n\t\t\t\tqlength += id_bytes + 1;\n\t\t\t\tplength += id_bytes + 1;\n\t\t\t\tif (target_prover == MQTTV5)\n\t\t\t\t\tlen_offset += prop_bytes;\n\t\t\t} else {\n\t\t\t\t//need to add 0 len for V4 msg\n\t\t\t\tif (target_prover == MQTTV4_V5) {\n\t\t\t\t\t// add proplen even 0\n\t\t\t\t\tmemcpy(p->qos_buf + qlength, proplen,\n\t\t\t\t\t    tprop_bytes);\n\t\t\t\t\tqlength += tprop_bytes;\n\t\t\t\t\tplength += tprop_bytes;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 2nd part of variable header: pid + proplen+0x0B+subid\n\t\t\tiov[niov].iov_buf = p->qos_buf+qlength-plength;\n\t\t\tiov[niov].iov_len = plength;\n\t\t\tniov++;\n\t\t\t// prop + body\n\t\t\tiov[niov].iov_buf = body + 2 + tlen + len_offset;\n\t\t\tiov[niov].iov_len = mlen - 2 - len_offset - tlen;\n\t\t\tniov++;\n\t\t\t// apending directly\n\t\t\tfor (int i = 0; i < niov; i++) {\n\t\t\t\tnni_msg_append(\n\t\t\t\t    smsg, iov[i].iov_buf, iov[i].iov_len);\n\t\t\t}\n\t\t\tniov = 0;\n\t\t}\n\t}\n\n\t// duplicated msg is gonna be freed by http. so we free old one\n\t// here\n\tnni_msg_free(msg);\n\tmsg = smsg;\n\n\t// MQTT V5 flow control\n\tif (qos > 0) {\n\t\tif (p->qsend_quota > 0) {\n\t\t\tp->qsend_quota--;\n\t\t} else {\n\t\t\t// what should broker does when exceed\n\t\t\t// max_recv? msg lost, make it look like a\n\t\t\t// normal send. qos msg will be resend\n\t\t\t// afterwards\n\t\t\tnni_msg_free(msg);\n\t\t\t// nni_aio_set_prov_data(txaio, NULL);\n\t\t\tnni_aio_set_msg(aio, NULL);\n\t\t\tnni_aio_finish(aio, 0, 0);\n\t\t\treturn;\n\t\t}\n\t}\n\n// normal sending if it is not PUBLISH\nsend:\n\tnni_aio_set_msg(aio, msg);\n\tnni_aio_set_msg(p->txaio, msg);\n\tnni_aio_set_msg(aio, NULL);\n\t// verify connect\n\tif (nni_msg_cmd_type(msg) == CMD_CONNACK) {\n\t\tuint8_t *header = nni_msg_header(msg);\n\t\tif (*(header + 3) != 0x00) {\n\t\t\tnni_pipe_close(p->npipe);\n\t\t}\n\t}\n\tnng_stream_send(p->ws, p->txaio);\n}\n\nstatic void\nwstran_pipe_send_start(ws_pipe *p)\n{\n\tnni_msg *msg;\n\tnng_aio *aio = p->user_txaio;\n\tmsg          = nni_aio_get_msg(aio);\n\n\tif (msg == NULL || p->ws_param == NULL) {\n\t\t// TODO error handler\n\t\tnni_println(\"ERROR: sending NULL msg or pipe is invalid!\");\n\t\tnni_aio_finish(aio, NNG_ECANCELED, 0);\n\t\treturn;\n\t}\n\n\tif (p->ws_param->pro_ver == 4) {\n\t\twstran_pipe_send_start_v4(p, msg, aio);\n\t\treturn;\n\t} else if (p->ws_param->pro_ver == 5) {\n\t\twstran_pipe_send_start_v5(p, msg, aio);\n\t\treturn;\n\t}\n\n}\n\nstatic void\nwstran_pipe_send(void *arg, nni_aio *aio)\n{\n\tws_pipe *p = arg;\n\tint      rv;\n\n\tif (nni_aio_begin(aio) != 0) {\n\t\treturn;\n\t}\n\tnni_mtx_lock(&p->mtx);\n\tif ((rv = nni_aio_schedule(aio, wstran_pipe_send_cancel, p)) != 0) {\n\t\tnni_mtx_unlock(&p->mtx);\n\t\tnni_aio_finish_error(aio, rv);\n\t\treturn;\n\t}\n\tp->user_txaio = aio;\n\twstran_pipe_send_start(p);\n\n\tnni_mtx_unlock(&p->mtx);\n}\n\nstatic void\nwstran_pipe_stop(void *arg)\n{\n\tws_pipe *p = arg;\n\n\tnni_aio_stop(p->rxaio);\n\tnni_aio_stop(p->txaio);\n\tnni_aio_stop(p->qsaio);\n}\n\nstatic int\nwstran_pipe_init(void *arg, nni_pipe *pipe)\n{\n\tlog_trace(\"************wstran_pipe_init************\");\n\tws_pipe *p = arg;\n\n\tnni_pipe_set_conn_param(pipe, p->ws_param);\n\tp->npipe      = pipe;\n\n\tif (!p->conf->sqlite.enable) {\n\t\tnni_qos_db_init_id_hash(pipe->nano_qos_db);\n\t}\n\n\tp->gotrxhead  = 0;\n\tp->wantrxhead = 0;\n\tp->ep_aio     = NULL;\n\n\tp->qos_buf = nng_zalloc(16 + NNI_NANO_MAX_PACKET_SIZE);\n\t// the size limit of qos_buf reserve 1 byte for property length\n\tp->qlength = 16 + NNI_NANO_MAX_PACKET_SIZE;\n\treturn (0);\n}\n\nstatic void\nwstran_pipe_fini(void *arg)\n{\n\tws_pipe *p = arg;\n\n\tnni_aio_free(p->rxaio);\n\tnni_aio_free(p->txaio);\n\tnni_aio_free(p->qsaio);\n\n\tnng_stream_free(p->ws);\n\tnni_msg_free(p->tmp_msg);\n\tnni_mtx_fini(&p->mtx);\n\tnng_free(p->qos_buf, 16 + NNI_NANO_MAX_PACKET_SIZE);\n\tNNI_FREE_STRUCT(p);\n}\n\nstatic void\nwstran_pipe_close(void *arg)\n{\n\tws_pipe *p = arg;\n\n\tnni_aio_close(p->rxaio);\n\tnni_aio_close(p->qsaio);\n\tnni_aio_close(p->txaio);\n\n\tnni_mtx_lock(&p->mtx);\n\tnng_stream_close(p->ws);\n\tnni_mtx_unlock(&p->mtx);\n}\n\nstatic int\nwstran_pipe_alloc(ws_pipe **pipep, void *ws)\n{\n\tws_pipe *p;\n\tint      rv;\n\n\tif ((p = NNI_ALLOC_STRUCT(p)) == NULL) {\n\t\treturn (NNG_ENOMEM);\n\t}\n\tnni_mtx_init(&p->mtx);\n\n\t// Initialize AIOs.\n\tif (((rv = nni_aio_alloc(&p->txaio, wstran_pipe_send_cb, p)) != 0) ||\n\t    ((rv = nni_aio_alloc(&p->qsaio, wstran_pipe_qos_send_cb, p)) != 0) ||\n\t    ((rv = nni_aio_alloc(&p->rxaio, wstran_pipe_recv_cb, p)) != 0)) {\n\t\twstran_pipe_fini(p);\n\t\treturn (rv);\n\t}\n\tp->ws = ws;\n\n\t*pipep = p;\n\treturn (0);\n}\n\nstatic uint16_t\nwstran_pipe_peer(void *arg)\n{\n\tws_pipe *p = arg;\n\n\treturn (p->peer);\n}\n\nstatic int\nws_listener_bind(void *arg)\n{\n\tws_listener *l = arg;\n\tint          rv;\n\n\tif ((rv = nng_stream_listener_listen(l->listener)) == 0) {\n\t\tl->started = true;\n\t}\n\treturn (rv);\n}\n\nstatic void\nws_listener_cancel(nni_aio *aio, void *arg, int rv)\n{\n\tws_listener *l = arg;\n\n\tnni_mtx_lock(&l->mtx);\n\tif (nni_aio_list_active(aio)) {\n\t\tnni_aio_list_remove(aio);\n\t\tnni_aio_finish_error(aio, rv);\n\t}\n\tnni_mtx_unlock(&l->mtx);\n}\n\nstatic void\nwstran_listener_accept(void *arg, nni_aio *aio)\n{\n\tws_listener *l = arg;\n\tint          rv;\n\n\t// We already bound, so we just need to look for an available\n\t// pipe (created by the handler), and match it.\n\t// Otherwise we stick the AIO in the accept list.\n\tif (nni_aio_begin(aio) != 0) {\n\t\treturn;\n\t}\n\tnni_mtx_lock(&l->mtx);\n\tif ((rv = nni_aio_schedule(aio, ws_listener_cancel, l)) != 0) {\n\t\tnni_mtx_unlock(&l->mtx);\n\t\tnni_aio_finish_error(aio, rv);\n\t\treturn;\n\t}\n\tnni_list_append(&l->aios, aio);\n\tif (aio == nni_list_first(&l->aios)) {\n\t\tnng_stream_listener_accept(l->listener, l->accaio);\n\t}\n\tnni_mtx_unlock(&l->mtx);\n}\n\nstatic const nni_option ws_pipe_options[] = {\n\t// terminate list\n\t{\n\t    .o_name = NULL,\n\t}\n};\n\nstatic int\nwstran_pipe_getopt(\n    void *arg, const char *name, void *buf, size_t *szp, nni_type t)\n{\n\tws_pipe *p = arg;\n\tint      rv;\n\n\tif ((rv = nni_stream_get(p->ws, name, buf, szp, t)) == NNG_ENOTSUP) {\n\t\trv = nni_getopt(ws_pipe_options, name, p, buf, szp, t);\n\t}\n\treturn (rv);\n}\n\nstatic nni_sp_pipe_ops ws_pipe_ops = {\n\t.p_init   = wstran_pipe_init,\n\t.p_fini   = wstran_pipe_fini,\n\t.p_stop   = wstran_pipe_stop,\n\t.p_send   = wstran_pipe_send,\n\t.p_recv   = wstran_pipe_recv,\n\t.p_close  = wstran_pipe_close,\n\t.p_peer   = wstran_pipe_peer,\n\t.p_getopt = wstran_pipe_getopt,\n};\n\nstatic void\nwstran_listener_fini(void *arg)\n{\n\tws_listener *l = arg;\n\n\tnni_aio_stop(l->accaio);\n\tnng_stream_listener_free(l->listener);\n\tnni_aio_free(l->accaio);\n\tnni_mtx_fini(&l->mtx);\n\tNNI_FREE_STRUCT(l);\n}\n\nstatic void\nwstran_listener_close(void *arg)\n{\n\tws_listener *l = arg;\n\n\tnni_aio_close(l->accaio);\n\tnng_stream_listener_close(l->listener);\n}\n\nstatic void\nws_pipe_start(ws_pipe *pipe, nng_stream *conn, ws_listener *l)\n{\n\tNNI_ARG_UNUSED(conn);\n\tws_pipe *p = pipe;\n\tlog_trace(\"ws_pipe_start!\");\n\tp->qrecv_quota = NANO_MAX_QOS_PACKET;\n\tp->conf        = l->conf;\n\tnng_stream_recv(p->ws, p->rxaio);\n}\n\nstatic void\nwstran_accept_cb(void *arg)\n{\n\tws_listener *l    = arg;\n\tnni_aio *    aaio = l->accaio;\n\tnni_aio *    uaio;\n\tint          rv;\n\n\tnni_mtx_lock(&l->mtx);\n\tuaio = nni_list_first(&l->aios);\n\tif ((rv = nni_aio_result(aaio)) != 0) {\n\t\tif (uaio != NULL) {\n\t\t\tnni_aio_list_remove(uaio);\n\t\t\tnni_aio_finish_error(uaio, rv);\n\t\t}\n\t} else {\n\t\tnng_stream *ws = nni_aio_get_output(aaio, 0);\n\t\tif (uaio != NULL) {\n\t\t\tws_pipe *p;\n\t\t\t// Make a pipe\n\t\t\tnni_aio_list_remove(uaio);\n\t\t\tif ((rv = wstran_pipe_alloc(&p, ws)) != 0) {\n\t\t\t\tnng_stream_close(ws);\n\t\t\t\tnni_aio_finish_error(uaio, rv);\n\t\t\t} else {\n\t\t\t\tp->peer = l->peer;\n\t\t\t\tws_pipe_start(p, p->ws, l);\n\t\t\t\tp->ep_aio = uaio;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!nni_list_empty(&l->aios)) {\n\t\tnng_stream_listener_accept(l->listener, aaio);\n\t}\n\tnni_mtx_unlock(&l->mtx);\n}\n\n\n// TODO proto name modify\nstatic int\nwstran_listener_init(void **lp, nng_url *url, nni_listener *listener)\n{\n\tws_listener *l;\n\tint          rv;\n\tnni_sock *   s = nni_listener_sock(listener);\n\tchar         name[64];\n\n\tif ((l = NNI_ALLOC_STRUCT(l)) == NULL) {\n\t\treturn (NNG_ENOMEM);\n\t}\n\tnni_mtx_init(&l->mtx);\n\n\tnni_aio_list_init(&l->aios);\n\n\tl->peer = nni_sock_peer_id(s);\n\n\tsnprintf(name, sizeof(name), \"mqtt\");\n\n\tif (((rv = nni_ws_listener_alloc(&l->listener, url)) != 0) ||\n\t    ((rv = nni_aio_alloc(&l->accaio, wstran_accept_cb, l)) != 0) ||\n\t    ((rv = nng_stream_listener_set_bool(\n\t          l->listener, NNI_OPT_WS_MSGMODE, true)) != 0) ||\n\t    ((rv = nng_stream_listener_set_string(\n\t          l->listener, NNG_OPT_WS_PROTOCOL, name)) != 0)) {\n\t\twstran_listener_fini(l);\n\t\treturn (rv);\n\t}\n\t*lp = l;\n\treturn (0);\n}\n\nstatic void\nwstran_init(void)\n{\n}\n\nstatic void\nwstran_fini(void)\n{\n}\n\nstatic int\nwstran_ep_set_conf(void *arg, const void *v, size_t sz, nni_type t)\n{\n\tws_listener *l = arg;\n\tNNI_ARG_UNUSED(sz);\n\tNNI_ARG_UNUSED(t);\n\tnni_mtx_lock(&l->mtx);\n\tl->conf = (conf *) v;\n\tnni_mtx_unlock(&l->mtx);\n\treturn 0;\n}\n\nstatic const nni_option wstran_ep_opts[] = {\n\t{\n\t    .o_name = NANO_CONF,\n\t    .o_set  = wstran_ep_set_conf,\n\t},\n\t// terminate list\n\t{\n\t    .o_name = NULL,\n\t},\n};\n\n\nstatic int\nwstran_listener_get(\n    void *arg, const char *name, void *buf, size_t *szp, nni_type t)\n{\n\tws_listener *l = arg;\n\tint          rv;\n\n\trv = nni_stream_listener_get(l->listener, name, buf, szp, t);\n\tif (rv == NNG_ENOTSUP) {\n\t\trv = nni_getopt(wstran_ep_opts, name, l, buf, szp, t);\n\t}\n\treturn (rv);\n}\n\nstatic int\nwstran_listener_set(\n    void *arg, const char *name, const void *buf, size_t sz, nni_type t)\n{\n\tws_listener *l = arg;\n\tint          rv;\n\n\trv = nni_stream_listener_set(l->listener, name, buf, sz, t);\n\tif (rv == NNG_ENOTSUP) {\n\t\trv = nni_setopt(wstran_ep_opts, name, l, buf, sz, t);\n\t}\n\treturn (rv);\n}\n\nstatic nni_sp_listener_ops ws_listener_ops = {\n\t.l_init   = wstran_listener_init,\n\t.l_fini   = wstran_listener_fini,\n\t.l_bind   = ws_listener_bind,\n\t.l_accept = wstran_listener_accept,\n\t.l_close  = wstran_listener_close,\n\t.l_setopt = wstran_listener_set,\n\t.l_getopt = wstran_listener_get,\n};\n\nstatic nni_sp_tran ws__tran = {\n\t.tran_scheme   = \"nmq+ws\",\n\t.tran_dialer   = NULL,\n\t.tran_listener = &ws_listener_ops,\n\t.tran_pipe     = &ws_pipe_ops,\n\t.tran_init     = wstran_init,\n\t.tran_fini     = wstran_fini,\n};\n\nstatic nni_sp_tran ws4__tran = {\n\t.tran_scheme   = \"nmq+ws4\",\n\t.tran_dialer   = NULL,\n\t.tran_listener = &ws_listener_ops,\n\t.tran_pipe     = &ws_pipe_ops,\n\t.tran_init     = wstran_init,\n\t.tran_fini     = wstran_fini,\n};\n\nstatic nni_sp_tran ws6__tran = {\n\t.tran_scheme   = \"nmq+ws6\",\n\t.tran_dialer   = NULL,\n\t.tran_listener = &ws_listener_ops,\n\t.tran_pipe     = &ws_pipe_ops,\n\t.tran_init     = wstran_init,\n\t.tran_fini     = wstran_fini,\n};\n\nstatic nni_sp_tran ws_tran = {\n\t.tran_scheme   = \"nmq-ws\",\n\t.tran_dialer   = NULL,\n\t.tran_listener = &ws_listener_ops,\n\t.tran_pipe     = &ws_pipe_ops,\n\t.tran_init     = wstran_init,\n\t.tran_fini     = wstran_fini,\n};\n\nstatic nni_sp_tran ws4_tran = {\n\t.tran_scheme   = \"nmq-ws4\",\n\t.tran_dialer   = NULL,\n\t.tran_listener = &ws_listener_ops,\n\t.tran_pipe     = &ws_pipe_ops,\n\t.tran_init     = wstran_init,\n\t.tran_fini     = wstran_fini,\n};\n\nstatic nni_sp_tran ws6_tran = {\n\t.tran_scheme   = \"nmq-ws6\",\n\t.tran_dialer   = NULL,\n\t.tran_listener = &ws_listener_ops,\n\t.tran_pipe     = &ws_pipe_ops,\n\t.tran_init     = wstran_init,\n\t.tran_fini     = wstran_fini,\n};\n\n#ifndef NNG_ELIDE_DEPRECATED\nint\nnng_nmq_ws_register(void)\n{\n\treturn (nni_init());\n}\n\nint\nnng_nmq_wss_register(void)\n{\n\treturn (nni_init());\n}\n#endif\n\nvoid\nnni_nmq_ws_register(void)\n{\n\tnni_sp_tran_register(&ws_tran);\n\tnni_sp_tran_register(&ws4_tran);\n\tnni_sp_tran_register(&ws6_tran);\n\tnni_sp_tran_register(&ws__tran);\n\tnni_sp_tran_register(&ws4__tran);\n\tnni_sp_tran_register(&ws6__tran);\n}\n\n#ifdef NNG_TRANSPORT_WSS\n\nstatic nni_sp_tran wss__tran = {\n\t.tran_scheme   = \"nmq+wss\",\n\t.tran_dialer   = NULL,\n\t.tran_listener = &ws_listener_ops,\n\t.tran_pipe     = &ws_pipe_ops,\n\t.tran_init     = wstran_init,\n\t.tran_fini     = wstran_fini,\n};\n\nstatic nni_sp_tran wss4__tran = {\n\t.tran_scheme   = \"nmq+wss4\",\n\t.tran_dialer   = NULL,\n\t.tran_listener = &ws_listener_ops,\n\t.tran_pipe     = &ws_pipe_ops,\n\t.tran_init     = wstran_init,\n\t.tran_fini     = wstran_fini,\n};\n\nstatic nni_sp_tran wss6__tran = {\n\t.tran_scheme   = \"nmq+wss6\",\n\t.tran_dialer   = NULL,\n\t.tran_listener = &ws_listener_ops,\n\t.tran_pipe     = &ws_pipe_ops,\n\t.tran_init     = wstran_init,\n\t.tran_fini     = wstran_fini,\n};\n\nstatic nni_sp_tran wss_tran = {\n\t.tran_scheme   = \"nmq-wss\",\n\t.tran_dialer   = NULL,\n\t.tran_listener = &ws_listener_ops,\n\t.tran_pipe     = &ws_pipe_ops,\n\t.tran_init     = wstran_init,\n\t.tran_fini     = wstran_fini,\n};\n\nstatic nni_sp_tran wss4_tran = {\n\t.tran_scheme   = \"nmq-wss4\",\n\t.tran_dialer   = NULL,\n\t.tran_listener = &ws_listener_ops,\n\t.tran_pipe     = &ws_pipe_ops,\n\t.tran_init     = wstran_init,\n\t.tran_fini     = wstran_fini,\n};\n\nstatic nni_sp_tran wss6_tran = {\n\t.tran_scheme   = \"nmq-wss6\",\n\t.tran_dialer   = NULL,\n\t.tran_listener = &ws_listener_ops,\n\t.tran_pipe     = &ws_pipe_ops,\n\t.tran_init     = wstran_init,\n\t.tran_fini     = wstran_fini,\n};\n\nvoid\nnni_nmq_wss_register(void)\n{\n\tnni_sp_tran_register(&wss_tran);\n\tnni_sp_tran_register(&wss4_tran);\n\tnni_sp_tran_register(&wss6_tran);\n\tnni_sp_tran_register(&wss__tran);\n\tnni_sp_tran_register(&wss4__tran);\n\tnni_sp_tran_register(&wss6__tran);\n}\n\n#endif // NNG_TRANSPORT_WSS\n"], "fixing_code": ["//\n// Copyright 2022 NanoMQ Team, Inc. <jaylin@emqx.io>\n//\n// This software is supplied under the terms of the MIT License, a\n// copy of which should be located in the distribution where this\n// file was obtained (LICENSE.txt).  A copy of the license may also be\n// found online at https://opensource.org/licenses/MIT.\n//\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"core/nng_impl.h\"\n#include \"nng/mqtt/mqtt_client.h\"\n#include \"nng/supplemental/tls/tls.h\"\n#include \"supplemental/mqtt/mqtt_msg.h\"\n#include \"nng/protocol/mqtt/mqtt_parser.h\"\n\n// TLS Over TCP transport.   Platform specific TLS Over TCP operations must be\n// supplied as well.\n\ntypedef struct mqtts_tcptran_pipe mqtts_tcptran_pipe;\ntypedef struct mqtts_tcptran_ep   mqtts_tcptran_ep;\n\n// tcp_pipe is one end of a TCP connection.\nstruct mqtts_tcptran_pipe {\n\tnng_stream *      conn;\n\tnni_pipe *        npipe;\n\tuint32_t          packmax; // MQTT Maximum Packet Size (Max length)\n\tuint16_t          peer;    // broker info\n\tuint16_t          proto;   // MQTT version\n\tuint16_t          keepalive;\n\tuint16_t          sndmax; // MQTT Receive Maximum (QoS 1/2 packet)\n\tuint8_t           pingcnt; // pingreq counter\n\tuint8_t           qosmax;\n\tsize_t            rcvmax;\n\tbool              closed;\n\tnni_list_node     node;\n\tmqtts_tcptran_ep *ep;\n\tnni_atomic_flag   reaped;\n\tnni_reap_node     reap;\n\tuint8_t           txlen[sizeof(uint64_t)];\n\tuint8_t           rxlen[sizeof(uint64_t)]; // fixed header\n\tsize_t            gottxhead;\n\tsize_t            gotrxhead;\n\tsize_t            wanttxhead;\n\tsize_t            wantrxhead;\n\tnni_list          recvq;\n\tnni_list          sendq;\n\tnni_aio           tmaio;\n\tnni_aio *         txaio;\n\tnni_aio *         rxaio;\n\tnni_aio *         rpaio;\n\tnni_aio *         qsaio;\n\tnni_lmq           rslmq;\n\tnni_aio *         negoaio;\n\tnni_msg *         rxmsg;\n\tnni_msg *         smsg;\n\tnni_mtx           mtx;\n\tbool              busy;\n#ifdef NNG_HAVE_MQTT_BROKER\n\tnni_msg *   connack;\n\tconn_param *cparam;\n#endif\n};\n\nstruct mqtts_tcptran_ep {\n\tnni_mtx              mtx;\n\tuint16_t             proto;\n\tsize_t               rcvmax;\n\tbool                 fini;\n\tbool                 started;\n\tbool                 closed;\n\tnng_url *            url;\n\tconst char *         host; // for dialers\n\tnng_sockaddr         src;\n\tnng_sockaddr         sa;\n\tint                  refcnt; // active pipes\n\tint                  authmode;\n\treason_code          reason_code;\n\tnni_aio *            useraio;\n\tnni_aio *            connaio;\n\tnni_aio *            timeaio;\n\tnni_list             busypipes; // busy pipes -- ones passed to socket\n\tnni_list             waitpipes; // pipes waiting to match to socket\n\tnni_list             negopipes; // pipes busy negotiating\n\tnni_reap_node        reap;\n\tnng_stream_dialer *  dialer;\n\tnng_stream_listener *listener;\n\tnni_dialer *         ndialer;\n\tvoid *               property;  // property\n\tvoid *               connmsg;\n\n#ifdef NNG_ENABLE_STATS\n\tnni_stat_item st_rcv_max;\n#endif\n};\n\nstatic void     mqtts_tcptran_pipe_send_start(mqtts_tcptran_pipe *);\nstatic void     mqtts_tcptran_pipe_recv_start(mqtts_tcptran_pipe *);\nstatic void     mqtts_tcptran_pipe_send_cb(void *);\nstatic void     mqtts_tcptran_pipe_qos_send_cb(void *);\nstatic void     mqtts_tcptran_pipe_recv_cb(void *);\nstatic void     mqtts_tcptran_pipe_nego_cb(void *);\nstatic void     mqtts_tcptran_ep_fini(void *);\nstatic void     mqtts_tcptran_pipe_fini(void *);\n\nstatic nni_reap_list tcptran_ep_reap_list = {\n\t.rl_offset = offsetof(mqtts_tcptran_ep, reap),\n\t.rl_func   = mqtts_tcptran_ep_fini,\n};\n\nstatic nni_reap_list tcptran_pipe_reap_list = {\n\t.rl_offset = offsetof(mqtts_tcptran_pipe, reap),\n\t.rl_func   = mqtts_tcptran_pipe_fini,\n};\n\nstatic void\nmqtts_tcptran_init(void)\n{\n}\n\nstatic void\nmqtts_tcptran_fini(void)\n{\n}\n\nstatic void\nmqtts_tcptran_pipe_close(void *arg)\n{\n\tmqtts_tcptran_pipe *p = arg;\n\n\tnni_mtx_lock(&p->mtx);\n\tp->closed = true;\n\tnni_lmq_flush(&p->rslmq);\n\tnni_mtx_unlock(&p->mtx);\n\n\tnni_aio_close(p->rxaio);\n\tnni_aio_close(p->qsaio);\n\tnni_aio_close(p->txaio);\n\tnni_aio_close(&p->tmaio);\n\tnni_aio_close(p->negoaio);\n\tnni_aio_close(p->rpaio);\n\tnng_stream_close(p->conn);\n}\n\nstatic void\nmqtts_pipe_timer_cb(void *arg)\n{\n\tmqtts_tcptran_pipe *p = arg;\n\tuint8_t             buf[2];\n\n\tif (nng_aio_result(&p->tmaio) != 0) {\n\t\treturn;\n\t}\n\n\tif (p->pingcnt > 1) {\n\t\tmqtts_tcptran_pipe_close(p);\n\t\treturn;\n\t}\n\t// send PINGREQ with tmaio itself?\n\t// nng_msleep(p->keepalive);\n\tnni_mtx_lock(&p->mtx);\n\tif (!p->busy && !nni_aio_busy(p->qsaio)) {\n\t\t// send pingreq\n\t\tbuf[0] = 0xC0;\n\t\tbuf[1] = 0x00;\n\n\t\tnni_iov iov;\n\t\tiov.iov_len = 2;\n\t\tiov.iov_buf = &buf;\n\t\t// send it down...\n\t\tnni_aio_set_iov(p->qsaio, 1, &iov);\n\t\tnng_stream_send(p->conn, p->qsaio);\n\t\tp->pingcnt ++;\n\t}\n\tnni_mtx_unlock(&p->mtx);\n\tnni_sleep_aio(p->keepalive, &p->tmaio);\n}\n\nstatic void\nmqtts_tcptran_pipe_stop(void *arg)\n{\n\tmqtts_tcptran_pipe *p = arg;\n\n\tnni_aio_stop(p->rxaio);\n\tnni_aio_stop(p->qsaio);\n\tnni_aio_stop(p->txaio);\n\tnni_aio_stop(p->negoaio);\n\tnni_aio_stop(p->rpaio);\n\tnni_aio_stop(&p->tmaio);\n}\n\nstatic int\nmqtts_tcptran_pipe_init(void *arg, nni_pipe *npipe)\n{\n\tmqtts_tcptran_pipe *p = arg;\n\tnni_pipe_set_conn_param(npipe, p->cparam);\n\n\tp->npipe              = npipe;\n\n\tnni_lmq_init(&p->rslmq, 16);\n\tp->busy = false;\n\tp->packmax = 0xFFFF;\n\tp->qosmax  = 2;\n\tp->pingcnt = 0;\n\tnni_sleep_aio(p->keepalive, &p->tmaio);\n\treturn (0);\n}\n\nstatic void\nmqtts_tcptran_pipe_fini(void *arg)\n{\n\tmqtts_tcptran_pipe *p = arg;\n\tmqtts_tcptran_ep *  ep;\n\n\tmqtts_tcptran_pipe_stop(p);\n\tif ((ep = p->ep) != NULL) {\n\t\tnni_mtx_lock(&ep->mtx);\n\t\tnni_list_node_remove(&p->node);\n\t\tep->refcnt--;\n\t\tif (ep->fini && (ep->refcnt == 0)) {\n\t\t\tnni_reap(&tcptran_ep_reap_list, ep);\n\t\t}\n\t\tnni_mtx_unlock(&ep->mtx);\n\t}\n\n\tnni_aio_free(p->rxaio);\n\tnni_aio_free(p->txaio);\n\tnni_aio_free(p->qsaio);\n\tnni_aio_free(p->negoaio);\n\tnni_aio_free(p->rpaio);\n\tnng_stream_free(p->conn);\n\tnni_msg_free(p->rxmsg);\n\tnni_lmq_fini(&p->rslmq);\n\tnni_mtx_fini(&p->mtx);\n\tnni_aio_fini(&p->tmaio);\n#ifdef NNG_HAVE_MQTT_BROKER\n\tconn_param_free(p->cparam);\n#endif\n\tNNI_FREE_STRUCT(p);\n}\n\nstatic void\nmqtts_tcptran_pipe_reap(mqtts_tcptran_pipe *p)\n{\n\tif (!nni_atomic_flag_test_and_set(&p->reaped)) {\n\t\tif (p->conn != NULL) {\n\t\t\tnng_stream_close(p->conn);\n\t\t}\n\t\tnni_reap(&tcptran_pipe_reap_list, p);\n\t}\n}\n\nstatic int\nmqtts_tcptran_pipe_alloc(mqtts_tcptran_pipe **pipep)\n{\n\tmqtts_tcptran_pipe *p;\n\tint                 rv;\n\n\tif ((p = NNI_ALLOC_STRUCT(p)) == NULL) {\n\t\treturn (NNG_ENOMEM);\n\t}\n\tnni_mtx_init(&p->mtx);\n\tnni_aio_init(&p->tmaio, mqtts_pipe_timer_cb, p);\n\tif (((rv = nni_aio_alloc(&p->txaio, mqtts_tcptran_pipe_send_cb, p)) !=\n\t        0) ||\n\t    ((rv = nni_aio_alloc(&p->rxaio, mqtts_tcptran_pipe_recv_cb, p)) !=\n\t        0) ||\n\t    ((rv = nni_aio_alloc(\n\t          &p->qsaio, mqtts_tcptran_pipe_qos_send_cb, p)) != 0) ||\n\t    ((rv = nni_aio_alloc(&p->rpaio, NULL, p)) != 0) ||\n\t    ((rv = nni_aio_alloc(\n\t          &p->negoaio, mqtts_tcptran_pipe_nego_cb, p)) != 0)) {\n\t\tmqtts_tcptran_pipe_fini(p);\n\t\treturn (rv);\n\t}\n\tnni_aio_list_init(&p->recvq);\n\tnni_aio_list_init(&p->sendq);\n\tnni_atomic_flag_reset(&p->reaped);\n\n\t*pipep = p;\n\n\treturn (0);\n}\n\nstatic void\nmqtts_tcptran_ep_match(mqtts_tcptran_ep *ep)\n{\n\tnni_aio *           aio;\n\tmqtts_tcptran_pipe *p;\n\n\tif (((aio = ep->useraio) == NULL) ||\n\t    ((p = nni_list_first(&ep->waitpipes)) == NULL)) {\n\t\treturn;\n\t}\n\tnni_list_remove(&ep->waitpipes, p);\n\tnni_list_append(&ep->busypipes, p);\n\tep->useraio = NULL;\n#ifdef NNG_HAVE_MQTT_BROKER\n\tif (p->cparam == NULL) {\n\t\tp->cparam = nni_get_conn_param_from_msg(ep->connmsg);\n\t}\n#endif\n\tnni_aio_set_output(aio, 0, p);\n\tnni_aio_finish(aio, 0, 0);\n}\n\nstatic void\nmqtts_tcptran_pipe_nego_cb(void *arg)\n{\n\tmqtts_tcptran_pipe *p   = arg;\n\tmqtts_tcptran_ep *  ep  = p->ep;\n\tnni_aio *           aio = p->negoaio;\n\tnni_aio *           uaio;\n\tint                 rv;\n\tuint8_t             pos = 0;\n\tint                 var_int;\n\n\tnni_mtx_lock(&ep->mtx);\n\n\tif ((rv = nni_aio_result(aio)) != 0) {\n\t\trv = SERVER_UNAVAILABLE;\n\t\tgoto error;\n\t}\n\t// We start transmitting before we receive.\n\tif (p->gottxhead < p->wanttxhead) {\n\t\tp->gottxhead += nni_aio_count(aio);\n\t} else if (p->gotrxhead < p->wantrxhead) {\n\t\tp->gotrxhead += nni_aio_count(aio);\n\t}\n\n\tif (p->gottxhead < p->wanttxhead) {\n\t\tnni_iov iov;\n\t\tiov.iov_len = p->wanttxhead - p->gottxhead;\n\t\tiov.iov_buf = &p->txlen[p->gottxhead];\n\t\t// send it down...\n\t\tnni_aio_set_iov(aio, 1, &iov);\n\t\tnng_stream_send(p->conn, aio);\n\t\tnni_mtx_unlock(&ep->mtx);\n\t\treturn;\n\t}\n\n\t// receving fixed header\n\tif (p->gotrxhead == 0 ||\n\t    (p->gotrxhead <= 5 && p->rxlen[p->gotrxhead - 1] > 0x7f &&\n\t        p->rxmsg == NULL)) {\n\t\tnni_iov iov;\n\t\tiov.iov_buf = &p->rxlen[p->gotrxhead];\n\t\tif (p->gotrxhead == 0) {\n\t\t\tiov.iov_len = p->wantrxhead - p->gotrxhead;\n\t\t} else {\n\t\t\tiov.iov_len = 1;\n\t\t}\n\t\tnni_aio_set_iov(aio, 1, &iov);\n\t\tnng_stream_recv(p->conn, aio);\n\t\tnni_mtx_unlock(&ep->mtx);\n\t\treturn;\n\t}\n\t// only accept CONNACK msg\n\tif ((p->rxlen[0] & CMD_CONNACK) != CMD_CONNACK) {\n\t\trv = PROTOCOL_ERROR;\n\t\tgoto error;\n\t}\n\t// finish recevied fixed header\n\tif (p->rxmsg == NULL) {\n\t\tpos = 0;\n\t\tif ((rv = mqtt_get_remaining_length(p->rxlen, p->gotrxhead,\n\t\t         (uint32_t *) &var_int, &pos)) != 0) {\n\t\t\trv = PAYLOAD_FORMAT_INVALID;\n\t\t\tgoto error;\n\t\t}\n\n\t\tif ((rv = nni_mqtt_msg_alloc(&p->rxmsg, var_int)) != 0) {\n\t\t\trv = NNG_ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\n\t\tnni_msg_header_append(p->rxmsg, p->rxlen, pos + 1);\n\n\t\tp->wantrxhead = var_int + 1 + pos;\n\t\tif (p->proto == MQTT_PROTOCOL_VERSION_v311 &&\n\t\t    ((rv = (p->wantrxhead <= 4) ? 0 : NNG_EPROTO) != 0)) {\n\t\t\t// Broker send a invalid CONNACK!\n\t\t\trv = PROTOCOL_ERROR;\n\t\t\tgoto error;\n\t\t}\n\t}\n\t// remaining length\n\tif (p->gotrxhead < p->wantrxhead) {\n\t\tnni_iov iov;\n\t\tiov.iov_len = p->wantrxhead - p->gotrxhead;\n\t\tiov.iov_buf = nni_msg_body(p->rxmsg);\n\t\tnni_aio_set_iov(aio, 1, &iov);\n\t\tnng_stream_recv(p->conn, aio);\n\t\tnni_mtx_unlock(&ep->mtx);\n\t\treturn;\n\t}\n\t// Connack\n\tif (p->gotrxhead >= p->wantrxhead) {\n\t\tif (p->proto == MQTT_PROTOCOL_VERSION_v5) {\n\t\t\trv              = nni_mqttv5_msg_decode(p->rxmsg);\n\t\t\tep->reason_code = rv;\n\t\t\tif (rv != 0)\n\t\t\t\tgoto mqtt_error;\n\t\t\tproperty_free(ep->property);\n\t\t\tproperty *prop =\n\t\t\t    (void *) nni_mqtt_msg_get_connack_property(\n\t\t\t        p->rxmsg);\n\t\t\tproperty_dup((property **) &ep->property, prop);\n\t\t\tproperty_data *data;\n\t\t\tdata =\n\t\t\t    property_get_value(ep->property, RECEIVE_MAXIMUM);\n\t\t\tif (data) {\n\t\t\t\tif (data->p_value.u16 == 0) {\n\t\t\t\t\trv              = MQTT_ERR_PROTOCOL;\n\t\t\t\t\tep->reason_code = rv;\n\t\t\t\t\tgoto mqtt_error;\n\t\t\t\t} else {\n\t\t\t\t\tp->sndmax = data->p_value.u16;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdata = property_get_value(\n\t\t\t    ep->property, MAXIMUM_PACKET_SIZE);\n\t\t\tif (data) {\n\t\t\t\tif (data->p_value.u32 == 0) {\n\t\t\t\t\trv              = MQTT_ERR_PROTOCOL;\n\t\t\t\t\tep->reason_code = rv;\n\t\t\t\t\tgoto mqtt_error;\n\t\t\t\t} else {\n\t\t\t\t\tp->packmax = data->p_value.u32;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdata = property_get_value(\n\t\t\t    ep->property, PUBLISH_MAXIMUM_QOS);\n\t\t\tif (data) {\n\t\t\t\tp->qosmax = data->p_value.u8;\n\t\t\t}\n\t\t} else {\n\t\t\tif ((rv = nni_mqtt_msg_decode(p->rxmsg)) !=\n\t\t\t    MQTT_SUCCESS) {\n\t\t\t\tep->reason_code = rv;\n\t\t\t\tgoto mqtt_error;\n\t\t\t}\n\t\t\tep->property = NULL;\n\t\t}\n\t\tep->reason_code =\n\t\t    nni_mqtt_msg_get_connack_return_code(p->rxmsg);\n\t}\n\t// put \n#ifdef NNG_HAVE_MQTT_BROKER\n\tnni_msg_clone(p->rxmsg);\n\tp->connack = p->rxmsg;\n#endif\n\nmqtt_error:\n\t// We are ready now.  We put this in the wait list, and\n\t// then try to run the matcher.\n\tnni_list_remove(&ep->negopipes, p);\n\tnni_list_append(&ep->waitpipes, p);\n\n\tnni_msg_free(p->rxmsg);\n\tp->rxmsg = NULL;\n\n\tif (rv == MQTT_SUCCESS) {\n\t\tmqtts_tcptran_ep_match(ep);\n\t} else {\n\t\t// Fail but still match to let user know ack has arrived\n\t\tmqtts_tcptran_ep_match(ep);\n\t\t// send DISCONNECT\n\t\tnni_iov iov;\n\t\tp->txlen[0] = CMD_DISCONNECT;\n\t\tif (p->proto == MQTT_PROTOCOL_VERSION_v5) {\n\t\t\tp->txlen[1] = 0x02;\n\t\t\tp->txlen[2] = ep->reason_code;\n\t\t\tp->txlen[3] = 0; // length of property\n\t\t\tiov.iov_len = 4;\n\t\t} else {\n\t\t\tp->txlen[1] = 0x00;\n\t\t\tiov.iov_len = 2;\n\t\t}\n\t\tiov.iov_buf = p->txlen;\n\t\tnni_aio_set_iov(p->rpaio, 1, &iov);\n\t\tnng_stream_send(p->conn, p->rpaio);\n\t}\n\tnni_mtx_unlock(&ep->mtx);\n\n\treturn;\n\nerror:\n\t// If the connection is closed, we need to pass back a different\n\t// error code.  This is necessary to avoid a problem where the\n\t// closed status is confused with the accept file descriptor\n\t// being closed.\n\tif (rv == NNG_ECLOSED) {\n\t\trv = SERVER_SHUTTING_DOWN;\n\t}\n\tnng_stream_close(p->conn);\n\n\tif (p->rxmsg != NULL) {\n\t\tnni_msg_free(p->rxmsg);\n\t\tp->rxmsg = NULL;\n\t}\n\n\tif ((uaio = ep->useraio) != NULL) {\n\t\tep->useraio = NULL;\n\t\tnni_aio_finish_error(uaio, rv);\n\t}\n\tnni_mtx_unlock(&ep->mtx);\n\tmqtts_tcptran_pipe_reap(p);\n}\n\nstatic void\nmqtts_tcptran_pipe_qos_send_cb(void *arg)\n{\n\tmqtts_tcptran_pipe *p = arg;\n\tnni_msg *           msg;\n\tnni_aio *           qsaio = p->qsaio;\n\n\tif (nni_aio_result(qsaio) != 0) {\n\t\tnni_msg_free(nni_aio_get_msg(qsaio));\n\t\tnni_aio_set_msg(qsaio, NULL);\n\t\tmqtts_tcptran_pipe_close(p);\n\t\treturn;\n\t}\n\tnni_mtx_lock(&p->mtx);\n\n\tmsg = nni_aio_get_msg(p->qsaio);\n\tnni_msg_free(msg);\n\tif (nni_lmq_get(&p->rslmq, &msg) == 0) {\n\t\tnni_iov iov;\n\t\tiov.iov_len = 4;\n\t\tiov.iov_buf = nni_msg_header(msg);\n\t\tnni_aio_set_msg(p->qsaio, msg);\n\t\t// send it down...\n\t\tnni_aio_set_iov(p->qsaio, 1, &iov);\n\t\tnng_stream_send(p->conn, p->qsaio);\n\t\tp->busy = true;\n\t\tnni_mtx_unlock(&p->mtx);\n\t\treturn;\n\t}\n\tp->busy = false;\n\tnni_aio_set_msg(qsaio, NULL);\n\tnni_mtx_unlock(&p->mtx);\n\treturn;\n}\n\nstatic void\nmqtts_tcptran_pipe_send_cb(void *arg)\n{\n\tmqtts_tcptran_pipe *p = arg;\n\tint                 rv;\n\tnni_aio *           aio;\n\tsize_t              n;\n\tnni_msg *           msg;\n\tnni_aio *           txaio = p->txaio;\n\n\tnni_mtx_lock(&p->mtx);\n\taio = nni_list_first(&p->sendq);\n\n\tif ((rv = nni_aio_result(txaio)) != 0) {\n\t\t// Intentionally we do not queue up another transfer.\n\t\t// There's an excellent chance that the pipe is no longer\n\t\t// usable, with a partial transfer.\n\t\t// The protocol should see this error, and close the\n\t\t// pipe itself, we hope.\n\t\tnni_aio_list_remove(aio);\n\t\tnni_mtx_unlock(&p->mtx);\n\t\tnni_aio_finish_error(aio, rv);\n\t\tnni_pipe_bump_error(p->npipe, rv);\n\t\treturn;\n\t}\n\n\tn = nni_aio_count(txaio);\n\tnni_aio_iov_advance(txaio, n);\n\tif (nni_aio_iov_count(txaio) > 0) {\n\t\tnng_stream_send(p->conn, txaio);\n\t\tnni_mtx_unlock(&p->mtx);\n\t\treturn;\n\t}\n\n\tnni_aio_list_remove(aio);\n\tmqtts_tcptran_pipe_send_start(p);\n\n\tmsg = nni_aio_get_msg(aio);\n\tn   = nni_msg_len(msg);\n\tnni_pipe_bump_tx(p->npipe, n);\n\tnni_mtx_unlock(&p->mtx);\n\n\tnni_aio_set_msg(aio, NULL);\n\tnni_msg_free(msg);\n\tnni_aio_finish_sync(aio, 0, n);\n}\n\nstatic void\nmqtts_tcptran_pipe_recv_cb(void *arg)\n{\n\tnni_aio *           aio;\n\tnni_iov             iov;\n\tuint8_t             type, pos, flags;\n\tuint32_t            len = 0, rv;\n\tsize_t              n;\n\tnni_msg *           msg, *qmsg;\n\tmqtts_tcptran_pipe *p     = arg;\n\tnni_aio *           rxaio = p->rxaio;\n\tbool                ack   = false;\n\tnni_mtx_lock(&p->mtx);\n\n\taio = nni_list_first(&p->recvq);\n\n\tif ((rv = nni_aio_result(rxaio)) != 0) {\n\t\trv = SERVER_UNAVAILABLE;\n\t\tgoto recv_error;\n\t}\n\n\tn = nni_aio_count(rxaio);\n\tp->gotrxhead += n;\n\n\t// in case one aio is not enough for handling whole buffer\n\tnni_aio_iov_advance(rxaio, n);\n\tif (nni_aio_iov_count(rxaio) > 0) {\n\t\tnng_stream_recv(p->conn, rxaio);\n\t\tnni_mtx_unlock(&p->mtx);\n\t\treturn;\n\t}\n\n\trv = mqtt_get_remaining_length(p->rxlen, p->gotrxhead, &len, &pos);\n\tp->wantrxhead = len + 1 + pos;\n\tif (p->gotrxhead <= 5 && p->rxlen[p->gotrxhead - 1] > 0x7f) {\n\t\tif (p->gotrxhead == NNI_NANO_MAX_HEADER_SIZE) {\n\t\t\trv = PACKET_TOO_LARGE;\n\t\t\tgoto recv_error;\n\t\t}\n\t\t// same packet, continue receving next byte of remaining length\n\t\tiov.iov_buf = &p->rxlen[p->gotrxhead];\n\t\tiov.iov_len = 1;\n\t\tnni_aio_set_iov(rxaio, 1, &iov);\n\t\tnng_stream_recv(p->conn, rxaio);\n\t\tnni_mtx_unlock(&p->mtx);\n\t\treturn;\n\t}\n\n\t// fixed header finished\n\tif (NULL == p->rxmsg) {\n\t\t// Make sure the message payload is not too big.  If it is\n\t\t// the caller will shut down the pipe.\n\t\tif ((len > p->rcvmax) && (p->rcvmax > 0)) {\n\t\t\trv = PACKET_TOO_LARGE;\n\t\t\tgoto recv_error;\n\t\t}\n\t\tif ((rv = nni_msg_alloc(&p->rxmsg, (size_t) len)) != 0) {\n\t\t\trv = UNSPECIFIED_ERROR;\n\t\t\tgoto recv_error;\n\t\t}\n\t\tnni_msg_set_remaining_len(p->rxmsg, len);\n\n\t\t// Submit the rest of the data for a read -- seperate Fixed\n\t\t// header with variable header and so on\n\t\t//  we want to read the entire message now.\n\t\tif (len != 0) {\n\t\t\tiov.iov_buf = nni_msg_body(p->rxmsg);\n\t\t\tiov.iov_len = (size_t) len;\n\n\t\t\tnni_aio_set_iov(rxaio, 1, &iov);\n\t\t\t// second recv action\n\t\t\tnng_stream_recv(p->conn, rxaio);\n\t\t\tnni_mtx_unlock(&p->mtx);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// We read a message completely.  Let the user know the good news. use\n\t// as application message callback of users\n\tnni_aio_list_remove(aio);\n\tnni_msg_header_append(p->rxmsg, p->rxlen, pos + 1);\n\tmsg      = p->rxmsg;\n\tp->rxmsg = NULL;\n\tn        = nni_msg_len(msg);\n\ttype     = p->rxlen[0] & 0xf0;\n\tflags    = p->rxlen[0] & 0x0f;\n\t// set the payload pointer of msg according to packet_type\n\tuint8_t   qos_pac;\n\tuint16_t  packet_id   = 0;\n\tuint8_t   reason_code = 0;\n\tproperty *prop        = NULL;\n\tuint8_t   ack_cmd     = 0;\n\tswitch (type) {\n\tcase CMD_PUBLISH:\n\t\t// should we seperate the 2 phase work of QoS into 2 aios?\n\t\t// TODO MQTT v5 qos\n\t\tqos_pac = nni_msg_get_pub_qos(msg);\n\t\tif (qos_pac > 0) {\n\t\t\tif (qos_pac == 1) {\n\t\t\t\tack_cmd = CMD_PUBACK;\n\t\t\t} else if (qos_pac == 2) {\n\t\t\t\tack_cmd = CMD_PUBREC;\n\t\t\t} else {\n\t\t\t\tlog_warn(\"Wrong QoS level!\");\n\t\t\t\trv = PROTOCOL_ERROR;\n\t\t\t\tgoto recv_error;\n\t\t\t}\n\t\t\tif ((packet_id = nni_msg_get_pub_pid(msg)) == 0) {\n\t\t\t\trv = PROTOCOL_ERROR;\n\t\t\t\tgoto recv_error;\n\t\t\t}\n\t\t\tack = true;\n\t\t}\n\t\tbreak;\n\tcase CMD_PUBREC:\n\t\tif (nni_mqtt_pubres_decode(msg, &packet_id, &reason_code, &prop,\n\t\t        p->proto) != 0) {\n\t\t\trv = PROTOCOL_ERROR;\n\t\t\tgoto recv_error;\n\t\t}\n\t\tack_cmd = CMD_PUBREL;\n\t\tack     = true;\n\t\tbreak;\n\tcase CMD_PUBREL:\n\t\tif (flags == 0x02) {\n\t\t\tif (nni_mqtt_pubres_decode(msg, &packet_id, &reason_code,\n\t\t\t        &prop, p->proto) != 0) {\n\t\t\t\trv = PROTOCOL_ERROR;\n\t\t\t\tgoto recv_error;\n\t\t\t}\n\t\t\tack_cmd = CMD_PUBCOMP;\n\t\t\tack     = true;\n\t\t\tbreak;\n\t\t} else {\n\t\t\trv = PROTOCOL_ERROR;\n\t\t\tgoto recv_error;\n\t\t}\n\tcase CMD_PUBACK:\n\t\t// TODO set property for user callback\n\tcase CMD_PUBCOMP:\n\t\tif (nni_mqtt_pubres_decode(\n\t\t        msg, &packet_id, &reason_code, &prop, p->proto) != 0) {\n\t\t\trv = PROTOCOL_ERROR;\n\t\t\tgoto recv_error;\n\t\t}\n\t\tif (p->proto == MQTT_PROTOCOL_VERSION_v5) {\n\t\t\tp->sndmax++;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (ack == true) {\n\t\t// alloc a msg here costs memory. However we must do it for the\n\t\t// sake of compatibility with nng.\n\t\tif ((rv = nni_msg_alloc(&qmsg, 0)) != 0) {\n\t\t\tack = false;\n\t\t\trv  = UNSPECIFIED_ERROR;\n\t\t\tgoto recv_error;\n\t\t}\n\t\t// TODO set reason code or property here if necessary\n\t\tnni_mqtt_msgack_encode(\n\t\t    qmsg, packet_id, reason_code, prop, p->proto);\n\t\tnni_mqtt_pubres_header_encode(qmsg, ack_cmd);\n\t\tif (p->proto == MQTT_PROTOCOL_VERSION_v5) {\n\t\t\tproperty_free(prop);\n\t\t}\n\t\t// aio_begin?\n\t\tif (p->busy == false) {\n\t\t\tnni_msg_insert(qmsg, nni_msg_header(qmsg),\n\t\t\t    nni_msg_header_len(qmsg));\n\t\t\tiov.iov_len    = nni_msg_len(qmsg);\n\t\t\tiov.iov_buf    = nni_msg_body(qmsg);\n\t\t\tp->busy        = true;\n\t\t\tnni_aio_set_msg(p->qsaio, qmsg);\n\t\t\t// send ACK down...\n\t\t\tnni_aio_set_iov(p->qsaio, 1, &iov);\n\t\t\tnng_stream_send(p->conn, p->qsaio);\n\t\t} else {\n\t\t\tif (nni_lmq_full(&p->rslmq)) {\n\t\t\t\t// Make space for the new message. TODO add max\n\t\t\t\t// limit of msgq len in conf\n\t\t\t\tif (nni_lmq_cap(&p->rslmq) <=\n\t\t\t\t    NNG_TRAN_MAX_LMQ_SIZE) {\n\t\t\t\t\tif ((rv = nni_lmq_resize(&p->rslmq,\n\t\t\t\t\t         nni_lmq_cap(&p->rslmq) *\n\t\t\t\t\t             2)) == 0) {\n\t\t\t\t\t\tnni_lmq_put(&p->rslmq, qmsg);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// memory error.\n\t\t\t\t\t\tnni_msg_free(qmsg);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tnni_msg *old;\n\t\t\t\t\t(void) nni_lmq_get(&p->rslmq, &old);\n\t\t\t\t\tnni_msg_free(old);\n\t\t\t\t\tnni_lmq_put(&p->rslmq, qmsg);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnni_lmq_put(&p->rslmq, qmsg);\n\t\t\t}\n\t\t}\n\t\tack = false;\n\t}\n\n\t// keep connection & Schedule next receive\n\tnni_pipe_bump_rx(p->npipe, n);\n\tif (!nni_list_empty(&p->recvq)) {\n\t\tmqtts_tcptran_pipe_recv_start(p);\n\t}\n#ifdef NNG_HAVE_MQTT_BROKER\n\tnni_msg_set_conn_param(msg, p->cparam);\n#endif\n\tnni_aio_set_msg(aio, msg);\n\tp->pingcnt = 0;\n\tnni_mtx_unlock(&p->mtx);\n\tnni_aio_finish_sync(aio, 0, n);\n\treturn;\n\nrecv_error:\n\tnni_aio_list_remove(aio);\n\tmsg      = p->rxmsg;\n\tp->rxmsg = NULL;\n\tnni_pipe_bump_error(p->npipe, rv);\n\tnni_mtx_unlock(&p->mtx);\n\n\tnni_msg_free(msg);\n\tnni_aio_finish_error(aio, rv);\n}\n\nstatic void\nmqtts_tcptran_pipe_send_cancel(nni_aio *aio, void *arg, int rv)\n{\n\tmqtts_tcptran_pipe *p = arg;\n\n\tnni_mtx_lock(&p->mtx);\n\tif (!nni_aio_list_active(aio)) {\n\t\tnni_mtx_unlock(&p->mtx);\n\t\treturn;\n\t}\n\t// If this is being sent, then cancel the pending transfer.\n\t// The callback on the txaio will cause the user aio to\n\t// be canceled too.\n\tif (nni_list_first(&p->sendq) == aio) {\n\t\tnni_aio_abort(p->txaio, rv);\n\t\tnni_mtx_unlock(&p->mtx);\n\t\treturn;\n\t}\n\tnni_aio_list_remove(aio);\n\tnni_mtx_unlock(&p->mtx);\n\n\tnni_aio_finish_error(aio, rv);\n}\n\nstatic void\nmqtts_tcptran_pipe_send_start(mqtts_tcptran_pipe *p)\n{\n\tnni_aio *aio;\n\tnni_aio *txaio;\n\tnni_msg *msg;\n\tint      niov;\n\tnni_iov  iov[3];\n\n\tif (p->closed) {\n\t\twhile ((aio = nni_list_first(&p->sendq)) != NULL) {\n\t\t\tnni_list_remove(&p->sendq, aio);\n\t\t\tnni_aio_finish_error(aio, NNG_ECLOSED);\n\t\t}\n\t\treturn;\n\t}\n\n\tif ((aio = nni_list_first(&p->sendq)) == NULL) {\n\t\treturn;\n\t}\n\n\t// This runs to send the message.\n\tmsg = nni_aio_get_msg(aio);\n\n\tif (msg != NULL && p->proto == MQTT_PROTOCOL_VERSION_v5) {\n\t\tuint8_t *header = nni_msg_header(msg);\n\t\tif ((*header & 0XF0) == CMD_PUBLISH) {\n\t\t\t// check max qos\n\t\t\tuint8_t qos = nni_mqtt_msg_get_publish_qos(msg);\n\t\t\tif (qos > 0)\n\t\t\t\tp->sndmax --;\n\t\t\tif (qos > p->qosmax) {\n\t\t\t\tp->qosmax == 1? (*header &= 0XF9) & (*header |= 0X02):*header;\n\t\t\t\tp->qosmax == 0? *header &= 0XF9:*header;\n\t\t\t}\n\n\t\t}\n\t\t// check max packet size\n\t\tif (nni_msg_header_len(msg) + nni_msg_len(msg) > p->packmax) {\n\t\t\ttxaio = p->txaio;\n\t\t\tnni_aio_finish_error(txaio, UNSPECIFIED_ERROR);\n\t\t\treturn;\n\t\t}\n\t}\n\n\ttxaio = p->txaio;\n\tniov  = 0;\n\n\tif (nni_msg_header_len(msg) > 0) {\n\t\tiov[niov].iov_buf = nni_msg_header(msg);\n\t\tiov[niov].iov_len = nni_msg_header_len(msg);\n\t\tniov++;\n\t}\n\tif (nni_msg_len(msg) > 0) {\n\t\tiov[niov].iov_buf = nni_msg_body(msg);\n\t\tiov[niov].iov_len = nni_msg_len(msg);\n\t\tniov++;\n\t}\n\tnni_aio_set_iov(txaio, niov, iov);\n\tnng_stream_send(p->conn, txaio);\n}\n\nstatic void\nmqtts_tcptran_pipe_send(void *arg, nni_aio *aio)\n{\n\tmqtts_tcptran_pipe *p = arg;\n\tint                 rv;\n\n\tif (nni_aio_begin(aio) != 0) {\n\t\treturn;\n\t}\n\tnni_mtx_lock(&p->mtx);\n\tif ((rv = nni_aio_schedule(aio, mqtts_tcptran_pipe_send_cancel, p)) !=\n\t    0) {\n\t\tnni_mtx_unlock(&p->mtx);\n\t\tnni_aio_finish_error(aio, rv);\n\t\treturn;\n\t}\n\tnni_list_append(&p->sendq, aio);\n\tif (nni_list_first(&p->sendq) == aio) {\n\t\tmqtts_tcptran_pipe_send_start(p);\n\t}\n\tnni_mtx_unlock(&p->mtx);\n}\n\nstatic void\nmqtts_tcptran_pipe_recv_cancel(nni_aio *aio, void *arg, int rv)\n{\n\tmqtts_tcptran_pipe *p = arg;\n\n\tnni_mtx_lock(&p->mtx);\n\tif (!nni_aio_list_active(aio)) {\n\t\tnni_mtx_unlock(&p->mtx);\n\t\treturn;\n\t}\n\t// If receive in progress, then cancel the pending transfer.\n\t// The callback on the rxaio will cause the user aio to\n\t// be canceled too.\n\tif (nni_list_first(&p->recvq) == aio) {\n\t\tnni_aio_abort(p->rxaio, rv);\n\t\tnni_mtx_unlock(&p->mtx);\n\t\treturn;\n\t}\n\tnni_aio_list_remove(aio);\n\tnni_mtx_unlock(&p->mtx);\n\tnni_aio_finish_error(aio, rv);\n}\n\nstatic void\nmqtts_tcptran_pipe_recv_start(mqtts_tcptran_pipe *p)\n{\n\tnni_aio *rxaio;\n\tnni_iov  iov;\n\n\tif (p->closed) {\n\t\tnni_aio *aio;\n\t\twhile ((aio = nni_list_first(&p->recvq)) != NULL) {\n\t\t\tnni_list_remove(&p->recvq, aio);\n\t\t\tnni_aio_finish_error(aio, NNG_ECLOSED);\n\t\t}\n\t\treturn;\n\t}\n\tif (nni_list_empty(&p->recvq)) {\n\t\treturn;\n\t}\n\n\t// Schedule a read of the header.\n\trxaio         = p->rxaio;\n\tp->gotrxhead  = 0;\n\tp->wantrxhead = 2;\n\tiov.iov_buf   = p->rxlen;\n\tiov.iov_len   = 2;\n\tnni_aio_set_iov(rxaio, 1, &iov);\n\tnng_stream_recv(p->conn, rxaio);\n}\n\nstatic void\nmqtts_tcptran_pipe_recv(void *arg, nni_aio *aio)\n{\n\tmqtts_tcptran_pipe *p = arg;\n\tint                 rv;\n\n\tif (nni_aio_begin(aio) != 0) {\n\t\treturn;\n\t}\n\tnni_mtx_lock(&p->mtx);\n\tif ((rv = nni_aio_schedule(aio, mqtts_tcptran_pipe_recv_cancel, p)) !=\n\t    0) {\n\t\tnni_mtx_unlock(&p->mtx);\n\t\tnni_aio_finish_error(aio, rv);\n\t\treturn;\n\t}\n#ifdef NNG_HAVE_MQTT_BROKER\n\tif (p->connack != NULL) {\n\t\tnni_aio_set_msg(aio, p->connack);\n\t\tnni_msg_set_conn_param(p->connack, p->cparam);\n\t\tp->connack = NULL;\n\t\tnni_mtx_unlock(&p->mtx);\n\t\tnni_aio_finish(aio, 0, 0);\n\t\treturn;\n\t}\n#endif\n\tnni_list_append(&p->recvq, aio);\n\tif (nni_list_first(&p->recvq) == aio) {\n\t\tmqtts_tcptran_pipe_recv_start(p);\n\t}\n\tnni_mtx_unlock(&p->mtx);\n}\n\nstatic uint16_t\nmqtts_tcptran_pipe_peer(void *arg)\n{\n\tmqtts_tcptran_pipe *p = arg;\n\n\treturn (p->peer);\n}\n\nstatic int\nmqtts_tcptran_pipe_getopt(\n    void *arg, const char *name, void *buf, size_t *szp, nni_type t)\n{\n\tmqtts_tcptran_pipe *p = arg;\n\treturn (nni_stream_get(p->conn, name, buf, szp, t));\n}\n\nstatic void\nmqtts_tcptran_pipe_start(\n    mqtts_tcptran_pipe *p, nng_stream *conn, mqtts_tcptran_ep *ep)\n{\n\tnni_iov  iov[2];\n\tnni_msg *connmsg = NULL;\n\tuint8_t mqtt_version;\n\tint      niov = 0;\n\tint      rv;\n\n\tep->refcnt++;\n\n\tp->conn   = conn;\n\tp->ep     = ep;\n\tp->rcvmax = 0;\n\tp->sndmax = 65535;\n#ifdef NNG_HAVE_MQTT_BROKER\n\tp->cparam = NULL;\n#endif\n\tnni_dialer_getopt(ep->ndialer, NNG_OPT_MQTT_CONNMSG, &connmsg, NULL,\n\t    NNI_TYPE_POINTER);\n\n\tif (connmsg == NULL) {\n\t\tmqtt_version = 0;\n\t}\n\n\tmqtt_version = nni_mqtt_msg_get_connect_proto_version(connmsg);\n\n\tif (mqtt_version == MQTT_PROTOCOL_VERSION_v311)\n\t\trv = nni_mqtt_msg_encode(connmsg);\n\telse if (mqtt_version == MQTT_PROTOCOL_VERSION_v5) {\n\t\tproperty *prop = nni_mqtt_msg_get_connect_property(connmsg);\n\t\tproperty_data *data;\n\t\tdata = property_get_value(prop, MAXIMUM_PACKET_SIZE);\n\t\tif (data)\n\t\t\tp->rcvmax = data->p_value.u32;\n\t\trv = nni_mqttv5_msg_encode(connmsg);\n\t} else {\n\t\tnni_plat_printf(\"Warning. MQTT protocol version is not specificed.\\n\");\n\t\trv = 1;\n\t}\n\n\tif (rv != MQTT_SUCCESS ||\n\t   (mqtt_version != MQTT_PROTOCOL_VERSION_v311 &&\n\t    mqtt_version != MQTT_PROTOCOL_VERSION_v5)) {\n\t\t// Free the msg from user\n\t\tnni_msg_free(connmsg);\n\t\tnni_plat_printf(\"Warning. Cancelled a illegal connnect msg from user.\\n\");\n\t\t// Using MQTT V311 as default protocol version\n\t\tmqtt_version = 4; // Default TODO Notify user as a warning\n\t\tnni_mqtt_msg_alloc(&connmsg, 0);\n\t\tnni_mqtt_msg_set_packet_type(connmsg, NNG_MQTT_CONNECT);\n\t\tnni_mqtt_msg_set_connect_proto_version(\n\t\t    connmsg, MQTT_PROTOCOL_VERSION_v311);\n\t\tnni_mqtt_msg_set_connect_keep_alive(connmsg, 60);\n\t\tnni_mqtt_msg_set_connect_clean_session(connmsg, true);\n\t}\n\n\tp->gotrxhead  = 0;\n\tp->gottxhead  = 0;\n\tp->wantrxhead = 2;\n\tp->wanttxhead = nni_msg_header_len(connmsg) + nni_msg_len(connmsg);\n\tp->rxmsg      = NULL;\n\tp->keepalive  = nni_mqtt_msg_get_connect_keep_alive(connmsg) * 1000;\n\tp->proto      = mqtt_version;\n\n\tif (nni_msg_len(connmsg) > 0) {\n\t\tnni_msg_insert(connmsg, nni_msg_header(connmsg),\n\t\t    nni_msg_header_len(connmsg));\n\t\tiov[niov].iov_buf = nni_msg_body(connmsg);\n\t\tiov[niov].iov_len = nni_msg_len(connmsg);\n\t\tniov++;\n\t}\n\tnni_aio_set_iov(p->negoaio, niov, iov);\n\tnni_list_append(&ep->negopipes, p);\n\n\tnni_aio_set_timeout(p->negoaio, 10000); // 10 sec timeout to negotiate\n\tnng_stream_send(p->conn, p->negoaio);\n}\n\nstatic void\nmqtts_tcptran_ep_fini(void *arg)\n{\n\tmqtts_tcptran_ep *ep = arg;\n\n\tnni_mtx_lock(&ep->mtx);\n\tep->fini = true;\n\tif (ep->refcnt != 0) {\n\t\tnni_mtx_unlock(&ep->mtx);\n\t\treturn;\n\t}\n\tnni_mtx_unlock(&ep->mtx);\n\tnni_aio_stop(ep->timeaio);\n\tnni_aio_stop(ep->connaio);\n\tnng_stream_dialer_free(ep->dialer);\n\tnng_stream_listener_free(ep->listener);\n\tnni_aio_free(ep->timeaio);\n\tnni_aio_free(ep->connaio);\n\tproperty_free(ep->property);\n\n\tnni_mtx_fini(&ep->mtx);\n\tNNI_FREE_STRUCT(ep);\n}\n\nstatic void\nmqtts_tcptran_ep_close(void *arg)\n{\n\tmqtts_tcptran_ep *  ep = arg;\n\tmqtts_tcptran_pipe *p;\n\n\tnni_mtx_lock(&ep->mtx);\n\n\tep->closed = true;\n\tnni_aio_close(ep->timeaio);\n\tif (ep->dialer != NULL) {\n\t\tnng_stream_dialer_close(ep->dialer);\n\t}\n\tif (ep->listener != NULL) {\n\t\tnng_stream_listener_close(ep->listener);\n\t}\n\tNNI_LIST_FOREACH (&ep->negopipes, p) {\n\t\tmqtts_tcptran_pipe_close(p);\n\t}\n\tNNI_LIST_FOREACH (&ep->waitpipes, p) {\n\t\tmqtts_tcptran_pipe_close(p);\n\t}\n\tNNI_LIST_FOREACH (&ep->busypipes, p) {\n\t\tmqtts_tcptran_pipe_close(p);\n\t}\n\tif (ep->useraio != NULL) {\n\t\tnni_aio_finish_error(ep->useraio, NNG_ECLOSED);\n\t\tep->useraio = NULL;\n\t}\n\n\tnni_mtx_unlock(&ep->mtx);\n}\n\n// This parses off the optional source address that this transport\n// uses. The special handling of this URL format is quite honestly an\n// historical mistake, which we would remove if we could.\nstatic int\nmqtts_tcptran_url_parse_source(\n    nng_url *url, nng_sockaddr *sa, const nng_url *surl)\n{\n\tint      af;\n\tchar *   semi;\n\tchar *   src;\n\tsize_t   len;\n\tint      rv;\n\tnni_aio *aio;\n\n\t// We modify the URL.  This relies on the fact that the\n\t// underlying transport does not free this, so we can just use\n\t// references.\n\n\turl->u_scheme   = surl->u_scheme;\n\turl->u_port     = surl->u_port;\n\turl->u_hostname = surl->u_hostname;\n\n\tif ((semi = strchr(url->u_hostname, ';')) == NULL) {\n\t\tmemset(sa, 0, sizeof(*sa));\n\t\treturn (0);\n\t}\n\n\tlen             = (size_t) (semi - url->u_hostname);\n\turl->u_hostname = semi + 1;\n\n\tif (strcmp(surl->u_scheme, \"tls+tcp\") == 0) {\n\t\taf = NNG_AF_UNSPEC;\n\t} else if (strcmp(surl->u_scheme, \"tls+tcp4\") == 0) {\n\t\taf = NNG_AF_INET;\n\t} else if (strcmp(surl->u_scheme, \"tls+tcp6\") == 0) {\n\t\taf = NNG_AF_INET6;\n\t} else {\n\t\treturn (NNG_EADDRINVAL);\n\t}\n\n\tif ((src = nni_alloc(len + 1)) == NULL) {\n\t\treturn (NNG_ENOMEM);\n\t}\n\tmemcpy(src, surl->u_hostname, len);\n\tsrc[len] = '\\0';\n\n\tif ((rv = nni_aio_alloc(&aio, NULL, NULL)) != 0) {\n\t\tnni_free(src, len + 1);\n\t\treturn (rv);\n\t}\n\n\tnni_resolv_ip(src, \"0\", af, true, sa, aio);\n\tnni_aio_wait(aio);\n\trv = nni_aio_result(aio);\n\tnni_aio_free(aio);\n\tnni_free(src, len + 1);\n\treturn (rv);\n}\n\nstatic void\nmqtts_tcptran_timer_cb(void *arg)\n{\n\tmqtts_tcptran_ep *ep = arg;\n\tif (nni_aio_result(ep->timeaio) == 0) {\n\t\tnng_stream_listener_accept(ep->listener, ep->connaio);\n\t}\n}\n\nstatic void\nmqtts_tcptran_accept_cb(void *arg)\n{\n\tmqtts_tcptran_ep *  ep  = arg;\n\tnni_aio *           aio = ep->connaio;\n\tmqtts_tcptran_pipe *p;\n\tint                 rv;\n\tnng_stream *        conn;\n\n\tnni_mtx_lock(&ep->mtx);\n\n\tif ((rv = nni_aio_result(aio)) != 0) {\n\t\tgoto error;\n\t}\n\n\tconn = nni_aio_get_output(aio, 0);\n\tif ((rv = mqtts_tcptran_pipe_alloc(&p)) != 0) {\n\t\tnng_stream_free(conn);\n\t\tgoto error;\n\t}\n\n\tif (ep->closed) {\n\t\tmqtts_tcptran_pipe_fini(p);\n\t\tnng_stream_free(conn);\n\t\trv = NNG_ECLOSED;\n\t\tgoto error;\n\t}\n\tmqtts_tcptran_pipe_start(p, conn, ep);\n\tnng_stream_listener_accept(ep->listener, ep->connaio);\n\tnni_mtx_unlock(&ep->mtx);\n\treturn;\n\nerror:\n\t// When an error here occurs, let's send a notice up to the\n\t// consumer. That way it can be reported properly.\n\tif ((aio = ep->useraio) != NULL) {\n\t\tep->useraio = NULL;\n\t\tnni_aio_finish_error(aio, rv);\n\t}\n\tswitch (rv) {\n\n\tcase NNG_ENOMEM:\n\tcase NNG_ENOFILES:\n\t\tnng_sleep_aio(10, ep->timeaio);\n\t\tbreak;\n\n\tdefault:\n\t\tif (!ep->closed) {\n\t\t\tnng_stream_listener_accept(ep->listener, ep->connaio);\n\t\t}\n\t\tbreak;\n\t}\n\tnni_mtx_unlock(&ep->mtx);\n}\n\nstatic void\nmqtts_tcptran_dial_cb(void *arg)\n{\n\tmqtts_tcptran_ep *  ep  = arg;\n\tnni_aio *           aio = ep->connaio;\n\tmqtts_tcptran_pipe *p;\n\tint                 rv;\n\tnng_stream *        conn;\n\n\tif ((rv = nni_aio_result(aio)) != 0) {\n\t\tgoto error;\n\t}\n\n\tconn = nni_aio_get_output(aio, 0);\n\tif ((rv = mqtts_tcptran_pipe_alloc(&p)) != 0) {\n\t\tnng_stream_free(conn);\n\t\tgoto error;\n\t}\n\tnni_mtx_lock(&ep->mtx);\n\tif (ep->closed) {\n\t\tmqtts_tcptran_pipe_fini(p);\n\t\tnng_stream_free(conn);\n\t\trv = NNG_ECLOSED;\n\t\tnni_mtx_unlock(&ep->mtx);\n\t\tgoto error;\n\t} else {\n\t\tmqtts_tcptran_pipe_start(p, conn, ep);\n\t}\n\tnni_mtx_unlock(&ep->mtx);\n\treturn;\n\nerror:\n\t// Error connecting.  We need to pass this straight back\n\t// to the user.\n\tnni_mtx_lock(&ep->mtx);\n\tif ((aio = ep->useraio) != NULL) {\n\t\tep->useraio = NULL;\n\t\tnni_aio_finish_error(aio, rv);\n\t}\n\tnni_mtx_unlock(&ep->mtx);\n}\n\nstatic int\nmqtts_tcptran_ep_init(mqtts_tcptran_ep **epp, nng_url *url, nni_sock *sock)\n{\n\tmqtts_tcptran_ep *ep;\n\n\tif ((ep = NNI_ALLOC_STRUCT(ep)) == NULL) {\n\t\treturn (NNG_ENOMEM);\n\t}\n\tnni_mtx_init(&ep->mtx);\n\tNNI_LIST_INIT(&ep->busypipes, mqtts_tcptran_pipe, node);\n\tNNI_LIST_INIT(&ep->waitpipes, mqtts_tcptran_pipe, node);\n\tNNI_LIST_INIT(&ep->negopipes, mqtts_tcptran_pipe, node);\n\n\tep->proto       = nni_sock_proto_id(sock);\n\tep->url         = url;\n\tep->connmsg     = NULL;\n\tep->reason_code = 0;\n\tep->property    = NULL;\n\n#ifdef NNG_ENABLE_STATS\n\tstatic const nni_stat_info rcv_max_info = {\n\t\t.si_name   = \"rcv_max\",\n\t\t.si_desc   = \"maximum receive size\",\n\t\t.si_type   = NNG_STAT_LEVEL,\n\t\t.si_unit   = NNG_UNIT_BYTES,\n\t\t.si_atomic = true,\n\t};\n\tnni_stat_init(&ep->st_rcv_max, &rcv_max_info);\n#endif\n\n\t*epp = ep;\n\treturn (0);\n}\n\nstatic int\nmqtts_tcptran_dialer_init(void **dp, nng_url *url, nni_dialer *ndialer)\n{\n\tmqtts_tcptran_ep *ep;\n\tint               rv;\n\tnng_sockaddr      srcsa;\n\tnni_sock *        sock = nni_dialer_sock(ndialer);\n\tnng_url           myurl;\n\n\t// Check for invalid URL components. only one dialer is allowed\n\tif ((strlen(url->u_path) != 0) && (strcmp(url->u_path, \"/\") != 0)) {\n\t\treturn (NNG_EADDRINVAL);\n\t}\n\tif ((url->u_fragment != NULL) || (url->u_userinfo != NULL) ||\n\t    (url->u_query != NULL) || (strlen(url->u_hostname) == 0) ||\n\t    (strlen(url->u_port) == 0)) {\n\t\treturn (NNG_EADDRINVAL);\n\t}\n\n\tif ((rv = mqtts_tcptran_url_parse_source(&myurl, &srcsa, url)) != 0) {\n\t\treturn (rv);\n\t}\n\n\tif (((rv = mqtts_tcptran_ep_init(&ep, url, sock)) != 0) ||\n\t    ((rv = nni_aio_alloc(&ep->connaio, mqtts_tcptran_dial_cb, ep)) !=\n\t        0)) {\n\t\treturn (rv);\n\t}\n\tep->ndialer  = ndialer;\n\tep->authmode = NNG_TLS_AUTH_MODE_REQUIRED;\n\n\tif ((rv != 0) ||\n\t    ((rv = nng_stream_dialer_alloc_url(&ep->dialer, &myurl)) != 0)) {\n\t\tmqtts_tcptran_ep_fini(ep);\n\t\treturn (rv);\n\t}\n\tif ((srcsa.s_family != NNG_AF_UNSPEC) &&\n\t    ((rv = nni_stream_dialer_set(ep->dialer, NNG_OPT_LOCADDR, &srcsa,\n\t          sizeof(srcsa), NNI_TYPE_SOCKADDR)) != 0)) {\n\t\tmqtts_tcptran_ep_fini(ep);\n\t\treturn (rv);\n\t}\n#ifdef NNG_ENABLE_STATS\n#endif\n\t*dp = ep;\n\treturn (0);\n}\n\nstatic int\nmqtts_tcptran_listener_init(void **lp, nng_url *url, nni_listener *nlistener)\n{\n\tmqtts_tcptran_ep *ep;\n\tuint16_t          af;\n\tchar *            host = url->u_hostname;\n\tnni_aio *         aio;\n\tint               rv;\n\tnni_sock *        sock = nni_listener_sock(nlistener);\n\n\tif (strcmp(url->u_scheme, \"tls+tcp\") == 0) {\n\t\taf = NNG_AF_UNSPEC;\n\t} else if (strcmp(url->u_scheme, \"tls+tcp4\") == 0) {\n\t\taf = NNG_AF_INET;\n\t} else if (strcmp(url->u_scheme, \"tls+tcp6\") == 0) {\n\t\taf = NNG_AF_INET6;\n\t} else {\n\t\treturn (NNG_EADDRINVAL);\n\t}\n\n\t// Check for invalid URL components.\n\tif ((strlen(url->u_path) != 0) && (strcmp(url->u_path, \"/\") != 0)) {\n\t\treturn (NNG_EADDRINVAL);\n\t}\n\tif ((url->u_fragment != NULL) || (url->u_userinfo != NULL) ||\n\t    (url->u_query != NULL)) {\n\t\treturn (NNG_EADDRINVAL);\n\t}\n\n\tif (((rv = mqtts_tcptran_ep_init(&ep, url, sock)) != 0) ||\n\t    ((rv = nni_aio_alloc(&ep->connaio, mqtts_tcptran_accept_cb, ep)) !=\n\t        0) ||\n\t    ((rv = nni_aio_alloc(&ep->timeaio, mqtts_tcptran_timer_cb, ep)) !=\n\t        0)) {\n\t\treturn (rv);\n\t}\n\n\tep->authmode = NNG_TLS_AUTH_MODE_NONE;\n\n\tif (strlen(host) == 0) {\n\t\thost = NULL;\n\t}\n\n\t// XXX: We are doing lookup at listener initialization.  There\n\t// is a valid argument that this should be done at bind time,\n\t// but that would require making bind asynchronous.  In some\n\t// ways this would be worse than the cost of just waiting here.\n\t// We always recommend using local IP addresses rather than\n\t// names when possible.\n\n\tif ((rv = nni_aio_alloc(&aio, NULL, NULL)) != 0) {\n\t\tmqtts_tcptran_ep_fini(ep);\n\t\treturn (rv);\n\t}\n\tnni_resolv_ip(host, url->u_port, af, true, &ep->sa, aio);\n\tnni_aio_wait(aio);\n\trv = nni_aio_result(aio);\n\tnni_aio_free(aio);\n\n\tif (((rv = nng_stream_listener_alloc_url(&ep->listener, url)) != 0) ||\n\t    ((rv = nni_stream_listener_set(ep->listener, NNG_OPT_TLS_AUTH_MODE,\n\t          &ep->authmode, sizeof(ep->authmode), NNI_TYPE_INT32)) !=\n\t        0)) {\n\t\tmqtts_tcptran_ep_fini(ep);\n\t\treturn (rv);\n\t}\n#ifdef NNG_ENABLE_STATS\n\tnni_listener_add_stat(nlistener, &ep->st_rcv_max);\n#endif\n\n\t*lp = ep;\n\treturn (0);\n}\n\nstatic void\nmqtts_tcptran_ep_cancel(nni_aio *aio, void *arg, int rv)\n{\n\tmqtts_tcptran_ep *ep = arg;\n\tnni_mtx_lock(&ep->mtx);\n\tif (ep->useraio == aio) {\n\t\tep->useraio = NULL;\n\t\tnni_aio_finish_error(aio, rv);\n\t}\n\tnni_mtx_unlock(&ep->mtx);\n}\n\nstatic void\nmqtts_tcptran_ep_connect(void *arg, nni_aio *aio)\n{\n\tmqtts_tcptran_ep *ep = arg;\n\tint               rv;\n\n\tif (nni_aio_begin(aio) != 0) {\n\t\treturn;\n\t}\n\tnni_mtx_lock(&ep->mtx);\n\tif (ep->closed) {\n\t\tnni_mtx_unlock(&ep->mtx);\n\t\tnni_aio_finish_error(aio, NNG_ECLOSED);\n\t\treturn;\n\t}\n\tif (ep->useraio != NULL) {\n\t\tnni_mtx_unlock(&ep->mtx);\n\t\tnni_aio_finish_error(aio, NNG_EBUSY);\n\t\treturn;\n\t}\n\tif ((rv = nni_aio_schedule(aio, mqtts_tcptran_ep_cancel, ep)) != 0) {\n\t\tnni_mtx_unlock(&ep->mtx);\n\t\tnni_aio_finish_error(aio, rv);\n\t\treturn;\n\t}\n\tep->useraio = aio;\n\n\tnng_stream_dialer_dial(ep->dialer, ep->connaio);\n\tnni_mtx_unlock(&ep->mtx);\n}\n\nstatic int\nmqtts_tcptran_ep_get_url(void *arg, void *v, size_t *szp, nni_opt_type t)\n{\n\tmqtts_tcptran_ep *ep = arg;\n\tchar *            s;\n\tint               rv;\n\tint               port = 0;\n\n\tif (ep->listener != NULL) {\n\t\t(void) nng_stream_listener_get_int(\n\t\t    ep->listener, NNG_OPT_TCP_BOUND_PORT, &port);\n\t}\n\n\tif ((rv = nni_url_asprintf_port(&s, ep->url, port)) == 0) {\n\t\trv = nni_copyout_str(s, v, szp, t);\n\t\tnni_strfree(s);\n\t}\n\treturn (rv);\n}\n\nstatic int\nmqtts_tcptran_ep_get_connmsg(void *arg, void *v, size_t *szp, nni_opt_type t)\n{\n\tmqtts_tcptran_ep *ep = arg;\n\tint               rv;\n\n\tnni_copyout_ptr(ep->connmsg, v, szp, t);\n\trv = 0;\n\n\treturn (rv);\n}\n\nstatic int\nmqtts_tcptran_ep_set_connmsg(\n    void *arg, const void *v, size_t sz, nni_opt_type t)\n{\n\tmqtts_tcptran_ep *ep = arg;\n\tint              rv;\n\n\tnni_mtx_lock(&ep->mtx);\n\trv = nni_copyin_ptr(&ep->connmsg, v, sz, t);\n\tnni_mtx_unlock(&ep->mtx);\n\n\treturn (rv);\n}\n\nstatic int\nmqtts_tcptran_ep_get_reasoncode(void *arg, void *v, size_t *sz, nni_opt_type t)\n{\n\tNNI_ARG_UNUSED(sz);\n\tmqtts_tcptran_ep *ep = arg;\n\tint              rv;\n\n\tnni_mtx_lock(&ep->mtx);\n\trv = nni_copyin_int(v, &ep->reason_code, sizeof(ep->reason_code), 0, 256, t);\n\tnni_mtx_unlock(&ep->mtx);\n\treturn (rv);\n}\n\nstatic int\nmqtts_tcptran_ep_get_property(void *arg, void *v, size_t *szp, nni_opt_type t)\n{\n\tmqtts_tcptran_ep *ep = arg;\n\tint              rv;\n\n\trv = nni_copyout_ptr(ep->property, v, szp, t);\n\treturn (rv);\n}\n\nstatic int\nmqtts_tcptran_ep_bind(void *arg)\n{\n\tmqtts_tcptran_ep *ep = arg;\n\tint               rv;\n\n\tnni_mtx_lock(&ep->mtx);\n\trv = nng_stream_listener_listen(ep->listener);\n\tnni_mtx_unlock(&ep->mtx);\n\n\treturn (rv);\n}\n\nstatic void\nmqtts_tcptran_ep_accept(void *arg, nni_aio *aio)\n{\n\tmqtts_tcptran_ep *ep = arg;\n\tint               rv;\n\n\tif (nni_aio_begin(aio) != 0) {\n\t\treturn;\n\t}\n\tnni_mtx_lock(&ep->mtx);\n\tif (ep->closed) {\n\t\tnni_mtx_unlock(&ep->mtx);\n\t\tnni_aio_finish_error(aio, NNG_ECLOSED);\n\t\treturn;\n\t}\n\tif (ep->useraio != NULL) {\n\t\tnni_mtx_unlock(&ep->mtx);\n\t\tnni_aio_finish_error(aio, NNG_EBUSY);\n\t\treturn;\n\t}\n\tif ((rv = nni_aio_schedule(aio, mqtts_tcptran_ep_cancel, ep)) != 0) {\n\t\tnni_mtx_unlock(&ep->mtx);\n\t\tnni_aio_finish_error(aio, rv);\n\t\treturn;\n\t}\n\tep->useraio = aio;\n\tif (!ep->started) {\n\t\tep->started = true;\n\t\tnng_stream_listener_accept(ep->listener, ep->connaio);\n\t} else {\n\t\tmqtts_tcptran_ep_match(ep);\n\t}\n\tnni_mtx_unlock(&ep->mtx);\n}\n\nstatic nni_sp_pipe_ops mqtts_tcptran_pipe_ops = {\n\t.p_init   = mqtts_tcptran_pipe_init,\n\t.p_fini   = mqtts_tcptran_pipe_fini,\n\t.p_stop   = mqtts_tcptran_pipe_stop,\n\t.p_send   = mqtts_tcptran_pipe_send,\n\t.p_recv   = mqtts_tcptran_pipe_recv,\n\t.p_close  = mqtts_tcptran_pipe_close,\n\t.p_peer   = mqtts_tcptran_pipe_peer,\n\t.p_getopt = mqtts_tcptran_pipe_getopt,\n};\n\nstatic const nni_option mqtts_tcptran_ep_opts[] = {\n\t{\n\t    .o_name = NNG_OPT_MQTT_CONNECT_REASON,\n\t    .o_get  = mqtts_tcptran_ep_get_reasoncode,\n\t},\n\t{\n\t    .o_name = NNG_OPT_MQTT_CONNECT_PROPERTY,\n\t    .o_get  = mqtts_tcptran_ep_get_property,\n\t},\n\t{\n\t    .o_name = NNG_OPT_MQTT_CONNMSG,\n\t    .o_get  = mqtts_tcptran_ep_get_connmsg,\n\t    .o_set  = mqtts_tcptran_ep_set_connmsg,\n\t},\n\t{\n\t    .o_name = NNG_OPT_URL,\n\t    .o_get  = mqtts_tcptran_ep_get_url,\n\t},\n\t// terminate list\n\t{\n\t    .o_name = NULL,\n\t},\n};\n\nstatic int\nmqtts_tcptran_dialer_getopt(\n    void *arg, const char *name, void *buf, size_t *szp, nni_type t)\n{\n\tmqtts_tcptran_ep *ep = arg;\n\tint               rv;\n\n\trv = nni_stream_dialer_get(ep->dialer, name, buf, szp, t);\n\tif (rv == NNG_ENOTSUP) {\n\t\trv = nni_getopt(mqtts_tcptran_ep_opts, name, ep, buf, szp, t);\n\t}\n\treturn (rv);\n}\n\nstatic int\nmqtts_tcptran_dialer_setopt(\n    void *arg, const char *name, const void *buf, size_t sz, nni_type t)\n{\n\tmqtts_tcptran_ep *ep = arg;\n\tint               rv;\n\n\t// TODO get mqtts dialer's option\n\trv = nni_stream_dialer_set(ep->dialer, name, buf, sz, t);\n\tif (rv == NNG_ENOTSUP) {\n\t\trv = nni_setopt(mqtts_tcptran_ep_opts, name, ep, buf, sz, t);\n\t}\n\treturn (rv);\n}\n\nstatic int\nmqtts_tcptran_listener_getopt(\n    void *arg, const char *name, void *buf, size_t *szp, nni_type t)\n{\n\tmqtts_tcptran_ep *ep = arg;\n\tint               rv;\n\n\trv = nni_stream_listener_get(ep->listener, name, buf, szp, t);\n\tif (rv == NNG_ENOTSUP) {\n\t\trv = nni_getopt(mqtts_tcptran_ep_opts, name, ep, buf, szp, t);\n\t}\n\treturn (rv);\n}\n\nstatic int\nmqtts_tcptran_listener_setopt(\n    void *arg, const char *name, const void *buf, size_t sz, nni_type t)\n{\n\tmqtts_tcptran_ep *ep = arg;\n\tint               rv;\n\n\trv = nni_stream_listener_set(ep->listener, name, buf, sz, t);\n\tif (rv == NNG_ENOTSUP) {\n\t\trv = nni_setopt(mqtts_tcptran_ep_opts, name, ep, buf, sz, t);\n\t}\n\treturn (rv);\n}\n\nstatic nni_sp_dialer_ops mqtts_tcptran_dialer_ops = {\n\t.d_init    = mqtts_tcptran_dialer_init,\n\t.d_fini    = mqtts_tcptran_ep_fini,\n\t.d_connect = mqtts_tcptran_ep_connect,\n\t.d_close   = mqtts_tcptran_ep_close,\n\t.d_getopt  = mqtts_tcptran_dialer_getopt,\n\t.d_setopt  = mqtts_tcptran_dialer_setopt,\n};\n\nstatic nni_sp_listener_ops mqtts_tcptran_listener_ops = {\n\t.l_init   = mqtts_tcptran_listener_init,\n\t.l_fini   = mqtts_tcptran_ep_fini,\n\t.l_bind   = mqtts_tcptran_ep_bind,\n\t.l_accept = mqtts_tcptran_ep_accept,\n\t.l_close  = mqtts_tcptran_ep_close,\n\t.l_getopt = mqtts_tcptran_listener_getopt,\n\t.l_setopt = mqtts_tcptran_listener_setopt,\n};\n\nstatic nni_sp_tran mqtts_tcp_tran = {\n\t.tran_scheme   = \"tls+mqtt-tcp\",\n\t.tran_dialer   = &mqtts_tcptran_dialer_ops,\n\t.tran_listener = &mqtts_tcptran_listener_ops,\n\t.tran_pipe     = &mqtts_tcptran_pipe_ops,\n\t.tran_init     = mqtts_tcptran_init,\n\t.tran_fini     = mqtts_tcptran_fini,\n};\n\nstatic nni_sp_tran mqtts_tcp4_tran = {\n\t.tran_scheme   = \"tls+mqtt-tcp4\",\n\t.tran_dialer   = &mqtts_tcptran_dialer_ops,\n\t.tran_listener = &mqtts_tcptran_listener_ops,\n\t.tran_pipe     = &mqtts_tcptran_pipe_ops,\n\t.tran_init     = mqtts_tcptran_init,\n\t.tran_fini     = mqtts_tcptran_fini,\n};\n\nstatic nni_sp_tran mqtts_tcp6_tran = {\n\t.tran_scheme   = \"tls+mqtt-tcp6\",\n\t.tran_dialer   = &mqtts_tcptran_dialer_ops,\n\t.tran_listener = &mqtts_tcptran_listener_ops,\n\t.tran_pipe     = &mqtts_tcptran_pipe_ops,\n\t.tran_init     = mqtts_tcptran_init,\n\t.tran_fini     = mqtts_tcptran_fini,\n};\n\n#ifndef NNG_ELIDE_DEPRECATED\nint\nnng_mqtts_tcp_register(void)\n{\n\treturn (nni_init());\n}\n#endif\n\nvoid\nnni_mqtts_tcp_register(void)\n{\n\tnni_mqtt_tran_register(&mqtts_tcp_tran);\n\tnni_mqtt_tran_register(&mqtts_tcp4_tran);\n\tnni_mqtt_tran_register(&mqtts_tcp6_tran);\n}\n", "//\n// Copyright 2022 NanoMQ Team, Inc. <jaylin@emqx.io>\n//\n// This software is supplied under the terms of the MIT License, a\n// copy of which should be located in the distribution where this\n// file was obtained (LICENSE.txt).  A copy of the license may also be\n// found online at https://opensource.org/licenses/MIT.\n//\n#include \"nng/supplemental/nanolib/conf.h\"\n#include \"nng/supplemental/nanolib/conf.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"core/nng_impl.h\"\n#include \"core/sockimpl.h\"\n\n#include \"nng/protocol/mqtt/mqtt.h\"\n#include \"nng/protocol/mqtt/mqtt_parser.h\"\n#include \"nng/supplemental/tls/tls.h\"\n#include \"supplemental/mqtt/mqtt_qos_db_api.h\"\n#include \"supplemental/mqtt/mqtt_msg.h\"\n\n// TLS over TCP transport.   Platform specific TLS Over TCP operations must be\n// supplied as well.\n\ntypedef struct tlstran_pipe tlstran_pipe;\ntypedef struct tlstran_ep   tlstran_ep;\n\nstatic inline void\ntlstran_pipe_send_start_v4(tlstran_pipe *p, nni_msg *msg, nni_aio *aio);\nstatic inline void\ntlstran_pipe_send_start_v5(tlstran_pipe *p, nni_msg *msg, nni_aio *aio);\n\n// tcp_pipe is one end of a TCP connection.\nstruct tlstran_pipe {\n\tnng_stream *conn;\n\tnni_pipe   *npipe; // for statitical\n\tconf       *conf;\n\t// uint16_t        peer;\t\t//reserved for MQTT sdk version\n\t// uint16_t        proto;\n\tsize_t          rcvmax;\n\tsize_t          gotrxhead;\n\tsize_t          wantrxhead;\n\tbool            closed;\n\tbool            busy; // indicator for qos ack & aio\n\tuint8_t         txlen[NANO_MIN_PACKET_LEN];\n\tuint8_t         rxlen[NNI_NANO_MAX_HEADER_SIZE];\n\tuint8_t        *conn_buf;\n\tuint8_t        *qos_buf;\n\tnni_aio        *txaio;\n\tnni_aio        *rxaio;\n\tnni_aio        *qsaio;\n\tnni_aio        *rpaio;\n\tnni_aio        *negoaio;\n\tnni_lmq         rslmq;\n\tnni_msg        *rxmsg, *cnmsg;\n\tnni_mtx         mtx;\n\tconn_param     *tcp_cparam;\n\tnni_list        recvq;\n\tnni_list        sendq;\n\tnni_list_node   node;\n\ttlstran_ep     *ep;\n\tnni_atomic_flag reaped;\n\tnni_reap_node   reap;\n\t// uint8_t       sli_win[5];\t//use aio multiple times instead of\n\t// seperating 2 packets manually\n\t// MQTT V5\n\tuint16_t qrecv_quota;\n\tuint32_t qsend_quota;\n};\n\nstruct tlstran_ep {\n\tnni_mtx mtx;\n\t// uint16_t             proto;\n\tsize_t               rcvmax;\n\tconf *               conf;\n\tbool                 fini;\n\tbool                 started;\n\tbool                 closed;\n\tnng_url *            url;\n\tnng_sockaddr         src;\n\tnng_sockaddr         sa;\n\tint                  refcnt; // active pipes\n\tint                  authmode;\n\tnni_aio *            useraio;\n\tnni_aio *            connaio;\n\tnni_aio *            timeaio;\n\tnni_list             busypipes; // busy pipes -- ones passed to socket\n\tnni_list             waitpipes; // pipes waiting to match to socket\n\tnni_list             negopipes; // pipes busy negotiating\n\tnni_reap_node        reap;\n\tnng_stream_listener *listener;\n#ifdef NNG_ENABLE_STATS\n\tnni_stat_item st_rcv_max;\n#endif\n};\n\nstatic void tlstran_pipe_send_start(tlstran_pipe *);\nstatic void tlstran_pipe_recv_start(tlstran_pipe *);\nstatic void tlstran_pipe_qos_send_cb(void *);\nstatic void tlstran_pipe_send_cb(void *);\nstatic void tlstran_pipe_recv_cb(void *);\nstatic void tlstran_pipe_nego_cb(void *);\nstatic void tlstran_ep_fini(void *);\nstatic void tlstran_pipe_fini(void *);\n\nstatic inline void\ntlstran_pipe_send_start_v5(tlstran_pipe *p, nni_msg *msg, nni_aio *aio);\n\nstatic nni_reap_list tlstran_ep_reap_list = {\n\t.rl_offset = offsetof(tlstran_ep, reap),\n\t.rl_func   = tlstran_ep_fini,\n};\n\nstatic nni_reap_list tlstran_pipe_reap_list = {\n\t.rl_offset = offsetof(tlstran_pipe, reap),\n\t.rl_func   = tlstran_pipe_fini,\n};\n\nstatic void\ntlstran_init(void)\n{\n}\n\nstatic void\ntlstran_fini(void)\n{\n}\n\nstatic void\ntlstran_pipe_close(void *arg)\n{\n\ttlstran_pipe *p = arg;\n\t// nni_pipe *    npipe = p->npipe;\n\n\tnni_mtx_lock(&p->mtx);\n\tp->closed = true;\n\tlog_trace(\" ###### tlstran_pipe_close ###### \");\n\t// p->closed = true;\n\n\tnni_lmq_flush(&p->rslmq);\n\tnni_mtx_unlock(&p->mtx);\n\n\tnni_aio_close(p->rxaio);\n\tnni_aio_close(p->rpaio);\n\tnni_aio_close(p->txaio);\n\tnni_aio_close(p->qsaio);\n\tnni_aio_close(p->negoaio);\n\n\tnng_stream_close(p->conn);\n}\n\nstatic void\ntlstran_pipe_stop(void *arg)\n{\n\ttlstran_pipe *p = arg;\n\tlog_trace(\" ###### tlstran_pipe_stop ###### \");\n\tp->tcp_cparam = NULL;\n\tnni_aio_stop(p->qsaio);\n\tnni_aio_stop(p->rpaio);\n\tnni_aio_stop(p->rxaio);\n\tnni_aio_stop(p->txaio);\n\tnni_aio_stop(p->negoaio);\n}\n\nstatic int\ntlstran_pipe_init(void *arg, nni_pipe *npipe)\n{\n\tlog_trace(\"************tlstran_pipe_init************\");\n\ttlstran_pipe *p = arg;\n\n\tnni_pipe_set_conn_param(npipe, p->tcp_cparam);\n\tp->npipe    = npipe;\n\n\tif (!p->conf->sqlite.enable) {\n\t\tnni_qos_db_init_id_hash(npipe->nano_qos_db);\n\t}\n\n\tp->conn_buf = NULL;\n\tp->busy     = false;\n\n\tnni_lmq_init(&p->rslmq, 16);\n\tp->qos_buf = nng_zalloc(16 + NNI_NANO_MAX_PACKET_SIZE);\n\treturn (0);\n}\n\nstatic void\ntlstran_pipe_fini(void *arg)\n{\n\ttlstran_pipe *p = arg;\n\ttlstran_ep *  ep;\n\n\ttlstran_pipe_stop(p);\n\tif ((ep = p->ep) != NULL) {\n\t\tnni_mtx_lock(&ep->mtx);\n\t\tnni_list_node_remove(&p->node);\n\t\tep->refcnt--;\n\t\tif (ep->fini && (ep->refcnt == 0)) {\n\t\t\tnni_reap(&tlstran_ep_reap_list, ep);\n\t\t}\n\t\tnni_mtx_unlock(&ep->mtx);\n\t}\n\n\tnng_free(p->qos_buf, 16 + NNI_NANO_MAX_PACKET_SIZE);\n\tnni_aio_free(p->qsaio);\n\tnni_aio_free(p->rpaio);\n\tnni_aio_free(p->rxaio);\n\tnni_aio_free(p->txaio);\n\tnni_aio_free(p->negoaio);\n\tnng_stream_free(p->conn);\n\tif (p->rxmsg != NULL)\n\t\tnni_msg_free(p->rxmsg);\n\tnni_lmq_fini(&p->rslmq);\n\t// nni_mtx_fini(&p->mtx);\n\tNNI_FREE_STRUCT(p);\n}\n\nstatic void\ntlstran_pipe_reap(tlstran_pipe *p)\n{\n\tif (!nni_atomic_flag_test_and_set(&p->reaped)) {\n\t\tif (p->conn != NULL) {\n\t\t\tnng_stream_close(p->conn);\n\t\t}\n\t\tnni_reap(&tlstran_pipe_reap_list, p);\n\t}\n}\n\nstatic int\ntlstran_pipe_alloc(tlstran_pipe **pipep)\n{\n\ttlstran_pipe *p;\n\tint           rv;\n\n\tif ((p = NNI_ALLOC_STRUCT(p)) == NULL) {\n\t\treturn (NNG_ENOMEM);\n\t}\n\tnni_mtx_init(&p->mtx);\n\tif (((rv = nni_aio_alloc(&p->txaio, tlstran_pipe_send_cb, p)) != 0) ||\n\t    ((rv = nni_aio_alloc(&p->qsaio, tlstran_pipe_qos_send_cb, p)) != 0) ||\n\t    ((rv = nni_aio_alloc(&p->rpaio, NULL, p)) != 0) ||\n\t    ((rv = nni_aio_alloc(&p->rxaio, tlstran_pipe_recv_cb, p)) != 0) ||\n\t    ((rv = nni_aio_alloc(&p->negoaio, tlstran_pipe_nego_cb, p)) !=\n\t        0)) {\n\t\ttlstran_pipe_fini(p);\n\t\treturn (rv);\n\t}\n\tnni_aio_list_init(&p->recvq);\n\tnni_aio_list_init(&p->sendq);\n\tnni_atomic_flag_reset(&p->reaped);\n\n\t*pipep = p;\n\n\treturn (0);\n}\n\nstatic void\ntlstran_ep_match(tlstran_ep *ep)\n{\n\tnni_aio *     aio;\n\ttlstran_pipe *p;\n\n\tif (((aio = ep->useraio) == NULL) ||\n\t    ((p = nni_list_first(&ep->waitpipes)) == NULL)) {\n\t\treturn;\n\t}\n\tnni_list_remove(&ep->waitpipes, p);\n\tnni_list_append(&ep->busypipes, p);\n\tep->useraio = NULL;\n\tp->rcvmax   = ep->rcvmax;\n\tp->conf     = ep->conf;\n\tnni_aio_set_output(aio, 0, p);\n\tnni_aio_finish(aio, 0, 0);\n}\n\n/**\n * MQTT protocal negotiate\n * deal with CONNECT packet\n * Fixed header to variable header\n * receive multiple times for complete data packet then reply ACK in protocol\n * layer iov_len limits the length readv reads\n * TODO independent with nng SP\n */\nstatic void\ntlstran_pipe_nego_cb(void *arg)\n{\n\ttlstran_pipe *p   = arg;\n\ttlstran_ep *  ep  = p->ep;\n\tnni_aio *     aio = p->negoaio;\n\tnni_aio *     uaio;\n\tnni_iov       iov;\n\tuint32_t      len;\n\tint           rv, len_of_varint = 0;\n\n\tlog_trace(\"start tlstran_pipe_nego_cb max len %ld pipe_addr %p\\n\",\n\t    NANO_CONNECT_PACKET_LEN, p);\n\tnni_mtx_lock(&ep->mtx);\n\n\tif ((rv = nni_aio_result(aio)) != 0) {\n\t\tlog_warn(\" nego aio error %s\", nng_strerror(rv));\n\t\tgoto error;\n\t}\n\n\t// calculate number of bytes received\n\tif (p->gotrxhead < p->wantrxhead) {\n\t\tp->gotrxhead += nni_aio_count(aio);\n\t}\n\n\t// recv fixed header\n\tif (p->gotrxhead < NNI_NANO_MAX_HEADER_SIZE) {\n\t\tnni_iov iov;\n\t\tiov.iov_len = NNI_NANO_MAX_HEADER_SIZE - p->gotrxhead;\n\t\tiov.iov_buf = &p->rxlen[p->gotrxhead];\n\t\tnni_aio_set_iov(aio, 1, &iov);\n\t\tnng_stream_recv(p->conn, aio);\n\t\tnni_mtx_unlock(&ep->mtx);\n\t\treturn;\n\t}\n\tif (p->gotrxhead == NNI_NANO_MAX_HEADER_SIZE) {\n\t\tif (p->rxlen[0] != CMD_CONNECT) {\n\t\t\tlog_warn(\"CMD TYPE %x\", p->rxlen[0]);\n\t\t\trv = NNG_EPROTO;\n\t\t\tgoto error;\n\t\t}\n\t\tlen =\n\t\t    get_var_integer(p->rxlen + 1, (uint32_t *) &len_of_varint);\n\t\tp->wantrxhead = len + 1 + len_of_varint;\n\t\trv            = (p->wantrxhead >= NANO_CONNECT_PACKET_LEN) ? 0\n\t\t                                                           : NNG_EPROTO;\n\t\tif (rv != 0) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t// we have finished the fixed header\n\tif (p->gotrxhead < p->wantrxhead) {\n\t\tnni_iov iov;\n\t\tiov.iov_len = p->wantrxhead - p->gotrxhead;\n\t\tif (p->conn_buf == NULL) {\n\t\t\tp->conn_buf = nng_alloc(p->wantrxhead);\n\t\t\tmemcpy(p->conn_buf, p->rxlen, p->gotrxhead);\n\t\t}\n\t\tiov.iov_buf = &p->conn_buf[p->gotrxhead];\n\t\tnni_aio_set_iov(aio, 1, &iov);\n\t\tnng_stream_recv(p->conn, aio);\n\t\tnni_mtx_unlock(&ep->mtx);\n\t\treturn;\n\t}\n\n\t// We have both sent and received the CONNECT headers.\n\t// CONNECT packet serialization\n\n\tif (p->gotrxhead >= p->wantrxhead) {\n\t\tif (p->tcp_cparam == NULL) {\n\t\t\tconn_param_alloc(&p->tcp_cparam);\n\t\t}\n\t\tif (conn_handler(p->conn_buf, p->tcp_cparam, p->wantrxhead) == 0) {\n\t\t\tnng_free(p->conn_buf, p->wantrxhead);\n\t\t\tp->conn_buf = NULL;\n\t\t\t// we don't need to alloc a new msg, just use pipe.\n\t\t\t// We are all ready now.  We put this in the wait list,\n\t\t\t// and then try to run the matcher.\n\n\t\t\t// Connection is accepted.\n\t\t\tif (p->tcp_cparam->pro_ver == 5) {\n\t\t\t\tp->qsend_quota = p->tcp_cparam->rx_max;\n\t\t\t}\n\t\t\tnni_list_remove(&ep->negopipes, p);\n\t\t\tnni_list_append(&ep->waitpipes, p);\n\t\t\ttlstran_ep_match(ep);\n\t\t\tif (p->tcp_cparam->max_packet_size == 0) {\n\t\t\t\t// set default max packet size for client\n\t\t\t\tp->tcp_cparam->max_packet_size = p->conf == NULL?\n\t\t\t\tNANO_MAX_RECV_PACKET_SIZE : p->conf->client_max_packet_size;\n\t\t\t}\n\t\t\tnni_mtx_unlock(&ep->mtx);\n\t\t\treturn;\n\t\t} else {\n\t\t\tnng_free(p->conn_buf, p->wantrxhead);\n\t\t\tif (p->tcp_cparam->pro_ver == 5) {\n\t\t\t\tgoto close;\n\t\t\t} else {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\tnni_mtx_unlock(&ep->mtx);\n\tlog_trace(\"^^^^^^^^^^end of tlstran_pipe_nego_cb^^^^^^^^^^\\n\");\n\treturn;\n\nclose:\n\t// if a malformated CONNECT packet is received\n\t// reply CONNACK here for MQTT V5\n\t// otherwise deal with it in protocol layer\n\tp->txlen[0] = CMD_CONNACK;\n\tp->txlen[1] = 0x03;\n\tp->txlen[2] = 0x00;\n\tp->txlen[3] = rv;\n\tp->txlen[4] = 0x00;\n\tiov.iov_len = 5;\n\tiov.iov_buf = &p->txlen;\n\t// send connack down...\n\tnni_aio_set_iov(p->rpaio, 1, &iov);\n\tnng_stream_send(p->conn, p->rpaio);\n\tnng_aio_wait(p->rpaio);\nerror:\n\t// If the connection is closed, we need to pass back a different\n\t// error code.  This is necessary to avoid a problem where the\n\t// closed status is confused with the accept file descriptor\n\t// being closed.\n\tconn_param_free(p->tcp_cparam);\n\tif (rv == NNG_ECLOSED) {\n\t\trv = NNG_ECONNSHUT;\n\t}\n\tnng_stream_close(p->conn);\n\n\tif ((uaio = ep->useraio) != NULL) {\n\t\tep->useraio = NULL;\n\t\tnni_aio_finish_error(uaio, rv);\n\t}\n\tnni_mtx_unlock(&ep->mtx);\n\ttlstran_pipe_reap(p);\n\tlog_error(\"connect nego error rv: %s(%d)\", nng_strerror(rv), rv);\n}\n\nstatic void\ntlstran_pipe_qos_send_cb(void *arg)\n{\n\ttlstran_pipe *p = arg;\n\tnni_msg      *msg;\n\tnni_aio      *qsaio = p->qsaio;\n\tuint8_t       type;\n\tsize_t        n;\n\n\tif (nni_aio_result(qsaio) != 0) {\n\t\tnni_msg_free(nni_aio_get_msg(qsaio));\n\t\tnni_aio_set_msg(qsaio, NULL);\n\t\ttlstran_pipe_close(p);\n\t\treturn;\n\t}\n\tnni_mtx_lock(&p->mtx);\n\tn = nni_aio_count(qsaio);\n\tnni_aio_iov_advance(qsaio, n);\n\tif (nni_aio_iov_count(qsaio) > 0) {\n\t\tnng_stream_send(p->conn, qsaio);\n\t\tnni_mtx_unlock(&p->mtx);\n\t\treturn;\n\t}\n\tmsg  = nni_aio_get_msg(p->qsaio);\n\ttype = nni_msg_cmd_type(msg);\n\n\tif (p->tcp_cparam->pro_ver == 5) {\n\t\t(type == CMD_PUBCOMP || type == PUBACK) ? p->qrecv_quota++\n\t\t                                        : p->qrecv_quota;\n\t}\n\tnni_msg_free(msg);\n\tif (nni_lmq_get(&p->rslmq, &msg) == 0) {\n\t\tnni_iov iov;\n\t\tnni_msg_insert(\n\t\t    msg, nni_msg_header(msg), nni_msg_header_len(msg));\n\t\tiov.iov_len = nni_msg_len(msg);\n\t\tiov.iov_buf = nni_msg_body(msg);\n\t\tnni_aio_set_msg(p->qsaio, msg);\n\t\t// send it down...\n\t\tnni_aio_set_iov(p->qsaio, 1, &iov);\n\t\tnng_stream_send(p->conn, p->qsaio);\n\t\tp->busy = true;\n\t\tnni_mtx_unlock(&p->mtx);\n\t\tnni_aio_set_msg(qsaio, NULL);\n\t\treturn;\n\t}\n\tp->busy = false;\n\tnni_mtx_unlock(&p->mtx);\n\tnni_aio_set_msg(qsaio, NULL);\n\treturn;\n}\n\nstatic void\ntlstran_pipe_send_cb(void *arg)\n{\n\ttlstran_pipe *p = arg;\n\tint           rv;\n\tnni_aio *     aio;\n\tuint8_t *     header;\n\tuint8_t       flag = 0, cmd;\n\tsize_t        n;\n\tnni_msg *     msg;\n\tnni_aio *     txaio = p->txaio;\n\n\tnni_mtx_lock(&p->mtx);\n\taio = nni_list_first(&p->sendq);\n\n\tlog_trace(\"############### tlstran_pipe_send_cb ################\");\n\n\tif ((rv = nni_aio_result(txaio)) != 0) {\n\t\tlog_warn(\" send aio error %s\", nng_strerror(rv));\n\t\tnni_pipe_bump_error(p->npipe, rv);\n\t\tnni_aio_list_remove(aio);\n\t\tnni_mtx_unlock(&p->mtx);\n\t\tnni_aio_finish_error(aio, rv);\n\t\treturn;\n\t}\n\n\tn = nni_aio_count(txaio);\n\tnni_aio_iov_advance(txaio, n);\n\tlog_trace(\"tls over tcp socket sent %ld bytes iov %ld\", n,\n\t    nni_aio_iov_count(txaio));\n\n\tif (nni_aio_iov_count(txaio) > 0) {\n\t\tnng_stream_send(p->conn, txaio);\n\t\tnni_mtx_unlock(&p->mtx);\n\t\treturn;\n\t}\n\tmsg = nni_aio_get_msg(txaio);\n\tnni_aio_set_msg(txaio, NULL);\n\tif (msg != NULL) {\n\t\tnni_msg_free(msg);\n\t}\n\tmsg = nni_aio_get_msg(aio);\n\n\tif (nni_aio_get_prov_data(txaio) != NULL) {\n\t\t// msgs left behind due to multiple topics matched\n\t\tif (p->tcp_cparam->pro_ver == 4)\n\t\t\ttlstran_pipe_send_start_v4(p, msg, txaio);\n\t\telse if (p->tcp_cparam->pro_ver == 5)\n\t\t\ttlstran_pipe_send_start_v5(p, msg, txaio);\n\t\tnni_mtx_unlock(&p->mtx);\n\t\treturn;\n\t}\n\n\tnni_aio_list_remove(aio);\n\ttlstran_pipe_send_start(p);\n\n\tif (msg == NULL) {\n\t\tnni_mtx_unlock(&p->mtx);\n\t\t// msg is lost due to flow control\n\t\tnni_aio_set_msg(aio, NULL);\n\t\tnni_aio_finish_sync(aio, 0, 0);\n\t\treturn;\n\t}\n\n\tn   = nni_msg_len(msg);\n\tcmd = nni_msg_cmd_type(msg);\n\tif (cmd == CMD_CONNACK) {\n\t\theader = nni_msg_header(msg);\n\t\t// parse result code TODO verify bug\n\t\tflag = header[3];\n\t}\n\t// nni_pipe_bump_tx(p->npipe, n);\n\tnni_mtx_unlock(&p->mtx);\n\n\tnni_aio_set_msg(aio, NULL);\n\tnni_msg_free(msg);\n\tif (cmd == CMD_CONNACK && flag != 0x00) {\n\t\tnni_aio_finish_error(aio, flag);\n\t} else if (cmd == CMD_DISCONNECT) {\n\t\tnni_aio_finish_error(aio, NNG_ECLOSED);\n\t} else {\n\t\tnni_aio_finish_sync(aio, 0, n);\n\t}\n}\n\n/*\n * deal with MQTT protocol\n * insure read complete MQTT packet from socket\n */\nstatic void\ntlstran_pipe_recv_cb(void *arg)\n{\n\tnni_aio *     aio;\n\tnni_iov       iov[2];\n\tuint8_t       type;\n\tuint8_t       rv;\n\tuint32_t      pos = 1;\n\tuint64_t      len = 0;\n\tsize_t        n;\n\tnni_msg      *msg, *qmsg;\n\ttlstran_pipe *p     = arg;\n\tnni_aio *     rxaio = p->rxaio;\n\tconn_param *  cparam;\n\tbool          ack   = false;\n\n\tlog_trace(\"tlstran_pipe_recv_cb %p\\n\", p);\n\tnni_mtx_lock(&p->mtx);\n\n\taio = nni_list_first(&p->recvq);\n\n\tif ((rv = nni_aio_result(rxaio)) != 0) {\n\t\tlog_warn(\" recv aio error %s\", nng_strerror(rv));\n\t\trv = NMQ_SERVER_BUSY;\n\t\tgoto recv_error;\n\t}\n\n\tn = nni_aio_count(rxaio);\n\tp->gotrxhead += n;\n\n\tnni_aio_iov_advance(rxaio, n);\n\t// not receive enough bytes, deal with remaining length\n\tlen = get_var_integer(p->rxlen, &pos);\n\tlog_trace(\"new %ld recevied %ld header %x %d pos: %d len : %d\", n,\n\t    p->gotrxhead, p->rxlen[0], p->rxlen[1], pos, len);\n\tlog_trace(\"still need byte count:%ld > 0\\n\", nni_aio_iov_count(rxaio));\n\n\tif (nni_aio_iov_count(rxaio) > 0) {\n\t\tlog_trace(\"got: %x %x, %ld!!\\n\", p->rxlen[0], p->rxlen[1],\n\t\t    strlen((char *) p->rxlen));\n\t\tnng_stream_recv(p->conn, rxaio);\n\t\tnni_mtx_unlock(&p->mtx);\n\t\treturn;\n\t} else if (p->gotrxhead <= NNI_NANO_MAX_HEADER_SIZE &&\n\t    p->rxlen[p->gotrxhead - 1] > 0x7f) {\n\t\t// length error\n\t\tif (p->gotrxhead == NNI_NANO_MAX_HEADER_SIZE) {\n\t\t\trv = NNG_EMSGSIZE;\n\t\t\tgoto recv_error;\n\t\t}\n\t\t// same packet, continue receving next byte of remaining length\n\t\tiov[0].iov_buf = &p->rxlen[p->gotrxhead];\n\t\tiov[0].iov_len = 1;\n\t\tnni_aio_set_iov(rxaio, 1, iov);\n\t\tnng_stream_recv(p->conn, rxaio);\n\t\tnni_mtx_unlock(&p->mtx);\n\t\treturn;\n\t} else if (len == 0 && n == 2) {\n\t\tif ((p->rxlen[0] & 0XFF) == CMD_PINGREQ) {\n\t\t\tnng_aio_wait(p->rpaio);\n\t\t\tp->txlen[0] = CMD_PINGRESP;\n\t\t\tp->txlen[1] = 0x00;\n\t\t\tiov[0].iov_len = 2;\n\t\t\tiov[0].iov_buf = &p->txlen;\n\t\t\t// send it down...\n\t\t\tnni_aio_set_iov(p->rpaio, 1, iov);\n\t\t\tnng_stream_send(p->conn, p->rpaio);\n\t\t\tgoto notify;\n\t\t}\n\t}\n\n\t// finish fixed header\n\tp->wantrxhead = len + p->gotrxhead;\n\tcparam        = p->tcp_cparam;\n\n\tif (p->rxmsg == NULL) {\n\t\t// We should have gotten a message header. len -> remaining\n\t\t// length to define how many bytes left\n\t\tlog_trace(\"pipe %p header got: %x %x %x %x %x, %ld!!\\n\", p,\n\t\t    p->rxlen[0], p->rxlen[1], p->rxlen[2], p->rxlen[3],\n\t\t    p->rxlen[4], p->wantrxhead);\n\t\t// Make sure the message payload is not too big.  If it is\n\t\t// the caller will shut down the pipe.\n\t\tif (len > p->conf->max_packet_size) {\n\t\t\tlog_error(\"size error 0x95\\n\");\n\t\t\trv = NMQ_PACKET_TOO_LARGE;\n\t\t\tgoto recv_error;\n\t\t}\n\n\t\tif ((rv = nni_msg_alloc(&p->rxmsg, (size_t) len)) != 0) {\n\t\t\tlog_error(\"mem error %ld\\n\", (size_t) len);\n\t\t\trv = NMQ_SERVER_UNAVAILABLE;\n\t\t\tgoto recv_error;\n\t\t}\n\n\t\t// Submit the rest of the data for a read -- seperate Fixed\n\t\t// header with variable header and so on\n\t\t//  we want to read the entire message now.\n\t\tif (len != 0) {\n\t\t\tiov[0].iov_buf = nni_msg_body(p->rxmsg);\n\t\t\tiov[0].iov_len = (size_t) len;\n\n\t\t\tnni_aio_set_iov(rxaio, 1, iov);\n\t\t\t// second recv action\n\t\t\tnng_stream_recv(p->conn, rxaio);\n\t\t\tnni_mtx_unlock(&p->mtx);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// We read a message completely.  Let the user know the good news. use\n\t// as application message callback of users\n\tnni_aio_list_remove(aio);\n\tmsg      = p->rxmsg;\n\tp->rxmsg = NULL;\n\tn        = nni_msg_len(msg);\n\ttype     = p->rxlen[0] & 0xf0;\n\n\tfixed_header_adaptor(p->rxlen, msg);\n\tnni_msg_set_conn_param(msg, cparam);\n\t// duplicated with fixed_header_adaptor\n\tnni_msg_set_remaining_len(msg, len);\n\tnni_msg_set_cmd_type(msg, type);\n\tlog_trace(\"remain_len %d cparam %p clientid %s username %s proto %d\\n\",\n\t    len, cparam, cparam->clientid.body, cparam->username.body,\n\t    cparam->pro_ver);\n\n\t// set the payload pointer of msg according to packet_type\n\tlog_trace(\"The type of msg is %x\", type);\n\tuint16_t  packet_id   = 0;\n\tuint8_t   reason_code = 0;\n\tproperty *prop        = NULL;\n\tuint8_t   ack_cmd     = 0;\n\tif (type == CMD_PUBLISH) {\n\t\tnni_msg_set_timestamp(msg, nng_clock());\n\t\tuint8_t qos_pac = nni_msg_get_pub_qos(msg);\n\t\tif (qos_pac > 0) {\n\t\t\t// flow control, check rx_max\n\t\t\t// recv_quota as length of lmq\n\t\t\tif (p->tcp_cparam->pro_ver == 5) {\n\t\t\t\tif (p->qrecv_quota > 0) {\n\t\t\t\t\tp->qrecv_quota--;\n\t\t\t\t} else {\n\t\t\t\t\trv = NMQ_RECEIVE_MAXIMUM_EXCEEDED;\n\t\t\t\t\tgoto recv_error;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (qos_pac == 1) {\n\t\t\t\tack_cmd = CMD_PUBACK;\n\t\t\t} else if (qos_pac == 2) {\n\t\t\t\tack_cmd = CMD_PUBREC;\n\t\t\t} else {\n\t\t\t\tlog_warn(\"Wrong QoS level!\");\n\t\t\t\trv = PROTOCOL_ERROR;\n\t\t\t\tgoto recv_error;\n\t\t\t}\n\t\t\tif ((packet_id = nni_msg_get_pub_pid(msg)) == 0) {\n\t\t\t\trv = PROTOCOL_ERROR;\n\t\t\t\tgoto recv_error;\n\t\t\t}\n\t\t\tack       = true;\n\t\t}\n\t} else if (type == CMD_PUBREC) {\n\t\tif (nni_mqtt_pubres_decode(msg, &packet_id, &reason_code, &prop,\n\t\t        cparam->pro_ver) != 0) {\n\t\t\tlog_error(\"decode PUBREC variable header failed!\");\n\t\t}\n\t\tack_cmd = CMD_PUBREL;\n\t\tack     = true;\n\t} else if (type == CMD_PUBREL) {\n\t\tif (nni_mqtt_pubres_decode(msg, &packet_id, &reason_code, &prop,\n\t\t        cparam->pro_ver) != 0) {\n\t\t\tlog_error(\"decode PUBREL variable header failed!\");\n\t\t}\n\t\tack_cmd = CMD_PUBCOMP;\n\t\tack     = true;\n\t} else if (type == CMD_PUBACK || type == CMD_PUBCOMP) {\n\t\tif (nni_mqtt_pubres_decode(msg, &packet_id, &reason_code, &prop,\n\t\t        cparam->pro_ver) != 0) {\n\t\t\tlog_error(\"decode PUBACK or PUBCOMP variable header \"\n\t\t\t          \"failed!\");\n\t\t}\n\t\t// MQTT V5 flow control\n\t\tif (p->tcp_cparam->pro_ver == 5) {\n\t\t\tproperty_free(prop);\n\t\t\tp->qsend_quota++;\n\t\t}\n\t}\n\tif (ack == true) {\n\t\t// alloc a msg here costs memory. However we must do it for the\n\t\t// sake of compatibility with nng.\n\t\tif ((rv = nni_msg_alloc(&qmsg, 0)) != 0) {\n\t\t\tack = false;\n\t\t\trv  = NMQ_SERVER_BUSY;\n\t\t\tgoto recv_error;\n\t\t}\n\t\t// TODO set reason code or property here if necessary\n\n\t\tnni_msg_set_cmd_type(qmsg, ack_cmd);\n\t\tnni_mqtt_msgack_encode(\n\t\t    qmsg, packet_id, reason_code, prop, cparam->pro_ver);\n\t\tnni_mqtt_pubres_header_encode(qmsg, ack_cmd);\n\t\t// if (prop != NULL) {\n\t\t// nni_msg_proto_set_property(qmsg, prop);\n\t\t// }\n\t\t// aio_begin?\n\t\tif (p->busy == false) {\n\t\t\t// nni_msg_insert(qmsg, nni_msg_header(qmsg),\n\t\t\t//     nni_msg_header_len(qmsg));\n\t\t\tif (nni_aio_begin(aio) != 0) {\n\t\t\t\tlog_error(\"ACK aio error!!\");\n\t\t\t}\n\t\t\tnni_msg_insert(qmsg, nni_msg_header(qmsg),\n\t\t\t    nni_msg_header_len(qmsg));\n\t\t\tiov[0].iov_len = nni_msg_len(qmsg);\n\t\t\tiov[0].iov_buf = nni_msg_body(qmsg);\n\t\t\tp->busy        = true;\n\t\t\tnni_aio_set_msg(p->qsaio, qmsg);\n\t\t\t// send ACK down...\n\t\t\tnni_aio_set_iov(p->qsaio, 1, iov);\n\t\t\tnng_stream_send(p->conn, p->qsaio);\n\t\t\tlog_trace(\"QoS ACK msg sent!\");\n\t\t} else {\n\t\t\tif (nni_lmq_full(&p->rslmq)) {\n\t\t\t\t// Make space for the new message. TODO add max\n\t\t\t\t// limit of msgq len in conf\n\t\t\t\tif (nni_lmq_cap(&p->rslmq) <=\n\t\t\t\t    NANO_MAX_QOS_PACKET) {\n\t\t\t\t\tif ((rv = nni_lmq_resize(&p->rslmq,\n\t\t\t\t\t         nni_lmq_cap(&p->rslmq) *\n\t\t\t\t\t             2)) == 0) {\n\t\t\t\t\t\tnni_lmq_put(&p->rslmq, qmsg);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// memory error.\n\t\t\t\t\t\tnni_msg_free(qmsg);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tnni_msg *old;\n\t\t\t\t\t(void) nni_lmq_get(&p->rslmq, &old);\n\t\t\t\t\tnni_msg_free(old);\n\t\t\t\t\tnni_lmq_put(&p->rslmq, qmsg);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnni_lmq_put(&p->rslmq, qmsg);\n\t\t\t}\n\t\t}\n\t\tack = false;\n\t}\n\n\t// keep connection & Schedule next receive\n\t// nni_pipe_bump_rx(p->npipe, n);\n\tif (!nni_list_empty(&p->recvq)) {\n\t\ttlstran_pipe_recv_start(p);\n\t}\n\tnni_pipe_bump_rx(p->npipe, n);\n\tnni_mtx_unlock(&p->mtx);\n\n\tnni_aio_set_msg(aio, msg);\n\tnni_aio_finish_sync(aio, 0, n);\n\tlog_trace(\"end of tlstran_pipe_recv_cb: synch! %p\\n\", p);\n\treturn;\n\nrecv_error:\n\tnni_aio_list_remove(aio);\n\tmsg      = p->rxmsg;\n\tp->rxmsg = NULL;\n\tnni_pipe_bump_error(p->npipe, rv);\n\tnni_mtx_unlock(&p->mtx);\n\n\tnni_msg_free(msg);\n\tnni_aio_finish_error(aio, rv);\n\tlog_trace(\"tlstran_pipe_recv_cb: recv error rv: %d\\n\", rv);\n\treturn;\nnotify:\n\t// nni_pipe_bump_rx(p->npipe, n);\n\tnni_aio_list_remove(aio);\n\t// tlstran_pipe_recv_start(p);\n\tnni_mtx_unlock(&p->mtx);\n\tnni_aio_set_msg(aio, NULL);\n\tnni_aio_finish(aio, 0, 0);\n\treturn;\n}\n\nstatic void\ntlstran_pipe_send_cancel(nni_aio *aio, void *arg, int rv)\n{\n\ttlstran_pipe *p = arg;\n\n\tnni_mtx_lock(&p->mtx);\n\tif (!nni_aio_list_active(aio)) {\n\t\tnni_mtx_unlock(&p->mtx);\n\t\treturn;\n\t}\n\t// If this is being sent, then cancel the pending transfer.\n\t// The callback on the txaio will cause the user aio to\n\t// be canceled too.\n\tif (nni_list_first(&p->sendq) == aio) {\n\t\tnni_aio_abort(p->txaio, rv);\n\t\tnni_mtx_unlock(&p->mtx);\n\t\treturn;\n\t}\n\tnni_aio_list_remove(aio);\n\tnni_mtx_unlock(&p->mtx);\n\n\tnni_aio_finish_error(aio, rv);\n}\n\n/**\n * @brief send msg to V4 client\n * \n * @param p \n * @param msg \n */\nstatic inline void\ntlstran_pipe_send_start_v4(tlstran_pipe *p, nni_msg *msg, nni_aio *aio)\n{\n\tnni_aio *txaio;\n\tnni_iov  iov[8];\n\tint      niov = 0;\n\tnni_msg  *tmsg;\n\t// qos default to 0 if the msg is not PUBLISH\n\tuint8_t  qos = 0;\n\n\tif (nni_msg_header_len(msg) <= 0 ||\n\t    nni_msg_get_type(msg) != CMD_PUBLISH) {\n\t\tgoto send;\n\t}\n\n\tbool      is_sqlite = p->conf->sqlite.enable;\n\tint       qlen = 0, topic_len = 0;\n\tsubinfo * tinfo = NULL, *info = NULL;\n\tnni_list *subinfol = p->npipe->subinfol;\n\tchar *    topic    = nni_msg_get_pub_topic(msg, &topic_len);\n\n\ttxaio = p->txaio;\n\ttinfo = nni_aio_get_prov_data(txaio);\n\tnni_aio_set_prov_data(txaio, NULL);\n\n\t// Recomposing for each msg\n\t// never modify the original msg\n\tNNI_LIST_FOREACH(subinfol, info) {\n\t\tif (tinfo != NULL && info != tinfo)\n\t\t\tcontinue;\n\n\t\ttinfo = NULL;\n\n\t\tchar *sub_topic = info->topic;\n\t\tif (sub_topic[0] == '$') {\n\t\t\tif (0 == strncmp(sub_topic, \"$share/\", strlen(\"$share/\"))) {\n\t\t\t\tsub_topic = strchr(sub_topic, '/');\n\t\t\t\tsub_topic++;\n\t\t\t\tsub_topic = strchr(sub_topic, '/');\n\t\t\t\tsub_topic++;\n\t\t\t}\n\t\t}\n\t\tif (false == topic_filtern(sub_topic, topic, topic_len))\n\t\t\tcontinue;\n\t\tif (niov > 4) {\n\t\t\t// donot send too many msgs at a time\n\t\t\tnni_aio_set_prov_data(txaio, info);\n\t\t\tbreak;\n\t\t}\n\n\t\tuint8_t * body, *header, qos_pac;\n\t\tuint8_t   var_extra[2], fixheader, tmp[4] = { 0 };\n\t\tint       len_offset = 0;\n\t\tuint32_t  pos        = 1;\n\t\tnni_pipe *pipe;\n\t\tuint16_t  pid;\n\t\tuint32_t  property_bytes = 0, property_len = 0;\n\t\tsize_t    tlen, rlen, mlen, plength;\n\n\t\tpipe    = p->npipe;\n\t\tbody    = nni_msg_body(msg);\n\t\theader  = nni_msg_header(msg);\n\n\t\tplength = 0;\n\t\tmlen    = nni_msg_len(msg);\n\t\tqos_pac = nni_msg_get_pub_qos(msg);\n\t\tNNI_GET16(body, tlen);\n\n\t\tif (nni_msg_cmd_type(msg) == CMD_PUBLISH_V5) {\n\t\t\t// V5 to V4 shrink msg, remove property length\n\t\t\t// APP layer must give topic name even if topic\n\t\t\t// alias is set\n\t\t\tif (qos_pac > 0) {\n\t\t\t\tproperty_len = get_var_integer(\n\t\t\t\t    body + 4 + tlen, &property_bytes);\n\n\t\t\t} else {\n\t\t\t\tproperty_len = get_var_integer(\n\t\t\t\t    body + 2 + tlen, &property_bytes);\n\t\t\t}\n\t\t\t// V5 msg sent to V4 client\n\t\t\t// caculate property length and delete it\n\n\t\t\tplength = property_len + property_bytes;\n\t\t} else if (nni_msg_cmd_type(msg) == CMD_PUBLISH) {\n\n\t\t\tif (qos_pac == 0) {\n\t\t\t\tif (nni_msg_header_len(msg) > 0) {\n\t\t\t\t\tiov[niov].iov_buf = nni_msg_header(msg);\n\t\t\t\t\tiov[niov].iov_len = nni_msg_header_len(msg);\n\t\t\t\t\tniov++;\n\t\t\t\t}\n\t\t\t\tif (nni_msg_len(msg) > 0) {\n\t\t\t\t\tiov[niov].iov_buf = nni_msg_body(msg);\n\t\t\t\t\tiov[niov].iov_len = nni_msg_len(msg);\n\t\t\t\t\tniov++;\n\t\t\t\t}\n\t\t\t\t// save time & space for QoS 0 publish\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tqos = info->qos;\n\t\tlog_trace(\"qos_pac %d sub %d\\n\", qos_pac, qos);\n\t\tfixheader = *header;\n\t\t// get final qos\n\t\tqos = qos_pac > qos ? qos : qos_pac;\n\n\t\t// alter qos according to sub qos\n\t\tif (qos_pac > qos) {\n\t\t\tif (qos == 1) {\n\t\t\t\t// set qos to 1\n\t\t\t\tfixheader = fixheader & 0xF9;\n\t\t\t\tfixheader = fixheader | 0x02;\n\t\t\t} else {\n\t\t\t\t// set qos to 0\n\t\t\t\tfixheader = fixheader & 0xF9;\n\t\t\t\tlen_offset   = len_offset - 2;\n\t\t\t}\n\t\t}\n\t\t// copy remaining length\n\t\trlen = put_var_integer(\n\t\t    tmp, get_var_integer(header, &pos) + len_offset - plength);\n\t\t*(p->qos_buf + qlen) = fixheader;\n\t\t//rlen : max 4 bytes\n\t\tmemcpy(p->qos_buf+1+qlen, tmp, rlen);\n\n\t\t// 1st part of variable header: topic\n\t\tlen_offset = 0;      // now use it to indicates the pid length\n\t\t// packet id\n\t\tif (qos > 0) {\n\t\t\t// set pid\n\t\t\tlen_offset = 2;\n\t\t\tnni_msg *old;\n\t\t\t// to differ resend msg\n\t\t\tpid = (uint16_t)(size_t) nni_aio_get_prov_data(aio);\n\t\t\tif (pid == 0) {\n\t\t\t\t// first time send this msg\n\t\t\t\tpid = nni_pipe_inc_packetid(pipe);\n\t\t\t\t// store msg for qos retrying\n\t\t\t\tnni_msg_clone(msg);\n\t\t\t\tif ((old = nni_qos_db_get(is_sqlite,\n\t\t\t\t         pipe->nano_qos_db, pipe->p_id,\n\t\t\t\t         pid)) != NULL) {\n\t\t\t\t\t// TODO packetid already exists.\n\t\t\t\t\t// do we need to replace old with new\n\t\t\t\t\t// one ? print warning to users\n\t\t\t\t\tlog_error(\"packet id duplicates in \"\n\t\t\t\t\t          \"nano_qos_db\");\n\n\t\t\t\t\tnni_qos_db_remove_msg(is_sqlite,\n\t\t\t\t\t    pipe->nano_qos_db, old);\n\t\t\t\t}\n\t\t\t\told = msg;\n\t\t\t\tnni_qos_db_set(is_sqlite, pipe->nano_qos_db,\n\t\t\t\t    pipe->p_id, pid, old);\n\t\t\t\tnni_qos_db_remove_oldest(is_sqlite,\n\t\t\t\t    pipe->nano_qos_db,\n\t\t\t\t    p->conf->sqlite.disk_cache_size);\n\t\t\t}\n\t\t\tNNI_PUT16(var_extra, pid);\n\t\t} else if (qos_pac > 0) {\n\t\t\tlen_offset += 2;\n\t\t}\n\t\t// fixed header\n\t\tiov[niov].iov_buf = p->qos_buf+qlen;\n\t\tiov[niov].iov_len = 1+rlen;\n\t\tniov++;\n\t\tqlen += rlen + 1;\n\t\t// topic + tlen\n\t\tiov[niov].iov_buf = body;\n\t\tiov[niov].iov_len = 2+tlen;\n\t\tniov++;\n\t\t// packet id if any\n\t\tif (qos > 0) {\n\t\t\t// copy packet id\n\t\t\tmemcpy(p->qos_buf + 5 + qlen, var_extra, 2);\n\t\t\tiov[niov].iov_buf = p->qos_buf + 5 + qlen;\n\t\t\tiov[niov].iov_len = 2;\n\t\t\tniov++;\n\t\t\tqlen += 2;\n\t\t}\n\t\t// variable header + payload\n\t\tif (mlen > 0) {\n\t\t\t// determine if it needs to skip packet id field\n\t\t\tiov[niov].iov_buf =\n\t\t\t    body + 2 + tlen + len_offset + plength;\n\t\t\tiov[niov].iov_len =\n\t\t\t    mlen - 2 - len_offset - tlen - plength;\n\t\t\tniov++;\n\t\t}\n\t}\n\n\tnni_msg_alloc(&tmsg, 0);\n\t// apending directly\n\tfor (int i = 0; i < niov; i++) {\n\t\tnni_msg_append(tmsg, iov[i].iov_buf, iov[i].iov_len);\n\t}\n\t// tls_common only send 1 iov each time\n\t// to avoid of racing we alloc a new msg for tls\n\tiov[0].iov_buf = nni_msg_body(tmsg);\n\tiov[0].iov_len = nni_msg_len(tmsg);\n\tnni_aio_set_msg(txaio, tmsg);\n\tnni_aio_set_iov(txaio, 1, iov);\n\n\tnng_stream_send(p->conn, txaio);\n\treturn;\n\nsend:\n\t// have to alloc new msg due to TLS doesn't support scatter\n\tnni_msg_alloc(&tmsg, 0);\n\ttxaio = p->txaio;\n\tniov  = 0;\n\n\tif (nni_msg_header_len(msg) > 0) {\n\t\tnni_msg_append(\n\t\t    tmsg, nni_msg_header(msg), nni_msg_header_len(msg));\n\t}\n\tif (nni_msg_len(msg) > 0) {\n\t\tnni_msg_append(tmsg, nni_msg_body(msg), nni_msg_len(msg));\n\t}\n\tiov[0].iov_buf = nni_msg_body(tmsg);\n\tiov[0].iov_len = nni_msg_len(tmsg);\n\tnni_aio_set_msg(txaio, tmsg);\n\tnni_aio_set_iov(txaio, 1, iov);\n\tnng_stream_send(p->conn, txaio);\n}\n\n/**\n * @brief we consider memory saving is prior to performance due\n * \t  to the requirement of our boss. so we use fragmented iov.\n * \n * @param p \n * @param msg \n * @param aio \n */\nstatic inline void\ntlstran_pipe_send_start_v5(tlstran_pipe *p, nni_msg *msg, nni_aio *aio)\n{\n\tnni_aio  *txaio;\n\tnni_pipe *pipe = p->npipe;\n\tint       niov;\n\tnni_iov   iov[8];\n\tnni_msg  *tmsg;\n\n\tif (nni_msg_get_type(msg) != CMD_PUBLISH)\n\t\tgoto send;\n\t// never modify the original msg\n\n\tuint8_t *     body, *header, qos_pac;\n\ttarget_prover target_prover;\n\tint           len_offset = 0, sub_id = 0, qos = 0;\n\tuint16_t      pid;\n\tuint32_t tprop_bytes, prop_bytes = 0, id_bytes = 0, property_len = 0;\n\tsize_t   tlen, rlen, mlen, hlen, qlength, plength;\n\n\tbool is_sqlite = p->conf->sqlite.enable;\n\n\ttxaio   = p->txaio;\n\tbody    = nni_msg_body(msg);\n\theader  = nni_msg_header(msg);\n\tniov    = 0;\n\tqlength = 0;\n\tplength = 0;\n\tmlen    = nni_msg_len(msg);\n\thlen    = nni_msg_header_len(msg);\n\tqos_pac = nni_msg_get_pub_qos(msg);\n\tNNI_GET16(body, tlen);\n\n\t// check max packet size for this client/msg\n\tuint32_t total_len = mlen + hlen;\n\tif (total_len > p->tcp_cparam->max_packet_size) {\n\t\t// drop msg and finish aio\n\t\t// pretend it has been sent\n\t\tlog_warn(\"msg dropped due to overceed max packet size!\");\n\t\tnni_msg_free(msg);\n\t\tnni_aio_set_msg(aio, NULL);\n\t\tnni_aio_finish(aio, 0, 0);\n\t\treturn;\n\t}\n\tif (nni_msg_cmd_type(msg) == CMD_PUBLISH_V5) {\n\t\tif (qos_pac > 0) {\n\t\t\tproperty_len =\n\t\t\t    get_var_integer(body + 4 + tlen, &prop_bytes);\n\t\t} else {\n\t\t\tproperty_len =\n\t\t\t    get_var_integer(body + 2 + tlen, &prop_bytes);\n\t\t}\n\t\ttarget_prover = MQTTV5;\n\t\ttprop_bytes = prop_bytes;\n\t}\n\t// subid\n\tsubinfo *info, *tinfo;\n\ttinfo = nni_aio_get_prov_data(txaio);\n\tnni_aio_set_prov_data(txaio, NULL);\n\tNNI_LIST_FOREACH (p->npipe->subinfol, info) {\n\t\tif (tinfo != NULL && info != tinfo ) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (info->no_local == 1 && p->npipe->p_id == nni_msg_get_pipe(msg)) {\n\t\t\tcontinue;\n\t\t}\n\t\ttinfo = NULL;\n\t\tlen_offset=0;\n\t\tchar *sub_topic = info->topic;\n\t\tif (sub_topic[0] == '$') {\n\t\t\tif (0 == strncmp(sub_topic, \"$share/\", strlen(\"$share/\"))) {\n\t\t\t\tsub_topic = strchr(sub_topic, '/');\n\t\t\t\tsub_topic++;\n\t\t\t\tsub_topic = strchr(sub_topic, '/');\n\t\t\t\tsub_topic++;\n\t\t\t}\n\t\t}\n\t\tif (topic_filtern(sub_topic, (char*)(body + 2), tlen)) {\n\t\t\tif (niov >= 8) {\n\t\t\t\t// nng aio only allow 2 msgs at a time\n\t\t\t\tnni_aio_set_prov_data(txaio, info);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tuint8_t  var_extra[2], fixheader, tmp[4] = { 0 };\n\t\t\tuint8_t  proplen[4] = { 0 }, var_subid[5] = { 0 };\n\t\t\tuint32_t pos = 1;\n\t\t\tsub_id       = info->subid;\n\t\t\tqos          = info->qos;\n\n\t\t\tfixheader = *header;\n\t\t\tif (nni_msg_cmd_type(msg) == CMD_PUBLISH) {\n\t\t\t\t// V4 to V5 add 0 property length\n\t\t\t\ttarget_prover = MQTTV4_V5;\n\t\t\t\tprop_bytes    = 1;\n\t\t\t\ttprop_bytes   = 1;\n\t\t\t\tlen_offset    = 1;\n\t\t\t}\n\t\t\tif (info->rap == 0) {\n\t\t\t\tfixheader = fixheader & 0xFE;\n\t\t\t}\n\t\t\tif (sub_id != 0) {\n\t\t\t\tvar_subid[0] = 0x0B;\n\t\t\t\tid_bytes = put_var_integer(var_subid+1, sub_id);\n\t\t\t\ttprop_bytes = put_var_integer(proplen, property_len+1+id_bytes);\n\t\t\t\tlen_offset += (tprop_bytes - prop_bytes + 1 + id_bytes);\n\t\t\t}\n\t\t\t// get final qos\n\t\t\tqos = qos_pac > qos ? qos : qos_pac;\n\n\t\t\t// alter qos according to sub qos\n\t\t\tif (qos_pac > qos) {\n\t\t\t\tif (qos == 1) {\n\t\t\t\t\t// set qos to 1\n\t\t\t\t\tfixheader = fixheader & 0xF9;\n\t\t\t\t\tfixheader = fixheader | 0x02;\n\t\t\t\t} else {\n\t\t\t\t\t// set qos to 0\n\t\t\t\t\tfixheader = fixheader & 0xF9;\n\t\t\t\t\tlen_offset   = len_offset - 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// fixed header + remaining length\n\t\t\tpos=1;\n\t\t\trlen = put_var_integer(\n\t\t\t    tmp, get_var_integer(header, &pos) + len_offset);\n\t\t\t// or just copy to qosbuf directly?\n\t\t\t*(p->qos_buf + qlength) = fixheader;\n\t\t\tmemcpy(p->qos_buf + qlength + 1, tmp, rlen);\n\t\t\tiov[niov].iov_buf = p->qos_buf + qlength;\n\t\t\tiov[niov].iov_len = rlen + 1;\n\t\t\tniov++;\n\t\t\tqlength += rlen + 1;\n\t\t\t// 1st part of variable header: topic + topic len\n\t\t\tiov[niov].iov_buf = body;\n\t\t\tiov[niov].iov_len = tlen+2;\n\t\t\tniov++;\n\t\t\t// len to indicate the offset in packet\n\t\t\tlen_offset = 0;\n\t\t\tplength = 0;\n\t\t\tif (qos > 0) {\n\t\t\t\t// set pid\n\t\t\t\tlen_offset = 2;\n\t\t\t\tnni_msg *old;\n\t\t\t\t// packetid in aio to differ resend msg\n\t\t\t\t// TODO replace it with set prov data/pipe\n\t\t\t\tpid = (uint16_t)(size_t) nni_aio_get_prov_data(aio);\n\t\t\t\tif (pid == 0) {\n\t\t\t\t\t// first time send this msg\n\t\t\t\t\tpid = nni_pipe_inc_packetid(pipe);\n\t\t\t\t\t// store msg for qos retrying\n\t\t\t\t\tnni_msg_clone(msg);\n\t\t\t\t\tif ((old = nni_qos_db_get(is_sqlite,\n\t\t\t\t\t         pipe->nano_qos_db, pipe->p_id,\n\t\t\t\t\t         pid)) != NULL) {\n\t\t\t\t\t\t// TODO packetid already\n\t\t\t\t\t\t// exists. do we need to\n\t\t\t\t\t\t// replace old with new one ?\n\t\t\t\t\t\t// print warning to users\n\t\t\t\t\t\tnni_println(\"ERROR: packet id \"\n\t\t\t\t\t\t            \"duplicates in \"\n\t\t\t\t\t\t            \"nano_qos_db\");\n\n\t\t\t\t\t\tnni_qos_db_remove_msg(\n\t\t\t\t\t\t    is_sqlite,\n\t\t\t\t\t\t    pipe->nano_qos_db, old);\n\t\t\t\t\t}\n\t\t\t\t\told = msg;\n\t\t\t\t\tnni_qos_db_set(is_sqlite,\n\t\t\t\t\t    pipe->nano_qos_db, pipe->p_id, pid,\n\t\t\t\t\t    old);\n\t\t\t\t\tnni_qos_db_remove_oldest(is_sqlite,\n\t\t\t\t\t    pipe->nano_qos_db,\n\t\t\t\t\t    p->conf->sqlite.disk_cache_size);\n\t\t\t\t}\n\t\t\t\tNNI_PUT16(var_extra, pid);\n\t\t\t\t// copy packet id\n\t\t\t\tmemcpy(p->qos_buf + qlength, var_extra, 2);\n\t\t\t\tqlength += 2;\n\t\t\t\tplength += 2;\n\t\t\t} else if (qos_pac > 0) {\n\t\t\t\t//ignore the packet id of original packet\n\t\t\t\tlen_offset += 2;\n\t\t\t}\n\t\t\t// prop len + sub id if any\n\t\t\tif (sub_id != 0) {\n\t\t\t\tmemcpy(p->qos_buf + qlength, proplen,\n\t\t\t\t    tprop_bytes);\n\t\t\t\tqlength += tprop_bytes;\n\t\t\t\tplength += tprop_bytes;\n\t\t\t\tmemcpy(p->qos_buf + qlength, var_subid,\n\t\t\t\t    id_bytes + 1);\n\t\t\t\tqlength += id_bytes + 1;\n\t\t\t\tplength += id_bytes + 1;\n\t\t\t\tif (target_prover == MQTTV5)\n\t\t\t\t\tlen_offset += prop_bytes;\n\t\t\t} else {\n\t\t\t\t//need to add 0 len for V4 msg\n\t\t\t\tif (target_prover == MQTTV4_V5) {\n\t\t\t\t\t// add proplen even 0\n\t\t\t\t\tmemcpy(p->qos_buf + qlength, proplen,\n\t\t\t\t\t    tprop_bytes);\n\t\t\t\t\tqlength += tprop_bytes;\n\t\t\t\t\tplength += tprop_bytes;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 2nd part of variable header: pid + proplen+0x0B+subid\n\t\t\tiov[niov].iov_buf = p->qos_buf+qlength-plength;\n\t\t\tiov[niov].iov_len = plength;\n\t\t\tniov++;\n\t\t\t// prop + body\n\t\t\tiov[niov].iov_buf = body + 2 + tlen + len_offset;\n\t\t\tiov[niov].iov_len = mlen - 2 - len_offset - tlen;\n\t\t\tniov++;\n\t\t}\n\t}\n\n\t// MQTT V5 flow control\n\tif (qos > 0) {\n\t\tif (p->qsend_quota > 0) {\n\t\t\tp->qsend_quota--;\n\t\t} else {\n\t\t\t// what should broker does when exceed\n\t\t\t// max_recv? msg lost, make it look like a\n\t\t\t// normal send. qos msg will be resend\n\t\t\t// afterwards\n\t\t\tnni_msg_free(msg);\n\t\t\tnni_aio_set_prov_data(txaio, NULL);\n\t\t\tnni_list_remove(&p->sendq, aio);\n\t\t\tnni_aio_set_msg(aio, NULL);\n\t\t\tnni_aio_finish(aio, 0, 0);\n\t\t\treturn;\n\t\t}\n\t}\n\tif (niov == 0) {\n\t\t// No content to send\n\t\tnni_msg_free(msg);\n\t\tnni_aio_set_prov_data(txaio, NULL);\n\t\tnni_list_remove(&p->sendq, aio);\n\t\tnni_aio_set_msg(aio, NULL);\n\t\tnni_aio_finish(aio, 0, 0);\n\t\treturn;\n\t}\n\tnni_msg_alloc(&tmsg, 0);\n\t// apending directly\n\tfor (int i = 0; i < niov; i++) {\n\t\tnni_msg_append(tmsg, iov[i].iov_buf, iov[i].iov_len);\n\t}\n\t// tls_common only send 1 iov each time\n\t// to avoid of racing we alloc a new msg for tls\n\tiov[0].iov_buf = nni_msg_body(tmsg);\n\tiov[0].iov_len = nni_msg_len(tmsg);\n\tnni_aio_set_msg(txaio, tmsg);\n\tnni_aio_set_iov(txaio, 1, iov);\n\n\tnng_stream_send(p->conn, txaio);\n\treturn;\n\nsend:\n\t// have to alloc new msg due to TLS doesn't support scatter\n\tnni_msg_alloc(&tmsg, 0);\n\ttxaio = p->txaio;\n\tniov  = 0;\n\n\tif (nni_msg_header_len(msg) > 0) {\n\t\tnni_msg_append(\n\t\t    tmsg, nni_msg_header(msg), nni_msg_header_len(msg));\n\t}\n\tif (nni_msg_len(msg) > 0) {\n\t\tnni_msg_append(tmsg, nni_msg_body(msg), nni_msg_len(msg));\n\t}\n\tiov[0].iov_buf = nni_msg_body(tmsg);\n\tiov[0].iov_len = nni_msg_len(tmsg);\n\tnni_aio_set_msg(txaio, tmsg);\n\tnni_aio_set_iov(txaio, 1, iov);\n\tnng_stream_send(p->conn, txaio);\n}\n\n/**\n * @brief this is the func that responsible for sending msg while\n *        keeping zero-copy feature, doing all the jobs neccesary\n *        for each unique client (it means ugly)\n * //TODO break it into 2 pieces V4 / V5\n *\n * @param p tcptran_pipe\n */\nstatic void\ntlstran_pipe_send_start(tlstran_pipe *p)\n{\n\tnni_aio *aio;\n\tnni_msg *msg;\n\n\tlog_trace(\"########### tlstran_pipe_send_start ###########\");\n\tif (p->closed) {\n\t\twhile ((aio = nni_list_first(&p->sendq)) != NULL) {\n\t\t\tnni_list_remove(&p->sendq, aio);\n\t\t\tnni_aio_finish_error(aio, NNG_ECLOSED);\n\t\t}\n\t\treturn;\n\t}\n\n\tif ((aio = nni_list_first(&p->sendq)) == NULL) {\n\t\tlog_trace(\"aio not functioning\");\n\t\treturn;\n\t}\n\n\t// This runs to send the message.\n\tmsg = nni_aio_get_msg(aio);\n\tif (msg == NULL || p->tcp_cparam == NULL) {\n\t\t// TODO error handler\n\t\tnni_println(\"ERROR: sending NULL msg or pipe is invalid!\");\n\t\tnni_aio_finish(aio, NNG_ECANCELED, 0);\n\t\treturn;\n\t}\n\tif (p->tcp_cparam->pro_ver == 4) {\n\t\ttlstran_pipe_send_start_v4(p, msg, aio);\n\t} else if (p->tcp_cparam->pro_ver == 5) {\n\t\ttlstran_pipe_send_start_v5(p, msg, aio);\n\t}\n\treturn;\n}\n\nstatic void\ntlstran_pipe_send(void *arg, nni_aio *aio)\n{\n\ttlstran_pipe *p = arg;\n\tint           rv;\n\n\tlog_trace(\"####################tlstran_pipe_send###########\");\n\tif (nni_aio_begin(aio) != 0) {\n\t\treturn;\n\t}\n\tnni_mtx_lock(&p->mtx);\n\tif ((rv = nni_aio_schedule(aio, tlstran_pipe_send_cancel, p)) != 0) {\n\t\tnni_mtx_unlock(&p->mtx);\n\t\tnni_aio_finish_error(aio, rv);\n\t\treturn;\n\t}\n\tnni_list_append(&p->sendq, aio);\n\tif (nni_list_first(&p->sendq) == aio) {\n\t\t// send publish msg or send others\n\t\ttlstran_pipe_send_start(p);\n\t}\n\tnni_mtx_unlock(&p->mtx);\n}\n\nstatic void\ntlstran_pipe_recv_cancel(nni_aio *aio, void *arg, int rv)\n{\n\ttlstran_pipe *p = arg;\n\n\tnni_mtx_lock(&p->mtx);\n\tif (!nni_aio_list_active(aio)) {\n\t\tnni_mtx_unlock(&p->mtx);\n\t\treturn;\n\t}\n\t// If receive in progress, then cancel the pending transfer.\n\t// The callback on the rxaio will cause the user aio to\n\t// be canceled too.\n\tif (nni_list_first(&p->recvq) == aio) {\n\t\tnni_aio_abort(p->rxaio, rv);\n\t\tnni_mtx_unlock(&p->mtx);\n\t\treturn;\n\t}\n\tnni_aio_list_remove(aio);\n\tnni_mtx_unlock(&p->mtx);\n\tnni_aio_finish_error(aio, rv);\n}\n\nstatic void\ntlstran_pipe_recv(void *arg, nni_aio *aio)\n{\n\ttlstran_pipe *p = arg;\n\tint           rv;\n\n\tif (nni_aio_begin(aio) != 0) {\n\t\treturn;\n\t}\n\tnni_mtx_lock(&p->mtx);\n\tif ((rv = nni_aio_schedule(aio, tlstran_pipe_recv_cancel, p)) != 0) {\n\t\tnni_mtx_unlock(&p->mtx);\n\t\tnni_aio_finish_error(aio, rv);\n\t\treturn;\n\t}\n\n\t// if (nni_aio_list_active(aio) == 0) {\n\tnni_list_append(&p->recvq, aio);\n\t// }\n\n\tif (nni_list_first(&p->recvq) == aio) {\n\t\ttlstran_pipe_recv_start(p);\n\t}\n\tnni_mtx_unlock(&p->mtx);\n}\n\nstatic int\ntlstran_pipe_getopt(\n    void *arg, const char *name, void *buf, size_t *szp, nni_type t)\n{\n\ttlstran_pipe *p = arg;\n\treturn (nni_stream_get(p->conn, name, buf, szp, t));\n}\n\nstatic void\ntlstran_pipe_recv_start(tlstran_pipe *p)\n{\n\tnni_aio *rxaio;\n\tnni_iov  iov;\n\tlog_trace(\"*** tlstran_pipe_recv_start ***\\n\");\n\n\tif (p->closed) {\n\t\tnni_aio *aio;\n\t\twhile ((aio = nni_list_first(&p->recvq)) != NULL) {\n\t\t\tnni_list_remove(&p->recvq, aio);\n\t\t\tnni_aio_finish_error(aio, NNG_ECLOSED);\n\t\t}\n\t\treturn;\n\t}\n\tif (nni_list_empty(&p->recvq)) {\n\t\treturn;\n\t}\n\n\t// Schedule a read of the fixed header.\n\trxaio         = p->rxaio;\n\tp->gotrxhead  = 0;\n\tp->wantrxhead = NANO_MIN_FIXED_HEADER_LEN;\n\tiov.iov_buf   = p->rxlen;\n\tiov.iov_len   = NANO_MIN_FIXED_HEADER_LEN;\n\tnni_aio_set_iov(rxaio, 1, &iov);\n\tnng_stream_recv(p->conn, rxaio);\n}\n\n// DEAL WITH CONNECT when PIPE INIT\nstatic void\ntlstran_pipe_start(tlstran_pipe *p, nng_stream *conn, tlstran_ep *ep)\n{\n\tnni_iov iov;\n\t// nni_tcp_conn *c;\n\n\tep->refcnt++;\n\n\tp->conn = conn;\n\tp->ep   = ep;\n\tp->conf = ep->conf;\n\t// p->proto = ep->proto;\n\n\tlog_trace(\"tlstran_pipe_start!\");\n\tp->qrecv_quota = NANO_MAX_QOS_PACKET;\n\tp->gotrxhead  = 0;\n\tp->wantrxhead = NANO_CONNECT_PACKET_LEN; // packet type 1 + remaining\n\t                                         // length 1 + protocal name 7\n\t                                         // + flag 1 + keepalive 2 = 12\n\tiov.iov_len = NNI_NANO_MAX_HEADER_SIZE;  // dynamic\n\tiov.iov_buf = p->rxlen;\n\n\tnni_aio_set_iov(p->negoaio, 1, &iov);\n\tnni_list_append(&ep->negopipes, p);\n\n\tnni_aio_set_timeout(p->negoaio,\n\t    15 * 1000); // 15 sec timeout to negotiate abide with emqx\n\tnng_stream_recv(p->conn, p->negoaio);\n}\n\nstatic void\ntlstran_ep_fini(void *arg)\n{\n\ttlstran_ep *ep = arg;\n\n\tnni_mtx_lock(&ep->mtx);\n\tep->fini = true;\n\tif (ep->refcnt != 0) {\n\t\tnni_mtx_unlock(&ep->mtx);\n\t\treturn;\n\t}\n\tnni_mtx_unlock(&ep->mtx);\n\tnni_aio_stop(ep->timeaio);\n\tnni_aio_stop(ep->connaio);\n\tnng_stream_listener_free(ep->listener);\n\tnni_aio_free(ep->timeaio);\n\tnni_aio_free(ep->connaio);\n\n\tnni_mtx_fini(&ep->mtx);\n\tNNI_FREE_STRUCT(ep);\n}\n\nstatic void\ntlstran_ep_close(void *arg)\n{\n\ttlstran_ep *  ep = arg;\n\ttlstran_pipe *p;\n\n\tnni_mtx_lock(&ep->mtx);\n\n\tlog_trace(\"tlstran_ep_close\");\n\tep->closed = true;\n\tnni_aio_close(ep->timeaio);\n\tif (ep->listener != NULL) {\n\t\tnng_stream_listener_close(ep->listener);\n\t}\n\tNNI_LIST_FOREACH (&ep->negopipes, p) {\n\t\ttlstran_pipe_close(p);\n\t}\n\tNNI_LIST_FOREACH (&ep->waitpipes, p) {\n\t\ttlstran_pipe_close(p);\n\t}\n\tNNI_LIST_FOREACH (&ep->busypipes, p) {\n\t\ttlstran_pipe_close(p);\n\t}\n\tif (ep->useraio != NULL) {\n\t\tnni_aio_finish_error(ep->useraio, NNG_ECLOSED);\n\t\tep->useraio = NULL;\n\t}\n\n\tnni_mtx_unlock(&ep->mtx);\n}\n\n// This parses off the optional source address that this transport uses.\n// The special handling of this URL format is quite honestly an historical\n// mistake, which we would remove if we could.static int\nint\ntlstran_url_parse_source(nng_url *url, nng_sockaddr *sa, const nng_url *surl)\n{\n\tint      af;\n\tchar *   semi;\n\tchar *   src;\n\tsize_t   len;\n\tint      rv;\n\tnni_aio *aio;\n\n\t// We modify the URL.  This relies on the fact that the underlying\n\t// transport does not free this, so we can just use references.\n\n\turl->u_scheme   = surl->u_scheme;\n\turl->u_port     = surl->u_port;\n\turl->u_hostname = surl->u_hostname;\n\n\tif ((semi = strchr(url->u_hostname, ';')) == NULL) {\n\t\tmemset(sa, 0, sizeof(*sa));\n\t\treturn (0);\n\t}\n\n\tlen             = (size_t)(semi - url->u_hostname);\n\turl->u_hostname = semi + 1;\n\n\tif (strcmp(surl->u_scheme, \"tls+tcp\") == 0) {\n\t\taf = NNG_AF_UNSPEC;\n\t} else if (strcmp(surl->u_scheme, \"tls+tcp4\") == 0) {\n\t\taf = NNG_AF_INET;\n\t} else if (strcmp(surl->u_scheme, \"tls+tcp6\") == 0) {\n\t\taf = NNG_AF_INET6;\n\t} else {\n\t\treturn (NNG_EADDRINVAL);\n\t}\n\n\tif ((src = nni_alloc(len + 1)) == NULL) {\n\t\treturn (NNG_ENOMEM);\n\t}\n\tmemcpy(src, surl->u_hostname, len);\n\tsrc[len] = '\\0';\n\n\tif ((rv = nni_aio_alloc(&aio, NULL, NULL)) != 0) {\n\t\tnni_free(src, len + 1);\n\t\treturn (rv);\n\t}\n\n\tnni_resolv_ip(src, \"0\", af, true, sa, aio);\n\tnni_aio_wait(aio);\n\trv = nni_aio_result(aio);\n\tnni_aio_free(aio);\n\tnni_free(src, len + 1);\n\treturn (rv);\n}\n\nstatic void\ntlstran_timer_cb(void *arg)\n{\n\ttlstran_ep *ep = arg;\n\tif (nni_aio_result(ep->timeaio) == 0) {\n\t\tnng_stream_listener_accept(ep->listener, ep->connaio);\n\t}\n}\n\n// TLS accpet trigger\nstatic void\ntlstran_accept_cb(void *arg)\n{\n\ttlstran_ep *  ep  = arg;\n\tnni_aio *     aio = ep->connaio;\n\ttlstran_pipe *p;\n\tint           rv;\n\tnng_stream *  conn;\n\n\tnni_mtx_lock(&ep->mtx);\n\n\tif ((rv = nni_aio_result(aio)) != 0) {\n\t\tlog_warn(\" send aio error %s\", nng_strerror(rv));\n\t\tgoto error;\n\t}\n\n\tconn = nni_aio_get_output(aio, 0);\n\tif ((rv = tlstran_pipe_alloc(&p)) != 0) {\n\t\tnng_stream_free(conn);\n\t\tgoto error;\n\t}\n\n\tif (ep->closed) {\n\t\ttlstran_pipe_fini(p);\n\t\tnng_stream_free(conn);\n\t\trv = NNG_ECLOSED;\n\t\tgoto error;\n\t}\n\ttlstran_pipe_start(p, conn, ep);\n\tnng_stream_listener_accept(ep->listener, ep->connaio);\n\tnni_mtx_unlock(&ep->mtx);\n\treturn;\n\nerror:\n\t// When an error here occurs, let's send a notice up to the consumer.\n\t// That way it can be reported properly.\n\tif ((aio = ep->useraio) != NULL) {\n\t\tep->useraio = NULL;\n\t\tnni_aio_finish_error(aio, rv);\n\t}\n\tswitch (rv) {\n\n\tcase NNG_ENOMEM:\n\tcase NNG_ENOFILES:\n\t\tnng_sleep_aio(10, ep->timeaio);\n\t\tbreak;\n\n\tdefault:\n\t\tif (!ep->closed) {\n\t\t\tnng_stream_listener_accept(ep->listener, ep->connaio);\n\t\t}\n\t\tbreak;\n\t}\n\tnni_mtx_unlock(&ep->mtx);\n}\n\nstatic int\ntlstran_ep_init(tlstran_ep **epp, nng_url *url, nni_sock *sock)\n{\n\ttlstran_ep *ep;\n\tNNI_ARG_UNUSED(sock);\n\n\tif ((ep = NNI_ALLOC_STRUCT(ep)) == NULL) {\n\t\treturn (NNG_ENOMEM);\n\t}\n\tnni_mtx_init(&ep->mtx);\n\tNNI_LIST_INIT(&ep->busypipes, tlstran_pipe, node);\n\tNNI_LIST_INIT(&ep->waitpipes, tlstran_pipe, node);\n\tNNI_LIST_INIT(&ep->negopipes, tlstran_pipe, node);\n\n\t// ep->proto = nni_sock_proto_id(sock);\n\tep->url = url;\n#ifdef NNG_ENABLE_STATS\n\tstatic const nni_stat_info rcv_max_info = {\n\t\t.si_name   = \"rcv_max\",\n\t\t.si_desc   = \"maximum receive size\",\n\t\t.si_type   = NNG_STAT_LEVEL,\n\t\t.si_unit   = NNG_UNIT_BYTES,\n\t\t.si_atomic = true,\n\t};\n\tnni_stat_init(&ep->st_rcv_max, &rcv_max_info);\n#endif\n\n\t*epp = ep;\n\treturn (0);\n}\n\nstatic int\ntlstran_ep_init_listener(void **lp, nng_url *url, nni_listener *nlistener)\n{\n\ttlstran_ep *ep;\n\tuint16_t    af;\n\tchar *      host = url->u_hostname;\n\tnni_aio *   aio;\n\tint         rv;\n\tnni_sock *  sock = nni_listener_sock(nlistener);\n\n\tif (strcmp(url->u_scheme, \"tls+nmq-tcp\") == 0) {\n\t\taf = NNG_AF_UNSPEC;\n\t} else if (strcmp(url->u_scheme, \"tls+nmq-tcp4\") == 0) {\n\t\taf = NNG_AF_INET;\n\t} else if (strcmp(url->u_scheme, \"tls+nmq-tcp6\") == 0) {\n\t\taf = NNG_AF_INET6;\n\t} else {\n\t\treturn (NNG_EADDRINVAL);\n\t}\n\t// Check for invalid URL components.\n\tif ((strlen(url->u_path) != 0) && (strcmp(url->u_path, \"/\") != 0)) {\n\t\treturn (NNG_EADDRINVAL);\n\t}\n\tif ((url->u_fragment != NULL) || (url->u_userinfo != NULL) ||\n\t    (url->u_query != NULL)) {\n\t\treturn (NNG_EADDRINVAL);\n\t}\n\n\tif (((rv = tlstran_ep_init(&ep, url, sock)) != 0) ||\n\t    ((rv = nni_aio_alloc(&ep->connaio, tlstran_accept_cb, ep)) != 0) ||\n\t    ((rv = nni_aio_alloc(&ep->timeaio, tlstran_timer_cb, ep)) != 0)) {\n\t\treturn (rv);\n\t}\n\n\tep->authmode = NNG_TLS_AUTH_MODE_NONE;\n\n\tif (strlen(host) == 0) {\n\t\thost = NULL;\n\t}\n\n\t// XXX: We are doing lookup at listener initialization.  There\n\t// is a valid argument that this should be done at bind time,\n\t// but that would require making bind asynchronous.  In some\n\t// ways this would be worse than the cost of just waiting here.\n\t// We always recommend using local IP addresses rather than\n\t// names when possible.\n\n\tif ((rv = nni_aio_alloc(&aio, NULL, NULL)) != 0) {\n\t\ttlstran_ep_fini(ep);\n\t\treturn (rv);\n\t}\n\tnni_resolv_ip(host, url->u_port, af, true, &ep->sa, aio);\n\tnni_aio_wait(aio);\n\trv = nni_aio_result(aio);\n\tnni_aio_free(aio);\n\n\tif ((rv != 0) ||\n\t    ((rv = nng_stream_listener_alloc_url(&ep->listener, url)) != 0) ||\n\t    ((rv = nni_stream_listener_set(ep->listener, NNG_OPT_TLS_AUTH_MODE,\n\t          &ep->authmode, sizeof(ep->authmode), NNI_TYPE_INT32)) !=\n\t        0)) {\n\t\ttlstran_ep_fini(ep);\n\t\treturn (rv);\n\t}\n\n#ifdef NNG_ENABLE_STATS\n\tnni_listener_add_stat(nlistener, &ep->st_rcv_max);\n#endif\n\t*lp = ep;\n\treturn (0);\n}\n\nstatic void\ntlstran_ep_cancel(nni_aio *aio, void *arg, int rv)\n{\n\ttlstran_ep *ep = arg;\n\tnni_mtx_lock(&ep->mtx);\n\tif (ep->useraio == aio) {\n\t\tep->useraio = NULL;\n\t\tnni_aio_finish_error(aio, rv);\n\t}\n\tnni_mtx_unlock(&ep->mtx);\n}\n\n// TODO network interface bind\nstatic int\ntlstran_ep_get_url(void *arg, void *v, size_t *szp, nni_opt_type t)\n{\n\ttlstran_ep *ep = arg;\n\tchar *      s;\n\tint         rv;\n\tint         port = 0;\n\n\tif (ep->listener != NULL) {\n\t\t(void) nng_stream_listener_get_int(\n\t\t    ep->listener, NNG_OPT_TCP_BOUND_PORT, &port);\n\t}\n\n\tif ((rv = nni_url_asprintf_port(&s, ep->url, port)) == 0) {\n\t\trv = nni_copyout_str(s, v, szp, t);\n\t\tnni_strfree(s);\n\t}\n\treturn (rv);\n}\n\nstatic int\ntlstran_ep_set_conf(void *arg, const void *v, size_t sz, nni_opt_type t)\n{\n\ttlstran_ep *ep = arg;\n\tNNI_ARG_UNUSED(sz);\n\tNNI_ARG_UNUSED(t);\n\tnni_mtx_lock(&ep->mtx);\n\tep->conf = (conf *) v;\n\tnni_mtx_unlock(&ep->mtx);\n\treturn 0;\n}\n\nstatic int\ntlstran_ep_get_recvmaxsz(void *arg, void *v, size_t *szp, nni_opt_type t)\n{\n\ttlstran_ep *ep = arg;\n\tint         rv;\n\n\tnni_mtx_lock(&ep->mtx);\n\trv = nni_copyout_size(ep->rcvmax, v, szp, t);\n\tnni_mtx_unlock(&ep->mtx);\n\treturn (rv);\n}\n\nstatic int\ntlstran_ep_set_recvmaxsz(void *arg, const void *v, size_t sz, nni_opt_type t)\n{\n\ttlstran_ep *ep = arg;\n\tsize_t      val;\n\tint         rv;\n\tif ((rv = nni_copyin_size(&val, v, sz, 0, NNI_MAXSZ, t)) == 0) {\n\t\ttlstran_pipe *p;\n\t\tnni_mtx_lock(&ep->mtx);\n\t\tep->rcvmax = val;\n\t\tNNI_LIST_FOREACH (&ep->waitpipes, p) {\n\t\t\tp->rcvmax = val;\n\t\t}\n\t\tNNI_LIST_FOREACH (&ep->negopipes, p) {\n\t\t\tp->rcvmax = val;\n\t\t}\n\t\tNNI_LIST_FOREACH (&ep->busypipes, p) {\n\t\t\tp->rcvmax = val;\n\t\t}\n\t\tnni_mtx_unlock(&ep->mtx);\n#ifdef NNG_ENABLE_STATS\n\t\tnni_stat_set_value(&ep->st_rcv_max, val);\n#endif\n\t}\n\treturn (rv);\n}\n\nstatic int\ntlstran_ep_bind(void *arg)\n{\n\ttlstran_ep *ep = arg;\n\tint         rv;\n\n\tnni_mtx_lock(&ep->mtx);\n\trv = nng_stream_listener_listen(ep->listener);\n\tnni_mtx_unlock(&ep->mtx);\n\n\treturn (rv);\n}\n\nstatic void\ntlstran_ep_accept(void *arg, nni_aio *aio)\n{\n\ttlstran_ep *ep = arg;\n\tint         rv;\n\n\tif (nni_aio_begin(aio) != 0) {\n\t\treturn;\n\t}\n\tnni_mtx_lock(&ep->mtx);\n\tif (ep->closed) {\n\t\tnni_mtx_unlock(&ep->mtx);\n\t\tnni_aio_finish_error(aio, NNG_ECLOSED);\n\t\treturn;\n\t}\n\tif (ep->useraio != NULL) {\n\t\tnni_mtx_unlock(&ep->mtx);\n\t\tnni_aio_finish_error(aio, NNG_EBUSY);\n\t\treturn;\n\t}\n\tif ((rv = nni_aio_schedule(aio, tlstran_ep_cancel, ep)) != 0) {\n\t\tnni_mtx_unlock(&ep->mtx);\n\t\tnni_aio_finish_error(aio, rv);\n\t\treturn;\n\t}\n\tep->useraio = aio;\n\tif (!ep->started) {\n\t\tep->started = true;\n\t\tnng_stream_listener_accept(ep->listener, ep->connaio);\n\t} else {\n\t\ttlstran_ep_match(ep);\n\t}\n\tnni_mtx_unlock(&ep->mtx);\n}\n\n\nstatic nni_sp_pipe_ops tlstran_pipe_ops = {\n\t.p_init  = tlstran_pipe_init,\n\t.p_fini  = tlstran_pipe_fini,\n\t.p_stop  = tlstran_pipe_stop,\n\t.p_send  = tlstran_pipe_send,\n\t.p_recv  = tlstran_pipe_recv,\n\t.p_close = tlstran_pipe_close,\n\t//.p_peer   = tlstran_pipe_peer,\n\t.p_getopt = tlstran_pipe_getopt,\n};\n\nstatic const nni_option tlstran_ep_opts[] = {\n\t{\n\t    .o_name = NNG_OPT_RECVMAXSZ,\n\t    .o_get  = tlstran_ep_get_recvmaxsz,\n\t    .o_set  = tlstran_ep_set_recvmaxsz,\n\t},\n\t{\n\t    .o_name = NNG_OPT_URL,\n\t    .o_get  = tlstran_ep_get_url,\n\t},\n\t{\n\t    .o_name = NANO_CONF,\n\t    .o_set  = tlstran_ep_set_conf,\n\t},\n\t// terminate list\n\t{\n\t    .o_name = NULL,\n\t},\n};\n\nstatic int\ntlstran_listener_get(\n    void *arg, const char *name, void *buf, size_t *szp, nni_type t)\n{\n\ttlstran_ep *ep = arg;\n\tint         rv;\n\n\trv = nni_stream_listener_get(ep->listener, name, buf, szp, t);\n\tif (rv == NNG_ENOTSUP) {\n\t\trv = nni_getopt(tlstran_ep_opts, name, ep, buf, szp, t);\n\t}\n\treturn (rv);\n}\n\nstatic int\ntlstran_listener_set(\n    void *arg, const char *name, const void *buf, size_t sz, nni_type t)\n{\n\ttlstran_ep *ep = arg;\n\tint         rv;\n\n\trv = nni_stream_listener_set(\n\t    ep != NULL ? ep->listener : NULL, name, buf, sz, t);\n\tif (rv == NNG_ENOTSUP) {\n\t\trv = nni_setopt(tlstran_ep_opts, name, ep, buf, sz, t);\n\t}\n\treturn (rv);\n}\n\nstatic nni_sp_listener_ops tlstran_listener_ops = {\n\t.l_init   = tlstran_ep_init_listener,\n\t.l_fini   = tlstran_ep_fini,\n\t.l_bind   = tlstran_ep_bind,\n\t.l_accept = tlstran_ep_accept,\n\t.l_close  = tlstran_ep_close,\n\t.l_getopt = tlstran_listener_get,\n\t.l_setopt = tlstran_listener_set,\n};\n\nstatic nni_sp_tran tlstran_mqtt = {\n\t.tran_scheme   = \"tls+nmq-tcp\",\n\t.tran_listener = &tlstran_listener_ops,\n\t.tran_pipe     = &tlstran_pipe_ops,\n\t.tran_init     = tlstran_init,\n\t.tran_fini     = tlstran_fini,\n};\n\nstatic nni_sp_tran tls_tcp4_tran_mqtt = {\n\t.tran_scheme   = \"tls+nmq-tcp4\",\n\t.tran_listener = &tlstran_listener_ops,\n\t.tran_pipe     = &tlstran_pipe_ops,\n\t.tran_init     = tlstran_init,\n\t.tran_fini     = tlstran_fini,\n};\n\nstatic nni_sp_tran tls_tcp6_tran_mqtt = {\n\t.tran_scheme   = \"tls+nmq-tcp6\",\n\t.tran_listener = &tlstran_listener_ops,\n\t.tran_pipe     = &tlstran_pipe_ops,\n\t.tran_init     = tlstran_init,\n\t.tran_fini     = tlstran_fini,\n};\n\n#ifndef NNG_ELIDE_DEPRECATED\nint\nnmq_mqtt_tls_register(void)\n{\n\treturn (nni_init());\n}\n#endif\n\nvoid\nnni_nmq_broker_tls_register(void)\n{\n\tnni_sp_tran_register(&tlstran_mqtt);\n\tnni_sp_tran_register(&tls_tcp4_tran_mqtt);\n\tnni_sp_tran_register(&tls_tcp6_tran_mqtt);\n}\n", "//\n// Copyright 2022 NanoMQ Team, Inc. <jaylin@emqx.io>\n//\n// This software is supplied under the terms of the MIT License, a\n// copy of which should be located in the distribution where this\n// file was obtained (LICENSE.txt).  A copy of the license may also be\n// found online at https://opensource.org/licenses/MIT.\n//\n\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <string.h>\n\n#include \"core/nng_impl.h\"\n#include \"core/sockimpl.h\"\n#include \"supplemental/websocket/websocket.h\"\n\n#include \"nng/supplemental/tls/tls.h\"\n#include \"nng/transport/mqttws/nmq_websocket.h\"\n\n#include \"nng/protocol/mqtt/mqtt.h\"\n#include \"nng/protocol/mqtt/mqtt_parser.h\"\n#include \"nng/supplemental/nanolib/mqtt_db.h\"\n#include \"nng/supplemental/nanolib/conf.h\"\n#include \"supplemental/mqtt/mqtt_qos_db_api.h\"\n#include \"supplemental/mqtt/mqtt_msg.h\"\n\ntypedef struct ws_listener ws_listener;\ntypedef struct ws_pipe     ws_pipe;\n\nstruct ws_listener {\n\tuint16_t             peer; // remote protocol\n\tconf                *conf;\n\tnni_list             aios;\n\tnni_mtx              mtx;\n\tnni_aio             *accaio;\n\tnng_stream_listener *listener;\n\tbool                 started;\n};\n\nstruct ws_pipe {\n\tnni_mtx     mtx;\n\tbool        closed;\n\tuint8_t     txlen[NANO_MIN_PACKET_LEN];\n\tuint16_t    peer;\n\tsize_t      gotrxhead;\n\tsize_t      wantrxhead;\n\tconf       *conf;\n\tnni_msg    *tmp_msg;\n\tnni_aio    *user_txaio;\n\tnni_aio    *user_rxaio;\n\tnni_aio    *ep_aio;\n\tnni_aio    *txaio;\n\tnni_aio    *rxaio;\n\tnni_aio    *qsaio;\n\tnni_pipe   *npipe;\n\tconn_param *ws_param;\n\tnng_stream *ws;\n\tuint8_t    *qos_buf; // msg trunk for qos & V4/V5 conversion\n\tsize_t      qlength; // length of qos_buf\n\t// MQTT V5\n\tuint16_t qrecv_quota;\n\tuint32_t qsend_quota;\n};\n\nstatic void\nwstran_pipe_send_cb(void *arg)\n{\n\tws_pipe *p = arg;\n\tnni_aio *taio;\n\tnni_aio *uaio;\n\n\tnni_mtx_lock(&p->mtx);\n\ttaio          = p->txaio;\n\tuaio          = p->user_txaio;\n\tp->user_txaio = NULL;\n\n\tif (uaio != NULL) {\n\t\tint rv;\n\t\tif ((rv = nni_aio_result(taio)) != 0) {\n\t\t\tnni_aio_finish_error(uaio, rv);\n\t\t} else {\n\t\t\tnni_aio_finish(uaio, 0, 0);\n\t\t}\n\t}\n\tnni_mtx_unlock(&p->mtx);\n}\n\nstatic void\nwstran_pipe_qos_send_cb(void *arg)\n{\n\tws_pipe *p = arg;\n\tnni_aio *qsaio;\n\n\tlog_trace(\" wstran_pipe_qos_send_cb \");\n\tqsaio          = p->qsaio;\n\n\tnni_msg *msg = nni_aio_get_msg(qsaio);\n\tif (msg != NULL) {\n\t\tnni_msg_free(msg);\n\t}\n}\n\nstatic void\nwstran_pipe_recv_cb(void *arg)\n{\n\tws_pipe *p = arg;\n\tnni_iov  iov[2];\n\tuint8_t  rv;\n\tuint32_t pos = 1;\n\tuint64_t len = 0;\n\tuint8_t *ptr;\n\tnni_msg *smsg = NULL, *msg = NULL;\n\tnni_aio *raio = p->rxaio;\n\tnni_aio *uaio = NULL;\n\tbool     ack  = false;\n\n\tnni_mtx_lock(&p->mtx);\n\t// only sets uaio at first time\n\tif (p->user_rxaio != NULL) {\n\t\tuaio = p->user_rxaio;\n\t}\n\t// process scatterd msgs\n\tif ((rv = nni_aio_result(raio)) != 0) {\n\t\tlog_warn(\" recv aio error %s\", nng_strerror(rv));\n\t\tgoto reset;\n\t}\n\tmsg = nni_aio_get_msg(raio);\n\tif (nni_msg_header_len(msg) == 0 && nni_msg_len(msg) == 0) {\n\t\tlog_trace(\"empty msg received! continue next receive\");\n\t\tgoto recv;\n\t}\n\tptr = nni_msg_body(msg);\n\tp->gotrxhead += nni_msg_len(msg);\n\tlog_trace(\"#### wstran_pipe_recv_cb got %ld msg: %p %x %ld\",\n\t    p->gotrxhead, ptr, *ptr, nni_msg_len(msg));\n\t// first we collect complete Fixheader\n\tif (p->tmp_msg == NULL && p->gotrxhead > 0) {\n\t\tif ((rv = nni_msg_alloc(&p->tmp_msg, 0)) != 0) {\n\t\t\tlog_error(\"mem error %ld\\n\", (size_t) len);\n\t\t\tgoto reset;\n\t\t}\n\t}\n\t// TODO use IOV instead of appending msg\n\tnni_msg_append(p->tmp_msg, ptr, nni_msg_len(msg));\n\tptr = nni_msg_body(p->tmp_msg); // packet might be sticky?\n\n\tif (p->wantrxhead == 0) {\n\t\tif (p->gotrxhead == 1) {\n\t\t\tgoto recv;\n\t\t}\n\t\tlen = get_var_integer(ptr, &pos);\n\t\tif (*(ptr + pos - 1) > 0x7f) {\n\t\t\t// continue to next byte of remaining length\n\t\t\tif (p->gotrxhead >= NNI_NANO_MAX_HEADER_SIZE) {\n\t\t\t\t// length error\n\t\t\t\trv = NNG_EMSGSIZE;\n\t\t\t\tgoto reset;\n\t\t\t}\n\t\t} else {\n\t\t\t// Fixed header finished\n\t\t\tp->wantrxhead = len + pos;\n\t\t\tnni_msg_set_cmd_type(p->tmp_msg, *ptr & 0xf0);\n\t\t}\n\t}\n\tif (p->gotrxhead >= p->wantrxhead) {\n\t\tgoto done;\n\t}\n\nrecv:\n\tnni_msg_free(msg);\n\tnng_stream_recv(p->ws, raio);\n\tnni_mtx_unlock(&p->mtx);\n\treturn;\ndone:\n\tif (uaio == NULL) {\n\t\tuaio = p->ep_aio;\n\t}\n\tif (uaio != NULL) {\n\t\tif (p->gotrxhead+p->wantrxhead > p->conf->max_packet_size) {\n\t\t\tlog_trace(\"size error 0x95\\n\");\n\t\t\trv = NMQ_PACKET_TOO_LARGE;\n\t\t\tgoto recv_error;\n\t\t}\n\t\tp->gotrxhead  = 0;\n\t\tp->wantrxhead = 0;\n\t\tnni_msg_free(msg);\n\t\tif (nni_msg_cmd_type(p->tmp_msg) == CMD_CONNECT) {\n\t\t\t// end of nego\n\t\t\tif (p->ws_param == NULL) {\n\t\t\t\tconn_param_alloc(&p->ws_param);\n\t\t\t}\n\t\t\tif (conn_handler(nni_msg_body(p->tmp_msg), p->ws_param,\n\t\t\t        nni_msg_len(p->tmp_msg)) != 0) {\n\t\t\t\tconn_param_free(p->ws_param);\n\t\t\t\trv = NNG_ECONNRESET;\n\t\t\t\tgoto reset;\n\t\t\t}\n\t\t\tif (p->ws_param->pro_ver == 5) {\n\t\t\t\tp->qsend_quota = p->ws_param->rx_max;\n\t\t\t}\n\t\t\tif (p->ws_param->max_packet_size == 0) {\n\t\t\t\t// set default max packet size for client\n\t\t\t\tp->ws_param->max_packet_size =\n\t\t\t\t    p->conf->client_max_packet_size;\n\t\t\t}\n\t\t\tnni_msg_free(p->tmp_msg);\n\t\t\tp->tmp_msg = NULL;\n\t\t\tnni_aio_set_output(uaio, 0, p);\n\t\t\t// pipe_start_cb send CONNACK\n\t\t\tnni_aio_finish(uaio, 0, 0);\n\t\t\tnni_mtx_unlock(&p->mtx);\n\t\t\treturn;\n\t\t} else {\n\t\t\tif (nni_msg_alloc(&smsg, 0) != 0) {\n\t\t\t\tgoto reset;\n\t\t\t}\n\t\t\t// parse fixed header\n\t\t\tws_msg_adaptor(ptr, smsg);\n\t\t\t// msg = p->tmp_msg;\n\t\t\tnni_msg_free(p->tmp_msg);\n\t\t\tp->tmp_msg = NULL;\n\t\t\tnni_msg_set_conn_param(smsg, p->ws_param);\n\t\t}\n\n\t\tuint8_t   qos_pac;\n\t\tproperty *prop        = NULL;\n\t\tuint8_t   reason_code = 0;\n\t\tuint8_t   ack_cmd     = 0;\n\n\t\tuint16_t packet_id = 0;\n\t\tnni_msg *qmsg;\n\t\tuint8_t  cmd = nni_msg_cmd_type(smsg);\n\t\tif (cmd == CMD_PUBLISH) {\n\t\t\tqos_pac = nni_msg_get_pub_qos(smsg);\n\t\t\tif (qos_pac > 0) {\n\t\t\t\t// flow control, check rx_max\n\t\t\t\t// recv_quota as length of lmq\n\t\t\t\tif (p->ws_param->pro_ver == 5) {\n\t\t\t\t\tif (p->qrecv_quota > 0) {\n\t\t\t\t\t\tp->qrecv_quota--;\n\t\t\t\t\t} else {\n\t\t\t\t\t\trv = NMQ_RECEIVE_MAXIMUM_EXCEEDED;\n\t\t\t\t\t\tgoto recv_error;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (qos_pac == 1) {\n\t\t\t\t\tack_cmd = CMD_PUBACK;\n\t\t\t\t} else if (qos_pac == 2) {\n\t\t\t\t\tack_cmd = CMD_PUBREC;\n\t\t\t\t} else {\n\t\t\t\t\tlog_warn(\"Wrong QoS level!\");\n\t\t\t\t\trv = PROTOCOL_ERROR;\n\t\t\t\t\tgoto recv_error;\n\t\t\t\t}\n\t\t\t\tif ((packet_id = nni_msg_get_pub_pid(msg)) ==\n\t\t\t\t    0) {\n\t\t\t\t\trv = PROTOCOL_ERROR;\n\t\t\t\t\tgoto recv_error;\n\t\t\t\t}\n\t\t\t\tack = true;\n\t\t\t}\n\t\t} else if (cmd == CMD_PUBREC) {\n\t\t\tif (nni_mqtt_pubres_decode(smsg, &packet_id, &reason_code, &prop,\n\t\t\t        p->ws_param->pro_ver) != 0) {\n\t\t\t\tlog_trace(\"decode PUBREC variable header failed!\");\n\t\t\t}\n\t\t\tack_cmd = CMD_PUBREL;\n\t\t\tack     = true;\n\t\t} else if (cmd == CMD_PUBREL) {\n\t\t\tif (nni_mqtt_pubres_decode(smsg, &packet_id, &reason_code, &prop,\n\t\t\t        p->ws_param->pro_ver) != 0) {\n\t\t\t\tlog_trace(\"decode PUBREL variable header failed!\");\n\t\t\t}\n\t\t\tack_cmd = CMD_PUBCOMP;\n\t\t\tack     = true;\n\t\t} else if (cmd == CMD_PUBACK || cmd == CMD_PUBCOMP) {\n\t\t\tif (nni_mqtt_pubres_decode(smsg, &packet_id, &reason_code, &prop,\n\t\t\t        p->ws_param->pro_ver) != 0) {\n\t\t\t\tlog_trace(\"decode PUBACK or PUBCOMP variable header \"\n\t\t\t\t          \"failed!\");\n\t\t\t}\n\t\t\t// MQTT V5 flow control\n\t\t\tif (p->ws_param->pro_ver == 5) {\n\t\t\t\tproperty_free(prop);\n\t\t\t\tp->qsend_quota++;\n\t\t\t}\n\t\t} else if (cmd == CMD_PINGREQ) {\n\t\t\t// reply PINGRESP\n\t\t\tack = true;\n\t\t}\n\n\t\tif (ack == true) {\n\t\t\t// alloc a msg here costs memory. However we must do it for the\n\t\t\t// sake of compatibility with nng.\n\t\t\tif ((rv = nni_msg_alloc(&qmsg, 0)) != 0) {\n\t\t\t\tack = false;\n\t\t\t\trv  = NMQ_SERVER_BUSY;\n\t\t\t\tlog_error(\"ERROR: OOM in WebSocket\");\n\t\t\t\tgoto recv_error;\n\t\t\t}\n\t\t\tif (cmd == CMD_PINGREQ) {\n\t\t\t\tuint8_t buf[2] = { CMD_PINGRESP, 0x00 };\n\t\t\t\tnni_msg_set_cmd_type(qmsg, CMD_PINGRESP);\n\t\t\t\tnni_msg_header_append(qmsg, buf, 2);\n\t\t\t\tnng_aio_wait(p->qsaio);\n\t\t\t\tiov[0].iov_len = nni_msg_header_len(qmsg);\n\t\t\t\tiov[0].iov_buf = nni_msg_header(qmsg);\n\t\t\t\tnni_aio_set_msg(p->qsaio, qmsg);\n\t\t\t\t// send ACK down...\n\t\t\t\tnni_aio_set_iov(p->qsaio, 1, iov);\n\t\t\t\tnng_stream_send(p->ws, p->qsaio);\n\t\t\t\t//ignore PING msg, only notify\n\t\t\t} else {\n\t\t\t\t// TODO set reason code or property here if\n\t\t\t\t// necessary\n\t\t\t\tnni_msg_set_cmd_type(qmsg, ack_cmd);\n\t\t\t\tnni_mqtt_msgack_encode(qmsg, packet_id, reason_code,\n\t\t\t\t    prop, p->ws_param->pro_ver);\n\t\t\t\tnni_mqtt_pubres_header_encode(qmsg, ack_cmd);\n\t\t\t\tnng_aio_wait(p->qsaio);\n\t\t\t\tiov[0].iov_len = nni_msg_header_len(qmsg);\n\t\t\t\tiov[0].iov_buf = nni_msg_header(qmsg);\n\t\t\t\tiov[1].iov_len = nni_msg_len(qmsg);\n\t\t\t\tiov[1].iov_buf = nni_msg_body(qmsg);\n\t\t\t\tnni_aio_set_msg(p->qsaio, qmsg);\n\t\t\t\t// send ACK down...\n\t\t\t\tnni_aio_set_iov(p->qsaio, 2, iov);\n\t\t\t\tnng_stream_send(p->ws, p->qsaio);\n\t\t\t}\n\t\t}\n\t\tnni_aio_set_msg(uaio, smsg);\n\t\tnni_aio_set_output(uaio, 0, p);\n\t} else {\n\t\tgoto reset;\n\t}\n\tnni_mtx_unlock(&p->mtx);\n\tnni_aio_finish(uaio, 0, nni_msg_len(smsg));\n\treturn;\nreset:\n\tp->gotrxhead  = 0;\n\tp->wantrxhead = 0;\n\tnng_stream_close(p->ws);\n\tif (uaio != NULL) {\n\t\tnni_aio_finish_error(uaio, rv);\n\t} else if (p->ep_aio != NULL) {\n\t\tnni_aio_finish_error(p->ep_aio, rv);\n\t}\n\tif (p->tmp_msg != NULL) {\n\t\tsmsg = p->tmp_msg;\n\t\tnni_msg_free(smsg);\n\t\tp->tmp_msg = NULL;\n\t}\n\tnni_mtx_unlock(&p->mtx);\n\treturn;\n\nrecv_error:\n\t//TODO fixme\n\t// nni_aio_list_remove(aio);\n\t// msg      = p->rxmsg;\n\t// p->rxmsg = NULL;\n\tnni_pipe_bump_error(p->npipe, rv);\n\tnni_mtx_unlock(&p->mtx);\n\tnni_msg_free(msg);\n\t// nni_aio_finish_error(aio, rv);\n\tlog_error(\"tcptran_pipe_recv_cb: recv error rv: %d\\n\", rv);\n\treturn;\n}\n\nstatic void\nwstran_pipe_recv_cancel(nni_aio *aio, void *arg, int rv)\n{\n\tws_pipe *p = arg;\n\tnni_mtx_lock(&p->mtx);\n\tif (p->user_rxaio != aio) {\n\t\tnni_mtx_unlock(&p->mtx);\n\t\treturn;\n\t}\n\tp->user_rxaio = NULL;\n\tnni_aio_abort(p->rxaio, rv);\n\tnni_aio_finish_error(aio, rv);\n\tnni_mtx_unlock(&p->mtx);\n}\n\nstatic void\nwstran_pipe_recv(void *arg, nni_aio *aio)\n{\n\tws_pipe *p = arg;\n\tint      rv;\n\n\tif (nni_aio_begin(aio) != 0) {\n\t\treturn;\n\t}\n\tnni_mtx_lock(&p->mtx);\n\tif ((rv = nni_aio_schedule(aio, wstran_pipe_recv_cancel, p)) != 0) {\n\t\tnni_mtx_unlock(&p->mtx);\n\t\tnni_aio_finish_error(aio, rv);\n\t\treturn;\n\t}\n\tp->user_rxaio = aio;\n\tnng_stream_recv(p->ws, p->rxaio);\n\tnni_mtx_unlock(&p->mtx);\n}\n\nstatic void\nwstran_pipe_send_cancel(nni_aio *aio, void *arg, int rv)\n{\n\tws_pipe *p = arg;\n\tnni_mtx_lock(&p->mtx);\n\tif (p->user_txaio != aio) {\n\t\tnni_mtx_unlock(&p->mtx);\n\t\treturn;\n\t}\n\tp->user_txaio = NULL;\n\tnni_aio_abort(p->txaio, rv);\n\tnni_aio_finish_error(aio, rv);\n\tnni_mtx_unlock(&p->mtx);\n}\n\nstatic inline void\nwstran_pipe_send_start_v4(ws_pipe *p, nni_msg *msg, nni_aio *aio)\n{\n\tnni_msg *smsg;\n\tint       niov;\n\tnni_iov   iov[8];\n\tnni_pipe *pipe = p->npipe;\n\tuint8_t   qos;\n\n\n\tif (nni_msg_get_type(msg) != CMD_PUBLISH)\n\t\tgoto send;\n\n\t// never modify the original msg\n\tuint8_t *     body, *header, qos_pac;\n\tint           len_offset = 0;\n\tuint16_t      pid;\n\tuint32_t      prop_bytes = 0, property_len = 0;\n\tsize_t        tlen, rlen, mlen, qlength, plength;\n\tbool          is_sqlite = p->conf->sqlite.enable;\n\n\tbody    = nni_msg_body(msg);\n\theader  = nni_msg_header(msg);\n\tniov    = 0;\n\tqlength = 0;\n\tplength = 0;\n\tmlen    = nni_msg_len(msg);\n\tqos_pac = nni_msg_get_pub_qos(msg);\n\tNNI_GET16(body, tlen);\n\n\tsubinfo *info, *tinfo=NULL;\n\tnni_msg_alloc(&smsg, 0);\n\tif (nni_msg_cmd_type(msg) == CMD_PUBLISH_V5) {\n\t\t// V5 to V4 shrink msg, remove property length\n\t\t// APP layer must give topic name even if topic\n\t\t// alias is set\n\t\tif (qos_pac > 0) {\n\t\t\tproperty_len =\n\t\t\t    get_var_integer(body + 4 + tlen, &prop_bytes);\n\n\t\t} else {\n\t\t\tproperty_len =\n\t\t\t    get_var_integer(body + 2 + tlen, &prop_bytes);\n\t\t}\n\t\tplength       = property_len + prop_bytes;\n\t}\n\n\tNNI_LIST_FOREACH (p->npipe->subinfol, info) {\n\t\tif (tinfo != NULL && info != tinfo ) {\n\t\t\tcontinue;\n\t\t}\n\t\ttinfo = NULL;\n\t\tlen_offset=0;\n\t\tchar *sub_topic = info->topic;\n\t\tif (sub_topic[0] == '$') {\n\t\t\tif (0 == strncmp(sub_topic, \"$share/\", strlen(\"$share/\"))) {\n\t\t\t\tsub_topic = strchr(sub_topic, '/');\n\t\t\t\tsub_topic++;\n\t\t\t\tsub_topic = strchr(sub_topic, '/');\n\t\t\t\tsub_topic++;\n\t\t\t}\n\t\t}\n\t\tif (topic_filtern(sub_topic, (char*)(body + 2), tlen)) {\n\t\t\tuint8_t  var_extra[2], fixheader, tmp[4] = { 0 };\n\t\t\tuint32_t pos = 1;\n\t\t\tqos          = info->qos;\n\t\t\tfixheader    = *header;\n\n\t\t\t// get final qos\n\t\t\tqos = qos_pac > qos ? qos : qos_pac;\n\n\t\t\t// alter qos according to sub qos\n\t\t\tif (qos_pac > qos) {\n\t\t\t\tif (qos == 1) {\n\t\t\t\t\t// set qos to 1\n\t\t\t\t\tfixheader = fixheader & 0xF9;\n\t\t\t\t\tfixheader = fixheader | 0x02;\n\t\t\t\t} else {\n\t\t\t\t\t// set qos to 0\n\t\t\t\t\tfixheader = fixheader & 0xF9;\n\t\t\t\t\tlen_offset   = len_offset - 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// fixed header + remaining length\n\t\t\trlen = put_var_integer(tmp,\n\t\t\t    get_var_integer(header, &pos) + len_offset -\n\t\t\t        plength);\n\t\t\t*(p->qos_buf + qlength) = fixheader;\n\t\t\t// copy remaining length\n\t\t\tmemcpy(p->qos_buf + qlength + 1, tmp, rlen);\n\t\t\tiov[niov].iov_buf = p->qos_buf + qlength;\n\t\t\tiov[niov].iov_len = rlen + 1;\n\t\t\tniov++;\n\t\t\tqlength += rlen + 1;\n\t\t\t// 1st part of variable header: topic + topic len\n\t\t\tiov[niov].iov_buf = body;\n\t\t\tiov[niov].iov_len = tlen+2;\n\t\t\tniov++;\n\t\t\t// len to indicate the offset in packet\n\t\t\tlen_offset = 0;\n\t\t\tif (qos > 0) {\n\t\t\t\t// set pid\n\t\t\t\tlen_offset = 2;\n\t\t\t\tnni_msg *old;\n\t\t\t\t// packetid in aio to differ resend msg\n\t\t\t\t// TODO replace it with set prov data\n\t\t\t\tpid = (uint16_t)(size_t) nni_aio_get_prov_data(aio);\n\t\t\t\tif (pid == 0) {\n\t\t\t\t\t// first time send this msg\n\t\t\t\t\tpid = nni_pipe_inc_packetid(pipe);\n\t\t\t\t\t// store msg for qos retrying\n\t\t\t\t\tnni_msg_clone(msg);\n\t\t\t\t\tif ((old = nni_qos_db_get(is_sqlite,\n\t\t\t\t\t         pipe->nano_qos_db, pipe->p_id,\n\t\t\t\t\t         pid)) != NULL) {\n\t\t\t\t\t\t// TODO packetid already\n\t\t\t\t\t\t// exists. we need to\n\t\t\t\t\t\t// replace old with new one\n\t\t\t\t\t\t// print warning to users\n\t\t\t\t\t\tnni_println(\"ERROR: packet id \"\n\t\t\t\t\t\t            \"duplicates in \"\n\t\t\t\t\t\t            \"nano_qos_db\");\n\t\t\t\t\t\tnni_qos_db_remove_msg(\n\t\t\t\t\t\t    is_sqlite,\n\t\t\t\t\t\t    pipe->nano_qos_db, old);\n\t\t\t\t\t}\n\t\t\t\t\told = msg;\n\t\t\t\t\tnni_qos_db_set(is_sqlite,\n\t\t\t\t\t    pipe->nano_qos_db, pipe->p_id, pid,\n\t\t\t\t\t    old);\n\t\t\t\t\tnni_qos_db_remove_oldest(is_sqlite,\n\t\t\t\t\t    pipe->nano_qos_db,\n\t\t\t\t\t    p->conf->sqlite.disk_cache_size);\n\t\t\t\t}\n\t\t\t\tNNI_PUT16(var_extra, pid);\n\t\t\t\t// copy packet id\n\t\t\t\tmemcpy(p->qos_buf + qlength, var_extra, 2);\n\t\t\t} else if (qos_pac > 0) {\n\t\t\t\t//ignore the packet id of original packet\n\t\t\t\tlen_offset += 2;\n\t\t\t}\n\t\t\t// 2nd part of variable header: pid\n\t\t\tiov[niov].iov_buf = p->qos_buf + qlength;\n\t\t\tiov[niov].iov_len = qos > 0 ? 2 : 0;\n\t\t\tniov++;\n\t\t\tqlength += qos > 0 ? 2 : 0;\n\t\t\t// body\n\t\t\tiov[niov].iov_buf = body + 2 + tlen + len_offset + plength;\n\t\t\tiov[niov].iov_len = mlen - 2 - len_offset - tlen - plength;\n\t\t\tniov++;\n\t\t\t// apending directly\n\t\t\tfor (int i = 0; i < niov; i++) {\n\t\t\t\tnni_msg_append(\n\t\t\t\t    smsg, iov[i].iov_buf, iov[i].iov_len);\n\t\t\t}\n\t\t\tniov = 0;\n\t\t}\n\t}\n\n\t// duplicated msg is gonna be freed by http. so we free old one\n\t// here\n\tnni_msg_free(msg);\n\tmsg = smsg;\n\n// normal sending if it is not PUBLISH\nsend:\n\tnni_aio_set_msg(aio, msg);\n\tnni_aio_set_msg(p->txaio, msg);\n\tnni_aio_set_msg(aio, NULL);\n\t// verify connect\n\t// for websocket, cmd type is 0x00 for PUBLISH\n\tif (nni_msg_cmd_type(msg) == CMD_CONNACK) {\n\t\tuint8_t *header = nni_msg_header(msg);\n\t\tif (*(header + 3) != 0x00) {\n\t\t\tnni_pipe_close(p->npipe);\n\t\t}\n\t}\n\tnng_stream_send(p->ws, p->txaio);\n}\n\n\n\nstatic inline void\nwstran_pipe_send_start_v5(ws_pipe *p, nni_msg *msg, nni_aio *aio)\n{\n\tnni_msg *smsg;\n\tint       niov;\n\tnni_iov   iov[8];\n\tnni_pipe *pipe = p->npipe;\n\tuint8_t   qos = 0;\n\n\n\tif (nni_msg_get_type(msg) != CMD_PUBLISH)\n\t\tgoto send;\n\n\t// never modify the original msg\n\tuint8_t *     body, *header, qos_pac;\n\ttarget_prover target_prover;\n\tint           len_offset = 0, sub_id = 0;\n\tuint16_t      pid;\n\tuint32_t tprop_bytes = 0, prop_bytes = 0, id_bytes = 0, property_len = 0;\n\tsize_t        tlen, rlen, mlen, hlen, qlength, plength;\n\tbool          is_sqlite = p->conf->sqlite.enable;\n\n\tbody    = nni_msg_body(msg);\n\theader  = nni_msg_header(msg);\n\tniov    = 0;\n\tqlength = 0;\n\tplength = 0;\n\tmlen    = nni_msg_len(msg);\n\thlen    = nni_msg_header_len(msg);\n\tqos_pac = nni_msg_get_pub_qos(msg);\n\tNNI_GET16(body, tlen);\n\n\t// check max packet size for this client/msg\n\tuint32_t total_len = mlen + hlen;\n\tif (total_len > p->ws_param->max_packet_size) {\n\t\t// drop msg and finish aio\n\t\t// pretend it has been sent\n\t\tlog_warn(\"msg dropped due to overceed max packet size!\");\n\t\tnni_msg_free(msg);\n\t\tnni_aio_set_msg(aio, NULL);\n\t\tnni_aio_finish(aio, 0, 0);\n\t\treturn;\n\t}\n\n\tif (nni_msg_cmd_type(msg) == CMD_PUBLISH_V5) {\n\t\t// V5 to V4 shrink msg, remove property length\n\t\t// APP layer must give topic name even if topic\n\t\t// alias is set\n\t\tif (qos_pac > 0) {\n\t\t\tproperty_len = get_var_integer(\n\t\t\t    body + 4 + tlen, &prop_bytes);\n\n\t\t} else {\n\t\t\tproperty_len = get_var_integer(\n\t\t\t    body + 2 + tlen, &prop_bytes);\n\t\t}\n\t\ttarget_prover = MQTTV5;\n\t\tplength = property_len + prop_bytes;\n\t}\n\n\t// subid\n\tsubinfo *info = NULL;\n\tnni_msg_alloc(&smsg, 0);\n\n\tNNI_LIST_FOREACH (p->npipe->subinfol, info) {\n\t\tif (info->no_local == 1 &&\n\t\t    p->npipe->p_id == nni_msg_get_pipe(msg)) {\n\t\t\tcontinue;\n\t\t}\n\t\tlen_offset      = 0;\n\t\tchar *sub_topic = info->topic;\n\t\tif (sub_topic[0] == '$') {\n\t\t\tif (0 ==\n\t\t\t    strncmp(sub_topic, \"$share/\", strlen(\"$share/\"))) {\n\t\t\t\tsub_topic = strchr(sub_topic, '/');\n\t\t\t\tsub_topic++;\n\t\t\t\tsub_topic = strchr(sub_topic, '/');\n\t\t\t\tsub_topic++;\n\t\t\t}\n\t\t}\n\t\tif (topic_filtern(sub_topic, (char *) (body + 2), tlen)) {\n\t\t\tuint8_t  var_extra[2], fixheader, tmp[4] = { 0 };\n\t\t\tuint8_t  proplen[4] = { 0 }, var_subid[5] = { 0 };\n\t\t\tuint32_t pos = 1;\n\t\t\tsub_id       = info->subid;\n\t\t\tqos          = info->qos;\n\n\t\t\t//else use original var payload & pid\n\t\t\tfixheader = *header;\n\t\t\tif (nni_msg_cmd_type(msg) == CMD_PUBLISH) {\n\t\t\t\t// V4 to V5 add 0 property length\n\t\t\t\ttarget_prover = MQTTV4_V5;\n\t\t\t\tprop_bytes    = 1;\n\t\t\t\ttprop_bytes   = 1;\n\t\t\t\tlen_offset    = 1;\n\t\t\t}\n\t\t\tif (info->rap == 0) {\n\t\t\t\tfixheader = fixheader & 0xFE;\n\t\t\t}\n\t\t\tif (sub_id != 0) {\n\t\t\t\tvar_subid[0] = 0x0B;\n\t\t\t\tid_bytes = put_var_integer(var_subid+1, sub_id);\n\t\t\t\ttprop_bytes = put_var_integer(proplen, property_len+1+id_bytes);\n\t\t\t\tlen_offset += (tprop_bytes - prop_bytes + 1 + id_bytes);\n\t\t\t}\n\n\t\t\t// get final qos\n\t\t\tqos = qos_pac > qos ? qos : qos_pac;\n\n\t\t\t// alter qos according to sub qos\n\t\t\tif (qos_pac > qos) {\n\t\t\t\tif (qos == 1) {\n\t\t\t\t\t// set qos to 1\n\t\t\t\t\tfixheader = fixheader & 0xF9;\n\t\t\t\t\tfixheader = fixheader | 0x02;\n\t\t\t\t} else {\n\t\t\t\t\t// set qos to 0\n\t\t\t\t\tfixheader = fixheader & 0xF9;\n\t\t\t\t\tlen_offset   = len_offset - 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// fixed header + remaining length\n\t\t\trlen = put_var_integer(\n\t\t\t    tmp, get_var_integer(header, &pos) + len_offset);\n\t\t\t// or just copy to qosbuf directly?\n\t\t\t*(p->qos_buf + qlength) = fixheader;\n\t\t\tmemcpy(p->qos_buf + qlength + 1, tmp, rlen);\n\t\t\tiov[niov].iov_buf = p->qos_buf + qlength;\n\t\t\tiov[niov].iov_len = rlen + 1;\n\t\t\tniov++;\n\t\t\tqlength += rlen + 1;\n\t\t\t// 1st part of variable header: topic + topic len\n\t\t\tiov[niov].iov_buf = body;\n\t\t\tiov[niov].iov_len = tlen+2;\n\t\t\tniov++;\n\t\t\t// len to indicate the offset in packet\n\t\t\tlen_offset = 0;\n\t\t\tplength = 0;\n\t\t\tif (qos > 0) {\n\t\t\t\t// set pid\n\t\t\t\tlen_offset = 2;\n\t\t\t\tnni_msg *old;\n\t\t\t\t// packetid in aio to differ resend msg\n\t\t\t\t// TODO replace it with set prov data\n\t\t\t\tpid = (uint16_t)(size_t) nni_aio_get_prov_data(\n\t\t\t\t    aio);\n\t\t\t\tif (pid == 0) {\n\t\t\t\t\t// first time send this msg\n\t\t\t\t\tpid = nni_pipe_inc_packetid(pipe);\n\t\t\t\t\t// store msg for qos retrying\n\t\t\t\t\tnni_msg_clone(msg);\n\t\t\t\t\tif ((old = nni_qos_db_get(is_sqlite,\n\t\t\t\t\t         pipe->nano_qos_db, pipe->p_id,\n\t\t\t\t\t         pid)) != NULL) {\n\t\t\t\t\t\t// TODO packetid already\n\t\t\t\t\t\t// exists. we need to\n\t\t\t\t\t\t// replace old with new one\n\t\t\t\t\t\t// print warning to users\n\t\t\t\t\t\tnni_println(\"ERROR: packet id \"\n\t\t\t\t\t\t            \"duplicates in \"\n\t\t\t\t\t\t            \"nano_qos_db\");\n\t\t\t\t\t\tnni_qos_db_remove_msg(\n\t\t\t\t\t\t    is_sqlite,\n\t\t\t\t\t\t    pipe->nano_qos_db, old);\n\t\t\t\t\t}\n\t\t\t\t\told = msg;\n\t\t\t\t\tnni_qos_db_set(is_sqlite,\n\t\t\t\t\t    pipe->nano_qos_db, pipe->p_id, pid,\n\t\t\t\t\t    old);\n\t\t\t\t\tnni_qos_db_remove_oldest(is_sqlite,\n\t\t\t\t\t    pipe->nano_qos_db,\n\t\t\t\t\t    p->conf->sqlite.disk_cache_size);\n\t\t\t\t}\n\t\t\t\tNNI_PUT16(var_extra, pid);\n\t\t\t\t// copy packet id\n\t\t\t\tmemcpy(p->qos_buf + qlength, var_extra, 2);\n\t\t\t\tqlength += 2;\n\t\t\t\tplength += 2;\n\t\t\t} else if (qos_pac > 0) {\n\t\t\t\t//ignore the packet id of original packet\n\t\t\t\tlen_offset += 2;\n\t\t\t}\n\t\t\t// prop len + sub id if any\n\t\t\tif (sub_id != 0) {\n\t\t\t\tmemcpy(p->qos_buf + qlength, proplen,\n\t\t\t\t    tprop_bytes);\n\t\t\t\tqlength += tprop_bytes;\n\t\t\t\tplength += tprop_bytes;\n\t\t\t\tmemcpy(p->qos_buf + qlength, var_subid,\n\t\t\t\t    id_bytes + 1);\n\t\t\t\tqlength += id_bytes + 1;\n\t\t\t\tplength += id_bytes + 1;\n\t\t\t\tif (target_prover == MQTTV5)\n\t\t\t\t\tlen_offset += prop_bytes;\n\t\t\t} else {\n\t\t\t\t//need to add 0 len for V4 msg\n\t\t\t\tif (target_prover == MQTTV4_V5) {\n\t\t\t\t\t// add proplen even 0\n\t\t\t\t\tmemcpy(p->qos_buf + qlength, proplen,\n\t\t\t\t\t    tprop_bytes);\n\t\t\t\t\tqlength += tprop_bytes;\n\t\t\t\t\tplength += tprop_bytes;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 2nd part of variable header: pid + proplen+0x0B+subid\n\t\t\tiov[niov].iov_buf = p->qos_buf+qlength-plength;\n\t\t\tiov[niov].iov_len = plength;\n\t\t\tniov++;\n\t\t\t// prop + body\n\t\t\tiov[niov].iov_buf = body + 2 + tlen + len_offset;\n\t\t\tiov[niov].iov_len = mlen - 2 - len_offset - tlen;\n\t\t\tniov++;\n\t\t\t// apending directly\n\t\t\tfor (int i = 0; i < niov; i++) {\n\t\t\t\tnni_msg_append(\n\t\t\t\t    smsg, iov[i].iov_buf, iov[i].iov_len);\n\t\t\t}\n\t\t\tniov = 0;\n\t\t}\n\t}\n\n\t// duplicated msg is gonna be freed by http. so we free old one\n\t// here\n\tnni_msg_free(msg);\n\tmsg = smsg;\n\n\t// MQTT V5 flow control\n\tif (qos > 0) {\n\t\tif (p->qsend_quota > 0) {\n\t\t\tp->qsend_quota--;\n\t\t} else {\n\t\t\t// what should broker does when exceed\n\t\t\t// max_recv? msg lost, make it look like a\n\t\t\t// normal send. qos msg will be resend\n\t\t\t// afterwards\n\t\t\tnni_msg_free(msg);\n\t\t\t// nni_aio_set_prov_data(txaio, NULL);\n\t\t\tnni_aio_set_msg(aio, NULL);\n\t\t\tnni_aio_finish(aio, 0, 0);\n\t\t\treturn;\n\t\t}\n\t}\n\n// normal sending if it is not PUBLISH\nsend:\n\tnni_aio_set_msg(aio, msg);\n\tnni_aio_set_msg(p->txaio, msg);\n\tnni_aio_set_msg(aio, NULL);\n\t// verify connect\n\tif (nni_msg_cmd_type(msg) == CMD_CONNACK) {\n\t\tuint8_t *header = nni_msg_header(msg);\n\t\tif (*(header + 3) != 0x00) {\n\t\t\tnni_pipe_close(p->npipe);\n\t\t}\n\t}\n\tnng_stream_send(p->ws, p->txaio);\n}\n\nstatic void\nwstran_pipe_send_start(ws_pipe *p)\n{\n\tnni_msg *msg;\n\tnng_aio *aio = p->user_txaio;\n\tmsg          = nni_aio_get_msg(aio);\n\n\tif (msg == NULL || p->ws_param == NULL) {\n\t\t// TODO error handler\n\t\tnni_println(\"ERROR: sending NULL msg or pipe is invalid!\");\n\t\tnni_aio_finish(aio, NNG_ECANCELED, 0);\n\t\treturn;\n\t}\n\n\tif (p->ws_param->pro_ver == 4) {\n\t\twstran_pipe_send_start_v4(p, msg, aio);\n\t\treturn;\n\t} else if (p->ws_param->pro_ver == 5) {\n\t\twstran_pipe_send_start_v5(p, msg, aio);\n\t\treturn;\n\t}\n\n}\n\nstatic void\nwstran_pipe_send(void *arg, nni_aio *aio)\n{\n\tws_pipe *p = arg;\n\tint      rv;\n\n\tif (nni_aio_begin(aio) != 0) {\n\t\treturn;\n\t}\n\tnni_mtx_lock(&p->mtx);\n\tif ((rv = nni_aio_schedule(aio, wstran_pipe_send_cancel, p)) != 0) {\n\t\tnni_mtx_unlock(&p->mtx);\n\t\tnni_aio_finish_error(aio, rv);\n\t\treturn;\n\t}\n\tp->user_txaio = aio;\n\twstran_pipe_send_start(p);\n\n\tnni_mtx_unlock(&p->mtx);\n}\n\nstatic void\nwstran_pipe_stop(void *arg)\n{\n\tws_pipe *p = arg;\n\n\tnni_aio_stop(p->rxaio);\n\tnni_aio_stop(p->txaio);\n\tnni_aio_stop(p->qsaio);\n}\n\nstatic int\nwstran_pipe_init(void *arg, nni_pipe *pipe)\n{\n\tlog_trace(\"************wstran_pipe_init************\");\n\tws_pipe *p = arg;\n\n\tnni_pipe_set_conn_param(pipe, p->ws_param);\n\tp->npipe      = pipe;\n\n\tif (!p->conf->sqlite.enable) {\n\t\tnni_qos_db_init_id_hash(pipe->nano_qos_db);\n\t}\n\n\tp->gotrxhead  = 0;\n\tp->wantrxhead = 0;\n\tp->ep_aio     = NULL;\n\n\tp->qos_buf = nng_zalloc(16 + NNI_NANO_MAX_PACKET_SIZE);\n\t// the size limit of qos_buf reserve 1 byte for property length\n\tp->qlength = 16 + NNI_NANO_MAX_PACKET_SIZE;\n\treturn (0);\n}\n\nstatic void\nwstran_pipe_fini(void *arg)\n{\n\tws_pipe *p = arg;\n\n\tnni_aio_free(p->rxaio);\n\tnni_aio_free(p->txaio);\n\tnni_aio_free(p->qsaio);\n\n\tnng_stream_free(p->ws);\n\tnni_msg_free(p->tmp_msg);\n\tnni_mtx_fini(&p->mtx);\n\tnng_free(p->qos_buf, 16 + NNI_NANO_MAX_PACKET_SIZE);\n\tNNI_FREE_STRUCT(p);\n}\n\nstatic void\nwstran_pipe_close(void *arg)\n{\n\tws_pipe *p = arg;\n\n\tnni_aio_close(p->rxaio);\n\tnni_aio_close(p->qsaio);\n\tnni_aio_close(p->txaio);\n\n\tnni_mtx_lock(&p->mtx);\n\tnng_stream_close(p->ws);\n\tnni_mtx_unlock(&p->mtx);\n}\n\nstatic int\nwstran_pipe_alloc(ws_pipe **pipep, void *ws)\n{\n\tws_pipe *p;\n\tint      rv;\n\n\tif ((p = NNI_ALLOC_STRUCT(p)) == NULL) {\n\t\treturn (NNG_ENOMEM);\n\t}\n\tnni_mtx_init(&p->mtx);\n\n\t// Initialize AIOs.\n\tif (((rv = nni_aio_alloc(&p->txaio, wstran_pipe_send_cb, p)) != 0) ||\n\t    ((rv = nni_aio_alloc(&p->qsaio, wstran_pipe_qos_send_cb, p)) != 0) ||\n\t    ((rv = nni_aio_alloc(&p->rxaio, wstran_pipe_recv_cb, p)) != 0)) {\n\t\twstran_pipe_fini(p);\n\t\treturn (rv);\n\t}\n\tp->ws = ws;\n\n\t*pipep = p;\n\treturn (0);\n}\n\nstatic uint16_t\nwstran_pipe_peer(void *arg)\n{\n\tws_pipe *p = arg;\n\n\treturn (p->peer);\n}\n\nstatic int\nws_listener_bind(void *arg)\n{\n\tws_listener *l = arg;\n\tint          rv;\n\n\tif ((rv = nng_stream_listener_listen(l->listener)) == 0) {\n\t\tl->started = true;\n\t}\n\treturn (rv);\n}\n\nstatic void\nws_listener_cancel(nni_aio *aio, void *arg, int rv)\n{\n\tws_listener *l = arg;\n\n\tnni_mtx_lock(&l->mtx);\n\tif (nni_aio_list_active(aio)) {\n\t\tnni_aio_list_remove(aio);\n\t\tnni_aio_finish_error(aio, rv);\n\t}\n\tnni_mtx_unlock(&l->mtx);\n}\n\nstatic void\nwstran_listener_accept(void *arg, nni_aio *aio)\n{\n\tws_listener *l = arg;\n\tint          rv;\n\n\t// We already bound, so we just need to look for an available\n\t// pipe (created by the handler), and match it.\n\t// Otherwise we stick the AIO in the accept list.\n\tif (nni_aio_begin(aio) != 0) {\n\t\treturn;\n\t}\n\tnni_mtx_lock(&l->mtx);\n\tif ((rv = nni_aio_schedule(aio, ws_listener_cancel, l)) != 0) {\n\t\tnni_mtx_unlock(&l->mtx);\n\t\tnni_aio_finish_error(aio, rv);\n\t\treturn;\n\t}\n\tnni_list_append(&l->aios, aio);\n\tif (aio == nni_list_first(&l->aios)) {\n\t\tnng_stream_listener_accept(l->listener, l->accaio);\n\t}\n\tnni_mtx_unlock(&l->mtx);\n}\n\nstatic const nni_option ws_pipe_options[] = {\n\t// terminate list\n\t{\n\t    .o_name = NULL,\n\t}\n};\n\nstatic int\nwstran_pipe_getopt(\n    void *arg, const char *name, void *buf, size_t *szp, nni_type t)\n{\n\tws_pipe *p = arg;\n\tint      rv;\n\n\tif ((rv = nni_stream_get(p->ws, name, buf, szp, t)) == NNG_ENOTSUP) {\n\t\trv = nni_getopt(ws_pipe_options, name, p, buf, szp, t);\n\t}\n\treturn (rv);\n}\n\nstatic nni_sp_pipe_ops ws_pipe_ops = {\n\t.p_init   = wstran_pipe_init,\n\t.p_fini   = wstran_pipe_fini,\n\t.p_stop   = wstran_pipe_stop,\n\t.p_send   = wstran_pipe_send,\n\t.p_recv   = wstran_pipe_recv,\n\t.p_close  = wstran_pipe_close,\n\t.p_peer   = wstran_pipe_peer,\n\t.p_getopt = wstran_pipe_getopt,\n};\n\nstatic void\nwstran_listener_fini(void *arg)\n{\n\tws_listener *l = arg;\n\n\tnni_aio_stop(l->accaio);\n\tnng_stream_listener_free(l->listener);\n\tnni_aio_free(l->accaio);\n\tnni_mtx_fini(&l->mtx);\n\tNNI_FREE_STRUCT(l);\n}\n\nstatic void\nwstran_listener_close(void *arg)\n{\n\tws_listener *l = arg;\n\n\tnni_aio_close(l->accaio);\n\tnng_stream_listener_close(l->listener);\n}\n\nstatic void\nws_pipe_start(ws_pipe *pipe, nng_stream *conn, ws_listener *l)\n{\n\tNNI_ARG_UNUSED(conn);\n\tws_pipe *p = pipe;\n\tlog_trace(\"ws_pipe_start!\");\n\tp->qrecv_quota = NANO_MAX_QOS_PACKET;\n\tp->conf        = l->conf;\n\tnng_stream_recv(p->ws, p->rxaio);\n}\n\nstatic void\nwstran_accept_cb(void *arg)\n{\n\tws_listener *l    = arg;\n\tnni_aio *    aaio = l->accaio;\n\tnni_aio *    uaio;\n\tint          rv;\n\n\tnni_mtx_lock(&l->mtx);\n\tuaio = nni_list_first(&l->aios);\n\tif ((rv = nni_aio_result(aaio)) != 0) {\n\t\tif (uaio != NULL) {\n\t\t\tnni_aio_list_remove(uaio);\n\t\t\tnni_aio_finish_error(uaio, rv);\n\t\t}\n\t} else {\n\t\tnng_stream *ws = nni_aio_get_output(aaio, 0);\n\t\tif (uaio != NULL) {\n\t\t\tws_pipe *p;\n\t\t\t// Make a pipe\n\t\t\tnni_aio_list_remove(uaio);\n\t\t\tif ((rv = wstran_pipe_alloc(&p, ws)) != 0) {\n\t\t\t\tnng_stream_close(ws);\n\t\t\t\tnni_aio_finish_error(uaio, rv);\n\t\t\t} else {\n\t\t\t\tp->peer = l->peer;\n\t\t\t\tws_pipe_start(p, p->ws, l);\n\t\t\t\tp->ep_aio = uaio;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!nni_list_empty(&l->aios)) {\n\t\tnng_stream_listener_accept(l->listener, aaio);\n\t}\n\tnni_mtx_unlock(&l->mtx);\n}\n\n\n// TODO proto name modify\nstatic int\nwstran_listener_init(void **lp, nng_url *url, nni_listener *listener)\n{\n\tws_listener *l;\n\tint          rv;\n\tnni_sock *   s = nni_listener_sock(listener);\n\tchar         name[64];\n\n\tif ((l = NNI_ALLOC_STRUCT(l)) == NULL) {\n\t\treturn (NNG_ENOMEM);\n\t}\n\tnni_mtx_init(&l->mtx);\n\n\tnni_aio_list_init(&l->aios);\n\n\tl->peer = nni_sock_peer_id(s);\n\n\tsnprintf(name, sizeof(name), \"mqtt\");\n\n\tif (((rv = nni_ws_listener_alloc(&l->listener, url)) != 0) ||\n\t    ((rv = nni_aio_alloc(&l->accaio, wstran_accept_cb, l)) != 0) ||\n\t    ((rv = nng_stream_listener_set_bool(\n\t          l->listener, NNI_OPT_WS_MSGMODE, true)) != 0) ||\n\t    ((rv = nng_stream_listener_set_string(\n\t          l->listener, NNG_OPT_WS_PROTOCOL, name)) != 0)) {\n\t\twstran_listener_fini(l);\n\t\treturn (rv);\n\t}\n\t*lp = l;\n\treturn (0);\n}\n\nstatic void\nwstran_init(void)\n{\n}\n\nstatic void\nwstran_fini(void)\n{\n}\n\nstatic int\nwstran_ep_set_conf(void *arg, const void *v, size_t sz, nni_type t)\n{\n\tws_listener *l = arg;\n\tNNI_ARG_UNUSED(sz);\n\tNNI_ARG_UNUSED(t);\n\tnni_mtx_lock(&l->mtx);\n\tl->conf = (conf *) v;\n\tnni_mtx_unlock(&l->mtx);\n\treturn 0;\n}\n\nstatic const nni_option wstran_ep_opts[] = {\n\t{\n\t    .o_name = NANO_CONF,\n\t    .o_set  = wstran_ep_set_conf,\n\t},\n\t// terminate list\n\t{\n\t    .o_name = NULL,\n\t},\n};\n\n\nstatic int\nwstran_listener_get(\n    void *arg, const char *name, void *buf, size_t *szp, nni_type t)\n{\n\tws_listener *l = arg;\n\tint          rv;\n\n\trv = nni_stream_listener_get(l->listener, name, buf, szp, t);\n\tif (rv == NNG_ENOTSUP) {\n\t\trv = nni_getopt(wstran_ep_opts, name, l, buf, szp, t);\n\t}\n\treturn (rv);\n}\n\nstatic int\nwstran_listener_set(\n    void *arg, const char *name, const void *buf, size_t sz, nni_type t)\n{\n\tws_listener *l = arg;\n\tint          rv;\n\n\trv = nni_stream_listener_set(l->listener, name, buf, sz, t);\n\tif (rv == NNG_ENOTSUP) {\n\t\trv = nni_setopt(wstran_ep_opts, name, l, buf, sz, t);\n\t}\n\treturn (rv);\n}\n\nstatic nni_sp_listener_ops ws_listener_ops = {\n\t.l_init   = wstran_listener_init,\n\t.l_fini   = wstran_listener_fini,\n\t.l_bind   = ws_listener_bind,\n\t.l_accept = wstran_listener_accept,\n\t.l_close  = wstran_listener_close,\n\t.l_setopt = wstran_listener_set,\n\t.l_getopt = wstran_listener_get,\n};\n\nstatic nni_sp_tran ws__tran = {\n\t.tran_scheme   = \"nmq+ws\",\n\t.tran_dialer   = NULL,\n\t.tran_listener = &ws_listener_ops,\n\t.tran_pipe     = &ws_pipe_ops,\n\t.tran_init     = wstran_init,\n\t.tran_fini     = wstran_fini,\n};\n\nstatic nni_sp_tran ws4__tran = {\n\t.tran_scheme   = \"nmq+ws4\",\n\t.tran_dialer   = NULL,\n\t.tran_listener = &ws_listener_ops,\n\t.tran_pipe     = &ws_pipe_ops,\n\t.tran_init     = wstran_init,\n\t.tran_fini     = wstran_fini,\n};\n\nstatic nni_sp_tran ws6__tran = {\n\t.tran_scheme   = \"nmq+ws6\",\n\t.tran_dialer   = NULL,\n\t.tran_listener = &ws_listener_ops,\n\t.tran_pipe     = &ws_pipe_ops,\n\t.tran_init     = wstran_init,\n\t.tran_fini     = wstran_fini,\n};\n\nstatic nni_sp_tran ws_tran = {\n\t.tran_scheme   = \"nmq-ws\",\n\t.tran_dialer   = NULL,\n\t.tran_listener = &ws_listener_ops,\n\t.tran_pipe     = &ws_pipe_ops,\n\t.tran_init     = wstran_init,\n\t.tran_fini     = wstran_fini,\n};\n\nstatic nni_sp_tran ws4_tran = {\n\t.tran_scheme   = \"nmq-ws4\",\n\t.tran_dialer   = NULL,\n\t.tran_listener = &ws_listener_ops,\n\t.tran_pipe     = &ws_pipe_ops,\n\t.tran_init     = wstran_init,\n\t.tran_fini     = wstran_fini,\n};\n\nstatic nni_sp_tran ws6_tran = {\n\t.tran_scheme   = \"nmq-ws6\",\n\t.tran_dialer   = NULL,\n\t.tran_listener = &ws_listener_ops,\n\t.tran_pipe     = &ws_pipe_ops,\n\t.tran_init     = wstran_init,\n\t.tran_fini     = wstran_fini,\n};\n\n#ifndef NNG_ELIDE_DEPRECATED\nint\nnng_nmq_ws_register(void)\n{\n\treturn (nni_init());\n}\n\nint\nnng_nmq_wss_register(void)\n{\n\treturn (nni_init());\n}\n#endif\n\nvoid\nnni_nmq_ws_register(void)\n{\n\tnni_sp_tran_register(&ws_tran);\n\tnni_sp_tran_register(&ws4_tran);\n\tnni_sp_tran_register(&ws6_tran);\n\tnni_sp_tran_register(&ws__tran);\n\tnni_sp_tran_register(&ws4__tran);\n\tnni_sp_tran_register(&ws6__tran);\n}\n\n#ifdef NNG_TRANSPORT_WSS\n\nstatic nni_sp_tran wss__tran = {\n\t.tran_scheme   = \"nmq+wss\",\n\t.tran_dialer   = NULL,\n\t.tran_listener = &ws_listener_ops,\n\t.tran_pipe     = &ws_pipe_ops,\n\t.tran_init     = wstran_init,\n\t.tran_fini     = wstran_fini,\n};\n\nstatic nni_sp_tran wss4__tran = {\n\t.tran_scheme   = \"nmq+wss4\",\n\t.tran_dialer   = NULL,\n\t.tran_listener = &ws_listener_ops,\n\t.tran_pipe     = &ws_pipe_ops,\n\t.tran_init     = wstran_init,\n\t.tran_fini     = wstran_fini,\n};\n\nstatic nni_sp_tran wss6__tran = {\n\t.tran_scheme   = \"nmq+wss6\",\n\t.tran_dialer   = NULL,\n\t.tran_listener = &ws_listener_ops,\n\t.tran_pipe     = &ws_pipe_ops,\n\t.tran_init     = wstran_init,\n\t.tran_fini     = wstran_fini,\n};\n\nstatic nni_sp_tran wss_tran = {\n\t.tran_scheme   = \"nmq-wss\",\n\t.tran_dialer   = NULL,\n\t.tran_listener = &ws_listener_ops,\n\t.tran_pipe     = &ws_pipe_ops,\n\t.tran_init     = wstran_init,\n\t.tran_fini     = wstran_fini,\n};\n\nstatic nni_sp_tran wss4_tran = {\n\t.tran_scheme   = \"nmq-wss4\",\n\t.tran_dialer   = NULL,\n\t.tran_listener = &ws_listener_ops,\n\t.tran_pipe     = &ws_pipe_ops,\n\t.tran_init     = wstran_init,\n\t.tran_fini     = wstran_fini,\n};\n\nstatic nni_sp_tran wss6_tran = {\n\t.tran_scheme   = \"nmq-wss6\",\n\t.tran_dialer   = NULL,\n\t.tran_listener = &ws_listener_ops,\n\t.tran_pipe     = &ws_pipe_ops,\n\t.tran_init     = wstran_init,\n\t.tran_fini     = wstran_fini,\n};\n\nvoid\nnni_nmq_wss_register(void)\n{\n\tnni_sp_tran_register(&wss_tran);\n\tnni_sp_tran_register(&wss4_tran);\n\tnni_sp_tran_register(&wss6_tran);\n\tnni_sp_tran_register(&wss__tran);\n\tnni_sp_tran_register(&wss4__tran);\n\tnni_sp_tran_register(&wss6__tran);\n}\n\n#endif // NNG_TRANSPORT_WSS\n"], "filenames": ["src/mqtt/transport/tls/mqtt_tls.c", "src/sp/transport/mqtts/broker_tls.c", "src/sp/transport/mqttws/nmq_websocket.c"], "buggy_code_start_loc": [697, 719, 252], "buggy_code_end_loc": [700, 722, 256], "fixing_code_start_loc": [698, 720, 253], "fixing_code_end_loc": [707, 729, 264], "type": "CWE-787", "message": "A heap buffer overflow vulnerability exists in NanoMQ 0.17.2. The vulnerability can be triggered by calling the function nni_msg_get_pub_pid() in the file message.c. An attacker could exploit this vulnerability to cause a denial of service attack.", "other": {"cve": {"id": "CVE-2023-33658", "sourceIdentifier": "cve@mitre.org", "published": "2023-06-08T12:15:09.240", "lastModified": "2023-06-14T19:12:15.637", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A heap buffer overflow vulnerability exists in NanoMQ 0.17.2. The vulnerability can be triggered by calling the function nni_msg_get_pub_pid() in the file message.c. An attacker could exploit this vulnerability to cause a denial of service attack."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:emqx:nanomq:0.17.2:*:*:*:*:*:*:*", "matchCriteriaId": "0898CABA-5930-437A-8300-4D91648091F1"}]}]}], "references": [{"url": "https://github.com/emqx/nanomq", "source": "cve@mitre.org", "tags": ["Product"]}, {"url": "https://github.com/emqx/nanomq/issues/1153", "source": "cve@mitre.org", "tags": ["Exploit"]}, {"url": "https://github.com/nanomq/NanoNNG/commit/657e6c81c474bdee0e6413483b990e90610030c1", "source": "cve@mitre.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/nanomq/NanoNNG/commit/657e6c81c474bdee0e6413483b990e90610030c1"}}