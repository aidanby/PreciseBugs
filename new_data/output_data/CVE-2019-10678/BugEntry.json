{"buggy_code": ["#include \"stdafx.h\"\n#include \"Helper.h\"\n#include \"Logger.h\"\n#ifdef WIN32\n#include \"dirent_windows.h\"\n#include <direct.h>\n#else\n#include <dirent.h>\n#include <unistd.h>\n#endif\n#if !defined(WIN32)\n#include <sys/ptrace.h>\n#endif\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <fstream>\n#include <math.h>\n#include <algorithm>\n#include \"../main/localtime_r.h\"\n#include <sstream>\n#include <openssl/md5.h>\n#include <chrono>\n#include <limits.h>\n#include <cstring>\n\n#if defined WIN32\n#include \"../msbuild/WindowsHelper.h\"\n#endif\n\n#include \"RFXtrx.h\"\n#include \"../hardware/hardwaretypes.h\"\n\n// Includes for SystemUptime()\n#if defined(__linux__) || defined(__linux) || defined(linux)\n#include <sys/sysinfo.h>\n#elif defined(macintosh) || defined(__APPLE__) || defined(__APPLE_CC__)\n#include <time.h>\n#include <errno.h>\n#include <sys/sysctl.h>\n#elif defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__) || defined(__DragonFly__)\n#include <time.h>\n#endif\n\n#if defined(__FreeBSD__) \n// Check if OpenBSD or DragonFly need that at well?\n#include <pthread_np.h>\n#ifndef PTHREAD_MAX_MAMELEN_NP\n#define PTHREAD_MAX_NAMELEN_NP 32 \t// Arbitrary\n#endif\n#endif\n\nvoid StringSplit(std::string str, const std::string &delim, std::vector<std::string> &results)\n{\n\tresults.clear();\n\tsize_t cutAt;\n\twhile( (cutAt = str.find(delim)) != std::string::npos )\n\t{\n\t\tresults.push_back(str.substr(0,cutAt));\n\t\tstr = str.substr(cutAt+ delim.size());\n\t}\n\tif (!str.empty())\n\t{\n\t\tresults.push_back(str);\n\t}\n}\n\nuint64_t hexstrtoui64(const std::string &str)\n{\n\tuint64_t ul;\n\tstd::stringstream ss;\n\tss << std::hex << str;\n\tss >> ul;\n\treturn ul;\n}\n\nvoid stdreplace(\n\tstd::string &inoutstring,\n\tconst std::string& replaceWhat,\n\tconst std::string& replaceWithWhat)\n{\n\tint pos = 0;\n\twhile (std::string::npos != (pos = inoutstring.find(replaceWhat, pos)))\n\t{\n\t\tinoutstring.replace(pos, replaceWhat.size(), replaceWithWhat);\n\t\tpos += replaceWithWhat.size();\n\t}\n}\n\nvoid stdupper(std::string &inoutstring)\n{\n\tfor (size_t i = 0; i < inoutstring.size(); ++i)\n\t\tinoutstring[i] = toupper(inoutstring[i]);\n}\n\nvoid stdlower(std::string &inoutstring)\n{\n\tstd::transform(inoutstring.begin(), inoutstring.end(), inoutstring.begin(), ::tolower);\n}\n\nstd::vector<std::string> GetSerialPorts(bool &bUseDirectPath)\n{\n\tbUseDirectPath=false;\n\n\tstd::vector<std::string> ret;\n#if defined WIN32\n\t//windows\n\n\tstd::vector<int> ports;\n\tstd::vector<std::string> friendlyNames;\n\tchar szPortName[40];\n\n\tEnumSerialFromWMI(ports, friendlyNames);\n\n\tbool bFoundPort = false;\n\tif (!ports.empty())\n\t{\n\t\tbFoundPort = true;\n\t\tfor (const auto & itt : ports)\n\t\t{\n\t\t\tsprintf(szPortName, \"COM%d\", itt);\n\t\t\tret.push_back(szPortName);\n\t\t}\n\t}\n\n\tif (bFoundPort)\n\t\treturn ret;\n\n\t//Scan old fashion way (SLOW!)\n\tCOMMCONFIG cc;\n\tDWORD dwSize = sizeof(COMMCONFIG);\n\tfor (int ii = 0; ii < 256; ii++)\n\t{\n\t\tsprintf(szPortName, \"COM%d\", ii);\n\t\tif (GetDefaultCommConfig(szPortName, &cc, &dwSize))\n\t\t{\n\t\t\tbFoundPort = true;\n\t\t\tsprintf(szPortName, \"COM%d\", ii);\n\n\t\t\t//Check if we did not already have it\n\t\t\tbool bFound = false;\n\t\t\tfor (const auto & itt : ret)\n\t\t\t{\n\t\t\t\tif (itt == szPortName)\n\t\t\t\t{\n\t\t\t\t\tbFound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!bFound)\n\t\t\t\tret.push_back(szPortName); // add port\n\t\t}\n\t}\n\t// Method 2: CreateFile, slow\n\t// ---------\n\tif (!bFoundPort) {\n\t\tfor (int ii = 0; ii < 256; ii++)\n\t\t{\n\t\t\tsprintf(szPortName, \"\\\\\\\\.\\\\COM%d\", ii);\n\t\t\tbool bSuccess = false;\n\t\t\tHANDLE hPort = ::CreateFile(szPortName, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING, 0, 0);\n\t\t\tif (hPort == INVALID_HANDLE_VALUE) {\n\t\t\t\tDWORD dwError = GetLastError();\n\t\t\t\t//Check to see if the error was because some other app had the port open\n\t\t\t\tif (dwError == ERROR_ACCESS_DENIED)\n\t\t\t\t\tbSuccess = TRUE;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t//The port was opened successfully\n\t\t\t\tbSuccess = TRUE;\n\t\t\t\t//Don't forget to close the port, since we are going to do nothing with it anyway\n\t\t\t\tCloseHandle(hPort);\n\t\t\t}\n\t\t\tif (bSuccess) {\n\t\t\t\tbFoundPort = true;\n\t\t\t\tsprintf(szPortName, \"COM%d\", ii);\n\t\t\t\tret.push_back(szPortName); // add port\n\t\t\t}\n\t\t\t// --------------\n\t\t}\n\t}\n\t// Method 3: EnumSerialPortsWindows, often fails\n\t// ---------\n\tif (!bFoundPort) {\n\t\tstd::vector<SerialPortInfo> serialports;\n\t\tEnumSerialPortsWindows(serialports);\n\t\tif (!serialports.empty())\n\t\t{\n\t\t\tfor (const auto & itt : serialports)\n\t\t\t{\n\t\t\t\tret.push_back(itt.szPortName); // add port\n\t\t\t}\n\t\t}\n\t}\n\n#else\n\t//scan /dev for /dev/ttyUSB* or /dev/ttyS* or /dev/tty.usbserial* or /dev/ttyAMA* or /dev/ttySAC*\n\t//also scan /dev/serial/by-id/* on Linux\n\n\tbool bHaveTtyAMAfree=false;\n\tstd::string sLine = \"\";\n\tstd::ifstream infile;\n\n\tinfile.open(\"/boot/cmdline.txt\");\n\tif (infile.is_open())\n\t{\n\t\tif (!infile.eof())\n\t\t{\n\t\t\tgetline(infile, sLine);\n\t\t\tbHaveTtyAMAfree=(sLine.find(\"ttyAMA0\")==std::string::npos);\n\t\t}\n\t}\n\n\tDIR *d=NULL;\n\td=opendir(\"/dev\");\n\tif (d != NULL)\n\t{\n\t\tstruct dirent *de=NULL;\n\t\t// Loop while not NULL\n\t\twhile ((de = readdir(d)))\n\t\t{\n\t\t\t// Only consider character devices and symbolic links\n                        if ((de->d_type == DT_CHR) || (de->d_type == DT_LNK))\n                        {\n\t\t\tstd::string fname = de->d_name;\n\t\t\tif (fname.find(\"ttyUSB\")!=std::string::npos)\n\t\t\t{\n\t\t\t\tret.push_back(\"/dev/\" + fname);\n\t\t\t}\n\t\t\telse if (fname.find(\"tty.usbserial\")!=std::string::npos)\n\t\t\t{\n\t\t\t\tbUseDirectPath=true;\n\t\t\t\tret.push_back(\"/dev/\" + fname);\n\t\t\t}\n\t\t\telse if (fname.find(\"ttyACM\")!=std::string::npos)\n\t\t\t{\n\t\t\t\tbUseDirectPath=true;\n\t\t\t\tret.push_back(\"/dev/\" + fname);\n\t\t\t}\n\t\t\telse if (fname.find(\"ttySAC\") != std::string::npos)\n\t\t\t{\n\t\t\t\tbUseDirectPath = true;\n\t\t\t\tret.push_back(\"/dev/\" + fname);\n\t\t\t}\n#if defined (__FreeBSD__) || defined (__OpenBSD__) || defined (__NetBSD__)\n\t\t\telse if (fname.find(\"ttyU\")!=std::string::npos)\n\t\t\t{\n\t\t\t\tbUseDirectPath=true;\n\t\t\t\tret.push_back(\"/dev/\" + fname);\n\t\t\t}\n\t\t\telse if (fname.find(\"cuaU\")!=std::string::npos)\n\t\t\t{\n\t\t\t\tbUseDirectPath=true;\n\t\t\t\tret.push_back(\"/dev/\" + fname);\n\t\t\t}\n#endif\n#ifdef __APPLE__\n\t\t\telse if (fname.find(\"cu.\")!=std::string::npos)\n\t\t\t{\n\t\t\t\tbUseDirectPath=true;\n\t\t\t\tret.push_back(\"/dev/\" + fname);\n\t\t\t}\n#endif\n\t\t\tif (bHaveTtyAMAfree)\n\t\t\t{\n\t\t\t\tif (fname.find(\"ttyAMA0\")!=std::string::npos)\n\t\t\t\t{\n\t\t\t\t\tret.push_back(\"/dev/\" + fname);\n\t\t\t\t\tbUseDirectPath=true;\n\t\t\t\t}\n\t\t\t\t// By default, this is the \"small UART\" on Rasberry 3 boards\n                                        if (fname.find(\"ttyS0\")!=std::string::npos)\n                                        {\n                                                ret.push_back(\"/dev/\" + fname);\n                                                bUseDirectPath=true;\n                                        }\n                                        // serial0 and serial1 are new with Rasbian Jessie\n                                        // Avoids confusion between Raspberry 2 and 3 boards\n                                        // More info at http://spellfoundry.com/2016/05/29/configuring-gpio-serial-port-raspbian-jessie-including-pi-3/\n                                        if (fname.find(\"serial\")!=std::string::npos)\n                                        {\n                                                ret.push_back(\"/dev/\" + fname);\n                                                bUseDirectPath=true;\n                                        }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tclosedir(d);\n\t}\n\t//also scan in /dev/usb\n\td=opendir(\"/dev/usb\");\n\tif (d != NULL)\n\t{\n\t\tstruct dirent *de=NULL;\n\t\t// Loop while not NULL\n\t\twhile ((de = readdir(d)))\n\t\t{\n\t\t\tstd::string fname = de->d_name;\n\t\t\tif (fname.find(\"ttyUSB\")!=std::string::npos)\n\t\t\t{\n\t\t\t\tbUseDirectPath=true;\n\t\t\t\tret.push_back(\"/dev/usb/\" + fname);\n\t\t\t}\n\t\t}\n\t\tclosedir(d);\n\t}\n\n#if defined(__linux__) || defined(__linux) || defined(linux)\n\td=opendir(\"/dev/serial/by-id\");\n\tif (d != NULL)\n\t{\n\t\tstruct dirent *de=NULL;\n\t\t// Loop while not NULL\n\t\twhile ((de = readdir(d)))\n\t\t{\n\t\t\t// Only consider symbolic links\n                        if (de->d_type == DT_LNK)\n                        {\n\t\t\t\tstd::string fname = de->d_name;\n\t\t\t\tret.push_back(\"/dev/serial/by-id/\" + fname);\n\t\t\t}\n\t\t}\n\t\tclosedir(d);\n\t}\n\n#endif\n#endif\n\treturn ret;\n}\n\nbool file_exist (const char *filename)\n{\n\tstruct stat sbuffer;\n\treturn (stat(filename, &sbuffer) == 0);\n}\n\ndouble CalculateAltitudeFromPressure(double pressure)\n{\n\tdouble seaLevelPressure=101325.0;\n\tdouble altitude = 44330.0 * (1.0 - pow( (pressure / seaLevelPressure), 0.1903));\n\treturn altitude;\n}\n\n/**************************************************************************/\n/*!\nCalculates the altitude (in meters) from the specified atmospheric\npressure (in hPa), sea-level pressure (in hPa), and temperature (in \u00b0C)\n@param seaLevel Sea-level pressure in hPa\n@param atmospheric Atmospheric pressure in hPa\n@param temp Temperature in degrees Celsius\n*/\n/**************************************************************************/\nfloat pressureToAltitude(float seaLevel, float atmospheric, float temp)\n{\n\t/* Hyposometric formula: */\n\t/* */\n\t/* ((P0/P)^(1/5.257) - 1) * (T + 273.15) */\n\t/* h = ------------------------------------- */\n\t/* 0.0065 */\n\t/* */\n\t/* where: h = height (in meters) */\n\t/* P0 = sea-level pressure (in hPa) */\n\t/* P = atmospheric pressure (in hPa) */\n\t/* T = temperature (in \u00b0C) */\n\treturn (((float)pow((seaLevel / atmospheric), 0.190223F) - 1.0F)\n\t\t* (temp + 273.15F)) / 0.0065F;\n}\n\n/**************************************************************************/\n/*!\nCalculates the sea-level pressure (in hPa) based on the current\naltitude (in meters), atmospheric pressure (in hPa), and temperature\n(in \u00b0C)\n@param altitude altitude in meters\n@param atmospheric Atmospheric pressure in hPa\n@param temp Temperature in degrees Celsius\n*/\n/**************************************************************************/\nfloat pressureSeaLevelFromAltitude(float altitude, float atmospheric, float temp)\n{\n\t/* Sea-level pressure: */\n\t/* */\n\t/* 0.0065*h */\n\t/* P0 = P * (1 - ----------------- ) ^ -5.257 */\n\t/* T+0.0065*h+273.15 */\n\t/* */\n\t/* where: P0 = sea-level pressure (in hPa) */\n\t/* P = atmospheric pressure (in hPa) */\n\t/* h = altitude (in meters) */\n\t/* T = Temperature (in \u00b0C) */\n\treturn atmospheric * (float)pow((1.0F - (0.0065F * altitude) /\n\t\t(temp + 0.0065F * altitude + 273.15F)), -5.257F);\n}\n\n\nstd::string &stdstring_ltrim(std::string &s)\n{\n\twhile (!s.empty())\n\t{\n\t\tif (s[0] != ' ')\n\t\t\treturn s;\n\t\ts = s.substr(1);\n\t}\n\t//\ts.erase(s.begin(), std::find_if(s.begin(), s.end(), std::not1(std::ptr_fun<int, int>(std::isspace))));\n\treturn s;\n}\n\nstd::string &stdstring_rtrim(std::string &s)\n{\n\twhile (!s.empty())\n\t{\n\t\tif (s[s.size() - 1] != ' ')\n\t\t\treturn s;\n\t\ts = s.substr(0, s.size() - 1);\n\t}\n\t//s.erase(std::find_if(s.rbegin(), s.rend(), std::not1(std::ptr_fun<int, int>(std::isspace))).base(), s.end());\n\treturn s;\n}\n\n// trim from both ends\nstd::string &stdstring_trim(std::string &s)\n{\n\treturn stdstring_ltrim(stdstring_rtrim(s));\n}\n\ndouble CalculateDewPoint(double temp, int humidity)\n{\n\tif (humidity==0)\n\t\treturn temp;\n\tdouble dew_numer = 243.04*(log(double(humidity)/100.0)+((17.625*temp)/(temp+243.04)));\n\tdouble dew_denom = 17.625-log(double(humidity)/100.0)-((17.625*temp)/(temp+243.04));\n\tif (dew_numer==0)\n\t\tdew_numer=1;\n\treturn dew_numer/dew_denom;\n}\n\nuint32_t IPToUInt(const std::string &ip)\n{\n\tint a, b, c, d;\n\tuint32_t addr = 0;\n\n\tif (sscanf(ip.c_str(), \"%d.%d.%d.%d\", &a, &b, &c, &d) != 4)\n\t\treturn 0;\n\n\taddr = a << 24;\n\taddr |= b << 16;\n\taddr |= c << 8;\n\taddr |= d;\n\treturn addr;\n}\n\nbool isInt(const std::string &s)\n{\n\tfor(size_t i = 0; i < s.length(); i++){\n\t\tif(!isdigit(s[i]))\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nvoid sleep_seconds(const long seconds)\n{\n\tstd::this_thread::sleep_for(std::chrono::seconds(seconds));\n}\n\nvoid sleep_milliseconds(const long milliseconds)\n{\n\tstd::this_thread::sleep_for(std::chrono::milliseconds(milliseconds));\n}\n\nint createdir(const char *szDirName, int secattr)\n{\n\tint ret = 0;\n#ifdef WIN32\n\tret = _mkdir(szDirName);\n#else\n\tret = mkdir(szDirName, secattr);\n#endif\n\treturn ret;\n}\n\nint mkdir_deep(const char *szDirName, int secattr)\n{\n\tchar DirName[260];\n\tDirName[0] = 0;\n\tconst char* p = szDirName;\n\tchar* q = DirName;\n\tint ret = 0;\n\twhile(*p)\n\t{\n\t\tif (('\\\\' == *p) || ('/' == *p))\n\t\t{\n\t\t\tif (':' != *(p-1))\n\t\t\t{\n\t\t\t\tret = createdir(DirName, secattr);\n\t\t\t}\n\t\t}\n\t\t*q++ = *p++;\n\t\t*q = '\\0';\n\t}\n\tif (DirName[0])\n\t{\n\t\tret = createdir(DirName, secattr);\n\t}\n\treturn ret;\n}\n\nint RemoveDir(const std::string &dirnames, std::string &errorPath)\n{\n\tstd::vector<std::string> splitresults;\n\tStringSplit(dirnames, \"|\", splitresults);\n\tint returncode = 0;\n\tif (!splitresults.empty())\n\t{\n#ifdef WIN32\n\t\tfor (size_t i = 0; i < splitresults.size(); i++)\n\t\t{\n\t\t\tif (!file_exist(splitresults[i].c_str()))\n\t\t\t\tcontinue;\n\t\t\tsize_t s_szLen = strlen(splitresults[i].c_str());\n\t\t\tif (s_szLen < MAX_PATH)\n\t\t\t{\n\t\t\t\tchar deletePath[MAX_PATH + 1];\n\t\t\t\tstrcpy_s(deletePath, splitresults[i].c_str());\n\t\t\t\tdeletePath[s_szLen + 1] = '\\0'; // SHFILEOPSTRUCT needs an additional null char\n\n\t\t\t\tSHFILEOPSTRUCT shfo = { NULL, FO_DELETE, deletePath, NULL, FOF_SILENT | FOF_NOERRORUI | FOF_NOCONFIRMATION, FALSE, NULL, NULL };\n\t\t\t\tif (returncode = SHFileOperation(&shfo))\n\t\t\t\t{\n\t\t\t\t\terrorPath = splitresults[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#else\n\t\tfor (size_t i = 0; i < splitresults.size(); i++)\n\t\t{\n\t\t\tif (!file_exist(splitresults[i].c_str()))\n\t\t\t\tcontinue;\n\t\t\tExecuteCommandAndReturn(\"rm -rf \\\"\" + splitresults[i] + \"\\\"\", returncode);\n\t\t\tif (returncode)\n\t\t\t{\n\t\t\t\terrorPath = splitresults[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\treturn returncode;\n}\n\ndouble ConvertToCelsius(const double Fahrenheit)\n{\n\treturn (Fahrenheit-32.0) * 0.5556;\n}\n\ndouble ConvertToFahrenheit(const double Celsius)\n{\n\treturn (Celsius*1.8)+32.0;\n}\n\ndouble RoundDouble(const long double invalue, const short numberOfPrecisions)\n{\n\tlong long p = (long long) pow(10.0L, numberOfPrecisions);\n\tdouble ret= (long long)(invalue * p + 0.5L) / (double)p;\n\treturn ret;\n}\n\ndouble ConvertTemperature(const double tValue, const unsigned char tSign)\n{\n\tif (tSign=='C')\n\t\treturn tValue;\n\treturn RoundDouble(ConvertToFahrenheit(tValue),1);\n}\n\nstd::vector<std::string> ExecuteCommandAndReturn(const std::string &szCommand, int &returncode)\n{\n\tstd::vector<std::string> ret;\n\n\ttry\n\t{\n\t\tFILE *fp;\n\n\t\t/* Open the command for reading. */\n#ifdef WIN32\n\t\tfp = _popen(szCommand.c_str(), \"r\");\n#else\n\t\tfp = popen(szCommand.c_str(), \"r\");\n#endif\n\t\tif (fp != NULL)\n\t\t{\n\t\t\tchar path[1035];\n\t\t\t/* Read the output a line at a time - output it. */\n\t\t\twhile (fgets(path, sizeof(path) - 1, fp) != NULL)\n\t\t\t{\n\t\t\t\tret.push_back(path);\n\t\t\t}\n\t\t\t/* close */\n#ifdef WIN32\n\t\t\treturncode = _pclose(fp);\n#else\n\t\t\treturncode = pclose(fp);\n#endif\n\t\t}\n\t}\n\tcatch (...)\n\t{\n\n\t}\n\treturn ret;\n}\n\nstd::string TimeToString(const time_t *ltime, const _eTimeFormat format)\n{\n\tstruct tm timeinfo;\n\tstruct timeval tv;\n\tstd::stringstream sstr;\n\tif (ltime == NULL) // current time\n\t{\n#ifdef CLOCK_REALTIME\n\t\tstruct timespec ts;\n\t\tif (!clock_gettime(CLOCK_REALTIME, &ts))\n\t\t{\n\t\t\ttv.tv_sec = ts.tv_sec;\n\t\t\ttv.tv_usec = ts.tv_nsec / 1000;\n\t\t}\n\t\telse\n#endif\n\t\t\tgettimeofday(&tv, NULL);\n#ifdef WIN32\n\t\ttime_t tv_sec = tv.tv_sec;\n\t\tlocaltime_r(&tv_sec, &timeinfo);\n#else\n\t\tlocaltime_r(&tv.tv_sec, &timeinfo);\n#endif\n\t}\n\telse\n\t\tlocaltime_r(ltime, &timeinfo);\n\n\tif (format > TF_Time)\n\t{\n\t\t//Date\n\t\tsstr << (timeinfo.tm_year + 1900) << \"-\"\n\t\t<< std::setw(2)\t<< std::setfill('0') << (timeinfo.tm_mon + 1) << \"-\"\n\t\t<< std::setw(2) << std::setfill('0') << timeinfo.tm_mday;\n\t}\n\n\tif (format != TF_Date)\n\t{\n\t\t//Time\n\t\tif (format > TF_Time)\n\t\t\tsstr << \" \";\n\t\tsstr\n\t\t<< std::setw(2) << std::setfill('0') << timeinfo.tm_hour << \":\"\n\t\t<< std::setw(2) << std::setfill('0') << timeinfo.tm_min << \":\"\n\t\t<< std::setw(2) << std::setfill('0') << timeinfo.tm_sec;\n\t}\n\n\tif (format > TF_DateTime && ltime == NULL)\n\t\tsstr << \".\" << std::setw(3) << std::setfill('0') << ((int)tv.tv_usec / 1000);\n\n\treturn sstr.str();\n}\n\nstd::string GenerateMD5Hash(const std::string &InputString, const std::string &Salt)\n{\n\tstd::string cstring = InputString + Salt;\n\tunsigned char digest[MD5_DIGEST_LENGTH + 1];\n\tdigest[MD5_DIGEST_LENGTH] = 0;\n\tMD5((const unsigned char*)cstring.c_str(), cstring.size(), (unsigned char*)&digest);\n\tchar mdString[(MD5_DIGEST_LENGTH * 2) + 1];\n\tmdString[MD5_DIGEST_LENGTH * 2] = 0;\n\tfor (int i = 0; i < 16; i++)\n\t\tsprintf(&mdString[i * 2], \"%02x\", (unsigned int)digest[i]);\n\treturn mdString;\n}\n\nvoid hsb2rgb(const float hue, const float saturation, const float vlue, int &outR, int &outG, int &outB, const double maxValue/* = 100.0 */)\n{\n\tdouble      hh, p, q, t, ff;\n\tlong        i;\n\n\tif(saturation <= 0.0) {\n\t\toutR = int(vlue*maxValue);\n\t\toutG = int(vlue*maxValue);\n\t\toutB = int(vlue*maxValue);\n\t}\n\thh = hue;\n\tif (hh >= 360.0) hh = 0.0;\n\thh /= 60.0;\n\ti = (long)hh;\n\tff = hh - i;\n\tp = vlue * (1.0 - saturation);\n\tq = vlue * (1.0 - (saturation * ff));\n\tt = vlue * (1.0 - (saturation * (1.0 - ff)));\n\n\tswitch (i) {\n\tcase 0:\n\t\toutR = int(vlue*maxValue);\n\t\toutG = int(t*maxValue);\n\t\toutB = int(p*maxValue);\n\t\tbreak;\n\tcase 1:\n\t\toutR = int(q*maxValue);\n\t\toutG = int(vlue*maxValue);\n\t\toutB = int(p*maxValue);\n\t\tbreak;\n\tcase 2:\n\t\toutR = int(p*maxValue);\n\t\toutG = int(vlue*maxValue);\n\t\toutB = int(t*maxValue);\n\t\tbreak;\n\n\tcase 3:\n\t\toutR = int(p*maxValue);\n\t\toutG = int(q*maxValue);\n\t\toutB = int(vlue*maxValue);\n\t\tbreak;\n\tcase 4:\n\t\toutR = int(t*maxValue);\n\t\toutG = int(p*maxValue);\n\t\toutB = int(vlue*maxValue);\n\t\tbreak;\n\tcase 5:\n\tdefault:\n\t\toutR = int(vlue*maxValue);\n\t\toutG = int(p*maxValue);\n\t\toutB = int(q*maxValue);\n\t\tbreak;\n\t}\n}\n\nvoid rgb2hsb(const int r, const int g, const int b, float hsbvals[3])\n{\n\tfloat hue, saturation, brightness;\n\tif (hsbvals == NULL)\n\t\treturn;\n\tint cmax = (r > g) ? r : g;\n\tif (b > cmax) cmax = b;\n\tint cmin = (r < g) ? r : g;\n\tif (b < cmin) cmin = b;\n\n\tbrightness = ((float)cmax) / 255.0f;\n\tif (cmax != 0)\n\t\tsaturation = ((float)(cmax - cmin)) / ((float)cmax);\n\telse\n\t\tsaturation = 0;\n\tif (saturation == 0)\n\t\thue = 0;\n\telse {\n\t\tfloat redc = ((float)(cmax - r)) / ((float)(cmax - cmin));\n\t\tfloat greenc = ((float)(cmax - g)) / ((float)(cmax - cmin));\n\t\tfloat bluec = ((float)(cmax - b)) / ((float)(cmax - cmin));\n\t\tif (r == cmax)\n\t\t\thue = bluec - greenc;\n\t\telse if (g == cmax)\n\t\t\thue = 2.0f + redc - bluec;\n\t\telse\n\t\t\thue = 4.0f + greenc - redc;\n\t\thue = hue / 6.0f;\n\t\tif (hue < 0)\n\t\t\thue = hue + 1.0f;\n\t}\n\thsbvals[0] = hue;\n\thsbvals[1] = saturation;\n\thsbvals[2] = brightness;\n}\n\nbool is_number(const std::string& s)\n{\n\tstd::string::const_iterator it = s.begin();\n\twhile (it != s.end() && (isdigit(*it) || (*it == '.') || (*it == '-') || (*it == ' ') || (*it == 0x00))) ++it;\n\treturn !s.empty() && it == s.end();\n}\n\nvoid padLeft(std::string &str, const size_t num, const char paddingChar)\n{\n\tif (num > str.size())\n\t\tstr.insert(0, num - str.size(), paddingChar);\n}\n\nbool IsLightOrSwitch(const int devType, const int subType)\n{\n\tbool bIsLightSwitch = false;\n\tswitch (devType)\n\t{\n\tcase pTypeLighting1:\n\tcase pTypeLighting2:\n\tcase pTypeLighting3:\n\tcase pTypeLighting4:\n\tcase pTypeLighting5:\n\tcase pTypeLighting6:\n\tcase pTypeFan:\n\tcase pTypeColorSwitch:\n\tcase pTypeSecurity1:\n\tcase pTypeSecurity2:\n\tcase pTypeCurtain:\n\tcase pTypeBlinds:\n\tcase pTypeRFY:\n\tcase pTypeThermostat2:\n\tcase pTypeThermostat3:\n\tcase pTypeThermostat4:\n\tcase pTypeRemote:\n\tcase pTypeGeneralSwitch:\n\tcase pTypeHomeConfort:\n\tcase pTypeFS20:\n\t\tbIsLightSwitch = true;\n\t\tbreak;\n\tcase pTypeRadiator1:\n\t\tbIsLightSwitch = (subType == sTypeSmartwaresSwitchRadiator);\n\t\tbreak;\n\t}\n\treturn bIsLightSwitch;\n}\n\nint MStoBeaufort(const float ms)\n{\n\tif (ms < 0.3f)\n\t\treturn 0;\n\tif (ms < 1.5f)\n\t\treturn 1;\n\tif (ms < 3.3f)\n\t\treturn 2;\n\tif (ms < 5.5f)\n\t\treturn 3;\n\tif (ms < 8.0f)\n\t\treturn 4;\n\tif (ms < 10.8f)\n\t\treturn 5;\n\tif (ms < 13.9f)\n\t\treturn 6;\n\tif (ms < 17.2f)\n\t\treturn 7;\n\tif (ms < 20.7f)\n\t\treturn 8;\n\tif (ms < 24.5f)\n\t\treturn 9;\n\tif (ms < 28.4f)\n\t\treturn 10;\n\tif (ms < 32.6f)\n\t\treturn 11;\n\treturn 12;\n}\n\nvoid FixFolderEnding(std::string &folder)\n{\n#if defined(WIN32)\n\tif (folder.at(folder.length() - 1) != '\\\\')\n\t\tfolder += \"\\\\\";\n#else\n\tif (folder.at(folder.length() - 1) != '/')\n\t\tfolder += \"/\";\n#endif\n}\n\nbool dirent_is_directory(const std::string &dir, struct dirent *ent)\n{\n\tif (ent->d_type == DT_DIR)\n\t\treturn true;\n#ifndef WIN32\n\tif (ent->d_type == DT_LNK)\n\t\treturn true;\n\tif (ent->d_type == DT_UNKNOWN) {\n\t\tstd::string fname = dir + \"/\" + ent->d_name;\n\t\tstruct stat st;\n\t\tif (!lstat(fname.c_str(), &st))\n\t\t\treturn S_ISDIR(st.st_mode);\n\t}\n#endif\n\treturn false;\n}\n\nbool dirent_is_file(const std::string &dir, struct dirent *ent)\n{\n\tif (ent->d_type == DT_REG)\n\t\treturn true;\n#ifndef WIN32\n\tif (ent->d_type == DT_UNKNOWN) {\n\t\tstd::string fname = dir + \"/\" + ent->d_name;\n\t\tstruct stat st;\n\t\tif (!lstat(fname.c_str(), &st))\n\t\t\treturn S_ISREG(st.st_mode);\n\t}\n#endif\n\treturn false;\n}\n\n/*!\n * List entries of a directory.\n * @param entries A string vector containing the result\n * @param dir Target directory for listing\n * @param bInclDirs Boolean flag to include directories in the result\n * @param bInclFiles Boolean flag to include regular files in the result\n */\nvoid DirectoryListing(std::vector<std::string>& entries, const std::string &dir, bool bInclDirs, bool bInclFiles)\n{\n\tDIR *d = NULL;\n\tstruct dirent *ent;\n\tif ((d = opendir(dir.c_str())) != NULL)\n\t{\n\t\twhile ((ent = readdir(d)) != NULL) {\n\t\t\tstd::string name = ent->d_name;\n\t\t\tif (bInclDirs && dirent_is_directory(dir, ent) && name != \".\" && name != \"..\") {\n\t\t\t\tentries.push_back(name);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (bInclFiles && dirent_is_file(dir, ent)) {\n\t\t\t\tentries.push_back(name);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tclosedir(d);\n\t}\n\treturn;\n}\n\nstd::string GenerateUserAgent()\n{\n\tsrand((unsigned int)time(NULL));\n\tint cversion = rand() % 0xFFFF;\n\tint mversion = rand() % 3;\n\tint sversion = rand() % 3;\n\tstd::stringstream sstr;\n\tsstr << \"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/\" << (601 + sversion) << \".\" << (36+mversion) << \" (KHTML, like Gecko) Chrome/\" << (53 + mversion) << \".0.\" << cversion << \".0 Safari/\" << (601 + sversion) << \".\" << (36+sversion);\n\treturn sstr.str();\n}\n\nstd::string MakeHtml(const std::string &txt)\n{\n        std::string sRet = txt;\n\n        stdreplace(sRet, \"&\", \"&amp;\");\n        stdreplace(sRet, \"\\\"\", \"&quot;\");\n        stdreplace(sRet, \"'\", \"&apos;\");\n        stdreplace(sRet, \"<\", \"&lt;\");\n        stdreplace(sRet, \">\", \"&gt;\");\n        stdreplace(sRet, \"\\r\\n\", \"<br/>\");\n        return sRet;\n}\n\n//Prevent against XSS (Cross Site Scripting)\nstd::string SafeHtml(const std::string &txt)\n{\n    std::string sRet = txt;\n\n    stdreplace(sRet, \"\\\"\", \"&quot;\");\n    stdreplace(sRet, \"'\", \"&apos;\");\n    stdreplace(sRet, \"<\", \"&lt;\");\n    stdreplace(sRet, \">\", \"&gt;\");\n    return sRet;\n}\n\n\n#if defined WIN32\n//FILETIME of Jan 1 1970 00:00:00\nstatic const uint64_t epoch = (const uint64_t)(116444736000000000);\n\nint gettimeofday( timeval * tp, void * tzp)\n{\n\tFILETIME    file_time;\n\tSYSTEMTIME  system_time;\n\tULARGE_INTEGER ularge;\n\tGetSystemTime(&system_time);\n\tSystemTimeToFileTime(&system_time, &file_time);\n\tularge.LowPart = file_time.dwLowDateTime;\n\tularge.HighPart = file_time.dwHighDateTime;\n\ttp->tv_sec = (long)((ularge.QuadPart - epoch) / 10000000L);\n\ttp->tv_usec = (long)(system_time.wMilliseconds * 1000);\n\treturn 0;\n}\n#endif\n\nint getclock(struct timeval *tv) {\n#ifdef CLOCK_MONOTONIC\n\tstruct timespec ts;\n\t\tif (!clock_gettime(CLOCK_MONOTONIC, &ts)) {\n\t\t\ttv->tv_sec = ts.tv_sec;\n\t\t\ttv->tv_usec = ts.tv_nsec / 1000;\n\t\t\treturn 0;\n\t\t}\n#endif\n\treturn gettimeofday(tv, NULL);\n}\nint timeval_subtract (struct timeval *result, struct timeval *x, struct timeval *y) {\n\t/* Perform the carry for the later subtraction by updating y. */\n  if (x->tv_usec < y->tv_usec) {\n\t\tint nsec = (y->tv_usec - x->tv_usec) / 1000000 + 1;\n    y->tv_usec -= 1000000 * nsec;\n    y->tv_sec += nsec;\n  }\n  if (x->tv_usec - y->tv_usec > 1000000) {\n    int nsec = (x->tv_usec - y->tv_usec) / 1000000;\n    y->tv_usec += 1000000 * nsec;\n    y->tv_sec -= nsec;\n  }\n\n  /* Compute the time remaining to wait.\n     tv_usec is certainly positive. */\n  result->tv_sec = x->tv_sec - y->tv_sec;\n  result->tv_usec = x->tv_usec - y->tv_usec;\n\n  /* Return 1 if result is negative. */\n  return x->tv_sec < y->tv_sec;\n}\n\nconst char *szInsecureArgumentOptions[] = {\n\t\"import\",\n\t\"socket\",\n\t\"process\",\n\t\"os\",\n\t\"|\",\n\t\";\",\n\t\"&\",\n\t\"$\",\n\t\"<\",\n\t\">\",\n\tNULL\n};\n\nbool IsArgumentSecure(const std::string &arg)\n{\n\tstd::string larg(arg);\n\tstd::transform(larg.begin(), larg.end(), larg.begin(), ::tolower);\n\n\tint ii = 0;\n\twhile (szInsecureArgumentOptions[ii] != NULL)\n\t{\n\t\tif (larg.find(szInsecureArgumentOptions[ii]) != std::string::npos)\n\t\t\treturn false;\n\t\tii++;\n\t}\n\treturn true;\n}\n\nuint32_t SystemUptime()\n{\n#if defined(WIN32)\n\treturn static_cast<uint32_t>(GetTickCount64() / 1000u);\n#elif defined(__linux__) || defined(__linux) || defined(linux)\n\tstruct sysinfo info;\n\tif (sysinfo(&info) != 0)\n\t\treturn -1;\n\treturn info.uptime;\n#elif defined(macintosh) || defined(__APPLE__) || defined(__APPLE_CC__)\n\tstruct timeval boottime;\n\tstd::size_t len = sizeof(boottime);\n\tint mib[2] = { CTL_KERN, KERN_BOOTTIME };\n\tif (sysctl(mib, 2, &boottime, &len, NULL, 0) < 0)\n\t\treturn -1;\n\treturn time(NULL) - boottime.tv_sec;\n#elif (defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__) || defined(__DragonFly__)) && defined(CLOCK_UPTIME)\n\tstruct timespec ts;\n\tif (clock_gettime(CLOCK_UPTIME, &ts) != 0)\n\t\treturn -1;\n\treturn ts.tv_sec;\n#else\n\treturn 0;\n#endif\n}\n\n// True random number generator (source: http://www.azillionmonkeys.com/qed/random.html)\nstatic struct\n{\n\tint which;\n\ttime_t t;\n\tclock_t c;\n\tint counter;\n} entropy = { 0, (time_t) 0, (clock_t) 0, 0 };\n\nstatic unsigned char * p = (unsigned char *) (&entropy + 1);\nstatic int accSeed = 0;\n\nint GenerateRandomNumber(const int range)\n{\n\tif (p == ((unsigned char *) (&entropy + 1)))\n\t{\n\t\tswitch (entropy.which)\n\t\t{\n\t\t\tcase 0:\n\t\t\t\tentropy.t += time (NULL);\n\t\t\t\taccSeed ^= entropy.t;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tentropy.c += clock();\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tentropy.counter++;\n\t\t\t\tbreak;\n\t\t}\n\t\tentropy.which = (entropy.which + 1) % 3;\n\t\tp = (unsigned char *) &entropy.t;\n\t}\n\taccSeed = ((accSeed * (UCHAR_MAX + 2U)) | 1) + (int) *p;\n\tp++;\n\tsrand (accSeed);\n\treturn (rand() / (RAND_MAX / range));\n}\n\nint GetDirFilesRecursive(const std::string &DirPath, std::map<std::string, int> &_Files)\n{\n\tDIR* dir;\n\tif ((dir = opendir(DirPath.c_str())) != NULL)\n\t{\n\t\tstruct dirent *ent;\n\t\twhile ((ent = readdir(dir)) != NULL)\n\t\t{\n\t\t\tif (dirent_is_directory(DirPath, ent))\n\t\t\t{\n\t\t\t\tif ((strcmp(ent->d_name, \".\") != 0) && (strcmp(ent->d_name, \"..\") != 0) && (strcmp(ent->d_name, \".svn\") != 0))\n\t\t\t\t{\n\t\t\t\t\tstd::string nextdir = DirPath + ent->d_name + \"/\";\n\t\t\t\t\tif (GetDirFilesRecursive(nextdir.c_str(), _Files))\n\t\t\t\t\t{\n\t\t\t\t\t\tclosedir(dir);\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstd::string fname = DirPath + ent->d_name;\n\t\t\t\t_Files[fname] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tclosedir(dir);\n\treturn 0;\n}\n\n#ifdef WIN32\n// From https://msdn.microsoft.com/en-us/library/xcb2z8hs.aspx\nconst DWORD MS_VC_EXCEPTION = 0x406D1388;\n#pragma pack(push,8)\ntypedef struct tagTHREADNAME_INFO\n{\n\tDWORD dwType; // Must be 0x1000.\n\tLPCSTR szName; // Pointer to name (in user addr space).\n\tDWORD dwThreadID; // Thread ID (-1=caller thread).\n\tDWORD dwFlags; // Reserved for future use, must be zero.\n} THREADNAME_INFO;\n#pragma pack(pop)\nint SetThreadName(const std::thread::native_handle_type &thread, const char* threadName) {\n\tDWORD dwThreadID = ::GetThreadId( static_cast<HANDLE>( thread ) );\n\tTHREADNAME_INFO info;\n\tinfo.dwType = 0x1000;\n\tinfo.szName = threadName;\n\tinfo.dwThreadID = dwThreadID;\n\tinfo.dwFlags = 0;\n#pragma warning(push)\n#pragma warning(disable: 6320 6322)\n\t__try{\n\t\tRaiseException(MS_VC_EXCEPTION, 0, sizeof(info) / sizeof(ULONG_PTR), (ULONG_PTR*)&info);\n\t}\n\t__except (EXCEPTION_EXECUTE_HANDLER){\n\t}\n#pragma warning(pop)\n\treturn 0;\n}\n#else\n// Based on https://stackoverflow.com/questions/2369738/how-to-set-the-name-of-a-thread-in-linux-pthreads\nint SetThreadName(const std::thread::native_handle_type &thread, const char *name)\n{\n#if defined(__linux__) || defined(__linux) || defined(linux)\n\tchar name_trunc[16];\n\tstrncpy(name_trunc, name, sizeof(name_trunc));\n\tname_trunc[sizeof(name_trunc)-1] = '\\0';\n\treturn pthread_setname_np(thread, name_trunc);\n#elif defined(macintosh) || defined(__APPLE__) || defined(__APPLE_CC__)\n\t// Not possible to set name of other thread: https://stackoverflow.com/questions/2369738/how-to-set-the-name-of-a-thread-in-linux-pthreads\n\treturn 0;\n#elif defined(__NetBSD__)\n\tchar name_trunc[PTHREAD_MAX_NAMELEN_NP];\n\tstrncpy(name_trunc, name, sizeof(name_trunc));\n\tname_trunc[sizeof(name_trunc)-1] = '\\0';\n\treturn pthread_setname_np(thread, \"%s\", (void *)name_trunc);\n#elif defined(__OpenBSD__) || defined(__DragonFly__)\n\tchar name_trunc[PTHREAD_MAX_NAMELEN_NP];\n\tstrncpy(name_trunc, name, sizeof(name_trunc));\n\tname_trunc[sizeof(name_trunc)-1] = '\\0';\n\tpthread_setname_np(thread, name_trunc);\n\treturn 0;\n#elif defined(__FreeBSD__)\n\tchar name_trunc[PTHREAD_MAX_NAMELEN_NP];\n\tstrncpy(name_trunc, name, sizeof(name_trunc));\n\tname_trunc[sizeof(name_trunc)-1] = '\\0';\n\tpthread_set_name_np(thread, name_trunc);\n\treturn 0;\n#endif\n}\n#endif\n\n#if !defined(WIN32)\nbool IsDebuggerPresent(void)\n{\n#if defined(__linux__)\n\t// Linux implementation: Search for 'TracerPid:' in /proc/self/status\n\tchar buf[4096];\n\n\tconst int status_fd = ::open(\"/proc/self/status\", O_RDONLY);\n\tif (status_fd == -1)\n\t\treturn false;\n\n\tconst ssize_t num_read = ::read(status_fd, buf, sizeof(buf) - 1);\n\tif (num_read <= 0)\n\t\treturn false;\n\n\tbuf[num_read] = '\\0';\n\tconstexpr char tracerPidString[] = \"TracerPid:\";\n\tconst auto tracer_pid_ptr = ::strstr(buf, tracerPidString);\n\tif (!tracer_pid_ptr)\n\t\treturn false;\n\n\tfor (const char* characterPtr = tracer_pid_ptr + sizeof(tracerPidString) - 1; characterPtr <= buf + num_read; ++characterPtr)\n\t{\n\t\tif (::isspace(*characterPtr))\n\t\t\tcontinue;\n\t\telse\n\t\t\treturn ::isdigit(*characterPtr) != 0 && *characterPtr != '0';\n\t}\n\n\treturn false;\n#else\n\t// MacOS X / BSD: TODO\n#\tifdef _DEBUG\n\treturn true;\n#\telse\n\treturn false;\n#\tendif\n#endif\n}\n#endif\n\n#if defined(__linux__)\nbool IsWSL(void)\n{\n\t// Detect WSL according to https://github.com/Microsoft/WSL/issues/423#issuecomment-221627364\n\tbool is_wsl = false;\n\n\tchar buf[1024];\n\n\tint status_fd = open(\"/proc/sys/kernel/osrelease\", O_RDONLY);\n\tif (status_fd == -1)\n\t\treturn is_wsl;\n\n\tssize_t num_read = read(status_fd, buf, sizeof(buf) - 1);\n\n\tif (num_read > 0)\n\t{\n\t\tbuf[num_read] = 0;\n\t\tis_wsl |= (strstr(buf, \"Microsoft\") != NULL);\n\t\tis_wsl |= (strstr(buf, \"WSL\") != NULL);\n\t}\n\n\tstatus_fd = open(\"/proc/version\", O_RDONLY);\n\tif (status_fd == -1)\n\t\treturn is_wsl;\n\n\tnum_read = read(status_fd, buf, sizeof(buf) - 1);\n\n\tif (num_read > 0)\n\t{\n\t\tbuf[num_read] = 0;\n\t\tis_wsl |= (strstr(buf, \"Microsoft\") != NULL);\n\t\tis_wsl |= (strstr(buf, \"WSL\") != NULL);\n\t}\n\n\treturn is_wsl;\n}\n#endif\n\nconst std::string hexCHARS = \"0123456789abcdef\";\nstd::string GenerateUUID() // DCE/RFC 4122\n{\n\tstd::srand((unsigned int)std::time(nullptr));\n\tstd::string uuid = std::string(36, ' ');\n\n\tuuid[8] = '-';\n\tuuid[13] = '-';\n\tuuid[14] = '4'; //M\n\tuuid[18] = '-';\n\t//uuid[19] = ' '; //N Variant 1 UUIDs (10xx N=8..b, 2 bits)\n\tuuid[23] = '-';\n\n\tfor (size_t ii = 0; ii < uuid.size(); ii++)\n\t{\n\t\tif (uuid[ii] == ' ')\n\t\t{\n\t\t\tuuid[ii] = hexCHARS[(ii == 19) ? (8 + (std::rand() & 0x03)) : std::rand() & 0x0F];\n\t\t}\n\t}\n\treturn uuid;\n}\n"], "fixing_code": ["#include \"stdafx.h\"\n#include \"Helper.h\"\n#include \"Logger.h\"\n#ifdef WIN32\n#include \"dirent_windows.h\"\n#include <direct.h>\n#else\n#include <dirent.h>\n#include <unistd.h>\n#endif\n#if !defined(WIN32)\n#include <sys/ptrace.h>\n#endif\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <fstream>\n#include <math.h>\n#include <algorithm>\n#include \"../main/localtime_r.h\"\n#include <sstream>\n#include <openssl/md5.h>\n#include <chrono>\n#include <limits.h>\n#include <cstring>\n\n#if defined WIN32\n#include \"../msbuild/WindowsHelper.h\"\n#endif\n\n#include \"RFXtrx.h\"\n#include \"../hardware/hardwaretypes.h\"\n\n// Includes for SystemUptime()\n#if defined(__linux__) || defined(__linux) || defined(linux)\n#include <sys/sysinfo.h>\n#elif defined(macintosh) || defined(__APPLE__) || defined(__APPLE_CC__)\n#include <time.h>\n#include <errno.h>\n#include <sys/sysctl.h>\n#elif defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__) || defined(__DragonFly__)\n#include <time.h>\n#endif\n\n#if defined(__FreeBSD__) \n// Check if OpenBSD or DragonFly need that at well?\n#include <pthread_np.h>\n#ifndef PTHREAD_MAX_MAMELEN_NP\n#define PTHREAD_MAX_NAMELEN_NP 32 \t// Arbitrary\n#endif\n#endif\n\nvoid StringSplit(std::string str, const std::string &delim, std::vector<std::string> &results)\n{\n\tresults.clear();\n\tsize_t cutAt;\n\twhile( (cutAt = str.find(delim)) != std::string::npos )\n\t{\n\t\tresults.push_back(str.substr(0,cutAt));\n\t\tstr = str.substr(cutAt+ delim.size());\n\t}\n\tif (!str.empty())\n\t{\n\t\tresults.push_back(str);\n\t}\n}\n\nuint64_t hexstrtoui64(const std::string &str)\n{\n\tuint64_t ul;\n\tstd::stringstream ss;\n\tss << std::hex << str;\n\tss >> ul;\n\treturn ul;\n}\n\nvoid stdreplace(\n\tstd::string &inoutstring,\n\tconst std::string& replaceWhat,\n\tconst std::string& replaceWithWhat)\n{\n\tint pos = 0;\n\twhile (std::string::npos != (pos = inoutstring.find(replaceWhat, pos)))\n\t{\n\t\tinoutstring.replace(pos, replaceWhat.size(), replaceWithWhat);\n\t\tpos += replaceWithWhat.size();\n\t}\n}\n\nvoid stdupper(std::string &inoutstring)\n{\n\tfor (size_t i = 0; i < inoutstring.size(); ++i)\n\t\tinoutstring[i] = toupper(inoutstring[i]);\n}\n\nvoid stdlower(std::string &inoutstring)\n{\n\tstd::transform(inoutstring.begin(), inoutstring.end(), inoutstring.begin(), ::tolower);\n}\n\nstd::vector<std::string> GetSerialPorts(bool &bUseDirectPath)\n{\n\tbUseDirectPath=false;\n\n\tstd::vector<std::string> ret;\n#if defined WIN32\n\t//windows\n\n\tstd::vector<int> ports;\n\tstd::vector<std::string> friendlyNames;\n\tchar szPortName[40];\n\n\tEnumSerialFromWMI(ports, friendlyNames);\n\n\tbool bFoundPort = false;\n\tif (!ports.empty())\n\t{\n\t\tbFoundPort = true;\n\t\tfor (const auto & itt : ports)\n\t\t{\n\t\t\tsprintf(szPortName, \"COM%d\", itt);\n\t\t\tret.push_back(szPortName);\n\t\t}\n\t}\n\n\tif (bFoundPort)\n\t\treturn ret;\n\n\t//Scan old fashion way (SLOW!)\n\tCOMMCONFIG cc;\n\tDWORD dwSize = sizeof(COMMCONFIG);\n\tfor (int ii = 0; ii < 256; ii++)\n\t{\n\t\tsprintf(szPortName, \"COM%d\", ii);\n\t\tif (GetDefaultCommConfig(szPortName, &cc, &dwSize))\n\t\t{\n\t\t\tbFoundPort = true;\n\t\t\tsprintf(szPortName, \"COM%d\", ii);\n\n\t\t\t//Check if we did not already have it\n\t\t\tbool bFound = false;\n\t\t\tfor (const auto & itt : ret)\n\t\t\t{\n\t\t\t\tif (itt == szPortName)\n\t\t\t\t{\n\t\t\t\t\tbFound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!bFound)\n\t\t\t\tret.push_back(szPortName); // add port\n\t\t}\n\t}\n\t// Method 2: CreateFile, slow\n\t// ---------\n\tif (!bFoundPort) {\n\t\tfor (int ii = 0; ii < 256; ii++)\n\t\t{\n\t\t\tsprintf(szPortName, \"\\\\\\\\.\\\\COM%d\", ii);\n\t\t\tbool bSuccess = false;\n\t\t\tHANDLE hPort = ::CreateFile(szPortName, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING, 0, 0);\n\t\t\tif (hPort == INVALID_HANDLE_VALUE) {\n\t\t\t\tDWORD dwError = GetLastError();\n\t\t\t\t//Check to see if the error was because some other app had the port open\n\t\t\t\tif (dwError == ERROR_ACCESS_DENIED)\n\t\t\t\t\tbSuccess = TRUE;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t//The port was opened successfully\n\t\t\t\tbSuccess = TRUE;\n\t\t\t\t//Don't forget to close the port, since we are going to do nothing with it anyway\n\t\t\t\tCloseHandle(hPort);\n\t\t\t}\n\t\t\tif (bSuccess) {\n\t\t\t\tbFoundPort = true;\n\t\t\t\tsprintf(szPortName, \"COM%d\", ii);\n\t\t\t\tret.push_back(szPortName); // add port\n\t\t\t}\n\t\t\t// --------------\n\t\t}\n\t}\n\t// Method 3: EnumSerialPortsWindows, often fails\n\t// ---------\n\tif (!bFoundPort) {\n\t\tstd::vector<SerialPortInfo> serialports;\n\t\tEnumSerialPortsWindows(serialports);\n\t\tif (!serialports.empty())\n\t\t{\n\t\t\tfor (const auto & itt : serialports)\n\t\t\t{\n\t\t\t\tret.push_back(itt.szPortName); // add port\n\t\t\t}\n\t\t}\n\t}\n\n#else\n\t//scan /dev for /dev/ttyUSB* or /dev/ttyS* or /dev/tty.usbserial* or /dev/ttyAMA* or /dev/ttySAC*\n\t//also scan /dev/serial/by-id/* on Linux\n\n\tbool bHaveTtyAMAfree=false;\n\tstd::string sLine = \"\";\n\tstd::ifstream infile;\n\n\tinfile.open(\"/boot/cmdline.txt\");\n\tif (infile.is_open())\n\t{\n\t\tif (!infile.eof())\n\t\t{\n\t\t\tgetline(infile, sLine);\n\t\t\tbHaveTtyAMAfree=(sLine.find(\"ttyAMA0\")==std::string::npos);\n\t\t}\n\t}\n\n\tDIR *d=NULL;\n\td=opendir(\"/dev\");\n\tif (d != NULL)\n\t{\n\t\tstruct dirent *de=NULL;\n\t\t// Loop while not NULL\n\t\twhile ((de = readdir(d)))\n\t\t{\n\t\t\t// Only consider character devices and symbolic links\n                        if ((de->d_type == DT_CHR) || (de->d_type == DT_LNK))\n                        {\n\t\t\tstd::string fname = de->d_name;\n\t\t\tif (fname.find(\"ttyUSB\")!=std::string::npos)\n\t\t\t{\n\t\t\t\tret.push_back(\"/dev/\" + fname);\n\t\t\t}\n\t\t\telse if (fname.find(\"tty.usbserial\")!=std::string::npos)\n\t\t\t{\n\t\t\t\tbUseDirectPath=true;\n\t\t\t\tret.push_back(\"/dev/\" + fname);\n\t\t\t}\n\t\t\telse if (fname.find(\"ttyACM\")!=std::string::npos)\n\t\t\t{\n\t\t\t\tbUseDirectPath=true;\n\t\t\t\tret.push_back(\"/dev/\" + fname);\n\t\t\t}\n\t\t\telse if (fname.find(\"ttySAC\") != std::string::npos)\n\t\t\t{\n\t\t\t\tbUseDirectPath = true;\n\t\t\t\tret.push_back(\"/dev/\" + fname);\n\t\t\t}\n#if defined (__FreeBSD__) || defined (__OpenBSD__) || defined (__NetBSD__)\n\t\t\telse if (fname.find(\"ttyU\")!=std::string::npos)\n\t\t\t{\n\t\t\t\tbUseDirectPath=true;\n\t\t\t\tret.push_back(\"/dev/\" + fname);\n\t\t\t}\n\t\t\telse if (fname.find(\"cuaU\")!=std::string::npos)\n\t\t\t{\n\t\t\t\tbUseDirectPath=true;\n\t\t\t\tret.push_back(\"/dev/\" + fname);\n\t\t\t}\n#endif\n#ifdef __APPLE__\n\t\t\telse if (fname.find(\"cu.\")!=std::string::npos)\n\t\t\t{\n\t\t\t\tbUseDirectPath=true;\n\t\t\t\tret.push_back(\"/dev/\" + fname);\n\t\t\t}\n#endif\n\t\t\tif (bHaveTtyAMAfree)\n\t\t\t{\n\t\t\t\tif (fname.find(\"ttyAMA0\")!=std::string::npos)\n\t\t\t\t{\n\t\t\t\t\tret.push_back(\"/dev/\" + fname);\n\t\t\t\t\tbUseDirectPath=true;\n\t\t\t\t}\n\t\t\t\t// By default, this is the \"small UART\" on Rasberry 3 boards\n                                        if (fname.find(\"ttyS0\")!=std::string::npos)\n                                        {\n                                                ret.push_back(\"/dev/\" + fname);\n                                                bUseDirectPath=true;\n                                        }\n                                        // serial0 and serial1 are new with Rasbian Jessie\n                                        // Avoids confusion between Raspberry 2 and 3 boards\n                                        // More info at http://spellfoundry.com/2016/05/29/configuring-gpio-serial-port-raspbian-jessie-including-pi-3/\n                                        if (fname.find(\"serial\")!=std::string::npos)\n                                        {\n                                                ret.push_back(\"/dev/\" + fname);\n                                                bUseDirectPath=true;\n                                        }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tclosedir(d);\n\t}\n\t//also scan in /dev/usb\n\td=opendir(\"/dev/usb\");\n\tif (d != NULL)\n\t{\n\t\tstruct dirent *de=NULL;\n\t\t// Loop while not NULL\n\t\twhile ((de = readdir(d)))\n\t\t{\n\t\t\tstd::string fname = de->d_name;\n\t\t\tif (fname.find(\"ttyUSB\")!=std::string::npos)\n\t\t\t{\n\t\t\t\tbUseDirectPath=true;\n\t\t\t\tret.push_back(\"/dev/usb/\" + fname);\n\t\t\t}\n\t\t}\n\t\tclosedir(d);\n\t}\n\n#if defined(__linux__) || defined(__linux) || defined(linux)\n\td=opendir(\"/dev/serial/by-id\");\n\tif (d != NULL)\n\t{\n\t\tstruct dirent *de=NULL;\n\t\t// Loop while not NULL\n\t\twhile ((de = readdir(d)))\n\t\t{\n\t\t\t// Only consider symbolic links\n                        if (de->d_type == DT_LNK)\n                        {\n\t\t\t\tstd::string fname = de->d_name;\n\t\t\t\tret.push_back(\"/dev/serial/by-id/\" + fname);\n\t\t\t}\n\t\t}\n\t\tclosedir(d);\n\t}\n\n#endif\n#endif\n\treturn ret;\n}\n\nbool file_exist (const char *filename)\n{\n\tstruct stat sbuffer;\n\treturn (stat(filename, &sbuffer) == 0);\n}\n\ndouble CalculateAltitudeFromPressure(double pressure)\n{\n\tdouble seaLevelPressure=101325.0;\n\tdouble altitude = 44330.0 * (1.0 - pow( (pressure / seaLevelPressure), 0.1903));\n\treturn altitude;\n}\n\n/**************************************************************************/\n/*!\nCalculates the altitude (in meters) from the specified atmospheric\npressure (in hPa), sea-level pressure (in hPa), and temperature (in \u00b0C)\n@param seaLevel Sea-level pressure in hPa\n@param atmospheric Atmospheric pressure in hPa\n@param temp Temperature in degrees Celsius\n*/\n/**************************************************************************/\nfloat pressureToAltitude(float seaLevel, float atmospheric, float temp)\n{\n\t/* Hyposometric formula: */\n\t/* */\n\t/* ((P0/P)^(1/5.257) - 1) * (T + 273.15) */\n\t/* h = ------------------------------------- */\n\t/* 0.0065 */\n\t/* */\n\t/* where: h = height (in meters) */\n\t/* P0 = sea-level pressure (in hPa) */\n\t/* P = atmospheric pressure (in hPa) */\n\t/* T = temperature (in \u00b0C) */\n\treturn (((float)pow((seaLevel / atmospheric), 0.190223F) - 1.0F)\n\t\t* (temp + 273.15F)) / 0.0065F;\n}\n\n/**************************************************************************/\n/*!\nCalculates the sea-level pressure (in hPa) based on the current\naltitude (in meters), atmospheric pressure (in hPa), and temperature\n(in \u00b0C)\n@param altitude altitude in meters\n@param atmospheric Atmospheric pressure in hPa\n@param temp Temperature in degrees Celsius\n*/\n/**************************************************************************/\nfloat pressureSeaLevelFromAltitude(float altitude, float atmospheric, float temp)\n{\n\t/* Sea-level pressure: */\n\t/* */\n\t/* 0.0065*h */\n\t/* P0 = P * (1 - ----------------- ) ^ -5.257 */\n\t/* T+0.0065*h+273.15 */\n\t/* */\n\t/* where: P0 = sea-level pressure (in hPa) */\n\t/* P = atmospheric pressure (in hPa) */\n\t/* h = altitude (in meters) */\n\t/* T = Temperature (in \u00b0C) */\n\treturn atmospheric * (float)pow((1.0F - (0.0065F * altitude) /\n\t\t(temp + 0.0065F * altitude + 273.15F)), -5.257F);\n}\n\n\nstd::string &stdstring_ltrim(std::string &s)\n{\n\twhile (!s.empty())\n\t{\n\t\tif (s[0] != ' ')\n\t\t\treturn s;\n\t\ts = s.substr(1);\n\t}\n\t//\ts.erase(s.begin(), std::find_if(s.begin(), s.end(), std::not1(std::ptr_fun<int, int>(std::isspace))));\n\treturn s;\n}\n\nstd::string &stdstring_rtrim(std::string &s)\n{\n\twhile (!s.empty())\n\t{\n\t\tif (s[s.size() - 1] != ' ')\n\t\t\treturn s;\n\t\ts = s.substr(0, s.size() - 1);\n\t}\n\t//s.erase(std::find_if(s.rbegin(), s.rend(), std::not1(std::ptr_fun<int, int>(std::isspace))).base(), s.end());\n\treturn s;\n}\n\n// trim from both ends\nstd::string &stdstring_trim(std::string &s)\n{\n\treturn stdstring_ltrim(stdstring_rtrim(s));\n}\n\ndouble CalculateDewPoint(double temp, int humidity)\n{\n\tif (humidity==0)\n\t\treturn temp;\n\tdouble dew_numer = 243.04*(log(double(humidity)/100.0)+((17.625*temp)/(temp+243.04)));\n\tdouble dew_denom = 17.625-log(double(humidity)/100.0)-((17.625*temp)/(temp+243.04));\n\tif (dew_numer==0)\n\t\tdew_numer=1;\n\treturn dew_numer/dew_denom;\n}\n\nuint32_t IPToUInt(const std::string &ip)\n{\n\tint a, b, c, d;\n\tuint32_t addr = 0;\n\n\tif (sscanf(ip.c_str(), \"%d.%d.%d.%d\", &a, &b, &c, &d) != 4)\n\t\treturn 0;\n\n\taddr = a << 24;\n\taddr |= b << 16;\n\taddr |= c << 8;\n\taddr |= d;\n\treturn addr;\n}\n\nbool isInt(const std::string &s)\n{\n\tfor(size_t i = 0; i < s.length(); i++){\n\t\tif(!isdigit(s[i]))\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nvoid sleep_seconds(const long seconds)\n{\n\tstd::this_thread::sleep_for(std::chrono::seconds(seconds));\n}\n\nvoid sleep_milliseconds(const long milliseconds)\n{\n\tstd::this_thread::sleep_for(std::chrono::milliseconds(milliseconds));\n}\n\nint createdir(const char *szDirName, int secattr)\n{\n\tint ret = 0;\n#ifdef WIN32\n\tret = _mkdir(szDirName);\n#else\n\tret = mkdir(szDirName, secattr);\n#endif\n\treturn ret;\n}\n\nint mkdir_deep(const char *szDirName, int secattr)\n{\n\tchar DirName[260];\n\tDirName[0] = 0;\n\tconst char* p = szDirName;\n\tchar* q = DirName;\n\tint ret = 0;\n\twhile(*p)\n\t{\n\t\tif (('\\\\' == *p) || ('/' == *p))\n\t\t{\n\t\t\tif (':' != *(p-1))\n\t\t\t{\n\t\t\t\tret = createdir(DirName, secattr);\n\t\t\t}\n\t\t}\n\t\t*q++ = *p++;\n\t\t*q = '\\0';\n\t}\n\tif (DirName[0])\n\t{\n\t\tret = createdir(DirName, secattr);\n\t}\n\treturn ret;\n}\n\nint RemoveDir(const std::string &dirnames, std::string &errorPath)\n{\n\tstd::vector<std::string> splitresults;\n\tStringSplit(dirnames, \"|\", splitresults);\n\tint returncode = 0;\n\tif (!splitresults.empty())\n\t{\n#ifdef WIN32\n\t\tfor (size_t i = 0; i < splitresults.size(); i++)\n\t\t{\n\t\t\tif (!file_exist(splitresults[i].c_str()))\n\t\t\t\tcontinue;\n\t\t\tsize_t s_szLen = strlen(splitresults[i].c_str());\n\t\t\tif (s_szLen < MAX_PATH)\n\t\t\t{\n\t\t\t\tchar deletePath[MAX_PATH + 1];\n\t\t\t\tstrcpy_s(deletePath, splitresults[i].c_str());\n\t\t\t\tdeletePath[s_szLen + 1] = '\\0'; // SHFILEOPSTRUCT needs an additional null char\n\n\t\t\t\tSHFILEOPSTRUCT shfo = { NULL, FO_DELETE, deletePath, NULL, FOF_SILENT | FOF_NOERRORUI | FOF_NOCONFIRMATION, FALSE, NULL, NULL };\n\t\t\t\tif (returncode = SHFileOperation(&shfo))\n\t\t\t\t{\n\t\t\t\t\terrorPath = splitresults[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#else\n\t\tfor (size_t i = 0; i < splitresults.size(); i++)\n\t\t{\n\t\t\tif (!file_exist(splitresults[i].c_str()))\n\t\t\t\tcontinue;\n\t\t\tExecuteCommandAndReturn(\"rm -rf \\\"\" + splitresults[i] + \"\\\"\", returncode);\n\t\t\tif (returncode)\n\t\t\t{\n\t\t\t\terrorPath = splitresults[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\treturn returncode;\n}\n\ndouble ConvertToCelsius(const double Fahrenheit)\n{\n\treturn (Fahrenheit-32.0) * 0.5556;\n}\n\ndouble ConvertToFahrenheit(const double Celsius)\n{\n\treturn (Celsius*1.8)+32.0;\n}\n\ndouble RoundDouble(const long double invalue, const short numberOfPrecisions)\n{\n\tlong long p = (long long) pow(10.0L, numberOfPrecisions);\n\tdouble ret= (long long)(invalue * p + 0.5L) / (double)p;\n\treturn ret;\n}\n\ndouble ConvertTemperature(const double tValue, const unsigned char tSign)\n{\n\tif (tSign=='C')\n\t\treturn tValue;\n\treturn RoundDouble(ConvertToFahrenheit(tValue),1);\n}\n\nstd::vector<std::string> ExecuteCommandAndReturn(const std::string &szCommand, int &returncode)\n{\n\tstd::vector<std::string> ret;\n\n\ttry\n\t{\n\t\tFILE *fp;\n\n\t\t/* Open the command for reading. */\n#ifdef WIN32\n\t\tfp = _popen(szCommand.c_str(), \"r\");\n#else\n\t\tfp = popen(szCommand.c_str(), \"r\");\n#endif\n\t\tif (fp != NULL)\n\t\t{\n\t\t\tchar path[1035];\n\t\t\t/* Read the output a line at a time - output it. */\n\t\t\twhile (fgets(path, sizeof(path) - 1, fp) != NULL)\n\t\t\t{\n\t\t\t\tret.push_back(path);\n\t\t\t}\n\t\t\t/* close */\n#ifdef WIN32\n\t\t\treturncode = _pclose(fp);\n#else\n\t\t\treturncode = pclose(fp);\n#endif\n\t\t}\n\t}\n\tcatch (...)\n\t{\n\n\t}\n\treturn ret;\n}\n\nstd::string TimeToString(const time_t *ltime, const _eTimeFormat format)\n{\n\tstruct tm timeinfo;\n\tstruct timeval tv;\n\tstd::stringstream sstr;\n\tif (ltime == NULL) // current time\n\t{\n#ifdef CLOCK_REALTIME\n\t\tstruct timespec ts;\n\t\tif (!clock_gettime(CLOCK_REALTIME, &ts))\n\t\t{\n\t\t\ttv.tv_sec = ts.tv_sec;\n\t\t\ttv.tv_usec = ts.tv_nsec / 1000;\n\t\t}\n\t\telse\n#endif\n\t\t\tgettimeofday(&tv, NULL);\n#ifdef WIN32\n\t\ttime_t tv_sec = tv.tv_sec;\n\t\tlocaltime_r(&tv_sec, &timeinfo);\n#else\n\t\tlocaltime_r(&tv.tv_sec, &timeinfo);\n#endif\n\t}\n\telse\n\t\tlocaltime_r(ltime, &timeinfo);\n\n\tif (format > TF_Time)\n\t{\n\t\t//Date\n\t\tsstr << (timeinfo.tm_year + 1900) << \"-\"\n\t\t<< std::setw(2)\t<< std::setfill('0') << (timeinfo.tm_mon + 1) << \"-\"\n\t\t<< std::setw(2) << std::setfill('0') << timeinfo.tm_mday;\n\t}\n\n\tif (format != TF_Date)\n\t{\n\t\t//Time\n\t\tif (format > TF_Time)\n\t\t\tsstr << \" \";\n\t\tsstr\n\t\t<< std::setw(2) << std::setfill('0') << timeinfo.tm_hour << \":\"\n\t\t<< std::setw(2) << std::setfill('0') << timeinfo.tm_min << \":\"\n\t\t<< std::setw(2) << std::setfill('0') << timeinfo.tm_sec;\n\t}\n\n\tif (format > TF_DateTime && ltime == NULL)\n\t\tsstr << \".\" << std::setw(3) << std::setfill('0') << ((int)tv.tv_usec / 1000);\n\n\treturn sstr.str();\n}\n\nstd::string GenerateMD5Hash(const std::string &InputString, const std::string &Salt)\n{\n\tstd::string cstring = InputString + Salt;\n\tunsigned char digest[MD5_DIGEST_LENGTH + 1];\n\tdigest[MD5_DIGEST_LENGTH] = 0;\n\tMD5((const unsigned char*)cstring.c_str(), cstring.size(), (unsigned char*)&digest);\n\tchar mdString[(MD5_DIGEST_LENGTH * 2) + 1];\n\tmdString[MD5_DIGEST_LENGTH * 2] = 0;\n\tfor (int i = 0; i < 16; i++)\n\t\tsprintf(&mdString[i * 2], \"%02x\", (unsigned int)digest[i]);\n\treturn mdString;\n}\n\nvoid hsb2rgb(const float hue, const float saturation, const float vlue, int &outR, int &outG, int &outB, const double maxValue/* = 100.0 */)\n{\n\tdouble      hh, p, q, t, ff;\n\tlong        i;\n\n\tif(saturation <= 0.0) {\n\t\toutR = int(vlue*maxValue);\n\t\toutG = int(vlue*maxValue);\n\t\toutB = int(vlue*maxValue);\n\t}\n\thh = hue;\n\tif (hh >= 360.0) hh = 0.0;\n\thh /= 60.0;\n\ti = (long)hh;\n\tff = hh - i;\n\tp = vlue * (1.0 - saturation);\n\tq = vlue * (1.0 - (saturation * ff));\n\tt = vlue * (1.0 - (saturation * (1.0 - ff)));\n\n\tswitch (i) {\n\tcase 0:\n\t\toutR = int(vlue*maxValue);\n\t\toutG = int(t*maxValue);\n\t\toutB = int(p*maxValue);\n\t\tbreak;\n\tcase 1:\n\t\toutR = int(q*maxValue);\n\t\toutG = int(vlue*maxValue);\n\t\toutB = int(p*maxValue);\n\t\tbreak;\n\tcase 2:\n\t\toutR = int(p*maxValue);\n\t\toutG = int(vlue*maxValue);\n\t\toutB = int(t*maxValue);\n\t\tbreak;\n\n\tcase 3:\n\t\toutR = int(p*maxValue);\n\t\toutG = int(q*maxValue);\n\t\toutB = int(vlue*maxValue);\n\t\tbreak;\n\tcase 4:\n\t\toutR = int(t*maxValue);\n\t\toutG = int(p*maxValue);\n\t\toutB = int(vlue*maxValue);\n\t\tbreak;\n\tcase 5:\n\tdefault:\n\t\toutR = int(vlue*maxValue);\n\t\toutG = int(p*maxValue);\n\t\toutB = int(q*maxValue);\n\t\tbreak;\n\t}\n}\n\nvoid rgb2hsb(const int r, const int g, const int b, float hsbvals[3])\n{\n\tfloat hue, saturation, brightness;\n\tif (hsbvals == NULL)\n\t\treturn;\n\tint cmax = (r > g) ? r : g;\n\tif (b > cmax) cmax = b;\n\tint cmin = (r < g) ? r : g;\n\tif (b < cmin) cmin = b;\n\n\tbrightness = ((float)cmax) / 255.0f;\n\tif (cmax != 0)\n\t\tsaturation = ((float)(cmax - cmin)) / ((float)cmax);\n\telse\n\t\tsaturation = 0;\n\tif (saturation == 0)\n\t\thue = 0;\n\telse {\n\t\tfloat redc = ((float)(cmax - r)) / ((float)(cmax - cmin));\n\t\tfloat greenc = ((float)(cmax - g)) / ((float)(cmax - cmin));\n\t\tfloat bluec = ((float)(cmax - b)) / ((float)(cmax - cmin));\n\t\tif (r == cmax)\n\t\t\thue = bluec - greenc;\n\t\telse if (g == cmax)\n\t\t\thue = 2.0f + redc - bluec;\n\t\telse\n\t\t\thue = 4.0f + greenc - redc;\n\t\thue = hue / 6.0f;\n\t\tif (hue < 0)\n\t\t\thue = hue + 1.0f;\n\t}\n\thsbvals[0] = hue;\n\thsbvals[1] = saturation;\n\thsbvals[2] = brightness;\n}\n\nbool is_number(const std::string& s)\n{\n\tstd::string::const_iterator it = s.begin();\n\twhile (it != s.end() && (isdigit(*it) || (*it == '.') || (*it == '-') || (*it == ' ') || (*it == 0x00))) ++it;\n\treturn !s.empty() && it == s.end();\n}\n\nvoid padLeft(std::string &str, const size_t num, const char paddingChar)\n{\n\tif (num > str.size())\n\t\tstr.insert(0, num - str.size(), paddingChar);\n}\n\nbool IsLightOrSwitch(const int devType, const int subType)\n{\n\tbool bIsLightSwitch = false;\n\tswitch (devType)\n\t{\n\tcase pTypeLighting1:\n\tcase pTypeLighting2:\n\tcase pTypeLighting3:\n\tcase pTypeLighting4:\n\tcase pTypeLighting5:\n\tcase pTypeLighting6:\n\tcase pTypeFan:\n\tcase pTypeColorSwitch:\n\tcase pTypeSecurity1:\n\tcase pTypeSecurity2:\n\tcase pTypeCurtain:\n\tcase pTypeBlinds:\n\tcase pTypeRFY:\n\tcase pTypeThermostat2:\n\tcase pTypeThermostat3:\n\tcase pTypeThermostat4:\n\tcase pTypeRemote:\n\tcase pTypeGeneralSwitch:\n\tcase pTypeHomeConfort:\n\tcase pTypeFS20:\n\t\tbIsLightSwitch = true;\n\t\tbreak;\n\tcase pTypeRadiator1:\n\t\tbIsLightSwitch = (subType == sTypeSmartwaresSwitchRadiator);\n\t\tbreak;\n\t}\n\treturn bIsLightSwitch;\n}\n\nint MStoBeaufort(const float ms)\n{\n\tif (ms < 0.3f)\n\t\treturn 0;\n\tif (ms < 1.5f)\n\t\treturn 1;\n\tif (ms < 3.3f)\n\t\treturn 2;\n\tif (ms < 5.5f)\n\t\treturn 3;\n\tif (ms < 8.0f)\n\t\treturn 4;\n\tif (ms < 10.8f)\n\t\treturn 5;\n\tif (ms < 13.9f)\n\t\treturn 6;\n\tif (ms < 17.2f)\n\t\treturn 7;\n\tif (ms < 20.7f)\n\t\treturn 8;\n\tif (ms < 24.5f)\n\t\treturn 9;\n\tif (ms < 28.4f)\n\t\treturn 10;\n\tif (ms < 32.6f)\n\t\treturn 11;\n\treturn 12;\n}\n\nvoid FixFolderEnding(std::string &folder)\n{\n#if defined(WIN32)\n\tif (folder.at(folder.length() - 1) != '\\\\')\n\t\tfolder += \"\\\\\";\n#else\n\tif (folder.at(folder.length() - 1) != '/')\n\t\tfolder += \"/\";\n#endif\n}\n\nbool dirent_is_directory(const std::string &dir, struct dirent *ent)\n{\n\tif (ent->d_type == DT_DIR)\n\t\treturn true;\n#ifndef WIN32\n\tif (ent->d_type == DT_LNK)\n\t\treturn true;\n\tif (ent->d_type == DT_UNKNOWN) {\n\t\tstd::string fname = dir + \"/\" + ent->d_name;\n\t\tstruct stat st;\n\t\tif (!lstat(fname.c_str(), &st))\n\t\t\treturn S_ISDIR(st.st_mode);\n\t}\n#endif\n\treturn false;\n}\n\nbool dirent_is_file(const std::string &dir, struct dirent *ent)\n{\n\tif (ent->d_type == DT_REG)\n\t\treturn true;\n#ifndef WIN32\n\tif (ent->d_type == DT_UNKNOWN) {\n\t\tstd::string fname = dir + \"/\" + ent->d_name;\n\t\tstruct stat st;\n\t\tif (!lstat(fname.c_str(), &st))\n\t\t\treturn S_ISREG(st.st_mode);\n\t}\n#endif\n\treturn false;\n}\n\n/*!\n * List entries of a directory.\n * @param entries A string vector containing the result\n * @param dir Target directory for listing\n * @param bInclDirs Boolean flag to include directories in the result\n * @param bInclFiles Boolean flag to include regular files in the result\n */\nvoid DirectoryListing(std::vector<std::string>& entries, const std::string &dir, bool bInclDirs, bool bInclFiles)\n{\n\tDIR *d = NULL;\n\tstruct dirent *ent;\n\tif ((d = opendir(dir.c_str())) != NULL)\n\t{\n\t\twhile ((ent = readdir(d)) != NULL) {\n\t\t\tstd::string name = ent->d_name;\n\t\t\tif (bInclDirs && dirent_is_directory(dir, ent) && name != \".\" && name != \"..\") {\n\t\t\t\tentries.push_back(name);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (bInclFiles && dirent_is_file(dir, ent)) {\n\t\t\t\tentries.push_back(name);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tclosedir(d);\n\t}\n\treturn;\n}\n\nstd::string GenerateUserAgent()\n{\n\tsrand((unsigned int)time(NULL));\n\tint cversion = rand() % 0xFFFF;\n\tint mversion = rand() % 3;\n\tint sversion = rand() % 3;\n\tstd::stringstream sstr;\n\tsstr << \"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/\" << (601 + sversion) << \".\" << (36+mversion) << \" (KHTML, like Gecko) Chrome/\" << (53 + mversion) << \".0.\" << cversion << \".0 Safari/\" << (601 + sversion) << \".\" << (36+sversion);\n\treturn sstr.str();\n}\n\nstd::string MakeHtml(const std::string &txt)\n{\n        std::string sRet = txt;\n\n        stdreplace(sRet, \"&\", \"&amp;\");\n        stdreplace(sRet, \"\\\"\", \"&quot;\");\n        stdreplace(sRet, \"'\", \"&apos;\");\n        stdreplace(sRet, \"<\", \"&lt;\");\n        stdreplace(sRet, \">\", \"&gt;\");\n        stdreplace(sRet, \"\\r\\n\", \"<br/>\");\n        return sRet;\n}\n\n//Prevent against XSS (Cross Site Scripting)\nstd::string SafeHtml(const std::string &txt)\n{\n    std::string sRet = txt;\n\n    stdreplace(sRet, \"\\\"\", \"&quot;\");\n    stdreplace(sRet, \"'\", \"&apos;\");\n    stdreplace(sRet, \"<\", \"&lt;\");\n    stdreplace(sRet, \">\", \"&gt;\");\n    return sRet;\n}\n\n\n#if defined WIN32\n//FILETIME of Jan 1 1970 00:00:00\nstatic const uint64_t epoch = (const uint64_t)(116444736000000000);\n\nint gettimeofday( timeval * tp, void * tzp)\n{\n\tFILETIME    file_time;\n\tSYSTEMTIME  system_time;\n\tULARGE_INTEGER ularge;\n\tGetSystemTime(&system_time);\n\tSystemTimeToFileTime(&system_time, &file_time);\n\tularge.LowPart = file_time.dwLowDateTime;\n\tularge.HighPart = file_time.dwHighDateTime;\n\ttp->tv_sec = (long)((ularge.QuadPart - epoch) / 10000000L);\n\ttp->tv_usec = (long)(system_time.wMilliseconds * 1000);\n\treturn 0;\n}\n#endif\n\nint getclock(struct timeval *tv) {\n#ifdef CLOCK_MONOTONIC\n\tstruct timespec ts;\n\t\tif (!clock_gettime(CLOCK_MONOTONIC, &ts)) {\n\t\t\ttv->tv_sec = ts.tv_sec;\n\t\t\ttv->tv_usec = ts.tv_nsec / 1000;\n\t\t\treturn 0;\n\t\t}\n#endif\n\treturn gettimeofday(tv, NULL);\n}\nint timeval_subtract (struct timeval *result, struct timeval *x, struct timeval *y) {\n\t/* Perform the carry for the later subtraction by updating y. */\n  if (x->tv_usec < y->tv_usec) {\n\t\tint nsec = (y->tv_usec - x->tv_usec) / 1000000 + 1;\n    y->tv_usec -= 1000000 * nsec;\n    y->tv_sec += nsec;\n  }\n  if (x->tv_usec - y->tv_usec > 1000000) {\n    int nsec = (x->tv_usec - y->tv_usec) / 1000000;\n    y->tv_usec += 1000000 * nsec;\n    y->tv_sec -= nsec;\n  }\n\n  /* Compute the time remaining to wait.\n     tv_usec is certainly positive. */\n  result->tv_sec = x->tv_sec - y->tv_sec;\n  result->tv_usec = x->tv_usec - y->tv_usec;\n\n  /* Return 1 if result is negative. */\n  return x->tv_sec < y->tv_sec;\n}\n\nconst char *szInsecureArgumentOptions[] = {\n\t\"import\",\n\t\"socket\",\n\t\"process\",\n\t\"os\",\n\t\"|\",\n\t\";\",\n\t\"&\",\n\t\"$\",\n\t\"<\",\n\t\">\",\n\t\"\\n\",\n\t\"\\r\",\n\tNULL\n};\n\nbool IsArgumentSecure(const std::string &arg)\n{\n\tstd::string larg(arg);\n\tstd::transform(larg.begin(), larg.end(), larg.begin(), ::tolower);\n\n\tint ii = 0;\n\twhile (szInsecureArgumentOptions[ii] != NULL)\n\t{\n\t\tif (larg.find(szInsecureArgumentOptions[ii]) != std::string::npos)\n\t\t\treturn false;\n\t\tii++;\n\t}\n\treturn true;\n}\n\nuint32_t SystemUptime()\n{\n#if defined(WIN32)\n\treturn static_cast<uint32_t>(GetTickCount64() / 1000u);\n#elif defined(__linux__) || defined(__linux) || defined(linux)\n\tstruct sysinfo info;\n\tif (sysinfo(&info) != 0)\n\t\treturn -1;\n\treturn info.uptime;\n#elif defined(macintosh) || defined(__APPLE__) || defined(__APPLE_CC__)\n\tstruct timeval boottime;\n\tstd::size_t len = sizeof(boottime);\n\tint mib[2] = { CTL_KERN, KERN_BOOTTIME };\n\tif (sysctl(mib, 2, &boottime, &len, NULL, 0) < 0)\n\t\treturn -1;\n\treturn time(NULL) - boottime.tv_sec;\n#elif (defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__) || defined(__DragonFly__)) && defined(CLOCK_UPTIME)\n\tstruct timespec ts;\n\tif (clock_gettime(CLOCK_UPTIME, &ts) != 0)\n\t\treturn -1;\n\treturn ts.tv_sec;\n#else\n\treturn 0;\n#endif\n}\n\n// True random number generator (source: http://www.azillionmonkeys.com/qed/random.html)\nstatic struct\n{\n\tint which;\n\ttime_t t;\n\tclock_t c;\n\tint counter;\n} entropy = { 0, (time_t) 0, (clock_t) 0, 0 };\n\nstatic unsigned char * p = (unsigned char *) (&entropy + 1);\nstatic int accSeed = 0;\n\nint GenerateRandomNumber(const int range)\n{\n\tif (p == ((unsigned char *) (&entropy + 1)))\n\t{\n\t\tswitch (entropy.which)\n\t\t{\n\t\t\tcase 0:\n\t\t\t\tentropy.t += time (NULL);\n\t\t\t\taccSeed ^= entropy.t;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tentropy.c += clock();\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tentropy.counter++;\n\t\t\t\tbreak;\n\t\t}\n\t\tentropy.which = (entropy.which + 1) % 3;\n\t\tp = (unsigned char *) &entropy.t;\n\t}\n\taccSeed = ((accSeed * (UCHAR_MAX + 2U)) | 1) + (int) *p;\n\tp++;\n\tsrand (accSeed);\n\treturn (rand() / (RAND_MAX / range));\n}\n\nint GetDirFilesRecursive(const std::string &DirPath, std::map<std::string, int> &_Files)\n{\n\tDIR* dir;\n\tif ((dir = opendir(DirPath.c_str())) != NULL)\n\t{\n\t\tstruct dirent *ent;\n\t\twhile ((ent = readdir(dir)) != NULL)\n\t\t{\n\t\t\tif (dirent_is_directory(DirPath, ent))\n\t\t\t{\n\t\t\t\tif ((strcmp(ent->d_name, \".\") != 0) && (strcmp(ent->d_name, \"..\") != 0) && (strcmp(ent->d_name, \".svn\") != 0))\n\t\t\t\t{\n\t\t\t\t\tstd::string nextdir = DirPath + ent->d_name + \"/\";\n\t\t\t\t\tif (GetDirFilesRecursive(nextdir.c_str(), _Files))\n\t\t\t\t\t{\n\t\t\t\t\t\tclosedir(dir);\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstd::string fname = DirPath + ent->d_name;\n\t\t\t\t_Files[fname] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tclosedir(dir);\n\treturn 0;\n}\n\n#ifdef WIN32\n// From https://msdn.microsoft.com/en-us/library/xcb2z8hs.aspx\nconst DWORD MS_VC_EXCEPTION = 0x406D1388;\n#pragma pack(push,8)\ntypedef struct tagTHREADNAME_INFO\n{\n\tDWORD dwType; // Must be 0x1000.\n\tLPCSTR szName; // Pointer to name (in user addr space).\n\tDWORD dwThreadID; // Thread ID (-1=caller thread).\n\tDWORD dwFlags; // Reserved for future use, must be zero.\n} THREADNAME_INFO;\n#pragma pack(pop)\nint SetThreadName(const std::thread::native_handle_type &thread, const char* threadName) {\n\tDWORD dwThreadID = ::GetThreadId( static_cast<HANDLE>( thread ) );\n\tTHREADNAME_INFO info;\n\tinfo.dwType = 0x1000;\n\tinfo.szName = threadName;\n\tinfo.dwThreadID = dwThreadID;\n\tinfo.dwFlags = 0;\n#pragma warning(push)\n#pragma warning(disable: 6320 6322)\n\t__try{\n\t\tRaiseException(MS_VC_EXCEPTION, 0, sizeof(info) / sizeof(ULONG_PTR), (ULONG_PTR*)&info);\n\t}\n\t__except (EXCEPTION_EXECUTE_HANDLER){\n\t}\n#pragma warning(pop)\n\treturn 0;\n}\n#else\n// Based on https://stackoverflow.com/questions/2369738/how-to-set-the-name-of-a-thread-in-linux-pthreads\nint SetThreadName(const std::thread::native_handle_type &thread, const char *name)\n{\n#if defined(__linux__) || defined(__linux) || defined(linux)\n\tchar name_trunc[16];\n\tstrncpy(name_trunc, name, sizeof(name_trunc));\n\tname_trunc[sizeof(name_trunc)-1] = '\\0';\n\treturn pthread_setname_np(thread, name_trunc);\n#elif defined(macintosh) || defined(__APPLE__) || defined(__APPLE_CC__)\n\t// Not possible to set name of other thread: https://stackoverflow.com/questions/2369738/how-to-set-the-name-of-a-thread-in-linux-pthreads\n\treturn 0;\n#elif defined(__NetBSD__)\n\tchar name_trunc[PTHREAD_MAX_NAMELEN_NP];\n\tstrncpy(name_trunc, name, sizeof(name_trunc));\n\tname_trunc[sizeof(name_trunc)-1] = '\\0';\n\treturn pthread_setname_np(thread, \"%s\", (void *)name_trunc);\n#elif defined(__OpenBSD__) || defined(__DragonFly__)\n\tchar name_trunc[PTHREAD_MAX_NAMELEN_NP];\n\tstrncpy(name_trunc, name, sizeof(name_trunc));\n\tname_trunc[sizeof(name_trunc)-1] = '\\0';\n\tpthread_setname_np(thread, name_trunc);\n\treturn 0;\n#elif defined(__FreeBSD__)\n\tchar name_trunc[PTHREAD_MAX_NAMELEN_NP];\n\tstrncpy(name_trunc, name, sizeof(name_trunc));\n\tname_trunc[sizeof(name_trunc)-1] = '\\0';\n\tpthread_set_name_np(thread, name_trunc);\n\treturn 0;\n#endif\n}\n#endif\n\n#if !defined(WIN32)\nbool IsDebuggerPresent(void)\n{\n#if defined(__linux__)\n\t// Linux implementation: Search for 'TracerPid:' in /proc/self/status\n\tchar buf[4096];\n\n\tconst int status_fd = ::open(\"/proc/self/status\", O_RDONLY);\n\tif (status_fd == -1)\n\t\treturn false;\n\n\tconst ssize_t num_read = ::read(status_fd, buf, sizeof(buf) - 1);\n\tif (num_read <= 0)\n\t\treturn false;\n\n\tbuf[num_read] = '\\0';\n\tconstexpr char tracerPidString[] = \"TracerPid:\";\n\tconst auto tracer_pid_ptr = ::strstr(buf, tracerPidString);\n\tif (!tracer_pid_ptr)\n\t\treturn false;\n\n\tfor (const char* characterPtr = tracer_pid_ptr + sizeof(tracerPidString) - 1; characterPtr <= buf + num_read; ++characterPtr)\n\t{\n\t\tif (::isspace(*characterPtr))\n\t\t\tcontinue;\n\t\telse\n\t\t\treturn ::isdigit(*characterPtr) != 0 && *characterPtr != '0';\n\t}\n\n\treturn false;\n#else\n\t// MacOS X / BSD: TODO\n#\tifdef _DEBUG\n\treturn true;\n#\telse\n\treturn false;\n#\tendif\n#endif\n}\n#endif\n\n#if defined(__linux__)\nbool IsWSL(void)\n{\n\t// Detect WSL according to https://github.com/Microsoft/WSL/issues/423#issuecomment-221627364\n\tbool is_wsl = false;\n\n\tchar buf[1024];\n\n\tint status_fd = open(\"/proc/sys/kernel/osrelease\", O_RDONLY);\n\tif (status_fd == -1)\n\t\treturn is_wsl;\n\n\tssize_t num_read = read(status_fd, buf, sizeof(buf) - 1);\n\n\tif (num_read > 0)\n\t{\n\t\tbuf[num_read] = 0;\n\t\tis_wsl |= (strstr(buf, \"Microsoft\") != NULL);\n\t\tis_wsl |= (strstr(buf, \"WSL\") != NULL);\n\t}\n\n\tstatus_fd = open(\"/proc/version\", O_RDONLY);\n\tif (status_fd == -1)\n\t\treturn is_wsl;\n\n\tnum_read = read(status_fd, buf, sizeof(buf) - 1);\n\n\tif (num_read > 0)\n\t{\n\t\tbuf[num_read] = 0;\n\t\tis_wsl |= (strstr(buf, \"Microsoft\") != NULL);\n\t\tis_wsl |= (strstr(buf, \"WSL\") != NULL);\n\t}\n\n\treturn is_wsl;\n}\n#endif\n\nconst std::string hexCHARS = \"0123456789abcdef\";\nstd::string GenerateUUID() // DCE/RFC 4122\n{\n\tstd::srand((unsigned int)std::time(nullptr));\n\tstd::string uuid = std::string(36, ' ');\n\n\tuuid[8] = '-';\n\tuuid[13] = '-';\n\tuuid[14] = '4'; //M\n\tuuid[18] = '-';\n\t//uuid[19] = ' '; //N Variant 1 UUIDs (10xx N=8..b, 2 bits)\n\tuuid[23] = '-';\n\n\tfor (size_t ii = 0; ii < uuid.size(); ii++)\n\t{\n\t\tif (uuid[ii] == ' ')\n\t\t{\n\t\t\tuuid[ii] = hexCHARS[(ii == 19) ? (8 + (std::rand() & 0x03)) : std::rand() & 0x0F];\n\t\t}\n\t}\n\treturn uuid;\n}\n"], "filenames": ["main/Helper.cpp"], "buggy_code_start_loc": [1016], "buggy_code_end_loc": [1016], "fixing_code_start_loc": [1017], "fixing_code_end_loc": [1019], "type": "CWE-93", "message": "Domoticz before 4.10579 neglects to categorize \\n and \\r as insecure argument options.", "other": {"cve": {"id": "CVE-2019-10678", "sourceIdentifier": "cve@mitre.org", "published": "2019-03-31T21:29:00.200", "lastModified": "2019-05-03T13:59:44.967", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Domoticz before 4.10579 neglects to categorize \\n and \\r as insecure argument options."}, {"lang": "es", "value": "Domoticz, en versiones anteriores a la 4.10579, no categoriza \\n y \\r como opciones de argumento inseguro."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-93"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:domoticz:domoticz:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.10579", "matchCriteriaId": "927FBAAC-3155-4ECF-A09F-A848769EF356"}]}]}], "references": [{"url": "http://packetstormsecurity.com/files/152678/Domoticz-4.10577-Unauthenticated-Remote-Command-Execution.html", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/domoticz/domoticz/commit/2119afbe74ee0c914c1d5c4c859c594c08b0ad42", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.exploit-db.com/exploits/46773/", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory", "VDB Entry"]}]}, "github_commit_url": "https://github.com/domoticz/domoticz/commit/2119afbe74ee0c914c1d5c4c859c594c08b0ad42"}}