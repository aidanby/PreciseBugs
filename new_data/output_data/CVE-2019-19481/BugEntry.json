{"buggy_code": ["/*\n * card-cac1.c: Support for legacy CAC-1\n * card-default.c: Support for cards with no driver\n *\n * Copyright (C) 2001, 2002  Juha Yrj\u00f6l\u00e4 <juha.yrjola@iki.fi>\n * Copyright (C) 2005,2006,2007,2008,2009,2010 Douglas E. Engert <deengert@anl.gov>\n * Copyright (C) 2006, Identity Alliance, Thomas Harning <thomas.harning@identityalliance.com>\n * Copyright (C) 2007, EMC, Russell Larner <rlarner@rsa.com>\n * Copyright (C) 2016 - 2018, Red Hat, Inc.\n *\n * CAC driver author: Robert Relyea <rrelyea@redhat.com>\n * Further work: Jakub Jelen <jjelen@redhat.com>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#if HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <ctype.h>\n#include <fcntl.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <string.h>\n\n#ifdef _WIN32\n#include <io.h>\n#else\n#include <unistd.h>\n#endif\n\n#ifdef ENABLE_OPENSSL\n#include <openssl/sha.h>\n#endif /* ENABLE_OPENSSL */\n\n#include \"internal.h\"\n#include \"simpletlv.h\"\n#include \"cardctl.h\"\n#ifdef ENABLE_ZLIB\n#include \"compression.h\"\n#endif\n#include \"iso7816.h\"\n#include \"card-cac-common.h\"\n\n/*\n *  CAC hardware and APDU constants\n */\n#define CAC_INS_GET_CERTIFICATE       0x36  /* CAC1 command to read a certificate */\n\n/*\n * OLD cac read certificate, only use with CAC-1 card.\n */\nstatic int cac_cac1_get_certificate(sc_card_t *card, u8 **out_buf, size_t *out_len)\n{\n\tu8 buf[CAC_MAX_SIZE];\n\tu8 *out_ptr;\n\tsize_t size = 0;\n\tsize_t left = 0;\n\tsize_t len, next_len;\n\tsc_apdu_t apdu;\n\tint r = SC_SUCCESS;\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\t/* get the size */\n\tsize = left = *out_buf ? *out_len : sizeof(buf);\n\tout_ptr = *out_buf ? *out_buf : buf;\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_2_SHORT, CAC_INS_GET_CERTIFICATE, 0, 0 );\n\tnext_len = MIN(left, 100);\n\tfor (; left > 0; left -= len, out_ptr += len) {\n\t\tlen = next_len;\n\t\tapdu.resp = out_ptr;\n\t\tapdu.le = len;\n\t\tapdu.resplen = left;\n\t\tr = sc_transmit_apdu(card, &apdu);\n\t\tif (r < 0) {\n\t\t\tbreak;\n\t\t}\n\t\tif (apdu.resplen == 0) {\n\t\t\tr = SC_ERROR_INTERNAL;\n\t\t\tbreak;\n\t\t}\n\t\t/* in the old CAC-1, 0x63 means 'more data' in addition to 'pin failed' */\n\t\tif (apdu.sw1 != 0x63 || apdu.sw2 < 1)  {\n\t\t\t/* we've either finished reading, or hit an error, break */\n\t\t\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\t\t\tleft -= len;\n\t\t\tbreak;\n\t\t}\n\t\tnext_len = MIN(left, apdu.sw2);\n\t}\n\tif (r < 0) {\n\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, r);\n\t}\n\tr = size - left;\n\tif (*out_buf == NULL) {\n\t\t*out_buf = malloc(r);\n\t\tif (*out_buf == NULL) {\n\t\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t\t\tSC_ERROR_OUT_OF_MEMORY);\n\t\t}\n\t\tmemcpy(*out_buf, buf, r);\n\t}\n\t*out_len = r;\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, r);\n}\n\n/*\n * Callers of this may be expecting a certificate,\n * select file will have saved the object type for us\n * as well as set that we want the cert from the object.\n */\nstatic int cac_read_binary(sc_card_t *card, unsigned int idx,\n\t\tunsigned char *buf, size_t count, unsigned long flags)\n{\n\tcac_private_data_t * priv = CAC_DATA(card);\n\tint r = 0;\n\tu8 *val = NULL;\n\tu8 *cert_ptr;\n\tsize_t val_len;\n\tsize_t len, cert_len;\n\tu8 cert_type;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\n\t/* if we didn't return it all last time, return the remainder */\n\tif (priv->cached) {\n\t\tsc_log(card->ctx, \n\t\t\t\"returning cached value idx=%d count=%\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\t\tidx, count);\n\t\tif (idx > priv->cache_buf_len) {\n\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_FILE_END_REACHED);\n\t\t}\n\t\tlen = MIN(count, priv->cache_buf_len-idx);\n\t\tmemcpy(buf, &priv->cache_buf[idx], len);\n\t\tLOG_FUNC_RETURN(card->ctx, len);\n\t}\n\n\tsc_log(card->ctx, \n\t\t\"clearing cache idx=%d count=%\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\tidx, count);\n\tfree(priv->cache_buf);\n\tpriv->cache_buf = NULL;\n\tpriv->cache_buf_len = 0;\n\n\tr = cac_cac1_get_certificate(card, &val, &val_len);\n\tif (r < 0)\n\t\tgoto done;\n\tif (val_len < 1) {\n\t\tr = SC_ERROR_INVALID_DATA;\n\t\tgoto done;\n\t}\n\n\tcert_type = val[0];\n\tcert_ptr = val + 1;\n\tcert_len = val_len - 1;\n\n\t/* if the info byte is 1, then the cert is compressed, decompress it */\n\tif ((cert_type & 0x3) == 1) {\n#ifdef ENABLE_ZLIB\n\t\tr = sc_decompress_alloc(&priv->cache_buf, &priv->cache_buf_len,\n\t\t\tcert_ptr, cert_len, COMPRESSION_AUTO);\n#else\n\t\tsc_log(card->ctx, \"CAC compression not supported, no zlib\");\n\t\tr = SC_ERROR_NOT_SUPPORTED;\n#endif\n\t\tif (r)\n\t\t\tgoto done;\n\t} else if (cert_len > 0) {\n\t\tpriv->cache_buf = malloc(cert_len);\n\t\tif (priv->cache_buf == NULL) {\n\t\t\tr = SC_ERROR_OUT_OF_MEMORY;\n\t\t\tgoto done;\n\t\t}\n\t\tpriv->cache_buf_len = cert_len;\n\t\tmemcpy(priv->cache_buf, cert_ptr, cert_len);\n\t}\n\n\t/* OK we've read the data, now copy the required portion out to the callers buffer */\n\tpriv->cached = 1;\n\tlen = MIN(count, priv->cache_buf_len-idx);\n\tif (len && priv->cache_buf)\n\t\tmemcpy(buf, &priv->cache_buf[idx], len);\n\tr = len;\ndone:\n\tif (val)\n\t\tfree(val);\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\n\n/*\n * CAC cards use SC_PATH_SELECT_OBJECT_ID rather than SC_PATH_SELECT_FILE_ID. In order to use more\n * of the PKCS #15 structure, we call the selection SC_PATH_SELECT_FILE_ID, but we set p1 to 2 instead\n * of 0. Also cac1 does not do any FCI, but it doesn't understand not selecting it. It returns invalid INS\n * if it doesn't like anything about the select, so we always 'request' FCI for CAC1\n *\n * The rest is just copied from iso7816_select_file\n */\nstatic int cac_select_file_by_type(sc_card_t *card, const sc_path_t *in_path, sc_file_t **file_out)\n{\n\tstruct sc_context *ctx;\n\tstruct sc_apdu apdu;\n\tunsigned char buf[SC_MAX_APDU_BUFFER_SIZE];\n\tunsigned char pathbuf[SC_MAX_PATH_SIZE], *path = pathbuf;\n\tint r, pathlen, pathtype;\n\tstruct sc_file *file = NULL;\n\tcac_private_data_t * priv = CAC_DATA(card);\n\n\tassert(card != NULL && in_path != NULL);\n\tctx = card->ctx;\n\n\tSC_FUNC_CALLED(ctx, SC_LOG_DEBUG_VERBOSE);\n\n\tmemcpy(path, in_path->value, in_path->len);\n\tpathlen = in_path->len;\n\tpathtype = in_path->type;\n\n\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t\"path=%s, path->value=%s path->type=%d (%x)\",\n\t\tsc_print_path(in_path),\n\t\tsc_dump_hex(in_path->value, in_path->len),\n\t\tin_path->type, in_path->type);\n\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE, \"file_out=%p index=%d count=%d\\n\",\n\t\tfile_out, in_path->index, in_path->count);\n\n\t/* Sigh, iso7816_select_file expects paths to keys to have specific\n\t * formats. There is no override. We have to add some bytes to the\n\t * path to make it happy.\n\t * We only need to do this for private keys.\n\t */\n\tif ((pathlen > 2) && (pathlen <= 4) && memcmp(path, \"\\x3F\\x00\", 2) == 0) {\n\t\tpath += 2;\n\t\tpathlen -= 2;\n\t}\n\n\n\t/* CAC has multiple different type of objects that aren't PKCS #15. When we read\n\t * them we need convert them to something PKCS #15 would understand. Find the object\n\t * and object type here:\n\t */\n\tif (priv) { /* don't record anything if we haven't been initialized yet */\n\t\t/* forget any old cached values */\n\t\tif (priv->cache_buf) {\n\t\t\tfree(priv->cache_buf);\n\t\t\tpriv->cache_buf = NULL;\n\t\t}\n\t\tpriv->cache_buf_len = 0;\n\t\tpriv->cached = 0;\n\t}\n\n\tif (in_path->aid.len) {\n\t\tif (!pathlen) {\n\t\t\tmemcpy(path, in_path->aid.value, in_path->aid.len);\n\t\t\tpathlen = in_path->aid.len;\n\t\t\tpathtype = SC_PATH_TYPE_DF_NAME;\n\t\t} else {\n\t\t\t/* First, select the application */\n\t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\"select application\" );\n\t\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0xA4, 4, 0);\n\t\t\tapdu.data = in_path->aid.value;\n\t\t\tapdu.datalen = in_path->aid.len;\n\t\t\tapdu.lc = in_path->aid.len;\n\n\t\t\tr = sc_transmit_apdu(card, &apdu);\n\t\t\tLOG_TEST_RET(ctx, r, \"APDU transmit failed\");\n\t\t\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\t\t\tif (r)\n\t\t\t\tLOG_FUNC_RETURN(ctx, r);\n\n\t\t}\n\t}\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0xA4, 0, 0);\n\n\tswitch (pathtype) {\n\t/* ideally we would had SC_PATH_TYPE_OBJECT_ID and add code to the iso7816 select.\n\t * Unfortunately we'd also need to update the caching code as well. For now just\n\t * use FILE_ID and change p1 here */\n\tcase SC_PATH_TYPE_FILE_ID:\n\t\tapdu.p1 = 2;\n\t\tif (pathlen != 2)\n\t\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t\tbreak;\n\tcase SC_PATH_TYPE_DF_NAME:\n\t\tapdu.p1 = 4;\n\t\tbreak;\n\tdefault:\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_INVALID_ARGUMENTS);\n\t}\n\tapdu.lc = pathlen;\n\tapdu.data = path;\n\tapdu.datalen = pathlen;\n\tapdu.resp = buf;\n\tapdu.resplen = sizeof(buf);\n\tapdu.le = sc_get_max_recv_size(card) < 256 ? sc_get_max_recv_size(card) : 256;\n\tapdu.p2 = 0x00;\n\n\tr = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(ctx, r, \"APDU transmit failed\");\n\n\tif (file_out == NULL) {\n\t\t/* For some cards 'SELECT' can be only with request to return FCI/FCP. */\n\t\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\t\tif (apdu.sw1 == 0x6A && apdu.sw2 == 0x86)   {\n\t\t\tapdu.p2 = 0x00;\n\t\t\tapdu.resplen = sizeof(buf);\n\t\t\tif (sc_transmit_apdu(card, &apdu) == SC_SUCCESS)\n\t\t\t\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\t\t}\n\t\tif (apdu.sw1 == 0x61)\n\t\t\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n\t\tLOG_FUNC_RETURN(ctx, r);\n\t}\n\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tif (r)\n\t\tLOG_FUNC_RETURN(ctx, r);\n\n\t/* CAC cards never return FCI, fake one */\n\tfile = sc_file_new();\n\tif (file == NULL)\n\t\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_OUT_OF_MEMORY);\n\tfile->path = *in_path;\n\tfile->size = CAC_MAX_SIZE; /* we don't know how big, just give a large size until we can read the file */\n\n\t*file_out = file;\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n\n}\n\nstatic int cac_select_file(sc_card_t *card, const sc_path_t *in_path, sc_file_t **file_out)\n{\n\treturn cac_select_file_by_type(card, in_path, file_out);\n}\n\nstatic int cac_finish(sc_card_t *card)\n{\n\tcac_private_data_t * priv = CAC_DATA(card);\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\tif (priv) {\n\t\tcac_free_private_data(priv);\n\t}\n\treturn SC_SUCCESS;\n}\n\n\n/* select a CAC pki applet by index */\nstatic int cac_select_pki_applet(sc_card_t *card, int index)\n{\n\tsc_path_t applet_path = cac_cac_pki_obj.path;\n\tapplet_path.aid.value[applet_path.aid.len-1] = index;\n\treturn cac_select_file_by_type(card, &applet_path, NULL);\n}\n\n/*\n *  Find the first existing CAC applet. If none found, then this isn't a CAC\n */\nstatic int cac_find_first_pki_applet(sc_card_t *card, int *index_out)\n{\n\tint r, i;\n\n\tfor (i = 0; i < MAX_CAC_SLOTS; i++) {\n\t\tr = cac_select_pki_applet(card, i);\n\t\tif (r == SC_SUCCESS) {\n\t\t\tu8 data[2];\n\t\t\tsc_apdu_t apdu;\n\n\t\t\t/* Try to read first two bytes of the buffer to\n\t\t\t * make sure it is not just malfunctioning card\n\t\t\t */\n\t\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_2,\n\t\t\t\tCAC_INS_GET_CERTIFICATE, 0x00, 0x00);\n\t\t\tapdu.le = 0x02;\n\t\t\tapdu.resplen = 2;\n\t\t\tapdu.resp = data;\n\t\t\tr = sc_transmit_apdu(card, &apdu);\n\t\t\t/* SW1 = 0x63 means more data in CAC1 */\n\t\t\tif (r == SC_SUCCESS && apdu.sw1 != 0x63)\n\t\t\t\tcontinue;\n\n\t\t\t*index_out = i;\n\t\t\treturn SC_SUCCESS;\n\t\t}\n\t}\n\treturn SC_ERROR_OBJECT_NOT_FOUND;\n}\n\nstatic int cac_populate_cac1(sc_card_t *card, int index, cac_private_data_t *priv)\n{\n\tint r, i;\n\tcac_object_t pki_obj = cac_cac_pki_obj;\n\tu8 buf[100];\n\tu8 *val;\n\tsize_t val_len;\n\n\t/* populate PKI objects */\n\tfor (i = index; i < MAX_CAC_SLOTS; i++) {\n\t\tr = cac_select_pki_applet(card, i);\n\t\tif (r == SC_SUCCESS) {\n\t\t\tpki_obj.name = get_cac_label(i);\n\t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t\t\t\"CAC: pki_object found, cert_next=%d (%s)\",\n\t\t\t\ti, pki_obj.name);\n\t\t\tpki_obj.path.aid.value[pki_obj.path.aid.len-1] = i;\n\t\t\tpki_obj.fd = i+1; /* don't use id of zero */\n\t\t\tcac_add_object_to_list(&priv->pki_list, &pki_obj);\n\t\t}\n\t}\n\n\t/*\n\t * create a cuid to simulate the cac 2 cuid.\n\t */\n\tpriv->cuid = cac_cac_cuid;\n\t/* create a serial number by hashing the first 100 bytes of the\n\t * first certificate on the card */\n\tr = cac_select_pki_applet(card, index);\n\tif (r < 0) {\n\t\treturn r; /* shouldn't happen unless the card has been removed or is malfunctioning */\n\t}\n\tval = buf;\n\tval_len = sizeof(buf);\n\tr = cac_cac1_get_certificate(card, &val, &val_len);\n\tif (r >= 0) {\n\t\tpriv->cac_id = malloc(20);\n\t\tif (priv->cac_id == NULL) {\n\t\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\t\t}\n#ifdef ENABLE_OPENSSL\n\t\tSHA1(val, val_len, priv->cac_id);\n\t\tpriv->cac_id_len = 20;\n\t\tsc_debug_hex(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t\t\"cuid\", priv->cac_id, priv->cac_id_len);\n#else\n\t\tsc_log(card->ctx, \"OpenSSL Required\");\n\t\treturn SC_ERROR_NOT_SUPPORTED;\n#endif /* ENABLE_OPENSSL */\n\t}\n\treturn SC_SUCCESS;\n}\n\n/*\n * Look for a CAC card. If it exists, initialize our data structures\n */\nstatic int cac_find_and_initialize(sc_card_t *card, int initialize)\n{\n\tint r, index;\n\tcac_private_data_t *priv = NULL;\n\n\t/* already initialized? */\n\tif (card->drv_data) {\n\t\treturn SC_SUCCESS;\n\t}\n\n\t/* is this a CAC Alt token without any accompanying structures */\n\tr = cac_find_first_pki_applet(card, &index);\n\tif (r == SC_SUCCESS) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE, \"PKI applet found, is bare CAC-1\");\n\t\tif (!initialize) /* match card only */\n\t\t\treturn r;\n\n\t\tif (!priv) {\n\t\t\tpriv = cac_new_private_data();\n\t\t\tif (!priv)\n\t\t\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\t\t}\n\t\tcard->drv_data = priv; /* needed for the read_binary() */\n\t\tr = cac_populate_cac1(card, index, priv);\n\t\tif (r == SC_SUCCESS) {\n\t\t\tcard->type = SC_CARD_TYPE_CAC_I;\n\t\t\treturn r;\n\t\t}\n\t\tcard->drv_data = NULL; /* reset on failure */\n\t}\n\tif (priv) {\n\t\tcac_free_private_data(priv);\n\t}\n\treturn r;\n}\n\n\n/* NOTE: returns a bool, 1 card matches, 0 it does not */\nstatic int cac_match_card(sc_card_t *card)\n{\n\tint r;\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\t/* Since we send an APDU, the card's logout function may be called...\n\t * however it may be in dirty memory */\n\tcard->ops->logout = NULL;\n\n\tr = cac_find_and_initialize(card, 0);\n\treturn (r == SC_SUCCESS); /* never match */\n}\n\n\nstatic int cac_init(sc_card_t *card)\n{\n\tint r;\n\tunsigned long flags;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\n\tr = cac_find_and_initialize(card, 1);\n\tif (r < 0) {\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_CARD);\n\t}\n\tflags = SC_ALGORITHM_RSA_RAW;\n\n\t_sc_card_add_rsa_alg(card, 1024, flags, 0); /* mandatory */\n\t_sc_card_add_rsa_alg(card, 2048, flags, 0); /* optional */\n\t_sc_card_add_rsa_alg(card, 3072, flags, 0); /* optional */\n\n\tcard->caps |= SC_CARD_CAP_RNG | SC_CARD_CAP_ISO7816_PIN_INFO;\n\n\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n}\n\nstatic struct sc_card_operations cac_ops;\n\nstatic struct sc_card_driver cac1_drv = {\n\t\"Common Access Card (CAC 1)\",\n\t\"cac1\",\n\t&cac_ops,\n\tNULL, 0, NULL\n};\n\nstatic struct sc_card_driver * sc_get_driver(void)\n{\n\t/* Inherit most of the things from the CAC driver */\n\tstruct sc_card_driver *cac_drv = sc_get_cac_driver();\n\n\tcac_ops = *cac_drv->ops;\n\tcac_ops.match_card = cac_match_card;\n\tcac_ops.init = cac_init;\n\tcac_ops.finish = cac_finish;\n\n\tcac_ops.select_file =  cac_select_file; /* need to record object type */\n\tcac_ops.read_binary = cac_read_binary;\n\n\treturn &cac1_drv;\n}\n\n\nstruct sc_card_driver * sc_get_cac1_driver(void)\n{\n\treturn sc_get_driver();\n}\n"], "fixing_code": ["/*\n * card-cac1.c: Support for legacy CAC-1\n * card-default.c: Support for cards with no driver\n *\n * Copyright (C) 2001, 2002  Juha Yrj\u00f6l\u00e4 <juha.yrjola@iki.fi>\n * Copyright (C) 2005,2006,2007,2008,2009,2010 Douglas E. Engert <deengert@anl.gov>\n * Copyright (C) 2006, Identity Alliance, Thomas Harning <thomas.harning@identityalliance.com>\n * Copyright (C) 2007, EMC, Russell Larner <rlarner@rsa.com>\n * Copyright (C) 2016 - 2018, Red Hat, Inc.\n *\n * CAC driver author: Robert Relyea <rrelyea@redhat.com>\n * Further work: Jakub Jelen <jjelen@redhat.com>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#if HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <ctype.h>\n#include <fcntl.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <string.h>\n\n#ifdef _WIN32\n#include <io.h>\n#else\n#include <unistd.h>\n#endif\n\n#ifdef ENABLE_OPENSSL\n#include <openssl/sha.h>\n#endif /* ENABLE_OPENSSL */\n\n#include \"internal.h\"\n#include \"simpletlv.h\"\n#include \"cardctl.h\"\n#ifdef ENABLE_ZLIB\n#include \"compression.h\"\n#endif\n#include \"iso7816.h\"\n#include \"card-cac-common.h\"\n\n/*\n *  CAC hardware and APDU constants\n */\n#define CAC_INS_GET_CERTIFICATE       0x36  /* CAC1 command to read a certificate */\n\n/*\n * OLD cac read certificate, only use with CAC-1 card.\n */\nstatic int cac_cac1_get_certificate(sc_card_t *card, u8 **out_buf, size_t *out_len)\n{\n\tu8 buf[CAC_MAX_SIZE];\n\tu8 *out_ptr;\n\tsize_t size = 0;\n\tsize_t left = 0;\n\tsize_t len;\n\tsc_apdu_t apdu;\n\tint r = SC_SUCCESS;\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\t/* get the size */\n\tsize = left = *out_buf ? *out_len : sizeof(buf);\n\tout_ptr = *out_buf ? *out_buf : buf;\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_2_SHORT, CAC_INS_GET_CERTIFICATE, 0, 0 );\n\tlen = MIN(left, 100);\n\tfor (; left > 0;) { /* Increments for readability in the end of the function */\n\t\tapdu.resp = out_ptr;\n\t\tapdu.le = len;\n\t\tapdu.resplen = left;\n\t\tr = sc_transmit_apdu(card, &apdu);\n\t\tif (r < 0) {\n\t\t\tbreak;\n\t\t}\n\t\tif (apdu.resplen == 0) {\n\t\t\tr = SC_ERROR_INTERNAL;\n\t\t\tbreak;\n\t\t}\n\t\t/* in the old CAC-1, 0x63 means 'more data' in addition to 'pin failed' */\n\t\tif (apdu.sw1 != 0x63 || apdu.sw2 < 1)  {\n\t\t\t/* we've either finished reading, or hit an error, break */\n\t\t\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\t\t\tleft -= len;\n\t\t\tbreak;\n\t\t}\n\t\t/* Adjust the lengths */\n\t\tleft -= len;\n\t\tout_ptr += len;\n\t\tlen = MIN(left, apdu.sw2);\n\t}\n\tif (r < 0) {\n\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, r);\n\t}\n\tr = size - left;\n\tif (*out_buf == NULL) {\n\t\t*out_buf = malloc(r);\n\t\tif (*out_buf == NULL) {\n\t\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t\t\tSC_ERROR_OUT_OF_MEMORY);\n\t\t}\n\t\tmemcpy(*out_buf, buf, r);\n\t}\n\t*out_len = r;\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, r);\n}\n\n/*\n * Callers of this may be expecting a certificate,\n * select file will have saved the object type for us\n * as well as set that we want the cert from the object.\n */\nstatic int cac_read_binary(sc_card_t *card, unsigned int idx,\n\t\tunsigned char *buf, size_t count, unsigned long flags)\n{\n\tcac_private_data_t * priv = CAC_DATA(card);\n\tint r = 0;\n\tu8 *val = NULL;\n\tu8 *cert_ptr;\n\tsize_t val_len = 0;\n\tsize_t len, cert_len;\n\tu8 cert_type;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\n\t/* if we didn't return it all last time, return the remainder */\n\tif (priv->cached) {\n\t\tsc_log(card->ctx, \n\t\t\t\"returning cached value idx=%d count=%\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\t\tidx, count);\n\t\tif (idx > priv->cache_buf_len) {\n\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_FILE_END_REACHED);\n\t\t}\n\t\tlen = MIN(count, priv->cache_buf_len-idx);\n\t\tmemcpy(buf, &priv->cache_buf[idx], len);\n\t\tLOG_FUNC_RETURN(card->ctx, len);\n\t}\n\n\tsc_log(card->ctx, \n\t\t\"clearing cache idx=%d count=%\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\tidx, count);\n\tfree(priv->cache_buf);\n\tpriv->cache_buf = NULL;\n\tpriv->cache_buf_len = 0;\n\n\tr = cac_cac1_get_certificate(card, &val, &val_len);\n\tif (r < 0)\n\t\tgoto done;\n\tif (val_len < 1) {\n\t\tr = SC_ERROR_INVALID_DATA;\n\t\tgoto done;\n\t}\n\n\tcert_type = val[0];\n\tcert_ptr = val + 1;\n\tcert_len = val_len - 1;\n\n\t/* if the info byte is 1, then the cert is compressed, decompress it */\n\tif ((cert_type & 0x3) == 1) {\n#ifdef ENABLE_ZLIB\n\t\tr = sc_decompress_alloc(&priv->cache_buf, &priv->cache_buf_len,\n\t\t\tcert_ptr, cert_len, COMPRESSION_AUTO);\n#else\n\t\tsc_log(card->ctx, \"CAC compression not supported, no zlib\");\n\t\tr = SC_ERROR_NOT_SUPPORTED;\n#endif\n\t\tif (r)\n\t\t\tgoto done;\n\t} else if (cert_len > 0) {\n\t\tpriv->cache_buf = malloc(cert_len);\n\t\tif (priv->cache_buf == NULL) {\n\t\t\tr = SC_ERROR_OUT_OF_MEMORY;\n\t\t\tgoto done;\n\t\t}\n\t\tpriv->cache_buf_len = cert_len;\n\t\tmemcpy(priv->cache_buf, cert_ptr, cert_len);\n\t}\n\n\t/* OK we've read the data, now copy the required portion out to the callers buffer */\n\tpriv->cached = 1;\n\tlen = MIN(count, priv->cache_buf_len-idx);\n\tif (len && priv->cache_buf)\n\t\tmemcpy(buf, &priv->cache_buf[idx], len);\n\tr = len;\ndone:\n\tif (val)\n\t\tfree(val);\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\n\n/*\n * CAC cards use SC_PATH_SELECT_OBJECT_ID rather than SC_PATH_SELECT_FILE_ID. In order to use more\n * of the PKCS #15 structure, we call the selection SC_PATH_SELECT_FILE_ID, but we set p1 to 2 instead\n * of 0. Also cac1 does not do any FCI, but it doesn't understand not selecting it. It returns invalid INS\n * if it doesn't like anything about the select, so we always 'request' FCI for CAC1\n *\n * The rest is just copied from iso7816_select_file\n */\nstatic int cac_select_file_by_type(sc_card_t *card, const sc_path_t *in_path, sc_file_t **file_out)\n{\n\tstruct sc_context *ctx;\n\tstruct sc_apdu apdu;\n\tunsigned char buf[SC_MAX_APDU_BUFFER_SIZE];\n\tunsigned char pathbuf[SC_MAX_PATH_SIZE], *path = pathbuf;\n\tint r, pathlen, pathtype;\n\tstruct sc_file *file = NULL;\n\tcac_private_data_t * priv = CAC_DATA(card);\n\n\tassert(card != NULL && in_path != NULL);\n\tctx = card->ctx;\n\n\tSC_FUNC_CALLED(ctx, SC_LOG_DEBUG_VERBOSE);\n\n\tmemcpy(path, in_path->value, in_path->len);\n\tpathlen = in_path->len;\n\tpathtype = in_path->type;\n\n\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t\"path=%s, path->value=%s path->type=%d (%x)\",\n\t\tsc_print_path(in_path),\n\t\tsc_dump_hex(in_path->value, in_path->len),\n\t\tin_path->type, in_path->type);\n\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE, \"file_out=%p index=%d count=%d\\n\",\n\t\tfile_out, in_path->index, in_path->count);\n\n\t/* Sigh, iso7816_select_file expects paths to keys to have specific\n\t * formats. There is no override. We have to add some bytes to the\n\t * path to make it happy.\n\t * We only need to do this for private keys.\n\t */\n\tif ((pathlen > 2) && (pathlen <= 4) && memcmp(path, \"\\x3F\\x00\", 2) == 0) {\n\t\tpath += 2;\n\t\tpathlen -= 2;\n\t}\n\n\n\t/* CAC has multiple different type of objects that aren't PKCS #15. When we read\n\t * them we need convert them to something PKCS #15 would understand. Find the object\n\t * and object type here:\n\t */\n\tif (priv) { /* don't record anything if we haven't been initialized yet */\n\t\t/* forget any old cached values */\n\t\tif (priv->cache_buf) {\n\t\t\tfree(priv->cache_buf);\n\t\t\tpriv->cache_buf = NULL;\n\t\t}\n\t\tpriv->cache_buf_len = 0;\n\t\tpriv->cached = 0;\n\t}\n\n\tif (in_path->aid.len) {\n\t\tif (!pathlen) {\n\t\t\tmemcpy(path, in_path->aid.value, in_path->aid.len);\n\t\t\tpathlen = in_path->aid.len;\n\t\t\tpathtype = SC_PATH_TYPE_DF_NAME;\n\t\t} else {\n\t\t\t/* First, select the application */\n\t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\"select application\" );\n\t\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0xA4, 4, 0);\n\t\t\tapdu.data = in_path->aid.value;\n\t\t\tapdu.datalen = in_path->aid.len;\n\t\t\tapdu.lc = in_path->aid.len;\n\n\t\t\tr = sc_transmit_apdu(card, &apdu);\n\t\t\tLOG_TEST_RET(ctx, r, \"APDU transmit failed\");\n\t\t\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\t\t\tif (r)\n\t\t\t\tLOG_FUNC_RETURN(ctx, r);\n\n\t\t}\n\t}\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0xA4, 0, 0);\n\n\tswitch (pathtype) {\n\t/* ideally we would had SC_PATH_TYPE_OBJECT_ID and add code to the iso7816 select.\n\t * Unfortunately we'd also need to update the caching code as well. For now just\n\t * use FILE_ID and change p1 here */\n\tcase SC_PATH_TYPE_FILE_ID:\n\t\tapdu.p1 = 2;\n\t\tif (pathlen != 2)\n\t\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t\tbreak;\n\tcase SC_PATH_TYPE_DF_NAME:\n\t\tapdu.p1 = 4;\n\t\tbreak;\n\tdefault:\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_INVALID_ARGUMENTS);\n\t}\n\tapdu.lc = pathlen;\n\tapdu.data = path;\n\tapdu.datalen = pathlen;\n\tapdu.resp = buf;\n\tapdu.resplen = sizeof(buf);\n\tapdu.le = sc_get_max_recv_size(card) < 256 ? sc_get_max_recv_size(card) : 256;\n\tapdu.p2 = 0x00;\n\n\tr = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(ctx, r, \"APDU transmit failed\");\n\n\tif (file_out == NULL) {\n\t\t/* For some cards 'SELECT' can be only with request to return FCI/FCP. */\n\t\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\t\tif (apdu.sw1 == 0x6A && apdu.sw2 == 0x86)   {\n\t\t\tapdu.p2 = 0x00;\n\t\t\tapdu.resplen = sizeof(buf);\n\t\t\tif (sc_transmit_apdu(card, &apdu) == SC_SUCCESS)\n\t\t\t\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\t\t}\n\t\tif (apdu.sw1 == 0x61)\n\t\t\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n\t\tLOG_FUNC_RETURN(ctx, r);\n\t}\n\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tif (r)\n\t\tLOG_FUNC_RETURN(ctx, r);\n\n\t/* CAC cards never return FCI, fake one */\n\tfile = sc_file_new();\n\tif (file == NULL)\n\t\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_OUT_OF_MEMORY);\n\tfile->path = *in_path;\n\tfile->size = CAC_MAX_SIZE; /* we don't know how big, just give a large size until we can read the file */\n\n\t*file_out = file;\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n\n}\n\nstatic int cac_select_file(sc_card_t *card, const sc_path_t *in_path, sc_file_t **file_out)\n{\n\treturn cac_select_file_by_type(card, in_path, file_out);\n}\n\nstatic int cac_finish(sc_card_t *card)\n{\n\tcac_private_data_t * priv = CAC_DATA(card);\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\tif (priv) {\n\t\tcac_free_private_data(priv);\n\t}\n\treturn SC_SUCCESS;\n}\n\n\n/* select a CAC pki applet by index */\nstatic int cac_select_pki_applet(sc_card_t *card, int index)\n{\n\tsc_path_t applet_path = cac_cac_pki_obj.path;\n\tapplet_path.aid.value[applet_path.aid.len-1] = index;\n\treturn cac_select_file_by_type(card, &applet_path, NULL);\n}\n\n/*\n *  Find the first existing CAC applet. If none found, then this isn't a CAC\n */\nstatic int cac_find_first_pki_applet(sc_card_t *card, int *index_out)\n{\n\tint r, i;\n\n\tfor (i = 0; i < MAX_CAC_SLOTS; i++) {\n\t\tr = cac_select_pki_applet(card, i);\n\t\tif (r == SC_SUCCESS) {\n\t\t\tu8 data[2];\n\t\t\tsc_apdu_t apdu;\n\n\t\t\t/* Try to read first two bytes of the buffer to\n\t\t\t * make sure it is not just malfunctioning card\n\t\t\t */\n\t\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_2,\n\t\t\t\tCAC_INS_GET_CERTIFICATE, 0x00, 0x00);\n\t\t\tapdu.le = 0x02;\n\t\t\tapdu.resplen = 2;\n\t\t\tapdu.resp = data;\n\t\t\tr = sc_transmit_apdu(card, &apdu);\n\t\t\t/* SW1 = 0x63 means more data in CAC1 */\n\t\t\tif (r == SC_SUCCESS && apdu.sw1 != 0x63)\n\t\t\t\tcontinue;\n\n\t\t\t*index_out = i;\n\t\t\treturn SC_SUCCESS;\n\t\t}\n\t}\n\treturn SC_ERROR_OBJECT_NOT_FOUND;\n}\n\nstatic int cac_populate_cac1(sc_card_t *card, int index, cac_private_data_t *priv)\n{\n\tint r, i;\n\tcac_object_t pki_obj = cac_cac_pki_obj;\n\tu8 buf[100];\n\tu8 *val;\n\tsize_t val_len;\n\n\t/* populate PKI objects */\n\tfor (i = index; i < MAX_CAC_SLOTS; i++) {\n\t\tr = cac_select_pki_applet(card, i);\n\t\tif (r == SC_SUCCESS) {\n\t\t\tpki_obj.name = get_cac_label(i);\n\t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t\t\t\"CAC: pki_object found, cert_next=%d (%s)\",\n\t\t\t\ti, pki_obj.name);\n\t\t\tpki_obj.path.aid.value[pki_obj.path.aid.len-1] = i;\n\t\t\tpki_obj.fd = i+1; /* don't use id of zero */\n\t\t\tcac_add_object_to_list(&priv->pki_list, &pki_obj);\n\t\t}\n\t}\n\n\t/*\n\t * create a cuid to simulate the cac 2 cuid.\n\t */\n\tpriv->cuid = cac_cac_cuid;\n\t/* create a serial number by hashing the first 100 bytes of the\n\t * first certificate on the card */\n\tr = cac_select_pki_applet(card, index);\n\tif (r < 0) {\n\t\treturn r; /* shouldn't happen unless the card has been removed or is malfunctioning */\n\t}\n\tval = buf;\n\tval_len = sizeof(buf);\n\tr = cac_cac1_get_certificate(card, &val, &val_len);\n\tif (r >= 0) {\n\t\tpriv->cac_id = malloc(20);\n\t\tif (priv->cac_id == NULL) {\n\t\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\t\t}\n#ifdef ENABLE_OPENSSL\n\t\tSHA1(val, val_len, priv->cac_id);\n\t\tpriv->cac_id_len = 20;\n\t\tsc_debug_hex(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t\t\"cuid\", priv->cac_id, priv->cac_id_len);\n#else\n\t\tsc_log(card->ctx, \"OpenSSL Required\");\n\t\treturn SC_ERROR_NOT_SUPPORTED;\n#endif /* ENABLE_OPENSSL */\n\t}\n\treturn SC_SUCCESS;\n}\n\n/*\n * Look for a CAC card. If it exists, initialize our data structures\n */\nstatic int cac_find_and_initialize(sc_card_t *card, int initialize)\n{\n\tint r, index;\n\tcac_private_data_t *priv = NULL;\n\n\t/* already initialized? */\n\tif (card->drv_data) {\n\t\treturn SC_SUCCESS;\n\t}\n\n\t/* is this a CAC Alt token without any accompanying structures */\n\tr = cac_find_first_pki_applet(card, &index);\n\tif (r == SC_SUCCESS) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE, \"PKI applet found, is bare CAC-1\");\n\t\tif (!initialize) /* match card only */\n\t\t\treturn r;\n\n\t\tif (!priv) {\n\t\t\tpriv = cac_new_private_data();\n\t\t\tif (!priv)\n\t\t\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\t\t}\n\t\tcard->drv_data = priv; /* needed for the read_binary() */\n\t\tr = cac_populate_cac1(card, index, priv);\n\t\tif (r == SC_SUCCESS) {\n\t\t\tcard->type = SC_CARD_TYPE_CAC_I;\n\t\t\treturn r;\n\t\t}\n\t\tcard->drv_data = NULL; /* reset on failure */\n\t}\n\tif (priv) {\n\t\tcac_free_private_data(priv);\n\t}\n\treturn r;\n}\n\n\n/* NOTE: returns a bool, 1 card matches, 0 it does not */\nstatic int cac_match_card(sc_card_t *card)\n{\n\tint r;\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\t/* Since we send an APDU, the card's logout function may be called...\n\t * however it may be in dirty memory */\n\tcard->ops->logout = NULL;\n\n\tr = cac_find_and_initialize(card, 0);\n\treturn (r == SC_SUCCESS); /* never match */\n}\n\n\nstatic int cac_init(sc_card_t *card)\n{\n\tint r;\n\tunsigned long flags;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\n\tr = cac_find_and_initialize(card, 1);\n\tif (r < 0) {\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_CARD);\n\t}\n\tflags = SC_ALGORITHM_RSA_RAW;\n\n\t_sc_card_add_rsa_alg(card, 1024, flags, 0); /* mandatory */\n\t_sc_card_add_rsa_alg(card, 2048, flags, 0); /* optional */\n\t_sc_card_add_rsa_alg(card, 3072, flags, 0); /* optional */\n\n\tcard->caps |= SC_CARD_CAP_RNG | SC_CARD_CAP_ISO7816_PIN_INFO;\n\n\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n}\n\nstatic struct sc_card_operations cac_ops;\n\nstatic struct sc_card_driver cac1_drv = {\n\t\"Common Access Card (CAC 1)\",\n\t\"cac1\",\n\t&cac_ops,\n\tNULL, 0, NULL\n};\n\nstatic struct sc_card_driver * sc_get_driver(void)\n{\n\t/* Inherit most of the things from the CAC driver */\n\tstruct sc_card_driver *cac_drv = sc_get_cac_driver();\n\n\tcac_ops = *cac_drv->ops;\n\tcac_ops.match_card = cac_match_card;\n\tcac_ops.init = cac_init;\n\tcac_ops.finish = cac_finish;\n\n\tcac_ops.select_file =  cac_select_file; /* need to record object type */\n\tcac_ops.read_binary = cac_read_binary;\n\n\treturn &cac1_drv;\n}\n\n\nstruct sc_card_driver * sc_get_cac1_driver(void)\n{\n\treturn sc_get_driver();\n}\n"], "filenames": ["src/libopensc/card-cac1.c"], "buggy_code_start_loc": [72], "buggy_code_end_loc": [132], "fixing_code_start_loc": [72], "fixing_code_end_loc": [134], "type": "CWE-119", "message": "An issue was discovered in OpenSC through 0.19.0 and 0.20.x through 0.20.0-rc3. libopensc/card-cac1.c mishandles buffer limits for CAC certificates.", "other": {"cve": {"id": "CVE-2019-19481", "sourceIdentifier": "cve@mitre.org", "published": "2019-12-01T23:15:10.807", "lastModified": "2020-01-24T19:15:13.463", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "An issue was discovered in OpenSC through 0.19.0 and 0.20.x through 0.20.0-rc3. libopensc/card-cac1.c mishandles buffer limits for CAC certificates."}, {"lang": "es", "value": "Se detect\u00f3 un problema en OpenSC versiones hasta 0.19.0 y versiones 0.20.x hasta 0.20.0-rc3. El archivo libopensc/card-cac1.c maneja inapropiadamente los l\u00edmites del b\u00fafer para los certificados CAC."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:P/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "PHYSICAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 4.6, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:opensc_project:opensc:0.19.0:-:*:*:*:*:*:*", "matchCriteriaId": "17EB32E0-0F48-4DFB-990A-2B7B159B36E7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:opensc_project:opensc:0.20.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "B40AD56D-CA2A-41D0-A0B5-C5ACF6F21858"}, {"vulnerable": true, "criteria": "cpe:2.3:a:opensc_project:opensc:0.20.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "9C6258EA-E2DE-4AB0-BCF8-E4F550E80A4E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:opensc_project:opensc:0.20.0:rc3:*:*:*:*:*:*", "matchCriteriaId": "69C9C1EF-1A86-44CD-A147-5DEA86441FC2"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2019/12/29/1", "source": "cve@mitre.org", "tags": ["Mailing List"]}, {"url": "https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=18618", "source": "cve@mitre.org", "tags": ["Permissions Required", "Third Party Advisory"]}, {"url": "https://github.com/OpenSC/OpenSC/commit/b75c002cfb1fd61cd20ec938ff4937d7b1a94278", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/NDSQLMZZYBHO5X3BK7D6E7E6NZIMZDI5/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/OpenSC/OpenSC/commit/b75c002cfb1fd61cd20ec938ff4937d7b1a94278"}}