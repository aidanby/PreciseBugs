{"buggy_code": ["// SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)\n/* Copyright (C) 2018 Netronome Systems, Inc. */\n\n#include <linux/bitfield.h>\n#include <net/pkt_cls.h>\n\n#include \"../nfpcore/nfp_cpp.h\"\n#include \"../nfp_app.h\"\n#include \"../nfp_net_repr.h\"\n#include \"main.h\"\n\nstruct nfp_abm_u32_match {\n\tu32 handle;\n\tu32 band;\n\tu8 mask;\n\tu8 val;\n\tstruct list_head list;\n};\n\nstatic bool\nnfp_abm_u32_check_knode(struct nfp_abm *abm, struct tc_cls_u32_knode *knode,\n\t\t\t__be16 proto, struct netlink_ext_ack *extack)\n{\n\tstruct tc_u32_key *k;\n\tunsigned int tos_off;\n\n\tif (knode->exts && tcf_exts_has_actions(knode->exts)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"action offload not supported\");\n\t\treturn false;\n\t}\n\tif (knode->link_handle) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"linking not supported\");\n\t\treturn false;\n\t}\n\tif (knode->sel->flags != TC_U32_TERMINAL) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"flags must be equal to TC_U32_TERMINAL\");\n\t\treturn false;\n\t}\n\tif (knode->sel->off || knode->sel->offshift || knode->sel->offmask ||\n\t    knode->sel->offoff || knode->fshift) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"variable offsetting not supported\");\n\t\treturn false;\n\t}\n\tif (knode->sel->hoff || knode->sel->hmask) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"hashing not supported\");\n\t\treturn false;\n\t}\n\tif (knode->val || knode->mask) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"matching on mark not supported\");\n\t\treturn false;\n\t}\n\tif (knode->res && knode->res->class) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"setting non-0 class not supported\");\n\t\treturn false;\n\t}\n\tif (knode->res && knode->res->classid >= abm->num_bands) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"classid higher than number of bands\");\n\t\treturn false;\n\t}\n\tif (knode->sel->nkeys != 1) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"exactly one key required\");\n\t\treturn false;\n\t}\n\n\tswitch (proto) {\n\tcase htons(ETH_P_IP):\n\t\ttos_off = 16;\n\t\tbreak;\n\tcase htons(ETH_P_IPV6):\n\t\ttos_off = 20;\n\t\tbreak;\n\tdefault:\n\t\tNL_SET_ERR_MSG_MOD(extack, \"only IP and IPv6 supported as filter protocol\");\n\t\treturn false;\n\t}\n\n\tk = &knode->sel->keys[0];\n\tif (k->offmask) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"offset mask - variable offsetting not supported\");\n\t\treturn false;\n\t}\n\tif (k->off) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"only DSCP fields can be matched\");\n\t\treturn false;\n\t}\n\tif (k->val & ~k->mask) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"mask does not cover the key\");\n\t\treturn false;\n\t}\n\tif (be32_to_cpu(k->mask) >> tos_off & ~abm->dscp_mask) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"only high DSCP class selector bits can be used\");\n\t\tnfp_err(abm->app->cpp,\n\t\t\t\"u32 offload: requested mask %x FW can support only %x\\n\",\n\t\t\tbe32_to_cpu(k->mask) >> tos_off, abm->dscp_mask);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n/* This filter list -> map conversion is O(n * m), we expect single digit or\n * low double digit number of prios and likewise for the filters.  Also u32\n * doesn't report stats, so it's really only setup time cost.\n */\nstatic unsigned int\nnfp_abm_find_band_for_prio(struct nfp_abm_link *alink, unsigned int prio)\n{\n\tstruct nfp_abm_u32_match *iter;\n\n\tlist_for_each_entry(iter, &alink->dscp_map, list)\n\t\tif ((prio & iter->mask) == iter->val)\n\t\t\treturn iter->band;\n\n\treturn alink->def_band;\n}\n\nstatic int nfp_abm_update_band_map(struct nfp_abm_link *alink)\n{\n\tunsigned int i, bits_per_prio, prios_per_word, base_shift;\n\tstruct nfp_abm *abm = alink->abm;\n\tu32 field_mask;\n\n\talink->has_prio = !list_empty(&alink->dscp_map);\n\n\tbits_per_prio = roundup_pow_of_two(order_base_2(abm->num_bands));\n\tfield_mask = (1 << bits_per_prio) - 1;\n\tprios_per_word = sizeof(u32) * BITS_PER_BYTE / bits_per_prio;\n\n\t/* FW mask applies from top bits */\n\tbase_shift = 8 - order_base_2(abm->num_prios);\n\n\tfor (i = 0; i < abm->num_prios; i++) {\n\t\tunsigned int offset;\n\t\tu32 *word;\n\t\tu8 band;\n\n\t\tword = &alink->prio_map[i / prios_per_word];\n\t\toffset = (i % prios_per_word) * bits_per_prio;\n\n\t\tband = nfp_abm_find_band_for_prio(alink, i << base_shift);\n\n\t\t*word &= ~(field_mask << offset);\n\t\t*word |= band << offset;\n\t}\n\n\t/* Qdisc offload status may change if has_prio changed */\n\tnfp_abm_qdisc_offload_update(alink);\n\n\treturn nfp_abm_ctrl_prio_map_update(alink, alink->prio_map);\n}\n\nstatic void\nnfp_abm_u32_knode_delete(struct nfp_abm_link *alink,\n\t\t\t struct tc_cls_u32_knode *knode)\n{\n\tstruct nfp_abm_u32_match *iter;\n\n\tlist_for_each_entry(iter, &alink->dscp_map, list)\n\t\tif (iter->handle == knode->handle) {\n\t\t\tlist_del(&iter->list);\n\t\t\tkfree(iter);\n\t\t\tnfp_abm_update_band_map(alink);\n\t\t\treturn;\n\t\t}\n}\n\nstatic int\nnfp_abm_u32_knode_replace(struct nfp_abm_link *alink,\n\t\t\t  struct tc_cls_u32_knode *knode,\n\t\t\t  __be16 proto, struct netlink_ext_ack *extack)\n{\n\tstruct nfp_abm_u32_match *match = NULL, *iter;\n\tunsigned int tos_off;\n\tu8 mask, val;\n\tint err;\n\n\tif (!nfp_abm_u32_check_knode(alink->abm, knode, proto, extack))\n\t\tgoto err_delete;\n\n\ttos_off = proto == htons(ETH_P_IP) ? 16 : 20;\n\n\t/* Extract the DSCP Class Selector bits */\n\tval = be32_to_cpu(knode->sel->keys[0].val) >> tos_off & 0xff;\n\tmask = be32_to_cpu(knode->sel->keys[0].mask) >> tos_off & 0xff;\n\n\t/* Check if there is no conflicting mapping and find match by handle */\n\tlist_for_each_entry(iter, &alink->dscp_map, list) {\n\t\tu32 cmask;\n\n\t\tif (iter->handle == knode->handle) {\n\t\t\tmatch = iter;\n\t\t\tcontinue;\n\t\t}\n\n\t\tcmask = iter->mask & mask;\n\t\tif ((iter->val & cmask) == (val & cmask) &&\n\t\t    iter->band != knode->res->classid) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"conflict with already offloaded filter\");\n\t\t\tgoto err_delete;\n\t\t}\n\t}\n\n\tif (!match) {\n\t\tmatch = kzalloc(sizeof(*match), GFP_KERNEL);\n\t\tif (!match)\n\t\t\treturn -ENOMEM;\n\t\tlist_add(&match->list, &alink->dscp_map);\n\t}\n\tmatch->handle = knode->handle;\n\tmatch->band = knode->res->classid;\n\tmatch->mask = mask;\n\tmatch->val = val;\n\n\terr = nfp_abm_update_band_map(alink);\n\tif (err)\n\t\tgoto err_delete;\n\n\treturn 0;\n\nerr_delete:\n\tnfp_abm_u32_knode_delete(alink, knode);\n\treturn -EOPNOTSUPP;\n}\n\nstatic int nfp_abm_setup_tc_block_cb(enum tc_setup_type type,\n\t\t\t\t     void *type_data, void *cb_priv)\n{\n\tstruct tc_cls_u32_offload *cls_u32 = type_data;\n\tstruct nfp_repr *repr = cb_priv;\n\tstruct nfp_abm_link *alink;\n\n\talink = repr->app_priv;\n\n\tif (type != TC_SETUP_CLSU32) {\n\t\tNL_SET_ERR_MSG_MOD(cls_u32->common.extack,\n\t\t\t\t   \"only offload of u32 classifier supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\tif (!tc_cls_can_offload_and_chain0(repr->netdev, &cls_u32->common))\n\t\treturn -EOPNOTSUPP;\n\n\tif (cls_u32->common.protocol != htons(ETH_P_IP) &&\n\t    cls_u32->common.protocol != htons(ETH_P_IPV6)) {\n\t\tNL_SET_ERR_MSG_MOD(cls_u32->common.extack,\n\t\t\t\t   \"only IP and IPv6 supported as filter protocol\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tswitch (cls_u32->command) {\n\tcase TC_CLSU32_NEW_KNODE:\n\tcase TC_CLSU32_REPLACE_KNODE:\n\t\treturn nfp_abm_u32_knode_replace(alink, &cls_u32->knode,\n\t\t\t\t\t\t cls_u32->common.protocol,\n\t\t\t\t\t\t cls_u32->common.extack);\n\tcase TC_CLSU32_DELETE_KNODE:\n\t\tnfp_abm_u32_knode_delete(alink, &cls_u32->knode);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic LIST_HEAD(nfp_abm_block_cb_list);\n\nint nfp_abm_setup_cls_block(struct net_device *netdev, struct nfp_repr *repr,\n\t\t\t    struct flow_block_offload *f)\n{\n\treturn flow_block_cb_setup_simple(f, &nfp_abm_block_cb_list,\n\t\t\t\t\t  nfp_abm_setup_tc_block_cb,\n\t\t\t\t\t  repr, repr, true);\n}\n"], "fixing_code": ["// SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)\n/* Copyright (C) 2018 Netronome Systems, Inc. */\n\n#include <linux/bitfield.h>\n#include <net/pkt_cls.h>\n\n#include \"../nfpcore/nfp_cpp.h\"\n#include \"../nfp_app.h\"\n#include \"../nfp_net_repr.h\"\n#include \"main.h\"\n\nstruct nfp_abm_u32_match {\n\tu32 handle;\n\tu32 band;\n\tu8 mask;\n\tu8 val;\n\tstruct list_head list;\n};\n\nstatic bool\nnfp_abm_u32_check_knode(struct nfp_abm *abm, struct tc_cls_u32_knode *knode,\n\t\t\t__be16 proto, struct netlink_ext_ack *extack)\n{\n\tstruct tc_u32_key *k;\n\tunsigned int tos_off;\n\n\tif (knode->exts && tcf_exts_has_actions(knode->exts)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"action offload not supported\");\n\t\treturn false;\n\t}\n\tif (knode->link_handle) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"linking not supported\");\n\t\treturn false;\n\t}\n\tif (knode->sel->flags != TC_U32_TERMINAL) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"flags must be equal to TC_U32_TERMINAL\");\n\t\treturn false;\n\t}\n\tif (knode->sel->off || knode->sel->offshift || knode->sel->offmask ||\n\t    knode->sel->offoff || knode->fshift) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"variable offsetting not supported\");\n\t\treturn false;\n\t}\n\tif (knode->sel->hoff || knode->sel->hmask) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"hashing not supported\");\n\t\treturn false;\n\t}\n\tif (knode->val || knode->mask) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"matching on mark not supported\");\n\t\treturn false;\n\t}\n\tif (knode->res && knode->res->class) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"setting non-0 class not supported\");\n\t\treturn false;\n\t}\n\tif (knode->res && knode->res->classid >= abm->num_bands) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"classid higher than number of bands\");\n\t\treturn false;\n\t}\n\tif (knode->sel->nkeys != 1) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"exactly one key required\");\n\t\treturn false;\n\t}\n\n\tswitch (proto) {\n\tcase htons(ETH_P_IP):\n\t\ttos_off = 16;\n\t\tbreak;\n\tcase htons(ETH_P_IPV6):\n\t\ttos_off = 20;\n\t\tbreak;\n\tdefault:\n\t\tNL_SET_ERR_MSG_MOD(extack, \"only IP and IPv6 supported as filter protocol\");\n\t\treturn false;\n\t}\n\n\tk = &knode->sel->keys[0];\n\tif (k->offmask) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"offset mask - variable offsetting not supported\");\n\t\treturn false;\n\t}\n\tif (k->off) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"only DSCP fields can be matched\");\n\t\treturn false;\n\t}\n\tif (k->val & ~k->mask) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"mask does not cover the key\");\n\t\treturn false;\n\t}\n\tif (be32_to_cpu(k->mask) >> tos_off & ~abm->dscp_mask) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"only high DSCP class selector bits can be used\");\n\t\tnfp_err(abm->app->cpp,\n\t\t\t\"u32 offload: requested mask %x FW can support only %x\\n\",\n\t\t\tbe32_to_cpu(k->mask) >> tos_off, abm->dscp_mask);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n/* This filter list -> map conversion is O(n * m), we expect single digit or\n * low double digit number of prios and likewise for the filters.  Also u32\n * doesn't report stats, so it's really only setup time cost.\n */\nstatic unsigned int\nnfp_abm_find_band_for_prio(struct nfp_abm_link *alink, unsigned int prio)\n{\n\tstruct nfp_abm_u32_match *iter;\n\n\tlist_for_each_entry(iter, &alink->dscp_map, list)\n\t\tif ((prio & iter->mask) == iter->val)\n\t\t\treturn iter->band;\n\n\treturn alink->def_band;\n}\n\nstatic int nfp_abm_update_band_map(struct nfp_abm_link *alink)\n{\n\tunsigned int i, bits_per_prio, prios_per_word, base_shift;\n\tstruct nfp_abm *abm = alink->abm;\n\tu32 field_mask;\n\n\talink->has_prio = !list_empty(&alink->dscp_map);\n\n\tbits_per_prio = roundup_pow_of_two(order_base_2(abm->num_bands));\n\tfield_mask = (1 << bits_per_prio) - 1;\n\tprios_per_word = sizeof(u32) * BITS_PER_BYTE / bits_per_prio;\n\n\t/* FW mask applies from top bits */\n\tbase_shift = 8 - order_base_2(abm->num_prios);\n\n\tfor (i = 0; i < abm->num_prios; i++) {\n\t\tunsigned int offset;\n\t\tu32 *word;\n\t\tu8 band;\n\n\t\tword = &alink->prio_map[i / prios_per_word];\n\t\toffset = (i % prios_per_word) * bits_per_prio;\n\n\t\tband = nfp_abm_find_band_for_prio(alink, i << base_shift);\n\n\t\t*word &= ~(field_mask << offset);\n\t\t*word |= band << offset;\n\t}\n\n\t/* Qdisc offload status may change if has_prio changed */\n\tnfp_abm_qdisc_offload_update(alink);\n\n\treturn nfp_abm_ctrl_prio_map_update(alink, alink->prio_map);\n}\n\nstatic void\nnfp_abm_u32_knode_delete(struct nfp_abm_link *alink,\n\t\t\t struct tc_cls_u32_knode *knode)\n{\n\tstruct nfp_abm_u32_match *iter;\n\n\tlist_for_each_entry(iter, &alink->dscp_map, list)\n\t\tif (iter->handle == knode->handle) {\n\t\t\tlist_del(&iter->list);\n\t\t\tkfree(iter);\n\t\t\tnfp_abm_update_band_map(alink);\n\t\t\treturn;\n\t\t}\n}\n\nstatic int\nnfp_abm_u32_knode_replace(struct nfp_abm_link *alink,\n\t\t\t  struct tc_cls_u32_knode *knode,\n\t\t\t  __be16 proto, struct netlink_ext_ack *extack)\n{\n\tstruct nfp_abm_u32_match *match = NULL, *iter;\n\tunsigned int tos_off;\n\tu8 mask, val;\n\tint err;\n\n\tif (!nfp_abm_u32_check_knode(alink->abm, knode, proto, extack)) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto err_delete;\n\t}\n\n\ttos_off = proto == htons(ETH_P_IP) ? 16 : 20;\n\n\t/* Extract the DSCP Class Selector bits */\n\tval = be32_to_cpu(knode->sel->keys[0].val) >> tos_off & 0xff;\n\tmask = be32_to_cpu(knode->sel->keys[0].mask) >> tos_off & 0xff;\n\n\t/* Check if there is no conflicting mapping and find match by handle */\n\tlist_for_each_entry(iter, &alink->dscp_map, list) {\n\t\tu32 cmask;\n\n\t\tif (iter->handle == knode->handle) {\n\t\t\tmatch = iter;\n\t\t\tcontinue;\n\t\t}\n\n\t\tcmask = iter->mask & mask;\n\t\tif ((iter->val & cmask) == (val & cmask) &&\n\t\t    iter->band != knode->res->classid) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"conflict with already offloaded filter\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto err_delete;\n\t\t}\n\t}\n\n\tif (!match) {\n\t\tmatch = kzalloc(sizeof(*match), GFP_KERNEL);\n\t\tif (!match) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_delete;\n\t\t}\n\n\t\tlist_add(&match->list, &alink->dscp_map);\n\t}\n\tmatch->handle = knode->handle;\n\tmatch->band = knode->res->classid;\n\tmatch->mask = mask;\n\tmatch->val = val;\n\n\terr = nfp_abm_update_band_map(alink);\n\tif (err)\n\t\tgoto err_delete;\n\n\treturn 0;\n\nerr_delete:\n\tnfp_abm_u32_knode_delete(alink, knode);\n\treturn err;\n}\n\nstatic int nfp_abm_setup_tc_block_cb(enum tc_setup_type type,\n\t\t\t\t     void *type_data, void *cb_priv)\n{\n\tstruct tc_cls_u32_offload *cls_u32 = type_data;\n\tstruct nfp_repr *repr = cb_priv;\n\tstruct nfp_abm_link *alink;\n\n\talink = repr->app_priv;\n\n\tif (type != TC_SETUP_CLSU32) {\n\t\tNL_SET_ERR_MSG_MOD(cls_u32->common.extack,\n\t\t\t\t   \"only offload of u32 classifier supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\tif (!tc_cls_can_offload_and_chain0(repr->netdev, &cls_u32->common))\n\t\treturn -EOPNOTSUPP;\n\n\tif (cls_u32->common.protocol != htons(ETH_P_IP) &&\n\t    cls_u32->common.protocol != htons(ETH_P_IPV6)) {\n\t\tNL_SET_ERR_MSG_MOD(cls_u32->common.extack,\n\t\t\t\t   \"only IP and IPv6 supported as filter protocol\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tswitch (cls_u32->command) {\n\tcase TC_CLSU32_NEW_KNODE:\n\tcase TC_CLSU32_REPLACE_KNODE:\n\t\treturn nfp_abm_u32_knode_replace(alink, &cls_u32->knode,\n\t\t\t\t\t\t cls_u32->common.protocol,\n\t\t\t\t\t\t cls_u32->common.extack);\n\tcase TC_CLSU32_DELETE_KNODE:\n\t\tnfp_abm_u32_knode_delete(alink, &cls_u32->knode);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic LIST_HEAD(nfp_abm_block_cb_list);\n\nint nfp_abm_setup_cls_block(struct net_device *netdev, struct nfp_repr *repr,\n\t\t\t    struct flow_block_offload *f)\n{\n\treturn flow_block_cb_setup_simple(f, &nfp_abm_block_cb_list,\n\t\t\t\t\t  nfp_abm_setup_tc_block_cb,\n\t\t\t\t\t  repr, repr, true);\n}\n"], "filenames": ["drivers/net/ethernet/netronome/nfp/abm/cls.c"], "buggy_code_start_loc": [179], "buggy_code_end_loc": [225], "fixing_code_start_loc": [179], "fixing_code_end_loc": [231], "type": "CWE-401", "message": "** DISPUTED ** A memory leak in the nfp_abm_u32_knode_replace() function in drivers/net/ethernet/netronome/nfp/abm/cls.c in the Linux kernel before 5.3.6 allows attackers to cause a denial of service (memory consumption), aka CID-78beef629fd9. NOTE: This has been argued as not a valid vulnerability. The upstream commit 78beef629fd9 was reverted.", "other": {"cve": {"id": "CVE-2019-19076", "sourceIdentifier": "cve@mitre.org", "published": "2019-11-18T06:15:13.420", "lastModified": "2020-08-24T17:37:01.140", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "** DISPUTED ** A memory leak in the nfp_abm_u32_knode_replace() function in drivers/net/ethernet/netronome/nfp/abm/cls.c in the Linux kernel before 5.3.6 allows attackers to cause a denial of service (memory consumption), aka CID-78beef629fd9. NOTE: This has been argued as not a valid vulnerability. The upstream commit 78beef629fd9 was reverted."}, {"lang": "es", "value": "** EN DISPUTA ** Una p\u00e9rdida de memoria en la funci\u00f3n nfp_abm_u32_knode_replace () en drivers / net / ethernet / netronome / nfp / abm / cls.c en el kernel de Linux antes de 5.3.6 permite a los atacantes causar una denegaci\u00f3n de servicio (consumo de memoria) , tambi\u00e9n conocido como CID-78beef629fd9. NOTA: Esto se ha discutido como una vulnerabilidad no v\u00e1lida. El commit upstream 78beef629fd9 fue revertido."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:C", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 7.1}, "baseSeverity": "HIGH", "exploitabilityScore": 8.6, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-401"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.3.6", "matchCriteriaId": "68E520D4-4BF9-40CB-94CE-E87D9B30A255"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.04:*:*:*:*:*:*:*", "matchCriteriaId": "CD783B0C-9246-47D9-A937-6144FE8BFF0F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "F4CFF558-3C47-480D-A2F0-BABF26042943"}]}]}], "references": [{"url": "https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.3.6", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://git.kernel.org/linus/1d1997db870f4058676439ef7014390ba9e24eb2", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/78beef629fd95be4ed853b2d37b832f766bd96ca", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lore.kernel.org/lkml/20191204103955.63c4d9af@cakuba.netronome.com/", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20191205-0001/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4209-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/78beef629fd95be4ed853b2d37b832f766bd96ca"}}