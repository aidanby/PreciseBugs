{"buggy_code": ["// Sandstorm - Personal Cloud Sandbox\n// Copyright (c) 2015 Sandstorm Development Group, Inc. and contributors\n// All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#include \"backup.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <kj/debug.h>\n#include <sched.h>\n#include <sys/mount.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/capability.h>\n\n// In case kernel headers are old.\n#ifndef PR_SET_NO_NEW_PRIVS\n#define PR_SET_NO_NEW_PRIVS 38\n#endif\n\nnamespace sandstorm {\n\nBackupMain::BackupMain(kj::ProcessContext& context): context(context) {}\n\nkj::MainFunc BackupMain::getMain() {\n  return kj::MainBuilder(context, \"Sandstorm version \" SANDSTORM_VERSION,\n                         \"Backs up the grain directory in <grain> to <file>, reading the grain \"\n                         \"metadata struct on stdin. Or, restores the backup in <file>, \"\n                         \"unpacking it to <grain>, and writing the metadata to stdout. In \"\n                         \"backup mode, <file> can be `-` to write the data to stdout.\")\n      .addOptionWithArg({\"uid\"}, KJ_BIND_METHOD(*this, setUid), \"<uid>\",\n                        \"Use setuid sandbox rather than userns. Must start as root, but swiches \"\n                        \"to <uid> to run the app.\")\n      .addOption({'r', \"restore\"}, KJ_BIND_METHOD(*this, setRestore),\n                 \"Restore a backup, rather than create a backup.\")\n      .addOptionWithArg({\"root\"}, KJ_BIND_METHOD(*this, setRoot), \"<root>\",\n                 \"Set the \\\"root directory\\\" to map in, which contains the zip/unzip binaries.\")\n      .expectArg(\"<file>\", KJ_BIND_METHOD(*this, setFile))\n      .expectArg(\"<grain>\", KJ_BIND_METHOD(*this, run))\n      .build();\n}\n\nbool BackupMain::setRestore() {\n  restore = true;\n  return true;\n}\n\nbool BackupMain::setFile(kj::StringPtr arg) {\n  filename = arg;\n  return true;\n}\n\nbool BackupMain::setRoot(kj::StringPtr arg) {\n  root = arg;\n  return true;\n}\n\nbool BackupMain::setUid(kj::StringPtr arg) {\n  KJ_IF_MAYBE(u, parseUInt(arg, 10)) {\n    if (getuid() != 0) {\n      return false;\n    }\n    if (*u == 0) {\n      return false;\n    }\n    KJ_SYSCALL(seteuid(*u));\n    sandboxUid = *u;\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid BackupMain::writeSetgroupsIfPresent(const char *contents) {\n  KJ_IF_MAYBE(fd, raiiOpenIfExists(\"/proc/self/setgroups\", O_WRONLY | O_CLOEXEC)) {\n    kj::FdOutputStream(kj::mv(*fd)).write(contents, strlen(contents));\n  }\n}\n\nvoid BackupMain::writeUserNSMap(const char *type, kj::StringPtr contents) {\n  kj::FdOutputStream(raiiOpen(kj::str(\"/proc/self/\", type, \"_map\").cStr(), O_WRONLY | O_CLOEXEC))\n      .write(contents.begin(), contents.size());\n}\n\nvoid BackupMain::bind(kj::StringPtr src, kj::StringPtr dst, unsigned long flags) {\n  // Contrary to the documentation of MS_BIND claiming this is no longer the case after 2.6.26,\n  // mountflags are ignored on the initial bind.  We have to issue a subsequent remount to set\n  // them.\n  KJ_SYSCALL(mount(src.cStr(), dst.cStr(), nullptr, MS_BIND | MS_REC, nullptr), src, dst);\n  KJ_SYSCALL(mount(src.cStr(), dst.cStr(), nullptr,\n                   MS_BIND | MS_REC | MS_REMOUNT | flags, nullptr),\n      src, dst);\n}\n\nbool BackupMain::run(kj::StringPtr grainDir) {\n  // Enable no_new_privs so that once we drop privileges we can never regain them through e.g.\n  // execing a suid-root binary, as a backup measure. This is a backup measure in case someone\n  // finds an arbitrary code execution exploit in zip/unzip; it's not needed otherwise.\n  KJ_SYSCALL(prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0));\n\n  // Create files / directories before we potentially change the UID, so that they are created\n  // with the right owner.\n  if (restore) {\n    KJ_SYSCALL(mkdir(kj::str(grainDir, \"/sandbox\").cStr(), 0770));\n  } else if (filename != \"-\") {\n    // Instead of binding into mount tree later, just open the file and we'll compress to stdout.\n    KJ_SYSCALL(dup2(raiiOpen(filename, O_WRONLY | O_CREAT | O_TRUNC | O_CLOEXEC), STDOUT_FILENO));\n  }\n\n  if (sandboxUid == nullptr) {\n    uid_t uid = getuid();\n    gid_t gid = getgid();\n\n    KJ_SYSCALL(unshare(CLONE_NEWUSER | CLONE_NEWNS |\n        // Unshare other stuff; like no_new_privs, this is only to defend against hypothetical\n        // arbitrary code execution bugs in zip/unzip.\n        CLONE_NEWNET | CLONE_NEWIPC | CLONE_NEWPID | CLONE_NEWUTS));\n    writeSetgroupsIfPresent(\"deny\\n\");\n    writeUserNSMap(\"uid\", kj::str(\"1000 \", uid, \" 1\\n\"));\n    writeUserNSMap(\"gid\", kj::str(\"1000 \", gid, \" 1\\n\"));\n  } else {\n    KJ_SYSCALL(seteuid(0));\n    KJ_SYSCALL(unshare(CLONE_NEWNS |\n        // Unshare other stuff; like no_new_privs, this is only to defend against hypothetical\n        // arbitrary code execution bugs in zip/unzip.\n        CLONE_NEWNET | CLONE_NEWIPC | CLONE_NEWPID | CLONE_NEWUTS));\n  }\n\n  // To really unshare the mount namespace, we also have to make sure all mounts are private.\n  // The parameters here were derived by strace'ing `mount --make-rprivate /`.  AFAICT the flags\n  // are undocumented.  :(\n  KJ_SYSCALL(mount(\"none\", \"/\", nullptr, MS_REC | MS_PRIVATE, nullptr));\n\n  // Mount root read-only.\n  bind(kj::str(root, \"/\"), \"/tmp\", MS_BIND | MS_NOSUID | MS_RDONLY);\n\n  if (access(\"/tmp/dev/null\", F_OK) != 0) {\n    // Looks like we need to bind in /dev.\n    KJ_SYSCALL(mount(\"/dev\", \"/tmp/dev\", nullptr, MS_BIND, nullptr));\n  }\n\n  // Hide sensitive directories.\n  KJ_SYSCALL(mount(\"tmpfs\", \"/tmp/proc\", \"tmpfs\", 0, \"size=32k,nr_inodes=8,mode=000\"));\n  KJ_SYSCALL(mount(\"tmpfs\", \"/tmp/var\", \"tmpfs\", 0, \"size=32k,nr_inodes=8,mode=000\"));\n  KJ_SYSCALL(mount(\"tmpfs\", \"/tmp/etc\", \"tmpfs\", 0, \"size=32k,nr_inodes=8,mode=000\"));\n\n  // Mount inner tmpfs.\n  KJ_SYSCALL(mount(\"tmpfs\", \"/tmp/tmp\", \"tmpfs\", 0, \"size=8m,nr_inodes=128,mode=777\"));\n\n  // Bind in the grain's `data` (=`sandbox`).\n  KJ_SYSCALL(mkdir(\"/tmp/tmp/data\", 0777));\n  bind(kj::str(grainDir, \"/sandbox\"), \"/tmp/tmp/data\",\n       MS_NODEV | MS_NOSUID | MS_NOEXEC | (restore ? 0 : MS_RDONLY));\n\n  // Bind in the grain's `log`. When restoring, we discard the log.\n  if (!restore) {\n    KJ_SYSCALL(mknod(\"/tmp/tmp/log\", S_IFREG | 0666, 0));\n    bind(kj::str(grainDir, \"/log\"), \"/tmp/tmp/log\", MS_RDONLY | MS_NOEXEC | MS_NOSUID | MS_NODEV);\n  }\n\n  // Bind in the file.\n  if (restore) {\n    KJ_SYSCALL(mknod(\"/tmp/tmp/file.zip\", S_IFREG | 0666, 0));\n    KJ_SYSCALL(mount(filename.cStr(), \"/tmp/tmp/file.zip\", nullptr, MS_BIND, nullptr));\n  }\n\n  // Use Andy's ridiculous pivot_root trick to place ourselves into the sandbox.\n  // See supervisor-main.c++ for more discussion.\n  {\n    auto oldRootDir = raiiOpen(\"/\", O_RDONLY | O_DIRECTORY | O_CLOEXEC);\n    KJ_SYSCALL(syscall(SYS_pivot_root, \"/tmp\", \"/tmp\"));\n    KJ_SYSCALL(fchdir(oldRootDir));\n    KJ_SYSCALL(umount2(\".\", MNT_DETACH));\n    KJ_SYSCALL(chdir(\"/tmp\"));\n  }\n\n  KJ_IF_MAYBE(u, sandboxUid) {\n    KJ_SYSCALL(setresuid(*u, *u, *u));\n  }\n\n  // TODO(security): We could seccomp this pretty tightly, but that would only be necessary to\n  //   defend against *both* zip/unzip *and* the Linux kernel having bugs at the same time. It's\n  //   fairly involved to set up, so maybe not worthwhile, unless we could factor the code out of\n  //   supervisor.c++...\n\n  if (!restore) {\n    // Read stdin to metadata file.\n    kj::FdInputStream in(STDIN_FILENO);\n    kj::FdOutputStream out(raiiOpen(\"metadata\", O_WRONLY | O_CREAT | O_EXCL | O_CLOEXEC));\n    pump(in, out);\n  }\n\n  {\n    // Drop crapabilities.\n    struct __user_cap_header_struct hdr;\n    struct __user_cap_data_struct data[2];\n    hdr.version = _LINUX_CAPABILITY_VERSION_3;\n    hdr.pid = 0;\n    memset(data, 0, sizeof(data));  // All capabilities disabled!\n    KJ_SYSCALL(capset(&hdr, data));\n    umask(0007);\n  }\n\n  // TODO(someday): Find a zip library that doesn't suck and use it instead of shelling out\n  //   to zip/unzip.\n  if (restore) {\n    Subprocess({\"unzip\", \"-q\", \"file.zip\", \"data/*\", \"metadata\"}).waitForSuccess();\n\n    // Read metadata file to stdout.\n    kj::FdInputStream in(raiiOpen(\"metadata\", O_RDONLY | O_CLOEXEC));\n    kj::FdOutputStream out(STDOUT_FILENO);\n    pump(in, out);\n  } else {\n    Subprocess::Options zipOptions({\"zip\", \"-qy@\", \"-\"});\n    auto inPipe = Pipe::make();\n    zipOptions.stdin = inPipe.readEnd;\n    Subprocess zip(kj::mv(zipOptions));\n    inPipe.readEnd = nullptr;\n\n    {\n      kj::FdOutputStream out(kj::mv(inPipe.writeEnd));\n      for (auto& entry: listDirectory(\".\")) {\n        findFilesToZip(entry, out);\n      }\n    }\n\n    zip.waitForSuccess();\n  }\n\n  return true;\n}\n\nvoid BackupMain::pump(kj::InputStream& in, kj::OutputStream& out) {\n  byte buffer[4096];\n  while (size_t n = in.tryRead(buffer, 1, sizeof(buffer))) {\n    out.write(buffer, n);\n  }\n}\n\nbool BackupMain::findFilesToZip(kj::StringPtr path, kj::OutputStream& out) {\n  struct stat stats;\n  KJ_SYSCALL(lstat(path.cStr(), &stats));\n  if (S_ISREG(stats.st_mode) || S_ISLNK(stats.st_mode)) {\n    // Regular file or link can be zipped; write to file stream.\n    // If the path contains a newline, we cannot correctly pass it to `zip` since `zip` expects\n    // one file per line. For security reasons, we must detect and filter out these files.\n    // Hopefully this never happens legitimately?\n    if (path.findFirst('\\n') == nullptr) {\n      kj::ArrayPtr<const byte> pieces[2];\n      pieces[0] = path.asBytes();\n      pieces[1] = kj::StringPtr(\"\\n\").asBytes();\n      out.write(pieces);\n      return true;\n    } else {\n      KJ_LOG(ERROR, \"tried to backup file containing newlines\", path);\n      return false;\n    }\n  } else if (S_ISDIR(stats.st_mode)) {\n    // Subdirectory; enumerate contents.\n    bool packedAny = false;\n    for (auto& entry: listDirectory(path)) {\n      if (findFilesToZip(kj::str(path, '/', entry), out)) {\n        packedAny = true;\n      }\n    }\n\n    if (!packedAny) {\n      // Empty directory. Need to make sure it gets into the zip.\n      kj::ArrayPtr<const byte> pieces[2];\n      pieces[0] = path.asBytes();\n      pieces[1] = kj::StringPtr(\"\\n\").asBytes();\n      out.write(pieces);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\n} // namespace sandstorm\n\n"], "fixing_code": ["// Sandstorm - Personal Cloud Sandbox\n// Copyright (c) 2015 Sandstorm Development Group, Inc. and contributors\n// All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#include \"backup.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include <kj/debug.h>\n#include <sched.h>\n#include <sys/mount.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/capability.h>\n\n// In case kernel headers are old.\n#ifndef PR_SET_NO_NEW_PRIVS\n#define PR_SET_NO_NEW_PRIVS 38\n#endif\n\nnamespace sandstorm {\n\nBackupMain::BackupMain(kj::ProcessContext& context): context(context) {}\n\nkj::MainFunc BackupMain::getMain() {\n  return kj::MainBuilder(context, \"Sandstorm version \" SANDSTORM_VERSION,\n                         \"Backs up the grain directory in <grain> to <file>, reading the grain \"\n                         \"metadata struct on stdin. Or, restores the backup in <file>, \"\n                         \"unpacking it to <grain>, and writing the metadata to stdout. In \"\n                         \"backup mode, <file> can be `-` to write the data to stdout.\")\n      .addOptionWithArg({\"uid\"}, KJ_BIND_METHOD(*this, setUid), \"<uid>\",\n                        \"Use setuid sandbox rather than userns. Must start as root, but swiches \"\n                        \"to <uid> to run the app.\")\n      .addOption({'r', \"restore\"}, KJ_BIND_METHOD(*this, setRestore),\n                 \"Restore a backup, rather than create a backup.\")\n      .addOptionWithArg({\"root\"}, KJ_BIND_METHOD(*this, setRoot), \"<root>\",\n                 \"Set the \\\"root directory\\\" to map in, which contains the zip/unzip binaries.\")\n      .expectArg(\"<file>\", KJ_BIND_METHOD(*this, setFile))\n      .expectArg(\"<grain>\", KJ_BIND_METHOD(*this, run))\n      .build();\n}\n\nbool BackupMain::setRestore() {\n  restore = true;\n  return true;\n}\n\nbool BackupMain::setFile(kj::StringPtr arg) {\n  filename = arg;\n  return true;\n}\n\nbool BackupMain::setRoot(kj::StringPtr arg) {\n  root = arg;\n  return true;\n}\n\nbool BackupMain::setUid(kj::StringPtr arg) {\n  KJ_IF_MAYBE(u, parseUInt(arg, 10)) {\n    if (getuid() != 0) {\n      return false;\n    }\n    if (*u == 0) {\n      return false;\n    }\n    KJ_SYSCALL(seteuid(*u));\n    sandboxUid = *u;\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid BackupMain::writeSetgroupsIfPresent(const char *contents) {\n  KJ_IF_MAYBE(fd, raiiOpenIfExists(\"/proc/self/setgroups\", O_WRONLY | O_CLOEXEC)) {\n    kj::FdOutputStream(kj::mv(*fd)).write(contents, strlen(contents));\n  }\n}\n\nvoid BackupMain::writeUserNSMap(const char *type, kj::StringPtr contents) {\n  kj::FdOutputStream(raiiOpen(kj::str(\"/proc/self/\", type, \"_map\").cStr(), O_WRONLY | O_CLOEXEC))\n      .write(contents.begin(), contents.size());\n}\n\nvoid BackupMain::bind(kj::StringPtr src, kj::StringPtr dst, unsigned long flags) {\n  // Contrary to the documentation of MS_BIND claiming this is no longer the case after 2.6.26,\n  // mountflags are ignored on the initial bind.  We have to issue a subsequent remount to set\n  // them.\n  KJ_SYSCALL(mount(src.cStr(), dst.cStr(), nullptr, MS_BIND | MS_REC, nullptr), src, dst);\n  KJ_SYSCALL(mount(src.cStr(), dst.cStr(), nullptr,\n                   MS_BIND | MS_REC | MS_REMOUNT | flags, nullptr),\n      src, dst);\n}\n\nbool BackupMain::run(kj::StringPtr grainDir) {\n  // Enable no_new_privs so that once we drop privileges we can never regain them through e.g.\n  // execing a suid-root binary, as a backup measure. This is a backup measure in case someone\n  // finds an arbitrary code execution exploit in zip/unzip; it's not needed otherwise.\n  KJ_SYSCALL(prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0));\n\n  // Create files / directories before we potentially change the UID, so that they are created\n  // with the right owner.\n  if (restore) {\n    KJ_SYSCALL(mkdir(kj::str(grainDir, \"/sandbox\").cStr(), 0770));\n  } else if (filename != \"-\") {\n    // Instead of binding into mount tree later, just open the file and we'll compress to stdout.\n    KJ_SYSCALL(dup2(raiiOpen(filename, O_WRONLY | O_CREAT | O_TRUNC | O_CLOEXEC), STDOUT_FILENO));\n  }\n\n  if (sandboxUid == nullptr) {\n    uid_t uid = getuid();\n    gid_t gid = getgid();\n\n    KJ_SYSCALL(unshare(CLONE_NEWUSER | CLONE_NEWNS |\n        // Unshare other stuff; like no_new_privs, this is only to defend against hypothetical\n        // arbitrary code execution bugs in zip/unzip.\n        CLONE_NEWNET | CLONE_NEWIPC | CLONE_NEWPID | CLONE_NEWUTS));\n    writeSetgroupsIfPresent(\"deny\\n\");\n    writeUserNSMap(\"uid\", kj::str(\"1000 \", uid, \" 1\\n\"));\n    writeUserNSMap(\"gid\", kj::str(\"1000 \", gid, \" 1\\n\"));\n  } else {\n    KJ_SYSCALL(seteuid(0));\n    KJ_SYSCALL(unshare(CLONE_NEWNS |\n        // Unshare other stuff; like no_new_privs, this is only to defend against hypothetical\n        // arbitrary code execution bugs in zip/unzip.\n        CLONE_NEWNET | CLONE_NEWIPC | CLONE_NEWPID | CLONE_NEWUTS));\n  }\n\n  // To really unshare the mount namespace, we also have to make sure all mounts are private.\n  // The parameters here were derived by strace'ing `mount --make-rprivate /`.  AFAICT the flags\n  // are undocumented.  :(\n  KJ_SYSCALL(mount(\"none\", \"/\", nullptr, MS_REC | MS_PRIVATE, nullptr));\n\n  // Create tmpfs root to whitelist directories that we want to bind in.\n  KJ_SYSCALL(mount(\"tmpfs\", \"/tmp\", \"tmpfs\", 0, \"size=8m,nr_inodes=128,mode=755\"));\n\n  // Bind in whitelisted directories.\n  const char* WHITELIST[] = { \"dev\", \"bin\", \"lib\", \"lib64\", \"usr\" };\n  for (const char* dir: WHITELIST) {\n    auto src = kj::str(root, \"/\", dir);\n    auto dst = kj::str(\"/tmp/\", dir);\n    if (access(src.cStr(), F_OK) == 0) {\n      KJ_SYSCALL(mkdir(dst.cStr(), 0755));\n      bind(src, dst, MS_BIND | MS_NOSUID | MS_RDONLY);\n    }\n  }\n\n  // Make sandboxed /tmp.\n  KJ_SYSCALL(mkdir(\"/tmp/tmp\", 0777));\n\n  // Bind in the grain's `data` (=`sandbox`).\n  KJ_SYSCALL(mkdir(\"/tmp/tmp/data\", 0777));\n  bind(kj::str(grainDir, \"/sandbox\"), \"/tmp/tmp/data\",\n       MS_NODEV | MS_NOSUID | MS_NOEXEC | (restore ? 0 : MS_RDONLY));\n\n  // Bind in the grain's `log`. When restoring, we discard the log.\n  if (!restore) {\n    KJ_SYSCALL(mknod(\"/tmp/tmp/log\", S_IFREG | 0666, 0));\n    bind(kj::str(grainDir, \"/log\"), \"/tmp/tmp/log\", MS_RDONLY | MS_NOEXEC | MS_NOSUID | MS_NODEV);\n  }\n\n  // Bind in the file.\n  if (restore) {\n    KJ_SYSCALL(mknod(\"/tmp/tmp/file.zip\", S_IFREG | 0666, 0));\n    KJ_SYSCALL(mount(filename.cStr(), \"/tmp/tmp/file.zip\", nullptr, MS_BIND, nullptr));\n  }\n\n  // Use Andy's ridiculous pivot_root trick to place ourselves into the sandbox.\n  // See supervisor-main.c++ for more discussion.\n  {\n    auto oldRootDir = raiiOpen(\"/\", O_RDONLY | O_DIRECTORY | O_CLOEXEC);\n    KJ_SYSCALL(syscall(SYS_pivot_root, \"/tmp\", \"/tmp\"));\n    KJ_SYSCALL(fchdir(oldRootDir));\n    KJ_SYSCALL(umount2(\".\", MNT_DETACH));\n    KJ_SYSCALL(chdir(\"/tmp\"));\n  }\n\n  KJ_IF_MAYBE(u, sandboxUid) {\n    KJ_SYSCALL(setresuid(*u, *u, *u));\n  }\n\n  // TODO(security): We could seccomp this pretty tightly, but that would only be necessary to\n  //   defend against *both* zip/unzip *and* the Linux kernel having bugs at the same time. It's\n  //   fairly involved to set up, so maybe not worthwhile, unless we could factor the code out of\n  //   supervisor.c++...\n\n  if (!restore) {\n    // Read stdin to metadata file.\n    kj::FdInputStream in(STDIN_FILENO);\n    kj::FdOutputStream out(raiiOpen(\"metadata\", O_WRONLY | O_CREAT | O_EXCL | O_CLOEXEC));\n    pump(in, out);\n  }\n\n  {\n    // Drop crapabilities.\n    struct __user_cap_header_struct hdr;\n    struct __user_cap_data_struct data[2];\n    hdr.version = _LINUX_CAPABILITY_VERSION_3;\n    hdr.pid = 0;\n    memset(data, 0, sizeof(data));  // All capabilities disabled!\n    KJ_SYSCALL(capset(&hdr, data));\n    umask(0007);\n  }\n\n  // TODO(someday): Find a zip library that doesn't suck and use it instead of shelling out\n  //   to zip/unzip.\n  if (restore) {\n    Subprocess({\"unzip\", \"-q\", \"file.zip\", \"data/*\", \"metadata\"}).waitForSuccess();\n\n    // Read metadata file to stdout.\n    kj::FdInputStream in(raiiOpen(\"metadata\", O_RDONLY | O_CLOEXEC));\n    kj::FdOutputStream out(STDOUT_FILENO);\n    pump(in, out);\n  } else {\n    Subprocess::Options zipOptions({\"zip\", \"-qy@\", \"-\"});\n    auto inPipe = Pipe::make();\n    zipOptions.stdin = inPipe.readEnd;\n    Subprocess zip(kj::mv(zipOptions));\n    inPipe.readEnd = nullptr;\n\n    {\n      kj::FdOutputStream out(kj::mv(inPipe.writeEnd));\n      for (auto& entry: listDirectory(\".\")) {\n        findFilesToZip(entry, out);\n      }\n    }\n\n    zip.waitForSuccess();\n  }\n\n  return true;\n}\n\nvoid BackupMain::pump(kj::InputStream& in, kj::OutputStream& out) {\n  byte buffer[4096];\n  while (size_t n = in.tryRead(buffer, 1, sizeof(buffer))) {\n    out.write(buffer, n);\n  }\n}\n\nbool BackupMain::findFilesToZip(kj::StringPtr path, kj::OutputStream& out) {\n  struct stat stats;\n  KJ_SYSCALL(lstat(path.cStr(), &stats));\n  if (S_ISREG(stats.st_mode) || S_ISLNK(stats.st_mode)) {\n    // Regular file or link can be zipped; write to file stream.\n    // If the path contains a newline, we cannot correctly pass it to `zip` since `zip` expects\n    // one file per line. For security reasons, we must detect and filter out these files.\n    // Hopefully this never happens legitimately?\n    if (path.findFirst('\\n') == nullptr) {\n      kj::ArrayPtr<const byte> pieces[2];\n      pieces[0] = path.asBytes();\n      pieces[1] = kj::StringPtr(\"\\n\").asBytes();\n      out.write(pieces);\n      return true;\n    } else {\n      KJ_LOG(ERROR, \"tried to backup file containing newlines\", path);\n      return false;\n    }\n  } else if (S_ISDIR(stats.st_mode)) {\n    // Subdirectory; enumerate contents.\n    bool packedAny = false;\n    for (auto& entry: listDirectory(path)) {\n      if (findFilesToZip(kj::str(path, '/', entry), out)) {\n        packedAny = true;\n      }\n    }\n\n    if (!packedAny) {\n      // Empty directory. Need to make sure it gets into the zip.\n      kj::ArrayPtr<const byte> pieces[2];\n      pieces[0] = path.asBytes();\n      pieces[1] = kj::StringPtr(\"\\n\").asBytes();\n      out.write(pieces);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\n} // namespace sandstorm\n\n"], "filenames": ["src/sandstorm/backup.c++"], "buggy_code_start_loc": [147], "buggy_code_end_loc": [162], "fixing_code_start_loc": [147], "fixing_code_end_loc": [163], "type": "CWE-200", "message": "Sandstorm before build 0.203 allows remote attackers to read any specified file under /etc or /run via the sandbox backup function. The root cause is that the findFilesToZip function doesn't filter Line Feed (\\n) characters in a directory name.", "other": {"cve": {"id": "CVE-2017-6200", "sourceIdentifier": "cve@mitre.org", "published": "2018-02-06T16:29:00.790", "lastModified": "2018-03-13T19:29:01.577", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Sandstorm before build 0.203 allows remote attackers to read any specified file under /etc or /run via the sandbox backup function. The root cause is that the findFilesToZip function doesn't filter Line Feed (\\n) characters in a directory name."}, {"lang": "es", "value": "Sandstorm antes de la build 0.203 permite que atacantes remotos lean cualquier archivo especificado bajo /etc o /run mediante la funci\u00f3n de copia de seguridad del sandbox. La causa principal es que la funci\u00f3n findFilesToZip no filtra los caracteres nueva l\u00ednea (\\n) en un nombre de directorio."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:sandstorm:sandstorm:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.203", "matchCriteriaId": "683ED5F0-D297-4A47-ADF9-186832F3A3AD"}]}]}], "references": [{"url": "https://devco.re/blog/2018/01/26/Sandstorm-Security-Review-CVE-2017-6200-en/", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/sandstorm-io/sandstorm/blob/v0.202/src/sandstorm/backup.c%2B%2B#L271", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/sandstorm-io/sandstorm/commit/4ea8df7403381d9b657b121b3c98d8081b27414d", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/sandstorm-io/sandstorm/commit/6e8572ea8bb56d0216bb1b410e5040edc051b120", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://sandstorm.io/news/2017-03-02-security-review", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/sandstorm-io/sandstorm/commit/4ea8df7403381d9b657b121b3c98d8081b27414d"}}