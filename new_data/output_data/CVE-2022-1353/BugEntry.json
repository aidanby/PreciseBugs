{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n * net/key/af_key.c\tAn implementation of PF_KEYv2 sockets.\n *\n * Authors:\tMaxim Giryaev\t<gem@asplinux.ru>\n *\t\tDavid S. Miller\t<davem@redhat.com>\n *\t\tAlexey Kuznetsov <kuznet@ms2.inr.ac.ru>\n *\t\tKunihiro Ishiguro <kunihiro@ipinfusion.com>\n *\t\tKazunori MIYAZAWA / USAGI Project <miyazawa@linux-ipv6.org>\n *\t\tDerek Atkins <derek@ihtfp.com>\n */\n\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/socket.h>\n#include <linux/pfkeyv2.h>\n#include <linux/ipsec.h>\n#include <linux/skbuff.h>\n#include <linux/rtnetlink.h>\n#include <linux/in.h>\n#include <linux/in6.h>\n#include <linux/proc_fs.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <net/net_namespace.h>\n#include <net/netns/generic.h>\n#include <net/xfrm.h>\n\n#include <net/sock.h>\n\n#define _X2KEY(x) ((x) == XFRM_INF ? 0 : (x))\n#define _KEY2X(x) ((x) == 0 ? XFRM_INF : (x))\n\nstatic unsigned int pfkey_net_id __read_mostly;\nstruct netns_pfkey {\n\t/* List of all pfkey sockets. */\n\tstruct hlist_head table;\n\tatomic_t socks_nr;\n};\nstatic DEFINE_MUTEX(pfkey_mutex);\n\n#define DUMMY_MARK 0\nstatic const struct xfrm_mark dummy_mark = {0, 0};\nstruct pfkey_sock {\n\t/* struct sock must be the first member of struct pfkey_sock */\n\tstruct sock\tsk;\n\tint\t\tregistered;\n\tint\t\tpromisc;\n\n\tstruct {\n\t\tuint8_t\t\tmsg_version;\n\t\tuint32_t\tmsg_portid;\n\t\tint\t\t(*dump)(struct pfkey_sock *sk);\n\t\tvoid\t\t(*done)(struct pfkey_sock *sk);\n\t\tunion {\n\t\t\tstruct xfrm_policy_walk\tpolicy;\n\t\t\tstruct xfrm_state_walk\tstate;\n\t\t} u;\n\t\tstruct sk_buff\t*skb;\n\t} dump;\n\tstruct mutex dump_lock;\n};\n\nstatic int parse_sockaddr_pair(struct sockaddr *sa, int ext_len,\n\t\t\t       xfrm_address_t *saddr, xfrm_address_t *daddr,\n\t\t\t       u16 *family);\n\nstatic inline struct pfkey_sock *pfkey_sk(struct sock *sk)\n{\n\treturn (struct pfkey_sock *)sk;\n}\n\nstatic int pfkey_can_dump(const struct sock *sk)\n{\n\tif (3 * atomic_read(&sk->sk_rmem_alloc) <= 2 * sk->sk_rcvbuf)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic void pfkey_terminate_dump(struct pfkey_sock *pfk)\n{\n\tif (pfk->dump.dump) {\n\t\tif (pfk->dump.skb) {\n\t\t\tkfree_skb(pfk->dump.skb);\n\t\t\tpfk->dump.skb = NULL;\n\t\t}\n\t\tpfk->dump.done(pfk);\n\t\tpfk->dump.dump = NULL;\n\t\tpfk->dump.done = NULL;\n\t}\n}\n\nstatic void pfkey_sock_destruct(struct sock *sk)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct netns_pfkey *net_pfkey = net_generic(net, pfkey_net_id);\n\n\tpfkey_terminate_dump(pfkey_sk(sk));\n\tskb_queue_purge(&sk->sk_receive_queue);\n\n\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\tpr_err(\"Attempt to release alive pfkey socket: %p\\n\", sk);\n\t\treturn;\n\t}\n\n\tWARN_ON(atomic_read(&sk->sk_rmem_alloc));\n\tWARN_ON(refcount_read(&sk->sk_wmem_alloc));\n\n\tatomic_dec(&net_pfkey->socks_nr);\n}\n\nstatic const struct proto_ops pfkey_ops;\n\nstatic void pfkey_insert(struct sock *sk)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct netns_pfkey *net_pfkey = net_generic(net, pfkey_net_id);\n\n\tmutex_lock(&pfkey_mutex);\n\tsk_add_node_rcu(sk, &net_pfkey->table);\n\tmutex_unlock(&pfkey_mutex);\n}\n\nstatic void pfkey_remove(struct sock *sk)\n{\n\tmutex_lock(&pfkey_mutex);\n\tsk_del_node_init_rcu(sk);\n\tmutex_unlock(&pfkey_mutex);\n}\n\nstatic struct proto key_proto = {\n\t.name\t  = \"KEY\",\n\t.owner\t  = THIS_MODULE,\n\t.obj_size = sizeof(struct pfkey_sock),\n};\n\nstatic int pfkey_create(struct net *net, struct socket *sock, int protocol,\n\t\t\tint kern)\n{\n\tstruct netns_pfkey *net_pfkey = net_generic(net, pfkey_net_id);\n\tstruct sock *sk;\n\tstruct pfkey_sock *pfk;\n\n\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\tif (sock->type != SOCK_RAW)\n\t\treturn -ESOCKTNOSUPPORT;\n\tif (protocol != PF_KEY_V2)\n\t\treturn -EPROTONOSUPPORT;\n\n\tsk = sk_alloc(net, PF_KEY, GFP_KERNEL, &key_proto, kern);\n\tif (sk == NULL)\n\t\treturn -ENOMEM;\n\n\tpfk = pfkey_sk(sk);\n\tmutex_init(&pfk->dump_lock);\n\n\tsock->ops = &pfkey_ops;\n\tsock_init_data(sock, sk);\n\n\tsk->sk_family = PF_KEY;\n\tsk->sk_destruct = pfkey_sock_destruct;\n\n\tatomic_inc(&net_pfkey->socks_nr);\n\n\tpfkey_insert(sk);\n\n\treturn 0;\n}\n\nstatic int pfkey_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\n\tif (!sk)\n\t\treturn 0;\n\n\tpfkey_remove(sk);\n\n\tsock_orphan(sk);\n\tsock->sk = NULL;\n\tskb_queue_purge(&sk->sk_write_queue);\n\n\tsynchronize_rcu();\n\tsock_put(sk);\n\n\treturn 0;\n}\n\nstatic int pfkey_broadcast_one(struct sk_buff *skb, gfp_t allocation,\n\t\t\t       struct sock *sk)\n{\n\tint err = -ENOBUFS;\n\n\tif (atomic_read(&sk->sk_rmem_alloc) > sk->sk_rcvbuf)\n\t\treturn err;\n\n\tskb = skb_clone(skb, allocation);\n\n\tif (skb) {\n\t\tskb_set_owner_r(skb, sk);\n\t\tskb_queue_tail(&sk->sk_receive_queue, skb);\n\t\tsk->sk_data_ready(sk);\n\t\terr = 0;\n\t}\n\treturn err;\n}\n\n/* Send SKB to all pfkey sockets matching selected criteria.  */\n#define BROADCAST_ALL\t\t0\n#define BROADCAST_ONE\t\t1\n#define BROADCAST_REGISTERED\t2\n#define BROADCAST_PROMISC_ONLY\t4\nstatic int pfkey_broadcast(struct sk_buff *skb, gfp_t allocation,\n\t\t\t   int broadcast_flags, struct sock *one_sk,\n\t\t\t   struct net *net)\n{\n\tstruct netns_pfkey *net_pfkey = net_generic(net, pfkey_net_id);\n\tstruct sock *sk;\n\tint err = -ESRCH;\n\n\t/* XXX Do we need something like netlink_overrun?  I think\n\t * XXX PF_KEY socket apps will not mind current behavior.\n\t */\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\trcu_read_lock();\n\tsk_for_each_rcu(sk, &net_pfkey->table) {\n\t\tstruct pfkey_sock *pfk = pfkey_sk(sk);\n\t\tint err2;\n\n\t\t/* Yes, it means that if you are meant to receive this\n\t\t * pfkey message you receive it twice as promiscuous\n\t\t * socket.\n\t\t */\n\t\tif (pfk->promisc)\n\t\t\tpfkey_broadcast_one(skb, GFP_ATOMIC, sk);\n\n\t\t/* the exact target will be processed later */\n\t\tif (sk == one_sk)\n\t\t\tcontinue;\n\t\tif (broadcast_flags != BROADCAST_ALL) {\n\t\t\tif (broadcast_flags & BROADCAST_PROMISC_ONLY)\n\t\t\t\tcontinue;\n\t\t\tif ((broadcast_flags & BROADCAST_REGISTERED) &&\n\t\t\t    !pfk->registered)\n\t\t\t\tcontinue;\n\t\t\tif (broadcast_flags & BROADCAST_ONE)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\terr2 = pfkey_broadcast_one(skb, GFP_ATOMIC, sk);\n\n\t\t/* Error is cleared after successful sending to at least one\n\t\t * registered KM */\n\t\tif ((broadcast_flags & BROADCAST_REGISTERED) && err)\n\t\t\terr = err2;\n\t}\n\trcu_read_unlock();\n\n\tif (one_sk != NULL)\n\t\terr = pfkey_broadcast_one(skb, allocation, one_sk);\n\n\tkfree_skb(skb);\n\treturn err;\n}\n\nstatic int pfkey_do_dump(struct pfkey_sock *pfk)\n{\n\tstruct sadb_msg *hdr;\n\tint rc;\n\n\tmutex_lock(&pfk->dump_lock);\n\tif (!pfk->dump.dump) {\n\t\trc = 0;\n\t\tgoto out;\n\t}\n\n\trc = pfk->dump.dump(pfk);\n\tif (rc == -ENOBUFS) {\n\t\trc = 0;\n\t\tgoto out;\n\t}\n\n\tif (pfk->dump.skb) {\n\t\tif (!pfkey_can_dump(&pfk->sk)) {\n\t\t\trc = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\thdr = (struct sadb_msg *) pfk->dump.skb->data;\n\t\thdr->sadb_msg_seq = 0;\n\t\thdr->sadb_msg_errno = rc;\n\t\tpfkey_broadcast(pfk->dump.skb, GFP_ATOMIC, BROADCAST_ONE,\n\t\t\t\t&pfk->sk, sock_net(&pfk->sk));\n\t\tpfk->dump.skb = NULL;\n\t}\n\n\tpfkey_terminate_dump(pfk);\n\nout:\n\tmutex_unlock(&pfk->dump_lock);\n\treturn rc;\n}\n\nstatic inline void pfkey_hdr_dup(struct sadb_msg *new,\n\t\t\t\t const struct sadb_msg *orig)\n{\n\t*new = *orig;\n}\n\nstatic int pfkey_error(const struct sadb_msg *orig, int err, struct sock *sk)\n{\n\tstruct sk_buff *skb = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_KERNEL);\n\tstruct sadb_msg *hdr;\n\n\tif (!skb)\n\t\treturn -ENOBUFS;\n\n\t/* Woe be to the platform trying to support PFKEY yet\n\t * having normal errnos outside the 1-255 range, inclusive.\n\t */\n\terr = -err;\n\tif (err == ERESTARTSYS ||\n\t    err == ERESTARTNOHAND ||\n\t    err == ERESTARTNOINTR)\n\t\terr = EINTR;\n\tif (err >= 512)\n\t\terr = EINVAL;\n\tBUG_ON(err <= 0 || err >= 256);\n\n\thdr = skb_put(skb, sizeof(struct sadb_msg));\n\tpfkey_hdr_dup(hdr, orig);\n\thdr->sadb_msg_errno = (uint8_t) err;\n\thdr->sadb_msg_len = (sizeof(struct sadb_msg) /\n\t\t\t     sizeof(uint64_t));\n\n\tpfkey_broadcast(skb, GFP_KERNEL, BROADCAST_ONE, sk, sock_net(sk));\n\n\treturn 0;\n}\n\nstatic const u8 sadb_ext_min_len[] = {\n\t[SADB_EXT_RESERVED]\t\t= (u8) 0,\n\t[SADB_EXT_SA]\t\t\t= (u8) sizeof(struct sadb_sa),\n\t[SADB_EXT_LIFETIME_CURRENT]\t= (u8) sizeof(struct sadb_lifetime),\n\t[SADB_EXT_LIFETIME_HARD]\t= (u8) sizeof(struct sadb_lifetime),\n\t[SADB_EXT_LIFETIME_SOFT]\t= (u8) sizeof(struct sadb_lifetime),\n\t[SADB_EXT_ADDRESS_SRC]\t\t= (u8) sizeof(struct sadb_address),\n\t[SADB_EXT_ADDRESS_DST]\t\t= (u8) sizeof(struct sadb_address),\n\t[SADB_EXT_ADDRESS_PROXY]\t= (u8) sizeof(struct sadb_address),\n\t[SADB_EXT_KEY_AUTH]\t\t= (u8) sizeof(struct sadb_key),\n\t[SADB_EXT_KEY_ENCRYPT]\t\t= (u8) sizeof(struct sadb_key),\n\t[SADB_EXT_IDENTITY_SRC]\t\t= (u8) sizeof(struct sadb_ident),\n\t[SADB_EXT_IDENTITY_DST]\t\t= (u8) sizeof(struct sadb_ident),\n\t[SADB_EXT_SENSITIVITY]\t\t= (u8) sizeof(struct sadb_sens),\n\t[SADB_EXT_PROPOSAL]\t\t= (u8) sizeof(struct sadb_prop),\n\t[SADB_EXT_SUPPORTED_AUTH]\t= (u8) sizeof(struct sadb_supported),\n\t[SADB_EXT_SUPPORTED_ENCRYPT]\t= (u8) sizeof(struct sadb_supported),\n\t[SADB_EXT_SPIRANGE]\t\t= (u8) sizeof(struct sadb_spirange),\n\t[SADB_X_EXT_KMPRIVATE]\t\t= (u8) sizeof(struct sadb_x_kmprivate),\n\t[SADB_X_EXT_POLICY]\t\t= (u8) sizeof(struct sadb_x_policy),\n\t[SADB_X_EXT_SA2]\t\t= (u8) sizeof(struct sadb_x_sa2),\n\t[SADB_X_EXT_NAT_T_TYPE]\t\t= (u8) sizeof(struct sadb_x_nat_t_type),\n\t[SADB_X_EXT_NAT_T_SPORT]\t= (u8) sizeof(struct sadb_x_nat_t_port),\n\t[SADB_X_EXT_NAT_T_DPORT]\t= (u8) sizeof(struct sadb_x_nat_t_port),\n\t[SADB_X_EXT_NAT_T_OA]\t\t= (u8) sizeof(struct sadb_address),\n\t[SADB_X_EXT_SEC_CTX]\t\t= (u8) sizeof(struct sadb_x_sec_ctx),\n\t[SADB_X_EXT_KMADDRESS]\t\t= (u8) sizeof(struct sadb_x_kmaddress),\n\t[SADB_X_EXT_FILTER]\t\t= (u8) sizeof(struct sadb_x_filter),\n};\n\n/* Verify sadb_address_{len,prefixlen} against sa_family.  */\nstatic int verify_address_len(const void *p)\n{\n\tconst struct sadb_address *sp = p;\n\tconst struct sockaddr *addr = (const struct sockaddr *)(sp + 1);\n\tconst struct sockaddr_in *sin;\n#if IS_ENABLED(CONFIG_IPV6)\n\tconst struct sockaddr_in6 *sin6;\n#endif\n\tint len;\n\n\tif (sp->sadb_address_len <\n\t    DIV_ROUND_UP(sizeof(*sp) + offsetofend(typeof(*addr), sa_family),\n\t\t\t sizeof(uint64_t)))\n\t\treturn -EINVAL;\n\n\tswitch (addr->sa_family) {\n\tcase AF_INET:\n\t\tlen = DIV_ROUND_UP(sizeof(*sp) + sizeof(*sin), sizeof(uint64_t));\n\t\tif (sp->sadb_address_len != len ||\n\t\t    sp->sadb_address_prefixlen > 32)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase AF_INET6:\n\t\tlen = DIV_ROUND_UP(sizeof(*sp) + sizeof(*sin6), sizeof(uint64_t));\n\t\tif (sp->sadb_address_len != len ||\n\t\t    sp->sadb_address_prefixlen > 128)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n#endif\n\tdefault:\n\t\t/* It is user using kernel to keep track of security\n\t\t * associations for another protocol, such as\n\t\t * OSPF/RSVP/RIPV2/MIP.  It is user's job to verify\n\t\t * lengths.\n\t\t *\n\t\t * XXX Actually, association/policy database is not yet\n\t\t * XXX able to cope with arbitrary sockaddr families.\n\t\t * XXX When it can, remove this -EINVAL.  -DaveM\n\t\t */\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic inline int sadb_key_len(const struct sadb_key *key)\n{\n\tint key_bytes = DIV_ROUND_UP(key->sadb_key_bits, 8);\n\n\treturn DIV_ROUND_UP(sizeof(struct sadb_key) + key_bytes,\n\t\t\t    sizeof(uint64_t));\n}\n\nstatic int verify_key_len(const void *p)\n{\n\tconst struct sadb_key *key = p;\n\n\tif (sadb_key_len(key) > key->sadb_key_len)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic inline int pfkey_sec_ctx_len(const struct sadb_x_sec_ctx *sec_ctx)\n{\n\treturn DIV_ROUND_UP(sizeof(struct sadb_x_sec_ctx) +\n\t\t\t    sec_ctx->sadb_x_ctx_len,\n\t\t\t    sizeof(uint64_t));\n}\n\nstatic inline int verify_sec_ctx_len(const void *p)\n{\n\tconst struct sadb_x_sec_ctx *sec_ctx = p;\n\tint len = sec_ctx->sadb_x_ctx_len;\n\n\tif (len > PAGE_SIZE)\n\t\treturn -EINVAL;\n\n\tlen = pfkey_sec_ctx_len(sec_ctx);\n\n\tif (sec_ctx->sadb_x_sec_len != len)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic inline struct xfrm_user_sec_ctx *pfkey_sadb2xfrm_user_sec_ctx(const struct sadb_x_sec_ctx *sec_ctx,\n\t\t\t\t\t\t\t\t     gfp_t gfp)\n{\n\tstruct xfrm_user_sec_ctx *uctx = NULL;\n\tint ctx_size = sec_ctx->sadb_x_ctx_len;\n\n\tuctx = kmalloc((sizeof(*uctx)+ctx_size), gfp);\n\n\tif (!uctx)\n\t\treturn NULL;\n\n\tuctx->len = pfkey_sec_ctx_len(sec_ctx);\n\tuctx->exttype = sec_ctx->sadb_x_sec_exttype;\n\tuctx->ctx_doi = sec_ctx->sadb_x_ctx_doi;\n\tuctx->ctx_alg = sec_ctx->sadb_x_ctx_alg;\n\tuctx->ctx_len = sec_ctx->sadb_x_ctx_len;\n\tmemcpy(uctx + 1, sec_ctx + 1,\n\t       uctx->ctx_len);\n\n\treturn uctx;\n}\n\nstatic int present_and_same_family(const struct sadb_address *src,\n\t\t\t\t   const struct sadb_address *dst)\n{\n\tconst struct sockaddr *s_addr, *d_addr;\n\n\tif (!src || !dst)\n\t\treturn 0;\n\n\ts_addr = (const struct sockaddr *)(src + 1);\n\td_addr = (const struct sockaddr *)(dst + 1);\n\tif (s_addr->sa_family != d_addr->sa_family)\n\t\treturn 0;\n\tif (s_addr->sa_family != AF_INET\n#if IS_ENABLED(CONFIG_IPV6)\n\t    && s_addr->sa_family != AF_INET6\n#endif\n\t\t)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic int parse_exthdrs(struct sk_buff *skb, const struct sadb_msg *hdr, void **ext_hdrs)\n{\n\tconst char *p = (char *) hdr;\n\tint len = skb->len;\n\n\tlen -= sizeof(*hdr);\n\tp += sizeof(*hdr);\n\twhile (len > 0) {\n\t\tconst struct sadb_ext *ehdr = (const struct sadb_ext *) p;\n\t\tuint16_t ext_type;\n\t\tint ext_len;\n\n\t\tif (len < sizeof(*ehdr))\n\t\t\treturn -EINVAL;\n\n\t\text_len  = ehdr->sadb_ext_len;\n\t\text_len *= sizeof(uint64_t);\n\t\text_type = ehdr->sadb_ext_type;\n\t\tif (ext_len < sizeof(uint64_t) ||\n\t\t    ext_len > len ||\n\t\t    ext_type == SADB_EXT_RESERVED)\n\t\t\treturn -EINVAL;\n\n\t\tif (ext_type <= SADB_EXT_MAX) {\n\t\t\tint min = (int) sadb_ext_min_len[ext_type];\n\t\t\tif (ext_len < min)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (ext_hdrs[ext_type-1] != NULL)\n\t\t\t\treturn -EINVAL;\n\t\t\tswitch (ext_type) {\n\t\t\tcase SADB_EXT_ADDRESS_SRC:\n\t\t\tcase SADB_EXT_ADDRESS_DST:\n\t\t\tcase SADB_EXT_ADDRESS_PROXY:\n\t\t\tcase SADB_X_EXT_NAT_T_OA:\n\t\t\t\tif (verify_address_len(p))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tbreak;\n\t\t\tcase SADB_X_EXT_SEC_CTX:\n\t\t\t\tif (verify_sec_ctx_len(p))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tbreak;\n\t\t\tcase SADB_EXT_KEY_AUTH:\n\t\t\tcase SADB_EXT_KEY_ENCRYPT:\n\t\t\t\tif (verify_key_len(p))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\text_hdrs[ext_type-1] = (void *) p;\n\t\t}\n\t\tp   += ext_len;\n\t\tlen -= ext_len;\n\t}\n\n\treturn 0;\n}\n\nstatic uint16_t\npfkey_satype2proto(uint8_t satype)\n{\n\tswitch (satype) {\n\tcase SADB_SATYPE_UNSPEC:\n\t\treturn IPSEC_PROTO_ANY;\n\tcase SADB_SATYPE_AH:\n\t\treturn IPPROTO_AH;\n\tcase SADB_SATYPE_ESP:\n\t\treturn IPPROTO_ESP;\n\tcase SADB_X_SATYPE_IPCOMP:\n\t\treturn IPPROTO_COMP;\n\tdefault:\n\t\treturn 0;\n\t}\n\t/* NOTREACHED */\n}\n\nstatic uint8_t\npfkey_proto2satype(uint16_t proto)\n{\n\tswitch (proto) {\n\tcase IPPROTO_AH:\n\t\treturn SADB_SATYPE_AH;\n\tcase IPPROTO_ESP:\n\t\treturn SADB_SATYPE_ESP;\n\tcase IPPROTO_COMP:\n\t\treturn SADB_X_SATYPE_IPCOMP;\n\tdefault:\n\t\treturn 0;\n\t}\n\t/* NOTREACHED */\n}\n\n/* BTW, this scheme means that there is no way with PFKEY2 sockets to\n * say specifically 'just raw sockets' as we encode them as 255.\n */\n\nstatic uint8_t pfkey_proto_to_xfrm(uint8_t proto)\n{\n\treturn proto == IPSEC_PROTO_ANY ? 0 : proto;\n}\n\nstatic uint8_t pfkey_proto_from_xfrm(uint8_t proto)\n{\n\treturn proto ? proto : IPSEC_PROTO_ANY;\n}\n\nstatic inline int pfkey_sockaddr_len(sa_family_t family)\n{\n\tswitch (family) {\n\tcase AF_INET:\n\t\treturn sizeof(struct sockaddr_in);\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase AF_INET6:\n\t\treturn sizeof(struct sockaddr_in6);\n#endif\n\t}\n\treturn 0;\n}\n\nstatic\nint pfkey_sockaddr_extract(const struct sockaddr *sa, xfrm_address_t *xaddr)\n{\n\tswitch (sa->sa_family) {\n\tcase AF_INET:\n\t\txaddr->a4 =\n\t\t\t((struct sockaddr_in *)sa)->sin_addr.s_addr;\n\t\treturn AF_INET;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase AF_INET6:\n\t\tmemcpy(xaddr->a6,\n\t\t       &((struct sockaddr_in6 *)sa)->sin6_addr,\n\t\t       sizeof(struct in6_addr));\n\t\treturn AF_INET6;\n#endif\n\t}\n\treturn 0;\n}\n\nstatic\nint pfkey_sadb_addr2xfrm_addr(const struct sadb_address *addr, xfrm_address_t *xaddr)\n{\n\treturn pfkey_sockaddr_extract((struct sockaddr *)(addr + 1),\n\t\t\t\t      xaddr);\n}\n\nstatic struct  xfrm_state *pfkey_xfrm_state_lookup(struct net *net, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tconst struct sadb_sa *sa;\n\tconst struct sadb_address *addr;\n\tuint16_t proto;\n\tunsigned short family;\n\txfrm_address_t *xaddr;\n\n\tsa = ext_hdrs[SADB_EXT_SA - 1];\n\tif (sa == NULL)\n\t\treturn NULL;\n\n\tproto = pfkey_satype2proto(hdr->sadb_msg_satype);\n\tif (proto == 0)\n\t\treturn NULL;\n\n\t/* sadb_address_len should be checked by caller */\n\taddr = ext_hdrs[SADB_EXT_ADDRESS_DST - 1];\n\tif (addr == NULL)\n\t\treturn NULL;\n\n\tfamily = ((const struct sockaddr *)(addr + 1))->sa_family;\n\tswitch (family) {\n\tcase AF_INET:\n\t\txaddr = (xfrm_address_t *)&((const struct sockaddr_in *)(addr + 1))->sin_addr;\n\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase AF_INET6:\n\t\txaddr = (xfrm_address_t *)&((const struct sockaddr_in6 *)(addr + 1))->sin6_addr;\n\t\tbreak;\n#endif\n\tdefault:\n\t\txaddr = NULL;\n\t}\n\n\tif (!xaddr)\n\t\treturn NULL;\n\n\treturn xfrm_state_lookup(net, DUMMY_MARK, xaddr, sa->sadb_sa_spi, proto, family);\n}\n\n#define PFKEY_ALIGN8(a) (1 + (((a) - 1) | (8 - 1)))\n\nstatic int\npfkey_sockaddr_size(sa_family_t family)\n{\n\treturn PFKEY_ALIGN8(pfkey_sockaddr_len(family));\n}\n\nstatic inline int pfkey_mode_from_xfrm(int mode)\n{\n\tswitch(mode) {\n\tcase XFRM_MODE_TRANSPORT:\n\t\treturn IPSEC_MODE_TRANSPORT;\n\tcase XFRM_MODE_TUNNEL:\n\t\treturn IPSEC_MODE_TUNNEL;\n\tcase XFRM_MODE_BEET:\n\t\treturn IPSEC_MODE_BEET;\n\tdefault:\n\t\treturn -1;\n\t}\n}\n\nstatic inline int pfkey_mode_to_xfrm(int mode)\n{\n\tswitch(mode) {\n\tcase IPSEC_MODE_ANY:\t/*XXX*/\n\tcase IPSEC_MODE_TRANSPORT:\n\t\treturn XFRM_MODE_TRANSPORT;\n\tcase IPSEC_MODE_TUNNEL:\n\t\treturn XFRM_MODE_TUNNEL;\n\tcase IPSEC_MODE_BEET:\n\t\treturn XFRM_MODE_BEET;\n\tdefault:\n\t\treturn -1;\n\t}\n}\n\nstatic unsigned int pfkey_sockaddr_fill(const xfrm_address_t *xaddr, __be16 port,\n\t\t\t\t\tstruct sockaddr *sa,\n\t\t\t\t\tunsigned short family)\n{\n\tswitch (family) {\n\tcase AF_INET:\n\t    {\n\t\tstruct sockaddr_in *sin = (struct sockaddr_in *)sa;\n\t\tsin->sin_family = AF_INET;\n\t\tsin->sin_port = port;\n\t\tsin->sin_addr.s_addr = xaddr->a4;\n\t\tmemset(sin->sin_zero, 0, sizeof(sin->sin_zero));\n\t\treturn 32;\n\t    }\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase AF_INET6:\n\t    {\n\t\tstruct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)sa;\n\t\tsin6->sin6_family = AF_INET6;\n\t\tsin6->sin6_port = port;\n\t\tsin6->sin6_flowinfo = 0;\n\t\tsin6->sin6_addr = xaddr->in6;\n\t\tsin6->sin6_scope_id = 0;\n\t\treturn 128;\n\t    }\n#endif\n\t}\n\treturn 0;\n}\n\nstatic struct sk_buff *__pfkey_xfrm_state2msg(const struct xfrm_state *x,\n\t\t\t\t\t      int add_keys, int hsc)\n{\n\tstruct sk_buff *skb;\n\tstruct sadb_msg *hdr;\n\tstruct sadb_sa *sa;\n\tstruct sadb_lifetime *lifetime;\n\tstruct sadb_address *addr;\n\tstruct sadb_key *key;\n\tstruct sadb_x_sa2 *sa2;\n\tstruct sadb_x_sec_ctx *sec_ctx;\n\tstruct xfrm_sec_ctx *xfrm_ctx;\n\tint ctx_size = 0;\n\tint size;\n\tint auth_key_size = 0;\n\tint encrypt_key_size = 0;\n\tint sockaddr_size;\n\tstruct xfrm_encap_tmpl *natt = NULL;\n\tint mode;\n\n\t/* address family check */\n\tsockaddr_size = pfkey_sockaddr_size(x->props.family);\n\tif (!sockaddr_size)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* base, SA, (lifetime (HSC),) address(SD), (address(P),)\n\t   key(AE), (identity(SD),) (sensitivity)> */\n\tsize = sizeof(struct sadb_msg) +sizeof(struct sadb_sa) +\n\t\tsizeof(struct sadb_lifetime) +\n\t\t((hsc & 1) ? sizeof(struct sadb_lifetime) : 0) +\n\t\t((hsc & 2) ? sizeof(struct sadb_lifetime) : 0) +\n\t\t\tsizeof(struct sadb_address)*2 +\n\t\t\t\tsockaddr_size*2 +\n\t\t\t\t\tsizeof(struct sadb_x_sa2);\n\n\tif ((xfrm_ctx = x->security)) {\n\t\tctx_size = PFKEY_ALIGN8(xfrm_ctx->ctx_len);\n\t\tsize += sizeof(struct sadb_x_sec_ctx) + ctx_size;\n\t}\n\n\t/* identity & sensitivity */\n\tif (!xfrm_addr_equal(&x->sel.saddr, &x->props.saddr, x->props.family))\n\t\tsize += sizeof(struct sadb_address) + sockaddr_size;\n\n\tif (add_keys) {\n\t\tif (x->aalg && x->aalg->alg_key_len) {\n\t\t\tauth_key_size =\n\t\t\t\tPFKEY_ALIGN8((x->aalg->alg_key_len + 7) / 8);\n\t\t\tsize += sizeof(struct sadb_key) + auth_key_size;\n\t\t}\n\t\tif (x->ealg && x->ealg->alg_key_len) {\n\t\t\tencrypt_key_size =\n\t\t\t\tPFKEY_ALIGN8((x->ealg->alg_key_len+7) / 8);\n\t\t\tsize += sizeof(struct sadb_key) + encrypt_key_size;\n\t\t}\n\t}\n\tif (x->encap)\n\t\tnatt = x->encap;\n\n\tif (natt && natt->encap_type) {\n\t\tsize += sizeof(struct sadb_x_nat_t_type);\n\t\tsize += sizeof(struct sadb_x_nat_t_port);\n\t\tsize += sizeof(struct sadb_x_nat_t_port);\n\t}\n\n\tskb =  alloc_skb(size + 16, GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn ERR_PTR(-ENOBUFS);\n\n\t/* call should fill header later */\n\thdr = skb_put(skb, sizeof(struct sadb_msg));\n\tmemset(hdr, 0, size);\t/* XXX do we need this ? */\n\thdr->sadb_msg_len = size / sizeof(uint64_t);\n\n\t/* sa */\n\tsa = skb_put(skb, sizeof(struct sadb_sa));\n\tsa->sadb_sa_len = sizeof(struct sadb_sa)/sizeof(uint64_t);\n\tsa->sadb_sa_exttype = SADB_EXT_SA;\n\tsa->sadb_sa_spi = x->id.spi;\n\tsa->sadb_sa_replay = x->props.replay_window;\n\tswitch (x->km.state) {\n\tcase XFRM_STATE_VALID:\n\t\tsa->sadb_sa_state = x->km.dying ?\n\t\t\tSADB_SASTATE_DYING : SADB_SASTATE_MATURE;\n\t\tbreak;\n\tcase XFRM_STATE_ACQ:\n\t\tsa->sadb_sa_state = SADB_SASTATE_LARVAL;\n\t\tbreak;\n\tdefault:\n\t\tsa->sadb_sa_state = SADB_SASTATE_DEAD;\n\t\tbreak;\n\t}\n\tsa->sadb_sa_auth = 0;\n\tif (x->aalg) {\n\t\tstruct xfrm_algo_desc *a = xfrm_aalg_get_byname(x->aalg->alg_name, 0);\n\t\tsa->sadb_sa_auth = (a && a->pfkey_supported) ?\n\t\t\t\t\ta->desc.sadb_alg_id : 0;\n\t}\n\tsa->sadb_sa_encrypt = 0;\n\tBUG_ON(x->ealg && x->calg);\n\tif (x->ealg) {\n\t\tstruct xfrm_algo_desc *a = xfrm_ealg_get_byname(x->ealg->alg_name, 0);\n\t\tsa->sadb_sa_encrypt = (a && a->pfkey_supported) ?\n\t\t\t\t\ta->desc.sadb_alg_id : 0;\n\t}\n\t/* KAME compatible: sadb_sa_encrypt is overloaded with calg id */\n\tif (x->calg) {\n\t\tstruct xfrm_algo_desc *a = xfrm_calg_get_byname(x->calg->alg_name, 0);\n\t\tsa->sadb_sa_encrypt = (a && a->pfkey_supported) ?\n\t\t\t\t\ta->desc.sadb_alg_id : 0;\n\t}\n\n\tsa->sadb_sa_flags = 0;\n\tif (x->props.flags & XFRM_STATE_NOECN)\n\t\tsa->sadb_sa_flags |= SADB_SAFLAGS_NOECN;\n\tif (x->props.flags & XFRM_STATE_DECAP_DSCP)\n\t\tsa->sadb_sa_flags |= SADB_SAFLAGS_DECAP_DSCP;\n\tif (x->props.flags & XFRM_STATE_NOPMTUDISC)\n\t\tsa->sadb_sa_flags |= SADB_SAFLAGS_NOPMTUDISC;\n\n\t/* hard time */\n\tif (hsc & 2) {\n\t\tlifetime = skb_put(skb, sizeof(struct sadb_lifetime));\n\t\tlifetime->sadb_lifetime_len =\n\t\t\tsizeof(struct sadb_lifetime)/sizeof(uint64_t);\n\t\tlifetime->sadb_lifetime_exttype = SADB_EXT_LIFETIME_HARD;\n\t\tlifetime->sadb_lifetime_allocations =  _X2KEY(x->lft.hard_packet_limit);\n\t\tlifetime->sadb_lifetime_bytes = _X2KEY(x->lft.hard_byte_limit);\n\t\tlifetime->sadb_lifetime_addtime = x->lft.hard_add_expires_seconds;\n\t\tlifetime->sadb_lifetime_usetime = x->lft.hard_use_expires_seconds;\n\t}\n\t/* soft time */\n\tif (hsc & 1) {\n\t\tlifetime = skb_put(skb, sizeof(struct sadb_lifetime));\n\t\tlifetime->sadb_lifetime_len =\n\t\t\tsizeof(struct sadb_lifetime)/sizeof(uint64_t);\n\t\tlifetime->sadb_lifetime_exttype = SADB_EXT_LIFETIME_SOFT;\n\t\tlifetime->sadb_lifetime_allocations =  _X2KEY(x->lft.soft_packet_limit);\n\t\tlifetime->sadb_lifetime_bytes = _X2KEY(x->lft.soft_byte_limit);\n\t\tlifetime->sadb_lifetime_addtime = x->lft.soft_add_expires_seconds;\n\t\tlifetime->sadb_lifetime_usetime = x->lft.soft_use_expires_seconds;\n\t}\n\t/* current time */\n\tlifetime = skb_put(skb, sizeof(struct sadb_lifetime));\n\tlifetime->sadb_lifetime_len =\n\t\tsizeof(struct sadb_lifetime)/sizeof(uint64_t);\n\tlifetime->sadb_lifetime_exttype = SADB_EXT_LIFETIME_CURRENT;\n\tlifetime->sadb_lifetime_allocations = x->curlft.packets;\n\tlifetime->sadb_lifetime_bytes = x->curlft.bytes;\n\tlifetime->sadb_lifetime_addtime = x->curlft.add_time;\n\tlifetime->sadb_lifetime_usetime = x->curlft.use_time;\n\t/* src address */\n\taddr = skb_put(skb, sizeof(struct sadb_address) + sockaddr_size);\n\taddr->sadb_address_len =\n\t\t(sizeof(struct sadb_address)+sockaddr_size)/\n\t\t\tsizeof(uint64_t);\n\taddr->sadb_address_exttype = SADB_EXT_ADDRESS_SRC;\n\t/* \"if the ports are non-zero, then the sadb_address_proto field,\n\t   normally zero, MUST be filled in with the transport\n\t   protocol's number.\" - RFC2367 */\n\taddr->sadb_address_proto = 0;\n\taddr->sadb_address_reserved = 0;\n\n\taddr->sadb_address_prefixlen =\n\t\tpfkey_sockaddr_fill(&x->props.saddr, 0,\n\t\t\t\t    (struct sockaddr *) (addr + 1),\n\t\t\t\t    x->props.family);\n\tBUG_ON(!addr->sadb_address_prefixlen);\n\n\t/* dst address */\n\taddr = skb_put(skb, sizeof(struct sadb_address) + sockaddr_size);\n\taddr->sadb_address_len =\n\t\t(sizeof(struct sadb_address)+sockaddr_size)/\n\t\t\tsizeof(uint64_t);\n\taddr->sadb_address_exttype = SADB_EXT_ADDRESS_DST;\n\taddr->sadb_address_proto = 0;\n\taddr->sadb_address_reserved = 0;\n\n\taddr->sadb_address_prefixlen =\n\t\tpfkey_sockaddr_fill(&x->id.daddr, 0,\n\t\t\t\t    (struct sockaddr *) (addr + 1),\n\t\t\t\t    x->props.family);\n\tBUG_ON(!addr->sadb_address_prefixlen);\n\n\tif (!xfrm_addr_equal(&x->sel.saddr, &x->props.saddr,\n\t\t\t     x->props.family)) {\n\t\taddr = skb_put(skb,\n\t\t\t       sizeof(struct sadb_address) + sockaddr_size);\n\t\taddr->sadb_address_len =\n\t\t\t(sizeof(struct sadb_address)+sockaddr_size)/\n\t\t\tsizeof(uint64_t);\n\t\taddr->sadb_address_exttype = SADB_EXT_ADDRESS_PROXY;\n\t\taddr->sadb_address_proto =\n\t\t\tpfkey_proto_from_xfrm(x->sel.proto);\n\t\taddr->sadb_address_prefixlen = x->sel.prefixlen_s;\n\t\taddr->sadb_address_reserved = 0;\n\n\t\tpfkey_sockaddr_fill(&x->sel.saddr, x->sel.sport,\n\t\t\t\t    (struct sockaddr *) (addr + 1),\n\t\t\t\t    x->props.family);\n\t}\n\n\t/* auth key */\n\tif (add_keys && auth_key_size) {\n\t\tkey = skb_put(skb, sizeof(struct sadb_key) + auth_key_size);\n\t\tkey->sadb_key_len = (sizeof(struct sadb_key) + auth_key_size) /\n\t\t\tsizeof(uint64_t);\n\t\tkey->sadb_key_exttype = SADB_EXT_KEY_AUTH;\n\t\tkey->sadb_key_bits = x->aalg->alg_key_len;\n\t\tkey->sadb_key_reserved = 0;\n\t\tmemcpy(key + 1, x->aalg->alg_key, (x->aalg->alg_key_len+7)/8);\n\t}\n\t/* encrypt key */\n\tif (add_keys && encrypt_key_size) {\n\t\tkey = skb_put(skb, sizeof(struct sadb_key) + encrypt_key_size);\n\t\tkey->sadb_key_len = (sizeof(struct sadb_key) +\n\t\t\t\t     encrypt_key_size) / sizeof(uint64_t);\n\t\tkey->sadb_key_exttype = SADB_EXT_KEY_ENCRYPT;\n\t\tkey->sadb_key_bits = x->ealg->alg_key_len;\n\t\tkey->sadb_key_reserved = 0;\n\t\tmemcpy(key + 1, x->ealg->alg_key,\n\t\t       (x->ealg->alg_key_len+7)/8);\n\t}\n\n\t/* sa */\n\tsa2 = skb_put(skb, sizeof(struct sadb_x_sa2));\n\tsa2->sadb_x_sa2_len = sizeof(struct sadb_x_sa2)/sizeof(uint64_t);\n\tsa2->sadb_x_sa2_exttype = SADB_X_EXT_SA2;\n\tif ((mode = pfkey_mode_from_xfrm(x->props.mode)) < 0) {\n\t\tkfree_skb(skb);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\tsa2->sadb_x_sa2_mode = mode;\n\tsa2->sadb_x_sa2_reserved1 = 0;\n\tsa2->sadb_x_sa2_reserved2 = 0;\n\tsa2->sadb_x_sa2_sequence = 0;\n\tsa2->sadb_x_sa2_reqid = x->props.reqid;\n\n\tif (natt && natt->encap_type) {\n\t\tstruct sadb_x_nat_t_type *n_type;\n\t\tstruct sadb_x_nat_t_port *n_port;\n\n\t\t/* type */\n\t\tn_type = skb_put(skb, sizeof(*n_type));\n\t\tn_type->sadb_x_nat_t_type_len = sizeof(*n_type)/sizeof(uint64_t);\n\t\tn_type->sadb_x_nat_t_type_exttype = SADB_X_EXT_NAT_T_TYPE;\n\t\tn_type->sadb_x_nat_t_type_type = natt->encap_type;\n\t\tn_type->sadb_x_nat_t_type_reserved[0] = 0;\n\t\tn_type->sadb_x_nat_t_type_reserved[1] = 0;\n\t\tn_type->sadb_x_nat_t_type_reserved[2] = 0;\n\n\t\t/* source port */\n\t\tn_port = skb_put(skb, sizeof(*n_port));\n\t\tn_port->sadb_x_nat_t_port_len = sizeof(*n_port)/sizeof(uint64_t);\n\t\tn_port->sadb_x_nat_t_port_exttype = SADB_X_EXT_NAT_T_SPORT;\n\t\tn_port->sadb_x_nat_t_port_port = natt->encap_sport;\n\t\tn_port->sadb_x_nat_t_port_reserved = 0;\n\n\t\t/* dest port */\n\t\tn_port = skb_put(skb, sizeof(*n_port));\n\t\tn_port->sadb_x_nat_t_port_len = sizeof(*n_port)/sizeof(uint64_t);\n\t\tn_port->sadb_x_nat_t_port_exttype = SADB_X_EXT_NAT_T_DPORT;\n\t\tn_port->sadb_x_nat_t_port_port = natt->encap_dport;\n\t\tn_port->sadb_x_nat_t_port_reserved = 0;\n\t}\n\n\t/* security context */\n\tif (xfrm_ctx) {\n\t\tsec_ctx = skb_put(skb,\n\t\t\t\t  sizeof(struct sadb_x_sec_ctx) + ctx_size);\n\t\tsec_ctx->sadb_x_sec_len =\n\t\t  (sizeof(struct sadb_x_sec_ctx) + ctx_size) / sizeof(uint64_t);\n\t\tsec_ctx->sadb_x_sec_exttype = SADB_X_EXT_SEC_CTX;\n\t\tsec_ctx->sadb_x_ctx_doi = xfrm_ctx->ctx_doi;\n\t\tsec_ctx->sadb_x_ctx_alg = xfrm_ctx->ctx_alg;\n\t\tsec_ctx->sadb_x_ctx_len = xfrm_ctx->ctx_len;\n\t\tmemcpy(sec_ctx + 1, xfrm_ctx->ctx_str,\n\t\t       xfrm_ctx->ctx_len);\n\t}\n\n\treturn skb;\n}\n\n\nstatic inline struct sk_buff *pfkey_xfrm_state2msg(const struct xfrm_state *x)\n{\n\tstruct sk_buff *skb;\n\n\tskb = __pfkey_xfrm_state2msg(x, 1, 3);\n\n\treturn skb;\n}\n\nstatic inline struct sk_buff *pfkey_xfrm_state2msg_expire(const struct xfrm_state *x,\n\t\t\t\t\t\t\t  int hsc)\n{\n\treturn __pfkey_xfrm_state2msg(x, 0, hsc);\n}\n\nstatic struct xfrm_state * pfkey_msg2xfrm_state(struct net *net,\n\t\t\t\t\t\tconst struct sadb_msg *hdr,\n\t\t\t\t\t\tvoid * const *ext_hdrs)\n{\n\tstruct xfrm_state *x;\n\tconst struct sadb_lifetime *lifetime;\n\tconst struct sadb_sa *sa;\n\tconst struct sadb_key *key;\n\tconst struct sadb_x_sec_ctx *sec_ctx;\n\tuint16_t proto;\n\tint err;\n\n\n\tsa = ext_hdrs[SADB_EXT_SA - 1];\n\tif (!sa ||\n\t    !present_and_same_family(ext_hdrs[SADB_EXT_ADDRESS_SRC-1],\n\t\t\t\t     ext_hdrs[SADB_EXT_ADDRESS_DST-1]))\n\t\treturn ERR_PTR(-EINVAL);\n\tif (hdr->sadb_msg_satype == SADB_SATYPE_ESP &&\n\t    !ext_hdrs[SADB_EXT_KEY_ENCRYPT-1])\n\t\treturn ERR_PTR(-EINVAL);\n\tif (hdr->sadb_msg_satype == SADB_SATYPE_AH &&\n\t    !ext_hdrs[SADB_EXT_KEY_AUTH-1])\n\t\treturn ERR_PTR(-EINVAL);\n\tif (!!ext_hdrs[SADB_EXT_LIFETIME_HARD-1] !=\n\t    !!ext_hdrs[SADB_EXT_LIFETIME_SOFT-1])\n\t\treturn ERR_PTR(-EINVAL);\n\n\tproto = pfkey_satype2proto(hdr->sadb_msg_satype);\n\tif (proto == 0)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* default error is no buffer space */\n\terr = -ENOBUFS;\n\n\t/* RFC2367:\n\n   Only SADB_SASTATE_MATURE SAs may be submitted in an SADB_ADD message.\n   SADB_SASTATE_LARVAL SAs are created by SADB_GETSPI and it is not\n   sensible to add a new SA in the DYING or SADB_SASTATE_DEAD state.\n   Therefore, the sadb_sa_state field of all submitted SAs MUST be\n   SADB_SASTATE_MATURE and the kernel MUST return an error if this is\n   not true.\n\n\t   However, KAME setkey always uses SADB_SASTATE_LARVAL.\n\t   Hence, we have to _ignore_ sadb_sa_state, which is also reasonable.\n\t */\n\tif (sa->sadb_sa_auth > SADB_AALG_MAX ||\n\t    (hdr->sadb_msg_satype == SADB_X_SATYPE_IPCOMP &&\n\t     sa->sadb_sa_encrypt > SADB_X_CALG_MAX) ||\n\t    sa->sadb_sa_encrypt > SADB_EALG_MAX)\n\t\treturn ERR_PTR(-EINVAL);\n\tkey = ext_hdrs[SADB_EXT_KEY_AUTH - 1];\n\tif (key != NULL &&\n\t    sa->sadb_sa_auth != SADB_X_AALG_NULL &&\n\t    key->sadb_key_bits == 0)\n\t\treturn ERR_PTR(-EINVAL);\n\tkey = ext_hdrs[SADB_EXT_KEY_ENCRYPT-1];\n\tif (key != NULL &&\n\t    sa->sadb_sa_encrypt != SADB_EALG_NULL &&\n\t    key->sadb_key_bits == 0)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tx = xfrm_state_alloc(net);\n\tif (x == NULL)\n\t\treturn ERR_PTR(-ENOBUFS);\n\n\tx->id.proto = proto;\n\tx->id.spi = sa->sadb_sa_spi;\n\tx->props.replay_window = min_t(unsigned int, sa->sadb_sa_replay,\n\t\t\t\t\t(sizeof(x->replay.bitmap) * 8));\n\tif (sa->sadb_sa_flags & SADB_SAFLAGS_NOECN)\n\t\tx->props.flags |= XFRM_STATE_NOECN;\n\tif (sa->sadb_sa_flags & SADB_SAFLAGS_DECAP_DSCP)\n\t\tx->props.flags |= XFRM_STATE_DECAP_DSCP;\n\tif (sa->sadb_sa_flags & SADB_SAFLAGS_NOPMTUDISC)\n\t\tx->props.flags |= XFRM_STATE_NOPMTUDISC;\n\n\tlifetime = ext_hdrs[SADB_EXT_LIFETIME_HARD - 1];\n\tif (lifetime != NULL) {\n\t\tx->lft.hard_packet_limit = _KEY2X(lifetime->sadb_lifetime_allocations);\n\t\tx->lft.hard_byte_limit = _KEY2X(lifetime->sadb_lifetime_bytes);\n\t\tx->lft.hard_add_expires_seconds = lifetime->sadb_lifetime_addtime;\n\t\tx->lft.hard_use_expires_seconds = lifetime->sadb_lifetime_usetime;\n\t}\n\tlifetime = ext_hdrs[SADB_EXT_LIFETIME_SOFT - 1];\n\tif (lifetime != NULL) {\n\t\tx->lft.soft_packet_limit = _KEY2X(lifetime->sadb_lifetime_allocations);\n\t\tx->lft.soft_byte_limit = _KEY2X(lifetime->sadb_lifetime_bytes);\n\t\tx->lft.soft_add_expires_seconds = lifetime->sadb_lifetime_addtime;\n\t\tx->lft.soft_use_expires_seconds = lifetime->sadb_lifetime_usetime;\n\t}\n\n\tsec_ctx = ext_hdrs[SADB_X_EXT_SEC_CTX - 1];\n\tif (sec_ctx != NULL) {\n\t\tstruct xfrm_user_sec_ctx *uctx = pfkey_sadb2xfrm_user_sec_ctx(sec_ctx, GFP_KERNEL);\n\n\t\tif (!uctx)\n\t\t\tgoto out;\n\n\t\terr = security_xfrm_state_alloc(x, uctx);\n\t\tkfree(uctx);\n\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\terr = -ENOBUFS;\n\tkey = ext_hdrs[SADB_EXT_KEY_AUTH - 1];\n\tif (sa->sadb_sa_auth) {\n\t\tint keysize = 0;\n\t\tstruct xfrm_algo_desc *a = xfrm_aalg_get_byid(sa->sadb_sa_auth);\n\t\tif (!a || !a->pfkey_supported) {\n\t\t\terr = -ENOSYS;\n\t\t\tgoto out;\n\t\t}\n\t\tif (key)\n\t\t\tkeysize = (key->sadb_key_bits + 7) / 8;\n\t\tx->aalg = kmalloc(sizeof(*x->aalg) + keysize, GFP_KERNEL);\n\t\tif (!x->aalg) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tstrcpy(x->aalg->alg_name, a->name);\n\t\tx->aalg->alg_key_len = 0;\n\t\tif (key) {\n\t\t\tx->aalg->alg_key_len = key->sadb_key_bits;\n\t\t\tmemcpy(x->aalg->alg_key, key+1, keysize);\n\t\t}\n\t\tx->aalg->alg_trunc_len = a->uinfo.auth.icv_truncbits;\n\t\tx->props.aalgo = sa->sadb_sa_auth;\n\t\t/* x->algo.flags = sa->sadb_sa_flags; */\n\t}\n\tif (sa->sadb_sa_encrypt) {\n\t\tif (hdr->sadb_msg_satype == SADB_X_SATYPE_IPCOMP) {\n\t\t\tstruct xfrm_algo_desc *a = xfrm_calg_get_byid(sa->sadb_sa_encrypt);\n\t\t\tif (!a || !a->pfkey_supported) {\n\t\t\t\terr = -ENOSYS;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tx->calg = kmalloc(sizeof(*x->calg), GFP_KERNEL);\n\t\t\tif (!x->calg) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tstrcpy(x->calg->alg_name, a->name);\n\t\t\tx->props.calgo = sa->sadb_sa_encrypt;\n\t\t} else {\n\t\t\tint keysize = 0;\n\t\t\tstruct xfrm_algo_desc *a = xfrm_ealg_get_byid(sa->sadb_sa_encrypt);\n\t\t\tif (!a || !a->pfkey_supported) {\n\t\t\t\terr = -ENOSYS;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tkey = (struct sadb_key*) ext_hdrs[SADB_EXT_KEY_ENCRYPT-1];\n\t\t\tif (key)\n\t\t\t\tkeysize = (key->sadb_key_bits + 7) / 8;\n\t\t\tx->ealg = kmalloc(sizeof(*x->ealg) + keysize, GFP_KERNEL);\n\t\t\tif (!x->ealg) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tstrcpy(x->ealg->alg_name, a->name);\n\t\t\tx->ealg->alg_key_len = 0;\n\t\t\tif (key) {\n\t\t\t\tx->ealg->alg_key_len = key->sadb_key_bits;\n\t\t\t\tmemcpy(x->ealg->alg_key, key+1, keysize);\n\t\t\t}\n\t\t\tx->props.ealgo = sa->sadb_sa_encrypt;\n\t\t\tx->geniv = a->uinfo.encr.geniv;\n\t\t}\n\t}\n\t/* x->algo.flags = sa->sadb_sa_flags; */\n\n\tx->props.family = pfkey_sadb_addr2xfrm_addr((struct sadb_address *) ext_hdrs[SADB_EXT_ADDRESS_SRC-1],\n\t\t\t\t\t\t    &x->props.saddr);\n\tpfkey_sadb_addr2xfrm_addr((struct sadb_address *) ext_hdrs[SADB_EXT_ADDRESS_DST-1],\n\t\t\t\t  &x->id.daddr);\n\n\tif (ext_hdrs[SADB_X_EXT_SA2-1]) {\n\t\tconst struct sadb_x_sa2 *sa2 = ext_hdrs[SADB_X_EXT_SA2-1];\n\t\tint mode = pfkey_mode_to_xfrm(sa2->sadb_x_sa2_mode);\n\t\tif (mode < 0) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tx->props.mode = mode;\n\t\tx->props.reqid = sa2->sadb_x_sa2_reqid;\n\t}\n\n\tif (ext_hdrs[SADB_EXT_ADDRESS_PROXY-1]) {\n\t\tconst struct sadb_address *addr = ext_hdrs[SADB_EXT_ADDRESS_PROXY-1];\n\n\t\t/* Nobody uses this, but we try. */\n\t\tx->sel.family = pfkey_sadb_addr2xfrm_addr(addr, &x->sel.saddr);\n\t\tx->sel.prefixlen_s = addr->sadb_address_prefixlen;\n\t}\n\n\tif (!x->sel.family)\n\t\tx->sel.family = x->props.family;\n\n\tif (ext_hdrs[SADB_X_EXT_NAT_T_TYPE-1]) {\n\t\tconst struct sadb_x_nat_t_type* n_type;\n\t\tstruct xfrm_encap_tmpl *natt;\n\n\t\tx->encap = kmalloc(sizeof(*x->encap), GFP_KERNEL);\n\t\tif (!x->encap) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tnatt = x->encap;\n\t\tn_type = ext_hdrs[SADB_X_EXT_NAT_T_TYPE-1];\n\t\tnatt->encap_type = n_type->sadb_x_nat_t_type_type;\n\n\t\tif (ext_hdrs[SADB_X_EXT_NAT_T_SPORT-1]) {\n\t\t\tconst struct sadb_x_nat_t_port *n_port =\n\t\t\t\text_hdrs[SADB_X_EXT_NAT_T_SPORT-1];\n\t\t\tnatt->encap_sport = n_port->sadb_x_nat_t_port_port;\n\t\t}\n\t\tif (ext_hdrs[SADB_X_EXT_NAT_T_DPORT-1]) {\n\t\t\tconst struct sadb_x_nat_t_port *n_port =\n\t\t\t\text_hdrs[SADB_X_EXT_NAT_T_DPORT-1];\n\t\t\tnatt->encap_dport = n_port->sadb_x_nat_t_port_port;\n\t\t}\n\t\tmemset(&natt->encap_oa, 0, sizeof(natt->encap_oa));\n\t}\n\n\terr = xfrm_init_state(x);\n\tif (err)\n\t\tgoto out;\n\n\tx->km.seq = hdr->sadb_msg_seq;\n\treturn x;\n\nout:\n\tx->km.state = XFRM_STATE_DEAD;\n\txfrm_state_put(x);\n\treturn ERR_PTR(err);\n}\n\nstatic int pfkey_reserved(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic int pfkey_getspi(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct sk_buff *resp_skb;\n\tstruct sadb_x_sa2 *sa2;\n\tstruct sadb_address *saddr, *daddr;\n\tstruct sadb_msg *out_hdr;\n\tstruct sadb_spirange *range;\n\tstruct xfrm_state *x = NULL;\n\tint mode;\n\tint err;\n\tu32 min_spi, max_spi;\n\tu32 reqid;\n\tu8 proto;\n\tunsigned short family;\n\txfrm_address_t *xsaddr = NULL, *xdaddr = NULL;\n\n\tif (!present_and_same_family(ext_hdrs[SADB_EXT_ADDRESS_SRC-1],\n\t\t\t\t     ext_hdrs[SADB_EXT_ADDRESS_DST-1]))\n\t\treturn -EINVAL;\n\n\tproto = pfkey_satype2proto(hdr->sadb_msg_satype);\n\tif (proto == 0)\n\t\treturn -EINVAL;\n\n\tif ((sa2 = ext_hdrs[SADB_X_EXT_SA2-1]) != NULL) {\n\t\tmode = pfkey_mode_to_xfrm(sa2->sadb_x_sa2_mode);\n\t\tif (mode < 0)\n\t\t\treturn -EINVAL;\n\t\treqid = sa2->sadb_x_sa2_reqid;\n\t} else {\n\t\tmode = 0;\n\t\treqid = 0;\n\t}\n\n\tsaddr = ext_hdrs[SADB_EXT_ADDRESS_SRC-1];\n\tdaddr = ext_hdrs[SADB_EXT_ADDRESS_DST-1];\n\n\tfamily = ((struct sockaddr *)(saddr + 1))->sa_family;\n\tswitch (family) {\n\tcase AF_INET:\n\t\txdaddr = (xfrm_address_t *)&((struct sockaddr_in *)(daddr + 1))->sin_addr.s_addr;\n\t\txsaddr = (xfrm_address_t *)&((struct sockaddr_in *)(saddr + 1))->sin_addr.s_addr;\n\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase AF_INET6:\n\t\txdaddr = (xfrm_address_t *)&((struct sockaddr_in6 *)(daddr + 1))->sin6_addr;\n\t\txsaddr = (xfrm_address_t *)&((struct sockaddr_in6 *)(saddr + 1))->sin6_addr;\n\t\tbreak;\n#endif\n\t}\n\n\tif (hdr->sadb_msg_seq) {\n\t\tx = xfrm_find_acq_byseq(net, DUMMY_MARK, hdr->sadb_msg_seq);\n\t\tif (x && !xfrm_addr_equal(&x->id.daddr, xdaddr, family)) {\n\t\t\txfrm_state_put(x);\n\t\t\tx = NULL;\n\t\t}\n\t}\n\n\tif (!x)\n\t\tx = xfrm_find_acq(net, &dummy_mark, mode, reqid, 0, proto, xdaddr, xsaddr, 1, family);\n\n\tif (x == NULL)\n\t\treturn -ENOENT;\n\n\tmin_spi = 0x100;\n\tmax_spi = 0x0fffffff;\n\n\trange = ext_hdrs[SADB_EXT_SPIRANGE-1];\n\tif (range) {\n\t\tmin_spi = range->sadb_spirange_min;\n\t\tmax_spi = range->sadb_spirange_max;\n\t}\n\n\terr = verify_spi_info(x->id.proto, min_spi, max_spi);\n\tif (err) {\n\t\txfrm_state_put(x);\n\t\treturn err;\n\t}\n\n\terr = xfrm_alloc_spi(x, min_spi, max_spi);\n\tresp_skb = err ? ERR_PTR(err) : pfkey_xfrm_state2msg(x);\n\n\tif (IS_ERR(resp_skb)) {\n\t\txfrm_state_put(x);\n\t\treturn  PTR_ERR(resp_skb);\n\t}\n\n\tout_hdr = (struct sadb_msg *) resp_skb->data;\n\tout_hdr->sadb_msg_version = hdr->sadb_msg_version;\n\tout_hdr->sadb_msg_type = SADB_GETSPI;\n\tout_hdr->sadb_msg_satype = pfkey_proto2satype(proto);\n\tout_hdr->sadb_msg_errno = 0;\n\tout_hdr->sadb_msg_reserved = 0;\n\tout_hdr->sadb_msg_seq = hdr->sadb_msg_seq;\n\tout_hdr->sadb_msg_pid = hdr->sadb_msg_pid;\n\n\txfrm_state_put(x);\n\n\tpfkey_broadcast(resp_skb, GFP_KERNEL, BROADCAST_ONE, sk, net);\n\n\treturn 0;\n}\n\nstatic int pfkey_acquire(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct xfrm_state *x;\n\n\tif (hdr->sadb_msg_len != sizeof(struct sadb_msg)/8)\n\t\treturn -EOPNOTSUPP;\n\n\tif (hdr->sadb_msg_seq == 0 || hdr->sadb_msg_errno == 0)\n\t\treturn 0;\n\n\tx = xfrm_find_acq_byseq(net, DUMMY_MARK, hdr->sadb_msg_seq);\n\tif (x == NULL)\n\t\treturn 0;\n\n\tspin_lock_bh(&x->lock);\n\tif (x->km.state == XFRM_STATE_ACQ)\n\t\tx->km.state = XFRM_STATE_ERROR;\n\n\tspin_unlock_bh(&x->lock);\n\txfrm_state_put(x);\n\treturn 0;\n}\n\nstatic inline int event2poltype(int event)\n{\n\tswitch (event) {\n\tcase XFRM_MSG_DELPOLICY:\n\t\treturn SADB_X_SPDDELETE;\n\tcase XFRM_MSG_NEWPOLICY:\n\t\treturn SADB_X_SPDADD;\n\tcase XFRM_MSG_UPDPOLICY:\n\t\treturn SADB_X_SPDUPDATE;\n\tcase XFRM_MSG_POLEXPIRE:\n\t//\treturn SADB_X_SPDEXPIRE;\n\tdefault:\n\t\tpr_err(\"pfkey: Unknown policy event %d\\n\", event);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic inline int event2keytype(int event)\n{\n\tswitch (event) {\n\tcase XFRM_MSG_DELSA:\n\t\treturn SADB_DELETE;\n\tcase XFRM_MSG_NEWSA:\n\t\treturn SADB_ADD;\n\tcase XFRM_MSG_UPDSA:\n\t\treturn SADB_UPDATE;\n\tcase XFRM_MSG_EXPIRE:\n\t\treturn SADB_EXPIRE;\n\tdefault:\n\t\tpr_err(\"pfkey: Unknown SA event %d\\n\", event);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n/* ADD/UPD/DEL */\nstatic int key_notify_sa(struct xfrm_state *x, const struct km_event *c)\n{\n\tstruct sk_buff *skb;\n\tstruct sadb_msg *hdr;\n\n\tskb = pfkey_xfrm_state2msg(x);\n\n\tif (IS_ERR(skb))\n\t\treturn PTR_ERR(skb);\n\n\thdr = (struct sadb_msg *) skb->data;\n\thdr->sadb_msg_version = PF_KEY_V2;\n\thdr->sadb_msg_type = event2keytype(c->event);\n\thdr->sadb_msg_satype = pfkey_proto2satype(x->id.proto);\n\thdr->sadb_msg_errno = 0;\n\thdr->sadb_msg_reserved = 0;\n\thdr->sadb_msg_seq = c->seq;\n\thdr->sadb_msg_pid = c->portid;\n\n\tpfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_ALL, NULL, xs_net(x));\n\n\treturn 0;\n}\n\nstatic int pfkey_add(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct xfrm_state *x;\n\tint err;\n\tstruct km_event c;\n\n\tx = pfkey_msg2xfrm_state(net, hdr, ext_hdrs);\n\tif (IS_ERR(x))\n\t\treturn PTR_ERR(x);\n\n\txfrm_state_hold(x);\n\tif (hdr->sadb_msg_type == SADB_ADD)\n\t\terr = xfrm_state_add(x);\n\telse\n\t\terr = xfrm_state_update(x);\n\n\txfrm_audit_state_add(x, err ? 0 : 1, true);\n\n\tif (err < 0) {\n\t\tx->km.state = XFRM_STATE_DEAD;\n\t\t__xfrm_state_put(x);\n\t\tgoto out;\n\t}\n\n\tif (hdr->sadb_msg_type == SADB_ADD)\n\t\tc.event = XFRM_MSG_NEWSA;\n\telse\n\t\tc.event = XFRM_MSG_UPDSA;\n\tc.seq = hdr->sadb_msg_seq;\n\tc.portid = hdr->sadb_msg_pid;\n\tkm_state_notify(x, &c);\nout:\n\txfrm_state_put(x);\n\treturn err;\n}\n\nstatic int pfkey_delete(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct xfrm_state *x;\n\tstruct km_event c;\n\tint err;\n\n\tif (!ext_hdrs[SADB_EXT_SA-1] ||\n\t    !present_and_same_family(ext_hdrs[SADB_EXT_ADDRESS_SRC-1],\n\t\t\t\t     ext_hdrs[SADB_EXT_ADDRESS_DST-1]))\n\t\treturn -EINVAL;\n\n\tx = pfkey_xfrm_state_lookup(net, hdr, ext_hdrs);\n\tif (x == NULL)\n\t\treturn -ESRCH;\n\n\tif ((err = security_xfrm_state_delete(x)))\n\t\tgoto out;\n\n\tif (xfrm_state_kern(x)) {\n\t\terr = -EPERM;\n\t\tgoto out;\n\t}\n\n\terr = xfrm_state_delete(x);\n\n\tif (err < 0)\n\t\tgoto out;\n\n\tc.seq = hdr->sadb_msg_seq;\n\tc.portid = hdr->sadb_msg_pid;\n\tc.event = XFRM_MSG_DELSA;\n\tkm_state_notify(x, &c);\nout:\n\txfrm_audit_state_delete(x, err ? 0 : 1, true);\n\txfrm_state_put(x);\n\n\treturn err;\n}\n\nstatic int pfkey_get(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct net *net = sock_net(sk);\n\t__u8 proto;\n\tstruct sk_buff *out_skb;\n\tstruct sadb_msg *out_hdr;\n\tstruct xfrm_state *x;\n\n\tif (!ext_hdrs[SADB_EXT_SA-1] ||\n\t    !present_and_same_family(ext_hdrs[SADB_EXT_ADDRESS_SRC-1],\n\t\t\t\t     ext_hdrs[SADB_EXT_ADDRESS_DST-1]))\n\t\treturn -EINVAL;\n\n\tx = pfkey_xfrm_state_lookup(net, hdr, ext_hdrs);\n\tif (x == NULL)\n\t\treturn -ESRCH;\n\n\tout_skb = pfkey_xfrm_state2msg(x);\n\tproto = x->id.proto;\n\txfrm_state_put(x);\n\tif (IS_ERR(out_skb))\n\t\treturn  PTR_ERR(out_skb);\n\n\tout_hdr = (struct sadb_msg *) out_skb->data;\n\tout_hdr->sadb_msg_version = hdr->sadb_msg_version;\n\tout_hdr->sadb_msg_type = SADB_GET;\n\tout_hdr->sadb_msg_satype = pfkey_proto2satype(proto);\n\tout_hdr->sadb_msg_errno = 0;\n\tout_hdr->sadb_msg_reserved = 0;\n\tout_hdr->sadb_msg_seq = hdr->sadb_msg_seq;\n\tout_hdr->sadb_msg_pid = hdr->sadb_msg_pid;\n\tpfkey_broadcast(out_skb, GFP_ATOMIC, BROADCAST_ONE, sk, sock_net(sk));\n\n\treturn 0;\n}\n\nstatic struct sk_buff *compose_sadb_supported(const struct sadb_msg *orig,\n\t\t\t\t\t      gfp_t allocation)\n{\n\tstruct sk_buff *skb;\n\tstruct sadb_msg *hdr;\n\tint len, auth_len, enc_len, i;\n\n\tauth_len = xfrm_count_pfkey_auth_supported();\n\tif (auth_len) {\n\t\tauth_len *= sizeof(struct sadb_alg);\n\t\tauth_len += sizeof(struct sadb_supported);\n\t}\n\n\tenc_len = xfrm_count_pfkey_enc_supported();\n\tif (enc_len) {\n\t\tenc_len *= sizeof(struct sadb_alg);\n\t\tenc_len += sizeof(struct sadb_supported);\n\t}\n\n\tlen = enc_len + auth_len + sizeof(struct sadb_msg);\n\n\tskb = alloc_skb(len + 16, allocation);\n\tif (!skb)\n\t\tgoto out_put_algs;\n\n\thdr = skb_put(skb, sizeof(*hdr));\n\tpfkey_hdr_dup(hdr, orig);\n\thdr->sadb_msg_errno = 0;\n\thdr->sadb_msg_len = len / sizeof(uint64_t);\n\n\tif (auth_len) {\n\t\tstruct sadb_supported *sp;\n\t\tstruct sadb_alg *ap;\n\n\t\tsp = skb_put(skb, auth_len);\n\t\tap = (struct sadb_alg *) (sp + 1);\n\n\t\tsp->sadb_supported_len = auth_len / sizeof(uint64_t);\n\t\tsp->sadb_supported_exttype = SADB_EXT_SUPPORTED_AUTH;\n\n\t\tfor (i = 0; ; i++) {\n\t\t\tstruct xfrm_algo_desc *aalg = xfrm_aalg_get_byidx(i);\n\t\t\tif (!aalg)\n\t\t\t\tbreak;\n\t\t\tif (!aalg->pfkey_supported)\n\t\t\t\tcontinue;\n\t\t\tif (aalg->available)\n\t\t\t\t*ap++ = aalg->desc;\n\t\t}\n\t}\n\n\tif (enc_len) {\n\t\tstruct sadb_supported *sp;\n\t\tstruct sadb_alg *ap;\n\n\t\tsp = skb_put(skb, enc_len);\n\t\tap = (struct sadb_alg *) (sp + 1);\n\n\t\tsp->sadb_supported_len = enc_len / sizeof(uint64_t);\n\t\tsp->sadb_supported_exttype = SADB_EXT_SUPPORTED_ENCRYPT;\n\n\t\tfor (i = 0; ; i++) {\n\t\t\tstruct xfrm_algo_desc *ealg = xfrm_ealg_get_byidx(i);\n\t\t\tif (!ealg)\n\t\t\t\tbreak;\n\t\t\tif (!ealg->pfkey_supported)\n\t\t\t\tcontinue;\n\t\t\tif (ealg->available)\n\t\t\t\t*ap++ = ealg->desc;\n\t\t}\n\t}\n\nout_put_algs:\n\treturn skb;\n}\n\nstatic int pfkey_register(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct pfkey_sock *pfk = pfkey_sk(sk);\n\tstruct sk_buff *supp_skb;\n\n\tif (hdr->sadb_msg_satype > SADB_SATYPE_MAX)\n\t\treturn -EINVAL;\n\n\tif (hdr->sadb_msg_satype != SADB_SATYPE_UNSPEC) {\n\t\tif (pfk->registered&(1<<hdr->sadb_msg_satype))\n\t\t\treturn -EEXIST;\n\t\tpfk->registered |= (1<<hdr->sadb_msg_satype);\n\t}\n\n\txfrm_probe_algs();\n\n\tsupp_skb = compose_sadb_supported(hdr, GFP_KERNEL);\n\tif (!supp_skb) {\n\t\tif (hdr->sadb_msg_satype != SADB_SATYPE_UNSPEC)\n\t\t\tpfk->registered &= ~(1<<hdr->sadb_msg_satype);\n\n\t\treturn -ENOBUFS;\n\t}\n\n\tpfkey_broadcast(supp_skb, GFP_KERNEL, BROADCAST_REGISTERED, sk,\n\t\t\tsock_net(sk));\n\treturn 0;\n}\n\nstatic int unicast_flush_resp(struct sock *sk, const struct sadb_msg *ihdr)\n{\n\tstruct sk_buff *skb;\n\tstruct sadb_msg *hdr;\n\n\tskb = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn -ENOBUFS;\n\n\thdr = skb_put_data(skb, ihdr, sizeof(struct sadb_msg));\n\thdr->sadb_msg_errno = (uint8_t) 0;\n\thdr->sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));\n\n\treturn pfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_ONE, sk,\n\t\t\t       sock_net(sk));\n}\n\nstatic int key_notify_sa_flush(const struct km_event *c)\n{\n\tstruct sk_buff *skb;\n\tstruct sadb_msg *hdr;\n\n\tskb = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn -ENOBUFS;\n\thdr = skb_put(skb, sizeof(struct sadb_msg));\n\thdr->sadb_msg_satype = pfkey_proto2satype(c->data.proto);\n\thdr->sadb_msg_type = SADB_FLUSH;\n\thdr->sadb_msg_seq = c->seq;\n\thdr->sadb_msg_pid = c->portid;\n\thdr->sadb_msg_version = PF_KEY_V2;\n\thdr->sadb_msg_errno = (uint8_t) 0;\n\thdr->sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));\n\thdr->sadb_msg_reserved = 0;\n\n\tpfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_ALL, NULL, c->net);\n\n\treturn 0;\n}\n\nstatic int pfkey_flush(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct net *net = sock_net(sk);\n\tunsigned int proto;\n\tstruct km_event c;\n\tint err, err2;\n\n\tproto = pfkey_satype2proto(hdr->sadb_msg_satype);\n\tif (proto == 0)\n\t\treturn -EINVAL;\n\n\terr = xfrm_state_flush(net, proto, true, false);\n\terr2 = unicast_flush_resp(sk, hdr);\n\tif (err || err2) {\n\t\tif (err == -ESRCH) /* empty table - go quietly */\n\t\t\terr = 0;\n\t\treturn err ? err : err2;\n\t}\n\n\tc.data.proto = proto;\n\tc.seq = hdr->sadb_msg_seq;\n\tc.portid = hdr->sadb_msg_pid;\n\tc.event = XFRM_MSG_FLUSHSA;\n\tc.net = net;\n\tkm_state_notify(NULL, &c);\n\n\treturn 0;\n}\n\nstatic int dump_sa(struct xfrm_state *x, int count, void *ptr)\n{\n\tstruct pfkey_sock *pfk = ptr;\n\tstruct sk_buff *out_skb;\n\tstruct sadb_msg *out_hdr;\n\n\tif (!pfkey_can_dump(&pfk->sk))\n\t\treturn -ENOBUFS;\n\n\tout_skb = pfkey_xfrm_state2msg(x);\n\tif (IS_ERR(out_skb))\n\t\treturn PTR_ERR(out_skb);\n\n\tout_hdr = (struct sadb_msg *) out_skb->data;\n\tout_hdr->sadb_msg_version = pfk->dump.msg_version;\n\tout_hdr->sadb_msg_type = SADB_DUMP;\n\tout_hdr->sadb_msg_satype = pfkey_proto2satype(x->id.proto);\n\tout_hdr->sadb_msg_errno = 0;\n\tout_hdr->sadb_msg_reserved = 0;\n\tout_hdr->sadb_msg_seq = count + 1;\n\tout_hdr->sadb_msg_pid = pfk->dump.msg_portid;\n\n\tif (pfk->dump.skb)\n\t\tpfkey_broadcast(pfk->dump.skb, GFP_ATOMIC, BROADCAST_ONE,\n\t\t\t\t&pfk->sk, sock_net(&pfk->sk));\n\tpfk->dump.skb = out_skb;\n\n\treturn 0;\n}\n\nstatic int pfkey_dump_sa(struct pfkey_sock *pfk)\n{\n\tstruct net *net = sock_net(&pfk->sk);\n\treturn xfrm_state_walk(net, &pfk->dump.u.state, dump_sa, (void *) pfk);\n}\n\nstatic void pfkey_dump_sa_done(struct pfkey_sock *pfk)\n{\n\tstruct net *net = sock_net(&pfk->sk);\n\n\txfrm_state_walk_done(&pfk->dump.u.state, net);\n}\n\nstatic int pfkey_dump(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tu8 proto;\n\tstruct xfrm_address_filter *filter = NULL;\n\tstruct pfkey_sock *pfk = pfkey_sk(sk);\n\n\tmutex_lock(&pfk->dump_lock);\n\tif (pfk->dump.dump != NULL) {\n\t\tmutex_unlock(&pfk->dump_lock);\n\t\treturn -EBUSY;\n\t}\n\n\tproto = pfkey_satype2proto(hdr->sadb_msg_satype);\n\tif (proto == 0) {\n\t\tmutex_unlock(&pfk->dump_lock);\n\t\treturn -EINVAL;\n\t}\n\n\tif (ext_hdrs[SADB_X_EXT_FILTER - 1]) {\n\t\tstruct sadb_x_filter *xfilter = ext_hdrs[SADB_X_EXT_FILTER - 1];\n\n\t\tif ((xfilter->sadb_x_filter_splen >=\n\t\t\t(sizeof(xfrm_address_t) << 3)) ||\n\t\t    (xfilter->sadb_x_filter_dplen >=\n\t\t\t(sizeof(xfrm_address_t) << 3))) {\n\t\t\tmutex_unlock(&pfk->dump_lock);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tfilter = kmalloc(sizeof(*filter), GFP_KERNEL);\n\t\tif (filter == NULL) {\n\t\t\tmutex_unlock(&pfk->dump_lock);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tmemcpy(&filter->saddr, &xfilter->sadb_x_filter_saddr,\n\t\t       sizeof(xfrm_address_t));\n\t\tmemcpy(&filter->daddr, &xfilter->sadb_x_filter_daddr,\n\t\t       sizeof(xfrm_address_t));\n\t\tfilter->family = xfilter->sadb_x_filter_family;\n\t\tfilter->splen = xfilter->sadb_x_filter_splen;\n\t\tfilter->dplen = xfilter->sadb_x_filter_dplen;\n\t}\n\n\tpfk->dump.msg_version = hdr->sadb_msg_version;\n\tpfk->dump.msg_portid = hdr->sadb_msg_pid;\n\tpfk->dump.dump = pfkey_dump_sa;\n\tpfk->dump.done = pfkey_dump_sa_done;\n\txfrm_state_walk_init(&pfk->dump.u.state, proto, filter);\n\tmutex_unlock(&pfk->dump_lock);\n\n\treturn pfkey_do_dump(pfk);\n}\n\nstatic int pfkey_promisc(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct pfkey_sock *pfk = pfkey_sk(sk);\n\tint satype = hdr->sadb_msg_satype;\n\tbool reset_errno = false;\n\n\tif (hdr->sadb_msg_len == (sizeof(*hdr) / sizeof(uint64_t))) {\n\t\treset_errno = true;\n\t\tif (satype != 0 && satype != 1)\n\t\t\treturn -EINVAL;\n\t\tpfk->promisc = satype;\n\t}\n\tif (reset_errno && skb_cloned(skb))\n\t\tskb = skb_copy(skb, GFP_KERNEL);\n\telse\n\t\tskb = skb_clone(skb, GFP_KERNEL);\n\n\tif (reset_errno && skb) {\n\t\tstruct sadb_msg *new_hdr = (struct sadb_msg *) skb->data;\n\t\tnew_hdr->sadb_msg_errno = 0;\n\t}\n\n\tpfkey_broadcast(skb, GFP_KERNEL, BROADCAST_ALL, NULL, sock_net(sk));\n\treturn 0;\n}\n\nstatic int check_reqid(struct xfrm_policy *xp, int dir, int count, void *ptr)\n{\n\tint i;\n\tu32 reqid = *(u32*)ptr;\n\n\tfor (i=0; i<xp->xfrm_nr; i++) {\n\t\tif (xp->xfrm_vec[i].reqid == reqid)\n\t\t\treturn -EEXIST;\n\t}\n\treturn 0;\n}\n\nstatic u32 gen_reqid(struct net *net)\n{\n\tstruct xfrm_policy_walk walk;\n\tu32 start;\n\tint rc;\n\tstatic u32 reqid = IPSEC_MANUAL_REQID_MAX;\n\n\tstart = reqid;\n\tdo {\n\t\t++reqid;\n\t\tif (reqid == 0)\n\t\t\treqid = IPSEC_MANUAL_REQID_MAX+1;\n\t\txfrm_policy_walk_init(&walk, XFRM_POLICY_TYPE_MAIN);\n\t\trc = xfrm_policy_walk(net, &walk, check_reqid, (void*)&reqid);\n\t\txfrm_policy_walk_done(&walk, net);\n\t\tif (rc != -EEXIST)\n\t\t\treturn reqid;\n\t} while (reqid != start);\n\treturn 0;\n}\n\nstatic int\nparse_ipsecrequest(struct xfrm_policy *xp, struct sadb_x_ipsecrequest *rq)\n{\n\tstruct net *net = xp_net(xp);\n\tstruct xfrm_tmpl *t = xp->xfrm_vec + xp->xfrm_nr;\n\tint mode;\n\n\tif (xp->xfrm_nr >= XFRM_MAX_DEPTH)\n\t\treturn -ELOOP;\n\n\tif (rq->sadb_x_ipsecrequest_mode == 0)\n\t\treturn -EINVAL;\n\tif (!xfrm_id_proto_valid(rq->sadb_x_ipsecrequest_proto))\n\t\treturn -EINVAL;\n\n\tt->id.proto = rq->sadb_x_ipsecrequest_proto;\n\tif ((mode = pfkey_mode_to_xfrm(rq->sadb_x_ipsecrequest_mode)) < 0)\n\t\treturn -EINVAL;\n\tt->mode = mode;\n\tif (rq->sadb_x_ipsecrequest_level == IPSEC_LEVEL_USE)\n\t\tt->optional = 1;\n\telse if (rq->sadb_x_ipsecrequest_level == IPSEC_LEVEL_UNIQUE) {\n\t\tt->reqid = rq->sadb_x_ipsecrequest_reqid;\n\t\tif (t->reqid > IPSEC_MANUAL_REQID_MAX)\n\t\t\tt->reqid = 0;\n\t\tif (!t->reqid && !(t->reqid = gen_reqid(net)))\n\t\t\treturn -ENOBUFS;\n\t}\n\n\t/* addresses present only in tunnel mode */\n\tif (t->mode == XFRM_MODE_TUNNEL) {\n\t\tint err;\n\n\t\terr = parse_sockaddr_pair(\n\t\t\t(struct sockaddr *)(rq + 1),\n\t\t\trq->sadb_x_ipsecrequest_len - sizeof(*rq),\n\t\t\t&t->saddr, &t->id.daddr, &t->encap_family);\n\t\tif (err)\n\t\t\treturn err;\n\t} else\n\t\tt->encap_family = xp->family;\n\n\t/* No way to set this via kame pfkey */\n\tt->allalgs = 1;\n\txp->xfrm_nr++;\n\treturn 0;\n}\n\nstatic int\nparse_ipsecrequests(struct xfrm_policy *xp, struct sadb_x_policy *pol)\n{\n\tint err;\n\tint len = pol->sadb_x_policy_len*8 - sizeof(struct sadb_x_policy);\n\tstruct sadb_x_ipsecrequest *rq = (void*)(pol+1);\n\n\tif (pol->sadb_x_policy_len * 8 < sizeof(struct sadb_x_policy))\n\t\treturn -EINVAL;\n\n\twhile (len >= sizeof(*rq)) {\n\t\tif (len < rq->sadb_x_ipsecrequest_len ||\n\t\t    rq->sadb_x_ipsecrequest_len < sizeof(*rq))\n\t\t\treturn -EINVAL;\n\n\t\tif ((err = parse_ipsecrequest(xp, rq)) < 0)\n\t\t\treturn err;\n\t\tlen -= rq->sadb_x_ipsecrequest_len;\n\t\trq = (void*)((u8*)rq + rq->sadb_x_ipsecrequest_len);\n\t}\n\treturn 0;\n}\n\nstatic inline int pfkey_xfrm_policy2sec_ctx_size(const struct xfrm_policy *xp)\n{\n\tstruct xfrm_sec_ctx *xfrm_ctx = xp->security;\n\n\tif (xfrm_ctx) {\n\t\tint len = sizeof(struct sadb_x_sec_ctx);\n\t\tlen += xfrm_ctx->ctx_len;\n\t\treturn PFKEY_ALIGN8(len);\n\t}\n\treturn 0;\n}\n\nstatic int pfkey_xfrm_policy2msg_size(const struct xfrm_policy *xp)\n{\n\tconst struct xfrm_tmpl *t;\n\tint sockaddr_size = pfkey_sockaddr_size(xp->family);\n\tint socklen = 0;\n\tint i;\n\n\tfor (i=0; i<xp->xfrm_nr; i++) {\n\t\tt = xp->xfrm_vec + i;\n\t\tsocklen += pfkey_sockaddr_len(t->encap_family);\n\t}\n\n\treturn sizeof(struct sadb_msg) +\n\t\t(sizeof(struct sadb_lifetime) * 3) +\n\t\t(sizeof(struct sadb_address) * 2) +\n\t\t(sockaddr_size * 2) +\n\t\tsizeof(struct sadb_x_policy) +\n\t\t(xp->xfrm_nr * sizeof(struct sadb_x_ipsecrequest)) +\n\t\t(socklen * 2) +\n\t\tpfkey_xfrm_policy2sec_ctx_size(xp);\n}\n\nstatic struct sk_buff * pfkey_xfrm_policy2msg_prep(const struct xfrm_policy *xp)\n{\n\tstruct sk_buff *skb;\n\tint size;\n\n\tsize = pfkey_xfrm_policy2msg_size(xp);\n\n\tskb =  alloc_skb(size + 16, GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn ERR_PTR(-ENOBUFS);\n\n\treturn skb;\n}\n\nstatic int pfkey_xfrm_policy2msg(struct sk_buff *skb, const struct xfrm_policy *xp, int dir)\n{\n\tstruct sadb_msg *hdr;\n\tstruct sadb_address *addr;\n\tstruct sadb_lifetime *lifetime;\n\tstruct sadb_x_policy *pol;\n\tstruct sadb_x_sec_ctx *sec_ctx;\n\tstruct xfrm_sec_ctx *xfrm_ctx;\n\tint i;\n\tint size;\n\tint sockaddr_size = pfkey_sockaddr_size(xp->family);\n\tint socklen = pfkey_sockaddr_len(xp->family);\n\n\tsize = pfkey_xfrm_policy2msg_size(xp);\n\n\t/* call should fill header later */\n\thdr = skb_put(skb, sizeof(struct sadb_msg));\n\tmemset(hdr, 0, size);\t/* XXX do we need this ? */\n\n\t/* src address */\n\taddr = skb_put(skb, sizeof(struct sadb_address) + sockaddr_size);\n\taddr->sadb_address_len =\n\t\t(sizeof(struct sadb_address)+sockaddr_size)/\n\t\t\tsizeof(uint64_t);\n\taddr->sadb_address_exttype = SADB_EXT_ADDRESS_SRC;\n\taddr->sadb_address_proto = pfkey_proto_from_xfrm(xp->selector.proto);\n\taddr->sadb_address_prefixlen = xp->selector.prefixlen_s;\n\taddr->sadb_address_reserved = 0;\n\tif (!pfkey_sockaddr_fill(&xp->selector.saddr,\n\t\t\t\t xp->selector.sport,\n\t\t\t\t (struct sockaddr *) (addr + 1),\n\t\t\t\t xp->family))\n\t\tBUG();\n\n\t/* dst address */\n\taddr = skb_put(skb, sizeof(struct sadb_address) + sockaddr_size);\n\taddr->sadb_address_len =\n\t\t(sizeof(struct sadb_address)+sockaddr_size)/\n\t\t\tsizeof(uint64_t);\n\taddr->sadb_address_exttype = SADB_EXT_ADDRESS_DST;\n\taddr->sadb_address_proto = pfkey_proto_from_xfrm(xp->selector.proto);\n\taddr->sadb_address_prefixlen = xp->selector.prefixlen_d;\n\taddr->sadb_address_reserved = 0;\n\n\tpfkey_sockaddr_fill(&xp->selector.daddr, xp->selector.dport,\n\t\t\t    (struct sockaddr *) (addr + 1),\n\t\t\t    xp->family);\n\n\t/* hard time */\n\tlifetime = skb_put(skb, sizeof(struct sadb_lifetime));\n\tlifetime->sadb_lifetime_len =\n\t\tsizeof(struct sadb_lifetime)/sizeof(uint64_t);\n\tlifetime->sadb_lifetime_exttype = SADB_EXT_LIFETIME_HARD;\n\tlifetime->sadb_lifetime_allocations =  _X2KEY(xp->lft.hard_packet_limit);\n\tlifetime->sadb_lifetime_bytes = _X2KEY(xp->lft.hard_byte_limit);\n\tlifetime->sadb_lifetime_addtime = xp->lft.hard_add_expires_seconds;\n\tlifetime->sadb_lifetime_usetime = xp->lft.hard_use_expires_seconds;\n\t/* soft time */\n\tlifetime = skb_put(skb, sizeof(struct sadb_lifetime));\n\tlifetime->sadb_lifetime_len =\n\t\tsizeof(struct sadb_lifetime)/sizeof(uint64_t);\n\tlifetime->sadb_lifetime_exttype = SADB_EXT_LIFETIME_SOFT;\n\tlifetime->sadb_lifetime_allocations =  _X2KEY(xp->lft.soft_packet_limit);\n\tlifetime->sadb_lifetime_bytes = _X2KEY(xp->lft.soft_byte_limit);\n\tlifetime->sadb_lifetime_addtime = xp->lft.soft_add_expires_seconds;\n\tlifetime->sadb_lifetime_usetime = xp->lft.soft_use_expires_seconds;\n\t/* current time */\n\tlifetime = skb_put(skb, sizeof(struct sadb_lifetime));\n\tlifetime->sadb_lifetime_len =\n\t\tsizeof(struct sadb_lifetime)/sizeof(uint64_t);\n\tlifetime->sadb_lifetime_exttype = SADB_EXT_LIFETIME_CURRENT;\n\tlifetime->sadb_lifetime_allocations = xp->curlft.packets;\n\tlifetime->sadb_lifetime_bytes = xp->curlft.bytes;\n\tlifetime->sadb_lifetime_addtime = xp->curlft.add_time;\n\tlifetime->sadb_lifetime_usetime = xp->curlft.use_time;\n\n\tpol = skb_put(skb, sizeof(struct sadb_x_policy));\n\tpol->sadb_x_policy_len = sizeof(struct sadb_x_policy)/sizeof(uint64_t);\n\tpol->sadb_x_policy_exttype = SADB_X_EXT_POLICY;\n\tpol->sadb_x_policy_type = IPSEC_POLICY_DISCARD;\n\tif (xp->action == XFRM_POLICY_ALLOW) {\n\t\tif (xp->xfrm_nr)\n\t\t\tpol->sadb_x_policy_type = IPSEC_POLICY_IPSEC;\n\t\telse\n\t\t\tpol->sadb_x_policy_type = IPSEC_POLICY_NONE;\n\t}\n\tpol->sadb_x_policy_dir = dir+1;\n\tpol->sadb_x_policy_reserved = 0;\n\tpol->sadb_x_policy_id = xp->index;\n\tpol->sadb_x_policy_priority = xp->priority;\n\n\tfor (i=0; i<xp->xfrm_nr; i++) {\n\t\tconst struct xfrm_tmpl *t = xp->xfrm_vec + i;\n\t\tstruct sadb_x_ipsecrequest *rq;\n\t\tint req_size;\n\t\tint mode;\n\n\t\treq_size = sizeof(struct sadb_x_ipsecrequest);\n\t\tif (t->mode == XFRM_MODE_TUNNEL) {\n\t\t\tsocklen = pfkey_sockaddr_len(t->encap_family);\n\t\t\treq_size += socklen * 2;\n\t\t} else {\n\t\t\tsize -= 2*socklen;\n\t\t}\n\t\trq = skb_put(skb, req_size);\n\t\tpol->sadb_x_policy_len += req_size/8;\n\t\tmemset(rq, 0, sizeof(*rq));\n\t\trq->sadb_x_ipsecrequest_len = req_size;\n\t\trq->sadb_x_ipsecrequest_proto = t->id.proto;\n\t\tif ((mode = pfkey_mode_from_xfrm(t->mode)) < 0)\n\t\t\treturn -EINVAL;\n\t\trq->sadb_x_ipsecrequest_mode = mode;\n\t\trq->sadb_x_ipsecrequest_level = IPSEC_LEVEL_REQUIRE;\n\t\tif (t->reqid)\n\t\t\trq->sadb_x_ipsecrequest_level = IPSEC_LEVEL_UNIQUE;\n\t\tif (t->optional)\n\t\t\trq->sadb_x_ipsecrequest_level = IPSEC_LEVEL_USE;\n\t\trq->sadb_x_ipsecrequest_reqid = t->reqid;\n\n\t\tif (t->mode == XFRM_MODE_TUNNEL) {\n\t\t\tu8 *sa = (void *)(rq + 1);\n\t\t\tpfkey_sockaddr_fill(&t->saddr, 0,\n\t\t\t\t\t    (struct sockaddr *)sa,\n\t\t\t\t\t    t->encap_family);\n\t\t\tpfkey_sockaddr_fill(&t->id.daddr, 0,\n\t\t\t\t\t    (struct sockaddr *) (sa + socklen),\n\t\t\t\t\t    t->encap_family);\n\t\t}\n\t}\n\n\t/* security context */\n\tif ((xfrm_ctx = xp->security)) {\n\t\tint ctx_size = pfkey_xfrm_policy2sec_ctx_size(xp);\n\n\t\tsec_ctx = skb_put(skb, ctx_size);\n\t\tsec_ctx->sadb_x_sec_len = ctx_size / sizeof(uint64_t);\n\t\tsec_ctx->sadb_x_sec_exttype = SADB_X_EXT_SEC_CTX;\n\t\tsec_ctx->sadb_x_ctx_doi = xfrm_ctx->ctx_doi;\n\t\tsec_ctx->sadb_x_ctx_alg = xfrm_ctx->ctx_alg;\n\t\tsec_ctx->sadb_x_ctx_len = xfrm_ctx->ctx_len;\n\t\tmemcpy(sec_ctx + 1, xfrm_ctx->ctx_str,\n\t\t       xfrm_ctx->ctx_len);\n\t}\n\n\thdr->sadb_msg_len = size / sizeof(uint64_t);\n\thdr->sadb_msg_reserved = refcount_read(&xp->refcnt);\n\n\treturn 0;\n}\n\nstatic int key_notify_policy(struct xfrm_policy *xp, int dir, const struct km_event *c)\n{\n\tstruct sk_buff *out_skb;\n\tstruct sadb_msg *out_hdr;\n\tint err;\n\n\tout_skb = pfkey_xfrm_policy2msg_prep(xp);\n\tif (IS_ERR(out_skb))\n\t\treturn PTR_ERR(out_skb);\n\n\terr = pfkey_xfrm_policy2msg(out_skb, xp, dir);\n\tif (err < 0) {\n\t\tkfree_skb(out_skb);\n\t\treturn err;\n\t}\n\n\tout_hdr = (struct sadb_msg *) out_skb->data;\n\tout_hdr->sadb_msg_version = PF_KEY_V2;\n\n\tif (c->data.byid && c->event == XFRM_MSG_DELPOLICY)\n\t\tout_hdr->sadb_msg_type = SADB_X_SPDDELETE2;\n\telse\n\t\tout_hdr->sadb_msg_type = event2poltype(c->event);\n\tout_hdr->sadb_msg_errno = 0;\n\tout_hdr->sadb_msg_seq = c->seq;\n\tout_hdr->sadb_msg_pid = c->portid;\n\tpfkey_broadcast(out_skb, GFP_ATOMIC, BROADCAST_ALL, NULL, xp_net(xp));\n\treturn 0;\n\n}\n\nstatic int pfkey_spdadd(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct net *net = sock_net(sk);\n\tint err = 0;\n\tstruct sadb_lifetime *lifetime;\n\tstruct sadb_address *sa;\n\tstruct sadb_x_policy *pol;\n\tstruct xfrm_policy *xp;\n\tstruct km_event c;\n\tstruct sadb_x_sec_ctx *sec_ctx;\n\n\tif (!present_and_same_family(ext_hdrs[SADB_EXT_ADDRESS_SRC-1],\n\t\t\t\t     ext_hdrs[SADB_EXT_ADDRESS_DST-1]) ||\n\t    !ext_hdrs[SADB_X_EXT_POLICY-1])\n\t\treturn -EINVAL;\n\n\tpol = ext_hdrs[SADB_X_EXT_POLICY-1];\n\tif (pol->sadb_x_policy_type > IPSEC_POLICY_IPSEC)\n\t\treturn -EINVAL;\n\tif (!pol->sadb_x_policy_dir || pol->sadb_x_policy_dir >= IPSEC_DIR_MAX)\n\t\treturn -EINVAL;\n\n\txp = xfrm_policy_alloc(net, GFP_KERNEL);\n\tif (xp == NULL)\n\t\treturn -ENOBUFS;\n\n\txp->action = (pol->sadb_x_policy_type == IPSEC_POLICY_DISCARD ?\n\t\t      XFRM_POLICY_BLOCK : XFRM_POLICY_ALLOW);\n\txp->priority = pol->sadb_x_policy_priority;\n\n\tsa = ext_hdrs[SADB_EXT_ADDRESS_SRC-1];\n\txp->family = pfkey_sadb_addr2xfrm_addr(sa, &xp->selector.saddr);\n\txp->selector.family = xp->family;\n\txp->selector.prefixlen_s = sa->sadb_address_prefixlen;\n\txp->selector.proto = pfkey_proto_to_xfrm(sa->sadb_address_proto);\n\txp->selector.sport = ((struct sockaddr_in *)(sa+1))->sin_port;\n\tif (xp->selector.sport)\n\t\txp->selector.sport_mask = htons(0xffff);\n\n\tsa = ext_hdrs[SADB_EXT_ADDRESS_DST-1];\n\tpfkey_sadb_addr2xfrm_addr(sa, &xp->selector.daddr);\n\txp->selector.prefixlen_d = sa->sadb_address_prefixlen;\n\n\t/* Amusing, we set this twice.  KAME apps appear to set same value\n\t * in both addresses.\n\t */\n\txp->selector.proto = pfkey_proto_to_xfrm(sa->sadb_address_proto);\n\n\txp->selector.dport = ((struct sockaddr_in *)(sa+1))->sin_port;\n\tif (xp->selector.dport)\n\t\txp->selector.dport_mask = htons(0xffff);\n\n\tsec_ctx = ext_hdrs[SADB_X_EXT_SEC_CTX - 1];\n\tif (sec_ctx != NULL) {\n\t\tstruct xfrm_user_sec_ctx *uctx = pfkey_sadb2xfrm_user_sec_ctx(sec_ctx, GFP_KERNEL);\n\n\t\tif (!uctx) {\n\t\t\terr = -ENOBUFS;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = security_xfrm_policy_alloc(&xp->security, uctx, GFP_KERNEL);\n\t\tkfree(uctx);\n\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\txp->lft.soft_byte_limit = XFRM_INF;\n\txp->lft.hard_byte_limit = XFRM_INF;\n\txp->lft.soft_packet_limit = XFRM_INF;\n\txp->lft.hard_packet_limit = XFRM_INF;\n\tif ((lifetime = ext_hdrs[SADB_EXT_LIFETIME_HARD-1]) != NULL) {\n\t\txp->lft.hard_packet_limit = _KEY2X(lifetime->sadb_lifetime_allocations);\n\t\txp->lft.hard_byte_limit = _KEY2X(lifetime->sadb_lifetime_bytes);\n\t\txp->lft.hard_add_expires_seconds = lifetime->sadb_lifetime_addtime;\n\t\txp->lft.hard_use_expires_seconds = lifetime->sadb_lifetime_usetime;\n\t}\n\tif ((lifetime = ext_hdrs[SADB_EXT_LIFETIME_SOFT-1]) != NULL) {\n\t\txp->lft.soft_packet_limit = _KEY2X(lifetime->sadb_lifetime_allocations);\n\t\txp->lft.soft_byte_limit = _KEY2X(lifetime->sadb_lifetime_bytes);\n\t\txp->lft.soft_add_expires_seconds = lifetime->sadb_lifetime_addtime;\n\t\txp->lft.soft_use_expires_seconds = lifetime->sadb_lifetime_usetime;\n\t}\n\txp->xfrm_nr = 0;\n\tif (pol->sadb_x_policy_type == IPSEC_POLICY_IPSEC &&\n\t    (err = parse_ipsecrequests(xp, pol)) < 0)\n\t\tgoto out;\n\n\terr = xfrm_policy_insert(pol->sadb_x_policy_dir-1, xp,\n\t\t\t\t hdr->sadb_msg_type != SADB_X_SPDUPDATE);\n\n\txfrm_audit_policy_add(xp, err ? 0 : 1, true);\n\n\tif (err)\n\t\tgoto out;\n\n\tif (hdr->sadb_msg_type == SADB_X_SPDUPDATE)\n\t\tc.event = XFRM_MSG_UPDPOLICY;\n\telse\n\t\tc.event = XFRM_MSG_NEWPOLICY;\n\n\tc.seq = hdr->sadb_msg_seq;\n\tc.portid = hdr->sadb_msg_pid;\n\n\tkm_policy_notify(xp, pol->sadb_x_policy_dir-1, &c);\n\txfrm_pol_put(xp);\n\treturn 0;\n\nout:\n\txp->walk.dead = 1;\n\txfrm_policy_destroy(xp);\n\treturn err;\n}\n\nstatic int pfkey_spddelete(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct net *net = sock_net(sk);\n\tint err;\n\tstruct sadb_address *sa;\n\tstruct sadb_x_policy *pol;\n\tstruct xfrm_policy *xp;\n\tstruct xfrm_selector sel;\n\tstruct km_event c;\n\tstruct sadb_x_sec_ctx *sec_ctx;\n\tstruct xfrm_sec_ctx *pol_ctx = NULL;\n\n\tif (!present_and_same_family(ext_hdrs[SADB_EXT_ADDRESS_SRC-1],\n\t\t\t\t     ext_hdrs[SADB_EXT_ADDRESS_DST-1]) ||\n\t    !ext_hdrs[SADB_X_EXT_POLICY-1])\n\t\treturn -EINVAL;\n\n\tpol = ext_hdrs[SADB_X_EXT_POLICY-1];\n\tif (!pol->sadb_x_policy_dir || pol->sadb_x_policy_dir >= IPSEC_DIR_MAX)\n\t\treturn -EINVAL;\n\n\tmemset(&sel, 0, sizeof(sel));\n\n\tsa = ext_hdrs[SADB_EXT_ADDRESS_SRC-1];\n\tsel.family = pfkey_sadb_addr2xfrm_addr(sa, &sel.saddr);\n\tsel.prefixlen_s = sa->sadb_address_prefixlen;\n\tsel.proto = pfkey_proto_to_xfrm(sa->sadb_address_proto);\n\tsel.sport = ((struct sockaddr_in *)(sa+1))->sin_port;\n\tif (sel.sport)\n\t\tsel.sport_mask = htons(0xffff);\n\n\tsa = ext_hdrs[SADB_EXT_ADDRESS_DST-1];\n\tpfkey_sadb_addr2xfrm_addr(sa, &sel.daddr);\n\tsel.prefixlen_d = sa->sadb_address_prefixlen;\n\tsel.proto = pfkey_proto_to_xfrm(sa->sadb_address_proto);\n\tsel.dport = ((struct sockaddr_in *)(sa+1))->sin_port;\n\tif (sel.dport)\n\t\tsel.dport_mask = htons(0xffff);\n\n\tsec_ctx = ext_hdrs[SADB_X_EXT_SEC_CTX - 1];\n\tif (sec_ctx != NULL) {\n\t\tstruct xfrm_user_sec_ctx *uctx = pfkey_sadb2xfrm_user_sec_ctx(sec_ctx, GFP_KERNEL);\n\n\t\tif (!uctx)\n\t\t\treturn -ENOMEM;\n\n\t\terr = security_xfrm_policy_alloc(&pol_ctx, uctx, GFP_KERNEL);\n\t\tkfree(uctx);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\txp = xfrm_policy_bysel_ctx(net, &dummy_mark, 0, XFRM_POLICY_TYPE_MAIN,\n\t\t\t\t   pol->sadb_x_policy_dir - 1, &sel, pol_ctx,\n\t\t\t\t   1, &err);\n\tsecurity_xfrm_policy_free(pol_ctx);\n\tif (xp == NULL)\n\t\treturn -ENOENT;\n\n\txfrm_audit_policy_delete(xp, err ? 0 : 1, true);\n\n\tif (err)\n\t\tgoto out;\n\n\tc.seq = hdr->sadb_msg_seq;\n\tc.portid = hdr->sadb_msg_pid;\n\tc.data.byid = 0;\n\tc.event = XFRM_MSG_DELPOLICY;\n\tkm_policy_notify(xp, pol->sadb_x_policy_dir-1, &c);\n\nout:\n\txfrm_pol_put(xp);\n\treturn err;\n}\n\nstatic int key_pol_get_resp(struct sock *sk, struct xfrm_policy *xp, const struct sadb_msg *hdr, int dir)\n{\n\tint err;\n\tstruct sk_buff *out_skb;\n\tstruct sadb_msg *out_hdr;\n\terr = 0;\n\n\tout_skb = pfkey_xfrm_policy2msg_prep(xp);\n\tif (IS_ERR(out_skb)) {\n\t\terr =  PTR_ERR(out_skb);\n\t\tgoto out;\n\t}\n\terr = pfkey_xfrm_policy2msg(out_skb, xp, dir);\n\tif (err < 0) {\n\t\tkfree_skb(out_skb);\n\t\tgoto out;\n\t}\n\n\tout_hdr = (struct sadb_msg *) out_skb->data;\n\tout_hdr->sadb_msg_version = hdr->sadb_msg_version;\n\tout_hdr->sadb_msg_type = hdr->sadb_msg_type;\n\tout_hdr->sadb_msg_satype = 0;\n\tout_hdr->sadb_msg_errno = 0;\n\tout_hdr->sadb_msg_seq = hdr->sadb_msg_seq;\n\tout_hdr->sadb_msg_pid = hdr->sadb_msg_pid;\n\tpfkey_broadcast(out_skb, GFP_ATOMIC, BROADCAST_ONE, sk, xp_net(xp));\n\terr = 0;\n\nout:\n\treturn err;\n}\n\nstatic int pfkey_sockaddr_pair_size(sa_family_t family)\n{\n\treturn PFKEY_ALIGN8(pfkey_sockaddr_len(family) * 2);\n}\n\nstatic int parse_sockaddr_pair(struct sockaddr *sa, int ext_len,\n\t\t\t       xfrm_address_t *saddr, xfrm_address_t *daddr,\n\t\t\t       u16 *family)\n{\n\tint af, socklen;\n\n\tif (ext_len < 2 || ext_len < pfkey_sockaddr_pair_size(sa->sa_family))\n\t\treturn -EINVAL;\n\n\taf = pfkey_sockaddr_extract(sa, saddr);\n\tif (!af)\n\t\treturn -EINVAL;\n\n\tsocklen = pfkey_sockaddr_len(af);\n\tif (pfkey_sockaddr_extract((struct sockaddr *) (((u8 *)sa) + socklen),\n\t\t\t\t   daddr) != af)\n\t\treturn -EINVAL;\n\n\t*family = af;\n\treturn 0;\n}\n\n#ifdef CONFIG_NET_KEY_MIGRATE\nstatic int ipsecrequests_to_migrate(struct sadb_x_ipsecrequest *rq1, int len,\n\t\t\t\t    struct xfrm_migrate *m)\n{\n\tint err;\n\tstruct sadb_x_ipsecrequest *rq2;\n\tint mode;\n\n\tif (len < sizeof(*rq1) ||\n\t    len < rq1->sadb_x_ipsecrequest_len ||\n\t    rq1->sadb_x_ipsecrequest_len < sizeof(*rq1))\n\t\treturn -EINVAL;\n\n\t/* old endoints */\n\terr = parse_sockaddr_pair((struct sockaddr *)(rq1 + 1),\n\t\t\t\t  rq1->sadb_x_ipsecrequest_len - sizeof(*rq1),\n\t\t\t\t  &m->old_saddr, &m->old_daddr,\n\t\t\t\t  &m->old_family);\n\tif (err)\n\t\treturn err;\n\n\trq2 = (struct sadb_x_ipsecrequest *)((u8 *)rq1 + rq1->sadb_x_ipsecrequest_len);\n\tlen -= rq1->sadb_x_ipsecrequest_len;\n\n\tif (len <= sizeof(*rq2) ||\n\t    len < rq2->sadb_x_ipsecrequest_len ||\n\t    rq2->sadb_x_ipsecrequest_len < sizeof(*rq2))\n\t\treturn -EINVAL;\n\n\t/* new endpoints */\n\terr = parse_sockaddr_pair((struct sockaddr *)(rq2 + 1),\n\t\t\t\t  rq2->sadb_x_ipsecrequest_len - sizeof(*rq2),\n\t\t\t\t  &m->new_saddr, &m->new_daddr,\n\t\t\t\t  &m->new_family);\n\tif (err)\n\t\treturn err;\n\n\tif (rq1->sadb_x_ipsecrequest_proto != rq2->sadb_x_ipsecrequest_proto ||\n\t    rq1->sadb_x_ipsecrequest_mode != rq2->sadb_x_ipsecrequest_mode ||\n\t    rq1->sadb_x_ipsecrequest_reqid != rq2->sadb_x_ipsecrequest_reqid)\n\t\treturn -EINVAL;\n\n\tm->proto = rq1->sadb_x_ipsecrequest_proto;\n\tif ((mode = pfkey_mode_to_xfrm(rq1->sadb_x_ipsecrequest_mode)) < 0)\n\t\treturn -EINVAL;\n\tm->mode = mode;\n\tm->reqid = rq1->sadb_x_ipsecrequest_reqid;\n\n\treturn ((int)(rq1->sadb_x_ipsecrequest_len +\n\t\t      rq2->sadb_x_ipsecrequest_len));\n}\n\nstatic int pfkey_migrate(struct sock *sk, struct sk_buff *skb,\n\t\t\t const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tint i, len, ret, err = -EINVAL;\n\tu8 dir;\n\tstruct sadb_address *sa;\n\tstruct sadb_x_kmaddress *kma;\n\tstruct sadb_x_policy *pol;\n\tstruct sadb_x_ipsecrequest *rq;\n\tstruct xfrm_selector sel;\n\tstruct xfrm_migrate m[XFRM_MAX_DEPTH];\n\tstruct xfrm_kmaddress k;\n\tstruct net *net = sock_net(sk);\n\n\tif (!present_and_same_family(ext_hdrs[SADB_EXT_ADDRESS_SRC - 1],\n\t\t\t\t     ext_hdrs[SADB_EXT_ADDRESS_DST - 1]) ||\n\t    !ext_hdrs[SADB_X_EXT_POLICY - 1]) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tkma = ext_hdrs[SADB_X_EXT_KMADDRESS - 1];\n\tpol = ext_hdrs[SADB_X_EXT_POLICY - 1];\n\n\tif (pol->sadb_x_policy_dir >= IPSEC_DIR_MAX) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (kma) {\n\t\t/* convert sadb_x_kmaddress to xfrm_kmaddress */\n\t\tk.reserved = kma->sadb_x_kmaddress_reserved;\n\t\tret = parse_sockaddr_pair((struct sockaddr *)(kma + 1),\n\t\t\t\t\t  8*(kma->sadb_x_kmaddress_len) - sizeof(*kma),\n\t\t\t\t\t  &k.local, &k.remote, &k.family);\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tdir = pol->sadb_x_policy_dir - 1;\n\tmemset(&sel, 0, sizeof(sel));\n\n\t/* set source address info of selector */\n\tsa = ext_hdrs[SADB_EXT_ADDRESS_SRC - 1];\n\tsel.family = pfkey_sadb_addr2xfrm_addr(sa, &sel.saddr);\n\tsel.prefixlen_s = sa->sadb_address_prefixlen;\n\tsel.proto = pfkey_proto_to_xfrm(sa->sadb_address_proto);\n\tsel.sport = ((struct sockaddr_in *)(sa + 1))->sin_port;\n\tif (sel.sport)\n\t\tsel.sport_mask = htons(0xffff);\n\n\t/* set destination address info of selector */\n\tsa = ext_hdrs[SADB_EXT_ADDRESS_DST - 1];\n\tpfkey_sadb_addr2xfrm_addr(sa, &sel.daddr);\n\tsel.prefixlen_d = sa->sadb_address_prefixlen;\n\tsel.proto = pfkey_proto_to_xfrm(sa->sadb_address_proto);\n\tsel.dport = ((struct sockaddr_in *)(sa + 1))->sin_port;\n\tif (sel.dport)\n\t\tsel.dport_mask = htons(0xffff);\n\n\trq = (struct sadb_x_ipsecrequest *)(pol + 1);\n\n\t/* extract ipsecrequests */\n\ti = 0;\n\tlen = pol->sadb_x_policy_len * 8 - sizeof(struct sadb_x_policy);\n\n\twhile (len > 0 && i < XFRM_MAX_DEPTH) {\n\t\tret = ipsecrequests_to_migrate(rq, len, &m[i]);\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\trq = (struct sadb_x_ipsecrequest *)((u8 *)rq + ret);\n\t\t\tlen -= ret;\n\t\t\ti++;\n\t\t}\n\t}\n\n\tif (!i || len > 0) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\treturn xfrm_migrate(&sel, dir, XFRM_POLICY_TYPE_MAIN, m, i,\n\t\t\t    kma ? &k : NULL, net, NULL, 0);\n\n out:\n\treturn err;\n}\n#else\nstatic int pfkey_migrate(struct sock *sk, struct sk_buff *skb,\n\t\t\t const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\treturn -ENOPROTOOPT;\n}\n#endif\n\n\nstatic int pfkey_spdget(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct net *net = sock_net(sk);\n\tunsigned int dir;\n\tint err = 0, delete;\n\tstruct sadb_x_policy *pol;\n\tstruct xfrm_policy *xp;\n\tstruct km_event c;\n\n\tif ((pol = ext_hdrs[SADB_X_EXT_POLICY-1]) == NULL)\n\t\treturn -EINVAL;\n\n\tdir = xfrm_policy_id2dir(pol->sadb_x_policy_id);\n\tif (dir >= XFRM_POLICY_MAX)\n\t\treturn -EINVAL;\n\n\tdelete = (hdr->sadb_msg_type == SADB_X_SPDDELETE2);\n\txp = xfrm_policy_byid(net, &dummy_mark, 0, XFRM_POLICY_TYPE_MAIN,\n\t\t\t      dir, pol->sadb_x_policy_id, delete, &err);\n\tif (xp == NULL)\n\t\treturn -ENOENT;\n\n\tif (delete) {\n\t\txfrm_audit_policy_delete(xp, err ? 0 : 1, true);\n\n\t\tif (err)\n\t\t\tgoto out;\n\t\tc.seq = hdr->sadb_msg_seq;\n\t\tc.portid = hdr->sadb_msg_pid;\n\t\tc.data.byid = 1;\n\t\tc.event = XFRM_MSG_DELPOLICY;\n\t\tkm_policy_notify(xp, dir, &c);\n\t} else {\n\t\terr = key_pol_get_resp(sk, xp, hdr, dir);\n\t}\n\nout:\n\txfrm_pol_put(xp);\n\treturn err;\n}\n\nstatic int dump_sp(struct xfrm_policy *xp, int dir, int count, void *ptr)\n{\n\tstruct pfkey_sock *pfk = ptr;\n\tstruct sk_buff *out_skb;\n\tstruct sadb_msg *out_hdr;\n\tint err;\n\n\tif (!pfkey_can_dump(&pfk->sk))\n\t\treturn -ENOBUFS;\n\n\tout_skb = pfkey_xfrm_policy2msg_prep(xp);\n\tif (IS_ERR(out_skb))\n\t\treturn PTR_ERR(out_skb);\n\n\terr = pfkey_xfrm_policy2msg(out_skb, xp, dir);\n\tif (err < 0) {\n\t\tkfree_skb(out_skb);\n\t\treturn err;\n\t}\n\n\tout_hdr = (struct sadb_msg *) out_skb->data;\n\tout_hdr->sadb_msg_version = pfk->dump.msg_version;\n\tout_hdr->sadb_msg_type = SADB_X_SPDDUMP;\n\tout_hdr->sadb_msg_satype = SADB_SATYPE_UNSPEC;\n\tout_hdr->sadb_msg_errno = 0;\n\tout_hdr->sadb_msg_seq = count + 1;\n\tout_hdr->sadb_msg_pid = pfk->dump.msg_portid;\n\n\tif (pfk->dump.skb)\n\t\tpfkey_broadcast(pfk->dump.skb, GFP_ATOMIC, BROADCAST_ONE,\n\t\t\t\t&pfk->sk, sock_net(&pfk->sk));\n\tpfk->dump.skb = out_skb;\n\n\treturn 0;\n}\n\nstatic int pfkey_dump_sp(struct pfkey_sock *pfk)\n{\n\tstruct net *net = sock_net(&pfk->sk);\n\treturn xfrm_policy_walk(net, &pfk->dump.u.policy, dump_sp, (void *) pfk);\n}\n\nstatic void pfkey_dump_sp_done(struct pfkey_sock *pfk)\n{\n\tstruct net *net = sock_net((struct sock *)pfk);\n\n\txfrm_policy_walk_done(&pfk->dump.u.policy, net);\n}\n\nstatic int pfkey_spddump(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct pfkey_sock *pfk = pfkey_sk(sk);\n\n\tmutex_lock(&pfk->dump_lock);\n\tif (pfk->dump.dump != NULL) {\n\t\tmutex_unlock(&pfk->dump_lock);\n\t\treturn -EBUSY;\n\t}\n\n\tpfk->dump.msg_version = hdr->sadb_msg_version;\n\tpfk->dump.msg_portid = hdr->sadb_msg_pid;\n\tpfk->dump.dump = pfkey_dump_sp;\n\tpfk->dump.done = pfkey_dump_sp_done;\n\txfrm_policy_walk_init(&pfk->dump.u.policy, XFRM_POLICY_TYPE_MAIN);\n\tmutex_unlock(&pfk->dump_lock);\n\n\treturn pfkey_do_dump(pfk);\n}\n\nstatic int key_notify_policy_flush(const struct km_event *c)\n{\n\tstruct sk_buff *skb_out;\n\tstruct sadb_msg *hdr;\n\n\tskb_out = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_ATOMIC);\n\tif (!skb_out)\n\t\treturn -ENOBUFS;\n\thdr = skb_put(skb_out, sizeof(struct sadb_msg));\n\thdr->sadb_msg_type = SADB_X_SPDFLUSH;\n\thdr->sadb_msg_seq = c->seq;\n\thdr->sadb_msg_pid = c->portid;\n\thdr->sadb_msg_version = PF_KEY_V2;\n\thdr->sadb_msg_errno = (uint8_t) 0;\n\thdr->sadb_msg_satype = SADB_SATYPE_UNSPEC;\n\thdr->sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));\n\thdr->sadb_msg_reserved = 0;\n\tpfkey_broadcast(skb_out, GFP_ATOMIC, BROADCAST_ALL, NULL, c->net);\n\treturn 0;\n\n}\n\nstatic int pfkey_spdflush(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct km_event c;\n\tint err, err2;\n\n\terr = xfrm_policy_flush(net, XFRM_POLICY_TYPE_MAIN, true);\n\terr2 = unicast_flush_resp(sk, hdr);\n\tif (err || err2) {\n\t\tif (err == -ESRCH) /* empty table - old silent behavior */\n\t\t\treturn 0;\n\t\treturn err;\n\t}\n\n\tc.data.type = XFRM_POLICY_TYPE_MAIN;\n\tc.event = XFRM_MSG_FLUSHPOLICY;\n\tc.portid = hdr->sadb_msg_pid;\n\tc.seq = hdr->sadb_msg_seq;\n\tc.net = net;\n\tkm_policy_notify(NULL, 0, &c);\n\n\treturn 0;\n}\n\ntypedef int (*pfkey_handler)(struct sock *sk, struct sk_buff *skb,\n\t\t\t     const struct sadb_msg *hdr, void * const *ext_hdrs);\nstatic const pfkey_handler pfkey_funcs[SADB_MAX + 1] = {\n\t[SADB_RESERVED]\t\t= pfkey_reserved,\n\t[SADB_GETSPI]\t\t= pfkey_getspi,\n\t[SADB_UPDATE]\t\t= pfkey_add,\n\t[SADB_ADD]\t\t= pfkey_add,\n\t[SADB_DELETE]\t\t= pfkey_delete,\n\t[SADB_GET]\t\t= pfkey_get,\n\t[SADB_ACQUIRE]\t\t= pfkey_acquire,\n\t[SADB_REGISTER]\t\t= pfkey_register,\n\t[SADB_EXPIRE]\t\t= NULL,\n\t[SADB_FLUSH]\t\t= pfkey_flush,\n\t[SADB_DUMP]\t\t= pfkey_dump,\n\t[SADB_X_PROMISC]\t= pfkey_promisc,\n\t[SADB_X_PCHANGE]\t= NULL,\n\t[SADB_X_SPDUPDATE]\t= pfkey_spdadd,\n\t[SADB_X_SPDADD]\t\t= pfkey_spdadd,\n\t[SADB_X_SPDDELETE]\t= pfkey_spddelete,\n\t[SADB_X_SPDGET]\t\t= pfkey_spdget,\n\t[SADB_X_SPDACQUIRE]\t= NULL,\n\t[SADB_X_SPDDUMP]\t= pfkey_spddump,\n\t[SADB_X_SPDFLUSH]\t= pfkey_spdflush,\n\t[SADB_X_SPDSETIDX]\t= pfkey_spdadd,\n\t[SADB_X_SPDDELETE2]\t= pfkey_spdget,\n\t[SADB_X_MIGRATE]\t= pfkey_migrate,\n};\n\nstatic int pfkey_process(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr)\n{\n\tvoid *ext_hdrs[SADB_EXT_MAX];\n\tint err;\n\n\tpfkey_broadcast(skb_clone(skb, GFP_KERNEL), GFP_KERNEL,\n\t\t\tBROADCAST_PROMISC_ONLY, NULL, sock_net(sk));\n\n\tmemset(ext_hdrs, 0, sizeof(ext_hdrs));\n\terr = parse_exthdrs(skb, hdr, ext_hdrs);\n\tif (!err) {\n\t\terr = -EOPNOTSUPP;\n\t\tif (pfkey_funcs[hdr->sadb_msg_type])\n\t\t\terr = pfkey_funcs[hdr->sadb_msg_type](sk, skb, hdr, ext_hdrs);\n\t}\n\treturn err;\n}\n\nstatic struct sadb_msg *pfkey_get_base_msg(struct sk_buff *skb, int *errp)\n{\n\tstruct sadb_msg *hdr = NULL;\n\n\tif (skb->len < sizeof(*hdr)) {\n\t\t*errp = -EMSGSIZE;\n\t} else {\n\t\thdr = (struct sadb_msg *) skb->data;\n\t\tif (hdr->sadb_msg_version != PF_KEY_V2 ||\n\t\t    hdr->sadb_msg_reserved != 0 ||\n\t\t    (hdr->sadb_msg_type <= SADB_RESERVED ||\n\t\t     hdr->sadb_msg_type > SADB_MAX)) {\n\t\t\thdr = NULL;\n\t\t\t*errp = -EINVAL;\n\t\t} else if (hdr->sadb_msg_len != (skb->len /\n\t\t\t\t\t\t sizeof(uint64_t)) ||\n\t\t\t   hdr->sadb_msg_len < (sizeof(struct sadb_msg) /\n\t\t\t\t\t\tsizeof(uint64_t))) {\n\t\t\thdr = NULL;\n\t\t\t*errp = -EMSGSIZE;\n\t\t} else {\n\t\t\t*errp = 0;\n\t\t}\n\t}\n\treturn hdr;\n}\n\nstatic inline int aalg_tmpl_set(const struct xfrm_tmpl *t,\n\t\t\t\tconst struct xfrm_algo_desc *d)\n{\n\tunsigned int id = d->desc.sadb_alg_id;\n\n\tif (id >= sizeof(t->aalgos) * 8)\n\t\treturn 0;\n\n\treturn (t->aalgos >> id) & 1;\n}\n\nstatic inline int ealg_tmpl_set(const struct xfrm_tmpl *t,\n\t\t\t\tconst struct xfrm_algo_desc *d)\n{\n\tunsigned int id = d->desc.sadb_alg_id;\n\n\tif (id >= sizeof(t->ealgos) * 8)\n\t\treturn 0;\n\n\treturn (t->ealgos >> id) & 1;\n}\n\nstatic int count_ah_combs(const struct xfrm_tmpl *t)\n{\n\tint i, sz = 0;\n\n\tfor (i = 0; ; i++) {\n\t\tconst struct xfrm_algo_desc *aalg = xfrm_aalg_get_byidx(i);\n\t\tif (!aalg)\n\t\t\tbreak;\n\t\tif (!aalg->pfkey_supported)\n\t\t\tcontinue;\n\t\tif (aalg_tmpl_set(t, aalg))\n\t\t\tsz += sizeof(struct sadb_comb);\n\t}\n\treturn sz + sizeof(struct sadb_prop);\n}\n\nstatic int count_esp_combs(const struct xfrm_tmpl *t)\n{\n\tint i, k, sz = 0;\n\n\tfor (i = 0; ; i++) {\n\t\tconst struct xfrm_algo_desc *ealg = xfrm_ealg_get_byidx(i);\n\t\tif (!ealg)\n\t\t\tbreak;\n\n\t\tif (!ealg->pfkey_supported)\n\t\t\tcontinue;\n\n\t\tif (!(ealg_tmpl_set(t, ealg)))\n\t\t\tcontinue;\n\n\t\tfor (k = 1; ; k++) {\n\t\t\tconst struct xfrm_algo_desc *aalg = xfrm_aalg_get_byidx(k);\n\t\t\tif (!aalg)\n\t\t\t\tbreak;\n\n\t\t\tif (!aalg->pfkey_supported)\n\t\t\t\tcontinue;\n\n\t\t\tif (aalg_tmpl_set(t, aalg))\n\t\t\t\tsz += sizeof(struct sadb_comb);\n\t\t}\n\t}\n\treturn sz + sizeof(struct sadb_prop);\n}\n\nstatic void dump_ah_combs(struct sk_buff *skb, const struct xfrm_tmpl *t)\n{\n\tstruct sadb_prop *p;\n\tint i;\n\n\tp = skb_put(skb, sizeof(struct sadb_prop));\n\tp->sadb_prop_len = sizeof(struct sadb_prop)/8;\n\tp->sadb_prop_exttype = SADB_EXT_PROPOSAL;\n\tp->sadb_prop_replay = 32;\n\tmemset(p->sadb_prop_reserved, 0, sizeof(p->sadb_prop_reserved));\n\n\tfor (i = 0; ; i++) {\n\t\tconst struct xfrm_algo_desc *aalg = xfrm_aalg_get_byidx(i);\n\t\tif (!aalg)\n\t\t\tbreak;\n\n\t\tif (!aalg->pfkey_supported)\n\t\t\tcontinue;\n\n\t\tif (aalg_tmpl_set(t, aalg) && aalg->available) {\n\t\t\tstruct sadb_comb *c;\n\t\t\tc = skb_put_zero(skb, sizeof(struct sadb_comb));\n\t\t\tp->sadb_prop_len += sizeof(struct sadb_comb)/8;\n\t\t\tc->sadb_comb_auth = aalg->desc.sadb_alg_id;\n\t\t\tc->sadb_comb_auth_minbits = aalg->desc.sadb_alg_minbits;\n\t\t\tc->sadb_comb_auth_maxbits = aalg->desc.sadb_alg_maxbits;\n\t\t\tc->sadb_comb_hard_addtime = 24*60*60;\n\t\t\tc->sadb_comb_soft_addtime = 20*60*60;\n\t\t\tc->sadb_comb_hard_usetime = 8*60*60;\n\t\t\tc->sadb_comb_soft_usetime = 7*60*60;\n\t\t}\n\t}\n}\n\nstatic void dump_esp_combs(struct sk_buff *skb, const struct xfrm_tmpl *t)\n{\n\tstruct sadb_prop *p;\n\tint i, k;\n\n\tp = skb_put(skb, sizeof(struct sadb_prop));\n\tp->sadb_prop_len = sizeof(struct sadb_prop)/8;\n\tp->sadb_prop_exttype = SADB_EXT_PROPOSAL;\n\tp->sadb_prop_replay = 32;\n\tmemset(p->sadb_prop_reserved, 0, sizeof(p->sadb_prop_reserved));\n\n\tfor (i=0; ; i++) {\n\t\tconst struct xfrm_algo_desc *ealg = xfrm_ealg_get_byidx(i);\n\t\tif (!ealg)\n\t\t\tbreak;\n\n\t\tif (!ealg->pfkey_supported)\n\t\t\tcontinue;\n\n\t\tif (!(ealg_tmpl_set(t, ealg) && ealg->available))\n\t\t\tcontinue;\n\n\t\tfor (k = 1; ; k++) {\n\t\t\tstruct sadb_comb *c;\n\t\t\tconst struct xfrm_algo_desc *aalg = xfrm_aalg_get_byidx(k);\n\t\t\tif (!aalg)\n\t\t\t\tbreak;\n\t\t\tif (!aalg->pfkey_supported)\n\t\t\t\tcontinue;\n\t\t\tif (!(aalg_tmpl_set(t, aalg) && aalg->available))\n\t\t\t\tcontinue;\n\t\t\tc = skb_put(skb, sizeof(struct sadb_comb));\n\t\t\tmemset(c, 0, sizeof(*c));\n\t\t\tp->sadb_prop_len += sizeof(struct sadb_comb)/8;\n\t\t\tc->sadb_comb_auth = aalg->desc.sadb_alg_id;\n\t\t\tc->sadb_comb_auth_minbits = aalg->desc.sadb_alg_minbits;\n\t\t\tc->sadb_comb_auth_maxbits = aalg->desc.sadb_alg_maxbits;\n\t\t\tc->sadb_comb_encrypt = ealg->desc.sadb_alg_id;\n\t\t\tc->sadb_comb_encrypt_minbits = ealg->desc.sadb_alg_minbits;\n\t\t\tc->sadb_comb_encrypt_maxbits = ealg->desc.sadb_alg_maxbits;\n\t\t\tc->sadb_comb_hard_addtime = 24*60*60;\n\t\t\tc->sadb_comb_soft_addtime = 20*60*60;\n\t\t\tc->sadb_comb_hard_usetime = 8*60*60;\n\t\t\tc->sadb_comb_soft_usetime = 7*60*60;\n\t\t}\n\t}\n}\n\nstatic int key_notify_policy_expire(struct xfrm_policy *xp, const struct km_event *c)\n{\n\treturn 0;\n}\n\nstatic int key_notify_sa_expire(struct xfrm_state *x, const struct km_event *c)\n{\n\tstruct sk_buff *out_skb;\n\tstruct sadb_msg *out_hdr;\n\tint hard;\n\tint hsc;\n\n\thard = c->data.hard;\n\tif (hard)\n\t\thsc = 2;\n\telse\n\t\thsc = 1;\n\n\tout_skb = pfkey_xfrm_state2msg_expire(x, hsc);\n\tif (IS_ERR(out_skb))\n\t\treturn PTR_ERR(out_skb);\n\n\tout_hdr = (struct sadb_msg *) out_skb->data;\n\tout_hdr->sadb_msg_version = PF_KEY_V2;\n\tout_hdr->sadb_msg_type = SADB_EXPIRE;\n\tout_hdr->sadb_msg_satype = pfkey_proto2satype(x->id.proto);\n\tout_hdr->sadb_msg_errno = 0;\n\tout_hdr->sadb_msg_reserved = 0;\n\tout_hdr->sadb_msg_seq = 0;\n\tout_hdr->sadb_msg_pid = 0;\n\n\tpfkey_broadcast(out_skb, GFP_ATOMIC, BROADCAST_REGISTERED, NULL,\n\t\t\txs_net(x));\n\treturn 0;\n}\n\nstatic int pfkey_send_notify(struct xfrm_state *x, const struct km_event *c)\n{\n\tstruct net *net = x ? xs_net(x) : c->net;\n\tstruct netns_pfkey *net_pfkey = net_generic(net, pfkey_net_id);\n\n\tif (atomic_read(&net_pfkey->socks_nr) == 0)\n\t\treturn 0;\n\n\tswitch (c->event) {\n\tcase XFRM_MSG_EXPIRE:\n\t\treturn key_notify_sa_expire(x, c);\n\tcase XFRM_MSG_DELSA:\n\tcase XFRM_MSG_NEWSA:\n\tcase XFRM_MSG_UPDSA:\n\t\treturn key_notify_sa(x, c);\n\tcase XFRM_MSG_FLUSHSA:\n\t\treturn key_notify_sa_flush(c);\n\tcase XFRM_MSG_NEWAE: /* not yet supported */\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"pfkey: Unknown SA event %d\\n\", c->event);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int pfkey_send_policy_notify(struct xfrm_policy *xp, int dir, const struct km_event *c)\n{\n\tif (xp && xp->type != XFRM_POLICY_TYPE_MAIN)\n\t\treturn 0;\n\n\tswitch (c->event) {\n\tcase XFRM_MSG_POLEXPIRE:\n\t\treturn key_notify_policy_expire(xp, c);\n\tcase XFRM_MSG_DELPOLICY:\n\tcase XFRM_MSG_NEWPOLICY:\n\tcase XFRM_MSG_UPDPOLICY:\n\t\treturn key_notify_policy(xp, dir, c);\n\tcase XFRM_MSG_FLUSHPOLICY:\n\t\tif (c->data.type != XFRM_POLICY_TYPE_MAIN)\n\t\t\tbreak;\n\t\treturn key_notify_policy_flush(c);\n\tdefault:\n\t\tpr_err(\"pfkey: Unknown policy event %d\\n\", c->event);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic u32 get_acqseq(void)\n{\n\tu32 res;\n\tstatic atomic_t acqseq;\n\n\tdo {\n\t\tres = atomic_inc_return(&acqseq);\n\t} while (!res);\n\treturn res;\n}\n\nstatic bool pfkey_is_alive(const struct km_event *c)\n{\n\tstruct netns_pfkey *net_pfkey = net_generic(c->net, pfkey_net_id);\n\tstruct sock *sk;\n\tbool is_alive = false;\n\n\trcu_read_lock();\n\tsk_for_each_rcu(sk, &net_pfkey->table) {\n\t\tif (pfkey_sk(sk)->registered) {\n\t\t\tis_alive = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn is_alive;\n}\n\nstatic int pfkey_send_acquire(struct xfrm_state *x, struct xfrm_tmpl *t, struct xfrm_policy *xp)\n{\n\tstruct sk_buff *skb;\n\tstruct sadb_msg *hdr;\n\tstruct sadb_address *addr;\n\tstruct sadb_x_policy *pol;\n\tint sockaddr_size;\n\tint size;\n\tstruct sadb_x_sec_ctx *sec_ctx;\n\tstruct xfrm_sec_ctx *xfrm_ctx;\n\tint ctx_size = 0;\n\n\tsockaddr_size = pfkey_sockaddr_size(x->props.family);\n\tif (!sockaddr_size)\n\t\treturn -EINVAL;\n\n\tsize = sizeof(struct sadb_msg) +\n\t\t(sizeof(struct sadb_address) * 2) +\n\t\t(sockaddr_size * 2) +\n\t\tsizeof(struct sadb_x_policy);\n\n\tif (x->id.proto == IPPROTO_AH)\n\t\tsize += count_ah_combs(t);\n\telse if (x->id.proto == IPPROTO_ESP)\n\t\tsize += count_esp_combs(t);\n\n\tif ((xfrm_ctx = x->security)) {\n\t\tctx_size = PFKEY_ALIGN8(xfrm_ctx->ctx_len);\n\t\tsize +=  sizeof(struct sadb_x_sec_ctx) + ctx_size;\n\t}\n\n\tskb =  alloc_skb(size + 16, GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\thdr = skb_put(skb, sizeof(struct sadb_msg));\n\thdr->sadb_msg_version = PF_KEY_V2;\n\thdr->sadb_msg_type = SADB_ACQUIRE;\n\thdr->sadb_msg_satype = pfkey_proto2satype(x->id.proto);\n\thdr->sadb_msg_len = size / sizeof(uint64_t);\n\thdr->sadb_msg_errno = 0;\n\thdr->sadb_msg_reserved = 0;\n\thdr->sadb_msg_seq = x->km.seq = get_acqseq();\n\thdr->sadb_msg_pid = 0;\n\n\t/* src address */\n\taddr = skb_put(skb, sizeof(struct sadb_address) + sockaddr_size);\n\taddr->sadb_address_len =\n\t\t(sizeof(struct sadb_address)+sockaddr_size)/\n\t\t\tsizeof(uint64_t);\n\taddr->sadb_address_exttype = SADB_EXT_ADDRESS_SRC;\n\taddr->sadb_address_proto = 0;\n\taddr->sadb_address_reserved = 0;\n\taddr->sadb_address_prefixlen =\n\t\tpfkey_sockaddr_fill(&x->props.saddr, 0,\n\t\t\t\t    (struct sockaddr *) (addr + 1),\n\t\t\t\t    x->props.family);\n\tif (!addr->sadb_address_prefixlen)\n\t\tBUG();\n\n\t/* dst address */\n\taddr = skb_put(skb, sizeof(struct sadb_address) + sockaddr_size);\n\taddr->sadb_address_len =\n\t\t(sizeof(struct sadb_address)+sockaddr_size)/\n\t\t\tsizeof(uint64_t);\n\taddr->sadb_address_exttype = SADB_EXT_ADDRESS_DST;\n\taddr->sadb_address_proto = 0;\n\taddr->sadb_address_reserved = 0;\n\taddr->sadb_address_prefixlen =\n\t\tpfkey_sockaddr_fill(&x->id.daddr, 0,\n\t\t\t\t    (struct sockaddr *) (addr + 1),\n\t\t\t\t    x->props.family);\n\tif (!addr->sadb_address_prefixlen)\n\t\tBUG();\n\n\tpol = skb_put(skb, sizeof(struct sadb_x_policy));\n\tpol->sadb_x_policy_len = sizeof(struct sadb_x_policy)/sizeof(uint64_t);\n\tpol->sadb_x_policy_exttype = SADB_X_EXT_POLICY;\n\tpol->sadb_x_policy_type = IPSEC_POLICY_IPSEC;\n\tpol->sadb_x_policy_dir = XFRM_POLICY_OUT + 1;\n\tpol->sadb_x_policy_reserved = 0;\n\tpol->sadb_x_policy_id = xp->index;\n\tpol->sadb_x_policy_priority = xp->priority;\n\n\t/* Set sadb_comb's. */\n\tif (x->id.proto == IPPROTO_AH)\n\t\tdump_ah_combs(skb, t);\n\telse if (x->id.proto == IPPROTO_ESP)\n\t\tdump_esp_combs(skb, t);\n\n\t/* security context */\n\tif (xfrm_ctx) {\n\t\tsec_ctx = skb_put(skb,\n\t\t\t\t  sizeof(struct sadb_x_sec_ctx) + ctx_size);\n\t\tsec_ctx->sadb_x_sec_len =\n\t\t  (sizeof(struct sadb_x_sec_ctx) + ctx_size) / sizeof(uint64_t);\n\t\tsec_ctx->sadb_x_sec_exttype = SADB_X_EXT_SEC_CTX;\n\t\tsec_ctx->sadb_x_ctx_doi = xfrm_ctx->ctx_doi;\n\t\tsec_ctx->sadb_x_ctx_alg = xfrm_ctx->ctx_alg;\n\t\tsec_ctx->sadb_x_ctx_len = xfrm_ctx->ctx_len;\n\t\tmemcpy(sec_ctx + 1, xfrm_ctx->ctx_str,\n\t\t       xfrm_ctx->ctx_len);\n\t}\n\n\treturn pfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_REGISTERED, NULL,\n\t\t\t       xs_net(x));\n}\n\nstatic struct xfrm_policy *pfkey_compile_policy(struct sock *sk, int opt,\n\t\t\t\t\t\tu8 *data, int len, int *dir)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct xfrm_policy *xp;\n\tstruct sadb_x_policy *pol = (struct sadb_x_policy*)data;\n\tstruct sadb_x_sec_ctx *sec_ctx;\n\n\tswitch (sk->sk_family) {\n\tcase AF_INET:\n\t\tif (opt != IP_IPSEC_POLICY) {\n\t\t\t*dir = -EOPNOTSUPP;\n\t\t\treturn NULL;\n\t\t}\n\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase AF_INET6:\n\t\tif (opt != IPV6_IPSEC_POLICY) {\n\t\t\t*dir = -EOPNOTSUPP;\n\t\t\treturn NULL;\n\t\t}\n\t\tbreak;\n#endif\n\tdefault:\n\t\t*dir = -EINVAL;\n\t\treturn NULL;\n\t}\n\n\t*dir = -EINVAL;\n\n\tif (len < sizeof(struct sadb_x_policy) ||\n\t    pol->sadb_x_policy_len*8 > len ||\n\t    pol->sadb_x_policy_type > IPSEC_POLICY_BYPASS ||\n\t    (!pol->sadb_x_policy_dir || pol->sadb_x_policy_dir > IPSEC_DIR_OUTBOUND))\n\t\treturn NULL;\n\n\txp = xfrm_policy_alloc(net, GFP_ATOMIC);\n\tif (xp == NULL) {\n\t\t*dir = -ENOBUFS;\n\t\treturn NULL;\n\t}\n\n\txp->action = (pol->sadb_x_policy_type == IPSEC_POLICY_DISCARD ?\n\t\t      XFRM_POLICY_BLOCK : XFRM_POLICY_ALLOW);\n\n\txp->lft.soft_byte_limit = XFRM_INF;\n\txp->lft.hard_byte_limit = XFRM_INF;\n\txp->lft.soft_packet_limit = XFRM_INF;\n\txp->lft.hard_packet_limit = XFRM_INF;\n\txp->family = sk->sk_family;\n\n\txp->xfrm_nr = 0;\n\tif (pol->sadb_x_policy_type == IPSEC_POLICY_IPSEC &&\n\t    (*dir = parse_ipsecrequests(xp, pol)) < 0)\n\t\tgoto out;\n\n\t/* security context too */\n\tif (len >= (pol->sadb_x_policy_len*8 +\n\t    sizeof(struct sadb_x_sec_ctx))) {\n\t\tchar *p = (char *)pol;\n\t\tstruct xfrm_user_sec_ctx *uctx;\n\n\t\tp += pol->sadb_x_policy_len*8;\n\t\tsec_ctx = (struct sadb_x_sec_ctx *)p;\n\t\tif (len < pol->sadb_x_policy_len*8 +\n\t\t    sec_ctx->sadb_x_sec_len*8) {\n\t\t\t*dir = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((*dir = verify_sec_ctx_len(p)))\n\t\t\tgoto out;\n\t\tuctx = pfkey_sadb2xfrm_user_sec_ctx(sec_ctx, GFP_ATOMIC);\n\t\t*dir = security_xfrm_policy_alloc(&xp->security, uctx, GFP_ATOMIC);\n\t\tkfree(uctx);\n\n\t\tif (*dir)\n\t\t\tgoto out;\n\t}\n\n\t*dir = pol->sadb_x_policy_dir-1;\n\treturn xp;\n\nout:\n\txp->walk.dead = 1;\n\txfrm_policy_destroy(xp);\n\treturn NULL;\n}\n\nstatic int pfkey_send_new_mapping(struct xfrm_state *x, xfrm_address_t *ipaddr, __be16 sport)\n{\n\tstruct sk_buff *skb;\n\tstruct sadb_msg *hdr;\n\tstruct sadb_sa *sa;\n\tstruct sadb_address *addr;\n\tstruct sadb_x_nat_t_port *n_port;\n\tint sockaddr_size;\n\tint size;\n\t__u8 satype = (x->id.proto == IPPROTO_ESP ? SADB_SATYPE_ESP : 0);\n\tstruct xfrm_encap_tmpl *natt = NULL;\n\n\tsockaddr_size = pfkey_sockaddr_size(x->props.family);\n\tif (!sockaddr_size)\n\t\treturn -EINVAL;\n\n\tif (!satype)\n\t\treturn -EINVAL;\n\n\tif (!x->encap)\n\t\treturn -EINVAL;\n\n\tnatt = x->encap;\n\n\t/* Build an SADB_X_NAT_T_NEW_MAPPING message:\n\t *\n\t * HDR | SA | ADDRESS_SRC (old addr) | NAT_T_SPORT (old port) |\n\t * ADDRESS_DST (new addr) | NAT_T_DPORT (new port)\n\t */\n\n\tsize = sizeof(struct sadb_msg) +\n\t\tsizeof(struct sadb_sa) +\n\t\t(sizeof(struct sadb_address) * 2) +\n\t\t(sockaddr_size * 2) +\n\t\t(sizeof(struct sadb_x_nat_t_port) * 2);\n\n\tskb =  alloc_skb(size + 16, GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\thdr = skb_put(skb, sizeof(struct sadb_msg));\n\thdr->sadb_msg_version = PF_KEY_V2;\n\thdr->sadb_msg_type = SADB_X_NAT_T_NEW_MAPPING;\n\thdr->sadb_msg_satype = satype;\n\thdr->sadb_msg_len = size / sizeof(uint64_t);\n\thdr->sadb_msg_errno = 0;\n\thdr->sadb_msg_reserved = 0;\n\thdr->sadb_msg_seq = x->km.seq = get_acqseq();\n\thdr->sadb_msg_pid = 0;\n\n\t/* SA */\n\tsa = skb_put(skb, sizeof(struct sadb_sa));\n\tsa->sadb_sa_len = sizeof(struct sadb_sa)/sizeof(uint64_t);\n\tsa->sadb_sa_exttype = SADB_EXT_SA;\n\tsa->sadb_sa_spi = x->id.spi;\n\tsa->sadb_sa_replay = 0;\n\tsa->sadb_sa_state = 0;\n\tsa->sadb_sa_auth = 0;\n\tsa->sadb_sa_encrypt = 0;\n\tsa->sadb_sa_flags = 0;\n\n\t/* ADDRESS_SRC (old addr) */\n\taddr = skb_put(skb, sizeof(struct sadb_address) + sockaddr_size);\n\taddr->sadb_address_len =\n\t\t(sizeof(struct sadb_address)+sockaddr_size)/\n\t\t\tsizeof(uint64_t);\n\taddr->sadb_address_exttype = SADB_EXT_ADDRESS_SRC;\n\taddr->sadb_address_proto = 0;\n\taddr->sadb_address_reserved = 0;\n\taddr->sadb_address_prefixlen =\n\t\tpfkey_sockaddr_fill(&x->props.saddr, 0,\n\t\t\t\t    (struct sockaddr *) (addr + 1),\n\t\t\t\t    x->props.family);\n\tif (!addr->sadb_address_prefixlen)\n\t\tBUG();\n\n\t/* NAT_T_SPORT (old port) */\n\tn_port = skb_put(skb, sizeof(*n_port));\n\tn_port->sadb_x_nat_t_port_len = sizeof(*n_port)/sizeof(uint64_t);\n\tn_port->sadb_x_nat_t_port_exttype = SADB_X_EXT_NAT_T_SPORT;\n\tn_port->sadb_x_nat_t_port_port = natt->encap_sport;\n\tn_port->sadb_x_nat_t_port_reserved = 0;\n\n\t/* ADDRESS_DST (new addr) */\n\taddr = skb_put(skb, sizeof(struct sadb_address) + sockaddr_size);\n\taddr->sadb_address_len =\n\t\t(sizeof(struct sadb_address)+sockaddr_size)/\n\t\t\tsizeof(uint64_t);\n\taddr->sadb_address_exttype = SADB_EXT_ADDRESS_DST;\n\taddr->sadb_address_proto = 0;\n\taddr->sadb_address_reserved = 0;\n\taddr->sadb_address_prefixlen =\n\t\tpfkey_sockaddr_fill(ipaddr, 0,\n\t\t\t\t    (struct sockaddr *) (addr + 1),\n\t\t\t\t    x->props.family);\n\tif (!addr->sadb_address_prefixlen)\n\t\tBUG();\n\n\t/* NAT_T_DPORT (new port) */\n\tn_port = skb_put(skb, sizeof(*n_port));\n\tn_port->sadb_x_nat_t_port_len = sizeof(*n_port)/sizeof(uint64_t);\n\tn_port->sadb_x_nat_t_port_exttype = SADB_X_EXT_NAT_T_DPORT;\n\tn_port->sadb_x_nat_t_port_port = sport;\n\tn_port->sadb_x_nat_t_port_reserved = 0;\n\n\treturn pfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_REGISTERED, NULL,\n\t\t\t       xs_net(x));\n}\n\n#ifdef CONFIG_NET_KEY_MIGRATE\nstatic int set_sadb_address(struct sk_buff *skb, int sasize, int type,\n\t\t\t    const struct xfrm_selector *sel)\n{\n\tstruct sadb_address *addr;\n\taddr = skb_put(skb, sizeof(struct sadb_address) + sasize);\n\taddr->sadb_address_len = (sizeof(struct sadb_address) + sasize)/8;\n\taddr->sadb_address_exttype = type;\n\taddr->sadb_address_proto = sel->proto;\n\taddr->sadb_address_reserved = 0;\n\n\tswitch (type) {\n\tcase SADB_EXT_ADDRESS_SRC:\n\t\taddr->sadb_address_prefixlen = sel->prefixlen_s;\n\t\tpfkey_sockaddr_fill(&sel->saddr, 0,\n\t\t\t\t    (struct sockaddr *)(addr + 1),\n\t\t\t\t    sel->family);\n\t\tbreak;\n\tcase SADB_EXT_ADDRESS_DST:\n\t\taddr->sadb_address_prefixlen = sel->prefixlen_d;\n\t\tpfkey_sockaddr_fill(&sel->daddr, 0,\n\t\t\t\t    (struct sockaddr *)(addr + 1),\n\t\t\t\t    sel->family);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n\nstatic int set_sadb_kmaddress(struct sk_buff *skb, const struct xfrm_kmaddress *k)\n{\n\tstruct sadb_x_kmaddress *kma;\n\tu8 *sa;\n\tint family = k->family;\n\tint socklen = pfkey_sockaddr_len(family);\n\tint size_req;\n\n\tsize_req = (sizeof(struct sadb_x_kmaddress) +\n\t\t    pfkey_sockaddr_pair_size(family));\n\n\tkma = skb_put_zero(skb, size_req);\n\tkma->sadb_x_kmaddress_len = size_req / 8;\n\tkma->sadb_x_kmaddress_exttype = SADB_X_EXT_KMADDRESS;\n\tkma->sadb_x_kmaddress_reserved = k->reserved;\n\n\tsa = (u8 *)(kma + 1);\n\tif (!pfkey_sockaddr_fill(&k->local, 0, (struct sockaddr *)sa, family) ||\n\t    !pfkey_sockaddr_fill(&k->remote, 0, (struct sockaddr *)(sa+socklen), family))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int set_ipsecrequest(struct sk_buff *skb,\n\t\t\t    uint8_t proto, uint8_t mode, int level,\n\t\t\t    uint32_t reqid, uint8_t family,\n\t\t\t    const xfrm_address_t *src, const xfrm_address_t *dst)\n{\n\tstruct sadb_x_ipsecrequest *rq;\n\tu8 *sa;\n\tint socklen = pfkey_sockaddr_len(family);\n\tint size_req;\n\n\tsize_req = sizeof(struct sadb_x_ipsecrequest) +\n\t\t   pfkey_sockaddr_pair_size(family);\n\n\trq = skb_put_zero(skb, size_req);\n\trq->sadb_x_ipsecrequest_len = size_req;\n\trq->sadb_x_ipsecrequest_proto = proto;\n\trq->sadb_x_ipsecrequest_mode = mode;\n\trq->sadb_x_ipsecrequest_level = level;\n\trq->sadb_x_ipsecrequest_reqid = reqid;\n\n\tsa = (u8 *) (rq + 1);\n\tif (!pfkey_sockaddr_fill(src, 0, (struct sockaddr *)sa, family) ||\n\t    !pfkey_sockaddr_fill(dst, 0, (struct sockaddr *)(sa + socklen), family))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n#endif\n\n#ifdef CONFIG_NET_KEY_MIGRATE\nstatic int pfkey_send_migrate(const struct xfrm_selector *sel, u8 dir, u8 type,\n\t\t\t      const struct xfrm_migrate *m, int num_bundles,\n\t\t\t      const struct xfrm_kmaddress *k,\n\t\t\t      const struct xfrm_encap_tmpl *encap)\n{\n\tint i;\n\tint sasize_sel;\n\tint size = 0;\n\tint size_pol = 0;\n\tstruct sk_buff *skb;\n\tstruct sadb_msg *hdr;\n\tstruct sadb_x_policy *pol;\n\tconst struct xfrm_migrate *mp;\n\n\tif (type != XFRM_POLICY_TYPE_MAIN)\n\t\treturn 0;\n\n\tif (num_bundles <= 0 || num_bundles > XFRM_MAX_DEPTH)\n\t\treturn -EINVAL;\n\n\tif (k != NULL) {\n\t\t/* addresses for KM */\n\t\tsize += PFKEY_ALIGN8(sizeof(struct sadb_x_kmaddress) +\n\t\t\t\t     pfkey_sockaddr_pair_size(k->family));\n\t}\n\n\t/* selector */\n\tsasize_sel = pfkey_sockaddr_size(sel->family);\n\tif (!sasize_sel)\n\t\treturn -EINVAL;\n\tsize += (sizeof(struct sadb_address) + sasize_sel) * 2;\n\n\t/* policy info */\n\tsize_pol += sizeof(struct sadb_x_policy);\n\n\t/* ipsecrequests */\n\tfor (i = 0, mp = m; i < num_bundles; i++, mp++) {\n\t\t/* old locator pair */\n\t\tsize_pol += sizeof(struct sadb_x_ipsecrequest) +\n\t\t\t    pfkey_sockaddr_pair_size(mp->old_family);\n\t\t/* new locator pair */\n\t\tsize_pol += sizeof(struct sadb_x_ipsecrequest) +\n\t\t\t    pfkey_sockaddr_pair_size(mp->new_family);\n\t}\n\n\tsize += sizeof(struct sadb_msg) + size_pol;\n\n\t/* alloc buffer */\n\tskb = alloc_skb(size, GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\thdr = skb_put(skb, sizeof(struct sadb_msg));\n\thdr->sadb_msg_version = PF_KEY_V2;\n\thdr->sadb_msg_type = SADB_X_MIGRATE;\n\thdr->sadb_msg_satype = pfkey_proto2satype(m->proto);\n\thdr->sadb_msg_len = size / 8;\n\thdr->sadb_msg_errno = 0;\n\thdr->sadb_msg_reserved = 0;\n\thdr->sadb_msg_seq = 0;\n\thdr->sadb_msg_pid = 0;\n\n\t/* Addresses to be used by KM for negotiation, if ext is available */\n\tif (k != NULL && (set_sadb_kmaddress(skb, k) < 0))\n\t\tgoto err;\n\n\t/* selector src */\n\tset_sadb_address(skb, sasize_sel, SADB_EXT_ADDRESS_SRC, sel);\n\n\t/* selector dst */\n\tset_sadb_address(skb, sasize_sel, SADB_EXT_ADDRESS_DST, sel);\n\n\t/* policy information */\n\tpol = skb_put(skb, sizeof(struct sadb_x_policy));\n\tpol->sadb_x_policy_len = size_pol / 8;\n\tpol->sadb_x_policy_exttype = SADB_X_EXT_POLICY;\n\tpol->sadb_x_policy_type = IPSEC_POLICY_IPSEC;\n\tpol->sadb_x_policy_dir = dir + 1;\n\tpol->sadb_x_policy_reserved = 0;\n\tpol->sadb_x_policy_id = 0;\n\tpol->sadb_x_policy_priority = 0;\n\n\tfor (i = 0, mp = m; i < num_bundles; i++, mp++) {\n\t\t/* old ipsecrequest */\n\t\tint mode = pfkey_mode_from_xfrm(mp->mode);\n\t\tif (mode < 0)\n\t\t\tgoto err;\n\t\tif (set_ipsecrequest(skb, mp->proto, mode,\n\t\t\t\t     (mp->reqid ?  IPSEC_LEVEL_UNIQUE : IPSEC_LEVEL_REQUIRE),\n\t\t\t\t     mp->reqid, mp->old_family,\n\t\t\t\t     &mp->old_saddr, &mp->old_daddr) < 0)\n\t\t\tgoto err;\n\n\t\t/* new ipsecrequest */\n\t\tif (set_ipsecrequest(skb, mp->proto, mode,\n\t\t\t\t     (mp->reqid ? IPSEC_LEVEL_UNIQUE : IPSEC_LEVEL_REQUIRE),\n\t\t\t\t     mp->reqid, mp->new_family,\n\t\t\t\t     &mp->new_saddr, &mp->new_daddr) < 0)\n\t\t\tgoto err;\n\t}\n\n\t/* broadcast migrate message to sockets */\n\tpfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_ALL, NULL, &init_net);\n\n\treturn 0;\n\nerr:\n\tkfree_skb(skb);\n\treturn -EINVAL;\n}\n#else\nstatic int pfkey_send_migrate(const struct xfrm_selector *sel, u8 dir, u8 type,\n\t\t\t      const struct xfrm_migrate *m, int num_bundles,\n\t\t\t      const struct xfrm_kmaddress *k,\n\t\t\t      const struct xfrm_encap_tmpl *encap)\n{\n\treturn -ENOPROTOOPT;\n}\n#endif\n\nstatic int pfkey_sendmsg(struct socket *sock, struct msghdr *msg, size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb = NULL;\n\tstruct sadb_msg *hdr = NULL;\n\tint err;\n\tstruct net *net = sock_net(sk);\n\n\terr = -EOPNOTSUPP;\n\tif (msg->msg_flags & MSG_OOB)\n\t\tgoto out;\n\n\terr = -EMSGSIZE;\n\tif ((unsigned int)len > sk->sk_sndbuf - 32)\n\t\tgoto out;\n\n\terr = -ENOBUFS;\n\tskb = alloc_skb(len, GFP_KERNEL);\n\tif (skb == NULL)\n\t\tgoto out;\n\n\terr = -EFAULT;\n\tif (memcpy_from_msg(skb_put(skb,len), msg, len))\n\t\tgoto out;\n\n\thdr = pfkey_get_base_msg(skb, &err);\n\tif (!hdr)\n\t\tgoto out;\n\n\tmutex_lock(&net->xfrm.xfrm_cfg_mutex);\n\terr = pfkey_process(sk, skb, hdr);\n\tmutex_unlock(&net->xfrm.xfrm_cfg_mutex);\n\nout:\n\tif (err && hdr && pfkey_error(hdr, err, sk) == 0)\n\t\terr = 0;\n\tkfree_skb(skb);\n\n\treturn err ? : len;\n}\n\nstatic int pfkey_recvmsg(struct socket *sock, struct msghdr *msg, size_t len,\n\t\t\t int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct pfkey_sock *pfk = pfkey_sk(sk);\n\tstruct sk_buff *skb;\n\tint copied, err;\n\n\terr = -EINVAL;\n\tif (flags & ~(MSG_PEEK|MSG_DONTWAIT|MSG_TRUNC|MSG_CMSG_COMPAT))\n\t\tgoto out;\n\n\tskb = skb_recv_datagram(sk, flags, flags & MSG_DONTWAIT, &err);\n\tif (skb == NULL)\n\t\tgoto out;\n\n\tcopied = skb->len;\n\tif (copied > len) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\n\tskb_reset_transport_header(skb);\n\terr = skb_copy_datagram_msg(skb, 0, msg, copied);\n\tif (err)\n\t\tgoto out_free;\n\n\tsock_recv_ts_and_drops(msg, sk, skb);\n\n\terr = (flags & MSG_TRUNC) ? skb->len : copied;\n\n\tif (pfk->dump.dump != NULL &&\n\t    3 * atomic_read(&sk->sk_rmem_alloc) <= sk->sk_rcvbuf)\n\t\tpfkey_do_dump(pfk);\n\nout_free:\n\tskb_free_datagram(sk, skb);\nout:\n\treturn err;\n}\n\nstatic const struct proto_ops pfkey_ops = {\n\t.family\t\t=\tPF_KEY,\n\t.owner\t\t=\tTHIS_MODULE,\n\t/* Operations that make no sense on pfkey sockets. */\n\t.bind\t\t=\tsock_no_bind,\n\t.connect\t=\tsock_no_connect,\n\t.socketpair\t=\tsock_no_socketpair,\n\t.accept\t\t=\tsock_no_accept,\n\t.getname\t=\tsock_no_getname,\n\t.ioctl\t\t=\tsock_no_ioctl,\n\t.listen\t\t=\tsock_no_listen,\n\t.shutdown\t=\tsock_no_shutdown,\n\t.mmap\t\t=\tsock_no_mmap,\n\t.sendpage\t=\tsock_no_sendpage,\n\n\t/* Now the operations that really occur. */\n\t.release\t=\tpfkey_release,\n\t.poll\t\t=\tdatagram_poll,\n\t.sendmsg\t=\tpfkey_sendmsg,\n\t.recvmsg\t=\tpfkey_recvmsg,\n};\n\nstatic const struct net_proto_family pfkey_family_ops = {\n\t.family\t=\tPF_KEY,\n\t.create\t=\tpfkey_create,\n\t.owner\t=\tTHIS_MODULE,\n};\n\n#ifdef CONFIG_PROC_FS\nstatic int pfkey_seq_show(struct seq_file *f, void *v)\n{\n\tstruct sock *s = sk_entry(v);\n\n\tif (v == SEQ_START_TOKEN)\n\t\tseq_printf(f ,\"sk       RefCnt Rmem   Wmem   User   Inode\\n\");\n\telse\n\t\tseq_printf(f, \"%pK %-6d %-6u %-6u %-6u %-6lu\\n\",\n\t\t\t       s,\n\t\t\t       refcount_read(&s->sk_refcnt),\n\t\t\t       sk_rmem_alloc_get(s),\n\t\t\t       sk_wmem_alloc_get(s),\n\t\t\t       from_kuid_munged(seq_user_ns(f), sock_i_uid(s)),\n\t\t\t       sock_i_ino(s)\n\t\t\t       );\n\treturn 0;\n}\n\nstatic void *pfkey_seq_start(struct seq_file *f, loff_t *ppos)\n\t__acquires(rcu)\n{\n\tstruct net *net = seq_file_net(f);\n\tstruct netns_pfkey *net_pfkey = net_generic(net, pfkey_net_id);\n\n\trcu_read_lock();\n\treturn seq_hlist_start_head_rcu(&net_pfkey->table, *ppos);\n}\n\nstatic void *pfkey_seq_next(struct seq_file *f, void *v, loff_t *ppos)\n{\n\tstruct net *net = seq_file_net(f);\n\tstruct netns_pfkey *net_pfkey = net_generic(net, pfkey_net_id);\n\n\treturn seq_hlist_next_rcu(v, &net_pfkey->table, ppos);\n}\n\nstatic void pfkey_seq_stop(struct seq_file *f, void *v)\n\t__releases(rcu)\n{\n\trcu_read_unlock();\n}\n\nstatic const struct seq_operations pfkey_seq_ops = {\n\t.start\t= pfkey_seq_start,\n\t.next\t= pfkey_seq_next,\n\t.stop\t= pfkey_seq_stop,\n\t.show\t= pfkey_seq_show,\n};\n\nstatic int __net_init pfkey_init_proc(struct net *net)\n{\n\tstruct proc_dir_entry *e;\n\n\te = proc_create_net(\"pfkey\", 0, net->proc_net, &pfkey_seq_ops,\n\t\t\tsizeof(struct seq_net_private));\n\tif (e == NULL)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic void __net_exit pfkey_exit_proc(struct net *net)\n{\n\tremove_proc_entry(\"pfkey\", net->proc_net);\n}\n#else\nstatic inline int pfkey_init_proc(struct net *net)\n{\n\treturn 0;\n}\n\nstatic inline void pfkey_exit_proc(struct net *net)\n{\n}\n#endif\n\nstatic struct xfrm_mgr pfkeyv2_mgr =\n{\n\t.notify\t\t= pfkey_send_notify,\n\t.acquire\t= pfkey_send_acquire,\n\t.compile_policy\t= pfkey_compile_policy,\n\t.new_mapping\t= pfkey_send_new_mapping,\n\t.notify_policy\t= pfkey_send_policy_notify,\n\t.migrate\t= pfkey_send_migrate,\n\t.is_alive\t= pfkey_is_alive,\n};\n\nstatic int __net_init pfkey_net_init(struct net *net)\n{\n\tstruct netns_pfkey *net_pfkey = net_generic(net, pfkey_net_id);\n\tint rv;\n\n\tINIT_HLIST_HEAD(&net_pfkey->table);\n\tatomic_set(&net_pfkey->socks_nr, 0);\n\n\trv = pfkey_init_proc(net);\n\n\treturn rv;\n}\n\nstatic void __net_exit pfkey_net_exit(struct net *net)\n{\n\tstruct netns_pfkey *net_pfkey = net_generic(net, pfkey_net_id);\n\n\tpfkey_exit_proc(net);\n\tWARN_ON(!hlist_empty(&net_pfkey->table));\n}\n\nstatic struct pernet_operations pfkey_net_ops = {\n\t.init = pfkey_net_init,\n\t.exit = pfkey_net_exit,\n\t.id   = &pfkey_net_id,\n\t.size = sizeof(struct netns_pfkey),\n};\n\nstatic void __exit ipsec_pfkey_exit(void)\n{\n\txfrm_unregister_km(&pfkeyv2_mgr);\n\tsock_unregister(PF_KEY);\n\tunregister_pernet_subsys(&pfkey_net_ops);\n\tproto_unregister(&key_proto);\n}\n\nstatic int __init ipsec_pfkey_init(void)\n{\n\tint err = proto_register(&key_proto, 0);\n\n\tif (err != 0)\n\t\tgoto out;\n\n\terr = register_pernet_subsys(&pfkey_net_ops);\n\tif (err != 0)\n\t\tgoto out_unregister_key_proto;\n\terr = sock_register(&pfkey_family_ops);\n\tif (err != 0)\n\t\tgoto out_unregister_pernet;\n\terr = xfrm_register_km(&pfkeyv2_mgr);\n\tif (err != 0)\n\t\tgoto out_sock_unregister;\nout:\n\treturn err;\n\nout_sock_unregister:\n\tsock_unregister(PF_KEY);\nout_unregister_pernet:\n\tunregister_pernet_subsys(&pfkey_net_ops);\nout_unregister_key_proto:\n\tproto_unregister(&key_proto);\n\tgoto out;\n}\n\nmodule_init(ipsec_pfkey_init);\nmodule_exit(ipsec_pfkey_exit);\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_NETPROTO(PF_KEY);\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n * net/key/af_key.c\tAn implementation of PF_KEYv2 sockets.\n *\n * Authors:\tMaxim Giryaev\t<gem@asplinux.ru>\n *\t\tDavid S. Miller\t<davem@redhat.com>\n *\t\tAlexey Kuznetsov <kuznet@ms2.inr.ac.ru>\n *\t\tKunihiro Ishiguro <kunihiro@ipinfusion.com>\n *\t\tKazunori MIYAZAWA / USAGI Project <miyazawa@linux-ipv6.org>\n *\t\tDerek Atkins <derek@ihtfp.com>\n */\n\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/socket.h>\n#include <linux/pfkeyv2.h>\n#include <linux/ipsec.h>\n#include <linux/skbuff.h>\n#include <linux/rtnetlink.h>\n#include <linux/in.h>\n#include <linux/in6.h>\n#include <linux/proc_fs.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <net/net_namespace.h>\n#include <net/netns/generic.h>\n#include <net/xfrm.h>\n\n#include <net/sock.h>\n\n#define _X2KEY(x) ((x) == XFRM_INF ? 0 : (x))\n#define _KEY2X(x) ((x) == 0 ? XFRM_INF : (x))\n\nstatic unsigned int pfkey_net_id __read_mostly;\nstruct netns_pfkey {\n\t/* List of all pfkey sockets. */\n\tstruct hlist_head table;\n\tatomic_t socks_nr;\n};\nstatic DEFINE_MUTEX(pfkey_mutex);\n\n#define DUMMY_MARK 0\nstatic const struct xfrm_mark dummy_mark = {0, 0};\nstruct pfkey_sock {\n\t/* struct sock must be the first member of struct pfkey_sock */\n\tstruct sock\tsk;\n\tint\t\tregistered;\n\tint\t\tpromisc;\n\n\tstruct {\n\t\tuint8_t\t\tmsg_version;\n\t\tuint32_t\tmsg_portid;\n\t\tint\t\t(*dump)(struct pfkey_sock *sk);\n\t\tvoid\t\t(*done)(struct pfkey_sock *sk);\n\t\tunion {\n\t\t\tstruct xfrm_policy_walk\tpolicy;\n\t\t\tstruct xfrm_state_walk\tstate;\n\t\t} u;\n\t\tstruct sk_buff\t*skb;\n\t} dump;\n\tstruct mutex dump_lock;\n};\n\nstatic int parse_sockaddr_pair(struct sockaddr *sa, int ext_len,\n\t\t\t       xfrm_address_t *saddr, xfrm_address_t *daddr,\n\t\t\t       u16 *family);\n\nstatic inline struct pfkey_sock *pfkey_sk(struct sock *sk)\n{\n\treturn (struct pfkey_sock *)sk;\n}\n\nstatic int pfkey_can_dump(const struct sock *sk)\n{\n\tif (3 * atomic_read(&sk->sk_rmem_alloc) <= 2 * sk->sk_rcvbuf)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic void pfkey_terminate_dump(struct pfkey_sock *pfk)\n{\n\tif (pfk->dump.dump) {\n\t\tif (pfk->dump.skb) {\n\t\t\tkfree_skb(pfk->dump.skb);\n\t\t\tpfk->dump.skb = NULL;\n\t\t}\n\t\tpfk->dump.done(pfk);\n\t\tpfk->dump.dump = NULL;\n\t\tpfk->dump.done = NULL;\n\t}\n}\n\nstatic void pfkey_sock_destruct(struct sock *sk)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct netns_pfkey *net_pfkey = net_generic(net, pfkey_net_id);\n\n\tpfkey_terminate_dump(pfkey_sk(sk));\n\tskb_queue_purge(&sk->sk_receive_queue);\n\n\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\tpr_err(\"Attempt to release alive pfkey socket: %p\\n\", sk);\n\t\treturn;\n\t}\n\n\tWARN_ON(atomic_read(&sk->sk_rmem_alloc));\n\tWARN_ON(refcount_read(&sk->sk_wmem_alloc));\n\n\tatomic_dec(&net_pfkey->socks_nr);\n}\n\nstatic const struct proto_ops pfkey_ops;\n\nstatic void pfkey_insert(struct sock *sk)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct netns_pfkey *net_pfkey = net_generic(net, pfkey_net_id);\n\n\tmutex_lock(&pfkey_mutex);\n\tsk_add_node_rcu(sk, &net_pfkey->table);\n\tmutex_unlock(&pfkey_mutex);\n}\n\nstatic void pfkey_remove(struct sock *sk)\n{\n\tmutex_lock(&pfkey_mutex);\n\tsk_del_node_init_rcu(sk);\n\tmutex_unlock(&pfkey_mutex);\n}\n\nstatic struct proto key_proto = {\n\t.name\t  = \"KEY\",\n\t.owner\t  = THIS_MODULE,\n\t.obj_size = sizeof(struct pfkey_sock),\n};\n\nstatic int pfkey_create(struct net *net, struct socket *sock, int protocol,\n\t\t\tint kern)\n{\n\tstruct netns_pfkey *net_pfkey = net_generic(net, pfkey_net_id);\n\tstruct sock *sk;\n\tstruct pfkey_sock *pfk;\n\n\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\tif (sock->type != SOCK_RAW)\n\t\treturn -ESOCKTNOSUPPORT;\n\tif (protocol != PF_KEY_V2)\n\t\treturn -EPROTONOSUPPORT;\n\n\tsk = sk_alloc(net, PF_KEY, GFP_KERNEL, &key_proto, kern);\n\tif (sk == NULL)\n\t\treturn -ENOMEM;\n\n\tpfk = pfkey_sk(sk);\n\tmutex_init(&pfk->dump_lock);\n\n\tsock->ops = &pfkey_ops;\n\tsock_init_data(sock, sk);\n\n\tsk->sk_family = PF_KEY;\n\tsk->sk_destruct = pfkey_sock_destruct;\n\n\tatomic_inc(&net_pfkey->socks_nr);\n\n\tpfkey_insert(sk);\n\n\treturn 0;\n}\n\nstatic int pfkey_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\n\tif (!sk)\n\t\treturn 0;\n\n\tpfkey_remove(sk);\n\n\tsock_orphan(sk);\n\tsock->sk = NULL;\n\tskb_queue_purge(&sk->sk_write_queue);\n\n\tsynchronize_rcu();\n\tsock_put(sk);\n\n\treturn 0;\n}\n\nstatic int pfkey_broadcast_one(struct sk_buff *skb, gfp_t allocation,\n\t\t\t       struct sock *sk)\n{\n\tint err = -ENOBUFS;\n\n\tif (atomic_read(&sk->sk_rmem_alloc) > sk->sk_rcvbuf)\n\t\treturn err;\n\n\tskb = skb_clone(skb, allocation);\n\n\tif (skb) {\n\t\tskb_set_owner_r(skb, sk);\n\t\tskb_queue_tail(&sk->sk_receive_queue, skb);\n\t\tsk->sk_data_ready(sk);\n\t\terr = 0;\n\t}\n\treturn err;\n}\n\n/* Send SKB to all pfkey sockets matching selected criteria.  */\n#define BROADCAST_ALL\t\t0\n#define BROADCAST_ONE\t\t1\n#define BROADCAST_REGISTERED\t2\n#define BROADCAST_PROMISC_ONLY\t4\nstatic int pfkey_broadcast(struct sk_buff *skb, gfp_t allocation,\n\t\t\t   int broadcast_flags, struct sock *one_sk,\n\t\t\t   struct net *net)\n{\n\tstruct netns_pfkey *net_pfkey = net_generic(net, pfkey_net_id);\n\tstruct sock *sk;\n\tint err = -ESRCH;\n\n\t/* XXX Do we need something like netlink_overrun?  I think\n\t * XXX PF_KEY socket apps will not mind current behavior.\n\t */\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\trcu_read_lock();\n\tsk_for_each_rcu(sk, &net_pfkey->table) {\n\t\tstruct pfkey_sock *pfk = pfkey_sk(sk);\n\t\tint err2;\n\n\t\t/* Yes, it means that if you are meant to receive this\n\t\t * pfkey message you receive it twice as promiscuous\n\t\t * socket.\n\t\t */\n\t\tif (pfk->promisc)\n\t\t\tpfkey_broadcast_one(skb, GFP_ATOMIC, sk);\n\n\t\t/* the exact target will be processed later */\n\t\tif (sk == one_sk)\n\t\t\tcontinue;\n\t\tif (broadcast_flags != BROADCAST_ALL) {\n\t\t\tif (broadcast_flags & BROADCAST_PROMISC_ONLY)\n\t\t\t\tcontinue;\n\t\t\tif ((broadcast_flags & BROADCAST_REGISTERED) &&\n\t\t\t    !pfk->registered)\n\t\t\t\tcontinue;\n\t\t\tif (broadcast_flags & BROADCAST_ONE)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\terr2 = pfkey_broadcast_one(skb, GFP_ATOMIC, sk);\n\n\t\t/* Error is cleared after successful sending to at least one\n\t\t * registered KM */\n\t\tif ((broadcast_flags & BROADCAST_REGISTERED) && err)\n\t\t\terr = err2;\n\t}\n\trcu_read_unlock();\n\n\tif (one_sk != NULL)\n\t\terr = pfkey_broadcast_one(skb, allocation, one_sk);\n\n\tkfree_skb(skb);\n\treturn err;\n}\n\nstatic int pfkey_do_dump(struct pfkey_sock *pfk)\n{\n\tstruct sadb_msg *hdr;\n\tint rc;\n\n\tmutex_lock(&pfk->dump_lock);\n\tif (!pfk->dump.dump) {\n\t\trc = 0;\n\t\tgoto out;\n\t}\n\n\trc = pfk->dump.dump(pfk);\n\tif (rc == -ENOBUFS) {\n\t\trc = 0;\n\t\tgoto out;\n\t}\n\n\tif (pfk->dump.skb) {\n\t\tif (!pfkey_can_dump(&pfk->sk)) {\n\t\t\trc = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\thdr = (struct sadb_msg *) pfk->dump.skb->data;\n\t\thdr->sadb_msg_seq = 0;\n\t\thdr->sadb_msg_errno = rc;\n\t\tpfkey_broadcast(pfk->dump.skb, GFP_ATOMIC, BROADCAST_ONE,\n\t\t\t\t&pfk->sk, sock_net(&pfk->sk));\n\t\tpfk->dump.skb = NULL;\n\t}\n\n\tpfkey_terminate_dump(pfk);\n\nout:\n\tmutex_unlock(&pfk->dump_lock);\n\treturn rc;\n}\n\nstatic inline void pfkey_hdr_dup(struct sadb_msg *new,\n\t\t\t\t const struct sadb_msg *orig)\n{\n\t*new = *orig;\n}\n\nstatic int pfkey_error(const struct sadb_msg *orig, int err, struct sock *sk)\n{\n\tstruct sk_buff *skb = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_KERNEL);\n\tstruct sadb_msg *hdr;\n\n\tif (!skb)\n\t\treturn -ENOBUFS;\n\n\t/* Woe be to the platform trying to support PFKEY yet\n\t * having normal errnos outside the 1-255 range, inclusive.\n\t */\n\terr = -err;\n\tif (err == ERESTARTSYS ||\n\t    err == ERESTARTNOHAND ||\n\t    err == ERESTARTNOINTR)\n\t\terr = EINTR;\n\tif (err >= 512)\n\t\terr = EINVAL;\n\tBUG_ON(err <= 0 || err >= 256);\n\n\thdr = skb_put(skb, sizeof(struct sadb_msg));\n\tpfkey_hdr_dup(hdr, orig);\n\thdr->sadb_msg_errno = (uint8_t) err;\n\thdr->sadb_msg_len = (sizeof(struct sadb_msg) /\n\t\t\t     sizeof(uint64_t));\n\n\tpfkey_broadcast(skb, GFP_KERNEL, BROADCAST_ONE, sk, sock_net(sk));\n\n\treturn 0;\n}\n\nstatic const u8 sadb_ext_min_len[] = {\n\t[SADB_EXT_RESERVED]\t\t= (u8) 0,\n\t[SADB_EXT_SA]\t\t\t= (u8) sizeof(struct sadb_sa),\n\t[SADB_EXT_LIFETIME_CURRENT]\t= (u8) sizeof(struct sadb_lifetime),\n\t[SADB_EXT_LIFETIME_HARD]\t= (u8) sizeof(struct sadb_lifetime),\n\t[SADB_EXT_LIFETIME_SOFT]\t= (u8) sizeof(struct sadb_lifetime),\n\t[SADB_EXT_ADDRESS_SRC]\t\t= (u8) sizeof(struct sadb_address),\n\t[SADB_EXT_ADDRESS_DST]\t\t= (u8) sizeof(struct sadb_address),\n\t[SADB_EXT_ADDRESS_PROXY]\t= (u8) sizeof(struct sadb_address),\n\t[SADB_EXT_KEY_AUTH]\t\t= (u8) sizeof(struct sadb_key),\n\t[SADB_EXT_KEY_ENCRYPT]\t\t= (u8) sizeof(struct sadb_key),\n\t[SADB_EXT_IDENTITY_SRC]\t\t= (u8) sizeof(struct sadb_ident),\n\t[SADB_EXT_IDENTITY_DST]\t\t= (u8) sizeof(struct sadb_ident),\n\t[SADB_EXT_SENSITIVITY]\t\t= (u8) sizeof(struct sadb_sens),\n\t[SADB_EXT_PROPOSAL]\t\t= (u8) sizeof(struct sadb_prop),\n\t[SADB_EXT_SUPPORTED_AUTH]\t= (u8) sizeof(struct sadb_supported),\n\t[SADB_EXT_SUPPORTED_ENCRYPT]\t= (u8) sizeof(struct sadb_supported),\n\t[SADB_EXT_SPIRANGE]\t\t= (u8) sizeof(struct sadb_spirange),\n\t[SADB_X_EXT_KMPRIVATE]\t\t= (u8) sizeof(struct sadb_x_kmprivate),\n\t[SADB_X_EXT_POLICY]\t\t= (u8) sizeof(struct sadb_x_policy),\n\t[SADB_X_EXT_SA2]\t\t= (u8) sizeof(struct sadb_x_sa2),\n\t[SADB_X_EXT_NAT_T_TYPE]\t\t= (u8) sizeof(struct sadb_x_nat_t_type),\n\t[SADB_X_EXT_NAT_T_SPORT]\t= (u8) sizeof(struct sadb_x_nat_t_port),\n\t[SADB_X_EXT_NAT_T_DPORT]\t= (u8) sizeof(struct sadb_x_nat_t_port),\n\t[SADB_X_EXT_NAT_T_OA]\t\t= (u8) sizeof(struct sadb_address),\n\t[SADB_X_EXT_SEC_CTX]\t\t= (u8) sizeof(struct sadb_x_sec_ctx),\n\t[SADB_X_EXT_KMADDRESS]\t\t= (u8) sizeof(struct sadb_x_kmaddress),\n\t[SADB_X_EXT_FILTER]\t\t= (u8) sizeof(struct sadb_x_filter),\n};\n\n/* Verify sadb_address_{len,prefixlen} against sa_family.  */\nstatic int verify_address_len(const void *p)\n{\n\tconst struct sadb_address *sp = p;\n\tconst struct sockaddr *addr = (const struct sockaddr *)(sp + 1);\n\tconst struct sockaddr_in *sin;\n#if IS_ENABLED(CONFIG_IPV6)\n\tconst struct sockaddr_in6 *sin6;\n#endif\n\tint len;\n\n\tif (sp->sadb_address_len <\n\t    DIV_ROUND_UP(sizeof(*sp) + offsetofend(typeof(*addr), sa_family),\n\t\t\t sizeof(uint64_t)))\n\t\treturn -EINVAL;\n\n\tswitch (addr->sa_family) {\n\tcase AF_INET:\n\t\tlen = DIV_ROUND_UP(sizeof(*sp) + sizeof(*sin), sizeof(uint64_t));\n\t\tif (sp->sadb_address_len != len ||\n\t\t    sp->sadb_address_prefixlen > 32)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase AF_INET6:\n\t\tlen = DIV_ROUND_UP(sizeof(*sp) + sizeof(*sin6), sizeof(uint64_t));\n\t\tif (sp->sadb_address_len != len ||\n\t\t    sp->sadb_address_prefixlen > 128)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n#endif\n\tdefault:\n\t\t/* It is user using kernel to keep track of security\n\t\t * associations for another protocol, such as\n\t\t * OSPF/RSVP/RIPV2/MIP.  It is user's job to verify\n\t\t * lengths.\n\t\t *\n\t\t * XXX Actually, association/policy database is not yet\n\t\t * XXX able to cope with arbitrary sockaddr families.\n\t\t * XXX When it can, remove this -EINVAL.  -DaveM\n\t\t */\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic inline int sadb_key_len(const struct sadb_key *key)\n{\n\tint key_bytes = DIV_ROUND_UP(key->sadb_key_bits, 8);\n\n\treturn DIV_ROUND_UP(sizeof(struct sadb_key) + key_bytes,\n\t\t\t    sizeof(uint64_t));\n}\n\nstatic int verify_key_len(const void *p)\n{\n\tconst struct sadb_key *key = p;\n\n\tif (sadb_key_len(key) > key->sadb_key_len)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic inline int pfkey_sec_ctx_len(const struct sadb_x_sec_ctx *sec_ctx)\n{\n\treturn DIV_ROUND_UP(sizeof(struct sadb_x_sec_ctx) +\n\t\t\t    sec_ctx->sadb_x_ctx_len,\n\t\t\t    sizeof(uint64_t));\n}\n\nstatic inline int verify_sec_ctx_len(const void *p)\n{\n\tconst struct sadb_x_sec_ctx *sec_ctx = p;\n\tint len = sec_ctx->sadb_x_ctx_len;\n\n\tif (len > PAGE_SIZE)\n\t\treturn -EINVAL;\n\n\tlen = pfkey_sec_ctx_len(sec_ctx);\n\n\tif (sec_ctx->sadb_x_sec_len != len)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic inline struct xfrm_user_sec_ctx *pfkey_sadb2xfrm_user_sec_ctx(const struct sadb_x_sec_ctx *sec_ctx,\n\t\t\t\t\t\t\t\t     gfp_t gfp)\n{\n\tstruct xfrm_user_sec_ctx *uctx = NULL;\n\tint ctx_size = sec_ctx->sadb_x_ctx_len;\n\n\tuctx = kmalloc((sizeof(*uctx)+ctx_size), gfp);\n\n\tif (!uctx)\n\t\treturn NULL;\n\n\tuctx->len = pfkey_sec_ctx_len(sec_ctx);\n\tuctx->exttype = sec_ctx->sadb_x_sec_exttype;\n\tuctx->ctx_doi = sec_ctx->sadb_x_ctx_doi;\n\tuctx->ctx_alg = sec_ctx->sadb_x_ctx_alg;\n\tuctx->ctx_len = sec_ctx->sadb_x_ctx_len;\n\tmemcpy(uctx + 1, sec_ctx + 1,\n\t       uctx->ctx_len);\n\n\treturn uctx;\n}\n\nstatic int present_and_same_family(const struct sadb_address *src,\n\t\t\t\t   const struct sadb_address *dst)\n{\n\tconst struct sockaddr *s_addr, *d_addr;\n\n\tif (!src || !dst)\n\t\treturn 0;\n\n\ts_addr = (const struct sockaddr *)(src + 1);\n\td_addr = (const struct sockaddr *)(dst + 1);\n\tif (s_addr->sa_family != d_addr->sa_family)\n\t\treturn 0;\n\tif (s_addr->sa_family != AF_INET\n#if IS_ENABLED(CONFIG_IPV6)\n\t    && s_addr->sa_family != AF_INET6\n#endif\n\t\t)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic int parse_exthdrs(struct sk_buff *skb, const struct sadb_msg *hdr, void **ext_hdrs)\n{\n\tconst char *p = (char *) hdr;\n\tint len = skb->len;\n\n\tlen -= sizeof(*hdr);\n\tp += sizeof(*hdr);\n\twhile (len > 0) {\n\t\tconst struct sadb_ext *ehdr = (const struct sadb_ext *) p;\n\t\tuint16_t ext_type;\n\t\tint ext_len;\n\n\t\tif (len < sizeof(*ehdr))\n\t\t\treturn -EINVAL;\n\n\t\text_len  = ehdr->sadb_ext_len;\n\t\text_len *= sizeof(uint64_t);\n\t\text_type = ehdr->sadb_ext_type;\n\t\tif (ext_len < sizeof(uint64_t) ||\n\t\t    ext_len > len ||\n\t\t    ext_type == SADB_EXT_RESERVED)\n\t\t\treturn -EINVAL;\n\n\t\tif (ext_type <= SADB_EXT_MAX) {\n\t\t\tint min = (int) sadb_ext_min_len[ext_type];\n\t\t\tif (ext_len < min)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (ext_hdrs[ext_type-1] != NULL)\n\t\t\t\treturn -EINVAL;\n\t\t\tswitch (ext_type) {\n\t\t\tcase SADB_EXT_ADDRESS_SRC:\n\t\t\tcase SADB_EXT_ADDRESS_DST:\n\t\t\tcase SADB_EXT_ADDRESS_PROXY:\n\t\t\tcase SADB_X_EXT_NAT_T_OA:\n\t\t\t\tif (verify_address_len(p))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tbreak;\n\t\t\tcase SADB_X_EXT_SEC_CTX:\n\t\t\t\tif (verify_sec_ctx_len(p))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tbreak;\n\t\t\tcase SADB_EXT_KEY_AUTH:\n\t\t\tcase SADB_EXT_KEY_ENCRYPT:\n\t\t\t\tif (verify_key_len(p))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\text_hdrs[ext_type-1] = (void *) p;\n\t\t}\n\t\tp   += ext_len;\n\t\tlen -= ext_len;\n\t}\n\n\treturn 0;\n}\n\nstatic uint16_t\npfkey_satype2proto(uint8_t satype)\n{\n\tswitch (satype) {\n\tcase SADB_SATYPE_UNSPEC:\n\t\treturn IPSEC_PROTO_ANY;\n\tcase SADB_SATYPE_AH:\n\t\treturn IPPROTO_AH;\n\tcase SADB_SATYPE_ESP:\n\t\treturn IPPROTO_ESP;\n\tcase SADB_X_SATYPE_IPCOMP:\n\t\treturn IPPROTO_COMP;\n\tdefault:\n\t\treturn 0;\n\t}\n\t/* NOTREACHED */\n}\n\nstatic uint8_t\npfkey_proto2satype(uint16_t proto)\n{\n\tswitch (proto) {\n\tcase IPPROTO_AH:\n\t\treturn SADB_SATYPE_AH;\n\tcase IPPROTO_ESP:\n\t\treturn SADB_SATYPE_ESP;\n\tcase IPPROTO_COMP:\n\t\treturn SADB_X_SATYPE_IPCOMP;\n\tdefault:\n\t\treturn 0;\n\t}\n\t/* NOTREACHED */\n}\n\n/* BTW, this scheme means that there is no way with PFKEY2 sockets to\n * say specifically 'just raw sockets' as we encode them as 255.\n */\n\nstatic uint8_t pfkey_proto_to_xfrm(uint8_t proto)\n{\n\treturn proto == IPSEC_PROTO_ANY ? 0 : proto;\n}\n\nstatic uint8_t pfkey_proto_from_xfrm(uint8_t proto)\n{\n\treturn proto ? proto : IPSEC_PROTO_ANY;\n}\n\nstatic inline int pfkey_sockaddr_len(sa_family_t family)\n{\n\tswitch (family) {\n\tcase AF_INET:\n\t\treturn sizeof(struct sockaddr_in);\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase AF_INET6:\n\t\treturn sizeof(struct sockaddr_in6);\n#endif\n\t}\n\treturn 0;\n}\n\nstatic\nint pfkey_sockaddr_extract(const struct sockaddr *sa, xfrm_address_t *xaddr)\n{\n\tswitch (sa->sa_family) {\n\tcase AF_INET:\n\t\txaddr->a4 =\n\t\t\t((struct sockaddr_in *)sa)->sin_addr.s_addr;\n\t\treturn AF_INET;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase AF_INET6:\n\t\tmemcpy(xaddr->a6,\n\t\t       &((struct sockaddr_in6 *)sa)->sin6_addr,\n\t\t       sizeof(struct in6_addr));\n\t\treturn AF_INET6;\n#endif\n\t}\n\treturn 0;\n}\n\nstatic\nint pfkey_sadb_addr2xfrm_addr(const struct sadb_address *addr, xfrm_address_t *xaddr)\n{\n\treturn pfkey_sockaddr_extract((struct sockaddr *)(addr + 1),\n\t\t\t\t      xaddr);\n}\n\nstatic struct  xfrm_state *pfkey_xfrm_state_lookup(struct net *net, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tconst struct sadb_sa *sa;\n\tconst struct sadb_address *addr;\n\tuint16_t proto;\n\tunsigned short family;\n\txfrm_address_t *xaddr;\n\n\tsa = ext_hdrs[SADB_EXT_SA - 1];\n\tif (sa == NULL)\n\t\treturn NULL;\n\n\tproto = pfkey_satype2proto(hdr->sadb_msg_satype);\n\tif (proto == 0)\n\t\treturn NULL;\n\n\t/* sadb_address_len should be checked by caller */\n\taddr = ext_hdrs[SADB_EXT_ADDRESS_DST - 1];\n\tif (addr == NULL)\n\t\treturn NULL;\n\n\tfamily = ((const struct sockaddr *)(addr + 1))->sa_family;\n\tswitch (family) {\n\tcase AF_INET:\n\t\txaddr = (xfrm_address_t *)&((const struct sockaddr_in *)(addr + 1))->sin_addr;\n\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase AF_INET6:\n\t\txaddr = (xfrm_address_t *)&((const struct sockaddr_in6 *)(addr + 1))->sin6_addr;\n\t\tbreak;\n#endif\n\tdefault:\n\t\txaddr = NULL;\n\t}\n\n\tif (!xaddr)\n\t\treturn NULL;\n\n\treturn xfrm_state_lookup(net, DUMMY_MARK, xaddr, sa->sadb_sa_spi, proto, family);\n}\n\n#define PFKEY_ALIGN8(a) (1 + (((a) - 1) | (8 - 1)))\n\nstatic int\npfkey_sockaddr_size(sa_family_t family)\n{\n\treturn PFKEY_ALIGN8(pfkey_sockaddr_len(family));\n}\n\nstatic inline int pfkey_mode_from_xfrm(int mode)\n{\n\tswitch(mode) {\n\tcase XFRM_MODE_TRANSPORT:\n\t\treturn IPSEC_MODE_TRANSPORT;\n\tcase XFRM_MODE_TUNNEL:\n\t\treturn IPSEC_MODE_TUNNEL;\n\tcase XFRM_MODE_BEET:\n\t\treturn IPSEC_MODE_BEET;\n\tdefault:\n\t\treturn -1;\n\t}\n}\n\nstatic inline int pfkey_mode_to_xfrm(int mode)\n{\n\tswitch(mode) {\n\tcase IPSEC_MODE_ANY:\t/*XXX*/\n\tcase IPSEC_MODE_TRANSPORT:\n\t\treturn XFRM_MODE_TRANSPORT;\n\tcase IPSEC_MODE_TUNNEL:\n\t\treturn XFRM_MODE_TUNNEL;\n\tcase IPSEC_MODE_BEET:\n\t\treturn XFRM_MODE_BEET;\n\tdefault:\n\t\treturn -1;\n\t}\n}\n\nstatic unsigned int pfkey_sockaddr_fill(const xfrm_address_t *xaddr, __be16 port,\n\t\t\t\t\tstruct sockaddr *sa,\n\t\t\t\t\tunsigned short family)\n{\n\tswitch (family) {\n\tcase AF_INET:\n\t    {\n\t\tstruct sockaddr_in *sin = (struct sockaddr_in *)sa;\n\t\tsin->sin_family = AF_INET;\n\t\tsin->sin_port = port;\n\t\tsin->sin_addr.s_addr = xaddr->a4;\n\t\tmemset(sin->sin_zero, 0, sizeof(sin->sin_zero));\n\t\treturn 32;\n\t    }\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase AF_INET6:\n\t    {\n\t\tstruct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)sa;\n\t\tsin6->sin6_family = AF_INET6;\n\t\tsin6->sin6_port = port;\n\t\tsin6->sin6_flowinfo = 0;\n\t\tsin6->sin6_addr = xaddr->in6;\n\t\tsin6->sin6_scope_id = 0;\n\t\treturn 128;\n\t    }\n#endif\n\t}\n\treturn 0;\n}\n\nstatic struct sk_buff *__pfkey_xfrm_state2msg(const struct xfrm_state *x,\n\t\t\t\t\t      int add_keys, int hsc)\n{\n\tstruct sk_buff *skb;\n\tstruct sadb_msg *hdr;\n\tstruct sadb_sa *sa;\n\tstruct sadb_lifetime *lifetime;\n\tstruct sadb_address *addr;\n\tstruct sadb_key *key;\n\tstruct sadb_x_sa2 *sa2;\n\tstruct sadb_x_sec_ctx *sec_ctx;\n\tstruct xfrm_sec_ctx *xfrm_ctx;\n\tint ctx_size = 0;\n\tint size;\n\tint auth_key_size = 0;\n\tint encrypt_key_size = 0;\n\tint sockaddr_size;\n\tstruct xfrm_encap_tmpl *natt = NULL;\n\tint mode;\n\n\t/* address family check */\n\tsockaddr_size = pfkey_sockaddr_size(x->props.family);\n\tif (!sockaddr_size)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* base, SA, (lifetime (HSC),) address(SD), (address(P),)\n\t   key(AE), (identity(SD),) (sensitivity)> */\n\tsize = sizeof(struct sadb_msg) +sizeof(struct sadb_sa) +\n\t\tsizeof(struct sadb_lifetime) +\n\t\t((hsc & 1) ? sizeof(struct sadb_lifetime) : 0) +\n\t\t((hsc & 2) ? sizeof(struct sadb_lifetime) : 0) +\n\t\t\tsizeof(struct sadb_address)*2 +\n\t\t\t\tsockaddr_size*2 +\n\t\t\t\t\tsizeof(struct sadb_x_sa2);\n\n\tif ((xfrm_ctx = x->security)) {\n\t\tctx_size = PFKEY_ALIGN8(xfrm_ctx->ctx_len);\n\t\tsize += sizeof(struct sadb_x_sec_ctx) + ctx_size;\n\t}\n\n\t/* identity & sensitivity */\n\tif (!xfrm_addr_equal(&x->sel.saddr, &x->props.saddr, x->props.family))\n\t\tsize += sizeof(struct sadb_address) + sockaddr_size;\n\n\tif (add_keys) {\n\t\tif (x->aalg && x->aalg->alg_key_len) {\n\t\t\tauth_key_size =\n\t\t\t\tPFKEY_ALIGN8((x->aalg->alg_key_len + 7) / 8);\n\t\t\tsize += sizeof(struct sadb_key) + auth_key_size;\n\t\t}\n\t\tif (x->ealg && x->ealg->alg_key_len) {\n\t\t\tencrypt_key_size =\n\t\t\t\tPFKEY_ALIGN8((x->ealg->alg_key_len+7) / 8);\n\t\t\tsize += sizeof(struct sadb_key) + encrypt_key_size;\n\t\t}\n\t}\n\tif (x->encap)\n\t\tnatt = x->encap;\n\n\tif (natt && natt->encap_type) {\n\t\tsize += sizeof(struct sadb_x_nat_t_type);\n\t\tsize += sizeof(struct sadb_x_nat_t_port);\n\t\tsize += sizeof(struct sadb_x_nat_t_port);\n\t}\n\n\tskb =  alloc_skb(size + 16, GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn ERR_PTR(-ENOBUFS);\n\n\t/* call should fill header later */\n\thdr = skb_put(skb, sizeof(struct sadb_msg));\n\tmemset(hdr, 0, size);\t/* XXX do we need this ? */\n\thdr->sadb_msg_len = size / sizeof(uint64_t);\n\n\t/* sa */\n\tsa = skb_put(skb, sizeof(struct sadb_sa));\n\tsa->sadb_sa_len = sizeof(struct sadb_sa)/sizeof(uint64_t);\n\tsa->sadb_sa_exttype = SADB_EXT_SA;\n\tsa->sadb_sa_spi = x->id.spi;\n\tsa->sadb_sa_replay = x->props.replay_window;\n\tswitch (x->km.state) {\n\tcase XFRM_STATE_VALID:\n\t\tsa->sadb_sa_state = x->km.dying ?\n\t\t\tSADB_SASTATE_DYING : SADB_SASTATE_MATURE;\n\t\tbreak;\n\tcase XFRM_STATE_ACQ:\n\t\tsa->sadb_sa_state = SADB_SASTATE_LARVAL;\n\t\tbreak;\n\tdefault:\n\t\tsa->sadb_sa_state = SADB_SASTATE_DEAD;\n\t\tbreak;\n\t}\n\tsa->sadb_sa_auth = 0;\n\tif (x->aalg) {\n\t\tstruct xfrm_algo_desc *a = xfrm_aalg_get_byname(x->aalg->alg_name, 0);\n\t\tsa->sadb_sa_auth = (a && a->pfkey_supported) ?\n\t\t\t\t\ta->desc.sadb_alg_id : 0;\n\t}\n\tsa->sadb_sa_encrypt = 0;\n\tBUG_ON(x->ealg && x->calg);\n\tif (x->ealg) {\n\t\tstruct xfrm_algo_desc *a = xfrm_ealg_get_byname(x->ealg->alg_name, 0);\n\t\tsa->sadb_sa_encrypt = (a && a->pfkey_supported) ?\n\t\t\t\t\ta->desc.sadb_alg_id : 0;\n\t}\n\t/* KAME compatible: sadb_sa_encrypt is overloaded with calg id */\n\tif (x->calg) {\n\t\tstruct xfrm_algo_desc *a = xfrm_calg_get_byname(x->calg->alg_name, 0);\n\t\tsa->sadb_sa_encrypt = (a && a->pfkey_supported) ?\n\t\t\t\t\ta->desc.sadb_alg_id : 0;\n\t}\n\n\tsa->sadb_sa_flags = 0;\n\tif (x->props.flags & XFRM_STATE_NOECN)\n\t\tsa->sadb_sa_flags |= SADB_SAFLAGS_NOECN;\n\tif (x->props.flags & XFRM_STATE_DECAP_DSCP)\n\t\tsa->sadb_sa_flags |= SADB_SAFLAGS_DECAP_DSCP;\n\tif (x->props.flags & XFRM_STATE_NOPMTUDISC)\n\t\tsa->sadb_sa_flags |= SADB_SAFLAGS_NOPMTUDISC;\n\n\t/* hard time */\n\tif (hsc & 2) {\n\t\tlifetime = skb_put(skb, sizeof(struct sadb_lifetime));\n\t\tlifetime->sadb_lifetime_len =\n\t\t\tsizeof(struct sadb_lifetime)/sizeof(uint64_t);\n\t\tlifetime->sadb_lifetime_exttype = SADB_EXT_LIFETIME_HARD;\n\t\tlifetime->sadb_lifetime_allocations =  _X2KEY(x->lft.hard_packet_limit);\n\t\tlifetime->sadb_lifetime_bytes = _X2KEY(x->lft.hard_byte_limit);\n\t\tlifetime->sadb_lifetime_addtime = x->lft.hard_add_expires_seconds;\n\t\tlifetime->sadb_lifetime_usetime = x->lft.hard_use_expires_seconds;\n\t}\n\t/* soft time */\n\tif (hsc & 1) {\n\t\tlifetime = skb_put(skb, sizeof(struct sadb_lifetime));\n\t\tlifetime->sadb_lifetime_len =\n\t\t\tsizeof(struct sadb_lifetime)/sizeof(uint64_t);\n\t\tlifetime->sadb_lifetime_exttype = SADB_EXT_LIFETIME_SOFT;\n\t\tlifetime->sadb_lifetime_allocations =  _X2KEY(x->lft.soft_packet_limit);\n\t\tlifetime->sadb_lifetime_bytes = _X2KEY(x->lft.soft_byte_limit);\n\t\tlifetime->sadb_lifetime_addtime = x->lft.soft_add_expires_seconds;\n\t\tlifetime->sadb_lifetime_usetime = x->lft.soft_use_expires_seconds;\n\t}\n\t/* current time */\n\tlifetime = skb_put(skb, sizeof(struct sadb_lifetime));\n\tlifetime->sadb_lifetime_len =\n\t\tsizeof(struct sadb_lifetime)/sizeof(uint64_t);\n\tlifetime->sadb_lifetime_exttype = SADB_EXT_LIFETIME_CURRENT;\n\tlifetime->sadb_lifetime_allocations = x->curlft.packets;\n\tlifetime->sadb_lifetime_bytes = x->curlft.bytes;\n\tlifetime->sadb_lifetime_addtime = x->curlft.add_time;\n\tlifetime->sadb_lifetime_usetime = x->curlft.use_time;\n\t/* src address */\n\taddr = skb_put(skb, sizeof(struct sadb_address) + sockaddr_size);\n\taddr->sadb_address_len =\n\t\t(sizeof(struct sadb_address)+sockaddr_size)/\n\t\t\tsizeof(uint64_t);\n\taddr->sadb_address_exttype = SADB_EXT_ADDRESS_SRC;\n\t/* \"if the ports are non-zero, then the sadb_address_proto field,\n\t   normally zero, MUST be filled in with the transport\n\t   protocol's number.\" - RFC2367 */\n\taddr->sadb_address_proto = 0;\n\taddr->sadb_address_reserved = 0;\n\n\taddr->sadb_address_prefixlen =\n\t\tpfkey_sockaddr_fill(&x->props.saddr, 0,\n\t\t\t\t    (struct sockaddr *) (addr + 1),\n\t\t\t\t    x->props.family);\n\tBUG_ON(!addr->sadb_address_prefixlen);\n\n\t/* dst address */\n\taddr = skb_put(skb, sizeof(struct sadb_address) + sockaddr_size);\n\taddr->sadb_address_len =\n\t\t(sizeof(struct sadb_address)+sockaddr_size)/\n\t\t\tsizeof(uint64_t);\n\taddr->sadb_address_exttype = SADB_EXT_ADDRESS_DST;\n\taddr->sadb_address_proto = 0;\n\taddr->sadb_address_reserved = 0;\n\n\taddr->sadb_address_prefixlen =\n\t\tpfkey_sockaddr_fill(&x->id.daddr, 0,\n\t\t\t\t    (struct sockaddr *) (addr + 1),\n\t\t\t\t    x->props.family);\n\tBUG_ON(!addr->sadb_address_prefixlen);\n\n\tif (!xfrm_addr_equal(&x->sel.saddr, &x->props.saddr,\n\t\t\t     x->props.family)) {\n\t\taddr = skb_put(skb,\n\t\t\t       sizeof(struct sadb_address) + sockaddr_size);\n\t\taddr->sadb_address_len =\n\t\t\t(sizeof(struct sadb_address)+sockaddr_size)/\n\t\t\tsizeof(uint64_t);\n\t\taddr->sadb_address_exttype = SADB_EXT_ADDRESS_PROXY;\n\t\taddr->sadb_address_proto =\n\t\t\tpfkey_proto_from_xfrm(x->sel.proto);\n\t\taddr->sadb_address_prefixlen = x->sel.prefixlen_s;\n\t\taddr->sadb_address_reserved = 0;\n\n\t\tpfkey_sockaddr_fill(&x->sel.saddr, x->sel.sport,\n\t\t\t\t    (struct sockaddr *) (addr + 1),\n\t\t\t\t    x->props.family);\n\t}\n\n\t/* auth key */\n\tif (add_keys && auth_key_size) {\n\t\tkey = skb_put(skb, sizeof(struct sadb_key) + auth_key_size);\n\t\tkey->sadb_key_len = (sizeof(struct sadb_key) + auth_key_size) /\n\t\t\tsizeof(uint64_t);\n\t\tkey->sadb_key_exttype = SADB_EXT_KEY_AUTH;\n\t\tkey->sadb_key_bits = x->aalg->alg_key_len;\n\t\tkey->sadb_key_reserved = 0;\n\t\tmemcpy(key + 1, x->aalg->alg_key, (x->aalg->alg_key_len+7)/8);\n\t}\n\t/* encrypt key */\n\tif (add_keys && encrypt_key_size) {\n\t\tkey = skb_put(skb, sizeof(struct sadb_key) + encrypt_key_size);\n\t\tkey->sadb_key_len = (sizeof(struct sadb_key) +\n\t\t\t\t     encrypt_key_size) / sizeof(uint64_t);\n\t\tkey->sadb_key_exttype = SADB_EXT_KEY_ENCRYPT;\n\t\tkey->sadb_key_bits = x->ealg->alg_key_len;\n\t\tkey->sadb_key_reserved = 0;\n\t\tmemcpy(key + 1, x->ealg->alg_key,\n\t\t       (x->ealg->alg_key_len+7)/8);\n\t}\n\n\t/* sa */\n\tsa2 = skb_put(skb, sizeof(struct sadb_x_sa2));\n\tsa2->sadb_x_sa2_len = sizeof(struct sadb_x_sa2)/sizeof(uint64_t);\n\tsa2->sadb_x_sa2_exttype = SADB_X_EXT_SA2;\n\tif ((mode = pfkey_mode_from_xfrm(x->props.mode)) < 0) {\n\t\tkfree_skb(skb);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\tsa2->sadb_x_sa2_mode = mode;\n\tsa2->sadb_x_sa2_reserved1 = 0;\n\tsa2->sadb_x_sa2_reserved2 = 0;\n\tsa2->sadb_x_sa2_sequence = 0;\n\tsa2->sadb_x_sa2_reqid = x->props.reqid;\n\n\tif (natt && natt->encap_type) {\n\t\tstruct sadb_x_nat_t_type *n_type;\n\t\tstruct sadb_x_nat_t_port *n_port;\n\n\t\t/* type */\n\t\tn_type = skb_put(skb, sizeof(*n_type));\n\t\tn_type->sadb_x_nat_t_type_len = sizeof(*n_type)/sizeof(uint64_t);\n\t\tn_type->sadb_x_nat_t_type_exttype = SADB_X_EXT_NAT_T_TYPE;\n\t\tn_type->sadb_x_nat_t_type_type = natt->encap_type;\n\t\tn_type->sadb_x_nat_t_type_reserved[0] = 0;\n\t\tn_type->sadb_x_nat_t_type_reserved[1] = 0;\n\t\tn_type->sadb_x_nat_t_type_reserved[2] = 0;\n\n\t\t/* source port */\n\t\tn_port = skb_put(skb, sizeof(*n_port));\n\t\tn_port->sadb_x_nat_t_port_len = sizeof(*n_port)/sizeof(uint64_t);\n\t\tn_port->sadb_x_nat_t_port_exttype = SADB_X_EXT_NAT_T_SPORT;\n\t\tn_port->sadb_x_nat_t_port_port = natt->encap_sport;\n\t\tn_port->sadb_x_nat_t_port_reserved = 0;\n\n\t\t/* dest port */\n\t\tn_port = skb_put(skb, sizeof(*n_port));\n\t\tn_port->sadb_x_nat_t_port_len = sizeof(*n_port)/sizeof(uint64_t);\n\t\tn_port->sadb_x_nat_t_port_exttype = SADB_X_EXT_NAT_T_DPORT;\n\t\tn_port->sadb_x_nat_t_port_port = natt->encap_dport;\n\t\tn_port->sadb_x_nat_t_port_reserved = 0;\n\t}\n\n\t/* security context */\n\tif (xfrm_ctx) {\n\t\tsec_ctx = skb_put(skb,\n\t\t\t\t  sizeof(struct sadb_x_sec_ctx) + ctx_size);\n\t\tsec_ctx->sadb_x_sec_len =\n\t\t  (sizeof(struct sadb_x_sec_ctx) + ctx_size) / sizeof(uint64_t);\n\t\tsec_ctx->sadb_x_sec_exttype = SADB_X_EXT_SEC_CTX;\n\t\tsec_ctx->sadb_x_ctx_doi = xfrm_ctx->ctx_doi;\n\t\tsec_ctx->sadb_x_ctx_alg = xfrm_ctx->ctx_alg;\n\t\tsec_ctx->sadb_x_ctx_len = xfrm_ctx->ctx_len;\n\t\tmemcpy(sec_ctx + 1, xfrm_ctx->ctx_str,\n\t\t       xfrm_ctx->ctx_len);\n\t}\n\n\treturn skb;\n}\n\n\nstatic inline struct sk_buff *pfkey_xfrm_state2msg(const struct xfrm_state *x)\n{\n\tstruct sk_buff *skb;\n\n\tskb = __pfkey_xfrm_state2msg(x, 1, 3);\n\n\treturn skb;\n}\n\nstatic inline struct sk_buff *pfkey_xfrm_state2msg_expire(const struct xfrm_state *x,\n\t\t\t\t\t\t\t  int hsc)\n{\n\treturn __pfkey_xfrm_state2msg(x, 0, hsc);\n}\n\nstatic struct xfrm_state * pfkey_msg2xfrm_state(struct net *net,\n\t\t\t\t\t\tconst struct sadb_msg *hdr,\n\t\t\t\t\t\tvoid * const *ext_hdrs)\n{\n\tstruct xfrm_state *x;\n\tconst struct sadb_lifetime *lifetime;\n\tconst struct sadb_sa *sa;\n\tconst struct sadb_key *key;\n\tconst struct sadb_x_sec_ctx *sec_ctx;\n\tuint16_t proto;\n\tint err;\n\n\n\tsa = ext_hdrs[SADB_EXT_SA - 1];\n\tif (!sa ||\n\t    !present_and_same_family(ext_hdrs[SADB_EXT_ADDRESS_SRC-1],\n\t\t\t\t     ext_hdrs[SADB_EXT_ADDRESS_DST-1]))\n\t\treturn ERR_PTR(-EINVAL);\n\tif (hdr->sadb_msg_satype == SADB_SATYPE_ESP &&\n\t    !ext_hdrs[SADB_EXT_KEY_ENCRYPT-1])\n\t\treturn ERR_PTR(-EINVAL);\n\tif (hdr->sadb_msg_satype == SADB_SATYPE_AH &&\n\t    !ext_hdrs[SADB_EXT_KEY_AUTH-1])\n\t\treturn ERR_PTR(-EINVAL);\n\tif (!!ext_hdrs[SADB_EXT_LIFETIME_HARD-1] !=\n\t    !!ext_hdrs[SADB_EXT_LIFETIME_SOFT-1])\n\t\treturn ERR_PTR(-EINVAL);\n\n\tproto = pfkey_satype2proto(hdr->sadb_msg_satype);\n\tif (proto == 0)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* default error is no buffer space */\n\terr = -ENOBUFS;\n\n\t/* RFC2367:\n\n   Only SADB_SASTATE_MATURE SAs may be submitted in an SADB_ADD message.\n   SADB_SASTATE_LARVAL SAs are created by SADB_GETSPI and it is not\n   sensible to add a new SA in the DYING or SADB_SASTATE_DEAD state.\n   Therefore, the sadb_sa_state field of all submitted SAs MUST be\n   SADB_SASTATE_MATURE and the kernel MUST return an error if this is\n   not true.\n\n\t   However, KAME setkey always uses SADB_SASTATE_LARVAL.\n\t   Hence, we have to _ignore_ sadb_sa_state, which is also reasonable.\n\t */\n\tif (sa->sadb_sa_auth > SADB_AALG_MAX ||\n\t    (hdr->sadb_msg_satype == SADB_X_SATYPE_IPCOMP &&\n\t     sa->sadb_sa_encrypt > SADB_X_CALG_MAX) ||\n\t    sa->sadb_sa_encrypt > SADB_EALG_MAX)\n\t\treturn ERR_PTR(-EINVAL);\n\tkey = ext_hdrs[SADB_EXT_KEY_AUTH - 1];\n\tif (key != NULL &&\n\t    sa->sadb_sa_auth != SADB_X_AALG_NULL &&\n\t    key->sadb_key_bits == 0)\n\t\treturn ERR_PTR(-EINVAL);\n\tkey = ext_hdrs[SADB_EXT_KEY_ENCRYPT-1];\n\tif (key != NULL &&\n\t    sa->sadb_sa_encrypt != SADB_EALG_NULL &&\n\t    key->sadb_key_bits == 0)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tx = xfrm_state_alloc(net);\n\tif (x == NULL)\n\t\treturn ERR_PTR(-ENOBUFS);\n\n\tx->id.proto = proto;\n\tx->id.spi = sa->sadb_sa_spi;\n\tx->props.replay_window = min_t(unsigned int, sa->sadb_sa_replay,\n\t\t\t\t\t(sizeof(x->replay.bitmap) * 8));\n\tif (sa->sadb_sa_flags & SADB_SAFLAGS_NOECN)\n\t\tx->props.flags |= XFRM_STATE_NOECN;\n\tif (sa->sadb_sa_flags & SADB_SAFLAGS_DECAP_DSCP)\n\t\tx->props.flags |= XFRM_STATE_DECAP_DSCP;\n\tif (sa->sadb_sa_flags & SADB_SAFLAGS_NOPMTUDISC)\n\t\tx->props.flags |= XFRM_STATE_NOPMTUDISC;\n\n\tlifetime = ext_hdrs[SADB_EXT_LIFETIME_HARD - 1];\n\tif (lifetime != NULL) {\n\t\tx->lft.hard_packet_limit = _KEY2X(lifetime->sadb_lifetime_allocations);\n\t\tx->lft.hard_byte_limit = _KEY2X(lifetime->sadb_lifetime_bytes);\n\t\tx->lft.hard_add_expires_seconds = lifetime->sadb_lifetime_addtime;\n\t\tx->lft.hard_use_expires_seconds = lifetime->sadb_lifetime_usetime;\n\t}\n\tlifetime = ext_hdrs[SADB_EXT_LIFETIME_SOFT - 1];\n\tif (lifetime != NULL) {\n\t\tx->lft.soft_packet_limit = _KEY2X(lifetime->sadb_lifetime_allocations);\n\t\tx->lft.soft_byte_limit = _KEY2X(lifetime->sadb_lifetime_bytes);\n\t\tx->lft.soft_add_expires_seconds = lifetime->sadb_lifetime_addtime;\n\t\tx->lft.soft_use_expires_seconds = lifetime->sadb_lifetime_usetime;\n\t}\n\n\tsec_ctx = ext_hdrs[SADB_X_EXT_SEC_CTX - 1];\n\tif (sec_ctx != NULL) {\n\t\tstruct xfrm_user_sec_ctx *uctx = pfkey_sadb2xfrm_user_sec_ctx(sec_ctx, GFP_KERNEL);\n\n\t\tif (!uctx)\n\t\t\tgoto out;\n\n\t\terr = security_xfrm_state_alloc(x, uctx);\n\t\tkfree(uctx);\n\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\terr = -ENOBUFS;\n\tkey = ext_hdrs[SADB_EXT_KEY_AUTH - 1];\n\tif (sa->sadb_sa_auth) {\n\t\tint keysize = 0;\n\t\tstruct xfrm_algo_desc *a = xfrm_aalg_get_byid(sa->sadb_sa_auth);\n\t\tif (!a || !a->pfkey_supported) {\n\t\t\terr = -ENOSYS;\n\t\t\tgoto out;\n\t\t}\n\t\tif (key)\n\t\t\tkeysize = (key->sadb_key_bits + 7) / 8;\n\t\tx->aalg = kmalloc(sizeof(*x->aalg) + keysize, GFP_KERNEL);\n\t\tif (!x->aalg) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tstrcpy(x->aalg->alg_name, a->name);\n\t\tx->aalg->alg_key_len = 0;\n\t\tif (key) {\n\t\t\tx->aalg->alg_key_len = key->sadb_key_bits;\n\t\t\tmemcpy(x->aalg->alg_key, key+1, keysize);\n\t\t}\n\t\tx->aalg->alg_trunc_len = a->uinfo.auth.icv_truncbits;\n\t\tx->props.aalgo = sa->sadb_sa_auth;\n\t\t/* x->algo.flags = sa->sadb_sa_flags; */\n\t}\n\tif (sa->sadb_sa_encrypt) {\n\t\tif (hdr->sadb_msg_satype == SADB_X_SATYPE_IPCOMP) {\n\t\t\tstruct xfrm_algo_desc *a = xfrm_calg_get_byid(sa->sadb_sa_encrypt);\n\t\t\tif (!a || !a->pfkey_supported) {\n\t\t\t\terr = -ENOSYS;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tx->calg = kmalloc(sizeof(*x->calg), GFP_KERNEL);\n\t\t\tif (!x->calg) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tstrcpy(x->calg->alg_name, a->name);\n\t\t\tx->props.calgo = sa->sadb_sa_encrypt;\n\t\t} else {\n\t\t\tint keysize = 0;\n\t\t\tstruct xfrm_algo_desc *a = xfrm_ealg_get_byid(sa->sadb_sa_encrypt);\n\t\t\tif (!a || !a->pfkey_supported) {\n\t\t\t\terr = -ENOSYS;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tkey = (struct sadb_key*) ext_hdrs[SADB_EXT_KEY_ENCRYPT-1];\n\t\t\tif (key)\n\t\t\t\tkeysize = (key->sadb_key_bits + 7) / 8;\n\t\t\tx->ealg = kmalloc(sizeof(*x->ealg) + keysize, GFP_KERNEL);\n\t\t\tif (!x->ealg) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tstrcpy(x->ealg->alg_name, a->name);\n\t\t\tx->ealg->alg_key_len = 0;\n\t\t\tif (key) {\n\t\t\t\tx->ealg->alg_key_len = key->sadb_key_bits;\n\t\t\t\tmemcpy(x->ealg->alg_key, key+1, keysize);\n\t\t\t}\n\t\t\tx->props.ealgo = sa->sadb_sa_encrypt;\n\t\t\tx->geniv = a->uinfo.encr.geniv;\n\t\t}\n\t}\n\t/* x->algo.flags = sa->sadb_sa_flags; */\n\n\tx->props.family = pfkey_sadb_addr2xfrm_addr((struct sadb_address *) ext_hdrs[SADB_EXT_ADDRESS_SRC-1],\n\t\t\t\t\t\t    &x->props.saddr);\n\tpfkey_sadb_addr2xfrm_addr((struct sadb_address *) ext_hdrs[SADB_EXT_ADDRESS_DST-1],\n\t\t\t\t  &x->id.daddr);\n\n\tif (ext_hdrs[SADB_X_EXT_SA2-1]) {\n\t\tconst struct sadb_x_sa2 *sa2 = ext_hdrs[SADB_X_EXT_SA2-1];\n\t\tint mode = pfkey_mode_to_xfrm(sa2->sadb_x_sa2_mode);\n\t\tif (mode < 0) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tx->props.mode = mode;\n\t\tx->props.reqid = sa2->sadb_x_sa2_reqid;\n\t}\n\n\tif (ext_hdrs[SADB_EXT_ADDRESS_PROXY-1]) {\n\t\tconst struct sadb_address *addr = ext_hdrs[SADB_EXT_ADDRESS_PROXY-1];\n\n\t\t/* Nobody uses this, but we try. */\n\t\tx->sel.family = pfkey_sadb_addr2xfrm_addr(addr, &x->sel.saddr);\n\t\tx->sel.prefixlen_s = addr->sadb_address_prefixlen;\n\t}\n\n\tif (!x->sel.family)\n\t\tx->sel.family = x->props.family;\n\n\tif (ext_hdrs[SADB_X_EXT_NAT_T_TYPE-1]) {\n\t\tconst struct sadb_x_nat_t_type* n_type;\n\t\tstruct xfrm_encap_tmpl *natt;\n\n\t\tx->encap = kmalloc(sizeof(*x->encap), GFP_KERNEL);\n\t\tif (!x->encap) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tnatt = x->encap;\n\t\tn_type = ext_hdrs[SADB_X_EXT_NAT_T_TYPE-1];\n\t\tnatt->encap_type = n_type->sadb_x_nat_t_type_type;\n\n\t\tif (ext_hdrs[SADB_X_EXT_NAT_T_SPORT-1]) {\n\t\t\tconst struct sadb_x_nat_t_port *n_port =\n\t\t\t\text_hdrs[SADB_X_EXT_NAT_T_SPORT-1];\n\t\t\tnatt->encap_sport = n_port->sadb_x_nat_t_port_port;\n\t\t}\n\t\tif (ext_hdrs[SADB_X_EXT_NAT_T_DPORT-1]) {\n\t\t\tconst struct sadb_x_nat_t_port *n_port =\n\t\t\t\text_hdrs[SADB_X_EXT_NAT_T_DPORT-1];\n\t\t\tnatt->encap_dport = n_port->sadb_x_nat_t_port_port;\n\t\t}\n\t\tmemset(&natt->encap_oa, 0, sizeof(natt->encap_oa));\n\t}\n\n\terr = xfrm_init_state(x);\n\tif (err)\n\t\tgoto out;\n\n\tx->km.seq = hdr->sadb_msg_seq;\n\treturn x;\n\nout:\n\tx->km.state = XFRM_STATE_DEAD;\n\txfrm_state_put(x);\n\treturn ERR_PTR(err);\n}\n\nstatic int pfkey_reserved(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic int pfkey_getspi(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct sk_buff *resp_skb;\n\tstruct sadb_x_sa2 *sa2;\n\tstruct sadb_address *saddr, *daddr;\n\tstruct sadb_msg *out_hdr;\n\tstruct sadb_spirange *range;\n\tstruct xfrm_state *x = NULL;\n\tint mode;\n\tint err;\n\tu32 min_spi, max_spi;\n\tu32 reqid;\n\tu8 proto;\n\tunsigned short family;\n\txfrm_address_t *xsaddr = NULL, *xdaddr = NULL;\n\n\tif (!present_and_same_family(ext_hdrs[SADB_EXT_ADDRESS_SRC-1],\n\t\t\t\t     ext_hdrs[SADB_EXT_ADDRESS_DST-1]))\n\t\treturn -EINVAL;\n\n\tproto = pfkey_satype2proto(hdr->sadb_msg_satype);\n\tif (proto == 0)\n\t\treturn -EINVAL;\n\n\tif ((sa2 = ext_hdrs[SADB_X_EXT_SA2-1]) != NULL) {\n\t\tmode = pfkey_mode_to_xfrm(sa2->sadb_x_sa2_mode);\n\t\tif (mode < 0)\n\t\t\treturn -EINVAL;\n\t\treqid = sa2->sadb_x_sa2_reqid;\n\t} else {\n\t\tmode = 0;\n\t\treqid = 0;\n\t}\n\n\tsaddr = ext_hdrs[SADB_EXT_ADDRESS_SRC-1];\n\tdaddr = ext_hdrs[SADB_EXT_ADDRESS_DST-1];\n\n\tfamily = ((struct sockaddr *)(saddr + 1))->sa_family;\n\tswitch (family) {\n\tcase AF_INET:\n\t\txdaddr = (xfrm_address_t *)&((struct sockaddr_in *)(daddr + 1))->sin_addr.s_addr;\n\t\txsaddr = (xfrm_address_t *)&((struct sockaddr_in *)(saddr + 1))->sin_addr.s_addr;\n\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase AF_INET6:\n\t\txdaddr = (xfrm_address_t *)&((struct sockaddr_in6 *)(daddr + 1))->sin6_addr;\n\t\txsaddr = (xfrm_address_t *)&((struct sockaddr_in6 *)(saddr + 1))->sin6_addr;\n\t\tbreak;\n#endif\n\t}\n\n\tif (hdr->sadb_msg_seq) {\n\t\tx = xfrm_find_acq_byseq(net, DUMMY_MARK, hdr->sadb_msg_seq);\n\t\tif (x && !xfrm_addr_equal(&x->id.daddr, xdaddr, family)) {\n\t\t\txfrm_state_put(x);\n\t\t\tx = NULL;\n\t\t}\n\t}\n\n\tif (!x)\n\t\tx = xfrm_find_acq(net, &dummy_mark, mode, reqid, 0, proto, xdaddr, xsaddr, 1, family);\n\n\tif (x == NULL)\n\t\treturn -ENOENT;\n\n\tmin_spi = 0x100;\n\tmax_spi = 0x0fffffff;\n\n\trange = ext_hdrs[SADB_EXT_SPIRANGE-1];\n\tif (range) {\n\t\tmin_spi = range->sadb_spirange_min;\n\t\tmax_spi = range->sadb_spirange_max;\n\t}\n\n\terr = verify_spi_info(x->id.proto, min_spi, max_spi);\n\tif (err) {\n\t\txfrm_state_put(x);\n\t\treturn err;\n\t}\n\n\terr = xfrm_alloc_spi(x, min_spi, max_spi);\n\tresp_skb = err ? ERR_PTR(err) : pfkey_xfrm_state2msg(x);\n\n\tif (IS_ERR(resp_skb)) {\n\t\txfrm_state_put(x);\n\t\treturn  PTR_ERR(resp_skb);\n\t}\n\n\tout_hdr = (struct sadb_msg *) resp_skb->data;\n\tout_hdr->sadb_msg_version = hdr->sadb_msg_version;\n\tout_hdr->sadb_msg_type = SADB_GETSPI;\n\tout_hdr->sadb_msg_satype = pfkey_proto2satype(proto);\n\tout_hdr->sadb_msg_errno = 0;\n\tout_hdr->sadb_msg_reserved = 0;\n\tout_hdr->sadb_msg_seq = hdr->sadb_msg_seq;\n\tout_hdr->sadb_msg_pid = hdr->sadb_msg_pid;\n\n\txfrm_state_put(x);\n\n\tpfkey_broadcast(resp_skb, GFP_KERNEL, BROADCAST_ONE, sk, net);\n\n\treturn 0;\n}\n\nstatic int pfkey_acquire(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct xfrm_state *x;\n\n\tif (hdr->sadb_msg_len != sizeof(struct sadb_msg)/8)\n\t\treturn -EOPNOTSUPP;\n\n\tif (hdr->sadb_msg_seq == 0 || hdr->sadb_msg_errno == 0)\n\t\treturn 0;\n\n\tx = xfrm_find_acq_byseq(net, DUMMY_MARK, hdr->sadb_msg_seq);\n\tif (x == NULL)\n\t\treturn 0;\n\n\tspin_lock_bh(&x->lock);\n\tif (x->km.state == XFRM_STATE_ACQ)\n\t\tx->km.state = XFRM_STATE_ERROR;\n\n\tspin_unlock_bh(&x->lock);\n\txfrm_state_put(x);\n\treturn 0;\n}\n\nstatic inline int event2poltype(int event)\n{\n\tswitch (event) {\n\tcase XFRM_MSG_DELPOLICY:\n\t\treturn SADB_X_SPDDELETE;\n\tcase XFRM_MSG_NEWPOLICY:\n\t\treturn SADB_X_SPDADD;\n\tcase XFRM_MSG_UPDPOLICY:\n\t\treturn SADB_X_SPDUPDATE;\n\tcase XFRM_MSG_POLEXPIRE:\n\t//\treturn SADB_X_SPDEXPIRE;\n\tdefault:\n\t\tpr_err(\"pfkey: Unknown policy event %d\\n\", event);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic inline int event2keytype(int event)\n{\n\tswitch (event) {\n\tcase XFRM_MSG_DELSA:\n\t\treturn SADB_DELETE;\n\tcase XFRM_MSG_NEWSA:\n\t\treturn SADB_ADD;\n\tcase XFRM_MSG_UPDSA:\n\t\treturn SADB_UPDATE;\n\tcase XFRM_MSG_EXPIRE:\n\t\treturn SADB_EXPIRE;\n\tdefault:\n\t\tpr_err(\"pfkey: Unknown SA event %d\\n\", event);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n/* ADD/UPD/DEL */\nstatic int key_notify_sa(struct xfrm_state *x, const struct km_event *c)\n{\n\tstruct sk_buff *skb;\n\tstruct sadb_msg *hdr;\n\n\tskb = pfkey_xfrm_state2msg(x);\n\n\tif (IS_ERR(skb))\n\t\treturn PTR_ERR(skb);\n\n\thdr = (struct sadb_msg *) skb->data;\n\thdr->sadb_msg_version = PF_KEY_V2;\n\thdr->sadb_msg_type = event2keytype(c->event);\n\thdr->sadb_msg_satype = pfkey_proto2satype(x->id.proto);\n\thdr->sadb_msg_errno = 0;\n\thdr->sadb_msg_reserved = 0;\n\thdr->sadb_msg_seq = c->seq;\n\thdr->sadb_msg_pid = c->portid;\n\n\tpfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_ALL, NULL, xs_net(x));\n\n\treturn 0;\n}\n\nstatic int pfkey_add(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct xfrm_state *x;\n\tint err;\n\tstruct km_event c;\n\n\tx = pfkey_msg2xfrm_state(net, hdr, ext_hdrs);\n\tif (IS_ERR(x))\n\t\treturn PTR_ERR(x);\n\n\txfrm_state_hold(x);\n\tif (hdr->sadb_msg_type == SADB_ADD)\n\t\terr = xfrm_state_add(x);\n\telse\n\t\terr = xfrm_state_update(x);\n\n\txfrm_audit_state_add(x, err ? 0 : 1, true);\n\n\tif (err < 0) {\n\t\tx->km.state = XFRM_STATE_DEAD;\n\t\t__xfrm_state_put(x);\n\t\tgoto out;\n\t}\n\n\tif (hdr->sadb_msg_type == SADB_ADD)\n\t\tc.event = XFRM_MSG_NEWSA;\n\telse\n\t\tc.event = XFRM_MSG_UPDSA;\n\tc.seq = hdr->sadb_msg_seq;\n\tc.portid = hdr->sadb_msg_pid;\n\tkm_state_notify(x, &c);\nout:\n\txfrm_state_put(x);\n\treturn err;\n}\n\nstatic int pfkey_delete(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct xfrm_state *x;\n\tstruct km_event c;\n\tint err;\n\n\tif (!ext_hdrs[SADB_EXT_SA-1] ||\n\t    !present_and_same_family(ext_hdrs[SADB_EXT_ADDRESS_SRC-1],\n\t\t\t\t     ext_hdrs[SADB_EXT_ADDRESS_DST-1]))\n\t\treturn -EINVAL;\n\n\tx = pfkey_xfrm_state_lookup(net, hdr, ext_hdrs);\n\tif (x == NULL)\n\t\treturn -ESRCH;\n\n\tif ((err = security_xfrm_state_delete(x)))\n\t\tgoto out;\n\n\tif (xfrm_state_kern(x)) {\n\t\terr = -EPERM;\n\t\tgoto out;\n\t}\n\n\terr = xfrm_state_delete(x);\n\n\tif (err < 0)\n\t\tgoto out;\n\n\tc.seq = hdr->sadb_msg_seq;\n\tc.portid = hdr->sadb_msg_pid;\n\tc.event = XFRM_MSG_DELSA;\n\tkm_state_notify(x, &c);\nout:\n\txfrm_audit_state_delete(x, err ? 0 : 1, true);\n\txfrm_state_put(x);\n\n\treturn err;\n}\n\nstatic int pfkey_get(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct net *net = sock_net(sk);\n\t__u8 proto;\n\tstruct sk_buff *out_skb;\n\tstruct sadb_msg *out_hdr;\n\tstruct xfrm_state *x;\n\n\tif (!ext_hdrs[SADB_EXT_SA-1] ||\n\t    !present_and_same_family(ext_hdrs[SADB_EXT_ADDRESS_SRC-1],\n\t\t\t\t     ext_hdrs[SADB_EXT_ADDRESS_DST-1]))\n\t\treturn -EINVAL;\n\n\tx = pfkey_xfrm_state_lookup(net, hdr, ext_hdrs);\n\tif (x == NULL)\n\t\treturn -ESRCH;\n\n\tout_skb = pfkey_xfrm_state2msg(x);\n\tproto = x->id.proto;\n\txfrm_state_put(x);\n\tif (IS_ERR(out_skb))\n\t\treturn  PTR_ERR(out_skb);\n\n\tout_hdr = (struct sadb_msg *) out_skb->data;\n\tout_hdr->sadb_msg_version = hdr->sadb_msg_version;\n\tout_hdr->sadb_msg_type = SADB_GET;\n\tout_hdr->sadb_msg_satype = pfkey_proto2satype(proto);\n\tout_hdr->sadb_msg_errno = 0;\n\tout_hdr->sadb_msg_reserved = 0;\n\tout_hdr->sadb_msg_seq = hdr->sadb_msg_seq;\n\tout_hdr->sadb_msg_pid = hdr->sadb_msg_pid;\n\tpfkey_broadcast(out_skb, GFP_ATOMIC, BROADCAST_ONE, sk, sock_net(sk));\n\n\treturn 0;\n}\n\nstatic struct sk_buff *compose_sadb_supported(const struct sadb_msg *orig,\n\t\t\t\t\t      gfp_t allocation)\n{\n\tstruct sk_buff *skb;\n\tstruct sadb_msg *hdr;\n\tint len, auth_len, enc_len, i;\n\n\tauth_len = xfrm_count_pfkey_auth_supported();\n\tif (auth_len) {\n\t\tauth_len *= sizeof(struct sadb_alg);\n\t\tauth_len += sizeof(struct sadb_supported);\n\t}\n\n\tenc_len = xfrm_count_pfkey_enc_supported();\n\tif (enc_len) {\n\t\tenc_len *= sizeof(struct sadb_alg);\n\t\tenc_len += sizeof(struct sadb_supported);\n\t}\n\n\tlen = enc_len + auth_len + sizeof(struct sadb_msg);\n\n\tskb = alloc_skb(len + 16, allocation);\n\tif (!skb)\n\t\tgoto out_put_algs;\n\n\thdr = skb_put(skb, sizeof(*hdr));\n\tpfkey_hdr_dup(hdr, orig);\n\thdr->sadb_msg_errno = 0;\n\thdr->sadb_msg_len = len / sizeof(uint64_t);\n\n\tif (auth_len) {\n\t\tstruct sadb_supported *sp;\n\t\tstruct sadb_alg *ap;\n\n\t\tsp = skb_put(skb, auth_len);\n\t\tap = (struct sadb_alg *) (sp + 1);\n\n\t\tsp->sadb_supported_len = auth_len / sizeof(uint64_t);\n\t\tsp->sadb_supported_exttype = SADB_EXT_SUPPORTED_AUTH;\n\n\t\tfor (i = 0; ; i++) {\n\t\t\tstruct xfrm_algo_desc *aalg = xfrm_aalg_get_byidx(i);\n\t\t\tif (!aalg)\n\t\t\t\tbreak;\n\t\t\tif (!aalg->pfkey_supported)\n\t\t\t\tcontinue;\n\t\t\tif (aalg->available)\n\t\t\t\t*ap++ = aalg->desc;\n\t\t}\n\t}\n\n\tif (enc_len) {\n\t\tstruct sadb_supported *sp;\n\t\tstruct sadb_alg *ap;\n\n\t\tsp = skb_put(skb, enc_len);\n\t\tap = (struct sadb_alg *) (sp + 1);\n\n\t\tsp->sadb_supported_len = enc_len / sizeof(uint64_t);\n\t\tsp->sadb_supported_exttype = SADB_EXT_SUPPORTED_ENCRYPT;\n\n\t\tfor (i = 0; ; i++) {\n\t\t\tstruct xfrm_algo_desc *ealg = xfrm_ealg_get_byidx(i);\n\t\t\tif (!ealg)\n\t\t\t\tbreak;\n\t\t\tif (!ealg->pfkey_supported)\n\t\t\t\tcontinue;\n\t\t\tif (ealg->available)\n\t\t\t\t*ap++ = ealg->desc;\n\t\t}\n\t}\n\nout_put_algs:\n\treturn skb;\n}\n\nstatic int pfkey_register(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct pfkey_sock *pfk = pfkey_sk(sk);\n\tstruct sk_buff *supp_skb;\n\n\tif (hdr->sadb_msg_satype > SADB_SATYPE_MAX)\n\t\treturn -EINVAL;\n\n\tif (hdr->sadb_msg_satype != SADB_SATYPE_UNSPEC) {\n\t\tif (pfk->registered&(1<<hdr->sadb_msg_satype))\n\t\t\treturn -EEXIST;\n\t\tpfk->registered |= (1<<hdr->sadb_msg_satype);\n\t}\n\n\txfrm_probe_algs();\n\n\tsupp_skb = compose_sadb_supported(hdr, GFP_KERNEL | __GFP_ZERO);\n\tif (!supp_skb) {\n\t\tif (hdr->sadb_msg_satype != SADB_SATYPE_UNSPEC)\n\t\t\tpfk->registered &= ~(1<<hdr->sadb_msg_satype);\n\n\t\treturn -ENOBUFS;\n\t}\n\n\tpfkey_broadcast(supp_skb, GFP_KERNEL, BROADCAST_REGISTERED, sk,\n\t\t\tsock_net(sk));\n\treturn 0;\n}\n\nstatic int unicast_flush_resp(struct sock *sk, const struct sadb_msg *ihdr)\n{\n\tstruct sk_buff *skb;\n\tstruct sadb_msg *hdr;\n\n\tskb = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn -ENOBUFS;\n\n\thdr = skb_put_data(skb, ihdr, sizeof(struct sadb_msg));\n\thdr->sadb_msg_errno = (uint8_t) 0;\n\thdr->sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));\n\n\treturn pfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_ONE, sk,\n\t\t\t       sock_net(sk));\n}\n\nstatic int key_notify_sa_flush(const struct km_event *c)\n{\n\tstruct sk_buff *skb;\n\tstruct sadb_msg *hdr;\n\n\tskb = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn -ENOBUFS;\n\thdr = skb_put(skb, sizeof(struct sadb_msg));\n\thdr->sadb_msg_satype = pfkey_proto2satype(c->data.proto);\n\thdr->sadb_msg_type = SADB_FLUSH;\n\thdr->sadb_msg_seq = c->seq;\n\thdr->sadb_msg_pid = c->portid;\n\thdr->sadb_msg_version = PF_KEY_V2;\n\thdr->sadb_msg_errno = (uint8_t) 0;\n\thdr->sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));\n\thdr->sadb_msg_reserved = 0;\n\n\tpfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_ALL, NULL, c->net);\n\n\treturn 0;\n}\n\nstatic int pfkey_flush(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct net *net = sock_net(sk);\n\tunsigned int proto;\n\tstruct km_event c;\n\tint err, err2;\n\n\tproto = pfkey_satype2proto(hdr->sadb_msg_satype);\n\tif (proto == 0)\n\t\treturn -EINVAL;\n\n\terr = xfrm_state_flush(net, proto, true, false);\n\terr2 = unicast_flush_resp(sk, hdr);\n\tif (err || err2) {\n\t\tif (err == -ESRCH) /* empty table - go quietly */\n\t\t\terr = 0;\n\t\treturn err ? err : err2;\n\t}\n\n\tc.data.proto = proto;\n\tc.seq = hdr->sadb_msg_seq;\n\tc.portid = hdr->sadb_msg_pid;\n\tc.event = XFRM_MSG_FLUSHSA;\n\tc.net = net;\n\tkm_state_notify(NULL, &c);\n\n\treturn 0;\n}\n\nstatic int dump_sa(struct xfrm_state *x, int count, void *ptr)\n{\n\tstruct pfkey_sock *pfk = ptr;\n\tstruct sk_buff *out_skb;\n\tstruct sadb_msg *out_hdr;\n\n\tif (!pfkey_can_dump(&pfk->sk))\n\t\treturn -ENOBUFS;\n\n\tout_skb = pfkey_xfrm_state2msg(x);\n\tif (IS_ERR(out_skb))\n\t\treturn PTR_ERR(out_skb);\n\n\tout_hdr = (struct sadb_msg *) out_skb->data;\n\tout_hdr->sadb_msg_version = pfk->dump.msg_version;\n\tout_hdr->sadb_msg_type = SADB_DUMP;\n\tout_hdr->sadb_msg_satype = pfkey_proto2satype(x->id.proto);\n\tout_hdr->sadb_msg_errno = 0;\n\tout_hdr->sadb_msg_reserved = 0;\n\tout_hdr->sadb_msg_seq = count + 1;\n\tout_hdr->sadb_msg_pid = pfk->dump.msg_portid;\n\n\tif (pfk->dump.skb)\n\t\tpfkey_broadcast(pfk->dump.skb, GFP_ATOMIC, BROADCAST_ONE,\n\t\t\t\t&pfk->sk, sock_net(&pfk->sk));\n\tpfk->dump.skb = out_skb;\n\n\treturn 0;\n}\n\nstatic int pfkey_dump_sa(struct pfkey_sock *pfk)\n{\n\tstruct net *net = sock_net(&pfk->sk);\n\treturn xfrm_state_walk(net, &pfk->dump.u.state, dump_sa, (void *) pfk);\n}\n\nstatic void pfkey_dump_sa_done(struct pfkey_sock *pfk)\n{\n\tstruct net *net = sock_net(&pfk->sk);\n\n\txfrm_state_walk_done(&pfk->dump.u.state, net);\n}\n\nstatic int pfkey_dump(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tu8 proto;\n\tstruct xfrm_address_filter *filter = NULL;\n\tstruct pfkey_sock *pfk = pfkey_sk(sk);\n\n\tmutex_lock(&pfk->dump_lock);\n\tif (pfk->dump.dump != NULL) {\n\t\tmutex_unlock(&pfk->dump_lock);\n\t\treturn -EBUSY;\n\t}\n\n\tproto = pfkey_satype2proto(hdr->sadb_msg_satype);\n\tif (proto == 0) {\n\t\tmutex_unlock(&pfk->dump_lock);\n\t\treturn -EINVAL;\n\t}\n\n\tif (ext_hdrs[SADB_X_EXT_FILTER - 1]) {\n\t\tstruct sadb_x_filter *xfilter = ext_hdrs[SADB_X_EXT_FILTER - 1];\n\n\t\tif ((xfilter->sadb_x_filter_splen >=\n\t\t\t(sizeof(xfrm_address_t) << 3)) ||\n\t\t    (xfilter->sadb_x_filter_dplen >=\n\t\t\t(sizeof(xfrm_address_t) << 3))) {\n\t\t\tmutex_unlock(&pfk->dump_lock);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tfilter = kmalloc(sizeof(*filter), GFP_KERNEL);\n\t\tif (filter == NULL) {\n\t\t\tmutex_unlock(&pfk->dump_lock);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tmemcpy(&filter->saddr, &xfilter->sadb_x_filter_saddr,\n\t\t       sizeof(xfrm_address_t));\n\t\tmemcpy(&filter->daddr, &xfilter->sadb_x_filter_daddr,\n\t\t       sizeof(xfrm_address_t));\n\t\tfilter->family = xfilter->sadb_x_filter_family;\n\t\tfilter->splen = xfilter->sadb_x_filter_splen;\n\t\tfilter->dplen = xfilter->sadb_x_filter_dplen;\n\t}\n\n\tpfk->dump.msg_version = hdr->sadb_msg_version;\n\tpfk->dump.msg_portid = hdr->sadb_msg_pid;\n\tpfk->dump.dump = pfkey_dump_sa;\n\tpfk->dump.done = pfkey_dump_sa_done;\n\txfrm_state_walk_init(&pfk->dump.u.state, proto, filter);\n\tmutex_unlock(&pfk->dump_lock);\n\n\treturn pfkey_do_dump(pfk);\n}\n\nstatic int pfkey_promisc(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct pfkey_sock *pfk = pfkey_sk(sk);\n\tint satype = hdr->sadb_msg_satype;\n\tbool reset_errno = false;\n\n\tif (hdr->sadb_msg_len == (sizeof(*hdr) / sizeof(uint64_t))) {\n\t\treset_errno = true;\n\t\tif (satype != 0 && satype != 1)\n\t\t\treturn -EINVAL;\n\t\tpfk->promisc = satype;\n\t}\n\tif (reset_errno && skb_cloned(skb))\n\t\tskb = skb_copy(skb, GFP_KERNEL);\n\telse\n\t\tskb = skb_clone(skb, GFP_KERNEL);\n\n\tif (reset_errno && skb) {\n\t\tstruct sadb_msg *new_hdr = (struct sadb_msg *) skb->data;\n\t\tnew_hdr->sadb_msg_errno = 0;\n\t}\n\n\tpfkey_broadcast(skb, GFP_KERNEL, BROADCAST_ALL, NULL, sock_net(sk));\n\treturn 0;\n}\n\nstatic int check_reqid(struct xfrm_policy *xp, int dir, int count, void *ptr)\n{\n\tint i;\n\tu32 reqid = *(u32*)ptr;\n\n\tfor (i=0; i<xp->xfrm_nr; i++) {\n\t\tif (xp->xfrm_vec[i].reqid == reqid)\n\t\t\treturn -EEXIST;\n\t}\n\treturn 0;\n}\n\nstatic u32 gen_reqid(struct net *net)\n{\n\tstruct xfrm_policy_walk walk;\n\tu32 start;\n\tint rc;\n\tstatic u32 reqid = IPSEC_MANUAL_REQID_MAX;\n\n\tstart = reqid;\n\tdo {\n\t\t++reqid;\n\t\tif (reqid == 0)\n\t\t\treqid = IPSEC_MANUAL_REQID_MAX+1;\n\t\txfrm_policy_walk_init(&walk, XFRM_POLICY_TYPE_MAIN);\n\t\trc = xfrm_policy_walk(net, &walk, check_reqid, (void*)&reqid);\n\t\txfrm_policy_walk_done(&walk, net);\n\t\tif (rc != -EEXIST)\n\t\t\treturn reqid;\n\t} while (reqid != start);\n\treturn 0;\n}\n\nstatic int\nparse_ipsecrequest(struct xfrm_policy *xp, struct sadb_x_ipsecrequest *rq)\n{\n\tstruct net *net = xp_net(xp);\n\tstruct xfrm_tmpl *t = xp->xfrm_vec + xp->xfrm_nr;\n\tint mode;\n\n\tif (xp->xfrm_nr >= XFRM_MAX_DEPTH)\n\t\treturn -ELOOP;\n\n\tif (rq->sadb_x_ipsecrequest_mode == 0)\n\t\treturn -EINVAL;\n\tif (!xfrm_id_proto_valid(rq->sadb_x_ipsecrequest_proto))\n\t\treturn -EINVAL;\n\n\tt->id.proto = rq->sadb_x_ipsecrequest_proto;\n\tif ((mode = pfkey_mode_to_xfrm(rq->sadb_x_ipsecrequest_mode)) < 0)\n\t\treturn -EINVAL;\n\tt->mode = mode;\n\tif (rq->sadb_x_ipsecrequest_level == IPSEC_LEVEL_USE)\n\t\tt->optional = 1;\n\telse if (rq->sadb_x_ipsecrequest_level == IPSEC_LEVEL_UNIQUE) {\n\t\tt->reqid = rq->sadb_x_ipsecrequest_reqid;\n\t\tif (t->reqid > IPSEC_MANUAL_REQID_MAX)\n\t\t\tt->reqid = 0;\n\t\tif (!t->reqid && !(t->reqid = gen_reqid(net)))\n\t\t\treturn -ENOBUFS;\n\t}\n\n\t/* addresses present only in tunnel mode */\n\tif (t->mode == XFRM_MODE_TUNNEL) {\n\t\tint err;\n\n\t\terr = parse_sockaddr_pair(\n\t\t\t(struct sockaddr *)(rq + 1),\n\t\t\trq->sadb_x_ipsecrequest_len - sizeof(*rq),\n\t\t\t&t->saddr, &t->id.daddr, &t->encap_family);\n\t\tif (err)\n\t\t\treturn err;\n\t} else\n\t\tt->encap_family = xp->family;\n\n\t/* No way to set this via kame pfkey */\n\tt->allalgs = 1;\n\txp->xfrm_nr++;\n\treturn 0;\n}\n\nstatic int\nparse_ipsecrequests(struct xfrm_policy *xp, struct sadb_x_policy *pol)\n{\n\tint err;\n\tint len = pol->sadb_x_policy_len*8 - sizeof(struct sadb_x_policy);\n\tstruct sadb_x_ipsecrequest *rq = (void*)(pol+1);\n\n\tif (pol->sadb_x_policy_len * 8 < sizeof(struct sadb_x_policy))\n\t\treturn -EINVAL;\n\n\twhile (len >= sizeof(*rq)) {\n\t\tif (len < rq->sadb_x_ipsecrequest_len ||\n\t\t    rq->sadb_x_ipsecrequest_len < sizeof(*rq))\n\t\t\treturn -EINVAL;\n\n\t\tif ((err = parse_ipsecrequest(xp, rq)) < 0)\n\t\t\treturn err;\n\t\tlen -= rq->sadb_x_ipsecrequest_len;\n\t\trq = (void*)((u8*)rq + rq->sadb_x_ipsecrequest_len);\n\t}\n\treturn 0;\n}\n\nstatic inline int pfkey_xfrm_policy2sec_ctx_size(const struct xfrm_policy *xp)\n{\n\tstruct xfrm_sec_ctx *xfrm_ctx = xp->security;\n\n\tif (xfrm_ctx) {\n\t\tint len = sizeof(struct sadb_x_sec_ctx);\n\t\tlen += xfrm_ctx->ctx_len;\n\t\treturn PFKEY_ALIGN8(len);\n\t}\n\treturn 0;\n}\n\nstatic int pfkey_xfrm_policy2msg_size(const struct xfrm_policy *xp)\n{\n\tconst struct xfrm_tmpl *t;\n\tint sockaddr_size = pfkey_sockaddr_size(xp->family);\n\tint socklen = 0;\n\tint i;\n\n\tfor (i=0; i<xp->xfrm_nr; i++) {\n\t\tt = xp->xfrm_vec + i;\n\t\tsocklen += pfkey_sockaddr_len(t->encap_family);\n\t}\n\n\treturn sizeof(struct sadb_msg) +\n\t\t(sizeof(struct sadb_lifetime) * 3) +\n\t\t(sizeof(struct sadb_address) * 2) +\n\t\t(sockaddr_size * 2) +\n\t\tsizeof(struct sadb_x_policy) +\n\t\t(xp->xfrm_nr * sizeof(struct sadb_x_ipsecrequest)) +\n\t\t(socklen * 2) +\n\t\tpfkey_xfrm_policy2sec_ctx_size(xp);\n}\n\nstatic struct sk_buff * pfkey_xfrm_policy2msg_prep(const struct xfrm_policy *xp)\n{\n\tstruct sk_buff *skb;\n\tint size;\n\n\tsize = pfkey_xfrm_policy2msg_size(xp);\n\n\tskb =  alloc_skb(size + 16, GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn ERR_PTR(-ENOBUFS);\n\n\treturn skb;\n}\n\nstatic int pfkey_xfrm_policy2msg(struct sk_buff *skb, const struct xfrm_policy *xp, int dir)\n{\n\tstruct sadb_msg *hdr;\n\tstruct sadb_address *addr;\n\tstruct sadb_lifetime *lifetime;\n\tstruct sadb_x_policy *pol;\n\tstruct sadb_x_sec_ctx *sec_ctx;\n\tstruct xfrm_sec_ctx *xfrm_ctx;\n\tint i;\n\tint size;\n\tint sockaddr_size = pfkey_sockaddr_size(xp->family);\n\tint socklen = pfkey_sockaddr_len(xp->family);\n\n\tsize = pfkey_xfrm_policy2msg_size(xp);\n\n\t/* call should fill header later */\n\thdr = skb_put(skb, sizeof(struct sadb_msg));\n\tmemset(hdr, 0, size);\t/* XXX do we need this ? */\n\n\t/* src address */\n\taddr = skb_put(skb, sizeof(struct sadb_address) + sockaddr_size);\n\taddr->sadb_address_len =\n\t\t(sizeof(struct sadb_address)+sockaddr_size)/\n\t\t\tsizeof(uint64_t);\n\taddr->sadb_address_exttype = SADB_EXT_ADDRESS_SRC;\n\taddr->sadb_address_proto = pfkey_proto_from_xfrm(xp->selector.proto);\n\taddr->sadb_address_prefixlen = xp->selector.prefixlen_s;\n\taddr->sadb_address_reserved = 0;\n\tif (!pfkey_sockaddr_fill(&xp->selector.saddr,\n\t\t\t\t xp->selector.sport,\n\t\t\t\t (struct sockaddr *) (addr + 1),\n\t\t\t\t xp->family))\n\t\tBUG();\n\n\t/* dst address */\n\taddr = skb_put(skb, sizeof(struct sadb_address) + sockaddr_size);\n\taddr->sadb_address_len =\n\t\t(sizeof(struct sadb_address)+sockaddr_size)/\n\t\t\tsizeof(uint64_t);\n\taddr->sadb_address_exttype = SADB_EXT_ADDRESS_DST;\n\taddr->sadb_address_proto = pfkey_proto_from_xfrm(xp->selector.proto);\n\taddr->sadb_address_prefixlen = xp->selector.prefixlen_d;\n\taddr->sadb_address_reserved = 0;\n\n\tpfkey_sockaddr_fill(&xp->selector.daddr, xp->selector.dport,\n\t\t\t    (struct sockaddr *) (addr + 1),\n\t\t\t    xp->family);\n\n\t/* hard time */\n\tlifetime = skb_put(skb, sizeof(struct sadb_lifetime));\n\tlifetime->sadb_lifetime_len =\n\t\tsizeof(struct sadb_lifetime)/sizeof(uint64_t);\n\tlifetime->sadb_lifetime_exttype = SADB_EXT_LIFETIME_HARD;\n\tlifetime->sadb_lifetime_allocations =  _X2KEY(xp->lft.hard_packet_limit);\n\tlifetime->sadb_lifetime_bytes = _X2KEY(xp->lft.hard_byte_limit);\n\tlifetime->sadb_lifetime_addtime = xp->lft.hard_add_expires_seconds;\n\tlifetime->sadb_lifetime_usetime = xp->lft.hard_use_expires_seconds;\n\t/* soft time */\n\tlifetime = skb_put(skb, sizeof(struct sadb_lifetime));\n\tlifetime->sadb_lifetime_len =\n\t\tsizeof(struct sadb_lifetime)/sizeof(uint64_t);\n\tlifetime->sadb_lifetime_exttype = SADB_EXT_LIFETIME_SOFT;\n\tlifetime->sadb_lifetime_allocations =  _X2KEY(xp->lft.soft_packet_limit);\n\tlifetime->sadb_lifetime_bytes = _X2KEY(xp->lft.soft_byte_limit);\n\tlifetime->sadb_lifetime_addtime = xp->lft.soft_add_expires_seconds;\n\tlifetime->sadb_lifetime_usetime = xp->lft.soft_use_expires_seconds;\n\t/* current time */\n\tlifetime = skb_put(skb, sizeof(struct sadb_lifetime));\n\tlifetime->sadb_lifetime_len =\n\t\tsizeof(struct sadb_lifetime)/sizeof(uint64_t);\n\tlifetime->sadb_lifetime_exttype = SADB_EXT_LIFETIME_CURRENT;\n\tlifetime->sadb_lifetime_allocations = xp->curlft.packets;\n\tlifetime->sadb_lifetime_bytes = xp->curlft.bytes;\n\tlifetime->sadb_lifetime_addtime = xp->curlft.add_time;\n\tlifetime->sadb_lifetime_usetime = xp->curlft.use_time;\n\n\tpol = skb_put(skb, sizeof(struct sadb_x_policy));\n\tpol->sadb_x_policy_len = sizeof(struct sadb_x_policy)/sizeof(uint64_t);\n\tpol->sadb_x_policy_exttype = SADB_X_EXT_POLICY;\n\tpol->sadb_x_policy_type = IPSEC_POLICY_DISCARD;\n\tif (xp->action == XFRM_POLICY_ALLOW) {\n\t\tif (xp->xfrm_nr)\n\t\t\tpol->sadb_x_policy_type = IPSEC_POLICY_IPSEC;\n\t\telse\n\t\t\tpol->sadb_x_policy_type = IPSEC_POLICY_NONE;\n\t}\n\tpol->sadb_x_policy_dir = dir+1;\n\tpol->sadb_x_policy_reserved = 0;\n\tpol->sadb_x_policy_id = xp->index;\n\tpol->sadb_x_policy_priority = xp->priority;\n\n\tfor (i=0; i<xp->xfrm_nr; i++) {\n\t\tconst struct xfrm_tmpl *t = xp->xfrm_vec + i;\n\t\tstruct sadb_x_ipsecrequest *rq;\n\t\tint req_size;\n\t\tint mode;\n\n\t\treq_size = sizeof(struct sadb_x_ipsecrequest);\n\t\tif (t->mode == XFRM_MODE_TUNNEL) {\n\t\t\tsocklen = pfkey_sockaddr_len(t->encap_family);\n\t\t\treq_size += socklen * 2;\n\t\t} else {\n\t\t\tsize -= 2*socklen;\n\t\t}\n\t\trq = skb_put(skb, req_size);\n\t\tpol->sadb_x_policy_len += req_size/8;\n\t\tmemset(rq, 0, sizeof(*rq));\n\t\trq->sadb_x_ipsecrequest_len = req_size;\n\t\trq->sadb_x_ipsecrequest_proto = t->id.proto;\n\t\tif ((mode = pfkey_mode_from_xfrm(t->mode)) < 0)\n\t\t\treturn -EINVAL;\n\t\trq->sadb_x_ipsecrequest_mode = mode;\n\t\trq->sadb_x_ipsecrequest_level = IPSEC_LEVEL_REQUIRE;\n\t\tif (t->reqid)\n\t\t\trq->sadb_x_ipsecrequest_level = IPSEC_LEVEL_UNIQUE;\n\t\tif (t->optional)\n\t\t\trq->sadb_x_ipsecrequest_level = IPSEC_LEVEL_USE;\n\t\trq->sadb_x_ipsecrequest_reqid = t->reqid;\n\n\t\tif (t->mode == XFRM_MODE_TUNNEL) {\n\t\t\tu8 *sa = (void *)(rq + 1);\n\t\t\tpfkey_sockaddr_fill(&t->saddr, 0,\n\t\t\t\t\t    (struct sockaddr *)sa,\n\t\t\t\t\t    t->encap_family);\n\t\t\tpfkey_sockaddr_fill(&t->id.daddr, 0,\n\t\t\t\t\t    (struct sockaddr *) (sa + socklen),\n\t\t\t\t\t    t->encap_family);\n\t\t}\n\t}\n\n\t/* security context */\n\tif ((xfrm_ctx = xp->security)) {\n\t\tint ctx_size = pfkey_xfrm_policy2sec_ctx_size(xp);\n\n\t\tsec_ctx = skb_put(skb, ctx_size);\n\t\tsec_ctx->sadb_x_sec_len = ctx_size / sizeof(uint64_t);\n\t\tsec_ctx->sadb_x_sec_exttype = SADB_X_EXT_SEC_CTX;\n\t\tsec_ctx->sadb_x_ctx_doi = xfrm_ctx->ctx_doi;\n\t\tsec_ctx->sadb_x_ctx_alg = xfrm_ctx->ctx_alg;\n\t\tsec_ctx->sadb_x_ctx_len = xfrm_ctx->ctx_len;\n\t\tmemcpy(sec_ctx + 1, xfrm_ctx->ctx_str,\n\t\t       xfrm_ctx->ctx_len);\n\t}\n\n\thdr->sadb_msg_len = size / sizeof(uint64_t);\n\thdr->sadb_msg_reserved = refcount_read(&xp->refcnt);\n\n\treturn 0;\n}\n\nstatic int key_notify_policy(struct xfrm_policy *xp, int dir, const struct km_event *c)\n{\n\tstruct sk_buff *out_skb;\n\tstruct sadb_msg *out_hdr;\n\tint err;\n\n\tout_skb = pfkey_xfrm_policy2msg_prep(xp);\n\tif (IS_ERR(out_skb))\n\t\treturn PTR_ERR(out_skb);\n\n\terr = pfkey_xfrm_policy2msg(out_skb, xp, dir);\n\tif (err < 0) {\n\t\tkfree_skb(out_skb);\n\t\treturn err;\n\t}\n\n\tout_hdr = (struct sadb_msg *) out_skb->data;\n\tout_hdr->sadb_msg_version = PF_KEY_V2;\n\n\tif (c->data.byid && c->event == XFRM_MSG_DELPOLICY)\n\t\tout_hdr->sadb_msg_type = SADB_X_SPDDELETE2;\n\telse\n\t\tout_hdr->sadb_msg_type = event2poltype(c->event);\n\tout_hdr->sadb_msg_errno = 0;\n\tout_hdr->sadb_msg_seq = c->seq;\n\tout_hdr->sadb_msg_pid = c->portid;\n\tpfkey_broadcast(out_skb, GFP_ATOMIC, BROADCAST_ALL, NULL, xp_net(xp));\n\treturn 0;\n\n}\n\nstatic int pfkey_spdadd(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct net *net = sock_net(sk);\n\tint err = 0;\n\tstruct sadb_lifetime *lifetime;\n\tstruct sadb_address *sa;\n\tstruct sadb_x_policy *pol;\n\tstruct xfrm_policy *xp;\n\tstruct km_event c;\n\tstruct sadb_x_sec_ctx *sec_ctx;\n\n\tif (!present_and_same_family(ext_hdrs[SADB_EXT_ADDRESS_SRC-1],\n\t\t\t\t     ext_hdrs[SADB_EXT_ADDRESS_DST-1]) ||\n\t    !ext_hdrs[SADB_X_EXT_POLICY-1])\n\t\treturn -EINVAL;\n\n\tpol = ext_hdrs[SADB_X_EXT_POLICY-1];\n\tif (pol->sadb_x_policy_type > IPSEC_POLICY_IPSEC)\n\t\treturn -EINVAL;\n\tif (!pol->sadb_x_policy_dir || pol->sadb_x_policy_dir >= IPSEC_DIR_MAX)\n\t\treturn -EINVAL;\n\n\txp = xfrm_policy_alloc(net, GFP_KERNEL);\n\tif (xp == NULL)\n\t\treturn -ENOBUFS;\n\n\txp->action = (pol->sadb_x_policy_type == IPSEC_POLICY_DISCARD ?\n\t\t      XFRM_POLICY_BLOCK : XFRM_POLICY_ALLOW);\n\txp->priority = pol->sadb_x_policy_priority;\n\n\tsa = ext_hdrs[SADB_EXT_ADDRESS_SRC-1];\n\txp->family = pfkey_sadb_addr2xfrm_addr(sa, &xp->selector.saddr);\n\txp->selector.family = xp->family;\n\txp->selector.prefixlen_s = sa->sadb_address_prefixlen;\n\txp->selector.proto = pfkey_proto_to_xfrm(sa->sadb_address_proto);\n\txp->selector.sport = ((struct sockaddr_in *)(sa+1))->sin_port;\n\tif (xp->selector.sport)\n\t\txp->selector.sport_mask = htons(0xffff);\n\n\tsa = ext_hdrs[SADB_EXT_ADDRESS_DST-1];\n\tpfkey_sadb_addr2xfrm_addr(sa, &xp->selector.daddr);\n\txp->selector.prefixlen_d = sa->sadb_address_prefixlen;\n\n\t/* Amusing, we set this twice.  KAME apps appear to set same value\n\t * in both addresses.\n\t */\n\txp->selector.proto = pfkey_proto_to_xfrm(sa->sadb_address_proto);\n\n\txp->selector.dport = ((struct sockaddr_in *)(sa+1))->sin_port;\n\tif (xp->selector.dport)\n\t\txp->selector.dport_mask = htons(0xffff);\n\n\tsec_ctx = ext_hdrs[SADB_X_EXT_SEC_CTX - 1];\n\tif (sec_ctx != NULL) {\n\t\tstruct xfrm_user_sec_ctx *uctx = pfkey_sadb2xfrm_user_sec_ctx(sec_ctx, GFP_KERNEL);\n\n\t\tif (!uctx) {\n\t\t\terr = -ENOBUFS;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = security_xfrm_policy_alloc(&xp->security, uctx, GFP_KERNEL);\n\t\tkfree(uctx);\n\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\txp->lft.soft_byte_limit = XFRM_INF;\n\txp->lft.hard_byte_limit = XFRM_INF;\n\txp->lft.soft_packet_limit = XFRM_INF;\n\txp->lft.hard_packet_limit = XFRM_INF;\n\tif ((lifetime = ext_hdrs[SADB_EXT_LIFETIME_HARD-1]) != NULL) {\n\t\txp->lft.hard_packet_limit = _KEY2X(lifetime->sadb_lifetime_allocations);\n\t\txp->lft.hard_byte_limit = _KEY2X(lifetime->sadb_lifetime_bytes);\n\t\txp->lft.hard_add_expires_seconds = lifetime->sadb_lifetime_addtime;\n\t\txp->lft.hard_use_expires_seconds = lifetime->sadb_lifetime_usetime;\n\t}\n\tif ((lifetime = ext_hdrs[SADB_EXT_LIFETIME_SOFT-1]) != NULL) {\n\t\txp->lft.soft_packet_limit = _KEY2X(lifetime->sadb_lifetime_allocations);\n\t\txp->lft.soft_byte_limit = _KEY2X(lifetime->sadb_lifetime_bytes);\n\t\txp->lft.soft_add_expires_seconds = lifetime->sadb_lifetime_addtime;\n\t\txp->lft.soft_use_expires_seconds = lifetime->sadb_lifetime_usetime;\n\t}\n\txp->xfrm_nr = 0;\n\tif (pol->sadb_x_policy_type == IPSEC_POLICY_IPSEC &&\n\t    (err = parse_ipsecrequests(xp, pol)) < 0)\n\t\tgoto out;\n\n\terr = xfrm_policy_insert(pol->sadb_x_policy_dir-1, xp,\n\t\t\t\t hdr->sadb_msg_type != SADB_X_SPDUPDATE);\n\n\txfrm_audit_policy_add(xp, err ? 0 : 1, true);\n\n\tif (err)\n\t\tgoto out;\n\n\tif (hdr->sadb_msg_type == SADB_X_SPDUPDATE)\n\t\tc.event = XFRM_MSG_UPDPOLICY;\n\telse\n\t\tc.event = XFRM_MSG_NEWPOLICY;\n\n\tc.seq = hdr->sadb_msg_seq;\n\tc.portid = hdr->sadb_msg_pid;\n\n\tkm_policy_notify(xp, pol->sadb_x_policy_dir-1, &c);\n\txfrm_pol_put(xp);\n\treturn 0;\n\nout:\n\txp->walk.dead = 1;\n\txfrm_policy_destroy(xp);\n\treturn err;\n}\n\nstatic int pfkey_spddelete(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct net *net = sock_net(sk);\n\tint err;\n\tstruct sadb_address *sa;\n\tstruct sadb_x_policy *pol;\n\tstruct xfrm_policy *xp;\n\tstruct xfrm_selector sel;\n\tstruct km_event c;\n\tstruct sadb_x_sec_ctx *sec_ctx;\n\tstruct xfrm_sec_ctx *pol_ctx = NULL;\n\n\tif (!present_and_same_family(ext_hdrs[SADB_EXT_ADDRESS_SRC-1],\n\t\t\t\t     ext_hdrs[SADB_EXT_ADDRESS_DST-1]) ||\n\t    !ext_hdrs[SADB_X_EXT_POLICY-1])\n\t\treturn -EINVAL;\n\n\tpol = ext_hdrs[SADB_X_EXT_POLICY-1];\n\tif (!pol->sadb_x_policy_dir || pol->sadb_x_policy_dir >= IPSEC_DIR_MAX)\n\t\treturn -EINVAL;\n\n\tmemset(&sel, 0, sizeof(sel));\n\n\tsa = ext_hdrs[SADB_EXT_ADDRESS_SRC-1];\n\tsel.family = pfkey_sadb_addr2xfrm_addr(sa, &sel.saddr);\n\tsel.prefixlen_s = sa->sadb_address_prefixlen;\n\tsel.proto = pfkey_proto_to_xfrm(sa->sadb_address_proto);\n\tsel.sport = ((struct sockaddr_in *)(sa+1))->sin_port;\n\tif (sel.sport)\n\t\tsel.sport_mask = htons(0xffff);\n\n\tsa = ext_hdrs[SADB_EXT_ADDRESS_DST-1];\n\tpfkey_sadb_addr2xfrm_addr(sa, &sel.daddr);\n\tsel.prefixlen_d = sa->sadb_address_prefixlen;\n\tsel.proto = pfkey_proto_to_xfrm(sa->sadb_address_proto);\n\tsel.dport = ((struct sockaddr_in *)(sa+1))->sin_port;\n\tif (sel.dport)\n\t\tsel.dport_mask = htons(0xffff);\n\n\tsec_ctx = ext_hdrs[SADB_X_EXT_SEC_CTX - 1];\n\tif (sec_ctx != NULL) {\n\t\tstruct xfrm_user_sec_ctx *uctx = pfkey_sadb2xfrm_user_sec_ctx(sec_ctx, GFP_KERNEL);\n\n\t\tif (!uctx)\n\t\t\treturn -ENOMEM;\n\n\t\terr = security_xfrm_policy_alloc(&pol_ctx, uctx, GFP_KERNEL);\n\t\tkfree(uctx);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\txp = xfrm_policy_bysel_ctx(net, &dummy_mark, 0, XFRM_POLICY_TYPE_MAIN,\n\t\t\t\t   pol->sadb_x_policy_dir - 1, &sel, pol_ctx,\n\t\t\t\t   1, &err);\n\tsecurity_xfrm_policy_free(pol_ctx);\n\tif (xp == NULL)\n\t\treturn -ENOENT;\n\n\txfrm_audit_policy_delete(xp, err ? 0 : 1, true);\n\n\tif (err)\n\t\tgoto out;\n\n\tc.seq = hdr->sadb_msg_seq;\n\tc.portid = hdr->sadb_msg_pid;\n\tc.data.byid = 0;\n\tc.event = XFRM_MSG_DELPOLICY;\n\tkm_policy_notify(xp, pol->sadb_x_policy_dir-1, &c);\n\nout:\n\txfrm_pol_put(xp);\n\treturn err;\n}\n\nstatic int key_pol_get_resp(struct sock *sk, struct xfrm_policy *xp, const struct sadb_msg *hdr, int dir)\n{\n\tint err;\n\tstruct sk_buff *out_skb;\n\tstruct sadb_msg *out_hdr;\n\terr = 0;\n\n\tout_skb = pfkey_xfrm_policy2msg_prep(xp);\n\tif (IS_ERR(out_skb)) {\n\t\terr =  PTR_ERR(out_skb);\n\t\tgoto out;\n\t}\n\terr = pfkey_xfrm_policy2msg(out_skb, xp, dir);\n\tif (err < 0) {\n\t\tkfree_skb(out_skb);\n\t\tgoto out;\n\t}\n\n\tout_hdr = (struct sadb_msg *) out_skb->data;\n\tout_hdr->sadb_msg_version = hdr->sadb_msg_version;\n\tout_hdr->sadb_msg_type = hdr->sadb_msg_type;\n\tout_hdr->sadb_msg_satype = 0;\n\tout_hdr->sadb_msg_errno = 0;\n\tout_hdr->sadb_msg_seq = hdr->sadb_msg_seq;\n\tout_hdr->sadb_msg_pid = hdr->sadb_msg_pid;\n\tpfkey_broadcast(out_skb, GFP_ATOMIC, BROADCAST_ONE, sk, xp_net(xp));\n\terr = 0;\n\nout:\n\treturn err;\n}\n\nstatic int pfkey_sockaddr_pair_size(sa_family_t family)\n{\n\treturn PFKEY_ALIGN8(pfkey_sockaddr_len(family) * 2);\n}\n\nstatic int parse_sockaddr_pair(struct sockaddr *sa, int ext_len,\n\t\t\t       xfrm_address_t *saddr, xfrm_address_t *daddr,\n\t\t\t       u16 *family)\n{\n\tint af, socklen;\n\n\tif (ext_len < 2 || ext_len < pfkey_sockaddr_pair_size(sa->sa_family))\n\t\treturn -EINVAL;\n\n\taf = pfkey_sockaddr_extract(sa, saddr);\n\tif (!af)\n\t\treturn -EINVAL;\n\n\tsocklen = pfkey_sockaddr_len(af);\n\tif (pfkey_sockaddr_extract((struct sockaddr *) (((u8 *)sa) + socklen),\n\t\t\t\t   daddr) != af)\n\t\treturn -EINVAL;\n\n\t*family = af;\n\treturn 0;\n}\n\n#ifdef CONFIG_NET_KEY_MIGRATE\nstatic int ipsecrequests_to_migrate(struct sadb_x_ipsecrequest *rq1, int len,\n\t\t\t\t    struct xfrm_migrate *m)\n{\n\tint err;\n\tstruct sadb_x_ipsecrequest *rq2;\n\tint mode;\n\n\tif (len < sizeof(*rq1) ||\n\t    len < rq1->sadb_x_ipsecrequest_len ||\n\t    rq1->sadb_x_ipsecrequest_len < sizeof(*rq1))\n\t\treturn -EINVAL;\n\n\t/* old endoints */\n\terr = parse_sockaddr_pair((struct sockaddr *)(rq1 + 1),\n\t\t\t\t  rq1->sadb_x_ipsecrequest_len - sizeof(*rq1),\n\t\t\t\t  &m->old_saddr, &m->old_daddr,\n\t\t\t\t  &m->old_family);\n\tif (err)\n\t\treturn err;\n\n\trq2 = (struct sadb_x_ipsecrequest *)((u8 *)rq1 + rq1->sadb_x_ipsecrequest_len);\n\tlen -= rq1->sadb_x_ipsecrequest_len;\n\n\tif (len <= sizeof(*rq2) ||\n\t    len < rq2->sadb_x_ipsecrequest_len ||\n\t    rq2->sadb_x_ipsecrequest_len < sizeof(*rq2))\n\t\treturn -EINVAL;\n\n\t/* new endpoints */\n\terr = parse_sockaddr_pair((struct sockaddr *)(rq2 + 1),\n\t\t\t\t  rq2->sadb_x_ipsecrequest_len - sizeof(*rq2),\n\t\t\t\t  &m->new_saddr, &m->new_daddr,\n\t\t\t\t  &m->new_family);\n\tif (err)\n\t\treturn err;\n\n\tif (rq1->sadb_x_ipsecrequest_proto != rq2->sadb_x_ipsecrequest_proto ||\n\t    rq1->sadb_x_ipsecrequest_mode != rq2->sadb_x_ipsecrequest_mode ||\n\t    rq1->sadb_x_ipsecrequest_reqid != rq2->sadb_x_ipsecrequest_reqid)\n\t\treturn -EINVAL;\n\n\tm->proto = rq1->sadb_x_ipsecrequest_proto;\n\tif ((mode = pfkey_mode_to_xfrm(rq1->sadb_x_ipsecrequest_mode)) < 0)\n\t\treturn -EINVAL;\n\tm->mode = mode;\n\tm->reqid = rq1->sadb_x_ipsecrequest_reqid;\n\n\treturn ((int)(rq1->sadb_x_ipsecrequest_len +\n\t\t      rq2->sadb_x_ipsecrequest_len));\n}\n\nstatic int pfkey_migrate(struct sock *sk, struct sk_buff *skb,\n\t\t\t const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tint i, len, ret, err = -EINVAL;\n\tu8 dir;\n\tstruct sadb_address *sa;\n\tstruct sadb_x_kmaddress *kma;\n\tstruct sadb_x_policy *pol;\n\tstruct sadb_x_ipsecrequest *rq;\n\tstruct xfrm_selector sel;\n\tstruct xfrm_migrate m[XFRM_MAX_DEPTH];\n\tstruct xfrm_kmaddress k;\n\tstruct net *net = sock_net(sk);\n\n\tif (!present_and_same_family(ext_hdrs[SADB_EXT_ADDRESS_SRC - 1],\n\t\t\t\t     ext_hdrs[SADB_EXT_ADDRESS_DST - 1]) ||\n\t    !ext_hdrs[SADB_X_EXT_POLICY - 1]) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tkma = ext_hdrs[SADB_X_EXT_KMADDRESS - 1];\n\tpol = ext_hdrs[SADB_X_EXT_POLICY - 1];\n\n\tif (pol->sadb_x_policy_dir >= IPSEC_DIR_MAX) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (kma) {\n\t\t/* convert sadb_x_kmaddress to xfrm_kmaddress */\n\t\tk.reserved = kma->sadb_x_kmaddress_reserved;\n\t\tret = parse_sockaddr_pair((struct sockaddr *)(kma + 1),\n\t\t\t\t\t  8*(kma->sadb_x_kmaddress_len) - sizeof(*kma),\n\t\t\t\t\t  &k.local, &k.remote, &k.family);\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tdir = pol->sadb_x_policy_dir - 1;\n\tmemset(&sel, 0, sizeof(sel));\n\n\t/* set source address info of selector */\n\tsa = ext_hdrs[SADB_EXT_ADDRESS_SRC - 1];\n\tsel.family = pfkey_sadb_addr2xfrm_addr(sa, &sel.saddr);\n\tsel.prefixlen_s = sa->sadb_address_prefixlen;\n\tsel.proto = pfkey_proto_to_xfrm(sa->sadb_address_proto);\n\tsel.sport = ((struct sockaddr_in *)(sa + 1))->sin_port;\n\tif (sel.sport)\n\t\tsel.sport_mask = htons(0xffff);\n\n\t/* set destination address info of selector */\n\tsa = ext_hdrs[SADB_EXT_ADDRESS_DST - 1];\n\tpfkey_sadb_addr2xfrm_addr(sa, &sel.daddr);\n\tsel.prefixlen_d = sa->sadb_address_prefixlen;\n\tsel.proto = pfkey_proto_to_xfrm(sa->sadb_address_proto);\n\tsel.dport = ((struct sockaddr_in *)(sa + 1))->sin_port;\n\tif (sel.dport)\n\t\tsel.dport_mask = htons(0xffff);\n\n\trq = (struct sadb_x_ipsecrequest *)(pol + 1);\n\n\t/* extract ipsecrequests */\n\ti = 0;\n\tlen = pol->sadb_x_policy_len * 8 - sizeof(struct sadb_x_policy);\n\n\twhile (len > 0 && i < XFRM_MAX_DEPTH) {\n\t\tret = ipsecrequests_to_migrate(rq, len, &m[i]);\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\trq = (struct sadb_x_ipsecrequest *)((u8 *)rq + ret);\n\t\t\tlen -= ret;\n\t\t\ti++;\n\t\t}\n\t}\n\n\tif (!i || len > 0) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\treturn xfrm_migrate(&sel, dir, XFRM_POLICY_TYPE_MAIN, m, i,\n\t\t\t    kma ? &k : NULL, net, NULL, 0);\n\n out:\n\treturn err;\n}\n#else\nstatic int pfkey_migrate(struct sock *sk, struct sk_buff *skb,\n\t\t\t const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\treturn -ENOPROTOOPT;\n}\n#endif\n\n\nstatic int pfkey_spdget(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct net *net = sock_net(sk);\n\tunsigned int dir;\n\tint err = 0, delete;\n\tstruct sadb_x_policy *pol;\n\tstruct xfrm_policy *xp;\n\tstruct km_event c;\n\n\tif ((pol = ext_hdrs[SADB_X_EXT_POLICY-1]) == NULL)\n\t\treturn -EINVAL;\n\n\tdir = xfrm_policy_id2dir(pol->sadb_x_policy_id);\n\tif (dir >= XFRM_POLICY_MAX)\n\t\treturn -EINVAL;\n\n\tdelete = (hdr->sadb_msg_type == SADB_X_SPDDELETE2);\n\txp = xfrm_policy_byid(net, &dummy_mark, 0, XFRM_POLICY_TYPE_MAIN,\n\t\t\t      dir, pol->sadb_x_policy_id, delete, &err);\n\tif (xp == NULL)\n\t\treturn -ENOENT;\n\n\tif (delete) {\n\t\txfrm_audit_policy_delete(xp, err ? 0 : 1, true);\n\n\t\tif (err)\n\t\t\tgoto out;\n\t\tc.seq = hdr->sadb_msg_seq;\n\t\tc.portid = hdr->sadb_msg_pid;\n\t\tc.data.byid = 1;\n\t\tc.event = XFRM_MSG_DELPOLICY;\n\t\tkm_policy_notify(xp, dir, &c);\n\t} else {\n\t\terr = key_pol_get_resp(sk, xp, hdr, dir);\n\t}\n\nout:\n\txfrm_pol_put(xp);\n\treturn err;\n}\n\nstatic int dump_sp(struct xfrm_policy *xp, int dir, int count, void *ptr)\n{\n\tstruct pfkey_sock *pfk = ptr;\n\tstruct sk_buff *out_skb;\n\tstruct sadb_msg *out_hdr;\n\tint err;\n\n\tif (!pfkey_can_dump(&pfk->sk))\n\t\treturn -ENOBUFS;\n\n\tout_skb = pfkey_xfrm_policy2msg_prep(xp);\n\tif (IS_ERR(out_skb))\n\t\treturn PTR_ERR(out_skb);\n\n\terr = pfkey_xfrm_policy2msg(out_skb, xp, dir);\n\tif (err < 0) {\n\t\tkfree_skb(out_skb);\n\t\treturn err;\n\t}\n\n\tout_hdr = (struct sadb_msg *) out_skb->data;\n\tout_hdr->sadb_msg_version = pfk->dump.msg_version;\n\tout_hdr->sadb_msg_type = SADB_X_SPDDUMP;\n\tout_hdr->sadb_msg_satype = SADB_SATYPE_UNSPEC;\n\tout_hdr->sadb_msg_errno = 0;\n\tout_hdr->sadb_msg_seq = count + 1;\n\tout_hdr->sadb_msg_pid = pfk->dump.msg_portid;\n\n\tif (pfk->dump.skb)\n\t\tpfkey_broadcast(pfk->dump.skb, GFP_ATOMIC, BROADCAST_ONE,\n\t\t\t\t&pfk->sk, sock_net(&pfk->sk));\n\tpfk->dump.skb = out_skb;\n\n\treturn 0;\n}\n\nstatic int pfkey_dump_sp(struct pfkey_sock *pfk)\n{\n\tstruct net *net = sock_net(&pfk->sk);\n\treturn xfrm_policy_walk(net, &pfk->dump.u.policy, dump_sp, (void *) pfk);\n}\n\nstatic void pfkey_dump_sp_done(struct pfkey_sock *pfk)\n{\n\tstruct net *net = sock_net((struct sock *)pfk);\n\n\txfrm_policy_walk_done(&pfk->dump.u.policy, net);\n}\n\nstatic int pfkey_spddump(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct pfkey_sock *pfk = pfkey_sk(sk);\n\n\tmutex_lock(&pfk->dump_lock);\n\tif (pfk->dump.dump != NULL) {\n\t\tmutex_unlock(&pfk->dump_lock);\n\t\treturn -EBUSY;\n\t}\n\n\tpfk->dump.msg_version = hdr->sadb_msg_version;\n\tpfk->dump.msg_portid = hdr->sadb_msg_pid;\n\tpfk->dump.dump = pfkey_dump_sp;\n\tpfk->dump.done = pfkey_dump_sp_done;\n\txfrm_policy_walk_init(&pfk->dump.u.policy, XFRM_POLICY_TYPE_MAIN);\n\tmutex_unlock(&pfk->dump_lock);\n\n\treturn pfkey_do_dump(pfk);\n}\n\nstatic int key_notify_policy_flush(const struct km_event *c)\n{\n\tstruct sk_buff *skb_out;\n\tstruct sadb_msg *hdr;\n\n\tskb_out = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_ATOMIC);\n\tif (!skb_out)\n\t\treturn -ENOBUFS;\n\thdr = skb_put(skb_out, sizeof(struct sadb_msg));\n\thdr->sadb_msg_type = SADB_X_SPDFLUSH;\n\thdr->sadb_msg_seq = c->seq;\n\thdr->sadb_msg_pid = c->portid;\n\thdr->sadb_msg_version = PF_KEY_V2;\n\thdr->sadb_msg_errno = (uint8_t) 0;\n\thdr->sadb_msg_satype = SADB_SATYPE_UNSPEC;\n\thdr->sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));\n\thdr->sadb_msg_reserved = 0;\n\tpfkey_broadcast(skb_out, GFP_ATOMIC, BROADCAST_ALL, NULL, c->net);\n\treturn 0;\n\n}\n\nstatic int pfkey_spdflush(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct km_event c;\n\tint err, err2;\n\n\terr = xfrm_policy_flush(net, XFRM_POLICY_TYPE_MAIN, true);\n\terr2 = unicast_flush_resp(sk, hdr);\n\tif (err || err2) {\n\t\tif (err == -ESRCH) /* empty table - old silent behavior */\n\t\t\treturn 0;\n\t\treturn err;\n\t}\n\n\tc.data.type = XFRM_POLICY_TYPE_MAIN;\n\tc.event = XFRM_MSG_FLUSHPOLICY;\n\tc.portid = hdr->sadb_msg_pid;\n\tc.seq = hdr->sadb_msg_seq;\n\tc.net = net;\n\tkm_policy_notify(NULL, 0, &c);\n\n\treturn 0;\n}\n\ntypedef int (*pfkey_handler)(struct sock *sk, struct sk_buff *skb,\n\t\t\t     const struct sadb_msg *hdr, void * const *ext_hdrs);\nstatic const pfkey_handler pfkey_funcs[SADB_MAX + 1] = {\n\t[SADB_RESERVED]\t\t= pfkey_reserved,\n\t[SADB_GETSPI]\t\t= pfkey_getspi,\n\t[SADB_UPDATE]\t\t= pfkey_add,\n\t[SADB_ADD]\t\t= pfkey_add,\n\t[SADB_DELETE]\t\t= pfkey_delete,\n\t[SADB_GET]\t\t= pfkey_get,\n\t[SADB_ACQUIRE]\t\t= pfkey_acquire,\n\t[SADB_REGISTER]\t\t= pfkey_register,\n\t[SADB_EXPIRE]\t\t= NULL,\n\t[SADB_FLUSH]\t\t= pfkey_flush,\n\t[SADB_DUMP]\t\t= pfkey_dump,\n\t[SADB_X_PROMISC]\t= pfkey_promisc,\n\t[SADB_X_PCHANGE]\t= NULL,\n\t[SADB_X_SPDUPDATE]\t= pfkey_spdadd,\n\t[SADB_X_SPDADD]\t\t= pfkey_spdadd,\n\t[SADB_X_SPDDELETE]\t= pfkey_spddelete,\n\t[SADB_X_SPDGET]\t\t= pfkey_spdget,\n\t[SADB_X_SPDACQUIRE]\t= NULL,\n\t[SADB_X_SPDDUMP]\t= pfkey_spddump,\n\t[SADB_X_SPDFLUSH]\t= pfkey_spdflush,\n\t[SADB_X_SPDSETIDX]\t= pfkey_spdadd,\n\t[SADB_X_SPDDELETE2]\t= pfkey_spdget,\n\t[SADB_X_MIGRATE]\t= pfkey_migrate,\n};\n\nstatic int pfkey_process(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr)\n{\n\tvoid *ext_hdrs[SADB_EXT_MAX];\n\tint err;\n\n\tpfkey_broadcast(skb_clone(skb, GFP_KERNEL), GFP_KERNEL,\n\t\t\tBROADCAST_PROMISC_ONLY, NULL, sock_net(sk));\n\n\tmemset(ext_hdrs, 0, sizeof(ext_hdrs));\n\terr = parse_exthdrs(skb, hdr, ext_hdrs);\n\tif (!err) {\n\t\terr = -EOPNOTSUPP;\n\t\tif (pfkey_funcs[hdr->sadb_msg_type])\n\t\t\terr = pfkey_funcs[hdr->sadb_msg_type](sk, skb, hdr, ext_hdrs);\n\t}\n\treturn err;\n}\n\nstatic struct sadb_msg *pfkey_get_base_msg(struct sk_buff *skb, int *errp)\n{\n\tstruct sadb_msg *hdr = NULL;\n\n\tif (skb->len < sizeof(*hdr)) {\n\t\t*errp = -EMSGSIZE;\n\t} else {\n\t\thdr = (struct sadb_msg *) skb->data;\n\t\tif (hdr->sadb_msg_version != PF_KEY_V2 ||\n\t\t    hdr->sadb_msg_reserved != 0 ||\n\t\t    (hdr->sadb_msg_type <= SADB_RESERVED ||\n\t\t     hdr->sadb_msg_type > SADB_MAX)) {\n\t\t\thdr = NULL;\n\t\t\t*errp = -EINVAL;\n\t\t} else if (hdr->sadb_msg_len != (skb->len /\n\t\t\t\t\t\t sizeof(uint64_t)) ||\n\t\t\t   hdr->sadb_msg_len < (sizeof(struct sadb_msg) /\n\t\t\t\t\t\tsizeof(uint64_t))) {\n\t\t\thdr = NULL;\n\t\t\t*errp = -EMSGSIZE;\n\t\t} else {\n\t\t\t*errp = 0;\n\t\t}\n\t}\n\treturn hdr;\n}\n\nstatic inline int aalg_tmpl_set(const struct xfrm_tmpl *t,\n\t\t\t\tconst struct xfrm_algo_desc *d)\n{\n\tunsigned int id = d->desc.sadb_alg_id;\n\n\tif (id >= sizeof(t->aalgos) * 8)\n\t\treturn 0;\n\n\treturn (t->aalgos >> id) & 1;\n}\n\nstatic inline int ealg_tmpl_set(const struct xfrm_tmpl *t,\n\t\t\t\tconst struct xfrm_algo_desc *d)\n{\n\tunsigned int id = d->desc.sadb_alg_id;\n\n\tif (id >= sizeof(t->ealgos) * 8)\n\t\treturn 0;\n\n\treturn (t->ealgos >> id) & 1;\n}\n\nstatic int count_ah_combs(const struct xfrm_tmpl *t)\n{\n\tint i, sz = 0;\n\n\tfor (i = 0; ; i++) {\n\t\tconst struct xfrm_algo_desc *aalg = xfrm_aalg_get_byidx(i);\n\t\tif (!aalg)\n\t\t\tbreak;\n\t\tif (!aalg->pfkey_supported)\n\t\t\tcontinue;\n\t\tif (aalg_tmpl_set(t, aalg))\n\t\t\tsz += sizeof(struct sadb_comb);\n\t}\n\treturn sz + sizeof(struct sadb_prop);\n}\n\nstatic int count_esp_combs(const struct xfrm_tmpl *t)\n{\n\tint i, k, sz = 0;\n\n\tfor (i = 0; ; i++) {\n\t\tconst struct xfrm_algo_desc *ealg = xfrm_ealg_get_byidx(i);\n\t\tif (!ealg)\n\t\t\tbreak;\n\n\t\tif (!ealg->pfkey_supported)\n\t\t\tcontinue;\n\n\t\tif (!(ealg_tmpl_set(t, ealg)))\n\t\t\tcontinue;\n\n\t\tfor (k = 1; ; k++) {\n\t\t\tconst struct xfrm_algo_desc *aalg = xfrm_aalg_get_byidx(k);\n\t\t\tif (!aalg)\n\t\t\t\tbreak;\n\n\t\t\tif (!aalg->pfkey_supported)\n\t\t\t\tcontinue;\n\n\t\t\tif (aalg_tmpl_set(t, aalg))\n\t\t\t\tsz += sizeof(struct sadb_comb);\n\t\t}\n\t}\n\treturn sz + sizeof(struct sadb_prop);\n}\n\nstatic void dump_ah_combs(struct sk_buff *skb, const struct xfrm_tmpl *t)\n{\n\tstruct sadb_prop *p;\n\tint i;\n\n\tp = skb_put(skb, sizeof(struct sadb_prop));\n\tp->sadb_prop_len = sizeof(struct sadb_prop)/8;\n\tp->sadb_prop_exttype = SADB_EXT_PROPOSAL;\n\tp->sadb_prop_replay = 32;\n\tmemset(p->sadb_prop_reserved, 0, sizeof(p->sadb_prop_reserved));\n\n\tfor (i = 0; ; i++) {\n\t\tconst struct xfrm_algo_desc *aalg = xfrm_aalg_get_byidx(i);\n\t\tif (!aalg)\n\t\t\tbreak;\n\n\t\tif (!aalg->pfkey_supported)\n\t\t\tcontinue;\n\n\t\tif (aalg_tmpl_set(t, aalg) && aalg->available) {\n\t\t\tstruct sadb_comb *c;\n\t\t\tc = skb_put_zero(skb, sizeof(struct sadb_comb));\n\t\t\tp->sadb_prop_len += sizeof(struct sadb_comb)/8;\n\t\t\tc->sadb_comb_auth = aalg->desc.sadb_alg_id;\n\t\t\tc->sadb_comb_auth_minbits = aalg->desc.sadb_alg_minbits;\n\t\t\tc->sadb_comb_auth_maxbits = aalg->desc.sadb_alg_maxbits;\n\t\t\tc->sadb_comb_hard_addtime = 24*60*60;\n\t\t\tc->sadb_comb_soft_addtime = 20*60*60;\n\t\t\tc->sadb_comb_hard_usetime = 8*60*60;\n\t\t\tc->sadb_comb_soft_usetime = 7*60*60;\n\t\t}\n\t}\n}\n\nstatic void dump_esp_combs(struct sk_buff *skb, const struct xfrm_tmpl *t)\n{\n\tstruct sadb_prop *p;\n\tint i, k;\n\n\tp = skb_put(skb, sizeof(struct sadb_prop));\n\tp->sadb_prop_len = sizeof(struct sadb_prop)/8;\n\tp->sadb_prop_exttype = SADB_EXT_PROPOSAL;\n\tp->sadb_prop_replay = 32;\n\tmemset(p->sadb_prop_reserved, 0, sizeof(p->sadb_prop_reserved));\n\n\tfor (i=0; ; i++) {\n\t\tconst struct xfrm_algo_desc *ealg = xfrm_ealg_get_byidx(i);\n\t\tif (!ealg)\n\t\t\tbreak;\n\n\t\tif (!ealg->pfkey_supported)\n\t\t\tcontinue;\n\n\t\tif (!(ealg_tmpl_set(t, ealg) && ealg->available))\n\t\t\tcontinue;\n\n\t\tfor (k = 1; ; k++) {\n\t\t\tstruct sadb_comb *c;\n\t\t\tconst struct xfrm_algo_desc *aalg = xfrm_aalg_get_byidx(k);\n\t\t\tif (!aalg)\n\t\t\t\tbreak;\n\t\t\tif (!aalg->pfkey_supported)\n\t\t\t\tcontinue;\n\t\t\tif (!(aalg_tmpl_set(t, aalg) && aalg->available))\n\t\t\t\tcontinue;\n\t\t\tc = skb_put(skb, sizeof(struct sadb_comb));\n\t\t\tmemset(c, 0, sizeof(*c));\n\t\t\tp->sadb_prop_len += sizeof(struct sadb_comb)/8;\n\t\t\tc->sadb_comb_auth = aalg->desc.sadb_alg_id;\n\t\t\tc->sadb_comb_auth_minbits = aalg->desc.sadb_alg_minbits;\n\t\t\tc->sadb_comb_auth_maxbits = aalg->desc.sadb_alg_maxbits;\n\t\t\tc->sadb_comb_encrypt = ealg->desc.sadb_alg_id;\n\t\t\tc->sadb_comb_encrypt_minbits = ealg->desc.sadb_alg_minbits;\n\t\t\tc->sadb_comb_encrypt_maxbits = ealg->desc.sadb_alg_maxbits;\n\t\t\tc->sadb_comb_hard_addtime = 24*60*60;\n\t\t\tc->sadb_comb_soft_addtime = 20*60*60;\n\t\t\tc->sadb_comb_hard_usetime = 8*60*60;\n\t\t\tc->sadb_comb_soft_usetime = 7*60*60;\n\t\t}\n\t}\n}\n\nstatic int key_notify_policy_expire(struct xfrm_policy *xp, const struct km_event *c)\n{\n\treturn 0;\n}\n\nstatic int key_notify_sa_expire(struct xfrm_state *x, const struct km_event *c)\n{\n\tstruct sk_buff *out_skb;\n\tstruct sadb_msg *out_hdr;\n\tint hard;\n\tint hsc;\n\n\thard = c->data.hard;\n\tif (hard)\n\t\thsc = 2;\n\telse\n\t\thsc = 1;\n\n\tout_skb = pfkey_xfrm_state2msg_expire(x, hsc);\n\tif (IS_ERR(out_skb))\n\t\treturn PTR_ERR(out_skb);\n\n\tout_hdr = (struct sadb_msg *) out_skb->data;\n\tout_hdr->sadb_msg_version = PF_KEY_V2;\n\tout_hdr->sadb_msg_type = SADB_EXPIRE;\n\tout_hdr->sadb_msg_satype = pfkey_proto2satype(x->id.proto);\n\tout_hdr->sadb_msg_errno = 0;\n\tout_hdr->sadb_msg_reserved = 0;\n\tout_hdr->sadb_msg_seq = 0;\n\tout_hdr->sadb_msg_pid = 0;\n\n\tpfkey_broadcast(out_skb, GFP_ATOMIC, BROADCAST_REGISTERED, NULL,\n\t\t\txs_net(x));\n\treturn 0;\n}\n\nstatic int pfkey_send_notify(struct xfrm_state *x, const struct km_event *c)\n{\n\tstruct net *net = x ? xs_net(x) : c->net;\n\tstruct netns_pfkey *net_pfkey = net_generic(net, pfkey_net_id);\n\n\tif (atomic_read(&net_pfkey->socks_nr) == 0)\n\t\treturn 0;\n\n\tswitch (c->event) {\n\tcase XFRM_MSG_EXPIRE:\n\t\treturn key_notify_sa_expire(x, c);\n\tcase XFRM_MSG_DELSA:\n\tcase XFRM_MSG_NEWSA:\n\tcase XFRM_MSG_UPDSA:\n\t\treturn key_notify_sa(x, c);\n\tcase XFRM_MSG_FLUSHSA:\n\t\treturn key_notify_sa_flush(c);\n\tcase XFRM_MSG_NEWAE: /* not yet supported */\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"pfkey: Unknown SA event %d\\n\", c->event);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int pfkey_send_policy_notify(struct xfrm_policy *xp, int dir, const struct km_event *c)\n{\n\tif (xp && xp->type != XFRM_POLICY_TYPE_MAIN)\n\t\treturn 0;\n\n\tswitch (c->event) {\n\tcase XFRM_MSG_POLEXPIRE:\n\t\treturn key_notify_policy_expire(xp, c);\n\tcase XFRM_MSG_DELPOLICY:\n\tcase XFRM_MSG_NEWPOLICY:\n\tcase XFRM_MSG_UPDPOLICY:\n\t\treturn key_notify_policy(xp, dir, c);\n\tcase XFRM_MSG_FLUSHPOLICY:\n\t\tif (c->data.type != XFRM_POLICY_TYPE_MAIN)\n\t\t\tbreak;\n\t\treturn key_notify_policy_flush(c);\n\tdefault:\n\t\tpr_err(\"pfkey: Unknown policy event %d\\n\", c->event);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic u32 get_acqseq(void)\n{\n\tu32 res;\n\tstatic atomic_t acqseq;\n\n\tdo {\n\t\tres = atomic_inc_return(&acqseq);\n\t} while (!res);\n\treturn res;\n}\n\nstatic bool pfkey_is_alive(const struct km_event *c)\n{\n\tstruct netns_pfkey *net_pfkey = net_generic(c->net, pfkey_net_id);\n\tstruct sock *sk;\n\tbool is_alive = false;\n\n\trcu_read_lock();\n\tsk_for_each_rcu(sk, &net_pfkey->table) {\n\t\tif (pfkey_sk(sk)->registered) {\n\t\t\tis_alive = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn is_alive;\n}\n\nstatic int pfkey_send_acquire(struct xfrm_state *x, struct xfrm_tmpl *t, struct xfrm_policy *xp)\n{\n\tstruct sk_buff *skb;\n\tstruct sadb_msg *hdr;\n\tstruct sadb_address *addr;\n\tstruct sadb_x_policy *pol;\n\tint sockaddr_size;\n\tint size;\n\tstruct sadb_x_sec_ctx *sec_ctx;\n\tstruct xfrm_sec_ctx *xfrm_ctx;\n\tint ctx_size = 0;\n\n\tsockaddr_size = pfkey_sockaddr_size(x->props.family);\n\tif (!sockaddr_size)\n\t\treturn -EINVAL;\n\n\tsize = sizeof(struct sadb_msg) +\n\t\t(sizeof(struct sadb_address) * 2) +\n\t\t(sockaddr_size * 2) +\n\t\tsizeof(struct sadb_x_policy);\n\n\tif (x->id.proto == IPPROTO_AH)\n\t\tsize += count_ah_combs(t);\n\telse if (x->id.proto == IPPROTO_ESP)\n\t\tsize += count_esp_combs(t);\n\n\tif ((xfrm_ctx = x->security)) {\n\t\tctx_size = PFKEY_ALIGN8(xfrm_ctx->ctx_len);\n\t\tsize +=  sizeof(struct sadb_x_sec_ctx) + ctx_size;\n\t}\n\n\tskb =  alloc_skb(size + 16, GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\thdr = skb_put(skb, sizeof(struct sadb_msg));\n\thdr->sadb_msg_version = PF_KEY_V2;\n\thdr->sadb_msg_type = SADB_ACQUIRE;\n\thdr->sadb_msg_satype = pfkey_proto2satype(x->id.proto);\n\thdr->sadb_msg_len = size / sizeof(uint64_t);\n\thdr->sadb_msg_errno = 0;\n\thdr->sadb_msg_reserved = 0;\n\thdr->sadb_msg_seq = x->km.seq = get_acqseq();\n\thdr->sadb_msg_pid = 0;\n\n\t/* src address */\n\taddr = skb_put(skb, sizeof(struct sadb_address) + sockaddr_size);\n\taddr->sadb_address_len =\n\t\t(sizeof(struct sadb_address)+sockaddr_size)/\n\t\t\tsizeof(uint64_t);\n\taddr->sadb_address_exttype = SADB_EXT_ADDRESS_SRC;\n\taddr->sadb_address_proto = 0;\n\taddr->sadb_address_reserved = 0;\n\taddr->sadb_address_prefixlen =\n\t\tpfkey_sockaddr_fill(&x->props.saddr, 0,\n\t\t\t\t    (struct sockaddr *) (addr + 1),\n\t\t\t\t    x->props.family);\n\tif (!addr->sadb_address_prefixlen)\n\t\tBUG();\n\n\t/* dst address */\n\taddr = skb_put(skb, sizeof(struct sadb_address) + sockaddr_size);\n\taddr->sadb_address_len =\n\t\t(sizeof(struct sadb_address)+sockaddr_size)/\n\t\t\tsizeof(uint64_t);\n\taddr->sadb_address_exttype = SADB_EXT_ADDRESS_DST;\n\taddr->sadb_address_proto = 0;\n\taddr->sadb_address_reserved = 0;\n\taddr->sadb_address_prefixlen =\n\t\tpfkey_sockaddr_fill(&x->id.daddr, 0,\n\t\t\t\t    (struct sockaddr *) (addr + 1),\n\t\t\t\t    x->props.family);\n\tif (!addr->sadb_address_prefixlen)\n\t\tBUG();\n\n\tpol = skb_put(skb, sizeof(struct sadb_x_policy));\n\tpol->sadb_x_policy_len = sizeof(struct sadb_x_policy)/sizeof(uint64_t);\n\tpol->sadb_x_policy_exttype = SADB_X_EXT_POLICY;\n\tpol->sadb_x_policy_type = IPSEC_POLICY_IPSEC;\n\tpol->sadb_x_policy_dir = XFRM_POLICY_OUT + 1;\n\tpol->sadb_x_policy_reserved = 0;\n\tpol->sadb_x_policy_id = xp->index;\n\tpol->sadb_x_policy_priority = xp->priority;\n\n\t/* Set sadb_comb's. */\n\tif (x->id.proto == IPPROTO_AH)\n\t\tdump_ah_combs(skb, t);\n\telse if (x->id.proto == IPPROTO_ESP)\n\t\tdump_esp_combs(skb, t);\n\n\t/* security context */\n\tif (xfrm_ctx) {\n\t\tsec_ctx = skb_put(skb,\n\t\t\t\t  sizeof(struct sadb_x_sec_ctx) + ctx_size);\n\t\tsec_ctx->sadb_x_sec_len =\n\t\t  (sizeof(struct sadb_x_sec_ctx) + ctx_size) / sizeof(uint64_t);\n\t\tsec_ctx->sadb_x_sec_exttype = SADB_X_EXT_SEC_CTX;\n\t\tsec_ctx->sadb_x_ctx_doi = xfrm_ctx->ctx_doi;\n\t\tsec_ctx->sadb_x_ctx_alg = xfrm_ctx->ctx_alg;\n\t\tsec_ctx->sadb_x_ctx_len = xfrm_ctx->ctx_len;\n\t\tmemcpy(sec_ctx + 1, xfrm_ctx->ctx_str,\n\t\t       xfrm_ctx->ctx_len);\n\t}\n\n\treturn pfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_REGISTERED, NULL,\n\t\t\t       xs_net(x));\n}\n\nstatic struct xfrm_policy *pfkey_compile_policy(struct sock *sk, int opt,\n\t\t\t\t\t\tu8 *data, int len, int *dir)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct xfrm_policy *xp;\n\tstruct sadb_x_policy *pol = (struct sadb_x_policy*)data;\n\tstruct sadb_x_sec_ctx *sec_ctx;\n\n\tswitch (sk->sk_family) {\n\tcase AF_INET:\n\t\tif (opt != IP_IPSEC_POLICY) {\n\t\t\t*dir = -EOPNOTSUPP;\n\t\t\treturn NULL;\n\t\t}\n\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase AF_INET6:\n\t\tif (opt != IPV6_IPSEC_POLICY) {\n\t\t\t*dir = -EOPNOTSUPP;\n\t\t\treturn NULL;\n\t\t}\n\t\tbreak;\n#endif\n\tdefault:\n\t\t*dir = -EINVAL;\n\t\treturn NULL;\n\t}\n\n\t*dir = -EINVAL;\n\n\tif (len < sizeof(struct sadb_x_policy) ||\n\t    pol->sadb_x_policy_len*8 > len ||\n\t    pol->sadb_x_policy_type > IPSEC_POLICY_BYPASS ||\n\t    (!pol->sadb_x_policy_dir || pol->sadb_x_policy_dir > IPSEC_DIR_OUTBOUND))\n\t\treturn NULL;\n\n\txp = xfrm_policy_alloc(net, GFP_ATOMIC);\n\tif (xp == NULL) {\n\t\t*dir = -ENOBUFS;\n\t\treturn NULL;\n\t}\n\n\txp->action = (pol->sadb_x_policy_type == IPSEC_POLICY_DISCARD ?\n\t\t      XFRM_POLICY_BLOCK : XFRM_POLICY_ALLOW);\n\n\txp->lft.soft_byte_limit = XFRM_INF;\n\txp->lft.hard_byte_limit = XFRM_INF;\n\txp->lft.soft_packet_limit = XFRM_INF;\n\txp->lft.hard_packet_limit = XFRM_INF;\n\txp->family = sk->sk_family;\n\n\txp->xfrm_nr = 0;\n\tif (pol->sadb_x_policy_type == IPSEC_POLICY_IPSEC &&\n\t    (*dir = parse_ipsecrequests(xp, pol)) < 0)\n\t\tgoto out;\n\n\t/* security context too */\n\tif (len >= (pol->sadb_x_policy_len*8 +\n\t    sizeof(struct sadb_x_sec_ctx))) {\n\t\tchar *p = (char *)pol;\n\t\tstruct xfrm_user_sec_ctx *uctx;\n\n\t\tp += pol->sadb_x_policy_len*8;\n\t\tsec_ctx = (struct sadb_x_sec_ctx *)p;\n\t\tif (len < pol->sadb_x_policy_len*8 +\n\t\t    sec_ctx->sadb_x_sec_len*8) {\n\t\t\t*dir = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((*dir = verify_sec_ctx_len(p)))\n\t\t\tgoto out;\n\t\tuctx = pfkey_sadb2xfrm_user_sec_ctx(sec_ctx, GFP_ATOMIC);\n\t\t*dir = security_xfrm_policy_alloc(&xp->security, uctx, GFP_ATOMIC);\n\t\tkfree(uctx);\n\n\t\tif (*dir)\n\t\t\tgoto out;\n\t}\n\n\t*dir = pol->sadb_x_policy_dir-1;\n\treturn xp;\n\nout:\n\txp->walk.dead = 1;\n\txfrm_policy_destroy(xp);\n\treturn NULL;\n}\n\nstatic int pfkey_send_new_mapping(struct xfrm_state *x, xfrm_address_t *ipaddr, __be16 sport)\n{\n\tstruct sk_buff *skb;\n\tstruct sadb_msg *hdr;\n\tstruct sadb_sa *sa;\n\tstruct sadb_address *addr;\n\tstruct sadb_x_nat_t_port *n_port;\n\tint sockaddr_size;\n\tint size;\n\t__u8 satype = (x->id.proto == IPPROTO_ESP ? SADB_SATYPE_ESP : 0);\n\tstruct xfrm_encap_tmpl *natt = NULL;\n\n\tsockaddr_size = pfkey_sockaddr_size(x->props.family);\n\tif (!sockaddr_size)\n\t\treturn -EINVAL;\n\n\tif (!satype)\n\t\treturn -EINVAL;\n\n\tif (!x->encap)\n\t\treturn -EINVAL;\n\n\tnatt = x->encap;\n\n\t/* Build an SADB_X_NAT_T_NEW_MAPPING message:\n\t *\n\t * HDR | SA | ADDRESS_SRC (old addr) | NAT_T_SPORT (old port) |\n\t * ADDRESS_DST (new addr) | NAT_T_DPORT (new port)\n\t */\n\n\tsize = sizeof(struct sadb_msg) +\n\t\tsizeof(struct sadb_sa) +\n\t\t(sizeof(struct sadb_address) * 2) +\n\t\t(sockaddr_size * 2) +\n\t\t(sizeof(struct sadb_x_nat_t_port) * 2);\n\n\tskb =  alloc_skb(size + 16, GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\thdr = skb_put(skb, sizeof(struct sadb_msg));\n\thdr->sadb_msg_version = PF_KEY_V2;\n\thdr->sadb_msg_type = SADB_X_NAT_T_NEW_MAPPING;\n\thdr->sadb_msg_satype = satype;\n\thdr->sadb_msg_len = size / sizeof(uint64_t);\n\thdr->sadb_msg_errno = 0;\n\thdr->sadb_msg_reserved = 0;\n\thdr->sadb_msg_seq = x->km.seq = get_acqseq();\n\thdr->sadb_msg_pid = 0;\n\n\t/* SA */\n\tsa = skb_put(skb, sizeof(struct sadb_sa));\n\tsa->sadb_sa_len = sizeof(struct sadb_sa)/sizeof(uint64_t);\n\tsa->sadb_sa_exttype = SADB_EXT_SA;\n\tsa->sadb_sa_spi = x->id.spi;\n\tsa->sadb_sa_replay = 0;\n\tsa->sadb_sa_state = 0;\n\tsa->sadb_sa_auth = 0;\n\tsa->sadb_sa_encrypt = 0;\n\tsa->sadb_sa_flags = 0;\n\n\t/* ADDRESS_SRC (old addr) */\n\taddr = skb_put(skb, sizeof(struct sadb_address) + sockaddr_size);\n\taddr->sadb_address_len =\n\t\t(sizeof(struct sadb_address)+sockaddr_size)/\n\t\t\tsizeof(uint64_t);\n\taddr->sadb_address_exttype = SADB_EXT_ADDRESS_SRC;\n\taddr->sadb_address_proto = 0;\n\taddr->sadb_address_reserved = 0;\n\taddr->sadb_address_prefixlen =\n\t\tpfkey_sockaddr_fill(&x->props.saddr, 0,\n\t\t\t\t    (struct sockaddr *) (addr + 1),\n\t\t\t\t    x->props.family);\n\tif (!addr->sadb_address_prefixlen)\n\t\tBUG();\n\n\t/* NAT_T_SPORT (old port) */\n\tn_port = skb_put(skb, sizeof(*n_port));\n\tn_port->sadb_x_nat_t_port_len = sizeof(*n_port)/sizeof(uint64_t);\n\tn_port->sadb_x_nat_t_port_exttype = SADB_X_EXT_NAT_T_SPORT;\n\tn_port->sadb_x_nat_t_port_port = natt->encap_sport;\n\tn_port->sadb_x_nat_t_port_reserved = 0;\n\n\t/* ADDRESS_DST (new addr) */\n\taddr = skb_put(skb, sizeof(struct sadb_address) + sockaddr_size);\n\taddr->sadb_address_len =\n\t\t(sizeof(struct sadb_address)+sockaddr_size)/\n\t\t\tsizeof(uint64_t);\n\taddr->sadb_address_exttype = SADB_EXT_ADDRESS_DST;\n\taddr->sadb_address_proto = 0;\n\taddr->sadb_address_reserved = 0;\n\taddr->sadb_address_prefixlen =\n\t\tpfkey_sockaddr_fill(ipaddr, 0,\n\t\t\t\t    (struct sockaddr *) (addr + 1),\n\t\t\t\t    x->props.family);\n\tif (!addr->sadb_address_prefixlen)\n\t\tBUG();\n\n\t/* NAT_T_DPORT (new port) */\n\tn_port = skb_put(skb, sizeof(*n_port));\n\tn_port->sadb_x_nat_t_port_len = sizeof(*n_port)/sizeof(uint64_t);\n\tn_port->sadb_x_nat_t_port_exttype = SADB_X_EXT_NAT_T_DPORT;\n\tn_port->sadb_x_nat_t_port_port = sport;\n\tn_port->sadb_x_nat_t_port_reserved = 0;\n\n\treturn pfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_REGISTERED, NULL,\n\t\t\t       xs_net(x));\n}\n\n#ifdef CONFIG_NET_KEY_MIGRATE\nstatic int set_sadb_address(struct sk_buff *skb, int sasize, int type,\n\t\t\t    const struct xfrm_selector *sel)\n{\n\tstruct sadb_address *addr;\n\taddr = skb_put(skb, sizeof(struct sadb_address) + sasize);\n\taddr->sadb_address_len = (sizeof(struct sadb_address) + sasize)/8;\n\taddr->sadb_address_exttype = type;\n\taddr->sadb_address_proto = sel->proto;\n\taddr->sadb_address_reserved = 0;\n\n\tswitch (type) {\n\tcase SADB_EXT_ADDRESS_SRC:\n\t\taddr->sadb_address_prefixlen = sel->prefixlen_s;\n\t\tpfkey_sockaddr_fill(&sel->saddr, 0,\n\t\t\t\t    (struct sockaddr *)(addr + 1),\n\t\t\t\t    sel->family);\n\t\tbreak;\n\tcase SADB_EXT_ADDRESS_DST:\n\t\taddr->sadb_address_prefixlen = sel->prefixlen_d;\n\t\tpfkey_sockaddr_fill(&sel->daddr, 0,\n\t\t\t\t    (struct sockaddr *)(addr + 1),\n\t\t\t\t    sel->family);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n\nstatic int set_sadb_kmaddress(struct sk_buff *skb, const struct xfrm_kmaddress *k)\n{\n\tstruct sadb_x_kmaddress *kma;\n\tu8 *sa;\n\tint family = k->family;\n\tint socklen = pfkey_sockaddr_len(family);\n\tint size_req;\n\n\tsize_req = (sizeof(struct sadb_x_kmaddress) +\n\t\t    pfkey_sockaddr_pair_size(family));\n\n\tkma = skb_put_zero(skb, size_req);\n\tkma->sadb_x_kmaddress_len = size_req / 8;\n\tkma->sadb_x_kmaddress_exttype = SADB_X_EXT_KMADDRESS;\n\tkma->sadb_x_kmaddress_reserved = k->reserved;\n\n\tsa = (u8 *)(kma + 1);\n\tif (!pfkey_sockaddr_fill(&k->local, 0, (struct sockaddr *)sa, family) ||\n\t    !pfkey_sockaddr_fill(&k->remote, 0, (struct sockaddr *)(sa+socklen), family))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int set_ipsecrequest(struct sk_buff *skb,\n\t\t\t    uint8_t proto, uint8_t mode, int level,\n\t\t\t    uint32_t reqid, uint8_t family,\n\t\t\t    const xfrm_address_t *src, const xfrm_address_t *dst)\n{\n\tstruct sadb_x_ipsecrequest *rq;\n\tu8 *sa;\n\tint socklen = pfkey_sockaddr_len(family);\n\tint size_req;\n\n\tsize_req = sizeof(struct sadb_x_ipsecrequest) +\n\t\t   pfkey_sockaddr_pair_size(family);\n\n\trq = skb_put_zero(skb, size_req);\n\trq->sadb_x_ipsecrequest_len = size_req;\n\trq->sadb_x_ipsecrequest_proto = proto;\n\trq->sadb_x_ipsecrequest_mode = mode;\n\trq->sadb_x_ipsecrequest_level = level;\n\trq->sadb_x_ipsecrequest_reqid = reqid;\n\n\tsa = (u8 *) (rq + 1);\n\tif (!pfkey_sockaddr_fill(src, 0, (struct sockaddr *)sa, family) ||\n\t    !pfkey_sockaddr_fill(dst, 0, (struct sockaddr *)(sa + socklen), family))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n#endif\n\n#ifdef CONFIG_NET_KEY_MIGRATE\nstatic int pfkey_send_migrate(const struct xfrm_selector *sel, u8 dir, u8 type,\n\t\t\t      const struct xfrm_migrate *m, int num_bundles,\n\t\t\t      const struct xfrm_kmaddress *k,\n\t\t\t      const struct xfrm_encap_tmpl *encap)\n{\n\tint i;\n\tint sasize_sel;\n\tint size = 0;\n\tint size_pol = 0;\n\tstruct sk_buff *skb;\n\tstruct sadb_msg *hdr;\n\tstruct sadb_x_policy *pol;\n\tconst struct xfrm_migrate *mp;\n\n\tif (type != XFRM_POLICY_TYPE_MAIN)\n\t\treturn 0;\n\n\tif (num_bundles <= 0 || num_bundles > XFRM_MAX_DEPTH)\n\t\treturn -EINVAL;\n\n\tif (k != NULL) {\n\t\t/* addresses for KM */\n\t\tsize += PFKEY_ALIGN8(sizeof(struct sadb_x_kmaddress) +\n\t\t\t\t     pfkey_sockaddr_pair_size(k->family));\n\t}\n\n\t/* selector */\n\tsasize_sel = pfkey_sockaddr_size(sel->family);\n\tif (!sasize_sel)\n\t\treturn -EINVAL;\n\tsize += (sizeof(struct sadb_address) + sasize_sel) * 2;\n\n\t/* policy info */\n\tsize_pol += sizeof(struct sadb_x_policy);\n\n\t/* ipsecrequests */\n\tfor (i = 0, mp = m; i < num_bundles; i++, mp++) {\n\t\t/* old locator pair */\n\t\tsize_pol += sizeof(struct sadb_x_ipsecrequest) +\n\t\t\t    pfkey_sockaddr_pair_size(mp->old_family);\n\t\t/* new locator pair */\n\t\tsize_pol += sizeof(struct sadb_x_ipsecrequest) +\n\t\t\t    pfkey_sockaddr_pair_size(mp->new_family);\n\t}\n\n\tsize += sizeof(struct sadb_msg) + size_pol;\n\n\t/* alloc buffer */\n\tskb = alloc_skb(size, GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\thdr = skb_put(skb, sizeof(struct sadb_msg));\n\thdr->sadb_msg_version = PF_KEY_V2;\n\thdr->sadb_msg_type = SADB_X_MIGRATE;\n\thdr->sadb_msg_satype = pfkey_proto2satype(m->proto);\n\thdr->sadb_msg_len = size / 8;\n\thdr->sadb_msg_errno = 0;\n\thdr->sadb_msg_reserved = 0;\n\thdr->sadb_msg_seq = 0;\n\thdr->sadb_msg_pid = 0;\n\n\t/* Addresses to be used by KM for negotiation, if ext is available */\n\tif (k != NULL && (set_sadb_kmaddress(skb, k) < 0))\n\t\tgoto err;\n\n\t/* selector src */\n\tset_sadb_address(skb, sasize_sel, SADB_EXT_ADDRESS_SRC, sel);\n\n\t/* selector dst */\n\tset_sadb_address(skb, sasize_sel, SADB_EXT_ADDRESS_DST, sel);\n\n\t/* policy information */\n\tpol = skb_put(skb, sizeof(struct sadb_x_policy));\n\tpol->sadb_x_policy_len = size_pol / 8;\n\tpol->sadb_x_policy_exttype = SADB_X_EXT_POLICY;\n\tpol->sadb_x_policy_type = IPSEC_POLICY_IPSEC;\n\tpol->sadb_x_policy_dir = dir + 1;\n\tpol->sadb_x_policy_reserved = 0;\n\tpol->sadb_x_policy_id = 0;\n\tpol->sadb_x_policy_priority = 0;\n\n\tfor (i = 0, mp = m; i < num_bundles; i++, mp++) {\n\t\t/* old ipsecrequest */\n\t\tint mode = pfkey_mode_from_xfrm(mp->mode);\n\t\tif (mode < 0)\n\t\t\tgoto err;\n\t\tif (set_ipsecrequest(skb, mp->proto, mode,\n\t\t\t\t     (mp->reqid ?  IPSEC_LEVEL_UNIQUE : IPSEC_LEVEL_REQUIRE),\n\t\t\t\t     mp->reqid, mp->old_family,\n\t\t\t\t     &mp->old_saddr, &mp->old_daddr) < 0)\n\t\t\tgoto err;\n\n\t\t/* new ipsecrequest */\n\t\tif (set_ipsecrequest(skb, mp->proto, mode,\n\t\t\t\t     (mp->reqid ? IPSEC_LEVEL_UNIQUE : IPSEC_LEVEL_REQUIRE),\n\t\t\t\t     mp->reqid, mp->new_family,\n\t\t\t\t     &mp->new_saddr, &mp->new_daddr) < 0)\n\t\t\tgoto err;\n\t}\n\n\t/* broadcast migrate message to sockets */\n\tpfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_ALL, NULL, &init_net);\n\n\treturn 0;\n\nerr:\n\tkfree_skb(skb);\n\treturn -EINVAL;\n}\n#else\nstatic int pfkey_send_migrate(const struct xfrm_selector *sel, u8 dir, u8 type,\n\t\t\t      const struct xfrm_migrate *m, int num_bundles,\n\t\t\t      const struct xfrm_kmaddress *k,\n\t\t\t      const struct xfrm_encap_tmpl *encap)\n{\n\treturn -ENOPROTOOPT;\n}\n#endif\n\nstatic int pfkey_sendmsg(struct socket *sock, struct msghdr *msg, size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb = NULL;\n\tstruct sadb_msg *hdr = NULL;\n\tint err;\n\tstruct net *net = sock_net(sk);\n\n\terr = -EOPNOTSUPP;\n\tif (msg->msg_flags & MSG_OOB)\n\t\tgoto out;\n\n\terr = -EMSGSIZE;\n\tif ((unsigned int)len > sk->sk_sndbuf - 32)\n\t\tgoto out;\n\n\terr = -ENOBUFS;\n\tskb = alloc_skb(len, GFP_KERNEL);\n\tif (skb == NULL)\n\t\tgoto out;\n\n\terr = -EFAULT;\n\tif (memcpy_from_msg(skb_put(skb,len), msg, len))\n\t\tgoto out;\n\n\thdr = pfkey_get_base_msg(skb, &err);\n\tif (!hdr)\n\t\tgoto out;\n\n\tmutex_lock(&net->xfrm.xfrm_cfg_mutex);\n\terr = pfkey_process(sk, skb, hdr);\n\tmutex_unlock(&net->xfrm.xfrm_cfg_mutex);\n\nout:\n\tif (err && hdr && pfkey_error(hdr, err, sk) == 0)\n\t\terr = 0;\n\tkfree_skb(skb);\n\n\treturn err ? : len;\n}\n\nstatic int pfkey_recvmsg(struct socket *sock, struct msghdr *msg, size_t len,\n\t\t\t int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct pfkey_sock *pfk = pfkey_sk(sk);\n\tstruct sk_buff *skb;\n\tint copied, err;\n\n\terr = -EINVAL;\n\tif (flags & ~(MSG_PEEK|MSG_DONTWAIT|MSG_TRUNC|MSG_CMSG_COMPAT))\n\t\tgoto out;\n\n\tskb = skb_recv_datagram(sk, flags, flags & MSG_DONTWAIT, &err);\n\tif (skb == NULL)\n\t\tgoto out;\n\n\tcopied = skb->len;\n\tif (copied > len) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\n\tskb_reset_transport_header(skb);\n\terr = skb_copy_datagram_msg(skb, 0, msg, copied);\n\tif (err)\n\t\tgoto out_free;\n\n\tsock_recv_ts_and_drops(msg, sk, skb);\n\n\terr = (flags & MSG_TRUNC) ? skb->len : copied;\n\n\tif (pfk->dump.dump != NULL &&\n\t    3 * atomic_read(&sk->sk_rmem_alloc) <= sk->sk_rcvbuf)\n\t\tpfkey_do_dump(pfk);\n\nout_free:\n\tskb_free_datagram(sk, skb);\nout:\n\treturn err;\n}\n\nstatic const struct proto_ops pfkey_ops = {\n\t.family\t\t=\tPF_KEY,\n\t.owner\t\t=\tTHIS_MODULE,\n\t/* Operations that make no sense on pfkey sockets. */\n\t.bind\t\t=\tsock_no_bind,\n\t.connect\t=\tsock_no_connect,\n\t.socketpair\t=\tsock_no_socketpair,\n\t.accept\t\t=\tsock_no_accept,\n\t.getname\t=\tsock_no_getname,\n\t.ioctl\t\t=\tsock_no_ioctl,\n\t.listen\t\t=\tsock_no_listen,\n\t.shutdown\t=\tsock_no_shutdown,\n\t.mmap\t\t=\tsock_no_mmap,\n\t.sendpage\t=\tsock_no_sendpage,\n\n\t/* Now the operations that really occur. */\n\t.release\t=\tpfkey_release,\n\t.poll\t\t=\tdatagram_poll,\n\t.sendmsg\t=\tpfkey_sendmsg,\n\t.recvmsg\t=\tpfkey_recvmsg,\n};\n\nstatic const struct net_proto_family pfkey_family_ops = {\n\t.family\t=\tPF_KEY,\n\t.create\t=\tpfkey_create,\n\t.owner\t=\tTHIS_MODULE,\n};\n\n#ifdef CONFIG_PROC_FS\nstatic int pfkey_seq_show(struct seq_file *f, void *v)\n{\n\tstruct sock *s = sk_entry(v);\n\n\tif (v == SEQ_START_TOKEN)\n\t\tseq_printf(f ,\"sk       RefCnt Rmem   Wmem   User   Inode\\n\");\n\telse\n\t\tseq_printf(f, \"%pK %-6d %-6u %-6u %-6u %-6lu\\n\",\n\t\t\t       s,\n\t\t\t       refcount_read(&s->sk_refcnt),\n\t\t\t       sk_rmem_alloc_get(s),\n\t\t\t       sk_wmem_alloc_get(s),\n\t\t\t       from_kuid_munged(seq_user_ns(f), sock_i_uid(s)),\n\t\t\t       sock_i_ino(s)\n\t\t\t       );\n\treturn 0;\n}\n\nstatic void *pfkey_seq_start(struct seq_file *f, loff_t *ppos)\n\t__acquires(rcu)\n{\n\tstruct net *net = seq_file_net(f);\n\tstruct netns_pfkey *net_pfkey = net_generic(net, pfkey_net_id);\n\n\trcu_read_lock();\n\treturn seq_hlist_start_head_rcu(&net_pfkey->table, *ppos);\n}\n\nstatic void *pfkey_seq_next(struct seq_file *f, void *v, loff_t *ppos)\n{\n\tstruct net *net = seq_file_net(f);\n\tstruct netns_pfkey *net_pfkey = net_generic(net, pfkey_net_id);\n\n\treturn seq_hlist_next_rcu(v, &net_pfkey->table, ppos);\n}\n\nstatic void pfkey_seq_stop(struct seq_file *f, void *v)\n\t__releases(rcu)\n{\n\trcu_read_unlock();\n}\n\nstatic const struct seq_operations pfkey_seq_ops = {\n\t.start\t= pfkey_seq_start,\n\t.next\t= pfkey_seq_next,\n\t.stop\t= pfkey_seq_stop,\n\t.show\t= pfkey_seq_show,\n};\n\nstatic int __net_init pfkey_init_proc(struct net *net)\n{\n\tstruct proc_dir_entry *e;\n\n\te = proc_create_net(\"pfkey\", 0, net->proc_net, &pfkey_seq_ops,\n\t\t\tsizeof(struct seq_net_private));\n\tif (e == NULL)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic void __net_exit pfkey_exit_proc(struct net *net)\n{\n\tremove_proc_entry(\"pfkey\", net->proc_net);\n}\n#else\nstatic inline int pfkey_init_proc(struct net *net)\n{\n\treturn 0;\n}\n\nstatic inline void pfkey_exit_proc(struct net *net)\n{\n}\n#endif\n\nstatic struct xfrm_mgr pfkeyv2_mgr =\n{\n\t.notify\t\t= pfkey_send_notify,\n\t.acquire\t= pfkey_send_acquire,\n\t.compile_policy\t= pfkey_compile_policy,\n\t.new_mapping\t= pfkey_send_new_mapping,\n\t.notify_policy\t= pfkey_send_policy_notify,\n\t.migrate\t= pfkey_send_migrate,\n\t.is_alive\t= pfkey_is_alive,\n};\n\nstatic int __net_init pfkey_net_init(struct net *net)\n{\n\tstruct netns_pfkey *net_pfkey = net_generic(net, pfkey_net_id);\n\tint rv;\n\n\tINIT_HLIST_HEAD(&net_pfkey->table);\n\tatomic_set(&net_pfkey->socks_nr, 0);\n\n\trv = pfkey_init_proc(net);\n\n\treturn rv;\n}\n\nstatic void __net_exit pfkey_net_exit(struct net *net)\n{\n\tstruct netns_pfkey *net_pfkey = net_generic(net, pfkey_net_id);\n\n\tpfkey_exit_proc(net);\n\tWARN_ON(!hlist_empty(&net_pfkey->table));\n}\n\nstatic struct pernet_operations pfkey_net_ops = {\n\t.init = pfkey_net_init,\n\t.exit = pfkey_net_exit,\n\t.id   = &pfkey_net_id,\n\t.size = sizeof(struct netns_pfkey),\n};\n\nstatic void __exit ipsec_pfkey_exit(void)\n{\n\txfrm_unregister_km(&pfkeyv2_mgr);\n\tsock_unregister(PF_KEY);\n\tunregister_pernet_subsys(&pfkey_net_ops);\n\tproto_unregister(&key_proto);\n}\n\nstatic int __init ipsec_pfkey_init(void)\n{\n\tint err = proto_register(&key_proto, 0);\n\n\tif (err != 0)\n\t\tgoto out;\n\n\terr = register_pernet_subsys(&pfkey_net_ops);\n\tif (err != 0)\n\t\tgoto out_unregister_key_proto;\n\terr = sock_register(&pfkey_family_ops);\n\tif (err != 0)\n\t\tgoto out_unregister_pernet;\n\terr = xfrm_register_km(&pfkeyv2_mgr);\n\tif (err != 0)\n\t\tgoto out_sock_unregister;\nout:\n\treturn err;\n\nout_sock_unregister:\n\tsock_unregister(PF_KEY);\nout_unregister_pernet:\n\tunregister_pernet_subsys(&pfkey_net_ops);\nout_unregister_key_proto:\n\tproto_unregister(&key_proto);\n\tgoto out;\n}\n\nmodule_init(ipsec_pfkey_init);\nmodule_exit(ipsec_pfkey_exit);\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_NETPROTO(PF_KEY);\n"], "filenames": ["net/key/af_key.c"], "buggy_code_start_loc": [1702], "buggy_code_end_loc": [1703], "fixing_code_start_loc": [1702], "fixing_code_end_loc": [1703], "type": "NVD-CWE-noinfo", "message": "A vulnerability was found in the pfkey_register function in net/key/af_key.c in the Linux kernel. This flaw allows a local, unprivileged user to gain access to kernel memory, leading to a system crash or a leak of internal kernel information.", "other": {"cve": {"id": "CVE-2022-1353", "sourceIdentifier": "secalert@redhat.com", "published": "2022-04-29T16:15:08.853", "lastModified": "2022-12-14T17:34:13.317", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability was found in the pfkey_register function in net/key/af_key.c in the Linux kernel. This flaw allows a local, unprivileged user to gain access to kernel memory, leading to a system crash or a leak of internal kernel information."}, {"lang": "es", "value": "Se encontr\u00f3 una vulnerabilidad en la funci\u00f3n pfkey_register en el archivo net/key/af_key.c en el kernel de Linux. Este fallo permite a un usuario local no privilegiado acceder a la memoria del kernel, conllevando a un bloqueo del sistema o un filtrado de informaci\u00f3n interna del kernel"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 3.6}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.17", "matchCriteriaId": "A37A8EE9-3F14-4C7A-A882-DA8A6AD1897C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:5.17:rc1:*:*:*:*:*:*", "matchCriteriaId": "7BD5F8D9-54FA-4CB0-B4F0-CB0471FDDB2D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:5.17:rc2:*:*:*:*:*:*", "matchCriteriaId": "E6E34B23-78B4-4516-9BD8-61B33F4AC49A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:5.17:rc3:*:*:*:*:*:*", "matchCriteriaId": "C030FA3D-03F4-4FB9-9DBF-D08E5CAC51AA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:5.17:rc4:*:*:*:*:*:*", "matchCriteriaId": "B2D2677C-5389-4AE9-869D-0F881E80D923"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:5.17:rc5:*:*:*:*:*:*", "matchCriteriaId": "EFA3917C-C322-4D92-912D-ECE45B2E7416"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:5.17:rc6:*:*:*:*:*:*", "matchCriteriaId": "BED18363-5ABC-4639-8BBA-68E771E5BB3F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:5.17:rc7:*:*:*:*:*:*", "matchCriteriaId": "7F635F96-FA0A-4769-ADE8-232B3AC9116D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:5.17:rc8:*:*:*:*:*:*", "matchCriteriaId": "FD39FE73-2A9D-4C92-AE7A-CA22F84B228D"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:11.0:*:*:*:*:*:*:*", "matchCriteriaId": "FA6FEEC2-9F11-4643-8827-749718254FED"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "F4CFF558-3C47-480D-A2F0-BABF26042943"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:baseboard_management_controller_h300s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "1746E116-3B82-4F65-B540-63D4058BD471"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:baseboard_management_controller_h300s:-:*:*:*:*:*:*:*", "matchCriteriaId": "04FD1F9A-8F43-4509-9A49-714C54C4783C"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:baseboard_management_controller_h500s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "BAFC49B0-FC63-4F06-A9DC-B853186003A9"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:baseboard_management_controller_h500s:-:*:*:*:*:*:*:*", "matchCriteriaId": "504201E4-04CD-4224-9264-C1AEAD480E36"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:baseboard_management_controller_h700s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "9BFAB819-0951-4D57-9B86-3CF590E50E7A"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:baseboard_management_controller_h700s:-:*:*:*:*:*:*:*", "matchCriteriaId": "BDDA0D1D-3A1E-4CF5-BD6A-F05AE4E8CDDA"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:baseboard_management_controller_h410s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "88A6EDE4-DD97-45A9-8366-E999525AA68F"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:baseboard_management_controller_h410s:-:*:*:*:*:*:*:*", "matchCriteriaId": "C2934495-6D4D-4C21-89E3-A2414ABDD5CE"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:baseboard_management_controller_h300e_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "806D1842-64F5-4F4C-B728-AFD0B99CE6EB"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:baseboard_management_controller_h300e:-:*:*:*:*:*:*:*", "matchCriteriaId": "266DDF39-2707-401F-88AF-3761D1045202"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:baseboard_management_controller_h500e_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "4ED4148B-73E9-48DA-BB54-F5A43B21FD56"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:baseboard_management_controller_h500e:-:*:*:*:*:*:*:*", "matchCriteriaId": "B09AB46C-8B35-4085-AD86-56EC06F665CB"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:baseboard_management_controller_h700e_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "46BB915A-F2AE-4041-89F1-03547F819DFF"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:baseboard_management_controller_h700e:-:*:*:*:*:*:*:*", "matchCriteriaId": "A33DCDCD-58EC-495A-BD5E-BB612F5B8A39"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:baseboard_management_controller_h410c_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "8665C148-3C9E-4EC9-A281-293D2352B8B9"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:baseboard_management_controller_h410c:-:*:*:*:*:*:*:*", "matchCriteriaId": "1A0CE664-32E5-4917-8319-7D2A31DCD72F"}]}]}], "references": [{"url": "https://bugzilla.redhat.com/show_bug.cgi?id=2066819", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/9a564bccb78a76740ea9d75a259942df8143d02c", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/07/msg00000.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20220629-0001/", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2022/dsa-5127", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2022/dsa-5173", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/9a564bccb78a76740ea9d75a259942df8143d02c"}}