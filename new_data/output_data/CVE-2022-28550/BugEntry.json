{"buggy_code": ["//--------------------------------------------------------------------------\n// Program to pull the information out of various types of EXIF digital\n// camera files and show it in a reasonably consistent way\n//\n// Version 3.06\n//\n// Compiling under Windows:\n//   Make sure you have Microsoft's compiler on the path, then run make.bat\n//\n// Dec 1999 - Oct 2020\n//\n// by Matthias Wandel   http://woodgears.ca\n//--------------------------------------------------------------------------\n#ifdef _WIN32\n    #include <io.h>\n#endif\n\n#include \"jhead.h\"\n\n#include <sys/stat.h>\n\n#define JHEAD_VERSION \"3.06\"\n\n// This #define turns on features that are too very specific to\n// how I organize my photos.  Best to ignore everything inside #ifdef MATTHIAS\n#define MATTHIAS\n\n\n// Bitmasks for DoModify:\n#define MODIFY_ANY  1\n#define READ_ANY    2\n#define JPEGS_ONLY  4\n#define MODIFY_JPEG 5\n#define READ_JPEG   6\nstatic int DoModify  = FALSE;\n\n\nstatic int FilesMatched;\nstatic int FileSequence;\n\nstatic const char * CurrentFile;\n\nstatic const char * progname;   // program name for error messages\n\n//--------------------------------------------------------------------------\n// Command line options flags\nstatic int TrimExif = FALSE;        // Cut off exif beyond interesting data.\nstatic int RenameToDate = 0;        // 1=rename, 2=rename all.\n#ifdef _WIN32\nstatic int RenameAssociatedFiles = FALSE;\n#endif\nstatic char * strftime_args = NULL; // Format for new file name.\nstatic int Exif2FileTime  = FALSE;\n       int ShowTags     = FALSE;    // Do not show raw by default.\nstatic int Quiet        = FALSE;    // Be quiet on success (like unix programs)\n       int DumpExifMap  = FALSE;\nstatic int ShowConcise  = FALSE;\nstatic int CreateExifSection = FALSE;\nstatic int TrimExifTrailingZeroes = FALSE;\nstatic char * ApplyCommand = NULL;  // Apply this command to all images.\nstatic char * FilterModel = NULL;\nstatic int    FilterQuality = 0;\nstatic int    ExifOnly    = FALSE;  // Only do images with exif header\nstatic int    ProcessOnly = -1;     // 0 for baseline, 2 for progressive only, -1 for all images.\nstatic int    PortraitOnly = FALSE; // Only do images with portrait orientation.\nstatic time_t ExifTimeAdjust = 0;   // Timezone adjust\nstatic time_t ExifTimeSet = 0;      // Set exif time to a value.\nstatic char DateSet[11];\nstatic unsigned DateSetChars = 0;\nstatic unsigned FileTimeToExif = FALSE;\n\nstatic int DeleteComments = FALSE;\nstatic int DeleteExif = FALSE;\nstatic int DeleteIptc = FALSE;\nstatic int DeleteXmp = FALSE;\nstatic int DeleteUnknown = FALSE;\nstatic char * ThumbSaveName = NULL; // If not NULL, use this string to make up\n                                    // the filename to store the thumbnail to.\n\nstatic char * ThumbInsertName = NULL; // If not NULL, use this string to make up\n                                    // the filename to retrieve the thumbnail from.\n\nstatic int RegenThumbnail = FALSE;\n\nstatic char * ExifXferScrFile = NULL;// Extract Exif header from this file, and\n                                    // put it into the Jpegs processed.\n\nstatic int EditComment = FALSE;     // Invoke an editor for editing the comment\nstatic int SuppressNonFatalErrors = FALSE; // Whether or not to pint warnings on recoverable errors\n\nstatic char * CommentSavefileName = NULL; // Save comment to this file.\nstatic char * CommentInsertfileName = NULL; // Insert comment from this file.\nstatic char * CommentInsertLiteral = NULL;  // Insert this comment (from command line)\n\nstatic int AutoRotate = FALSE;\nstatic int ZeroRotateTagOnly = FALSE;\n\nstatic int ShowFileInfo = TRUE;     // Indicates to show standard file info\n                                    // (file name, file size, file date)\n\n\n#ifdef MATTHIAS\n    // This #ifdef to take out less than elegant stuff for editing\n    // the comments in a JPEG.  The programs rdjpgcom and wrjpgcom\n    // included with Linux distributions do a better job.\n\n    static char * AddComment = NULL; // Add this tag.\n    static char * RemComment = NULL; // Remove this tag\n    static int AutoResize = FALSE;\n#endif // MATTHIAS\n\n//--------------------------------------------------------------------------\n// Error exit handler\n//--------------------------------------------------------------------------\nvoid ErrFatal(const char * msg)\n{\n    fprintf(stderr,\"\\nError : %s\\n\", msg);\n    if (CurrentFile) fprintf(stderr,\"in file '%s'\\n\",CurrentFile);\n    exit(EXIT_FAILURE);\n}\n\n//--------------------------------------------------------------------------\n// Report non fatal errors.  Now that microsoft.net modifies exif headers,\n// there's corrupted ones, and there could be more in the future.\n//--------------------------------------------------------------------------\nvoid ErrNonfatal(const char * msg, int a1, int a2)\n{\n    if (SuppressNonFatalErrors) return;\n\n    fprintf(stderr,\"\\nNonfatal Error : \");\n    if (CurrentFile) fprintf(stderr,\"'%s' \",CurrentFile);\n    fprintf(stderr, msg, a1, a2);\n    fprintf(stderr, \"\\n\");\n}\n\n\n//--------------------------------------------------------------------------\n// Invoke an editor for editing a string.\n//--------------------------------------------------------------------------\nstatic int FileEditComment(char * TempFileName, char * Comment, int CommentSize)\n{\n    FILE * file;\n    int a;\n    char QuotedPath[2*PATH_MAX+10];\n\n    file = fopen(TempFileName, \"w\");\n    if (file == NULL){\n        fprintf(stderr, \"Can't create file '%s'\\n\",TempFileName);\n        ErrFatal(\"could not create temporary file\");\n    }\n    fwrite(Comment, CommentSize, 1, file);\n\n    fclose(file);\n\n    fflush(stdout); // So logs are contiguous.\n\n    {\n        char * Editor;\n        Editor = getenv(\"EDITOR\");\n        if (Editor == NULL){\n#ifdef _WIN32\n            Editor = \"notepad\";\n#else\n            Editor = \"vi\";\n#endif\n        }\n        if (strlen(Editor) > PATH_MAX) ErrFatal(\"env too long\");\n\n        // Disallow characters in the editor or filename that could be used to execute arbitrary\n        // shell commands with system() below.\n        if (strpbrk(TempFileName, \"\\\";'&|`$\")) {\n            ErrFatal(\"Filename has invalid characters\");\n        }\n        if (strpbrk(Editor, \"\\\";'&|`$\")) {\n            ErrFatal(\"Editor has invalid characters\");\n        }\n\n        int num = snprintf(QuotedPath, sizeof(QuotedPath), \"%s \\\"%s\\\"\",Editor, TempFileName);\n        if(num > sizeof(QuotedPath)) {\n            ErrFatal(\"Quoted path to edit would be too long\");\n        }\n\n        a = system(QuotedPath);\n    }\n\n    if (a != 0){\n        perror(\"Editor failed to launch\");\n        exit(-1);\n    }\n\n    file = fopen(TempFileName, \"r\");\n    if (file == NULL){\n        ErrFatal(\"could not open temp file for read\");\n    }\n\n    // Read the file back in.\n    CommentSize = fread(Comment, 1, MAX_COMMENT_SIZE, file);\n\n    fclose(file);\n\n    unlink(TempFileName);\n\n    return CommentSize;\n}\n\n#ifdef MATTHIAS\n//--------------------------------------------------------------------------\n// Modify one of the lines in the comment field.\n// This very specific to the photo album program stuff.\n//--------------------------------------------------------------------------\nstatic char KnownTags[][10] = {\"date\", \"desc\",\"scan_date\",\"author\",\n                               \"keyword\",\"videograb\",\n                               \"show_raw\",\"panorama\",\"titlepix\",\"\"};\n\nstatic int ModifyDescriptComment(char * OutComment, char * SrcComment)\n{\n    char Line[500];\n    int Len;\n    int a,i;\n    unsigned l;\n    int HasScandate = FALSE;\n    int TagExists = FALSE;\n    int Modified = FALSE;\n    Len = 0;\n\n    OutComment[0] = 0;\n\n\n    for (i=0;;i++){\n        if (SrcComment[i] == '\\r' || SrcComment[i] == '\\n' || SrcComment[i] == 0 || Len >= 199){\n            // Process the line.\n            if (Len > 0){\n                Line[Len] = 0;\n                //printf(\"Line: '%s'\\n\",Line);\n                for (a=0;;a++){\n                    l = strlen(KnownTags[a]);\n                    if (!l){\n                        // Unknown tag.  Discard it.\n                        printf(\"Error: Unknown tag '%s'\\n\", Line); // Deletes the tag.\n                        Modified = TRUE;\n                        break;\n                    }\n                    if (memcmp(Line, KnownTags[a], l) == 0){\n                        if (Line[l] == ' ' || Line[l] == '=' || Line[l] == 0){\n                            // Its a good tag.\n                            if (Line[l] == ' ') Line[l] = '='; // Use equal sign for clarity.\n                            if (a == 2) break; // Delete 'orig_path' tag.\n                            if (a == 3) HasScandate = TRUE;\n                            if (RemComment){\n                                if (strlen(RemComment) == l){\n                                    if (!memcmp(Line, RemComment, l)){\n                                        Modified = TRUE;\n                                        break;\n                                    }\n                                }\n                            }\n                            if (AddComment){\n                                // Overwrite old comment of same tag with new one.\n                                if (!memcmp(Line, AddComment, l+1)){\n                                    TagExists = TRUE;\n                                    strncpy(Line, AddComment, sizeof(Line));\n                                    Line[sizeof(Line)-1]='\\0';\n                                    Modified = TRUE;\n                                }\n                            }\n                            strncat(OutComment, Line, MAX_COMMENT_SIZE-5-strlen(OutComment));\n                            strcat(OutComment, \"\\n\");\n                            break;\n                        }\n                    }\n                }\n            }\n            Line[Len = 0] = 0;\n            if (SrcComment[i] == 0) break;\n        }else{\n            Line[Len++] = SrcComment[i];\n        }\n    }\n\n    if (AddComment && TagExists == FALSE){\n        strncat(OutComment, AddComment, MAX_COMMENT_SIZE-5-strlen(OutComment));\n        strcat(OutComment, \"\\n\");\n        Modified = TRUE;\n    }\n\n    if (!HasScandate && !ImageInfo.DateTime[0]){\n        // Scan date is not in the file yet, and it doesn't have one built in.  Add it.\n        char Temp[40];\n        sprintf(Temp, \"scan_date=%s\", ctime(&ImageInfo.FileDateTime));\n        strncat(OutComment, Temp, MAX_COMMENT_SIZE-5-strlen(OutComment));\n        Modified = TRUE;\n    }\n    return Modified;\n}\n//--------------------------------------------------------------------------\n// Automatic make smaller command stuff\n//--------------------------------------------------------------------------\nstatic int AutoResizeCmdStuff(void)\n{\n    static char CommandString[PATH_MAX+1];\n    double scale;\n    float TargetSize = 1800;\n\n    ApplyCommand = CommandString;\n\n    scale = TargetSize / ImageInfo.Width;\n    if (scale > TargetSize / ImageInfo.Height) scale = TargetSize / ImageInfo.Height;\n\n    if (scale > 0.8){\n        if (ImageInfo.QualityGuess >= 93){\n            // Re-compress at lower quality.\n            sprintf(CommandString, \"mogrify -quality 86 &i\");\n            return TRUE;\n        }\n        printf(\"not resizing %dx%x '%s'\\n\",ImageInfo.Height, ImageInfo.Width, ImageInfo.FileName);\n        return FALSE;\n    }\n\n    if (scale < 0.4) scale = 0.4; // Don't scale down by too much.\n\n    sprintf(CommandString, \"mogrify -geometry %dx%d -quality 85 &i\",(int)(ImageInfo.Width*scale+0.5),\n                                    (int)(ImageInfo.Height*scale+0.5));\n    return TRUE;\n}\n\n\n#endif // MATTHIAS\n\n\n//--------------------------------------------------------------------------\n// Escape an argument such that it is interpreted literally by the shell\n// (returns the number of written characters)\n//--------------------------------------------------------------------------\nstatic int shellescape(char* to, const char* from)\n{\n    int i, j;\n    i = j = 0;\n\n    // Enclosing characters in double quotes preserves the literal value of\n    // all characters within the quotes, with the exception of $, `, and \\.\n    to[j++] = '\"';\n    while(from[i])\n    {\n#ifdef _WIN32\n        // Under WIN32, there isn't really anything dangerous you can do with\n        // escape characters, plus windows users aren't as security paranoid.\n        // Hence, no need to do fancy escaping.\n        to[j++] = from[i++];\n#else\n        switch(from[i]) {\n            case '\"':\n            case '$':\n            case '`':\n            case '\\\\':\n                to[j++] = '\\\\';\n                // Fallthru...\n            default:\n                to[j++] = from[i++];\n        }\n#endif\n        if (j >= PATH_MAX) ErrFatal(\"max path exceeded\");\n    }\n    to[j++] = '\"';\n    return j;\n}\n\n\n//--------------------------------------------------------------------------\n// Apply the specified command to the JPEG file.\n//--------------------------------------------------------------------------\nstatic void DoCommand(const char * FileName, int ShowIt)\n{\n    int a,e;\n    char ExecString[PATH_MAX*3];\n    char TempName[PATH_MAX+10];\n    int TempUsed = FALSE;\n\n    e = 0;\n\n    // Generate an unused temporary file name in the destination directory\n    // (a is the number of characters to copy from FileName)\n    a = strlen(FileName)-1;\n    while(a > 0 && FileName[a-1] != SLASH) a--;\n    memcpy(TempName, FileName, a);\n    strcpy(TempName+a, \"XXXXXX\");\n\n    // Note: Compiler will warn about mkstemp.  but I need a filename, not a file.\n    // I could just then get the file name from what mkstemp made, and pass that\n    // to the executable, but that would make for the exact same vulnerability\n    // as mktemp - that is, that between getting the random name, and making the file\n    // some other program could snatch that exact same name!\n    // also, not all platforms support mkstemp.\n    mktemp(TempName);\n\n\n    if(!TempName[0]) {\n        ErrFatal(\"Cannot find available temporary file name\");\n    }\n\n\n    // Build the exec string.  &i and &o in the exec string get replaced by input and output files.\n    for (a=0;;a++){\n        if (ApplyCommand[a] == '&'){\n            if (ApplyCommand[a+1] == 'i'){\n                // Input file.\n                e += shellescape(ExecString+e, FileName);\n                a += 1;\n                continue;\n            }\n            if (ApplyCommand[a+1] == 'o'){\n                // Needs an output file distinct from the input file.\n                e += shellescape(ExecString+e, TempName);\n                a += 1;\n                TempUsed = TRUE;\n                continue;\n            }\n        }\n        ExecString[e++] = ApplyCommand[a];\n        if (ApplyCommand[a] == 0) break;\n    }\n\n    if (ShowIt) printf(\"Cmd:%s\\n\",ExecString);\n\n    errno = 0;\n    a = system(ExecString);\n\n    if (a || errno){\n        // A command can however fail without errno getting set or system returning an error.\n        if (errno) perror(\"system\");\n        ErrFatal(\"Problem executing specified command\");\n    }\n\n    if (TempUsed){\n        // Don't delete original file until we know a new one was created by the command.\n        struct stat dummy;\n        if (stat(TempName, &dummy) == 0){\n            struct stat buf;\n            int stat_result = stat(FileName, &buf);\n\n            unlink(FileName);\n            rename(TempName, FileName);\n            if (stat_result == 0){\n                // set Unix access rights and time to new file\n                struct utimbuf mtime;\n                chmod(FileName, buf.st_mode);\n\n                mtime.actime = buf.st_atime;\n                mtime.modtime = buf.st_mtime;\n\n                utime(FileName, &mtime);\n            }\n        }else{\n            ErrFatal(\"specified command did not produce expected output file\");\n        }\n    }\n}\n\n//--------------------------------------------------------------------------\n// check if this file should be skipped based on contents.\n//--------------------------------------------------------------------------\nstatic int CheckFileSkip(void)\n{\n    // I sometimes add code here to only process images based on certain\n    // criteria - for example, only to convert non progressive Jpegs to progressives, etc..\n    if(ProcessOnly >= 0 && (ImageInfo.Process & 0x0f) != ProcessOnly){\n        // ProcessOnly == 0 means skip baseline oencoded jpegs\n        // ProcessOnly == 2 means skip progressive oencoded jpegs\n        return TRUE;\n    }\n\n    if (FilterModel){\n        // Filtering processing by camera model.\n        // This feature is useful when pictures from multiple cameras are collated,\n        // the its found that one of the cameras has the time set incorrectly.\n        if (strstr(ImageInfo.CameraModel, FilterModel) == NULL){\n            // Skip.\n            return TRUE;\n        }\n    }\n    if (FilterQuality > 0){\n        //Filter by above threshold quality\n        if (ImageInfo.QualityGuess < FilterQuality){\n            return TRUE;\n        }\n    }\n\n    if (ExifOnly){\n        // Filtering by EXIF only.  Skip all files that have no Exif.\n        if (FindSection(M_EXIF) == NULL){\n            return TRUE;\n        }\n    }\n\n    if (PortraitOnly == 1){\n        if (ImageInfo.Width > ImageInfo.Height) return TRUE;\n    }\n\n    if (PortraitOnly == -1){\n        if (ImageInfo.Width < ImageInfo.Height) return TRUE;\n    }\n\n    return FALSE;\n}\n\n//--------------------------------------------------------------------------\n// Substitute original name for '&i' if present in specified name.\n// This to allow specifying relative names when manipulating multiple files.\n//--------------------------------------------------------------------------\nstatic void RelativeName(char * OutFileName, const char * NamePattern, const char * OrigName)\n{\n    // If the filename contains substring \"&i\", then substitute the\n    // filename for that.  This gives flexibility in terms of processing\n    // multiple files at a time.\n    char * Subst;\n    Subst = strstr(NamePattern, \"&i\");\n    if (Subst > NamePattern+PATH_MAX-10){\n        ErrFatal(\"Bad file name pattern\");\n    }\n\n    if (Subst){\n        strncpy(OutFileName, NamePattern, Subst-NamePattern);\n        OutFileName[Subst-NamePattern] = 0;\n        strncat(OutFileName, OrigName, PATH_MAX-1-strlen(OutFileName));\n        strncat(OutFileName, Subst+2, PATH_MAX-1-strlen(OutFileName));\n    }else{\n        strncpy(OutFileName, NamePattern, PATH_MAX);\n    }\n}\n\n\n#ifdef _WIN32\n//--------------------------------------------------------------------------\n// Rename associated files\n//--------------------------------------------------------------------------\nvoid RenameAssociated(const char * FileName, char * NewBaseName)\n{\n    int a;\n    int PathLen;\n    int ExtPos;\n    char FilePattern[_MAX_PATH+1];\n    char NewName[_MAX_PATH+1];\n    struct _finddata_t finddata;\n    long find_handle;\n\n    for(ExtPos = strlen(FileName);FileName[ExtPos-1] != '.';){\n        if (--ExtPos == 0) return; // No extension!\n    }\n\n    memcpy(FilePattern, FileName, ExtPos);\n    FilePattern[ExtPos] = '*';\n    FilePattern[ExtPos+1] = '\\0';\n\n    for(PathLen = strlen(FileName);FileName[PathLen-1] != SLASH;){\n        if (--PathLen == 0) break;\n    }\n\n    find_handle = _findfirst(FilePattern, &finddata);\n\n    for (;;){\n        if (find_handle == -1) break;\n\n        // Eliminate the obvious patterns.\n        if (!memcmp(finddata.name, \".\",2)) goto next_file;\n        if (!memcmp(finddata.name, \"..\",3)) goto next_file;\n        if (finddata.attrib & _A_SUBDIR) goto next_file;\n\n        strncpy(FilePattern+PathLen, finddata.name, PATH_MAX-PathLen); // full name with path\n\n        strcpy(NewName, NewBaseName);\n        for(a = strlen(finddata.name);finddata.name[a] != '.';){\n            if (--a == 0) goto next_file;\n        }\n        strncat(NewName, finddata.name+a, _MAX_PATH-strlen(NewName)); // add extension to new name\n\n        if (rename(FilePattern, NewName) == 0){\n            if (!Quiet){\n                printf(\"%s --> %s\\n\",FilePattern, NewName);\n            }\n        }\n\n        next_file:\n        if (_findnext(find_handle, &finddata) != 0) break;\n    }\n    _findclose(find_handle);\n}\n#endif\n\n//--------------------------------------------------------------------------\n// Handle renaming of files by date.\n//--------------------------------------------------------------------------\nstatic void DoFileRenaming(const char * FileName)\n{\n    int PrefixPart = 0; // Where the actual filename starts.\n    int ExtensionPart;  // Where the file extension starts.\n    int a;\n    struct tm tm;\n    char NewBaseName[PATH_MAX*2];\n    int AddLetter = 0;\n    char NewName[PATH_MAX+2];\n\n    ExtensionPart = strlen(FileName);\n    for (a=0;FileName[a];a++){\n        if (FileName[a] == SLASH){\n            // Don't count path component.\n            PrefixPart = a+1;\n        }\n\n        if (FileName[a] == '.') ExtensionPart = a;  // Remember where extension starts.\n    }\n    if (ExtensionPart < PrefixPart) { // no extension found\n        ExtensionPart = strlen(FileName);\n    }\n\n    if (!Exif2tm(&tm, ImageInfo.DateTime)){\n        printf(\"File '%s' contains no exif date stamp.  Using file date\\n\",FileName);\n        // Use file date/time instead.\n        tm = *localtime(&ImageInfo.FileDateTime);\n    }\n\n\n    strncpy(NewBaseName, FileName, PATH_MAX); // Get path component of name.\n\n    if (strftime_args){\n        // Complicated scheme for flexibility.  Just pass the args to strftime.\n        time_t UnixTime;\n\n        char *s;\n        char pattern[PATH_MAX+20];\n        int n = ExtensionPart - PrefixPart;\n\n        // Call mktime to get weekday and such filled in.\n        UnixTime = mktime(&tm);\n        if ((int)UnixTime == -1){\n            printf(\"Could not convert %s to unix time\",ImageInfo.DateTime);\n            return;\n        }\n\n        // Substitute \"%f\" for the original name (minus path & extension)\n        pattern[PATH_MAX-1]=0;\n        strncpy(pattern, strftime_args, PATH_MAX-1);\n        while ((s = strstr(pattern, \"%f\")) && strlen(pattern) + n < PATH_MAX-1){\n            memmove(s + n, s + 2, strlen(s+2) + 1);\n            memmove(s, FileName + PrefixPart, n);\n        }\n\n        {\n            // Sequential number renaming part.\n            // '%i' type pattern becomes sequence number.\n            int ppos = -1;\n            for (a=0;pattern[a];a++){\n                if (pattern[a] == '%'){\n                     ppos = a;\n                }else if (pattern[a] == 'i'){\n                    if (ppos >= 0 && a<ppos+4){\n                        // Replace this part with a number.\n                        char pat[8], num[16];\n                        int l,nl;\n                        memcpy(pat, pattern+ppos, 4);\n                        pat[a-ppos] = 'd'; // Replace 'i' with 'd' for '%d'\n                        pat[a-ppos+1] = '\\0';\n                        sprintf(num, pat, FileSequence); // let printf do the number formatting.\n                        nl = strlen(num);\n                        l = strlen(pattern+a+1);\n                        if (ppos+nl+l+1 >= PATH_MAX) ErrFatal(\"str overflow\");\n                        memmove(pattern+ppos+nl, pattern+a+1, l+1);\n                        memcpy(pattern+ppos, num, nl);\n                        break;\n                    }\n                }else if (!isdigit(pattern[a])){\n                    ppos = -1;\n                }\n            }\n        }\n        strftime(NewName, PATH_MAX, pattern, &tm);\n    }else{\n        // My favourite scheme.\n        sprintf(NewName, \"%02d%02d-%02d%02d%02d\",\n             tm.tm_mon+1, tm.tm_mday, tm.tm_hour, tm.tm_min, tm.tm_sec);\n    }\n\n    NewBaseName[PrefixPart] = 0;\n    CatPath(NewBaseName, NewName);\n\n    AddLetter = isdigit(NewBaseName[strlen(NewBaseName)-1]);\n    for (a=0;;a++){\n        char NewName[PATH_MAX*2+10];\n        char NameExtra[3];\n        struct stat dummy;\n\n        if (a){\n            // Generate a suffix for the file name if previous choice of names is taken.\n            // depending on whether the name ends in a letter or digit, pick the opposite to separate\n            // it.  This to avoid using a separator character - this because any good separator\n            // is before the '.' in ascii, and so sorting the names would put the later name before\n            // the name without suffix, causing the pictures to more likely be out of order.\n            if (AddLetter){\n                NameExtra[0] = (char)('a'-1+a); // Try a,b,c,d... for suffix if it ends in a number.\n            }else{\n                NameExtra[0] = (char)('0'-1+a); // Try 0,1,2,3... for suffix if it ends in a latter.\n            }\n            NameExtra[1] = 0;\n        }else{\n            NameExtra[0] = 0;\n        }\n\n        snprintf(NewName, sizeof(NewName), \"%s%s.jpg\", NewBaseName, NameExtra);\n\n        if (!strcmp(FileName, NewName)) break; // Skip if its already this name.\n\n        if (!EnsurePathExists(NewBaseName)){\n            break;\n        }\n\n\n        if (stat(NewName, &dummy)){\n            // This name does not pre-exist.\n            if (rename(FileName, NewName) == 0){\n                printf(\"%s --> %s\\n\",FileName, NewName);\n#ifdef _WIN32\n                if (RenameAssociatedFiles){\n                    sprintf(NewName, \"%s%s\", NewBaseName, NameExtra);\n                    RenameAssociated(FileName, NewName);\n                }\n#endif\n            }else{\n                printf(\"Error: Couldn't rename '%s' to '%s'\\n\",FileName, NewName);\n            }\n            break;\n\n        }\n\n        if (a > 25 || (!AddLetter && a > 9)){\n            printf(\"Possible new names for for '%s' already exist\\n\",FileName);\n            break;\n        }\n    }\n}\n\n//--------------------------------------------------------------------------\n// Rotate the image and its thumbnail\n//--------------------------------------------------------------------------\nstatic int DoAutoRotate(const char * FileName)\n{\n    if (ImageInfo.Orientation != 1){\n        const char * Argument;\n        Argument = ClearOrientation();\n        if (Argument == NULL) return FALSE; // orientation tag in image, nothing changed.\n\n        if (!ZeroRotateTagOnly){\n            char RotateCommand[PATH_MAX*2+50];\n            if (strlen(Argument) == 0){\n                // Unknown orientation, but still modified.\n                return TRUE; // Image is still modified.\n            }\n            sprintf(RotateCommand, \"jpegtran -trim -%s -outfile &o &i\", Argument);\n            ApplyCommand = RotateCommand;\n            DoCommand(FileName, FALSE);\n            ApplyCommand = NULL;\n\n            // Now rotate the thumbnail, if there is one.\n            if (ImageInfo.ThumbnailOffset &&\n                ImageInfo.ThumbnailSize &&\n                ImageInfo.ThumbnailAtEnd){\n                // Must have a thumbnail that exists and is modifiable.\n\n                char ThumbTempName_in[PATH_MAX+5];\n                char ThumbTempName_out[PATH_MAX+5];\n\n                strcpy(ThumbTempName_in, FileName);\n                strcat(ThumbTempName_in, \".thi\");\n                strcpy(ThumbTempName_out, FileName);\n                strcat(ThumbTempName_out, \".tho\");\n                SaveThumbnail(ThumbTempName_in);\n                sprintf(RotateCommand,\"jpegtran -trim -%s -outfile \\\"%s\\\" \\\"%s\\\"\",\n                    Argument, ThumbTempName_out, ThumbTempName_in);\n\n                // Disallow characters in the filenames that could be used to execute arbitrary\n                // shell commands with system() below.\n                if (strpbrk(FileName, \"\\\";'&|`$\")) {\n                    ErrNonfatal(\"Command has invalid characters.\", 0, 0);\n                    unlink(ThumbTempName_in);\n                    return FALSE;\n                }\n\n                if (system(RotateCommand) == 0){\n                    // Put the thumbnail back in the header\n                    ReplaceThumbnail(ThumbTempName_out);\n                }\n\n                unlink(ThumbTempName_in);\n                unlink(ThumbTempName_out);\n            }\n        }\n        return TRUE;\n    }\n    return FALSE;\n}\n\n//--------------------------------------------------------------------------\n// Regenerate the thumbnail using mogrify\n//--------------------------------------------------------------------------\nstatic int RegenerateThumbnail(const char * FileName)\n{\n    char ThumbnailGenCommand[PATH_MAX*2+50];\n    if (ImageInfo.ThumbnailOffset == 0 || ImageInfo.ThumbnailAtEnd == FALSE){\n        // There is no thumbnail, or the thumbnail is not at the end.\n        return FALSE;\n    }\n\n    // Disallow characters in the filename that could be used to execute arbitrary\n    // shell commands with system() below.\n    if(strpbrk(FileName, \"\\\";'&|`$\")) {\n        ErrNonfatal(\"Filename has invalid characters.\", 0, 0);\n        return FALSE;\n    }\n\n    snprintf(ThumbnailGenCommand, sizeof(ThumbnailGenCommand),\n        \"mogrify -thumbnail %dx%d -quality 80 \\\"%s\\\"\",\n        RegenThumbnail, RegenThumbnail, FileName);\n\n    if (system(ThumbnailGenCommand) == 0){\n        // Put the thumbnail back in the header\n        return ReplaceThumbnail(FileName);\n    }else{\n        ErrFatal(\"Unable to run 'mogrify' command\");\n        return FALSE;\n    }\n}\n\n//--------------------------------------------------------------------------\n// Set file time as exif time.\n//--------------------------------------------------------------------------\nvoid FileTimeAsString(char * TimeStr)\n{\n    struct tm ts;\n    ts = *localtime(&ImageInfo.FileDateTime);\n    strftime(TimeStr, 20, \"%Y:%m:%d %H:%M:%S\", &ts);\n}\n\n//--------------------------------------------------------------------------\n// Do selected operations to one file at a time.\n//--------------------------------------------------------------------------\nstatic void ProcessFile(const char * FileName)\n{\n    int Modified = FALSE;\n    ReadMode_t ReadMode;\n\n    if (strlen(FileName) >= PATH_MAX-1){\n        // Protect against buffer overruns in strcpy / strcat's on filename\n        ErrFatal(\"filename too long\");\n    }\n\n    ReadMode = READ_METADATA;\n    CurrentFile = FileName;\n    FilesMatched = 1;\n\n    ResetJpgfile();\n    Clear_EXIF();\n\n    // Start with an empty image information structure.\n    memset(&ImageInfo, 0, sizeof(ImageInfo));\n    ImageInfo.FlashUsed = -1;\n    ImageInfo.MeteringMode = -1;\n    ImageInfo.Whitebalance = -1;\n\n    // Store file date/time.\n    {\n        struct stat st;\n        if (stat(FileName, &st) >= 0){\n            ImageInfo.FileDateTime = st.st_mtime;\n            ImageInfo.FileSize = st.st_size;\n        }else{\n            ErrFatal(\"No such file\");\n        }\n    }\n\n    if ((DoModify & MODIFY_ANY) || RenameToDate || Exif2FileTime){\n        if (access(FileName, 2 /*W_OK*/)){\n            printf(\"Skipping readonly file '%s'\\n\",FileName);\n            return;\n        }\n    }\n\n    strncpy(ImageInfo.FileName, FileName, PATH_MAX);\n\n\n    if (ApplyCommand || AutoRotate){\n        // Applying a command is special - the headers from the file have to be\n        // pre-read, then the command executed, and then the image part of the file read.\n\n        if (!ReadJpegFile(FileName, READ_METADATA)) return;\n\n        #ifdef MATTHIAS\n            if (AutoResize){\n                // Automatic resize computation - to customize for each run...\n                if (AutoResizeCmdStuff() == 0){\n                    DiscardData();\n                    return;\n                }\n            }\n        #endif // MATTHIAS\n\n\n        if (CheckFileSkip()){\n            DiscardData();\n            return;\n        }\n\n        DiscardAllButExif();\n\n        if (AutoRotate){\n            if (DoAutoRotate(FileName)){\n                Modified = TRUE;\n            }\n        }else{\n            struct stat dummy;\n            DoCommand(FileName, Quiet ? FALSE : TRUE);\n\n            if (stat(FileName, &dummy)){\n                // The file is not there anymore. Perhaps the command\n                // was a delete or a move.  So we are all done.\n                return;\n            }\n            Modified = TRUE;\n        }\n        ReadMode = READ_IMAGE;   // Don't re-read exif section again on next read.\n    }\n\n    if (ExifXferScrFile){\n        char RelativeExifName[PATH_MAX+1];\n        // Make a relative name.\n        RelativeName(RelativeExifName, ExifXferScrFile, FileName);\n        if(!ReadJpegFile(RelativeExifName, READ_METADATA)) return;\n\n        DiscardAllButExif();    // Don't re-read exif section again on next read.\n\n        Modified = TRUE;\n        ReadMode = READ_IMAGE;\n    }\n\n    if (DoModify){\n        ReadMode |= READ_IMAGE;\n    }\n\n    if (!ReadJpegFile(FileName, ReadMode)) return;\n\n    if (CheckFileSkip()){\n        DiscardData();\n        return;\n    }\n\n    if (TrimExifTrailingZeroes){\n        if (ImageInfo.ThumbnailAtEnd){\n            Section_t * ExifSection;\n            int NumRedundant, WasRedundant;\n            unsigned char * StartRedundant;\n            //printf(\"Exif: Thumbnail %d - %d\\n\",ImageInfo.ThumbnailOffset, ImageInfo.ThumbnailOffset+ImageInfo.ThumbnailSize);\n            ExifSection = FindSection(M_EXIF);\n\n            StartRedundant = ExifSection->Data + 8 + ImageInfo.ThumbnailOffset+ImageInfo.ThumbnailSize;\n            WasRedundant = NumRedundant = (ExifSection->Size) - (ImageInfo.ThumbnailOffset + ImageInfo.ThumbnailSize + 8);\n\n            //printf(\"Exif length: %d  Wasted: %d\\n\",ExifSection->Size, NumRedundant);\n\n            for(;NumRedundant > 0 && StartRedundant[NumRedundant-1] == 0;NumRedundant--);// Only remove trailing bytes if they are zero.\n\n            if (NumRedundant != WasRedundant){\n                int NewExifSize;\n                printf(\"Trimming %d bytes from exif in %s\\n\", WasRedundant-NumRedundant, FileName);\n                NewExifSize = ImageInfo.ThumbnailOffset + ImageInfo.ThumbnailSize + 8 + NumRedundant;\n                ExifSection->Data[0] = (uchar)(NewExifSize >> 8); // Must write new length into exif data.\n                ExifSection->Data[1] = (uchar)NewExifSize;\n                ExifSection->Size = NewExifSize;\n                Modified = TRUE;\n            }else{\n                //printf(\"Noting to remove from %s\\n\", FileName);\n            }\n        }\n    }\n\n    FileSequence += 1; // Count files processed.\n\n    if (ShowConcise){\n        ShowConciseImageInfo();\n    }else{\n        if (!(DoModify) || ShowTags){\n            ShowImageInfo(ShowFileInfo);\n\n            {\n                // if IPTC section is present, show it also.\n                Section_t * IptcSection;\n                IptcSection = FindSection(M_IPTC);\n\n                if (IptcSection){\n                    show_IPTC(IptcSection->Data, IptcSection->Size);\n                }\n            }\n            printf(\"\\n\");\n        }\n    }\n\n    if (ThumbSaveName){\n        char OutFileName[PATH_MAX+1];\n        // Make a relative name.\n        RelativeName(OutFileName, ThumbSaveName, FileName);\n\n        if (SaveThumbnail(OutFileName)){\n            printf(\"Created: '%s'\\n\", OutFileName);\n        }\n    }\n\n    if (CreateExifSection){\n        // Make a new minimal exif section\n        create_EXIF();\n        Modified = TRUE;\n    }\n\n    if (RegenThumbnail){\n        if (RegenerateThumbnail(FileName)){\n            Modified = TRUE;\n        }\n    }\n\n    if (ThumbInsertName){\n        char ThumbFileName[PATH_MAX+1];\n        // Make a relative name.\n        RelativeName(ThumbFileName, ThumbInsertName, FileName);\n\n        if (ReplaceThumbnail(ThumbFileName)){\n            Modified = TRUE;\n        }\n    }else if (TrimExif){\n        // Deleting thumbnail is just replacing it with a null thumbnail.\n        if (ReplaceThumbnail(NULL)){\n            Modified = TRUE;\n        }\n    }\n\n    if (\n#ifdef MATTHIAS\n        AddComment || RemComment ||\n#endif\n                   EditComment || CommentInsertfileName || CommentInsertLiteral){\n\n        Section_t * CommentSec;\n        char Comment[MAX_COMMENT_SIZE+1];\n        int CommentSize;\n\n        CommentSec = FindSection(M_COM);\n\n        if (CommentSec == NULL){\n            unsigned char * DummyData;\n\n            DummyData = (uchar *) malloc(3);\n            DummyData[0] = 0;\n            DummyData[1] = 2;\n            DummyData[2] = 0;\n            CommentSec = CreateSection(M_COM, DummyData, 2);\n        }\n\n        CommentSize = CommentSec->Size-2;\n        if (CommentSize > MAX_COMMENT_SIZE){\n            fprintf(stderr, \"Truncating comment at %d chars\\n\",MAX_COMMENT_SIZE);\n            CommentSize = MAX_COMMENT_SIZE;\n        }\n\n        if (CommentInsertfileName){\n            // Read a new comment section from file.\n            char CommentFileName[PATH_MAX+1];\n            FILE * CommentFile;\n\n            // Make a relative name.\n            RelativeName(CommentFileName, CommentInsertfileName, FileName);\n\n            CommentFile = fopen(CommentFileName,\"r\");\n            if (CommentFile == NULL){\n                printf(\"Could not open '%s'\\n\",CommentFileName);\n            }else{\n                // Read it in.\n                // Replace the section.\n                CommentSize = fread(Comment, 1, MAX_COMMENT_SIZE, CommentFile);\n                fclose(CommentFile);\n                if (CommentSize < 0) CommentSize = 0;\n            }\n        }else if (CommentInsertLiteral){\n            strncpy(Comment, CommentInsertLiteral, MAX_COMMENT_SIZE);\n            CommentSize = strlen(Comment);\n        }else{\n#ifdef MATTHIAS\n            char CommentZt[MAX_COMMENT_SIZE+1];\n            memcpy(CommentZt, (char *)CommentSec->Data+2, CommentSize);\n            CommentZt[CommentSize] = '\\0';\n            if (ModifyDescriptComment(Comment, CommentZt)){\n                Modified = TRUE;\n                CommentSize = strlen(Comment);\n            }\n            if (EditComment)\n#else\n            memcpy(Comment, (char *)CommentSec->Data+2, CommentSize);\n#endif\n            {\n                char EditFileName[PATH_MAX+5];\n                strcpy(EditFileName, FileName);\n                strcat(EditFileName, \".txt\");\n\n                CommentSize = FileEditComment(EditFileName, Comment, CommentSize);\n            }\n        }\n\n        if (strcmp(Comment, (char *)CommentSec->Data+2)){\n            // Discard old comment section and put a new one in.\n            int size;\n            size = CommentSize+2;\n            free(CommentSec->Data);\n            CommentSec->Size = size;\n            CommentSec->Data = malloc(size);\n            CommentSec->Data[0] = (uchar)(size >> 8);\n            CommentSec->Data[1] = (uchar)(size);\n            memcpy((CommentSec->Data)+2, Comment, size-2);\n            Modified = TRUE;\n        }\n        if (!Modified){\n            printf(\"Comment not modified\\n\");\n        }\n    }\n\n\n    if (CommentSavefileName){\n        Section_t * CommentSec;\n        CommentSec = FindSection(M_COM);\n\n        if (CommentSec != NULL){\n            char OutFileName[PATH_MAX+1];\n            FILE * CommentFile;\n\n            // Make a relative name.\n            RelativeName(OutFileName, CommentSavefileName, FileName);\n\n            CommentFile = fopen(OutFileName,\"w\");\n            if (CommentFile){\n                fwrite((char *)CommentSec->Data+2 ,CommentSec->Size-2, 1, CommentFile);\n                fclose(CommentFile);\n            }else{\n                ErrFatal(\"Could not write comment file\");\n            }\n        }else{\n            printf(\"File '%s' contains no comment section\\n\",FileName);\n        }\n    }\n\n    if (ExifTimeAdjust || ExifTimeSet || DateSetChars || FileTimeToExif){\n       if (ImageInfo.numDateTimeTags){\n            struct tm tm;\n            time_t UnixTime;\n            char TempBuf[50];\n            int a;\n            Section_t * ExifSection;\n            if (ExifTimeSet){\n                // A time to set was specified.\n                UnixTime = ExifTimeSet;\n            }else{\n                if (FileTimeToExif){\n                    FileTimeAsString(ImageInfo.DateTime);\n                }\n                if (DateSetChars){\n                    memcpy(ImageInfo.DateTime, DateSet, DateSetChars);\n                    a = 1970;\n                    sscanf(DateSet, \"%d\", &a);\n                    if (a < 1970){\n                        strcpy(TempBuf, ImageInfo.DateTime);\n                        goto skip_unixtime;\n                    }\n                }\n                // A time offset to adjust by was specified.\n                if (!Exif2tm(&tm, ImageInfo.DateTime)) goto badtime;\n\n                // Convert to unix 32 bit time value, add offset, and convert back.\n                UnixTime = mktime(&tm);\n                if ((int)UnixTime == -1) goto badtime;\n                UnixTime += ExifTimeAdjust;\n            }\n            tm = *localtime(&UnixTime);\n\n            // Print to temp buffer first to avoid putting null termination in destination.\n            // snprintf() would do the trick, but not available everywhere (like FreeBSD 4.4)\n            sprintf(TempBuf, \"%04d:%02d:%02d %02d:%02d:%02d\",\n                tm.tm_year+1900, tm.tm_mon+1, tm.tm_mday,\n                tm.tm_hour, tm.tm_min, tm.tm_sec);\n\nskip_unixtime:\n            ExifSection = FindSection(M_EXIF);\n\n            for (a = 0; a < ImageInfo.numDateTimeTags; a++) {\n                uchar * Pointer;\n                Pointer = ExifSection->Data+ImageInfo.DateTimeOffsets[a]+8;\n                memcpy(Pointer, TempBuf, 19);\n            }\n            memcpy(ImageInfo.DateTime, TempBuf, 19);\n\n            Modified = TRUE;\n        }else{\n            printf(\"File '%s' contains no Exif timestamp to change\\n\", FileName);\n        }\n    }\n\n    if (DeleteComments){\n        if (RemoveSectionType(M_COM)) Modified = TRUE;\n    }\n    if (DeleteExif){\n        if (RemoveSectionType(M_EXIF)) Modified = TRUE;\n    }\n    if (DeleteIptc){\n        if (RemoveSectionType(M_IPTC)) Modified = TRUE;\n    }\n    if (DeleteXmp){\n        if (RemoveSectionType(M_XMP)) Modified = TRUE;\n    }\n    if (DeleteUnknown){\n        if (RemoveUnknownSections()) Modified = TRUE;\n    }\n\n\n    if (Modified){\n        char BackupName[PATH_MAX+5];\n        struct stat buf;\n\n        if (!Quiet) printf(\"Modified: %s\\n\",FileName);\n\n        strcpy(BackupName, FileName);\n        strcat(BackupName, \".t\");\n\n        // Remove any .old file name that may pre-exist\n        unlink(BackupName);\n\n        // Rename the old file.\n        rename(FileName, BackupName);\n\n        // Write the new file.\n        WriteJpegFile(FileName);\n\n        // Copy the access rights from original file\n        if (stat(BackupName, &buf) == 0){\n            // set Unix access rights and time to new file\n            struct utimbuf mtime;\n            chmod(FileName, buf.st_mode);\n\n            mtime.actime = buf.st_mtime;\n            mtime.modtime = buf.st_mtime;\n\n            utime(FileName, &mtime);\n        }\n\n        // Now that we are done, remove original file.\n        unlink(BackupName);\n    }\n\n\n    if (Exif2FileTime){\n        // Set the file date to the date from the exif header.\n        if (ImageInfo.numDateTimeTags){\n            // Convert the file date to Unix time.\n            struct tm tm;\n            time_t UnixTime;\n            struct utimbuf mtime;\n          if (!Exif2tm(&tm, ImageInfo.DateTime)) goto badtime;\n            UnixTime = mktime(&tm);\n            if ((int)UnixTime == -1){\n                goto badtime;\n            }\n            mtime.actime = UnixTime;\n            mtime.modtime = UnixTime;\n\n            if (utime(FileName, &mtime) != 0){\n                printf(\"Error: Could not change time of file '%s'\\n\",FileName);\n            }else{\n                if (!Quiet) printf(\"%s\\n\",FileName);\n            }\n        }else{\n            printf(\"File '%s' contains no Exif timestamp\\n\", FileName);\n        }\n    }\n\n    // Feature to rename image according to date and time from camera.\n    // I use this feature to put images from multiple digicams in sequence.\n\n    if (RenameToDate){\n        DoFileRenaming(FileName);\n    }\n    DiscardData();\n    return;\nbadtime:\n    printf(\"Error: Time '%s': cannot convert to Unix time\\n\",ImageInfo.DateTime);\n    DiscardData();\n}\n\n//--------------------------------------------------------------------------\n// complain about bad state of the command line.\n//--------------------------------------------------------------------------\nstatic void Usage (void)\n{\n    printf(\"Jhead is a program for manipulating settings and thumbnails in Exif jpeg headers\\n\"\n           \"used by most Digital Cameras.  v\"JHEAD_VERSION\" Matthias Wandel, Oct 5 2020.\\n\"\n           \"http://www.sentex.net/~mwandel/jhead\\n\"\n           \"\\n\");\n\n    printf(\"Usage: %s [options] files\\n\", progname);\n    printf(\"Where:\\n\"\n           \" files       path/filenames with or without wildcards\\n\"\n\n           \"[options] are:\\n\"\n           \"\\nGENERAL METADATA:\\n\"\n           \"  -te <name> Transfer exif header from another image file <name>\\n\"\n           \"             Uses same name mangling as '-st' option\\n\"\n           \"  -dc        Delete comment field (as left by progs like Photoshop & Compupic)\\n\"\n           \"  -de        Strip Exif section (smaller JPEG file, but lose digicam info)\\n\"\n           \"  -di        Delete IPTC section (from Photoshop, or Picasa)\\n\"\n           \"  -dx        Delete XMP section\\n\"\n           \"  -du        Delete non image sections except for Exif and comment sections\\n\"\n           \"  -purejpg   Strip all unnecessary data from jpeg (combines -dc -de and -du)\\n\"\n           \"  -mkexif    Create new minimal exif section (overwrites pre-existing exif)\\n\"\n           \"  -ce        Edit comment field.  Uses environment variable 'editor' to\\n\"\n           \"             determine which editor to use.  If editor not set, uses VI\\n\"\n           \"             under Unix and notepad with windows\\n\"\n           \"  -cs <name> Save comment section to a file\\n\"\n           \"  -ci <name> Insert comment section from a file.  -cs and -ci use same naming\\n\"\n           \"             scheme as used by the -st option\\n\"\n           \"  -cl string Insert literal comment string\\n\"\n           \"  -zt        Trim exif header trailing zeroes (Nikon 1 wastes 30k that way)\\n\"\n\n           \"\\nDATE / TIME MANIPULATION:\\n\"\n           \"  -ft        Set file modification time to Exif time\\n\"\n           \"  -dsft      Set Exif time to file modification time\\n\"\n           \"  -n[format-string]\\n\"\n           \"             Rename files according to date.  Uses exif date if present, file\\n\"\n           \"             date otherwise.  If the optional format-string is not supplied,\\n\"\n           \"             the format is mmdd-hhmmss.  If a format-string is given, it is\\n\"\n           \"             is passed to the 'strftime' function for formatting\\n\"\n           \"             %%d Day of month    %%H Hour (24-hour)\\n\"\n           \"             %%m Month number    %%M Minute    %%S Second\\n\"\n           \"             %%y Year (2 digit 00 - 99)        %%Y Year (4 digit 1980-2036)\\n\"\n           \"             For more arguments, look up the 'strftime' function.\\n\"\n           \"             In addition to strftime format codes:\\n\"\n           \"             '%%f' as part of the string will include the original file name\\n\"\n           \"             '%%i' will include a sequence number, starting from 1. You can\\n\"\n           \"             You can specify '%%03i' for example to get leading zeros.\\n\"\n           \"             This feature is useful for ordering files from multiple digicams to\\n\"\n           \"             sequence of taking.\\n\"\n           \"             The '.jpg' is automatically added to the end of the name.  If the\\n\"\n           \"             destination name already exists, a letter or digit is added to \\n\"\n           \"             the end of the name to make it unique.\\n\"\n           \"             The new name may include a path as part of the name.  If this path\\n\"\n           \"             does not exist, it will be created\\n\"\n           \"  -a         (Windows only) Rename files with same name but different extension\\n\"\n           \"             Use together with -n to rename .AVI files from exif in .THM files\\n\"\n           \"             for example\\n\"\n           \"  -ta<+|->h[:mm[:ss]]\\n\"\n           \"             Adjust time by h:mm forwards or backwards.  Useful when having\\n\"\n           \"             taken pictures with the wrong time set on the camera, such as when\\n\"\n           \"             traveling across time zones or DST changes. Dates can be adjusted\\n\"\n           \"             by offsetting by 24 hours or more.  For large date adjustments,\\n\"\n           \"             use the -da option\\n\"\n           \"  -da<date>-<date>\\n\"\n           \"             Adjust date by large amounts.  This is used to fix photos from\\n\"\n           \"             cameras where the date got set back to the default camera date\\n\"\n           \"             by accident or battery removal.\\n\"\n           \"             To deal with different months and years having different numbers of\\n\"\n           \"             days, a simple date-month-year offset would result in unexpected\\n\"\n           \"             results.  Instead, the difference is specified as desired date\\n\"\n           \"             minus original date.  Date is specified as yyyy:mm:dd or as date\\n\"\n           \"             and time in the format yyyy:mm:dd/hh:mm:ss\\n\"\n           \"  -ts<time>  Set the Exif internal time to <time>.  <time> is in the format\\n\"\n           \"             yyyy:mm:dd-hh:mm:ss\\n\"\n           \"  -tf file   Set the exif time to the modification time from another file\\n\"\n           \"  -ds<date>  Set the Exif internal date.  <date> is in the format YYYY:MM:DD\\n\"\n           \"             or YYYY:MM or YYYY\\n\"\n\n           \"\\nTHUMBNAIL MANIPULATION:\\n\"\n           \"  -dt        Remove exif integral thumbnails.  Typically trims 10k\\n\"\n           \"  -st <name> Save Exif thumbnail, if there is one, in file <name>\\n\"\n           \"             If output file name contains the substring \\\"&i\\\" then the\\n\"\n           \"             image file name is substitute for the &i.  Note that quotes around\\n\"\n           \"             the argument are required for the '&' to be passed to the program.\\n\"\n#ifndef _WIN32\n           \"             An output name of '-' causes thumbnail to be written to stdout\\n\"\n#endif\n           \"  -rt <name> Replace Exif thumbnail.  Can only be done with headers that\\n\"\n           \"             already contain a thumbnail.\\n\"\n           \"  -rgt[size] Regenerate exif thumbnail.  Only works if image already\\n\"\n           \"             contains a thumbnail.  size specifies maximum height or width of\\n\"\n           \"             thumbnail.  Relies on 'mogrify' programs to be on path\\n\"\n\n           \"\\nROTATION TAG MANIPULATION:\\n\"\n           \"  -autorot   Invoke jpegtran to rotate images according to Exif orientation tag\\n\"\n           \"             and clear Exif orientation tag\\n\"\n           \"             Note: Windows users must get jpegtran for this to work\\n\"\n           \"  -norot     Zero out the rotation tag.  This to avoid some browsers from\\n\"\n           \"             rotating the image again after you rotated it but neglected to\\n\"\n           \"             clear the rotation tag\\n\"\n\n           \"\\nOUTPUT VERBOSITY CONTROL:\\n\"\n           \"  -h         help (this text)\\n\"\n           \"  -v         even more verbose output\\n\"\n           \"  -q         Quiet (no messages on success, like Unix)\\n\"\n           \"  -V         Show jhead version\\n\"\n           \"  -exifmap   Dump header bytes, annotate.  Pipe thru sort for better viewing\\n\"\n           \"  -se        Suppress error messages relating to corrupt exif header structure\\n\"\n           \"  -c         concise output\\n\"\n           \"  -nofinfo   Don't show file info (name/size/date)\\n\"\n\n           \"\\nFILE MATCHING AND SELECTION:\\n\"\n           \"  -model model\\n\"\n           \"             Only process files from digicam containing model substring in\\n\"\n           \"             camera model description\\n\"\n           \"  -exonly    Skip all files that don't have an exif header (skip all jpegs that\\n\"\n           \"             were not created by digicam)\\n\"\n           \"  -quality x Only work on images with JPEG quality factor x or higher\\n\"\n           \"  -cmd command\\n\"\n           \"             Apply 'command' to every file, then re-insert exif and command\\n\"\n           \"             sections into the image. &i will be substituted for the input file\\n\"\n           \"             name, and &o (if &o is used). Use quotes around the command string\\n\"\n           \"             This is most useful in conjunction with the free ImageMagick tool. \\n\"\n           \"             For example, with my Canon S100, which suboptimally compresses\\n\"\n           \"             jpegs I can specify\\n\"\n           \"                jhead -cmd \\\"mogrify -quality 80 &i\\\" *.jpg\\n\"\n           \"             to re-compress a lot of images using ImageMagick to half the size,\\n\"\n           \"             and no visible loss of quality while keeping the exif header\\n\"\n           \"             Another invocation I like to use is jpegtran (hard to find for\\n\"\n           \"             windows).  I type:\\n\"\n           \"                jhead -cmd \\\"jpegtran -progressive &i &o\\\" *.jpg\\n\"\n           \"             to convert jpegs to progressive jpegs (Unix jpegtran syntax\\n\"\n           \"             differs slightly)\\n\"\n           \"  -orp       Only operate on 'portrait' aspect ratio images\\n\"\n           \"  -orl       Only operate on 'landscape' aspect ratio images\\n\"\n#ifdef _WIN32\n           \"  -r         No longer supported.  Use the ** wildcard to recurse directories\\n\"\n           \"             with instead.\\n\"\n           \"             examples:\\n\"\n           \"                 jhead **/*.jpg\\n\"\n           \"                 jhead \\\"c:\\\\my photos\\\\**\\\\*.jpg\\\"\\n\"\n#endif\n\n\n#ifdef MATTHIAS\n           \"\\n\"\n           \"  -cr        Remove comment tag (my way)\\n\"\n           \"  -ca        Add comment tag (my way)\\n\"\n           \"  -ar        Auto resize to fit in 1024x1024, but never less than half\\n\"\n#endif //MATTHIAS\n\n\n           );\n\n    exit(EXIT_FAILURE);\n}\n\n\n//--------------------------------------------------------------------------\n// Parse specified date or date+time from command line.\n//--------------------------------------------------------------------------\nstatic time_t ParseCmdDate(char * DateSpecified)\n{\n    int a;\n    struct tm tm;\n    time_t UnixTime;\n\n    tm.tm_wday = -1;\n    tm.tm_hour = tm.tm_min = tm.tm_sec = 0;\n\n    a = sscanf(DateSpecified, \"%d:%d:%d/%d:%d:%d\",\n            &tm.tm_year, &tm.tm_mon, &tm.tm_mday,\n            &tm.tm_hour, &tm.tm_min, &tm.tm_sec);\n\n    if (a != 3 && a < 5){\n        // Date must be YYYY:MM:DD, YYYY:MM:DD+HH:MM\n        // or YYYY:MM:DD+HH:MM:SS\n        ErrFatal(\"Could not parse specified date\");\n    }\n    tm.tm_isdst = -1;\n    tm.tm_mon -= 1;      // Adjust for unix zero-based months\n    tm.tm_year -= 1900;  // Adjust for year starting at 1900\n\n    UnixTime = mktime(&tm);\n    if (UnixTime == -1){\n        ErrFatal(\"Specified time is invalid or out of range\");\n    }\n\n    return UnixTime;\n}\n\n//--------------------------------------------------------------------------\n// The main program.\n//--------------------------------------------------------------------------\nint main (int argc, char **argv)\n{\n    int argn;\n    char * arg;\n    progname = argv[0];\n\n    for (argn=1;argn<argc;argn++){\n        arg = argv[argn];\n        if (arg[0] != '-') break; // Filenames from here on.\n\n    // General metadata options:\n        if (!strcmp(arg,\"-te\")){\n            ExifXferScrFile = argv[++argn];\n            DoModify |= MODIFY_JPEG;\n        }else if (!strcmp(arg,\"-dc\")){\n            DeleteComments = TRUE;\n            DoModify |= MODIFY_JPEG;\n        }else if (!strcmp(arg,\"-de\")){\n            DeleteExif = TRUE;\n            DoModify |= MODIFY_JPEG;\n        }else if (!strcmp(arg,\"-di\")){\n            DeleteIptc = TRUE;\n            DoModify |= MODIFY_JPEG;\n        }else if (!strcmp(arg,\"-dx\")){\n            DeleteXmp = TRUE;\n            DoModify |= MODIFY_JPEG;\n        }else if (!strcmp(arg, \"-du\")){\n            DeleteUnknown = TRUE;\n            DoModify |= MODIFY_JPEG;\n        }else if (!strcmp(arg, \"-purejpg\")){\n            DeleteExif = TRUE;\n            DeleteComments = TRUE;\n            DeleteIptc = TRUE;\n            DeleteUnknown = TRUE;\n            DeleteXmp = TRUE;\n            DoModify |= MODIFY_JPEG;\n        }else if (!strcmp(arg,\"-ce\")){\n            EditComment = TRUE;\n            DoModify |= MODIFY_JPEG;\n        }else if (!strcmp(arg,\"-cs\")){\n            CommentSavefileName = argv[++argn];\n        }else if (!strcmp(arg,\"-ci\")){\n            CommentInsertfileName = argv[++argn];\n            DoModify |= MODIFY_JPEG;\n        }else if (!strcmp(arg,\"-cl\")){\n            CommentInsertLiteral = argv[++argn];\n            DoModify |= MODIFY_JPEG;\n        }else if (!strcmp(arg,\"-zt\")){\n            TrimExifTrailingZeroes = TRUE;\n            DoModify |= MODIFY_JPEG;\n        }else if (!strcmp(arg,\"-mkexif\")){\n            CreateExifSection = TRUE;\n            DoModify |= MODIFY_JPEG;\n    // Output verbosity control\n        }else if (!strcmp(arg,\"-h\") || !strcmp(arg,\"--help\")){\n            Usage();\n        }else if (!strcmp(arg,\"-v\")){\n            ShowTags = TRUE;\n        }else if (!strcmp(arg,\"-q\")){\n            Quiet = TRUE;\n        }else if (!strcmp(arg,\"-V\")){\n            printf(\"Jhead version: \"JHEAD_VERSION\"\\n\");\n            exit(0);\n        }else if (!strcmp(arg,\"-exifmap\")){\n            DumpExifMap = TRUE;\n        }else if (!strcmp(arg,\"-se\")){\n            SuppressNonFatalErrors = TRUE;\n        }else if (!strcmp(arg,\"-c\")){\n            ShowConcise = TRUE;\n        }else if (!strcmp(arg,\"-nofinfo\")){\n            ShowFileInfo = 0;\n\n    // Thumbnail manipulation options\n        }else if (!strcmp(arg,\"-dt\")){\n            TrimExif = TRUE;\n            DoModify |= MODIFY_JPEG;\n        }else if (!strcmp(arg,\"-st\")){\n            ThumbSaveName = argv[++argn];\n            DoModify |= READ_JPEG;\n        }else if (!strcmp(arg,\"-rt\")){\n            ThumbInsertName = argv[++argn];\n            DoModify |= MODIFY_JPEG;\n        }else if (!memcmp(arg,\"-rgt\", 4)){\n            RegenThumbnail = 160;\n            sscanf(arg+4, \"%d\", &RegenThumbnail);\n            if (RegenThumbnail > 320){\n                ErrFatal(\"Specified thumbnail geometry too big!\");\n            }\n            DoModify |= MODIFY_JPEG;\n\n    // Rotation tag manipulation\n        }else if (!strcmp(arg,\"-autorot\")){\n            AutoRotate = 1;\n            DoModify |= MODIFY_JPEG;\n        }else if (!strcmp(arg,\"-norot\")){\n            AutoRotate = 1;\n            ZeroRotateTagOnly = 1;\n            DoModify |= MODIFY_JPEG;\n\n    // Date/Time manipulation options\n        }else if (!memcmp(arg,\"-n\",2)){\n            RenameToDate = 1;\n            DoModify |= READ_JPEG; // Rename doesn't modify file, so count as read action.\n            arg+=2;\n            if (*arg == 'f'){\n                // Accept -nf, but -n does the same thing now.\n                arg++;\n            }\n            if (*arg){\n                // A strftime format string is supplied.\n                strftime_args = arg;\n                #ifdef _WIN32\n                    SlashToNative(strftime_args);\n                #endif\n                //printf(\"strftime_args = %s\\n\",arg);\n            }\n        }else if (!strcmp(arg,\"-a\")){\n            #ifndef _WIN32\n                ErrFatal(\"Error: -a only supported in Windows version\");\n            #else\n                RenameAssociatedFiles = TRUE;\n            #endif\n        }else if (!strcmp(arg,\"-ft\")){\n            Exif2FileTime = TRUE;\n            DoModify |= MODIFY_ANY;\n        }else if (!memcmp(arg,\"-ta\",3)){\n            // Time adjust feature.\n            int hours, minutes, seconds, n;\n            minutes = seconds = 0;\n            if (arg[3] != '-' && arg[3] != '+'){\n                ErrFatal(\"Error: -ta must be followed by +/- and a time\");\n            }\n            n = sscanf(arg+4, \"%d:%d:%d\", &hours, &minutes, &seconds);\n\n            if (n < 1){\n                ErrFatal(\"Error: -ta must be immediately followed by time\");\n            }\n            if (ExifTimeAdjust) ErrFatal(\"Can only use one of -da or -ta options at once\");\n            ExifTimeAdjust = hours*3600 + minutes*60 + seconds;\n            if (arg[3] == '-') ExifTimeAdjust = -ExifTimeAdjust;\n            DoModify |= MODIFY_JPEG;\n        }else if (!memcmp(arg,\"-da\",3)){\n            // Date adjust feature (large time adjustments)\n            time_t NewDate, OldDate = 0;\n            char * pOldDate;\n            NewDate = ParseCmdDate(arg+3);\n            pOldDate = strstr(arg+1, \"-\");\n            if (pOldDate){\n                OldDate = ParseCmdDate(pOldDate+1);\n            }else{\n                ErrFatal(\"Must specify second date for -da option\");\n            }\n            if (ExifTimeAdjust) ErrFatal(\"Can only use one of -da or -ta options at once\");\n            ExifTimeAdjust = NewDate-OldDate;\n            DoModify |= MODIFY_JPEG;\n        }else if (!memcmp(arg,\"-dsft\",5)){\n            // Set exif time to the timestamp of the file.\n            FileTimeToExif = TRUE;\n            DoModify |= MODIFY_JPEG;\n        }else if (!memcmp(arg,\"-ds\",3)){\n            // Set date feature\n            int a;\n            // Check date validity and copy it.  Could be incompletely specified.\n            strcpy(DateSet, \"0000:01:01\");\n            for (a=0;arg[a+3] && a < sizeof(DateSet);a++){\n                if (isdigit(DateSet[a])){\n                    if (!isdigit(arg[a+3])){\n                        a = 0;\n                        break;\n                    }\n                }else{\n                    if (arg[a+3] != ':'){\n                        a=0;\n                        break;\n                    }\n                }\n                DateSet[a] = arg[a+3];\n            }\n            if (a < 4 || a > 10){\n                ErrFatal(\"Date must be in format YYYY, YYYY:MM, or YYYY:MM:DD\");\n            }\n            DateSetChars = a;\n            DoModify |= MODIFY_JPEG;\n        }else if (!memcmp(arg,\"-ts\",3)){\n            // Set the exif time.\n            // Time must be specified as \"yyyy:mm:dd-hh:mm:ss\"\n            char * c;\n            struct tm tm;\n\n            c = strstr(arg+1, \"-\");\n            if (c) *c = ' '; // Replace '-' with a space.\n\n            if (!Exif2tm(&tm, arg+3)){\n                ErrFatal(\"-ts option must be followed by time in format yyyy:mm:dd-hh:mm:ss\\n\"\n                        \"Example: jhead -ts2001:01:01-12:00:00 foo.jpg\");\n            }\n\n            ExifTimeSet  = mktime(&tm);\n\n            if ((int)ExifTimeSet == -1) ErrFatal(\"Time specified is out of range\");\n            DoModify |= MODIFY_JPEG;\n\n        }else if (!memcmp(arg,\"-tf\",3)){\n            // Set the exif time to the modification time from another file.\n            struct stat stat_buf;\n            if (stat(argv[++argn], &stat_buf) == 0){\n                ExifTimeSet = stat_buf.st_mtime;\n            }else{\n                ErrFatal(\"Could not read file\");\n            }\n            DoModify |= MODIFY_JPEG;\n\n    // File matching and selection\n        }else if (!strcmp(arg,\"-model\")){\n            if (argn+1 >= argc) Usage(); // No extra argument.\n            FilterModel = argv[++argn];\n        }else if (!strcmp(arg,\"-quality\")){\n            if (argn+1 >= argc) Usage(); // No extra argument.\n            if (sscanf(argv[++argn], \"%d\", &FilterQuality) != 1){\n                Usage();\n            }\n        }else if (!strcmp(arg,\"-proc\")){\n            sscanf(argv[++argn], \"%d\", &ProcessOnly);\n            if (ProcessOnly < 0 || ProcessOnly > 2){\n                ErrFatal(\"-proc must be followed by a number 0-2\");\n            }\n        }else if (!strcmp(arg,\"-exonly\")){\n            ExifOnly = 1;\n        }else if (!strcmp(arg,\"-orp\")){\n            PortraitOnly = 1;\n        }else if (!strcmp(arg,\"-orl\")){\n            PortraitOnly = -1;\n        }else if (!strcmp(arg,\"-cmd\")){\n            if (argn+1 >= argc) Usage(); // No extra argument.\n            ApplyCommand = argv[++argn];\n            DoModify |= MODIFY_ANY;\n\n#ifdef MATTHIAS\n        }else if (!strcmp(arg,\"-ca\")){\n            // Its a literal comment.  Add.\n            AddComment = argv[++argn];\n            DoModify |= MODIFY_JPEG;\n        }else if (!strcmp(arg,\"-cr\")){\n            // Its a literal comment.  Remove this keyword.\n            RemComment = argv[++argn];\n            DoModify |= MODIFY_JPEG;\n        }else if (!strcmp(arg,\"-ar\")){\n            AutoResize = TRUE;\n            ShowConcise = TRUE;\n            ApplyCommand = (char *)1; // Must be non null so it does commands.\n            DoModify |= MODIFY_JPEG;\n#endif // MATTHIAS\n        }else{\n            printf(\"Argument '%s' not understood\\n\",arg);\n            printf(\"Use jhead -h for list of arguments\\n\");\n            exit(-1);\n        }\n        if (argn >= argc){\n            // Used an extra argument - because the last argument\n            // used up an extr argument.\n            ErrFatal(\"Extra argument required\");\n        }\n    }\n    if (argn == argc){\n        ErrFatal(\"No files to process.  Use -h for help\");\n    }\n\n    if (ThumbSaveName != NULL && strcmp(ThumbSaveName, \"&i\") == 0){\n        printf(\"Error: By specifying \\\"&i\\\" for the thumbail name, your original file\\n\"\n               \"       will be overwritten.  If this is what you really want,\\n\"\n               \"       specify -st \\\"./&i\\\"  to override this check\\n\");\n        exit(0);\n    }\n\n    if (RegenThumbnail){\n        if (ThumbSaveName || ThumbInsertName){\n            printf(\"Error: Cannot regen and save or insert thumbnail in same run\\n\");\n            exit(0);\n        }\n    }\n\n    if (EditComment){\n        if (CommentSavefileName != NULL || CommentInsertfileName != NULL){\n            printf(\"Error: Cannot use -ce option in combination with -cs or -ci\\n\");\n            exit(0);\n        }\n    }\n\n\n    if (ExifXferScrFile){\n        if (FilterModel || ApplyCommand){\n            ErrFatal(\"Error: Filter by model and/or applying command to files\\n\"\n            \"   invalid while transferring Exif headers\");\n        }\n    }\n\n    FileSequence = 0;\n    for (;argn<argc;argn++){\n        FilesMatched = FALSE;\n\n        #ifdef _WIN32\n            SlashToNative(argv[argn]);\n            // Use my globbing module to do fancier wildcard expansion with recursive\n            // subdirectories under Windows.\n            MyGlob(argv[argn], ProcessFile);\n        #else\n            // Under linux, don't do any extra fancy globbing - shell globbing is\n            // pretty fancy as it is - although not as good as myglob.c\n            ProcessFile(argv[argn]);\n        #endif\n\n        if (!FilesMatched){\n            fprintf(stderr, \"Error: No files matched '%s'\\n\",argv[argn]);\n        }\n    }\n\n    if (FileSequence == 0){\n        return EXIT_FAILURE;\n    }else{\n        return EXIT_SUCCESS;\n    }\n}\n"], "fixing_code": ["//--------------------------------------------------------------------------\n// Program to pull the information out of various types of EXIF digital\n// camera files and show it in a reasonably consistent way\n//\n// Version 3.06\n//\n// Compiling under Windows:\n//   Make sure you have Microsoft's compiler on the path, then run make.bat\n//\n// Dec 1999 - Oct 2020\n//\n// by Matthias Wandel   http://woodgears.ca\n//--------------------------------------------------------------------------\n#ifdef _WIN32\n    #include <io.h>\n#endif\n\n#include \"jhead.h\"\n\n#include <sys/stat.h>\n\n#define JHEAD_VERSION \"3.06\"\n\n// This #define turns on features that are too very specific to\n// how I organize my photos.  Best to ignore everything inside #ifdef MATTHIAS\n#define MATTHIAS\n\n\n// Bitmasks for DoModify:\n#define MODIFY_ANY  1\n#define READ_ANY    2\n#define JPEGS_ONLY  4\n#define MODIFY_JPEG 5\n#define READ_JPEG   6\nstatic int DoModify  = FALSE;\n\n\nstatic int FilesMatched;\nstatic int FileSequence;\n\nstatic const char * CurrentFile;\n\nstatic const char * progname;   // program name for error messages\n\n//--------------------------------------------------------------------------\n// Command line options flags\nstatic int TrimExif = FALSE;        // Cut off exif beyond interesting data.\nstatic int RenameToDate = 0;        // 1=rename, 2=rename all.\n#ifdef _WIN32\nstatic int RenameAssociatedFiles = FALSE;\n#endif\nstatic char * strftime_args = NULL; // Format for new file name.\nstatic int Exif2FileTime  = FALSE;\n       int ShowTags     = FALSE;    // Do not show raw by default.\nstatic int Quiet        = FALSE;    // Be quiet on success (like unix programs)\n       int DumpExifMap  = FALSE;\nstatic int ShowConcise  = FALSE;\nstatic int CreateExifSection = FALSE;\nstatic int TrimExifTrailingZeroes = FALSE;\nstatic char * ApplyCommand = NULL;  // Apply this command to all images.\nstatic char * FilterModel = NULL;\nstatic int    FilterQuality = 0;\nstatic int    ExifOnly    = FALSE;  // Only do images with exif header\nstatic int    ProcessOnly = -1;     // 0 for baseline, 2 for progressive only, -1 for all images.\nstatic int    PortraitOnly = FALSE; // Only do images with portrait orientation.\nstatic time_t ExifTimeAdjust = 0;   // Timezone adjust\nstatic time_t ExifTimeSet = 0;      // Set exif time to a value.\nstatic char DateSet[11];\nstatic unsigned DateSetChars = 0;\nstatic unsigned FileTimeToExif = FALSE;\n\nstatic int DeleteComments = FALSE;\nstatic int DeleteExif = FALSE;\nstatic int DeleteIptc = FALSE;\nstatic int DeleteXmp = FALSE;\nstatic int DeleteUnknown = FALSE;\nstatic char * ThumbSaveName = NULL; // If not NULL, use this string to make up\n                                    // the filename to store the thumbnail to.\n\nstatic char * ThumbInsertName = NULL; // If not NULL, use this string to make up\n                                    // the filename to retrieve the thumbnail from.\n\nstatic int RegenThumbnail = FALSE;\n\nstatic char * ExifXferScrFile = NULL;// Extract Exif header from this file, and\n                                    // put it into the Jpegs processed.\n\nstatic int EditComment = FALSE;     // Invoke an editor for editing the comment\nstatic int SuppressNonFatalErrors = FALSE; // Whether or not to pint warnings on recoverable errors\n\nstatic char * CommentSavefileName = NULL; // Save comment to this file.\nstatic char * CommentInsertfileName = NULL; // Insert comment from this file.\nstatic char * CommentInsertLiteral = NULL;  // Insert this comment (from command line)\n\nstatic int AutoRotate = FALSE;\nstatic int ZeroRotateTagOnly = FALSE;\n\nstatic int ShowFileInfo = TRUE;     // Indicates to show standard file info\n                                    // (file name, file size, file date)\n\n\n#ifdef MATTHIAS\n    // This #ifdef to take out less than elegant stuff for editing\n    // the comments in a JPEG.  The programs rdjpgcom and wrjpgcom\n    // included with Linux distributions do a better job.\n\n    static char * AddComment = NULL; // Add this tag.\n    static char * RemComment = NULL; // Remove this tag\n    static int AutoResize = FALSE;\n#endif // MATTHIAS\n\n//--------------------------------------------------------------------------\n// Error exit handler\n//--------------------------------------------------------------------------\nvoid ErrFatal(const char * msg)\n{\n    fprintf(stderr,\"\\nError : %s\\n\", msg);\n    if (CurrentFile) fprintf(stderr,\"in file '%s'\\n\",CurrentFile);\n    exit(EXIT_FAILURE);\n}\n\n//--------------------------------------------------------------------------\n// Report non fatal errors.  Now that microsoft.net modifies exif headers,\n// there's corrupted ones, and there could be more in the future.\n//--------------------------------------------------------------------------\nvoid ErrNonfatal(const char * msg, int a1, int a2)\n{\n    if (SuppressNonFatalErrors) return;\n\n    fprintf(stderr,\"\\nNonfatal Error : \");\n    if (CurrentFile) fprintf(stderr,\"'%s' \",CurrentFile);\n    fprintf(stderr, msg, a1, a2);\n    fprintf(stderr, \"\\n\");\n}\n\n\n//--------------------------------------------------------------------------\n// Invoke an editor for editing a string.\n//--------------------------------------------------------------------------\nstatic int FileEditComment(char * TempFileName, char * Comment, int CommentSize)\n{\n    FILE * file;\n    int a;\n    char QuotedPath[2*PATH_MAX+10];\n\n    file = fopen(TempFileName, \"w\");\n    if (file == NULL){\n        fprintf(stderr, \"Can't create file '%s'\\n\",TempFileName);\n        ErrFatal(\"could not create temporary file\");\n    }\n    fwrite(Comment, CommentSize, 1, file);\n\n    fclose(file);\n\n    fflush(stdout); // So logs are contiguous.\n\n    {\n        char * Editor;\n        Editor = getenv(\"EDITOR\");\n        if (Editor == NULL){\n#ifdef _WIN32\n            Editor = \"notepad\";\n#else\n            Editor = \"vi\";\n#endif\n        }\n        if (strlen(Editor) > PATH_MAX) ErrFatal(\"env too long\");\n\n        // Disallow characters in the editor or filename that could be used to execute arbitrary\n        // shell commands with system() below.\n        if (strpbrk(TempFileName, \"\\\";'&|`$\")) {\n            ErrFatal(\"Filename has invalid characters\");\n        }\n        if (strpbrk(Editor, \"\\\";'&|`$\")) {\n            ErrFatal(\"Editor has invalid characters\");\n        }\n\n        int num = snprintf(QuotedPath, sizeof(QuotedPath), \"%s \\\"%s\\\"\",Editor, TempFileName);\n        if(num > sizeof(QuotedPath)) {\n            ErrFatal(\"Quoted path to edit would be too long\");\n        }\n\n        a = system(QuotedPath);\n    }\n\n    if (a != 0){\n        perror(\"Editor failed to launch\");\n        exit(-1);\n    }\n\n    file = fopen(TempFileName, \"r\");\n    if (file == NULL){\n        ErrFatal(\"could not open temp file for read\");\n    }\n\n    // Read the file back in.\n    CommentSize = fread(Comment, 1, MAX_COMMENT_SIZE, file);\n\n    fclose(file);\n\n    unlink(TempFileName);\n\n    return CommentSize;\n}\n\n#ifdef MATTHIAS\n//--------------------------------------------------------------------------\n// Modify one of the lines in the comment field.\n// This very specific to the photo album program stuff.\n//--------------------------------------------------------------------------\nstatic char KnownTags[][10] = {\"date\", \"desc\",\"scan_date\",\"author\",\n                               \"keyword\",\"videograb\",\n                               \"show_raw\",\"panorama\",\"titlepix\",\"\"};\n\nstatic int ModifyDescriptComment(char * OutComment, char * SrcComment)\n{\n    char Line[500];\n    int Len;\n    int a,i;\n    unsigned l;\n    int HasScandate = FALSE;\n    int TagExists = FALSE;\n    int Modified = FALSE;\n    Len = 0;\n\n    OutComment[0] = 0;\n\n\n    for (i=0;;i++){\n        if (SrcComment[i] == '\\r' || SrcComment[i] == '\\n' || SrcComment[i] == 0 || Len >= 199){\n            // Process the line.\n            if (Len > 0){\n                Line[Len] = 0;\n                //printf(\"Line: '%s'\\n\",Line);\n                for (a=0;;a++){\n                    l = strlen(KnownTags[a]);\n                    if (!l){\n                        // Unknown tag.  Discard it.\n                        printf(\"Error: Unknown tag '%s'\\n\", Line); // Deletes the tag.\n                        Modified = TRUE;\n                        break;\n                    }\n                    if (memcmp(Line, KnownTags[a], l) == 0){\n                        if (Line[l] == ' ' || Line[l] == '=' || Line[l] == 0){\n                            // Its a good tag.\n                            if (Line[l] == ' ') Line[l] = '='; // Use equal sign for clarity.\n                            if (a == 2) break; // Delete 'orig_path' tag.\n                            if (a == 3) HasScandate = TRUE;\n                            if (RemComment){\n                                if (strlen(RemComment) == l){\n                                    if (!memcmp(Line, RemComment, l)){\n                                        Modified = TRUE;\n                                        break;\n                                    }\n                                }\n                            }\n                            if (AddComment){\n                                // Overwrite old comment of same tag with new one.\n                                if (!memcmp(Line, AddComment, l+1)){\n                                    TagExists = TRUE;\n                                    strncpy(Line, AddComment, sizeof(Line));\n                                    Line[sizeof(Line)-1]='\\0';\n                                    Modified = TRUE;\n                                }\n                            }\n                            strncat(OutComment, Line, MAX_COMMENT_SIZE-5-strlen(OutComment));\n                            strcat(OutComment, \"\\n\");\n                            break;\n                        }\n                    }\n                }\n            }\n            Line[Len = 0] = 0;\n            if (SrcComment[i] == 0) break;\n        }else{\n            Line[Len++] = SrcComment[i];\n        }\n    }\n\n    if (AddComment && TagExists == FALSE){\n        strncat(OutComment, AddComment, MAX_COMMENT_SIZE-5-strlen(OutComment));\n        strcat(OutComment, \"\\n\");\n        Modified = TRUE;\n    }\n\n    if (!HasScandate && !ImageInfo.DateTime[0]){\n        // Scan date is not in the file yet, and it doesn't have one built in.  Add it.\n        char Temp[40];\n        sprintf(Temp, \"scan_date=%s\", ctime(&ImageInfo.FileDateTime));\n        strncat(OutComment, Temp, MAX_COMMENT_SIZE-5-strlen(OutComment));\n        Modified = TRUE;\n    }\n    return Modified;\n}\n//--------------------------------------------------------------------------\n// Automatic make smaller command stuff\n//--------------------------------------------------------------------------\nstatic int AutoResizeCmdStuff(void)\n{\n    static char CommandString[PATH_MAX+1];\n    double scale;\n    float TargetSize = 1800;\n\n    ApplyCommand = CommandString;\n\n    scale = TargetSize / ImageInfo.Width;\n    if (scale > TargetSize / ImageInfo.Height) scale = TargetSize / ImageInfo.Height;\n\n    if (scale > 0.8){\n        if (ImageInfo.QualityGuess >= 93){\n            // Re-compress at lower quality.\n            sprintf(CommandString, \"mogrify -quality 86 &i\");\n            return TRUE;\n        }\n        printf(\"not resizing %dx%x '%s'\\n\",ImageInfo.Height, ImageInfo.Width, ImageInfo.FileName);\n        return FALSE;\n    }\n\n    if (scale < 0.4) scale = 0.4; // Don't scale down by too much.\n\n    sprintf(CommandString, \"mogrify -geometry %dx%d -quality 85 &i\",(int)(ImageInfo.Width*scale+0.5),\n                                    (int)(ImageInfo.Height*scale+0.5));\n    return TRUE;\n}\n\n\n#endif // MATTHIAS\n\n\n//--------------------------------------------------------------------------\n// Escape an argument such that it is interpreted literally by the shell\n// (returns the number of written characters)\n//--------------------------------------------------------------------------\nstatic int shellescape(char* to, const char* from)\n{\n    int i, j;\n    i = j = 0;\n\n    // Enclosing characters in double quotes preserves the literal value of\n    // all characters within the quotes, with the exception of $, `, and \\.\n    to[j++] = '\"';\n    while(from[i])\n    {\n#ifdef _WIN32\n        // Under WIN32, there isn't really anything dangerous you can do with\n        // escape characters, plus windows users aren't as security paranoid.\n        // Hence, no need to do fancy escaping.\n        to[j++] = from[i++];\n#else\n        switch(from[i]) {\n            case '\"':\n            case '$':\n            case '`':\n            case '\\\\':\n                to[j++] = '\\\\';\n                // Fallthru...\n            default:\n                to[j++] = from[i++];\n        }\n#endif\n        if (j >= PATH_MAX) ErrFatal(\"max path exceeded\");\n    }\n    to[j++] = '\"';\n    return j;\n}\n\n\n//--------------------------------------------------------------------------\n// Apply the specified command to the JPEG file.\n//--------------------------------------------------------------------------\nstatic void DoCommand(const char * FileName, int ShowIt)\n{\n    int a,e;\n    char ExecString[PATH_MAX*3];\n    char TempName[PATH_MAX+10];\n    int TempUsed = FALSE;\n\n    e = 0;\n\n    // Generate an unused temporary file name in the destination directory\n    // (a is the number of characters to copy from FileName)\n    a = strlen(FileName)-1;\n    while(a > 0 && FileName[a-1] != SLASH) a--;\n    memcpy(TempName, FileName, a);\n    strcpy(TempName+a, \"XXXXXX\");\n\n    // Note: Compiler will warn about mkstemp.  but I need a filename, not a file.\n    // I could just then get the file name from what mkstemp made, and pass that\n    // to the executable, but that would make for the exact same vulnerability\n    // as mktemp - that is, that between getting the random name, and making the file\n    // some other program could snatch that exact same name!\n    // also, not all platforms support mkstemp.\n    mktemp(TempName);\n\n\n    if(!TempName[0]) {\n        ErrFatal(\"Cannot find available temporary file name\");\n    }\n\n\n    // Build the exec string.  &i and &o in the exec string get replaced by input and output files.\n    for (a=0;;a++){\n        if (ApplyCommand[a] == '&'){\n            printf(\"Arg &%c, e=%d max %d\\n\",ApplyCommand[a+1], e, PATH_MAX);\n            if (ApplyCommand[a+1] == 'i' || ApplyCommand[a+1] == 'o'){\n                if (e > PATH_MAX * 2) ErrFatal(\"Specified command line too long\");\n            }\n\n            if (ApplyCommand[a+1] == 'i'){\n                // Input file.\n                e += shellescape(ExecString+e, FileName);\n                a += 1;\n                continue;\n            }\n            if (ApplyCommand[a+1] == 'o'){\n                // Needs an output file distinct from the input file.\n                e += shellescape(ExecString+e, TempName);\n                a += 1;\n                TempUsed = TRUE;\n                continue;\n            }\n        }\n        ExecString[e++] = ApplyCommand[a];\n        if (ApplyCommand[a] == 0) break;\n    }\n\n    if (ShowIt) printf(\"Cmd:%s\\n\",ExecString);\n\n    errno = 0;\n    a = system(ExecString);\n\n    if (a || errno){\n        // A command can however fail without errno getting set or system returning an error.\n        if (errno) perror(\"system\");\n        ErrFatal(\"Problem executing specified command\");\n    }\n\n    if (TempUsed){\n        // Don't delete original file until we know a new one was created by the command.\n        struct stat dummy;\n        if (stat(TempName, &dummy) == 0){\n            struct stat buf;\n            int stat_result = stat(FileName, &buf);\n\n            unlink(FileName);\n            rename(TempName, FileName);\n            if (stat_result == 0){\n                // set Unix access rights and time to new file\n                struct utimbuf mtime;\n                chmod(FileName, buf.st_mode);\n\n                mtime.actime = buf.st_atime;\n                mtime.modtime = buf.st_mtime;\n\n                utime(FileName, &mtime);\n            }\n        }else{\n            ErrFatal(\"specified command did not produce expected output file\");\n        }\n    }\n}\n\n//--------------------------------------------------------------------------\n// check if this file should be skipped based on contents.\n//--------------------------------------------------------------------------\nstatic int CheckFileSkip(void)\n{\n    // I sometimes add code here to only process images based on certain\n    // criteria - for example, only to convert non progressive Jpegs to progressives, etc..\n    if(ProcessOnly >= 0 && (ImageInfo.Process & 0x0f) != ProcessOnly){\n        // ProcessOnly == 0 means skip baseline oencoded jpegs\n        // ProcessOnly == 2 means skip progressive oencoded jpegs\n        return TRUE;\n    }\n\n    if (FilterModel){\n        // Filtering processing by camera model.\n        // This feature is useful when pictures from multiple cameras are collated,\n        // the its found that one of the cameras has the time set incorrectly.\n        if (strstr(ImageInfo.CameraModel, FilterModel) == NULL){\n            // Skip.\n            return TRUE;\n        }\n    }\n    if (FilterQuality > 0){\n        //Filter by above threshold quality\n        if (ImageInfo.QualityGuess < FilterQuality){\n            return TRUE;\n        }\n    }\n\n    if (ExifOnly){\n        // Filtering by EXIF only.  Skip all files that have no Exif.\n        if (FindSection(M_EXIF) == NULL){\n            return TRUE;\n        }\n    }\n\n    if (PortraitOnly == 1){\n        if (ImageInfo.Width > ImageInfo.Height) return TRUE;\n    }\n\n    if (PortraitOnly == -1){\n        if (ImageInfo.Width < ImageInfo.Height) return TRUE;\n    }\n\n    return FALSE;\n}\n\n//--------------------------------------------------------------------------\n// Substitute original name for '&i' if present in specified name.\n// This to allow specifying relative names when manipulating multiple files.\n//--------------------------------------------------------------------------\nstatic void RelativeName(char * OutFileName, const char * NamePattern, const char * OrigName)\n{\n    // If the filename contains substring \"&i\", then substitute the\n    // filename for that.  This gives flexibility in terms of processing\n    // multiple files at a time.\n    char * Subst;\n    Subst = strstr(NamePattern, \"&i\");\n    if (Subst > NamePattern+PATH_MAX-10){\n        ErrFatal(\"Bad file name pattern\");\n    }\n\n    if (Subst){\n        strncpy(OutFileName, NamePattern, Subst-NamePattern);\n        OutFileName[Subst-NamePattern] = 0;\n        strncat(OutFileName, OrigName, PATH_MAX-1-strlen(OutFileName));\n        strncat(OutFileName, Subst+2, PATH_MAX-1-strlen(OutFileName));\n    }else{\n        strncpy(OutFileName, NamePattern, PATH_MAX);\n    }\n}\n\n\n#ifdef _WIN32\n//--------------------------------------------------------------------------\n// Rename associated files\n//--------------------------------------------------------------------------\nvoid RenameAssociated(const char * FileName, char * NewBaseName)\n{\n    int a;\n    int PathLen;\n    int ExtPos;\n    char FilePattern[_MAX_PATH+1];\n    char NewName[_MAX_PATH+1];\n    struct _finddata_t finddata;\n    long find_handle;\n\n    for(ExtPos = strlen(FileName);FileName[ExtPos-1] != '.';){\n        if (--ExtPos == 0) return; // No extension!\n    }\n\n    memcpy(FilePattern, FileName, ExtPos);\n    FilePattern[ExtPos] = '*';\n    FilePattern[ExtPos+1] = '\\0';\n\n    for(PathLen = strlen(FileName);FileName[PathLen-1] != SLASH;){\n        if (--PathLen == 0) break;\n    }\n\n    find_handle = _findfirst(FilePattern, &finddata);\n\n    for (;;){\n        if (find_handle == -1) break;\n\n        // Eliminate the obvious patterns.\n        if (!memcmp(finddata.name, \".\",2)) goto next_file;\n        if (!memcmp(finddata.name, \"..\",3)) goto next_file;\n        if (finddata.attrib & _A_SUBDIR) goto next_file;\n\n        strncpy(FilePattern+PathLen, finddata.name, PATH_MAX-PathLen); // full name with path\n\n        strcpy(NewName, NewBaseName);\n        for(a = strlen(finddata.name);finddata.name[a] != '.';){\n            if (--a == 0) goto next_file;\n        }\n        strncat(NewName, finddata.name+a, _MAX_PATH-strlen(NewName)); // add extension to new name\n\n        if (rename(FilePattern, NewName) == 0){\n            if (!Quiet){\n                printf(\"%s --> %s\\n\",FilePattern, NewName);\n            }\n        }\n\n        next_file:\n        if (_findnext(find_handle, &finddata) != 0) break;\n    }\n    _findclose(find_handle);\n}\n#endif\n\n//--------------------------------------------------------------------------\n// Handle renaming of files by date.\n//--------------------------------------------------------------------------\nstatic void DoFileRenaming(const char * FileName)\n{\n    int PrefixPart = 0; // Where the actual filename starts.\n    int ExtensionPart;  // Where the file extension starts.\n    int a;\n    struct tm tm;\n    char NewBaseName[PATH_MAX*2];\n    int AddLetter = 0;\n    char NewName[PATH_MAX+2];\n\n    ExtensionPart = strlen(FileName);\n    for (a=0;FileName[a];a++){\n        if (FileName[a] == SLASH){\n            // Don't count path component.\n            PrefixPart = a+1;\n        }\n\n        if (FileName[a] == '.') ExtensionPart = a;  // Remember where extension starts.\n    }\n    if (ExtensionPart < PrefixPart) { // no extension found\n        ExtensionPart = strlen(FileName);\n    }\n\n    if (!Exif2tm(&tm, ImageInfo.DateTime)){\n        printf(\"File '%s' contains no exif date stamp.  Using file date\\n\",FileName);\n        // Use file date/time instead.\n        tm = *localtime(&ImageInfo.FileDateTime);\n    }\n\n\n    strncpy(NewBaseName, FileName, PATH_MAX); // Get path component of name.\n\n    if (strftime_args){\n        // Complicated scheme for flexibility.  Just pass the args to strftime.\n        time_t UnixTime;\n\n        char *s;\n        char pattern[PATH_MAX+20];\n        int n = ExtensionPart - PrefixPart;\n\n        // Call mktime to get weekday and such filled in.\n        UnixTime = mktime(&tm);\n        if ((int)UnixTime == -1){\n            printf(\"Could not convert %s to unix time\",ImageInfo.DateTime);\n            return;\n        }\n\n        // Substitute \"%f\" for the original name (minus path & extension)\n        pattern[PATH_MAX-1]=0;\n        strncpy(pattern, strftime_args, PATH_MAX-1);\n        while ((s = strstr(pattern, \"%f\")) && strlen(pattern) + n < PATH_MAX-1){\n            memmove(s + n, s + 2, strlen(s+2) + 1);\n            memmove(s, FileName + PrefixPart, n);\n        }\n\n        {\n            // Sequential number renaming part.\n            // '%i' type pattern becomes sequence number.\n            int ppos = -1;\n            for (a=0;pattern[a];a++){\n                if (pattern[a] == '%'){\n                     ppos = a;\n                }else if (pattern[a] == 'i'){\n                    if (ppos >= 0 && a<ppos+4){\n                        // Replace this part with a number.\n                        char pat[8], num[16];\n                        int l,nl;\n                        memcpy(pat, pattern+ppos, 4);\n                        pat[a-ppos] = 'd'; // Replace 'i' with 'd' for '%d'\n                        pat[a-ppos+1] = '\\0';\n                        sprintf(num, pat, FileSequence); // let printf do the number formatting.\n                        nl = strlen(num);\n                        l = strlen(pattern+a+1);\n                        if (ppos+nl+l+1 >= PATH_MAX) ErrFatal(\"str overflow\");\n                        memmove(pattern+ppos+nl, pattern+a+1, l+1);\n                        memcpy(pattern+ppos, num, nl);\n                        break;\n                    }\n                }else if (!isdigit(pattern[a])){\n                    ppos = -1;\n                }\n            }\n        }\n        strftime(NewName, PATH_MAX, pattern, &tm);\n    }else{\n        // My favourite scheme.\n        sprintf(NewName, \"%02d%02d-%02d%02d%02d\",\n             tm.tm_mon+1, tm.tm_mday, tm.tm_hour, tm.tm_min, tm.tm_sec);\n    }\n\n    NewBaseName[PrefixPart] = 0;\n    CatPath(NewBaseName, NewName);\n\n    AddLetter = isdigit(NewBaseName[strlen(NewBaseName)-1]);\n    for (a=0;;a++){\n        char NewName[PATH_MAX*2+10];\n        char NameExtra[3];\n        struct stat dummy;\n\n        if (a){\n            // Generate a suffix for the file name if previous choice of names is taken.\n            // depending on whether the name ends in a letter or digit, pick the opposite to separate\n            // it.  This to avoid using a separator character - this because any good separator\n            // is before the '.' in ascii, and so sorting the names would put the later name before\n            // the name without suffix, causing the pictures to more likely be out of order.\n            if (AddLetter){\n                NameExtra[0] = (char)('a'-1+a); // Try a,b,c,d... for suffix if it ends in a number.\n            }else{\n                NameExtra[0] = (char)('0'-1+a); // Try 0,1,2,3... for suffix if it ends in a latter.\n            }\n            NameExtra[1] = 0;\n        }else{\n            NameExtra[0] = 0;\n        }\n\n        snprintf(NewName, sizeof(NewName), \"%s%s.jpg\", NewBaseName, NameExtra);\n\n        if (!strcmp(FileName, NewName)) break; // Skip if its already this name.\n\n        if (!EnsurePathExists(NewBaseName)){\n            break;\n        }\n\n\n        if (stat(NewName, &dummy)){\n            // This name does not pre-exist.\n            if (rename(FileName, NewName) == 0){\n                printf(\"%s --> %s\\n\",FileName, NewName);\n#ifdef _WIN32\n                if (RenameAssociatedFiles){\n                    sprintf(NewName, \"%s%s\", NewBaseName, NameExtra);\n                    RenameAssociated(FileName, NewName);\n                }\n#endif\n            }else{\n                printf(\"Error: Couldn't rename '%s' to '%s'\\n\",FileName, NewName);\n            }\n            break;\n\n        }\n\n        if (a > 25 || (!AddLetter && a > 9)){\n            printf(\"Possible new names for for '%s' already exist\\n\",FileName);\n            break;\n        }\n    }\n}\n\n//--------------------------------------------------------------------------\n// Rotate the image and its thumbnail\n//--------------------------------------------------------------------------\nstatic int DoAutoRotate(const char * FileName)\n{\n    if (ImageInfo.Orientation != 1){\n        const char * Argument;\n        Argument = ClearOrientation();\n        if (Argument == NULL) return FALSE; // orientation tag in image, nothing changed.\n\n        if (!ZeroRotateTagOnly){\n            char RotateCommand[PATH_MAX*2+50];\n            if (strlen(Argument) == 0){\n                // Unknown orientation, but still modified.\n                return TRUE; // Image is still modified.\n            }\n            sprintf(RotateCommand, \"jpegtran -trim -%s -outfile &o &i\", Argument);\n            ApplyCommand = RotateCommand;\n            DoCommand(FileName, FALSE);\n            ApplyCommand = NULL;\n\n            // Now rotate the thumbnail, if there is one.\n            if (ImageInfo.ThumbnailOffset &&\n                ImageInfo.ThumbnailSize &&\n                ImageInfo.ThumbnailAtEnd){\n                // Must have a thumbnail that exists and is modifiable.\n\n                char ThumbTempName_in[PATH_MAX+5];\n                char ThumbTempName_out[PATH_MAX+5];\n\n                strcpy(ThumbTempName_in, FileName);\n                strcat(ThumbTempName_in, \".thi\");\n                strcpy(ThumbTempName_out, FileName);\n                strcat(ThumbTempName_out, \".tho\");\n                SaveThumbnail(ThumbTempName_in);\n                sprintf(RotateCommand,\"jpegtran -trim -%s -outfile \\\"%s\\\" \\\"%s\\\"\",\n                    Argument, ThumbTempName_out, ThumbTempName_in);\n\n                // Disallow characters in the filenames that could be used to execute arbitrary\n                // shell commands with system() below.\n                if (strpbrk(FileName, \"\\\";'&|`$\")) {\n                    ErrNonfatal(\"Command has invalid characters.\", 0, 0);\n                    unlink(ThumbTempName_in);\n                    return FALSE;\n                }\n\n                if (system(RotateCommand) == 0){\n                    // Put the thumbnail back in the header\n                    ReplaceThumbnail(ThumbTempName_out);\n                }\n\n                unlink(ThumbTempName_in);\n                unlink(ThumbTempName_out);\n            }\n        }\n        return TRUE;\n    }\n    return FALSE;\n}\n\n//--------------------------------------------------------------------------\n// Regenerate the thumbnail using mogrify\n//--------------------------------------------------------------------------\nstatic int RegenerateThumbnail(const char * FileName)\n{\n    char ThumbnailGenCommand[PATH_MAX*2+50];\n    if (ImageInfo.ThumbnailOffset == 0 || ImageInfo.ThumbnailAtEnd == FALSE){\n        // There is no thumbnail, or the thumbnail is not at the end.\n        return FALSE;\n    }\n\n    // Disallow characters in the filename that could be used to execute arbitrary\n    // shell commands with system() below.\n    if(strpbrk(FileName, \"\\\";'&|`$\")) {\n        ErrNonfatal(\"Filename has invalid characters.\", 0, 0);\n        return FALSE;\n    }\n\n    snprintf(ThumbnailGenCommand, sizeof(ThumbnailGenCommand),\n        \"mogrify -thumbnail %dx%d -quality 80 \\\"%s\\\"\",\n        RegenThumbnail, RegenThumbnail, FileName);\n\n    if (system(ThumbnailGenCommand) == 0){\n        // Put the thumbnail back in the header\n        return ReplaceThumbnail(FileName);\n    }else{\n        ErrFatal(\"Unable to run 'mogrify' command\");\n        return FALSE;\n    }\n}\n\n//--------------------------------------------------------------------------\n// Set file time as exif time.\n//--------------------------------------------------------------------------\nvoid FileTimeAsString(char * TimeStr)\n{\n    struct tm ts;\n    ts = *localtime(&ImageInfo.FileDateTime);\n    strftime(TimeStr, 20, \"%Y:%m:%d %H:%M:%S\", &ts);\n}\n\n//--------------------------------------------------------------------------\n// Do selected operations to one file at a time.\n//--------------------------------------------------------------------------\nstatic void ProcessFile(const char * FileName)\n{\n    int Modified = FALSE;\n    ReadMode_t ReadMode;\n\n    if (strlen(FileName) >= PATH_MAX-1){\n        // Protect against buffer overruns in strcpy / strcat's on filename\n        ErrFatal(\"filename too long\");\n    }\n\n    ReadMode = READ_METADATA;\n    CurrentFile = FileName;\n    FilesMatched = 1;\n\n    ResetJpgfile();\n    Clear_EXIF();\n\n    // Start with an empty image information structure.\n    memset(&ImageInfo, 0, sizeof(ImageInfo));\n    ImageInfo.FlashUsed = -1;\n    ImageInfo.MeteringMode = -1;\n    ImageInfo.Whitebalance = -1;\n\n    // Store file date/time.\n    {\n        struct stat st;\n        if (stat(FileName, &st) >= 0){\n            ImageInfo.FileDateTime = st.st_mtime;\n            ImageInfo.FileSize = st.st_size;\n        }else{\n            ErrFatal(\"No such file\");\n        }\n    }\n\n    if ((DoModify & MODIFY_ANY) || RenameToDate || Exif2FileTime){\n        if (access(FileName, 2 /*W_OK*/)){\n            printf(\"Skipping readonly file '%s'\\n\",FileName);\n            return;\n        }\n    }\n\n    strncpy(ImageInfo.FileName, FileName, PATH_MAX);\n\n\n    if (ApplyCommand || AutoRotate){\n        // Applying a command is special - the headers from the file have to be\n        // pre-read, then the command executed, and then the image part of the file read.\n\n        if (!ReadJpegFile(FileName, READ_METADATA)) return;\n\n        #ifdef MATTHIAS\n            if (AutoResize){\n                // Automatic resize computation - to customize for each run...\n                if (AutoResizeCmdStuff() == 0){\n                    DiscardData();\n                    return;\n                }\n            }\n        #endif // MATTHIAS\n\n\n        if (CheckFileSkip()){\n            DiscardData();\n            return;\n        }\n\n        DiscardAllButExif();\n\n        if (AutoRotate){\n            if (DoAutoRotate(FileName)){\n                Modified = TRUE;\n            }\n        }else{\n            struct stat dummy;\n            DoCommand(FileName, Quiet ? FALSE : TRUE);\n\n            if (stat(FileName, &dummy)){\n                // The file is not there anymore. Perhaps the command\n                // was a delete or a move.  So we are all done.\n                return;\n            }\n            Modified = TRUE;\n        }\n        ReadMode = READ_IMAGE;   // Don't re-read exif section again on next read.\n    }\n\n    if (ExifXferScrFile){\n        char RelativeExifName[PATH_MAX+1];\n        // Make a relative name.\n        RelativeName(RelativeExifName, ExifXferScrFile, FileName);\n        if(!ReadJpegFile(RelativeExifName, READ_METADATA)) return;\n\n        DiscardAllButExif();    // Don't re-read exif section again on next read.\n\n        Modified = TRUE;\n        ReadMode = READ_IMAGE;\n    }\n\n    if (DoModify){\n        ReadMode |= READ_IMAGE;\n    }\n\n    if (!ReadJpegFile(FileName, ReadMode)) return;\n\n    if (CheckFileSkip()){\n        DiscardData();\n        return;\n    }\n\n    if (TrimExifTrailingZeroes){\n        if (ImageInfo.ThumbnailAtEnd){\n            Section_t * ExifSection;\n            int NumRedundant, WasRedundant;\n            unsigned char * StartRedundant;\n            //printf(\"Exif: Thumbnail %d - %d\\n\",ImageInfo.ThumbnailOffset, ImageInfo.ThumbnailOffset+ImageInfo.ThumbnailSize);\n            ExifSection = FindSection(M_EXIF);\n\n            StartRedundant = ExifSection->Data + 8 + ImageInfo.ThumbnailOffset+ImageInfo.ThumbnailSize;\n            WasRedundant = NumRedundant = (ExifSection->Size) - (ImageInfo.ThumbnailOffset + ImageInfo.ThumbnailSize + 8);\n\n            //printf(\"Exif length: %d  Wasted: %d\\n\",ExifSection->Size, NumRedundant);\n\n            for(;NumRedundant > 0 && StartRedundant[NumRedundant-1] == 0;NumRedundant--);// Only remove trailing bytes if they are zero.\n\n            if (NumRedundant != WasRedundant){\n                int NewExifSize;\n                printf(\"Trimming %d bytes from exif in %s\\n\", WasRedundant-NumRedundant, FileName);\n                NewExifSize = ImageInfo.ThumbnailOffset + ImageInfo.ThumbnailSize + 8 + NumRedundant;\n                ExifSection->Data[0] = (uchar)(NewExifSize >> 8); // Must write new length into exif data.\n                ExifSection->Data[1] = (uchar)NewExifSize;\n                ExifSection->Size = NewExifSize;\n                Modified = TRUE;\n            }else{\n                //printf(\"Noting to remove from %s\\n\", FileName);\n            }\n        }\n    }\n\n    FileSequence += 1; // Count files processed.\n\n    if (ShowConcise){\n        ShowConciseImageInfo();\n    }else{\n        if (!(DoModify) || ShowTags){\n            ShowImageInfo(ShowFileInfo);\n\n            {\n                // if IPTC section is present, show it also.\n                Section_t * IptcSection;\n                IptcSection = FindSection(M_IPTC);\n\n                if (IptcSection){\n                    show_IPTC(IptcSection->Data, IptcSection->Size);\n                }\n            }\n            printf(\"\\n\");\n        }\n    }\n\n    if (ThumbSaveName){\n        char OutFileName[PATH_MAX+1];\n        // Make a relative name.\n        RelativeName(OutFileName, ThumbSaveName, FileName);\n\n        if (SaveThumbnail(OutFileName)){\n            printf(\"Created: '%s'\\n\", OutFileName);\n        }\n    }\n\n    if (CreateExifSection){\n        // Make a new minimal exif section\n        create_EXIF();\n        Modified = TRUE;\n    }\n\n    if (RegenThumbnail){\n        if (RegenerateThumbnail(FileName)){\n            Modified = TRUE;\n        }\n    }\n\n    if (ThumbInsertName){\n        char ThumbFileName[PATH_MAX+1];\n        // Make a relative name.\n        RelativeName(ThumbFileName, ThumbInsertName, FileName);\n\n        if (ReplaceThumbnail(ThumbFileName)){\n            Modified = TRUE;\n        }\n    }else if (TrimExif){\n        // Deleting thumbnail is just replacing it with a null thumbnail.\n        if (ReplaceThumbnail(NULL)){\n            Modified = TRUE;\n        }\n    }\n\n    if (\n#ifdef MATTHIAS\n        AddComment || RemComment ||\n#endif\n                   EditComment || CommentInsertfileName || CommentInsertLiteral){\n\n        Section_t * CommentSec;\n        char Comment[MAX_COMMENT_SIZE+1];\n        int CommentSize;\n\n        CommentSec = FindSection(M_COM);\n\n        if (CommentSec == NULL){\n            unsigned char * DummyData;\n\n            DummyData = (uchar *) malloc(3);\n            DummyData[0] = 0;\n            DummyData[1] = 2;\n            DummyData[2] = 0;\n            CommentSec = CreateSection(M_COM, DummyData, 2);\n        }\n\n        CommentSize = CommentSec->Size-2;\n        if (CommentSize > MAX_COMMENT_SIZE){\n            fprintf(stderr, \"Truncating comment at %d chars\\n\",MAX_COMMENT_SIZE);\n            CommentSize = MAX_COMMENT_SIZE;\n        }\n\n        if (CommentInsertfileName){\n            // Read a new comment section from file.\n            char CommentFileName[PATH_MAX+1];\n            FILE * CommentFile;\n\n            // Make a relative name.\n            RelativeName(CommentFileName, CommentInsertfileName, FileName);\n\n            CommentFile = fopen(CommentFileName,\"r\");\n            if (CommentFile == NULL){\n                printf(\"Could not open '%s'\\n\",CommentFileName);\n            }else{\n                // Read it in.\n                // Replace the section.\n                CommentSize = fread(Comment, 1, MAX_COMMENT_SIZE, CommentFile);\n                fclose(CommentFile);\n                if (CommentSize < 0) CommentSize = 0;\n            }\n        }else if (CommentInsertLiteral){\n            strncpy(Comment, CommentInsertLiteral, MAX_COMMENT_SIZE);\n            CommentSize = strlen(Comment);\n        }else{\n#ifdef MATTHIAS\n            char CommentZt[MAX_COMMENT_SIZE+1];\n            memcpy(CommentZt, (char *)CommentSec->Data+2, CommentSize);\n            CommentZt[CommentSize] = '\\0';\n            if (ModifyDescriptComment(Comment, CommentZt)){\n                Modified = TRUE;\n                CommentSize = strlen(Comment);\n            }\n            if (EditComment)\n#else\n            memcpy(Comment, (char *)CommentSec->Data+2, CommentSize);\n#endif\n            {\n                char EditFileName[PATH_MAX+5];\n                strcpy(EditFileName, FileName);\n                strcat(EditFileName, \".txt\");\n\n                CommentSize = FileEditComment(EditFileName, Comment, CommentSize);\n            }\n        }\n\n        if (strcmp(Comment, (char *)CommentSec->Data+2)){\n            // Discard old comment section and put a new one in.\n            int size;\n            size = CommentSize+2;\n            free(CommentSec->Data);\n            CommentSec->Size = size;\n            CommentSec->Data = malloc(size);\n            CommentSec->Data[0] = (uchar)(size >> 8);\n            CommentSec->Data[1] = (uchar)(size);\n            memcpy((CommentSec->Data)+2, Comment, size-2);\n            Modified = TRUE;\n        }\n        if (!Modified){\n            printf(\"Comment not modified\\n\");\n        }\n    }\n\n\n    if (CommentSavefileName){\n        Section_t * CommentSec;\n        CommentSec = FindSection(M_COM);\n\n        if (CommentSec != NULL){\n            char OutFileName[PATH_MAX+1];\n            FILE * CommentFile;\n\n            // Make a relative name.\n            RelativeName(OutFileName, CommentSavefileName, FileName);\n\n            CommentFile = fopen(OutFileName,\"w\");\n            if (CommentFile){\n                fwrite((char *)CommentSec->Data+2 ,CommentSec->Size-2, 1, CommentFile);\n                fclose(CommentFile);\n            }else{\n                ErrFatal(\"Could not write comment file\");\n            }\n        }else{\n            printf(\"File '%s' contains no comment section\\n\",FileName);\n        }\n    }\n\n    if (ExifTimeAdjust || ExifTimeSet || DateSetChars || FileTimeToExif){\n       if (ImageInfo.numDateTimeTags){\n            struct tm tm;\n            time_t UnixTime;\n            char TempBuf[50];\n            int a;\n            Section_t * ExifSection;\n            if (ExifTimeSet){\n                // A time to set was specified.\n                UnixTime = ExifTimeSet;\n            }else{\n                if (FileTimeToExif){\n                    FileTimeAsString(ImageInfo.DateTime);\n                }\n                if (DateSetChars){\n                    memcpy(ImageInfo.DateTime, DateSet, DateSetChars);\n                    a = 1970;\n                    sscanf(DateSet, \"%d\", &a);\n                    if (a < 1970){\n                        strcpy(TempBuf, ImageInfo.DateTime);\n                        goto skip_unixtime;\n                    }\n                }\n                // A time offset to adjust by was specified.\n                if (!Exif2tm(&tm, ImageInfo.DateTime)) goto badtime;\n\n                // Convert to unix 32 bit time value, add offset, and convert back.\n                UnixTime = mktime(&tm);\n                if ((int)UnixTime == -1) goto badtime;\n                UnixTime += ExifTimeAdjust;\n            }\n            tm = *localtime(&UnixTime);\n\n            // Print to temp buffer first to avoid putting null termination in destination.\n            // snprintf() would do the trick, but not available everywhere (like FreeBSD 4.4)\n            sprintf(TempBuf, \"%04d:%02d:%02d %02d:%02d:%02d\",\n                tm.tm_year+1900, tm.tm_mon+1, tm.tm_mday,\n                tm.tm_hour, tm.tm_min, tm.tm_sec);\n\nskip_unixtime:\n            ExifSection = FindSection(M_EXIF);\n\n            for (a = 0; a < ImageInfo.numDateTimeTags; a++) {\n                uchar * Pointer;\n                Pointer = ExifSection->Data+ImageInfo.DateTimeOffsets[a]+8;\n                memcpy(Pointer, TempBuf, 19);\n            }\n            memcpy(ImageInfo.DateTime, TempBuf, 19);\n\n            Modified = TRUE;\n        }else{\n            printf(\"File '%s' contains no Exif timestamp to change\\n\", FileName);\n        }\n    }\n\n    if (DeleteComments){\n        if (RemoveSectionType(M_COM)) Modified = TRUE;\n    }\n    if (DeleteExif){\n        if (RemoveSectionType(M_EXIF)) Modified = TRUE;\n    }\n    if (DeleteIptc){\n        if (RemoveSectionType(M_IPTC)) Modified = TRUE;\n    }\n    if (DeleteXmp){\n        if (RemoveSectionType(M_XMP)) Modified = TRUE;\n    }\n    if (DeleteUnknown){\n        if (RemoveUnknownSections()) Modified = TRUE;\n    }\n\n\n    if (Modified){\n        char BackupName[PATH_MAX+5];\n        struct stat buf;\n\n        if (!Quiet) printf(\"Modified: %s\\n\",FileName);\n\n        strcpy(BackupName, FileName);\n        strcat(BackupName, \".t\");\n\n        // Remove any .old file name that may pre-exist\n        unlink(BackupName);\n\n        // Rename the old file.\n        rename(FileName, BackupName);\n\n        // Write the new file.\n        WriteJpegFile(FileName);\n\n        // Copy the access rights from original file\n        if (stat(BackupName, &buf) == 0){\n            // set Unix access rights and time to new file\n            struct utimbuf mtime;\n            chmod(FileName, buf.st_mode);\n\n            mtime.actime = buf.st_mtime;\n            mtime.modtime = buf.st_mtime;\n\n            utime(FileName, &mtime);\n        }\n\n        // Now that we are done, remove original file.\n        unlink(BackupName);\n    }\n\n\n    if (Exif2FileTime){\n        // Set the file date to the date from the exif header.\n        if (ImageInfo.numDateTimeTags){\n            // Convert the file date to Unix time.\n            struct tm tm;\n            time_t UnixTime;\n            struct utimbuf mtime;\n          if (!Exif2tm(&tm, ImageInfo.DateTime)) goto badtime;\n            UnixTime = mktime(&tm);\n            if ((int)UnixTime == -1){\n                goto badtime;\n            }\n            mtime.actime = UnixTime;\n            mtime.modtime = UnixTime;\n\n            if (utime(FileName, &mtime) != 0){\n                printf(\"Error: Could not change time of file '%s'\\n\",FileName);\n            }else{\n                if (!Quiet) printf(\"%s\\n\",FileName);\n            }\n        }else{\n            printf(\"File '%s' contains no Exif timestamp\\n\", FileName);\n        }\n    }\n\n    // Feature to rename image according to date and time from camera.\n    // I use this feature to put images from multiple digicams in sequence.\n\n    if (RenameToDate){\n        DoFileRenaming(FileName);\n    }\n    DiscardData();\n    return;\nbadtime:\n    printf(\"Error: Time '%s': cannot convert to Unix time\\n\",ImageInfo.DateTime);\n    DiscardData();\n}\n\n//--------------------------------------------------------------------------\n// complain about bad state of the command line.\n//--------------------------------------------------------------------------\nstatic void Usage (void)\n{\n    printf(\"Jhead is a program for manipulating settings and thumbnails in Exif jpeg headers\\n\"\n           \"used by most Digital Cameras.  v\"JHEAD_VERSION\" Matthias Wandel, Oct 5 2020.\\n\"\n           \"http://www.sentex.net/~mwandel/jhead\\n\"\n           \"\\n\");\n\n    printf(\"Usage: %s [options] files\\n\", progname);\n    printf(\"Where:\\n\"\n           \" files       path/filenames with or without wildcards\\n\"\n\n           \"[options] are:\\n\"\n           \"\\nGENERAL METADATA:\\n\"\n           \"  -te <name> Transfer exif header from another image file <name>\\n\"\n           \"             Uses same name mangling as '-st' option\\n\"\n           \"  -dc        Delete comment field (as left by progs like Photoshop & Compupic)\\n\"\n           \"  -de        Strip Exif section (smaller JPEG file, but lose digicam info)\\n\"\n           \"  -di        Delete IPTC section (from Photoshop, or Picasa)\\n\"\n           \"  -dx        Delete XMP section\\n\"\n           \"  -du        Delete non image sections except for Exif and comment sections\\n\"\n           \"  -purejpg   Strip all unnecessary data from jpeg (combines -dc -de and -du)\\n\"\n           \"  -mkexif    Create new minimal exif section (overwrites pre-existing exif)\\n\"\n           \"  -ce        Edit comment field.  Uses environment variable 'editor' to\\n\"\n           \"             determine which editor to use.  If editor not set, uses VI\\n\"\n           \"             under Unix and notepad with windows\\n\"\n           \"  -cs <name> Save comment section to a file\\n\"\n           \"  -ci <name> Insert comment section from a file.  -cs and -ci use same naming\\n\"\n           \"             scheme as used by the -st option\\n\"\n           \"  -cl string Insert literal comment string\\n\"\n           \"  -zt        Trim exif header trailing zeroes (Nikon 1 wastes 30k that way)\\n\"\n\n           \"\\nDATE / TIME MANIPULATION:\\n\"\n           \"  -ft        Set file modification time to Exif time\\n\"\n           \"  -dsft      Set Exif time to file modification time\\n\"\n           \"  -n[format-string]\\n\"\n           \"             Rename files according to date.  Uses exif date if present, file\\n\"\n           \"             date otherwise.  If the optional format-string is not supplied,\\n\"\n           \"             the format is mmdd-hhmmss.  If a format-string is given, it is\\n\"\n           \"             is passed to the 'strftime' function for formatting\\n\"\n           \"             %%d Day of month    %%H Hour (24-hour)\\n\"\n           \"             %%m Month number    %%M Minute    %%S Second\\n\"\n           \"             %%y Year (2 digit 00 - 99)        %%Y Year (4 digit 1980-2036)\\n\"\n           \"             For more arguments, look up the 'strftime' function.\\n\"\n           \"             In addition to strftime format codes:\\n\"\n           \"             '%%f' as part of the string will include the original file name\\n\"\n           \"             '%%i' will include a sequence number, starting from 1. You can\\n\"\n           \"             You can specify '%%03i' for example to get leading zeros.\\n\"\n           \"             This feature is useful for ordering files from multiple digicams to\\n\"\n           \"             sequence of taking.\\n\"\n           \"             The '.jpg' is automatically added to the end of the name.  If the\\n\"\n           \"             destination name already exists, a letter or digit is added to \\n\"\n           \"             the end of the name to make it unique.\\n\"\n           \"             The new name may include a path as part of the name.  If this path\\n\"\n           \"             does not exist, it will be created\\n\"\n           \"  -a         (Windows only) Rename files with same name but different extension\\n\"\n           \"             Use together with -n to rename .AVI files from exif in .THM files\\n\"\n           \"             for example\\n\"\n           \"  -ta<+|->h[:mm[:ss]]\\n\"\n           \"             Adjust time by h:mm forwards or backwards.  Useful when having\\n\"\n           \"             taken pictures with the wrong time set on the camera, such as when\\n\"\n           \"             traveling across time zones or DST changes. Dates can be adjusted\\n\"\n           \"             by offsetting by 24 hours or more.  For large date adjustments,\\n\"\n           \"             use the -da option\\n\"\n           \"  -da<date>-<date>\\n\"\n           \"             Adjust date by large amounts.  This is used to fix photos from\\n\"\n           \"             cameras where the date got set back to the default camera date\\n\"\n           \"             by accident or battery removal.\\n\"\n           \"             To deal with different months and years having different numbers of\\n\"\n           \"             days, a simple date-month-year offset would result in unexpected\\n\"\n           \"             results.  Instead, the difference is specified as desired date\\n\"\n           \"             minus original date.  Date is specified as yyyy:mm:dd or as date\\n\"\n           \"             and time in the format yyyy:mm:dd/hh:mm:ss\\n\"\n           \"  -ts<time>  Set the Exif internal time to <time>.  <time> is in the format\\n\"\n           \"             yyyy:mm:dd-hh:mm:ss\\n\"\n           \"  -tf file   Set the exif time to the modification time from another file\\n\"\n           \"  -ds<date>  Set the Exif internal date.  <date> is in the format YYYY:MM:DD\\n\"\n           \"             or YYYY:MM or YYYY\\n\"\n\n           \"\\nTHUMBNAIL MANIPULATION:\\n\"\n           \"  -dt        Remove exif integral thumbnails.  Typically trims 10k\\n\"\n           \"  -st <name> Save Exif thumbnail, if there is one, in file <name>\\n\"\n           \"             If output file name contains the substring \\\"&i\\\" then the\\n\"\n           \"             image file name is substitute for the &i.  Note that quotes around\\n\"\n           \"             the argument are required for the '&' to be passed to the program.\\n\"\n#ifndef _WIN32\n           \"             An output name of '-' causes thumbnail to be written to stdout\\n\"\n#endif\n           \"  -rt <name> Replace Exif thumbnail.  Can only be done with headers that\\n\"\n           \"             already contain a thumbnail.\\n\"\n           \"  -rgt[size] Regenerate exif thumbnail.  Only works if image already\\n\"\n           \"             contains a thumbnail.  size specifies maximum height or width of\\n\"\n           \"             thumbnail.  Relies on 'mogrify' programs to be on path\\n\"\n\n           \"\\nROTATION TAG MANIPULATION:\\n\"\n           \"  -autorot   Invoke jpegtran to rotate images according to Exif orientation tag\\n\"\n           \"             and clear Exif orientation tag\\n\"\n           \"             Note: Windows users must get jpegtran for this to work\\n\"\n           \"  -norot     Zero out the rotation tag.  This to avoid some browsers from\\n\"\n           \"             rotating the image again after you rotated it but neglected to\\n\"\n           \"             clear the rotation tag\\n\"\n\n           \"\\nOUTPUT VERBOSITY CONTROL:\\n\"\n           \"  -h         help (this text)\\n\"\n           \"  -v         even more verbose output\\n\"\n           \"  -q         Quiet (no messages on success, like Unix)\\n\"\n           \"  -V         Show jhead version\\n\"\n           \"  -exifmap   Dump header bytes, annotate.  Pipe thru sort for better viewing\\n\"\n           \"  -se        Suppress error messages relating to corrupt exif header structure\\n\"\n           \"  -c         concise output\\n\"\n           \"  -nofinfo   Don't show file info (name/size/date)\\n\"\n\n           \"\\nFILE MATCHING AND SELECTION:\\n\"\n           \"  -model model\\n\"\n           \"             Only process files from digicam containing model substring in\\n\"\n           \"             camera model description\\n\"\n           \"  -exonly    Skip all files that don't have an exif header (skip all jpegs that\\n\"\n           \"             were not created by digicam)\\n\"\n           \"  -quality x Only work on images with JPEG quality factor x or higher\\n\"\n           \"  -cmd command\\n\"\n           \"             Apply 'command' to every file, then re-insert exif and command\\n\"\n           \"             sections into the image. &i will be substituted for the input file\\n\"\n           \"             name, and &o (if &o is used). Use quotes around the command string\\n\"\n           \"             This is most useful in conjunction with the free ImageMagick tool. \\n\"\n           \"             For example, with my Canon S100, which suboptimally compresses\\n\"\n           \"             jpegs I can specify\\n\"\n           \"                jhead -cmd \\\"mogrify -quality 80 &i\\\" *.jpg\\n\"\n           \"             to re-compress a lot of images using ImageMagick to half the size,\\n\"\n           \"             and no visible loss of quality while keeping the exif header\\n\"\n           \"             Another invocation I like to use is jpegtran (hard to find for\\n\"\n           \"             windows).  I type:\\n\"\n           \"                jhead -cmd \\\"jpegtran -progressive &i &o\\\" *.jpg\\n\"\n           \"             to convert jpegs to progressive jpegs (Unix jpegtran syntax\\n\"\n           \"             differs slightly)\\n\"\n           \"  -orp       Only operate on 'portrait' aspect ratio images\\n\"\n           \"  -orl       Only operate on 'landscape' aspect ratio images\\n\"\n#ifdef _WIN32\n           \"  -r         No longer supported.  Use the ** wildcard to recurse directories\\n\"\n           \"             with instead.\\n\"\n           \"             examples:\\n\"\n           \"                 jhead **/*.jpg\\n\"\n           \"                 jhead \\\"c:\\\\my photos\\\\**\\\\*.jpg\\\"\\n\"\n#endif\n\n\n#ifdef MATTHIAS\n           \"\\n\"\n           \"  -cr        Remove comment tag (my way)\\n\"\n           \"  -ca        Add comment tag (my way)\\n\"\n           \"  -ar        Auto resize to fit in 1024x1024, but never less than half\\n\"\n#endif //MATTHIAS\n\n\n           );\n\n    exit(EXIT_FAILURE);\n}\n\n\n//--------------------------------------------------------------------------\n// Parse specified date or date+time from command line.\n//--------------------------------------------------------------------------\nstatic time_t ParseCmdDate(char * DateSpecified)\n{\n    int a;\n    struct tm tm;\n    time_t UnixTime;\n\n    tm.tm_wday = -1;\n    tm.tm_hour = tm.tm_min = tm.tm_sec = 0;\n\n    a = sscanf(DateSpecified, \"%d:%d:%d/%d:%d:%d\",\n            &tm.tm_year, &tm.tm_mon, &tm.tm_mday,\n            &tm.tm_hour, &tm.tm_min, &tm.tm_sec);\n\n    if (a != 3 && a < 5){\n        // Date must be YYYY:MM:DD, YYYY:MM:DD+HH:MM\n        // or YYYY:MM:DD+HH:MM:SS\n        ErrFatal(\"Could not parse specified date\");\n    }\n    tm.tm_isdst = -1;\n    tm.tm_mon -= 1;      // Adjust for unix zero-based months\n    tm.tm_year -= 1900;  // Adjust for year starting at 1900\n\n    UnixTime = mktime(&tm);\n    if (UnixTime == -1){\n        ErrFatal(\"Specified time is invalid or out of range\");\n    }\n\n    return UnixTime;\n}\n\n//--------------------------------------------------------------------------\n// The main program.\n//--------------------------------------------------------------------------\nint main (int argc, char **argv)\n{\n    int argn;\n    char * arg;\n    progname = argv[0];\n\n    for (argn=1;argn<argc;argn++){\n        arg = argv[argn];\n        if (arg[0] != '-') break; // Filenames from here on.\n\n    // General metadata options:\n        if (!strcmp(arg,\"-te\")){\n            ExifXferScrFile = argv[++argn];\n            DoModify |= MODIFY_JPEG;\n        }else if (!strcmp(arg,\"-dc\")){\n            DeleteComments = TRUE;\n            DoModify |= MODIFY_JPEG;\n        }else if (!strcmp(arg,\"-de\")){\n            DeleteExif = TRUE;\n            DoModify |= MODIFY_JPEG;\n        }else if (!strcmp(arg,\"-di\")){\n            DeleteIptc = TRUE;\n            DoModify |= MODIFY_JPEG;\n        }else if (!strcmp(arg,\"-dx\")){\n            DeleteXmp = TRUE;\n            DoModify |= MODIFY_JPEG;\n        }else if (!strcmp(arg, \"-du\")){\n            DeleteUnknown = TRUE;\n            DoModify |= MODIFY_JPEG;\n        }else if (!strcmp(arg, \"-purejpg\")){\n            DeleteExif = TRUE;\n            DeleteComments = TRUE;\n            DeleteIptc = TRUE;\n            DeleteUnknown = TRUE;\n            DeleteXmp = TRUE;\n            DoModify |= MODIFY_JPEG;\n        }else if (!strcmp(arg,\"-ce\")){\n            EditComment = TRUE;\n            DoModify |= MODIFY_JPEG;\n        }else if (!strcmp(arg,\"-cs\")){\n            CommentSavefileName = argv[++argn];\n        }else if (!strcmp(arg,\"-ci\")){\n            CommentInsertfileName = argv[++argn];\n            DoModify |= MODIFY_JPEG;\n        }else if (!strcmp(arg,\"-cl\")){\n            CommentInsertLiteral = argv[++argn];\n            DoModify |= MODIFY_JPEG;\n        }else if (!strcmp(arg,\"-zt\")){\n            TrimExifTrailingZeroes = TRUE;\n            DoModify |= MODIFY_JPEG;\n        }else if (!strcmp(arg,\"-mkexif\")){\n            CreateExifSection = TRUE;\n            DoModify |= MODIFY_JPEG;\n    // Output verbosity control\n        }else if (!strcmp(arg,\"-h\") || !strcmp(arg,\"--help\")){\n            Usage();\n        }else if (!strcmp(arg,\"-v\")){\n            ShowTags = TRUE;\n        }else if (!strcmp(arg,\"-q\")){\n            Quiet = TRUE;\n        }else if (!strcmp(arg,\"-V\")){\n            printf(\"Jhead version: \"JHEAD_VERSION\"\\n\");\n            exit(0);\n        }else if (!strcmp(arg,\"-exifmap\")){\n            DumpExifMap = TRUE;\n        }else if (!strcmp(arg,\"-se\")){\n            SuppressNonFatalErrors = TRUE;\n        }else if (!strcmp(arg,\"-c\")){\n            ShowConcise = TRUE;\n        }else if (!strcmp(arg,\"-nofinfo\")){\n            ShowFileInfo = 0;\n\n    // Thumbnail manipulation options\n        }else if (!strcmp(arg,\"-dt\")){\n            TrimExif = TRUE;\n            DoModify |= MODIFY_JPEG;\n        }else if (!strcmp(arg,\"-st\")){\n            ThumbSaveName = argv[++argn];\n            DoModify |= READ_JPEG;\n        }else if (!strcmp(arg,\"-rt\")){\n            ThumbInsertName = argv[++argn];\n            DoModify |= MODIFY_JPEG;\n        }else if (!memcmp(arg,\"-rgt\", 4)){\n            RegenThumbnail = 160;\n            sscanf(arg+4, \"%d\", &RegenThumbnail);\n            if (RegenThumbnail > 320){\n                ErrFatal(\"Specified thumbnail geometry too big!\");\n            }\n            DoModify |= MODIFY_JPEG;\n\n    // Rotation tag manipulation\n        }else if (!strcmp(arg,\"-autorot\")){\n            AutoRotate = 1;\n            DoModify |= MODIFY_JPEG;\n        }else if (!strcmp(arg,\"-norot\")){\n            AutoRotate = 1;\n            ZeroRotateTagOnly = 1;\n            DoModify |= MODIFY_JPEG;\n\n    // Date/Time manipulation options\n        }else if (!memcmp(arg,\"-n\",2)){\n            RenameToDate = 1;\n            DoModify |= READ_JPEG; // Rename doesn't modify file, so count as read action.\n            arg+=2;\n            if (*arg == 'f'){\n                // Accept -nf, but -n does the same thing now.\n                arg++;\n            }\n            if (*arg){\n                // A strftime format string is supplied.\n                strftime_args = arg;\n                #ifdef _WIN32\n                    SlashToNative(strftime_args);\n                #endif\n                //printf(\"strftime_args = %s\\n\",arg);\n            }\n        }else if (!strcmp(arg,\"-a\")){\n            #ifndef _WIN32\n                ErrFatal(\"Error: -a only supported in Windows version\");\n            #else\n                RenameAssociatedFiles = TRUE;\n            #endif\n        }else if (!strcmp(arg,\"-ft\")){\n            Exif2FileTime = TRUE;\n            DoModify |= MODIFY_ANY;\n        }else if (!memcmp(arg,\"-ta\",3)){\n            // Time adjust feature.\n            int hours, minutes, seconds, n;\n            minutes = seconds = 0;\n            if (arg[3] != '-' && arg[3] != '+'){\n                ErrFatal(\"Error: -ta must be followed by +/- and a time\");\n            }\n            n = sscanf(arg+4, \"%d:%d:%d\", &hours, &minutes, &seconds);\n\n            if (n < 1){\n                ErrFatal(\"Error: -ta must be immediately followed by time\");\n            }\n            if (ExifTimeAdjust) ErrFatal(\"Can only use one of -da or -ta options at once\");\n            ExifTimeAdjust = hours*3600 + minutes*60 + seconds;\n            if (arg[3] == '-') ExifTimeAdjust = -ExifTimeAdjust;\n            DoModify |= MODIFY_JPEG;\n        }else if (!memcmp(arg,\"-da\",3)){\n            // Date adjust feature (large time adjustments)\n            time_t NewDate, OldDate = 0;\n            char * pOldDate;\n            NewDate = ParseCmdDate(arg+3);\n            pOldDate = strstr(arg+1, \"-\");\n            if (pOldDate){\n                OldDate = ParseCmdDate(pOldDate+1);\n            }else{\n                ErrFatal(\"Must specify second date for -da option\");\n            }\n            if (ExifTimeAdjust) ErrFatal(\"Can only use one of -da or -ta options at once\");\n            ExifTimeAdjust = NewDate-OldDate;\n            DoModify |= MODIFY_JPEG;\n        }else if (!memcmp(arg,\"-dsft\",5)){\n            // Set exif time to the timestamp of the file.\n            FileTimeToExif = TRUE;\n            DoModify |= MODIFY_JPEG;\n        }else if (!memcmp(arg,\"-ds\",3)){\n            // Set date feature\n            int a;\n            // Check date validity and copy it.  Could be incompletely specified.\n            strcpy(DateSet, \"0000:01:01\");\n            for (a=0;arg[a+3] && a < sizeof(DateSet);a++){\n                if (isdigit(DateSet[a])){\n                    if (!isdigit(arg[a+3])){\n                        a = 0;\n                        break;\n                    }\n                }else{\n                    if (arg[a+3] != ':'){\n                        a=0;\n                        break;\n                    }\n                }\n                DateSet[a] = arg[a+3];\n            }\n            if (a < 4 || a > 10){\n                ErrFatal(\"Date must be in format YYYY, YYYY:MM, or YYYY:MM:DD\");\n            }\n            DateSetChars = a;\n            DoModify |= MODIFY_JPEG;\n        }else if (!memcmp(arg,\"-ts\",3)){\n            // Set the exif time.\n            // Time must be specified as \"yyyy:mm:dd-hh:mm:ss\"\n            char * c;\n            struct tm tm;\n\n            c = strstr(arg+1, \"-\");\n            if (c) *c = ' '; // Replace '-' with a space.\n\n            if (!Exif2tm(&tm, arg+3)){\n                ErrFatal(\"-ts option must be followed by time in format yyyy:mm:dd-hh:mm:ss\\n\"\n                        \"Example: jhead -ts2001:01:01-12:00:00 foo.jpg\");\n            }\n\n            ExifTimeSet  = mktime(&tm);\n\n            if ((int)ExifTimeSet == -1) ErrFatal(\"Time specified is out of range\");\n            DoModify |= MODIFY_JPEG;\n\n        }else if (!memcmp(arg,\"-tf\",3)){\n            // Set the exif time to the modification time from another file.\n            struct stat stat_buf;\n            if (stat(argv[++argn], &stat_buf) == 0){\n                ExifTimeSet = stat_buf.st_mtime;\n            }else{\n                ErrFatal(\"Could not read file\");\n            }\n            DoModify |= MODIFY_JPEG;\n\n    // File matching and selection\n        }else if (!strcmp(arg,\"-model\")){\n            if (argn+1 >= argc) Usage(); // No extra argument.\n            FilterModel = argv[++argn];\n        }else if (!strcmp(arg,\"-quality\")){\n            if (argn+1 >= argc) Usage(); // No extra argument.\n            if (sscanf(argv[++argn], \"%d\", &FilterQuality) != 1){\n                Usage();\n            }\n        }else if (!strcmp(arg,\"-proc\")){\n            sscanf(argv[++argn], \"%d\", &ProcessOnly);\n            if (ProcessOnly < 0 || ProcessOnly > 2){\n                ErrFatal(\"-proc must be followed by a number 0-2\");\n            }\n        }else if (!strcmp(arg,\"-exonly\")){\n            ExifOnly = 1;\n        }else if (!strcmp(arg,\"-orp\")){\n            PortraitOnly = 1;\n        }else if (!strcmp(arg,\"-orl\")){\n            PortraitOnly = -1;\n        }else if (!strcmp(arg,\"-cmd\")){\n            if (argn+1 >= argc) Usage(); // No extra argument.\n            ApplyCommand = argv[++argn];\n            DoModify |= MODIFY_ANY;\n\n#ifdef MATTHIAS\n        }else if (!strcmp(arg,\"-ca\")){\n            // Its a literal comment.  Add.\n            AddComment = argv[++argn];\n            DoModify |= MODIFY_JPEG;\n        }else if (!strcmp(arg,\"-cr\")){\n            // Its a literal comment.  Remove this keyword.\n            RemComment = argv[++argn];\n            DoModify |= MODIFY_JPEG;\n        }else if (!strcmp(arg,\"-ar\")){\n            AutoResize = TRUE;\n            ShowConcise = TRUE;\n            ApplyCommand = (char *)1; // Must be non null so it does commands.\n            DoModify |= MODIFY_JPEG;\n#endif // MATTHIAS\n        }else{\n            printf(\"Argument '%s' not understood\\n\",arg);\n            printf(\"Use jhead -h for list of arguments\\n\");\n            exit(-1);\n        }\n        if (argn >= argc){\n            // Used an extra argument - because the last argument\n            // used up an extr argument.\n            ErrFatal(\"Extra argument required\");\n        }\n    }\n    if (argn == argc){\n        ErrFatal(\"No files to process.  Use -h for help\");\n    }\n\n    if (ThumbSaveName != NULL && strcmp(ThumbSaveName, \"&i\") == 0){\n        printf(\"Error: By specifying \\\"&i\\\" for the thumbail name, your original file\\n\"\n               \"       will be overwritten.  If this is what you really want,\\n\"\n               \"       specify -st \\\"./&i\\\"  to override this check\\n\");\n        exit(0);\n    }\n\n    if (RegenThumbnail){\n        if (ThumbSaveName || ThumbInsertName){\n            printf(\"Error: Cannot regen and save or insert thumbnail in same run\\n\");\n            exit(0);\n        }\n    }\n\n    if (EditComment){\n        if (CommentSavefileName != NULL || CommentInsertfileName != NULL){\n            printf(\"Error: Cannot use -ce option in combination with -cs or -ci\\n\");\n            exit(0);\n        }\n    }\n\n\n    if (ExifXferScrFile){\n        if (FilterModel || ApplyCommand){\n            ErrFatal(\"Error: Filter by model and/or applying command to files\\n\"\n            \"   invalid while transferring Exif headers\");\n        }\n    }\n\n    FileSequence = 0;\n    for (;argn<argc;argn++){\n        FilesMatched = FALSE;\n\n        #ifdef _WIN32\n            SlashToNative(argv[argn]);\n            // Use my globbing module to do fancier wildcard expansion with recursive\n            // subdirectories under Windows.\n            MyGlob(argv[argn], ProcessFile);\n        #else\n            // Under linux, don't do any extra fancy globbing - shell globbing is\n            // pretty fancy as it is - although not as good as myglob.c\n            ProcessFile(argv[argn]);\n        #endif\n\n        if (!FilesMatched){\n            fprintf(stderr, \"Error: No files matched '%s'\\n\",argv[argn]);\n        }\n    }\n\n    if (FileSequence == 0){\n        return EXIT_FAILURE;\n    }else{\n        return EXIT_SUCCESS;\n    }\n}\n"], "filenames": ["jhead.c"], "buggy_code_start_loc": [403], "buggy_code_end_loc": [403], "fixing_code_start_loc": [404], "fixing_code_end_loc": [409], "type": "CWE-787", "message": "Matthias-Wandel/jhead jhead 3.06 is vulnerable to Buffer Overflow via shellescape(), jhead.c, jhead. jhead copies strings to a stack buffer when it detects a &i or &o. However, jhead does not check the boundary of the stack buffer. As a result, there will be a stack buffer overflow problem when multiple `&i` or `&o` are given.", "other": {"cve": {"id": "CVE-2022-28550", "sourceIdentifier": "cve@mitre.org", "published": "2023-06-13T20:15:08.907", "lastModified": "2023-06-23T20:10:56.137", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Matthias-Wandel/jhead jhead 3.06 is vulnerable to Buffer Overflow via shellescape(), jhead.c, jhead. jhead copies strings to a stack buffer when it detects a &i or &o. However, jhead does not check the boundary of the stack buffer. As a result, there will be a stack buffer overflow problem when multiple `&i` or `&o` are given."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:jhead_project:jhead:3.06:*:*:*:*:*:*:*", "matchCriteriaId": "D05C20ED-B09A-43EE-8D82-0524C33E0E60"}]}]}], "references": [{"url": "https://github.com/Matthias-Wandel/jhead/commit/64894dbc7d8e1e232e85f1cab25c64290b2fc167", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/Matthias-Wandel/jhead/issues/51", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Matthias-Wandel/jhead/commit/64894dbc7d8e1e232e85f1cab25c64290b2fc167"}}