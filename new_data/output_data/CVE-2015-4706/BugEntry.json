{"buggy_code": ["\"\"\"Base Tornado handlers for the notebook server.\"\"\"\n\n# Copyright (c) IPython Development Team.\n# Distributed under the terms of the Modified BSD License.\n\nimport functools\nimport json\nimport logging\nimport os\nimport re\nimport sys\nimport traceback\ntry:\n    # py3\n    from http.client import responses\nexcept ImportError:\n    from httplib import responses\n\nfrom jinja2 import TemplateNotFound\nfrom tornado import web\n\nfrom tornado import gen\nfrom tornado.log import app_log\n\n\nimport IPython\nfrom IPython.utils.sysinfo import get_sys_info\n\nfrom IPython.config import Application\nfrom IPython.utils.path import filefind\nfrom IPython.utils.py3compat import string_types\nfrom IPython.html.utils import is_hidden, url_path_join, url_escape\n\nfrom IPython.html.services.security import csp_report_uri\n\n#-----------------------------------------------------------------------------\n# Top-level handlers\n#-----------------------------------------------------------------------------\nnon_alphanum = re.compile(r'[^A-Za-z0-9]')\n\nsys_info = json.dumps(get_sys_info())\n\nclass AuthenticatedHandler(web.RequestHandler):\n    \"\"\"A RequestHandler with an authenticated user.\"\"\"\n\n    def set_default_headers(self):\n        headers = self.settings.get('headers', {})\n\n        if \"Content-Security-Policy\" not in headers:\n            headers[\"Content-Security-Policy\"] = (\n                    \"frame-ancestors 'self'; \"\n                    # Make sure the report-uri is relative to the base_url\n                    \"report-uri \" + url_path_join(self.base_url, csp_report_uri) + \";\"\n            )\n\n        # Allow for overriding headers\n        for header_name,value in headers.items() :\n            try:\n                self.set_header(header_name, value)\n            except Exception as e:\n                # tornado raise Exception (not a subclass)\n                # if method is unsupported (websocket and Access-Control-Allow-Origin\n                # for example, so just ignore)\n                self.log.debug(e)\n    \n    def clear_login_cookie(self):\n        self.clear_cookie(self.cookie_name)\n    \n    def get_current_user(self):\n        if self.login_handler is None:\n            return 'anonymous'\n        return self.login_handler.get_user(self)\n\n    @property\n    def cookie_name(self):\n        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(\n            self.request.host\n        ))\n        return self.settings.get('cookie_name', default_cookie_name)\n    \n    @property\n    def logged_in(self):\n        \"\"\"Is a user currently logged in?\"\"\"\n        user = self.get_current_user()\n        return (user and not user == 'anonymous')\n\n    @property\n    def login_handler(self):\n        \"\"\"Return the login handler for this application, if any.\"\"\"\n        return self.settings.get('login_handler_class', None)\n\n    @property\n    def login_available(self):\n        \"\"\"May a user proceed to log in?\n\n        This returns True if login capability is available, irrespective of\n        whether the user is already logged in or not.\n\n        \"\"\"\n        if self.login_handler is None:\n            return False\n        return bool(self.login_handler.login_available(self.settings))\n\n\nclass IPythonHandler(AuthenticatedHandler):\n    \"\"\"IPython-specific extensions to authenticated handling\n    \n    Mostly property shortcuts to IPython-specific settings.\n    \"\"\"\n    \n    @property\n    def config(self):\n        return self.settings.get('config', None)\n    \n    @property\n    def log(self):\n        \"\"\"use the IPython log by default, falling back on tornado's logger\"\"\"\n        if Application.initialized():\n            return Application.instance().log\n        else:\n            return app_log\n\n    @property\n    def jinja_template_vars(self):\n        \"\"\"User-supplied values to supply to jinja templates.\"\"\"\n        return self.settings.get('jinja_template_vars', {})\n    \n    #---------------------------------------------------------------\n    # URLs\n    #---------------------------------------------------------------\n    \n    @property\n    def version_hash(self):\n        \"\"\"The version hash to use for cache hints for static files\"\"\"\n        return self.settings.get('version_hash', '')\n    \n    @property\n    def mathjax_url(self):\n        return self.settings.get('mathjax_url', '')\n    \n    @property\n    def base_url(self):\n        return self.settings.get('base_url', '/')\n\n    @property\n    def default_url(self):\n        return self.settings.get('default_url', '')\n\n    @property\n    def ws_url(self):\n        return self.settings.get('websocket_url', '')\n\n    @property\n    def contents_js_source(self):\n        self.log.debug(\"Using contents: %s\", self.settings.get('contents_js_source',\n            'services/contents'))\n        return self.settings.get('contents_js_source', 'services/contents')\n    \n    #---------------------------------------------------------------\n    # Manager objects\n    #---------------------------------------------------------------\n    \n    @property\n    def kernel_manager(self):\n        return self.settings['kernel_manager']\n\n    @property\n    def contents_manager(self):\n        return self.settings['contents_manager']\n    \n    @property\n    def cluster_manager(self):\n        return self.settings['cluster_manager']\n    \n    @property\n    def session_manager(self):\n        return self.settings['session_manager']\n    \n    @property\n    def terminal_manager(self):\n        return self.settings['terminal_manager']\n    \n    @property\n    def kernel_spec_manager(self):\n        return self.settings['kernel_spec_manager']\n\n    @property\n    def config_manager(self):\n        return self.settings['config_manager']\n\n    #---------------------------------------------------------------\n    # CORS\n    #---------------------------------------------------------------\n    \n    @property\n    def allow_origin(self):\n        \"\"\"Normal Access-Control-Allow-Origin\"\"\"\n        return self.settings.get('allow_origin', '')\n    \n    @property\n    def allow_origin_pat(self):\n        \"\"\"Regular expression version of allow_origin\"\"\"\n        return self.settings.get('allow_origin_pat', None)\n    \n    @property\n    def allow_credentials(self):\n        \"\"\"Whether to set Access-Control-Allow-Credentials\"\"\"\n        return self.settings.get('allow_credentials', False)\n    \n    def set_default_headers(self):\n        \"\"\"Add CORS headers, if defined\"\"\"\n        super(IPythonHandler, self).set_default_headers()\n        if self.allow_origin:\n            self.set_header(\"Access-Control-Allow-Origin\", self.allow_origin)\n        elif self.allow_origin_pat:\n            origin = self.get_origin()\n            if origin and self.allow_origin_pat.match(origin):\n                self.set_header(\"Access-Control-Allow-Origin\", origin)\n        if self.allow_credentials:\n            self.set_header(\"Access-Control-Allow-Credentials\", 'true')\n    \n    def get_origin(self):\n        # Handle WebSocket Origin naming convention differences\n        # The difference between version 8 and 13 is that in 8 the\n        # client sends a \"Sec-Websocket-Origin\" header and in 13 it's\n        # simply \"Origin\".\n        if \"Origin\" in self.request.headers:\n            origin = self.request.headers.get(\"Origin\")\n        else:\n            origin = self.request.headers.get(\"Sec-Websocket-Origin\", None)\n        return origin\n    \n    #---------------------------------------------------------------\n    # template rendering\n    #---------------------------------------------------------------\n    \n    def get_template(self, name):\n        \"\"\"Return the jinja template object for a given name\"\"\"\n        return self.settings['jinja2_env'].get_template(name)\n    \n    def render_template(self, name, **ns):\n        ns.update(self.template_namespace)\n        template = self.get_template(name)\n        return template.render(**ns)\n    \n    @property\n    def template_namespace(self):\n        return dict(\n            base_url=self.base_url,\n            default_url=self.default_url,\n            ws_url=self.ws_url,\n            logged_in=self.logged_in,\n            login_available=self.login_available,\n            static_url=self.static_url,\n            sys_info=sys_info,\n            contents_js_source=self.contents_js_source,\n            version_hash=self.version_hash,\n            **self.jinja_template_vars\n        )\n    \n    def get_json_body(self):\n        \"\"\"Return the body of the request as JSON data.\"\"\"\n        if not self.request.body:\n            return None\n        # Do we need to call body.decode('utf-8') here?\n        body = self.request.body.strip().decode(u'utf-8')\n        try:\n            model = json.loads(body)\n        except Exception:\n            self.log.debug(\"Bad JSON: %r\", body)\n            self.log.error(\"Couldn't parse JSON\", exc_info=True)\n            raise web.HTTPError(400, u'Invalid JSON in body of request')\n        return model\n\n    def write_error(self, status_code, **kwargs):\n        \"\"\"render custom error pages\"\"\"\n        exc_info = kwargs.get('exc_info')\n        message = ''\n        status_message = responses.get(status_code, 'Unknown HTTP Error')\n        if exc_info:\n            exception = exc_info[1]\n            # get the custom message, if defined\n            try:\n                message = exception.log_message % exception.args\n            except Exception:\n                pass\n            \n            # construct the custom reason, if defined\n            reason = getattr(exception, 'reason', '')\n            if reason:\n                status_message = reason\n        \n        # build template namespace\n        ns = dict(\n            status_code=status_code,\n            status_message=status_message,\n            message=message,\n            exception=exception,\n        )\n        \n        self.set_header('Content-Type', 'text/html')\n        # render the template\n        try:\n            html = self.render_template('%s.html' % status_code, **ns)\n        except TemplateNotFound:\n            self.log.debug(\"No template for %d\", status_code)\n            html = self.render_template('error.html', **ns)\n        \n        self.write(html)\n        \n\n\nclass Template404(IPythonHandler):\n    \"\"\"Render our 404 template\"\"\"\n    def prepare(self):\n        raise web.HTTPError(404)\n\n\nclass AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):\n    \"\"\"static files should only be accessible when logged in\"\"\"\n\n    @web.authenticated\n    def get(self, path):\n        if os.path.splitext(path)[1] == '.ipynb':\n            name = path.rsplit('/', 1)[-1]\n            self.set_header('Content-Type', 'application/json')\n            self.set_header('Content-Disposition','attachment; filename=\"%s\"' % name)\n        \n        return web.StaticFileHandler.get(self, path)\n    \n    def set_headers(self):\n        super(AuthenticatedFileHandler, self).set_headers()\n        # disable browser caching, rely on 304 replies for savings\n        if \"v\" not in self.request.arguments:\n            self.add_header(\"Cache-Control\", \"no-cache\")\n    \n    def compute_etag(self):\n        return None\n    \n    def validate_absolute_path(self, root, absolute_path):\n        \"\"\"Validate and return the absolute path.\n        \n        Requires tornado 3.1\n        \n        Adding to tornado's own handling, forbids the serving of hidden files.\n        \"\"\"\n        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)\n        abs_root = os.path.abspath(root)\n        if is_hidden(abs_path, abs_root):\n            self.log.info(\"Refusing to serve hidden file, via 404 Error\")\n            raise web.HTTPError(404)\n        return abs_path\n\n\ndef json_errors(method):\n    \"\"\"Decorate methods with this to return GitHub style JSON errors.\n    \n    This should be used on any JSON API on any handler method that can raise HTTPErrors.\n    \n    This will grab the latest HTTPError exception using sys.exc_info\n    and then:\n    \n    1. Set the HTTP status code based on the HTTPError\n    2. Create and return a JSON body with a message field describing\n       the error in a human readable form.\n    \"\"\"\n    @functools.wraps(method)\n    @gen.coroutine\n    def wrapper(self, *args, **kwargs):\n        try:\n            result = yield gen.maybe_future(method(self, *args, **kwargs))\n        except web.HTTPError as e:\n            status = e.status_code\n            message = e.log_message\n            self.log.warn(message)\n            self.set_status(e.status_code)\n            reply = dict(message=message, reason=e.reason)\n            self.finish(json.dumps(reply))\n        except Exception:\n            self.log.error(\"Unhandled error in API request\", exc_info=True)\n            status = 500\n            message = \"Unknown server error\"\n            t, value, tb = sys.exc_info()\n            self.set_status(status)\n            tb_text = ''.join(traceback.format_exception(t, value, tb))\n            reply = dict(message=message, reason=None, traceback=tb_text)\n            self.finish(json.dumps(reply))\n        else:\n            # FIXME: can use regular return in generators in py3\n            raise gen.Return(result)\n    return wrapper\n\n\n\n#-----------------------------------------------------------------------------\n# File handler\n#-----------------------------------------------------------------------------\n\n# to minimize subclass changes:\nHTTPError = web.HTTPError\n\nclass FileFindHandler(web.StaticFileHandler):\n    \"\"\"subclass of StaticFileHandler for serving files from a search path\"\"\"\n    \n    # cache search results, don't search for files more than once\n    _static_paths = {}\n    \n    def set_headers(self):\n        super(FileFindHandler, self).set_headers()\n        # disable browser caching, rely on 304 replies for savings\n        if \"v\" not in self.request.arguments or \\\n                any(self.request.path.startswith(path) for path in self.no_cache_paths):\n            self.set_header(\"Cache-Control\", \"no-cache\")\n    \n    def initialize(self, path, default_filename=None, no_cache_paths=None):\n        self.no_cache_paths = no_cache_paths or []\n        \n        if isinstance(path, string_types):\n            path = [path]\n        \n        self.root = tuple(\n            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path\n        )\n        self.default_filename = default_filename\n    \n    def compute_etag(self):\n        return None\n    \n    @classmethod\n    def get_absolute_path(cls, roots, path):\n        \"\"\"locate a file to serve on our static file search path\"\"\"\n        with cls._lock:\n            if path in cls._static_paths:\n                return cls._static_paths[path]\n            try:\n                abspath = os.path.abspath(filefind(path, roots))\n            except IOError:\n                # IOError means not found\n                return ''\n            \n            cls._static_paths[path] = abspath\n            return abspath\n    \n    def validate_absolute_path(self, root, absolute_path):\n        \"\"\"check if the file should be served (raises 404, 403, etc.)\"\"\"\n        if absolute_path == '':\n            raise web.HTTPError(404)\n        \n        for root in self.root:\n            if (absolute_path + os.sep).startswith(root):\n                break\n        \n        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)\n\n\nclass ApiVersionHandler(IPythonHandler):\n\n    @json_errors\n    def get(self):\n        # not authenticated, so give as few info as possible\n        self.finish(json.dumps({\"version\":IPython.__version__}))\n\n\nclass TrailingSlashHandler(web.RequestHandler):\n    \"\"\"Simple redirect handler that strips trailing slashes\n    \n    This should be the first, highest priority handler.\n    \"\"\"\n    \n    def get(self):\n        self.redirect(self.request.uri.rstrip('/'))\n    \n    post = put = get\n\n\nclass FilesRedirectHandler(IPythonHandler):\n    \"\"\"Handler for redirecting relative URLs to the /files/ handler\"\"\"\n    \n    @staticmethod\n    def redirect_to_files(self, path):\n        \"\"\"make redirect logic a reusable static method\n        \n        so it can be called from other handlers.\n        \"\"\"\n        cm = self.contents_manager\n        if cm.dir_exists(path):\n            # it's a *directory*, redirect to /tree\n            url = url_path_join(self.base_url, 'tree', path)\n        else:\n            orig_path = path\n            # otherwise, redirect to /files\n            parts = path.split('/')\n\n            if not cm.file_exists(path=path) and 'files' in parts:\n                # redirect without files/ iff it would 404\n                # this preserves pre-2.0-style 'files/' links\n                self.log.warn(\"Deprecated files/ URL: %s\", orig_path)\n                parts.remove('files')\n                path = '/'.join(parts)\n\n            if not cm.file_exists(path=path):\n                raise web.HTTPError(404)\n\n            url = url_path_join(self.base_url, 'files', path)\n        url = url_escape(url)\n        self.log.debug(\"Redirecting %s to %s\", self.request.path, url)\n        self.redirect(url)\n    \n    def get(self, path=''):\n        return self.redirect_to_files(self, path)\n\n\n#-----------------------------------------------------------------------------\n# URL pattern fragments for re-use\n#-----------------------------------------------------------------------------\n\n# path matches any number of `/foo[/bar...]` or just `/` or ''\npath_regex = r\"(?P<path>(?:(?:/[^/]+)+|/?))\"\n\n#-----------------------------------------------------------------------------\n# URL to handler mappings\n#-----------------------------------------------------------------------------\n\n\ndefault_handlers = [\n    (r\".*/\", TrailingSlashHandler),\n    (r\"api\", ApiVersionHandler)\n]\n", "\"\"\"Tornado handlers for cluster web service.\"\"\"\n\n# Copyright (c) IPython Development Team.\n# Distributed under the terms of the Modified BSD License.\n\nimport json\n\nfrom tornado import web\n\nfrom ...base.handlers import IPythonHandler\n\n#-----------------------------------------------------------------------------\n# Cluster handlers\n#-----------------------------------------------------------------------------\n\n\nclass MainClusterHandler(IPythonHandler):\n\n    @web.authenticated\n    def get(self):\n        self.finish(json.dumps(self.cluster_manager.list_profiles()))\n\n\nclass ClusterProfileHandler(IPythonHandler):\n\n    @web.authenticated\n    def get(self, profile):\n        self.finish(json.dumps(self.cluster_manager.profile_info(profile)))\n\n\nclass ClusterActionHandler(IPythonHandler):\n\n    @web.authenticated\n    def post(self, profile, action):\n        cm = self.cluster_manager\n        if action == 'start':\n            n = self.get_argument('n', default=None)\n            if not n:\n                data = cm.start_cluster(profile)\n            else:\n                data = cm.start_cluster(profile, int(n))\n        if action == 'stop':\n            data = cm.stop_cluster(profile)\n        self.finish(json.dumps(data))\n\n\n#-----------------------------------------------------------------------------\n# URL to handler mappings\n#-----------------------------------------------------------------------------\n\n\n_cluster_action_regex = r\"(?P<action>start|stop)\"\n_profile_regex = r\"(?P<profile>[^\\/]+)\" # there is almost no text that is invalid\n\ndefault_handlers = [\n    (r\"/clusters\", MainClusterHandler),\n    (r\"/clusters/%s/%s\" % (_profile_regex, _cluster_action_regex), ClusterActionHandler),\n    (r\"/clusters/%s\" % _profile_regex, ClusterProfileHandler),\n]\n", "\"\"\"Tornado handlers for frontend config storage.\"\"\"\n\n# Copyright (c) IPython Development Team.\n# Distributed under the terms of the Modified BSD License.\nimport json\nimport os\nimport io\nimport errno\nfrom tornado import web\n\nfrom IPython.utils.py3compat import PY3\nfrom ...base.handlers import IPythonHandler, json_errors\n\nclass ConfigHandler(IPythonHandler):\n    SUPPORTED_METHODS = ('GET', 'PUT', 'PATCH')\n\n    @web.authenticated\n    @json_errors\n    def get(self, section_name):\n        self.set_header(\"Content-Type\", 'application/json')\n        self.finish(json.dumps(self.config_manager.get(section_name)))\n\n    @web.authenticated\n    @json_errors\n    def put(self, section_name):\n        data = self.get_json_body()  # Will raise 400 if content is not valid JSON\n        self.config_manager.set(section_name, data)\n        self.set_status(204)\n\n    @web.authenticated\n    @json_errors\n    def patch(self, section_name):\n        new_data = self.get_json_body()\n        section = self.config_manager.update(section_name, new_data)\n        self.finish(json.dumps(section))\n\n\n# URL to handler mappings\n\nsection_name_regex = r\"(?P<section_name>\\w+)\"\n\ndefault_handlers = [\n    (r\"/api/config/%s\" % section_name_regex, ConfigHandler),\n]\n", "\"\"\"Tornado handlers for the contents web service.\"\"\"\n\n# Copyright (c) IPython Development Team.\n# Distributed under the terms of the Modified BSD License.\n\nimport json\n\nfrom tornado import gen, web\n\nfrom IPython.html.utils import url_path_join, url_escape\nfrom IPython.utils.jsonutil import date_default\n\nfrom IPython.html.base.handlers import (\n    IPythonHandler, json_errors, path_regex,\n)\n\n\ndef sort_key(model):\n    \"\"\"key function for case-insensitive sort by name and type\"\"\"\n    iname = model['name'].lower()\n    type_key = {\n        'directory' : '0',\n        'notebook'  : '1',\n        'file'      : '2',\n    }.get(model['type'], '9')\n    return u'%s%s' % (type_key, iname)\n\n\ndef validate_model(model, expect_content):\n    \"\"\"\n    Validate a model returned by a ContentsManager method.\n\n    If expect_content is True, then we expect non-null entries for 'content'\n    and 'format'.\n    \"\"\"\n    required_keys = {\n        \"name\",\n        \"path\",\n        \"type\",\n        \"writable\",\n        \"created\",\n        \"last_modified\",\n        \"mimetype\",\n        \"content\",\n        \"format\",\n    }\n    missing = required_keys - set(model.keys())\n    if missing:\n        raise web.HTTPError(\n            500,\n            u\"Missing Model Keys: {missing}\".format(missing=missing),\n        )\n\n    maybe_none_keys = ['content', 'format']\n    if model['type'] == 'file':\n        # mimetype should be populated only for file models\n        maybe_none_keys.append('mimetype')\n    if expect_content:\n        errors = [key for key in maybe_none_keys if model[key] is None]\n        if errors:\n            raise web.HTTPError(\n                500,\n                u\"Keys unexpectedly None: {keys}\".format(keys=errors),\n            )\n    else:\n        errors = {\n            key: model[key]\n            for key in maybe_none_keys\n            if model[key] is not None\n        }\n        if errors:\n            raise web.HTTPError(\n                500,\n                u\"Keys unexpectedly not None: {keys}\".format(keys=errors),\n            )\n\n\nclass ContentsHandler(IPythonHandler):\n\n    SUPPORTED_METHODS = (u'GET', u'PUT', u'PATCH', u'POST', u'DELETE')\n\n    def location_url(self, path):\n        \"\"\"Return the full URL location of a file.\n\n        Parameters\n        ----------\n        path : unicode\n            The API path of the file, such as \"foo/bar.txt\".\n        \"\"\"\n        return url_escape(url_path_join(\n            self.base_url, 'api', 'contents', path\n        ))\n\n    def _finish_model(self, model, location=True):\n        \"\"\"Finish a JSON request with a model, setting relevant headers, etc.\"\"\"\n        if location:\n            location = self.location_url(model['path'])\n            self.set_header('Location', location)\n        self.set_header('Last-Modified', model['last_modified'])\n        self.set_header('Content-Type', 'application/json')\n        self.finish(json.dumps(model, default=date_default))\n\n    @web.authenticated\n    @json_errors\n    @gen.coroutine\n    def get(self, path=''):\n        \"\"\"Return a model for a file or directory.\n\n        A directory model contains a list of models (without content)\n        of the files and directories it contains.\n        \"\"\"\n        path = path or ''\n        type = self.get_query_argument('type', default=None)\n        if type not in {None, 'directory', 'file', 'notebook'}:\n            raise web.HTTPError(400, u'Type %r is invalid' % type)\n\n        format = self.get_query_argument('format', default=None)\n        if format not in {None, 'text', 'base64'}:\n            raise web.HTTPError(400, u'Format %r is invalid' % format)\n        content = self.get_query_argument('content', default='1')\n        if content not in {'0', '1'}:\n            raise web.HTTPError(400, u'Content %r is invalid' % content)\n        content = int(content)\n        \n        model = yield gen.maybe_future(self.contents_manager.get(\n            path=path, type=type, format=format, content=content,\n        ))\n        if model['type'] == 'directory' and content:\n            # group listing by type, then by name (case-insensitive)\n            # FIXME: sorting should be done in the frontends\n            model['content'].sort(key=sort_key)\n        validate_model(model, expect_content=content)\n        self._finish_model(model, location=False)\n\n    @web.authenticated\n    @json_errors\n    @gen.coroutine\n    def patch(self, path=''):\n        \"\"\"PATCH renames a file or directory without re-uploading content.\"\"\"\n        cm = self.contents_manager\n        model = self.get_json_body()\n        if model is None:\n            raise web.HTTPError(400, u'JSON body missing')\n        model = yield gen.maybe_future(cm.update(model, path))\n        validate_model(model, expect_content=False)\n        self._finish_model(model)\n    \n    @gen.coroutine\n    def _copy(self, copy_from, copy_to=None):\n        \"\"\"Copy a file, optionally specifying a target directory.\"\"\"\n        self.log.info(u\"Copying {copy_from} to {copy_to}\".format(\n            copy_from=copy_from,\n            copy_to=copy_to or '',\n        ))\n        model = yield gen.maybe_future(self.contents_manager.copy(copy_from, copy_to))\n        self.set_status(201)\n        validate_model(model, expect_content=False)\n        self._finish_model(model)\n\n    @gen.coroutine\n    def _upload(self, model, path):\n        \"\"\"Handle upload of a new file to path\"\"\"\n        self.log.info(u\"Uploading file to %s\", path)\n        model = yield gen.maybe_future(self.contents_manager.new(model, path))\n        self.set_status(201)\n        validate_model(model, expect_content=False)\n        self._finish_model(model)\n    \n    @gen.coroutine\n    def _new_untitled(self, path, type='', ext=''):\n        \"\"\"Create a new, empty untitled entity\"\"\"\n        self.log.info(u\"Creating new %s in %s\", type or 'file', path)\n        model = yield gen.maybe_future(self.contents_manager.new_untitled(path=path, type=type, ext=ext))\n        self.set_status(201)\n        validate_model(model, expect_content=False)\n        self._finish_model(model)\n    \n    @gen.coroutine\n    def _save(self, model, path):\n        \"\"\"Save an existing file.\"\"\"\n        self.log.info(u\"Saving file at %s\", path)\n        model = yield gen.maybe_future(self.contents_manager.save(model, path))\n        validate_model(model, expect_content=False)\n        self._finish_model(model)\n\n    @web.authenticated\n    @json_errors\n    @gen.coroutine\n    def post(self, path=''):\n        \"\"\"Create a new file in the specified path.\n\n        POST creates new files. The server always decides on the name.\n\n        POST /api/contents/path\n          New untitled, empty file or directory.\n        POST /api/contents/path\n          with body {\"copy_from\" : \"/path/to/OtherNotebook.ipynb\"}\n          New copy of OtherNotebook in path\n        \"\"\"\n\n        cm = self.contents_manager\n\n        if cm.file_exists(path):\n            raise web.HTTPError(400, \"Cannot POST to files, use PUT instead.\")\n\n        if not cm.dir_exists(path):\n            raise web.HTTPError(404, \"No such directory: %s\" % path)\n\n        model = self.get_json_body()\n\n        if model is not None:\n            copy_from = model.get('copy_from')\n            ext = model.get('ext', '')\n            type = model.get('type', '')\n            if copy_from:\n                yield self._copy(copy_from, path)\n            else:\n                yield self._new_untitled(path, type=type, ext=ext)\n        else:\n            yield self._new_untitled(path)\n\n    @web.authenticated\n    @json_errors\n    @gen.coroutine\n    def put(self, path=''):\n        \"\"\"Saves the file in the location specified by name and path.\n\n        PUT is very similar to POST, but the requester specifies the name,\n        whereas with POST, the server picks the name.\n\n        PUT /api/contents/path/Name.ipynb\n          Save notebook at ``path/Name.ipynb``. Notebook structure is specified\n          in `content` key of JSON request body. If content is not specified,\n          create a new empty notebook.\n        \"\"\"\n        model = self.get_json_body()\n        if model:\n            if model.get('copy_from'):\n                raise web.HTTPError(400, \"Cannot copy with PUT, only POST\")\n            exists = yield gen.maybe_future(self.contents_manager.file_exists(path))\n            if exists:\n                yield gen.maybe_future(self._save(model, path))\n            else:\n                yield gen.maybe_future(self._upload(model, path))\n        else:\n            yield gen.maybe_future(self._new_untitled(path))\n\n    @web.authenticated\n    @json_errors\n    @gen.coroutine\n    def delete(self, path=''):\n        \"\"\"delete a file in the given path\"\"\"\n        cm = self.contents_manager\n        self.log.warn('delete %s', path)\n        yield gen.maybe_future(cm.delete(path))\n        self.set_status(204)\n        self.finish()\n\n\nclass CheckpointsHandler(IPythonHandler):\n\n    SUPPORTED_METHODS = ('GET', 'POST')\n\n    @web.authenticated\n    @json_errors\n    @gen.coroutine\n    def get(self, path=''):\n        \"\"\"get lists checkpoints for a file\"\"\"\n        cm = self.contents_manager\n        checkpoints = yield gen.maybe_future(cm.list_checkpoints(path))\n        data = json.dumps(checkpoints, default=date_default)\n        self.finish(data)\n\n    @web.authenticated\n    @json_errors\n    @gen.coroutine\n    def post(self, path=''):\n        \"\"\"post creates a new checkpoint\"\"\"\n        cm = self.contents_manager\n        checkpoint = yield gen.maybe_future(cm.create_checkpoint(path))\n        data = json.dumps(checkpoint, default=date_default)\n        location = url_path_join(self.base_url, 'api/contents',\n            path, 'checkpoints', checkpoint['id'])\n        self.set_header('Location', url_escape(location))\n        self.set_status(201)\n        self.finish(data)\n\n\nclass ModifyCheckpointsHandler(IPythonHandler):\n\n    SUPPORTED_METHODS = ('POST', 'DELETE')\n\n    @web.authenticated\n    @json_errors\n    @gen.coroutine\n    def post(self, path, checkpoint_id):\n        \"\"\"post restores a file from a checkpoint\"\"\"\n        cm = self.contents_manager\n        yield gen.maybe_future(cm.restore_checkpoint(checkpoint_id, path))\n        self.set_status(204)\n        self.finish()\n\n    @web.authenticated\n    @json_errors\n    @gen.coroutine\n    def delete(self, path, checkpoint_id):\n        \"\"\"delete clears a checkpoint for a given file\"\"\"\n        cm = self.contents_manager\n        yield gen.maybe_future(cm.delete_checkpoint(checkpoint_id, path))\n        self.set_status(204)\n        self.finish()\n\n\nclass NotebooksRedirectHandler(IPythonHandler):\n    \"\"\"Redirect /api/notebooks to /api/contents\"\"\"\n    SUPPORTED_METHODS = ('GET', 'PUT', 'PATCH', 'POST', 'DELETE')\n\n    def get(self, path):\n        self.log.warn(\"/api/notebooks is deprecated, use /api/contents\")\n        self.redirect(url_path_join(\n            self.base_url,\n            'api/contents',\n            path\n        ))\n\n    put = patch = post = delete = get\n\n\n#-----------------------------------------------------------------------------\n# URL to handler mappings\n#-----------------------------------------------------------------------------\n\n\n_checkpoint_id_regex = r\"(?P<checkpoint_id>[\\w-]+)\"\n\ndefault_handlers = [\n    (r\"/api/contents%s/checkpoints\" % path_regex, CheckpointsHandler),\n    (r\"/api/contents%s/checkpoints/%s\" % (path_regex, _checkpoint_id_regex),\n        ModifyCheckpointsHandler),\n    (r\"/api/contents%s\" % path_regex, ContentsHandler),\n    (r\"/api/notebooks/?(.*)\", NotebooksRedirectHandler),\n]\n", "\"\"\"Tornado handlers for kernels.\"\"\"\n\n# Copyright (c) IPython Development Team.\n# Distributed under the terms of the Modified BSD License.\n\nimport json\nimport logging\nfrom tornado import gen, web\nfrom tornado.concurrent import Future\nfrom tornado.ioloop import IOLoop\n\nfrom IPython.utils.jsonutil import date_default\nfrom IPython.utils.py3compat import cast_unicode\nfrom IPython.html.utils import url_path_join, url_escape\n\nfrom ...base.handlers import IPythonHandler, json_errors\nfrom ...base.zmqhandlers import AuthenticatedZMQStreamHandler, deserialize_binary_message\n\nfrom IPython.core.release import kernel_protocol_version\n\nclass MainKernelHandler(IPythonHandler):\n\n    @web.authenticated\n    @json_errors\n    def get(self):\n        km = self.kernel_manager\n        self.finish(json.dumps(km.list_kernels()))\n\n    @web.authenticated\n    @json_errors\n    def post(self):\n        km = self.kernel_manager\n        model = self.get_json_body()\n        if model is None:\n            model = {\n                'name': km.default_kernel_name\n            }\n        else:\n            model.setdefault('name', km.default_kernel_name)\n\n        kernel_id = km.start_kernel(kernel_name=model['name'])\n        model = km.kernel_model(kernel_id)\n        location = url_path_join(self.base_url, 'api', 'kernels', kernel_id)\n        self.set_header('Location', url_escape(location))\n        self.set_status(201)\n        self.finish(json.dumps(model))\n\n\nclass KernelHandler(IPythonHandler):\n\n    SUPPORTED_METHODS = ('DELETE', 'GET')\n\n    @web.authenticated\n    @json_errors\n    def get(self, kernel_id):\n        km = self.kernel_manager\n        km._check_kernel_id(kernel_id)\n        model = km.kernel_model(kernel_id)\n        self.finish(json.dumps(model))\n\n    @web.authenticated\n    @json_errors\n    def delete(self, kernel_id):\n        km = self.kernel_manager\n        km.shutdown_kernel(kernel_id)\n        self.set_status(204)\n        self.finish()\n\n\nclass KernelActionHandler(IPythonHandler):\n\n    @web.authenticated\n    @json_errors\n    def post(self, kernel_id, action):\n        km = self.kernel_manager\n        if action == 'interrupt':\n            km.interrupt_kernel(kernel_id)\n            self.set_status(204)\n        if action == 'restart':\n            km.restart_kernel(kernel_id)\n            model = km.kernel_model(kernel_id)\n            self.set_header('Location', '{0}api/kernels/{1}'.format(self.base_url, kernel_id))\n            self.write(json.dumps(model))\n        self.finish()\n\n\nclass ZMQChannelsHandler(AuthenticatedZMQStreamHandler):\n    \n    @property\n    def kernel_info_timeout(self):\n        return self.settings.get('kernel_info_timeout', 10)\n    \n    def __repr__(self):\n        return \"%s(%s)\" % (self.__class__.__name__, getattr(self, 'kernel_id', 'uninitialized'))\n    \n    def create_stream(self):\n        km = self.kernel_manager\n        identity = self.session.bsession\n        for channel in ('shell', 'iopub', 'stdin'):\n            meth = getattr(km, 'connect_' + channel)\n            self.channels[channel] = stream = meth(self.kernel_id, identity=identity)\n            stream.channel = channel\n        km.add_restart_callback(self.kernel_id, self.on_kernel_restarted)\n        km.add_restart_callback(self.kernel_id, self.on_restart_failed, 'dead')\n    \n    def request_kernel_info(self):\n        \"\"\"send a request for kernel_info\"\"\"\n        km = self.kernel_manager\n        kernel = km.get_kernel(self.kernel_id)\n        try:\n            # check for previous request\n            future = kernel._kernel_info_future\n        except AttributeError:\n            self.log.debug(\"Requesting kernel info from %s\", self.kernel_id)\n            # Create a kernel_info channel to query the kernel protocol version.\n            # This channel will be closed after the kernel_info reply is received.\n            if self.kernel_info_channel is None:\n                self.kernel_info_channel = km.connect_shell(self.kernel_id)\n            self.kernel_info_channel.on_recv(self._handle_kernel_info_reply)\n            self.session.send(self.kernel_info_channel, \"kernel_info_request\")\n            # store the future on the kernel, so only one request is sent\n            kernel._kernel_info_future = self._kernel_info_future\n        else:\n            if not future.done():\n                self.log.debug(\"Waiting for pending kernel_info request\")\n            future.add_done_callback(lambda f: self._finish_kernel_info(f.result()))\n        return self._kernel_info_future\n    \n    def _handle_kernel_info_reply(self, msg):\n        \"\"\"process the kernel_info_reply\n        \n        enabling msg spec adaptation, if necessary\n        \"\"\"\n        idents,msg = self.session.feed_identities(msg)\n        try:\n            msg = self.session.deserialize(msg)\n        except:\n            self.log.error(\"Bad kernel_info reply\", exc_info=True)\n            self._kernel_info_future.set_result({})\n            return\n        else:\n            info = msg['content']\n            self.log.debug(\"Received kernel info: %s\", info)\n            if msg['msg_type'] != 'kernel_info_reply' or 'protocol_version' not in info:\n                self.log.error(\"Kernel info request failed, assuming current %s\", info)\n                info = {}\n            self._finish_kernel_info(info)\n        \n        # close the kernel_info channel, we don't need it anymore\n        if self.kernel_info_channel:\n            self.kernel_info_channel.close()\n        self.kernel_info_channel = None\n    \n    def _finish_kernel_info(self, info):\n        \"\"\"Finish handling kernel_info reply\n        \n        Set up protocol adaptation, if needed,\n        and signal that connection can continue.\n        \"\"\"\n        protocol_version = info.get('protocol_version', kernel_protocol_version)\n        if protocol_version != kernel_protocol_version:\n            self.session.adapt_version = int(protocol_version.split('.')[0])\n            self.log.info(\"Adapting to protocol v%s for kernel %s\", protocol_version, self.kernel_id)\n        if not self._kernel_info_future.done():\n            self._kernel_info_future.set_result(info)\n    \n    def initialize(self):\n        super(ZMQChannelsHandler, self).initialize()\n        self.zmq_stream = None\n        self.channels = {}\n        self.kernel_id = None\n        self.kernel_info_channel = None\n        self._kernel_info_future = Future()\n    \n    @gen.coroutine\n    def pre_get(self):\n        # authenticate first\n        super(ZMQChannelsHandler, self).pre_get()\n        # then request kernel info, waiting up to a certain time before giving up.\n        # We don't want to wait forever, because browsers don't take it well when\n        # servers never respond to websocket connection requests.\n        kernel = self.kernel_manager.get_kernel(self.kernel_id)\n        self.session.key = kernel.session.key\n        future = self.request_kernel_info()\n        \n        def give_up():\n            \"\"\"Don't wait forever for the kernel to reply\"\"\"\n            if future.done():\n                return\n            self.log.warn(\"Timeout waiting for kernel_info reply from %s\", self.kernel_id)\n            future.set_result({})\n        loop = IOLoop.current()\n        loop.add_timeout(loop.time() + self.kernel_info_timeout, give_up)\n        # actually wait for it\n        yield future\n    \n    @gen.coroutine\n    def get(self, kernel_id):\n        self.kernel_id = cast_unicode(kernel_id, 'ascii')\n        yield super(ZMQChannelsHandler, self).get(kernel_id=kernel_id)\n    \n    def open(self, kernel_id):\n        super(ZMQChannelsHandler, self).open()\n        try:\n            self.create_stream()\n        except web.HTTPError as e:\n            self.log.error(\"Error opening stream: %s\", e)\n            # WebSockets don't response to traditional error codes so we\n            # close the connection.\n            for channel, stream in self.channels.items():\n                if not stream.closed():\n                    stream.close()\n            self.close()\n        else:\n            for channel, stream in self.channels.items():\n                stream.on_recv_stream(self._on_zmq_reply)\n\n    def on_message(self, msg):\n        if not self.channels:\n            # already closed, ignore the message\n            self.log.debug(\"Received message on closed websocket %r\", msg)\n            return\n        if isinstance(msg, bytes):\n            msg = deserialize_binary_message(msg)\n        else:\n            msg = json.loads(msg)\n        channel = msg.pop('channel', None)\n        if channel is None:\n            self.log.warn(\"No channel specified, assuming shell: %s\", msg)\n            channel = 'shell'\n        if channel not in self.channels:\n            self.log.warn(\"No such channel: %r\", channel)\n            return\n        stream = self.channels[channel]\n        self.session.send(stream, msg)\n\n    def on_close(self):\n        km = self.kernel_manager\n        if self.kernel_id in km:\n            km.remove_restart_callback(\n                self.kernel_id, self.on_kernel_restarted,\n            )\n            km.remove_restart_callback(\n                self.kernel_id, self.on_restart_failed, 'dead',\n            )\n        # This method can be called twice, once by self.kernel_died and once\n        # from the WebSocket close event. If the WebSocket connection is\n        # closed before the ZMQ streams are setup, they could be None.\n        for channel, stream in self.channels.items():\n            if stream is not None and not stream.closed():\n                stream.on_recv(None)\n                # close the socket directly, don't wait for the stream\n                socket = stream.socket\n                stream.close()\n                socket.close()\n        \n        self.channels = {}\n\n    def _send_status_message(self, status):\n        msg = self.session.msg(\"status\",\n            {'execution_state': status}\n        )\n        msg['channel'] = 'iopub'\n        self.write_message(json.dumps(msg, default=date_default))\n\n    def on_kernel_restarted(self):\n        logging.warn(\"kernel %s restarted\", self.kernel_id)\n        self._send_status_message('restarting')\n\n    def on_restart_failed(self):\n        logging.error(\"kernel %s restarted failed!\", self.kernel_id)\n        self._send_status_message('dead')\n\n\n#-----------------------------------------------------------------------------\n# URL to handler mappings\n#-----------------------------------------------------------------------------\n\n\n_kernel_id_regex = r\"(?P<kernel_id>\\w+-\\w+-\\w+-\\w+-\\w+)\"\n_kernel_action_regex = r\"(?P<action>restart|interrupt)\"\n\ndefault_handlers = [\n    (r\"/api/kernels\", MainKernelHandler),\n    (r\"/api/kernels/%s\" % _kernel_id_regex, KernelHandler),\n    (r\"/api/kernels/%s/%s\" % (_kernel_id_regex, _kernel_action_regex), KernelActionHandler),\n    (r\"/api/kernels/%s/channels\" % _kernel_id_regex, ZMQChannelsHandler),\n]\n", "\"\"\"Test the kernels service API.\"\"\"\n\nimport json\nimport requests\n\nfrom IPython.html.utils import url_path_join\nfrom IPython.html.tests.launchnotebook import NotebookTestBase, assert_http_error\n\nclass KernelAPI(object):\n    \"\"\"Wrapper for kernel REST API requests\"\"\"\n    def __init__(self, base_url):\n        self.base_url = base_url\n\n    def _req(self, verb, path, body=None):\n        response = requests.request(verb,\n                url_path_join(self.base_url, 'api/kernels', path), data=body)\n\n        if 400 <= response.status_code < 600:\n            try:\n                response.reason = response.json()['message']\n            except:\n                pass\n        response.raise_for_status()\n\n        return response\n\n    def list(self):\n        return self._req('GET', '')\n\n    def get(self, id):\n        return self._req('GET', id)\n\n    def start(self, name='python'):\n        body = json.dumps({'name': name})\n        return self._req('POST', '', body)\n\n    def shutdown(self, id):\n        return self._req('DELETE', id)\n\n    def interrupt(self, id):\n        return self._req('POST', url_path_join(id, 'interrupt'))\n\n    def restart(self, id):\n        return self._req('POST', url_path_join(id, 'restart'))\n\nclass KernelAPITest(NotebookTestBase):\n    \"\"\"Test the kernels web service API\"\"\"\n    def setUp(self):\n        self.kern_api = KernelAPI(self.base_url())\n\n    def tearDown(self):\n        for k in self.kern_api.list().json():\n            self.kern_api.shutdown(k['id'])\n\n    def test__no_kernels(self):\n        \"\"\"Make sure there are no kernels running at the start\"\"\"\n        kernels = self.kern_api.list().json()\n        self.assertEqual(kernels, [])\n\n    def test_default_kernel(self):\n        # POST request\n        r = self.kern_api._req('POST', '')\n        kern1 = r.json()\n        self.assertEqual(r.headers['location'], '/api/kernels/' + kern1['id'])\n        self.assertEqual(r.status_code, 201)\n        self.assertIsInstance(kern1, dict)\n\n        self.assertEqual(r.headers['Content-Security-Policy'], (\n                            \"frame-ancestors 'self'; \"\n                            \"report-uri /api/security/csp-report;\"\n        ))\n\n    def test_main_kernel_handler(self):\n        # POST request\n        r = self.kern_api.start()\n        kern1 = r.json()\n        self.assertEqual(r.headers['location'], '/api/kernels/' + kern1['id'])\n        self.assertEqual(r.status_code, 201)\n        self.assertIsInstance(kern1, dict)\n\n        self.assertEqual(r.headers['Content-Security-Policy'], (\n                            \"frame-ancestors 'self'; \"\n                            \"report-uri /api/security/csp-report;\"\n        ))\n\n        # GET request\n        r = self.kern_api.list()\n        self.assertEqual(r.status_code, 200)\n        assert isinstance(r.json(), list)\n        self.assertEqual(r.json()[0]['id'], kern1['id'])\n        self.assertEqual(r.json()[0]['name'], kern1['name'])\n\n        # create another kernel and check that they both are added to the\n        # list of kernels from a GET request\n        kern2 = self.kern_api.start().json()\n        assert isinstance(kern2, dict)\n        r = self.kern_api.list()\n        kernels = r.json()\n        self.assertEqual(r.status_code, 200)\n        assert isinstance(kernels, list)\n        self.assertEqual(len(kernels), 2)\n\n        # Interrupt a kernel\n        r = self.kern_api.interrupt(kern2['id'])\n        self.assertEqual(r.status_code, 204)\n\n        # Restart a kernel\n        r = self.kern_api.restart(kern2['id'])\n        self.assertEqual(r.headers['Location'], '/api/kernels/'+kern2['id'])\n        rekern = r.json()\n        self.assertEqual(rekern['id'], kern2['id'])\n        self.assertEqual(rekern['name'], kern2['name'])\n\n    def test_kernel_handler(self):\n        # GET kernel with given id\n        kid = self.kern_api.start().json()['id']\n        r = self.kern_api.get(kid)\n        kern1 = r.json()\n        self.assertEqual(r.status_code, 200)\n        assert isinstance(kern1, dict)\n        self.assertIn('id', kern1)\n        self.assertEqual(kern1['id'], kid)\n\n        # Request a bad kernel id and check that a JSON\n        # message is returned!\n        bad_id = '111-111-111-111-111'\n        with assert_http_error(404, 'Kernel does not exist: ' + bad_id):\n            self.kern_api.get(bad_id)\n\n        # DELETE kernel with id\n        r = self.kern_api.shutdown(kid)\n        self.assertEqual(r.status_code, 204)\n        kernels = self.kern_api.list().json()\n        self.assertEqual(kernels, [])\n\n        # Request to delete a non-existent kernel id\n        bad_id = '111-111-111-111-111'\n        with assert_http_error(404, 'Kernel does not exist: ' + bad_id):\n            self.kern_api.shutdown(bad_id)\n", "\"\"\"Tornado handlers for kernel specifications.\"\"\"\n\n# Copyright (c) IPython Development Team.\n# Distributed under the terms of the Modified BSD License.\n\nimport glob\nimport json\nimport os\npjoin = os.path.join\n\nfrom tornado import web\n\nfrom ...base.handlers import IPythonHandler, json_errors\nfrom ...utils import url_path_join\n\ndef kernelspec_model(handler, name):\n    \"\"\"Load a KernelSpec by name and return the REST API model\"\"\"\n    ksm = handler.kernel_spec_manager\n    spec = ksm.get_kernel_spec(name)\n    d = {'name': name}\n    d['spec'] = spec.to_dict()\n    d['resources'] = resources = {}\n    resource_dir = spec.resource_dir\n    for resource in ['kernel.js', 'kernel.css']:\n        if os.path.exists(pjoin(resource_dir, resource)):\n            resources[resource] = url_path_join(\n                handler.base_url,\n                'kernelspecs',\n                name,\n                resource\n            )\n    for logo_file in glob.glob(pjoin(resource_dir, 'logo-*')):\n        fname = os.path.basename(logo_file)\n        no_ext, _ = os.path.splitext(fname)\n        resources[no_ext] = url_path_join(\n            handler.base_url,\n            'kernelspecs',\n            name,\n            fname\n        )\n    return d\n\nclass MainKernelSpecHandler(IPythonHandler):\n    SUPPORTED_METHODS = ('GET',)\n\n    @web.authenticated\n    @json_errors\n    def get(self):\n        ksm = self.kernel_spec_manager\n        km = self.kernel_manager\n        model = {}\n        model['default'] = km.default_kernel_name\n        model['kernelspecs'] = specs = {}\n        for kernel_name in ksm.find_kernel_specs():\n            try:\n                d = kernelspec_model(self, kernel_name)\n            except Exception:\n                self.log.error(\"Failed to load kernel spec: '%s'\", kernel_name, exc_info=True)\n                continue\n            specs[kernel_name] = d\n        self.set_header(\"Content-Type\", 'application/json')\n        self.finish(json.dumps(model))\n\n\nclass KernelSpecHandler(IPythonHandler):\n    SUPPORTED_METHODS = ('GET',)\n\n    @web.authenticated\n    @json_errors\n    def get(self, kernel_name):\n        try:\n            model = kernelspec_model(self, kernel_name)\n        except KeyError:\n            raise web.HTTPError(404, u'Kernel spec %s not found' % kernel_name)\n        self.set_header(\"Content-Type\", 'application/json')\n        self.finish(json.dumps(model))\n\n\n# URL to handler mappings\n\nkernel_name_regex = r\"(?P<kernel_name>\\w+)\"\n\ndefault_handlers = [\n    (r\"/api/kernelspecs\", MainKernelSpecHandler),\n    (r\"/api/kernelspecs/%s\" % kernel_name_regex, KernelSpecHandler),\n]\n", "import json\n\nfrom tornado import web\n\nfrom ...base.handlers import IPythonHandler, json_errors\n\nclass NbconvertRootHandler(IPythonHandler):\n    SUPPORTED_METHODS = ('GET',)\n\n    @web.authenticated\n    @json_errors\n    def get(self):\n        try:\n            from IPython.nbconvert.exporters.export import exporter_map\n        except ImportError as e:\n            raise web.HTTPError(500, \"Could not import nbconvert: %s\" % e)\n        res = {}\n        for format, exporter in exporter_map.items():\n            res[format] = info = {}\n            info['output_mimetype'] = exporter.output_mimetype\n\n        self.finish(json.dumps(res))\n\ndefault_handlers = [\n    (r\"/api/nbconvert\", NbconvertRootHandler),\n]", "\"\"\"Tornado handlers for security logging.\"\"\"\n\n# Copyright (c) IPython Development Team.\n# Distributed under the terms of the Modified BSD License.\n\nfrom tornado import gen, web\n\nfrom ...base.handlers import IPythonHandler, json_errors\nfrom . import csp_report_uri\n\nclass CSPReportHandler(IPythonHandler):\n    '''Accepts a content security policy violation report'''\n    @web.authenticated\n    @json_errors\n    def post(self):\n        '''Log a content security policy violation report'''\n        csp_report = self.get_json_body()\n        self.log.warn(\"Content security violation: %s\",\n                      self.request.body.decode('utf8', 'replace'))\n\ndefault_handlers = [\n    (csp_report_uri, CSPReportHandler)\n]\n", "\"\"\"Tornado handlers for the sessions web service.\"\"\"\n\n# Copyright (c) IPython Development Team.\n# Distributed under the terms of the Modified BSD License.\n\nimport json\n\nfrom tornado import web\n\nfrom ...base.handlers import IPythonHandler, json_errors\nfrom IPython.utils.jsonutil import date_default\nfrom IPython.html.utils import url_path_join, url_escape\nfrom IPython.kernel.kernelspec import NoSuchKernel\n\n\nclass SessionRootHandler(IPythonHandler):\n\n    @web.authenticated\n    @json_errors\n    def get(self):\n        # Return a list of running sessions\n        sm = self.session_manager\n        sessions = sm.list_sessions()\n        self.finish(json.dumps(sessions, default=date_default))\n\n    @web.authenticated\n    @json_errors\n    def post(self):\n        # Creates a new session\n        #(unless a session already exists for the named nb)\n        sm = self.session_manager\n        cm = self.contents_manager\n        km = self.kernel_manager\n\n        model = self.get_json_body()\n        if model is None:\n            raise web.HTTPError(400, \"No JSON data provided\")\n        try:\n            path = model['notebook']['path']\n        except KeyError:\n            raise web.HTTPError(400, \"Missing field in JSON data: notebook.path\")\n        try:\n            kernel_name = model['kernel']['name']\n        except KeyError:\n            self.log.debug(\"No kernel name specified, using default kernel\")\n            kernel_name = None\n\n        # Check to see if session exists\n        if sm.session_exists(path=path):\n            model = sm.get_session(path=path)\n        else:\n            try:\n                model = sm.create_session(path=path, kernel_name=kernel_name)\n            except NoSuchKernel:\n                msg = (\"The '%s' kernel is not available. Please pick another \"\n                       \"suitable kernel instead, or install that kernel.\" % kernel_name)\n                status_msg = '%s not found' % kernel_name\n                self.log.warn('Kernel not found: %s' % kernel_name)\n                self.set_status(501)\n                self.finish(json.dumps(dict(message=msg, short_message=status_msg)))\n                return\n\n        location = url_path_join(self.base_url, 'api', 'sessions', model['id'])\n        self.set_header('Location', url_escape(location))\n        self.set_status(201)\n        self.finish(json.dumps(model, default=date_default))\n\nclass SessionHandler(IPythonHandler):\n\n    SUPPORTED_METHODS = ('GET', 'PATCH', 'DELETE')\n\n    @web.authenticated\n    @json_errors\n    def get(self, session_id):\n        # Returns the JSON model for a single session\n        sm = self.session_manager\n        model = sm.get_session(session_id=session_id)\n        self.finish(json.dumps(model, default=date_default))\n\n    @web.authenticated\n    @json_errors\n    def patch(self, session_id):\n        # Currently, this handler is strictly for renaming notebooks\n        sm = self.session_manager\n        model = self.get_json_body()\n        if model is None:\n            raise web.HTTPError(400, \"No JSON data provided\")\n        changes = {}\n        if 'notebook' in model:\n            notebook = model['notebook']\n            if 'path' in notebook:\n                changes['path'] = notebook['path']\n\n        sm.update_session(session_id, **changes)\n        model = sm.get_session(session_id=session_id)\n        self.finish(json.dumps(model, default=date_default))\n\n    @web.authenticated\n    @json_errors\n    def delete(self, session_id):\n        # Deletes the session with given session_id\n        sm = self.session_manager\n        try:\n            sm.delete_session(session_id)\n        except KeyError:\n            # the kernel was deleted but the session wasn't!\n            raise web.HTTPError(410, \"Kernel deleted before session\")\n        self.set_status(204)\n        self.finish()\n\n\n#-----------------------------------------------------------------------------\n# URL to handler mappings\n#-----------------------------------------------------------------------------\n\n_session_id_regex = r\"(?P<session_id>\\w+-\\w+-\\w+-\\w+-\\w+)\"\n\ndefault_handlers = [\n    (r\"/api/sessions/%s\" % _session_id_regex, SessionHandler),\n    (r\"/api/sessions\",  SessionRootHandler)\n]\n\n", "import json\nfrom tornado import web, gen\nfrom ..base.handlers import IPythonHandler, json_errors\nfrom ..utils import url_path_join\n\nclass TerminalRootHandler(IPythonHandler):\n    @web.authenticated\n    @json_errors\n    def get(self):\n        tm = self.terminal_manager\n        terms = [{'name': name} for name in tm.terminals]\n        self.finish(json.dumps(terms))\n\n    @web.authenticated\n    @json_errors\n    def post(self):\n        \"\"\"POST /terminals creates a new terminal and redirects to it\"\"\"\n        name, _ = self.terminal_manager.new_named_terminal()\n        self.finish(json.dumps({'name': name}))\n\n\nclass TerminalHandler(IPythonHandler):\n    SUPPORTED_METHODS = ('GET', 'DELETE')\n\n    @web.authenticated\n    @json_errors\n    def get(self, name):\n        tm = self.terminal_manager\n        if name in tm.terminals:\n            self.finish(json.dumps({'name': name}))\n        else:\n            raise web.HTTPError(404, \"Terminal not found: %r\" % name)\n\n    @web.authenticated\n    @json_errors\n    @gen.coroutine\n    def delete(self, name):\n        tm = self.terminal_manager\n        if name in tm.terminals:\n            yield tm.terminate(name, force=True)\n            self.set_status(204)\n            self.finish()\n        else:\n            raise web.HTTPError(404, \"Terminal not found: %r\" % name)\n"], "fixing_code": ["\"\"\"Base Tornado handlers for the notebook server.\"\"\"\n\n# Copyright (c) IPython Development Team.\n# Distributed under the terms of the Modified BSD License.\n\nimport functools\nimport json\nimport logging\nimport os\nimport re\nimport sys\nimport traceback\ntry:\n    # py3\n    from http.client import responses\nexcept ImportError:\n    from httplib import responses\n\nfrom jinja2 import TemplateNotFound\nfrom tornado import web\n\nfrom tornado import gen\nfrom tornado.log import app_log\n\n\nimport IPython\nfrom IPython.utils.sysinfo import get_sys_info\n\nfrom IPython.config import Application\nfrom IPython.utils.path import filefind\nfrom IPython.utils.py3compat import string_types\nfrom IPython.html.utils import is_hidden, url_path_join, url_escape\n\nfrom IPython.html.services.security import csp_report_uri\n\n#-----------------------------------------------------------------------------\n# Top-level handlers\n#-----------------------------------------------------------------------------\nnon_alphanum = re.compile(r'[^A-Za-z0-9]')\n\nsys_info = json.dumps(get_sys_info())\n\nclass AuthenticatedHandler(web.RequestHandler):\n    \"\"\"A RequestHandler with an authenticated user.\"\"\"\n    \n    @property\n    def content_security_policy(self):\n        \"\"\"The default Content-Security-Policy header\n        \n        Can be overridden by defining Content-Security-Policy in settings['headers']\n        \"\"\"\n        return '; '.join([\n            \"frame-ancestors 'self'\",\n            # Make sure the report-uri is relative to the base_url\n            \"report-uri \" + url_path_join(self.base_url, csp_report_uri),\n        ])\n\n    def set_default_headers(self):\n        headers = self.settings.get('headers', {})\n\n        if \"Content-Security-Policy\" not in headers:\n            headers[\"Content-Security-Policy\"] = self.content_security_policy\n\n        # Allow for overriding headers\n        for header_name,value in headers.items() :\n            try:\n                self.set_header(header_name, value)\n            except Exception as e:\n                # tornado raise Exception (not a subclass)\n                # if method is unsupported (websocket and Access-Control-Allow-Origin\n                # for example, so just ignore)\n                self.log.debug(e)\n    \n    def clear_login_cookie(self):\n        self.clear_cookie(self.cookie_name)\n    \n    def get_current_user(self):\n        if self.login_handler is None:\n            return 'anonymous'\n        return self.login_handler.get_user(self)\n\n    @property\n    def cookie_name(self):\n        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(\n            self.request.host\n        ))\n        return self.settings.get('cookie_name', default_cookie_name)\n    \n    @property\n    def logged_in(self):\n        \"\"\"Is a user currently logged in?\"\"\"\n        user = self.get_current_user()\n        return (user and not user == 'anonymous')\n\n    @property\n    def login_handler(self):\n        \"\"\"Return the login handler for this application, if any.\"\"\"\n        return self.settings.get('login_handler_class', None)\n\n    @property\n    def login_available(self):\n        \"\"\"May a user proceed to log in?\n\n        This returns True if login capability is available, irrespective of\n        whether the user is already logged in or not.\n\n        \"\"\"\n        if self.login_handler is None:\n            return False\n        return bool(self.login_handler.login_available(self.settings))\n\n\nclass IPythonHandler(AuthenticatedHandler):\n    \"\"\"IPython-specific extensions to authenticated handling\n    \n    Mostly property shortcuts to IPython-specific settings.\n    \"\"\"\n    \n    @property\n    def config(self):\n        return self.settings.get('config', None)\n    \n    @property\n    def log(self):\n        \"\"\"use the IPython log by default, falling back on tornado's logger\"\"\"\n        if Application.initialized():\n            return Application.instance().log\n        else:\n            return app_log\n\n    @property\n    def jinja_template_vars(self):\n        \"\"\"User-supplied values to supply to jinja templates.\"\"\"\n        return self.settings.get('jinja_template_vars', {})\n    \n    #---------------------------------------------------------------\n    # URLs\n    #---------------------------------------------------------------\n    \n    @property\n    def version_hash(self):\n        \"\"\"The version hash to use for cache hints for static files\"\"\"\n        return self.settings.get('version_hash', '')\n    \n    @property\n    def mathjax_url(self):\n        return self.settings.get('mathjax_url', '')\n    \n    @property\n    def base_url(self):\n        return self.settings.get('base_url', '/')\n\n    @property\n    def default_url(self):\n        return self.settings.get('default_url', '')\n\n    @property\n    def ws_url(self):\n        return self.settings.get('websocket_url', '')\n\n    @property\n    def contents_js_source(self):\n        self.log.debug(\"Using contents: %s\", self.settings.get('contents_js_source',\n            'services/contents'))\n        return self.settings.get('contents_js_source', 'services/contents')\n    \n    #---------------------------------------------------------------\n    # Manager objects\n    #---------------------------------------------------------------\n    \n    @property\n    def kernel_manager(self):\n        return self.settings['kernel_manager']\n\n    @property\n    def contents_manager(self):\n        return self.settings['contents_manager']\n    \n    @property\n    def cluster_manager(self):\n        return self.settings['cluster_manager']\n    \n    @property\n    def session_manager(self):\n        return self.settings['session_manager']\n    \n    @property\n    def terminal_manager(self):\n        return self.settings['terminal_manager']\n    \n    @property\n    def kernel_spec_manager(self):\n        return self.settings['kernel_spec_manager']\n\n    @property\n    def config_manager(self):\n        return self.settings['config_manager']\n\n    #---------------------------------------------------------------\n    # CORS\n    #---------------------------------------------------------------\n    \n    @property\n    def allow_origin(self):\n        \"\"\"Normal Access-Control-Allow-Origin\"\"\"\n        return self.settings.get('allow_origin', '')\n    \n    @property\n    def allow_origin_pat(self):\n        \"\"\"Regular expression version of allow_origin\"\"\"\n        return self.settings.get('allow_origin_pat', None)\n    \n    @property\n    def allow_credentials(self):\n        \"\"\"Whether to set Access-Control-Allow-Credentials\"\"\"\n        return self.settings.get('allow_credentials', False)\n    \n    def set_default_headers(self):\n        \"\"\"Add CORS headers, if defined\"\"\"\n        super(IPythonHandler, self).set_default_headers()\n        if self.allow_origin:\n            self.set_header(\"Access-Control-Allow-Origin\", self.allow_origin)\n        elif self.allow_origin_pat:\n            origin = self.get_origin()\n            if origin and self.allow_origin_pat.match(origin):\n                self.set_header(\"Access-Control-Allow-Origin\", origin)\n        if self.allow_credentials:\n            self.set_header(\"Access-Control-Allow-Credentials\", 'true')\n    \n    def get_origin(self):\n        # Handle WebSocket Origin naming convention differences\n        # The difference between version 8 and 13 is that in 8 the\n        # client sends a \"Sec-Websocket-Origin\" header and in 13 it's\n        # simply \"Origin\".\n        if \"Origin\" in self.request.headers:\n            origin = self.request.headers.get(\"Origin\")\n        else:\n            origin = self.request.headers.get(\"Sec-Websocket-Origin\", None)\n        return origin\n    \n    #---------------------------------------------------------------\n    # template rendering\n    #---------------------------------------------------------------\n    \n    def get_template(self, name):\n        \"\"\"Return the jinja template object for a given name\"\"\"\n        return self.settings['jinja2_env'].get_template(name)\n    \n    def render_template(self, name, **ns):\n        ns.update(self.template_namespace)\n        template = self.get_template(name)\n        return template.render(**ns)\n    \n    @property\n    def template_namespace(self):\n        return dict(\n            base_url=self.base_url,\n            default_url=self.default_url,\n            ws_url=self.ws_url,\n            logged_in=self.logged_in,\n            login_available=self.login_available,\n            static_url=self.static_url,\n            sys_info=sys_info,\n            contents_js_source=self.contents_js_source,\n            version_hash=self.version_hash,\n            **self.jinja_template_vars\n        )\n    \n    def get_json_body(self):\n        \"\"\"Return the body of the request as JSON data.\"\"\"\n        if not self.request.body:\n            return None\n        # Do we need to call body.decode('utf-8') here?\n        body = self.request.body.strip().decode(u'utf-8')\n        try:\n            model = json.loads(body)\n        except Exception:\n            self.log.debug(\"Bad JSON: %r\", body)\n            self.log.error(\"Couldn't parse JSON\", exc_info=True)\n            raise web.HTTPError(400, u'Invalid JSON in body of request')\n        return model\n\n    def write_error(self, status_code, **kwargs):\n        \"\"\"render custom error pages\"\"\"\n        exc_info = kwargs.get('exc_info')\n        message = ''\n        status_message = responses.get(status_code, 'Unknown HTTP Error')\n        if exc_info:\n            exception = exc_info[1]\n            # get the custom message, if defined\n            try:\n                message = exception.log_message % exception.args\n            except Exception:\n                pass\n            \n            # construct the custom reason, if defined\n            reason = getattr(exception, 'reason', '')\n            if reason:\n                status_message = reason\n        \n        # build template namespace\n        ns = dict(\n            status_code=status_code,\n            status_message=status_message,\n            message=message,\n            exception=exception,\n        )\n        \n        self.set_header('Content-Type', 'text/html')\n        # render the template\n        try:\n            html = self.render_template('%s.html' % status_code, **ns)\n        except TemplateNotFound:\n            self.log.debug(\"No template for %d\", status_code)\n            html = self.render_template('error.html', **ns)\n        \n        self.write(html)\n\n\nclass APIHandler(IPythonHandler):\n    \"\"\"Base class for API handlers\"\"\"\n    \n    @property\n    def content_security_policy(self):\n        csp = '; '.join([\n                super(APIHandler, self).content_security_policy,\n                \"default-src 'none'\",\n            ])\n        return csp\n    \n    def finish(self, *args, **kwargs):\n        self.set_header('Content-Type', 'application/json')\n        return super(APIHandler, self).finish(*args, **kwargs)\n\n\nclass Template404(IPythonHandler):\n    \"\"\"Render our 404 template\"\"\"\n    def prepare(self):\n        raise web.HTTPError(404)\n\n\nclass AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):\n    \"\"\"static files should only be accessible when logged in\"\"\"\n\n    @web.authenticated\n    def get(self, path):\n        if os.path.splitext(path)[1] == '.ipynb':\n            name = path.rsplit('/', 1)[-1]\n            self.set_header('Content-Type', 'application/json')\n            self.set_header('Content-Disposition','attachment; filename=\"%s\"' % name)\n        \n        return web.StaticFileHandler.get(self, path)\n    \n    def set_headers(self):\n        super(AuthenticatedFileHandler, self).set_headers()\n        # disable browser caching, rely on 304 replies for savings\n        if \"v\" not in self.request.arguments:\n            self.add_header(\"Cache-Control\", \"no-cache\")\n    \n    def compute_etag(self):\n        return None\n    \n    def validate_absolute_path(self, root, absolute_path):\n        \"\"\"Validate and return the absolute path.\n        \n        Requires tornado 3.1\n        \n        Adding to tornado's own handling, forbids the serving of hidden files.\n        \"\"\"\n        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)\n        abs_root = os.path.abspath(root)\n        if is_hidden(abs_path, abs_root):\n            self.log.info(\"Refusing to serve hidden file, via 404 Error\")\n            raise web.HTTPError(404)\n        return abs_path\n\n\ndef json_errors(method):\n    \"\"\"Decorate methods with this to return GitHub style JSON errors.\n    \n    This should be used on any JSON API on any handler method that can raise HTTPErrors.\n    \n    This will grab the latest HTTPError exception using sys.exc_info\n    and then:\n    \n    1. Set the HTTP status code based on the HTTPError\n    2. Create and return a JSON body with a message field describing\n       the error in a human readable form.\n    \"\"\"\n    @functools.wraps(method)\n    @gen.coroutine\n    def wrapper(self, *args, **kwargs):\n        try:\n            result = yield gen.maybe_future(method(self, *args, **kwargs))\n        except web.HTTPError as e:\n            self.set_header('Content-Type', 'application/json')\n            status = e.status_code\n            message = e.log_message\n            self.log.warn(message)\n            self.set_status(e.status_code)\n            reply = dict(message=message, reason=e.reason)\n            self.finish(json.dumps(reply))\n        except Exception:\n            self.set_header('Content-Type', 'application/json')\n            self.log.error(\"Unhandled error in API request\", exc_info=True)\n            status = 500\n            message = \"Unknown server error\"\n            t, value, tb = sys.exc_info()\n            self.set_status(status)\n            tb_text = ''.join(traceback.format_exception(t, value, tb))\n            reply = dict(message=message, reason=None, traceback=tb_text)\n            self.finish(json.dumps(reply))\n        else:\n            # FIXME: can use regular return in generators in py3\n            raise gen.Return(result)\n    return wrapper\n\n\n\n#-----------------------------------------------------------------------------\n# File handler\n#-----------------------------------------------------------------------------\n\n# to minimize subclass changes:\nHTTPError = web.HTTPError\n\nclass FileFindHandler(IPythonHandler, web.StaticFileHandler):\n    \"\"\"subclass of StaticFileHandler for serving files from a search path\"\"\"\n    \n    # cache search results, don't search for files more than once\n    _static_paths = {}\n    \n    def set_headers(self):\n        super(FileFindHandler, self).set_headers()\n        # disable browser caching, rely on 304 replies for savings\n        if \"v\" not in self.request.arguments or \\\n                any(self.request.path.startswith(path) for path in self.no_cache_paths):\n            self.set_header(\"Cache-Control\", \"no-cache\")\n    \n    def initialize(self, path, default_filename=None, no_cache_paths=None):\n        self.no_cache_paths = no_cache_paths or []\n        \n        if isinstance(path, string_types):\n            path = [path]\n        \n        self.root = tuple(\n            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path\n        )\n        self.default_filename = default_filename\n    \n    def compute_etag(self):\n        return None\n    \n    @classmethod\n    def get_absolute_path(cls, roots, path):\n        \"\"\"locate a file to serve on our static file search path\"\"\"\n        with cls._lock:\n            if path in cls._static_paths:\n                return cls._static_paths[path]\n            try:\n                abspath = os.path.abspath(filefind(path, roots))\n            except IOError:\n                # IOError means not found\n                return ''\n            \n            cls._static_paths[path] = abspath\n            return abspath\n    \n    def validate_absolute_path(self, root, absolute_path):\n        \"\"\"check if the file should be served (raises 404, 403, etc.)\"\"\"\n        if absolute_path == '':\n            raise web.HTTPError(404)\n        \n        for root in self.root:\n            if (absolute_path + os.sep).startswith(root):\n                break\n        \n        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)\n\n\nclass APIVersionHandler(APIHandler):\n\n    @json_errors\n    def get(self):\n        # not authenticated, so give as few info as possible\n        self.finish(json.dumps({\"version\":IPython.__version__}))\n\n\nclass TrailingSlashHandler(web.RequestHandler):\n    \"\"\"Simple redirect handler that strips trailing slashes\n    \n    This should be the first, highest priority handler.\n    \"\"\"\n    \n    def get(self):\n        self.redirect(self.request.uri.rstrip('/'))\n    \n    post = put = get\n\n\nclass FilesRedirectHandler(IPythonHandler):\n    \"\"\"Handler for redirecting relative URLs to the /files/ handler\"\"\"\n    \n    @staticmethod\n    def redirect_to_files(self, path):\n        \"\"\"make redirect logic a reusable static method\n        \n        so it can be called from other handlers.\n        \"\"\"\n        cm = self.contents_manager\n        if cm.dir_exists(path):\n            # it's a *directory*, redirect to /tree\n            url = url_path_join(self.base_url, 'tree', path)\n        else:\n            orig_path = path\n            # otherwise, redirect to /files\n            parts = path.split('/')\n\n            if not cm.file_exists(path=path) and 'files' in parts:\n                # redirect without files/ iff it would 404\n                # this preserves pre-2.0-style 'files/' links\n                self.log.warn(\"Deprecated files/ URL: %s\", orig_path)\n                parts.remove('files')\n                path = '/'.join(parts)\n\n            if not cm.file_exists(path=path):\n                raise web.HTTPError(404)\n\n            url = url_path_join(self.base_url, 'files', path)\n        url = url_escape(url)\n        self.log.debug(\"Redirecting %s to %s\", self.request.path, url)\n        self.redirect(url)\n    \n    def get(self, path=''):\n        return self.redirect_to_files(self, path)\n\n\n#-----------------------------------------------------------------------------\n# URL pattern fragments for re-use\n#-----------------------------------------------------------------------------\n\n# path matches any number of `/foo[/bar...]` or just `/` or ''\npath_regex = r\"(?P<path>(?:(?:/[^/]+)+|/?))\"\n\n#-----------------------------------------------------------------------------\n# URL to handler mappings\n#-----------------------------------------------------------------------------\n\n\ndefault_handlers = [\n    (r\".*/\", TrailingSlashHandler),\n    (r\"api\", APIVersionHandler)\n]\n", "\"\"\"Tornado handlers for cluster web service.\"\"\"\n\n# Copyright (c) IPython Development Team.\n# Distributed under the terms of the Modified BSD License.\n\nimport json\n\nfrom tornado import web\n\nfrom ...base.handlers import APIHandler\n\n#-----------------------------------------------------------------------------\n# Cluster handlers\n#-----------------------------------------------------------------------------\n\n\nclass MainClusterHandler(APIHandler):\n\n    @web.authenticated\n    def get(self):\n        self.finish(json.dumps(self.cluster_manager.list_profiles()))\n\n\nclass ClusterProfileHandler(APIHandler):\n\n    @web.authenticated\n    def get(self, profile):\n        self.finish(json.dumps(self.cluster_manager.profile_info(profile)))\n\n\nclass ClusterActionHandler(APIHandler):\n\n    @web.authenticated\n    def post(self, profile, action):\n        cm = self.cluster_manager\n        if action == 'start':\n            n = self.get_argument('n', default=None)\n            if not n:\n                data = cm.start_cluster(profile)\n            else:\n                data = cm.start_cluster(profile, int(n))\n        if action == 'stop':\n            data = cm.stop_cluster(profile)\n        self.finish(json.dumps(data))\n\n\n#-----------------------------------------------------------------------------\n# URL to handler mappings\n#-----------------------------------------------------------------------------\n\n\n_cluster_action_regex = r\"(?P<action>start|stop)\"\n_profile_regex = r\"(?P<profile>[^\\/]+)\" # there is almost no text that is invalid\n\ndefault_handlers = [\n    (r\"/clusters\", MainClusterHandler),\n    (r\"/clusters/%s/%s\" % (_profile_regex, _cluster_action_regex), ClusterActionHandler),\n    (r\"/clusters/%s\" % _profile_regex, ClusterProfileHandler),\n]\n", "\"\"\"Tornado handlers for frontend config storage.\"\"\"\n\n# Copyright (c) IPython Development Team.\n# Distributed under the terms of the Modified BSD License.\nimport json\nimport os\nimport io\nimport errno\nfrom tornado import web\n\nfrom IPython.utils.py3compat import PY3\nfrom ...base.handlers import APIHandler, json_errors\n\nclass ConfigHandler(APIHandler):\n    SUPPORTED_METHODS = ('GET', 'PUT', 'PATCH')\n\n    @web.authenticated\n    @json_errors\n    def get(self, section_name):\n        self.set_header(\"Content-Type\", 'application/json')\n        self.finish(json.dumps(self.config_manager.get(section_name)))\n\n    @web.authenticated\n    @json_errors\n    def put(self, section_name):\n        data = self.get_json_body()  # Will raise 400 if content is not valid JSON\n        self.config_manager.set(section_name, data)\n        self.set_status(204)\n\n    @web.authenticated\n    @json_errors\n    def patch(self, section_name):\n        new_data = self.get_json_body()\n        section = self.config_manager.update(section_name, new_data)\n        self.finish(json.dumps(section))\n\n\n# URL to handler mappings\n\nsection_name_regex = r\"(?P<section_name>\\w+)\"\n\ndefault_handlers = [\n    (r\"/api/config/%s\" % section_name_regex, ConfigHandler),\n]\n", "\"\"\"Tornado handlers for the contents web service.\"\"\"\n\n# Copyright (c) IPython Development Team.\n# Distributed under the terms of the Modified BSD License.\n\nimport json\n\nfrom tornado import gen, web\n\nfrom IPython.html.utils import url_path_join, url_escape\nfrom IPython.utils.jsonutil import date_default\n\nfrom IPython.html.base.handlers import (\n    IPythonHandler, APIHandler, json_errors, path_regex,\n)\n\n\ndef sort_key(model):\n    \"\"\"key function for case-insensitive sort by name and type\"\"\"\n    iname = model['name'].lower()\n    type_key = {\n        'directory' : '0',\n        'notebook'  : '1',\n        'file'      : '2',\n    }.get(model['type'], '9')\n    return u'%s%s' % (type_key, iname)\n\n\ndef validate_model(model, expect_content):\n    \"\"\"\n    Validate a model returned by a ContentsManager method.\n\n    If expect_content is True, then we expect non-null entries for 'content'\n    and 'format'.\n    \"\"\"\n    required_keys = {\n        \"name\",\n        \"path\",\n        \"type\",\n        \"writable\",\n        \"created\",\n        \"last_modified\",\n        \"mimetype\",\n        \"content\",\n        \"format\",\n    }\n    missing = required_keys - set(model.keys())\n    if missing:\n        raise web.HTTPError(\n            500,\n            u\"Missing Model Keys: {missing}\".format(missing=missing),\n        )\n\n    maybe_none_keys = ['content', 'format']\n    if model['type'] == 'file':\n        # mimetype should be populated only for file models\n        maybe_none_keys.append('mimetype')\n    if expect_content:\n        errors = [key for key in maybe_none_keys if model[key] is None]\n        if errors:\n            raise web.HTTPError(\n                500,\n                u\"Keys unexpectedly None: {keys}\".format(keys=errors),\n            )\n    else:\n        errors = {\n            key: model[key]\n            for key in maybe_none_keys\n            if model[key] is not None\n        }\n        if errors:\n            raise web.HTTPError(\n                500,\n                u\"Keys unexpectedly not None: {keys}\".format(keys=errors),\n            )\n\n\nclass ContentsHandler(APIHandler):\n\n    SUPPORTED_METHODS = (u'GET', u'PUT', u'PATCH', u'POST', u'DELETE')\n\n    def location_url(self, path):\n        \"\"\"Return the full URL location of a file.\n\n        Parameters\n        ----------\n        path : unicode\n            The API path of the file, such as \"foo/bar.txt\".\n        \"\"\"\n        return url_escape(url_path_join(\n            self.base_url, 'api', 'contents', path\n        ))\n\n    def _finish_model(self, model, location=True):\n        \"\"\"Finish a JSON request with a model, setting relevant headers, etc.\"\"\"\n        if location:\n            location = self.location_url(model['path'])\n            self.set_header('Location', location)\n        self.set_header('Last-Modified', model['last_modified'])\n        self.set_header('Content-Type', 'application/json')\n        self.finish(json.dumps(model, default=date_default))\n\n    @web.authenticated\n    @json_errors\n    @gen.coroutine\n    def get(self, path=''):\n        \"\"\"Return a model for a file or directory.\n\n        A directory model contains a list of models (without content)\n        of the files and directories it contains.\n        \"\"\"\n        path = path or ''\n        type = self.get_query_argument('type', default=None)\n        if type not in {None, 'directory', 'file', 'notebook'}:\n            raise web.HTTPError(400, u'Type %r is invalid' % type)\n\n        format = self.get_query_argument('format', default=None)\n        if format not in {None, 'text', 'base64'}:\n            raise web.HTTPError(400, u'Format %r is invalid' % format)\n        content = self.get_query_argument('content', default='1')\n        if content not in {'0', '1'}:\n            raise web.HTTPError(400, u'Content %r is invalid' % content)\n        content = int(content)\n        \n        model = yield gen.maybe_future(self.contents_manager.get(\n            path=path, type=type, format=format, content=content,\n        ))\n        if model['type'] == 'directory' and content:\n            # group listing by type, then by name (case-insensitive)\n            # FIXME: sorting should be done in the frontends\n            model['content'].sort(key=sort_key)\n        validate_model(model, expect_content=content)\n        self._finish_model(model, location=False)\n\n    @web.authenticated\n    @json_errors\n    @gen.coroutine\n    def patch(self, path=''):\n        \"\"\"PATCH renames a file or directory without re-uploading content.\"\"\"\n        cm = self.contents_manager\n        model = self.get_json_body()\n        if model is None:\n            raise web.HTTPError(400, u'JSON body missing')\n        model = yield gen.maybe_future(cm.update(model, path))\n        validate_model(model, expect_content=False)\n        self._finish_model(model)\n    \n    @gen.coroutine\n    def _copy(self, copy_from, copy_to=None):\n        \"\"\"Copy a file, optionally specifying a target directory.\"\"\"\n        self.log.info(u\"Copying {copy_from} to {copy_to}\".format(\n            copy_from=copy_from,\n            copy_to=copy_to or '',\n        ))\n        model = yield gen.maybe_future(self.contents_manager.copy(copy_from, copy_to))\n        self.set_status(201)\n        validate_model(model, expect_content=False)\n        self._finish_model(model)\n\n    @gen.coroutine\n    def _upload(self, model, path):\n        \"\"\"Handle upload of a new file to path\"\"\"\n        self.log.info(u\"Uploading file to %s\", path)\n        model = yield gen.maybe_future(self.contents_manager.new(model, path))\n        self.set_status(201)\n        validate_model(model, expect_content=False)\n        self._finish_model(model)\n    \n    @gen.coroutine\n    def _new_untitled(self, path, type='', ext=''):\n        \"\"\"Create a new, empty untitled entity\"\"\"\n        self.log.info(u\"Creating new %s in %s\", type or 'file', path)\n        model = yield gen.maybe_future(self.contents_manager.new_untitled(path=path, type=type, ext=ext))\n        self.set_status(201)\n        validate_model(model, expect_content=False)\n        self._finish_model(model)\n    \n    @gen.coroutine\n    def _save(self, model, path):\n        \"\"\"Save an existing file.\"\"\"\n        self.log.info(u\"Saving file at %s\", path)\n        model = yield gen.maybe_future(self.contents_manager.save(model, path))\n        validate_model(model, expect_content=False)\n        self._finish_model(model)\n\n    @web.authenticated\n    @json_errors\n    @gen.coroutine\n    def post(self, path=''):\n        \"\"\"Create a new file in the specified path.\n\n        POST creates new files. The server always decides on the name.\n\n        POST /api/contents/path\n          New untitled, empty file or directory.\n        POST /api/contents/path\n          with body {\"copy_from\" : \"/path/to/OtherNotebook.ipynb\"}\n          New copy of OtherNotebook in path\n        \"\"\"\n\n        cm = self.contents_manager\n\n        if cm.file_exists(path):\n            raise web.HTTPError(400, \"Cannot POST to files, use PUT instead.\")\n\n        if not cm.dir_exists(path):\n            raise web.HTTPError(404, \"No such directory: %s\" % path)\n\n        model = self.get_json_body()\n\n        if model is not None:\n            copy_from = model.get('copy_from')\n            ext = model.get('ext', '')\n            type = model.get('type', '')\n            if copy_from:\n                yield self._copy(copy_from, path)\n            else:\n                yield self._new_untitled(path, type=type, ext=ext)\n        else:\n            yield self._new_untitled(path)\n\n    @web.authenticated\n    @json_errors\n    @gen.coroutine\n    def put(self, path=''):\n        \"\"\"Saves the file in the location specified by name and path.\n\n        PUT is very similar to POST, but the requester specifies the name,\n        whereas with POST, the server picks the name.\n\n        PUT /api/contents/path/Name.ipynb\n          Save notebook at ``path/Name.ipynb``. Notebook structure is specified\n          in `content` key of JSON request body. If content is not specified,\n          create a new empty notebook.\n        \"\"\"\n        model = self.get_json_body()\n        if model:\n            if model.get('copy_from'):\n                raise web.HTTPError(400, \"Cannot copy with PUT, only POST\")\n            exists = yield gen.maybe_future(self.contents_manager.file_exists(path))\n            if exists:\n                yield gen.maybe_future(self._save(model, path))\n            else:\n                yield gen.maybe_future(self._upload(model, path))\n        else:\n            yield gen.maybe_future(self._new_untitled(path))\n\n    @web.authenticated\n    @json_errors\n    @gen.coroutine\n    def delete(self, path=''):\n        \"\"\"delete a file in the given path\"\"\"\n        cm = self.contents_manager\n        self.log.warn('delete %s', path)\n        yield gen.maybe_future(cm.delete(path))\n        self.set_status(204)\n        self.finish()\n\n\nclass CheckpointsHandler(APIHandler):\n\n    SUPPORTED_METHODS = ('GET', 'POST')\n\n    @web.authenticated\n    @json_errors\n    @gen.coroutine\n    def get(self, path=''):\n        \"\"\"get lists checkpoints for a file\"\"\"\n        cm = self.contents_manager\n        checkpoints = yield gen.maybe_future(cm.list_checkpoints(path))\n        data = json.dumps(checkpoints, default=date_default)\n        self.finish(data)\n\n    @web.authenticated\n    @json_errors\n    @gen.coroutine\n    def post(self, path=''):\n        \"\"\"post creates a new checkpoint\"\"\"\n        cm = self.contents_manager\n        checkpoint = yield gen.maybe_future(cm.create_checkpoint(path))\n        data = json.dumps(checkpoint, default=date_default)\n        location = url_path_join(self.base_url, 'api/contents',\n            path, 'checkpoints', checkpoint['id'])\n        self.set_header('Location', url_escape(location))\n        self.set_status(201)\n        self.finish(data)\n\n\nclass ModifyCheckpointsHandler(APIHandler):\n\n    SUPPORTED_METHODS = ('POST', 'DELETE')\n\n    @web.authenticated\n    @json_errors\n    @gen.coroutine\n    def post(self, path, checkpoint_id):\n        \"\"\"post restores a file from a checkpoint\"\"\"\n        cm = self.contents_manager\n        yield gen.maybe_future(cm.restore_checkpoint(checkpoint_id, path))\n        self.set_status(204)\n        self.finish()\n\n    @web.authenticated\n    @json_errors\n    @gen.coroutine\n    def delete(self, path, checkpoint_id):\n        \"\"\"delete clears a checkpoint for a given file\"\"\"\n        cm = self.contents_manager\n        yield gen.maybe_future(cm.delete_checkpoint(checkpoint_id, path))\n        self.set_status(204)\n        self.finish()\n\n\nclass NotebooksRedirectHandler(IPythonHandler):\n    \"\"\"Redirect /api/notebooks to /api/contents\"\"\"\n    SUPPORTED_METHODS = ('GET', 'PUT', 'PATCH', 'POST', 'DELETE')\n\n    def get(self, path):\n        self.log.warn(\"/api/notebooks is deprecated, use /api/contents\")\n        self.redirect(url_path_join(\n            self.base_url,\n            'api/contents',\n            path\n        ))\n\n    put = patch = post = delete = get\n\n\n#-----------------------------------------------------------------------------\n# URL to handler mappings\n#-----------------------------------------------------------------------------\n\n\n_checkpoint_id_regex = r\"(?P<checkpoint_id>[\\w-]+)\"\n\ndefault_handlers = [\n    (r\"/api/contents%s/checkpoints\" % path_regex, CheckpointsHandler),\n    (r\"/api/contents%s/checkpoints/%s\" % (path_regex, _checkpoint_id_regex),\n        ModifyCheckpointsHandler),\n    (r\"/api/contents%s\" % path_regex, ContentsHandler),\n    (r\"/api/notebooks/?(.*)\", NotebooksRedirectHandler),\n]\n", "\"\"\"Tornado handlers for kernels.\"\"\"\n\n# Copyright (c) IPython Development Team.\n# Distributed under the terms of the Modified BSD License.\n\nimport json\nimport logging\nfrom tornado import gen, web\nfrom tornado.concurrent import Future\nfrom tornado.ioloop import IOLoop\n\nfrom IPython.utils.jsonutil import date_default\nfrom IPython.utils.py3compat import cast_unicode\nfrom IPython.html.utils import url_path_join, url_escape\n\nfrom ...base.handlers import IPythonHandler, APIHandler, json_errors\nfrom ...base.zmqhandlers import AuthenticatedZMQStreamHandler, deserialize_binary_message\n\nfrom IPython.core.release import kernel_protocol_version\n\nclass MainKernelHandler(APIHandler):\n\n    @web.authenticated\n    @json_errors\n    def get(self):\n        km = self.kernel_manager\n        self.finish(json.dumps(km.list_kernels()))\n\n    @web.authenticated\n    @json_errors\n    def post(self):\n        km = self.kernel_manager\n        model = self.get_json_body()\n        if model is None:\n            model = {\n                'name': km.default_kernel_name\n            }\n        else:\n            model.setdefault('name', km.default_kernel_name)\n\n        kernel_id = km.start_kernel(kernel_name=model['name'])\n        model = km.kernel_model(kernel_id)\n        location = url_path_join(self.base_url, 'api', 'kernels', kernel_id)\n        self.set_header('Location', url_escape(location))\n        self.set_status(201)\n        self.finish(json.dumps(model))\n\n\nclass KernelHandler(APIHandler):\n\n    SUPPORTED_METHODS = ('DELETE', 'GET')\n\n    @web.authenticated\n    @json_errors\n    def get(self, kernel_id):\n        km = self.kernel_manager\n        km._check_kernel_id(kernel_id)\n        model = km.kernel_model(kernel_id)\n        self.finish(json.dumps(model))\n\n    @web.authenticated\n    @json_errors\n    def delete(self, kernel_id):\n        km = self.kernel_manager\n        km.shutdown_kernel(kernel_id)\n        self.set_status(204)\n        self.finish()\n\n\nclass KernelActionHandler(APIHandler):\n\n    @web.authenticated\n    @json_errors\n    def post(self, kernel_id, action):\n        km = self.kernel_manager\n        if action == 'interrupt':\n            km.interrupt_kernel(kernel_id)\n            self.set_status(204)\n        if action == 'restart':\n            km.restart_kernel(kernel_id)\n            model = km.kernel_model(kernel_id)\n            self.set_header('Location', '{0}api/kernels/{1}'.format(self.base_url, kernel_id))\n            self.write(json.dumps(model))\n        self.finish()\n\n\nclass ZMQChannelsHandler(AuthenticatedZMQStreamHandler):\n    \n    @property\n    def kernel_info_timeout(self):\n        return self.settings.get('kernel_info_timeout', 10)\n    \n    def __repr__(self):\n        return \"%s(%s)\" % (self.__class__.__name__, getattr(self, 'kernel_id', 'uninitialized'))\n    \n    def create_stream(self):\n        km = self.kernel_manager\n        identity = self.session.bsession\n        for channel in ('shell', 'iopub', 'stdin'):\n            meth = getattr(km, 'connect_' + channel)\n            self.channels[channel] = stream = meth(self.kernel_id, identity=identity)\n            stream.channel = channel\n        km.add_restart_callback(self.kernel_id, self.on_kernel_restarted)\n        km.add_restart_callback(self.kernel_id, self.on_restart_failed, 'dead')\n    \n    def request_kernel_info(self):\n        \"\"\"send a request for kernel_info\"\"\"\n        km = self.kernel_manager\n        kernel = km.get_kernel(self.kernel_id)\n        try:\n            # check for previous request\n            future = kernel._kernel_info_future\n        except AttributeError:\n            self.log.debug(\"Requesting kernel info from %s\", self.kernel_id)\n            # Create a kernel_info channel to query the kernel protocol version.\n            # This channel will be closed after the kernel_info reply is received.\n            if self.kernel_info_channel is None:\n                self.kernel_info_channel = km.connect_shell(self.kernel_id)\n            self.kernel_info_channel.on_recv(self._handle_kernel_info_reply)\n            self.session.send(self.kernel_info_channel, \"kernel_info_request\")\n            # store the future on the kernel, so only one request is sent\n            kernel._kernel_info_future = self._kernel_info_future\n        else:\n            if not future.done():\n                self.log.debug(\"Waiting for pending kernel_info request\")\n            future.add_done_callback(lambda f: self._finish_kernel_info(f.result()))\n        return self._kernel_info_future\n    \n    def _handle_kernel_info_reply(self, msg):\n        \"\"\"process the kernel_info_reply\n        \n        enabling msg spec adaptation, if necessary\n        \"\"\"\n        idents,msg = self.session.feed_identities(msg)\n        try:\n            msg = self.session.deserialize(msg)\n        except:\n            self.log.error(\"Bad kernel_info reply\", exc_info=True)\n            self._kernel_info_future.set_result({})\n            return\n        else:\n            info = msg['content']\n            self.log.debug(\"Received kernel info: %s\", info)\n            if msg['msg_type'] != 'kernel_info_reply' or 'protocol_version' not in info:\n                self.log.error(\"Kernel info request failed, assuming current %s\", info)\n                info = {}\n            self._finish_kernel_info(info)\n        \n        # close the kernel_info channel, we don't need it anymore\n        if self.kernel_info_channel:\n            self.kernel_info_channel.close()\n        self.kernel_info_channel = None\n    \n    def _finish_kernel_info(self, info):\n        \"\"\"Finish handling kernel_info reply\n        \n        Set up protocol adaptation, if needed,\n        and signal that connection can continue.\n        \"\"\"\n        protocol_version = info.get('protocol_version', kernel_protocol_version)\n        if protocol_version != kernel_protocol_version:\n            self.session.adapt_version = int(protocol_version.split('.')[0])\n            self.log.info(\"Adapting to protocol v%s for kernel %s\", protocol_version, self.kernel_id)\n        if not self._kernel_info_future.done():\n            self._kernel_info_future.set_result(info)\n    \n    def initialize(self):\n        super(ZMQChannelsHandler, self).initialize()\n        self.zmq_stream = None\n        self.channels = {}\n        self.kernel_id = None\n        self.kernel_info_channel = None\n        self._kernel_info_future = Future()\n    \n    @gen.coroutine\n    def pre_get(self):\n        # authenticate first\n        super(ZMQChannelsHandler, self).pre_get()\n        # then request kernel info, waiting up to a certain time before giving up.\n        # We don't want to wait forever, because browsers don't take it well when\n        # servers never respond to websocket connection requests.\n        kernel = self.kernel_manager.get_kernel(self.kernel_id)\n        self.session.key = kernel.session.key\n        future = self.request_kernel_info()\n        \n        def give_up():\n            \"\"\"Don't wait forever for the kernel to reply\"\"\"\n            if future.done():\n                return\n            self.log.warn(\"Timeout waiting for kernel_info reply from %s\", self.kernel_id)\n            future.set_result({})\n        loop = IOLoop.current()\n        loop.add_timeout(loop.time() + self.kernel_info_timeout, give_up)\n        # actually wait for it\n        yield future\n    \n    @gen.coroutine\n    def get(self, kernel_id):\n        self.kernel_id = cast_unicode(kernel_id, 'ascii')\n        yield super(ZMQChannelsHandler, self).get(kernel_id=kernel_id)\n    \n    def open(self, kernel_id):\n        super(ZMQChannelsHandler, self).open()\n        try:\n            self.create_stream()\n        except web.HTTPError as e:\n            self.log.error(\"Error opening stream: %s\", e)\n            # WebSockets don't response to traditional error codes so we\n            # close the connection.\n            for channel, stream in self.channels.items():\n                if not stream.closed():\n                    stream.close()\n            self.close()\n        else:\n            for channel, stream in self.channels.items():\n                stream.on_recv_stream(self._on_zmq_reply)\n\n    def on_message(self, msg):\n        if not self.channels:\n            # already closed, ignore the message\n            self.log.debug(\"Received message on closed websocket %r\", msg)\n            return\n        if isinstance(msg, bytes):\n            msg = deserialize_binary_message(msg)\n        else:\n            msg = json.loads(msg)\n        channel = msg.pop('channel', None)\n        if channel is None:\n            self.log.warn(\"No channel specified, assuming shell: %s\", msg)\n            channel = 'shell'\n        if channel not in self.channels:\n            self.log.warn(\"No such channel: %r\", channel)\n            return\n        stream = self.channels[channel]\n        self.session.send(stream, msg)\n\n    def on_close(self):\n        km = self.kernel_manager\n        if self.kernel_id in km:\n            km.remove_restart_callback(\n                self.kernel_id, self.on_kernel_restarted,\n            )\n            km.remove_restart_callback(\n                self.kernel_id, self.on_restart_failed, 'dead',\n            )\n        # This method can be called twice, once by self.kernel_died and once\n        # from the WebSocket close event. If the WebSocket connection is\n        # closed before the ZMQ streams are setup, they could be None.\n        for channel, stream in self.channels.items():\n            if stream is not None and not stream.closed():\n                stream.on_recv(None)\n                # close the socket directly, don't wait for the stream\n                socket = stream.socket\n                stream.close()\n                socket.close()\n        \n        self.channels = {}\n\n    def _send_status_message(self, status):\n        msg = self.session.msg(\"status\",\n            {'execution_state': status}\n        )\n        msg['channel'] = 'iopub'\n        self.write_message(json.dumps(msg, default=date_default))\n\n    def on_kernel_restarted(self):\n        logging.warn(\"kernel %s restarted\", self.kernel_id)\n        self._send_status_message('restarting')\n\n    def on_restart_failed(self):\n        logging.error(\"kernel %s restarted failed!\", self.kernel_id)\n        self._send_status_message('dead')\n\n\n#-----------------------------------------------------------------------------\n# URL to handler mappings\n#-----------------------------------------------------------------------------\n\n\n_kernel_id_regex = r\"(?P<kernel_id>\\w+-\\w+-\\w+-\\w+-\\w+)\"\n_kernel_action_regex = r\"(?P<action>restart|interrupt)\"\n\ndefault_handlers = [\n    (r\"/api/kernels\", MainKernelHandler),\n    (r\"/api/kernels/%s\" % _kernel_id_regex, KernelHandler),\n    (r\"/api/kernels/%s/%s\" % (_kernel_id_regex, _kernel_action_regex), KernelActionHandler),\n    (r\"/api/kernels/%s/channels\" % _kernel_id_regex, ZMQChannelsHandler),\n]\n", "\"\"\"Test the kernels service API.\"\"\"\n\nimport json\nimport requests\n\nfrom IPython.html.utils import url_path_join\nfrom IPython.html.tests.launchnotebook import NotebookTestBase, assert_http_error\n\nclass KernelAPI(object):\n    \"\"\"Wrapper for kernel REST API requests\"\"\"\n    def __init__(self, base_url):\n        self.base_url = base_url\n\n    def _req(self, verb, path, body=None):\n        response = requests.request(verb,\n                url_path_join(self.base_url, 'api/kernels', path), data=body)\n\n        if 400 <= response.status_code < 600:\n            try:\n                response.reason = response.json()['message']\n            except:\n                pass\n        response.raise_for_status()\n\n        return response\n\n    def list(self):\n        return self._req('GET', '')\n\n    def get(self, id):\n        return self._req('GET', id)\n\n    def start(self, name='python'):\n        body = json.dumps({'name': name})\n        return self._req('POST', '', body)\n\n    def shutdown(self, id):\n        return self._req('DELETE', id)\n\n    def interrupt(self, id):\n        return self._req('POST', url_path_join(id, 'interrupt'))\n\n    def restart(self, id):\n        return self._req('POST', url_path_join(id, 'restart'))\n\nclass KernelAPITest(NotebookTestBase):\n    \"\"\"Test the kernels web service API\"\"\"\n    def setUp(self):\n        self.kern_api = KernelAPI(self.base_url())\n\n    def tearDown(self):\n        for k in self.kern_api.list().json():\n            self.kern_api.shutdown(k['id'])\n\n    def test__no_kernels(self):\n        \"\"\"Make sure there are no kernels running at the start\"\"\"\n        kernels = self.kern_api.list().json()\n        self.assertEqual(kernels, [])\n\n    def test_default_kernel(self):\n        # POST request\n        r = self.kern_api._req('POST', '')\n        kern1 = r.json()\n        self.assertEqual(r.headers['location'], '/api/kernels/' + kern1['id'])\n        self.assertEqual(r.status_code, 201)\n        self.assertIsInstance(kern1, dict)\n\n        self.assertEqual(r.headers['Content-Security-Policy'], (\n                            \"frame-ancestors 'self'; \"\n                            \"report-uri /api/security/csp-report; \"\n                            \"default-src 'none'\"\n        ))\n\n    def test_main_kernel_handler(self):\n        # POST request\n        r = self.kern_api.start()\n        kern1 = r.json()\n        self.assertEqual(r.headers['location'], '/api/kernels/' + kern1['id'])\n        self.assertEqual(r.status_code, 201)\n        self.assertIsInstance(kern1, dict)\n\n        self.assertEqual(r.headers['Content-Security-Policy'], (\n                            \"frame-ancestors 'self'; \"\n                            \"report-uri /api/security/csp-report; \"\n                            \"default-src 'none'\"\n        ))\n\n        # GET request\n        r = self.kern_api.list()\n        self.assertEqual(r.status_code, 200)\n        assert isinstance(r.json(), list)\n        self.assertEqual(r.json()[0]['id'], kern1['id'])\n        self.assertEqual(r.json()[0]['name'], kern1['name'])\n\n        # create another kernel and check that they both are added to the\n        # list of kernels from a GET request\n        kern2 = self.kern_api.start().json()\n        assert isinstance(kern2, dict)\n        r = self.kern_api.list()\n        kernels = r.json()\n        self.assertEqual(r.status_code, 200)\n        assert isinstance(kernels, list)\n        self.assertEqual(len(kernels), 2)\n\n        # Interrupt a kernel\n        r = self.kern_api.interrupt(kern2['id'])\n        self.assertEqual(r.status_code, 204)\n\n        # Restart a kernel\n        r = self.kern_api.restart(kern2['id'])\n        self.assertEqual(r.headers['Location'], '/api/kernels/'+kern2['id'])\n        rekern = r.json()\n        self.assertEqual(rekern['id'], kern2['id'])\n        self.assertEqual(rekern['name'], kern2['name'])\n\n    def test_kernel_handler(self):\n        # GET kernel with given id\n        kid = self.kern_api.start().json()['id']\n        r = self.kern_api.get(kid)\n        kern1 = r.json()\n        self.assertEqual(r.status_code, 200)\n        assert isinstance(kern1, dict)\n        self.assertIn('id', kern1)\n        self.assertEqual(kern1['id'], kid)\n\n        # Request a bad kernel id and check that a JSON\n        # message is returned!\n        bad_id = '111-111-111-111-111'\n        with assert_http_error(404, 'Kernel does not exist: ' + bad_id):\n            self.kern_api.get(bad_id)\n\n        # DELETE kernel with id\n        r = self.kern_api.shutdown(kid)\n        self.assertEqual(r.status_code, 204)\n        kernels = self.kern_api.list().json()\n        self.assertEqual(kernels, [])\n\n        # Request to delete a non-existent kernel id\n        bad_id = '111-111-111-111-111'\n        with assert_http_error(404, 'Kernel does not exist: ' + bad_id):\n            self.kern_api.shutdown(bad_id)\n", "\"\"\"Tornado handlers for kernel specifications.\"\"\"\n\n# Copyright (c) IPython Development Team.\n# Distributed under the terms of the Modified BSD License.\n\nimport glob\nimport json\nimport os\npjoin = os.path.join\n\nfrom tornado import web\n\nfrom ...base.handlers import APIHandler, json_errors\nfrom ...utils import url_path_join\n\ndef kernelspec_model(handler, name):\n    \"\"\"Load a KernelSpec by name and return the REST API model\"\"\"\n    ksm = handler.kernel_spec_manager\n    spec = ksm.get_kernel_spec(name)\n    d = {'name': name}\n    d['spec'] = spec.to_dict()\n    d['resources'] = resources = {}\n    resource_dir = spec.resource_dir\n    for resource in ['kernel.js', 'kernel.css']:\n        if os.path.exists(pjoin(resource_dir, resource)):\n            resources[resource] = url_path_join(\n                handler.base_url,\n                'kernelspecs',\n                name,\n                resource\n            )\n    for logo_file in glob.glob(pjoin(resource_dir, 'logo-*')):\n        fname = os.path.basename(logo_file)\n        no_ext, _ = os.path.splitext(fname)\n        resources[no_ext] = url_path_join(\n            handler.base_url,\n            'kernelspecs',\n            name,\n            fname\n        )\n    return d\n\nclass MainKernelSpecHandler(APIHandler):\n    SUPPORTED_METHODS = ('GET',)\n\n    @web.authenticated\n    @json_errors\n    def get(self):\n        ksm = self.kernel_spec_manager\n        km = self.kernel_manager\n        model = {}\n        model['default'] = km.default_kernel_name\n        model['kernelspecs'] = specs = {}\n        for kernel_name in ksm.find_kernel_specs():\n            try:\n                d = kernelspec_model(self, kernel_name)\n            except Exception:\n                self.log.error(\"Failed to load kernel spec: '%s'\", kernel_name, exc_info=True)\n                continue\n            specs[kernel_name] = d\n        self.set_header(\"Content-Type\", 'application/json')\n        self.finish(json.dumps(model))\n\n\nclass KernelSpecHandler(APIHandler):\n    SUPPORTED_METHODS = ('GET',)\n\n    @web.authenticated\n    @json_errors\n    def get(self, kernel_name):\n        try:\n            model = kernelspec_model(self, kernel_name)\n        except KeyError:\n            raise web.HTTPError(404, u'Kernel spec %s not found' % kernel_name)\n        self.set_header(\"Content-Type\", 'application/json')\n        self.finish(json.dumps(model))\n\n\n# URL to handler mappings\n\nkernel_name_regex = r\"(?P<kernel_name>\\w+)\"\n\ndefault_handlers = [\n    (r\"/api/kernelspecs\", MainKernelSpecHandler),\n    (r\"/api/kernelspecs/%s\" % kernel_name_regex, KernelSpecHandler),\n]\n", "import json\n\nfrom tornado import web\n\nfrom ...base.handlers import APIHandler, json_errors\n\nclass NbconvertRootHandler(APIHandler):\n    SUPPORTED_METHODS = ('GET',)\n\n    @web.authenticated\n    @json_errors\n    def get(self):\n        try:\n            from IPython.nbconvert.exporters.export import exporter_map\n        except ImportError as e:\n            raise web.HTTPError(500, \"Could not import nbconvert: %s\" % e)\n        res = {}\n        for format, exporter in exporter_map.items():\n            res[format] = info = {}\n            info['output_mimetype'] = exporter.output_mimetype\n\n        self.finish(json.dumps(res))\n\ndefault_handlers = [\n    (r\"/api/nbconvert\", NbconvertRootHandler),\n]", "\"\"\"Tornado handlers for security logging.\"\"\"\n\n# Copyright (c) IPython Development Team.\n# Distributed under the terms of the Modified BSD License.\n\nfrom tornado import gen, web\n\nfrom ...base.handlers import APIHandler, json_errors\nfrom . import csp_report_uri\n\nclass CSPReportHandler(APIHandler):\n    '''Accepts a content security policy violation report'''\n    @web.authenticated\n    @json_errors\n    def post(self):\n        '''Log a content security policy violation report'''\n        csp_report = self.get_json_body()\n        self.log.warn(\"Content security violation: %s\",\n                      self.request.body.decode('utf8', 'replace'))\n\ndefault_handlers = [\n    (csp_report_uri, CSPReportHandler)\n]\n", "\"\"\"Tornado handlers for the sessions web service.\"\"\"\n\n# Copyright (c) IPython Development Team.\n# Distributed under the terms of the Modified BSD License.\n\nimport json\n\nfrom tornado import web\n\nfrom ...base.handlers import APIHandler, json_errors\nfrom IPython.utils.jsonutil import date_default\nfrom IPython.html.utils import url_path_join, url_escape\nfrom IPython.kernel.kernelspec import NoSuchKernel\n\n\nclass SessionRootHandler(APIHandler):\n\n    @web.authenticated\n    @json_errors\n    def get(self):\n        # Return a list of running sessions\n        sm = self.session_manager\n        sessions = sm.list_sessions()\n        self.finish(json.dumps(sessions, default=date_default))\n\n    @web.authenticated\n    @json_errors\n    def post(self):\n        # Creates a new session\n        #(unless a session already exists for the named nb)\n        sm = self.session_manager\n        cm = self.contents_manager\n        km = self.kernel_manager\n\n        model = self.get_json_body()\n        if model is None:\n            raise web.HTTPError(400, \"No JSON data provided\")\n        try:\n            path = model['notebook']['path']\n        except KeyError:\n            raise web.HTTPError(400, \"Missing field in JSON data: notebook.path\")\n        try:\n            kernel_name = model['kernel']['name']\n        except KeyError:\n            self.log.debug(\"No kernel name specified, using default kernel\")\n            kernel_name = None\n\n        # Check to see if session exists\n        if sm.session_exists(path=path):\n            model = sm.get_session(path=path)\n        else:\n            try:\n                model = sm.create_session(path=path, kernel_name=kernel_name)\n            except NoSuchKernel:\n                msg = (\"The '%s' kernel is not available. Please pick another \"\n                       \"suitable kernel instead, or install that kernel.\" % kernel_name)\n                status_msg = '%s not found' % kernel_name\n                self.log.warn('Kernel not found: %s' % kernel_name)\n                self.set_status(501)\n                self.finish(json.dumps(dict(message=msg, short_message=status_msg)))\n                return\n\n        location = url_path_join(self.base_url, 'api', 'sessions', model['id'])\n        self.set_header('Location', url_escape(location))\n        self.set_status(201)\n        self.finish(json.dumps(model, default=date_default))\n\nclass SessionHandler(APIHandler):\n\n    SUPPORTED_METHODS = ('GET', 'PATCH', 'DELETE')\n\n    @web.authenticated\n    @json_errors\n    def get(self, session_id):\n        # Returns the JSON model for a single session\n        sm = self.session_manager\n        model = sm.get_session(session_id=session_id)\n        self.finish(json.dumps(model, default=date_default))\n\n    @web.authenticated\n    @json_errors\n    def patch(self, session_id):\n        # Currently, this handler is strictly for renaming notebooks\n        sm = self.session_manager\n        model = self.get_json_body()\n        if model is None:\n            raise web.HTTPError(400, \"No JSON data provided\")\n        changes = {}\n        if 'notebook' in model:\n            notebook = model['notebook']\n            if 'path' in notebook:\n                changes['path'] = notebook['path']\n\n        sm.update_session(session_id, **changes)\n        model = sm.get_session(session_id=session_id)\n        self.finish(json.dumps(model, default=date_default))\n\n    @web.authenticated\n    @json_errors\n    def delete(self, session_id):\n        # Deletes the session with given session_id\n        sm = self.session_manager\n        try:\n            sm.delete_session(session_id)\n        except KeyError:\n            # the kernel was deleted but the session wasn't!\n            raise web.HTTPError(410, \"Kernel deleted before session\")\n        self.set_status(204)\n        self.finish()\n\n\n#-----------------------------------------------------------------------------\n# URL to handler mappings\n#-----------------------------------------------------------------------------\n\n_session_id_regex = r\"(?P<session_id>\\w+-\\w+-\\w+-\\w+-\\w+)\"\n\ndefault_handlers = [\n    (r\"/api/sessions/%s\" % _session_id_regex, SessionHandler),\n    (r\"/api/sessions\",  SessionRootHandler)\n]\n\n", "import json\nfrom tornado import web, gen\nfrom ..base.handlers import APIHandler, json_errors\nfrom ..utils import url_path_join\n\nclass TerminalRootHandler(APIHandler):\n    @web.authenticated\n    @json_errors\n    def get(self):\n        tm = self.terminal_manager\n        terms = [{'name': name} for name in tm.terminals]\n        self.finish(json.dumps(terms))\n\n    @web.authenticated\n    @json_errors\n    def post(self):\n        \"\"\"POST /terminals creates a new terminal and redirects to it\"\"\"\n        name, _ = self.terminal_manager.new_named_terminal()\n        self.finish(json.dumps({'name': name}))\n\n\nclass TerminalHandler(APIHandler):\n    SUPPORTED_METHODS = ('GET', 'DELETE')\n\n    @web.authenticated\n    @json_errors\n    def get(self, name):\n        tm = self.terminal_manager\n        if name in tm.terminals:\n            self.finish(json.dumps({'name': name}))\n        else:\n            raise web.HTTPError(404, \"Terminal not found: %r\" % name)\n\n    @web.authenticated\n    @json_errors\n    @gen.coroutine\n    def delete(self, name):\n        tm = self.terminal_manager\n        if name in tm.terminals:\n            yield tm.terminate(name, force=True)\n            self.set_status(204)\n            self.finish()\n        else:\n            raise web.HTTPError(404, \"Terminal not found: %r\" % name)\n"], "filenames": ["IPython/html/base/handlers.py", "IPython/html/services/clusters/handlers.py", "IPython/html/services/config/handlers.py", "IPython/html/services/contents/handlers.py", "IPython/html/services/kernels/handlers.py", "IPython/html/services/kernels/tests/test_kernels_api.py", "IPython/html/services/kernelspecs/handlers.py", "IPython/html/services/nbconvert/handlers.py", "IPython/html/services/security/handlers.py", "IPython/html/services/sessions/handlers.py", "IPython/html/terminal/api_handlers.py"], "buggy_code_start_loc": [44, 10, 12, 14, 16, 70, 13, 5, 8, 10, 3], "buggy_code_end_loc": [528, 32, 15, 290, 71, 84, 66, 8, 12, 69, 23], "fixing_code_start_loc": [45, 10, 12, 14, 16, 70, 13, 5, 8, 10, 3], "fixing_code_end_loc": [553, 32, 15, 290, 71, 86, 66, 8, 12, 69, 23], "type": "CWE-79", "message": "Cross-site scripting (XSS) vulnerability in IPython 3.x before 3.2 allows remote attackers to inject arbitrary web script or HTML via vectors involving JSON error messages and the /api/contents path.", "other": {"cve": {"id": "CVE-2015-4706", "sourceIdentifier": "cve@mitre.org", "published": "2017-09-21T14:29:00.230", "lastModified": "2017-09-30T10:12:25.710", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Cross-site scripting (XSS) vulnerability in IPython 3.x before 3.2 allows remote attackers to inject arbitrary web script or HTML via vectors involving JSON error messages and the /api/contents path."}, {"lang": "es", "value": "Una vulnerabilidad de tipo Cross-Site Scripting (XSS) en las versiones 3.x de IPython anteriores a la 3.2 permite que atacantes remotos inyecten scripts web o HTML mediante vectores que implican mensajes de error JSON y la ruta /api/contents."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ipython:ipython:3.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "790A7C14-145B-4683-AA47-E4B113CB97B3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ipython:ipython:3.1.0:*:*:*:*:*:*:*", "matchCriteriaId": "B9B56190-B31B-46E3-82D0-07E19EE0B5A3"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2015/06/22/7", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/75328", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1235688", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/ipython/ipython/commit/7222bd53ad089a65fd610fab4626f9d0ab47dfce", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ipython/ipython/commit/c2078a53543ed502efd968649fee1125e0eb549c", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://ipython.org/ipython-doc/3/whatsnew/version3.html", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/ipython/ipython/commit/7222bd53ad089a65fd610fab4626f9d0ab47dfce"}}