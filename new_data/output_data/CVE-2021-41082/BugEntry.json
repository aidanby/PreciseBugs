{"buggy_code": ["# frozen_string_literal: true\n\nclass TopicsController < ApplicationController\n  requires_login only: [\n    :timings,\n    :destroy_timings,\n    :update,\n    :update_shared_draft,\n    :destroy,\n    :recover,\n    :status,\n    :invite,\n    :mute,\n    :unmute,\n    :set_notifications,\n    :move_posts,\n    :merge_topic,\n    :clear_pin,\n    :re_pin,\n    :status_update,\n    :timer,\n    :bulk,\n    :reset_new,\n    :change_post_owners,\n    :change_timestamps,\n    :archive_message,\n    :move_to_inbox,\n    :convert_topic,\n    :bookmark,\n    :publish,\n    :reset_bump_date,\n    :set_slow_mode\n  ]\n\n  before_action :consider_user_for_promotion, only: :show\n\n  skip_before_action :check_xhr, only: [:show, :feed]\n\n  def id_for_slug\n    topic = Topic.find_by_slug(params[:slug])\n    guardian.ensure_can_see!(topic)\n    raise Discourse::NotFound unless topic\n    render json: { slug: topic.slug, topic_id: topic.id, url: topic.url }\n  end\n\n  def show\n    if request.referer\n      flash[\"referer\"] ||= request.referer[0..255]\n    end\n\n    # We'd like to migrate the wordpress feed to another url. This keeps up backwards compatibility with\n    # existing installs.\n    return wordpress if params[:best].present?\n\n    # work around people somehow sending in arrays,\n    # arrays are not supported\n    params[:page] = params[:page].to_i rescue 1\n\n    opts = params.slice(:username_filters, :filter, :page, :post_number, :show_deleted, :replies_to_post_number, :filter_upwards_post_id)\n    username_filters = opts[:username_filters]\n\n    opts[:print] = true if params[:print].present?\n    opts[:username_filters] = username_filters.split(',') if username_filters.is_a?(String)\n\n    # Special case: a slug with a number in front should look by slug first before looking\n    # up that particular number\n    if params[:id] && params[:id] =~ /^\\d+[^\\d\\\\]+$/\n      topic = Topic.find_by_slug(params[:id])\n      return redirect_to_correct_topic(topic, opts[:post_number]) if topic\n    end\n\n    if opts[:print]\n      raise Discourse::InvalidAccess unless SiteSetting.max_prints_per_hour_per_user > 0\n      begin\n        RateLimiter.new(current_user, \"print-topic-per-hour\", SiteSetting.max_prints_per_hour_per_user, 1.hour).performed! unless @guardian.is_admin?\n      rescue RateLimiter::LimitExceeded\n        return render_json_error I18n.t(\"rate_limiter.slow_down\")\n      end\n    end\n\n    begin\n      @topic_view = TopicView.new(params[:id] || params[:topic_id], current_user, opts)\n    rescue Discourse::NotFound => ex\n      if params[:id]\n        topic = Topic.find_by_slug(params[:id])\n        return redirect_to_correct_topic(topic, opts[:post_number]) if topic\n      end\n\n      raise ex\n    rescue Discourse::NotLoggedIn => ex\n      raise(SiteSetting.detailed_404 ? ex : Discourse::NotFound)\n    rescue Discourse::InvalidAccess => ex\n      # If the user can't see the topic, clean up notifications for it.\n      Notification.remove_for(current_user.id, params[:topic_id]) if current_user\n\n      deleted = guardian.can_see_topic?(ex.obj, false) ||\n        (!guardian.can_see_topic?(ex.obj) &&\n         ex.obj&.access_topic_via_group &&\n         ex.obj.deleted_at)\n\n      if SiteSetting.detailed_404\n        if deleted\n          raise Discourse::NotFound.new(\n            'deleted topic',\n            custom_message: 'deleted_topic',\n            status: 410,\n            check_permalinks: true,\n            original_path: ex.obj.relative_url\n          )\n        elsif !guardian.can_see_topic?(ex.obj) && group = ex.obj&.access_topic_via_group\n          raise Discourse::InvalidAccess.new(\n            'not in group',\n            ex.obj,\n            custom_message: 'not_in_group.title_topic',\n            custom_message_params: { group: group.name },\n            group: group\n          )\n        end\n\n        raise ex\n      else\n        raise Discourse::NotFound.new(\n          nil,\n          check_permalinks: deleted,\n          original_path: ex.obj.relative_url\n        )\n      end\n    end\n\n    page = params[:page]\n    if (page < 0) || ((page - 1) * @topic_view.chunk_size >= @topic_view.topic.highest_post_number)\n      raise Discourse::NotFound\n    end\n\n    discourse_expires_in 1.minute\n\n    if slugs_do_not_match || (!request.format.json? && params[:slug].nil?)\n      redirect_to_correct_topic(@topic_view.topic, opts[:post_number])\n      return\n    end\n\n    track_visit_to_topic\n\n    if should_track_visit_to_topic?\n      @topic_view.draft = Draft.get(current_user, @topic_view.draft_key, @topic_view.draft_sequence)\n    end\n\n    unless @topic_view.topic.visible\n      response.headers['X-Robots-Tag'] = 'noindex'\n    end\n\n    canonical_url UrlHelper.absolute_without_cdn(@topic_view.canonical_path)\n\n    # provide hint to crawlers only for now\n    # we would like to give them a bit more signal about age of data\n    if use_crawler_layout?\n      if last_modified = @topic_view.posts&.map { |p| p.updated_at }&.max&.httpdate\n        response.headers['Last-Modified'] = last_modified\n      end\n    end\n\n    perform_show_response\n  end\n\n  def publish\n    params.permit(:id, :destination_category_id)\n\n    topic = Topic.find(params[:id])\n    category = Category.find(params[:destination_category_id])\n\n    raise Discourse::InvalidParameters if category.id == SiteSetting.shared_drafts_category.to_i\n\n    guardian.ensure_can_publish_topic!(topic, category)\n    topic = TopicPublisher.new(topic, current_user, category.id).publish!\n\n    render_serialized(topic.reload, BasicTopicSerializer)\n  end\n\n  def wordpress\n    params.require(:best)\n    params.require(:topic_id)\n    params.permit(:min_trust_level, :min_score, :min_replies, :bypass_trust_level_score, :only_moderator_liked)\n\n    opts = {\n      best: params[:best].to_i,\n      min_trust_level: params[:min_trust_level] ? params[:min_trust_level].to_i : 1,\n      min_score: params[:min_score].to_i,\n      min_replies: params[:min_replies].to_i,\n      bypass_trust_level_score: params[:bypass_trust_level_score].to_i, # safe cause 0 means ignore\n      only_moderator_liked: params[:only_moderator_liked].to_s == \"true\",\n      exclude_hidden: true\n    }\n\n    @topic_view = TopicView.new(params[:topic_id], current_user, opts)\n    discourse_expires_in 1.minute\n\n    wordpress_serializer = TopicViewWordpressSerializer.new(@topic_view, scope: guardian, root: false)\n    render_json_dump(wordpress_serializer)\n  end\n\n  def post_ids\n    params.require(:topic_id)\n    params.permit(:post_number, :username_filters, :filter)\n\n    options = {\n      filter_post_number: params[:post_number],\n      filter: params[:filter],\n      skip_limit: true,\n      asc: true,\n      skip_custom_fields: true\n    }\n\n    fetch_topic_view(options)\n    render_json_dump(post_ids: @topic_view.posts.pluck(:id))\n  end\n\n  def posts\n    params.require(:topic_id)\n    params.permit(:post_ids, :post_number, :username_filters, :filter, :include_suggested)\n\n    include_suggested = params[:include_suggested] == \"true\"\n\n    options = {\n      filter_post_number: params[:post_number],\n      post_ids: params[:post_ids],\n      asc: ActiveRecord::Type::Boolean.new.deserialize(params[:asc]),\n      filter: params[:filter],\n      include_suggested: include_suggested,\n      include_related: include_suggested,\n    }\n\n    fetch_topic_view(options)\n\n    render_json_dump(\n      TopicViewPostsSerializer.new(\n        @topic_view,\n        scope: guardian,\n        root: false,\n        include_raw: !!params[:include_raw]\n      )\n    )\n  end\n\n  def excerpts\n    params.require(:topic_id)\n    params.require(:post_ids)\n\n    unless Array === params[:post_ids]\n      render_json_error(\"Expecting post_ids to contain a list of posts ids\")\n      return\n    end\n    post_ids = params[:post_ids].map(&:to_i)\n\n    if post_ids.length > 100\n      render_json_error(\"Requested a chunk that is too big\")\n      return\n    end\n\n    @topic = Topic.with_deleted.where(id: params[:topic_id]).first\n    guardian.ensure_can_see!(@topic)\n\n    @posts = Post.where(hidden: false, deleted_at: nil, topic_id: @topic.id)\n      .where('posts.id in (?)', post_ids)\n      .joins(\"LEFT JOIN users u on u.id = posts.user_id\")\n      .pluck(:id, :cooked, :username)\n      .map do |post_id, cooked, username|\n      {\n        post_id: post_id,\n        username: username,\n        excerpt: PrettyText.excerpt(cooked, 800, keep_emoji_images: true)\n      }\n    end\n\n    render json: @posts.to_json\n  end\n\n  def destroy_timings\n    topic_id = params[:topic_id].to_i\n\n    if params[:last].to_s == \"1\"\n      PostTiming.destroy_last_for(current_user, topic_id)\n    else\n      PostTiming.destroy_for(current_user.id, [topic_id])\n    end\n\n    last_notification = Notification\n      .where(\n        user_id: current_user.id,\n        topic_id: topic_id\n      )\n      .order(created_at: :desc)\n      .limit(1)\n      .first\n\n    if last_notification\n      last_notification.update!(read: false)\n    end\n\n    render body: nil\n  end\n\n  def update_shared_draft\n    topic = Topic.find_by(id: params[:id])\n    guardian.ensure_can_edit!(topic)\n\n    category = Category.where(id: params[:category_id].to_i).first\n    guardian.ensure_can_publish_topic!(topic, category)\n\n    row_count = SharedDraft.where(topic_id: topic.id).update_all(category_id: category.id)\n    if row_count == 0\n      SharedDraft.create(topic_id: topic.id, category_id: category.id)\n    end\n\n    render json: success_json\n  end\n\n  def update\n    topic = Topic.find_by(id: params[:topic_id])\n    guardian.ensure_can_edit!(topic)\n\n    if params[:category_id] && (params[:category_id].to_i != topic.category_id.to_i)\n      if topic.shared_draft\n        topic.shared_draft.update(category_id: params[:category_id])\n        params.delete(:category_id)\n      else\n        category = Category.find_by(id: params[:category_id])\n\n        if category || (params[:category_id].to_i == 0)\n          guardian.ensure_can_move_topic_to_category!(category)\n        else\n          return render_json_error(I18n.t('category.errors.not_found'))\n        end\n\n        if category && topic_tags = (params[:tags] || topic.tags.pluck(:name)).reject { |c| c.empty? }\n          if topic_tags.present?\n            allowed_tags = DiscourseTagging.filter_allowed_tags(\n              guardian,\n              category: category\n            ).map(&:name)\n\n            invalid_tags = topic_tags - allowed_tags\n\n            # Do not raise an error on a topic's hidden tags when not modifying tags\n            if params[:tags].blank?\n              invalid_tags.each do |tag_name|\n                if DiscourseTagging.hidden_tag_names.include?(tag_name)\n                  invalid_tags.delete(tag_name)\n                end\n              end\n            end\n\n            invalid_tags = Tag.where_name(invalid_tags).pluck(:name)\n\n            if !invalid_tags.empty?\n              if (invalid_tags & DiscourseTagging.hidden_tag_names).present?\n                return render_json_error(I18n.t('category.errors.disallowed_tags_generic'))\n              else\n                return render_json_error(I18n.t('category.errors.disallowed_topic_tags', tags: invalid_tags.join(\", \")))\n              end\n            end\n          end\n        end\n      end\n    end\n\n    changes = {}\n\n    PostRevisor.tracked_topic_fields.each_key do |f|\n      changes[f] = params[f] if params.has_key?(f)\n    end\n\n    changes.delete(:title) if topic.title == changes[:title]\n    changes.delete(:category_id) if topic.category_id.to_i == changes[:category_id].to_i\n\n    if Tag.include_tags?\n      topic_tags = topic.tags.map(&:name).sort\n      changes.delete(:tags) if changes[:tags]&.sort == topic_tags\n    end\n\n    success = true\n\n    if changes.length > 0\n      first_post = topic.ordered_posts.first\n      success = PostRevisor.new(first_post, topic).revise!(current_user, changes, validate_post: false)\n\n      if !success && topic.errors.blank?\n        topic.errors.add(:base, :unable_to_update)\n      end\n    end\n\n    # this is used to return the title to the client as it may have been changed by \"TextCleaner\"\n    success ? render_serialized(topic, BasicTopicSerializer) : render_json_error(topic)\n  end\n\n  def update_tags\n    params.require(:tags)\n    topic = Topic.find_by(id: params[:topic_id])\n    guardian.ensure_can_edit_tags!(topic)\n\n    success = PostRevisor.new(topic.first_post, topic).revise!(current_user, { tags: params[:tags] }, validate_post: false)\n\n    success ? render_serialized(topic, BasicTopicSerializer) : render_json_error(topic)\n  end\n\n  def feature_stats\n    params.require(:category_id)\n    category_id = params[:category_id].to_i\n\n    visible_topics = Topic.listable_topics.visible\n\n    render json: {\n      pinned_in_category_count: visible_topics.where(category_id: category_id).where(pinned_globally: false).where.not(pinned_at: nil).count,\n      pinned_globally_count: visible_topics.where(pinned_globally: true).where.not(pinned_at: nil).count,\n      banner_count: Topic.listable_topics.where(archetype: Archetype.banner).count,\n    }\n  end\n\n  def status\n    params.require(:status)\n    params.require(:enabled)\n    params.permit(:until)\n\n    status = params[:status]\n    topic_id = params[:topic_id].to_i\n    enabled = params[:enabled] == 'true'\n\n    check_for_status_presence(:status, status)\n    @topic = Topic.find_by(id: topic_id)\n\n    case status\n    when 'closed'\n      guardian.ensure_can_close_topic!(@topic)\n    when 'archived'\n      guardian.ensure_can_archive_topic!(@topic)\n    when 'visible'\n      guardian.ensure_can_toggle_topic_visibility!(@topic)\n    when 'pinned'\n      guardian.ensure_can_pin_unpin_topic!(@topic)\n    else\n      guardian.ensure_can_moderate!(@topic)\n    end\n\n    params[:until] === '' ? params[:until] = nil : params[:until]\n\n    @topic.update_status(status, enabled, current_user, until: params[:until])\n\n    render json: success_json.merge!(\n      topic_status_update: TopicTimerSerializer.new(\n        TopicTimer.find_by(topic: @topic), root: false\n      )\n    )\n  end\n\n  def mute\n    toggle_mute\n  end\n\n  def unmute\n    toggle_mute\n  end\n\n  def timer\n    params.permit(:time, :based_on_last_post, :category_id)\n    params.require(:status_type)\n\n    status_type =\n      begin\n        TopicTimer.types.fetch(params[:status_type].to_sym)\n      rescue\n        invalid_param(:status_type)\n      end\n    based_on_last_post = params[:based_on_last_post]\n    params.require(:duration_minutes) if based_on_last_post\n\n    topic = Topic.find_by(id: params[:topic_id])\n    guardian.ensure_can_moderate!(topic)\n\n    options = {\n      by_user: current_user,\n      based_on_last_post: based_on_last_post\n    }\n\n    options.merge!(category_id: params[:category_id]) if !params[:category_id].blank?\n    options.merge!(duration_minutes: params[:duration_minutes].to_i) if params[:duration_minutes].present?\n    options.merge!(duration: params[:duration].to_i) if params[:duration].present?\n\n    begin\n      topic_timer = topic.set_or_create_timer(\n        status_type,\n        params[:time],\n        **options\n      )\n    rescue ActiveRecord::RecordInvalid => e\n      return render_json_error(e.message)\n    end\n\n    if topic.save\n      render json: success_json.merge!(\n        execute_at: topic_timer&.execute_at,\n        duration_minutes: topic_timer&.duration_minutes,\n        based_on_last_post: topic_timer&.based_on_last_post,\n        closed: topic.closed,\n        category_id: topic_timer&.category_id\n      )\n    else\n      render_json_error(topic)\n    end\n  end\n\n  def make_banner\n    topic = Topic.find_by(id: params[:topic_id].to_i)\n    guardian.ensure_can_banner_topic!(topic)\n\n    topic.make_banner!(current_user)\n\n    render body: nil\n  end\n\n  def remove_banner\n    topic = Topic.find_by(id: params[:topic_id].to_i)\n    guardian.ensure_can_banner_topic!(topic)\n\n    topic.remove_banner!(current_user)\n\n    render body: nil\n  end\n\n  def remove_bookmarks\n    topic = Topic.find(params[:topic_id].to_i)\n    BookmarkManager.new(current_user).destroy_for_topic(topic)\n    render body: nil\n  end\n\n  def archive_message\n    toggle_archive_message(true)\n  end\n\n  def move_to_inbox\n    toggle_archive_message(false)\n  end\n\n  def toggle_archive_message(archive)\n    topic = Topic.find(params[:id].to_i)\n\n    group_id = nil\n\n    group_ids = current_user.groups.pluck(:id)\n    if group_ids.present?\n      allowed_groups = topic.allowed_groups\n        .where('topic_allowed_groups.group_id IN (?)', group_ids).pluck(:id)\n\n      allowed_groups.each do |id|\n        if archive\n          GroupArchivedMessage.archive!(\n            id,\n            topic,\n            acting_user_id: current_user.id\n          )\n\n          group_id = id\n        else\n          GroupArchivedMessage.move_to_inbox!(\n            id,\n            topic,\n            acting_user_id: current_user.id\n          )\n        end\n      end\n    end\n\n    if topic.allowed_users.include?(current_user)\n      if archive\n        UserArchivedMessage.archive!(current_user.id, topic)\n      else\n        UserArchivedMessage.move_to_inbox!(current_user.id, topic)\n      end\n    end\n\n    if group_id\n      name = Group.find_by(id: group_id).try(:name)\n      render_json_dump(group_name: name)\n    else\n      render body: nil\n    end\n  end\n\n  def bookmark\n    topic = Topic.find(params[:topic_id].to_i)\n    first_post = topic.ordered_posts.first\n\n    bookmark_manager = BookmarkManager.new(current_user)\n    bookmark_manager.create(post_id: first_post.id)\n\n    if bookmark_manager.errors.any?\n      return render_json_error(bookmark_manager, status: 400)\n    end\n\n    render body: nil\n  end\n\n  def destroy\n    topic = Topic.find_by(id: params[:id])\n    guardian.ensure_can_delete!(topic)\n\n    first_post = topic.ordered_posts.first\n    PostDestroyer.new(current_user, first_post, context: params[:context]).destroy\n\n    render body: nil\n  rescue Discourse::InvalidAccess\n    render_json_error I18n.t(\"delete_topic_failed\")\n  end\n\n  def recover\n    topic = Topic.where(id: params[:topic_id]).with_deleted.first\n    guardian.ensure_can_recover_topic!(topic)\n\n    first_post = topic.posts.with_deleted.order(:post_number).first\n    PostDestroyer.new(current_user, first_post, context: params[:context]).recover\n\n    render body: nil\n  end\n\n  def excerpt\n    render body: nil\n  end\n\n  def remove_allowed_user\n    params.require(:username)\n    topic = Topic.find_by(id: params[:topic_id])\n    raise Discourse::NotFound unless topic\n    user = User.find_by(username: params[:username])\n    raise Discourse::NotFound unless user\n\n    guardian.ensure_can_remove_allowed_users!(topic, user)\n\n    if topic.remove_allowed_user(current_user, user)\n      render json: success_json\n    else\n      render json: failed_json, status: 422\n    end\n  end\n\n  def remove_allowed_group\n    params.require(:name)\n    topic = Topic.find_by(id: params[:topic_id])\n    guardian.ensure_can_remove_allowed_users!(topic)\n\n    if topic.remove_allowed_group(current_user, params[:name])\n      render json: success_json\n    else\n      render json: failed_json, status: 422\n    end\n  end\n\n  def invite_notify\n    topic = Topic.find_by(id: params[:topic_id])\n    guardian.ensure_can_see!(topic)\n\n    usernames = params[:usernames]\n    raise Discourse::InvalidParameters.new(:usernames) if !usernames.kind_of?(Array) || (!current_user.staff? && usernames.size > 1)\n\n    users = User.where(username_lower: usernames.map(&:downcase))\n    raise Discourse::InvalidParameters.new(:usernames) if usernames.size != users.size\n\n    topic.rate_limit_topic_invitation(current_user)\n\n    users.find_each do |user|\n      if !user.guardian.can_see_topic?(topic)\n        return render json: failed_json.merge(error: I18n.t('topic_invite.user_cannot_see_topic', username: user.username)), status: 422\n      end\n    end\n\n    users.find_each do |user|\n      last_notification = user.notifications\n        .where(notification_type: Notification.types[:invited_to_topic])\n        .where(topic_id: topic.id)\n        .where(post_number: 1)\n        .where('created_at > ?', 1.hour.ago)\n\n      if !last_notification.exists?\n        topic.create_invite_notification!(user, Notification.types[:invited_to_topic], current_user.username)\n      end\n    end\n\n    render json: success_json\n  end\n\n  def invite_group\n    group = Group.find_by(name: params[:group])\n    raise Discourse::NotFound unless group\n\n    topic = Topic.find_by(id: params[:topic_id])\n\n    unless pm_has_slots?(topic)\n      return render_json_error(\n        I18n.t(\"pm_reached_recipients_limit\", recipients_limit: SiteSetting.max_allowed_message_recipients)\n      )\n    end\n\n    if topic.private_message?\n      guardian.ensure_can_invite_group_to_private_message!(group, topic)\n      topic.invite_group(current_user, group)\n      render_json_dump BasicGroupSerializer.new(group, scope: guardian, root: 'group')\n    else\n      render json: failed_json, status: 422\n    end\n  end\n\n  def invite\n    topic = Topic.find_by(id: params[:topic_id])\n    raise Discourse::InvalidParameters.new unless topic\n\n    username_or_email = params[:user] ? fetch_username : fetch_email\n\n    groups = Group.lookup_groups(\n      group_ids: params[:group_ids],\n      group_names: params[:group_names]\n    )\n\n    unless pm_has_slots?(topic)\n      return render_json_error(\n        I18n.t(\"pm_reached_recipients_limit\", recipients_limit: SiteSetting.max_allowed_message_recipients)\n      )\n    end\n\n    guardian.ensure_can_invite_to!(topic)\n    group_ids = groups.map(&:id)\n\n    begin\n      if topic.invite(current_user, username_or_email, group_ids, params[:custom_message])\n        user = User.find_by_username_or_email(username_or_email)\n\n        if user\n          render_json_dump BasicUserSerializer.new(user, scope: guardian, root: 'user')\n        else\n          render json: success_json\n        end\n      else\n        json = failed_json\n\n        unless topic.private_message?\n          group_names = topic.category\n            .visible_group_names(current_user)\n            .where(automatic: false)\n            .pluck(:name)\n            .join(\", \")\n\n          if group_names.present?\n            json.merge!(errors: [\n              I18n.t(\n                \"topic_invite.failed_to_invite\",\n                group_names: group_names\n              )\n            ])\n          end\n        end\n\n        render json: json, status: 422\n      end\n    rescue Topic::UserExists, Topic::NotAllowed => e\n      render json: { errors: [e.message] }, status: 422\n    end\n  end\n\n  def set_notifications\n    topic = Topic.find(params[:topic_id].to_i)\n    TopicUser.change(current_user, topic.id, notification_level: params[:notification_level].to_i)\n    render json: success_json\n  end\n\n  def merge_topic\n    topic_id = params.require(:topic_id)\n    destination_topic_id = params.require(:destination_topic_id)\n    params.permit(:participants)\n    params.permit(:archetype)\n\n    raise Discourse::InvalidAccess if params[:archetype] == \"private_message\" && !guardian.is_staff?\n\n    topic = Topic.find_by(id: topic_id)\n    guardian.ensure_can_move_posts!(topic)\n\n    destination_topic = Topic.find_by(id: destination_topic_id)\n    guardian.ensure_can_create_post_on_topic!(destination_topic)\n\n    args = {}\n    args[:destination_topic_id] = destination_topic_id.to_i\n\n    if params[:archetype].present?\n      args[:archetype] = params[:archetype]\n      args[:participants] = params[:participants] if params[:participants].present? && params[:archetype] == \"private_message\"\n    end\n\n    destination_topic = topic.move_posts(current_user, topic.posts.pluck(:id), args)\n    render_topic_changes(destination_topic)\n  end\n\n  def move_posts\n    post_ids = params.require(:post_ids)\n    topic_id = params.require(:topic_id)\n    params.permit(:category_id)\n    params.permit(:tags)\n    params.permit(:participants)\n    params.permit(:archetype)\n\n    raise Discourse::InvalidAccess if params[:archetype] == \"private_message\" && !guardian.is_staff?\n\n    topic = Topic.with_deleted.find_by(id: topic_id)\n    guardian.ensure_can_move_posts!(topic)\n\n    if params[:title].present?\n      # when creating a new topic, ensure the 1st post is a regular post\n      if Post.where(topic: topic, id: post_ids).order(:post_number).pluck_first(:post_type) != Post.types[:regular]\n        return render_json_error(\"When moving posts to a new topic, the first post must be a regular post.\")\n      end\n\n      if params[:category_id].present?\n        guardian.ensure_can_create_topic_on_category!(params[:category_id])\n      end\n    end\n\n    destination_topic = move_posts_to_destination(topic)\n    render_topic_changes(destination_topic)\n  rescue ActiveRecord::RecordInvalid => ex\n    render_json_error(ex)\n  end\n\n  def change_post_owners\n    params.require(:post_ids)\n    params.require(:topic_id)\n    params.require(:username)\n\n    guardian.ensure_can_change_post_owner!\n\n    begin\n      PostOwnerChanger.new(post_ids: params[:post_ids].to_a,\n                           topic_id: params[:topic_id].to_i,\n                           new_owner: User.find_by(username: params[:username]),\n                           acting_user: current_user).change_owner!\n      render json: success_json\n    rescue ArgumentError\n      render json: failed_json, status: 422\n    end\n  end\n\n  def change_timestamps\n    topic_id = params.require(:topic_id).to_i\n    timestamp = params.require(:timestamp).to_f\n\n    guardian.ensure_can_change_post_timestamps!\n\n    topic = Topic.with_deleted.find(topic_id)\n    previous_timestamp = topic.first_post.created_at\n\n    begin\n      TopicTimestampChanger.new(\n        topic: topic,\n        timestamp: timestamp\n      ).change!\n\n      StaffActionLogger.new(current_user).log_topic_timestamps_changed(topic, Time.zone.at(timestamp), previous_timestamp)\n\n      render json: success_json\n    rescue ActiveRecord::RecordInvalid, TopicTimestampChanger::InvalidTimestampError\n      render json: failed_json, status: 422\n    end\n  end\n\n  def clear_pin\n    topic = Topic.find_by(id: params[:topic_id].to_i)\n    guardian.ensure_can_see!(topic)\n    topic.clear_pin_for(current_user)\n    render body: nil\n  end\n\n  def re_pin\n    topic = Topic.find_by(id: params[:topic_id].to_i)\n    guardian.ensure_can_see!(topic)\n    topic.re_pin_for(current_user)\n    render body: nil\n  end\n\n  def timings\n    allowed_params = topic_params\n\n    topic_id = allowed_params[:topic_id].to_i\n    topic_time = allowed_params[:topic_time].to_i\n    timings = allowed_params[:timings].to_h || {}\n\n    # ensure we capture current user for the block\n    user = current_user\n\n    hijack do\n      PostTiming.process_timings(\n        user,\n        topic_id,\n        topic_time,\n        timings.map { |post_number, t| [post_number.to_i, t.to_i] },\n        mobile: view_context.mobile_view?\n      )\n      render body: nil\n    end\n  end\n\n  def feed\n    raise Discourse::NotFound if !Post.exists?(topic_id: params[:topic_id])\n\n    begin\n      @topic_view = TopicView.new(params[:topic_id])\n    rescue Discourse::NotLoggedIn\n      raise Discourse::NotFound\n    rescue Discourse::InvalidAccess => ex\n\n      deleted = guardian.can_see_topic?(ex.obj, false) ||\n        (!guardian.can_see_topic?(ex.obj) &&\n         ex.obj&.access_topic_via_group &&\n         ex.obj.deleted_at)\n\n      raise Discourse::NotFound.new(\n        nil,\n        check_permalinks: deleted,\n        original_path: ex.obj.relative_url\n      )\n    end\n\n    discourse_expires_in 1.minute\n    render 'topics/show', formats: [:rss]\n  end\n\n  def bulk\n    if params[:topic_ids].present?\n      unless Array === params[:topic_ids]\n        raise Discourse::InvalidParameters.new(\n          \"Expecting topic_ids to contain a list of topic ids\"\n        )\n      end\n      topic_ids = params[:topic_ids].map { |t| t.to_i }\n    elsif params[:filter] == 'unread'\n      topic_ids = bulk_unread_topic_ids\n    else\n      raise ActionController::ParameterMissing.new(:topic_ids)\n    end\n\n    operation = params\n      .require(:operation)\n      .permit(:type, :group, :category_id, :notification_level_id, *DiscoursePluginRegistry.permitted_bulk_action_parameters, tags: [])\n      .to_h.symbolize_keys\n\n    raise ActionController::ParameterMissing.new(:operation_type) if operation[:type].blank?\n    operator = TopicsBulkAction.new(current_user, topic_ids, operation, group: operation[:group])\n    changed_topic_ids = operator.perform!\n    render_json_dump topic_ids: changed_topic_ids\n  end\n\n  def private_message_reset_new\n    topic_query = TopicQuery.new(current_user, limit: false)\n\n    if params[:topic_ids].present?\n      unless Array === params[:topic_ids]\n        raise Discourse::InvalidParameters.new(\n          \"Expecting topic_ids to contain a list of topic ids\"\n        )\n      end\n\n      topic_scope = topic_query\n        .private_messages_for(current_user, :all)\n        .where(\"topics.id IN (?)\", params[:topic_ids].map(&:to_i))\n    else\n      params.require(:inbox)\n      inbox = params[:inbox].to_s\n      filter = private_message_filter(topic_query, inbox)\n      topic_scope = topic_query.filter_private_message_new(current_user, filter)\n    end\n\n    topic_ids = TopicsBulkAction.new(\n      current_user,\n      topic_scope.distinct(false).pluck(:id),\n      type: \"dismiss_topics\"\n    ).perform!\n\n    render json: success_json.merge(topic_ids: topic_ids)\n  end\n\n  def reset_new\n    topic_scope =\n      if params[:category_id].present?\n        category_ids = [params[:category_id]]\n        if params[:include_subcategories] == 'true'\n          category_ids = category_ids.concat(Category.where(parent_category_id: params[:category_id]).pluck(:id))\n        end\n\n        scope = Topic.where(category_id: category_ids)\n        scope = scope.joins(:tags).where(tags: { name: params[:tag_id] }) if params[:tag_id]\n        scope\n      elsif params[:tag_id].present?\n        Topic.joins(:tags).where(tags: { name: params[:tag_id] })\n      else\n        new_results = TopicQuery.new(current_user).new_results(limit: false)\n        if params[:tracked].to_s == \"true\"\n          TopicQuery.tracked_filter(new_results, current_user.id)\n        else\n          current_user.user_stat.update_column(:new_since, Time.zone.now)\n          new_results\n        end\n      end\n\n    if params[:topic_ids].present?\n      unless Array === params[:topic_ids]\n        raise Discourse::InvalidParameters.new(\n          \"Expecting topic_ids to contain a list of topic ids\"\n        )\n      end\n\n      topic_ids = params[:topic_ids].map { |t| t.to_i }\n      topic_scope = topic_scope.where(id: topic_ids)\n    end\n\n    dismissed_topic_ids = TopicsBulkAction.new(current_user, topic_scope.pluck(:id), type: \"dismiss_topics\").perform!\n    TopicTrackingState.publish_dismiss_new(current_user.id, topic_ids: dismissed_topic_ids)\n\n    render body: nil\n  end\n\n  def convert_topic\n    params.require(:id)\n    params.require(:type)\n    topic = Topic.find_by(id: params[:id])\n    guardian.ensure_can_convert_topic!(topic)\n\n    if params[:type] == \"public\"\n      converted_topic = topic.convert_to_public_topic(current_user, category_id: params[:category_id])\n    else\n      converted_topic = topic.convert_to_private_message(current_user)\n    end\n    render_topic_changes(converted_topic)\n  rescue ActiveRecord::RecordInvalid => ex\n    render_json_error(ex)\n  end\n\n  def reset_bump_date\n    params.require(:id)\n    guardian.ensure_can_update_bumped_at!\n\n    topic = Topic.find_by(id: params[:id])\n    raise Discourse::NotFound.new unless topic\n\n    topic.reset_bumped_at\n    render body: nil\n  end\n\n  def set_slow_mode\n    topic = Topic.find(params[:topic_id])\n    slow_mode_type = TopicTimer.types[:clear_slow_mode]\n    timer = TopicTimer.find_by(topic: topic, status_type: slow_mode_type)\n\n    guardian.ensure_can_moderate!(topic)\n    topic.update!(slow_mode_seconds: params[:seconds])\n    enabled = params[:seconds].to_i > 0\n\n    time = enabled && params[:enabled_until].present? ? params[:enabled_until] : nil\n\n    topic.set_or_create_timer(\n      slow_mode_type,\n      time,\n      by_user: timer&.user\n    )\n\n    head :ok\n  end\n\n  private\n\n  def topic_params\n    params.permit(\n      :topic_id,\n      :topic_time,\n      timings: {}\n    )\n  end\n\n  def fetch_topic_view(options)\n    if (username_filters = params[:username_filters]).present?\n      options[:username_filters] = username_filters.split(',')\n    end\n\n    @topic_view = TopicView.new(params[:topic_id], current_user, options)\n  end\n\n  def toggle_mute\n    @topic = Topic.find_by(id: params[:topic_id].to_i)\n    guardian.ensure_can_see!(@topic)\n\n    @topic.toggle_mute(current_user)\n    render body: nil\n  end\n\n  def consider_user_for_promotion\n    Promotion.new(current_user).review if current_user.present?\n  end\n\n  def slugs_do_not_match\n    if SiteSetting.slug_generation_method != \"encoded\"\n      params[:slug] && @topic_view.topic.slug != params[:slug]\n    else\n      params[:slug] && CGI.unescape(@topic_view.topic.slug) != params[:slug]\n    end\n  end\n\n  def redirect_to_correct_topic(topic, post_number = nil)\n    begin\n      guardian.ensure_can_see!(topic)\n    rescue Discourse::InvalidAccess => ex\n      raise(SiteSetting.detailed_404 ? ex : Discourse::NotFound)\n    end\n\n    url = topic.relative_url\n    url << \"/#{post_number}\" if post_number.to_i > 0\n    url << \".json\" if request.format.json?\n\n    page = params[:page]\n    url << \"?page=#{page}\" if page != 0\n\n    redirect_to url, status: 301\n  end\n\n  def track_visit_to_topic\n    topic_id =  @topic_view.topic.id\n    ip = request.remote_ip\n    user_id = (current_user.id if current_user)\n    track_visit = should_track_visit_to_topic?\n\n    if !request.format.json?\n      hash = {\n        referer: request.referer || flash[:referer],\n        host: request.host,\n        current_user: current_user,\n        topic_id: @topic_view.topic.id,\n        post_number: @topic_view.current_post_number,\n        username: request['u'],\n        ip_address: request.remote_ip\n      }\n      # defer this way so we do not capture the whole controller\n      # in the closure\n      TopicsController.defer_add_incoming_link(hash)\n    end\n\n    TopicsController.defer_track_visit(topic_id, ip, user_id, track_visit)\n  end\n\n  def self.defer_track_visit(topic_id, ip, user_id, track_visit)\n    Scheduler::Defer.later \"Track Visit\" do\n      TopicViewItem.add(topic_id, ip, user_id)\n      TopicUser.track_visit!(topic_id, user_id) if track_visit\n    end\n  end\n\n  def self.defer_add_incoming_link(hash)\n    Scheduler::Defer.later \"Track Link\" do\n      IncomingLink.add(hash)\n    end\n  end\n\n  def should_track_visit_to_topic?\n    !!((!request.format.json? || params[:track_visit]) && current_user)\n  end\n\n  def perform_show_response\n\n    if request.head?\n      head :ok\n      return\n    end\n\n    topic_view_serializer = TopicViewSerializer.new(\n      @topic_view,\n      scope: guardian,\n      root: false,\n      include_raw: !!params[:include_raw],\n      exclude_suggested_and_related: !!params[:replies_to_post_number] || !!params[:filter_upwards_post_id]\n    )\n\n    respond_to do |format|\n      format.html do\n        @tags = SiteSetting.tagging_enabled ? @topic_view.topic.tags : []\n        @breadcrumbs = helpers.categories_breadcrumb(@topic_view.topic) || []\n        @description_meta = @topic_view.topic.excerpt.present? ? @topic_view.topic.excerpt : @topic_view.summary\n        store_preloaded(\"topic_#{@topic_view.topic.id}\", MultiJson.dump(topic_view_serializer))\n        render :show\n      end\n\n      format.json do\n        render_json_dump(topic_view_serializer)\n      end\n    end\n  end\n\n  def render_topic_changes(dest_topic)\n    if dest_topic.present?\n      render json: { success: true, url: dest_topic.relative_url }\n    else\n      render json: { success: false }\n    end\n  end\n\n  def move_posts_to_destination(topic)\n    args = {}\n    args[:title] = params[:title] if params[:title].present?\n    args[:destination_topic_id] = params[:destination_topic_id].to_i if params[:destination_topic_id].present?\n    args[:tags] = params[:tags] if params[:tags].present?\n\n    if params[:archetype].present?\n      args[:archetype] = params[:archetype]\n      args[:participants] = params[:participants] if params[:participants].present? && params[:archetype] == \"private_message\"\n    else\n      args[:category_id] = params[:category_id].to_i if params[:category_id].present?\n    end\n\n    topic.move_posts(current_user, post_ids_including_replies, args)\n  end\n\n  def check_for_status_presence(key, attr)\n    invalid_param(key) unless %w(pinned pinned_globally visible closed archived).include?(attr)\n  end\n\n  def invalid_param(key)\n    raise Discourse::InvalidParameters.new(key.to_sym)\n  end\n\n  def fetch_username\n    params.require(:user)\n    params[:user]\n  end\n\n  def fetch_email\n    params.require(:email)\n    params[:email]\n  end\n\n  def pm_has_slots?(pm)\n    guardian.is_staff? || !pm.reached_recipients_limit?\n  end\n\n  def bulk_unread_topic_ids\n    topic_query = TopicQuery.new(current_user)\n\n    if inbox = params[:private_message_inbox]\n      filter = private_message_filter(topic_query, inbox)\n      topic_query.options[:limit] = false\n\n      topic_query\n        .filter_private_messages_unread(current_user, filter)\n        .distinct(false)\n        .pluck(:id)\n    else\n      topics = TopicQuery.unread_filter(topic_query.joined_topic_user, staff: guardian.is_staff?).listable_topics\n      topics = TopicQuery.tracked_filter(topics, current_user.id) if params[:tracked].to_s == \"true\"\n\n      if params[:category_id]\n        if params[:include_subcategories]\n          topics = topics.where(<<~SQL, category_id: params[:category_id])\n            category_id in (select id FROM categories WHERE parent_category_id = :category_id) OR\n            category_id = :category_id\n          SQL\n        else\n          topics = topics.where('category_id = ?', params[:category_id])\n        end\n      end\n\n      if params[:tag_name].present?\n        topics = topics.joins(:tags).where(\"tags.name\": params[:tag_name])\n      end\n\n      topics.pluck(:id)\n    end\n  end\n\n  def private_message_filter(topic_query, inbox)\n    case inbox\n    when \"group\"\n      group_name = params[:group_name]\n      group = Group.find_by(\"lower(name) = ?\", group_name)\n      raise Discourse::NotFound if !group\n      raise Discourse::NotFound if !guardian.can_see_group_messages?(group)\n      topic_query.options[:group_name] = group_name\n      :group\n    when \"user\"\n      :user\n    else\n      :all\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nclass TopicQuery\n  module PrivateMessageLists\n    def list_private_messages_all(user)\n      list = private_messages_for(user, :all)\n      list = filter_archived(list, user, archived: false)\n      create_list(:private_messages, {}, list)\n    end\n\n    def list_private_messages_all_sent(user)\n      list = private_messages_for(user, :all)\n\n      list = list.where(<<~SQL, user.id)\n      EXISTS (\n        SELECT 1 FROM posts\n        WHERE posts.topic_id = topics.id AND posts.user_id = ?\n      )\n      SQL\n\n      list = filter_archived(list, user, archived: false)\n      create_list(:private_messages, {}, list)\n    end\n\n    def list_private_messages_all_archive(user)\n      list = private_messages_for(user, :all)\n      list = filter_archived(list, user, archived: true)\n      create_list(:private_messages, {}, list)\n    end\n\n    def list_private_messages_all_new(user)\n      list_private_messages_new(user, :all)\n    end\n\n    def list_private_messages_all_unread(user)\n      list_private_messages_unread(user, :all)\n    end\n\n    def list_private_messages(user)\n      list = private_messages_for(user, :user)\n      list = not_archived(list, user)\n      create_list(:private_messages, {}, list)\n    end\n\n    def list_private_messages_archive(user)\n      list = private_messages_for(user, :user)\n      list = list.joins(:user_archived_messages).where('user_archived_messages.user_id = ?', user.id)\n      create_list(:private_messages, {}, list)\n    end\n\n    def list_private_messages_sent(user)\n      list = private_messages_for(user, :user)\n\n      list = list.where(<<~SQL, user.id)\n      EXISTS (\n        SELECT 1 FROM posts\n        WHERE posts.topic_id = topics.id AND posts.user_id = ?\n      )\n      SQL\n\n      list = not_archived(list, user)\n      create_list(:private_messages, {}, list)\n    end\n\n    def list_private_messages_new(user, type = :user)\n      list = filter_private_message_new(user, type)\n      list = remove_muted_tags(list, user)\n      list = remove_dismissed(list, user)\n\n      create_list(:private_messages, {}, list)\n    end\n\n    def list_private_messages_unread(user, type = :user)\n      list = filter_private_messages_unread(user, type)\n      create_list(:private_messages, {}, list)\n    end\n\n    def list_private_messages_group(user)\n      list = private_messages_for(user, :group)\n\n      list = list.joins(<<~SQL)\n      LEFT JOIN group_archived_messages gm\n      ON gm.topic_id = topics.id AND gm.group_id = #{group.id.to_i}\n      SQL\n\n      list = list.where(\"gm.id IS NULL\")\n      publish_read_state = !!group.publish_read_state\n      list = append_read_state(list, group) if publish_read_state\n      create_list(:private_messages, { publish_read_state: publish_read_state }, list)\n    end\n\n    def list_private_messages_group_archive(user)\n      list = private_messages_for(user, :group)\n\n      list = list.joins(<<~SQL)\n      INNER JOIN group_archived_messages gm\n      ON gm.topic_id = topics.id AND gm.group_id = #{group.id.to_i}\n      SQL\n\n      publish_read_state = !!group.publish_read_state\n      list = append_read_state(list, group) if publish_read_state\n      create_list(:private_messages, { publish_read_state: publish_read_state }, list)\n    end\n\n    def list_private_messages_group_new(user)\n      list = filter_private_message_new(user, :group)\n      list = remove_dismissed(list, user)\n      publish_read_state = !!group.publish_read_state\n      list = append_read_state(list, group) if publish_read_state\n      create_list(:private_messages, { publish_read_state: publish_read_state }, list)\n    end\n\n    def list_private_messages_group_unread(user)\n      list = filter_private_messages_unread(user, :group)\n      publish_read_state = !!group.publish_read_state\n      list = append_read_state(list, group) if publish_read_state\n      create_list(:private_messages, { publish_read_state: publish_read_state }, list)\n    end\n\n    def list_private_messages_warnings(user)\n      list = private_messages_for(user, :user)\n      list = list.where('topics.subtype = ?', TopicSubtype.moderator_warning)\n      # Exclude official warnings that the user created, instead of received\n      list = list.where('topics.user_id <> ?', user.id)\n      create_list(:private_messages, {}, list)\n    end\n\n    def private_messages_for(user, type)\n      options = @options\n      options.reverse_merge!(per_page: per_page_setting)\n\n      result = Topic.includes(:allowed_users)\n      result = result.includes(:tags) if SiteSetting.tagging_enabled\n\n      if type == :group\n        result = result.joins(\n          \"INNER JOIN topic_allowed_groups tag ON tag.topic_id = topics.id AND tag.group_id IN (SELECT id FROM groups WHERE LOWER(name) = '#{PG::Connection.escape_string(@options[:group_name].downcase)}')\"\n        )\n\n        unless user.admin?\n          result = result.joins(\"INNER JOIN group_users gu ON gu.group_id = tag.group_id AND gu.user_id = #{user.id.to_i}\")\n        end\n      elsif type == :user\n        result = result.where(\"topics.id IN (SELECT topic_id FROM topic_allowed_users WHERE user_id = #{user.id.to_i})\")\n      elsif type == :all\n        group_ids = group_with_messages_ids(user)\n\n        result = result.joins(<<~SQL)\n        LEFT JOIN topic_allowed_users tau\n          ON tau.topic_id = topics.id\n          AND tau.user_id = #{user.id.to_i}\n        LEFT JOIN topic_allowed_groups tag\n          ON tag.topic_id = topics.id\n          #{group_ids.present? ? \"AND tag.group_id IN (#{group_ids.join(\",\")})\" : \"\"}\n        SQL\n\n        result = result\n          .where(\"tag.topic_id IS NOT NULL OR tau.topic_id IS NOT NULL\")\n          .distinct\n      end\n\n      result = result.joins(\"LEFT OUTER JOIN topic_users AS tu ON (topics.id = tu.topic_id AND tu.user_id = #{user.id.to_i})\")\n        .order(\"topics.bumped_at DESC\")\n        .private_messages\n\n      result = result.limit(options[:per_page]) unless options[:limit] == false\n      result = result.visible if options[:visible] || @user.nil? || @user.regular?\n\n      if options[:page]\n        offset = options[:page].to_i * options[:per_page]\n        result = result.offset(offset) if offset > 0\n      end\n      result\n    end\n\n    def list_private_messages_tag(user)\n      list = private_messages_for(user, :all)\n      list = list.joins(\"JOIN topic_tags tt ON tt.topic_id = topics.id\n                        JOIN tags t ON t.id = tt.tag_id AND t.name = '#{@options[:tags][0]}'\")\n      create_list(:private_messages, {}, list)\n    end\n\n    def filter_private_messages_unread(user, type)\n      list = TopicQuery.unread_filter(\n        private_messages_for(user, type),\n        staff: user.staff?\n      )\n\n      first_unread_pm_at =\n        case type\n        when :user\n          user_first_unread_pm_at(user)\n        when :group\n          GroupUser\n            .where(user: user, group: group)\n            .pluck_first(:first_unread_pm_at)\n        else\n          user_first_unread_pm_at = user_first_unread_pm_at(user)\n\n          group_first_unread_pm_at = GroupUser\n            .where(user: user)\n            .minimum(:first_unread_pm_at)\n\n          [user_first_unread_pm_at, group_first_unread_pm_at].compact.min\n        end\n\n      if first_unread_pm_at\n        list = list.where(\"topics.updated_at >= ?\", first_unread_pm_at)\n      end\n\n      list\n    end\n\n    def filter_private_message_new(user, type)\n      TopicQuery.new_filter(\n        private_messages_for(user, type),\n        treat_as_new_topic_start_date: user.user_option.treat_as_new_topic_start_date\n      )\n    end\n\n    private\n\n    def append_read_state(list, group)\n      group_id = group.id\n      return list if group_id.nil?\n\n      selected_values = list.select_values.empty? ? ['topics.*'] : list.select_values\n      selected_values << \"COALESCE(tg.last_read_post_number, 0) AS last_read_post_number\"\n\n      list\n        .joins(\"LEFT OUTER JOIN topic_groups tg ON topics.id = tg.topic_id AND tg.group_id = #{group_id}\")\n        .select(*selected_values)\n    end\n\n    def filter_archived(list, user, archived: true)\n      # Executing an extra query instead of a sub-query because it is more\n      # efficient for the PG planner. Caution should be used when changing the\n      # query here as it can easily lead to an inefficient query.\n      group_ids = group_with_messages_ids(user)\n\n      list = list.joins(<<~SQL)\n      LEFT JOIN group_archived_messages gm\n        ON gm.topic_id = topics.id\n        #{group_ids.present? ? \"AND gm.group_id IN (#{group_ids.join(\",\")})\" : \"\"}\n      LEFT JOIN user_archived_messages um\n        ON um.user_id = #{user.id.to_i}\n        AND um.topic_id = topics.id\n      SQL\n\n      list =\n        if archived\n          list.where(\"um.user_id IS NOT NULL OR gm.topic_id IS NOT NULL\")\n        else\n          list.where(\"um.user_id IS NULL AND gm.topic_id IS NULL\")\n        end\n\n      list\n    end\n\n    def not_archived(list, user)\n      list.joins(\"LEFT JOIN user_archived_messages um\n                         ON um.user_id = #{user.id.to_i} AND um.topic_id = topics.id\")\n        .where('um.user_id IS NULL')\n    end\n\n    def group\n      @group ||= begin\n        Group\n          .where('name ilike ?', @options[:group_name])\n          .select(:id, :publish_read_state)\n          .first\n      end\n    end\n\n    def user_first_unread_pm_at(user)\n      UserStat.where(user: user).pluck_first(:first_unread_pm_at)\n    end\n\n    def group_with_messages_ids(user)\n      @group_with_messages_ids ||= {}\n\n      if ids = @group_with_messages_ids[user.id]\n        return ids\n      end\n\n      @group_with_messages_ids[user.id] = user.groups.where(has_messages: true).pluck(:id)\n    end\n  end\nend\n"], "fixing_code": ["# frozen_string_literal: true\n\nclass TopicsController < ApplicationController\n  requires_login only: [\n    :timings,\n    :destroy_timings,\n    :update,\n    :update_shared_draft,\n    :destroy,\n    :recover,\n    :status,\n    :invite,\n    :mute,\n    :unmute,\n    :set_notifications,\n    :move_posts,\n    :merge_topic,\n    :clear_pin,\n    :re_pin,\n    :status_update,\n    :timer,\n    :bulk,\n    :reset_new,\n    :change_post_owners,\n    :change_timestamps,\n    :archive_message,\n    :move_to_inbox,\n    :convert_topic,\n    :bookmark,\n    :publish,\n    :reset_bump_date,\n    :set_slow_mode\n  ]\n\n  before_action :consider_user_for_promotion, only: :show\n\n  skip_before_action :check_xhr, only: [:show, :feed]\n\n  def id_for_slug\n    topic = Topic.find_by_slug(params[:slug])\n    guardian.ensure_can_see!(topic)\n    raise Discourse::NotFound unless topic\n    render json: { slug: topic.slug, topic_id: topic.id, url: topic.url }\n  end\n\n  def show\n    if request.referer\n      flash[\"referer\"] ||= request.referer[0..255]\n    end\n\n    # We'd like to migrate the wordpress feed to another url. This keeps up backwards compatibility with\n    # existing installs.\n    return wordpress if params[:best].present?\n\n    # work around people somehow sending in arrays,\n    # arrays are not supported\n    params[:page] = params[:page].to_i rescue 1\n\n    opts = params.slice(:username_filters, :filter, :page, :post_number, :show_deleted, :replies_to_post_number, :filter_upwards_post_id)\n    username_filters = opts[:username_filters]\n\n    opts[:print] = true if params[:print].present?\n    opts[:username_filters] = username_filters.split(',') if username_filters.is_a?(String)\n\n    # Special case: a slug with a number in front should look by slug first before looking\n    # up that particular number\n    if params[:id] && params[:id] =~ /^\\d+[^\\d\\\\]+$/\n      topic = Topic.find_by_slug(params[:id])\n      return redirect_to_correct_topic(topic, opts[:post_number]) if topic\n    end\n\n    if opts[:print]\n      raise Discourse::InvalidAccess unless SiteSetting.max_prints_per_hour_per_user > 0\n      begin\n        RateLimiter.new(current_user, \"print-topic-per-hour\", SiteSetting.max_prints_per_hour_per_user, 1.hour).performed! unless @guardian.is_admin?\n      rescue RateLimiter::LimitExceeded\n        return render_json_error I18n.t(\"rate_limiter.slow_down\")\n      end\n    end\n\n    begin\n      @topic_view = TopicView.new(params[:id] || params[:topic_id], current_user, opts)\n    rescue Discourse::NotFound => ex\n      if params[:id]\n        topic = Topic.find_by_slug(params[:id])\n        return redirect_to_correct_topic(topic, opts[:post_number]) if topic\n      end\n\n      raise ex\n    rescue Discourse::NotLoggedIn => ex\n      raise(SiteSetting.detailed_404 ? ex : Discourse::NotFound)\n    rescue Discourse::InvalidAccess => ex\n      # If the user can't see the topic, clean up notifications for it.\n      Notification.remove_for(current_user.id, params[:topic_id]) if current_user\n\n      deleted = guardian.can_see_topic?(ex.obj, false) ||\n        (!guardian.can_see_topic?(ex.obj) &&\n         ex.obj&.access_topic_via_group &&\n         ex.obj.deleted_at)\n\n      if SiteSetting.detailed_404\n        if deleted\n          raise Discourse::NotFound.new(\n            'deleted topic',\n            custom_message: 'deleted_topic',\n            status: 410,\n            check_permalinks: true,\n            original_path: ex.obj.relative_url\n          )\n        elsif !guardian.can_see_topic?(ex.obj) && group = ex.obj&.access_topic_via_group\n          raise Discourse::InvalidAccess.new(\n            'not in group',\n            ex.obj,\n            custom_message: 'not_in_group.title_topic',\n            custom_message_params: { group: group.name },\n            group: group\n          )\n        end\n\n        raise ex\n      else\n        raise Discourse::NotFound.new(\n          nil,\n          check_permalinks: deleted,\n          original_path: ex.obj.relative_url\n        )\n      end\n    end\n\n    page = params[:page]\n    if (page < 0) || ((page - 1) * @topic_view.chunk_size >= @topic_view.topic.highest_post_number)\n      raise Discourse::NotFound\n    end\n\n    discourse_expires_in 1.minute\n\n    if slugs_do_not_match || (!request.format.json? && params[:slug].nil?)\n      redirect_to_correct_topic(@topic_view.topic, opts[:post_number])\n      return\n    end\n\n    track_visit_to_topic\n\n    if should_track_visit_to_topic?\n      @topic_view.draft = Draft.get(current_user, @topic_view.draft_key, @topic_view.draft_sequence)\n    end\n\n    unless @topic_view.topic.visible\n      response.headers['X-Robots-Tag'] = 'noindex'\n    end\n\n    canonical_url UrlHelper.absolute_without_cdn(@topic_view.canonical_path)\n\n    # provide hint to crawlers only for now\n    # we would like to give them a bit more signal about age of data\n    if use_crawler_layout?\n      if last_modified = @topic_view.posts&.map { |p| p.updated_at }&.max&.httpdate\n        response.headers['Last-Modified'] = last_modified\n      end\n    end\n\n    perform_show_response\n  end\n\n  def publish\n    params.permit(:id, :destination_category_id)\n\n    topic = Topic.find(params[:id])\n    category = Category.find(params[:destination_category_id])\n\n    raise Discourse::InvalidParameters if category.id == SiteSetting.shared_drafts_category.to_i\n\n    guardian.ensure_can_publish_topic!(topic, category)\n    topic = TopicPublisher.new(topic, current_user, category.id).publish!\n\n    render_serialized(topic.reload, BasicTopicSerializer)\n  end\n\n  def wordpress\n    params.require(:best)\n    params.require(:topic_id)\n    params.permit(:min_trust_level, :min_score, :min_replies, :bypass_trust_level_score, :only_moderator_liked)\n\n    opts = {\n      best: params[:best].to_i,\n      min_trust_level: params[:min_trust_level] ? params[:min_trust_level].to_i : 1,\n      min_score: params[:min_score].to_i,\n      min_replies: params[:min_replies].to_i,\n      bypass_trust_level_score: params[:bypass_trust_level_score].to_i, # safe cause 0 means ignore\n      only_moderator_liked: params[:only_moderator_liked].to_s == \"true\",\n      exclude_hidden: true\n    }\n\n    @topic_view = TopicView.new(params[:topic_id], current_user, opts)\n    discourse_expires_in 1.minute\n\n    wordpress_serializer = TopicViewWordpressSerializer.new(@topic_view, scope: guardian, root: false)\n    render_json_dump(wordpress_serializer)\n  end\n\n  def post_ids\n    params.require(:topic_id)\n    params.permit(:post_number, :username_filters, :filter)\n\n    options = {\n      filter_post_number: params[:post_number],\n      filter: params[:filter],\n      skip_limit: true,\n      asc: true,\n      skip_custom_fields: true\n    }\n\n    fetch_topic_view(options)\n    render_json_dump(post_ids: @topic_view.posts.pluck(:id))\n  end\n\n  def posts\n    params.require(:topic_id)\n    params.permit(:post_ids, :post_number, :username_filters, :filter, :include_suggested)\n\n    include_suggested = params[:include_suggested] == \"true\"\n\n    options = {\n      filter_post_number: params[:post_number],\n      post_ids: params[:post_ids],\n      asc: ActiveRecord::Type::Boolean.new.deserialize(params[:asc]),\n      filter: params[:filter],\n      include_suggested: include_suggested,\n      include_related: include_suggested,\n    }\n\n    fetch_topic_view(options)\n\n    render_json_dump(\n      TopicViewPostsSerializer.new(\n        @topic_view,\n        scope: guardian,\n        root: false,\n        include_raw: !!params[:include_raw]\n      )\n    )\n  end\n\n  def excerpts\n    params.require(:topic_id)\n    params.require(:post_ids)\n\n    unless Array === params[:post_ids]\n      render_json_error(\"Expecting post_ids to contain a list of posts ids\")\n      return\n    end\n    post_ids = params[:post_ids].map(&:to_i)\n\n    if post_ids.length > 100\n      render_json_error(\"Requested a chunk that is too big\")\n      return\n    end\n\n    @topic = Topic.with_deleted.where(id: params[:topic_id]).first\n    guardian.ensure_can_see!(@topic)\n\n    @posts = Post.where(hidden: false, deleted_at: nil, topic_id: @topic.id)\n      .where('posts.id in (?)', post_ids)\n      .joins(\"LEFT JOIN users u on u.id = posts.user_id\")\n      .pluck(:id, :cooked, :username)\n      .map do |post_id, cooked, username|\n      {\n        post_id: post_id,\n        username: username,\n        excerpt: PrettyText.excerpt(cooked, 800, keep_emoji_images: true)\n      }\n    end\n\n    render json: @posts.to_json\n  end\n\n  def destroy_timings\n    topic_id = params[:topic_id].to_i\n\n    if params[:last].to_s == \"1\"\n      PostTiming.destroy_last_for(current_user, topic_id)\n    else\n      PostTiming.destroy_for(current_user.id, [topic_id])\n    end\n\n    last_notification = Notification\n      .where(\n        user_id: current_user.id,\n        topic_id: topic_id\n      )\n      .order(created_at: :desc)\n      .limit(1)\n      .first\n\n    if last_notification\n      last_notification.update!(read: false)\n    end\n\n    render body: nil\n  end\n\n  def update_shared_draft\n    topic = Topic.find_by(id: params[:id])\n    guardian.ensure_can_edit!(topic)\n\n    category = Category.where(id: params[:category_id].to_i).first\n    guardian.ensure_can_publish_topic!(topic, category)\n\n    row_count = SharedDraft.where(topic_id: topic.id).update_all(category_id: category.id)\n    if row_count == 0\n      SharedDraft.create(topic_id: topic.id, category_id: category.id)\n    end\n\n    render json: success_json\n  end\n\n  def update\n    topic = Topic.find_by(id: params[:topic_id])\n    guardian.ensure_can_edit!(topic)\n\n    if params[:category_id] && (params[:category_id].to_i != topic.category_id.to_i)\n      if topic.shared_draft\n        topic.shared_draft.update(category_id: params[:category_id])\n        params.delete(:category_id)\n      else\n        category = Category.find_by(id: params[:category_id])\n\n        if category || (params[:category_id].to_i == 0)\n          guardian.ensure_can_move_topic_to_category!(category)\n        else\n          return render_json_error(I18n.t('category.errors.not_found'))\n        end\n\n        if category && topic_tags = (params[:tags] || topic.tags.pluck(:name)).reject { |c| c.empty? }\n          if topic_tags.present?\n            allowed_tags = DiscourseTagging.filter_allowed_tags(\n              guardian,\n              category: category\n            ).map(&:name)\n\n            invalid_tags = topic_tags - allowed_tags\n\n            # Do not raise an error on a topic's hidden tags when not modifying tags\n            if params[:tags].blank?\n              invalid_tags.each do |tag_name|\n                if DiscourseTagging.hidden_tag_names.include?(tag_name)\n                  invalid_tags.delete(tag_name)\n                end\n              end\n            end\n\n            invalid_tags = Tag.where_name(invalid_tags).pluck(:name)\n\n            if !invalid_tags.empty?\n              if (invalid_tags & DiscourseTagging.hidden_tag_names).present?\n                return render_json_error(I18n.t('category.errors.disallowed_tags_generic'))\n              else\n                return render_json_error(I18n.t('category.errors.disallowed_topic_tags', tags: invalid_tags.join(\", \")))\n              end\n            end\n          end\n        end\n      end\n    end\n\n    changes = {}\n\n    PostRevisor.tracked_topic_fields.each_key do |f|\n      changes[f] = params[f] if params.has_key?(f)\n    end\n\n    changes.delete(:title) if topic.title == changes[:title]\n    changes.delete(:category_id) if topic.category_id.to_i == changes[:category_id].to_i\n\n    if Tag.include_tags?\n      topic_tags = topic.tags.map(&:name).sort\n      changes.delete(:tags) if changes[:tags]&.sort == topic_tags\n    end\n\n    success = true\n\n    if changes.length > 0\n      first_post = topic.ordered_posts.first\n      success = PostRevisor.new(first_post, topic).revise!(current_user, changes, validate_post: false)\n\n      if !success && topic.errors.blank?\n        topic.errors.add(:base, :unable_to_update)\n      end\n    end\n\n    # this is used to return the title to the client as it may have been changed by \"TextCleaner\"\n    success ? render_serialized(topic, BasicTopicSerializer) : render_json_error(topic)\n  end\n\n  def update_tags\n    params.require(:tags)\n    topic = Topic.find_by(id: params[:topic_id])\n    guardian.ensure_can_edit_tags!(topic)\n\n    success = PostRevisor.new(topic.first_post, topic).revise!(current_user, { tags: params[:tags] }, validate_post: false)\n\n    success ? render_serialized(topic, BasicTopicSerializer) : render_json_error(topic)\n  end\n\n  def feature_stats\n    params.require(:category_id)\n    category_id = params[:category_id].to_i\n\n    visible_topics = Topic.listable_topics.visible\n\n    render json: {\n      pinned_in_category_count: visible_topics.where(category_id: category_id).where(pinned_globally: false).where.not(pinned_at: nil).count,\n      pinned_globally_count: visible_topics.where(pinned_globally: true).where.not(pinned_at: nil).count,\n      banner_count: Topic.listable_topics.where(archetype: Archetype.banner).count,\n    }\n  end\n\n  def status\n    params.require(:status)\n    params.require(:enabled)\n    params.permit(:until)\n\n    status = params[:status]\n    topic_id = params[:topic_id].to_i\n    enabled = params[:enabled] == 'true'\n\n    check_for_status_presence(:status, status)\n    @topic = Topic.find_by(id: topic_id)\n\n    case status\n    when 'closed'\n      guardian.ensure_can_close_topic!(@topic)\n    when 'archived'\n      guardian.ensure_can_archive_topic!(@topic)\n    when 'visible'\n      guardian.ensure_can_toggle_topic_visibility!(@topic)\n    when 'pinned'\n      guardian.ensure_can_pin_unpin_topic!(@topic)\n    else\n      guardian.ensure_can_moderate!(@topic)\n    end\n\n    params[:until] === '' ? params[:until] = nil : params[:until]\n\n    @topic.update_status(status, enabled, current_user, until: params[:until])\n\n    render json: success_json.merge!(\n      topic_status_update: TopicTimerSerializer.new(\n        TopicTimer.find_by(topic: @topic), root: false\n      )\n    )\n  end\n\n  def mute\n    toggle_mute\n  end\n\n  def unmute\n    toggle_mute\n  end\n\n  def timer\n    params.permit(:time, :based_on_last_post, :category_id)\n    params.require(:status_type)\n\n    status_type =\n      begin\n        TopicTimer.types.fetch(params[:status_type].to_sym)\n      rescue\n        invalid_param(:status_type)\n      end\n    based_on_last_post = params[:based_on_last_post]\n    params.require(:duration_minutes) if based_on_last_post\n\n    topic = Topic.find_by(id: params[:topic_id])\n    guardian.ensure_can_moderate!(topic)\n\n    options = {\n      by_user: current_user,\n      based_on_last_post: based_on_last_post\n    }\n\n    options.merge!(category_id: params[:category_id]) if !params[:category_id].blank?\n    options.merge!(duration_minutes: params[:duration_minutes].to_i) if params[:duration_minutes].present?\n    options.merge!(duration: params[:duration].to_i) if params[:duration].present?\n\n    begin\n      topic_timer = topic.set_or_create_timer(\n        status_type,\n        params[:time],\n        **options\n      )\n    rescue ActiveRecord::RecordInvalid => e\n      return render_json_error(e.message)\n    end\n\n    if topic.save\n      render json: success_json.merge!(\n        execute_at: topic_timer&.execute_at,\n        duration_minutes: topic_timer&.duration_minutes,\n        based_on_last_post: topic_timer&.based_on_last_post,\n        closed: topic.closed,\n        category_id: topic_timer&.category_id\n      )\n    else\n      render_json_error(topic)\n    end\n  end\n\n  def make_banner\n    topic = Topic.find_by(id: params[:topic_id].to_i)\n    guardian.ensure_can_banner_topic!(topic)\n\n    topic.make_banner!(current_user)\n\n    render body: nil\n  end\n\n  def remove_banner\n    topic = Topic.find_by(id: params[:topic_id].to_i)\n    guardian.ensure_can_banner_topic!(topic)\n\n    topic.remove_banner!(current_user)\n\n    render body: nil\n  end\n\n  def remove_bookmarks\n    topic = Topic.find(params[:topic_id].to_i)\n    BookmarkManager.new(current_user).destroy_for_topic(topic)\n    render body: nil\n  end\n\n  def archive_message\n    toggle_archive_message(true)\n  end\n\n  def move_to_inbox\n    toggle_archive_message(false)\n  end\n\n  def toggle_archive_message(archive)\n    topic = Topic.find(params[:id].to_i)\n\n    group_id = nil\n\n    group_ids = current_user.groups.pluck(:id)\n    if group_ids.present?\n      allowed_groups = topic.allowed_groups\n        .where('topic_allowed_groups.group_id IN (?)', group_ids).pluck(:id)\n\n      allowed_groups.each do |id|\n        if archive\n          GroupArchivedMessage.archive!(\n            id,\n            topic,\n            acting_user_id: current_user.id\n          )\n\n          group_id = id\n        else\n          GroupArchivedMessage.move_to_inbox!(\n            id,\n            topic,\n            acting_user_id: current_user.id\n          )\n        end\n      end\n    end\n\n    if topic.allowed_users.include?(current_user)\n      if archive\n        UserArchivedMessage.archive!(current_user.id, topic)\n      else\n        UserArchivedMessage.move_to_inbox!(current_user.id, topic)\n      end\n    end\n\n    if group_id\n      name = Group.find_by(id: group_id).try(:name)\n      render_json_dump(group_name: name)\n    else\n      render body: nil\n    end\n  end\n\n  def bookmark\n    topic = Topic.find(params[:topic_id].to_i)\n    first_post = topic.ordered_posts.first\n\n    bookmark_manager = BookmarkManager.new(current_user)\n    bookmark_manager.create(post_id: first_post.id)\n\n    if bookmark_manager.errors.any?\n      return render_json_error(bookmark_manager, status: 400)\n    end\n\n    render body: nil\n  end\n\n  def destroy\n    topic = Topic.find_by(id: params[:id])\n    guardian.ensure_can_delete!(topic)\n\n    first_post = topic.ordered_posts.first\n    PostDestroyer.new(current_user, first_post, context: params[:context]).destroy\n\n    render body: nil\n  rescue Discourse::InvalidAccess\n    render_json_error I18n.t(\"delete_topic_failed\")\n  end\n\n  def recover\n    topic = Topic.where(id: params[:topic_id]).with_deleted.first\n    guardian.ensure_can_recover_topic!(topic)\n\n    first_post = topic.posts.with_deleted.order(:post_number).first\n    PostDestroyer.new(current_user, first_post, context: params[:context]).recover\n\n    render body: nil\n  end\n\n  def excerpt\n    render body: nil\n  end\n\n  def remove_allowed_user\n    params.require(:username)\n    topic = Topic.find_by(id: params[:topic_id])\n    raise Discourse::NotFound unless topic\n    user = User.find_by(username: params[:username])\n    raise Discourse::NotFound unless user\n\n    guardian.ensure_can_remove_allowed_users!(topic, user)\n\n    if topic.remove_allowed_user(current_user, user)\n      render json: success_json\n    else\n      render json: failed_json, status: 422\n    end\n  end\n\n  def remove_allowed_group\n    params.require(:name)\n    topic = Topic.find_by(id: params[:topic_id])\n    guardian.ensure_can_remove_allowed_users!(topic)\n\n    if topic.remove_allowed_group(current_user, params[:name])\n      render json: success_json\n    else\n      render json: failed_json, status: 422\n    end\n  end\n\n  def invite_notify\n    topic = Topic.find_by(id: params[:topic_id])\n    guardian.ensure_can_see!(topic)\n\n    usernames = params[:usernames]\n    raise Discourse::InvalidParameters.new(:usernames) if !usernames.kind_of?(Array) || (!current_user.staff? && usernames.size > 1)\n\n    users = User.where(username_lower: usernames.map(&:downcase))\n    raise Discourse::InvalidParameters.new(:usernames) if usernames.size != users.size\n\n    topic.rate_limit_topic_invitation(current_user)\n\n    users.find_each do |user|\n      if !user.guardian.can_see_topic?(topic)\n        return render json: failed_json.merge(error: I18n.t('topic_invite.user_cannot_see_topic', username: user.username)), status: 422\n      end\n    end\n\n    users.find_each do |user|\n      last_notification = user.notifications\n        .where(notification_type: Notification.types[:invited_to_topic])\n        .where(topic_id: topic.id)\n        .where(post_number: 1)\n        .where('created_at > ?', 1.hour.ago)\n\n      if !last_notification.exists?\n        topic.create_invite_notification!(user, Notification.types[:invited_to_topic], current_user.username)\n      end\n    end\n\n    render json: success_json\n  end\n\n  def invite_group\n    group = Group.find_by(name: params[:group])\n    raise Discourse::NotFound unless group\n\n    topic = Topic.find_by(id: params[:topic_id])\n\n    unless pm_has_slots?(topic)\n      return render_json_error(\n        I18n.t(\"pm_reached_recipients_limit\", recipients_limit: SiteSetting.max_allowed_message_recipients)\n      )\n    end\n\n    if topic.private_message?\n      guardian.ensure_can_invite_group_to_private_message!(group, topic)\n      topic.invite_group(current_user, group)\n      render_json_dump BasicGroupSerializer.new(group, scope: guardian, root: 'group')\n    else\n      render json: failed_json, status: 422\n    end\n  end\n\n  def invite\n    topic = Topic.find_by(id: params[:topic_id])\n    raise Discourse::InvalidParameters.new unless topic\n\n    username_or_email = params[:user] ? fetch_username : fetch_email\n\n    groups = Group.lookup_groups(\n      group_ids: params[:group_ids],\n      group_names: params[:group_names]\n    )\n\n    unless pm_has_slots?(topic)\n      return render_json_error(\n        I18n.t(\"pm_reached_recipients_limit\", recipients_limit: SiteSetting.max_allowed_message_recipients)\n      )\n    end\n\n    guardian.ensure_can_invite_to!(topic)\n    group_ids = groups.map(&:id)\n\n    begin\n      if topic.invite(current_user, username_or_email, group_ids, params[:custom_message])\n        user = User.find_by_username_or_email(username_or_email)\n\n        if user\n          render_json_dump BasicUserSerializer.new(user, scope: guardian, root: 'user')\n        else\n          render json: success_json\n        end\n      else\n        json = failed_json\n\n        unless topic.private_message?\n          group_names = topic.category\n            .visible_group_names(current_user)\n            .where(automatic: false)\n            .pluck(:name)\n            .join(\", \")\n\n          if group_names.present?\n            json.merge!(errors: [\n              I18n.t(\n                \"topic_invite.failed_to_invite\",\n                group_names: group_names\n              )\n            ])\n          end\n        end\n\n        render json: json, status: 422\n      end\n    rescue Topic::UserExists, Topic::NotAllowed => e\n      render json: { errors: [e.message] }, status: 422\n    end\n  end\n\n  def set_notifications\n    topic = Topic.find(params[:topic_id].to_i)\n    TopicUser.change(current_user, topic.id, notification_level: params[:notification_level].to_i)\n    render json: success_json\n  end\n\n  def merge_topic\n    topic_id = params.require(:topic_id)\n    destination_topic_id = params.require(:destination_topic_id)\n    params.permit(:participants)\n    params.permit(:archetype)\n\n    raise Discourse::InvalidAccess if params[:archetype] == \"private_message\" && !guardian.is_staff?\n\n    topic = Topic.find_by(id: topic_id)\n    guardian.ensure_can_move_posts!(topic)\n\n    destination_topic = Topic.find_by(id: destination_topic_id)\n    guardian.ensure_can_create_post_on_topic!(destination_topic)\n\n    args = {}\n    args[:destination_topic_id] = destination_topic_id.to_i\n\n    if params[:archetype].present?\n      args[:archetype] = params[:archetype]\n      args[:participants] = params[:participants] if params[:participants].present? && params[:archetype] == \"private_message\"\n    end\n\n    destination_topic = topic.move_posts(current_user, topic.posts.pluck(:id), args)\n    render_topic_changes(destination_topic)\n  end\n\n  def move_posts\n    post_ids = params.require(:post_ids)\n    topic_id = params.require(:topic_id)\n    params.permit(:category_id)\n    params.permit(:tags)\n    params.permit(:participants)\n    params.permit(:archetype)\n\n    raise Discourse::InvalidAccess if params[:archetype] == \"private_message\" && !guardian.is_staff?\n\n    topic = Topic.with_deleted.find_by(id: topic_id)\n    guardian.ensure_can_move_posts!(topic)\n\n    if params[:title].present?\n      # when creating a new topic, ensure the 1st post is a regular post\n      if Post.where(topic: topic, id: post_ids).order(:post_number).pluck_first(:post_type) != Post.types[:regular]\n        return render_json_error(\"When moving posts to a new topic, the first post must be a regular post.\")\n      end\n\n      if params[:category_id].present?\n        guardian.ensure_can_create_topic_on_category!(params[:category_id])\n      end\n    end\n\n    destination_topic = move_posts_to_destination(topic)\n    render_topic_changes(destination_topic)\n  rescue ActiveRecord::RecordInvalid => ex\n    render_json_error(ex)\n  end\n\n  def change_post_owners\n    params.require(:post_ids)\n    params.require(:topic_id)\n    params.require(:username)\n\n    guardian.ensure_can_change_post_owner!\n\n    begin\n      PostOwnerChanger.new(post_ids: params[:post_ids].to_a,\n                           topic_id: params[:topic_id].to_i,\n                           new_owner: User.find_by(username: params[:username]),\n                           acting_user: current_user).change_owner!\n      render json: success_json\n    rescue ArgumentError\n      render json: failed_json, status: 422\n    end\n  end\n\n  def change_timestamps\n    topic_id = params.require(:topic_id).to_i\n    timestamp = params.require(:timestamp).to_f\n\n    guardian.ensure_can_change_post_timestamps!\n\n    topic = Topic.with_deleted.find(topic_id)\n    previous_timestamp = topic.first_post.created_at\n\n    begin\n      TopicTimestampChanger.new(\n        topic: topic,\n        timestamp: timestamp\n      ).change!\n\n      StaffActionLogger.new(current_user).log_topic_timestamps_changed(topic, Time.zone.at(timestamp), previous_timestamp)\n\n      render json: success_json\n    rescue ActiveRecord::RecordInvalid, TopicTimestampChanger::InvalidTimestampError\n      render json: failed_json, status: 422\n    end\n  end\n\n  def clear_pin\n    topic = Topic.find_by(id: params[:topic_id].to_i)\n    guardian.ensure_can_see!(topic)\n    topic.clear_pin_for(current_user)\n    render body: nil\n  end\n\n  def re_pin\n    topic = Topic.find_by(id: params[:topic_id].to_i)\n    guardian.ensure_can_see!(topic)\n    topic.re_pin_for(current_user)\n    render body: nil\n  end\n\n  def timings\n    allowed_params = topic_params\n\n    topic_id = allowed_params[:topic_id].to_i\n    topic_time = allowed_params[:topic_time].to_i\n    timings = allowed_params[:timings].to_h || {}\n\n    # ensure we capture current user for the block\n    user = current_user\n\n    hijack do\n      PostTiming.process_timings(\n        user,\n        topic_id,\n        topic_time,\n        timings.map { |post_number, t| [post_number.to_i, t.to_i] },\n        mobile: view_context.mobile_view?\n      )\n      render body: nil\n    end\n  end\n\n  def feed\n    raise Discourse::NotFound if !Post.exists?(topic_id: params[:topic_id])\n\n    begin\n      @topic_view = TopicView.new(params[:topic_id])\n    rescue Discourse::NotLoggedIn\n      raise Discourse::NotFound\n    rescue Discourse::InvalidAccess => ex\n\n      deleted = guardian.can_see_topic?(ex.obj, false) ||\n        (!guardian.can_see_topic?(ex.obj) &&\n         ex.obj&.access_topic_via_group &&\n         ex.obj.deleted_at)\n\n      raise Discourse::NotFound.new(\n        nil,\n        check_permalinks: deleted,\n        original_path: ex.obj.relative_url\n      )\n    end\n\n    discourse_expires_in 1.minute\n    render 'topics/show', formats: [:rss]\n  end\n\n  def bulk\n    if params[:topic_ids].present?\n      unless Array === params[:topic_ids]\n        raise Discourse::InvalidParameters.new(\n          \"Expecting topic_ids to contain a list of topic ids\"\n        )\n      end\n      topic_ids = params[:topic_ids].map { |t| t.to_i }\n    elsif params[:filter] == 'unread'\n      topic_ids = bulk_unread_topic_ids\n    else\n      raise ActionController::ParameterMissing.new(:topic_ids)\n    end\n\n    operation = params\n      .require(:operation)\n      .permit(:type, :group, :category_id, :notification_level_id, *DiscoursePluginRegistry.permitted_bulk_action_parameters, tags: [])\n      .to_h.symbolize_keys\n\n    raise ActionController::ParameterMissing.new(:operation_type) if operation[:type].blank?\n    operator = TopicsBulkAction.new(current_user, topic_ids, operation, group: operation[:group])\n    changed_topic_ids = operator.perform!\n    render_json_dump topic_ids: changed_topic_ids\n  end\n\n  def private_message_reset_new\n    topic_query = TopicQuery.new(current_user, limit: false)\n\n    if params[:topic_ids].present?\n      unless Array === params[:topic_ids]\n        raise Discourse::InvalidParameters.new(\n          \"Expecting topic_ids to contain a list of topic ids\"\n        )\n      end\n\n      topic_scope = topic_query\n        .private_messages_for(current_user, :all)\n        .where(\"topics.id IN (?)\", params[:topic_ids].map(&:to_i))\n    else\n      params.require(:inbox)\n      inbox = params[:inbox].to_s\n      filter = private_message_filter(topic_query, inbox)\n      topic_scope = topic_query.filter_private_message_new(current_user, filter)\n    end\n\n    topic_ids = TopicsBulkAction.new(\n      current_user,\n      topic_scope.pluck(:id),\n      type: \"dismiss_topics\"\n    ).perform!\n\n    render json: success_json.merge(topic_ids: topic_ids)\n  end\n\n  def reset_new\n    topic_scope =\n      if params[:category_id].present?\n        category_ids = [params[:category_id]]\n        if params[:include_subcategories] == 'true'\n          category_ids = category_ids.concat(Category.where(parent_category_id: params[:category_id]).pluck(:id))\n        end\n\n        scope = Topic.where(category_id: category_ids)\n        scope = scope.joins(:tags).where(tags: { name: params[:tag_id] }) if params[:tag_id]\n        scope\n      elsif params[:tag_id].present?\n        Topic.joins(:tags).where(tags: { name: params[:tag_id] })\n      else\n        new_results = TopicQuery.new(current_user).new_results(limit: false)\n        if params[:tracked].to_s == \"true\"\n          TopicQuery.tracked_filter(new_results, current_user.id)\n        else\n          current_user.user_stat.update_column(:new_since, Time.zone.now)\n          new_results\n        end\n      end\n\n    if params[:topic_ids].present?\n      unless Array === params[:topic_ids]\n        raise Discourse::InvalidParameters.new(\n          \"Expecting topic_ids to contain a list of topic ids\"\n        )\n      end\n\n      topic_ids = params[:topic_ids].map { |t| t.to_i }\n      topic_scope = topic_scope.where(id: topic_ids)\n    end\n\n    dismissed_topic_ids = TopicsBulkAction.new(current_user, topic_scope.pluck(:id), type: \"dismiss_topics\").perform!\n    TopicTrackingState.publish_dismiss_new(current_user.id, topic_ids: dismissed_topic_ids)\n\n    render body: nil\n  end\n\n  def convert_topic\n    params.require(:id)\n    params.require(:type)\n    topic = Topic.find_by(id: params[:id])\n    guardian.ensure_can_convert_topic!(topic)\n\n    if params[:type] == \"public\"\n      converted_topic = topic.convert_to_public_topic(current_user, category_id: params[:category_id])\n    else\n      converted_topic = topic.convert_to_private_message(current_user)\n    end\n    render_topic_changes(converted_topic)\n  rescue ActiveRecord::RecordInvalid => ex\n    render_json_error(ex)\n  end\n\n  def reset_bump_date\n    params.require(:id)\n    guardian.ensure_can_update_bumped_at!\n\n    topic = Topic.find_by(id: params[:id])\n    raise Discourse::NotFound.new unless topic\n\n    topic.reset_bumped_at\n    render body: nil\n  end\n\n  def set_slow_mode\n    topic = Topic.find(params[:topic_id])\n    slow_mode_type = TopicTimer.types[:clear_slow_mode]\n    timer = TopicTimer.find_by(topic: topic, status_type: slow_mode_type)\n\n    guardian.ensure_can_moderate!(topic)\n    topic.update!(slow_mode_seconds: params[:seconds])\n    enabled = params[:seconds].to_i > 0\n\n    time = enabled && params[:enabled_until].present? ? params[:enabled_until] : nil\n\n    topic.set_or_create_timer(\n      slow_mode_type,\n      time,\n      by_user: timer&.user\n    )\n\n    head :ok\n  end\n\n  private\n\n  def topic_params\n    params.permit(\n      :topic_id,\n      :topic_time,\n      timings: {}\n    )\n  end\n\n  def fetch_topic_view(options)\n    if (username_filters = params[:username_filters]).present?\n      options[:username_filters] = username_filters.split(',')\n    end\n\n    @topic_view = TopicView.new(params[:topic_id], current_user, options)\n  end\n\n  def toggle_mute\n    @topic = Topic.find_by(id: params[:topic_id].to_i)\n    guardian.ensure_can_see!(@topic)\n\n    @topic.toggle_mute(current_user)\n    render body: nil\n  end\n\n  def consider_user_for_promotion\n    Promotion.new(current_user).review if current_user.present?\n  end\n\n  def slugs_do_not_match\n    if SiteSetting.slug_generation_method != \"encoded\"\n      params[:slug] && @topic_view.topic.slug != params[:slug]\n    else\n      params[:slug] && CGI.unescape(@topic_view.topic.slug) != params[:slug]\n    end\n  end\n\n  def redirect_to_correct_topic(topic, post_number = nil)\n    begin\n      guardian.ensure_can_see!(topic)\n    rescue Discourse::InvalidAccess => ex\n      raise(SiteSetting.detailed_404 ? ex : Discourse::NotFound)\n    end\n\n    url = topic.relative_url\n    url << \"/#{post_number}\" if post_number.to_i > 0\n    url << \".json\" if request.format.json?\n\n    page = params[:page]\n    url << \"?page=#{page}\" if page != 0\n\n    redirect_to url, status: 301\n  end\n\n  def track_visit_to_topic\n    topic_id =  @topic_view.topic.id\n    ip = request.remote_ip\n    user_id = (current_user.id if current_user)\n    track_visit = should_track_visit_to_topic?\n\n    if !request.format.json?\n      hash = {\n        referer: request.referer || flash[:referer],\n        host: request.host,\n        current_user: current_user,\n        topic_id: @topic_view.topic.id,\n        post_number: @topic_view.current_post_number,\n        username: request['u'],\n        ip_address: request.remote_ip\n      }\n      # defer this way so we do not capture the whole controller\n      # in the closure\n      TopicsController.defer_add_incoming_link(hash)\n    end\n\n    TopicsController.defer_track_visit(topic_id, ip, user_id, track_visit)\n  end\n\n  def self.defer_track_visit(topic_id, ip, user_id, track_visit)\n    Scheduler::Defer.later \"Track Visit\" do\n      TopicViewItem.add(topic_id, ip, user_id)\n      TopicUser.track_visit!(topic_id, user_id) if track_visit\n    end\n  end\n\n  def self.defer_add_incoming_link(hash)\n    Scheduler::Defer.later \"Track Link\" do\n      IncomingLink.add(hash)\n    end\n  end\n\n  def should_track_visit_to_topic?\n    !!((!request.format.json? || params[:track_visit]) && current_user)\n  end\n\n  def perform_show_response\n\n    if request.head?\n      head :ok\n      return\n    end\n\n    topic_view_serializer = TopicViewSerializer.new(\n      @topic_view,\n      scope: guardian,\n      root: false,\n      include_raw: !!params[:include_raw],\n      exclude_suggested_and_related: !!params[:replies_to_post_number] || !!params[:filter_upwards_post_id]\n    )\n\n    respond_to do |format|\n      format.html do\n        @tags = SiteSetting.tagging_enabled ? @topic_view.topic.tags : []\n        @breadcrumbs = helpers.categories_breadcrumb(@topic_view.topic) || []\n        @description_meta = @topic_view.topic.excerpt.present? ? @topic_view.topic.excerpt : @topic_view.summary\n        store_preloaded(\"topic_#{@topic_view.topic.id}\", MultiJson.dump(topic_view_serializer))\n        render :show\n      end\n\n      format.json do\n        render_json_dump(topic_view_serializer)\n      end\n    end\n  end\n\n  def render_topic_changes(dest_topic)\n    if dest_topic.present?\n      render json: { success: true, url: dest_topic.relative_url }\n    else\n      render json: { success: false }\n    end\n  end\n\n  def move_posts_to_destination(topic)\n    args = {}\n    args[:title] = params[:title] if params[:title].present?\n    args[:destination_topic_id] = params[:destination_topic_id].to_i if params[:destination_topic_id].present?\n    args[:tags] = params[:tags] if params[:tags].present?\n\n    if params[:archetype].present?\n      args[:archetype] = params[:archetype]\n      args[:participants] = params[:participants] if params[:participants].present? && params[:archetype] == \"private_message\"\n    else\n      args[:category_id] = params[:category_id].to_i if params[:category_id].present?\n    end\n\n    topic.move_posts(current_user, post_ids_including_replies, args)\n  end\n\n  def check_for_status_presence(key, attr)\n    invalid_param(key) unless %w(pinned pinned_globally visible closed archived).include?(attr)\n  end\n\n  def invalid_param(key)\n    raise Discourse::InvalidParameters.new(key.to_sym)\n  end\n\n  def fetch_username\n    params.require(:user)\n    params[:user]\n  end\n\n  def fetch_email\n    params.require(:email)\n    params[:email]\n  end\n\n  def pm_has_slots?(pm)\n    guardian.is_staff? || !pm.reached_recipients_limit?\n  end\n\n  def bulk_unread_topic_ids\n    topic_query = TopicQuery.new(current_user)\n\n    if inbox = params[:private_message_inbox]\n      filter = private_message_filter(topic_query, inbox)\n      topic_query.options[:limit] = false\n      topics = topic_query.filter_private_messages_unread(current_user, filter)\n    else\n      topics = TopicQuery.unread_filter(topic_query.joined_topic_user, staff: guardian.is_staff?).listable_topics\n      topics = TopicQuery.tracked_filter(topics, current_user.id) if params[:tracked].to_s == \"true\"\n\n      if params[:category_id]\n        if params[:include_subcategories]\n          topics = topics.where(<<~SQL, category_id: params[:category_id])\n            category_id in (select id FROM categories WHERE parent_category_id = :category_id) OR\n            category_id = :category_id\n          SQL\n        else\n          topics = topics.where('category_id = ?', params[:category_id])\n        end\n      end\n\n      if params[:tag_name].present?\n        topics = topics.joins(:tags).where(\"tags.name\": params[:tag_name])\n      end\n    end\n\n    topics.pluck(:id)\n  end\n\n  def private_message_filter(topic_query, inbox)\n    case inbox\n    when \"group\"\n      group_name = params[:group_name]\n      group = Group.find_by(\"lower(name) = ?\", group_name)\n      raise Discourse::NotFound if !group\n      raise Discourse::NotFound if !guardian.can_see_group_messages?(group)\n      topic_query.options[:group_name] = group_name\n      :group\n    when \"user\"\n      :user\n    else\n      :all\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nclass TopicQuery\n  module PrivateMessageLists\n    def list_private_messages_all(user)\n      list = private_messages_for(user, :all)\n      list = filter_archived(list, user, archived: false)\n      create_list(:private_messages, {}, list)\n    end\n\n    def list_private_messages_all_sent(user)\n      list = private_messages_for(user, :all)\n\n      list = list.where(<<~SQL, user.id)\n      EXISTS (\n        SELECT 1 FROM posts\n        WHERE posts.topic_id = topics.id AND posts.user_id = ?\n      )\n      SQL\n\n      list = filter_archived(list, user, archived: false)\n      create_list(:private_messages, {}, list)\n    end\n\n    def list_private_messages_all_archive(user)\n      list = private_messages_for(user, :all)\n      list = filter_archived(list, user, archived: true)\n      create_list(:private_messages, {}, list)\n    end\n\n    def list_private_messages_all_new(user)\n      list_private_messages_new(user, :all)\n    end\n\n    def list_private_messages_all_unread(user)\n      list_private_messages_unread(user, :all)\n    end\n\n    def list_private_messages(user)\n      list = private_messages_for(user, :user)\n      list = not_archived(list, user)\n      create_list(:private_messages, {}, list)\n    end\n\n    def list_private_messages_archive(user)\n      list = private_messages_for(user, :user)\n      list = list.joins(:user_archived_messages).where('user_archived_messages.user_id = ?', user.id)\n      create_list(:private_messages, {}, list)\n    end\n\n    def list_private_messages_sent(user)\n      list = private_messages_for(user, :user)\n\n      list = list.where(<<~SQL, user.id)\n      EXISTS (\n        SELECT 1 FROM posts\n        WHERE posts.topic_id = topics.id AND posts.user_id = ?\n      )\n      SQL\n\n      list = not_archived(list, user)\n      create_list(:private_messages, {}, list)\n    end\n\n    def list_private_messages_new(user, type = :user)\n      list = filter_private_message_new(user, type)\n      list = remove_muted_tags(list, user)\n      list = remove_dismissed(list, user)\n\n      create_list(:private_messages, {}, list)\n    end\n\n    def list_private_messages_unread(user, type = :user)\n      list = filter_private_messages_unread(user, type)\n      create_list(:private_messages, {}, list)\n    end\n\n    def list_private_messages_group(user)\n      list = private_messages_for(user, :group)\n\n      list = list.joins(<<~SQL)\n      LEFT JOIN group_archived_messages gm\n      ON gm.topic_id = topics.id AND gm.group_id = #{group.id.to_i}\n      SQL\n\n      list = list.where(\"gm.id IS NULL\")\n      publish_read_state = !!group.publish_read_state\n      list = append_read_state(list, group) if publish_read_state\n      create_list(:private_messages, { publish_read_state: publish_read_state }, list)\n    end\n\n    def list_private_messages_group_archive(user)\n      list = private_messages_for(user, :group)\n\n      list = list.joins(<<~SQL)\n      INNER JOIN group_archived_messages gm\n      ON gm.topic_id = topics.id AND gm.group_id = #{group.id.to_i}\n      SQL\n\n      publish_read_state = !!group.publish_read_state\n      list = append_read_state(list, group) if publish_read_state\n      create_list(:private_messages, { publish_read_state: publish_read_state }, list)\n    end\n\n    def list_private_messages_group_new(user)\n      list = filter_private_message_new(user, :group)\n      list = remove_dismissed(list, user)\n      publish_read_state = !!group.publish_read_state\n      list = append_read_state(list, group) if publish_read_state\n      create_list(:private_messages, { publish_read_state: publish_read_state }, list)\n    end\n\n    def list_private_messages_group_unread(user)\n      list = filter_private_messages_unread(user, :group)\n      publish_read_state = !!group.publish_read_state\n      list = append_read_state(list, group) if publish_read_state\n      create_list(:private_messages, { publish_read_state: publish_read_state }, list)\n    end\n\n    def list_private_messages_warnings(user)\n      list = private_messages_for(user, :user)\n      list = list.where('topics.subtype = ?', TopicSubtype.moderator_warning)\n      # Exclude official warnings that the user created, instead of received\n      list = list.where('topics.user_id <> ?', user.id)\n      create_list(:private_messages, {}, list)\n    end\n\n    def private_messages_for(user, type)\n      options = @options\n      options.reverse_merge!(per_page: per_page_setting)\n\n      result = Topic.includes(:allowed_users)\n      result = result.includes(:tags) if SiteSetting.tagging_enabled\n\n      if type == :group\n        result = result.joins(\n          \"INNER JOIN topic_allowed_groups tag ON tag.topic_id = topics.id AND tag.group_id IN (SELECT id FROM groups WHERE LOWER(name) = '#{PG::Connection.escape_string(@options[:group_name].downcase)}')\"\n        )\n\n        unless user.admin?\n          result = result.joins(\"INNER JOIN group_users gu ON gu.group_id = tag.group_id AND gu.user_id = #{user.id.to_i}\")\n        end\n      elsif type == :user\n        result = result.where(\"topics.id IN (SELECT topic_id FROM topic_allowed_users WHERE user_id = #{user.id.to_i})\")\n      elsif type == :all\n        group_ids = group_with_messages_ids(user)\n\n        result =\n        if group_ids.present?\n          result.where(<<~SQL)\n            topics.id IN (\n              SELECT topic_id\n              FROM topic_allowed_users\n              WHERE user_id = #{user.id.to_i}\n              UNION ALL\n              SELECT topic_id FROM topic_allowed_groups\n              WHERE group_id IN (#{group_ids.join(\",\")})\n            )\n          SQL\n        else\n          result.joins(<<~SQL)\n          INNER JOIN topic_allowed_users tau\n            ON tau.topic_id = topics.id\n            AND tau.user_id = #{user.id.to_i}\n          SQL\n        end\n      end\n\n      result = result.joins(\"LEFT OUTER JOIN topic_users AS tu ON (topics.id = tu.topic_id AND tu.user_id = #{user.id.to_i})\")\n        .order(\"topics.bumped_at DESC\")\n        .private_messages\n\n      result = result.limit(options[:per_page]) unless options[:limit] == false\n      result = result.visible if options[:visible] || @user.nil? || @user.regular?\n\n      if options[:page]\n        offset = options[:page].to_i * options[:per_page]\n        result = result.offset(offset) if offset > 0\n      end\n      result\n    end\n\n    def list_private_messages_tag(user)\n      list = private_messages_for(user, :all)\n      list = list.joins(\"JOIN topic_tags tt ON tt.topic_id = topics.id\n                        JOIN tags t ON t.id = tt.tag_id AND t.name = '#{@options[:tags][0]}'\")\n      create_list(:private_messages, {}, list)\n    end\n\n    def filter_private_messages_unread(user, type)\n      list = TopicQuery.unread_filter(\n        private_messages_for(user, type),\n        staff: user.staff?\n      )\n\n      first_unread_pm_at =\n        case type\n        when :user\n          user_first_unread_pm_at(user)\n        when :group\n          GroupUser\n            .where(user: user, group: group)\n            .pluck_first(:first_unread_pm_at)\n        else\n          user_first_unread_pm_at = user_first_unread_pm_at(user)\n\n          group_first_unread_pm_at = GroupUser\n            .where(user: user)\n            .minimum(:first_unread_pm_at)\n\n          [user_first_unread_pm_at, group_first_unread_pm_at].compact.min\n        end\n\n      if first_unread_pm_at\n        list = list.where(\"topics.updated_at >= ?\", first_unread_pm_at)\n      end\n\n      list\n    end\n\n    def filter_private_message_new(user, type)\n      TopicQuery.new_filter(\n        private_messages_for(user, type),\n        treat_as_new_topic_start_date: user.user_option.treat_as_new_topic_start_date\n      )\n    end\n\n    private\n\n    def append_read_state(list, group)\n      group_id = group.id\n      return list if group_id.nil?\n\n      selected_values = list.select_values.empty? ? ['topics.*'] : list.select_values\n      selected_values << \"COALESCE(tg.last_read_post_number, 0) AS last_read_post_number\"\n\n      list\n        .joins(\"LEFT OUTER JOIN topic_groups tg ON topics.id = tg.topic_id AND tg.group_id = #{group_id}\")\n        .select(*selected_values)\n    end\n\n    def filter_archived(list, user, archived: true)\n      # Executing an extra query instead of a sub-query because it is more\n      # efficient for the PG planner. Caution should be used when changing the\n      # query here as it can easily lead to an inefficient query.\n      group_ids = group_with_messages_ids(user)\n\n      if group_ids.present?\n        list = list.joins(<<~SQL)\n          LEFT JOIN group_archived_messages gm\n            ON gm.topic_id = topics.id\n            AND gm.group_id IN (#{group_ids.join(\",\")})\n          LEFT JOIN user_archived_messages um\n            ON um.user_id = #{user.id.to_i}\n            AND um.topic_id = topics.id\n        SQL\n\n        if archived\n          list.where(\"um.user_id IS NOT NULL OR gm.topic_id IS NOT NULL\")\n        else\n          list.where(\"um.user_id IS NULL AND gm.topic_id IS NULL\")\n        end\n      else\n        list = list.joins(<<~SQL)\n          LEFT JOIN user_archived_messages um\n          ON um.user_id = #{user.id.to_i}\n          AND um.topic_id = topics.id\n        SQL\n\n        list.where(\"um.user_id IS #{archived ? \"NOT NULL\" : \"NULL\"}\")\n      end\n    end\n\n    def not_archived(list, user)\n      list.joins(\"LEFT JOIN user_archived_messages um\n                         ON um.user_id = #{user.id.to_i} AND um.topic_id = topics.id\")\n        .where('um.user_id IS NULL')\n    end\n\n    def group\n      @group ||= begin\n        Group\n          .where('name ilike ?', @options[:group_name])\n          .select(:id, :publish_read_state)\n          .first\n      end\n    end\n\n    def user_first_unread_pm_at(user)\n      UserStat.where(user: user).pluck_first(:first_unread_pm_at)\n    end\n\n    def group_with_messages_ids(user)\n      @group_with_messages_ids ||= {}\n\n      if ids = @group_with_messages_ids[user.id]\n        return ids\n      end\n\n      @group_with_messages_ids[user.id] = user.groups.where(has_messages: true).pluck(:id)\n    end\n  end\nend\n"], "filenames": ["app/controllers/topics_controller.rb", "lib/topic_query/private_message_lists.rb"], "buggy_code_start_loc": [976, 148], "buggy_code_end_loc": [1274, 258], "fixing_code_start_loc": [976, 148], "fixing_code_end_loc": [1270, 272], "type": "CWE-863", "message": "Discourse is a platform for community discussion. In affected versions any private message that includes a group had its title and participating user exposed to users that do not have access to the private messages. However, access control for the private messages was not compromised as users were not able to view the posts in the leaked private message despite seeing it in their inbox. The problematic commit was reverted around 32 minutes after it was made. Users are encouraged to upgrade to the latest commit if they are running Discourse against the `tests-passed` branch.", "other": {"cve": {"id": "CVE-2021-41082", "sourceIdentifier": "security-advisories@github.com", "published": "2021-09-20T21:15:07.523", "lastModified": "2021-10-04T18:07:10.450", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Discourse is a platform for community discussion. In affected versions any private message that includes a group had its title and participating user exposed to users that do not have access to the private messages. However, access control for the private messages was not compromised as users were not able to view the posts in the leaked private message despite seeing it in their inbox. The problematic commit was reverted around 32 minutes after it was made. Users are encouraged to upgrade to the latest commit if they are running Discourse against the `tests-passed` branch."}, {"lang": "es", "value": "Discourse es una plataforma de discusi\u00f3n comunitaria. En las versiones afectadas, cualquier mensaje privado que incluya un grupo ten\u00eda su t\u00edtulo y el usuario participante expuestos a usuarios que no tienen acceso a los mensajes privados. Sin embargo, el control de acceso a los mensajes privados no estaba comprometido, ya que los usuarios no pod\u00edan visualizar los mensajes privados filtrados a pesar de verlos en su bandeja de entrada. El commit problem\u00e1tico fue revertido unos 32 minutos despu\u00e9s de su realizaci\u00f3n. Se recomienda a los usuarios que actualicen al \u00faltimo commit si est\u00e1n ejecutando Discourse con la rama \"tests-passed\""}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-863"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:*:*:*:*:*:*:*:*", "versionEndExcluding": "2021-09-14", "matchCriteriaId": "0517E24E-7DAB-4CA0-A5C1-D5BAD07AC781"}]}]}], "references": [{"url": "https://github.com/discourse/discourse/commit/27bad28c530c89acab35a56b945b6a3924280f4b", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/discourse/discourse/commit/ddb458343dc39a7a8c99467dcd809b444514fe2c", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/discourse/discourse/security/advisories/GHSA-vm3x-w6jm-j9vv", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/discourse/discourse/commit/27bad28c530c89acab35a56b945b6a3924280f4b"}}