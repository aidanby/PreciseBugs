{"buggy_code": ["/* vi:set et sw=2 sts=2 cin cino=t0,f0,(0,{s,>2s,n-s,^-s,e-s:\n * Copyright \u00a9 2018 Red Hat, Inc\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\t See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library. If not, see <http://www.gnu.org/licenses/>.\n *\n * Authors:\n *       Alexander Larsson <alexl@redhat.com>\n */\n\n#include \"config.h\"\n\n#include \"flatpak-cli-transaction.h\"\n#include \"flatpak-transaction-private.h\"\n#include \"flatpak-installation-private.h\"\n#include \"flatpak-run-private.h\"\n#include \"flatpak-table-printer.h\"\n#include \"flatpak-utils-private.h\"\n#include \"flatpak-error.h\"\n#include <glib/gi18n.h>\n\n\nstruct _FlatpakCliTransaction\n{\n  FlatpakTransaction   parent;\n\n  gboolean             disable_interaction;\n  gboolean             stop_on_first_error;\n  gboolean             non_default_arch;\n  GError              *first_operation_error;\n\n  GHashTable          *eol_actions;\n  GHashTable          *runtime_app_map;\n  GHashTable          *extension_app_map;\n\n  int                  rows;\n  int                  cols;\n  int                  table_width;\n  int                  table_height;\n\n  int                  n_ops;\n  int                  op;\n  int                  op_progress;\n\n  gboolean             installing;\n  gboolean             updating;\n  gboolean             uninstalling;\n\n  int                  download_col;\n\n  FlatpakTablePrinter *printer;\n  int                  progress_row;\n  char                *progress_msg;\n  int                  speed_len;\n\n  gboolean             did_interaction;\n};\n\nstruct _FlatpakCliTransactionClass\n{\n  FlatpakTransactionClass parent_class;\n};\n\nG_DEFINE_TYPE (FlatpakCliTransaction, flatpak_cli_transaction, FLATPAK_TYPE_TRANSACTION);\n\nstatic int\nchoose_remote_for_ref (FlatpakTransaction *transaction,\n                       const char         *for_ref,\n                       const char         *runtime_ref,\n                       const char * const *remotes)\n{\n  FlatpakCliTransaction *self = FLATPAK_CLI_TRANSACTION (transaction);\n  int n_remotes = g_strv_length ((char **) remotes);\n  int chosen = -1;\n  const char *pref;\n\n  pref = strchr (for_ref, '/') + 1;\n\n  self->did_interaction = TRUE;\n\n  if (self->disable_interaction)\n    {\n      g_print (_(\"Required runtime for %s (%s) found in remote %s\\n\"),\n               pref, runtime_ref, remotes[0]);\n      chosen = 0;\n    }\n  else if (n_remotes == 1)\n    {\n      g_print (_(\"Required runtime for %s (%s) found in remote %s\\n\"),\n               pref, runtime_ref, remotes[0]);\n      if (flatpak_yes_no_prompt (TRUE, _(\"Do you want to install it?\")))\n        chosen = 0;\n    }\n  else\n    {\n      flatpak_format_choices ((const char **) remotes,\n                              _(\"Required runtime for %s (%s) found in remotes:\"),\n                              pref, runtime_ref);\n      chosen = flatpak_number_prompt (TRUE, 0, n_remotes, _(\"Which do you want to install (0 to abort)?\"));\n      chosen -= 1; /* convert from base-1 to base-0 (and -1 to abort) */\n    }\n\n  return chosen;\n}\n\nstatic gboolean\nadd_new_remote (FlatpakTransaction            *transaction,\n                FlatpakTransactionRemoteReason reason,\n                const char                    *from_id,\n                const char                    *remote_name,\n                const char                    *url)\n{\n  FlatpakCliTransaction *self = FLATPAK_CLI_TRANSACTION (transaction);\n\n  self->did_interaction = TRUE;\n\n  if (self->disable_interaction)\n    {\n      g_print (_(\"Configuring %s as new remote '%s'\\n\"), url, remote_name);\n      return TRUE;\n    }\n\n  if (reason == FLATPAK_TRANSACTION_REMOTE_GENERIC_REPO)\n    {\n      if (flatpak_yes_no_prompt (TRUE, /* default to yes on Enter */\n                                 _(\"The remote '%s', referred to by '%s' at location %s contains additional applications.\\n\"\n                                   \"Should the remote be kept for future installations?\"),\n                                 remote_name, from_id, url))\n        return TRUE;\n    }\n  else if (reason == FLATPAK_TRANSACTION_REMOTE_RUNTIME_DEPS)\n    {\n      if (flatpak_yes_no_prompt (TRUE, /* default to yes on Enter */\n                                 _(\"The application %s depends on runtimes from:\\n  %s\\n\"\n                                   \"Configure this as new remote '%s'\"),\n                                 from_id, url, remote_name))\n        return TRUE;\n    }\n\n  return FALSE;\n}\n\nstatic void\ninstall_authenticator (FlatpakTransaction            *old_transaction,\n                       const char                    *remote,\n                       const char                    *ref)\n{\n  FlatpakCliTransaction *old_cli = FLATPAK_CLI_TRANSACTION (old_transaction);\n  g_autoptr(FlatpakTransaction)  transaction2 = NULL;\n  g_autoptr(GError) local_error = NULL;\n  FlatpakInstallation *installation = flatpak_transaction_get_installation (old_transaction);\n  FlatpakDir *dir = flatpak_installation_get_dir (installation, NULL);\n\n  if (dir == NULL)\n    {\n      /* This should not happen */\n      g_warning (\"No dir in install_authenticator\");\n      return;\n    }\n\n  old_cli->did_interaction = TRUE;\n\n  transaction2 = flatpak_cli_transaction_new (dir, old_cli->disable_interaction, TRUE, FALSE, &local_error);\n  if (transaction2 == NULL)\n    {\n      g_printerr (\"Unable to install authenticator: %s\\n\", local_error->message);\n      return;\n    }\n\n  g_print (\"Installing required authenticator for remote %s\\n\", remote);\n  if (!flatpak_transaction_add_install (transaction2, remote, ref, NULL, &local_error))\n    {\n      if (!g_error_matches (local_error, FLATPAK_ERROR, FLATPAK_ERROR_ALREADY_INSTALLED))\n        g_printerr (\"Unable to install authenticator: %s\\n\", local_error->message);\n      return;\n    }\n\n  if (!flatpak_transaction_run (transaction2, NULL, &local_error))\n    {\n      if (!g_error_matches (local_error, FLATPAK_ERROR, FLATPAK_ERROR_ABORTED))\n        g_printerr (\"Unable to install authenticator: %s\\n\", local_error->message);\n      return;\n    }\n\n  return;\n}\n\nstatic gboolean\nredraw (FlatpakCliTransaction *self)\n{\n  int top;\n  int row;\n  int current_row;\n  int current_col;\n  int skip;\n\n  /* We may have resized and thus repositioned the cursor since last redraw */\n  flatpak_get_window_size (&self->rows, &self->cols);\n  if (flatpak_get_cursor_pos (&current_row, &current_col))\n    {\n      /* We're currently displaying the last row of the table, extept the\n         very first time where the user pressed return for the prompt causing us\n         to scroll down one extra row */\n      top = current_row - self->table_height + 1;\n      if (top > 0)\n        {\n          row = top;\n          skip = 0;\n        }\n      else\n        {\n          row = 1;\n          skip = 1 - top;\n        }\n\n      g_print (FLATPAK_ANSI_ROW_N FLATPAK_ANSI_CLEAR, row);\n      // we update table_height and end_row here, since we might have added to the table\n      flatpak_table_printer_print_full (self->printer, skip, self->cols,\n                                        &self->table_height, &self->table_width);\n      return TRUE;\n    }\n  return FALSE;\n}\n\nstatic void\nset_op_progress (FlatpakCliTransaction       *self,\n                 FlatpakTransactionOperation *op,\n                 const char                  *progress)\n{\n  if (flatpak_fancy_output ())\n    {\n      int row = GPOINTER_TO_INT (g_object_get_data (G_OBJECT (op), \"row\"));\n      g_autofree char *cell = g_strdup_printf (\"[%s]\", progress);\n      flatpak_table_printer_set_cell (self->printer, row, 1, cell);\n    }\n}\n\nstatic void\nspin_op_progress (FlatpakCliTransaction       *self,\n                  FlatpakTransactionOperation *op)\n{\n  const char *p[] = {\n    \"|\",\n    \"/\",\n    \"\u2014\",\n    \"\\\\\",\n  };\n\n  set_op_progress (self, op, p[self->op_progress++ % G_N_ELEMENTS (p)]);\n}\n\nstatic char *\nformat_duration (guint64 duration)\n{\n  int h, m, s;\n\n  m = duration / 60;\n  s = duration % 60;\n  h = m / 60;\n  m = m % 60;\n\n  if (h > 0)\n    return g_strdup_printf (\"%02d:%02d:%02d\", h, m, s);\n  else\n    return g_strdup_printf (\"%02d:%02d\", m, s);\n}\n\nstatic void\nprogress_changed_cb (FlatpakTransactionProgress *progress,\n                     gpointer                    data)\n{\n  FlatpakCliTransaction *cli = data;\n  FlatpakTransaction *self = FLATPAK_TRANSACTION (cli);\n  g_autoptr(FlatpakTransactionOperation) op = flatpak_transaction_get_current_operation (self);\n  g_autoptr(GString) str = g_string_new (\"\");\n  int i;\n  int n_full, partial;\n  g_autofree char *speed = NULL;\n  int bar_length;\n  const char *partial_blocks[] = {\n    \" \",\n    \"\u258f\",\n    \"\u258e\",\n    \"\u258d\",\n    \"\u258c\",\n    \"\u258b\",\n    \"\u258a\",\n    \"\u2589\",\n  };\n  const char *full_block = \"\u2588\";\n\n  guint percent = flatpak_transaction_progress_get_progress (progress);\n  guint64 start_time = flatpak_transaction_progress_get_start_time (progress);\n  guint64 elapsed_time = (g_get_monotonic_time () - start_time) / G_USEC_PER_SEC;\n  guint64 transferred = flatpak_transaction_progress_get_bytes_transferred (progress);\n  guint64 max = flatpak_transaction_operation_get_download_size (op);\n\n  if (elapsed_time > 0)\n    {\n      g_autofree char *formatted_bytes_sec = g_format_size (transferred / elapsed_time);\n      g_autofree char *remaining = NULL;\n      if (elapsed_time > 3 && percent > 0)\n        {\n          guint64 total_time = elapsed_time * 100 / (double) percent;\n          remaining = format_duration (total_time - elapsed_time);\n        }\n      speed = g_strdup_printf (\"%s/s%s%s\", formatted_bytes_sec, remaining ? \"  \" : \"\", remaining ? remaining : \"\");\n      cli->speed_len = MAX (cli->speed_len, strlen (speed) + 2);\n    }\n\n  spin_op_progress (cli, op);\n\n  bar_length = MIN (20, cli->table_width - (strlen (cli->progress_msg) + 6 + cli->speed_len));\n\n  n_full = (bar_length * percent) / 100;\n  partial = (((bar_length * percent) % 100) * G_N_ELEMENTS (partial_blocks)) / 100;\n  /* The above should guarantee this: */\n  g_assert (partial >= 0);\n  g_assert (partial < G_N_ELEMENTS (partial_blocks));\n\n  g_string_append (str, cli->progress_msg);\n  g_string_append (str, \" \");\n\n  if (flatpak_fancy_output ())\n    g_string_append (str, FLATPAK_ANSI_FAINT_ON);\n\n  for (i = 0; i < n_full; i++)\n    g_string_append (str, full_block);\n\n  if (i < bar_length)\n    {\n      g_string_append (str, partial_blocks[partial]);\n      i++;\n    }\n\n  if (flatpak_fancy_output ())\n    g_string_append (str, FLATPAK_ANSI_FAINT_OFF);\n\n  for (; i < bar_length; i++)\n    g_string_append (str, \" \");\n\n  g_string_append (str, \" \");\n  g_string_append_printf (str, \"%3d%%\", percent);\n\n  if (speed)\n    g_string_append_printf (str, \"  %s\", speed);\n\n  if (flatpak_fancy_output ())\n    {\n      flatpak_table_printer_set_cell (cli->printer, cli->progress_row, 0, str->str);\n      if (flatpak_transaction_operation_get_operation_type (op) != FLATPAK_TRANSACTION_OPERATION_UNINSTALL)\n        {\n          g_autofree char *formatted_max = NULL;\n          g_autofree char *formatted = NULL;\n          g_autofree char *text = NULL;\n          int row;\n\n          // avoid \"bytes\"\n          formatted = transferred < 1000 ? g_format_size (1000) : g_format_size (transferred);\n          formatted_max = max < 1000 ? g_format_size (1000) : g_format_size (max);\n\n          text = g_strdup_printf (\"%s / %s\", formatted, formatted_max);\n          row = GPOINTER_TO_INT (g_object_get_data (G_OBJECT (op), \"row\"));\n          flatpak_table_printer_set_decimal_cell (cli->printer, row, cli->download_col, text);\n        }\n      if (!redraw (cli))\n        g_print (\"\\r%s\", str->str); /* redraw failed, just update the progress */\n    }\n  else\n    g_print (\"%s\\n\", str->str);\n}\n\nstatic void\nset_progress (FlatpakCliTransaction *self,\n              const char            *text)\n{\n  flatpak_table_printer_set_cell (self->printer, self->progress_row, 0, text);\n}\n\nstatic void\nnew_operation (FlatpakTransaction          *transaction,\n               FlatpakTransactionOperation *op,\n               FlatpakTransactionProgress  *progress)\n{\n  FlatpakCliTransaction *self = FLATPAK_CLI_TRANSACTION (transaction);\n  FlatpakTransactionOperationType op_type = flatpak_transaction_operation_get_operation_type (op);\n  g_autofree char *text = NULL;\n\n  self->op++;\n  self->op_progress = 0;\n\n  switch (op_type)\n    {\n    case FLATPAK_TRANSACTION_OPERATION_INSTALL_BUNDLE:\n    case FLATPAK_TRANSACTION_OPERATION_INSTALL:\n      if (self->n_ops == 1)\n        text = g_strdup (_(\"Installing\u2026\"));\n      else\n        text = g_strdup_printf (_(\"Installing %d/%d\u2026\"), self->op, self->n_ops);\n      break;\n\n    case FLATPAK_TRANSACTION_OPERATION_UPDATE:\n      if (self->n_ops == 1)\n        text = g_strdup (_(\"Updating\u2026\"));\n      else\n        text = g_strdup_printf (_(\"Updating %d/%d\u2026\"), self->op, self->n_ops);\n      break;\n\n    case FLATPAK_TRANSACTION_OPERATION_UNINSTALL:\n      if (self->n_ops == 1)\n        text = g_strdup (_(\"Uninstalling\u2026\"));\n      else\n        text = g_strdup_printf (_(\"Uninstalling %d/%d\u2026\"), self->op, self->n_ops);\n      break;\n\n    default:\n      g_assert_not_reached ();\n      break;\n    }\n\n  if (flatpak_fancy_output ())\n    {\n      set_progress (self, text);\n      spin_op_progress (self, op);\n      redraw (self);\n    }\n  else\n    g_print (\"%s\\n\", text);\n\n  g_free (self->progress_msg);\n  self->progress_msg = g_steal_pointer (&text);\n\n  g_signal_connect (progress, \"changed\", G_CALLBACK (progress_changed_cb), self);\n  flatpak_transaction_progress_set_update_frequency (progress, FLATPAK_CLI_UPDATE_INTERVAL_MS);\n}\n\nstatic void\noperation_done (FlatpakTransaction          *transaction,\n                FlatpakTransactionOperation *op,\n                const char                  *commit,\n                FlatpakTransactionResult     details)\n{\n  FlatpakCliTransaction *self = FLATPAK_CLI_TRANSACTION (transaction);\n  FlatpakTransactionOperationType op_type = flatpak_transaction_operation_get_operation_type (op);\n\n  if (op_type == FLATPAK_TRANSACTION_OPERATION_UNINSTALL)\n    set_op_progress (self, op, FLATPAK_ANSI_GREEN \"-\" FLATPAK_ANSI_COLOR_RESET);\n  else\n    set_op_progress (self, op, FLATPAK_ANSI_GREEN \"\u2713\" FLATPAK_ANSI_COLOR_RESET);\n\n  if (flatpak_fancy_output ())\n    redraw (self);\n}\n\nstatic gboolean\noperation_error (FlatpakTransaction            *transaction,\n                 FlatpakTransactionOperation   *op,\n                 const GError                  *error,\n                 FlatpakTransactionErrorDetails detail)\n{\n  FlatpakCliTransaction *self = FLATPAK_CLI_TRANSACTION (transaction);\n  FlatpakTransactionOperationType op_type = flatpak_transaction_operation_get_operation_type (op);\n  const char *ref = flatpak_transaction_operation_get_ref (op);\n  g_autoptr(FlatpakRef) rref = flatpak_ref_parse (ref, NULL);\n  gboolean non_fatal = (detail & FLATPAK_TRANSACTION_ERROR_DETAILS_NON_FATAL) != 0;\n  g_autofree char *text = NULL;\n  const char *on = \"\";\n  const char *off = \"\";\n\n  if (flatpak_fancy_output ())\n    {\n      on = FLATPAK_ANSI_BOLD_ON;\n      off = FLATPAK_ANSI_BOLD_OFF;\n    }\n\n  if (g_error_matches (error, FLATPAK_ERROR, FLATPAK_ERROR_SKIPPED))\n    {\n      set_op_progress (self, op, \"\u237b\");\n      text = g_strdup_printf (_(\"Info: %s was skipped\"), flatpak_ref_get_name (rref));\n      if (flatpak_fancy_output ())\n        {\n          flatpak_table_printer_set_cell (self->printer, self->progress_row, 0, text);\n          self->progress_row++;\n          flatpak_table_printer_add_span (self->printer, \"\");\n          flatpak_table_printer_finish_row (self->printer);\n          redraw (self);\n        }\n      else\n        g_print (\"%s\\n\", text);\n\n      return TRUE;\n    }\n\n  set_op_progress (self, op, \"\u2717\");\n\n  /* Here we go to great lengths not to split the sentences. See\n   * https://wiki.gnome.org/TranslationProject/DevGuidelines/Never%20split%20sentences\n   */\n  if (g_error_matches (error, FLATPAK_ERROR, FLATPAK_ERROR_ALREADY_INSTALLED))\n    {\n      if (non_fatal)\n        text = g_strdup_printf (_(\"Warning: %s%s%s already installed\"),\n                                on, flatpak_ref_get_name (rref), off);\n      else\n        text = g_strdup_printf (_(\"Error: %s%s%s already installed\"),\n                                on, flatpak_ref_get_name (rref), off);\n    }\n  else if (g_error_matches (error, FLATPAK_ERROR, FLATPAK_ERROR_NOT_INSTALLED))\n    {\n      if (non_fatal)\n        text = g_strdup_printf (_(\"Warning: %s%s%s not installed\"),\n                                on, flatpak_ref_get_name (rref), off);\n      else\n        text = g_strdup_printf (_(\"Error: %s%s%s not installed\"),\n                                on, flatpak_ref_get_name (rref), off);\n    }\n  else if (g_error_matches (error, FLATPAK_ERROR, FLATPAK_ERROR_NEED_NEW_FLATPAK))\n    {\n      if (non_fatal)\n        text = g_strdup_printf (_(\"Warning: %s%s%s needs a later flatpak version\"),\n                                on, flatpak_ref_get_name (rref), off);\n      else\n        text = g_strdup_printf (_(\"Error: %s%s%s needs a later flatpak version\"),\n                                on, flatpak_ref_get_name (rref), off);\n    }\n  else if (g_error_matches (error, FLATPAK_ERROR, FLATPAK_ERROR_OUT_OF_SPACE))\n    {\n      if (non_fatal)\n        text = g_strdup (_(\"Warning: Not enough disk space to complete this operation\"));\n      else\n        text = g_strdup (_(\"Error: Not enough disk space to complete this operation\"));\n    }\n  else if (error)\n    {\n      if (non_fatal)\n        text = g_strdup_printf (_(\"Warning: %s\"), error->message);\n      else\n        text = g_strdup_printf (_(\"Error: %s\"), error->message);\n    }\n  else\n    text = g_strdup (\"(internal error, please report)\");\n\n  if (!non_fatal && self->first_operation_error == NULL)\n    {\n      /* Here we go to great lengths not to split the sentences. See\n       * https://wiki.gnome.org/TranslationProject/DevGuidelines/Never%20split%20sentences\n       */\n      switch (op_type)\n        {\n          case FLATPAK_TRANSACTION_OPERATION_INSTALL:\n            g_propagate_prefixed_error (&self->first_operation_error,\n                                        g_error_copy (error),\n                                        _(\"Failed to install %s%s%s: \"),\n                                        on, flatpak_ref_get_name (rref), off);\n            break;\n\n          case FLATPAK_TRANSACTION_OPERATION_UPDATE:\n            g_propagate_prefixed_error (&self->first_operation_error,\n                                        g_error_copy (error),\n                                        _(\"Failed to update %s%s%s: \"),\n                                        on, flatpak_ref_get_name (rref), off);\n            break;\n\n          case FLATPAK_TRANSACTION_OPERATION_INSTALL_BUNDLE:\n            g_propagate_prefixed_error (&self->first_operation_error,\n                                        g_error_copy (error),\n                                        _(\"Failed to install bundle %s%s%s: \"),\n                                        on, flatpak_ref_get_name (rref), off);\n            break;\n\n          case FLATPAK_TRANSACTION_OPERATION_UNINSTALL:\n            g_propagate_prefixed_error (&self->first_operation_error,\n                                        g_error_copy (error),\n                                        _(\"Failed to uninstall %s%s%s: \"),\n                                        on, flatpak_ref_get_name (rref), off);\n            break;\n\n          default:\n            g_assert_not_reached ();\n        }\n    }\n\n  if (flatpak_fancy_output ())\n    {\n      flatpak_table_printer_set_cell (self->printer, self->progress_row, 0, text);\n      self->progress_row++;\n      flatpak_table_printer_add_span (self->printer, \"\");\n      flatpak_table_printer_finish_row (self->printer);\n      redraw (self);\n    }\n  else\n    g_printerr (\"%s\\n\", text);\n\n  if (!non_fatal && self->stop_on_first_error)\n    return FALSE;\n\n  return TRUE; /* Continue */\n}\n\nstatic gboolean\nwebflow_start (FlatpakTransaction *transaction,\n               const char         *remote,\n               const char         *url,\n               GVariant           *options,\n               guint               id)\n{\n  FlatpakCliTransaction *self = FLATPAK_CLI_TRANSACTION (transaction);\n  const char *browser;\n  g_autoptr(GError) local_error = NULL;\n  const char *args[3] = { NULL, url, NULL };\n\n  self->did_interaction = TRUE;\n\n  if (!self->disable_interaction)\n    {\n      g_print (_(\"Authentication required for remote '%s'\\n\"), remote);\n      if (!flatpak_yes_no_prompt (TRUE, _(\"Open browser?\")))\n        return FALSE;\n    }\n\n  /* Allow hard overrides with $BROWSER */\n  browser = g_getenv (\"BROWSER\");\n  if (browser != NULL)\n    {\n      args[0] = browser;\n      if (!g_spawn_async (NULL, (char **)args, NULL, G_SPAWN_SEARCH_PATH,\n                          NULL, NULL, NULL, &local_error))\n        {\n          g_printerr (\"Failed to start browser %s: %s\\n\", browser, local_error->message);\n          return FALSE;\n        }\n    }\n  else\n    {\n      if (!g_app_info_launch_default_for_uri (url, NULL, &local_error))\n        {\n          g_printerr (\"Failed to show url: %s\\n\", local_error->message);\n          return FALSE;\n        }\n    }\n\n  g_print (\"Waiting for browser...\\n\");\n\n  return TRUE;\n}\n\nstatic void\nwebflow_done (FlatpakTransaction *transaction,\n              GVariant           *options,\n              guint               id)\n{\n  g_print (\"Browser done\\n\");\n}\n\nstatic gboolean\nbasic_auth_start (FlatpakTransaction *transaction,\n                  const char         *remote,\n                  const char         *realm,\n                  GVariant           *options,\n                  guint               id)\n{\n  FlatpakCliTransaction *self = FLATPAK_CLI_TRANSACTION (transaction);\n  char *user, *password, *previous_error = NULL;\n\n  if (self->disable_interaction)\n    return FALSE;\n\n  self->did_interaction = TRUE;\n\n  if (g_variant_lookup (options, \"previous-error\", \"&s\", &previous_error))\n    g_print (\"%s\\n\", previous_error);\n\n  g_print (_(\"Login required remote %s (realm %s)\\n\"), remote, realm);\n  user = flatpak_prompt (FALSE, _(\"User\"));\n  if (user == NULL)\n    return FALSE;\n\n  password = flatpak_password_prompt (_(\"Password\"));\n  if (password == NULL)\n    return FALSE;\n\n  flatpak_transaction_complete_basic_auth (transaction, id, user, password, NULL);\n  return TRUE;\n}\n\n\ntypedef enum {\n  EOL_UNDECIDED,\n  EOL_IGNORE,        /* Don't do anything, we already printed a warning */\n  EOL_NO_REBASE,     /* Choose to not rebase */\n  EOL_REBASE,        /* Choose to rebase */\n} EolAction;\n\nstatic void\nprint_eol_info_message (FlatpakDir        *dir,\n                        FlatpakDecomposed *ref,\n                        const char        *ref_name,\n                        const char        *rebased_to_ref,\n                        const char        *reason)\n{\n  gboolean is_pinned = flatpak_dir_ref_is_pinned (dir, flatpak_decomposed_get_ref (ref));\n  g_autofree char *ref_branch = flatpak_decomposed_dup_branch (ref);\n  const char *on = \"\";\n  const char *off = \"\";\n\n  if (flatpak_fancy_output ())\n    {\n      on = FLATPAK_ANSI_BOLD_ON;\n      off = FLATPAK_ANSI_BOLD_OFF;\n    }\n\n  /* Here we go to great lengths not to split the sentences. See\n   * https://wiki.gnome.org/TranslationProject/DevGuidelines/Never%20split%20sentences\n   */\n  if (rebased_to_ref)\n    {\n      g_autoptr(FlatpakDecomposed) eolr_decomposed = NULL;\n      g_autofree char *eolr_name = NULL;\n      const char *eolr_branch;\n\n      eolr_decomposed = flatpak_decomposed_new_from_ref (rebased_to_ref, NULL);\n\n      /* These are guarantees from FlatpakTransaction */\n      g_assert (eolr_decomposed != NULL);\n      g_assert (flatpak_decomposed_get_kind (ref) == flatpak_decomposed_get_kind (eolr_decomposed));\n\n      eolr_name = flatpak_decomposed_dup_id (eolr_decomposed);\n      eolr_branch = flatpak_decomposed_get_branch (eolr_decomposed);\n\n      if (is_pinned)\n        {\n          /* Only runtimes can be pinned */\n          g_print (_(\"\\nInfo: (pinned) runtime %s%s%s branch %s%s%s is end-of-life, in favor of %s%s%s branch %s%s%s\\n\"),\n                   on, ref_name, off, on, ref_branch, off, on, eolr_name, off, on, eolr_branch, off);\n        }\n      else\n        {\n          if (flatpak_decomposed_is_runtime (ref))\n            g_print (_(\"\\nInfo: runtime %s%s%s branch %s%s%s is end-of-life, in favor of %s%s%s branch %s%s%s\\n\"),\n                     on, ref_name, off, on, ref_branch, off, on, eolr_name, off, on, eolr_branch, off);\n          else\n            g_print (_(\"\\nInfo: app %s%s%s branch %s%s%s is end-of-life, in favor of %s%s%s branch %s%s%s\\n\"),\n                     on, ref_name, off, on, ref_branch, off, on, eolr_name, off, on, eolr_branch, off);\n        }\n    }\n  else if (reason)\n    {\n      if (is_pinned)\n        {\n          /* Only runtimes can be pinned */\n          g_print (_(\"\\nInfo: (pinned) runtime %s%s%s branch %s%s%s is end-of-life, with reason:\\n\"),\n                   on, ref_name, off, on, ref_branch, off);\n        }\n      else\n        {\n          if (flatpak_decomposed_is_runtime (ref))\n            g_print (_(\"\\nInfo: runtime %s%s%s branch %s%s%s is end-of-life, with reason:\\n\"),\n                     on, ref_name, off, on, ref_branch, off);\n          else\n            g_print (_(\"\\nInfo: app %s%s%s branch %s%s%s is end-of-life, with reason:\\n\"),\n                     on, ref_name, off, on, ref_branch, off);\n        }\n      g_print (\"   %s\\n\", reason);\n    }\n}\n\nstatic void\ncheck_current_transaction_for_dependent_apps (GPtrArray          *apps,\n                                              FlatpakTransaction *transaction,\n                                              FlatpakDecomposed  *ref)\n{\n  g_autoptr(FlatpakTransactionOperation) ref_op = NULL;\n  GPtrArray *related_ops;\n\n  ref_op = flatpak_transaction_get_operation_for_ref (transaction, NULL, flatpak_decomposed_get_ref (ref), NULL);\n  g_assert (ref_op != NULL);\n\n  /* Get the related ops to find any apps that use @ref as a runtime or extension */\n  related_ops = flatpak_transaction_operation_get_related_to_ops (ref_op);\n  if (related_ops == NULL)\n    return;\n\n  for (int i = 0; i < related_ops->len; i++)\n    {\n      FlatpakTransactionOperation *related_op = g_ptr_array_index (related_ops, i);\n      const char *related_op_ref = flatpak_transaction_operation_get_ref (related_op);\n      g_autoptr(FlatpakDecomposed) related_op_decomposed = flatpak_decomposed_new_from_ref (related_op_ref, NULL);\n\n      if (related_op_decomposed == NULL)\n        continue;\n      if (flatpak_decomposed_id_is_subref (related_op_decomposed))\n        continue;\n\n      /* Recurse in case @ref was a runtime extension. We need to check since a\n       * runtime can have a runtime extension in its related ops in the\n       * extra-data case, so if we recurse unconditionally it could be infinite\n       * recursion.\n       */\n      if (flatpak_decomposed_is_runtime (related_op_decomposed))\n        {\n          GKeyFile *metadata = flatpak_transaction_operation_get_metadata (ref_op);\n          if (g_key_file_has_group (metadata, FLATPAK_METADATA_GROUP_EXTENSION_OF))\n            check_current_transaction_for_dependent_apps (apps, transaction, related_op_decomposed);\n        }\n      else if (!g_ptr_array_find_with_equal_func (apps, related_op_decomposed, (GEqualFunc)flatpak_decomposed_equal, NULL))\n        g_ptr_array_add (apps, g_steal_pointer (&related_op_decomposed));\n    }\n}\n\nstatic GPtrArray *\nfind_reverse_dep_apps (FlatpakTransaction *transaction,\n                       FlatpakDir         *dir,\n                       FlatpakDecomposed  *ref,\n                       gboolean           *out_is_extension)\n{\n  FlatpakCliTransaction *self = FLATPAK_CLI_TRANSACTION (transaction);\n  g_autoptr(GPtrArray) apps = NULL;\n  g_autoptr(GError) local_error = NULL;\n\n  g_assert (out_is_extension);\n\n  *out_is_extension = flatpak_dir_is_runtime_extension (dir, ref);\n  if (*out_is_extension)\n    {\n      /* Find apps which are using the ref as an extension directly or as an\n       * extension of their runtime.\n       */\n      apps = flatpak_dir_list_app_refs_with_runtime_extension (dir,\n                                                               &self->runtime_app_map,\n                                                               &self->extension_app_map,\n                                                               ref, NULL, &local_error);\n      if (apps == NULL)\n        {\n          g_info (\"Unable to list apps using extension %s: %s\\n\",\n                  flatpak_decomposed_get_ref (ref), local_error->message);\n          return NULL;\n        }\n    }\n  else\n    {\n      /* Find any apps using the runtime directly */\n      apps = flatpak_dir_list_app_refs_with_runtime (dir, &self->runtime_app_map, ref,\n                                                     NULL, &local_error);\n      if (apps == NULL)\n        {\n          g_info (\"Unable to find apps using runtime %s: %s\\n\",\n                  flatpak_decomposed_get_ref (ref), local_error->message);\n          return NULL;\n        }\n    }\n\n  /* Also check the current transaction since it's possible the EOL ref\n   * and/or any app(s) that depend on it are not installed. It's also\n   * possible the current transaction updates one of the apps to a\n   * newer runtime but we don't handle that yet\n   * (https://github.com/flatpak/flatpak/issues/4832)\n   */\n  check_current_transaction_for_dependent_apps (apps, transaction, ref);\n\n  return g_steal_pointer (&apps);\n}\n\nstatic gboolean\nend_of_lifed_with_rebase (FlatpakTransaction *transaction,\n                          const char         *remote,\n                          const char         *ref_str,\n                          const char         *reason,\n                          const char         *rebased_to_ref,\n                          const char        **previous_ids)\n{\n  FlatpakCliTransaction *self = FLATPAK_CLI_TRANSACTION (transaction);\n  g_autoptr(FlatpakDecomposed) ref = flatpak_decomposed_new_from_ref (ref_str, NULL);\n  g_autofree char *name = NULL;\n  EolAction action = EOL_UNDECIDED;\n  EolAction old_action = EOL_UNDECIDED;\n  gboolean can_rebase = rebased_to_ref != NULL && remote != NULL;\n  FlatpakInstallation *installation = flatpak_transaction_get_installation (transaction);\n  FlatpakDir *dir = flatpak_installation_get_dir (installation, NULL);\n\n  if (ref == NULL)\n    return FALSE; /* Shouldn't happen, the ref should be valid */\n\n  name = flatpak_decomposed_dup_id (ref);\n\n  self->did_interaction = TRUE;\n\n  if (flatpak_decomposed_id_is_subref (ref))\n    {\n      GLNX_HASH_TABLE_FOREACH_KV (self->eol_actions, FlatpakDecomposed *, eoled_ref, gpointer, value)\n        {\n          guint old_eol_action = GPOINTER_TO_UINT (value);\n\n          if (flatpak_decomposed_id_is_subref_of (ref, eoled_ref))\n              {\n                old_action = old_eol_action; /* Do the same */\n                break;\n              }\n        }\n    }\n\n  if (old_action != EOL_UNDECIDED)\n    {\n      switch (old_action)\n        {\n        default:\n        case EOL_IGNORE:\n          if (!can_rebase)\n            action = EOL_IGNORE;\n          /* Else, ask if we want to rebase */\n          break;\n        case EOL_REBASE:\n        case EOL_NO_REBASE:\n          if (can_rebase)\n            action = old_action;\n          else\n            action = EOL_IGNORE;\n        }\n    }\n\n  if (action == EOL_UNDECIDED)\n    {\n      action = EOL_IGNORE;\n\n      print_eol_info_message (dir, ref, name, rebased_to_ref, reason);\n\n      if (flatpak_decomposed_is_runtime (ref) && !rebased_to_ref)\n        {\n          gboolean is_extension;\n          g_autoptr(GPtrArray) apps = find_reverse_dep_apps (transaction, dir, ref, &is_extension);\n\n          if (apps && apps->len > 0)\n            {\n              if (is_extension)\n                g_print (_(\"Info: applications using this extension:\\n\"));\n              else\n                g_print (_(\"Info: applications using this runtime:\\n\"));\n\n              g_print (\"   \");\n              for (guint i = 0; i < apps->len; i++)\n                {\n                  FlatpakDecomposed *app_ref = g_ptr_array_index (apps, i);\n                  g_autofree char *id = flatpak_decomposed_dup_id (app_ref);\n                  if (i != 0)\n                    g_print (\", \");\n                  g_print (\"%s\", id);\n                }\n              g_print (\"\\n\");\n            }\n        }\n\n      if (rebased_to_ref && remote)\n        {\n          /* The context for this prompt is in print_eol_info_message() */\n          if (self->disable_interaction ||\n              flatpak_yes_no_prompt (TRUE, _(\"Replace?\")))\n            {\n              if (self->disable_interaction)\n                g_print (_(\"Updating to rebased version\\n\"));\n\n              action = EOL_REBASE;\n            }\n          else\n            action = EOL_NO_REBASE;\n        }\n    }\n  else\n    {\n      g_info (\"%s is end-of-life, using action from parent ref\", name);\n    }\n\n  /* Cache for later comparison and reuse */\n  g_hash_table_insert (self->eol_actions, flatpak_decomposed_ref (ref), GUINT_TO_POINTER (action));\n\n  if (action == EOL_REBASE)\n    {\n      g_autoptr(GError) error = NULL;\n\n      if (!flatpak_transaction_add_rebase (transaction, remote, rebased_to_ref, NULL, previous_ids, &error))\n        {\n          g_propagate_prefixed_error (&self->first_operation_error,\n                                      g_error_copy (error),\n                                      _(\"Failed to rebase %s to %s: \"),\n                                      name, rebased_to_ref);\n          return FALSE;\n        }\n\n      if (!flatpak_transaction_add_uninstall (transaction, ref_str, &error))\n        {\n          /* NOT_INSTALLED error is expected in case the op that triggered this was install not update */\n          if (g_error_matches (error, FLATPAK_ERROR, FLATPAK_ERROR_NOT_INSTALLED))\n            g_clear_error (&error);\n          else\n            {\n              g_propagate_prefixed_error (&self->first_operation_error,\n                                          g_error_copy (error),\n                                          _(\"Failed to uninstall %s for rebase to %s: \"),\n                                          name, rebased_to_ref);\n              return FALSE;\n            }\n        }\n\n      return TRUE; /* skip install/update op of end-of-life ref */\n    }\n  else /* IGNORE or NO_REBASE */\n    return FALSE;\n}\n\nstatic int\ncmpstringp (const void *p1, const void *p2)\n{\n  return strcmp (*(char * const *) p1, *(char * const *) p2);\n}\n\nstatic void\nappend_permissions (GPtrArray  *permissions,\n                    GKeyFile   *metadata,\n                    GKeyFile   *old_metadata,\n                    const char *group)\n{\n  g_auto(GStrv) options = g_key_file_get_string_list (metadata, FLATPAK_METADATA_GROUP_CONTEXT, group, NULL, NULL);\n  g_auto(GStrv) old_options = NULL;\n  int i;\n\n  if (options == NULL)\n    return;\n\n  qsort (options, g_strv_length (options), sizeof (const char *), cmpstringp);\n\n  if (old_metadata)\n    old_options = g_key_file_get_string_list (old_metadata, FLATPAK_METADATA_GROUP_CONTEXT, group, NULL, NULL);\n\n  for (i = 0; options[i] != NULL; i++)\n    {\n      const char *option = options[i];\n      if (option[0] == '!')\n        continue;\n\n      if (old_options && g_strv_contains ((const char * const *) old_options, option))\n        continue;\n\n      if (strcmp (group, FLATPAK_METADATA_KEY_DEVICES) == 0 && strcmp (option, \"all\") == 0)\n        option = \"devices\";\n\n      g_ptr_array_add (permissions, g_strdup (option));\n    }\n}\n\nstatic void\nappend_bus (GPtrArray  *talk,\n            GPtrArray  *own,\n            GKeyFile   *metadata,\n            GKeyFile   *old_metadata,\n            const char *group)\n{\n  g_auto(GStrv) keys = NULL;\n  gsize i, keys_count;\n\n  keys = g_key_file_get_keys (metadata, group, &keys_count, NULL);\n  if (keys == NULL)\n    return;\n\n  qsort (keys, g_strv_length (keys), sizeof (const char *), cmpstringp);\n\n  for (i = 0; i < keys_count; i++)\n    {\n      const char *key = keys[i];\n      g_autofree char *value = g_key_file_get_string (metadata, group, key, NULL);\n\n      if (g_strcmp0 (value, \"none\") == 0)\n        continue;\n\n      if (old_metadata)\n        {\n          g_autofree char *old_value = g_key_file_get_string (old_metadata, group, key, NULL);\n          if (g_strcmp0 (old_value, value) == 0)\n            continue;\n        }\n\n      if (g_strcmp0 (value, \"own\") == 0)\n        g_ptr_array_add (own, g_strdup (key));\n      else\n        g_ptr_array_add (talk, g_strdup (key));\n    }\n}\n\nstatic void\nappend_tags (GPtrArray *tags_array,\n             GKeyFile  *metadata,\n             GKeyFile  *old_metadata)\n{\n  gsize i, size = 0;\n  g_auto(GStrv) tags = g_key_file_get_string_list (metadata, FLATPAK_METADATA_GROUP_APPLICATION, \"tags\",\n                                                   &size, NULL);\n  g_auto(GStrv) old_tags = NULL;\n\n  if (old_metadata)\n    old_tags = g_key_file_get_string_list (old_metadata, FLATPAK_METADATA_GROUP_APPLICATION, \"tags\",\n                                           NULL, NULL);\n\n  for (i = 0; i < size; i++)\n    {\n      const char *tag = tags[i];\n      if (old_tags == NULL || !g_strv_contains ((const char * const *) old_tags, tag))\n        g_ptr_array_add (tags_array, g_strdup (tag));\n    }\n}\n\nstatic void\nprint_perm_line (int        idx,\n                 GPtrArray *items,\n                 int        cols)\n{\n  g_autoptr(GString) res = g_string_new (NULL);\n  g_autofree char *escaped_first_perm = NULL;\n  int i;\n\n  escaped_first_perm = flatpak_escape_string (items->pdata[0], FLATPAK_ESCAPE_DEFAULT);\n  g_string_append_printf (res, \"    [%d] %s\", idx, escaped_first_perm);\n\n  for (i = 1; i < items->len; i++)\n    {\n      g_autofree char *escaped = flatpak_escape_string (items->pdata[i],\n                                                        FLATPAK_ESCAPE_DEFAULT);\n      char *p;\n      int len;\n\n      p = strrchr (res->str, '\\n');\n      if (!p)\n        p = res->str;\n\n      len = (res->str + strlen (res->str)) - p;\n      if (len + strlen (escaped) + 2 >= cols)\n        g_string_append_printf (res, \",\\n        %s\", escaped);\n      else\n        g_string_append_printf (res, \", %s\", escaped);\n    }\n\n  g_print (\"%s\\n\", res->str);\n}\n\nstatic void\nprint_permissions (FlatpakCliTransaction *self,\n                   const char            *ref,\n                   GKeyFile              *metadata,\n                   GKeyFile              *old_metadata)\n{\n  g_autoptr(FlatpakRef) rref = flatpak_ref_parse (ref, NULL);\n  g_autoptr(GPtrArray) permissions = g_ptr_array_new_with_free_func (g_free);\n  g_autoptr(GPtrArray) files = g_ptr_array_new_with_free_func (g_free);\n  g_autoptr(GPtrArray) session_bus_talk = g_ptr_array_new_with_free_func (g_free);\n  g_autoptr(GPtrArray) session_bus_own = g_ptr_array_new_with_free_func (g_free);\n  g_autoptr(GPtrArray) system_bus_talk = g_ptr_array_new_with_free_func (g_free);\n  g_autoptr(GPtrArray) system_bus_own = g_ptr_array_new_with_free_func (g_free);\n  g_autoptr(GPtrArray) tags = g_ptr_array_new_with_free_func (g_free);\n  g_autoptr(FlatpakTablePrinter) printer = NULL;\n  int max_permission_width;\n  int n_permission_cols;\n  int i, j;\n  int rows, cols;\n  int table_rows, table_cols;\n  const char *on = \"\";\n  const char *off = \"\";\n\n  if (flatpak_fancy_output ())\n    {\n      on = FLATPAK_ANSI_BOLD_ON;\n      off = FLATPAK_ANSI_BOLD_OFF;\n    }\n\n  if (metadata == NULL)\n    return;\n\n  /* Only apps have permissions */\n  if (flatpak_ref_get_kind (rref) != FLATPAK_REF_KIND_APP)\n    return;\n\n  append_permissions (permissions, metadata, old_metadata, FLATPAK_METADATA_KEY_SHARED);\n  append_permissions (permissions, metadata, old_metadata, FLATPAK_METADATA_KEY_SOCKETS);\n  append_permissions (permissions, metadata, old_metadata, FLATPAK_METADATA_KEY_DEVICES);\n  append_permissions (permissions, metadata, old_metadata, FLATPAK_METADATA_KEY_FEATURES);\n  append_permissions (files, metadata, old_metadata, FLATPAK_METADATA_KEY_FILESYSTEMS);\n  append_bus (session_bus_talk, session_bus_own,\n              metadata, old_metadata, FLATPAK_METADATA_GROUP_SESSION_BUS_POLICY);\n  append_bus (system_bus_talk, system_bus_own,\n              metadata, old_metadata, FLATPAK_METADATA_GROUP_SYSTEM_BUS_POLICY);\n  append_tags (tags, metadata, old_metadata);\n\n  j = 1;\n  if (files->len > 0)\n    g_ptr_array_add (permissions, g_strdup_printf (\"file access [%d]\", j++));\n  if (session_bus_talk->len > 0)\n    g_ptr_array_add (permissions, g_strdup_printf (\"dbus access [%d]\", j++));\n  if (session_bus_own->len > 0)\n    g_ptr_array_add (permissions, g_strdup_printf (\"bus ownership [%d]\", j++));\n  if (system_bus_talk->len > 0)\n    g_ptr_array_add (permissions, g_strdup_printf (\"system dbus access [%d]\", j++));\n  if (system_bus_own->len > 0)\n    g_ptr_array_add (permissions, g_strdup_printf (\"system bus ownership [%d]\", j++));\n  if (tags->len > 0)\n    g_ptr_array_add (permissions, g_strdup_printf (\"tags [%d]\", j++));\n\n  /* Early exit if no (or no new) permissions */\n  if (permissions->len == 0)\n    return;\n\n  g_print (\"\\n\");\n\n  if (old_metadata)\n    g_print (_(\"New %s%s%s permissions:\"), on, flatpak_ref_get_name (rref), off);\n  else\n    g_print (_(\"%s%s%s permissions:\"), on, flatpak_ref_get_name (rref), off);\n\n  g_print (\"\\n\");\n\n  flatpak_get_window_size (&rows, &cols);\n  max_permission_width = 0;\n  for (i = 0; i < permissions->len; i++)\n    max_permission_width = MAX (max_permission_width, strlen (g_ptr_array_index (permissions, i)));\n\n  /* At least 4 columns, but more if we're guaranteed to fit */\n  n_permission_cols =  MAX (4, cols / (max_permission_width + 4));\n\n  printer = flatpak_table_printer_new ();\n  for (i = 0; i < permissions->len; i++)\n    {\n      char *perm = g_ptr_array_index (permissions, i);\n      if (i % n_permission_cols == 0)\n        {\n          g_autofree char *text = NULL;\n\n          if (i > 0)\n            flatpak_table_printer_finish_row (printer);\n\n          text = g_strdup_printf (\"    %s\", perm);\n          flatpak_table_printer_add_column (printer, text);\n        }\n      else\n        flatpak_table_printer_add_column (printer, perm);\n    }\n  flatpak_table_printer_finish_row (printer);\n\n  for (i = 0; i < n_permission_cols; i++)\n    flatpak_table_printer_set_column_expand (printer, i, TRUE);\n\n  flatpak_table_printer_print_full (printer, 0, cols, &table_rows, &table_cols);\n\n  g_print (\"\\n\\n\");\n\n  j = 1;\n  if (files->len > 0)\n    print_perm_line (j++, files, cols);\n  if (session_bus_talk->len > 0)\n    print_perm_line (j++, session_bus_talk, cols);\n  if (session_bus_own->len > 0)\n    print_perm_line (j++, session_bus_own, cols);\n  if (system_bus_talk->len > 0)\n    print_perm_line (j++, system_bus_talk, cols);\n  if (system_bus_own->len > 0)\n    print_perm_line (j++, system_bus_own, cols);\n  if (tags->len > 0)\n    print_perm_line (j++, tags, cols);\n}\n\nstatic void\nmessage_handler (const gchar   *log_domain,\n                 GLogLevelFlags log_level,\n                 const gchar   *message,\n                 gpointer       user_data)\n{\n  FlatpakCliTransaction *self = FLATPAK_CLI_TRANSACTION (user_data);\n  g_autofree char *text = NULL;\n\n  text = g_strconcat (_(\"Warning: \"), message, NULL);\n\n  if (flatpak_fancy_output ())\n    {\n      flatpak_table_printer_set_cell (self->printer, self->progress_row, 0, text);\n      self->progress_row++;\n      flatpak_table_printer_add_span (self->printer, \"\");\n      flatpak_table_printer_finish_row (self->printer);\n      redraw (self);\n    }\n  else\n    g_print (\"%s\\n\", text);\n}\n\nstatic gboolean\ntransaction_ready_pre_auth (FlatpakTransaction *transaction)\n{\n  FlatpakCliTransaction *self = FLATPAK_CLI_TRANSACTION (transaction);\n  GList *ops = flatpak_transaction_get_operations (transaction);\n  GList *l;\n  int i;\n  FlatpakTablePrinter *printer;\n  const char *op_shorthand[] = { \"i\", \"u\", \"i\", \"r\" };\n\n  /* These caches may no longer be valid once the transaction runs */\n  g_clear_pointer (&self->runtime_app_map, g_hash_table_unref);\n  g_clear_pointer (&self->extension_app_map, g_hash_table_unref);\n\n  if (ops == NULL)\n    return TRUE;\n\n  self->n_ops = g_list_length (ops);\n\n  for (l = ops; l != NULL; l = l->next)\n    {\n      FlatpakTransactionOperation *op = l->data;\n      FlatpakTransactionOperationType type = flatpak_transaction_operation_get_operation_type (op);\n\n      switch (type)\n        {\n        case FLATPAK_TRANSACTION_OPERATION_UNINSTALL:\n          self->uninstalling = TRUE;\n          break;\n\n        case FLATPAK_TRANSACTION_OPERATION_INSTALL:\n        case FLATPAK_TRANSACTION_OPERATION_INSTALL_BUNDLE:\n          self->installing = TRUE;\n          break;\n\n        case FLATPAK_TRANSACTION_OPERATION_UPDATE:\n          self->updating = TRUE;\n          break;\n\n        default:;\n        }\n    }\n\n  /* first, show permissions */\n  for (l = ops; l != NULL; l = l->next)\n    {\n      FlatpakTransactionOperation *op = l->data;\n      FlatpakTransactionOperationType type = flatpak_transaction_operation_get_operation_type (op);\n\n      if (type == FLATPAK_TRANSACTION_OPERATION_INSTALL ||\n          type == FLATPAK_TRANSACTION_OPERATION_INSTALL_BUNDLE ||\n          type == FLATPAK_TRANSACTION_OPERATION_UPDATE)\n        {\n          const char *ref = flatpak_transaction_operation_get_ref (op);\n          GKeyFile *metadata = flatpak_transaction_operation_get_metadata (op);\n          GKeyFile *old_metadata = flatpak_transaction_operation_get_old_metadata (op);\n\n          print_permissions (self, ref, metadata, old_metadata);\n        }\n    }\n\n  g_print (\"\\n\");\n\n  printer = self->printer = flatpak_table_printer_new ();\n  i = 0;\n\n  flatpak_table_printer_set_column_title (printer, i++, \"   \");\n  flatpak_table_printer_set_column_title (printer, i++, \"   \");\n\n  flatpak_table_printer_set_column_expand (printer, i, TRUE);\n  flatpak_table_printer_set_column_title (printer, i++, _(\"ID\"));\n\n  flatpak_table_printer_set_column_expand (printer, i, TRUE);\n  if (!self->non_default_arch)\n    {\n      flatpak_table_printer_set_column_skip_unique (printer, i, TRUE);\n      flatpak_table_printer_set_column_skip_unique_string (printer, i, flatpak_get_arch ());\n    }\n  flatpak_table_printer_set_column_title (printer, i++, _(\"Arch\"));\n\n  flatpak_table_printer_set_column_expand (printer, i, TRUE);\n  flatpak_table_printer_set_column_title (printer, i++, _(\"Branch\"));\n\n  flatpak_table_printer_set_column_expand (printer, i, TRUE);\n  /* translators: This is short for operation, the title of a one-char column */\n  flatpak_table_printer_set_column_title (printer, i++, _(\"Op\"));\n\n  if (self->installing || self->updating)\n    {\n      g_autofree char *text1 = NULL;\n      g_autofree char *text2 = NULL;\n      g_autofree char *text = NULL;\n      int size;\n\n      flatpak_table_printer_set_column_expand (printer, i, TRUE);\n      flatpak_table_printer_set_column_title (printer, i++, _(\"Remote\"));\n      self->download_col = i;\n\n      /* Avoid resizing the download column too much,\n       * by making the title as long as typical content\n       */\n      text1 = g_strdup_printf (\"< 999.9 kB (%s)\", _(\"partial\"));\n      text2 = g_strdup_printf (\"  123.4 MB / 999.9 MB\");\n      size = MAX (strlen (text1), strlen (text2));\n      text = g_strdup_printf (\"%-*s\", size, _(\"Download\"));\n      flatpak_table_printer_set_column_title (printer, i++, text);\n    }\n\n  for (l = ops, i = 1; l != NULL; l = l->next, i++)\n    {\n      FlatpakTransactionOperation *op = l->data;\n      FlatpakTransactionOperationType type = flatpak_transaction_operation_get_operation_type (op);\n      FlatpakDecomposed *ref = flatpak_transaction_operation_get_decomposed (op);\n      const char *remote = flatpak_transaction_operation_get_remote (op);\n      g_autofree char *id = flatpak_decomposed_dup_id (ref);\n      const char *branch = flatpak_decomposed_get_branch (ref);\n      g_autofree char *arch = flatpak_decomposed_dup_arch (ref);\n      g_autofree char *rownum = g_strdup_printf (\"%2d.\", i);\n\n      flatpak_table_printer_add_column (printer, rownum);\n      flatpak_table_printer_add_column (printer, \"   \");\n      flatpak_table_printer_add_column (printer, id);\n      flatpak_table_printer_add_column (printer, arch);\n      flatpak_table_printer_add_column (printer, branch);\n      flatpak_table_printer_add_column (printer, op_shorthand[type]);\n\n      if (type == FLATPAK_TRANSACTION_OPERATION_INSTALL ||\n          type == FLATPAK_TRANSACTION_OPERATION_INSTALL_BUNDLE ||\n          type == FLATPAK_TRANSACTION_OPERATION_UPDATE)\n        {\n          guint64 download_size;\n          g_autofree char *formatted = NULL;\n          g_autofree char *text = NULL;\n          const char *prefix;\n\n          download_size = flatpak_transaction_operation_get_download_size (op);\n          formatted = g_format_size (download_size);\n\n          if (download_size > 0)\n            prefix = \"< \";\n          else\n            prefix = \"\";\n\n          flatpak_table_printer_add_column (printer, remote);\n          if (flatpak_transaction_operation_get_subpaths (op) != NULL)\n            text = g_strdup_printf (\"%s%s (%s)\", prefix, formatted, _(\"partial\"));\n          else\n            text = g_strdup_printf (\"%s%s\", prefix, formatted);\n          flatpak_table_printer_add_decimal_column (printer, text);\n        }\n\n      g_object_set_data (G_OBJECT (op), \"row\", GINT_TO_POINTER (flatpak_table_printer_get_current_row (printer)));\n      flatpak_table_printer_finish_row (printer);\n    }\n\n  flatpak_get_window_size (&self->rows, &self->cols);\n\n  g_print (\"\\n\");\n\n  flatpak_table_printer_print_full (printer, 0, self->cols,\n                                    &self->table_height, &self->table_width);\n\n  g_print (\"\\n\");\n\n  if (!self->disable_interaction)\n    {\n      g_autoptr(FlatpakInstallation) installation = flatpak_transaction_get_installation (transaction);\n      const char *name;\n      const char *id;\n      gboolean ret;\n\n      g_print (\"\\n\");\n\n      name = flatpak_installation_get_display_name (installation);\n      id = flatpak_installation_get_id (installation);\n\n      if (flatpak_installation_get_is_user (installation))\n        ret = flatpak_yes_no_prompt (TRUE, _(\"Proceed with these changes to the user installation?\"));\n      else if (g_strcmp0 (id, SYSTEM_DIR_DEFAULT_ID) == 0)\n        ret = flatpak_yes_no_prompt (TRUE, _(\"Proceed with these changes to the system installation?\"));\n      else\n        ret = flatpak_yes_no_prompt (TRUE, _(\"Proceed with these changes to the %s?\"), name);\n\n      if (!ret)\n        {\n          g_list_free_full (ops, g_object_unref);\n          return FALSE;\n        }\n    }\n  else\n    g_print (\"\\n\\n\");\n\n  self->did_interaction = FALSE;\n\n  return TRUE;\n}\n\nstatic gboolean\ntransaction_ready (FlatpakTransaction *transaction)\n{\n  FlatpakCliTransaction *self = FLATPAK_CLI_TRANSACTION (transaction);\n  GList *ops = flatpak_transaction_get_operations (transaction);\n  GList *l;\n  FlatpakTablePrinter *printer;\n\n  if (ops == NULL)\n    return TRUE;\n\n  printer = self->printer;\n\n  if (self->did_interaction)\n    {\n      /* We did some interaction since ready_pre_auth which messes up the formating, so re-print table */\n      flatpak_table_printer_print_full (printer, 0, self->cols,\n                                        &self->table_height, &self->table_width);\n      g_print (\"\\n\\n\");\n    }\n\n  for (l = ops; l; l = l->next)\n    {\n      FlatpakTransactionOperation *op = l->data;\n      set_op_progress (self, op, \" \");\n    }\n\n  g_list_free_full (ops, g_object_unref);\n\n  flatpak_table_printer_add_span (printer, \"\");\n  flatpak_table_printer_finish_row (printer);\n  flatpak_table_printer_add_span (printer, \"\");\n  self->progress_row = flatpak_table_printer_get_current_row (printer);\n  flatpak_table_printer_finish_row (printer);\n\n  self->table_height += 3; /* 2 for the added lines and one for the newline from the user after the prompt */\n\n  if (flatpak_fancy_output ())\n    {\n      flatpak_hide_cursor ();\n      flatpak_enable_raw_mode ();\n      redraw (self);\n    }\n\n  g_log_set_handler (G_LOG_DOMAIN, G_LOG_LEVEL_MESSAGE | G_LOG_LEVEL_WARNING, message_handler, transaction);\n\n  return TRUE;\n}\n\nstatic void\nflatpak_cli_transaction_finalize (GObject *object)\n{\n  FlatpakCliTransaction *self = FLATPAK_CLI_TRANSACTION (object);\n\n  if (self->first_operation_error)\n    g_error_free (self->first_operation_error);\n\n  g_free (self->progress_msg);\n\n  g_hash_table_unref (self->eol_actions);\n\n  if (self->runtime_app_map)\n    g_hash_table_unref (self->runtime_app_map);\n\n  if (self->extension_app_map)\n    g_hash_table_unref (self->extension_app_map);\n\n  if (self->printer)\n    flatpak_table_printer_free (self->printer);\n\n  G_OBJECT_CLASS (flatpak_cli_transaction_parent_class)->finalize (object);\n}\n\nstatic void\nflatpak_cli_transaction_init (FlatpakCliTransaction *self)\n{\n  self->eol_actions = g_hash_table_new_full ((GHashFunc)flatpak_decomposed_hash, (GEqualFunc)flatpak_decomposed_equal,\n                                             (GDestroyNotify)flatpak_decomposed_unref, NULL);\n}\n\nstatic gboolean flatpak_cli_transaction_run (FlatpakTransaction *transaction,\n                                             GCancellable       *cancellable,\n                                             GError            **error);\n\nstatic void\nflatpak_cli_transaction_class_init (FlatpakCliTransactionClass *klass)\n{\n  GObjectClass *object_class = G_OBJECT_CLASS (klass);\n  FlatpakTransactionClass *transaction_class = FLATPAK_TRANSACTION_CLASS (klass);\n\n  object_class->finalize = flatpak_cli_transaction_finalize;\n  transaction_class->add_new_remote = add_new_remote;\n  transaction_class->ready = transaction_ready;\n  transaction_class->ready_pre_auth = transaction_ready_pre_auth;\n  transaction_class->new_operation = new_operation;\n  transaction_class->operation_done = operation_done;\n  transaction_class->operation_error = operation_error;\n  transaction_class->choose_remote_for_ref = choose_remote_for_ref;\n  transaction_class->end_of_lifed_with_rebase = end_of_lifed_with_rebase;\n  transaction_class->run = flatpak_cli_transaction_run;\n  transaction_class->webflow_start = webflow_start;\n  transaction_class->webflow_done = webflow_done;\n  transaction_class->basic_auth_start = basic_auth_start;\n  transaction_class->install_authenticator = install_authenticator;\n}\n\nFlatpakTransaction *\nflatpak_cli_transaction_new (FlatpakDir *dir,\n                             gboolean    disable_interaction,\n                             gboolean    stop_on_first_error,\n                             gboolean    non_default_arch,\n                             GError    **error)\n{\n  g_autoptr(FlatpakInstallation) installation = NULL;\n  g_autoptr(FlatpakCliTransaction) self = NULL;\n\n  installation = flatpak_installation_new_for_dir (dir, NULL, error);\n  if (installation == NULL)\n    return NULL;\n\n  self = g_initable_new (FLATPAK_TYPE_CLI_TRANSACTION,\n                         NULL, error,\n                         \"installation\", installation,\n                         NULL);\n  if (self == NULL)\n    return NULL;\n\n  self->disable_interaction = disable_interaction;\n  self->stop_on_first_error = stop_on_first_error;\n  self->non_default_arch = non_default_arch;\n\n  flatpak_transaction_set_no_interaction (FLATPAK_TRANSACTION (self), disable_interaction);\n  flatpak_transaction_add_default_dependency_sources (FLATPAK_TRANSACTION (self));\n\n  return (FlatpakTransaction *) g_steal_pointer (&self);\n}\n\nstatic gboolean\nflatpak_cli_transaction_run (FlatpakTransaction *transaction,\n                             GCancellable       *cancellable,\n                             GError            **error)\n{\n  FlatpakCliTransaction *self = FLATPAK_CLI_TRANSACTION (transaction);\n  gboolean res;\n\n  res = FLATPAK_TRANSACTION_CLASS (flatpak_cli_transaction_parent_class)->run (transaction, cancellable, error);\n\n  if (flatpak_fancy_output ())\n    {\n      flatpak_disable_raw_mode ();\n      flatpak_show_cursor ();\n    }\n\n  if (res && self->n_ops > 0)\n    {\n      const char *text;\n\n      if (self->uninstalling + self->installing + self->updating > 1)\n        text = _(\"Changes complete.\");\n      else if (self->uninstalling)\n        text = _(\"Uninstall complete.\");\n      else if (self->installing)\n        text = _(\"Installation complete.\");\n      else\n        text = _(\"Updates complete.\");\n\n      if (flatpak_fancy_output ())\n        {\n          set_progress (self, text);\n          redraw (self);\n        }\n      else\n        g_print (\"%s\", text);\n\n      g_print (\"\\n\");\n    }\n\n  if (self->first_operation_error)\n    {\n      g_clear_error (error);\n\n      /* We always want to return an error if there was some kind of operation error,\n         as that causes the main CLI to return an error status. */\n\n      if (self->stop_on_first_error)\n        {\n          /* For the install/stop_on_first_error we return the first operation error,\n             as we have not yet printed it.  */\n\n          g_propagate_error (error, g_steal_pointer (&self->first_operation_error));\n          return FALSE;\n        }\n      else\n        {\n          /* For updates/!stop_on_first_error we already printed all errors so we make up\n             a different one. */\n\n          return flatpak_fail (error, _(\"There were one or more errors\"));\n        }\n    }\n\n  if (!res)\n    return FALSE;\n\n  return TRUE;\n}\n"], "fixing_code": ["/* vi:set et sw=2 sts=2 cin cino=t0,f0,(0,{s,>2s,n-s,^-s,e-s:\n * Copyright \u00a9 2018 Red Hat, Inc\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\t See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library. If not, see <http://www.gnu.org/licenses/>.\n *\n * Authors:\n *       Alexander Larsson <alexl@redhat.com>\n */\n\n#include \"config.h\"\n\n#include \"flatpak-cli-transaction.h\"\n#include \"flatpak-transaction-private.h\"\n#include \"flatpak-installation-private.h\"\n#include \"flatpak-run-private.h\"\n#include \"flatpak-table-printer.h\"\n#include \"flatpak-utils-private.h\"\n#include \"flatpak-error.h\"\n#include <glib/gi18n.h>\n\n\nstruct _FlatpakCliTransaction\n{\n  FlatpakTransaction   parent;\n\n  gboolean             disable_interaction;\n  gboolean             stop_on_first_error;\n  gboolean             non_default_arch;\n  GError              *first_operation_error;\n\n  GHashTable          *eol_actions;\n  GHashTable          *runtime_app_map;\n  GHashTable          *extension_app_map;\n\n  int                  rows;\n  int                  cols;\n  int                  table_width;\n  int                  table_height;\n\n  int                  n_ops;\n  int                  op;\n  int                  op_progress;\n\n  gboolean             installing;\n  gboolean             updating;\n  gboolean             uninstalling;\n\n  int                  download_col;\n\n  FlatpakTablePrinter *printer;\n  int                  progress_row;\n  char                *progress_msg;\n  int                  speed_len;\n\n  gboolean             did_interaction;\n};\n\nstruct _FlatpakCliTransactionClass\n{\n  FlatpakTransactionClass parent_class;\n};\n\nG_DEFINE_TYPE (FlatpakCliTransaction, flatpak_cli_transaction, FLATPAK_TYPE_TRANSACTION);\n\nstatic int\nchoose_remote_for_ref (FlatpakTransaction *transaction,\n                       const char         *for_ref,\n                       const char         *runtime_ref,\n                       const char * const *remotes)\n{\n  FlatpakCliTransaction *self = FLATPAK_CLI_TRANSACTION (transaction);\n  int n_remotes = g_strv_length ((char **) remotes);\n  int chosen = -1;\n  const char *pref;\n\n  pref = strchr (for_ref, '/') + 1;\n\n  self->did_interaction = TRUE;\n\n  if (self->disable_interaction)\n    {\n      g_print (_(\"Required runtime for %s (%s) found in remote %s\\n\"),\n               pref, runtime_ref, remotes[0]);\n      chosen = 0;\n    }\n  else if (n_remotes == 1)\n    {\n      g_print (_(\"Required runtime for %s (%s) found in remote %s\\n\"),\n               pref, runtime_ref, remotes[0]);\n      if (flatpak_yes_no_prompt (TRUE, _(\"Do you want to install it?\")))\n        chosen = 0;\n    }\n  else\n    {\n      flatpak_format_choices ((const char **) remotes,\n                              _(\"Required runtime for %s (%s) found in remotes:\"),\n                              pref, runtime_ref);\n      chosen = flatpak_number_prompt (TRUE, 0, n_remotes, _(\"Which do you want to install (0 to abort)?\"));\n      chosen -= 1; /* convert from base-1 to base-0 (and -1 to abort) */\n    }\n\n  return chosen;\n}\n\nstatic gboolean\nadd_new_remote (FlatpakTransaction            *transaction,\n                FlatpakTransactionRemoteReason reason,\n                const char                    *from_id,\n                const char                    *remote_name,\n                const char                    *url)\n{\n  FlatpakCliTransaction *self = FLATPAK_CLI_TRANSACTION (transaction);\n\n  self->did_interaction = TRUE;\n\n  if (self->disable_interaction)\n    {\n      g_print (_(\"Configuring %s as new remote '%s'\\n\"), url, remote_name);\n      return TRUE;\n    }\n\n  if (reason == FLATPAK_TRANSACTION_REMOTE_GENERIC_REPO)\n    {\n      if (flatpak_yes_no_prompt (TRUE, /* default to yes on Enter */\n                                 _(\"The remote '%s', referred to by '%s' at location %s contains additional applications.\\n\"\n                                   \"Should the remote be kept for future installations?\"),\n                                 remote_name, from_id, url))\n        return TRUE;\n    }\n  else if (reason == FLATPAK_TRANSACTION_REMOTE_RUNTIME_DEPS)\n    {\n      if (flatpak_yes_no_prompt (TRUE, /* default to yes on Enter */\n                                 _(\"The application %s depends on runtimes from:\\n  %s\\n\"\n                                   \"Configure this as new remote '%s'\"),\n                                 from_id, url, remote_name))\n        return TRUE;\n    }\n\n  return FALSE;\n}\n\nstatic void\ninstall_authenticator (FlatpakTransaction            *old_transaction,\n                       const char                    *remote,\n                       const char                    *ref)\n{\n  FlatpakCliTransaction *old_cli = FLATPAK_CLI_TRANSACTION (old_transaction);\n  g_autoptr(FlatpakTransaction)  transaction2 = NULL;\n  g_autoptr(GError) local_error = NULL;\n  FlatpakInstallation *installation = flatpak_transaction_get_installation (old_transaction);\n  FlatpakDir *dir = flatpak_installation_get_dir (installation, NULL);\n\n  if (dir == NULL)\n    {\n      /* This should not happen */\n      g_warning (\"No dir in install_authenticator\");\n      return;\n    }\n\n  old_cli->did_interaction = TRUE;\n\n  transaction2 = flatpak_cli_transaction_new (dir, old_cli->disable_interaction, TRUE, FALSE, &local_error);\n  if (transaction2 == NULL)\n    {\n      g_printerr (\"Unable to install authenticator: %s\\n\", local_error->message);\n      return;\n    }\n\n  g_print (\"Installing required authenticator for remote %s\\n\", remote);\n  if (!flatpak_transaction_add_install (transaction2, remote, ref, NULL, &local_error))\n    {\n      if (!g_error_matches (local_error, FLATPAK_ERROR, FLATPAK_ERROR_ALREADY_INSTALLED))\n        g_printerr (\"Unable to install authenticator: %s\\n\", local_error->message);\n      return;\n    }\n\n  if (!flatpak_transaction_run (transaction2, NULL, &local_error))\n    {\n      if (!g_error_matches (local_error, FLATPAK_ERROR, FLATPAK_ERROR_ABORTED))\n        g_printerr (\"Unable to install authenticator: %s\\n\", local_error->message);\n      return;\n    }\n\n  return;\n}\n\nstatic gboolean\nredraw (FlatpakCliTransaction *self)\n{\n  int top;\n  int row;\n  int current_row;\n  int current_col;\n  int skip;\n\n  /* We may have resized and thus repositioned the cursor since last redraw */\n  flatpak_get_window_size (&self->rows, &self->cols);\n  if (flatpak_get_cursor_pos (&current_row, &current_col))\n    {\n      /* We're currently displaying the last row of the table, extept the\n         very first time where the user pressed return for the prompt causing us\n         to scroll down one extra row */\n      top = current_row - self->table_height + 1;\n      if (top > 0)\n        {\n          row = top;\n          skip = 0;\n        }\n      else\n        {\n          row = 1;\n          skip = 1 - top;\n        }\n\n      g_print (FLATPAK_ANSI_ROW_N FLATPAK_ANSI_CLEAR, row);\n      // we update table_height and end_row here, since we might have added to the table\n      flatpak_table_printer_print_full (self->printer, skip, self->cols,\n                                        &self->table_height, &self->table_width);\n      return TRUE;\n    }\n  return FALSE;\n}\n\nstatic void\nset_op_progress (FlatpakCliTransaction       *self,\n                 FlatpakTransactionOperation *op,\n                 const char                  *progress)\n{\n  if (flatpak_fancy_output ())\n    {\n      int row = GPOINTER_TO_INT (g_object_get_data (G_OBJECT (op), \"row\"));\n      g_autofree char *cell = g_strdup_printf (\"[%s]\", progress);\n      flatpak_table_printer_set_cell (self->printer, row, 1, cell);\n    }\n}\n\nstatic void\nspin_op_progress (FlatpakCliTransaction       *self,\n                  FlatpakTransactionOperation *op)\n{\n  const char *p[] = {\n    \"|\",\n    \"/\",\n    \"\u2014\",\n    \"\\\\\",\n  };\n\n  set_op_progress (self, op, p[self->op_progress++ % G_N_ELEMENTS (p)]);\n}\n\nstatic char *\nformat_duration (guint64 duration)\n{\n  int h, m, s;\n\n  m = duration / 60;\n  s = duration % 60;\n  h = m / 60;\n  m = m % 60;\n\n  if (h > 0)\n    return g_strdup_printf (\"%02d:%02d:%02d\", h, m, s);\n  else\n    return g_strdup_printf (\"%02d:%02d\", m, s);\n}\n\nstatic void\nprogress_changed_cb (FlatpakTransactionProgress *progress,\n                     gpointer                    data)\n{\n  FlatpakCliTransaction *cli = data;\n  FlatpakTransaction *self = FLATPAK_TRANSACTION (cli);\n  g_autoptr(FlatpakTransactionOperation) op = flatpak_transaction_get_current_operation (self);\n  g_autoptr(GString) str = g_string_new (\"\");\n  int i;\n  int n_full, partial;\n  g_autofree char *speed = NULL;\n  int bar_length;\n  const char *partial_blocks[] = {\n    \" \",\n    \"\u258f\",\n    \"\u258e\",\n    \"\u258d\",\n    \"\u258c\",\n    \"\u258b\",\n    \"\u258a\",\n    \"\u2589\",\n  };\n  const char *full_block = \"\u2588\";\n\n  guint percent = flatpak_transaction_progress_get_progress (progress);\n  guint64 start_time = flatpak_transaction_progress_get_start_time (progress);\n  guint64 elapsed_time = (g_get_monotonic_time () - start_time) / G_USEC_PER_SEC;\n  guint64 transferred = flatpak_transaction_progress_get_bytes_transferred (progress);\n  guint64 max = flatpak_transaction_operation_get_download_size (op);\n\n  if (elapsed_time > 0)\n    {\n      g_autofree char *formatted_bytes_sec = g_format_size (transferred / elapsed_time);\n      g_autofree char *remaining = NULL;\n      if (elapsed_time > 3 && percent > 0)\n        {\n          guint64 total_time = elapsed_time * 100 / (double) percent;\n          remaining = format_duration (total_time - elapsed_time);\n        }\n      speed = g_strdup_printf (\"%s/s%s%s\", formatted_bytes_sec, remaining ? \"  \" : \"\", remaining ? remaining : \"\");\n      cli->speed_len = MAX (cli->speed_len, strlen (speed) + 2);\n    }\n\n  spin_op_progress (cli, op);\n\n  bar_length = MIN (20, cli->table_width - (strlen (cli->progress_msg) + 6 + cli->speed_len));\n\n  n_full = (bar_length * percent) / 100;\n  partial = (((bar_length * percent) % 100) * G_N_ELEMENTS (partial_blocks)) / 100;\n  /* The above should guarantee this: */\n  g_assert (partial >= 0);\n  g_assert (partial < G_N_ELEMENTS (partial_blocks));\n\n  g_string_append (str, cli->progress_msg);\n  g_string_append (str, \" \");\n\n  if (flatpak_fancy_output ())\n    g_string_append (str, FLATPAK_ANSI_FAINT_ON);\n\n  for (i = 0; i < n_full; i++)\n    g_string_append (str, full_block);\n\n  if (i < bar_length)\n    {\n      g_string_append (str, partial_blocks[partial]);\n      i++;\n    }\n\n  if (flatpak_fancy_output ())\n    g_string_append (str, FLATPAK_ANSI_FAINT_OFF);\n\n  for (; i < bar_length; i++)\n    g_string_append (str, \" \");\n\n  g_string_append (str, \" \");\n  g_string_append_printf (str, \"%3d%%\", percent);\n\n  if (speed)\n    g_string_append_printf (str, \"  %s\", speed);\n\n  if (flatpak_fancy_output ())\n    {\n      flatpak_table_printer_set_cell (cli->printer, cli->progress_row, 0, str->str);\n      if (flatpak_transaction_operation_get_operation_type (op) != FLATPAK_TRANSACTION_OPERATION_UNINSTALL)\n        {\n          g_autofree char *formatted_max = NULL;\n          g_autofree char *formatted = NULL;\n          g_autofree char *text = NULL;\n          int row;\n\n          // avoid \"bytes\"\n          formatted = transferred < 1000 ? g_format_size (1000) : g_format_size (transferred);\n          formatted_max = max < 1000 ? g_format_size (1000) : g_format_size (max);\n\n          text = g_strdup_printf (\"%s / %s\", formatted, formatted_max);\n          row = GPOINTER_TO_INT (g_object_get_data (G_OBJECT (op), \"row\"));\n          flatpak_table_printer_set_decimal_cell (cli->printer, row, cli->download_col, text);\n        }\n      if (!redraw (cli))\n        g_print (\"\\r%s\", str->str); /* redraw failed, just update the progress */\n    }\n  else\n    g_print (\"%s\\n\", str->str);\n}\n\nstatic void\nset_progress (FlatpakCliTransaction *self,\n              const char            *text)\n{\n  flatpak_table_printer_set_cell (self->printer, self->progress_row, 0, text);\n}\n\nstatic void\nnew_operation (FlatpakTransaction          *transaction,\n               FlatpakTransactionOperation *op,\n               FlatpakTransactionProgress  *progress)\n{\n  FlatpakCliTransaction *self = FLATPAK_CLI_TRANSACTION (transaction);\n  FlatpakTransactionOperationType op_type = flatpak_transaction_operation_get_operation_type (op);\n  g_autofree char *text = NULL;\n\n  self->op++;\n  self->op_progress = 0;\n\n  switch (op_type)\n    {\n    case FLATPAK_TRANSACTION_OPERATION_INSTALL_BUNDLE:\n    case FLATPAK_TRANSACTION_OPERATION_INSTALL:\n      if (self->n_ops == 1)\n        text = g_strdup (_(\"Installing\u2026\"));\n      else\n        text = g_strdup_printf (_(\"Installing %d/%d\u2026\"), self->op, self->n_ops);\n      break;\n\n    case FLATPAK_TRANSACTION_OPERATION_UPDATE:\n      if (self->n_ops == 1)\n        text = g_strdup (_(\"Updating\u2026\"));\n      else\n        text = g_strdup_printf (_(\"Updating %d/%d\u2026\"), self->op, self->n_ops);\n      break;\n\n    case FLATPAK_TRANSACTION_OPERATION_UNINSTALL:\n      if (self->n_ops == 1)\n        text = g_strdup (_(\"Uninstalling\u2026\"));\n      else\n        text = g_strdup_printf (_(\"Uninstalling %d/%d\u2026\"), self->op, self->n_ops);\n      break;\n\n    default:\n      g_assert_not_reached ();\n      break;\n    }\n\n  if (flatpak_fancy_output ())\n    {\n      set_progress (self, text);\n      spin_op_progress (self, op);\n      redraw (self);\n    }\n  else\n    g_print (\"%s\\n\", text);\n\n  g_free (self->progress_msg);\n  self->progress_msg = g_steal_pointer (&text);\n\n  g_signal_connect (progress, \"changed\", G_CALLBACK (progress_changed_cb), self);\n  flatpak_transaction_progress_set_update_frequency (progress, FLATPAK_CLI_UPDATE_INTERVAL_MS);\n}\n\nstatic void\noperation_done (FlatpakTransaction          *transaction,\n                FlatpakTransactionOperation *op,\n                const char                  *commit,\n                FlatpakTransactionResult     details)\n{\n  FlatpakCliTransaction *self = FLATPAK_CLI_TRANSACTION (transaction);\n  FlatpakTransactionOperationType op_type = flatpak_transaction_operation_get_operation_type (op);\n\n  if (op_type == FLATPAK_TRANSACTION_OPERATION_UNINSTALL)\n    set_op_progress (self, op, FLATPAK_ANSI_GREEN \"-\" FLATPAK_ANSI_COLOR_RESET);\n  else\n    set_op_progress (self, op, FLATPAK_ANSI_GREEN \"\u2713\" FLATPAK_ANSI_COLOR_RESET);\n\n  if (flatpak_fancy_output ())\n    redraw (self);\n}\n\nstatic gboolean\noperation_error (FlatpakTransaction            *transaction,\n                 FlatpakTransactionOperation   *op,\n                 const GError                  *error,\n                 FlatpakTransactionErrorDetails detail)\n{\n  FlatpakCliTransaction *self = FLATPAK_CLI_TRANSACTION (transaction);\n  FlatpakTransactionOperationType op_type = flatpak_transaction_operation_get_operation_type (op);\n  const char *ref = flatpak_transaction_operation_get_ref (op);\n  g_autoptr(FlatpakRef) rref = flatpak_ref_parse (ref, NULL);\n  gboolean non_fatal = (detail & FLATPAK_TRANSACTION_ERROR_DETAILS_NON_FATAL) != 0;\n  g_autofree char *text = NULL;\n  const char *on = \"\";\n  const char *off = \"\";\n\n  if (flatpak_fancy_output ())\n    {\n      on = FLATPAK_ANSI_BOLD_ON;\n      off = FLATPAK_ANSI_BOLD_OFF;\n    }\n\n  if (g_error_matches (error, FLATPAK_ERROR, FLATPAK_ERROR_SKIPPED))\n    {\n      set_op_progress (self, op, \"\u237b\");\n      text = g_strdup_printf (_(\"Info: %s was skipped\"), flatpak_ref_get_name (rref));\n      if (flatpak_fancy_output ())\n        {\n          flatpak_table_printer_set_cell (self->printer, self->progress_row, 0, text);\n          self->progress_row++;\n          flatpak_table_printer_add_span (self->printer, \"\");\n          flatpak_table_printer_finish_row (self->printer);\n          redraw (self);\n        }\n      else\n        g_print (\"%s\\n\", text);\n\n      return TRUE;\n    }\n\n  set_op_progress (self, op, \"\u2717\");\n\n  /* Here we go to great lengths not to split the sentences. See\n   * https://wiki.gnome.org/TranslationProject/DevGuidelines/Never%20split%20sentences\n   */\n  if (g_error_matches (error, FLATPAK_ERROR, FLATPAK_ERROR_ALREADY_INSTALLED))\n    {\n      if (non_fatal)\n        text = g_strdup_printf (_(\"Warning: %s%s%s already installed\"),\n                                on, flatpak_ref_get_name (rref), off);\n      else\n        text = g_strdup_printf (_(\"Error: %s%s%s already installed\"),\n                                on, flatpak_ref_get_name (rref), off);\n    }\n  else if (g_error_matches (error, FLATPAK_ERROR, FLATPAK_ERROR_NOT_INSTALLED))\n    {\n      if (non_fatal)\n        text = g_strdup_printf (_(\"Warning: %s%s%s not installed\"),\n                                on, flatpak_ref_get_name (rref), off);\n      else\n        text = g_strdup_printf (_(\"Error: %s%s%s not installed\"),\n                                on, flatpak_ref_get_name (rref), off);\n    }\n  else if (g_error_matches (error, FLATPAK_ERROR, FLATPAK_ERROR_NEED_NEW_FLATPAK))\n    {\n      if (non_fatal)\n        text = g_strdup_printf (_(\"Warning: %s%s%s needs a later flatpak version\"),\n                                on, flatpak_ref_get_name (rref), off);\n      else\n        text = g_strdup_printf (_(\"Error: %s%s%s needs a later flatpak version\"),\n                                on, flatpak_ref_get_name (rref), off);\n    }\n  else if (g_error_matches (error, FLATPAK_ERROR, FLATPAK_ERROR_OUT_OF_SPACE))\n    {\n      if (non_fatal)\n        text = g_strdup (_(\"Warning: Not enough disk space to complete this operation\"));\n      else\n        text = g_strdup (_(\"Error: Not enough disk space to complete this operation\"));\n    }\n  else if (error)\n    {\n      if (non_fatal)\n        text = g_strdup_printf (_(\"Warning: %s\"), error->message);\n      else\n        text = g_strdup_printf (_(\"Error: %s\"), error->message);\n    }\n  else\n    text = g_strdup (\"(internal error, please report)\");\n\n  if (!non_fatal && self->first_operation_error == NULL)\n    {\n      /* Here we go to great lengths not to split the sentences. See\n       * https://wiki.gnome.org/TranslationProject/DevGuidelines/Never%20split%20sentences\n       */\n      switch (op_type)\n        {\n          case FLATPAK_TRANSACTION_OPERATION_INSTALL:\n            g_propagate_prefixed_error (&self->first_operation_error,\n                                        g_error_copy (error),\n                                        _(\"Failed to install %s%s%s: \"),\n                                        on, flatpak_ref_get_name (rref), off);\n            break;\n\n          case FLATPAK_TRANSACTION_OPERATION_UPDATE:\n            g_propagate_prefixed_error (&self->first_operation_error,\n                                        g_error_copy (error),\n                                        _(\"Failed to update %s%s%s: \"),\n                                        on, flatpak_ref_get_name (rref), off);\n            break;\n\n          case FLATPAK_TRANSACTION_OPERATION_INSTALL_BUNDLE:\n            g_propagate_prefixed_error (&self->first_operation_error,\n                                        g_error_copy (error),\n                                        _(\"Failed to install bundle %s%s%s: \"),\n                                        on, flatpak_ref_get_name (rref), off);\n            break;\n\n          case FLATPAK_TRANSACTION_OPERATION_UNINSTALL:\n            g_propagate_prefixed_error (&self->first_operation_error,\n                                        g_error_copy (error),\n                                        _(\"Failed to uninstall %s%s%s: \"),\n                                        on, flatpak_ref_get_name (rref), off);\n            break;\n\n          default:\n            g_assert_not_reached ();\n        }\n    }\n\n  if (flatpak_fancy_output ())\n    {\n      flatpak_table_printer_set_cell (self->printer, self->progress_row, 0, text);\n      self->progress_row++;\n      flatpak_table_printer_add_span (self->printer, \"\");\n      flatpak_table_printer_finish_row (self->printer);\n      redraw (self);\n    }\n  else\n    g_printerr (\"%s\\n\", text);\n\n  if (!non_fatal && self->stop_on_first_error)\n    return FALSE;\n\n  return TRUE; /* Continue */\n}\n\nstatic gboolean\nwebflow_start (FlatpakTransaction *transaction,\n               const char         *remote,\n               const char         *url,\n               GVariant           *options,\n               guint               id)\n{\n  FlatpakCliTransaction *self = FLATPAK_CLI_TRANSACTION (transaction);\n  const char *browser;\n  g_autoptr(GError) local_error = NULL;\n  const char *args[3] = { NULL, url, NULL };\n\n  self->did_interaction = TRUE;\n\n  if (!self->disable_interaction)\n    {\n      g_print (_(\"Authentication required for remote '%s'\\n\"), remote);\n      if (!flatpak_yes_no_prompt (TRUE, _(\"Open browser?\")))\n        return FALSE;\n    }\n\n  /* Allow hard overrides with $BROWSER */\n  browser = g_getenv (\"BROWSER\");\n  if (browser != NULL)\n    {\n      args[0] = browser;\n      if (!g_spawn_async (NULL, (char **)args, NULL, G_SPAWN_SEARCH_PATH,\n                          NULL, NULL, NULL, &local_error))\n        {\n          g_printerr (\"Failed to start browser %s: %s\\n\", browser, local_error->message);\n          return FALSE;\n        }\n    }\n  else\n    {\n      if (!g_app_info_launch_default_for_uri (url, NULL, &local_error))\n        {\n          g_printerr (\"Failed to show url: %s\\n\", local_error->message);\n          return FALSE;\n        }\n    }\n\n  g_print (\"Waiting for browser...\\n\");\n\n  return TRUE;\n}\n\nstatic void\nwebflow_done (FlatpakTransaction *transaction,\n              GVariant           *options,\n              guint               id)\n{\n  g_print (\"Browser done\\n\");\n}\n\nstatic gboolean\nbasic_auth_start (FlatpakTransaction *transaction,\n                  const char         *remote,\n                  const char         *realm,\n                  GVariant           *options,\n                  guint               id)\n{\n  FlatpakCliTransaction *self = FLATPAK_CLI_TRANSACTION (transaction);\n  char *user, *password, *previous_error = NULL;\n\n  if (self->disable_interaction)\n    return FALSE;\n\n  self->did_interaction = TRUE;\n\n  if (g_variant_lookup (options, \"previous-error\", \"&s\", &previous_error))\n    g_print (\"%s\\n\", previous_error);\n\n  g_print (_(\"Login required remote %s (realm %s)\\n\"), remote, realm);\n  user = flatpak_prompt (FALSE, _(\"User\"));\n  if (user == NULL)\n    return FALSE;\n\n  password = flatpak_password_prompt (_(\"Password\"));\n  if (password == NULL)\n    return FALSE;\n\n  flatpak_transaction_complete_basic_auth (transaction, id, user, password, NULL);\n  return TRUE;\n}\n\n\ntypedef enum {\n  EOL_UNDECIDED,\n  EOL_IGNORE,        /* Don't do anything, we already printed a warning */\n  EOL_NO_REBASE,     /* Choose to not rebase */\n  EOL_REBASE,        /* Choose to rebase */\n} EolAction;\n\nstatic void\nprint_eol_info_message (FlatpakDir        *dir,\n                        FlatpakDecomposed *ref,\n                        const char        *ref_name,\n                        const char        *rebased_to_ref,\n                        const char        *reason)\n{\n  gboolean is_pinned = flatpak_dir_ref_is_pinned (dir, flatpak_decomposed_get_ref (ref));\n  g_autofree char *ref_branch = flatpak_decomposed_dup_branch (ref);\n  const char *on = \"\";\n  const char *off = \"\";\n\n  if (flatpak_fancy_output ())\n    {\n      on = FLATPAK_ANSI_BOLD_ON;\n      off = FLATPAK_ANSI_BOLD_OFF;\n    }\n\n  /* Here we go to great lengths not to split the sentences. See\n   * https://wiki.gnome.org/TranslationProject/DevGuidelines/Never%20split%20sentences\n   */\n  if (rebased_to_ref)\n    {\n      g_autoptr(FlatpakDecomposed) eolr_decomposed = NULL;\n      g_autofree char *eolr_name = NULL;\n      const char *eolr_branch;\n\n      eolr_decomposed = flatpak_decomposed_new_from_ref (rebased_to_ref, NULL);\n\n      /* These are guarantees from FlatpakTransaction */\n      g_assert (eolr_decomposed != NULL);\n      g_assert (flatpak_decomposed_get_kind (ref) == flatpak_decomposed_get_kind (eolr_decomposed));\n\n      eolr_name = flatpak_decomposed_dup_id (eolr_decomposed);\n      eolr_branch = flatpak_decomposed_get_branch (eolr_decomposed);\n\n      if (is_pinned)\n        {\n          /* Only runtimes can be pinned */\n          g_print (_(\"\\nInfo: (pinned) runtime %s%s%s branch %s%s%s is end-of-life, in favor of %s%s%s branch %s%s%s\\n\"),\n                   on, ref_name, off, on, ref_branch, off, on, eolr_name, off, on, eolr_branch, off);\n        }\n      else\n        {\n          if (flatpak_decomposed_is_runtime (ref))\n            g_print (_(\"\\nInfo: runtime %s%s%s branch %s%s%s is end-of-life, in favor of %s%s%s branch %s%s%s\\n\"),\n                     on, ref_name, off, on, ref_branch, off, on, eolr_name, off, on, eolr_branch, off);\n          else\n            g_print (_(\"\\nInfo: app %s%s%s branch %s%s%s is end-of-life, in favor of %s%s%s branch %s%s%s\\n\"),\n                     on, ref_name, off, on, ref_branch, off, on, eolr_name, off, on, eolr_branch, off);\n        }\n    }\n  else if (reason)\n    {\n      g_autofree char *escaped_reason = flatpak_escape_string (reason,\n                                                               FLATPAK_ESCAPE_ALLOW_NEWLINES |\n                                                               FLATPAK_ESCAPE_DO_NOT_QUOTE);\n      if (is_pinned)\n        {\n          /* Only runtimes can be pinned */\n          g_print (_(\"\\nInfo: (pinned) runtime %s%s%s branch %s%s%s is end-of-life, with reason:\\n\"),\n                   on, ref_name, off, on, ref_branch, off);\n        }\n      else\n        {\n          if (flatpak_decomposed_is_runtime (ref))\n            g_print (_(\"\\nInfo: runtime %s%s%s branch %s%s%s is end-of-life, with reason:\\n\"),\n                     on, ref_name, off, on, ref_branch, off);\n          else\n            g_print (_(\"\\nInfo: app %s%s%s branch %s%s%s is end-of-life, with reason:\\n\"),\n                     on, ref_name, off, on, ref_branch, off);\n        }\n      g_print (\"   %s\\n\", escaped_reason);\n    }\n}\n\nstatic void\ncheck_current_transaction_for_dependent_apps (GPtrArray          *apps,\n                                              FlatpakTransaction *transaction,\n                                              FlatpakDecomposed  *ref)\n{\n  g_autoptr(FlatpakTransactionOperation) ref_op = NULL;\n  GPtrArray *related_ops;\n\n  ref_op = flatpak_transaction_get_operation_for_ref (transaction, NULL, flatpak_decomposed_get_ref (ref), NULL);\n  g_assert (ref_op != NULL);\n\n  /* Get the related ops to find any apps that use @ref as a runtime or extension */\n  related_ops = flatpak_transaction_operation_get_related_to_ops (ref_op);\n  if (related_ops == NULL)\n    return;\n\n  for (int i = 0; i < related_ops->len; i++)\n    {\n      FlatpakTransactionOperation *related_op = g_ptr_array_index (related_ops, i);\n      const char *related_op_ref = flatpak_transaction_operation_get_ref (related_op);\n      g_autoptr(FlatpakDecomposed) related_op_decomposed = flatpak_decomposed_new_from_ref (related_op_ref, NULL);\n\n      if (related_op_decomposed == NULL)\n        continue;\n      if (flatpak_decomposed_id_is_subref (related_op_decomposed))\n        continue;\n\n      /* Recurse in case @ref was a runtime extension. We need to check since a\n       * runtime can have a runtime extension in its related ops in the\n       * extra-data case, so if we recurse unconditionally it could be infinite\n       * recursion.\n       */\n      if (flatpak_decomposed_is_runtime (related_op_decomposed))\n        {\n          GKeyFile *metadata = flatpak_transaction_operation_get_metadata (ref_op);\n          if (g_key_file_has_group (metadata, FLATPAK_METADATA_GROUP_EXTENSION_OF))\n            check_current_transaction_for_dependent_apps (apps, transaction, related_op_decomposed);\n        }\n      else if (!g_ptr_array_find_with_equal_func (apps, related_op_decomposed, (GEqualFunc)flatpak_decomposed_equal, NULL))\n        g_ptr_array_add (apps, g_steal_pointer (&related_op_decomposed));\n    }\n}\n\nstatic GPtrArray *\nfind_reverse_dep_apps (FlatpakTransaction *transaction,\n                       FlatpakDir         *dir,\n                       FlatpakDecomposed  *ref,\n                       gboolean           *out_is_extension)\n{\n  FlatpakCliTransaction *self = FLATPAK_CLI_TRANSACTION (transaction);\n  g_autoptr(GPtrArray) apps = NULL;\n  g_autoptr(GError) local_error = NULL;\n\n  g_assert (out_is_extension);\n\n  *out_is_extension = flatpak_dir_is_runtime_extension (dir, ref);\n  if (*out_is_extension)\n    {\n      /* Find apps which are using the ref as an extension directly or as an\n       * extension of their runtime.\n       */\n      apps = flatpak_dir_list_app_refs_with_runtime_extension (dir,\n                                                               &self->runtime_app_map,\n                                                               &self->extension_app_map,\n                                                               ref, NULL, &local_error);\n      if (apps == NULL)\n        {\n          g_info (\"Unable to list apps using extension %s: %s\\n\",\n                  flatpak_decomposed_get_ref (ref), local_error->message);\n          return NULL;\n        }\n    }\n  else\n    {\n      /* Find any apps using the runtime directly */\n      apps = flatpak_dir_list_app_refs_with_runtime (dir, &self->runtime_app_map, ref,\n                                                     NULL, &local_error);\n      if (apps == NULL)\n        {\n          g_info (\"Unable to find apps using runtime %s: %s\\n\",\n                  flatpak_decomposed_get_ref (ref), local_error->message);\n          return NULL;\n        }\n    }\n\n  /* Also check the current transaction since it's possible the EOL ref\n   * and/or any app(s) that depend on it are not installed. It's also\n   * possible the current transaction updates one of the apps to a\n   * newer runtime but we don't handle that yet\n   * (https://github.com/flatpak/flatpak/issues/4832)\n   */\n  check_current_transaction_for_dependent_apps (apps, transaction, ref);\n\n  return g_steal_pointer (&apps);\n}\n\nstatic gboolean\nend_of_lifed_with_rebase (FlatpakTransaction *transaction,\n                          const char         *remote,\n                          const char         *ref_str,\n                          const char         *reason,\n                          const char         *rebased_to_ref,\n                          const char        **previous_ids)\n{\n  FlatpakCliTransaction *self = FLATPAK_CLI_TRANSACTION (transaction);\n  g_autoptr(FlatpakDecomposed) ref = flatpak_decomposed_new_from_ref (ref_str, NULL);\n  g_autofree char *name = NULL;\n  EolAction action = EOL_UNDECIDED;\n  EolAction old_action = EOL_UNDECIDED;\n  gboolean can_rebase = rebased_to_ref != NULL && remote != NULL;\n  FlatpakInstallation *installation = flatpak_transaction_get_installation (transaction);\n  FlatpakDir *dir = flatpak_installation_get_dir (installation, NULL);\n\n  if (ref == NULL)\n    return FALSE; /* Shouldn't happen, the ref should be valid */\n\n  name = flatpak_decomposed_dup_id (ref);\n\n  self->did_interaction = TRUE;\n\n  if (flatpak_decomposed_id_is_subref (ref))\n    {\n      GLNX_HASH_TABLE_FOREACH_KV (self->eol_actions, FlatpakDecomposed *, eoled_ref, gpointer, value)\n        {\n          guint old_eol_action = GPOINTER_TO_UINT (value);\n\n          if (flatpak_decomposed_id_is_subref_of (ref, eoled_ref))\n              {\n                old_action = old_eol_action; /* Do the same */\n                break;\n              }\n        }\n    }\n\n  if (old_action != EOL_UNDECIDED)\n    {\n      switch (old_action)\n        {\n        default:\n        case EOL_IGNORE:\n          if (!can_rebase)\n            action = EOL_IGNORE;\n          /* Else, ask if we want to rebase */\n          break;\n        case EOL_REBASE:\n        case EOL_NO_REBASE:\n          if (can_rebase)\n            action = old_action;\n          else\n            action = EOL_IGNORE;\n        }\n    }\n\n  if (action == EOL_UNDECIDED)\n    {\n      action = EOL_IGNORE;\n\n      print_eol_info_message (dir, ref, name, rebased_to_ref, reason);\n\n      if (flatpak_decomposed_is_runtime (ref) && !rebased_to_ref)\n        {\n          gboolean is_extension;\n          g_autoptr(GPtrArray) apps = find_reverse_dep_apps (transaction, dir, ref, &is_extension);\n\n          if (apps && apps->len > 0)\n            {\n              if (is_extension)\n                g_print (_(\"Info: applications using this extension:\\n\"));\n              else\n                g_print (_(\"Info: applications using this runtime:\\n\"));\n\n              g_print (\"   \");\n              for (guint i = 0; i < apps->len; i++)\n                {\n                  FlatpakDecomposed *app_ref = g_ptr_array_index (apps, i);\n                  g_autofree char *id = flatpak_decomposed_dup_id (app_ref);\n                  if (i != 0)\n                    g_print (\", \");\n                  g_print (\"%s\", id);\n                }\n              g_print (\"\\n\");\n            }\n        }\n\n      if (rebased_to_ref && remote)\n        {\n          /* The context for this prompt is in print_eol_info_message() */\n          if (self->disable_interaction ||\n              flatpak_yes_no_prompt (TRUE, _(\"Replace?\")))\n            {\n              if (self->disable_interaction)\n                g_print (_(\"Updating to rebased version\\n\"));\n\n              action = EOL_REBASE;\n            }\n          else\n            action = EOL_NO_REBASE;\n        }\n    }\n  else\n    {\n      g_info (\"%s is end-of-life, using action from parent ref\", name);\n    }\n\n  /* Cache for later comparison and reuse */\n  g_hash_table_insert (self->eol_actions, flatpak_decomposed_ref (ref), GUINT_TO_POINTER (action));\n\n  if (action == EOL_REBASE)\n    {\n      g_autoptr(GError) error = NULL;\n\n      if (!flatpak_transaction_add_rebase (transaction, remote, rebased_to_ref, NULL, previous_ids, &error))\n        {\n          g_propagate_prefixed_error (&self->first_operation_error,\n                                      g_error_copy (error),\n                                      _(\"Failed to rebase %s to %s: \"),\n                                      name, rebased_to_ref);\n          return FALSE;\n        }\n\n      if (!flatpak_transaction_add_uninstall (transaction, ref_str, &error))\n        {\n          /* NOT_INSTALLED error is expected in case the op that triggered this was install not update */\n          if (g_error_matches (error, FLATPAK_ERROR, FLATPAK_ERROR_NOT_INSTALLED))\n            g_clear_error (&error);\n          else\n            {\n              g_propagate_prefixed_error (&self->first_operation_error,\n                                          g_error_copy (error),\n                                          _(\"Failed to uninstall %s for rebase to %s: \"),\n                                          name, rebased_to_ref);\n              return FALSE;\n            }\n        }\n\n      return TRUE; /* skip install/update op of end-of-life ref */\n    }\n  else /* IGNORE or NO_REBASE */\n    return FALSE;\n}\n\nstatic int\ncmpstringp (const void *p1, const void *p2)\n{\n  return strcmp (*(char * const *) p1, *(char * const *) p2);\n}\n\nstatic void\nappend_permissions (GPtrArray  *permissions,\n                    GKeyFile   *metadata,\n                    GKeyFile   *old_metadata,\n                    const char *group)\n{\n  g_auto(GStrv) options = g_key_file_get_string_list (metadata, FLATPAK_METADATA_GROUP_CONTEXT, group, NULL, NULL);\n  g_auto(GStrv) old_options = NULL;\n  int i;\n\n  if (options == NULL)\n    return;\n\n  qsort (options, g_strv_length (options), sizeof (const char *), cmpstringp);\n\n  if (old_metadata)\n    old_options = g_key_file_get_string_list (old_metadata, FLATPAK_METADATA_GROUP_CONTEXT, group, NULL, NULL);\n\n  for (i = 0; options[i] != NULL; i++)\n    {\n      const char *option = options[i];\n      if (option[0] == '!')\n        continue;\n\n      if (old_options && g_strv_contains ((const char * const *) old_options, option))\n        continue;\n\n      if (strcmp (group, FLATPAK_METADATA_KEY_DEVICES) == 0 && strcmp (option, \"all\") == 0)\n        option = \"devices\";\n\n      g_ptr_array_add (permissions, g_strdup (option));\n    }\n}\n\nstatic void\nappend_bus (GPtrArray  *talk,\n            GPtrArray  *own,\n            GKeyFile   *metadata,\n            GKeyFile   *old_metadata,\n            const char *group)\n{\n  g_auto(GStrv) keys = NULL;\n  gsize i, keys_count;\n\n  keys = g_key_file_get_keys (metadata, group, &keys_count, NULL);\n  if (keys == NULL)\n    return;\n\n  qsort (keys, g_strv_length (keys), sizeof (const char *), cmpstringp);\n\n  for (i = 0; i < keys_count; i++)\n    {\n      const char *key = keys[i];\n      g_autofree char *value = g_key_file_get_string (metadata, group, key, NULL);\n\n      if (g_strcmp0 (value, \"none\") == 0)\n        continue;\n\n      if (old_metadata)\n        {\n          g_autofree char *old_value = g_key_file_get_string (old_metadata, group, key, NULL);\n          if (g_strcmp0 (old_value, value) == 0)\n            continue;\n        }\n\n      if (g_strcmp0 (value, \"own\") == 0)\n        g_ptr_array_add (own, g_strdup (key));\n      else\n        g_ptr_array_add (talk, g_strdup (key));\n    }\n}\n\nstatic void\nappend_tags (GPtrArray *tags_array,\n             GKeyFile  *metadata,\n             GKeyFile  *old_metadata)\n{\n  gsize i, size = 0;\n  g_auto(GStrv) tags = g_key_file_get_string_list (metadata, FLATPAK_METADATA_GROUP_APPLICATION, \"tags\",\n                                                   &size, NULL);\n  g_auto(GStrv) old_tags = NULL;\n\n  if (old_metadata)\n    old_tags = g_key_file_get_string_list (old_metadata, FLATPAK_METADATA_GROUP_APPLICATION, \"tags\",\n                                           NULL, NULL);\n\n  for (i = 0; i < size; i++)\n    {\n      const char *tag = tags[i];\n      if (old_tags == NULL || !g_strv_contains ((const char * const *) old_tags, tag))\n        g_ptr_array_add (tags_array, g_strdup (tag));\n    }\n}\n\nstatic void\nprint_perm_line (int        idx,\n                 GPtrArray *items,\n                 int        cols)\n{\n  g_autoptr(GString) res = g_string_new (NULL);\n  g_autofree char *escaped_first_perm = NULL;\n  int i;\n\n  escaped_first_perm = flatpak_escape_string (items->pdata[0], FLATPAK_ESCAPE_DEFAULT);\n  g_string_append_printf (res, \"    [%d] %s\", idx, escaped_first_perm);\n\n  for (i = 1; i < items->len; i++)\n    {\n      g_autofree char *escaped = flatpak_escape_string (items->pdata[i],\n                                                        FLATPAK_ESCAPE_DEFAULT);\n      char *p;\n      int len;\n\n      p = strrchr (res->str, '\\n');\n      if (!p)\n        p = res->str;\n\n      len = (res->str + strlen (res->str)) - p;\n      if (len + strlen (escaped) + 2 >= cols)\n        g_string_append_printf (res, \",\\n        %s\", escaped);\n      else\n        g_string_append_printf (res, \", %s\", escaped);\n    }\n\n  g_print (\"%s\\n\", res->str);\n}\n\nstatic void\nprint_permissions (FlatpakCliTransaction *self,\n                   const char            *ref,\n                   GKeyFile              *metadata,\n                   GKeyFile              *old_metadata)\n{\n  g_autoptr(FlatpakRef) rref = flatpak_ref_parse (ref, NULL);\n  g_autoptr(GPtrArray) permissions = g_ptr_array_new_with_free_func (g_free);\n  g_autoptr(GPtrArray) files = g_ptr_array_new_with_free_func (g_free);\n  g_autoptr(GPtrArray) session_bus_talk = g_ptr_array_new_with_free_func (g_free);\n  g_autoptr(GPtrArray) session_bus_own = g_ptr_array_new_with_free_func (g_free);\n  g_autoptr(GPtrArray) system_bus_talk = g_ptr_array_new_with_free_func (g_free);\n  g_autoptr(GPtrArray) system_bus_own = g_ptr_array_new_with_free_func (g_free);\n  g_autoptr(GPtrArray) tags = g_ptr_array_new_with_free_func (g_free);\n  g_autoptr(FlatpakTablePrinter) printer = NULL;\n  int max_permission_width;\n  int n_permission_cols;\n  int i, j;\n  int rows, cols;\n  int table_rows, table_cols;\n  const char *on = \"\";\n  const char *off = \"\";\n\n  if (flatpak_fancy_output ())\n    {\n      on = FLATPAK_ANSI_BOLD_ON;\n      off = FLATPAK_ANSI_BOLD_OFF;\n    }\n\n  if (metadata == NULL)\n    return;\n\n  /* Only apps have permissions */\n  if (flatpak_ref_get_kind (rref) != FLATPAK_REF_KIND_APP)\n    return;\n\n  append_permissions (permissions, metadata, old_metadata, FLATPAK_METADATA_KEY_SHARED);\n  append_permissions (permissions, metadata, old_metadata, FLATPAK_METADATA_KEY_SOCKETS);\n  append_permissions (permissions, metadata, old_metadata, FLATPAK_METADATA_KEY_DEVICES);\n  append_permissions (permissions, metadata, old_metadata, FLATPAK_METADATA_KEY_FEATURES);\n  append_permissions (files, metadata, old_metadata, FLATPAK_METADATA_KEY_FILESYSTEMS);\n  append_bus (session_bus_talk, session_bus_own,\n              metadata, old_metadata, FLATPAK_METADATA_GROUP_SESSION_BUS_POLICY);\n  append_bus (system_bus_talk, system_bus_own,\n              metadata, old_metadata, FLATPAK_METADATA_GROUP_SYSTEM_BUS_POLICY);\n  append_tags (tags, metadata, old_metadata);\n\n  j = 1;\n  if (files->len > 0)\n    g_ptr_array_add (permissions, g_strdup_printf (\"file access [%d]\", j++));\n  if (session_bus_talk->len > 0)\n    g_ptr_array_add (permissions, g_strdup_printf (\"dbus access [%d]\", j++));\n  if (session_bus_own->len > 0)\n    g_ptr_array_add (permissions, g_strdup_printf (\"bus ownership [%d]\", j++));\n  if (system_bus_talk->len > 0)\n    g_ptr_array_add (permissions, g_strdup_printf (\"system dbus access [%d]\", j++));\n  if (system_bus_own->len > 0)\n    g_ptr_array_add (permissions, g_strdup_printf (\"system bus ownership [%d]\", j++));\n  if (tags->len > 0)\n    g_ptr_array_add (permissions, g_strdup_printf (\"tags [%d]\", j++));\n\n  /* Early exit if no (or no new) permissions */\n  if (permissions->len == 0)\n    return;\n\n  g_print (\"\\n\");\n\n  if (old_metadata)\n    g_print (_(\"New %s%s%s permissions:\"), on, flatpak_ref_get_name (rref), off);\n  else\n    g_print (_(\"%s%s%s permissions:\"), on, flatpak_ref_get_name (rref), off);\n\n  g_print (\"\\n\");\n\n  flatpak_get_window_size (&rows, &cols);\n  max_permission_width = 0;\n  for (i = 0; i < permissions->len; i++)\n    max_permission_width = MAX (max_permission_width, strlen (g_ptr_array_index (permissions, i)));\n\n  /* At least 4 columns, but more if we're guaranteed to fit */\n  n_permission_cols =  MAX (4, cols / (max_permission_width + 4));\n\n  printer = flatpak_table_printer_new ();\n  for (i = 0; i < permissions->len; i++)\n    {\n      char *perm = g_ptr_array_index (permissions, i);\n      if (i % n_permission_cols == 0)\n        {\n          g_autofree char *text = NULL;\n\n          if (i > 0)\n            flatpak_table_printer_finish_row (printer);\n\n          text = g_strdup_printf (\"    %s\", perm);\n          flatpak_table_printer_add_column (printer, text);\n        }\n      else\n        flatpak_table_printer_add_column (printer, perm);\n    }\n  flatpak_table_printer_finish_row (printer);\n\n  for (i = 0; i < n_permission_cols; i++)\n    flatpak_table_printer_set_column_expand (printer, i, TRUE);\n\n  flatpak_table_printer_print_full (printer, 0, cols, &table_rows, &table_cols);\n\n  g_print (\"\\n\\n\");\n\n  j = 1;\n  if (files->len > 0)\n    print_perm_line (j++, files, cols);\n  if (session_bus_talk->len > 0)\n    print_perm_line (j++, session_bus_talk, cols);\n  if (session_bus_own->len > 0)\n    print_perm_line (j++, session_bus_own, cols);\n  if (system_bus_talk->len > 0)\n    print_perm_line (j++, system_bus_talk, cols);\n  if (system_bus_own->len > 0)\n    print_perm_line (j++, system_bus_own, cols);\n  if (tags->len > 0)\n    print_perm_line (j++, tags, cols);\n}\n\nstatic void\nmessage_handler (const gchar   *log_domain,\n                 GLogLevelFlags log_level,\n                 const gchar   *message,\n                 gpointer       user_data)\n{\n  FlatpakCliTransaction *self = FLATPAK_CLI_TRANSACTION (user_data);\n  g_autofree char *text = NULL;\n\n  text = g_strconcat (_(\"Warning: \"), message, NULL);\n\n  if (flatpak_fancy_output ())\n    {\n      flatpak_table_printer_set_cell (self->printer, self->progress_row, 0, text);\n      self->progress_row++;\n      flatpak_table_printer_add_span (self->printer, \"\");\n      flatpak_table_printer_finish_row (self->printer);\n      redraw (self);\n    }\n  else\n    g_print (\"%s\\n\", text);\n}\n\nstatic gboolean\ntransaction_ready_pre_auth (FlatpakTransaction *transaction)\n{\n  FlatpakCliTransaction *self = FLATPAK_CLI_TRANSACTION (transaction);\n  GList *ops = flatpak_transaction_get_operations (transaction);\n  GList *l;\n  int i;\n  FlatpakTablePrinter *printer;\n  const char *op_shorthand[] = { \"i\", \"u\", \"i\", \"r\" };\n\n  /* These caches may no longer be valid once the transaction runs */\n  g_clear_pointer (&self->runtime_app_map, g_hash_table_unref);\n  g_clear_pointer (&self->extension_app_map, g_hash_table_unref);\n\n  if (ops == NULL)\n    return TRUE;\n\n  self->n_ops = g_list_length (ops);\n\n  for (l = ops; l != NULL; l = l->next)\n    {\n      FlatpakTransactionOperation *op = l->data;\n      FlatpakTransactionOperationType type = flatpak_transaction_operation_get_operation_type (op);\n\n      switch (type)\n        {\n        case FLATPAK_TRANSACTION_OPERATION_UNINSTALL:\n          self->uninstalling = TRUE;\n          break;\n\n        case FLATPAK_TRANSACTION_OPERATION_INSTALL:\n        case FLATPAK_TRANSACTION_OPERATION_INSTALL_BUNDLE:\n          self->installing = TRUE;\n          break;\n\n        case FLATPAK_TRANSACTION_OPERATION_UPDATE:\n          self->updating = TRUE;\n          break;\n\n        default:;\n        }\n    }\n\n  /* first, show permissions */\n  for (l = ops; l != NULL; l = l->next)\n    {\n      FlatpakTransactionOperation *op = l->data;\n      FlatpakTransactionOperationType type = flatpak_transaction_operation_get_operation_type (op);\n\n      if (type == FLATPAK_TRANSACTION_OPERATION_INSTALL ||\n          type == FLATPAK_TRANSACTION_OPERATION_INSTALL_BUNDLE ||\n          type == FLATPAK_TRANSACTION_OPERATION_UPDATE)\n        {\n          const char *ref = flatpak_transaction_operation_get_ref (op);\n          GKeyFile *metadata = flatpak_transaction_operation_get_metadata (op);\n          GKeyFile *old_metadata = flatpak_transaction_operation_get_old_metadata (op);\n\n          print_permissions (self, ref, metadata, old_metadata);\n        }\n    }\n\n  g_print (\"\\n\");\n\n  printer = self->printer = flatpak_table_printer_new ();\n  i = 0;\n\n  flatpak_table_printer_set_column_title (printer, i++, \"   \");\n  flatpak_table_printer_set_column_title (printer, i++, \"   \");\n\n  flatpak_table_printer_set_column_expand (printer, i, TRUE);\n  flatpak_table_printer_set_column_title (printer, i++, _(\"ID\"));\n\n  flatpak_table_printer_set_column_expand (printer, i, TRUE);\n  if (!self->non_default_arch)\n    {\n      flatpak_table_printer_set_column_skip_unique (printer, i, TRUE);\n      flatpak_table_printer_set_column_skip_unique_string (printer, i, flatpak_get_arch ());\n    }\n  flatpak_table_printer_set_column_title (printer, i++, _(\"Arch\"));\n\n  flatpak_table_printer_set_column_expand (printer, i, TRUE);\n  flatpak_table_printer_set_column_title (printer, i++, _(\"Branch\"));\n\n  flatpak_table_printer_set_column_expand (printer, i, TRUE);\n  /* translators: This is short for operation, the title of a one-char column */\n  flatpak_table_printer_set_column_title (printer, i++, _(\"Op\"));\n\n  if (self->installing || self->updating)\n    {\n      g_autofree char *text1 = NULL;\n      g_autofree char *text2 = NULL;\n      g_autofree char *text = NULL;\n      int size;\n\n      flatpak_table_printer_set_column_expand (printer, i, TRUE);\n      flatpak_table_printer_set_column_title (printer, i++, _(\"Remote\"));\n      self->download_col = i;\n\n      /* Avoid resizing the download column too much,\n       * by making the title as long as typical content\n       */\n      text1 = g_strdup_printf (\"< 999.9 kB (%s)\", _(\"partial\"));\n      text2 = g_strdup_printf (\"  123.4 MB / 999.9 MB\");\n      size = MAX (strlen (text1), strlen (text2));\n      text = g_strdup_printf (\"%-*s\", size, _(\"Download\"));\n      flatpak_table_printer_set_column_title (printer, i++, text);\n    }\n\n  for (l = ops, i = 1; l != NULL; l = l->next, i++)\n    {\n      FlatpakTransactionOperation *op = l->data;\n      FlatpakTransactionOperationType type = flatpak_transaction_operation_get_operation_type (op);\n      FlatpakDecomposed *ref = flatpak_transaction_operation_get_decomposed (op);\n      const char *remote = flatpak_transaction_operation_get_remote (op);\n      g_autofree char *id = flatpak_decomposed_dup_id (ref);\n      const char *branch = flatpak_decomposed_get_branch (ref);\n      g_autofree char *arch = flatpak_decomposed_dup_arch (ref);\n      g_autofree char *rownum = g_strdup_printf (\"%2d.\", i);\n\n      flatpak_table_printer_add_column (printer, rownum);\n      flatpak_table_printer_add_column (printer, \"   \");\n      flatpak_table_printer_add_column (printer, id);\n      flatpak_table_printer_add_column (printer, arch);\n      flatpak_table_printer_add_column (printer, branch);\n      flatpak_table_printer_add_column (printer, op_shorthand[type]);\n\n      if (type == FLATPAK_TRANSACTION_OPERATION_INSTALL ||\n          type == FLATPAK_TRANSACTION_OPERATION_INSTALL_BUNDLE ||\n          type == FLATPAK_TRANSACTION_OPERATION_UPDATE)\n        {\n          guint64 download_size;\n          g_autofree char *formatted = NULL;\n          g_autofree char *text = NULL;\n          const char *prefix;\n\n          download_size = flatpak_transaction_operation_get_download_size (op);\n          formatted = g_format_size (download_size);\n\n          if (download_size > 0)\n            prefix = \"< \";\n          else\n            prefix = \"\";\n\n          flatpak_table_printer_add_column (printer, remote);\n          if (flatpak_transaction_operation_get_subpaths (op) != NULL)\n            text = g_strdup_printf (\"%s%s (%s)\", prefix, formatted, _(\"partial\"));\n          else\n            text = g_strdup_printf (\"%s%s\", prefix, formatted);\n          flatpak_table_printer_add_decimal_column (printer, text);\n        }\n\n      g_object_set_data (G_OBJECT (op), \"row\", GINT_TO_POINTER (flatpak_table_printer_get_current_row (printer)));\n      flatpak_table_printer_finish_row (printer);\n    }\n\n  flatpak_get_window_size (&self->rows, &self->cols);\n\n  g_print (\"\\n\");\n\n  flatpak_table_printer_print_full (printer, 0, self->cols,\n                                    &self->table_height, &self->table_width);\n\n  g_print (\"\\n\");\n\n  if (!self->disable_interaction)\n    {\n      g_autoptr(FlatpakInstallation) installation = flatpak_transaction_get_installation (transaction);\n      const char *name;\n      const char *id;\n      gboolean ret;\n\n      g_print (\"\\n\");\n\n      name = flatpak_installation_get_display_name (installation);\n      id = flatpak_installation_get_id (installation);\n\n      if (flatpak_installation_get_is_user (installation))\n        ret = flatpak_yes_no_prompt (TRUE, _(\"Proceed with these changes to the user installation?\"));\n      else if (g_strcmp0 (id, SYSTEM_DIR_DEFAULT_ID) == 0)\n        ret = flatpak_yes_no_prompt (TRUE, _(\"Proceed with these changes to the system installation?\"));\n      else\n        ret = flatpak_yes_no_prompt (TRUE, _(\"Proceed with these changes to the %s?\"), name);\n\n      if (!ret)\n        {\n          g_list_free_full (ops, g_object_unref);\n          return FALSE;\n        }\n    }\n  else\n    g_print (\"\\n\\n\");\n\n  self->did_interaction = FALSE;\n\n  return TRUE;\n}\n\nstatic gboolean\ntransaction_ready (FlatpakTransaction *transaction)\n{\n  FlatpakCliTransaction *self = FLATPAK_CLI_TRANSACTION (transaction);\n  GList *ops = flatpak_transaction_get_operations (transaction);\n  GList *l;\n  FlatpakTablePrinter *printer;\n\n  if (ops == NULL)\n    return TRUE;\n\n  printer = self->printer;\n\n  if (self->did_interaction)\n    {\n      /* We did some interaction since ready_pre_auth which messes up the formating, so re-print table */\n      flatpak_table_printer_print_full (printer, 0, self->cols,\n                                        &self->table_height, &self->table_width);\n      g_print (\"\\n\\n\");\n    }\n\n  for (l = ops; l; l = l->next)\n    {\n      FlatpakTransactionOperation *op = l->data;\n      set_op_progress (self, op, \" \");\n    }\n\n  g_list_free_full (ops, g_object_unref);\n\n  flatpak_table_printer_add_span (printer, \"\");\n  flatpak_table_printer_finish_row (printer);\n  flatpak_table_printer_add_span (printer, \"\");\n  self->progress_row = flatpak_table_printer_get_current_row (printer);\n  flatpak_table_printer_finish_row (printer);\n\n  self->table_height += 3; /* 2 for the added lines and one for the newline from the user after the prompt */\n\n  if (flatpak_fancy_output ())\n    {\n      flatpak_hide_cursor ();\n      flatpak_enable_raw_mode ();\n      redraw (self);\n    }\n\n  g_log_set_handler (G_LOG_DOMAIN, G_LOG_LEVEL_MESSAGE | G_LOG_LEVEL_WARNING, message_handler, transaction);\n\n  return TRUE;\n}\n\nstatic void\nflatpak_cli_transaction_finalize (GObject *object)\n{\n  FlatpakCliTransaction *self = FLATPAK_CLI_TRANSACTION (object);\n\n  if (self->first_operation_error)\n    g_error_free (self->first_operation_error);\n\n  g_free (self->progress_msg);\n\n  g_hash_table_unref (self->eol_actions);\n\n  if (self->runtime_app_map)\n    g_hash_table_unref (self->runtime_app_map);\n\n  if (self->extension_app_map)\n    g_hash_table_unref (self->extension_app_map);\n\n  if (self->printer)\n    flatpak_table_printer_free (self->printer);\n\n  G_OBJECT_CLASS (flatpak_cli_transaction_parent_class)->finalize (object);\n}\n\nstatic void\nflatpak_cli_transaction_init (FlatpakCliTransaction *self)\n{\n  self->eol_actions = g_hash_table_new_full ((GHashFunc)flatpak_decomposed_hash, (GEqualFunc)flatpak_decomposed_equal,\n                                             (GDestroyNotify)flatpak_decomposed_unref, NULL);\n}\n\nstatic gboolean flatpak_cli_transaction_run (FlatpakTransaction *transaction,\n                                             GCancellable       *cancellable,\n                                             GError            **error);\n\nstatic void\nflatpak_cli_transaction_class_init (FlatpakCliTransactionClass *klass)\n{\n  GObjectClass *object_class = G_OBJECT_CLASS (klass);\n  FlatpakTransactionClass *transaction_class = FLATPAK_TRANSACTION_CLASS (klass);\n\n  object_class->finalize = flatpak_cli_transaction_finalize;\n  transaction_class->add_new_remote = add_new_remote;\n  transaction_class->ready = transaction_ready;\n  transaction_class->ready_pre_auth = transaction_ready_pre_auth;\n  transaction_class->new_operation = new_operation;\n  transaction_class->operation_done = operation_done;\n  transaction_class->operation_error = operation_error;\n  transaction_class->choose_remote_for_ref = choose_remote_for_ref;\n  transaction_class->end_of_lifed_with_rebase = end_of_lifed_with_rebase;\n  transaction_class->run = flatpak_cli_transaction_run;\n  transaction_class->webflow_start = webflow_start;\n  transaction_class->webflow_done = webflow_done;\n  transaction_class->basic_auth_start = basic_auth_start;\n  transaction_class->install_authenticator = install_authenticator;\n}\n\nFlatpakTransaction *\nflatpak_cli_transaction_new (FlatpakDir *dir,\n                             gboolean    disable_interaction,\n                             gboolean    stop_on_first_error,\n                             gboolean    non_default_arch,\n                             GError    **error)\n{\n  g_autoptr(FlatpakInstallation) installation = NULL;\n  g_autoptr(FlatpakCliTransaction) self = NULL;\n\n  installation = flatpak_installation_new_for_dir (dir, NULL, error);\n  if (installation == NULL)\n    return NULL;\n\n  self = g_initable_new (FLATPAK_TYPE_CLI_TRANSACTION,\n                         NULL, error,\n                         \"installation\", installation,\n                         NULL);\n  if (self == NULL)\n    return NULL;\n\n  self->disable_interaction = disable_interaction;\n  self->stop_on_first_error = stop_on_first_error;\n  self->non_default_arch = non_default_arch;\n\n  flatpak_transaction_set_no_interaction (FLATPAK_TRANSACTION (self), disable_interaction);\n  flatpak_transaction_add_default_dependency_sources (FLATPAK_TRANSACTION (self));\n\n  return (FlatpakTransaction *) g_steal_pointer (&self);\n}\n\nstatic gboolean\nflatpak_cli_transaction_run (FlatpakTransaction *transaction,\n                             GCancellable       *cancellable,\n                             GError            **error)\n{\n  FlatpakCliTransaction *self = FLATPAK_CLI_TRANSACTION (transaction);\n  gboolean res;\n\n  res = FLATPAK_TRANSACTION_CLASS (flatpak_cli_transaction_parent_class)->run (transaction, cancellable, error);\n\n  if (flatpak_fancy_output ())\n    {\n      flatpak_disable_raw_mode ();\n      flatpak_show_cursor ();\n    }\n\n  if (res && self->n_ops > 0)\n    {\n      const char *text;\n\n      if (self->uninstalling + self->installing + self->updating > 1)\n        text = _(\"Changes complete.\");\n      else if (self->uninstalling)\n        text = _(\"Uninstall complete.\");\n      else if (self->installing)\n        text = _(\"Installation complete.\");\n      else\n        text = _(\"Updates complete.\");\n\n      if (flatpak_fancy_output ())\n        {\n          set_progress (self, text);\n          redraw (self);\n        }\n      else\n        g_print (\"%s\", text);\n\n      g_print (\"\\n\");\n    }\n\n  if (self->first_operation_error)\n    {\n      g_clear_error (error);\n\n      /* We always want to return an error if there was some kind of operation error,\n         as that causes the main CLI to return an error status. */\n\n      if (self->stop_on_first_error)\n        {\n          /* For the install/stop_on_first_error we return the first operation error,\n             as we have not yet printed it.  */\n\n          g_propagate_error (error, g_steal_pointer (&self->first_operation_error));\n          return FALSE;\n        }\n      else\n        {\n          /* For updates/!stop_on_first_error we already printed all errors so we make up\n             a different one. */\n\n          return flatpak_fail (error, _(\"There were one or more errors\"));\n        }\n    }\n\n  if (!res)\n    return FALSE;\n\n  return TRUE;\n}\n"], "filenames": ["app/flatpak-cli-transaction.c"], "buggy_code_start_loc": [757], "buggy_code_end_loc": [774], "fixing_code_start_loc": [758], "fixing_code_end_loc": [777], "type": "CWE-116", "message": "Flatpak is a system for building, distributing, and running sandboxed desktop applications on Linux. In versions prior to 1.10.8, 1.12.8, 1.14.4, and 1.15.4, if an attacker publishes a Flatpak app with elevated permissions, they can hide those permissions from users of the `flatpak(1)` command-line interface by setting other permissions to crafted values that contain non-printable control characters such as `ESC`. A fix is available in versions 1.10.8, 1.12.8, 1.14.4, and 1.15.4. As a workaround, use a GUI like GNOME Software rather than the command-line interface, or only install apps whose maintainers you trust.", "other": {"cve": {"id": "CVE-2023-28101", "sourceIdentifier": "security-advisories@github.com", "published": "2023-03-16T16:15:12.650", "lastModified": "2023-03-22T19:02:43.367", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Flatpak is a system for building, distributing, and running sandboxed desktop applications on Linux. In versions prior to 1.10.8, 1.12.8, 1.14.4, and 1.15.4, if an attacker publishes a Flatpak app with elevated permissions, they can hide those permissions from users of the `flatpak(1)` command-line interface by setting other permissions to crafted values that contain non-printable control characters such as `ESC`. A fix is available in versions 1.10.8, 1.12.8, 1.14.4, and 1.15.4. As a workaround, use a GUI like GNOME Software rather than the command-line interface, or only install apps whose maintainers you trust."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.0, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.1, "impactScore": 1.4}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-116"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:flatpak:flatpak:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.10.8", "matchCriteriaId": "D7C3C072-DE21-4063-A561-44CA1E5AE584"}, {"vulnerable": true, "criteria": "cpe:2.3:a:flatpak:flatpak:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.12.0", "versionEndExcluding": "1.12.8", "matchCriteriaId": "3572AF68-883F-44B3-95F8-5062ED29D5F9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:flatpak:flatpak:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.14.0", "versionEndExcluding": "1.14.4", "matchCriteriaId": "50573059-1A6E-40DA-9D68-9D054DCC71BE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:flatpak:flatpak:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.15.0", "versionEndExcluding": "1.15.4", "matchCriteriaId": "02CAAC00-232B-45A2-86ED-1EE9DC1F0128"}]}]}], "references": [{"url": "https://github.com/flatpak/flatpak/commit/409e34187de2b2b2c4ef34c79f417be698830f6c", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/flatpak/flatpak/commit/6cac99dafe6003c8a4bd5666341c217876536869", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/flatpak/flatpak/commit/7fe63f2e8f1fd2dafc31d45154cf0b191ebec66c", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/flatpak/flatpak/security/advisories/GHSA-h43h-fwqx-mpp8", "source": "security-advisories@github.com", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/flatpak/flatpak/commit/409e34187de2b2b2c4ef34c79f417be698830f6c"}}