{"buggy_code": ["/*\n *       .                             .o8                     oooo\n *    .o8                             \"888                     `888\n *  .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\n *    888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\n *    888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\n *    888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\n *    \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\n *  ========================================================================\n *  Author:     Chris Brame\n *  Updated:    1/20/19 4:43 PM\n *  Copyright (c) 2014-2019. All rights reserved.\n */\n\nvar _ = require('lodash')\n\nmodule.exports.sendToSelf = function (socket, method, data) {\n  socket.emit(method, data)\n}\n\nmodule.exports._sendToSelf = function (io, socketId, method, data) {\n  _.each(io.sockets.sockets, function (socket) {\n    if (socket.id === socketId) {\n      socket.emit(method, data)\n    }\n  })\n}\n\nmodule.exports.sendToAllConnectedClients = function (io, method, data) {\n  io.sockets.emit(method, data)\n}\n\nmodule.exports.sendToAllClientsInRoom = function (io, room, method, data) {\n  io.sockets.in(room).emit(method, data)\n}\n\nmodule.exports.sendToUser = function (socketList, userList, username, method, data) {\n  var userOnline = null\n  _.forEach(userList, function (v, k) {\n    if (k.toLowerCase() === username.toLowerCase()) {\n      userOnline = v\n      return true\n    }\n  })\n\n  if (_.isNull(userOnline)) return true\n\n  _.forEach(userOnline.sockets, function (socket) {\n    var o = _.findKey(socketList, { id: socket })\n    var i = socketList[o]\n    if (_.isUndefined(i)) return true\n    i.emit(method, data)\n  })\n}\n\nmodule.exports.sendToAllExcept = function (io, exceptSocketId, method, data) {\n  _.each(io.sockets.sockets, function (socket) {\n    if (socket.id !== exceptSocketId) {\n      socket.emit(method, data)\n    }\n  })\n}\n\nmodule.exports.disconnectAllClients = function (io) {\n  Object.keys(io.sockets.sockets).forEach(function (sock) {\n    io.sockets.sockets[sock].disconnect(true)\n  })\n}\n", "/*\n *       .                             .o8                     oooo\n *    .o8                             \"888                     `888\n *  .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\n *    888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\n *    888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\n *    888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\n *    \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\n *  ========================================================================\n *  Author:     Chris Brame\n *  Updated:    1/20/19 4:43 PM\n *  Copyright (c) 2014-2019. All rights reserved.\n */\n\nvar mongoose = require('mongoose')\n\nvar attachmentSchema = mongoose.Schema({\n  owner: { type: mongoose.Schema.Types.ObjectId, ref: 'accounts' },\n  name: { type: String, required: true },\n  date: { type: Date, required: true, default: Date.now },\n  path: { type: String, required: true },\n  type: { type: String, required: true }\n})\n\nattachmentSchema.pre('save', function (next) {\n  this.name = this.name.trim()\n\n  return next()\n})\n\nmodule.exports = attachmentSchema\n", "/*\n      .                              .o8                     oooo\n   .o8                             \"888                     `888\n .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\n   888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\n   888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\n   888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\n   \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\n ========================================================================\n Created:    11/1/2018\n Author:     Chris Brame\n\n **/\n\nvar _ = require('lodash')\nvar async = require('async')\nvar mongoose = require('mongoose')\n\n// Refs\nrequire('./group')\nvar Teams = require('./team')\nvar Groups = require('./group')\n\nvar COLLECTION = 'departments'\n\nvar departmentSchema = mongoose.Schema({\n  name: { type: String, required: true, unique: true },\n  normalized: { type: String },\n  teams: [{ type: mongoose.Schema.Types.ObjectId, ref: 'teams', autopopulate: true }],\n  allGroups: { type: Boolean, default: false },\n  publicGroups: { type: Boolean, default: false },\n  groups: [{ type: mongoose.Schema.Types.ObjectId, ref: 'groups', autopopulate: true }]\n})\n\ndepartmentSchema.plugin(require('mongoose-autopopulate'))\n\ndepartmentSchema.pre('save', function (next) {\n  this.name = this.name.trim()\n  this.normalized = this.name.trim().toLowerCase()\n\n  return next()\n})\n\ndepartmentSchema.statics.getDepartmentsByTeam = function (teamIds, callback) {\n  return this.model(COLLECTION)\n    .find({ teams: { $in: teamIds } })\n    .exec(callback)\n}\n\ndepartmentSchema.statics.getUserDepartments = function (userId, callback) {\n  var self = this\n\n  Teams.getTeamsOfUser(userId, function (err, teams) {\n    if (err) return callback(err)\n\n    return self\n      .model(COLLECTION)\n      .find({ teams: { $in: teams } })\n      .exec(callback)\n  })\n}\n\ndepartmentSchema.statics.getDepartmentGroupsOfUser = function (userId, callback) {\n  var self = this\n\n  Teams.getTeamsOfUser(userId, function (err, teams) {\n    if (err) return callback(err)\n\n    return self\n      .model(COLLECTION)\n      .find({ teams: { $in: teams } })\n      .exec(function (err, departments) {\n        if (err) return callback(err)\n\n        var hasAllGroups = _.some(departments, { allGroups: true })\n        var hasPublicGroups = _.some(departments, { publicGroups: true })\n        if (hasAllGroups) {\n          return Groups.getAllGroups(callback)\n        } else if (hasPublicGroups) {\n          return Groups.getAllPublicGroups(function (err, publicGroups) {\n            if (err) return callback(err)\n\n            var mapped = departments.map(function (department) {\n              return department.groups\n            })\n            var merged = _.concat(publicGroups, mapped)\n\n            merged = _.flattenDeep(merged)\n            merged = _.uniqBy(merged, function (i) {\n              return i._id\n            })\n\n            return callback(null, merged)\n          })\n        } else {\n          var groups = _.flattenDeep(\n            departments.map(function (department) {\n              return department.groups\n            })\n          )\n\n          return callback(null, groups)\n        }\n      })\n  })\n}\n\ndepartmentSchema.statics.getDepartmentsByGroup = function (groupId, callback) {\n  var self = this\n\n  return self\n    .model(COLLECTION)\n    .find({ $or: [{ groups: groupId }, { allGroups: true }] })\n    .exec(callback)\n}\n\nmodule.exports = mongoose.model(COLLECTION, departmentSchema)\n", "/*\n *       .                             .o8                     oooo\n *    .o8                             \"888                     `888\n *  .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\n *    888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\n *    888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\n *    888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\n *    \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\n *  ========================================================================\n *  Author:     Chris Brame\n *  Updated:    1/20/19 4:46 PM\n *  Copyright (c) 2014-2019. All rights reserved.\n */\n\nvar _ = require('lodash')\nvar mongoose = require('mongoose')\n\nvar COLLECTION = 'groups'\n\n/**\n * Group Schema\n * @module models/ticket\n * @class Group\n * @requires {@link User}\n *\n * @property {object} _id ```Required``` ```unique``` MongoDB Object ID\n * @property {String} name ```Required``` ```unique``` Name of Group\n * @property {Array} members Members in this group\n * @property {Array} sendMailTo Members to email when a new / updated ticket has triggered\n */\nvar groupSchema = mongoose.Schema({\n  name: { type: String, required: true, unique: true },\n  members: [\n    {\n      type: mongoose.Schema.Types.ObjectId,\n      ref: 'accounts',\n      autopopulate: { select: '-hasL2Auth -preferences -__v' }\n    }\n  ],\n  sendMailTo: [{ type: mongoose.Schema.Types.ObjectId, ref: 'accounts' }],\n  public: { type: Boolean, required: true, default: false }\n})\n\ngroupSchema.plugin(require('mongoose-autopopulate'))\n\ngroupSchema.pre('save', function (next) {\n  this.name = this.name.trim()\n\n  next()\n})\n\ngroupSchema.methods.addMember = function (memberId, callback) {\n  if (_.isUndefined(memberId)) return callback('Invalid MemberId - $Group.AddMember()')\n\n  if (this.members === null) this.members = []\n\n  if (isMember(this.members, memberId)) return callback(null, false)\n\n  this.members.push(memberId)\n  this.members = _.uniq(this.members)\n\n  return callback(null, true)\n}\n\ngroupSchema.methods.removeMember = function (memberId, callback) {\n  if (_.isUndefined(memberId)) return callback('Invalid MemberId - $Group.RemoveMember()')\n\n  if (!isMember(this.members, memberId)) return callback(null, false)\n\n  this.members.splice(_.indexOf(this.members, _.find(this.members, { _id: memberId })), 1)\n\n  this.members = _.uniq(this.members)\n\n  return callback(null, true)\n}\n\ngroupSchema.methods.isMember = function (memberId) {\n  return isMember(this.members, memberId)\n}\n\ngroupSchema.methods.addSendMailTo = function (memberId, callback) {\n  if (_.isUndefined(memberId)) return callback('Invalid MemberId - $Group.AddSendMailTo()')\n\n  if (this.sendMailTo === null) this.sendMailTo = []\n\n  if (isMember(this.sendMailTo, memberId)) return callback(null, false)\n\n  this.sendMailTo.push(memberId)\n  this.sendMailTo = _.uniq(this.sendMailTo)\n\n  return callback(null, true)\n}\n\ngroupSchema.methods.removeSendMailTo = function (memberId, callback) {\n  if (_.isUndefined(memberId)) return callback('Invalid MemberId - $Group.RemoveSendMailTo()')\n\n  if (!isMember(this.sendMailTo, memberId)) return callback(null, false)\n\n  this.sendMailTo.splice(_.indexOf(this.sendMailTo, _.find(this.sendMailTo, { _id: memberId })), 1)\n\n  return callback(null, true)\n}\n\ngroupSchema.statics.getGroupByName = function (name, callback) {\n  if (_.isUndefined(name) || name.length < 1) return callback('Invalid Group Name - GroupSchema.GetGroupByName()')\n\n  var q = this.model(COLLECTION)\n    .findOne({ name: name })\n    .populate('members', '_id username fullname email role preferences image title deleted')\n    .populate('sendMailTo', '_id username fullname email role preferences image title deleted')\n\n  return q.exec(callback)\n}\n\ngroupSchema.statics.getWithObject = function (obj, callback) {\n  var limit = obj.limit ? Number(obj.limit) : 100\n  var page = obj.page ? Number(obj.page) : 0\n  var userId = obj.userId\n\n  if (userId) {\n    return this.model(COLLECTION)\n      .find({ members: userId })\n      .limit(limit)\n      .skip(page * limit)\n      .populate('members', '_id username fullname email role preferences image title deleted')\n      .populate('sendMailTo', '_id username fullname email role preferences image title deleted')\n      .sort('name')\n      .exec(callback)\n  }\n\n  return this.model(COLLECTION)\n    .find({})\n    .limit(limit)\n    .skip(page * limit)\n    .populate('members', '_id username fullname email role preferences image title deleted')\n    .populate('sendMailTo', '_id username fullname email role preferences image title deleted')\n    .sort('name')\n    .exec(callback)\n}\n\ngroupSchema.statics.getAllGroups = function (callback) {\n  var q = this.model(COLLECTION)\n    .find({})\n    .populate('members', '_id username fullname email role preferences image title deleted')\n    .populate('sendMailTo', '_id username fullname email role preferences image title deleted')\n    .sort('name')\n\n  return q.exec(callback)\n}\n\ngroupSchema.statics.getAllGroupsNoPopulate = function (callback) {\n  var q = this.model(COLLECTION)\n    .find({})\n    .sort('name')\n\n  return q.exec(callback)\n}\n\ngroupSchema.statics.getAllPublicGroups = function (callback) {\n  var q = this.model(COLLECTION)\n    .find({ public: true })\n    .sort('name')\n\n  return q.exec(callback)\n}\n\ngroupSchema.statics.getGroups = function (groupIds, callback) {\n  if (_.isUndefined(groupIds)) return callback('Invalid Array of Group IDs - GroupSchema.GetGroups()')\n\n  this.model(COLLECTION)\n    .find({ _id: { $in: groupIds } })\n    .populate('members', '_id username fullname email role preferences image title deleted')\n    .sort('name')\n    .exec(callback)\n}\n\ngroupSchema.statics.getAllGroupsOfUser = function (userId, callback) {\n  if (_.isUndefined(userId)) return callback('Invalid UserId - GroupSchema.GetAllGroupsOfUser()')\n\n  var q = this.model(COLLECTION)\n    .find({ members: userId })\n    .populate('members', '_id username fullname email role preferences image title deleted')\n    .populate('sendMailTo', '_id username fullname email role preferences image title deleted')\n    .sort('name')\n\n  return q.exec(callback)\n}\n\ngroupSchema.statics.getAllGroupsOfUserNoPopulate = function (userId, callback) {\n  if (_.isUndefined(userId)) return callback('Invalid UserId - GroupSchema.GetAllGroupsOfUserNoPopulate()')\n\n  var q = this.model(COLLECTION)\n    .find({ members: userId })\n    .sort('name')\n\n  return q.exec(callback)\n}\n\ngroupSchema.statics.getGroupById = function (gId, callback) {\n  if (_.isUndefined(gId)) return callback('Invalid GroupId - GroupSchema.GetGroupById()')\n\n  var q = this.model(COLLECTION)\n    .findOne({ _id: gId })\n    .populate('members', '_id username fullname email role preferences image title')\n    .populate('sendMailTo', '_id username fullname email role preferences image title')\n\n  return q.exec(callback)\n}\n\nfunction isMember (arr, id) {\n  var matches = _.filter(arr, function (value) {\n    if (value._id.toString() === id.toString()) {\n      return value\n    }\n  })\n\n  return matches.length > 0\n}\n\nmodule.exports = mongoose.model(COLLECTION, groupSchema)\n", "/*\n      .                              .o8                     oooo\n   .o8                             \"888                     `888\n .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\n   888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\n   888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\n   888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\n   \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\n ========================================================================\n */\n\nvar mongoose = require('mongoose')\n\nvar COLLECTION = 'notices'\n\n/**\n * @since 1.0\n * @author Chris Brame <polonel@gmail.com>\n * @copyright 2015 Chris Brame\n **/\n\n/**\n * Notice Object Schema for MongoDB\n * @module models/notice\n * @class Notice\n * @property {String} name ```Required``` Name of the notice\n * @property {Date} date ```Required``` __[default:Date.now]__ Date the notice was created\n * @property {String} color ```Required``` __[default:#e74c3c]__ Color to display the notice in\n * @property {String} message ```Required``` Message of the Notice\n * @property {Boolean} active ```Required``` __[default: false]__ Is the Notice Active?\n */\nvar noticeSchema = mongoose.Schema({\n  name: { type: String, required: true },\n  date: { type: Date, default: Date.now, required: true },\n  color: { type: String, default: '#e74c3c', required: true },\n  fontColor: { type: String, default: '#ffffff', required: true },\n  message: { type: String, required: true },\n  active: { type: Boolean, default: false, required: true },\n  activeDate: { type: Date, default: Date.now },\n  alertWindow: { type: Boolean, default: false }\n})\n\nnoticeSchema.pre('save', function (next) {\n  this.name = this.name.trim()\n\n  return next()\n})\n\nnoticeSchema.statics.getNotices = function (callback) {\n  return this.model(COLLECTION)\n    .find({})\n    .exec(callback)\n}\n\nnoticeSchema.statics.getNotice = function (id, callback) {\n  return this.model(COLLECTION)\n    .findOne({ _id: id })\n    .exec(callback)\n}\n\nnoticeSchema.statics.getNoticeByName = function (name, callback) {\n  return this.model(COLLECTION)\n    .find({ name: name })\n    .exec(callback)\n}\n\nnoticeSchema.statics.getActive = function (callback) {\n  return this.model(COLLECTION)\n    .findOne({ active: true })\n    .exec(callback)\n}\n\nmodule.exports = mongoose.model(COLLECTION, noticeSchema)\n", "/*\n     .                              .o8                     oooo\n   .o8                             \"888                     `888\n .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\n   888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\n   888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\n   888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\n   \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\n ========================================================================\n Created:    10/28/2018\n Author:     Chris Brame\n\n **/\n\nvar mongoose = require('mongoose')\nvar mongooseLeanVirtuals = require('mongoose-lean-virtuals')\nvar _ = require('lodash')\n\nvar COLLECTION = 'roles'\n\nvar roleSchema = mongoose.Schema(\n  {\n    name: { type: String, required: true, unique: true },\n    normalized: String,\n    description: String,\n    grants: [{ type: String, required: true }],\n    hierarchy: { type: Boolean, required: true, default: true }\n  },\n  {\n    toObject: { getters: true, virtuals: true },\n    toJSON: { virtuals: true }\n  }\n)\n\nroleSchema.virtual('isAdmin').get(function () {\n  if (_.isUndefined(global.roles)) return false\n  var role = _.find(global.roles, { normalized: this.normalized })\n  if (!role) return false\n\n  return _.indexOf(role.grants, 'admin:*') !== -1\n})\n\nroleSchema.virtual('isAgent').get(function () {\n  if (_.isUndefined(global.roles)) return false\n  var role = _.find(global.roles, { normalized: this.normalized })\n  if (!role) return false\n\n  return _.indexOf(role.grants, 'agent:*') !== -1\n})\n\nroleSchema.plugin(mongooseLeanVirtuals)\n\nroleSchema.pre('save', function (next) {\n  this.name = this.name.trim()\n  this.normalized = this.name.toLowerCase().trim()\n\n  return next()\n})\n\nroleSchema.methods.updateGrants = function (grants, callback) {\n  this.grants = grants\n  this.save(callback)\n}\n\nroleSchema.methods.updateGrantsAndHierarchy = function (grants, hierarchy, callback) {\n  this.grants = grants\n  this.hierarchy = hierarchy\n  this.save(callback)\n}\n\nroleSchema.statics.getRoles = function (callback) {\n  return this.model(COLLECTION)\n    .find({})\n    .exec(callback)\n}\n\nroleSchema.statics.getRolesLean = function (callback) {\n  return this.model(COLLECTION)\n    .find({})\n    .lean({ virtuals: true })\n    .exec(callback)\n}\n\nroleSchema.statics.getRole = function (id, callback) {\n  var q = this.model(COLLECTION).findOne({ _id: id })\n\n  return q.exec(callback)\n}\n\nroleSchema.statics.getRoleByName = function (name, callback) {\n  var q = this.model(COLLECTION).findOne({ normalized: new RegExp('^' + name.trim() + '$', 'i') })\n\n  return q.exec(callback)\n}\n\nroleSchema.statics.getAgentRoles = function (callback) {\n  var q = this.model(COLLECTION).find({})\n  q.exec(function (err, roles) {\n    if (err) return callback(err)\n\n    var rolesWithAgent = _.filter(roles, function (role) {\n      return _.indexOf(role.grants, 'agent:*') !== -1\n    })\n\n    return callback(null, rolesWithAgent)\n  })\n}\n\n// Alias\nroleSchema.statics.get = roleSchema.statics.getRole\n\nmodule.exports = mongoose.model(COLLECTION, roleSchema)\n", "/*\n *       .                             .o8                     oooo\n *    .o8                             \"888                     `888\n *  .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\n *    888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\n *    888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\n *    888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\n *    \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\n *  ========================================================================\n *  Author:     Chris Brame\n *  Updated:    1/20/19 4:43 PM\n *  Copyright (c) 2014-2019. All rights reserved.\n */\n\nvar mongoose = require('mongoose')\n\nvar COLLECTION = 'tags'\n\n/**\n * Tag Schema\n * @module models/tag\n * @class Tag\n\n *\n * @property {object} _id ```Required``` ```unique``` MongoDB Object ID\n * @property {String} name ```Required``` ```unique``` Name of Tag\n */\nvar tagSchema = mongoose.Schema({\n  name: { type: String, required: true, unique: true },\n  normalized: String\n})\n\ntagSchema.pre('save', function (next) {\n  this.name = this.name.trim()\n  this.normalized = this.name.toLowerCase().trim()\n\n  return next()\n})\n\ntagSchema.statics.getTag = function (id, callback) {\n  var q = this.model(COLLECTION).findOne({ _id: id })\n\n  return q.exec(callback)\n}\n\n/**\n * Return all Tags\n *\n * @memberof Tag\n * @static\n * @method getTags\n *\n * @param {QueryCallback} callback MongoDB Query Callback\n */\ntagSchema.statics.getTags = function (callback) {\n  var q = this.model(COLLECTION)\n    .find({})\n    .sort('normalized')\n\n  return q.exec(callback)\n}\n\ntagSchema.statics.getTagsWithLimit = function (limit, page, callback) {\n  var q = this.model(COLLECTION)\n    .find({})\n    .sort('normalized')\n\n  if (limit !== -1) {\n    q.limit(limit).skip(page * limit)\n  }\n\n  return q.exec(callback)\n}\n\ntagSchema.statics.getTagByName = function (tagName, callback) {\n  var q = this.model(COLLECTION)\n    .find({ name: tagName })\n    .limit(1)\n\n  return q.exec(callback)\n}\n\ntagSchema.statics.tagExist = function (tagName, callback) {\n  var q = this.model(COLLECTION).countDocuments({ name: tagName })\n\n  return q.exec(callback)\n}\n\ntagSchema.statics.getTagCount = function (callback) {\n  var q = this.model(COLLECTION)\n    .countDocuments({})\n    .lean()\n\n  return q.exec(callback)\n}\n\nmodule.exports = mongoose.model(COLLECTION, tagSchema)\n", "/*\n *       .                             .o8                     oooo\n *    .o8                             \"888                     `888\n *  .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\n *    888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\n *    888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\n *    888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\n *    \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\n *  ========================================================================\n *  Author:     Chris Brame\n *  Updated:    3/28/19 2:13 AM\n *  Copyright (c) 2014-2019. All rights reserved.\n */\n\nvar _ = require('lodash')\nvar mongoose = require('mongoose')\n\n// Refs\nrequire('./user')\n\nvar COLLECTION = 'teams'\n\nvar teamSchema = mongoose.Schema({\n  name: { type: String, required: true, unique: true },\n  normalized: { type: String, required: true, unique: true, lowercase: true },\n  members: [\n    {\n      type: mongoose.Schema.Types.ObjectId,\n      ref: 'accounts',\n      autopopulate: { select: '-hasL2Auth -preferences -__v' }\n    }\n  ]\n})\n\nteamSchema.plugin(require('mongoose-autopopulate'))\n\nteamSchema.pre('validate', function () {\n  this.normalized = this.name.trim().toLowerCase()\n})\n\nteamSchema.pre('save', function (next) {\n  this.name = this.name.trim()\n\n  return next()\n})\n\nteamSchema.methods.addMember = function (memberId, callback) {\n  if (_.isUndefined(memberId)) return callback('Invalid MemberId - TeamSchema.AddMember()')\n\n  if (this.members === null) this.members = []\n\n  if (isMember(this.members, memberId)) return callback(null, false)\n\n  this.members.push(memberId)\n  this.members = _.uniq(this.members)\n\n  return callback(null, true)\n}\n\nteamSchema.methods.removeMember = function (memberId, callback) {\n  if (_.isUndefined(memberId)) return callback('Invalid MemberId - TeamSchema.RemoveMember()')\n\n  if (!isMember(this.members, memberId)) return callback(null, false)\n\n  this.members.splice(_.indexOf(this.members, _.find(this.members, { _id: memberId })), 1)\n\n  this.members = _.uniq(this.members)\n\n  return callback(null, true)\n}\n\nteamSchema.methods.isMember = function (memberId) {\n  return isMember(this.members, memberId)\n}\n\nteamSchema.statics.getWithObject = function (obj, callback) {\n  if (!obj) return callback({ message: 'Invalid Team Object - TeamSchema.GetWithObject()' })\n\n  var q = this.model(COLLECTION)\n    .find({})\n    .skip(obj.limit * obj.page)\n    .limit(obj.limit)\n    .sort('name')\n\n  return q.exec(callback)\n}\n\nteamSchema.statics.getTeamByName = function (name, callback) {\n  if (_.isUndefined(name) || name.length < 1) return callback('Invalid Team Name - TeamSchema.GetTeamByName()')\n\n  var q = this.model(COLLECTION).findOne({ normalized: name })\n\n  return q.exec(callback)\n}\n\nteamSchema.statics.getTeams = function (callback) {\n  var q = this.model(COLLECTION)\n    .find({})\n    .sort('name')\n\n  return q.exec(callback)\n}\n\nteamSchema.statics.getTeamsByIds = function (ids, callback) {\n  return this.model(COLLECTION)\n    .find({ _id: { $in: ids } })\n    .sort('name')\n    .exec(callback)\n}\n\nteamSchema.statics.getTeamsNoPopulate = function (callback) {\n  var q = this.model(COLLECTION)\n    .find({})\n    .sort('name')\n\n  return q.exec(callback)\n}\n\nteamSchema.statics.getTeamsOfUser = function (userId, callback) {\n  if (_.isUndefined(userId)) return callback('Invalid UserId - TeamSchema.GetTeamsOfUser()')\n\n  var q = this.model(COLLECTION)\n    .find({ members: userId })\n    .sort('name')\n\n  return q.exec(callback)\n}\n\nteamSchema.statics.getTeamsOfUserNoPopulate = function (userId, callback) {\n  if (_.isUndefined(userId)) return callback('Invalid UserId - TeamSchema.GetTeamsOfUserNoPopulate()')\n\n  var q = this.model(COLLECTION)\n    .find({ members: userId })\n    .sort('name')\n\n  return q.exec(callback)\n}\n\nteamSchema.statics.getTeam = function (id, callback) {\n  if (_.isUndefined(id)) return callback('Invalid TeamId - TeamSchema.GetTeam()')\n\n  var q = this.model(COLLECTION).findOne({ _id: id })\n\n  return q.exec(callback)\n}\n\nfunction isMember (arr, id) {\n  var matches = _.filter(arr, function (value) {\n    if (value._id.toString() === id.toString()) return value\n  })\n\n  return matches.length > 0\n}\n\nmodule.exports = mongoose.model(COLLECTION, teamSchema)\n", "/*\n *       .                             .o8                     oooo\n *    .o8                             \"888                     `888\n *  .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\n *    888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\n *    888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\n *    888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\n *    \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\n *  ========================================================================\n *  Author:     Chris Brame\n *  Updated:    1/20/19 4:43 PM\n *  Copyright (c) 2014-2019. All rights reserved.\n */\n\nvar async = require('async')\nvar mongoose = require('mongoose')\nvar winston = require('winston')\nvar _ = require('lodash')\nvar moment = require('moment')\nvar sanitizeHtml = require('sanitize-html')\n// var redisCache          = require('../cache/rediscache');\nvar xss = require('xss')\n\n// Needed - For Population\nvar groupSchema = require('./group')\nrequire('./tickettype')\nvar userSchema = require('./user')\nvar commentSchema = require('./comment')\nvar noteSchema = require('./note')\nvar attachmentSchema = require('./attachment')\nvar historySchema = require('./history')\nrequire('./tag')\nrequire('./ticketpriority')\n\nvar COLLECTION = 'tickets'\n\n/**\n * Ticket Schema\n * @module models/ticket\n * @class Ticket\n * @requires {@link Group}\n * @requires {@link TicketType}\n * @requires {@link User}\n * @requires {@link Comment}\n * @requires {@link Attachment}\n * @requires {@link History}\n *\n * @property {object} _id ```Required``` ```unique``` MongoDB Object ID\n * @property {Number} uid ```Required``` ```unique``` Readable Ticket ID\n * @property {User} owner ```Required``` Reference to User Object. Owner of this Object.\n * @property {Group} group ```Required``` Group this Ticket is under.\n * @property {User} assignee User currently assigned to this Ticket.\n * @property {Date} date ```Required``` [default: Date.now] Date Ticket was created.\n * @property {Date} updated Date ticket was last updated\n * @property {Boolean} deleted ```Required``` [default: false] If they ticket is flagged as deleted.\n * @property {TicketType} type ```Required``` Reference to the TicketType\n * @property {Number} status ```Required``` [default: 0] Ticket Status. (See {@link Ticket#setStatus})\n * @property {Number} priority ```Required```\n * @property {Array} tags An array of Tags.\n * @property {String} subject ```Required``` The subject of the ticket. (Overview)\n * @property {String} issue ```Required``` Detailed information about the ticket problem/task\n * @property {Date} closedDate show the datetime the ticket was moved to status 3.\n * @property {Array} comments An array of {@link Comment} items\n * @property {Array} notes An array of {@link Comment} items for internal notes\n * @property {Array} attachments An Array of {@link Attachment} items\n * @property {Array} history An array of {@link History} items\n * @property {Array} subscribers An array of user _ids that receive notifications on ticket changes.\n */\nvar ticketSchema = mongoose.Schema({\n  uid: { type: Number, unique: true, index: true },\n  owner: {\n    type: mongoose.Schema.Types.ObjectId,\n    required: true,\n    ref: 'accounts'\n  },\n  group: {\n    type: mongoose.Schema.Types.ObjectId,\n    required: true,\n    ref: 'groups'\n  },\n  assignee: {\n    type: mongoose.Schema.Types.ObjectId,\n    ref: 'accounts'\n  },\n  date: { type: Date, default: Date.now, required: true, index: true },\n  updated: { type: Date },\n  deleted: { type: Boolean, default: false, required: true, index: true },\n  type: {\n    type: mongoose.Schema.Types.ObjectId,\n    required: true,\n    ref: 'tickettypes'\n  },\n  status: { type: Number, default: 0, required: true, index: true },\n\n  priority: {\n    type: mongoose.Schema.Types.ObjectId,\n    ref: 'priorities',\n    required: true\n  },\n  tags: [{ type: mongoose.Schema.Types.ObjectId, ref: 'tags', autopopulate: true }],\n  subject: { type: String, required: true },\n  issue: { type: String, required: true },\n  closedDate: { type: Date },\n  dueDate: { type: Date },\n  comments: [commentSchema],\n  notes: [noteSchema],\n  attachments: [attachmentSchema],\n  history: [historySchema],\n  subscribers: [{ type: mongoose.Schema.Types.ObjectId, ref: 'accounts' }]\n})\n\nticketSchema.index({ deleted: -1, group: 1, status: 1 })\n\nvar autoPopulate = function (next) {\n  this.populate('priority')\n\n  return next()\n}\n\nticketSchema.pre('findOne', autoPopulate).pre('find', autoPopulate)\n\nticketSchema.pre('save', function (next) {\n  this.subject = this.subject.trim()\n  this.wasNew = this.isNew\n\n  if (!_.isUndefined(this.uid) || this.uid) {\n    return next()\n  }\n\n  var c = require('./counters')\n  var self = this\n  c.increment('tickets', function (err, res) {\n    if (err) return next(err)\n\n    self.uid = res.value.next\n\n    if (_.isUndefined(self.uid)) {\n      var error = new Error('Invalid UID.')\n      return next(error)\n    }\n\n    return next()\n  })\n})\n\nticketSchema.post('save', async function (doc, next) {\n  if (!this.wasNew) {\n    var emitter = require('../emitter')\n    try {\n      var savedTicket = await doc.populate([\n        {\n          path: 'owner assignee comments.owner notes.owner subscribers history.owner',\n          select: '_id username fullname email role image title'\n        },\n        { path: 'type tags' },\n        {\n          path: 'group',\n          model: groupSchema,\n          populate: [\n            {\n              path: 'members',\n              model: userSchema,\n              select: '-__v -accessToken -tOTPKey'\n            },\n            {\n              path: 'sendMailTo',\n              model: userSchema,\n              select: '-__v -accessToken -tOTPKey'\n            }\n          ]\n        }\n      ])\n\n      emitter.emit('ticket:updated', savedTicket)\n    } catch (err) {\n      winston.warn('WARNING: ' + err)\n    }\n\n    return next()\n  } else {\n    return next()\n  }\n})\n\nticketSchema.virtual('statusFormatted').get(function () {\n  var s = this.status\n  var formatted\n  switch (s) {\n    case 0:\n      formatted = 'New'\n      break\n    case 1:\n      formatted = 'Open'\n      break\n    case 2:\n      formatted = 'Pending'\n      break\n    case 3:\n      formatted = 'Closed'\n      break\n    default:\n      formatted = 'New'\n  }\n\n  return formatted\n})\n\nticketSchema.virtual('commentsAndNotes').get(function () {\n  _.each(this.comments, function (i) {\n    i.isComment = true\n  })\n  _.each(this.notes, function (i) {\n    i.isNote = true\n  })\n  var combined = _.union(this.comments, this.notes)\n  combined = _.sortBy(combined, 'date')\n\n  return combined\n})\n\n/**\n * Set Status on Instanced Ticket\n * @instance\n * @method setStatus\n * @memberof Ticket\n *\n * @param {Object} ownerId Account ID preforming this action\n * @param {Number} status Status to set\n * @param {TicketCallback} callback Callback with the updated ticket.\n *\n * @example\n * Status:\n *      0 - New\n *      1 - Open\n *      2 - Pending\n *      3 - Closed\n */\nticketSchema.methods.setStatus = function (ownerId, status, callback) {\n  if (_.isUndefined(status)) return callback('Invalid Status', null)\n\n  var self = this\n\n  if (status === 3) {\n    self.closedDate = new Date()\n  } else {\n    self.closedDate = null\n  }\n\n  self.status = status\n  var historyItem = {\n    action: 'ticket:set:status:' + status,\n    description: 'Ticket Status set to: ' + statusToString(status),\n    owner: ownerId\n  }\n  self.history.push(historyItem)\n\n  callback(null, self)\n}\n\n/**\n * Set Assignee on Instanced Ticket\n * @instance\n * @method setAssignee\n * @memberof Ticket\n *\n * @param {Object} ownerId Account ID preforming this action\n * @param {Object} userId User ID to set as assignee\n * @param {TicketCallback} callback Callback with the updated ticket.\n */\nticketSchema.methods.setAssignee = function (ownerId, userId, callback) {\n  if (_.isUndefined(userId)) return callback('Invalid User Id', null)\n  var permissions = require('../permissions')\n  var self = this\n\n  self.assignee = userId\n  userSchema.getUser(userId, function (err, user) {\n    if (err) return callback(err, null)\n\n    if (!permissions.canThis(user.role, 'tickets:update') && !permissions.canThis(user.role, 'agent:*')) {\n      return callback('User does not have permission to be set as an assignee.', null)\n    }\n\n    var historyItem = {\n      action: 'ticket:set:assignee',\n      description: user.fullname + ' was set as assignee',\n      owner: ownerId\n    }\n\n    self.history.push(historyItem)\n\n    return callback(null, self)\n  })\n}\n\n/**\n * Clear the current assignee\n * @instance\n * @method clearAssignee\n * @memberof Ticket\n *\n * @param {Object} ownerId Account ID preforming this action\n * @param {TicketCallback} callback Callback with the updated ticket.\n */\nticketSchema.methods.clearAssignee = function (ownerId, callback) {\n  var self = this\n  self.assignee = undefined\n  var historyItem = {\n    action: 'ticket:set:assignee',\n    description: 'Assignee was cleared',\n    owner: ownerId\n  }\n  self.history.push(historyItem)\n  callback(null, self)\n}\n\n/**\n * Sets the ticket type for the instanced Ticket\n * @instance\n * @method setTicketType\n * @memberof Ticket\n *\n * @param {Object} ownerId Account ID preforming this action\n * @param {Object} typeId TicketType Id to set as ticket type\n * @param {TicketCallback} callback Callback with the updated ticket.\n */\nticketSchema.methods.setTicketType = function (ownerId, typeId, callback) {\n  var typeSchema = require('./tickettype')\n  var self = this\n  self.type = typeId\n  typeSchema.findOne({ _id: typeId }, function (err, type) {\n    if (err) return callback(err)\n    if (!type) return callback('Invalid Type Id: ' + typeId)\n\n    var historyItem = {\n      action: 'ticket:set:type',\n      description: 'Ticket type set to: ' + type.name,\n      owner: ownerId\n    }\n\n    self.history.push(historyItem)\n\n    if (typeof callback === 'function') return callback(null, self)\n  })\n}\n\n/**\n * Sets the ticket priority\n * @instance\n * @method setTicketPriority\n * @memberof Ticket\n *\n * @param {Object} ownerId Account ID preforming this action\n * @param {Number} priority Priority to set\n * @param {TicketCallback} callback Callback with the updated ticket.\n */\nticketSchema.methods.setTicketPriority = function (ownerId, priority, callback) {\n  if (_.isUndefined(priority) || !_.isObject(priority)) return callback('Priority must be a PriorityObject.', null)\n\n  var self = this\n  self.priority = priority._id\n  var historyItem = {\n    action: 'ticket:set:priority',\n    description: 'Ticket Priority set to: ' + priority.name,\n    owner: ownerId\n  }\n  self.history.push(historyItem)\n\n  self\n    .populate(['priority'])\n    .then(function (updatedSelf) {\n      return callback(null, updatedSelf)\n    })\n    .catch(function (err) {\n      return callback(err, null)\n    })\n}\n\n/**\n * Sets this ticket under the given group Id\n * @instance\n * @method setTicketGroup\n * @memberof Ticket\n *\n * @param {Object} ownerId Account ID preforming this action\n * @param {Object} groupId MongoDB group Id to assign this ticket to\n * @param {TicketCallback} callback Callback with the updated ticket.\n */\nticketSchema.methods.setTicketGroup = function (ownerId, groupId, callback) {\n  var self = this\n  self.group = groupId\n\n  self.populate('group', function (err, ticket) {\n    if (err) return callback(err)\n\n    var historyItem = {\n      action: 'ticket:set:group',\n      description: 'Ticket Group set to: ' + ticket.group.name,\n      owner: ownerId\n    }\n    self.history.push(historyItem)\n\n    return callback(null, ticket)\n  })\n}\n\nticketSchema.methods.setTicketDueDate = function (ownerId, dueDate, callback) {\n  var self = this\n  self.dueDate = dueDate\n\n  var historyItem = {\n    action: 'ticket:set:duedate',\n    description: 'Ticket Due Date set to: ' + self.dueDate,\n    owner: ownerId\n  }\n\n  self.history.push(historyItem)\n\n  return callback(null, self)\n}\n\n/**\n * Sets this ticket's issue text\n * @instance\n * @method setIssue\n * @memberof Ticket\n *\n * @param {Object} ownerId Account ID preforming this action\n * @param {Object} issue Issue text to set on the ticket\n * @param {TicketCallback} callback Callback with the updated ticket.\n * @example\n * ticket.setIssue({ownerId}, 'This is the new issue string.', function(err, t) {\n *    if (err) throw err;\n *\n *    ticket.save(function(err, t) {\n *       if (err) throw err;\n *    });\n * });\n */\nticketSchema.methods.setIssue = function (ownerId, issue, callback) {\n  var marked = require('marked')\n\n  var self = this\n  issue = issue.replace(/(\\r\\n|\\n\\r|\\r|\\n)/g, '<br>')\n  issue = sanitizeHtml(issue).trim()\n  self.issue = xss(marked.parse(issue))\n\n  var historyItem = {\n    action: 'ticket:update:issue',\n    description: 'Ticket Issue was updated.',\n    owner: ownerId\n  }\n\n  self.history.push(historyItem)\n\n  return callback(null, self)\n}\n\nticketSchema.methods.setSubject = function (ownerId, subject, callback) {\n  var self = this\n  self.subject = subject\n  var historyItem = {\n    action: 'ticket:update:subject',\n    description: 'Ticket Subject was updated.',\n    owner: ownerId\n  }\n\n  self.history.push(historyItem)\n\n  return callback(null, self)\n}\n\n/**\n * Updates a given comment inside the comment array on this ticket\n * @instance\n * @method updateComment\n * @memberof Ticket\n *\n * @param {Object} ownerId Account ID preforming this action\n * @param {Object} commentId Comment ID to update\n * @param {String} commentText Text to update the comment to\n * @param {TicketCallback} callback Callback with the updated ticket.\n * @example\n * ticket.updateComment({ownerId}, {commentId} 'This is the new comment string.', function(err, t) {\n *    if (err) throw err;\n *\n *    ticket.save(function(err, t) {\n *       if (err) throw err;\n *    });\n * });\n */\nticketSchema.methods.updateComment = function (ownerId, commentId, commentText, callback) {\n  var self = this\n  var comment = _.find(self.comments, function (c) {\n    return c._id.toString() === commentId.toString()\n  })\n  if (_.isUndefined(comment)) return callback('Invalid Comment', null)\n\n  comment.comment = commentText\n\n  var historyItem = {\n    action: 'ticket:comment:updated',\n    description: 'Comment was updated: ' + commentId,\n    owner: ownerId\n  }\n  self.history.push(historyItem)\n\n  return callback(null, self)\n}\n\n/**\n * Removes a comment from the comment array on this ticket.\n * @instance\n * @method removeComment\n * @memberof Ticket\n *\n * @param {Object} ownerId Account ID preforming this action\n * @param {Object} commentId Comment ID to remove\n * @param {TicketCallback} callback Callback with the updated ticket.\n */\nticketSchema.methods.removeComment = function (ownerId, commentId, callback) {\n  var self = this\n  self.comments = _.reject(self.comments, function (o) {\n    return o._id.toString() === commentId.toString()\n  })\n\n  var historyItem = {\n    action: 'ticket:delete:comment',\n    description: 'Comment was deleted: ' + commentId,\n    owner: ownerId\n  }\n  self.history.push(historyItem)\n\n  return callback(null, self)\n}\n\n/**\n * Updates a given Note inside the note array on this ticket\n * @instance\n * @method updateNote\n * @memberof Ticket\n *\n * @param {Object} ownerId Account ID preforming this action\n * @param {Object} noteId Note ID to update\n * @param {String} noteText Text to update the note to\n * @param {TicketCallback} callback Callback with the updated ticket.\n * @example\n * ticket.updateNote({ownerId}, {noteId} 'This is the new note string.', function(err, t) {\n *    if (err) throw err;\n *\n *    ticket.save(function(err, t) {\n *       if (err) throw err;\n *    });\n * });\n */\nticketSchema.methods.updateNote = function (ownerId, noteId, noteText, callback) {\n  var self = this\n  var note = _.find(self.notes, function (c) {\n    return c._id.toString() === noteId.toString()\n  })\n  if (_.isUndefined(note)) return callback('Invalid Note', null)\n\n  note.note = noteText\n\n  var historyItem = {\n    action: 'ticket:note:updated',\n    description: 'Note was updated: ' + noteId,\n    owner: ownerId\n  }\n  self.history.push(historyItem)\n\n  return callback(null, self)\n}\n\n/**\n * Removes a note from the note array on this ticket.\n * @instance\n * @method removeNote\n * @memberof Ticket\n *\n * @param {Object} ownerId Account ID preforming this action\n * @param {Object} noteId Comment ID to remove\n * @param {TicketCallback} callback Callback with the updated ticket.\n */\nticketSchema.methods.removeNote = function (ownerId, noteId, callback) {\n  var self = this\n  self.notes = _.reject(self.notes, function (o) {\n    return o._id.toString() === noteId.toString()\n  })\n\n  var historyItem = {\n    action: 'ticket:delete:note',\n    description: 'Note was deleted: ' + noteId,\n    owner: ownerId\n  }\n  self.history.push(historyItem)\n\n  return callback(null, self)\n}\n\nticketSchema.methods.getAttachment = function (attachmentId, callback) {\n  var self = this\n  var attachment = _.find(self.attachments, function (o) {\n    return o._id.toString() === attachmentId.toString()\n  })\n\n  return callback(attachment)\n}\n\nticketSchema.methods.removeAttachment = function (ownerId, attachmentId, callback) {\n  var self = this\n  var attachment = _.find(self.attachments, function (o) {\n    return o._id.toString() === attachmentId.toString()\n  })\n  self.attachments = _.reject(self.attachments, function (o) {\n    return o._id.toString() === attachmentId.toString()\n  })\n\n  if (_.isUndefined(attachment)) {\n    return callback(null, self)\n  }\n\n  var historyItem = {\n    action: 'ticket:delete:attachment',\n    description: 'Attachment was deleted: ' + attachment.name,\n    owner: ownerId\n  }\n\n  self.history.push(historyItem)\n\n  return callback(null, self)\n}\n\nticketSchema.methods.addSubscriber = function (userId, callback) {\n  var self = this\n\n  var hasSub = _.some(self.subscribers, function (i) {\n    return i._id.toString() === userId.toString()\n  })\n\n  if (!hasSub) {\n    self.subscribers.push(userId)\n  }\n\n  return callback(null, self)\n}\n\nticketSchema.methods.removeSubscriber = function (userId, callback) {\n  var self = this\n\n  var user = _.find(self.subscribers, function (i) {\n    return i._id.toString() === userId.toString()\n  })\n\n  if (_.isUndefined(user) || _.isEmpty(user) || _.isNull(user)) return callback(null, self)\n\n  self.subscribers = _.reject(self.subscribers, function (i) {\n    return i._id.toString() === userId.toString()\n  })\n\n  return callback(null, self)\n}\n\n/**\n * Gets all tickets that are not marked as deleted <br> <br>\n *\n * **Deep populates: group, group.members, group.sendMailTo, comments, comments.owner**\n *\n * @memberof Ticket\n * @static\n * @method getAll\n * @param {QueryCallback} callback MongoDB Query Callback\n *\n * @example\n * ticketSchema.getAll(function(err, tickets) {\n *    if (err) throw err;\n *\n *    //tickets is an array\n * });\n */\nticketSchema.statics.getAll = function (callback) {\n  var self = this\n  var q = self\n    .model(COLLECTION)\n    .find({ deleted: false })\n    .populate('owner assignee', '-password -__v -preferences -iOSDeviceTokens -tOTPKey')\n    .populate('type tags group')\n    .sort({ status: 1 })\n    .lean()\n\n  return q.exec(callback)\n}\n\nticketSchema.statics.getForCache = function (callback) {\n  var self = this\n  var t365 = moment\n    .utc()\n    .hour(23)\n    .minute(59)\n    .second(59)\n    .subtract(365, 'd')\n    .toDate()\n  self\n    .model(COLLECTION)\n    .find({ date: { $gte: t365 }, deleted: false })\n    .select('_id uid date status history comments assignee owner tags')\n    .sort('date')\n    .lean()\n    .exec(callback)\n}\n\nticketSchema.statics.getAllNoPopulate = function (callback) {\n  var self = this\n  var q = self\n    .model(COLLECTION)\n    .find({ deleted: false })\n    .sort({ status: 1 })\n    .lean()\n\n  return q.exec(callback)\n}\n\nticketSchema.statics.getAllByStatus = function (status, callback) {\n  var self = this\n\n  if (!_.isArray(status)) {\n    status = [status]\n  }\n\n  var q = self\n    .model(COLLECTION)\n    .find({ status: { $in: status }, deleted: false })\n    .populate(\n      'owner assignee comments.owner notes.owner subscribers history.owner',\n      'username fullname email role image title'\n    )\n    .populate('type tags group')\n    .sort({ status: 1 })\n    .lean()\n\n  return q.exec(callback)\n}\n\n/**\n * Gets Tickets with a given group id.\n *\n * @memberof Ticket\n * @static\n * @method getTickets\n * @param {Array} grpIds Group Id to retrieve tickets for.\n * @param {QueryCallback} callback MongoDB Query Callback\n */\nticketSchema.statics.getTickets = function (grpIds, callback) {\n  if (_.isUndefined(grpIds)) {\n    return callback('Invalid GroupId - TicketSchema.GetTickets()', null)\n  }\n\n  if (!_.isArray(grpIds)) {\n    return callback('Invalid GroupId (Must be of type Array) - TicketSchema.GetTickets()', null)\n  }\n\n  var self = this\n\n  var q = self\n    .model(COLLECTION)\n    .find({ group: { $in: grpIds }, deleted: false })\n    .populate(\n      'owner assignee comments.owner notes.owner subscribers history.owner',\n      'username fullname email role image title'\n    )\n    .populate('type tags group')\n    .sort({ status: 1 })\n\n  return q.exec(callback)\n}\n\n/**\n * Gets Tickets with a given group id and a JSON Object <br/><br/>\n * *Sorts on UID desc.*\n * @memberof Ticket\n * @static\n * @method getTicketsWithObject\n *\n * @param {Object} grpId Group Id to retrieve tickets for.\n * @param {Object} object JSON Object with various options\n * @param {QueryCallback} callback MongoDB Query Callback\n *\n * @example\n * //Object Options\n * {\n *    limit: 10,\n *    page: 0,\n *    closed: false,\n *    status: 1\n * }\n */\nticketSchema.statics.getTicketsByDepartments = function (departments, object, callback) {\n  if (!departments || !_.isObject(departments) || !object)\n    return callback('Invalid Data - TicketSchema.GetTicketsByDepartments()')\n\n  var self = this\n\n  if (_.some(departments, { allGroups: true })) {\n    groupSchema.find({}, function (err, groups) {\n      if (err) return callback({ error: err })\n      return self.getTicketsWithObject(groups, object, callback)\n    })\n  } else {\n    var groups = _.flattenDeep(\n      departments.map(function (d) {\n        return d.groups.map(function (g) {\n          return g._id\n        })\n      })\n    )\n\n    return self.getTicketsWithObject(groups, object, callback)\n  }\n}\n\nticketSchema.statics.getTicketsWithObject = function (grpId, object, callback) {\n  if (_.isUndefined(grpId)) {\n    return callback('Invalid GroupId - TicketSchema.GetTickets()', null)\n  }\n\n  if (!_.isArray(grpId)) {\n    return callback('Invalid GroupId (Must be of type Array) - TicketSchema.GetTicketsWithObject()', null)\n  }\n\n  if (!_.isObject(object)) {\n    return callback('Invalid Object (Must be of type Object) - TicketSchema.GetTicketsWithObject()', null)\n  }\n\n  var self = this\n\n  var limit = !object.limit ? 10 : object.limit\n  var page = !object.page ? 0 : object.page\n  var _status = object.status\n\n  if (!_.isUndefined(object.filter) && !_.isUndefined(object.filter.groups)) {\n    var g = _.map(grpId, '_id').map(String)\n    grpId = _.intersection(object.filter.groups, g)\n  }\n\n  var q = self\n    .model(COLLECTION)\n    .find({ group: { $in: grpId }, deleted: false })\n    .populate(\n      'owner assignee subscribers comments.owner notes.owner history.owner',\n      'username fullname email role image title'\n    )\n    .populate('assignee', 'username fullname email role image title')\n    .populate('type tags group')\n    .sort({ uid: -1 })\n\n  if (limit !== -1) {\n    q.skip(page * limit).limit(limit)\n  }\n\n  if (_.isArray(_status) && _.size(_status) > 0) {\n    q.where({ status: { $in: _status } })\n  }\n\n  if (!_.isUndefined(object.filter)) {\n    if (!_.isUndefined(object.filter.uid)) {\n      object.filter.uid = parseInt(object.filter.uid)\n      if (!_.isNaN(object.filter.uid)) {\n        q.or([{ uid: object.filter.uid }])\n      }\n    }\n\n    if (!_.isUndefined(object.filter.priority)) {\n      q.where({ priority: { $in: object.filter.priority } })\n    }\n\n    if (!_.isUndefined(object.filter.types)) {\n      q.where({ type: { $in: object.filter.types } })\n    }\n\n    if (!_.isUndefined(object.filter.tags)) {\n      q.where({ tags: { $in: object.filter.tags } })\n    }\n\n    if (!_.isUndefined(object.filter.assignee)) {\n      q.where({ assignee: { $in: object.filter.assignee } })\n    }\n\n    if (!_.isUndefined(object.filter.unassigned)) {\n      q.where({ assignee: { $exists: false } })\n    }\n\n    if (!_.isUndefined(object.filter.owner)) {\n      q.where({ owner: { $in: object.filter.owner } })\n    }\n\n    if (!_.isUndefined(object.filter.subject)) {\n      q.or([{ subject: new RegExp(object.filter.subject, 'i') }])\n    }\n\n    if (!_.isUndefined(object.filter.issue)) {\n      q.or([{ issue: new RegExp(object.filter.issue, 'i') }])\n    }\n\n    if (!_.isUndefined(object.filter.date)) {\n      var startDate = new Date(2000, 0, 1, 0, 0, 1)\n      var endDate = new Date()\n      if (!_.isUndefined(object.filter.date.start)) {\n        startDate = new Date(object.filter.date.start)\n      }\n      if (!_.isUndefined(object.filter.date.end)) {\n        endDate = new Date(object.filter.date.end)\n      }\n\n      q.where({ date: { $gte: startDate, $lte: endDate } })\n    }\n  }\n\n  if (!_.isUndefined(object.owner) && !_.isNull(object.owner)) q.where('owner', object.owner)\n\n  if (!_.isUndefined(object.assignedSelf) && !_.isNull(object.assignedSelf)) q.where('assignee', object.user)\n  if (!_.isUndefined(object.unassigned) && !_.isNull(object.unassigned)) q.where({ assignee: { $exists: false } })\n\n  return q.exec(callback)\n}\n\nticketSchema.statics.getCountWithObject = function (grpId, object, callback) {\n  if (_.isUndefined(grpId)) {\n    return callback('Invalid GroupId - TicketSchema.GetCountWithObject()', null)\n  }\n\n  if (!_.isArray(grpId)) {\n    return callback('Invalid GroupId (Must be of type Array) - TicketSchema.GetCountWithObject()', null)\n  }\n\n  if (!_.isObject(object)) {\n    return callback('Invalid Object (Must be of type Object) - TicketSchema.GetCountWithObject()', null)\n  }\n\n  var self = this\n\n  if (!_.isUndefined(object.filter) && !_.isUndefined(object.filter.groups)) {\n    var g = _.map(grpId, '_id').map(String)\n    grpId = _.intersection(object.filter.groups, g)\n  }\n\n  var q = self.model(COLLECTION).countDocuments({ group: { $in: grpId }, deleted: false })\n  if (!_.isUndefined(object.status) && _.isArray(object.status)) {\n    var status = object.status.map(Number)\n    q.where({ status: { $in: status } })\n  }\n\n  if (!_.isUndefined(object.filter) && !_.isUndefined(object.filter.assignee)) {\n    q.where({ assignee: { $in: object.filter.assignee } })\n  }\n\n  if (!_.isUndefined(object.filter) && !_.isUndefined(object.filter.types)) {\n    q.where({ type: { $in: object.filter.types } })\n  }\n\n  if (!_.isUndefined(object.filter) && !_.isUndefined(object.filter.subject))\n    q.where({ subject: new RegExp(object.filter.subject, 'i') })\n\n  if (\n    !_.isUndefined(object.assignedSelf) &&\n    object.assignedSelf === true &&\n    !_.isUndefined(object.assignedUserId) &&\n    !_.isNull(object.assignedUserId)\n  ) {\n    q.where('assignee', object.assignedUserId)\n  }\n\n  if (!_.isUndefined(object.unassigned) && object.unassigned === true) {\n    q.where({ assignee: { $exists: false } })\n  }\n\n  if (!_.isUndefined(object.owner) && !_.isNull(object.owner)) q.where('owner', object.owner)\n\n  return q.lean().exec(callback)\n}\n\n/**\n * Gets Tickets for status in given group. <br/><br/>\n * *Sorts on UID desc*\n * @memberof Ticket\n * @static\n * @method getTicketsByStatus\n *\n * @param {Object} grpId Group Id to retrieve tickets for.\n * @param {Number} status Status number to check\n * @param {QueryCallback} callback MongoDB Query Callback\n */\nticketSchema.statics.getTicketsByStatus = function (grpId, status, callback) {\n  if (_.isUndefined(grpId)) {\n    return callback('Invalid GroupId - TicketSchema.GetTickets()', null)\n  }\n\n  if (!_.isArray(grpId)) {\n    return callback('Invalid GroupId (Must be of type Array) - TicketSchema.GetTickets()', null)\n  }\n\n  var self = this\n\n  var q = self\n    .model(COLLECTION)\n    .find({ group: { $in: grpId }, status: status, deleted: false })\n    .populate(\n      'owner assignee comments.owner notes.owner subscribers history.owner',\n      'username fullname email role image title'\n    )\n    .populate('type tags group')\n    .sort({ uid: -1 })\n\n  return q.exec(callback)\n}\n\n/**\n * Gets Single ticket with given UID.\n * @memberof Ticket\n * @static\n * @method getTicketByUid\n *\n * @param {Number} uid Unique Id for ticket.\n * @param {QueryCallback} callback MongoDB Query Callback\n */\nticketSchema.statics.getTicketByUid = function (uid, callback) {\n  if (_.isUndefined(uid)) return callback('Invalid Uid - TicketSchema.GetTicketByUid()', null)\n\n  var self = this\n\n  var q = self\n    .model(COLLECTION)\n    .findOne({ uid: uid, deleted: false })\n    .populate(\n      'owner assignee comments.owner notes.owner subscribers history.owner',\n      'username fullname email role image title'\n    )\n    .populate('type tags group')\n\n  return q.exec(callback)\n}\n\n/**\n * Gets Single ticket with given object _id.\n * @memberof Ticket\n * @static\n * @method getTicketById\n *\n * @param {Object} id MongoDb _id.\n * @param {QueryCallback} callback MongoDB Query Callback\n */\nticketSchema.statics.getTicketById = function (id, callback) {\n  if (_.isUndefined(id)) return callback('Invalid Id - TicketSchema.GetTicketById()', null)\n\n  var self = this\n\n  var q = self\n    .model(COLLECTION)\n    .findOne({ _id: id, deleted: false })\n    .populate(\n      'owner assignee comments.owner notes.owner subscribers history.owner',\n      'username fullname email role image title'\n    )\n    .populate('type tags')\n    .populate({\n      path: 'group',\n      model: groupSchema,\n      populate: [\n        {\n          path: 'members',\n          model: userSchema,\n          select: '-__v -iOSDeviceTokens -accessToken -tOTPKey'\n        },\n        {\n          path: 'sendMailTo',\n          model: userSchema,\n          select: '-__v -iOSDeviceTokens -accessToken -tOTPKey'\n        }\n      ]\n    })\n\n  return q.exec(callback)\n}\n\n/**\n * Gets tickets by given Requester User Id\n * @memberof Ticket\n * @static\n * @method getTicketsByRequester\n *\n * @param {Object} userId MongoDb _id of user.\n * @param {QueryCallback} callback MongoDB Query Callback\n */\nticketSchema.statics.getTicketsByRequester = function (userId, callback) {\n  if (_.isUndefined(userId)) return callback('Invalid Requester Id - TicketSchema.GetTicketsByRequester()', null)\n\n  var self = this\n\n  var q = self\n    .model(COLLECTION)\n    .find({ owner: userId, deleted: false })\n    .limit(10000)\n    .populate(\n      'owner assignee comments.owner notes.owner subscribers history.owner',\n      'username fullname email role image title'\n    )\n    .populate('type tags')\n    .populate({\n      path: 'group',\n      model: groupSchema,\n      populate: [\n        {\n          path: 'members',\n          model: userSchema,\n          select: '-__v -iOSDeviceTokens -accessToken -tOTPKey'\n        },\n        {\n          path: 'sendMailTo',\n          model: userSchema,\n          select: '-__v -iOSDeviceTokens -accessToken -tOTPKey'\n        }\n      ]\n    })\n\n  return q.exec(callback)\n}\n\nticketSchema.statics.getTicketsWithSearchString = function (grps, search, callback) {\n  if (_.isUndefined(grps) || _.isUndefined(search))\n    return callback('Invalid Post Data - TicketSchema.GetTicketsWithSearchString()', null)\n\n  var self = this\n\n  var tickets = []\n\n  async.parallel(\n    [\n      function (callback) {\n        var q = self\n          .model(COLLECTION)\n          .find({\n            group: { $in: grps },\n            deleted: false,\n            $where: '/^' + search + '.*/.test(this.uid)'\n          })\n          .populate(\n            'owner assignee comments.owner notes.owner subscribers history.owner',\n            'username fullname email role image title'\n          )\n          .populate('type tags group')\n          .limit(100)\n\n        q.exec(function (err, results) {\n          if (err) return callback(err)\n          tickets.push(results)\n\n          return callback(null)\n        })\n      },\n      function (callback) {\n        var q = self\n          .model(COLLECTION)\n          .find({\n            group: { $in: grps },\n            deleted: false,\n            subject: { $regex: search, $options: 'i' }\n          })\n          .populate(\n            'owner assignee comments.owner notes.owner subscribers history.owner',\n            'username fullname email role image title'\n          )\n          .populate('type tags group')\n          .limit(100)\n\n        q.exec(function (err, results) {\n          if (err) return callback(err)\n          tickets.push(results)\n\n          return callback(null)\n        })\n      },\n      function (callback) {\n        var q = self\n          .model(COLLECTION)\n          .find({\n            group: { $in: grps },\n            deleted: false,\n            issue: { $regex: search, $options: 'i' }\n          })\n          .populate(\n            'owner assignee comments.owner notes.owner subscribers history.owner',\n            'username fullname email role image title'\n          )\n          .populate('type tags group')\n          .limit(100)\n\n        q.exec(function (err, results) {\n          if (err) return callback(err)\n          tickets.push(results)\n\n          return callback(null)\n        })\n      }\n    ],\n    function (err) {\n      if (err) return callback(err, null)\n\n      var t = _.uniqBy(_.flatten(tickets), function (i) {\n        return i.uid\n      })\n\n      return callback(null, t)\n    }\n  )\n}\n\n/**\n * Gets tickets that are overdue\n * @memberof Ticket\n * @static\n * @method getOverdue\n *\n * @param {Array} grpId Group Array of User\n * @param {QueryCallback} callback MongoDB Query Callback\n */\nticketSchema.statics.getOverdue = function (grpId, callback) {\n  if (_.isUndefined(grpId)) return callback('Invalid Group Ids - TicketSchema.GetOverdue()', null)\n\n  var self = this\n\n  // Disable cache (TEMP 01/04/2019)\n  // var grpHash = hash(grpId);\n  // var cache = global.cache;\n  // if (cache) {\n  //     var overdue = cache.get('tickets:overdue:' + grpHash);\n  //     if (overdue)\n  //         return callback(null, overdue);\n  // }\n\n  async.waterfall(\n    [\n      function (next) {\n        return self\n          .model(COLLECTION)\n          .find({\n            group: { $in: grpId },\n            status: { $in: [0, 1] },\n            deleted: false\n          })\n          .select('_id date updated')\n          .lean()\n          .exec(next)\n      },\n      function (tickets, next) {\n        var t = _.map(tickets, function (i) {\n          return _.transform(\n            i,\n            function (result, value, key) {\n              if (key === '_id') result._id = value\n              if (key === 'priority') result.overdueIn = value.overdueIn\n              if (key === 'date') result.date = value\n              if (key === 'updated') result.updated = value\n            },\n            {}\n          )\n        })\n\n        return next(null, t)\n      },\n      function (tickets, next) {\n        var now = new Date()\n        var ids = _.filter(tickets, function (t) {\n          if (!t.date && !t.updated) {\n            return false\n          }\n\n          var timeout = null\n          if (t.updated) {\n            var updated = new Date(t.updated)\n            timeout = new Date(updated)\n            timeout.setMinutes(updated.getMinutes() + t.overdueIn)\n          } else {\n            var date = new Date(t.date)\n            timeout = new Date(date)\n            timeout.setMinutes(date.getMinutes() + t.overdueIn)\n          }\n\n          return now > timeout\n        })\n\n        ids = _.map(ids, '_id')\n\n        return next(null, ids)\n      },\n      function (ids, next) {\n        return self\n          .model(COLLECTION)\n          .find({ _id: { $in: ids } })\n          .limit(50)\n          .select('_id uid subject updated date')\n          .lean()\n          .exec(next)\n      }\n    ],\n    function (err, tickets) {\n      if (err) return callback(err, null)\n      // Disable cache (TEMP 01/04/2019)\n      // if (cache) cache.set('tickets:overdue:' + grpHash, tickets, 600); //10min\n\n      return callback(null, tickets)\n    }\n  )\n\n  // var q = self.model(COLLECTION).find({group: {$in: grpId}, status: {$in: [0,1]}, deleted: false})\n  //     .$where(function() {\n  //         return this.priority.overdueIn === undefined;\n  //         var now = new Date();\n  //         var timeout = null;\n  //         if (this.updated) {\n  //             timeout = new Date(this.updated);\n  //             timeout.setMinutes(timeout.getMinutes() + this.priority.overdueIn);\n  //         } else {\n  //             timeout = new Date(this.date);\n  //             timeout.setMinutes(timeout.getMinutes() + this.priority.overdueIn);\n  //         }\n  //         return now > timeout;\n  //     }).select('_id uid subject updated');\n  //\n  // q.lean().exec(function(err, results) {\n  //     if (err) return callback(err, null);\n  //     if (cache) cache.set('tickets:overdue:' + grpHash, results, 600); //10min\n  //\n  //     return callback(null, results);\n  // });\n\n  // TODO: Turn on when REDIS is impl\n  // This will be pres through server reload\n  // redisCache.getCache('$trudesk:tickets:overdue' + grpHash, function(err, value) {\n  //     if (err) return callback(err, null);\n  //     if (value) {\n  //         console.log('served from redis');\n  //         return callback(null, JSON.parse(value.data));\n  //     } else {\n  //         var q = self.model(COLLECTION).find({group: {$in: grpId}, status: 1, deleted: false})\n  //             .$where(function() {\n  //                 var now = new Date();\n  //                 var updated = new Date(this.updated);\n  //                 var timeout = new Date(updated);\n  //                 timeout.setDate(timeout.getDate() + 2);\n  //                 return now > timeout;\n  //             }).select('_id uid subject updated');\n  //\n  //         return q.lean().exec(function(err, results) {\n  //             if (err) return callback(err, null);\n  //             if (cache) {\n  //                 cache.set('tickets:overdue:' + grpHash, results, 600);\n  //             }\n  //             redisCache.setCache('tickets:' + grpHash, results, function(err) {\n  //                 return callback(err, results);\n  //             }, 600);\n  //         });\n  //     }\n  // });\n}\n\n/**\n * Gets tickets via tag id\n * @memberof Ticket\n * @static\n * @method getTicketsByTag\n *\n * @param {Array} grpId Group Array of User\n * @param {string} tagId Tag Id\n * @param {QueryCallback} callback MongoDB Query Callback\n */\nticketSchema.statics.getTicketsByTag = function (grpId, tagId, callback) {\n  if (_.isUndefined(grpId)) return callback('Invalid Group Ids - TicketSchema.GetTicketsByTag()', null)\n  if (_.isUndefined(tagId)) return callback('Invalid Tag Id - TicketSchema.GetTicketsByTag()', null)\n\n  var self = this\n\n  var q = self.model(COLLECTION).find({ group: { $in: grpId }, tags: tagId, deleted: false })\n\n  return q.exec(callback)\n}\n\n/**\n * Gets all tickets via tag id\n * @memberof Ticket\n * @static\n * @method getAllTicketsByTag\n *\n * @param {string} tagId Tag Id\n * @param {QueryCallback} callback MongoDB Query Callback\n */\nticketSchema.statics.getAllTicketsByTag = function (tagId, callback) {\n  if (_.isUndefined(tagId)) return callback('Invalid Tag Id - TicketSchema.GetAllTicketsByTag()', null)\n\n  var self = this\n\n  var q = self.model(COLLECTION).find({ tags: tagId, deleted: false })\n\n  return q.exec(callback)\n}\n\n/**\n * Gets tickets via type id\n * @memberof Ticket\n * @static\n * @method getTicketsByType\n *\n * @param {Array} grpId Group Array of User\n * @param {string} typeId Type Id\n * @param {QueryCallback} callback MongoDB Query Callback\n * @param {Boolean} limit Should Limit results?\n */\nticketSchema.statics.getTicketsByType = function (grpId, typeId, callback, limit) {\n  if (_.isUndefined(grpId)) return callback('Invalid Group Ids = TicketSchema.GetTicketsByType()', null)\n  if (_.isUndefined(typeId)) return callback('Invalid Ticket Type Id - TicketSchema.GetTicketsByType()', null)\n\n  var self = this\n\n  var q = self.model(COLLECTION).find({ group: { $in: grpId }, type: typeId, deleted: false })\n  if (limit) {\n    q.limit(1000)\n  }\n\n  return q.lean().exec(callback)\n}\n\n/**\n * Gets all tickets via type id\n * @memberof Ticket\n * @static\n * @method getAllTicketsByType\n *\n * @param {string} typeId Type Id\n * @param {QueryCallback} callback MongoDB Query Callback\n */\nticketSchema.statics.getAllTicketsByType = function (typeId, callback) {\n  if (_.isUndefined(typeId)) return callback('Invalid Ticket Type Id - TicketSchema.GetAllTicketsByType()', null)\n\n  var self = this\n  var q = self.model(COLLECTION).find({ type: typeId })\n\n  return q.lean().exec(callback)\n}\n\nticketSchema.statics.updateType = function (oldTypeId, newTypeId, callback) {\n  if (_.isUndefined(oldTypeId) || _.isUndefined(newTypeId)) {\n    return callback('Invalid IDs - TicketSchema.UpdateType()', null)\n  }\n\n  var self = this\n  return self.model(COLLECTION).updateMany({ type: oldTypeId }, { $set: { type: newTypeId } }, callback)\n}\n\nticketSchema.statics.getAssigned = function (userId, callback) {\n  if (_.isUndefined(userId)) return callback('Invalid Id - TicketSchema.GetAssigned()', null)\n\n  var self = this\n\n  var q = self\n    .model(COLLECTION)\n    .find({ assignee: userId, deleted: false, status: { $ne: 3 } })\n    .populate(\n      'owner assignee comments.owner notes.owner subscribers history.owner',\n      'username fullname email role image title'\n    )\n    .populate('type tags group')\n\n  return q.exec(callback)\n}\n\n/**\n * Gets count of X Top Groups\n *\n * @memberof Ticket\n * @static\n * @method getTopTicketGroups\n *\n * @param {Number} timespan Timespan to get the top groups (default: 9999)\n * @param {Number} top Top number of Groups to return (default: 5)\n * @param {QueryCallback} callback MongoDB Query Callback\n * @example\n * ticketSchema.getTopTicketGroups(5, function(err, results) {\n *    if (err) throw err;\n *\n *    //results is an array with name of group and count of total tickets\n *    results[x].name\n *    results[x].count\n * });\n */\nticketSchema.statics.getTopTicketGroups = function (timespan, top, callback) {\n  if (_.isUndefined(timespan) || _.isNaN(timespan) || timespan === 0) timespan = -1\n  if (_.isUndefined(top) || _.isNaN(top)) top = 5\n\n  var self = this\n\n  var today = moment\n    .utc()\n    .hour(23)\n    .minute(59)\n    .second(59)\n  var tsDate = today.clone().subtract(timespan, 'd')\n  var query = {\n    date: { $gte: tsDate.toDate(), $lte: today.toDate() },\n    deleted: false\n  }\n  if (timespan === -1) {\n    query = { deleted: false }\n  }\n\n  var q = self\n    .model(COLLECTION)\n    .find(query)\n    .select('group')\n    .populate('group', 'name')\n    .lean()\n\n  var topCount = []\n  var ticketsDb = []\n\n  async.waterfall(\n    [\n      function (next) {\n        q.exec(function (err, t) {\n          if (err) return next(err)\n\n          var arr = []\n\n          for (var i = 0; i < t.length; i++) {\n            var ticket = t[i]\n            if (ticket.group) {\n              ticketsDb.push({\n                ticketId: ticket._id,\n                groupId: ticket.group._id\n              })\n              var o = {}\n              o._id = ticket.group._id\n              o.name = ticket.group.name\n\n              if (!_.filter(arr, { name: o.name }).length) {\n                arr.push(o)\n              }\n            }\n          }\n\n          return next(null, _.uniq(arr))\n        })\n      },\n      function (grps, next) {\n        for (var g = 0; g < grps.length; g++) {\n          var tickets = []\n          var grp = grps[g]\n          for (var i = 0; i < ticketsDb.length; i++) {\n            if (ticketsDb[i].groupId === grp._id) {\n              tickets.push(ticketsDb)\n            }\n          }\n\n          topCount.push({ name: grp.name, count: tickets.length })\n        }\n\n        topCount = _.sortBy(topCount, function (o) {\n          return -o.count\n        })\n\n        topCount = topCount.slice(0, top)\n\n        return next(null, topCount)\n      }\n    ],\n    function (err, result) {\n      if (err) return callback(err, null)\n\n      return callback(null, result)\n    }\n  )\n}\n\nticketSchema.statics.getTagCount = function (tagId, callback) {\n  if (_.isUndefined(tagId)) return callback('Invalid Tag Id - TicketSchema.GetTagCount()', null)\n\n  var self = this\n\n  var q = self.model(COLLECTION).countDocuments({ tags: tagId, deleted: false })\n\n  return q.exec(callback)\n}\n\nticketSchema.statics.getTypeCount = function (typeId, callback) {\n  if (_.isUndefined(typeId)) return callback('Invalid Type Id - TicketSchema.GetTypeCount()', null)\n\n  var self = this\n\n  var q = self.model(COLLECTION).countDocuments({ type: typeId, deleted: false })\n\n  return q.exec(callback)\n}\n\nticketSchema.statics.getCount = function (callback) {\n  var q = this.model(COLLECTION)\n    .countDocuments({ deleted: false })\n    .lean()\n  return q.exec(callback)\n}\n\n/**\n * Mark a ticket as deleted in MongoDb <br/><br/>\n * *Ticket has its ```deleted``` flag set to true*\n *\n * @memberof Ticket\n * @static\n * @method softDelete\n *\n * @param {Object} oId Ticket Object _id\n * @param {QueryCallback} callback MongoDB Query Callback\n */\nticketSchema.statics.softDelete = function (oId, callback) {\n  if (_.isUndefined(oId)) return callback('Invalid ObjectID - TicketSchema.SoftDelete()', null)\n\n  var self = this\n\n  return self.model(COLLECTION).findOneAndUpdate({ _id: oId }, { deleted: true }, { new: true }, callback)\n}\n\nticketSchema.statics.softDeleteUid = function (uid, callback) {\n  if (_.isUndefined(uid)) return callback({ message: 'Invalid UID - TicketSchema.SoftDeleteUid()' })\n\n  return this.model(COLLECTION).findOneAndUpdate({ uid: uid }, { deleted: true }, { new: true }, callback)\n}\n\nticketSchema.statics.restoreDeleted = function (oId, callback) {\n  if (_.isUndefined(oId)) return callback('Invalid ObjectID - TicketSchema.RestoreDeleted()', null)\n\n  var self = this\n\n  return self.model(COLLECTION).findOneAndUpdate({ _id: oId }, { deleted: false }, { new: true }, callback)\n}\n\nticketSchema.statics.getDeleted = function (callback) {\n  return this.model(COLLECTION)\n    .find({ deleted: true })\n    .populate('group')\n    .sort({ uid: -1 })\n    .limit(1000)\n    .exec(callback)\n}\n\nfunction statusToString (status) {\n  var str\n  switch (status) {\n    case 0:\n      str = 'New'\n      break\n    case 1:\n      str = 'Open'\n      break\n    case 2:\n      str = 'Pending'\n      break\n    case 3:\n      str = 'Closed'\n      break\n    default:\n      str = status\n      break\n  }\n\n  return str\n}\n\nmodule.exports = mongoose.model(COLLECTION, ticketSchema)\n", "/*\n *       .                             .o8                     oooo\n *    .o8                             \"888                     `888\n *  .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\n *    888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\n *    888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\n *    888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\n *    \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\n *  ========================================================================\n *  Author:     Chris Brame\n *  Updated:    1/20/19 4:43 PM\n *  Copyright (c) 2014-2019. All rights reserved.\n */\n\n// var _               = require('lodash');\nvar mongoose = require('mongoose')\nvar moment = require('moment')\nrequire('moment-duration-format')\n\nvar COLLECTION = 'priorities'\n\nvar prioritySchema = mongoose.Schema(\n  {\n    name: { type: String, required: true, unique: true },\n    overdueIn: { type: Number, required: true, default: 2880 }, // Minutes until overdue (48 Hours)\n    htmlColor: { type: String, default: '#29b955' },\n\n    migrationNum: { type: Number, index: true }, // Needed to convert <1.0 priorities to new format.\n    default: { type: Boolean }\n  },\n  {\n    toJSON: {\n      virtuals: true\n    }\n  }\n)\n\nprioritySchema.pre('save', function (next) {\n  this.name = this.name.trim()\n\n  return next()\n})\n\nprioritySchema.virtual('durationFormatted').get(function () {\n  var priority = this\n  return moment\n    .duration(priority.overdueIn, 'minutes')\n    .format('Y [year], M [month], d [day], h [hour], m [min]', { trim: 'both' })\n})\n\nprioritySchema.statics.getPriority = function (_id, callback) {\n  return this.model(COLLECTION)\n    .findOne({ _id: _id })\n    .exec(callback)\n}\n\nprioritySchema.statics.getPriorities = function (callback) {\n  return this.model(COLLECTION)\n    .find({})\n    .exec(callback)\n}\n\nprioritySchema.statics.getByMigrationNum = function (num, callback) {\n  var q = this.model(COLLECTION).findOne({ migrationNum: num })\n\n  return q.exec(callback)\n}\n\nmodule.exports = mongoose.model(COLLECTION, prioritySchema)\n", "/*\n *       .                             .o8                     oooo\n *    .o8                             \"888                     `888\n *  .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\n *    888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\n *    888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\n *    888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\n *    \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\n *  ========================================================================\n *  Author:     Chris Brame\n *  Updated:    1/20/19 4:43 PM\n *  Copyright (c) 2014-2019. All rights reserved.\n */\n\nvar _ = require('lodash')\nvar mongoose = require('mongoose')\n\nvar COLLECTION = 'tickettypes'\n\n// Needed for Population\nrequire('./ticketpriority')\n\n/**\n * TicketType Schema\n * @module models/tickettype\n * @class TicketType\n\n *\n * @property {object} _id ```Required``` ```unique``` MongoDB Object ID\n * @property {String} name ```Required``` ```unique``` Name of Ticket Type\n */\nvar ticketTypeSchema = mongoose.Schema({\n  name: { type: String, required: true, unique: true },\n  priorities: [{ type: mongoose.Schema.Types.ObjectId, ref: 'priorities' }]\n})\n\nvar autoPopulatePriorities = function (next) {\n  this.populate('priorities')\n  return next()\n}\n\nticketTypeSchema.pre('find', autoPopulatePriorities)\nticketTypeSchema.pre('findOne', autoPopulatePriorities)\n\nticketTypeSchema.pre('save', function (next) {\n  this.name = this.name.trim()\n\n  return next()\n})\n\n/**\n * Return all Ticket Types\n *\n * @memberof TicketType\n * @static\n * @method getTypes\n *\n * @param {QueryCallback} callback MongoDB Query Callback\n */\nticketTypeSchema.statics.getTypes = function (callback) {\n  var q = this.model(COLLECTION).find({})\n\n  return q.exec(callback)\n}\n\n/**\n * Return Single Ticket Types\n *\n * @memberof TicketType\n * @static\n * @method getType\n *\n * @param {String} id Object Id of ticket type\n * @param {QueryCallback} callback MongoDB Query Callback\n */\nticketTypeSchema.statics.getType = function (id, callback) {\n  var q = this.model(COLLECTION).findOne({ _id: id })\n\n  return q.exec(callback)\n}\n\n/**\n * Return Single Ticket Type based on given type name\n *\n * @memberof TicketType\n * @static\n * @method getTypeByName\n *\n * @param {String} name Name of Ticket Type to search for\n * @param {QueryCallback} callback MongoDB Query Callback\n */\nticketTypeSchema.statics.getTypeByName = function (name, callback) {\n  var q = this.model(COLLECTION).findOne({ name: name })\n\n  return q.exec(callback)\n}\n\nticketTypeSchema.methods.addPriority = function (priorityId, callback) {\n  if (!priorityId) return callback({ message: 'Invalid Priority Id' })\n\n  var self = this\n\n  if (!_.isArray(self.priorities)) {\n    self.priorities = []\n  }\n\n  self.priorities.push(priorityId)\n\n  return callback(null, self)\n}\n\nticketTypeSchema.methods.removePriority = function (priorityId, callback) {\n  if (!priorityId) return callback({ message: 'Invalid Priority Id' })\n\n  var self = this\n\n  self.priorities = _.reject(self.priorities, function (p) {\n    return p._id.toString() === priorityId.toString()\n  })\n\n  return callback(null, self)\n}\n\nmodule.exports = mongoose.model(COLLECTION, ticketTypeSchema)\n", "/*\n *       .                             .o8                     oooo\n *    .o8                             \"888                     `888\n *  .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\n *    888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\n *    888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\n *    888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\n *    \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\n *  ========================================================================\n *  Author:     Chris Brame\n *  Updated:    1/20/19 4:43 PM\n *  Copyright (c) 2014-2019. All rights reserved.\n */\n\nvar async = require('async')\nvar mongoose = require('mongoose')\nvar winston = require('winston')\nvar bcrypt = require('bcrypt')\nvar _ = require('lodash')\nvar Chance = require('chance')\n\n// Required for linkage\nrequire('./role')\n\nvar SALT_FACTOR = 10\nvar COLLECTION = 'accounts'\n\n/**\n * User Schema\n * @module models/user\n * @class User\n *\n * @property {object} _id ```Required``` ```unique``` MongoDB Object ID\n * @property {String} username ```Required``` ```unique``` Username of user\n * @property {String} password ```Required``` Bcrypt password\n * @property {String} fullname ```Required``` Full name of user\n * @property {String} email ```Required``` ```unique``` Email Address of user\n * @property {String} role ```Required``` Permission role of the given user. See {@link Permissions}\n * @property {Date} lastOnline Last timestamp given user was online.\n * @property {String} title Job Title of user\n * @property {String} image Filename of user image\n * @property {String} resetPassHash Password reset has for recovery password link.\n * @property {Date} resetPassExpire Date when the password recovery link will expire\n * @property {String} tOTPKey One Time Password Secret Key\n * @property {Number} tOTPPeriod One Time Password Key Length (Time) - Default 30 Seconds\n * @property {String} accessToken API Access Token\n * @property {Array} iOSDeviceTokens Array of String based device Ids for Apple iOS devices. *push notifications*\n * @property {Object} preferences Object to hold user preferences\n * @property {Boolean} preferences.autoRefreshTicketGrid Enable the auto refresh of the ticket grid.\n * @property {Boolean} deleted Account Deleted\n */\nvar userSchema = mongoose.Schema({\n  username: { type: String, required: true, unique: true, lowercase: true },\n  password: { type: String, required: true, select: false },\n  fullname: { type: String, required: true, index: true },\n  email: { type: String, required: true, unique: true, lowercase: true },\n  role: { type: mongoose.Schema.Types.ObjectId, ref: 'roles', required: true },\n  lastOnline: Date,\n  title: String,\n  image: String,\n\n  resetPassHash: { type: String, select: false },\n  resetPassExpire: { type: Date, select: false },\n  tOTPKey: { type: String, select: false },\n  tOTPPeriod: { type: Number, select: false },\n  resetL2AuthHash: { type: String, select: false },\n  resetL2AuthExpire: { type: Date, select: false },\n  hasL2Auth: { type: Boolean, required: true, default: false },\n  accessToken: { type: String, sparse: true, select: false },\n\n  preferences: {\n    tourCompleted: { type: Boolean, default: false },\n    autoRefreshTicketGrid: { type: Boolean, default: true },\n    openChatWindows: [{ type: String, default: [] }]\n  },\n\n  deleted: { type: Boolean, default: false }\n})\n\nuserSchema.set('toObject', { getters: true })\n\nvar autoPopulateRole = function (next) {\n  this.populate('role', 'name description normalized _id')\n  next()\n}\n\nuserSchema.pre('findOne', autoPopulateRole).pre('find', autoPopulateRole)\n\nuserSchema.pre('save', function (next) {\n  var user = this\n\n  user.username = user.username.toLowerCase().trim()\n  user.email = user.email.trim()\n  if (user.fullname) user.fullname = user.fullname.trim()\n  if (user.title) user.title = user.title.trim()\n\n  if (!user.isModified('password')) {\n    return next()\n  }\n\n  bcrypt.genSalt(SALT_FACTOR, function (err, salt) {\n    if (err) return next(err)\n\n    bcrypt.hash(user.password, salt, function (err, hash) {\n      if (err) return next(err)\n\n      user.password = hash\n      return next()\n    })\n  })\n})\n\nuserSchema.methods.addAccessToken = function (callback) {\n  var user = this\n  var date = new Date()\n  var salt = user.username.toString() + date.toISOString()\n  var chance = new Chance(salt)\n  user.accessToken = chance.hash()\n  user.save(function (err) {\n    if (err) return callback(err, null)\n\n    return callback(null, user.accessToken)\n  })\n}\n\nuserSchema.methods.removeAccessToken = function (callback) {\n  var user = this\n  if (!user.accessToken) return callback()\n\n  user.accessToken = undefined\n  user.save(function (err) {\n    if (err) return callback(err, null)\n\n    return callback()\n  })\n}\n\nuserSchema.methods.generateL2Auth = function (callback) {\n  var user = this\n  if (_.isUndefined(user.tOTPKey) || _.isNull(user.tOTPKey)) {\n    var chance = new Chance()\n    var base32 = require('thirty-two')\n\n    var genOTPKey = chance.string({\n      length: 7,\n      pool: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ23456789'\n    })\n    var base32GenOTPKey = base32\n      .encode(genOTPKey)\n      .toString()\n      .replace(/=/g, '')\n\n    user.tOTPKey = base32GenOTPKey\n    user.hasL2Auth = true\n    user.save(function (err) {\n      if (err) return callback(err)\n\n      return callback(null, base32GenOTPKey)\n    })\n  } else {\n    return callback()\n  }\n}\n\nuserSchema.methods.removeL2Auth = function (callback) {\n  var user = this\n\n  user.tOTPKey = undefined\n  user.hasL2Auth = false\n  user.save(function (err) {\n    if (err) return callback(err, null)\n\n    return callback()\n  })\n}\n\nuserSchema.methods.addDeviceToken = function (token, type, callback) {\n  if (_.isUndefined(token)) return callback('Invalid token')\n  var user = this\n  // type 1 = iOS\n  // type 2 = Android\n  if (type === 1) {\n    if (hasDeviceToken(user, token, type)) return callback(null, token)\n\n    user.iOSDeviceTokens.push(token)\n    user.save(function (err) {\n      if (err) return callback(err, null)\n\n      callback(null, token)\n    })\n  }\n}\n\nuserSchema.methods.removeDeviceToken = function (token, type, callback) {\n  var user = this\n  if (type === 1) {\n    if (!hasDeviceToken(user, token, type)) return callback()\n\n    winston.debug('Removing Device: ' + token)\n    user.iOSDeviceTokens.splice(_.indexOf(this.iOSDeviceTokens, token), 1)\n    user.save(function (err, u) {\n      if (err) return callback(err, null)\n\n      return callback(null, u.iOSDeviceTokens)\n    })\n  }\n}\n\nuserSchema.methods.addOpenChatWindow = function (convoId, callback) {\n  if (convoId === undefined) {\n    if (!_.isFunction(callback)) return false\n    return callback('Invalid convoId')\n  }\n  var user = this\n  var hasChatWindow =\n    _.filter(user.preferences.openChatWindows, function (value) {\n      return value.toString() === convoId.toString()\n    }).length > 0\n\n  if (hasChatWindow) {\n    if (!_.isFunction(callback)) return false\n    return callback()\n  }\n  user.preferences.openChatWindows.push(convoId.toString())\n  user.save(function (err, u) {\n    if (err) {\n      if (!_.isFunction(callback)) return false\n      return callback(err)\n    }\n\n    if (!_.isFunction(callback)) return false\n    return callback(null, u.preferences.openChatWindows)\n  })\n}\n\nuserSchema.methods.removeOpenChatWindow = function (convoId, callback) {\n  if (convoId === undefined) {\n    if (!_.isFunction(callback)) return false\n    return callback('Invalid convoId')\n  }\n  var user = this\n  var hasChatWindow =\n    _.filter(user.preferences.openChatWindows, function (value) {\n      return value.toString() === convoId.toString()\n    }).length > 0\n\n  if (!hasChatWindow) {\n    if (!_.isFunction(callback)) return false\n    return callback()\n  }\n  user.preferences.openChatWindows.splice(\n    _.findIndex(user.preferences.openChatWindows, function (item) {\n      return item.toString() === convoId.toString()\n    }),\n    1\n  )\n\n  user.save(function (err, u) {\n    if (err) {\n      if (!_.isFunction(callback)) return false\n      return callback(err)\n    }\n\n    if (!_.isFunction(callback)) return false\n    return callback(null, u.preferences.openChatWindows)\n  })\n}\n\nuserSchema.methods.softDelete = function (callback) {\n  var user = this\n\n  user.deleted = true\n\n  user.save(function (err) {\n    if (err) return callback(err, false)\n\n    callback(null, true)\n  })\n}\n\nuserSchema.statics.validate = function (password, dbPass) {\n  return bcrypt.compareSync(password, dbPass)\n}\n\n/**\n * Gets all users\n *\n * @memberof User\n * @static\n * @method findAll\n *\n * @param {QueryCallback} callback MongoDB Query Callback\n */\nuserSchema.statics.findAll = function (callback) {\n  return this.model(COLLECTION).find({}, callback)\n}\n\n/**\n * Gets user via object _id\n *\n * @memberof User\n * @static\n * @method getUser\n *\n * @param {Object} oId Object _id to Query MongoDB\n * @param {QueryCallback} callback MongoDB Query Callback\n */\nuserSchema.statics.getUser = function (oId, callback) {\n  if (_.isUndefined(oId)) {\n    return callback('Invalid ObjectId - UserSchema.GetUser()', null)\n  }\n\n  return this.model(COLLECTION).findOne({ _id: oId }, callback)\n}\n\n/**\n * Gets user via username\n *\n * @memberof User\n * @static\n * @method getUserByUsername\n *\n * @param {String} user Username to Query MongoDB\n * @param {QueryCallback} callback MongoDB Query Callback\n */\nuserSchema.statics.getUserByUsername = function (user, callback) {\n  if (_.isUndefined(user)) {\n    return callback('Invalid Username - UserSchema.GetUserByUsername()', null)\n  }\n\n  return this.model(COLLECTION)\n    .findOne({ username: new RegExp('^' + user + '$', 'i') })\n    .select('+password +accessToken')\n    .exec(callback)\n}\n\nuserSchema.statics.getByUsername = userSchema.statics.getUserByUsername\n\n/**\n * Gets user via email\n *\n * @memberof User\n * @static\n * @method getUserByEmail\n *\n * @param {String} email Email to Query MongoDB\n * @param {QueryCallback} callback MongoDB Query Callback\n */\nuserSchema.statics.getUserByEmail = function (email, callback) {\n  if (_.isUndefined(email)) {\n    return callback('Invalid Email - UserSchema.GetUserByEmail()', null)\n  }\n\n  return this.model(COLLECTION).findOne({ email: email.toLowerCase() }, callback)\n}\n\n/**\n * Gets user via reset password hash\n *\n * @memberof User\n * @static\n * @method getUserByResetHash\n *\n * @param {String} hash Hash to Query MongoDB\n * @param {QueryCallback} callback MongoDB Query Callback\n */\nuserSchema.statics.getUserByResetHash = function (hash, callback) {\n  if (_.isUndefined(hash)) {\n    return callback('Invalid Hash - UserSchema.GetUserByResetHash()', null)\n  }\n\n  return this.model(COLLECTION).findOne(\n    { resetPassHash: hash, deleted: false },\n    '+resetPassHash +resetPassExpire',\n    callback\n  )\n}\n\nuserSchema.statics.getUserByL2ResetHash = function (hash, callback) {\n  if (_.isUndefined(hash)) {\n    return callback('Invalid Hash - UserSchema.GetUserByL2ResetHash()', null)\n  }\n\n  return this.model(COLLECTION).findOne(\n    { resetL2AuthHash: hash, deleted: false },\n    '+resetL2AuthHash +resetL2AuthExpire',\n    callback\n  )\n}\n\n/**\n * Gets user via API Access Token\n *\n * @memberof User\n * @static\n * @method getUserByAccessToken\n *\n * @param {String} token Access Token to Query MongoDB\n * @param {QueryCallback} callback MongoDB Query Callback\n */\nuserSchema.statics.getUserByAccessToken = function (token, callback) {\n  if (_.isUndefined(token)) {\n    return callback('Invalid Token - UserSchema.GetUserByAccessToken()', null)\n  }\n\n  return this.model(COLLECTION).findOne({ accessToken: token, deleted: false }, '+password', callback)\n}\n\nuserSchema.statics.getUserWithObject = function (object, callback) {\n  if (!_.isObject(object)) {\n    return callback('Invalid Object (Must be of type Object) - UserSchema.GetUserWithObject()', null)\n  }\n\n  var self = this\n\n  var limit = object.limit === null ? 10 : object.limit\n  var page = object.page === null ? 0 : object.page\n  var search = object.search === null ? '' : object.search\n\n  var q = self\n    .model(COLLECTION)\n    .find({}, '-password -resetPassHash -resetPassExpire')\n    .sort({ fullname: 1 })\n    .skip(page * limit)\n  if (limit !== -1) {\n    q.limit(limit)\n  }\n\n  if (!object.showDeleted) q.where({ deleted: false })\n\n  if (!_.isEmpty(search)) {\n    q.where({ fullname: new RegExp('^' + search.toLowerCase(), 'i') })\n  }\n\n  return q.exec(callback)\n}\n\n/**\n * Gets users based on permissions > mod\n *\n * @memberof User\n * @static\n * @method getAssigneeUsers\n *\n * @param {QueryCallback} callback MongoDB Query Callback\n */\nuserSchema.statics.getAssigneeUsers = function (callback) {\n  var roles = global.roles\n  if (_.isUndefined(roles)) return callback(null, [])\n\n  var assigneeRoles = []\n  async.each(roles, function (role) {\n    if (role.isAgent) assigneeRoles.push(role._id)\n  })\n\n  assigneeRoles = _.uniq(assigneeRoles)\n  this.model(COLLECTION).find({ role: { $in: assigneeRoles }, deleted: false }, function (err, users) {\n    if (err) {\n      winston.warn(err)\n      return callback(err, null)\n    }\n\n    return callback(null, _.sortBy(users, 'fullname'))\n  })\n}\n\n/**\n * Gets users based on roles\n *\n * @memberof User\n * @static\n * @method getUsersByRoles\n *\n * @param {Array} roles Array of role ids\n * @param {QueryCallback} callback MongoDB Query Callback\n */\nuserSchema.statics.getUsersByRoles = function (roles, callback) {\n  if (_.isUndefined(roles)) return callback('Invalid roles array', null)\n  if (!_.isArray(roles)) {\n    roles = [roles]\n  }\n\n  var q = this.model(COLLECTION).find({ role: { $in: roles }, deleted: false })\n\n  return q.exec(callback)\n}\n\n/**\n * Creates a user with the given data object\n *\n * @memberof User\n * @static\n * @method createUser\n *\n * @param {User} data JSON data object of new User\n * @param {QueryCallback} callback MongoDB Query Callback\n */\nuserSchema.statics.createUser = function (data, callback) {\n  if (_.isUndefined(data) || _.isUndefined(data.username)) {\n    return callback('Invalid User Data - UserSchema.CreateUser()', null)\n  }\n\n  var self = this\n\n  self.model(COLLECTION).find({ username: data.username }, function (err, items) {\n    if (err) {\n      return callback(err, null)\n    }\n\n    if (_.size(items) > 0) {\n      return callback('Username Already Exists', null)\n    }\n\n    return self.collection.insert(data, callback)\n  })\n}\n\n/**\n * Creates a user with only Email address. Emails user password.\n *\n * @param email\n * @param callback\n */\nuserSchema.statics.createUserFromEmail = function (email, callback) {\n  if (_.isUndefined(email)) {\n    return callback('Invalid User Data - UserSchema.CreatePublicUser()', null)\n  }\n\n  var self = this\n\n  var settingSchema = require('./setting')\n  settingSchema.getSetting('role:user:default', function (err, userRoleDefault) {\n    if (err || !userRoleDefault) return callback('Invalid Setting - UserRoleDefault')\n\n    var Chance = require('chance')\n\n    var chance = new Chance()\n\n    var plainTextPass = chance.string({\n      length: 6,\n      pool: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890'\n    })\n\n    var user = new self({\n      username: email,\n      email: email,\n      password: plainTextPass,\n      fullname: email,\n      role: userRoleDefault.value\n    })\n\n    self.model(COLLECTION).find({ username: user.username }, function (err, items) {\n      if (err) return callback(err)\n      if (_.size(items) > 0) return callback('Username already exists')\n\n      user.save(function (err, savedUser) {\n        if (err) return callback(err)\n\n        // Create a group for this user\n        var GroupSchema = require('./group')\n        var group = new GroupSchema({\n          name: savedUser.email,\n          members: [savedUser._id],\n          sendMailTo: [savedUser._id],\n          public: true\n        })\n\n        group.save(function (err, group) {\n          if (err) return callback(err)\n\n          // Send welcome email\n          var path = require('path')\n          var mailer = require('../mailer')\n          var Email = require('email-templates')\n          var templateDir = path.resolve(__dirname, '..', 'mailer', 'templates')\n\n          var email = new Email({\n            views: {\n              root: templateDir,\n              options: {\n                extension: 'handlebars'\n              }\n            }\n          })\n\n          var settingSchema = require('./setting')\n          settingSchema.getSetting('gen:siteurl', function (err, setting) {\n            if (err) return callback(err)\n\n            if (!setting) {\n              setting = { value: '' }\n            }\n\n            var dataObject = {\n              user: savedUser,\n              plainTextPassword: plainTextPass,\n              baseUrl: setting.value\n            }\n\n            email\n              .render('public-account-created', dataObject)\n              .then(function (html) {\n                var mailOptions = {\n                  to: savedUser.email,\n                  subject: 'Welcome to trudesk! - Here are your account details.',\n                  html: html,\n                  generateTextFromHTML: true\n                }\n\n                mailer.sendMail(mailOptions, function (err) {\n                  if (err) {\n                    winston.warn(err)\n                    return callback(err)\n                  }\n\n                  return callback(null, { user: savedUser, group: group })\n                })\n              })\n              .catch(function (err) {\n                winston.warn(err)\n                return callback(err)\n              })\n          })\n        })\n      })\n    })\n  })\n}\n\nuserSchema.statics.getCustomers = function (obj, callback) {\n  var limit = obj.limit || 10\n  var page = obj.page || 0\n  var self = this\n  return self\n    .model(COLLECTION)\n    .find({}, '-password -resetPassHash -resetPassExpire')\n    .exec(function (err, accounts) {\n      if (err) return callback(err)\n\n      var customerRoleIds = _.filter(accounts, function (a) {\n        return !a.role.isAdmin && !a.role.isAgent\n      }).map(function (a) {\n        return a.role._id\n      })\n\n      var q = self\n        .find({ role: { $in: customerRoleIds } }, '-password -resetPassHash -resetPassExpire')\n        .sort({ fullname: 1 })\n        .skip(page * limit)\n        .limit(limit)\n\n      if (!obj.showDeleted) q.where({ deleted: false })\n\n      q.exec(callback)\n    })\n}\n\nuserSchema.statics.getAgents = function (obj, callback) {\n  var limit = obj.limit || 10\n  var page = obj.page || 0\n  var self = this\n\n  return self\n    .model(COLLECTION)\n    .find({})\n    .exec(function (err, accounts) {\n      if (err) return callback(err)\n\n      var agentRoleIds = _.filter(accounts, function (a) {\n        return a.role.isAgent\n      }).map(function (a) {\n        return a.role._id\n      })\n\n      var q = self\n        .model(COLLECTION)\n        .find({ role: { $in: agentRoleIds } }, '-password -resetPassHash -resetPassExpire')\n        .sort({ fullname: 1 })\n        .skip(page * limit)\n        .limit(limit)\n\n      if (!obj.showDeleted) q.where({ deleted: false })\n\n      q.exec(callback)\n    })\n}\n\nuserSchema.statics.getAdmins = function (obj, callback) {\n  var limit = obj.limit || 10\n  var page = obj.page || 0\n  var self = this\n\n  return self\n    .model(COLLECTION)\n    .find({})\n    .exec(function (err, accounts) {\n      if (err) return callback(err)\n\n      var adminRoleIds = _.filter(accounts, function (a) {\n        return a.role.isAdmin\n      }).map(function (a) {\n        return a.role._id\n      })\n\n      var q = self\n        .model(COLLECTION)\n        .find({ role: { $in: adminRoleIds } }, '-password -resetPassHash -resetPassExpire')\n        .sort({ fullname: 1 })\n        .skip(page * limit)\n        .limit(limit)\n\n      if (!obj.showDeleted) q.where({ deleted: false })\n\n      q.exec(callback)\n    })\n}\n\n/**\n * Checks if a user has device token already\n *\n * @memberof User\n * @instance\n * @method hasDeviceToken\n *\n * @param {User} user User to check against\n * @param {String} token token to check for in given user\n * @param {Number} type Type of Device token to check.\n * @return {Boolean}\n * @example\n * type:\n *   1: iOS\n *   2: Android\n *   3: Windows\n */\nfunction hasDeviceToken (user, token, type) {\n  if (type === 1) {\n    var matches = _.filter(user.iOSDeviceTokens, function (value) {\n      if (value === token) {\n        return value\n      }\n    })\n\n    return matches.length > 0\n  }\n\n  return false\n}\n\nmodule.exports = mongoose.model(COLLECTION, userSchema)\n"], "fixing_code": ["/*\n *       .                             .o8                     oooo\n *    .o8                             \"888                     `888\n *  .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\n *    888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\n *    888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\n *    888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\n *    \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\n *  ========================================================================\n *  Author:     Chris Brame\n *  Updated:    1/20/19 4:43 PM\n *  Copyright (c) 2014-2019. All rights reserved.\n */\n\nconst _ = require('lodash')\nconst xss = require('xss')\n\nmodule.exports.sanitizeFieldPlainText = function (text) {\n  const t = xss(text, {\n    whileList: {},\n    stripIgnoreTag: true,\n    stripIgnoreTagBody: ['script']\n  })\n  return t\n}\n\nmodule.exports.sendToSelf = function (socket, method, data) {\n  socket.emit(method, data)\n}\n\nmodule.exports._sendToSelf = function (io, socketId, method, data) {\n  _.each(io.sockets.sockets, function (socket) {\n    if (socket.id === socketId) {\n      socket.emit(method, data)\n    }\n  })\n}\n\nmodule.exports.sendToAllConnectedClients = function (io, method, data) {\n  io.sockets.emit(method, data)\n}\n\nmodule.exports.sendToAllClientsInRoom = function (io, room, method, data) {\n  io.sockets.in(room).emit(method, data)\n}\n\nmodule.exports.sendToUser = function (socketList, userList, username, method, data) {\n  var userOnline = null\n  _.forEach(userList, function (v, k) {\n    if (k.toLowerCase() === username.toLowerCase()) {\n      userOnline = v\n      return true\n    }\n  })\n\n  if (_.isNull(userOnline)) return true\n\n  _.forEach(userOnline.sockets, function (socket) {\n    var o = _.findKey(socketList, { id: socket })\n    var i = socketList[o]\n    if (_.isUndefined(i)) return true\n    i.emit(method, data)\n  })\n}\n\nmodule.exports.sendToAllExcept = function (io, exceptSocketId, method, data) {\n  _.each(io.sockets.sockets, function (socket) {\n    if (socket.id !== exceptSocketId) {\n      socket.emit(method, data)\n    }\n  })\n}\n\nmodule.exports.disconnectAllClients = function (io) {\n  Object.keys(io.sockets.sockets).forEach(function (sock) {\n    io.sockets.sockets[sock].disconnect(true)\n  })\n}\n", "/*\n *       .                             .o8                     oooo\n *    .o8                             \"888                     `888\n *  .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\n *    888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\n *    888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\n *    888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\n *    \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\n *  ========================================================================\n *  Author:     Chris Brame\n *  Updated:    1/20/19 4:43 PM\n *  Copyright (c) 2014-2019. All rights reserved.\n */\n\nvar mongoose = require('mongoose')\nvar utils = require('../helpers/utils')\n\nvar attachmentSchema = mongoose.Schema({\n  owner: { type: mongoose.Schema.Types.ObjectId, ref: 'accounts' },\n  name: { type: String, required: true },\n  date: { type: Date, required: true, default: Date.now },\n  path: { type: String, required: true },\n  type: { type: String, required: true }\n})\n\nattachmentSchema.pre('save', function (next) {\n  this.name = utils.sanitizeFieldPlainText(this.name.trim())\n\n  return next()\n})\n\nmodule.exports = attachmentSchema\n", "/*\n      .                              .o8                     oooo\n   .o8                             \"888                     `888\n .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\n   888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\n   888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\n   888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\n   \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\n ========================================================================\n Created:    11/1/2018\n Author:     Chris Brame\n\n **/\n\nvar _ = require('lodash')\nvar async = require('async')\nvar mongoose = require('mongoose')\nvar utils = require('../helpers/utils')\n\n// Refs\nrequire('./group')\nvar Teams = require('./team')\nvar Groups = require('./group')\n\nvar COLLECTION = 'departments'\n\nvar departmentSchema = mongoose.Schema({\n  name: { type: String, required: true, unique: true },\n  normalized: { type: String },\n  teams: [{ type: mongoose.Schema.Types.ObjectId, ref: 'teams', autopopulate: true }],\n  allGroups: { type: Boolean, default: false },\n  publicGroups: { type: Boolean, default: false },\n  groups: [{ type: mongoose.Schema.Types.ObjectId, ref: 'groups', autopopulate: true }]\n})\n\ndepartmentSchema.plugin(require('mongoose-autopopulate'))\n\ndepartmentSchema.pre('save', function (next) {\n  this.name = utils.sanitizeFieldPlainText(this.name.trim())\n  this.normalized = utils.sanitizeFieldPlainText(this.name.trim().toLowerCase())\n\n  return next()\n})\n\ndepartmentSchema.statics.getDepartmentsByTeam = function (teamIds, callback) {\n  return this.model(COLLECTION)\n    .find({ teams: { $in: teamIds } })\n    .exec(callback)\n}\n\ndepartmentSchema.statics.getUserDepartments = function (userId, callback) {\n  var self = this\n\n  Teams.getTeamsOfUser(userId, function (err, teams) {\n    if (err) return callback(err)\n\n    return self\n      .model(COLLECTION)\n      .find({ teams: { $in: teams } })\n      .exec(callback)\n  })\n}\n\ndepartmentSchema.statics.getDepartmentGroupsOfUser = function (userId, callback) {\n  var self = this\n\n  Teams.getTeamsOfUser(userId, function (err, teams) {\n    if (err) return callback(err)\n\n    return self\n      .model(COLLECTION)\n      .find({ teams: { $in: teams } })\n      .exec(function (err, departments) {\n        if (err) return callback(err)\n\n        var hasAllGroups = _.some(departments, { allGroups: true })\n        var hasPublicGroups = _.some(departments, { publicGroups: true })\n        if (hasAllGroups) {\n          return Groups.getAllGroups(callback)\n        } else if (hasPublicGroups) {\n          return Groups.getAllPublicGroups(function (err, publicGroups) {\n            if (err) return callback(err)\n\n            var mapped = departments.map(function (department) {\n              return department.groups\n            })\n            var merged = _.concat(publicGroups, mapped)\n\n            merged = _.flattenDeep(merged)\n            merged = _.uniqBy(merged, function (i) {\n              return i._id\n            })\n\n            return callback(null, merged)\n          })\n        } else {\n          var groups = _.flattenDeep(\n            departments.map(function (department) {\n              return department.groups\n            })\n          )\n\n          return callback(null, groups)\n        }\n      })\n  })\n}\n\ndepartmentSchema.statics.getDepartmentsByGroup = function (groupId, callback) {\n  var self = this\n\n  return self\n    .model(COLLECTION)\n    .find({ $or: [{ groups: groupId }, { allGroups: true }] })\n    .exec(callback)\n}\n\nmodule.exports = mongoose.model(COLLECTION, departmentSchema)\n", "/*\n *       .                             .o8                     oooo\n *    .o8                             \"888                     `888\n *  .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\n *    888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\n *    888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\n *    888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\n *    \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\n *  ========================================================================\n *  Author:     Chris Brame\n *  Updated:    1/20/19 4:46 PM\n *  Copyright (c) 2014-2019. All rights reserved.\n */\n\nvar _ = require('lodash')\nvar mongoose = require('mongoose')\nvar utils = require('../helpers/utils')\n\nvar COLLECTION = 'groups'\n\n/**\n * Group Schema\n * @module models/ticket\n * @class Group\n * @requires {@link User}\n *\n * @property {object} _id ```Required``` ```unique``` MongoDB Object ID\n * @property {String} name ```Required``` ```unique``` Name of Group\n * @property {Array} members Members in this group\n * @property {Array} sendMailTo Members to email when a new / updated ticket has triggered\n */\nvar groupSchema = mongoose.Schema({\n  name: { type: String, required: true, unique: true },\n  members: [\n    {\n      type: mongoose.Schema.Types.ObjectId,\n      ref: 'accounts',\n      autopopulate: { select: '-hasL2Auth -preferences -__v' }\n    }\n  ],\n  sendMailTo: [{ type: mongoose.Schema.Types.ObjectId, ref: 'accounts' }],\n  public: { type: Boolean, required: true, default: false }\n})\n\ngroupSchema.plugin(require('mongoose-autopopulate'))\n\ngroupSchema.pre('save', function (next) {\n  this.name = utils.sanitizeFieldPlainText(this.name.trim())\n\n  next()\n})\n\ngroupSchema.methods.addMember = function (memberId, callback) {\n  if (_.isUndefined(memberId)) return callback('Invalid MemberId - $Group.AddMember()')\n\n  if (this.members === null) this.members = []\n\n  if (isMember(this.members, memberId)) return callback(null, false)\n\n  this.members.push(memberId)\n  this.members = _.uniq(this.members)\n\n  return callback(null, true)\n}\n\ngroupSchema.methods.removeMember = function (memberId, callback) {\n  if (_.isUndefined(memberId)) return callback('Invalid MemberId - $Group.RemoveMember()')\n\n  if (!isMember(this.members, memberId)) return callback(null, false)\n\n  this.members.splice(_.indexOf(this.members, _.find(this.members, { _id: memberId })), 1)\n\n  this.members = _.uniq(this.members)\n\n  return callback(null, true)\n}\n\ngroupSchema.methods.isMember = function (memberId) {\n  return isMember(this.members, memberId)\n}\n\ngroupSchema.methods.addSendMailTo = function (memberId, callback) {\n  if (_.isUndefined(memberId)) return callback('Invalid MemberId - $Group.AddSendMailTo()')\n\n  if (this.sendMailTo === null) this.sendMailTo = []\n\n  if (isMember(this.sendMailTo, memberId)) return callback(null, false)\n\n  this.sendMailTo.push(memberId)\n  this.sendMailTo = _.uniq(this.sendMailTo)\n\n  return callback(null, true)\n}\n\ngroupSchema.methods.removeSendMailTo = function (memberId, callback) {\n  if (_.isUndefined(memberId)) return callback('Invalid MemberId - $Group.RemoveSendMailTo()')\n\n  if (!isMember(this.sendMailTo, memberId)) return callback(null, false)\n\n  this.sendMailTo.splice(_.indexOf(this.sendMailTo, _.find(this.sendMailTo, { _id: memberId })), 1)\n\n  return callback(null, true)\n}\n\ngroupSchema.statics.getGroupByName = function (name, callback) {\n  if (_.isUndefined(name) || name.length < 1) return callback('Invalid Group Name - GroupSchema.GetGroupByName()')\n\n  var q = this.model(COLLECTION)\n    .findOne({ name: name })\n    .populate('members', '_id username fullname email role preferences image title deleted')\n    .populate('sendMailTo', '_id username fullname email role preferences image title deleted')\n\n  return q.exec(callback)\n}\n\ngroupSchema.statics.getWithObject = function (obj, callback) {\n  var limit = obj.limit ? Number(obj.limit) : 100\n  var page = obj.page ? Number(obj.page) : 0\n  var userId = obj.userId\n\n  if (userId) {\n    return this.model(COLLECTION)\n      .find({ members: userId })\n      .limit(limit)\n      .skip(page * limit)\n      .populate('members', '_id username fullname email role preferences image title deleted')\n      .populate('sendMailTo', '_id username fullname email role preferences image title deleted')\n      .sort('name')\n      .exec(callback)\n  }\n\n  return this.model(COLLECTION)\n    .find({})\n    .limit(limit)\n    .skip(page * limit)\n    .populate('members', '_id username fullname email role preferences image title deleted')\n    .populate('sendMailTo', '_id username fullname email role preferences image title deleted')\n    .sort('name')\n    .exec(callback)\n}\n\ngroupSchema.statics.getAllGroups = function (callback) {\n  var q = this.model(COLLECTION)\n    .find({})\n    .populate('members', '_id username fullname email role preferences image title deleted')\n    .populate('sendMailTo', '_id username fullname email role preferences image title deleted')\n    .sort('name')\n\n  return q.exec(callback)\n}\n\ngroupSchema.statics.getAllGroupsNoPopulate = function (callback) {\n  var q = this.model(COLLECTION)\n    .find({})\n    .sort('name')\n\n  return q.exec(callback)\n}\n\ngroupSchema.statics.getAllPublicGroups = function (callback) {\n  var q = this.model(COLLECTION)\n    .find({ public: true })\n    .sort('name')\n\n  return q.exec(callback)\n}\n\ngroupSchema.statics.getGroups = function (groupIds, callback) {\n  if (_.isUndefined(groupIds)) return callback('Invalid Array of Group IDs - GroupSchema.GetGroups()')\n\n  this.model(COLLECTION)\n    .find({ _id: { $in: groupIds } })\n    .populate('members', '_id username fullname email role preferences image title deleted')\n    .sort('name')\n    .exec(callback)\n}\n\ngroupSchema.statics.getAllGroupsOfUser = function (userId, callback) {\n  if (_.isUndefined(userId)) return callback('Invalid UserId - GroupSchema.GetAllGroupsOfUser()')\n\n  var q = this.model(COLLECTION)\n    .find({ members: userId })\n    .populate('members', '_id username fullname email role preferences image title deleted')\n    .populate('sendMailTo', '_id username fullname email role preferences image title deleted')\n    .sort('name')\n\n  return q.exec(callback)\n}\n\ngroupSchema.statics.getAllGroupsOfUserNoPopulate = function (userId, callback) {\n  if (_.isUndefined(userId)) return callback('Invalid UserId - GroupSchema.GetAllGroupsOfUserNoPopulate()')\n\n  var q = this.model(COLLECTION)\n    .find({ members: userId })\n    .sort('name')\n\n  return q.exec(callback)\n}\n\ngroupSchema.statics.getGroupById = function (gId, callback) {\n  if (_.isUndefined(gId)) return callback('Invalid GroupId - GroupSchema.GetGroupById()')\n\n  var q = this.model(COLLECTION)\n    .findOne({ _id: gId })\n    .populate('members', '_id username fullname email role preferences image title')\n    .populate('sendMailTo', '_id username fullname email role preferences image title')\n\n  return q.exec(callback)\n}\n\nfunction isMember (arr, id) {\n  var matches = _.filter(arr, function (value) {\n    if (value._id.toString() === id.toString()) {\n      return value\n    }\n  })\n\n  return matches.length > 0\n}\n\nmodule.exports = mongoose.model(COLLECTION, groupSchema)\n", "/*\n      .                              .o8                     oooo\n   .o8                             \"888                     `888\n .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\n   888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\n   888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\n   888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\n   \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\n ========================================================================\n */\n\nvar mongoose = require('mongoose')\nvar utils = require('../helpers/utils')\n\nvar COLLECTION = 'notices'\n\n/**\n * @since 1.0\n * @author Chris Brame <polonel@gmail.com>\n * @copyright 2015 Chris Brame\n **/\n\n/**\n * Notice Object Schema for MongoDB\n * @module models/notice\n * @class Notice\n * @property {String} name ```Required``` Name of the notice\n * @property {Date} date ```Required``` __[default:Date.now]__ Date the notice was created\n * @property {String} color ```Required``` __[default:#e74c3c]__ Color to display the notice in\n * @property {String} message ```Required``` Message of the Notice\n * @property {Boolean} active ```Required``` __[default: false]__ Is the Notice Active?\n */\nvar noticeSchema = mongoose.Schema({\n  name: { type: String, required: true },\n  date: { type: Date, default: Date.now, required: true },\n  color: { type: String, default: '#e74c3c', required: true },\n  fontColor: { type: String, default: '#ffffff', required: true },\n  message: { type: String, required: true },\n  active: { type: Boolean, default: false, required: true },\n  activeDate: { type: Date, default: Date.now },\n  alertWindow: { type: Boolean, default: false }\n})\n\nnoticeSchema.pre('save', function (next) {\n  this.name = utils.sanitizeFieldPlainText(this.name.trim())\n  this.message = utils.sanitizeFieldPlainText(this.message.trim())\n\n  return next()\n})\n\nnoticeSchema.statics.getNotices = function (callback) {\n  return this.model(COLLECTION)\n    .find({})\n    .exec(callback)\n}\n\nnoticeSchema.statics.getNotice = function (id, callback) {\n  return this.model(COLLECTION)\n    .findOne({ _id: id })\n    .exec(callback)\n}\n\nnoticeSchema.statics.getNoticeByName = function (name, callback) {\n  return this.model(COLLECTION)\n    .find({ name: name })\n    .exec(callback)\n}\n\nnoticeSchema.statics.getActive = function (callback) {\n  return this.model(COLLECTION)\n    .findOne({ active: true })\n    .exec(callback)\n}\n\nmodule.exports = mongoose.model(COLLECTION, noticeSchema)\n", "/*\n     .                              .o8                     oooo\n   .o8                             \"888                     `888\n .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\n   888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\n   888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\n   888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\n   \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\n ========================================================================\n Created:    10/28/2018\n Author:     Chris Brame\n\n **/\n\nvar mongoose = require('mongoose')\nvar mongooseLeanVirtuals = require('mongoose-lean-virtuals')\nvar _ = require('lodash')\nvar utils = require('../helpers/utils')\n\nvar COLLECTION = 'roles'\n\nvar roleSchema = mongoose.Schema(\n  {\n    name: { type: String, required: true, unique: true },\n    normalized: String,\n    description: String,\n    grants: [{ type: String, required: true }],\n    hierarchy: { type: Boolean, required: true, default: true }\n  },\n  {\n    toObject: { getters: true, virtuals: true },\n    toJSON: { virtuals: true }\n  }\n)\n\nroleSchema.virtual('isAdmin').get(function () {\n  if (_.isUndefined(global.roles)) return false\n  var role = _.find(global.roles, { normalized: this.normalized })\n  if (!role) return false\n\n  return _.indexOf(role.grants, 'admin:*') !== -1\n})\n\nroleSchema.virtual('isAgent').get(function () {\n  if (_.isUndefined(global.roles)) return false\n  var role = _.find(global.roles, { normalized: this.normalized })\n  if (!role) return false\n\n  return _.indexOf(role.grants, 'agent:*') !== -1\n})\n\nroleSchema.plugin(mongooseLeanVirtuals)\n\nroleSchema.pre('save', function (next) {\n  this.name = utils.sanitizeFieldPlainText(this.name.trim())\n  this.normalized = utils.sanitizeFieldPlainText(this.name.toLowerCase().trim())\n\n  return next()\n})\n\nroleSchema.methods.updateGrants = function (grants, callback) {\n  this.grants = grants\n  this.save(callback)\n}\n\nroleSchema.methods.updateGrantsAndHierarchy = function (grants, hierarchy, callback) {\n  this.grants = grants\n  this.hierarchy = hierarchy\n  this.save(callback)\n}\n\nroleSchema.statics.getRoles = function (callback) {\n  return this.model(COLLECTION)\n    .find({})\n    .exec(callback)\n}\n\nroleSchema.statics.getRolesLean = function (callback) {\n  return this.model(COLLECTION)\n    .find({})\n    .lean({ virtuals: true })\n    .exec(callback)\n}\n\nroleSchema.statics.getRole = function (id, callback) {\n  var q = this.model(COLLECTION).findOne({ _id: id })\n\n  return q.exec(callback)\n}\n\nroleSchema.statics.getRoleByName = function (name, callback) {\n  var q = this.model(COLLECTION).findOne({ normalized: new RegExp('^' + name.trim() + '$', 'i') })\n\n  return q.exec(callback)\n}\n\nroleSchema.statics.getAgentRoles = function (callback) {\n  var q = this.model(COLLECTION).find({})\n  q.exec(function (err, roles) {\n    if (err) return callback(err)\n\n    var rolesWithAgent = _.filter(roles, function (role) {\n      return _.indexOf(role.grants, 'agent:*') !== -1\n    })\n\n    return callback(null, rolesWithAgent)\n  })\n}\n\n// Alias\nroleSchema.statics.get = roleSchema.statics.getRole\n\nmodule.exports = mongoose.model(COLLECTION, roleSchema)\n", "/*\n *       .                             .o8                     oooo\n *    .o8                             \"888                     `888\n *  .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\n *    888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\n *    888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\n *    888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\n *    \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\n *  ========================================================================\n *  Author:     Chris Brame\n *  Updated:    1/20/19 4:43 PM\n *  Copyright (c) 2014-2019. All rights reserved.\n */\n\nvar mongoose = require('mongoose')\nvar utils = require('../helpers/utils')\n\nvar COLLECTION = 'tags'\n\n/**\n * Tag Schema\n * @module models/tag\n * @class Tag\n\n *\n * @property {object} _id ```Required``` ```unique``` MongoDB Object ID\n * @property {String} name ```Required``` ```unique``` Name of Tag\n */\nvar tagSchema = mongoose.Schema({\n  name: { type: String, required: true, unique: true },\n  normalized: String\n})\n\ntagSchema.pre('save', function (next) {\n  this.name = utils.sanitizeFieldPlainText(this.name.trim())\n  this.normalized = utils.sanitizeFieldPlainText(this.name.toLowerCase().trim())\n\n  return next()\n})\n\ntagSchema.statics.getTag = function (id, callback) {\n  var q = this.model(COLLECTION).findOne({ _id: id })\n\n  return q.exec(callback)\n}\n\n/**\n * Return all Tags\n *\n * @memberof Tag\n * @static\n * @method getTags\n *\n * @param {QueryCallback} callback MongoDB Query Callback\n */\ntagSchema.statics.getTags = function (callback) {\n  var q = this.model(COLLECTION)\n    .find({})\n    .sort('normalized')\n\n  return q.exec(callback)\n}\n\ntagSchema.statics.getTagsWithLimit = function (limit, page, callback) {\n  var q = this.model(COLLECTION)\n    .find({})\n    .sort('normalized')\n\n  if (limit !== -1) {\n    q.limit(limit).skip(page * limit)\n  }\n\n  return q.exec(callback)\n}\n\ntagSchema.statics.getTagByName = function (tagName, callback) {\n  var q = this.model(COLLECTION)\n    .find({ name: tagName })\n    .limit(1)\n\n  return q.exec(callback)\n}\n\ntagSchema.statics.tagExist = function (tagName, callback) {\n  var q = this.model(COLLECTION).countDocuments({ name: tagName })\n\n  return q.exec(callback)\n}\n\ntagSchema.statics.getTagCount = function (callback) {\n  var q = this.model(COLLECTION)\n    .countDocuments({})\n    .lean()\n\n  return q.exec(callback)\n}\n\nmodule.exports = mongoose.model(COLLECTION, tagSchema)\n", "/*\n *       .                             .o8                     oooo\n *    .o8                             \"888                     `888\n *  .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\n *    888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\n *    888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\n *    888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\n *    \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\n *  ========================================================================\n *  Author:     Chris Brame\n *  Updated:    3/28/19 2:13 AM\n *  Copyright (c) 2014-2019. All rights reserved.\n */\n\nvar _ = require('lodash')\nvar mongoose = require('mongoose')\nvar utils = require('../helpers/utils')\n\n// Refs\nrequire('./user')\n\nvar COLLECTION = 'teams'\n\nvar teamSchema = mongoose.Schema({\n  name: { type: String, required: true, unique: true },\n  normalized: { type: String, required: true, unique: true, lowercase: true },\n  members: [\n    {\n      type: mongoose.Schema.Types.ObjectId,\n      ref: 'accounts',\n      autopopulate: { select: '-hasL2Auth -preferences -__v' }\n    }\n  ]\n})\n\nteamSchema.plugin(require('mongoose-autopopulate'))\n\nteamSchema.pre('validate', function () {\n  this.normalized = utils.sanitizeFieldPlainText(this.name.trim().toLowerCase())\n})\n\nteamSchema.pre('save', function (next) {\n  this.name = utils.sanitizeFieldPlainText(this.name.trim())\n\n  return next()\n})\n\nteamSchema.methods.addMember = function (memberId, callback) {\n  if (_.isUndefined(memberId)) return callback('Invalid MemberId - TeamSchema.AddMember()')\n\n  if (this.members === null) this.members = []\n\n  if (isMember(this.members, memberId)) return callback(null, false)\n\n  this.members.push(memberId)\n  this.members = _.uniq(this.members)\n\n  return callback(null, true)\n}\n\nteamSchema.methods.removeMember = function (memberId, callback) {\n  if (_.isUndefined(memberId)) return callback('Invalid MemberId - TeamSchema.RemoveMember()')\n\n  if (!isMember(this.members, memberId)) return callback(null, false)\n\n  this.members.splice(_.indexOf(this.members, _.find(this.members, { _id: memberId })), 1)\n\n  this.members = _.uniq(this.members)\n\n  return callback(null, true)\n}\n\nteamSchema.methods.isMember = function (memberId) {\n  return isMember(this.members, memberId)\n}\n\nteamSchema.statics.getWithObject = function (obj, callback) {\n  if (!obj) return callback({ message: 'Invalid Team Object - TeamSchema.GetWithObject()' })\n\n  var q = this.model(COLLECTION)\n    .find({})\n    .skip(obj.limit * obj.page)\n    .limit(obj.limit)\n    .sort('name')\n\n  return q.exec(callback)\n}\n\nteamSchema.statics.getTeamByName = function (name, callback) {\n  if (_.isUndefined(name) || name.length < 1) return callback('Invalid Team Name - TeamSchema.GetTeamByName()')\n\n  var q = this.model(COLLECTION).findOne({ normalized: name })\n\n  return q.exec(callback)\n}\n\nteamSchema.statics.getTeams = function (callback) {\n  var q = this.model(COLLECTION)\n    .find({})\n    .sort('name')\n\n  return q.exec(callback)\n}\n\nteamSchema.statics.getTeamsByIds = function (ids, callback) {\n  return this.model(COLLECTION)\n    .find({ _id: { $in: ids } })\n    .sort('name')\n    .exec(callback)\n}\n\nteamSchema.statics.getTeamsNoPopulate = function (callback) {\n  var q = this.model(COLLECTION)\n    .find({})\n    .sort('name')\n\n  return q.exec(callback)\n}\n\nteamSchema.statics.getTeamsOfUser = function (userId, callback) {\n  if (_.isUndefined(userId)) return callback('Invalid UserId - TeamSchema.GetTeamsOfUser()')\n\n  var q = this.model(COLLECTION)\n    .find({ members: userId })\n    .sort('name')\n\n  return q.exec(callback)\n}\n\nteamSchema.statics.getTeamsOfUserNoPopulate = function (userId, callback) {\n  if (_.isUndefined(userId)) return callback('Invalid UserId - TeamSchema.GetTeamsOfUserNoPopulate()')\n\n  var q = this.model(COLLECTION)\n    .find({ members: userId })\n    .sort('name')\n\n  return q.exec(callback)\n}\n\nteamSchema.statics.getTeam = function (id, callback) {\n  if (_.isUndefined(id)) return callback('Invalid TeamId - TeamSchema.GetTeam()')\n\n  var q = this.model(COLLECTION).findOne({ _id: id })\n\n  return q.exec(callback)\n}\n\nfunction isMember (arr, id) {\n  var matches = _.filter(arr, function (value) {\n    if (value._id.toString() === id.toString()) return value\n  })\n\n  return matches.length > 0\n}\n\nmodule.exports = mongoose.model(COLLECTION, teamSchema)\n", "/*\n *       .                             .o8                     oooo\n *    .o8                             \"888                     `888\n *  .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\n *    888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\n *    888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\n *    888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\n *    \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\n *  ========================================================================\n *  Author:     Chris Brame\n *  Updated:    1/20/19 4:43 PM\n *  Copyright (c) 2014-2019. All rights reserved.\n */\n\nvar async = require('async')\nvar mongoose = require('mongoose')\nvar winston = require('winston')\nvar _ = require('lodash')\nvar moment = require('moment')\nvar sanitizeHtml = require('sanitize-html')\n// var redisCache          = require('../cache/rediscache');\nvar xss = require('xss')\nvar utils = require('../helpers/utils')\n\n// Needed - For Population\nvar groupSchema = require('./group')\nrequire('./tickettype')\nvar userSchema = require('./user')\nvar commentSchema = require('./comment')\nvar noteSchema = require('./note')\nvar attachmentSchema = require('./attachment')\nvar historySchema = require('./history')\nrequire('./tag')\nrequire('./ticketpriority')\n\nvar COLLECTION = 'tickets'\n\n/**\n * Ticket Schema\n * @module models/ticket\n * @class Ticket\n * @requires {@link Group}\n * @requires {@link TicketType}\n * @requires {@link User}\n * @requires {@link Comment}\n * @requires {@link Attachment}\n * @requires {@link History}\n *\n * @property {object} _id ```Required``` ```unique``` MongoDB Object ID\n * @property {Number} uid ```Required``` ```unique``` Readable Ticket ID\n * @property {User} owner ```Required``` Reference to User Object. Owner of this Object.\n * @property {Group} group ```Required``` Group this Ticket is under.\n * @property {User} assignee User currently assigned to this Ticket.\n * @property {Date} date ```Required``` [default: Date.now] Date Ticket was created.\n * @property {Date} updated Date ticket was last updated\n * @property {Boolean} deleted ```Required``` [default: false] If they ticket is flagged as deleted.\n * @property {TicketType} type ```Required``` Reference to the TicketType\n * @property {Number} status ```Required``` [default: 0] Ticket Status. (See {@link Ticket#setStatus})\n * @property {Number} priority ```Required```\n * @property {Array} tags An array of Tags.\n * @property {String} subject ```Required``` The subject of the ticket. (Overview)\n * @property {String} issue ```Required``` Detailed information about the ticket problem/task\n * @property {Date} closedDate show the datetime the ticket was moved to status 3.\n * @property {Array} comments An array of {@link Comment} items\n * @property {Array} notes An array of {@link Comment} items for internal notes\n * @property {Array} attachments An Array of {@link Attachment} items\n * @property {Array} history An array of {@link History} items\n * @property {Array} subscribers An array of user _ids that receive notifications on ticket changes.\n */\nvar ticketSchema = mongoose.Schema({\n  uid: { type: Number, unique: true, index: true },\n  owner: {\n    type: mongoose.Schema.Types.ObjectId,\n    required: true,\n    ref: 'accounts'\n  },\n  group: {\n    type: mongoose.Schema.Types.ObjectId,\n    required: true,\n    ref: 'groups'\n  },\n  assignee: {\n    type: mongoose.Schema.Types.ObjectId,\n    ref: 'accounts'\n  },\n  date: { type: Date, default: Date.now, required: true, index: true },\n  updated: { type: Date },\n  deleted: { type: Boolean, default: false, required: true, index: true },\n  type: {\n    type: mongoose.Schema.Types.ObjectId,\n    required: true,\n    ref: 'tickettypes'\n  },\n  status: { type: Number, default: 0, required: true, index: true },\n\n  priority: {\n    type: mongoose.Schema.Types.ObjectId,\n    ref: 'priorities',\n    required: true\n  },\n  tags: [{ type: mongoose.Schema.Types.ObjectId, ref: 'tags', autopopulate: true }],\n  subject: { type: String, required: true },\n  issue: { type: String, required: true },\n  closedDate: { type: Date },\n  dueDate: { type: Date },\n  comments: [commentSchema],\n  notes: [noteSchema],\n  attachments: [attachmentSchema],\n  history: [historySchema],\n  subscribers: [{ type: mongoose.Schema.Types.ObjectId, ref: 'accounts' }]\n})\n\nticketSchema.index({ deleted: -1, group: 1, status: 1 })\n\nvar autoPopulate = function (next) {\n  this.populate('priority')\n\n  return next()\n}\n\nticketSchema.pre('findOne', autoPopulate).pre('find', autoPopulate)\n\nticketSchema.pre('save', function (next) {\n  this.subject = utils.sanitizeFieldPlainText(this.subject.trim())\n  this.wasNew = this.isNew\n\n  if (!_.isUndefined(this.uid) || this.uid) {\n    return next()\n  }\n\n  var c = require('./counters')\n  var self = this\n  c.increment('tickets', function (err, res) {\n    if (err) return next(err)\n\n    self.uid = res.value.next\n\n    if (_.isUndefined(self.uid)) {\n      var error = new Error('Invalid UID.')\n      return next(error)\n    }\n\n    return next()\n  })\n})\n\nticketSchema.post('save', async function (doc, next) {\n  if (!this.wasNew) {\n    var emitter = require('../emitter')\n    try {\n      var savedTicket = await doc.populate([\n        {\n          path: 'owner assignee comments.owner notes.owner subscribers history.owner',\n          select: '_id username fullname email role image title'\n        },\n        { path: 'type tags' },\n        {\n          path: 'group',\n          model: groupSchema,\n          populate: [\n            {\n              path: 'members',\n              model: userSchema,\n              select: '-__v -accessToken -tOTPKey'\n            },\n            {\n              path: 'sendMailTo',\n              model: userSchema,\n              select: '-__v -accessToken -tOTPKey'\n            }\n          ]\n        }\n      ])\n\n      emitter.emit('ticket:updated', savedTicket)\n    } catch (err) {\n      winston.warn('WARNING: ' + err)\n    }\n\n    return next()\n  } else {\n    return next()\n  }\n})\n\nticketSchema.virtual('statusFormatted').get(function () {\n  var s = this.status\n  var formatted\n  switch (s) {\n    case 0:\n      formatted = 'New'\n      break\n    case 1:\n      formatted = 'Open'\n      break\n    case 2:\n      formatted = 'Pending'\n      break\n    case 3:\n      formatted = 'Closed'\n      break\n    default:\n      formatted = 'New'\n  }\n\n  return formatted\n})\n\nticketSchema.virtual('commentsAndNotes').get(function () {\n  _.each(this.comments, function (i) {\n    i.isComment = true\n  })\n  _.each(this.notes, function (i) {\n    i.isNote = true\n  })\n  var combined = _.union(this.comments, this.notes)\n  combined = _.sortBy(combined, 'date')\n\n  return combined\n})\n\n/**\n * Set Status on Instanced Ticket\n * @instance\n * @method setStatus\n * @memberof Ticket\n *\n * @param {Object} ownerId Account ID preforming this action\n * @param {Number} status Status to set\n * @param {TicketCallback} callback Callback with the updated ticket.\n *\n * @example\n * Status:\n *      0 - New\n *      1 - Open\n *      2 - Pending\n *      3 - Closed\n */\nticketSchema.methods.setStatus = function (ownerId, status, callback) {\n  if (_.isUndefined(status)) return callback('Invalid Status', null)\n\n  var self = this\n\n  if (status === 3) {\n    self.closedDate = new Date()\n  } else {\n    self.closedDate = null\n  }\n\n  self.status = status\n  var historyItem = {\n    action: 'ticket:set:status:' + status,\n    description: 'Ticket Status set to: ' + statusToString(status),\n    owner: ownerId\n  }\n  self.history.push(historyItem)\n\n  callback(null, self)\n}\n\n/**\n * Set Assignee on Instanced Ticket\n * @instance\n * @method setAssignee\n * @memberof Ticket\n *\n * @param {Object} ownerId Account ID preforming this action\n * @param {Object} userId User ID to set as assignee\n * @param {TicketCallback} callback Callback with the updated ticket.\n */\nticketSchema.methods.setAssignee = function (ownerId, userId, callback) {\n  if (_.isUndefined(userId)) return callback('Invalid User Id', null)\n  var permissions = require('../permissions')\n  var self = this\n\n  self.assignee = userId\n  userSchema.getUser(userId, function (err, user) {\n    if (err) return callback(err, null)\n\n    if (!permissions.canThis(user.role, 'tickets:update') && !permissions.canThis(user.role, 'agent:*')) {\n      return callback('User does not have permission to be set as an assignee.', null)\n    }\n\n    var historyItem = {\n      action: 'ticket:set:assignee',\n      description: user.fullname + ' was set as assignee',\n      owner: ownerId\n    }\n\n    self.history.push(historyItem)\n\n    return callback(null, self)\n  })\n}\n\n/**\n * Clear the current assignee\n * @instance\n * @method clearAssignee\n * @memberof Ticket\n *\n * @param {Object} ownerId Account ID preforming this action\n * @param {TicketCallback} callback Callback with the updated ticket.\n */\nticketSchema.methods.clearAssignee = function (ownerId, callback) {\n  var self = this\n  self.assignee = undefined\n  var historyItem = {\n    action: 'ticket:set:assignee',\n    description: 'Assignee was cleared',\n    owner: ownerId\n  }\n  self.history.push(historyItem)\n  callback(null, self)\n}\n\n/**\n * Sets the ticket type for the instanced Ticket\n * @instance\n * @method setTicketType\n * @memberof Ticket\n *\n * @param {Object} ownerId Account ID preforming this action\n * @param {Object} typeId TicketType Id to set as ticket type\n * @param {TicketCallback} callback Callback with the updated ticket.\n */\nticketSchema.methods.setTicketType = function (ownerId, typeId, callback) {\n  var typeSchema = require('./tickettype')\n  var self = this\n  self.type = typeId\n  typeSchema.findOne({ _id: typeId }, function (err, type) {\n    if (err) return callback(err)\n    if (!type) return callback('Invalid Type Id: ' + typeId)\n\n    var historyItem = {\n      action: 'ticket:set:type',\n      description: 'Ticket type set to: ' + type.name,\n      owner: ownerId\n    }\n\n    self.history.push(historyItem)\n\n    if (typeof callback === 'function') return callback(null, self)\n  })\n}\n\n/**\n * Sets the ticket priority\n * @instance\n * @method setTicketPriority\n * @memberof Ticket\n *\n * @param {Object} ownerId Account ID preforming this action\n * @param {Number} priority Priority to set\n * @param {TicketCallback} callback Callback with the updated ticket.\n */\nticketSchema.methods.setTicketPriority = function (ownerId, priority, callback) {\n  if (_.isUndefined(priority) || !_.isObject(priority)) return callback('Priority must be a PriorityObject.', null)\n\n  var self = this\n  self.priority = priority._id\n  var historyItem = {\n    action: 'ticket:set:priority',\n    description: 'Ticket Priority set to: ' + priority.name,\n    owner: ownerId\n  }\n  self.history.push(historyItem)\n\n  self\n    .populate(['priority'])\n    .then(function (updatedSelf) {\n      return callback(null, updatedSelf)\n    })\n    .catch(function (err) {\n      return callback(err, null)\n    })\n}\n\n/**\n * Sets this ticket under the given group Id\n * @instance\n * @method setTicketGroup\n * @memberof Ticket\n *\n * @param {Object} ownerId Account ID preforming this action\n * @param {Object} groupId MongoDB group Id to assign this ticket to\n * @param {TicketCallback} callback Callback with the updated ticket.\n */\nticketSchema.methods.setTicketGroup = function (ownerId, groupId, callback) {\n  var self = this\n  self.group = groupId\n\n  self.populate('group', function (err, ticket) {\n    if (err) return callback(err)\n\n    var historyItem = {\n      action: 'ticket:set:group',\n      description: 'Ticket Group set to: ' + ticket.group.name,\n      owner: ownerId\n    }\n    self.history.push(historyItem)\n\n    return callback(null, ticket)\n  })\n}\n\nticketSchema.methods.setTicketDueDate = function (ownerId, dueDate, callback) {\n  var self = this\n  self.dueDate = dueDate\n\n  var historyItem = {\n    action: 'ticket:set:duedate',\n    description: 'Ticket Due Date set to: ' + self.dueDate,\n    owner: ownerId\n  }\n\n  self.history.push(historyItem)\n\n  return callback(null, self)\n}\n\n/**\n * Sets this ticket's issue text\n * @instance\n * @method setIssue\n * @memberof Ticket\n *\n * @param {Object} ownerId Account ID preforming this action\n * @param {Object} issue Issue text to set on the ticket\n * @param {TicketCallback} callback Callback with the updated ticket.\n * @example\n * ticket.setIssue({ownerId}, 'This is the new issue string.', function(err, t) {\n *    if (err) throw err;\n *\n *    ticket.save(function(err, t) {\n *       if (err) throw err;\n *    });\n * });\n */\nticketSchema.methods.setIssue = function (ownerId, issue, callback) {\n  var marked = require('marked')\n\n  var self = this\n  issue = issue.replace(/(\\r\\n|\\n\\r|\\r|\\n)/g, '<br>')\n  issue = sanitizeHtml(issue).trim()\n  self.issue = xss(marked.parse(issue))\n\n  var historyItem = {\n    action: 'ticket:update:issue',\n    description: 'Ticket Issue was updated.',\n    owner: ownerId\n  }\n\n  self.history.push(historyItem)\n\n  return callback(null, self)\n}\n\nticketSchema.methods.setSubject = function (ownerId, subject, callback) {\n  var self = this\n  self.subject = subject\n  var historyItem = {\n    action: 'ticket:update:subject',\n    description: 'Ticket Subject was updated.',\n    owner: ownerId\n  }\n\n  self.history.push(historyItem)\n\n  return callback(null, self)\n}\n\n/**\n * Updates a given comment inside the comment array on this ticket\n * @instance\n * @method updateComment\n * @memberof Ticket\n *\n * @param {Object} ownerId Account ID preforming this action\n * @param {Object} commentId Comment ID to update\n * @param {String} commentText Text to update the comment to\n * @param {TicketCallback} callback Callback with the updated ticket.\n * @example\n * ticket.updateComment({ownerId}, {commentId} 'This is the new comment string.', function(err, t) {\n *    if (err) throw err;\n *\n *    ticket.save(function(err, t) {\n *       if (err) throw err;\n *    });\n * });\n */\nticketSchema.methods.updateComment = function (ownerId, commentId, commentText, callback) {\n  var self = this\n  var comment = _.find(self.comments, function (c) {\n    return c._id.toString() === commentId.toString()\n  })\n  if (_.isUndefined(comment)) return callback('Invalid Comment', null)\n\n  comment.comment = commentText\n\n  var historyItem = {\n    action: 'ticket:comment:updated',\n    description: 'Comment was updated: ' + commentId,\n    owner: ownerId\n  }\n  self.history.push(historyItem)\n\n  return callback(null, self)\n}\n\n/**\n * Removes a comment from the comment array on this ticket.\n * @instance\n * @method removeComment\n * @memberof Ticket\n *\n * @param {Object} ownerId Account ID preforming this action\n * @param {Object} commentId Comment ID to remove\n * @param {TicketCallback} callback Callback with the updated ticket.\n */\nticketSchema.methods.removeComment = function (ownerId, commentId, callback) {\n  var self = this\n  self.comments = _.reject(self.comments, function (o) {\n    return o._id.toString() === commentId.toString()\n  })\n\n  var historyItem = {\n    action: 'ticket:delete:comment',\n    description: 'Comment was deleted: ' + commentId,\n    owner: ownerId\n  }\n  self.history.push(historyItem)\n\n  return callback(null, self)\n}\n\n/**\n * Updates a given Note inside the note array on this ticket\n * @instance\n * @method updateNote\n * @memberof Ticket\n *\n * @param {Object} ownerId Account ID preforming this action\n * @param {Object} noteId Note ID to update\n * @param {String} noteText Text to update the note to\n * @param {TicketCallback} callback Callback with the updated ticket.\n * @example\n * ticket.updateNote({ownerId}, {noteId} 'This is the new note string.', function(err, t) {\n *    if (err) throw err;\n *\n *    ticket.save(function(err, t) {\n *       if (err) throw err;\n *    });\n * });\n */\nticketSchema.methods.updateNote = function (ownerId, noteId, noteText, callback) {\n  var self = this\n  var note = _.find(self.notes, function (c) {\n    return c._id.toString() === noteId.toString()\n  })\n  if (_.isUndefined(note)) return callback('Invalid Note', null)\n\n  note.note = noteText\n\n  var historyItem = {\n    action: 'ticket:note:updated',\n    description: 'Note was updated: ' + noteId,\n    owner: ownerId\n  }\n  self.history.push(historyItem)\n\n  return callback(null, self)\n}\n\n/**\n * Removes a note from the note array on this ticket.\n * @instance\n * @method removeNote\n * @memberof Ticket\n *\n * @param {Object} ownerId Account ID preforming this action\n * @param {Object} noteId Comment ID to remove\n * @param {TicketCallback} callback Callback with the updated ticket.\n */\nticketSchema.methods.removeNote = function (ownerId, noteId, callback) {\n  var self = this\n  self.notes = _.reject(self.notes, function (o) {\n    return o._id.toString() === noteId.toString()\n  })\n\n  var historyItem = {\n    action: 'ticket:delete:note',\n    description: 'Note was deleted: ' + noteId,\n    owner: ownerId\n  }\n  self.history.push(historyItem)\n\n  return callback(null, self)\n}\n\nticketSchema.methods.getAttachment = function (attachmentId, callback) {\n  var self = this\n  var attachment = _.find(self.attachments, function (o) {\n    return o._id.toString() === attachmentId.toString()\n  })\n\n  return callback(attachment)\n}\n\nticketSchema.methods.removeAttachment = function (ownerId, attachmentId, callback) {\n  var self = this\n  var attachment = _.find(self.attachments, function (o) {\n    return o._id.toString() === attachmentId.toString()\n  })\n  self.attachments = _.reject(self.attachments, function (o) {\n    return o._id.toString() === attachmentId.toString()\n  })\n\n  if (_.isUndefined(attachment)) {\n    return callback(null, self)\n  }\n\n  var historyItem = {\n    action: 'ticket:delete:attachment',\n    description: 'Attachment was deleted: ' + attachment.name,\n    owner: ownerId\n  }\n\n  self.history.push(historyItem)\n\n  return callback(null, self)\n}\n\nticketSchema.methods.addSubscriber = function (userId, callback) {\n  var self = this\n\n  var hasSub = _.some(self.subscribers, function (i) {\n    return i._id.toString() === userId.toString()\n  })\n\n  if (!hasSub) {\n    self.subscribers.push(userId)\n  }\n\n  return callback(null, self)\n}\n\nticketSchema.methods.removeSubscriber = function (userId, callback) {\n  var self = this\n\n  var user = _.find(self.subscribers, function (i) {\n    return i._id.toString() === userId.toString()\n  })\n\n  if (_.isUndefined(user) || _.isEmpty(user) || _.isNull(user)) return callback(null, self)\n\n  self.subscribers = _.reject(self.subscribers, function (i) {\n    return i._id.toString() === userId.toString()\n  })\n\n  return callback(null, self)\n}\n\n/**\n * Gets all tickets that are not marked as deleted <br> <br>\n *\n * **Deep populates: group, group.members, group.sendMailTo, comments, comments.owner**\n *\n * @memberof Ticket\n * @static\n * @method getAll\n * @param {QueryCallback} callback MongoDB Query Callback\n *\n * @example\n * ticketSchema.getAll(function(err, tickets) {\n *    if (err) throw err;\n *\n *    //tickets is an array\n * });\n */\nticketSchema.statics.getAll = function (callback) {\n  var self = this\n  var q = self\n    .model(COLLECTION)\n    .find({ deleted: false })\n    .populate('owner assignee', '-password -__v -preferences -iOSDeviceTokens -tOTPKey')\n    .populate('type tags group')\n    .sort({ status: 1 })\n    .lean()\n\n  return q.exec(callback)\n}\n\nticketSchema.statics.getForCache = function (callback) {\n  var self = this\n  var t365 = moment\n    .utc()\n    .hour(23)\n    .minute(59)\n    .second(59)\n    .subtract(365, 'd')\n    .toDate()\n  self\n    .model(COLLECTION)\n    .find({ date: { $gte: t365 }, deleted: false })\n    .select('_id uid date status history comments assignee owner tags')\n    .sort('date')\n    .lean()\n    .exec(callback)\n}\n\nticketSchema.statics.getAllNoPopulate = function (callback) {\n  var self = this\n  var q = self\n    .model(COLLECTION)\n    .find({ deleted: false })\n    .sort({ status: 1 })\n    .lean()\n\n  return q.exec(callback)\n}\n\nticketSchema.statics.getAllByStatus = function (status, callback) {\n  var self = this\n\n  if (!_.isArray(status)) {\n    status = [status]\n  }\n\n  var q = self\n    .model(COLLECTION)\n    .find({ status: { $in: status }, deleted: false })\n    .populate(\n      'owner assignee comments.owner notes.owner subscribers history.owner',\n      'username fullname email role image title'\n    )\n    .populate('type tags group')\n    .sort({ status: 1 })\n    .lean()\n\n  return q.exec(callback)\n}\n\n/**\n * Gets Tickets with a given group id.\n *\n * @memberof Ticket\n * @static\n * @method getTickets\n * @param {Array} grpIds Group Id to retrieve tickets for.\n * @param {QueryCallback} callback MongoDB Query Callback\n */\nticketSchema.statics.getTickets = function (grpIds, callback) {\n  if (_.isUndefined(grpIds)) {\n    return callback('Invalid GroupId - TicketSchema.GetTickets()', null)\n  }\n\n  if (!_.isArray(grpIds)) {\n    return callback('Invalid GroupId (Must be of type Array) - TicketSchema.GetTickets()', null)\n  }\n\n  var self = this\n\n  var q = self\n    .model(COLLECTION)\n    .find({ group: { $in: grpIds }, deleted: false })\n    .populate(\n      'owner assignee comments.owner notes.owner subscribers history.owner',\n      'username fullname email role image title'\n    )\n    .populate('type tags group')\n    .sort({ status: 1 })\n\n  return q.exec(callback)\n}\n\n/**\n * Gets Tickets with a given group id and a JSON Object <br/><br/>\n * *Sorts on UID desc.*\n * @memberof Ticket\n * @static\n * @method getTicketsWithObject\n *\n * @param {Object} grpId Group Id to retrieve tickets for.\n * @param {Object} object JSON Object with various options\n * @param {QueryCallback} callback MongoDB Query Callback\n *\n * @example\n * //Object Options\n * {\n *    limit: 10,\n *    page: 0,\n *    closed: false,\n *    status: 1\n * }\n */\nticketSchema.statics.getTicketsByDepartments = function (departments, object, callback) {\n  if (!departments || !_.isObject(departments) || !object)\n    return callback('Invalid Data - TicketSchema.GetTicketsByDepartments()')\n\n  var self = this\n\n  if (_.some(departments, { allGroups: true })) {\n    groupSchema.find({}, function (err, groups) {\n      if (err) return callback({ error: err })\n      return self.getTicketsWithObject(groups, object, callback)\n    })\n  } else {\n    var groups = _.flattenDeep(\n      departments.map(function (d) {\n        return d.groups.map(function (g) {\n          return g._id\n        })\n      })\n    )\n\n    return self.getTicketsWithObject(groups, object, callback)\n  }\n}\n\nticketSchema.statics.getTicketsWithObject = function (grpId, object, callback) {\n  if (_.isUndefined(grpId)) {\n    return callback('Invalid GroupId - TicketSchema.GetTickets()', null)\n  }\n\n  if (!_.isArray(grpId)) {\n    return callback('Invalid GroupId (Must be of type Array) - TicketSchema.GetTicketsWithObject()', null)\n  }\n\n  if (!_.isObject(object)) {\n    return callback('Invalid Object (Must be of type Object) - TicketSchema.GetTicketsWithObject()', null)\n  }\n\n  var self = this\n\n  var limit = !object.limit ? 10 : object.limit\n  var page = !object.page ? 0 : object.page\n  var _status = object.status\n\n  if (!_.isUndefined(object.filter) && !_.isUndefined(object.filter.groups)) {\n    var g = _.map(grpId, '_id').map(String)\n    grpId = _.intersection(object.filter.groups, g)\n  }\n\n  var q = self\n    .model(COLLECTION)\n    .find({ group: { $in: grpId }, deleted: false })\n    .populate(\n      'owner assignee subscribers comments.owner notes.owner history.owner',\n      'username fullname email role image title'\n    )\n    .populate('assignee', 'username fullname email role image title')\n    .populate('type tags group')\n    .sort({ uid: -1 })\n\n  if (limit !== -1) {\n    q.skip(page * limit).limit(limit)\n  }\n\n  if (_.isArray(_status) && _.size(_status) > 0) {\n    q.where({ status: { $in: _status } })\n  }\n\n  if (!_.isUndefined(object.filter)) {\n    if (!_.isUndefined(object.filter.uid)) {\n      object.filter.uid = parseInt(object.filter.uid)\n      if (!_.isNaN(object.filter.uid)) {\n        q.or([{ uid: object.filter.uid }])\n      }\n    }\n\n    if (!_.isUndefined(object.filter.priority)) {\n      q.where({ priority: { $in: object.filter.priority } })\n    }\n\n    if (!_.isUndefined(object.filter.types)) {\n      q.where({ type: { $in: object.filter.types } })\n    }\n\n    if (!_.isUndefined(object.filter.tags)) {\n      q.where({ tags: { $in: object.filter.tags } })\n    }\n\n    if (!_.isUndefined(object.filter.assignee)) {\n      q.where({ assignee: { $in: object.filter.assignee } })\n    }\n\n    if (!_.isUndefined(object.filter.unassigned)) {\n      q.where({ assignee: { $exists: false } })\n    }\n\n    if (!_.isUndefined(object.filter.owner)) {\n      q.where({ owner: { $in: object.filter.owner } })\n    }\n\n    if (!_.isUndefined(object.filter.subject)) {\n      q.or([{ subject: new RegExp(object.filter.subject, 'i') }])\n    }\n\n    if (!_.isUndefined(object.filter.issue)) {\n      q.or([{ issue: new RegExp(object.filter.issue, 'i') }])\n    }\n\n    if (!_.isUndefined(object.filter.date)) {\n      var startDate = new Date(2000, 0, 1, 0, 0, 1)\n      var endDate = new Date()\n      if (!_.isUndefined(object.filter.date.start)) {\n        startDate = new Date(object.filter.date.start)\n      }\n      if (!_.isUndefined(object.filter.date.end)) {\n        endDate = new Date(object.filter.date.end)\n      }\n\n      q.where({ date: { $gte: startDate, $lte: endDate } })\n    }\n  }\n\n  if (!_.isUndefined(object.owner) && !_.isNull(object.owner)) q.where('owner', object.owner)\n\n  if (!_.isUndefined(object.assignedSelf) && !_.isNull(object.assignedSelf)) q.where('assignee', object.user)\n  if (!_.isUndefined(object.unassigned) && !_.isNull(object.unassigned)) q.where({ assignee: { $exists: false } })\n\n  return q.exec(callback)\n}\n\nticketSchema.statics.getCountWithObject = function (grpId, object, callback) {\n  if (_.isUndefined(grpId)) {\n    return callback('Invalid GroupId - TicketSchema.GetCountWithObject()', null)\n  }\n\n  if (!_.isArray(grpId)) {\n    return callback('Invalid GroupId (Must be of type Array) - TicketSchema.GetCountWithObject()', null)\n  }\n\n  if (!_.isObject(object)) {\n    return callback('Invalid Object (Must be of type Object) - TicketSchema.GetCountWithObject()', null)\n  }\n\n  var self = this\n\n  if (!_.isUndefined(object.filter) && !_.isUndefined(object.filter.groups)) {\n    var g = _.map(grpId, '_id').map(String)\n    grpId = _.intersection(object.filter.groups, g)\n  }\n\n  var q = self.model(COLLECTION).countDocuments({ group: { $in: grpId }, deleted: false })\n  if (!_.isUndefined(object.status) && _.isArray(object.status)) {\n    var status = object.status.map(Number)\n    q.where({ status: { $in: status } })\n  }\n\n  if (!_.isUndefined(object.filter) && !_.isUndefined(object.filter.assignee)) {\n    q.where({ assignee: { $in: object.filter.assignee } })\n  }\n\n  if (!_.isUndefined(object.filter) && !_.isUndefined(object.filter.types)) {\n    q.where({ type: { $in: object.filter.types } })\n  }\n\n  if (!_.isUndefined(object.filter) && !_.isUndefined(object.filter.subject))\n    q.where({ subject: new RegExp(object.filter.subject, 'i') })\n\n  if (\n    !_.isUndefined(object.assignedSelf) &&\n    object.assignedSelf === true &&\n    !_.isUndefined(object.assignedUserId) &&\n    !_.isNull(object.assignedUserId)\n  ) {\n    q.where('assignee', object.assignedUserId)\n  }\n\n  if (!_.isUndefined(object.unassigned) && object.unassigned === true) {\n    q.where({ assignee: { $exists: false } })\n  }\n\n  if (!_.isUndefined(object.owner) && !_.isNull(object.owner)) q.where('owner', object.owner)\n\n  return q.lean().exec(callback)\n}\n\n/**\n * Gets Tickets for status in given group. <br/><br/>\n * *Sorts on UID desc*\n * @memberof Ticket\n * @static\n * @method getTicketsByStatus\n *\n * @param {Object} grpId Group Id to retrieve tickets for.\n * @param {Number} status Status number to check\n * @param {QueryCallback} callback MongoDB Query Callback\n */\nticketSchema.statics.getTicketsByStatus = function (grpId, status, callback) {\n  if (_.isUndefined(grpId)) {\n    return callback('Invalid GroupId - TicketSchema.GetTickets()', null)\n  }\n\n  if (!_.isArray(grpId)) {\n    return callback('Invalid GroupId (Must be of type Array) - TicketSchema.GetTickets()', null)\n  }\n\n  var self = this\n\n  var q = self\n    .model(COLLECTION)\n    .find({ group: { $in: grpId }, status: status, deleted: false })\n    .populate(\n      'owner assignee comments.owner notes.owner subscribers history.owner',\n      'username fullname email role image title'\n    )\n    .populate('type tags group')\n    .sort({ uid: -1 })\n\n  return q.exec(callback)\n}\n\n/**\n * Gets Single ticket with given UID.\n * @memberof Ticket\n * @static\n * @method getTicketByUid\n *\n * @param {Number} uid Unique Id for ticket.\n * @param {QueryCallback} callback MongoDB Query Callback\n */\nticketSchema.statics.getTicketByUid = function (uid, callback) {\n  if (_.isUndefined(uid)) return callback('Invalid Uid - TicketSchema.GetTicketByUid()', null)\n\n  var self = this\n\n  var q = self\n    .model(COLLECTION)\n    .findOne({ uid: uid, deleted: false })\n    .populate(\n      'owner assignee comments.owner notes.owner subscribers history.owner',\n      'username fullname email role image title'\n    )\n    .populate('type tags group')\n\n  return q.exec(callback)\n}\n\n/**\n * Gets Single ticket with given object _id.\n * @memberof Ticket\n * @static\n * @method getTicketById\n *\n * @param {Object} id MongoDb _id.\n * @param {QueryCallback} callback MongoDB Query Callback\n */\nticketSchema.statics.getTicketById = function (id, callback) {\n  if (_.isUndefined(id)) return callback('Invalid Id - TicketSchema.GetTicketById()', null)\n\n  var self = this\n\n  var q = self\n    .model(COLLECTION)\n    .findOne({ _id: id, deleted: false })\n    .populate(\n      'owner assignee comments.owner notes.owner subscribers history.owner',\n      'username fullname email role image title'\n    )\n    .populate('type tags')\n    .populate({\n      path: 'group',\n      model: groupSchema,\n      populate: [\n        {\n          path: 'members',\n          model: userSchema,\n          select: '-__v -iOSDeviceTokens -accessToken -tOTPKey'\n        },\n        {\n          path: 'sendMailTo',\n          model: userSchema,\n          select: '-__v -iOSDeviceTokens -accessToken -tOTPKey'\n        }\n      ]\n    })\n\n  return q.exec(callback)\n}\n\n/**\n * Gets tickets by given Requester User Id\n * @memberof Ticket\n * @static\n * @method getTicketsByRequester\n *\n * @param {Object} userId MongoDb _id of user.\n * @param {QueryCallback} callback MongoDB Query Callback\n */\nticketSchema.statics.getTicketsByRequester = function (userId, callback) {\n  if (_.isUndefined(userId)) return callback('Invalid Requester Id - TicketSchema.GetTicketsByRequester()', null)\n\n  var self = this\n\n  var q = self\n    .model(COLLECTION)\n    .find({ owner: userId, deleted: false })\n    .limit(10000)\n    .populate(\n      'owner assignee comments.owner notes.owner subscribers history.owner',\n      'username fullname email role image title'\n    )\n    .populate('type tags')\n    .populate({\n      path: 'group',\n      model: groupSchema,\n      populate: [\n        {\n          path: 'members',\n          model: userSchema,\n          select: '-__v -iOSDeviceTokens -accessToken -tOTPKey'\n        },\n        {\n          path: 'sendMailTo',\n          model: userSchema,\n          select: '-__v -iOSDeviceTokens -accessToken -tOTPKey'\n        }\n      ]\n    })\n\n  return q.exec(callback)\n}\n\nticketSchema.statics.getTicketsWithSearchString = function (grps, search, callback) {\n  if (_.isUndefined(grps) || _.isUndefined(search))\n    return callback('Invalid Post Data - TicketSchema.GetTicketsWithSearchString()', null)\n\n  var self = this\n\n  var tickets = []\n\n  async.parallel(\n    [\n      function (callback) {\n        var q = self\n          .model(COLLECTION)\n          .find({\n            group: { $in: grps },\n            deleted: false,\n            $where: '/^' + search + '.*/.test(this.uid)'\n          })\n          .populate(\n            'owner assignee comments.owner notes.owner subscribers history.owner',\n            'username fullname email role image title'\n          )\n          .populate('type tags group')\n          .limit(100)\n\n        q.exec(function (err, results) {\n          if (err) return callback(err)\n          tickets.push(results)\n\n          return callback(null)\n        })\n      },\n      function (callback) {\n        var q = self\n          .model(COLLECTION)\n          .find({\n            group: { $in: grps },\n            deleted: false,\n            subject: { $regex: search, $options: 'i' }\n          })\n          .populate(\n            'owner assignee comments.owner notes.owner subscribers history.owner',\n            'username fullname email role image title'\n          )\n          .populate('type tags group')\n          .limit(100)\n\n        q.exec(function (err, results) {\n          if (err) return callback(err)\n          tickets.push(results)\n\n          return callback(null)\n        })\n      },\n      function (callback) {\n        var q = self\n          .model(COLLECTION)\n          .find({\n            group: { $in: grps },\n            deleted: false,\n            issue: { $regex: search, $options: 'i' }\n          })\n          .populate(\n            'owner assignee comments.owner notes.owner subscribers history.owner',\n            'username fullname email role image title'\n          )\n          .populate('type tags group')\n          .limit(100)\n\n        q.exec(function (err, results) {\n          if (err) return callback(err)\n          tickets.push(results)\n\n          return callback(null)\n        })\n      }\n    ],\n    function (err) {\n      if (err) return callback(err, null)\n\n      var t = _.uniqBy(_.flatten(tickets), function (i) {\n        return i.uid\n      })\n\n      return callback(null, t)\n    }\n  )\n}\n\n/**\n * Gets tickets that are overdue\n * @memberof Ticket\n * @static\n * @method getOverdue\n *\n * @param {Array} grpId Group Array of User\n * @param {QueryCallback} callback MongoDB Query Callback\n */\nticketSchema.statics.getOverdue = function (grpId, callback) {\n  if (_.isUndefined(grpId)) return callback('Invalid Group Ids - TicketSchema.GetOverdue()', null)\n\n  var self = this\n\n  // Disable cache (TEMP 01/04/2019)\n  // var grpHash = hash(grpId);\n  // var cache = global.cache;\n  // if (cache) {\n  //     var overdue = cache.get('tickets:overdue:' + grpHash);\n  //     if (overdue)\n  //         return callback(null, overdue);\n  // }\n\n  async.waterfall(\n    [\n      function (next) {\n        return self\n          .model(COLLECTION)\n          .find({\n            group: { $in: grpId },\n            status: { $in: [0, 1] },\n            deleted: false\n          })\n          .select('_id date updated')\n          .lean()\n          .exec(next)\n      },\n      function (tickets, next) {\n        var t = _.map(tickets, function (i) {\n          return _.transform(\n            i,\n            function (result, value, key) {\n              if (key === '_id') result._id = value\n              if (key === 'priority') result.overdueIn = value.overdueIn\n              if (key === 'date') result.date = value\n              if (key === 'updated') result.updated = value\n            },\n            {}\n          )\n        })\n\n        return next(null, t)\n      },\n      function (tickets, next) {\n        var now = new Date()\n        var ids = _.filter(tickets, function (t) {\n          if (!t.date && !t.updated) {\n            return false\n          }\n\n          var timeout = null\n          if (t.updated) {\n            var updated = new Date(t.updated)\n            timeout = new Date(updated)\n            timeout.setMinutes(updated.getMinutes() + t.overdueIn)\n          } else {\n            var date = new Date(t.date)\n            timeout = new Date(date)\n            timeout.setMinutes(date.getMinutes() + t.overdueIn)\n          }\n\n          return now > timeout\n        })\n\n        ids = _.map(ids, '_id')\n\n        return next(null, ids)\n      },\n      function (ids, next) {\n        return self\n          .model(COLLECTION)\n          .find({ _id: { $in: ids } })\n          .limit(50)\n          .select('_id uid subject updated date')\n          .lean()\n          .exec(next)\n      }\n    ],\n    function (err, tickets) {\n      if (err) return callback(err, null)\n      // Disable cache (TEMP 01/04/2019)\n      // if (cache) cache.set('tickets:overdue:' + grpHash, tickets, 600); //10min\n\n      return callback(null, tickets)\n    }\n  )\n\n  // var q = self.model(COLLECTION).find({group: {$in: grpId}, status: {$in: [0,1]}, deleted: false})\n  //     .$where(function() {\n  //         return this.priority.overdueIn === undefined;\n  //         var now = new Date();\n  //         var timeout = null;\n  //         if (this.updated) {\n  //             timeout = new Date(this.updated);\n  //             timeout.setMinutes(timeout.getMinutes() + this.priority.overdueIn);\n  //         } else {\n  //             timeout = new Date(this.date);\n  //             timeout.setMinutes(timeout.getMinutes() + this.priority.overdueIn);\n  //         }\n  //         return now > timeout;\n  //     }).select('_id uid subject updated');\n  //\n  // q.lean().exec(function(err, results) {\n  //     if (err) return callback(err, null);\n  //     if (cache) cache.set('tickets:overdue:' + grpHash, results, 600); //10min\n  //\n  //     return callback(null, results);\n  // });\n\n  // TODO: Turn on when REDIS is impl\n  // This will be pres through server reload\n  // redisCache.getCache('$trudesk:tickets:overdue' + grpHash, function(err, value) {\n  //     if (err) return callback(err, null);\n  //     if (value) {\n  //         console.log('served from redis');\n  //         return callback(null, JSON.parse(value.data));\n  //     } else {\n  //         var q = self.model(COLLECTION).find({group: {$in: grpId}, status: 1, deleted: false})\n  //             .$where(function() {\n  //                 var now = new Date();\n  //                 var updated = new Date(this.updated);\n  //                 var timeout = new Date(updated);\n  //                 timeout.setDate(timeout.getDate() + 2);\n  //                 return now > timeout;\n  //             }).select('_id uid subject updated');\n  //\n  //         return q.lean().exec(function(err, results) {\n  //             if (err) return callback(err, null);\n  //             if (cache) {\n  //                 cache.set('tickets:overdue:' + grpHash, results, 600);\n  //             }\n  //             redisCache.setCache('tickets:' + grpHash, results, function(err) {\n  //                 return callback(err, results);\n  //             }, 600);\n  //         });\n  //     }\n  // });\n}\n\n/**\n * Gets tickets via tag id\n * @memberof Ticket\n * @static\n * @method getTicketsByTag\n *\n * @param {Array} grpId Group Array of User\n * @param {string} tagId Tag Id\n * @param {QueryCallback} callback MongoDB Query Callback\n */\nticketSchema.statics.getTicketsByTag = function (grpId, tagId, callback) {\n  if (_.isUndefined(grpId)) return callback('Invalid Group Ids - TicketSchema.GetTicketsByTag()', null)\n  if (_.isUndefined(tagId)) return callback('Invalid Tag Id - TicketSchema.GetTicketsByTag()', null)\n\n  var self = this\n\n  var q = self.model(COLLECTION).find({ group: { $in: grpId }, tags: tagId, deleted: false })\n\n  return q.exec(callback)\n}\n\n/**\n * Gets all tickets via tag id\n * @memberof Ticket\n * @static\n * @method getAllTicketsByTag\n *\n * @param {string} tagId Tag Id\n * @param {QueryCallback} callback MongoDB Query Callback\n */\nticketSchema.statics.getAllTicketsByTag = function (tagId, callback) {\n  if (_.isUndefined(tagId)) return callback('Invalid Tag Id - TicketSchema.GetAllTicketsByTag()', null)\n\n  var self = this\n\n  var q = self.model(COLLECTION).find({ tags: tagId, deleted: false })\n\n  return q.exec(callback)\n}\n\n/**\n * Gets tickets via type id\n * @memberof Ticket\n * @static\n * @method getTicketsByType\n *\n * @param {Array} grpId Group Array of User\n * @param {string} typeId Type Id\n * @param {QueryCallback} callback MongoDB Query Callback\n * @param {Boolean} limit Should Limit results?\n */\nticketSchema.statics.getTicketsByType = function (grpId, typeId, callback, limit) {\n  if (_.isUndefined(grpId)) return callback('Invalid Group Ids = TicketSchema.GetTicketsByType()', null)\n  if (_.isUndefined(typeId)) return callback('Invalid Ticket Type Id - TicketSchema.GetTicketsByType()', null)\n\n  var self = this\n\n  var q = self.model(COLLECTION).find({ group: { $in: grpId }, type: typeId, deleted: false })\n  if (limit) {\n    q.limit(1000)\n  }\n\n  return q.lean().exec(callback)\n}\n\n/**\n * Gets all tickets via type id\n * @memberof Ticket\n * @static\n * @method getAllTicketsByType\n *\n * @param {string} typeId Type Id\n * @param {QueryCallback} callback MongoDB Query Callback\n */\nticketSchema.statics.getAllTicketsByType = function (typeId, callback) {\n  if (_.isUndefined(typeId)) return callback('Invalid Ticket Type Id - TicketSchema.GetAllTicketsByType()', null)\n\n  var self = this\n  var q = self.model(COLLECTION).find({ type: typeId })\n\n  return q.lean().exec(callback)\n}\n\nticketSchema.statics.updateType = function (oldTypeId, newTypeId, callback) {\n  if (_.isUndefined(oldTypeId) || _.isUndefined(newTypeId)) {\n    return callback('Invalid IDs - TicketSchema.UpdateType()', null)\n  }\n\n  var self = this\n  return self.model(COLLECTION).updateMany({ type: oldTypeId }, { $set: { type: newTypeId } }, callback)\n}\n\nticketSchema.statics.getAssigned = function (userId, callback) {\n  if (_.isUndefined(userId)) return callback('Invalid Id - TicketSchema.GetAssigned()', null)\n\n  var self = this\n\n  var q = self\n    .model(COLLECTION)\n    .find({ assignee: userId, deleted: false, status: { $ne: 3 } })\n    .populate(\n      'owner assignee comments.owner notes.owner subscribers history.owner',\n      'username fullname email role image title'\n    )\n    .populate('type tags group')\n\n  return q.exec(callback)\n}\n\n/**\n * Gets count of X Top Groups\n *\n * @memberof Ticket\n * @static\n * @method getTopTicketGroups\n *\n * @param {Number} timespan Timespan to get the top groups (default: 9999)\n * @param {Number} top Top number of Groups to return (default: 5)\n * @param {QueryCallback} callback MongoDB Query Callback\n * @example\n * ticketSchema.getTopTicketGroups(5, function(err, results) {\n *    if (err) throw err;\n *\n *    //results is an array with name of group and count of total tickets\n *    results[x].name\n *    results[x].count\n * });\n */\nticketSchema.statics.getTopTicketGroups = function (timespan, top, callback) {\n  if (_.isUndefined(timespan) || _.isNaN(timespan) || timespan === 0) timespan = -1\n  if (_.isUndefined(top) || _.isNaN(top)) top = 5\n\n  var self = this\n\n  var today = moment\n    .utc()\n    .hour(23)\n    .minute(59)\n    .second(59)\n  var tsDate = today.clone().subtract(timespan, 'd')\n  var query = {\n    date: { $gte: tsDate.toDate(), $lte: today.toDate() },\n    deleted: false\n  }\n  if (timespan === -1) {\n    query = { deleted: false }\n  }\n\n  var q = self\n    .model(COLLECTION)\n    .find(query)\n    .select('group')\n    .populate('group', 'name')\n    .lean()\n\n  var topCount = []\n  var ticketsDb = []\n\n  async.waterfall(\n    [\n      function (next) {\n        q.exec(function (err, t) {\n          if (err) return next(err)\n\n          var arr = []\n\n          for (var i = 0; i < t.length; i++) {\n            var ticket = t[i]\n            if (ticket.group) {\n              ticketsDb.push({\n                ticketId: ticket._id,\n                groupId: ticket.group._id\n              })\n              var o = {}\n              o._id = ticket.group._id\n              o.name = ticket.group.name\n\n              if (!_.filter(arr, { name: o.name }).length) {\n                arr.push(o)\n              }\n            }\n          }\n\n          return next(null, _.uniq(arr))\n        })\n      },\n      function (grps, next) {\n        for (var g = 0; g < grps.length; g++) {\n          var tickets = []\n          var grp = grps[g]\n          for (var i = 0; i < ticketsDb.length; i++) {\n            if (ticketsDb[i].groupId === grp._id) {\n              tickets.push(ticketsDb)\n            }\n          }\n\n          topCount.push({ name: grp.name, count: tickets.length })\n        }\n\n        topCount = _.sortBy(topCount, function (o) {\n          return -o.count\n        })\n\n        topCount = topCount.slice(0, top)\n\n        return next(null, topCount)\n      }\n    ],\n    function (err, result) {\n      if (err) return callback(err, null)\n\n      return callback(null, result)\n    }\n  )\n}\n\nticketSchema.statics.getTagCount = function (tagId, callback) {\n  if (_.isUndefined(tagId)) return callback('Invalid Tag Id - TicketSchema.GetTagCount()', null)\n\n  var self = this\n\n  var q = self.model(COLLECTION).countDocuments({ tags: tagId, deleted: false })\n\n  return q.exec(callback)\n}\n\nticketSchema.statics.getTypeCount = function (typeId, callback) {\n  if (_.isUndefined(typeId)) return callback('Invalid Type Id - TicketSchema.GetTypeCount()', null)\n\n  var self = this\n\n  var q = self.model(COLLECTION).countDocuments({ type: typeId, deleted: false })\n\n  return q.exec(callback)\n}\n\nticketSchema.statics.getCount = function (callback) {\n  var q = this.model(COLLECTION)\n    .countDocuments({ deleted: false })\n    .lean()\n  return q.exec(callback)\n}\n\n/**\n * Mark a ticket as deleted in MongoDb <br/><br/>\n * *Ticket has its ```deleted``` flag set to true*\n *\n * @memberof Ticket\n * @static\n * @method softDelete\n *\n * @param {Object} oId Ticket Object _id\n * @param {QueryCallback} callback MongoDB Query Callback\n */\nticketSchema.statics.softDelete = function (oId, callback) {\n  if (_.isUndefined(oId)) return callback('Invalid ObjectID - TicketSchema.SoftDelete()', null)\n\n  var self = this\n\n  return self.model(COLLECTION).findOneAndUpdate({ _id: oId }, { deleted: true }, { new: true }, callback)\n}\n\nticketSchema.statics.softDeleteUid = function (uid, callback) {\n  if (_.isUndefined(uid)) return callback({ message: 'Invalid UID - TicketSchema.SoftDeleteUid()' })\n\n  return this.model(COLLECTION).findOneAndUpdate({ uid: uid }, { deleted: true }, { new: true }, callback)\n}\n\nticketSchema.statics.restoreDeleted = function (oId, callback) {\n  if (_.isUndefined(oId)) return callback('Invalid ObjectID - TicketSchema.RestoreDeleted()', null)\n\n  var self = this\n\n  return self.model(COLLECTION).findOneAndUpdate({ _id: oId }, { deleted: false }, { new: true }, callback)\n}\n\nticketSchema.statics.getDeleted = function (callback) {\n  return this.model(COLLECTION)\n    .find({ deleted: true })\n    .populate('group')\n    .sort({ uid: -1 })\n    .limit(1000)\n    .exec(callback)\n}\n\nfunction statusToString (status) {\n  var str\n  switch (status) {\n    case 0:\n      str = 'New'\n      break\n    case 1:\n      str = 'Open'\n      break\n    case 2:\n      str = 'Pending'\n      break\n    case 3:\n      str = 'Closed'\n      break\n    default:\n      str = status\n      break\n  }\n\n  return str\n}\n\nmodule.exports = mongoose.model(COLLECTION, ticketSchema)\n", "/*\n *       .                             .o8                     oooo\n *    .o8                             \"888                     `888\n *  .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\n *    888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\n *    888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\n *    888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\n *    \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\n *  ========================================================================\n *  Author:     Chris Brame\n *  Updated:    1/20/19 4:43 PM\n *  Copyright (c) 2014-2019. All rights reserved.\n */\n\n// var _               = require('lodash');\nvar mongoose = require('mongoose')\nvar moment = require('moment')\nrequire('moment-duration-format')\nvar utils = require('../helpers/utils')\n\nvar COLLECTION = 'priorities'\n\nvar prioritySchema = mongoose.Schema(\n  {\n    name: { type: String, required: true, unique: true },\n    overdueIn: { type: Number, required: true, default: 2880 }, // Minutes until overdue (48 Hours)\n    htmlColor: { type: String, default: '#29b955' },\n\n    migrationNum: { type: Number, index: true }, // Needed to convert <1.0 priorities to new format.\n    default: { type: Boolean }\n  },\n  {\n    toJSON: {\n      virtuals: true\n    }\n  }\n)\n\nprioritySchema.pre('save', function (next) {\n  this.name = utils.sanitizeFieldPlainText(this.name.trim())\n\n  return next()\n})\n\nprioritySchema.virtual('durationFormatted').get(function () {\n  var priority = this\n  return moment\n    .duration(priority.overdueIn, 'minutes')\n    .format('Y [year], M [month], d [day], h [hour], m [min]', { trim: 'both' })\n})\n\nprioritySchema.statics.getPriority = function (_id, callback) {\n  return this.model(COLLECTION)\n    .findOne({ _id: _id })\n    .exec(callback)\n}\n\nprioritySchema.statics.getPriorities = function (callback) {\n  return this.model(COLLECTION)\n    .find({})\n    .exec(callback)\n}\n\nprioritySchema.statics.getByMigrationNum = function (num, callback) {\n  var q = this.model(COLLECTION).findOne({ migrationNum: num })\n\n  return q.exec(callback)\n}\n\nmodule.exports = mongoose.model(COLLECTION, prioritySchema)\n", "/*\n *       .                             .o8                     oooo\n *    .o8                             \"888                     `888\n *  .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\n *    888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\n *    888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\n *    888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\n *    \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\n *  ========================================================================\n *  Author:     Chris Brame\n *  Updated:    1/20/19 4:43 PM\n *  Copyright (c) 2014-2019. All rights reserved.\n */\n\nvar _ = require('lodash')\nvar mongoose = require('mongoose')\nvar utils = require('../helpers/utils')\n\nvar COLLECTION = 'tickettypes'\n\n// Needed for Population\nrequire('./ticketpriority')\n\n/**\n * TicketType Schema\n * @module models/tickettype\n * @class TicketType\n\n *\n * @property {object} _id ```Required``` ```unique``` MongoDB Object ID\n * @property {String} name ```Required``` ```unique``` Name of Ticket Type\n */\nvar ticketTypeSchema = mongoose.Schema({\n  name: { type: String, required: true, unique: true },\n  priorities: [{ type: mongoose.Schema.Types.ObjectId, ref: 'priorities' }]\n})\n\nvar autoPopulatePriorities = function (next) {\n  this.populate('priorities')\n  return next()\n}\n\nticketTypeSchema.pre('find', autoPopulatePriorities)\nticketTypeSchema.pre('findOne', autoPopulatePriorities)\n\nticketTypeSchema.pre('save', function (next) {\n  this.name = utils.sanitizeFieldPlainText(this.name.trim())\n\n  return next()\n})\n\n/**\n * Return all Ticket Types\n *\n * @memberof TicketType\n * @static\n * @method getTypes\n *\n * @param {QueryCallback} callback MongoDB Query Callback\n */\nticketTypeSchema.statics.getTypes = function (callback) {\n  var q = this.model(COLLECTION).find({})\n\n  return q.exec(callback)\n}\n\n/**\n * Return Single Ticket Types\n *\n * @memberof TicketType\n * @static\n * @method getType\n *\n * @param {String} id Object Id of ticket type\n * @param {QueryCallback} callback MongoDB Query Callback\n */\nticketTypeSchema.statics.getType = function (id, callback) {\n  var q = this.model(COLLECTION).findOne({ _id: id })\n\n  return q.exec(callback)\n}\n\n/**\n * Return Single Ticket Type based on given type name\n *\n * @memberof TicketType\n * @static\n * @method getTypeByName\n *\n * @param {String} name Name of Ticket Type to search for\n * @param {QueryCallback} callback MongoDB Query Callback\n */\nticketTypeSchema.statics.getTypeByName = function (name, callback) {\n  var q = this.model(COLLECTION).findOne({ name: name })\n\n  return q.exec(callback)\n}\n\nticketTypeSchema.methods.addPriority = function (priorityId, callback) {\n  if (!priorityId) return callback({ message: 'Invalid Priority Id' })\n\n  var self = this\n\n  if (!_.isArray(self.priorities)) {\n    self.priorities = []\n  }\n\n  self.priorities.push(priorityId)\n\n  return callback(null, self)\n}\n\nticketTypeSchema.methods.removePriority = function (priorityId, callback) {\n  if (!priorityId) return callback({ message: 'Invalid Priority Id' })\n\n  var self = this\n\n  self.priorities = _.reject(self.priorities, function (p) {\n    return p._id.toString() === priorityId.toString()\n  })\n\n  return callback(null, self)\n}\n\nmodule.exports = mongoose.model(COLLECTION, ticketTypeSchema)\n", "/*\n *       .                             .o8                     oooo\n *    .o8                             \"888                     `888\n *  .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\n *    888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\n *    888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\n *    888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\n *    \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\n *  ========================================================================\n *  Author:     Chris Brame\n *  Updated:    1/20/19 4:43 PM\n *  Copyright (c) 2014-2019. All rights reserved.\n */\n\nvar async = require('async')\nvar mongoose = require('mongoose')\nvar winston = require('winston')\nvar bcrypt = require('bcrypt')\nvar _ = require('lodash')\nvar Chance = require('chance')\nconst utils = require('../helpers/utils')\n\n// Required for linkage\nrequire('./role')\n\nvar SALT_FACTOR = 10\nvar COLLECTION = 'accounts'\n\n/**\n * User Schema\n * @module models/user\n * @class User\n *\n * @property {object} _id ```Required``` ```unique``` MongoDB Object ID\n * @property {String} username ```Required``` ```unique``` Username of user\n * @property {String} password ```Required``` Bcrypt password\n * @property {String} fullname ```Required``` Full name of user\n * @property {String} email ```Required``` ```unique``` Email Address of user\n * @property {String} role ```Required``` Permission role of the given user. See {@link Permissions}\n * @property {Date} lastOnline Last timestamp given user was online.\n * @property {String} title Job Title of user\n * @property {String} image Filename of user image\n * @property {String} resetPassHash Password reset has for recovery password link.\n * @property {Date} resetPassExpire Date when the password recovery link will expire\n * @property {String} tOTPKey One Time Password Secret Key\n * @property {Number} tOTPPeriod One Time Password Key Length (Time) - Default 30 Seconds\n * @property {String} accessToken API Access Token\n * @property {Array} iOSDeviceTokens Array of String based device Ids for Apple iOS devices. *push notifications*\n * @property {Object} preferences Object to hold user preferences\n * @property {Boolean} preferences.autoRefreshTicketGrid Enable the auto refresh of the ticket grid.\n * @property {Boolean} deleted Account Deleted\n */\nvar userSchema = mongoose.Schema({\n  username: { type: String, required: true, unique: true, lowercase: true },\n  password: { type: String, required: true, select: false },\n  fullname: { type: String, required: true, index: true },\n  email: { type: String, required: true, unique: true, lowercase: true },\n  role: { type: mongoose.Schema.Types.ObjectId, ref: 'roles', required: true },\n  lastOnline: Date,\n  title: String,\n  image: String,\n\n  resetPassHash: { type: String, select: false },\n  resetPassExpire: { type: Date, select: false },\n  tOTPKey: { type: String, select: false },\n  tOTPPeriod: { type: Number, select: false },\n  resetL2AuthHash: { type: String, select: false },\n  resetL2AuthExpire: { type: Date, select: false },\n  hasL2Auth: { type: Boolean, required: true, default: false },\n  accessToken: { type: String, sparse: true, select: false },\n\n  preferences: {\n    tourCompleted: { type: Boolean, default: false },\n    autoRefreshTicketGrid: { type: Boolean, default: true },\n    openChatWindows: [{ type: String, default: [] }]\n  },\n\n  deleted: { type: Boolean, default: false }\n})\n\nuserSchema.set('toObject', { getters: true })\n\nvar autoPopulateRole = function (next) {\n  this.populate('role', 'name description normalized _id')\n  next()\n}\n\nuserSchema.pre('findOne', autoPopulateRole).pre('find', autoPopulateRole)\n\nuserSchema.pre('save', function (next) {\n  var user = this\n\n  user.username = utils.sanitizeFieldPlainText(user.username.toLowerCase().trim())\n  user.email = utils.sanitizeFieldPlainText(user.email.trim())\n\n  if (user.fullname) user.fullname = utils.sanitizeFieldPlainText(user.fullname.trim())\n  if (user.title) user.title = utils.sanitizeFieldPlainText(user.title.trim())\n\n  if (!user.isModified('password')) {\n    return next()\n  }\n\n  bcrypt.genSalt(SALT_FACTOR, function (err, salt) {\n    if (err) return next(err)\n\n    bcrypt.hash(user.password, salt, function (err, hash) {\n      if (err) return next(err)\n\n      user.password = hash\n      return next()\n    })\n  })\n})\n\nuserSchema.methods.addAccessToken = function (callback) {\n  var user = this\n  var date = new Date()\n  var salt = user.username.toString() + date.toISOString()\n  var chance = new Chance(salt)\n  user.accessToken = chance.hash()\n  user.save(function (err) {\n    if (err) return callback(err, null)\n\n    return callback(null, user.accessToken)\n  })\n}\n\nuserSchema.methods.removeAccessToken = function (callback) {\n  var user = this\n  if (!user.accessToken) return callback()\n\n  user.accessToken = undefined\n  user.save(function (err) {\n    if (err) return callback(err, null)\n\n    return callback()\n  })\n}\n\nuserSchema.methods.generateL2Auth = function (callback) {\n  var user = this\n  if (_.isUndefined(user.tOTPKey) || _.isNull(user.tOTPKey)) {\n    var chance = new Chance()\n    var base32 = require('thirty-two')\n\n    var genOTPKey = chance.string({\n      length: 7,\n      pool: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ23456789'\n    })\n    var base32GenOTPKey = base32\n      .encode(genOTPKey)\n      .toString()\n      .replace(/=/g, '')\n\n    user.tOTPKey = base32GenOTPKey\n    user.hasL2Auth = true\n    user.save(function (err) {\n      if (err) return callback(err)\n\n      return callback(null, base32GenOTPKey)\n    })\n  } else {\n    return callback()\n  }\n}\n\nuserSchema.methods.removeL2Auth = function (callback) {\n  var user = this\n\n  user.tOTPKey = undefined\n  user.hasL2Auth = false\n  user.save(function (err) {\n    if (err) return callback(err, null)\n\n    return callback()\n  })\n}\n\nuserSchema.methods.addDeviceToken = function (token, type, callback) {\n  if (_.isUndefined(token)) return callback('Invalid token')\n  var user = this\n  // type 1 = iOS\n  // type 2 = Android\n  if (type === 1) {\n    if (hasDeviceToken(user, token, type)) return callback(null, token)\n\n    user.iOSDeviceTokens.push(token)\n    user.save(function (err) {\n      if (err) return callback(err, null)\n\n      callback(null, token)\n    })\n  }\n}\n\nuserSchema.methods.removeDeviceToken = function (token, type, callback) {\n  var user = this\n  if (type === 1) {\n    if (!hasDeviceToken(user, token, type)) return callback()\n\n    winston.debug('Removing Device: ' + token)\n    user.iOSDeviceTokens.splice(_.indexOf(this.iOSDeviceTokens, token), 1)\n    user.save(function (err, u) {\n      if (err) return callback(err, null)\n\n      return callback(null, u.iOSDeviceTokens)\n    })\n  }\n}\n\nuserSchema.methods.addOpenChatWindow = function (convoId, callback) {\n  if (convoId === undefined) {\n    if (!_.isFunction(callback)) return false\n    return callback('Invalid convoId')\n  }\n  var user = this\n  var hasChatWindow =\n    _.filter(user.preferences.openChatWindows, function (value) {\n      return value.toString() === convoId.toString()\n    }).length > 0\n\n  if (hasChatWindow) {\n    if (!_.isFunction(callback)) return false\n    return callback()\n  }\n  user.preferences.openChatWindows.push(convoId.toString())\n  user.save(function (err, u) {\n    if (err) {\n      if (!_.isFunction(callback)) return false\n      return callback(err)\n    }\n\n    if (!_.isFunction(callback)) return false\n    return callback(null, u.preferences.openChatWindows)\n  })\n}\n\nuserSchema.methods.removeOpenChatWindow = function (convoId, callback) {\n  if (convoId === undefined) {\n    if (!_.isFunction(callback)) return false\n    return callback('Invalid convoId')\n  }\n  var user = this\n  var hasChatWindow =\n    _.filter(user.preferences.openChatWindows, function (value) {\n      return value.toString() === convoId.toString()\n    }).length > 0\n\n  if (!hasChatWindow) {\n    if (!_.isFunction(callback)) return false\n    return callback()\n  }\n  user.preferences.openChatWindows.splice(\n    _.findIndex(user.preferences.openChatWindows, function (item) {\n      return item.toString() === convoId.toString()\n    }),\n    1\n  )\n\n  user.save(function (err, u) {\n    if (err) {\n      if (!_.isFunction(callback)) return false\n      return callback(err)\n    }\n\n    if (!_.isFunction(callback)) return false\n    return callback(null, u.preferences.openChatWindows)\n  })\n}\n\nuserSchema.methods.softDelete = function (callback) {\n  var user = this\n\n  user.deleted = true\n\n  user.save(function (err) {\n    if (err) return callback(err, false)\n\n    callback(null, true)\n  })\n}\n\nuserSchema.statics.validate = function (password, dbPass) {\n  return bcrypt.compareSync(password, dbPass)\n}\n\n/**\n * Gets all users\n *\n * @memberof User\n * @static\n * @method findAll\n *\n * @param {QueryCallback} callback MongoDB Query Callback\n */\nuserSchema.statics.findAll = function (callback) {\n  return this.model(COLLECTION).find({}, callback)\n}\n\n/**\n * Gets user via object _id\n *\n * @memberof User\n * @static\n * @method getUser\n *\n * @param {Object} oId Object _id to Query MongoDB\n * @param {QueryCallback} callback MongoDB Query Callback\n */\nuserSchema.statics.getUser = function (oId, callback) {\n  if (_.isUndefined(oId)) {\n    return callback('Invalid ObjectId - UserSchema.GetUser()', null)\n  }\n\n  return this.model(COLLECTION).findOne({ _id: oId }, callback)\n}\n\n/**\n * Gets user via username\n *\n * @memberof User\n * @static\n * @method getUserByUsername\n *\n * @param {String} user Username to Query MongoDB\n * @param {QueryCallback} callback MongoDB Query Callback\n */\nuserSchema.statics.getUserByUsername = function (user, callback) {\n  if (_.isUndefined(user)) {\n    return callback('Invalid Username - UserSchema.GetUserByUsername()', null)\n  }\n\n  return this.model(COLLECTION)\n    .findOne({ username: new RegExp('^' + user + '$', 'i') })\n    .select('+password +accessToken')\n    .exec(callback)\n}\n\nuserSchema.statics.getByUsername = userSchema.statics.getUserByUsername\n\n/**\n * Gets user via email\n *\n * @memberof User\n * @static\n * @method getUserByEmail\n *\n * @param {String} email Email to Query MongoDB\n * @param {QueryCallback} callback MongoDB Query Callback\n */\nuserSchema.statics.getUserByEmail = function (email, callback) {\n  if (_.isUndefined(email)) {\n    return callback('Invalid Email - UserSchema.GetUserByEmail()', null)\n  }\n\n  return this.model(COLLECTION).findOne({ email: email.toLowerCase() }, callback)\n}\n\n/**\n * Gets user via reset password hash\n *\n * @memberof User\n * @static\n * @method getUserByResetHash\n *\n * @param {String} hash Hash to Query MongoDB\n * @param {QueryCallback} callback MongoDB Query Callback\n */\nuserSchema.statics.getUserByResetHash = function (hash, callback) {\n  if (_.isUndefined(hash)) {\n    return callback('Invalid Hash - UserSchema.GetUserByResetHash()', null)\n  }\n\n  return this.model(COLLECTION).findOne(\n    { resetPassHash: hash, deleted: false },\n    '+resetPassHash +resetPassExpire',\n    callback\n  )\n}\n\nuserSchema.statics.getUserByL2ResetHash = function (hash, callback) {\n  if (_.isUndefined(hash)) {\n    return callback('Invalid Hash - UserSchema.GetUserByL2ResetHash()', null)\n  }\n\n  return this.model(COLLECTION).findOne(\n    { resetL2AuthHash: hash, deleted: false },\n    '+resetL2AuthHash +resetL2AuthExpire',\n    callback\n  )\n}\n\n/**\n * Gets user via API Access Token\n *\n * @memberof User\n * @static\n * @method getUserByAccessToken\n *\n * @param {String} token Access Token to Query MongoDB\n * @param {QueryCallback} callback MongoDB Query Callback\n */\nuserSchema.statics.getUserByAccessToken = function (token, callback) {\n  if (_.isUndefined(token)) {\n    return callback('Invalid Token - UserSchema.GetUserByAccessToken()', null)\n  }\n\n  return this.model(COLLECTION).findOne({ accessToken: token, deleted: false }, '+password', callback)\n}\n\nuserSchema.statics.getUserWithObject = function (object, callback) {\n  if (!_.isObject(object)) {\n    return callback('Invalid Object (Must be of type Object) - UserSchema.GetUserWithObject()', null)\n  }\n\n  var self = this\n\n  var limit = object.limit === null ? 10 : object.limit\n  var page = object.page === null ? 0 : object.page\n  var search = object.search === null ? '' : object.search\n\n  var q = self\n    .model(COLLECTION)\n    .find({}, '-password -resetPassHash -resetPassExpire')\n    .sort({ fullname: 1 })\n    .skip(page * limit)\n  if (limit !== -1) {\n    q.limit(limit)\n  }\n\n  if (!object.showDeleted) q.where({ deleted: false })\n\n  if (!_.isEmpty(search)) {\n    q.where({ fullname: new RegExp('^' + search.toLowerCase(), 'i') })\n  }\n\n  return q.exec(callback)\n}\n\n/**\n * Gets users based on permissions > mod\n *\n * @memberof User\n * @static\n * @method getAssigneeUsers\n *\n * @param {QueryCallback} callback MongoDB Query Callback\n */\nuserSchema.statics.getAssigneeUsers = function (callback) {\n  var roles = global.roles\n  if (_.isUndefined(roles)) return callback(null, [])\n\n  var assigneeRoles = []\n  async.each(roles, function (role) {\n    if (role.isAgent) assigneeRoles.push(role._id)\n  })\n\n  assigneeRoles = _.uniq(assigneeRoles)\n  this.model(COLLECTION).find({ role: { $in: assigneeRoles }, deleted: false }, function (err, users) {\n    if (err) {\n      winston.warn(err)\n      return callback(err, null)\n    }\n\n    return callback(null, _.sortBy(users, 'fullname'))\n  })\n}\n\n/**\n * Gets users based on roles\n *\n * @memberof User\n * @static\n * @method getUsersByRoles\n *\n * @param {Array} roles Array of role ids\n * @param {QueryCallback} callback MongoDB Query Callback\n */\nuserSchema.statics.getUsersByRoles = function (roles, callback) {\n  if (_.isUndefined(roles)) return callback('Invalid roles array', null)\n  if (!_.isArray(roles)) {\n    roles = [roles]\n  }\n\n  var q = this.model(COLLECTION).find({ role: { $in: roles }, deleted: false })\n\n  return q.exec(callback)\n}\n\n/**\n * Creates a user with the given data object\n *\n * @memberof User\n * @static\n * @method createUser\n *\n * @param {User} data JSON data object of new User\n * @param {QueryCallback} callback MongoDB Query Callback\n */\nuserSchema.statics.createUser = function (data, callback) {\n  if (_.isUndefined(data) || _.isUndefined(data.username)) {\n    return callback('Invalid User Data - UserSchema.CreateUser()', null)\n  }\n\n  var self = this\n\n  self.model(COLLECTION).find({ username: data.username }, function (err, items) {\n    if (err) {\n      return callback(err, null)\n    }\n\n    if (_.size(items) > 0) {\n      return callback('Username Already Exists', null)\n    }\n\n    return self.collection.insert(data, callback)\n  })\n}\n\n/**\n * Creates a user with only Email address. Emails user password.\n *\n * @param email\n * @param callback\n */\nuserSchema.statics.createUserFromEmail = function (email, callback) {\n  if (_.isUndefined(email)) {\n    return callback('Invalid User Data - UserSchema.CreatePublicUser()', null)\n  }\n\n  var self = this\n\n  var settingSchema = require('./setting')\n  settingSchema.getSetting('role:user:default', function (err, userRoleDefault) {\n    if (err || !userRoleDefault) return callback('Invalid Setting - UserRoleDefault')\n\n    var Chance = require('chance')\n\n    var chance = new Chance()\n\n    var plainTextPass = chance.string({\n      length: 6,\n      pool: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890'\n    })\n\n    var user = new self({\n      username: email,\n      email: email,\n      password: plainTextPass,\n      fullname: email,\n      role: userRoleDefault.value\n    })\n\n    self.model(COLLECTION).find({ username: user.username }, function (err, items) {\n      if (err) return callback(err)\n      if (_.size(items) > 0) return callback('Username already exists')\n\n      user.save(function (err, savedUser) {\n        if (err) return callback(err)\n\n        // Create a group for this user\n        var GroupSchema = require('./group')\n        var group = new GroupSchema({\n          name: savedUser.email,\n          members: [savedUser._id],\n          sendMailTo: [savedUser._id],\n          public: true\n        })\n\n        group.save(function (err, group) {\n          if (err) return callback(err)\n\n          // Send welcome email\n          var path = require('path')\n          var mailer = require('../mailer')\n          var Email = require('email-templates')\n          var templateDir = path.resolve(__dirname, '..', 'mailer', 'templates')\n\n          var email = new Email({\n            views: {\n              root: templateDir,\n              options: {\n                extension: 'handlebars'\n              }\n            }\n          })\n\n          var settingSchema = require('./setting')\n          settingSchema.getSetting('gen:siteurl', function (err, setting) {\n            if (err) return callback(err)\n\n            if (!setting) {\n              setting = { value: '' }\n            }\n\n            var dataObject = {\n              user: savedUser,\n              plainTextPassword: plainTextPass,\n              baseUrl: setting.value\n            }\n\n            email\n              .render('public-account-created', dataObject)\n              .then(function (html) {\n                var mailOptions = {\n                  to: savedUser.email,\n                  subject: 'Welcome to trudesk! - Here are your account details.',\n                  html: html,\n                  generateTextFromHTML: true\n                }\n\n                mailer.sendMail(mailOptions, function (err) {\n                  if (err) {\n                    winston.warn(err)\n                    return callback(err)\n                  }\n\n                  return callback(null, { user: savedUser, group: group })\n                })\n              })\n              .catch(function (err) {\n                winston.warn(err)\n                return callback(err)\n              })\n          })\n        })\n      })\n    })\n  })\n}\n\nuserSchema.statics.getCustomers = function (obj, callback) {\n  var limit = obj.limit || 10\n  var page = obj.page || 0\n  var self = this\n  return self\n    .model(COLLECTION)\n    .find({}, '-password -resetPassHash -resetPassExpire')\n    .exec(function (err, accounts) {\n      if (err) return callback(err)\n\n      var customerRoleIds = _.filter(accounts, function (a) {\n        return !a.role.isAdmin && !a.role.isAgent\n      }).map(function (a) {\n        return a.role._id\n      })\n\n      var q = self\n        .find({ role: { $in: customerRoleIds } }, '-password -resetPassHash -resetPassExpire')\n        .sort({ fullname: 1 })\n        .skip(page * limit)\n        .limit(limit)\n\n      if (!obj.showDeleted) q.where({ deleted: false })\n\n      q.exec(callback)\n    })\n}\n\nuserSchema.statics.getAgents = function (obj, callback) {\n  var limit = obj.limit || 10\n  var page = obj.page || 0\n  var self = this\n\n  return self\n    .model(COLLECTION)\n    .find({})\n    .exec(function (err, accounts) {\n      if (err) return callback(err)\n\n      var agentRoleIds = _.filter(accounts, function (a) {\n        return a.role.isAgent\n      }).map(function (a) {\n        return a.role._id\n      })\n\n      var q = self\n        .model(COLLECTION)\n        .find({ role: { $in: agentRoleIds } }, '-password -resetPassHash -resetPassExpire')\n        .sort({ fullname: 1 })\n        .skip(page * limit)\n        .limit(limit)\n\n      if (!obj.showDeleted) q.where({ deleted: false })\n\n      q.exec(callback)\n    })\n}\n\nuserSchema.statics.getAdmins = function (obj, callback) {\n  var limit = obj.limit || 10\n  var page = obj.page || 0\n  var self = this\n\n  return self\n    .model(COLLECTION)\n    .find({})\n    .exec(function (err, accounts) {\n      if (err) return callback(err)\n\n      var adminRoleIds = _.filter(accounts, function (a) {\n        return a.role.isAdmin\n      }).map(function (a) {\n        return a.role._id\n      })\n\n      var q = self\n        .model(COLLECTION)\n        .find({ role: { $in: adminRoleIds } }, '-password -resetPassHash -resetPassExpire')\n        .sort({ fullname: 1 })\n        .skip(page * limit)\n        .limit(limit)\n\n      if (!obj.showDeleted) q.where({ deleted: false })\n\n      q.exec(callback)\n    })\n}\n\n/**\n * Checks if a user has device token already\n *\n * @memberof User\n * @instance\n * @method hasDeviceToken\n *\n * @param {User} user User to check against\n * @param {String} token token to check for in given user\n * @param {Number} type Type of Device token to check.\n * @return {Boolean}\n * @example\n * type:\n *   1: iOS\n *   2: Android\n *   3: Windows\n */\nfunction hasDeviceToken (user, token, type) {\n  if (type === 1) {\n    var matches = _.filter(user.iOSDeviceTokens, function (value) {\n      if (value === token) {\n        return value\n      }\n    })\n\n    return matches.length > 0\n  }\n\n  return false\n}\n\nmodule.exports = mongoose.model(COLLECTION, userSchema)\n"], "filenames": ["src/helpers/utils/index.js", "src/models/attachment.js", "src/models/department.js", "src/models/group.js", "src/models/notice.js", "src/models/role.js", "src/models/tag.js", "src/models/team.js", "src/models/ticket.js", "src/models/ticketpriority.js", "src/models/tickettype.js", "src/models/user.js"], "buggy_code_start_loc": [15, 15, 17, 16, 12, 17, 15, 16, 22, 18, 16, 20], "buggy_code_end_loc": [16, 27, 40, 48, 45, 56, 36, 43, 124, 40, 47, 96], "fixing_code_start_loc": [15, 16, 18, 17, 13, 18, 16, 17, 23, 19, 17, 21], "fixing_code_end_loc": [26, 28, 41, 49, 47, 57, 37, 44, 125, 41, 48, 98], "type": "CWE-79", "message": "Stored XSS in \"Name\", \"Group Name\" & \"Title\" in GitHub repository polonel/trudesk prior to v1.2.0. This allows attackers to execute malicious scripts in the user's browser and it can lead to session hijacking, sensitive data exposure, and worse.", "other": {"cve": {"id": "CVE-2022-1290", "sourceIdentifier": "security@huntr.dev", "published": "2022-04-10T16:15:07.907", "lastModified": "2023-03-07T22:39:11.490", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Stored XSS in \"Name\", \"Group Name\" & \"Title\" in GitHub repository polonel/trudesk prior to v1.2.0. This allows attackers to execute malicious scripts in the user's browser and it can lead to session hijacking, sensitive data exposure, and worse."}, {"lang": "es", "value": "Una vulnerabilidad de tipo XSS almacenado en \"Name\", \"Group Name\" &amp; \"Title\" en el repositorio de GitHub polonel/trudesk versiones anteriores a v1.2.0. Esto permite a atacantes ejecutar scripts maliciosos en el navegador del usuario y puede conllevar a un secuestro de la sesi\u00f3n, una exposici\u00f3n de datos confidenciales y cosas peores"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:R/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.0, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 2.3, "impactScore": 6.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 3.5}, "baseSeverity": "LOW", "exploitabilityScore": 6.8, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:trudesk_project:trudesk:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.2.0", "matchCriteriaId": "485D4AC2-2B88-49BA-B298-AB78A027FCE8"}]}]}], "references": [{"url": "https://github.com/polonel/trudesk/commit/4f48b3bb86ba66a0085803591065bb6437e864ec", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/da6d03e6-053f-43b6-99a7-78c2e386e3ed", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/polonel/trudesk/commit/4f48b3bb86ba66a0085803591065bb6437e864ec"}}