{"buggy_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * ex_eval.c: functions for Ex command line for the +eval feature.\n */\n\n#include \"vim.h\"\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n\nstatic char\t*get_end_emsg(cstack_T *cstack);\n\n/*\n * Exception handling terms:\n *\n *\t:try\t\t\":try\" command\t\t\\\n *\t    ...\t\ttry block\t\t|\n *\t:catch RE\t\":catch\" command\t|\n *\t    ...\t\tcatch clause\t\t|- try conditional\n *\t:finally\t\":finally\" command\t|\n *\t    ...\t\tfinally clause\t\t|\n *\t:endtry\t\t\":endtry\" command\t/\n *\n * The try conditional may have any number of catch clauses and at most one\n * finally clause.  A \":throw\" command can be inside the try block, a catch\n * clause, the finally clause, or in a function called or script sourced from\n * there or even outside the try conditional.  Try conditionals may be nested.\n */\n\n/*\n * Configuration whether an exception is thrown on error or interrupt.  When\n * the preprocessor macros below evaluate to FALSE, an error (did_emsg) or\n * interrupt (got_int) under an active try conditional terminates the script\n * after the non-active finally clauses of all active try conditionals have been\n * executed.  Otherwise, errors and/or interrupts are converted into catchable\n * exceptions (did_throw additionally set), which terminate the script only if\n * not caught.  For user exceptions, only did_throw is set.  (Note: got_int can\n * be set asynchronously afterwards by a SIGINT, so did_throw && got_int is not\n * a reliant test that the exception currently being thrown is an interrupt\n * exception.  Similarly, did_emsg can be set afterwards on an error in an\n * (unskipped) conditional command inside an inactive conditional, so did_throw\n * && did_emsg is not a reliant test that the exception currently being thrown\n * is an error exception.)  -  The macros can be defined as expressions checking\n * for a variable that is allowed to be changed during execution of a script.\n */\n#if 0\n// Expressions used for testing during the development phase.\n# define THROW_ON_ERROR\t\t(!eval_to_number(\"$VIMNOERRTHROW\"))\n# define THROW_ON_INTERRUPT\t(!eval_to_number(\"$VIMNOINTTHROW\"))\n# define THROW_TEST\n#else\n// Values used for the Vim release.\n# define THROW_ON_ERROR\t\tTRUE\n# define THROW_ON_ERROR_TRUE\n# define THROW_ON_INTERRUPT\tTRUE\n# define THROW_ON_INTERRUPT_TRUE\n#endif\n\n/*\n * When several errors appear in a row, setting \"force_abort\" is delayed until\n * the failing command returned.  \"cause_abort\" is set to TRUE meanwhile, in\n * order to indicate that situation.  This is useful when \"force_abort\" was set\n * during execution of a function call from an expression: the aborting of the\n * expression evaluation is done without producing any error messages, but all\n * error messages on parsing errors during the expression evaluation are given\n * (even if a try conditional is active).\n */\nstatic int cause_abort = FALSE;\n\n/*\n * Return TRUE when immediately aborting on error, or when an interrupt\n * occurred or an exception was thrown but not caught.  Use for \":{range}call\"\n * to check whether an aborted function that does not handle a range itself\n * should be called again for the next line in the range.  Also used for\n * cancelling expression evaluation after a function call caused an immediate\n * abort.  Note that the first emsg() call temporarily resets \"force_abort\"\n * until the throw point for error messages has been reached.  That is, during\n * cancellation of an expression evaluation after an aborting function call or\n * due to a parsing error, aborting() always returns the same value.\n * \"got_int\" is also set by calling interrupt().\n */\n    int\naborting(void)\n{\n    return (did_emsg && force_abort) || got_int || did_throw;\n}\n\n/*\n * The value of \"force_abort\" is temporarily reset by the first emsg() call\n * during an expression evaluation, and \"cause_abort\" is used instead.  It might\n * be necessary to restore \"force_abort\" even before the throw point for the\n * error message has been reached.  update_force_abort() should be called then.\n */\n    void\nupdate_force_abort(void)\n{\n    if (cause_abort)\n\tforce_abort = TRUE;\n}\n\n/*\n * Return TRUE if a command with a subcommand resulting in \"retcode\" should\n * abort the script processing.  Can be used to suppress an autocommand after\n * execution of a failing subcommand as long as the error message has not been\n * displayed and actually caused the abortion.\n */\n    int\nshould_abort(int retcode)\n{\n    return ((retcode == FAIL && trylevel != 0 && !emsg_silent) || aborting());\n}\n\n/*\n * Return TRUE if a function with the \"abort\" flag should not be considered\n * ended on an error.  This means that parsing commands is continued in order\n * to find finally clauses to be executed, and that some errors in skipped\n * commands are still reported.\n */\n    int\naborted_in_try(void)\n{\n    // This function is only called after an error.  In this case, \"force_abort\"\n    // determines whether searching for finally clauses is necessary.\n    return force_abort;\n}\n\n/*\n * cause_errthrow(): Cause a throw of an error exception if appropriate.\n * Return TRUE if the error message should not be displayed by emsg().\n * Sets \"ignore\", if the emsg() call should be ignored completely.\n *\n * When several messages appear in the same command, the first is usually the\n * most specific one and used as the exception value.  The \"severe\" flag can be\n * set to TRUE, if a later but severer message should be used instead.\n */\n    int\ncause_errthrow(\n    char_u\t*mesg,\n    int\t\tsevere,\n    int\t\t*ignore)\n{\n    msglist_T\t*elem;\n    msglist_T\t**plist;\n\n    /*\n     * Do nothing when displaying the interrupt message or reporting an\n     * uncaught exception (which has already been discarded then) at the top\n     * level.  Also when no exception can be thrown.  The message will be\n     * displayed by emsg().\n     */\n    if (suppress_errthrow)\n\treturn FALSE;\n\n    /*\n     * If emsg() has not been called previously, temporarily reset\n     * \"force_abort\" until the throw point for error messages has been\n     * reached.  This ensures that aborting() returns the same value for all\n     * errors that appear in the same command.  This means particularly that\n     * for parsing errors during expression evaluation emsg() will be called\n     * multiply, even when the expression is evaluated from a finally clause\n     * that was activated due to an aborting error, interrupt, or exception.\n     */\n    if (!did_emsg)\n    {\n\tcause_abort = force_abort;\n\tforce_abort = FALSE;\n    }\n\n    /*\n     * If no try conditional is active and no exception is being thrown and\n     * there has not been an error in a try conditional or a throw so far, do\n     * nothing (for compatibility of non-EH scripts).  The message will then\n     * be displayed by emsg().  When \":silent!\" was used and we are not\n     * currently throwing an exception, do nothing.  The message text will\n     * then be stored to v:errmsg by emsg() without displaying it.\n     */\n    if (((trylevel == 0 && !cause_abort) || emsg_silent) && !did_throw)\n\treturn FALSE;\n\n    /*\n     * Ignore an interrupt message when inside a try conditional or when an\n     * exception is being thrown or when an error in a try conditional or\n     * throw has been detected previously.  This is important in order that an\n     * interrupt exception is catchable by the innermost try conditional and\n     * not replaced by an interrupt message error exception.\n     */\n    if (mesg == (char_u *)_(e_interrupted))\n    {\n\t*ignore = TRUE;\n\treturn TRUE;\n    }\n\n    /*\n     * Ensure that all commands in nested function calls and sourced files\n     * are aborted immediately.\n     */\n    cause_abort = TRUE;\n\n    /*\n     * When an exception is being thrown, some commands (like conditionals) are\n     * not skipped.  Errors in those commands may affect what of the subsequent\n     * commands are regarded part of catch and finally clauses.  Catching the\n     * exception would then cause execution of commands not intended by the\n     * user, who wouldn't even get aware of the problem.  Therefore, discard the\n     * exception currently being thrown to prevent it from being caught.  Just\n     * execute finally clauses and terminate.\n     */\n    if (did_throw)\n    {\n\t// When discarding an interrupt exception, reset got_int to prevent the\n\t// same interrupt being converted to an exception again and discarding\n\t// the error exception we are about to throw here.\n\tif (current_exception->type == ET_INTERRUPT)\n\t    got_int = FALSE;\n\tdiscard_current_exception();\n    }\n\n#ifdef THROW_TEST\n    if (!THROW_ON_ERROR)\n    {\n\t/*\n\t * Print error message immediately without searching for a matching\n\t * catch clause; just finally clauses are executed before the script\n\t * is terminated.\n\t */\n\treturn FALSE;\n    }\n    else\n#endif\n    {\n\t/*\n\t * Prepare the throw of an error exception, so that everything will\n\t * be aborted (except for executing finally clauses), until the error\n\t * exception is caught; if still uncaught at the top level, the error\n\t * message will be displayed and the script processing terminated\n\t * then.  -  This function has no access to the conditional stack.\n\t * Thus, the actual throw is made after the failing command has\n\t * returned.  -  Throw only the first of several errors in a row, except\n\t * a severe error is following.\n\t */\n\tif (msg_list != NULL)\n\t{\n\t    plist = msg_list;\n\t    while (*plist != NULL)\n\t\tplist = &(*plist)->next;\n\n\t    elem = ALLOC_CLEAR_ONE(msglist_T);\n\t    if (elem == NULL)\n\t    {\n\t\tsuppress_errthrow = TRUE;\n\t\temsg(_(e_out_of_memory));\n\t    }\n\t    else\n\t    {\n\t\telem->msg = (char *)vim_strsave(mesg);\n\t\tif (elem->msg == NULL)\n\t\t{\n\t\t    vim_free(elem);\n\t\t    suppress_errthrow = TRUE;\n\t\t    emsg(_(e_out_of_memory));\n\t\t}\n\t\telse\n\t\t{\n\t\t    elem->next = NULL;\n\t\t    elem->throw_msg = NULL;\n\t\t    *plist = elem;\n\t\t    if (plist == msg_list || severe)\n\t\t    {\n\t\t\tchar\t    *tmsg;\n\n\t\t\t// Skip the extra \"Vim \" prefix for message \"E458\".\n\t\t\ttmsg = elem->msg;\n\t\t\tif (STRNCMP(tmsg, \"Vim E\", 5) == 0\n\t\t\t\t&& VIM_ISDIGIT(tmsg[5])\n\t\t\t\t&& VIM_ISDIGIT(tmsg[6])\n\t\t\t\t&& VIM_ISDIGIT(tmsg[7])\n\t\t\t\t&& tmsg[8] == ':'\n\t\t\t\t&& tmsg[9] == ' ')\n\t\t\t    (*msg_list)->throw_msg = &tmsg[4];\n\t\t\telse\n\t\t\t    (*msg_list)->throw_msg = tmsg;\n\t\t    }\n\n\t\t    // Get the source name and lnum now, it may change before\n\t\t    // reaching do_errthrow().\n\t\t    elem->sfile = estack_sfile(ESTACK_NONE);\n\t\t    elem->slnum = SOURCING_LNUM;\n\t\t    elem->msg_compiling = estack_compiling;\n\t\t}\n\t    }\n\t}\n\treturn TRUE;\n    }\n}\n\n/*\n * Free a \"msg_list\" and the messages it contains.\n */\n    static void\nfree_msglist(msglist_T *l)\n{\n    msglist_T  *messages, *next;\n\n    messages = l;\n    while (messages != NULL)\n    {\n\tnext = messages->next;\n\tvim_free(messages->msg);\n\tvim_free(messages->sfile);\n\tvim_free(messages);\n\tmessages = next;\n    }\n}\n\n/*\n * Free global \"*msg_list\" and the messages it contains, then set \"*msg_list\"\n * to NULL.\n */\n    void\nfree_global_msglist(void)\n{\n    free_msglist(*msg_list);\n    *msg_list = NULL;\n}\n\n/*\n * Throw the message specified in the call to cause_errthrow() above as an\n * error exception.  If cstack is NULL, postpone the throw until do_cmdline()\n * has returned (see do_one_cmd()).\n */\n    void\ndo_errthrow(cstack_T *cstack, char_u *cmdname)\n{\n    /*\n     * Ensure that all commands in nested function calls and sourced files\n     * are aborted immediately.\n     */\n    if (cause_abort)\n    {\n\tcause_abort = FALSE;\n\tforce_abort = TRUE;\n    }\n\n    // If no exception is to be thrown or the conversion should be done after\n    // returning to a previous invocation of do_one_cmd(), do nothing.\n    if (msg_list == NULL || *msg_list == NULL)\n\treturn;\n\n    if (throw_exception(*msg_list, ET_ERROR, cmdname) == FAIL)\n\tfree_msglist(*msg_list);\n    else\n    {\n\tif (cstack != NULL)\n\t    do_throw(cstack);\n\telse\n\t    need_rethrow = TRUE;\n    }\n    *msg_list = NULL;\n}\n\n/*\n * do_intthrow(): Replace the current exception by an interrupt or interrupt\n * exception if appropriate.  Return TRUE if the current exception is discarded,\n * FALSE otherwise.\n */\n    int\ndo_intthrow(cstack_T *cstack)\n{\n    /*\n     * If no interrupt occurred or no try conditional is active and no exception\n     * is being thrown, do nothing (for compatibility of non-EH scripts).\n     */\n    if (!got_int || (trylevel == 0 && !did_throw))\n\treturn FALSE;\n\n#ifdef THROW_TEST\t// avoid warning for condition always true\n    if (!THROW_ON_INTERRUPT)\n    {\n\t/*\n\t * The interrupt aborts everything except for executing finally clauses.\n\t * Discard any user or error or interrupt exception currently being\n\t * thrown.\n\t */\n\tif (did_throw)\n\t    discard_current_exception();\n    }\n    else\n#endif\n    {\n\t/*\n\t * Throw an interrupt exception, so that everything will be aborted\n\t * (except for executing finally clauses), until the interrupt exception\n\t * is caught; if still uncaught at the top level, the script processing\n\t * will be terminated then.  -  If an interrupt exception is already\n\t * being thrown, do nothing.\n\t *\n\t */\n\tif (did_throw)\n\t{\n\t    if (current_exception->type == ET_INTERRUPT)\n\t\treturn FALSE;\n\n\t    // An interrupt exception replaces any user or error exception.\n\t    discard_current_exception();\n\t}\n\tif (throw_exception(\"Vim:Interrupt\", ET_INTERRUPT, NULL) != FAIL)\n\t    do_throw(cstack);\n    }\n\n    return TRUE;\n}\n\n/*\n * Get an exception message that is to be stored in current_exception->value.\n */\n    char *\nget_exception_string(\n    void\t*value,\n    except_type_T type,\n    char_u\t*cmdname,\n    int\t\t*should_free)\n{\n    char\t*ret;\n    char\t*mesg;\n    int\t\tcmdlen;\n    char\t*p, *val;\n\n    if (type == ET_ERROR)\n    {\n\t*should_free = TRUE;\n\tmesg = ((msglist_T *)value)->throw_msg;\n\tif (cmdname != NULL && *cmdname != NUL)\n\t{\n\t    cmdlen = (int)STRLEN(cmdname);\n\t    ret = (char *)vim_strnsave((char_u *)\"Vim(\",\n\t\t\t\t\t\t4 + cmdlen + 2 + STRLEN(mesg));\n\t    if (ret == NULL)\n\t\treturn ret;\n\t    STRCPY(&ret[4], cmdname);\n\t    STRCPY(&ret[4 + cmdlen], \"):\");\n\t    val = ret + 4 + cmdlen + 2;\n\t}\n\telse\n\t{\n\t    ret = (char *)vim_strnsave((char_u *)\"Vim:\", 4 + STRLEN(mesg));\n\t    if (ret == NULL)\n\t\treturn ret;\n\t    val = ret + 4;\n\t}\n\n\t// msg_add_fname may have been used to prefix the message with a file\n\t// name in quotes.  In the exception value, put the file name in\n\t// parentheses and move it to the end.\n\tfor (p = mesg; ; p++)\n\t{\n\t    if (*p == NUL\n\t\t    || (*p == 'E'\n\t\t\t&& VIM_ISDIGIT(p[1])\n\t\t\t&& (p[2] == ':'\n\t\t\t    || (VIM_ISDIGIT(p[2])\n\t\t\t\t&& (p[3] == ':'\n\t\t\t\t    || (VIM_ISDIGIT(p[3])\n\t\t\t\t\t&& p[4] == ':'))))))\n\t    {\n\t\tif (*p == NUL || p == mesg)\n\t\t    STRCAT(val, mesg);  // 'E123' missing or at beginning\n\t\telse\n\t\t{\n\t\t    // '\"filename\" E123: message text'\n\t\t    if (mesg[0] != '\"' || p-2 < &mesg[1] ||\n\t\t\t    p[-2] != '\"' || p[-1] != ' ')\n\t\t\t// \"E123:\" is part of the file name.\n\t\t\tcontinue;\n\n\t\t    STRCAT(val, p);\n\t\t    p[-2] = NUL;\n\t\t    sprintf((char *)(val + STRLEN(p)), \" (%s)\", &mesg[1]);\n\t\t    p[-2] = '\"';\n\t\t}\n\t\tbreak;\n\t    }\n\t}\n    }\n    else\n    {\n\t*should_free = FALSE;\n\tret = value;\n    }\n\n    return ret;\n}\n\n\n/*\n * Throw a new exception.  Return FAIL when out of memory or it was tried to\n * throw an illegal user exception.  \"value\" is the exception string for a\n * user or interrupt exception, or points to a message list in case of an\n * error exception.\n */\n    int\nthrow_exception(void *value, except_type_T type, char_u *cmdname)\n{\n    except_T\t*excp;\n    int\t\tshould_free;\n\n    /*\n     * Disallow faking Interrupt or error exceptions as user exceptions.  They\n     * would be treated differently from real interrupt or error exceptions\n     * when no active try block is found, see do_cmdline().\n     */\n    if (type == ET_USER)\n    {\n\tif (STRNCMP((char_u *)value, \"Vim\", 3) == 0\n\t\t&& (((char_u *)value)[3] == NUL || ((char_u *)value)[3] == ':'\n\t\t    || ((char_u *)value)[3] == '('))\n\t{\n\t    emsg(_(e_cannot_throw_exceptions_with_vim_prefix));\n\t    goto fail;\n\t}\n    }\n\n    excp = ALLOC_ONE(except_T);\n    if (excp == NULL)\n\tgoto nomem;\n\n    if (type == ET_ERROR)\n\t// Store the original message and prefix the exception value with\n\t// \"Vim:\" or, if a command name is given, \"Vim(cmdname):\".\n\texcp->messages = (msglist_T *)value;\n\n    excp->value = get_exception_string(value, type, cmdname, &should_free);\n    if (excp->value == NULL && should_free)\n\tgoto nomem;\n\n    excp->type = type;\n    if (type == ET_ERROR && ((msglist_T *)value)->sfile != NULL)\n    {\n\tmsglist_T *entry = (msglist_T *)value;\n\n\texcp->throw_name = entry->sfile;\n\tentry->sfile = NULL;\n\texcp->throw_lnum = entry->slnum;\n    }\n    else\n    {\n\texcp->throw_name = estack_sfile(ESTACK_NONE);\n\tif (excp->throw_name == NULL)\n\t    excp->throw_name = vim_strsave((char_u *)\"\");\n\tif (excp->throw_name == NULL)\n\t{\n\t    if (should_free)\n\t\tvim_free(excp->value);\n\t    goto nomem;\n\t}\n\texcp->throw_lnum = SOURCING_LNUM;\n    }\n\n    if (p_verbose >= 13 || debug_break_level > 0)\n    {\n\tint\tsave_msg_silent = msg_silent;\n\n\tif (debug_break_level > 0)\n\t    msg_silent = FALSE;\t\t// display messages\n\telse\n\t    verbose_enter();\n\t++no_wait_return;\n\tif (debug_break_level > 0 || *p_vfile == NUL)\n\t    msg_scroll = TRUE;\t    // always scroll up, don't overwrite\n\n\tsmsg(_(\"Exception thrown: %s\"), excp->value);\n\tmsg_puts(\"\\n\");   // don't overwrite this either\n\n\tif (debug_break_level > 0 || *p_vfile == NUL)\n\t    cmdline_row = msg_row;\n\t--no_wait_return;\n\tif (debug_break_level > 0)\n\t    msg_silent = save_msg_silent;\n\telse\n\t    verbose_leave();\n    }\n\n    current_exception = excp;\n    return OK;\n\nnomem:\n    vim_free(excp);\n    suppress_errthrow = TRUE;\n    emsg(_(e_out_of_memory));\nfail:\n    current_exception = NULL;\n    return FAIL;\n}\n\n/*\n * Discard an exception.  \"was_finished\" is set when the exception has been\n * caught and the catch clause has been ended normally.\n */\n    static void\ndiscard_exception(except_T *excp, int was_finished)\n{\n    char_u\t\t*saved_IObuff;\n\n    if (current_exception == excp)\n\tcurrent_exception = NULL;\n    if (excp == NULL)\n    {\n\tinternal_error(\"discard_exception()\");\n\treturn;\n    }\n\n    if (p_verbose >= 13 || debug_break_level > 0)\n    {\n\tint\tsave_msg_silent = msg_silent;\n\n\tsaved_IObuff = vim_strsave(IObuff);\n\tif (debug_break_level > 0)\n\t    msg_silent = FALSE;\t\t// display messages\n\telse\n\t    verbose_enter();\n\t++no_wait_return;\n\tif (debug_break_level > 0 || *p_vfile == NUL)\n\t    msg_scroll = TRUE;\t    // always scroll up, don't overwrite\n\tsmsg(was_finished\n\t\t    ? _(\"Exception finished: %s\")\n\t\t    : _(\"Exception discarded: %s\"),\n\t\texcp->value);\n\tmsg_puts(\"\\n\");   // don't overwrite this either\n\tif (debug_break_level > 0 || *p_vfile == NUL)\n\t    cmdline_row = msg_row;\n\t--no_wait_return;\n\tif (debug_break_level > 0)\n\t    msg_silent = save_msg_silent;\n\telse\n\t    verbose_leave();\n\tSTRCPY(IObuff, saved_IObuff);\n\tvim_free(saved_IObuff);\n    }\n    if (excp->type != ET_INTERRUPT)\n\tvim_free(excp->value);\n    if (excp->type == ET_ERROR)\n\tfree_msglist(excp->messages);\n    vim_free(excp->throw_name);\n    vim_free(excp);\n}\n\n/*\n * Discard the exception currently being thrown.\n */\n    void\ndiscard_current_exception(void)\n{\n    if (current_exception != NULL)\n\tdiscard_exception(current_exception, FALSE);\n    did_throw = FALSE;\n    need_rethrow = FALSE;\n}\n\n/*\n * Put an exception on the caught stack.\n */\n    void\ncatch_exception(except_T *excp)\n{\n    excp->caught = caught_stack;\n    caught_stack = excp;\n    set_vim_var_string(VV_EXCEPTION, (char_u *)excp->value, -1);\n    if (*excp->throw_name != NUL)\n    {\n\tif (excp->throw_lnum != 0)\n\t    vim_snprintf((char *)IObuff, IOSIZE, _(\"%s, line %ld\"),\n\t\t\t\t    excp->throw_name, (long)excp->throw_lnum);\n\telse\n\t    vim_snprintf((char *)IObuff, IOSIZE, \"%s\", excp->throw_name);\n\tset_vim_var_string(VV_THROWPOINT, IObuff, -1);\n    }\n    else\n\t// throw_name not set on an exception from a command that was typed.\n\tset_vim_var_string(VV_THROWPOINT, NULL, -1);\n\n    if (p_verbose >= 13 || debug_break_level > 0)\n    {\n\tint\tsave_msg_silent = msg_silent;\n\n\tif (debug_break_level > 0)\n\t    msg_silent = FALSE;\t\t// display messages\n\telse\n\t    verbose_enter();\n\t++no_wait_return;\n\tif (debug_break_level > 0 || *p_vfile == NUL)\n\t    msg_scroll = TRUE;\t    // always scroll up, don't overwrite\n\n\tsmsg(_(\"Exception caught: %s\"), excp->value);\n\tmsg_puts(\"\\n\");   // don't overwrite this either\n\n\tif (debug_break_level > 0 || *p_vfile == NUL)\n\t    cmdline_row = msg_row;\n\t--no_wait_return;\n\tif (debug_break_level > 0)\n\t    msg_silent = save_msg_silent;\n\telse\n\t    verbose_leave();\n    }\n}\n\n/*\n * Remove an exception from the caught stack.\n */\n    static void\nfinish_exception(except_T *excp)\n{\n    if (excp != caught_stack)\n\tinternal_error(\"finish_exception()\");\n    caught_stack = caught_stack->caught;\n    if (caught_stack != NULL)\n    {\n\tset_vim_var_string(VV_EXCEPTION, (char_u *)caught_stack->value, -1);\n\tif (*caught_stack->throw_name != NUL)\n\t{\n\t    if (caught_stack->throw_lnum != 0)\n\t\tvim_snprintf((char *)IObuff, IOSIZE,\n\t\t\t_(\"%s, line %ld\"), caught_stack->throw_name,\n\t\t\t(long)caught_stack->throw_lnum);\n\t    else\n\t\tvim_snprintf((char *)IObuff, IOSIZE, \"%s\",\n\t\t\t\t\t\t    caught_stack->throw_name);\n\t    set_vim_var_string(VV_THROWPOINT, IObuff, -1);\n\t}\n\telse\n\t    // throw_name not set on an exception from a command that was\n\t    // typed.\n\t    set_vim_var_string(VV_THROWPOINT, NULL, -1);\n    }\n    else\n    {\n\tset_vim_var_string(VV_EXCEPTION, NULL, -1);\n\tset_vim_var_string(VV_THROWPOINT, NULL, -1);\n    }\n\n    // Discard the exception, but use the finish message for 'verbose'.\n    discard_exception(excp, TRUE);\n}\n\n/*\n * Flags specifying the message displayed by report_pending.\n */\n#define RP_MAKE\t\t0\n#define RP_RESUME\t1\n#define RP_DISCARD\t2\n\n/*\n * Report information about something pending in a finally clause if required by\n * the 'verbose' option or when debugging.  \"action\" tells whether something is\n * made pending or something pending is resumed or discarded.  \"pending\" tells\n * what is pending.  \"value\" specifies the return value for a pending \":return\"\n * or the exception value for a pending exception.\n */\n    static void\nreport_pending(int action, int pending, void *value)\n{\n    char\t*mesg;\n    char\t*s;\n    int\t\tsave_msg_silent;\n\n\n    switch (action)\n    {\n\tcase RP_MAKE:\n\t    mesg = _(\"%s made pending\");\n\t    break;\n\tcase RP_RESUME:\n\t    mesg = _(\"%s resumed\");\n\t    break;\n\t// case RP_DISCARD:\n\tdefault:\n\t    mesg = _(\"%s discarded\");\n\t    break;\n    }\n\n    switch (pending)\n    {\n\tcase CSTP_NONE:\n\t    return;\n\n\tcase CSTP_CONTINUE:\n\t    s = \":continue\";\n\t    break;\n\tcase CSTP_BREAK:\n\t    s = \":break\";\n\t    break;\n\tcase CSTP_FINISH:\n\t    s = \":finish\";\n\t    break;\n\tcase CSTP_RETURN:\n\t    // \":return\" command producing value, allocated\n\t    s = (char *)get_return_cmd(value);\n\t    break;\n\n\tdefault:\n\t    if (pending & CSTP_THROW)\n\t    {\n\t\tvim_snprintf((char *)IObuff, IOSIZE, mesg, _(\"Exception\"));\n\t\tmesg = (char *)vim_strnsave(IObuff, STRLEN(IObuff) + 4);\n\t\tSTRCAT(mesg, \": %s\");\n\t\ts = (char *)((except_T *)value)->value;\n\t    }\n\t    else if ((pending & CSTP_ERROR) && (pending & CSTP_INTERRUPT))\n\t\ts = _(\"Error and interrupt\");\n\t    else if (pending & CSTP_ERROR)\n\t\ts = _(\"Error\");\n\t    else // if (pending & CSTP_INTERRUPT)\n\t\ts = _(\"Interrupt\");\n    }\n\n    save_msg_silent = msg_silent;\n    if (debug_break_level > 0)\n\tmsg_silent = FALSE;\t// display messages\n    ++no_wait_return;\n    msg_scroll = TRUE;\t\t// always scroll up, don't overwrite\n    smsg(mesg, s);\n    msg_puts(\"\\n\");   // don't overwrite this either\n    cmdline_row = msg_row;\n    --no_wait_return;\n    if (debug_break_level > 0)\n\tmsg_silent = save_msg_silent;\n\n    if (pending == CSTP_RETURN)\n\tvim_free(s);\n    else if (pending & CSTP_THROW)\n\tvim_free(mesg);\n}\n\n/*\n * If something is made pending in a finally clause, report it if required by\n * the 'verbose' option or when debugging.\n */\n    void\nreport_make_pending(int pending, void *value)\n{\n    if (p_verbose >= 14 || debug_break_level > 0)\n    {\n\tif (debug_break_level <= 0)\n\t    verbose_enter();\n\treport_pending(RP_MAKE, pending, value);\n\tif (debug_break_level <= 0)\n\t    verbose_leave();\n    }\n}\n\n/*\n * If something pending in a finally clause is resumed at the \":endtry\", report\n * it if required by the 'verbose' option or when debugging.\n */\n    static void\nreport_resume_pending(int pending, void *value)\n{\n    if (p_verbose >= 14 || debug_break_level > 0)\n    {\n\tif (debug_break_level <= 0)\n\t    verbose_enter();\n\treport_pending(RP_RESUME, pending, value);\n\tif (debug_break_level <= 0)\n\t    verbose_leave();\n    }\n}\n\n/*\n * If something pending in a finally clause is discarded, report it if required\n * by the 'verbose' option or when debugging.\n */\n    static void\nreport_discard_pending(int pending, void *value)\n{\n    if (p_verbose >= 14 || debug_break_level > 0)\n    {\n\tif (debug_break_level <= 0)\n\t    verbose_enter();\n\treport_pending(RP_DISCARD, pending, value);\n\tif (debug_break_level <= 0)\n\t    verbose_leave();\n    }\n}\n\n/*\n * Return TRUE if \"arg\" is only a variable, register, environment variable,\n * option name or string.\n */\n    int\ncmd_is_name_only(char_u *arg)\n{\n    char_u  *p = arg;\n    char_u  *alias = NULL;\n    int\t    name_only = FALSE;\n\n    if (*p == '@')\n    {\n\t++p;\n\tif (*p != NUL)\n\t    ++p;\n    }\n    else if (*p == '\\'' || *p == '\"')\n    {\n\tint\t    r;\n\n\tif (*p == '\"')\n\t    r = eval_string(&p, NULL, FALSE, FALSE);\n\telse\n\t    r = eval_lit_string(&p, NULL, FALSE, FALSE);\n\tif (r == FAIL)\n\t    return FALSE;\n    }\n    else\n    {\n\tif (*p == '&')\n\t{\n\t    ++p;\n\t    if (STRNCMP(\"l:\", p, 2) == 0 || STRNCMP(\"g:\", p, 2) == 0)\n\t\tp += 2;\n\t}\n\telse if (*p == '$')\n\t    ++p;\n\t(void)get_name_len(&p, &alias, FALSE, FALSE);\n    }\n    name_only = ends_excmd2(arg, skipwhite(p));\n    vim_free(alias);\n    return name_only;\n}\n\n/*\n * \":eval\".\n */\n    void\nex_eval(exarg_T *eap)\n{\n    typval_T\ttv;\n    evalarg_T\tevalarg;\n    int\t\tname_only = FALSE;\n    long\tlnum = SOURCING_LNUM;\n\n    if (in_vim9script())\n\tname_only = cmd_is_name_only(eap->arg);\n\n    fill_evalarg_from_eap(&evalarg, eap, eap->skip);\n\n    if (eval0(eap->arg, &tv, eap, &evalarg) == OK)\n    {\n\tclear_tv(&tv);\n\tif (in_vim9script() && name_only\n\t\t&& (evalarg.eval_tofree == NULL\n\t\t    || ends_excmd2(evalarg.eval_tofree,\n\t\t\t\t\t      skipwhite(evalarg.eval_tofree))))\n\t{\n\t    SOURCING_LNUM = lnum;\n\t    semsg(_(e_expression_without_effect_str), eap->arg);\n\t}\n    }\n\n    clear_evalarg(&evalarg, eap);\n}\n\n/*\n * Start a new scope/block.  Caller should have checked that cs_idx is not\n * exceeding CSTACK_LEN.\n */\n    static void\nenter_block(cstack_T *cstack)\n{\n    ++cstack->cs_idx;\n    if (in_vim9script() && current_sctx.sc_sid > 0)\n    {\n\tscriptitem_T *si = SCRIPT_ITEM(current_sctx.sc_sid);\n\n\tcstack->cs_script_var_len[cstack->cs_idx] = si->sn_var_vals.ga_len;\n\tcstack->cs_block_id[cstack->cs_idx] = ++si->sn_last_block_id;\n\tsi->sn_current_block_id = si->sn_last_block_id;\n    }\n    else\n    {\n\t// Just in case in_vim9script() does not return the same value when the\n\t// block ends.\n\tcstack->cs_script_var_len[cstack->cs_idx] = 0;\n\tcstack->cs_block_id[cstack->cs_idx] = 0;\n    }\n}\n\n    static void\nleave_block(cstack_T *cstack)\n{\n    if (in_vim9script() && SCRIPT_ID_VALID(current_sctx.sc_sid))\n    {\n\tscriptitem_T\t*si = SCRIPT_ITEM(current_sctx.sc_sid);\n\tint\t\ti;\n\tint\t\tfunc_defined =\n\t\t\t       cstack->cs_flags[cstack->cs_idx] & CSF_FUNC_DEF;\n\n\tfor (i = cstack->cs_script_var_len[cstack->cs_idx];\n\t\t\t\t\t       i < si->sn_var_vals.ga_len; ++i)\n\t{\n\t    svar_T\t*sv = ((svar_T *)si->sn_var_vals.ga_data) + i;\n\n\t    // sv_name is set to NULL if it was already removed.  This happens\n\t    // when it was defined in an inner block and no functions were\n\t    // defined there.\n\t    if (sv->sv_name != NULL)\n\t\t// Remove a variable declared inside the block, if it still\n\t\t// exists, from sn_vars and move the value into sn_all_vars\n\t\t// if \"func_defined\" is non-zero.\n\t\thide_script_var(si, i, func_defined);\n\t}\n\n\tif (cstack->cs_idx == 0)\n\t    si->sn_current_block_id = 0;\n\telse\n\t    si->sn_current_block_id = cstack->cs_block_id[cstack->cs_idx - 1];\n    }\n    --cstack->cs_idx;\n}\n\n/*\n * \":if\".\n */\n    void\nex_if(exarg_T *eap)\n{\n    int\t\terror;\n    int\t\tskip;\n    int\t\tresult;\n    cstack_T\t*cstack = eap->cstack;\n\n    if (cstack->cs_idx == CSTACK_LEN - 1)\n\teap->errmsg = _(e_if_nesting_too_deep);\n    else\n    {\n\tenter_block(cstack);\n\tcstack->cs_flags[cstack->cs_idx] = 0;\n\n\t/*\n\t * Don't do something after an error, interrupt, or throw, or when\n\t * there is a surrounding conditional and it was not active.\n\t */\n\tskip = did_emsg || got_int || did_throw || (cstack->cs_idx > 0\n\t\t&& !(cstack->cs_flags[cstack->cs_idx - 1] & CSF_ACTIVE));\n\n\tresult = eval_to_bool(eap->arg, &error, eap, skip);\n\n\tif (!skip && !error)\n\t{\n\t    if (result)\n\t\tcstack->cs_flags[cstack->cs_idx] = CSF_ACTIVE | CSF_TRUE;\n\t}\n\telse\n\t    // set TRUE, so this conditional will never get active\n\t    cstack->cs_flags[cstack->cs_idx] = CSF_TRUE;\n    }\n}\n\n/*\n * \":endif\".\n */\n    void\nex_endif(exarg_T *eap)\n{\n    cstack_T\t*cstack = eap->cstack;\n\n    if (cmdmod_error(FALSE))\n\treturn;\n    did_endif = TRUE;\n    if (cstack->cs_idx < 0\n\t    || (cstack->cs_flags[cstack->cs_idx]\n\t\t\t\t& (CSF_WHILE | CSF_FOR | CSF_TRY | CSF_BLOCK)))\n\teap->errmsg = _(e_endif_without_if);\n    else\n    {\n\t/*\n\t * When debugging or a breakpoint was encountered, display the debug\n\t * prompt (if not already done).  This shows the user that an \":endif\"\n\t * is executed when the \":if\" or a previous \":elseif\" was not TRUE.\n\t * Handle a \">quit\" debug command as if an interrupt had occurred before\n\t * the \":endif\".  That is, throw an interrupt exception if appropriate.\n\t * Doing this here prevents an exception for a parsing error being\n\t * discarded by throwing the interrupt exception later on.\n\t */\n\tif (!(cstack->cs_flags[cstack->cs_idx] & CSF_TRUE)\n\t\t\t\t\t\t    && dbg_check_skipped(eap))\n\t    (void)do_intthrow(cstack);\n\n\tleave_block(cstack);\n    }\n}\n\n/*\n * \":else\" and \":elseif\".\n */\n    void\nex_else(exarg_T *eap)\n{\n    int\t\terror;\n    int\t\tskip;\n    int\t\tresult;\n    cstack_T\t*cstack = eap->cstack;\n\n    /*\n     * Don't do something after an error, interrupt, or throw, or when there is\n     * a surrounding conditional and it was not active.\n     */\n    skip = did_emsg || got_int || did_throw || (cstack->cs_idx > 0\n\t    && !(cstack->cs_flags[cstack->cs_idx - 1] & CSF_ACTIVE));\n\n    if (cstack->cs_idx < 0\n\t    || (cstack->cs_flags[cstack->cs_idx]\n\t\t\t\t& (CSF_WHILE | CSF_FOR | CSF_TRY | CSF_BLOCK)))\n    {\n\tif (eap->cmdidx == CMD_else)\n\t{\n\t    eap->errmsg = _(e_else_without_if);\n\t    return;\n\t}\n\teap->errmsg = _(e_elseif_without_if);\n\tskip = TRUE;\n    }\n    else if (cstack->cs_flags[cstack->cs_idx] & CSF_ELSE)\n    {\n\tif (eap->cmdidx == CMD_else)\n\t{\n\t    eap->errmsg = _(e_multiple_else);\n\t    return;\n\t}\n\teap->errmsg = _(e_elseif_after_else);\n\tskip = TRUE;\n    }\n\n    if (cstack->cs_idx >= 0)\n    {\n\t// Variables declared in the previous block can no longer be\n\t// used.  Needs to be done before setting \"cs_flags\".\n\tleave_block(cstack);\n\tenter_block(cstack);\n    }\n\n    // if skipping or the \":if\" was TRUE, reset ACTIVE, otherwise set it\n    if (skip || cstack->cs_flags[cstack->cs_idx] & CSF_TRUE)\n    {\n\tif (eap->errmsg == NULL)\n\t    cstack->cs_flags[cstack->cs_idx] = CSF_TRUE;\n\tskip = TRUE;\t// don't evaluate an \":elseif\"\n    }\n    else\n\tcstack->cs_flags[cstack->cs_idx] = CSF_ACTIVE;\n\n    /*\n     * When debugging or a breakpoint was encountered, display the debug prompt\n     * (if not already done).  This shows the user that an \":else\" or \":elseif\"\n     * is executed when the \":if\" or previous \":elseif\" was not TRUE.  Handle\n     * a \">quit\" debug command as if an interrupt had occurred before the\n     * \":else\" or \":elseif\".  That is, set \"skip\" and throw an interrupt\n     * exception if appropriate.  Doing this here prevents that an exception\n     * for a parsing errors is discarded when throwing the interrupt exception\n     * later on.\n     */\n    if (!skip && dbg_check_skipped(eap) && got_int)\n    {\n\t(void)do_intthrow(cstack);\n\tskip = TRUE;\n    }\n\n    if (eap->cmdidx == CMD_elseif)\n    {\n\t// When skipping we ignore most errors, but a missing expression is\n\t// wrong, perhaps it should have been \"else\".\n\tif (skip && ends_excmd(*eap->arg))\n\t    semsg(_(e_invalid_expression_str), eap->arg);\n\telse\n\t    result = eval_to_bool(eap->arg, &error, eap, skip);\n\n\t// When throwing error exceptions, we want to throw always the first\n\t// of several errors in a row.  This is what actually happens when\n\t// a conditional error was detected above and there is another failure\n\t// when parsing the expression.  Since the skip flag is set in this\n\t// case, the parsing error will be ignored by emsg().\n\tif (!skip && !error)\n\t{\n\t    if (result)\n\t\tcstack->cs_flags[cstack->cs_idx] = CSF_ACTIVE | CSF_TRUE;\n\t    else\n\t\tcstack->cs_flags[cstack->cs_idx] = 0;\n\t}\n\telse if (eap->errmsg == NULL)\n\t    // set TRUE, so this conditional will never get active\n\t    cstack->cs_flags[cstack->cs_idx] = CSF_TRUE;\n    }\n    else\n\tcstack->cs_flags[cstack->cs_idx] |= CSF_ELSE;\n}\n\n/*\n * Handle \":while\" and \":for\".\n */\n    void\nex_while(exarg_T *eap)\n{\n    int\t\terror;\n    int\t\tskip;\n    int\t\tresult;\n    cstack_T\t*cstack = eap->cstack;\n    int\t\tprev_cs_flags = 0;\n\n    if (cstack->cs_idx == CSTACK_LEN - 1)\n\teap->errmsg = _(e_while_for_nesting_too_deep);\n    else\n    {\n\t/*\n\t * The loop flag is set when we have jumped back from the matching\n\t * \":endwhile\" or \":endfor\".  When not set, need to initialise this\n\t * cstack entry.\n\t */\n\tif ((cstack->cs_lflags & CSL_HAD_LOOP) == 0)\n\t{\n\t    enter_block(cstack);\n\t    ++cstack->cs_looplevel;\n\t    cstack->cs_line[cstack->cs_idx] = -1;\n\t}\n\telse\n\t{\n\t    if (in_vim9script() && SCRIPT_ID_VALID(current_sctx.sc_sid))\n\t    {\n\t\tscriptitem_T\t*si = SCRIPT_ITEM(current_sctx.sc_sid);\n\t\tint\t\ti;\n\t\tint\t\tfirst;\n\t\tint\t\tfunc_defined = cstack->cs_flags[cstack->cs_idx]\n\t\t\t\t\t\t\t\t& CSF_FUNC_DEF;\n\n\t\t// Any variables defined in the previous round are no longer\n\t\t// visible.  Keep the first one for \":for\", it is the loop\n\t\t// variable that we reuse every time around.\n\t\t// Do this backwards, so that vars defined in a later round are\n\t\t// found first.\n\t\tfirst = cstack->cs_script_var_len[cstack->cs_idx];\n\t\tif (eap->cmdidx == CMD_for)\n\t\t{\n\t\t    forinfo_T\t*fi = cstack->cs_forinfo[cstack->cs_idx];\n\n\t\t    first += fi == NULL || fi->fi_varcount == 0\n\t\t\t\t\t\t\t ? 1 : fi->fi_varcount;\n\t\t}\n\t\tfor (i = si->sn_var_vals.ga_len - 1; i >= first; --i)\n\t\t{\n\t\t    svar_T\t*sv = ((svar_T *)si->sn_var_vals.ga_data) + i;\n\n\t\t    // sv_name is set to NULL if it was already removed.  This\n\t\t    // happens when it was defined in an inner block and no\n\t\t    // functions were defined there.\n\t\t    if (sv->sv_name != NULL)\n\t\t\t// Remove a variable declared inside the block, if it\n\t\t\t// still exists, from sn_vars.\n\t\t\thide_script_var(si, i, func_defined);\n\t\t}\n\n\t\t// Start a new block ID, so that variables defined inside the\n\t\t// loop are created new and not shared with the previous loop.\n\t\t// Matters when used in a closure.\n\t\tcstack->cs_block_id[cstack->cs_idx] = ++si->sn_last_block_id;\n\t\tsi->sn_current_block_id = si->sn_last_block_id;\n\t    }\n\t}\n\tprev_cs_flags = cstack->cs_flags[cstack->cs_idx];\n\tcstack->cs_flags[cstack->cs_idx] =\n\t\t\t       eap->cmdidx == CMD_while ? CSF_WHILE : CSF_FOR;\n\n\t/*\n\t * Don't do something after an error, interrupt, or throw, or when\n\t * there is a surrounding conditional and it was not active.\n\t */\n\tskip = did_emsg || got_int || did_throw || (cstack->cs_idx > 0\n\t\t&& !(cstack->cs_flags[cstack->cs_idx - 1] & CSF_ACTIVE));\n\tif (eap->cmdidx == CMD_while)\n\t{\n\t    /*\n\t     * \":while bool-expr\"\n\t     */\n\t    result = eval_to_bool(eap->arg, &error, eap, skip);\n\t}\n\telse\n\t{\n\t    forinfo_T\t*fi;\n\t    evalarg_T\tevalarg;\n\n\t    /*\n\t     * \":for var in list-expr\"\n\t     */\n\t    fill_evalarg_from_eap(&evalarg, eap, skip);\n\t    if ((cstack->cs_lflags & CSL_HAD_LOOP) != 0)\n\t    {\n\t\t// Jumping here from a \":continue\" or \":endfor\": use the\n\t\t// previously evaluated list.\n\t\tfi = cstack->cs_forinfo[cstack->cs_idx];\n\t\terror = FALSE;\n\n\t\t// the \"in expr\" is not used, skip over it\n\t\tskip_for_lines(fi, &evalarg);\n\t    }\n\t    else\n\t    {\n\t\tlong save_lnum = SOURCING_LNUM;\n\n\t\t// Evaluate the argument and get the info in a structure.\n\t\tfi = eval_for_line(eap->arg, &error, eap, &evalarg);\n\t\tcstack->cs_forinfo[cstack->cs_idx] = fi;\n\n\t\t// Errors should use the first line number.\n\t\tSOURCING_LNUM = save_lnum;\n\t    }\n\n\t    // use the element at the start of the list and advance\n\t    if (!error && fi != NULL && !skip)\n\t\tresult = next_for_item(fi, eap->arg);\n\t    else\n\t\tresult = FALSE;\n\t    if (fi != NULL)\n\t\t// OR all the cs_flags together, if a function was defined in\n\t\t// any round then the loop variable may have been used.\n\t\tfi->fi_cs_flags |= prev_cs_flags;\n\n\t    if (!result)\n\t    {\n\t\t// If a function was defined in any round then set the\n\t\t// CSF_FUNC_DEF flag now, so that it's seen by leave_block().\n\t\tif (fi != NULL && (fi->fi_cs_flags & CSF_FUNC_DEF))\n\t\t    cstack->cs_flags[cstack->cs_idx] |= CSF_FUNC_DEF;\n\n\t\tfree_for_info(fi);\n\t\tcstack->cs_forinfo[cstack->cs_idx] = NULL;\n\t    }\n\t    clear_evalarg(&evalarg, eap);\n\t}\n\n\t/*\n\t * If this cstack entry was just initialised and is active, set the\n\t * loop flag, so do_cmdline() will set the line number in cs_line[].\n\t * If executing the command a second time, clear the loop flag.\n\t */\n\tif (!skip && !error && result)\n\t{\n\t    cstack->cs_flags[cstack->cs_idx] |= (CSF_ACTIVE | CSF_TRUE);\n\t    cstack->cs_lflags ^= CSL_HAD_LOOP;\n\t}\n\telse\n\t{\n\t    cstack->cs_lflags &= ~CSL_HAD_LOOP;\n\t    // If the \":while\" evaluates to FALSE or \":for\" is past the end of\n\t    // the list, show the debug prompt at the \":endwhile\"/\":endfor\" as\n\t    // if there was a \":break\" in a \":while\"/\":for\" evaluating to\n\t    // TRUE.\n\t    if (!skip && !error)\n\t\tcstack->cs_flags[cstack->cs_idx] |= CSF_TRUE;\n\t}\n    }\n}\n\n/*\n * \":continue\"\n */\n    void\nex_continue(exarg_T *eap)\n{\n    int\t\tidx;\n    cstack_T\t*cstack = eap->cstack;\n\n    if (cstack->cs_looplevel <= 0 || cstack->cs_idx < 0)\n\teap->errmsg = _(e_continue_without_while_or_for);\n    else\n    {\n\t// Try to find the matching \":while\".  This might stop at a try\n\t// conditional not in its finally clause (which is then to be executed\n\t// next).  Therefore, inactivate all conditionals except the \":while\"\n\t// itself (if reached).\n\tidx = cleanup_conditionals(cstack, CSF_WHILE | CSF_FOR, FALSE);\n\tif (idx >= 0 && (cstack->cs_flags[idx] & (CSF_WHILE | CSF_FOR)))\n\t{\n\t    rewind_conditionals(cstack, idx, CSF_TRY, &cstack->cs_trylevel);\n\n\t    /*\n\t     * Set CSL_HAD_CONT, so do_cmdline() will jump back to the\n\t     * matching \":while\".\n\t     */\n\t    cstack->cs_lflags |= CSL_HAD_CONT;\t// let do_cmdline() handle it\n\t}\n\telse\n\t{\n\t    // If a try conditional not in its finally clause is reached first,\n\t    // make the \":continue\" pending for execution at the \":endtry\".\n\t    cstack->cs_pending[idx] = CSTP_CONTINUE;\n\t    report_make_pending(CSTP_CONTINUE, NULL);\n\t}\n    }\n}\n\n/*\n * \":break\"\n */\n    void\nex_break(exarg_T *eap)\n{\n    int\t\tidx;\n    cstack_T\t*cstack = eap->cstack;\n\n    if (cstack->cs_looplevel <= 0 || cstack->cs_idx < 0)\n\teap->errmsg = _(e_break_without_while_or_for);\n    else\n    {\n\t// Inactivate conditionals until the matching \":while\" or a try\n\t// conditional not in its finally clause (which is then to be\n\t// executed next) is found.  In the latter case, make the \":break\"\n\t// pending for execution at the \":endtry\".\n\tidx = cleanup_conditionals(cstack, CSF_WHILE | CSF_FOR, TRUE);\n\tif (idx >= 0 && !(cstack->cs_flags[idx] & (CSF_WHILE | CSF_FOR)))\n\t{\n\t    cstack->cs_pending[idx] = CSTP_BREAK;\n\t    report_make_pending(CSTP_BREAK, NULL);\n\t}\n    }\n}\n\n/*\n * \":endwhile\" and \":endfor\"\n */\n    void\nex_endwhile(exarg_T *eap)\n{\n    cstack_T\t*cstack = eap->cstack;\n    int\t\tidx;\n    char\t*err;\n    int\t\tcsf;\n    int\t\tfl;\n\n    if (cmdmod_error(TRUE))\n\treturn;\n\n    if (eap->cmdidx == CMD_endwhile)\n    {\n\terr = e_endwhile_without_while;\n\tcsf = CSF_WHILE;\n    }\n    else\n    {\n\terr = e_endfor_without_for;\n\tcsf = CSF_FOR;\n    }\n\n    if (cstack->cs_looplevel <= 0 || cstack->cs_idx < 0)\n\teap->errmsg = _(err);\n    else\n    {\n\tfl = cstack->cs_flags[cstack->cs_idx];\n\tif (!(fl & csf))\n\t{\n\t    // If we are in a \":while\" or \":for\" but used the wrong endloop\n\t    // command, do not rewind to the next enclosing \":for\"/\":while\".\n\t    if (fl & CSF_WHILE)\n\t\teap->errmsg = _(e_using_endfor_with_while);\n\t    else if (fl & CSF_FOR)\n\t\teap->errmsg = _(e_using_endwhile_with_for);\n\t}\n\tif (!(fl & (CSF_WHILE | CSF_FOR)))\n\t{\n\t    if (!(fl & CSF_TRY))\n\t\teap->errmsg = _(e_missing_endif);\n\t    else if (fl & CSF_FINALLY)\n\t\teap->errmsg = _(e_missing_endtry);\n\t    // Try to find the matching \":while\" and report what's missing.\n\t    for (idx = cstack->cs_idx; idx > 0; --idx)\n\t    {\n\t\tfl =  cstack->cs_flags[idx];\n\t\tif ((fl & CSF_TRY) && !(fl & CSF_FINALLY))\n\t\t{\n\t\t    // Give up at a try conditional not in its finally clause.\n\t\t    // Ignore the \":endwhile\"/\":endfor\".\n\t\t    eap->errmsg = _(err);\n\t\t    return;\n\t\t}\n\t\tif (fl & csf)\n\t\t    break;\n\t    }\n\t    // Cleanup and rewind all contained (and unclosed) conditionals.\n\t    (void)cleanup_conditionals(cstack, CSF_WHILE | CSF_FOR, FALSE);\n\t    rewind_conditionals(cstack, idx, CSF_TRY, &cstack->cs_trylevel);\n\t}\n\n\t/*\n\t * When debugging or a breakpoint was encountered, display the debug\n\t * prompt (if not already done).  This shows the user that an\n\t * \":endwhile\"/\":endfor\" is executed when the \":while\" was not TRUE or\n\t * after a \":break\".  Handle a \">quit\" debug command as if an\n\t * interrupt had occurred before the \":endwhile\"/\":endfor\".  That is,\n\t * throw an interrupt exception if appropriate.  Doing this here\n\t * prevents that an exception for a parsing error is discarded when\n\t * throwing the interrupt exception later on.\n\t */\n\telse if (cstack->cs_flags[cstack->cs_idx] & CSF_TRUE\n\t\t&& !(cstack->cs_flags[cstack->cs_idx] & CSF_ACTIVE)\n\t\t&& dbg_check_skipped(eap))\n\t    (void)do_intthrow(cstack);\n\n\t// Set loop flag, so do_cmdline() will jump back to the matching\n\t// \":while\" or \":for\".\n\tcstack->cs_lflags |= CSL_HAD_ENDLOOP;\n    }\n}\n\n/*\n * \"{\" start of a block in Vim9 script\n */\n    void\nex_block(exarg_T *eap)\n{\n    cstack_T\t*cstack = eap->cstack;\n\n    if (cstack->cs_idx == CSTACK_LEN - 1)\n\teap->errmsg = _(e_block_nesting_too_deep);\n    else\n    {\n\tenter_block(cstack);\n\tcstack->cs_flags[cstack->cs_idx] = CSF_BLOCK | CSF_ACTIVE | CSF_TRUE;\n    }\n}\n\n/*\n * \"}\" end of a block in Vim9 script\n */\n    void\nex_endblock(exarg_T *eap)\n{\n    cstack_T\t*cstack = eap->cstack;\n\n    if (cstack->cs_idx < 0\n\t    || (cstack->cs_flags[cstack->cs_idx] & CSF_BLOCK) == 0)\n\teap->errmsg = _(e_endblock_without_block);\n    else\n\tleave_block(cstack);\n}\n\n    int\ninside_block(exarg_T *eap)\n{\n    cstack_T\t*cstack = eap->cstack;\n    int\t\ti;\n\n    for (i = 0; i <= cstack->cs_idx; ++i)\n\tif (cstack->cs_flags[cstack->cs_idx] & CSF_BLOCK)\n\t    return TRUE;\n    return FALSE;\n}\n\n/*\n * \":throw expr\"\n */\n    void\nex_throw(exarg_T *eap)\n{\n    char_u\t*arg = eap->arg;\n    char_u\t*value;\n\n    if (*arg != NUL && *arg != '|' && *arg != '\\n')\n\tvalue = eval_to_string_skip(arg, eap, eap->skip);\n    else\n    {\n\temsg(_(e_argument_required));\n\tvalue = NULL;\n    }\n\n    // On error or when an exception is thrown during argument evaluation, do\n    // not throw.\n    if (!eap->skip && value != NULL)\n    {\n\tif (throw_exception(value, ET_USER, NULL) == FAIL)\n\t    vim_free(value);\n\telse\n\t    do_throw(eap->cstack);\n    }\n}\n\n/*\n * Throw the current exception through the specified cstack.  Common routine\n * for \":throw\" (user exception) and error and interrupt exceptions.  Also\n * used for rethrowing an uncaught exception.\n */\n    void\ndo_throw(cstack_T *cstack)\n{\n    int\t\tidx;\n    int\t\tinactivate_try = FALSE;\n\n    /*\n     * Cleanup and inactivate up to the next surrounding try conditional that\n     * is not in its finally clause.  Normally, do not inactivate the try\n     * conditional itself, so that its ACTIVE flag can be tested below.  But\n     * if a previous error or interrupt has not been converted to an exception,\n     * inactivate the try conditional, too, as if the conversion had been done,\n     * and reset the did_emsg or got_int flag, so this won't happen again at\n     * the next surrounding try conditional.\n     */\n#ifndef THROW_ON_ERROR_TRUE\n    if (did_emsg && !THROW_ON_ERROR)\n    {\n\tinactivate_try = TRUE;\n\tdid_emsg = FALSE;\n    }\n#endif\n#ifndef THROW_ON_INTERRUPT_TRUE\n    if (got_int && !THROW_ON_INTERRUPT)\n    {\n\tinactivate_try = TRUE;\n\tgot_int = FALSE;\n    }\n#endif\n    idx = cleanup_conditionals(cstack, 0, inactivate_try);\n    if (idx >= 0)\n    {\n\t/*\n\t * If this try conditional is active and we are before its first\n\t * \":catch\", set THROWN so that the \":catch\" commands will check\n\t * whether the exception matches.  When the exception came from any of\n\t * the catch clauses, it will be made pending at the \":finally\" (if\n\t * present) and rethrown at the \":endtry\".  This will also happen if\n\t * the try conditional is inactive.  This is the case when we are\n\t * throwing an exception due to an error or interrupt on the way from\n\t * a preceding \":continue\", \":break\", \":return\", \":finish\", error or\n\t * interrupt (not converted to an exception) to the finally clause or\n\t * from a preceding throw of a user or error or interrupt exception to\n\t * the matching catch clause or the finally clause.\n\t */\n\tif (!(cstack->cs_flags[idx] & CSF_CAUGHT))\n\t{\n\t    if (cstack->cs_flags[idx] & CSF_ACTIVE)\n\t\tcstack->cs_flags[idx] |= CSF_THROWN;\n\t    else\n\t\t// THROWN may have already been set for a catchable exception\n\t\t// that has been discarded.  Ensure it is reset for the new\n\t\t// exception.\n\t\tcstack->cs_flags[idx] &= ~CSF_THROWN;\n\t}\n\tcstack->cs_flags[idx] &= ~CSF_ACTIVE;\n\tcstack->cs_exception[idx] = current_exception;\n    }\n#if 0\n    // TODO: Add optimization below.  Not yet done because of interface\n    // problems to eval.c and ex_cmds2.c. (Servatius)\n    else\n    {\n\t/*\n\t * There are no catch clauses to check or finally clauses to execute.\n\t * End the current script or function.  The exception will be rethrown\n\t * in the caller.\n\t */\n\tif (getline_equal(eap->getline, eap->cookie, get_func_line))\n\t    current_funccal->returned = TRUE;\n\telseif (eap->get_func_line == getsourceline)\n\t    ((struct source_cookie *)eap->cookie)->finished = TRUE;\n    }\n#endif\n\n    did_throw = TRUE;\n}\n\n/*\n * \":try\"\n */\n    void\nex_try(exarg_T *eap)\n{\n    int\t\tskip;\n    cstack_T\t*cstack = eap->cstack;\n\n    if (cmdmod_error(FALSE))\n\treturn;\n\n    if (cstack->cs_idx == CSTACK_LEN - 1)\n\teap->errmsg = _(e_try_nesting_too_deep);\n    else\n    {\n\tenter_block(cstack);\n\t++cstack->cs_trylevel;\n\tcstack->cs_flags[cstack->cs_idx] = CSF_TRY;\n\tcstack->cs_pending[cstack->cs_idx] = CSTP_NONE;\n\n\t/*\n\t * Don't do something after an error, interrupt, or throw, or when there\n\t * is a surrounding conditional and it was not active.\n\t */\n\tskip = did_emsg || got_int || did_throw || (cstack->cs_idx > 0\n\t\t&& !(cstack->cs_flags[cstack->cs_idx - 1] & CSF_ACTIVE));\n\n\tif (!skip)\n\t{\n\t    // Set ACTIVE and TRUE.  TRUE means that the corresponding \":catch\"\n\t    // commands should check for a match if an exception is thrown and\n\t    // that the finally clause needs to be executed.\n\t    cstack->cs_flags[cstack->cs_idx] |= CSF_ACTIVE | CSF_TRUE;\n\n\t    /*\n\t     * \":silent!\", even when used in a try conditional, disables\n\t     * displaying of error messages and conversion of errors to\n\t     * exceptions.  When the silent commands again open a try\n\t     * conditional, save \"emsg_silent\" and reset it so that errors are\n\t     * again converted to exceptions.  The value is restored when that\n\t     * try conditional is left.  If it is left normally, the commands\n\t     * following the \":endtry\" are again silent.  If it is left by\n\t     * a \":continue\", \":break\", \":return\", or \":finish\", the commands\n\t     * executed next are again silent.  If it is left due to an\n\t     * aborting error, an interrupt, or an exception, restoring\n\t     * \"emsg_silent\" does not matter since we are already in the\n\t     * aborting state and/or the exception has already been thrown.\n\t     * The effect is then just freeing the memory that was allocated\n\t     * to save the value.\n\t     */\n\t    if (emsg_silent)\n\t    {\n\t\teslist_T\t*elem;\n\n\t\telem = ALLOC_ONE(struct eslist_elem);\n\t\tif (elem == NULL)\n\t\t    emsg(_(e_out_of_memory));\n\t\telse\n\t\t{\n\t\t    elem->saved_emsg_silent = emsg_silent;\n\t\t    elem->next = cstack->cs_emsg_silent_list;\n\t\t    cstack->cs_emsg_silent_list = elem;\n\t\t    cstack->cs_flags[cstack->cs_idx] |= CSF_SILENT;\n\t\t    emsg_silent = 0;\n\t\t}\n\t    }\n\t}\n\n    }\n}\n\n/*\n * \":catch /{pattern}/\" and \":catch\"\n */\n    void\nex_catch(exarg_T *eap)\n{\n    int\t\tidx = 0;\n    int\t\tgive_up = FALSE;\n    int\t\tskip = FALSE;\n    int\t\tcaught = FALSE;\n    char_u\t*end;\n    int\t\tsave_char = 0;\n    char_u\t*save_cpo;\n    regmatch_T\tregmatch;\n    int\t\tprev_got_int;\n    cstack_T\t*cstack = eap->cstack;\n    char_u\t*pat;\n\n    if (cmdmod_error(FALSE))\n\treturn;\n\n    if (cstack->cs_trylevel <= 0 || cstack->cs_idx < 0)\n    {\n\teap->errmsg = _(e_catch_without_try);\n\tgive_up = TRUE;\n    }\n    else\n    {\n\tif (!(cstack->cs_flags[cstack->cs_idx] & CSF_TRY))\n\t{\n\t    // Report what's missing if the matching \":try\" is not in its\n\t    // finally clause.\n\t    eap->errmsg = get_end_emsg(cstack);\n\t    skip = TRUE;\n\t}\n\tfor (idx = cstack->cs_idx; idx > 0; --idx)\n\t    if (cstack->cs_flags[idx] & CSF_TRY)\n\t\tbreak;\n\tif (cstack->cs_flags[idx] & CSF_TRY)\n\t    cstack->cs_flags[idx] |= CSF_CATCH;\n\tif (cstack->cs_flags[idx] & CSF_FINALLY)\n\t{\n\t    // Give up for a \":catch\" after \":finally\" and ignore it.\n\t    // Just parse.\n\t    eap->errmsg = _(e_catch_after_finally);\n\t    give_up = TRUE;\n\t}\n\telse\n\t    rewind_conditionals(cstack, idx, CSF_WHILE | CSF_FOR,\n\t\t\t\t\t\t       &cstack->cs_looplevel);\n    }\n\n    if (ends_excmd2(eap->cmd, eap->arg))   // no argument, catch all errors\n    {\n\tpat = (char_u *)\".*\";\n\tend = NULL;\n\teap->nextcmd = find_nextcmd(eap->arg);\n    }\n    else\n    {\n\tpat = eap->arg + 1;\n\tend = skip_regexp_err(pat, *eap->arg, TRUE);\n\tif (end == NULL)\n\t    give_up = TRUE;\n    }\n\n    if (!give_up)\n    {\n\t/*\n\t * Don't do something when no exception has been thrown or when the\n\t * corresponding try block never got active (because of an inactive\n\t * surrounding conditional or after an error or interrupt or throw).\n\t */\n\tif (!did_throw || !(cstack->cs_flags[idx] & CSF_TRUE))\n\t    skip = TRUE;\n\n\t/*\n\t * Check for a match only if an exception is thrown but not caught by\n\t * a previous \":catch\".  An exception that has replaced a discarded\n\t * exception is not checked (THROWN is not set then).\n\t */\n\tif (!skip && (cstack->cs_flags[idx] & CSF_THROWN)\n\t\t&& !(cstack->cs_flags[idx] & CSF_CAUGHT))\n\t{\n\t    if (end != NULL && *end != NUL\n\t\t\t\t      && !ends_excmd2(end, skipwhite(end + 1)))\n\t    {\n\t\tsemsg(_(e_trailing_characters_str), end);\n\t\treturn;\n\t    }\n\n\t    // When debugging or a breakpoint was encountered, display the\n\t    // debug prompt (if not already done) before checking for a match.\n\t    // This is a helpful hint for the user when the regular expression\n\t    // matching fails.  Handle a \">quit\" debug command as if an\n\t    // interrupt had occurred before the \":catch\".  That is, discard\n\t    // the original exception, replace it by an interrupt exception,\n\t    // and don't catch it in this try block.\n\t    if (!dbg_check_skipped(eap) || !do_intthrow(cstack))\n\t    {\n\t\t// Terminate the pattern and avoid the 'l' flag in 'cpoptions'\n\t\t// while compiling it.\n\t\tif (end != NULL)\n\t\t{\n\t\t    save_char = *end;\n\t\t    *end = NUL;\n\t\t}\n\t\tsave_cpo  = p_cpo;\n\t\tp_cpo = empty_option;\n\t\t// Disable error messages, it will make current_exception\n\t\t// invalid.\n\t\t++emsg_off;\n\t\tregmatch.regprog = vim_regcomp(pat, RE_MAGIC + RE_STRING);\n\t\t--emsg_off;\n\t\tregmatch.rm_ic = FALSE;\n\t\tif (end != NULL)\n\t\t    *end = save_char;\n\t\tp_cpo = save_cpo;\n\t\tif (regmatch.regprog == NULL)\n\t\t    semsg(_(e_invalid_argument_str), pat);\n\t\telse\n\t\t{\n\t\t    /*\n\t\t     * Save the value of got_int and reset it.  We don't want\n\t\t     * a previous interruption cancel matching, only hitting\n\t\t     * CTRL-C while matching should abort it.\n\t\t     */\n\t\t    prev_got_int = got_int;\n\t\t    got_int = FALSE;\n\t\t    caught = vim_regexec_nl(&regmatch,\n\t\t\t       (char_u *)current_exception->value, (colnr_T)0);\n\t\t    got_int |= prev_got_int;\n\t\t    vim_regfree(regmatch.regprog);\n\t\t}\n\t    }\n\t}\n\n\tif (caught)\n\t{\n\t    // Make this \":catch\" clause active and reset did_emsg, got_int,\n\t    // and did_throw.  Put the exception on the caught stack.\n\t    cstack->cs_flags[idx] |= CSF_ACTIVE | CSF_CAUGHT;\n\t    did_emsg = got_int = did_throw = FALSE;\n\t    catch_exception((except_T *)cstack->cs_exception[idx]);\n\n\t    if (cstack->cs_idx >= 0\n\t\t\t       && (cstack->cs_flags[cstack->cs_idx] & CSF_TRY))\n\t    {\n\t\t// Variables declared in the previous block can no longer be\n\t\t// used.\n\t\tleave_block(cstack);\n\t\tenter_block(cstack);\n\t    }\n\n\t    // It's mandatory that the current exception is stored in the cstack\n\t    // so that it can be discarded at the next \":catch\", \":finally\", or\n\t    // \":endtry\" or when the catch clause is left by a \":continue\",\n\t    // \":break\", \":return\", \":finish\", error, interrupt, or another\n\t    // exception.\n\t    if (cstack->cs_exception[cstack->cs_idx] != current_exception)\n\t\tinternal_error(\"ex_catch()\");\n\t}\n\telse\n\t{\n\t    /*\n\t     * If there is a preceding catch clause and it caught the exception,\n\t     * finish the exception now.  This happens also after errors except\n\t     * when this \":catch\" was after the \":finally\" or not within\n\t     * a \":try\".  Make the try conditional inactive so that the\n\t     * following catch clauses are skipped.  On an error or interrupt\n\t     * after the preceding try block or catch clause was left by\n\t     * a \":continue\", \":break\", \":return\", or \":finish\", discard the\n\t     * pending action.\n\t     */\n\t    cleanup_conditionals(cstack, CSF_TRY, TRUE);\n\t}\n    }\n\n    if (end != NULL)\n\teap->nextcmd = find_nextcmd(end);\n}\n\n/*\n * \":finally\"\n */\n    void\nex_finally(exarg_T *eap)\n{\n    int\t\tidx;\n    int\t\tskip = FALSE;\n    int\t\tpending = CSTP_NONE;\n    cstack_T\t*cstack = eap->cstack;\n\n    if (cmdmod_error(FALSE))\n\treturn;\n\n    if (cstack->cs_trylevel <= 0 || cstack->cs_idx < 0)\n\teap->errmsg = _(e_finally_without_try);\n    else\n    {\n\tif (!(cstack->cs_flags[cstack->cs_idx] & CSF_TRY))\n\t{\n\t    eap->errmsg = get_end_emsg(cstack);\n\t    for (idx = cstack->cs_idx - 1; idx > 0; --idx)\n\t\tif (cstack->cs_flags[idx] & CSF_TRY)\n\t\t    break;\n\t    // Make this error pending, so that the commands in the following\n\t    // finally clause can be executed.  This overrules also a pending\n\t    // \":continue\", \":break\", \":return\", or \":finish\".\n\t    pending = CSTP_ERROR;\n\t}\n\telse\n\t    idx = cstack->cs_idx;\n\n\tif (cstack->cs_flags[idx] & CSF_FINALLY)\n\t{\n\t    // Give up for a multiple \":finally\" and ignore it.\n\t    eap->errmsg = _(e_multiple_finally);\n\t    return;\n\t}\n\trewind_conditionals(cstack, idx, CSF_WHILE | CSF_FOR,\n\t\t\t\t\t\t       &cstack->cs_looplevel);\n\n\t/*\n\t * Don't do something when the corresponding try block never got active\n\t * (because of an inactive surrounding conditional or after an error or\n\t * interrupt or throw) or for a \":finally\" without \":try\" or a multiple\n\t * \":finally\".  After every other error (did_emsg or the conditional\n\t * errors detected above) or after an interrupt (got_int) or an\n\t * exception (did_throw), the finally clause must be executed.\n\t */\n\tskip = !(cstack->cs_flags[cstack->cs_idx] & CSF_TRUE);\n\n\tif (!skip)\n\t{\n\t    // When debugging or a breakpoint was encountered, display the\n\t    // debug prompt (if not already done).  The user then knows that the\n\t    // finally clause is executed.\n\t    if (dbg_check_skipped(eap))\n\t    {\n\t\t// Handle a \">quit\" debug command as if an interrupt had\n\t\t// occurred before the \":finally\".  That is, discard the\n\t\t// original exception and replace it by an interrupt\n\t\t// exception.\n\t\t(void)do_intthrow(cstack);\n\t    }\n\n\t    /*\n\t     * If there is a preceding catch clause and it caught the exception,\n\t     * finish the exception now.  This happens also after errors except\n\t     * when this is a multiple \":finally\" or one not within a \":try\".\n\t     * After an error or interrupt, this also discards a pending\n\t     * \":continue\", \":break\", \":finish\", or \":return\" from the preceding\n\t     * try block or catch clause.\n\t     */\n\t    cleanup_conditionals(cstack, CSF_TRY, FALSE);\n\n\t    if (cstack->cs_idx >= 0\n\t\t\t       && (cstack->cs_flags[cstack->cs_idx] & CSF_TRY))\n\t    {\n\t\t// Variables declared in the previous block can no longer be\n\t\t// used.\n\t\tleave_block(cstack);\n\t\tenter_block(cstack);\n\t    }\n\n\t    /*\n\t     * Make did_emsg, got_int, did_throw pending.  If set, they overrule\n\t     * a pending \":continue\", \":break\", \":return\", or \":finish\".  Then\n\t     * we have particularly to discard a pending return value (as done\n\t     * by the call to cleanup_conditionals() above when did_emsg or\n\t     * got_int is set).  The pending values are restored by the\n\t     * \":endtry\", except if there is a new error, interrupt, exception,\n\t     * \":continue\", \":break\", \":return\", or \":finish\" in the following\n\t     * finally clause.  A missing \":endwhile\", \":endfor\" or \":endif\"\n\t     * detected here is treated as if did_emsg and did_throw had\n\t     * already been set, respectively in case that the error is not\n\t     * converted to an exception, did_throw had already been unset.\n\t     * We must not set did_emsg here since that would suppress the\n\t     * error message.\n\t     */\n\t    if (pending == CSTP_ERROR || did_emsg || got_int || did_throw)\n\t    {\n\t\tif (cstack->cs_pending[cstack->cs_idx] == CSTP_RETURN)\n\t\t{\n\t\t    report_discard_pending(CSTP_RETURN,\n\t\t\t\t\t   cstack->cs_rettv[cstack->cs_idx]);\n\t\t    discard_pending_return(cstack->cs_rettv[cstack->cs_idx]);\n\t\t}\n\t\tif (pending == CSTP_ERROR && !did_emsg)\n\t\t    pending |= (THROW_ON_ERROR) ? CSTP_THROW : 0;\n\t\telse\n\t\t    pending |= did_throw ? CSTP_THROW : 0;\n\t\tpending |= did_emsg  ? CSTP_ERROR     : 0;\n\t\tpending |= got_int   ? CSTP_INTERRUPT : 0;\n\t\tcstack->cs_pending[cstack->cs_idx] = pending;\n\n\t\t// It's mandatory that the current exception is stored in the\n\t\t// cstack so that it can be rethrown at the \":endtry\" or be\n\t\t// discarded if the finally clause is left by a \":continue\",\n\t\t// \":break\", \":return\", \":finish\", error, interrupt, or another\n\t\t// exception.  When emsg() is called for a missing \":endif\" or\n\t\t// a missing \":endwhile\"/\":endfor\" detected here, the\n\t\t// exception will be discarded.\n\t\tif (did_throw && cstack->cs_exception[cstack->cs_idx]\n\t\t\t\t\t\t\t != current_exception)\n\t\t    internal_error(\"ex_finally()\");\n\t    }\n\n\t    /*\n\t     * Set CSL_HAD_FINA, so do_cmdline() will reset did_emsg,\n\t     * got_int, and did_throw and make the finally clause active.\n\t     * This will happen after emsg() has been called for a missing\n\t     * \":endif\" or a missing \":endwhile\"/\":endfor\" detected here, so\n\t     * that the following finally clause will be executed even then.\n\t     */\n\t    cstack->cs_lflags |= CSL_HAD_FINA;\n\t}\n    }\n}\n\n/*\n * \":endtry\"\n */\n    void\nex_endtry(exarg_T *eap)\n{\n    int\t\tidx;\n    int\t\tskip;\n    int\t\trethrow = FALSE;\n    int\t\tpending = CSTP_NONE;\n    void\t*rettv = NULL;\n    cstack_T\t*cstack = eap->cstack;\n\n    if (cmdmod_error(FALSE))\n\treturn;\n\n    if (cstack->cs_trylevel <= 0 || cstack->cs_idx < 0)\n\teap->errmsg = _(e_endtry_without_try);\n    else\n    {\n\t/*\n\t * Don't do something after an error, interrupt or throw in the try\n\t * block, catch clause, or finally clause preceding this \":endtry\" or\n\t * when an error or interrupt occurred after a \":continue\", \":break\",\n\t * \":return\", or \":finish\" in a try block or catch clause preceding this\n\t * \":endtry\" or when the try block never got active (because of an\n\t * inactive surrounding conditional or after an error or interrupt or\n\t * throw) or when there is a surrounding conditional and it has been\n\t * made inactive by a \":continue\", \":break\", \":return\", or \":finish\" in\n\t * the finally clause.  The latter case need not be tested since then\n\t * anything pending has already been discarded. */\n\tskip = did_emsg || got_int || did_throw\n\t\t\t     || !(cstack->cs_flags[cstack->cs_idx] & CSF_TRUE);\n\n\tif (!(cstack->cs_flags[cstack->cs_idx] & CSF_TRY))\n\t{\n\t    eap->errmsg = get_end_emsg(cstack);\n\n\t    // Find the matching \":try\" and report what's missing.\n\t    idx = cstack->cs_idx;\n\t    do\n\t\t--idx;\n\t    while (idx > 0 && !(cstack->cs_flags[idx] & CSF_TRY));\n\t    rewind_conditionals(cstack, idx, CSF_WHILE | CSF_FOR,\n\t\t\t\t\t\t       &cstack->cs_looplevel);\n\t    skip = TRUE;\n\n\t    /*\n\t     * If an exception is being thrown, discard it to prevent it from\n\t     * being rethrown at the end of this function.  It would be\n\t     * discarded by the error message, anyway.  Resets did_throw.\n\t     * This does not affect the script termination due to the error\n\t     * since \"trylevel\" is decremented after emsg() has been called.\n\t     */\n\t    if (did_throw)\n\t\tdiscard_current_exception();\n\n\t    // report eap->errmsg, also when there already was an error\n\t    did_emsg = FALSE;\n\t}\n\telse\n\t{\n\t    idx = cstack->cs_idx;\n\n\t    // Check the flags only when not in a skipped block.\n\t    if (!skip && in_vim9script()\n\t\t     && (cstack->cs_flags[idx] & (CSF_CATCH|CSF_FINALLY)) == 0)\n\t    {\n\t\t// try/endtry without any catch or finally: give an error and\n\t\t// continue.\n\t\teap->errmsg = _(e_missing_catch_or_finally);\n\t    }\n\n\t    /*\n\t     * If we stopped with the exception currently being thrown at this\n\t     * try conditional since we didn't know that it doesn't have\n\t     * a finally clause, we need to rethrow it after closing the try\n\t     * conditional.\n\t     */\n\t    if (did_throw && (cstack->cs_flags[idx] & CSF_TRUE)\n\t\t    && !(cstack->cs_flags[idx] & CSF_FINALLY))\n\t\trethrow = TRUE;\n\t}\n\n\t// If there was no finally clause, show the user when debugging or\n\t// a breakpoint was encountered that the end of the try conditional has\n\t// been reached: display the debug prompt (if not already done).  Do\n\t// this on normal control flow or when an exception was thrown, but not\n\t// on an interrupt or error not converted to an exception or when\n\t// a \":break\", \":continue\", \":return\", or \":finish\" is pending.  These\n\t// actions are carried out immediately.\n\tif ((rethrow || (!skip\n\t\t\t&& !(cstack->cs_flags[idx] & CSF_FINALLY)\n\t\t\t&& !cstack->cs_pending[idx]))\n\t\t&& dbg_check_skipped(eap))\n\t{\n\t    // Handle a \">quit\" debug command as if an interrupt had occurred\n\t    // before the \":endtry\".  That is, throw an interrupt exception and\n\t    // set \"skip\" and \"rethrow\".\n\t    if (got_int)\n\t    {\n\t\tskip = TRUE;\n\t\t(void)do_intthrow(cstack);\n\t\t// The do_intthrow() call may have reset did_throw or\n\t\t// cstack->cs_pending[idx].\n\t\trethrow = FALSE;\n\t\tif (did_throw && !(cstack->cs_flags[idx] & CSF_FINALLY))\n\t\t    rethrow = TRUE;\n\t    }\n\t}\n\n\t/*\n\t * If a \":return\" is pending, we need to resume it after closing the\n\t * try conditional; remember the return value.  If there was a finally\n\t * clause making an exception pending, we need to rethrow it.  Make it\n\t * the exception currently being thrown.\n\t */\n\tif (!skip)\n\t{\n\t    pending = cstack->cs_pending[idx];\n\t    cstack->cs_pending[idx] = CSTP_NONE;\n\t    if (pending == CSTP_RETURN)\n\t\trettv = cstack->cs_rettv[idx];\n\t    else if (pending & CSTP_THROW)\n\t\tcurrent_exception = cstack->cs_exception[idx];\n\t}\n\n\t/*\n\t * Discard anything pending on an error, interrupt, or throw in the\n\t * finally clause.  If there was no \":finally\", discard a pending\n\t * \":continue\", \":break\", \":return\", or \":finish\" if an error or\n\t * interrupt occurred afterwards, but before the \":endtry\" was reached.\n\t * If an exception was caught by the last of the catch clauses and there\n\t * was no finally clause, finish the exception now.  This happens also\n\t * after errors except when this \":endtry\" is not within a \":try\".\n\t * Restore \"emsg_silent\" if it has been reset by this try conditional.\n\t */\n\t(void)cleanup_conditionals(cstack, CSF_TRY | CSF_SILENT, TRUE);\n\n\tif (cstack->cs_idx >= 0\n\t\t\t       && (cstack->cs_flags[cstack->cs_idx] & CSF_TRY))\n\t    leave_block(cstack);\n\t--cstack->cs_trylevel;\n\n\tif (!skip)\n\t{\n\t    report_resume_pending(pending,\n\t\t    (pending == CSTP_RETURN) ? rettv :\n\t\t    (pending & CSTP_THROW) ? (void *)current_exception : NULL);\n\t    switch (pending)\n\t    {\n\t\tcase CSTP_NONE:\n\t\t    break;\n\n\t\t// Reactivate a pending \":continue\", \":break\", \":return\",\n\t\t// \":finish\" from the try block or a catch clause of this try\n\t\t// conditional.  This is skipped, if there was an error in an\n\t\t// (unskipped) conditional command or an interrupt afterwards\n\t\t// or if the finally clause is present and executed a new error,\n\t\t// interrupt, throw, \":continue\", \":break\", \":return\", or\n\t\t// \":finish\".\n\t\tcase CSTP_CONTINUE:\n\t\t    ex_continue(eap);\n\t\t    break;\n\t\tcase CSTP_BREAK:\n\t\t    ex_break(eap);\n\t\t    break;\n\t\tcase CSTP_RETURN:\n\t\t    do_return(eap, FALSE, FALSE, rettv);\n\t\t    break;\n\t\tcase CSTP_FINISH:\n\t\t    do_finish(eap, FALSE);\n\t\t    break;\n\n\t\t// When the finally clause was entered due to an error,\n\t\t// interrupt or throw (as opposed to a \":continue\", \":break\",\n\t\t// \":return\", or \":finish\"), restore the pending values of\n\t\t// did_emsg, got_int, and did_throw.  This is skipped, if there\n\t\t// was a new error, interrupt, throw, \":continue\", \":break\",\n\t\t// \":return\", or \":finish\".  in the finally clause.\n\t\tdefault:\n\t\t    if (pending & CSTP_ERROR)\n\t\t\tdid_emsg = TRUE;\n\t\t    if (pending & CSTP_INTERRUPT)\n\t\t\tgot_int = TRUE;\n\t\t    if (pending & CSTP_THROW)\n\t\t\trethrow = TRUE;\n\t\t    break;\n\t    }\n\t}\n\n\tif (rethrow)\n\t    // Rethrow the current exception (within this cstack).\n\t    do_throw(cstack);\n    }\n}\n\n/*\n * enter_cleanup() and leave_cleanup()\n *\n * Functions to be called before/after invoking a sequence of autocommands for\n * cleanup for a failed command.  (Failure means here that a call to emsg()\n * has been made, an interrupt occurred, or there is an uncaught exception\n * from a previous autocommand execution of the same command.)\n *\n * Call enter_cleanup() with a pointer to a cleanup_T and pass the same\n * pointer to leave_cleanup().  The cleanup_T structure stores the pending\n * error/interrupt/exception state.\n */\n\n/*\n * This function works a bit like ex_finally() except that there was not\n * actually an extra try block around the part that failed and an error or\n * interrupt has not (yet) been converted to an exception.  This function\n * saves the error/interrupt/ exception state and prepares for the call to\n * do_cmdline() that is going to be made for the cleanup autocommand\n * execution.\n */\n    void\nenter_cleanup(cleanup_T *csp)\n{\n    int\t\tpending = CSTP_NONE;\n\n    /*\n     * Postpone did_emsg, got_int, did_throw.  The pending values will be\n     * restored by leave_cleanup() except if there was an aborting error,\n     * interrupt, or uncaught exception after this function ends.\n     */\n    if (did_emsg || got_int || did_throw || need_rethrow)\n    {\n\tcsp->pending = (did_emsg     ? CSTP_ERROR     : 0)\n\t\t     | (got_int      ? CSTP_INTERRUPT : 0)\n\t\t     | (did_throw    ? CSTP_THROW     : 0)\n\t\t     | (need_rethrow ? CSTP_THROW     : 0);\n\n\t// If we are currently throwing an exception (did_throw), save it as\n\t// well.  On an error not yet converted to an exception, update\n\t// \"force_abort\" and reset \"cause_abort\" (as do_errthrow() would do).\n\t// This is needed for the do_cmdline() call that is going to be made\n\t// for autocommand execution.  We need not save *msg_list because\n\t// there is an extra instance for every call of do_cmdline(), anyway.\n\tif (did_throw || need_rethrow)\n\t{\n\t    csp->exception = current_exception;\n\t    current_exception = NULL;\n\t}\n\telse\n\t{\n\t    csp->exception = NULL;\n\t    if (did_emsg)\n\t    {\n\t\tforce_abort |= cause_abort;\n\t\tcause_abort = FALSE;\n\t    }\n\t}\n\tdid_emsg = got_int = did_throw = need_rethrow = FALSE;\n\n\t// Report if required by the 'verbose' option or when debugging.\n\treport_make_pending(pending, csp->exception);\n    }\n    else\n    {\n\tcsp->pending = CSTP_NONE;\n\tcsp->exception = NULL;\n    }\n}\n\n/*\n * See comment above enter_cleanup() for how this function is used.\n *\n * This function is a bit like ex_endtry() except that there was not actually\n * an extra try block around the part that failed and an error or interrupt\n * had not (yet) been converted to an exception when the cleanup autocommand\n * sequence was invoked.\n *\n * This function has to be called with the address of the cleanup_T structure\n * filled by enter_cleanup() as an argument; it restores the error/interrupt/\n * exception state saved by that function - except there was an aborting\n * error, an interrupt or an uncaught exception during execution of the\n * cleanup autocommands.  In the latter case, the saved error/interrupt/\n * exception state is discarded.\n */\n    void\nleave_cleanup(cleanup_T *csp)\n{\n    int\t\tpending = csp->pending;\n\n    if (pending == CSTP_NONE)\t// nothing to do\n\treturn;\n\n    // If there was an aborting error, an interrupt, or an uncaught exception\n    // after the corresponding call to enter_cleanup(), discard what has been\n    // made pending by it.  Report this to the user if required by the\n    // 'verbose' option or when debugging.\n    if (aborting() || need_rethrow)\n    {\n\tif (pending & CSTP_THROW)\n\t    // Cancel the pending exception (includes report).\n\t    discard_exception(csp->exception, FALSE);\n\telse\n\t    report_discard_pending(pending, NULL);\n\n\t// If an error was about to be converted to an exception when\n\t// enter_cleanup() was called, free the message list.\n\tif (msg_list != NULL)\n\t    free_global_msglist();\n    }\n\n    /*\n     * If there was no new error, interrupt, or throw between the calls\n     * to enter_cleanup() and leave_cleanup(), restore the pending\n     * error/interrupt/exception state.\n     */\n    else\n    {\n\t/*\n\t * If there was an exception being thrown when enter_cleanup() was\n\t * called, we need to rethrow it.  Make it the exception currently\n\t * being thrown.\n\t */\n\tif (pending & CSTP_THROW)\n\t    current_exception = csp->exception;\n\n\t/*\n\t * If an error was about to be converted to an exception when\n\t * enter_cleanup() was called, let \"cause_abort\" take the part of\n\t * \"force_abort\" (as done by cause_errthrow()).\n\t */\n\telse if (pending & CSTP_ERROR)\n\t{\n\t    cause_abort = force_abort;\n\t    force_abort = FALSE;\n\t}\n\n\t/*\n\t * Restore the pending values of did_emsg, got_int, and did_throw.\n\t */\n\tif (pending & CSTP_ERROR)\n\t    did_emsg = TRUE;\n\tif (pending & CSTP_INTERRUPT)\n\t    got_int = TRUE;\n\tif (pending & CSTP_THROW)\n\t    need_rethrow = TRUE;    // did_throw will be set by do_one_cmd()\n\n\t// Report if required by the 'verbose' option or when debugging.\n\treport_resume_pending(pending,\n\t\t   (pending & CSTP_THROW) ? (void *)current_exception : NULL);\n    }\n}\n\n\n/*\n * Make conditionals inactive and discard what's pending in finally clauses\n * until the conditional type searched for or a try conditional not in its\n * finally clause is reached.  If this is in an active catch clause, finish\n * the caught exception.\n * Return the cstack index where the search stopped.\n * Values used for \"searched_cond\" are (CSF_WHILE | CSF_FOR) or CSF_TRY or 0,\n * the latter meaning the innermost try conditional not in its finally clause.\n * \"inclusive\" tells whether the conditional searched for should be made\n * inactive itself (a try conditional not in its finally clause possibly find\n * before is always made inactive).  If \"inclusive\" is TRUE and\n * \"searched_cond\" is CSF_TRY|CSF_SILENT, the saved former value of\n * \"emsg_silent\", if reset when the try conditional finally reached was\n * entered, is restored (used by ex_endtry()).  This is normally done only\n * when such a try conditional is left.\n */\n    int\ncleanup_conditionals(\n    cstack_T   *cstack,\n    int\t\tsearched_cond,\n    int\t\tinclusive)\n{\n    int\t\tidx;\n    int\t\tstop = FALSE;\n\n    for (idx = cstack->cs_idx; idx >= 0; --idx)\n    {\n\tif (cstack->cs_flags[idx] & CSF_TRY)\n\t{\n\t    /*\n\t     * Discard anything pending in a finally clause and continue the\n\t     * search.  There may also be a pending \":continue\", \":break\",\n\t     * \":return\", or \":finish\" before the finally clause.  We must not\n\t     * discard it, unless an error or interrupt occurred afterwards.\n\t     */\n\t    if (did_emsg || got_int || (cstack->cs_flags[idx] & CSF_FINALLY))\n\t    {\n\t\tswitch (cstack->cs_pending[idx])\n\t\t{\n\t\t    case CSTP_NONE:\n\t\t\tbreak;\n\n\t\t    case CSTP_CONTINUE:\n\t\t    case CSTP_BREAK:\n\t\t    case CSTP_FINISH:\n\t\t\treport_discard_pending(cstack->cs_pending[idx], NULL);\n\t\t\tcstack->cs_pending[idx] = CSTP_NONE;\n\t\t\tbreak;\n\n\t\t    case CSTP_RETURN:\n\t\t\treport_discard_pending(CSTP_RETURN,\n\t\t\t\t\t\t      cstack->cs_rettv[idx]);\n\t\t\tdiscard_pending_return(cstack->cs_rettv[idx]);\n\t\t\tcstack->cs_pending[idx] = CSTP_NONE;\n\t\t\tbreak;\n\n\t\t    default:\n\t\t\tif (cstack->cs_flags[idx] & CSF_FINALLY)\n\t\t\t{\n\t\t\t    if ((cstack->cs_pending[idx] & CSTP_THROW)\n\t\t\t\t    && cstack->cs_exception[idx] != NULL)\n\t\t\t    {\n\t\t\t\t// Cancel the pending exception.  This is in the\n\t\t\t\t// finally clause, so that the stack of the\n\t\t\t\t// caught exceptions is not involved.\n\t\t\t\tdiscard_exception(\n\t\t\t\t\t(except_T *)cstack->cs_exception[idx],\n\t\t\t\t\tFALSE);\n\t\t\t    }\n\t\t\t    else\n\t\t\t\treport_discard_pending(cstack->cs_pending[idx],\n\t\t\t\t\tNULL);\n\t\t\t    cstack->cs_pending[idx] = CSTP_NONE;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t    }\n\n\t    /*\n\t     * Stop at a try conditional not in its finally clause.  If this try\n\t     * conditional is in an active catch clause, finish the caught\n\t     * exception.\n\t     */\n\t    if (!(cstack->cs_flags[idx] & CSF_FINALLY))\n\t    {\n\t\tif ((cstack->cs_flags[idx] & CSF_ACTIVE)\n\t\t\t&& (cstack->cs_flags[idx] & CSF_CAUGHT)\n\t\t\t&& !(cstack->cs_flags[idx] & CSF_FINISHED))\n\t\t{\n\t\t    finish_exception((except_T *)cstack->cs_exception[idx]);\n\t\t    cstack->cs_flags[idx] |= CSF_FINISHED;\n\t\t}\n\t\t// Stop at this try conditional - except the try block never\n\t\t// got active (because of an inactive surrounding conditional\n\t\t// or when the \":try\" appeared after an error or interrupt or\n\t\t// throw).\n\t\tif (cstack->cs_flags[idx] & CSF_TRUE)\n\t\t{\n\t\t    if (searched_cond == 0 && !inclusive)\n\t\t\tbreak;\n\t\t    stop = TRUE;\n\t\t}\n\t    }\n\t}\n\n\t// Stop on the searched conditional type (even when the surrounding\n\t// conditional is not active or something has been made pending).\n\t// If \"inclusive\" is TRUE and \"searched_cond\" is CSF_TRY|CSF_SILENT,\n\t// check first whether \"emsg_silent\" needs to be restored.\n\tif (cstack->cs_flags[idx] & searched_cond)\n\t{\n\t    if (!inclusive)\n\t\tbreak;\n\t    stop = TRUE;\n\t}\n\tcstack->cs_flags[idx] &= ~CSF_ACTIVE;\n\tif (stop && searched_cond != (CSF_TRY | CSF_SILENT))\n\t    break;\n\n\t/*\n\t * When leaving a try conditional that reset \"emsg_silent\" on its\n\t * entry after saving the original value, restore that value here and\n\t * free the memory used to store it.\n\t */\n\tif ((cstack->cs_flags[idx] & CSF_TRY)\n\t\t&& (cstack->cs_flags[idx] & CSF_SILENT))\n\t{\n\t    eslist_T\t*elem;\n\n\t    elem = cstack->cs_emsg_silent_list;\n\t    cstack->cs_emsg_silent_list = elem->next;\n\t    emsg_silent = elem->saved_emsg_silent;\n\t    vim_free(elem);\n\t    cstack->cs_flags[idx] &= ~CSF_SILENT;\n\t}\n\tif (stop)\n\t    break;\n    }\n    return idx;\n}\n\n/*\n * Return an appropriate error message for a missing endwhile/endfor/endif.\n */\n   static char *\nget_end_emsg(cstack_T *cstack)\n{\n    if (cstack->cs_flags[cstack->cs_idx] & CSF_WHILE)\n\treturn _(e_missing_endwhile);\n    if (cstack->cs_flags[cstack->cs_idx] & CSF_FOR)\n\treturn _(e_missing_endfor);\n    return _(e_missing_endif);\n}\n\n\n/*\n * Rewind conditionals until index \"idx\" is reached.  \"cond_type\" and\n * \"cond_level\" specify a conditional type and the address of a level variable\n * which is to be decremented with each skipped conditional of the specified\n * type.\n * Also free \"for info\" structures where needed.\n */\n    void\nrewind_conditionals(\n    cstack_T   *cstack,\n    int\t\tidx,\n    int\t\tcond_type,\n    int\t\t*cond_level)\n{\n    while (cstack->cs_idx > idx)\n    {\n\tif (cstack->cs_flags[cstack->cs_idx] & cond_type)\n\t    --*cond_level;\n\tif (cstack->cs_flags[cstack->cs_idx] & CSF_FOR)\n\t    free_for_info(cstack->cs_forinfo[cstack->cs_idx]);\n\tleave_block(cstack);\n    }\n}\n\n/*\n * \":endfunction\" or \":enddef\" when not after a \":function\"\n */\n    void\nex_endfunction(exarg_T *eap)\n{\n    if (eap->cmdidx == CMD_enddef)\n\tsemsg(_(e_str_not_inside_function), \":enddef\");\n    else\n\tsemsg(_(e_str_not_inside_function), \":endfunction\");\n}\n\n/*\n * Return TRUE if the string \"p\" looks like a \":while\" or \":for\" command.\n */\n    int\nhas_loop_cmd(char_u *p)\n{\n    int\t\tlen;\n\n    // skip modifiers, white space and ':'\n    for (;;)\n    {\n\twhile (*p == ' ' || *p == '\\t' || *p == ':')\n\t    ++p;\n\tlen = modifier_len(p);\n\tif (len == 0)\n\t    break;\n\tp += len;\n    }\n    if ((p[0] == 'w' && p[1] == 'h')\n\t    || (p[0] == 'f' && p[1] == 'o' && p[2] == 'r'))\n\treturn TRUE;\n    return FALSE;\n}\n\n#endif // FEAT_EVAL\n", "\" Test try-catch-finally exception handling\n\" Most of this was formerly in test49.\n\nsource check.vim\nsource shared.vim\n\n\"-------------------------------------------------------------------------------\n\" Test environment\t\t\t\t\t\t\t    {{{1\n\"-------------------------------------------------------------------------------\n\ncom!\t\t   XpathINIT  let g:Xpath = ''\ncom! -nargs=1 -bar Xpath      let g:Xpath = g:Xpath . <args>\n\n\" Test 25:  Executing :finally clauses on normal control flow\t\t    {{{1\n\"\n\"\t    Control flow in a :try conditional should always fall through to its\n\"\t    :finally clause.  A :finally clause of a :try conditional inside an\n\"\t    inactive conditional should never be executed.\n\"-------------------------------------------------------------------------------\n\nfunc T25_F()\n  let loops = 3\n  while loops > 0\n    Xpath 'a' . loops\n    if loops >= 2\n      try\n        Xpath 'b' . loops\n        if loops == 2\n          try\n            Xpath 'c' . loops\n          finally\n            Xpath 'd' . loops\n          endtry\n        endif\n      finally\n        Xpath 'e' . loops\n        if loops == 2\n          try\n            Xpath 'f' . loops\n          final\n            Xpath 'g' . loops\n          endtry\n        endif\n      endtry\n    endif\n    Xpath 'h' . loops\n    let loops = loops - 1\n  endwhile\n  Xpath 'i'\nendfunc\n\n\" Also try using \"fina\" and \"final\" and \"finall\" as abbreviations.\nfunc T25_G()\n  if 1\n    try\n      Xpath 'A'\n      call T25_F()\n      Xpath 'B'\n    fina\n      Xpath 'C'\n    endtry\n  else\n    try\n      Xpath 'D'\n    finall\n      Xpath 'E'\n    endtry\n  endif\nendfunc\n\nfunc Test_finally()\n  XpathINIT\n  call T25_G()\n  call assert_equal('Aa3b3e3h3a2b2c2d2e2f2g2h2a1h1iBC', g:Xpath)\nendfunc\n\n\n\"-------------------------------------------------------------------------------\n\" Test 26:  Executing :finally clauses after :continue or :break\t    {{{1\n\"\n\"\t    For a :continue or :break dynamically enclosed in a :try/:endtry\n\"\t    region inside the next surrounding :while/:endwhile, if the\n\"\t    :continue/:break is before the :finally, the :finally clause is\n\"\t    executed first.  If the :continue/:break is after the :finally, the\n\"\t    :finally clause is broken (like an :if/:endif region).\n\"-------------------------------------------------------------------------------\n\nfunc T26_F()\n  try\n    let loops = 3\n    while loops > 0\n      try\n        try\n          if loops == 2\n            Xpath 'a' . loops\n            let loops = loops - 1\n            continue\n          elseif loops == 1\n            Xpath 'b' . loops\n            break\n            finish\n          endif\n          Xpath 'c' . loops\n        endtry\n      finally\n        Xpath 'd' . loops\n      endtry\n      Xpath 'e' . loops\n      let loops = loops - 1\n    endwhile\n    Xpath 'f'\n  finally\n    Xpath 'g'\n    let loops = 3\n    while loops > 0\n      try\n      finally\n        try\n          if loops == 2\n            Xpath 'h' . loops\n            let loops = loops - 1\n            continue\n          elseif loops == 1\n            Xpath 'i' . loops\n            break\n            finish\n          endif\n        endtry\n        Xpath 'j' . loops\n      endtry\n      Xpath 'k' . loops\n      let loops = loops - 1\n    endwhile\n    Xpath 'l'\n  endtry\n  Xpath 'm'\nendfunc\n\nfunc Test_finally_after_continue()\n  XpathINIT\n  call T26_F()\n  call assert_equal('c3d3e3a2d1b1d1fgj3k3h2i1lm', g:Xpath)\nendfunc\n\n\n\"-------------------------------------------------------------------------------\n\" Test 32:  Remembering the :return value on :finally\t\t\t    {{{1\n\"\n\"\t    If a :finally clause is executed due to a :return specifying\n\"\t    a value, this is the value visible to the caller if not overwritten\n\"\t    by a new :return in the :finally clause.  A :return without a value\n\"\t    in the :finally clause overwrites with value 0.\n\"-------------------------------------------------------------------------------\n\nfunc T32_F()\n  try\n    Xpath 'a'\n    try\n      Xpath 'b'\n      return \"ABCD\"\n      Xpath 'c'\n    finally\n      Xpath 'd'\n    endtry\n    Xpath 'e'\n  finally\n    Xpath 'f'\n  endtry\n  Xpath 'g'\nendfunc\n\nfunc T32_G()\n  try\n    Xpath 'h'\n    return 8\n    Xpath 'i'\n  finally\n    Xpath 'j'\n    return 16 + strlen(T32_F())\n    Xpath 'k'\n  endtry\n  Xpath 'l'\nendfunc\n\nfunc T32_H()\n  try\n    Xpath 'm'\n    return 32\n    Xpath 'n'\n  finally\n    Xpath 'o'\n    return\n    Xpath 'p'\n  endtry\n  Xpath 'q'\nendfunc\n\nfunc T32_I()\n  try\n    Xpath 'r'\n  finally\n    Xpath 's'\n    return T32_G() + T32_H() + 64\n    Xpath 't'\n  endtry\n  Xpath 'u'\nendfunc\n\nfunc Test_finally_return()\n  XpathINIT\n  call assert_equal(84, T32_I())\n  call assert_equal('rshjabdfmo', g:Xpath)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 33:  :return under :execute or user command and :finally\t\t    {{{1\n\"\n\"\t    A :return command may be executed under an \":execute\" or from\n\"\t    a user command.  Executing of :finally clauses and passing through\n\"\t    the return code works also then.\n\"-------------------------------------------------------------------------------\n\nfunc T33_F()\n  try\n    RETURN 10\n    Xpath 'a'\n  finally\n    Xpath 'b'\n  endtry\n  Xpath 'c'\nendfunc\n\nfunc T33_G()\n  try\n    RETURN 20\n    Xpath 'd'\n  finally\n    Xpath 'e'\n    RETURN 30\n    Xpath 'f'\n  endtry\n  Xpath 'g'\nendfunc\n\nfunc T33_H()\n  try\n    execute \"try | return 40 | finally | return 50 | endtry\"\n    Xpath 'h'\n  finally\n    Xpath 'i'\n  endtry\n  Xpath 'j'\nendfunc\n\nfunc T33_I()\n  try\n    execute \"try | return 60 | finally | return 70 | endtry\"\n    Xpath 'k'\n  finally\n    Xpath 'l'\n    execute \"try | return 80 | finally | return 90 | endtry\"\n    Xpath 'm'\n  endtry\n  Xpath 'n'\nendfunc\n\nfunc T33_J()\n  try\n    RETURN 100\n    Xpath 'o'\n  finally\n    Xpath 'p'\n    return\n    Xpath 'q'\n  endtry\n  Xpath 'r'\nendfunc\n\nfunc T33_K()\n  try\n    execute \"try | return 110 | finally | return 120 | endtry\"\n    Xpath 's'\n  finally\n    Xpath 't'\n    execute \"try | return 130 | finally | return | endtry\"\n    Xpath 'u'\n  endtry\n  Xpath 'v'\nendfunc\n\nfunc T33_L()\n  try\n    return\n    Xpath 'w'\n  finally\n    Xpath 'x'\n    RETURN 140\n    Xpath 'y'\n  endtry\n  Xpath 'z'\nendfunc\n\nfunc T33_M()\n  try\n    return\n    Xpath 'A'\n  finally\n    Xpath 'B'\n    execute \"try | return 150 | finally | return 160 | endtry\"\n    Xpath 'C'\n  endtry\n  Xpath 'D'\nendfunc\n\nfunc T33_N()\n  RETURN 170\nendfunc\n\nfunc T33_O()\n  execute \"try | return 180 | finally | return 190 | endtry\"\nendfunc\n\nfunc Test_finally_cmd_return()\n  command! -nargs=? RETURN\n        \\ try | return <args> | finally | return <args> * 2 | endtry\n  XpathINIT\n  call assert_equal(20, T33_F())\n  call assert_equal(60, T33_G())\n  call assert_equal(50, T33_H())\n  call assert_equal(90, T33_I())\n  call assert_equal(0, T33_J())\n  call assert_equal(0, T33_K())\n  call assert_equal(280, T33_L())\n  call assert_equal(160, T33_M())\n  call assert_equal(340, T33_N())\n  call assert_equal(190, T33_O())\n  call assert_equal('beilptxB', g:Xpath)\n  delcommand RETURN\nendfunc\n\n\n\"-------------------------------------------------------------------------------\n\" Test 41:  Skipped :throw finding next command\t\t\t\t    {{{1\n\"\n\"\t    A :throw in an inactive conditional must not hide a following\n\"\t    command.\n\"-------------------------------------------------------------------------------\n\nfunc T41_F()\n  Xpath 'a'\n  if 0 | throw 'never' | endif | Xpath 'b'\n  Xpath 'c'\nendfunc\n\nfunc T41_G()\n  Xpath 'd'\n  while 0 | throw 'never' | endwhile | Xpath 'e'\n  Xpath 'f'\nendfunc\n\nfunc T41_H()\n  Xpath 'g'\n  if 0 | try | throw 'never' | endtry | endif | Xpath 'h'\n  Xpath 'i'\nendfunc\n\nfunc Test_throw_inactive_cond()\n  XpathINIT\n  try\n    Xpath 'j'\n    call T41_F()\n    Xpath 'k'\n  catch /.*/\n    Xpath 'l'\n    call assert_report('Caught ' . v:exception . ' in ' . v:throwpoint)\n  endtry\n\n  try\n    Xpath 'm'\n    call T41_G()\n    Xpath 'n'\n  catch /.*/\n    Xpath 'o'\n    call assert_report('Caught ' . v:exception . ' in ' . v:throwpoint)\n  endtry\n\n  try\n    Xpath 'p'\n    call T41_H()\n    Xpath 'q'\n  catch /.*/\n    Xpath 'r'\n    call assert_report('Caught ' . v:exception . ' in ' . v:throwpoint)\n  endtry\n\n  call assert_equal('jabckmdefnpghiq', g:Xpath)\nendfunc\n\n\n\"-------------------------------------------------------------------------------\n\" Test 42:  Catching number and string exceptions\t\t\t    {{{1\n\"\n\"\t    When a number is thrown, it is converted to a string exception.\n\"\t    Numbers and strings may be caught by specifying a regular exception\n\"\t    as argument to the :catch command.\n\"-------------------------------------------------------------------------------\n\n\nfunc T42_F()\n  try\n\n    try\n      Xpath 'a'\n      throw 4711\n      Xpath 'b'\n    catch /4711/\n      Xpath 'c'\n    endtry\n\n    try\n      Xpath 'd'\n      throw 4711\n      Xpath 'e'\n    catch /^4711$/\n      Xpath 'f'\n    endtry\n\n    try\n      Xpath 'g'\n      throw 4711\n      Xpath 'h'\n    catch /\\d/\n      Xpath 'i'\n    endtry\n\n    try\n      Xpath 'j'\n      throw 4711\n      Xpath 'k'\n    catch /^\\d\\+$/\n      Xpath 'l'\n    endtry\n\n    try\n      Xpath 'm'\n      throw \"arrgh\"\n      Xpath 'n'\n    catch /arrgh/\n      Xpath 'o'\n    endtry\n\n    try\n      Xpath 'p'\n      throw \"arrgh\"\n      Xpath 'q'\n    catch /^arrgh$/\n      Xpath 'r'\n    endtry\n\n    try\n      Xpath 's'\n      throw \"arrgh\"\n      Xpath 't'\n    catch /\\l/\n      Xpath 'u'\n    endtry\n\n    try\n      Xpath 'v'\n      throw \"arrgh\"\n      Xpath 'w'\n    catch /^\\l\\+$/\n      Xpath 'x'\n    endtry\n\n    try\n      try\n        Xpath 'y'\n        throw \"ARRGH\"\n        Xpath 'z'\n      catch /^arrgh$/\n        Xpath 'A'\n      endtry\n    catch /^\\carrgh$/\n      Xpath 'B'\n    endtry\n\n    try\n      Xpath 'C'\n      throw \"\"\n      Xpath 'D'\n    catch /^$/\n      Xpath 'E'\n    endtry\n\n  catch /.*/\n    Xpath 'F'\n    call assert_report('Caught ' . v:exception . ' in ' . v:throwpoint)\n  endtry\nendfunc\n\nfunc Test_catch_number_string()\n  XpathINIT\n  call T42_F()\n  call assert_equal('acdfgijlmoprsuvxyBCE', g:Xpath)\nendfunc\n\n\n\"-------------------------------------------------------------------------------\n\" Test 43:  Selecting the correct :catch clause\t\t\t\t    {{{1\n\"\n\"\t    When an exception is thrown and there are multiple :catch clauses,\n\"\t    the first matching one is taken.\n\"-------------------------------------------------------------------------------\n\nfunc T43_F()\n  let loops = 3\n  while loops > 0\n    try\n      if loops == 3\n        Xpath 'a' . loops\n        throw \"a\"\n        Xpath 'b' . loops\n      elseif loops == 2\n        Xpath 'c' . loops\n        throw \"ab\"\n        Xpath 'd' . loops\n      elseif loops == 1\n        Xpath 'e' . loops\n        throw \"abc\"\n        Xpath 'f' . loops\n      endif\n    catch /abc/\n      Xpath 'g' . loops\n    catch /ab/\n      Xpath 'h' . loops\n    catch /.*/\n      Xpath 'i' . loops\n    catch /a/\n      Xpath 'j' . loops\n    endtry\n\n    let loops = loops - 1\n  endwhile\n  Xpath 'k'\nendfunc\n\nfunc Test_multi_catch()\n  XpathINIT\n  call T43_F()\n  call assert_equal('a3i3c2h2e1g1k', g:Xpath)\nendfunc\n\n\n\"-------------------------------------------------------------------------------\n\" Test 44:  Missing or empty :catch patterns\t\t\t\t    {{{1\n\"\n\"\t    A missing or empty :catch pattern means the same as /.*/, that is,\n\"\t    catches everything.  To catch only empty exceptions, /^$/ must be\n\"\t    used.  A :catch with missing, empty, or /.*/ argument also works\n\"\t    when followed by another command separated by a bar on the same\n\"\t    line.  :catch patterns cannot be specified between ||.  But other\n\"\t    pattern separators can be used instead of //.\n\"-------------------------------------------------------------------------------\n\nfunc T44_F()\n  try\n    try\n      Xpath 'a'\n      throw \"\"\n    catch /^$/\n      Xpath 'b'\n    endtry\n\n    try\n      Xpath 'c'\n      throw \"\"\n    catch /.*/\n      Xpath 'd'\n    endtry\n\n    try\n      Xpath 'e'\n      throw \"\"\n    catch //\n      Xpath 'f'\n    endtry\n\n    try\n      Xpath 'g'\n      throw \"\"\n    catch\n      Xpath 'h'\n    endtry\n\n    try\n      Xpath 'i'\n      throw \"oops\"\n    catch /^$/\n      Xpath 'j'\n    catch /.*/\n      Xpath 'k'\n    endtry\n\n    try\n      Xpath 'l'\n      throw \"arrgh\"\n    catch /^$/\n      Xpath 'm'\n    catch //\n      Xpath 'n'\n    endtry\n\n    try\n      Xpath 'o'\n      throw \"brrr\"\n    catch /^$/\n      Xpath 'p'\n    catch\n      Xpath 'q'\n    endtry\n\n    try | Xpath 'r' | throw \"x\" | catch /.*/ | Xpath 's' | endtry\n\n    try | Xpath 't' | throw \"y\" | catch // | Xpath 'u' | endtry\n\n    while 1\n      try\n        let caught = 0\n        let v:errmsg = \"\"\n        \" Extra try level:  if \":catch\" without arguments below raises\n        \" a syntax error because it misinterprets the \"Xpath\" as a pattern,\n        \" let it be caught by the \":catch /.*/\" below.\n        try\n          try | Xpath 'v' | throw \"z\" | catch | Xpath 'w' | :\n          endtry\n        endtry\n      catch /.*/\n        let caught = 1\n        call assert_report('Caught ' . v:exception . ' in ' . v:throwpoint)\n      finally\n        if $VIMNOERRTHROW && v:errmsg != \"\"\n          call assert_report(v:errmsg)\n        endif\n        if caught || $VIMNOERRTHROW && v:errmsg != \"\"\n          Xpath 'x'\n        endif\n        break\t\t\" discard error for $VIMNOERRTHROW\n      endtry\n    endwhile\n\n    let cologne = 4711\n    try\n      try\n        Xpath 'y'\n        throw \"throw cologne\"\n        \" Next lines catches all and throws 4711:\n      catch |throw cologne|\n        Xpath 'z'\n      endtry\n    catch /4711/\n      Xpath 'A'\n    endtry\n\n    try\n      Xpath 'B'\n      throw \"plus\"\n    catch +plus+\n      Xpath 'C'\n    endtry\n\n    Xpath 'D'\n  catch /.*/\n    Xpath 'E'\n    call assert_report('Caught ' . v:exception . ' in ' . v:throwpoint)\n  endtry\nendfunc\n\nfunc Test_empty_catch()\n  XpathINIT\n  call T44_F()\n  call assert_equal('abcdefghiklnoqrstuvwyABCD', g:Xpath)\nendfunc\n\n\n\"-------------------------------------------------------------------------------\n\" Test 45:  Catching exceptions from nested :try blocks\t\t\t    {{{1\n\"\n\"\t    When :try blocks are nested, an exception is caught by the innermost\n\"\t    try conditional that has a matching :catch clause.\n\"-------------------------------------------------------------------------------\n\nfunc T45_F()\n  let loops = 3\n  while loops > 0\n    try\n      try\n        try\n          try\n            if loops == 3\n              Xpath 'a' . loops\n              throw \"a\"\n              Xpath 'b' . loops\n            elseif loops == 2\n              Xpath 'c' . loops\n              throw \"ab\"\n              Xpath 'd' . loops\n            elseif loops == 1\n              Xpath 'e' . loops\n              throw \"abc\"\n              Xpath 'f' . loops\n            endif\n          catch /abc/\n            Xpath 'g' . loops\n          endtry\n        catch /ab/\n          Xpath 'h' . loops\n        endtry\n      catch /.*/\n        Xpath 'i' . loops\n      endtry\n    catch /a/\n      Xpath 'j' . loops\n    endtry\n\n    let loops = loops - 1\n  endwhile\n  Xpath 'k'\nendfunc\n\nfunc Test_catch_from_nested_try()\n  XpathINIT\n  call T45_F()\n  call assert_equal('a3i3c2h2e1g1k', g:Xpath)\nendfunc\n\n\n\"-------------------------------------------------------------------------------\n\" Test 46:  Executing :finally after a :throw in nested :try\t\t    {{{1\n\"\n\"\t    When an exception is thrown from within nested :try blocks, the\n\"\t    :finally clauses of the non-catching try conditionals should be\n\"\t    executed before the matching :catch of the next surrounding :try\n\"\t    gets the control.  If this also has a :finally clause, it is\n\"\t    executed afterwards.\n\"-------------------------------------------------------------------------------\n\nfunc T46_F()\n  let sum = 0\n\n  try\n    Xpath 'a'\n    try\n      Xpath 'b'\n      try\n        Xpath 'c'\n        try\n          Xpath 'd'\n          throw \"ABC\"\n          Xpath 'e'\n        catch /xyz/\n          Xpath 'f'\n        finally\n          Xpath 'g'\n          if sum != 0\n            Xpath 'h'\n          endif\n          let sum = sum + 1\n        endtry\n        Xpath 'i'\n      catch /123/\n        Xpath 'j'\n      catch /321/\n        Xpath 'k'\n      finally\n        Xpath 'l'\n        if sum != 1\n          Xpath 'm'\n        endif\n        let sum = sum + 2\n      endtry\n      Xpath 'n'\n    finally\n      Xpath 'o'\n      if sum != 3\n        Xpath 'p'\n      endif\n      let sum = sum + 4\n    endtry\n    Xpath 'q'\n  catch /ABC/\n    Xpath 'r'\n    if sum != 7\n      Xpath 's'\n    endif\n    let sum = sum + 8\n  finally\n    Xpath 't'\n    if sum != 15\n      Xpath 'u'\n    endif\n    let sum = sum + 16\n  endtry\n  Xpath 'v'\n  if sum != 31\n    Xpath 'w'\n  endif\nendfunc\n\nfunc Test_finally_after_throw()\n  XpathINIT\n  call T46_F()\n  call assert_equal('abcdglortv', g:Xpath)\nendfunc\n\n\n\"-------------------------------------------------------------------------------\n\" Test 47:  Throwing exceptions from a :catch clause\t\t\t    {{{1\n\"\n\"\t    When an exception is thrown from a :catch clause, it should not be\n\"\t    caught by a :catch of the same :try conditional.  After executing\n\"\t    the :finally clause (if present), surrounding try conditionals\n\"\t    should be checked for a matching :catch.\n\"-------------------------------------------------------------------------------\n\nfunc T47_F()\n  Xpath 'a'\n  try\n    Xpath 'b'\n    try\n      Xpath 'c'\n      try\n        Xpath 'd'\n        throw \"x1\"\n        Xpath 'e'\n      catch /x1/\n        Xpath 'f'\n        try\n          Xpath 'g'\n          throw \"x2\"\n          Xpath 'h'\n        catch /x1/\n          Xpath 'i'\n        catch /x2/\n          Xpath 'j'\n          try\n            Xpath 'k'\n            throw \"x3\"\n            Xpath 'l'\n          catch /x1/\n            Xpath 'm'\n          catch /x2/\n            Xpath 'n'\n          finally\n            Xpath 'o'\n          endtry\n          Xpath 'p'\n        catch /x3/\n          Xpath 'q'\n        endtry\n        Xpath 'r'\n      catch /x1/\n        Xpath 's'\n      catch /x2/\n        Xpath 't'\n      catch /x3/\n        Xpath 'u'\n      finally\n        Xpath 'v'\n      endtry\n      Xpath 'w'\n    catch /x1/\n      Xpath 'x'\n    catch /x2/\n      Xpath 'y'\n    catch /x3/\n      Xpath 'z'\n    endtry\n    Xpath 'A'\n  catch /.*/\n    Xpath 'B'\n    call assert_report('Caught ' . v:exception . ' in ' . v:throwpoint)\n  endtry\n  Xpath 'C'\nendfunc\n\nfunc Test_throw_from_catch()\n  XpathINIT\n  call T47_F()\n  call assert_equal('abcdfgjkovzAC', g:Xpath)\nendfunc\n\n\n\"-------------------------------------------------------------------------------\n\" Test 48:  Throwing exceptions from a :finally clause\t\t\t    {{{1\n\"\n\"\t    When an exception is thrown from a :finally clause, it should not be\n\"\t    caught by a :catch of the same :try conditional.  Surrounding try\n\"\t    conditionals should be checked for a matching :catch.  A previously\n\"\t    thrown exception is discarded.\n\"-------------------------------------------------------------------------------\n\nfunc T48_F()\n  try\n\n    try\n      try\n        Xpath 'a'\n      catch /x1/\n        Xpath 'b'\n      finally\n        Xpath 'c'\n        throw \"x1\"\n        Xpath 'd'\n      endtry\n      Xpath 'e'\n    catch /x1/\n      Xpath 'f'\n    endtry\n    Xpath 'g'\n\n    try\n      try\n        Xpath 'h'\n        throw \"x2\"\n        Xpath 'i'\n      catch /x2/\n        Xpath 'j'\n      catch /x3/\n        Xpath 'k'\n      finally\n        Xpath 'l'\n        throw \"x3\"\n        Xpath 'm'\n      endtry\n      Xpath 'n'\n    catch /x2/\n      Xpath 'o'\n    catch /x3/\n      Xpath 'p'\n    endtry\n    Xpath 'q'\n\n    try\n      try\n        try\n          Xpath 'r'\n          throw \"x4\"\n          Xpath 's'\n        catch /x5/\n          Xpath 't'\n        finally\n          Xpath 'u'\n          throw \"x5\"\t\" discards 'x4'\n          Xpath 'v'\n        endtry\n        Xpath 'w'\n      catch /x4/\n        Xpath 'x'\n      finally\n        Xpath 'y'\n      endtry\n      Xpath 'z'\n    catch /x5/\n      Xpath 'A'\n    endtry\n    Xpath 'B'\n\n  catch /.*/\n    Xpath 'C'\n    call assert_report('Caught ' . v:exception . ' in ' . v:throwpoint)\n  endtry\n  Xpath 'D'\nendfunc\n\nfunc Test_throw_from_finally()\n  XpathINIT\n  call T48_F()\n  call assert_equal('acfghjlpqruyABD', g:Xpath)\nendfunc\n\n\n\"-------------------------------------------------------------------------------\n\" Test 51:  Throwing exceptions across :execute and user commands\t    {{{1\n\"\n\"\t    A :throw command may be executed under an \":execute\" or from\n\"\t    a user command.\n\"-------------------------------------------------------------------------------\n\nfunc T51_F()\n  command! -nargs=? THROW1    throw <args> | throw 1\n  command! -nargs=? THROW2    try | throw <args> | endtry | throw 2\n  command! -nargs=? THROW3    try | throw 3 | catch /3/ | throw <args> | endtry\n  command! -nargs=? THROW4    try | throw 4 | finally   | throw <args> | endtry\n\n  try\n\n    try\n      try\n        Xpath 'a'\n        THROW1 \"A\"\n      catch /A/\n        Xpath 'b'\n      endtry\n    catch /1/\n      Xpath 'c'\n    endtry\n\n    try\n      try\n        Xpath 'd'\n        THROW2 \"B\"\n      catch /B/\n        Xpath 'e'\n      endtry\n    catch /2/\n      Xpath 'f'\n    endtry\n\n    try\n      try\n        Xpath 'g'\n        THROW3 \"C\"\n      catch /C/\n        Xpath 'h'\n      endtry\n    catch /3/\n      Xpath 'i'\n    endtry\n\n    try\n      try\n        Xpath 'j'\n        THROW4 \"D\"\n      catch /D/\n        Xpath 'k'\n      endtry\n    catch /4/\n      Xpath 'l'\n    endtry\n\n    try\n      try\n        Xpath 'm'\n        execute 'throw \"E\" | throw 5'\n      catch /E/\n        Xpath 'n'\n      endtry\n    catch /5/\n      Xpath 'o'\n    endtry\n\n    try\n      try\n        Xpath 'p'\n        execute 'try | throw \"F\" | endtry | throw 6'\n      catch /F/\n        Xpath 'q'\n      endtry\n    catch /6/\n      Xpath 'r'\n    endtry\n\n    try\n      try\n        Xpath 's'\n        execute'try | throw 7 | catch /7/ | throw \"G\" | endtry'\n      catch /G/\n        Xpath 't'\n      endtry\n    catch /7/\n      Xpath 'u'\n    endtry\n\n    try\n      try\n        Xpath 'v'\n        execute 'try | throw 8 | finally   | throw \"H\" | endtry'\n      catch /H/\n        Xpath 'w'\n      endtry\n    catch /8/\n      Xpath 'x'\n    endtry\n\n  catch /.*/\n    Xpath 'y'\n    call assert_report('Caught ' . v:exception . ' in ' . v:throwpoint)\n  endtry\n\n  Xpath 'z'\n\n  delcommand THROW1\n  delcommand THROW2\n  delcommand THROW3\n  delcommand THROW4\nendfunc\n\nfunc Test_throw_across_commands()\n  XpathINIT\n  call T51_F()\n  call assert_equal('abdeghjkmnpqstvwz', g:Xpath)\nendfunc\n\n\n\n\"-------------------------------------------------------------------------------\n\" Test 69:  :throw across :if, :elseif, :while\t\t\t\t    {{{1\n\"\n\"\t    On an :if, :elseif, or :while command, an exception might be thrown\n\"\t    during evaluation of the expression to test.  The exception can be\n\"\t    caught by the script.\n\"-------------------------------------------------------------------------------\n\nfunc T69_throw(x)\n  Xpath 'x'\n  throw a:x\nendfunc\n\nfunc Test_throw_ifelsewhile()\n  XpathINIT\n\n  try\n    try\n      Xpath 'a'\n      if 111 == T69_throw(\"if\") + 111\n        Xpath 'b'\n      else\n        Xpath 'c'\n      endif\n      Xpath 'd'\n    catch /^if$/\n      Xpath 'e'\n    catch /.*/\n      Xpath 'f'\n      call assert_report(\"if: \" . v:exception . \" in \" . v:throwpoint)\n    endtry\n\n    try\n      Xpath 'g'\n      if v:false\n        Xpath 'h'\n      elseif 222 == T69_throw(\"elseif\") + 222\n        Xpath 'i'\n      else\n        Xpath 'j'\n      endif\n      Xpath 'k'\n    catch /^elseif$/\n      Xpath 'l'\n    catch /.*/\n      Xpath 'm'\n      call assert_report(\"elseif: \" . v:exception . \" in \" . v:throwpoint)\n    endtry\n\n    try\n      Xpath 'n'\n      while 333 == T69_throw(\"while\") + 333\n        Xpath 'o'\n        break\n      endwhile\n      Xpath 'p'\n    catch /^while$/\n      Xpath 'q'\n    catch /.*/\n      Xpath 'r'\n      call assert_report(\"while: \" .. v:exception .. \" in \" .. v:throwpoint)\n    endtry\n  catch /^0$/\t    \" default return value\n    Xpath 's'\n    call assert_report(v:throwpoint)\n  catch /.*/\n    call assert_report(v:exception .. \" in \" .. v:throwpoint)\n    Xpath 't'\n  endtry\n\n  call assert_equal('axegxlnxq', g:Xpath)\nendfunc\n\n\n\"-------------------------------------------------------------------------------\n\" Test 70:  :throw across :return or :throw\t\t\t\t    {{{1\n\"\n\"\t    On a :return or :throw command, an exception might be thrown during\n\"\t    evaluation of the expression to return or throw, respectively.  The\n\"\t    exception can be caught by the script.\n\"-------------------------------------------------------------------------------\n\nlet T70_taken = \"\"\n\nfunc T70_throw(x, n)\n    let g:T70_taken = g:T70_taken . \"T\" . a:n\n    throw a:x\nendfunc\n\nfunc T70_F(x, y, n)\n    let g:T70_taken = g:T70_taken . \"F\" . a:n\n    return a:x + T70_throw(a:y, a:n)\nendfunc\n\nfunc T70_G(x, y, n)\n    let g:T70_taken = g:T70_taken . \"G\" . a:n\n    throw a:x . T70_throw(a:y, a:n)\n    return a:x\nendfunc\n\nfunc Test_throwreturn()\n  XpathINIT\n\n  try\n    try\n      Xpath 'a'\n      call T70_F(4711, \"return\", 1)\n      Xpath 'b'\n    catch /^return$/\n      Xpath 'c'\n    catch /.*/\n      Xpath 'd'\n      call assert_report(\"return: \" .. v:exception .. \" in \" .. v:throwpoint)\n    endtry\n\n    try\n      Xpath 'e'\n      let var = T70_F(4712, \"return-var\", 2)\n      Xpath 'f'\n    catch /^return-var$/\n      Xpath 'g'\n    catch /.*/\n      Xpath 'h'\n      call assert_report(\"return-var: \" . v:exception . \" in \" . v:throwpoint)\n    finally\n      unlet! var\n    endtry\n\n    try\n      Xpath 'i'\n      throw \"except1\" . T70_throw(\"throw1\", 3)\n      Xpath 'j'\n    catch /^except1/\n      Xpath 'k'\n    catch /^throw1$/\n      Xpath 'l'\n    catch /.*/\n      Xpath 'm'\n      call assert_report(\"throw1: \" .. v:exception .. \" in \" .. v:throwpoint)\n    endtry\n\n    try\n      Xpath 'n'\n      call T70_G(\"except2\", \"throw2\", 4)\n      Xpath 'o'\n    catch /^except2/\n      Xpath 'p'\n    catch /^throw2$/\n      Xpath 'q'\n    catch /.*/\n      Xpath 'r'\n      call assert_report(\"throw2: \" .. v:exception .. \" in \" .. v:throwpoint)\n    endtry\n\n    try\n      Xpath 's'\n      let var = T70_G(\"except3\", \"throw3\", 5)\n      Xpath 't'\n    catch /^except3/\n      Xpath 'u'\n    catch /^throw3$/\n      Xpath 'v'\n    catch /.*/\n      Xpath 'w'\n      call assert_report(\"throw3: \" .. v:exception .. \" in \" .. v:throwpoint)\n    finally\n      unlet! var\n    endtry\n\n    call assert_equal('F1T1F2T2T3G4T4G5T5', g:T70_taken)\n    Xpath 'x'\n  catch /^0$/\t    \" default return value\n    Xpath 'y'\n    call assert_report(v:throwpoint)\n  catch /.*/\n    Xpath 'z'\n    call assert_report('Caught' .. v:exception .. ' in ' .. v:throwpoint)\n  endtry\n\n  call assert_equal('acegilnqsvx', g:Xpath)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 71:  :throw across :echo variants and :execute\t\t\t    {{{1\n\"\n\"\t    On an :echo, :echon, :echomsg, :echoerr, or :execute command, an\n\"\t    exception might be thrown during evaluation of the arguments to\n\"\t    be displayed or executed as a command, respectively.  Any following\n\"\t    arguments are not evaluated, then.  The exception can be caught by\n\"\t    the script.\n\"-------------------------------------------------------------------------------\n\nlet T71_taken = \"\"\n\nfunc T71_throw(x, n)\n    let g:T71_taken = g:T71_taken . \"T\" . a:n\n    throw a:x\nendfunc\n\nfunc T71_F(n)\n    let g:T71_taken = g:T71_taken . \"F\" . a:n\n    return \"F\" . a:n\nendfunc\n\nfunc Test_throw_echo()\n  XpathINIT\n\n  try\n    try\n      Xpath 'a'\n      echo 'echo ' . T71_throw(\"echo-except\", 1) . T71_F(1)\n      Xpath 'b'\n    catch /^echo-except$/\n      Xpath 'c'\n    catch /.*/\n      Xpath 'd'\n      call assert_report(\"echo: \" .. v:exception .. \" in \" .. v:throwpoint)\n    endtry\n\n    try\n      Xpath 'e'\n      echon \"echon \" . T71_throw(\"echon-except\", 2) . T71_F(2)\n      Xpath 'f'\n    catch /^echon-except$/\n      Xpath 'g'\n    catch /.*/\n      Xpath 'h'\n      call assert_report('echon: ' . v:exception . ' in ' . v:throwpoint)\n    endtry\n\n    try\n      Xpath 'i'\n      echomsg \"echomsg \" . T71_throw(\"echomsg-except\", 3) . T71_F(3)\n      Xpath 'j'\n    catch /^echomsg-except$/\n      Xpath 'k'\n    catch /.*/\n      Xpath 'l'\n      call assert_report('echomsg: ' . v:exception . ' in ' . v:throwpoint)\n    endtry\n\n    try\n      Xpath 'm'\n      echoerr \"echoerr \" . T71_throw(\"echoerr-except\", 4) . T71_F(4)\n      Xpath 'n'\n    catch /^echoerr-except$/\n      Xpath 'o'\n    catch /Vim/\n      Xpath 'p'\n    catch /echoerr/\n      Xpath 'q'\n    catch /.*/\n      Xpath 'r'\n      call assert_report('echoerr: ' . v:exception . ' in ' . v:throwpoint)\n    endtry\n\n    try\n      Xpath 's'\n      execute \"echo 'execute \" . T71_throw(\"execute-except\", 5) . T71_F(5) \"'\"\n      Xpath 't'\n    catch /^execute-except$/\n      Xpath 'u'\n    catch /.*/\n      Xpath 'v'\n      call assert_report('execute: ' . v:exception . ' in ' . v:throwpoint)\n    endtry\n\n    call assert_equal('T1T2T3T4T5', g:T71_taken)\n    Xpath 'w'\n  catch /^0$/\t    \" default return value\n    Xpath 'x'\n    call assert_report(v:throwpoint)\n  catch /.*/\n    Xpath 'y'\n    call assert_report('Caught ' . v:exception . ' in ' . v:throwpoint)\n  endtry\n\n  call assert_equal('acegikmosuw', g:Xpath)\nendfunc\n\n\n\"-------------------------------------------------------------------------------\n\" Test 72:  :throw across :let or :unlet\t\t\t\t    {{{1\n\"\n\"\t    On a :let command, an exception might be thrown during evaluation\n\"\t    of the expression to assign.  On an :let or :unlet command, the\n\"\t    evaluation of the name of the variable to be assigned or list or\n\"\t    deleted, respectively, may throw an exception.  Any following\n\"\t    arguments are not evaluated, then.  The exception can be caught by\n\"\t    the script.\n\"-------------------------------------------------------------------------------\n\nlet throwcount = 0\n\nfunc T72_throw(x)\n  let g:throwcount = g:throwcount + 1\n  throw a:x\nendfunc\n\nlet T72_addpath = ''\n\nfunc T72_addpath(p)\n  let g:T72_addpath = g:T72_addpath . a:p\nendfunc\n\nfunc Test_throw_let()\n  XpathINIT\n\n  try\n    try\n      let $VAR = 'old_value'\n      Xpath 'a'\n      let $VAR = 'let(' . T72_throw('var') . ')'\n      Xpath 'b'\n    catch /^var$/\n      Xpath 'c'\n    finally\n      call assert_equal('old_value', $VAR)\n    endtry\n\n    try\n      let @a = 'old_value'\n      Xpath 'd'\n      let @a = 'let(' . T72_throw('reg') . ')'\n      Xpath 'e'\n    catch /^reg$/\n      try\n        Xpath 'f'\n        let @A = 'let(' . T72_throw('REG') . ')'\n        Xpath 'g'\n      catch /^REG$/\n        Xpath 'h'\n      endtry\n    finally\n      call assert_equal('old_value', @a)\n      call assert_equal('old_value', @A)\n    endtry\n\n    try\n      let saved_gpath = &g:path\n      let saved_lpath = &l:path\n      Xpath 'i'\n      let &path = 'let(' . T72_throw('opt') . ')'\n      Xpath 'j'\n    catch /^opt$/\n      try\n        Xpath 'k'\n        let &g:path = 'let(' . T72_throw('gopt') . ')'\n        Xpath 'l'\n      catch /^gopt$/\n        try\n          Xpath 'm'\n          let &l:path = 'let(' . T72_throw('lopt') . ')'\n          Xpath 'n'\n        catch /^lopt$/\n          Xpath 'o'\n        endtry\n      endtry\n    finally\n      call assert_equal(saved_gpath, &g:path)\n      call assert_equal(saved_lpath, &l:path)\n      let &g:path = saved_gpath\n      let &l:path = saved_lpath\n    endtry\n\n    unlet! var1 var2 var3\n\n    try\n      Xpath 'p'\n      let var1 = 'let(' . T72_throw('var1') . ')'\n      Xpath 'q'\n    catch /^var1$/\n      Xpath 'r'\n    finally\n      call assert_true(!exists('var1'))\n    endtry\n\n    try\n      let var2 = 'old_value'\n      Xpath 's'\n      let var2 = 'let(' . T72_throw('var2'). ')'\n      Xpath 't'\n    catch /^var2$/\n      Xpath 'u'\n    finally\n      call assert_equal('old_value', var2)\n    endtry\n\n    try\n      Xpath 'v'\n      let var{T72_throw('var3')} = 4711\n      Xpath 'w'\n    catch /^var3$/\n      Xpath 'x'\n    endtry\n\n    try\n      call T72_addpath('T1')\n      let var{T72_throw('var4')} var{T72_addpath('T2')} | call T72_addpath('T3')\n      call T72_addpath('T4')\n    catch /^var4$/\n      call T72_addpath('T5')\n    endtry\n\n    try\n      call T72_addpath('T6')\n      unlet var{T72_throw('var5')} var{T72_addpath('T7')}\n            \\ | call T72_addpath('T8')\n      call T72_addpath('T9')\n    catch /^var5$/\n      call T72_addpath('T10')\n    endtry\n\n    call assert_equal('T1T5T6T10', g:T72_addpath)\n    call assert_equal(11, g:throwcount)\n  catch /.*/\n    call assert_report('Caught ' . v:exception . ' in ' . v:throwpoint)\n  endtry\n\n  call assert_equal('acdfhikmoprsuvx', g:Xpath)\nendfunc\n\n\n\"-------------------------------------------------------------------------------\n\" Test 73:  :throw across :function, :delfunction\t\t\t    {{{1\n\"\n\"\t    The :function and :delfunction commands may cause an expression\n\"\t    specified in braces to be evaluated.  During evaluation, an\n\"\t    exception might be thrown.  The exception can be caught by the\n\"\t    script.\n\"-------------------------------------------------------------------------------\n\nlet T73_taken = ''\n\nfunc T73_throw(x, n)\n  let g:T73_taken = g:T73_taken . 'T' . a:n\n  throw a:x\nendfunc\n\nfunc T73_expr(x, n)\n  let g:T73_taken = g:T73_taken . 'E' . a:n\n  if a:n % 2 == 0\n    call T73_throw(a:x, a:n)\n  endif\n  return 2 - a:n % 2\nendfunc\n\nfunc Test_throw_func()\n  XpathINIT\n\n  try\n    try\n      \" Define function.\n      Xpath 'a'\n      function! F0()\n      endfunction\n      Xpath 'b'\n      function! F{T73_expr('function-def-ok', 1)}()\n      endfunction\n      Xpath 'c'\n      function! F{T73_expr('function-def', 2)}()\n      endfunction\n      Xpath 'd'\n    catch /^function-def-ok$/\n      Xpath 'e'\n    catch /^function-def$/\n      Xpath 'f'\n    catch /.*/\n      call assert_report('def: ' . v:exception . ' in ' . v:throwpoint)\n    endtry\n\n    try\n      \" List function.\n      Xpath 'g'\n      function F0\n      Xpath 'h'\n      function F{T73_expr('function-lst-ok', 3)}\n      Xpath 'i'\n      function F{T73_expr('function-lst', 4)}\n      Xpath 'j'\n    catch /^function-lst-ok$/\n      Xpath 'k'\n    catch /^function-lst$/\n      Xpath 'l'\n    catch /.*/\n      call assert_report('lst: ' . v:exception . ' in ' . v:throwpoint)\n    endtry\n\n    try\n      \" Delete function\n      Xpath 'm'\n      delfunction F0\n      Xpath 'n'\n      delfunction F{T73_expr('function-del-ok', 5)}\n      Xpath 'o'\n      delfunction F{T73_expr('function-del', 6)}\n      Xpath 'p'\n    catch /^function-del-ok$/\n      Xpath 'q'\n    catch /^function-del$/\n      Xpath 'r'\n    catch /.*/\n      call assert_report('del: ' . v:exception . ' in ' . v:throwpoint)\n    endtry\n    call assert_equal('E1E2T2E3E4T4E5E6T6', g:T73_taken)\n  catch /.*/\n    call assert_report('Caught ' . v:exception . ' in ' . v:throwpoint)\n  endtry\n\n  call assert_equal('abcfghilmnor', g:Xpath)\nendfunc\n\n\n\"-------------------------------------------------------------------------------\n\" Test 74:  :throw across builtin functions and commands\t\t    {{{1\n\"\n\"\t    Some functions like exists(), searchpair() take expression\n\"\t    arguments, other functions or commands like substitute() or\n\"\t    :substitute cause an expression (specified in the regular\n\"\t    expression) to be evaluated.  During evaluation an exception\n\"\t    might be thrown.  The exception can be caught by the script.\n\"-------------------------------------------------------------------------------\n\nlet T74_taken = \"\"\n\nfunc T74_throw(x, n)\n  let g:T74_taken = g:T74_taken . \"T\" . a:n\n  throw a:x\nendfunc\n\nfunc T74_expr(x, n)\n  let g:T74_taken = g:T74_taken . \"E\" . a:n\n  call T74_throw(a:x . a:n, a:n)\n  return \"EXPR\"\nendfunc\n\nfunc T74_skip(x, n)\n  let g:T74_taken = g:T74_taken . \"S\" . a:n . \"(\" . line(\".\")\n  let theline = getline(\".\")\n  if theline =~ \"skip\"\n    let g:T74_taken = g:T74_taken . \"s)\"\n    return 1\n  elseif theline =~ \"throw\"\n    let g:T74_taken = g:T74_taken . \"t)\"\n    call T74_throw(a:x . a:n, a:n)\n  else\n    let g:T74_taken = g:T74_taken . \")\"\n    return 0\n  endif\nendfunc\n\nfunc T74_subst(x, n)\n  let g:T74_taken = g:T74_taken . \"U\" . a:n . \"(\" . line(\".\")\n  let theline = getline(\".\")\n  if theline =~ \"not\"       \" T74_subst() should not be called for this line\n    let g:T74_taken = g:T74_taken . \"n)\"\n    call T74_throw(a:x . a:n, a:n)\n  elseif theline =~ \"throw\"\n    let g:T74_taken = g:T74_taken . \"t)\"\n    call T74_throw(a:x . a:n, a:n)\n  else\n    let g:T74_taken = g:T74_taken . \")\"\n    return \"replaced\"\n  endif\nendfunc\n\nfunc Test_throw_builtin_func()\n  XpathINIT\n\n  try\n    try\n      Xpath 'a'\n      let result = exists('*{T74_expr(\"exists\", 1)}')\n      Xpath 'b'\n    catch /^exists1$/\n      Xpath 'c'\n      try\n        let result = exists('{T74_expr(\"exists\", 2)}')\n        Xpath 'd'\n      catch /^exists2$/\n        Xpath 'e'\n      catch /.*/\n        call assert_report('exists2: ' . v:exception . ' in ' . v:throwpoint)\n      endtry\n    catch /.*/\n      call assert_report('exists1: ' . v:exception . ' in ' . v:throwpoint)\n    endtry\n\n    try\n      let file = tempname()\n      exec \"edit\" file\n      call append(0, [\n            \\ 'begin',\n            \\ 'xx',\n            \\ 'middle 3',\n            \\ 'xx',\n            \\ 'middle 5 skip',\n            \\ 'xx',\n            \\ 'middle 7 throw',\n            \\ 'xx',\n            \\ 'end'])\n      normal! gg\n      Xpath 'f'\n      let result = searchpair(\"begin\", \"middle\", \"end\", '',\n            \\ 'T74_skip(\"searchpair\", 3)')\n      Xpath 'g'\n      let result = searchpair(\"begin\", \"middle\", \"end\", '',\n            \\ 'T74_skip(\"searchpair\", 4)')\n      Xpath 'h'\n      let result = searchpair(\"begin\", \"middle\", \"end\", '',\n            \\ 'T74_skip(\"searchpair\", 5)')\n      Xpath 'i'\n    catch /^searchpair[35]$/\n      Xpath 'j'\n    catch /^searchpair4$/\n      Xpath 'k'\n    catch /.*/\n      call assert_report('searchpair: ' . v:exception . ' in ' . v:throwpoint)\n    finally\n      bwipeout!\n      call delete(file)\n    endtry\n\n    try\n      let file = tempname()\n      exec \"edit\" file\n      call append(0, [\n            \\ 'subst 1',\n            \\ 'subst 2',\n            \\ 'not',\n            \\ 'subst 4',\n            \\ 'subst throw',\n            \\ 'subst 6'])\n      normal! gg\n      Xpath 'l'\n      1,2substitute/subst/\\=T74_subst(\"substitute\", 6)/\n      try\n        Xpath 'm'\n        try\n          let v:errmsg = \"\"\n          3substitute/subst/\\=T74_subst(\"substitute\", 7)/\n        finally\n          if v:errmsg != \"\"\n            \" If exceptions are not thrown on errors, fake the error\n            \" exception in order to get the same execution path.\n            throw \"faked Vim(substitute)\"\n          endif\n        endtry\n      catch /Vim(substitute)/\t    \" Pattern not found ('e' flag missing)\n        Xpath 'n'\n        3substitute/subst/\\=T74_subst(\"substitute\", 8)/e\n        Xpath 'o'\n      endtry\n      Xpath 'p'\n      4,6substitute/subst/\\=T74_subst(\"substitute\", 9)/\n      Xpath 'q'\n    catch /^substitute[678]/\n      Xpath 'r'\n    catch /^substitute9/\n      Xpath 's'\n    finally\n      bwipeout!\n      call delete(file)\n    endtry\n\n    try\n      Xpath 't'\n      let var = substitute(\"sub\", \"sub\", '\\=T74_throw(\"substitute()y\", 10)', '')\n      Xpath 'u'\n    catch /substitute()y/\n      Xpath 'v'\n    catch /.*/\n      call assert_report('substitute()y: ' . v:exception . ' in '\n            \\ . v:throwpoint)\n    endtry\n\n    try\n      Xpath 'w'\n      let var = substitute(\"not\", \"sub\", '\\=T74_throw(\"substitute()n\", 11)', '')\n      Xpath 'x'\n    catch /substitute()n/\n      Xpath 'y'\n    catch /.*/\n      call assert_report('substitute()n: ' . v:exception . ' in '\n            \\ . v:throwpoint)\n    endtry\n\n    call assert_equal('E1T1E2T2S3(3)S4(5s)S4(7t)T4U6(1)U6(2)U9(4)U9(5t)T9T10',\n          \\ g:T74_taken)\n\n  catch /.*/\n    call assert_report('Caught ' . v:exception . ' in ' . v:throwpoint)\n  endtry\n\n  call assert_equal('acefgklmnopstvwx', g:Xpath)\nendfunc\n\n\n\"-------------------------------------------------------------------------------\n\" Test 75:  Errors in builtin functions.\t\t\t\t    {{{1\n\"\n\"\t    On an error in a builtin function called inside a :try/:endtry\n\"\t    region, the evaluation of the expression calling that function and\n\"\t    the command containing that expression are abandoned.  The error can\n\"\t    be caught as an exception.\n\"\n\"\t    A simple :call of the builtin function is a trivial case.  If the\n\"\t    builtin function is called in the argument list of another function,\n\"\t    no further arguments are evaluated, and the other function is not\n\"\t    executed.  If the builtin function is called from the argument of\n\"\t    a :return command, the :return command is not executed.  If the\n\"\t    builtin function is called from the argument of a :throw command,\n\"\t    the :throw command is not executed.  The evaluation of the\n\"\t    expression calling the builtin function is abandoned.\n\"-------------------------------------------------------------------------------\n\nfunc T75_F1(arg1)\n  Xpath 'a'\nendfunc\n\nfunc T75_F2(arg1, arg2)\n  Xpath 'b'\nendfunc\n\nfunc T75_G()\n  Xpath 'c'\nendfunc\n\nfunc T75_H()\n  Xpath 'd'\nendfunc\n\nfunc T75_R()\n  while 1\n    try\n      let caught = 0\n      let v:errmsg = \"\"\n      Xpath 'e'\n      return append(1, \"s\")\n    catch /E21/\n      let caught = 1\n    catch /.*/\n      Xpath 'f'\n    finally\n      Xpath 'g'\n      if caught || $VIMNOERRTHROW && v:errmsg =~ 'E21'\n        Xpath 'h'\n      endif\n      break\t\t\" discard error for $VIMNOERRTHROW\n    endtry\n  endwhile\n  Xpath 'i'\nendfunc\n\nfunc Test_builtin_func_error()\n  XpathINIT\n\n  try\n    set noma\t\" let append() fail with \"E21\"\n\n    while 1\n      try\n        let caught = 0\n        let v:errmsg = \"\"\n        Xpath 'j'\n        call append(1, \"s\")\n      catch /E21/\n        let caught = 1\n      catch /.*/\n        Xpath 'k'\n      finally\n        Xpath 'l'\n        if caught || $VIMNOERRTHROW && v:errmsg =~ 'E21'\n          Xpath 'm'\n        endif\n        break\t\t\" discard error for $VIMNOERRTHROW\n      endtry\n    endwhile\n\n    while 1\n      try\n        let caught = 0\n        let v:errmsg = \"\"\n        Xpath 'n'\n        call T75_F1('x' . append(1, \"s\"))\n      catch /E21/\n        let caught = 1\n      catch /.*/\n        Xpath 'o'\n      finally\n        Xpath 'p'\n        if caught || $VIMNOERRTHROW && v:errmsg =~ 'E21'\n          Xpath 'q'\n        endif\n        break\t\t\" discard error for $VIMNOERRTHROW\n      endtry\n    endwhile\n\n    while 1\n      try\n        let caught = 0\n        let v:errmsg = \"\"\n        Xpath 'r'\n        call T75_F2('x' . append(1, \"s\"), T75_G())\n      catch /E21/\n        let caught = 1\n      catch /.*/\n        Xpath 's'\n      finally\n        Xpath 't'\n        if caught || $VIMNOERRTHROW && v:errmsg =~ 'E21'\n          Xpath 'u'\n        endif\n        break\t\t\" discard error for $VIMNOERRTHROW\n      endtry\n    endwhile\n\n    call T75_R()\n\n    while 1\n      try\n        let caught = 0\n        let v:errmsg = \"\"\n        Xpath 'v'\n        throw \"T\" . append(1, \"s\")\n      catch /E21/\n        let caught = 1\n      catch /^T.*/\n        Xpath 'w'\n      catch /.*/\n        Xpath 'x'\n      finally\n        Xpath 'y'\n        if caught || $VIMNOERRTHROW && v:errmsg =~ 'E21'\n          Xpath 'z'\n        endif\n        break\t\t\" discard error for $VIMNOERRTHROW\n      endtry\n    endwhile\n\n    while 1\n      try\n        let caught = 0\n        let v:errmsg = \"\"\n        Xpath 'A'\n        let x = \"a\"\n        let x = x . \"b\" . append(1, \"s\") . T75_H()\n      catch /E21/\n        let caught = 1\n      catch /.*/\n        Xpath 'B'\n      finally\n        Xpath 'C'\n        if caught || $VIMNOERRTHROW && v:errmsg =~ 'E21'\n          Xpath 'D'\n        endif\n        call assert_equal('a', x)\n        break\t\t\" discard error for $VIMNOERRTHROW\n      endtry\n    endwhile\n  catch /.*/\n    call assert_report('Caught ' . v:exception . ' in ' . v:throwpoint)\n  finally\n    set ma&\n  endtry\n\n  call assert_equal('jlmnpqrtueghivyzACD', g:Xpath)\nendfunc\n\nfunc Test_reload_in_try_catch()\n  call writefile(['x'], 'Xreload')\n  set autoread\n  edit Xreload\n  tabnew\n  call writefile(['xx'], 'Xreload')\n  augroup ReLoad\n    au FileReadPost Xreload let x = doesnotexist\n    au BufReadPost Xreload let x = doesnotexist\n  augroup END\n  try\n    edit Xreload\n  catch\n  endtry\n  tabnew\n\n  tabclose\n  tabclose\n  autocmd! ReLoad\n  set noautoread\n  bwipe! Xreload\n  call delete('Xreload')\nendfunc\n\n\" Test for errors with :catch, :throw, :finally                            {{{1\nfunc Test_try_catch_errors()\n  call assert_fails('throw |', 'E471:')\n  call assert_fails(\"throw \\n \", 'E471:')\n  call assert_fails('catch abc', 'E654:')\n  call assert_fails('try | let i = 1| finally | catch | endtry', 'E604:')\n  call assert_fails('finally', 'E606:')\n  call assert_fails('try | finally | finally | endtry', 'E607:')\n  call assert_fails('try | for i in range(5) | endif | endtry', 'E580:')\n  call assert_fails('try | while v:true | endtry', 'E170:')\n  call assert_fails('try | if v:true | endtry', 'E171:')\nendfunc\n\n\" Test for verbose messages with :try :catch, and :finally                 {{{1\nfunc Test_try_catch_verbose()\n  \" This test works only when the language is English\n  CheckEnglish\n\n  set verbose=14\n\n  \" Test for verbose messages displayed when an exception is caught\n  redir => msg\n  try\n    echo i\n  catch /E121:/\n  finally\n  endtry\n  redir END\n  let expected = [\n        \\ 'Exception thrown: Vim(echo):E121: Undefined variable: i', '',\n        \\ 'Exception caught: Vim(echo):E121: Undefined variable: i', '',\n        \\ 'Exception finished: Vim(echo):E121: Undefined variable: i']\n  call assert_equal(expected, split(msg, \"\\n\"))\n\n  \" Test for verbose messages displayed when an exception is discarded\n  redir => msg\n  try\n    try\n      throw 'abc'\n    finally\n      throw 'xyz'\n    endtry\n  catch\n  endtry\n  redir END\n  let expected = [\n        \\ 'Exception thrown: abc', '',\n        \\ 'Exception made pending: abc', '',\n        \\ 'Exception thrown: xyz', '',\n        \\ 'Exception discarded: abc', '',\n        \\ 'Exception caught: xyz', '',\n        \\ 'Exception finished: xyz']\n  call assert_equal(expected, split(msg, \"\\n\"))\n\n  \" Test for messages displayed when :throw is resumed after :finally\n  redir => msg\n  try\n    try\n      throw 'abc'\n    finally\n    endtry\n  catch\n  endtry\n  redir END\n  let expected = [\n        \\ 'Exception thrown: abc', '',\n        \\ 'Exception made pending: abc', '',\n        \\ 'Exception resumed: abc', '',\n        \\ 'Exception caught: abc', '',\n        \\ 'Exception finished: abc']\n  call assert_equal(expected, split(msg, \"\\n\"))\n\n  \" Test for messages displayed when :break is resumed after :finally\n  redir => msg\n  for i in range(1)\n    try\n      break\n    finally\n    endtry\n  endfor\n  redir END\n  let expected = [':break made pending', '', ':break resumed']\n  call assert_equal(expected, split(msg, \"\\n\"))\n\n  \" Test for messages displayed when :continue is resumed after :finally\n  redir => msg\n  for i in range(1)\n    try\n      continue\n    finally\n    endtry\n  endfor\n  redir END\n  let expected = [':continue made pending', '', ':continue resumed']\n  call assert_equal(expected, split(msg, \"\\n\"))\n\n  \" Test for messages displayed when :return is resumed after :finally\n  func Xtest()\n    try\n      return 'vim'\n    finally\n    endtry\n  endfunc\n  redir => msg\n  call Xtest()\n  redir END\n  let expected = [\n        \\ 'calling Xtest()', '',\n        \\ ':return vim made pending', '',\n        \\ ':return vim resumed', '',\n        \\ 'Xtest returning ''vim''', '',\n        \\ 'continuing in Test_try_catch_verbose']\n  call assert_equal(expected, split(msg, \"\\n\"))\n  delfunc Xtest\n\n  \" Test for messages displayed when :finish is resumed after :finally\n  call writefile(['try', 'finish', 'finally', 'endtry'], 'Xscript')\n  redir => msg\n  source Xscript\n  redir END\n  let expected = [\n        \\ ':finish made pending', '',\n        \\ ':finish resumed', '',\n        \\ 'finished sourcing Xscript',\n        \\ 'continuing in Test_try_catch_verbose']\n  call assert_equal(expected, split(msg, \"\\n\")[1:])\n  call delete('Xscript')\n\n  \" Test for messages displayed when a pending :continue is discarded by an\n  \" exception in a finally handler\n  redir => msg\n  try\n    for i in range(1)\n      try\n        continue\n      finally\n        throw 'abc'\n      endtry\n    endfor\n  catch\n  endtry\n  redir END\n  let expected = [\n        \\ ':continue made pending', '',\n        \\ 'Exception thrown: abc', '',\n        \\ ':continue discarded', '',\n        \\ 'Exception caught: abc', '',\n        \\ 'Exception finished: abc']\n  call assert_equal(expected, split(msg, \"\\n\"))\n\n  set verbose&\nendfunc\n\n\" Test for throwing an exception from a BufEnter autocmd                   {{{1\nfunc Test_BufEnter_exception()\n  augroup bufenter_exception\n    au!\n    autocmd BufEnter Xfile1 throw 'abc'\n  augroup END\n\n  let caught_abc = 0\n  try\n    sp Xfile1\n  catch /^abc/\n    let caught_abc = 1\n  endtry\n  call assert_equal(1, caught_abc)\n  call assert_equal(1, winnr('$'))\n\n  augroup bufenter_exception\n    au!\n  augroup END\n  augroup! bufenter_exception\n  %bwipe!\n\n  \" Test for recursively throwing exceptions in autocmds\n  augroup bufenter_exception\n    au!\n    autocmd BufEnter Xfile1 throw 'bufenter'\n    autocmd BufLeave Xfile1 throw 'bufleave'\n  augroup END\n\n  let ex_count = 0\n  try\n    try\n      sp Xfile1\n    catch /^bufenter/\n      let ex_count += 1\n    endtry\n  catch /^bufleave/\n      let ex_count += 10\n  endtry\n  call assert_equal(10, ex_count)\n  call assert_equal(2, winnr('$'))\n\n  augroup bufenter_exception\n    au!\n  augroup END\n  augroup! bufenter_exception\n  %bwipe!\nendfunc\n\n\" Test for using try/catch in a user command with a failing expression    {{{1\nfunc Test_user_command_try_catch()\n  let lines =<< trim END\n      function s:throw() abort\n        throw 'error'\n      endfunction\n\n      command! Execute\n      \\   try\n      \\ |   let s:x = s:throw()\n      \\ | catch\n      \\ |   let g:caught = 'caught'\n      \\ | endtry\n\n      let g:caught = 'no'\n      Execute\n      call assert_equal('caught', g:caught)\n  END\n  call writefile(lines, 'XtestTryCatch')\n  source XtestTryCatch\n\n  call delete('XtestTryCatch')\n  unlet g:caught\nendfunc\n\n\" Test for using throw in a called function with following error    {{{1\nfunc Test_user_command_throw_in_function_call()\n  let lines =<< trim END\n      function s:get_dict() abort\n        throw 'my_error'\n      endfunction\n\n      try\n        call s:get_dict().foo()\n      catch /my_error/\n        let caught = 'yes'\n      catch\n        let caught = v:exception\n      endtry\n      call assert_equal('yes', caught)\n  END\n  call writefile(lines, 'XtestThrow')\n  source XtestThrow\n\n  call delete('XtestThrow')\n  unlet g:caught\nendfunc\n\n\" Test that after reporting an uncaught exception there is no error for a\n\" missing :endif\nfunc Test_after_exception_no_endif_error()\n  function Throw()\n    throw \"Failure\"\n  endfunction\n\n  function Foo()\n    if 1\n      call Throw()\n    endif\n  endfunction\n  call assert_fails('call Foo()', ['E605:', 'E605:'])\n  delfunc Throw\n  delfunc Foo\nendfunc\n\n\" Test for using throw in a called function with following endtry    {{{1\nfunc Test_user_command_function_call_with_endtry()\n  let lines =<< trim END\n      funct s:throw(msg) abort\n        throw a:msg\n      endfunc\n      func s:main() abort\n        try\n          try\n            throw 'err1'\n          catch\n            call s:throw('err2') | endtry\n          catch\n            let s:caught = 'yes'\n        endtry\n      endfunc\n\n      call s:main()\n      call assert_equal('yes', s:caught)\n  END\n  call writefile(lines, 'XtestThrow')\n  source XtestThrow\n\n  call delete('XtestThrow')\nendfunc\n\nfunc ThisWillFail()\n\nendfunc\n\n\" This was crashing prior to the fix in 8.2.3478.\nfunc Test_error_in_catch_and_finally()\n  let lines =<< trim END\n    try\n      echo x\n    catch\n      for l in []\n    finally\n  END\n  call writefile(lines, 'XtestCatchAndFinally')\n  try\n    source XtestCatchAndFinally\n  catch /E600:/\n  endtry\n\n  call delete('XtestCatchAndFinally')\nendfunc\n\n\" This was causing an illegal memory access\nfunc Test_leave_block_in_endtry_not_called()\n  let lines =<< trim END\n      vim9script\n      try #\n      for x in []\n      if\n      endwhile\n      if\n      endtry\n  END\n  call writefile(lines, 'XtestEndtry')\n  try\n    source XtestEndtry\n  catch /E171:/\n  endtry\n\n  call delete('XtestEndtry')\nendfunc\n\n\" Modeline\t\t\t\t\t\t\t\t    {{{1\n\" vim: ts=8 sw=2 sts=2 expandtab tw=80 fdm=marker\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n\t\"++builtin_terms\",\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n\t\"+file_in_path\",\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n\t\"+float\",\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n\t\"-footer\",\n\t// only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n\t\"+path_extra\",\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n\t\"+textobjects\",\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n\t\"+wildignore\",\n\t\"+wildmenu\",\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_BIG)\n    msg_puts(_(\"\\nBig version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#elif defined(FEAT_SMALL)\n    msg_puts(_(\"\\nSmall version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "fixing_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * ex_eval.c: functions for Ex command line for the +eval feature.\n */\n\n#include \"vim.h\"\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n\nstatic char\t*get_end_emsg(cstack_T *cstack);\n\n/*\n * Exception handling terms:\n *\n *\t:try\t\t\":try\" command\t\t\\\n *\t    ...\t\ttry block\t\t|\n *\t:catch RE\t\":catch\" command\t|\n *\t    ...\t\tcatch clause\t\t|- try conditional\n *\t:finally\t\":finally\" command\t|\n *\t    ...\t\tfinally clause\t\t|\n *\t:endtry\t\t\":endtry\" command\t/\n *\n * The try conditional may have any number of catch clauses and at most one\n * finally clause.  A \":throw\" command can be inside the try block, a catch\n * clause, the finally clause, or in a function called or script sourced from\n * there or even outside the try conditional.  Try conditionals may be nested.\n */\n\n/*\n * Configuration whether an exception is thrown on error or interrupt.  When\n * the preprocessor macros below evaluate to FALSE, an error (did_emsg) or\n * interrupt (got_int) under an active try conditional terminates the script\n * after the non-active finally clauses of all active try conditionals have been\n * executed.  Otherwise, errors and/or interrupts are converted into catchable\n * exceptions (did_throw additionally set), which terminate the script only if\n * not caught.  For user exceptions, only did_throw is set.  (Note: got_int can\n * be set asynchronously afterwards by a SIGINT, so did_throw && got_int is not\n * a reliant test that the exception currently being thrown is an interrupt\n * exception.  Similarly, did_emsg can be set afterwards on an error in an\n * (unskipped) conditional command inside an inactive conditional, so did_throw\n * && did_emsg is not a reliant test that the exception currently being thrown\n * is an error exception.)  -  The macros can be defined as expressions checking\n * for a variable that is allowed to be changed during execution of a script.\n */\n#if 0\n// Expressions used for testing during the development phase.\n# define THROW_ON_ERROR\t\t(!eval_to_number(\"$VIMNOERRTHROW\"))\n# define THROW_ON_INTERRUPT\t(!eval_to_number(\"$VIMNOINTTHROW\"))\n# define THROW_TEST\n#else\n// Values used for the Vim release.\n# define THROW_ON_ERROR\t\tTRUE\n# define THROW_ON_ERROR_TRUE\n# define THROW_ON_INTERRUPT\tTRUE\n# define THROW_ON_INTERRUPT_TRUE\n#endif\n\n/*\n * When several errors appear in a row, setting \"force_abort\" is delayed until\n * the failing command returned.  \"cause_abort\" is set to TRUE meanwhile, in\n * order to indicate that situation.  This is useful when \"force_abort\" was set\n * during execution of a function call from an expression: the aborting of the\n * expression evaluation is done without producing any error messages, but all\n * error messages on parsing errors during the expression evaluation are given\n * (even if a try conditional is active).\n */\nstatic int cause_abort = FALSE;\n\n/*\n * Return TRUE when immediately aborting on error, or when an interrupt\n * occurred or an exception was thrown but not caught.  Use for \":{range}call\"\n * to check whether an aborted function that does not handle a range itself\n * should be called again for the next line in the range.  Also used for\n * cancelling expression evaluation after a function call caused an immediate\n * abort.  Note that the first emsg() call temporarily resets \"force_abort\"\n * until the throw point for error messages has been reached.  That is, during\n * cancellation of an expression evaluation after an aborting function call or\n * due to a parsing error, aborting() always returns the same value.\n * \"got_int\" is also set by calling interrupt().\n */\n    int\naborting(void)\n{\n    return (did_emsg && force_abort) || got_int || did_throw;\n}\n\n/*\n * The value of \"force_abort\" is temporarily reset by the first emsg() call\n * during an expression evaluation, and \"cause_abort\" is used instead.  It might\n * be necessary to restore \"force_abort\" even before the throw point for the\n * error message has been reached.  update_force_abort() should be called then.\n */\n    void\nupdate_force_abort(void)\n{\n    if (cause_abort)\n\tforce_abort = TRUE;\n}\n\n/*\n * Return TRUE if a command with a subcommand resulting in \"retcode\" should\n * abort the script processing.  Can be used to suppress an autocommand after\n * execution of a failing subcommand as long as the error message has not been\n * displayed and actually caused the abortion.\n */\n    int\nshould_abort(int retcode)\n{\n    return ((retcode == FAIL && trylevel != 0 && !emsg_silent) || aborting());\n}\n\n/*\n * Return TRUE if a function with the \"abort\" flag should not be considered\n * ended on an error.  This means that parsing commands is continued in order\n * to find finally clauses to be executed, and that some errors in skipped\n * commands are still reported.\n */\n    int\naborted_in_try(void)\n{\n    // This function is only called after an error.  In this case, \"force_abort\"\n    // determines whether searching for finally clauses is necessary.\n    return force_abort;\n}\n\n/*\n * cause_errthrow(): Cause a throw of an error exception if appropriate.\n * Return TRUE if the error message should not be displayed by emsg().\n * Sets \"ignore\", if the emsg() call should be ignored completely.\n *\n * When several messages appear in the same command, the first is usually the\n * most specific one and used as the exception value.  The \"severe\" flag can be\n * set to TRUE, if a later but severer message should be used instead.\n */\n    int\ncause_errthrow(\n    char_u\t*mesg,\n    int\t\tsevere,\n    int\t\t*ignore)\n{\n    msglist_T\t*elem;\n    msglist_T\t**plist;\n\n    /*\n     * Do nothing when displaying the interrupt message or reporting an\n     * uncaught exception (which has already been discarded then) at the top\n     * level.  Also when no exception can be thrown.  The message will be\n     * displayed by emsg().\n     */\n    if (suppress_errthrow)\n\treturn FALSE;\n\n    /*\n     * If emsg() has not been called previously, temporarily reset\n     * \"force_abort\" until the throw point for error messages has been\n     * reached.  This ensures that aborting() returns the same value for all\n     * errors that appear in the same command.  This means particularly that\n     * for parsing errors during expression evaluation emsg() will be called\n     * multiply, even when the expression is evaluated from a finally clause\n     * that was activated due to an aborting error, interrupt, or exception.\n     */\n    if (!did_emsg)\n    {\n\tcause_abort = force_abort;\n\tforce_abort = FALSE;\n    }\n\n    /*\n     * If no try conditional is active and no exception is being thrown and\n     * there has not been an error in a try conditional or a throw so far, do\n     * nothing (for compatibility of non-EH scripts).  The message will then\n     * be displayed by emsg().  When \":silent!\" was used and we are not\n     * currently throwing an exception, do nothing.  The message text will\n     * then be stored to v:errmsg by emsg() without displaying it.\n     */\n    if (((trylevel == 0 && !cause_abort) || emsg_silent) && !did_throw)\n\treturn FALSE;\n\n    /*\n     * Ignore an interrupt message when inside a try conditional or when an\n     * exception is being thrown or when an error in a try conditional or\n     * throw has been detected previously.  This is important in order that an\n     * interrupt exception is catchable by the innermost try conditional and\n     * not replaced by an interrupt message error exception.\n     */\n    if (mesg == (char_u *)_(e_interrupted))\n    {\n\t*ignore = TRUE;\n\treturn TRUE;\n    }\n\n    /*\n     * Ensure that all commands in nested function calls and sourced files\n     * are aborted immediately.\n     */\n    cause_abort = TRUE;\n\n    /*\n     * When an exception is being thrown, some commands (like conditionals) are\n     * not skipped.  Errors in those commands may affect what of the subsequent\n     * commands are regarded part of catch and finally clauses.  Catching the\n     * exception would then cause execution of commands not intended by the\n     * user, who wouldn't even get aware of the problem.  Therefore, discard the\n     * exception currently being thrown to prevent it from being caught.  Just\n     * execute finally clauses and terminate.\n     */\n    if (did_throw)\n    {\n\t// When discarding an interrupt exception, reset got_int to prevent the\n\t// same interrupt being converted to an exception again and discarding\n\t// the error exception we are about to throw here.\n\tif (current_exception->type == ET_INTERRUPT)\n\t    got_int = FALSE;\n\tdiscard_current_exception();\n    }\n\n#ifdef THROW_TEST\n    if (!THROW_ON_ERROR)\n    {\n\t/*\n\t * Print error message immediately without searching for a matching\n\t * catch clause; just finally clauses are executed before the script\n\t * is terminated.\n\t */\n\treturn FALSE;\n    }\n    else\n#endif\n    {\n\t/*\n\t * Prepare the throw of an error exception, so that everything will\n\t * be aborted (except for executing finally clauses), until the error\n\t * exception is caught; if still uncaught at the top level, the error\n\t * message will be displayed and the script processing terminated\n\t * then.  -  This function has no access to the conditional stack.\n\t * Thus, the actual throw is made after the failing command has\n\t * returned.  -  Throw only the first of several errors in a row, except\n\t * a severe error is following.\n\t */\n\tif (msg_list != NULL)\n\t{\n\t    plist = msg_list;\n\t    while (*plist != NULL)\n\t\tplist = &(*plist)->next;\n\n\t    elem = ALLOC_CLEAR_ONE(msglist_T);\n\t    if (elem == NULL)\n\t    {\n\t\tsuppress_errthrow = TRUE;\n\t\temsg(_(e_out_of_memory));\n\t    }\n\t    else\n\t    {\n\t\telem->msg = (char *)vim_strsave(mesg);\n\t\tif (elem->msg == NULL)\n\t\t{\n\t\t    vim_free(elem);\n\t\t    suppress_errthrow = TRUE;\n\t\t    emsg(_(e_out_of_memory));\n\t\t}\n\t\telse\n\t\t{\n\t\t    elem->next = NULL;\n\t\t    elem->throw_msg = NULL;\n\t\t    *plist = elem;\n\t\t    if (plist == msg_list || severe)\n\t\t    {\n\t\t\tchar\t    *tmsg;\n\n\t\t\t// Skip the extra \"Vim \" prefix for message \"E458\".\n\t\t\ttmsg = elem->msg;\n\t\t\tif (STRNCMP(tmsg, \"Vim E\", 5) == 0\n\t\t\t\t&& VIM_ISDIGIT(tmsg[5])\n\t\t\t\t&& VIM_ISDIGIT(tmsg[6])\n\t\t\t\t&& VIM_ISDIGIT(tmsg[7])\n\t\t\t\t&& tmsg[8] == ':'\n\t\t\t\t&& tmsg[9] == ' ')\n\t\t\t    (*msg_list)->throw_msg = &tmsg[4];\n\t\t\telse\n\t\t\t    (*msg_list)->throw_msg = tmsg;\n\t\t    }\n\n\t\t    // Get the source name and lnum now, it may change before\n\t\t    // reaching do_errthrow().\n\t\t    elem->sfile = estack_sfile(ESTACK_NONE);\n\t\t    elem->slnum = SOURCING_LNUM;\n\t\t    elem->msg_compiling = estack_compiling;\n\t\t}\n\t    }\n\t}\n\treturn TRUE;\n    }\n}\n\n/*\n * Free a \"msg_list\" and the messages it contains.\n */\n    static void\nfree_msglist(msglist_T *l)\n{\n    msglist_T  *messages, *next;\n\n    messages = l;\n    while (messages != NULL)\n    {\n\tnext = messages->next;\n\tvim_free(messages->msg);\n\tvim_free(messages->sfile);\n\tvim_free(messages);\n\tmessages = next;\n    }\n}\n\n/*\n * Free global \"*msg_list\" and the messages it contains, then set \"*msg_list\"\n * to NULL.\n */\n    void\nfree_global_msglist(void)\n{\n    free_msglist(*msg_list);\n    *msg_list = NULL;\n}\n\n/*\n * Throw the message specified in the call to cause_errthrow() above as an\n * error exception.  If cstack is NULL, postpone the throw until do_cmdline()\n * has returned (see do_one_cmd()).\n */\n    void\ndo_errthrow(cstack_T *cstack, char_u *cmdname)\n{\n    /*\n     * Ensure that all commands in nested function calls and sourced files\n     * are aborted immediately.\n     */\n    if (cause_abort)\n    {\n\tcause_abort = FALSE;\n\tforce_abort = TRUE;\n    }\n\n    // If no exception is to be thrown or the conversion should be done after\n    // returning to a previous invocation of do_one_cmd(), do nothing.\n    if (msg_list == NULL || *msg_list == NULL)\n\treturn;\n\n    if (throw_exception(*msg_list, ET_ERROR, cmdname) == FAIL)\n\tfree_msglist(*msg_list);\n    else\n    {\n\tif (cstack != NULL)\n\t    do_throw(cstack);\n\telse\n\t    need_rethrow = TRUE;\n    }\n    *msg_list = NULL;\n}\n\n/*\n * do_intthrow(): Replace the current exception by an interrupt or interrupt\n * exception if appropriate.  Return TRUE if the current exception is discarded,\n * FALSE otherwise.\n */\n    int\ndo_intthrow(cstack_T *cstack)\n{\n    /*\n     * If no interrupt occurred or no try conditional is active and no exception\n     * is being thrown, do nothing (for compatibility of non-EH scripts).\n     */\n    if (!got_int || (trylevel == 0 && !did_throw))\n\treturn FALSE;\n\n#ifdef THROW_TEST\t// avoid warning for condition always true\n    if (!THROW_ON_INTERRUPT)\n    {\n\t/*\n\t * The interrupt aborts everything except for executing finally clauses.\n\t * Discard any user or error or interrupt exception currently being\n\t * thrown.\n\t */\n\tif (did_throw)\n\t    discard_current_exception();\n    }\n    else\n#endif\n    {\n\t/*\n\t * Throw an interrupt exception, so that everything will be aborted\n\t * (except for executing finally clauses), until the interrupt exception\n\t * is caught; if still uncaught at the top level, the script processing\n\t * will be terminated then.  -  If an interrupt exception is already\n\t * being thrown, do nothing.\n\t *\n\t */\n\tif (did_throw)\n\t{\n\t    if (current_exception->type == ET_INTERRUPT)\n\t\treturn FALSE;\n\n\t    // An interrupt exception replaces any user or error exception.\n\t    discard_current_exception();\n\t}\n\tif (throw_exception(\"Vim:Interrupt\", ET_INTERRUPT, NULL) != FAIL)\n\t    do_throw(cstack);\n    }\n\n    return TRUE;\n}\n\n/*\n * Get an exception message that is to be stored in current_exception->value.\n */\n    char *\nget_exception_string(\n    void\t*value,\n    except_type_T type,\n    char_u\t*cmdname,\n    int\t\t*should_free)\n{\n    char\t*ret;\n    char\t*mesg;\n    int\t\tcmdlen;\n    char\t*p, *val;\n\n    if (type == ET_ERROR)\n    {\n\t*should_free = TRUE;\n\tmesg = ((msglist_T *)value)->throw_msg;\n\tif (cmdname != NULL && *cmdname != NUL)\n\t{\n\t    cmdlen = (int)STRLEN(cmdname);\n\t    ret = (char *)vim_strnsave((char_u *)\"Vim(\",\n\t\t\t\t\t\t4 + cmdlen + 2 + STRLEN(mesg));\n\t    if (ret == NULL)\n\t\treturn ret;\n\t    STRCPY(&ret[4], cmdname);\n\t    STRCPY(&ret[4 + cmdlen], \"):\");\n\t    val = ret + 4 + cmdlen + 2;\n\t}\n\telse\n\t{\n\t    ret = (char *)vim_strnsave((char_u *)\"Vim:\", 4 + STRLEN(mesg));\n\t    if (ret == NULL)\n\t\treturn ret;\n\t    val = ret + 4;\n\t}\n\n\t// msg_add_fname may have been used to prefix the message with a file\n\t// name in quotes.  In the exception value, put the file name in\n\t// parentheses and move it to the end.\n\tfor (p = mesg; ; p++)\n\t{\n\t    if (*p == NUL\n\t\t    || (*p == 'E'\n\t\t\t&& VIM_ISDIGIT(p[1])\n\t\t\t&& (p[2] == ':'\n\t\t\t    || (VIM_ISDIGIT(p[2])\n\t\t\t\t&& (p[3] == ':'\n\t\t\t\t    || (VIM_ISDIGIT(p[3])\n\t\t\t\t\t&& p[4] == ':'))))))\n\t    {\n\t\tif (*p == NUL || p == mesg)\n\t\t    STRCAT(val, mesg);  // 'E123' missing or at beginning\n\t\telse\n\t\t{\n\t\t    // '\"filename\" E123: message text'\n\t\t    if (mesg[0] != '\"' || p-2 < &mesg[1] ||\n\t\t\t    p[-2] != '\"' || p[-1] != ' ')\n\t\t\t// \"E123:\" is part of the file name.\n\t\t\tcontinue;\n\n\t\t    STRCAT(val, p);\n\t\t    p[-2] = NUL;\n\t\t    sprintf((char *)(val + STRLEN(p)), \" (%s)\", &mesg[1]);\n\t\t    p[-2] = '\"';\n\t\t}\n\t\tbreak;\n\t    }\n\t}\n    }\n    else\n    {\n\t*should_free = FALSE;\n\tret = value;\n    }\n\n    return ret;\n}\n\n\n/*\n * Throw a new exception.  Return FAIL when out of memory or it was tried to\n * throw an illegal user exception.  \"value\" is the exception string for a\n * user or interrupt exception, or points to a message list in case of an\n * error exception.\n */\n    int\nthrow_exception(void *value, except_type_T type, char_u *cmdname)\n{\n    except_T\t*excp;\n    int\t\tshould_free;\n\n    /*\n     * Disallow faking Interrupt or error exceptions as user exceptions.  They\n     * would be treated differently from real interrupt or error exceptions\n     * when no active try block is found, see do_cmdline().\n     */\n    if (type == ET_USER)\n    {\n\tif (STRNCMP((char_u *)value, \"Vim\", 3) == 0\n\t\t&& (((char_u *)value)[3] == NUL || ((char_u *)value)[3] == ':'\n\t\t    || ((char_u *)value)[3] == '('))\n\t{\n\t    emsg(_(e_cannot_throw_exceptions_with_vim_prefix));\n\t    goto fail;\n\t}\n    }\n\n    excp = ALLOC_ONE(except_T);\n    if (excp == NULL)\n\tgoto nomem;\n\n    if (type == ET_ERROR)\n\t// Store the original message and prefix the exception value with\n\t// \"Vim:\" or, if a command name is given, \"Vim(cmdname):\".\n\texcp->messages = (msglist_T *)value;\n\n    excp->value = get_exception_string(value, type, cmdname, &should_free);\n    if (excp->value == NULL && should_free)\n\tgoto nomem;\n\n    excp->type = type;\n    if (type == ET_ERROR && ((msglist_T *)value)->sfile != NULL)\n    {\n\tmsglist_T *entry = (msglist_T *)value;\n\n\texcp->throw_name = entry->sfile;\n\tentry->sfile = NULL;\n\texcp->throw_lnum = entry->slnum;\n    }\n    else\n    {\n\texcp->throw_name = estack_sfile(ESTACK_NONE);\n\tif (excp->throw_name == NULL)\n\t    excp->throw_name = vim_strsave((char_u *)\"\");\n\tif (excp->throw_name == NULL)\n\t{\n\t    if (should_free)\n\t\tvim_free(excp->value);\n\t    goto nomem;\n\t}\n\texcp->throw_lnum = SOURCING_LNUM;\n    }\n\n    if (p_verbose >= 13 || debug_break_level > 0)\n    {\n\tint\tsave_msg_silent = msg_silent;\n\n\tif (debug_break_level > 0)\n\t    msg_silent = FALSE;\t\t// display messages\n\telse\n\t    verbose_enter();\n\t++no_wait_return;\n\tif (debug_break_level > 0 || *p_vfile == NUL)\n\t    msg_scroll = TRUE;\t    // always scroll up, don't overwrite\n\n\tsmsg(_(\"Exception thrown: %s\"), excp->value);\n\tmsg_puts(\"\\n\");   // don't overwrite this either\n\n\tif (debug_break_level > 0 || *p_vfile == NUL)\n\t    cmdline_row = msg_row;\n\t--no_wait_return;\n\tif (debug_break_level > 0)\n\t    msg_silent = save_msg_silent;\n\telse\n\t    verbose_leave();\n    }\n\n    current_exception = excp;\n    return OK;\n\nnomem:\n    vim_free(excp);\n    suppress_errthrow = TRUE;\n    emsg(_(e_out_of_memory));\nfail:\n    current_exception = NULL;\n    return FAIL;\n}\n\n/*\n * Discard an exception.  \"was_finished\" is set when the exception has been\n * caught and the catch clause has been ended normally.\n */\n    static void\ndiscard_exception(except_T *excp, int was_finished)\n{\n    char_u\t\t*saved_IObuff;\n\n    if (current_exception == excp)\n\tcurrent_exception = NULL;\n    if (excp == NULL)\n    {\n\tinternal_error(\"discard_exception()\");\n\treturn;\n    }\n\n    if (p_verbose >= 13 || debug_break_level > 0)\n    {\n\tint\tsave_msg_silent = msg_silent;\n\n\tsaved_IObuff = vim_strsave(IObuff);\n\tif (debug_break_level > 0)\n\t    msg_silent = FALSE;\t\t// display messages\n\telse\n\t    verbose_enter();\n\t++no_wait_return;\n\tif (debug_break_level > 0 || *p_vfile == NUL)\n\t    msg_scroll = TRUE;\t    // always scroll up, don't overwrite\n\tsmsg(was_finished\n\t\t    ? _(\"Exception finished: %s\")\n\t\t    : _(\"Exception discarded: %s\"),\n\t\texcp->value);\n\tmsg_puts(\"\\n\");   // don't overwrite this either\n\tif (debug_break_level > 0 || *p_vfile == NUL)\n\t    cmdline_row = msg_row;\n\t--no_wait_return;\n\tif (debug_break_level > 0)\n\t    msg_silent = save_msg_silent;\n\telse\n\t    verbose_leave();\n\tSTRCPY(IObuff, saved_IObuff);\n\tvim_free(saved_IObuff);\n    }\n    if (excp->type != ET_INTERRUPT)\n\tvim_free(excp->value);\n    if (excp->type == ET_ERROR)\n\tfree_msglist(excp->messages);\n    vim_free(excp->throw_name);\n    vim_free(excp);\n}\n\n/*\n * Discard the exception currently being thrown.\n */\n    void\ndiscard_current_exception(void)\n{\n    if (current_exception != NULL)\n\tdiscard_exception(current_exception, FALSE);\n    did_throw = FALSE;\n    need_rethrow = FALSE;\n}\n\n/*\n * Put an exception on the caught stack.\n */\n    void\ncatch_exception(except_T *excp)\n{\n    excp->caught = caught_stack;\n    caught_stack = excp;\n    set_vim_var_string(VV_EXCEPTION, (char_u *)excp->value, -1);\n    if (*excp->throw_name != NUL)\n    {\n\tif (excp->throw_lnum != 0)\n\t    vim_snprintf((char *)IObuff, IOSIZE, _(\"%s, line %ld\"),\n\t\t\t\t    excp->throw_name, (long)excp->throw_lnum);\n\telse\n\t    vim_snprintf((char *)IObuff, IOSIZE, \"%s\", excp->throw_name);\n\tset_vim_var_string(VV_THROWPOINT, IObuff, -1);\n    }\n    else\n\t// throw_name not set on an exception from a command that was typed.\n\tset_vim_var_string(VV_THROWPOINT, NULL, -1);\n\n    if (p_verbose >= 13 || debug_break_level > 0)\n    {\n\tint\tsave_msg_silent = msg_silent;\n\n\tif (debug_break_level > 0)\n\t    msg_silent = FALSE;\t\t// display messages\n\telse\n\t    verbose_enter();\n\t++no_wait_return;\n\tif (debug_break_level > 0 || *p_vfile == NUL)\n\t    msg_scroll = TRUE;\t    // always scroll up, don't overwrite\n\n\tsmsg(_(\"Exception caught: %s\"), excp->value);\n\tmsg_puts(\"\\n\");   // don't overwrite this either\n\n\tif (debug_break_level > 0 || *p_vfile == NUL)\n\t    cmdline_row = msg_row;\n\t--no_wait_return;\n\tif (debug_break_level > 0)\n\t    msg_silent = save_msg_silent;\n\telse\n\t    verbose_leave();\n    }\n}\n\n/*\n * Remove an exception from the caught stack.\n */\n    static void\nfinish_exception(except_T *excp)\n{\n    if (excp != caught_stack)\n\tinternal_error(\"finish_exception()\");\n    caught_stack = caught_stack->caught;\n    if (caught_stack != NULL)\n    {\n\tset_vim_var_string(VV_EXCEPTION, (char_u *)caught_stack->value, -1);\n\tif (*caught_stack->throw_name != NUL)\n\t{\n\t    if (caught_stack->throw_lnum != 0)\n\t\tvim_snprintf((char *)IObuff, IOSIZE,\n\t\t\t_(\"%s, line %ld\"), caught_stack->throw_name,\n\t\t\t(long)caught_stack->throw_lnum);\n\t    else\n\t\tvim_snprintf((char *)IObuff, IOSIZE, \"%s\",\n\t\t\t\t\t\t    caught_stack->throw_name);\n\t    set_vim_var_string(VV_THROWPOINT, IObuff, -1);\n\t}\n\telse\n\t    // throw_name not set on an exception from a command that was\n\t    // typed.\n\t    set_vim_var_string(VV_THROWPOINT, NULL, -1);\n    }\n    else\n    {\n\tset_vim_var_string(VV_EXCEPTION, NULL, -1);\n\tset_vim_var_string(VV_THROWPOINT, NULL, -1);\n    }\n\n    // Discard the exception, but use the finish message for 'verbose'.\n    discard_exception(excp, TRUE);\n}\n\n/*\n * Flags specifying the message displayed by report_pending.\n */\n#define RP_MAKE\t\t0\n#define RP_RESUME\t1\n#define RP_DISCARD\t2\n\n/*\n * Report information about something pending in a finally clause if required by\n * the 'verbose' option or when debugging.  \"action\" tells whether something is\n * made pending or something pending is resumed or discarded.  \"pending\" tells\n * what is pending.  \"value\" specifies the return value for a pending \":return\"\n * or the exception value for a pending exception.\n */\n    static void\nreport_pending(int action, int pending, void *value)\n{\n    char\t*mesg;\n    char\t*s;\n    int\t\tsave_msg_silent;\n\n\n    switch (action)\n    {\n\tcase RP_MAKE:\n\t    mesg = _(\"%s made pending\");\n\t    break;\n\tcase RP_RESUME:\n\t    mesg = _(\"%s resumed\");\n\t    break;\n\t// case RP_DISCARD:\n\tdefault:\n\t    mesg = _(\"%s discarded\");\n\t    break;\n    }\n\n    switch (pending)\n    {\n\tcase CSTP_NONE:\n\t    return;\n\n\tcase CSTP_CONTINUE:\n\t    s = \":continue\";\n\t    break;\n\tcase CSTP_BREAK:\n\t    s = \":break\";\n\t    break;\n\tcase CSTP_FINISH:\n\t    s = \":finish\";\n\t    break;\n\tcase CSTP_RETURN:\n\t    // \":return\" command producing value, allocated\n\t    s = (char *)get_return_cmd(value);\n\t    break;\n\n\tdefault:\n\t    if (pending & CSTP_THROW)\n\t    {\n\t\tvim_snprintf((char *)IObuff, IOSIZE, mesg, _(\"Exception\"));\n\t\tmesg = (char *)vim_strnsave(IObuff, STRLEN(IObuff) + 4);\n\t\tSTRCAT(mesg, \": %s\");\n\t\ts = (char *)((except_T *)value)->value;\n\t    }\n\t    else if ((pending & CSTP_ERROR) && (pending & CSTP_INTERRUPT))\n\t\ts = _(\"Error and interrupt\");\n\t    else if (pending & CSTP_ERROR)\n\t\ts = _(\"Error\");\n\t    else // if (pending & CSTP_INTERRUPT)\n\t\ts = _(\"Interrupt\");\n    }\n\n    save_msg_silent = msg_silent;\n    if (debug_break_level > 0)\n\tmsg_silent = FALSE;\t// display messages\n    ++no_wait_return;\n    msg_scroll = TRUE;\t\t// always scroll up, don't overwrite\n    smsg(mesg, s);\n    msg_puts(\"\\n\");   // don't overwrite this either\n    cmdline_row = msg_row;\n    --no_wait_return;\n    if (debug_break_level > 0)\n\tmsg_silent = save_msg_silent;\n\n    if (pending == CSTP_RETURN)\n\tvim_free(s);\n    else if (pending & CSTP_THROW)\n\tvim_free(mesg);\n}\n\n/*\n * If something is made pending in a finally clause, report it if required by\n * the 'verbose' option or when debugging.\n */\n    void\nreport_make_pending(int pending, void *value)\n{\n    if (p_verbose >= 14 || debug_break_level > 0)\n    {\n\tif (debug_break_level <= 0)\n\t    verbose_enter();\n\treport_pending(RP_MAKE, pending, value);\n\tif (debug_break_level <= 0)\n\t    verbose_leave();\n    }\n}\n\n/*\n * If something pending in a finally clause is resumed at the \":endtry\", report\n * it if required by the 'verbose' option or when debugging.\n */\n    static void\nreport_resume_pending(int pending, void *value)\n{\n    if (p_verbose >= 14 || debug_break_level > 0)\n    {\n\tif (debug_break_level <= 0)\n\t    verbose_enter();\n\treport_pending(RP_RESUME, pending, value);\n\tif (debug_break_level <= 0)\n\t    verbose_leave();\n    }\n}\n\n/*\n * If something pending in a finally clause is discarded, report it if required\n * by the 'verbose' option or when debugging.\n */\n    static void\nreport_discard_pending(int pending, void *value)\n{\n    if (p_verbose >= 14 || debug_break_level > 0)\n    {\n\tif (debug_break_level <= 0)\n\t    verbose_enter();\n\treport_pending(RP_DISCARD, pending, value);\n\tif (debug_break_level <= 0)\n\t    verbose_leave();\n    }\n}\n\n/*\n * Return TRUE if \"arg\" is only a variable, register, environment variable,\n * option name or string.\n */\n    int\ncmd_is_name_only(char_u *arg)\n{\n    char_u  *p = arg;\n    char_u  *alias = NULL;\n    int\t    name_only = FALSE;\n\n    if (*p == '@')\n    {\n\t++p;\n\tif (*p != NUL)\n\t    ++p;\n    }\n    else if (*p == '\\'' || *p == '\"')\n    {\n\tint\t    r;\n\n\tif (*p == '\"')\n\t    r = eval_string(&p, NULL, FALSE, FALSE);\n\telse\n\t    r = eval_lit_string(&p, NULL, FALSE, FALSE);\n\tif (r == FAIL)\n\t    return FALSE;\n    }\n    else\n    {\n\tif (*p == '&')\n\t{\n\t    ++p;\n\t    if (STRNCMP(\"l:\", p, 2) == 0 || STRNCMP(\"g:\", p, 2) == 0)\n\t\tp += 2;\n\t}\n\telse if (*p == '$')\n\t    ++p;\n\t(void)get_name_len(&p, &alias, FALSE, FALSE);\n    }\n    name_only = ends_excmd2(arg, skipwhite(p));\n    vim_free(alias);\n    return name_only;\n}\n\n/*\n * \":eval\".\n */\n    void\nex_eval(exarg_T *eap)\n{\n    typval_T\ttv;\n    evalarg_T\tevalarg;\n    int\t\tname_only = FALSE;\n    long\tlnum = SOURCING_LNUM;\n\n    if (in_vim9script())\n\tname_only = cmd_is_name_only(eap->arg);\n\n    fill_evalarg_from_eap(&evalarg, eap, eap->skip);\n\n    if (eval0(eap->arg, &tv, eap, &evalarg) == OK)\n    {\n\tclear_tv(&tv);\n\tif (in_vim9script() && name_only\n\t\t&& (evalarg.eval_tofree == NULL\n\t\t    || ends_excmd2(evalarg.eval_tofree,\n\t\t\t\t\t      skipwhite(evalarg.eval_tofree))))\n\t{\n\t    SOURCING_LNUM = lnum;\n\t    semsg(_(e_expression_without_effect_str), eap->arg);\n\t}\n    }\n\n    clear_evalarg(&evalarg, eap);\n}\n\n/*\n * Start a new scope/block.  Caller should have checked that cs_idx is not\n * exceeding CSTACK_LEN.\n */\n    static void\nenter_block(cstack_T *cstack)\n{\n    ++cstack->cs_idx;\n    if (in_vim9script() && current_sctx.sc_sid > 0)\n    {\n\tscriptitem_T *si = SCRIPT_ITEM(current_sctx.sc_sid);\n\n\tcstack->cs_script_var_len[cstack->cs_idx] = si->sn_var_vals.ga_len;\n\tcstack->cs_block_id[cstack->cs_idx] = ++si->sn_last_block_id;\n\tsi->sn_current_block_id = si->sn_last_block_id;\n    }\n    else\n    {\n\t// Just in case in_vim9script() does not return the same value when the\n\t// block ends.\n\tcstack->cs_script_var_len[cstack->cs_idx] = 0;\n\tcstack->cs_block_id[cstack->cs_idx] = 0;\n    }\n}\n\n    static void\nleave_block(cstack_T *cstack)\n{\n    if (in_vim9script() && SCRIPT_ID_VALID(current_sctx.sc_sid))\n    {\n\tscriptitem_T\t*si = SCRIPT_ITEM(current_sctx.sc_sid);\n\tint\t\ti;\n\tint\t\tfunc_defined =\n\t\t\t       cstack->cs_flags[cstack->cs_idx] & CSF_FUNC_DEF;\n\n\tfor (i = cstack->cs_script_var_len[cstack->cs_idx];\n\t\t\t\t\t       i < si->sn_var_vals.ga_len; ++i)\n\t{\n\t    svar_T\t*sv = ((svar_T *)si->sn_var_vals.ga_data) + i;\n\n\t    // sv_name is set to NULL if it was already removed.  This happens\n\t    // when it was defined in an inner block and no functions were\n\t    // defined there.\n\t    if (sv->sv_name != NULL)\n\t\t// Remove a variable declared inside the block, if it still\n\t\t// exists, from sn_vars and move the value into sn_all_vars\n\t\t// if \"func_defined\" is non-zero.\n\t\thide_script_var(si, i, func_defined);\n\t}\n\n\tif (cstack->cs_idx == 0)\n\t    si->sn_current_block_id = 0;\n\telse\n\t    si->sn_current_block_id = cstack->cs_block_id[cstack->cs_idx - 1];\n    }\n    --cstack->cs_idx;\n}\n\n/*\n * \":if\".\n */\n    void\nex_if(exarg_T *eap)\n{\n    int\t\terror;\n    int\t\tskip;\n    int\t\tresult;\n    cstack_T\t*cstack = eap->cstack;\n\n    if (cstack->cs_idx == CSTACK_LEN - 1)\n\teap->errmsg = _(e_if_nesting_too_deep);\n    else\n    {\n\tenter_block(cstack);\n\tcstack->cs_flags[cstack->cs_idx] = 0;\n\n\t/*\n\t * Don't do something after an error, interrupt, or throw, or when\n\t * there is a surrounding conditional and it was not active.\n\t */\n\tskip = did_emsg || got_int || did_throw || (cstack->cs_idx > 0\n\t\t&& !(cstack->cs_flags[cstack->cs_idx - 1] & CSF_ACTIVE));\n\n\tresult = eval_to_bool(eap->arg, &error, eap, skip);\n\n\tif (!skip && !error)\n\t{\n\t    if (result)\n\t\tcstack->cs_flags[cstack->cs_idx] = CSF_ACTIVE | CSF_TRUE;\n\t}\n\telse\n\t    // set TRUE, so this conditional will never get active\n\t    cstack->cs_flags[cstack->cs_idx] = CSF_TRUE;\n    }\n}\n\n/*\n * \":endif\".\n */\n    void\nex_endif(exarg_T *eap)\n{\n    cstack_T\t*cstack = eap->cstack;\n\n    if (cmdmod_error(FALSE))\n\treturn;\n    did_endif = TRUE;\n    if (cstack->cs_idx < 0\n\t    || (cstack->cs_flags[cstack->cs_idx]\n\t\t\t\t& (CSF_WHILE | CSF_FOR | CSF_TRY | CSF_BLOCK)))\n\teap->errmsg = _(e_endif_without_if);\n    else\n    {\n\t/*\n\t * When debugging or a breakpoint was encountered, display the debug\n\t * prompt (if not already done).  This shows the user that an \":endif\"\n\t * is executed when the \":if\" or a previous \":elseif\" was not TRUE.\n\t * Handle a \">quit\" debug command as if an interrupt had occurred before\n\t * the \":endif\".  That is, throw an interrupt exception if appropriate.\n\t * Doing this here prevents an exception for a parsing error being\n\t * discarded by throwing the interrupt exception later on.\n\t */\n\tif (!(cstack->cs_flags[cstack->cs_idx] & CSF_TRUE)\n\t\t\t\t\t\t    && dbg_check_skipped(eap))\n\t    (void)do_intthrow(cstack);\n\n\tleave_block(cstack);\n    }\n}\n\n/*\n * \":else\" and \":elseif\".\n */\n    void\nex_else(exarg_T *eap)\n{\n    int\t\terror;\n    int\t\tskip;\n    int\t\tresult;\n    cstack_T\t*cstack = eap->cstack;\n\n    /*\n     * Don't do something after an error, interrupt, or throw, or when there is\n     * a surrounding conditional and it was not active.\n     */\n    skip = did_emsg || got_int || did_throw || (cstack->cs_idx > 0\n\t    && !(cstack->cs_flags[cstack->cs_idx - 1] & CSF_ACTIVE));\n\n    if (cstack->cs_idx < 0\n\t    || (cstack->cs_flags[cstack->cs_idx]\n\t\t\t\t& (CSF_WHILE | CSF_FOR | CSF_TRY | CSF_BLOCK)))\n    {\n\tif (eap->cmdidx == CMD_else)\n\t{\n\t    eap->errmsg = _(e_else_without_if);\n\t    return;\n\t}\n\teap->errmsg = _(e_elseif_without_if);\n\tskip = TRUE;\n    }\n    else if (cstack->cs_flags[cstack->cs_idx] & CSF_ELSE)\n    {\n\tif (eap->cmdidx == CMD_else)\n\t{\n\t    eap->errmsg = _(e_multiple_else);\n\t    return;\n\t}\n\teap->errmsg = _(e_elseif_after_else);\n\tskip = TRUE;\n    }\n\n    if (cstack->cs_idx >= 0)\n    {\n\t// Variables declared in the previous block can no longer be\n\t// used.  Needs to be done before setting \"cs_flags\".\n\tleave_block(cstack);\n\tenter_block(cstack);\n    }\n\n    // if skipping or the \":if\" was TRUE, reset ACTIVE, otherwise set it\n    if (skip || cstack->cs_flags[cstack->cs_idx] & CSF_TRUE)\n    {\n\tif (eap->errmsg == NULL)\n\t    cstack->cs_flags[cstack->cs_idx] = CSF_TRUE;\n\tskip = TRUE;\t// don't evaluate an \":elseif\"\n    }\n    else\n\tcstack->cs_flags[cstack->cs_idx] = CSF_ACTIVE;\n\n    /*\n     * When debugging or a breakpoint was encountered, display the debug prompt\n     * (if not already done).  This shows the user that an \":else\" or \":elseif\"\n     * is executed when the \":if\" or previous \":elseif\" was not TRUE.  Handle\n     * a \">quit\" debug command as if an interrupt had occurred before the\n     * \":else\" or \":elseif\".  That is, set \"skip\" and throw an interrupt\n     * exception if appropriate.  Doing this here prevents that an exception\n     * for a parsing errors is discarded when throwing the interrupt exception\n     * later on.\n     */\n    if (!skip && dbg_check_skipped(eap) && got_int)\n    {\n\t(void)do_intthrow(cstack);\n\tskip = TRUE;\n    }\n\n    if (eap->cmdidx == CMD_elseif)\n    {\n\t// When skipping we ignore most errors, but a missing expression is\n\t// wrong, perhaps it should have been \"else\".\n\tif (skip && ends_excmd(*eap->arg))\n\t    semsg(_(e_invalid_expression_str), eap->arg);\n\telse\n\t    result = eval_to_bool(eap->arg, &error, eap, skip);\n\n\t// When throwing error exceptions, we want to throw always the first\n\t// of several errors in a row.  This is what actually happens when\n\t// a conditional error was detected above and there is another failure\n\t// when parsing the expression.  Since the skip flag is set in this\n\t// case, the parsing error will be ignored by emsg().\n\tif (!skip && !error)\n\t{\n\t    if (result)\n\t\tcstack->cs_flags[cstack->cs_idx] = CSF_ACTIVE | CSF_TRUE;\n\t    else\n\t\tcstack->cs_flags[cstack->cs_idx] = 0;\n\t}\n\telse if (eap->errmsg == NULL)\n\t    // set TRUE, so this conditional will never get active\n\t    cstack->cs_flags[cstack->cs_idx] = CSF_TRUE;\n    }\n    else\n\tcstack->cs_flags[cstack->cs_idx] |= CSF_ELSE;\n}\n\n/*\n * Handle \":while\" and \":for\".\n */\n    void\nex_while(exarg_T *eap)\n{\n    int\t\terror;\n    int\t\tskip;\n    int\t\tresult;\n    cstack_T\t*cstack = eap->cstack;\n    int\t\tprev_cs_flags = 0;\n\n    if (cstack->cs_idx == CSTACK_LEN - 1)\n\teap->errmsg = _(e_while_for_nesting_too_deep);\n    else\n    {\n\t/*\n\t * The loop flag is set when we have jumped back from the matching\n\t * \":endwhile\" or \":endfor\".  When not set, need to initialise this\n\t * cstack entry.\n\t */\n\tif ((cstack->cs_lflags & CSL_HAD_LOOP) == 0)\n\t{\n\t    enter_block(cstack);\n\t    ++cstack->cs_looplevel;\n\t    cstack->cs_line[cstack->cs_idx] = -1;\n\t}\n\telse\n\t{\n\t    if (in_vim9script() && SCRIPT_ID_VALID(current_sctx.sc_sid))\n\t    {\n\t\tscriptitem_T\t*si = SCRIPT_ITEM(current_sctx.sc_sid);\n\t\tint\t\ti;\n\t\tint\t\tfirst;\n\t\tint\t\tfunc_defined = cstack->cs_flags[cstack->cs_idx]\n\t\t\t\t\t\t\t\t& CSF_FUNC_DEF;\n\n\t\t// Any variables defined in the previous round are no longer\n\t\t// visible.  Keep the first one for \":for\", it is the loop\n\t\t// variable that we reuse every time around.\n\t\t// Do this backwards, so that vars defined in a later round are\n\t\t// found first.\n\t\tfirst = cstack->cs_script_var_len[cstack->cs_idx];\n\t\tif (eap->cmdidx == CMD_for)\n\t\t{\n\t\t    forinfo_T\t*fi = cstack->cs_forinfo[cstack->cs_idx];\n\n\t\t    first += fi == NULL || fi->fi_varcount == 0\n\t\t\t\t\t\t\t ? 1 : fi->fi_varcount;\n\t\t}\n\t\tfor (i = si->sn_var_vals.ga_len - 1; i >= first; --i)\n\t\t{\n\t\t    svar_T\t*sv = ((svar_T *)si->sn_var_vals.ga_data) + i;\n\n\t\t    // sv_name is set to NULL if it was already removed.  This\n\t\t    // happens when it was defined in an inner block and no\n\t\t    // functions were defined there.\n\t\t    if (sv->sv_name != NULL)\n\t\t\t// Remove a variable declared inside the block, if it\n\t\t\t// still exists, from sn_vars.\n\t\t\thide_script_var(si, i, func_defined);\n\t\t}\n\n\t\t// Start a new block ID, so that variables defined inside the\n\t\t// loop are created new and not shared with the previous loop.\n\t\t// Matters when used in a closure.\n\t\tcstack->cs_block_id[cstack->cs_idx] = ++si->sn_last_block_id;\n\t\tsi->sn_current_block_id = si->sn_last_block_id;\n\t    }\n\t}\n\tprev_cs_flags = cstack->cs_flags[cstack->cs_idx];\n\tcstack->cs_flags[cstack->cs_idx] =\n\t\t\t       eap->cmdidx == CMD_while ? CSF_WHILE : CSF_FOR;\n\n\t/*\n\t * Don't do something after an error, interrupt, or throw, or when\n\t * there is a surrounding conditional and it was not active.\n\t */\n\tskip = did_emsg || got_int || did_throw || (cstack->cs_idx > 0\n\t\t&& !(cstack->cs_flags[cstack->cs_idx - 1] & CSF_ACTIVE));\n\tif (eap->cmdidx == CMD_while)\n\t{\n\t    /*\n\t     * \":while bool-expr\"\n\t     */\n\t    result = eval_to_bool(eap->arg, &error, eap, skip);\n\t}\n\telse\n\t{\n\t    forinfo_T\t*fi;\n\t    evalarg_T\tevalarg;\n\n\t    /*\n\t     * \":for var in list-expr\"\n\t     */\n\t    fill_evalarg_from_eap(&evalarg, eap, skip);\n\t    if ((cstack->cs_lflags & CSL_HAD_LOOP) != 0)\n\t    {\n\t\t// Jumping here from a \":continue\" or \":endfor\": use the\n\t\t// previously evaluated list.\n\t\tfi = cstack->cs_forinfo[cstack->cs_idx];\n\t\terror = FALSE;\n\n\t\t// the \"in expr\" is not used, skip over it\n\t\tskip_for_lines(fi, &evalarg);\n\t    }\n\t    else\n\t    {\n\t\tlong save_lnum = SOURCING_LNUM;\n\n\t\t// Evaluate the argument and get the info in a structure.\n\t\tfi = eval_for_line(eap->arg, &error, eap, &evalarg);\n\t\tcstack->cs_forinfo[cstack->cs_idx] = fi;\n\n\t\t// Errors should use the first line number.\n\t\tSOURCING_LNUM = save_lnum;\n\t    }\n\n\t    // use the element at the start of the list and advance\n\t    if (!error && fi != NULL && !skip)\n\t\tresult = next_for_item(fi, eap->arg);\n\t    else\n\t\tresult = FALSE;\n\t    if (fi != NULL)\n\t\t// OR all the cs_flags together, if a function was defined in\n\t\t// any round then the loop variable may have been used.\n\t\tfi->fi_cs_flags |= prev_cs_flags;\n\n\t    if (!result)\n\t    {\n\t\t// If a function was defined in any round then set the\n\t\t// CSF_FUNC_DEF flag now, so that it's seen by leave_block().\n\t\tif (fi != NULL && (fi->fi_cs_flags & CSF_FUNC_DEF))\n\t\t    cstack->cs_flags[cstack->cs_idx] |= CSF_FUNC_DEF;\n\n\t\tfree_for_info(fi);\n\t\tcstack->cs_forinfo[cstack->cs_idx] = NULL;\n\t    }\n\t    clear_evalarg(&evalarg, eap);\n\t}\n\n\t/*\n\t * If this cstack entry was just initialised and is active, set the\n\t * loop flag, so do_cmdline() will set the line number in cs_line[].\n\t * If executing the command a second time, clear the loop flag.\n\t */\n\tif (!skip && !error && result)\n\t{\n\t    cstack->cs_flags[cstack->cs_idx] |= (CSF_ACTIVE | CSF_TRUE);\n\t    cstack->cs_lflags ^= CSL_HAD_LOOP;\n\t}\n\telse\n\t{\n\t    cstack->cs_lflags &= ~CSL_HAD_LOOP;\n\t    // If the \":while\" evaluates to FALSE or \":for\" is past the end of\n\t    // the list, show the debug prompt at the \":endwhile\"/\":endfor\" as\n\t    // if there was a \":break\" in a \":while\"/\":for\" evaluating to\n\t    // TRUE.\n\t    if (!skip && !error)\n\t\tcstack->cs_flags[cstack->cs_idx] |= CSF_TRUE;\n\t}\n    }\n}\n\n/*\n * \":continue\"\n */\n    void\nex_continue(exarg_T *eap)\n{\n    int\t\tidx;\n    cstack_T\t*cstack = eap->cstack;\n\n    if (cstack->cs_looplevel <= 0 || cstack->cs_idx < 0)\n\teap->errmsg = _(e_continue_without_while_or_for);\n    else\n    {\n\t// Try to find the matching \":while\".  This might stop at a try\n\t// conditional not in its finally clause (which is then to be executed\n\t// next).  Therefore, inactivate all conditionals except the \":while\"\n\t// itself (if reached).\n\tidx = cleanup_conditionals(cstack, CSF_WHILE | CSF_FOR, FALSE);\n\tif (idx >= 0 && (cstack->cs_flags[idx] & (CSF_WHILE | CSF_FOR)))\n\t{\n\t    rewind_conditionals(cstack, idx, CSF_TRY, &cstack->cs_trylevel);\n\n\t    /*\n\t     * Set CSL_HAD_CONT, so do_cmdline() will jump back to the\n\t     * matching \":while\".\n\t     */\n\t    cstack->cs_lflags |= CSL_HAD_CONT;\t// let do_cmdline() handle it\n\t}\n\telse\n\t{\n\t    // If a try conditional not in its finally clause is reached first,\n\t    // make the \":continue\" pending for execution at the \":endtry\".\n\t    cstack->cs_pending[idx] = CSTP_CONTINUE;\n\t    report_make_pending(CSTP_CONTINUE, NULL);\n\t}\n    }\n}\n\n/*\n * \":break\"\n */\n    void\nex_break(exarg_T *eap)\n{\n    int\t\tidx;\n    cstack_T\t*cstack = eap->cstack;\n\n    if (cstack->cs_looplevel <= 0 || cstack->cs_idx < 0)\n\teap->errmsg = _(e_break_without_while_or_for);\n    else\n    {\n\t// Inactivate conditionals until the matching \":while\" or a try\n\t// conditional not in its finally clause (which is then to be\n\t// executed next) is found.  In the latter case, make the \":break\"\n\t// pending for execution at the \":endtry\".\n\tidx = cleanup_conditionals(cstack, CSF_WHILE | CSF_FOR, TRUE);\n\tif (idx >= 0 && !(cstack->cs_flags[idx] & (CSF_WHILE | CSF_FOR)))\n\t{\n\t    cstack->cs_pending[idx] = CSTP_BREAK;\n\t    report_make_pending(CSTP_BREAK, NULL);\n\t}\n    }\n}\n\n/*\n * \":endwhile\" and \":endfor\"\n */\n    void\nex_endwhile(exarg_T *eap)\n{\n    cstack_T\t*cstack = eap->cstack;\n    int\t\tidx;\n    char\t*err;\n    int\t\tcsf;\n    int\t\tfl;\n\n    if (cmdmod_error(TRUE))\n\treturn;\n\n    if (eap->cmdidx == CMD_endwhile)\n    {\n\terr = e_endwhile_without_while;\n\tcsf = CSF_WHILE;\n    }\n    else\n    {\n\terr = e_endfor_without_for;\n\tcsf = CSF_FOR;\n    }\n\n    if (cstack->cs_looplevel <= 0 || cstack->cs_idx < 0)\n\teap->errmsg = _(err);\n    else\n    {\n\tfl = cstack->cs_flags[cstack->cs_idx];\n\tif (!(fl & csf))\n\t{\n\t    // If we are in a \":while\" or \":for\" but used the wrong endloop\n\t    // command, do not rewind to the next enclosing \":for\"/\":while\".\n\t    if (fl & CSF_WHILE)\n\t\teap->errmsg = _(e_using_endfor_with_while);\n\t    else if (fl & CSF_FOR)\n\t\teap->errmsg = _(e_using_endwhile_with_for);\n\t}\n\tif (!(fl & (CSF_WHILE | CSF_FOR)))\n\t{\n\t    if (!(fl & CSF_TRY))\n\t\teap->errmsg = _(e_missing_endif);\n\t    else if (fl & CSF_FINALLY)\n\t\teap->errmsg = _(e_missing_endtry);\n\t    // Try to find the matching \":while\" and report what's missing.\n\t    for (idx = cstack->cs_idx; idx > 0; --idx)\n\t    {\n\t\tfl =  cstack->cs_flags[idx];\n\t\tif ((fl & CSF_TRY) && !(fl & CSF_FINALLY))\n\t\t{\n\t\t    // Give up at a try conditional not in its finally clause.\n\t\t    // Ignore the \":endwhile\"/\":endfor\".\n\t\t    eap->errmsg = _(err);\n\t\t    return;\n\t\t}\n\t\tif (fl & csf)\n\t\t    break;\n\t    }\n\t    // Cleanup and rewind all contained (and unclosed) conditionals.\n\t    (void)cleanup_conditionals(cstack, CSF_WHILE | CSF_FOR, FALSE);\n\t    rewind_conditionals(cstack, idx, CSF_TRY, &cstack->cs_trylevel);\n\t}\n\n\t/*\n\t * When debugging or a breakpoint was encountered, display the debug\n\t * prompt (if not already done).  This shows the user that an\n\t * \":endwhile\"/\":endfor\" is executed when the \":while\" was not TRUE or\n\t * after a \":break\".  Handle a \">quit\" debug command as if an\n\t * interrupt had occurred before the \":endwhile\"/\":endfor\".  That is,\n\t * throw an interrupt exception if appropriate.  Doing this here\n\t * prevents that an exception for a parsing error is discarded when\n\t * throwing the interrupt exception later on.\n\t */\n\telse if (cstack->cs_flags[cstack->cs_idx] & CSF_TRUE\n\t\t&& !(cstack->cs_flags[cstack->cs_idx] & CSF_ACTIVE)\n\t\t&& dbg_check_skipped(eap))\n\t    (void)do_intthrow(cstack);\n\n\t// Set loop flag, so do_cmdline() will jump back to the matching\n\t// \":while\" or \":for\".\n\tcstack->cs_lflags |= CSL_HAD_ENDLOOP;\n    }\n}\n\n/*\n * \"{\" start of a block in Vim9 script\n */\n    void\nex_block(exarg_T *eap)\n{\n    cstack_T\t*cstack = eap->cstack;\n\n    if (cstack->cs_idx == CSTACK_LEN - 1)\n\teap->errmsg = _(e_block_nesting_too_deep);\n    else\n    {\n\tenter_block(cstack);\n\tcstack->cs_flags[cstack->cs_idx] = CSF_BLOCK | CSF_ACTIVE | CSF_TRUE;\n    }\n}\n\n/*\n * \"}\" end of a block in Vim9 script\n */\n    void\nex_endblock(exarg_T *eap)\n{\n    cstack_T\t*cstack = eap->cstack;\n\n    if (cstack->cs_idx < 0\n\t    || (cstack->cs_flags[cstack->cs_idx] & CSF_BLOCK) == 0)\n\teap->errmsg = _(e_endblock_without_block);\n    else\n\tleave_block(cstack);\n}\n\n    int\ninside_block(exarg_T *eap)\n{\n    cstack_T\t*cstack = eap->cstack;\n    int\t\ti;\n\n    for (i = 0; i <= cstack->cs_idx; ++i)\n\tif (cstack->cs_flags[cstack->cs_idx] & CSF_BLOCK)\n\t    return TRUE;\n    return FALSE;\n}\n\n/*\n * \":throw expr\"\n */\n    void\nex_throw(exarg_T *eap)\n{\n    char_u\t*arg = eap->arg;\n    char_u\t*value;\n\n    if (*arg != NUL && *arg != '|' && *arg != '\\n')\n\tvalue = eval_to_string_skip(arg, eap, eap->skip);\n    else\n    {\n\temsg(_(e_argument_required));\n\tvalue = NULL;\n    }\n\n    // On error or when an exception is thrown during argument evaluation, do\n    // not throw.\n    if (!eap->skip && value != NULL)\n    {\n\tif (throw_exception(value, ET_USER, NULL) == FAIL)\n\t    vim_free(value);\n\telse\n\t    do_throw(eap->cstack);\n    }\n}\n\n/*\n * Throw the current exception through the specified cstack.  Common routine\n * for \":throw\" (user exception) and error and interrupt exceptions.  Also\n * used for rethrowing an uncaught exception.\n */\n    void\ndo_throw(cstack_T *cstack)\n{\n    int\t\tidx;\n    int\t\tinactivate_try = FALSE;\n\n    /*\n     * Cleanup and inactivate up to the next surrounding try conditional that\n     * is not in its finally clause.  Normally, do not inactivate the try\n     * conditional itself, so that its ACTIVE flag can be tested below.  But\n     * if a previous error or interrupt has not been converted to an exception,\n     * inactivate the try conditional, too, as if the conversion had been done,\n     * and reset the did_emsg or got_int flag, so this won't happen again at\n     * the next surrounding try conditional.\n     */\n#ifndef THROW_ON_ERROR_TRUE\n    if (did_emsg && !THROW_ON_ERROR)\n    {\n\tinactivate_try = TRUE;\n\tdid_emsg = FALSE;\n    }\n#endif\n#ifndef THROW_ON_INTERRUPT_TRUE\n    if (got_int && !THROW_ON_INTERRUPT)\n    {\n\tinactivate_try = TRUE;\n\tgot_int = FALSE;\n    }\n#endif\n    idx = cleanup_conditionals(cstack, 0, inactivate_try);\n    if (idx >= 0)\n    {\n\t/*\n\t * If this try conditional is active and we are before its first\n\t * \":catch\", set THROWN so that the \":catch\" commands will check\n\t * whether the exception matches.  When the exception came from any of\n\t * the catch clauses, it will be made pending at the \":finally\" (if\n\t * present) and rethrown at the \":endtry\".  This will also happen if\n\t * the try conditional is inactive.  This is the case when we are\n\t * throwing an exception due to an error or interrupt on the way from\n\t * a preceding \":continue\", \":break\", \":return\", \":finish\", error or\n\t * interrupt (not converted to an exception) to the finally clause or\n\t * from a preceding throw of a user or error or interrupt exception to\n\t * the matching catch clause or the finally clause.\n\t */\n\tif (!(cstack->cs_flags[idx] & CSF_CAUGHT))\n\t{\n\t    if (cstack->cs_flags[idx] & CSF_ACTIVE)\n\t\tcstack->cs_flags[idx] |= CSF_THROWN;\n\t    else\n\t\t// THROWN may have already been set for a catchable exception\n\t\t// that has been discarded.  Ensure it is reset for the new\n\t\t// exception.\n\t\tcstack->cs_flags[idx] &= ~CSF_THROWN;\n\t}\n\tcstack->cs_flags[idx] &= ~CSF_ACTIVE;\n\tcstack->cs_exception[idx] = current_exception;\n    }\n#if 0\n    // TODO: Add optimization below.  Not yet done because of interface\n    // problems to eval.c and ex_cmds2.c. (Servatius)\n    else\n    {\n\t/*\n\t * There are no catch clauses to check or finally clauses to execute.\n\t * End the current script or function.  The exception will be rethrown\n\t * in the caller.\n\t */\n\tif (getline_equal(eap->getline, eap->cookie, get_func_line))\n\t    current_funccal->returned = TRUE;\n\telseif (eap->get_func_line == getsourceline)\n\t    ((struct source_cookie *)eap->cookie)->finished = TRUE;\n    }\n#endif\n\n    did_throw = TRUE;\n}\n\n/*\n * \":try\"\n */\n    void\nex_try(exarg_T *eap)\n{\n    int\t\tskip;\n    cstack_T\t*cstack = eap->cstack;\n\n    if (cmdmod_error(FALSE))\n\treturn;\n\n    if (cstack->cs_idx == CSTACK_LEN - 1)\n\teap->errmsg = _(e_try_nesting_too_deep);\n    else\n    {\n\tenter_block(cstack);\n\t++cstack->cs_trylevel;\n\tcstack->cs_flags[cstack->cs_idx] = CSF_TRY;\n\tcstack->cs_pending[cstack->cs_idx] = CSTP_NONE;\n\n\t/*\n\t * Don't do something after an error, interrupt, or throw, or when there\n\t * is a surrounding conditional and it was not active.\n\t */\n\tskip = did_emsg || got_int || did_throw || (cstack->cs_idx > 0\n\t\t&& !(cstack->cs_flags[cstack->cs_idx - 1] & CSF_ACTIVE));\n\n\tif (!skip)\n\t{\n\t    // Set ACTIVE and TRUE.  TRUE means that the corresponding \":catch\"\n\t    // commands should check for a match if an exception is thrown and\n\t    // that the finally clause needs to be executed.\n\t    cstack->cs_flags[cstack->cs_idx] |= CSF_ACTIVE | CSF_TRUE;\n\n\t    /*\n\t     * \":silent!\", even when used in a try conditional, disables\n\t     * displaying of error messages and conversion of errors to\n\t     * exceptions.  When the silent commands again open a try\n\t     * conditional, save \"emsg_silent\" and reset it so that errors are\n\t     * again converted to exceptions.  The value is restored when that\n\t     * try conditional is left.  If it is left normally, the commands\n\t     * following the \":endtry\" are again silent.  If it is left by\n\t     * a \":continue\", \":break\", \":return\", or \":finish\", the commands\n\t     * executed next are again silent.  If it is left due to an\n\t     * aborting error, an interrupt, or an exception, restoring\n\t     * \"emsg_silent\" does not matter since we are already in the\n\t     * aborting state and/or the exception has already been thrown.\n\t     * The effect is then just freeing the memory that was allocated\n\t     * to save the value.\n\t     */\n\t    if (emsg_silent)\n\t    {\n\t\teslist_T\t*elem;\n\n\t\telem = ALLOC_ONE(struct eslist_elem);\n\t\tif (elem == NULL)\n\t\t    emsg(_(e_out_of_memory));\n\t\telse\n\t\t{\n\t\t    elem->saved_emsg_silent = emsg_silent;\n\t\t    elem->next = cstack->cs_emsg_silent_list;\n\t\t    cstack->cs_emsg_silent_list = elem;\n\t\t    cstack->cs_flags[cstack->cs_idx] |= CSF_SILENT;\n\t\t    emsg_silent = 0;\n\t\t}\n\t    }\n\t}\n\n    }\n}\n\n/*\n * \":catch /{pattern}/\" and \":catch\"\n */\n    void\nex_catch(exarg_T *eap)\n{\n    int\t\tidx = 0;\n    int\t\tgive_up = FALSE;\n    int\t\tskip = FALSE;\n    int\t\tcaught = FALSE;\n    char_u\t*end;\n    int\t\tsave_char = 0;\n    char_u\t*save_cpo;\n    regmatch_T\tregmatch;\n    int\t\tprev_got_int;\n    cstack_T\t*cstack = eap->cstack;\n    char_u\t*pat;\n\n    if (cmdmod_error(FALSE))\n\treturn;\n\n    if (cstack->cs_trylevel <= 0 || cstack->cs_idx < 0)\n    {\n\teap->errmsg = _(e_catch_without_try);\n\tgive_up = TRUE;\n    }\n    else\n    {\n\tif (!(cstack->cs_flags[cstack->cs_idx] & CSF_TRY))\n\t{\n\t    // Report what's missing if the matching \":try\" is not in its\n\t    // finally clause.\n\t    eap->errmsg = get_end_emsg(cstack);\n\t    skip = TRUE;\n\t}\n\tfor (idx = cstack->cs_idx; idx > 0; --idx)\n\t    if (cstack->cs_flags[idx] & CSF_TRY)\n\t\tbreak;\n\tif (cstack->cs_flags[idx] & CSF_TRY)\n\t    cstack->cs_flags[idx] |= CSF_CATCH;\n\tif (cstack->cs_flags[idx] & CSF_FINALLY)\n\t{\n\t    // Give up for a \":catch\" after \":finally\" and ignore it.\n\t    // Just parse.\n\t    eap->errmsg = _(e_catch_after_finally);\n\t    give_up = TRUE;\n\t}\n\telse\n\t    rewind_conditionals(cstack, idx, CSF_WHILE | CSF_FOR,\n\t\t\t\t\t\t       &cstack->cs_looplevel);\n    }\n\n    if (ends_excmd2(eap->cmd, eap->arg))   // no argument, catch all errors\n    {\n\tpat = (char_u *)\".*\";\n\tend = NULL;\n\teap->nextcmd = find_nextcmd(eap->arg);\n    }\n    else\n    {\n\tpat = eap->arg + 1;\n\tend = skip_regexp_err(pat, *eap->arg, TRUE);\n\tif (end == NULL)\n\t    give_up = TRUE;\n    }\n\n    if (!give_up)\n    {\n\t/*\n\t * Don't do something when no exception has been thrown or when the\n\t * corresponding try block never got active (because of an inactive\n\t * surrounding conditional or after an error or interrupt or throw).\n\t */\n\tif (!did_throw || !(cstack->cs_flags[idx] & CSF_TRUE))\n\t    skip = TRUE;\n\n\t/*\n\t * Check for a match only if an exception is thrown but not caught by\n\t * a previous \":catch\".  An exception that has replaced a discarded\n\t * exception is not checked (THROWN is not set then).\n\t */\n\tif (!skip && (cstack->cs_flags[idx] & CSF_THROWN)\n\t\t&& !(cstack->cs_flags[idx] & CSF_CAUGHT))\n\t{\n\t    if (end != NULL && *end != NUL\n\t\t\t\t      && !ends_excmd2(end, skipwhite(end + 1)))\n\t    {\n\t\tsemsg(_(e_trailing_characters_str), end);\n\t\treturn;\n\t    }\n\n\t    // When debugging or a breakpoint was encountered, display the\n\t    // debug prompt (if not already done) before checking for a match.\n\t    // This is a helpful hint for the user when the regular expression\n\t    // matching fails.  Handle a \">quit\" debug command as if an\n\t    // interrupt had occurred before the \":catch\".  That is, discard\n\t    // the original exception, replace it by an interrupt exception,\n\t    // and don't catch it in this try block.\n\t    if (!dbg_check_skipped(eap) || !do_intthrow(cstack))\n\t    {\n\t\t// Terminate the pattern and avoid the 'l' flag in 'cpoptions'\n\t\t// while compiling it.\n\t\tif (end != NULL)\n\t\t{\n\t\t    save_char = *end;\n\t\t    *end = NUL;\n\t\t}\n\t\tsave_cpo  = p_cpo;\n\t\tp_cpo = empty_option;\n\t\t// Disable error messages, it will make current_exception\n\t\t// invalid.\n\t\t++emsg_off;\n\t\tregmatch.regprog = vim_regcomp(pat, RE_MAGIC + RE_STRING);\n\t\t--emsg_off;\n\t\tregmatch.rm_ic = FALSE;\n\t\tif (end != NULL)\n\t\t    *end = save_char;\n\t\tp_cpo = save_cpo;\n\t\tif (regmatch.regprog == NULL)\n\t\t    semsg(_(e_invalid_argument_str), pat);\n\t\telse\n\t\t{\n\t\t    /*\n\t\t     * Save the value of got_int and reset it.  We don't want\n\t\t     * a previous interruption cancel matching, only hitting\n\t\t     * CTRL-C while matching should abort it.\n\t\t     */\n\t\t    prev_got_int = got_int;\n\t\t    got_int = FALSE;\n\t\t    caught = vim_regexec_nl(&regmatch,\n\t\t\t       (char_u *)current_exception->value, (colnr_T)0);\n\t\t    got_int |= prev_got_int;\n\t\t    vim_regfree(regmatch.regprog);\n\t\t}\n\t    }\n\t}\n\n\tif (caught)\n\t{\n\t    // Make this \":catch\" clause active and reset did_emsg, got_int,\n\t    // and did_throw.  Put the exception on the caught stack.\n\t    cstack->cs_flags[idx] |= CSF_ACTIVE | CSF_CAUGHT;\n\t    did_emsg = got_int = did_throw = FALSE;\n\t    catch_exception((except_T *)cstack->cs_exception[idx]);\n\n\t    if (cstack->cs_idx >= 0\n\t\t\t       && (cstack->cs_flags[cstack->cs_idx] & CSF_TRY))\n\t    {\n\t\t// Variables declared in the previous block can no longer be\n\t\t// used.\n\t\tleave_block(cstack);\n\t\tenter_block(cstack);\n\t    }\n\n\t    // It's mandatory that the current exception is stored in the cstack\n\t    // so that it can be discarded at the next \":catch\", \":finally\", or\n\t    // \":endtry\" or when the catch clause is left by a \":continue\",\n\t    // \":break\", \":return\", \":finish\", error, interrupt, or another\n\t    // exception.\n\t    if (cstack->cs_exception[cstack->cs_idx] != current_exception)\n\t\tinternal_error(\"ex_catch()\");\n\t}\n\telse\n\t{\n\t    /*\n\t     * If there is a preceding catch clause and it caught the exception,\n\t     * finish the exception now.  This happens also after errors except\n\t     * when this \":catch\" was after the \":finally\" or not within\n\t     * a \":try\".  Make the try conditional inactive so that the\n\t     * following catch clauses are skipped.  On an error or interrupt\n\t     * after the preceding try block or catch clause was left by\n\t     * a \":continue\", \":break\", \":return\", or \":finish\", discard the\n\t     * pending action.\n\t     */\n\t    cleanup_conditionals(cstack, CSF_TRY, TRUE);\n\t}\n    }\n\n    if (end != NULL)\n\teap->nextcmd = find_nextcmd(end);\n}\n\n/*\n * \":finally\"\n */\n    void\nex_finally(exarg_T *eap)\n{\n    int\t\tidx;\n    int\t\tskip = FALSE;\n    int\t\tpending = CSTP_NONE;\n    cstack_T\t*cstack = eap->cstack;\n\n    if (cmdmod_error(FALSE))\n\treturn;\n\n    for (idx = cstack->cs_idx; idx >= 0; --idx)\n\tif (cstack->cs_flags[idx] & CSF_TRY)\n\t    break;\n    if (cstack->cs_trylevel <= 0 || idx < 0)\n    {\n\teap->errmsg = _(e_finally_without_try);\n\treturn;\n    }\n\n    if (!(cstack->cs_flags[cstack->cs_idx] & CSF_TRY))\n    {\n\teap->errmsg = get_end_emsg(cstack);\n\t// Make this error pending, so that the commands in the following\n\t// finally clause can be executed.  This overrules also a pending\n\t// \":continue\", \":break\", \":return\", or \":finish\".\n\tpending = CSTP_ERROR;\n    }\n\n    if (cstack->cs_flags[idx] & CSF_FINALLY)\n    {\n\t// Give up for a multiple \":finally\" and ignore it.\n\teap->errmsg = _(e_multiple_finally);\n\treturn;\n    }\n    rewind_conditionals(cstack, idx, CSF_WHILE | CSF_FOR,\n\t\t\t\t\t\t   &cstack->cs_looplevel);\n\n    /*\n     * Don't do something when the corresponding try block never got active\n     * (because of an inactive surrounding conditional or after an error or\n     * interrupt or throw) or for a \":finally\" without \":try\" or a multiple\n     * \":finally\".  After every other error (did_emsg or the conditional\n     * errors detected above) or after an interrupt (got_int) or an\n     * exception (did_throw), the finally clause must be executed.\n     */\n    skip = !(cstack->cs_flags[cstack->cs_idx] & CSF_TRUE);\n\n    if (!skip)\n    {\n\t// When debugging or a breakpoint was encountered, display the\n\t// debug prompt (if not already done).  The user then knows that the\n\t// finally clause is executed.\n\tif (dbg_check_skipped(eap))\n\t{\n\t    // Handle a \">quit\" debug command as if an interrupt had\n\t    // occurred before the \":finally\".  That is, discard the\n\t    // original exception and replace it by an interrupt\n\t    // exception.\n\t    (void)do_intthrow(cstack);\n\t}\n\n\t/*\n\t * If there is a preceding catch clause and it caught the exception,\n\t * finish the exception now.  This happens also after errors except\n\t * when this is a multiple \":finally\" or one not within a \":try\".\n\t * After an error or interrupt, this also discards a pending\n\t * \":continue\", \":break\", \":finish\", or \":return\" from the preceding\n\t * try block or catch clause.\n\t */\n\tcleanup_conditionals(cstack, CSF_TRY, FALSE);\n\n\tif (cstack->cs_idx >= 0\n\t\t\t   && (cstack->cs_flags[cstack->cs_idx] & CSF_TRY))\n\t{\n\t    // Variables declared in the previous block can no longer be\n\t    // used.\n\t    leave_block(cstack);\n\t    enter_block(cstack);\n\t}\n\n\t/*\n\t * Make did_emsg, got_int, did_throw pending.  If set, they overrule\n\t * a pending \":continue\", \":break\", \":return\", or \":finish\".  Then\n\t * we have particularly to discard a pending return value (as done\n\t * by the call to cleanup_conditionals() above when did_emsg or\n\t * got_int is set).  The pending values are restored by the\n\t * \":endtry\", except if there is a new error, interrupt, exception,\n\t * \":continue\", \":break\", \":return\", or \":finish\" in the following\n\t * finally clause.  A missing \":endwhile\", \":endfor\" or \":endif\"\n\t * detected here is treated as if did_emsg and did_throw had\n\t * already been set, respectively in case that the error is not\n\t * converted to an exception, did_throw had already been unset.\n\t * We must not set did_emsg here since that would suppress the\n\t * error message.\n\t */\n\tif (pending == CSTP_ERROR || did_emsg || got_int || did_throw)\n\t{\n\t    if (cstack->cs_pending[cstack->cs_idx] == CSTP_RETURN)\n\t    {\n\t\treport_discard_pending(CSTP_RETURN,\n\t\t\t\t       cstack->cs_rettv[cstack->cs_idx]);\n\t\tdiscard_pending_return(cstack->cs_rettv[cstack->cs_idx]);\n\t    }\n\t    if (pending == CSTP_ERROR && !did_emsg)\n\t\tpending |= (THROW_ON_ERROR) ? CSTP_THROW : 0;\n\t    else\n\t\tpending |= did_throw ? CSTP_THROW : 0;\n\t    pending |= did_emsg  ? CSTP_ERROR     : 0;\n\t    pending |= got_int   ? CSTP_INTERRUPT : 0;\n\t    cstack->cs_pending[cstack->cs_idx] = pending;\n\n\t    // It's mandatory that the current exception is stored in the\n\t    // cstack so that it can be rethrown at the \":endtry\" or be\n\t    // discarded if the finally clause is left by a \":continue\",\n\t    // \":break\", \":return\", \":finish\", error, interrupt, or another\n\t    // exception.  When emsg() is called for a missing \":endif\" or\n\t    // a missing \":endwhile\"/\":endfor\" detected here, the\n\t    // exception will be discarded.\n\t    if (did_throw && cstack->cs_exception[cstack->cs_idx]\n\t\t\t\t\t\t     != current_exception)\n\t\tinternal_error(\"ex_finally()\");\n\t}\n\n\t/*\n\t * Set CSL_HAD_FINA, so do_cmdline() will reset did_emsg,\n\t * got_int, and did_throw and make the finally clause active.\n\t * This will happen after emsg() has been called for a missing\n\t * \":endif\" or a missing \":endwhile\"/\":endfor\" detected here, so\n\t * that the following finally clause will be executed even then.\n\t */\n\tcstack->cs_lflags |= CSL_HAD_FINA;\n    }\n}\n\n/*\n * \":endtry\"\n */\n    void\nex_endtry(exarg_T *eap)\n{\n    int\t\tidx;\n    int\t\tskip;\n    int\t\trethrow = FALSE;\n    int\t\tpending = CSTP_NONE;\n    void\t*rettv = NULL;\n    cstack_T\t*cstack = eap->cstack;\n\n    if (cmdmod_error(FALSE))\n\treturn;\n\n    for (idx = cstack->cs_idx; idx >= 0; --idx)\n\tif (cstack->cs_flags[idx] & CSF_TRY)\n\t    break;\n    if (cstack->cs_trylevel <= 0 || idx < 0)\n    {\n\teap->errmsg = _(e_endtry_without_try);\n\treturn;\n    }\n\n    /*\n     * Don't do something after an error, interrupt or throw in the try\n     * block, catch clause, or finally clause preceding this \":endtry\" or\n     * when an error or interrupt occurred after a \":continue\", \":break\",\n     * \":return\", or \":finish\" in a try block or catch clause preceding this\n     * \":endtry\" or when the try block never got active (because of an\n     * inactive surrounding conditional or after an error or interrupt or\n     * throw) or when there is a surrounding conditional and it has been\n     * made inactive by a \":continue\", \":break\", \":return\", or \":finish\" in\n     * the finally clause.  The latter case need not be tested since then\n     * anything pending has already been discarded. */\n    skip = did_emsg || got_int || did_throw\n\t\t\t     || !(cstack->cs_flags[cstack->cs_idx] & CSF_TRUE);\n\n    if (!(cstack->cs_flags[cstack->cs_idx] & CSF_TRY))\n    {\n\teap->errmsg = get_end_emsg(cstack);\n\n\t// Find the matching \":try\" and report what's missing.\n\trewind_conditionals(cstack, idx, CSF_WHILE | CSF_FOR,\n\t\t\t\t\t\t\t&cstack->cs_looplevel);\n\tskip = TRUE;\n\n\t/*\n\t * If an exception is being thrown, discard it to prevent it from\n\t * being rethrown at the end of this function.  It would be\n\t * discarded by the error message, anyway.  Resets did_throw.\n\t * This does not affect the script termination due to the error\n\t * since \"trylevel\" is decremented after emsg() has been called.\n\t */\n\tif (did_throw)\n\t    discard_current_exception();\n\n\t// report eap->errmsg, also when there already was an error\n\tdid_emsg = FALSE;\n    }\n    else\n    {\n\tidx = cstack->cs_idx;\n\n\t// Check the flags only when not in a skipped block.\n\tif (!skip && in_vim9script()\n\t\t     && (cstack->cs_flags[idx] & (CSF_CATCH|CSF_FINALLY)) == 0)\n\t{\n\t    // try/endtry without any catch or finally: give an error and\n\t    // continue.\n\t    eap->errmsg = _(e_missing_catch_or_finally);\n\t}\n\n\t/*\n\t * If we stopped with the exception currently being thrown at this\n\t * try conditional since we didn't know that it doesn't have\n\t * a finally clause, we need to rethrow it after closing the try\n\t * conditional.\n\t */\n\tif (did_throw && (cstack->cs_flags[idx] & CSF_TRUE)\n\t\t&& !(cstack->cs_flags[idx] & CSF_FINALLY))\n\t    rethrow = TRUE;\n    }\n\n    // If there was no finally clause, show the user when debugging or\n    // a breakpoint was encountered that the end of the try conditional has\n    // been reached: display the debug prompt (if not already done).  Do\n    // this on normal control flow or when an exception was thrown, but not\n    // on an interrupt or error not converted to an exception or when\n    // a \":break\", \":continue\", \":return\", or \":finish\" is pending.  These\n    // actions are carried out immediately.\n    if ((rethrow || (!skip && !(cstack->cs_flags[idx] & CSF_FINALLY)\n\t\t    && !cstack->cs_pending[idx]))\n\t    && dbg_check_skipped(eap))\n    {\n\t// Handle a \">quit\" debug command as if an interrupt had occurred\n\t// before the \":endtry\".  That is, throw an interrupt exception and\n\t// set \"skip\" and \"rethrow\".\n\tif (got_int)\n\t{\n\t    skip = TRUE;\n\t    (void)do_intthrow(cstack);\n\t    // The do_intthrow() call may have reset did_throw or\n\t    // cstack->cs_pending[idx].\n\t    rethrow = FALSE;\n\t    if (did_throw && !(cstack->cs_flags[idx] & CSF_FINALLY))\n\t\trethrow = TRUE;\n\t}\n    }\n\n    /*\n     * If a \":return\" is pending, we need to resume it after closing the\n     * try conditional; remember the return value.  If there was a finally\n     * clause making an exception pending, we need to rethrow it.  Make it\n     * the exception currently being thrown.\n     */\n    if (!skip)\n    {\n\tpending = cstack->cs_pending[idx];\n\tcstack->cs_pending[idx] = CSTP_NONE;\n\tif (pending == CSTP_RETURN)\n\t    rettv = cstack->cs_rettv[idx];\n\telse if (pending & CSTP_THROW)\n\t    current_exception = cstack->cs_exception[idx];\n    }\n\n    /*\n     * Discard anything pending on an error, interrupt, or throw in the\n     * finally clause.  If there was no \":finally\", discard a pending\n     * \":continue\", \":break\", \":return\", or \":finish\" if an error or\n     * interrupt occurred afterwards, but before the \":endtry\" was reached.\n     * If an exception was caught by the last of the catch clauses and there\n     * was no finally clause, finish the exception now.  This happens also\n     * after errors except when this \":endtry\" is not within a \":try\".\n     * Restore \"emsg_silent\" if it has been reset by this try conditional.\n     */\n    (void)cleanup_conditionals(cstack, CSF_TRY | CSF_SILENT, TRUE);\n\n    if (cstack->cs_idx >= 0 && (cstack->cs_flags[cstack->cs_idx] & CSF_TRY))\n\tleave_block(cstack);\n    --cstack->cs_trylevel;\n\n    if (!skip)\n    {\n\treport_resume_pending(pending,\n\t\t    (pending == CSTP_RETURN) ? rettv :\n\t\t    (pending & CSTP_THROW) ? (void *)current_exception : NULL);\n\tswitch (pending)\n\t{\n\t    case CSTP_NONE:\n\t\tbreak;\n\n\t    // Reactivate a pending \":continue\", \":break\", \":return\",\n\t    // \":finish\" from the try block or a catch clause of this try\n\t    // conditional.  This is skipped, if there was an error in an\n\t    // (unskipped) conditional command or an interrupt afterwards\n\t    // or if the finally clause is present and executed a new error,\n\t    // interrupt, throw, \":continue\", \":break\", \":return\", or\n\t    // \":finish\".\n\t    case CSTP_CONTINUE:\n\t\tex_continue(eap);\n\t\tbreak;\n\t    case CSTP_BREAK:\n\t\tex_break(eap);\n\t\tbreak;\n\t    case CSTP_RETURN:\n\t\tdo_return(eap, FALSE, FALSE, rettv);\n\t\tbreak;\n\t    case CSTP_FINISH:\n\t\tdo_finish(eap, FALSE);\n\t\tbreak;\n\n\t    // When the finally clause was entered due to an error,\n\t    // interrupt or throw (as opposed to a \":continue\", \":break\",\n\t    // \":return\", or \":finish\"), restore the pending values of\n\t    // did_emsg, got_int, and did_throw.  This is skipped, if there\n\t    // was a new error, interrupt, throw, \":continue\", \":break\",\n\t    // \":return\", or \":finish\".  in the finally clause.\n\t    default:\n\t\tif (pending & CSTP_ERROR)\n\t\t    did_emsg = TRUE;\n\t\tif (pending & CSTP_INTERRUPT)\n\t\t    got_int = TRUE;\n\t\tif (pending & CSTP_THROW)\n\t\t    rethrow = TRUE;\n\t\tbreak;\n\t}\n    }\n\n    if (rethrow)\n\t// Rethrow the current exception (within this cstack).\n\tdo_throw(cstack);\n}\n\n/*\n * enter_cleanup() and leave_cleanup()\n *\n * Functions to be called before/after invoking a sequence of autocommands for\n * cleanup for a failed command.  (Failure means here that a call to emsg()\n * has been made, an interrupt occurred, or there is an uncaught exception\n * from a previous autocommand execution of the same command.)\n *\n * Call enter_cleanup() with a pointer to a cleanup_T and pass the same\n * pointer to leave_cleanup().  The cleanup_T structure stores the pending\n * error/interrupt/exception state.\n */\n\n/*\n * This function works a bit like ex_finally() except that there was not\n * actually an extra try block around the part that failed and an error or\n * interrupt has not (yet) been converted to an exception.  This function\n * saves the error/interrupt/ exception state and prepares for the call to\n * do_cmdline() that is going to be made for the cleanup autocommand\n * execution.\n */\n    void\nenter_cleanup(cleanup_T *csp)\n{\n    int\t\tpending = CSTP_NONE;\n\n    /*\n     * Postpone did_emsg, got_int, did_throw.  The pending values will be\n     * restored by leave_cleanup() except if there was an aborting error,\n     * interrupt, or uncaught exception after this function ends.\n     */\n    if (did_emsg || got_int || did_throw || need_rethrow)\n    {\n\tcsp->pending = (did_emsg     ? CSTP_ERROR     : 0)\n\t\t     | (got_int      ? CSTP_INTERRUPT : 0)\n\t\t     | (did_throw    ? CSTP_THROW     : 0)\n\t\t     | (need_rethrow ? CSTP_THROW     : 0);\n\n\t// If we are currently throwing an exception (did_throw), save it as\n\t// well.  On an error not yet converted to an exception, update\n\t// \"force_abort\" and reset \"cause_abort\" (as do_errthrow() would do).\n\t// This is needed for the do_cmdline() call that is going to be made\n\t// for autocommand execution.  We need not save *msg_list because\n\t// there is an extra instance for every call of do_cmdline(), anyway.\n\tif (did_throw || need_rethrow)\n\t{\n\t    csp->exception = current_exception;\n\t    current_exception = NULL;\n\t}\n\telse\n\t{\n\t    csp->exception = NULL;\n\t    if (did_emsg)\n\t    {\n\t\tforce_abort |= cause_abort;\n\t\tcause_abort = FALSE;\n\t    }\n\t}\n\tdid_emsg = got_int = did_throw = need_rethrow = FALSE;\n\n\t// Report if required by the 'verbose' option or when debugging.\n\treport_make_pending(pending, csp->exception);\n    }\n    else\n    {\n\tcsp->pending = CSTP_NONE;\n\tcsp->exception = NULL;\n    }\n}\n\n/*\n * See comment above enter_cleanup() for how this function is used.\n *\n * This function is a bit like ex_endtry() except that there was not actually\n * an extra try block around the part that failed and an error or interrupt\n * had not (yet) been converted to an exception when the cleanup autocommand\n * sequence was invoked.\n *\n * This function has to be called with the address of the cleanup_T structure\n * filled by enter_cleanup() as an argument; it restores the error/interrupt/\n * exception state saved by that function - except there was an aborting\n * error, an interrupt or an uncaught exception during execution of the\n * cleanup autocommands.  In the latter case, the saved error/interrupt/\n * exception state is discarded.\n */\n    void\nleave_cleanup(cleanup_T *csp)\n{\n    int\t\tpending = csp->pending;\n\n    if (pending == CSTP_NONE)\t// nothing to do\n\treturn;\n\n    // If there was an aborting error, an interrupt, or an uncaught exception\n    // after the corresponding call to enter_cleanup(), discard what has been\n    // made pending by it.  Report this to the user if required by the\n    // 'verbose' option or when debugging.\n    if (aborting() || need_rethrow)\n    {\n\tif (pending & CSTP_THROW)\n\t    // Cancel the pending exception (includes report).\n\t    discard_exception(csp->exception, FALSE);\n\telse\n\t    report_discard_pending(pending, NULL);\n\n\t// If an error was about to be converted to an exception when\n\t// enter_cleanup() was called, free the message list.\n\tif (msg_list != NULL)\n\t    free_global_msglist();\n    }\n\n    /*\n     * If there was no new error, interrupt, or throw between the calls\n     * to enter_cleanup() and leave_cleanup(), restore the pending\n     * error/interrupt/exception state.\n     */\n    else\n    {\n\t/*\n\t * If there was an exception being thrown when enter_cleanup() was\n\t * called, we need to rethrow it.  Make it the exception currently\n\t * being thrown.\n\t */\n\tif (pending & CSTP_THROW)\n\t    current_exception = csp->exception;\n\n\t/*\n\t * If an error was about to be converted to an exception when\n\t * enter_cleanup() was called, let \"cause_abort\" take the part of\n\t * \"force_abort\" (as done by cause_errthrow()).\n\t */\n\telse if (pending & CSTP_ERROR)\n\t{\n\t    cause_abort = force_abort;\n\t    force_abort = FALSE;\n\t}\n\n\t/*\n\t * Restore the pending values of did_emsg, got_int, and did_throw.\n\t */\n\tif (pending & CSTP_ERROR)\n\t    did_emsg = TRUE;\n\tif (pending & CSTP_INTERRUPT)\n\t    got_int = TRUE;\n\tif (pending & CSTP_THROW)\n\t    need_rethrow = TRUE;    // did_throw will be set by do_one_cmd()\n\n\t// Report if required by the 'verbose' option or when debugging.\n\treport_resume_pending(pending,\n\t\t   (pending & CSTP_THROW) ? (void *)current_exception : NULL);\n    }\n}\n\n\n/*\n * Make conditionals inactive and discard what's pending in finally clauses\n * until the conditional type searched for or a try conditional not in its\n * finally clause is reached.  If this is in an active catch clause, finish\n * the caught exception.\n * Return the cstack index where the search stopped.\n * Values used for \"searched_cond\" are (CSF_WHILE | CSF_FOR) or CSF_TRY or 0,\n * the latter meaning the innermost try conditional not in its finally clause.\n * \"inclusive\" tells whether the conditional searched for should be made\n * inactive itself (a try conditional not in its finally clause possibly find\n * before is always made inactive).  If \"inclusive\" is TRUE and\n * \"searched_cond\" is CSF_TRY|CSF_SILENT, the saved former value of\n * \"emsg_silent\", if reset when the try conditional finally reached was\n * entered, is restored (used by ex_endtry()).  This is normally done only\n * when such a try conditional is left.\n */\n    int\ncleanup_conditionals(\n    cstack_T   *cstack,\n    int\t\tsearched_cond,\n    int\t\tinclusive)\n{\n    int\t\tidx;\n    int\t\tstop = FALSE;\n\n    for (idx = cstack->cs_idx; idx >= 0; --idx)\n    {\n\tif (cstack->cs_flags[idx] & CSF_TRY)\n\t{\n\t    /*\n\t     * Discard anything pending in a finally clause and continue the\n\t     * search.  There may also be a pending \":continue\", \":break\",\n\t     * \":return\", or \":finish\" before the finally clause.  We must not\n\t     * discard it, unless an error or interrupt occurred afterwards.\n\t     */\n\t    if (did_emsg || got_int || (cstack->cs_flags[idx] & CSF_FINALLY))\n\t    {\n\t\tswitch (cstack->cs_pending[idx])\n\t\t{\n\t\t    case CSTP_NONE:\n\t\t\tbreak;\n\n\t\t    case CSTP_CONTINUE:\n\t\t    case CSTP_BREAK:\n\t\t    case CSTP_FINISH:\n\t\t\treport_discard_pending(cstack->cs_pending[idx], NULL);\n\t\t\tcstack->cs_pending[idx] = CSTP_NONE;\n\t\t\tbreak;\n\n\t\t    case CSTP_RETURN:\n\t\t\treport_discard_pending(CSTP_RETURN,\n\t\t\t\t\t\t      cstack->cs_rettv[idx]);\n\t\t\tdiscard_pending_return(cstack->cs_rettv[idx]);\n\t\t\tcstack->cs_pending[idx] = CSTP_NONE;\n\t\t\tbreak;\n\n\t\t    default:\n\t\t\tif (cstack->cs_flags[idx] & CSF_FINALLY)\n\t\t\t{\n\t\t\t    if ((cstack->cs_pending[idx] & CSTP_THROW)\n\t\t\t\t    && cstack->cs_exception[idx] != NULL)\n\t\t\t    {\n\t\t\t\t// Cancel the pending exception.  This is in the\n\t\t\t\t// finally clause, so that the stack of the\n\t\t\t\t// caught exceptions is not involved.\n\t\t\t\tdiscard_exception(\n\t\t\t\t\t(except_T *)cstack->cs_exception[idx],\n\t\t\t\t\tFALSE);\n\t\t\t    }\n\t\t\t    else\n\t\t\t\treport_discard_pending(cstack->cs_pending[idx],\n\t\t\t\t\tNULL);\n\t\t\t    cstack->cs_pending[idx] = CSTP_NONE;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t    }\n\n\t    /*\n\t     * Stop at a try conditional not in its finally clause.  If this try\n\t     * conditional is in an active catch clause, finish the caught\n\t     * exception.\n\t     */\n\t    if (!(cstack->cs_flags[idx] & CSF_FINALLY))\n\t    {\n\t\tif ((cstack->cs_flags[idx] & CSF_ACTIVE)\n\t\t\t&& (cstack->cs_flags[idx] & CSF_CAUGHT)\n\t\t\t&& !(cstack->cs_flags[idx] & CSF_FINISHED))\n\t\t{\n\t\t    finish_exception((except_T *)cstack->cs_exception[idx]);\n\t\t    cstack->cs_flags[idx] |= CSF_FINISHED;\n\t\t}\n\t\t// Stop at this try conditional - except the try block never\n\t\t// got active (because of an inactive surrounding conditional\n\t\t// or when the \":try\" appeared after an error or interrupt or\n\t\t// throw).\n\t\tif (cstack->cs_flags[idx] & CSF_TRUE)\n\t\t{\n\t\t    if (searched_cond == 0 && !inclusive)\n\t\t\tbreak;\n\t\t    stop = TRUE;\n\t\t}\n\t    }\n\t}\n\n\t// Stop on the searched conditional type (even when the surrounding\n\t// conditional is not active or something has been made pending).\n\t// If \"inclusive\" is TRUE and \"searched_cond\" is CSF_TRY|CSF_SILENT,\n\t// check first whether \"emsg_silent\" needs to be restored.\n\tif (cstack->cs_flags[idx] & searched_cond)\n\t{\n\t    if (!inclusive)\n\t\tbreak;\n\t    stop = TRUE;\n\t}\n\tcstack->cs_flags[idx] &= ~CSF_ACTIVE;\n\tif (stop && searched_cond != (CSF_TRY | CSF_SILENT))\n\t    break;\n\n\t/*\n\t * When leaving a try conditional that reset \"emsg_silent\" on its\n\t * entry after saving the original value, restore that value here and\n\t * free the memory used to store it.\n\t */\n\tif ((cstack->cs_flags[idx] & CSF_TRY)\n\t\t&& (cstack->cs_flags[idx] & CSF_SILENT))\n\t{\n\t    eslist_T\t*elem;\n\n\t    elem = cstack->cs_emsg_silent_list;\n\t    cstack->cs_emsg_silent_list = elem->next;\n\t    emsg_silent = elem->saved_emsg_silent;\n\t    vim_free(elem);\n\t    cstack->cs_flags[idx] &= ~CSF_SILENT;\n\t}\n\tif (stop)\n\t    break;\n    }\n    return idx;\n}\n\n/*\n * Return an appropriate error message for a missing endwhile/endfor/endif.\n */\n   static char *\nget_end_emsg(cstack_T *cstack)\n{\n    if (cstack->cs_flags[cstack->cs_idx] & CSF_WHILE)\n\treturn _(e_missing_endwhile);\n    if (cstack->cs_flags[cstack->cs_idx] & CSF_FOR)\n\treturn _(e_missing_endfor);\n    return _(e_missing_endif);\n}\n\n\n/*\n * Rewind conditionals until index \"idx\" is reached.  \"cond_type\" and\n * \"cond_level\" specify a conditional type and the address of a level variable\n * which is to be decremented with each skipped conditional of the specified\n * type.\n * Also free \"for info\" structures where needed.\n */\n    void\nrewind_conditionals(\n    cstack_T   *cstack,\n    int\t\tidx,\n    int\t\tcond_type,\n    int\t\t*cond_level)\n{\n    while (cstack->cs_idx > idx)\n    {\n\tif (cstack->cs_flags[cstack->cs_idx] & cond_type)\n\t    --*cond_level;\n\tif (cstack->cs_flags[cstack->cs_idx] & CSF_FOR)\n\t    free_for_info(cstack->cs_forinfo[cstack->cs_idx]);\n\tleave_block(cstack);\n    }\n}\n\n/*\n * \":endfunction\" or \":enddef\" when not after a \":function\"\n */\n    void\nex_endfunction(exarg_T *eap)\n{\n    if (eap->cmdidx == CMD_enddef)\n\tsemsg(_(e_str_not_inside_function), \":enddef\");\n    else\n\tsemsg(_(e_str_not_inside_function), \":endfunction\");\n}\n\n/*\n * Return TRUE if the string \"p\" looks like a \":while\" or \":for\" command.\n */\n    int\nhas_loop_cmd(char_u *p)\n{\n    int\t\tlen;\n\n    // skip modifiers, white space and ':'\n    for (;;)\n    {\n\twhile (*p == ' ' || *p == '\\t' || *p == ':')\n\t    ++p;\n\tlen = modifier_len(p);\n\tif (len == 0)\n\t    break;\n\tp += len;\n    }\n    if ((p[0] == 'w' && p[1] == 'h')\n\t    || (p[0] == 'f' && p[1] == 'o' && p[2] == 'r'))\n\treturn TRUE;\n    return FALSE;\n}\n\n#endif // FEAT_EVAL\n", "\" Test try-catch-finally exception handling\n\" Most of this was formerly in test49.\n\nsource check.vim\nsource shared.vim\nimport './vim9.vim' as v9\n\n\"-------------------------------------------------------------------------------\n\" Test environment\t\t\t\t\t\t\t    {{{1\n\"-------------------------------------------------------------------------------\n\ncom!\t\t   XpathINIT  let g:Xpath = ''\ncom! -nargs=1 -bar Xpath      let g:Xpath = g:Xpath . <args>\n\n\" Test 25:  Executing :finally clauses on normal control flow\t\t    {{{1\n\"\n\"\t    Control flow in a :try conditional should always fall through to its\n\"\t    :finally clause.  A :finally clause of a :try conditional inside an\n\"\t    inactive conditional should never be executed.\n\"-------------------------------------------------------------------------------\n\nfunc T25_F()\n  let loops = 3\n  while loops > 0\n    Xpath 'a' . loops\n    if loops >= 2\n      try\n        Xpath 'b' . loops\n        if loops == 2\n          try\n            Xpath 'c' . loops\n          finally\n            Xpath 'd' . loops\n          endtry\n        endif\n      finally\n        Xpath 'e' . loops\n        if loops == 2\n          try\n            Xpath 'f' . loops\n          final\n            Xpath 'g' . loops\n          endtry\n        endif\n      endtry\n    endif\n    Xpath 'h' . loops\n    let loops = loops - 1\n  endwhile\n  Xpath 'i'\nendfunc\n\n\" Also try using \"fina\" and \"final\" and \"finall\" as abbreviations.\nfunc T25_G()\n  if 1\n    try\n      Xpath 'A'\n      call T25_F()\n      Xpath 'B'\n    fina\n      Xpath 'C'\n    endtry\n  else\n    try\n      Xpath 'D'\n    finall\n      Xpath 'E'\n    endtry\n  endif\nendfunc\n\nfunc Test_finally()\n  XpathINIT\n  call T25_G()\n  call assert_equal('Aa3b3e3h3a2b2c2d2e2f2g2h2a1h1iBC', g:Xpath)\nendfunc\n\n\n\"-------------------------------------------------------------------------------\n\" Test 26:  Executing :finally clauses after :continue or :break\t    {{{1\n\"\n\"\t    For a :continue or :break dynamically enclosed in a :try/:endtry\n\"\t    region inside the next surrounding :while/:endwhile, if the\n\"\t    :continue/:break is before the :finally, the :finally clause is\n\"\t    executed first.  If the :continue/:break is after the :finally, the\n\"\t    :finally clause is broken (like an :if/:endif region).\n\"-------------------------------------------------------------------------------\n\nfunc T26_F()\n  try\n    let loops = 3\n    while loops > 0\n      try\n        try\n          if loops == 2\n            Xpath 'a' . loops\n            let loops = loops - 1\n            continue\n          elseif loops == 1\n            Xpath 'b' . loops\n            break\n            finish\n          endif\n          Xpath 'c' . loops\n        endtry\n      finally\n        Xpath 'd' . loops\n      endtry\n      Xpath 'e' . loops\n      let loops = loops - 1\n    endwhile\n    Xpath 'f'\n  finally\n    Xpath 'g'\n    let loops = 3\n    while loops > 0\n      try\n      finally\n        try\n          if loops == 2\n            Xpath 'h' . loops\n            let loops = loops - 1\n            continue\n          elseif loops == 1\n            Xpath 'i' . loops\n            break\n            finish\n          endif\n        endtry\n        Xpath 'j' . loops\n      endtry\n      Xpath 'k' . loops\n      let loops = loops - 1\n    endwhile\n    Xpath 'l'\n  endtry\n  Xpath 'm'\nendfunc\n\nfunc Test_finally_after_continue()\n  XpathINIT\n  call T26_F()\n  call assert_equal('c3d3e3a2d1b1d1fgj3k3h2i1lm', g:Xpath)\nendfunc\n\n\n\"-------------------------------------------------------------------------------\n\" Test 32:  Remembering the :return value on :finally\t\t\t    {{{1\n\"\n\"\t    If a :finally clause is executed due to a :return specifying\n\"\t    a value, this is the value visible to the caller if not overwritten\n\"\t    by a new :return in the :finally clause.  A :return without a value\n\"\t    in the :finally clause overwrites with value 0.\n\"-------------------------------------------------------------------------------\n\nfunc T32_F()\n  try\n    Xpath 'a'\n    try\n      Xpath 'b'\n      return \"ABCD\"\n      Xpath 'c'\n    finally\n      Xpath 'd'\n    endtry\n    Xpath 'e'\n  finally\n    Xpath 'f'\n  endtry\n  Xpath 'g'\nendfunc\n\nfunc T32_G()\n  try\n    Xpath 'h'\n    return 8\n    Xpath 'i'\n  finally\n    Xpath 'j'\n    return 16 + strlen(T32_F())\n    Xpath 'k'\n  endtry\n  Xpath 'l'\nendfunc\n\nfunc T32_H()\n  try\n    Xpath 'm'\n    return 32\n    Xpath 'n'\n  finally\n    Xpath 'o'\n    return\n    Xpath 'p'\n  endtry\n  Xpath 'q'\nendfunc\n\nfunc T32_I()\n  try\n    Xpath 'r'\n  finally\n    Xpath 's'\n    return T32_G() + T32_H() + 64\n    Xpath 't'\n  endtry\n  Xpath 'u'\nendfunc\n\nfunc Test_finally_return()\n  XpathINIT\n  call assert_equal(84, T32_I())\n  call assert_equal('rshjabdfmo', g:Xpath)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 33:  :return under :execute or user command and :finally\t\t    {{{1\n\"\n\"\t    A :return command may be executed under an \":execute\" or from\n\"\t    a user command.  Executing of :finally clauses and passing through\n\"\t    the return code works also then.\n\"-------------------------------------------------------------------------------\n\nfunc T33_F()\n  try\n    RETURN 10\n    Xpath 'a'\n  finally\n    Xpath 'b'\n  endtry\n  Xpath 'c'\nendfunc\n\nfunc T33_G()\n  try\n    RETURN 20\n    Xpath 'd'\n  finally\n    Xpath 'e'\n    RETURN 30\n    Xpath 'f'\n  endtry\n  Xpath 'g'\nendfunc\n\nfunc T33_H()\n  try\n    execute \"try | return 40 | finally | return 50 | endtry\"\n    Xpath 'h'\n  finally\n    Xpath 'i'\n  endtry\n  Xpath 'j'\nendfunc\n\nfunc T33_I()\n  try\n    execute \"try | return 60 | finally | return 70 | endtry\"\n    Xpath 'k'\n  finally\n    Xpath 'l'\n    execute \"try | return 80 | finally | return 90 | endtry\"\n    Xpath 'm'\n  endtry\n  Xpath 'n'\nendfunc\n\nfunc T33_J()\n  try\n    RETURN 100\n    Xpath 'o'\n  finally\n    Xpath 'p'\n    return\n    Xpath 'q'\n  endtry\n  Xpath 'r'\nendfunc\n\nfunc T33_K()\n  try\n    execute \"try | return 110 | finally | return 120 | endtry\"\n    Xpath 's'\n  finally\n    Xpath 't'\n    execute \"try | return 130 | finally | return | endtry\"\n    Xpath 'u'\n  endtry\n  Xpath 'v'\nendfunc\n\nfunc T33_L()\n  try\n    return\n    Xpath 'w'\n  finally\n    Xpath 'x'\n    RETURN 140\n    Xpath 'y'\n  endtry\n  Xpath 'z'\nendfunc\n\nfunc T33_M()\n  try\n    return\n    Xpath 'A'\n  finally\n    Xpath 'B'\n    execute \"try | return 150 | finally | return 160 | endtry\"\n    Xpath 'C'\n  endtry\n  Xpath 'D'\nendfunc\n\nfunc T33_N()\n  RETURN 170\nendfunc\n\nfunc T33_O()\n  execute \"try | return 180 | finally | return 190 | endtry\"\nendfunc\n\nfunc Test_finally_cmd_return()\n  command! -nargs=? RETURN\n        \\ try | return <args> | finally | return <args> * 2 | endtry\n  XpathINIT\n  call assert_equal(20, T33_F())\n  call assert_equal(60, T33_G())\n  call assert_equal(50, T33_H())\n  call assert_equal(90, T33_I())\n  call assert_equal(0, T33_J())\n  call assert_equal(0, T33_K())\n  call assert_equal(280, T33_L())\n  call assert_equal(160, T33_M())\n  call assert_equal(340, T33_N())\n  call assert_equal(190, T33_O())\n  call assert_equal('beilptxB', g:Xpath)\n  delcommand RETURN\nendfunc\n\n\n\"-------------------------------------------------------------------------------\n\" Test 41:  Skipped :throw finding next command\t\t\t\t    {{{1\n\"\n\"\t    A :throw in an inactive conditional must not hide a following\n\"\t    command.\n\"-------------------------------------------------------------------------------\n\nfunc T41_F()\n  Xpath 'a'\n  if 0 | throw 'never' | endif | Xpath 'b'\n  Xpath 'c'\nendfunc\n\nfunc T41_G()\n  Xpath 'd'\n  while 0 | throw 'never' | endwhile | Xpath 'e'\n  Xpath 'f'\nendfunc\n\nfunc T41_H()\n  Xpath 'g'\n  if 0 | try | throw 'never' | endtry | endif | Xpath 'h'\n  Xpath 'i'\nendfunc\n\nfunc Test_throw_inactive_cond()\n  XpathINIT\n  try\n    Xpath 'j'\n    call T41_F()\n    Xpath 'k'\n  catch /.*/\n    Xpath 'l'\n    call assert_report('Caught ' . v:exception . ' in ' . v:throwpoint)\n  endtry\n\n  try\n    Xpath 'm'\n    call T41_G()\n    Xpath 'n'\n  catch /.*/\n    Xpath 'o'\n    call assert_report('Caught ' . v:exception . ' in ' . v:throwpoint)\n  endtry\n\n  try\n    Xpath 'p'\n    call T41_H()\n    Xpath 'q'\n  catch /.*/\n    Xpath 'r'\n    call assert_report('Caught ' . v:exception . ' in ' . v:throwpoint)\n  endtry\n\n  call assert_equal('jabckmdefnpghiq', g:Xpath)\nendfunc\n\n\n\"-------------------------------------------------------------------------------\n\" Test 42:  Catching number and string exceptions\t\t\t    {{{1\n\"\n\"\t    When a number is thrown, it is converted to a string exception.\n\"\t    Numbers and strings may be caught by specifying a regular exception\n\"\t    as argument to the :catch command.\n\"-------------------------------------------------------------------------------\n\n\nfunc T42_F()\n  try\n\n    try\n      Xpath 'a'\n      throw 4711\n      Xpath 'b'\n    catch /4711/\n      Xpath 'c'\n    endtry\n\n    try\n      Xpath 'd'\n      throw 4711\n      Xpath 'e'\n    catch /^4711$/\n      Xpath 'f'\n    endtry\n\n    try\n      Xpath 'g'\n      throw 4711\n      Xpath 'h'\n    catch /\\d/\n      Xpath 'i'\n    endtry\n\n    try\n      Xpath 'j'\n      throw 4711\n      Xpath 'k'\n    catch /^\\d\\+$/\n      Xpath 'l'\n    endtry\n\n    try\n      Xpath 'm'\n      throw \"arrgh\"\n      Xpath 'n'\n    catch /arrgh/\n      Xpath 'o'\n    endtry\n\n    try\n      Xpath 'p'\n      throw \"arrgh\"\n      Xpath 'q'\n    catch /^arrgh$/\n      Xpath 'r'\n    endtry\n\n    try\n      Xpath 's'\n      throw \"arrgh\"\n      Xpath 't'\n    catch /\\l/\n      Xpath 'u'\n    endtry\n\n    try\n      Xpath 'v'\n      throw \"arrgh\"\n      Xpath 'w'\n    catch /^\\l\\+$/\n      Xpath 'x'\n    endtry\n\n    try\n      try\n        Xpath 'y'\n        throw \"ARRGH\"\n        Xpath 'z'\n      catch /^arrgh$/\n        Xpath 'A'\n      endtry\n    catch /^\\carrgh$/\n      Xpath 'B'\n    endtry\n\n    try\n      Xpath 'C'\n      throw \"\"\n      Xpath 'D'\n    catch /^$/\n      Xpath 'E'\n    endtry\n\n  catch /.*/\n    Xpath 'F'\n    call assert_report('Caught ' . v:exception . ' in ' . v:throwpoint)\n  endtry\nendfunc\n\nfunc Test_catch_number_string()\n  XpathINIT\n  call T42_F()\n  call assert_equal('acdfgijlmoprsuvxyBCE', g:Xpath)\nendfunc\n\n\n\"-------------------------------------------------------------------------------\n\" Test 43:  Selecting the correct :catch clause\t\t\t\t    {{{1\n\"\n\"\t    When an exception is thrown and there are multiple :catch clauses,\n\"\t    the first matching one is taken.\n\"-------------------------------------------------------------------------------\n\nfunc T43_F()\n  let loops = 3\n  while loops > 0\n    try\n      if loops == 3\n        Xpath 'a' . loops\n        throw \"a\"\n        Xpath 'b' . loops\n      elseif loops == 2\n        Xpath 'c' . loops\n        throw \"ab\"\n        Xpath 'd' . loops\n      elseif loops == 1\n        Xpath 'e' . loops\n        throw \"abc\"\n        Xpath 'f' . loops\n      endif\n    catch /abc/\n      Xpath 'g' . loops\n    catch /ab/\n      Xpath 'h' . loops\n    catch /.*/\n      Xpath 'i' . loops\n    catch /a/\n      Xpath 'j' . loops\n    endtry\n\n    let loops = loops - 1\n  endwhile\n  Xpath 'k'\nendfunc\n\nfunc Test_multi_catch()\n  XpathINIT\n  call T43_F()\n  call assert_equal('a3i3c2h2e1g1k', g:Xpath)\nendfunc\n\n\n\"-------------------------------------------------------------------------------\n\" Test 44:  Missing or empty :catch patterns\t\t\t\t    {{{1\n\"\n\"\t    A missing or empty :catch pattern means the same as /.*/, that is,\n\"\t    catches everything.  To catch only empty exceptions, /^$/ must be\n\"\t    used.  A :catch with missing, empty, or /.*/ argument also works\n\"\t    when followed by another command separated by a bar on the same\n\"\t    line.  :catch patterns cannot be specified between ||.  But other\n\"\t    pattern separators can be used instead of //.\n\"-------------------------------------------------------------------------------\n\nfunc T44_F()\n  try\n    try\n      Xpath 'a'\n      throw \"\"\n    catch /^$/\n      Xpath 'b'\n    endtry\n\n    try\n      Xpath 'c'\n      throw \"\"\n    catch /.*/\n      Xpath 'd'\n    endtry\n\n    try\n      Xpath 'e'\n      throw \"\"\n    catch //\n      Xpath 'f'\n    endtry\n\n    try\n      Xpath 'g'\n      throw \"\"\n    catch\n      Xpath 'h'\n    endtry\n\n    try\n      Xpath 'i'\n      throw \"oops\"\n    catch /^$/\n      Xpath 'j'\n    catch /.*/\n      Xpath 'k'\n    endtry\n\n    try\n      Xpath 'l'\n      throw \"arrgh\"\n    catch /^$/\n      Xpath 'm'\n    catch //\n      Xpath 'n'\n    endtry\n\n    try\n      Xpath 'o'\n      throw \"brrr\"\n    catch /^$/\n      Xpath 'p'\n    catch\n      Xpath 'q'\n    endtry\n\n    try | Xpath 'r' | throw \"x\" | catch /.*/ | Xpath 's' | endtry\n\n    try | Xpath 't' | throw \"y\" | catch // | Xpath 'u' | endtry\n\n    while 1\n      try\n        let caught = 0\n        let v:errmsg = \"\"\n        \" Extra try level:  if \":catch\" without arguments below raises\n        \" a syntax error because it misinterprets the \"Xpath\" as a pattern,\n        \" let it be caught by the \":catch /.*/\" below.\n        try\n          try | Xpath 'v' | throw \"z\" | catch | Xpath 'w' | :\n          endtry\n        endtry\n      catch /.*/\n        let caught = 1\n        call assert_report('Caught ' . v:exception . ' in ' . v:throwpoint)\n      finally\n        if $VIMNOERRTHROW && v:errmsg != \"\"\n          call assert_report(v:errmsg)\n        endif\n        if caught || $VIMNOERRTHROW && v:errmsg != \"\"\n          Xpath 'x'\n        endif\n        break\t\t\" discard error for $VIMNOERRTHROW\n      endtry\n    endwhile\n\n    let cologne = 4711\n    try\n      try\n        Xpath 'y'\n        throw \"throw cologne\"\n        \" Next lines catches all and throws 4711:\n      catch |throw cologne|\n        Xpath 'z'\n      endtry\n    catch /4711/\n      Xpath 'A'\n    endtry\n\n    try\n      Xpath 'B'\n      throw \"plus\"\n    catch +plus+\n      Xpath 'C'\n    endtry\n\n    Xpath 'D'\n  catch /.*/\n    Xpath 'E'\n    call assert_report('Caught ' . v:exception . ' in ' . v:throwpoint)\n  endtry\nendfunc\n\nfunc Test_empty_catch()\n  XpathINIT\n  call T44_F()\n  call assert_equal('abcdefghiklnoqrstuvwyABCD', g:Xpath)\nendfunc\n\n\n\"-------------------------------------------------------------------------------\n\" Test 45:  Catching exceptions from nested :try blocks\t\t\t    {{{1\n\"\n\"\t    When :try blocks are nested, an exception is caught by the innermost\n\"\t    try conditional that has a matching :catch clause.\n\"-------------------------------------------------------------------------------\n\nfunc T45_F()\n  let loops = 3\n  while loops > 0\n    try\n      try\n        try\n          try\n            if loops == 3\n              Xpath 'a' . loops\n              throw \"a\"\n              Xpath 'b' . loops\n            elseif loops == 2\n              Xpath 'c' . loops\n              throw \"ab\"\n              Xpath 'd' . loops\n            elseif loops == 1\n              Xpath 'e' . loops\n              throw \"abc\"\n              Xpath 'f' . loops\n            endif\n          catch /abc/\n            Xpath 'g' . loops\n          endtry\n        catch /ab/\n          Xpath 'h' . loops\n        endtry\n      catch /.*/\n        Xpath 'i' . loops\n      endtry\n    catch /a/\n      Xpath 'j' . loops\n    endtry\n\n    let loops = loops - 1\n  endwhile\n  Xpath 'k'\nendfunc\n\nfunc Test_catch_from_nested_try()\n  XpathINIT\n  call T45_F()\n  call assert_equal('a3i3c2h2e1g1k', g:Xpath)\nendfunc\n\n\n\"-------------------------------------------------------------------------------\n\" Test 46:  Executing :finally after a :throw in nested :try\t\t    {{{1\n\"\n\"\t    When an exception is thrown from within nested :try blocks, the\n\"\t    :finally clauses of the non-catching try conditionals should be\n\"\t    executed before the matching :catch of the next surrounding :try\n\"\t    gets the control.  If this also has a :finally clause, it is\n\"\t    executed afterwards.\n\"-------------------------------------------------------------------------------\n\nfunc T46_F()\n  let sum = 0\n\n  try\n    Xpath 'a'\n    try\n      Xpath 'b'\n      try\n        Xpath 'c'\n        try\n          Xpath 'd'\n          throw \"ABC\"\n          Xpath 'e'\n        catch /xyz/\n          Xpath 'f'\n        finally\n          Xpath 'g'\n          if sum != 0\n            Xpath 'h'\n          endif\n          let sum = sum + 1\n        endtry\n        Xpath 'i'\n      catch /123/\n        Xpath 'j'\n      catch /321/\n        Xpath 'k'\n      finally\n        Xpath 'l'\n        if sum != 1\n          Xpath 'm'\n        endif\n        let sum = sum + 2\n      endtry\n      Xpath 'n'\n    finally\n      Xpath 'o'\n      if sum != 3\n        Xpath 'p'\n      endif\n      let sum = sum + 4\n    endtry\n    Xpath 'q'\n  catch /ABC/\n    Xpath 'r'\n    if sum != 7\n      Xpath 's'\n    endif\n    let sum = sum + 8\n  finally\n    Xpath 't'\n    if sum != 15\n      Xpath 'u'\n    endif\n    let sum = sum + 16\n  endtry\n  Xpath 'v'\n  if sum != 31\n    Xpath 'w'\n  endif\nendfunc\n\nfunc Test_finally_after_throw()\n  XpathINIT\n  call T46_F()\n  call assert_equal('abcdglortv', g:Xpath)\nendfunc\n\n\n\"-------------------------------------------------------------------------------\n\" Test 47:  Throwing exceptions from a :catch clause\t\t\t    {{{1\n\"\n\"\t    When an exception is thrown from a :catch clause, it should not be\n\"\t    caught by a :catch of the same :try conditional.  After executing\n\"\t    the :finally clause (if present), surrounding try conditionals\n\"\t    should be checked for a matching :catch.\n\"-------------------------------------------------------------------------------\n\nfunc T47_F()\n  Xpath 'a'\n  try\n    Xpath 'b'\n    try\n      Xpath 'c'\n      try\n        Xpath 'd'\n        throw \"x1\"\n        Xpath 'e'\n      catch /x1/\n        Xpath 'f'\n        try\n          Xpath 'g'\n          throw \"x2\"\n          Xpath 'h'\n        catch /x1/\n          Xpath 'i'\n        catch /x2/\n          Xpath 'j'\n          try\n            Xpath 'k'\n            throw \"x3\"\n            Xpath 'l'\n          catch /x1/\n            Xpath 'm'\n          catch /x2/\n            Xpath 'n'\n          finally\n            Xpath 'o'\n          endtry\n          Xpath 'p'\n        catch /x3/\n          Xpath 'q'\n        endtry\n        Xpath 'r'\n      catch /x1/\n        Xpath 's'\n      catch /x2/\n        Xpath 't'\n      catch /x3/\n        Xpath 'u'\n      finally\n        Xpath 'v'\n      endtry\n      Xpath 'w'\n    catch /x1/\n      Xpath 'x'\n    catch /x2/\n      Xpath 'y'\n    catch /x3/\n      Xpath 'z'\n    endtry\n    Xpath 'A'\n  catch /.*/\n    Xpath 'B'\n    call assert_report('Caught ' . v:exception . ' in ' . v:throwpoint)\n  endtry\n  Xpath 'C'\nendfunc\n\nfunc Test_throw_from_catch()\n  XpathINIT\n  call T47_F()\n  call assert_equal('abcdfgjkovzAC', g:Xpath)\nendfunc\n\n\n\"-------------------------------------------------------------------------------\n\" Test 48:  Throwing exceptions from a :finally clause\t\t\t    {{{1\n\"\n\"\t    When an exception is thrown from a :finally clause, it should not be\n\"\t    caught by a :catch of the same :try conditional.  Surrounding try\n\"\t    conditionals should be checked for a matching :catch.  A previously\n\"\t    thrown exception is discarded.\n\"-------------------------------------------------------------------------------\n\nfunc T48_F()\n  try\n\n    try\n      try\n        Xpath 'a'\n      catch /x1/\n        Xpath 'b'\n      finally\n        Xpath 'c'\n        throw \"x1\"\n        Xpath 'd'\n      endtry\n      Xpath 'e'\n    catch /x1/\n      Xpath 'f'\n    endtry\n    Xpath 'g'\n\n    try\n      try\n        Xpath 'h'\n        throw \"x2\"\n        Xpath 'i'\n      catch /x2/\n        Xpath 'j'\n      catch /x3/\n        Xpath 'k'\n      finally\n        Xpath 'l'\n        throw \"x3\"\n        Xpath 'm'\n      endtry\n      Xpath 'n'\n    catch /x2/\n      Xpath 'o'\n    catch /x3/\n      Xpath 'p'\n    endtry\n    Xpath 'q'\n\n    try\n      try\n        try\n          Xpath 'r'\n          throw \"x4\"\n          Xpath 's'\n        catch /x5/\n          Xpath 't'\n        finally\n          Xpath 'u'\n          throw \"x5\"\t\" discards 'x4'\n          Xpath 'v'\n        endtry\n        Xpath 'w'\n      catch /x4/\n        Xpath 'x'\n      finally\n        Xpath 'y'\n      endtry\n      Xpath 'z'\n    catch /x5/\n      Xpath 'A'\n    endtry\n    Xpath 'B'\n\n  catch /.*/\n    Xpath 'C'\n    call assert_report('Caught ' . v:exception . ' in ' . v:throwpoint)\n  endtry\n  Xpath 'D'\nendfunc\n\nfunc Test_throw_from_finally()\n  XpathINIT\n  call T48_F()\n  call assert_equal('acfghjlpqruyABD', g:Xpath)\nendfunc\n\n\n\"-------------------------------------------------------------------------------\n\" Test 51:  Throwing exceptions across :execute and user commands\t    {{{1\n\"\n\"\t    A :throw command may be executed under an \":execute\" or from\n\"\t    a user command.\n\"-------------------------------------------------------------------------------\n\nfunc T51_F()\n  command! -nargs=? THROW1    throw <args> | throw 1\n  command! -nargs=? THROW2    try | throw <args> | endtry | throw 2\n  command! -nargs=? THROW3    try | throw 3 | catch /3/ | throw <args> | endtry\n  command! -nargs=? THROW4    try | throw 4 | finally   | throw <args> | endtry\n\n  try\n\n    try\n      try\n        Xpath 'a'\n        THROW1 \"A\"\n      catch /A/\n        Xpath 'b'\n      endtry\n    catch /1/\n      Xpath 'c'\n    endtry\n\n    try\n      try\n        Xpath 'd'\n        THROW2 \"B\"\n      catch /B/\n        Xpath 'e'\n      endtry\n    catch /2/\n      Xpath 'f'\n    endtry\n\n    try\n      try\n        Xpath 'g'\n        THROW3 \"C\"\n      catch /C/\n        Xpath 'h'\n      endtry\n    catch /3/\n      Xpath 'i'\n    endtry\n\n    try\n      try\n        Xpath 'j'\n        THROW4 \"D\"\n      catch /D/\n        Xpath 'k'\n      endtry\n    catch /4/\n      Xpath 'l'\n    endtry\n\n    try\n      try\n        Xpath 'm'\n        execute 'throw \"E\" | throw 5'\n      catch /E/\n        Xpath 'n'\n      endtry\n    catch /5/\n      Xpath 'o'\n    endtry\n\n    try\n      try\n        Xpath 'p'\n        execute 'try | throw \"F\" | endtry | throw 6'\n      catch /F/\n        Xpath 'q'\n      endtry\n    catch /6/\n      Xpath 'r'\n    endtry\n\n    try\n      try\n        Xpath 's'\n        execute'try | throw 7 | catch /7/ | throw \"G\" | endtry'\n      catch /G/\n        Xpath 't'\n      endtry\n    catch /7/\n      Xpath 'u'\n    endtry\n\n    try\n      try\n        Xpath 'v'\n        execute 'try | throw 8 | finally   | throw \"H\" | endtry'\n      catch /H/\n        Xpath 'w'\n      endtry\n    catch /8/\n      Xpath 'x'\n    endtry\n\n  catch /.*/\n    Xpath 'y'\n    call assert_report('Caught ' . v:exception . ' in ' . v:throwpoint)\n  endtry\n\n  Xpath 'z'\n\n  delcommand THROW1\n  delcommand THROW2\n  delcommand THROW3\n  delcommand THROW4\nendfunc\n\nfunc Test_throw_across_commands()\n  XpathINIT\n  call T51_F()\n  call assert_equal('abdeghjkmnpqstvwz', g:Xpath)\nendfunc\n\n\n\n\"-------------------------------------------------------------------------------\n\" Test 69:  :throw across :if, :elseif, :while\t\t\t\t    {{{1\n\"\n\"\t    On an :if, :elseif, or :while command, an exception might be thrown\n\"\t    during evaluation of the expression to test.  The exception can be\n\"\t    caught by the script.\n\"-------------------------------------------------------------------------------\n\nfunc T69_throw(x)\n  Xpath 'x'\n  throw a:x\nendfunc\n\nfunc Test_throw_ifelsewhile()\n  XpathINIT\n\n  try\n    try\n      Xpath 'a'\n      if 111 == T69_throw(\"if\") + 111\n        Xpath 'b'\n      else\n        Xpath 'c'\n      endif\n      Xpath 'd'\n    catch /^if$/\n      Xpath 'e'\n    catch /.*/\n      Xpath 'f'\n      call assert_report(\"if: \" . v:exception . \" in \" . v:throwpoint)\n    endtry\n\n    try\n      Xpath 'g'\n      if v:false\n        Xpath 'h'\n      elseif 222 == T69_throw(\"elseif\") + 222\n        Xpath 'i'\n      else\n        Xpath 'j'\n      endif\n      Xpath 'k'\n    catch /^elseif$/\n      Xpath 'l'\n    catch /.*/\n      Xpath 'm'\n      call assert_report(\"elseif: \" . v:exception . \" in \" . v:throwpoint)\n    endtry\n\n    try\n      Xpath 'n'\n      while 333 == T69_throw(\"while\") + 333\n        Xpath 'o'\n        break\n      endwhile\n      Xpath 'p'\n    catch /^while$/\n      Xpath 'q'\n    catch /.*/\n      Xpath 'r'\n      call assert_report(\"while: \" .. v:exception .. \" in \" .. v:throwpoint)\n    endtry\n  catch /^0$/\t    \" default return value\n    Xpath 's'\n    call assert_report(v:throwpoint)\n  catch /.*/\n    call assert_report(v:exception .. \" in \" .. v:throwpoint)\n    Xpath 't'\n  endtry\n\n  call assert_equal('axegxlnxq', g:Xpath)\nendfunc\n\n\n\"-------------------------------------------------------------------------------\n\" Test 70:  :throw across :return or :throw\t\t\t\t    {{{1\n\"\n\"\t    On a :return or :throw command, an exception might be thrown during\n\"\t    evaluation of the expression to return or throw, respectively.  The\n\"\t    exception can be caught by the script.\n\"-------------------------------------------------------------------------------\n\nlet T70_taken = \"\"\n\nfunc T70_throw(x, n)\n    let g:T70_taken = g:T70_taken . \"T\" . a:n\n    throw a:x\nendfunc\n\nfunc T70_F(x, y, n)\n    let g:T70_taken = g:T70_taken . \"F\" . a:n\n    return a:x + T70_throw(a:y, a:n)\nendfunc\n\nfunc T70_G(x, y, n)\n    let g:T70_taken = g:T70_taken . \"G\" . a:n\n    throw a:x . T70_throw(a:y, a:n)\n    return a:x\nendfunc\n\nfunc Test_throwreturn()\n  XpathINIT\n\n  try\n    try\n      Xpath 'a'\n      call T70_F(4711, \"return\", 1)\n      Xpath 'b'\n    catch /^return$/\n      Xpath 'c'\n    catch /.*/\n      Xpath 'd'\n      call assert_report(\"return: \" .. v:exception .. \" in \" .. v:throwpoint)\n    endtry\n\n    try\n      Xpath 'e'\n      let var = T70_F(4712, \"return-var\", 2)\n      Xpath 'f'\n    catch /^return-var$/\n      Xpath 'g'\n    catch /.*/\n      Xpath 'h'\n      call assert_report(\"return-var: \" . v:exception . \" in \" . v:throwpoint)\n    finally\n      unlet! var\n    endtry\n\n    try\n      Xpath 'i'\n      throw \"except1\" . T70_throw(\"throw1\", 3)\n      Xpath 'j'\n    catch /^except1/\n      Xpath 'k'\n    catch /^throw1$/\n      Xpath 'l'\n    catch /.*/\n      Xpath 'm'\n      call assert_report(\"throw1: \" .. v:exception .. \" in \" .. v:throwpoint)\n    endtry\n\n    try\n      Xpath 'n'\n      call T70_G(\"except2\", \"throw2\", 4)\n      Xpath 'o'\n    catch /^except2/\n      Xpath 'p'\n    catch /^throw2$/\n      Xpath 'q'\n    catch /.*/\n      Xpath 'r'\n      call assert_report(\"throw2: \" .. v:exception .. \" in \" .. v:throwpoint)\n    endtry\n\n    try\n      Xpath 's'\n      let var = T70_G(\"except3\", \"throw3\", 5)\n      Xpath 't'\n    catch /^except3/\n      Xpath 'u'\n    catch /^throw3$/\n      Xpath 'v'\n    catch /.*/\n      Xpath 'w'\n      call assert_report(\"throw3: \" .. v:exception .. \" in \" .. v:throwpoint)\n    finally\n      unlet! var\n    endtry\n\n    call assert_equal('F1T1F2T2T3G4T4G5T5', g:T70_taken)\n    Xpath 'x'\n  catch /^0$/\t    \" default return value\n    Xpath 'y'\n    call assert_report(v:throwpoint)\n  catch /.*/\n    Xpath 'z'\n    call assert_report('Caught' .. v:exception .. ' in ' .. v:throwpoint)\n  endtry\n\n  call assert_equal('acegilnqsvx', g:Xpath)\nendfunc\n\n\"-------------------------------------------------------------------------------\n\" Test 71:  :throw across :echo variants and :execute\t\t\t    {{{1\n\"\n\"\t    On an :echo, :echon, :echomsg, :echoerr, or :execute command, an\n\"\t    exception might be thrown during evaluation of the arguments to\n\"\t    be displayed or executed as a command, respectively.  Any following\n\"\t    arguments are not evaluated, then.  The exception can be caught by\n\"\t    the script.\n\"-------------------------------------------------------------------------------\n\nlet T71_taken = \"\"\n\nfunc T71_throw(x, n)\n    let g:T71_taken = g:T71_taken . \"T\" . a:n\n    throw a:x\nendfunc\n\nfunc T71_F(n)\n    let g:T71_taken = g:T71_taken . \"F\" . a:n\n    return \"F\" . a:n\nendfunc\n\nfunc Test_throw_echo()\n  XpathINIT\n\n  try\n    try\n      Xpath 'a'\n      echo 'echo ' . T71_throw(\"echo-except\", 1) . T71_F(1)\n      Xpath 'b'\n    catch /^echo-except$/\n      Xpath 'c'\n    catch /.*/\n      Xpath 'd'\n      call assert_report(\"echo: \" .. v:exception .. \" in \" .. v:throwpoint)\n    endtry\n\n    try\n      Xpath 'e'\n      echon \"echon \" . T71_throw(\"echon-except\", 2) . T71_F(2)\n      Xpath 'f'\n    catch /^echon-except$/\n      Xpath 'g'\n    catch /.*/\n      Xpath 'h'\n      call assert_report('echon: ' . v:exception . ' in ' . v:throwpoint)\n    endtry\n\n    try\n      Xpath 'i'\n      echomsg \"echomsg \" . T71_throw(\"echomsg-except\", 3) . T71_F(3)\n      Xpath 'j'\n    catch /^echomsg-except$/\n      Xpath 'k'\n    catch /.*/\n      Xpath 'l'\n      call assert_report('echomsg: ' . v:exception . ' in ' . v:throwpoint)\n    endtry\n\n    try\n      Xpath 'm'\n      echoerr \"echoerr \" . T71_throw(\"echoerr-except\", 4) . T71_F(4)\n      Xpath 'n'\n    catch /^echoerr-except$/\n      Xpath 'o'\n    catch /Vim/\n      Xpath 'p'\n    catch /echoerr/\n      Xpath 'q'\n    catch /.*/\n      Xpath 'r'\n      call assert_report('echoerr: ' . v:exception . ' in ' . v:throwpoint)\n    endtry\n\n    try\n      Xpath 's'\n      execute \"echo 'execute \" . T71_throw(\"execute-except\", 5) . T71_F(5) \"'\"\n      Xpath 't'\n    catch /^execute-except$/\n      Xpath 'u'\n    catch /.*/\n      Xpath 'v'\n      call assert_report('execute: ' . v:exception . ' in ' . v:throwpoint)\n    endtry\n\n    call assert_equal('T1T2T3T4T5', g:T71_taken)\n    Xpath 'w'\n  catch /^0$/\t    \" default return value\n    Xpath 'x'\n    call assert_report(v:throwpoint)\n  catch /.*/\n    Xpath 'y'\n    call assert_report('Caught ' . v:exception . ' in ' . v:throwpoint)\n  endtry\n\n  call assert_equal('acegikmosuw', g:Xpath)\nendfunc\n\n\n\"-------------------------------------------------------------------------------\n\" Test 72:  :throw across :let or :unlet\t\t\t\t    {{{1\n\"\n\"\t    On a :let command, an exception might be thrown during evaluation\n\"\t    of the expression to assign.  On an :let or :unlet command, the\n\"\t    evaluation of the name of the variable to be assigned or list or\n\"\t    deleted, respectively, may throw an exception.  Any following\n\"\t    arguments are not evaluated, then.  The exception can be caught by\n\"\t    the script.\n\"-------------------------------------------------------------------------------\n\nlet throwcount = 0\n\nfunc T72_throw(x)\n  let g:throwcount = g:throwcount + 1\n  throw a:x\nendfunc\n\nlet T72_addpath = ''\n\nfunc T72_addpath(p)\n  let g:T72_addpath = g:T72_addpath . a:p\nendfunc\n\nfunc Test_throw_let()\n  XpathINIT\n\n  try\n    try\n      let $VAR = 'old_value'\n      Xpath 'a'\n      let $VAR = 'let(' . T72_throw('var') . ')'\n      Xpath 'b'\n    catch /^var$/\n      Xpath 'c'\n    finally\n      call assert_equal('old_value', $VAR)\n    endtry\n\n    try\n      let @a = 'old_value'\n      Xpath 'd'\n      let @a = 'let(' . T72_throw('reg') . ')'\n      Xpath 'e'\n    catch /^reg$/\n      try\n        Xpath 'f'\n        let @A = 'let(' . T72_throw('REG') . ')'\n        Xpath 'g'\n      catch /^REG$/\n        Xpath 'h'\n      endtry\n    finally\n      call assert_equal('old_value', @a)\n      call assert_equal('old_value', @A)\n    endtry\n\n    try\n      let saved_gpath = &g:path\n      let saved_lpath = &l:path\n      Xpath 'i'\n      let &path = 'let(' . T72_throw('opt') . ')'\n      Xpath 'j'\n    catch /^opt$/\n      try\n        Xpath 'k'\n        let &g:path = 'let(' . T72_throw('gopt') . ')'\n        Xpath 'l'\n      catch /^gopt$/\n        try\n          Xpath 'm'\n          let &l:path = 'let(' . T72_throw('lopt') . ')'\n          Xpath 'n'\n        catch /^lopt$/\n          Xpath 'o'\n        endtry\n      endtry\n    finally\n      call assert_equal(saved_gpath, &g:path)\n      call assert_equal(saved_lpath, &l:path)\n      let &g:path = saved_gpath\n      let &l:path = saved_lpath\n    endtry\n\n    unlet! var1 var2 var3\n\n    try\n      Xpath 'p'\n      let var1 = 'let(' . T72_throw('var1') . ')'\n      Xpath 'q'\n    catch /^var1$/\n      Xpath 'r'\n    finally\n      call assert_true(!exists('var1'))\n    endtry\n\n    try\n      let var2 = 'old_value'\n      Xpath 's'\n      let var2 = 'let(' . T72_throw('var2'). ')'\n      Xpath 't'\n    catch /^var2$/\n      Xpath 'u'\n    finally\n      call assert_equal('old_value', var2)\n    endtry\n\n    try\n      Xpath 'v'\n      let var{T72_throw('var3')} = 4711\n      Xpath 'w'\n    catch /^var3$/\n      Xpath 'x'\n    endtry\n\n    try\n      call T72_addpath('T1')\n      let var{T72_throw('var4')} var{T72_addpath('T2')} | call T72_addpath('T3')\n      call T72_addpath('T4')\n    catch /^var4$/\n      call T72_addpath('T5')\n    endtry\n\n    try\n      call T72_addpath('T6')\n      unlet var{T72_throw('var5')} var{T72_addpath('T7')}\n            \\ | call T72_addpath('T8')\n      call T72_addpath('T9')\n    catch /^var5$/\n      call T72_addpath('T10')\n    endtry\n\n    call assert_equal('T1T5T6T10', g:T72_addpath)\n    call assert_equal(11, g:throwcount)\n  catch /.*/\n    call assert_report('Caught ' . v:exception . ' in ' . v:throwpoint)\n  endtry\n\n  call assert_equal('acdfhikmoprsuvx', g:Xpath)\nendfunc\n\n\n\"-------------------------------------------------------------------------------\n\" Test 73:  :throw across :function, :delfunction\t\t\t    {{{1\n\"\n\"\t    The :function and :delfunction commands may cause an expression\n\"\t    specified in braces to be evaluated.  During evaluation, an\n\"\t    exception might be thrown.  The exception can be caught by the\n\"\t    script.\n\"-------------------------------------------------------------------------------\n\nlet T73_taken = ''\n\nfunc T73_throw(x, n)\n  let g:T73_taken = g:T73_taken . 'T' . a:n\n  throw a:x\nendfunc\n\nfunc T73_expr(x, n)\n  let g:T73_taken = g:T73_taken . 'E' . a:n\n  if a:n % 2 == 0\n    call T73_throw(a:x, a:n)\n  endif\n  return 2 - a:n % 2\nendfunc\n\nfunc Test_throw_func()\n  XpathINIT\n\n  try\n    try\n      \" Define function.\n      Xpath 'a'\n      function! F0()\n      endfunction\n      Xpath 'b'\n      function! F{T73_expr('function-def-ok', 1)}()\n      endfunction\n      Xpath 'c'\n      function! F{T73_expr('function-def', 2)}()\n      endfunction\n      Xpath 'd'\n    catch /^function-def-ok$/\n      Xpath 'e'\n    catch /^function-def$/\n      Xpath 'f'\n    catch /.*/\n      call assert_report('def: ' . v:exception . ' in ' . v:throwpoint)\n    endtry\n\n    try\n      \" List function.\n      Xpath 'g'\n      function F0\n      Xpath 'h'\n      function F{T73_expr('function-lst-ok', 3)}\n      Xpath 'i'\n      function F{T73_expr('function-lst', 4)}\n      Xpath 'j'\n    catch /^function-lst-ok$/\n      Xpath 'k'\n    catch /^function-lst$/\n      Xpath 'l'\n    catch /.*/\n      call assert_report('lst: ' . v:exception . ' in ' . v:throwpoint)\n    endtry\n\n    try\n      \" Delete function\n      Xpath 'm'\n      delfunction F0\n      Xpath 'n'\n      delfunction F{T73_expr('function-del-ok', 5)}\n      Xpath 'o'\n      delfunction F{T73_expr('function-del', 6)}\n      Xpath 'p'\n    catch /^function-del-ok$/\n      Xpath 'q'\n    catch /^function-del$/\n      Xpath 'r'\n    catch /.*/\n      call assert_report('del: ' . v:exception . ' in ' . v:throwpoint)\n    endtry\n    call assert_equal('E1E2T2E3E4T4E5E6T6', g:T73_taken)\n  catch /.*/\n    call assert_report('Caught ' . v:exception . ' in ' . v:throwpoint)\n  endtry\n\n  call assert_equal('abcfghilmnor', g:Xpath)\nendfunc\n\n\n\"-------------------------------------------------------------------------------\n\" Test 74:  :throw across builtin functions and commands\t\t    {{{1\n\"\n\"\t    Some functions like exists(), searchpair() take expression\n\"\t    arguments, other functions or commands like substitute() or\n\"\t    :substitute cause an expression (specified in the regular\n\"\t    expression) to be evaluated.  During evaluation an exception\n\"\t    might be thrown.  The exception can be caught by the script.\n\"-------------------------------------------------------------------------------\n\nlet T74_taken = \"\"\n\nfunc T74_throw(x, n)\n  let g:T74_taken = g:T74_taken . \"T\" . a:n\n  throw a:x\nendfunc\n\nfunc T74_expr(x, n)\n  let g:T74_taken = g:T74_taken . \"E\" . a:n\n  call T74_throw(a:x . a:n, a:n)\n  return \"EXPR\"\nendfunc\n\nfunc T74_skip(x, n)\n  let g:T74_taken = g:T74_taken . \"S\" . a:n . \"(\" . line(\".\")\n  let theline = getline(\".\")\n  if theline =~ \"skip\"\n    let g:T74_taken = g:T74_taken . \"s)\"\n    return 1\n  elseif theline =~ \"throw\"\n    let g:T74_taken = g:T74_taken . \"t)\"\n    call T74_throw(a:x . a:n, a:n)\n  else\n    let g:T74_taken = g:T74_taken . \")\"\n    return 0\n  endif\nendfunc\n\nfunc T74_subst(x, n)\n  let g:T74_taken = g:T74_taken . \"U\" . a:n . \"(\" . line(\".\")\n  let theline = getline(\".\")\n  if theline =~ \"not\"       \" T74_subst() should not be called for this line\n    let g:T74_taken = g:T74_taken . \"n)\"\n    call T74_throw(a:x . a:n, a:n)\n  elseif theline =~ \"throw\"\n    let g:T74_taken = g:T74_taken . \"t)\"\n    call T74_throw(a:x . a:n, a:n)\n  else\n    let g:T74_taken = g:T74_taken . \")\"\n    return \"replaced\"\n  endif\nendfunc\n\nfunc Test_throw_builtin_func()\n  XpathINIT\n\n  try\n    try\n      Xpath 'a'\n      let result = exists('*{T74_expr(\"exists\", 1)}')\n      Xpath 'b'\n    catch /^exists1$/\n      Xpath 'c'\n      try\n        let result = exists('{T74_expr(\"exists\", 2)}')\n        Xpath 'd'\n      catch /^exists2$/\n        Xpath 'e'\n      catch /.*/\n        call assert_report('exists2: ' . v:exception . ' in ' . v:throwpoint)\n      endtry\n    catch /.*/\n      call assert_report('exists1: ' . v:exception . ' in ' . v:throwpoint)\n    endtry\n\n    try\n      let file = tempname()\n      exec \"edit\" file\n      call append(0, [\n            \\ 'begin',\n            \\ 'xx',\n            \\ 'middle 3',\n            \\ 'xx',\n            \\ 'middle 5 skip',\n            \\ 'xx',\n            \\ 'middle 7 throw',\n            \\ 'xx',\n            \\ 'end'])\n      normal! gg\n      Xpath 'f'\n      let result = searchpair(\"begin\", \"middle\", \"end\", '',\n            \\ 'T74_skip(\"searchpair\", 3)')\n      Xpath 'g'\n      let result = searchpair(\"begin\", \"middle\", \"end\", '',\n            \\ 'T74_skip(\"searchpair\", 4)')\n      Xpath 'h'\n      let result = searchpair(\"begin\", \"middle\", \"end\", '',\n            \\ 'T74_skip(\"searchpair\", 5)')\n      Xpath 'i'\n    catch /^searchpair[35]$/\n      Xpath 'j'\n    catch /^searchpair4$/\n      Xpath 'k'\n    catch /.*/\n      call assert_report('searchpair: ' . v:exception . ' in ' . v:throwpoint)\n    finally\n      bwipeout!\n      call delete(file)\n    endtry\n\n    try\n      let file = tempname()\n      exec \"edit\" file\n      call append(0, [\n            \\ 'subst 1',\n            \\ 'subst 2',\n            \\ 'not',\n            \\ 'subst 4',\n            \\ 'subst throw',\n            \\ 'subst 6'])\n      normal! gg\n      Xpath 'l'\n      1,2substitute/subst/\\=T74_subst(\"substitute\", 6)/\n      try\n        Xpath 'm'\n        try\n          let v:errmsg = \"\"\n          3substitute/subst/\\=T74_subst(\"substitute\", 7)/\n        finally\n          if v:errmsg != \"\"\n            \" If exceptions are not thrown on errors, fake the error\n            \" exception in order to get the same execution path.\n            throw \"faked Vim(substitute)\"\n          endif\n        endtry\n      catch /Vim(substitute)/\t    \" Pattern not found ('e' flag missing)\n        Xpath 'n'\n        3substitute/subst/\\=T74_subst(\"substitute\", 8)/e\n        Xpath 'o'\n      endtry\n      Xpath 'p'\n      4,6substitute/subst/\\=T74_subst(\"substitute\", 9)/\n      Xpath 'q'\n    catch /^substitute[678]/\n      Xpath 'r'\n    catch /^substitute9/\n      Xpath 's'\n    finally\n      bwipeout!\n      call delete(file)\n    endtry\n\n    try\n      Xpath 't'\n      let var = substitute(\"sub\", \"sub\", '\\=T74_throw(\"substitute()y\", 10)', '')\n      Xpath 'u'\n    catch /substitute()y/\n      Xpath 'v'\n    catch /.*/\n      call assert_report('substitute()y: ' . v:exception . ' in '\n            \\ . v:throwpoint)\n    endtry\n\n    try\n      Xpath 'w'\n      let var = substitute(\"not\", \"sub\", '\\=T74_throw(\"substitute()n\", 11)', '')\n      Xpath 'x'\n    catch /substitute()n/\n      Xpath 'y'\n    catch /.*/\n      call assert_report('substitute()n: ' . v:exception . ' in '\n            \\ . v:throwpoint)\n    endtry\n\n    call assert_equal('E1T1E2T2S3(3)S4(5s)S4(7t)T4U6(1)U6(2)U9(4)U9(5t)T9T10',\n          \\ g:T74_taken)\n\n  catch /.*/\n    call assert_report('Caught ' . v:exception . ' in ' . v:throwpoint)\n  endtry\n\n  call assert_equal('acefgklmnopstvwx', g:Xpath)\nendfunc\n\n\n\"-------------------------------------------------------------------------------\n\" Test 75:  Errors in builtin functions.\t\t\t\t    {{{1\n\"\n\"\t    On an error in a builtin function called inside a :try/:endtry\n\"\t    region, the evaluation of the expression calling that function and\n\"\t    the command containing that expression are abandoned.  The error can\n\"\t    be caught as an exception.\n\"\n\"\t    A simple :call of the builtin function is a trivial case.  If the\n\"\t    builtin function is called in the argument list of another function,\n\"\t    no further arguments are evaluated, and the other function is not\n\"\t    executed.  If the builtin function is called from the argument of\n\"\t    a :return command, the :return command is not executed.  If the\n\"\t    builtin function is called from the argument of a :throw command,\n\"\t    the :throw command is not executed.  The evaluation of the\n\"\t    expression calling the builtin function is abandoned.\n\"-------------------------------------------------------------------------------\n\nfunc T75_F1(arg1)\n  Xpath 'a'\nendfunc\n\nfunc T75_F2(arg1, arg2)\n  Xpath 'b'\nendfunc\n\nfunc T75_G()\n  Xpath 'c'\nendfunc\n\nfunc T75_H()\n  Xpath 'd'\nendfunc\n\nfunc T75_R()\n  while 1\n    try\n      let caught = 0\n      let v:errmsg = \"\"\n      Xpath 'e'\n      return append(1, \"s\")\n    catch /E21/\n      let caught = 1\n    catch /.*/\n      Xpath 'f'\n    finally\n      Xpath 'g'\n      if caught || $VIMNOERRTHROW && v:errmsg =~ 'E21'\n        Xpath 'h'\n      endif\n      break\t\t\" discard error for $VIMNOERRTHROW\n    endtry\n  endwhile\n  Xpath 'i'\nendfunc\n\nfunc Test_builtin_func_error()\n  XpathINIT\n\n  try\n    set noma\t\" let append() fail with \"E21\"\n\n    while 1\n      try\n        let caught = 0\n        let v:errmsg = \"\"\n        Xpath 'j'\n        call append(1, \"s\")\n      catch /E21/\n        let caught = 1\n      catch /.*/\n        Xpath 'k'\n      finally\n        Xpath 'l'\n        if caught || $VIMNOERRTHROW && v:errmsg =~ 'E21'\n          Xpath 'm'\n        endif\n        break\t\t\" discard error for $VIMNOERRTHROW\n      endtry\n    endwhile\n\n    while 1\n      try\n        let caught = 0\n        let v:errmsg = \"\"\n        Xpath 'n'\n        call T75_F1('x' . append(1, \"s\"))\n      catch /E21/\n        let caught = 1\n      catch /.*/\n        Xpath 'o'\n      finally\n        Xpath 'p'\n        if caught || $VIMNOERRTHROW && v:errmsg =~ 'E21'\n          Xpath 'q'\n        endif\n        break\t\t\" discard error for $VIMNOERRTHROW\n      endtry\n    endwhile\n\n    while 1\n      try\n        let caught = 0\n        let v:errmsg = \"\"\n        Xpath 'r'\n        call T75_F2('x' . append(1, \"s\"), T75_G())\n      catch /E21/\n        let caught = 1\n      catch /.*/\n        Xpath 's'\n      finally\n        Xpath 't'\n        if caught || $VIMNOERRTHROW && v:errmsg =~ 'E21'\n          Xpath 'u'\n        endif\n        break\t\t\" discard error for $VIMNOERRTHROW\n      endtry\n    endwhile\n\n    call T75_R()\n\n    while 1\n      try\n        let caught = 0\n        let v:errmsg = \"\"\n        Xpath 'v'\n        throw \"T\" . append(1, \"s\")\n      catch /E21/\n        let caught = 1\n      catch /^T.*/\n        Xpath 'w'\n      catch /.*/\n        Xpath 'x'\n      finally\n        Xpath 'y'\n        if caught || $VIMNOERRTHROW && v:errmsg =~ 'E21'\n          Xpath 'z'\n        endif\n        break\t\t\" discard error for $VIMNOERRTHROW\n      endtry\n    endwhile\n\n    while 1\n      try\n        let caught = 0\n        let v:errmsg = \"\"\n        Xpath 'A'\n        let x = \"a\"\n        let x = x . \"b\" . append(1, \"s\") . T75_H()\n      catch /E21/\n        let caught = 1\n      catch /.*/\n        Xpath 'B'\n      finally\n        Xpath 'C'\n        if caught || $VIMNOERRTHROW && v:errmsg =~ 'E21'\n          Xpath 'D'\n        endif\n        call assert_equal('a', x)\n        break\t\t\" discard error for $VIMNOERRTHROW\n      endtry\n    endwhile\n  catch /.*/\n    call assert_report('Caught ' . v:exception . ' in ' . v:throwpoint)\n  finally\n    set ma&\n  endtry\n\n  call assert_equal('jlmnpqrtueghivyzACD', g:Xpath)\nendfunc\n\nfunc Test_reload_in_try_catch()\n  call writefile(['x'], 'Xreload')\n  set autoread\n  edit Xreload\n  tabnew\n  call writefile(['xx'], 'Xreload')\n  augroup ReLoad\n    au FileReadPost Xreload let x = doesnotexist\n    au BufReadPost Xreload let x = doesnotexist\n  augroup END\n  try\n    edit Xreload\n  catch\n  endtry\n  tabnew\n\n  tabclose\n  tabclose\n  autocmd! ReLoad\n  set noautoread\n  bwipe! Xreload\n  call delete('Xreload')\nendfunc\n\n\" Test for errors with :catch, :throw, :finally                            {{{1\nfunc Test_try_catch_errors()\n  call assert_fails('throw |', 'E471:')\n  call assert_fails(\"throw \\n \", 'E471:')\n  call assert_fails('catch abc', 'E654:')\n  call assert_fails('try | let i = 1| finally | catch | endtry', 'E604:')\n  call assert_fails('finally', 'E606:')\n  call assert_fails('try | finally | finally | endtry', 'E607:')\n  call assert_fails('try | for i in range(5) | endif | endtry', 'E580:')\n  call assert_fails('try | while v:true | endtry', 'E170:')\n  call assert_fails('try | if v:true | endtry', 'E171:')\n\n  \" this was using a negative index in cstack[]\n  let lines =<< trim END\n      try\n      for\n      if\n      endwhile\n      if\n      finally\n  END\n  call v9.CheckScriptFailure(lines, 'E690:')\n\n  let lines =<< trim END\n      try\n      for\n      if\n      endwhile\n      if\n      endtry\n  END\n  call v9.CheckScriptFailure(lines, 'E690:')\nendfunc\n\n\" Test for verbose messages with :try :catch, and :finally                 {{{1\nfunc Test_try_catch_verbose()\n  \" This test works only when the language is English\n  CheckEnglish\n\n  set verbose=14\n\n  \" Test for verbose messages displayed when an exception is caught\n  redir => msg\n  try\n    echo i\n  catch /E121:/\n  finally\n  endtry\n  redir END\n  let expected = [\n        \\ 'Exception thrown: Vim(echo):E121: Undefined variable: i', '',\n        \\ 'Exception caught: Vim(echo):E121: Undefined variable: i', '',\n        \\ 'Exception finished: Vim(echo):E121: Undefined variable: i']\n  call assert_equal(expected, split(msg, \"\\n\"))\n\n  \" Test for verbose messages displayed when an exception is discarded\n  redir => msg\n  try\n    try\n      throw 'abc'\n    finally\n      throw 'xyz'\n    endtry\n  catch\n  endtry\n  redir END\n  let expected = [\n        \\ 'Exception thrown: abc', '',\n        \\ 'Exception made pending: abc', '',\n        \\ 'Exception thrown: xyz', '',\n        \\ 'Exception discarded: abc', '',\n        \\ 'Exception caught: xyz', '',\n        \\ 'Exception finished: xyz']\n  call assert_equal(expected, split(msg, \"\\n\"))\n\n  \" Test for messages displayed when :throw is resumed after :finally\n  redir => msg\n  try\n    try\n      throw 'abc'\n    finally\n    endtry\n  catch\n  endtry\n  redir END\n  let expected = [\n        \\ 'Exception thrown: abc', '',\n        \\ 'Exception made pending: abc', '',\n        \\ 'Exception resumed: abc', '',\n        \\ 'Exception caught: abc', '',\n        \\ 'Exception finished: abc']\n  call assert_equal(expected, split(msg, \"\\n\"))\n\n  \" Test for messages displayed when :break is resumed after :finally\n  redir => msg\n  for i in range(1)\n    try\n      break\n    finally\n    endtry\n  endfor\n  redir END\n  let expected = [':break made pending', '', ':break resumed']\n  call assert_equal(expected, split(msg, \"\\n\"))\n\n  \" Test for messages displayed when :continue is resumed after :finally\n  redir => msg\n  for i in range(1)\n    try\n      continue\n    finally\n    endtry\n  endfor\n  redir END\n  let expected = [':continue made pending', '', ':continue resumed']\n  call assert_equal(expected, split(msg, \"\\n\"))\n\n  \" Test for messages displayed when :return is resumed after :finally\n  func Xtest()\n    try\n      return 'vim'\n    finally\n    endtry\n  endfunc\n  redir => msg\n  call Xtest()\n  redir END\n  let expected = [\n        \\ 'calling Xtest()', '',\n        \\ ':return vim made pending', '',\n        \\ ':return vim resumed', '',\n        \\ 'Xtest returning ''vim''', '',\n        \\ 'continuing in Test_try_catch_verbose']\n  call assert_equal(expected, split(msg, \"\\n\"))\n  delfunc Xtest\n\n  \" Test for messages displayed when :finish is resumed after :finally\n  call writefile(['try', 'finish', 'finally', 'endtry'], 'Xscript')\n  redir => msg\n  source Xscript\n  redir END\n  let expected = [\n        \\ ':finish made pending', '',\n        \\ ':finish resumed', '',\n        \\ 'finished sourcing Xscript',\n        \\ 'continuing in Test_try_catch_verbose']\n  call assert_equal(expected, split(msg, \"\\n\")[1:])\n  call delete('Xscript')\n\n  \" Test for messages displayed when a pending :continue is discarded by an\n  \" exception in a finally handler\n  redir => msg\n  try\n    for i in range(1)\n      try\n        continue\n      finally\n        throw 'abc'\n      endtry\n    endfor\n  catch\n  endtry\n  redir END\n  let expected = [\n        \\ ':continue made pending', '',\n        \\ 'Exception thrown: abc', '',\n        \\ ':continue discarded', '',\n        \\ 'Exception caught: abc', '',\n        \\ 'Exception finished: abc']\n  call assert_equal(expected, split(msg, \"\\n\"))\n\n  set verbose&\nendfunc\n\n\" Test for throwing an exception from a BufEnter autocmd                   {{{1\nfunc Test_BufEnter_exception()\n  augroup bufenter_exception\n    au!\n    autocmd BufEnter Xfile1 throw 'abc'\n  augroup END\n\n  let caught_abc = 0\n  try\n    sp Xfile1\n  catch /^abc/\n    let caught_abc = 1\n  endtry\n  call assert_equal(1, caught_abc)\n  call assert_equal(1, winnr('$'))\n\n  augroup bufenter_exception\n    au!\n  augroup END\n  augroup! bufenter_exception\n  %bwipe!\n\n  \" Test for recursively throwing exceptions in autocmds\n  augroup bufenter_exception\n    au!\n    autocmd BufEnter Xfile1 throw 'bufenter'\n    autocmd BufLeave Xfile1 throw 'bufleave'\n  augroup END\n\n  let ex_count = 0\n  try\n    try\n      sp Xfile1\n    catch /^bufenter/\n      let ex_count += 1\n    endtry\n  catch /^bufleave/\n      let ex_count += 10\n  endtry\n  call assert_equal(10, ex_count)\n  call assert_equal(2, winnr('$'))\n\n  augroup bufenter_exception\n    au!\n  augroup END\n  augroup! bufenter_exception\n  %bwipe!\nendfunc\n\n\" Test for using try/catch in a user command with a failing expression    {{{1\nfunc Test_user_command_try_catch()\n  let lines =<< trim END\n      function s:throw() abort\n        throw 'error'\n      endfunction\n\n      command! Execute\n      \\   try\n      \\ |   let s:x = s:throw()\n      \\ | catch\n      \\ |   let g:caught = 'caught'\n      \\ | endtry\n\n      let g:caught = 'no'\n      Execute\n      call assert_equal('caught', g:caught)\n  END\n  call writefile(lines, 'XtestTryCatch')\n  source XtestTryCatch\n\n  call delete('XtestTryCatch')\n  unlet g:caught\nendfunc\n\n\" Test for using throw in a called function with following error    {{{1\nfunc Test_user_command_throw_in_function_call()\n  let lines =<< trim END\n      function s:get_dict() abort\n        throw 'my_error'\n      endfunction\n\n      try\n        call s:get_dict().foo()\n      catch /my_error/\n        let caught = 'yes'\n      catch\n        let caught = v:exception\n      endtry\n      call assert_equal('yes', caught)\n  END\n  call writefile(lines, 'XtestThrow')\n  source XtestThrow\n\n  call delete('XtestThrow')\n  unlet g:caught\nendfunc\n\n\" Test that after reporting an uncaught exception there is no error for a\n\" missing :endif\nfunc Test_after_exception_no_endif_error()\n  function Throw()\n    throw \"Failure\"\n  endfunction\n\n  function Foo()\n    if 1\n      call Throw()\n    endif\n  endfunction\n  call assert_fails('call Foo()', ['E605:', 'E605:'])\n  delfunc Throw\n  delfunc Foo\nendfunc\n\n\" Test for using throw in a called function with following endtry    {{{1\nfunc Test_user_command_function_call_with_endtry()\n  let lines =<< trim END\n      funct s:throw(msg) abort\n        throw a:msg\n      endfunc\n      func s:main() abort\n        try\n          try\n            throw 'err1'\n          catch\n            call s:throw('err2') | endtry\n          catch\n            let s:caught = 'yes'\n        endtry\n      endfunc\n\n      call s:main()\n      call assert_equal('yes', s:caught)\n  END\n  call writefile(lines, 'XtestThrow')\n  source XtestThrow\n\n  call delete('XtestThrow')\nendfunc\n\nfunc ThisWillFail()\n\nendfunc\n\n\" This was crashing prior to the fix in 8.2.3478.\nfunc Test_error_in_catch_and_finally()\n  let lines =<< trim END\n    try\n      echo x\n    catch\n      for l in []\n    finally\n  END\n  call writefile(lines, 'XtestCatchAndFinally')\n  try\n    source XtestCatchAndFinally\n  catch /E600:/\n  endtry\n\n  call delete('XtestCatchAndFinally')\nendfunc\n\n\" This was causing an illegal memory access\nfunc Test_leave_block_in_endtry_not_called()\n  let lines =<< trim END\n      vim9script\n      try #\n      for x in []\n      if\n      endwhile\n      if\n      endtry\n  END\n  call writefile(lines, 'XtestEndtry')\n  try\n    source XtestEndtry\n  catch /E171:/\n  endtry\n\n  call delete('XtestEndtry')\nendfunc\n\n\" Modeline\t\t\t\t\t\t\t\t    {{{1\n\" vim: ts=8 sw=2 sts=2 expandtab tw=80 fdm=marker\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n\t\"++builtin_terms\",\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n\t\"+file_in_path\",\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n\t\"+float\",\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n\t\"-footer\",\n\t// only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n\t\"+path_extra\",\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n\t\"+textobjects\",\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n\t\"+wildignore\",\n\t\"+wildmenu\",\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_BIG)\n    msg_puts(_(\"\\nBig version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#elif defined(FEAT_SMALL)\n    msg_puts(_(\"\\nSmall version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "filenames": ["src/ex_eval.c", "src/testdir/test_trycatch.vim", "src/version.c"], "buggy_code_start_loc": [1938, 5, 701], "buggy_code_end_loc": [2258, 2010, 701], "fixing_code_start_loc": [1938, 6, 702], "fixing_code_end_loc": [2255, 2033, 704], "type": "CWE-121", "message": "Stack-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.0577.", "other": {"cve": {"id": "CVE-2022-3296", "sourceIdentifier": "security@huntr.dev", "published": "2022-09-25T17:15:09.457", "lastModified": "2023-05-03T12:16:20.403", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Stack-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.0577."}, {"lang": "es", "value": "Desbordamiento del b\u00fafer en la regi\u00f3n Stack de la memoria en el repositorio de GitHub vim/vim versiones anteriores a 9.0.0577."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-121"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndExcluding": "9.0.0577", "matchCriteriaId": "76896CB5-1CD3-4606-AAF7-B32E08653D7A"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:37:*:*:*:*:*:*:*", "matchCriteriaId": "E30D0E6F-4AE8-4284-8716-991DFA48CC5D"}]}]}], "references": [{"url": "https://github.com/vim/vim/commit/96b9bf8f74af8abf1e30054f996708db7dc285be", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/958866b8-526a-4979-9471-39392e0c9077", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/4QI7AETXBHPC7SGA77Q7O5IEGULWYET7/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/GTBVD4J2SKVSWK4VBN5JP5OEVK6GDS3N/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/LSSEWQLK55MCNT4Z2IIJEJYEI5HLCODI/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202305-16", "source": "security@huntr.dev"}]}, "github_commit_url": "https://github.com/vim/vim/commit/96b9bf8f74af8abf1e30054f996708db7dc285be"}}