{"buggy_code": ["/*\n * Silicon Graphics Movie demuxer\n * Copyright (c) 2012 Peter Ross\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n/**\n * @file\n * Silicon Graphics Movie demuxer\n */\n\n#include \"libavutil/channel_layout.h\"\n#include \"libavutil/eval.h\"\n#include \"libavutil/intreadwrite.h\"\n#include \"libavutil/rational.h\"\n\n#include \"avformat.h\"\n#include \"internal.h\"\n\ntypedef struct MvContext {\n    int nb_video_tracks;\n    int nb_audio_tracks;\n\n    int eof_count;        ///< number of streams that have finished\n    int stream_index;     ///< current stream index\n    int frame[2];         ///< frame nb for current stream\n\n    int acompression;     ///< compression level for audio stream\n    int aformat;          ///< audio format\n} MvContext;\n\n#define AUDIO_FORMAT_SIGNED 401\n\nstatic int mv_probe(AVProbeData *p)\n{\n    if (AV_RB32(p->buf) == MKBETAG('M', 'O', 'V', 'I') &&\n        AV_RB16(p->buf + 4) < 3)\n        return AVPROBE_SCORE_MAX;\n    return 0;\n}\n\nstatic char *var_read_string(AVIOContext *pb, int size)\n{\n    int n;\n    char *str;\n\n    if (size < 0 || size == INT_MAX)\n        return NULL;\n\n    str = av_malloc(size + 1);\n    if (!str)\n        return NULL;\n    n = avio_get_str(pb, size, str, size + 1);\n    if (n < size)\n        avio_skip(pb, size - n);\n    return str;\n}\n\nstatic int var_read_int(AVIOContext *pb, int size)\n{\n    int v;\n    char *s = var_read_string(pb, size);\n    if (!s)\n        return 0;\n    v = strtol(s, NULL, 10);\n    av_free(s);\n    return v;\n}\n\nstatic AVRational var_read_float(AVIOContext *pb, int size)\n{\n    AVRational v;\n    char *s = var_read_string(pb, size);\n    if (!s)\n        return (AVRational) { 0, 0 };\n    v = av_d2q(av_strtod(s, NULL), INT_MAX);\n    av_free(s);\n    return v;\n}\n\nstatic void var_read_metadata(AVFormatContext *avctx, const char *tag, int size)\n{\n    char *value = var_read_string(avctx->pb, size);\n    if (value)\n        av_dict_set(&avctx->metadata, tag, value, AV_DICT_DONT_STRDUP_VAL);\n}\n\nstatic int set_channels(AVFormatContext *avctx, AVStream *st, int channels)\n{\n    if (channels <= 0) {\n        av_log(avctx, AV_LOG_ERROR, \"Channel count %d invalid.\\n\", channels);\n        return AVERROR_INVALIDDATA;\n    }\n    st->codecpar->channels       = channels;\n    st->codecpar->channel_layout = (st->codecpar->channels == 1) ? AV_CH_LAYOUT_MONO\n                                                                 : AV_CH_LAYOUT_STEREO;\n    return 0;\n}\n\n/**\n * Parse global variable\n * @return < 0 if unknown\n */\nstatic int parse_global_var(AVFormatContext *avctx, AVStream *st,\n                            const char *name, int size)\n{\n    MvContext *mv = avctx->priv_data;\n    AVIOContext *pb = avctx->pb;\n    if (!strcmp(name, \"__NUM_I_TRACKS\")) {\n        mv->nb_video_tracks = var_read_int(pb, size);\n    } else if (!strcmp(name, \"__NUM_A_TRACKS\")) {\n        mv->nb_audio_tracks = var_read_int(pb, size);\n    } else if (!strcmp(name, \"COMMENT\") || !strcmp(name, \"TITLE\")) {\n        var_read_metadata(avctx, name, size);\n    } else if (!strcmp(name, \"LOOP_MODE\") || !strcmp(name, \"NUM_LOOPS\") ||\n               !strcmp(name, \"OPTIMIZED\")) {\n        avio_skip(pb, size); // ignore\n    } else\n        return AVERROR_INVALIDDATA;\n\n    return 0;\n}\n\n/**\n * Parse audio variable\n * @return < 0 if unknown\n */\nstatic int parse_audio_var(AVFormatContext *avctx, AVStream *st,\n                           const char *name, int size)\n{\n    MvContext *mv = avctx->priv_data;\n    AVIOContext *pb = avctx->pb;\n    if (!strcmp(name, \"__DIR_COUNT\")) {\n        st->nb_frames = var_read_int(pb, size);\n    } else if (!strcmp(name, \"AUDIO_FORMAT\")) {\n        mv->aformat = var_read_int(pb, size);\n    } else if (!strcmp(name, \"COMPRESSION\")) {\n        mv->acompression = var_read_int(pb, size);\n    } else if (!strcmp(name, \"DEFAULT_VOL\")) {\n        var_read_metadata(avctx, name, size);\n    } else if (!strcmp(name, \"NUM_CHANNELS\")) {\n        return set_channels(avctx, st, var_read_int(pb, size));\n    } else if (!strcmp(name, \"SAMPLE_RATE\")) {\n        st->codecpar->sample_rate = var_read_int(pb, size);\n        avpriv_set_pts_info(st, 33, 1, st->codecpar->sample_rate);\n    } else if (!strcmp(name, \"SAMPLE_WIDTH\")) {\n        st->codecpar->bits_per_coded_sample = var_read_int(pb, size) * 8;\n    } else\n        return AVERROR_INVALIDDATA;\n\n    return 0;\n}\n\n/**\n * Parse video variable\n * @return < 0 if unknown\n */\nstatic int parse_video_var(AVFormatContext *avctx, AVStream *st,\n                           const char *name, int size)\n{\n    AVIOContext *pb = avctx->pb;\n    if (!strcmp(name, \"__DIR_COUNT\")) {\n        st->nb_frames = st->duration = var_read_int(pb, size);\n    } else if (!strcmp(name, \"COMPRESSION\")) {\n        char *str = var_read_string(pb, size);\n        if (!str)\n            return AVERROR_INVALIDDATA;\n        if (!strcmp(str, \"1\")) {\n            st->codecpar->codec_id = AV_CODEC_ID_MVC1;\n        } else if (!strcmp(str, \"2\")) {\n            st->codecpar->format = AV_PIX_FMT_ABGR;\n            st->codecpar->codec_id = AV_CODEC_ID_RAWVIDEO;\n        } else if (!strcmp(str, \"3\")) {\n            st->codecpar->codec_id = AV_CODEC_ID_SGIRLE;\n        } else if (!strcmp(str, \"10\")) {\n            st->codecpar->codec_id = AV_CODEC_ID_MJPEG;\n        } else if (!strcmp(str, \"MVC2\")) {\n            st->codecpar->codec_id = AV_CODEC_ID_MVC2;\n        } else {\n            avpriv_request_sample(avctx, \"Video compression %s\", str);\n        }\n        av_free(str);\n    } else if (!strcmp(name, \"FPS\")) {\n        AVRational fps = var_read_float(pb, size);\n        avpriv_set_pts_info(st, 64, fps.den, fps.num);\n        st->avg_frame_rate = fps;\n    } else if (!strcmp(name, \"HEIGHT\")) {\n        st->codecpar->height = var_read_int(pb, size);\n    } else if (!strcmp(name, \"PIXEL_ASPECT\")) {\n        st->sample_aspect_ratio = var_read_float(pb, size);\n        av_reduce(&st->sample_aspect_ratio.num, &st->sample_aspect_ratio.den,\n                  st->sample_aspect_ratio.num, st->sample_aspect_ratio.den,\n                  INT_MAX);\n    } else if (!strcmp(name, \"WIDTH\")) {\n        st->codecpar->width = var_read_int(pb, size);\n    } else if (!strcmp(name, \"ORIENTATION\")) {\n        if (var_read_int(pb, size) == 1101) {\n            st->codecpar->extradata      = av_strdup(\"BottomUp\");\n            st->codecpar->extradata_size = 9;\n        }\n    } else if (!strcmp(name, \"Q_SPATIAL\") || !strcmp(name, \"Q_TEMPORAL\")) {\n        var_read_metadata(avctx, name, size);\n    } else if (!strcmp(name, \"INTERLACING\") || !strcmp(name, \"PACKING\")) {\n        avio_skip(pb, size); // ignore\n    } else\n        return AVERROR_INVALIDDATA;\n\n    return 0;\n}\n\nstatic int read_table(AVFormatContext *avctx, AVStream *st,\n                       int (*parse)(AVFormatContext *avctx, AVStream *st,\n                                    const char *name, int size))\n{\n    int count, i;\n    AVIOContext *pb = avctx->pb;\n    avio_skip(pb, 4);\n    count = avio_rb32(pb);\n    avio_skip(pb, 4);\n    for (i = 0; i < count; i++) {\n        char name[17];\n        int size;\n        avio_read(pb, name, 16);\n        name[sizeof(name) - 1] = 0;\n        size = avio_rb32(pb);\n        if (size < 0) {\n            av_log(avctx, AV_LOG_ERROR, \"entry size %d is invalid\\n\", size);\n            return AVERROR_INVALIDDATA;\n        }\n        if (parse(avctx, st, name, size) < 0) {\n            avpriv_request_sample(avctx, \"Variable %s\", name);\n            avio_skip(pb, size);\n        }\n    }\n    return 0;\n}\n\nstatic void read_index(AVIOContext *pb, AVStream *st)\n{\n    uint64_t timestamp = 0;\n    int i;\n    for (i = 0; i < st->nb_frames; i++) {\n        uint32_t pos  = avio_rb32(pb);\n        uint32_t size = avio_rb32(pb);\n        avio_skip(pb, 8);\n        av_add_index_entry(st, pos, timestamp, size, 0, AVINDEX_KEYFRAME);\n        if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO) {\n            timestamp += size / (st->codecpar->channels * 2);\n        } else {\n            timestamp++;\n        }\n    }\n}\n\nstatic int mv_read_header(AVFormatContext *avctx)\n{\n    MvContext *mv = avctx->priv_data;\n    AVIOContext *pb = avctx->pb;\n    AVStream *ast = NULL, *vst = NULL; //initialization to suppress warning\n    int version, i;\n    int ret;\n\n    avio_skip(pb, 4);\n\n    version = avio_rb16(pb);\n    if (version == 2) {\n        uint64_t timestamp;\n        int v;\n        avio_skip(pb, 22);\n\n        /* allocate audio track first to prevent unnecessary seeking\n         * (audio packet always precede video packet for a given frame) */\n        ast = avformat_new_stream(avctx, NULL);\n        if (!ast)\n            return AVERROR(ENOMEM);\n\n        vst = avformat_new_stream(avctx, NULL);\n        if (!vst)\n            return AVERROR(ENOMEM);\n        avpriv_set_pts_info(vst, 64, 1, 15);\n        vst->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;\n        vst->avg_frame_rate    = av_inv_q(vst->time_base);\n        vst->nb_frames         = avio_rb32(pb);\n        v = avio_rb32(pb);\n        switch (v) {\n        case 1:\n            vst->codecpar->codec_id = AV_CODEC_ID_MVC1;\n            break;\n        case 2:\n            vst->codecpar->format = AV_PIX_FMT_ARGB;\n            vst->codecpar->codec_id = AV_CODEC_ID_RAWVIDEO;\n            break;\n        default:\n            avpriv_request_sample(avctx, \"Video compression %i\", v);\n            break;\n        }\n        vst->codecpar->codec_tag = 0;\n        vst->codecpar->width     = avio_rb32(pb);\n        vst->codecpar->height    = avio_rb32(pb);\n        avio_skip(pb, 12);\n\n        ast->codecpar->codec_type  = AVMEDIA_TYPE_AUDIO;\n        ast->nb_frames          = vst->nb_frames;\n        ast->codecpar->sample_rate = avio_rb32(pb);\n        if (ast->codecpar->sample_rate <= 0) {\n            av_log(avctx, AV_LOG_ERROR, \"Invalid sample rate %d\\n\", ast->codecpar->sample_rate);\n            return AVERROR_INVALIDDATA;\n        }\n        avpriv_set_pts_info(ast, 33, 1, ast->codecpar->sample_rate);\n        if (set_channels(avctx, ast, avio_rb32(pb)) < 0)\n            return AVERROR_INVALIDDATA;\n\n        v = avio_rb32(pb);\n        if (v == AUDIO_FORMAT_SIGNED) {\n            ast->codecpar->codec_id = AV_CODEC_ID_PCM_S16BE;\n        } else {\n            avpriv_request_sample(avctx, \"Audio compression (format %i)\", v);\n        }\n\n        avio_skip(pb, 12);\n        var_read_metadata(avctx, \"title\", 0x80);\n        var_read_metadata(avctx, \"comment\", 0x100);\n        avio_skip(pb, 0x80);\n\n        timestamp = 0;\n        for (i = 0; i < vst->nb_frames; i++) {\n            uint32_t pos   = avio_rb32(pb);\n            uint32_t asize = avio_rb32(pb);\n            uint32_t vsize = avio_rb32(pb);\n            avio_skip(pb, 8);\n            av_add_index_entry(ast, pos, timestamp, asize, 0, AVINDEX_KEYFRAME);\n            av_add_index_entry(vst, pos + asize, i, vsize, 0, AVINDEX_KEYFRAME);\n            timestamp += asize / (ast->codecpar->channels * 2);\n        }\n    } else if (!version && avio_rb16(pb) == 3) {\n        avio_skip(pb, 4);\n\n        if ((ret = read_table(avctx, NULL, parse_global_var)) < 0)\n            return ret;\n\n        if (mv->nb_audio_tracks > 1) {\n            avpriv_request_sample(avctx, \"Multiple audio streams support\");\n            return AVERROR_PATCHWELCOME;\n        } else if (mv->nb_audio_tracks) {\n            ast = avformat_new_stream(avctx, NULL);\n            if (!ast)\n                return AVERROR(ENOMEM);\n            ast->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;\n            if ((read_table(avctx, ast, parse_audio_var)) < 0)\n                return ret;\n            if (mv->acompression == 100 &&\n                mv->aformat == AUDIO_FORMAT_SIGNED &&\n                ast->codecpar->bits_per_coded_sample == 16) {\n                ast->codecpar->codec_id = AV_CODEC_ID_PCM_S16BE;\n            } else {\n                avpriv_request_sample(avctx,\n                                      \"Audio compression %i (format %i, sr %i)\",\n                                      mv->acompression, mv->aformat,\n                                      ast->codecpar->bits_per_coded_sample);\n                ast->codecpar->codec_id = AV_CODEC_ID_NONE;\n            }\n            if (ast->codecpar->channels <= 0) {\n                av_log(avctx, AV_LOG_ERROR, \"No valid channel count found.\\n\");\n                return AVERROR_INVALIDDATA;\n            }\n        }\n\n        if (mv->nb_video_tracks > 1) {\n            avpriv_request_sample(avctx, \"Multiple video streams support\");\n            return AVERROR_PATCHWELCOME;\n        } else if (mv->nb_video_tracks) {\n            vst = avformat_new_stream(avctx, NULL);\n            if (!vst)\n                return AVERROR(ENOMEM);\n            vst->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;\n            if ((ret = read_table(avctx, vst, parse_video_var))<0)\n                return ret;\n        }\n\n        if (mv->nb_audio_tracks)\n            read_index(pb, ast);\n\n        if (mv->nb_video_tracks)\n            read_index(pb, vst);\n    } else {\n        avpriv_request_sample(avctx, \"Version %i\", version);\n        return AVERROR_PATCHWELCOME;\n    }\n\n    return 0;\n}\n\nstatic int mv_read_packet(AVFormatContext *avctx, AVPacket *pkt)\n{\n    MvContext *mv = avctx->priv_data;\n    AVIOContext *pb = avctx->pb;\n    AVStream *st = avctx->streams[mv->stream_index];\n    const AVIndexEntry *index;\n    int frame = mv->frame[mv->stream_index];\n    int64_t ret;\n    uint64_t pos;\n\n    if (frame < st->nb_index_entries) {\n        index = &st->index_entries[frame];\n        pos   = avio_tell(pb);\n        if (index->pos > pos)\n            avio_skip(pb, index->pos - pos);\n        else if (index->pos < pos) {\n            if (!(pb->seekable & AVIO_SEEKABLE_NORMAL))\n                return AVERROR(EIO);\n            ret = avio_seek(pb, index->pos, SEEK_SET);\n            if (ret < 0)\n                return ret;\n        }\n        ret = av_get_packet(pb, pkt, index->size);\n        if (ret < 0)\n            return ret;\n\n        pkt->stream_index = mv->stream_index;\n        pkt->pts          = index->timestamp;\n        pkt->flags       |= AV_PKT_FLAG_KEY;\n\n        mv->frame[mv->stream_index]++;\n        mv->eof_count = 0;\n    } else {\n        mv->eof_count++;\n        if (mv->eof_count >= avctx->nb_streams)\n            return AVERROR_EOF;\n\n        // avoid returning 0 without a packet\n        return AVERROR(EAGAIN);\n    }\n\n    mv->stream_index++;\n    if (mv->stream_index >= avctx->nb_streams)\n        mv->stream_index = 0;\n\n    return 0;\n}\n\nstatic int mv_read_seek(AVFormatContext *avctx, int stream_index,\n                        int64_t timestamp, int flags)\n{\n    MvContext *mv = avctx->priv_data;\n    AVStream *st = avctx->streams[stream_index];\n    int frame, i;\n\n    if ((flags & AVSEEK_FLAG_FRAME) || (flags & AVSEEK_FLAG_BYTE))\n        return AVERROR(ENOSYS);\n\n    if (!(avctx->pb->seekable & AVIO_SEEKABLE_NORMAL))\n        return AVERROR(EIO);\n\n    frame = av_index_search_timestamp(st, timestamp, flags);\n    if (frame < 0)\n        return AVERROR_INVALIDDATA;\n\n    for (i = 0; i < avctx->nb_streams; i++)\n        mv->frame[i] = frame;\n    return 0;\n}\n\nAVInputFormat ff_mv_demuxer = {\n    .name           = \"mv\",\n    .long_name      = NULL_IF_CONFIG_SMALL(\"Silicon Graphics Movie\"),\n    .priv_data_size = sizeof(MvContext),\n    .read_probe     = mv_probe,\n    .read_header    = mv_read_header,\n    .read_packet    = mv_read_packet,\n    .read_seek      = mv_read_seek,\n};\n"], "fixing_code": ["/*\n * Silicon Graphics Movie demuxer\n * Copyright (c) 2012 Peter Ross\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n/**\n * @file\n * Silicon Graphics Movie demuxer\n */\n\n#include \"libavutil/channel_layout.h\"\n#include \"libavutil/eval.h\"\n#include \"libavutil/intreadwrite.h\"\n#include \"libavutil/rational.h\"\n\n#include \"avformat.h\"\n#include \"internal.h\"\n\ntypedef struct MvContext {\n    int nb_video_tracks;\n    int nb_audio_tracks;\n\n    int eof_count;        ///< number of streams that have finished\n    int stream_index;     ///< current stream index\n    int frame[2];         ///< frame nb for current stream\n\n    int acompression;     ///< compression level for audio stream\n    int aformat;          ///< audio format\n} MvContext;\n\n#define AUDIO_FORMAT_SIGNED 401\n\nstatic int mv_probe(AVProbeData *p)\n{\n    if (AV_RB32(p->buf) == MKBETAG('M', 'O', 'V', 'I') &&\n        AV_RB16(p->buf + 4) < 3)\n        return AVPROBE_SCORE_MAX;\n    return 0;\n}\n\nstatic char *var_read_string(AVIOContext *pb, int size)\n{\n    int n;\n    char *str;\n\n    if (size < 0 || size == INT_MAX)\n        return NULL;\n\n    str = av_malloc(size + 1);\n    if (!str)\n        return NULL;\n    n = avio_get_str(pb, size, str, size + 1);\n    if (n < size)\n        avio_skip(pb, size - n);\n    return str;\n}\n\nstatic int var_read_int(AVIOContext *pb, int size)\n{\n    int v;\n    char *s = var_read_string(pb, size);\n    if (!s)\n        return 0;\n    v = strtol(s, NULL, 10);\n    av_free(s);\n    return v;\n}\n\nstatic AVRational var_read_float(AVIOContext *pb, int size)\n{\n    AVRational v;\n    char *s = var_read_string(pb, size);\n    if (!s)\n        return (AVRational) { 0, 0 };\n    v = av_d2q(av_strtod(s, NULL), INT_MAX);\n    av_free(s);\n    return v;\n}\n\nstatic void var_read_metadata(AVFormatContext *avctx, const char *tag, int size)\n{\n    char *value = var_read_string(avctx->pb, size);\n    if (value)\n        av_dict_set(&avctx->metadata, tag, value, AV_DICT_DONT_STRDUP_VAL);\n}\n\nstatic int set_channels(AVFormatContext *avctx, AVStream *st, int channels)\n{\n    if (channels <= 0) {\n        av_log(avctx, AV_LOG_ERROR, \"Channel count %d invalid.\\n\", channels);\n        return AVERROR_INVALIDDATA;\n    }\n    st->codecpar->channels       = channels;\n    st->codecpar->channel_layout = (st->codecpar->channels == 1) ? AV_CH_LAYOUT_MONO\n                                                                 : AV_CH_LAYOUT_STEREO;\n    return 0;\n}\n\n/**\n * Parse global variable\n * @return < 0 if unknown\n */\nstatic int parse_global_var(AVFormatContext *avctx, AVStream *st,\n                            const char *name, int size)\n{\n    MvContext *mv = avctx->priv_data;\n    AVIOContext *pb = avctx->pb;\n    if (!strcmp(name, \"__NUM_I_TRACKS\")) {\n        mv->nb_video_tracks = var_read_int(pb, size);\n    } else if (!strcmp(name, \"__NUM_A_TRACKS\")) {\n        mv->nb_audio_tracks = var_read_int(pb, size);\n    } else if (!strcmp(name, \"COMMENT\") || !strcmp(name, \"TITLE\")) {\n        var_read_metadata(avctx, name, size);\n    } else if (!strcmp(name, \"LOOP_MODE\") || !strcmp(name, \"NUM_LOOPS\") ||\n               !strcmp(name, \"OPTIMIZED\")) {\n        avio_skip(pb, size); // ignore\n    } else\n        return AVERROR_INVALIDDATA;\n\n    return 0;\n}\n\n/**\n * Parse audio variable\n * @return < 0 if unknown\n */\nstatic int parse_audio_var(AVFormatContext *avctx, AVStream *st,\n                           const char *name, int size)\n{\n    MvContext *mv = avctx->priv_data;\n    AVIOContext *pb = avctx->pb;\n    if (!strcmp(name, \"__DIR_COUNT\")) {\n        st->nb_frames = var_read_int(pb, size);\n    } else if (!strcmp(name, \"AUDIO_FORMAT\")) {\n        mv->aformat = var_read_int(pb, size);\n    } else if (!strcmp(name, \"COMPRESSION\")) {\n        mv->acompression = var_read_int(pb, size);\n    } else if (!strcmp(name, \"DEFAULT_VOL\")) {\n        var_read_metadata(avctx, name, size);\n    } else if (!strcmp(name, \"NUM_CHANNELS\")) {\n        return set_channels(avctx, st, var_read_int(pb, size));\n    } else if (!strcmp(name, \"SAMPLE_RATE\")) {\n        st->codecpar->sample_rate = var_read_int(pb, size);\n        avpriv_set_pts_info(st, 33, 1, st->codecpar->sample_rate);\n    } else if (!strcmp(name, \"SAMPLE_WIDTH\")) {\n        st->codecpar->bits_per_coded_sample = var_read_int(pb, size) * 8;\n    } else\n        return AVERROR_INVALIDDATA;\n\n    return 0;\n}\n\n/**\n * Parse video variable\n * @return < 0 if unknown\n */\nstatic int parse_video_var(AVFormatContext *avctx, AVStream *st,\n                           const char *name, int size)\n{\n    AVIOContext *pb = avctx->pb;\n    if (!strcmp(name, \"__DIR_COUNT\")) {\n        st->nb_frames = st->duration = var_read_int(pb, size);\n    } else if (!strcmp(name, \"COMPRESSION\")) {\n        char *str = var_read_string(pb, size);\n        if (!str)\n            return AVERROR_INVALIDDATA;\n        if (!strcmp(str, \"1\")) {\n            st->codecpar->codec_id = AV_CODEC_ID_MVC1;\n        } else if (!strcmp(str, \"2\")) {\n            st->codecpar->format = AV_PIX_FMT_ABGR;\n            st->codecpar->codec_id = AV_CODEC_ID_RAWVIDEO;\n        } else if (!strcmp(str, \"3\")) {\n            st->codecpar->codec_id = AV_CODEC_ID_SGIRLE;\n        } else if (!strcmp(str, \"10\")) {\n            st->codecpar->codec_id = AV_CODEC_ID_MJPEG;\n        } else if (!strcmp(str, \"MVC2\")) {\n            st->codecpar->codec_id = AV_CODEC_ID_MVC2;\n        } else {\n            avpriv_request_sample(avctx, \"Video compression %s\", str);\n        }\n        av_free(str);\n    } else if (!strcmp(name, \"FPS\")) {\n        AVRational fps = var_read_float(pb, size);\n        avpriv_set_pts_info(st, 64, fps.den, fps.num);\n        st->avg_frame_rate = fps;\n    } else if (!strcmp(name, \"HEIGHT\")) {\n        st->codecpar->height = var_read_int(pb, size);\n    } else if (!strcmp(name, \"PIXEL_ASPECT\")) {\n        st->sample_aspect_ratio = var_read_float(pb, size);\n        av_reduce(&st->sample_aspect_ratio.num, &st->sample_aspect_ratio.den,\n                  st->sample_aspect_ratio.num, st->sample_aspect_ratio.den,\n                  INT_MAX);\n    } else if (!strcmp(name, \"WIDTH\")) {\n        st->codecpar->width = var_read_int(pb, size);\n    } else if (!strcmp(name, \"ORIENTATION\")) {\n        if (var_read_int(pb, size) == 1101) {\n            st->codecpar->extradata      = av_strdup(\"BottomUp\");\n            st->codecpar->extradata_size = 9;\n        }\n    } else if (!strcmp(name, \"Q_SPATIAL\") || !strcmp(name, \"Q_TEMPORAL\")) {\n        var_read_metadata(avctx, name, size);\n    } else if (!strcmp(name, \"INTERLACING\") || !strcmp(name, \"PACKING\")) {\n        avio_skip(pb, size); // ignore\n    } else\n        return AVERROR_INVALIDDATA;\n\n    return 0;\n}\n\nstatic int read_table(AVFormatContext *avctx, AVStream *st,\n                       int (*parse)(AVFormatContext *avctx, AVStream *st,\n                                    const char *name, int size))\n{\n    int count, i;\n    AVIOContext *pb = avctx->pb;\n    avio_skip(pb, 4);\n    count = avio_rb32(pb);\n    avio_skip(pb, 4);\n    for (i = 0; i < count; i++) {\n        char name[17];\n        int size;\n        avio_read(pb, name, 16);\n        name[sizeof(name) - 1] = 0;\n        size = avio_rb32(pb);\n        if (size < 0) {\n            av_log(avctx, AV_LOG_ERROR, \"entry size %d is invalid\\n\", size);\n            return AVERROR_INVALIDDATA;\n        }\n        if (parse(avctx, st, name, size) < 0) {\n            avpriv_request_sample(avctx, \"Variable %s\", name);\n            avio_skip(pb, size);\n        }\n    }\n    return 0;\n}\n\nstatic void read_index(AVIOContext *pb, AVStream *st)\n{\n    uint64_t timestamp = 0;\n    int i;\n    for (i = 0; i < st->nb_frames; i++) {\n        uint32_t pos  = avio_rb32(pb);\n        uint32_t size = avio_rb32(pb);\n        avio_skip(pb, 8);\n        av_add_index_entry(st, pos, timestamp, size, 0, AVINDEX_KEYFRAME);\n        if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO) {\n            timestamp += size / (st->codecpar->channels * 2);\n        } else {\n            timestamp++;\n        }\n    }\n}\n\nstatic int mv_read_header(AVFormatContext *avctx)\n{\n    MvContext *mv = avctx->priv_data;\n    AVIOContext *pb = avctx->pb;\n    AVStream *ast = NULL, *vst = NULL; //initialization to suppress warning\n    int version, i;\n    int ret;\n\n    avio_skip(pb, 4);\n\n    version = avio_rb16(pb);\n    if (version == 2) {\n        uint64_t timestamp;\n        int v;\n        avio_skip(pb, 22);\n\n        /* allocate audio track first to prevent unnecessary seeking\n         * (audio packet always precede video packet for a given frame) */\n        ast = avformat_new_stream(avctx, NULL);\n        if (!ast)\n            return AVERROR(ENOMEM);\n\n        vst = avformat_new_stream(avctx, NULL);\n        if (!vst)\n            return AVERROR(ENOMEM);\n        avpriv_set_pts_info(vst, 64, 1, 15);\n        vst->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;\n        vst->avg_frame_rate    = av_inv_q(vst->time_base);\n        vst->nb_frames         = avio_rb32(pb);\n        v = avio_rb32(pb);\n        switch (v) {\n        case 1:\n            vst->codecpar->codec_id = AV_CODEC_ID_MVC1;\n            break;\n        case 2:\n            vst->codecpar->format = AV_PIX_FMT_ARGB;\n            vst->codecpar->codec_id = AV_CODEC_ID_RAWVIDEO;\n            break;\n        default:\n            avpriv_request_sample(avctx, \"Video compression %i\", v);\n            break;\n        }\n        vst->codecpar->codec_tag = 0;\n        vst->codecpar->width     = avio_rb32(pb);\n        vst->codecpar->height    = avio_rb32(pb);\n        avio_skip(pb, 12);\n\n        ast->codecpar->codec_type  = AVMEDIA_TYPE_AUDIO;\n        ast->nb_frames          = vst->nb_frames;\n        ast->codecpar->sample_rate = avio_rb32(pb);\n        if (ast->codecpar->sample_rate <= 0) {\n            av_log(avctx, AV_LOG_ERROR, \"Invalid sample rate %d\\n\", ast->codecpar->sample_rate);\n            return AVERROR_INVALIDDATA;\n        }\n        avpriv_set_pts_info(ast, 33, 1, ast->codecpar->sample_rate);\n        if (set_channels(avctx, ast, avio_rb32(pb)) < 0)\n            return AVERROR_INVALIDDATA;\n\n        v = avio_rb32(pb);\n        if (v == AUDIO_FORMAT_SIGNED) {\n            ast->codecpar->codec_id = AV_CODEC_ID_PCM_S16BE;\n        } else {\n            avpriv_request_sample(avctx, \"Audio compression (format %i)\", v);\n        }\n\n        avio_skip(pb, 12);\n        var_read_metadata(avctx, \"title\", 0x80);\n        var_read_metadata(avctx, \"comment\", 0x100);\n        avio_skip(pb, 0x80);\n\n        timestamp = 0;\n        for (i = 0; i < vst->nb_frames; i++) {\n            uint32_t pos   = avio_rb32(pb);\n            uint32_t asize = avio_rb32(pb);\n            uint32_t vsize = avio_rb32(pb);\n            if (avio_feof(pb))\n                return AVERROR_INVALIDDATA;\n            avio_skip(pb, 8);\n            av_add_index_entry(ast, pos, timestamp, asize, 0, AVINDEX_KEYFRAME);\n            av_add_index_entry(vst, pos + asize, i, vsize, 0, AVINDEX_KEYFRAME);\n            timestamp += asize / (ast->codecpar->channels * 2);\n        }\n    } else if (!version && avio_rb16(pb) == 3) {\n        avio_skip(pb, 4);\n\n        if ((ret = read_table(avctx, NULL, parse_global_var)) < 0)\n            return ret;\n\n        if (mv->nb_audio_tracks > 1) {\n            avpriv_request_sample(avctx, \"Multiple audio streams support\");\n            return AVERROR_PATCHWELCOME;\n        } else if (mv->nb_audio_tracks) {\n            ast = avformat_new_stream(avctx, NULL);\n            if (!ast)\n                return AVERROR(ENOMEM);\n            ast->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;\n            if ((read_table(avctx, ast, parse_audio_var)) < 0)\n                return ret;\n            if (mv->acompression == 100 &&\n                mv->aformat == AUDIO_FORMAT_SIGNED &&\n                ast->codecpar->bits_per_coded_sample == 16) {\n                ast->codecpar->codec_id = AV_CODEC_ID_PCM_S16BE;\n            } else {\n                avpriv_request_sample(avctx,\n                                      \"Audio compression %i (format %i, sr %i)\",\n                                      mv->acompression, mv->aformat,\n                                      ast->codecpar->bits_per_coded_sample);\n                ast->codecpar->codec_id = AV_CODEC_ID_NONE;\n            }\n            if (ast->codecpar->channels <= 0) {\n                av_log(avctx, AV_LOG_ERROR, \"No valid channel count found.\\n\");\n                return AVERROR_INVALIDDATA;\n            }\n        }\n\n        if (mv->nb_video_tracks > 1) {\n            avpriv_request_sample(avctx, \"Multiple video streams support\");\n            return AVERROR_PATCHWELCOME;\n        } else if (mv->nb_video_tracks) {\n            vst = avformat_new_stream(avctx, NULL);\n            if (!vst)\n                return AVERROR(ENOMEM);\n            vst->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;\n            if ((ret = read_table(avctx, vst, parse_video_var))<0)\n                return ret;\n        }\n\n        if (mv->nb_audio_tracks)\n            read_index(pb, ast);\n\n        if (mv->nb_video_tracks)\n            read_index(pb, vst);\n    } else {\n        avpriv_request_sample(avctx, \"Version %i\", version);\n        return AVERROR_PATCHWELCOME;\n    }\n\n    return 0;\n}\n\nstatic int mv_read_packet(AVFormatContext *avctx, AVPacket *pkt)\n{\n    MvContext *mv = avctx->priv_data;\n    AVIOContext *pb = avctx->pb;\n    AVStream *st = avctx->streams[mv->stream_index];\n    const AVIndexEntry *index;\n    int frame = mv->frame[mv->stream_index];\n    int64_t ret;\n    uint64_t pos;\n\n    if (frame < st->nb_index_entries) {\n        index = &st->index_entries[frame];\n        pos   = avio_tell(pb);\n        if (index->pos > pos)\n            avio_skip(pb, index->pos - pos);\n        else if (index->pos < pos) {\n            if (!(pb->seekable & AVIO_SEEKABLE_NORMAL))\n                return AVERROR(EIO);\n            ret = avio_seek(pb, index->pos, SEEK_SET);\n            if (ret < 0)\n                return ret;\n        }\n        ret = av_get_packet(pb, pkt, index->size);\n        if (ret < 0)\n            return ret;\n\n        pkt->stream_index = mv->stream_index;\n        pkt->pts          = index->timestamp;\n        pkt->flags       |= AV_PKT_FLAG_KEY;\n\n        mv->frame[mv->stream_index]++;\n        mv->eof_count = 0;\n    } else {\n        mv->eof_count++;\n        if (mv->eof_count >= avctx->nb_streams)\n            return AVERROR_EOF;\n\n        // avoid returning 0 without a packet\n        return AVERROR(EAGAIN);\n    }\n\n    mv->stream_index++;\n    if (mv->stream_index >= avctx->nb_streams)\n        mv->stream_index = 0;\n\n    return 0;\n}\n\nstatic int mv_read_seek(AVFormatContext *avctx, int stream_index,\n                        int64_t timestamp, int flags)\n{\n    MvContext *mv = avctx->priv_data;\n    AVStream *st = avctx->streams[stream_index];\n    int frame, i;\n\n    if ((flags & AVSEEK_FLAG_FRAME) || (flags & AVSEEK_FLAG_BYTE))\n        return AVERROR(ENOSYS);\n\n    if (!(avctx->pb->seekable & AVIO_SEEKABLE_NORMAL))\n        return AVERROR(EIO);\n\n    frame = av_index_search_timestamp(st, timestamp, flags);\n    if (frame < 0)\n        return AVERROR_INVALIDDATA;\n\n    for (i = 0; i < avctx->nb_streams; i++)\n        mv->frame[i] = frame;\n    return 0;\n}\n\nAVInputFormat ff_mv_demuxer = {\n    .name           = \"mv\",\n    .long_name      = NULL_IF_CONFIG_SMALL(\"Silicon Graphics Movie\"),\n    .priv_data_size = sizeof(MvContext),\n    .read_probe     = mv_probe,\n    .read_header    = mv_read_header,\n    .read_packet    = mv_read_packet,\n    .read_seek      = mv_read_seek,\n};\n"], "filenames": ["libavformat/mvdec.c"], "buggy_code_start_loc": [344], "buggy_code_end_loc": [344], "fixing_code_start_loc": [345], "fixing_code_end_loc": [347], "type": "CWE-834", "message": "In libavformat/mvdec.c in FFmpeg 3.3.3, a DoS in mv_read_header() due to lack of an EOF (End of File) check might cause huge CPU and memory consumption. When a crafted MV file, which claims a large \"nb_frames\" field in the header but does not contain sufficient backing data, is provided, the loop over the frames would consume huge CPU and memory resources, since there is no EOF check inside the loop.", "other": {"cve": {"id": "CVE-2017-14055", "sourceIdentifier": "cve@mitre.org", "published": "2017-08-31T15:29:00.340", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "In libavformat/mvdec.c in FFmpeg 3.3.3, a DoS in mv_read_header() due to lack of an EOF (End of File) check might cause huge CPU and memory consumption. When a crafted MV file, which claims a large \"nb_frames\" field in the header but does not contain sufficient backing data, is provided, the loop over the frames would consume huge CPU and memory resources, since there is no EOF check inside the loop."}, {"lang": "es", "value": "En libavformat/mvdec.c in FFmpeg 3.3.3, se podr\u00eda realizar un ataque de denegaci\u00f3n de servicio en mv_read_header() al no haber un chequeo EOF (End Of File) que podr\u00eda provocar acabar en un gran consumo de CPU y de memoria. Cuando se env\u00eda un archivo MV manipulado que reclama un campo \"nb_frames\" grande en la cabecera pero que no contiene suficientes datos de respaldo, el bucle en los frames consumir\u00eda una gran cantidad de recursos de CPU y de memoria, ya que no hay ning\u00fan chequeo EOF en el bucle."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:C", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 7.1}, "baseSeverity": "HIGH", "exploitabilityScore": 8.6, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-834"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:3.3.3:*:*:*:*:*:*:*", "matchCriteriaId": "A97A44A7-DFB8-4DA8-8A4A-DBC1FF255D9A"}]}]}], "references": [{"url": "http://www.debian.org/security/2017/dsa-3996", "source": "cve@mitre.org"}, {"url": "http://www.securityfocus.com/bid/100626", "source": "cve@mitre.org"}, {"url": "https://github.com/FFmpeg/FFmpeg/commit/4f05e2e2dc1a89f38cd9f0960a6561083d714f1e", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/01/msg00006.html", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/FFmpeg/FFmpeg/commit/4f05e2e2dc1a89f38cd9f0960a6561083d714f1e"}}