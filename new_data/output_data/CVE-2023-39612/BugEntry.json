{"buggy_code": ["package http\n\nimport (\n\t\"errors\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/url\"\n\tgopath \"path\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"github.com/mholt/archiver/v3\"\n\n\t\"github.com/filebrowser/filebrowser/v2/files\"\n\t\"github.com/filebrowser/filebrowser/v2/fileutils\"\n\t\"github.com/filebrowser/filebrowser/v2/users\"\n)\n\nfunc slashClean(name string) string {\n\tif name == \"\" || name[0] != '/' {\n\t\tname = \"/\" + name\n\t}\n\treturn gopath.Clean(name)\n}\n\nfunc parseQueryFiles(r *http.Request, f *files.FileInfo, _ *users.User) ([]string, error) {\n\tvar fileSlice []string\n\tnames := strings.Split(r.URL.Query().Get(\"files\"), \",\")\n\n\tif len(names) == 0 {\n\t\tfileSlice = append(fileSlice, f.Path)\n\t} else {\n\t\tfor _, name := range names {\n\t\t\tname, err := url.QueryUnescape(strings.Replace(name, \"+\", \"%2B\", -1)) //nolint:govet\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tname = slashClean(name)\n\t\t\tfileSlice = append(fileSlice, filepath.Join(f.Path, name))\n\t\t}\n\t}\n\n\treturn fileSlice, nil\n}\n\n// nolint: goconst,nolintlint\nfunc parseQueryAlgorithm(r *http.Request) (string, archiver.Writer, error) {\n\t// TODO: use enum\n\tswitch r.URL.Query().Get(\"algo\") {\n\tcase \"zip\", \"true\", \"\":\n\t\treturn \".zip\", archiver.NewZip(), nil\n\tcase \"tar\":\n\t\treturn \".tar\", archiver.NewTar(), nil\n\tcase \"targz\":\n\t\treturn \".tar.gz\", archiver.NewTarGz(), nil\n\tcase \"tarbz2\":\n\t\treturn \".tar.bz2\", archiver.NewTarBz2(), nil\n\tcase \"tarxz\":\n\t\treturn \".tar.xz\", archiver.NewTarXz(), nil\n\tcase \"tarlz4\":\n\t\treturn \".tar.lz4\", archiver.NewTarLz4(), nil\n\tcase \"tarsz\":\n\t\treturn \".tar.sz\", archiver.NewTarSz(), nil\n\tdefault:\n\t\treturn \"\", nil, errors.New(\"format not implemented\")\n\t}\n}\n\nfunc setContentDisposition(w http.ResponseWriter, r *http.Request, file *files.FileInfo) {\n\tif r.URL.Query().Get(\"inline\") == \"true\" {\n\t\tw.Header().Set(\"Content-Disposition\", \"inline\")\n\t} else {\n\t\t// As per RFC6266 section 4.3\n\t\tw.Header().Set(\"Content-Disposition\", \"attachment; filename*=utf-8''\"+url.PathEscape(file.Name))\n\t}\n}\n\nvar rawHandler = withUser(func(w http.ResponseWriter, r *http.Request, d *data) (int, error) {\n\tif !d.user.Perm.Download {\n\t\treturn http.StatusAccepted, nil\n\t}\n\n\tfile, err := files.NewFileInfo(files.FileOptions{\n\t\tFs:         d.user.Fs,\n\t\tPath:       r.URL.Path,\n\t\tModify:     d.user.Perm.Modify,\n\t\tExpand:     false,\n\t\tReadHeader: d.server.TypeDetectionByHeader,\n\t\tChecker:    d,\n\t})\n\tif err != nil {\n\t\treturn errToStatus(err), err\n\t}\n\n\tif files.IsNamedPipe(file.Mode) {\n\t\tsetContentDisposition(w, r, file)\n\t\treturn 0, nil\n\t}\n\n\tif !file.IsDir {\n\t\treturn rawFileHandler(w, r, file)\n\t}\n\n\treturn rawDirHandler(w, r, d, file)\n})\n\nfunc addFile(ar archiver.Writer, d *data, path, commonPath string) error {\n\tif !d.Check(path) {\n\t\treturn nil\n\t}\n\n\tinfo, err := d.user.Fs.Stat(path)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !info.IsDir() && !info.Mode().IsRegular() {\n\t\treturn nil\n\t}\n\n\tfile, err := d.user.Fs.Open(path)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\n\tif path != commonPath {\n\t\tfilename := strings.TrimPrefix(path, commonPath)\n\t\tfilename = strings.TrimPrefix(filename, string(filepath.Separator))\n\t\terr = ar.Write(archiver.File{\n\t\t\tFileInfo: archiver.FileInfo{\n\t\t\t\tFileInfo:   info,\n\t\t\t\tCustomName: filename,\n\t\t\t},\n\t\t\tReadCloser: file,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif info.IsDir() {\n\t\tnames, err := file.Readdirnames(0)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tfor _, name := range names {\n\t\t\tfPath := filepath.Join(path, name)\n\t\t\terr = addFile(ar, d, fPath, commonPath)\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"Failed to archive %s: %v\", fPath, err)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc rawDirHandler(w http.ResponseWriter, r *http.Request, d *data, file *files.FileInfo) (int, error) {\n\tfilenames, err := parseQueryFiles(r, file, d.user)\n\tif err != nil {\n\t\treturn http.StatusInternalServerError, err\n\t}\n\n\textension, ar, err := parseQueryAlgorithm(r)\n\tif err != nil {\n\t\treturn http.StatusInternalServerError, err\n\t}\n\n\terr = ar.Create(w)\n\tif err != nil {\n\t\treturn http.StatusInternalServerError, err\n\t}\n\tdefer ar.Close()\n\n\tcommonDir := fileutils.CommonPrefix(filepath.Separator, filenames...)\n\n\tname := filepath.Base(commonDir)\n\tif name == \".\" || name == \"\" || name == string(filepath.Separator) {\n\t\tname = file.Name\n\t}\n\t// Prefix used to distinguish a filelist generated\n\t// archive from the full directory archive\n\tif len(filenames) > 1 {\n\t\tname = \"_\" + name\n\t}\n\tname += extension\n\tw.Header().Set(\"Content-Disposition\", \"attachment; filename*=utf-8''\"+url.PathEscape(name))\n\n\tfor _, fname := range filenames {\n\t\terr = addFile(ar, d, fname, commonDir)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Failed to archive %s: %v\", fname, err)\n\t\t}\n\t}\n\n\treturn 0, nil\n}\n\nfunc rawFileHandler(w http.ResponseWriter, r *http.Request, file *files.FileInfo) (int, error) {\n\tfd, err := file.Fs.Open(file.Path)\n\tif err != nil {\n\t\treturn http.StatusInternalServerError, err\n\t}\n\tdefer fd.Close()\n\n\tsetContentDisposition(w, r, file)\n\n\tw.Header().Set(\"Cache-Control\", \"private\")\n\thttp.ServeContent(w, r, file.Name, file.ModTime, fd)\n\treturn 0, nil\n}\n"], "fixing_code": ["package http\n\nimport (\n\t\"errors\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/url\"\n\tgopath \"path\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"github.com/mholt/archiver/v3\"\n\n\t\"github.com/filebrowser/filebrowser/v2/files\"\n\t\"github.com/filebrowser/filebrowser/v2/fileutils\"\n\t\"github.com/filebrowser/filebrowser/v2/users\"\n)\n\nfunc slashClean(name string) string {\n\tif name == \"\" || name[0] != '/' {\n\t\tname = \"/\" + name\n\t}\n\treturn gopath.Clean(name)\n}\n\nfunc parseQueryFiles(r *http.Request, f *files.FileInfo, _ *users.User) ([]string, error) {\n\tvar fileSlice []string\n\tnames := strings.Split(r.URL.Query().Get(\"files\"), \",\")\n\n\tif len(names) == 0 {\n\t\tfileSlice = append(fileSlice, f.Path)\n\t} else {\n\t\tfor _, name := range names {\n\t\t\tname, err := url.QueryUnescape(strings.Replace(name, \"+\", \"%2B\", -1)) //nolint:govet\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tname = slashClean(name)\n\t\t\tfileSlice = append(fileSlice, filepath.Join(f.Path, name))\n\t\t}\n\t}\n\n\treturn fileSlice, nil\n}\n\n// nolint: goconst,nolintlint\nfunc parseQueryAlgorithm(r *http.Request) (string, archiver.Writer, error) {\n\t// TODO: use enum\n\tswitch r.URL.Query().Get(\"algo\") {\n\tcase \"zip\", \"true\", \"\":\n\t\treturn \".zip\", archiver.NewZip(), nil\n\tcase \"tar\":\n\t\treturn \".tar\", archiver.NewTar(), nil\n\tcase \"targz\":\n\t\treturn \".tar.gz\", archiver.NewTarGz(), nil\n\tcase \"tarbz2\":\n\t\treturn \".tar.bz2\", archiver.NewTarBz2(), nil\n\tcase \"tarxz\":\n\t\treturn \".tar.xz\", archiver.NewTarXz(), nil\n\tcase \"tarlz4\":\n\t\treturn \".tar.lz4\", archiver.NewTarLz4(), nil\n\tcase \"tarsz\":\n\t\treturn \".tar.sz\", archiver.NewTarSz(), nil\n\tdefault:\n\t\treturn \"\", nil, errors.New(\"format not implemented\")\n\t}\n}\n\nfunc setContentDisposition(w http.ResponseWriter, r *http.Request, file *files.FileInfo) {\n\tif r.URL.Query().Get(\"inline\") == \"true\" {\n\t\tw.Header().Set(\"Content-Disposition\", \"inline\")\n\t} else {\n\t\t// As per RFC6266 section 4.3\n\t\tw.Header().Set(\"Content-Disposition\", \"attachment; filename*=utf-8''\"+url.PathEscape(file.Name))\n\t}\n}\n\nvar rawHandler = withUser(func(w http.ResponseWriter, r *http.Request, d *data) (int, error) {\n\tif !d.user.Perm.Download {\n\t\treturn http.StatusAccepted, nil\n\t}\n\n\tfile, err := files.NewFileInfo(files.FileOptions{\n\t\tFs:         d.user.Fs,\n\t\tPath:       r.URL.Path,\n\t\tModify:     d.user.Perm.Modify,\n\t\tExpand:     false,\n\t\tReadHeader: d.server.TypeDetectionByHeader,\n\t\tChecker:    d,\n\t})\n\tif err != nil {\n\t\treturn errToStatus(err), err\n\t}\n\n\tif files.IsNamedPipe(file.Mode) {\n\t\tsetContentDisposition(w, r, file)\n\t\treturn 0, nil\n\t}\n\n\tif !file.IsDir {\n\t\treturn rawFileHandler(w, r, file)\n\t}\n\n\treturn rawDirHandler(w, r, d, file)\n})\n\nfunc addFile(ar archiver.Writer, d *data, path, commonPath string) error {\n\tif !d.Check(path) {\n\t\treturn nil\n\t}\n\n\tinfo, err := d.user.Fs.Stat(path)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !info.IsDir() && !info.Mode().IsRegular() {\n\t\treturn nil\n\t}\n\n\tfile, err := d.user.Fs.Open(path)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\n\tif path != commonPath {\n\t\tfilename := strings.TrimPrefix(path, commonPath)\n\t\tfilename = strings.TrimPrefix(filename, string(filepath.Separator))\n\t\terr = ar.Write(archiver.File{\n\t\t\tFileInfo: archiver.FileInfo{\n\t\t\t\tFileInfo:   info,\n\t\t\t\tCustomName: filename,\n\t\t\t},\n\t\t\tReadCloser: file,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif info.IsDir() {\n\t\tnames, err := file.Readdirnames(0)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tfor _, name := range names {\n\t\t\tfPath := filepath.Join(path, name)\n\t\t\terr = addFile(ar, d, fPath, commonPath)\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"Failed to archive %s: %v\", fPath, err)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc rawDirHandler(w http.ResponseWriter, r *http.Request, d *data, file *files.FileInfo) (int, error) {\n\tfilenames, err := parseQueryFiles(r, file, d.user)\n\tif err != nil {\n\t\treturn http.StatusInternalServerError, err\n\t}\n\n\textension, ar, err := parseQueryAlgorithm(r)\n\tif err != nil {\n\t\treturn http.StatusInternalServerError, err\n\t}\n\n\terr = ar.Create(w)\n\tif err != nil {\n\t\treturn http.StatusInternalServerError, err\n\t}\n\tdefer ar.Close()\n\n\tcommonDir := fileutils.CommonPrefix(filepath.Separator, filenames...)\n\n\tname := filepath.Base(commonDir)\n\tif name == \".\" || name == \"\" || name == string(filepath.Separator) {\n\t\tname = file.Name\n\t}\n\t// Prefix used to distinguish a filelist generated\n\t// archive from the full directory archive\n\tif len(filenames) > 1 {\n\t\tname = \"_\" + name\n\t}\n\tname += extension\n\tw.Header().Set(\"Content-Disposition\", \"attachment; filename*=utf-8''\"+url.PathEscape(name))\n\n\tfor _, fname := range filenames {\n\t\terr = addFile(ar, d, fname, commonDir)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Failed to archive %s: %v\", fname, err)\n\t\t}\n\t}\n\n\treturn 0, nil\n}\n\nfunc rawFileHandler(w http.ResponseWriter, r *http.Request, file *files.FileInfo) (int, error) {\n\tfd, err := file.Fs.Open(file.Path)\n\tif err != nil {\n\t\treturn http.StatusInternalServerError, err\n\t}\n\tdefer fd.Close()\n\n\tsetContentDisposition(w, r, file)\n\tw.Header().Add(\"Content-Security-Policy\", `script-src 'none';`)\n\tw.Header().Set(\"Cache-Control\", \"private\")\n\thttp.ServeContent(w, r, file.Name, file.ModTime, fd)\n\treturn 0, nil\n}\n"], "filenames": ["http/raw.go"], "buggy_code_start_loc": [210], "buggy_code_end_loc": [211], "fixing_code_start_loc": [210], "fixing_code_end_loc": [211], "type": "CWE-79", "message": "A cross-site scripting (XSS) vulnerability in FileBrowser before v2.23.0 allows an authenticated attacker to escalate privileges to Administrator via user interaction with a crafted HTML file or URL.", "other": {"cve": {"id": "CVE-2023-39612", "sourceIdentifier": "cve@mitre.org", "published": "2023-09-16T01:15:07.397", "lastModified": "2023-09-20T13:16:36.457", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A cross-site scripting (XSS) vulnerability in FileBrowser before v2.23.0 allows an authenticated attacker to escalate privileges to Administrator via user interaction with a crafted HTML file or URL."}, {"lang": "es", "value": "Una vulnerabilidad de Cross-Site Scripting (XSS) en FileBrowser anterior a v2.23.0 permite a un atacante autenticado escalar privilegios a Administrador a trav\u00e9s de la interacci\u00f3n del usuario con un archivo HTML o URL manipulada."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.0, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 2.3, "impactScore": 6.0}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:filebrowser:filebrowser:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.23.0", "matchCriteriaId": "B368F96D-05ED-446B-BA42-68FC7F8A2269"}]}]}], "references": [{"url": "https://febin0x4e4a.wordpress.com/2023/09/15/xss-in-filebrowser-leads-to-admin-account-takeover-in-filebrowser/", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/filebrowser/filebrowser/commit/b508ac3d4f7f0f75d6b49c99bdc661a6d2173f30", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/filebrowser/filebrowser/issues/2570", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking"]}]}, "github_commit_url": "https://github.com/filebrowser/filebrowser/commit/b508ac3d4f7f0f75d6b49c99bdc661a6d2173f30"}}