{"buggy_code": ["/************************************************************\n Copyright (c) 1994 by Silicon Graphics Computer Systems, Inc.\n\n Permission to use, copy, modify, and distribute this\n software and its documentation for any purpose and without\n fee is hereby granted, provided that the above copyright\n notice appear in all copies and that both that copyright\n notice and this permission notice appear in supporting\n documentation, and that the name of Silicon Graphics not be\n used in advertising or publicity pertaining to distribution\n of the software without specific prior written permission.\n Silicon Graphics makes no representation about the suitability\n of this software for any purpose. It is provided \"as is\"\n without any express or implied warranty.\n\n SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS\n SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON\n GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL\n DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,\n DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE\n OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH\n THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n ********************************************************/\n\n/*\n * The parser should work with reasonably recent versions of either\n * bison or byacc.  So if you make changes, try to make sure it works\n * in both!\n */\n\n%{\n#include \"xkbcomp/xkbcomp-priv.h\"\n#include \"xkbcomp/ast-build.h\"\n#include \"xkbcomp/parser-priv.h\"\n#include \"scanner-utils.h\"\n\nstruct parser_param {\n    struct xkb_context *ctx;\n    struct scanner *scanner;\n    XkbFile *rtrn;\n    bool more_maps;\n};\n\n#define parser_err(param, fmt, ...) \\\n    scanner_err((param)->scanner, fmt, ##__VA_ARGS__)\n\n#define parser_warn(param, fmt, ...) \\\n    scanner_warn((param)->scanner, fmt, ##__VA_ARGS__)\n\nstatic void\n_xkbcommon_error(struct parser_param *param, const char *msg)\n{\n    parser_err(param, \"%s\", msg);\n}\n\nstatic bool\nresolve_keysym(const char *name, xkb_keysym_t *sym_rtrn)\n{\n    xkb_keysym_t sym;\n\n    if (!name || istreq(name, \"any\") || istreq(name, \"nosymbol\")) {\n        *sym_rtrn = XKB_KEY_NoSymbol;\n        return true;\n    }\n\n    if (istreq(name, \"none\") || istreq(name, \"voidsymbol\")) {\n        *sym_rtrn = XKB_KEY_VoidSymbol;\n        return true;\n    }\n\n    sym = xkb_keysym_from_name(name, XKB_KEYSYM_NO_FLAGS);\n    if (sym != XKB_KEY_NoSymbol) {\n        *sym_rtrn = sym;\n        return true;\n    }\n\n    return false;\n}\n\n#define param_scanner param->scanner\n%}\n\n%pure-parser\n%lex-param      { struct scanner *param_scanner }\n%parse-param    { struct parser_param *param }\n\n%token\n        END_OF_FILE     0\n        ERROR_TOK       255\n        XKB_KEYMAP      1\n        XKB_KEYCODES    2\n        XKB_TYPES       3\n        XKB_SYMBOLS     4\n        XKB_COMPATMAP   5\n        XKB_GEOMETRY    6\n        XKB_SEMANTICS   7\n        XKB_LAYOUT      8\n        INCLUDE         10\n        OVERRIDE        11\n        AUGMENT         12\n        REPLACE         13\n        ALTERNATE       14\n        VIRTUAL_MODS    20\n        TYPE            21\n        INTERPRET       22\n        ACTION_TOK      23\n        KEY             24\n        ALIAS           25\n        GROUP           26\n        MODIFIER_MAP    27\n        INDICATOR       28\n        SHAPE           29\n        KEYS            30\n        ROW             31\n        SECTION         32\n        OVERLAY         33\n        TEXT            34\n        OUTLINE         35\n        SOLID           36\n        LOGO            37\n        VIRTUAL         38\n        EQUALS          40\n        PLUS            41\n        MINUS           42\n        DIVIDE          43\n        TIMES           44\n        OBRACE          45\n        CBRACE          46\n        OPAREN          47\n        CPAREN          48\n        OBRACKET        49\n        CBRACKET        50\n        DOT             51\n        COMMA           52\n        SEMI            53\n        EXCLAM          54\n        INVERT          55\n        STRING          60\n        INTEGER         61\n        FLOAT           62\n        IDENT           63\n        KEYNAME         64\n        PARTIAL         70\n        DEFAULT         71\n        HIDDEN          72\n        ALPHANUMERIC_KEYS       73\n        MODIFIER_KEYS           74\n        KEYPAD_KEYS             75\n        FUNCTION_KEYS           76\n        ALTERNATE_GROUP         77\n\n%right  EQUALS\n%left   PLUS MINUS\n%left   TIMES DIVIDE\n%left   EXCLAM INVERT\n%left   OPAREN\n\n%start  XkbFile\n\n%union  {\n        int              ival;\n        int64_t          num;\n        enum xkb_file_type file_type;\n        char            *str;\n        xkb_atom_t      atom;\n        enum merge_mode merge;\n        enum xkb_map_flags mapFlags;\n        xkb_keysym_t    keysym;\n        ParseCommon     *any;\n        ExprDef         *expr;\n        VarDef          *var;\n        VModDef         *vmod;\n        InterpDef       *interp;\n        KeyTypeDef      *keyType;\n        SymbolsDef      *syms;\n        ModMapDef       *modMask;\n        GroupCompatDef  *groupCompat;\n        LedMapDef       *ledMap;\n        LedNameDef      *ledName;\n        KeycodeDef      *keyCode;\n        KeyAliasDef     *keyAlias;\n        void            *geom;\n        XkbFile         *file;\n}\n\n%type <num>     INTEGER FLOAT\n%type <str>     IDENT STRING\n%type <atom>    KEYNAME\n%type <num>     KeyCode\n%type <ival>    Number Integer Float SignedNumber DoodadType\n%type <merge>   MergeMode OptMergeMode\n%type <file_type> XkbCompositeType FileType\n%type <mapFlags> Flag Flags OptFlags\n%type <str>     MapName OptMapName\n%type <atom>    FieldSpec Ident Element String\n%type <keysym>  KeySym\n%type <any>     DeclList Decl\n%type <expr>    OptExprList ExprList Expr Term Lhs Terminal ArrayInit KeySyms\n%type <expr>    OptKeySymList KeySymList Action ActionList Coord CoordList\n%type <var>     VarDecl VarDeclList SymbolsBody SymbolsVarDecl\n%type <vmod>    VModDecl VModDefList VModDef\n%type <interp>  InterpretDecl InterpretMatch\n%type <keyType> KeyTypeDecl\n%type <syms>    SymbolsDecl\n%type <modMask> ModMapDecl\n%type <groupCompat> GroupCompatDecl\n%type <ledMap>  LedMapDecl\n%type <ledName> LedNameDecl\n%type <keyCode> KeyNameDecl\n%type <keyAlias> KeyAliasDecl\n%type <geom>    ShapeDecl SectionDecl SectionBody SectionBodyItem RowBody RowBodyItem\n%type <geom>    Keys Key OverlayDecl OverlayKeyList OverlayKey OutlineList OutlineInList\n%type <geom>    DoodadDecl\n%type <file>    XkbFile XkbMapConfigList XkbMapConfig\n%type <file>    XkbCompositeMap\n\n%destructor { FreeStmt((ParseCommon *) $$); }\n    <any> <expr> <var> <vmod> <interp> <keyType> <syms> <modMask> <groupCompat>\n    <ledMap> <ledName> <keyCode> <keyAlias>\n/* The destructor also runs on the start symbol when the parser *succeeds*.\n * The `if` here catches this case. */\n%destructor { if (!param->rtrn) FreeXkbFile($$); } <file>\n%destructor { free($$); } <str>\n\n%%\n\n/*\n * An actual file may contain more than one map. However, if we do things\n * in the normal yacc way, i.e. aggregate all of the maps into a list and\n * let the caller find the map it wants, we end up scanning and parsing a\n * lot of unneeded maps (in the end we always just need one).\n * Instead of doing that, we make yyparse return one map at a time, and\n * then call it repeatedly until we find the map we need. Once we find it,\n * we don't need to parse everything that follows in the file.\n * This does mean that if we e.g. always use the first map, the file may\n * contain complete garbage after that. But it's worth it.\n */\n\nXkbFile         :       XkbCompositeMap\n                        { $$ = param->rtrn = $1; param->more_maps = true; }\n                |       XkbMapConfig\n                        { $$ = param->rtrn = $1; param->more_maps = true; YYACCEPT; }\n                |       END_OF_FILE\n                        { $$ = param->rtrn = NULL; param->more_maps = false; }\n                ;\n\nXkbCompositeMap :       OptFlags XkbCompositeType OptMapName OBRACE\n                            XkbMapConfigList\n                        CBRACE SEMI\n                        { $$ = XkbFileCreate($2, $3, (ParseCommon *) $5, $1); }\n                ;\n\nXkbCompositeType:       XKB_KEYMAP      { $$ = FILE_TYPE_KEYMAP; }\n                |       XKB_SEMANTICS   { $$ = FILE_TYPE_KEYMAP; }\n                |       XKB_LAYOUT      { $$ = FILE_TYPE_KEYMAP; }\n                ;\n\nXkbMapConfigList :      XkbMapConfigList XkbMapConfig\n                        {\n                            if (!$2)\n                                $$ = $1;\n                            else\n                                $$ = (XkbFile *) AppendStmt((ParseCommon *) $1,\n                                                            (ParseCommon *) $2);\n                        }\n                |       XkbMapConfig\n                        { $$ = $1; }\n                ;\n\nXkbMapConfig    :       OptFlags FileType OptMapName OBRACE\n                            DeclList\n                        CBRACE SEMI\n                        {\n                            $$ = XkbFileCreate($2, $3, $5, $1);\n                        }\n                ;\n\nFileType        :       XKB_KEYCODES            { $$ = FILE_TYPE_KEYCODES; }\n                |       XKB_TYPES               { $$ = FILE_TYPE_TYPES; }\n                |       XKB_COMPATMAP           { $$ = FILE_TYPE_COMPAT; }\n                |       XKB_SYMBOLS             { $$ = FILE_TYPE_SYMBOLS; }\n                |       XKB_GEOMETRY            { $$ = FILE_TYPE_GEOMETRY; }\n                ;\n\nOptFlags        :       Flags                   { $$ = $1; }\n                |                               { $$ = 0; }\n                ;\n\nFlags           :       Flags Flag              { $$ = ($1 | $2); }\n                |       Flag                    { $$ = $1; }\n                ;\n\nFlag            :       PARTIAL                 { $$ = MAP_IS_PARTIAL; }\n                |       DEFAULT                 { $$ = MAP_IS_DEFAULT; }\n                |       HIDDEN                  { $$ = MAP_IS_HIDDEN; }\n                |       ALPHANUMERIC_KEYS       { $$ = MAP_HAS_ALPHANUMERIC; }\n                |       MODIFIER_KEYS           { $$ = MAP_HAS_MODIFIER; }\n                |       KEYPAD_KEYS             { $$ = MAP_HAS_KEYPAD; }\n                |       FUNCTION_KEYS           { $$ = MAP_HAS_FN; }\n                |       ALTERNATE_GROUP         { $$ = MAP_IS_ALTGR; }\n                ;\n\nDeclList        :       DeclList Decl\n                        { $$ = AppendStmt($1, $2); }\n                |       { $$ = NULL; }\n                ;\n\nDecl            :       OptMergeMode VarDecl\n                        {\n                            $2->merge = $1;\n                            $$ = (ParseCommon *) $2;\n                        }\n                |       OptMergeMode VModDecl\n                        {\n                            $2->merge = $1;\n                            $$ = (ParseCommon *) $2;\n                        }\n                |       OptMergeMode InterpretDecl\n                        {\n                            $2->merge = $1;\n                            $$ = (ParseCommon *) $2;\n                        }\n                |       OptMergeMode KeyNameDecl\n                        {\n                            $2->merge = $1;\n                            $$ = (ParseCommon *) $2;\n                        }\n                |       OptMergeMode KeyAliasDecl\n                        {\n                            $2->merge = $1;\n                            $$ = (ParseCommon *) $2;\n                        }\n                |       OptMergeMode KeyTypeDecl\n                        {\n                            $2->merge = $1;\n                            $$ = (ParseCommon *) $2;\n                        }\n                |       OptMergeMode SymbolsDecl\n                        {\n                            $2->merge = $1;\n                            $$ = (ParseCommon *) $2;\n                        }\n                |       OptMergeMode ModMapDecl\n                        {\n                            $2->merge = $1;\n                            $$ = (ParseCommon *) $2;\n                        }\n                |       OptMergeMode GroupCompatDecl\n                        {\n                            $2->merge = $1;\n                            $$ = (ParseCommon *) $2;\n                        }\n                |       OptMergeMode LedMapDecl\n                        {\n                            $2->merge = $1;\n                            $$ = (ParseCommon *) $2;\n                        }\n                |       OptMergeMode LedNameDecl\n                        {\n                            $2->merge = $1;\n                            $$ = (ParseCommon *) $2;\n                        }\n                |       OptMergeMode ShapeDecl          { $$ = NULL; }\n                |       OptMergeMode SectionDecl        { $$ = NULL; }\n                |       OptMergeMode DoodadDecl         { $$ = NULL; }\n                |       MergeMode STRING\n                        {\n                            $$ = (ParseCommon *) IncludeCreate(param->ctx, $2, $1);\n                            free($2);\n                        }\n                ;\n\nVarDecl         :       Lhs EQUALS Expr SEMI\n                        { $$ = VarCreate($1, $3); }\n                |       Ident SEMI\n                        { $$ = BoolVarCreate($1, true); }\n                |       EXCLAM Ident SEMI\n                        { $$ = BoolVarCreate($2, false); }\n                ;\n\nKeyNameDecl     :       KEYNAME EQUALS KeyCode SEMI\n                        { $$ = KeycodeCreate($1, $3); }\n                ;\n\nKeyAliasDecl    :       ALIAS KEYNAME EQUALS KEYNAME SEMI\n                        { $$ = KeyAliasCreate($2, $4); }\n                ;\n\nVModDecl        :       VIRTUAL_MODS VModDefList SEMI\n                        { $$ = $2; }\n                ;\n\nVModDefList     :       VModDefList COMMA VModDef\n                        { $$ = (VModDef *) AppendStmt((ParseCommon *) $1,\n                                                      (ParseCommon *) $3); }\n                |       VModDef\n                        { $$ = $1; }\n                ;\n\nVModDef         :       Ident\n                        { $$ = VModCreate($1, NULL); }\n                |       Ident EQUALS Expr\n                        { $$ = VModCreate($1, $3); }\n                ;\n\nInterpretDecl   :       INTERPRET InterpretMatch OBRACE\n                            VarDeclList\n                        CBRACE SEMI\n                        { $2->def = $4; $$ = $2; }\n                ;\n\nInterpretMatch  :       KeySym PLUS Expr\n                        { $$ = InterpCreate($1, $3); }\n                |       KeySym\n                        { $$ = InterpCreate($1, NULL); }\n                ;\n\nVarDeclList     :       VarDeclList VarDecl\n                        { $$ = (VarDef *) AppendStmt((ParseCommon *) $1,\n                                                     (ParseCommon *) $2); }\n                |       VarDecl\n                        { $$ = $1; }\n                ;\n\nKeyTypeDecl     :       TYPE String OBRACE\n                            VarDeclList\n                        CBRACE SEMI\n                        { $$ = KeyTypeCreate($2, $4); }\n                ;\n\nSymbolsDecl     :       KEY KEYNAME OBRACE\n                            SymbolsBody\n                        CBRACE SEMI\n                        { $$ = SymbolsCreate($2, $4); }\n                ;\n\nSymbolsBody     :       SymbolsBody COMMA SymbolsVarDecl\n                        { $$ = (VarDef *) AppendStmt((ParseCommon *) $1,\n                                                     (ParseCommon *) $3); }\n                |       SymbolsVarDecl\n                        { $$ = $1; }\n                |       { $$ = NULL; }\n                ;\n\nSymbolsVarDecl  :       Lhs EQUALS Expr         { $$ = VarCreate($1, $3); }\n                |       Lhs EQUALS ArrayInit    { $$ = VarCreate($1, $3); }\n                |       Ident                   { $$ = BoolVarCreate($1, true); }\n                |       EXCLAM Ident            { $$ = BoolVarCreate($2, false); }\n                |       ArrayInit               { $$ = VarCreate(NULL, $1); }\n                ;\n\nArrayInit       :       OBRACKET OptKeySymList CBRACKET\n                        { $$ = $2; }\n                |       OBRACKET ActionList CBRACKET\n                        { $$ = ExprCreateUnary(EXPR_ACTION_LIST, EXPR_TYPE_ACTION, $2); }\n                ;\n\nGroupCompatDecl :       GROUP Integer EQUALS Expr SEMI\n                        { $$ = GroupCompatCreate($2, $4); }\n                ;\n\nModMapDecl      :       MODIFIER_MAP Ident OBRACE ExprList CBRACE SEMI\n                        { $$ = ModMapCreate($2, $4); }\n                ;\n\nLedMapDecl:             INDICATOR String OBRACE VarDeclList CBRACE SEMI\n                        { $$ = LedMapCreate($2, $4); }\n                ;\n\nLedNameDecl:            INDICATOR Integer EQUALS Expr SEMI\n                        { $$ = LedNameCreate($2, $4, false); }\n                |       VIRTUAL INDICATOR Integer EQUALS Expr SEMI\n                        { $$ = LedNameCreate($3, $5, true); }\n                ;\n\nShapeDecl       :       SHAPE String OBRACE OutlineList CBRACE SEMI\n                        { $$ = NULL; }\n                |       SHAPE String OBRACE CoordList CBRACE SEMI\n                        { (void) $4; $$ = NULL; }\n                ;\n\nSectionDecl     :       SECTION String OBRACE SectionBody CBRACE SEMI\n                        { $$ = NULL; }\n                ;\n\nSectionBody     :       SectionBody SectionBodyItem     { $$ = NULL;}\n                |       SectionBodyItem                 { $$ = NULL; }\n                ;\n\nSectionBodyItem :       ROW OBRACE RowBody CBRACE SEMI\n                        { $$ = NULL; }\n                |       VarDecl\n                        { FreeStmt((ParseCommon *) $1); $$ = NULL; }\n                |       DoodadDecl\n                        { $$ = NULL; }\n                |       LedMapDecl\n                        { FreeStmt((ParseCommon *) $1); $$ = NULL; }\n                |       OverlayDecl\n                        { $$ = NULL; }\n                ;\n\nRowBody         :       RowBody RowBodyItem     { $$ = NULL;}\n                |       RowBodyItem             { $$ = NULL; }\n                ;\n\nRowBodyItem     :       KEYS OBRACE Keys CBRACE SEMI { $$ = NULL; }\n                |       VarDecl\n                        { FreeStmt((ParseCommon *) $1); $$ = NULL; }\n                ;\n\nKeys            :       Keys COMMA Key          { $$ = NULL; }\n                |       Key                     { $$ = NULL; }\n                ;\n\nKey             :       KEYNAME\n                        { $$ = NULL; }\n                |       OBRACE ExprList CBRACE\n                        { FreeStmt((ParseCommon *) $2); $$ = NULL; }\n                ;\n\nOverlayDecl     :       OVERLAY String OBRACE OverlayKeyList CBRACE SEMI\n                        { $$ = NULL; }\n                ;\n\nOverlayKeyList  :       OverlayKeyList COMMA OverlayKey { $$ = NULL; }\n                |       OverlayKey                      { $$ = NULL; }\n                ;\n\nOverlayKey      :       KEYNAME EQUALS KEYNAME          { $$ = NULL; }\n                ;\n\nOutlineList     :       OutlineList COMMA OutlineInList\n                        { $$ = NULL;}\n                |       OutlineInList\n                        { $$ = NULL; }\n                ;\n\nOutlineInList   :       OBRACE CoordList CBRACE\n                        { (void) $2; $$ = NULL; }\n                |       Ident EQUALS OBRACE CoordList CBRACE\n                        { (void) $4; $$ = NULL; }\n                |       Ident EQUALS Expr\n                        { FreeStmt((ParseCommon *) $3); $$ = NULL; }\n                ;\n\nCoordList       :       CoordList COMMA Coord\n                        { (void) $1; (void) $3; $$ = NULL; }\n                |       Coord\n                        { (void) $1; $$ = NULL; }\n                ;\n\nCoord           :       OBRACKET SignedNumber COMMA SignedNumber CBRACKET\n                        { $$ = NULL; }\n                ;\n\nDoodadDecl      :       DoodadType String OBRACE VarDeclList CBRACE SEMI\n                        { FreeStmt((ParseCommon *) $4); $$ = NULL; }\n                ;\n\nDoodadType      :       TEXT    { $$ = 0; }\n                |       OUTLINE { $$ = 0; }\n                |       SOLID   { $$ = 0; }\n                |       LOGO    { $$ = 0; }\n                ;\n\nFieldSpec       :       Ident   { $$ = $1; }\n                |       Element { $$ = $1; }\n                ;\n\nElement         :       ACTION_TOK\n                        { $$ = xkb_atom_intern_literal(param->ctx, \"action\"); }\n                |       INTERPRET\n                        { $$ = xkb_atom_intern_literal(param->ctx, \"interpret\"); }\n                |       TYPE\n                        { $$ = xkb_atom_intern_literal(param->ctx, \"type\"); }\n                |       KEY\n                        { $$ = xkb_atom_intern_literal(param->ctx, \"key\"); }\n                |       GROUP\n                        { $$ = xkb_atom_intern_literal(param->ctx, \"group\"); }\n                |       MODIFIER_MAP\n                        {$$ = xkb_atom_intern_literal(param->ctx, \"modifier_map\");}\n                |       INDICATOR\n                        { $$ = xkb_atom_intern_literal(param->ctx, \"indicator\"); }\n                |       SHAPE\n                        { $$ = xkb_atom_intern_literal(param->ctx, \"shape\"); }\n                |       ROW\n                        { $$ = xkb_atom_intern_literal(param->ctx, \"row\"); }\n                |       SECTION\n                        { $$ = xkb_atom_intern_literal(param->ctx, \"section\"); }\n                |       TEXT\n                        { $$ = xkb_atom_intern_literal(param->ctx, \"text\"); }\n                ;\n\nOptMergeMode    :       MergeMode       { $$ = $1; }\n                |                       { $$ = MERGE_DEFAULT; }\n                ;\n\nMergeMode       :       INCLUDE         { $$ = MERGE_DEFAULT; }\n                |       AUGMENT         { $$ = MERGE_AUGMENT; }\n                |       OVERRIDE        { $$ = MERGE_OVERRIDE; }\n                |       REPLACE         { $$ = MERGE_REPLACE; }\n                |       ALTERNATE\n                {\n                    /*\n                     * This used to be MERGE_ALT_FORM. This functionality was\n                     * unused and has been removed.\n                     */\n                    $$ = MERGE_DEFAULT;\n                }\n                ;\n\nOptExprList     :       ExprList        { $$ = $1; }\n                |                       { $$ = NULL; }\n                ;\n\nExprList        :       ExprList COMMA Expr\n                        { $$ = (ExprDef *) AppendStmt((ParseCommon *) $1,\n                                                      (ParseCommon *) $3); }\n                |       Expr\n                        { $$ = $1; }\n                ;\n\nExpr            :       Expr DIVIDE Expr\n                        { $$ = ExprCreateBinary(EXPR_DIVIDE, $1, $3); }\n                |       Expr PLUS Expr\n                        { $$ = ExprCreateBinary(EXPR_ADD, $1, $3); }\n                |       Expr MINUS Expr\n                        { $$ = ExprCreateBinary(EXPR_SUBTRACT, $1, $3); }\n                |       Expr TIMES Expr\n                        { $$ = ExprCreateBinary(EXPR_MULTIPLY, $1, $3); }\n                |       Lhs EQUALS Expr\n                        { $$ = ExprCreateBinary(EXPR_ASSIGN, $1, $3); }\n                |       Term\n                        { $$ = $1; }\n                ;\n\nTerm            :       MINUS Term\n                        { $$ = ExprCreateUnary(EXPR_NEGATE, $2->expr.value_type, $2); }\n                |       PLUS Term\n                        { $$ = ExprCreateUnary(EXPR_UNARY_PLUS, $2->expr.value_type, $2); }\n                |       EXCLAM Term\n                        { $$ = ExprCreateUnary(EXPR_NOT, EXPR_TYPE_BOOLEAN, $2); }\n                |       INVERT Term\n                        { $$ = ExprCreateUnary(EXPR_INVERT, $2->expr.value_type, $2); }\n                |       Lhs\n                        { $$ = $1;  }\n                |       FieldSpec OPAREN OptExprList CPAREN %prec OPAREN\n                        { $$ = ExprCreateAction($1, $3); }\n                |       Terminal\n                        { $$ = $1;  }\n                |       OPAREN Expr CPAREN\n                        { $$ = $2;  }\n                ;\n\nActionList      :       ActionList COMMA Action\n                        { $$ = (ExprDef *) AppendStmt((ParseCommon *) $1,\n                                                      (ParseCommon *) $3); }\n                |       Action\n                        { $$ = $1; }\n                ;\n\nAction          :       FieldSpec OPAREN OptExprList CPAREN\n                        { $$ = ExprCreateAction($1, $3); }\n                ;\n\nLhs             :       FieldSpec\n                        { $$ = ExprCreateIdent($1); }\n                |       FieldSpec DOT FieldSpec\n                        { $$ = ExprCreateFieldRef($1, $3); }\n                |       FieldSpec OBRACKET Expr CBRACKET\n                        { $$ = ExprCreateArrayRef(XKB_ATOM_NONE, $1, $3); }\n                |       FieldSpec DOT FieldSpec OBRACKET Expr CBRACKET\n                        { $$ = ExprCreateArrayRef($1, $3, $5); }\n                ;\n\nTerminal        :       String\n                        { $$ = ExprCreateString($1); }\n                |       Integer\n                        { $$ = ExprCreateInteger($1); }\n                |       Float\n                        { $$ = ExprCreateFloat(/* Discard $1 */); }\n                |       KEYNAME\n                        { $$ = ExprCreateKeyName($1); }\n                ;\n\nOptKeySymList   :       KeySymList      { $$ = $1; }\n                |                       { $$ = NULL; }\n                ;\n\nKeySymList      :       KeySymList COMMA KeySym\n                        { $$ = ExprAppendKeysymList($1, $3); }\n                |       KeySymList COMMA KeySyms\n                        { $$ = ExprAppendMultiKeysymList($1, $3); }\n                |       KeySym\n                        { $$ = ExprCreateKeysymList($1); }\n                |       KeySyms\n                        { $$ = ExprCreateMultiKeysymList($1); }\n                ;\n\nKeySyms         :       OBRACE KeySymList CBRACE\n                        { $$ = $2; }\n                ;\n\nKeySym          :       IDENT\n                        {\n                            if (!resolve_keysym($1, &$$))\n                                parser_warn(param, \"unrecognized keysym \\\"%s\\\"\", $1);\n                            free($1);\n                        }\n                |       SECTION { $$ = XKB_KEY_section; }\n                |       Integer\n                        {\n                            if ($1 < 0) {\n                                parser_warn(param, \"unrecognized keysym \\\"%d\\\"\", $1);\n                                $$ = XKB_KEY_NoSymbol;\n                            }\n                            else if ($1 < 10) {      /* XKB_KEY_0 .. XKB_KEY_9 */\n                                $$ = XKB_KEY_0 + (xkb_keysym_t) $1;\n                            }\n                            else {\n                                char buf[17];\n                                snprintf(buf, sizeof(buf), \"0x%x\", $1);\n                                if (!resolve_keysym(buf, &$$)) {\n                                    parser_warn(param, \"unrecognized keysym \\\"%s\\\"\", buf);\n                                    $$ = XKB_KEY_NoSymbol;\n                                }\n                            }\n                        }\n                ;\n\nSignedNumber    :       MINUS Number    { $$ = -$2; }\n                |       Number          { $$ = $1; }\n                ;\n\nNumber          :       FLOAT   { $$ = $1; }\n                |       INTEGER { $$ = $1; }\n                ;\n\nFloat           :       FLOAT   { $$ = 0; }\n                ;\n\nInteger         :       INTEGER { $$ = $1; }\n                ;\n\nKeyCode         :       INTEGER { $$ = $1; }\n                ;\n\nIdent           :       IDENT   { $$ = xkb_atom_steal(param->ctx, $1); }\n                |       DEFAULT { $$ = xkb_atom_intern_literal(param->ctx, \"default\"); }\n                ;\n\nString          :       STRING  { $$ = xkb_atom_steal(param->ctx, $1); }\n                ;\n\nOptMapName      :       MapName { $$ = $1; }\n                |               { $$ = NULL; }\n                ;\n\nMapName         :       STRING  { $$ = $1; }\n                ;\n\n%%\n\nXkbFile *\nparse(struct xkb_context *ctx, struct scanner *scanner, const char *map)\n{\n    int ret;\n    XkbFile *first = NULL;\n    struct parser_param param = {\n        .scanner = scanner,\n        .ctx = ctx,\n        .rtrn = NULL,\n    };\n\n    /*\n     * If we got a specific map, we look for it exclusively and return\n     * immediately upon finding it. Otherwise, we need to get the\n     * default map. If we find a map marked as default, we return it\n     * immediately. If there are no maps marked as default, we return\n     * the first map in the file.\n     */\n\n    while ((ret = yyparse(&param)) == 0 && param.more_maps) {\n        if (map) {\n            if (streq_not_null(map, param.rtrn->name))\n                return param.rtrn;\n            else\n                FreeXkbFile(param.rtrn);\n        }\n        else {\n            if (param.rtrn->flags & MAP_IS_DEFAULT) {\n                FreeXkbFile(first);\n                return param.rtrn;\n            }\n            else if (!first) {\n                first = param.rtrn;\n            }\n            else {\n                FreeXkbFile(param.rtrn);\n            }\n        }\n        param.rtrn = NULL;\n    }\n\n    if (ret != 0) {\n        FreeXkbFile(first);\n        return NULL;\n    }\n\n    if (first)\n        log_vrb(ctx, 5,\n                \"No map in include statement, but \\\"%s\\\" contains several; \"\n                \"Using first defined map, \\\"%s\\\"\\n\",\n                scanner->file_name, first->name);\n\n    return first;\n}\n"], "fixing_code": ["/************************************************************\n Copyright (c) 1994 by Silicon Graphics Computer Systems, Inc.\n\n Permission to use, copy, modify, and distribute this\n software and its documentation for any purpose and without\n fee is hereby granted, provided that the above copyright\n notice appear in all copies and that both that copyright\n notice and this permission notice appear in supporting\n documentation, and that the name of Silicon Graphics not be\n used in advertising or publicity pertaining to distribution\n of the software without specific prior written permission.\n Silicon Graphics makes no representation about the suitability\n of this software for any purpose. It is provided \"as is\"\n without any express or implied warranty.\n\n SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS\n SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON\n GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL\n DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,\n DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE\n OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH\n THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n ********************************************************/\n\n/*\n * The parser should work with reasonably recent versions of either\n * bison or byacc.  So if you make changes, try to make sure it works\n * in both!\n */\n\n%{\n#include \"xkbcomp/xkbcomp-priv.h\"\n#include \"xkbcomp/ast-build.h\"\n#include \"xkbcomp/parser-priv.h\"\n#include \"scanner-utils.h\"\n\nstruct parser_param {\n    struct xkb_context *ctx;\n    struct scanner *scanner;\n    XkbFile *rtrn;\n    bool more_maps;\n};\n\n#define parser_err(param, fmt, ...) \\\n    scanner_err((param)->scanner, fmt, ##__VA_ARGS__)\n\n#define parser_warn(param, fmt, ...) \\\n    scanner_warn((param)->scanner, fmt, ##__VA_ARGS__)\n\nstatic void\n_xkbcommon_error(struct parser_param *param, const char *msg)\n{\n    parser_err(param, \"%s\", msg);\n}\n\nstatic bool\nresolve_keysym(const char *name, xkb_keysym_t *sym_rtrn)\n{\n    xkb_keysym_t sym;\n\n    if (!name || istreq(name, \"any\") || istreq(name, \"nosymbol\")) {\n        *sym_rtrn = XKB_KEY_NoSymbol;\n        return true;\n    }\n\n    if (istreq(name, \"none\") || istreq(name, \"voidsymbol\")) {\n        *sym_rtrn = XKB_KEY_VoidSymbol;\n        return true;\n    }\n\n    sym = xkb_keysym_from_name(name, XKB_KEYSYM_NO_FLAGS);\n    if (sym != XKB_KEY_NoSymbol) {\n        *sym_rtrn = sym;\n        return true;\n    }\n\n    return false;\n}\n\n#define param_scanner param->scanner\n%}\n\n%pure-parser\n%lex-param      { struct scanner *param_scanner }\n%parse-param    { struct parser_param *param }\n\n%token\n        END_OF_FILE     0\n        ERROR_TOK       255\n        XKB_KEYMAP      1\n        XKB_KEYCODES    2\n        XKB_TYPES       3\n        XKB_SYMBOLS     4\n        XKB_COMPATMAP   5\n        XKB_GEOMETRY    6\n        XKB_SEMANTICS   7\n        XKB_LAYOUT      8\n        INCLUDE         10\n        OVERRIDE        11\n        AUGMENT         12\n        REPLACE         13\n        ALTERNATE       14\n        VIRTUAL_MODS    20\n        TYPE            21\n        INTERPRET       22\n        ACTION_TOK      23\n        KEY             24\n        ALIAS           25\n        GROUP           26\n        MODIFIER_MAP    27\n        INDICATOR       28\n        SHAPE           29\n        KEYS            30\n        ROW             31\n        SECTION         32\n        OVERLAY         33\n        TEXT            34\n        OUTLINE         35\n        SOLID           36\n        LOGO            37\n        VIRTUAL         38\n        EQUALS          40\n        PLUS            41\n        MINUS           42\n        DIVIDE          43\n        TIMES           44\n        OBRACE          45\n        CBRACE          46\n        OPAREN          47\n        CPAREN          48\n        OBRACKET        49\n        CBRACKET        50\n        DOT             51\n        COMMA           52\n        SEMI            53\n        EXCLAM          54\n        INVERT          55\n        STRING          60\n        INTEGER         61\n        FLOAT           62\n        IDENT           63\n        KEYNAME         64\n        PARTIAL         70\n        DEFAULT         71\n        HIDDEN          72\n        ALPHANUMERIC_KEYS       73\n        MODIFIER_KEYS           74\n        KEYPAD_KEYS             75\n        FUNCTION_KEYS           76\n        ALTERNATE_GROUP         77\n\n%right  EQUALS\n%left   PLUS MINUS\n%left   TIMES DIVIDE\n%left   EXCLAM INVERT\n%left   OPAREN\n\n%start  XkbFile\n\n%union  {\n        int              ival;\n        int64_t          num;\n        enum xkb_file_type file_type;\n        char            *str;\n        xkb_atom_t      atom;\n        enum merge_mode merge;\n        enum xkb_map_flags mapFlags;\n        xkb_keysym_t    keysym;\n        ParseCommon     *any;\n        ExprDef         *expr;\n        VarDef          *var;\n        VModDef         *vmod;\n        InterpDef       *interp;\n        KeyTypeDef      *keyType;\n        SymbolsDef      *syms;\n        ModMapDef       *modMask;\n        GroupCompatDef  *groupCompat;\n        LedMapDef       *ledMap;\n        LedNameDef      *ledName;\n        KeycodeDef      *keyCode;\n        KeyAliasDef     *keyAlias;\n        void            *geom;\n        XkbFile         *file;\n}\n\n%type <num>     INTEGER FLOAT\n%type <str>     IDENT STRING\n%type <atom>    KEYNAME\n%type <num>     KeyCode\n%type <ival>    Number Integer Float SignedNumber DoodadType\n%type <merge>   MergeMode OptMergeMode\n%type <file_type> XkbCompositeType FileType\n%type <mapFlags> Flag Flags OptFlags\n%type <str>     MapName OptMapName\n%type <atom>    FieldSpec Ident Element String\n%type <keysym>  KeySym\n%type <any>     DeclList Decl\n%type <expr>    OptExprList ExprList Expr Term Lhs Terminal ArrayInit KeySyms\n%type <expr>    OptKeySymList KeySymList Action ActionList Coord CoordList\n%type <var>     VarDecl VarDeclList SymbolsBody SymbolsVarDecl\n%type <vmod>    VModDecl VModDefList VModDef\n%type <interp>  InterpretDecl InterpretMatch\n%type <keyType> KeyTypeDecl\n%type <syms>    SymbolsDecl\n%type <modMask> ModMapDecl\n%type <groupCompat> GroupCompatDecl\n%type <ledMap>  LedMapDecl\n%type <ledName> LedNameDecl\n%type <keyCode> KeyNameDecl\n%type <keyAlias> KeyAliasDecl\n%type <geom>    ShapeDecl SectionDecl SectionBody SectionBodyItem RowBody RowBodyItem\n%type <geom>    Keys Key OverlayDecl OverlayKeyList OverlayKey OutlineList OutlineInList\n%type <geom>    DoodadDecl\n%type <file>    XkbFile XkbMapConfigList XkbMapConfig\n%type <file>    XkbCompositeMap\n\n%destructor { FreeStmt((ParseCommon *) $$); }\n    <any> <expr> <var> <vmod> <interp> <keyType> <syms> <modMask> <groupCompat>\n    <ledMap> <ledName> <keyCode> <keyAlias>\n/* The destructor also runs on the start symbol when the parser *succeeds*.\n * The `if` here catches this case. */\n%destructor { if (!param->rtrn) FreeXkbFile($$); } <file>\n%destructor { free($$); } <str>\n\n%%\n\n/*\n * An actual file may contain more than one map. However, if we do things\n * in the normal yacc way, i.e. aggregate all of the maps into a list and\n * let the caller find the map it wants, we end up scanning and parsing a\n * lot of unneeded maps (in the end we always just need one).\n * Instead of doing that, we make yyparse return one map at a time, and\n * then call it repeatedly until we find the map we need. Once we find it,\n * we don't need to parse everything that follows in the file.\n * This does mean that if we e.g. always use the first map, the file may\n * contain complete garbage after that. But it's worth it.\n */\n\nXkbFile         :       XkbCompositeMap\n                        { $$ = param->rtrn = $1; param->more_maps = !!param->rtrn; }\n                |       XkbMapConfig\n                        { $$ = param->rtrn = $1; param->more_maps = !!param->rtrn; YYACCEPT; }\n                |       END_OF_FILE\n                        { $$ = param->rtrn = NULL; param->more_maps = false; }\n                ;\n\nXkbCompositeMap :       OptFlags XkbCompositeType OptMapName OBRACE\n                            XkbMapConfigList\n                        CBRACE SEMI\n                        { $$ = XkbFileCreate($2, $3, (ParseCommon *) $5, $1); }\n                ;\n\nXkbCompositeType:       XKB_KEYMAP      { $$ = FILE_TYPE_KEYMAP; }\n                |       XKB_SEMANTICS   { $$ = FILE_TYPE_KEYMAP; }\n                |       XKB_LAYOUT      { $$ = FILE_TYPE_KEYMAP; }\n                ;\n\nXkbMapConfigList :      XkbMapConfigList XkbMapConfig\n                        {\n                            if (!$2)\n                                $$ = $1;\n                            else\n                                $$ = (XkbFile *) AppendStmt((ParseCommon *) $1,\n                                                            (ParseCommon *) $2);\n                        }\n                |       XkbMapConfig\n                        { $$ = $1; }\n                ;\n\nXkbMapConfig    :       OptFlags FileType OptMapName OBRACE\n                            DeclList\n                        CBRACE SEMI\n                        {\n                            $$ = XkbFileCreate($2, $3, $5, $1);\n                        }\n                ;\n\nFileType        :       XKB_KEYCODES            { $$ = FILE_TYPE_KEYCODES; }\n                |       XKB_TYPES               { $$ = FILE_TYPE_TYPES; }\n                |       XKB_COMPATMAP           { $$ = FILE_TYPE_COMPAT; }\n                |       XKB_SYMBOLS             { $$ = FILE_TYPE_SYMBOLS; }\n                |       XKB_GEOMETRY            { $$ = FILE_TYPE_GEOMETRY; }\n                ;\n\nOptFlags        :       Flags                   { $$ = $1; }\n                |                               { $$ = 0; }\n                ;\n\nFlags           :       Flags Flag              { $$ = ($1 | $2); }\n                |       Flag                    { $$ = $1; }\n                ;\n\nFlag            :       PARTIAL                 { $$ = MAP_IS_PARTIAL; }\n                |       DEFAULT                 { $$ = MAP_IS_DEFAULT; }\n                |       HIDDEN                  { $$ = MAP_IS_HIDDEN; }\n                |       ALPHANUMERIC_KEYS       { $$ = MAP_HAS_ALPHANUMERIC; }\n                |       MODIFIER_KEYS           { $$ = MAP_HAS_MODIFIER; }\n                |       KEYPAD_KEYS             { $$ = MAP_HAS_KEYPAD; }\n                |       FUNCTION_KEYS           { $$ = MAP_HAS_FN; }\n                |       ALTERNATE_GROUP         { $$ = MAP_IS_ALTGR; }\n                ;\n\nDeclList        :       DeclList Decl\n                        { $$ = AppendStmt($1, $2); }\n                |       { $$ = NULL; }\n                ;\n\nDecl            :       OptMergeMode VarDecl\n                        {\n                            $2->merge = $1;\n                            $$ = (ParseCommon *) $2;\n                        }\n                |       OptMergeMode VModDecl\n                        {\n                            $2->merge = $1;\n                            $$ = (ParseCommon *) $2;\n                        }\n                |       OptMergeMode InterpretDecl\n                        {\n                            $2->merge = $1;\n                            $$ = (ParseCommon *) $2;\n                        }\n                |       OptMergeMode KeyNameDecl\n                        {\n                            $2->merge = $1;\n                            $$ = (ParseCommon *) $2;\n                        }\n                |       OptMergeMode KeyAliasDecl\n                        {\n                            $2->merge = $1;\n                            $$ = (ParseCommon *) $2;\n                        }\n                |       OptMergeMode KeyTypeDecl\n                        {\n                            $2->merge = $1;\n                            $$ = (ParseCommon *) $2;\n                        }\n                |       OptMergeMode SymbolsDecl\n                        {\n                            $2->merge = $1;\n                            $$ = (ParseCommon *) $2;\n                        }\n                |       OptMergeMode ModMapDecl\n                        {\n                            $2->merge = $1;\n                            $$ = (ParseCommon *) $2;\n                        }\n                |       OptMergeMode GroupCompatDecl\n                        {\n                            $2->merge = $1;\n                            $$ = (ParseCommon *) $2;\n                        }\n                |       OptMergeMode LedMapDecl\n                        {\n                            $2->merge = $1;\n                            $$ = (ParseCommon *) $2;\n                        }\n                |       OptMergeMode LedNameDecl\n                        {\n                            $2->merge = $1;\n                            $$ = (ParseCommon *) $2;\n                        }\n                |       OptMergeMode ShapeDecl          { $$ = NULL; }\n                |       OptMergeMode SectionDecl        { $$ = NULL; }\n                |       OptMergeMode DoodadDecl         { $$ = NULL; }\n                |       MergeMode STRING\n                        {\n                            $$ = (ParseCommon *) IncludeCreate(param->ctx, $2, $1);\n                            free($2);\n                        }\n                ;\n\nVarDecl         :       Lhs EQUALS Expr SEMI\n                        { $$ = VarCreate($1, $3); }\n                |       Ident SEMI\n                        { $$ = BoolVarCreate($1, true); }\n                |       EXCLAM Ident SEMI\n                        { $$ = BoolVarCreate($2, false); }\n                ;\n\nKeyNameDecl     :       KEYNAME EQUALS KeyCode SEMI\n                        { $$ = KeycodeCreate($1, $3); }\n                ;\n\nKeyAliasDecl    :       ALIAS KEYNAME EQUALS KEYNAME SEMI\n                        { $$ = KeyAliasCreate($2, $4); }\n                ;\n\nVModDecl        :       VIRTUAL_MODS VModDefList SEMI\n                        { $$ = $2; }\n                ;\n\nVModDefList     :       VModDefList COMMA VModDef\n                        { $$ = (VModDef *) AppendStmt((ParseCommon *) $1,\n                                                      (ParseCommon *) $3); }\n                |       VModDef\n                        { $$ = $1; }\n                ;\n\nVModDef         :       Ident\n                        { $$ = VModCreate($1, NULL); }\n                |       Ident EQUALS Expr\n                        { $$ = VModCreate($1, $3); }\n                ;\n\nInterpretDecl   :       INTERPRET InterpretMatch OBRACE\n                            VarDeclList\n                        CBRACE SEMI\n                        { $2->def = $4; $$ = $2; }\n                ;\n\nInterpretMatch  :       KeySym PLUS Expr\n                        { $$ = InterpCreate($1, $3); }\n                |       KeySym\n                        { $$ = InterpCreate($1, NULL); }\n                ;\n\nVarDeclList     :       VarDeclList VarDecl\n                        { $$ = (VarDef *) AppendStmt((ParseCommon *) $1,\n                                                     (ParseCommon *) $2); }\n                |       VarDecl\n                        { $$ = $1; }\n                ;\n\nKeyTypeDecl     :       TYPE String OBRACE\n                            VarDeclList\n                        CBRACE SEMI\n                        { $$ = KeyTypeCreate($2, $4); }\n                ;\n\nSymbolsDecl     :       KEY KEYNAME OBRACE\n                            SymbolsBody\n                        CBRACE SEMI\n                        { $$ = SymbolsCreate($2, $4); }\n                ;\n\nSymbolsBody     :       SymbolsBody COMMA SymbolsVarDecl\n                        { $$ = (VarDef *) AppendStmt((ParseCommon *) $1,\n                                                     (ParseCommon *) $3); }\n                |       SymbolsVarDecl\n                        { $$ = $1; }\n                |       { $$ = NULL; }\n                ;\n\nSymbolsVarDecl  :       Lhs EQUALS Expr         { $$ = VarCreate($1, $3); }\n                |       Lhs EQUALS ArrayInit    { $$ = VarCreate($1, $3); }\n                |       Ident                   { $$ = BoolVarCreate($1, true); }\n                |       EXCLAM Ident            { $$ = BoolVarCreate($2, false); }\n                |       ArrayInit               { $$ = VarCreate(NULL, $1); }\n                ;\n\nArrayInit       :       OBRACKET OptKeySymList CBRACKET\n                        { $$ = $2; }\n                |       OBRACKET ActionList CBRACKET\n                        { $$ = ExprCreateUnary(EXPR_ACTION_LIST, EXPR_TYPE_ACTION, $2); }\n                ;\n\nGroupCompatDecl :       GROUP Integer EQUALS Expr SEMI\n                        { $$ = GroupCompatCreate($2, $4); }\n                ;\n\nModMapDecl      :       MODIFIER_MAP Ident OBRACE ExprList CBRACE SEMI\n                        { $$ = ModMapCreate($2, $4); }\n                ;\n\nLedMapDecl:             INDICATOR String OBRACE VarDeclList CBRACE SEMI\n                        { $$ = LedMapCreate($2, $4); }\n                ;\n\nLedNameDecl:            INDICATOR Integer EQUALS Expr SEMI\n                        { $$ = LedNameCreate($2, $4, false); }\n                |       VIRTUAL INDICATOR Integer EQUALS Expr SEMI\n                        { $$ = LedNameCreate($3, $5, true); }\n                ;\n\nShapeDecl       :       SHAPE String OBRACE OutlineList CBRACE SEMI\n                        { $$ = NULL; }\n                |       SHAPE String OBRACE CoordList CBRACE SEMI\n                        { (void) $4; $$ = NULL; }\n                ;\n\nSectionDecl     :       SECTION String OBRACE SectionBody CBRACE SEMI\n                        { $$ = NULL; }\n                ;\n\nSectionBody     :       SectionBody SectionBodyItem     { $$ = NULL;}\n                |       SectionBodyItem                 { $$ = NULL; }\n                ;\n\nSectionBodyItem :       ROW OBRACE RowBody CBRACE SEMI\n                        { $$ = NULL; }\n                |       VarDecl\n                        { FreeStmt((ParseCommon *) $1); $$ = NULL; }\n                |       DoodadDecl\n                        { $$ = NULL; }\n                |       LedMapDecl\n                        { FreeStmt((ParseCommon *) $1); $$ = NULL; }\n                |       OverlayDecl\n                        { $$ = NULL; }\n                ;\n\nRowBody         :       RowBody RowBodyItem     { $$ = NULL;}\n                |       RowBodyItem             { $$ = NULL; }\n                ;\n\nRowBodyItem     :       KEYS OBRACE Keys CBRACE SEMI { $$ = NULL; }\n                |       VarDecl\n                        { FreeStmt((ParseCommon *) $1); $$ = NULL; }\n                ;\n\nKeys            :       Keys COMMA Key          { $$ = NULL; }\n                |       Key                     { $$ = NULL; }\n                ;\n\nKey             :       KEYNAME\n                        { $$ = NULL; }\n                |       OBRACE ExprList CBRACE\n                        { FreeStmt((ParseCommon *) $2); $$ = NULL; }\n                ;\n\nOverlayDecl     :       OVERLAY String OBRACE OverlayKeyList CBRACE SEMI\n                        { $$ = NULL; }\n                ;\n\nOverlayKeyList  :       OverlayKeyList COMMA OverlayKey { $$ = NULL; }\n                |       OverlayKey                      { $$ = NULL; }\n                ;\n\nOverlayKey      :       KEYNAME EQUALS KEYNAME          { $$ = NULL; }\n                ;\n\nOutlineList     :       OutlineList COMMA OutlineInList\n                        { $$ = NULL;}\n                |       OutlineInList\n                        { $$ = NULL; }\n                ;\n\nOutlineInList   :       OBRACE CoordList CBRACE\n                        { (void) $2; $$ = NULL; }\n                |       Ident EQUALS OBRACE CoordList CBRACE\n                        { (void) $4; $$ = NULL; }\n                |       Ident EQUALS Expr\n                        { FreeStmt((ParseCommon *) $3); $$ = NULL; }\n                ;\n\nCoordList       :       CoordList COMMA Coord\n                        { (void) $1; (void) $3; $$ = NULL; }\n                |       Coord\n                        { (void) $1; $$ = NULL; }\n                ;\n\nCoord           :       OBRACKET SignedNumber COMMA SignedNumber CBRACKET\n                        { $$ = NULL; }\n                ;\n\nDoodadDecl      :       DoodadType String OBRACE VarDeclList CBRACE SEMI\n                        { FreeStmt((ParseCommon *) $4); $$ = NULL; }\n                ;\n\nDoodadType      :       TEXT    { $$ = 0; }\n                |       OUTLINE { $$ = 0; }\n                |       SOLID   { $$ = 0; }\n                |       LOGO    { $$ = 0; }\n                ;\n\nFieldSpec       :       Ident   { $$ = $1; }\n                |       Element { $$ = $1; }\n                ;\n\nElement         :       ACTION_TOK\n                        { $$ = xkb_atom_intern_literal(param->ctx, \"action\"); }\n                |       INTERPRET\n                        { $$ = xkb_atom_intern_literal(param->ctx, \"interpret\"); }\n                |       TYPE\n                        { $$ = xkb_atom_intern_literal(param->ctx, \"type\"); }\n                |       KEY\n                        { $$ = xkb_atom_intern_literal(param->ctx, \"key\"); }\n                |       GROUP\n                        { $$ = xkb_atom_intern_literal(param->ctx, \"group\"); }\n                |       MODIFIER_MAP\n                        {$$ = xkb_atom_intern_literal(param->ctx, \"modifier_map\");}\n                |       INDICATOR\n                        { $$ = xkb_atom_intern_literal(param->ctx, \"indicator\"); }\n                |       SHAPE\n                        { $$ = xkb_atom_intern_literal(param->ctx, \"shape\"); }\n                |       ROW\n                        { $$ = xkb_atom_intern_literal(param->ctx, \"row\"); }\n                |       SECTION\n                        { $$ = xkb_atom_intern_literal(param->ctx, \"section\"); }\n                |       TEXT\n                        { $$ = xkb_atom_intern_literal(param->ctx, \"text\"); }\n                ;\n\nOptMergeMode    :       MergeMode       { $$ = $1; }\n                |                       { $$ = MERGE_DEFAULT; }\n                ;\n\nMergeMode       :       INCLUDE         { $$ = MERGE_DEFAULT; }\n                |       AUGMENT         { $$ = MERGE_AUGMENT; }\n                |       OVERRIDE        { $$ = MERGE_OVERRIDE; }\n                |       REPLACE         { $$ = MERGE_REPLACE; }\n                |       ALTERNATE\n                {\n                    /*\n                     * This used to be MERGE_ALT_FORM. This functionality was\n                     * unused and has been removed.\n                     */\n                    $$ = MERGE_DEFAULT;\n                }\n                ;\n\nOptExprList     :       ExprList        { $$ = $1; }\n                |                       { $$ = NULL; }\n                ;\n\nExprList        :       ExprList COMMA Expr\n                        { $$ = (ExprDef *) AppendStmt((ParseCommon *) $1,\n                                                      (ParseCommon *) $3); }\n                |       Expr\n                        { $$ = $1; }\n                ;\n\nExpr            :       Expr DIVIDE Expr\n                        { $$ = ExprCreateBinary(EXPR_DIVIDE, $1, $3); }\n                |       Expr PLUS Expr\n                        { $$ = ExprCreateBinary(EXPR_ADD, $1, $3); }\n                |       Expr MINUS Expr\n                        { $$ = ExprCreateBinary(EXPR_SUBTRACT, $1, $3); }\n                |       Expr TIMES Expr\n                        { $$ = ExprCreateBinary(EXPR_MULTIPLY, $1, $3); }\n                |       Lhs EQUALS Expr\n                        { $$ = ExprCreateBinary(EXPR_ASSIGN, $1, $3); }\n                |       Term\n                        { $$ = $1; }\n                ;\n\nTerm            :       MINUS Term\n                        { $$ = ExprCreateUnary(EXPR_NEGATE, $2->expr.value_type, $2); }\n                |       PLUS Term\n                        { $$ = ExprCreateUnary(EXPR_UNARY_PLUS, $2->expr.value_type, $2); }\n                |       EXCLAM Term\n                        { $$ = ExprCreateUnary(EXPR_NOT, EXPR_TYPE_BOOLEAN, $2); }\n                |       INVERT Term\n                        { $$ = ExprCreateUnary(EXPR_INVERT, $2->expr.value_type, $2); }\n                |       Lhs\n                        { $$ = $1;  }\n                |       FieldSpec OPAREN OptExprList CPAREN %prec OPAREN\n                        { $$ = ExprCreateAction($1, $3); }\n                |       Terminal\n                        { $$ = $1;  }\n                |       OPAREN Expr CPAREN\n                        { $$ = $2;  }\n                ;\n\nActionList      :       ActionList COMMA Action\n                        { $$ = (ExprDef *) AppendStmt((ParseCommon *) $1,\n                                                      (ParseCommon *) $3); }\n                |       Action\n                        { $$ = $1; }\n                ;\n\nAction          :       FieldSpec OPAREN OptExprList CPAREN\n                        { $$ = ExprCreateAction($1, $3); }\n                ;\n\nLhs             :       FieldSpec\n                        { $$ = ExprCreateIdent($1); }\n                |       FieldSpec DOT FieldSpec\n                        { $$ = ExprCreateFieldRef($1, $3); }\n                |       FieldSpec OBRACKET Expr CBRACKET\n                        { $$ = ExprCreateArrayRef(XKB_ATOM_NONE, $1, $3); }\n                |       FieldSpec DOT FieldSpec OBRACKET Expr CBRACKET\n                        { $$ = ExprCreateArrayRef($1, $3, $5); }\n                ;\n\nTerminal        :       String\n                        { $$ = ExprCreateString($1); }\n                |       Integer\n                        { $$ = ExprCreateInteger($1); }\n                |       Float\n                        { $$ = ExprCreateFloat(/* Discard $1 */); }\n                |       KEYNAME\n                        { $$ = ExprCreateKeyName($1); }\n                ;\n\nOptKeySymList   :       KeySymList      { $$ = $1; }\n                |                       { $$ = NULL; }\n                ;\n\nKeySymList      :       KeySymList COMMA KeySym\n                        { $$ = ExprAppendKeysymList($1, $3); }\n                |       KeySymList COMMA KeySyms\n                        { $$ = ExprAppendMultiKeysymList($1, $3); }\n                |       KeySym\n                        { $$ = ExprCreateKeysymList($1); }\n                |       KeySyms\n                        { $$ = ExprCreateMultiKeysymList($1); }\n                ;\n\nKeySyms         :       OBRACE KeySymList CBRACE\n                        { $$ = $2; }\n                ;\n\nKeySym          :       IDENT\n                        {\n                            if (!resolve_keysym($1, &$$))\n                                parser_warn(param, \"unrecognized keysym \\\"%s\\\"\", $1);\n                            free($1);\n                        }\n                |       SECTION { $$ = XKB_KEY_section; }\n                |       Integer\n                        {\n                            if ($1 < 0) {\n                                parser_warn(param, \"unrecognized keysym \\\"%d\\\"\", $1);\n                                $$ = XKB_KEY_NoSymbol;\n                            }\n                            else if ($1 < 10) {      /* XKB_KEY_0 .. XKB_KEY_9 */\n                                $$ = XKB_KEY_0 + (xkb_keysym_t) $1;\n                            }\n                            else {\n                                char buf[17];\n                                snprintf(buf, sizeof(buf), \"0x%x\", $1);\n                                if (!resolve_keysym(buf, &$$)) {\n                                    parser_warn(param, \"unrecognized keysym \\\"%s\\\"\", buf);\n                                    $$ = XKB_KEY_NoSymbol;\n                                }\n                            }\n                        }\n                ;\n\nSignedNumber    :       MINUS Number    { $$ = -$2; }\n                |       Number          { $$ = $1; }\n                ;\n\nNumber          :       FLOAT   { $$ = $1; }\n                |       INTEGER { $$ = $1; }\n                ;\n\nFloat           :       FLOAT   { $$ = 0; }\n                ;\n\nInteger         :       INTEGER { $$ = $1; }\n                ;\n\nKeyCode         :       INTEGER { $$ = $1; }\n                ;\n\nIdent           :       IDENT   { $$ = xkb_atom_steal(param->ctx, $1); }\n                |       DEFAULT { $$ = xkb_atom_intern_literal(param->ctx, \"default\"); }\n                ;\n\nString          :       STRING  { $$ = xkb_atom_steal(param->ctx, $1); }\n                ;\n\nOptMapName      :       MapName { $$ = $1; }\n                |               { $$ = NULL; }\n                ;\n\nMapName         :       STRING  { $$ = $1; }\n                ;\n\n%%\n\nXkbFile *\nparse(struct xkb_context *ctx, struct scanner *scanner, const char *map)\n{\n    int ret;\n    XkbFile *first = NULL;\n    struct parser_param param = {\n        .scanner = scanner,\n        .ctx = ctx,\n        .rtrn = NULL,\n        .more_maps = false,\n    };\n\n    /*\n     * If we got a specific map, we look for it exclusively and return\n     * immediately upon finding it. Otherwise, we need to get the\n     * default map. If we find a map marked as default, we return it\n     * immediately. If there are no maps marked as default, we return\n     * the first map in the file.\n     */\n\n    while ((ret = yyparse(&param)) == 0 && param.more_maps) {\n        if (map) {\n            if (streq_not_null(map, param.rtrn->name))\n                return param.rtrn;\n            else\n                FreeXkbFile(param.rtrn);\n        }\n        else {\n            if (param.rtrn->flags & MAP_IS_DEFAULT) {\n                FreeXkbFile(first);\n                return param.rtrn;\n            }\n            else if (!first) {\n                first = param.rtrn;\n            }\n            else {\n                FreeXkbFile(param.rtrn);\n            }\n        }\n        param.rtrn = NULL;\n    }\n\n    if (ret != 0) {\n        FreeXkbFile(first);\n        return NULL;\n    }\n\n    if (first)\n        log_vrb(ctx, 5,\n                \"No map in include statement, but \\\"%s\\\" contains several; \"\n                \"Using first defined map, \\\"%s\\\"\\n\",\n                scanner->file_name, first->name);\n\n    return first;\n}\n"], "filenames": ["src/xkbcomp/parser.y"], "buggy_code_start_loc": [242], "buggy_code_end_loc": [774], "fixing_code_start_loc": [242], "fixing_code_end_loc": [776], "type": "CWE-476", "message": "Unchecked NULL pointer usage in resolve_keysym in xkbcomp/parser.y in xkbcommon before 0.8.2 could be used by local attackers to crash (NULL pointer dereference) the xkbcommon parser by supplying a crafted keymap file, because a map access attempt can occur for a map that was never created.", "other": {"cve": {"id": "CVE-2018-15864", "sourceIdentifier": "cve@mitre.org", "published": "2018-08-25T21:29:02.593", "lastModified": "2019-08-06T17:15:26.087", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Unchecked NULL pointer usage in resolve_keysym in xkbcomp/parser.y in xkbcommon before 0.8.2 could be used by local attackers to crash (NULL pointer dereference) the xkbcommon parser by supplying a crafted keymap file, because a map access attempt can occur for a map that was never created."}, {"lang": "es", "value": "El uso de un puntero NULL no verificado en resolve_keysym en xkbcomp/parser.y en xkbcommon, en versiones anteriores a la 0.8.2, podr\u00eda ser aprovechado por atacantes locales para provocar el cierre inesperado (desreferencia de puntero NULL) del analizador xkbcommon proporcionando un archivo keymap manipulado, debido a que puede ocurrir un intento de acceso al mapa para un mapa que nunca ha sido creado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:xkbcommon:libxkbcommon:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.8.1", "matchCriteriaId": "4B6764BA-E4C4-4657-B0B4-98C694C96632"}, {"vulnerable": true, "criteria": "cpe:2.3:a:xkbcommon:xkbcommon:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.8.1", "matchCriteriaId": "BEDDC322-0FA8-4907-A4E1-000BCCBECEFD"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}]}]}], "references": [{"url": "https://access.redhat.com/errata/RHSA-2019:2079", "source": "cve@mitre.org"}, {"url": "https://github.com/xkbcommon/libxkbcommon/commit/a8ea7a1d3daa7bdcb877615ae0a252c189153bd2", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.freedesktop.org/archives/wayland-devel/2018-August/039243.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201810-05", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3786-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3786-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/xkbcommon/libxkbcommon/commit/a8ea7a1d3daa7bdcb877615ae0a252c189153bd2"}}