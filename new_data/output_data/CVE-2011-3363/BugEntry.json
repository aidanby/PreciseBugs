{"buggy_code": ["/*\n *   fs/cifs/connect.c\n *\n *   Copyright (C) International Business Machines  Corp., 2002,2009\n *   Author(s): Steve French (sfrench@us.ibm.com)\n *\n *   This library is free software; you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published\n *   by the Free Software Foundation; either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This library is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See\n *   the GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this library; if not, write to the Free Software\n *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\n */\n#include <linux/fs.h>\n#include <linux/net.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/ctype.h>\n#include <linux/utsname.h>\n#include <linux/mempool.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/pagevec.h>\n#include <linux/freezer.h>\n#include <linux/namei.h>\n#include <asm/uaccess.h>\n#include <asm/processor.h>\n#include <linux/inet.h>\n#include <net/ipv6.h>\n#include \"cifspdu.h\"\n#include \"cifsglob.h\"\n#include \"cifsproto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_fs_sb.h\"\n#include \"ntlmssp.h\"\n#include \"nterr.h\"\n#include \"rfc1002pdu.h\"\n#include \"fscache.h\"\n\n#define CIFS_PORT 445\n#define RFC1001_PORT 139\n\n/* SMB echo \"timeout\" -- FIXME: tunable? */\n#define SMB_ECHO_INTERVAL (60 * HZ)\n\nextern mempool_t *cifs_req_poolp;\n\nstruct smb_vol {\n\tchar *username;\n\tchar *password;\n\tchar *domainname;\n\tchar *UNC;\n\tchar *UNCip;\n\tchar *iocharset;  /* local code page for mapping to and from Unicode */\n\tchar source_rfc1001_name[RFC1001_NAME_LEN_WITH_NULL]; /* clnt nb name */\n\tchar target_rfc1001_name[RFC1001_NAME_LEN_WITH_NULL]; /* srvr nb name */\n\tuid_t cred_uid;\n\tuid_t linux_uid;\n\tgid_t linux_gid;\n\tmode_t file_mode;\n\tmode_t dir_mode;\n\tunsigned secFlg;\n\tbool retry:1;\n\tbool intr:1;\n\tbool setuids:1;\n\tbool override_uid:1;\n\tbool override_gid:1;\n\tbool dynperm:1;\n\tbool noperm:1;\n\tbool no_psx_acl:1; /* set if posix acl support should be disabled */\n\tbool cifs_acl:1;\n\tbool no_xattr:1;   /* set if xattr (EA) support should be disabled*/\n\tbool server_ino:1; /* use inode numbers from server ie UniqueId */\n\tbool direct_io:1;\n\tbool strict_io:1; /* strict cache behavior */\n\tbool remap:1;      /* set to remap seven reserved chars in filenames */\n\tbool posix_paths:1; /* unset to not ask for posix pathnames. */\n\tbool no_linux_ext:1;\n\tbool sfu_emul:1;\n\tbool nullauth:1;   /* attempt to authenticate with null user */\n\tbool nocase:1;     /* request case insensitive filenames */\n\tbool nobrl:1;      /* disable sending byte range locks to srv */\n\tbool mand_lock:1;  /* send mandatory not posix byte range lock reqs */\n\tbool seal:1;       /* request transport encryption on share */\n\tbool nodfs:1;      /* Do not request DFS, even if available */\n\tbool local_lease:1; /* check leases only on local system, not remote */\n\tbool noblocksnd:1;\n\tbool noautotune:1;\n\tbool nostrictsync:1; /* do not force expensive SMBflush on every sync */\n\tbool fsc:1;\t/* enable fscache */\n\tbool mfsymlinks:1; /* use Minshall+French Symlinks */\n\tbool multiuser:1;\n\tunsigned int rsize;\n\tunsigned int wsize;\n\tbool sockopt_tcp_nodelay:1;\n\tunsigned short int port;\n\tunsigned long actimeo; /* attribute cache timeout (jiffies) */\n\tchar *prepath;\n\tstruct sockaddr_storage srcaddr; /* allow binding to a local IP */\n\tstruct nls_table *local_nls;\n};\n\n/* FIXME: should these be tunable? */\n#define TLINK_ERROR_EXPIRE\t(1 * HZ)\n#define TLINK_IDLE_EXPIRE\t(600 * HZ)\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\nstatic void tlink_rb_insert(struct rb_root *root, struct tcon_link *new_tlink);\nstatic void cifs_prune_tlinks(struct work_struct *work);\n\n/*\n * cifs tcp session reconnection\n *\n * mark tcp session as reconnecting so temporarily locked\n * mark all smb sessions as reconnecting for tcp session\n * reconnect tcp session\n * wake up waiters on reconnection? - (not needed currently)\n */\nstatic int\ncifs_reconnect(struct TCP_Server_Info *server)\n{\n\tint rc = 0;\n\tstruct list_head *tmp, *tmp2;\n\tstruct cifsSesInfo *ses;\n\tstruct cifsTconInfo *tcon;\n\tstruct mid_q_entry *mid_entry;\n\n\tspin_lock(&GlobalMid_Lock);\n\tif (server->tcpStatus == CifsExiting) {\n\t\t/* the demux thread will exit normally\n\t\tnext time through the loop */\n\t\tspin_unlock(&GlobalMid_Lock);\n\t\treturn rc;\n\t} else\n\t\tserver->tcpStatus = CifsNeedReconnect;\n\tspin_unlock(&GlobalMid_Lock);\n\tserver->maxBuf = 0;\n\n\tcFYI(1, \"Reconnecting tcp session\");\n\n\t/* before reconnecting the tcp session, mark the smb session (uid)\n\t\tand the tid bad so they are not used until reconnected */\n\tcFYI(1, \"%s: marking sessions and tcons for reconnect\", __func__);\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each(tmp, &server->smb_ses_list) {\n\t\tses = list_entry(tmp, struct cifsSesInfo, smb_ses_list);\n\t\tses->need_reconnect = true;\n\t\tses->ipc_tid = 0;\n\t\tlist_for_each(tmp2, &ses->tcon_list) {\n\t\t\ttcon = list_entry(tmp2, struct cifsTconInfo, tcon_list);\n\t\t\ttcon->need_reconnect = true;\n\t\t}\n\t}\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\t/* do not want to be sending data on a socket we are freeing */\n\tcFYI(1, \"%s: tearing down socket\", __func__);\n\tmutex_lock(&server->srv_mutex);\n\tif (server->ssocket) {\n\t\tcFYI(1, \"State: 0x%x Flags: 0x%lx\", server->ssocket->state,\n\t\t\tserver->ssocket->flags);\n\t\tkernel_sock_shutdown(server->ssocket, SHUT_WR);\n\t\tcFYI(1, \"Post shutdown state: 0x%x Flags: 0x%lx\",\n\t\t\tserver->ssocket->state,\n\t\t\tserver->ssocket->flags);\n\t\tsock_release(server->ssocket);\n\t\tserver->ssocket = NULL;\n\t}\n\tserver->sequence_number = 0;\n\tserver->session_estab = false;\n\tkfree(server->session_key.response);\n\tserver->session_key.response = NULL;\n\tserver->session_key.len = 0;\n\tserver->lstrp = jiffies;\n\tmutex_unlock(&server->srv_mutex);\n\n\t/* mark submitted MIDs for retry and issue callback */\n\tcFYI(1, \"%s: issuing mid callbacks\", __func__);\n\tspin_lock(&GlobalMid_Lock);\n\tlist_for_each_safe(tmp, tmp2, &server->pending_mid_q) {\n\t\tmid_entry = list_entry(tmp, struct mid_q_entry, qhead);\n\t\tif (mid_entry->midState == MID_REQUEST_SUBMITTED)\n\t\t\tmid_entry->midState = MID_RETRY_NEEDED;\n\t\tlist_del_init(&mid_entry->qhead);\n\t\tmid_entry->callback(mid_entry);\n\t}\n\tspin_unlock(&GlobalMid_Lock);\n\n\twhile ((server->tcpStatus != CifsExiting) &&\n\t       (server->tcpStatus != CifsGood)) {\n\t\ttry_to_freeze();\n\n\t\t/* we should try only the port we connected to before */\n\t\trc = generic_ip_connect(server);\n\t\tif (rc) {\n\t\t\tcFYI(1, \"reconnect error %d\", rc);\n\t\t\tmsleep(3000);\n\t\t} else {\n\t\t\tatomic_inc(&tcpSesReconnectCount);\n\t\t\tspin_lock(&GlobalMid_Lock);\n\t\t\tif (server->tcpStatus != CifsExiting)\n\t\t\t\tserver->tcpStatus = CifsGood;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t}\n\t}\n\n\treturn rc;\n}\n\n/*\n\treturn codes:\n\t\t0 \tnot a transact2, or all data present\n\t\t>0 \ttransact2 with that much data missing\n\t\t-EINVAL = invalid transact2\n\n */\nstatic int check2ndT2(struct smb_hdr *pSMB, unsigned int maxBufSize)\n{\n\tstruct smb_t2_rsp *pSMBt;\n\tint remaining;\n\t__u16 total_data_size, data_in_this_rsp;\n\n\tif (pSMB->Command != SMB_COM_TRANSACTION2)\n\t\treturn 0;\n\n\t/* check for plausible wct, bcc and t2 data and parm sizes */\n\t/* check for parm and data offset going beyond end of smb */\n\tif (pSMB->WordCount != 10) { /* coalesce_t2 depends on this */\n\t\tcFYI(1, \"invalid transact2 word count\");\n\t\treturn -EINVAL;\n\t}\n\n\tpSMBt = (struct smb_t2_rsp *)pSMB;\n\n\ttotal_data_size = get_unaligned_le16(&pSMBt->t2_rsp.TotalDataCount);\n\tdata_in_this_rsp = get_unaligned_le16(&pSMBt->t2_rsp.DataCount);\n\n\tremaining = total_data_size - data_in_this_rsp;\n\n\tif (remaining == 0)\n\t\treturn 0;\n\telse if (remaining < 0) {\n\t\tcFYI(1, \"total data %d smaller than data in frame %d\",\n\t\t\ttotal_data_size, data_in_this_rsp);\n\t\treturn -EINVAL;\n\t} else {\n\t\tcFYI(1, \"missing %d bytes from transact2, check next response\",\n\t\t\tremaining);\n\t\tif (total_data_size > maxBufSize) {\n\t\t\tcERROR(1, \"TotalDataSize %d is over maximum buffer %d\",\n\t\t\t\ttotal_data_size, maxBufSize);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn remaining;\n\t}\n}\n\nstatic int coalesce_t2(struct smb_hdr *psecond, struct smb_hdr *pTargetSMB)\n{\n\tstruct smb_t2_rsp *pSMB2 = (struct smb_t2_rsp *)psecond;\n\tstruct smb_t2_rsp *pSMBt  = (struct smb_t2_rsp *)pTargetSMB;\n\tchar *data_area_of_target;\n\tchar *data_area_of_buf2;\n\tint remaining;\n\t__u16 byte_count, total_data_size, total_in_buf, total_in_buf2;\n\n\ttotal_data_size = get_unaligned_le16(&pSMBt->t2_rsp.TotalDataCount);\n\n\tif (total_data_size !=\n\t    get_unaligned_le16(&pSMB2->t2_rsp.TotalDataCount))\n\t\tcFYI(1, \"total data size of primary and secondary t2 differ\");\n\n\ttotal_in_buf = get_unaligned_le16(&pSMBt->t2_rsp.DataCount);\n\n\tremaining = total_data_size - total_in_buf;\n\n\tif (remaining < 0)\n\t\treturn -EINVAL;\n\n\tif (remaining == 0) /* nothing to do, ignore */\n\t\treturn 0;\n\n\ttotal_in_buf2 = get_unaligned_le16(&pSMB2->t2_rsp.DataCount);\n\tif (remaining < total_in_buf2) {\n\t\tcFYI(1, \"transact2 2nd response contains too much data\");\n\t}\n\n\t/* find end of first SMB data area */\n\tdata_area_of_target = (char *)&pSMBt->hdr.Protocol +\n\t\t\t\tget_unaligned_le16(&pSMBt->t2_rsp.DataOffset);\n\t/* validate target area */\n\n\tdata_area_of_buf2 = (char *)&pSMB2->hdr.Protocol +\n\t\t\t\tget_unaligned_le16(&pSMB2->t2_rsp.DataOffset);\n\n\tdata_area_of_target += total_in_buf;\n\n\t/* copy second buffer into end of first buffer */\n\tmemcpy(data_area_of_target, data_area_of_buf2, total_in_buf2);\n\ttotal_in_buf += total_in_buf2;\n\tput_unaligned_le16(total_in_buf, &pSMBt->t2_rsp.DataCount);\n\tbyte_count = get_bcc_le(pTargetSMB);\n\tbyte_count += total_in_buf2;\n\tput_bcc_le(byte_count, pTargetSMB);\n\n\tbyte_count = pTargetSMB->smb_buf_length;\n\tbyte_count += total_in_buf2;\n\n\t/* BB also add check that we are not beyond maximum buffer size */\n\n\tpTargetSMB->smb_buf_length = byte_count;\n\n\tif (remaining == total_in_buf2) {\n\t\tcFYI(1, \"found the last secondary response\");\n\t\treturn 0; /* we are done */\n\t} else /* more responses to go */\n\t\treturn 1;\n}\n\nstatic void\ncifs_echo_request(struct work_struct *work)\n{\n\tint rc;\n\tstruct TCP_Server_Info *server = container_of(work,\n\t\t\t\t\tstruct TCP_Server_Info, echo.work);\n\n\t/*\n\t * We cannot send an echo until the NEGOTIATE_PROTOCOL request is\n\t * done, which is indicated by maxBuf != 0. Also, no need to ping if\n\t * we got a response recently\n\t */\n\tif (server->maxBuf == 0 ||\n\t    time_before(jiffies, server->lstrp + SMB_ECHO_INTERVAL - HZ))\n\t\tgoto requeue_echo;\n\n\trc = CIFSSMBEcho(server);\n\tif (rc)\n\t\tcFYI(1, \"Unable to send echo request to server: %s\",\n\t\t\tserver->hostname);\n\nrequeue_echo:\n\tqueue_delayed_work(system_nrt_wq, &server->echo, SMB_ECHO_INTERVAL);\n}\n\nstatic int\ncifs_demultiplex_thread(struct TCP_Server_Info *server)\n{\n\tint length;\n\tunsigned int pdu_length, total_read;\n\tstruct smb_hdr *smb_buffer = NULL;\n\tstruct smb_hdr *bigbuf = NULL;\n\tstruct smb_hdr *smallbuf = NULL;\n\tstruct msghdr smb_msg;\n\tstruct kvec iov;\n\tstruct socket *csocket = server->ssocket;\n\tstruct list_head *tmp, *tmp2;\n\tstruct task_struct *task_to_wake = NULL;\n\tstruct mid_q_entry *mid_entry;\n\tchar temp;\n\tbool isLargeBuf = false;\n\tbool isMultiRsp;\n\tint reconnect;\n\n\tcurrent->flags |= PF_MEMALLOC;\n\tcFYI(1, \"Demultiplex PID: %d\", task_pid_nr(current));\n\n\tlength = atomic_inc_return(&tcpSesAllocCount);\n\tif (length > 1)\n\t\tmempool_resize(cifs_req_poolp, length + cifs_min_rcv,\n\t\t\t\tGFP_KERNEL);\n\n\tset_freezable();\n\twhile (server->tcpStatus != CifsExiting) {\n\t\tif (try_to_freeze())\n\t\t\tcontinue;\n\t\tif (bigbuf == NULL) {\n\t\t\tbigbuf = cifs_buf_get();\n\t\t\tif (!bigbuf) {\n\t\t\t\tcERROR(1, \"No memory for large SMB response\");\n\t\t\t\tmsleep(3000);\n\t\t\t\t/* retry will check if exiting */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else if (isLargeBuf) {\n\t\t\t/* we are reusing a dirty large buf, clear its start */\n\t\t\tmemset(bigbuf, 0, sizeof(struct smb_hdr));\n\t\t}\n\n\t\tif (smallbuf == NULL) {\n\t\t\tsmallbuf = cifs_small_buf_get();\n\t\t\tif (!smallbuf) {\n\t\t\t\tcERROR(1, \"No memory for SMB response\");\n\t\t\t\tmsleep(1000);\n\t\t\t\t/* retry will check if exiting */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* beginning of smb buffer is cleared in our buf_get */\n\t\t} else /* if existing small buf clear beginning */\n\t\t\tmemset(smallbuf, 0, sizeof(struct smb_hdr));\n\n\t\tisLargeBuf = false;\n\t\tisMultiRsp = false;\n\t\tsmb_buffer = smallbuf;\n\t\tiov.iov_base = smb_buffer;\n\t\tiov.iov_len = 4;\n\t\tsmb_msg.msg_control = NULL;\n\t\tsmb_msg.msg_controllen = 0;\n\t\tpdu_length = 4; /* enough to get RFC1001 header */\n\nincomplete_rcv:\n\t\tif (echo_retries > 0 &&\n\t\t    time_after(jiffies, server->lstrp +\n\t\t\t\t\t(echo_retries * SMB_ECHO_INTERVAL))) {\n\t\t\tcERROR(1, \"Server %s has not responded in %d seconds. \"\n\t\t\t\t  \"Reconnecting...\", server->hostname,\n\t\t\t\t  (echo_retries * SMB_ECHO_INTERVAL / HZ));\n\t\t\tcifs_reconnect(server);\n\t\t\tcsocket = server->ssocket;\n\t\t\twake_up(&server->response_q);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlength =\n\t\t    kernel_recvmsg(csocket, &smb_msg,\n\t\t\t\t&iov, 1, pdu_length, 0 /* BB other flags? */);\n\n\t\tif (server->tcpStatus == CifsExiting) {\n\t\t\tbreak;\n\t\t} else if (server->tcpStatus == CifsNeedReconnect) {\n\t\t\tcFYI(1, \"Reconnect after server stopped responding\");\n\t\t\tcifs_reconnect(server);\n\t\t\tcFYI(1, \"call to reconnect done\");\n\t\t\tcsocket = server->ssocket;\n\t\t\tcontinue;\n\t\t} else if (length == -ERESTARTSYS ||\n\t\t\t   length == -EAGAIN ||\n\t\t\t   length == -EINTR) {\n\t\t\tmsleep(1); /* minimum sleep to prevent looping\n\t\t\t\tallowing socket to clear and app threads to set\n\t\t\t\ttcpStatus CifsNeedReconnect if server hung */\n\t\t\tif (pdu_length < 4) {\n\t\t\t\tiov.iov_base = (4 - pdu_length) +\n\t\t\t\t\t\t\t(char *)smb_buffer;\n\t\t\t\tiov.iov_len = pdu_length;\n\t\t\t\tsmb_msg.msg_control = NULL;\n\t\t\t\tsmb_msg.msg_controllen = 0;\n\t\t\t\tgoto incomplete_rcv;\n\t\t\t} else\n\t\t\t\tcontinue;\n\t\t} else if (length <= 0) {\n\t\t\tcFYI(1, \"Reconnect after unexpected peek error %d\",\n\t\t\t\tlength);\n\t\t\tcifs_reconnect(server);\n\t\t\tcsocket = server->ssocket;\n\t\t\twake_up(&server->response_q);\n\t\t\tcontinue;\n\t\t} else if (length < pdu_length) {\n\t\t\tcFYI(1, \"requested %d bytes but only got %d bytes\",\n\t\t\t\t  pdu_length, length);\n\t\t\tpdu_length -= length;\n\t\t\tmsleep(1);\n\t\t\tgoto incomplete_rcv;\n\t\t}\n\n\t\t/* The right amount was read from socket - 4 bytes */\n\t\t/* so we can now interpret the length field */\n\n\t\t/* the first byte big endian of the length field,\n\t\tis actually not part of the length but the type\n\t\twith the most common, zero, as regular data */\n\t\ttemp = *((char *) smb_buffer);\n\n\t\t/* Note that FC 1001 length is big endian on the wire,\n\t\tbut we convert it here so it is always manipulated\n\t\tas host byte order */\n\t\tpdu_length = be32_to_cpu((__force __be32)smb_buffer->smb_buf_length);\n\t\tsmb_buffer->smb_buf_length = pdu_length;\n\n\t\tcFYI(1, \"rfc1002 length 0x%x\", pdu_length+4);\n\n\t\tif (temp == (char) RFC1002_SESSION_KEEP_ALIVE) {\n\t\t\tcontinue;\n\t\t} else if (temp == (char)RFC1002_POSITIVE_SESSION_RESPONSE) {\n\t\t\tcFYI(1, \"Good RFC 1002 session rsp\");\n\t\t\tcontinue;\n\t\t} else if (temp == (char)RFC1002_NEGATIVE_SESSION_RESPONSE) {\n\t\t\t/* we get this from Windows 98 instead of\n\t\t\t   an error on SMB negprot response */\n\t\t\tcFYI(1, \"Negative RFC1002 Session Response Error 0x%x)\",\n\t\t\t\tpdu_length);\n\t\t\t/* give server a second to clean up  */\n\t\t\tmsleep(1000);\n\t\t\t/* always try 445 first on reconnect since we get NACK\n\t\t\t * on some if we ever connected to port 139 (the NACK\n\t\t\t * is since we do not begin with RFC1001 session\n\t\t\t * initialize frame)\n\t\t\t */\n\t\t\tcifs_set_port((struct sockaddr *)\n\t\t\t\t\t&server->dstaddr, CIFS_PORT);\n\t\t\tcifs_reconnect(server);\n\t\t\tcsocket = server->ssocket;\n\t\t\twake_up(&server->response_q);\n\t\t\tcontinue;\n\t\t} else if (temp != (char) 0) {\n\t\t\tcERROR(1, \"Unknown RFC 1002 frame\");\n\t\t\tcifs_dump_mem(\" Received Data: \", (char *)smb_buffer,\n\t\t\t\t      length);\n\t\t\tcifs_reconnect(server);\n\t\t\tcsocket = server->ssocket;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* else we have an SMB response */\n\t\tif ((pdu_length > CIFSMaxBufSize + MAX_CIFS_HDR_SIZE - 4) ||\n\t\t\t    (pdu_length < sizeof(struct smb_hdr) - 1 - 4)) {\n\t\t\tcERROR(1, \"Invalid size SMB length %d pdu_length %d\",\n\t\t\t\t\tlength, pdu_length+4);\n\t\t\tcifs_reconnect(server);\n\t\t\tcsocket = server->ssocket;\n\t\t\twake_up(&server->response_q);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* else length ok */\n\t\treconnect = 0;\n\n\t\tif (pdu_length > MAX_CIFS_SMALL_BUFFER_SIZE - 4) {\n\t\t\tisLargeBuf = true;\n\t\t\tmemcpy(bigbuf, smallbuf, 4);\n\t\t\tsmb_buffer = bigbuf;\n\t\t}\n\t\tlength = 0;\n\t\tiov.iov_base = 4 + (char *)smb_buffer;\n\t\tiov.iov_len = pdu_length;\n\t\tfor (total_read = 0; total_read < pdu_length;\n\t\t     total_read += length) {\n\t\t\tlength = kernel_recvmsg(csocket, &smb_msg, &iov, 1,\n\t\t\t\t\t\tpdu_length - total_read, 0);\n\t\t\tif (server->tcpStatus == CifsExiting) {\n\t\t\t\t/* then will exit */\n\t\t\t\treconnect = 2;\n\t\t\t\tbreak;\n\t\t\t} else if (server->tcpStatus == CifsNeedReconnect) {\n\t\t\t\tcifs_reconnect(server);\n\t\t\t\tcsocket = server->ssocket;\n\t\t\t\t/* Reconnect wakes up rspns q */\n\t\t\t\t/* Now we will reread sock */\n\t\t\t\treconnect = 1;\n\t\t\t\tbreak;\n\t\t\t} else if (length == -ERESTARTSYS ||\n\t\t\t\t   length == -EAGAIN ||\n\t\t\t\t   length == -EINTR) {\n\t\t\t\tmsleep(1); /* minimum sleep to prevent looping,\n\t\t\t\t\t      allowing socket to clear and app\n\t\t\t\t\t      threads to set tcpStatus\n\t\t\t\t\t      CifsNeedReconnect if server hung*/\n\t\t\t\tlength = 0;\n\t\t\t\tcontinue;\n\t\t\t} else if (length <= 0) {\n\t\t\t\tcERROR(1, \"Received no data, expecting %d\",\n\t\t\t\t\t      pdu_length - total_read);\n\t\t\t\tcifs_reconnect(server);\n\t\t\t\tcsocket = server->ssocket;\n\t\t\t\treconnect = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (reconnect == 2)\n\t\t\tbreak;\n\t\telse if (reconnect == 1)\n\t\t\tcontinue;\n\n\t\ttotal_read += 4; /* account for rfc1002 hdr */\n\n\t\tdump_smb(smb_buffer, total_read);\n\n\t\t/*\n\t\t * We know that we received enough to get to the MID as we\n\t\t * checked the pdu_length earlier. Now check to see\n\t\t * if the rest of the header is OK. We borrow the length\n\t\t * var for the rest of the loop to avoid a new stack var.\n\t\t *\n\t\t * 48 bytes is enough to display the header and a little bit\n\t\t * into the payload for debugging purposes.\n\t\t */\n\t\tlength = checkSMB(smb_buffer, smb_buffer->Mid, total_read);\n\t\tif (length != 0)\n\t\t\tcifs_dump_mem(\"Bad SMB: \", smb_buffer,\n\t\t\t\t\tmin_t(unsigned int, total_read, 48));\n\n\t\tmid_entry = NULL;\n\t\tserver->lstrp = jiffies;\n\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tlist_for_each_safe(tmp, tmp2, &server->pending_mid_q) {\n\t\t\tmid_entry = list_entry(tmp, struct mid_q_entry, qhead);\n\n\t\t\tif ((mid_entry->mid == smb_buffer->Mid) &&\n\t\t\t    (mid_entry->midState == MID_REQUEST_SUBMITTED) &&\n\t\t\t    (mid_entry->command == smb_buffer->Command)) {\n\t\t\t\tif (length == 0 &&\n\t\t\t\t   check2ndT2(smb_buffer, server->maxBuf) > 0) {\n\t\t\t\t\t/* We have a multipart transact2 resp */\n\t\t\t\t\tisMultiRsp = true;\n\t\t\t\t\tif (mid_entry->resp_buf) {\n\t\t\t\t\t\t/* merge response - fix up 1st*/\n\t\t\t\t\t\tif (coalesce_t2(smb_buffer,\n\t\t\t\t\t\t\tmid_entry->resp_buf)) {\n\t\t\t\t\t\t\tmid_entry->multiRsp =\n\t\t\t\t\t\t\t\t true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t/* all parts received */\n\t\t\t\t\t\t\tmid_entry->multiEnd =\n\t\t\t\t\t\t\t\t true;\n\t\t\t\t\t\t\tgoto multi_t2_fnd;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!isLargeBuf) {\n\t\t\t\t\t\t\tcERROR(1, \"1st trans2 resp needs bigbuf\");\n\t\t\t\t\t/* BB maybe we can fix this up,  switch\n\t\t\t\t\t   to already allocated large buffer? */\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t/* Have first buffer */\n\t\t\t\t\t\t\tmid_entry->resp_buf =\n\t\t\t\t\t\t\t\t smb_buffer;\n\t\t\t\t\t\t\tmid_entry->largeBuf =\n\t\t\t\t\t\t\t\t true;\n\t\t\t\t\t\t\tbigbuf = NULL;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tmid_entry->resp_buf = smb_buffer;\n\t\t\t\tmid_entry->largeBuf = isLargeBuf;\nmulti_t2_fnd:\n\t\t\t\tif (length == 0)\n\t\t\t\t\tmid_entry->midState =\n\t\t\t\t\t\t\tMID_RESPONSE_RECEIVED;\n\t\t\t\telse\n\t\t\t\t\tmid_entry->midState =\n\t\t\t\t\t\t\tMID_RESPONSE_MALFORMED;\n#ifdef CONFIG_CIFS_STATS2\n\t\t\t\tmid_entry->when_received = jiffies;\n#endif\n\t\t\t\tlist_del_init(&mid_entry->qhead);\n\t\t\t\tmid_entry->callback(mid_entry);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmid_entry = NULL;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\n\t\tif (mid_entry != NULL) {\n\t\t\t/* Was previous buf put in mpx struct for multi-rsp? */\n\t\t\tif (!isMultiRsp) {\n\t\t\t\t/* smb buffer will be freed by user thread */\n\t\t\t\tif (isLargeBuf)\n\t\t\t\t\tbigbuf = NULL;\n\t\t\t\telse\n\t\t\t\t\tsmallbuf = NULL;\n\t\t\t}\n\t\t} else if (length != 0) {\n\t\t\t/* response sanity checks failed */\n\t\t\tcontinue;\n\t\t} else if (!is_valid_oplock_break(smb_buffer, server) &&\n\t\t\t   !isMultiRsp) {\n\t\t\tcERROR(1, \"No task to wake, unknown frame received! \"\n\t\t\t\t   \"NumMids %d\", atomic_read(&midCount));\n\t\t\tcifs_dump_mem(\"Received Data is: \", (char *)smb_buffer,\n\t\t\t\t      sizeof(struct smb_hdr));\n#ifdef CONFIG_CIFS_DEBUG2\n\t\t\tcifs_dump_detail(smb_buffer);\n\t\t\tcifs_dump_mids(server);\n#endif /* CIFS_DEBUG2 */\n\n\t\t}\n\t} /* end while !EXITING */\n\n\t/* take it off the list, if it's not already */\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_del_init(&server->tcp_ses_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tspin_lock(&GlobalMid_Lock);\n\tserver->tcpStatus = CifsExiting;\n\tspin_unlock(&GlobalMid_Lock);\n\twake_up_all(&server->response_q);\n\n\t/* check if we have blocked requests that need to free */\n\t/* Note that cifs_max_pending is normally 50, but\n\tcan be set at module install time to as little as two */\n\tspin_lock(&GlobalMid_Lock);\n\tif (atomic_read(&server->inFlight) >= cifs_max_pending)\n\t\tatomic_set(&server->inFlight, cifs_max_pending - 1);\n\t/* We do not want to set the max_pending too low or we\n\tcould end up with the counter going negative */\n\tspin_unlock(&GlobalMid_Lock);\n\t/* Although there should not be any requests blocked on\n\tthis queue it can not hurt to be paranoid and try to wake up requests\n\tthat may haven been blocked when more than 50 at time were on the wire\n\tto the same server - they now will see the session is in exit state\n\tand get out of SendReceive.  */\n\twake_up_all(&server->request_q);\n\t/* give those requests time to exit */\n\tmsleep(125);\n\n\tif (server->ssocket) {\n\t\tsock_release(csocket);\n\t\tserver->ssocket = NULL;\n\t}\n\t/* buffer usuallly freed in free_mid - need to free it here on exit */\n\tcifs_buf_release(bigbuf);\n\tif (smallbuf) /* no sense logging a debug message if NULL */\n\t\tcifs_small_buf_release(smallbuf);\n\n\tif (!list_empty(&server->pending_mid_q)) {\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tlist_for_each_safe(tmp, tmp2, &server->pending_mid_q) {\n\t\t\tmid_entry = list_entry(tmp, struct mid_q_entry, qhead);\n\t\t\tcFYI(1, \"Clearing Mid 0x%x - issuing callback\",\n\t\t\t\t\t mid_entry->mid);\n\t\t\tlist_del_init(&mid_entry->qhead);\n\t\t\tmid_entry->callback(mid_entry);\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t\t/* 1/8th of sec is more than enough time for them to exit */\n\t\tmsleep(125);\n\t}\n\n\tif (!list_empty(&server->pending_mid_q)) {\n\t\t/* mpx threads have not exited yet give them\n\t\tat least the smb send timeout time for long ops */\n\t\t/* due to delays on oplock break requests, we need\n\t\tto wait at least 45 seconds before giving up\n\t\ton a request getting a response and going ahead\n\t\tand killing cifsd */\n\t\tcFYI(1, \"Wait for exit from demultiplex thread\");\n\t\tmsleep(46000);\n\t\t/* if threads still have not exited they are probably never\n\t\tcoming home not much else we can do but free the memory */\n\t}\n\n\tkfree(server->hostname);\n\ttask_to_wake = xchg(&server->tsk, NULL);\n\tkfree(server);\n\n\tlength = atomic_dec_return(&tcpSesAllocCount);\n\tif (length  > 0)\n\t\tmempool_resize(cifs_req_poolp, length + cifs_min_rcv,\n\t\t\t\tGFP_KERNEL);\n\n\t/* if server->tsk was NULL then wait for a signal before exiting */\n\tif (!task_to_wake) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\twhile (!signal_pending(current)) {\n\t\t\tschedule();\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t}\n\t\tset_current_state(TASK_RUNNING);\n\t}\n\n\tmodule_put_and_exit(0);\n}\n\n/* extract the host portion of the UNC string */\nstatic char *\nextract_hostname(const char *unc)\n{\n\tconst char *src;\n\tchar *dst, *delim;\n\tunsigned int len;\n\n\t/* skip double chars at beginning of string */\n\t/* BB: check validity of these bytes? */\n\tsrc = unc + 2;\n\n\t/* delimiter between hostname and sharename is always '\\\\' now */\n\tdelim = strchr(src, '\\\\');\n\tif (!delim)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tlen = delim - src;\n\tdst = kmalloc((len + 1), GFP_KERNEL);\n\tif (dst == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmemcpy(dst, src, len);\n\tdst[len] = '\\0';\n\n\treturn dst;\n}\n\nstatic int\ncifs_parse_mount_options(char *options, const char *devname,\n\t\t\t struct smb_vol *vol)\n{\n\tchar *value;\n\tchar *data;\n\tunsigned int  temp_len, i, j;\n\tchar separator[2];\n\tshort int override_uid = -1;\n\tshort int override_gid = -1;\n\tbool uid_specified = false;\n\tbool gid_specified = false;\n\tchar *nodename = utsname()->nodename;\n\n\tseparator[0] = ',';\n\tseparator[1] = 0;\n\n\t/*\n\t * does not have to be perfect mapping since field is\n\t * informational, only used for servers that do not support\n\t * port 445 and it can be overridden at mount time\n\t */\n\tmemset(vol->source_rfc1001_name, 0x20, RFC1001_NAME_LEN);\n\tfor (i = 0; i < strnlen(nodename, RFC1001_NAME_LEN); i++)\n\t\tvol->source_rfc1001_name[i] = toupper(nodename[i]);\n\n\tvol->source_rfc1001_name[RFC1001_NAME_LEN] = 0;\n\t/* null target name indicates to use *SMBSERVR default called name\n\t   if we end up sending RFC1001 session initialize */\n\tvol->target_rfc1001_name[0] = 0;\n\tvol->cred_uid = current_uid();\n\tvol->linux_uid = current_uid();\n\tvol->linux_gid = current_gid();\n\n\t/* default to only allowing write access to owner of the mount */\n\tvol->dir_mode = vol->file_mode = S_IRUGO | S_IXUGO | S_IWUSR;\n\n\t/* vol->retry default is 0 (i.e. \"soft\" limited retry not hard retry) */\n\t/* default is always to request posix paths. */\n\tvol->posix_paths = 1;\n\t/* default to using server inode numbers where available */\n\tvol->server_ino = 1;\n\n\tvol->actimeo = CIFS_DEF_ACTIMEO;\n\n\tif (!options)\n\t\treturn 1;\n\n\tif (strncmp(options, \"sep=\", 4) == 0) {\n\t\tif (options[4] != 0) {\n\t\t\tseparator[0] = options[4];\n\t\t\toptions += 5;\n\t\t} else {\n\t\t\tcFYI(1, \"Null separator not allowed\");\n\t\t}\n\t}\n\n\twhile ((data = strsep(&options, separator)) != NULL) {\n\t\tif (!*data)\n\t\t\tcontinue;\n\t\tif ((value = strchr(data, '=')) != NULL)\n\t\t\t*value++ = '\\0';\n\n\t\t/* Have to parse this before we parse for \"user\" */\n\t\tif (strnicmp(data, \"user_xattr\", 10) == 0) {\n\t\t\tvol->no_xattr = 0;\n\t\t} else if (strnicmp(data, \"nouser_xattr\", 12) == 0) {\n\t\t\tvol->no_xattr = 1;\n\t\t} else if (strnicmp(data, \"user\", 4) == 0) {\n\t\t\tif (!value) {\n\t\t\t\tprintk(KERN_WARNING\n\t\t\t\t       \"CIFS: invalid or missing username\\n\");\n\t\t\t\treturn 1;\t/* needs_arg; */\n\t\t\t} else if (!*value) {\n\t\t\t\t/* null user, ie anonymous, authentication */\n\t\t\t\tvol->nullauth = 1;\n\t\t\t}\n\t\t\tif (strnlen(value, MAX_USERNAME_SIZE) <\n\t\t\t\t\t\tMAX_USERNAME_SIZE) {\n\t\t\t\tvol->username = value;\n\t\t\t} else {\n\t\t\t\tprintk(KERN_WARNING \"CIFS: username too long\\n\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t} else if (strnicmp(data, \"pass\", 4) == 0) {\n\t\t\tif (!value) {\n\t\t\t\tvol->password = NULL;\n\t\t\t\tcontinue;\n\t\t\t} else if (value[0] == 0) {\n\t\t\t\t/* check if string begins with double comma\n\t\t\t\t   since that would mean the password really\n\t\t\t\t   does start with a comma, and would not\n\t\t\t\t   indicate an empty string */\n\t\t\t\tif (value[1] != separator[0]) {\n\t\t\t\t\tvol->password = NULL;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttemp_len = strlen(value);\n\t\t\t/* removed password length check, NTLM passwords\n\t\t\t\tcan be arbitrarily long */\n\n\t\t\t/* if comma in password, the string will be\n\t\t\tprematurely null terminated.  Commas in password are\n\t\t\tspecified across the cifs mount interface by a double\n\t\t\tcomma ie ,, and a comma used as in other cases ie ','\n\t\t\tas a parameter delimiter/separator is single and due\n\t\t\tto the strsep above is temporarily zeroed. */\n\n\t\t\t/* NB: password legally can have multiple commas and\n\t\t\tthe only illegal character in a password is null */\n\n\t\t\tif ((value[temp_len] == 0) &&\n\t\t\t    (value[temp_len+1] == separator[0])) {\n\t\t\t\t/* reinsert comma */\n\t\t\t\tvalue[temp_len] = separator[0];\n\t\t\t\ttemp_len += 2;  /* move after second comma */\n\t\t\t\twhile (value[temp_len] != 0)  {\n\t\t\t\t\tif (value[temp_len] == separator[0]) {\n\t\t\t\t\t\tif (value[temp_len+1] ==\n\t\t\t\t\t\t     separator[0]) {\n\t\t\t\t\t\t/* skip second comma */\n\t\t\t\t\t\t\ttemp_len++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t/* single comma indicating start\n\t\t\t\t\t\t\t of next parm */\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ttemp_len++;\n\t\t\t\t}\n\t\t\t\tif (value[temp_len] == 0) {\n\t\t\t\t\toptions = NULL;\n\t\t\t\t} else {\n\t\t\t\t\tvalue[temp_len] = 0;\n\t\t\t\t\t/* point option to start of next parm */\n\t\t\t\t\toptions = value + temp_len + 1;\n\t\t\t\t}\n\t\t\t\t/* go from value to value + temp_len condensing\n\t\t\t\tdouble commas to singles. Note that this ends up\n\t\t\t\tallocating a few bytes too many, which is ok */\n\t\t\t\tvol->password = kzalloc(temp_len, GFP_KERNEL);\n\t\t\t\tif (vol->password == NULL) {\n\t\t\t\t\tprintk(KERN_WARNING \"CIFS: no memory \"\n\t\t\t\t\t\t\t    \"for password\\n\");\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tfor (i = 0, j = 0; i < temp_len; i++, j++) {\n\t\t\t\t\tvol->password[j] = value[i];\n\t\t\t\t\tif (value[i] == separator[0]\n\t\t\t\t\t\t&& value[i+1] == separator[0]) {\n\t\t\t\t\t\t/* skip second comma */\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvol->password[j] = 0;\n\t\t\t} else {\n\t\t\t\tvol->password = kzalloc(temp_len+1, GFP_KERNEL);\n\t\t\t\tif (vol->password == NULL) {\n\t\t\t\t\tprintk(KERN_WARNING \"CIFS: no memory \"\n\t\t\t\t\t\t\t    \"for password\\n\");\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tstrcpy(vol->password, value);\n\t\t\t}\n\t\t} else if (!strnicmp(data, \"ip\", 2) ||\n\t\t\t   !strnicmp(data, \"addr\", 4)) {\n\t\t\tif (!value || !*value) {\n\t\t\t\tvol->UNCip = NULL;\n\t\t\t} else if (strnlen(value, INET6_ADDRSTRLEN) <\n\t\t\t\t\t\t\tINET6_ADDRSTRLEN) {\n\t\t\t\tvol->UNCip = value;\n\t\t\t} else {\n\t\t\t\tprintk(KERN_WARNING \"CIFS: ip address \"\n\t\t\t\t\t\t    \"too long\\n\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t} else if (strnicmp(data, \"sec\", 3) == 0) {\n\t\t\tif (!value || !*value) {\n\t\t\t\tcERROR(1, \"no security value specified\");\n\t\t\t\tcontinue;\n\t\t\t} else if (strnicmp(value, \"krb5i\", 5) == 0) {\n\t\t\t\tvol->secFlg |= CIFSSEC_MAY_KRB5 |\n\t\t\t\t\tCIFSSEC_MUST_SIGN;\n\t\t\t} else if (strnicmp(value, \"krb5p\", 5) == 0) {\n\t\t\t\t/* vol->secFlg |= CIFSSEC_MUST_SEAL |\n\t\t\t\t\tCIFSSEC_MAY_KRB5; */\n\t\t\t\tcERROR(1, \"Krb5 cifs privacy not supported\");\n\t\t\t\treturn 1;\n\t\t\t} else if (strnicmp(value, \"krb5\", 4) == 0) {\n\t\t\t\tvol->secFlg |= CIFSSEC_MAY_KRB5;\n\t\t\t} else if (strnicmp(value, \"ntlmsspi\", 8) == 0) {\n\t\t\t\tvol->secFlg |= CIFSSEC_MAY_NTLMSSP |\n\t\t\t\t\tCIFSSEC_MUST_SIGN;\n\t\t\t} else if (strnicmp(value, \"ntlmssp\", 7) == 0) {\n\t\t\t\tvol->secFlg |= CIFSSEC_MAY_NTLMSSP;\n\t\t\t} else if (strnicmp(value, \"ntlmv2i\", 7) == 0) {\n\t\t\t\tvol->secFlg |= CIFSSEC_MAY_NTLMV2 |\n\t\t\t\t\tCIFSSEC_MUST_SIGN;\n\t\t\t} else if (strnicmp(value, \"ntlmv2\", 6) == 0) {\n\t\t\t\tvol->secFlg |= CIFSSEC_MAY_NTLMV2;\n\t\t\t} else if (strnicmp(value, \"ntlmi\", 5) == 0) {\n\t\t\t\tvol->secFlg |= CIFSSEC_MAY_NTLM |\n\t\t\t\t\tCIFSSEC_MUST_SIGN;\n\t\t\t} else if (strnicmp(value, \"ntlm\", 4) == 0) {\n\t\t\t\t/* ntlm is default so can be turned off too */\n\t\t\t\tvol->secFlg |= CIFSSEC_MAY_NTLM;\n\t\t\t} else if (strnicmp(value, \"nontlm\", 6) == 0) {\n\t\t\t\t/* BB is there a better way to do this? */\n\t\t\t\tvol->secFlg |= CIFSSEC_MAY_NTLMV2;\n#ifdef CONFIG_CIFS_WEAK_PW_HASH\n\t\t\t} else if (strnicmp(value, \"lanman\", 6) == 0) {\n\t\t\t\tvol->secFlg |= CIFSSEC_MAY_LANMAN;\n#endif\n\t\t\t} else if (strnicmp(value, \"none\", 4) == 0) {\n\t\t\t\tvol->nullauth = 1;\n\t\t\t} else {\n\t\t\t\tcERROR(1, \"bad security option: %s\", value);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t} else if ((strnicmp(data, \"unc\", 3) == 0)\n\t\t\t   || (strnicmp(data, \"target\", 6) == 0)\n\t\t\t   || (strnicmp(data, \"path\", 4) == 0)) {\n\t\t\tif (!value || !*value) {\n\t\t\t\tprintk(KERN_WARNING \"CIFS: invalid path to \"\n\t\t\t\t\t\t    \"network resource\\n\");\n\t\t\t\treturn 1;\t/* needs_arg; */\n\t\t\t}\n\t\t\tif ((temp_len = strnlen(value, 300)) < 300) {\n\t\t\t\tvol->UNC = kmalloc(temp_len+1, GFP_KERNEL);\n\t\t\t\tif (vol->UNC == NULL)\n\t\t\t\t\treturn 1;\n\t\t\t\tstrcpy(vol->UNC, value);\n\t\t\t\tif (strncmp(vol->UNC, \"//\", 2) == 0) {\n\t\t\t\t\tvol->UNC[0] = '\\\\';\n\t\t\t\t\tvol->UNC[1] = '\\\\';\n\t\t\t\t} else if (strncmp(vol->UNC, \"\\\\\\\\\", 2) != 0) {\n\t\t\t\t\tprintk(KERN_WARNING\n\t\t\t\t\t       \"CIFS: UNC Path does not begin \"\n\t\t\t\t\t       \"with // or \\\\\\\\ \\n\");\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tprintk(KERN_WARNING \"CIFS: UNC name too long\\n\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t} else if ((strnicmp(data, \"domain\", 3) == 0)\n\t\t\t   || (strnicmp(data, \"workgroup\", 5) == 0)) {\n\t\t\tif (!value || !*value) {\n\t\t\t\tprintk(KERN_WARNING \"CIFS: invalid domain name\\n\");\n\t\t\t\treturn 1;\t/* needs_arg; */\n\t\t\t}\n\t\t\t/* BB are there cases in which a comma can be valid in\n\t\t\ta domain name and need special handling? */\n\t\t\tif (strnlen(value, 256) < 256) {\n\t\t\t\tvol->domainname = value;\n\t\t\t\tcFYI(1, \"Domain name set\");\n\t\t\t} else {\n\t\t\t\tprintk(KERN_WARNING \"CIFS: domain name too \"\n\t\t\t\t\t\t    \"long\\n\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t} else if (strnicmp(data, \"srcaddr\", 7) == 0) {\n\t\t\tvol->srcaddr.ss_family = AF_UNSPEC;\n\n\t\t\tif (!value || !*value) {\n\t\t\t\tprintk(KERN_WARNING \"CIFS: srcaddr value\"\n\t\t\t\t       \" not specified.\\n\");\n\t\t\t\treturn 1;\t/* needs_arg; */\n\t\t\t}\n\t\t\ti = cifs_convert_address((struct sockaddr *)&vol->srcaddr,\n\t\t\t\t\t\t value, strlen(value));\n\t\t\tif (i == 0) {\n\t\t\t\tprintk(KERN_WARNING \"CIFS:  Could not parse\"\n\t\t\t\t       \" srcaddr: %s\\n\",\n\t\t\t\t       value);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t} else if (strnicmp(data, \"prefixpath\", 10) == 0) {\n\t\t\tif (!value || !*value) {\n\t\t\t\tprintk(KERN_WARNING\n\t\t\t\t\t\"CIFS: invalid path prefix\\n\");\n\t\t\t\treturn 1;       /* needs_argument */\n\t\t\t}\n\t\t\tif ((temp_len = strnlen(value, 1024)) < 1024) {\n\t\t\t\tif (value[0] != '/')\n\t\t\t\t\ttemp_len++;  /* missing leading slash */\n\t\t\t\tvol->prepath = kmalloc(temp_len+1, GFP_KERNEL);\n\t\t\t\tif (vol->prepath == NULL)\n\t\t\t\t\treturn 1;\n\t\t\t\tif (value[0] != '/') {\n\t\t\t\t\tvol->prepath[0] = '/';\n\t\t\t\t\tstrcpy(vol->prepath+1, value);\n\t\t\t\t} else\n\t\t\t\t\tstrcpy(vol->prepath, value);\n\t\t\t\tcFYI(1, \"prefix path %s\", vol->prepath);\n\t\t\t} else {\n\t\t\t\tprintk(KERN_WARNING \"CIFS: prefix too long\\n\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t} else if (strnicmp(data, \"iocharset\", 9) == 0) {\n\t\t\tif (!value || !*value) {\n\t\t\t\tprintk(KERN_WARNING \"CIFS: invalid iocharset \"\n\t\t\t\t\t\t    \"specified\\n\");\n\t\t\t\treturn 1;\t/* needs_arg; */\n\t\t\t}\n\t\t\tif (strnlen(value, 65) < 65) {\n\t\t\t\tif (strnicmp(value, \"default\", 7))\n\t\t\t\t\tvol->iocharset = value;\n\t\t\t\t/* if iocharset not set then load_nls_default\n\t\t\t\t   is used by caller */\n\t\t\t\tcFYI(1, \"iocharset set to %s\", value);\n\t\t\t} else {\n\t\t\t\tprintk(KERN_WARNING \"CIFS: iocharset name \"\n\t\t\t\t\t\t    \"too long.\\n\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t} else if (!strnicmp(data, \"uid\", 3) && value && *value) {\n\t\t\tvol->linux_uid = simple_strtoul(value, &value, 0);\n\t\t\tuid_specified = true;\n\t\t} else if (!strnicmp(data, \"cruid\", 5) && value && *value) {\n\t\t\tvol->cred_uid = simple_strtoul(value, &value, 0);\n\t\t} else if (!strnicmp(data, \"forceuid\", 8)) {\n\t\t\toverride_uid = 1;\n\t\t} else if (!strnicmp(data, \"noforceuid\", 10)) {\n\t\t\toverride_uid = 0;\n\t\t} else if (!strnicmp(data, \"gid\", 3) && value && *value) {\n\t\t\tvol->linux_gid = simple_strtoul(value, &value, 0);\n\t\t\tgid_specified = true;\n\t\t} else if (!strnicmp(data, \"forcegid\", 8)) {\n\t\t\toverride_gid = 1;\n\t\t} else if (!strnicmp(data, \"noforcegid\", 10)) {\n\t\t\toverride_gid = 0;\n\t\t} else if (strnicmp(data, \"file_mode\", 4) == 0) {\n\t\t\tif (value && *value) {\n\t\t\t\tvol->file_mode =\n\t\t\t\t\tsimple_strtoul(value, &value, 0);\n\t\t\t}\n\t\t} else if (strnicmp(data, \"dir_mode\", 4) == 0) {\n\t\t\tif (value && *value) {\n\t\t\t\tvol->dir_mode =\n\t\t\t\t\tsimple_strtoul(value, &value, 0);\n\t\t\t}\n\t\t} else if (strnicmp(data, \"dirmode\", 4) == 0) {\n\t\t\tif (value && *value) {\n\t\t\t\tvol->dir_mode =\n\t\t\t\t\tsimple_strtoul(value, &value, 0);\n\t\t\t}\n\t\t} else if (strnicmp(data, \"port\", 4) == 0) {\n\t\t\tif (value && *value) {\n\t\t\t\tvol->port =\n\t\t\t\t\tsimple_strtoul(value, &value, 0);\n\t\t\t}\n\t\t} else if (strnicmp(data, \"rsize\", 5) == 0) {\n\t\t\tif (value && *value) {\n\t\t\t\tvol->rsize =\n\t\t\t\t\tsimple_strtoul(value, &value, 0);\n\t\t\t}\n\t\t} else if (strnicmp(data, \"wsize\", 5) == 0) {\n\t\t\tif (value && *value) {\n\t\t\t\tvol->wsize =\n\t\t\t\t\tsimple_strtoul(value, &value, 0);\n\t\t\t}\n\t\t} else if (strnicmp(data, \"sockopt\", 5) == 0) {\n\t\t\tif (!value || !*value) {\n\t\t\t\tcERROR(1, \"no socket option specified\");\n\t\t\t\tcontinue;\n\t\t\t} else if (strnicmp(value, \"TCP_NODELAY\", 11) == 0) {\n\t\t\t\tvol->sockopt_tcp_nodelay = 1;\n\t\t\t}\n\t\t} else if (strnicmp(data, \"netbiosname\", 4) == 0) {\n\t\t\tif (!value || !*value || (*value == ' ')) {\n\t\t\t\tcFYI(1, \"invalid (empty) netbiosname\");\n\t\t\t} else {\n\t\t\t\tmemset(vol->source_rfc1001_name, 0x20,\n\t\t\t\t\tRFC1001_NAME_LEN);\n\t\t\t\t/*\n\t\t\t\t * FIXME: are there cases in which a comma can\n\t\t\t\t * be valid in workstation netbios name (and\n\t\t\t\t * need special handling)?\n\t\t\t\t */\n\t\t\t\tfor (i = 0; i < RFC1001_NAME_LEN; i++) {\n\t\t\t\t\t/* don't ucase netbiosname for user */\n\t\t\t\t\tif (value[i] == 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tvol->source_rfc1001_name[i] = value[i];\n\t\t\t\t}\n\t\t\t\t/* The string has 16th byte zero still from\n\t\t\t\tset at top of the function  */\n\t\t\t\tif (i == RFC1001_NAME_LEN && value[i] != 0)\n\t\t\t\t\tprintk(KERN_WARNING \"CIFS: netbiosname\"\n\t\t\t\t\t\t\" longer than 15 truncated.\\n\");\n\t\t\t}\n\t\t} else if (strnicmp(data, \"servern\", 7) == 0) {\n\t\t\t/* servernetbiosname specified override *SMBSERVER */\n\t\t\tif (!value || !*value || (*value == ' ')) {\n\t\t\t\tcFYI(1, \"empty server netbiosname specified\");\n\t\t\t} else {\n\t\t\t\t/* last byte, type, is 0x20 for servr type */\n\t\t\t\tmemset(vol->target_rfc1001_name, 0x20,\n\t\t\t\t\tRFC1001_NAME_LEN_WITH_NULL);\n\n\t\t\t\tfor (i = 0; i < 15; i++) {\n\t\t\t\t/* BB are there cases in which a comma can be\n\t\t\t\t   valid in this workstation netbios name\n\t\t\t\t   (and need special handling)? */\n\n\t\t\t\t/* user or mount helper must uppercase\n\t\t\t\t   the netbiosname */\n\t\t\t\t\tif (value[i] == 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\telse\n\t\t\t\t\t\tvol->target_rfc1001_name[i] =\n\t\t\t\t\t\t\t\tvalue[i];\n\t\t\t\t}\n\t\t\t\t/* The string has 16th byte zero still from\n\t\t\t\t   set at top of the function  */\n\t\t\t\tif (i == RFC1001_NAME_LEN && value[i] != 0)\n\t\t\t\t\tprintk(KERN_WARNING \"CIFS: server net\"\n\t\t\t\t\t\"biosname longer than 15 truncated.\\n\");\n\t\t\t}\n\t\t} else if (strnicmp(data, \"actimeo\", 7) == 0) {\n\t\t\tif (value && *value) {\n\t\t\t\tvol->actimeo = HZ * simple_strtoul(value,\n\t\t\t\t\t\t\t\t   &value, 0);\n\t\t\t\tif (vol->actimeo > CIFS_MAX_ACTIMEO) {\n\t\t\t\t\tcERROR(1, \"CIFS: attribute cache\"\n\t\t\t\t\t\t\t\"timeout too large\");\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (strnicmp(data, \"credentials\", 4) == 0) {\n\t\t\t/* ignore */\n\t\t} else if (strnicmp(data, \"version\", 3) == 0) {\n\t\t\t/* ignore */\n\t\t} else if (strnicmp(data, \"guest\", 5) == 0) {\n\t\t\t/* ignore */\n\t\t} else if (strnicmp(data, \"rw\", 2) == 0) {\n\t\t\t/* ignore */\n\t\t} else if (strnicmp(data, \"ro\", 2) == 0) {\n\t\t\t/* ignore */\n\t\t} else if (strnicmp(data, \"noblocksend\", 11) == 0) {\n\t\t\tvol->noblocksnd = 1;\n\t\t} else if (strnicmp(data, \"noautotune\", 10) == 0) {\n\t\t\tvol->noautotune = 1;\n\t\t} else if ((strnicmp(data, \"suid\", 4) == 0) ||\n\t\t\t\t   (strnicmp(data, \"nosuid\", 6) == 0) ||\n\t\t\t\t   (strnicmp(data, \"exec\", 4) == 0) ||\n\t\t\t\t   (strnicmp(data, \"noexec\", 6) == 0) ||\n\t\t\t\t   (strnicmp(data, \"nodev\", 5) == 0) ||\n\t\t\t\t   (strnicmp(data, \"noauto\", 6) == 0) ||\n\t\t\t\t   (strnicmp(data, \"dev\", 3) == 0)) {\n\t\t\t/*  The mount tool or mount.cifs helper (if present)\n\t\t\t    uses these opts to set flags, and the flags are read\n\t\t\t    by the kernel vfs layer before we get here (ie\n\t\t\t    before read super) so there is no point trying to\n\t\t\t    parse these options again and set anything and it\n\t\t\t    is ok to just ignore them */\n\t\t\tcontinue;\n\t\t} else if (strnicmp(data, \"hard\", 4) == 0) {\n\t\t\tvol->retry = 1;\n\t\t} else if (strnicmp(data, \"soft\", 4) == 0) {\n\t\t\tvol->retry = 0;\n\t\t} else if (strnicmp(data, \"perm\", 4) == 0) {\n\t\t\tvol->noperm = 0;\n\t\t} else if (strnicmp(data, \"noperm\", 6) == 0) {\n\t\t\tvol->noperm = 1;\n\t\t} else if (strnicmp(data, \"mapchars\", 8) == 0) {\n\t\t\tvol->remap = 1;\n\t\t} else if (strnicmp(data, \"nomapchars\", 10) == 0) {\n\t\t\tvol->remap = 0;\n\t\t} else if (strnicmp(data, \"sfu\", 3) == 0) {\n\t\t\tvol->sfu_emul = 1;\n\t\t} else if (strnicmp(data, \"nosfu\", 5) == 0) {\n\t\t\tvol->sfu_emul = 0;\n\t\t} else if (strnicmp(data, \"nodfs\", 5) == 0) {\n\t\t\tvol->nodfs = 1;\n\t\t} else if (strnicmp(data, \"posixpaths\", 10) == 0) {\n\t\t\tvol->posix_paths = 1;\n\t\t} else if (strnicmp(data, \"noposixpaths\", 12) == 0) {\n\t\t\tvol->posix_paths = 0;\n\t\t} else if (strnicmp(data, \"nounix\", 6) == 0) {\n\t\t\tvol->no_linux_ext = 1;\n\t\t} else if (strnicmp(data, \"nolinux\", 7) == 0) {\n\t\t\tvol->no_linux_ext = 1;\n\t\t} else if ((strnicmp(data, \"nocase\", 6) == 0) ||\n\t\t\t   (strnicmp(data, \"ignorecase\", 10)  == 0)) {\n\t\t\tvol->nocase = 1;\n\t\t} else if (strnicmp(data, \"mand\", 4) == 0) {\n\t\t\t/* ignore */\n\t\t} else if (strnicmp(data, \"nomand\", 6) == 0) {\n\t\t\t/* ignore */\n\t\t} else if (strnicmp(data, \"_netdev\", 7) == 0) {\n\t\t\t/* ignore */\n\t\t} else if (strnicmp(data, \"brl\", 3) == 0) {\n\t\t\tvol->nobrl =  0;\n\t\t} else if ((strnicmp(data, \"nobrl\", 5) == 0) ||\n\t\t\t   (strnicmp(data, \"nolock\", 6) == 0)) {\n\t\t\tvol->nobrl =  1;\n\t\t\t/* turn off mandatory locking in mode\n\t\t\tif remote locking is turned off since the\n\t\t\tlocal vfs will do advisory */\n\t\t\tif (vol->file_mode ==\n\t\t\t\t(S_IALLUGO & ~(S_ISUID | S_IXGRP)))\n\t\t\t\tvol->file_mode = S_IALLUGO;\n\t\t} else if (strnicmp(data, \"forcemandatorylock\", 9) == 0) {\n\t\t\t/* will take the shorter form \"forcemand\" as well */\n\t\t\t/* This mount option will force use of mandatory\n\t\t\t  (DOS/Windows style) byte range locks, instead of\n\t\t\t  using posix advisory byte range locks, even if the\n\t\t\t  Unix extensions are available and posix locks would\n\t\t\t  be supported otherwise. If Unix extensions are not\n\t\t\t  negotiated this has no effect since mandatory locks\n\t\t\t  would be used (mandatory locks is all that those\n\t\t\t  those servers support) */\n\t\t\tvol->mand_lock = 1;\n\t\t} else if (strnicmp(data, \"setuids\", 7) == 0) {\n\t\t\tvol->setuids = 1;\n\t\t} else if (strnicmp(data, \"nosetuids\", 9) == 0) {\n\t\t\tvol->setuids = 0;\n\t\t} else if (strnicmp(data, \"dynperm\", 7) == 0) {\n\t\t\tvol->dynperm = true;\n\t\t} else if (strnicmp(data, \"nodynperm\", 9) == 0) {\n\t\t\tvol->dynperm = false;\n\t\t} else if (strnicmp(data, \"nohard\", 6) == 0) {\n\t\t\tvol->retry = 0;\n\t\t} else if (strnicmp(data, \"nosoft\", 6) == 0) {\n\t\t\tvol->retry = 1;\n\t\t} else if (strnicmp(data, \"nointr\", 6) == 0) {\n\t\t\tvol->intr = 0;\n\t\t} else if (strnicmp(data, \"intr\", 4) == 0) {\n\t\t\tvol->intr = 1;\n\t\t} else if (strnicmp(data, \"nostrictsync\", 12) == 0) {\n\t\t\tvol->nostrictsync = 1;\n\t\t} else if (strnicmp(data, \"strictsync\", 10) == 0) {\n\t\t\tvol->nostrictsync = 0;\n\t\t} else if (strnicmp(data, \"serverino\", 7) == 0) {\n\t\t\tvol->server_ino = 1;\n\t\t} else if (strnicmp(data, \"noserverino\", 9) == 0) {\n\t\t\tvol->server_ino = 0;\n\t\t} else if (strnicmp(data, \"cifsacl\", 7) == 0) {\n\t\t\tvol->cifs_acl = 1;\n\t\t} else if (strnicmp(data, \"nocifsacl\", 9) == 0) {\n\t\t\tvol->cifs_acl = 0;\n\t\t} else if (strnicmp(data, \"acl\", 3) == 0) {\n\t\t\tvol->no_psx_acl = 0;\n\t\t} else if (strnicmp(data, \"noacl\", 5) == 0) {\n\t\t\tvol->no_psx_acl = 1;\n\t\t} else if (strnicmp(data, \"locallease\", 6) == 0) {\n\t\t\tvol->local_lease = 1;\n\t\t} else if (strnicmp(data, \"sign\", 4) == 0) {\n\t\t\tvol->secFlg |= CIFSSEC_MUST_SIGN;\n\t\t} else if (strnicmp(data, \"seal\", 4) == 0) {\n\t\t\t/* we do not do the following in secFlags because seal\n\t\t\t   is a per tree connection (mount) not a per socket\n\t\t\t   or per-smb connection option in the protocol */\n\t\t\t/* vol->secFlg |= CIFSSEC_MUST_SEAL; */\n\t\t\tvol->seal = 1;\n\t\t} else if (strnicmp(data, \"direct\", 6) == 0) {\n\t\t\tvol->direct_io = 1;\n\t\t} else if (strnicmp(data, \"forcedirectio\", 13) == 0) {\n\t\t\tvol->direct_io = 1;\n\t\t} else if (strnicmp(data, \"strictcache\", 11) == 0) {\n\t\t\tvol->strict_io = 1;\n\t\t} else if (strnicmp(data, \"noac\", 4) == 0) {\n\t\t\tprintk(KERN_WARNING \"CIFS: Mount option noac not \"\n\t\t\t\t\"supported. Instead set \"\n\t\t\t\t\"/proc/fs/cifs/LookupCacheEnabled to 0\\n\");\n\t\t} else if (strnicmp(data, \"fsc\", 3) == 0) {\n#ifndef CONFIG_CIFS_FSCACHE\n\t\t\tcERROR(1, \"FS-Cache support needs CONFIG_CIFS_FSCACHE\"\n\t\t\t\t  \"kernel config option set\");\n\t\t\treturn 1;\n#endif\n\t\t\tvol->fsc = true;\n\t\t} else if (strnicmp(data, \"mfsymlinks\", 10) == 0) {\n\t\t\tvol->mfsymlinks = true;\n\t\t} else if (strnicmp(data, \"multiuser\", 8) == 0) {\n\t\t\tvol->multiuser = true;\n\t\t} else\n\t\t\tprintk(KERN_WARNING \"CIFS: Unknown mount option %s\\n\",\n\t\t\t\t\t\tdata);\n\t}\n\tif (vol->UNC == NULL) {\n\t\tif (devname == NULL) {\n\t\t\tprintk(KERN_WARNING \"CIFS: Missing UNC name for mount \"\n\t\t\t\t\t\t\"target\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\tif ((temp_len = strnlen(devname, 300)) < 300) {\n\t\t\tvol->UNC = kmalloc(temp_len+1, GFP_KERNEL);\n\t\t\tif (vol->UNC == NULL)\n\t\t\t\treturn 1;\n\t\t\tstrcpy(vol->UNC, devname);\n\t\t\tif (strncmp(vol->UNC, \"//\", 2) == 0) {\n\t\t\t\tvol->UNC[0] = '\\\\';\n\t\t\t\tvol->UNC[1] = '\\\\';\n\t\t\t} else if (strncmp(vol->UNC, \"\\\\\\\\\", 2) != 0) {\n\t\t\t\tprintk(KERN_WARNING \"CIFS: UNC Path does not \"\n\t\t\t\t\t\t    \"begin with // or \\\\\\\\ \\n\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tvalue = strpbrk(vol->UNC+2, \"/\\\\\");\n\t\t\tif (value)\n\t\t\t\t*value = '\\\\';\n\t\t} else {\n\t\t\tprintk(KERN_WARNING \"CIFS: UNC name too long\\n\");\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif (vol->multiuser && !(vol->secFlg & CIFSSEC_MAY_KRB5)) {\n\t\tcERROR(1, \"Multiuser mounts currently require krb5 \"\n\t\t\t  \"authentication!\");\n\t\treturn 1;\n\t}\n\n\tif (vol->UNCip == NULL)\n\t\tvol->UNCip = &vol->UNC[2];\n\n\tif (uid_specified)\n\t\tvol->override_uid = override_uid;\n\telse if (override_uid == 1)\n\t\tprintk(KERN_NOTICE \"CIFS: ignoring forceuid mount option \"\n\t\t\t\t   \"specified with no uid= option.\\n\");\n\n\tif (gid_specified)\n\t\tvol->override_gid = override_gid;\n\telse if (override_gid == 1)\n\t\tprintk(KERN_NOTICE \"CIFS: ignoring forcegid mount option \"\n\t\t\t\t   \"specified with no gid= option.\\n\");\n\n\treturn 0;\n}\n\n/** Returns true if srcaddr isn't specified and rhs isn't\n * specified, or if srcaddr is specified and\n * matches the IP address of the rhs argument.\n */\nstatic bool\nsrcip_matches(struct sockaddr *srcaddr, struct sockaddr *rhs)\n{\n\tswitch (srcaddr->sa_family) {\n\tcase AF_UNSPEC:\n\t\treturn (rhs->sa_family == AF_UNSPEC);\n\tcase AF_INET: {\n\t\tstruct sockaddr_in *saddr4 = (struct sockaddr_in *)srcaddr;\n\t\tstruct sockaddr_in *vaddr4 = (struct sockaddr_in *)rhs;\n\t\treturn (saddr4->sin_addr.s_addr == vaddr4->sin_addr.s_addr);\n\t}\n\tcase AF_INET6: {\n\t\tstruct sockaddr_in6 *saddr6 = (struct sockaddr_in6 *)srcaddr;\n\t\tstruct sockaddr_in6 *vaddr6 = (struct sockaddr_in6 *)&rhs;\n\t\treturn ipv6_addr_equal(&saddr6->sin6_addr, &vaddr6->sin6_addr);\n\t}\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn false; /* don't expect to be here */\n\t}\n}\n\n/*\n * If no port is specified in addr structure, we try to match with 445 port\n * and if it fails - with 139 ports. It should be called only if address\n * families of server and addr are equal.\n */\nstatic bool\nmatch_port(struct TCP_Server_Info *server, struct sockaddr *addr)\n{\n\t__be16 port, *sport;\n\n\tswitch (addr->sa_family) {\n\tcase AF_INET:\n\t\tsport = &((struct sockaddr_in *) &server->dstaddr)->sin_port;\n\t\tport = ((struct sockaddr_in *) addr)->sin_port;\n\t\tbreak;\n\tcase AF_INET6:\n\t\tsport = &((struct sockaddr_in6 *) &server->dstaddr)->sin6_port;\n\t\tport = ((struct sockaddr_in6 *) addr)->sin6_port;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn false;\n\t}\n\n\tif (!port) {\n\t\tport = htons(CIFS_PORT);\n\t\tif (port == *sport)\n\t\t\treturn true;\n\n\t\tport = htons(RFC1001_PORT);\n\t}\n\n\treturn port == *sport;\n}\n\nstatic bool\nmatch_address(struct TCP_Server_Info *server, struct sockaddr *addr,\n\t      struct sockaddr *srcaddr)\n{\n\tswitch (addr->sa_family) {\n\tcase AF_INET: {\n\t\tstruct sockaddr_in *addr4 = (struct sockaddr_in *)addr;\n\t\tstruct sockaddr_in *srv_addr4 =\n\t\t\t\t\t(struct sockaddr_in *)&server->dstaddr;\n\n\t\tif (addr4->sin_addr.s_addr != srv_addr4->sin_addr.s_addr)\n\t\t\treturn false;\n\t\tbreak;\n\t}\n\tcase AF_INET6: {\n\t\tstruct sockaddr_in6 *addr6 = (struct sockaddr_in6 *)addr;\n\t\tstruct sockaddr_in6 *srv_addr6 =\n\t\t\t\t\t(struct sockaddr_in6 *)&server->dstaddr;\n\n\t\tif (!ipv6_addr_equal(&addr6->sin6_addr,\n\t\t\t\t     &srv_addr6->sin6_addr))\n\t\t\treturn false;\n\t\tif (addr6->sin6_scope_id != srv_addr6->sin6_scope_id)\n\t\t\treturn false;\n\t\tbreak;\n\t}\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn false; /* don't expect to be here */\n\t}\n\n\tif (!srcip_matches(srcaddr, (struct sockaddr *)&server->srcaddr))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool\nmatch_security(struct TCP_Server_Info *server, struct smb_vol *vol)\n{\n\tunsigned int secFlags;\n\n\tif (vol->secFlg & (~(CIFSSEC_MUST_SIGN | CIFSSEC_MUST_SEAL)))\n\t\tsecFlags = vol->secFlg;\n\telse\n\t\tsecFlags = global_secflags | vol->secFlg;\n\n\tswitch (server->secType) {\n\tcase LANMAN:\n\t\tif (!(secFlags & (CIFSSEC_MAY_LANMAN|CIFSSEC_MAY_PLNTXT)))\n\t\t\treturn false;\n\t\tbreak;\n\tcase NTLMv2:\n\t\tif (!(secFlags & CIFSSEC_MAY_NTLMV2))\n\t\t\treturn false;\n\t\tbreak;\n\tcase NTLM:\n\t\tif (!(secFlags & CIFSSEC_MAY_NTLM))\n\t\t\treturn false;\n\t\tbreak;\n\tcase Kerberos:\n\t\tif (!(secFlags & CIFSSEC_MAY_KRB5))\n\t\t\treturn false;\n\t\tbreak;\n\tcase RawNTLMSSP:\n\t\tif (!(secFlags & CIFSSEC_MAY_NTLMSSP))\n\t\t\treturn false;\n\t\tbreak;\n\tdefault:\n\t\t/* shouldn't happen */\n\t\treturn false;\n\t}\n\n\t/* now check if signing mode is acceptable */\n\tif ((secFlags & CIFSSEC_MAY_SIGN) == 0 &&\n\t    (server->secMode & SECMODE_SIGN_REQUIRED))\n\t\t\treturn false;\n\telse if (((secFlags & CIFSSEC_MUST_SIGN) == CIFSSEC_MUST_SIGN) &&\n\t\t (server->secMode &\n\t\t  (SECMODE_SIGN_ENABLED|SECMODE_SIGN_REQUIRED)) == 0)\n\t\t\treturn false;\n\n\treturn true;\n}\n\nstatic struct TCP_Server_Info *\ncifs_find_tcp_session(struct sockaddr *addr, struct smb_vol *vol)\n{\n\tstruct TCP_Server_Info *server;\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each_entry(server, &cifs_tcp_ses_list, tcp_ses_list) {\n\t\tif (!net_eq(cifs_net_ns(server), current->nsproxy->net_ns))\n\t\t\tcontinue;\n\n\t\tif (!match_address(server, addr,\n\t\t\t\t   (struct sockaddr *)&vol->srcaddr))\n\t\t\tcontinue;\n\n\t\tif (!match_port(server, addr))\n\t\t\tcontinue;\n\n\t\tif (!match_security(server, vol))\n\t\t\tcontinue;\n\n\t\t++server->srv_count;\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\tcFYI(1, \"Existing tcp session with server found\");\n\t\treturn server;\n\t}\n\tspin_unlock(&cifs_tcp_ses_lock);\n\treturn NULL;\n}\n\nstatic void\ncifs_put_tcp_session(struct TCP_Server_Info *server)\n{\n\tstruct task_struct *task;\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tif (--server->srv_count > 0) {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t}\n\n\tput_net(cifs_net_ns(server));\n\n\tlist_del_init(&server->tcp_ses_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tcancel_delayed_work_sync(&server->echo);\n\n\tspin_lock(&GlobalMid_Lock);\n\tserver->tcpStatus = CifsExiting;\n\tspin_unlock(&GlobalMid_Lock);\n\n\tcifs_crypto_shash_release(server);\n\tcifs_fscache_release_client_cookie(server);\n\n\tkfree(server->session_key.response);\n\tserver->session_key.response = NULL;\n\tserver->session_key.len = 0;\n\n\ttask = xchg(&server->tsk, NULL);\n\tif (task)\n\t\tforce_sig(SIGKILL, task);\n}\n\nstatic struct TCP_Server_Info *\ncifs_get_tcp_session(struct smb_vol *volume_info)\n{\n\tstruct TCP_Server_Info *tcp_ses = NULL;\n\tstruct sockaddr_storage addr;\n\tstruct sockaddr_in *sin_server = (struct sockaddr_in *) &addr;\n\tstruct sockaddr_in6 *sin_server6 = (struct sockaddr_in6 *) &addr;\n\tint rc;\n\n\tmemset(&addr, 0, sizeof(struct sockaddr_storage));\n\n\tcFYI(1, \"UNC: %s ip: %s\", volume_info->UNC, volume_info->UNCip);\n\n\tif (volume_info->UNCip && volume_info->UNC) {\n\t\trc = cifs_fill_sockaddr((struct sockaddr *)&addr,\n\t\t\t\t\tvolume_info->UNCip,\n\t\t\t\t\tstrlen(volume_info->UNCip),\n\t\t\t\t\tvolume_info->port);\n\t\tif (!rc) {\n\t\t\t/* we failed translating address */\n\t\t\trc = -EINVAL;\n\t\t\tgoto out_err;\n\t\t}\n\t} else if (volume_info->UNCip) {\n\t\t/* BB using ip addr as tcp_ses name to connect to the\n\t\t   DFS root below */\n\t\tcERROR(1, \"Connecting to DFS root not implemented yet\");\n\t\trc = -EINVAL;\n\t\tgoto out_err;\n\t} else /* which tcp_sess DFS root would we conect to */ {\n\t\tcERROR(1, \"CIFS mount error: No UNC path (e.g. -o \"\n\t\t\t\"unc=//192.168.1.100/public) specified\");\n\t\trc = -EINVAL;\n\t\tgoto out_err;\n\t}\n\n\t/* see if we already have a matching tcp_ses */\n\ttcp_ses = cifs_find_tcp_session((struct sockaddr *)&addr, volume_info);\n\tif (tcp_ses)\n\t\treturn tcp_ses;\n\n\ttcp_ses = kzalloc(sizeof(struct TCP_Server_Info), GFP_KERNEL);\n\tif (!tcp_ses) {\n\t\trc = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\trc = cifs_crypto_shash_allocate(tcp_ses);\n\tif (rc) {\n\t\tcERROR(1, \"could not setup hash structures rc %d\", rc);\n\t\tgoto out_err;\n\t}\n\n\tcifs_set_net_ns(tcp_ses, get_net(current->nsproxy->net_ns));\n\ttcp_ses->hostname = extract_hostname(volume_info->UNC);\n\tif (IS_ERR(tcp_ses->hostname)) {\n\t\trc = PTR_ERR(tcp_ses->hostname);\n\t\tgoto out_err_crypto_release;\n\t}\n\n\ttcp_ses->noblocksnd = volume_info->noblocksnd;\n\ttcp_ses->noautotune = volume_info->noautotune;\n\ttcp_ses->tcp_nodelay = volume_info->sockopt_tcp_nodelay;\n\tatomic_set(&tcp_ses->inFlight, 0);\n\tinit_waitqueue_head(&tcp_ses->response_q);\n\tinit_waitqueue_head(&tcp_ses->request_q);\n\tINIT_LIST_HEAD(&tcp_ses->pending_mid_q);\n\tmutex_init(&tcp_ses->srv_mutex);\n\tmemcpy(tcp_ses->workstation_RFC1001_name,\n\t\tvolume_info->source_rfc1001_name, RFC1001_NAME_LEN_WITH_NULL);\n\tmemcpy(tcp_ses->server_RFC1001_name,\n\t\tvolume_info->target_rfc1001_name, RFC1001_NAME_LEN_WITH_NULL);\n\ttcp_ses->session_estab = false;\n\ttcp_ses->sequence_number = 0;\n\ttcp_ses->lstrp = jiffies;\n\tINIT_LIST_HEAD(&tcp_ses->tcp_ses_list);\n\tINIT_LIST_HEAD(&tcp_ses->smb_ses_list);\n\tINIT_DELAYED_WORK(&tcp_ses->echo, cifs_echo_request);\n\n\t/*\n\t * at this point we are the only ones with the pointer\n\t * to the struct since the kernel thread not created yet\n\t * no need to spinlock this init of tcpStatus or srv_count\n\t */\n\ttcp_ses->tcpStatus = CifsNew;\n\tmemcpy(&tcp_ses->srcaddr, &volume_info->srcaddr,\n\t       sizeof(tcp_ses->srcaddr));\n\t++tcp_ses->srv_count;\n\n\tif (addr.ss_family == AF_INET6) {\n\t\tcFYI(1, \"attempting ipv6 connect\");\n\t\t/* BB should we allow ipv6 on port 139? */\n\t\t/* other OS never observed in Wild doing 139 with v6 */\n\t\tmemcpy(&tcp_ses->dstaddr, sin_server6,\n\t\t       sizeof(struct sockaddr_in6));\n\t} else\n\t\tmemcpy(&tcp_ses->dstaddr, sin_server,\n\t\t       sizeof(struct sockaddr_in));\n\n\trc = ip_connect(tcp_ses);\n\tif (rc < 0) {\n\t\tcERROR(1, \"Error connecting to socket. Aborting operation\");\n\t\tgoto out_err_crypto_release;\n\t}\n\n\t/*\n\t * since we're in a cifs function already, we know that\n\t * this will succeed. No need for try_module_get().\n\t */\n\t__module_get(THIS_MODULE);\n\ttcp_ses->tsk = kthread_run((void *)(void *)cifs_demultiplex_thread,\n\t\t\t\t  tcp_ses, \"cifsd\");\n\tif (IS_ERR(tcp_ses->tsk)) {\n\t\trc = PTR_ERR(tcp_ses->tsk);\n\t\tcERROR(1, \"error %d create cifsd thread\", rc);\n\t\tmodule_put(THIS_MODULE);\n\t\tgoto out_err_crypto_release;\n\t}\n\n\t/* thread spawned, put it on the list */\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_add(&tcp_ses->tcp_ses_list, &cifs_tcp_ses_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tcifs_fscache_get_client_cookie(tcp_ses);\n\n\t/* queue echo request delayed work */\n\tqueue_delayed_work(system_nrt_wq, &tcp_ses->echo, SMB_ECHO_INTERVAL);\n\n\treturn tcp_ses;\n\nout_err_crypto_release:\n\tcifs_crypto_shash_release(tcp_ses);\n\n\tput_net(cifs_net_ns(tcp_ses));\n\nout_err:\n\tif (tcp_ses) {\n\t\tif (!IS_ERR(tcp_ses->hostname))\n\t\t\tkfree(tcp_ses->hostname);\n\t\tif (tcp_ses->ssocket)\n\t\t\tsock_release(tcp_ses->ssocket);\n\t\tkfree(tcp_ses);\n\t}\n\treturn ERR_PTR(rc);\n}\n\nstatic struct cifsSesInfo *\ncifs_find_smb_ses(struct TCP_Server_Info *server, struct smb_vol *vol)\n{\n\tstruct cifsSesInfo *ses;\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each_entry(ses, &server->smb_ses_list, smb_ses_list) {\n\t\tswitch (server->secType) {\n\t\tcase Kerberos:\n\t\t\tif (vol->cred_uid != ses->cred_uid)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* anything else takes username/password */\n\t\t\tif (ses->user_name == NULL)\n\t\t\t\tcontinue;\n\t\t\tif (strncmp(ses->user_name, vol->username,\n\t\t\t\t    MAX_USERNAME_SIZE))\n\t\t\t\tcontinue;\n\t\t\tif (strlen(vol->username) != 0 &&\n\t\t\t    ses->password != NULL &&\n\t\t\t    strncmp(ses->password,\n\t\t\t\t    vol->password ? vol->password : \"\",\n\t\t\t\t    MAX_PASSWORD_SIZE))\n\t\t\t\tcontinue;\n\t\t}\n\t\t++ses->ses_count;\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn ses;\n\t}\n\tspin_unlock(&cifs_tcp_ses_lock);\n\treturn NULL;\n}\n\nstatic void\ncifs_put_smb_ses(struct cifsSesInfo *ses)\n{\n\tint xid;\n\tstruct TCP_Server_Info *server = ses->server;\n\n\tcFYI(1, \"%s: ses_count=%d\\n\", __func__, ses->ses_count);\n\tspin_lock(&cifs_tcp_ses_lock);\n\tif (--ses->ses_count > 0) {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t}\n\n\tlist_del_init(&ses->smb_ses_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tif (ses->status == CifsGood) {\n\t\txid = GetXid();\n\t\tCIFSSMBLogoff(xid, ses);\n\t\t_FreeXid(xid);\n\t}\n\tsesInfoFree(ses);\n\tcifs_put_tcp_session(server);\n}\n\nstatic struct cifsSesInfo *\ncifs_get_smb_ses(struct TCP_Server_Info *server, struct smb_vol *volume_info)\n{\n\tint rc = -ENOMEM, xid;\n\tstruct cifsSesInfo *ses;\n\tstruct sockaddr_in *addr = (struct sockaddr_in *)&server->dstaddr;\n\tstruct sockaddr_in6 *addr6 = (struct sockaddr_in6 *)&server->dstaddr;\n\n\txid = GetXid();\n\n\tses = cifs_find_smb_ses(server, volume_info);\n\tif (ses) {\n\t\tcFYI(1, \"Existing smb sess found (status=%d)\", ses->status);\n\n\t\tmutex_lock(&ses->session_mutex);\n\t\trc = cifs_negotiate_protocol(xid, ses);\n\t\tif (rc) {\n\t\t\tmutex_unlock(&ses->session_mutex);\n\t\t\t/* problem -- put our ses reference */\n\t\t\tcifs_put_smb_ses(ses);\n\t\t\tFreeXid(xid);\n\t\t\treturn ERR_PTR(rc);\n\t\t}\n\t\tif (ses->need_reconnect) {\n\t\t\tcFYI(1, \"Session needs reconnect\");\n\t\t\trc = cifs_setup_session(xid, ses,\n\t\t\t\t\t\tvolume_info->local_nls);\n\t\t\tif (rc) {\n\t\t\t\tmutex_unlock(&ses->session_mutex);\n\t\t\t\t/* problem -- put our reference */\n\t\t\t\tcifs_put_smb_ses(ses);\n\t\t\t\tFreeXid(xid);\n\t\t\t\treturn ERR_PTR(rc);\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&ses->session_mutex);\n\n\t\t/* existing SMB ses has a server reference already */\n\t\tcifs_put_tcp_session(server);\n\t\tFreeXid(xid);\n\t\treturn ses;\n\t}\n\n\tcFYI(1, \"Existing smb sess not found\");\n\tses = sesInfoAlloc();\n\tif (ses == NULL)\n\t\tgoto get_ses_fail;\n\n\t/* new SMB session uses our server ref */\n\tses->server = server;\n\tif (server->dstaddr.ss_family == AF_INET6)\n\t\tsprintf(ses->serverName, \"%pI6\", &addr6->sin6_addr);\n\telse\n\t\tsprintf(ses->serverName, \"%pI4\", &addr->sin_addr);\n\n\tif (volume_info->username) {\n\t\tses->user_name = kstrdup(volume_info->username, GFP_KERNEL);\n\t\tif (!ses->user_name)\n\t\t\tgoto get_ses_fail;\n\t}\n\n\t/* volume_info->password freed at unmount */\n\tif (volume_info->password) {\n\t\tses->password = kstrdup(volume_info->password, GFP_KERNEL);\n\t\tif (!ses->password)\n\t\t\tgoto get_ses_fail;\n\t}\n\tif (volume_info->domainname) {\n\t\tses->domainName = kstrdup(volume_info->domainname, GFP_KERNEL);\n\t\tif (!ses->domainName)\n\t\t\tgoto get_ses_fail;\n\t}\n\tses->cred_uid = volume_info->cred_uid;\n\tses->linux_uid = volume_info->linux_uid;\n\tses->overrideSecFlg = volume_info->secFlg;\n\n\tmutex_lock(&ses->session_mutex);\n\trc = cifs_negotiate_protocol(xid, ses);\n\tif (!rc)\n\t\trc = cifs_setup_session(xid, ses, volume_info->local_nls);\n\tmutex_unlock(&ses->session_mutex);\n\tif (rc)\n\t\tgoto get_ses_fail;\n\n\t/* success, put it on the list */\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_add(&ses->smb_ses_list, &server->smb_ses_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tFreeXid(xid);\n\treturn ses;\n\nget_ses_fail:\n\tsesInfoFree(ses);\n\tFreeXid(xid);\n\treturn ERR_PTR(rc);\n}\n\nstatic struct cifsTconInfo *\ncifs_find_tcon(struct cifsSesInfo *ses, const char *unc)\n{\n\tstruct list_head *tmp;\n\tstruct cifsTconInfo *tcon;\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each(tmp, &ses->tcon_list) {\n\t\ttcon = list_entry(tmp, struct cifsTconInfo, tcon_list);\n\t\tif (tcon->tidStatus == CifsExiting)\n\t\t\tcontinue;\n\t\tif (strncmp(tcon->treeName, unc, MAX_TREE_SIZE))\n\t\t\tcontinue;\n\n\t\t++tcon->tc_count;\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn tcon;\n\t}\n\tspin_unlock(&cifs_tcp_ses_lock);\n\treturn NULL;\n}\n\nstatic void\ncifs_put_tcon(struct cifsTconInfo *tcon)\n{\n\tint xid;\n\tstruct cifsSesInfo *ses = tcon->ses;\n\n\tcFYI(1, \"%s: tc_count=%d\\n\", __func__, tcon->tc_count);\n\tspin_lock(&cifs_tcp_ses_lock);\n\tif (--tcon->tc_count > 0) {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t}\n\n\tlist_del_init(&tcon->tcon_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\txid = GetXid();\n\tCIFSSMBTDis(xid, tcon);\n\t_FreeXid(xid);\n\n\tcifs_fscache_release_super_cookie(tcon);\n\ttconInfoFree(tcon);\n\tcifs_put_smb_ses(ses);\n}\n\nstatic struct cifsTconInfo *\ncifs_get_tcon(struct cifsSesInfo *ses, struct smb_vol *volume_info)\n{\n\tint rc, xid;\n\tstruct cifsTconInfo *tcon;\n\n\ttcon = cifs_find_tcon(ses, volume_info->UNC);\n\tif (tcon) {\n\t\tcFYI(1, \"Found match on UNC path\");\n\t\t/* existing tcon already has a reference */\n\t\tcifs_put_smb_ses(ses);\n\t\tif (tcon->seal != volume_info->seal)\n\t\t\tcERROR(1, \"transport encryption setting \"\n\t\t\t\t   \"conflicts with existing tid\");\n\t\treturn tcon;\n\t}\n\n\ttcon = tconInfoAlloc();\n\tif (tcon == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto out_fail;\n\t}\n\n\ttcon->ses = ses;\n\tif (volume_info->password) {\n\t\ttcon->password = kstrdup(volume_info->password, GFP_KERNEL);\n\t\tif (!tcon->password) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out_fail;\n\t\t}\n\t}\n\n\tif (strchr(volume_info->UNC + 3, '\\\\') == NULL\n\t    && strchr(volume_info->UNC + 3, '/') == NULL) {\n\t\tcERROR(1, \"Missing share name\");\n\t\trc = -ENODEV;\n\t\tgoto out_fail;\n\t}\n\n\t/* BB Do we need to wrap session_mutex around\n\t * this TCon call and Unix SetFS as\n\t * we do on SessSetup and reconnect? */\n\txid = GetXid();\n\trc = CIFSTCon(xid, ses, volume_info->UNC, tcon, volume_info->local_nls);\n\tFreeXid(xid);\n\tcFYI(1, \"CIFS Tcon rc = %d\", rc);\n\tif (rc)\n\t\tgoto out_fail;\n\n\tif (volume_info->nodfs) {\n\t\ttcon->Flags &= ~SMB_SHARE_IS_IN_DFS;\n\t\tcFYI(1, \"DFS disabled (%d)\", tcon->Flags);\n\t}\n\ttcon->seal = volume_info->seal;\n\t/* we can have only one retry value for a connection\n\t   to a share so for resources mounted more than once\n\t   to the same server share the last value passed in\n\t   for the retry flag is used */\n\ttcon->retry = volume_info->retry;\n\ttcon->nocase = volume_info->nocase;\n\ttcon->local_lease = volume_info->local_lease;\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_add(&tcon->tcon_list, &ses->tcon_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tcifs_fscache_get_super_cookie(tcon);\n\n\treturn tcon;\n\nout_fail:\n\ttconInfoFree(tcon);\n\treturn ERR_PTR(rc);\n}\n\nvoid\ncifs_put_tlink(struct tcon_link *tlink)\n{\n\tif (!tlink || IS_ERR(tlink))\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&tlink->tl_count) ||\n\t    test_bit(TCON_LINK_IN_TREE, &tlink->tl_flags)) {\n\t\ttlink->tl_time = jiffies;\n\t\treturn;\n\t}\n\n\tif (!IS_ERR(tlink_tcon(tlink)))\n\t\tcifs_put_tcon(tlink_tcon(tlink));\n\tkfree(tlink);\n\treturn;\n}\n\nint\nget_dfs_path(int xid, struct cifsSesInfo *pSesInfo, const char *old_path,\n\t     const struct nls_table *nls_codepage, unsigned int *pnum_referrals,\n\t     struct dfs_info3_param **preferrals, int remap)\n{\n\tchar *temp_unc;\n\tint rc = 0;\n\n\t*pnum_referrals = 0;\n\t*preferrals = NULL;\n\n\tif (pSesInfo->ipc_tid == 0) {\n\t\ttemp_unc = kmalloc(2 /* for slashes */ +\n\t\t\tstrnlen(pSesInfo->serverName,\n\t\t\t\tSERVER_NAME_LEN_WITH_NULL * 2)\n\t\t\t\t + 1 + 4 /* slash IPC$ */  + 2,\n\t\t\t\tGFP_KERNEL);\n\t\tif (temp_unc == NULL)\n\t\t\treturn -ENOMEM;\n\t\ttemp_unc[0] = '\\\\';\n\t\ttemp_unc[1] = '\\\\';\n\t\tstrcpy(temp_unc + 2, pSesInfo->serverName);\n\t\tstrcpy(temp_unc + 2 + strlen(pSesInfo->serverName), \"\\\\IPC$\");\n\t\trc = CIFSTCon(xid, pSesInfo, temp_unc, NULL, nls_codepage);\n\t\tcFYI(1, \"CIFS Tcon rc = %d ipc_tid = %d\", rc, pSesInfo->ipc_tid);\n\t\tkfree(temp_unc);\n\t}\n\tif (rc == 0)\n\t\trc = CIFSGetDFSRefer(xid, pSesInfo, old_path, preferrals,\n\t\t\t\t     pnum_referrals, nls_codepage, remap);\n\t/* BB map targetUNCs to dfs_info3 structures, here or\n\t\tin CIFSGetDFSRefer BB */\n\n\treturn rc;\n}\n\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\nstatic struct lock_class_key cifs_key[2];\nstatic struct lock_class_key cifs_slock_key[2];\n\nstatic inline void\ncifs_reclassify_socket4(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tBUG_ON(sock_owned_by_user(sk));\n\tsock_lock_init_class_and_name(sk, \"slock-AF_INET-CIFS\",\n\t\t&cifs_slock_key[0], \"sk_lock-AF_INET-CIFS\", &cifs_key[0]);\n}\n\nstatic inline void\ncifs_reclassify_socket6(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tBUG_ON(sock_owned_by_user(sk));\n\tsock_lock_init_class_and_name(sk, \"slock-AF_INET6-CIFS\",\n\t\t&cifs_slock_key[1], \"sk_lock-AF_INET6-CIFS\", &cifs_key[1]);\n}\n#else\nstatic inline void\ncifs_reclassify_socket4(struct socket *sock)\n{\n}\n\nstatic inline void\ncifs_reclassify_socket6(struct socket *sock)\n{\n}\n#endif\n\n/* See RFC1001 section 14 on representation of Netbios names */\nstatic void rfc1002mangle(char *target, char *source, unsigned int length)\n{\n\tunsigned int i, j;\n\n\tfor (i = 0, j = 0; i < (length); i++) {\n\t\t/* mask a nibble at a time and encode */\n\t\ttarget[j] = 'A' + (0x0F & (source[i] >> 4));\n\t\ttarget[j+1] = 'A' + (0x0F & source[i]);\n\t\tj += 2;\n\t}\n\n}\n\nstatic int\nbind_socket(struct TCP_Server_Info *server)\n{\n\tint rc = 0;\n\tif (server->srcaddr.ss_family != AF_UNSPEC) {\n\t\t/* Bind to the specified local IP address */\n\t\tstruct socket *socket = server->ssocket;\n\t\trc = socket->ops->bind(socket,\n\t\t\t\t       (struct sockaddr *) &server->srcaddr,\n\t\t\t\t       sizeof(server->srcaddr));\n\t\tif (rc < 0) {\n\t\t\tstruct sockaddr_in *saddr4;\n\t\t\tstruct sockaddr_in6 *saddr6;\n\t\t\tsaddr4 = (struct sockaddr_in *)&server->srcaddr;\n\t\t\tsaddr6 = (struct sockaddr_in6 *)&server->srcaddr;\n\t\t\tif (saddr6->sin6_family == AF_INET6)\n\t\t\t\tcERROR(1, \"cifs: \"\n\t\t\t\t       \"Failed to bind to: %pI6c, error: %d\\n\",\n\t\t\t\t       &saddr6->sin6_addr, rc);\n\t\t\telse\n\t\t\t\tcERROR(1, \"cifs: \"\n\t\t\t\t       \"Failed to bind to: %pI4, error: %d\\n\",\n\t\t\t\t       &saddr4->sin_addr.s_addr, rc);\n\t\t}\n\t}\n\treturn rc;\n}\n\nstatic int\nip_rfc1001_connect(struct TCP_Server_Info *server)\n{\n\tint rc = 0;\n\t/*\n\t * some servers require RFC1001 sessinit before sending\n\t * negprot - BB check reconnection in case where second\n\t * sessinit is sent but no second negprot\n\t */\n\tstruct rfc1002_session_packet *ses_init_buf;\n\tstruct smb_hdr *smb_buf;\n\tses_init_buf = kzalloc(sizeof(struct rfc1002_session_packet),\n\t\t\t       GFP_KERNEL);\n\tif (ses_init_buf) {\n\t\tses_init_buf->trailer.session_req.called_len = 32;\n\n\t\tif (server->server_RFC1001_name &&\n\t\t    server->server_RFC1001_name[0] != 0)\n\t\t\trfc1002mangle(ses_init_buf->trailer.\n\t\t\t\t      session_req.called_name,\n\t\t\t\t      server->server_RFC1001_name,\n\t\t\t\t      RFC1001_NAME_LEN_WITH_NULL);\n\t\telse\n\t\t\trfc1002mangle(ses_init_buf->trailer.\n\t\t\t\t      session_req.called_name,\n\t\t\t\t      DEFAULT_CIFS_CALLED_NAME,\n\t\t\t\t      RFC1001_NAME_LEN_WITH_NULL);\n\n\t\tses_init_buf->trailer.session_req.calling_len = 32;\n\n\t\t/*\n\t\t * calling name ends in null (byte 16) from old smb\n\t\t * convention.\n\t\t */\n\t\tif (server->workstation_RFC1001_name &&\n\t\t    server->workstation_RFC1001_name[0] != 0)\n\t\t\trfc1002mangle(ses_init_buf->trailer.\n\t\t\t\t      session_req.calling_name,\n\t\t\t\t      server->workstation_RFC1001_name,\n\t\t\t\t      RFC1001_NAME_LEN_WITH_NULL);\n\t\telse\n\t\t\trfc1002mangle(ses_init_buf->trailer.\n\t\t\t\t      session_req.calling_name,\n\t\t\t\t      \"LINUX_CIFS_CLNT\",\n\t\t\t\t      RFC1001_NAME_LEN_WITH_NULL);\n\n\t\tses_init_buf->trailer.session_req.scope1 = 0;\n\t\tses_init_buf->trailer.session_req.scope2 = 0;\n\t\tsmb_buf = (struct smb_hdr *)ses_init_buf;\n\n\t\t/* sizeof RFC1002_SESSION_REQUEST with no scope */\n\t\tsmb_buf->smb_buf_length = 0x81000044;\n\t\trc = smb_send(server, smb_buf, 0x44);\n\t\tkfree(ses_init_buf);\n\t\t/*\n\t\t * RFC1001 layer in at least one server\n\t\t * requires very short break before negprot\n\t\t * presumably because not expecting negprot\n\t\t * to follow so fast.  This is a simple\n\t\t * solution that works without\n\t\t * complicating the code and causes no\n\t\t * significant slowing down on mount\n\t\t * for everyone else\n\t\t */\n\t\tusleep_range(1000, 2000);\n\t}\n\t/*\n\t * else the negprot may still work without this\n\t * even though malloc failed\n\t */\n\n\treturn rc;\n}\n\nstatic int\ngeneric_ip_connect(struct TCP_Server_Info *server)\n{\n\tint rc = 0;\n\t__be16 sport;\n\tint slen, sfamily;\n\tstruct socket *socket = server->ssocket;\n\tstruct sockaddr *saddr;\n\n\tsaddr = (struct sockaddr *) &server->dstaddr;\n\n\tif (server->dstaddr.ss_family == AF_INET6) {\n\t\tsport = ((struct sockaddr_in6 *) saddr)->sin6_port;\n\t\tslen = sizeof(struct sockaddr_in6);\n\t\tsfamily = AF_INET6;\n\t} else {\n\t\tsport = ((struct sockaddr_in *) saddr)->sin_port;\n\t\tslen = sizeof(struct sockaddr_in);\n\t\tsfamily = AF_INET;\n\t}\n\n\tif (socket == NULL) {\n\t\trc = __sock_create(cifs_net_ns(server), sfamily, SOCK_STREAM,\n\t\t\t\t   IPPROTO_TCP, &socket, 1);\n\t\tif (rc < 0) {\n\t\t\tcERROR(1, \"Error %d creating socket\", rc);\n\t\t\tserver->ssocket = NULL;\n\t\t\treturn rc;\n\t\t}\n\n\t\t/* BB other socket options to set KEEPALIVE, NODELAY? */\n\t\tcFYI(1, \"Socket created\");\n\t\tserver->ssocket = socket;\n\t\tsocket->sk->sk_allocation = GFP_NOFS;\n\t\tif (sfamily == AF_INET6)\n\t\t\tcifs_reclassify_socket6(socket);\n\t\telse\n\t\t\tcifs_reclassify_socket4(socket);\n\t}\n\n\trc = bind_socket(server);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = socket->ops->connect(socket, saddr, slen, 0);\n\tif (rc < 0) {\n\t\tcFYI(1, \"Error %d connecting to server\", rc);\n\t\tsock_release(socket);\n\t\tserver->ssocket = NULL;\n\t\treturn rc;\n\t}\n\n\t/*\n\t * Eventually check for other socket options to change from\n\t * the default. sock_setsockopt not used because it expects\n\t * user space buffer\n\t */\n\tsocket->sk->sk_rcvtimeo = 7 * HZ;\n\tsocket->sk->sk_sndtimeo = 5 * HZ;\n\n\t/* make the bufsizes depend on wsize/rsize and max requests */\n\tif (server->noautotune) {\n\t\tif (socket->sk->sk_sndbuf < (200 * 1024))\n\t\t\tsocket->sk->sk_sndbuf = 200 * 1024;\n\t\tif (socket->sk->sk_rcvbuf < (140 * 1024))\n\t\t\tsocket->sk->sk_rcvbuf = 140 * 1024;\n\t}\n\n\tif (server->tcp_nodelay) {\n\t\tint val = 1;\n\t\trc = kernel_setsockopt(socket, SOL_TCP, TCP_NODELAY,\n\t\t\t\t(char *)&val, sizeof(val));\n\t\tif (rc)\n\t\t\tcFYI(1, \"set TCP_NODELAY socket option error %d\", rc);\n\t}\n\n\t cFYI(1, \"sndbuf %d rcvbuf %d rcvtimeo 0x%lx\",\n\t\t socket->sk->sk_sndbuf,\n\t\t socket->sk->sk_rcvbuf, socket->sk->sk_rcvtimeo);\n\n\tif (sport == htons(RFC1001_PORT))\n\t\trc = ip_rfc1001_connect(server);\n\n\treturn rc;\n}\n\nstatic int\nip_connect(struct TCP_Server_Info *server)\n{\n\t__be16 *sport;\n\tstruct sockaddr_in6 *addr6 = (struct sockaddr_in6 *)&server->dstaddr;\n\tstruct sockaddr_in *addr = (struct sockaddr_in *)&server->dstaddr;\n\n\tif (server->dstaddr.ss_family == AF_INET6)\n\t\tsport = &addr6->sin6_port;\n\telse\n\t\tsport = &addr->sin_port;\n\n\tif (*sport == 0) {\n\t\tint rc;\n\n\t\t/* try with 445 port at first */\n\t\t*sport = htons(CIFS_PORT);\n\n\t\trc = generic_ip_connect(server);\n\t\tif (rc >= 0)\n\t\t\treturn rc;\n\n\t\t/* if it failed, try with 139 port */\n\t\t*sport = htons(RFC1001_PORT);\n\t}\n\n\treturn generic_ip_connect(server);\n}\n\nvoid reset_cifs_unix_caps(int xid, struct cifsTconInfo *tcon,\n\t\t\t  struct super_block *sb, struct smb_vol *vol_info)\n{\n\t/* if we are reconnecting then should we check to see if\n\t * any requested capabilities changed locally e.g. via\n\t * remount but we can not do much about it here\n\t * if they have (even if we could detect it by the following)\n\t * Perhaps we could add a backpointer to array of sb from tcon\n\t * or if we change to make all sb to same share the same\n\t * sb as NFS - then we only have one backpointer to sb.\n\t * What if we wanted to mount the server share twice once with\n\t * and once without posixacls or posix paths? */\n\t__u64 saved_cap = le64_to_cpu(tcon->fsUnixInfo.Capability);\n\n\tif (vol_info && vol_info->no_linux_ext) {\n\t\ttcon->fsUnixInfo.Capability = 0;\n\t\ttcon->unix_ext = 0; /* Unix Extensions disabled */\n\t\tcFYI(1, \"Linux protocol extensions disabled\");\n\t\treturn;\n\t} else if (vol_info)\n\t\ttcon->unix_ext = 1; /* Unix Extensions supported */\n\n\tif (tcon->unix_ext == 0) {\n\t\tcFYI(1, \"Unix extensions disabled so not set on reconnect\");\n\t\treturn;\n\t}\n\n\tif (!CIFSSMBQFSUnixInfo(xid, tcon)) {\n\t\t__u64 cap = le64_to_cpu(tcon->fsUnixInfo.Capability);\n\n\t\t/* check for reconnect case in which we do not\n\t\t   want to change the mount behavior if we can avoid it */\n\t\tif (vol_info == NULL) {\n\t\t\t/* turn off POSIX ACL and PATHNAMES if not set\n\t\t\t   originally at mount time */\n\t\t\tif ((saved_cap & CIFS_UNIX_POSIX_ACL_CAP) == 0)\n\t\t\t\tcap &= ~CIFS_UNIX_POSIX_ACL_CAP;\n\t\t\tif ((saved_cap & CIFS_UNIX_POSIX_PATHNAMES_CAP) == 0) {\n\t\t\t\tif (cap & CIFS_UNIX_POSIX_PATHNAMES_CAP)\n\t\t\t\t\tcERROR(1, \"POSIXPATH support change\");\n\t\t\t\tcap &= ~CIFS_UNIX_POSIX_PATHNAMES_CAP;\n\t\t\t} else if ((cap & CIFS_UNIX_POSIX_PATHNAMES_CAP) == 0) {\n\t\t\t\tcERROR(1, \"possible reconnect error\");\n\t\t\t\tcERROR(1, \"server disabled POSIX path support\");\n\t\t\t}\n\t\t}\n\n\t\tcap &= CIFS_UNIX_CAP_MASK;\n\t\tif (vol_info && vol_info->no_psx_acl)\n\t\t\tcap &= ~CIFS_UNIX_POSIX_ACL_CAP;\n\t\telse if (CIFS_UNIX_POSIX_ACL_CAP & cap) {\n\t\t\tcFYI(1, \"negotiated posix acl support\");\n\t\t\tif (sb)\n\t\t\t\tsb->s_flags |= MS_POSIXACL;\n\t\t}\n\n\t\tif (vol_info && vol_info->posix_paths == 0)\n\t\t\tcap &= ~CIFS_UNIX_POSIX_PATHNAMES_CAP;\n\t\telse if (cap & CIFS_UNIX_POSIX_PATHNAMES_CAP) {\n\t\t\tcFYI(1, \"negotiate posix pathnames\");\n\t\t\tif (sb)\n\t\t\t\tCIFS_SB(sb)->mnt_cifs_flags |=\n\t\t\t\t\tCIFS_MOUNT_POSIX_PATHS;\n\t\t}\n\n\t\t/* We might be setting the path sep back to a different\n\t\tform if we are reconnecting and the server switched its\n\t\tposix path capability for this share */\n\t\tif (sb && (CIFS_SB(sb)->prepathlen > 0))\n\t\t\tCIFS_SB(sb)->prepath[0] = CIFS_DIR_SEP(CIFS_SB(sb));\n\n\t\tif (sb && (CIFS_SB(sb)->rsize > 127 * 1024)) {\n\t\t\tif ((cap & CIFS_UNIX_LARGE_READ_CAP) == 0) {\n\t\t\t\tCIFS_SB(sb)->rsize = 127 * 1024;\n\t\t\t\tcFYI(DBG2, \"larger reads not supported by srv\");\n\t\t\t}\n\t\t}\n\n\n\t\tcFYI(1, \"Negotiate caps 0x%x\", (int)cap);\n#ifdef CONFIG_CIFS_DEBUG2\n\t\tif (cap & CIFS_UNIX_FCNTL_CAP)\n\t\t\tcFYI(1, \"FCNTL cap\");\n\t\tif (cap & CIFS_UNIX_EXTATTR_CAP)\n\t\t\tcFYI(1, \"EXTATTR cap\");\n\t\tif (cap & CIFS_UNIX_POSIX_PATHNAMES_CAP)\n\t\t\tcFYI(1, \"POSIX path cap\");\n\t\tif (cap & CIFS_UNIX_XATTR_CAP)\n\t\t\tcFYI(1, \"XATTR cap\");\n\t\tif (cap & CIFS_UNIX_POSIX_ACL_CAP)\n\t\t\tcFYI(1, \"POSIX ACL cap\");\n\t\tif (cap & CIFS_UNIX_LARGE_READ_CAP)\n\t\t\tcFYI(1, \"very large read cap\");\n\t\tif (cap & CIFS_UNIX_LARGE_WRITE_CAP)\n\t\t\tcFYI(1, \"very large write cap\");\n#endif /* CIFS_DEBUG2 */\n\t\tif (CIFSSMBSetFSUnixInfo(xid, tcon, cap)) {\n\t\t\tif (vol_info == NULL) {\n\t\t\t\tcFYI(1, \"resetting capabilities failed\");\n\t\t\t} else\n\t\t\t\tcERROR(1, \"Negotiating Unix capabilities \"\n\t\t\t\t\t   \"with the server failed.  Consider \"\n\t\t\t\t\t   \"mounting with the Unix Extensions\\n\"\n\t\t\t\t\t   \"disabled, if problems are found, \"\n\t\t\t\t\t   \"by specifying the nounix mount \"\n\t\t\t\t\t   \"option.\");\n\n\t\t}\n\t}\n}\n\nstatic void\nconvert_delimiter(char *path, char delim)\n{\n\tint i;\n\tchar old_delim;\n\n\tif (path == NULL)\n\t\treturn;\n\n\tif (delim == '/')\n\t\told_delim = '\\\\';\n\telse\n\t\told_delim = '/';\n\n\tfor (i = 0; path[i] != '\\0'; i++) {\n\t\tif (path[i] == old_delim)\n\t\t\tpath[i] = delim;\n\t}\n}\n\nstatic void setup_cifs_sb(struct smb_vol *pvolume_info,\n\t\t\t  struct cifs_sb_info *cifs_sb)\n{\n\tINIT_DELAYED_WORK(&cifs_sb->prune_tlinks, cifs_prune_tlinks);\n\n\tif (pvolume_info->rsize > CIFSMaxBufSize) {\n\t\tcERROR(1, \"rsize %d too large, using MaxBufSize\",\n\t\t\tpvolume_info->rsize);\n\t\tcifs_sb->rsize = CIFSMaxBufSize;\n\t} else if ((pvolume_info->rsize) &&\n\t\t\t(pvolume_info->rsize <= CIFSMaxBufSize))\n\t\tcifs_sb->rsize = pvolume_info->rsize;\n\telse /* default */\n\t\tcifs_sb->rsize = CIFSMaxBufSize;\n\n\tif (pvolume_info->wsize > PAGEVEC_SIZE * PAGE_CACHE_SIZE) {\n\t\tcERROR(1, \"wsize %d too large, using 4096 instead\",\n\t\t\t  pvolume_info->wsize);\n\t\tcifs_sb->wsize = 4096;\n\t} else if (pvolume_info->wsize)\n\t\tcifs_sb->wsize = pvolume_info->wsize;\n\telse\n\t\tcifs_sb->wsize = min_t(const int,\n\t\t\t\t\tPAGEVEC_SIZE * PAGE_CACHE_SIZE,\n\t\t\t\t\t127*1024);\n\t\t/* old default of CIFSMaxBufSize was too small now\n\t\t   that SMB Write2 can send multiple pages in kvec.\n\t\t   RFC1001 does not describe what happens when frame\n\t\t   bigger than 128K is sent so use that as max in\n\t\t   conjunction with 52K kvec constraint on arch with 4K\n\t\t   page size  */\n\n\tif (cifs_sb->rsize < 2048) {\n\t\tcifs_sb->rsize = 2048;\n\t\t/* Windows ME may prefer this */\n\t\tcFYI(1, \"readsize set to minimum: 2048\");\n\t}\n\t/* calculate prepath */\n\tcifs_sb->prepath = pvolume_info->prepath;\n\tif (cifs_sb->prepath) {\n\t\tcifs_sb->prepathlen = strlen(cifs_sb->prepath);\n\t\t/* we can not convert the / to \\ in the path\n\t\tseparators in the prefixpath yet because we do not\n\t\tknow (until reset_cifs_unix_caps is called later)\n\t\twhether POSIX PATH CAP is available. We normalize\n\t\tthe / to \\ after reset_cifs_unix_caps is called */\n\t\tpvolume_info->prepath = NULL;\n\t} else\n\t\tcifs_sb->prepathlen = 0;\n\tcifs_sb->mnt_uid = pvolume_info->linux_uid;\n\tcifs_sb->mnt_gid = pvolume_info->linux_gid;\n\tcifs_sb->mnt_file_mode = pvolume_info->file_mode;\n\tcifs_sb->mnt_dir_mode = pvolume_info->dir_mode;\n\tcFYI(1, \"file mode: 0x%x  dir mode: 0x%x\",\n\t\tcifs_sb->mnt_file_mode, cifs_sb->mnt_dir_mode);\n\n\tcifs_sb->actimeo = pvolume_info->actimeo;\n\n\tif (pvolume_info->noperm)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_NO_PERM;\n\tif (pvolume_info->setuids)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_SET_UID;\n\tif (pvolume_info->server_ino)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_SERVER_INUM;\n\tif (pvolume_info->remap)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_MAP_SPECIAL_CHR;\n\tif (pvolume_info->no_xattr)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_NO_XATTR;\n\tif (pvolume_info->sfu_emul)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_UNX_EMUL;\n\tif (pvolume_info->nobrl)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_NO_BRL;\n\tif (pvolume_info->nostrictsync)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_NOSSYNC;\n\tif (pvolume_info->mand_lock)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_NOPOSIXBRL;\n\tif (pvolume_info->cifs_acl)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_CIFS_ACL;\n\tif (pvolume_info->override_uid)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_OVERR_UID;\n\tif (pvolume_info->override_gid)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_OVERR_GID;\n\tif (pvolume_info->dynperm)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_DYNPERM;\n\tif (pvolume_info->fsc)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_FSCACHE;\n\tif (pvolume_info->multiuser)\n\t\tcifs_sb->mnt_cifs_flags |= (CIFS_MOUNT_MULTIUSER |\n\t\t\t\t\t    CIFS_MOUNT_NO_PERM);\n\tif (pvolume_info->strict_io)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_STRICT_IO;\n\tif (pvolume_info->direct_io) {\n\t\tcFYI(1, \"mounting share using direct i/o\");\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_DIRECT_IO;\n\t}\n\tif (pvolume_info->mfsymlinks) {\n\t\tif (pvolume_info->sfu_emul) {\n\t\t\tcERROR(1,  \"mount option mfsymlinks ignored if sfu \"\n\t\t\t\t   \"mount option is used\");\n\t\t} else {\n\t\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_MF_SYMLINKS;\n\t\t}\n\t}\n\n\tif ((pvolume_info->cifs_acl) && (pvolume_info->dynperm))\n\t\tcERROR(1, \"mount option dynperm ignored if cifsacl \"\n\t\t\t   \"mount option supported\");\n}\n\nstatic int\nis_path_accessible(int xid, struct cifsTconInfo *tcon,\n\t\t   struct cifs_sb_info *cifs_sb, const char *full_path)\n{\n\tint rc;\n\tFILE_ALL_INFO *pfile_info;\n\n\tpfile_info = kmalloc(sizeof(FILE_ALL_INFO), GFP_KERNEL);\n\tif (pfile_info == NULL)\n\t\treturn -ENOMEM;\n\n\trc = CIFSSMBQPathInfo(xid, tcon, full_path, pfile_info,\n\t\t\t      0 /* not legacy */, cifs_sb->local_nls,\n\t\t\t      cifs_sb->mnt_cifs_flags &\n\t\t\t\tCIFS_MOUNT_MAP_SPECIAL_CHR);\n\tkfree(pfile_info);\n\treturn rc;\n}\n\nstatic void\ncleanup_volume_info(struct smb_vol **pvolume_info)\n{\n\tstruct smb_vol *volume_info;\n\n\tif (!pvolume_info || !*pvolume_info)\n\t\treturn;\n\n\tvolume_info = *pvolume_info;\n\tkzfree(volume_info->password);\n\tkfree(volume_info->UNC);\n\tkfree(volume_info->prepath);\n\tkfree(volume_info);\n\t*pvolume_info = NULL;\n\treturn;\n}\n\n#ifdef CONFIG_CIFS_DFS_UPCALL\n/* build_path_to_root returns full path to root when\n * we do not have an exiting connection (tcon) */\nstatic char *\nbuild_unc_path_to_root(const struct smb_vol *volume_info,\n\t\tconst struct cifs_sb_info *cifs_sb)\n{\n\tchar *full_path;\n\n\tint unc_len = strnlen(volume_info->UNC, MAX_TREE_SIZE + 1);\n\tfull_path = kmalloc(unc_len + cifs_sb->prepathlen + 1, GFP_KERNEL);\n\tif (full_path == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstrncpy(full_path, volume_info->UNC, unc_len);\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS) {\n\t\tint i;\n\t\tfor (i = 0; i < unc_len; i++) {\n\t\t\tif (full_path[i] == '\\\\')\n\t\t\t\tfull_path[i] = '/';\n\t\t}\n\t}\n\n\tif (cifs_sb->prepathlen)\n\t\tstrncpy(full_path + unc_len, cifs_sb->prepath,\n\t\t\t\tcifs_sb->prepathlen);\n\n\tfull_path[unc_len + cifs_sb->prepathlen] = 0; /* add trailing null */\n\treturn full_path;\n}\n#endif\n\nint\ncifs_mount(struct super_block *sb, struct cifs_sb_info *cifs_sb,\n\t\tchar *mount_data_global, const char *devname)\n{\n\tint rc;\n\tint xid;\n\tstruct smb_vol *volume_info;\n\tstruct cifsSesInfo *pSesInfo;\n\tstruct cifsTconInfo *tcon;\n\tstruct TCP_Server_Info *srvTcp;\n\tchar   *full_path;\n\tchar *mount_data = mount_data_global;\n\tstruct tcon_link *tlink;\n#ifdef CONFIG_CIFS_DFS_UPCALL\n\tstruct dfs_info3_param *referrals = NULL;\n\tunsigned int num_referrals = 0;\n\tint referral_walks_count = 0;\ntry_mount_again:\n#endif\n\trc = 0;\n\ttcon = NULL;\n\tpSesInfo = NULL;\n\tsrvTcp = NULL;\n\tfull_path = NULL;\n\ttlink = NULL;\n\n\txid = GetXid();\n\n\tvolume_info = kzalloc(sizeof(struct smb_vol), GFP_KERNEL);\n\tif (!volume_info) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (cifs_parse_mount_options(mount_data, devname, volume_info)) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (volume_info->nullauth) {\n\t\tcFYI(1, \"null user\");\n\t\tvolume_info->username = \"\";\n\t} else if (volume_info->username) {\n\t\t/* BB fixme parse for domain name here */\n\t\tcFYI(1, \"Username: %s\", volume_info->username);\n\t} else {\n\t\tcifserror(\"No username specified\");\n\t/* In userspace mount helper we can get user name from alternate\n\t   locations such as env variables and files on disk */\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* this is needed for ASCII cp to Unicode converts */\n\tif (volume_info->iocharset == NULL) {\n\t\t/* load_nls_default cannot return null */\n\t\tvolume_info->local_nls = load_nls_default();\n\t} else {\n\t\tvolume_info->local_nls = load_nls(volume_info->iocharset);\n\t\tif (volume_info->local_nls == NULL) {\n\t\t\tcERROR(1, \"CIFS mount error: iocharset %s not found\",\n\t\t\t\t volume_info->iocharset);\n\t\t\trc = -ELIBACC;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tcifs_sb->local_nls = volume_info->local_nls;\n\n\t/* get a reference to a tcp session */\n\tsrvTcp = cifs_get_tcp_session(volume_info);\n\tif (IS_ERR(srvTcp)) {\n\t\trc = PTR_ERR(srvTcp);\n\t\tgoto out;\n\t}\n\n\t/* get a reference to a SMB session */\n\tpSesInfo = cifs_get_smb_ses(srvTcp, volume_info);\n\tif (IS_ERR(pSesInfo)) {\n\t\trc = PTR_ERR(pSesInfo);\n\t\tpSesInfo = NULL;\n\t\tgoto mount_fail_check;\n\t}\n\n\tsetup_cifs_sb(volume_info, cifs_sb);\n\tif (pSesInfo->capabilities & CAP_LARGE_FILES)\n\t\tsb->s_maxbytes = MAX_LFS_FILESIZE;\n\telse\n\t\tsb->s_maxbytes = MAX_NON_LFS;\n\n\t/* BB FIXME fix time_gran to be larger for LANMAN sessions */\n\tsb->s_time_gran = 100;\n\n\t/* search for existing tcon to this server share */\n\ttcon = cifs_get_tcon(pSesInfo, volume_info);\n\tif (IS_ERR(tcon)) {\n\t\trc = PTR_ERR(tcon);\n\t\ttcon = NULL;\n\t\tgoto remote_path_check;\n\t}\n\n\t/* do not care if following two calls succeed - informational */\n\tif (!tcon->ipc) {\n\t\tCIFSSMBQFSDeviceInfo(xid, tcon);\n\t\tCIFSSMBQFSAttributeInfo(xid, tcon);\n\t}\n\n\t/* tell server which Unix caps we support */\n\tif (tcon->ses->capabilities & CAP_UNIX)\n\t\t/* reset of caps checks mount to see if unix extensions\n\t\t   disabled for just this mount */\n\t\treset_cifs_unix_caps(xid, tcon, sb, volume_info);\n\telse\n\t\ttcon->unix_ext = 0; /* server does not support them */\n\n\t/* convert forward to back slashes in prepath here if needed */\n\tif ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS) == 0)\n\t\tconvert_delimiter(cifs_sb->prepath, CIFS_DIR_SEP(cifs_sb));\n\n\tif ((tcon->unix_ext == 0) && (cifs_sb->rsize > (1024 * 127))) {\n\t\tcifs_sb->rsize = 1024 * 127;\n\t\tcFYI(DBG2, \"no very large read support, rsize now 127K\");\n\t}\n\tif (!(tcon->ses->capabilities & CAP_LARGE_WRITE_X))\n\t\tcifs_sb->wsize = min(cifs_sb->wsize,\n\t\t\t       (tcon->ses->server->maxBuf - MAX_CIFS_HDR_SIZE));\n\tif (!(tcon->ses->capabilities & CAP_LARGE_READ_X))\n\t\tcifs_sb->rsize = min(cifs_sb->rsize,\n\t\t\t       (tcon->ses->server->maxBuf - MAX_CIFS_HDR_SIZE));\n\nremote_path_check:\n\t/* check if a whole path (including prepath) is not remote */\n\tif (!rc && cifs_sb->prepathlen && tcon) {\n\t\t/* build_path_to_root works only when we have a valid tcon */\n\t\tfull_path = cifs_build_path_to_root(cifs_sb, tcon);\n\t\tif (full_path == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto mount_fail_check;\n\t\t}\n\t\trc = is_path_accessible(xid, tcon, cifs_sb, full_path);\n\t\tif (rc != 0 && rc != -EREMOTE) {\n\t\t\tkfree(full_path);\n\t\t\tgoto mount_fail_check;\n\t\t}\n\t\tkfree(full_path);\n\t}\n\n\t/* get referral if needed */\n\tif (rc == -EREMOTE) {\n#ifdef CONFIG_CIFS_DFS_UPCALL\n\t\tif (referral_walks_count > MAX_NESTED_LINKS) {\n\t\t\t/*\n\t\t\t * BB: when we implement proper loop detection,\n\t\t\t *     we will remove this check. But now we need it\n\t\t\t *     to prevent an indefinite loop if 'DFS tree' is\n\t\t\t *     misconfigured (i.e. has loops).\n\t\t\t */\n\t\t\trc = -ELOOP;\n\t\t\tgoto mount_fail_check;\n\t\t}\n\t\t/* convert forward to back slashes in prepath here if needed */\n\t\tif ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS) == 0)\n\t\t\tconvert_delimiter(cifs_sb->prepath,\n\t\t\t\t\tCIFS_DIR_SEP(cifs_sb));\n\t\tfull_path = build_unc_path_to_root(volume_info, cifs_sb);\n\t\tif (IS_ERR(full_path)) {\n\t\t\trc = PTR_ERR(full_path);\n\t\t\tgoto mount_fail_check;\n\t\t}\n\n\t\tcFYI(1, \"Getting referral for: %s\", full_path);\n\t\trc = get_dfs_path(xid, pSesInfo , full_path + 1,\n\t\t\tcifs_sb->local_nls, &num_referrals, &referrals,\n\t\t\tcifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR);\n\t\tif (!rc && num_referrals > 0) {\n\t\t\tchar *fake_devname = NULL;\n\n\t\t\tif (mount_data != mount_data_global)\n\t\t\t\tkfree(mount_data);\n\n\t\t\tmount_data = cifs_compose_mount_options(\n\t\t\t\t\tcifs_sb->mountdata, full_path + 1,\n\t\t\t\t\treferrals, &fake_devname);\n\n\t\t\tfree_dfs_info_array(referrals, num_referrals);\n\t\t\tkfree(fake_devname);\n\t\t\tkfree(full_path);\n\n\t\t\tif (IS_ERR(mount_data)) {\n\t\t\t\trc = PTR_ERR(mount_data);\n\t\t\t\tmount_data = NULL;\n\t\t\t\tgoto mount_fail_check;\n\t\t\t}\n\n\t\t\tif (tcon)\n\t\t\t\tcifs_put_tcon(tcon);\n\t\t\telse if (pSesInfo)\n\t\t\t\tcifs_put_smb_ses(pSesInfo);\n\n\t\t\tcleanup_volume_info(&volume_info);\n\t\t\treferral_walks_count++;\n\t\t\tFreeXid(xid);\n\t\t\tgoto try_mount_again;\n\t\t}\n#else /* No DFS support, return error on mount */\n\t\trc = -EOPNOTSUPP;\n#endif\n\t}\n\n\tif (rc)\n\t\tgoto mount_fail_check;\n\n\t/* now, hang the tcon off of the superblock */\n\ttlink = kzalloc(sizeof *tlink, GFP_KERNEL);\n\tif (tlink == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto mount_fail_check;\n\t}\n\n\ttlink->tl_uid = pSesInfo->linux_uid;\n\ttlink->tl_tcon = tcon;\n\ttlink->tl_time = jiffies;\n\tset_bit(TCON_LINK_MASTER, &tlink->tl_flags);\n\tset_bit(TCON_LINK_IN_TREE, &tlink->tl_flags);\n\n\tcifs_sb->master_tlink = tlink;\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\ttlink_rb_insert(&cifs_sb->tlink_tree, tlink);\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tqueue_delayed_work(system_nrt_wq, &cifs_sb->prune_tlinks,\n\t\t\t\tTLINK_IDLE_EXPIRE);\n\nmount_fail_check:\n\t/* on error free sesinfo and tcon struct if needed */\n\tif (rc) {\n\t\tif (mount_data != mount_data_global)\n\t\t\tkfree(mount_data);\n\t\t/* If find_unc succeeded then rc == 0 so we can not end */\n\t\t/* up accidentally freeing someone elses tcon struct */\n\t\tif (tcon)\n\t\t\tcifs_put_tcon(tcon);\n\t\telse if (pSesInfo)\n\t\t\tcifs_put_smb_ses(pSesInfo);\n\t\telse\n\t\t\tcifs_put_tcp_session(srvTcp);\n\t\tgoto out;\n\t}\n\n\t/* volume_info->password is freed above when existing session found\n\t(in which case it is not needed anymore) but when new sesion is created\n\tthe password ptr is put in the new session structure (in which case the\n\tpassword will be freed at unmount time) */\nout:\n\t/* zero out password before freeing */\n\tcleanup_volume_info(&volume_info);\n\tFreeXid(xid);\n\treturn rc;\n}\n\nint\nCIFSTCon(unsigned int xid, struct cifsSesInfo *ses,\n\t const char *tree, struct cifsTconInfo *tcon,\n\t const struct nls_table *nls_codepage)\n{\n\tstruct smb_hdr *smb_buffer;\n\tstruct smb_hdr *smb_buffer_response;\n\tTCONX_REQ *pSMB;\n\tTCONX_RSP *pSMBr;\n\tunsigned char *bcc_ptr;\n\tint rc = 0;\n\tint length;\n\t__u16 bytes_left, count;\n\n\tif (ses == NULL)\n\t\treturn -EIO;\n\n\tsmb_buffer = cifs_buf_get();\n\tif (smb_buffer == NULL)\n\t\treturn -ENOMEM;\n\n\tsmb_buffer_response = smb_buffer;\n\n\theader_assemble(smb_buffer, SMB_COM_TREE_CONNECT_ANDX,\n\t\t\tNULL /*no tid */ , 4 /*wct */ );\n\n\tsmb_buffer->Mid = GetNextMid(ses->server);\n\tsmb_buffer->Uid = ses->Suid;\n\tpSMB = (TCONX_REQ *) smb_buffer;\n\tpSMBr = (TCONX_RSP *) smb_buffer_response;\n\n\tpSMB->AndXCommand = 0xFF;\n\tpSMB->Flags = cpu_to_le16(TCON_EXTENDED_SECINFO);\n\tbcc_ptr = &pSMB->Password[0];\n\tif ((ses->server->secMode) & SECMODE_USER) {\n\t\tpSMB->PasswordLength = cpu_to_le16(1);\t/* minimum */\n\t\t*bcc_ptr = 0; /* password is null byte */\n\t\tbcc_ptr++;              /* skip password */\n\t\t/* already aligned so no need to do it below */\n\t} else {\n\t\tpSMB->PasswordLength = cpu_to_le16(CIFS_AUTH_RESP_SIZE);\n\t\t/* BB FIXME add code to fail this if NTLMv2 or Kerberos\n\t\t   specified as required (when that support is added to\n\t\t   the vfs in the future) as only NTLM or the much\n\t\t   weaker LANMAN (which we do not send by default) is accepted\n\t\t   by Samba (not sure whether other servers allow\n\t\t   NTLMv2 password here) */\n#ifdef CONFIG_CIFS_WEAK_PW_HASH\n\t\tif ((global_secflags & CIFSSEC_MAY_LANMAN) &&\n\t\t    (ses->server->secType == LANMAN))\n\t\t\tcalc_lanman_hash(tcon->password, ses->server->cryptkey,\n\t\t\t\t\t ses->server->secMode &\n\t\t\t\t\t    SECMODE_PW_ENCRYPT ? true : false,\n\t\t\t\t\t bcc_ptr);\n\t\telse\n#endif /* CIFS_WEAK_PW_HASH */\n\t\trc = SMBNTencrypt(tcon->password, ses->server->cryptkey,\n\t\t\t\t\tbcc_ptr);\n\n\t\tbcc_ptr += CIFS_AUTH_RESP_SIZE;\n\t\tif (ses->capabilities & CAP_UNICODE) {\n\t\t\t/* must align unicode strings */\n\t\t\t*bcc_ptr = 0; /* null byte password */\n\t\t\tbcc_ptr++;\n\t\t}\n\t}\n\n\tif (ses->server->secMode &\n\t\t\t(SECMODE_SIGN_REQUIRED | SECMODE_SIGN_ENABLED))\n\t\tsmb_buffer->Flags2 |= SMBFLG2_SECURITY_SIGNATURE;\n\n\tif (ses->capabilities & CAP_STATUS32) {\n\t\tsmb_buffer->Flags2 |= SMBFLG2_ERR_STATUS;\n\t}\n\tif (ses->capabilities & CAP_DFS) {\n\t\tsmb_buffer->Flags2 |= SMBFLG2_DFS;\n\t}\n\tif (ses->capabilities & CAP_UNICODE) {\n\t\tsmb_buffer->Flags2 |= SMBFLG2_UNICODE;\n\t\tlength =\n\t\t    cifs_strtoUCS((__le16 *) bcc_ptr, tree,\n\t\t\t6 /* max utf8 char length in bytes */ *\n\t\t\t(/* server len*/ + 256 /* share len */), nls_codepage);\n\t\tbcc_ptr += 2 * length;\t/* convert num 16 bit words to bytes */\n\t\tbcc_ptr += 2;\t/* skip trailing null */\n\t} else {\t\t/* ASCII */\n\t\tstrcpy(bcc_ptr, tree);\n\t\tbcc_ptr += strlen(tree) + 1;\n\t}\n\tstrcpy(bcc_ptr, \"?????\");\n\tbcc_ptr += strlen(\"?????\");\n\tbcc_ptr += 1;\n\tcount = bcc_ptr - &pSMB->Password[0];\n\tpSMB->hdr.smb_buf_length += count;\n\tpSMB->ByteCount = cpu_to_le16(count);\n\n\trc = SendReceive(xid, ses, smb_buffer, smb_buffer_response, &length,\n\t\t\t 0);\n\n\t/* above now done in SendReceive */\n\tif ((rc == 0) && (tcon != NULL)) {\n\t\tbool is_unicode;\n\n\t\ttcon->tidStatus = CifsGood;\n\t\ttcon->need_reconnect = false;\n\t\ttcon->tid = smb_buffer_response->Tid;\n\t\tbcc_ptr = pByteArea(smb_buffer_response);\n\t\tbytes_left = get_bcc(smb_buffer_response);\n\t\tlength = strnlen(bcc_ptr, bytes_left - 2);\n\t\tif (smb_buffer->Flags2 & SMBFLG2_UNICODE)\n\t\t\tis_unicode = true;\n\t\telse\n\t\t\tis_unicode = false;\n\n\n\t\t/* skip service field (NB: this field is always ASCII) */\n\t\tif (length == 3) {\n\t\t\tif ((bcc_ptr[0] == 'I') && (bcc_ptr[1] == 'P') &&\n\t\t\t    (bcc_ptr[2] == 'C')) {\n\t\t\t\tcFYI(1, \"IPC connection\");\n\t\t\t\ttcon->ipc = 1;\n\t\t\t}\n\t\t} else if (length == 2) {\n\t\t\tif ((bcc_ptr[0] == 'A') && (bcc_ptr[1] == ':')) {\n\t\t\t\t/* the most common case */\n\t\t\t\tcFYI(1, \"disk share connection\");\n\t\t\t}\n\t\t}\n\t\tbcc_ptr += length + 1;\n\t\tbytes_left -= (length + 1);\n\t\tstrncpy(tcon->treeName, tree, MAX_TREE_SIZE);\n\n\t\t/* mostly informational -- no need to fail on error here */\n\t\tkfree(tcon->nativeFileSystem);\n\t\ttcon->nativeFileSystem = cifs_strndup_from_ucs(bcc_ptr,\n\t\t\t\t\t\t      bytes_left, is_unicode,\n\t\t\t\t\t\t      nls_codepage);\n\n\t\tcFYI(1, \"nativeFileSystem=%s\", tcon->nativeFileSystem);\n\n\t\tif ((smb_buffer_response->WordCount == 3) ||\n\t\t\t (smb_buffer_response->WordCount == 7))\n\t\t\t/* field is in same location */\n\t\t\ttcon->Flags = le16_to_cpu(pSMBr->OptionalSupport);\n\t\telse\n\t\t\ttcon->Flags = 0;\n\t\tcFYI(1, \"Tcon flags: 0x%x \", tcon->Flags);\n\t} else if ((rc == 0) && tcon == NULL) {\n\t\t/* all we need to save for IPC$ connection */\n\t\tses->ipc_tid = smb_buffer_response->Tid;\n\t}\n\n\tcifs_buf_release(smb_buffer);\n\treturn rc;\n}\n\nint\ncifs_umount(struct super_block *sb, struct cifs_sb_info *cifs_sb)\n{\n\tstruct rb_root *root = &cifs_sb->tlink_tree;\n\tstruct rb_node *node;\n\tstruct tcon_link *tlink;\n\tchar *tmp;\n\n\tcancel_delayed_work_sync(&cifs_sb->prune_tlinks);\n\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\twhile ((node = rb_first(root))) {\n\t\ttlink = rb_entry(node, struct tcon_link, tl_rbnode);\n\t\tcifs_get_tlink(tlink);\n\t\tclear_bit(TCON_LINK_IN_TREE, &tlink->tl_flags);\n\t\trb_erase(node, root);\n\n\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t\tcifs_put_tlink(tlink);\n\t\tspin_lock(&cifs_sb->tlink_tree_lock);\n\t}\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\ttmp = cifs_sb->prepath;\n\tcifs_sb->prepathlen = 0;\n\tcifs_sb->prepath = NULL;\n\tkfree(tmp);\n\n\treturn 0;\n}\n\nint cifs_negotiate_protocol(unsigned int xid, struct cifsSesInfo *ses)\n{\n\tint rc = 0;\n\tstruct TCP_Server_Info *server = ses->server;\n\n\t/* only send once per connect */\n\tif (server->maxBuf != 0)\n\t\treturn 0;\n\n\trc = CIFSSMBNegotiate(xid, ses);\n\tif (rc == -EAGAIN) {\n\t\t/* retry only once on 1st time connection */\n\t\trc = CIFSSMBNegotiate(xid, ses);\n\t\tif (rc == -EAGAIN)\n\t\t\trc = -EHOSTDOWN;\n\t}\n\tif (rc == 0) {\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (server->tcpStatus != CifsExiting)\n\t\t\tserver->tcpStatus = CifsGood;\n\t\telse\n\t\t\trc = -EHOSTDOWN;\n\t\tspin_unlock(&GlobalMid_Lock);\n\n\t}\n\n\treturn rc;\n}\n\n\nint cifs_setup_session(unsigned int xid, struct cifsSesInfo *ses,\n\t\t\tstruct nls_table *nls_info)\n{\n\tint rc = 0;\n\tstruct TCP_Server_Info *server = ses->server;\n\n\tses->flags = 0;\n\tses->capabilities = server->capabilities;\n\tif (linuxExtEnabled == 0)\n\t\tses->capabilities &= (~CAP_UNIX);\n\n\tcFYI(1, \"Security Mode: 0x%x Capabilities: 0x%x TimeAdjust: %d\",\n\t\t server->secMode, server->capabilities, server->timeAdj);\n\n\trc = CIFS_SessSetup(xid, ses, nls_info);\n\tif (rc) {\n\t\tcERROR(1, \"Send error in SessSetup = %d\", rc);\n\t} else {\n\t\tmutex_lock(&ses->server->srv_mutex);\n\t\tif (!server->session_estab) {\n\t\t\tserver->session_key.response = ses->auth_key.response;\n\t\t\tserver->session_key.len = ses->auth_key.len;\n\t\t\tserver->sequence_number = 0x2;\n\t\t\tserver->session_estab = true;\n\t\t\tses->auth_key.response = NULL;\n\t\t}\n\t\tmutex_unlock(&server->srv_mutex);\n\n\t\tcFYI(1, \"CIFS Session Established successfully\");\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tses->status = CifsGood;\n\t\tses->need_reconnect = false;\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\tkfree(ses->auth_key.response);\n\tses->auth_key.response = NULL;\n\tses->auth_key.len = 0;\n\tkfree(ses->ntlmssp);\n\tses->ntlmssp = NULL;\n\n\treturn rc;\n}\n\nstatic struct cifsTconInfo *\ncifs_construct_tcon(struct cifs_sb_info *cifs_sb, uid_t fsuid)\n{\n\tstruct cifsTconInfo *master_tcon = cifs_sb_master_tcon(cifs_sb);\n\tstruct cifsSesInfo *ses;\n\tstruct cifsTconInfo *tcon = NULL;\n\tstruct smb_vol *vol_info;\n\tchar username[MAX_USERNAME_SIZE + 1];\n\n\tvol_info = kzalloc(sizeof(*vol_info), GFP_KERNEL);\n\tif (vol_info == NULL) {\n\t\ttcon = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\n\tsnprintf(username, MAX_USERNAME_SIZE, \"krb50x%x\", fsuid);\n\tvol_info->username = username;\n\tvol_info->local_nls = cifs_sb->local_nls;\n\tvol_info->linux_uid = fsuid;\n\tvol_info->cred_uid = fsuid;\n\tvol_info->UNC = master_tcon->treeName;\n\tvol_info->retry = master_tcon->retry;\n\tvol_info->nocase = master_tcon->nocase;\n\tvol_info->local_lease = master_tcon->local_lease;\n\tvol_info->no_linux_ext = !master_tcon->unix_ext;\n\n\t/* FIXME: allow for other secFlg settings */\n\tvol_info->secFlg = CIFSSEC_MUST_KRB5;\n\n\t/* get a reference for the same TCP session */\n\tspin_lock(&cifs_tcp_ses_lock);\n\t++master_tcon->ses->server->srv_count;\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tses = cifs_get_smb_ses(master_tcon->ses->server, vol_info);\n\tif (IS_ERR(ses)) {\n\t\ttcon = (struct cifsTconInfo *)ses;\n\t\tcifs_put_tcp_session(master_tcon->ses->server);\n\t\tgoto out;\n\t}\n\n\ttcon = cifs_get_tcon(ses, vol_info);\n\tif (IS_ERR(tcon)) {\n\t\tcifs_put_smb_ses(ses);\n\t\tgoto out;\n\t}\n\n\tif (ses->capabilities & CAP_UNIX)\n\t\treset_cifs_unix_caps(0, tcon, NULL, vol_info);\nout:\n\tkfree(vol_info);\n\n\treturn tcon;\n}\n\nstatic inline struct tcon_link *\ncifs_sb_master_tlink(struct cifs_sb_info *cifs_sb)\n{\n\treturn cifs_sb->master_tlink;\n}\n\nstruct cifsTconInfo *\ncifs_sb_master_tcon(struct cifs_sb_info *cifs_sb)\n{\n\treturn tlink_tcon(cifs_sb_master_tlink(cifs_sb));\n}\n\nstatic int\ncifs_sb_tcon_pending_wait(void *unused)\n{\n\tschedule();\n\treturn signal_pending(current) ? -ERESTARTSYS : 0;\n}\n\n/* find and return a tlink with given uid */\nstatic struct tcon_link *\ntlink_rb_search(struct rb_root *root, uid_t uid)\n{\n\tstruct rb_node *node = root->rb_node;\n\tstruct tcon_link *tlink;\n\n\twhile (node) {\n\t\ttlink = rb_entry(node, struct tcon_link, tl_rbnode);\n\n\t\tif (tlink->tl_uid > uid)\n\t\t\tnode = node->rb_left;\n\t\telse if (tlink->tl_uid < uid)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn tlink;\n\t}\n\treturn NULL;\n}\n\n/* insert a tcon_link into the tree */\nstatic void\ntlink_rb_insert(struct rb_root *root, struct tcon_link *new_tlink)\n{\n\tstruct rb_node **new = &(root->rb_node), *parent = NULL;\n\tstruct tcon_link *tlink;\n\n\twhile (*new) {\n\t\ttlink = rb_entry(*new, struct tcon_link, tl_rbnode);\n\t\tparent = *new;\n\n\t\tif (tlink->tl_uid > new_tlink->tl_uid)\n\t\t\tnew = &((*new)->rb_left);\n\t\telse\n\t\t\tnew = &((*new)->rb_right);\n\t}\n\n\trb_link_node(&new_tlink->tl_rbnode, parent, new);\n\trb_insert_color(&new_tlink->tl_rbnode, root);\n}\n\n/*\n * Find or construct an appropriate tcon given a cifs_sb and the fsuid of the\n * current task.\n *\n * If the superblock doesn't refer to a multiuser mount, then just return\n * the master tcon for the mount.\n *\n * First, search the rbtree for an existing tcon for this fsuid. If one\n * exists, then check to see if it's pending construction. If it is then wait\n * for construction to complete. Once it's no longer pending, check to see if\n * it failed and either return an error or retry construction, depending on\n * the timeout.\n *\n * If one doesn't exist then insert a new tcon_link struct into the tree and\n * try to construct a new one.\n */\nstruct tcon_link *\ncifs_sb_tlink(struct cifs_sb_info *cifs_sb)\n{\n\tint ret;\n\tuid_t fsuid = current_fsuid();\n\tstruct tcon_link *tlink, *newtlink;\n\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER))\n\t\treturn cifs_get_tlink(cifs_sb_master_tlink(cifs_sb));\n\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\tif (tlink)\n\t\tcifs_get_tlink(tlink);\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tif (tlink == NULL) {\n\t\tnewtlink = kzalloc(sizeof(*tlink), GFP_KERNEL);\n\t\tif (newtlink == NULL)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tnewtlink->tl_uid = fsuid;\n\t\tnewtlink->tl_tcon = ERR_PTR(-EACCES);\n\t\tset_bit(TCON_LINK_PENDING, &newtlink->tl_flags);\n\t\tset_bit(TCON_LINK_IN_TREE, &newtlink->tl_flags);\n\t\tcifs_get_tlink(newtlink);\n\n\t\tspin_lock(&cifs_sb->tlink_tree_lock);\n\t\t/* was one inserted after previous search? */\n\t\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\t\tif (tlink) {\n\t\t\tcifs_get_tlink(tlink);\n\t\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t\t\tkfree(newtlink);\n\t\t\tgoto wait_for_construction;\n\t\t}\n\t\ttlink = newtlink;\n\t\ttlink_rb_insert(&cifs_sb->tlink_tree, tlink);\n\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t} else {\nwait_for_construction:\n\t\tret = wait_on_bit(&tlink->tl_flags, TCON_LINK_PENDING,\n\t\t\t\t  cifs_sb_tcon_pending_wait,\n\t\t\t\t  TASK_INTERRUPTIBLE);\n\t\tif (ret) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\n\t\t/* if it's good, return it */\n\t\tif (!IS_ERR(tlink->tl_tcon))\n\t\t\treturn tlink;\n\n\t\t/* return error if we tried this already recently */\n\t\tif (time_before(jiffies, tlink->tl_time + TLINK_ERROR_EXPIRE)) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-EACCES);\n\t\t}\n\n\t\tif (test_and_set_bit(TCON_LINK_PENDING, &tlink->tl_flags))\n\t\t\tgoto wait_for_construction;\n\t}\n\n\ttlink->tl_tcon = cifs_construct_tcon(cifs_sb, fsuid);\n\tclear_bit(TCON_LINK_PENDING, &tlink->tl_flags);\n\twake_up_bit(&tlink->tl_flags, TCON_LINK_PENDING);\n\n\tif (IS_ERR(tlink->tl_tcon)) {\n\t\tcifs_put_tlink(tlink);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\treturn tlink;\n}\n\n/*\n * periodic workqueue job that scans tcon_tree for a superblock and closes\n * out tcons.\n */\nstatic void\ncifs_prune_tlinks(struct work_struct *work)\n{\n\tstruct cifs_sb_info *cifs_sb = container_of(work, struct cifs_sb_info,\n\t\t\t\t\t\t    prune_tlinks.work);\n\tstruct rb_root *root = &cifs_sb->tlink_tree;\n\tstruct rb_node *node = rb_first(root);\n\tstruct rb_node *tmp;\n\tstruct tcon_link *tlink;\n\n\t/*\n\t * Because we drop the spinlock in the loop in order to put the tlink\n\t * it's not guarded against removal of links from the tree. The only\n\t * places that remove entries from the tree are this function and\n\t * umounts. Because this function is non-reentrant and is canceled\n\t * before umount can proceed, this is safe.\n\t */\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\tnode = rb_first(root);\n\twhile (node != NULL) {\n\t\ttmp = node;\n\t\tnode = rb_next(tmp);\n\t\ttlink = rb_entry(tmp, struct tcon_link, tl_rbnode);\n\n\t\tif (test_bit(TCON_LINK_MASTER, &tlink->tl_flags) ||\n\t\t    atomic_read(&tlink->tl_count) != 0 ||\n\t\t    time_after(tlink->tl_time + TLINK_IDLE_EXPIRE, jiffies))\n\t\t\tcontinue;\n\n\t\tcifs_get_tlink(tlink);\n\t\tclear_bit(TCON_LINK_IN_TREE, &tlink->tl_flags);\n\t\trb_erase(tmp, root);\n\n\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t\tcifs_put_tlink(tlink);\n\t\tspin_lock(&cifs_sb->tlink_tree_lock);\n\t}\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tqueue_delayed_work(system_nrt_wq, &cifs_sb->prune_tlinks,\n\t\t\t\tTLINK_IDLE_EXPIRE);\n}\n"], "fixing_code": ["/*\n *   fs/cifs/connect.c\n *\n *   Copyright (C) International Business Machines  Corp., 2002,2009\n *   Author(s): Steve French (sfrench@us.ibm.com)\n *\n *   This library is free software; you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published\n *   by the Free Software Foundation; either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This library is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See\n *   the GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this library; if not, write to the Free Software\n *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\n */\n#include <linux/fs.h>\n#include <linux/net.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/ctype.h>\n#include <linux/utsname.h>\n#include <linux/mempool.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/pagevec.h>\n#include <linux/freezer.h>\n#include <linux/namei.h>\n#include <asm/uaccess.h>\n#include <asm/processor.h>\n#include <linux/inet.h>\n#include <net/ipv6.h>\n#include \"cifspdu.h\"\n#include \"cifsglob.h\"\n#include \"cifsproto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_fs_sb.h\"\n#include \"ntlmssp.h\"\n#include \"nterr.h\"\n#include \"rfc1002pdu.h\"\n#include \"fscache.h\"\n\n#define CIFS_PORT 445\n#define RFC1001_PORT 139\n\n/* SMB echo \"timeout\" -- FIXME: tunable? */\n#define SMB_ECHO_INTERVAL (60 * HZ)\n\nextern mempool_t *cifs_req_poolp;\n\nstruct smb_vol {\n\tchar *username;\n\tchar *password;\n\tchar *domainname;\n\tchar *UNC;\n\tchar *UNCip;\n\tchar *iocharset;  /* local code page for mapping to and from Unicode */\n\tchar source_rfc1001_name[RFC1001_NAME_LEN_WITH_NULL]; /* clnt nb name */\n\tchar target_rfc1001_name[RFC1001_NAME_LEN_WITH_NULL]; /* srvr nb name */\n\tuid_t cred_uid;\n\tuid_t linux_uid;\n\tgid_t linux_gid;\n\tmode_t file_mode;\n\tmode_t dir_mode;\n\tunsigned secFlg;\n\tbool retry:1;\n\tbool intr:1;\n\tbool setuids:1;\n\tbool override_uid:1;\n\tbool override_gid:1;\n\tbool dynperm:1;\n\tbool noperm:1;\n\tbool no_psx_acl:1; /* set if posix acl support should be disabled */\n\tbool cifs_acl:1;\n\tbool no_xattr:1;   /* set if xattr (EA) support should be disabled*/\n\tbool server_ino:1; /* use inode numbers from server ie UniqueId */\n\tbool direct_io:1;\n\tbool strict_io:1; /* strict cache behavior */\n\tbool remap:1;      /* set to remap seven reserved chars in filenames */\n\tbool posix_paths:1; /* unset to not ask for posix pathnames. */\n\tbool no_linux_ext:1;\n\tbool sfu_emul:1;\n\tbool nullauth:1;   /* attempt to authenticate with null user */\n\tbool nocase:1;     /* request case insensitive filenames */\n\tbool nobrl:1;      /* disable sending byte range locks to srv */\n\tbool mand_lock:1;  /* send mandatory not posix byte range lock reqs */\n\tbool seal:1;       /* request transport encryption on share */\n\tbool nodfs:1;      /* Do not request DFS, even if available */\n\tbool local_lease:1; /* check leases only on local system, not remote */\n\tbool noblocksnd:1;\n\tbool noautotune:1;\n\tbool nostrictsync:1; /* do not force expensive SMBflush on every sync */\n\tbool fsc:1;\t/* enable fscache */\n\tbool mfsymlinks:1; /* use Minshall+French Symlinks */\n\tbool multiuser:1;\n\tunsigned int rsize;\n\tunsigned int wsize;\n\tbool sockopt_tcp_nodelay:1;\n\tunsigned short int port;\n\tunsigned long actimeo; /* attribute cache timeout (jiffies) */\n\tchar *prepath;\n\tstruct sockaddr_storage srcaddr; /* allow binding to a local IP */\n\tstruct nls_table *local_nls;\n};\n\n/* FIXME: should these be tunable? */\n#define TLINK_ERROR_EXPIRE\t(1 * HZ)\n#define TLINK_IDLE_EXPIRE\t(600 * HZ)\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\nstatic void tlink_rb_insert(struct rb_root *root, struct tcon_link *new_tlink);\nstatic void cifs_prune_tlinks(struct work_struct *work);\n\n/*\n * cifs tcp session reconnection\n *\n * mark tcp session as reconnecting so temporarily locked\n * mark all smb sessions as reconnecting for tcp session\n * reconnect tcp session\n * wake up waiters on reconnection? - (not needed currently)\n */\nstatic int\ncifs_reconnect(struct TCP_Server_Info *server)\n{\n\tint rc = 0;\n\tstruct list_head *tmp, *tmp2;\n\tstruct cifsSesInfo *ses;\n\tstruct cifsTconInfo *tcon;\n\tstruct mid_q_entry *mid_entry;\n\n\tspin_lock(&GlobalMid_Lock);\n\tif (server->tcpStatus == CifsExiting) {\n\t\t/* the demux thread will exit normally\n\t\tnext time through the loop */\n\t\tspin_unlock(&GlobalMid_Lock);\n\t\treturn rc;\n\t} else\n\t\tserver->tcpStatus = CifsNeedReconnect;\n\tspin_unlock(&GlobalMid_Lock);\n\tserver->maxBuf = 0;\n\n\tcFYI(1, \"Reconnecting tcp session\");\n\n\t/* before reconnecting the tcp session, mark the smb session (uid)\n\t\tand the tid bad so they are not used until reconnected */\n\tcFYI(1, \"%s: marking sessions and tcons for reconnect\", __func__);\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each(tmp, &server->smb_ses_list) {\n\t\tses = list_entry(tmp, struct cifsSesInfo, smb_ses_list);\n\t\tses->need_reconnect = true;\n\t\tses->ipc_tid = 0;\n\t\tlist_for_each(tmp2, &ses->tcon_list) {\n\t\t\ttcon = list_entry(tmp2, struct cifsTconInfo, tcon_list);\n\t\t\ttcon->need_reconnect = true;\n\t\t}\n\t}\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\t/* do not want to be sending data on a socket we are freeing */\n\tcFYI(1, \"%s: tearing down socket\", __func__);\n\tmutex_lock(&server->srv_mutex);\n\tif (server->ssocket) {\n\t\tcFYI(1, \"State: 0x%x Flags: 0x%lx\", server->ssocket->state,\n\t\t\tserver->ssocket->flags);\n\t\tkernel_sock_shutdown(server->ssocket, SHUT_WR);\n\t\tcFYI(1, \"Post shutdown state: 0x%x Flags: 0x%lx\",\n\t\t\tserver->ssocket->state,\n\t\t\tserver->ssocket->flags);\n\t\tsock_release(server->ssocket);\n\t\tserver->ssocket = NULL;\n\t}\n\tserver->sequence_number = 0;\n\tserver->session_estab = false;\n\tkfree(server->session_key.response);\n\tserver->session_key.response = NULL;\n\tserver->session_key.len = 0;\n\tserver->lstrp = jiffies;\n\tmutex_unlock(&server->srv_mutex);\n\n\t/* mark submitted MIDs for retry and issue callback */\n\tcFYI(1, \"%s: issuing mid callbacks\", __func__);\n\tspin_lock(&GlobalMid_Lock);\n\tlist_for_each_safe(tmp, tmp2, &server->pending_mid_q) {\n\t\tmid_entry = list_entry(tmp, struct mid_q_entry, qhead);\n\t\tif (mid_entry->midState == MID_REQUEST_SUBMITTED)\n\t\t\tmid_entry->midState = MID_RETRY_NEEDED;\n\t\tlist_del_init(&mid_entry->qhead);\n\t\tmid_entry->callback(mid_entry);\n\t}\n\tspin_unlock(&GlobalMid_Lock);\n\n\twhile ((server->tcpStatus != CifsExiting) &&\n\t       (server->tcpStatus != CifsGood)) {\n\t\ttry_to_freeze();\n\n\t\t/* we should try only the port we connected to before */\n\t\trc = generic_ip_connect(server);\n\t\tif (rc) {\n\t\t\tcFYI(1, \"reconnect error %d\", rc);\n\t\t\tmsleep(3000);\n\t\t} else {\n\t\t\tatomic_inc(&tcpSesReconnectCount);\n\t\t\tspin_lock(&GlobalMid_Lock);\n\t\t\tif (server->tcpStatus != CifsExiting)\n\t\t\t\tserver->tcpStatus = CifsGood;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t}\n\t}\n\n\treturn rc;\n}\n\n/*\n\treturn codes:\n\t\t0 \tnot a transact2, or all data present\n\t\t>0 \ttransact2 with that much data missing\n\t\t-EINVAL = invalid transact2\n\n */\nstatic int check2ndT2(struct smb_hdr *pSMB, unsigned int maxBufSize)\n{\n\tstruct smb_t2_rsp *pSMBt;\n\tint remaining;\n\t__u16 total_data_size, data_in_this_rsp;\n\n\tif (pSMB->Command != SMB_COM_TRANSACTION2)\n\t\treturn 0;\n\n\t/* check for plausible wct, bcc and t2 data and parm sizes */\n\t/* check for parm and data offset going beyond end of smb */\n\tif (pSMB->WordCount != 10) { /* coalesce_t2 depends on this */\n\t\tcFYI(1, \"invalid transact2 word count\");\n\t\treturn -EINVAL;\n\t}\n\n\tpSMBt = (struct smb_t2_rsp *)pSMB;\n\n\ttotal_data_size = get_unaligned_le16(&pSMBt->t2_rsp.TotalDataCount);\n\tdata_in_this_rsp = get_unaligned_le16(&pSMBt->t2_rsp.DataCount);\n\n\tremaining = total_data_size - data_in_this_rsp;\n\n\tif (remaining == 0)\n\t\treturn 0;\n\telse if (remaining < 0) {\n\t\tcFYI(1, \"total data %d smaller than data in frame %d\",\n\t\t\ttotal_data_size, data_in_this_rsp);\n\t\treturn -EINVAL;\n\t} else {\n\t\tcFYI(1, \"missing %d bytes from transact2, check next response\",\n\t\t\tremaining);\n\t\tif (total_data_size > maxBufSize) {\n\t\t\tcERROR(1, \"TotalDataSize %d is over maximum buffer %d\",\n\t\t\t\ttotal_data_size, maxBufSize);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn remaining;\n\t}\n}\n\nstatic int coalesce_t2(struct smb_hdr *psecond, struct smb_hdr *pTargetSMB)\n{\n\tstruct smb_t2_rsp *pSMB2 = (struct smb_t2_rsp *)psecond;\n\tstruct smb_t2_rsp *pSMBt  = (struct smb_t2_rsp *)pTargetSMB;\n\tchar *data_area_of_target;\n\tchar *data_area_of_buf2;\n\tint remaining;\n\t__u16 byte_count, total_data_size, total_in_buf, total_in_buf2;\n\n\ttotal_data_size = get_unaligned_le16(&pSMBt->t2_rsp.TotalDataCount);\n\n\tif (total_data_size !=\n\t    get_unaligned_le16(&pSMB2->t2_rsp.TotalDataCount))\n\t\tcFYI(1, \"total data size of primary and secondary t2 differ\");\n\n\ttotal_in_buf = get_unaligned_le16(&pSMBt->t2_rsp.DataCount);\n\n\tremaining = total_data_size - total_in_buf;\n\n\tif (remaining < 0)\n\t\treturn -EINVAL;\n\n\tif (remaining == 0) /* nothing to do, ignore */\n\t\treturn 0;\n\n\ttotal_in_buf2 = get_unaligned_le16(&pSMB2->t2_rsp.DataCount);\n\tif (remaining < total_in_buf2) {\n\t\tcFYI(1, \"transact2 2nd response contains too much data\");\n\t}\n\n\t/* find end of first SMB data area */\n\tdata_area_of_target = (char *)&pSMBt->hdr.Protocol +\n\t\t\t\tget_unaligned_le16(&pSMBt->t2_rsp.DataOffset);\n\t/* validate target area */\n\n\tdata_area_of_buf2 = (char *)&pSMB2->hdr.Protocol +\n\t\t\t\tget_unaligned_le16(&pSMB2->t2_rsp.DataOffset);\n\n\tdata_area_of_target += total_in_buf;\n\n\t/* copy second buffer into end of first buffer */\n\tmemcpy(data_area_of_target, data_area_of_buf2, total_in_buf2);\n\ttotal_in_buf += total_in_buf2;\n\tput_unaligned_le16(total_in_buf, &pSMBt->t2_rsp.DataCount);\n\tbyte_count = get_bcc_le(pTargetSMB);\n\tbyte_count += total_in_buf2;\n\tput_bcc_le(byte_count, pTargetSMB);\n\n\tbyte_count = pTargetSMB->smb_buf_length;\n\tbyte_count += total_in_buf2;\n\n\t/* BB also add check that we are not beyond maximum buffer size */\n\n\tpTargetSMB->smb_buf_length = byte_count;\n\n\tif (remaining == total_in_buf2) {\n\t\tcFYI(1, \"found the last secondary response\");\n\t\treturn 0; /* we are done */\n\t} else /* more responses to go */\n\t\treturn 1;\n}\n\nstatic void\ncifs_echo_request(struct work_struct *work)\n{\n\tint rc;\n\tstruct TCP_Server_Info *server = container_of(work,\n\t\t\t\t\tstruct TCP_Server_Info, echo.work);\n\n\t/*\n\t * We cannot send an echo until the NEGOTIATE_PROTOCOL request is\n\t * done, which is indicated by maxBuf != 0. Also, no need to ping if\n\t * we got a response recently\n\t */\n\tif (server->maxBuf == 0 ||\n\t    time_before(jiffies, server->lstrp + SMB_ECHO_INTERVAL - HZ))\n\t\tgoto requeue_echo;\n\n\trc = CIFSSMBEcho(server);\n\tif (rc)\n\t\tcFYI(1, \"Unable to send echo request to server: %s\",\n\t\t\tserver->hostname);\n\nrequeue_echo:\n\tqueue_delayed_work(system_nrt_wq, &server->echo, SMB_ECHO_INTERVAL);\n}\n\nstatic int\ncifs_demultiplex_thread(struct TCP_Server_Info *server)\n{\n\tint length;\n\tunsigned int pdu_length, total_read;\n\tstruct smb_hdr *smb_buffer = NULL;\n\tstruct smb_hdr *bigbuf = NULL;\n\tstruct smb_hdr *smallbuf = NULL;\n\tstruct msghdr smb_msg;\n\tstruct kvec iov;\n\tstruct socket *csocket = server->ssocket;\n\tstruct list_head *tmp, *tmp2;\n\tstruct task_struct *task_to_wake = NULL;\n\tstruct mid_q_entry *mid_entry;\n\tchar temp;\n\tbool isLargeBuf = false;\n\tbool isMultiRsp;\n\tint reconnect;\n\n\tcurrent->flags |= PF_MEMALLOC;\n\tcFYI(1, \"Demultiplex PID: %d\", task_pid_nr(current));\n\n\tlength = atomic_inc_return(&tcpSesAllocCount);\n\tif (length > 1)\n\t\tmempool_resize(cifs_req_poolp, length + cifs_min_rcv,\n\t\t\t\tGFP_KERNEL);\n\n\tset_freezable();\n\twhile (server->tcpStatus != CifsExiting) {\n\t\tif (try_to_freeze())\n\t\t\tcontinue;\n\t\tif (bigbuf == NULL) {\n\t\t\tbigbuf = cifs_buf_get();\n\t\t\tif (!bigbuf) {\n\t\t\t\tcERROR(1, \"No memory for large SMB response\");\n\t\t\t\tmsleep(3000);\n\t\t\t\t/* retry will check if exiting */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else if (isLargeBuf) {\n\t\t\t/* we are reusing a dirty large buf, clear its start */\n\t\t\tmemset(bigbuf, 0, sizeof(struct smb_hdr));\n\t\t}\n\n\t\tif (smallbuf == NULL) {\n\t\t\tsmallbuf = cifs_small_buf_get();\n\t\t\tif (!smallbuf) {\n\t\t\t\tcERROR(1, \"No memory for SMB response\");\n\t\t\t\tmsleep(1000);\n\t\t\t\t/* retry will check if exiting */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* beginning of smb buffer is cleared in our buf_get */\n\t\t} else /* if existing small buf clear beginning */\n\t\t\tmemset(smallbuf, 0, sizeof(struct smb_hdr));\n\n\t\tisLargeBuf = false;\n\t\tisMultiRsp = false;\n\t\tsmb_buffer = smallbuf;\n\t\tiov.iov_base = smb_buffer;\n\t\tiov.iov_len = 4;\n\t\tsmb_msg.msg_control = NULL;\n\t\tsmb_msg.msg_controllen = 0;\n\t\tpdu_length = 4; /* enough to get RFC1001 header */\n\nincomplete_rcv:\n\t\tif (echo_retries > 0 &&\n\t\t    time_after(jiffies, server->lstrp +\n\t\t\t\t\t(echo_retries * SMB_ECHO_INTERVAL))) {\n\t\t\tcERROR(1, \"Server %s has not responded in %d seconds. \"\n\t\t\t\t  \"Reconnecting...\", server->hostname,\n\t\t\t\t  (echo_retries * SMB_ECHO_INTERVAL / HZ));\n\t\t\tcifs_reconnect(server);\n\t\t\tcsocket = server->ssocket;\n\t\t\twake_up(&server->response_q);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlength =\n\t\t    kernel_recvmsg(csocket, &smb_msg,\n\t\t\t\t&iov, 1, pdu_length, 0 /* BB other flags? */);\n\n\t\tif (server->tcpStatus == CifsExiting) {\n\t\t\tbreak;\n\t\t} else if (server->tcpStatus == CifsNeedReconnect) {\n\t\t\tcFYI(1, \"Reconnect after server stopped responding\");\n\t\t\tcifs_reconnect(server);\n\t\t\tcFYI(1, \"call to reconnect done\");\n\t\t\tcsocket = server->ssocket;\n\t\t\tcontinue;\n\t\t} else if (length == -ERESTARTSYS ||\n\t\t\t   length == -EAGAIN ||\n\t\t\t   length == -EINTR) {\n\t\t\tmsleep(1); /* minimum sleep to prevent looping\n\t\t\t\tallowing socket to clear and app threads to set\n\t\t\t\ttcpStatus CifsNeedReconnect if server hung */\n\t\t\tif (pdu_length < 4) {\n\t\t\t\tiov.iov_base = (4 - pdu_length) +\n\t\t\t\t\t\t\t(char *)smb_buffer;\n\t\t\t\tiov.iov_len = pdu_length;\n\t\t\t\tsmb_msg.msg_control = NULL;\n\t\t\t\tsmb_msg.msg_controllen = 0;\n\t\t\t\tgoto incomplete_rcv;\n\t\t\t} else\n\t\t\t\tcontinue;\n\t\t} else if (length <= 0) {\n\t\t\tcFYI(1, \"Reconnect after unexpected peek error %d\",\n\t\t\t\tlength);\n\t\t\tcifs_reconnect(server);\n\t\t\tcsocket = server->ssocket;\n\t\t\twake_up(&server->response_q);\n\t\t\tcontinue;\n\t\t} else if (length < pdu_length) {\n\t\t\tcFYI(1, \"requested %d bytes but only got %d bytes\",\n\t\t\t\t  pdu_length, length);\n\t\t\tpdu_length -= length;\n\t\t\tmsleep(1);\n\t\t\tgoto incomplete_rcv;\n\t\t}\n\n\t\t/* The right amount was read from socket - 4 bytes */\n\t\t/* so we can now interpret the length field */\n\n\t\t/* the first byte big endian of the length field,\n\t\tis actually not part of the length but the type\n\t\twith the most common, zero, as regular data */\n\t\ttemp = *((char *) smb_buffer);\n\n\t\t/* Note that FC 1001 length is big endian on the wire,\n\t\tbut we convert it here so it is always manipulated\n\t\tas host byte order */\n\t\tpdu_length = be32_to_cpu((__force __be32)smb_buffer->smb_buf_length);\n\t\tsmb_buffer->smb_buf_length = pdu_length;\n\n\t\tcFYI(1, \"rfc1002 length 0x%x\", pdu_length+4);\n\n\t\tif (temp == (char) RFC1002_SESSION_KEEP_ALIVE) {\n\t\t\tcontinue;\n\t\t} else if (temp == (char)RFC1002_POSITIVE_SESSION_RESPONSE) {\n\t\t\tcFYI(1, \"Good RFC 1002 session rsp\");\n\t\t\tcontinue;\n\t\t} else if (temp == (char)RFC1002_NEGATIVE_SESSION_RESPONSE) {\n\t\t\t/* we get this from Windows 98 instead of\n\t\t\t   an error on SMB negprot response */\n\t\t\tcFYI(1, \"Negative RFC1002 Session Response Error 0x%x)\",\n\t\t\t\tpdu_length);\n\t\t\t/* give server a second to clean up  */\n\t\t\tmsleep(1000);\n\t\t\t/* always try 445 first on reconnect since we get NACK\n\t\t\t * on some if we ever connected to port 139 (the NACK\n\t\t\t * is since we do not begin with RFC1001 session\n\t\t\t * initialize frame)\n\t\t\t */\n\t\t\tcifs_set_port((struct sockaddr *)\n\t\t\t\t\t&server->dstaddr, CIFS_PORT);\n\t\t\tcifs_reconnect(server);\n\t\t\tcsocket = server->ssocket;\n\t\t\twake_up(&server->response_q);\n\t\t\tcontinue;\n\t\t} else if (temp != (char) 0) {\n\t\t\tcERROR(1, \"Unknown RFC 1002 frame\");\n\t\t\tcifs_dump_mem(\" Received Data: \", (char *)smb_buffer,\n\t\t\t\t      length);\n\t\t\tcifs_reconnect(server);\n\t\t\tcsocket = server->ssocket;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* else we have an SMB response */\n\t\tif ((pdu_length > CIFSMaxBufSize + MAX_CIFS_HDR_SIZE - 4) ||\n\t\t\t    (pdu_length < sizeof(struct smb_hdr) - 1 - 4)) {\n\t\t\tcERROR(1, \"Invalid size SMB length %d pdu_length %d\",\n\t\t\t\t\tlength, pdu_length+4);\n\t\t\tcifs_reconnect(server);\n\t\t\tcsocket = server->ssocket;\n\t\t\twake_up(&server->response_q);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* else length ok */\n\t\treconnect = 0;\n\n\t\tif (pdu_length > MAX_CIFS_SMALL_BUFFER_SIZE - 4) {\n\t\t\tisLargeBuf = true;\n\t\t\tmemcpy(bigbuf, smallbuf, 4);\n\t\t\tsmb_buffer = bigbuf;\n\t\t}\n\t\tlength = 0;\n\t\tiov.iov_base = 4 + (char *)smb_buffer;\n\t\tiov.iov_len = pdu_length;\n\t\tfor (total_read = 0; total_read < pdu_length;\n\t\t     total_read += length) {\n\t\t\tlength = kernel_recvmsg(csocket, &smb_msg, &iov, 1,\n\t\t\t\t\t\tpdu_length - total_read, 0);\n\t\t\tif (server->tcpStatus == CifsExiting) {\n\t\t\t\t/* then will exit */\n\t\t\t\treconnect = 2;\n\t\t\t\tbreak;\n\t\t\t} else if (server->tcpStatus == CifsNeedReconnect) {\n\t\t\t\tcifs_reconnect(server);\n\t\t\t\tcsocket = server->ssocket;\n\t\t\t\t/* Reconnect wakes up rspns q */\n\t\t\t\t/* Now we will reread sock */\n\t\t\t\treconnect = 1;\n\t\t\t\tbreak;\n\t\t\t} else if (length == -ERESTARTSYS ||\n\t\t\t\t   length == -EAGAIN ||\n\t\t\t\t   length == -EINTR) {\n\t\t\t\tmsleep(1); /* minimum sleep to prevent looping,\n\t\t\t\t\t      allowing socket to clear and app\n\t\t\t\t\t      threads to set tcpStatus\n\t\t\t\t\t      CifsNeedReconnect if server hung*/\n\t\t\t\tlength = 0;\n\t\t\t\tcontinue;\n\t\t\t} else if (length <= 0) {\n\t\t\t\tcERROR(1, \"Received no data, expecting %d\",\n\t\t\t\t\t      pdu_length - total_read);\n\t\t\t\tcifs_reconnect(server);\n\t\t\t\tcsocket = server->ssocket;\n\t\t\t\treconnect = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (reconnect == 2)\n\t\t\tbreak;\n\t\telse if (reconnect == 1)\n\t\t\tcontinue;\n\n\t\ttotal_read += 4; /* account for rfc1002 hdr */\n\n\t\tdump_smb(smb_buffer, total_read);\n\n\t\t/*\n\t\t * We know that we received enough to get to the MID as we\n\t\t * checked the pdu_length earlier. Now check to see\n\t\t * if the rest of the header is OK. We borrow the length\n\t\t * var for the rest of the loop to avoid a new stack var.\n\t\t *\n\t\t * 48 bytes is enough to display the header and a little bit\n\t\t * into the payload for debugging purposes.\n\t\t */\n\t\tlength = checkSMB(smb_buffer, smb_buffer->Mid, total_read);\n\t\tif (length != 0)\n\t\t\tcifs_dump_mem(\"Bad SMB: \", smb_buffer,\n\t\t\t\t\tmin_t(unsigned int, total_read, 48));\n\n\t\tmid_entry = NULL;\n\t\tserver->lstrp = jiffies;\n\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tlist_for_each_safe(tmp, tmp2, &server->pending_mid_q) {\n\t\t\tmid_entry = list_entry(tmp, struct mid_q_entry, qhead);\n\n\t\t\tif ((mid_entry->mid == smb_buffer->Mid) &&\n\t\t\t    (mid_entry->midState == MID_REQUEST_SUBMITTED) &&\n\t\t\t    (mid_entry->command == smb_buffer->Command)) {\n\t\t\t\tif (length == 0 &&\n\t\t\t\t   check2ndT2(smb_buffer, server->maxBuf) > 0) {\n\t\t\t\t\t/* We have a multipart transact2 resp */\n\t\t\t\t\tisMultiRsp = true;\n\t\t\t\t\tif (mid_entry->resp_buf) {\n\t\t\t\t\t\t/* merge response - fix up 1st*/\n\t\t\t\t\t\tif (coalesce_t2(smb_buffer,\n\t\t\t\t\t\t\tmid_entry->resp_buf)) {\n\t\t\t\t\t\t\tmid_entry->multiRsp =\n\t\t\t\t\t\t\t\t true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t/* all parts received */\n\t\t\t\t\t\t\tmid_entry->multiEnd =\n\t\t\t\t\t\t\t\t true;\n\t\t\t\t\t\t\tgoto multi_t2_fnd;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!isLargeBuf) {\n\t\t\t\t\t\t\tcERROR(1, \"1st trans2 resp needs bigbuf\");\n\t\t\t\t\t/* BB maybe we can fix this up,  switch\n\t\t\t\t\t   to already allocated large buffer? */\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t/* Have first buffer */\n\t\t\t\t\t\t\tmid_entry->resp_buf =\n\t\t\t\t\t\t\t\t smb_buffer;\n\t\t\t\t\t\t\tmid_entry->largeBuf =\n\t\t\t\t\t\t\t\t true;\n\t\t\t\t\t\t\tbigbuf = NULL;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tmid_entry->resp_buf = smb_buffer;\n\t\t\t\tmid_entry->largeBuf = isLargeBuf;\nmulti_t2_fnd:\n\t\t\t\tif (length == 0)\n\t\t\t\t\tmid_entry->midState =\n\t\t\t\t\t\t\tMID_RESPONSE_RECEIVED;\n\t\t\t\telse\n\t\t\t\t\tmid_entry->midState =\n\t\t\t\t\t\t\tMID_RESPONSE_MALFORMED;\n#ifdef CONFIG_CIFS_STATS2\n\t\t\t\tmid_entry->when_received = jiffies;\n#endif\n\t\t\t\tlist_del_init(&mid_entry->qhead);\n\t\t\t\tmid_entry->callback(mid_entry);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmid_entry = NULL;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\n\t\tif (mid_entry != NULL) {\n\t\t\t/* Was previous buf put in mpx struct for multi-rsp? */\n\t\t\tif (!isMultiRsp) {\n\t\t\t\t/* smb buffer will be freed by user thread */\n\t\t\t\tif (isLargeBuf)\n\t\t\t\t\tbigbuf = NULL;\n\t\t\t\telse\n\t\t\t\t\tsmallbuf = NULL;\n\t\t\t}\n\t\t} else if (length != 0) {\n\t\t\t/* response sanity checks failed */\n\t\t\tcontinue;\n\t\t} else if (!is_valid_oplock_break(smb_buffer, server) &&\n\t\t\t   !isMultiRsp) {\n\t\t\tcERROR(1, \"No task to wake, unknown frame received! \"\n\t\t\t\t   \"NumMids %d\", atomic_read(&midCount));\n\t\t\tcifs_dump_mem(\"Received Data is: \", (char *)smb_buffer,\n\t\t\t\t      sizeof(struct smb_hdr));\n#ifdef CONFIG_CIFS_DEBUG2\n\t\t\tcifs_dump_detail(smb_buffer);\n\t\t\tcifs_dump_mids(server);\n#endif /* CIFS_DEBUG2 */\n\n\t\t}\n\t} /* end while !EXITING */\n\n\t/* take it off the list, if it's not already */\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_del_init(&server->tcp_ses_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tspin_lock(&GlobalMid_Lock);\n\tserver->tcpStatus = CifsExiting;\n\tspin_unlock(&GlobalMid_Lock);\n\twake_up_all(&server->response_q);\n\n\t/* check if we have blocked requests that need to free */\n\t/* Note that cifs_max_pending is normally 50, but\n\tcan be set at module install time to as little as two */\n\tspin_lock(&GlobalMid_Lock);\n\tif (atomic_read(&server->inFlight) >= cifs_max_pending)\n\t\tatomic_set(&server->inFlight, cifs_max_pending - 1);\n\t/* We do not want to set the max_pending too low or we\n\tcould end up with the counter going negative */\n\tspin_unlock(&GlobalMid_Lock);\n\t/* Although there should not be any requests blocked on\n\tthis queue it can not hurt to be paranoid and try to wake up requests\n\tthat may haven been blocked when more than 50 at time were on the wire\n\tto the same server - they now will see the session is in exit state\n\tand get out of SendReceive.  */\n\twake_up_all(&server->request_q);\n\t/* give those requests time to exit */\n\tmsleep(125);\n\n\tif (server->ssocket) {\n\t\tsock_release(csocket);\n\t\tserver->ssocket = NULL;\n\t}\n\t/* buffer usuallly freed in free_mid - need to free it here on exit */\n\tcifs_buf_release(bigbuf);\n\tif (smallbuf) /* no sense logging a debug message if NULL */\n\t\tcifs_small_buf_release(smallbuf);\n\n\tif (!list_empty(&server->pending_mid_q)) {\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tlist_for_each_safe(tmp, tmp2, &server->pending_mid_q) {\n\t\t\tmid_entry = list_entry(tmp, struct mid_q_entry, qhead);\n\t\t\tcFYI(1, \"Clearing Mid 0x%x - issuing callback\",\n\t\t\t\t\t mid_entry->mid);\n\t\t\tlist_del_init(&mid_entry->qhead);\n\t\t\tmid_entry->callback(mid_entry);\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t\t/* 1/8th of sec is more than enough time for them to exit */\n\t\tmsleep(125);\n\t}\n\n\tif (!list_empty(&server->pending_mid_q)) {\n\t\t/* mpx threads have not exited yet give them\n\t\tat least the smb send timeout time for long ops */\n\t\t/* due to delays on oplock break requests, we need\n\t\tto wait at least 45 seconds before giving up\n\t\ton a request getting a response and going ahead\n\t\tand killing cifsd */\n\t\tcFYI(1, \"Wait for exit from demultiplex thread\");\n\t\tmsleep(46000);\n\t\t/* if threads still have not exited they are probably never\n\t\tcoming home not much else we can do but free the memory */\n\t}\n\n\tkfree(server->hostname);\n\ttask_to_wake = xchg(&server->tsk, NULL);\n\tkfree(server);\n\n\tlength = atomic_dec_return(&tcpSesAllocCount);\n\tif (length  > 0)\n\t\tmempool_resize(cifs_req_poolp, length + cifs_min_rcv,\n\t\t\t\tGFP_KERNEL);\n\n\t/* if server->tsk was NULL then wait for a signal before exiting */\n\tif (!task_to_wake) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\twhile (!signal_pending(current)) {\n\t\t\tschedule();\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t}\n\t\tset_current_state(TASK_RUNNING);\n\t}\n\n\tmodule_put_and_exit(0);\n}\n\n/* extract the host portion of the UNC string */\nstatic char *\nextract_hostname(const char *unc)\n{\n\tconst char *src;\n\tchar *dst, *delim;\n\tunsigned int len;\n\n\t/* skip double chars at beginning of string */\n\t/* BB: check validity of these bytes? */\n\tsrc = unc + 2;\n\n\t/* delimiter between hostname and sharename is always '\\\\' now */\n\tdelim = strchr(src, '\\\\');\n\tif (!delim)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tlen = delim - src;\n\tdst = kmalloc((len + 1), GFP_KERNEL);\n\tif (dst == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmemcpy(dst, src, len);\n\tdst[len] = '\\0';\n\n\treturn dst;\n}\n\nstatic int\ncifs_parse_mount_options(char *options, const char *devname,\n\t\t\t struct smb_vol *vol)\n{\n\tchar *value;\n\tchar *data;\n\tunsigned int  temp_len, i, j;\n\tchar separator[2];\n\tshort int override_uid = -1;\n\tshort int override_gid = -1;\n\tbool uid_specified = false;\n\tbool gid_specified = false;\n\tchar *nodename = utsname()->nodename;\n\n\tseparator[0] = ',';\n\tseparator[1] = 0;\n\n\t/*\n\t * does not have to be perfect mapping since field is\n\t * informational, only used for servers that do not support\n\t * port 445 and it can be overridden at mount time\n\t */\n\tmemset(vol->source_rfc1001_name, 0x20, RFC1001_NAME_LEN);\n\tfor (i = 0; i < strnlen(nodename, RFC1001_NAME_LEN); i++)\n\t\tvol->source_rfc1001_name[i] = toupper(nodename[i]);\n\n\tvol->source_rfc1001_name[RFC1001_NAME_LEN] = 0;\n\t/* null target name indicates to use *SMBSERVR default called name\n\t   if we end up sending RFC1001 session initialize */\n\tvol->target_rfc1001_name[0] = 0;\n\tvol->cred_uid = current_uid();\n\tvol->linux_uid = current_uid();\n\tvol->linux_gid = current_gid();\n\n\t/* default to only allowing write access to owner of the mount */\n\tvol->dir_mode = vol->file_mode = S_IRUGO | S_IXUGO | S_IWUSR;\n\n\t/* vol->retry default is 0 (i.e. \"soft\" limited retry not hard retry) */\n\t/* default is always to request posix paths. */\n\tvol->posix_paths = 1;\n\t/* default to using server inode numbers where available */\n\tvol->server_ino = 1;\n\n\tvol->actimeo = CIFS_DEF_ACTIMEO;\n\n\tif (!options)\n\t\treturn 1;\n\n\tif (strncmp(options, \"sep=\", 4) == 0) {\n\t\tif (options[4] != 0) {\n\t\t\tseparator[0] = options[4];\n\t\t\toptions += 5;\n\t\t} else {\n\t\t\tcFYI(1, \"Null separator not allowed\");\n\t\t}\n\t}\n\n\twhile ((data = strsep(&options, separator)) != NULL) {\n\t\tif (!*data)\n\t\t\tcontinue;\n\t\tif ((value = strchr(data, '=')) != NULL)\n\t\t\t*value++ = '\\0';\n\n\t\t/* Have to parse this before we parse for \"user\" */\n\t\tif (strnicmp(data, \"user_xattr\", 10) == 0) {\n\t\t\tvol->no_xattr = 0;\n\t\t} else if (strnicmp(data, \"nouser_xattr\", 12) == 0) {\n\t\t\tvol->no_xattr = 1;\n\t\t} else if (strnicmp(data, \"user\", 4) == 0) {\n\t\t\tif (!value) {\n\t\t\t\tprintk(KERN_WARNING\n\t\t\t\t       \"CIFS: invalid or missing username\\n\");\n\t\t\t\treturn 1;\t/* needs_arg; */\n\t\t\t} else if (!*value) {\n\t\t\t\t/* null user, ie anonymous, authentication */\n\t\t\t\tvol->nullauth = 1;\n\t\t\t}\n\t\t\tif (strnlen(value, MAX_USERNAME_SIZE) <\n\t\t\t\t\t\tMAX_USERNAME_SIZE) {\n\t\t\t\tvol->username = value;\n\t\t\t} else {\n\t\t\t\tprintk(KERN_WARNING \"CIFS: username too long\\n\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t} else if (strnicmp(data, \"pass\", 4) == 0) {\n\t\t\tif (!value) {\n\t\t\t\tvol->password = NULL;\n\t\t\t\tcontinue;\n\t\t\t} else if (value[0] == 0) {\n\t\t\t\t/* check if string begins with double comma\n\t\t\t\t   since that would mean the password really\n\t\t\t\t   does start with a comma, and would not\n\t\t\t\t   indicate an empty string */\n\t\t\t\tif (value[1] != separator[0]) {\n\t\t\t\t\tvol->password = NULL;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttemp_len = strlen(value);\n\t\t\t/* removed password length check, NTLM passwords\n\t\t\t\tcan be arbitrarily long */\n\n\t\t\t/* if comma in password, the string will be\n\t\t\tprematurely null terminated.  Commas in password are\n\t\t\tspecified across the cifs mount interface by a double\n\t\t\tcomma ie ,, and a comma used as in other cases ie ','\n\t\t\tas a parameter delimiter/separator is single and due\n\t\t\tto the strsep above is temporarily zeroed. */\n\n\t\t\t/* NB: password legally can have multiple commas and\n\t\t\tthe only illegal character in a password is null */\n\n\t\t\tif ((value[temp_len] == 0) &&\n\t\t\t    (value[temp_len+1] == separator[0])) {\n\t\t\t\t/* reinsert comma */\n\t\t\t\tvalue[temp_len] = separator[0];\n\t\t\t\ttemp_len += 2;  /* move after second comma */\n\t\t\t\twhile (value[temp_len] != 0)  {\n\t\t\t\t\tif (value[temp_len] == separator[0]) {\n\t\t\t\t\t\tif (value[temp_len+1] ==\n\t\t\t\t\t\t     separator[0]) {\n\t\t\t\t\t\t/* skip second comma */\n\t\t\t\t\t\t\ttemp_len++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t/* single comma indicating start\n\t\t\t\t\t\t\t of next parm */\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ttemp_len++;\n\t\t\t\t}\n\t\t\t\tif (value[temp_len] == 0) {\n\t\t\t\t\toptions = NULL;\n\t\t\t\t} else {\n\t\t\t\t\tvalue[temp_len] = 0;\n\t\t\t\t\t/* point option to start of next parm */\n\t\t\t\t\toptions = value + temp_len + 1;\n\t\t\t\t}\n\t\t\t\t/* go from value to value + temp_len condensing\n\t\t\t\tdouble commas to singles. Note that this ends up\n\t\t\t\tallocating a few bytes too many, which is ok */\n\t\t\t\tvol->password = kzalloc(temp_len, GFP_KERNEL);\n\t\t\t\tif (vol->password == NULL) {\n\t\t\t\t\tprintk(KERN_WARNING \"CIFS: no memory \"\n\t\t\t\t\t\t\t    \"for password\\n\");\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tfor (i = 0, j = 0; i < temp_len; i++, j++) {\n\t\t\t\t\tvol->password[j] = value[i];\n\t\t\t\t\tif (value[i] == separator[0]\n\t\t\t\t\t\t&& value[i+1] == separator[0]) {\n\t\t\t\t\t\t/* skip second comma */\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvol->password[j] = 0;\n\t\t\t} else {\n\t\t\t\tvol->password = kzalloc(temp_len+1, GFP_KERNEL);\n\t\t\t\tif (vol->password == NULL) {\n\t\t\t\t\tprintk(KERN_WARNING \"CIFS: no memory \"\n\t\t\t\t\t\t\t    \"for password\\n\");\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tstrcpy(vol->password, value);\n\t\t\t}\n\t\t} else if (!strnicmp(data, \"ip\", 2) ||\n\t\t\t   !strnicmp(data, \"addr\", 4)) {\n\t\t\tif (!value || !*value) {\n\t\t\t\tvol->UNCip = NULL;\n\t\t\t} else if (strnlen(value, INET6_ADDRSTRLEN) <\n\t\t\t\t\t\t\tINET6_ADDRSTRLEN) {\n\t\t\t\tvol->UNCip = value;\n\t\t\t} else {\n\t\t\t\tprintk(KERN_WARNING \"CIFS: ip address \"\n\t\t\t\t\t\t    \"too long\\n\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t} else if (strnicmp(data, \"sec\", 3) == 0) {\n\t\t\tif (!value || !*value) {\n\t\t\t\tcERROR(1, \"no security value specified\");\n\t\t\t\tcontinue;\n\t\t\t} else if (strnicmp(value, \"krb5i\", 5) == 0) {\n\t\t\t\tvol->secFlg |= CIFSSEC_MAY_KRB5 |\n\t\t\t\t\tCIFSSEC_MUST_SIGN;\n\t\t\t} else if (strnicmp(value, \"krb5p\", 5) == 0) {\n\t\t\t\t/* vol->secFlg |= CIFSSEC_MUST_SEAL |\n\t\t\t\t\tCIFSSEC_MAY_KRB5; */\n\t\t\t\tcERROR(1, \"Krb5 cifs privacy not supported\");\n\t\t\t\treturn 1;\n\t\t\t} else if (strnicmp(value, \"krb5\", 4) == 0) {\n\t\t\t\tvol->secFlg |= CIFSSEC_MAY_KRB5;\n\t\t\t} else if (strnicmp(value, \"ntlmsspi\", 8) == 0) {\n\t\t\t\tvol->secFlg |= CIFSSEC_MAY_NTLMSSP |\n\t\t\t\t\tCIFSSEC_MUST_SIGN;\n\t\t\t} else if (strnicmp(value, \"ntlmssp\", 7) == 0) {\n\t\t\t\tvol->secFlg |= CIFSSEC_MAY_NTLMSSP;\n\t\t\t} else if (strnicmp(value, \"ntlmv2i\", 7) == 0) {\n\t\t\t\tvol->secFlg |= CIFSSEC_MAY_NTLMV2 |\n\t\t\t\t\tCIFSSEC_MUST_SIGN;\n\t\t\t} else if (strnicmp(value, \"ntlmv2\", 6) == 0) {\n\t\t\t\tvol->secFlg |= CIFSSEC_MAY_NTLMV2;\n\t\t\t} else if (strnicmp(value, \"ntlmi\", 5) == 0) {\n\t\t\t\tvol->secFlg |= CIFSSEC_MAY_NTLM |\n\t\t\t\t\tCIFSSEC_MUST_SIGN;\n\t\t\t} else if (strnicmp(value, \"ntlm\", 4) == 0) {\n\t\t\t\t/* ntlm is default so can be turned off too */\n\t\t\t\tvol->secFlg |= CIFSSEC_MAY_NTLM;\n\t\t\t} else if (strnicmp(value, \"nontlm\", 6) == 0) {\n\t\t\t\t/* BB is there a better way to do this? */\n\t\t\t\tvol->secFlg |= CIFSSEC_MAY_NTLMV2;\n#ifdef CONFIG_CIFS_WEAK_PW_HASH\n\t\t\t} else if (strnicmp(value, \"lanman\", 6) == 0) {\n\t\t\t\tvol->secFlg |= CIFSSEC_MAY_LANMAN;\n#endif\n\t\t\t} else if (strnicmp(value, \"none\", 4) == 0) {\n\t\t\t\tvol->nullauth = 1;\n\t\t\t} else {\n\t\t\t\tcERROR(1, \"bad security option: %s\", value);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t} else if ((strnicmp(data, \"unc\", 3) == 0)\n\t\t\t   || (strnicmp(data, \"target\", 6) == 0)\n\t\t\t   || (strnicmp(data, \"path\", 4) == 0)) {\n\t\t\tif (!value || !*value) {\n\t\t\t\tprintk(KERN_WARNING \"CIFS: invalid path to \"\n\t\t\t\t\t\t    \"network resource\\n\");\n\t\t\t\treturn 1;\t/* needs_arg; */\n\t\t\t}\n\t\t\tif ((temp_len = strnlen(value, 300)) < 300) {\n\t\t\t\tvol->UNC = kmalloc(temp_len+1, GFP_KERNEL);\n\t\t\t\tif (vol->UNC == NULL)\n\t\t\t\t\treturn 1;\n\t\t\t\tstrcpy(vol->UNC, value);\n\t\t\t\tif (strncmp(vol->UNC, \"//\", 2) == 0) {\n\t\t\t\t\tvol->UNC[0] = '\\\\';\n\t\t\t\t\tvol->UNC[1] = '\\\\';\n\t\t\t\t} else if (strncmp(vol->UNC, \"\\\\\\\\\", 2) != 0) {\n\t\t\t\t\tprintk(KERN_WARNING\n\t\t\t\t\t       \"CIFS: UNC Path does not begin \"\n\t\t\t\t\t       \"with // or \\\\\\\\ \\n\");\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tprintk(KERN_WARNING \"CIFS: UNC name too long\\n\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t} else if ((strnicmp(data, \"domain\", 3) == 0)\n\t\t\t   || (strnicmp(data, \"workgroup\", 5) == 0)) {\n\t\t\tif (!value || !*value) {\n\t\t\t\tprintk(KERN_WARNING \"CIFS: invalid domain name\\n\");\n\t\t\t\treturn 1;\t/* needs_arg; */\n\t\t\t}\n\t\t\t/* BB are there cases in which a comma can be valid in\n\t\t\ta domain name and need special handling? */\n\t\t\tif (strnlen(value, 256) < 256) {\n\t\t\t\tvol->domainname = value;\n\t\t\t\tcFYI(1, \"Domain name set\");\n\t\t\t} else {\n\t\t\t\tprintk(KERN_WARNING \"CIFS: domain name too \"\n\t\t\t\t\t\t    \"long\\n\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t} else if (strnicmp(data, \"srcaddr\", 7) == 0) {\n\t\t\tvol->srcaddr.ss_family = AF_UNSPEC;\n\n\t\t\tif (!value || !*value) {\n\t\t\t\tprintk(KERN_WARNING \"CIFS: srcaddr value\"\n\t\t\t\t       \" not specified.\\n\");\n\t\t\t\treturn 1;\t/* needs_arg; */\n\t\t\t}\n\t\t\ti = cifs_convert_address((struct sockaddr *)&vol->srcaddr,\n\t\t\t\t\t\t value, strlen(value));\n\t\t\tif (i == 0) {\n\t\t\t\tprintk(KERN_WARNING \"CIFS:  Could not parse\"\n\t\t\t\t       \" srcaddr: %s\\n\",\n\t\t\t\t       value);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t} else if (strnicmp(data, \"prefixpath\", 10) == 0) {\n\t\t\tif (!value || !*value) {\n\t\t\t\tprintk(KERN_WARNING\n\t\t\t\t\t\"CIFS: invalid path prefix\\n\");\n\t\t\t\treturn 1;       /* needs_argument */\n\t\t\t}\n\t\t\tif ((temp_len = strnlen(value, 1024)) < 1024) {\n\t\t\t\tif (value[0] != '/')\n\t\t\t\t\ttemp_len++;  /* missing leading slash */\n\t\t\t\tvol->prepath = kmalloc(temp_len+1, GFP_KERNEL);\n\t\t\t\tif (vol->prepath == NULL)\n\t\t\t\t\treturn 1;\n\t\t\t\tif (value[0] != '/') {\n\t\t\t\t\tvol->prepath[0] = '/';\n\t\t\t\t\tstrcpy(vol->prepath+1, value);\n\t\t\t\t} else\n\t\t\t\t\tstrcpy(vol->prepath, value);\n\t\t\t\tcFYI(1, \"prefix path %s\", vol->prepath);\n\t\t\t} else {\n\t\t\t\tprintk(KERN_WARNING \"CIFS: prefix too long\\n\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t} else if (strnicmp(data, \"iocharset\", 9) == 0) {\n\t\t\tif (!value || !*value) {\n\t\t\t\tprintk(KERN_WARNING \"CIFS: invalid iocharset \"\n\t\t\t\t\t\t    \"specified\\n\");\n\t\t\t\treturn 1;\t/* needs_arg; */\n\t\t\t}\n\t\t\tif (strnlen(value, 65) < 65) {\n\t\t\t\tif (strnicmp(value, \"default\", 7))\n\t\t\t\t\tvol->iocharset = value;\n\t\t\t\t/* if iocharset not set then load_nls_default\n\t\t\t\t   is used by caller */\n\t\t\t\tcFYI(1, \"iocharset set to %s\", value);\n\t\t\t} else {\n\t\t\t\tprintk(KERN_WARNING \"CIFS: iocharset name \"\n\t\t\t\t\t\t    \"too long.\\n\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t} else if (!strnicmp(data, \"uid\", 3) && value && *value) {\n\t\t\tvol->linux_uid = simple_strtoul(value, &value, 0);\n\t\t\tuid_specified = true;\n\t\t} else if (!strnicmp(data, \"cruid\", 5) && value && *value) {\n\t\t\tvol->cred_uid = simple_strtoul(value, &value, 0);\n\t\t} else if (!strnicmp(data, \"forceuid\", 8)) {\n\t\t\toverride_uid = 1;\n\t\t} else if (!strnicmp(data, \"noforceuid\", 10)) {\n\t\t\toverride_uid = 0;\n\t\t} else if (!strnicmp(data, \"gid\", 3) && value && *value) {\n\t\t\tvol->linux_gid = simple_strtoul(value, &value, 0);\n\t\t\tgid_specified = true;\n\t\t} else if (!strnicmp(data, \"forcegid\", 8)) {\n\t\t\toverride_gid = 1;\n\t\t} else if (!strnicmp(data, \"noforcegid\", 10)) {\n\t\t\toverride_gid = 0;\n\t\t} else if (strnicmp(data, \"file_mode\", 4) == 0) {\n\t\t\tif (value && *value) {\n\t\t\t\tvol->file_mode =\n\t\t\t\t\tsimple_strtoul(value, &value, 0);\n\t\t\t}\n\t\t} else if (strnicmp(data, \"dir_mode\", 4) == 0) {\n\t\t\tif (value && *value) {\n\t\t\t\tvol->dir_mode =\n\t\t\t\t\tsimple_strtoul(value, &value, 0);\n\t\t\t}\n\t\t} else if (strnicmp(data, \"dirmode\", 4) == 0) {\n\t\t\tif (value && *value) {\n\t\t\t\tvol->dir_mode =\n\t\t\t\t\tsimple_strtoul(value, &value, 0);\n\t\t\t}\n\t\t} else if (strnicmp(data, \"port\", 4) == 0) {\n\t\t\tif (value && *value) {\n\t\t\t\tvol->port =\n\t\t\t\t\tsimple_strtoul(value, &value, 0);\n\t\t\t}\n\t\t} else if (strnicmp(data, \"rsize\", 5) == 0) {\n\t\t\tif (value && *value) {\n\t\t\t\tvol->rsize =\n\t\t\t\t\tsimple_strtoul(value, &value, 0);\n\t\t\t}\n\t\t} else if (strnicmp(data, \"wsize\", 5) == 0) {\n\t\t\tif (value && *value) {\n\t\t\t\tvol->wsize =\n\t\t\t\t\tsimple_strtoul(value, &value, 0);\n\t\t\t}\n\t\t} else if (strnicmp(data, \"sockopt\", 5) == 0) {\n\t\t\tif (!value || !*value) {\n\t\t\t\tcERROR(1, \"no socket option specified\");\n\t\t\t\tcontinue;\n\t\t\t} else if (strnicmp(value, \"TCP_NODELAY\", 11) == 0) {\n\t\t\t\tvol->sockopt_tcp_nodelay = 1;\n\t\t\t}\n\t\t} else if (strnicmp(data, \"netbiosname\", 4) == 0) {\n\t\t\tif (!value || !*value || (*value == ' ')) {\n\t\t\t\tcFYI(1, \"invalid (empty) netbiosname\");\n\t\t\t} else {\n\t\t\t\tmemset(vol->source_rfc1001_name, 0x20,\n\t\t\t\t\tRFC1001_NAME_LEN);\n\t\t\t\t/*\n\t\t\t\t * FIXME: are there cases in which a comma can\n\t\t\t\t * be valid in workstation netbios name (and\n\t\t\t\t * need special handling)?\n\t\t\t\t */\n\t\t\t\tfor (i = 0; i < RFC1001_NAME_LEN; i++) {\n\t\t\t\t\t/* don't ucase netbiosname for user */\n\t\t\t\t\tif (value[i] == 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tvol->source_rfc1001_name[i] = value[i];\n\t\t\t\t}\n\t\t\t\t/* The string has 16th byte zero still from\n\t\t\t\tset at top of the function  */\n\t\t\t\tif (i == RFC1001_NAME_LEN && value[i] != 0)\n\t\t\t\t\tprintk(KERN_WARNING \"CIFS: netbiosname\"\n\t\t\t\t\t\t\" longer than 15 truncated.\\n\");\n\t\t\t}\n\t\t} else if (strnicmp(data, \"servern\", 7) == 0) {\n\t\t\t/* servernetbiosname specified override *SMBSERVER */\n\t\t\tif (!value || !*value || (*value == ' ')) {\n\t\t\t\tcFYI(1, \"empty server netbiosname specified\");\n\t\t\t} else {\n\t\t\t\t/* last byte, type, is 0x20 for servr type */\n\t\t\t\tmemset(vol->target_rfc1001_name, 0x20,\n\t\t\t\t\tRFC1001_NAME_LEN_WITH_NULL);\n\n\t\t\t\tfor (i = 0; i < 15; i++) {\n\t\t\t\t/* BB are there cases in which a comma can be\n\t\t\t\t   valid in this workstation netbios name\n\t\t\t\t   (and need special handling)? */\n\n\t\t\t\t/* user or mount helper must uppercase\n\t\t\t\t   the netbiosname */\n\t\t\t\t\tif (value[i] == 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\telse\n\t\t\t\t\t\tvol->target_rfc1001_name[i] =\n\t\t\t\t\t\t\t\tvalue[i];\n\t\t\t\t}\n\t\t\t\t/* The string has 16th byte zero still from\n\t\t\t\t   set at top of the function  */\n\t\t\t\tif (i == RFC1001_NAME_LEN && value[i] != 0)\n\t\t\t\t\tprintk(KERN_WARNING \"CIFS: server net\"\n\t\t\t\t\t\"biosname longer than 15 truncated.\\n\");\n\t\t\t}\n\t\t} else if (strnicmp(data, \"actimeo\", 7) == 0) {\n\t\t\tif (value && *value) {\n\t\t\t\tvol->actimeo = HZ * simple_strtoul(value,\n\t\t\t\t\t\t\t\t   &value, 0);\n\t\t\t\tif (vol->actimeo > CIFS_MAX_ACTIMEO) {\n\t\t\t\t\tcERROR(1, \"CIFS: attribute cache\"\n\t\t\t\t\t\t\t\"timeout too large\");\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (strnicmp(data, \"credentials\", 4) == 0) {\n\t\t\t/* ignore */\n\t\t} else if (strnicmp(data, \"version\", 3) == 0) {\n\t\t\t/* ignore */\n\t\t} else if (strnicmp(data, \"guest\", 5) == 0) {\n\t\t\t/* ignore */\n\t\t} else if (strnicmp(data, \"rw\", 2) == 0) {\n\t\t\t/* ignore */\n\t\t} else if (strnicmp(data, \"ro\", 2) == 0) {\n\t\t\t/* ignore */\n\t\t} else if (strnicmp(data, \"noblocksend\", 11) == 0) {\n\t\t\tvol->noblocksnd = 1;\n\t\t} else if (strnicmp(data, \"noautotune\", 10) == 0) {\n\t\t\tvol->noautotune = 1;\n\t\t} else if ((strnicmp(data, \"suid\", 4) == 0) ||\n\t\t\t\t   (strnicmp(data, \"nosuid\", 6) == 0) ||\n\t\t\t\t   (strnicmp(data, \"exec\", 4) == 0) ||\n\t\t\t\t   (strnicmp(data, \"noexec\", 6) == 0) ||\n\t\t\t\t   (strnicmp(data, \"nodev\", 5) == 0) ||\n\t\t\t\t   (strnicmp(data, \"noauto\", 6) == 0) ||\n\t\t\t\t   (strnicmp(data, \"dev\", 3) == 0)) {\n\t\t\t/*  The mount tool or mount.cifs helper (if present)\n\t\t\t    uses these opts to set flags, and the flags are read\n\t\t\t    by the kernel vfs layer before we get here (ie\n\t\t\t    before read super) so there is no point trying to\n\t\t\t    parse these options again and set anything and it\n\t\t\t    is ok to just ignore them */\n\t\t\tcontinue;\n\t\t} else if (strnicmp(data, \"hard\", 4) == 0) {\n\t\t\tvol->retry = 1;\n\t\t} else if (strnicmp(data, \"soft\", 4) == 0) {\n\t\t\tvol->retry = 0;\n\t\t} else if (strnicmp(data, \"perm\", 4) == 0) {\n\t\t\tvol->noperm = 0;\n\t\t} else if (strnicmp(data, \"noperm\", 6) == 0) {\n\t\t\tvol->noperm = 1;\n\t\t} else if (strnicmp(data, \"mapchars\", 8) == 0) {\n\t\t\tvol->remap = 1;\n\t\t} else if (strnicmp(data, \"nomapchars\", 10) == 0) {\n\t\t\tvol->remap = 0;\n\t\t} else if (strnicmp(data, \"sfu\", 3) == 0) {\n\t\t\tvol->sfu_emul = 1;\n\t\t} else if (strnicmp(data, \"nosfu\", 5) == 0) {\n\t\t\tvol->sfu_emul = 0;\n\t\t} else if (strnicmp(data, \"nodfs\", 5) == 0) {\n\t\t\tvol->nodfs = 1;\n\t\t} else if (strnicmp(data, \"posixpaths\", 10) == 0) {\n\t\t\tvol->posix_paths = 1;\n\t\t} else if (strnicmp(data, \"noposixpaths\", 12) == 0) {\n\t\t\tvol->posix_paths = 0;\n\t\t} else if (strnicmp(data, \"nounix\", 6) == 0) {\n\t\t\tvol->no_linux_ext = 1;\n\t\t} else if (strnicmp(data, \"nolinux\", 7) == 0) {\n\t\t\tvol->no_linux_ext = 1;\n\t\t} else if ((strnicmp(data, \"nocase\", 6) == 0) ||\n\t\t\t   (strnicmp(data, \"ignorecase\", 10)  == 0)) {\n\t\t\tvol->nocase = 1;\n\t\t} else if (strnicmp(data, \"mand\", 4) == 0) {\n\t\t\t/* ignore */\n\t\t} else if (strnicmp(data, \"nomand\", 6) == 0) {\n\t\t\t/* ignore */\n\t\t} else if (strnicmp(data, \"_netdev\", 7) == 0) {\n\t\t\t/* ignore */\n\t\t} else if (strnicmp(data, \"brl\", 3) == 0) {\n\t\t\tvol->nobrl =  0;\n\t\t} else if ((strnicmp(data, \"nobrl\", 5) == 0) ||\n\t\t\t   (strnicmp(data, \"nolock\", 6) == 0)) {\n\t\t\tvol->nobrl =  1;\n\t\t\t/* turn off mandatory locking in mode\n\t\t\tif remote locking is turned off since the\n\t\t\tlocal vfs will do advisory */\n\t\t\tif (vol->file_mode ==\n\t\t\t\t(S_IALLUGO & ~(S_ISUID | S_IXGRP)))\n\t\t\t\tvol->file_mode = S_IALLUGO;\n\t\t} else if (strnicmp(data, \"forcemandatorylock\", 9) == 0) {\n\t\t\t/* will take the shorter form \"forcemand\" as well */\n\t\t\t/* This mount option will force use of mandatory\n\t\t\t  (DOS/Windows style) byte range locks, instead of\n\t\t\t  using posix advisory byte range locks, even if the\n\t\t\t  Unix extensions are available and posix locks would\n\t\t\t  be supported otherwise. If Unix extensions are not\n\t\t\t  negotiated this has no effect since mandatory locks\n\t\t\t  would be used (mandatory locks is all that those\n\t\t\t  those servers support) */\n\t\t\tvol->mand_lock = 1;\n\t\t} else if (strnicmp(data, \"setuids\", 7) == 0) {\n\t\t\tvol->setuids = 1;\n\t\t} else if (strnicmp(data, \"nosetuids\", 9) == 0) {\n\t\t\tvol->setuids = 0;\n\t\t} else if (strnicmp(data, \"dynperm\", 7) == 0) {\n\t\t\tvol->dynperm = true;\n\t\t} else if (strnicmp(data, \"nodynperm\", 9) == 0) {\n\t\t\tvol->dynperm = false;\n\t\t} else if (strnicmp(data, \"nohard\", 6) == 0) {\n\t\t\tvol->retry = 0;\n\t\t} else if (strnicmp(data, \"nosoft\", 6) == 0) {\n\t\t\tvol->retry = 1;\n\t\t} else if (strnicmp(data, \"nointr\", 6) == 0) {\n\t\t\tvol->intr = 0;\n\t\t} else if (strnicmp(data, \"intr\", 4) == 0) {\n\t\t\tvol->intr = 1;\n\t\t} else if (strnicmp(data, \"nostrictsync\", 12) == 0) {\n\t\t\tvol->nostrictsync = 1;\n\t\t} else if (strnicmp(data, \"strictsync\", 10) == 0) {\n\t\t\tvol->nostrictsync = 0;\n\t\t} else if (strnicmp(data, \"serverino\", 7) == 0) {\n\t\t\tvol->server_ino = 1;\n\t\t} else if (strnicmp(data, \"noserverino\", 9) == 0) {\n\t\t\tvol->server_ino = 0;\n\t\t} else if (strnicmp(data, \"cifsacl\", 7) == 0) {\n\t\t\tvol->cifs_acl = 1;\n\t\t} else if (strnicmp(data, \"nocifsacl\", 9) == 0) {\n\t\t\tvol->cifs_acl = 0;\n\t\t} else if (strnicmp(data, \"acl\", 3) == 0) {\n\t\t\tvol->no_psx_acl = 0;\n\t\t} else if (strnicmp(data, \"noacl\", 5) == 0) {\n\t\t\tvol->no_psx_acl = 1;\n\t\t} else if (strnicmp(data, \"locallease\", 6) == 0) {\n\t\t\tvol->local_lease = 1;\n\t\t} else if (strnicmp(data, \"sign\", 4) == 0) {\n\t\t\tvol->secFlg |= CIFSSEC_MUST_SIGN;\n\t\t} else if (strnicmp(data, \"seal\", 4) == 0) {\n\t\t\t/* we do not do the following in secFlags because seal\n\t\t\t   is a per tree connection (mount) not a per socket\n\t\t\t   or per-smb connection option in the protocol */\n\t\t\t/* vol->secFlg |= CIFSSEC_MUST_SEAL; */\n\t\t\tvol->seal = 1;\n\t\t} else if (strnicmp(data, \"direct\", 6) == 0) {\n\t\t\tvol->direct_io = 1;\n\t\t} else if (strnicmp(data, \"forcedirectio\", 13) == 0) {\n\t\t\tvol->direct_io = 1;\n\t\t} else if (strnicmp(data, \"strictcache\", 11) == 0) {\n\t\t\tvol->strict_io = 1;\n\t\t} else if (strnicmp(data, \"noac\", 4) == 0) {\n\t\t\tprintk(KERN_WARNING \"CIFS: Mount option noac not \"\n\t\t\t\t\"supported. Instead set \"\n\t\t\t\t\"/proc/fs/cifs/LookupCacheEnabled to 0\\n\");\n\t\t} else if (strnicmp(data, \"fsc\", 3) == 0) {\n#ifndef CONFIG_CIFS_FSCACHE\n\t\t\tcERROR(1, \"FS-Cache support needs CONFIG_CIFS_FSCACHE\"\n\t\t\t\t  \"kernel config option set\");\n\t\t\treturn 1;\n#endif\n\t\t\tvol->fsc = true;\n\t\t} else if (strnicmp(data, \"mfsymlinks\", 10) == 0) {\n\t\t\tvol->mfsymlinks = true;\n\t\t} else if (strnicmp(data, \"multiuser\", 8) == 0) {\n\t\t\tvol->multiuser = true;\n\t\t} else\n\t\t\tprintk(KERN_WARNING \"CIFS: Unknown mount option %s\\n\",\n\t\t\t\t\t\tdata);\n\t}\n\tif (vol->UNC == NULL) {\n\t\tif (devname == NULL) {\n\t\t\tprintk(KERN_WARNING \"CIFS: Missing UNC name for mount \"\n\t\t\t\t\t\t\"target\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\tif ((temp_len = strnlen(devname, 300)) < 300) {\n\t\t\tvol->UNC = kmalloc(temp_len+1, GFP_KERNEL);\n\t\t\tif (vol->UNC == NULL)\n\t\t\t\treturn 1;\n\t\t\tstrcpy(vol->UNC, devname);\n\t\t\tif (strncmp(vol->UNC, \"//\", 2) == 0) {\n\t\t\t\tvol->UNC[0] = '\\\\';\n\t\t\t\tvol->UNC[1] = '\\\\';\n\t\t\t} else if (strncmp(vol->UNC, \"\\\\\\\\\", 2) != 0) {\n\t\t\t\tprintk(KERN_WARNING \"CIFS: UNC Path does not \"\n\t\t\t\t\t\t    \"begin with // or \\\\\\\\ \\n\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tvalue = strpbrk(vol->UNC+2, \"/\\\\\");\n\t\t\tif (value)\n\t\t\t\t*value = '\\\\';\n\t\t} else {\n\t\t\tprintk(KERN_WARNING \"CIFS: UNC name too long\\n\");\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif (vol->multiuser && !(vol->secFlg & CIFSSEC_MAY_KRB5)) {\n\t\tcERROR(1, \"Multiuser mounts currently require krb5 \"\n\t\t\t  \"authentication!\");\n\t\treturn 1;\n\t}\n\n\tif (vol->UNCip == NULL)\n\t\tvol->UNCip = &vol->UNC[2];\n\n\tif (uid_specified)\n\t\tvol->override_uid = override_uid;\n\telse if (override_uid == 1)\n\t\tprintk(KERN_NOTICE \"CIFS: ignoring forceuid mount option \"\n\t\t\t\t   \"specified with no uid= option.\\n\");\n\n\tif (gid_specified)\n\t\tvol->override_gid = override_gid;\n\telse if (override_gid == 1)\n\t\tprintk(KERN_NOTICE \"CIFS: ignoring forcegid mount option \"\n\t\t\t\t   \"specified with no gid= option.\\n\");\n\n\treturn 0;\n}\n\n/** Returns true if srcaddr isn't specified and rhs isn't\n * specified, or if srcaddr is specified and\n * matches the IP address of the rhs argument.\n */\nstatic bool\nsrcip_matches(struct sockaddr *srcaddr, struct sockaddr *rhs)\n{\n\tswitch (srcaddr->sa_family) {\n\tcase AF_UNSPEC:\n\t\treturn (rhs->sa_family == AF_UNSPEC);\n\tcase AF_INET: {\n\t\tstruct sockaddr_in *saddr4 = (struct sockaddr_in *)srcaddr;\n\t\tstruct sockaddr_in *vaddr4 = (struct sockaddr_in *)rhs;\n\t\treturn (saddr4->sin_addr.s_addr == vaddr4->sin_addr.s_addr);\n\t}\n\tcase AF_INET6: {\n\t\tstruct sockaddr_in6 *saddr6 = (struct sockaddr_in6 *)srcaddr;\n\t\tstruct sockaddr_in6 *vaddr6 = (struct sockaddr_in6 *)&rhs;\n\t\treturn ipv6_addr_equal(&saddr6->sin6_addr, &vaddr6->sin6_addr);\n\t}\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn false; /* don't expect to be here */\n\t}\n}\n\n/*\n * If no port is specified in addr structure, we try to match with 445 port\n * and if it fails - with 139 ports. It should be called only if address\n * families of server and addr are equal.\n */\nstatic bool\nmatch_port(struct TCP_Server_Info *server, struct sockaddr *addr)\n{\n\t__be16 port, *sport;\n\n\tswitch (addr->sa_family) {\n\tcase AF_INET:\n\t\tsport = &((struct sockaddr_in *) &server->dstaddr)->sin_port;\n\t\tport = ((struct sockaddr_in *) addr)->sin_port;\n\t\tbreak;\n\tcase AF_INET6:\n\t\tsport = &((struct sockaddr_in6 *) &server->dstaddr)->sin6_port;\n\t\tport = ((struct sockaddr_in6 *) addr)->sin6_port;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn false;\n\t}\n\n\tif (!port) {\n\t\tport = htons(CIFS_PORT);\n\t\tif (port == *sport)\n\t\t\treturn true;\n\n\t\tport = htons(RFC1001_PORT);\n\t}\n\n\treturn port == *sport;\n}\n\nstatic bool\nmatch_address(struct TCP_Server_Info *server, struct sockaddr *addr,\n\t      struct sockaddr *srcaddr)\n{\n\tswitch (addr->sa_family) {\n\tcase AF_INET: {\n\t\tstruct sockaddr_in *addr4 = (struct sockaddr_in *)addr;\n\t\tstruct sockaddr_in *srv_addr4 =\n\t\t\t\t\t(struct sockaddr_in *)&server->dstaddr;\n\n\t\tif (addr4->sin_addr.s_addr != srv_addr4->sin_addr.s_addr)\n\t\t\treturn false;\n\t\tbreak;\n\t}\n\tcase AF_INET6: {\n\t\tstruct sockaddr_in6 *addr6 = (struct sockaddr_in6 *)addr;\n\t\tstruct sockaddr_in6 *srv_addr6 =\n\t\t\t\t\t(struct sockaddr_in6 *)&server->dstaddr;\n\n\t\tif (!ipv6_addr_equal(&addr6->sin6_addr,\n\t\t\t\t     &srv_addr6->sin6_addr))\n\t\t\treturn false;\n\t\tif (addr6->sin6_scope_id != srv_addr6->sin6_scope_id)\n\t\t\treturn false;\n\t\tbreak;\n\t}\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn false; /* don't expect to be here */\n\t}\n\n\tif (!srcip_matches(srcaddr, (struct sockaddr *)&server->srcaddr))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool\nmatch_security(struct TCP_Server_Info *server, struct smb_vol *vol)\n{\n\tunsigned int secFlags;\n\n\tif (vol->secFlg & (~(CIFSSEC_MUST_SIGN | CIFSSEC_MUST_SEAL)))\n\t\tsecFlags = vol->secFlg;\n\telse\n\t\tsecFlags = global_secflags | vol->secFlg;\n\n\tswitch (server->secType) {\n\tcase LANMAN:\n\t\tif (!(secFlags & (CIFSSEC_MAY_LANMAN|CIFSSEC_MAY_PLNTXT)))\n\t\t\treturn false;\n\t\tbreak;\n\tcase NTLMv2:\n\t\tif (!(secFlags & CIFSSEC_MAY_NTLMV2))\n\t\t\treturn false;\n\t\tbreak;\n\tcase NTLM:\n\t\tif (!(secFlags & CIFSSEC_MAY_NTLM))\n\t\t\treturn false;\n\t\tbreak;\n\tcase Kerberos:\n\t\tif (!(secFlags & CIFSSEC_MAY_KRB5))\n\t\t\treturn false;\n\t\tbreak;\n\tcase RawNTLMSSP:\n\t\tif (!(secFlags & CIFSSEC_MAY_NTLMSSP))\n\t\t\treturn false;\n\t\tbreak;\n\tdefault:\n\t\t/* shouldn't happen */\n\t\treturn false;\n\t}\n\n\t/* now check if signing mode is acceptable */\n\tif ((secFlags & CIFSSEC_MAY_SIGN) == 0 &&\n\t    (server->secMode & SECMODE_SIGN_REQUIRED))\n\t\t\treturn false;\n\telse if (((secFlags & CIFSSEC_MUST_SIGN) == CIFSSEC_MUST_SIGN) &&\n\t\t (server->secMode &\n\t\t  (SECMODE_SIGN_ENABLED|SECMODE_SIGN_REQUIRED)) == 0)\n\t\t\treturn false;\n\n\treturn true;\n}\n\nstatic struct TCP_Server_Info *\ncifs_find_tcp_session(struct sockaddr *addr, struct smb_vol *vol)\n{\n\tstruct TCP_Server_Info *server;\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each_entry(server, &cifs_tcp_ses_list, tcp_ses_list) {\n\t\tif (!net_eq(cifs_net_ns(server), current->nsproxy->net_ns))\n\t\t\tcontinue;\n\n\t\tif (!match_address(server, addr,\n\t\t\t\t   (struct sockaddr *)&vol->srcaddr))\n\t\t\tcontinue;\n\n\t\tif (!match_port(server, addr))\n\t\t\tcontinue;\n\n\t\tif (!match_security(server, vol))\n\t\t\tcontinue;\n\n\t\t++server->srv_count;\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\tcFYI(1, \"Existing tcp session with server found\");\n\t\treturn server;\n\t}\n\tspin_unlock(&cifs_tcp_ses_lock);\n\treturn NULL;\n}\n\nstatic void\ncifs_put_tcp_session(struct TCP_Server_Info *server)\n{\n\tstruct task_struct *task;\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tif (--server->srv_count > 0) {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t}\n\n\tput_net(cifs_net_ns(server));\n\n\tlist_del_init(&server->tcp_ses_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tcancel_delayed_work_sync(&server->echo);\n\n\tspin_lock(&GlobalMid_Lock);\n\tserver->tcpStatus = CifsExiting;\n\tspin_unlock(&GlobalMid_Lock);\n\n\tcifs_crypto_shash_release(server);\n\tcifs_fscache_release_client_cookie(server);\n\n\tkfree(server->session_key.response);\n\tserver->session_key.response = NULL;\n\tserver->session_key.len = 0;\n\n\ttask = xchg(&server->tsk, NULL);\n\tif (task)\n\t\tforce_sig(SIGKILL, task);\n}\n\nstatic struct TCP_Server_Info *\ncifs_get_tcp_session(struct smb_vol *volume_info)\n{\n\tstruct TCP_Server_Info *tcp_ses = NULL;\n\tstruct sockaddr_storage addr;\n\tstruct sockaddr_in *sin_server = (struct sockaddr_in *) &addr;\n\tstruct sockaddr_in6 *sin_server6 = (struct sockaddr_in6 *) &addr;\n\tint rc;\n\n\tmemset(&addr, 0, sizeof(struct sockaddr_storage));\n\n\tcFYI(1, \"UNC: %s ip: %s\", volume_info->UNC, volume_info->UNCip);\n\n\tif (volume_info->UNCip && volume_info->UNC) {\n\t\trc = cifs_fill_sockaddr((struct sockaddr *)&addr,\n\t\t\t\t\tvolume_info->UNCip,\n\t\t\t\t\tstrlen(volume_info->UNCip),\n\t\t\t\t\tvolume_info->port);\n\t\tif (!rc) {\n\t\t\t/* we failed translating address */\n\t\t\trc = -EINVAL;\n\t\t\tgoto out_err;\n\t\t}\n\t} else if (volume_info->UNCip) {\n\t\t/* BB using ip addr as tcp_ses name to connect to the\n\t\t   DFS root below */\n\t\tcERROR(1, \"Connecting to DFS root not implemented yet\");\n\t\trc = -EINVAL;\n\t\tgoto out_err;\n\t} else /* which tcp_sess DFS root would we conect to */ {\n\t\tcERROR(1, \"CIFS mount error: No UNC path (e.g. -o \"\n\t\t\t\"unc=//192.168.1.100/public) specified\");\n\t\trc = -EINVAL;\n\t\tgoto out_err;\n\t}\n\n\t/* see if we already have a matching tcp_ses */\n\ttcp_ses = cifs_find_tcp_session((struct sockaddr *)&addr, volume_info);\n\tif (tcp_ses)\n\t\treturn tcp_ses;\n\n\ttcp_ses = kzalloc(sizeof(struct TCP_Server_Info), GFP_KERNEL);\n\tif (!tcp_ses) {\n\t\trc = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\trc = cifs_crypto_shash_allocate(tcp_ses);\n\tif (rc) {\n\t\tcERROR(1, \"could not setup hash structures rc %d\", rc);\n\t\tgoto out_err;\n\t}\n\n\tcifs_set_net_ns(tcp_ses, get_net(current->nsproxy->net_ns));\n\ttcp_ses->hostname = extract_hostname(volume_info->UNC);\n\tif (IS_ERR(tcp_ses->hostname)) {\n\t\trc = PTR_ERR(tcp_ses->hostname);\n\t\tgoto out_err_crypto_release;\n\t}\n\n\ttcp_ses->noblocksnd = volume_info->noblocksnd;\n\ttcp_ses->noautotune = volume_info->noautotune;\n\ttcp_ses->tcp_nodelay = volume_info->sockopt_tcp_nodelay;\n\tatomic_set(&tcp_ses->inFlight, 0);\n\tinit_waitqueue_head(&tcp_ses->response_q);\n\tinit_waitqueue_head(&tcp_ses->request_q);\n\tINIT_LIST_HEAD(&tcp_ses->pending_mid_q);\n\tmutex_init(&tcp_ses->srv_mutex);\n\tmemcpy(tcp_ses->workstation_RFC1001_name,\n\t\tvolume_info->source_rfc1001_name, RFC1001_NAME_LEN_WITH_NULL);\n\tmemcpy(tcp_ses->server_RFC1001_name,\n\t\tvolume_info->target_rfc1001_name, RFC1001_NAME_LEN_WITH_NULL);\n\ttcp_ses->session_estab = false;\n\ttcp_ses->sequence_number = 0;\n\ttcp_ses->lstrp = jiffies;\n\tINIT_LIST_HEAD(&tcp_ses->tcp_ses_list);\n\tINIT_LIST_HEAD(&tcp_ses->smb_ses_list);\n\tINIT_DELAYED_WORK(&tcp_ses->echo, cifs_echo_request);\n\n\t/*\n\t * at this point we are the only ones with the pointer\n\t * to the struct since the kernel thread not created yet\n\t * no need to spinlock this init of tcpStatus or srv_count\n\t */\n\ttcp_ses->tcpStatus = CifsNew;\n\tmemcpy(&tcp_ses->srcaddr, &volume_info->srcaddr,\n\t       sizeof(tcp_ses->srcaddr));\n\t++tcp_ses->srv_count;\n\n\tif (addr.ss_family == AF_INET6) {\n\t\tcFYI(1, \"attempting ipv6 connect\");\n\t\t/* BB should we allow ipv6 on port 139? */\n\t\t/* other OS never observed in Wild doing 139 with v6 */\n\t\tmemcpy(&tcp_ses->dstaddr, sin_server6,\n\t\t       sizeof(struct sockaddr_in6));\n\t} else\n\t\tmemcpy(&tcp_ses->dstaddr, sin_server,\n\t\t       sizeof(struct sockaddr_in));\n\n\trc = ip_connect(tcp_ses);\n\tif (rc < 0) {\n\t\tcERROR(1, \"Error connecting to socket. Aborting operation\");\n\t\tgoto out_err_crypto_release;\n\t}\n\n\t/*\n\t * since we're in a cifs function already, we know that\n\t * this will succeed. No need for try_module_get().\n\t */\n\t__module_get(THIS_MODULE);\n\ttcp_ses->tsk = kthread_run((void *)(void *)cifs_demultiplex_thread,\n\t\t\t\t  tcp_ses, \"cifsd\");\n\tif (IS_ERR(tcp_ses->tsk)) {\n\t\trc = PTR_ERR(tcp_ses->tsk);\n\t\tcERROR(1, \"error %d create cifsd thread\", rc);\n\t\tmodule_put(THIS_MODULE);\n\t\tgoto out_err_crypto_release;\n\t}\n\n\t/* thread spawned, put it on the list */\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_add(&tcp_ses->tcp_ses_list, &cifs_tcp_ses_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tcifs_fscache_get_client_cookie(tcp_ses);\n\n\t/* queue echo request delayed work */\n\tqueue_delayed_work(system_nrt_wq, &tcp_ses->echo, SMB_ECHO_INTERVAL);\n\n\treturn tcp_ses;\n\nout_err_crypto_release:\n\tcifs_crypto_shash_release(tcp_ses);\n\n\tput_net(cifs_net_ns(tcp_ses));\n\nout_err:\n\tif (tcp_ses) {\n\t\tif (!IS_ERR(tcp_ses->hostname))\n\t\t\tkfree(tcp_ses->hostname);\n\t\tif (tcp_ses->ssocket)\n\t\t\tsock_release(tcp_ses->ssocket);\n\t\tkfree(tcp_ses);\n\t}\n\treturn ERR_PTR(rc);\n}\n\nstatic struct cifsSesInfo *\ncifs_find_smb_ses(struct TCP_Server_Info *server, struct smb_vol *vol)\n{\n\tstruct cifsSesInfo *ses;\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each_entry(ses, &server->smb_ses_list, smb_ses_list) {\n\t\tswitch (server->secType) {\n\t\tcase Kerberos:\n\t\t\tif (vol->cred_uid != ses->cred_uid)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* anything else takes username/password */\n\t\t\tif (ses->user_name == NULL)\n\t\t\t\tcontinue;\n\t\t\tif (strncmp(ses->user_name, vol->username,\n\t\t\t\t    MAX_USERNAME_SIZE))\n\t\t\t\tcontinue;\n\t\t\tif (strlen(vol->username) != 0 &&\n\t\t\t    ses->password != NULL &&\n\t\t\t    strncmp(ses->password,\n\t\t\t\t    vol->password ? vol->password : \"\",\n\t\t\t\t    MAX_PASSWORD_SIZE))\n\t\t\t\tcontinue;\n\t\t}\n\t\t++ses->ses_count;\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn ses;\n\t}\n\tspin_unlock(&cifs_tcp_ses_lock);\n\treturn NULL;\n}\n\nstatic void\ncifs_put_smb_ses(struct cifsSesInfo *ses)\n{\n\tint xid;\n\tstruct TCP_Server_Info *server = ses->server;\n\n\tcFYI(1, \"%s: ses_count=%d\\n\", __func__, ses->ses_count);\n\tspin_lock(&cifs_tcp_ses_lock);\n\tif (--ses->ses_count > 0) {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t}\n\n\tlist_del_init(&ses->smb_ses_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tif (ses->status == CifsGood) {\n\t\txid = GetXid();\n\t\tCIFSSMBLogoff(xid, ses);\n\t\t_FreeXid(xid);\n\t}\n\tsesInfoFree(ses);\n\tcifs_put_tcp_session(server);\n}\n\nstatic struct cifsSesInfo *\ncifs_get_smb_ses(struct TCP_Server_Info *server, struct smb_vol *volume_info)\n{\n\tint rc = -ENOMEM, xid;\n\tstruct cifsSesInfo *ses;\n\tstruct sockaddr_in *addr = (struct sockaddr_in *)&server->dstaddr;\n\tstruct sockaddr_in6 *addr6 = (struct sockaddr_in6 *)&server->dstaddr;\n\n\txid = GetXid();\n\n\tses = cifs_find_smb_ses(server, volume_info);\n\tif (ses) {\n\t\tcFYI(1, \"Existing smb sess found (status=%d)\", ses->status);\n\n\t\tmutex_lock(&ses->session_mutex);\n\t\trc = cifs_negotiate_protocol(xid, ses);\n\t\tif (rc) {\n\t\t\tmutex_unlock(&ses->session_mutex);\n\t\t\t/* problem -- put our ses reference */\n\t\t\tcifs_put_smb_ses(ses);\n\t\t\tFreeXid(xid);\n\t\t\treturn ERR_PTR(rc);\n\t\t}\n\t\tif (ses->need_reconnect) {\n\t\t\tcFYI(1, \"Session needs reconnect\");\n\t\t\trc = cifs_setup_session(xid, ses,\n\t\t\t\t\t\tvolume_info->local_nls);\n\t\t\tif (rc) {\n\t\t\t\tmutex_unlock(&ses->session_mutex);\n\t\t\t\t/* problem -- put our reference */\n\t\t\t\tcifs_put_smb_ses(ses);\n\t\t\t\tFreeXid(xid);\n\t\t\t\treturn ERR_PTR(rc);\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&ses->session_mutex);\n\n\t\t/* existing SMB ses has a server reference already */\n\t\tcifs_put_tcp_session(server);\n\t\tFreeXid(xid);\n\t\treturn ses;\n\t}\n\n\tcFYI(1, \"Existing smb sess not found\");\n\tses = sesInfoAlloc();\n\tif (ses == NULL)\n\t\tgoto get_ses_fail;\n\n\t/* new SMB session uses our server ref */\n\tses->server = server;\n\tif (server->dstaddr.ss_family == AF_INET6)\n\t\tsprintf(ses->serverName, \"%pI6\", &addr6->sin6_addr);\n\telse\n\t\tsprintf(ses->serverName, \"%pI4\", &addr->sin_addr);\n\n\tif (volume_info->username) {\n\t\tses->user_name = kstrdup(volume_info->username, GFP_KERNEL);\n\t\tif (!ses->user_name)\n\t\t\tgoto get_ses_fail;\n\t}\n\n\t/* volume_info->password freed at unmount */\n\tif (volume_info->password) {\n\t\tses->password = kstrdup(volume_info->password, GFP_KERNEL);\n\t\tif (!ses->password)\n\t\t\tgoto get_ses_fail;\n\t}\n\tif (volume_info->domainname) {\n\t\tses->domainName = kstrdup(volume_info->domainname, GFP_KERNEL);\n\t\tif (!ses->domainName)\n\t\t\tgoto get_ses_fail;\n\t}\n\tses->cred_uid = volume_info->cred_uid;\n\tses->linux_uid = volume_info->linux_uid;\n\tses->overrideSecFlg = volume_info->secFlg;\n\n\tmutex_lock(&ses->session_mutex);\n\trc = cifs_negotiate_protocol(xid, ses);\n\tif (!rc)\n\t\trc = cifs_setup_session(xid, ses, volume_info->local_nls);\n\tmutex_unlock(&ses->session_mutex);\n\tif (rc)\n\t\tgoto get_ses_fail;\n\n\t/* success, put it on the list */\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_add(&ses->smb_ses_list, &server->smb_ses_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tFreeXid(xid);\n\treturn ses;\n\nget_ses_fail:\n\tsesInfoFree(ses);\n\tFreeXid(xid);\n\treturn ERR_PTR(rc);\n}\n\nstatic struct cifsTconInfo *\ncifs_find_tcon(struct cifsSesInfo *ses, const char *unc)\n{\n\tstruct list_head *tmp;\n\tstruct cifsTconInfo *tcon;\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each(tmp, &ses->tcon_list) {\n\t\ttcon = list_entry(tmp, struct cifsTconInfo, tcon_list);\n\t\tif (tcon->tidStatus == CifsExiting)\n\t\t\tcontinue;\n\t\tif (strncmp(tcon->treeName, unc, MAX_TREE_SIZE))\n\t\t\tcontinue;\n\n\t\t++tcon->tc_count;\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn tcon;\n\t}\n\tspin_unlock(&cifs_tcp_ses_lock);\n\treturn NULL;\n}\n\nstatic void\ncifs_put_tcon(struct cifsTconInfo *tcon)\n{\n\tint xid;\n\tstruct cifsSesInfo *ses = tcon->ses;\n\n\tcFYI(1, \"%s: tc_count=%d\\n\", __func__, tcon->tc_count);\n\tspin_lock(&cifs_tcp_ses_lock);\n\tif (--tcon->tc_count > 0) {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t}\n\n\tlist_del_init(&tcon->tcon_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\txid = GetXid();\n\tCIFSSMBTDis(xid, tcon);\n\t_FreeXid(xid);\n\n\tcifs_fscache_release_super_cookie(tcon);\n\ttconInfoFree(tcon);\n\tcifs_put_smb_ses(ses);\n}\n\nstatic struct cifsTconInfo *\ncifs_get_tcon(struct cifsSesInfo *ses, struct smb_vol *volume_info)\n{\n\tint rc, xid;\n\tstruct cifsTconInfo *tcon;\n\n\ttcon = cifs_find_tcon(ses, volume_info->UNC);\n\tif (tcon) {\n\t\tcFYI(1, \"Found match on UNC path\");\n\t\t/* existing tcon already has a reference */\n\t\tcifs_put_smb_ses(ses);\n\t\tif (tcon->seal != volume_info->seal)\n\t\t\tcERROR(1, \"transport encryption setting \"\n\t\t\t\t   \"conflicts with existing tid\");\n\t\treturn tcon;\n\t}\n\n\ttcon = tconInfoAlloc();\n\tif (tcon == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto out_fail;\n\t}\n\n\ttcon->ses = ses;\n\tif (volume_info->password) {\n\t\ttcon->password = kstrdup(volume_info->password, GFP_KERNEL);\n\t\tif (!tcon->password) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out_fail;\n\t\t}\n\t}\n\n\tif (strchr(volume_info->UNC + 3, '\\\\') == NULL\n\t    && strchr(volume_info->UNC + 3, '/') == NULL) {\n\t\tcERROR(1, \"Missing share name\");\n\t\trc = -ENODEV;\n\t\tgoto out_fail;\n\t}\n\n\t/* BB Do we need to wrap session_mutex around\n\t * this TCon call and Unix SetFS as\n\t * we do on SessSetup and reconnect? */\n\txid = GetXid();\n\trc = CIFSTCon(xid, ses, volume_info->UNC, tcon, volume_info->local_nls);\n\tFreeXid(xid);\n\tcFYI(1, \"CIFS Tcon rc = %d\", rc);\n\tif (rc)\n\t\tgoto out_fail;\n\n\tif (volume_info->nodfs) {\n\t\ttcon->Flags &= ~SMB_SHARE_IS_IN_DFS;\n\t\tcFYI(1, \"DFS disabled (%d)\", tcon->Flags);\n\t}\n\ttcon->seal = volume_info->seal;\n\t/* we can have only one retry value for a connection\n\t   to a share so for resources mounted more than once\n\t   to the same server share the last value passed in\n\t   for the retry flag is used */\n\ttcon->retry = volume_info->retry;\n\ttcon->nocase = volume_info->nocase;\n\ttcon->local_lease = volume_info->local_lease;\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_add(&tcon->tcon_list, &ses->tcon_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tcifs_fscache_get_super_cookie(tcon);\n\n\treturn tcon;\n\nout_fail:\n\ttconInfoFree(tcon);\n\treturn ERR_PTR(rc);\n}\n\nvoid\ncifs_put_tlink(struct tcon_link *tlink)\n{\n\tif (!tlink || IS_ERR(tlink))\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&tlink->tl_count) ||\n\t    test_bit(TCON_LINK_IN_TREE, &tlink->tl_flags)) {\n\t\ttlink->tl_time = jiffies;\n\t\treturn;\n\t}\n\n\tif (!IS_ERR(tlink_tcon(tlink)))\n\t\tcifs_put_tcon(tlink_tcon(tlink));\n\tkfree(tlink);\n\treturn;\n}\n\nint\nget_dfs_path(int xid, struct cifsSesInfo *pSesInfo, const char *old_path,\n\t     const struct nls_table *nls_codepage, unsigned int *pnum_referrals,\n\t     struct dfs_info3_param **preferrals, int remap)\n{\n\tchar *temp_unc;\n\tint rc = 0;\n\n\t*pnum_referrals = 0;\n\t*preferrals = NULL;\n\n\tif (pSesInfo->ipc_tid == 0) {\n\t\ttemp_unc = kmalloc(2 /* for slashes */ +\n\t\t\tstrnlen(pSesInfo->serverName,\n\t\t\t\tSERVER_NAME_LEN_WITH_NULL * 2)\n\t\t\t\t + 1 + 4 /* slash IPC$ */  + 2,\n\t\t\t\tGFP_KERNEL);\n\t\tif (temp_unc == NULL)\n\t\t\treturn -ENOMEM;\n\t\ttemp_unc[0] = '\\\\';\n\t\ttemp_unc[1] = '\\\\';\n\t\tstrcpy(temp_unc + 2, pSesInfo->serverName);\n\t\tstrcpy(temp_unc + 2 + strlen(pSesInfo->serverName), \"\\\\IPC$\");\n\t\trc = CIFSTCon(xid, pSesInfo, temp_unc, NULL, nls_codepage);\n\t\tcFYI(1, \"CIFS Tcon rc = %d ipc_tid = %d\", rc, pSesInfo->ipc_tid);\n\t\tkfree(temp_unc);\n\t}\n\tif (rc == 0)\n\t\trc = CIFSGetDFSRefer(xid, pSesInfo, old_path, preferrals,\n\t\t\t\t     pnum_referrals, nls_codepage, remap);\n\t/* BB map targetUNCs to dfs_info3 structures, here or\n\t\tin CIFSGetDFSRefer BB */\n\n\treturn rc;\n}\n\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\nstatic struct lock_class_key cifs_key[2];\nstatic struct lock_class_key cifs_slock_key[2];\n\nstatic inline void\ncifs_reclassify_socket4(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tBUG_ON(sock_owned_by_user(sk));\n\tsock_lock_init_class_and_name(sk, \"slock-AF_INET-CIFS\",\n\t\t&cifs_slock_key[0], \"sk_lock-AF_INET-CIFS\", &cifs_key[0]);\n}\n\nstatic inline void\ncifs_reclassify_socket6(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tBUG_ON(sock_owned_by_user(sk));\n\tsock_lock_init_class_and_name(sk, \"slock-AF_INET6-CIFS\",\n\t\t&cifs_slock_key[1], \"sk_lock-AF_INET6-CIFS\", &cifs_key[1]);\n}\n#else\nstatic inline void\ncifs_reclassify_socket4(struct socket *sock)\n{\n}\n\nstatic inline void\ncifs_reclassify_socket6(struct socket *sock)\n{\n}\n#endif\n\n/* See RFC1001 section 14 on representation of Netbios names */\nstatic void rfc1002mangle(char *target, char *source, unsigned int length)\n{\n\tunsigned int i, j;\n\n\tfor (i = 0, j = 0; i < (length); i++) {\n\t\t/* mask a nibble at a time and encode */\n\t\ttarget[j] = 'A' + (0x0F & (source[i] >> 4));\n\t\ttarget[j+1] = 'A' + (0x0F & source[i]);\n\t\tj += 2;\n\t}\n\n}\n\nstatic int\nbind_socket(struct TCP_Server_Info *server)\n{\n\tint rc = 0;\n\tif (server->srcaddr.ss_family != AF_UNSPEC) {\n\t\t/* Bind to the specified local IP address */\n\t\tstruct socket *socket = server->ssocket;\n\t\trc = socket->ops->bind(socket,\n\t\t\t\t       (struct sockaddr *) &server->srcaddr,\n\t\t\t\t       sizeof(server->srcaddr));\n\t\tif (rc < 0) {\n\t\t\tstruct sockaddr_in *saddr4;\n\t\t\tstruct sockaddr_in6 *saddr6;\n\t\t\tsaddr4 = (struct sockaddr_in *)&server->srcaddr;\n\t\t\tsaddr6 = (struct sockaddr_in6 *)&server->srcaddr;\n\t\t\tif (saddr6->sin6_family == AF_INET6)\n\t\t\t\tcERROR(1, \"cifs: \"\n\t\t\t\t       \"Failed to bind to: %pI6c, error: %d\\n\",\n\t\t\t\t       &saddr6->sin6_addr, rc);\n\t\t\telse\n\t\t\t\tcERROR(1, \"cifs: \"\n\t\t\t\t       \"Failed to bind to: %pI4, error: %d\\n\",\n\t\t\t\t       &saddr4->sin_addr.s_addr, rc);\n\t\t}\n\t}\n\treturn rc;\n}\n\nstatic int\nip_rfc1001_connect(struct TCP_Server_Info *server)\n{\n\tint rc = 0;\n\t/*\n\t * some servers require RFC1001 sessinit before sending\n\t * negprot - BB check reconnection in case where second\n\t * sessinit is sent but no second negprot\n\t */\n\tstruct rfc1002_session_packet *ses_init_buf;\n\tstruct smb_hdr *smb_buf;\n\tses_init_buf = kzalloc(sizeof(struct rfc1002_session_packet),\n\t\t\t       GFP_KERNEL);\n\tif (ses_init_buf) {\n\t\tses_init_buf->trailer.session_req.called_len = 32;\n\n\t\tif (server->server_RFC1001_name &&\n\t\t    server->server_RFC1001_name[0] != 0)\n\t\t\trfc1002mangle(ses_init_buf->trailer.\n\t\t\t\t      session_req.called_name,\n\t\t\t\t      server->server_RFC1001_name,\n\t\t\t\t      RFC1001_NAME_LEN_WITH_NULL);\n\t\telse\n\t\t\trfc1002mangle(ses_init_buf->trailer.\n\t\t\t\t      session_req.called_name,\n\t\t\t\t      DEFAULT_CIFS_CALLED_NAME,\n\t\t\t\t      RFC1001_NAME_LEN_WITH_NULL);\n\n\t\tses_init_buf->trailer.session_req.calling_len = 32;\n\n\t\t/*\n\t\t * calling name ends in null (byte 16) from old smb\n\t\t * convention.\n\t\t */\n\t\tif (server->workstation_RFC1001_name &&\n\t\t    server->workstation_RFC1001_name[0] != 0)\n\t\t\trfc1002mangle(ses_init_buf->trailer.\n\t\t\t\t      session_req.calling_name,\n\t\t\t\t      server->workstation_RFC1001_name,\n\t\t\t\t      RFC1001_NAME_LEN_WITH_NULL);\n\t\telse\n\t\t\trfc1002mangle(ses_init_buf->trailer.\n\t\t\t\t      session_req.calling_name,\n\t\t\t\t      \"LINUX_CIFS_CLNT\",\n\t\t\t\t      RFC1001_NAME_LEN_WITH_NULL);\n\n\t\tses_init_buf->trailer.session_req.scope1 = 0;\n\t\tses_init_buf->trailer.session_req.scope2 = 0;\n\t\tsmb_buf = (struct smb_hdr *)ses_init_buf;\n\n\t\t/* sizeof RFC1002_SESSION_REQUEST with no scope */\n\t\tsmb_buf->smb_buf_length = 0x81000044;\n\t\trc = smb_send(server, smb_buf, 0x44);\n\t\tkfree(ses_init_buf);\n\t\t/*\n\t\t * RFC1001 layer in at least one server\n\t\t * requires very short break before negprot\n\t\t * presumably because not expecting negprot\n\t\t * to follow so fast.  This is a simple\n\t\t * solution that works without\n\t\t * complicating the code and causes no\n\t\t * significant slowing down on mount\n\t\t * for everyone else\n\t\t */\n\t\tusleep_range(1000, 2000);\n\t}\n\t/*\n\t * else the negprot may still work without this\n\t * even though malloc failed\n\t */\n\n\treturn rc;\n}\n\nstatic int\ngeneric_ip_connect(struct TCP_Server_Info *server)\n{\n\tint rc = 0;\n\t__be16 sport;\n\tint slen, sfamily;\n\tstruct socket *socket = server->ssocket;\n\tstruct sockaddr *saddr;\n\n\tsaddr = (struct sockaddr *) &server->dstaddr;\n\n\tif (server->dstaddr.ss_family == AF_INET6) {\n\t\tsport = ((struct sockaddr_in6 *) saddr)->sin6_port;\n\t\tslen = sizeof(struct sockaddr_in6);\n\t\tsfamily = AF_INET6;\n\t} else {\n\t\tsport = ((struct sockaddr_in *) saddr)->sin_port;\n\t\tslen = sizeof(struct sockaddr_in);\n\t\tsfamily = AF_INET;\n\t}\n\n\tif (socket == NULL) {\n\t\trc = __sock_create(cifs_net_ns(server), sfamily, SOCK_STREAM,\n\t\t\t\t   IPPROTO_TCP, &socket, 1);\n\t\tif (rc < 0) {\n\t\t\tcERROR(1, \"Error %d creating socket\", rc);\n\t\t\tserver->ssocket = NULL;\n\t\t\treturn rc;\n\t\t}\n\n\t\t/* BB other socket options to set KEEPALIVE, NODELAY? */\n\t\tcFYI(1, \"Socket created\");\n\t\tserver->ssocket = socket;\n\t\tsocket->sk->sk_allocation = GFP_NOFS;\n\t\tif (sfamily == AF_INET6)\n\t\t\tcifs_reclassify_socket6(socket);\n\t\telse\n\t\t\tcifs_reclassify_socket4(socket);\n\t}\n\n\trc = bind_socket(server);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = socket->ops->connect(socket, saddr, slen, 0);\n\tif (rc < 0) {\n\t\tcFYI(1, \"Error %d connecting to server\", rc);\n\t\tsock_release(socket);\n\t\tserver->ssocket = NULL;\n\t\treturn rc;\n\t}\n\n\t/*\n\t * Eventually check for other socket options to change from\n\t * the default. sock_setsockopt not used because it expects\n\t * user space buffer\n\t */\n\tsocket->sk->sk_rcvtimeo = 7 * HZ;\n\tsocket->sk->sk_sndtimeo = 5 * HZ;\n\n\t/* make the bufsizes depend on wsize/rsize and max requests */\n\tif (server->noautotune) {\n\t\tif (socket->sk->sk_sndbuf < (200 * 1024))\n\t\t\tsocket->sk->sk_sndbuf = 200 * 1024;\n\t\tif (socket->sk->sk_rcvbuf < (140 * 1024))\n\t\t\tsocket->sk->sk_rcvbuf = 140 * 1024;\n\t}\n\n\tif (server->tcp_nodelay) {\n\t\tint val = 1;\n\t\trc = kernel_setsockopt(socket, SOL_TCP, TCP_NODELAY,\n\t\t\t\t(char *)&val, sizeof(val));\n\t\tif (rc)\n\t\t\tcFYI(1, \"set TCP_NODELAY socket option error %d\", rc);\n\t}\n\n\t cFYI(1, \"sndbuf %d rcvbuf %d rcvtimeo 0x%lx\",\n\t\t socket->sk->sk_sndbuf,\n\t\t socket->sk->sk_rcvbuf, socket->sk->sk_rcvtimeo);\n\n\tif (sport == htons(RFC1001_PORT))\n\t\trc = ip_rfc1001_connect(server);\n\n\treturn rc;\n}\n\nstatic int\nip_connect(struct TCP_Server_Info *server)\n{\n\t__be16 *sport;\n\tstruct sockaddr_in6 *addr6 = (struct sockaddr_in6 *)&server->dstaddr;\n\tstruct sockaddr_in *addr = (struct sockaddr_in *)&server->dstaddr;\n\n\tif (server->dstaddr.ss_family == AF_INET6)\n\t\tsport = &addr6->sin6_port;\n\telse\n\t\tsport = &addr->sin_port;\n\n\tif (*sport == 0) {\n\t\tint rc;\n\n\t\t/* try with 445 port at first */\n\t\t*sport = htons(CIFS_PORT);\n\n\t\trc = generic_ip_connect(server);\n\t\tif (rc >= 0)\n\t\t\treturn rc;\n\n\t\t/* if it failed, try with 139 port */\n\t\t*sport = htons(RFC1001_PORT);\n\t}\n\n\treturn generic_ip_connect(server);\n}\n\nvoid reset_cifs_unix_caps(int xid, struct cifsTconInfo *tcon,\n\t\t\t  struct super_block *sb, struct smb_vol *vol_info)\n{\n\t/* if we are reconnecting then should we check to see if\n\t * any requested capabilities changed locally e.g. via\n\t * remount but we can not do much about it here\n\t * if they have (even if we could detect it by the following)\n\t * Perhaps we could add a backpointer to array of sb from tcon\n\t * or if we change to make all sb to same share the same\n\t * sb as NFS - then we only have one backpointer to sb.\n\t * What if we wanted to mount the server share twice once with\n\t * and once without posixacls or posix paths? */\n\t__u64 saved_cap = le64_to_cpu(tcon->fsUnixInfo.Capability);\n\n\tif (vol_info && vol_info->no_linux_ext) {\n\t\ttcon->fsUnixInfo.Capability = 0;\n\t\ttcon->unix_ext = 0; /* Unix Extensions disabled */\n\t\tcFYI(1, \"Linux protocol extensions disabled\");\n\t\treturn;\n\t} else if (vol_info)\n\t\ttcon->unix_ext = 1; /* Unix Extensions supported */\n\n\tif (tcon->unix_ext == 0) {\n\t\tcFYI(1, \"Unix extensions disabled so not set on reconnect\");\n\t\treturn;\n\t}\n\n\tif (!CIFSSMBQFSUnixInfo(xid, tcon)) {\n\t\t__u64 cap = le64_to_cpu(tcon->fsUnixInfo.Capability);\n\n\t\t/* check for reconnect case in which we do not\n\t\t   want to change the mount behavior if we can avoid it */\n\t\tif (vol_info == NULL) {\n\t\t\t/* turn off POSIX ACL and PATHNAMES if not set\n\t\t\t   originally at mount time */\n\t\t\tif ((saved_cap & CIFS_UNIX_POSIX_ACL_CAP) == 0)\n\t\t\t\tcap &= ~CIFS_UNIX_POSIX_ACL_CAP;\n\t\t\tif ((saved_cap & CIFS_UNIX_POSIX_PATHNAMES_CAP) == 0) {\n\t\t\t\tif (cap & CIFS_UNIX_POSIX_PATHNAMES_CAP)\n\t\t\t\t\tcERROR(1, \"POSIXPATH support change\");\n\t\t\t\tcap &= ~CIFS_UNIX_POSIX_PATHNAMES_CAP;\n\t\t\t} else if ((cap & CIFS_UNIX_POSIX_PATHNAMES_CAP) == 0) {\n\t\t\t\tcERROR(1, \"possible reconnect error\");\n\t\t\t\tcERROR(1, \"server disabled POSIX path support\");\n\t\t\t}\n\t\t}\n\n\t\tcap &= CIFS_UNIX_CAP_MASK;\n\t\tif (vol_info && vol_info->no_psx_acl)\n\t\t\tcap &= ~CIFS_UNIX_POSIX_ACL_CAP;\n\t\telse if (CIFS_UNIX_POSIX_ACL_CAP & cap) {\n\t\t\tcFYI(1, \"negotiated posix acl support\");\n\t\t\tif (sb)\n\t\t\t\tsb->s_flags |= MS_POSIXACL;\n\t\t}\n\n\t\tif (vol_info && vol_info->posix_paths == 0)\n\t\t\tcap &= ~CIFS_UNIX_POSIX_PATHNAMES_CAP;\n\t\telse if (cap & CIFS_UNIX_POSIX_PATHNAMES_CAP) {\n\t\t\tcFYI(1, \"negotiate posix pathnames\");\n\t\t\tif (sb)\n\t\t\t\tCIFS_SB(sb)->mnt_cifs_flags |=\n\t\t\t\t\tCIFS_MOUNT_POSIX_PATHS;\n\t\t}\n\n\t\t/* We might be setting the path sep back to a different\n\t\tform if we are reconnecting and the server switched its\n\t\tposix path capability for this share */\n\t\tif (sb && (CIFS_SB(sb)->prepathlen > 0))\n\t\t\tCIFS_SB(sb)->prepath[0] = CIFS_DIR_SEP(CIFS_SB(sb));\n\n\t\tif (sb && (CIFS_SB(sb)->rsize > 127 * 1024)) {\n\t\t\tif ((cap & CIFS_UNIX_LARGE_READ_CAP) == 0) {\n\t\t\t\tCIFS_SB(sb)->rsize = 127 * 1024;\n\t\t\t\tcFYI(DBG2, \"larger reads not supported by srv\");\n\t\t\t}\n\t\t}\n\n\n\t\tcFYI(1, \"Negotiate caps 0x%x\", (int)cap);\n#ifdef CONFIG_CIFS_DEBUG2\n\t\tif (cap & CIFS_UNIX_FCNTL_CAP)\n\t\t\tcFYI(1, \"FCNTL cap\");\n\t\tif (cap & CIFS_UNIX_EXTATTR_CAP)\n\t\t\tcFYI(1, \"EXTATTR cap\");\n\t\tif (cap & CIFS_UNIX_POSIX_PATHNAMES_CAP)\n\t\t\tcFYI(1, \"POSIX path cap\");\n\t\tif (cap & CIFS_UNIX_XATTR_CAP)\n\t\t\tcFYI(1, \"XATTR cap\");\n\t\tif (cap & CIFS_UNIX_POSIX_ACL_CAP)\n\t\t\tcFYI(1, \"POSIX ACL cap\");\n\t\tif (cap & CIFS_UNIX_LARGE_READ_CAP)\n\t\t\tcFYI(1, \"very large read cap\");\n\t\tif (cap & CIFS_UNIX_LARGE_WRITE_CAP)\n\t\t\tcFYI(1, \"very large write cap\");\n#endif /* CIFS_DEBUG2 */\n\t\tif (CIFSSMBSetFSUnixInfo(xid, tcon, cap)) {\n\t\t\tif (vol_info == NULL) {\n\t\t\t\tcFYI(1, \"resetting capabilities failed\");\n\t\t\t} else\n\t\t\t\tcERROR(1, \"Negotiating Unix capabilities \"\n\t\t\t\t\t   \"with the server failed.  Consider \"\n\t\t\t\t\t   \"mounting with the Unix Extensions\\n\"\n\t\t\t\t\t   \"disabled, if problems are found, \"\n\t\t\t\t\t   \"by specifying the nounix mount \"\n\t\t\t\t\t   \"option.\");\n\n\t\t}\n\t}\n}\n\nstatic void\nconvert_delimiter(char *path, char delim)\n{\n\tint i;\n\tchar old_delim;\n\n\tif (path == NULL)\n\t\treturn;\n\n\tif (delim == '/')\n\t\told_delim = '\\\\';\n\telse\n\t\told_delim = '/';\n\n\tfor (i = 0; path[i] != '\\0'; i++) {\n\t\tif (path[i] == old_delim)\n\t\t\tpath[i] = delim;\n\t}\n}\n\nstatic void setup_cifs_sb(struct smb_vol *pvolume_info,\n\t\t\t  struct cifs_sb_info *cifs_sb)\n{\n\tINIT_DELAYED_WORK(&cifs_sb->prune_tlinks, cifs_prune_tlinks);\n\n\tif (pvolume_info->rsize > CIFSMaxBufSize) {\n\t\tcERROR(1, \"rsize %d too large, using MaxBufSize\",\n\t\t\tpvolume_info->rsize);\n\t\tcifs_sb->rsize = CIFSMaxBufSize;\n\t} else if ((pvolume_info->rsize) &&\n\t\t\t(pvolume_info->rsize <= CIFSMaxBufSize))\n\t\tcifs_sb->rsize = pvolume_info->rsize;\n\telse /* default */\n\t\tcifs_sb->rsize = CIFSMaxBufSize;\n\n\tif (pvolume_info->wsize > PAGEVEC_SIZE * PAGE_CACHE_SIZE) {\n\t\tcERROR(1, \"wsize %d too large, using 4096 instead\",\n\t\t\t  pvolume_info->wsize);\n\t\tcifs_sb->wsize = 4096;\n\t} else if (pvolume_info->wsize)\n\t\tcifs_sb->wsize = pvolume_info->wsize;\n\telse\n\t\tcifs_sb->wsize = min_t(const int,\n\t\t\t\t\tPAGEVEC_SIZE * PAGE_CACHE_SIZE,\n\t\t\t\t\t127*1024);\n\t\t/* old default of CIFSMaxBufSize was too small now\n\t\t   that SMB Write2 can send multiple pages in kvec.\n\t\t   RFC1001 does not describe what happens when frame\n\t\t   bigger than 128K is sent so use that as max in\n\t\t   conjunction with 52K kvec constraint on arch with 4K\n\t\t   page size  */\n\n\tif (cifs_sb->rsize < 2048) {\n\t\tcifs_sb->rsize = 2048;\n\t\t/* Windows ME may prefer this */\n\t\tcFYI(1, \"readsize set to minimum: 2048\");\n\t}\n\t/* calculate prepath */\n\tcifs_sb->prepath = pvolume_info->prepath;\n\tif (cifs_sb->prepath) {\n\t\tcifs_sb->prepathlen = strlen(cifs_sb->prepath);\n\t\t/* we can not convert the / to \\ in the path\n\t\tseparators in the prefixpath yet because we do not\n\t\tknow (until reset_cifs_unix_caps is called later)\n\t\twhether POSIX PATH CAP is available. We normalize\n\t\tthe / to \\ after reset_cifs_unix_caps is called */\n\t\tpvolume_info->prepath = NULL;\n\t} else\n\t\tcifs_sb->prepathlen = 0;\n\tcifs_sb->mnt_uid = pvolume_info->linux_uid;\n\tcifs_sb->mnt_gid = pvolume_info->linux_gid;\n\tcifs_sb->mnt_file_mode = pvolume_info->file_mode;\n\tcifs_sb->mnt_dir_mode = pvolume_info->dir_mode;\n\tcFYI(1, \"file mode: 0x%x  dir mode: 0x%x\",\n\t\tcifs_sb->mnt_file_mode, cifs_sb->mnt_dir_mode);\n\n\tcifs_sb->actimeo = pvolume_info->actimeo;\n\n\tif (pvolume_info->noperm)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_NO_PERM;\n\tif (pvolume_info->setuids)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_SET_UID;\n\tif (pvolume_info->server_ino)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_SERVER_INUM;\n\tif (pvolume_info->remap)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_MAP_SPECIAL_CHR;\n\tif (pvolume_info->no_xattr)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_NO_XATTR;\n\tif (pvolume_info->sfu_emul)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_UNX_EMUL;\n\tif (pvolume_info->nobrl)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_NO_BRL;\n\tif (pvolume_info->nostrictsync)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_NOSSYNC;\n\tif (pvolume_info->mand_lock)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_NOPOSIXBRL;\n\tif (pvolume_info->cifs_acl)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_CIFS_ACL;\n\tif (pvolume_info->override_uid)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_OVERR_UID;\n\tif (pvolume_info->override_gid)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_OVERR_GID;\n\tif (pvolume_info->dynperm)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_DYNPERM;\n\tif (pvolume_info->fsc)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_FSCACHE;\n\tif (pvolume_info->multiuser)\n\t\tcifs_sb->mnt_cifs_flags |= (CIFS_MOUNT_MULTIUSER |\n\t\t\t\t\t    CIFS_MOUNT_NO_PERM);\n\tif (pvolume_info->strict_io)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_STRICT_IO;\n\tif (pvolume_info->direct_io) {\n\t\tcFYI(1, \"mounting share using direct i/o\");\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_DIRECT_IO;\n\t}\n\tif (pvolume_info->mfsymlinks) {\n\t\tif (pvolume_info->sfu_emul) {\n\t\t\tcERROR(1,  \"mount option mfsymlinks ignored if sfu \"\n\t\t\t\t   \"mount option is used\");\n\t\t} else {\n\t\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_MF_SYMLINKS;\n\t\t}\n\t}\n\n\tif ((pvolume_info->cifs_acl) && (pvolume_info->dynperm))\n\t\tcERROR(1, \"mount option dynperm ignored if cifsacl \"\n\t\t\t   \"mount option supported\");\n}\n\nstatic int\nis_path_accessible(int xid, struct cifsTconInfo *tcon,\n\t\t   struct cifs_sb_info *cifs_sb, const char *full_path)\n{\n\tint rc;\n\tFILE_ALL_INFO *pfile_info;\n\n\tpfile_info = kmalloc(sizeof(FILE_ALL_INFO), GFP_KERNEL);\n\tif (pfile_info == NULL)\n\t\treturn -ENOMEM;\n\n\trc = CIFSSMBQPathInfo(xid, tcon, full_path, pfile_info,\n\t\t\t      0 /* not legacy */, cifs_sb->local_nls,\n\t\t\t      cifs_sb->mnt_cifs_flags &\n\t\t\t\tCIFS_MOUNT_MAP_SPECIAL_CHR);\n\tkfree(pfile_info);\n\treturn rc;\n}\n\nstatic void\ncleanup_volume_info(struct smb_vol **pvolume_info)\n{\n\tstruct smb_vol *volume_info;\n\n\tif (!pvolume_info || !*pvolume_info)\n\t\treturn;\n\n\tvolume_info = *pvolume_info;\n\tkzfree(volume_info->password);\n\tkfree(volume_info->UNC);\n\tkfree(volume_info->prepath);\n\tkfree(volume_info);\n\t*pvolume_info = NULL;\n\treturn;\n}\n\n#ifdef CONFIG_CIFS_DFS_UPCALL\n/* build_path_to_root returns full path to root when\n * we do not have an exiting connection (tcon) */\nstatic char *\nbuild_unc_path_to_root(const struct smb_vol *volume_info,\n\t\tconst struct cifs_sb_info *cifs_sb)\n{\n\tchar *full_path;\n\n\tint unc_len = strnlen(volume_info->UNC, MAX_TREE_SIZE + 1);\n\tfull_path = kmalloc(unc_len + cifs_sb->prepathlen + 1, GFP_KERNEL);\n\tif (full_path == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstrncpy(full_path, volume_info->UNC, unc_len);\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS) {\n\t\tint i;\n\t\tfor (i = 0; i < unc_len; i++) {\n\t\t\tif (full_path[i] == '\\\\')\n\t\t\t\tfull_path[i] = '/';\n\t\t}\n\t}\n\n\tif (cifs_sb->prepathlen)\n\t\tstrncpy(full_path + unc_len, cifs_sb->prepath,\n\t\t\t\tcifs_sb->prepathlen);\n\n\tfull_path[unc_len + cifs_sb->prepathlen] = 0; /* add trailing null */\n\treturn full_path;\n}\n#endif\n\nint\ncifs_mount(struct super_block *sb, struct cifs_sb_info *cifs_sb,\n\t\tchar *mount_data_global, const char *devname)\n{\n\tint rc;\n\tint xid;\n\tstruct smb_vol *volume_info;\n\tstruct cifsSesInfo *pSesInfo;\n\tstruct cifsTconInfo *tcon;\n\tstruct TCP_Server_Info *srvTcp;\n\tchar   *full_path;\n\tchar *mount_data = mount_data_global;\n\tstruct tcon_link *tlink;\n#ifdef CONFIG_CIFS_DFS_UPCALL\n\tstruct dfs_info3_param *referrals = NULL;\n\tunsigned int num_referrals = 0;\n\tint referral_walks_count = 0;\ntry_mount_again:\n#endif\n\trc = 0;\n\ttcon = NULL;\n\tpSesInfo = NULL;\n\tsrvTcp = NULL;\n\tfull_path = NULL;\n\ttlink = NULL;\n\n\txid = GetXid();\n\n\tvolume_info = kzalloc(sizeof(struct smb_vol), GFP_KERNEL);\n\tif (!volume_info) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (cifs_parse_mount_options(mount_data, devname, volume_info)) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (volume_info->nullauth) {\n\t\tcFYI(1, \"null user\");\n\t\tvolume_info->username = \"\";\n\t} else if (volume_info->username) {\n\t\t/* BB fixme parse for domain name here */\n\t\tcFYI(1, \"Username: %s\", volume_info->username);\n\t} else {\n\t\tcifserror(\"No username specified\");\n\t/* In userspace mount helper we can get user name from alternate\n\t   locations such as env variables and files on disk */\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* this is needed for ASCII cp to Unicode converts */\n\tif (volume_info->iocharset == NULL) {\n\t\t/* load_nls_default cannot return null */\n\t\tvolume_info->local_nls = load_nls_default();\n\t} else {\n\t\tvolume_info->local_nls = load_nls(volume_info->iocharset);\n\t\tif (volume_info->local_nls == NULL) {\n\t\t\tcERROR(1, \"CIFS mount error: iocharset %s not found\",\n\t\t\t\t volume_info->iocharset);\n\t\t\trc = -ELIBACC;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tcifs_sb->local_nls = volume_info->local_nls;\n\n\t/* get a reference to a tcp session */\n\tsrvTcp = cifs_get_tcp_session(volume_info);\n\tif (IS_ERR(srvTcp)) {\n\t\trc = PTR_ERR(srvTcp);\n\t\tgoto out;\n\t}\n\n\t/* get a reference to a SMB session */\n\tpSesInfo = cifs_get_smb_ses(srvTcp, volume_info);\n\tif (IS_ERR(pSesInfo)) {\n\t\trc = PTR_ERR(pSesInfo);\n\t\tpSesInfo = NULL;\n\t\tgoto mount_fail_check;\n\t}\n\n\tsetup_cifs_sb(volume_info, cifs_sb);\n\tif (pSesInfo->capabilities & CAP_LARGE_FILES)\n\t\tsb->s_maxbytes = MAX_LFS_FILESIZE;\n\telse\n\t\tsb->s_maxbytes = MAX_NON_LFS;\n\n\t/* BB FIXME fix time_gran to be larger for LANMAN sessions */\n\tsb->s_time_gran = 100;\n\n\t/* search for existing tcon to this server share */\n\ttcon = cifs_get_tcon(pSesInfo, volume_info);\n\tif (IS_ERR(tcon)) {\n\t\trc = PTR_ERR(tcon);\n\t\ttcon = NULL;\n\t\tgoto remote_path_check;\n\t}\n\n\t/* do not care if following two calls succeed - informational */\n\tif (!tcon->ipc) {\n\t\tCIFSSMBQFSDeviceInfo(xid, tcon);\n\t\tCIFSSMBQFSAttributeInfo(xid, tcon);\n\t}\n\n\t/* tell server which Unix caps we support */\n\tif (tcon->ses->capabilities & CAP_UNIX)\n\t\t/* reset of caps checks mount to see if unix extensions\n\t\t   disabled for just this mount */\n\t\treset_cifs_unix_caps(xid, tcon, sb, volume_info);\n\telse\n\t\ttcon->unix_ext = 0; /* server does not support them */\n\n\t/* convert forward to back slashes in prepath here if needed */\n\tif ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS) == 0)\n\t\tconvert_delimiter(cifs_sb->prepath, CIFS_DIR_SEP(cifs_sb));\n\n\tif ((tcon->unix_ext == 0) && (cifs_sb->rsize > (1024 * 127))) {\n\t\tcifs_sb->rsize = 1024 * 127;\n\t\tcFYI(DBG2, \"no very large read support, rsize now 127K\");\n\t}\n\tif (!(tcon->ses->capabilities & CAP_LARGE_WRITE_X))\n\t\tcifs_sb->wsize = min(cifs_sb->wsize,\n\t\t\t       (tcon->ses->server->maxBuf - MAX_CIFS_HDR_SIZE));\n\tif (!(tcon->ses->capabilities & CAP_LARGE_READ_X))\n\t\tcifs_sb->rsize = min(cifs_sb->rsize,\n\t\t\t       (tcon->ses->server->maxBuf - MAX_CIFS_HDR_SIZE));\n\nremote_path_check:\n\t/* check if a whole path (including prepath) is not remote */\n\tif (!rc && tcon) {\n\t\t/* build_path_to_root works only when we have a valid tcon */\n\t\tfull_path = cifs_build_path_to_root(cifs_sb, tcon);\n\t\tif (full_path == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto mount_fail_check;\n\t\t}\n\t\trc = is_path_accessible(xid, tcon, cifs_sb, full_path);\n\t\tif (rc != 0 && rc != -EREMOTE) {\n\t\t\tkfree(full_path);\n\t\t\tgoto mount_fail_check;\n\t\t}\n\t\tkfree(full_path);\n\t}\n\n\t/* get referral if needed */\n\tif (rc == -EREMOTE) {\n#ifdef CONFIG_CIFS_DFS_UPCALL\n\t\tif (referral_walks_count > MAX_NESTED_LINKS) {\n\t\t\t/*\n\t\t\t * BB: when we implement proper loop detection,\n\t\t\t *     we will remove this check. But now we need it\n\t\t\t *     to prevent an indefinite loop if 'DFS tree' is\n\t\t\t *     misconfigured (i.e. has loops).\n\t\t\t */\n\t\t\trc = -ELOOP;\n\t\t\tgoto mount_fail_check;\n\t\t}\n\t\t/* convert forward to back slashes in prepath here if needed */\n\t\tif ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS) == 0)\n\t\t\tconvert_delimiter(cifs_sb->prepath,\n\t\t\t\t\tCIFS_DIR_SEP(cifs_sb));\n\t\tfull_path = build_unc_path_to_root(volume_info, cifs_sb);\n\t\tif (IS_ERR(full_path)) {\n\t\t\trc = PTR_ERR(full_path);\n\t\t\tgoto mount_fail_check;\n\t\t}\n\n\t\tcFYI(1, \"Getting referral for: %s\", full_path);\n\t\trc = get_dfs_path(xid, pSesInfo , full_path + 1,\n\t\t\tcifs_sb->local_nls, &num_referrals, &referrals,\n\t\t\tcifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR);\n\t\tif (!rc && num_referrals > 0) {\n\t\t\tchar *fake_devname = NULL;\n\n\t\t\tif (mount_data != mount_data_global)\n\t\t\t\tkfree(mount_data);\n\n\t\t\tmount_data = cifs_compose_mount_options(\n\t\t\t\t\tcifs_sb->mountdata, full_path + 1,\n\t\t\t\t\treferrals, &fake_devname);\n\n\t\t\tfree_dfs_info_array(referrals, num_referrals);\n\t\t\tkfree(fake_devname);\n\t\t\tkfree(full_path);\n\n\t\t\tif (IS_ERR(mount_data)) {\n\t\t\t\trc = PTR_ERR(mount_data);\n\t\t\t\tmount_data = NULL;\n\t\t\t\tgoto mount_fail_check;\n\t\t\t}\n\n\t\t\tif (tcon)\n\t\t\t\tcifs_put_tcon(tcon);\n\t\t\telse if (pSesInfo)\n\t\t\t\tcifs_put_smb_ses(pSesInfo);\n\n\t\t\tcleanup_volume_info(&volume_info);\n\t\t\treferral_walks_count++;\n\t\t\tFreeXid(xid);\n\t\t\tgoto try_mount_again;\n\t\t}\n#else /* No DFS support, return error on mount */\n\t\trc = -EOPNOTSUPP;\n#endif\n\t}\n\n\tif (rc)\n\t\tgoto mount_fail_check;\n\n\t/* now, hang the tcon off of the superblock */\n\ttlink = kzalloc(sizeof *tlink, GFP_KERNEL);\n\tif (tlink == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto mount_fail_check;\n\t}\n\n\ttlink->tl_uid = pSesInfo->linux_uid;\n\ttlink->tl_tcon = tcon;\n\ttlink->tl_time = jiffies;\n\tset_bit(TCON_LINK_MASTER, &tlink->tl_flags);\n\tset_bit(TCON_LINK_IN_TREE, &tlink->tl_flags);\n\n\tcifs_sb->master_tlink = tlink;\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\ttlink_rb_insert(&cifs_sb->tlink_tree, tlink);\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tqueue_delayed_work(system_nrt_wq, &cifs_sb->prune_tlinks,\n\t\t\t\tTLINK_IDLE_EXPIRE);\n\nmount_fail_check:\n\t/* on error free sesinfo and tcon struct if needed */\n\tif (rc) {\n\t\tif (mount_data != mount_data_global)\n\t\t\tkfree(mount_data);\n\t\t/* If find_unc succeeded then rc == 0 so we can not end */\n\t\t/* up accidentally freeing someone elses tcon struct */\n\t\tif (tcon)\n\t\t\tcifs_put_tcon(tcon);\n\t\telse if (pSesInfo)\n\t\t\tcifs_put_smb_ses(pSesInfo);\n\t\telse\n\t\t\tcifs_put_tcp_session(srvTcp);\n\t\tgoto out;\n\t}\n\n\t/* volume_info->password is freed above when existing session found\n\t(in which case it is not needed anymore) but when new sesion is created\n\tthe password ptr is put in the new session structure (in which case the\n\tpassword will be freed at unmount time) */\nout:\n\t/* zero out password before freeing */\n\tcleanup_volume_info(&volume_info);\n\tFreeXid(xid);\n\treturn rc;\n}\n\nint\nCIFSTCon(unsigned int xid, struct cifsSesInfo *ses,\n\t const char *tree, struct cifsTconInfo *tcon,\n\t const struct nls_table *nls_codepage)\n{\n\tstruct smb_hdr *smb_buffer;\n\tstruct smb_hdr *smb_buffer_response;\n\tTCONX_REQ *pSMB;\n\tTCONX_RSP *pSMBr;\n\tunsigned char *bcc_ptr;\n\tint rc = 0;\n\tint length;\n\t__u16 bytes_left, count;\n\n\tif (ses == NULL)\n\t\treturn -EIO;\n\n\tsmb_buffer = cifs_buf_get();\n\tif (smb_buffer == NULL)\n\t\treturn -ENOMEM;\n\n\tsmb_buffer_response = smb_buffer;\n\n\theader_assemble(smb_buffer, SMB_COM_TREE_CONNECT_ANDX,\n\t\t\tNULL /*no tid */ , 4 /*wct */ );\n\n\tsmb_buffer->Mid = GetNextMid(ses->server);\n\tsmb_buffer->Uid = ses->Suid;\n\tpSMB = (TCONX_REQ *) smb_buffer;\n\tpSMBr = (TCONX_RSP *) smb_buffer_response;\n\n\tpSMB->AndXCommand = 0xFF;\n\tpSMB->Flags = cpu_to_le16(TCON_EXTENDED_SECINFO);\n\tbcc_ptr = &pSMB->Password[0];\n\tif ((ses->server->secMode) & SECMODE_USER) {\n\t\tpSMB->PasswordLength = cpu_to_le16(1);\t/* minimum */\n\t\t*bcc_ptr = 0; /* password is null byte */\n\t\tbcc_ptr++;              /* skip password */\n\t\t/* already aligned so no need to do it below */\n\t} else {\n\t\tpSMB->PasswordLength = cpu_to_le16(CIFS_AUTH_RESP_SIZE);\n\t\t/* BB FIXME add code to fail this if NTLMv2 or Kerberos\n\t\t   specified as required (when that support is added to\n\t\t   the vfs in the future) as only NTLM or the much\n\t\t   weaker LANMAN (which we do not send by default) is accepted\n\t\t   by Samba (not sure whether other servers allow\n\t\t   NTLMv2 password here) */\n#ifdef CONFIG_CIFS_WEAK_PW_HASH\n\t\tif ((global_secflags & CIFSSEC_MAY_LANMAN) &&\n\t\t    (ses->server->secType == LANMAN))\n\t\t\tcalc_lanman_hash(tcon->password, ses->server->cryptkey,\n\t\t\t\t\t ses->server->secMode &\n\t\t\t\t\t    SECMODE_PW_ENCRYPT ? true : false,\n\t\t\t\t\t bcc_ptr);\n\t\telse\n#endif /* CIFS_WEAK_PW_HASH */\n\t\trc = SMBNTencrypt(tcon->password, ses->server->cryptkey,\n\t\t\t\t\tbcc_ptr);\n\n\t\tbcc_ptr += CIFS_AUTH_RESP_SIZE;\n\t\tif (ses->capabilities & CAP_UNICODE) {\n\t\t\t/* must align unicode strings */\n\t\t\t*bcc_ptr = 0; /* null byte password */\n\t\t\tbcc_ptr++;\n\t\t}\n\t}\n\n\tif (ses->server->secMode &\n\t\t\t(SECMODE_SIGN_REQUIRED | SECMODE_SIGN_ENABLED))\n\t\tsmb_buffer->Flags2 |= SMBFLG2_SECURITY_SIGNATURE;\n\n\tif (ses->capabilities & CAP_STATUS32) {\n\t\tsmb_buffer->Flags2 |= SMBFLG2_ERR_STATUS;\n\t}\n\tif (ses->capabilities & CAP_DFS) {\n\t\tsmb_buffer->Flags2 |= SMBFLG2_DFS;\n\t}\n\tif (ses->capabilities & CAP_UNICODE) {\n\t\tsmb_buffer->Flags2 |= SMBFLG2_UNICODE;\n\t\tlength =\n\t\t    cifs_strtoUCS((__le16 *) bcc_ptr, tree,\n\t\t\t6 /* max utf8 char length in bytes */ *\n\t\t\t(/* server len*/ + 256 /* share len */), nls_codepage);\n\t\tbcc_ptr += 2 * length;\t/* convert num 16 bit words to bytes */\n\t\tbcc_ptr += 2;\t/* skip trailing null */\n\t} else {\t\t/* ASCII */\n\t\tstrcpy(bcc_ptr, tree);\n\t\tbcc_ptr += strlen(tree) + 1;\n\t}\n\tstrcpy(bcc_ptr, \"?????\");\n\tbcc_ptr += strlen(\"?????\");\n\tbcc_ptr += 1;\n\tcount = bcc_ptr - &pSMB->Password[0];\n\tpSMB->hdr.smb_buf_length += count;\n\tpSMB->ByteCount = cpu_to_le16(count);\n\n\trc = SendReceive(xid, ses, smb_buffer, smb_buffer_response, &length,\n\t\t\t 0);\n\n\t/* above now done in SendReceive */\n\tif ((rc == 0) && (tcon != NULL)) {\n\t\tbool is_unicode;\n\n\t\ttcon->tidStatus = CifsGood;\n\t\ttcon->need_reconnect = false;\n\t\ttcon->tid = smb_buffer_response->Tid;\n\t\tbcc_ptr = pByteArea(smb_buffer_response);\n\t\tbytes_left = get_bcc(smb_buffer_response);\n\t\tlength = strnlen(bcc_ptr, bytes_left - 2);\n\t\tif (smb_buffer->Flags2 & SMBFLG2_UNICODE)\n\t\t\tis_unicode = true;\n\t\telse\n\t\t\tis_unicode = false;\n\n\n\t\t/* skip service field (NB: this field is always ASCII) */\n\t\tif (length == 3) {\n\t\t\tif ((bcc_ptr[0] == 'I') && (bcc_ptr[1] == 'P') &&\n\t\t\t    (bcc_ptr[2] == 'C')) {\n\t\t\t\tcFYI(1, \"IPC connection\");\n\t\t\t\ttcon->ipc = 1;\n\t\t\t}\n\t\t} else if (length == 2) {\n\t\t\tif ((bcc_ptr[0] == 'A') && (bcc_ptr[1] == ':')) {\n\t\t\t\t/* the most common case */\n\t\t\t\tcFYI(1, \"disk share connection\");\n\t\t\t}\n\t\t}\n\t\tbcc_ptr += length + 1;\n\t\tbytes_left -= (length + 1);\n\t\tstrncpy(tcon->treeName, tree, MAX_TREE_SIZE);\n\n\t\t/* mostly informational -- no need to fail on error here */\n\t\tkfree(tcon->nativeFileSystem);\n\t\ttcon->nativeFileSystem = cifs_strndup_from_ucs(bcc_ptr,\n\t\t\t\t\t\t      bytes_left, is_unicode,\n\t\t\t\t\t\t      nls_codepage);\n\n\t\tcFYI(1, \"nativeFileSystem=%s\", tcon->nativeFileSystem);\n\n\t\tif ((smb_buffer_response->WordCount == 3) ||\n\t\t\t (smb_buffer_response->WordCount == 7))\n\t\t\t/* field is in same location */\n\t\t\ttcon->Flags = le16_to_cpu(pSMBr->OptionalSupport);\n\t\telse\n\t\t\ttcon->Flags = 0;\n\t\tcFYI(1, \"Tcon flags: 0x%x \", tcon->Flags);\n\t} else if ((rc == 0) && tcon == NULL) {\n\t\t/* all we need to save for IPC$ connection */\n\t\tses->ipc_tid = smb_buffer_response->Tid;\n\t}\n\n\tcifs_buf_release(smb_buffer);\n\treturn rc;\n}\n\nint\ncifs_umount(struct super_block *sb, struct cifs_sb_info *cifs_sb)\n{\n\tstruct rb_root *root = &cifs_sb->tlink_tree;\n\tstruct rb_node *node;\n\tstruct tcon_link *tlink;\n\tchar *tmp;\n\n\tcancel_delayed_work_sync(&cifs_sb->prune_tlinks);\n\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\twhile ((node = rb_first(root))) {\n\t\ttlink = rb_entry(node, struct tcon_link, tl_rbnode);\n\t\tcifs_get_tlink(tlink);\n\t\tclear_bit(TCON_LINK_IN_TREE, &tlink->tl_flags);\n\t\trb_erase(node, root);\n\n\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t\tcifs_put_tlink(tlink);\n\t\tspin_lock(&cifs_sb->tlink_tree_lock);\n\t}\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\ttmp = cifs_sb->prepath;\n\tcifs_sb->prepathlen = 0;\n\tcifs_sb->prepath = NULL;\n\tkfree(tmp);\n\n\treturn 0;\n}\n\nint cifs_negotiate_protocol(unsigned int xid, struct cifsSesInfo *ses)\n{\n\tint rc = 0;\n\tstruct TCP_Server_Info *server = ses->server;\n\n\t/* only send once per connect */\n\tif (server->maxBuf != 0)\n\t\treturn 0;\n\n\trc = CIFSSMBNegotiate(xid, ses);\n\tif (rc == -EAGAIN) {\n\t\t/* retry only once on 1st time connection */\n\t\trc = CIFSSMBNegotiate(xid, ses);\n\t\tif (rc == -EAGAIN)\n\t\t\trc = -EHOSTDOWN;\n\t}\n\tif (rc == 0) {\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (server->tcpStatus != CifsExiting)\n\t\t\tserver->tcpStatus = CifsGood;\n\t\telse\n\t\t\trc = -EHOSTDOWN;\n\t\tspin_unlock(&GlobalMid_Lock);\n\n\t}\n\n\treturn rc;\n}\n\n\nint cifs_setup_session(unsigned int xid, struct cifsSesInfo *ses,\n\t\t\tstruct nls_table *nls_info)\n{\n\tint rc = 0;\n\tstruct TCP_Server_Info *server = ses->server;\n\n\tses->flags = 0;\n\tses->capabilities = server->capabilities;\n\tif (linuxExtEnabled == 0)\n\t\tses->capabilities &= (~CAP_UNIX);\n\n\tcFYI(1, \"Security Mode: 0x%x Capabilities: 0x%x TimeAdjust: %d\",\n\t\t server->secMode, server->capabilities, server->timeAdj);\n\n\trc = CIFS_SessSetup(xid, ses, nls_info);\n\tif (rc) {\n\t\tcERROR(1, \"Send error in SessSetup = %d\", rc);\n\t} else {\n\t\tmutex_lock(&ses->server->srv_mutex);\n\t\tif (!server->session_estab) {\n\t\t\tserver->session_key.response = ses->auth_key.response;\n\t\t\tserver->session_key.len = ses->auth_key.len;\n\t\t\tserver->sequence_number = 0x2;\n\t\t\tserver->session_estab = true;\n\t\t\tses->auth_key.response = NULL;\n\t\t}\n\t\tmutex_unlock(&server->srv_mutex);\n\n\t\tcFYI(1, \"CIFS Session Established successfully\");\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tses->status = CifsGood;\n\t\tses->need_reconnect = false;\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\tkfree(ses->auth_key.response);\n\tses->auth_key.response = NULL;\n\tses->auth_key.len = 0;\n\tkfree(ses->ntlmssp);\n\tses->ntlmssp = NULL;\n\n\treturn rc;\n}\n\nstatic struct cifsTconInfo *\ncifs_construct_tcon(struct cifs_sb_info *cifs_sb, uid_t fsuid)\n{\n\tstruct cifsTconInfo *master_tcon = cifs_sb_master_tcon(cifs_sb);\n\tstruct cifsSesInfo *ses;\n\tstruct cifsTconInfo *tcon = NULL;\n\tstruct smb_vol *vol_info;\n\tchar username[MAX_USERNAME_SIZE + 1];\n\n\tvol_info = kzalloc(sizeof(*vol_info), GFP_KERNEL);\n\tif (vol_info == NULL) {\n\t\ttcon = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\n\tsnprintf(username, MAX_USERNAME_SIZE, \"krb50x%x\", fsuid);\n\tvol_info->username = username;\n\tvol_info->local_nls = cifs_sb->local_nls;\n\tvol_info->linux_uid = fsuid;\n\tvol_info->cred_uid = fsuid;\n\tvol_info->UNC = master_tcon->treeName;\n\tvol_info->retry = master_tcon->retry;\n\tvol_info->nocase = master_tcon->nocase;\n\tvol_info->local_lease = master_tcon->local_lease;\n\tvol_info->no_linux_ext = !master_tcon->unix_ext;\n\n\t/* FIXME: allow for other secFlg settings */\n\tvol_info->secFlg = CIFSSEC_MUST_KRB5;\n\n\t/* get a reference for the same TCP session */\n\tspin_lock(&cifs_tcp_ses_lock);\n\t++master_tcon->ses->server->srv_count;\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tses = cifs_get_smb_ses(master_tcon->ses->server, vol_info);\n\tif (IS_ERR(ses)) {\n\t\ttcon = (struct cifsTconInfo *)ses;\n\t\tcifs_put_tcp_session(master_tcon->ses->server);\n\t\tgoto out;\n\t}\n\n\ttcon = cifs_get_tcon(ses, vol_info);\n\tif (IS_ERR(tcon)) {\n\t\tcifs_put_smb_ses(ses);\n\t\tgoto out;\n\t}\n\n\tif (ses->capabilities & CAP_UNIX)\n\t\treset_cifs_unix_caps(0, tcon, NULL, vol_info);\nout:\n\tkfree(vol_info);\n\n\treturn tcon;\n}\n\nstatic inline struct tcon_link *\ncifs_sb_master_tlink(struct cifs_sb_info *cifs_sb)\n{\n\treturn cifs_sb->master_tlink;\n}\n\nstruct cifsTconInfo *\ncifs_sb_master_tcon(struct cifs_sb_info *cifs_sb)\n{\n\treturn tlink_tcon(cifs_sb_master_tlink(cifs_sb));\n}\n\nstatic int\ncifs_sb_tcon_pending_wait(void *unused)\n{\n\tschedule();\n\treturn signal_pending(current) ? -ERESTARTSYS : 0;\n}\n\n/* find and return a tlink with given uid */\nstatic struct tcon_link *\ntlink_rb_search(struct rb_root *root, uid_t uid)\n{\n\tstruct rb_node *node = root->rb_node;\n\tstruct tcon_link *tlink;\n\n\twhile (node) {\n\t\ttlink = rb_entry(node, struct tcon_link, tl_rbnode);\n\n\t\tif (tlink->tl_uid > uid)\n\t\t\tnode = node->rb_left;\n\t\telse if (tlink->tl_uid < uid)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn tlink;\n\t}\n\treturn NULL;\n}\n\n/* insert a tcon_link into the tree */\nstatic void\ntlink_rb_insert(struct rb_root *root, struct tcon_link *new_tlink)\n{\n\tstruct rb_node **new = &(root->rb_node), *parent = NULL;\n\tstruct tcon_link *tlink;\n\n\twhile (*new) {\n\t\ttlink = rb_entry(*new, struct tcon_link, tl_rbnode);\n\t\tparent = *new;\n\n\t\tif (tlink->tl_uid > new_tlink->tl_uid)\n\t\t\tnew = &((*new)->rb_left);\n\t\telse\n\t\t\tnew = &((*new)->rb_right);\n\t}\n\n\trb_link_node(&new_tlink->tl_rbnode, parent, new);\n\trb_insert_color(&new_tlink->tl_rbnode, root);\n}\n\n/*\n * Find or construct an appropriate tcon given a cifs_sb and the fsuid of the\n * current task.\n *\n * If the superblock doesn't refer to a multiuser mount, then just return\n * the master tcon for the mount.\n *\n * First, search the rbtree for an existing tcon for this fsuid. If one\n * exists, then check to see if it's pending construction. If it is then wait\n * for construction to complete. Once it's no longer pending, check to see if\n * it failed and either return an error or retry construction, depending on\n * the timeout.\n *\n * If one doesn't exist then insert a new tcon_link struct into the tree and\n * try to construct a new one.\n */\nstruct tcon_link *\ncifs_sb_tlink(struct cifs_sb_info *cifs_sb)\n{\n\tint ret;\n\tuid_t fsuid = current_fsuid();\n\tstruct tcon_link *tlink, *newtlink;\n\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER))\n\t\treturn cifs_get_tlink(cifs_sb_master_tlink(cifs_sb));\n\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\tif (tlink)\n\t\tcifs_get_tlink(tlink);\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tif (tlink == NULL) {\n\t\tnewtlink = kzalloc(sizeof(*tlink), GFP_KERNEL);\n\t\tif (newtlink == NULL)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tnewtlink->tl_uid = fsuid;\n\t\tnewtlink->tl_tcon = ERR_PTR(-EACCES);\n\t\tset_bit(TCON_LINK_PENDING, &newtlink->tl_flags);\n\t\tset_bit(TCON_LINK_IN_TREE, &newtlink->tl_flags);\n\t\tcifs_get_tlink(newtlink);\n\n\t\tspin_lock(&cifs_sb->tlink_tree_lock);\n\t\t/* was one inserted after previous search? */\n\t\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\t\tif (tlink) {\n\t\t\tcifs_get_tlink(tlink);\n\t\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t\t\tkfree(newtlink);\n\t\t\tgoto wait_for_construction;\n\t\t}\n\t\ttlink = newtlink;\n\t\ttlink_rb_insert(&cifs_sb->tlink_tree, tlink);\n\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t} else {\nwait_for_construction:\n\t\tret = wait_on_bit(&tlink->tl_flags, TCON_LINK_PENDING,\n\t\t\t\t  cifs_sb_tcon_pending_wait,\n\t\t\t\t  TASK_INTERRUPTIBLE);\n\t\tif (ret) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\n\t\t/* if it's good, return it */\n\t\tif (!IS_ERR(tlink->tl_tcon))\n\t\t\treturn tlink;\n\n\t\t/* return error if we tried this already recently */\n\t\tif (time_before(jiffies, tlink->tl_time + TLINK_ERROR_EXPIRE)) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-EACCES);\n\t\t}\n\n\t\tif (test_and_set_bit(TCON_LINK_PENDING, &tlink->tl_flags))\n\t\t\tgoto wait_for_construction;\n\t}\n\n\ttlink->tl_tcon = cifs_construct_tcon(cifs_sb, fsuid);\n\tclear_bit(TCON_LINK_PENDING, &tlink->tl_flags);\n\twake_up_bit(&tlink->tl_flags, TCON_LINK_PENDING);\n\n\tif (IS_ERR(tlink->tl_tcon)) {\n\t\tcifs_put_tlink(tlink);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\treturn tlink;\n}\n\n/*\n * periodic workqueue job that scans tcon_tree for a superblock and closes\n * out tcons.\n */\nstatic void\ncifs_prune_tlinks(struct work_struct *work)\n{\n\tstruct cifs_sb_info *cifs_sb = container_of(work, struct cifs_sb_info,\n\t\t\t\t\t\t    prune_tlinks.work);\n\tstruct rb_root *root = &cifs_sb->tlink_tree;\n\tstruct rb_node *node = rb_first(root);\n\tstruct rb_node *tmp;\n\tstruct tcon_link *tlink;\n\n\t/*\n\t * Because we drop the spinlock in the loop in order to put the tlink\n\t * it's not guarded against removal of links from the tree. The only\n\t * places that remove entries from the tree are this function and\n\t * umounts. Because this function is non-reentrant and is canceled\n\t * before umount can proceed, this is safe.\n\t */\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\tnode = rb_first(root);\n\twhile (node != NULL) {\n\t\ttmp = node;\n\t\tnode = rb_next(tmp);\n\t\ttlink = rb_entry(tmp, struct tcon_link, tl_rbnode);\n\n\t\tif (test_bit(TCON_LINK_MASTER, &tlink->tl_flags) ||\n\t\t    atomic_read(&tlink->tl_count) != 0 ||\n\t\t    time_after(tlink->tl_time + TLINK_IDLE_EXPIRE, jiffies))\n\t\t\tcontinue;\n\n\t\tcifs_get_tlink(tlink);\n\t\tclear_bit(TCON_LINK_IN_TREE, &tlink->tl_flags);\n\t\trb_erase(tmp, root);\n\n\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t\tcifs_put_tlink(tlink);\n\t\tspin_lock(&cifs_sb->tlink_tree_lock);\n\t}\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tqueue_delayed_work(system_nrt_wq, &cifs_sb->prune_tlinks,\n\t\t\t\tTLINK_IDLE_EXPIRE);\n}\n"], "filenames": ["fs/cifs/connect.c"], "buggy_code_start_loc": [2834], "buggy_code_end_loc": [2835], "fixing_code_start_loc": [2834], "fixing_code_end_loc": [2835], "type": "CWE-20", "message": "The setup_cifs_sb function in fs/cifs/connect.c in the Linux kernel before 2.6.39 does not properly handle DFS referrals, which allows remote CIFS servers to cause a denial of service (system crash) by placing a referral at the root of a share.", "other": {"cve": {"id": "CVE-2011-3363", "sourceIdentifier": "secalert@redhat.com", "published": "2012-05-24T23:55:02.387", "lastModified": "2023-02-13T01:20:50.530", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The setup_cifs_sb function in fs/cifs/connect.c in the Linux kernel before 2.6.39 does not properly handle DFS referrals, which allows remote CIFS servers to cause a denial of service (system crash) by placing a referral at the root of a share."}, {"lang": "es", "value": "La funci\u00f3n setup_cifs_sb function en fs/cifs/connect.cen el kernel de Linux antes de v2.6.39 no maneja correctamente las referencias de la DFS, lo que permite a servidores CIFS remotos provocar una denegaci\u00f3n de servicio (ca\u00edda del sistema) mediante la colocaci\u00f3n de una derivaci\u00f3n en la ra\u00edz de una acci\u00f3n."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:A/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:A/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "ADJACENT_NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 6.1}, "baseSeverity": "MEDIUM", "exploitabilityScore": 6.5, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.6.39", "matchCriteriaId": "176353CE-F17E-4776-AD9F-19014DA75B76"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:4.0:*:*:*:*:*:*:*", "matchCriteriaId": "6172AF57-B26D-45F8-BE3A-F75ABDF28F49"}]}]}], "references": [{"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=70945643722ffeac779d2529a348f99567fa5c33", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2011/09/14/12", "source": "secalert@redhat.com", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=738291", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/70945643722ffeac779d2529a348f99567fa5c33", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/70945643722ffeac779d2529a348f99567fa5c33"}}