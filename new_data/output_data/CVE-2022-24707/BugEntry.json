{"buggy_code": ["<?php\n/* Copyright (c) Anuko International Ltd. https://www.anuko.com\nLicense: See license.txt */\n\n// Report all errors except E_NOTICE and E_STRICT.\n// Ignoring E_STRICT is here because PEAR 1.9.4 that we use is not E_STRICT compliant.\nif (!defined('E_STRICT')) define('E_STRICT', 2048);\n// if (!defined('E_DEPRECATED')) define('E_DEPRECATED', 8192);\nerror_reporting(E_ALL & ~E_NOTICE & ~E_STRICT); // & ~E_DEPRECATED);\n// E_ALL tends to change as PHP evolves, therefore we use & here instead of exclusive OR (^).\n\n// Disable displaying errors on screen.\nini_set('display_errors', 'Off');\n\ndefine(\"APP_VERSION\", \"1.20.0.5641\");\ndefine(\"APP_DIR\", dirname(__FILE__));\ndefine(\"LIBRARY_DIR\", APP_DIR.\"/WEB-INF/lib\");\ndefine(\"TEMPLATE_DIR\", APP_DIR.\"/WEB-INF/templates\");\n// Date format for database and URI parameters.\ndefine('DB_DATEFORMAT', '%Y-%m-%d');\ndefine('MAX_RANK', 512); // Max user rank.\n\nrequire_once(LIBRARY_DIR.'/common.lib.php');\n\n// Require the configuration file with application settings.\nif (!file_exists(APP_DIR.\"/WEB-INF/config.php\")) die (\"WEB-INF/config.php file does not exist.\");\nrequire_once(\"WEB-INF/config.php\");\n// Check whether DSN is defined.\nif (!defined(\"DSN\")) {\n  die (\"DSN value is not defined. Check your config.php file.\");\n}\n\n// Depending on DSN, require either mysqli or mysql extensions.\nif (strrpos(DSN, 'mysqli://', -strlen(DSN)) !== FALSE) {\n  check_extension('mysqli'); // DSN starts with mysqli:// - require mysqli extension.\n}\nif (strrpos(DSN, 'mysql://', -strlen(DSN)) !== FALSE) {\n  check_extension('mysql');  // DSN starts with mysql:// - require mysql extension.\n}\n\n// Require other extensions.\ncheck_extension('mbstring');\n\n// If auth params are not defined (in config.php) - initialize with an empty array.\nif (!isset($GLOBALS['AUTH_MODULE_PARAMS']) || !is_array($GLOBALS['AUTH_MODULE_PARAMS']))\n  $GLOBALS['AUTH_MODULE_PARAMS'] = array();\n\n// Smarty initialization.\nimport('smarty.Smarty');\n$smarty = new Smarty;\n$smarty->use_sub_dirs = false;\n$smarty->template_dir = TEMPLATE_DIR;\n$smarty->compile_dir  = TEMPLATE_DIR.'_c';\n\n// Note: these 3 settings below used to be in .htaccess file. Moved them here to eliminate \"error 500\" problems\n// with some shared hostings that do not have AllowOverride Options or AllowOverride All in their apache configurations.\n// Change http cache expiration time to 1 minute.\nsession_cache_expire(1);\n\n$phpsessid_ttl = defined('PHPSESSID_TTL') ? PHPSESSID_TTL : 60*60*24;\n// Set lifetime for garbage collection.\nini_set('session.gc_maxlifetime', $phpsessid_ttl);\n// Set PHP session path, if defined to avoid garbage collection interference from other scripts.\nif (defined('PHP_SESSION_PATH') && realpath(PHP_SESSION_PATH)) {\n  ini_set('session.save_path', realpath(PHP_SESSION_PATH));\n  ini_set('session.gc_probability', 1);\n}\n\n// \"tt_\" prefix is to avoid sharing session with other PHP apps that do not name session.\nif (!defined('SESSION_COOKIE_NAME')) define('SESSION_COOKIE_NAME', 'tt_PHPSESSID');\nif (!defined('LOGIN_COOKIE_NAME')) define('LOGIN_COOKIE_NAME', 'tt_login');\n\n// Set session cookie lifetime.\nsession_set_cookie_params($phpsessid_ttl);\nif (isset($_COOKIE[SESSION_COOKIE_NAME])) {\n  // Extend PHP session cookie lifetime by PHPSESSID_TTL (if defined, otherwise 24 hours) \n  // so that users don't have to re-login during this period from now. \n  setcookie(SESSION_COOKIE_NAME, $_COOKIE[SESSION_COOKIE_NAME],  time() + $phpsessid_ttl, '/');\n}\n\n// Start or resume PHP session.\nsession_name(SESSION_COOKIE_NAME);\n@session_start();\n\n// Authorization.\nimport('Auth');\n$auth = Auth::factory(AUTH_MODULE, $GLOBALS['AUTH_MODULE_PARAMS']);\n\n// Some defines we'll need.\n//\ndefine('RESOURCE_DIR', APP_DIR.'/WEB-INF/resources');\ndefine('COOKIE_EXPIRE', 60*60*24*30); // Cookies expire in 30 days.\n\n// Status values for projects, users, etc.\ndefine('ACTIVE', 1);\ndefine('INACTIVE', 0);\n// define('DELETED', -1); // DELETED items should have a NULL status. This allows us to have duplicate NULL status entries with existing indexes.\n\n// Definitions for tracking mode types.\ndefine('MODE_TIME', 0); // Tracking time only. There are no projects or tasks.\ndefine('MODE_PROJECTS', 1); // Tracking time per projects. There are no tasks.\ndefine('MODE_PROJECTS_AND_TASKS', 2); // Tracking time for projects and tasks.\n\n// Definitions of types for time records.\ndefine('TYPE_ALL', 0); // Time record can be specified with either duration or start and finish times.\ndefine('TYPE_START_FINISH', 1); // Time record has start and finish times.\ndefine('TYPE_DURATION', 2); // Time record has only duration, no start and finish times.\n\ndefine('CHARSET', 'utf-8');\n\ndate_default_timezone_set(@date_default_timezone_get());\n\n// Initialize global objects that are needed for the application.\nimport('html.HttpRequest');\n$request = new ttHttpRequest();\n\nimport('form.ActionErrors');\n$err = new ActionErrors(); // Error messages for user.\n$msg = new ActionErrors(); // Notification messages (not errrors) for user.\n\n// Create an instance of ttUser class. This gets us most of user details.\nimport('ttUser');\n$user = new ttUser(null, $auth->getUserId());\nif ($user->custom_logo) {\n  $smarty->assign('custom_logo', 'img/'.$user->group_id.'.png');\n  $smarty->assign('mobile_custom_logo', '../img/'.$user->group_id.'.png');\n}\n$smarty->assign('user', $user);\n\n// Localization.\nimport('I18n');\n$i18n = new I18n();\n\n// Determine the language to use.\n$lang = $user->lang;\nif (!$lang) {\n  if (defined('LANG_DEFAULT'))\n    $lang = LANG_DEFAULT;\n\n  // If we still do not have the language get it from the browser.\n  if (!$lang) {\n    $lang = $i18n->getBrowserLanguage();\n\n    // Finally - English is the default.\n    if (!$lang) {\n      $lang = 'en';\n    }\n  }\n}\n\n// Load i18n file.\n$i18n->load($lang);\n\n// Assign things for smarty to use in template files.\n$smarty->assign('i18n', $i18n->keys);\n$smarty->assign('err', $err);\n$smarty->assign('msg', $msg);\n\n// TODO: move this code out of here to the files that use it.\n\n// We use js/strftime.js to print dates in JavaScript (in DateField controls).\n// One of our date formats (%d.%m.%Y %a) prints a localized short weekday name (%a).\n// The init_js_date_locale function iniitializes Date.ext.locales array in js/strftime.js for our language\n// so that we could print localized short weekday names.\n//\n// JavaScript usage (see http://hacks.bluesmoon.info/strftime/localisation.html).\n//\n// var d = new Date();\n// d.locale = \"fr\";           // Remember to initialize locale.\n// d.strftime(\"%d.%m.%Y %a\"); // This will output a localized %a as in \"31.05.2013 Ven\"\n\n// Initialize date locale for JavaScript.\ninit_js_date_locale();\n\nfunction init_js_date_locale()\n{\n  global $i18n, $smarty;\n  $lang = $i18n->lang;\n\n  $days = $i18n->weekdayNames;\n  $short_day_names = array();\n  foreach($days as $k => $v) {\n    $short_day_names[$k] = mb_substr($v, 0, 3, 'utf-8');\n  }\n\n  /*\n  $months = $i18n->monthNames;\n  $short_month_names = array();\n  foreach ($months as $k => $v) {\n    $short_month_names[$k] = mb_substr($v, 0, 3, 'utf-8');\n  }\n  $js = \"Date.ext.locales['$lang'] = {\n      a: ['\" . join(\"', '\", $short_day_names) . \"'],\n      A: ['\" . join(\"', '\", $days) . \"'],\n      b: ['\" . join(\"', '\", $short_month_names) . \"'],\n      B: ['\" . join(\"', '\", $months) . \"'],\n      c: '%a %d %b %Y %T %Z',\n      p: ['', ''],\n      P: ['', ''],\n      x: '%Y-%m-%d',\n      X: '%T'\n    };\"; */\n  // We use %a in one of date formats. Therefore, simplified code here (instead of the above block).\n  // %p is also used on the Profile page in 12-hour time format example. Note that %p is not localized.\n  $js = \"Date.ext.locales['$lang'] = {\n      a: ['\" . join(\"', '\", $short_day_names) . \"'],\n      p: ['AM', 'PM']\n    };\";\n  $smarty->assign('js_date_locale', $js);\n}\n", "<?php\n/* Copyright (c) Anuko International Ltd. https://www.anuko.com\nLicense: See license.txt */\n\nrequire_once('initialize.php');\nimport('form.Form');\nimport('ttUserHelper');\nimport('ttGroupHelper');\nimport('ttClientHelper');\nimport('ttTimeHelper');\nimport('DateAndTime');\n\n// Access check.\nif (!ttAccessAllowed('track_own_time')) {\n  header('Location: access_denied.php');\n  exit();\n}\nif (!$user->isPluginEnabled('pu')) {\n  header('Location: feature_disabled.php');\n  exit();\n}\nif ($request->isPost()) {\n  // Validate that browser_today parameter is in correct format.\n  $browser_today = $request->getParameter('browser_today');\n  if ($browser_today && !ttValidDbDateFormatDate($browser_today)) {\n    header('Location: access_denied.php');\n    exit();\n  }\n}\n// End of access checks.\n\n$showClient = $user->isPluginEnabled('cl');\n$showBillable = $user->isPluginEnabled('iv');\n$trackingMode = $user->getTrackingMode();\n$showProject = MODE_PROJECTS == $trackingMode || MODE_PROJECTS_AND_TASKS == $trackingMode;\n$showTask = MODE_PROJECTS_AND_TASKS == $trackingMode;\n$taskRequired = false;\nif ($showTask) $taskRequired = $user->getConfigOption('task_required');\n\n// Initialize and store date in session.\n$cl_date  = $request->getParameter('date', @$_SESSION['date']);\n$selected_date = new DateAndTime(DB_DATEFORMAT, $cl_date);\nif($selected_date->isError())\n  $selected_date = new DateAndTime(DB_DATEFORMAT);\nif(!$cl_date)\n  $cl_date = $selected_date->toString(DB_DATEFORMAT);\n$_SESSION['date'] = $cl_date;\n// TODO: for timer page we may limit the day to today only.\n\n// Use custom fields plugin if it is enabled.\nif ($user->isPluginEnabled('cf')) {\n  require_once('plugins/CustomFields.class.php');\n  $custom_fields = new CustomFields();\n  $smarty->assign('custom_fields', $custom_fields);\n}\n\n// Obtain uncompleted record. Assumption is that only 1 uncompleted record is allowed.\n$uncompleted = ttTimeHelper::getUncompleted($user->getUser());\n$enable_controls = ($uncompleted == null);\n\n// Initialize variables.\n$cl_start = trim($request->getParameter('browser_time'));\n$cl_finish = trim($request->getParameter('browser_time'));\n$cl_duration = $cl_note = null;\n// Disabled controls are not posted. Therefore, && $enable_controls condition in several places below.\n// This allows us to get values from session when controls are disabled and reset to null when not.\n$cl_billable = 1;\nif ($user->isPluginEnabled('iv')) {\n  $cl_billable = $request->getParameter('billable', ($request->isPost() && $enable_controls ? null : @$_SESSION['billable']));\n  $_SESSION['billable'] = $cl_billable;\n}\n$cl_client = $request->getParameter('client', ($request->isPost() && $enable_controls ? null : @$_SESSION['client']));\n$_SESSION['client'] = $cl_client;\n$cl_project = $request->getParameter('project', ($request->isPost() && $enable_controls ? null : @$_SESSION['project']));\n$_SESSION['project'] = $cl_project;\n$cl_task = $request->getParameter('task', ($request->isPost() && $enable_controls ? null : @$_SESSION['task']));\n$_SESSION['task'] = $cl_task;\n\n// Handle time custom fields.\n$timeCustomFields = array();\nif (isset($custom_fields) && $custom_fields->timeFields) {\n  foreach ($custom_fields->timeFields as $timeField) {\n    $control_name = 'time_field_'.$timeField['id'];\n    $cl_control_name = $request->getParameter($control_name, ($request->isPost() && $enable_controls ? null : @$_SESSION[$control_name]));\n    $_SESSION[$control_name] = $cl_control_name;\n    $timeCustomFields[$timeField['id']] = array('field_id' => $timeField['id'],\n      'control_name' => $control_name,\n      'label' => $timeField['label'],\n      'type' => $timeField['type'],\n      'required' => $timeField['required'],\n      'value' => trim($cl_control_name));\n  }\n}\n\n// Elements of timeRecordForm.\n$form = new Form('timeRecordForm');\n\n// Dropdown for clients in MODE_TIME. Use all active clients.\nif (MODE_TIME == $trackingMode && $showClient) {\n    $active_clients = ttGroupHelper::getActiveClients(true);\n    $form->addInput(array('type'=>'combobox',\n      'onchange'=>'fillProjectDropdown(this.value);',\n      'name'=>'client',\n      'enable'=>$enable_controls,\n      'value'=>$cl_client,\n      'data'=>$active_clients,\n      'datakeys'=>array('id', 'name'),\n      'empty'=>array(''=>$i18n->get('dropdown.select'))));\n  // Note: in other modes the client list is filtered to relevant clients only. See below.\n}\n\n// Billable checkbox.\nif ($showBillable) {\n  $form->addInput(array('type'=>'checkbox','name'=>'billable','value'=>$cl_billable,'enable'=>$enable_controls));\n}\n\n// If we have time custom fields - add controls for them.\nif (isset($custom_fields) && $custom_fields->timeFields) {\n  foreach ($custom_fields->timeFields as $timeField) {\n    $field_name = 'time_field_'.$timeField['id'];\n    if ($timeField['type'] == CustomFields::TYPE_TEXT) {\n      $form->addInput(array('type'=>'text',\n        'name'=>$field_name,\n        'enable'=>$enable_controls,\n        'value'=>$timeCustomFields[$timeField['id']]['value']));\n    } elseif ($timeField['type'] == CustomFields::TYPE_DROPDOWN) {\n      $form->addInput(array('type'=>'combobox','name'=>$field_name,\n      'data'=>CustomFields::getOptions($timeField['id']),\n      'value'=>$timeCustomFields[$timeField['id']]['value'],\n      'enable'=>$enable_controls,\n      'empty'=>array(''=>$i18n->get('dropdown.select'))));\n    }\n  }\n}\n\n// If we show project dropdown, add controls for project and client.\n$project_list = $client_list = array();\nif ($showProject) {\n  // Dropdown for projects assigned to user.\n  $project_list = $user->getAssignedProjects();\n  $form->addInput(array('type'=>'combobox',\n    'onchange'=>'fillTaskDropdown(this.value);',\n    'name'=>'project',\n    'enable'=>$enable_controls,\n    'value'=>$cl_project,\n    'data'=>$project_list,\n    'datakeys'=>array('id','name'),\n    'empty'=>array(''=>$i18n->get('dropdown.select'))));\n\n  // Client dropdown.\n  if ($showClient) {\n    $active_clients = ttGroupHelper::getActiveClients(true);\n    // We need an array of assigned project ids to do some trimming.\n    foreach($project_list as $project)\n      $projects_assigned_to_user[] = $project['id'];\n\n    // Build a client list out of active clients. Use only clients that are relevant to user.\n    // Also trim their associated project list to only assigned projects (to user).\n    foreach($active_clients as $client) {\n      $projects_assigned_to_client = explode(',', $client['projects']);\n      $intersection = array_intersect($projects_assigned_to_client, $projects_assigned_to_user);\n      if ($intersection) {\n        $client['projects'] = implode(',', $intersection);\n        $client_list[] = $client;\n      }\n    }\n    $form->addInput(array('type'=>'combobox',\n      'onchange'=>'fillProjectDropdown(this.value);',\n      'name'=>'client',\n      'enable'=>$enable_controls,\n      'value'=>$cl_client,\n      'data'=>$client_list,\n      'datakeys'=>array('id', 'name'),\n      'empty'=>array(''=>$i18n->get('dropdown.select'))));\n  }\n}\n\n// Task dropdown.\n$task_list = array();\nif ($showTask) {\n  $task_list = ttGroupHelper::getActiveTasks();\n  $form->addInput(array('type'=>'combobox',\n    'name'=>'task',\n    'enable'=>$enable_controls,\n    'value'=>$cl_task,\n    'data'=>$task_list,\n    'datakeys'=>array('id','name'),\n    'empty'=>array(''=>$i18n->get('dropdown.select'))));\n}\n\n// A hidden control for today's date from user's browser.\n$form->addInput(array('type'=>'hidden','name'=>'browser_today','value'=>'')); // User current date, which gets filled in on button click.\n\n// A hidden control for current time from user's browser.\n$form->addInput(array('type'=>'hidden','name'=>'browser_time','value'=>''));  // User current time, which gets filled in on button click.\n\n// Start and stop buttons.\n$enable_start = $uncompleted ? false : true;\nif (!$uncompleted)\n  $form->addInput(array('type'=>'submit','name'=>'btn_start','onclick'=>'browser_time.value=get_time()','value'=>$i18n->get('button.start'),'enable'=>$enable_start));\nelse\n  $form->addInput(array('type'=>'submit','name'=>'btn_stop','onclick'=>'browser_time.value=get_time()','value'=>$i18n->get('button.stop'),'enable'=>!$enable_start));\n\n// Submit.\nif ($request->isPost()) {\n  if ($request->getParameter('btn_start')) {\n    // Start button clicked. We need to create a new uncompleted record with only the start time.\n    $cl_finish = null;\n\n    // Validate user input.\n    if ($showClient && $user->isOptionEnabled('client_required') && !$cl_client)\n      $err->add($i18n->get('error.client'));\n    // Validate input in time custom fields.\n    if (isset($custom_fields) && $custom_fields->timeFields) {\n      foreach ($timeCustomFields as $timeField) {\n        // Validation is the same for text and dropdown fields.\n        if (!ttValidString($timeField['value'], !$timeField['required'])) $err->add($i18n->get('error.field'), htmlspecialchars($timeField['label']));\n      }\n    }\n    if ($showProject) {\n      if (!$cl_project) $err->add($i18n->get('error.project'));\n    }\n    if ($showTask && $taskRequired) {\n      if (!$cl_task) $err->add($i18n->get('error.task'));\n    }\n    // Finished validating user input.\n\n    // Prohibit creating entries in future.\n    if (!$user->isOptionEnabled('future_entries')) {\n      $browser_today = new DateAndTime(DB_DATEFORMAT, $request->getParameter('browser_today', null));\n      if ($selected_date->after($browser_today))\n        $err->add($i18n->get('error.future_date'));\n    }\n\n    // Prohibit creating time entries in locked interval.\n    if ($user->isDateLocked($selected_date))\n      $err->add($i18n->get('error.range_locked'));\n\n    // Prohibit creating another uncompleted record.\n    if ($err->no() && $uncompleted) {\n      $err->add($i18n->get('error.uncompleted_exists').\" <a href = 'time_edit.php?id=\".$not_completed_rec['id'].\"'>\".$i18n->get('error.goto_uncompleted').\"</a>\");\n    }\n\n    // Prohibit creating an overlapping record.\n    if ($err->no()) {\n      if (ttTimeHelper::overlaps($user->getUser(), $cl_date, $cl_start, $cl_finish))\n        $err->add($i18n->get('error.overlap'));\n    }\n\n    if ($err->no()) {\n      $id = ttTimeHelper::insert(array(\n        'date' => $cl_date,\n        'client' => $cl_client,\n        'project' => $cl_project,\n        'task' => $cl_task,\n        'start' => $cl_start,\n        'finish' => $cl_finish,\n        'duration' => $cl_duration,\n        'note' => $cl_note,\n        'billable' => $cl_billable));\n\n      // Insert time custom fields if we have them.\n      $result = true;\n      if ($id && isset($custom_fields) && $custom_fields->timeFields) {\n        $result = $custom_fields->insertTimeFields($id, $timeCustomFields);\n      }\n\n      if ($id && $result) {\n        header('Location: puncher.php');\n        exit();\n      }\n      $err->add($i18n->get('error.db'));\n    }\n  }\n  if ($request->getParameter('btn_stop')) {\n    // Stop button clicked. We need to finish an uncompleted record in progress.\n    $record = ttTimeHelper::getRecord($uncompleted['id']);\n\n    // Can we complete this record?\n    if (ttTimeHelper::isValidInterval($record['start'], $cl_finish) // finish time is greater than start time\n      && !ttTimeHelper::overlaps($user->getUser(), $cl_date, $record['start'], $cl_finish)) { // no overlap\n      $res = ttTimeHelper::update(array(\n        'id'=>$record['id'],\n        'date'=>$cl_date,\n        'client'=>$record['client_id'],\n        'project'=>$record['project_id'],\n        'task'=>$record['task_id'],\n        'start'=>$record['start'],\n        'finish'=>$cl_finish,\n        'note'=>$record['comment'],\n        'billable'=>$record['billable']));\n      if ($res) {\n        header('Location: puncher.php');\n        exit();\n      } else\n        $err->add($i18n->get('error.db'));\n    } else {\n      // Cannot complete, redirect for manual edit.\n      header('Location: time_edit.php?id='.$record['id']);\n      exit();\n    }\n  }\n} // isPost\n\n$week_total = ttTimeHelper::getTimeForWeek($cl_date);\n$timeRecords = ttTimeHelper::getRecords($cl_date);\n\n$smarty->assign('week_total', $week_total);\n$smarty->assign('uncompleted', $uncompleted);\n$smarty->assign('show_client', $showClient);\n$smarty->assign('show_billable', $showBillable);\n$smarty->assign('show_project', $showProject);\n$smarty->assign('show_task', $showTask);\n$smarty->assign('task_required', $taskRequired);\n$smarty->assign('time_records', ttTimeHelper::getRecords($cl_date));\n$smarty->assign('day_total', ttTimeHelper::getTimeForDay($cl_date));\n$smarty->assign('time_records', $timeRecords);\n$smarty->assign('show_record_custom_fields', $user->isOptionEnabled('record_custom_fields'));\n$smarty->assign('show_start', true);\n$smarty->assign('client_list', $client_list);\n$smarty->assign('project_list', $project_list);\n$smarty->assign('task_list', $task_list);\n$smarty->assign('forms', array($form->getName()=>$form->toArray()));\n$smarty->assign('onload', 'onLoad=\"fillDropdowns()\"');\n$smarty->assign('timestring', $selected_date->toString($user->date_format));\n$smarty->assign('title', $i18n->get('title.puncher'));\n$smarty->assign('content_page_name', 'puncher.tpl');\n$smarty->display('index.tpl');\n"], "fixing_code": ["<?php\n/* Copyright (c) Anuko International Ltd. https://www.anuko.com\nLicense: See license.txt */\n\n// Report all errors except E_NOTICE and E_STRICT.\n// Ignoring E_STRICT is here because PEAR 1.9.4 that we use is not E_STRICT compliant.\nif (!defined('E_STRICT')) define('E_STRICT', 2048);\n// if (!defined('E_DEPRECATED')) define('E_DEPRECATED', 8192);\nerror_reporting(E_ALL & ~E_NOTICE & ~E_STRICT); // & ~E_DEPRECATED);\n// E_ALL tends to change as PHP evolves, therefore we use & here instead of exclusive OR (^).\n\n// Disable displaying errors on screen.\nini_set('display_errors', 'Off');\n\ndefine(\"APP_VERSION\", \"1.20.0.5642\");\ndefine(\"APP_DIR\", dirname(__FILE__));\ndefine(\"LIBRARY_DIR\", APP_DIR.\"/WEB-INF/lib\");\ndefine(\"TEMPLATE_DIR\", APP_DIR.\"/WEB-INF/templates\");\n// Date format for database and URI parameters.\ndefine('DB_DATEFORMAT', '%Y-%m-%d');\ndefine('MAX_RANK', 512); // Max user rank.\n\nrequire_once(LIBRARY_DIR.'/common.lib.php');\n\n// Require the configuration file with application settings.\nif (!file_exists(APP_DIR.\"/WEB-INF/config.php\")) die (\"WEB-INF/config.php file does not exist.\");\nrequire_once(\"WEB-INF/config.php\");\n// Check whether DSN is defined.\nif (!defined(\"DSN\")) {\n  die (\"DSN value is not defined. Check your config.php file.\");\n}\n\n// Depending on DSN, require either mysqli or mysql extensions.\nif (strrpos(DSN, 'mysqli://', -strlen(DSN)) !== FALSE) {\n  check_extension('mysqli'); // DSN starts with mysqli:// - require mysqli extension.\n}\nif (strrpos(DSN, 'mysql://', -strlen(DSN)) !== FALSE) {\n  check_extension('mysql');  // DSN starts with mysql:// - require mysql extension.\n}\n\n// Require other extensions.\ncheck_extension('mbstring');\n\n// If auth params are not defined (in config.php) - initialize with an empty array.\nif (!isset($GLOBALS['AUTH_MODULE_PARAMS']) || !is_array($GLOBALS['AUTH_MODULE_PARAMS']))\n  $GLOBALS['AUTH_MODULE_PARAMS'] = array();\n\n// Smarty initialization.\nimport('smarty.Smarty');\n$smarty = new Smarty;\n$smarty->use_sub_dirs = false;\n$smarty->template_dir = TEMPLATE_DIR;\n$smarty->compile_dir  = TEMPLATE_DIR.'_c';\n\n// Note: these 3 settings below used to be in .htaccess file. Moved them here to eliminate \"error 500\" problems\n// with some shared hostings that do not have AllowOverride Options or AllowOverride All in their apache configurations.\n// Change http cache expiration time to 1 minute.\nsession_cache_expire(1);\n\n$phpsessid_ttl = defined('PHPSESSID_TTL') ? PHPSESSID_TTL : 60*60*24;\n// Set lifetime for garbage collection.\nini_set('session.gc_maxlifetime', $phpsessid_ttl);\n// Set PHP session path, if defined to avoid garbage collection interference from other scripts.\nif (defined('PHP_SESSION_PATH') && realpath(PHP_SESSION_PATH)) {\n  ini_set('session.save_path', realpath(PHP_SESSION_PATH));\n  ini_set('session.gc_probability', 1);\n}\n\n// \"tt_\" prefix is to avoid sharing session with other PHP apps that do not name session.\nif (!defined('SESSION_COOKIE_NAME')) define('SESSION_COOKIE_NAME', 'tt_PHPSESSID');\nif (!defined('LOGIN_COOKIE_NAME')) define('LOGIN_COOKIE_NAME', 'tt_login');\n\n// Set session cookie lifetime.\nsession_set_cookie_params($phpsessid_ttl);\nif (isset($_COOKIE[SESSION_COOKIE_NAME])) {\n  // Extend PHP session cookie lifetime by PHPSESSID_TTL (if defined, otherwise 24 hours) \n  // so that users don't have to re-login during this period from now. \n  setcookie(SESSION_COOKIE_NAME, $_COOKIE[SESSION_COOKIE_NAME],  time() + $phpsessid_ttl, '/');\n}\n\n// Start or resume PHP session.\nsession_name(SESSION_COOKIE_NAME);\n@session_start();\n\n// Authorization.\nimport('Auth');\n$auth = Auth::factory(AUTH_MODULE, $GLOBALS['AUTH_MODULE_PARAMS']);\n\n// Some defines we'll need.\n//\ndefine('RESOURCE_DIR', APP_DIR.'/WEB-INF/resources');\ndefine('COOKIE_EXPIRE', 60*60*24*30); // Cookies expire in 30 days.\n\n// Status values for projects, users, etc.\ndefine('ACTIVE', 1);\ndefine('INACTIVE', 0);\n// define('DELETED', -1); // DELETED items should have a NULL status. This allows us to have duplicate NULL status entries with existing indexes.\n\n// Definitions for tracking mode types.\ndefine('MODE_TIME', 0); // Tracking time only. There are no projects or tasks.\ndefine('MODE_PROJECTS', 1); // Tracking time per projects. There are no tasks.\ndefine('MODE_PROJECTS_AND_TASKS', 2); // Tracking time for projects and tasks.\n\n// Definitions of types for time records.\ndefine('TYPE_ALL', 0); // Time record can be specified with either duration or start and finish times.\ndefine('TYPE_START_FINISH', 1); // Time record has start and finish times.\ndefine('TYPE_DURATION', 2); // Time record has only duration, no start and finish times.\n\ndefine('CHARSET', 'utf-8');\n\ndate_default_timezone_set(@date_default_timezone_get());\n\n// Initialize global objects that are needed for the application.\nimport('html.HttpRequest');\n$request = new ttHttpRequest();\n\nimport('form.ActionErrors');\n$err = new ActionErrors(); // Error messages for user.\n$msg = new ActionErrors(); // Notification messages (not errrors) for user.\n\n// Create an instance of ttUser class. This gets us most of user details.\nimport('ttUser');\n$user = new ttUser(null, $auth->getUserId());\nif ($user->custom_logo) {\n  $smarty->assign('custom_logo', 'img/'.$user->group_id.'.png');\n  $smarty->assign('mobile_custom_logo', '../img/'.$user->group_id.'.png');\n}\n$smarty->assign('user', $user);\n\n// Localization.\nimport('I18n');\n$i18n = new I18n();\n\n// Determine the language to use.\n$lang = $user->lang;\nif (!$lang) {\n  if (defined('LANG_DEFAULT'))\n    $lang = LANG_DEFAULT;\n\n  // If we still do not have the language get it from the browser.\n  if (!$lang) {\n    $lang = $i18n->getBrowserLanguage();\n\n    // Finally - English is the default.\n    if (!$lang) {\n      $lang = 'en';\n    }\n  }\n}\n\n// Load i18n file.\n$i18n->load($lang);\n\n// Assign things for smarty to use in template files.\n$smarty->assign('i18n', $i18n->keys);\n$smarty->assign('err', $err);\n$smarty->assign('msg', $msg);\n\n// TODO: move this code out of here to the files that use it.\n\n// We use js/strftime.js to print dates in JavaScript (in DateField controls).\n// One of our date formats (%d.%m.%Y %a) prints a localized short weekday name (%a).\n// The init_js_date_locale function iniitializes Date.ext.locales array in js/strftime.js for our language\n// so that we could print localized short weekday names.\n//\n// JavaScript usage (see http://hacks.bluesmoon.info/strftime/localisation.html).\n//\n// var d = new Date();\n// d.locale = \"fr\";           // Remember to initialize locale.\n// d.strftime(\"%d.%m.%Y %a\"); // This will output a localized %a as in \"31.05.2013 Ven\"\n\n// Initialize date locale for JavaScript.\ninit_js_date_locale();\n\nfunction init_js_date_locale()\n{\n  global $i18n, $smarty;\n  $lang = $i18n->lang;\n\n  $days = $i18n->weekdayNames;\n  $short_day_names = array();\n  foreach($days as $k => $v) {\n    $short_day_names[$k] = mb_substr($v, 0, 3, 'utf-8');\n  }\n\n  /*\n  $months = $i18n->monthNames;\n  $short_month_names = array();\n  foreach ($months as $k => $v) {\n    $short_month_names[$k] = mb_substr($v, 0, 3, 'utf-8');\n  }\n  $js = \"Date.ext.locales['$lang'] = {\n      a: ['\" . join(\"', '\", $short_day_names) . \"'],\n      A: ['\" . join(\"', '\", $days) . \"'],\n      b: ['\" . join(\"', '\", $short_month_names) . \"'],\n      B: ['\" . join(\"', '\", $months) . \"'],\n      c: '%a %d %b %Y %T %Z',\n      p: ['', ''],\n      P: ['', ''],\n      x: '%Y-%m-%d',\n      X: '%T'\n    };\"; */\n  // We use %a in one of date formats. Therefore, simplified code here (instead of the above block).\n  // %p is also used on the Profile page in 12-hour time format example. Note that %p is not localized.\n  $js = \"Date.ext.locales['$lang'] = {\n      a: ['\" . join(\"', '\", $short_day_names) . \"'],\n      p: ['AM', 'PM']\n    };\";\n  $smarty->assign('js_date_locale', $js);\n}\n", "<?php\n/* Copyright (c) Anuko International Ltd. https://www.anuko.com\nLicense: See license.txt */\n\nrequire_once('initialize.php');\nimport('form.Form');\nimport('ttUserHelper');\nimport('ttGroupHelper');\nimport('ttClientHelper');\nimport('ttTimeHelper');\nimport('DateAndTime');\n\n// Access check.\nif (!ttAccessAllowed('track_own_time')) {\n  header('Location: access_denied.php');\n  exit();\n}\nif (!$user->isPluginEnabled('pu')) {\n  header('Location: feature_disabled.php');\n  exit();\n}\n// If we are passed in a date, make sure it is in correct format.\n// TODO: redo this temporary sql injection fix as we are not supposed to pass a date.\n$date = $request->getParameter('date');\nif ($date && !ttValidDbDateFormatDate($date)) {\n  header('Location: access_denied.php');\n  exit();\n}\nif ($request->isPost()) {\n  // Validate that browser_today parameter is in correct format.\n  $browser_today = $request->getParameter('browser_today');\n  if ($browser_today && !ttValidDbDateFormatDate($browser_today)) {\n    header('Location: access_denied.php');\n    exit();\n  }\n}\n// End of access checks.\n\n$showClient = $user->isPluginEnabled('cl');\n$showBillable = $user->isPluginEnabled('iv');\n$trackingMode = $user->getTrackingMode();\n$showProject = MODE_PROJECTS == $trackingMode || MODE_PROJECTS_AND_TASKS == $trackingMode;\n$showTask = MODE_PROJECTS_AND_TASKS == $trackingMode;\n$taskRequired = false;\nif ($showTask) $taskRequired = $user->getConfigOption('task_required');\n\n// Initialize and store date in session.\n$cl_date  = $request->getParameter('date', @$_SESSION['date']);\n$selected_date = new DateAndTime(DB_DATEFORMAT, $cl_date);\nif($selected_date->isError())\n  $selected_date = new DateAndTime(DB_DATEFORMAT);\nif(!$cl_date)\n  $cl_date = $selected_date->toString(DB_DATEFORMAT);\n$_SESSION['date'] = $cl_date;\n// TODO: for timer page we may limit the day to today only.\n\n// Use custom fields plugin if it is enabled.\nif ($user->isPluginEnabled('cf')) {\n  require_once('plugins/CustomFields.class.php');\n  $custom_fields = new CustomFields();\n  $smarty->assign('custom_fields', $custom_fields);\n}\n\n// Obtain uncompleted record. Assumption is that only 1 uncompleted record is allowed.\n$uncompleted = ttTimeHelper::getUncompleted($user->getUser());\n$enable_controls = ($uncompleted == null);\n\n// Initialize variables.\n$cl_start = trim($request->getParameter('browser_time'));\n$cl_finish = trim($request->getParameter('browser_time'));\n$cl_duration = $cl_note = null;\n// Disabled controls are not posted. Therefore, && $enable_controls condition in several places below.\n// This allows us to get values from session when controls are disabled and reset to null when not.\n$cl_billable = 1;\nif ($user->isPluginEnabled('iv')) {\n  $cl_billable = $request->getParameter('billable', ($request->isPost() && $enable_controls ? null : @$_SESSION['billable']));\n  $_SESSION['billable'] = $cl_billable;\n}\n$cl_client = $request->getParameter('client', ($request->isPost() && $enable_controls ? null : @$_SESSION['client']));\n$_SESSION['client'] = $cl_client;\n$cl_project = $request->getParameter('project', ($request->isPost() && $enable_controls ? null : @$_SESSION['project']));\n$_SESSION['project'] = $cl_project;\n$cl_task = $request->getParameter('task', ($request->isPost() && $enable_controls ? null : @$_SESSION['task']));\n$_SESSION['task'] = $cl_task;\n\n// Handle time custom fields.\n$timeCustomFields = array();\nif (isset($custom_fields) && $custom_fields->timeFields) {\n  foreach ($custom_fields->timeFields as $timeField) {\n    $control_name = 'time_field_'.$timeField['id'];\n    $cl_control_name = $request->getParameter($control_name, ($request->isPost() && $enable_controls ? null : @$_SESSION[$control_name]));\n    $_SESSION[$control_name] = $cl_control_name;\n    $timeCustomFields[$timeField['id']] = array('field_id' => $timeField['id'],\n      'control_name' => $control_name,\n      'label' => $timeField['label'],\n      'type' => $timeField['type'],\n      'required' => $timeField['required'],\n      'value' => trim($cl_control_name));\n  }\n}\n\n// Elements of timeRecordForm.\n$form = new Form('timeRecordForm');\n\n// Dropdown for clients in MODE_TIME. Use all active clients.\nif (MODE_TIME == $trackingMode && $showClient) {\n    $active_clients = ttGroupHelper::getActiveClients(true);\n    $form->addInput(array('type'=>'combobox',\n      'onchange'=>'fillProjectDropdown(this.value);',\n      'name'=>'client',\n      'enable'=>$enable_controls,\n      'value'=>$cl_client,\n      'data'=>$active_clients,\n      'datakeys'=>array('id', 'name'),\n      'empty'=>array(''=>$i18n->get('dropdown.select'))));\n  // Note: in other modes the client list is filtered to relevant clients only. See below.\n}\n\n// Billable checkbox.\nif ($showBillable) {\n  $form->addInput(array('type'=>'checkbox','name'=>'billable','value'=>$cl_billable,'enable'=>$enable_controls));\n}\n\n// If we have time custom fields - add controls for them.\nif (isset($custom_fields) && $custom_fields->timeFields) {\n  foreach ($custom_fields->timeFields as $timeField) {\n    $field_name = 'time_field_'.$timeField['id'];\n    if ($timeField['type'] == CustomFields::TYPE_TEXT) {\n      $form->addInput(array('type'=>'text',\n        'name'=>$field_name,\n        'enable'=>$enable_controls,\n        'value'=>$timeCustomFields[$timeField['id']]['value']));\n    } elseif ($timeField['type'] == CustomFields::TYPE_DROPDOWN) {\n      $form->addInput(array('type'=>'combobox','name'=>$field_name,\n      'data'=>CustomFields::getOptions($timeField['id']),\n      'value'=>$timeCustomFields[$timeField['id']]['value'],\n      'enable'=>$enable_controls,\n      'empty'=>array(''=>$i18n->get('dropdown.select'))));\n    }\n  }\n}\n\n// If we show project dropdown, add controls for project and client.\n$project_list = $client_list = array();\nif ($showProject) {\n  // Dropdown for projects assigned to user.\n  $project_list = $user->getAssignedProjects();\n  $form->addInput(array('type'=>'combobox',\n    'onchange'=>'fillTaskDropdown(this.value);',\n    'name'=>'project',\n    'enable'=>$enable_controls,\n    'value'=>$cl_project,\n    'data'=>$project_list,\n    'datakeys'=>array('id','name'),\n    'empty'=>array(''=>$i18n->get('dropdown.select'))));\n\n  // Client dropdown.\n  if ($showClient) {\n    $active_clients = ttGroupHelper::getActiveClients(true);\n    // We need an array of assigned project ids to do some trimming.\n    foreach($project_list as $project)\n      $projects_assigned_to_user[] = $project['id'];\n\n    // Build a client list out of active clients. Use only clients that are relevant to user.\n    // Also trim their associated project list to only assigned projects (to user).\n    foreach($active_clients as $client) {\n      $projects_assigned_to_client = explode(',', $client['projects']);\n      $intersection = array_intersect($projects_assigned_to_client, $projects_assigned_to_user);\n      if ($intersection) {\n        $client['projects'] = implode(',', $intersection);\n        $client_list[] = $client;\n      }\n    }\n    $form->addInput(array('type'=>'combobox',\n      'onchange'=>'fillProjectDropdown(this.value);',\n      'name'=>'client',\n      'enable'=>$enable_controls,\n      'value'=>$cl_client,\n      'data'=>$client_list,\n      'datakeys'=>array('id', 'name'),\n      'empty'=>array(''=>$i18n->get('dropdown.select'))));\n  }\n}\n\n// Task dropdown.\n$task_list = array();\nif ($showTask) {\n  $task_list = ttGroupHelper::getActiveTasks();\n  $form->addInput(array('type'=>'combobox',\n    'name'=>'task',\n    'enable'=>$enable_controls,\n    'value'=>$cl_task,\n    'data'=>$task_list,\n    'datakeys'=>array('id','name'),\n    'empty'=>array(''=>$i18n->get('dropdown.select'))));\n}\n\n// A hidden control for today's date from user's browser.\n$form->addInput(array('type'=>'hidden','name'=>'browser_today','value'=>'')); // User current date, which gets filled in on button click.\n\n// A hidden control for current time from user's browser.\n$form->addInput(array('type'=>'hidden','name'=>'browser_time','value'=>''));  // User current time, which gets filled in on button click.\n\n// Start and stop buttons.\n$enable_start = $uncompleted ? false : true;\nif (!$uncompleted)\n  $form->addInput(array('type'=>'submit','name'=>'btn_start','onclick'=>'browser_time.value=get_time()','value'=>$i18n->get('button.start'),'enable'=>$enable_start));\nelse\n  $form->addInput(array('type'=>'submit','name'=>'btn_stop','onclick'=>'browser_time.value=get_time()','value'=>$i18n->get('button.stop'),'enable'=>!$enable_start));\n\n// Submit.\nif ($request->isPost()) {\n  if ($request->getParameter('btn_start')) {\n    // Start button clicked. We need to create a new uncompleted record with only the start time.\n    $cl_finish = null;\n\n    // Validate user input.\n    if ($showClient && $user->isOptionEnabled('client_required') && !$cl_client)\n      $err->add($i18n->get('error.client'));\n    // Validate input in time custom fields.\n    if (isset($custom_fields) && $custom_fields->timeFields) {\n      foreach ($timeCustomFields as $timeField) {\n        // Validation is the same for text and dropdown fields.\n        if (!ttValidString($timeField['value'], !$timeField['required'])) $err->add($i18n->get('error.field'), htmlspecialchars($timeField['label']));\n      }\n    }\n    if ($showProject) {\n      if (!$cl_project) $err->add($i18n->get('error.project'));\n    }\n    if ($showTask && $taskRequired) {\n      if (!$cl_task) $err->add($i18n->get('error.task'));\n    }\n    // Finished validating user input.\n\n    // Prohibit creating entries in future.\n    if (!$user->isOptionEnabled('future_entries')) {\n      $browser_today = new DateAndTime(DB_DATEFORMAT, $request->getParameter('browser_today', null));\n      if ($selected_date->after($browser_today))\n        $err->add($i18n->get('error.future_date'));\n    }\n\n    // Prohibit creating time entries in locked interval.\n    if ($user->isDateLocked($selected_date))\n      $err->add($i18n->get('error.range_locked'));\n\n    // Prohibit creating another uncompleted record.\n    if ($err->no() && $uncompleted) {\n      $err->add($i18n->get('error.uncompleted_exists').\" <a href = 'time_edit.php?id=\".$not_completed_rec['id'].\"'>\".$i18n->get('error.goto_uncompleted').\"</a>\");\n    }\n\n    // Prohibit creating an overlapping record.\n    if ($err->no()) {\n      if (ttTimeHelper::overlaps($user->getUser(), $cl_date, $cl_start, $cl_finish))\n        $err->add($i18n->get('error.overlap'));\n    }\n\n    if ($err->no()) {\n      $id = ttTimeHelper::insert(array(\n        'date' => $cl_date,\n        'client' => $cl_client,\n        'project' => $cl_project,\n        'task' => $cl_task,\n        'start' => $cl_start,\n        'finish' => $cl_finish,\n        'duration' => $cl_duration,\n        'note' => $cl_note,\n        'billable' => $cl_billable));\n\n      // Insert time custom fields if we have them.\n      $result = true;\n      if ($id && isset($custom_fields) && $custom_fields->timeFields) {\n        $result = $custom_fields->insertTimeFields($id, $timeCustomFields);\n      }\n\n      if ($id && $result) {\n        header('Location: puncher.php');\n        exit();\n      }\n      $err->add($i18n->get('error.db'));\n    }\n  }\n  if ($request->getParameter('btn_stop')) {\n    // Stop button clicked. We need to finish an uncompleted record in progress.\n    $record = ttTimeHelper::getRecord($uncompleted['id']);\n\n    // Can we complete this record?\n    if (ttTimeHelper::isValidInterval($record['start'], $cl_finish) // finish time is greater than start time\n      && !ttTimeHelper::overlaps($user->getUser(), $cl_date, $record['start'], $cl_finish)) { // no overlap\n      $res = ttTimeHelper::update(array(\n        'id'=>$record['id'],\n        'date'=>$cl_date,\n        'client'=>$record['client_id'],\n        'project'=>$record['project_id'],\n        'task'=>$record['task_id'],\n        'start'=>$record['start'],\n        'finish'=>$cl_finish,\n        'note'=>$record['comment'],\n        'billable'=>$record['billable']));\n      if ($res) {\n        header('Location: puncher.php');\n        exit();\n      } else\n        $err->add($i18n->get('error.db'));\n    } else {\n      // Cannot complete, redirect for manual edit.\n      header('Location: time_edit.php?id='.$record['id']);\n      exit();\n    }\n  }\n} // isPost\n\n$week_total = ttTimeHelper::getTimeForWeek($cl_date);\n$timeRecords = ttTimeHelper::getRecords($cl_date);\n\n$smarty->assign('week_total', $week_total);\n$smarty->assign('uncompleted', $uncompleted);\n$smarty->assign('show_client', $showClient);\n$smarty->assign('show_billable', $showBillable);\n$smarty->assign('show_project', $showProject);\n$smarty->assign('show_task', $showTask);\n$smarty->assign('task_required', $taskRequired);\n$smarty->assign('time_records', ttTimeHelper::getRecords($cl_date));\n$smarty->assign('day_total', ttTimeHelper::getTimeForDay($cl_date));\n$smarty->assign('time_records', $timeRecords);\n$smarty->assign('show_record_custom_fields', $user->isOptionEnabled('record_custom_fields'));\n$smarty->assign('show_start', true);\n$smarty->assign('client_list', $client_list);\n$smarty->assign('project_list', $project_list);\n$smarty->assign('task_list', $task_list);\n$smarty->assign('forms', array($form->getName()=>$form->toArray()));\n$smarty->assign('onload', 'onLoad=\"fillDropdowns()\"');\n$smarty->assign('timestring', $selected_date->toString($user->date_format));\n$smarty->assign('title', $i18n->get('title.puncher'));\n$smarty->assign('content_page_name', 'puncher.tpl');\n$smarty->display('index.tpl');\n"], "filenames": ["initialize.php", "puncher.php"], "buggy_code_start_loc": [15, 19], "buggy_code_end_loc": [16, 19], "fixing_code_start_loc": [15, 20], "fixing_code_end_loc": [16, 27], "type": "CWE-89", "message": "Anuko Time Tracker is an open source, web-based time tracking application written in PHP. UNION SQL injection and time-based blind injection vulnerabilities existed in Time Tracker Puncher plugin in versions of anuko timetracker prior to 1.20.0.5642. This was happening because the Puncher plugin was reusing code from other places and was relying on an unsanitized date parameter in POST requests. Because the parameter was not checked, it was possible to craft POST requests with malicious SQL for Time Tracker database. This issue has been resolved in in version 1.20.0.5642. Users unable to upgrade are advised to add their own checks to input.", "other": {"cve": {"id": "CVE-2022-24707", "sourceIdentifier": "security-advisories@github.com", "published": "2022-02-24T16:15:08.240", "lastModified": "2022-05-12T19:36:06.057", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Anuko Time Tracker is an open source, web-based time tracking application written in PHP. UNION SQL injection and time-based blind injection vulnerabilities existed in Time Tracker Puncher plugin in versions of anuko timetracker prior to 1.20.0.5642. This was happening because the Puncher plugin was reusing code from other places and was relying on an unsanitized date parameter in POST requests. Because the parameter was not checked, it was possible to craft POST requests with malicious SQL for Time Tracker database. This issue has been resolved in in version 1.20.0.5642. Users unable to upgrade are advised to add their own checks to input."}, {"lang": "es", "value": "Anuko Time Tracker es una aplicaci\u00f3n de seguimiento del tiempo basada en la web y de c\u00f3digo abierto escrita en PHP. Unas vulnerabilidades de inyecci\u00f3n SQL y de inyecci\u00f3n ciega basada en el tiempo se presentan en el plugin Puncher de Time Tracker en anuko timetracker versiones anteriores a 1.20.0.5642. Esto ocurr\u00eda porque el plugin Puncher reusaba c\u00f3digo de otros lugares y era basado en un par\u00e1metro de fecha no saneado en las peticiones POST. Como el par\u00e1metro no era comprobado, era posible dise\u00f1ar peticiones POST con SQL malicioso para la base de datos de Time Tracker. Este problema ha sido resuelto en versi\u00f3n 1.20.0.5642. Es recomendado a usuarios que no puedan actualizarse a\u00f1adir sus propias comprobaciones a la entrada"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 7.4, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.1, "impactScore": 3.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:anuko:time_tracker:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.20.0.5642", "matchCriteriaId": "A560E137-D2F9-40B5-9EFB-9FAF4B1FF0C1"}]}]}], "references": [{"url": "http://packetstormsecurity.com/files/167060/Anuko-Time-Tracker-1.20.0.5640-SQL-Injection.html", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/anuko/timetracker/commit/0e2d6563e2d969209c502a1eae4ddd8e87b73299", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/anuko/timetracker/security/advisories/GHSA-wqx7-95fx-wjxj", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/anuko/timetracker/commit/0e2d6563e2d969209c502a1eae4ddd8e87b73299"}}