{"buggy_code": ["/* exif-mnote-data-canon.c\n *\n * Copyright (c) 2002, 2003 Lutz Mueller <lutz@users.sourceforge.net>\n * Copyright (c) 2003 Matthieu Castet <mat-c@users.sourceforge.net>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the\n * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n * Boston, MA  02110-1301  USA.\n */\n\n#include <config.h>\n#include \"exif-mnote-data-canon.h\"\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n\n#include <libexif/exif-byte-order.h>\n#include <libexif/exif-utils.h>\n#include <libexif/exif-data.h>\n\n#define CHECKOVERFLOW(offset,datasize,structsize) (( offset >= datasize) || (structsize > datasize) || (offset > datasize - structsize ))\n\nstatic void\nexif_mnote_data_canon_clear (ExifMnoteDataCanon *n)\n{\n\tExifMnoteData *d = (ExifMnoteData *) n;\n\tunsigned int i;\n\n\tif (!n) return;\n\n\tif (n->entries) {\n\t\tfor (i = 0; i < n->count; i++)\n\t\t\tif (n->entries[i].data) {\n\t\t\t\texif_mem_free (d->mem, n->entries[i].data);\n\t\t\t\tn->entries[i].data = NULL;\n\t\t\t}\n\t\texif_mem_free (d->mem, n->entries);\n\t\tn->entries = NULL;\n\t\tn->count = 0;\n\t}\n}\n\nstatic void\nexif_mnote_data_canon_free (ExifMnoteData *n)\n{\n\tif (!n) return;\n\n\texif_mnote_data_canon_clear ((ExifMnoteDataCanon *) n);\n}\n\nstatic void\nexif_mnote_data_canon_get_tags (ExifMnoteDataCanon *dc, unsigned int n,\n\t\tunsigned int *m, unsigned int *s)\n{\n\tunsigned int from = 0, to;\n\n\tif (!dc || !m) return;\n\tfor (*m = 0; *m < dc->count; (*m)++) {\n\t\tto = from + mnote_canon_entry_count_values (&dc->entries[*m]);\n\t\tif (to > n) {\n\t\t\tif (s) *s = n - from;\n\t\t\tbreak;\n\t\t}\n\t\tfrom = to;\n\t}\n}\n\nstatic char *\nexif_mnote_data_canon_get_value (ExifMnoteData *note, unsigned int n, char *val, unsigned int maxlen)\n{\n\tExifMnoteDataCanon *dc = (ExifMnoteDataCanon *) note;\n\tunsigned int m, s;\n\n\tif (!dc) return NULL;\n\texif_mnote_data_canon_get_tags (dc, n, &m, &s);\n\tif (m >= dc->count) return NULL;\n\treturn mnote_canon_entry_get_value (&dc->entries[m], s, val, maxlen);\n}\n\nstatic void\nexif_mnote_data_canon_set_byte_order (ExifMnoteData *d, ExifByteOrder o)\n{\n\tExifByteOrder o_orig;\n\tExifMnoteDataCanon *n = (ExifMnoteDataCanon *) d;\n\tunsigned int i;\n\n\tif (!n) return;\n\n\to_orig = n->order;\n\tn->order = o;\n\tfor (i = 0; i < n->count; i++) {\n\t\tif (n->entries[i].components && (n->entries[i].size/n->entries[i].components < exif_format_get_size (n->entries[i].format)))\n\t\t\tcontinue;\n\t\tn->entries[i].order = o;\n\t\texif_array_set_byte_order (n->entries[i].format, n->entries[i].data,\n\t\t\t\tn->entries[i].components, o_orig, o);\n\t}\n}\n\nstatic void\nexif_mnote_data_canon_set_offset (ExifMnoteData *n, unsigned int o)\n{\n\tif (n) ((ExifMnoteDataCanon *) n)->offset = o;\n}\n\nstatic void\nexif_mnote_data_canon_save (ExifMnoteData *ne, \n\tunsigned char **buf, unsigned int *buf_size)\n{\n\tExifMnoteDataCanon *n = (ExifMnoteDataCanon *) ne;\n\tsize_t i, o, s, doff;\n\tunsigned char *t;\n\tsize_t ts;\n\n\tif (!n || !buf || !buf_size) return;\n\n\t/*\n\t * Allocate enough memory for all entries and the number\n\t * of entries.\n\t */\n\t*buf_size = 2 + n->count * 12 + 4;\n\t*buf = exif_mem_alloc (ne->mem, sizeof (char) * *buf_size);\n\tif (!*buf) {\n\t\tEXIF_LOG_NO_MEMORY(ne->log, \"ExifMnoteCanon\", *buf_size);\n\t\treturn;\n\t}\n\n\t/* Save the number of entries */\n\texif_set_short (*buf, n->order, (ExifShort) n->count);\n\t\n\t/* Save each entry */\n\tfor (i = 0; i < n->count; i++) {\n\t\to = 2 + i * 12;\n\t\texif_set_short (*buf + o + 0, n->order, (ExifShort) n->entries[i].tag);\n\t\texif_set_short (*buf + o + 2, n->order, (ExifShort) n->entries[i].format);\n\t\texif_set_long  (*buf + o + 4, n->order,\n\t\t\t\tn->entries[i].components);\n\t\to += 8;\n\t\ts = exif_format_get_size (n->entries[i].format) *\n\t\t\t\t\t\tn->entries[i].components;\n\t\tif (s > 65536) {\n\t\t\t/* Corrupt data: EXIF data size is limited to the\n\t\t\t * maximum size of a JPEG segment (64 kb).\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\t\tif (s > 4) {\n\t\t\tts = *buf_size + s;\n\n\t\t\t/* Ensure even offsets. Set padding bytes to 0. */\n\t\t\tif (s & 1) ts += 1;\n\t\t\tt = exif_mem_realloc (ne->mem, *buf,\n\t\t\t\t\t\t sizeof (char) * ts);\n\t\t\tif (!t) {\n\t\t\t\tEXIF_LOG_NO_MEMORY(ne->log, \"ExifMnoteCanon\", ts);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t*buf = t;\n\t\t\t*buf_size = ts;\n\t\t\tdoff = *buf_size - s;\n\t\t\tif (s & 1) { doff--; *(*buf + *buf_size - 1) = '\\0'; }\n\t\t\texif_set_long (*buf + o, n->order, n->offset + doff);\n\t\t} else\n\t\t\tdoff = o;\n\n\t\t/*\n\t\t * Write the data. Fill unneeded bytes with 0. Do not\n\t\t * crash if data is NULL.\n\t\t */\n\t\tif (!n->entries[i].data) memset (*buf + doff, 0, s);\n\t\telse memcpy (*buf + doff, n->entries[i].data, s);\n\t\tif (s < 4) memset (*buf + doff + s, 0, (4 - s));\n\t}\n}\n\n/* XXX\n * FIXME: exif_mnote_data_canon_load() may fail and there is no\n *        semantics to express that.\n *        See bug #1054323 for details, especially the comment by liblit\n *        after it has supposedly been fixed:\n *\n *        https://sourceforge.net/tracker/?func=detail&aid=1054323&group_id=12272&atid=112272\n *        Unfortunately, the \"return\" statements aren't commented at\n *        all, so it isn't trivial to find out what is a normal\n *        return, and what is a reaction to an error condition.\n */\n\nstatic void\nexif_mnote_data_canon_load (ExifMnoteData *ne,\n\tconst unsigned char *buf, unsigned int buf_size)\n{\n\tExifMnoteDataCanon *n = (ExifMnoteDataCanon *) ne;\n\tExifShort c;\n\tsize_t i, tcount, o, datao;\n\n\tif (!n || !buf || !buf_size) {\n\t\texif_log (ne->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t  \"ExifMnoteCanon\", \"Short MakerNote\");\n\t\treturn;\n\t}\n\tdatao = 6 + n->offset;\n\tif (CHECKOVERFLOW(datao, buf_size, 2)) {\n\t\texif_log (ne->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t  \"ExifMnoteCanon\", \"Short MakerNote\");\n\t\treturn;\n\t}\n\n\t/* Read the number of tags */\n\tc = exif_get_short (buf + datao, n->order);\n\tdatao += 2;\n\n\t/* Remove any old entries */\n\texif_mnote_data_canon_clear (n);\n\n\t/* Reserve enough space for all the possible MakerNote tags */\n\tn->entries = exif_mem_alloc (ne->mem, sizeof (MnoteCanonEntry) * c);\n\tif (!n->entries) {\n\t\tEXIF_LOG_NO_MEMORY(ne->log, \"ExifMnoteCanon\", sizeof (MnoteCanonEntry) * c);\n\t\treturn;\n\t}\n\n\t/* Parse the entries */\n\ttcount = 0;\n\tfor (i = c, o = datao; i; --i, o += 12) {\n\t\tsize_t s;\n\n\t\tmemset(&n->entries[tcount], 0, sizeof(MnoteCanonEntry));\n\t\tif (CHECKOVERFLOW(o,buf_size,12)) {\n\t\t\texif_log (ne->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t\t\"ExifMnoteCanon\", \"Short MakerNote\");\n\t\t\tbreak;\n\t\t}\n\n\t\tn->entries[tcount].tag        = exif_get_short (buf + o, n->order);\n\t\tn->entries[tcount].format     = exif_get_short (buf + o + 2, n->order);\n\t\tn->entries[tcount].components = exif_get_long (buf + o + 4, n->order);\n\t\tn->entries[tcount].order      = n->order;\n\n\t\texif_log (ne->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteCanon\",\n\t\t\t\"Loading entry 0x%x ('%s')...\", n->entries[tcount].tag,\n\t\t\t mnote_canon_tag_get_name (n->entries[tcount].tag));\n\n\t\t/* Check if we overflow the multiplication. Use buf_size as the max size for integer overflow detection,\n\t\t * we will check the buffer sizes closer later. */\n\t\tif (\texif_format_get_size (n->entries[tcount].format) &&\n\t\t\tbuf_size / exif_format_get_size (n->entries[tcount].format) < n->entries[tcount].components\n\t\t) {\n\t\t\texif_log (ne->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t\t  \"ExifMnoteCanon\", \"Tag size overflow detected (%u * %lu)\", exif_format_get_size (n->entries[tcount].format), n->entries[tcount].components);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Size? If bigger than 4 bytes, the actual data is not\n\t\t * in the entry but somewhere else (offset).\n\t\t */\n\t\ts = exif_format_get_size (n->entries[tcount].format) * \n\t\t\t\t\t\t\t\t  n->entries[tcount].components;\n\t\tn->entries[tcount].size = s;\n\t\tif (!s) {\n\t\t\texif_log (ne->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t\t  \"ExifMnoteCanon\",\n\t\t\t\t  \"Invalid zero-length tag size\");\n\t\t\tcontinue;\n\n\t\t} else {\n\t\t\tsize_t dataofs = o + 8;\n\t\t\tif (s > 4) dataofs = exif_get_long (buf + dataofs, n->order) + 6;\n\n\t\t\tif (CHECKOVERFLOW(dataofs, buf_size, s)) {\n\t\t\t\texif_log (ne->log, EXIF_LOG_CODE_DEBUG,\n\t\t\t\t\t\"ExifMnoteCanon\",\n\t\t\t\t\t\"Tag data past end of buffer (%u > %u)\",\n\t\t\t\t\t(unsigned)(dataofs + s), buf_size);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tn->entries[tcount].data = exif_mem_alloc (ne->mem, s);\n\t\t\tif (!n->entries[tcount].data) {\n\t\t\t\tEXIF_LOG_NO_MEMORY(ne->log, \"ExifMnoteCanon\", s);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmemcpy (n->entries[tcount].data, buf + dataofs, s);\n\t\t}\n\n\t\t/* Tag was successfully parsed */\n\t\t++tcount;\n\t}\n\t/* Store the count of successfully parsed tags */\n\tn->count = tcount;\n}\n\nstatic unsigned int\nexif_mnote_data_canon_count (ExifMnoteData *n)\n{\n\tExifMnoteDataCanon *dc = (ExifMnoteDataCanon *) n;\n\tunsigned int i, c;\n\n\tfor (i = c = 0; dc && (i < dc->count); i++)\n\t\tc += mnote_canon_entry_count_values (&dc->entries[i]);\n\treturn c;\n}\n\nstatic unsigned int\nexif_mnote_data_canon_get_id (ExifMnoteData *d, unsigned int i)\n{\n\tExifMnoteDataCanon *dc = (ExifMnoteDataCanon *) d;\n\tunsigned int m;\n\n\tif (!dc) return 0;\n\texif_mnote_data_canon_get_tags (dc, i, &m, NULL);\n\tif (m >= dc->count) return 0;\n\treturn dc->entries[m].tag;\n}\n\nstatic const char *\nexif_mnote_data_canon_get_name (ExifMnoteData *note, unsigned int i)\n{\n\tExifMnoteDataCanon *dc = (ExifMnoteDataCanon *) note;\n\tunsigned int m, s;\n\n\tif (!dc) return NULL;\n\texif_mnote_data_canon_get_tags (dc, i, &m, &s);\n\tif (m >= dc->count) return NULL;\n\treturn mnote_canon_tag_get_name_sub (dc->entries[m].tag, s, dc->options);\n}\n\nstatic const char *\nexif_mnote_data_canon_get_title (ExifMnoteData *note, unsigned int i)\n{\n\tExifMnoteDataCanon *dc = (ExifMnoteDataCanon *) note;\n\tunsigned int m, s;\n\n\tif (!dc) return NULL;\n\texif_mnote_data_canon_get_tags (dc, i, &m, &s);\n\tif (m >= dc->count) return NULL;\n\treturn mnote_canon_tag_get_title_sub (dc->entries[m].tag, s, dc->options);\n}\n\nstatic const char *\nexif_mnote_data_canon_get_description (ExifMnoteData *note, unsigned int i)\n{\n\tExifMnoteDataCanon *dc = (ExifMnoteDataCanon *) note;\n\tunsigned int m;\n\n\tif (!dc) return NULL;\n\texif_mnote_data_canon_get_tags (dc, i, &m, NULL);\n\tif (m >= dc->count) return NULL;\n\treturn mnote_canon_tag_get_description (dc->entries[m].tag);\n}\n\nint\nexif_mnote_data_canon_identify (const ExifData *ed, const ExifEntry *e)\n{\n\tchar value[8];\n\n\t(void) e;  /* unused */\n\tExifEntry *em = exif_data_get_entry (ed, EXIF_TAG_MAKE);\n\tif (!em) \n\t\treturn 0;\n\treturn !strcmp (exif_entry_get_value (em, value, sizeof (value)), \"Canon\");\n}\n\nExifMnoteData *\nexif_mnote_data_canon_new (ExifMem *mem, ExifDataOption o)\n{\n\tExifMnoteData *d;\n\tExifMnoteDataCanon *dc;\n\n\tif (!mem) return NULL;\n\n\td = exif_mem_alloc (mem, sizeof (ExifMnoteDataCanon));\n\tif (!d)\n\t\treturn NULL;\n\n\texif_mnote_data_construct (d, mem);\n\n\t/* Set up function pointers */\n\td->methods.free            = exif_mnote_data_canon_free;\n\td->methods.set_byte_order  = exif_mnote_data_canon_set_byte_order;\n\td->methods.set_offset      = exif_mnote_data_canon_set_offset;\n\td->methods.load            = exif_mnote_data_canon_load;\n\td->methods.save            = exif_mnote_data_canon_save;\n\td->methods.count           = exif_mnote_data_canon_count;\n\td->methods.get_id          = exif_mnote_data_canon_get_id;\n\td->methods.get_name        = exif_mnote_data_canon_get_name;\n\td->methods.get_title       = exif_mnote_data_canon_get_title;\n\td->methods.get_description = exif_mnote_data_canon_get_description;\n\td->methods.get_value       = exif_mnote_data_canon_get_value;\n\n\tdc = (ExifMnoteDataCanon*)d;\n\tdc->options = o;\n\treturn d;\n}\n"], "fixing_code": ["/* exif-mnote-data-canon.c\n *\n * Copyright (c) 2002, 2003 Lutz Mueller <lutz@users.sourceforge.net>\n * Copyright (c) 2003 Matthieu Castet <mat-c@users.sourceforge.net>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the\n * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n * Boston, MA  02110-1301  USA.\n */\n\n#include <config.h>\n#include \"exif-mnote-data-canon.h\"\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n\n#include <libexif/exif-byte-order.h>\n#include <libexif/exif-utils.h>\n#include <libexif/exif-data.h>\n\n#define CHECKOVERFLOW(offset,datasize,structsize) (( offset >= datasize) || (structsize > datasize) || (offset > datasize - structsize ))\n\n/* Total size limit to prevent abuse by DoS */\n#define FAILSAFE_SIZE_MAX 1000000L\n\nstatic void\nexif_mnote_data_canon_clear (ExifMnoteDataCanon *n)\n{\n\tExifMnoteData *d = (ExifMnoteData *) n;\n\tunsigned int i;\n\n\tif (!n) return;\n\n\tif (n->entries) {\n\t\tfor (i = 0; i < n->count; i++)\n\t\t\tif (n->entries[i].data) {\n\t\t\t\texif_mem_free (d->mem, n->entries[i].data);\n\t\t\t\tn->entries[i].data = NULL;\n\t\t\t}\n\t\texif_mem_free (d->mem, n->entries);\n\t\tn->entries = NULL;\n\t\tn->count = 0;\n\t}\n}\n\nstatic void\nexif_mnote_data_canon_free (ExifMnoteData *n)\n{\n\tif (!n) return;\n\n\texif_mnote_data_canon_clear ((ExifMnoteDataCanon *) n);\n}\n\nstatic void\nexif_mnote_data_canon_get_tags (ExifMnoteDataCanon *dc, unsigned int n,\n\t\tunsigned int *m, unsigned int *s)\n{\n\tunsigned int from = 0, to;\n\n\tif (!dc || !m) return;\n\tfor (*m = 0; *m < dc->count; (*m)++) {\n\t\tto = from + mnote_canon_entry_count_values (&dc->entries[*m]);\n\t\tif (to > n) {\n\t\t\tif (s) *s = n - from;\n\t\t\tbreak;\n\t\t}\n\t\tfrom = to;\n\t}\n}\n\nstatic char *\nexif_mnote_data_canon_get_value (ExifMnoteData *note, unsigned int n, char *val, unsigned int maxlen)\n{\n\tExifMnoteDataCanon *dc = (ExifMnoteDataCanon *) note;\n\tunsigned int m, s;\n\n\tif (!dc) return NULL;\n\texif_mnote_data_canon_get_tags (dc, n, &m, &s);\n\tif (m >= dc->count) return NULL;\n\treturn mnote_canon_entry_get_value (&dc->entries[m], s, val, maxlen);\n}\n\nstatic void\nexif_mnote_data_canon_set_byte_order (ExifMnoteData *d, ExifByteOrder o)\n{\n\tExifByteOrder o_orig;\n\tExifMnoteDataCanon *n = (ExifMnoteDataCanon *) d;\n\tunsigned int i;\n\n\tif (!n) return;\n\n\to_orig = n->order;\n\tn->order = o;\n\tfor (i = 0; i < n->count; i++) {\n\t\tif (n->entries[i].components && (n->entries[i].size/n->entries[i].components < exif_format_get_size (n->entries[i].format)))\n\t\t\tcontinue;\n\t\tn->entries[i].order = o;\n\t\texif_array_set_byte_order (n->entries[i].format, n->entries[i].data,\n\t\t\t\tn->entries[i].components, o_orig, o);\n\t}\n}\n\nstatic void\nexif_mnote_data_canon_set_offset (ExifMnoteData *n, unsigned int o)\n{\n\tif (n) ((ExifMnoteDataCanon *) n)->offset = o;\n}\n\nstatic void\nexif_mnote_data_canon_save (ExifMnoteData *ne, \n\tunsigned char **buf, unsigned int *buf_size)\n{\n\tExifMnoteDataCanon *n = (ExifMnoteDataCanon *) ne;\n\tsize_t i, o, s, doff;\n\tunsigned char *t;\n\tsize_t ts;\n\n\tif (!n || !buf || !buf_size) return;\n\n\t/*\n\t * Allocate enough memory for all entries and the number\n\t * of entries.\n\t */\n\t*buf_size = 2 + n->count * 12 + 4;\n\t*buf = exif_mem_alloc (ne->mem, sizeof (char) * *buf_size);\n\tif (!*buf) {\n\t\tEXIF_LOG_NO_MEMORY(ne->log, \"ExifMnoteCanon\", *buf_size);\n\t\treturn;\n\t}\n\n\t/* Save the number of entries */\n\texif_set_short (*buf, n->order, (ExifShort) n->count);\n\t\n\t/* Save each entry */\n\tfor (i = 0; i < n->count; i++) {\n\t\to = 2 + i * 12;\n\t\texif_set_short (*buf + o + 0, n->order, (ExifShort) n->entries[i].tag);\n\t\texif_set_short (*buf + o + 2, n->order, (ExifShort) n->entries[i].format);\n\t\texif_set_long  (*buf + o + 4, n->order,\n\t\t\t\tn->entries[i].components);\n\t\to += 8;\n\t\ts = exif_format_get_size (n->entries[i].format) *\n\t\t\t\t\t\tn->entries[i].components;\n\t\tif (s > 65536) {\n\t\t\t/* Corrupt data: EXIF data size is limited to the\n\t\t\t * maximum size of a JPEG segment (64 kb).\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\t\tif (s > 4) {\n\t\t\tts = *buf_size + s;\n\n\t\t\t/* Ensure even offsets. Set padding bytes to 0. */\n\t\t\tif (s & 1) ts += 1;\n\t\t\tt = exif_mem_realloc (ne->mem, *buf,\n\t\t\t\t\t\t sizeof (char) * ts);\n\t\t\tif (!t) {\n\t\t\t\tEXIF_LOG_NO_MEMORY(ne->log, \"ExifMnoteCanon\", ts);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t*buf = t;\n\t\t\t*buf_size = ts;\n\t\t\tdoff = *buf_size - s;\n\t\t\tif (s & 1) { doff--; *(*buf + *buf_size - 1) = '\\0'; }\n\t\t\texif_set_long (*buf + o, n->order, n->offset + doff);\n\t\t} else\n\t\t\tdoff = o;\n\n\t\t/*\n\t\t * Write the data. Fill unneeded bytes with 0. Do not\n\t\t * crash if data is NULL.\n\t\t */\n\t\tif (!n->entries[i].data) memset (*buf + doff, 0, s);\n\t\telse memcpy (*buf + doff, n->entries[i].data, s);\n\t\tif (s < 4) memset (*buf + doff + s, 0, (4 - s));\n\t}\n}\n\n/* XXX\n * FIXME: exif_mnote_data_canon_load() may fail and there is no\n *        semantics to express that.\n *        See bug #1054323 for details, especially the comment by liblit\n *        after it has supposedly been fixed:\n *\n *        https://sourceforge.net/tracker/?func=detail&aid=1054323&group_id=12272&atid=112272\n *        Unfortunately, the \"return\" statements aren't commented at\n *        all, so it isn't trivial to find out what is a normal\n *        return, and what is a reaction to an error condition.\n */\n\nstatic void\nexif_mnote_data_canon_load (ExifMnoteData *ne,\n\tconst unsigned char *buf, unsigned int buf_size)\n{\n\tExifMnoteDataCanon *n = (ExifMnoteDataCanon *) ne;\n\tExifShort c;\n\tsize_t i, tcount, o, datao;\n\tlong failsafe_size = 0;\n\n\tif (!n || !buf || !buf_size) {\n\t\texif_log (ne->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t  \"ExifMnoteCanon\", \"Short MakerNote\");\n\t\treturn;\n\t}\n\tdatao = 6 + n->offset;\n\tif (CHECKOVERFLOW(datao, buf_size, 2)) {\n\t\texif_log (ne->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t  \"ExifMnoteCanon\", \"Short MakerNote\");\n\t\treturn;\n\t}\n\n\t/* Read the number of tags */\n\tc = exif_get_short (buf + datao, n->order);\n\tdatao += 2;\n\n\t/* Remove any old entries */\n\texif_mnote_data_canon_clear (n);\n\n\t/* Reserve enough space for all the possible MakerNote tags */\n\tn->entries = exif_mem_alloc (ne->mem, sizeof (MnoteCanonEntry) * c);\n\tif (!n->entries) {\n\t\tEXIF_LOG_NO_MEMORY(ne->log, \"ExifMnoteCanon\", sizeof (MnoteCanonEntry) * c);\n\t\treturn;\n\t}\n\n\t/* Parse the entries */\n\ttcount = 0;\n\tfor (i = c, o = datao; i; --i, o += 12) {\n\t\tsize_t s;\n\n\t\tmemset(&n->entries[tcount], 0, sizeof(MnoteCanonEntry));\n\t\tif (CHECKOVERFLOW(o,buf_size,12)) {\n\t\t\texif_log (ne->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t\t\"ExifMnoteCanon\", \"Short MakerNote\");\n\t\t\tbreak;\n\t\t}\n\n\t\tn->entries[tcount].tag        = exif_get_short (buf + o, n->order);\n\t\tn->entries[tcount].format     = exif_get_short (buf + o + 2, n->order);\n\t\tn->entries[tcount].components = exif_get_long (buf + o + 4, n->order);\n\t\tn->entries[tcount].order      = n->order;\n\n\t\texif_log (ne->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteCanon\",\n\t\t\t\"Loading entry 0x%x ('%s')...\", n->entries[tcount].tag,\n\t\t\t mnote_canon_tag_get_name (n->entries[tcount].tag));\n\n\t\t/* Check if we overflow the multiplication. Use buf_size as the max size for integer overflow detection,\n\t\t * we will check the buffer sizes closer later. */\n\t\tif (\texif_format_get_size (n->entries[tcount].format) &&\n\t\t\tbuf_size / exif_format_get_size (n->entries[tcount].format) < n->entries[tcount].components\n\t\t) {\n\t\t\texif_log (ne->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t\t  \"ExifMnoteCanon\", \"Tag size overflow detected (%u * %lu)\", exif_format_get_size (n->entries[tcount].format), n->entries[tcount].components);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Size? If bigger than 4 bytes, the actual data is not\n\t\t * in the entry but somewhere else (offset).\n\t\t */\n\t\ts = exif_format_get_size (n->entries[tcount].format) * \n\t\t\t\t\t\t\t\t  n->entries[tcount].components;\n\t\tn->entries[tcount].size = s;\n\t\tif (!s) {\n\t\t\texif_log (ne->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t\t  \"ExifMnoteCanon\",\n\t\t\t\t  \"Invalid zero-length tag size\");\n\t\t\tcontinue;\n\n\t\t} else {\n\t\t\tsize_t dataofs = o + 8;\n\t\t\tif (s > 4) dataofs = exif_get_long (buf + dataofs, n->order) + 6;\n\n\t\t\tif (CHECKOVERFLOW(dataofs, buf_size, s)) {\n\t\t\t\texif_log (ne->log, EXIF_LOG_CODE_DEBUG,\n\t\t\t\t\t\"ExifMnoteCanon\",\n\t\t\t\t\t\"Tag data past end of buffer (%u > %u)\",\n\t\t\t\t\t(unsigned)(dataofs + s), buf_size);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tn->entries[tcount].data = exif_mem_alloc (ne->mem, s);\n\t\t\tif (!n->entries[tcount].data) {\n\t\t\t\tEXIF_LOG_NO_MEMORY(ne->log, \"ExifMnoteCanon\", s);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmemcpy (n->entries[tcount].data, buf + dataofs, s);\n\t\t}\n\n\t\t/* Track the size of decoded tag data. A malicious file could\n\t\t * be crafted to cause extremely large values here without\n\t\t * tripping any buffer range checks.  This is especially bad\n\t\t * with the libexif representation of Canon MakerNotes because\n\t\t * some arrays are turned into individual tags that the\n\t\t * application must loop around. */\n\t\tfailsafe_size += mnote_canon_entry_count_values(&n->entries[tcount]);\n\n\t\tif (failsafe_size > FAILSAFE_SIZE_MAX) {\n\t\t\t/* Abort if the total size of the data in the tags extraordinarily large, */\n\t\t\texif_mem_free (ne->mem, n->entries[tcount].data);\n\t\t\texif_log (ne->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t\t\t  \"ExifMnoteCanon\", \"Failsafe tag size overflow (%lu > %ld)\",\n\t\t\t\t\t  failsafe_size, FAILSAFE_SIZE_MAX);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Tag was successfully parsed */\n\t\t++tcount;\n\t}\n\t/* Store the count of successfully parsed tags */\n\tn->count = tcount;\n}\n\nstatic unsigned int\nexif_mnote_data_canon_count (ExifMnoteData *n)\n{\n\tExifMnoteDataCanon *dc = (ExifMnoteDataCanon *) n;\n\tunsigned int i, c;\n\n\tfor (i = c = 0; dc && (i < dc->count); i++)\n\t\tc += mnote_canon_entry_count_values (&dc->entries[i]);\n\treturn c;\n}\n\nstatic unsigned int\nexif_mnote_data_canon_get_id (ExifMnoteData *d, unsigned int i)\n{\n\tExifMnoteDataCanon *dc = (ExifMnoteDataCanon *) d;\n\tunsigned int m;\n\n\tif (!dc) return 0;\n\texif_mnote_data_canon_get_tags (dc, i, &m, NULL);\n\tif (m >= dc->count) return 0;\n\treturn dc->entries[m].tag;\n}\n\nstatic const char *\nexif_mnote_data_canon_get_name (ExifMnoteData *note, unsigned int i)\n{\n\tExifMnoteDataCanon *dc = (ExifMnoteDataCanon *) note;\n\tunsigned int m, s;\n\n\tif (!dc) return NULL;\n\texif_mnote_data_canon_get_tags (dc, i, &m, &s);\n\tif (m >= dc->count) return NULL;\n\treturn mnote_canon_tag_get_name_sub (dc->entries[m].tag, s, dc->options);\n}\n\nstatic const char *\nexif_mnote_data_canon_get_title (ExifMnoteData *note, unsigned int i)\n{\n\tExifMnoteDataCanon *dc = (ExifMnoteDataCanon *) note;\n\tunsigned int m, s;\n\n\tif (!dc) return NULL;\n\texif_mnote_data_canon_get_tags (dc, i, &m, &s);\n\tif (m >= dc->count) return NULL;\n\treturn mnote_canon_tag_get_title_sub (dc->entries[m].tag, s, dc->options);\n}\n\nstatic const char *\nexif_mnote_data_canon_get_description (ExifMnoteData *note, unsigned int i)\n{\n\tExifMnoteDataCanon *dc = (ExifMnoteDataCanon *) note;\n\tunsigned int m;\n\n\tif (!dc) return NULL;\n\texif_mnote_data_canon_get_tags (dc, i, &m, NULL);\n\tif (m >= dc->count) return NULL;\n\treturn mnote_canon_tag_get_description (dc->entries[m].tag);\n}\n\nint\nexif_mnote_data_canon_identify (const ExifData *ed, const ExifEntry *e)\n{\n\tchar value[8];\n\n\t(void) e;  /* unused */\n\tExifEntry *em = exif_data_get_entry (ed, EXIF_TAG_MAKE);\n\tif (!em) \n\t\treturn 0;\n\treturn !strcmp (exif_entry_get_value (em, value, sizeof (value)), \"Canon\");\n}\n\nExifMnoteData *\nexif_mnote_data_canon_new (ExifMem *mem, ExifDataOption o)\n{\n\tExifMnoteData *d;\n\tExifMnoteDataCanon *dc;\n\n\tif (!mem) return NULL;\n\n\td = exif_mem_alloc (mem, sizeof (ExifMnoteDataCanon));\n\tif (!d)\n\t\treturn NULL;\n\n\texif_mnote_data_construct (d, mem);\n\n\t/* Set up function pointers */\n\td->methods.free            = exif_mnote_data_canon_free;\n\td->methods.set_byte_order  = exif_mnote_data_canon_set_byte_order;\n\td->methods.set_offset      = exif_mnote_data_canon_set_offset;\n\td->methods.load            = exif_mnote_data_canon_load;\n\td->methods.save            = exif_mnote_data_canon_save;\n\td->methods.count           = exif_mnote_data_canon_count;\n\td->methods.get_id          = exif_mnote_data_canon_get_id;\n\td->methods.get_name        = exif_mnote_data_canon_get_name;\n\td->methods.get_title       = exif_mnote_data_canon_get_title;\n\td->methods.get_description = exif_mnote_data_canon_get_description;\n\td->methods.get_value       = exif_mnote_data_canon_get_value;\n\n\tdc = (ExifMnoteDataCanon*)d;\n\tdc->options = o;\n\treturn d;\n}\n"], "filenames": ["libexif/canon/exif-mnote-data-canon.c"], "buggy_code_start_loc": [34], "buggy_code_end_loc": [297], "fixing_code_start_loc": [35], "fixing_code_end_loc": [319], "type": "CWE-770", "message": "An issue was discovered in libexif before 0.6.22. An unrestricted size in handling Canon EXIF MakerNote data could lead to consumption of large amounts of compute time for decoding EXIF data.", "other": {"cve": {"id": "CVE-2020-13114", "sourceIdentifier": "cve@mitre.org", "published": "2020-05-21T16:15:10.930", "lastModified": "2022-04-27T14:45:16.417", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in libexif before 0.6.22. An unrestricted size in handling Canon EXIF MakerNote data could lead to consumption of large amounts of compute time for decoding EXIF data."}, {"lang": "es", "value": "Se descubri\u00f3 un problema en el libexif versiones anteriores a la versi\u00f3n 0.6.22. Un tama\u00f1o sin restricciones en el manejo de los datos de Canon EXIF MakerNote podr\u00eda conllevar al consumo de grandes cantidades de tiempo de c\u00e1lculo para la decodificaci\u00f3n de datos EXIF."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-770"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libexif_project:libexif:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.6.22", "matchCriteriaId": "C81CD57C-F020-46D6-859A-A9E81EF9685B"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:-:*:*:*", "matchCriteriaId": "CB66DB75-2B16-4EBF-9B93-CE49D8086E41"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:esm:*:*:*", "matchCriteriaId": "815D70A8-47D3-459C-A32C-9FEACA0659D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:esm:*:*:*", "matchCriteriaId": "7A5301BF-1402-4BE0-A0F8-69FBE79BC6D6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.10:*:*:*:*:*:*:*", "matchCriteriaId": "A31C8344-3E02-4EB8-8BD8-4C84B7959624"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:20.04:*:*:*:lts:*:*:*", "matchCriteriaId": "902B8056-9E37-443B-8905-8AA93E2447FB"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-06/msg00017.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/libexif/libexif/commit/e6a38a1a23ba94d139b1fa2cd4519fdcfe3c9bab", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/05/msg00025.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202007-05", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4396-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/libexif/libexif/commit/e6a38a1a23ba94d139b1fa2cd4519fdcfe3c9bab"}}