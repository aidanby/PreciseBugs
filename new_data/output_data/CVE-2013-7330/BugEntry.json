{"buggy_code": ["/*\n * The MIT License\n * \n * Copyright (c) 2004-2011, Sun Microsystems, Inc., Kohsuke Kawaguchi,\n * Brian Westrich, Erik Ramfelt, Ertan Deniz, Jean-Baptiste Quenot,\n * Luca Domenico Milanesio, R. Tyler Ballance, Stephen Connolly, Tom Huybrechts,\n * id:cactusman, Yahoo! Inc., Andrew Bayer, Manufacture Francaise des Pneumatiques\n * Michelin, Romain Seguy\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage hudson.model;\n\nimport com.infradna.tool.bridge_method_injector.WithBridgeMethods;\nimport hudson.EnvVars;\nimport hudson.Functions;\nimport antlr.ANTLRException;\nimport hudson.AbortException;\nimport hudson.CopyOnWrite;\nimport hudson.FeedAdapter;\nimport hudson.FilePath;\nimport hudson.Launcher;\nimport hudson.Util;\nimport hudson.cli.declarative.CLIMethod;\nimport hudson.cli.declarative.CLIResolver;\nimport hudson.model.Cause.LegacyCodeCause;\nimport hudson.model.Cause.RemoteCause;\nimport hudson.model.Cause.UserIdCause;\nimport hudson.model.Descriptor.FormException;\nimport hudson.model.Fingerprint.RangeSet;\nimport hudson.model.Queue.Executable;\nimport hudson.model.Queue.Task;\nimport hudson.model.queue.QueueTaskFuture;\nimport hudson.model.queue.SubTask;\nimport hudson.model.Queue.WaitingItem;\nimport hudson.model.RunMap.Constructor;\nimport hudson.model.labels.LabelAtom;\nimport hudson.model.labels.LabelExpression;\nimport hudson.model.listeners.SCMPollListener;\nimport hudson.model.queue.CauseOfBlockage;\nimport hudson.model.queue.SubTaskContributor;\nimport hudson.scm.ChangeLogSet;\nimport hudson.scm.ChangeLogSet.Entry;\nimport hudson.scm.NullSCM;\nimport hudson.scm.PollingResult;\nimport hudson.scm.SCM;\nimport hudson.scm.SCMRevisionState;\nimport hudson.scm.SCMS;\nimport hudson.search.SearchIndexBuilder;\nimport hudson.security.Permission;\nimport hudson.slaves.WorkspaceList;\nimport hudson.tasks.BuildStep;\nimport hudson.tasks.BuildStepDescriptor;\nimport hudson.tasks.BuildTrigger;\nimport hudson.tasks.BuildWrapperDescriptor;\nimport hudson.tasks.Publisher;\nimport hudson.triggers.SCMTrigger;\nimport hudson.triggers.Trigger;\nimport hudson.triggers.TriggerDescriptor;\nimport hudson.util.AlternativeUiTextProvider;\nimport hudson.util.AlternativeUiTextProvider.Message;\nimport hudson.util.DescribableList;\nimport hudson.util.EditDistance;\nimport hudson.util.FormValidation;\nimport hudson.widgets.BuildHistoryWidget;\nimport hudson.widgets.HistoryWidget;\nimport jenkins.model.Jenkins;\nimport jenkins.model.JenkinsLocationConfiguration;\nimport jenkins.model.lazy.AbstractLazyLoadRunMap.Direction;\nimport jenkins.scm.DefaultSCMCheckoutStrategyImpl;\nimport jenkins.scm.SCMCheckoutStrategy;\nimport jenkins.scm.SCMCheckoutStrategyDescriptor;\nimport jenkins.util.TimeDuration;\nimport net.sf.json.JSONObject;\nimport org.apache.tools.ant.taskdefs.email.Mailer;\nimport org.kohsuke.accmod.Restricted;\nimport org.kohsuke.accmod.restrictions.NoExternalUse;\nimport org.kohsuke.args4j.Argument;\nimport org.kohsuke.args4j.CmdLineException;\nimport org.kohsuke.stapler.ForwardToView;\nimport org.kohsuke.stapler.HttpRedirect;\nimport org.kohsuke.stapler.HttpResponse;\nimport org.kohsuke.stapler.HttpResponses;\nimport org.kohsuke.stapler.QueryParameter;\nimport org.kohsuke.stapler.StaplerRequest;\nimport org.kohsuke.stapler.StaplerResponse;\nimport org.kohsuke.stapler.export.Exported;\nimport org.kohsuke.stapler.interceptor.RequirePOST;\n\nimport javax.servlet.ServletException;\nimport java.io.File;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Calendar;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.Vector;\nimport java.util.concurrent.Future;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport static hudson.scm.PollingResult.*;\nimport static javax.servlet.http.HttpServletResponse.*;\n\n/**\n * Base implementation of {@link Job}s that build software.\n *\n * For now this is primarily the common part of {@link Project} and MavenModule.\n *\n * @author Kohsuke Kawaguchi\n * @see AbstractBuild\n */\n@SuppressWarnings(\"rawtypes\")\npublic abstract class AbstractProject<P extends AbstractProject<P,R>,R extends AbstractBuild<P,R>> extends Job<P,R> implements BuildableItem {\n\n    /**\n     * {@link SCM} associated with the project.\n     * To allow derived classes to link {@link SCM} config to elsewhere,\n     * access to this variable should always go through {@link #getScm()}.\n     */\n    private volatile SCM scm = new NullSCM();\n\n    /**\n     * Controls how the checkout is done.\n     */\n    private volatile SCMCheckoutStrategy scmCheckoutStrategy;\n\n    /**\n     * State returned from {@link SCM#poll(AbstractProject, Launcher, FilePath, TaskListener, SCMRevisionState)}.\n     */\n    private volatile transient SCMRevisionState pollingBaseline = null;\n\n    /**\n     * All the builds keyed by their build number.\n     *\n     * External code should use {@link #getBuildByNumber(int)} or {@link #getLastBuild()} and traverse via\n     * {@link Run#getPreviousBuild()}\n     */\n    @Restricted(NoExternalUse.class)\n    @SuppressWarnings(\"deprecation\") // [JENKINS-15156] builds accessed before onLoad or onCreatedFromScratch called\n    protected transient RunMap<R> builds = new RunMap<R>();\n\n    /**\n     * The quiet period. Null to delegate to the system default.\n     */\n    private volatile Integer quietPeriod = null;\n    \n    /**\n     * The retry count. Null to delegate to the system default.\n     */\n    private volatile Integer scmCheckoutRetryCount = null;\n\n    /**\n     * If this project is configured to be only built on a certain label,\n     * this value will be set to that label.\n     *\n     * For historical reasons, this is called 'assignedNode'. Also for\n     * a historical reason, null to indicate the affinity\n     * with the master node.\n     *\n     * @see #canRoam\n     */\n    private String assignedNode;\n\n    /**\n     * True if this project can be built on any node.\n     *\n     * <p>\n     * This somewhat ugly flag combination is so that we can migrate\n     * existing Hudson installations nicely.\n     */\n    private volatile boolean canRoam;\n\n    /**\n     * True to suspend new builds.\n     */\n    protected volatile boolean disabled;\n\n    /**\n     * True to keep builds of this project in queue when downstream projects are\n     * building. False by default to keep from breaking existing behavior.\n     */\n    protected volatile boolean blockBuildWhenDownstreamBuilding = false;\n\n    /**\n     * True to keep builds of this project in queue when upstream projects are\n     * building. False by default to keep from breaking existing behavior.\n     */\n    protected volatile boolean blockBuildWhenUpstreamBuilding = false;\n\n    /**\n     * Identifies {@link JDK} to be used.\n     * Null if no explicit configuration is required.\n     *\n     * <p>\n     * Can't store {@link JDK} directly because {@link Jenkins} and {@link Project}\n     * are saved independently.\n     *\n     * @see Jenkins#getJDK(String)\n     */\n    private volatile String jdk;\n\n    private volatile BuildAuthorizationToken authToken = null;\n\n    /**\n     * List of all {@link Trigger}s for this project.\n     */\n    protected List<Trigger<?>> triggers = new Vector<Trigger<?>>();\n\n    /**\n     * {@link Action}s contributed from subsidiary objects associated with\n     * {@link AbstractProject}, such as from triggers, builders, publishers, etc.\n     *\n     * We don't want to persist them separately, and these actions\n     * come and go as configuration change, so it's kept separate.\n     */\n    @CopyOnWrite\n    protected transient volatile List<Action> transientActions = new Vector<Action>();\n\n    private boolean concurrentBuild;\n\n    /**\n     * See {@link #setCustomWorkspace(String)}.\n     *\n     * @since 1.410\n     */\n    private String customWorkspace;\n    \n    protected AbstractProject(ItemGroup parent, String name) {\n        super(parent,name);\n\n        if(!Jenkins.getInstance().getNodes().isEmpty()) {\n            // if a new job is configured with Hudson that already has slave nodes\n            // make it roamable by default\n            canRoam = true;\n        }\n    }\n\n    @Override\n    public synchronized void save() throws IOException {\n        super.save();\n        updateTransientActions();\n    }\n\n    @Override\n    public void onCreatedFromScratch() {\n        super.onCreatedFromScratch();\n        builds = createBuildRunMap();\n        // solicit initial contributions, especially from TransientProjectActionFactory\n        updateTransientActions();\n    }\n\n    @Override\n    public void onLoad(ItemGroup<? extends Item> parent, String name) throws IOException {\n        super.onLoad(parent, name);\n\n        RunMap<R> builds = createBuildRunMap();\n        if (this.builds!=null) {\n            // if we are reloading, keep all those that are still building intact\n            for (R r : this.builds.getLoadedBuilds().values()) {\n                if (r.isBuilding())\n                    builds.put(r);\n            }\n        }\n        this.builds = builds;\n        for (Trigger t : triggers())\n            t.start(this, Items.updatingByXml.get());\n        if(scm==null)\n            scm = new NullSCM(); // perhaps it was pointing to a plugin that no longer exists.\n\n        if(transientActions==null)\n            transientActions = new Vector<Action>();    // happens when loaded from disk\n        updateTransientActions();\n    }\n\n    private RunMap<R> createBuildRunMap() {\n        return new RunMap<R>(getBuildDir(), new Constructor<R>() {\n            public R create(File dir) throws IOException {\n                return loadBuild(dir);\n            }\n        });\n    }\n\n    private synchronized List<Trigger<?>> triggers() {\n        if (triggers == null) {\n            triggers = new Vector<Trigger<?>>();\n        }\n        return triggers;\n    }\n\n    @Override\n    public EnvVars getEnvironment(Node node, TaskListener listener) throws IOException, InterruptedException {\n        EnvVars env =  super.getEnvironment(node, listener);\n\n        JDK jdk = getJDK();\n        if (jdk != null) {\n            if (node != null) { // just in case were not in a build\n                jdk = jdk.forNode(node, listener);\n            }\n            jdk.buildEnvVars(env);\n        }\n\n        return env;\n    }\n\n    @Override\n    protected void performDelete() throws IOException, InterruptedException {\n        // prevent a new build while a delete operation is in progress\n        makeDisabled(true);\n        FilePath ws = getWorkspace();\n        if(ws!=null) {\n            Node on = getLastBuiltOn();\n            getScm().processWorkspaceBeforeDeletion(this, ws, on);\n            if(on!=null)\n                on.getFileSystemProvisioner().discardWorkspace(this,ws);\n        }\n        super.performDelete();\n    }\n\n    /**\n     * Does this project perform concurrent builds?\n     * @since 1.319\n     */\n    @Exported\n    public boolean isConcurrentBuild() {\n        return concurrentBuild;\n    }\n\n    public void setConcurrentBuild(boolean b) throws IOException {\n        concurrentBuild = b;\n        save();\n    }\n\n    /**\n     * If this project is configured to be always built on this node,\n     * return that {@link Node}. Otherwise null.\n     */\n    public Label getAssignedLabel() {\n        if(canRoam)\n            return null;\n\n        if(assignedNode==null)\n            return Jenkins.getInstance().getSelfLabel();\n        return Jenkins.getInstance().getLabel(assignedNode);\n    }\n\n    /**\n     * Set of labels relevant to this job.\n     *\n     * This method is used to determine what slaves are relevant to jobs, for example by {@link View}s.\n     * It does not affect the scheduling. This information is informational and the best-effort basis.\n     *\n     * @since 1.456\n     * @return\n     *      Minimally it should contain {@link #getAssignedLabel()}. The set can contain null element\n     *      to correspond to the null return value from {@link #getAssignedLabel()}.\n     */\n    public Set<Label> getRelevantLabels() {\n        return Collections.singleton(getAssignedLabel());\n    }\n\n    /**\n     * Gets the textual representation of the assigned label as it was entered by the user.\n     */\n    public String getAssignedLabelString() {\n        if (canRoam || assignedNode==null)    return null;\n        try {\n            LabelExpression.parseExpression(assignedNode);\n            return assignedNode;\n        } catch (ANTLRException e) {\n            // must be old label or host name that includes whitespace or other unsafe chars\n            return LabelAtom.escape(assignedNode);\n        }\n    }\n\n    /**\n     * Sets the assigned label.\n     */\n    public void setAssignedLabel(Label l) throws IOException {\n        if(l==null) {\n            canRoam = true;\n            assignedNode = null;\n        } else {\n            canRoam = false;\n            if(l== Jenkins.getInstance().getSelfLabel())  assignedNode = null;\n            else                                        assignedNode = l.getExpression();\n        }\n        save();\n    }\n\n    /**\n     * Assigns this job to the given node. A convenience method over {@link #setAssignedLabel(Label)}.\n     */\n    public void setAssignedNode(Node l) throws IOException {\n        setAssignedLabel(l.getSelfLabel());\n    }\n\n    /**\n     * Get the term used in the UI to represent this kind of {@link AbstractProject}.\n     * Must start with a capital letter.\n     */\n    @Override\n    public String getPronoun() {\n        return AlternativeUiTextProvider.get(PRONOUN, this,Messages.AbstractProject_Pronoun());\n    }\n\n    /**\n     * Gets the human readable display name to be rendered in the \"Build Now\" link.\n     *\n     * @since 1.401\n     */\n    public String getBuildNowText() {\n        return AlternativeUiTextProvider.get(BUILD_NOW_TEXT,this,Messages.AbstractProject_BuildNow());\n    }\n\n    /**\n     * Gets the nearest ancestor {@link TopLevelItem} that's also an {@link AbstractProject}.\n     *\n     * <p>\n     * Some projects (such as matrix projects, Maven projects, or promotion processes) form a tree of jobs\n     * that acts as a single unit. This method can be used to find the top most dominating job that\n     * covers such a tree.\n     *\n     * @return never null.\n     * @see AbstractBuild#getRootBuild()\n     */\n    public AbstractProject<?,?> getRootProject() {\n        if (this instanceof TopLevelItem) {\n            return this;\n        } else {\n            ItemGroup p = this.getParent();\n            if (p instanceof AbstractProject)\n                return ((AbstractProject) p).getRootProject();\n            return this;\n        }\n    }\n\n    /**\n     * Gets the directory where the module is checked out.\n     *\n     * @return\n     *      null if the workspace is on a slave that's not connected.\n     * @deprecated as of 1.319\n     *      To support concurrent builds of the same project, this method is moved to {@link AbstractBuild}.\n     *      For backward compatibility, this method returns the right {@link AbstractBuild#getWorkspace()} if called\n     *      from {@link Executor}, and otherwise the workspace of the last build.\n     *\n     *      <p>\n     *      If you are calling this method during a build from an executor, switch it to {@link AbstractBuild#getWorkspace()}.\n     *      If you are calling this method to serve a file from the workspace, doing a form validation, etc., then\n     *      use {@link #getSomeWorkspace()}\n     */\n    public final FilePath getWorkspace() {\n        AbstractBuild b = getBuildForDeprecatedMethods();\n        return b != null ? b.getWorkspace() : null;\n\n    }\n    \n    /**\n     * Various deprecated methods in this class all need the 'current' build.  This method returns\n     * the build suitable for that purpose.\n     * \n     * @return An AbstractBuild for deprecated methods to use.\n     */\n    private AbstractBuild getBuildForDeprecatedMethods() {\n        Executor e = Executor.currentExecutor();\n        if(e!=null) {\n            Executable exe = e.getCurrentExecutable();\n            if (exe instanceof AbstractBuild) {\n                AbstractBuild b = (AbstractBuild) exe;\n                if(b.getProject()==this)\n                    return b;\n            }\n        }\n        R lb = getLastBuild();\n        if(lb!=null)    return lb;\n        return null;\n    }\n\n    /**\n     * Gets a workspace for some build of this project.\n     *\n     * <p>\n     * This is useful for obtaining a workspace for the purpose of form field validation, where exactly\n     * which build the workspace belonged is less important. The implementation makes a cursory effort\n     * to find some workspace.\n     *\n     * @return\n     *      null if there's no available workspace.\n     * @since 1.319\n     */\n    public final FilePath getSomeWorkspace() {\n        R b = getSomeBuildWithWorkspace();\n        if (b!=null) return b.getWorkspace();\n        for (WorkspaceBrowser browser : Jenkins.getInstance().getExtensionList(WorkspaceBrowser.class)) {\n            FilePath f = browser.getWorkspace(this);\n            if (f != null) return f;\n        }\n        return null;\n    }\n\n    /**\n     * Gets some build that has a live workspace.\n     *\n     * @return null if no such build exists.\n     */\n    public final R getSomeBuildWithWorkspace() {\n        int cnt=0;\n        for (R b = getLastBuild(); cnt<5 && b!=null; b=b.getPreviousBuild()) {\n            FilePath ws = b.getWorkspace();\n            if (ws!=null)   return b;\n        }\n        return null;\n    }\n\n    /**\n     * Returns the root directory of the checked-out module.\n     * <p>\n     * This is usually where <tt>pom.xml</tt>, <tt>build.xml</tt>\n     * and so on exists.\n     *\n     * @deprecated as of 1.319\n     *      See {@link #getWorkspace()} for a migration strategy.\n     */\n    public FilePath getModuleRoot() {\n        AbstractBuild b = getBuildForDeprecatedMethods();\n        return b != null ? b.getModuleRoot() : null;\n    }\n\n    /**\n     * Returns the root directories of all checked-out modules.\n     * <p>\n     * Some SCMs support checking out multiple modules into the same workspace.\n     * In these cases, the returned array will have a length greater than one.\n     * @return The roots of all modules checked out from the SCM.\n     *\n     * @deprecated as of 1.319\n     *      See {@link #getWorkspace()} for a migration strategy.\n     */\n    public FilePath[] getModuleRoots() {\n        AbstractBuild b = getBuildForDeprecatedMethods();\n        return b != null ? b.getModuleRoots() : null;\n    }\n\n    public int getQuietPeriod() {\n        return quietPeriod!=null ? quietPeriod : Jenkins.getInstance().getQuietPeriod();\n    }\n\n    public SCMCheckoutStrategy getScmCheckoutStrategy() {\n        return scmCheckoutStrategy == null ? new DefaultSCMCheckoutStrategyImpl() : scmCheckoutStrategy;\n    }\n\n    public void setScmCheckoutStrategy(SCMCheckoutStrategy scmCheckoutStrategy) throws IOException {\n        this.scmCheckoutStrategy = scmCheckoutStrategy;\n        save();\n    }\n\n\n    public int getScmCheckoutRetryCount() {\n        return scmCheckoutRetryCount !=null ? scmCheckoutRetryCount : Jenkins.getInstance().getScmCheckoutRetryCount();\n    }\n\n    // ugly name because of EL\n    public boolean getHasCustomQuietPeriod() {\n        return quietPeriod!=null;\n    }\n\n    /**\n     * Sets the custom quiet period of this project, or revert to the global default if null is given. \n     */\n    public void setQuietPeriod(Integer seconds) throws IOException {\n        this.quietPeriod = seconds;\n        save();\n    }\n    \n    public boolean hasCustomScmCheckoutRetryCount(){\n        return scmCheckoutRetryCount != null;\n    }\n\n    @Override\n    public boolean isBuildable() {\n        return !isDisabled() && !isHoldOffBuildUntilSave();\n    }\n\n    /**\n     * Used in <tt>sidepanel.jelly</tt> to decide whether to display\n     * the config/delete/build links.\n     */\n    public boolean isConfigurable() {\n        return true;\n    }\n\n    public boolean blockBuildWhenDownstreamBuilding() {\n        return blockBuildWhenDownstreamBuilding;\n    }\n\n    public void setBlockBuildWhenDownstreamBuilding(boolean b) throws IOException {\n        blockBuildWhenDownstreamBuilding = b;\n        save();\n    }\n\n    public boolean blockBuildWhenUpstreamBuilding() {\n        return blockBuildWhenUpstreamBuilding;\n    }\n\n    public void setBlockBuildWhenUpstreamBuilding(boolean b) throws IOException {\n        blockBuildWhenUpstreamBuilding = b;\n        save();\n    }\n\n    public boolean isDisabled() {\n        return disabled;\n    }\n    \n    /**\n     * Validates the retry count Regex\n     */\n    public FormValidation doCheckRetryCount(@QueryParameter String value)throws IOException,ServletException{\n        // retry count is optional so this is ok\n        if(value == null || value.trim().equals(\"\"))\n            return FormValidation.ok();\n        if (!value.matches(\"[0-9]*\")) {\n            return FormValidation.error(\"Invalid retry count\");\n        } \n        return FormValidation.ok();\n    }\n\n    /**\n     * Marks the build as disabled.\n     */\n    public void makeDisabled(boolean b) throws IOException {\n        if(disabled==b)     return; // noop\n        this.disabled = b;\n        if(b)\n            Jenkins.getInstance().getQueue().cancel(this);\n        save();\n    }\n\n    /**\n     * Specifies whether this project may be disabled by the user.\n     * By default, it can be only if this is a {@link TopLevelItem};\n     * would be false for matrix configurations, etc.\n     * @return true if the GUI should allow {@link #doDisable} and the like\n     * @since 1.475\n     */\n    public boolean supportsMakeDisabled() {\n        return this instanceof TopLevelItem;\n    }\n\n    public void disable() throws IOException {\n        makeDisabled(true);\n    }\n\n    public void enable() throws IOException {\n        makeDisabled(false);\n    }\n\n    @Override\n    public BallColor getIconColor() {\n        if(isDisabled())\n            return BallColor.DISABLED;\n        else\n            return super.getIconColor();\n    }\n\n    /**\n     * effectively deprecated. Since using updateTransientActions correctly\n     * under concurrent environment requires a lock that can too easily cause deadlocks.\n     *\n     * <p>\n     * Override {@link #createTransientActions()} instead.\n     */\n    protected void updateTransientActions() {\n        transientActions = createTransientActions();\n    }\n\n    protected List<Action> createTransientActions() {\n        Vector<Action> ta = new Vector<Action>();\n\n        for (JobProperty<? super P> p : Util.fixNull(properties))\n            ta.addAll(p.getJobActions((P)this));\n\n        for (TransientProjectActionFactory tpaf : TransientProjectActionFactory.all())\n            ta.addAll(Util.fixNull(tpaf.createFor(this))); // be defensive against null\n        return ta;\n    }\n\n    /**\n     * Returns the live list of all {@link Publisher}s configured for this project.\n     *\n     * <p>\n     * This method couldn't be called <tt>getPublishers()</tt> because existing methods\n     * in sub-classes return different inconsistent types.\n     */\n    public abstract DescribableList<Publisher,Descriptor<Publisher>> getPublishersList();\n\n    @Override\n    public void addProperty(JobProperty<? super P> jobProp) throws IOException {\n        super.addProperty(jobProp);\n        updateTransientActions();\n    }\n\n    public List<ProminentProjectAction> getProminentActions() {\n        List<Action> a = getActions();\n        List<ProminentProjectAction> pa = new Vector<ProminentProjectAction>();\n        for (Action action : a) {\n            if(action instanceof ProminentProjectAction)\n                pa.add((ProminentProjectAction) action);\n        }\n        return pa;\n    }\n\n    @Override\n    public void doConfigSubmit( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException, FormException {\n        super.doConfigSubmit(req,rsp);\n\n        updateTransientActions();\n\n        Set<AbstractProject> upstream = Collections.emptySet();\n        if(req.getParameter(\"pseudoUpstreamTrigger\")!=null) {\n            upstream = new HashSet<AbstractProject>(Items.fromNameList(getParent(),req.getParameter(\"upstreamProjects\"),AbstractProject.class));\n        }\n\n        // dependency setting might have been changed by the user, so rebuild.\n        Jenkins.getInstance().rebuildDependencyGraph();\n\n        // reflect the submission of the pseudo 'upstream build trriger'.\n        // this needs to be done after we release the lock on 'this',\n        // or otherwise we could dead-lock\n\n        for (AbstractProject<?,?> p : Jenkins.getInstance().getAllItems(AbstractProject.class)) {\n            // Don't consider child projects such as MatrixConfiguration:\n            if (!p.isConfigurable()) continue;\n            boolean isUpstream = upstream.contains(p);\n            synchronized(p) {\n                // does 'p' include us in its BuildTrigger? \n                DescribableList<Publisher,Descriptor<Publisher>> pl = p.getPublishersList();\n                BuildTrigger trigger = pl.get(BuildTrigger.class);\n                List<AbstractProject> newChildProjects = trigger == null ? new ArrayList<AbstractProject>():trigger.getChildProjects(p);\n                if(isUpstream) {\n                    if(!newChildProjects.contains(this))\n                        newChildProjects.add(this);\n                } else {\n                    newChildProjects.remove(this);\n                }\n\n                if(newChildProjects.isEmpty()) {\n                    pl.remove(BuildTrigger.class);\n                } else {\n                    // here, we just need to replace the old one with the new one,\n                    // but there was a regression (we don't know when it started) that put multiple BuildTriggers\n                    // into the list.\n                    // for us not to lose the data, we need to merge them all.\n                    List<BuildTrigger> existingList = pl.getAll(BuildTrigger.class);\n                    BuildTrigger existing;\n                    switch (existingList.size()) {\n                    case 0:\n                        existing = null;\n                        break;\n                    case 1:\n                        existing = existingList.get(0);\n                        break;\n                    default:\n                        pl.removeAll(BuildTrigger.class);\n                        Set<AbstractProject> combinedChildren = new HashSet<AbstractProject>();\n                        for (BuildTrigger bt : existingList)\n                            combinedChildren.addAll(bt.getChildProjects(p));\n                        existing = new BuildTrigger(new ArrayList<AbstractProject>(combinedChildren),existingList.get(0).getThreshold());\n                        pl.add(existing);\n                        break;\n                    }\n\n                    if(existing!=null && existing.hasSame(p,newChildProjects))\n                        continue;   // no need to touch\n                    pl.replace(new BuildTrigger(newChildProjects,\n                        existing==null?Result.SUCCESS:existing.getThreshold()));\n                }\n            }\n        }\n\n        // notify the queue as the project might be now tied to different node\n        Jenkins.getInstance().getQueue().scheduleMaintenance();\n\n        // this is to reflect the upstream build adjustments done above\n        Jenkins.getInstance().rebuildDependencyGraph();\n    }\n\n\t/**\n\t * @deprecated\n\t *    Use {@link #scheduleBuild(Cause)}.  Since 1.283\n\t */\n    public boolean scheduleBuild() {\n    \treturn scheduleBuild(new LegacyCodeCause());\n    }\n    \n\t/**\n\t * @deprecated\n\t *    Use {@link #scheduleBuild(int, Cause)}.  Since 1.283\n\t */\n    public boolean scheduleBuild(int quietPeriod) {\n    \treturn scheduleBuild(quietPeriod, new LegacyCodeCause());\n    }\n    \n    /**\n     * Schedules a build of this project.\n     *\n     * @return\n     *      true if the project is actually added to the queue.\n     *      false if the queue contained it and therefore the add()\n     *      was noop\n     */\n    public boolean scheduleBuild(Cause c) {\n        return scheduleBuild(getQuietPeriod(), c);\n    }\n\n    public boolean scheduleBuild(int quietPeriod, Cause c) {\n        return scheduleBuild(quietPeriod, c, new Action[0]);\n    }\n\n    /**\n     * Schedules a build.\n     *\n     * Important: the actions should be persistable without outside references (e.g. don't store\n     * references to this project). To provide parameters for a parameterized project, add a ParametersAction. If\n     * no ParametersAction is provided for such a project, one will be created with the default parameter values.\n     *\n     * @param quietPeriod the quiet period to observer\n     * @param c the cause for this build which should be recorded\n     * @param actions a list of Actions that will be added to the build\n     * @return whether the build was actually scheduled\n     */\n    public boolean scheduleBuild(int quietPeriod, Cause c, Action... actions) {\n        return scheduleBuild2(quietPeriod,c,actions)!=null;\n    }\n\n    /**\n     * Schedules a build of this project, and returns a {@link Future} object\n     * to wait for the completion of the build.\n     *\n     * @param actions\n     *      For the convenience of the caller, this array can contain null, and those will be silently ignored.\n     */\n    @WithBridgeMethods(Future.class)\n    public QueueTaskFuture<R> scheduleBuild2(int quietPeriod, Cause c, Action... actions) {\n        return scheduleBuild2(quietPeriod,c,Arrays.asList(actions));\n    }\n\n    /**\n     * Schedules a build of this project, and returns a {@link Future} object\n     * to wait for the completion of the build.\n     *\n     * @param actions\n     *      For the convenience of the caller, this collection can contain null, and those will be silently ignored.\n     * @since 1.383\n     */\n    @SuppressWarnings(\"unchecked\")\n    @WithBridgeMethods(Future.class)\n    public QueueTaskFuture<R> scheduleBuild2(int quietPeriod, Cause c, Collection<? extends Action> actions) {\n        if (!isBuildable())\n            return null;\n\n        List<Action> queueActions = new ArrayList<Action>(actions);\n        if (isParameterized() && Util.filter(queueActions, ParametersAction.class).isEmpty()) {\n            queueActions.add(new ParametersAction(getDefaultParametersValues()));\n        }\n\n        if (c != null) {\n            queueActions.add(new CauseAction(c));\n        }\n\n        WaitingItem i = Jenkins.getInstance().getQueue().schedule(this, quietPeriod, queueActions);\n        if(i!=null)\n            return (QueueTaskFuture)i.getFuture();\n        return null;\n    }\n\n    private List<ParameterValue> getDefaultParametersValues() {\n        ParametersDefinitionProperty paramDefProp = getProperty(ParametersDefinitionProperty.class);\n        ArrayList<ParameterValue> defValues = new ArrayList<ParameterValue>();\n        \n        /*\n         * This check is made ONLY if someone will call this method even if isParametrized() is false.\n         */\n        if(paramDefProp == null)\n            return defValues;\n        \n        /* Scan for all parameter with an associated default values */\n        for(ParameterDefinition paramDefinition : paramDefProp.getParameterDefinitions())\n        {\n           ParameterValue defaultValue  = paramDefinition.getDefaultParameterValue();\n            \n            if(defaultValue != null)\n                defValues.add(defaultValue);           \n        }\n        \n        return defValues;\n    }\n\n    /**\n     * Schedules a build, and returns a {@link Future} object\n     * to wait for the completion of the build.\n     *\n     * <p>\n     * Production code shouldn't be using this, but for tests this is very convenient, so this isn't marked\n     * as deprecated.\n     */\n    @SuppressWarnings(\"deprecation\")\n    @WithBridgeMethods(Future.class)\n    public QueueTaskFuture<R> scheduleBuild2(int quietPeriod) {\n        return scheduleBuild2(quietPeriod, new LegacyCodeCause());\n    }\n    \n    /**\n     * Schedules a build of this project, and returns a {@link Future} object\n     * to wait for the completion of the build.\n     */\n    @WithBridgeMethods(Future.class)\n    public QueueTaskFuture<R> scheduleBuild2(int quietPeriod, Cause c) {\n        return scheduleBuild2(quietPeriod, c, new Action[0]);\n    }\n\n    /**\n     * Schedules a polling of this project.\n     */\n    public boolean schedulePolling() {\n        if(isDisabled())    return false;\n        SCMTrigger scmt = getTrigger(SCMTrigger.class);\n        if(scmt==null)      return false;\n        scmt.run();\n        return true;\n    }\n\n    /**\n     * Returns true if the build is in the queue.\n     */\n    @Override\n    public boolean isInQueue() {\n        return Jenkins.getInstance().getQueue().contains(this);\n    }\n\n    @Override\n    public Queue.Item getQueueItem() {\n        return Jenkins.getInstance().getQueue().getItem(this);\n    }\n\n    /**\n     * Gets the JDK that this project is configured with, or null.\n     */\n    public JDK getJDK() {\n        return Jenkins.getInstance().getJDK(jdk);\n    }\n\n    /**\n     * Overwrites the JDK setting.\n     */\n    public void setJDK(JDK jdk) throws IOException {\n        this.jdk = jdk.getName();\n        save();\n    }\n\n    public BuildAuthorizationToken getAuthToken() {\n        return authToken;\n    }\n\n    @Override\n    public RunMap<R> _getRuns() {\n        return builds;\n    }\n\n    @Override\n    public void removeRun(R run) {\n        this.builds.remove(run);\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * More efficient implementation.\n     */\n    @Override\n    public R getBuild(String id) {\n        return builds.getById(id);\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * More efficient implementation.\n     */\n    @Override\n    public R getBuildByNumber(int n) {\n        return builds.getByNumber(n);\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * More efficient implementation.\n     */\n    @Override\n    public R getFirstBuild() {\n        return builds.oldestBuild();\n    }\n\n    @Override\n    public R getLastBuild() {\n        return builds.newestBuild();\n    }\n\n    @Override\n    public R getNearestBuild(int n) {\n        return builds.search(n, Direction.ASC);\n    }\n\n    @Override\n    public R getNearestOldBuild(int n) {\n        return builds.search(n, Direction.DESC);\n    }\n\n    /**\n     * Determines Class&lt;R>.\n     */\n    protected abstract Class<R> getBuildClass();\n\n    // keep track of the previous time we started a build\n    private transient long lastBuildStartTime;\n    \n    /**\n     * Creates a new build of this project for immediate execution.\n     */\n    protected synchronized R newBuild() throws IOException {\n    \t// make sure we don't start two builds in the same second\n    \t// so the build directories will be different too\n    \tlong timeSinceLast = System.currentTimeMillis() - lastBuildStartTime;\n    \tif (timeSinceLast < 1000) {\n    \t\ttry {\n\t\t\t\tThread.sleep(1000 - timeSinceLast);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t}\n    \t}\n    \tlastBuildStartTime = System.currentTimeMillis();\n        try {\n            R lastBuild = getBuildClass().getConstructor(getClass()).newInstance(this);\n            builds.put(lastBuild);\n            return lastBuild;\n        } catch (InstantiationException e) {\n            throw new Error(e);\n        } catch (IllegalAccessException e) {\n            throw new Error(e);\n        } catch (InvocationTargetException e) {\n            throw handleInvocationTargetException(e);\n        } catch (NoSuchMethodException e) {\n            throw new Error(e);\n        }\n    }\n\n    private IOException handleInvocationTargetException(InvocationTargetException e) {\n        Throwable t = e.getTargetException();\n        if(t instanceof Error)  throw (Error)t;\n        if(t instanceof RuntimeException)   throw (RuntimeException)t;\n        if(t instanceof IOException)    return (IOException)t;\n        throw new Error(t);\n    }\n\n    /**\n     * Loads an existing build record from disk.\n     */\n    protected R loadBuild(File dir) throws IOException {\n        try {\n            return getBuildClass().getConstructor(getClass(),File.class).newInstance(this,dir);\n        } catch (InstantiationException e) {\n            throw new Error(e);\n        } catch (IllegalAccessException e) {\n            throw new Error(e);\n        } catch (InvocationTargetException e) {\n            throw handleInvocationTargetException(e);\n        } catch (NoSuchMethodException e) {\n            throw new Error(e);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * <p>\n     * Note that this method returns a read-only view of {@link Action}s.\n     * {@link BuildStep}s and others who want to add a project action\n     * should do so by implementing {@link BuildStep#getProjectActions(AbstractProject)}.\n     *\n     * @see TransientProjectActionFactory\n     */\n    @Override\n    public synchronized List<Action> getActions() {\n        // add all the transient actions, too\n        List<Action> actions = new Vector<Action>(super.getActions());\n        actions.addAll(transientActions);\n        // return the read only list to cause a failure on plugins who try to add an action here\n        return Collections.unmodifiableList(actions);\n    }\n\n    /**\n     * Gets the {@link Node} where this project was last built on.\n     *\n     * @return\n     *      null if no information is available (for example,\n     *      if no build was done yet.)\n     */\n    public Node getLastBuiltOn() {\n        // where was it built on?\n        AbstractBuild b = getLastBuild();\n        if(b==null)\n            return null;\n        else\n            return b.getBuiltOn();\n    }\n\n    public Object getSameNodeConstraint() {\n        return this; // in this way, any member that wants to run with the main guy can nominate the project itself \n    }\n\n    public final Task getOwnerTask() {\n        return this;\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * <p>\n     * A project must be blocked if its own previous build is in progress,\n     * or if the blockBuildWhenUpstreamBuilding option is true and an upstream\n     * project is building, but derived classes can also check other conditions.\n     */\n    public boolean isBuildBlocked() {\n        return getCauseOfBlockage()!=null;\n    }\n\n    public String getWhyBlocked() {\n        CauseOfBlockage cb = getCauseOfBlockage();\n        return cb!=null ? cb.getShortDescription() : null;\n    }\n\n    /**\n     * Blocked because the previous build is already in progress.\n     */\n    public static class BecauseOfBuildInProgress extends CauseOfBlockage {\n        private final AbstractBuild<?,?> build;\n\n        public BecauseOfBuildInProgress(AbstractBuild<?, ?> build) {\n            this.build = build;\n        }\n\n        @Override\n        public String getShortDescription() {\n            Executor e = build.getExecutor();\n            String eta = \"\";\n            if (e != null)\n                eta = Messages.AbstractProject_ETA(e.getEstimatedRemainingTime());\n            int lbn = build.getNumber();\n            return Messages.AbstractProject_BuildInProgress(lbn, eta);\n        }\n    }\n    \n    /**\n     * Because the downstream build is in progress, and we are configured to wait for that.\n     */\n    public static class BecauseOfDownstreamBuildInProgress extends CauseOfBlockage {\n        public final AbstractProject<?,?> up;\n\n        public BecauseOfDownstreamBuildInProgress(AbstractProject<?,?> up) {\n            this.up = up;\n        }\n\n        @Override\n        public String getShortDescription() {\n            return Messages.AbstractProject_DownstreamBuildInProgress(up.getName());\n        }\n    }\n\n    /**\n     * Because the upstream build is in progress, and we are configured to wait for that.\n     */\n    public static class BecauseOfUpstreamBuildInProgress extends CauseOfBlockage {\n        public final AbstractProject<?,?> up;\n\n        public BecauseOfUpstreamBuildInProgress(AbstractProject<?,?> up) {\n            this.up = up;\n        }\n\n        @Override\n        public String getShortDescription() {\n            return Messages.AbstractProject_UpstreamBuildInProgress(up.getName());\n        }\n    }\n\n    public CauseOfBlockage getCauseOfBlockage() {\n        // Block builds until they are done with post-production\n        if (isLogUpdated() && !isConcurrentBuild())\n            return new BecauseOfBuildInProgress(getLastBuild());\n        if (blockBuildWhenDownstreamBuilding()) {\n            AbstractProject<?,?> bup = getBuildingDownstream();\n            if (bup!=null)\n                return new BecauseOfDownstreamBuildInProgress(bup);\n        }\n        if (blockBuildWhenUpstreamBuilding()) {\n            AbstractProject<?,?> bup = getBuildingUpstream();\n            if (bup!=null)\n                return new BecauseOfUpstreamBuildInProgress(bup);\n        }\n        return null;\n    }\n\n    /**\n     * Returns the project if any of the downstream project is either\n     * building, waiting, pending or buildable.\n     * <p>\n     * This means eventually there will be an automatic triggering of\n     * the given project (provided that all builds went smoothly.)\n     */\n    public AbstractProject getBuildingDownstream() {\n        Set<Task> unblockedTasks = Jenkins.getInstance().getQueue().getUnblockedTasks();\n\n        for (AbstractProject tup : getTransitiveDownstreamProjects()) {\n\t\t\tif (tup!=this && (tup.isBuilding() || unblockedTasks.contains(tup)))\n                return tup;\n        }\n        return null;\n    }\n\n    /**\n     * Returns the project if any of the upstream project is either\n     * building or is in the queue.\n     * <p>\n     * This means eventually there will be an automatic triggering of\n     * the given project (provided that all builds went smoothly.)\n     */\n    public AbstractProject getBuildingUpstream() {\n        Set<Task> unblockedTasks = Jenkins.getInstance().getQueue().getUnblockedTasks();\n\n        for (AbstractProject tup : getTransitiveUpstreamProjects()) {\n\t\t\tif (tup!=this && (tup.isBuilding() || unblockedTasks.contains(tup)))\n                return tup;\n        }\n        return null;\n    }\n\n    public List<SubTask> getSubTasks() {\n        List<SubTask> r = new ArrayList<SubTask>();\n        r.add(this);\n        for (SubTaskContributor euc : SubTaskContributor.all())\n            r.addAll(euc.forProject(this));\n        for (JobProperty<? super P> p : properties)\n            r.addAll(p.getSubTasks());\n        return r;\n    }\n\n    public R createExecutable() throws IOException {\n        if(isDisabled())    return null;\n        return newBuild();\n    }\n\n    public void checkAbortPermission() {\n        checkPermission(AbstractProject.ABORT);\n    }\n\n    public boolean hasAbortPermission() {\n        return hasPermission(AbstractProject.ABORT);\n    }\n\n    /**\n     * Gets the {@link Resource} that represents the workspace of this project.\n     * Useful for locking and mutual exclusion control.\n     *\n     * @deprecated as of 1.319\n     *      Projects no longer have a fixed workspace, ands builds will find an available workspace via\n     *      {@link WorkspaceList} for each build (furthermore, that happens after a build is started.)\n     *      So a {@link Resource} representation for a workspace at the project level no longer makes sense.\n     *\n     *      <p>\n     *      If you need to lock a workspace while you do some computation, see the source code of\n     *      {@link #pollSCMChanges(TaskListener)} for how to obtain a lock of a workspace through {@link WorkspaceList}.\n     */\n    public Resource getWorkspaceResource() {\n        return new Resource(getFullDisplayName()+\" workspace\");\n    }\n\n    /**\n     * List of necessary resources to perform the build of this project.\n     */\n    public ResourceList getResourceList() {\n        final Set<ResourceActivity> resourceActivities = getResourceActivities();\n        final List<ResourceList> resourceLists = new ArrayList<ResourceList>(1 + resourceActivities.size());\n        for (ResourceActivity activity : resourceActivities) {\n            if (activity != this && activity != null) {\n                // defensive infinite recursion and null check\n                resourceLists.add(activity.getResourceList());\n            }\n        }\n        return ResourceList.union(resourceLists);\n    }\n\n    /**\n     * Set of child resource activities of the build of this project (override in child projects).\n     * @return The set of child resource activities of the build of this project.\n     */\n    protected Set<ResourceActivity> getResourceActivities() {\n        return Collections.emptySet();\n    }\n\n    public boolean checkout(AbstractBuild build, Launcher launcher, BuildListener listener, File changelogFile) throws IOException, InterruptedException {\n        SCM scm = getScm();\n        if(scm==null)\n            return true;    // no SCM\n\n        FilePath workspace = build.getWorkspace();\n        workspace.mkdirs();\n        \n        boolean r = scm.checkout(build, launcher, workspace, listener, changelogFile);\n        if (r) {\n            // Only calcRevisionsFromBuild if checkout was successful. Note that modern SCM implementations\n            // won't reach this line anyway, as they throw AbortExceptions on checkout failure.\n            calcPollingBaseline(build, launcher, listener);\n        }\n        return r;\n    }\n\n    /**\n     * Pushes the baseline up to the newly checked out revision.\n     */\n    private void calcPollingBaseline(AbstractBuild build, Launcher launcher, TaskListener listener) throws IOException, InterruptedException {\n        SCMRevisionState baseline = build.getAction(SCMRevisionState.class);\n        if (baseline==null) {\n            try {\n                baseline = getScm()._calcRevisionsFromBuild(build, launcher, listener);\n            } catch (AbstractMethodError e) {\n                baseline = SCMRevisionState.NONE; // pre-1.345 SCM implementations, which doesn't use the baseline in polling\n            }\n            if (baseline!=null)\n                build.addAction(baseline);\n        }\n        pollingBaseline = baseline;\n    }\n\n    /**\n     * Checks if there's any update in SCM, and returns true if any is found.\n     *\n     * @deprecated as of 1.346\n     *      Use {@link #poll(TaskListener)} instead.\n     */\n    public boolean pollSCMChanges( TaskListener listener ) {\n        return poll(listener).hasChanges();\n    }\n\n    /**\n     * Checks if there's any update in SCM, and returns true if any is found.\n     *\n     * <p>\n     * The implementation is responsible for ensuring mutual exclusion between polling and builds\n     * if necessary.\n     *\n     * @since 1.345\n     */\n    public PollingResult poll( TaskListener listener ) {\n        SCM scm = getScm();\n        if (scm==null) {\n            listener.getLogger().println(Messages.AbstractProject_NoSCM());\n            return NO_CHANGES;\n        }\n        if (!isBuildable()) {\n            listener.getLogger().println(Messages.AbstractProject_Disabled());\n            return NO_CHANGES;\n        }\n\n        R lb = getLastBuild();\n        if (lb==null) {\n            listener.getLogger().println(Messages.AbstractProject_NoBuilds());\n            return isInQueue() ? NO_CHANGES : BUILD_NOW;\n        }\n\n        if (pollingBaseline==null) {\n            R success = getLastSuccessfulBuild(); // if we have a persisted baseline, we'll find it by this\n            for (R r=lb; r!=null; r=r.getPreviousBuild()) {\n                SCMRevisionState s = r.getAction(SCMRevisionState.class);\n                if (s!=null) {\n                    pollingBaseline = s;\n                    break;\n                }\n                if (r==success) break;  // searched far enough\n            }\n            // NOTE-NO-BASELINE:\n            // if we don't have baseline yet, it means the data is built by old Hudson that doesn't set the baseline\n            // as action, so we need to compute it. This happens later.\n        }\n\n        try {\n            SCMPollListener.fireBeforePolling(this, listener);\n            PollingResult r = _poll(listener, scm, lb);\n            SCMPollListener.firePollingSuccess(this,listener, r);\n            return r;\n        } catch (AbortException e) {\n            listener.getLogger().println(e.getMessage());\n            listener.fatalError(Messages.AbstractProject_Aborted());\n            LOGGER.log(Level.FINE, \"Polling \"+this+\" aborted\",e);\n            SCMPollListener.firePollingFailed(this, listener,e);\n            return NO_CHANGES;\n        } catch (IOException e) {\n            e.printStackTrace(listener.fatalError(e.getMessage()));\n            SCMPollListener.firePollingFailed(this, listener,e);\n            return NO_CHANGES;\n        } catch (InterruptedException e) {\n            e.printStackTrace(listener.fatalError(Messages.AbstractProject_PollingABorted()));\n            SCMPollListener.firePollingFailed(this, listener,e);\n            return NO_CHANGES;\n        } catch (RuntimeException e) {\n            SCMPollListener.firePollingFailed(this, listener,e);\n            throw e;\n        } catch (Error e) {\n            SCMPollListener.firePollingFailed(this, listener,e);\n            throw e;\n        }\n    }\n\n    /**\n     * {@link #poll(TaskListener)} method without the try/catch block that does listener notification and .\n     */\n    private PollingResult _poll(TaskListener listener, SCM scm, R lb) throws IOException, InterruptedException {\n        if (scm.requiresWorkspaceForPolling()) {\n            // lock the workspace of the last build\n            FilePath ws=lb.getWorkspace();\n\n            WorkspaceOfflineReason workspaceOfflineReason = workspaceOffline( lb );\n            if ( workspaceOfflineReason != null ) {\n                // workspace offline\n                for (WorkspaceBrowser browser : Jenkins.getInstance().getExtensionList(WorkspaceBrowser.class)) {\n                    ws = browser.getWorkspace(this);\n                    if (ws != null) {\n                        return pollWithWorkspace(listener, scm, lb, ws, browser.getWorkspaceList());\n                    }\n                }\n\n                // build now, or nothing will ever be built\n                Label label = getAssignedLabel();\n                if (label != null && label.isSelfLabel()) {\n                    // if the build is fixed on a node, then attempting a build will do us\n                    // no good. We should just wait for the slave to come back.\n                    listener.getLogger().print(Messages.AbstractProject_NoWorkspace());\n                    listener.getLogger().println( \" (\" + workspaceOfflineReason.name() + \")\");\n                    return NO_CHANGES;\n                }\n                listener.getLogger().println( ws==null\n                    ? Messages.AbstractProject_WorkspaceOffline()\n                    : Messages.AbstractProject_NoWorkspace());\n                if (isInQueue()) {\n                    listener.getLogger().println(Messages.AbstractProject_AwaitingBuildForWorkspace());\n                    return NO_CHANGES;\n                } else {\n                    listener.getLogger().print(Messages.AbstractProject_NewBuildForWorkspace());\n                    listener.getLogger().println( \" (\" + workspaceOfflineReason.name() + \")\");\n                    return BUILD_NOW;\n                }\n            } else {\n                WorkspaceList l = lb.getBuiltOn().toComputer().getWorkspaceList();\n                return pollWithWorkspace(listener, scm, lb, ws, l);\n\n            }\n        } else {\n            // polling without workspace\n            LOGGER.fine(\"Polling SCM changes of \" + getName());\n\n            if (pollingBaseline==null) // see NOTE-NO-BASELINE above\n                calcPollingBaseline(lb,null,listener);\n            PollingResult r = scm.poll(this, null, null, listener, pollingBaseline);\n            pollingBaseline = r.remote;\n            return r;\n        }\n    }\n\n    private PollingResult pollWithWorkspace(TaskListener listener, SCM scm, R lb, FilePath ws, WorkspaceList l) throws InterruptedException, IOException {\n        // if doing non-concurrent build, acquire a workspace in a way that causes builds to block for this workspace.\n        // this prevents multiple workspaces of the same job --- the behavior of Hudson < 1.319.\n        //\n        // OTOH, if a concurrent build is chosen, the user is willing to create a multiple workspace,\n        // so better throughput is achieved over time (modulo the initial cost of creating that many workspaces)\n        // by having multiple workspaces\n        WorkspaceList.Lease lease = l.acquire(ws, !concurrentBuild);\n        Launcher launcher = ws.createLauncher(listener).decorateByEnv(getEnvironment(lb.getBuiltOn(),listener));\n        try {\n            LOGGER.fine(\"Polling SCM changes of \" + getName());\n            if (pollingBaseline==null) // see NOTE-NO-BASELINE above\n                calcPollingBaseline(lb,launcher,listener);\n            PollingResult r = scm.poll(this, launcher, ws, listener, pollingBaseline);\n            pollingBaseline = r.remote;\n            return r;\n        } finally {\n            lease.release();\n        }\n    }\n\n    enum WorkspaceOfflineReason {\n        nonexisting_workspace,\n        builton_node_gone,\n        builton_node_no_executors\n    }\n\n    private WorkspaceOfflineReason workspaceOffline(R build) throws IOException, InterruptedException {\n        FilePath ws = build.getWorkspace();\n        if (ws==null || !ws.exists()) {\n            return WorkspaceOfflineReason.nonexisting_workspace;\n        }\n        \n        Node builtOn = build.getBuiltOn();\n        if (builtOn == null) { // node built-on doesn't exist anymore\n            return WorkspaceOfflineReason.builton_node_gone;\n        }\n        \n        if (builtOn.toComputer() == null) { // node still exists, but has 0 executors - o.s.l.t.\n            return WorkspaceOfflineReason.builton_node_no_executors;\n        }\n\n        return null;\n    }\n\n    /**\n     * Returns true if this user has made a commit to this project.\n     *\n     * @since 1.191\n     */\n    public boolean hasParticipant(User user) {\n        for( R build = getLastBuild(); build!=null; build=build.getPreviousBuild())\n            if(build.hasParticipant(user))\n                return true;\n        return false;\n    }\n\n    @Exported\n    public SCM getScm() {\n        return scm;\n    }\n\n    public void setScm(SCM scm) throws IOException {\n        this.scm = scm;\n        save();\n    }\n\n    /**\n     * Adds a new {@link Trigger} to this {@link Project} if not active yet.\n     */\n    public void addTrigger(Trigger<?> trigger) throws IOException {\n        addToList(trigger,triggers());\n    }\n\n    public void removeTrigger(TriggerDescriptor trigger) throws IOException {\n        removeFromList(trigger,triggers());\n    }\n\n    protected final synchronized <T extends Describable<T>>\n    void addToList( T item, List<T> collection ) throws IOException {\n        for( int i=0; i<collection.size(); i++ ) {\n            if(collection.get(i).getDescriptor()==item.getDescriptor()) {\n                // replace\n                collection.set(i,item);\n                save();\n                return;\n            }\n        }\n        // add\n        collection.add(item);\n        save();\n        updateTransientActions();\n    }\n\n    protected final synchronized <T extends Describable<T>>\n    void removeFromList(Descriptor<T> item, List<T> collection) throws IOException {\n        for( int i=0; i< collection.size(); i++ ) {\n            if(collection.get(i).getDescriptor()==item) {\n                // found it\n                collection.remove(i);\n                save();\n                updateTransientActions();\n                return;\n            }\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public synchronized Map<TriggerDescriptor,Trigger> getTriggers() {\n        return (Map)Descriptor.toMap(triggers());\n    }\n\n    /**\n     * Gets the specific trigger, or null if the propert is not configured for this job.\n     */\n    public <T extends Trigger> T getTrigger(Class<T> clazz) {\n        for (Trigger p : triggers()) {\n            if(clazz.isInstance(p))\n                return clazz.cast(p);\n        }\n        return null;\n    }\n\n//\n//\n// fingerprint related\n//\n//\n    /**\n     * True if the builds of this project produces {@link Fingerprint} records.\n     */\n    public abstract boolean isFingerprintConfigured();\n\n    /**\n     * Gets the other {@link AbstractProject}s that should be built\n     * when a build of this project is completed.\n     */\n    @Exported\n    public final List<AbstractProject> getDownstreamProjects() {\n        return Jenkins.getInstance().getDependencyGraph().getDownstream(this);\n    }\n\n    @Exported\n    public final List<AbstractProject> getUpstreamProjects() {\n        return Jenkins.getInstance().getDependencyGraph().getUpstream(this);\n    }\n\n    /**\n     * Returns only those upstream projects that defines {@link BuildTrigger} to this project.\n     * This is a subset of {@link #getUpstreamProjects()}\n     *\n     * @return A List of upstream projects that has a {@link BuildTrigger} to this project.\n     */\n    public final List<AbstractProject> getBuildTriggerUpstreamProjects() {\n        ArrayList<AbstractProject> result = new ArrayList<AbstractProject>();\n        for (AbstractProject<?,?> ap : getUpstreamProjects()) {\n            BuildTrigger buildTrigger = ap.getPublishersList().get(BuildTrigger.class);\n            if (buildTrigger != null)\n                if (buildTrigger.getChildProjects(ap).contains(this))\n                    result.add(ap);\n        }        \n        return result;\n    }    \n    \n    /**\n     * Gets all the upstream projects including transitive upstream projects.\n     *\n     * @since 1.138\n     */\n    public final Set<AbstractProject> getTransitiveUpstreamProjects() {\n        return Jenkins.getInstance().getDependencyGraph().getTransitiveUpstream(this);\n    }\n\n    /**\n     * Gets all the downstream projects including transitive downstream projects.\n     *\n     * @since 1.138\n     */\n    public final Set<AbstractProject> getTransitiveDownstreamProjects() {\n        return Jenkins.getInstance().getDependencyGraph().getTransitiveDownstream(this);\n    }\n\n    /**\n     * Gets the dependency relationship map between this project (as the source)\n     * and that project (as the sink.)\n     *\n     * @return\n     *      can be empty but not null. build number of this project to the build\n     *      numbers of that project.\n     */\n    public SortedMap<Integer, RangeSet> getRelationship(AbstractProject that) {\n        TreeMap<Integer,RangeSet> r = new TreeMap<Integer,RangeSet>(REVERSE_INTEGER_COMPARATOR);\n\n        checkAndRecord(that, r, this.getBuilds());\n        // checkAndRecord(that, r, that.getBuilds());\n\n        return r;\n    }\n\n    /**\n     * Helper method for getDownstreamRelationship.\n     *\n     * For each given build, find the build number range of the given project and put that into the map.\n     */\n    private void checkAndRecord(AbstractProject that, TreeMap<Integer, RangeSet> r, Collection<R> builds) {\n        for (R build : builds) {\n            RangeSet rs = build.getDownstreamRelationship(that);\n            if(rs==null || rs.isEmpty())\n                continue;\n\n            int n = build.getNumber();\n\n            RangeSet value = r.get(n);\n            if(value==null)\n                r.put(n,rs);\n            else\n                value.add(rs);\n        }\n    }\n\n    /**\n     * Builds the dependency graph.\n     * @see DependencyGraph\n     */\n    protected abstract void buildDependencyGraph(DependencyGraph graph);\n\n    @Override\n    protected SearchIndexBuilder makeSearchIndex() {\n        SearchIndexBuilder sib = super.makeSearchIndex();\n        if(isBuildable() && hasPermission(Jenkins.ADMINISTER))\n            sib.add(\"build\",\"build\");\n        return sib;\n    }\n\n    @Override\n    protected HistoryWidget createHistoryWidget() {\n        return new BuildHistoryWidget<R>(this,builds,HISTORY_ADAPTER);\n    }\n    \n    public boolean isParameterized() {\n        return getProperty(ParametersDefinitionProperty.class) != null;\n    }\n\n//\n//\n// actions\n//\n//\n    /**\n     * Schedules a new build command.\n     */\n    public void doBuild( StaplerRequest req, StaplerResponse rsp, @QueryParameter TimeDuration delay ) throws IOException, ServletException {\n        if (delay==null)    delay=new TimeDuration(getQuietPeriod());\n\n        // if a build is parameterized, let that take over\n        ParametersDefinitionProperty pp = getProperty(ParametersDefinitionProperty.class);\n        if (pp != null && !req.getMethod().equals(\"POST\")) {\n            // show the parameter entry form.\n            req.getView(pp, \"index.jelly\").forward(req, rsp);\n            return;\n        }\n\n        BuildAuthorizationToken.checkPermission(this, authToken, req, rsp);\n\n        if (pp != null) {\n            pp._doBuild(req,rsp,delay);\n            return;\n        }\n\n        if (!isBuildable())\n            throw HttpResponses.error(SC_INTERNAL_SERVER_ERROR,new IOException(getFullName()+\" is not buildable\"));\n\n        Jenkins.getInstance().getQueue().schedule(this, (int)delay.getTime(), getBuildCause(req));\n        rsp.sendRedirect(\".\");\n    }\n\n    /**\n     * Computes the build cause, using RemoteCause or UserCause as appropriate.\n     */\n    /*package*/ CauseAction getBuildCause(StaplerRequest req) {\n        Cause cause;\n        if (authToken != null && authToken.getToken() != null && req.getParameter(\"token\") != null) {\n            // Optional additional cause text when starting via token\n            String causeText = req.getParameter(\"cause\");\n            cause = new RemoteCause(req.getRemoteAddr(), causeText);\n        } else {\n            cause = new UserIdCause();\n        }\n        return new CauseAction(cause);\n    }\n\n    /**\n     * Computes the delay by taking the default value and the override in the request parameter into the account.\n     *\n     * @deprecated as of 1.488\n     *      Inject {@link TimeDuration}.\n     */\n    public int getDelay(StaplerRequest req) throws ServletException {\n        String delay = req.getParameter(\"delay\");\n        if (delay==null)    return getQuietPeriod();\n\n        try {\n            // TODO: more unit handling\n            if(delay.endsWith(\"sec\"))   delay=delay.substring(0,delay.length()-3);\n            if(delay.endsWith(\"secs\"))  delay=delay.substring(0,delay.length()-4);\n            return Integer.parseInt(delay);\n        } catch (NumberFormatException e) {\n            throw new ServletException(\"Invalid delay parameter value: \"+delay);\n        }\n    }\n\n    /**\n     * Supports build trigger with parameters via an HTTP GET or POST.\n     * Currently only String parameters are supported.\n     */\n    public void doBuildWithParameters(StaplerRequest req, StaplerResponse rsp, @QueryParameter TimeDuration delay) throws IOException, ServletException {\n        BuildAuthorizationToken.checkPermission(this, authToken, req, rsp);\n\n        ParametersDefinitionProperty pp = getProperty(ParametersDefinitionProperty.class);\n        if (pp != null) {\n            pp.buildWithParameters(req,rsp,delay);\n        } else {\n        \tthrow new IllegalStateException(\"This build is not parameterized!\");\n        }\n    \t\n    }\n\n    /**\n     * Schedules a new SCM polling command.\n     */\n    public void doPolling( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {\n        BuildAuthorizationToken.checkPermission(this, authToken, req, rsp);\n        schedulePolling();\n        rsp.sendRedirect(\".\");\n    }\n\n    /**\n     * Cancels a scheduled build.\n     */\n    @RequirePOST\n    public void doCancelQueue( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {\n        checkPermission(ABORT);\n\n        Jenkins.getInstance().getQueue().cancel(this);\n        rsp.forwardToPreviousPage(req);\n    }\n\n    /**\n     * Deletes this project.\n     */\n    @Override\n    @RequirePOST\n    public void doDoDelete(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException, InterruptedException {\n        delete();\n        if (req == null || rsp == null)\n            return;\n        View view = req.findAncestorObject(View.class);\n        if (view == null)\n            rsp.sendRedirect2(req.getContextPath() + '/' + getParent().getUrl());\n        else \n            rsp.sendRedirect2(req.getContextPath() + '/' + view.getUrl());\n    }\n    \n    @Override\n    protected void submit(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException, FormException {\n        super.submit(req,rsp);\n        JSONObject json = req.getSubmittedForm();\n\n        makeDisabled(req.getParameter(\"disable\")!=null);\n\n        jdk = req.getParameter(\"jdk\");\n        if(req.getParameter(\"hasCustomQuietPeriod\")!=null) {\n            quietPeriod = Integer.parseInt(req.getParameter(\"quiet_period\"));\n        } else {\n            quietPeriod = null;\n        }\n        if(req.getParameter(\"hasCustomScmCheckoutRetryCount\")!=null) {\n            scmCheckoutRetryCount = Integer.parseInt(req.getParameter(\"scmCheckoutRetryCount\"));\n        } else {\n            scmCheckoutRetryCount = null;\n        }\n        blockBuildWhenDownstreamBuilding = req.getParameter(\"blockBuildWhenDownstreamBuilding\")!=null;\n        blockBuildWhenUpstreamBuilding = req.getParameter(\"blockBuildWhenUpstreamBuilding\")!=null;\n\n        if(req.hasParameter(\"customWorkspace\")) {\n            customWorkspace = Util.fixEmptyAndTrim(req.getParameter(\"customWorkspace.directory\"));\n        } else {\n            customWorkspace = null;\n        }\n\n        if (json.has(\"scmCheckoutStrategy\"))\n            scmCheckoutStrategy = req.bindJSON(SCMCheckoutStrategy.class,\n                json.getJSONObject(\"scmCheckoutStrategy\"));\n        else\n            scmCheckoutStrategy = null;\n\n        \n        if(req.getParameter(\"hasSlaveAffinity\")!=null) {\n            assignedNode = Util.fixEmptyAndTrim(req.getParameter(\"_.assignedLabelString\"));\n        } else {\n            assignedNode = null;\n        }\n        canRoam = assignedNode==null;\n\n        concurrentBuild = req.getSubmittedForm().has(\"concurrentBuild\");\n\n        authToken = BuildAuthorizationToken.create(req);\n\n        setScm(SCMS.parseSCM(req,this));\n\n        for (Trigger t : triggers())\n            t.stop();\n        triggers = buildDescribable(req, Trigger.for_(this));\n        for (Trigger t : triggers)\n            t.start(this,true);\n    }\n\n    /**\n     * @deprecated\n     *      As of 1.261. Use {@link #buildDescribable(StaplerRequest, List)} instead.\n     */\n    protected final <T extends Describable<T>> List<T> buildDescribable(StaplerRequest req, List<? extends Descriptor<T>> descriptors, String prefix) throws FormException, ServletException {\n        return buildDescribable(req,descriptors);\n    }\n\n    protected final <T extends Describable<T>> List<T> buildDescribable(StaplerRequest req, List<? extends Descriptor<T>> descriptors)\n        throws FormException, ServletException {\n\n        JSONObject data = req.getSubmittedForm();\n        List<T> r = new Vector<T>();\n        for (Descriptor<T> d : descriptors) {\n            String safeName = d.getJsonSafeClassName();\n            if (req.getParameter(safeName) != null) {\n                T instance = d.newInstance(req, data.getJSONObject(safeName));\n                r.add(instance);\n            }\n        }\n        return r;\n    }\n\n    /**\n     * Serves the workspace files.\n     */\n    public DirectoryBrowserSupport doWs( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException, InterruptedException {\n        checkPermission(AbstractProject.WORKSPACE);\n        FilePath ws = getSomeWorkspace();\n        if ((ws == null) || (!ws.exists())) {\n            // if there's no workspace, report a nice error message\n            // Would be good if when asked for *plain*, do something else!\n            // (E.g. return 404, or send empty doc.)\n            // Not critical; client can just check if content type is not text/plain,\n            // which also serves to detect old versions of Hudson.\n            req.getView(this,\"noWorkspace.jelly\").forward(req,rsp);\n            return null;\n        } else {\n            return new DirectoryBrowserSupport(this, ws, getDisplayName()+\" workspace\", \"folder.png\", true);\n        }\n    }\n\n    /**\n     * Wipes out the workspace.\n     */\n    public HttpResponse doDoWipeOutWorkspace() throws IOException, ServletException, InterruptedException {\n        checkPermission(Functions.isWipeOutPermissionEnabled() ? WIPEOUT : BUILD);\n        R b = getSomeBuildWithWorkspace();\n        FilePath ws = b!=null ? b.getWorkspace() : null;\n        if (ws!=null && getScm().processWorkspaceBeforeDeletion(this, ws, b.getBuiltOn())) {\n            ws.deleteRecursive();\n            for (WorkspaceListener wl : WorkspaceListener.all()) {\n                wl.afterDelete(this);\n            }\n            return new HttpRedirect(\".\");\n        } else {\n            // If we get here, that means the SCM blocked the workspace deletion.\n            return new ForwardToView(this,\"wipeOutWorkspaceBlocked.jelly\");\n        }\n    }\n\n    @CLIMethod(name=\"disable-job\")\n    @RequirePOST\n    public HttpResponse doDisable() throws IOException, ServletException {\n        checkPermission(CONFIGURE);\n        makeDisabled(true);\n        return new HttpRedirect(\".\");\n    }\n\n    @CLIMethod(name=\"enable-job\")\n    @RequirePOST\n    public HttpResponse doEnable() throws IOException, ServletException {\n        checkPermission(CONFIGURE);\n        makeDisabled(false);\n        return new HttpRedirect(\".\");\n    }\n\n    /**\n     * RSS feed for changes in this project.\n     */\n    public void doRssChangelog(  StaplerRequest req, StaplerResponse rsp  ) throws IOException, ServletException {\n        class FeedItem {\n            ChangeLogSet.Entry e;\n            int idx;\n\n            public FeedItem(Entry e, int idx) {\n                this.e = e;\n                this.idx = idx;\n            }\n\n            AbstractBuild<?,?> getBuild() {\n                return e.getParent().build;\n            }\n        }\n\n        List<FeedItem> entries = new ArrayList<FeedItem>();\n\n        for(R r=getLastBuild(); r!=null; r=r.getPreviousBuild()) {\n            int idx=0;\n            for( ChangeLogSet.Entry e : r.getChangeSet())\n                entries.add(new FeedItem(e,idx++));\n        }\n\n        RSS.forwardToRss(\n            getDisplayName()+' '+getScm().getDescriptor().getDisplayName()+\" changes\",\n            getUrl()+\"changes\",\n            entries, new FeedAdapter<FeedItem>() {\n                public String getEntryTitle(FeedItem item) {\n                    return \"#\"+item.getBuild().number+' '+item.e.getMsg()+\" (\"+item.e.getAuthor()+\")\";\n                }\n\n                public String getEntryUrl(FeedItem item) {\n                    return item.getBuild().getUrl()+\"changes#detail\"+item.idx;\n                }\n\n                public String getEntryID(FeedItem item) {\n                    return getEntryUrl(item);\n                }\n\n                public String getEntryDescription(FeedItem item) {\n                    StringBuilder buf = new StringBuilder();\n                    for(String path : item.e.getAffectedPaths())\n                        buf.append(path).append('\\n');\n                    return buf.toString();\n                }\n\n                public Calendar getEntryTimestamp(FeedItem item) {\n                    return item.getBuild().getTimestamp();\n                }\n\n                public String getEntryAuthor(FeedItem entry) {\n                    return JenkinsLocationConfiguration.get().getAdminAddress();\n                }\n            },\n            req, rsp );\n    }\n\n    /**\n     * {@link AbstractProject} subtypes should implement this base class as a descriptor.\n     *\n     * @since 1.294\n     */\n    public static abstract class AbstractProjectDescriptor extends TopLevelItemDescriptor {\n        /**\n         * {@link AbstractProject} subtypes can override this method to veto some {@link Descriptor}s\n         * from showing up on their configuration screen. This is often useful when you are building\n         * a workflow/company specific project type, where you want to limit the number of choices\n         * given to the users.\n         *\n         * <p>\n         * Some {@link Descriptor}s define their own schemes for controlling applicability\n         * (such as {@link BuildStepDescriptor#isApplicable(Class)}),\n         * This method works like AND in conjunction with them;\n         * Both this method and that method need to return true in order for a given {@link Descriptor}\n         * to show up for the given {@link Project}.\n         *\n         * <p>\n         * The default implementation returns true for everything.\n         *\n         * @see BuildStepDescriptor#isApplicable(Class) \n         * @see BuildWrapperDescriptor#isApplicable(AbstractProject) \n         * @see TriggerDescriptor#isApplicable(Item)\n         */\n        @Override\n        public boolean isApplicable(Descriptor descriptor) {\n            return true;\n        }\n\n        public FormValidation doCheckAssignedLabelString(@QueryParameter String value) {\n            if (Util.fixEmpty(value)==null)\n                return FormValidation.ok(); // nothing typed yet\n            try {\n                Label.parseExpression(value);\n            } catch (ANTLRException e) {\n                return FormValidation.error(e,\n                        Messages.AbstractProject_AssignedLabelString_InvalidBooleanExpression(e.getMessage()));\n            }\n            Label l = Jenkins.getInstance().getLabel(value);\n            if (l.isEmpty()) {\n                for (LabelAtom a : l.listAtoms()) {\n                    if (a.isEmpty()) {\n                        LabelAtom nearest = LabelAtom.findNearest(a.getName());\n                        return FormValidation.warning(Messages.AbstractProject_AssignedLabelString_NoMatch_DidYouMean(a.getName(),nearest.getDisplayName()));\n                    }\n                }\n                return FormValidation.warning(Messages.AbstractProject_AssignedLabelString_NoMatch());\n            }\n            return FormValidation.ok();\n        }\n\n        public FormValidation doCheckCustomWorkspace(@QueryParameter(value=\"customWorkspace.directory\") String customWorkspace){\n        \tif(Util.fixEmptyAndTrim(customWorkspace)==null)\n        \t\treturn FormValidation.error(Messages.AbstractProject_CustomWorkspaceEmpty());\n        \telse\n        \t\treturn FormValidation.ok();\n        }\n        \n        public AutoCompletionCandidates doAutoCompleteUpstreamProjects(@QueryParameter String value) {\n            AutoCompletionCandidates candidates = new AutoCompletionCandidates();\n            List<Job> jobs = Jenkins.getInstance().getItems(Job.class);\n            for (Job job: jobs) {\n                if (job.getFullName().startsWith(value)) {\n                    if (job.hasPermission(Item.READ)) {\n                        candidates.add(job.getFullName());\n                    }\n                }\n            }\n            return candidates;\n        }\n\n        public AutoCompletionCandidates doAutoCompleteAssignedLabelString(@QueryParameter String value) {\n            AutoCompletionCandidates c = new AutoCompletionCandidates();\n            Set<Label> labels = Jenkins.getInstance().getLabels();\n            List<String> queries = new AutoCompleteSeeder(value).getSeeds();\n\n            for (String term : queries) {\n                for (Label l : labels) {\n                    if (l.getName().startsWith(term)) {\n                        c.add(l.getName());\n                    }\n                }\n            }\n            return c;\n        }\n\n        public List<SCMCheckoutStrategyDescriptor> getApplicableSCMCheckoutStrategyDescriptors(AbstractProject p) {\n            return SCMCheckoutStrategyDescriptor._for(p);\n        }\n\n        /**\n        * Utility class for taking the current input value and computing a list\n        * of potential terms to match against the list of defined labels.\n         */\n        static class AutoCompleteSeeder {\n            private String source;\n\n            AutoCompleteSeeder(String source) {\n                this.source = source;\n            }\n\n            List<String> getSeeds() {\n                ArrayList<String> terms = new ArrayList<String>();\n                boolean trailingQuote = source.endsWith(\"\\\"\");\n                boolean leadingQuote = source.startsWith(\"\\\"\");\n                boolean trailingSpace = source.endsWith(\" \");\n\n                if (trailingQuote || (trailingSpace && !leadingQuote)) {\n                    terms.add(\"\");\n                } else {\n                    if (leadingQuote) {\n                        int quote = source.lastIndexOf('\"');\n                        if (quote == 0) {\n                            terms.add(source.substring(1));\n                        } else {\n                            terms.add(\"\");\n                        }\n                    } else {\n                        int space = source.lastIndexOf(' ');\n                        if (space > -1) {\n                            terms.add(source.substring(space+1));\n                        } else {\n                            terms.add(source);\n                        }\n                    }\n                }\n\n                return terms;\n            }\n        }\n    }\n\n    /**\n     * Finds a {@link AbstractProject} that has the name closest to the given name.\n     */\n    public static AbstractProject findNearest(String name) {\n        return findNearest(name,Hudson.getInstance());\n    }\n\n    /**\n     * Finds a {@link AbstractProject} whose name (when referenced from the specified context) is closest to the given name.\n     *\n     * @since 1.419\n     */\n    public static AbstractProject findNearest(String name, ItemGroup context) {\n        List<AbstractProject> projects = Hudson.getInstance().getAllItems(AbstractProject.class);\n        String[] names = new String[projects.size()];\n        for( int i=0; i<projects.size(); i++ )\n            names[i] = projects.get(i).getRelativeNameFrom(context);\n\n        String nearest = EditDistance.findNearest(name, names);\n        return (AbstractProject)Jenkins.getInstance().getItem(nearest,context);\n    }\n\n    private static final Comparator<Integer> REVERSE_INTEGER_COMPARATOR = new Comparator<Integer>() {\n        public int compare(Integer o1, Integer o2) {\n            return o2-o1;\n        }\n    };\n\n    private static final Logger LOGGER = Logger.getLogger(AbstractProject.class.getName());\n\n    /**\n     * Permission to abort a build\n     */\n    public static final Permission ABORT = CANCEL;\n\n    /**\n     * Replaceable \"Build Now\" text.\n     */\n    public static final Message<AbstractProject> BUILD_NOW_TEXT = new Message<AbstractProject>();\n\n    /**\n     * Used for CLI binding.\n     */\n    @CLIResolver\n    public static AbstractProject resolveForCLI(\n            @Argument(required=true,metaVar=\"NAME\",usage=\"Job name\") String name) throws CmdLineException {\n        AbstractProject item = Jenkins.getInstance().getItemByFullName(name, AbstractProject.class);\n        if (item==null)\n            throw new CmdLineException(null,Messages.AbstractItem_NoSuchJobExists(name,AbstractProject.findNearest(name).getFullName()));\n        return item;\n    }\n\n    public String getCustomWorkspace() {\n        return customWorkspace;\n    }\n\n    /**\n     * User-specified workspace directory, or null if it's up to Jenkins.\n     *\n     * <p>\n     * Normally a project uses the workspace location assigned by its parent container,\n     * but sometimes people have builds that have hard-coded paths.\n     *\n     * <p>\n     * This is not {@link File} because it may have to hold a path representation on another OS.\n     *\n     * <p>\n     * If this path is relative, it's resolved against {@link Node#getRootPath()} on the node where this workspace\n     * is prepared. \n     *\n     * @since 1.410\n     */\n    public void setCustomWorkspace(String customWorkspace) throws IOException {\n        this.customWorkspace= Util.fixEmptyAndTrim(customWorkspace);\n        save();\n    }\n    \n}\n", "/*\n * The MIT License\n * \n * Copyright (c) 2004-2011, Sun Microsystems, Inc., Kohsuke Kawaguchi\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage hudson.model;\n\nimport hudson.DescriptorExtensionList;\nimport hudson.PluginWrapper;\nimport hudson.RelativePath;\nimport hudson.XmlFile;\nimport hudson.BulkChange;\nimport hudson.Util;\nimport hudson.model.listeners.SaveableListener;\nimport hudson.util.FormApply;\nimport hudson.util.ReflectionUtils;\nimport hudson.util.ReflectionUtils.Parameter;\nimport hudson.views.ListViewColumn;\nimport jenkins.model.Jenkins;\nimport net.sf.json.JSONArray;\nimport net.sf.json.JSONObject;\nimport org.kohsuke.stapler.*;\nimport org.kohsuke.stapler.jelly.JellyCompatibleFacet;\nimport org.kohsuke.stapler.lang.Klass;\nimport org.springframework.util.StringUtils;\nimport org.jvnet.tiger_types.Types;\nimport org.apache.commons.io.IOUtils;\n\nimport static hudson.Functions.*;\nimport static hudson.util.QuotedStringTokenizer.*;\nimport static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\nimport javax.servlet.ServletException;\nimport javax.servlet.RequestDispatcher;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.HashMap;\nimport java.util.Locale;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.ParameterizedType;\nimport java.beans.Introspector;\nimport javax.annotation.CheckForNull;\nimport javax.annotation.Nonnull;\n\n/**\n * Metadata about a configurable instance.\n *\n * <p>\n * {@link Descriptor} is an object that has metadata about a {@link Describable}\n * object, and also serves as a factory (in a way this relationship is similar\n * to {@link Object}/{@link Class} relationship.\n *\n * A {@link Descriptor}/{@link Describable}\n * combination is used throughout in Hudson to implement a\n * configuration/extensibility mechanism.\n *\n * <p>\n * Take the list view support as an example, which is implemented\n * in {@link ListView} class. Whenever a new view is created, a new\n * {@link ListView} instance is created with the configuration\n * information. This instance gets serialized to XML, and this instance\n * will be called to render the view page. This is the job\n * of {@link Describable} &mdash; each instance represents a specific\n * configuration of a view (what projects are in it, regular expression, etc.)\n *\n * <p>\n * For Hudson to create such configured {@link ListView} instance, Hudson\n * needs another object that captures the metadata of {@link ListView},\n * and that is what a {@link Descriptor} is for. {@link ListView} class\n * has a singleton descriptor, and this descriptor helps render\n * the configuration form, remember system-wide configuration, and works as a factory.\n *\n * <p>\n * {@link Descriptor} also usually have its associated views.\n *\n *\n * <h2>Persistence</h2>\n * <p>\n * {@link Descriptor} can persist data just by storing them in fields.\n * However, it is the responsibility of the derived type to properly\n * invoke {@link #save()} and {@link #load()}.\n *\n * <h2>Reflection Enhancement</h2>\n * {@link Descriptor} defines addition to the standard Java reflection\n * and provides reflective information about its corresponding {@link Describable}.\n * These are primarily used by tag libraries to\n * keep the Jelly scripts concise. \n *\n * @author Kohsuke Kawaguchi\n * @see Describable\n */\npublic abstract class Descriptor<T extends Describable<T>> implements Saveable {\n    /**\n     * The class being described by this descriptor.\n     */\n    public transient final Class<? extends T> clazz;\n\n    private transient final Map<String,String> checkMethods = new ConcurrentHashMap<String,String>();\n\n    /**\n     * Lazily computed list of properties on {@link #clazz} and on the descriptor itself.\n     */\n    private transient volatile Map<String, PropertyType> propertyTypes,globalPropertyTypes;\n\n    /**\n     * Represents a readable property on {@link Describable}.\n     */\n    public static final class PropertyType {\n        public final Class clazz;\n        public final Type type;\n        private volatile Class itemType;\n        public final String displayName;\n\n        PropertyType(Class clazz, Type type, String displayName) {\n            this.clazz = clazz;\n            this.type = type;\n            this.displayName = displayName;\n        }\n\n        PropertyType(Field f) {\n            this(f.getType(),f.getGenericType(),f.toString());\n        }\n\n        PropertyType(Method getter) {\n            this(getter.getReturnType(),getter.getGenericReturnType(),getter.toString());\n        }\n\n        public Enum[] getEnumConstants() {\n            return (Enum[])clazz.getEnumConstants();\n        }\n\n        /**\n         * If the property is a collection/array type, what is an item type?\n         */\n        public Class getItemType() {\n            if(itemType==null)\n                itemType = computeItemType();\n            return itemType;\n        }\n\n        private Class computeItemType() {\n            if(clazz.isArray()) {\n                return clazz.getComponentType();\n            }\n            if(Collection.class.isAssignableFrom(clazz)) {\n                Type col = Types.getBaseClass(type, Collection.class);\n\n                if (col instanceof ParameterizedType)\n                    return Types.erasure(Types.getTypeArgument(col,0));\n                else\n                    return Object.class;\n            }\n            return null;\n        }\n\n        /**\n         * Returns {@link Descriptor} whose 'clazz' is the same as {@link #getItemType() the item type}.\n         */\n        public Descriptor getItemTypeDescriptor() {\n            return Jenkins.getInstance().getDescriptor(getItemType());\n        }\n\n        public Descriptor getItemTypeDescriptorOrDie() {\n            Class it = getItemType();\n            if (it == null) {\n                throw new AssertionError(clazz + \" is not an array/collection type in \" + displayName + \". See https://wiki.jenkins-ci.org/display/JENKINS/My+class+is+missing+descriptor\");\n            }\n            Descriptor d = Jenkins.getInstance().getDescriptor(it);\n            if (d==null)\n                throw new AssertionError(it +\" is missing its descriptor in \"+displayName+\". See https://wiki.jenkins-ci.org/display/JENKINS/My+class+is+missing+descriptor\");\n            return d;\n        }\n\n        /**\n         * Returns all the descriptors that produce types assignable to the property type.\n         */\n        public List<? extends Descriptor> getApplicableDescriptors() {\n            return Jenkins.getInstance().getDescriptorList(clazz);\n        }\n\n        /**\n         * Returns all the descriptors that produce types assignable to the item type for a collection property.\n         */\n        public List<? extends Descriptor> getApplicableItemDescriptors() {\n            return Jenkins.getInstance().getDescriptorList(getItemType());\n        }\n    }\n\n    /**\n     * Help file redirect, keyed by the field name to the path.\n     *\n     * @see #getHelpFile(String) \n     */\n    private transient final Map<String,String> helpRedirect = new HashMap<String, String>();\n\n    /**\n     *\n     * @param clazz\n     *      Pass in {@link #self()} to have the descriptor describe itself,\n     *      (this hack is needed since derived types can't call \"getClass()\" to refer to itself.\n     */\n    protected Descriptor(Class<? extends T> clazz) {\n        if (clazz==self())\n            clazz = (Class)getClass();\n        this.clazz = clazz;\n        // doing this turns out to be very error prone,\n        // as field initializers in derived types will override values.\n        // load();\n    }\n\n    /**\n     * Infers the type of the corresponding {@link Describable} from the outer class.\n     * This version works when you follow the common convention, where a descriptor\n     * is written as the static nested class of the describable class.\n     * \n     * @since 1.278\n     */\n    protected Descriptor() {\n        this.clazz = (Class<T>)getClass().getEnclosingClass();\n        if(clazz==null)\n            throw new AssertionError(getClass()+\" doesn't have an outer class. Use the constructor that takes the Class object explicitly.\");\n\n        // detect an type error\n        Type bt = Types.getBaseClass(getClass(), Descriptor.class);\n        if (bt instanceof ParameterizedType) {\n            ParameterizedType pt = (ParameterizedType) bt;\n            // this 't' is the closest approximation of T of Descriptor<T>.\n            Class t = Types.erasure(pt.getActualTypeArguments()[0]);\n            if(!t.isAssignableFrom(clazz))\n                throw new AssertionError(\"Outer class \"+clazz+\" of \"+getClass()+\" is not assignable to \"+t+\". Perhaps wrong outer class?\");\n        }\n\n        // detect a type error. this Descriptor is supposed to be returned from getDescriptor(), so make sure its type match up.\n        // this prevents a bug like http://www.nabble.com/Creating-a-new-parameter-Type-%3A-Masked-Parameter-td24786554.html\n        try {\n            Method getd = clazz.getMethod(\"getDescriptor\");\n            if(!getd.getReturnType().isAssignableFrom(getClass())) {\n                throw new AssertionError(getClass()+\" must be assignable to \"+getd.getReturnType());\n            }\n        } catch (NoSuchMethodException e) {\n            throw new AssertionError(getClass()+\" is missing getDescriptor method.\");\n        }\n\n    }\n\n    /**\n     * Human readable name of this kind of configurable object.\n     */\n    public abstract String getDisplayName();\n\n    /**\n     * Uniquely identifies this {@link Descriptor} among all the other {@link Descriptor}s.\n     *\n     * <p>\n     * Historically {@link #clazz} is assumed to be unique, so this method uses that as the default,\n     * but if you are adding {@link Descriptor}s programmatically for the same type, you can change\n     * this to disambiguate them.\n     *\n     * <p>\n     * To look up {@link Descriptor} from ID, use {@link Jenkins#getDescriptor(String)}.\n     *\n     * @return\n     *      Stick to valid Java identifier character, plus '.', which had to be allowed for historical reasons.\n     * \n     * @since 1.391\n     */\n    public String getId() {\n        return clazz.getName();\n    }\n\n    /**\n     * Unlike {@link #clazz}, return the parameter type 'T', which determines\n     * the {@link DescriptorExtensionList} that this goes to.\n     *\n     * <p>\n     * In those situations where subtypes cannot provide the type parameter,\n     * this method can be overridden to provide it.\n     */\n    public Class<T> getT() {\n        Type subTyping = Types.getBaseClass(getClass(), Descriptor.class);\n        if (!(subTyping instanceof ParameterizedType)) {\n            throw new IllegalStateException(getClass()+\" doesn't extend Descriptor with a type parameter.\");\n        }\n        return Types.erasure(Types.getTypeArgument(subTyping, 0));\n    }\n\n    /**\n     * Gets the URL that this Descriptor is bound to, relative to the nearest {@link DescriptorByNameOwner}.\n     * Since {@link Jenkins} is a {@link DescriptorByNameOwner}, there's always one such ancestor to any request.\n     */\n    public String getDescriptorUrl() {\n        return \"descriptorByName/\"+getId();\n    }\n\n    /**\n     * Gets the URL that this Descriptor is bound to, relative to the context path.\n     * @since 1.406\n     */\n    public final String getDescriptorFullUrl() {\n        return getCurrentDescriptorByNameUrl()+'/'+getDescriptorUrl();\n    }\n\n    /**\n     * @since 1.402\n     */\n    public static String getCurrentDescriptorByNameUrl() {\n        StaplerRequest req = Stapler.getCurrentRequest();\n\n        // this override allows RenderOnDemandClosure to preserve the proper value\n        Object url = req.getAttribute(\"currentDescriptorByNameUrl\");\n        if (url!=null)  return url.toString();\n\n        Ancestor a = req.findAncestor(DescriptorByNameOwner.class);\n        return a.getUrl();\n    }\n\n    /**\n     * If the field \"xyz\" of a {@link Describable} has the corresponding \"doCheckXyz\" method,\n     * return the form-field validation string. Otherwise null.\n     * <p>\n     * This method is used to hook up the form validation method to the corresponding HTML input element.\n     */\n    public String getCheckUrl(String fieldName) {\n        String method = checkMethods.get(fieldName);\n        if(method==null) {\n            method = calcCheckUrl(fieldName);\n            checkMethods.put(fieldName,method);\n        }\n\n        if (method.equals(NONE)) // == would do, but it makes IDE flag a warning\n            return null;\n\n        // put this under the right contextual umbrella.\n        // a is always non-null because we already have Hudson as the sentinel\n        return '\\'' + jsStringEscape(getCurrentDescriptorByNameUrl()) + \"/'+\" + method;\n    }\n\n    private String calcCheckUrl(String fieldName) {\n        String capitalizedFieldName = StringUtils.capitalize(fieldName);\n\n        Method method = ReflectionUtils.getPublicMethodNamed(getClass(),\"doCheck\"+ capitalizedFieldName);\n\n        if(method==null)\n            return NONE;\n\n        return '\\'' + getDescriptorUrl() + \"/check\" + capitalizedFieldName + '\\'' + buildParameterList(method, new StringBuilder()).append(\".toString()\");\n    }\n\n    /**\n     * Builds query parameter line by figuring out what should be submitted\n     */\n    private StringBuilder buildParameterList(Method method, StringBuilder query) {\n        for (Parameter p : ReflectionUtils.getParameters(method)) {\n            QueryParameter qp = p.annotation(QueryParameter.class);\n            if (qp!=null) {\n                String name = qp.value();\n                if (name.length()==0) name = p.name();\n                if (name==null || name.length()==0)\n                    continue;   // unknown parameter name. we'll report the error when the form is submitted.\n\n                RelativePath rp = p.annotation(RelativePath.class);\n                if (rp!=null)\n                    name = rp.value()+'/'+name;\n\n                if (query.length()==0)  query.append(\"+qs(this)\");\n\n                if (name.equals(\"value\")) {\n                    // The special 'value' parameter binds to the the current field\n                    query.append(\".addThis()\");\n                } else {\n                    query.append(\".nearBy('\"+name+\"')\");\n                }\n                continue;\n            }\n\n            Method m = ReflectionUtils.getPublicMethodNamed(p.type(), \"fromStapler\");\n            if (m!=null)    buildParameterList(m,query);\n        }\n        return query;\n    }\n\n    /**\n     * Computes the list of other form fields that the given field depends on, via the doFillXyzItems method,\n     * and sets that as the 'fillDependsOn' attribute. Also computes the URL of the doFillXyzItems and\n     * sets that as the 'fillUrl' attribute.\n     */\n    public void calcFillSettings(String field, Map<String,Object> attributes) {\n        String capitalizedFieldName = StringUtils.capitalize(field);\n        String methodName = \"doFill\" + capitalizedFieldName + \"Items\";\n        Method method = ReflectionUtils.getPublicMethodNamed(getClass(), methodName);\n        if(method==null)\n            throw new IllegalStateException(String.format(\"%s doesn't have the %s method for filling a drop-down list\", getClass(), methodName));\n\n        // build query parameter line by figuring out what should be submitted\n        List<String> depends = buildFillDependencies(method, new ArrayList<String>());\n\n        if (!depends.isEmpty())\n            attributes.put(\"fillDependsOn\",Util.join(depends,\" \"));\n        attributes.put(\"fillUrl\", String.format(\"%s/%s/fill%sItems\", getCurrentDescriptorByNameUrl(), getDescriptorUrl(), capitalizedFieldName));\n    }\n\n    private List<String> buildFillDependencies(Method method, List<String> depends) {\n        for (Parameter p : ReflectionUtils.getParameters(method)) {\n            QueryParameter qp = p.annotation(QueryParameter.class);\n            if (qp!=null) {\n                String name = qp.value();\n                if (name.length()==0) name = p.name();\n                if (name==null || name.length()==0)\n                    continue;   // unknown parameter name. we'll report the error when the form is submitted.\n\n                RelativePath rp = p.annotation(RelativePath.class);\n                if (rp!=null)\n                    name = rp.value()+'/'+name;\n\n                depends.add(name);\n                continue;\n            }\n\n            Method m = ReflectionUtils.getPublicMethodNamed(p.type(), \"fromStapler\");\n            if (m!=null)\n                buildFillDependencies(m,depends);\n        }\n        return depends;\n    }\n\n    /**\n     * Computes the auto-completion setting\n     */\n    public void calcAutoCompleteSettings(String field, Map<String,Object> attributes) {\n        String capitalizedFieldName = StringUtils.capitalize(field);\n        String methodName = \"doAutoComplete\" + capitalizedFieldName;\n        Method method = ReflectionUtils.getPublicMethodNamed(getClass(), methodName);\n        if(method==null)\n            return;    // no auto-completion\n\n        attributes.put(\"autoCompleteUrl\", String.format(\"%s/%s/autoComplete%s\", getCurrentDescriptorByNameUrl(), getDescriptorUrl(), capitalizedFieldName));\n    }\n\n    /**\n     * Used by Jelly to abstract away the handlign of global.jelly vs config.jelly databinding difference.\n     */\n    public @CheckForNull PropertyType getPropertyType(@Nonnull Object instance, @Nonnull String field) {\n        // in global.jelly, instance==descriptor\n        return instance==this ? getGlobalPropertyType(field) : getPropertyType(field);\n    }\n\n    /**\n     * Akin to {@link #getPropertyType(Object,String) but never returns null.\n     * @throws AssertionError in case the field cannot be found\n     * @since 1.492\n     */\n    public @Nonnull PropertyType getPropertyTypeOrDie(@Nonnull Object instance, @Nonnull String field) {\n        PropertyType propertyType = getPropertyType(instance, field);\n        if (propertyType != null) {\n            return propertyType;\n        } else if (instance == this) {\n            throw new AssertionError(getClass().getName() + \" has no property \" + field);\n        } else {\n            throw new AssertionError(clazz.getName() + \" has no property \" + field);\n        }\n    }\n\n    /**\n     * Obtains the property type of the given field of {@link #clazz}\n     */\n    public PropertyType getPropertyType(String field) {\n        if(propertyTypes==null)\n            propertyTypes = buildPropertyTypes(clazz);\n        return propertyTypes.get(field);\n    }\n\n    /**\n     * Obtains the property type of the given field of this descriptor.\n     */\n    public PropertyType getGlobalPropertyType(String field) {\n        if(globalPropertyTypes==null)\n            globalPropertyTypes = buildPropertyTypes(getClass());\n        return globalPropertyTypes.get(field);\n    }\n\n    /**\n     * Given the class, list up its {@link PropertyType}s from its public fields/getters.\n     */\n    private Map<String, PropertyType> buildPropertyTypes(Class<?> clazz) {\n        Map<String, PropertyType> r = new HashMap<String, PropertyType>();\n        for (Field f : clazz.getFields())\n            r.put(f.getName(),new PropertyType(f));\n\n        for (Method m : clazz.getMethods())\n            if(m.getName().startsWith(\"get\"))\n                r.put(Introspector.decapitalize(m.getName().substring(3)),new PropertyType(m));\n\n        return r;\n    }\n\n    /**\n     * Gets the class name nicely escaped to be usable as a key in the structured form submission.\n     */\n    public final String getJsonSafeClassName() {\n        return getId().replace('.','-');\n    }\n\n    /**\n     * @deprecated\n     *      Implement {@link #newInstance(StaplerRequest, JSONObject)} method instead.\n     *      Deprecated as of 1.145. \n     */\n    public T newInstance(StaplerRequest req) throws FormException {\n        throw new UnsupportedOperationException(getClass()+\" should implement newInstance(StaplerRequest,JSONObject)\");\n    }\n\n    /**\n     * Creates a configured instance from the submitted form.\n     *\n     * <p>\n     * Hudson only invokes this method when the user wants an instance of <tt>T</tt>.\n     * So there's no need to check that in the implementation.\n     *\n     * <p>\n     * Starting 1.206, the default implementation of this method does the following:\n     * <pre>\n     * req.bindJSON(clazz,formData);\n     * </pre>\n     * <p>\n     * ... which performs the databinding on the constructor of {@link #clazz}.\n     *\n     * <p>\n     * For some types of {@link Describable}, such as {@link ListViewColumn}, this method\n     * can be invoked with null request object for historical reason. Such design is considered\n     * broken, but due to the compatibility reasons we cannot fix it. Because of this, the\n     * default implementation gracefully handles null request, but the contract of the method\n     * still is \"request is always non-null.\" Extension points that need to define the \"default instance\"\n     * semantics should define a descriptor subtype and add the no-arg newInstance method.\n     *\n     * @param req\n     *      Always non-null (see note above.) This object includes represents the entire submission.\n     * @param formData\n     *      The JSON object that captures the configuration data for this {@link Descriptor}.\n     *      See http://wiki.jenkins-ci.org/display/JENKINS/Structured+Form+Submission\n     *      Always non-null.\n     *\n     * @throws FormException\n     *      Signals a problem in the submitted form.\n     * @since 1.145\n     */\n    public T newInstance(StaplerRequest req, JSONObject formData) throws FormException {\n        try {\n            Method m = getClass().getMethod(\"newInstance\", StaplerRequest.class);\n\n            if(!Modifier.isAbstract(m.getDeclaringClass().getModifiers())) {\n                // this class overrides newInstance(StaplerRequest).\n                // maintain the backward compatible behavior\n                return verifyNewInstance(newInstance(req));\n            } else {\n                if (req==null) {\n                    // yes, req is supposed to be always non-null, but see the note above\n                    return verifyNewInstance(clazz.newInstance());\n                }\n\n                // new behavior as of 1.206\n                return verifyNewInstance(req.bindJSON(clazz,formData));\n            }\n        } catch (NoSuchMethodException e) {\n            throw new AssertionError(e); // impossible\n        } catch (InstantiationException e) {\n            throw new Error(\"Failed to instantiate \"+clazz+\" from \"+formData,e);\n        } catch (IllegalAccessException e) {\n            throw new Error(\"Failed to instantiate \"+clazz+\" from \"+formData,e);\n        } catch (RuntimeException e) {\n            throw new RuntimeException(\"Failed to instantiate \"+clazz+\" from \"+formData,e);\n        }\n    }\n\n    /**\n     * Look out for a typical error a plugin developer makes.\n     * See http://hudson.361315.n4.nabble.com/Help-Hint-needed-Post-build-action-doesn-t-stay-activated-td2308833.html\n     */\n    private T verifyNewInstance(T t) {\n        if (t!=null && t.getDescriptor()!=this) {\n            // TODO: should this be a fatal error?\n            LOGGER.warning(\"Father of \"+ t+\" and its getDescriptor() points to two different instances. Probably malplaced @Extension. See http://hudson.361315.n4.nabble.com/Help-Hint-needed-Post-build-action-doesn-t-stay-activated-td2308833.html\");\n        }\n        return t;\n    }\n\n    /**\n     * Returns the {@link Klass} object used for the purpose of loading resources from this descriptor.\n     *\n     * This hook enables other JVM languages to provide more integrated lookup.\n     */\n    public Klass<?> getKlass() {\n        return Klass.java(clazz);\n    }\n\n    /**\n     * Returns the resource path to the help screen HTML, if any.\n     *\n     * <p>\n     * Starting 1.282, this method uses \"convention over configuration\" &mdash; you should\n     * just put the \"help.html\" (and its localized versions, if any) in the same directory\n     * you put your Jelly view files, and this method will automatically does the right thing.\n     *\n     * <p>\n     * This value is relative to the context root of Hudson, so normally\n     * the values are something like <tt>\"/plugin/emma/help.html\"</tt> to\n     * refer to static resource files in a plugin, or <tt>\"/publisher/EmmaPublisher/abc\"</tt>\n     * to refer to Jelly script <tt>abc.jelly</tt> or a method <tt>EmmaPublisher.doAbc()</tt>.\n     *\n     * @return\n     *      null to indicate that there's no help.\n     */\n    public String getHelpFile() {\n        return getHelpFile(null);\n    }\n\n    /**\n     * Returns the path to the help screen HTML for the given field.\n     *\n     * <p>\n     * The help files are assumed to be at \"help/FIELDNAME.html\" with possible\n     * locale variations.\n     */\n    public String getHelpFile(final String fieldName) {\n        return getHelpFile(getKlass(),fieldName);\n    }\n\n    public String getHelpFile(Klass<?> clazz, String fieldName) {\n        String v = helpRedirect.get(fieldName);\n        if (v!=null)    return v;\n\n        for (Klass<?> c : clazz.getAncestors()) {\n            String page = \"/descriptor/\" + getId() + \"/help\";\n            String suffix;\n            if(fieldName==null) {\n                suffix=\"\";\n            } else {\n                page += '/'+fieldName;\n                suffix='-'+fieldName;\n            }\n\n            try {\n                if(Stapler.getCurrentRequest().getView(c,\"help\"+suffix)!=null)\n                    return page;\n            } catch (IOException e) {\n                throw new Error(e);\n            }\n\n            if(getStaticHelpUrl(c, suffix) !=null)    return page;\n        }\n        return null;\n    }\n    \n    /**\n     * Tells Jenkins that the help file for the field 'fieldName' is defined in the help file for\n     * the 'fieldNameToRedirectTo' in the 'owner' class.\n     * @since 1.425\n     */\n    protected void addHelpFileRedirect(String fieldName, Class<? extends Describable> owner, String fieldNameToRedirectTo) {\n        helpRedirect.put(fieldName,\n            Jenkins.getInstance().getDescriptor(owner).getHelpFile(fieldNameToRedirectTo));\n    }\n\n    /**\n     * Checks if the given object is created from this {@link Descriptor}.\n     */\n    public final boolean isInstance( T instance ) {\n        return clazz.isInstance(instance);\n    }\n\n    /**\n     * Checks if the type represented by this descriptor is a subtype of the given type.\n     */\n    public final boolean isSubTypeOf(Class type) {\n        return type.isAssignableFrom(clazz);\n    }\n\n    /**\n     * @deprecated\n     *      As of 1.239, use {@link #configure(StaplerRequest, JSONObject)}.\n     */\n    public boolean configure( StaplerRequest req ) throws FormException {\n        return true;\n    }\n\n    /**\n     * Invoked when the global configuration page is submitted.\n     *\n     * Can be overriden to store descriptor-specific information.\n     *\n     * @param json\n     *      The JSON object that captures the configuration data for this {@link Descriptor}.\n     *      See http://wiki.jenkins-ci.org/display/JENKINS/Structured+Form+Submission\n     * @return false\n     *      to keep the client in the same config page.\n     */\n    public boolean configure( StaplerRequest req, JSONObject json ) throws FormException {\n        // compatibility\n        return configure(req);\n    }\n\n    public String getConfigPage() {\n        return getViewPage(clazz, getPossibleViewNames(\"config\"), \"config.jelly\");\n    }\n\n    public String getGlobalConfigPage() {\n        return getViewPage(clazz, getPossibleViewNames(\"global\"), null);\n    }\n    \n    private String getViewPage(Class<?> clazz, String pageName, String defaultValue) {\n        return getViewPage(clazz,Collections.singleton(pageName),defaultValue);\n    }\n\n    private String getViewPage(Class<?> clazz, Collection<String> pageNames, String defaultValue) {\n        while(clazz!=Object.class && clazz!=null) {\n            for (String pageName : pageNames) {\n                String name = clazz.getName().replace('.', '/').replace('$', '/') + \"/\" + pageName;\n                if(clazz.getClassLoader().getResource(name)!=null)\n                    return '/'+name;\n            }\n            clazz = clazz.getSuperclass();\n        }\n        return defaultValue;\n    }\n\n    protected final String getViewPage(Class<?> clazz, String pageName) {\n        // We didn't find the configuration page.\n        // Either this is non-fatal, in which case it doesn't matter what string we return so long as\n        // it doesn't exist.\n        // Or this error is fatal, in which case we want the developer to see what page he's missing.\n        // so we put the page name.\n        return getViewPage(clazz,pageName,pageName);\n    }\n\n    protected List<String> getPossibleViewNames(String baseName) {\n        List<String> names = new ArrayList<String>();\n        for (Facet f : WebApp.get(Jenkins.getInstance().servletContext).facets) {\n            if (f instanceof JellyCompatibleFacet) {\n                JellyCompatibleFacet jcf = (JellyCompatibleFacet) f;\n                for (String ext : jcf.getScriptExtensions())\n                    names.add(baseName +ext);\n            }\n        }\n        return names;\n    }\n\n\n    /**\n     * Saves the configuration info to the disk.\n     */\n    public synchronized void save() {\n        if(BulkChange.contains(this))   return;\n        try {\n            getConfigFile().write(this);\n            SaveableListener.fireOnChange(this, getConfigFile());\n        } catch (IOException e) {\n            LOGGER.log(Level.WARNING, \"Failed to save \"+getConfigFile(),e);\n        }\n    }\n\n    /**\n     * Loads the data from the disk into this object.\n     *\n     * <p>\n     * The constructor of the derived class must call this method.\n     * (If we do that in the base class, the derived class won't\n     * get a chance to set default values.)\n     */\n    public synchronized void load() {\n        XmlFile file = getConfigFile();\n        if(!file.exists())\n            return;\n\n        try {\n            file.unmarshal(this);\n        } catch (IOException e) {\n            LOGGER.log(Level.WARNING, \"Failed to load \"+file, e);\n        }\n    }\n\n    protected final XmlFile getConfigFile() {\n        return new XmlFile(new File(Jenkins.getInstance().getRootDir(),getId()+\".xml\"));\n    }\n\n    /**\n     * Returns the plugin in which this descriptor is defined.\n     *\n     * @return\n     *      null to indicate that this descriptor came from the core.\n     */\n    protected PluginWrapper getPlugin() {\n        return Jenkins.getInstance().getPluginManager().whichPlugin(clazz);\n    }\n\n    /**\n     * Serves <tt>help.html</tt> from the resource of {@link #clazz}.\n     */\n    public void doHelp(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n        String path = req.getRestOfPath();\n        if(path.contains(\"..\")) throw new ServletException(\"Illegal path: \"+path);\n\n        path = path.replace('/','-');\n\n        PluginWrapper pw = getPlugin();\n        if (pw!=null) {\n            rsp.setHeader(\"X-Plugin-Short-Name\",pw.getShortName());\n            rsp.setHeader(\"X-Plugin-Long-Name\",pw.getLongName());\n            rsp.setHeader(\"X-Plugin-From\", Messages.Descriptor_From(\n                    pw.getLongName().replace(\"Hudson\",\"Jenkins\").replace(\"hudson\",\"jenkins\"), pw.getUrl()));\n        }\n\n        for (Klass<?> c= getKlass(); c!=null; c=c.getSuperClass()) {\n            RequestDispatcher rd = Stapler.getCurrentRequest().getView(c, \"help\"+path);\n            if(rd!=null) {// template based help page\n                rd.forward(req,rsp);\n                return;\n            }\n\n            URL url = getStaticHelpUrl(c, path);\n            if(url!=null) {\n                // TODO: generalize macro expansion and perhaps even support JEXL\n                rsp.setContentType(\"text/html;charset=UTF-8\");\n                InputStream in = url.openStream();\n                try {\n                    String literal = IOUtils.toString(in,\"UTF-8\");\n                    rsp.getWriter().println(Util.replaceMacro(literal, Collections.singletonMap(\"rootURL\",req.getContextPath())));\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n                return;\n            }\n        }\n        rsp.sendError(SC_NOT_FOUND);\n    }\n\n    private URL getStaticHelpUrl(Klass<?> c, String suffix) {\n        Locale locale = Stapler.getCurrentRequest().getLocale();\n\n        String base = \"help\"+suffix;\n\n        URL url;\n        url = c.getResource(base + '_' + locale.getLanguage() + '_' + locale.getCountry() + '_' + locale.getVariant() + \".html\");\n        if(url!=null)    return url;\n        url = c.getResource(base + '_' + locale.getLanguage() + '_' + locale.getCountry() + \".html\");\n        if(url!=null)    return url;\n        url = c.getResource(base + '_' + locale.getLanguage() + \".html\");\n        if(url!=null)    return url;\n\n        // default\n        return c.getResource(base + \".html\");\n    }\n\n\n//\n// static methods\n//\n\n\n    // to work around warning when creating a generic array type\n    public static <T> T[] toArray( T... values ) {\n        return values;\n    }\n\n    public static <T> List<T> toList( T... values ) {\n        return new ArrayList<T>(Arrays.asList(values));\n    }\n\n    public static <T extends Describable<T>>\n    Map<Descriptor<T>,T> toMap(Iterable<T> describables) {\n        Map<Descriptor<T>,T> m = new LinkedHashMap<Descriptor<T>,T>();\n        for (T d : describables) {\n            m.put(d.getDescriptor(),d);\n        }\n        return m;\n    }\n\n    /**\n     * Used to build {@link Describable} instance list from &lt;f:hetero-list> tag.\n     *\n     * @param req\n     *      Request that represents the form submission.\n     * @param formData\n     *      Structured form data that represents the contains data for the list of describables.\n     * @param key\n     *      The JSON property name for 'formData' that represents the data for the list of describables.\n     * @param descriptors\n     *      List of descriptors to create instances from.\n     * @return\n     *      Can be empty but never null.\n     */\n    public static <T extends Describable<T>>\n    List<T> newInstancesFromHeteroList(StaplerRequest req, JSONObject formData, String key,\n                Collection<? extends Descriptor<T>> descriptors) throws FormException {\n\n        return newInstancesFromHeteroList(req,formData.get(key),descriptors);\n    }\n\n    public static <T extends Describable<T>>\n    List<T> newInstancesFromHeteroList(StaplerRequest req, Object formData,\n                Collection<? extends Descriptor<T>> descriptors) throws FormException {\n\n        List<T> items = new ArrayList<T>();\n\n        if (formData!=null) {\n            for (Object o : JSONArray.fromObject(formData)) {\n                JSONObject jo = (JSONObject)o;\n                String kind = jo.getString(\"kind\");\n                items.add(find(descriptors,kind).newInstance(req,jo));\n            }\n        }\n\n        return items;\n    }\n\n    /**\n     * Finds a descriptor from a collection by its class name.\n     */\n    public static <T extends Descriptor> T find(Collection<? extends T> list, String className) {\n        for (T d : list) {\n            if(d.getClass().getName().equals(className))\n                return d;\n        }\n        // Since we introduced Descriptor.getId(), it is a preferred method of identifying descriptor by a string.\n        // To make that migration easier without breaking compatibility, let's also match up with the id.\n        for (T d : list) {\n            if(d.getId().equals(className))\n                return d;\n        }\n        return null;\n    }\n\n    public static Descriptor find(String className) {\n        return find(Jenkins.getInstance().getExtensionList(Descriptor.class),className);\n    }\n\n    public static final class FormException extends Exception implements HttpResponse {\n        private final String formField;\n\n        public FormException(String message, String formField) {\n            super(message);\n            this.formField = formField;\n        }\n\n        public FormException(String message, Throwable cause, String formField) {\n            super(message, cause);\n            this.formField = formField;\n        }\n\n        public FormException(Throwable cause, String formField) {\n            super(cause);\n            this.formField = formField;\n        }\n\n        /**\n         * Which form field contained an error?\n         */\n        public String getFormField() {\n            return formField;\n        }\n\n        public void generateResponse(StaplerRequest req, StaplerResponse rsp, Object node) throws IOException, ServletException {\n            if (FormApply.isApply(req)) {\n                FormApply.applyResponse(\"notificationBar.show(\" + quote(getMessage())+ \",notificationBar.defaultOptions.ERROR)\")\n                        .generateResponse(req, rsp, node);\n            } else {\n                // for now, we can't really use the field name that caused the problem.\n                new Failure(getMessage()).generateResponse(req,rsp,node);\n            }\n        }\n    }\n\n    private static final Logger LOGGER = Logger.getLogger(Descriptor.class.getName());\n\n    /**\n     * Used in {@link #checkMethods} to indicate that there's no check method.\n     */\n    private static final String NONE = \"\\u0000\";\n\n    /**\n     * Special type indicating that {@link Descriptor} describes itself.\n     * @see Descriptor#Descriptor(Class)\n     */\n    public static final class Self {}\n\n    protected static Class self() { return Self.class; }\n}\n", "/*\n * The MIT License\n *\n * Copyright (c) 2004-2009, Sun Microsystems, Inc., Kohsuke Kawaguchi, Brian Westrich, Martin Eigenbrodt\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage hudson.tasks;\n\nimport hudson.Extension;\nimport hudson.Launcher;\nimport hudson.Util;\nimport hudson.console.ModelHyperlinkNote;\nimport hudson.model.AbstractBuild;\nimport hudson.model.AbstractProject;\nimport hudson.model.Action;\nimport hudson.model.AutoCompletionCandidates;\nimport hudson.model.BuildListener;\nimport hudson.model.Cause.UpstreamCause;\nimport jenkins.model.DependencyDeclarer;\nimport hudson.model.DependencyGraph;\nimport hudson.model.DependencyGraph.Dependency;\nimport jenkins.model.Jenkins;\nimport hudson.model.Item;\nimport hudson.model.ItemGroup;\nimport hudson.model.Items;\nimport hudson.model.Job;\nimport hudson.model.Project;\nimport hudson.model.Result;\nimport hudson.model.Run;\nimport hudson.model.TaskListener;\nimport hudson.model.listeners.ItemListener;\nimport hudson.tasks.BuildTrigger.DescriptorImpl.ItemListenerImpl;\nimport hudson.util.FormValidation;\nimport net.sf.json.JSONObject;\nimport org.apache.commons.lang.StringUtils;\nimport org.kohsuke.stapler.AncestorInPath;\nimport org.kohsuke.stapler.DataBoundConstructor;\nimport org.kohsuke.stapler.QueryParameter;\nimport org.kohsuke.stapler.StaplerRequest;\n\nimport java.io.IOException;\nimport java.io.PrintStream;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport javax.annotation.CheckForNull;\n\n/**\n * Triggers builds of other projects.\n *\n * <p>\n * Despite what the name suggests, this class doesn't actually trigger other jobs\n * as a part of {@link #perform} method. Its main job is to simply augment\n * {@link DependencyGraph}. Jobs are responsible for triggering downstream jobs\n * on its own, because dependencies may come from other sources.\n *\n * <p>\n * This class, however, does provide the {@link #execute(AbstractBuild, BuildListener, BuildTrigger)}\n * method as a convenience method to invoke downstream builds.\n *\n * @author Kohsuke Kawaguchi\n */\npublic class BuildTrigger extends Recorder implements DependencyDeclarer {\n\n    /**\n     * Comma-separated list of other projects to be scheduled.\n     */\n    private String childProjects;\n\n    /**\n     * Threshold status to trigger other builds.\n     *\n     * For compatibility reasons, this field could be null, in which case\n     * it should read as \"SUCCESS\".\n     */\n    private final Result threshold;\n\n    public BuildTrigger(String childProjects, boolean evenIfUnstable) {\n        this(childProjects,evenIfUnstable ? Result.UNSTABLE : Result.SUCCESS);\n    }\n\n    @DataBoundConstructor\n    public BuildTrigger(String childProjects, String threshold) {\n        this(childProjects, Result.fromString(StringUtils.defaultString(threshold, Result.SUCCESS.toString())));\n    }\n\n    public BuildTrigger(String childProjects, Result threshold) {\n        if(childProjects==null)\n            throw new IllegalArgumentException();\n        this.childProjects = childProjects;\n        this.threshold = threshold;\n    }\n\n    public BuildTrigger(List<AbstractProject> childProjects, Result threshold) {\n        this((Collection<AbstractProject>)childProjects,threshold);\n    }\n\n    public BuildTrigger(Collection<? extends AbstractProject> childProjects, Result threshold) {\n        this(Items.toNameList(childProjects),threshold);\n    }\n\n    public String getChildProjectsValue() {\n        return childProjects;\n    }\n\n    public Result getThreshold() {\n        if(threshold==null)\n            return Result.SUCCESS;\n        else\n            return threshold;\n    }\n\n    /**\n     * @deprecated as of 1.406\n     *      Use {@link #getChildProjects(ItemGroup)}\n     */\n    public List<AbstractProject> getChildProjects() {\n        return getChildProjects(Jenkins.getInstance());\n    }\n\n    public List<AbstractProject> getChildProjects(AbstractProject owner) {\n        return getChildProjects(owner==null?null:owner.getParent());\n    }\n\n    public List<AbstractProject> getChildProjects(ItemGroup base) {\n        return Items.fromNameList(base,childProjects,AbstractProject.class);\n    }\n\n    public BuildStepMonitor getRequiredMonitorService() {\n        return BuildStepMonitor.NONE;\n    }\n\n    /**\n     * Checks if this trigger has the exact same set of children as the given list.\n     */\n    public boolean hasSame(AbstractProject owner, Collection<? extends AbstractProject> projects) {\n        List<AbstractProject> children = getChildProjects(owner);\n        return children.size()==projects.size() && children.containsAll(projects);\n    }\n\n    /**\n     * @deprecated as of 1.406\n     *      Use {@link #hasSame(AbstractProject, Collection)}\n     */\n    public boolean hasSame(Collection<? extends AbstractProject> projects) {\n        return hasSame(null,projects);\n    }\n\n    @Override\n    public boolean perform(AbstractBuild build, Launcher launcher, BuildListener listener) {\n        return true;\n    }\n\n    /**\n     * @deprecated since 1.341; use {@link #execute(AbstractBuild,BuildListener)}\n     */\n    @Deprecated\n    public static boolean execute(AbstractBuild build, BuildListener listener, BuildTrigger trigger) {\n        return execute(build, listener);\n    }\n\n    /**\n     * Convenience method to trigger downstream builds.\n     *\n     * @param build\n     *      The current build. Its downstreams will be triggered.\n     * @param listener\n     *      Receives the progress report.\n     */\n    public static boolean execute(AbstractBuild build, BuildListener listener) {\n        PrintStream logger = listener.getLogger();\n        // Check all downstream Project of the project, not just those defined by BuildTrigger\n        final DependencyGraph graph = Jenkins.getInstance().getDependencyGraph();\n        List<Dependency> downstreamProjects = new ArrayList<Dependency>(\n                graph.getDownstreamDependencies(build.getProject()));\n        // Sort topologically\n        Collections.sort(downstreamProjects, new Comparator<Dependency>() {\n            public int compare(Dependency lhs, Dependency rhs) {\n                // Swapping lhs/rhs to get reverse sort:\n                return graph.compare(rhs.getDownstreamProject(), lhs.getDownstreamProject());\n            }\n        });\n\n        for (Dependency dep : downstreamProjects) {\n            AbstractProject p = dep.getDownstreamProject();\n            if (p.isDisabled()) {\n                logger.println(Messages.BuildTrigger_Disabled(ModelHyperlinkNote.encodeTo(p)));\n                continue;\n            }\n            List<Action> buildActions = new ArrayList<Action>();\n            if (dep.shouldTriggerBuild(build, listener, buildActions)) {\n                // this is not completely accurate, as a new build might be triggered\n                // between these calls\n                String name = ModelHyperlinkNote.encodeTo(p)+\" #\"+p.getNextBuildNumber();\n                if(p.scheduleBuild(p.getQuietPeriod(), new UpstreamCause((Run)build),\n                                   buildActions.toArray(new Action[buildActions.size()]))) {\n                    logger.println(Messages.BuildTrigger_Triggering(name));\n                } else {\n                    logger.println(Messages.BuildTrigger_InQueue(name));\n                }\n            }\n        }\n\n        return true;\n    }\n\n    public void buildDependencyGraph(AbstractProject owner, DependencyGraph graph) {\n        for (AbstractProject p : getChildProjects(owner))\n            graph.addDependency(new Dependency(owner, p) {\n                @Override\n                public boolean shouldTriggerBuild(AbstractBuild build, TaskListener listener,\n                                                  List<Action> actions) {\n                    return build.getResult().isBetterOrEqualTo(threshold);\n                }\n            });\n    }\n\n    @Override\n    public boolean needsToRunAfterFinalized() {\n        return true;\n    }\n\n    /**\n     * Called from {@link ItemListenerImpl} when a job is renamed.\n     *\n     * @return true if this {@link BuildTrigger} is changed and needs to be saved.\n     */\n    public boolean onJobRenamed(String oldName, String newName) {\n        // quick test\n        if(!childProjects.contains(oldName))\n            return false;\n\n        boolean changed = false;\n\n        // we need to do this per string, since old Project object is already gone.\n        String[] projects = childProjects.split(\",\");\n        for( int i=0; i<projects.length; i++ ) {\n            if(projects[i].trim().equals(oldName)) {\n                projects[i] = newName;\n                changed = true;\n            }\n        }\n\n        if(changed) {\n            StringBuilder b = new StringBuilder();\n            for (String p : projects) {\n                if(b.length()>0)    b.append(',');\n                b.append(p);\n            }\n            childProjects = b.toString();\n        }\n\n        return changed;\n    }\n\n    /**\n     * Correct broken data gracefully (#1537)\n     */\n    private Object readResolve() {\n        if(childProjects==null)\n            return childProjects=\"\";\n        return this;\n    }\n\n    @Extension\n    public static class DescriptorImpl extends BuildStepDescriptor<Publisher> {\n        public String getDisplayName() {\n            return Messages.BuildTrigger_DisplayName();\n        }\n\n        @Override\n        public String getHelpFile() {\n            return \"/help/project-config/downstream.html\";\n        }\n\n        @Override\n        public Publisher newInstance(StaplerRequest req, JSONObject formData) throws FormException {\n            String childProjectsString = formData.getString(\"childProjects\").trim();\n            if (childProjectsString.endsWith(\",\")) {\n                childProjectsString = childProjectsString.substring(0, childProjectsString.length() - 1).trim();\n            }\n            return new BuildTrigger(\n                childProjectsString,\n                formData.optString(\"threshold\", Result.SUCCESS.toString()));\n        }\n\n        @Override\n        public boolean isApplicable(Class<? extends AbstractProject> jobType) {\n            return true;\n        }\n\n        public boolean showEvenIfUnstableOption(@CheckForNull Class<? extends AbstractProject<?,?>> jobType) {\n            // UGLY: for promotion process, this option doesn't make sense.\n            return jobType == null || !jobType.getName().contains(\"PromotionProcess\");\n        }\n\n        /**\n         * Form validation method.\n         */\n        public FormValidation doCheck(@AncestorInPath Item project, @QueryParameter String value ) {\n            // Require CONFIGURE permission on this project\n            if(!project.hasPermission(Item.CONFIGURE))      return FormValidation.ok();\n\n            StringTokenizer tokens = new StringTokenizer(Util.fixNull(value),\",\");\n            boolean hasProjects = false;\n            while(tokens.hasMoreTokens()) {\n                String projectName = tokens.nextToken().trim();\n                if (StringUtils.isNotBlank(projectName)) {\n                    Item item = Jenkins.getInstance().getItem(projectName,project,Item.class);\n                    if(item==null)\n                        return FormValidation.error(Messages.BuildTrigger_NoSuchProject(projectName,\n                                AbstractProject.findNearest(projectName,project.getParent()).getRelativeNameFrom(project)));\n                    if(!(item instanceof AbstractProject))\n                        return FormValidation.error(Messages.BuildTrigger_NotBuildable(projectName));\n                    hasProjects = true;\n                }\n            }\n            if (!hasProjects) {\n                return FormValidation.error(Messages.BuildTrigger_NoProjectSpecified());\n            }\n\n            return FormValidation.ok();\n        }\n\n        public AutoCompletionCandidates doAutoCompleteChildProjects(@QueryParameter String value, @AncestorInPath Item self, @AncestorInPath ItemGroup container) {\n            return AutoCompletionCandidates.ofJobNames(Job.class,value,self,container);\n        }\n\n        @Extension\n        public static class ItemListenerImpl extends ItemListener {\n            @Override\n            public void onRenamed(Item item, String oldName, String newName) {\n                // update BuildTrigger of other projects that point to this object.\n                // can't we generalize this?\n                for( Project<?,?> p : Jenkins.getInstance().getAllItems(Project.class) ) {\n                    BuildTrigger t = p.getPublishersList().get(BuildTrigger.class);\n                    if(t!=null) {\n                        if(t.onJobRenamed(oldName,newName)) {\n                            try {\n                                p.save();\n                            } catch (IOException e) {\n                                LOGGER.log(Level.WARNING, \"Failed to persist project setting during rename from \"+oldName+\" to \"+newName,e);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    private static final Logger LOGGER = Logger.getLogger(BuildTrigger.class.getName());\n}\n", "# The MIT License\n# \n# Copyright (c) 2004-2009, Sun Microsystems, Inc., Kohsuke Kawaguchi, Jene Jasper\n# \n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n# \n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n# \n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n# THE SOFTWARE.\n\nAnt.DisplayName=Invoke Ant\nAnt.ExecFailed=command execution failed.\nAnt.ExecutableNotFound=Cannot find executable from the chosen Ant installation \"{0}\"\nAnt.GlobalConfigNeeded= Maybe you need to configure where your Ant installations are?\nAnt.NotADirectory={0} is not a directory\nAnt.NotAntDirectory={0} doesn''t look like an Ant directory\nAnt.ProjectConfigNeeded= Maybe you need to configure the job to choose one of your Ant installations?\n\nArtifactArchiver.ARCHIVING_ARTIFACTS=Archiving artifacts\nArtifactArchiver.DeletingOld=Deleting old artifacts from {0}\nArtifactArchiver.DisplayName=Archive the artifacts\nArtifactArchiver.FailedToArchive=Failed to archive artifacts: {0}\nArtifactArchiver.NoIncludes=\\\nNo artifacts are configured for archiving.\\n\\\nYou probably forgot to set the file pattern, so please go back to the configuration and specify it.\\n\\\nIf you really did mean to archive all the files in the workspace, please specify \"**\"\nArtifactArchiver.NoMatchFound=No artifacts found that match the file pattern \"{0}\". Configuration error?\n\nBatchFile.DisplayName=Execute Windows batch command\n\nBuildTrigger.Disabled={0} is disabled. Triggering skipped\nBuildTrigger.DisplayName=Build other projects\nBuildTrigger.InQueue={0} is already in the queue\nBuildTrigger.NoSuchProject=No such project ''{0}''. Did you mean ''{1}''?\nBuildTrigger.NoProjectSpecified=No project specified\nBuildTrigger.NotBuildable={0} is not buildable\nBuildTrigger.Triggering=Triggering a new build of {0}\n\nCommandInterpreter.CommandFailed=command execution failed\nCommandInterpreter.UnableToDelete=Unable to delete script file {0}\nCommandInterpreter.UnableToProduceScript=Unable to produce a script file\n\nFingerprinter.Aborted=Aborted\nFingerprinter.Action.DisplayName=See Fingerprints\nFingerprinter.DigestFailed=Failed to compute digest for {0}\nFingerprinter.DisplayName=Record fingerprints of files to track usage\nFingerprinter.Failed=Failed to record fingerprints\nFingerprinter.FailedFor=failed to record fingerprint for {0}\nFingerprinter.NoArchiving=Build artifacts are supposed to be fingerprinted, but build artifact archiving is not configured\nFingerprinter.NoWorkspace=Unable to record fingerprints because there''s no workspace\nFingerprinter.Recording=Recording fingerprints\n\nInstallFromApache=Install from Apache\n\nJavadocArchiver.DisplayName=Publish Javadoc\nJavadocArchiver.DisplayName.Generic=Document\nJavadocArchiver.DisplayName.Javadoc=Javadoc\nTestJavadocArchiver.DisplayName.Javadoc=Test Javadoc\nJavadocArchiver.NoMatchFound=No javadoc found in {0}: {1}\nJavadocArchiver.Publishing=Publishing Javadoc\nJavadocArchiver.UnableToCopy=Unable to copy Javadoc from {0} to {1}\n\nMaven.DisplayName=Invoke top-level Maven targets\nMaven.ExecFailed=command execution failed\nMaven.NotMavenDirectory={0} doesn''t look like a Maven directory\nMaven.NoExecutable=Couldn''t find any executable in {0}\nMaven.NotADirectory={0} is not a directory\n\nShell.DisplayName=Execute shell\n", "<!--\nThe MIT License\n\nCopyright (c) 2004-2011, Sun Microsystems, Inc., Kohsuke Kawaguchi, Seiji Sogabe, Andrew Bayer\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n-->\n\n<!--\n  Present the pseudo \"upstream project trigger\". Used inside <p:config-trigger>\n\n  \"it\" is assumed to be a Project object.\n-->\n<?jelly escape-by-default='true'?>\n<j:jelly xmlns:j=\"jelly:core\" xmlns:st=\"jelly:stapler\" xmlns:d=\"jelly:define\" xmlns:l=\"/lib/layout\" xmlns:t=\"/lib/hudson\" xmlns:f=\"/lib/form\">\n  <!-- pseudo-trigger to list upstream projects. -->\n  <j:set var=\"up\" value=\"${it.buildTriggerUpstreamProjects}\" />\n  <f:optionalBlock name=\"pseudoUpstreamTrigger\"\n                   help=\"/help/project-config/upstream.html\"\n                   title=\"${%Build after other projects are built}\" \n                   checked=\"${!empty(up)}\">\n    <f:entry title=\"${%Project names}\"\n             description=\"${%Multiple projects can be specified like 'abc, def'}\">\n      <f:textbox name=\"upstreamProjects\" value=\"${h.getProjectListString(up)}\"\n        checkUrl=\"'descriptorByName/hudson.tasks.BuildTrigger/check?value='+encodeURIComponent(this.value)\"\n        autoCompleteField=\"upstreamProjects\"/>\n    </f:entry>\n  </f:optionalBlock>\n</j:jelly>\n"], "fixing_code": ["/*\n * The MIT License\n * \n * Copyright (c) 2004-2011, Sun Microsystems, Inc., Kohsuke Kawaguchi,\n * Brian Westrich, Erik Ramfelt, Ertan Deniz, Jean-Baptiste Quenot,\n * Luca Domenico Milanesio, R. Tyler Ballance, Stephen Connolly, Tom Huybrechts,\n * id:cactusman, Yahoo! Inc., Andrew Bayer, Manufacture Francaise des Pneumatiques\n * Michelin, Romain Seguy\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage hudson.model;\n\nimport com.infradna.tool.bridge_method_injector.WithBridgeMethods;\nimport hudson.EnvVars;\nimport hudson.Functions;\nimport antlr.ANTLRException;\nimport hudson.AbortException;\nimport hudson.CopyOnWrite;\nimport hudson.FeedAdapter;\nimport hudson.FilePath;\nimport hudson.Launcher;\nimport hudson.Util;\nimport hudson.cli.declarative.CLIMethod;\nimport hudson.cli.declarative.CLIResolver;\nimport hudson.model.Cause.LegacyCodeCause;\nimport hudson.model.Cause.RemoteCause;\nimport hudson.model.Cause.UserIdCause;\nimport hudson.model.Descriptor.FormException;\nimport hudson.model.Fingerprint.RangeSet;\nimport hudson.model.Queue.Executable;\nimport hudson.model.Queue.Task;\nimport hudson.model.queue.QueueTaskFuture;\nimport hudson.model.queue.SubTask;\nimport hudson.model.Queue.WaitingItem;\nimport hudson.model.RunMap.Constructor;\nimport hudson.model.labels.LabelAtom;\nimport hudson.model.labels.LabelExpression;\nimport hudson.model.listeners.SCMPollListener;\nimport hudson.model.queue.CauseOfBlockage;\nimport hudson.model.queue.SubTaskContributor;\nimport hudson.scm.ChangeLogSet;\nimport hudson.scm.ChangeLogSet.Entry;\nimport hudson.scm.NullSCM;\nimport hudson.scm.PollingResult;\nimport hudson.scm.SCM;\nimport hudson.scm.SCMRevisionState;\nimport hudson.scm.SCMS;\nimport hudson.search.SearchIndexBuilder;\nimport hudson.security.Permission;\nimport hudson.slaves.WorkspaceList;\nimport hudson.tasks.BuildStep;\nimport hudson.tasks.BuildStepDescriptor;\nimport hudson.tasks.BuildTrigger;\nimport hudson.tasks.BuildWrapperDescriptor;\nimport hudson.tasks.Publisher;\nimport hudson.triggers.SCMTrigger;\nimport hudson.triggers.Trigger;\nimport hudson.triggers.TriggerDescriptor;\nimport hudson.util.AlternativeUiTextProvider;\nimport hudson.util.AlternativeUiTextProvider.Message;\nimport hudson.util.DescribableList;\nimport hudson.util.EditDistance;\nimport hudson.util.FormValidation;\nimport hudson.widgets.BuildHistoryWidget;\nimport hudson.widgets.HistoryWidget;\nimport jenkins.model.Jenkins;\nimport jenkins.model.JenkinsLocationConfiguration;\nimport jenkins.model.lazy.AbstractLazyLoadRunMap.Direction;\nimport jenkins.scm.DefaultSCMCheckoutStrategyImpl;\nimport jenkins.scm.SCMCheckoutStrategy;\nimport jenkins.scm.SCMCheckoutStrategyDescriptor;\nimport jenkins.util.TimeDuration;\nimport net.sf.json.JSONObject;\nimport org.apache.tools.ant.taskdefs.email.Mailer;\nimport org.kohsuke.accmod.Restricted;\nimport org.kohsuke.accmod.restrictions.NoExternalUse;\nimport org.kohsuke.args4j.Argument;\nimport org.kohsuke.args4j.CmdLineException;\nimport org.kohsuke.stapler.ForwardToView;\nimport org.kohsuke.stapler.HttpRedirect;\nimport org.kohsuke.stapler.HttpResponse;\nimport org.kohsuke.stapler.HttpResponses;\nimport org.kohsuke.stapler.QueryParameter;\nimport org.kohsuke.stapler.StaplerRequest;\nimport org.kohsuke.stapler.StaplerResponse;\nimport org.kohsuke.stapler.export.Exported;\nimport org.kohsuke.stapler.interceptor.RequirePOST;\n\nimport javax.servlet.ServletException;\nimport java.io.File;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Calendar;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.Vector;\nimport java.util.concurrent.Future;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport static hudson.scm.PollingResult.*;\nimport static javax.servlet.http.HttpServletResponse.*;\n\n/**\n * Base implementation of {@link Job}s that build software.\n *\n * For now this is primarily the common part of {@link Project} and MavenModule.\n *\n * @author Kohsuke Kawaguchi\n * @see AbstractBuild\n */\n@SuppressWarnings(\"rawtypes\")\npublic abstract class AbstractProject<P extends AbstractProject<P,R>,R extends AbstractBuild<P,R>> extends Job<P,R> implements BuildableItem {\n\n    /**\n     * {@link SCM} associated with the project.\n     * To allow derived classes to link {@link SCM} config to elsewhere,\n     * access to this variable should always go through {@link #getScm()}.\n     */\n    private volatile SCM scm = new NullSCM();\n\n    /**\n     * Controls how the checkout is done.\n     */\n    private volatile SCMCheckoutStrategy scmCheckoutStrategy;\n\n    /**\n     * State returned from {@link SCM#poll(AbstractProject, Launcher, FilePath, TaskListener, SCMRevisionState)}.\n     */\n    private volatile transient SCMRevisionState pollingBaseline = null;\n\n    /**\n     * All the builds keyed by their build number.\n     *\n     * External code should use {@link #getBuildByNumber(int)} or {@link #getLastBuild()} and traverse via\n     * {@link Run#getPreviousBuild()}\n     */\n    @Restricted(NoExternalUse.class)\n    @SuppressWarnings(\"deprecation\") // [JENKINS-15156] builds accessed before onLoad or onCreatedFromScratch called\n    protected transient RunMap<R> builds = new RunMap<R>();\n\n    /**\n     * The quiet period. Null to delegate to the system default.\n     */\n    private volatile Integer quietPeriod = null;\n    \n    /**\n     * The retry count. Null to delegate to the system default.\n     */\n    private volatile Integer scmCheckoutRetryCount = null;\n\n    /**\n     * If this project is configured to be only built on a certain label,\n     * this value will be set to that label.\n     *\n     * For historical reasons, this is called 'assignedNode'. Also for\n     * a historical reason, null to indicate the affinity\n     * with the master node.\n     *\n     * @see #canRoam\n     */\n    private String assignedNode;\n\n    /**\n     * True if this project can be built on any node.\n     *\n     * <p>\n     * This somewhat ugly flag combination is so that we can migrate\n     * existing Hudson installations nicely.\n     */\n    private volatile boolean canRoam;\n\n    /**\n     * True to suspend new builds.\n     */\n    protected volatile boolean disabled;\n\n    /**\n     * True to keep builds of this project in queue when downstream projects are\n     * building. False by default to keep from breaking existing behavior.\n     */\n    protected volatile boolean blockBuildWhenDownstreamBuilding = false;\n\n    /**\n     * True to keep builds of this project in queue when upstream projects are\n     * building. False by default to keep from breaking existing behavior.\n     */\n    protected volatile boolean blockBuildWhenUpstreamBuilding = false;\n\n    /**\n     * Identifies {@link JDK} to be used.\n     * Null if no explicit configuration is required.\n     *\n     * <p>\n     * Can't store {@link JDK} directly because {@link Jenkins} and {@link Project}\n     * are saved independently.\n     *\n     * @see Jenkins#getJDK(String)\n     */\n    private volatile String jdk;\n\n    private volatile BuildAuthorizationToken authToken = null;\n\n    /**\n     * List of all {@link Trigger}s for this project.\n     */\n    protected List<Trigger<?>> triggers = new Vector<Trigger<?>>();\n\n    /**\n     * {@link Action}s contributed from subsidiary objects associated with\n     * {@link AbstractProject}, such as from triggers, builders, publishers, etc.\n     *\n     * We don't want to persist them separately, and these actions\n     * come and go as configuration change, so it's kept separate.\n     */\n    @CopyOnWrite\n    protected transient volatile List<Action> transientActions = new Vector<Action>();\n\n    private boolean concurrentBuild;\n\n    /**\n     * See {@link #setCustomWorkspace(String)}.\n     *\n     * @since 1.410\n     */\n    private String customWorkspace;\n    \n    protected AbstractProject(ItemGroup parent, String name) {\n        super(parent,name);\n\n        if(!Jenkins.getInstance().getNodes().isEmpty()) {\n            // if a new job is configured with Hudson that already has slave nodes\n            // make it roamable by default\n            canRoam = true;\n        }\n    }\n\n    @Override\n    public synchronized void save() throws IOException {\n        super.save();\n        updateTransientActions();\n    }\n\n    @Override\n    public void onCreatedFromScratch() {\n        super.onCreatedFromScratch();\n        builds = createBuildRunMap();\n        // solicit initial contributions, especially from TransientProjectActionFactory\n        updateTransientActions();\n    }\n\n    @Override\n    public void onLoad(ItemGroup<? extends Item> parent, String name) throws IOException {\n        super.onLoad(parent, name);\n\n        RunMap<R> builds = createBuildRunMap();\n        if (this.builds!=null) {\n            // if we are reloading, keep all those that are still building intact\n            for (R r : this.builds.getLoadedBuilds().values()) {\n                if (r.isBuilding())\n                    builds.put(r);\n            }\n        }\n        this.builds = builds;\n        for (Trigger t : triggers())\n            t.start(this, Items.updatingByXml.get());\n        if(scm==null)\n            scm = new NullSCM(); // perhaps it was pointing to a plugin that no longer exists.\n\n        if(transientActions==null)\n            transientActions = new Vector<Action>();    // happens when loaded from disk\n        updateTransientActions();\n    }\n\n    private RunMap<R> createBuildRunMap() {\n        return new RunMap<R>(getBuildDir(), new Constructor<R>() {\n            public R create(File dir) throws IOException {\n                return loadBuild(dir);\n            }\n        });\n    }\n\n    private synchronized List<Trigger<?>> triggers() {\n        if (triggers == null) {\n            triggers = new Vector<Trigger<?>>();\n        }\n        return triggers;\n    }\n\n    @Override\n    public EnvVars getEnvironment(Node node, TaskListener listener) throws IOException, InterruptedException {\n        EnvVars env =  super.getEnvironment(node, listener);\n\n        JDK jdk = getJDK();\n        if (jdk != null) {\n            if (node != null) { // just in case were not in a build\n                jdk = jdk.forNode(node, listener);\n            }\n            jdk.buildEnvVars(env);\n        }\n\n        return env;\n    }\n\n    @Override\n    protected void performDelete() throws IOException, InterruptedException {\n        // prevent a new build while a delete operation is in progress\n        makeDisabled(true);\n        FilePath ws = getWorkspace();\n        if(ws!=null) {\n            Node on = getLastBuiltOn();\n            getScm().processWorkspaceBeforeDeletion(this, ws, on);\n            if(on!=null)\n                on.getFileSystemProvisioner().discardWorkspace(this,ws);\n        }\n        super.performDelete();\n    }\n\n    /**\n     * Does this project perform concurrent builds?\n     * @since 1.319\n     */\n    @Exported\n    public boolean isConcurrentBuild() {\n        return concurrentBuild;\n    }\n\n    public void setConcurrentBuild(boolean b) throws IOException {\n        concurrentBuild = b;\n        save();\n    }\n\n    /**\n     * If this project is configured to be always built on this node,\n     * return that {@link Node}. Otherwise null.\n     */\n    public Label getAssignedLabel() {\n        if(canRoam)\n            return null;\n\n        if(assignedNode==null)\n            return Jenkins.getInstance().getSelfLabel();\n        return Jenkins.getInstance().getLabel(assignedNode);\n    }\n\n    /**\n     * Set of labels relevant to this job.\n     *\n     * This method is used to determine what slaves are relevant to jobs, for example by {@link View}s.\n     * It does not affect the scheduling. This information is informational and the best-effort basis.\n     *\n     * @since 1.456\n     * @return\n     *      Minimally it should contain {@link #getAssignedLabel()}. The set can contain null element\n     *      to correspond to the null return value from {@link #getAssignedLabel()}.\n     */\n    public Set<Label> getRelevantLabels() {\n        return Collections.singleton(getAssignedLabel());\n    }\n\n    /**\n     * Gets the textual representation of the assigned label as it was entered by the user.\n     */\n    public String getAssignedLabelString() {\n        if (canRoam || assignedNode==null)    return null;\n        try {\n            LabelExpression.parseExpression(assignedNode);\n            return assignedNode;\n        } catch (ANTLRException e) {\n            // must be old label or host name that includes whitespace or other unsafe chars\n            return LabelAtom.escape(assignedNode);\n        }\n    }\n\n    /**\n     * Sets the assigned label.\n     */\n    public void setAssignedLabel(Label l) throws IOException {\n        if(l==null) {\n            canRoam = true;\n            assignedNode = null;\n        } else {\n            canRoam = false;\n            if(l== Jenkins.getInstance().getSelfLabel())  assignedNode = null;\n            else                                        assignedNode = l.getExpression();\n        }\n        save();\n    }\n\n    /**\n     * Assigns this job to the given node. A convenience method over {@link #setAssignedLabel(Label)}.\n     */\n    public void setAssignedNode(Node l) throws IOException {\n        setAssignedLabel(l.getSelfLabel());\n    }\n\n    /**\n     * Get the term used in the UI to represent this kind of {@link AbstractProject}.\n     * Must start with a capital letter.\n     */\n    @Override\n    public String getPronoun() {\n        return AlternativeUiTextProvider.get(PRONOUN, this,Messages.AbstractProject_Pronoun());\n    }\n\n    /**\n     * Gets the human readable display name to be rendered in the \"Build Now\" link.\n     *\n     * @since 1.401\n     */\n    public String getBuildNowText() {\n        return AlternativeUiTextProvider.get(BUILD_NOW_TEXT,this,Messages.AbstractProject_BuildNow());\n    }\n\n    /**\n     * Gets the nearest ancestor {@link TopLevelItem} that's also an {@link AbstractProject}.\n     *\n     * <p>\n     * Some projects (such as matrix projects, Maven projects, or promotion processes) form a tree of jobs\n     * that acts as a single unit. This method can be used to find the top most dominating job that\n     * covers such a tree.\n     *\n     * @return never null.\n     * @see AbstractBuild#getRootBuild()\n     */\n    public AbstractProject<?,?> getRootProject() {\n        if (this instanceof TopLevelItem) {\n            return this;\n        } else {\n            ItemGroup p = this.getParent();\n            if (p instanceof AbstractProject)\n                return ((AbstractProject) p).getRootProject();\n            return this;\n        }\n    }\n\n    /**\n     * Gets the directory where the module is checked out.\n     *\n     * @return\n     *      null if the workspace is on a slave that's not connected.\n     * @deprecated as of 1.319\n     *      To support concurrent builds of the same project, this method is moved to {@link AbstractBuild}.\n     *      For backward compatibility, this method returns the right {@link AbstractBuild#getWorkspace()} if called\n     *      from {@link Executor}, and otherwise the workspace of the last build.\n     *\n     *      <p>\n     *      If you are calling this method during a build from an executor, switch it to {@link AbstractBuild#getWorkspace()}.\n     *      If you are calling this method to serve a file from the workspace, doing a form validation, etc., then\n     *      use {@link #getSomeWorkspace()}\n     */\n    public final FilePath getWorkspace() {\n        AbstractBuild b = getBuildForDeprecatedMethods();\n        return b != null ? b.getWorkspace() : null;\n\n    }\n    \n    /**\n     * Various deprecated methods in this class all need the 'current' build.  This method returns\n     * the build suitable for that purpose.\n     * \n     * @return An AbstractBuild for deprecated methods to use.\n     */\n    private AbstractBuild getBuildForDeprecatedMethods() {\n        Executor e = Executor.currentExecutor();\n        if(e!=null) {\n            Executable exe = e.getCurrentExecutable();\n            if (exe instanceof AbstractBuild) {\n                AbstractBuild b = (AbstractBuild) exe;\n                if(b.getProject()==this)\n                    return b;\n            }\n        }\n        R lb = getLastBuild();\n        if(lb!=null)    return lb;\n        return null;\n    }\n\n    /**\n     * Gets a workspace for some build of this project.\n     *\n     * <p>\n     * This is useful for obtaining a workspace for the purpose of form field validation, where exactly\n     * which build the workspace belonged is less important. The implementation makes a cursory effort\n     * to find some workspace.\n     *\n     * @return\n     *      null if there's no available workspace.\n     * @since 1.319\n     */\n    public final FilePath getSomeWorkspace() {\n        R b = getSomeBuildWithWorkspace();\n        if (b!=null) return b.getWorkspace();\n        for (WorkspaceBrowser browser : Jenkins.getInstance().getExtensionList(WorkspaceBrowser.class)) {\n            FilePath f = browser.getWorkspace(this);\n            if (f != null) return f;\n        }\n        return null;\n    }\n\n    /**\n     * Gets some build that has a live workspace.\n     *\n     * @return null if no such build exists.\n     */\n    public final R getSomeBuildWithWorkspace() {\n        int cnt=0;\n        for (R b = getLastBuild(); cnt<5 && b!=null; b=b.getPreviousBuild()) {\n            FilePath ws = b.getWorkspace();\n            if (ws!=null)   return b;\n        }\n        return null;\n    }\n\n    /**\n     * Returns the root directory of the checked-out module.\n     * <p>\n     * This is usually where <tt>pom.xml</tt>, <tt>build.xml</tt>\n     * and so on exists.\n     *\n     * @deprecated as of 1.319\n     *      See {@link #getWorkspace()} for a migration strategy.\n     */\n    public FilePath getModuleRoot() {\n        AbstractBuild b = getBuildForDeprecatedMethods();\n        return b != null ? b.getModuleRoot() : null;\n    }\n\n    /**\n     * Returns the root directories of all checked-out modules.\n     * <p>\n     * Some SCMs support checking out multiple modules into the same workspace.\n     * In these cases, the returned array will have a length greater than one.\n     * @return The roots of all modules checked out from the SCM.\n     *\n     * @deprecated as of 1.319\n     *      See {@link #getWorkspace()} for a migration strategy.\n     */\n    public FilePath[] getModuleRoots() {\n        AbstractBuild b = getBuildForDeprecatedMethods();\n        return b != null ? b.getModuleRoots() : null;\n    }\n\n    public int getQuietPeriod() {\n        return quietPeriod!=null ? quietPeriod : Jenkins.getInstance().getQuietPeriod();\n    }\n\n    public SCMCheckoutStrategy getScmCheckoutStrategy() {\n        return scmCheckoutStrategy == null ? new DefaultSCMCheckoutStrategyImpl() : scmCheckoutStrategy;\n    }\n\n    public void setScmCheckoutStrategy(SCMCheckoutStrategy scmCheckoutStrategy) throws IOException {\n        this.scmCheckoutStrategy = scmCheckoutStrategy;\n        save();\n    }\n\n\n    public int getScmCheckoutRetryCount() {\n        return scmCheckoutRetryCount !=null ? scmCheckoutRetryCount : Jenkins.getInstance().getScmCheckoutRetryCount();\n    }\n\n    // ugly name because of EL\n    public boolean getHasCustomQuietPeriod() {\n        return quietPeriod!=null;\n    }\n\n    /**\n     * Sets the custom quiet period of this project, or revert to the global default if null is given. \n     */\n    public void setQuietPeriod(Integer seconds) throws IOException {\n        this.quietPeriod = seconds;\n        save();\n    }\n    \n    public boolean hasCustomScmCheckoutRetryCount(){\n        return scmCheckoutRetryCount != null;\n    }\n\n    @Override\n    public boolean isBuildable() {\n        return !isDisabled() && !isHoldOffBuildUntilSave();\n    }\n\n    /**\n     * Used in <tt>sidepanel.jelly</tt> to decide whether to display\n     * the config/delete/build links.\n     */\n    public boolean isConfigurable() {\n        return true;\n    }\n\n    public boolean blockBuildWhenDownstreamBuilding() {\n        return blockBuildWhenDownstreamBuilding;\n    }\n\n    public void setBlockBuildWhenDownstreamBuilding(boolean b) throws IOException {\n        blockBuildWhenDownstreamBuilding = b;\n        save();\n    }\n\n    public boolean blockBuildWhenUpstreamBuilding() {\n        return blockBuildWhenUpstreamBuilding;\n    }\n\n    public void setBlockBuildWhenUpstreamBuilding(boolean b) throws IOException {\n        blockBuildWhenUpstreamBuilding = b;\n        save();\n    }\n\n    public boolean isDisabled() {\n        return disabled;\n    }\n    \n    /**\n     * Validates the retry count Regex\n     */\n    public FormValidation doCheckRetryCount(@QueryParameter String value)throws IOException,ServletException{\n        // retry count is optional so this is ok\n        if(value == null || value.trim().equals(\"\"))\n            return FormValidation.ok();\n        if (!value.matches(\"[0-9]*\")) {\n            return FormValidation.error(\"Invalid retry count\");\n        } \n        return FormValidation.ok();\n    }\n\n    /**\n     * Marks the build as disabled.\n     */\n    public void makeDisabled(boolean b) throws IOException {\n        if(disabled==b)     return; // noop\n        this.disabled = b;\n        if(b)\n            Jenkins.getInstance().getQueue().cancel(this);\n        save();\n    }\n\n    /**\n     * Specifies whether this project may be disabled by the user.\n     * By default, it can be only if this is a {@link TopLevelItem};\n     * would be false for matrix configurations, etc.\n     * @return true if the GUI should allow {@link #doDisable} and the like\n     * @since 1.475\n     */\n    public boolean supportsMakeDisabled() {\n        return this instanceof TopLevelItem;\n    }\n\n    public void disable() throws IOException {\n        makeDisabled(true);\n    }\n\n    public void enable() throws IOException {\n        makeDisabled(false);\n    }\n\n    @Override\n    public BallColor getIconColor() {\n        if(isDisabled())\n            return BallColor.DISABLED;\n        else\n            return super.getIconColor();\n    }\n\n    /**\n     * effectively deprecated. Since using updateTransientActions correctly\n     * under concurrent environment requires a lock that can too easily cause deadlocks.\n     *\n     * <p>\n     * Override {@link #createTransientActions()} instead.\n     */\n    protected void updateTransientActions() {\n        transientActions = createTransientActions();\n    }\n\n    protected List<Action> createTransientActions() {\n        Vector<Action> ta = new Vector<Action>();\n\n        for (JobProperty<? super P> p : Util.fixNull(properties))\n            ta.addAll(p.getJobActions((P)this));\n\n        for (TransientProjectActionFactory tpaf : TransientProjectActionFactory.all())\n            ta.addAll(Util.fixNull(tpaf.createFor(this))); // be defensive against null\n        return ta;\n    }\n\n    /**\n     * Returns the live list of all {@link Publisher}s configured for this project.\n     *\n     * <p>\n     * This method couldn't be called <tt>getPublishers()</tt> because existing methods\n     * in sub-classes return different inconsistent types.\n     */\n    public abstract DescribableList<Publisher,Descriptor<Publisher>> getPublishersList();\n\n    @Override\n    public void addProperty(JobProperty<? super P> jobProp) throws IOException {\n        super.addProperty(jobProp);\n        updateTransientActions();\n    }\n\n    public List<ProminentProjectAction> getProminentActions() {\n        List<Action> a = getActions();\n        List<ProminentProjectAction> pa = new Vector<ProminentProjectAction>();\n        for (Action action : a) {\n            if(action instanceof ProminentProjectAction)\n                pa.add((ProminentProjectAction) action);\n        }\n        return pa;\n    }\n\n    @Override\n    public void doConfigSubmit( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException, FormException {\n        super.doConfigSubmit(req,rsp);\n\n        updateTransientActions();\n\n        Set<AbstractProject> upstream = Collections.emptySet();\n        if(req.getParameter(\"pseudoUpstreamTrigger\")!=null) {\n            upstream = new HashSet<AbstractProject>(Items.fromNameList(getParent(),req.getParameter(\"upstreamProjects\"),AbstractProject.class));\n        }\n\n        // dependency setting might have been changed by the user, so rebuild.\n        Jenkins.getInstance().rebuildDependencyGraph();\n\n        // reflect the submission of the pseudo 'upstream build trriger'.\n        // this needs to be done after we release the lock on 'this',\n        // or otherwise we could dead-lock\n\n        for (AbstractProject<?,?> p : Jenkins.getInstance().getAllItems(AbstractProject.class)) {\n            // Don't consider child projects such as MatrixConfiguration:\n            if (!p.isConfigurable()) continue;\n            boolean isUpstream = upstream.contains(p);\n            synchronized(p) {\n                // does 'p' include us in its BuildTrigger? \n                DescribableList<Publisher,Descriptor<Publisher>> pl = p.getPublishersList();\n                BuildTrigger trigger = pl.get(BuildTrigger.class);\n                List<AbstractProject> newChildProjects = trigger == null ? new ArrayList<AbstractProject>():trigger.getChildProjects(p);\n                if(isUpstream) {\n                    if(!newChildProjects.contains(this))\n                        newChildProjects.add(this);\n                } else {\n                    newChildProjects.remove(this);\n                }\n\n                if(newChildProjects.isEmpty()) {\n                    pl.remove(BuildTrigger.class);\n                } else {\n                    // here, we just need to replace the old one with the new one,\n                    // but there was a regression (we don't know when it started) that put multiple BuildTriggers\n                    // into the list.\n                    // for us not to lose the data, we need to merge them all.\n                    List<BuildTrigger> existingList = pl.getAll(BuildTrigger.class);\n                    BuildTrigger existing;\n                    switch (existingList.size()) {\n                    case 0:\n                        existing = null;\n                        break;\n                    case 1:\n                        existing = existingList.get(0);\n                        break;\n                    default:\n                        pl.removeAll(BuildTrigger.class);\n                        Set<AbstractProject> combinedChildren = new HashSet<AbstractProject>();\n                        for (BuildTrigger bt : existingList)\n                            combinedChildren.addAll(bt.getChildProjects(p));\n                        existing = new BuildTrigger(new ArrayList<AbstractProject>(combinedChildren),existingList.get(0).getThreshold());\n                        pl.add(existing);\n                        break;\n                    }\n\n                    if(existing!=null && existing.hasSame(p,newChildProjects))\n                        continue;   // no need to touch\n                    pl.replace(new BuildTrigger(newChildProjects,\n                        existing==null?Result.SUCCESS:existing.getThreshold()));\n                }\n            }\n        }\n\n        // notify the queue as the project might be now tied to different node\n        Jenkins.getInstance().getQueue().scheduleMaintenance();\n\n        // this is to reflect the upstream build adjustments done above\n        Jenkins.getInstance().rebuildDependencyGraph();\n    }\n\n\t/**\n\t * @deprecated\n\t *    Use {@link #scheduleBuild(Cause)}.  Since 1.283\n\t */\n    public boolean scheduleBuild() {\n    \treturn scheduleBuild(new LegacyCodeCause());\n    }\n    \n\t/**\n\t * @deprecated\n\t *    Use {@link #scheduleBuild(int, Cause)}.  Since 1.283\n\t */\n    public boolean scheduleBuild(int quietPeriod) {\n    \treturn scheduleBuild(quietPeriod, new LegacyCodeCause());\n    }\n    \n    /**\n     * Schedules a build of this project.\n     *\n     * @return\n     *      true if the project is actually added to the queue.\n     *      false if the queue contained it and therefore the add()\n     *      was noop\n     */\n    public boolean scheduleBuild(Cause c) {\n        return scheduleBuild(getQuietPeriod(), c);\n    }\n\n    public boolean scheduleBuild(int quietPeriod, Cause c) {\n        return scheduleBuild(quietPeriod, c, new Action[0]);\n    }\n\n    /**\n     * Schedules a build.\n     *\n     * Important: the actions should be persistable without outside references (e.g. don't store\n     * references to this project). To provide parameters for a parameterized project, add a ParametersAction. If\n     * no ParametersAction is provided for such a project, one will be created with the default parameter values.\n     *\n     * @param quietPeriod the quiet period to observer\n     * @param c the cause for this build which should be recorded\n     * @param actions a list of Actions that will be added to the build\n     * @return whether the build was actually scheduled\n     */\n    public boolean scheduleBuild(int quietPeriod, Cause c, Action... actions) {\n        return scheduleBuild2(quietPeriod,c,actions)!=null;\n    }\n\n    /**\n     * Schedules a build of this project, and returns a {@link Future} object\n     * to wait for the completion of the build.\n     *\n     * @param actions\n     *      For the convenience of the caller, this array can contain null, and those will be silently ignored.\n     */\n    @WithBridgeMethods(Future.class)\n    public QueueTaskFuture<R> scheduleBuild2(int quietPeriod, Cause c, Action... actions) {\n        return scheduleBuild2(quietPeriod,c,Arrays.asList(actions));\n    }\n\n    /**\n     * Schedules a build of this project, and returns a {@link Future} object\n     * to wait for the completion of the build.\n     *\n     * @param actions\n     *      For the convenience of the caller, this collection can contain null, and those will be silently ignored.\n     * @since 1.383\n     */\n    @SuppressWarnings(\"unchecked\")\n    @WithBridgeMethods(Future.class)\n    public QueueTaskFuture<R> scheduleBuild2(int quietPeriod, Cause c, Collection<? extends Action> actions) {\n        if (!isBuildable())\n            return null;\n\n        List<Action> queueActions = new ArrayList<Action>(actions);\n        if (isParameterized() && Util.filter(queueActions, ParametersAction.class).isEmpty()) {\n            queueActions.add(new ParametersAction(getDefaultParametersValues()));\n        }\n\n        if (c != null) {\n            queueActions.add(new CauseAction(c));\n        }\n\n        WaitingItem i = Jenkins.getInstance().getQueue().schedule(this, quietPeriod, queueActions);\n        if(i!=null)\n            return (QueueTaskFuture)i.getFuture();\n        return null;\n    }\n\n    private List<ParameterValue> getDefaultParametersValues() {\n        ParametersDefinitionProperty paramDefProp = getProperty(ParametersDefinitionProperty.class);\n        ArrayList<ParameterValue> defValues = new ArrayList<ParameterValue>();\n        \n        /*\n         * This check is made ONLY if someone will call this method even if isParametrized() is false.\n         */\n        if(paramDefProp == null)\n            return defValues;\n        \n        /* Scan for all parameter with an associated default values */\n        for(ParameterDefinition paramDefinition : paramDefProp.getParameterDefinitions())\n        {\n           ParameterValue defaultValue  = paramDefinition.getDefaultParameterValue();\n            \n            if(defaultValue != null)\n                defValues.add(defaultValue);           \n        }\n        \n        return defValues;\n    }\n\n    /**\n     * Schedules a build, and returns a {@link Future} object\n     * to wait for the completion of the build.\n     *\n     * <p>\n     * Production code shouldn't be using this, but for tests this is very convenient, so this isn't marked\n     * as deprecated.\n     */\n    @SuppressWarnings(\"deprecation\")\n    @WithBridgeMethods(Future.class)\n    public QueueTaskFuture<R> scheduleBuild2(int quietPeriod) {\n        return scheduleBuild2(quietPeriod, new LegacyCodeCause());\n    }\n    \n    /**\n     * Schedules a build of this project, and returns a {@link Future} object\n     * to wait for the completion of the build.\n     */\n    @WithBridgeMethods(Future.class)\n    public QueueTaskFuture<R> scheduleBuild2(int quietPeriod, Cause c) {\n        return scheduleBuild2(quietPeriod, c, new Action[0]);\n    }\n\n    /**\n     * Schedules a polling of this project.\n     */\n    public boolean schedulePolling() {\n        if(isDisabled())    return false;\n        SCMTrigger scmt = getTrigger(SCMTrigger.class);\n        if(scmt==null)      return false;\n        scmt.run();\n        return true;\n    }\n\n    /**\n     * Returns true if the build is in the queue.\n     */\n    @Override\n    public boolean isInQueue() {\n        return Jenkins.getInstance().getQueue().contains(this);\n    }\n\n    @Override\n    public Queue.Item getQueueItem() {\n        return Jenkins.getInstance().getQueue().getItem(this);\n    }\n\n    /**\n     * Gets the JDK that this project is configured with, or null.\n     */\n    public JDK getJDK() {\n        return Jenkins.getInstance().getJDK(jdk);\n    }\n\n    /**\n     * Overwrites the JDK setting.\n     */\n    public void setJDK(JDK jdk) throws IOException {\n        this.jdk = jdk.getName();\n        save();\n    }\n\n    public BuildAuthorizationToken getAuthToken() {\n        return authToken;\n    }\n\n    @Override\n    public RunMap<R> _getRuns() {\n        return builds;\n    }\n\n    @Override\n    public void removeRun(R run) {\n        this.builds.remove(run);\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * More efficient implementation.\n     */\n    @Override\n    public R getBuild(String id) {\n        return builds.getById(id);\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * More efficient implementation.\n     */\n    @Override\n    public R getBuildByNumber(int n) {\n        return builds.getByNumber(n);\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * More efficient implementation.\n     */\n    @Override\n    public R getFirstBuild() {\n        return builds.oldestBuild();\n    }\n\n    @Override\n    public R getLastBuild() {\n        return builds.newestBuild();\n    }\n\n    @Override\n    public R getNearestBuild(int n) {\n        return builds.search(n, Direction.ASC);\n    }\n\n    @Override\n    public R getNearestOldBuild(int n) {\n        return builds.search(n, Direction.DESC);\n    }\n\n    /**\n     * Determines Class&lt;R>.\n     */\n    protected abstract Class<R> getBuildClass();\n\n    // keep track of the previous time we started a build\n    private transient long lastBuildStartTime;\n    \n    /**\n     * Creates a new build of this project for immediate execution.\n     */\n    protected synchronized R newBuild() throws IOException {\n    \t// make sure we don't start two builds in the same second\n    \t// so the build directories will be different too\n    \tlong timeSinceLast = System.currentTimeMillis() - lastBuildStartTime;\n    \tif (timeSinceLast < 1000) {\n    \t\ttry {\n\t\t\t\tThread.sleep(1000 - timeSinceLast);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t}\n    \t}\n    \tlastBuildStartTime = System.currentTimeMillis();\n        try {\n            R lastBuild = getBuildClass().getConstructor(getClass()).newInstance(this);\n            builds.put(lastBuild);\n            return lastBuild;\n        } catch (InstantiationException e) {\n            throw new Error(e);\n        } catch (IllegalAccessException e) {\n            throw new Error(e);\n        } catch (InvocationTargetException e) {\n            throw handleInvocationTargetException(e);\n        } catch (NoSuchMethodException e) {\n            throw new Error(e);\n        }\n    }\n\n    private IOException handleInvocationTargetException(InvocationTargetException e) {\n        Throwable t = e.getTargetException();\n        if(t instanceof Error)  throw (Error)t;\n        if(t instanceof RuntimeException)   throw (RuntimeException)t;\n        if(t instanceof IOException)    return (IOException)t;\n        throw new Error(t);\n    }\n\n    /**\n     * Loads an existing build record from disk.\n     */\n    protected R loadBuild(File dir) throws IOException {\n        try {\n            return getBuildClass().getConstructor(getClass(),File.class).newInstance(this,dir);\n        } catch (InstantiationException e) {\n            throw new Error(e);\n        } catch (IllegalAccessException e) {\n            throw new Error(e);\n        } catch (InvocationTargetException e) {\n            throw handleInvocationTargetException(e);\n        } catch (NoSuchMethodException e) {\n            throw new Error(e);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * <p>\n     * Note that this method returns a read-only view of {@link Action}s.\n     * {@link BuildStep}s and others who want to add a project action\n     * should do so by implementing {@link BuildStep#getProjectActions(AbstractProject)}.\n     *\n     * @see TransientProjectActionFactory\n     */\n    @Override\n    public synchronized List<Action> getActions() {\n        // add all the transient actions, too\n        List<Action> actions = new Vector<Action>(super.getActions());\n        actions.addAll(transientActions);\n        // return the read only list to cause a failure on plugins who try to add an action here\n        return Collections.unmodifiableList(actions);\n    }\n\n    /**\n     * Gets the {@link Node} where this project was last built on.\n     *\n     * @return\n     *      null if no information is available (for example,\n     *      if no build was done yet.)\n     */\n    public Node getLastBuiltOn() {\n        // where was it built on?\n        AbstractBuild b = getLastBuild();\n        if(b==null)\n            return null;\n        else\n            return b.getBuiltOn();\n    }\n\n    public Object getSameNodeConstraint() {\n        return this; // in this way, any member that wants to run with the main guy can nominate the project itself \n    }\n\n    public final Task getOwnerTask() {\n        return this;\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * <p>\n     * A project must be blocked if its own previous build is in progress,\n     * or if the blockBuildWhenUpstreamBuilding option is true and an upstream\n     * project is building, but derived classes can also check other conditions.\n     */\n    public boolean isBuildBlocked() {\n        return getCauseOfBlockage()!=null;\n    }\n\n    public String getWhyBlocked() {\n        CauseOfBlockage cb = getCauseOfBlockage();\n        return cb!=null ? cb.getShortDescription() : null;\n    }\n\n    /**\n     * Blocked because the previous build is already in progress.\n     */\n    public static class BecauseOfBuildInProgress extends CauseOfBlockage {\n        private final AbstractBuild<?,?> build;\n\n        public BecauseOfBuildInProgress(AbstractBuild<?, ?> build) {\n            this.build = build;\n        }\n\n        @Override\n        public String getShortDescription() {\n            Executor e = build.getExecutor();\n            String eta = \"\";\n            if (e != null)\n                eta = Messages.AbstractProject_ETA(e.getEstimatedRemainingTime());\n            int lbn = build.getNumber();\n            return Messages.AbstractProject_BuildInProgress(lbn, eta);\n        }\n    }\n    \n    /**\n     * Because the downstream build is in progress, and we are configured to wait for that.\n     */\n    public static class BecauseOfDownstreamBuildInProgress extends CauseOfBlockage {\n        public final AbstractProject<?,?> up;\n\n        public BecauseOfDownstreamBuildInProgress(AbstractProject<?,?> up) {\n            this.up = up;\n        }\n\n        @Override\n        public String getShortDescription() {\n            return Messages.AbstractProject_DownstreamBuildInProgress(up.getName());\n        }\n    }\n\n    /**\n     * Because the upstream build is in progress, and we are configured to wait for that.\n     */\n    public static class BecauseOfUpstreamBuildInProgress extends CauseOfBlockage {\n        public final AbstractProject<?,?> up;\n\n        public BecauseOfUpstreamBuildInProgress(AbstractProject<?,?> up) {\n            this.up = up;\n        }\n\n        @Override\n        public String getShortDescription() {\n            return Messages.AbstractProject_UpstreamBuildInProgress(up.getName());\n        }\n    }\n\n    public CauseOfBlockage getCauseOfBlockage() {\n        // Block builds until they are done with post-production\n        if (isLogUpdated() && !isConcurrentBuild())\n            return new BecauseOfBuildInProgress(getLastBuild());\n        if (blockBuildWhenDownstreamBuilding()) {\n            AbstractProject<?,?> bup = getBuildingDownstream();\n            if (bup!=null)\n                return new BecauseOfDownstreamBuildInProgress(bup);\n        }\n        if (blockBuildWhenUpstreamBuilding()) {\n            AbstractProject<?,?> bup = getBuildingUpstream();\n            if (bup!=null)\n                return new BecauseOfUpstreamBuildInProgress(bup);\n        }\n        return null;\n    }\n\n    /**\n     * Returns the project if any of the downstream project is either\n     * building, waiting, pending or buildable.\n     * <p>\n     * This means eventually there will be an automatic triggering of\n     * the given project (provided that all builds went smoothly.)\n     */\n    public AbstractProject getBuildingDownstream() {\n        Set<Task> unblockedTasks = Jenkins.getInstance().getQueue().getUnblockedTasks();\n\n        for (AbstractProject tup : getTransitiveDownstreamProjects()) {\n\t\t\tif (tup!=this && (tup.isBuilding() || unblockedTasks.contains(tup)))\n                return tup;\n        }\n        return null;\n    }\n\n    /**\n     * Returns the project if any of the upstream project is either\n     * building or is in the queue.\n     * <p>\n     * This means eventually there will be an automatic triggering of\n     * the given project (provided that all builds went smoothly.)\n     */\n    public AbstractProject getBuildingUpstream() {\n        Set<Task> unblockedTasks = Jenkins.getInstance().getQueue().getUnblockedTasks();\n\n        for (AbstractProject tup : getTransitiveUpstreamProjects()) {\n\t\t\tif (tup!=this && (tup.isBuilding() || unblockedTasks.contains(tup)))\n                return tup;\n        }\n        return null;\n    }\n\n    public List<SubTask> getSubTasks() {\n        List<SubTask> r = new ArrayList<SubTask>();\n        r.add(this);\n        for (SubTaskContributor euc : SubTaskContributor.all())\n            r.addAll(euc.forProject(this));\n        for (JobProperty<? super P> p : properties)\n            r.addAll(p.getSubTasks());\n        return r;\n    }\n\n    public R createExecutable() throws IOException {\n        if(isDisabled())    return null;\n        return newBuild();\n    }\n\n    public void checkAbortPermission() {\n        checkPermission(AbstractProject.ABORT);\n    }\n\n    public boolean hasAbortPermission() {\n        return hasPermission(AbstractProject.ABORT);\n    }\n\n    /**\n     * Gets the {@link Resource} that represents the workspace of this project.\n     * Useful for locking and mutual exclusion control.\n     *\n     * @deprecated as of 1.319\n     *      Projects no longer have a fixed workspace, ands builds will find an available workspace via\n     *      {@link WorkspaceList} for each build (furthermore, that happens after a build is started.)\n     *      So a {@link Resource} representation for a workspace at the project level no longer makes sense.\n     *\n     *      <p>\n     *      If you need to lock a workspace while you do some computation, see the source code of\n     *      {@link #pollSCMChanges(TaskListener)} for how to obtain a lock of a workspace through {@link WorkspaceList}.\n     */\n    public Resource getWorkspaceResource() {\n        return new Resource(getFullDisplayName()+\" workspace\");\n    }\n\n    /**\n     * List of necessary resources to perform the build of this project.\n     */\n    public ResourceList getResourceList() {\n        final Set<ResourceActivity> resourceActivities = getResourceActivities();\n        final List<ResourceList> resourceLists = new ArrayList<ResourceList>(1 + resourceActivities.size());\n        for (ResourceActivity activity : resourceActivities) {\n            if (activity != this && activity != null) {\n                // defensive infinite recursion and null check\n                resourceLists.add(activity.getResourceList());\n            }\n        }\n        return ResourceList.union(resourceLists);\n    }\n\n    /**\n     * Set of child resource activities of the build of this project (override in child projects).\n     * @return The set of child resource activities of the build of this project.\n     */\n    protected Set<ResourceActivity> getResourceActivities() {\n        return Collections.emptySet();\n    }\n\n    public boolean checkout(AbstractBuild build, Launcher launcher, BuildListener listener, File changelogFile) throws IOException, InterruptedException {\n        SCM scm = getScm();\n        if(scm==null)\n            return true;    // no SCM\n\n        FilePath workspace = build.getWorkspace();\n        workspace.mkdirs();\n        \n        boolean r = scm.checkout(build, launcher, workspace, listener, changelogFile);\n        if (r) {\n            // Only calcRevisionsFromBuild if checkout was successful. Note that modern SCM implementations\n            // won't reach this line anyway, as they throw AbortExceptions on checkout failure.\n            calcPollingBaseline(build, launcher, listener);\n        }\n        return r;\n    }\n\n    /**\n     * Pushes the baseline up to the newly checked out revision.\n     */\n    private void calcPollingBaseline(AbstractBuild build, Launcher launcher, TaskListener listener) throws IOException, InterruptedException {\n        SCMRevisionState baseline = build.getAction(SCMRevisionState.class);\n        if (baseline==null) {\n            try {\n                baseline = getScm()._calcRevisionsFromBuild(build, launcher, listener);\n            } catch (AbstractMethodError e) {\n                baseline = SCMRevisionState.NONE; // pre-1.345 SCM implementations, which doesn't use the baseline in polling\n            }\n            if (baseline!=null)\n                build.addAction(baseline);\n        }\n        pollingBaseline = baseline;\n    }\n\n    /**\n     * Checks if there's any update in SCM, and returns true if any is found.\n     *\n     * @deprecated as of 1.346\n     *      Use {@link #poll(TaskListener)} instead.\n     */\n    public boolean pollSCMChanges( TaskListener listener ) {\n        return poll(listener).hasChanges();\n    }\n\n    /**\n     * Checks if there's any update in SCM, and returns true if any is found.\n     *\n     * <p>\n     * The implementation is responsible for ensuring mutual exclusion between polling and builds\n     * if necessary.\n     *\n     * @since 1.345\n     */\n    public PollingResult poll( TaskListener listener ) {\n        SCM scm = getScm();\n        if (scm==null) {\n            listener.getLogger().println(Messages.AbstractProject_NoSCM());\n            return NO_CHANGES;\n        }\n        if (!isBuildable()) {\n            listener.getLogger().println(Messages.AbstractProject_Disabled());\n            return NO_CHANGES;\n        }\n\n        R lb = getLastBuild();\n        if (lb==null) {\n            listener.getLogger().println(Messages.AbstractProject_NoBuilds());\n            return isInQueue() ? NO_CHANGES : BUILD_NOW;\n        }\n\n        if (pollingBaseline==null) {\n            R success = getLastSuccessfulBuild(); // if we have a persisted baseline, we'll find it by this\n            for (R r=lb; r!=null; r=r.getPreviousBuild()) {\n                SCMRevisionState s = r.getAction(SCMRevisionState.class);\n                if (s!=null) {\n                    pollingBaseline = s;\n                    break;\n                }\n                if (r==success) break;  // searched far enough\n            }\n            // NOTE-NO-BASELINE:\n            // if we don't have baseline yet, it means the data is built by old Hudson that doesn't set the baseline\n            // as action, so we need to compute it. This happens later.\n        }\n\n        try {\n            SCMPollListener.fireBeforePolling(this, listener);\n            PollingResult r = _poll(listener, scm, lb);\n            SCMPollListener.firePollingSuccess(this,listener, r);\n            return r;\n        } catch (AbortException e) {\n            listener.getLogger().println(e.getMessage());\n            listener.fatalError(Messages.AbstractProject_Aborted());\n            LOGGER.log(Level.FINE, \"Polling \"+this+\" aborted\",e);\n            SCMPollListener.firePollingFailed(this, listener,e);\n            return NO_CHANGES;\n        } catch (IOException e) {\n            e.printStackTrace(listener.fatalError(e.getMessage()));\n            SCMPollListener.firePollingFailed(this, listener,e);\n            return NO_CHANGES;\n        } catch (InterruptedException e) {\n            e.printStackTrace(listener.fatalError(Messages.AbstractProject_PollingABorted()));\n            SCMPollListener.firePollingFailed(this, listener,e);\n            return NO_CHANGES;\n        } catch (RuntimeException e) {\n            SCMPollListener.firePollingFailed(this, listener,e);\n            throw e;\n        } catch (Error e) {\n            SCMPollListener.firePollingFailed(this, listener,e);\n            throw e;\n        }\n    }\n\n    /**\n     * {@link #poll(TaskListener)} method without the try/catch block that does listener notification and .\n     */\n    private PollingResult _poll(TaskListener listener, SCM scm, R lb) throws IOException, InterruptedException {\n        if (scm.requiresWorkspaceForPolling()) {\n            // lock the workspace of the last build\n            FilePath ws=lb.getWorkspace();\n\n            WorkspaceOfflineReason workspaceOfflineReason = workspaceOffline( lb );\n            if ( workspaceOfflineReason != null ) {\n                // workspace offline\n                for (WorkspaceBrowser browser : Jenkins.getInstance().getExtensionList(WorkspaceBrowser.class)) {\n                    ws = browser.getWorkspace(this);\n                    if (ws != null) {\n                        return pollWithWorkspace(listener, scm, lb, ws, browser.getWorkspaceList());\n                    }\n                }\n\n                // build now, or nothing will ever be built\n                Label label = getAssignedLabel();\n                if (label != null && label.isSelfLabel()) {\n                    // if the build is fixed on a node, then attempting a build will do us\n                    // no good. We should just wait for the slave to come back.\n                    listener.getLogger().print(Messages.AbstractProject_NoWorkspace());\n                    listener.getLogger().println( \" (\" + workspaceOfflineReason.name() + \")\");\n                    return NO_CHANGES;\n                }\n                listener.getLogger().println( ws==null\n                    ? Messages.AbstractProject_WorkspaceOffline()\n                    : Messages.AbstractProject_NoWorkspace());\n                if (isInQueue()) {\n                    listener.getLogger().println(Messages.AbstractProject_AwaitingBuildForWorkspace());\n                    return NO_CHANGES;\n                } else {\n                    listener.getLogger().print(Messages.AbstractProject_NewBuildForWorkspace());\n                    listener.getLogger().println( \" (\" + workspaceOfflineReason.name() + \")\");\n                    return BUILD_NOW;\n                }\n            } else {\n                WorkspaceList l = lb.getBuiltOn().toComputer().getWorkspaceList();\n                return pollWithWorkspace(listener, scm, lb, ws, l);\n\n            }\n        } else {\n            // polling without workspace\n            LOGGER.fine(\"Polling SCM changes of \" + getName());\n\n            if (pollingBaseline==null) // see NOTE-NO-BASELINE above\n                calcPollingBaseline(lb,null,listener);\n            PollingResult r = scm.poll(this, null, null, listener, pollingBaseline);\n            pollingBaseline = r.remote;\n            return r;\n        }\n    }\n\n    private PollingResult pollWithWorkspace(TaskListener listener, SCM scm, R lb, FilePath ws, WorkspaceList l) throws InterruptedException, IOException {\n        // if doing non-concurrent build, acquire a workspace in a way that causes builds to block for this workspace.\n        // this prevents multiple workspaces of the same job --- the behavior of Hudson < 1.319.\n        //\n        // OTOH, if a concurrent build is chosen, the user is willing to create a multiple workspace,\n        // so better throughput is achieved over time (modulo the initial cost of creating that many workspaces)\n        // by having multiple workspaces\n        WorkspaceList.Lease lease = l.acquire(ws, !concurrentBuild);\n        Launcher launcher = ws.createLauncher(listener).decorateByEnv(getEnvironment(lb.getBuiltOn(),listener));\n        try {\n            LOGGER.fine(\"Polling SCM changes of \" + getName());\n            if (pollingBaseline==null) // see NOTE-NO-BASELINE above\n                calcPollingBaseline(lb,launcher,listener);\n            PollingResult r = scm.poll(this, launcher, ws, listener, pollingBaseline);\n            pollingBaseline = r.remote;\n            return r;\n        } finally {\n            lease.release();\n        }\n    }\n\n    enum WorkspaceOfflineReason {\n        nonexisting_workspace,\n        builton_node_gone,\n        builton_node_no_executors\n    }\n\n    private WorkspaceOfflineReason workspaceOffline(R build) throws IOException, InterruptedException {\n        FilePath ws = build.getWorkspace();\n        if (ws==null || !ws.exists()) {\n            return WorkspaceOfflineReason.nonexisting_workspace;\n        }\n        \n        Node builtOn = build.getBuiltOn();\n        if (builtOn == null) { // node built-on doesn't exist anymore\n            return WorkspaceOfflineReason.builton_node_gone;\n        }\n        \n        if (builtOn.toComputer() == null) { // node still exists, but has 0 executors - o.s.l.t.\n            return WorkspaceOfflineReason.builton_node_no_executors;\n        }\n\n        return null;\n    }\n\n    /**\n     * Returns true if this user has made a commit to this project.\n     *\n     * @since 1.191\n     */\n    public boolean hasParticipant(User user) {\n        for( R build = getLastBuild(); build!=null; build=build.getPreviousBuild())\n            if(build.hasParticipant(user))\n                return true;\n        return false;\n    }\n\n    @Exported\n    public SCM getScm() {\n        return scm;\n    }\n\n    public void setScm(SCM scm) throws IOException {\n        this.scm = scm;\n        save();\n    }\n\n    /**\n     * Adds a new {@link Trigger} to this {@link Project} if not active yet.\n     */\n    public void addTrigger(Trigger<?> trigger) throws IOException {\n        addToList(trigger,triggers());\n    }\n\n    public void removeTrigger(TriggerDescriptor trigger) throws IOException {\n        removeFromList(trigger,triggers());\n    }\n\n    protected final synchronized <T extends Describable<T>>\n    void addToList( T item, List<T> collection ) throws IOException {\n        for( int i=0; i<collection.size(); i++ ) {\n            if(collection.get(i).getDescriptor()==item.getDescriptor()) {\n                // replace\n                collection.set(i,item);\n                save();\n                return;\n            }\n        }\n        // add\n        collection.add(item);\n        save();\n        updateTransientActions();\n    }\n\n    protected final synchronized <T extends Describable<T>>\n    void removeFromList(Descriptor<T> item, List<T> collection) throws IOException {\n        for( int i=0; i< collection.size(); i++ ) {\n            if(collection.get(i).getDescriptor()==item) {\n                // found it\n                collection.remove(i);\n                save();\n                updateTransientActions();\n                return;\n            }\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public synchronized Map<TriggerDescriptor,Trigger> getTriggers() {\n        return (Map)Descriptor.toMap(triggers());\n    }\n\n    /**\n     * Gets the specific trigger, or null if the propert is not configured for this job.\n     */\n    public <T extends Trigger> T getTrigger(Class<T> clazz) {\n        for (Trigger p : triggers()) {\n            if(clazz.isInstance(p))\n                return clazz.cast(p);\n        }\n        return null;\n    }\n\n//\n//\n// fingerprint related\n//\n//\n    /**\n     * True if the builds of this project produces {@link Fingerprint} records.\n     */\n    public abstract boolean isFingerprintConfigured();\n\n    /**\n     * Gets the other {@link AbstractProject}s that should be built\n     * when a build of this project is completed.\n     */\n    @Exported\n    public final List<AbstractProject> getDownstreamProjects() {\n        return Jenkins.getInstance().getDependencyGraph().getDownstream(this);\n    }\n\n    @Exported\n    public final List<AbstractProject> getUpstreamProjects() {\n        return Jenkins.getInstance().getDependencyGraph().getUpstream(this);\n    }\n\n    /**\n     * Returns only those upstream projects that defines {@link BuildTrigger} to this project.\n     * This is a subset of {@link #getUpstreamProjects()}\n     *\n     * @return A List of upstream projects that has a {@link BuildTrigger} to this project.\n     */\n    public final List<AbstractProject> getBuildTriggerUpstreamProjects() {\n        ArrayList<AbstractProject> result = new ArrayList<AbstractProject>();\n        for (AbstractProject<?,?> ap : getUpstreamProjects()) {\n            BuildTrigger buildTrigger = ap.getPublishersList().get(BuildTrigger.class);\n            if (buildTrigger != null)\n                if (buildTrigger.getChildProjects(ap).contains(this))\n                    result.add(ap);\n        }        \n        return result;\n    }    \n    \n    /**\n     * Gets all the upstream projects including transitive upstream projects.\n     *\n     * @since 1.138\n     */\n    public final Set<AbstractProject> getTransitiveUpstreamProjects() {\n        return Jenkins.getInstance().getDependencyGraph().getTransitiveUpstream(this);\n    }\n\n    /**\n     * Gets all the downstream projects including transitive downstream projects.\n     *\n     * @since 1.138\n     */\n    public final Set<AbstractProject> getTransitiveDownstreamProjects() {\n        return Jenkins.getInstance().getDependencyGraph().getTransitiveDownstream(this);\n    }\n\n    /**\n     * Gets the dependency relationship map between this project (as the source)\n     * and that project (as the sink.)\n     *\n     * @return\n     *      can be empty but not null. build number of this project to the build\n     *      numbers of that project.\n     */\n    public SortedMap<Integer, RangeSet> getRelationship(AbstractProject that) {\n        TreeMap<Integer,RangeSet> r = new TreeMap<Integer,RangeSet>(REVERSE_INTEGER_COMPARATOR);\n\n        checkAndRecord(that, r, this.getBuilds());\n        // checkAndRecord(that, r, that.getBuilds());\n\n        return r;\n    }\n\n    /**\n     * Helper method for getDownstreamRelationship.\n     *\n     * For each given build, find the build number range of the given project and put that into the map.\n     */\n    private void checkAndRecord(AbstractProject that, TreeMap<Integer, RangeSet> r, Collection<R> builds) {\n        for (R build : builds) {\n            RangeSet rs = build.getDownstreamRelationship(that);\n            if(rs==null || rs.isEmpty())\n                continue;\n\n            int n = build.getNumber();\n\n            RangeSet value = r.get(n);\n            if(value==null)\n                r.put(n,rs);\n            else\n                value.add(rs);\n        }\n    }\n\n    /**\n     * Builds the dependency graph.\n     * @see DependencyGraph\n     */\n    protected abstract void buildDependencyGraph(DependencyGraph graph);\n\n    @Override\n    protected SearchIndexBuilder makeSearchIndex() {\n        SearchIndexBuilder sib = super.makeSearchIndex();\n        if(isBuildable() && hasPermission(Jenkins.ADMINISTER))\n            sib.add(\"build\",\"build\");\n        return sib;\n    }\n\n    @Override\n    protected HistoryWidget createHistoryWidget() {\n        return new BuildHistoryWidget<R>(this,builds,HISTORY_ADAPTER);\n    }\n    \n    public boolean isParameterized() {\n        return getProperty(ParametersDefinitionProperty.class) != null;\n    }\n\n//\n//\n// actions\n//\n//\n    /**\n     * Schedules a new build command.\n     */\n    public void doBuild( StaplerRequest req, StaplerResponse rsp, @QueryParameter TimeDuration delay ) throws IOException, ServletException {\n        if (delay==null)    delay=new TimeDuration(getQuietPeriod());\n\n        // if a build is parameterized, let that take over\n        ParametersDefinitionProperty pp = getProperty(ParametersDefinitionProperty.class);\n        if (pp != null && !req.getMethod().equals(\"POST\")) {\n            // show the parameter entry form.\n            req.getView(pp, \"index.jelly\").forward(req, rsp);\n            return;\n        }\n\n        BuildAuthorizationToken.checkPermission(this, authToken, req, rsp);\n\n        if (pp != null) {\n            pp._doBuild(req,rsp,delay);\n            return;\n        }\n\n        if (!isBuildable())\n            throw HttpResponses.error(SC_INTERNAL_SERVER_ERROR,new IOException(getFullName()+\" is not buildable\"));\n\n        Jenkins.getInstance().getQueue().schedule(this, (int)delay.getTime(), getBuildCause(req));\n        rsp.sendRedirect(\".\");\n    }\n\n    /**\n     * Computes the build cause, using RemoteCause or UserCause as appropriate.\n     */\n    /*package*/ CauseAction getBuildCause(StaplerRequest req) {\n        Cause cause;\n        if (authToken != null && authToken.getToken() != null && req.getParameter(\"token\") != null) {\n            // Optional additional cause text when starting via token\n            String causeText = req.getParameter(\"cause\");\n            cause = new RemoteCause(req.getRemoteAddr(), causeText);\n        } else {\n            cause = new UserIdCause();\n        }\n        return new CauseAction(cause);\n    }\n\n    /**\n     * Computes the delay by taking the default value and the override in the request parameter into the account.\n     *\n     * @deprecated as of 1.488\n     *      Inject {@link TimeDuration}.\n     */\n    public int getDelay(StaplerRequest req) throws ServletException {\n        String delay = req.getParameter(\"delay\");\n        if (delay==null)    return getQuietPeriod();\n\n        try {\n            // TODO: more unit handling\n            if(delay.endsWith(\"sec\"))   delay=delay.substring(0,delay.length()-3);\n            if(delay.endsWith(\"secs\"))  delay=delay.substring(0,delay.length()-4);\n            return Integer.parseInt(delay);\n        } catch (NumberFormatException e) {\n            throw new ServletException(\"Invalid delay parameter value: \"+delay);\n        }\n    }\n\n    /**\n     * Supports build trigger with parameters via an HTTP GET or POST.\n     * Currently only String parameters are supported.\n     */\n    public void doBuildWithParameters(StaplerRequest req, StaplerResponse rsp, @QueryParameter TimeDuration delay) throws IOException, ServletException {\n        BuildAuthorizationToken.checkPermission(this, authToken, req, rsp);\n\n        ParametersDefinitionProperty pp = getProperty(ParametersDefinitionProperty.class);\n        if (pp != null) {\n            pp.buildWithParameters(req,rsp,delay);\n        } else {\n        \tthrow new IllegalStateException(\"This build is not parameterized!\");\n        }\n    \t\n    }\n\n    /**\n     * Schedules a new SCM polling command.\n     */\n    public void doPolling( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {\n        BuildAuthorizationToken.checkPermission(this, authToken, req, rsp);\n        schedulePolling();\n        rsp.sendRedirect(\".\");\n    }\n\n    /**\n     * Cancels a scheduled build.\n     */\n    @RequirePOST\n    public void doCancelQueue( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {\n        checkPermission(ABORT);\n\n        Jenkins.getInstance().getQueue().cancel(this);\n        rsp.forwardToPreviousPage(req);\n    }\n\n    /**\n     * Deletes this project.\n     */\n    @Override\n    @RequirePOST\n    public void doDoDelete(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException, InterruptedException {\n        delete();\n        if (req == null || rsp == null)\n            return;\n        View view = req.findAncestorObject(View.class);\n        if (view == null)\n            rsp.sendRedirect2(req.getContextPath() + '/' + getParent().getUrl());\n        else \n            rsp.sendRedirect2(req.getContextPath() + '/' + view.getUrl());\n    }\n    \n    @Override\n    protected void submit(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException, FormException {\n        super.submit(req,rsp);\n        JSONObject json = req.getSubmittedForm();\n\n        makeDisabled(req.getParameter(\"disable\")!=null);\n\n        jdk = req.getParameter(\"jdk\");\n        if(req.getParameter(\"hasCustomQuietPeriod\")!=null) {\n            quietPeriod = Integer.parseInt(req.getParameter(\"quiet_period\"));\n        } else {\n            quietPeriod = null;\n        }\n        if(req.getParameter(\"hasCustomScmCheckoutRetryCount\")!=null) {\n            scmCheckoutRetryCount = Integer.parseInt(req.getParameter(\"scmCheckoutRetryCount\"));\n        } else {\n            scmCheckoutRetryCount = null;\n        }\n        blockBuildWhenDownstreamBuilding = req.getParameter(\"blockBuildWhenDownstreamBuilding\")!=null;\n        blockBuildWhenUpstreamBuilding = req.getParameter(\"blockBuildWhenUpstreamBuilding\")!=null;\n\n        if(req.hasParameter(\"customWorkspace\")) {\n            customWorkspace = Util.fixEmptyAndTrim(req.getParameter(\"customWorkspace.directory\"));\n        } else {\n            customWorkspace = null;\n        }\n\n        if (json.has(\"scmCheckoutStrategy\"))\n            scmCheckoutStrategy = req.bindJSON(SCMCheckoutStrategy.class,\n                json.getJSONObject(\"scmCheckoutStrategy\"));\n        else\n            scmCheckoutStrategy = null;\n\n        \n        if(req.getParameter(\"hasSlaveAffinity\")!=null) {\n            assignedNode = Util.fixEmptyAndTrim(req.getParameter(\"_.assignedLabelString\"));\n        } else {\n            assignedNode = null;\n        }\n        canRoam = assignedNode==null;\n\n        concurrentBuild = req.getSubmittedForm().has(\"concurrentBuild\");\n\n        authToken = BuildAuthorizationToken.create(req);\n\n        setScm(SCMS.parseSCM(req,this));\n\n        for (Trigger t : triggers())\n            t.stop();\n        triggers = buildDescribable(req, Trigger.for_(this));\n        for (Trigger t : triggers)\n            t.start(this,true);\n\n        for (Publisher _t : Descriptor.newInstancesFromHeteroList(req, json, \"publisher\", Jenkins.getInstance().getExtensionList(BuildTrigger.DescriptorImpl.class))) {\n            BuildTrigger t = (BuildTrigger) _t;\n            for (AbstractProject downstream : t.getChildProjects(this)) {\n                downstream.checkPermission(BUILD);\n            }\n        }\n    }\n\n    /**\n     * @deprecated\n     *      As of 1.261. Use {@link #buildDescribable(StaplerRequest, List)} instead.\n     */\n    protected final <T extends Describable<T>> List<T> buildDescribable(StaplerRequest req, List<? extends Descriptor<T>> descriptors, String prefix) throws FormException, ServletException {\n        return buildDescribable(req,descriptors);\n    }\n\n    protected final <T extends Describable<T>> List<T> buildDescribable(StaplerRequest req, List<? extends Descriptor<T>> descriptors)\n        throws FormException, ServletException {\n\n        JSONObject data = req.getSubmittedForm();\n        List<T> r = new Vector<T>();\n        for (Descriptor<T> d : descriptors) {\n            String safeName = d.getJsonSafeClassName();\n            if (req.getParameter(safeName) != null) {\n                T instance = d.newInstance(req, data.getJSONObject(safeName));\n                r.add(instance);\n            }\n        }\n        return r;\n    }\n\n    /**\n     * Serves the workspace files.\n     */\n    public DirectoryBrowserSupport doWs( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException, InterruptedException {\n        checkPermission(AbstractProject.WORKSPACE);\n        FilePath ws = getSomeWorkspace();\n        if ((ws == null) || (!ws.exists())) {\n            // if there's no workspace, report a nice error message\n            // Would be good if when asked for *plain*, do something else!\n            // (E.g. return 404, or send empty doc.)\n            // Not critical; client can just check if content type is not text/plain,\n            // which also serves to detect old versions of Hudson.\n            req.getView(this,\"noWorkspace.jelly\").forward(req,rsp);\n            return null;\n        } else {\n            return new DirectoryBrowserSupport(this, ws, getDisplayName()+\" workspace\", \"folder.png\", true);\n        }\n    }\n\n    /**\n     * Wipes out the workspace.\n     */\n    public HttpResponse doDoWipeOutWorkspace() throws IOException, ServletException, InterruptedException {\n        checkPermission(Functions.isWipeOutPermissionEnabled() ? WIPEOUT : BUILD);\n        R b = getSomeBuildWithWorkspace();\n        FilePath ws = b!=null ? b.getWorkspace() : null;\n        if (ws!=null && getScm().processWorkspaceBeforeDeletion(this, ws, b.getBuiltOn())) {\n            ws.deleteRecursive();\n            for (WorkspaceListener wl : WorkspaceListener.all()) {\n                wl.afterDelete(this);\n            }\n            return new HttpRedirect(\".\");\n        } else {\n            // If we get here, that means the SCM blocked the workspace deletion.\n            return new ForwardToView(this,\"wipeOutWorkspaceBlocked.jelly\");\n        }\n    }\n\n    @CLIMethod(name=\"disable-job\")\n    @RequirePOST\n    public HttpResponse doDisable() throws IOException, ServletException {\n        checkPermission(CONFIGURE);\n        makeDisabled(true);\n        return new HttpRedirect(\".\");\n    }\n\n    @CLIMethod(name=\"enable-job\")\n    @RequirePOST\n    public HttpResponse doEnable() throws IOException, ServletException {\n        checkPermission(CONFIGURE);\n        makeDisabled(false);\n        return new HttpRedirect(\".\");\n    }\n\n    /**\n     * RSS feed for changes in this project.\n     */\n    public void doRssChangelog(  StaplerRequest req, StaplerResponse rsp  ) throws IOException, ServletException {\n        class FeedItem {\n            ChangeLogSet.Entry e;\n            int idx;\n\n            public FeedItem(Entry e, int idx) {\n                this.e = e;\n                this.idx = idx;\n            }\n\n            AbstractBuild<?,?> getBuild() {\n                return e.getParent().build;\n            }\n        }\n\n        List<FeedItem> entries = new ArrayList<FeedItem>();\n\n        for(R r=getLastBuild(); r!=null; r=r.getPreviousBuild()) {\n            int idx=0;\n            for( ChangeLogSet.Entry e : r.getChangeSet())\n                entries.add(new FeedItem(e,idx++));\n        }\n\n        RSS.forwardToRss(\n            getDisplayName()+' '+getScm().getDescriptor().getDisplayName()+\" changes\",\n            getUrl()+\"changes\",\n            entries, new FeedAdapter<FeedItem>() {\n                public String getEntryTitle(FeedItem item) {\n                    return \"#\"+item.getBuild().number+' '+item.e.getMsg()+\" (\"+item.e.getAuthor()+\")\";\n                }\n\n                public String getEntryUrl(FeedItem item) {\n                    return item.getBuild().getUrl()+\"changes#detail\"+item.idx;\n                }\n\n                public String getEntryID(FeedItem item) {\n                    return getEntryUrl(item);\n                }\n\n                public String getEntryDescription(FeedItem item) {\n                    StringBuilder buf = new StringBuilder();\n                    for(String path : item.e.getAffectedPaths())\n                        buf.append(path).append('\\n');\n                    return buf.toString();\n                }\n\n                public Calendar getEntryTimestamp(FeedItem item) {\n                    return item.getBuild().getTimestamp();\n                }\n\n                public String getEntryAuthor(FeedItem entry) {\n                    return JenkinsLocationConfiguration.get().getAdminAddress();\n                }\n            },\n            req, rsp );\n    }\n\n    /**\n     * {@link AbstractProject} subtypes should implement this base class as a descriptor.\n     *\n     * @since 1.294\n     */\n    public static abstract class AbstractProjectDescriptor extends TopLevelItemDescriptor {\n        /**\n         * {@link AbstractProject} subtypes can override this method to veto some {@link Descriptor}s\n         * from showing up on their configuration screen. This is often useful when you are building\n         * a workflow/company specific project type, where you want to limit the number of choices\n         * given to the users.\n         *\n         * <p>\n         * Some {@link Descriptor}s define their own schemes for controlling applicability\n         * (such as {@link BuildStepDescriptor#isApplicable(Class)}),\n         * This method works like AND in conjunction with them;\n         * Both this method and that method need to return true in order for a given {@link Descriptor}\n         * to show up for the given {@link Project}.\n         *\n         * <p>\n         * The default implementation returns true for everything.\n         *\n         * @see BuildStepDescriptor#isApplicable(Class) \n         * @see BuildWrapperDescriptor#isApplicable(AbstractProject) \n         * @see TriggerDescriptor#isApplicable(Item)\n         */\n        @Override\n        public boolean isApplicable(Descriptor descriptor) {\n            return true;\n        }\n\n        public FormValidation doCheckAssignedLabelString(@QueryParameter String value) {\n            if (Util.fixEmpty(value)==null)\n                return FormValidation.ok(); // nothing typed yet\n            try {\n                Label.parseExpression(value);\n            } catch (ANTLRException e) {\n                return FormValidation.error(e,\n                        Messages.AbstractProject_AssignedLabelString_InvalidBooleanExpression(e.getMessage()));\n            }\n            Label l = Jenkins.getInstance().getLabel(value);\n            if (l.isEmpty()) {\n                for (LabelAtom a : l.listAtoms()) {\n                    if (a.isEmpty()) {\n                        LabelAtom nearest = LabelAtom.findNearest(a.getName());\n                        return FormValidation.warning(Messages.AbstractProject_AssignedLabelString_NoMatch_DidYouMean(a.getName(),nearest.getDisplayName()));\n                    }\n                }\n                return FormValidation.warning(Messages.AbstractProject_AssignedLabelString_NoMatch());\n            }\n            return FormValidation.ok();\n        }\n\n        public FormValidation doCheckCustomWorkspace(@QueryParameter(value=\"customWorkspace.directory\") String customWorkspace){\n        \tif(Util.fixEmptyAndTrim(customWorkspace)==null)\n        \t\treturn FormValidation.error(Messages.AbstractProject_CustomWorkspaceEmpty());\n        \telse\n        \t\treturn FormValidation.ok();\n        }\n        \n        public AutoCompletionCandidates doAutoCompleteUpstreamProjects(@QueryParameter String value) {\n            AutoCompletionCandidates candidates = new AutoCompletionCandidates();\n            List<Job> jobs = Jenkins.getInstance().getItems(Job.class);\n            for (Job job: jobs) {\n                if (job.getFullName().startsWith(value)) {\n                    if (job.hasPermission(Item.READ)) {\n                        candidates.add(job.getFullName());\n                    }\n                }\n            }\n            return candidates;\n        }\n\n        public AutoCompletionCandidates doAutoCompleteAssignedLabelString(@QueryParameter String value) {\n            AutoCompletionCandidates c = new AutoCompletionCandidates();\n            Set<Label> labels = Jenkins.getInstance().getLabels();\n            List<String> queries = new AutoCompleteSeeder(value).getSeeds();\n\n            for (String term : queries) {\n                for (Label l : labels) {\n                    if (l.getName().startsWith(term)) {\n                        c.add(l.getName());\n                    }\n                }\n            }\n            return c;\n        }\n\n        public List<SCMCheckoutStrategyDescriptor> getApplicableSCMCheckoutStrategyDescriptors(AbstractProject p) {\n            return SCMCheckoutStrategyDescriptor._for(p);\n        }\n\n        /**\n        * Utility class for taking the current input value and computing a list\n        * of potential terms to match against the list of defined labels.\n         */\n        static class AutoCompleteSeeder {\n            private String source;\n\n            AutoCompleteSeeder(String source) {\n                this.source = source;\n            }\n\n            List<String> getSeeds() {\n                ArrayList<String> terms = new ArrayList<String>();\n                boolean trailingQuote = source.endsWith(\"\\\"\");\n                boolean leadingQuote = source.startsWith(\"\\\"\");\n                boolean trailingSpace = source.endsWith(\" \");\n\n                if (trailingQuote || (trailingSpace && !leadingQuote)) {\n                    terms.add(\"\");\n                } else {\n                    if (leadingQuote) {\n                        int quote = source.lastIndexOf('\"');\n                        if (quote == 0) {\n                            terms.add(source.substring(1));\n                        } else {\n                            terms.add(\"\");\n                        }\n                    } else {\n                        int space = source.lastIndexOf(' ');\n                        if (space > -1) {\n                            terms.add(source.substring(space+1));\n                        } else {\n                            terms.add(source);\n                        }\n                    }\n                }\n\n                return terms;\n            }\n        }\n    }\n\n    /**\n     * Finds a {@link AbstractProject} that has the name closest to the given name.\n     */\n    public static AbstractProject findNearest(String name) {\n        return findNearest(name,Hudson.getInstance());\n    }\n\n    /**\n     * Finds a {@link AbstractProject} whose name (when referenced from the specified context) is closest to the given name.\n     *\n     * @since 1.419\n     */\n    public static AbstractProject findNearest(String name, ItemGroup context) {\n        List<AbstractProject> projects = Hudson.getInstance().getAllItems(AbstractProject.class);\n        String[] names = new String[projects.size()];\n        for( int i=0; i<projects.size(); i++ )\n            names[i] = projects.get(i).getRelativeNameFrom(context);\n\n        String nearest = EditDistance.findNearest(name, names);\n        return (AbstractProject)Jenkins.getInstance().getItem(nearest,context);\n    }\n\n    private static final Comparator<Integer> REVERSE_INTEGER_COMPARATOR = new Comparator<Integer>() {\n        public int compare(Integer o1, Integer o2) {\n            return o2-o1;\n        }\n    };\n\n    private static final Logger LOGGER = Logger.getLogger(AbstractProject.class.getName());\n\n    /**\n     * Permission to abort a build\n     */\n    public static final Permission ABORT = CANCEL;\n\n    /**\n     * Replaceable \"Build Now\" text.\n     */\n    public static final Message<AbstractProject> BUILD_NOW_TEXT = new Message<AbstractProject>();\n\n    /**\n     * Used for CLI binding.\n     */\n    @CLIResolver\n    public static AbstractProject resolveForCLI(\n            @Argument(required=true,metaVar=\"NAME\",usage=\"Job name\") String name) throws CmdLineException {\n        AbstractProject item = Jenkins.getInstance().getItemByFullName(name, AbstractProject.class);\n        if (item==null)\n            throw new CmdLineException(null,Messages.AbstractItem_NoSuchJobExists(name,AbstractProject.findNearest(name).getFullName()));\n        return item;\n    }\n\n    public String getCustomWorkspace() {\n        return customWorkspace;\n    }\n\n    /**\n     * User-specified workspace directory, or null if it's up to Jenkins.\n     *\n     * <p>\n     * Normally a project uses the workspace location assigned by its parent container,\n     * but sometimes people have builds that have hard-coded paths.\n     *\n     * <p>\n     * This is not {@link File} because it may have to hold a path representation on another OS.\n     *\n     * <p>\n     * If this path is relative, it's resolved against {@link Node#getRootPath()} on the node where this workspace\n     * is prepared. \n     *\n     * @since 1.410\n     */\n    public void setCustomWorkspace(String customWorkspace) throws IOException {\n        this.customWorkspace= Util.fixEmptyAndTrim(customWorkspace);\n        save();\n    }\n    \n}\n", "/*\n * The MIT License\n * \n * Copyright (c) 2004-2011, Sun Microsystems, Inc., Kohsuke Kawaguchi\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage hudson.model;\n\nimport hudson.DescriptorExtensionList;\nimport hudson.PluginWrapper;\nimport hudson.RelativePath;\nimport hudson.XmlFile;\nimport hudson.BulkChange;\nimport hudson.Util;\nimport hudson.model.listeners.SaveableListener;\nimport hudson.util.FormApply;\nimport hudson.util.ReflectionUtils;\nimport hudson.util.ReflectionUtils.Parameter;\nimport hudson.views.ListViewColumn;\nimport jenkins.model.Jenkins;\nimport net.sf.json.JSONArray;\nimport net.sf.json.JSONObject;\nimport org.kohsuke.stapler.*;\nimport org.kohsuke.stapler.jelly.JellyCompatibleFacet;\nimport org.kohsuke.stapler.lang.Klass;\nimport org.springframework.util.StringUtils;\nimport org.jvnet.tiger_types.Types;\nimport org.apache.commons.io.IOUtils;\n\nimport static hudson.Functions.*;\nimport static hudson.util.QuotedStringTokenizer.*;\nimport static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\nimport javax.servlet.ServletException;\nimport javax.servlet.RequestDispatcher;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.HashMap;\nimport java.util.Locale;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.ParameterizedType;\nimport java.beans.Introspector;\nimport javax.annotation.CheckForNull;\nimport javax.annotation.Nonnull;\n\n/**\n * Metadata about a configurable instance.\n *\n * <p>\n * {@link Descriptor} is an object that has metadata about a {@link Describable}\n * object, and also serves as a factory (in a way this relationship is similar\n * to {@link Object}/{@link Class} relationship.\n *\n * A {@link Descriptor}/{@link Describable}\n * combination is used throughout in Hudson to implement a\n * configuration/extensibility mechanism.\n *\n * <p>\n * Take the list view support as an example, which is implemented\n * in {@link ListView} class. Whenever a new view is created, a new\n * {@link ListView} instance is created with the configuration\n * information. This instance gets serialized to XML, and this instance\n * will be called to render the view page. This is the job\n * of {@link Describable} &mdash; each instance represents a specific\n * configuration of a view (what projects are in it, regular expression, etc.)\n *\n * <p>\n * For Hudson to create such configured {@link ListView} instance, Hudson\n * needs another object that captures the metadata of {@link ListView},\n * and that is what a {@link Descriptor} is for. {@link ListView} class\n * has a singleton descriptor, and this descriptor helps render\n * the configuration form, remember system-wide configuration, and works as a factory.\n *\n * <p>\n * {@link Descriptor} also usually have its associated views.\n *\n *\n * <h2>Persistence</h2>\n * <p>\n * {@link Descriptor} can persist data just by storing them in fields.\n * However, it is the responsibility of the derived type to properly\n * invoke {@link #save()} and {@link #load()}.\n *\n * <h2>Reflection Enhancement</h2>\n * {@link Descriptor} defines addition to the standard Java reflection\n * and provides reflective information about its corresponding {@link Describable}.\n * These are primarily used by tag libraries to\n * keep the Jelly scripts concise. \n *\n * @author Kohsuke Kawaguchi\n * @see Describable\n */\npublic abstract class Descriptor<T extends Describable<T>> implements Saveable {\n    /**\n     * The class being described by this descriptor.\n     */\n    public transient final Class<? extends T> clazz;\n\n    private transient final Map<String,String> checkMethods = new ConcurrentHashMap<String,String>();\n\n    /**\n     * Lazily computed list of properties on {@link #clazz} and on the descriptor itself.\n     */\n    private transient volatile Map<String, PropertyType> propertyTypes,globalPropertyTypes;\n\n    /**\n     * Represents a readable property on {@link Describable}.\n     */\n    public static final class PropertyType {\n        public final Class clazz;\n        public final Type type;\n        private volatile Class itemType;\n        public final String displayName;\n\n        PropertyType(Class clazz, Type type, String displayName) {\n            this.clazz = clazz;\n            this.type = type;\n            this.displayName = displayName;\n        }\n\n        PropertyType(Field f) {\n            this(f.getType(),f.getGenericType(),f.toString());\n        }\n\n        PropertyType(Method getter) {\n            this(getter.getReturnType(),getter.getGenericReturnType(),getter.toString());\n        }\n\n        public Enum[] getEnumConstants() {\n            return (Enum[])clazz.getEnumConstants();\n        }\n\n        /**\n         * If the property is a collection/array type, what is an item type?\n         */\n        public Class getItemType() {\n            if(itemType==null)\n                itemType = computeItemType();\n            return itemType;\n        }\n\n        private Class computeItemType() {\n            if(clazz.isArray()) {\n                return clazz.getComponentType();\n            }\n            if(Collection.class.isAssignableFrom(clazz)) {\n                Type col = Types.getBaseClass(type, Collection.class);\n\n                if (col instanceof ParameterizedType)\n                    return Types.erasure(Types.getTypeArgument(col,0));\n                else\n                    return Object.class;\n            }\n            return null;\n        }\n\n        /**\n         * Returns {@link Descriptor} whose 'clazz' is the same as {@link #getItemType() the item type}.\n         */\n        public Descriptor getItemTypeDescriptor() {\n            return Jenkins.getInstance().getDescriptor(getItemType());\n        }\n\n        public Descriptor getItemTypeDescriptorOrDie() {\n            Class it = getItemType();\n            if (it == null) {\n                throw new AssertionError(clazz + \" is not an array/collection type in \" + displayName + \". See https://wiki.jenkins-ci.org/display/JENKINS/My+class+is+missing+descriptor\");\n            }\n            Descriptor d = Jenkins.getInstance().getDescriptor(it);\n            if (d==null)\n                throw new AssertionError(it +\" is missing its descriptor in \"+displayName+\". See https://wiki.jenkins-ci.org/display/JENKINS/My+class+is+missing+descriptor\");\n            return d;\n        }\n\n        /**\n         * Returns all the descriptors that produce types assignable to the property type.\n         */\n        public List<? extends Descriptor> getApplicableDescriptors() {\n            return Jenkins.getInstance().getDescriptorList(clazz);\n        }\n\n        /**\n         * Returns all the descriptors that produce types assignable to the item type for a collection property.\n         */\n        public List<? extends Descriptor> getApplicableItemDescriptors() {\n            return Jenkins.getInstance().getDescriptorList(getItemType());\n        }\n    }\n\n    /**\n     * Help file redirect, keyed by the field name to the path.\n     *\n     * @see #getHelpFile(String) \n     */\n    private transient final Map<String,String> helpRedirect = new HashMap<String, String>();\n\n    /**\n     *\n     * @param clazz\n     *      Pass in {@link #self()} to have the descriptor describe itself,\n     *      (this hack is needed since derived types can't call \"getClass()\" to refer to itself.\n     */\n    protected Descriptor(Class<? extends T> clazz) {\n        if (clazz==self())\n            clazz = (Class)getClass();\n        this.clazz = clazz;\n        // doing this turns out to be very error prone,\n        // as field initializers in derived types will override values.\n        // load();\n    }\n\n    /**\n     * Infers the type of the corresponding {@link Describable} from the outer class.\n     * This version works when you follow the common convention, where a descriptor\n     * is written as the static nested class of the describable class.\n     * \n     * @since 1.278\n     */\n    protected Descriptor() {\n        this.clazz = (Class<T>)getClass().getEnclosingClass();\n        if(clazz==null)\n            throw new AssertionError(getClass()+\" doesn't have an outer class. Use the constructor that takes the Class object explicitly.\");\n\n        // detect an type error\n        Type bt = Types.getBaseClass(getClass(), Descriptor.class);\n        if (bt instanceof ParameterizedType) {\n            ParameterizedType pt = (ParameterizedType) bt;\n            // this 't' is the closest approximation of T of Descriptor<T>.\n            Class t = Types.erasure(pt.getActualTypeArguments()[0]);\n            if(!t.isAssignableFrom(clazz))\n                throw new AssertionError(\"Outer class \"+clazz+\" of \"+getClass()+\" is not assignable to \"+t+\". Perhaps wrong outer class?\");\n        }\n\n        // detect a type error. this Descriptor is supposed to be returned from getDescriptor(), so make sure its type match up.\n        // this prevents a bug like http://www.nabble.com/Creating-a-new-parameter-Type-%3A-Masked-Parameter-td24786554.html\n        try {\n            Method getd = clazz.getMethod(\"getDescriptor\");\n            if(!getd.getReturnType().isAssignableFrom(getClass())) {\n                throw new AssertionError(getClass()+\" must be assignable to \"+getd.getReturnType());\n            }\n        } catch (NoSuchMethodException e) {\n            throw new AssertionError(getClass()+\" is missing getDescriptor method.\");\n        }\n\n    }\n\n    /**\n     * Human readable name of this kind of configurable object.\n     */\n    public abstract String getDisplayName();\n\n    /**\n     * Uniquely identifies this {@link Descriptor} among all the other {@link Descriptor}s.\n     *\n     * <p>\n     * Historically {@link #clazz} is assumed to be unique, so this method uses that as the default,\n     * but if you are adding {@link Descriptor}s programmatically for the same type, you can change\n     * this to disambiguate them.\n     *\n     * <p>\n     * To look up {@link Descriptor} from ID, use {@link Jenkins#getDescriptor(String)}.\n     *\n     * @return\n     *      Stick to valid Java identifier character, plus '.', which had to be allowed for historical reasons.\n     * \n     * @since 1.391\n     */\n    public String getId() {\n        return clazz.getName();\n    }\n\n    /**\n     * Unlike {@link #clazz}, return the parameter type 'T', which determines\n     * the {@link DescriptorExtensionList} that this goes to.\n     *\n     * <p>\n     * In those situations where subtypes cannot provide the type parameter,\n     * this method can be overridden to provide it.\n     */\n    public Class<T> getT() {\n        Type subTyping = Types.getBaseClass(getClass(), Descriptor.class);\n        if (!(subTyping instanceof ParameterizedType)) {\n            throw new IllegalStateException(getClass()+\" doesn't extend Descriptor with a type parameter.\");\n        }\n        return Types.erasure(Types.getTypeArgument(subTyping, 0));\n    }\n\n    /**\n     * Gets the URL that this Descriptor is bound to, relative to the nearest {@link DescriptorByNameOwner}.\n     * Since {@link Jenkins} is a {@link DescriptorByNameOwner}, there's always one such ancestor to any request.\n     */\n    public String getDescriptorUrl() {\n        return \"descriptorByName/\"+getId();\n    }\n\n    /**\n     * Gets the URL that this Descriptor is bound to, relative to the context path.\n     * @since 1.406\n     */\n    public final String getDescriptorFullUrl() {\n        return getCurrentDescriptorByNameUrl()+'/'+getDescriptorUrl();\n    }\n\n    /**\n     * @since 1.402\n     */\n    public static String getCurrentDescriptorByNameUrl() {\n        StaplerRequest req = Stapler.getCurrentRequest();\n\n        // this override allows RenderOnDemandClosure to preserve the proper value\n        Object url = req.getAttribute(\"currentDescriptorByNameUrl\");\n        if (url!=null)  return url.toString();\n\n        Ancestor a = req.findAncestor(DescriptorByNameOwner.class);\n        return a.getUrl();\n    }\n\n    /**\n     * If the field \"xyz\" of a {@link Describable} has the corresponding \"doCheckXyz\" method,\n     * return the form-field validation string. Otherwise null.\n     * <p>\n     * This method is used to hook up the form validation method to the corresponding HTML input element.\n     */\n    public String getCheckUrl(String fieldName) {\n        String method = checkMethods.get(fieldName);\n        if(method==null) {\n            method = calcCheckUrl(fieldName);\n            checkMethods.put(fieldName,method);\n        }\n\n        if (method.equals(NONE)) // == would do, but it makes IDE flag a warning\n            return null;\n\n        // put this under the right contextual umbrella.\n        // a is always non-null because we already have Hudson as the sentinel\n        return '\\'' + jsStringEscape(getCurrentDescriptorByNameUrl()) + \"/'+\" + method;\n    }\n\n    private String calcCheckUrl(String fieldName) {\n        String capitalizedFieldName = StringUtils.capitalize(fieldName);\n\n        Method method = ReflectionUtils.getPublicMethodNamed(getClass(),\"doCheck\"+ capitalizedFieldName);\n\n        if(method==null)\n            return NONE;\n\n        return '\\'' + getDescriptorUrl() + \"/check\" + capitalizedFieldName + '\\'' + buildParameterList(method, new StringBuilder()).append(\".toString()\");\n    }\n\n    /**\n     * Builds query parameter line by figuring out what should be submitted\n     */\n    private StringBuilder buildParameterList(Method method, StringBuilder query) {\n        for (Parameter p : ReflectionUtils.getParameters(method)) {\n            QueryParameter qp = p.annotation(QueryParameter.class);\n            if (qp!=null) {\n                String name = qp.value();\n                if (name.length()==0) name = p.name();\n                if (name==null || name.length()==0)\n                    continue;   // unknown parameter name. we'll report the error when the form is submitted.\n\n                RelativePath rp = p.annotation(RelativePath.class);\n                if (rp!=null)\n                    name = rp.value()+'/'+name;\n\n                if (query.length()==0)  query.append(\"+qs(this)\");\n\n                if (name.equals(\"value\")) {\n                    // The special 'value' parameter binds to the the current field\n                    query.append(\".addThis()\");\n                } else {\n                    query.append(\".nearBy('\"+name+\"')\");\n                }\n                continue;\n            }\n\n            Method m = ReflectionUtils.getPublicMethodNamed(p.type(), \"fromStapler\");\n            if (m!=null)    buildParameterList(m,query);\n        }\n        return query;\n    }\n\n    /**\n     * Computes the list of other form fields that the given field depends on, via the doFillXyzItems method,\n     * and sets that as the 'fillDependsOn' attribute. Also computes the URL of the doFillXyzItems and\n     * sets that as the 'fillUrl' attribute.\n     */\n    public void calcFillSettings(String field, Map<String,Object> attributes) {\n        String capitalizedFieldName = StringUtils.capitalize(field);\n        String methodName = \"doFill\" + capitalizedFieldName + \"Items\";\n        Method method = ReflectionUtils.getPublicMethodNamed(getClass(), methodName);\n        if(method==null)\n            throw new IllegalStateException(String.format(\"%s doesn't have the %s method for filling a drop-down list\", getClass(), methodName));\n\n        // build query parameter line by figuring out what should be submitted\n        List<String> depends = buildFillDependencies(method, new ArrayList<String>());\n\n        if (!depends.isEmpty())\n            attributes.put(\"fillDependsOn\",Util.join(depends,\" \"));\n        attributes.put(\"fillUrl\", String.format(\"%s/%s/fill%sItems\", getCurrentDescriptorByNameUrl(), getDescriptorUrl(), capitalizedFieldName));\n    }\n\n    private List<String> buildFillDependencies(Method method, List<String> depends) {\n        for (Parameter p : ReflectionUtils.getParameters(method)) {\n            QueryParameter qp = p.annotation(QueryParameter.class);\n            if (qp!=null) {\n                String name = qp.value();\n                if (name.length()==0) name = p.name();\n                if (name==null || name.length()==0)\n                    continue;   // unknown parameter name. we'll report the error when the form is submitted.\n\n                RelativePath rp = p.annotation(RelativePath.class);\n                if (rp!=null)\n                    name = rp.value()+'/'+name;\n\n                depends.add(name);\n                continue;\n            }\n\n            Method m = ReflectionUtils.getPublicMethodNamed(p.type(), \"fromStapler\");\n            if (m!=null)\n                buildFillDependencies(m,depends);\n        }\n        return depends;\n    }\n\n    /**\n     * Computes the auto-completion setting\n     */\n    public void calcAutoCompleteSettings(String field, Map<String,Object> attributes) {\n        String capitalizedFieldName = StringUtils.capitalize(field);\n        String methodName = \"doAutoComplete\" + capitalizedFieldName;\n        Method method = ReflectionUtils.getPublicMethodNamed(getClass(), methodName);\n        if(method==null)\n            return;    // no auto-completion\n\n        attributes.put(\"autoCompleteUrl\", String.format(\"%s/%s/autoComplete%s\", getCurrentDescriptorByNameUrl(), getDescriptorUrl(), capitalizedFieldName));\n    }\n\n    /**\n     * Used by Jelly to abstract away the handlign of global.jelly vs config.jelly databinding difference.\n     */\n    public @CheckForNull PropertyType getPropertyType(@Nonnull Object instance, @Nonnull String field) {\n        // in global.jelly, instance==descriptor\n        return instance==this ? getGlobalPropertyType(field) : getPropertyType(field);\n    }\n\n    /**\n     * Akin to {@link #getPropertyType(Object,String) but never returns null.\n     * @throws AssertionError in case the field cannot be found\n     * @since 1.492\n     */\n    public @Nonnull PropertyType getPropertyTypeOrDie(@Nonnull Object instance, @Nonnull String field) {\n        PropertyType propertyType = getPropertyType(instance, field);\n        if (propertyType != null) {\n            return propertyType;\n        } else if (instance == this) {\n            throw new AssertionError(getClass().getName() + \" has no property \" + field);\n        } else {\n            throw new AssertionError(clazz.getName() + \" has no property \" + field);\n        }\n    }\n\n    /**\n     * Obtains the property type of the given field of {@link #clazz}\n     */\n    public PropertyType getPropertyType(String field) {\n        if(propertyTypes==null)\n            propertyTypes = buildPropertyTypes(clazz);\n        return propertyTypes.get(field);\n    }\n\n    /**\n     * Obtains the property type of the given field of this descriptor.\n     */\n    public PropertyType getGlobalPropertyType(String field) {\n        if(globalPropertyTypes==null)\n            globalPropertyTypes = buildPropertyTypes(getClass());\n        return globalPropertyTypes.get(field);\n    }\n\n    /**\n     * Given the class, list up its {@link PropertyType}s from its public fields/getters.\n     */\n    private Map<String, PropertyType> buildPropertyTypes(Class<?> clazz) {\n        Map<String, PropertyType> r = new HashMap<String, PropertyType>();\n        for (Field f : clazz.getFields())\n            r.put(f.getName(),new PropertyType(f));\n\n        for (Method m : clazz.getMethods())\n            if(m.getName().startsWith(\"get\"))\n                r.put(Introspector.decapitalize(m.getName().substring(3)),new PropertyType(m));\n\n        return r;\n    }\n\n    /**\n     * Gets the class name nicely escaped to be usable as a key in the structured form submission.\n     */\n    public final String getJsonSafeClassName() {\n        return getId().replace('.','-');\n    }\n\n    /**\n     * @deprecated\n     *      Implement {@link #newInstance(StaplerRequest, JSONObject)} method instead.\n     *      Deprecated as of 1.145. \n     */\n    public T newInstance(StaplerRequest req) throws FormException {\n        throw new UnsupportedOperationException(getClass()+\" should implement newInstance(StaplerRequest,JSONObject)\");\n    }\n\n    /**\n     * Creates a configured instance from the submitted form.\n     *\n     * <p>\n     * Hudson only invokes this method when the user wants an instance of <tt>T</tt>.\n     * So there's no need to check that in the implementation.\n     *\n     * <p>\n     * Starting 1.206, the default implementation of this method does the following:\n     * <pre>\n     * req.bindJSON(clazz,formData);\n     * </pre>\n     * <p>\n     * ... which performs the databinding on the constructor of {@link #clazz}.\n     *\n     * <p>\n     * For some types of {@link Describable}, such as {@link ListViewColumn}, this method\n     * can be invoked with null request object for historical reason. Such design is considered\n     * broken, but due to the compatibility reasons we cannot fix it. Because of this, the\n     * default implementation gracefully handles null request, but the contract of the method\n     * still is \"request is always non-null.\" Extension points that need to define the \"default instance\"\n     * semantics should define a descriptor subtype and add the no-arg newInstance method.\n     *\n     * @param req\n     *      Always non-null (see note above.) This object includes represents the entire submission.\n     * @param formData\n     *      The JSON object that captures the configuration data for this {@link Descriptor}.\n     *      See http://wiki.jenkins-ci.org/display/JENKINS/Structured+Form+Submission\n     *      Always non-null.\n     *\n     * @throws FormException\n     *      Signals a problem in the submitted form.\n     * @since 1.145\n     */\n    public T newInstance(StaplerRequest req, JSONObject formData) throws FormException {\n        try {\n            Method m = getClass().getMethod(\"newInstance\", StaplerRequest.class);\n\n            if(!Modifier.isAbstract(m.getDeclaringClass().getModifiers())) {\n                // this class overrides newInstance(StaplerRequest).\n                // maintain the backward compatible behavior\n                return verifyNewInstance(newInstance(req));\n            } else {\n                if (req==null) {\n                    // yes, req is supposed to be always non-null, but see the note above\n                    return verifyNewInstance(clazz.newInstance());\n                }\n\n                // new behavior as of 1.206\n                return verifyNewInstance(req.bindJSON(clazz,formData));\n            }\n        } catch (NoSuchMethodException e) {\n            throw new AssertionError(e); // impossible\n        } catch (InstantiationException e) {\n            throw new Error(\"Failed to instantiate \"+clazz+\" from \"+formData,e);\n        } catch (IllegalAccessException e) {\n            throw new Error(\"Failed to instantiate \"+clazz+\" from \"+formData,e);\n        } catch (RuntimeException e) {\n            throw new RuntimeException(\"Failed to instantiate \"+clazz+\" from \"+formData,e);\n        }\n    }\n\n    /**\n     * Look out for a typical error a plugin developer makes.\n     * See http://hudson.361315.n4.nabble.com/Help-Hint-needed-Post-build-action-doesn-t-stay-activated-td2308833.html\n     */\n    private T verifyNewInstance(T t) {\n        if (t!=null && t.getDescriptor()!=this) {\n            // TODO: should this be a fatal error?\n            LOGGER.warning(\"Father of \"+ t+\" and its getDescriptor() points to two different instances. Probably malplaced @Extension. See http://hudson.361315.n4.nabble.com/Help-Hint-needed-Post-build-action-doesn-t-stay-activated-td2308833.html\");\n        }\n        return t;\n    }\n\n    /**\n     * Returns the {@link Klass} object used for the purpose of loading resources from this descriptor.\n     *\n     * This hook enables other JVM languages to provide more integrated lookup.\n     */\n    public Klass<?> getKlass() {\n        return Klass.java(clazz);\n    }\n\n    /**\n     * Returns the resource path to the help screen HTML, if any.\n     *\n     * <p>\n     * Starting 1.282, this method uses \"convention over configuration\" &mdash; you should\n     * just put the \"help.html\" (and its localized versions, if any) in the same directory\n     * you put your Jelly view files, and this method will automatically does the right thing.\n     *\n     * <p>\n     * This value is relative to the context root of Hudson, so normally\n     * the values are something like <tt>\"/plugin/emma/help.html\"</tt> to\n     * refer to static resource files in a plugin, or <tt>\"/publisher/EmmaPublisher/abc\"</tt>\n     * to refer to Jelly script <tt>abc.jelly</tt> or a method <tt>EmmaPublisher.doAbc()</tt>.\n     *\n     * @return\n     *      null to indicate that there's no help.\n     */\n    public String getHelpFile() {\n        return getHelpFile(null);\n    }\n\n    /**\n     * Returns the path to the help screen HTML for the given field.\n     *\n     * <p>\n     * The help files are assumed to be at \"help/FIELDNAME.html\" with possible\n     * locale variations.\n     */\n    public String getHelpFile(final String fieldName) {\n        return getHelpFile(getKlass(),fieldName);\n    }\n\n    public String getHelpFile(Klass<?> clazz, String fieldName) {\n        String v = helpRedirect.get(fieldName);\n        if (v!=null)    return v;\n\n        for (Klass<?> c : clazz.getAncestors()) {\n            String page = \"/descriptor/\" + getId() + \"/help\";\n            String suffix;\n            if(fieldName==null) {\n                suffix=\"\";\n            } else {\n                page += '/'+fieldName;\n                suffix='-'+fieldName;\n            }\n\n            try {\n                if(Stapler.getCurrentRequest().getView(c,\"help\"+suffix)!=null)\n                    return page;\n            } catch (IOException e) {\n                throw new Error(e);\n            }\n\n            if(getStaticHelpUrl(c, suffix) !=null)    return page;\n        }\n        return null;\n    }\n    \n    /**\n     * Tells Jenkins that the help file for the field 'fieldName' is defined in the help file for\n     * the 'fieldNameToRedirectTo' in the 'owner' class.\n     * @since 1.425\n     */\n    protected void addHelpFileRedirect(String fieldName, Class<? extends Describable> owner, String fieldNameToRedirectTo) {\n        helpRedirect.put(fieldName,\n            Jenkins.getInstance().getDescriptor(owner).getHelpFile(fieldNameToRedirectTo));\n    }\n\n    /**\n     * Checks if the given object is created from this {@link Descriptor}.\n     */\n    public final boolean isInstance( T instance ) {\n        return clazz.isInstance(instance);\n    }\n\n    /**\n     * Checks if the type represented by this descriptor is a subtype of the given type.\n     */\n    public final boolean isSubTypeOf(Class type) {\n        return type.isAssignableFrom(clazz);\n    }\n\n    /**\n     * @deprecated\n     *      As of 1.239, use {@link #configure(StaplerRequest, JSONObject)}.\n     */\n    public boolean configure( StaplerRequest req ) throws FormException {\n        return true;\n    }\n\n    /**\n     * Invoked when the global configuration page is submitted.\n     *\n     * Can be overriden to store descriptor-specific information.\n     *\n     * @param json\n     *      The JSON object that captures the configuration data for this {@link Descriptor}.\n     *      See http://wiki.jenkins-ci.org/display/JENKINS/Structured+Form+Submission\n     * @return false\n     *      to keep the client in the same config page.\n     */\n    public boolean configure( StaplerRequest req, JSONObject json ) throws FormException {\n        // compatibility\n        return configure(req);\n    }\n\n    public String getConfigPage() {\n        return getViewPage(clazz, getPossibleViewNames(\"config\"), \"config.jelly\");\n    }\n\n    public String getGlobalConfigPage() {\n        return getViewPage(clazz, getPossibleViewNames(\"global\"), null);\n    }\n    \n    private String getViewPage(Class<?> clazz, String pageName, String defaultValue) {\n        return getViewPage(clazz,Collections.singleton(pageName),defaultValue);\n    }\n\n    private String getViewPage(Class<?> clazz, Collection<String> pageNames, String defaultValue) {\n        while(clazz!=Object.class && clazz!=null) {\n            for (String pageName : pageNames) {\n                String name = clazz.getName().replace('.', '/').replace('$', '/') + \"/\" + pageName;\n                if(clazz.getClassLoader().getResource(name)!=null)\n                    return '/'+name;\n            }\n            clazz = clazz.getSuperclass();\n        }\n        return defaultValue;\n    }\n\n    protected final String getViewPage(Class<?> clazz, String pageName) {\n        // We didn't find the configuration page.\n        // Either this is non-fatal, in which case it doesn't matter what string we return so long as\n        // it doesn't exist.\n        // Or this error is fatal, in which case we want the developer to see what page he's missing.\n        // so we put the page name.\n        return getViewPage(clazz,pageName,pageName);\n    }\n\n    protected List<String> getPossibleViewNames(String baseName) {\n        List<String> names = new ArrayList<String>();\n        for (Facet f : WebApp.get(Jenkins.getInstance().servletContext).facets) {\n            if (f instanceof JellyCompatibleFacet) {\n                JellyCompatibleFacet jcf = (JellyCompatibleFacet) f;\n                for (String ext : jcf.getScriptExtensions())\n                    names.add(baseName +ext);\n            }\n        }\n        return names;\n    }\n\n\n    /**\n     * Saves the configuration info to the disk.\n     */\n    public synchronized void save() {\n        if(BulkChange.contains(this))   return;\n        try {\n            getConfigFile().write(this);\n            SaveableListener.fireOnChange(this, getConfigFile());\n        } catch (IOException e) {\n            LOGGER.log(Level.WARNING, \"Failed to save \"+getConfigFile(),e);\n        }\n    }\n\n    /**\n     * Loads the data from the disk into this object.\n     *\n     * <p>\n     * The constructor of the derived class must call this method.\n     * (If we do that in the base class, the derived class won't\n     * get a chance to set default values.)\n     */\n    public synchronized void load() {\n        XmlFile file = getConfigFile();\n        if(!file.exists())\n            return;\n\n        try {\n            file.unmarshal(this);\n        } catch (IOException e) {\n            LOGGER.log(Level.WARNING, \"Failed to load \"+file, e);\n        }\n    }\n\n    protected final XmlFile getConfigFile() {\n        return new XmlFile(new File(Jenkins.getInstance().getRootDir(),getId()+\".xml\"));\n    }\n\n    /**\n     * Returns the plugin in which this descriptor is defined.\n     *\n     * @return\n     *      null to indicate that this descriptor came from the core.\n     */\n    protected PluginWrapper getPlugin() {\n        return Jenkins.getInstance().getPluginManager().whichPlugin(clazz);\n    }\n\n    /**\n     * Serves <tt>help.html</tt> from the resource of {@link #clazz}.\n     */\n    public void doHelp(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n        String path = req.getRestOfPath();\n        if(path.contains(\"..\")) throw new ServletException(\"Illegal path: \"+path);\n\n        path = path.replace('/','-');\n\n        PluginWrapper pw = getPlugin();\n        if (pw!=null) {\n            rsp.setHeader(\"X-Plugin-Short-Name\",pw.getShortName());\n            rsp.setHeader(\"X-Plugin-Long-Name\",pw.getLongName());\n            rsp.setHeader(\"X-Plugin-From\", Messages.Descriptor_From(\n                    pw.getLongName().replace(\"Hudson\",\"Jenkins\").replace(\"hudson\",\"jenkins\"), pw.getUrl()));\n        }\n\n        for (Klass<?> c= getKlass(); c!=null; c=c.getSuperClass()) {\n            RequestDispatcher rd = Stapler.getCurrentRequest().getView(c, \"help\"+path);\n            if(rd!=null) {// template based help page\n                rd.forward(req,rsp);\n                return;\n            }\n\n            URL url = getStaticHelpUrl(c, path);\n            if(url!=null) {\n                // TODO: generalize macro expansion and perhaps even support JEXL\n                rsp.setContentType(\"text/html;charset=UTF-8\");\n                InputStream in = url.openStream();\n                try {\n                    String literal = IOUtils.toString(in,\"UTF-8\");\n                    rsp.getWriter().println(Util.replaceMacro(literal, Collections.singletonMap(\"rootURL\",req.getContextPath())));\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n                return;\n            }\n        }\n        rsp.sendError(SC_NOT_FOUND);\n    }\n\n    private URL getStaticHelpUrl(Klass<?> c, String suffix) {\n        Locale locale = Stapler.getCurrentRequest().getLocale();\n\n        String base = \"help\"+suffix;\n\n        URL url;\n        url = c.getResource(base + '_' + locale.getLanguage() + '_' + locale.getCountry() + '_' + locale.getVariant() + \".html\");\n        if(url!=null)    return url;\n        url = c.getResource(base + '_' + locale.getLanguage() + '_' + locale.getCountry() + \".html\");\n        if(url!=null)    return url;\n        url = c.getResource(base + '_' + locale.getLanguage() + \".html\");\n        if(url!=null)    return url;\n\n        // default\n        return c.getResource(base + \".html\");\n    }\n\n\n//\n// static methods\n//\n\n\n    // to work around warning when creating a generic array type\n    public static <T> T[] toArray( T... values ) {\n        return values;\n    }\n\n    public static <T> List<T> toList( T... values ) {\n        return new ArrayList<T>(Arrays.asList(values));\n    }\n\n    public static <T extends Describable<T>>\n    Map<Descriptor<T>,T> toMap(Iterable<T> describables) {\n        Map<Descriptor<T>,T> m = new LinkedHashMap<Descriptor<T>,T>();\n        for (T d : describables) {\n            m.put(d.getDescriptor(),d);\n        }\n        return m;\n    }\n\n    /**\n     * Used to build {@link Describable} instance list from &lt;f:hetero-list> tag.\n     *\n     * @param req\n     *      Request that represents the form submission.\n     * @param formData\n     *      Structured form data that represents the contains data for the list of describables.\n     * @param key\n     *      The JSON property name for 'formData' that represents the data for the list of describables.\n     * @param descriptors\n     *      List of descriptors to create instances from.\n     * @return\n     *      Can be empty but never null.\n     */\n    public static <T extends Describable<T>>\n    List<T> newInstancesFromHeteroList(StaplerRequest req, JSONObject formData, String key,\n                Collection<? extends Descriptor<T>> descriptors) throws FormException {\n\n        return newInstancesFromHeteroList(req,formData.get(key),descriptors);\n    }\n\n    public static <T extends Describable<T>>\n    List<T> newInstancesFromHeteroList(StaplerRequest req, Object formData,\n                Collection<? extends Descriptor<T>> descriptors) throws FormException {\n\n        List<T> items = new ArrayList<T>();\n\n        if (formData!=null) {\n            for (Object o : JSONArray.fromObject(formData)) {\n                JSONObject jo = (JSONObject)o;\n                String kind = jo.getString(\"kind\");\n                Descriptor<T> d = find(descriptors, kind);\n                if (d != null) {\n                    items.add(d.newInstance(req, jo));\n                }\n            }\n        }\n\n        return items;\n    }\n\n    /**\n     * Finds a descriptor from a collection by its class name.\n     */\n    public static @CheckForNull <T extends Descriptor> T find(Collection<? extends T> list, String className) {\n        for (T d : list) {\n            if(d.getClass().getName().equals(className))\n                return d;\n        }\n        // Since we introduced Descriptor.getId(), it is a preferred method of identifying descriptor by a string.\n        // To make that migration easier without breaking compatibility, let's also match up with the id.\n        for (T d : list) {\n            if(d.getId().equals(className))\n                return d;\n        }\n        return null;\n    }\n\n    public static @CheckForNull Descriptor find(String className) {\n        return find(Jenkins.getInstance().getExtensionList(Descriptor.class),className);\n    }\n\n    public static final class FormException extends Exception implements HttpResponse {\n        private final String formField;\n\n        public FormException(String message, String formField) {\n            super(message);\n            this.formField = formField;\n        }\n\n        public FormException(String message, Throwable cause, String formField) {\n            super(message, cause);\n            this.formField = formField;\n        }\n\n        public FormException(Throwable cause, String formField) {\n            super(cause);\n            this.formField = formField;\n        }\n\n        /**\n         * Which form field contained an error?\n         */\n        public String getFormField() {\n            return formField;\n        }\n\n        public void generateResponse(StaplerRequest req, StaplerResponse rsp, Object node) throws IOException, ServletException {\n            if (FormApply.isApply(req)) {\n                FormApply.applyResponse(\"notificationBar.show(\" + quote(getMessage())+ \",notificationBar.defaultOptions.ERROR)\")\n                        .generateResponse(req, rsp, node);\n            } else {\n                // for now, we can't really use the field name that caused the problem.\n                new Failure(getMessage()).generateResponse(req,rsp,node);\n            }\n        }\n    }\n\n    private static final Logger LOGGER = Logger.getLogger(Descriptor.class.getName());\n\n    /**\n     * Used in {@link #checkMethods} to indicate that there's no check method.\n     */\n    private static final String NONE = \"\\u0000\";\n\n    /**\n     * Special type indicating that {@link Descriptor} describes itself.\n     * @see Descriptor#Descriptor(Class)\n     */\n    public static final class Self {}\n\n    protected static Class self() { return Self.class; }\n}\n", "/*\n * The MIT License\n *\n * Copyright (c) 2004-2009, Sun Microsystems, Inc., Kohsuke Kawaguchi, Brian Westrich, Martin Eigenbrodt\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage hudson.tasks;\n\nimport hudson.Extension;\nimport hudson.Launcher;\nimport hudson.Util;\nimport hudson.console.ModelHyperlinkNote;\nimport hudson.model.AbstractBuild;\nimport hudson.model.AbstractProject;\nimport hudson.model.Action;\nimport hudson.model.AutoCompletionCandidates;\nimport hudson.model.BuildListener;\nimport hudson.model.Cause.UpstreamCause;\nimport jenkins.model.DependencyDeclarer;\nimport hudson.model.DependencyGraph;\nimport hudson.model.DependencyGraph.Dependency;\nimport jenkins.model.Jenkins;\nimport hudson.model.Item;\nimport hudson.model.ItemGroup;\nimport hudson.model.Items;\nimport hudson.model.Job;\nimport hudson.model.Project;\nimport hudson.model.Result;\nimport hudson.model.Run;\nimport hudson.model.TaskListener;\nimport hudson.model.listeners.ItemListener;\nimport hudson.tasks.BuildTrigger.DescriptorImpl.ItemListenerImpl;\nimport hudson.util.FormValidation;\nimport net.sf.json.JSONObject;\nimport org.apache.commons.lang.StringUtils;\nimport org.kohsuke.stapler.AncestorInPath;\nimport org.kohsuke.stapler.DataBoundConstructor;\nimport org.kohsuke.stapler.QueryParameter;\nimport org.kohsuke.stapler.StaplerRequest;\n\nimport java.io.IOException;\nimport java.io.PrintStream;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport javax.annotation.CheckForNull;\n\n/**\n * Triggers builds of other projects.\n *\n * <p>\n * Despite what the name suggests, this class doesn't actually trigger other jobs\n * as a part of {@link #perform} method. Its main job is to simply augment\n * {@link DependencyGraph}. Jobs are responsible for triggering downstream jobs\n * on its own, because dependencies may come from other sources.\n *\n * <p>\n * This class, however, does provide the {@link #execute(AbstractBuild, BuildListener, BuildTrigger)}\n * method as a convenience method to invoke downstream builds.\n *\n * @author Kohsuke Kawaguchi\n */\npublic class BuildTrigger extends Recorder implements DependencyDeclarer {\n\n    /**\n     * Comma-separated list of other projects to be scheduled.\n     */\n    private String childProjects;\n\n    /**\n     * Threshold status to trigger other builds.\n     *\n     * For compatibility reasons, this field could be null, in which case\n     * it should read as \"SUCCESS\".\n     */\n    private final Result threshold;\n\n    public BuildTrigger(String childProjects, boolean evenIfUnstable) {\n        this(childProjects,evenIfUnstable ? Result.UNSTABLE : Result.SUCCESS);\n    }\n\n    @DataBoundConstructor\n    public BuildTrigger(String childProjects, String threshold) {\n        this(childProjects, Result.fromString(StringUtils.defaultString(threshold, Result.SUCCESS.toString())));\n    }\n\n    public BuildTrigger(String childProjects, Result threshold) {\n        if(childProjects==null)\n            throw new IllegalArgumentException();\n        this.childProjects = childProjects;\n        this.threshold = threshold;\n    }\n\n    public BuildTrigger(List<AbstractProject> childProjects, Result threshold) {\n        this((Collection<AbstractProject>)childProjects,threshold);\n    }\n\n    public BuildTrigger(Collection<? extends AbstractProject> childProjects, Result threshold) {\n        this(Items.toNameList(childProjects),threshold);\n    }\n\n    public String getChildProjectsValue() {\n        return childProjects;\n    }\n\n    public Result getThreshold() {\n        if(threshold==null)\n            return Result.SUCCESS;\n        else\n            return threshold;\n    }\n\n    /**\n     * @deprecated as of 1.406\n     *      Use {@link #getChildProjects(ItemGroup)}\n     */\n    public List<AbstractProject> getChildProjects() {\n        return getChildProjects(Jenkins.getInstance());\n    }\n\n    public List<AbstractProject> getChildProjects(AbstractProject owner) {\n        return getChildProjects(owner==null?null:owner.getParent());\n    }\n\n    public List<AbstractProject> getChildProjects(ItemGroup base) {\n        return Items.fromNameList(base,childProjects,AbstractProject.class);\n    }\n\n    public BuildStepMonitor getRequiredMonitorService() {\n        return BuildStepMonitor.NONE;\n    }\n\n    /**\n     * Checks if this trigger has the exact same set of children as the given list.\n     */\n    public boolean hasSame(AbstractProject owner, Collection<? extends AbstractProject> projects) {\n        List<AbstractProject> children = getChildProjects(owner);\n        return children.size()==projects.size() && children.containsAll(projects);\n    }\n\n    /**\n     * @deprecated as of 1.406\n     *      Use {@link #hasSame(AbstractProject, Collection)}\n     */\n    public boolean hasSame(Collection<? extends AbstractProject> projects) {\n        return hasSame(null,projects);\n    }\n\n    @Override\n    public boolean perform(AbstractBuild build, Launcher launcher, BuildListener listener) {\n        return true;\n    }\n\n    /**\n     * @deprecated since 1.341; use {@link #execute(AbstractBuild,BuildListener)}\n     */\n    @Deprecated\n    public static boolean execute(AbstractBuild build, BuildListener listener, BuildTrigger trigger) {\n        return execute(build, listener);\n    }\n\n    /**\n     * Convenience method to trigger downstream builds.\n     *\n     * @param build\n     *      The current build. Its downstreams will be triggered.\n     * @param listener\n     *      Receives the progress report.\n     */\n    public static boolean execute(AbstractBuild build, BuildListener listener) {\n        PrintStream logger = listener.getLogger();\n        // Check all downstream Project of the project, not just those defined by BuildTrigger\n        final DependencyGraph graph = Jenkins.getInstance().getDependencyGraph();\n        List<Dependency> downstreamProjects = new ArrayList<Dependency>(\n                graph.getDownstreamDependencies(build.getProject()));\n        // Sort topologically\n        Collections.sort(downstreamProjects, new Comparator<Dependency>() {\n            public int compare(Dependency lhs, Dependency rhs) {\n                // Swapping lhs/rhs to get reverse sort:\n                return graph.compare(rhs.getDownstreamProject(), lhs.getDownstreamProject());\n            }\n        });\n\n        for (Dependency dep : downstreamProjects) {\n            AbstractProject p = dep.getDownstreamProject();\n            if (p.isDisabled()) {\n                logger.println(Messages.BuildTrigger_Disabled(ModelHyperlinkNote.encodeTo(p)));\n                continue;\n            }\n            List<Action> buildActions = new ArrayList<Action>();\n            if (dep.shouldTriggerBuild(build, listener, buildActions)) {\n                // this is not completely accurate, as a new build might be triggered\n                // between these calls\n                String name = ModelHyperlinkNote.encodeTo(p)+\" #\"+p.getNextBuildNumber();\n                if(p.scheduleBuild(p.getQuietPeriod(), new UpstreamCause((Run)build),\n                                   buildActions.toArray(new Action[buildActions.size()]))) {\n                    logger.println(Messages.BuildTrigger_Triggering(name));\n                } else {\n                    logger.println(Messages.BuildTrigger_InQueue(name));\n                }\n            }\n        }\n\n        return true;\n    }\n\n    public void buildDependencyGraph(AbstractProject owner, DependencyGraph graph) {\n        for (AbstractProject p : getChildProjects(owner))\n            graph.addDependency(new Dependency(owner, p) {\n                @Override\n                public boolean shouldTriggerBuild(AbstractBuild build, TaskListener listener,\n                                                  List<Action> actions) {\n                    return build.getResult().isBetterOrEqualTo(threshold);\n                }\n            });\n    }\n\n    @Override\n    public boolean needsToRunAfterFinalized() {\n        return true;\n    }\n\n    /**\n     * Called from {@link ItemListenerImpl} when a job is renamed.\n     *\n     * @return true if this {@link BuildTrigger} is changed and needs to be saved.\n     */\n    public boolean onJobRenamed(String oldName, String newName) {\n        // quick test\n        if(!childProjects.contains(oldName))\n            return false;\n\n        boolean changed = false;\n\n        // we need to do this per string, since old Project object is already gone.\n        String[] projects = childProjects.split(\",\");\n        for( int i=0; i<projects.length; i++ ) {\n            if(projects[i].trim().equals(oldName)) {\n                projects[i] = newName;\n                changed = true;\n            }\n        }\n\n        if(changed) {\n            StringBuilder b = new StringBuilder();\n            for (String p : projects) {\n                if(b.length()>0)    b.append(',');\n                b.append(p);\n            }\n            childProjects = b.toString();\n        }\n\n        return changed;\n    }\n\n    /**\n     * Correct broken data gracefully (#1537)\n     */\n    private Object readResolve() {\n        if(childProjects==null)\n            return childProjects=\"\";\n        return this;\n    }\n\n    @Extension\n    public static class DescriptorImpl extends BuildStepDescriptor<Publisher> {\n        public String getDisplayName() {\n            return Messages.BuildTrigger_DisplayName();\n        }\n\n        @Override\n        public String getHelpFile() {\n            return \"/help/project-config/downstream.html\";\n        }\n\n        @Override\n        public Publisher newInstance(StaplerRequest req, JSONObject formData) throws FormException {\n            String childProjectsString = formData.getString(\"childProjects\").trim();\n            if (childProjectsString.endsWith(\",\")) {\n                childProjectsString = childProjectsString.substring(0, childProjectsString.length() - 1).trim();\n            }\n            return new BuildTrigger(\n                childProjectsString,\n                formData.optString(\"threshold\", Result.SUCCESS.toString()));\n        }\n\n        @Override\n        public boolean isApplicable(Class<? extends AbstractProject> jobType) {\n            return true;\n        }\n\n        public boolean showEvenIfUnstableOption(@CheckForNull Class<? extends AbstractProject<?,?>> jobType) {\n            // UGLY: for promotion process, this option doesn't make sense.\n            return jobType == null || !jobType.getName().contains(\"PromotionProcess\");\n        }\n\n        /**\n         * Form validation method.\n         */\n        public FormValidation doCheck(@AncestorInPath Item project, @QueryParameter String value, @QueryParameter boolean upstream) {\n            // Require CONFIGURE permission on this project\n            if(!project.hasPermission(Item.CONFIGURE))      return FormValidation.ok();\n\n            StringTokenizer tokens = new StringTokenizer(Util.fixNull(value),\",\");\n            boolean hasProjects = false;\n            while(tokens.hasMoreTokens()) {\n                String projectName = tokens.nextToken().trim();\n                if (StringUtils.isNotBlank(projectName)) {\n                    Item item = Jenkins.getInstance().getItem(projectName,project,Item.class);\n                    if(item==null)\n                        return FormValidation.error(Messages.BuildTrigger_NoSuchProject(projectName,\n                                AbstractProject.findNearest(projectName,project.getParent()).getRelativeNameFrom(project)));\n                    if(!(item instanceof AbstractProject))\n                        return FormValidation.error(Messages.BuildTrigger_NotBuildable(projectName));\n                    if (!upstream && !item.hasPermission(Item.BUILD)) {\n                        return FormValidation.error(Messages.BuildTrigger_you_have_no_permission_to_build_(projectName));\n                    }\n                    hasProjects = true;\n                }\n            }\n            if (!hasProjects) {\n                return FormValidation.error(Messages.BuildTrigger_NoProjectSpecified());\n            }\n\n            return FormValidation.ok();\n        }\n\n        public AutoCompletionCandidates doAutoCompleteChildProjects(@QueryParameter String value, @AncestorInPath Item self, @AncestorInPath ItemGroup container) {\n            return AutoCompletionCandidates.ofJobNames(Job.class,value,self,container);\n        }\n\n        @Extension\n        public static class ItemListenerImpl extends ItemListener {\n            @Override\n            public void onRenamed(Item item, String oldName, String newName) {\n                // update BuildTrigger of other projects that point to this object.\n                // can't we generalize this?\n                for( Project<?,?> p : Jenkins.getInstance().getAllItems(Project.class) ) {\n                    BuildTrigger t = p.getPublishersList().get(BuildTrigger.class);\n                    if(t!=null) {\n                        if(t.onJobRenamed(oldName,newName)) {\n                            try {\n                                p.save();\n                            } catch (IOException e) {\n                                LOGGER.log(Level.WARNING, \"Failed to persist project setting during rename from \"+oldName+\" to \"+newName,e);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    private static final Logger LOGGER = Logger.getLogger(BuildTrigger.class.getName());\n}\n", "# The MIT License\n# \n# Copyright (c) 2004-2009, Sun Microsystems, Inc., Kohsuke Kawaguchi, Jene Jasper\n# \n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n# \n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n# \n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n# THE SOFTWARE.\n\nAnt.DisplayName=Invoke Ant\nAnt.ExecFailed=command execution failed.\nAnt.ExecutableNotFound=Cannot find executable from the chosen Ant installation \"{0}\"\nAnt.GlobalConfigNeeded= Maybe you need to configure where your Ant installations are?\nAnt.NotADirectory={0} is not a directory\nAnt.NotAntDirectory={0} doesn''t look like an Ant directory\nAnt.ProjectConfigNeeded= Maybe you need to configure the job to choose one of your Ant installations?\n\nArtifactArchiver.ARCHIVING_ARTIFACTS=Archiving artifacts\nArtifactArchiver.DeletingOld=Deleting old artifacts from {0}\nArtifactArchiver.DisplayName=Archive the artifacts\nArtifactArchiver.FailedToArchive=Failed to archive artifacts: {0}\nArtifactArchiver.NoIncludes=\\\nNo artifacts are configured for archiving.\\n\\\nYou probably forgot to set the file pattern, so please go back to the configuration and specify it.\\n\\\nIf you really did mean to archive all the files in the workspace, please specify \"**\"\nArtifactArchiver.NoMatchFound=No artifacts found that match the file pattern \"{0}\". Configuration error?\n\nBatchFile.DisplayName=Execute Windows batch command\n\nBuildTrigger.Disabled={0} is disabled. Triggering skipped\nBuildTrigger.DisplayName=Build other projects\nBuildTrigger.InQueue={0} is already in the queue\nBuildTrigger.NoSuchProject=No such project ''{0}''. Did you mean ''{1}''?\nBuildTrigger.NoProjectSpecified=No project specified\nBuildTrigger.NotBuildable={0} is not buildable\nBuildTrigger.Triggering=Triggering a new build of {0}\nBuildTrigger.you_have_no_permission_to_build_=You have no permission to build {0}\n\nCommandInterpreter.CommandFailed=command execution failed\nCommandInterpreter.UnableToDelete=Unable to delete script file {0}\nCommandInterpreter.UnableToProduceScript=Unable to produce a script file\n\nFingerprinter.Aborted=Aborted\nFingerprinter.Action.DisplayName=See Fingerprints\nFingerprinter.DigestFailed=Failed to compute digest for {0}\nFingerprinter.DisplayName=Record fingerprints of files to track usage\nFingerprinter.Failed=Failed to record fingerprints\nFingerprinter.FailedFor=failed to record fingerprint for {0}\nFingerprinter.NoArchiving=Build artifacts are supposed to be fingerprinted, but build artifact archiving is not configured\nFingerprinter.NoWorkspace=Unable to record fingerprints because there''s no workspace\nFingerprinter.Recording=Recording fingerprints\n\nInstallFromApache=Install from Apache\n\nJavadocArchiver.DisplayName=Publish Javadoc\nJavadocArchiver.DisplayName.Generic=Document\nJavadocArchiver.DisplayName.Javadoc=Javadoc\nTestJavadocArchiver.DisplayName.Javadoc=Test Javadoc\nJavadocArchiver.NoMatchFound=No javadoc found in {0}: {1}\nJavadocArchiver.Publishing=Publishing Javadoc\nJavadocArchiver.UnableToCopy=Unable to copy Javadoc from {0} to {1}\n\nMaven.DisplayName=Invoke top-level Maven targets\nMaven.ExecFailed=command execution failed\nMaven.NotMavenDirectory={0} doesn''t look like a Maven directory\nMaven.NoExecutable=Couldn''t find any executable in {0}\nMaven.NotADirectory={0} is not a directory\n\nShell.DisplayName=Execute shell\n", "<!--\nThe MIT License\n\nCopyright (c) 2004-2011, Sun Microsystems, Inc., Kohsuke Kawaguchi, Seiji Sogabe, Andrew Bayer\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n-->\n\n<!--\n  Present the pseudo \"upstream project trigger\". Used inside <p:config-trigger>\n\n  \"it\" is assumed to be a Project object.\n-->\n<?jelly escape-by-default='true'?>\n<j:jelly xmlns:j=\"jelly:core\" xmlns:st=\"jelly:stapler\" xmlns:d=\"jelly:define\" xmlns:l=\"/lib/layout\" xmlns:t=\"/lib/hudson\" xmlns:f=\"/lib/form\">\n  <!-- pseudo-trigger to list upstream projects. -->\n  <j:set var=\"up\" value=\"${it.buildTriggerUpstreamProjects}\" />\n  <f:optionalBlock name=\"pseudoUpstreamTrigger\"\n                   help=\"/help/project-config/upstream.html\"\n                   title=\"${%Build after other projects are built}\" \n                   checked=\"${!empty(up)}\">\n    <f:entry title=\"${%Project names}\"\n             description=\"${%Multiple projects can be specified like 'abc, def'}\">\n      <f:textbox name=\"upstreamProjects\" value=\"${h.getProjectListString(up)}\"\n        checkUrl=\"'descriptorByName/hudson.tasks.BuildTrigger/check?upstream=true&amp;value='+encodeURIComponent(this.value)\"\n        autoCompleteField=\"upstreamProjects\"/>\n    </f:entry>\n  </f:optionalBlock>\n</j:jelly>\n"], "filenames": ["core/src/main/java/hudson/model/AbstractProject.java", "core/src/main/java/hudson/model/Descriptor.java", "core/src/main/java/hudson/tasks/BuildTrigger.java", "core/src/main/resources/hudson/tasks/Messages.properties", "core/src/main/resources/lib/hudson/project/config-upstream-pseudo-trigger.jelly"], "buggy_code_start_loc": [1916, 939, 322, 49, 41], "buggy_code_end_loc": [1916, 964, 336, 49, 42], "fixing_code_start_loc": [1917, 939, 322, 50, 41], "fixing_code_end_loc": [1924, 967, 340, 51, 42], "type": "CWE-264", "message": "Jenkins before 1.502 allows remote authenticated users to configure an otherwise restricted project via vectors related to post-build actions.", "other": {"cve": {"id": "CVE-2013-7330", "sourceIdentifier": "security@debian.org", "published": "2014-10-17T15:55:05.463", "lastModified": "2016-06-13T23:27:39.187", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Jenkins before 1.502 allows remote authenticated users to configure an otherwise restricted project via vectors related to post-build actions."}, {"lang": "es", "value": "Jenkins en versiones anteriores a 1.502 permite a usuarios remotos autenticados configurar un proyecto restringido de otro modo a trav\u00e9s de vectores relacionados con acciones post-build."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-264"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:jenkins:jenkins:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.501", "matchCriteriaId": "5815F006-F668-40CD-B26C-AF3F9AD2C7F9"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2014/02/21/2", "source": "security@debian.org"}, {"url": "https://github.com/jenkinsci/jenkins/commit/36342d71e29e0620f803a7470ce96c61761648d8", "source": "security@debian.org", "tags": ["Patch"]}, {"url": "https://wiki.jenkins-ci.org/display/SECURITY/Jenkins+Security+Advisory+2014-02-14", "source": "security@debian.org", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/jenkinsci/jenkins/commit/36342d71e29e0620f803a7470ce96c61761648d8"}}