{"buggy_code": ["import { describe, expect, it } from 'vitest'\nimport { deepMerge, objectMap } from './object'\n\nit('objectMap', () => {\n  expect(objectMap({}, (...args) => args)).toEqual({})\n\n  expect(\n    objectMap(\n      { a: 1, b: 2 },\n      (k, v) => [k.toString().toUpperCase(), v.toString()],\n    ),\n  ).toEqual({ A: '1', B: '2' })\n\n  expect(\n    objectMap(\n      { a: 1, b: 2 },\n      () => undefined,\n    ),\n  ).toEqual({})\n\n  expect(\n    objectMap(\n      { a: 1, b: 2 },\n      (k, v) => k === 'a' ? undefined : [k, v],\n    ),\n  ).toEqual({ b: 2 })\n\n  expect(\n    objectMap(\n      { a: 1, b: 2 },\n      (k, v) => [v, k],\n    ),\n  ).toEqual({ 1: 'a', 2: 'b' })\n})\n\ndescribe('deepMerge', () => {\n  it('should merge Objects and all nested Ones', () => {\n    const obj1 = { a: { a1: 'A1' }, c: 'C', d: {} }\n    const obj2 = { a: { a2: 'A2' }, b: { b1: 'B1' }, d: null } as any\n    const obj3 = { a: { a1: 'A1', a2: 'A2' }, b: { b1: 'B1' }, c: 'C', d: null }\n    expect(deepMerge({}, obj1, obj2)).toEqual(obj3)\n  })\n  it('should behave like Object.assign on the top level', () => {\n    const obj1 = { a: { a1: 'A1' }, c: 'C' }\n    const obj2 = { a: undefined, b: { b1: 'B1' } }\n    const merged = deepMerge(obj1, obj2)\n    expect(merged).toEqual(Object.assign({}, obj1, obj2))\n  })\n  it('should not merge array values, just override', () => {\n    const obj1 = { a: ['A', 'B'] }\n    const obj2 = { a: ['C'], b: ['D'] }\n    expect(deepMerge({}, obj1, obj2)).toEqual({ a: ['C'], b: ['D'] })\n  })\n})\n", "import { notNullish } from './guards'\nimport { isObject } from './is'\nimport type { DeepMerge } from './types'\n\n/**\n * Map key/value pairs for an object, and construct a new one\n *\n *\n * @category Object\n *\n * Transform:\n * @example\n * ```\n * objectMap({ a: 1, b: 2 }, (k, v) => [k.toString().toUpperCase(), v.toString()])\n * // { A: '1', B: '2' }\n * ```\n *\n * Swap key/value:\n * @example\n * ```\n * objectMap({ a: 1, b: 2 }, (k, v) => [v, k])\n * // { 1: 'a', 2: 'b' }\n * ```\n *\n * Filter keys:\n * @example\n * ```\n * objectMap({ a: 1, b: 2 }, (k, v) => k === 'a' ? undefined : [k, v])\n * // { b: 2 }\n * ```\n */\nexport function objectMap<K extends string, V, NK = K, NV = V>(obj: Record<K, V>, fn: (key: K, value: V) => [NK, NV] | undefined): Record<K, V> {\n  return Object.fromEntries(\n    Object.entries(obj)\n      .map(([k, v]) => fn(k as K, v as V))\n      .filter(notNullish),\n  )\n}\n\n/**\n * Type guard for any key, `k`.\n * Marks `k` as a key of `T` if `k` is in `obj`.\n *\n * @category Object\n * @param obj object to query for key `k`\n * @param k key to check existence in `obj`\n */\nexport function isKeyOf<T extends object>(obj: T, k: keyof any): k is keyof T {\n  return k in obj\n}\n\n/**\n * Strict typed `Object.keys`\n *\n * @category Object\n */\nexport function objectKeys<T extends object>(obj: T) {\n  return Object.keys(obj) as Array<`${keyof T & (string | number | boolean | null | undefined)}`>\n}\n\n/**\n * Strict typed `Object.entries`\n *\n * @category Object\n */\nexport function objectEntries<T extends object>(obj: T) {\n  return Object.entries(obj) as Array<[keyof T, T[keyof T]]>\n}\n\n/**\n * Deep merge :P\n *\n * @category Object\n */\nexport function deepMerge<T extends object = object, S extends object = T>(target: T, ...sources: S[]): DeepMerge<T, S> {\n  if (!sources.length)\n    return target as any\n\n  const source = sources.shift()\n  if (source === undefined)\n    return target as any\n\n  if (isMergableObject(target) && isMergableObject(source)) {\n    objectKeys(source).forEach((key) => {\n      // @ts-expect-error\n      if (isMergableObject(source[key])) {\n        // @ts-expect-error\n        if (!target[key])\n          // @ts-expect-error\n          target[key] = {}\n\n        // @ts-expect-error\n        deepMerge(target[key], source[key])\n      }\n      else {\n        // @ts-expect-error\n        target[key] = source[key]\n      }\n    })\n  }\n\n  return deepMerge(target, ...sources)\n}\n\nfunction isMergableObject(item: any): item is Object {\n  return isObject(item) && !Array.isArray(item)\n}\n\n/**\n * Create a new subset object by giving keys\n *\n * @category Object\n */\nexport function objectPick<O extends object, T extends keyof O>(obj: O, keys: T[], omitUndefined = false) {\n  return keys.reduce((n, k) => {\n    if (k in obj) {\n      if (!omitUndefined || obj[k] !== undefined)\n        n[k] = obj[k]\n    }\n    return n\n  }, {} as Pick<O, T>)\n}\n\n/**\n * Clear undefined fields from an object. It mutates the object\n *\n * @category Object\n */\nexport function clearUndefined<T extends object>(obj: T): T {\n  // @ts-expect-error\n  Object.keys(obj).forEach((key: string) => (obj[key] === undefined ? delete obj[key] : {}))\n  return obj\n}\n\n/**\n * Determines whether an object has a property with the specified name\n *\n * @see https://eslint.org/docs/rules/no-prototype-builtins\n * @category Object\n */\nexport function hasOwnProperty<T>(obj: T, v: PropertyKey) {\n  if (obj == null)\n    return false\n  return Object.prototype.hasOwnProperty.call(obj, v)\n}\n"], "fixing_code": ["import { describe, expect, it } from 'vitest'\nimport { deepMerge, objectMap } from './object'\n\nit('objectMap', () => {\n  expect(objectMap({}, (...args) => args)).toEqual({})\n\n  expect(\n    objectMap(\n      { a: 1, b: 2 },\n      (k, v) => [k.toString().toUpperCase(), v.toString()],\n    ),\n  ).toEqual({ A: '1', B: '2' })\n\n  expect(\n    objectMap(\n      { a: 1, b: 2 },\n      () => undefined,\n    ),\n  ).toEqual({})\n\n  expect(\n    objectMap(\n      { a: 1, b: 2 },\n      (k, v) => k === 'a' ? undefined : [k, v],\n    ),\n  ).toEqual({ b: 2 })\n\n  expect(\n    objectMap(\n      { a: 1, b: 2 },\n      (k, v) => [v, k],\n    ),\n  ).toEqual({ 1: 'a', 2: 'b' })\n})\n\ndescribe('deepMerge', () => {\n  it('should merge Objects and all nested Ones', () => {\n    const obj1 = { a: { a1: 'A1' }, c: 'C', d: {} }\n    const obj2 = { a: { a2: 'A2' }, b: { b1: 'B1' }, d: null } as any\n    const obj3 = { a: { a1: 'A1', a2: 'A2' }, b: { b1: 'B1' }, c: 'C', d: null }\n    expect(deepMerge({}, obj1, obj2)).toEqual(obj3)\n  })\n  it('should behave like Object.assign on the top level', () => {\n    const obj1 = { a: { a1: 'A1' }, c: 'C' }\n    const obj2 = { a: undefined, b: { b1: 'B1' } }\n    const merged = deepMerge(obj1, obj2)\n    expect(merged).toEqual(Object.assign({}, obj1, obj2))\n  })\n  it('should not merge array values, just override', () => {\n    const obj1 = { a: ['A', 'B'] }\n    const obj2 = { a: ['C'], b: ['D'] }\n    expect(deepMerge({}, obj1, obj2)).toEqual({ a: ['C'], b: ['D'] })\n  })\n\n  it('prototype pollution 1', () => {\n    const obj = {} as any\n    const obj2 = {} as any\n    const payload = JSON.parse('{\"__proto__\":{\"polluted\":\"Polluted!\"}}')\n\n    expect(obj.polluted).toBeUndefined()\n    expect(obj2.polluted).toBeUndefined()\n    deepMerge(obj, payload)\n    expect(obj.polluted).toBeUndefined()\n    expect(obj2.polluted).toBeUndefined()\n  })\n})\n", "import { notNullish } from './guards'\nimport { isObject } from './is'\nimport type { DeepMerge } from './types'\n\n/**\n * Map key/value pairs for an object, and construct a new one\n *\n *\n * @category Object\n *\n * Transform:\n * @example\n * ```\n * objectMap({ a: 1, b: 2 }, (k, v) => [k.toString().toUpperCase(), v.toString()])\n * // { A: '1', B: '2' }\n * ```\n *\n * Swap key/value:\n * @example\n * ```\n * objectMap({ a: 1, b: 2 }, (k, v) => [v, k])\n * // { 1: 'a', 2: 'b' }\n * ```\n *\n * Filter keys:\n * @example\n * ```\n * objectMap({ a: 1, b: 2 }, (k, v) => k === 'a' ? undefined : [k, v])\n * // { b: 2 }\n * ```\n */\nexport function objectMap<K extends string, V, NK = K, NV = V>(obj: Record<K, V>, fn: (key: K, value: V) => [NK, NV] | undefined): Record<K, V> {\n  return Object.fromEntries(\n    Object.entries(obj)\n      .map(([k, v]) => fn(k as K, v as V))\n      .filter(notNullish),\n  )\n}\n\n/**\n * Type guard for any key, `k`.\n * Marks `k` as a key of `T` if `k` is in `obj`.\n *\n * @category Object\n * @param obj object to query for key `k`\n * @param k key to check existence in `obj`\n */\nexport function isKeyOf<T extends object>(obj: T, k: keyof any): k is keyof T {\n  return k in obj\n}\n\n/**\n * Strict typed `Object.keys`\n *\n * @category Object\n */\nexport function objectKeys<T extends object>(obj: T) {\n  return Object.keys(obj) as Array<`${keyof T & (string | number | boolean | null | undefined)}`>\n}\n\n/**\n * Strict typed `Object.entries`\n *\n * @category Object\n */\nexport function objectEntries<T extends object>(obj: T) {\n  return Object.entries(obj) as Array<[keyof T, T[keyof T]]>\n}\n\n/**\n * Deep merge :P\n *\n * @category Object\n */\nexport function deepMerge<T extends object = object, S extends object = T>(target: T, ...sources: S[]): DeepMerge<T, S> {\n  if (!sources.length)\n    return target as any\n\n  const source = sources.shift()\n  if (source === undefined)\n    return target as any\n\n  if (isMergableObject(target) && isMergableObject(source)) {\n    objectKeys(source).forEach((key) => {\n      if (key === '__proto__' || key === 'constructor' || key === 'prototype')\n        return\n\n      // @ts-expect-error\n      if (isMergableObject(source[key])) {\n        // @ts-expect-error\n        if (!target[key])\n          // @ts-expect-error\n          target[key] = {}\n\n        // @ts-expect-error\n        deepMerge(target[key], source[key])\n      }\n      else {\n        // @ts-expect-error\n        target[key] = source[key]\n      }\n    })\n  }\n\n  return deepMerge(target, ...sources)\n}\n\nfunction isMergableObject(item: any): item is Object {\n  return isObject(item) && !Array.isArray(item)\n}\n\n/**\n * Create a new subset object by giving keys\n *\n * @category Object\n */\nexport function objectPick<O extends object, T extends keyof O>(obj: O, keys: T[], omitUndefined = false) {\n  return keys.reduce((n, k) => {\n    if (k in obj) {\n      if (!omitUndefined || obj[k] !== undefined)\n        n[k] = obj[k]\n    }\n    return n\n  }, {} as Pick<O, T>)\n}\n\n/**\n * Clear undefined fields from an object. It mutates the object\n *\n * @category Object\n */\nexport function clearUndefined<T extends object>(obj: T): T {\n  // @ts-expect-error\n  Object.keys(obj).forEach((key: string) => (obj[key] === undefined ? delete obj[key] : {}))\n  return obj\n}\n\n/**\n * Determines whether an object has a property with the specified name\n *\n * @see https://eslint.org/docs/rules/no-prototype-builtins\n * @category Object\n */\nexport function hasOwnProperty<T>(obj: T, v: PropertyKey) {\n  if (obj == null)\n    return false\n  return Object.prototype.hasOwnProperty.call(obj, v)\n}\n"], "filenames": ["src/object.test.ts", "src/object.ts"], "buggy_code_start_loc": [53, 84], "buggy_code_end_loc": [53, 84], "fixing_code_start_loc": [54, 85], "fixing_code_end_loc": [66, 88], "type": "CWE-1321", "message": "Prototype Pollution in GitHub repository antfu/utils prior to 0.7.3.", "other": {"cve": {"id": "CVE-2023-2972", "sourceIdentifier": "security@huntr.dev", "published": "2023-05-30T11:15:09.373", "lastModified": "2023-06-05T16:44:03.170", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Prototype Pollution in GitHub repository antfu/utils prior to 0.7.3."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.5}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-1321"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:utils_project:utils:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.7.3", "matchCriteriaId": "804F67C3-14D1-4E7A-82F5-BC2EFFFFAB73"}]}]}], "references": [{"url": "https://github.com/antfu/utils/commit/7f8b16c6181c988bdb96613fbb2533b345f68682", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/009f1cd9-401c-49a7-bd08-be35cff6faef", "source": "security@huntr.dev", "tags": ["Exploit", "Patch"]}]}, "github_commit_url": "https://github.com/antfu/utils/commit/7f8b16c6181c988bdb96613fbb2533b345f68682"}}