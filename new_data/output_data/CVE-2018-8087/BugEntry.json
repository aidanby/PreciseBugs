{"buggy_code": ["/*\n * mac80211_hwsim - software simulator of 802.11 radio(s) for mac80211\n * Copyright (c) 2008, Jouni Malinen <j@w1.fi>\n * Copyright (c) 2011, Javier Lopez <jlopex@gmail.com>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation.\n */\n\n/*\n * TODO:\n * - Add TSF sync and fix IBSS beacon transmission by adding\n *   competition for \"air time\" at TBTT\n * - RX filtering based on filter configuration (data->rx_filter)\n */\n\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <net/dst.h>\n#include <net/xfrm.h>\n#include <net/mac80211.h>\n#include <net/ieee80211_radiotap.h>\n#include <linux/if_arp.h>\n#include <linux/rtnetlink.h>\n#include <linux/etherdevice.h>\n#include <linux/platform_device.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/ktime.h>\n#include <net/genetlink.h>\n#include <net/net_namespace.h>\n#include <net/netns/generic.h>\n#include <linux/rhashtable.h>\n#include \"mac80211_hwsim.h\"\n\n#define WARN_QUEUE 100\n#define MAX_QUEUE 200\n\nMODULE_AUTHOR(\"Jouni Malinen\");\nMODULE_DESCRIPTION(\"Software simulator of 802.11 radio(s) for mac80211\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int radios = 2;\nmodule_param(radios, int, 0444);\nMODULE_PARM_DESC(radios, \"Number of simulated radios\");\n\nstatic int channels = 1;\nmodule_param(channels, int, 0444);\nMODULE_PARM_DESC(channels, \"Number of concurrent channels\");\n\nstatic bool paged_rx = false;\nmodule_param(paged_rx, bool, 0644);\nMODULE_PARM_DESC(paged_rx, \"Use paged SKBs for RX instead of linear ones\");\n\nstatic bool rctbl = false;\nmodule_param(rctbl, bool, 0444);\nMODULE_PARM_DESC(rctbl, \"Handle rate control table\");\n\nstatic bool support_p2p_device = true;\nmodule_param(support_p2p_device, bool, 0444);\nMODULE_PARM_DESC(support_p2p_device, \"Support P2P-Device interface type\");\n\n/**\n * enum hwsim_regtest - the type of regulatory tests we offer\n *\n * These are the different values you can use for the regtest\n * module parameter. This is useful to help test world roaming\n * and the driver regulatory_hint() call and combinations of these.\n * If you want to do specific alpha2 regulatory domain tests simply\n * use the userspace regulatory request as that will be respected as\n * well without the need of this module parameter. This is designed\n * only for testing the driver regulatory request, world roaming\n * and all possible combinations.\n *\n * @HWSIM_REGTEST_DISABLED: No regulatory tests are performed,\n * \tthis is the default value.\n * @HWSIM_REGTEST_DRIVER_REG_FOLLOW: Used for testing the driver regulatory\n *\thint, only one driver regulatory hint will be sent as such the\n * \tsecondary radios are expected to follow.\n * @HWSIM_REGTEST_DRIVER_REG_ALL: Used for testing the driver regulatory\n * \trequest with all radios reporting the same regulatory domain.\n * @HWSIM_REGTEST_DIFF_COUNTRY: Used for testing the drivers calling\n * \tdifferent regulatory domains requests. Expected behaviour is for\n * \tan intersection to occur but each device will still use their\n * \trespective regulatory requested domains. Subsequent radios will\n * \tuse the resulting intersection.\n * @HWSIM_REGTEST_WORLD_ROAM: Used for testing the world roaming. We accomplish\n *\tthis by using a custom beacon-capable regulatory domain for the first\n *\tradio. All other device world roam.\n * @HWSIM_REGTEST_CUSTOM_WORLD: Used for testing the custom world regulatory\n * \tdomain requests. All radios will adhere to this custom world regulatory\n * \tdomain.\n * @HWSIM_REGTEST_CUSTOM_WORLD_2: Used for testing 2 custom world regulatory\n * \tdomain requests. The first radio will adhere to the first custom world\n * \tregulatory domain, the second one to the second custom world regulatory\n * \tdomain. All other devices will world roam.\n * @HWSIM_REGTEST_STRICT_FOLLOW_: Used for testing strict regulatory domain\n *\tsettings, only the first radio will send a regulatory domain request\n *\tand use strict settings. The rest of the radios are expected to follow.\n * @HWSIM_REGTEST_STRICT_ALL: Used for testing strict regulatory domain\n *\tsettings. All radios will adhere to this.\n * @HWSIM_REGTEST_STRICT_AND_DRIVER_REG: Used for testing strict regulatory\n *\tdomain settings, combined with secondary driver regulatory domain\n *\tsettings. The first radio will get a strict regulatory domain setting\n *\tusing the first driver regulatory request and the second radio will use\n *\tnon-strict settings using the second driver regulatory request. All\n *\tother devices should follow the intersection created between the\n *\tfirst two.\n * @HWSIM_REGTEST_ALL: Used for testing every possible mix. You will need\n * \tat least 6 radios for a complete test. We will test in this order:\n * \t1 - driver custom world regulatory domain\n * \t2 - second custom world regulatory domain\n * \t3 - first driver regulatory domain request\n * \t4 - second driver regulatory domain request\n * \t5 - strict regulatory domain settings using the third driver regulatory\n * \t    domain request\n * \t6 and on - should follow the intersection of the 3rd, 4rth and 5th radio\n * \t           regulatory requests.\n */\nenum hwsim_regtest {\n\tHWSIM_REGTEST_DISABLED = 0,\n\tHWSIM_REGTEST_DRIVER_REG_FOLLOW = 1,\n\tHWSIM_REGTEST_DRIVER_REG_ALL = 2,\n\tHWSIM_REGTEST_DIFF_COUNTRY = 3,\n\tHWSIM_REGTEST_WORLD_ROAM = 4,\n\tHWSIM_REGTEST_CUSTOM_WORLD = 5,\n\tHWSIM_REGTEST_CUSTOM_WORLD_2 = 6,\n\tHWSIM_REGTEST_STRICT_FOLLOW = 7,\n\tHWSIM_REGTEST_STRICT_ALL = 8,\n\tHWSIM_REGTEST_STRICT_AND_DRIVER_REG = 9,\n\tHWSIM_REGTEST_ALL = 10,\n};\n\n/* Set to one of the HWSIM_REGTEST_* values above */\nstatic int regtest = HWSIM_REGTEST_DISABLED;\nmodule_param(regtest, int, 0444);\nMODULE_PARM_DESC(regtest, \"The type of regulatory test we want to run\");\n\nstatic const char *hwsim_alpha2s[] = {\n\t\"FI\",\n\t\"AL\",\n\t\"US\",\n\t\"DE\",\n\t\"JP\",\n\t\"AL\",\n};\n\nstatic const struct ieee80211_regdomain hwsim_world_regdom_custom_01 = {\n\t.n_reg_rules = 4,\n\t.alpha2 =  \"99\",\n\t.reg_rules = {\n\t\tREG_RULE(2412-10, 2462+10, 40, 0, 20, 0),\n\t\tREG_RULE(2484-10, 2484+10, 40, 0, 20, 0),\n\t\tREG_RULE(5150-10, 5240+10, 40, 0, 30, 0),\n\t\tREG_RULE(5745-10, 5825+10, 40, 0, 30, 0),\n\t}\n};\n\nstatic const struct ieee80211_regdomain hwsim_world_regdom_custom_02 = {\n\t.n_reg_rules = 2,\n\t.alpha2 =  \"99\",\n\t.reg_rules = {\n\t\tREG_RULE(2412-10, 2462+10, 40, 0, 20, 0),\n\t\tREG_RULE(5725-10, 5850+10, 40, 0, 30,\n\t\t\t NL80211_RRF_NO_IR),\n\t}\n};\n\nstatic const struct ieee80211_regdomain *hwsim_world_regdom_custom[] = {\n\t&hwsim_world_regdom_custom_01,\n\t&hwsim_world_regdom_custom_02,\n};\n\nstruct hwsim_vif_priv {\n\tu32 magic;\n\tu8 bssid[ETH_ALEN];\n\tbool assoc;\n\tbool bcn_en;\n\tu16 aid;\n};\n\n#define HWSIM_VIF_MAGIC\t0x69537748\n\nstatic inline void hwsim_check_magic(struct ieee80211_vif *vif)\n{\n\tstruct hwsim_vif_priv *vp = (void *)vif->drv_priv;\n\tWARN(vp->magic != HWSIM_VIF_MAGIC,\n\t     \"Invalid VIF (%p) magic %#x, %pM, %d/%d\\n\",\n\t     vif, vp->magic, vif->addr, vif->type, vif->p2p);\n}\n\nstatic inline void hwsim_set_magic(struct ieee80211_vif *vif)\n{\n\tstruct hwsim_vif_priv *vp = (void *)vif->drv_priv;\n\tvp->magic = HWSIM_VIF_MAGIC;\n}\n\nstatic inline void hwsim_clear_magic(struct ieee80211_vif *vif)\n{\n\tstruct hwsim_vif_priv *vp = (void *)vif->drv_priv;\n\tvp->magic = 0;\n}\n\nstruct hwsim_sta_priv {\n\tu32 magic;\n};\n\n#define HWSIM_STA_MAGIC\t0x6d537749\n\nstatic inline void hwsim_check_sta_magic(struct ieee80211_sta *sta)\n{\n\tstruct hwsim_sta_priv *sp = (void *)sta->drv_priv;\n\tWARN_ON(sp->magic != HWSIM_STA_MAGIC);\n}\n\nstatic inline void hwsim_set_sta_magic(struct ieee80211_sta *sta)\n{\n\tstruct hwsim_sta_priv *sp = (void *)sta->drv_priv;\n\tsp->magic = HWSIM_STA_MAGIC;\n}\n\nstatic inline void hwsim_clear_sta_magic(struct ieee80211_sta *sta)\n{\n\tstruct hwsim_sta_priv *sp = (void *)sta->drv_priv;\n\tsp->magic = 0;\n}\n\nstruct hwsim_chanctx_priv {\n\tu32 magic;\n};\n\n#define HWSIM_CHANCTX_MAGIC 0x6d53774a\n\nstatic inline void hwsim_check_chanctx_magic(struct ieee80211_chanctx_conf *c)\n{\n\tstruct hwsim_chanctx_priv *cp = (void *)c->drv_priv;\n\tWARN_ON(cp->magic != HWSIM_CHANCTX_MAGIC);\n}\n\nstatic inline void hwsim_set_chanctx_magic(struct ieee80211_chanctx_conf *c)\n{\n\tstruct hwsim_chanctx_priv *cp = (void *)c->drv_priv;\n\tcp->magic = HWSIM_CHANCTX_MAGIC;\n}\n\nstatic inline void hwsim_clear_chanctx_magic(struct ieee80211_chanctx_conf *c)\n{\n\tstruct hwsim_chanctx_priv *cp = (void *)c->drv_priv;\n\tcp->magic = 0;\n}\n\nstatic unsigned int hwsim_net_id;\n\nstatic int hwsim_netgroup;\n\nstruct hwsim_net {\n\tint netgroup;\n\tu32 wmediumd;\n};\n\nstatic inline int hwsim_net_get_netgroup(struct net *net)\n{\n\tstruct hwsim_net *hwsim_net = net_generic(net, hwsim_net_id);\n\n\treturn hwsim_net->netgroup;\n}\n\nstatic inline void hwsim_net_set_netgroup(struct net *net)\n{\n\tstruct hwsim_net *hwsim_net = net_generic(net, hwsim_net_id);\n\n\thwsim_net->netgroup = hwsim_netgroup++;\n}\n\nstatic inline u32 hwsim_net_get_wmediumd(struct net *net)\n{\n\tstruct hwsim_net *hwsim_net = net_generic(net, hwsim_net_id);\n\n\treturn hwsim_net->wmediumd;\n}\n\nstatic inline void hwsim_net_set_wmediumd(struct net *net, u32 portid)\n{\n\tstruct hwsim_net *hwsim_net = net_generic(net, hwsim_net_id);\n\n\thwsim_net->wmediumd = portid;\n}\n\nstatic struct class *hwsim_class;\n\nstatic struct net_device *hwsim_mon; /* global monitor netdev */\n\n#define CHAN2G(_freq)  { \\\n\t.band = NL80211_BAND_2GHZ, \\\n\t.center_freq = (_freq), \\\n\t.hw_value = (_freq), \\\n\t.max_power = 20, \\\n}\n\n#define CHAN5G(_freq) { \\\n\t.band = NL80211_BAND_5GHZ, \\\n\t.center_freq = (_freq), \\\n\t.hw_value = (_freq), \\\n\t.max_power = 20, \\\n}\n\nstatic const struct ieee80211_channel hwsim_channels_2ghz[] = {\n\tCHAN2G(2412), /* Channel 1 */\n\tCHAN2G(2417), /* Channel 2 */\n\tCHAN2G(2422), /* Channel 3 */\n\tCHAN2G(2427), /* Channel 4 */\n\tCHAN2G(2432), /* Channel 5 */\n\tCHAN2G(2437), /* Channel 6 */\n\tCHAN2G(2442), /* Channel 7 */\n\tCHAN2G(2447), /* Channel 8 */\n\tCHAN2G(2452), /* Channel 9 */\n\tCHAN2G(2457), /* Channel 10 */\n\tCHAN2G(2462), /* Channel 11 */\n\tCHAN2G(2467), /* Channel 12 */\n\tCHAN2G(2472), /* Channel 13 */\n\tCHAN2G(2484), /* Channel 14 */\n};\n\nstatic const struct ieee80211_channel hwsim_channels_5ghz[] = {\n\tCHAN5G(5180), /* Channel 36 */\n\tCHAN5G(5200), /* Channel 40 */\n\tCHAN5G(5220), /* Channel 44 */\n\tCHAN5G(5240), /* Channel 48 */\n\n\tCHAN5G(5260), /* Channel 52 */\n\tCHAN5G(5280), /* Channel 56 */\n\tCHAN5G(5300), /* Channel 60 */\n\tCHAN5G(5320), /* Channel 64 */\n\n\tCHAN5G(5500), /* Channel 100 */\n\tCHAN5G(5520), /* Channel 104 */\n\tCHAN5G(5540), /* Channel 108 */\n\tCHAN5G(5560), /* Channel 112 */\n\tCHAN5G(5580), /* Channel 116 */\n\tCHAN5G(5600), /* Channel 120 */\n\tCHAN5G(5620), /* Channel 124 */\n\tCHAN5G(5640), /* Channel 128 */\n\tCHAN5G(5660), /* Channel 132 */\n\tCHAN5G(5680), /* Channel 136 */\n\tCHAN5G(5700), /* Channel 140 */\n\n\tCHAN5G(5745), /* Channel 149 */\n\tCHAN5G(5765), /* Channel 153 */\n\tCHAN5G(5785), /* Channel 157 */\n\tCHAN5G(5805), /* Channel 161 */\n\tCHAN5G(5825), /* Channel 165 */\n\tCHAN5G(5845), /* Channel 169 */\n};\n\nstatic const struct ieee80211_rate hwsim_rates[] = {\n\t{ .bitrate = 10 },\n\t{ .bitrate = 20, .flags = IEEE80211_RATE_SHORT_PREAMBLE },\n\t{ .bitrate = 55, .flags = IEEE80211_RATE_SHORT_PREAMBLE },\n\t{ .bitrate = 110, .flags = IEEE80211_RATE_SHORT_PREAMBLE },\n\t{ .bitrate = 60 },\n\t{ .bitrate = 90 },\n\t{ .bitrate = 120 },\n\t{ .bitrate = 180 },\n\t{ .bitrate = 240 },\n\t{ .bitrate = 360 },\n\t{ .bitrate = 480 },\n\t{ .bitrate = 540 }\n};\n\n#define OUI_QCA 0x001374\n#define QCA_NL80211_SUBCMD_TEST 1\nenum qca_nl80211_vendor_subcmds {\n\tQCA_WLAN_VENDOR_ATTR_TEST = 8,\n\tQCA_WLAN_VENDOR_ATTR_MAX = QCA_WLAN_VENDOR_ATTR_TEST\n};\n\nstatic const struct nla_policy\nhwsim_vendor_test_policy[QCA_WLAN_VENDOR_ATTR_MAX + 1] = {\n\t[QCA_WLAN_VENDOR_ATTR_MAX] = { .type = NLA_U32 },\n};\n\nstatic int mac80211_hwsim_vendor_cmd_test(struct wiphy *wiphy,\n\t\t\t\t\t  struct wireless_dev *wdev,\n\t\t\t\t\t  const void *data, int data_len)\n{\n\tstruct sk_buff *skb;\n\tstruct nlattr *tb[QCA_WLAN_VENDOR_ATTR_MAX + 1];\n\tint err;\n\tu32 val;\n\n\terr = nla_parse(tb, QCA_WLAN_VENDOR_ATTR_MAX, data, data_len,\n\t\t\thwsim_vendor_test_policy, NULL);\n\tif (err)\n\t\treturn err;\n\tif (!tb[QCA_WLAN_VENDOR_ATTR_TEST])\n\t\treturn -EINVAL;\n\tval = nla_get_u32(tb[QCA_WLAN_VENDOR_ATTR_TEST]);\n\twiphy_dbg(wiphy, \"%s: test=%u\\n\", __func__, val);\n\n\t/* Send a vendor event as a test. Note that this would not normally be\n\t * done within a command handler, but rather, based on some other\n\t * trigger. For simplicity, this command is used to trigger the event\n\t * here.\n\t *\n\t * event_idx = 0 (index in mac80211_hwsim_vendor_commands)\n\t */\n\tskb = cfg80211_vendor_event_alloc(wiphy, wdev, 100, 0, GFP_KERNEL);\n\tif (skb) {\n\t\t/* skb_put() or nla_put() will fill up data within\n\t\t * NL80211_ATTR_VENDOR_DATA.\n\t\t */\n\n\t\t/* Add vendor data */\n\t\tnla_put_u32(skb, QCA_WLAN_VENDOR_ATTR_TEST, val + 1);\n\n\t\t/* Send the event - this will call nla_nest_end() */\n\t\tcfg80211_vendor_event(skb, GFP_KERNEL);\n\t}\n\n\t/* Send a response to the command */\n\tskb = cfg80211_vendor_cmd_alloc_reply_skb(wiphy, 10);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\t/* skb_put() or nla_put() will fill up data within\n\t * NL80211_ATTR_VENDOR_DATA\n\t */\n\tnla_put_u32(skb, QCA_WLAN_VENDOR_ATTR_TEST, val + 2);\n\n\treturn cfg80211_vendor_cmd_reply(skb);\n}\n\nstatic struct wiphy_vendor_command mac80211_hwsim_vendor_commands[] = {\n\t{\n\t\t.info = { .vendor_id = OUI_QCA,\n\t\t\t  .subcmd = QCA_NL80211_SUBCMD_TEST },\n\t\t.flags = WIPHY_VENDOR_CMD_NEED_NETDEV,\n\t\t.doit = mac80211_hwsim_vendor_cmd_test,\n\t}\n};\n\n/* Advertise support vendor specific events */\nstatic const struct nl80211_vendor_cmd_info mac80211_hwsim_vendor_events[] = {\n\t{ .vendor_id = OUI_QCA, .subcmd = 1 },\n};\n\nstatic const struct ieee80211_iface_limit hwsim_if_limits[] = {\n\t{ .max = 1, .types = BIT(NL80211_IFTYPE_ADHOC) },\n\t{ .max = 2048,  .types = BIT(NL80211_IFTYPE_STATION) |\n\t\t\t\t BIT(NL80211_IFTYPE_P2P_CLIENT) |\n#ifdef CONFIG_MAC80211_MESH\n\t\t\t\t BIT(NL80211_IFTYPE_MESH_POINT) |\n#endif\n\t\t\t\t BIT(NL80211_IFTYPE_AP) |\n\t\t\t\t BIT(NL80211_IFTYPE_P2P_GO) },\n\t/* must be last, see hwsim_if_comb */\n\t{ .max = 1, .types = BIT(NL80211_IFTYPE_P2P_DEVICE) }\n};\n\nstatic const struct ieee80211_iface_combination hwsim_if_comb[] = {\n\t{\n\t\t.limits = hwsim_if_limits,\n\t\t/* remove the last entry which is P2P_DEVICE */\n\t\t.n_limits = ARRAY_SIZE(hwsim_if_limits) - 1,\n\t\t.max_interfaces = 2048,\n\t\t.num_different_channels = 1,\n\t\t.radar_detect_widths = BIT(NL80211_CHAN_WIDTH_20_NOHT) |\n\t\t\t\t       BIT(NL80211_CHAN_WIDTH_20) |\n\t\t\t\t       BIT(NL80211_CHAN_WIDTH_40) |\n\t\t\t\t       BIT(NL80211_CHAN_WIDTH_80) |\n\t\t\t\t       BIT(NL80211_CHAN_WIDTH_160),\n\t},\n};\n\nstatic const struct ieee80211_iface_combination hwsim_if_comb_p2p_dev[] = {\n\t{\n\t\t.limits = hwsim_if_limits,\n\t\t.n_limits = ARRAY_SIZE(hwsim_if_limits),\n\t\t.max_interfaces = 2048,\n\t\t.num_different_channels = 1,\n\t\t.radar_detect_widths = BIT(NL80211_CHAN_WIDTH_20_NOHT) |\n\t\t\t\t       BIT(NL80211_CHAN_WIDTH_20) |\n\t\t\t\t       BIT(NL80211_CHAN_WIDTH_40) |\n\t\t\t\t       BIT(NL80211_CHAN_WIDTH_80) |\n\t\t\t\t       BIT(NL80211_CHAN_WIDTH_160),\n\t},\n};\n\nstatic spinlock_t hwsim_radio_lock;\nstatic LIST_HEAD(hwsim_radios);\nstatic struct rhashtable hwsim_radios_rht;\nstatic int hwsim_radio_idx;\n\nstatic struct platform_driver mac80211_hwsim_driver = {\n\t.driver = {\n\t\t.name = \"mac80211_hwsim\",\n\t},\n};\n\nstruct mac80211_hwsim_data {\n\tstruct list_head list;\n\tstruct rhash_head rht;\n\tstruct ieee80211_hw *hw;\n\tstruct device *dev;\n\tstruct ieee80211_supported_band bands[NUM_NL80211_BANDS];\n\tstruct ieee80211_channel channels_2ghz[ARRAY_SIZE(hwsim_channels_2ghz)];\n\tstruct ieee80211_channel channels_5ghz[ARRAY_SIZE(hwsim_channels_5ghz)];\n\tstruct ieee80211_rate rates[ARRAY_SIZE(hwsim_rates)];\n\tstruct ieee80211_iface_combination if_combination;\n\n\tstruct mac_address addresses[2];\n\tint channels, idx;\n\tbool use_chanctx;\n\tbool destroy_on_close;\n\tstruct work_struct destroy_work;\n\tu32 portid;\n\tchar alpha2[2];\n\tconst struct ieee80211_regdomain *regd;\n\n\tstruct ieee80211_channel *tmp_chan;\n\tstruct ieee80211_channel *roc_chan;\n\tu32 roc_duration;\n\tstruct delayed_work roc_start;\n\tstruct delayed_work roc_done;\n\tstruct delayed_work hw_scan;\n\tstruct cfg80211_scan_request *hw_scan_request;\n\tstruct ieee80211_vif *hw_scan_vif;\n\tint scan_chan_idx;\n\tu8 scan_addr[ETH_ALEN];\n\tstruct {\n\t\tstruct ieee80211_channel *channel;\n\t\tunsigned long next_start, start, end;\n\t} survey_data[ARRAY_SIZE(hwsim_channels_2ghz) +\n\t\t      ARRAY_SIZE(hwsim_channels_5ghz)];\n\n\tstruct ieee80211_channel *channel;\n\tu64 beacon_int\t/* beacon interval in us */;\n\tunsigned int rx_filter;\n\tbool started, idle, scanning;\n\tstruct mutex mutex;\n\tstruct tasklet_hrtimer beacon_timer;\n\tenum ps_mode {\n\t\tPS_DISABLED, PS_ENABLED, PS_AUTO_POLL, PS_MANUAL_POLL\n\t} ps;\n\tbool ps_poll_pending;\n\tstruct dentry *debugfs;\n\n\tuintptr_t pending_cookie;\n\tstruct sk_buff_head pending;\t/* packets pending */\n\t/*\n\t * Only radios in the same group can communicate together (the\n\t * channel has to match too). Each bit represents a group. A\n\t * radio can be in more than one group.\n\t */\n\tu64 group;\n\n\t/* group shared by radios created in the same netns */\n\tint netgroup;\n\t/* wmediumd portid responsible for netgroup of this radio */\n\tu32 wmediumd;\n\n\t/* difference between this hw's clock and the real clock, in usecs */\n\ts64 tsf_offset;\n\ts64 bcn_delta;\n\t/* absolute beacon transmission time. Used to cover up \"tx\" delay. */\n\tu64 abs_bcn_ts;\n\n\t/* Stats */\n\tu64 tx_pkts;\n\tu64 rx_pkts;\n\tu64 tx_bytes;\n\tu64 rx_bytes;\n\tu64 tx_dropped;\n\tu64 tx_failed;\n};\n\nstatic const struct rhashtable_params hwsim_rht_params = {\n\t.nelem_hint = 2,\n\t.automatic_shrinking = true,\n\t.key_len = ETH_ALEN,\n\t.key_offset = offsetof(struct mac80211_hwsim_data, addresses[1]),\n\t.head_offset = offsetof(struct mac80211_hwsim_data, rht),\n};\n\nstruct hwsim_radiotap_hdr {\n\tstruct ieee80211_radiotap_header hdr;\n\t__le64 rt_tsft;\n\tu8 rt_flags;\n\tu8 rt_rate;\n\t__le16 rt_channel;\n\t__le16 rt_chbitmask;\n} __packed;\n\nstruct hwsim_radiotap_ack_hdr {\n\tstruct ieee80211_radiotap_header hdr;\n\tu8 rt_flags;\n\tu8 pad;\n\t__le16 rt_channel;\n\t__le16 rt_chbitmask;\n} __packed;\n\n/* MAC80211_HWSIM netlink family */\nstatic struct genl_family hwsim_genl_family;\n\nenum hwsim_multicast_groups {\n\tHWSIM_MCGRP_CONFIG,\n};\n\nstatic const struct genl_multicast_group hwsim_mcgrps[] = {\n\t[HWSIM_MCGRP_CONFIG] = { .name = \"config\", },\n};\n\n/* MAC80211_HWSIM netlink policy */\n\nstatic const struct nla_policy hwsim_genl_policy[HWSIM_ATTR_MAX + 1] = {\n\t[HWSIM_ATTR_ADDR_RECEIVER] = { .type = NLA_UNSPEC, .len = ETH_ALEN },\n\t[HWSIM_ATTR_ADDR_TRANSMITTER] = { .type = NLA_UNSPEC, .len = ETH_ALEN },\n\t[HWSIM_ATTR_FRAME] = { .type = NLA_BINARY,\n\t\t\t       .len = IEEE80211_MAX_DATA_LEN },\n\t[HWSIM_ATTR_FLAGS] = { .type = NLA_U32 },\n\t[HWSIM_ATTR_RX_RATE] = { .type = NLA_U32 },\n\t[HWSIM_ATTR_SIGNAL] = { .type = NLA_U32 },\n\t[HWSIM_ATTR_TX_INFO] = { .type = NLA_UNSPEC,\n\t\t\t\t .len = IEEE80211_TX_MAX_RATES *\n\t\t\t\t\tsizeof(struct hwsim_tx_rate)},\n\t[HWSIM_ATTR_COOKIE] = { .type = NLA_U64 },\n\t[HWSIM_ATTR_CHANNELS] = { .type = NLA_U32 },\n\t[HWSIM_ATTR_RADIO_ID] = { .type = NLA_U32 },\n\t[HWSIM_ATTR_REG_HINT_ALPHA2] = { .type = NLA_STRING, .len = 2 },\n\t[HWSIM_ATTR_REG_CUSTOM_REG] = { .type = NLA_U32 },\n\t[HWSIM_ATTR_REG_STRICT_REG] = { .type = NLA_FLAG },\n\t[HWSIM_ATTR_SUPPORT_P2P_DEVICE] = { .type = NLA_FLAG },\n\t[HWSIM_ATTR_DESTROY_RADIO_ON_CLOSE] = { .type = NLA_FLAG },\n\t[HWSIM_ATTR_RADIO_NAME] = { .type = NLA_STRING },\n\t[HWSIM_ATTR_NO_VIF] = { .type = NLA_FLAG },\n\t[HWSIM_ATTR_FREQ] = { .type = NLA_U32 },\n};\n\nstatic void mac80211_hwsim_tx_frame(struct ieee80211_hw *hw,\n\t\t\t\t    struct sk_buff *skb,\n\t\t\t\t    struct ieee80211_channel *chan);\n\n/* sysfs attributes */\nstatic void hwsim_send_ps_poll(void *dat, u8 *mac, struct ieee80211_vif *vif)\n{\n\tstruct mac80211_hwsim_data *data = dat;\n\tstruct hwsim_vif_priv *vp = (void *)vif->drv_priv;\n\tstruct sk_buff *skb;\n\tstruct ieee80211_pspoll *pspoll;\n\n\tif (!vp->assoc)\n\t\treturn;\n\n\twiphy_dbg(data->hw->wiphy,\n\t\t  \"%s: send PS-Poll to %pM for aid %d\\n\",\n\t\t  __func__, vp->bssid, vp->aid);\n\n\tskb = dev_alloc_skb(sizeof(*pspoll));\n\tif (!skb)\n\t\treturn;\n\tpspoll = skb_put(skb, sizeof(*pspoll));\n\tpspoll->frame_control = cpu_to_le16(IEEE80211_FTYPE_CTL |\n\t\t\t\t\t    IEEE80211_STYPE_PSPOLL |\n\t\t\t\t\t    IEEE80211_FCTL_PM);\n\tpspoll->aid = cpu_to_le16(0xc000 | vp->aid);\n\tmemcpy(pspoll->bssid, vp->bssid, ETH_ALEN);\n\tmemcpy(pspoll->ta, mac, ETH_ALEN);\n\n\trcu_read_lock();\n\tmac80211_hwsim_tx_frame(data->hw, skb,\n\t\t\t\trcu_dereference(vif->chanctx_conf)->def.chan);\n\trcu_read_unlock();\n}\n\nstatic void hwsim_send_nullfunc(struct mac80211_hwsim_data *data, u8 *mac,\n\t\t\t\tstruct ieee80211_vif *vif, int ps)\n{\n\tstruct hwsim_vif_priv *vp = (void *)vif->drv_priv;\n\tstruct sk_buff *skb;\n\tstruct ieee80211_hdr *hdr;\n\n\tif (!vp->assoc)\n\t\treturn;\n\n\twiphy_dbg(data->hw->wiphy,\n\t\t  \"%s: send data::nullfunc to %pM ps=%d\\n\",\n\t\t  __func__, vp->bssid, ps);\n\n\tskb = dev_alloc_skb(sizeof(*hdr));\n\tif (!skb)\n\t\treturn;\n\thdr = skb_put(skb, sizeof(*hdr) - ETH_ALEN);\n\thdr->frame_control = cpu_to_le16(IEEE80211_FTYPE_DATA |\n\t\t\t\t\t IEEE80211_STYPE_NULLFUNC |\n\t\t\t\t\t IEEE80211_FCTL_TODS |\n\t\t\t\t\t (ps ? IEEE80211_FCTL_PM : 0));\n\thdr->duration_id = cpu_to_le16(0);\n\tmemcpy(hdr->addr1, vp->bssid, ETH_ALEN);\n\tmemcpy(hdr->addr2, mac, ETH_ALEN);\n\tmemcpy(hdr->addr3, vp->bssid, ETH_ALEN);\n\n\trcu_read_lock();\n\tmac80211_hwsim_tx_frame(data->hw, skb,\n\t\t\t\trcu_dereference(vif->chanctx_conf)->def.chan);\n\trcu_read_unlock();\n}\n\n\nstatic void hwsim_send_nullfunc_ps(void *dat, u8 *mac,\n\t\t\t\t   struct ieee80211_vif *vif)\n{\n\tstruct mac80211_hwsim_data *data = dat;\n\thwsim_send_nullfunc(data, mac, vif, 1);\n}\n\nstatic void hwsim_send_nullfunc_no_ps(void *dat, u8 *mac,\n\t\t\t\t      struct ieee80211_vif *vif)\n{\n\tstruct mac80211_hwsim_data *data = dat;\n\thwsim_send_nullfunc(data, mac, vif, 0);\n}\n\nstatic int hwsim_fops_ps_read(void *dat, u64 *val)\n{\n\tstruct mac80211_hwsim_data *data = dat;\n\t*val = data->ps;\n\treturn 0;\n}\n\nstatic int hwsim_fops_ps_write(void *dat, u64 val)\n{\n\tstruct mac80211_hwsim_data *data = dat;\n\tenum ps_mode old_ps;\n\n\tif (val != PS_DISABLED && val != PS_ENABLED && val != PS_AUTO_POLL &&\n\t    val != PS_MANUAL_POLL)\n\t\treturn -EINVAL;\n\n\tif (val == PS_MANUAL_POLL) {\n\t\tif (data->ps != PS_ENABLED)\n\t\t\treturn -EINVAL;\n\t\tlocal_bh_disable();\n\t\tieee80211_iterate_active_interfaces_atomic(\n\t\t\tdata->hw, IEEE80211_IFACE_ITER_NORMAL,\n\t\t\thwsim_send_ps_poll, data);\n\t\tlocal_bh_enable();\n\t\treturn 0;\n\t}\n\told_ps = data->ps;\n\tdata->ps = val;\n\n\tlocal_bh_disable();\n\tif (old_ps == PS_DISABLED && val != PS_DISABLED) {\n\t\tieee80211_iterate_active_interfaces_atomic(\n\t\t\tdata->hw, IEEE80211_IFACE_ITER_NORMAL,\n\t\t\thwsim_send_nullfunc_ps, data);\n\t} else if (old_ps != PS_DISABLED && val == PS_DISABLED) {\n\t\tieee80211_iterate_active_interfaces_atomic(\n\t\t\tdata->hw, IEEE80211_IFACE_ITER_NORMAL,\n\t\t\thwsim_send_nullfunc_no_ps, data);\n\t}\n\tlocal_bh_enable();\n\n\treturn 0;\n}\n\nDEFINE_SIMPLE_ATTRIBUTE(hwsim_fops_ps, hwsim_fops_ps_read, hwsim_fops_ps_write,\n\t\t\t\"%llu\\n\");\n\nstatic int hwsim_write_simulate_radar(void *dat, u64 val)\n{\n\tstruct mac80211_hwsim_data *data = dat;\n\n\tieee80211_radar_detected(data->hw);\n\n\treturn 0;\n}\n\nDEFINE_SIMPLE_ATTRIBUTE(hwsim_simulate_radar, NULL,\n\t\t\thwsim_write_simulate_radar, \"%llu\\n\");\n\nstatic int hwsim_fops_group_read(void *dat, u64 *val)\n{\n\tstruct mac80211_hwsim_data *data = dat;\n\t*val = data->group;\n\treturn 0;\n}\n\nstatic int hwsim_fops_group_write(void *dat, u64 val)\n{\n\tstruct mac80211_hwsim_data *data = dat;\n\tdata->group = val;\n\treturn 0;\n}\n\nDEFINE_SIMPLE_ATTRIBUTE(hwsim_fops_group,\n\t\t\thwsim_fops_group_read, hwsim_fops_group_write,\n\t\t\t\"%llx\\n\");\n\nstatic netdev_tx_t hwsim_mon_xmit(struct sk_buff *skb,\n\t\t\t\t\tstruct net_device *dev)\n{\n\t/* TODO: allow packet injection */\n\tdev_kfree_skb(skb);\n\treturn NETDEV_TX_OK;\n}\n\nstatic inline u64 mac80211_hwsim_get_tsf_raw(void)\n{\n\treturn ktime_to_us(ktime_get_real());\n}\n\nstatic __le64 __mac80211_hwsim_get_tsf(struct mac80211_hwsim_data *data)\n{\n\tu64 now = mac80211_hwsim_get_tsf_raw();\n\treturn cpu_to_le64(now + data->tsf_offset);\n}\n\nstatic u64 mac80211_hwsim_get_tsf(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_vif *vif)\n{\n\tstruct mac80211_hwsim_data *data = hw->priv;\n\treturn le64_to_cpu(__mac80211_hwsim_get_tsf(data));\n}\n\nstatic void mac80211_hwsim_set_tsf(struct ieee80211_hw *hw,\n\t\tstruct ieee80211_vif *vif, u64 tsf)\n{\n\tstruct mac80211_hwsim_data *data = hw->priv;\n\tu64 now = mac80211_hwsim_get_tsf(hw, vif);\n\tu32 bcn_int = data->beacon_int;\n\tu64 delta = abs(tsf - now);\n\n\t/* adjust after beaconing with new timestamp at old TBTT */\n\tif (tsf > now) {\n\t\tdata->tsf_offset += delta;\n\t\tdata->bcn_delta = do_div(delta, bcn_int);\n\t} else {\n\t\tdata->tsf_offset -= delta;\n\t\tdata->bcn_delta = -(s64)do_div(delta, bcn_int);\n\t}\n}\n\nstatic void mac80211_hwsim_monitor_rx(struct ieee80211_hw *hw,\n\t\t\t\t      struct sk_buff *tx_skb,\n\t\t\t\t      struct ieee80211_channel *chan)\n{\n\tstruct mac80211_hwsim_data *data = hw->priv;\n\tstruct sk_buff *skb;\n\tstruct hwsim_radiotap_hdr *hdr;\n\tu16 flags;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx_skb);\n\tstruct ieee80211_rate *txrate = ieee80211_get_tx_rate(hw, info);\n\n\tif (WARN_ON(!txrate))\n\t\treturn;\n\n\tif (!netif_running(hwsim_mon))\n\t\treturn;\n\n\tskb = skb_copy_expand(tx_skb, sizeof(*hdr), 0, GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn;\n\n\thdr = skb_push(skb, sizeof(*hdr));\n\thdr->hdr.it_version = PKTHDR_RADIOTAP_VERSION;\n\thdr->hdr.it_pad = 0;\n\thdr->hdr.it_len = cpu_to_le16(sizeof(*hdr));\n\thdr->hdr.it_present = cpu_to_le32((1 << IEEE80211_RADIOTAP_FLAGS) |\n\t\t\t\t\t  (1 << IEEE80211_RADIOTAP_RATE) |\n\t\t\t\t\t  (1 << IEEE80211_RADIOTAP_TSFT) |\n\t\t\t\t\t  (1 << IEEE80211_RADIOTAP_CHANNEL));\n\thdr->rt_tsft = __mac80211_hwsim_get_tsf(data);\n\thdr->rt_flags = 0;\n\thdr->rt_rate = txrate->bitrate / 5;\n\thdr->rt_channel = cpu_to_le16(chan->center_freq);\n\tflags = IEEE80211_CHAN_2GHZ;\n\tif (txrate->flags & IEEE80211_RATE_ERP_G)\n\t\tflags |= IEEE80211_CHAN_OFDM;\n\telse\n\t\tflags |= IEEE80211_CHAN_CCK;\n\thdr->rt_chbitmask = cpu_to_le16(flags);\n\n\tskb->dev = hwsim_mon;\n\tskb_reset_mac_header(skb);\n\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\tskb->pkt_type = PACKET_OTHERHOST;\n\tskb->protocol = htons(ETH_P_802_2);\n\tmemset(skb->cb, 0, sizeof(skb->cb));\n\tnetif_rx(skb);\n}\n\n\nstatic void mac80211_hwsim_monitor_ack(struct ieee80211_channel *chan,\n\t\t\t\t       const u8 *addr)\n{\n\tstruct sk_buff *skb;\n\tstruct hwsim_radiotap_ack_hdr *hdr;\n\tu16 flags;\n\tstruct ieee80211_hdr *hdr11;\n\n\tif (!netif_running(hwsim_mon))\n\t\treturn;\n\n\tskb = dev_alloc_skb(100);\n\tif (skb == NULL)\n\t\treturn;\n\n\thdr = skb_put(skb, sizeof(*hdr));\n\thdr->hdr.it_version = PKTHDR_RADIOTAP_VERSION;\n\thdr->hdr.it_pad = 0;\n\thdr->hdr.it_len = cpu_to_le16(sizeof(*hdr));\n\thdr->hdr.it_present = cpu_to_le32((1 << IEEE80211_RADIOTAP_FLAGS) |\n\t\t\t\t\t  (1 << IEEE80211_RADIOTAP_CHANNEL));\n\thdr->rt_flags = 0;\n\thdr->pad = 0;\n\thdr->rt_channel = cpu_to_le16(chan->center_freq);\n\tflags = IEEE80211_CHAN_2GHZ;\n\thdr->rt_chbitmask = cpu_to_le16(flags);\n\n\thdr11 = skb_put(skb, 10);\n\thdr11->frame_control = cpu_to_le16(IEEE80211_FTYPE_CTL |\n\t\t\t\t\t   IEEE80211_STYPE_ACK);\n\thdr11->duration_id = cpu_to_le16(0);\n\tmemcpy(hdr11->addr1, addr, ETH_ALEN);\n\n\tskb->dev = hwsim_mon;\n\tskb_reset_mac_header(skb);\n\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\tskb->pkt_type = PACKET_OTHERHOST;\n\tskb->protocol = htons(ETH_P_802_2);\n\tmemset(skb->cb, 0, sizeof(skb->cb));\n\tnetif_rx(skb);\n}\n\nstruct mac80211_hwsim_addr_match_data {\n\tu8 addr[ETH_ALEN];\n\tbool ret;\n};\n\nstatic void mac80211_hwsim_addr_iter(void *data, u8 *mac,\n\t\t\t\t     struct ieee80211_vif *vif)\n{\n\tstruct mac80211_hwsim_addr_match_data *md = data;\n\n\tif (memcmp(mac, md->addr, ETH_ALEN) == 0)\n\t\tmd->ret = true;\n}\n\nstatic bool mac80211_hwsim_addr_match(struct mac80211_hwsim_data *data,\n\t\t\t\t      const u8 *addr)\n{\n\tstruct mac80211_hwsim_addr_match_data md = {\n\t\t.ret = false,\n\t};\n\n\tif (data->scanning && memcmp(addr, data->scan_addr, ETH_ALEN) == 0)\n\t\treturn true;\n\n\tmemcpy(md.addr, addr, ETH_ALEN);\n\n\tieee80211_iterate_active_interfaces_atomic(data->hw,\n\t\t\t\t\t\t   IEEE80211_IFACE_ITER_NORMAL,\n\t\t\t\t\t\t   mac80211_hwsim_addr_iter,\n\t\t\t\t\t\t   &md);\n\n\treturn md.ret;\n}\n\nstatic bool hwsim_ps_rx_ok(struct mac80211_hwsim_data *data,\n\t\t\t   struct sk_buff *skb)\n{\n\tswitch (data->ps) {\n\tcase PS_DISABLED:\n\t\treturn true;\n\tcase PS_ENABLED:\n\t\treturn false;\n\tcase PS_AUTO_POLL:\n\t\t/* TODO: accept (some) Beacons by default and other frames only\n\t\t * if pending PS-Poll has been sent */\n\t\treturn true;\n\tcase PS_MANUAL_POLL:\n\t\t/* Allow unicast frames to own address if there is a pending\n\t\t * PS-Poll */\n\t\tif (data->ps_poll_pending &&\n\t\t    mac80211_hwsim_addr_match(data, skb->data + 4)) {\n\t\t\tdata->ps_poll_pending = false;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic int hwsim_unicast_netgroup(struct mac80211_hwsim_data *data,\n\t\t\t\t  struct sk_buff *skb, int portid)\n{\n\tstruct net *net;\n\tbool found = false;\n\tint res = -ENOENT;\n\n\trcu_read_lock();\n\tfor_each_net_rcu(net) {\n\t\tif (data->netgroup == hwsim_net_get_netgroup(net)) {\n\t\t\tres = genlmsg_unicast(net, skb, portid);\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tif (!found)\n\t\tnlmsg_free(skb);\n\n\treturn res;\n}\n\nstatic inline u16 trans_tx_rate_flags_ieee2hwsim(struct ieee80211_tx_rate *rate)\n{\n\tu16 result = 0;\n\n\tif (rate->flags & IEEE80211_TX_RC_USE_RTS_CTS)\n\t\tresult |= MAC80211_HWSIM_TX_RC_USE_RTS_CTS;\n\tif (rate->flags & IEEE80211_TX_RC_USE_CTS_PROTECT)\n\t\tresult |= MAC80211_HWSIM_TX_RC_USE_CTS_PROTECT;\n\tif (rate->flags & IEEE80211_TX_RC_USE_SHORT_PREAMBLE)\n\t\tresult |= MAC80211_HWSIM_TX_RC_USE_SHORT_PREAMBLE;\n\tif (rate->flags & IEEE80211_TX_RC_MCS)\n\t\tresult |= MAC80211_HWSIM_TX_RC_MCS;\n\tif (rate->flags & IEEE80211_TX_RC_GREEN_FIELD)\n\t\tresult |= MAC80211_HWSIM_TX_RC_GREEN_FIELD;\n\tif (rate->flags & IEEE80211_TX_RC_40_MHZ_WIDTH)\n\t\tresult |= MAC80211_HWSIM_TX_RC_40_MHZ_WIDTH;\n\tif (rate->flags & IEEE80211_TX_RC_DUP_DATA)\n\t\tresult |= MAC80211_HWSIM_TX_RC_DUP_DATA;\n\tif (rate->flags & IEEE80211_TX_RC_SHORT_GI)\n\t\tresult |= MAC80211_HWSIM_TX_RC_SHORT_GI;\n\tif (rate->flags & IEEE80211_TX_RC_VHT_MCS)\n\t\tresult |= MAC80211_HWSIM_TX_RC_VHT_MCS;\n\tif (rate->flags & IEEE80211_TX_RC_80_MHZ_WIDTH)\n\t\tresult |= MAC80211_HWSIM_TX_RC_80_MHZ_WIDTH;\n\tif (rate->flags & IEEE80211_TX_RC_160_MHZ_WIDTH)\n\t\tresult |= MAC80211_HWSIM_TX_RC_160_MHZ_WIDTH;\n\n\treturn result;\n}\n\nstatic void mac80211_hwsim_tx_frame_nl(struct ieee80211_hw *hw,\n\t\t\t\t       struct sk_buff *my_skb,\n\t\t\t\t       int dst_portid)\n{\n\tstruct sk_buff *skb;\n\tstruct mac80211_hwsim_data *data = hw->priv;\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) my_skb->data;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(my_skb);\n\tvoid *msg_head;\n\tunsigned int hwsim_flags = 0;\n\tint i;\n\tstruct hwsim_tx_rate tx_attempts[IEEE80211_TX_MAX_RATES];\n\tstruct hwsim_tx_rate_flag tx_attempts_flags[IEEE80211_TX_MAX_RATES];\n\tuintptr_t cookie;\n\n\tif (data->ps != PS_DISABLED)\n\t\thdr->frame_control |= cpu_to_le16(IEEE80211_FCTL_PM);\n\t/* If the queue contains MAX_QUEUE skb's drop some */\n\tif (skb_queue_len(&data->pending) >= MAX_QUEUE) {\n\t\t/* Droping until WARN_QUEUE level */\n\t\twhile (skb_queue_len(&data->pending) >= WARN_QUEUE) {\n\t\t\tieee80211_free_txskb(hw, skb_dequeue(&data->pending));\n\t\t\tdata->tx_dropped++;\n\t\t}\n\t}\n\n\tskb = genlmsg_new(GENLMSG_DEFAULT_SIZE, GFP_ATOMIC);\n\tif (skb == NULL)\n\t\tgoto nla_put_failure;\n\n\tmsg_head = genlmsg_put(skb, 0, 0, &hwsim_genl_family, 0,\n\t\t\t       HWSIM_CMD_FRAME);\n\tif (msg_head == NULL) {\n\t\tpr_debug(\"mac80211_hwsim: problem with msg_head\\n\");\n\t\tgoto nla_put_failure;\n\t}\n\n\tif (nla_put(skb, HWSIM_ATTR_ADDR_TRANSMITTER,\n\t\t    ETH_ALEN, data->addresses[1].addr))\n\t\tgoto nla_put_failure;\n\n\t/* We get the skb->data */\n\tif (nla_put(skb, HWSIM_ATTR_FRAME, my_skb->len, my_skb->data))\n\t\tgoto nla_put_failure;\n\n\t/* We get the flags for this transmission, and we translate them to\n\t   wmediumd flags  */\n\n\tif (info->flags & IEEE80211_TX_CTL_REQ_TX_STATUS)\n\t\thwsim_flags |= HWSIM_TX_CTL_REQ_TX_STATUS;\n\n\tif (info->flags & IEEE80211_TX_CTL_NO_ACK)\n\t\thwsim_flags |= HWSIM_TX_CTL_NO_ACK;\n\n\tif (nla_put_u32(skb, HWSIM_ATTR_FLAGS, hwsim_flags))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(skb, HWSIM_ATTR_FREQ, data->channel->center_freq))\n\t\tgoto nla_put_failure;\n\n\t/* We get the tx control (rate and retries) info*/\n\n\tfor (i = 0; i < IEEE80211_TX_MAX_RATES; i++) {\n\t\ttx_attempts[i].idx = info->status.rates[i].idx;\n\t\ttx_attempts_flags[i].idx = info->status.rates[i].idx;\n\t\ttx_attempts[i].count = info->status.rates[i].count;\n\t\ttx_attempts_flags[i].flags =\n\t\t\t\ttrans_tx_rate_flags_ieee2hwsim(\n\t\t\t\t\t\t&info->status.rates[i]);\n\t}\n\n\tif (nla_put(skb, HWSIM_ATTR_TX_INFO,\n\t\t    sizeof(struct hwsim_tx_rate)*IEEE80211_TX_MAX_RATES,\n\t\t    tx_attempts))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put(skb, HWSIM_ATTR_TX_INFO_FLAGS,\n\t\t    sizeof(struct hwsim_tx_rate_flag) * IEEE80211_TX_MAX_RATES,\n\t\t    tx_attempts_flags))\n\t\tgoto nla_put_failure;\n\n\t/* We create a cookie to identify this skb */\n\tdata->pending_cookie++;\n\tcookie = data->pending_cookie;\n\tinfo->rate_driver_data[0] = (void *)cookie;\n\tif (nla_put_u64_64bit(skb, HWSIM_ATTR_COOKIE, cookie, HWSIM_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(skb, msg_head);\n\tif (hwsim_unicast_netgroup(data, skb, dst_portid))\n\t\tgoto err_free_txskb;\n\n\t/* Enqueue the packet */\n\tskb_queue_tail(&data->pending, my_skb);\n\tdata->tx_pkts++;\n\tdata->tx_bytes += my_skb->len;\n\treturn;\n\nnla_put_failure:\n\tnlmsg_free(skb);\nerr_free_txskb:\n\tpr_debug(\"mac80211_hwsim: error occurred in %s\\n\", __func__);\n\tieee80211_free_txskb(hw, my_skb);\n\tdata->tx_failed++;\n}\n\nstatic bool hwsim_chans_compat(struct ieee80211_channel *c1,\n\t\t\t       struct ieee80211_channel *c2)\n{\n\tif (!c1 || !c2)\n\t\treturn false;\n\n\treturn c1->center_freq == c2->center_freq;\n}\n\nstruct tx_iter_data {\n\tstruct ieee80211_channel *channel;\n\tbool receive;\n};\n\nstatic void mac80211_hwsim_tx_iter(void *_data, u8 *addr,\n\t\t\t\t   struct ieee80211_vif *vif)\n{\n\tstruct tx_iter_data *data = _data;\n\n\tif (!vif->chanctx_conf)\n\t\treturn;\n\n\tif (!hwsim_chans_compat(data->channel,\n\t\t\t\trcu_dereference(vif->chanctx_conf)->def.chan))\n\t\treturn;\n\n\tdata->receive = true;\n}\n\nstatic void mac80211_hwsim_add_vendor_rtap(struct sk_buff *skb)\n{\n\t/*\n\t * To enable this code, #define the HWSIM_RADIOTAP_OUI,\n\t * e.g. like this:\n\t * #define HWSIM_RADIOTAP_OUI \"\\x02\\x00\\x00\"\n\t * (but you should use a valid OUI, not that)\n\t *\n\t * If anyone wants to 'donate' a radiotap OUI/subns code\n\t * please send a patch removing this #ifdef and changing\n\t * the values accordingly.\n\t */\n#ifdef HWSIM_RADIOTAP_OUI\n\tstruct ieee80211_vendor_radiotap *rtap;\n\n\t/*\n\t * Note that this code requires the headroom in the SKB\n\t * that was allocated earlier.\n\t */\n\trtap = skb_push(skb, sizeof(*rtap) + 8 + 4);\n\trtap->oui[0] = HWSIM_RADIOTAP_OUI[0];\n\trtap->oui[1] = HWSIM_RADIOTAP_OUI[1];\n\trtap->oui[2] = HWSIM_RADIOTAP_OUI[2];\n\trtap->subns = 127;\n\n\t/*\n\t * Radiotap vendor namespaces can (and should) also be\n\t * split into fields by using the standard radiotap\n\t * presence bitmap mechanism. Use just BIT(0) here for\n\t * the presence bitmap.\n\t */\n\trtap->present = BIT(0);\n\t/* We have 8 bytes of (dummy) data */\n\trtap->len = 8;\n\t/* For testing, also require it to be aligned */\n\trtap->align = 8;\n\t/* And also test that padding works, 4 bytes */\n\trtap->pad = 4;\n\t/* push the data */\n\tmemcpy(rtap->data, \"ABCDEFGH\", 8);\n\t/* make sure to clear padding, mac80211 doesn't */\n\tmemset(rtap->data + 8, 0, 4);\n\n\tIEEE80211_SKB_RXCB(skb)->flag |= RX_FLAG_RADIOTAP_VENDOR_DATA;\n#endif\n}\n\nstatic bool mac80211_hwsim_tx_frame_no_nl(struct ieee80211_hw *hw,\n\t\t\t\t\t  struct sk_buff *skb,\n\t\t\t\t\t  struct ieee80211_channel *chan)\n{\n\tstruct mac80211_hwsim_data *data = hw->priv, *data2;\n\tbool ack = false;\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_rx_status rx_status;\n\tu64 now;\n\n\tmemset(&rx_status, 0, sizeof(rx_status));\n\trx_status.flag |= RX_FLAG_MACTIME_START;\n\trx_status.freq = chan->center_freq;\n\trx_status.band = chan->band;\n\tif (info->control.rates[0].flags & IEEE80211_TX_RC_VHT_MCS) {\n\t\trx_status.rate_idx =\n\t\t\tieee80211_rate_get_vht_mcs(&info->control.rates[0]);\n\t\trx_status.nss =\n\t\t\tieee80211_rate_get_vht_nss(&info->control.rates[0]);\n\t\trx_status.encoding = RX_ENC_VHT;\n\t} else {\n\t\trx_status.rate_idx = info->control.rates[0].idx;\n\t\tif (info->control.rates[0].flags & IEEE80211_TX_RC_MCS)\n\t\t\trx_status.encoding = RX_ENC_HT;\n\t}\n\tif (info->control.rates[0].flags & IEEE80211_TX_RC_40_MHZ_WIDTH)\n\t\trx_status.bw = RATE_INFO_BW_40;\n\telse if (info->control.rates[0].flags & IEEE80211_TX_RC_80_MHZ_WIDTH)\n\t\trx_status.bw = RATE_INFO_BW_80;\n\telse if (info->control.rates[0].flags & IEEE80211_TX_RC_160_MHZ_WIDTH)\n\t\trx_status.bw = RATE_INFO_BW_160;\n\telse\n\t\trx_status.bw = RATE_INFO_BW_20;\n\tif (info->control.rates[0].flags & IEEE80211_TX_RC_SHORT_GI)\n\t\trx_status.enc_flags |= RX_ENC_FLAG_SHORT_GI;\n\t/* TODO: simulate real signal strength (and optional packet loss) */\n\trx_status.signal = -50;\n\tif (info->control.vif)\n\t\trx_status.signal += info->control.vif->bss_conf.txpower;\n\n\tif (data->ps != PS_DISABLED)\n\t\thdr->frame_control |= cpu_to_le16(IEEE80211_FCTL_PM);\n\n\t/* release the skb's source info */\n\tskb_orphan(skb);\n\tskb_dst_drop(skb);\n\tskb->mark = 0;\n\tsecpath_reset(skb);\n\tnf_reset(skb);\n\n\t/*\n\t * Get absolute mactime here so all HWs RX at the \"same time\", and\n\t * absolute TX time for beacon mactime so the timestamp matches.\n\t * Giving beacons a different mactime than non-beacons looks messy, but\n\t * it helps the Toffset be exact and a ~10us mactime discrepancy\n\t * probably doesn't really matter.\n\t */\n\tif (ieee80211_is_beacon(hdr->frame_control) ||\n\t    ieee80211_is_probe_resp(hdr->frame_control))\n\t\tnow = data->abs_bcn_ts;\n\telse\n\t\tnow = mac80211_hwsim_get_tsf_raw();\n\n\t/* Copy skb to all enabled radios that are on the current frequency */\n\tspin_lock(&hwsim_radio_lock);\n\tlist_for_each_entry(data2, &hwsim_radios, list) {\n\t\tstruct sk_buff *nskb;\n\t\tstruct tx_iter_data tx_iter_data = {\n\t\t\t.receive = false,\n\t\t\t.channel = chan,\n\t\t};\n\n\t\tif (data == data2)\n\t\t\tcontinue;\n\n\t\tif (!data2->started || (data2->idle && !data2->tmp_chan) ||\n\t\t    !hwsim_ps_rx_ok(data2, skb))\n\t\t\tcontinue;\n\n\t\tif (!(data->group & data2->group))\n\t\t\tcontinue;\n\n\t\tif (data->netgroup != data2->netgroup)\n\t\t\tcontinue;\n\n\t\tif (!hwsim_chans_compat(chan, data2->tmp_chan) &&\n\t\t    !hwsim_chans_compat(chan, data2->channel)) {\n\t\t\tieee80211_iterate_active_interfaces_atomic(\n\t\t\t\tdata2->hw, IEEE80211_IFACE_ITER_NORMAL,\n\t\t\t\tmac80211_hwsim_tx_iter, &tx_iter_data);\n\t\t\tif (!tx_iter_data.receive)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * reserve some space for our vendor and the normal\n\t\t * radiotap header, since we're copying anyway\n\t\t */\n\t\tif (skb->len < PAGE_SIZE && paged_rx) {\n\t\t\tstruct page *page = alloc_page(GFP_ATOMIC);\n\n\t\t\tif (!page)\n\t\t\t\tcontinue;\n\n\t\t\tnskb = dev_alloc_skb(128);\n\t\t\tif (!nskb) {\n\t\t\t\t__free_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tmemcpy(page_address(page), skb->data, skb->len);\n\t\t\tskb_add_rx_frag(nskb, 0, page, 0, skb->len, skb->len);\n\t\t} else {\n\t\t\tnskb = skb_copy(skb, GFP_ATOMIC);\n\t\t\tif (!nskb)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (mac80211_hwsim_addr_match(data2, hdr->addr1))\n\t\t\tack = true;\n\n\t\trx_status.mactime = now + data2->tsf_offset;\n\n\t\tmemcpy(IEEE80211_SKB_RXCB(nskb), &rx_status, sizeof(rx_status));\n\n\t\tmac80211_hwsim_add_vendor_rtap(nskb);\n\n\t\tdata2->rx_pkts++;\n\t\tdata2->rx_bytes += nskb->len;\n\t\tieee80211_rx_irqsafe(data2->hw, nskb);\n\t}\n\tspin_unlock(&hwsim_radio_lock);\n\n\treturn ack;\n}\n\nstatic void mac80211_hwsim_tx(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_tx_control *control,\n\t\t\t      struct sk_buff *skb)\n{\n\tstruct mac80211_hwsim_data *data = hw->priv;\n\tstruct ieee80211_tx_info *txi = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_hdr *hdr = (void *)skb->data;\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\tstruct ieee80211_channel *channel;\n\tbool ack;\n\tu32 _portid;\n\n\tif (WARN_ON(skb->len < 10)) {\n\t\t/* Should not happen; just a sanity check for addr1 use */\n\t\tieee80211_free_txskb(hw, skb);\n\t\treturn;\n\t}\n\n\tif (!data->use_chanctx) {\n\t\tchannel = data->channel;\n\t} else if (txi->hw_queue == 4) {\n\t\tchannel = data->tmp_chan;\n\t} else {\n\t\tchanctx_conf = rcu_dereference(txi->control.vif->chanctx_conf);\n\t\tif (chanctx_conf)\n\t\t\tchannel = chanctx_conf->def.chan;\n\t\telse\n\t\t\tchannel = NULL;\n\t}\n\n\tif (WARN(!channel, \"TX w/o channel - queue = %d\\n\", txi->hw_queue)) {\n\t\tieee80211_free_txskb(hw, skb);\n\t\treturn;\n\t}\n\n\tif (data->idle && !data->tmp_chan) {\n\t\twiphy_dbg(hw->wiphy, \"Trying to TX when idle - reject\\n\");\n\t\tieee80211_free_txskb(hw, skb);\n\t\treturn;\n\t}\n\n\tif (txi->control.vif)\n\t\thwsim_check_magic(txi->control.vif);\n\tif (control->sta)\n\t\thwsim_check_sta_magic(control->sta);\n\n\tif (ieee80211_hw_check(hw, SUPPORTS_RC_TABLE))\n\t\tieee80211_get_tx_rates(txi->control.vif, control->sta, skb,\n\t\t\t\t       txi->control.rates,\n\t\t\t\t       ARRAY_SIZE(txi->control.rates));\n\n\tif (skb->len >= 24 + 8 &&\n\t    ieee80211_is_probe_resp(hdr->frame_control)) {\n\t\t/* fake header transmission time */\n\t\tstruct ieee80211_mgmt *mgmt;\n\t\tstruct ieee80211_rate *txrate;\n\t\tu64 ts;\n\n\t\tmgmt = (struct ieee80211_mgmt *)skb->data;\n\t\ttxrate = ieee80211_get_tx_rate(hw, txi);\n\t\tts = mac80211_hwsim_get_tsf_raw();\n\t\tmgmt->u.probe_resp.timestamp =\n\t\t\tcpu_to_le64(ts + data->tsf_offset +\n\t\t\t\t    24 * 8 * 10 / txrate->bitrate);\n\t}\n\n\tmac80211_hwsim_monitor_rx(hw, skb, channel);\n\n\t/* wmediumd mode check */\n\t_portid = READ_ONCE(data->wmediumd);\n\n\tif (_portid)\n\t\treturn mac80211_hwsim_tx_frame_nl(hw, skb, _portid);\n\n\t/* NO wmediumd detected, perfect medium simulation */\n\tdata->tx_pkts++;\n\tdata->tx_bytes += skb->len;\n\tack = mac80211_hwsim_tx_frame_no_nl(hw, skb, channel);\n\n\tif (ack && skb->len >= 16)\n\t\tmac80211_hwsim_monitor_ack(channel, hdr->addr2);\n\n\tieee80211_tx_info_clear_status(txi);\n\n\t/* frame was transmitted at most favorable rate at first attempt */\n\ttxi->control.rates[0].count = 1;\n\ttxi->control.rates[1].idx = -1;\n\n\tif (!(txi->flags & IEEE80211_TX_CTL_NO_ACK) && ack)\n\t\ttxi->flags |= IEEE80211_TX_STAT_ACK;\n\tieee80211_tx_status_irqsafe(hw, skb);\n}\n\n\nstatic int mac80211_hwsim_start(struct ieee80211_hw *hw)\n{\n\tstruct mac80211_hwsim_data *data = hw->priv;\n\twiphy_dbg(hw->wiphy, \"%s\\n\", __func__);\n\tdata->started = true;\n\treturn 0;\n}\n\n\nstatic void mac80211_hwsim_stop(struct ieee80211_hw *hw)\n{\n\tstruct mac80211_hwsim_data *data = hw->priv;\n\tdata->started = false;\n\ttasklet_hrtimer_cancel(&data->beacon_timer);\n\twiphy_dbg(hw->wiphy, \"%s\\n\", __func__);\n}\n\n\nstatic int mac80211_hwsim_add_interface(struct ieee80211_hw *hw,\n\t\t\t\t\tstruct ieee80211_vif *vif)\n{\n\twiphy_dbg(hw->wiphy, \"%s (type=%d mac_addr=%pM)\\n\",\n\t\t  __func__, ieee80211_vif_type_p2p(vif),\n\t\t  vif->addr);\n\thwsim_set_magic(vif);\n\n\tvif->cab_queue = 0;\n\tvif->hw_queue[IEEE80211_AC_VO] = 0;\n\tvif->hw_queue[IEEE80211_AC_VI] = 1;\n\tvif->hw_queue[IEEE80211_AC_BE] = 2;\n\tvif->hw_queue[IEEE80211_AC_BK] = 3;\n\n\treturn 0;\n}\n\n\nstatic int mac80211_hwsim_change_interface(struct ieee80211_hw *hw,\n\t\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t\t   enum nl80211_iftype newtype,\n\t\t\t\t\t   bool newp2p)\n{\n\tnewtype = ieee80211_iftype_p2p(newtype, newp2p);\n\twiphy_dbg(hw->wiphy,\n\t\t  \"%s (old type=%d, new type=%d, mac_addr=%pM)\\n\",\n\t\t  __func__, ieee80211_vif_type_p2p(vif),\n\t\t    newtype, vif->addr);\n\thwsim_check_magic(vif);\n\n\t/*\n\t * interface may change from non-AP to AP in\n\t * which case this needs to be set up again\n\t */\n\tvif->cab_queue = 0;\n\n\treturn 0;\n}\n\nstatic void mac80211_hwsim_remove_interface(\n\tstruct ieee80211_hw *hw, struct ieee80211_vif *vif)\n{\n\twiphy_dbg(hw->wiphy, \"%s (type=%d mac_addr=%pM)\\n\",\n\t\t  __func__, ieee80211_vif_type_p2p(vif),\n\t\t  vif->addr);\n\thwsim_check_magic(vif);\n\thwsim_clear_magic(vif);\n}\n\nstatic void mac80211_hwsim_tx_frame(struct ieee80211_hw *hw,\n\t\t\t\t    struct sk_buff *skb,\n\t\t\t\t    struct ieee80211_channel *chan)\n{\n\tstruct mac80211_hwsim_data *data = hw->priv;\n\tu32 _pid = READ_ONCE(data->wmediumd);\n\n\tif (ieee80211_hw_check(hw, SUPPORTS_RC_TABLE)) {\n\t\tstruct ieee80211_tx_info *txi = IEEE80211_SKB_CB(skb);\n\t\tieee80211_get_tx_rates(txi->control.vif, NULL, skb,\n\t\t\t\t       txi->control.rates,\n\t\t\t\t       ARRAY_SIZE(txi->control.rates));\n\t}\n\n\tmac80211_hwsim_monitor_rx(hw, skb, chan);\n\n\tif (_pid)\n\t\treturn mac80211_hwsim_tx_frame_nl(hw, skb, _pid);\n\n\tmac80211_hwsim_tx_frame_no_nl(hw, skb, chan);\n\tdev_kfree_skb(skb);\n}\n\nstatic void mac80211_hwsim_beacon_tx(void *arg, u8 *mac,\n\t\t\t\t     struct ieee80211_vif *vif)\n{\n\tstruct mac80211_hwsim_data *data = arg;\n\tstruct ieee80211_hw *hw = data->hw;\n\tstruct ieee80211_tx_info *info;\n\tstruct ieee80211_rate *txrate;\n\tstruct ieee80211_mgmt *mgmt;\n\tstruct sk_buff *skb;\n\n\thwsim_check_magic(vif);\n\n\tif (vif->type != NL80211_IFTYPE_AP &&\n\t    vif->type != NL80211_IFTYPE_MESH_POINT &&\n\t    vif->type != NL80211_IFTYPE_ADHOC)\n\t\treturn;\n\n\tskb = ieee80211_beacon_get(hw, vif);\n\tif (skb == NULL)\n\t\treturn;\n\tinfo = IEEE80211_SKB_CB(skb);\n\tif (ieee80211_hw_check(hw, SUPPORTS_RC_TABLE))\n\t\tieee80211_get_tx_rates(vif, NULL, skb,\n\t\t\t\t       info->control.rates,\n\t\t\t\t       ARRAY_SIZE(info->control.rates));\n\n\ttxrate = ieee80211_get_tx_rate(hw, info);\n\n\tmgmt = (struct ieee80211_mgmt *) skb->data;\n\t/* fake header transmission time */\n\tdata->abs_bcn_ts = mac80211_hwsim_get_tsf_raw();\n\tmgmt->u.beacon.timestamp = cpu_to_le64(data->abs_bcn_ts +\n\t\t\t\t\t       data->tsf_offset +\n\t\t\t\t\t       24 * 8 * 10 / txrate->bitrate);\n\n\tmac80211_hwsim_tx_frame(hw, skb,\n\t\t\t\trcu_dereference(vif->chanctx_conf)->def.chan);\n\n\tif (vif->csa_active && ieee80211_csa_is_complete(vif))\n\t\tieee80211_csa_finish(vif);\n}\n\nstatic enum hrtimer_restart\nmac80211_hwsim_beacon(struct hrtimer *timer)\n{\n\tstruct mac80211_hwsim_data *data =\n\t\tcontainer_of(timer, struct mac80211_hwsim_data,\n\t\t\t     beacon_timer.timer);\n\tstruct ieee80211_hw *hw = data->hw;\n\tu64 bcn_int = data->beacon_int;\n\tktime_t next_bcn;\n\n\tif (!data->started)\n\t\tgoto out;\n\n\tieee80211_iterate_active_interfaces_atomic(\n\t\thw, IEEE80211_IFACE_ITER_NORMAL,\n\t\tmac80211_hwsim_beacon_tx, data);\n\n\t/* beacon at new TBTT + beacon interval */\n\tif (data->bcn_delta) {\n\t\tbcn_int -= data->bcn_delta;\n\t\tdata->bcn_delta = 0;\n\t}\n\n\tnext_bcn = ktime_add(hrtimer_get_expires(timer),\n\t\t\t     ns_to_ktime(bcn_int * 1000));\n\ttasklet_hrtimer_start(&data->beacon_timer, next_bcn, HRTIMER_MODE_ABS);\nout:\n\treturn HRTIMER_NORESTART;\n}\n\nstatic const char * const hwsim_chanwidths[] = {\n\t[NL80211_CHAN_WIDTH_20_NOHT] = \"noht\",\n\t[NL80211_CHAN_WIDTH_20] = \"ht20\",\n\t[NL80211_CHAN_WIDTH_40] = \"ht40\",\n\t[NL80211_CHAN_WIDTH_80] = \"vht80\",\n\t[NL80211_CHAN_WIDTH_80P80] = \"vht80p80\",\n\t[NL80211_CHAN_WIDTH_160] = \"vht160\",\n};\n\nstatic int mac80211_hwsim_config(struct ieee80211_hw *hw, u32 changed)\n{\n\tstruct mac80211_hwsim_data *data = hw->priv;\n\tstruct ieee80211_conf *conf = &hw->conf;\n\tstatic const char *smps_modes[IEEE80211_SMPS_NUM_MODES] = {\n\t\t[IEEE80211_SMPS_AUTOMATIC] = \"auto\",\n\t\t[IEEE80211_SMPS_OFF] = \"off\",\n\t\t[IEEE80211_SMPS_STATIC] = \"static\",\n\t\t[IEEE80211_SMPS_DYNAMIC] = \"dynamic\",\n\t};\n\tint idx;\n\n\tif (conf->chandef.chan)\n\t\twiphy_dbg(hw->wiphy,\n\t\t\t  \"%s (freq=%d(%d - %d)/%s idle=%d ps=%d smps=%s)\\n\",\n\t\t\t  __func__,\n\t\t\t  conf->chandef.chan->center_freq,\n\t\t\t  conf->chandef.center_freq1,\n\t\t\t  conf->chandef.center_freq2,\n\t\t\t  hwsim_chanwidths[conf->chandef.width],\n\t\t\t  !!(conf->flags & IEEE80211_CONF_IDLE),\n\t\t\t  !!(conf->flags & IEEE80211_CONF_PS),\n\t\t\t  smps_modes[conf->smps_mode]);\n\telse\n\t\twiphy_dbg(hw->wiphy,\n\t\t\t  \"%s (freq=0 idle=%d ps=%d smps=%s)\\n\",\n\t\t\t  __func__,\n\t\t\t  !!(conf->flags & IEEE80211_CONF_IDLE),\n\t\t\t  !!(conf->flags & IEEE80211_CONF_PS),\n\t\t\t  smps_modes[conf->smps_mode]);\n\n\tdata->idle = !!(conf->flags & IEEE80211_CONF_IDLE);\n\n\tWARN_ON(conf->chandef.chan && data->use_chanctx);\n\n\tmutex_lock(&data->mutex);\n\tif (data->scanning && conf->chandef.chan) {\n\t\tfor (idx = 0; idx < ARRAY_SIZE(data->survey_data); idx++) {\n\t\t\tif (data->survey_data[idx].channel == data->channel) {\n\t\t\t\tdata->survey_data[idx].start =\n\t\t\t\t\tdata->survey_data[idx].next_start;\n\t\t\t\tdata->survey_data[idx].end = jiffies;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tdata->channel = conf->chandef.chan;\n\n\t\tfor (idx = 0; idx < ARRAY_SIZE(data->survey_data); idx++) {\n\t\t\tif (data->survey_data[idx].channel &&\n\t\t\t    data->survey_data[idx].channel != data->channel)\n\t\t\t\tcontinue;\n\t\t\tdata->survey_data[idx].channel = data->channel;\n\t\t\tdata->survey_data[idx].next_start = jiffies;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tdata->channel = conf->chandef.chan;\n\t}\n\tmutex_unlock(&data->mutex);\n\n\tif (!data->started || !data->beacon_int)\n\t\ttasklet_hrtimer_cancel(&data->beacon_timer);\n\telse if (!hrtimer_is_queued(&data->beacon_timer.timer)) {\n\t\tu64 tsf = mac80211_hwsim_get_tsf(hw, NULL);\n\t\tu32 bcn_int = data->beacon_int;\n\t\tu64 until_tbtt = bcn_int - do_div(tsf, bcn_int);\n\n\t\ttasklet_hrtimer_start(&data->beacon_timer,\n\t\t\t\t      ns_to_ktime(until_tbtt * 1000),\n\t\t\t\t      HRTIMER_MODE_REL);\n\t}\n\n\treturn 0;\n}\n\n\nstatic void mac80211_hwsim_configure_filter(struct ieee80211_hw *hw,\n\t\t\t\t\t    unsigned int changed_flags,\n\t\t\t\t\t    unsigned int *total_flags,u64 multicast)\n{\n\tstruct mac80211_hwsim_data *data = hw->priv;\n\n\twiphy_dbg(hw->wiphy, \"%s\\n\", __func__);\n\n\tdata->rx_filter = 0;\n\tif (*total_flags & FIF_ALLMULTI)\n\t\tdata->rx_filter |= FIF_ALLMULTI;\n\n\t*total_flags = data->rx_filter;\n}\n\nstatic void mac80211_hwsim_bcn_en_iter(void *data, u8 *mac,\n\t\t\t\t       struct ieee80211_vif *vif)\n{\n\tunsigned int *count = data;\n\tstruct hwsim_vif_priv *vp = (void *)vif->drv_priv;\n\n\tif (vp->bcn_en)\n\t\t(*count)++;\n}\n\nstatic void mac80211_hwsim_bss_info_changed(struct ieee80211_hw *hw,\n\t\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t\t    struct ieee80211_bss_conf *info,\n\t\t\t\t\t    u32 changed)\n{\n\tstruct hwsim_vif_priv *vp = (void *)vif->drv_priv;\n\tstruct mac80211_hwsim_data *data = hw->priv;\n\n\thwsim_check_magic(vif);\n\n\twiphy_dbg(hw->wiphy, \"%s(changed=0x%x vif->addr=%pM)\\n\",\n\t\t  __func__, changed, vif->addr);\n\n\tif (changed & BSS_CHANGED_BSSID) {\n\t\twiphy_dbg(hw->wiphy, \"%s: BSSID changed: %pM\\n\",\n\t\t\t  __func__, info->bssid);\n\t\tmemcpy(vp->bssid, info->bssid, ETH_ALEN);\n\t}\n\n\tif (changed & BSS_CHANGED_ASSOC) {\n\t\twiphy_dbg(hw->wiphy, \"  ASSOC: assoc=%d aid=%d\\n\",\n\t\t\t  info->assoc, info->aid);\n\t\tvp->assoc = info->assoc;\n\t\tvp->aid = info->aid;\n\t}\n\n\tif (changed & BSS_CHANGED_BEACON_ENABLED) {\n\t\twiphy_dbg(hw->wiphy, \"  BCN EN: %d (BI=%u)\\n\",\n\t\t\t  info->enable_beacon, info->beacon_int);\n\t\tvp->bcn_en = info->enable_beacon;\n\t\tif (data->started &&\n\t\t    !hrtimer_is_queued(&data->beacon_timer.timer) &&\n\t\t    info->enable_beacon) {\n\t\t\tu64 tsf, until_tbtt;\n\t\t\tu32 bcn_int;\n\t\t\tdata->beacon_int = info->beacon_int * 1024;\n\t\t\ttsf = mac80211_hwsim_get_tsf(hw, vif);\n\t\t\tbcn_int = data->beacon_int;\n\t\t\tuntil_tbtt = bcn_int - do_div(tsf, bcn_int);\n\t\t\ttasklet_hrtimer_start(&data->beacon_timer,\n\t\t\t\t\t      ns_to_ktime(until_tbtt * 1000),\n\t\t\t\t\t      HRTIMER_MODE_REL);\n\t\t} else if (!info->enable_beacon) {\n\t\t\tunsigned int count = 0;\n\t\t\tieee80211_iterate_active_interfaces_atomic(\n\t\t\t\tdata->hw, IEEE80211_IFACE_ITER_NORMAL,\n\t\t\t\tmac80211_hwsim_bcn_en_iter, &count);\n\t\t\twiphy_dbg(hw->wiphy, \"  beaconing vifs remaining: %u\",\n\t\t\t\t  count);\n\t\t\tif (count == 0) {\n\t\t\t\ttasklet_hrtimer_cancel(&data->beacon_timer);\n\t\t\t\tdata->beacon_int = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (changed & BSS_CHANGED_ERP_CTS_PROT) {\n\t\twiphy_dbg(hw->wiphy, \"  ERP_CTS_PROT: %d\\n\",\n\t\t\t  info->use_cts_prot);\n\t}\n\n\tif (changed & BSS_CHANGED_ERP_PREAMBLE) {\n\t\twiphy_dbg(hw->wiphy, \"  ERP_PREAMBLE: %d\\n\",\n\t\t\t  info->use_short_preamble);\n\t}\n\n\tif (changed & BSS_CHANGED_ERP_SLOT) {\n\t\twiphy_dbg(hw->wiphy, \"  ERP_SLOT: %d\\n\", info->use_short_slot);\n\t}\n\n\tif (changed & BSS_CHANGED_HT) {\n\t\twiphy_dbg(hw->wiphy, \"  HT: op_mode=0x%x\\n\",\n\t\t\t  info->ht_operation_mode);\n\t}\n\n\tif (changed & BSS_CHANGED_BASIC_RATES) {\n\t\twiphy_dbg(hw->wiphy, \"  BASIC_RATES: 0x%llx\\n\",\n\t\t\t  (unsigned long long) info->basic_rates);\n\t}\n\n\tif (changed & BSS_CHANGED_TXPOWER)\n\t\twiphy_dbg(hw->wiphy, \"  TX Power: %d dBm\\n\", info->txpower);\n}\n\nstatic int mac80211_hwsim_sta_add(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t  struct ieee80211_sta *sta)\n{\n\thwsim_check_magic(vif);\n\thwsim_set_sta_magic(sta);\n\n\treturn 0;\n}\n\nstatic int mac80211_hwsim_sta_remove(struct ieee80211_hw *hw,\n\t\t\t\t     struct ieee80211_vif *vif,\n\t\t\t\t     struct ieee80211_sta *sta)\n{\n\thwsim_check_magic(vif);\n\thwsim_clear_sta_magic(sta);\n\n\treturn 0;\n}\n\nstatic void mac80211_hwsim_sta_notify(struct ieee80211_hw *hw,\n\t\t\t\t      struct ieee80211_vif *vif,\n\t\t\t\t      enum sta_notify_cmd cmd,\n\t\t\t\t      struct ieee80211_sta *sta)\n{\n\thwsim_check_magic(vif);\n\n\tswitch (cmd) {\n\tcase STA_NOTIFY_SLEEP:\n\tcase STA_NOTIFY_AWAKE:\n\t\t/* TODO: make good use of these flags */\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"Invalid sta notify: %d\\n\", cmd);\n\t\tbreak;\n\t}\n}\n\nstatic int mac80211_hwsim_set_tim(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_sta *sta,\n\t\t\t\t  bool set)\n{\n\thwsim_check_sta_magic(sta);\n\treturn 0;\n}\n\nstatic int mac80211_hwsim_conf_tx(\n\tstruct ieee80211_hw *hw,\n\tstruct ieee80211_vif *vif, u16 queue,\n\tconst struct ieee80211_tx_queue_params *params)\n{\n\twiphy_dbg(hw->wiphy,\n\t\t  \"%s (queue=%d txop=%d cw_min=%d cw_max=%d aifs=%d)\\n\",\n\t\t  __func__, queue,\n\t\t  params->txop, params->cw_min,\n\t\t  params->cw_max, params->aifs);\n\treturn 0;\n}\n\nstatic int mac80211_hwsim_get_survey(struct ieee80211_hw *hw, int idx,\n\t\t\t\t     struct survey_info *survey)\n{\n\tstruct mac80211_hwsim_data *hwsim = hw->priv;\n\n\tif (idx < 0 || idx >= ARRAY_SIZE(hwsim->survey_data))\n\t\treturn -ENOENT;\n\n\tmutex_lock(&hwsim->mutex);\n\tsurvey->channel = hwsim->survey_data[idx].channel;\n\tif (!survey->channel) {\n\t\tmutex_unlock(&hwsim->mutex);\n\t\treturn -ENOENT;\n\t}\n\n\t/*\n\t * Magically conjured dummy values --- this is only ok for simulated hardware.\n\t *\n\t * A real driver which cannot determine real values noise MUST NOT\n\t * report any, especially not a magically conjured ones :-)\n\t */\n\tsurvey->filled = SURVEY_INFO_NOISE_DBM |\n\t\t\t SURVEY_INFO_TIME |\n\t\t\t SURVEY_INFO_TIME_BUSY;\n\tsurvey->noise = -92;\n\tsurvey->time =\n\t\tjiffies_to_msecs(hwsim->survey_data[idx].end -\n\t\t\t\t hwsim->survey_data[idx].start);\n\t/* report 12.5% of channel time is used */\n\tsurvey->time_busy = survey->time/8;\n\tmutex_unlock(&hwsim->mutex);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_NL80211_TESTMODE\n/*\n * This section contains example code for using netlink\n * attributes with the testmode command in nl80211.\n */\n\n/* These enums need to be kept in sync with userspace */\nenum hwsim_testmode_attr {\n\t__HWSIM_TM_ATTR_INVALID\t= 0,\n\tHWSIM_TM_ATTR_CMD\t= 1,\n\tHWSIM_TM_ATTR_PS\t= 2,\n\n\t/* keep last */\n\t__HWSIM_TM_ATTR_AFTER_LAST,\n\tHWSIM_TM_ATTR_MAX\t= __HWSIM_TM_ATTR_AFTER_LAST - 1\n};\n\nenum hwsim_testmode_cmd {\n\tHWSIM_TM_CMD_SET_PS\t\t= 0,\n\tHWSIM_TM_CMD_GET_PS\t\t= 1,\n\tHWSIM_TM_CMD_STOP_QUEUES\t= 2,\n\tHWSIM_TM_CMD_WAKE_QUEUES\t= 3,\n};\n\nstatic const struct nla_policy hwsim_testmode_policy[HWSIM_TM_ATTR_MAX + 1] = {\n\t[HWSIM_TM_ATTR_CMD] = { .type = NLA_U32 },\n\t[HWSIM_TM_ATTR_PS] = { .type = NLA_U32 },\n};\n\nstatic int mac80211_hwsim_testmode_cmd(struct ieee80211_hw *hw,\n\t\t\t\t       struct ieee80211_vif *vif,\n\t\t\t\t       void *data, int len)\n{\n\tstruct mac80211_hwsim_data *hwsim = hw->priv;\n\tstruct nlattr *tb[HWSIM_TM_ATTR_MAX + 1];\n\tstruct sk_buff *skb;\n\tint err, ps;\n\n\terr = nla_parse(tb, HWSIM_TM_ATTR_MAX, data, len,\n\t\t\thwsim_testmode_policy, NULL);\n\tif (err)\n\t\treturn err;\n\n\tif (!tb[HWSIM_TM_ATTR_CMD])\n\t\treturn -EINVAL;\n\n\tswitch (nla_get_u32(tb[HWSIM_TM_ATTR_CMD])) {\n\tcase HWSIM_TM_CMD_SET_PS:\n\t\tif (!tb[HWSIM_TM_ATTR_PS])\n\t\t\treturn -EINVAL;\n\t\tps = nla_get_u32(tb[HWSIM_TM_ATTR_PS]);\n\t\treturn hwsim_fops_ps_write(hwsim, ps);\n\tcase HWSIM_TM_CMD_GET_PS:\n\t\tskb = cfg80211_testmode_alloc_reply_skb(hw->wiphy,\n\t\t\t\t\t\tnla_total_size(sizeof(u32)));\n\t\tif (!skb)\n\t\t\treturn -ENOMEM;\n\t\tif (nla_put_u32(skb, HWSIM_TM_ATTR_PS, hwsim->ps))\n\t\t\tgoto nla_put_failure;\n\t\treturn cfg80211_testmode_reply(skb);\n\tcase HWSIM_TM_CMD_STOP_QUEUES:\n\t\tieee80211_stop_queues(hw);\n\t\treturn 0;\n\tcase HWSIM_TM_CMD_WAKE_QUEUES:\n\t\tieee80211_wake_queues(hw);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n nla_put_failure:\n\tkfree_skb(skb);\n\treturn -ENOBUFS;\n}\n#endif\n\nstatic int mac80211_hwsim_ampdu_action(struct ieee80211_hw *hw,\n\t\t\t\t       struct ieee80211_vif *vif,\n\t\t\t\t       struct ieee80211_ampdu_params *params)\n{\n\tstruct ieee80211_sta *sta = params->sta;\n\tenum ieee80211_ampdu_mlme_action action = params->action;\n\tu16 tid = params->tid;\n\n\tswitch (action) {\n\tcase IEEE80211_AMPDU_TX_START:\n\t\tieee80211_start_tx_ba_cb_irqsafe(vif, sta->addr, tid);\n\t\tbreak;\n\tcase IEEE80211_AMPDU_TX_STOP_CONT:\n\tcase IEEE80211_AMPDU_TX_STOP_FLUSH:\n\tcase IEEE80211_AMPDU_TX_STOP_FLUSH_CONT:\n\t\tieee80211_stop_tx_ba_cb_irqsafe(vif, sta->addr, tid);\n\t\tbreak;\n\tcase IEEE80211_AMPDU_TX_OPERATIONAL:\n\t\tbreak;\n\tcase IEEE80211_AMPDU_RX_START:\n\tcase IEEE80211_AMPDU_RX_STOP:\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic void mac80211_hwsim_flush(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t u32 queues, bool drop)\n{\n\t/* Not implemented, queues only on kernel side */\n}\n\nstatic void hw_scan_work(struct work_struct *work)\n{\n\tstruct mac80211_hwsim_data *hwsim =\n\t\tcontainer_of(work, struct mac80211_hwsim_data, hw_scan.work);\n\tstruct cfg80211_scan_request *req = hwsim->hw_scan_request;\n\tint dwell, i;\n\n\tmutex_lock(&hwsim->mutex);\n\tif (hwsim->scan_chan_idx >= req->n_channels) {\n\t\tstruct cfg80211_scan_info info = {\n\t\t\t.aborted = false,\n\t\t};\n\n\t\twiphy_dbg(hwsim->hw->wiphy, \"hw scan complete\\n\");\n\t\tieee80211_scan_completed(hwsim->hw, &info);\n\t\thwsim->hw_scan_request = NULL;\n\t\thwsim->hw_scan_vif = NULL;\n\t\thwsim->tmp_chan = NULL;\n\t\tmutex_unlock(&hwsim->mutex);\n\t\treturn;\n\t}\n\n\twiphy_dbg(hwsim->hw->wiphy, \"hw scan %d MHz\\n\",\n\t\t  req->channels[hwsim->scan_chan_idx]->center_freq);\n\n\thwsim->tmp_chan = req->channels[hwsim->scan_chan_idx];\n\tif (hwsim->tmp_chan->flags & (IEEE80211_CHAN_NO_IR |\n\t\t\t\t      IEEE80211_CHAN_RADAR) ||\n\t    !req->n_ssids) {\n\t\tdwell = 120;\n\t} else {\n\t\tdwell = 30;\n\t\t/* send probes */\n\t\tfor (i = 0; i < req->n_ssids; i++) {\n\t\t\tstruct sk_buff *probe;\n\t\t\tstruct ieee80211_mgmt *mgmt;\n\n\t\t\tprobe = ieee80211_probereq_get(hwsim->hw,\n\t\t\t\t\t\t       hwsim->scan_addr,\n\t\t\t\t\t\t       req->ssids[i].ssid,\n\t\t\t\t\t\t       req->ssids[i].ssid_len,\n\t\t\t\t\t\t       req->ie_len);\n\t\t\tif (!probe)\n\t\t\t\tcontinue;\n\n\t\t\tmgmt = (struct ieee80211_mgmt *) probe->data;\n\t\t\tmemcpy(mgmt->da, req->bssid, ETH_ALEN);\n\t\t\tmemcpy(mgmt->bssid, req->bssid, ETH_ALEN);\n\n\t\t\tif (req->ie_len)\n\t\t\t\tskb_put_data(probe, req->ie, req->ie_len);\n\n\t\t\tlocal_bh_disable();\n\t\t\tmac80211_hwsim_tx_frame(hwsim->hw, probe,\n\t\t\t\t\t\thwsim->tmp_chan);\n\t\t\tlocal_bh_enable();\n\t\t}\n\t}\n\tieee80211_queue_delayed_work(hwsim->hw, &hwsim->hw_scan,\n\t\t\t\t     msecs_to_jiffies(dwell));\n\thwsim->survey_data[hwsim->scan_chan_idx].channel = hwsim->tmp_chan;\n\thwsim->survey_data[hwsim->scan_chan_idx].start = jiffies;\n\thwsim->survey_data[hwsim->scan_chan_idx].end =\n\t\tjiffies + msecs_to_jiffies(dwell);\n\thwsim->scan_chan_idx++;\n\tmutex_unlock(&hwsim->mutex);\n}\n\nstatic int mac80211_hwsim_hw_scan(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t  struct ieee80211_scan_request *hw_req)\n{\n\tstruct mac80211_hwsim_data *hwsim = hw->priv;\n\tstruct cfg80211_scan_request *req = &hw_req->req;\n\n\tmutex_lock(&hwsim->mutex);\n\tif (WARN_ON(hwsim->tmp_chan || hwsim->hw_scan_request)) {\n\t\tmutex_unlock(&hwsim->mutex);\n\t\treturn -EBUSY;\n\t}\n\thwsim->hw_scan_request = req;\n\thwsim->hw_scan_vif = vif;\n\thwsim->scan_chan_idx = 0;\n\tif (req->flags & NL80211_SCAN_FLAG_RANDOM_ADDR)\n\t\tget_random_mask_addr(hwsim->scan_addr,\n\t\t\t\t     hw_req->req.mac_addr,\n\t\t\t\t     hw_req->req.mac_addr_mask);\n\telse\n\t\tmemcpy(hwsim->scan_addr, vif->addr, ETH_ALEN);\n\tmemset(hwsim->survey_data, 0, sizeof(hwsim->survey_data));\n\tmutex_unlock(&hwsim->mutex);\n\n\twiphy_dbg(hw->wiphy, \"hwsim hw_scan request\\n\");\n\n\tieee80211_queue_delayed_work(hwsim->hw, &hwsim->hw_scan, 0);\n\n\treturn 0;\n}\n\nstatic void mac80211_hwsim_cancel_hw_scan(struct ieee80211_hw *hw,\n\t\t\t\t\t  struct ieee80211_vif *vif)\n{\n\tstruct mac80211_hwsim_data *hwsim = hw->priv;\n\tstruct cfg80211_scan_info info = {\n\t\t.aborted = true,\n\t};\n\n\twiphy_dbg(hw->wiphy, \"hwsim cancel_hw_scan\\n\");\n\n\tcancel_delayed_work_sync(&hwsim->hw_scan);\n\n\tmutex_lock(&hwsim->mutex);\n\tieee80211_scan_completed(hwsim->hw, &info);\n\thwsim->tmp_chan = NULL;\n\thwsim->hw_scan_request = NULL;\n\thwsim->hw_scan_vif = NULL;\n\tmutex_unlock(&hwsim->mutex);\n}\n\nstatic void mac80211_hwsim_sw_scan(struct ieee80211_hw *hw,\n\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t   const u8 *mac_addr)\n{\n\tstruct mac80211_hwsim_data *hwsim = hw->priv;\n\n\tmutex_lock(&hwsim->mutex);\n\n\tif (hwsim->scanning) {\n\t\tpr_debug(\"two hwsim sw_scans detected!\\n\");\n\t\tgoto out;\n\t}\n\n\tpr_debug(\"hwsim sw_scan request, prepping stuff\\n\");\n\n\tmemcpy(hwsim->scan_addr, mac_addr, ETH_ALEN);\n\thwsim->scanning = true;\n\tmemset(hwsim->survey_data, 0, sizeof(hwsim->survey_data));\n\nout:\n\tmutex_unlock(&hwsim->mutex);\n}\n\nstatic void mac80211_hwsim_sw_scan_complete(struct ieee80211_hw *hw,\n\t\t\t\t\t    struct ieee80211_vif *vif)\n{\n\tstruct mac80211_hwsim_data *hwsim = hw->priv;\n\n\tmutex_lock(&hwsim->mutex);\n\n\tpr_debug(\"hwsim sw_scan_complete\\n\");\n\thwsim->scanning = false;\n\teth_zero_addr(hwsim->scan_addr);\n\n\tmutex_unlock(&hwsim->mutex);\n}\n\nstatic void hw_roc_start(struct work_struct *work)\n{\n\tstruct mac80211_hwsim_data *hwsim =\n\t\tcontainer_of(work, struct mac80211_hwsim_data, roc_start.work);\n\n\tmutex_lock(&hwsim->mutex);\n\n\twiphy_dbg(hwsim->hw->wiphy, \"hwsim ROC begins\\n\");\n\thwsim->tmp_chan = hwsim->roc_chan;\n\tieee80211_ready_on_channel(hwsim->hw);\n\n\tieee80211_queue_delayed_work(hwsim->hw, &hwsim->roc_done,\n\t\t\t\t     msecs_to_jiffies(hwsim->roc_duration));\n\n\tmutex_unlock(&hwsim->mutex);\n}\n\nstatic void hw_roc_done(struct work_struct *work)\n{\n\tstruct mac80211_hwsim_data *hwsim =\n\t\tcontainer_of(work, struct mac80211_hwsim_data, roc_done.work);\n\n\tmutex_lock(&hwsim->mutex);\n\tieee80211_remain_on_channel_expired(hwsim->hw);\n\thwsim->tmp_chan = NULL;\n\tmutex_unlock(&hwsim->mutex);\n\n\twiphy_dbg(hwsim->hw->wiphy, \"hwsim ROC expired\\n\");\n}\n\nstatic int mac80211_hwsim_roc(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_vif *vif,\n\t\t\t      struct ieee80211_channel *chan,\n\t\t\t      int duration,\n\t\t\t      enum ieee80211_roc_type type)\n{\n\tstruct mac80211_hwsim_data *hwsim = hw->priv;\n\n\tmutex_lock(&hwsim->mutex);\n\tif (WARN_ON(hwsim->tmp_chan || hwsim->hw_scan_request)) {\n\t\tmutex_unlock(&hwsim->mutex);\n\t\treturn -EBUSY;\n\t}\n\n\thwsim->roc_chan = chan;\n\thwsim->roc_duration = duration;\n\tmutex_unlock(&hwsim->mutex);\n\n\twiphy_dbg(hw->wiphy, \"hwsim ROC (%d MHz, %d ms)\\n\",\n\t\t  chan->center_freq, duration);\n\tieee80211_queue_delayed_work(hw, &hwsim->roc_start, HZ/50);\n\n\treturn 0;\n}\n\nstatic int mac80211_hwsim_croc(struct ieee80211_hw *hw)\n{\n\tstruct mac80211_hwsim_data *hwsim = hw->priv;\n\n\tcancel_delayed_work_sync(&hwsim->roc_start);\n\tcancel_delayed_work_sync(&hwsim->roc_done);\n\n\tmutex_lock(&hwsim->mutex);\n\thwsim->tmp_chan = NULL;\n\tmutex_unlock(&hwsim->mutex);\n\n\twiphy_dbg(hw->wiphy, \"hwsim ROC canceled\\n\");\n\n\treturn 0;\n}\n\nstatic int mac80211_hwsim_add_chanctx(struct ieee80211_hw *hw,\n\t\t\t\t      struct ieee80211_chanctx_conf *ctx)\n{\n\thwsim_set_chanctx_magic(ctx);\n\twiphy_dbg(hw->wiphy,\n\t\t  \"add channel context control: %d MHz/width: %d/cfreqs:%d/%d MHz\\n\",\n\t\t  ctx->def.chan->center_freq, ctx->def.width,\n\t\t  ctx->def.center_freq1, ctx->def.center_freq2);\n\treturn 0;\n}\n\nstatic void mac80211_hwsim_remove_chanctx(struct ieee80211_hw *hw,\n\t\t\t\t\t  struct ieee80211_chanctx_conf *ctx)\n{\n\twiphy_dbg(hw->wiphy,\n\t\t  \"remove channel context control: %d MHz/width: %d/cfreqs:%d/%d MHz\\n\",\n\t\t  ctx->def.chan->center_freq, ctx->def.width,\n\t\t  ctx->def.center_freq1, ctx->def.center_freq2);\n\thwsim_check_chanctx_magic(ctx);\n\thwsim_clear_chanctx_magic(ctx);\n}\n\nstatic void mac80211_hwsim_change_chanctx(struct ieee80211_hw *hw,\n\t\t\t\t\t  struct ieee80211_chanctx_conf *ctx,\n\t\t\t\t\t  u32 changed)\n{\n\thwsim_check_chanctx_magic(ctx);\n\twiphy_dbg(hw->wiphy,\n\t\t  \"change channel context control: %d MHz/width: %d/cfreqs:%d/%d MHz\\n\",\n\t\t  ctx->def.chan->center_freq, ctx->def.width,\n\t\t  ctx->def.center_freq1, ctx->def.center_freq2);\n}\n\nstatic int mac80211_hwsim_assign_vif_chanctx(struct ieee80211_hw *hw,\n\t\t\t\t\t     struct ieee80211_vif *vif,\n\t\t\t\t\t     struct ieee80211_chanctx_conf *ctx)\n{\n\thwsim_check_magic(vif);\n\thwsim_check_chanctx_magic(ctx);\n\n\treturn 0;\n}\n\nstatic void mac80211_hwsim_unassign_vif_chanctx(struct ieee80211_hw *hw,\n\t\t\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\t\t\tstruct ieee80211_chanctx_conf *ctx)\n{\n\thwsim_check_magic(vif);\n\thwsim_check_chanctx_magic(ctx);\n}\n\nstatic const char mac80211_hwsim_gstrings_stats[][ETH_GSTRING_LEN] = {\n\t\"tx_pkts_nic\",\n\t\"tx_bytes_nic\",\n\t\"rx_pkts_nic\",\n\t\"rx_bytes_nic\",\n\t\"d_tx_dropped\",\n\t\"d_tx_failed\",\n\t\"d_ps_mode\",\n\t\"d_group\",\n};\n\n#define MAC80211_HWSIM_SSTATS_LEN ARRAY_SIZE(mac80211_hwsim_gstrings_stats)\n\nstatic void mac80211_hwsim_get_et_strings(struct ieee80211_hw *hw,\n\t\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t\t  u32 sset, u8 *data)\n{\n\tif (sset == ETH_SS_STATS)\n\t\tmemcpy(data, *mac80211_hwsim_gstrings_stats,\n\t\t       sizeof(mac80211_hwsim_gstrings_stats));\n}\n\nstatic int mac80211_hwsim_get_et_sset_count(struct ieee80211_hw *hw,\n\t\t\t\t\t    struct ieee80211_vif *vif, int sset)\n{\n\tif (sset == ETH_SS_STATS)\n\t\treturn MAC80211_HWSIM_SSTATS_LEN;\n\treturn 0;\n}\n\nstatic void mac80211_hwsim_get_et_stats(struct ieee80211_hw *hw,\n\t\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\t\tstruct ethtool_stats *stats, u64 *data)\n{\n\tstruct mac80211_hwsim_data *ar = hw->priv;\n\tint i = 0;\n\n\tdata[i++] = ar->tx_pkts;\n\tdata[i++] = ar->tx_bytes;\n\tdata[i++] = ar->rx_pkts;\n\tdata[i++] = ar->rx_bytes;\n\tdata[i++] = ar->tx_dropped;\n\tdata[i++] = ar->tx_failed;\n\tdata[i++] = ar->ps;\n\tdata[i++] = ar->group;\n\n\tWARN_ON(i != MAC80211_HWSIM_SSTATS_LEN);\n}\n\n#define HWSIM_COMMON_OPS\t\t\t\t\t\\\n\t.tx = mac80211_hwsim_tx,\t\t\t\t\\\n\t.start = mac80211_hwsim_start,\t\t\t\t\\\n\t.stop = mac80211_hwsim_stop,\t\t\t\t\\\n\t.add_interface = mac80211_hwsim_add_interface,\t\t\\\n\t.change_interface = mac80211_hwsim_change_interface,\t\\\n\t.remove_interface = mac80211_hwsim_remove_interface,\t\\\n\t.config = mac80211_hwsim_config,\t\t\t\\\n\t.configure_filter = mac80211_hwsim_configure_filter,\t\\\n\t.bss_info_changed = mac80211_hwsim_bss_info_changed,\t\\\n\t.sta_add = mac80211_hwsim_sta_add,\t\t\t\\\n\t.sta_remove = mac80211_hwsim_sta_remove,\t\t\\\n\t.sta_notify = mac80211_hwsim_sta_notify,\t\t\\\n\t.set_tim = mac80211_hwsim_set_tim,\t\t\t\\\n\t.conf_tx = mac80211_hwsim_conf_tx,\t\t\t\\\n\t.get_survey = mac80211_hwsim_get_survey,\t\t\\\n\tCFG80211_TESTMODE_CMD(mac80211_hwsim_testmode_cmd)\t\\\n\t.ampdu_action = mac80211_hwsim_ampdu_action,\t\t\\\n\t.flush = mac80211_hwsim_flush,\t\t\t\t\\\n\t.get_tsf = mac80211_hwsim_get_tsf,\t\t\t\\\n\t.set_tsf = mac80211_hwsim_set_tsf,\t\t\t\\\n\t.get_et_sset_count = mac80211_hwsim_get_et_sset_count,\t\\\n\t.get_et_stats = mac80211_hwsim_get_et_stats,\t\t\\\n\t.get_et_strings = mac80211_hwsim_get_et_strings,\n\nstatic const struct ieee80211_ops mac80211_hwsim_ops = {\n\tHWSIM_COMMON_OPS\n\t.sw_scan_start = mac80211_hwsim_sw_scan,\n\t.sw_scan_complete = mac80211_hwsim_sw_scan_complete,\n};\n\nstatic const struct ieee80211_ops mac80211_hwsim_mchan_ops = {\n\tHWSIM_COMMON_OPS\n\t.hw_scan = mac80211_hwsim_hw_scan,\n\t.cancel_hw_scan = mac80211_hwsim_cancel_hw_scan,\n\t.sw_scan_start = NULL,\n\t.sw_scan_complete = NULL,\n\t.remain_on_channel = mac80211_hwsim_roc,\n\t.cancel_remain_on_channel = mac80211_hwsim_croc,\n\t.add_chanctx = mac80211_hwsim_add_chanctx,\n\t.remove_chanctx = mac80211_hwsim_remove_chanctx,\n\t.change_chanctx = mac80211_hwsim_change_chanctx,\n\t.assign_vif_chanctx = mac80211_hwsim_assign_vif_chanctx,\n\t.unassign_vif_chanctx = mac80211_hwsim_unassign_vif_chanctx,\n};\n\nstruct hwsim_new_radio_params {\n\tunsigned int channels;\n\tconst char *reg_alpha2;\n\tconst struct ieee80211_regdomain *regd;\n\tbool reg_strict;\n\tbool p2p_device;\n\tbool use_chanctx;\n\tbool destroy_on_close;\n\tconst char *hwname;\n\tbool no_vif;\n};\n\nstatic void hwsim_mcast_config_msg(struct sk_buff *mcast_skb,\n\t\t\t\t   struct genl_info *info)\n{\n\tif (info)\n\t\tgenl_notify(&hwsim_genl_family, mcast_skb, info,\n\t\t\t    HWSIM_MCGRP_CONFIG, GFP_KERNEL);\n\telse\n\t\tgenlmsg_multicast(&hwsim_genl_family, mcast_skb, 0,\n\t\t\t\t  HWSIM_MCGRP_CONFIG, GFP_KERNEL);\n}\n\nstatic int append_radio_msg(struct sk_buff *skb, int id,\n\t\t\t    struct hwsim_new_radio_params *param)\n{\n\tint ret;\n\n\tret = nla_put_u32(skb, HWSIM_ATTR_RADIO_ID, id);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (param->channels) {\n\t\tret = nla_put_u32(skb, HWSIM_ATTR_CHANNELS, param->channels);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (param->reg_alpha2) {\n\t\tret = nla_put(skb, HWSIM_ATTR_REG_HINT_ALPHA2, 2,\n\t\t\t      param->reg_alpha2);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (param->regd) {\n\t\tint i;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(hwsim_world_regdom_custom); i++) {\n\t\t\tif (hwsim_world_regdom_custom[i] != param->regd)\n\t\t\t\tcontinue;\n\n\t\t\tret = nla_put_u32(skb, HWSIM_ATTR_REG_CUSTOM_REG, i);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (param->reg_strict) {\n\t\tret = nla_put_flag(skb, HWSIM_ATTR_REG_STRICT_REG);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (param->p2p_device) {\n\t\tret = nla_put_flag(skb, HWSIM_ATTR_SUPPORT_P2P_DEVICE);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (param->use_chanctx) {\n\t\tret = nla_put_flag(skb, HWSIM_ATTR_USE_CHANCTX);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (param->hwname) {\n\t\tret = nla_put(skb, HWSIM_ATTR_RADIO_NAME,\n\t\t\t      strlen(param->hwname), param->hwname);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void hwsim_mcast_new_radio(int id, struct genl_info *info,\n\t\t\t\t  struct hwsim_new_radio_params *param)\n{\n\tstruct sk_buff *mcast_skb;\n\tvoid *data;\n\n\tmcast_skb = genlmsg_new(GENLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!mcast_skb)\n\t\treturn;\n\n\tdata = genlmsg_put(mcast_skb, 0, 0, &hwsim_genl_family, 0,\n\t\t\t   HWSIM_CMD_NEW_RADIO);\n\tif (!data)\n\t\tgoto out_err;\n\n\tif (append_radio_msg(mcast_skb, id, param) < 0)\n\t\tgoto out_err;\n\n\tgenlmsg_end(mcast_skb, data);\n\n\thwsim_mcast_config_msg(mcast_skb, info);\n\treturn;\n\nout_err:\n\tgenlmsg_cancel(mcast_skb, data);\n\tnlmsg_free(mcast_skb);\n}\n\nstatic int mac80211_hwsim_new_radio(struct genl_info *info,\n\t\t\t\t    struct hwsim_new_radio_params *param)\n{\n\tint err;\n\tu8 addr[ETH_ALEN];\n\tstruct mac80211_hwsim_data *data;\n\tstruct ieee80211_hw *hw;\n\tenum nl80211_band band;\n\tconst struct ieee80211_ops *ops = &mac80211_hwsim_ops;\n\tstruct net *net;\n\tint idx;\n\n\tif (WARN_ON(param->channels > 1 && !param->use_chanctx))\n\t\treturn -EINVAL;\n\n\tspin_lock_bh(&hwsim_radio_lock);\n\tidx = hwsim_radio_idx++;\n\tspin_unlock_bh(&hwsim_radio_lock);\n\n\tif (param->use_chanctx)\n\t\tops = &mac80211_hwsim_mchan_ops;\n\thw = ieee80211_alloc_hw_nm(sizeof(*data), ops, param->hwname);\n\tif (!hw) {\n\t\tpr_debug(\"mac80211_hwsim: ieee80211_alloc_hw failed\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto failed;\n\t}\n\n\t/* ieee80211_alloc_hw_nm may have used a default name */\n\tparam->hwname = wiphy_name(hw->wiphy);\n\n\tif (info)\n\t\tnet = genl_info_net(info);\n\telse\n\t\tnet = &init_net;\n\twiphy_net_set(hw->wiphy, net);\n\n\tdata = hw->priv;\n\tdata->hw = hw;\n\n\tdata->dev = device_create(hwsim_class, NULL, 0, hw, \"hwsim%d\", idx);\n\tif (IS_ERR(data->dev)) {\n\t\tprintk(KERN_DEBUG\n\t\t       \"mac80211_hwsim: device_create failed (%ld)\\n\",\n\t\t       PTR_ERR(data->dev));\n\t\terr = -ENOMEM;\n\t\tgoto failed_drvdata;\n\t}\n\tdata->dev->driver = &mac80211_hwsim_driver.driver;\n\terr = device_bind_driver(data->dev);\n\tif (err != 0) {\n\t\tpr_debug(\"mac80211_hwsim: device_bind_driver failed (%d)\\n\",\n\t\t       err);\n\t\tgoto failed_bind;\n\t}\n\n\tskb_queue_head_init(&data->pending);\n\n\tSET_IEEE80211_DEV(hw, data->dev);\n\teth_zero_addr(addr);\n\taddr[0] = 0x02;\n\taddr[3] = idx >> 8;\n\taddr[4] = idx;\n\tmemcpy(data->addresses[0].addr, addr, ETH_ALEN);\n\tmemcpy(data->addresses[1].addr, addr, ETH_ALEN);\n\tdata->addresses[1].addr[0] |= 0x40;\n\thw->wiphy->n_addresses = 2;\n\thw->wiphy->addresses = data->addresses;\n\n\tdata->channels = param->channels;\n\tdata->use_chanctx = param->use_chanctx;\n\tdata->idx = idx;\n\tdata->destroy_on_close = param->destroy_on_close;\n\tif (info)\n\t\tdata->portid = info->snd_portid;\n\n\tif (data->use_chanctx) {\n\t\thw->wiphy->max_scan_ssids = 255;\n\t\thw->wiphy->max_scan_ie_len = IEEE80211_MAX_DATA_LEN;\n\t\thw->wiphy->max_remain_on_channel_duration = 1000;\n\t\thw->wiphy->iface_combinations = &data->if_combination;\n\t\tif (param->p2p_device)\n\t\t\tdata->if_combination = hwsim_if_comb_p2p_dev[0];\n\t\telse\n\t\t\tdata->if_combination = hwsim_if_comb[0];\n\t\thw->wiphy->n_iface_combinations = 1;\n\t\t/* For channels > 1 DFS is not allowed */\n\t\tdata->if_combination.radar_detect_widths = 0;\n\t\tdata->if_combination.num_different_channels = data->channels;\n\t} else if (param->p2p_device) {\n\t\thw->wiphy->iface_combinations = hwsim_if_comb_p2p_dev;\n\t\thw->wiphy->n_iface_combinations =\n\t\t\tARRAY_SIZE(hwsim_if_comb_p2p_dev);\n\t} else {\n\t\thw->wiphy->iface_combinations = hwsim_if_comb;\n\t\thw->wiphy->n_iface_combinations = ARRAY_SIZE(hwsim_if_comb);\n\t}\n\n\tINIT_DELAYED_WORK(&data->roc_start, hw_roc_start);\n\tINIT_DELAYED_WORK(&data->roc_done, hw_roc_done);\n\tINIT_DELAYED_WORK(&data->hw_scan, hw_scan_work);\n\n\thw->queues = 5;\n\thw->offchannel_tx_hw_queue = 4;\n\thw->wiphy->interface_modes = BIT(NL80211_IFTYPE_STATION) |\n\t\t\t\t     BIT(NL80211_IFTYPE_AP) |\n\t\t\t\t     BIT(NL80211_IFTYPE_P2P_CLIENT) |\n\t\t\t\t     BIT(NL80211_IFTYPE_P2P_GO) |\n\t\t\t\t     BIT(NL80211_IFTYPE_ADHOC) |\n\t\t\t\t     BIT(NL80211_IFTYPE_MESH_POINT);\n\n\tif (param->p2p_device)\n\t\thw->wiphy->interface_modes |= BIT(NL80211_IFTYPE_P2P_DEVICE);\n\n\tieee80211_hw_set(hw, SUPPORT_FAST_XMIT);\n\tieee80211_hw_set(hw, CHANCTX_STA_CSA);\n\tieee80211_hw_set(hw, SUPPORTS_HT_CCK_RATES);\n\tieee80211_hw_set(hw, QUEUE_CONTROL);\n\tieee80211_hw_set(hw, WANT_MONITOR_VIF);\n\tieee80211_hw_set(hw, AMPDU_AGGREGATION);\n\tieee80211_hw_set(hw, MFP_CAPABLE);\n\tieee80211_hw_set(hw, SIGNAL_DBM);\n\tieee80211_hw_set(hw, TDLS_WIDER_BW);\n\tif (rctbl)\n\t\tieee80211_hw_set(hw, SUPPORTS_RC_TABLE);\n\n\thw->wiphy->flags |= WIPHY_FLAG_SUPPORTS_TDLS |\n\t\t\t    WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL |\n\t\t\t    WIPHY_FLAG_AP_UAPSD |\n\t\t\t    WIPHY_FLAG_HAS_CHANNEL_SWITCH;\n\thw->wiphy->features |= NL80211_FEATURE_ACTIVE_MONITOR |\n\t\t\t       NL80211_FEATURE_AP_MODE_CHAN_WIDTH_CHANGE |\n\t\t\t       NL80211_FEATURE_STATIC_SMPS |\n\t\t\t       NL80211_FEATURE_DYNAMIC_SMPS |\n\t\t\t       NL80211_FEATURE_SCAN_RANDOM_MAC_ADDR;\n\twiphy_ext_feature_set(hw->wiphy, NL80211_EXT_FEATURE_VHT_IBSS);\n\n\t/* ask mac80211 to reserve space for magic */\n\thw->vif_data_size = sizeof(struct hwsim_vif_priv);\n\thw->sta_data_size = sizeof(struct hwsim_sta_priv);\n\thw->chanctx_data_size = sizeof(struct hwsim_chanctx_priv);\n\n\tmemcpy(data->channels_2ghz, hwsim_channels_2ghz,\n\t\tsizeof(hwsim_channels_2ghz));\n\tmemcpy(data->channels_5ghz, hwsim_channels_5ghz,\n\t\tsizeof(hwsim_channels_5ghz));\n\tmemcpy(data->rates, hwsim_rates, sizeof(hwsim_rates));\n\n\tfor (band = NL80211_BAND_2GHZ; band < NUM_NL80211_BANDS; band++) {\n\t\tstruct ieee80211_supported_band *sband = &data->bands[band];\n\t\tswitch (band) {\n\t\tcase NL80211_BAND_2GHZ:\n\t\t\tsband->channels = data->channels_2ghz;\n\t\t\tsband->n_channels = ARRAY_SIZE(hwsim_channels_2ghz);\n\t\t\tsband->bitrates = data->rates;\n\t\t\tsband->n_bitrates = ARRAY_SIZE(hwsim_rates);\n\t\t\tbreak;\n\t\tcase NL80211_BAND_5GHZ:\n\t\t\tsband->channels = data->channels_5ghz;\n\t\t\tsband->n_channels = ARRAY_SIZE(hwsim_channels_5ghz);\n\t\t\tsband->bitrates = data->rates + 4;\n\t\t\tsband->n_bitrates = ARRAY_SIZE(hwsim_rates) - 4;\n\n\t\t\tsband->vht_cap.vht_supported = true;\n\t\t\tsband->vht_cap.cap =\n\t\t\t\tIEEE80211_VHT_CAP_MAX_MPDU_LENGTH_11454 |\n\t\t\t\tIEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160_80PLUS80MHZ |\n\t\t\t\tIEEE80211_VHT_CAP_RXLDPC |\n\t\t\t\tIEEE80211_VHT_CAP_SHORT_GI_80 |\n\t\t\t\tIEEE80211_VHT_CAP_SHORT_GI_160 |\n\t\t\t\tIEEE80211_VHT_CAP_TXSTBC |\n\t\t\t\tIEEE80211_VHT_CAP_RXSTBC_1 |\n\t\t\t\tIEEE80211_VHT_CAP_RXSTBC_2 |\n\t\t\t\tIEEE80211_VHT_CAP_RXSTBC_3 |\n\t\t\t\tIEEE80211_VHT_CAP_RXSTBC_4 |\n\t\t\t\tIEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_MASK;\n\t\t\tsband->vht_cap.vht_mcs.rx_mcs_map =\n\t\t\t\tcpu_to_le16(IEEE80211_VHT_MCS_SUPPORT_0_9 << 0 |\n\t\t\t\t\t    IEEE80211_VHT_MCS_SUPPORT_0_9 << 2 |\n\t\t\t\t\t    IEEE80211_VHT_MCS_SUPPORT_0_9 << 4 |\n\t\t\t\t\t    IEEE80211_VHT_MCS_SUPPORT_0_9 << 6 |\n\t\t\t\t\t    IEEE80211_VHT_MCS_SUPPORT_0_9 << 8 |\n\t\t\t\t\t    IEEE80211_VHT_MCS_SUPPORT_0_9 << 10 |\n\t\t\t\t\t    IEEE80211_VHT_MCS_SUPPORT_0_9 << 12 |\n\t\t\t\t\t    IEEE80211_VHT_MCS_SUPPORT_0_9 << 14);\n\t\t\tsband->vht_cap.vht_mcs.tx_mcs_map =\n\t\t\t\tsband->vht_cap.vht_mcs.rx_mcs_map;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\n\t\tsband->ht_cap.ht_supported = true;\n\t\tsband->ht_cap.cap = IEEE80211_HT_CAP_SUP_WIDTH_20_40 |\n\t\t\t\t    IEEE80211_HT_CAP_GRN_FLD |\n\t\t\t\t    IEEE80211_HT_CAP_SGI_20 |\n\t\t\t\t    IEEE80211_HT_CAP_SGI_40 |\n\t\t\t\t    IEEE80211_HT_CAP_DSSSCCK40;\n\t\tsband->ht_cap.ampdu_factor = 0x3;\n\t\tsband->ht_cap.ampdu_density = 0x6;\n\t\tmemset(&sband->ht_cap.mcs, 0,\n\t\t       sizeof(sband->ht_cap.mcs));\n\t\tsband->ht_cap.mcs.rx_mask[0] = 0xff;\n\t\tsband->ht_cap.mcs.rx_mask[1] = 0xff;\n\t\tsband->ht_cap.mcs.tx_params = IEEE80211_HT_MCS_TX_DEFINED;\n\n\t\thw->wiphy->bands[band] = sband;\n\t}\n\n\t/* By default all radios belong to the first group */\n\tdata->group = 1;\n\tmutex_init(&data->mutex);\n\n\tdata->netgroup = hwsim_net_get_netgroup(net);\n\n\t/* Enable frame retransmissions for lossy channels */\n\thw->max_rates = 4;\n\thw->max_rate_tries = 11;\n\n\thw->wiphy->vendor_commands = mac80211_hwsim_vendor_commands;\n\thw->wiphy->n_vendor_commands =\n\t\tARRAY_SIZE(mac80211_hwsim_vendor_commands);\n\thw->wiphy->vendor_events = mac80211_hwsim_vendor_events;\n\thw->wiphy->n_vendor_events = ARRAY_SIZE(mac80211_hwsim_vendor_events);\n\n\tif (param->reg_strict)\n\t\thw->wiphy->regulatory_flags |= REGULATORY_STRICT_REG;\n\tif (param->regd) {\n\t\tdata->regd = param->regd;\n\t\thw->wiphy->regulatory_flags |= REGULATORY_CUSTOM_REG;\n\t\twiphy_apply_custom_regulatory(hw->wiphy, param->regd);\n\t\t/* give the regulatory workqueue a chance to run */\n\t\tschedule_timeout_interruptible(1);\n\t}\n\n\tif (param->no_vif)\n\t\tieee80211_hw_set(hw, NO_AUTO_VIF);\n\n\twiphy_ext_feature_set(hw->wiphy, NL80211_EXT_FEATURE_CQM_RSSI_LIST);\n\n\terr = ieee80211_register_hw(hw);\n\tif (err < 0) {\n\t\tpr_debug(\"mac80211_hwsim: ieee80211_register_hw failed (%d)\\n\",\n\t\t       err);\n\t\tgoto failed_hw;\n\t}\n\n\twiphy_dbg(hw->wiphy, \"hwaddr %pM registered\\n\", hw->wiphy->perm_addr);\n\n\tif (param->reg_alpha2) {\n\t\tdata->alpha2[0] = param->reg_alpha2[0];\n\t\tdata->alpha2[1] = param->reg_alpha2[1];\n\t\tregulatory_hint(hw->wiphy, param->reg_alpha2);\n\t}\n\n\tdata->debugfs = debugfs_create_dir(\"hwsim\", hw->wiphy->debugfsdir);\n\tdebugfs_create_file(\"ps\", 0666, data->debugfs, data, &hwsim_fops_ps);\n\tdebugfs_create_file(\"group\", 0666, data->debugfs, data,\n\t\t\t    &hwsim_fops_group);\n\tif (!data->use_chanctx)\n\t\tdebugfs_create_file(\"dfs_simulate_radar\", 0222,\n\t\t\t\t    data->debugfs,\n\t\t\t\t    data, &hwsim_simulate_radar);\n\n\ttasklet_hrtimer_init(&data->beacon_timer,\n\t\t\t     mac80211_hwsim_beacon,\n\t\t\t     CLOCK_MONOTONIC, HRTIMER_MODE_ABS);\n\n\tspin_lock_bh(&hwsim_radio_lock);\n\terr = rhashtable_insert_fast(&hwsim_radios_rht, &data->rht,\n\t\t\t\t     hwsim_rht_params);\n\tif (err < 0) {\n\t\tpr_debug(\"mac80211_hwsim: radio index %d already present\\n\",\n\t\t\t idx);\n\t\tspin_unlock_bh(&hwsim_radio_lock);\n\t\tgoto failed_final_insert;\n\t}\n\n\tlist_add_tail(&data->list, &hwsim_radios);\n\tspin_unlock_bh(&hwsim_radio_lock);\n\n\tif (idx > 0)\n\t\thwsim_mcast_new_radio(idx, info, param);\n\n\treturn idx;\n\nfailed_final_insert:\n\tdebugfs_remove_recursive(data->debugfs);\n\tieee80211_unregister_hw(data->hw);\nfailed_hw:\n\tdevice_release_driver(data->dev);\nfailed_bind:\n\tdevice_unregister(data->dev);\nfailed_drvdata:\n\tieee80211_free_hw(hw);\nfailed:\n\treturn err;\n}\n\nstatic void hwsim_mcast_del_radio(int id, const char *hwname,\n\t\t\t\t  struct genl_info *info)\n{\n\tstruct sk_buff *skb;\n\tvoid *data;\n\tint ret;\n\n\tskb = genlmsg_new(GENLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!skb)\n\t\treturn;\n\n\tdata = genlmsg_put(skb, 0, 0, &hwsim_genl_family, 0,\n\t\t\t   HWSIM_CMD_DEL_RADIO);\n\tif (!data)\n\t\tgoto error;\n\n\tret = nla_put_u32(skb, HWSIM_ATTR_RADIO_ID, id);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tret = nla_put(skb, HWSIM_ATTR_RADIO_NAME, strlen(hwname),\n\t\t      hwname);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tgenlmsg_end(skb, data);\n\n\thwsim_mcast_config_msg(skb, info);\n\n\treturn;\n\nerror:\n\tnlmsg_free(skb);\n}\n\nstatic void mac80211_hwsim_del_radio(struct mac80211_hwsim_data *data,\n\t\t\t\t     const char *hwname,\n\t\t\t\t     struct genl_info *info)\n{\n\thwsim_mcast_del_radio(data->idx, hwname, info);\n\tdebugfs_remove_recursive(data->debugfs);\n\tieee80211_unregister_hw(data->hw);\n\tdevice_release_driver(data->dev);\n\tdevice_unregister(data->dev);\n\tieee80211_free_hw(data->hw);\n}\n\nstatic int mac80211_hwsim_get_radio(struct sk_buff *skb,\n\t\t\t\t    struct mac80211_hwsim_data *data,\n\t\t\t\t    u32 portid, u32 seq,\n\t\t\t\t    struct netlink_callback *cb, int flags)\n{\n\tvoid *hdr;\n\tstruct hwsim_new_radio_params param = { };\n\tint res = -EMSGSIZE;\n\n\thdr = genlmsg_put(skb, portid, seq, &hwsim_genl_family, flags,\n\t\t\t  HWSIM_CMD_GET_RADIO);\n\tif (!hdr)\n\t\treturn -EMSGSIZE;\n\n\tif (cb)\n\t\tgenl_dump_check_consistent(cb, hdr);\n\n\tif (data->alpha2[0] && data->alpha2[1])\n\t\tparam.reg_alpha2 = data->alpha2;\n\n\tparam.reg_strict = !!(data->hw->wiphy->regulatory_flags &\n\t\t\t\t\tREGULATORY_STRICT_REG);\n\tparam.p2p_device = !!(data->hw->wiphy->interface_modes &\n\t\t\t\t\tBIT(NL80211_IFTYPE_P2P_DEVICE));\n\tparam.use_chanctx = data->use_chanctx;\n\tparam.regd = data->regd;\n\tparam.channels = data->channels;\n\tparam.hwname = wiphy_name(data->hw->wiphy);\n\n\tres = append_radio_msg(skb, data->idx, &param);\n\tif (res < 0)\n\t\tgoto out_err;\n\n\tgenlmsg_end(skb, hdr);\n\treturn 0;\n\nout_err:\n\tgenlmsg_cancel(skb, hdr);\n\treturn res;\n}\n\nstatic void mac80211_hwsim_free(void)\n{\n\tstruct mac80211_hwsim_data *data;\n\n\tspin_lock_bh(&hwsim_radio_lock);\n\twhile ((data = list_first_entry_or_null(&hwsim_radios,\n\t\t\t\t\t\tstruct mac80211_hwsim_data,\n\t\t\t\t\t\tlist))) {\n\t\tlist_del(&data->list);\n\t\tspin_unlock_bh(&hwsim_radio_lock);\n\t\tmac80211_hwsim_del_radio(data, wiphy_name(data->hw->wiphy),\n\t\t\t\t\t NULL);\n\t\tspin_lock_bh(&hwsim_radio_lock);\n\t}\n\tspin_unlock_bh(&hwsim_radio_lock);\n\tclass_destroy(hwsim_class);\n}\n\nstatic const struct net_device_ops hwsim_netdev_ops = {\n\t.ndo_start_xmit \t= hwsim_mon_xmit,\n\t.ndo_set_mac_address \t= eth_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\nstatic void hwsim_mon_setup(struct net_device *dev)\n{\n\tdev->netdev_ops = &hwsim_netdev_ops;\n\tdev->needs_free_netdev = true;\n\tether_setup(dev);\n\tdev->priv_flags |= IFF_NO_QUEUE;\n\tdev->type = ARPHRD_IEEE80211_RADIOTAP;\n\teth_zero_addr(dev->dev_addr);\n\tdev->dev_addr[0] = 0x12;\n}\n\nstatic struct mac80211_hwsim_data *get_hwsim_data_ref_from_addr(const u8 *addr)\n{\n\treturn rhashtable_lookup_fast(&hwsim_radios_rht,\n\t\t\t\t      addr,\n\t\t\t\t      hwsim_rht_params);\n}\n\nstatic void hwsim_register_wmediumd(struct net *net, u32 portid)\n{\n\tstruct mac80211_hwsim_data *data;\n\n\thwsim_net_set_wmediumd(net, portid);\n\n\tspin_lock_bh(&hwsim_radio_lock);\n\tlist_for_each_entry(data, &hwsim_radios, list) {\n\t\tif (data->netgroup == hwsim_net_get_netgroup(net))\n\t\t\tdata->wmediumd = portid;\n\t}\n\tspin_unlock_bh(&hwsim_radio_lock);\n}\n\nstatic int hwsim_tx_info_frame_received_nl(struct sk_buff *skb_2,\n\t\t\t\t\t   struct genl_info *info)\n{\n\n\tstruct ieee80211_hdr *hdr;\n\tstruct mac80211_hwsim_data *data2;\n\tstruct ieee80211_tx_info *txi;\n\tstruct hwsim_tx_rate *tx_attempts;\n\tu64 ret_skb_cookie;\n\tstruct sk_buff *skb, *tmp;\n\tconst u8 *src;\n\tunsigned int hwsim_flags;\n\tint i;\n\tbool found = false;\n\n\tif (!info->attrs[HWSIM_ATTR_ADDR_TRANSMITTER] ||\n\t    !info->attrs[HWSIM_ATTR_FLAGS] ||\n\t    !info->attrs[HWSIM_ATTR_COOKIE] ||\n\t    !info->attrs[HWSIM_ATTR_SIGNAL] ||\n\t    !info->attrs[HWSIM_ATTR_TX_INFO])\n\t\tgoto out;\n\n\tsrc = (void *)nla_data(info->attrs[HWSIM_ATTR_ADDR_TRANSMITTER]);\n\thwsim_flags = nla_get_u32(info->attrs[HWSIM_ATTR_FLAGS]);\n\tret_skb_cookie = nla_get_u64(info->attrs[HWSIM_ATTR_COOKIE]);\n\n\tdata2 = get_hwsim_data_ref_from_addr(src);\n\tif (!data2)\n\t\tgoto out;\n\n\tif (hwsim_net_get_netgroup(genl_info_net(info)) != data2->netgroup)\n\t\tgoto out;\n\n\tif (info->snd_portid != data2->wmediumd)\n\t\tgoto out;\n\n\t/* look for the skb matching the cookie passed back from user */\n\tskb_queue_walk_safe(&data2->pending, skb, tmp) {\n\t\tu64 skb_cookie;\n\n\t\ttxi = IEEE80211_SKB_CB(skb);\n\t\tskb_cookie = (u64)(uintptr_t)txi->rate_driver_data[0];\n\n\t\tif (skb_cookie == ret_skb_cookie) {\n\t\t\tskb_unlink(skb, &data2->pending);\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* not found */\n\tif (!found)\n\t\tgoto out;\n\n\t/* Tx info received because the frame was broadcasted on user space,\n\t so we get all the necessary info: tx attempts and skb control buff */\n\n\ttx_attempts = (struct hwsim_tx_rate *)nla_data(\n\t\t       info->attrs[HWSIM_ATTR_TX_INFO]);\n\n\t/* now send back TX status */\n\ttxi = IEEE80211_SKB_CB(skb);\n\n\tieee80211_tx_info_clear_status(txi);\n\n\tfor (i = 0; i < IEEE80211_TX_MAX_RATES; i++) {\n\t\ttxi->status.rates[i].idx = tx_attempts[i].idx;\n\t\ttxi->status.rates[i].count = tx_attempts[i].count;\n\t}\n\n\ttxi->status.ack_signal = nla_get_u32(info->attrs[HWSIM_ATTR_SIGNAL]);\n\n\tif (!(hwsim_flags & HWSIM_TX_CTL_NO_ACK) &&\n\t   (hwsim_flags & HWSIM_TX_STAT_ACK)) {\n\t\tif (skb->len >= 16) {\n\t\t\thdr = (struct ieee80211_hdr *) skb->data;\n\t\t\tmac80211_hwsim_monitor_ack(data2->channel,\n\t\t\t\t\t\t   hdr->addr2);\n\t\t}\n\t\ttxi->flags |= IEEE80211_TX_STAT_ACK;\n\t}\n\tieee80211_tx_status_irqsafe(data2->hw, skb);\n\treturn 0;\nout:\n\treturn -EINVAL;\n\n}\n\nstatic int hwsim_cloned_frame_received_nl(struct sk_buff *skb_2,\n\t\t\t\t\t  struct genl_info *info)\n{\n\tstruct mac80211_hwsim_data *data2;\n\tstruct ieee80211_rx_status rx_status;\n\tconst u8 *dst;\n\tint frame_data_len;\n\tvoid *frame_data;\n\tstruct sk_buff *skb = NULL;\n\n\tif (!info->attrs[HWSIM_ATTR_ADDR_RECEIVER] ||\n\t    !info->attrs[HWSIM_ATTR_FRAME] ||\n\t    !info->attrs[HWSIM_ATTR_RX_RATE] ||\n\t    !info->attrs[HWSIM_ATTR_SIGNAL])\n\t\tgoto out;\n\n\tdst = (void *)nla_data(info->attrs[HWSIM_ATTR_ADDR_RECEIVER]);\n\tframe_data_len = nla_len(info->attrs[HWSIM_ATTR_FRAME]);\n\tframe_data = (void *)nla_data(info->attrs[HWSIM_ATTR_FRAME]);\n\n\t/* Allocate new skb here */\n\tskb = alloc_skb(frame_data_len, GFP_KERNEL);\n\tif (skb == NULL)\n\t\tgoto err;\n\n\tif (frame_data_len > IEEE80211_MAX_DATA_LEN)\n\t\tgoto err;\n\n\t/* Copy the data */\n\tskb_put_data(skb, frame_data, frame_data_len);\n\n\tdata2 = get_hwsim_data_ref_from_addr(dst);\n\tif (!data2)\n\t\tgoto out;\n\n\tif (hwsim_net_get_netgroup(genl_info_net(info)) != data2->netgroup)\n\t\tgoto out;\n\n\tif (info->snd_portid != data2->wmediumd)\n\t\tgoto out;\n\n\t/* check if radio is configured properly */\n\n\tif (data2->idle || !data2->started)\n\t\tgoto out;\n\n\t/* A frame is received from user space */\n\tmemset(&rx_status, 0, sizeof(rx_status));\n\tif (info->attrs[HWSIM_ATTR_FREQ]) {\n\t\t/* throw away off-channel packets, but allow both the temporary\n\t\t * (\"hw\" scan/remain-on-channel) and regular channel, since the\n\t\t * internal datapath also allows this\n\t\t */\n\t\tmutex_lock(&data2->mutex);\n\t\trx_status.freq = nla_get_u32(info->attrs[HWSIM_ATTR_FREQ]);\n\n\t\tif (rx_status.freq != data2->channel->center_freq &&\n\t\t    (!data2->tmp_chan ||\n\t\t     rx_status.freq != data2->tmp_chan->center_freq)) {\n\t\t\tmutex_unlock(&data2->mutex);\n\t\t\tgoto out;\n\t\t}\n\t\tmutex_unlock(&data2->mutex);\n\t} else {\n\t\trx_status.freq = data2->channel->center_freq;\n\t}\n\n\trx_status.band = data2->channel->band;\n\trx_status.rate_idx = nla_get_u32(info->attrs[HWSIM_ATTR_RX_RATE]);\n\trx_status.signal = nla_get_u32(info->attrs[HWSIM_ATTR_SIGNAL]);\n\n\tmemcpy(IEEE80211_SKB_RXCB(skb), &rx_status, sizeof(rx_status));\n\tdata2->rx_pkts++;\n\tdata2->rx_bytes += skb->len;\n\tieee80211_rx_irqsafe(data2->hw, skb);\n\n\treturn 0;\nerr:\n\tpr_debug(\"mac80211_hwsim: error occurred in %s\\n\", __func__);\nout:\n\tdev_kfree_skb(skb);\n\treturn -EINVAL;\n}\n\nstatic int hwsim_register_received_nl(struct sk_buff *skb_2,\n\t\t\t\t      struct genl_info *info)\n{\n\tstruct net *net = genl_info_net(info);\n\tstruct mac80211_hwsim_data *data;\n\tint chans = 1;\n\n\tspin_lock_bh(&hwsim_radio_lock);\n\tlist_for_each_entry(data, &hwsim_radios, list)\n\t\tchans = max(chans, data->channels);\n\tspin_unlock_bh(&hwsim_radio_lock);\n\n\t/* In the future we should revise the userspace API and allow it\n\t * to set a flag that it does support multi-channel, then we can\n\t * let this pass conditionally on the flag.\n\t * For current userspace, prohibit it since it won't work right.\n\t */\n\tif (chans > 1)\n\t\treturn -EOPNOTSUPP;\n\n\tif (hwsim_net_get_wmediumd(net))\n\t\treturn -EBUSY;\n\n\thwsim_register_wmediumd(net, info->snd_portid);\n\n\tpr_debug(\"mac80211_hwsim: received a REGISTER, \"\n\t       \"switching to wmediumd mode with pid %d\\n\", info->snd_portid);\n\n\treturn 0;\n}\n\nstatic int hwsim_new_radio_nl(struct sk_buff *msg, struct genl_info *info)\n{\n\tstruct hwsim_new_radio_params param = { 0 };\n\tconst char *hwname = NULL;\n\tint ret;\n\n\tparam.reg_strict = info->attrs[HWSIM_ATTR_REG_STRICT_REG];\n\tparam.p2p_device = info->attrs[HWSIM_ATTR_SUPPORT_P2P_DEVICE];\n\tparam.channels = channels;\n\tparam.destroy_on_close =\n\t\tinfo->attrs[HWSIM_ATTR_DESTROY_RADIO_ON_CLOSE];\n\n\tif (info->attrs[HWSIM_ATTR_CHANNELS])\n\t\tparam.channels = nla_get_u32(info->attrs[HWSIM_ATTR_CHANNELS]);\n\n\tif (info->attrs[HWSIM_ATTR_NO_VIF])\n\t\tparam.no_vif = true;\n\n\tif (info->attrs[HWSIM_ATTR_RADIO_NAME]) {\n\t\thwname = kasprintf(GFP_KERNEL, \"%.*s\",\n\t\t\t\t   nla_len(info->attrs[HWSIM_ATTR_RADIO_NAME]),\n\t\t\t\t   (char *)nla_data(info->attrs[HWSIM_ATTR_RADIO_NAME]));\n\t\tif (!hwname)\n\t\t\treturn -ENOMEM;\n\t\tparam.hwname = hwname;\n\t}\n\n\tif (info->attrs[HWSIM_ATTR_USE_CHANCTX])\n\t\tparam.use_chanctx = true;\n\telse\n\t\tparam.use_chanctx = (param.channels > 1);\n\n\tif (info->attrs[HWSIM_ATTR_REG_HINT_ALPHA2])\n\t\tparam.reg_alpha2 =\n\t\t\tnla_data(info->attrs[HWSIM_ATTR_REG_HINT_ALPHA2]);\n\n\tif (info->attrs[HWSIM_ATTR_REG_CUSTOM_REG]) {\n\t\tu32 idx = nla_get_u32(info->attrs[HWSIM_ATTR_REG_CUSTOM_REG]);\n\n\t\tif (idx >= ARRAY_SIZE(hwsim_world_regdom_custom))\n\t\t\treturn -EINVAL;\n\t\tparam.regd = hwsim_world_regdom_custom[idx];\n\t}\n\n\tret = mac80211_hwsim_new_radio(info, &param);\n\tkfree(hwname);\n\treturn ret;\n}\n\nstatic int hwsim_del_radio_nl(struct sk_buff *msg, struct genl_info *info)\n{\n\tstruct mac80211_hwsim_data *data;\n\ts64 idx = -1;\n\tconst char *hwname = NULL;\n\n\tif (info->attrs[HWSIM_ATTR_RADIO_ID]) {\n\t\tidx = nla_get_u32(info->attrs[HWSIM_ATTR_RADIO_ID]);\n\t} else if (info->attrs[HWSIM_ATTR_RADIO_NAME]) {\n\t\thwname = kasprintf(GFP_KERNEL, \"%.*s\",\n\t\t\t\t   nla_len(info->attrs[HWSIM_ATTR_RADIO_NAME]),\n\t\t\t\t   (char *)nla_data(info->attrs[HWSIM_ATTR_RADIO_NAME]));\n\t\tif (!hwname)\n\t\t\treturn -ENOMEM;\n\t} else\n\t\treturn -EINVAL;\n\n\tspin_lock_bh(&hwsim_radio_lock);\n\tlist_for_each_entry(data, &hwsim_radios, list) {\n\t\tif (idx >= 0) {\n\t\t\tif (data->idx != idx)\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\tif (!hwname ||\n\t\t\t    strcmp(hwname, wiphy_name(data->hw->wiphy)))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (!net_eq(wiphy_net(data->hw->wiphy), genl_info_net(info)))\n\t\t\tcontinue;\n\n\t\tlist_del(&data->list);\n\t\trhashtable_remove_fast(&hwsim_radios_rht, &data->rht,\n\t\t\t\t       hwsim_rht_params);\n\t\tspin_unlock_bh(&hwsim_radio_lock);\n\t\tmac80211_hwsim_del_radio(data, wiphy_name(data->hw->wiphy),\n\t\t\t\t\t info);\n\t\tkfree(hwname);\n\t\treturn 0;\n\t}\n\tspin_unlock_bh(&hwsim_radio_lock);\n\n\tkfree(hwname);\n\treturn -ENODEV;\n}\n\nstatic int hwsim_get_radio_nl(struct sk_buff *msg, struct genl_info *info)\n{\n\tstruct mac80211_hwsim_data *data;\n\tstruct sk_buff *skb;\n\tint idx, res = -ENODEV;\n\n\tif (!info->attrs[HWSIM_ATTR_RADIO_ID])\n\t\treturn -EINVAL;\n\tidx = nla_get_u32(info->attrs[HWSIM_ATTR_RADIO_ID]);\n\n\tspin_lock_bh(&hwsim_radio_lock);\n\tlist_for_each_entry(data, &hwsim_radios, list) {\n\t\tif (data->idx != idx)\n\t\t\tcontinue;\n\n\t\tif (!net_eq(wiphy_net(data->hw->wiphy), genl_info_net(info)))\n\t\t\tcontinue;\n\n\t\tskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\n\t\tif (!skb) {\n\t\t\tres = -ENOMEM;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tres = mac80211_hwsim_get_radio(skb, data, info->snd_portid,\n\t\t\t\t\t       info->snd_seq, NULL, 0);\n\t\tif (res < 0) {\n\t\t\tnlmsg_free(skb);\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tgenlmsg_reply(skb, info);\n\t\tbreak;\n\t}\n\nout_err:\n\tspin_unlock_bh(&hwsim_radio_lock);\n\n\treturn res;\n}\n\nstatic int hwsim_dump_radio_nl(struct sk_buff *skb,\n\t\t\t       struct netlink_callback *cb)\n{\n\tint idx = cb->args[0];\n\tstruct mac80211_hwsim_data *data = NULL;\n\tint res;\n\n\tspin_lock_bh(&hwsim_radio_lock);\n\n\tif (idx == hwsim_radio_idx)\n\t\tgoto done;\n\n\tlist_for_each_entry(data, &hwsim_radios, list) {\n\t\tif (data->idx < idx)\n\t\t\tcontinue;\n\n\t\tif (!net_eq(wiphy_net(data->hw->wiphy), sock_net(skb->sk)))\n\t\t\tcontinue;\n\n\t\tres = mac80211_hwsim_get_radio(skb, data,\n\t\t\t\t\t       NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t       cb->nlh->nlmsg_seq, cb,\n\t\t\t\t\t       NLM_F_MULTI);\n\t\tif (res < 0)\n\t\t\tbreak;\n\n\t\tidx = data->idx + 1;\n\t}\n\n\tcb->args[0] = idx;\n\ndone:\n\tspin_unlock_bh(&hwsim_radio_lock);\n\treturn skb->len;\n}\n\n/* Generic Netlink operations array */\nstatic const struct genl_ops hwsim_ops[] = {\n\t{\n\t\t.cmd = HWSIM_CMD_REGISTER,\n\t\t.policy = hwsim_genl_policy,\n\t\t.doit = hwsim_register_received_nl,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = HWSIM_CMD_FRAME,\n\t\t.policy = hwsim_genl_policy,\n\t\t.doit = hwsim_cloned_frame_received_nl,\n\t},\n\t{\n\t\t.cmd = HWSIM_CMD_TX_INFO_FRAME,\n\t\t.policy = hwsim_genl_policy,\n\t\t.doit = hwsim_tx_info_frame_received_nl,\n\t},\n\t{\n\t\t.cmd = HWSIM_CMD_NEW_RADIO,\n\t\t.policy = hwsim_genl_policy,\n\t\t.doit = hwsim_new_radio_nl,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = HWSIM_CMD_DEL_RADIO,\n\t\t.policy = hwsim_genl_policy,\n\t\t.doit = hwsim_del_radio_nl,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = HWSIM_CMD_GET_RADIO,\n\t\t.policy = hwsim_genl_policy,\n\t\t.doit = hwsim_get_radio_nl,\n\t\t.dumpit = hwsim_dump_radio_nl,\n\t},\n};\n\nstatic struct genl_family hwsim_genl_family __ro_after_init = {\n\t.name = \"MAC80211_HWSIM\",\n\t.version = 1,\n\t.maxattr = HWSIM_ATTR_MAX,\n\t.netnsok = true,\n\t.module = THIS_MODULE,\n\t.ops = hwsim_ops,\n\t.n_ops = ARRAY_SIZE(hwsim_ops),\n\t.mcgrps = hwsim_mcgrps,\n\t.n_mcgrps = ARRAY_SIZE(hwsim_mcgrps),\n};\n\nstatic void destroy_radio(struct work_struct *work)\n{\n\tstruct mac80211_hwsim_data *data =\n\t\tcontainer_of(work, struct mac80211_hwsim_data, destroy_work);\n\n\tmac80211_hwsim_del_radio(data, wiphy_name(data->hw->wiphy), NULL);\n}\n\nstatic void remove_user_radios(u32 portid)\n{\n\tstruct mac80211_hwsim_data *entry, *tmp;\n\n\tspin_lock_bh(&hwsim_radio_lock);\n\tlist_for_each_entry_safe(entry, tmp, &hwsim_radios, list) {\n\t\tif (entry->destroy_on_close && entry->portid == portid) {\n\t\t\tlist_del(&entry->list);\n\t\t\trhashtable_remove_fast(&hwsim_radios_rht, &entry->rht,\n\t\t\t\t\t       hwsim_rht_params);\n\t\t\tINIT_WORK(&entry->destroy_work, destroy_radio);\n\t\t\tschedule_work(&entry->destroy_work);\n\t\t}\n\t}\n\tspin_unlock_bh(&hwsim_radio_lock);\n}\n\nstatic int mac80211_hwsim_netlink_notify(struct notifier_block *nb,\n\t\t\t\t\t unsigned long state,\n\t\t\t\t\t void *_notify)\n{\n\tstruct netlink_notify *notify = _notify;\n\n\tif (state != NETLINK_URELEASE)\n\t\treturn NOTIFY_DONE;\n\n\tremove_user_radios(notify->portid);\n\n\tif (notify->portid == hwsim_net_get_wmediumd(notify->net)) {\n\t\tprintk(KERN_INFO \"mac80211_hwsim: wmediumd released netlink\"\n\t\t       \" socket, switching to perfect channel medium\\n\");\n\t\thwsim_register_wmediumd(notify->net, 0);\n\t}\n\treturn NOTIFY_DONE;\n\n}\n\nstatic struct notifier_block hwsim_netlink_notifier = {\n\t.notifier_call = mac80211_hwsim_netlink_notify,\n};\n\nstatic int __init hwsim_init_netlink(void)\n{\n\tint rc;\n\n\tprintk(KERN_INFO \"mac80211_hwsim: initializing netlink\\n\");\n\n\trc = genl_register_family(&hwsim_genl_family);\n\tif (rc)\n\t\tgoto failure;\n\n\trc = netlink_register_notifier(&hwsim_netlink_notifier);\n\tif (rc) {\n\t\tgenl_unregister_family(&hwsim_genl_family);\n\t\tgoto failure;\n\t}\n\n\treturn 0;\n\nfailure:\n\tpr_debug(\"mac80211_hwsim: error occurred in %s\\n\", __func__);\n\treturn -EINVAL;\n}\n\nstatic __net_init int hwsim_init_net(struct net *net)\n{\n\thwsim_net_set_netgroup(net);\n\n\treturn 0;\n}\n\nstatic void __net_exit hwsim_exit_net(struct net *net)\n{\n\tstruct mac80211_hwsim_data *data, *tmp;\n\n\tspin_lock_bh(&hwsim_radio_lock);\n\tlist_for_each_entry_safe(data, tmp, &hwsim_radios, list) {\n\t\tif (!net_eq(wiphy_net(data->hw->wiphy), net))\n\t\t\tcontinue;\n\n\t\t/* Radios created in init_net are returned to init_net. */\n\t\tif (data->netgroup == hwsim_net_get_netgroup(&init_net))\n\t\t\tcontinue;\n\n\t\tlist_del(&data->list);\n\t\trhashtable_remove_fast(&hwsim_radios_rht, &data->rht,\n\t\t\t\t       hwsim_rht_params);\n\t\tINIT_WORK(&data->destroy_work, destroy_radio);\n\t\tschedule_work(&data->destroy_work);\n\t}\n\tspin_unlock_bh(&hwsim_radio_lock);\n}\n\nstatic struct pernet_operations hwsim_net_ops = {\n\t.init = hwsim_init_net,\n\t.exit = hwsim_exit_net,\n\t.id   = &hwsim_net_id,\n\t.size = sizeof(struct hwsim_net),\n};\n\nstatic void hwsim_exit_netlink(void)\n{\n\t/* unregister the notifier */\n\tnetlink_unregister_notifier(&hwsim_netlink_notifier);\n\t/* unregister the family */\n\tgenl_unregister_family(&hwsim_genl_family);\n}\n\nstatic int __init init_mac80211_hwsim(void)\n{\n\tint i, err;\n\n\tif (radios < 0 || radios > 100)\n\t\treturn -EINVAL;\n\n\tif (channels < 1)\n\t\treturn -EINVAL;\n\n\tspin_lock_init(&hwsim_radio_lock);\n\n\trhashtable_init(&hwsim_radios_rht, &hwsim_rht_params);\n\n\terr = register_pernet_device(&hwsim_net_ops);\n\tif (err)\n\t\treturn err;\n\n\terr = platform_driver_register(&mac80211_hwsim_driver);\n\tif (err)\n\t\tgoto out_unregister_pernet;\n\n\thwsim_class = class_create(THIS_MODULE, \"mac80211_hwsim\");\n\tif (IS_ERR(hwsim_class)) {\n\t\terr = PTR_ERR(hwsim_class);\n\t\tgoto out_unregister_driver;\n\t}\n\n\terr = hwsim_init_netlink();\n\tif (err < 0)\n\t\tgoto out_unregister_driver;\n\n\tfor (i = 0; i < radios; i++) {\n\t\tstruct hwsim_new_radio_params param = { 0 };\n\n\t\tparam.channels = channels;\n\n\t\tswitch (regtest) {\n\t\tcase HWSIM_REGTEST_DIFF_COUNTRY:\n\t\t\tif (i < ARRAY_SIZE(hwsim_alpha2s))\n\t\t\t\tparam.reg_alpha2 = hwsim_alpha2s[i];\n\t\t\tbreak;\n\t\tcase HWSIM_REGTEST_DRIVER_REG_FOLLOW:\n\t\t\tif (!i)\n\t\t\t\tparam.reg_alpha2 = hwsim_alpha2s[0];\n\t\t\tbreak;\n\t\tcase HWSIM_REGTEST_STRICT_ALL:\n\t\t\tparam.reg_strict = true;\n\t\tcase HWSIM_REGTEST_DRIVER_REG_ALL:\n\t\t\tparam.reg_alpha2 = hwsim_alpha2s[0];\n\t\t\tbreak;\n\t\tcase HWSIM_REGTEST_WORLD_ROAM:\n\t\t\tif (i == 0)\n\t\t\t\tparam.regd = &hwsim_world_regdom_custom_01;\n\t\t\tbreak;\n\t\tcase HWSIM_REGTEST_CUSTOM_WORLD:\n\t\t\tparam.regd = &hwsim_world_regdom_custom_01;\n\t\t\tbreak;\n\t\tcase HWSIM_REGTEST_CUSTOM_WORLD_2:\n\t\t\tif (i == 0)\n\t\t\t\tparam.regd = &hwsim_world_regdom_custom_01;\n\t\t\telse if (i == 1)\n\t\t\t\tparam.regd = &hwsim_world_regdom_custom_02;\n\t\t\tbreak;\n\t\tcase HWSIM_REGTEST_STRICT_FOLLOW:\n\t\t\tif (i == 0) {\n\t\t\t\tparam.reg_strict = true;\n\t\t\t\tparam.reg_alpha2 = hwsim_alpha2s[0];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase HWSIM_REGTEST_STRICT_AND_DRIVER_REG:\n\t\t\tif (i == 0) {\n\t\t\t\tparam.reg_strict = true;\n\t\t\t\tparam.reg_alpha2 = hwsim_alpha2s[0];\n\t\t\t} else if (i == 1) {\n\t\t\t\tparam.reg_alpha2 = hwsim_alpha2s[1];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase HWSIM_REGTEST_ALL:\n\t\t\tswitch (i) {\n\t\t\tcase 0:\n\t\t\t\tparam.regd = &hwsim_world_regdom_custom_01;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tparam.regd = &hwsim_world_regdom_custom_02;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tparam.reg_alpha2 = hwsim_alpha2s[0];\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tparam.reg_alpha2 = hwsim_alpha2s[1];\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tparam.reg_strict = true;\n\t\t\t\tparam.reg_alpha2 = hwsim_alpha2s[2];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tparam.p2p_device = support_p2p_device;\n\t\tparam.use_chanctx = channels > 1;\n\n\t\terr = mac80211_hwsim_new_radio(NULL, &param);\n\t\tif (err < 0)\n\t\t\tgoto out_free_radios;\n\t}\n\n\thwsim_mon = alloc_netdev(0, \"hwsim%d\", NET_NAME_UNKNOWN,\n\t\t\t\t hwsim_mon_setup);\n\tif (hwsim_mon == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto out_free_radios;\n\t}\n\n\trtnl_lock();\n\terr = dev_alloc_name(hwsim_mon, hwsim_mon->name);\n\tif (err < 0) {\n\t\trtnl_unlock();\n\t\tgoto out_free_radios;\n\t}\n\n\terr = register_netdevice(hwsim_mon);\n\tif (err < 0) {\n\t\trtnl_unlock();\n\t\tgoto out_free_mon;\n\t}\n\trtnl_unlock();\n\n\treturn 0;\n\nout_free_mon:\n\tfree_netdev(hwsim_mon);\nout_free_radios:\n\tmac80211_hwsim_free();\nout_unregister_driver:\n\tplatform_driver_unregister(&mac80211_hwsim_driver);\nout_unregister_pernet:\n\tunregister_pernet_device(&hwsim_net_ops);\n\treturn err;\n}\nmodule_init(init_mac80211_hwsim);\n\nstatic void __exit exit_mac80211_hwsim(void)\n{\n\tpr_debug(\"mac80211_hwsim: unregister radios\\n\");\n\n\thwsim_exit_netlink();\n\n\tmac80211_hwsim_free();\n\trhashtable_destroy(&hwsim_radios_rht);\n\tunregister_netdev(hwsim_mon);\n\tplatform_driver_unregister(&mac80211_hwsim_driver);\n\tunregister_pernet_device(&hwsim_net_ops);\n}\nmodule_exit(exit_mac80211_hwsim);\n"], "fixing_code": ["/*\n * mac80211_hwsim - software simulator of 802.11 radio(s) for mac80211\n * Copyright (c) 2008, Jouni Malinen <j@w1.fi>\n * Copyright (c) 2011, Javier Lopez <jlopex@gmail.com>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation.\n */\n\n/*\n * TODO:\n * - Add TSF sync and fix IBSS beacon transmission by adding\n *   competition for \"air time\" at TBTT\n * - RX filtering based on filter configuration (data->rx_filter)\n */\n\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <net/dst.h>\n#include <net/xfrm.h>\n#include <net/mac80211.h>\n#include <net/ieee80211_radiotap.h>\n#include <linux/if_arp.h>\n#include <linux/rtnetlink.h>\n#include <linux/etherdevice.h>\n#include <linux/platform_device.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/ktime.h>\n#include <net/genetlink.h>\n#include <net/net_namespace.h>\n#include <net/netns/generic.h>\n#include <linux/rhashtable.h>\n#include \"mac80211_hwsim.h\"\n\n#define WARN_QUEUE 100\n#define MAX_QUEUE 200\n\nMODULE_AUTHOR(\"Jouni Malinen\");\nMODULE_DESCRIPTION(\"Software simulator of 802.11 radio(s) for mac80211\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int radios = 2;\nmodule_param(radios, int, 0444);\nMODULE_PARM_DESC(radios, \"Number of simulated radios\");\n\nstatic int channels = 1;\nmodule_param(channels, int, 0444);\nMODULE_PARM_DESC(channels, \"Number of concurrent channels\");\n\nstatic bool paged_rx = false;\nmodule_param(paged_rx, bool, 0644);\nMODULE_PARM_DESC(paged_rx, \"Use paged SKBs for RX instead of linear ones\");\n\nstatic bool rctbl = false;\nmodule_param(rctbl, bool, 0444);\nMODULE_PARM_DESC(rctbl, \"Handle rate control table\");\n\nstatic bool support_p2p_device = true;\nmodule_param(support_p2p_device, bool, 0444);\nMODULE_PARM_DESC(support_p2p_device, \"Support P2P-Device interface type\");\n\n/**\n * enum hwsim_regtest - the type of regulatory tests we offer\n *\n * These are the different values you can use for the regtest\n * module parameter. This is useful to help test world roaming\n * and the driver regulatory_hint() call and combinations of these.\n * If you want to do specific alpha2 regulatory domain tests simply\n * use the userspace regulatory request as that will be respected as\n * well without the need of this module parameter. This is designed\n * only for testing the driver regulatory request, world roaming\n * and all possible combinations.\n *\n * @HWSIM_REGTEST_DISABLED: No regulatory tests are performed,\n * \tthis is the default value.\n * @HWSIM_REGTEST_DRIVER_REG_FOLLOW: Used for testing the driver regulatory\n *\thint, only one driver regulatory hint will be sent as such the\n * \tsecondary radios are expected to follow.\n * @HWSIM_REGTEST_DRIVER_REG_ALL: Used for testing the driver regulatory\n * \trequest with all radios reporting the same regulatory domain.\n * @HWSIM_REGTEST_DIFF_COUNTRY: Used for testing the drivers calling\n * \tdifferent regulatory domains requests. Expected behaviour is for\n * \tan intersection to occur but each device will still use their\n * \trespective regulatory requested domains. Subsequent radios will\n * \tuse the resulting intersection.\n * @HWSIM_REGTEST_WORLD_ROAM: Used for testing the world roaming. We accomplish\n *\tthis by using a custom beacon-capable regulatory domain for the first\n *\tradio. All other device world roam.\n * @HWSIM_REGTEST_CUSTOM_WORLD: Used for testing the custom world regulatory\n * \tdomain requests. All radios will adhere to this custom world regulatory\n * \tdomain.\n * @HWSIM_REGTEST_CUSTOM_WORLD_2: Used for testing 2 custom world regulatory\n * \tdomain requests. The first radio will adhere to the first custom world\n * \tregulatory domain, the second one to the second custom world regulatory\n * \tdomain. All other devices will world roam.\n * @HWSIM_REGTEST_STRICT_FOLLOW_: Used for testing strict regulatory domain\n *\tsettings, only the first radio will send a regulatory domain request\n *\tand use strict settings. The rest of the radios are expected to follow.\n * @HWSIM_REGTEST_STRICT_ALL: Used for testing strict regulatory domain\n *\tsettings. All radios will adhere to this.\n * @HWSIM_REGTEST_STRICT_AND_DRIVER_REG: Used for testing strict regulatory\n *\tdomain settings, combined with secondary driver regulatory domain\n *\tsettings. The first radio will get a strict regulatory domain setting\n *\tusing the first driver regulatory request and the second radio will use\n *\tnon-strict settings using the second driver regulatory request. All\n *\tother devices should follow the intersection created between the\n *\tfirst two.\n * @HWSIM_REGTEST_ALL: Used for testing every possible mix. You will need\n * \tat least 6 radios for a complete test. We will test in this order:\n * \t1 - driver custom world regulatory domain\n * \t2 - second custom world regulatory domain\n * \t3 - first driver regulatory domain request\n * \t4 - second driver regulatory domain request\n * \t5 - strict regulatory domain settings using the third driver regulatory\n * \t    domain request\n * \t6 and on - should follow the intersection of the 3rd, 4rth and 5th radio\n * \t           regulatory requests.\n */\nenum hwsim_regtest {\n\tHWSIM_REGTEST_DISABLED = 0,\n\tHWSIM_REGTEST_DRIVER_REG_FOLLOW = 1,\n\tHWSIM_REGTEST_DRIVER_REG_ALL = 2,\n\tHWSIM_REGTEST_DIFF_COUNTRY = 3,\n\tHWSIM_REGTEST_WORLD_ROAM = 4,\n\tHWSIM_REGTEST_CUSTOM_WORLD = 5,\n\tHWSIM_REGTEST_CUSTOM_WORLD_2 = 6,\n\tHWSIM_REGTEST_STRICT_FOLLOW = 7,\n\tHWSIM_REGTEST_STRICT_ALL = 8,\n\tHWSIM_REGTEST_STRICT_AND_DRIVER_REG = 9,\n\tHWSIM_REGTEST_ALL = 10,\n};\n\n/* Set to one of the HWSIM_REGTEST_* values above */\nstatic int regtest = HWSIM_REGTEST_DISABLED;\nmodule_param(regtest, int, 0444);\nMODULE_PARM_DESC(regtest, \"The type of regulatory test we want to run\");\n\nstatic const char *hwsim_alpha2s[] = {\n\t\"FI\",\n\t\"AL\",\n\t\"US\",\n\t\"DE\",\n\t\"JP\",\n\t\"AL\",\n};\n\nstatic const struct ieee80211_regdomain hwsim_world_regdom_custom_01 = {\n\t.n_reg_rules = 4,\n\t.alpha2 =  \"99\",\n\t.reg_rules = {\n\t\tREG_RULE(2412-10, 2462+10, 40, 0, 20, 0),\n\t\tREG_RULE(2484-10, 2484+10, 40, 0, 20, 0),\n\t\tREG_RULE(5150-10, 5240+10, 40, 0, 30, 0),\n\t\tREG_RULE(5745-10, 5825+10, 40, 0, 30, 0),\n\t}\n};\n\nstatic const struct ieee80211_regdomain hwsim_world_regdom_custom_02 = {\n\t.n_reg_rules = 2,\n\t.alpha2 =  \"99\",\n\t.reg_rules = {\n\t\tREG_RULE(2412-10, 2462+10, 40, 0, 20, 0),\n\t\tREG_RULE(5725-10, 5850+10, 40, 0, 30,\n\t\t\t NL80211_RRF_NO_IR),\n\t}\n};\n\nstatic const struct ieee80211_regdomain *hwsim_world_regdom_custom[] = {\n\t&hwsim_world_regdom_custom_01,\n\t&hwsim_world_regdom_custom_02,\n};\n\nstruct hwsim_vif_priv {\n\tu32 magic;\n\tu8 bssid[ETH_ALEN];\n\tbool assoc;\n\tbool bcn_en;\n\tu16 aid;\n};\n\n#define HWSIM_VIF_MAGIC\t0x69537748\n\nstatic inline void hwsim_check_magic(struct ieee80211_vif *vif)\n{\n\tstruct hwsim_vif_priv *vp = (void *)vif->drv_priv;\n\tWARN(vp->magic != HWSIM_VIF_MAGIC,\n\t     \"Invalid VIF (%p) magic %#x, %pM, %d/%d\\n\",\n\t     vif, vp->magic, vif->addr, vif->type, vif->p2p);\n}\n\nstatic inline void hwsim_set_magic(struct ieee80211_vif *vif)\n{\n\tstruct hwsim_vif_priv *vp = (void *)vif->drv_priv;\n\tvp->magic = HWSIM_VIF_MAGIC;\n}\n\nstatic inline void hwsim_clear_magic(struct ieee80211_vif *vif)\n{\n\tstruct hwsim_vif_priv *vp = (void *)vif->drv_priv;\n\tvp->magic = 0;\n}\n\nstruct hwsim_sta_priv {\n\tu32 magic;\n};\n\n#define HWSIM_STA_MAGIC\t0x6d537749\n\nstatic inline void hwsim_check_sta_magic(struct ieee80211_sta *sta)\n{\n\tstruct hwsim_sta_priv *sp = (void *)sta->drv_priv;\n\tWARN_ON(sp->magic != HWSIM_STA_MAGIC);\n}\n\nstatic inline void hwsim_set_sta_magic(struct ieee80211_sta *sta)\n{\n\tstruct hwsim_sta_priv *sp = (void *)sta->drv_priv;\n\tsp->magic = HWSIM_STA_MAGIC;\n}\n\nstatic inline void hwsim_clear_sta_magic(struct ieee80211_sta *sta)\n{\n\tstruct hwsim_sta_priv *sp = (void *)sta->drv_priv;\n\tsp->magic = 0;\n}\n\nstruct hwsim_chanctx_priv {\n\tu32 magic;\n};\n\n#define HWSIM_CHANCTX_MAGIC 0x6d53774a\n\nstatic inline void hwsim_check_chanctx_magic(struct ieee80211_chanctx_conf *c)\n{\n\tstruct hwsim_chanctx_priv *cp = (void *)c->drv_priv;\n\tWARN_ON(cp->magic != HWSIM_CHANCTX_MAGIC);\n}\n\nstatic inline void hwsim_set_chanctx_magic(struct ieee80211_chanctx_conf *c)\n{\n\tstruct hwsim_chanctx_priv *cp = (void *)c->drv_priv;\n\tcp->magic = HWSIM_CHANCTX_MAGIC;\n}\n\nstatic inline void hwsim_clear_chanctx_magic(struct ieee80211_chanctx_conf *c)\n{\n\tstruct hwsim_chanctx_priv *cp = (void *)c->drv_priv;\n\tcp->magic = 0;\n}\n\nstatic unsigned int hwsim_net_id;\n\nstatic int hwsim_netgroup;\n\nstruct hwsim_net {\n\tint netgroup;\n\tu32 wmediumd;\n};\n\nstatic inline int hwsim_net_get_netgroup(struct net *net)\n{\n\tstruct hwsim_net *hwsim_net = net_generic(net, hwsim_net_id);\n\n\treturn hwsim_net->netgroup;\n}\n\nstatic inline void hwsim_net_set_netgroup(struct net *net)\n{\n\tstruct hwsim_net *hwsim_net = net_generic(net, hwsim_net_id);\n\n\thwsim_net->netgroup = hwsim_netgroup++;\n}\n\nstatic inline u32 hwsim_net_get_wmediumd(struct net *net)\n{\n\tstruct hwsim_net *hwsim_net = net_generic(net, hwsim_net_id);\n\n\treturn hwsim_net->wmediumd;\n}\n\nstatic inline void hwsim_net_set_wmediumd(struct net *net, u32 portid)\n{\n\tstruct hwsim_net *hwsim_net = net_generic(net, hwsim_net_id);\n\n\thwsim_net->wmediumd = portid;\n}\n\nstatic struct class *hwsim_class;\n\nstatic struct net_device *hwsim_mon; /* global monitor netdev */\n\n#define CHAN2G(_freq)  { \\\n\t.band = NL80211_BAND_2GHZ, \\\n\t.center_freq = (_freq), \\\n\t.hw_value = (_freq), \\\n\t.max_power = 20, \\\n}\n\n#define CHAN5G(_freq) { \\\n\t.band = NL80211_BAND_5GHZ, \\\n\t.center_freq = (_freq), \\\n\t.hw_value = (_freq), \\\n\t.max_power = 20, \\\n}\n\nstatic const struct ieee80211_channel hwsim_channels_2ghz[] = {\n\tCHAN2G(2412), /* Channel 1 */\n\tCHAN2G(2417), /* Channel 2 */\n\tCHAN2G(2422), /* Channel 3 */\n\tCHAN2G(2427), /* Channel 4 */\n\tCHAN2G(2432), /* Channel 5 */\n\tCHAN2G(2437), /* Channel 6 */\n\tCHAN2G(2442), /* Channel 7 */\n\tCHAN2G(2447), /* Channel 8 */\n\tCHAN2G(2452), /* Channel 9 */\n\tCHAN2G(2457), /* Channel 10 */\n\tCHAN2G(2462), /* Channel 11 */\n\tCHAN2G(2467), /* Channel 12 */\n\tCHAN2G(2472), /* Channel 13 */\n\tCHAN2G(2484), /* Channel 14 */\n};\n\nstatic const struct ieee80211_channel hwsim_channels_5ghz[] = {\n\tCHAN5G(5180), /* Channel 36 */\n\tCHAN5G(5200), /* Channel 40 */\n\tCHAN5G(5220), /* Channel 44 */\n\tCHAN5G(5240), /* Channel 48 */\n\n\tCHAN5G(5260), /* Channel 52 */\n\tCHAN5G(5280), /* Channel 56 */\n\tCHAN5G(5300), /* Channel 60 */\n\tCHAN5G(5320), /* Channel 64 */\n\n\tCHAN5G(5500), /* Channel 100 */\n\tCHAN5G(5520), /* Channel 104 */\n\tCHAN5G(5540), /* Channel 108 */\n\tCHAN5G(5560), /* Channel 112 */\n\tCHAN5G(5580), /* Channel 116 */\n\tCHAN5G(5600), /* Channel 120 */\n\tCHAN5G(5620), /* Channel 124 */\n\tCHAN5G(5640), /* Channel 128 */\n\tCHAN5G(5660), /* Channel 132 */\n\tCHAN5G(5680), /* Channel 136 */\n\tCHAN5G(5700), /* Channel 140 */\n\n\tCHAN5G(5745), /* Channel 149 */\n\tCHAN5G(5765), /* Channel 153 */\n\tCHAN5G(5785), /* Channel 157 */\n\tCHAN5G(5805), /* Channel 161 */\n\tCHAN5G(5825), /* Channel 165 */\n\tCHAN5G(5845), /* Channel 169 */\n};\n\nstatic const struct ieee80211_rate hwsim_rates[] = {\n\t{ .bitrate = 10 },\n\t{ .bitrate = 20, .flags = IEEE80211_RATE_SHORT_PREAMBLE },\n\t{ .bitrate = 55, .flags = IEEE80211_RATE_SHORT_PREAMBLE },\n\t{ .bitrate = 110, .flags = IEEE80211_RATE_SHORT_PREAMBLE },\n\t{ .bitrate = 60 },\n\t{ .bitrate = 90 },\n\t{ .bitrate = 120 },\n\t{ .bitrate = 180 },\n\t{ .bitrate = 240 },\n\t{ .bitrate = 360 },\n\t{ .bitrate = 480 },\n\t{ .bitrate = 540 }\n};\n\n#define OUI_QCA 0x001374\n#define QCA_NL80211_SUBCMD_TEST 1\nenum qca_nl80211_vendor_subcmds {\n\tQCA_WLAN_VENDOR_ATTR_TEST = 8,\n\tQCA_WLAN_VENDOR_ATTR_MAX = QCA_WLAN_VENDOR_ATTR_TEST\n};\n\nstatic const struct nla_policy\nhwsim_vendor_test_policy[QCA_WLAN_VENDOR_ATTR_MAX + 1] = {\n\t[QCA_WLAN_VENDOR_ATTR_MAX] = { .type = NLA_U32 },\n};\n\nstatic int mac80211_hwsim_vendor_cmd_test(struct wiphy *wiphy,\n\t\t\t\t\t  struct wireless_dev *wdev,\n\t\t\t\t\t  const void *data, int data_len)\n{\n\tstruct sk_buff *skb;\n\tstruct nlattr *tb[QCA_WLAN_VENDOR_ATTR_MAX + 1];\n\tint err;\n\tu32 val;\n\n\terr = nla_parse(tb, QCA_WLAN_VENDOR_ATTR_MAX, data, data_len,\n\t\t\thwsim_vendor_test_policy, NULL);\n\tif (err)\n\t\treturn err;\n\tif (!tb[QCA_WLAN_VENDOR_ATTR_TEST])\n\t\treturn -EINVAL;\n\tval = nla_get_u32(tb[QCA_WLAN_VENDOR_ATTR_TEST]);\n\twiphy_dbg(wiphy, \"%s: test=%u\\n\", __func__, val);\n\n\t/* Send a vendor event as a test. Note that this would not normally be\n\t * done within a command handler, but rather, based on some other\n\t * trigger. For simplicity, this command is used to trigger the event\n\t * here.\n\t *\n\t * event_idx = 0 (index in mac80211_hwsim_vendor_commands)\n\t */\n\tskb = cfg80211_vendor_event_alloc(wiphy, wdev, 100, 0, GFP_KERNEL);\n\tif (skb) {\n\t\t/* skb_put() or nla_put() will fill up data within\n\t\t * NL80211_ATTR_VENDOR_DATA.\n\t\t */\n\n\t\t/* Add vendor data */\n\t\tnla_put_u32(skb, QCA_WLAN_VENDOR_ATTR_TEST, val + 1);\n\n\t\t/* Send the event - this will call nla_nest_end() */\n\t\tcfg80211_vendor_event(skb, GFP_KERNEL);\n\t}\n\n\t/* Send a response to the command */\n\tskb = cfg80211_vendor_cmd_alloc_reply_skb(wiphy, 10);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\t/* skb_put() or nla_put() will fill up data within\n\t * NL80211_ATTR_VENDOR_DATA\n\t */\n\tnla_put_u32(skb, QCA_WLAN_VENDOR_ATTR_TEST, val + 2);\n\n\treturn cfg80211_vendor_cmd_reply(skb);\n}\n\nstatic struct wiphy_vendor_command mac80211_hwsim_vendor_commands[] = {\n\t{\n\t\t.info = { .vendor_id = OUI_QCA,\n\t\t\t  .subcmd = QCA_NL80211_SUBCMD_TEST },\n\t\t.flags = WIPHY_VENDOR_CMD_NEED_NETDEV,\n\t\t.doit = mac80211_hwsim_vendor_cmd_test,\n\t}\n};\n\n/* Advertise support vendor specific events */\nstatic const struct nl80211_vendor_cmd_info mac80211_hwsim_vendor_events[] = {\n\t{ .vendor_id = OUI_QCA, .subcmd = 1 },\n};\n\nstatic const struct ieee80211_iface_limit hwsim_if_limits[] = {\n\t{ .max = 1, .types = BIT(NL80211_IFTYPE_ADHOC) },\n\t{ .max = 2048,  .types = BIT(NL80211_IFTYPE_STATION) |\n\t\t\t\t BIT(NL80211_IFTYPE_P2P_CLIENT) |\n#ifdef CONFIG_MAC80211_MESH\n\t\t\t\t BIT(NL80211_IFTYPE_MESH_POINT) |\n#endif\n\t\t\t\t BIT(NL80211_IFTYPE_AP) |\n\t\t\t\t BIT(NL80211_IFTYPE_P2P_GO) },\n\t/* must be last, see hwsim_if_comb */\n\t{ .max = 1, .types = BIT(NL80211_IFTYPE_P2P_DEVICE) }\n};\n\nstatic const struct ieee80211_iface_combination hwsim_if_comb[] = {\n\t{\n\t\t.limits = hwsim_if_limits,\n\t\t/* remove the last entry which is P2P_DEVICE */\n\t\t.n_limits = ARRAY_SIZE(hwsim_if_limits) - 1,\n\t\t.max_interfaces = 2048,\n\t\t.num_different_channels = 1,\n\t\t.radar_detect_widths = BIT(NL80211_CHAN_WIDTH_20_NOHT) |\n\t\t\t\t       BIT(NL80211_CHAN_WIDTH_20) |\n\t\t\t\t       BIT(NL80211_CHAN_WIDTH_40) |\n\t\t\t\t       BIT(NL80211_CHAN_WIDTH_80) |\n\t\t\t\t       BIT(NL80211_CHAN_WIDTH_160),\n\t},\n};\n\nstatic const struct ieee80211_iface_combination hwsim_if_comb_p2p_dev[] = {\n\t{\n\t\t.limits = hwsim_if_limits,\n\t\t.n_limits = ARRAY_SIZE(hwsim_if_limits),\n\t\t.max_interfaces = 2048,\n\t\t.num_different_channels = 1,\n\t\t.radar_detect_widths = BIT(NL80211_CHAN_WIDTH_20_NOHT) |\n\t\t\t\t       BIT(NL80211_CHAN_WIDTH_20) |\n\t\t\t\t       BIT(NL80211_CHAN_WIDTH_40) |\n\t\t\t\t       BIT(NL80211_CHAN_WIDTH_80) |\n\t\t\t\t       BIT(NL80211_CHAN_WIDTH_160),\n\t},\n};\n\nstatic spinlock_t hwsim_radio_lock;\nstatic LIST_HEAD(hwsim_radios);\nstatic struct rhashtable hwsim_radios_rht;\nstatic int hwsim_radio_idx;\n\nstatic struct platform_driver mac80211_hwsim_driver = {\n\t.driver = {\n\t\t.name = \"mac80211_hwsim\",\n\t},\n};\n\nstruct mac80211_hwsim_data {\n\tstruct list_head list;\n\tstruct rhash_head rht;\n\tstruct ieee80211_hw *hw;\n\tstruct device *dev;\n\tstruct ieee80211_supported_band bands[NUM_NL80211_BANDS];\n\tstruct ieee80211_channel channels_2ghz[ARRAY_SIZE(hwsim_channels_2ghz)];\n\tstruct ieee80211_channel channels_5ghz[ARRAY_SIZE(hwsim_channels_5ghz)];\n\tstruct ieee80211_rate rates[ARRAY_SIZE(hwsim_rates)];\n\tstruct ieee80211_iface_combination if_combination;\n\n\tstruct mac_address addresses[2];\n\tint channels, idx;\n\tbool use_chanctx;\n\tbool destroy_on_close;\n\tstruct work_struct destroy_work;\n\tu32 portid;\n\tchar alpha2[2];\n\tconst struct ieee80211_regdomain *regd;\n\n\tstruct ieee80211_channel *tmp_chan;\n\tstruct ieee80211_channel *roc_chan;\n\tu32 roc_duration;\n\tstruct delayed_work roc_start;\n\tstruct delayed_work roc_done;\n\tstruct delayed_work hw_scan;\n\tstruct cfg80211_scan_request *hw_scan_request;\n\tstruct ieee80211_vif *hw_scan_vif;\n\tint scan_chan_idx;\n\tu8 scan_addr[ETH_ALEN];\n\tstruct {\n\t\tstruct ieee80211_channel *channel;\n\t\tunsigned long next_start, start, end;\n\t} survey_data[ARRAY_SIZE(hwsim_channels_2ghz) +\n\t\t      ARRAY_SIZE(hwsim_channels_5ghz)];\n\n\tstruct ieee80211_channel *channel;\n\tu64 beacon_int\t/* beacon interval in us */;\n\tunsigned int rx_filter;\n\tbool started, idle, scanning;\n\tstruct mutex mutex;\n\tstruct tasklet_hrtimer beacon_timer;\n\tenum ps_mode {\n\t\tPS_DISABLED, PS_ENABLED, PS_AUTO_POLL, PS_MANUAL_POLL\n\t} ps;\n\tbool ps_poll_pending;\n\tstruct dentry *debugfs;\n\n\tuintptr_t pending_cookie;\n\tstruct sk_buff_head pending;\t/* packets pending */\n\t/*\n\t * Only radios in the same group can communicate together (the\n\t * channel has to match too). Each bit represents a group. A\n\t * radio can be in more than one group.\n\t */\n\tu64 group;\n\n\t/* group shared by radios created in the same netns */\n\tint netgroup;\n\t/* wmediumd portid responsible for netgroup of this radio */\n\tu32 wmediumd;\n\n\t/* difference between this hw's clock and the real clock, in usecs */\n\ts64 tsf_offset;\n\ts64 bcn_delta;\n\t/* absolute beacon transmission time. Used to cover up \"tx\" delay. */\n\tu64 abs_bcn_ts;\n\n\t/* Stats */\n\tu64 tx_pkts;\n\tu64 rx_pkts;\n\tu64 tx_bytes;\n\tu64 rx_bytes;\n\tu64 tx_dropped;\n\tu64 tx_failed;\n};\n\nstatic const struct rhashtable_params hwsim_rht_params = {\n\t.nelem_hint = 2,\n\t.automatic_shrinking = true,\n\t.key_len = ETH_ALEN,\n\t.key_offset = offsetof(struct mac80211_hwsim_data, addresses[1]),\n\t.head_offset = offsetof(struct mac80211_hwsim_data, rht),\n};\n\nstruct hwsim_radiotap_hdr {\n\tstruct ieee80211_radiotap_header hdr;\n\t__le64 rt_tsft;\n\tu8 rt_flags;\n\tu8 rt_rate;\n\t__le16 rt_channel;\n\t__le16 rt_chbitmask;\n} __packed;\n\nstruct hwsim_radiotap_ack_hdr {\n\tstruct ieee80211_radiotap_header hdr;\n\tu8 rt_flags;\n\tu8 pad;\n\t__le16 rt_channel;\n\t__le16 rt_chbitmask;\n} __packed;\n\n/* MAC80211_HWSIM netlink family */\nstatic struct genl_family hwsim_genl_family;\n\nenum hwsim_multicast_groups {\n\tHWSIM_MCGRP_CONFIG,\n};\n\nstatic const struct genl_multicast_group hwsim_mcgrps[] = {\n\t[HWSIM_MCGRP_CONFIG] = { .name = \"config\", },\n};\n\n/* MAC80211_HWSIM netlink policy */\n\nstatic const struct nla_policy hwsim_genl_policy[HWSIM_ATTR_MAX + 1] = {\n\t[HWSIM_ATTR_ADDR_RECEIVER] = { .type = NLA_UNSPEC, .len = ETH_ALEN },\n\t[HWSIM_ATTR_ADDR_TRANSMITTER] = { .type = NLA_UNSPEC, .len = ETH_ALEN },\n\t[HWSIM_ATTR_FRAME] = { .type = NLA_BINARY,\n\t\t\t       .len = IEEE80211_MAX_DATA_LEN },\n\t[HWSIM_ATTR_FLAGS] = { .type = NLA_U32 },\n\t[HWSIM_ATTR_RX_RATE] = { .type = NLA_U32 },\n\t[HWSIM_ATTR_SIGNAL] = { .type = NLA_U32 },\n\t[HWSIM_ATTR_TX_INFO] = { .type = NLA_UNSPEC,\n\t\t\t\t .len = IEEE80211_TX_MAX_RATES *\n\t\t\t\t\tsizeof(struct hwsim_tx_rate)},\n\t[HWSIM_ATTR_COOKIE] = { .type = NLA_U64 },\n\t[HWSIM_ATTR_CHANNELS] = { .type = NLA_U32 },\n\t[HWSIM_ATTR_RADIO_ID] = { .type = NLA_U32 },\n\t[HWSIM_ATTR_REG_HINT_ALPHA2] = { .type = NLA_STRING, .len = 2 },\n\t[HWSIM_ATTR_REG_CUSTOM_REG] = { .type = NLA_U32 },\n\t[HWSIM_ATTR_REG_STRICT_REG] = { .type = NLA_FLAG },\n\t[HWSIM_ATTR_SUPPORT_P2P_DEVICE] = { .type = NLA_FLAG },\n\t[HWSIM_ATTR_DESTROY_RADIO_ON_CLOSE] = { .type = NLA_FLAG },\n\t[HWSIM_ATTR_RADIO_NAME] = { .type = NLA_STRING },\n\t[HWSIM_ATTR_NO_VIF] = { .type = NLA_FLAG },\n\t[HWSIM_ATTR_FREQ] = { .type = NLA_U32 },\n};\n\nstatic void mac80211_hwsim_tx_frame(struct ieee80211_hw *hw,\n\t\t\t\t    struct sk_buff *skb,\n\t\t\t\t    struct ieee80211_channel *chan);\n\n/* sysfs attributes */\nstatic void hwsim_send_ps_poll(void *dat, u8 *mac, struct ieee80211_vif *vif)\n{\n\tstruct mac80211_hwsim_data *data = dat;\n\tstruct hwsim_vif_priv *vp = (void *)vif->drv_priv;\n\tstruct sk_buff *skb;\n\tstruct ieee80211_pspoll *pspoll;\n\n\tif (!vp->assoc)\n\t\treturn;\n\n\twiphy_dbg(data->hw->wiphy,\n\t\t  \"%s: send PS-Poll to %pM for aid %d\\n\",\n\t\t  __func__, vp->bssid, vp->aid);\n\n\tskb = dev_alloc_skb(sizeof(*pspoll));\n\tif (!skb)\n\t\treturn;\n\tpspoll = skb_put(skb, sizeof(*pspoll));\n\tpspoll->frame_control = cpu_to_le16(IEEE80211_FTYPE_CTL |\n\t\t\t\t\t    IEEE80211_STYPE_PSPOLL |\n\t\t\t\t\t    IEEE80211_FCTL_PM);\n\tpspoll->aid = cpu_to_le16(0xc000 | vp->aid);\n\tmemcpy(pspoll->bssid, vp->bssid, ETH_ALEN);\n\tmemcpy(pspoll->ta, mac, ETH_ALEN);\n\n\trcu_read_lock();\n\tmac80211_hwsim_tx_frame(data->hw, skb,\n\t\t\t\trcu_dereference(vif->chanctx_conf)->def.chan);\n\trcu_read_unlock();\n}\n\nstatic void hwsim_send_nullfunc(struct mac80211_hwsim_data *data, u8 *mac,\n\t\t\t\tstruct ieee80211_vif *vif, int ps)\n{\n\tstruct hwsim_vif_priv *vp = (void *)vif->drv_priv;\n\tstruct sk_buff *skb;\n\tstruct ieee80211_hdr *hdr;\n\n\tif (!vp->assoc)\n\t\treturn;\n\n\twiphy_dbg(data->hw->wiphy,\n\t\t  \"%s: send data::nullfunc to %pM ps=%d\\n\",\n\t\t  __func__, vp->bssid, ps);\n\n\tskb = dev_alloc_skb(sizeof(*hdr));\n\tif (!skb)\n\t\treturn;\n\thdr = skb_put(skb, sizeof(*hdr) - ETH_ALEN);\n\thdr->frame_control = cpu_to_le16(IEEE80211_FTYPE_DATA |\n\t\t\t\t\t IEEE80211_STYPE_NULLFUNC |\n\t\t\t\t\t IEEE80211_FCTL_TODS |\n\t\t\t\t\t (ps ? IEEE80211_FCTL_PM : 0));\n\thdr->duration_id = cpu_to_le16(0);\n\tmemcpy(hdr->addr1, vp->bssid, ETH_ALEN);\n\tmemcpy(hdr->addr2, mac, ETH_ALEN);\n\tmemcpy(hdr->addr3, vp->bssid, ETH_ALEN);\n\n\trcu_read_lock();\n\tmac80211_hwsim_tx_frame(data->hw, skb,\n\t\t\t\trcu_dereference(vif->chanctx_conf)->def.chan);\n\trcu_read_unlock();\n}\n\n\nstatic void hwsim_send_nullfunc_ps(void *dat, u8 *mac,\n\t\t\t\t   struct ieee80211_vif *vif)\n{\n\tstruct mac80211_hwsim_data *data = dat;\n\thwsim_send_nullfunc(data, mac, vif, 1);\n}\n\nstatic void hwsim_send_nullfunc_no_ps(void *dat, u8 *mac,\n\t\t\t\t      struct ieee80211_vif *vif)\n{\n\tstruct mac80211_hwsim_data *data = dat;\n\thwsim_send_nullfunc(data, mac, vif, 0);\n}\n\nstatic int hwsim_fops_ps_read(void *dat, u64 *val)\n{\n\tstruct mac80211_hwsim_data *data = dat;\n\t*val = data->ps;\n\treturn 0;\n}\n\nstatic int hwsim_fops_ps_write(void *dat, u64 val)\n{\n\tstruct mac80211_hwsim_data *data = dat;\n\tenum ps_mode old_ps;\n\n\tif (val != PS_DISABLED && val != PS_ENABLED && val != PS_AUTO_POLL &&\n\t    val != PS_MANUAL_POLL)\n\t\treturn -EINVAL;\n\n\tif (val == PS_MANUAL_POLL) {\n\t\tif (data->ps != PS_ENABLED)\n\t\t\treturn -EINVAL;\n\t\tlocal_bh_disable();\n\t\tieee80211_iterate_active_interfaces_atomic(\n\t\t\tdata->hw, IEEE80211_IFACE_ITER_NORMAL,\n\t\t\thwsim_send_ps_poll, data);\n\t\tlocal_bh_enable();\n\t\treturn 0;\n\t}\n\told_ps = data->ps;\n\tdata->ps = val;\n\n\tlocal_bh_disable();\n\tif (old_ps == PS_DISABLED && val != PS_DISABLED) {\n\t\tieee80211_iterate_active_interfaces_atomic(\n\t\t\tdata->hw, IEEE80211_IFACE_ITER_NORMAL,\n\t\t\thwsim_send_nullfunc_ps, data);\n\t} else if (old_ps != PS_DISABLED && val == PS_DISABLED) {\n\t\tieee80211_iterate_active_interfaces_atomic(\n\t\t\tdata->hw, IEEE80211_IFACE_ITER_NORMAL,\n\t\t\thwsim_send_nullfunc_no_ps, data);\n\t}\n\tlocal_bh_enable();\n\n\treturn 0;\n}\n\nDEFINE_SIMPLE_ATTRIBUTE(hwsim_fops_ps, hwsim_fops_ps_read, hwsim_fops_ps_write,\n\t\t\t\"%llu\\n\");\n\nstatic int hwsim_write_simulate_radar(void *dat, u64 val)\n{\n\tstruct mac80211_hwsim_data *data = dat;\n\n\tieee80211_radar_detected(data->hw);\n\n\treturn 0;\n}\n\nDEFINE_SIMPLE_ATTRIBUTE(hwsim_simulate_radar, NULL,\n\t\t\thwsim_write_simulate_radar, \"%llu\\n\");\n\nstatic int hwsim_fops_group_read(void *dat, u64 *val)\n{\n\tstruct mac80211_hwsim_data *data = dat;\n\t*val = data->group;\n\treturn 0;\n}\n\nstatic int hwsim_fops_group_write(void *dat, u64 val)\n{\n\tstruct mac80211_hwsim_data *data = dat;\n\tdata->group = val;\n\treturn 0;\n}\n\nDEFINE_SIMPLE_ATTRIBUTE(hwsim_fops_group,\n\t\t\thwsim_fops_group_read, hwsim_fops_group_write,\n\t\t\t\"%llx\\n\");\n\nstatic netdev_tx_t hwsim_mon_xmit(struct sk_buff *skb,\n\t\t\t\t\tstruct net_device *dev)\n{\n\t/* TODO: allow packet injection */\n\tdev_kfree_skb(skb);\n\treturn NETDEV_TX_OK;\n}\n\nstatic inline u64 mac80211_hwsim_get_tsf_raw(void)\n{\n\treturn ktime_to_us(ktime_get_real());\n}\n\nstatic __le64 __mac80211_hwsim_get_tsf(struct mac80211_hwsim_data *data)\n{\n\tu64 now = mac80211_hwsim_get_tsf_raw();\n\treturn cpu_to_le64(now + data->tsf_offset);\n}\n\nstatic u64 mac80211_hwsim_get_tsf(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_vif *vif)\n{\n\tstruct mac80211_hwsim_data *data = hw->priv;\n\treturn le64_to_cpu(__mac80211_hwsim_get_tsf(data));\n}\n\nstatic void mac80211_hwsim_set_tsf(struct ieee80211_hw *hw,\n\t\tstruct ieee80211_vif *vif, u64 tsf)\n{\n\tstruct mac80211_hwsim_data *data = hw->priv;\n\tu64 now = mac80211_hwsim_get_tsf(hw, vif);\n\tu32 bcn_int = data->beacon_int;\n\tu64 delta = abs(tsf - now);\n\n\t/* adjust after beaconing with new timestamp at old TBTT */\n\tif (tsf > now) {\n\t\tdata->tsf_offset += delta;\n\t\tdata->bcn_delta = do_div(delta, bcn_int);\n\t} else {\n\t\tdata->tsf_offset -= delta;\n\t\tdata->bcn_delta = -(s64)do_div(delta, bcn_int);\n\t}\n}\n\nstatic void mac80211_hwsim_monitor_rx(struct ieee80211_hw *hw,\n\t\t\t\t      struct sk_buff *tx_skb,\n\t\t\t\t      struct ieee80211_channel *chan)\n{\n\tstruct mac80211_hwsim_data *data = hw->priv;\n\tstruct sk_buff *skb;\n\tstruct hwsim_radiotap_hdr *hdr;\n\tu16 flags;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx_skb);\n\tstruct ieee80211_rate *txrate = ieee80211_get_tx_rate(hw, info);\n\n\tif (WARN_ON(!txrate))\n\t\treturn;\n\n\tif (!netif_running(hwsim_mon))\n\t\treturn;\n\n\tskb = skb_copy_expand(tx_skb, sizeof(*hdr), 0, GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn;\n\n\thdr = skb_push(skb, sizeof(*hdr));\n\thdr->hdr.it_version = PKTHDR_RADIOTAP_VERSION;\n\thdr->hdr.it_pad = 0;\n\thdr->hdr.it_len = cpu_to_le16(sizeof(*hdr));\n\thdr->hdr.it_present = cpu_to_le32((1 << IEEE80211_RADIOTAP_FLAGS) |\n\t\t\t\t\t  (1 << IEEE80211_RADIOTAP_RATE) |\n\t\t\t\t\t  (1 << IEEE80211_RADIOTAP_TSFT) |\n\t\t\t\t\t  (1 << IEEE80211_RADIOTAP_CHANNEL));\n\thdr->rt_tsft = __mac80211_hwsim_get_tsf(data);\n\thdr->rt_flags = 0;\n\thdr->rt_rate = txrate->bitrate / 5;\n\thdr->rt_channel = cpu_to_le16(chan->center_freq);\n\tflags = IEEE80211_CHAN_2GHZ;\n\tif (txrate->flags & IEEE80211_RATE_ERP_G)\n\t\tflags |= IEEE80211_CHAN_OFDM;\n\telse\n\t\tflags |= IEEE80211_CHAN_CCK;\n\thdr->rt_chbitmask = cpu_to_le16(flags);\n\n\tskb->dev = hwsim_mon;\n\tskb_reset_mac_header(skb);\n\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\tskb->pkt_type = PACKET_OTHERHOST;\n\tskb->protocol = htons(ETH_P_802_2);\n\tmemset(skb->cb, 0, sizeof(skb->cb));\n\tnetif_rx(skb);\n}\n\n\nstatic void mac80211_hwsim_monitor_ack(struct ieee80211_channel *chan,\n\t\t\t\t       const u8 *addr)\n{\n\tstruct sk_buff *skb;\n\tstruct hwsim_radiotap_ack_hdr *hdr;\n\tu16 flags;\n\tstruct ieee80211_hdr *hdr11;\n\n\tif (!netif_running(hwsim_mon))\n\t\treturn;\n\n\tskb = dev_alloc_skb(100);\n\tif (skb == NULL)\n\t\treturn;\n\n\thdr = skb_put(skb, sizeof(*hdr));\n\thdr->hdr.it_version = PKTHDR_RADIOTAP_VERSION;\n\thdr->hdr.it_pad = 0;\n\thdr->hdr.it_len = cpu_to_le16(sizeof(*hdr));\n\thdr->hdr.it_present = cpu_to_le32((1 << IEEE80211_RADIOTAP_FLAGS) |\n\t\t\t\t\t  (1 << IEEE80211_RADIOTAP_CHANNEL));\n\thdr->rt_flags = 0;\n\thdr->pad = 0;\n\thdr->rt_channel = cpu_to_le16(chan->center_freq);\n\tflags = IEEE80211_CHAN_2GHZ;\n\thdr->rt_chbitmask = cpu_to_le16(flags);\n\n\thdr11 = skb_put(skb, 10);\n\thdr11->frame_control = cpu_to_le16(IEEE80211_FTYPE_CTL |\n\t\t\t\t\t   IEEE80211_STYPE_ACK);\n\thdr11->duration_id = cpu_to_le16(0);\n\tmemcpy(hdr11->addr1, addr, ETH_ALEN);\n\n\tskb->dev = hwsim_mon;\n\tskb_reset_mac_header(skb);\n\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\tskb->pkt_type = PACKET_OTHERHOST;\n\tskb->protocol = htons(ETH_P_802_2);\n\tmemset(skb->cb, 0, sizeof(skb->cb));\n\tnetif_rx(skb);\n}\n\nstruct mac80211_hwsim_addr_match_data {\n\tu8 addr[ETH_ALEN];\n\tbool ret;\n};\n\nstatic void mac80211_hwsim_addr_iter(void *data, u8 *mac,\n\t\t\t\t     struct ieee80211_vif *vif)\n{\n\tstruct mac80211_hwsim_addr_match_data *md = data;\n\n\tif (memcmp(mac, md->addr, ETH_ALEN) == 0)\n\t\tmd->ret = true;\n}\n\nstatic bool mac80211_hwsim_addr_match(struct mac80211_hwsim_data *data,\n\t\t\t\t      const u8 *addr)\n{\n\tstruct mac80211_hwsim_addr_match_data md = {\n\t\t.ret = false,\n\t};\n\n\tif (data->scanning && memcmp(addr, data->scan_addr, ETH_ALEN) == 0)\n\t\treturn true;\n\n\tmemcpy(md.addr, addr, ETH_ALEN);\n\n\tieee80211_iterate_active_interfaces_atomic(data->hw,\n\t\t\t\t\t\t   IEEE80211_IFACE_ITER_NORMAL,\n\t\t\t\t\t\t   mac80211_hwsim_addr_iter,\n\t\t\t\t\t\t   &md);\n\n\treturn md.ret;\n}\n\nstatic bool hwsim_ps_rx_ok(struct mac80211_hwsim_data *data,\n\t\t\t   struct sk_buff *skb)\n{\n\tswitch (data->ps) {\n\tcase PS_DISABLED:\n\t\treturn true;\n\tcase PS_ENABLED:\n\t\treturn false;\n\tcase PS_AUTO_POLL:\n\t\t/* TODO: accept (some) Beacons by default and other frames only\n\t\t * if pending PS-Poll has been sent */\n\t\treturn true;\n\tcase PS_MANUAL_POLL:\n\t\t/* Allow unicast frames to own address if there is a pending\n\t\t * PS-Poll */\n\t\tif (data->ps_poll_pending &&\n\t\t    mac80211_hwsim_addr_match(data, skb->data + 4)) {\n\t\t\tdata->ps_poll_pending = false;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic int hwsim_unicast_netgroup(struct mac80211_hwsim_data *data,\n\t\t\t\t  struct sk_buff *skb, int portid)\n{\n\tstruct net *net;\n\tbool found = false;\n\tint res = -ENOENT;\n\n\trcu_read_lock();\n\tfor_each_net_rcu(net) {\n\t\tif (data->netgroup == hwsim_net_get_netgroup(net)) {\n\t\t\tres = genlmsg_unicast(net, skb, portid);\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tif (!found)\n\t\tnlmsg_free(skb);\n\n\treturn res;\n}\n\nstatic inline u16 trans_tx_rate_flags_ieee2hwsim(struct ieee80211_tx_rate *rate)\n{\n\tu16 result = 0;\n\n\tif (rate->flags & IEEE80211_TX_RC_USE_RTS_CTS)\n\t\tresult |= MAC80211_HWSIM_TX_RC_USE_RTS_CTS;\n\tif (rate->flags & IEEE80211_TX_RC_USE_CTS_PROTECT)\n\t\tresult |= MAC80211_HWSIM_TX_RC_USE_CTS_PROTECT;\n\tif (rate->flags & IEEE80211_TX_RC_USE_SHORT_PREAMBLE)\n\t\tresult |= MAC80211_HWSIM_TX_RC_USE_SHORT_PREAMBLE;\n\tif (rate->flags & IEEE80211_TX_RC_MCS)\n\t\tresult |= MAC80211_HWSIM_TX_RC_MCS;\n\tif (rate->flags & IEEE80211_TX_RC_GREEN_FIELD)\n\t\tresult |= MAC80211_HWSIM_TX_RC_GREEN_FIELD;\n\tif (rate->flags & IEEE80211_TX_RC_40_MHZ_WIDTH)\n\t\tresult |= MAC80211_HWSIM_TX_RC_40_MHZ_WIDTH;\n\tif (rate->flags & IEEE80211_TX_RC_DUP_DATA)\n\t\tresult |= MAC80211_HWSIM_TX_RC_DUP_DATA;\n\tif (rate->flags & IEEE80211_TX_RC_SHORT_GI)\n\t\tresult |= MAC80211_HWSIM_TX_RC_SHORT_GI;\n\tif (rate->flags & IEEE80211_TX_RC_VHT_MCS)\n\t\tresult |= MAC80211_HWSIM_TX_RC_VHT_MCS;\n\tif (rate->flags & IEEE80211_TX_RC_80_MHZ_WIDTH)\n\t\tresult |= MAC80211_HWSIM_TX_RC_80_MHZ_WIDTH;\n\tif (rate->flags & IEEE80211_TX_RC_160_MHZ_WIDTH)\n\t\tresult |= MAC80211_HWSIM_TX_RC_160_MHZ_WIDTH;\n\n\treturn result;\n}\n\nstatic void mac80211_hwsim_tx_frame_nl(struct ieee80211_hw *hw,\n\t\t\t\t       struct sk_buff *my_skb,\n\t\t\t\t       int dst_portid)\n{\n\tstruct sk_buff *skb;\n\tstruct mac80211_hwsim_data *data = hw->priv;\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) my_skb->data;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(my_skb);\n\tvoid *msg_head;\n\tunsigned int hwsim_flags = 0;\n\tint i;\n\tstruct hwsim_tx_rate tx_attempts[IEEE80211_TX_MAX_RATES];\n\tstruct hwsim_tx_rate_flag tx_attempts_flags[IEEE80211_TX_MAX_RATES];\n\tuintptr_t cookie;\n\n\tif (data->ps != PS_DISABLED)\n\t\thdr->frame_control |= cpu_to_le16(IEEE80211_FCTL_PM);\n\t/* If the queue contains MAX_QUEUE skb's drop some */\n\tif (skb_queue_len(&data->pending) >= MAX_QUEUE) {\n\t\t/* Droping until WARN_QUEUE level */\n\t\twhile (skb_queue_len(&data->pending) >= WARN_QUEUE) {\n\t\t\tieee80211_free_txskb(hw, skb_dequeue(&data->pending));\n\t\t\tdata->tx_dropped++;\n\t\t}\n\t}\n\n\tskb = genlmsg_new(GENLMSG_DEFAULT_SIZE, GFP_ATOMIC);\n\tif (skb == NULL)\n\t\tgoto nla_put_failure;\n\n\tmsg_head = genlmsg_put(skb, 0, 0, &hwsim_genl_family, 0,\n\t\t\t       HWSIM_CMD_FRAME);\n\tif (msg_head == NULL) {\n\t\tpr_debug(\"mac80211_hwsim: problem with msg_head\\n\");\n\t\tgoto nla_put_failure;\n\t}\n\n\tif (nla_put(skb, HWSIM_ATTR_ADDR_TRANSMITTER,\n\t\t    ETH_ALEN, data->addresses[1].addr))\n\t\tgoto nla_put_failure;\n\n\t/* We get the skb->data */\n\tif (nla_put(skb, HWSIM_ATTR_FRAME, my_skb->len, my_skb->data))\n\t\tgoto nla_put_failure;\n\n\t/* We get the flags for this transmission, and we translate them to\n\t   wmediumd flags  */\n\n\tif (info->flags & IEEE80211_TX_CTL_REQ_TX_STATUS)\n\t\thwsim_flags |= HWSIM_TX_CTL_REQ_TX_STATUS;\n\n\tif (info->flags & IEEE80211_TX_CTL_NO_ACK)\n\t\thwsim_flags |= HWSIM_TX_CTL_NO_ACK;\n\n\tif (nla_put_u32(skb, HWSIM_ATTR_FLAGS, hwsim_flags))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(skb, HWSIM_ATTR_FREQ, data->channel->center_freq))\n\t\tgoto nla_put_failure;\n\n\t/* We get the tx control (rate and retries) info*/\n\n\tfor (i = 0; i < IEEE80211_TX_MAX_RATES; i++) {\n\t\ttx_attempts[i].idx = info->status.rates[i].idx;\n\t\ttx_attempts_flags[i].idx = info->status.rates[i].idx;\n\t\ttx_attempts[i].count = info->status.rates[i].count;\n\t\ttx_attempts_flags[i].flags =\n\t\t\t\ttrans_tx_rate_flags_ieee2hwsim(\n\t\t\t\t\t\t&info->status.rates[i]);\n\t}\n\n\tif (nla_put(skb, HWSIM_ATTR_TX_INFO,\n\t\t    sizeof(struct hwsim_tx_rate)*IEEE80211_TX_MAX_RATES,\n\t\t    tx_attempts))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put(skb, HWSIM_ATTR_TX_INFO_FLAGS,\n\t\t    sizeof(struct hwsim_tx_rate_flag) * IEEE80211_TX_MAX_RATES,\n\t\t    tx_attempts_flags))\n\t\tgoto nla_put_failure;\n\n\t/* We create a cookie to identify this skb */\n\tdata->pending_cookie++;\n\tcookie = data->pending_cookie;\n\tinfo->rate_driver_data[0] = (void *)cookie;\n\tif (nla_put_u64_64bit(skb, HWSIM_ATTR_COOKIE, cookie, HWSIM_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(skb, msg_head);\n\tif (hwsim_unicast_netgroup(data, skb, dst_portid))\n\t\tgoto err_free_txskb;\n\n\t/* Enqueue the packet */\n\tskb_queue_tail(&data->pending, my_skb);\n\tdata->tx_pkts++;\n\tdata->tx_bytes += my_skb->len;\n\treturn;\n\nnla_put_failure:\n\tnlmsg_free(skb);\nerr_free_txskb:\n\tpr_debug(\"mac80211_hwsim: error occurred in %s\\n\", __func__);\n\tieee80211_free_txskb(hw, my_skb);\n\tdata->tx_failed++;\n}\n\nstatic bool hwsim_chans_compat(struct ieee80211_channel *c1,\n\t\t\t       struct ieee80211_channel *c2)\n{\n\tif (!c1 || !c2)\n\t\treturn false;\n\n\treturn c1->center_freq == c2->center_freq;\n}\n\nstruct tx_iter_data {\n\tstruct ieee80211_channel *channel;\n\tbool receive;\n};\n\nstatic void mac80211_hwsim_tx_iter(void *_data, u8 *addr,\n\t\t\t\t   struct ieee80211_vif *vif)\n{\n\tstruct tx_iter_data *data = _data;\n\n\tif (!vif->chanctx_conf)\n\t\treturn;\n\n\tif (!hwsim_chans_compat(data->channel,\n\t\t\t\trcu_dereference(vif->chanctx_conf)->def.chan))\n\t\treturn;\n\n\tdata->receive = true;\n}\n\nstatic void mac80211_hwsim_add_vendor_rtap(struct sk_buff *skb)\n{\n\t/*\n\t * To enable this code, #define the HWSIM_RADIOTAP_OUI,\n\t * e.g. like this:\n\t * #define HWSIM_RADIOTAP_OUI \"\\x02\\x00\\x00\"\n\t * (but you should use a valid OUI, not that)\n\t *\n\t * If anyone wants to 'donate' a radiotap OUI/subns code\n\t * please send a patch removing this #ifdef and changing\n\t * the values accordingly.\n\t */\n#ifdef HWSIM_RADIOTAP_OUI\n\tstruct ieee80211_vendor_radiotap *rtap;\n\n\t/*\n\t * Note that this code requires the headroom in the SKB\n\t * that was allocated earlier.\n\t */\n\trtap = skb_push(skb, sizeof(*rtap) + 8 + 4);\n\trtap->oui[0] = HWSIM_RADIOTAP_OUI[0];\n\trtap->oui[1] = HWSIM_RADIOTAP_OUI[1];\n\trtap->oui[2] = HWSIM_RADIOTAP_OUI[2];\n\trtap->subns = 127;\n\n\t/*\n\t * Radiotap vendor namespaces can (and should) also be\n\t * split into fields by using the standard radiotap\n\t * presence bitmap mechanism. Use just BIT(0) here for\n\t * the presence bitmap.\n\t */\n\trtap->present = BIT(0);\n\t/* We have 8 bytes of (dummy) data */\n\trtap->len = 8;\n\t/* For testing, also require it to be aligned */\n\trtap->align = 8;\n\t/* And also test that padding works, 4 bytes */\n\trtap->pad = 4;\n\t/* push the data */\n\tmemcpy(rtap->data, \"ABCDEFGH\", 8);\n\t/* make sure to clear padding, mac80211 doesn't */\n\tmemset(rtap->data + 8, 0, 4);\n\n\tIEEE80211_SKB_RXCB(skb)->flag |= RX_FLAG_RADIOTAP_VENDOR_DATA;\n#endif\n}\n\nstatic bool mac80211_hwsim_tx_frame_no_nl(struct ieee80211_hw *hw,\n\t\t\t\t\t  struct sk_buff *skb,\n\t\t\t\t\t  struct ieee80211_channel *chan)\n{\n\tstruct mac80211_hwsim_data *data = hw->priv, *data2;\n\tbool ack = false;\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_rx_status rx_status;\n\tu64 now;\n\n\tmemset(&rx_status, 0, sizeof(rx_status));\n\trx_status.flag |= RX_FLAG_MACTIME_START;\n\trx_status.freq = chan->center_freq;\n\trx_status.band = chan->band;\n\tif (info->control.rates[0].flags & IEEE80211_TX_RC_VHT_MCS) {\n\t\trx_status.rate_idx =\n\t\t\tieee80211_rate_get_vht_mcs(&info->control.rates[0]);\n\t\trx_status.nss =\n\t\t\tieee80211_rate_get_vht_nss(&info->control.rates[0]);\n\t\trx_status.encoding = RX_ENC_VHT;\n\t} else {\n\t\trx_status.rate_idx = info->control.rates[0].idx;\n\t\tif (info->control.rates[0].flags & IEEE80211_TX_RC_MCS)\n\t\t\trx_status.encoding = RX_ENC_HT;\n\t}\n\tif (info->control.rates[0].flags & IEEE80211_TX_RC_40_MHZ_WIDTH)\n\t\trx_status.bw = RATE_INFO_BW_40;\n\telse if (info->control.rates[0].flags & IEEE80211_TX_RC_80_MHZ_WIDTH)\n\t\trx_status.bw = RATE_INFO_BW_80;\n\telse if (info->control.rates[0].flags & IEEE80211_TX_RC_160_MHZ_WIDTH)\n\t\trx_status.bw = RATE_INFO_BW_160;\n\telse\n\t\trx_status.bw = RATE_INFO_BW_20;\n\tif (info->control.rates[0].flags & IEEE80211_TX_RC_SHORT_GI)\n\t\trx_status.enc_flags |= RX_ENC_FLAG_SHORT_GI;\n\t/* TODO: simulate real signal strength (and optional packet loss) */\n\trx_status.signal = -50;\n\tif (info->control.vif)\n\t\trx_status.signal += info->control.vif->bss_conf.txpower;\n\n\tif (data->ps != PS_DISABLED)\n\t\thdr->frame_control |= cpu_to_le16(IEEE80211_FCTL_PM);\n\n\t/* release the skb's source info */\n\tskb_orphan(skb);\n\tskb_dst_drop(skb);\n\tskb->mark = 0;\n\tsecpath_reset(skb);\n\tnf_reset(skb);\n\n\t/*\n\t * Get absolute mactime here so all HWs RX at the \"same time\", and\n\t * absolute TX time for beacon mactime so the timestamp matches.\n\t * Giving beacons a different mactime than non-beacons looks messy, but\n\t * it helps the Toffset be exact and a ~10us mactime discrepancy\n\t * probably doesn't really matter.\n\t */\n\tif (ieee80211_is_beacon(hdr->frame_control) ||\n\t    ieee80211_is_probe_resp(hdr->frame_control))\n\t\tnow = data->abs_bcn_ts;\n\telse\n\t\tnow = mac80211_hwsim_get_tsf_raw();\n\n\t/* Copy skb to all enabled radios that are on the current frequency */\n\tspin_lock(&hwsim_radio_lock);\n\tlist_for_each_entry(data2, &hwsim_radios, list) {\n\t\tstruct sk_buff *nskb;\n\t\tstruct tx_iter_data tx_iter_data = {\n\t\t\t.receive = false,\n\t\t\t.channel = chan,\n\t\t};\n\n\t\tif (data == data2)\n\t\t\tcontinue;\n\n\t\tif (!data2->started || (data2->idle && !data2->tmp_chan) ||\n\t\t    !hwsim_ps_rx_ok(data2, skb))\n\t\t\tcontinue;\n\n\t\tif (!(data->group & data2->group))\n\t\t\tcontinue;\n\n\t\tif (data->netgroup != data2->netgroup)\n\t\t\tcontinue;\n\n\t\tif (!hwsim_chans_compat(chan, data2->tmp_chan) &&\n\t\t    !hwsim_chans_compat(chan, data2->channel)) {\n\t\t\tieee80211_iterate_active_interfaces_atomic(\n\t\t\t\tdata2->hw, IEEE80211_IFACE_ITER_NORMAL,\n\t\t\t\tmac80211_hwsim_tx_iter, &tx_iter_data);\n\t\t\tif (!tx_iter_data.receive)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * reserve some space for our vendor and the normal\n\t\t * radiotap header, since we're copying anyway\n\t\t */\n\t\tif (skb->len < PAGE_SIZE && paged_rx) {\n\t\t\tstruct page *page = alloc_page(GFP_ATOMIC);\n\n\t\t\tif (!page)\n\t\t\t\tcontinue;\n\n\t\t\tnskb = dev_alloc_skb(128);\n\t\t\tif (!nskb) {\n\t\t\t\t__free_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tmemcpy(page_address(page), skb->data, skb->len);\n\t\t\tskb_add_rx_frag(nskb, 0, page, 0, skb->len, skb->len);\n\t\t} else {\n\t\t\tnskb = skb_copy(skb, GFP_ATOMIC);\n\t\t\tif (!nskb)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (mac80211_hwsim_addr_match(data2, hdr->addr1))\n\t\t\tack = true;\n\n\t\trx_status.mactime = now + data2->tsf_offset;\n\n\t\tmemcpy(IEEE80211_SKB_RXCB(nskb), &rx_status, sizeof(rx_status));\n\n\t\tmac80211_hwsim_add_vendor_rtap(nskb);\n\n\t\tdata2->rx_pkts++;\n\t\tdata2->rx_bytes += nskb->len;\n\t\tieee80211_rx_irqsafe(data2->hw, nskb);\n\t}\n\tspin_unlock(&hwsim_radio_lock);\n\n\treturn ack;\n}\n\nstatic void mac80211_hwsim_tx(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_tx_control *control,\n\t\t\t      struct sk_buff *skb)\n{\n\tstruct mac80211_hwsim_data *data = hw->priv;\n\tstruct ieee80211_tx_info *txi = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_hdr *hdr = (void *)skb->data;\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\tstruct ieee80211_channel *channel;\n\tbool ack;\n\tu32 _portid;\n\n\tif (WARN_ON(skb->len < 10)) {\n\t\t/* Should not happen; just a sanity check for addr1 use */\n\t\tieee80211_free_txskb(hw, skb);\n\t\treturn;\n\t}\n\n\tif (!data->use_chanctx) {\n\t\tchannel = data->channel;\n\t} else if (txi->hw_queue == 4) {\n\t\tchannel = data->tmp_chan;\n\t} else {\n\t\tchanctx_conf = rcu_dereference(txi->control.vif->chanctx_conf);\n\t\tif (chanctx_conf)\n\t\t\tchannel = chanctx_conf->def.chan;\n\t\telse\n\t\t\tchannel = NULL;\n\t}\n\n\tif (WARN(!channel, \"TX w/o channel - queue = %d\\n\", txi->hw_queue)) {\n\t\tieee80211_free_txskb(hw, skb);\n\t\treturn;\n\t}\n\n\tif (data->idle && !data->tmp_chan) {\n\t\twiphy_dbg(hw->wiphy, \"Trying to TX when idle - reject\\n\");\n\t\tieee80211_free_txskb(hw, skb);\n\t\treturn;\n\t}\n\n\tif (txi->control.vif)\n\t\thwsim_check_magic(txi->control.vif);\n\tif (control->sta)\n\t\thwsim_check_sta_magic(control->sta);\n\n\tif (ieee80211_hw_check(hw, SUPPORTS_RC_TABLE))\n\t\tieee80211_get_tx_rates(txi->control.vif, control->sta, skb,\n\t\t\t\t       txi->control.rates,\n\t\t\t\t       ARRAY_SIZE(txi->control.rates));\n\n\tif (skb->len >= 24 + 8 &&\n\t    ieee80211_is_probe_resp(hdr->frame_control)) {\n\t\t/* fake header transmission time */\n\t\tstruct ieee80211_mgmt *mgmt;\n\t\tstruct ieee80211_rate *txrate;\n\t\tu64 ts;\n\n\t\tmgmt = (struct ieee80211_mgmt *)skb->data;\n\t\ttxrate = ieee80211_get_tx_rate(hw, txi);\n\t\tts = mac80211_hwsim_get_tsf_raw();\n\t\tmgmt->u.probe_resp.timestamp =\n\t\t\tcpu_to_le64(ts + data->tsf_offset +\n\t\t\t\t    24 * 8 * 10 / txrate->bitrate);\n\t}\n\n\tmac80211_hwsim_monitor_rx(hw, skb, channel);\n\n\t/* wmediumd mode check */\n\t_portid = READ_ONCE(data->wmediumd);\n\n\tif (_portid)\n\t\treturn mac80211_hwsim_tx_frame_nl(hw, skb, _portid);\n\n\t/* NO wmediumd detected, perfect medium simulation */\n\tdata->tx_pkts++;\n\tdata->tx_bytes += skb->len;\n\tack = mac80211_hwsim_tx_frame_no_nl(hw, skb, channel);\n\n\tif (ack && skb->len >= 16)\n\t\tmac80211_hwsim_monitor_ack(channel, hdr->addr2);\n\n\tieee80211_tx_info_clear_status(txi);\n\n\t/* frame was transmitted at most favorable rate at first attempt */\n\ttxi->control.rates[0].count = 1;\n\ttxi->control.rates[1].idx = -1;\n\n\tif (!(txi->flags & IEEE80211_TX_CTL_NO_ACK) && ack)\n\t\ttxi->flags |= IEEE80211_TX_STAT_ACK;\n\tieee80211_tx_status_irqsafe(hw, skb);\n}\n\n\nstatic int mac80211_hwsim_start(struct ieee80211_hw *hw)\n{\n\tstruct mac80211_hwsim_data *data = hw->priv;\n\twiphy_dbg(hw->wiphy, \"%s\\n\", __func__);\n\tdata->started = true;\n\treturn 0;\n}\n\n\nstatic void mac80211_hwsim_stop(struct ieee80211_hw *hw)\n{\n\tstruct mac80211_hwsim_data *data = hw->priv;\n\tdata->started = false;\n\ttasklet_hrtimer_cancel(&data->beacon_timer);\n\twiphy_dbg(hw->wiphy, \"%s\\n\", __func__);\n}\n\n\nstatic int mac80211_hwsim_add_interface(struct ieee80211_hw *hw,\n\t\t\t\t\tstruct ieee80211_vif *vif)\n{\n\twiphy_dbg(hw->wiphy, \"%s (type=%d mac_addr=%pM)\\n\",\n\t\t  __func__, ieee80211_vif_type_p2p(vif),\n\t\t  vif->addr);\n\thwsim_set_magic(vif);\n\n\tvif->cab_queue = 0;\n\tvif->hw_queue[IEEE80211_AC_VO] = 0;\n\tvif->hw_queue[IEEE80211_AC_VI] = 1;\n\tvif->hw_queue[IEEE80211_AC_BE] = 2;\n\tvif->hw_queue[IEEE80211_AC_BK] = 3;\n\n\treturn 0;\n}\n\n\nstatic int mac80211_hwsim_change_interface(struct ieee80211_hw *hw,\n\t\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t\t   enum nl80211_iftype newtype,\n\t\t\t\t\t   bool newp2p)\n{\n\tnewtype = ieee80211_iftype_p2p(newtype, newp2p);\n\twiphy_dbg(hw->wiphy,\n\t\t  \"%s (old type=%d, new type=%d, mac_addr=%pM)\\n\",\n\t\t  __func__, ieee80211_vif_type_p2p(vif),\n\t\t    newtype, vif->addr);\n\thwsim_check_magic(vif);\n\n\t/*\n\t * interface may change from non-AP to AP in\n\t * which case this needs to be set up again\n\t */\n\tvif->cab_queue = 0;\n\n\treturn 0;\n}\n\nstatic void mac80211_hwsim_remove_interface(\n\tstruct ieee80211_hw *hw, struct ieee80211_vif *vif)\n{\n\twiphy_dbg(hw->wiphy, \"%s (type=%d mac_addr=%pM)\\n\",\n\t\t  __func__, ieee80211_vif_type_p2p(vif),\n\t\t  vif->addr);\n\thwsim_check_magic(vif);\n\thwsim_clear_magic(vif);\n}\n\nstatic void mac80211_hwsim_tx_frame(struct ieee80211_hw *hw,\n\t\t\t\t    struct sk_buff *skb,\n\t\t\t\t    struct ieee80211_channel *chan)\n{\n\tstruct mac80211_hwsim_data *data = hw->priv;\n\tu32 _pid = READ_ONCE(data->wmediumd);\n\n\tif (ieee80211_hw_check(hw, SUPPORTS_RC_TABLE)) {\n\t\tstruct ieee80211_tx_info *txi = IEEE80211_SKB_CB(skb);\n\t\tieee80211_get_tx_rates(txi->control.vif, NULL, skb,\n\t\t\t\t       txi->control.rates,\n\t\t\t\t       ARRAY_SIZE(txi->control.rates));\n\t}\n\n\tmac80211_hwsim_monitor_rx(hw, skb, chan);\n\n\tif (_pid)\n\t\treturn mac80211_hwsim_tx_frame_nl(hw, skb, _pid);\n\n\tmac80211_hwsim_tx_frame_no_nl(hw, skb, chan);\n\tdev_kfree_skb(skb);\n}\n\nstatic void mac80211_hwsim_beacon_tx(void *arg, u8 *mac,\n\t\t\t\t     struct ieee80211_vif *vif)\n{\n\tstruct mac80211_hwsim_data *data = arg;\n\tstruct ieee80211_hw *hw = data->hw;\n\tstruct ieee80211_tx_info *info;\n\tstruct ieee80211_rate *txrate;\n\tstruct ieee80211_mgmt *mgmt;\n\tstruct sk_buff *skb;\n\n\thwsim_check_magic(vif);\n\n\tif (vif->type != NL80211_IFTYPE_AP &&\n\t    vif->type != NL80211_IFTYPE_MESH_POINT &&\n\t    vif->type != NL80211_IFTYPE_ADHOC)\n\t\treturn;\n\n\tskb = ieee80211_beacon_get(hw, vif);\n\tif (skb == NULL)\n\t\treturn;\n\tinfo = IEEE80211_SKB_CB(skb);\n\tif (ieee80211_hw_check(hw, SUPPORTS_RC_TABLE))\n\t\tieee80211_get_tx_rates(vif, NULL, skb,\n\t\t\t\t       info->control.rates,\n\t\t\t\t       ARRAY_SIZE(info->control.rates));\n\n\ttxrate = ieee80211_get_tx_rate(hw, info);\n\n\tmgmt = (struct ieee80211_mgmt *) skb->data;\n\t/* fake header transmission time */\n\tdata->abs_bcn_ts = mac80211_hwsim_get_tsf_raw();\n\tmgmt->u.beacon.timestamp = cpu_to_le64(data->abs_bcn_ts +\n\t\t\t\t\t       data->tsf_offset +\n\t\t\t\t\t       24 * 8 * 10 / txrate->bitrate);\n\n\tmac80211_hwsim_tx_frame(hw, skb,\n\t\t\t\trcu_dereference(vif->chanctx_conf)->def.chan);\n\n\tif (vif->csa_active && ieee80211_csa_is_complete(vif))\n\t\tieee80211_csa_finish(vif);\n}\n\nstatic enum hrtimer_restart\nmac80211_hwsim_beacon(struct hrtimer *timer)\n{\n\tstruct mac80211_hwsim_data *data =\n\t\tcontainer_of(timer, struct mac80211_hwsim_data,\n\t\t\t     beacon_timer.timer);\n\tstruct ieee80211_hw *hw = data->hw;\n\tu64 bcn_int = data->beacon_int;\n\tktime_t next_bcn;\n\n\tif (!data->started)\n\t\tgoto out;\n\n\tieee80211_iterate_active_interfaces_atomic(\n\t\thw, IEEE80211_IFACE_ITER_NORMAL,\n\t\tmac80211_hwsim_beacon_tx, data);\n\n\t/* beacon at new TBTT + beacon interval */\n\tif (data->bcn_delta) {\n\t\tbcn_int -= data->bcn_delta;\n\t\tdata->bcn_delta = 0;\n\t}\n\n\tnext_bcn = ktime_add(hrtimer_get_expires(timer),\n\t\t\t     ns_to_ktime(bcn_int * 1000));\n\ttasklet_hrtimer_start(&data->beacon_timer, next_bcn, HRTIMER_MODE_ABS);\nout:\n\treturn HRTIMER_NORESTART;\n}\n\nstatic const char * const hwsim_chanwidths[] = {\n\t[NL80211_CHAN_WIDTH_20_NOHT] = \"noht\",\n\t[NL80211_CHAN_WIDTH_20] = \"ht20\",\n\t[NL80211_CHAN_WIDTH_40] = \"ht40\",\n\t[NL80211_CHAN_WIDTH_80] = \"vht80\",\n\t[NL80211_CHAN_WIDTH_80P80] = \"vht80p80\",\n\t[NL80211_CHAN_WIDTH_160] = \"vht160\",\n};\n\nstatic int mac80211_hwsim_config(struct ieee80211_hw *hw, u32 changed)\n{\n\tstruct mac80211_hwsim_data *data = hw->priv;\n\tstruct ieee80211_conf *conf = &hw->conf;\n\tstatic const char *smps_modes[IEEE80211_SMPS_NUM_MODES] = {\n\t\t[IEEE80211_SMPS_AUTOMATIC] = \"auto\",\n\t\t[IEEE80211_SMPS_OFF] = \"off\",\n\t\t[IEEE80211_SMPS_STATIC] = \"static\",\n\t\t[IEEE80211_SMPS_DYNAMIC] = \"dynamic\",\n\t};\n\tint idx;\n\n\tif (conf->chandef.chan)\n\t\twiphy_dbg(hw->wiphy,\n\t\t\t  \"%s (freq=%d(%d - %d)/%s idle=%d ps=%d smps=%s)\\n\",\n\t\t\t  __func__,\n\t\t\t  conf->chandef.chan->center_freq,\n\t\t\t  conf->chandef.center_freq1,\n\t\t\t  conf->chandef.center_freq2,\n\t\t\t  hwsim_chanwidths[conf->chandef.width],\n\t\t\t  !!(conf->flags & IEEE80211_CONF_IDLE),\n\t\t\t  !!(conf->flags & IEEE80211_CONF_PS),\n\t\t\t  smps_modes[conf->smps_mode]);\n\telse\n\t\twiphy_dbg(hw->wiphy,\n\t\t\t  \"%s (freq=0 idle=%d ps=%d smps=%s)\\n\",\n\t\t\t  __func__,\n\t\t\t  !!(conf->flags & IEEE80211_CONF_IDLE),\n\t\t\t  !!(conf->flags & IEEE80211_CONF_PS),\n\t\t\t  smps_modes[conf->smps_mode]);\n\n\tdata->idle = !!(conf->flags & IEEE80211_CONF_IDLE);\n\n\tWARN_ON(conf->chandef.chan && data->use_chanctx);\n\n\tmutex_lock(&data->mutex);\n\tif (data->scanning && conf->chandef.chan) {\n\t\tfor (idx = 0; idx < ARRAY_SIZE(data->survey_data); idx++) {\n\t\t\tif (data->survey_data[idx].channel == data->channel) {\n\t\t\t\tdata->survey_data[idx].start =\n\t\t\t\t\tdata->survey_data[idx].next_start;\n\t\t\t\tdata->survey_data[idx].end = jiffies;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tdata->channel = conf->chandef.chan;\n\n\t\tfor (idx = 0; idx < ARRAY_SIZE(data->survey_data); idx++) {\n\t\t\tif (data->survey_data[idx].channel &&\n\t\t\t    data->survey_data[idx].channel != data->channel)\n\t\t\t\tcontinue;\n\t\t\tdata->survey_data[idx].channel = data->channel;\n\t\t\tdata->survey_data[idx].next_start = jiffies;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tdata->channel = conf->chandef.chan;\n\t}\n\tmutex_unlock(&data->mutex);\n\n\tif (!data->started || !data->beacon_int)\n\t\ttasklet_hrtimer_cancel(&data->beacon_timer);\n\telse if (!hrtimer_is_queued(&data->beacon_timer.timer)) {\n\t\tu64 tsf = mac80211_hwsim_get_tsf(hw, NULL);\n\t\tu32 bcn_int = data->beacon_int;\n\t\tu64 until_tbtt = bcn_int - do_div(tsf, bcn_int);\n\n\t\ttasklet_hrtimer_start(&data->beacon_timer,\n\t\t\t\t      ns_to_ktime(until_tbtt * 1000),\n\t\t\t\t      HRTIMER_MODE_REL);\n\t}\n\n\treturn 0;\n}\n\n\nstatic void mac80211_hwsim_configure_filter(struct ieee80211_hw *hw,\n\t\t\t\t\t    unsigned int changed_flags,\n\t\t\t\t\t    unsigned int *total_flags,u64 multicast)\n{\n\tstruct mac80211_hwsim_data *data = hw->priv;\n\n\twiphy_dbg(hw->wiphy, \"%s\\n\", __func__);\n\n\tdata->rx_filter = 0;\n\tif (*total_flags & FIF_ALLMULTI)\n\t\tdata->rx_filter |= FIF_ALLMULTI;\n\n\t*total_flags = data->rx_filter;\n}\n\nstatic void mac80211_hwsim_bcn_en_iter(void *data, u8 *mac,\n\t\t\t\t       struct ieee80211_vif *vif)\n{\n\tunsigned int *count = data;\n\tstruct hwsim_vif_priv *vp = (void *)vif->drv_priv;\n\n\tif (vp->bcn_en)\n\t\t(*count)++;\n}\n\nstatic void mac80211_hwsim_bss_info_changed(struct ieee80211_hw *hw,\n\t\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t\t    struct ieee80211_bss_conf *info,\n\t\t\t\t\t    u32 changed)\n{\n\tstruct hwsim_vif_priv *vp = (void *)vif->drv_priv;\n\tstruct mac80211_hwsim_data *data = hw->priv;\n\n\thwsim_check_magic(vif);\n\n\twiphy_dbg(hw->wiphy, \"%s(changed=0x%x vif->addr=%pM)\\n\",\n\t\t  __func__, changed, vif->addr);\n\n\tif (changed & BSS_CHANGED_BSSID) {\n\t\twiphy_dbg(hw->wiphy, \"%s: BSSID changed: %pM\\n\",\n\t\t\t  __func__, info->bssid);\n\t\tmemcpy(vp->bssid, info->bssid, ETH_ALEN);\n\t}\n\n\tif (changed & BSS_CHANGED_ASSOC) {\n\t\twiphy_dbg(hw->wiphy, \"  ASSOC: assoc=%d aid=%d\\n\",\n\t\t\t  info->assoc, info->aid);\n\t\tvp->assoc = info->assoc;\n\t\tvp->aid = info->aid;\n\t}\n\n\tif (changed & BSS_CHANGED_BEACON_ENABLED) {\n\t\twiphy_dbg(hw->wiphy, \"  BCN EN: %d (BI=%u)\\n\",\n\t\t\t  info->enable_beacon, info->beacon_int);\n\t\tvp->bcn_en = info->enable_beacon;\n\t\tif (data->started &&\n\t\t    !hrtimer_is_queued(&data->beacon_timer.timer) &&\n\t\t    info->enable_beacon) {\n\t\t\tu64 tsf, until_tbtt;\n\t\t\tu32 bcn_int;\n\t\t\tdata->beacon_int = info->beacon_int * 1024;\n\t\t\ttsf = mac80211_hwsim_get_tsf(hw, vif);\n\t\t\tbcn_int = data->beacon_int;\n\t\t\tuntil_tbtt = bcn_int - do_div(tsf, bcn_int);\n\t\t\ttasklet_hrtimer_start(&data->beacon_timer,\n\t\t\t\t\t      ns_to_ktime(until_tbtt * 1000),\n\t\t\t\t\t      HRTIMER_MODE_REL);\n\t\t} else if (!info->enable_beacon) {\n\t\t\tunsigned int count = 0;\n\t\t\tieee80211_iterate_active_interfaces_atomic(\n\t\t\t\tdata->hw, IEEE80211_IFACE_ITER_NORMAL,\n\t\t\t\tmac80211_hwsim_bcn_en_iter, &count);\n\t\t\twiphy_dbg(hw->wiphy, \"  beaconing vifs remaining: %u\",\n\t\t\t\t  count);\n\t\t\tif (count == 0) {\n\t\t\t\ttasklet_hrtimer_cancel(&data->beacon_timer);\n\t\t\t\tdata->beacon_int = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (changed & BSS_CHANGED_ERP_CTS_PROT) {\n\t\twiphy_dbg(hw->wiphy, \"  ERP_CTS_PROT: %d\\n\",\n\t\t\t  info->use_cts_prot);\n\t}\n\n\tif (changed & BSS_CHANGED_ERP_PREAMBLE) {\n\t\twiphy_dbg(hw->wiphy, \"  ERP_PREAMBLE: %d\\n\",\n\t\t\t  info->use_short_preamble);\n\t}\n\n\tif (changed & BSS_CHANGED_ERP_SLOT) {\n\t\twiphy_dbg(hw->wiphy, \"  ERP_SLOT: %d\\n\", info->use_short_slot);\n\t}\n\n\tif (changed & BSS_CHANGED_HT) {\n\t\twiphy_dbg(hw->wiphy, \"  HT: op_mode=0x%x\\n\",\n\t\t\t  info->ht_operation_mode);\n\t}\n\n\tif (changed & BSS_CHANGED_BASIC_RATES) {\n\t\twiphy_dbg(hw->wiphy, \"  BASIC_RATES: 0x%llx\\n\",\n\t\t\t  (unsigned long long) info->basic_rates);\n\t}\n\n\tif (changed & BSS_CHANGED_TXPOWER)\n\t\twiphy_dbg(hw->wiphy, \"  TX Power: %d dBm\\n\", info->txpower);\n}\n\nstatic int mac80211_hwsim_sta_add(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t  struct ieee80211_sta *sta)\n{\n\thwsim_check_magic(vif);\n\thwsim_set_sta_magic(sta);\n\n\treturn 0;\n}\n\nstatic int mac80211_hwsim_sta_remove(struct ieee80211_hw *hw,\n\t\t\t\t     struct ieee80211_vif *vif,\n\t\t\t\t     struct ieee80211_sta *sta)\n{\n\thwsim_check_magic(vif);\n\thwsim_clear_sta_magic(sta);\n\n\treturn 0;\n}\n\nstatic void mac80211_hwsim_sta_notify(struct ieee80211_hw *hw,\n\t\t\t\t      struct ieee80211_vif *vif,\n\t\t\t\t      enum sta_notify_cmd cmd,\n\t\t\t\t      struct ieee80211_sta *sta)\n{\n\thwsim_check_magic(vif);\n\n\tswitch (cmd) {\n\tcase STA_NOTIFY_SLEEP:\n\tcase STA_NOTIFY_AWAKE:\n\t\t/* TODO: make good use of these flags */\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"Invalid sta notify: %d\\n\", cmd);\n\t\tbreak;\n\t}\n}\n\nstatic int mac80211_hwsim_set_tim(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_sta *sta,\n\t\t\t\t  bool set)\n{\n\thwsim_check_sta_magic(sta);\n\treturn 0;\n}\n\nstatic int mac80211_hwsim_conf_tx(\n\tstruct ieee80211_hw *hw,\n\tstruct ieee80211_vif *vif, u16 queue,\n\tconst struct ieee80211_tx_queue_params *params)\n{\n\twiphy_dbg(hw->wiphy,\n\t\t  \"%s (queue=%d txop=%d cw_min=%d cw_max=%d aifs=%d)\\n\",\n\t\t  __func__, queue,\n\t\t  params->txop, params->cw_min,\n\t\t  params->cw_max, params->aifs);\n\treturn 0;\n}\n\nstatic int mac80211_hwsim_get_survey(struct ieee80211_hw *hw, int idx,\n\t\t\t\t     struct survey_info *survey)\n{\n\tstruct mac80211_hwsim_data *hwsim = hw->priv;\n\n\tif (idx < 0 || idx >= ARRAY_SIZE(hwsim->survey_data))\n\t\treturn -ENOENT;\n\n\tmutex_lock(&hwsim->mutex);\n\tsurvey->channel = hwsim->survey_data[idx].channel;\n\tif (!survey->channel) {\n\t\tmutex_unlock(&hwsim->mutex);\n\t\treturn -ENOENT;\n\t}\n\n\t/*\n\t * Magically conjured dummy values --- this is only ok for simulated hardware.\n\t *\n\t * A real driver which cannot determine real values noise MUST NOT\n\t * report any, especially not a magically conjured ones :-)\n\t */\n\tsurvey->filled = SURVEY_INFO_NOISE_DBM |\n\t\t\t SURVEY_INFO_TIME |\n\t\t\t SURVEY_INFO_TIME_BUSY;\n\tsurvey->noise = -92;\n\tsurvey->time =\n\t\tjiffies_to_msecs(hwsim->survey_data[idx].end -\n\t\t\t\t hwsim->survey_data[idx].start);\n\t/* report 12.5% of channel time is used */\n\tsurvey->time_busy = survey->time/8;\n\tmutex_unlock(&hwsim->mutex);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_NL80211_TESTMODE\n/*\n * This section contains example code for using netlink\n * attributes with the testmode command in nl80211.\n */\n\n/* These enums need to be kept in sync with userspace */\nenum hwsim_testmode_attr {\n\t__HWSIM_TM_ATTR_INVALID\t= 0,\n\tHWSIM_TM_ATTR_CMD\t= 1,\n\tHWSIM_TM_ATTR_PS\t= 2,\n\n\t/* keep last */\n\t__HWSIM_TM_ATTR_AFTER_LAST,\n\tHWSIM_TM_ATTR_MAX\t= __HWSIM_TM_ATTR_AFTER_LAST - 1\n};\n\nenum hwsim_testmode_cmd {\n\tHWSIM_TM_CMD_SET_PS\t\t= 0,\n\tHWSIM_TM_CMD_GET_PS\t\t= 1,\n\tHWSIM_TM_CMD_STOP_QUEUES\t= 2,\n\tHWSIM_TM_CMD_WAKE_QUEUES\t= 3,\n};\n\nstatic const struct nla_policy hwsim_testmode_policy[HWSIM_TM_ATTR_MAX + 1] = {\n\t[HWSIM_TM_ATTR_CMD] = { .type = NLA_U32 },\n\t[HWSIM_TM_ATTR_PS] = { .type = NLA_U32 },\n};\n\nstatic int mac80211_hwsim_testmode_cmd(struct ieee80211_hw *hw,\n\t\t\t\t       struct ieee80211_vif *vif,\n\t\t\t\t       void *data, int len)\n{\n\tstruct mac80211_hwsim_data *hwsim = hw->priv;\n\tstruct nlattr *tb[HWSIM_TM_ATTR_MAX + 1];\n\tstruct sk_buff *skb;\n\tint err, ps;\n\n\terr = nla_parse(tb, HWSIM_TM_ATTR_MAX, data, len,\n\t\t\thwsim_testmode_policy, NULL);\n\tif (err)\n\t\treturn err;\n\n\tif (!tb[HWSIM_TM_ATTR_CMD])\n\t\treturn -EINVAL;\n\n\tswitch (nla_get_u32(tb[HWSIM_TM_ATTR_CMD])) {\n\tcase HWSIM_TM_CMD_SET_PS:\n\t\tif (!tb[HWSIM_TM_ATTR_PS])\n\t\t\treturn -EINVAL;\n\t\tps = nla_get_u32(tb[HWSIM_TM_ATTR_PS]);\n\t\treturn hwsim_fops_ps_write(hwsim, ps);\n\tcase HWSIM_TM_CMD_GET_PS:\n\t\tskb = cfg80211_testmode_alloc_reply_skb(hw->wiphy,\n\t\t\t\t\t\tnla_total_size(sizeof(u32)));\n\t\tif (!skb)\n\t\t\treturn -ENOMEM;\n\t\tif (nla_put_u32(skb, HWSIM_TM_ATTR_PS, hwsim->ps))\n\t\t\tgoto nla_put_failure;\n\t\treturn cfg80211_testmode_reply(skb);\n\tcase HWSIM_TM_CMD_STOP_QUEUES:\n\t\tieee80211_stop_queues(hw);\n\t\treturn 0;\n\tcase HWSIM_TM_CMD_WAKE_QUEUES:\n\t\tieee80211_wake_queues(hw);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n nla_put_failure:\n\tkfree_skb(skb);\n\treturn -ENOBUFS;\n}\n#endif\n\nstatic int mac80211_hwsim_ampdu_action(struct ieee80211_hw *hw,\n\t\t\t\t       struct ieee80211_vif *vif,\n\t\t\t\t       struct ieee80211_ampdu_params *params)\n{\n\tstruct ieee80211_sta *sta = params->sta;\n\tenum ieee80211_ampdu_mlme_action action = params->action;\n\tu16 tid = params->tid;\n\n\tswitch (action) {\n\tcase IEEE80211_AMPDU_TX_START:\n\t\tieee80211_start_tx_ba_cb_irqsafe(vif, sta->addr, tid);\n\t\tbreak;\n\tcase IEEE80211_AMPDU_TX_STOP_CONT:\n\tcase IEEE80211_AMPDU_TX_STOP_FLUSH:\n\tcase IEEE80211_AMPDU_TX_STOP_FLUSH_CONT:\n\t\tieee80211_stop_tx_ba_cb_irqsafe(vif, sta->addr, tid);\n\t\tbreak;\n\tcase IEEE80211_AMPDU_TX_OPERATIONAL:\n\t\tbreak;\n\tcase IEEE80211_AMPDU_RX_START:\n\tcase IEEE80211_AMPDU_RX_STOP:\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic void mac80211_hwsim_flush(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t u32 queues, bool drop)\n{\n\t/* Not implemented, queues only on kernel side */\n}\n\nstatic void hw_scan_work(struct work_struct *work)\n{\n\tstruct mac80211_hwsim_data *hwsim =\n\t\tcontainer_of(work, struct mac80211_hwsim_data, hw_scan.work);\n\tstruct cfg80211_scan_request *req = hwsim->hw_scan_request;\n\tint dwell, i;\n\n\tmutex_lock(&hwsim->mutex);\n\tif (hwsim->scan_chan_idx >= req->n_channels) {\n\t\tstruct cfg80211_scan_info info = {\n\t\t\t.aborted = false,\n\t\t};\n\n\t\twiphy_dbg(hwsim->hw->wiphy, \"hw scan complete\\n\");\n\t\tieee80211_scan_completed(hwsim->hw, &info);\n\t\thwsim->hw_scan_request = NULL;\n\t\thwsim->hw_scan_vif = NULL;\n\t\thwsim->tmp_chan = NULL;\n\t\tmutex_unlock(&hwsim->mutex);\n\t\treturn;\n\t}\n\n\twiphy_dbg(hwsim->hw->wiphy, \"hw scan %d MHz\\n\",\n\t\t  req->channels[hwsim->scan_chan_idx]->center_freq);\n\n\thwsim->tmp_chan = req->channels[hwsim->scan_chan_idx];\n\tif (hwsim->tmp_chan->flags & (IEEE80211_CHAN_NO_IR |\n\t\t\t\t      IEEE80211_CHAN_RADAR) ||\n\t    !req->n_ssids) {\n\t\tdwell = 120;\n\t} else {\n\t\tdwell = 30;\n\t\t/* send probes */\n\t\tfor (i = 0; i < req->n_ssids; i++) {\n\t\t\tstruct sk_buff *probe;\n\t\t\tstruct ieee80211_mgmt *mgmt;\n\n\t\t\tprobe = ieee80211_probereq_get(hwsim->hw,\n\t\t\t\t\t\t       hwsim->scan_addr,\n\t\t\t\t\t\t       req->ssids[i].ssid,\n\t\t\t\t\t\t       req->ssids[i].ssid_len,\n\t\t\t\t\t\t       req->ie_len);\n\t\t\tif (!probe)\n\t\t\t\tcontinue;\n\n\t\t\tmgmt = (struct ieee80211_mgmt *) probe->data;\n\t\t\tmemcpy(mgmt->da, req->bssid, ETH_ALEN);\n\t\t\tmemcpy(mgmt->bssid, req->bssid, ETH_ALEN);\n\n\t\t\tif (req->ie_len)\n\t\t\t\tskb_put_data(probe, req->ie, req->ie_len);\n\n\t\t\tlocal_bh_disable();\n\t\t\tmac80211_hwsim_tx_frame(hwsim->hw, probe,\n\t\t\t\t\t\thwsim->tmp_chan);\n\t\t\tlocal_bh_enable();\n\t\t}\n\t}\n\tieee80211_queue_delayed_work(hwsim->hw, &hwsim->hw_scan,\n\t\t\t\t     msecs_to_jiffies(dwell));\n\thwsim->survey_data[hwsim->scan_chan_idx].channel = hwsim->tmp_chan;\n\thwsim->survey_data[hwsim->scan_chan_idx].start = jiffies;\n\thwsim->survey_data[hwsim->scan_chan_idx].end =\n\t\tjiffies + msecs_to_jiffies(dwell);\n\thwsim->scan_chan_idx++;\n\tmutex_unlock(&hwsim->mutex);\n}\n\nstatic int mac80211_hwsim_hw_scan(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t  struct ieee80211_scan_request *hw_req)\n{\n\tstruct mac80211_hwsim_data *hwsim = hw->priv;\n\tstruct cfg80211_scan_request *req = &hw_req->req;\n\n\tmutex_lock(&hwsim->mutex);\n\tif (WARN_ON(hwsim->tmp_chan || hwsim->hw_scan_request)) {\n\t\tmutex_unlock(&hwsim->mutex);\n\t\treturn -EBUSY;\n\t}\n\thwsim->hw_scan_request = req;\n\thwsim->hw_scan_vif = vif;\n\thwsim->scan_chan_idx = 0;\n\tif (req->flags & NL80211_SCAN_FLAG_RANDOM_ADDR)\n\t\tget_random_mask_addr(hwsim->scan_addr,\n\t\t\t\t     hw_req->req.mac_addr,\n\t\t\t\t     hw_req->req.mac_addr_mask);\n\telse\n\t\tmemcpy(hwsim->scan_addr, vif->addr, ETH_ALEN);\n\tmemset(hwsim->survey_data, 0, sizeof(hwsim->survey_data));\n\tmutex_unlock(&hwsim->mutex);\n\n\twiphy_dbg(hw->wiphy, \"hwsim hw_scan request\\n\");\n\n\tieee80211_queue_delayed_work(hwsim->hw, &hwsim->hw_scan, 0);\n\n\treturn 0;\n}\n\nstatic void mac80211_hwsim_cancel_hw_scan(struct ieee80211_hw *hw,\n\t\t\t\t\t  struct ieee80211_vif *vif)\n{\n\tstruct mac80211_hwsim_data *hwsim = hw->priv;\n\tstruct cfg80211_scan_info info = {\n\t\t.aborted = true,\n\t};\n\n\twiphy_dbg(hw->wiphy, \"hwsim cancel_hw_scan\\n\");\n\n\tcancel_delayed_work_sync(&hwsim->hw_scan);\n\n\tmutex_lock(&hwsim->mutex);\n\tieee80211_scan_completed(hwsim->hw, &info);\n\thwsim->tmp_chan = NULL;\n\thwsim->hw_scan_request = NULL;\n\thwsim->hw_scan_vif = NULL;\n\tmutex_unlock(&hwsim->mutex);\n}\n\nstatic void mac80211_hwsim_sw_scan(struct ieee80211_hw *hw,\n\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t   const u8 *mac_addr)\n{\n\tstruct mac80211_hwsim_data *hwsim = hw->priv;\n\n\tmutex_lock(&hwsim->mutex);\n\n\tif (hwsim->scanning) {\n\t\tpr_debug(\"two hwsim sw_scans detected!\\n\");\n\t\tgoto out;\n\t}\n\n\tpr_debug(\"hwsim sw_scan request, prepping stuff\\n\");\n\n\tmemcpy(hwsim->scan_addr, mac_addr, ETH_ALEN);\n\thwsim->scanning = true;\n\tmemset(hwsim->survey_data, 0, sizeof(hwsim->survey_data));\n\nout:\n\tmutex_unlock(&hwsim->mutex);\n}\n\nstatic void mac80211_hwsim_sw_scan_complete(struct ieee80211_hw *hw,\n\t\t\t\t\t    struct ieee80211_vif *vif)\n{\n\tstruct mac80211_hwsim_data *hwsim = hw->priv;\n\n\tmutex_lock(&hwsim->mutex);\n\n\tpr_debug(\"hwsim sw_scan_complete\\n\");\n\thwsim->scanning = false;\n\teth_zero_addr(hwsim->scan_addr);\n\n\tmutex_unlock(&hwsim->mutex);\n}\n\nstatic void hw_roc_start(struct work_struct *work)\n{\n\tstruct mac80211_hwsim_data *hwsim =\n\t\tcontainer_of(work, struct mac80211_hwsim_data, roc_start.work);\n\n\tmutex_lock(&hwsim->mutex);\n\n\twiphy_dbg(hwsim->hw->wiphy, \"hwsim ROC begins\\n\");\n\thwsim->tmp_chan = hwsim->roc_chan;\n\tieee80211_ready_on_channel(hwsim->hw);\n\n\tieee80211_queue_delayed_work(hwsim->hw, &hwsim->roc_done,\n\t\t\t\t     msecs_to_jiffies(hwsim->roc_duration));\n\n\tmutex_unlock(&hwsim->mutex);\n}\n\nstatic void hw_roc_done(struct work_struct *work)\n{\n\tstruct mac80211_hwsim_data *hwsim =\n\t\tcontainer_of(work, struct mac80211_hwsim_data, roc_done.work);\n\n\tmutex_lock(&hwsim->mutex);\n\tieee80211_remain_on_channel_expired(hwsim->hw);\n\thwsim->tmp_chan = NULL;\n\tmutex_unlock(&hwsim->mutex);\n\n\twiphy_dbg(hwsim->hw->wiphy, \"hwsim ROC expired\\n\");\n}\n\nstatic int mac80211_hwsim_roc(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_vif *vif,\n\t\t\t      struct ieee80211_channel *chan,\n\t\t\t      int duration,\n\t\t\t      enum ieee80211_roc_type type)\n{\n\tstruct mac80211_hwsim_data *hwsim = hw->priv;\n\n\tmutex_lock(&hwsim->mutex);\n\tif (WARN_ON(hwsim->tmp_chan || hwsim->hw_scan_request)) {\n\t\tmutex_unlock(&hwsim->mutex);\n\t\treturn -EBUSY;\n\t}\n\n\thwsim->roc_chan = chan;\n\thwsim->roc_duration = duration;\n\tmutex_unlock(&hwsim->mutex);\n\n\twiphy_dbg(hw->wiphy, \"hwsim ROC (%d MHz, %d ms)\\n\",\n\t\t  chan->center_freq, duration);\n\tieee80211_queue_delayed_work(hw, &hwsim->roc_start, HZ/50);\n\n\treturn 0;\n}\n\nstatic int mac80211_hwsim_croc(struct ieee80211_hw *hw)\n{\n\tstruct mac80211_hwsim_data *hwsim = hw->priv;\n\n\tcancel_delayed_work_sync(&hwsim->roc_start);\n\tcancel_delayed_work_sync(&hwsim->roc_done);\n\n\tmutex_lock(&hwsim->mutex);\n\thwsim->tmp_chan = NULL;\n\tmutex_unlock(&hwsim->mutex);\n\n\twiphy_dbg(hw->wiphy, \"hwsim ROC canceled\\n\");\n\n\treturn 0;\n}\n\nstatic int mac80211_hwsim_add_chanctx(struct ieee80211_hw *hw,\n\t\t\t\t      struct ieee80211_chanctx_conf *ctx)\n{\n\thwsim_set_chanctx_magic(ctx);\n\twiphy_dbg(hw->wiphy,\n\t\t  \"add channel context control: %d MHz/width: %d/cfreqs:%d/%d MHz\\n\",\n\t\t  ctx->def.chan->center_freq, ctx->def.width,\n\t\t  ctx->def.center_freq1, ctx->def.center_freq2);\n\treturn 0;\n}\n\nstatic void mac80211_hwsim_remove_chanctx(struct ieee80211_hw *hw,\n\t\t\t\t\t  struct ieee80211_chanctx_conf *ctx)\n{\n\twiphy_dbg(hw->wiphy,\n\t\t  \"remove channel context control: %d MHz/width: %d/cfreqs:%d/%d MHz\\n\",\n\t\t  ctx->def.chan->center_freq, ctx->def.width,\n\t\t  ctx->def.center_freq1, ctx->def.center_freq2);\n\thwsim_check_chanctx_magic(ctx);\n\thwsim_clear_chanctx_magic(ctx);\n}\n\nstatic void mac80211_hwsim_change_chanctx(struct ieee80211_hw *hw,\n\t\t\t\t\t  struct ieee80211_chanctx_conf *ctx,\n\t\t\t\t\t  u32 changed)\n{\n\thwsim_check_chanctx_magic(ctx);\n\twiphy_dbg(hw->wiphy,\n\t\t  \"change channel context control: %d MHz/width: %d/cfreqs:%d/%d MHz\\n\",\n\t\t  ctx->def.chan->center_freq, ctx->def.width,\n\t\t  ctx->def.center_freq1, ctx->def.center_freq2);\n}\n\nstatic int mac80211_hwsim_assign_vif_chanctx(struct ieee80211_hw *hw,\n\t\t\t\t\t     struct ieee80211_vif *vif,\n\t\t\t\t\t     struct ieee80211_chanctx_conf *ctx)\n{\n\thwsim_check_magic(vif);\n\thwsim_check_chanctx_magic(ctx);\n\n\treturn 0;\n}\n\nstatic void mac80211_hwsim_unassign_vif_chanctx(struct ieee80211_hw *hw,\n\t\t\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\t\t\tstruct ieee80211_chanctx_conf *ctx)\n{\n\thwsim_check_magic(vif);\n\thwsim_check_chanctx_magic(ctx);\n}\n\nstatic const char mac80211_hwsim_gstrings_stats[][ETH_GSTRING_LEN] = {\n\t\"tx_pkts_nic\",\n\t\"tx_bytes_nic\",\n\t\"rx_pkts_nic\",\n\t\"rx_bytes_nic\",\n\t\"d_tx_dropped\",\n\t\"d_tx_failed\",\n\t\"d_ps_mode\",\n\t\"d_group\",\n};\n\n#define MAC80211_HWSIM_SSTATS_LEN ARRAY_SIZE(mac80211_hwsim_gstrings_stats)\n\nstatic void mac80211_hwsim_get_et_strings(struct ieee80211_hw *hw,\n\t\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t\t  u32 sset, u8 *data)\n{\n\tif (sset == ETH_SS_STATS)\n\t\tmemcpy(data, *mac80211_hwsim_gstrings_stats,\n\t\t       sizeof(mac80211_hwsim_gstrings_stats));\n}\n\nstatic int mac80211_hwsim_get_et_sset_count(struct ieee80211_hw *hw,\n\t\t\t\t\t    struct ieee80211_vif *vif, int sset)\n{\n\tif (sset == ETH_SS_STATS)\n\t\treturn MAC80211_HWSIM_SSTATS_LEN;\n\treturn 0;\n}\n\nstatic void mac80211_hwsim_get_et_stats(struct ieee80211_hw *hw,\n\t\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\t\tstruct ethtool_stats *stats, u64 *data)\n{\n\tstruct mac80211_hwsim_data *ar = hw->priv;\n\tint i = 0;\n\n\tdata[i++] = ar->tx_pkts;\n\tdata[i++] = ar->tx_bytes;\n\tdata[i++] = ar->rx_pkts;\n\tdata[i++] = ar->rx_bytes;\n\tdata[i++] = ar->tx_dropped;\n\tdata[i++] = ar->tx_failed;\n\tdata[i++] = ar->ps;\n\tdata[i++] = ar->group;\n\n\tWARN_ON(i != MAC80211_HWSIM_SSTATS_LEN);\n}\n\n#define HWSIM_COMMON_OPS\t\t\t\t\t\\\n\t.tx = mac80211_hwsim_tx,\t\t\t\t\\\n\t.start = mac80211_hwsim_start,\t\t\t\t\\\n\t.stop = mac80211_hwsim_stop,\t\t\t\t\\\n\t.add_interface = mac80211_hwsim_add_interface,\t\t\\\n\t.change_interface = mac80211_hwsim_change_interface,\t\\\n\t.remove_interface = mac80211_hwsim_remove_interface,\t\\\n\t.config = mac80211_hwsim_config,\t\t\t\\\n\t.configure_filter = mac80211_hwsim_configure_filter,\t\\\n\t.bss_info_changed = mac80211_hwsim_bss_info_changed,\t\\\n\t.sta_add = mac80211_hwsim_sta_add,\t\t\t\\\n\t.sta_remove = mac80211_hwsim_sta_remove,\t\t\\\n\t.sta_notify = mac80211_hwsim_sta_notify,\t\t\\\n\t.set_tim = mac80211_hwsim_set_tim,\t\t\t\\\n\t.conf_tx = mac80211_hwsim_conf_tx,\t\t\t\\\n\t.get_survey = mac80211_hwsim_get_survey,\t\t\\\n\tCFG80211_TESTMODE_CMD(mac80211_hwsim_testmode_cmd)\t\\\n\t.ampdu_action = mac80211_hwsim_ampdu_action,\t\t\\\n\t.flush = mac80211_hwsim_flush,\t\t\t\t\\\n\t.get_tsf = mac80211_hwsim_get_tsf,\t\t\t\\\n\t.set_tsf = mac80211_hwsim_set_tsf,\t\t\t\\\n\t.get_et_sset_count = mac80211_hwsim_get_et_sset_count,\t\\\n\t.get_et_stats = mac80211_hwsim_get_et_stats,\t\t\\\n\t.get_et_strings = mac80211_hwsim_get_et_strings,\n\nstatic const struct ieee80211_ops mac80211_hwsim_ops = {\n\tHWSIM_COMMON_OPS\n\t.sw_scan_start = mac80211_hwsim_sw_scan,\n\t.sw_scan_complete = mac80211_hwsim_sw_scan_complete,\n};\n\nstatic const struct ieee80211_ops mac80211_hwsim_mchan_ops = {\n\tHWSIM_COMMON_OPS\n\t.hw_scan = mac80211_hwsim_hw_scan,\n\t.cancel_hw_scan = mac80211_hwsim_cancel_hw_scan,\n\t.sw_scan_start = NULL,\n\t.sw_scan_complete = NULL,\n\t.remain_on_channel = mac80211_hwsim_roc,\n\t.cancel_remain_on_channel = mac80211_hwsim_croc,\n\t.add_chanctx = mac80211_hwsim_add_chanctx,\n\t.remove_chanctx = mac80211_hwsim_remove_chanctx,\n\t.change_chanctx = mac80211_hwsim_change_chanctx,\n\t.assign_vif_chanctx = mac80211_hwsim_assign_vif_chanctx,\n\t.unassign_vif_chanctx = mac80211_hwsim_unassign_vif_chanctx,\n};\n\nstruct hwsim_new_radio_params {\n\tunsigned int channels;\n\tconst char *reg_alpha2;\n\tconst struct ieee80211_regdomain *regd;\n\tbool reg_strict;\n\tbool p2p_device;\n\tbool use_chanctx;\n\tbool destroy_on_close;\n\tconst char *hwname;\n\tbool no_vif;\n};\n\nstatic void hwsim_mcast_config_msg(struct sk_buff *mcast_skb,\n\t\t\t\t   struct genl_info *info)\n{\n\tif (info)\n\t\tgenl_notify(&hwsim_genl_family, mcast_skb, info,\n\t\t\t    HWSIM_MCGRP_CONFIG, GFP_KERNEL);\n\telse\n\t\tgenlmsg_multicast(&hwsim_genl_family, mcast_skb, 0,\n\t\t\t\t  HWSIM_MCGRP_CONFIG, GFP_KERNEL);\n}\n\nstatic int append_radio_msg(struct sk_buff *skb, int id,\n\t\t\t    struct hwsim_new_radio_params *param)\n{\n\tint ret;\n\n\tret = nla_put_u32(skb, HWSIM_ATTR_RADIO_ID, id);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (param->channels) {\n\t\tret = nla_put_u32(skb, HWSIM_ATTR_CHANNELS, param->channels);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (param->reg_alpha2) {\n\t\tret = nla_put(skb, HWSIM_ATTR_REG_HINT_ALPHA2, 2,\n\t\t\t      param->reg_alpha2);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (param->regd) {\n\t\tint i;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(hwsim_world_regdom_custom); i++) {\n\t\t\tif (hwsim_world_regdom_custom[i] != param->regd)\n\t\t\t\tcontinue;\n\n\t\t\tret = nla_put_u32(skb, HWSIM_ATTR_REG_CUSTOM_REG, i);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (param->reg_strict) {\n\t\tret = nla_put_flag(skb, HWSIM_ATTR_REG_STRICT_REG);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (param->p2p_device) {\n\t\tret = nla_put_flag(skb, HWSIM_ATTR_SUPPORT_P2P_DEVICE);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (param->use_chanctx) {\n\t\tret = nla_put_flag(skb, HWSIM_ATTR_USE_CHANCTX);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (param->hwname) {\n\t\tret = nla_put(skb, HWSIM_ATTR_RADIO_NAME,\n\t\t\t      strlen(param->hwname), param->hwname);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void hwsim_mcast_new_radio(int id, struct genl_info *info,\n\t\t\t\t  struct hwsim_new_radio_params *param)\n{\n\tstruct sk_buff *mcast_skb;\n\tvoid *data;\n\n\tmcast_skb = genlmsg_new(GENLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!mcast_skb)\n\t\treturn;\n\n\tdata = genlmsg_put(mcast_skb, 0, 0, &hwsim_genl_family, 0,\n\t\t\t   HWSIM_CMD_NEW_RADIO);\n\tif (!data)\n\t\tgoto out_err;\n\n\tif (append_radio_msg(mcast_skb, id, param) < 0)\n\t\tgoto out_err;\n\n\tgenlmsg_end(mcast_skb, data);\n\n\thwsim_mcast_config_msg(mcast_skb, info);\n\treturn;\n\nout_err:\n\tgenlmsg_cancel(mcast_skb, data);\n\tnlmsg_free(mcast_skb);\n}\n\nstatic int mac80211_hwsim_new_radio(struct genl_info *info,\n\t\t\t\t    struct hwsim_new_radio_params *param)\n{\n\tint err;\n\tu8 addr[ETH_ALEN];\n\tstruct mac80211_hwsim_data *data;\n\tstruct ieee80211_hw *hw;\n\tenum nl80211_band band;\n\tconst struct ieee80211_ops *ops = &mac80211_hwsim_ops;\n\tstruct net *net;\n\tint idx;\n\n\tif (WARN_ON(param->channels > 1 && !param->use_chanctx))\n\t\treturn -EINVAL;\n\n\tspin_lock_bh(&hwsim_radio_lock);\n\tidx = hwsim_radio_idx++;\n\tspin_unlock_bh(&hwsim_radio_lock);\n\n\tif (param->use_chanctx)\n\t\tops = &mac80211_hwsim_mchan_ops;\n\thw = ieee80211_alloc_hw_nm(sizeof(*data), ops, param->hwname);\n\tif (!hw) {\n\t\tpr_debug(\"mac80211_hwsim: ieee80211_alloc_hw failed\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto failed;\n\t}\n\n\t/* ieee80211_alloc_hw_nm may have used a default name */\n\tparam->hwname = wiphy_name(hw->wiphy);\n\n\tif (info)\n\t\tnet = genl_info_net(info);\n\telse\n\t\tnet = &init_net;\n\twiphy_net_set(hw->wiphy, net);\n\n\tdata = hw->priv;\n\tdata->hw = hw;\n\n\tdata->dev = device_create(hwsim_class, NULL, 0, hw, \"hwsim%d\", idx);\n\tif (IS_ERR(data->dev)) {\n\t\tprintk(KERN_DEBUG\n\t\t       \"mac80211_hwsim: device_create failed (%ld)\\n\",\n\t\t       PTR_ERR(data->dev));\n\t\terr = -ENOMEM;\n\t\tgoto failed_drvdata;\n\t}\n\tdata->dev->driver = &mac80211_hwsim_driver.driver;\n\terr = device_bind_driver(data->dev);\n\tif (err != 0) {\n\t\tpr_debug(\"mac80211_hwsim: device_bind_driver failed (%d)\\n\",\n\t\t       err);\n\t\tgoto failed_bind;\n\t}\n\n\tskb_queue_head_init(&data->pending);\n\n\tSET_IEEE80211_DEV(hw, data->dev);\n\teth_zero_addr(addr);\n\taddr[0] = 0x02;\n\taddr[3] = idx >> 8;\n\taddr[4] = idx;\n\tmemcpy(data->addresses[0].addr, addr, ETH_ALEN);\n\tmemcpy(data->addresses[1].addr, addr, ETH_ALEN);\n\tdata->addresses[1].addr[0] |= 0x40;\n\thw->wiphy->n_addresses = 2;\n\thw->wiphy->addresses = data->addresses;\n\n\tdata->channels = param->channels;\n\tdata->use_chanctx = param->use_chanctx;\n\tdata->idx = idx;\n\tdata->destroy_on_close = param->destroy_on_close;\n\tif (info)\n\t\tdata->portid = info->snd_portid;\n\n\tif (data->use_chanctx) {\n\t\thw->wiphy->max_scan_ssids = 255;\n\t\thw->wiphy->max_scan_ie_len = IEEE80211_MAX_DATA_LEN;\n\t\thw->wiphy->max_remain_on_channel_duration = 1000;\n\t\thw->wiphy->iface_combinations = &data->if_combination;\n\t\tif (param->p2p_device)\n\t\t\tdata->if_combination = hwsim_if_comb_p2p_dev[0];\n\t\telse\n\t\t\tdata->if_combination = hwsim_if_comb[0];\n\t\thw->wiphy->n_iface_combinations = 1;\n\t\t/* For channels > 1 DFS is not allowed */\n\t\tdata->if_combination.radar_detect_widths = 0;\n\t\tdata->if_combination.num_different_channels = data->channels;\n\t} else if (param->p2p_device) {\n\t\thw->wiphy->iface_combinations = hwsim_if_comb_p2p_dev;\n\t\thw->wiphy->n_iface_combinations =\n\t\t\tARRAY_SIZE(hwsim_if_comb_p2p_dev);\n\t} else {\n\t\thw->wiphy->iface_combinations = hwsim_if_comb;\n\t\thw->wiphy->n_iface_combinations = ARRAY_SIZE(hwsim_if_comb);\n\t}\n\n\tINIT_DELAYED_WORK(&data->roc_start, hw_roc_start);\n\tINIT_DELAYED_WORK(&data->roc_done, hw_roc_done);\n\tINIT_DELAYED_WORK(&data->hw_scan, hw_scan_work);\n\n\thw->queues = 5;\n\thw->offchannel_tx_hw_queue = 4;\n\thw->wiphy->interface_modes = BIT(NL80211_IFTYPE_STATION) |\n\t\t\t\t     BIT(NL80211_IFTYPE_AP) |\n\t\t\t\t     BIT(NL80211_IFTYPE_P2P_CLIENT) |\n\t\t\t\t     BIT(NL80211_IFTYPE_P2P_GO) |\n\t\t\t\t     BIT(NL80211_IFTYPE_ADHOC) |\n\t\t\t\t     BIT(NL80211_IFTYPE_MESH_POINT);\n\n\tif (param->p2p_device)\n\t\thw->wiphy->interface_modes |= BIT(NL80211_IFTYPE_P2P_DEVICE);\n\n\tieee80211_hw_set(hw, SUPPORT_FAST_XMIT);\n\tieee80211_hw_set(hw, CHANCTX_STA_CSA);\n\tieee80211_hw_set(hw, SUPPORTS_HT_CCK_RATES);\n\tieee80211_hw_set(hw, QUEUE_CONTROL);\n\tieee80211_hw_set(hw, WANT_MONITOR_VIF);\n\tieee80211_hw_set(hw, AMPDU_AGGREGATION);\n\tieee80211_hw_set(hw, MFP_CAPABLE);\n\tieee80211_hw_set(hw, SIGNAL_DBM);\n\tieee80211_hw_set(hw, TDLS_WIDER_BW);\n\tif (rctbl)\n\t\tieee80211_hw_set(hw, SUPPORTS_RC_TABLE);\n\n\thw->wiphy->flags |= WIPHY_FLAG_SUPPORTS_TDLS |\n\t\t\t    WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL |\n\t\t\t    WIPHY_FLAG_AP_UAPSD |\n\t\t\t    WIPHY_FLAG_HAS_CHANNEL_SWITCH;\n\thw->wiphy->features |= NL80211_FEATURE_ACTIVE_MONITOR |\n\t\t\t       NL80211_FEATURE_AP_MODE_CHAN_WIDTH_CHANGE |\n\t\t\t       NL80211_FEATURE_STATIC_SMPS |\n\t\t\t       NL80211_FEATURE_DYNAMIC_SMPS |\n\t\t\t       NL80211_FEATURE_SCAN_RANDOM_MAC_ADDR;\n\twiphy_ext_feature_set(hw->wiphy, NL80211_EXT_FEATURE_VHT_IBSS);\n\n\t/* ask mac80211 to reserve space for magic */\n\thw->vif_data_size = sizeof(struct hwsim_vif_priv);\n\thw->sta_data_size = sizeof(struct hwsim_sta_priv);\n\thw->chanctx_data_size = sizeof(struct hwsim_chanctx_priv);\n\n\tmemcpy(data->channels_2ghz, hwsim_channels_2ghz,\n\t\tsizeof(hwsim_channels_2ghz));\n\tmemcpy(data->channels_5ghz, hwsim_channels_5ghz,\n\t\tsizeof(hwsim_channels_5ghz));\n\tmemcpy(data->rates, hwsim_rates, sizeof(hwsim_rates));\n\n\tfor (band = NL80211_BAND_2GHZ; band < NUM_NL80211_BANDS; band++) {\n\t\tstruct ieee80211_supported_band *sband = &data->bands[band];\n\t\tswitch (band) {\n\t\tcase NL80211_BAND_2GHZ:\n\t\t\tsband->channels = data->channels_2ghz;\n\t\t\tsband->n_channels = ARRAY_SIZE(hwsim_channels_2ghz);\n\t\t\tsband->bitrates = data->rates;\n\t\t\tsband->n_bitrates = ARRAY_SIZE(hwsim_rates);\n\t\t\tbreak;\n\t\tcase NL80211_BAND_5GHZ:\n\t\t\tsband->channels = data->channels_5ghz;\n\t\t\tsband->n_channels = ARRAY_SIZE(hwsim_channels_5ghz);\n\t\t\tsband->bitrates = data->rates + 4;\n\t\t\tsband->n_bitrates = ARRAY_SIZE(hwsim_rates) - 4;\n\n\t\t\tsband->vht_cap.vht_supported = true;\n\t\t\tsband->vht_cap.cap =\n\t\t\t\tIEEE80211_VHT_CAP_MAX_MPDU_LENGTH_11454 |\n\t\t\t\tIEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160_80PLUS80MHZ |\n\t\t\t\tIEEE80211_VHT_CAP_RXLDPC |\n\t\t\t\tIEEE80211_VHT_CAP_SHORT_GI_80 |\n\t\t\t\tIEEE80211_VHT_CAP_SHORT_GI_160 |\n\t\t\t\tIEEE80211_VHT_CAP_TXSTBC |\n\t\t\t\tIEEE80211_VHT_CAP_RXSTBC_1 |\n\t\t\t\tIEEE80211_VHT_CAP_RXSTBC_2 |\n\t\t\t\tIEEE80211_VHT_CAP_RXSTBC_3 |\n\t\t\t\tIEEE80211_VHT_CAP_RXSTBC_4 |\n\t\t\t\tIEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_MASK;\n\t\t\tsband->vht_cap.vht_mcs.rx_mcs_map =\n\t\t\t\tcpu_to_le16(IEEE80211_VHT_MCS_SUPPORT_0_9 << 0 |\n\t\t\t\t\t    IEEE80211_VHT_MCS_SUPPORT_0_9 << 2 |\n\t\t\t\t\t    IEEE80211_VHT_MCS_SUPPORT_0_9 << 4 |\n\t\t\t\t\t    IEEE80211_VHT_MCS_SUPPORT_0_9 << 6 |\n\t\t\t\t\t    IEEE80211_VHT_MCS_SUPPORT_0_9 << 8 |\n\t\t\t\t\t    IEEE80211_VHT_MCS_SUPPORT_0_9 << 10 |\n\t\t\t\t\t    IEEE80211_VHT_MCS_SUPPORT_0_9 << 12 |\n\t\t\t\t\t    IEEE80211_VHT_MCS_SUPPORT_0_9 << 14);\n\t\t\tsband->vht_cap.vht_mcs.tx_mcs_map =\n\t\t\t\tsband->vht_cap.vht_mcs.rx_mcs_map;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\n\t\tsband->ht_cap.ht_supported = true;\n\t\tsband->ht_cap.cap = IEEE80211_HT_CAP_SUP_WIDTH_20_40 |\n\t\t\t\t    IEEE80211_HT_CAP_GRN_FLD |\n\t\t\t\t    IEEE80211_HT_CAP_SGI_20 |\n\t\t\t\t    IEEE80211_HT_CAP_SGI_40 |\n\t\t\t\t    IEEE80211_HT_CAP_DSSSCCK40;\n\t\tsband->ht_cap.ampdu_factor = 0x3;\n\t\tsband->ht_cap.ampdu_density = 0x6;\n\t\tmemset(&sband->ht_cap.mcs, 0,\n\t\t       sizeof(sband->ht_cap.mcs));\n\t\tsband->ht_cap.mcs.rx_mask[0] = 0xff;\n\t\tsband->ht_cap.mcs.rx_mask[1] = 0xff;\n\t\tsband->ht_cap.mcs.tx_params = IEEE80211_HT_MCS_TX_DEFINED;\n\n\t\thw->wiphy->bands[band] = sband;\n\t}\n\n\t/* By default all radios belong to the first group */\n\tdata->group = 1;\n\tmutex_init(&data->mutex);\n\n\tdata->netgroup = hwsim_net_get_netgroup(net);\n\n\t/* Enable frame retransmissions for lossy channels */\n\thw->max_rates = 4;\n\thw->max_rate_tries = 11;\n\n\thw->wiphy->vendor_commands = mac80211_hwsim_vendor_commands;\n\thw->wiphy->n_vendor_commands =\n\t\tARRAY_SIZE(mac80211_hwsim_vendor_commands);\n\thw->wiphy->vendor_events = mac80211_hwsim_vendor_events;\n\thw->wiphy->n_vendor_events = ARRAY_SIZE(mac80211_hwsim_vendor_events);\n\n\tif (param->reg_strict)\n\t\thw->wiphy->regulatory_flags |= REGULATORY_STRICT_REG;\n\tif (param->regd) {\n\t\tdata->regd = param->regd;\n\t\thw->wiphy->regulatory_flags |= REGULATORY_CUSTOM_REG;\n\t\twiphy_apply_custom_regulatory(hw->wiphy, param->regd);\n\t\t/* give the regulatory workqueue a chance to run */\n\t\tschedule_timeout_interruptible(1);\n\t}\n\n\tif (param->no_vif)\n\t\tieee80211_hw_set(hw, NO_AUTO_VIF);\n\n\twiphy_ext_feature_set(hw->wiphy, NL80211_EXT_FEATURE_CQM_RSSI_LIST);\n\n\terr = ieee80211_register_hw(hw);\n\tif (err < 0) {\n\t\tpr_debug(\"mac80211_hwsim: ieee80211_register_hw failed (%d)\\n\",\n\t\t       err);\n\t\tgoto failed_hw;\n\t}\n\n\twiphy_dbg(hw->wiphy, \"hwaddr %pM registered\\n\", hw->wiphy->perm_addr);\n\n\tif (param->reg_alpha2) {\n\t\tdata->alpha2[0] = param->reg_alpha2[0];\n\t\tdata->alpha2[1] = param->reg_alpha2[1];\n\t\tregulatory_hint(hw->wiphy, param->reg_alpha2);\n\t}\n\n\tdata->debugfs = debugfs_create_dir(\"hwsim\", hw->wiphy->debugfsdir);\n\tdebugfs_create_file(\"ps\", 0666, data->debugfs, data, &hwsim_fops_ps);\n\tdebugfs_create_file(\"group\", 0666, data->debugfs, data,\n\t\t\t    &hwsim_fops_group);\n\tif (!data->use_chanctx)\n\t\tdebugfs_create_file(\"dfs_simulate_radar\", 0222,\n\t\t\t\t    data->debugfs,\n\t\t\t\t    data, &hwsim_simulate_radar);\n\n\ttasklet_hrtimer_init(&data->beacon_timer,\n\t\t\t     mac80211_hwsim_beacon,\n\t\t\t     CLOCK_MONOTONIC, HRTIMER_MODE_ABS);\n\n\tspin_lock_bh(&hwsim_radio_lock);\n\terr = rhashtable_insert_fast(&hwsim_radios_rht, &data->rht,\n\t\t\t\t     hwsim_rht_params);\n\tif (err < 0) {\n\t\tpr_debug(\"mac80211_hwsim: radio index %d already present\\n\",\n\t\t\t idx);\n\t\tspin_unlock_bh(&hwsim_radio_lock);\n\t\tgoto failed_final_insert;\n\t}\n\n\tlist_add_tail(&data->list, &hwsim_radios);\n\tspin_unlock_bh(&hwsim_radio_lock);\n\n\tif (idx > 0)\n\t\thwsim_mcast_new_radio(idx, info, param);\n\n\treturn idx;\n\nfailed_final_insert:\n\tdebugfs_remove_recursive(data->debugfs);\n\tieee80211_unregister_hw(data->hw);\nfailed_hw:\n\tdevice_release_driver(data->dev);\nfailed_bind:\n\tdevice_unregister(data->dev);\nfailed_drvdata:\n\tieee80211_free_hw(hw);\nfailed:\n\treturn err;\n}\n\nstatic void hwsim_mcast_del_radio(int id, const char *hwname,\n\t\t\t\t  struct genl_info *info)\n{\n\tstruct sk_buff *skb;\n\tvoid *data;\n\tint ret;\n\n\tskb = genlmsg_new(GENLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!skb)\n\t\treturn;\n\n\tdata = genlmsg_put(skb, 0, 0, &hwsim_genl_family, 0,\n\t\t\t   HWSIM_CMD_DEL_RADIO);\n\tif (!data)\n\t\tgoto error;\n\n\tret = nla_put_u32(skb, HWSIM_ATTR_RADIO_ID, id);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tret = nla_put(skb, HWSIM_ATTR_RADIO_NAME, strlen(hwname),\n\t\t      hwname);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tgenlmsg_end(skb, data);\n\n\thwsim_mcast_config_msg(skb, info);\n\n\treturn;\n\nerror:\n\tnlmsg_free(skb);\n}\n\nstatic void mac80211_hwsim_del_radio(struct mac80211_hwsim_data *data,\n\t\t\t\t     const char *hwname,\n\t\t\t\t     struct genl_info *info)\n{\n\thwsim_mcast_del_radio(data->idx, hwname, info);\n\tdebugfs_remove_recursive(data->debugfs);\n\tieee80211_unregister_hw(data->hw);\n\tdevice_release_driver(data->dev);\n\tdevice_unregister(data->dev);\n\tieee80211_free_hw(data->hw);\n}\n\nstatic int mac80211_hwsim_get_radio(struct sk_buff *skb,\n\t\t\t\t    struct mac80211_hwsim_data *data,\n\t\t\t\t    u32 portid, u32 seq,\n\t\t\t\t    struct netlink_callback *cb, int flags)\n{\n\tvoid *hdr;\n\tstruct hwsim_new_radio_params param = { };\n\tint res = -EMSGSIZE;\n\n\thdr = genlmsg_put(skb, portid, seq, &hwsim_genl_family, flags,\n\t\t\t  HWSIM_CMD_GET_RADIO);\n\tif (!hdr)\n\t\treturn -EMSGSIZE;\n\n\tif (cb)\n\t\tgenl_dump_check_consistent(cb, hdr);\n\n\tif (data->alpha2[0] && data->alpha2[1])\n\t\tparam.reg_alpha2 = data->alpha2;\n\n\tparam.reg_strict = !!(data->hw->wiphy->regulatory_flags &\n\t\t\t\t\tREGULATORY_STRICT_REG);\n\tparam.p2p_device = !!(data->hw->wiphy->interface_modes &\n\t\t\t\t\tBIT(NL80211_IFTYPE_P2P_DEVICE));\n\tparam.use_chanctx = data->use_chanctx;\n\tparam.regd = data->regd;\n\tparam.channels = data->channels;\n\tparam.hwname = wiphy_name(data->hw->wiphy);\n\n\tres = append_radio_msg(skb, data->idx, &param);\n\tif (res < 0)\n\t\tgoto out_err;\n\n\tgenlmsg_end(skb, hdr);\n\treturn 0;\n\nout_err:\n\tgenlmsg_cancel(skb, hdr);\n\treturn res;\n}\n\nstatic void mac80211_hwsim_free(void)\n{\n\tstruct mac80211_hwsim_data *data;\n\n\tspin_lock_bh(&hwsim_radio_lock);\n\twhile ((data = list_first_entry_or_null(&hwsim_radios,\n\t\t\t\t\t\tstruct mac80211_hwsim_data,\n\t\t\t\t\t\tlist))) {\n\t\tlist_del(&data->list);\n\t\tspin_unlock_bh(&hwsim_radio_lock);\n\t\tmac80211_hwsim_del_radio(data, wiphy_name(data->hw->wiphy),\n\t\t\t\t\t NULL);\n\t\tspin_lock_bh(&hwsim_radio_lock);\n\t}\n\tspin_unlock_bh(&hwsim_radio_lock);\n\tclass_destroy(hwsim_class);\n}\n\nstatic const struct net_device_ops hwsim_netdev_ops = {\n\t.ndo_start_xmit \t= hwsim_mon_xmit,\n\t.ndo_set_mac_address \t= eth_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\nstatic void hwsim_mon_setup(struct net_device *dev)\n{\n\tdev->netdev_ops = &hwsim_netdev_ops;\n\tdev->needs_free_netdev = true;\n\tether_setup(dev);\n\tdev->priv_flags |= IFF_NO_QUEUE;\n\tdev->type = ARPHRD_IEEE80211_RADIOTAP;\n\teth_zero_addr(dev->dev_addr);\n\tdev->dev_addr[0] = 0x12;\n}\n\nstatic struct mac80211_hwsim_data *get_hwsim_data_ref_from_addr(const u8 *addr)\n{\n\treturn rhashtable_lookup_fast(&hwsim_radios_rht,\n\t\t\t\t      addr,\n\t\t\t\t      hwsim_rht_params);\n}\n\nstatic void hwsim_register_wmediumd(struct net *net, u32 portid)\n{\n\tstruct mac80211_hwsim_data *data;\n\n\thwsim_net_set_wmediumd(net, portid);\n\n\tspin_lock_bh(&hwsim_radio_lock);\n\tlist_for_each_entry(data, &hwsim_radios, list) {\n\t\tif (data->netgroup == hwsim_net_get_netgroup(net))\n\t\t\tdata->wmediumd = portid;\n\t}\n\tspin_unlock_bh(&hwsim_radio_lock);\n}\n\nstatic int hwsim_tx_info_frame_received_nl(struct sk_buff *skb_2,\n\t\t\t\t\t   struct genl_info *info)\n{\n\n\tstruct ieee80211_hdr *hdr;\n\tstruct mac80211_hwsim_data *data2;\n\tstruct ieee80211_tx_info *txi;\n\tstruct hwsim_tx_rate *tx_attempts;\n\tu64 ret_skb_cookie;\n\tstruct sk_buff *skb, *tmp;\n\tconst u8 *src;\n\tunsigned int hwsim_flags;\n\tint i;\n\tbool found = false;\n\n\tif (!info->attrs[HWSIM_ATTR_ADDR_TRANSMITTER] ||\n\t    !info->attrs[HWSIM_ATTR_FLAGS] ||\n\t    !info->attrs[HWSIM_ATTR_COOKIE] ||\n\t    !info->attrs[HWSIM_ATTR_SIGNAL] ||\n\t    !info->attrs[HWSIM_ATTR_TX_INFO])\n\t\tgoto out;\n\n\tsrc = (void *)nla_data(info->attrs[HWSIM_ATTR_ADDR_TRANSMITTER]);\n\thwsim_flags = nla_get_u32(info->attrs[HWSIM_ATTR_FLAGS]);\n\tret_skb_cookie = nla_get_u64(info->attrs[HWSIM_ATTR_COOKIE]);\n\n\tdata2 = get_hwsim_data_ref_from_addr(src);\n\tif (!data2)\n\t\tgoto out;\n\n\tif (hwsim_net_get_netgroup(genl_info_net(info)) != data2->netgroup)\n\t\tgoto out;\n\n\tif (info->snd_portid != data2->wmediumd)\n\t\tgoto out;\n\n\t/* look for the skb matching the cookie passed back from user */\n\tskb_queue_walk_safe(&data2->pending, skb, tmp) {\n\t\tu64 skb_cookie;\n\n\t\ttxi = IEEE80211_SKB_CB(skb);\n\t\tskb_cookie = (u64)(uintptr_t)txi->rate_driver_data[0];\n\n\t\tif (skb_cookie == ret_skb_cookie) {\n\t\t\tskb_unlink(skb, &data2->pending);\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* not found */\n\tif (!found)\n\t\tgoto out;\n\n\t/* Tx info received because the frame was broadcasted on user space,\n\t so we get all the necessary info: tx attempts and skb control buff */\n\n\ttx_attempts = (struct hwsim_tx_rate *)nla_data(\n\t\t       info->attrs[HWSIM_ATTR_TX_INFO]);\n\n\t/* now send back TX status */\n\ttxi = IEEE80211_SKB_CB(skb);\n\n\tieee80211_tx_info_clear_status(txi);\n\n\tfor (i = 0; i < IEEE80211_TX_MAX_RATES; i++) {\n\t\ttxi->status.rates[i].idx = tx_attempts[i].idx;\n\t\ttxi->status.rates[i].count = tx_attempts[i].count;\n\t}\n\n\ttxi->status.ack_signal = nla_get_u32(info->attrs[HWSIM_ATTR_SIGNAL]);\n\n\tif (!(hwsim_flags & HWSIM_TX_CTL_NO_ACK) &&\n\t   (hwsim_flags & HWSIM_TX_STAT_ACK)) {\n\t\tif (skb->len >= 16) {\n\t\t\thdr = (struct ieee80211_hdr *) skb->data;\n\t\t\tmac80211_hwsim_monitor_ack(data2->channel,\n\t\t\t\t\t\t   hdr->addr2);\n\t\t}\n\t\ttxi->flags |= IEEE80211_TX_STAT_ACK;\n\t}\n\tieee80211_tx_status_irqsafe(data2->hw, skb);\n\treturn 0;\nout:\n\treturn -EINVAL;\n\n}\n\nstatic int hwsim_cloned_frame_received_nl(struct sk_buff *skb_2,\n\t\t\t\t\t  struct genl_info *info)\n{\n\tstruct mac80211_hwsim_data *data2;\n\tstruct ieee80211_rx_status rx_status;\n\tconst u8 *dst;\n\tint frame_data_len;\n\tvoid *frame_data;\n\tstruct sk_buff *skb = NULL;\n\n\tif (!info->attrs[HWSIM_ATTR_ADDR_RECEIVER] ||\n\t    !info->attrs[HWSIM_ATTR_FRAME] ||\n\t    !info->attrs[HWSIM_ATTR_RX_RATE] ||\n\t    !info->attrs[HWSIM_ATTR_SIGNAL])\n\t\tgoto out;\n\n\tdst = (void *)nla_data(info->attrs[HWSIM_ATTR_ADDR_RECEIVER]);\n\tframe_data_len = nla_len(info->attrs[HWSIM_ATTR_FRAME]);\n\tframe_data = (void *)nla_data(info->attrs[HWSIM_ATTR_FRAME]);\n\n\t/* Allocate new skb here */\n\tskb = alloc_skb(frame_data_len, GFP_KERNEL);\n\tif (skb == NULL)\n\t\tgoto err;\n\n\tif (frame_data_len > IEEE80211_MAX_DATA_LEN)\n\t\tgoto err;\n\n\t/* Copy the data */\n\tskb_put_data(skb, frame_data, frame_data_len);\n\n\tdata2 = get_hwsim_data_ref_from_addr(dst);\n\tif (!data2)\n\t\tgoto out;\n\n\tif (hwsim_net_get_netgroup(genl_info_net(info)) != data2->netgroup)\n\t\tgoto out;\n\n\tif (info->snd_portid != data2->wmediumd)\n\t\tgoto out;\n\n\t/* check if radio is configured properly */\n\n\tif (data2->idle || !data2->started)\n\t\tgoto out;\n\n\t/* A frame is received from user space */\n\tmemset(&rx_status, 0, sizeof(rx_status));\n\tif (info->attrs[HWSIM_ATTR_FREQ]) {\n\t\t/* throw away off-channel packets, but allow both the temporary\n\t\t * (\"hw\" scan/remain-on-channel) and regular channel, since the\n\t\t * internal datapath also allows this\n\t\t */\n\t\tmutex_lock(&data2->mutex);\n\t\trx_status.freq = nla_get_u32(info->attrs[HWSIM_ATTR_FREQ]);\n\n\t\tif (rx_status.freq != data2->channel->center_freq &&\n\t\t    (!data2->tmp_chan ||\n\t\t     rx_status.freq != data2->tmp_chan->center_freq)) {\n\t\t\tmutex_unlock(&data2->mutex);\n\t\t\tgoto out;\n\t\t}\n\t\tmutex_unlock(&data2->mutex);\n\t} else {\n\t\trx_status.freq = data2->channel->center_freq;\n\t}\n\n\trx_status.band = data2->channel->band;\n\trx_status.rate_idx = nla_get_u32(info->attrs[HWSIM_ATTR_RX_RATE]);\n\trx_status.signal = nla_get_u32(info->attrs[HWSIM_ATTR_SIGNAL]);\n\n\tmemcpy(IEEE80211_SKB_RXCB(skb), &rx_status, sizeof(rx_status));\n\tdata2->rx_pkts++;\n\tdata2->rx_bytes += skb->len;\n\tieee80211_rx_irqsafe(data2->hw, skb);\n\n\treturn 0;\nerr:\n\tpr_debug(\"mac80211_hwsim: error occurred in %s\\n\", __func__);\nout:\n\tdev_kfree_skb(skb);\n\treturn -EINVAL;\n}\n\nstatic int hwsim_register_received_nl(struct sk_buff *skb_2,\n\t\t\t\t      struct genl_info *info)\n{\n\tstruct net *net = genl_info_net(info);\n\tstruct mac80211_hwsim_data *data;\n\tint chans = 1;\n\n\tspin_lock_bh(&hwsim_radio_lock);\n\tlist_for_each_entry(data, &hwsim_radios, list)\n\t\tchans = max(chans, data->channels);\n\tspin_unlock_bh(&hwsim_radio_lock);\n\n\t/* In the future we should revise the userspace API and allow it\n\t * to set a flag that it does support multi-channel, then we can\n\t * let this pass conditionally on the flag.\n\t * For current userspace, prohibit it since it won't work right.\n\t */\n\tif (chans > 1)\n\t\treturn -EOPNOTSUPP;\n\n\tif (hwsim_net_get_wmediumd(net))\n\t\treturn -EBUSY;\n\n\thwsim_register_wmediumd(net, info->snd_portid);\n\n\tpr_debug(\"mac80211_hwsim: received a REGISTER, \"\n\t       \"switching to wmediumd mode with pid %d\\n\", info->snd_portid);\n\n\treturn 0;\n}\n\nstatic int hwsim_new_radio_nl(struct sk_buff *msg, struct genl_info *info)\n{\n\tstruct hwsim_new_radio_params param = { 0 };\n\tconst char *hwname = NULL;\n\tint ret;\n\n\tparam.reg_strict = info->attrs[HWSIM_ATTR_REG_STRICT_REG];\n\tparam.p2p_device = info->attrs[HWSIM_ATTR_SUPPORT_P2P_DEVICE];\n\tparam.channels = channels;\n\tparam.destroy_on_close =\n\t\tinfo->attrs[HWSIM_ATTR_DESTROY_RADIO_ON_CLOSE];\n\n\tif (info->attrs[HWSIM_ATTR_CHANNELS])\n\t\tparam.channels = nla_get_u32(info->attrs[HWSIM_ATTR_CHANNELS]);\n\n\tif (info->attrs[HWSIM_ATTR_NO_VIF])\n\t\tparam.no_vif = true;\n\n\tif (info->attrs[HWSIM_ATTR_RADIO_NAME]) {\n\t\thwname = kasprintf(GFP_KERNEL, \"%.*s\",\n\t\t\t\t   nla_len(info->attrs[HWSIM_ATTR_RADIO_NAME]),\n\t\t\t\t   (char *)nla_data(info->attrs[HWSIM_ATTR_RADIO_NAME]));\n\t\tif (!hwname)\n\t\t\treturn -ENOMEM;\n\t\tparam.hwname = hwname;\n\t}\n\n\tif (info->attrs[HWSIM_ATTR_USE_CHANCTX])\n\t\tparam.use_chanctx = true;\n\telse\n\t\tparam.use_chanctx = (param.channels > 1);\n\n\tif (info->attrs[HWSIM_ATTR_REG_HINT_ALPHA2])\n\t\tparam.reg_alpha2 =\n\t\t\tnla_data(info->attrs[HWSIM_ATTR_REG_HINT_ALPHA2]);\n\n\tif (info->attrs[HWSIM_ATTR_REG_CUSTOM_REG]) {\n\t\tu32 idx = nla_get_u32(info->attrs[HWSIM_ATTR_REG_CUSTOM_REG]);\n\n\t\tif (idx >= ARRAY_SIZE(hwsim_world_regdom_custom)) {\n\t\t\tkfree(hwname);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tparam.regd = hwsim_world_regdom_custom[idx];\n\t}\n\n\tret = mac80211_hwsim_new_radio(info, &param);\n\tkfree(hwname);\n\treturn ret;\n}\n\nstatic int hwsim_del_radio_nl(struct sk_buff *msg, struct genl_info *info)\n{\n\tstruct mac80211_hwsim_data *data;\n\ts64 idx = -1;\n\tconst char *hwname = NULL;\n\n\tif (info->attrs[HWSIM_ATTR_RADIO_ID]) {\n\t\tidx = nla_get_u32(info->attrs[HWSIM_ATTR_RADIO_ID]);\n\t} else if (info->attrs[HWSIM_ATTR_RADIO_NAME]) {\n\t\thwname = kasprintf(GFP_KERNEL, \"%.*s\",\n\t\t\t\t   nla_len(info->attrs[HWSIM_ATTR_RADIO_NAME]),\n\t\t\t\t   (char *)nla_data(info->attrs[HWSIM_ATTR_RADIO_NAME]));\n\t\tif (!hwname)\n\t\t\treturn -ENOMEM;\n\t} else\n\t\treturn -EINVAL;\n\n\tspin_lock_bh(&hwsim_radio_lock);\n\tlist_for_each_entry(data, &hwsim_radios, list) {\n\t\tif (idx >= 0) {\n\t\t\tif (data->idx != idx)\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\tif (!hwname ||\n\t\t\t    strcmp(hwname, wiphy_name(data->hw->wiphy)))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (!net_eq(wiphy_net(data->hw->wiphy), genl_info_net(info)))\n\t\t\tcontinue;\n\n\t\tlist_del(&data->list);\n\t\trhashtable_remove_fast(&hwsim_radios_rht, &data->rht,\n\t\t\t\t       hwsim_rht_params);\n\t\tspin_unlock_bh(&hwsim_radio_lock);\n\t\tmac80211_hwsim_del_radio(data, wiphy_name(data->hw->wiphy),\n\t\t\t\t\t info);\n\t\tkfree(hwname);\n\t\treturn 0;\n\t}\n\tspin_unlock_bh(&hwsim_radio_lock);\n\n\tkfree(hwname);\n\treturn -ENODEV;\n}\n\nstatic int hwsim_get_radio_nl(struct sk_buff *msg, struct genl_info *info)\n{\n\tstruct mac80211_hwsim_data *data;\n\tstruct sk_buff *skb;\n\tint idx, res = -ENODEV;\n\n\tif (!info->attrs[HWSIM_ATTR_RADIO_ID])\n\t\treturn -EINVAL;\n\tidx = nla_get_u32(info->attrs[HWSIM_ATTR_RADIO_ID]);\n\n\tspin_lock_bh(&hwsim_radio_lock);\n\tlist_for_each_entry(data, &hwsim_radios, list) {\n\t\tif (data->idx != idx)\n\t\t\tcontinue;\n\n\t\tif (!net_eq(wiphy_net(data->hw->wiphy), genl_info_net(info)))\n\t\t\tcontinue;\n\n\t\tskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\n\t\tif (!skb) {\n\t\t\tres = -ENOMEM;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tres = mac80211_hwsim_get_radio(skb, data, info->snd_portid,\n\t\t\t\t\t       info->snd_seq, NULL, 0);\n\t\tif (res < 0) {\n\t\t\tnlmsg_free(skb);\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tgenlmsg_reply(skb, info);\n\t\tbreak;\n\t}\n\nout_err:\n\tspin_unlock_bh(&hwsim_radio_lock);\n\n\treturn res;\n}\n\nstatic int hwsim_dump_radio_nl(struct sk_buff *skb,\n\t\t\t       struct netlink_callback *cb)\n{\n\tint idx = cb->args[0];\n\tstruct mac80211_hwsim_data *data = NULL;\n\tint res;\n\n\tspin_lock_bh(&hwsim_radio_lock);\n\n\tif (idx == hwsim_radio_idx)\n\t\tgoto done;\n\n\tlist_for_each_entry(data, &hwsim_radios, list) {\n\t\tif (data->idx < idx)\n\t\t\tcontinue;\n\n\t\tif (!net_eq(wiphy_net(data->hw->wiphy), sock_net(skb->sk)))\n\t\t\tcontinue;\n\n\t\tres = mac80211_hwsim_get_radio(skb, data,\n\t\t\t\t\t       NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t       cb->nlh->nlmsg_seq, cb,\n\t\t\t\t\t       NLM_F_MULTI);\n\t\tif (res < 0)\n\t\t\tbreak;\n\n\t\tidx = data->idx + 1;\n\t}\n\n\tcb->args[0] = idx;\n\ndone:\n\tspin_unlock_bh(&hwsim_radio_lock);\n\treturn skb->len;\n}\n\n/* Generic Netlink operations array */\nstatic const struct genl_ops hwsim_ops[] = {\n\t{\n\t\t.cmd = HWSIM_CMD_REGISTER,\n\t\t.policy = hwsim_genl_policy,\n\t\t.doit = hwsim_register_received_nl,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = HWSIM_CMD_FRAME,\n\t\t.policy = hwsim_genl_policy,\n\t\t.doit = hwsim_cloned_frame_received_nl,\n\t},\n\t{\n\t\t.cmd = HWSIM_CMD_TX_INFO_FRAME,\n\t\t.policy = hwsim_genl_policy,\n\t\t.doit = hwsim_tx_info_frame_received_nl,\n\t},\n\t{\n\t\t.cmd = HWSIM_CMD_NEW_RADIO,\n\t\t.policy = hwsim_genl_policy,\n\t\t.doit = hwsim_new_radio_nl,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = HWSIM_CMD_DEL_RADIO,\n\t\t.policy = hwsim_genl_policy,\n\t\t.doit = hwsim_del_radio_nl,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = HWSIM_CMD_GET_RADIO,\n\t\t.policy = hwsim_genl_policy,\n\t\t.doit = hwsim_get_radio_nl,\n\t\t.dumpit = hwsim_dump_radio_nl,\n\t},\n};\n\nstatic struct genl_family hwsim_genl_family __ro_after_init = {\n\t.name = \"MAC80211_HWSIM\",\n\t.version = 1,\n\t.maxattr = HWSIM_ATTR_MAX,\n\t.netnsok = true,\n\t.module = THIS_MODULE,\n\t.ops = hwsim_ops,\n\t.n_ops = ARRAY_SIZE(hwsim_ops),\n\t.mcgrps = hwsim_mcgrps,\n\t.n_mcgrps = ARRAY_SIZE(hwsim_mcgrps),\n};\n\nstatic void destroy_radio(struct work_struct *work)\n{\n\tstruct mac80211_hwsim_data *data =\n\t\tcontainer_of(work, struct mac80211_hwsim_data, destroy_work);\n\n\tmac80211_hwsim_del_radio(data, wiphy_name(data->hw->wiphy), NULL);\n}\n\nstatic void remove_user_radios(u32 portid)\n{\n\tstruct mac80211_hwsim_data *entry, *tmp;\n\n\tspin_lock_bh(&hwsim_radio_lock);\n\tlist_for_each_entry_safe(entry, tmp, &hwsim_radios, list) {\n\t\tif (entry->destroy_on_close && entry->portid == portid) {\n\t\t\tlist_del(&entry->list);\n\t\t\trhashtable_remove_fast(&hwsim_radios_rht, &entry->rht,\n\t\t\t\t\t       hwsim_rht_params);\n\t\t\tINIT_WORK(&entry->destroy_work, destroy_radio);\n\t\t\tschedule_work(&entry->destroy_work);\n\t\t}\n\t}\n\tspin_unlock_bh(&hwsim_radio_lock);\n}\n\nstatic int mac80211_hwsim_netlink_notify(struct notifier_block *nb,\n\t\t\t\t\t unsigned long state,\n\t\t\t\t\t void *_notify)\n{\n\tstruct netlink_notify *notify = _notify;\n\n\tif (state != NETLINK_URELEASE)\n\t\treturn NOTIFY_DONE;\n\n\tremove_user_radios(notify->portid);\n\n\tif (notify->portid == hwsim_net_get_wmediumd(notify->net)) {\n\t\tprintk(KERN_INFO \"mac80211_hwsim: wmediumd released netlink\"\n\t\t       \" socket, switching to perfect channel medium\\n\");\n\t\thwsim_register_wmediumd(notify->net, 0);\n\t}\n\treturn NOTIFY_DONE;\n\n}\n\nstatic struct notifier_block hwsim_netlink_notifier = {\n\t.notifier_call = mac80211_hwsim_netlink_notify,\n};\n\nstatic int __init hwsim_init_netlink(void)\n{\n\tint rc;\n\n\tprintk(KERN_INFO \"mac80211_hwsim: initializing netlink\\n\");\n\n\trc = genl_register_family(&hwsim_genl_family);\n\tif (rc)\n\t\tgoto failure;\n\n\trc = netlink_register_notifier(&hwsim_netlink_notifier);\n\tif (rc) {\n\t\tgenl_unregister_family(&hwsim_genl_family);\n\t\tgoto failure;\n\t}\n\n\treturn 0;\n\nfailure:\n\tpr_debug(\"mac80211_hwsim: error occurred in %s\\n\", __func__);\n\treturn -EINVAL;\n}\n\nstatic __net_init int hwsim_init_net(struct net *net)\n{\n\thwsim_net_set_netgroup(net);\n\n\treturn 0;\n}\n\nstatic void __net_exit hwsim_exit_net(struct net *net)\n{\n\tstruct mac80211_hwsim_data *data, *tmp;\n\n\tspin_lock_bh(&hwsim_radio_lock);\n\tlist_for_each_entry_safe(data, tmp, &hwsim_radios, list) {\n\t\tif (!net_eq(wiphy_net(data->hw->wiphy), net))\n\t\t\tcontinue;\n\n\t\t/* Radios created in init_net are returned to init_net. */\n\t\tif (data->netgroup == hwsim_net_get_netgroup(&init_net))\n\t\t\tcontinue;\n\n\t\tlist_del(&data->list);\n\t\trhashtable_remove_fast(&hwsim_radios_rht, &data->rht,\n\t\t\t\t       hwsim_rht_params);\n\t\tINIT_WORK(&data->destroy_work, destroy_radio);\n\t\tschedule_work(&data->destroy_work);\n\t}\n\tspin_unlock_bh(&hwsim_radio_lock);\n}\n\nstatic struct pernet_operations hwsim_net_ops = {\n\t.init = hwsim_init_net,\n\t.exit = hwsim_exit_net,\n\t.id   = &hwsim_net_id,\n\t.size = sizeof(struct hwsim_net),\n};\n\nstatic void hwsim_exit_netlink(void)\n{\n\t/* unregister the notifier */\n\tnetlink_unregister_notifier(&hwsim_netlink_notifier);\n\t/* unregister the family */\n\tgenl_unregister_family(&hwsim_genl_family);\n}\n\nstatic int __init init_mac80211_hwsim(void)\n{\n\tint i, err;\n\n\tif (radios < 0 || radios > 100)\n\t\treturn -EINVAL;\n\n\tif (channels < 1)\n\t\treturn -EINVAL;\n\n\tspin_lock_init(&hwsim_radio_lock);\n\n\trhashtable_init(&hwsim_radios_rht, &hwsim_rht_params);\n\n\terr = register_pernet_device(&hwsim_net_ops);\n\tif (err)\n\t\treturn err;\n\n\terr = platform_driver_register(&mac80211_hwsim_driver);\n\tif (err)\n\t\tgoto out_unregister_pernet;\n\n\thwsim_class = class_create(THIS_MODULE, \"mac80211_hwsim\");\n\tif (IS_ERR(hwsim_class)) {\n\t\terr = PTR_ERR(hwsim_class);\n\t\tgoto out_unregister_driver;\n\t}\n\n\terr = hwsim_init_netlink();\n\tif (err < 0)\n\t\tgoto out_unregister_driver;\n\n\tfor (i = 0; i < radios; i++) {\n\t\tstruct hwsim_new_radio_params param = { 0 };\n\n\t\tparam.channels = channels;\n\n\t\tswitch (regtest) {\n\t\tcase HWSIM_REGTEST_DIFF_COUNTRY:\n\t\t\tif (i < ARRAY_SIZE(hwsim_alpha2s))\n\t\t\t\tparam.reg_alpha2 = hwsim_alpha2s[i];\n\t\t\tbreak;\n\t\tcase HWSIM_REGTEST_DRIVER_REG_FOLLOW:\n\t\t\tif (!i)\n\t\t\t\tparam.reg_alpha2 = hwsim_alpha2s[0];\n\t\t\tbreak;\n\t\tcase HWSIM_REGTEST_STRICT_ALL:\n\t\t\tparam.reg_strict = true;\n\t\tcase HWSIM_REGTEST_DRIVER_REG_ALL:\n\t\t\tparam.reg_alpha2 = hwsim_alpha2s[0];\n\t\t\tbreak;\n\t\tcase HWSIM_REGTEST_WORLD_ROAM:\n\t\t\tif (i == 0)\n\t\t\t\tparam.regd = &hwsim_world_regdom_custom_01;\n\t\t\tbreak;\n\t\tcase HWSIM_REGTEST_CUSTOM_WORLD:\n\t\t\tparam.regd = &hwsim_world_regdom_custom_01;\n\t\t\tbreak;\n\t\tcase HWSIM_REGTEST_CUSTOM_WORLD_2:\n\t\t\tif (i == 0)\n\t\t\t\tparam.regd = &hwsim_world_regdom_custom_01;\n\t\t\telse if (i == 1)\n\t\t\t\tparam.regd = &hwsim_world_regdom_custom_02;\n\t\t\tbreak;\n\t\tcase HWSIM_REGTEST_STRICT_FOLLOW:\n\t\t\tif (i == 0) {\n\t\t\t\tparam.reg_strict = true;\n\t\t\t\tparam.reg_alpha2 = hwsim_alpha2s[0];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase HWSIM_REGTEST_STRICT_AND_DRIVER_REG:\n\t\t\tif (i == 0) {\n\t\t\t\tparam.reg_strict = true;\n\t\t\t\tparam.reg_alpha2 = hwsim_alpha2s[0];\n\t\t\t} else if (i == 1) {\n\t\t\t\tparam.reg_alpha2 = hwsim_alpha2s[1];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase HWSIM_REGTEST_ALL:\n\t\t\tswitch (i) {\n\t\t\tcase 0:\n\t\t\t\tparam.regd = &hwsim_world_regdom_custom_01;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tparam.regd = &hwsim_world_regdom_custom_02;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tparam.reg_alpha2 = hwsim_alpha2s[0];\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tparam.reg_alpha2 = hwsim_alpha2s[1];\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tparam.reg_strict = true;\n\t\t\t\tparam.reg_alpha2 = hwsim_alpha2s[2];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tparam.p2p_device = support_p2p_device;\n\t\tparam.use_chanctx = channels > 1;\n\n\t\terr = mac80211_hwsim_new_radio(NULL, &param);\n\t\tif (err < 0)\n\t\t\tgoto out_free_radios;\n\t}\n\n\thwsim_mon = alloc_netdev(0, \"hwsim%d\", NET_NAME_UNKNOWN,\n\t\t\t\t hwsim_mon_setup);\n\tif (hwsim_mon == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto out_free_radios;\n\t}\n\n\trtnl_lock();\n\terr = dev_alloc_name(hwsim_mon, hwsim_mon->name);\n\tif (err < 0) {\n\t\trtnl_unlock();\n\t\tgoto out_free_radios;\n\t}\n\n\terr = register_netdevice(hwsim_mon);\n\tif (err < 0) {\n\t\trtnl_unlock();\n\t\tgoto out_free_mon;\n\t}\n\trtnl_unlock();\n\n\treturn 0;\n\nout_free_mon:\n\tfree_netdev(hwsim_mon);\nout_free_radios:\n\tmac80211_hwsim_free();\nout_unregister_driver:\n\tplatform_driver_unregister(&mac80211_hwsim_driver);\nout_unregister_pernet:\n\tunregister_pernet_device(&hwsim_net_ops);\n\treturn err;\n}\nmodule_init(init_mac80211_hwsim);\n\nstatic void __exit exit_mac80211_hwsim(void)\n{\n\tpr_debug(\"mac80211_hwsim: unregister radios\\n\");\n\n\thwsim_exit_netlink();\n\n\tmac80211_hwsim_free();\n\trhashtable_destroy(&hwsim_radios_rht);\n\tunregister_netdev(hwsim_mon);\n\tplatform_driver_unregister(&mac80211_hwsim_driver);\n\tunregister_pernet_device(&hwsim_net_ops);\n}\nmodule_exit(exit_mac80211_hwsim);\n"], "filenames": ["drivers/net/wireless/mac80211_hwsim.c"], "buggy_code_start_loc": [3200], "buggy_code_end_loc": [3201], "fixing_code_start_loc": [3200], "fixing_code_end_loc": [3204], "type": "CWE-772", "message": "Memory leak in the hwsim_new_radio_nl function in drivers/net/wireless/mac80211_hwsim.c in the Linux kernel through 4.15.9 allows local users to cause a denial of service (memory consumption) by triggering an out-of-array error case.", "other": {"cve": {"id": "CVE-2018-8087", "sourceIdentifier": "cve@mitre.org", "published": "2018-03-13T06:29:00.260", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Memory leak in the hwsim_new_radio_nl function in drivers/net/wireless/mac80211_hwsim.c in the Linux kernel through 4.15.9 allows local users to cause a denial of service (memory consumption) by triggering an out-of-array error case."}, {"lang": "es", "value": "Fuga de memoria en la funci\u00f3n hwsim_new_radio_nl en drivers/net/wireless/mac80211_hwsim.c en el kernel de Linux hasta la versi\u00f3n 4.15.9 permite que usuarios locales provoquen una denegaci\u00f3n de servicio (consumo de memoria) desencadenando un caso de error fuera de array."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-772"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.15.9", "matchCriteriaId": "9511E3E2-F4FD-42A1-941F-D47186F35DCB"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:17.10:*:*:*:*:*:*:*", "matchCriteriaId": "9070C9D8-A14A-467F-8253-33B966C16886"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=0ddcff49b672239dda94d70d0fcf50317a9f4b51", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "http://www.securityfocus.com/bid/103397", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://access.redhat.com/errata/RHSA-2019:2029", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2019:2043", "source": "cve@mitre.org"}, {"url": "https://github.com/torvalds/linux/commit/0ddcff49b672239dda94d70d0fcf50317a9f4b51", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://usn.ubuntu.com/3676-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3676-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3677-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3677-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3678-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3678-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3678-3/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3678-4/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2018/dsa-4188", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/0ddcff49b672239dda94d70d0fcf50317a9f4b51"}}