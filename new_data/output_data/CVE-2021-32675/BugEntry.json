{"buggy_code": ["/*\n * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"server.h\"\n#include \"atomicvar.h\"\n#include \"cluster.h\"\n#include <sys/socket.h>\n#include <sys/uio.h>\n#include <math.h>\n#include <ctype.h>\n\nstatic void setProtocolError(const char *errstr, client *c);\nint postponeClientRead(client *c);\nint ProcessingEventsWhileBlocked = 0; /* See processEventsWhileBlocked(). */\n\n/* Return the size consumed from the allocator, for the specified SDS string,\n * including internal fragmentation. This function is used in order to compute\n * the client output buffer size. */\nsize_t sdsZmallocSize(sds s) {\n    void *sh = sdsAllocPtr(s);\n    return zmalloc_size(sh);\n}\n\n/* Return the amount of memory used by the sds string at object->ptr\n * for a string object. This includes internal fragmentation. */\nsize_t getStringObjectSdsUsedMemory(robj *o) {\n    serverAssertWithInfo(NULL,o,o->type == OBJ_STRING);\n    switch(o->encoding) {\n    case OBJ_ENCODING_RAW: return sdsZmallocSize(o->ptr);\n    case OBJ_ENCODING_EMBSTR: return zmalloc_size(o)-sizeof(robj);\n    default: return 0; /* Just integer encoding for now. */\n    }\n}\n\n/* Return the length of a string object.\n * This does NOT includes internal fragmentation or sds unused space. */\nsize_t getStringObjectLen(robj *o) {\n    serverAssertWithInfo(NULL,o,o->type == OBJ_STRING);\n    switch(o->encoding) {\n    case OBJ_ENCODING_RAW: return sdslen(o->ptr);\n    case OBJ_ENCODING_EMBSTR: return sdslen(o->ptr);\n    default: return 0; /* Just integer encoding for now. */\n    }\n}\n\n/* Client.reply list dup and free methods. */\nvoid *dupClientReplyValue(void *o) {\n    clientReplyBlock *old = o;\n    clientReplyBlock *buf = zmalloc(sizeof(clientReplyBlock) + old->size);\n    memcpy(buf, o, sizeof(clientReplyBlock) + old->size);\n    return buf;\n}\n\nvoid freeClientReplyValue(void *o) {\n    zfree(o);\n}\n\nint listMatchObjects(void *a, void *b) {\n    return equalStringObjects(a,b);\n}\n\n/* This function links the client to the global linked list of clients.\n * unlinkClient() does the opposite, among other things. */\nvoid linkClient(client *c) {\n    listAddNodeTail(server.clients,c);\n    /* Note that we remember the linked list node where the client is stored,\n     * this way removing the client in unlinkClient() will not require\n     * a linear scan, but just a constant time operation. */\n    c->client_list_node = listLast(server.clients);\n    uint64_t id = htonu64(c->id);\n    raxInsert(server.clients_index,(unsigned char*)&id,sizeof(id),c,NULL);\n}\n\nclient *createClient(connection *conn) {\n    client *c = zmalloc(sizeof(client));\n\n    /* passing NULL as conn it is possible to create a non connected client.\n     * This is useful since all the commands needs to be executed\n     * in the context of a client. When commands are executed in other\n     * contexts (for instance a Lua script) we need a non connected client. */\n    if (conn) {\n        connNonBlock(conn);\n        connEnableTcpNoDelay(conn);\n        if (server.tcpkeepalive)\n            connKeepAlive(conn,server.tcpkeepalive);\n        connSetReadHandler(conn, readQueryFromClient);\n        connSetPrivateData(conn, c);\n    }\n\n    selectDb(c,0);\n    uint64_t client_id = ++server.next_client_id;\n    c->id = client_id;\n    c->resp = 2;\n    c->conn = conn;\n    c->name = NULL;\n    c->bufpos = 0;\n    c->qb_pos = 0;\n    c->querybuf = sdsempty();\n    c->pending_querybuf = sdsempty();\n    c->querybuf_peak = 0;\n    c->reqtype = 0;\n    c->argc = 0;\n    c->argv = NULL;\n    c->argv_len_sum = 0;\n    c->cmd = c->lastcmd = NULL;\n    c->user = DefaultUser;\n    c->multibulklen = 0;\n    c->bulklen = -1;\n    c->sentlen = 0;\n    c->flags = 0;\n    c->ctime = c->lastinteraction = server.unixtime;\n    /* If the default user does not require authentication, the user is\n     * directly authenticated. */\n    c->authenticated = (c->user->flags & USER_FLAG_NOPASS) &&\n                       !(c->user->flags & USER_FLAG_DISABLED);\n    c->replstate = REPL_STATE_NONE;\n    c->repl_put_online_on_ack = 0;\n    c->reploff = 0;\n    c->read_reploff = 0;\n    c->repl_ack_off = 0;\n    c->repl_ack_time = 0;\n    c->repl_last_partial_write = 0;\n    c->slave_listening_port = 0;\n    c->slave_ip[0] = '\\0';\n    c->slave_capa = SLAVE_CAPA_NONE;\n    c->reply = listCreate();\n    c->reply_bytes = 0;\n    c->obuf_soft_limit_reached_time = 0;\n    listSetFreeMethod(c->reply,freeClientReplyValue);\n    listSetDupMethod(c->reply,dupClientReplyValue);\n    c->btype = BLOCKED_NONE;\n    c->bpop.timeout = 0;\n    c->bpop.keys = dictCreate(&objectKeyHeapPointerValueDictType,NULL);\n    c->bpop.target = NULL;\n    c->bpop.xread_group = NULL;\n    c->bpop.xread_consumer = NULL;\n    c->bpop.xread_group_noack = 0;\n    c->bpop.numreplicas = 0;\n    c->bpop.reploffset = 0;\n    c->woff = 0;\n    c->watched_keys = listCreate();\n    c->pubsub_channels = dictCreate(&objectKeyPointerValueDictType,NULL);\n    c->pubsub_patterns = listCreate();\n    c->peerid = NULL;\n    c->client_list_node = NULL;\n    c->client_tracking_redirection = 0;\n    c->client_tracking_prefixes = NULL;\n    c->client_cron_last_memory_usage = 0;\n    c->client_cron_last_memory_type = CLIENT_TYPE_NORMAL;\n    c->auth_callback = NULL;\n    c->auth_callback_privdata = NULL;\n    c->auth_module = NULL;\n    listSetFreeMethod(c->pubsub_patterns,decrRefCountVoid);\n    listSetMatchMethod(c->pubsub_patterns,listMatchObjects);\n    if (conn) linkClient(c);\n    initClientMultiState(c);\n    return c;\n}\n\n/* This function puts the client in the queue of clients that should write\n * their output buffers to the socket. Note that it does not *yet* install\n * the write handler, to start clients are put in a queue of clients that need\n * to write, so we try to do that before returning in the event loop (see the\n * handleClientsWithPendingWrites() function).\n * If we fail and there is more data to write, compared to what the socket\n * buffers can hold, then we'll really install the handler. */\nvoid clientInstallWriteHandler(client *c) {\n    /* Schedule the client to write the output buffers to the socket only\n     * if not already done and, for slaves, if the slave can actually receive\n     * writes at this stage. */\n    if (!(c->flags & CLIENT_PENDING_WRITE) &&\n        (c->replstate == REPL_STATE_NONE ||\n         (c->replstate == SLAVE_STATE_ONLINE && !c->repl_put_online_on_ack)))\n    {\n        /* Here instead of installing the write handler, we just flag the\n         * client and put it into a list of clients that have something\n         * to write to the socket. This way before re-entering the event\n         * loop, we can try to directly write to the client sockets avoiding\n         * a system call. We'll only really install the write handler if\n         * we'll not be able to write the whole reply at once. */\n        c->flags |= CLIENT_PENDING_WRITE;\n        listAddNodeHead(server.clients_pending_write,c);\n    }\n}\n\n/* This function is called every time we are going to transmit new data\n * to the client. The behavior is the following:\n *\n * If the client should receive new data (normal clients will) the function\n * returns C_OK, and make sure to install the write handler in our event\n * loop so that when the socket is writable new data gets written.\n *\n * If the client should not receive new data, because it is a fake client\n * (used to load AOF in memory), a master or because the setup of the write\n * handler failed, the function returns C_ERR.\n *\n * The function may return C_OK without actually installing the write\n * event handler in the following cases:\n *\n * 1) The event handler should already be installed since the output buffer\n *    already contains something.\n * 2) The client is a slave but not yet online, so we want to just accumulate\n *    writes in the buffer but not actually sending them yet.\n *\n * Typically gets called every time a reply is built, before adding more\n * data to the clients output buffers. If the function returns C_ERR no\n * data should be appended to the output buffers. */\nint prepareClientToWrite(client *c) {\n    /* If it's the Lua client we always return ok without installing any\n     * handler since there is no socket at all. */\n    if (c->flags & (CLIENT_LUA|CLIENT_MODULE)) return C_OK;\n\n    /* If CLIENT_CLOSE_ASAP flag is set, we need not write anything. */\n    if (c->flags & CLIENT_CLOSE_ASAP) return C_ERR;\n\n    /* CLIENT REPLY OFF / SKIP handling: don't send replies. */\n    if (c->flags & (CLIENT_REPLY_OFF|CLIENT_REPLY_SKIP)) return C_ERR;\n\n    /* Masters don't receive replies, unless CLIENT_MASTER_FORCE_REPLY flag\n     * is set. */\n    if ((c->flags & CLIENT_MASTER) &&\n        !(c->flags & CLIENT_MASTER_FORCE_REPLY)) return C_ERR;\n\n    if (!c->conn) return C_ERR; /* Fake client for AOF loading. */\n\n    /* Schedule the client to write the output buffers to the socket, unless\n     * it should already be setup to do so (it has already pending data).\n     *\n     * If CLIENT_PENDING_READ is set, we're in an IO thread and should\n     * not install a write handler. Instead, it will be done by\n     * handleClientsWithPendingReadsUsingThreads() upon return.\n     */\n    if (!clientHasPendingReplies(c) && !(c->flags & CLIENT_PENDING_READ))\n            clientInstallWriteHandler(c);\n\n    /* Authorize the caller to queue in the output buffer of this client. */\n    return C_OK;\n}\n\n/* -----------------------------------------------------------------------------\n * Low level functions to add more data to output buffers.\n * -------------------------------------------------------------------------- */\n\n/* Attempts to add the reply to the static buffer in the client struct.\n * Returns C_ERR if the buffer is full, or the reply list is not empty,\n * in which case the reply must be added to the reply list. */\nint _addReplyToBuffer(client *c, const char *s, size_t len) {\n    size_t available = sizeof(c->buf)-c->bufpos;\n\n    if (c->flags & CLIENT_CLOSE_AFTER_REPLY) return C_OK;\n\n    /* If there already are entries in the reply list, we cannot\n     * add anything more to the static buffer. */\n    if (listLength(c->reply) > 0) return C_ERR;\n\n    /* Check that the buffer has enough space available for this string. */\n    if (len > available) return C_ERR;\n\n    memcpy(c->buf+c->bufpos,s,len);\n    c->bufpos+=len;\n    return C_OK;\n}\n\n/* Adds the reply to the reply linked list.\n * Note: some edits to this function need to be relayed to AddReplyFromClient. */\nvoid _addReplyProtoToList(client *c, const char *s, size_t len) {\n    if (c->flags & CLIENT_CLOSE_AFTER_REPLY) return;\n\n    listNode *ln = listLast(c->reply);\n    clientReplyBlock *tail = ln? listNodeValue(ln): NULL;\n\n    /* Note that 'tail' may be NULL even if we have a tail node, because when\n     * addReplyDeferredLen() is used, it sets a dummy node to NULL just\n     * fo fill it later, when the size of the bulk length is set. */\n\n    /* Append to tail string when possible. */\n    if (tail) {\n        /* Copy the part we can fit into the tail, and leave the rest for a\n         * new node */\n        size_t avail = tail->size - tail->used;\n        size_t copy = avail >= len? len: avail;\n        memcpy(tail->buf + tail->used, s, copy);\n        tail->used += copy;\n        s += copy;\n        len -= copy;\n    }\n    if (len) {\n        /* Create a new node, make sure it is allocated to at\n         * least PROTO_REPLY_CHUNK_BYTES */\n        size_t size = len < PROTO_REPLY_CHUNK_BYTES? PROTO_REPLY_CHUNK_BYTES: len;\n        tail = zmalloc(size + sizeof(clientReplyBlock));\n        /* take over the allocation's internal fragmentation */\n        tail->size = zmalloc_usable(tail) - sizeof(clientReplyBlock);\n        tail->used = len;\n        memcpy(tail->buf, s, len);\n        listAddNodeTail(c->reply, tail);\n        c->reply_bytes += tail->size;\n    }\n    asyncCloseClientOnOutputBufferLimitReached(c);\n}\n\n/* -----------------------------------------------------------------------------\n * Higher level functions to queue data on the client output buffer.\n * The following functions are the ones that commands implementations will call.\n * -------------------------------------------------------------------------- */\n\n/* Add the object 'obj' string representation to the client output buffer. */\nvoid addReply(client *c, robj *obj) {\n    if (prepareClientToWrite(c) != C_OK) return;\n\n    if (sdsEncodedObject(obj)) {\n        if (_addReplyToBuffer(c,obj->ptr,sdslen(obj->ptr)) != C_OK)\n            _addReplyProtoToList(c,obj->ptr,sdslen(obj->ptr));\n    } else if (obj->encoding == OBJ_ENCODING_INT) {\n        /* For integer encoded strings we just convert it into a string\n         * using our optimized function, and attach the resulting string\n         * to the output buffer. */\n        char buf[32];\n        size_t len = ll2string(buf,sizeof(buf),(long)obj->ptr);\n        if (_addReplyToBuffer(c,buf,len) != C_OK)\n            _addReplyProtoToList(c,buf,len);\n    } else {\n        serverPanic(\"Wrong obj->encoding in addReply()\");\n    }\n}\n\n/* Add the SDS 's' string to the client output buffer, as a side effect\n * the SDS string is freed. */\nvoid addReplySds(client *c, sds s) {\n    if (prepareClientToWrite(c) != C_OK) {\n        /* The caller expects the sds to be free'd. */\n        sdsfree(s);\n        return;\n    }\n    if (_addReplyToBuffer(c,s,sdslen(s)) != C_OK)\n        _addReplyProtoToList(c,s,sdslen(s));\n    sdsfree(s);\n}\n\n/* This low level function just adds whatever protocol you send it to the\n * client buffer, trying the static buffer initially, and using the string\n * of objects if not possible.\n *\n * It is efficient because does not create an SDS object nor an Redis object\n * if not needed. The object will only be created by calling\n * _addReplyProtoToList() if we fail to extend the existing tail object\n * in the list of objects. */\nvoid addReplyProto(client *c, const char *s, size_t len) {\n    if (prepareClientToWrite(c) != C_OK) return;\n    if (_addReplyToBuffer(c,s,len) != C_OK)\n        _addReplyProtoToList(c,s,len);\n}\n\n/* Low level function called by the addReplyError...() functions.\n * It emits the protocol for a Redis error, in the form:\n *\n * -ERRORCODE Error Message<CR><LF>\n *\n * If the error code is already passed in the string 's', the error\n * code provided is used, otherwise the string \"-ERR \" for the generic\n * error code is automatically added.\n * Note that 's' must NOT end with \\r\\n. */\nvoid addReplyErrorLength(client *c, const char *s, size_t len) {\n    /* If the string already starts with \"-...\" then the error code\n     * is provided by the caller. Otherwise we use \"-ERR\". */\n    if (!len || s[0] != '-') addReplyProto(c,\"-ERR \",5);\n    addReplyProto(c,s,len);\n    addReplyProto(c,\"\\r\\n\",2);\n}\n\n/* Do some actions after an error reply was sent (Log if needed, updates stats, etc.) */\nvoid afterErrorReply(client *c, const char *s, size_t len) {\n    /* Sometimes it could be normal that a slave replies to a master with\n     * an error and this function gets called. Actually the error will never\n     * be sent because addReply*() against master clients has no effect...\n     * A notable example is:\n     *\n     *    EVAL 'redis.call(\"incr\",KEYS[1]); redis.call(\"nonexisting\")' 1 x\n     *\n     * Where the master must propagate the first change even if the second\n     * will produce an error. However it is useful to log such events since\n     * they are rare and may hint at errors in a script or a bug in Redis. */\n    int ctype = getClientType(c);\n    if (ctype == CLIENT_TYPE_MASTER || ctype == CLIENT_TYPE_SLAVE || c->id == CLIENT_ID_AOF) {\n        char *to, *from;\n\n        if (c->id == CLIENT_ID_AOF) {\n            to = \"AOF-loading-client\";\n            from = \"server\";\n        } else if (ctype == CLIENT_TYPE_MASTER) {\n            to = \"master\";\n            from = \"replica\";\n        } else {\n            to = \"replica\";\n            from = \"master\";\n        }\n\n        if (len > 4096) len = 4096;\n        char *cmdname = c->lastcmd ? c->lastcmd->name : \"<unknown>\";\n        serverLog(LL_WARNING,\"== CRITICAL == This %s is sending an error \"\n                             \"to its %s: '%.*s' after processing the command \"\n                             \"'%s'\", from, to, (int)len, s, cmdname);\n        if (ctype == CLIENT_TYPE_MASTER && server.repl_backlog &&\n            server.repl_backlog_histlen > 0)\n        {\n            showLatestBacklog();\n        }\n        server.stat_unexpected_error_replies++;\n    }\n}\n\n/* The 'err' object is expected to start with -ERRORCODE and end with \\r\\n.\n * Unlike addReplyErrorSds and others alike which rely on addReplyErrorLength. */\nvoid addReplyErrorObject(client *c, robj *err) {\n    addReply(c, err);\n    afterErrorReply(c, err->ptr, sdslen(err->ptr)-2); /* Ignore trailing \\r\\n */\n}\n\n/* See addReplyErrorLength for expectations from the input string. */\nvoid addReplyError(client *c, const char *err) {\n    addReplyErrorLength(c,err,strlen(err));\n    afterErrorReply(c,err,strlen(err));\n}\n\n/* See addReplyErrorLength for expectations from the input string. */\nvoid addReplyErrorSds(client *c, sds err) {\n    addReplyErrorLength(c,err,sdslen(err));\n    afterErrorReply(c,err,sdslen(err));\n}\n\n/* See addReplyErrorLength for expectations from the formatted string.\n * The formatted string is safe to contain \\r and \\n anywhere. */\nvoid addReplyErrorFormat(client *c, const char *fmt, ...) {\n    va_list ap;\n    va_start(ap,fmt);\n    sds s = sdscatvprintf(sdsempty(),fmt,ap);\n    va_end(ap);\n    /* Trim any newlines at the end (ones will be added by addReplyErrorLength) */\n    s = sdstrim(s, \"\\r\\n\");\n    /* Make sure there are no newlines in the middle of the string, otherwise\n     * invalid protocol is emitted. */\n    s = sdsmapchars(s, \"\\r\\n\", \"  \",  2);\n    addReplyErrorLength(c,s,sdslen(s));\n    afterErrorReply(c,s,sdslen(s));\n    sdsfree(s);\n}\n\nvoid addReplyStatusLength(client *c, const char *s, size_t len) {\n    addReplyProto(c,\"+\",1);\n    addReplyProto(c,s,len);\n    addReplyProto(c,\"\\r\\n\",2);\n}\n\nvoid addReplyStatus(client *c, const char *status) {\n    addReplyStatusLength(c,status,strlen(status));\n}\n\nvoid addReplyStatusFormat(client *c, const char *fmt, ...) {\n    va_list ap;\n    va_start(ap,fmt);\n    sds s = sdscatvprintf(sdsempty(),fmt,ap);\n    va_end(ap);\n    addReplyStatusLength(c,s,sdslen(s));\n    sdsfree(s);\n}\n\n/* Sometimes we are forced to create a new reply node, and we can't append to\n * the previous one, when that happens, we wanna try to trim the unused space\n * at the end of the last reply node which we won't use anymore. */\nvoid trimReplyUnusedTailSpace(client *c) {\n    listNode *ln = listLast(c->reply);\n    clientReplyBlock *tail = ln? listNodeValue(ln): NULL;\n\n    /* Note that 'tail' may be NULL even if we have a tail node, becuase when\n     * addReplyDeferredLen() is used */\n    if (!tail) return;\n\n    /* We only try to trim the space is relatively high (more than a 1/4 of the\n     * allocation), otherwise there's a high chance realloc will NOP.\n     * Also, to avoid large memmove which happens as part of realloc, we only do\n     * that if the used part is small.  */\n    if (tail->size - tail->used > tail->size / 4 &&\n        tail->used < PROTO_REPLY_CHUNK_BYTES)\n    {\n        size_t old_size = tail->size;\n        tail = zrealloc(tail, tail->used + sizeof(clientReplyBlock));\n        /* take over the allocation's internal fragmentation (at least for\n         * memory usage tracking) */\n        tail->size = zmalloc_usable(tail) - sizeof(clientReplyBlock);\n        c->reply_bytes = c->reply_bytes + tail->size - old_size;\n        listNodeValue(ln) = tail;\n    }\n}\n\n/* Adds an empty object to the reply list that will contain the multi bulk\n * length, which is not known when this function is called. */\nvoid *addReplyDeferredLen(client *c) {\n    /* Note that we install the write event here even if the object is not\n     * ready to be sent, since we are sure that before returning to the\n     * event loop setDeferredAggregateLen() will be called. */\n    if (prepareClientToWrite(c) != C_OK) return NULL;\n    trimReplyUnusedTailSpace(c);\n    listAddNodeTail(c->reply,NULL); /* NULL is our placeholder. */\n    return listLast(c->reply);\n}\n\n/* Populate the length object and try gluing it to the next chunk. */\nvoid setDeferredAggregateLen(client *c, void *node, long length, char prefix) {\n    serverAssert(length >= 0);\n    listNode *ln = (listNode*)node;\n    clientReplyBlock *next;\n    char lenstr[128];\n    size_t lenstr_len = sprintf(lenstr, \"%c%ld\\r\\n\", prefix, length);\n\n    /* Abort when *node is NULL: when the client should not accept writes\n     * we return NULL in addReplyDeferredLen() */\n    if (node == NULL) return;\n    serverAssert(!listNodeValue(ln));\n\n    /* Normally we fill this dummy NULL node, added by addReplyDeferredLen(),\n     * with a new buffer structure containing the protocol needed to specify\n     * the length of the array following. However sometimes when there is\n     * little memory to move, we may instead remove this NULL node, and prefix\n     * our protocol in the node immediately after to it, in order to save a\n     * write(2) syscall later. Conditions needed to do it:\n     *\n     * - The next node is non-NULL,\n     * - It has enough room already allocated\n     * - And not too large (avoid large memmove) */\n    if (ln->next != NULL && (next = listNodeValue(ln->next)) &&\n        next->size - next->used >= lenstr_len &&\n        next->used < PROTO_REPLY_CHUNK_BYTES * 4) {\n        memmove(next->buf + lenstr_len, next->buf, next->used);\n        memcpy(next->buf, lenstr, lenstr_len);\n        next->used += lenstr_len;\n        listDelNode(c->reply,ln);\n    } else {\n        /* Create a new node */\n        clientReplyBlock *buf = zmalloc(lenstr_len + sizeof(clientReplyBlock));\n        /* Take over the allocation's internal fragmentation */\n        buf->size = zmalloc_usable(buf) - sizeof(clientReplyBlock);\n        buf->used = lenstr_len;\n        memcpy(buf->buf, lenstr, lenstr_len);\n        listNodeValue(ln) = buf;\n        c->reply_bytes += buf->size;\n    }\n    asyncCloseClientOnOutputBufferLimitReached(c);\n}\n\nvoid setDeferredArrayLen(client *c, void *node, long length) {\n    setDeferredAggregateLen(c,node,length,'*');\n}\n\nvoid setDeferredMapLen(client *c, void *node, long length) {\n    int prefix = c->resp == 2 ? '*' : '%';\n    if (c->resp == 2) length *= 2;\n    setDeferredAggregateLen(c,node,length,prefix);\n}\n\nvoid setDeferredSetLen(client *c, void *node, long length) {\n    int prefix = c->resp == 2 ? '*' : '~';\n    setDeferredAggregateLen(c,node,length,prefix);\n}\n\nvoid setDeferredAttributeLen(client *c, void *node, long length) {\n    serverAssert(c->resp >= 3);\n    setDeferredAggregateLen(c,node,length,'|');\n}\n\nvoid setDeferredPushLen(client *c, void *node, long length) {\n    serverAssert(c->resp >= 3);\n    setDeferredAggregateLen(c,node,length,'>');\n}\n\n/* Add a double as a bulk reply */\nvoid addReplyDouble(client *c, double d) {\n    if (isinf(d)) {\n        /* Libc in odd systems (Hi Solaris!) will format infinite in a\n         * different way, so better to handle it in an explicit way. */\n        if (c->resp == 2) {\n            addReplyBulkCString(c, d > 0 ? \"inf\" : \"-inf\");\n        } else {\n            addReplyProto(c, d > 0 ? \",inf\\r\\n\" : \",-inf\\r\\n\",\n                              d > 0 ? 6 : 7);\n        }\n    } else {\n        char dbuf[MAX_LONG_DOUBLE_CHARS+3],\n             sbuf[MAX_LONG_DOUBLE_CHARS+32];\n        int dlen, slen;\n        if (c->resp == 2) {\n            dlen = snprintf(dbuf,sizeof(dbuf),\"%.17g\",d);\n            slen = snprintf(sbuf,sizeof(sbuf),\"$%d\\r\\n%s\\r\\n\",dlen,dbuf);\n            addReplyProto(c,sbuf,slen);\n        } else {\n            dlen = snprintf(dbuf,sizeof(dbuf),\",%.17g\\r\\n\",d);\n            addReplyProto(c,dbuf,dlen);\n        }\n    }\n}\n\nvoid addReplyBigNum(client *c, const char* num, size_t len) {\n    if (c->resp == 2) {\n        addReplyBulkCBuffer(c, num, len);\n    } else {\n        addReplyProto(c,\"(\",1);\n        addReplyProto(c,num,len);\n        addReply(c,shared.crlf);\n    }\n}\n\n/* Add a long double as a bulk reply, but uses a human readable formatting\n * of the double instead of exposing the crude behavior of doubles to the\n * dear user. */\nvoid addReplyHumanLongDouble(client *c, long double d) {\n    if (c->resp == 2) {\n        robj *o = createStringObjectFromLongDouble(d,1);\n        addReplyBulk(c,o);\n        decrRefCount(o);\n    } else {\n        char buf[MAX_LONG_DOUBLE_CHARS];\n        int len = ld2string(buf,sizeof(buf),d,LD_STR_HUMAN);\n        addReplyProto(c,\",\",1);\n        addReplyProto(c,buf,len);\n        addReplyProto(c,\"\\r\\n\",2);\n    }\n}\n\n/* Add a long long as integer reply or bulk len / multi bulk count.\n * Basically this is used to output <prefix><long long><crlf>. */\nvoid addReplyLongLongWithPrefix(client *c, long long ll, char prefix) {\n    char buf[128];\n    int len;\n\n    /* Things like $3\\r\\n or *2\\r\\n are emitted very often by the protocol\n     * so we have a few shared objects to use if the integer is small\n     * like it is most of the times. */\n    if (prefix == '*' && ll < OBJ_SHARED_BULKHDR_LEN && ll >= 0) {\n        addReply(c,shared.mbulkhdr[ll]);\n        return;\n    } else if (prefix == '$' && ll < OBJ_SHARED_BULKHDR_LEN && ll >= 0) {\n        addReply(c,shared.bulkhdr[ll]);\n        return;\n    }\n\n    buf[0] = prefix;\n    len = ll2string(buf+1,sizeof(buf)-1,ll);\n    buf[len+1] = '\\r';\n    buf[len+2] = '\\n';\n    addReplyProto(c,buf,len+3);\n}\n\nvoid addReplyLongLong(client *c, long long ll) {\n    if (ll == 0)\n        addReply(c,shared.czero);\n    else if (ll == 1)\n        addReply(c,shared.cone);\n    else\n        addReplyLongLongWithPrefix(c,ll,':');\n}\n\nvoid addReplyAggregateLen(client *c, long length, int prefix) {\n    if (prefix == '*' && length < OBJ_SHARED_BULKHDR_LEN)\n        addReply(c,shared.mbulkhdr[length]);\n    else\n        addReplyLongLongWithPrefix(c,length,prefix);\n}\n\nvoid addReplyArrayLen(client *c, long length) {\n    addReplyAggregateLen(c,length,'*');\n}\n\nvoid addReplyMapLen(client *c, long length) {\n    int prefix = c->resp == 2 ? '*' : '%';\n    if (c->resp == 2) length *= 2;\n    addReplyAggregateLen(c,length,prefix);\n}\n\nvoid addReplySetLen(client *c, long length) {\n    int prefix = c->resp == 2 ? '*' : '~';\n    addReplyAggregateLen(c,length,prefix);\n}\n\nvoid addReplyAttributeLen(client *c, long length) {\n    serverAssert(c->resp >= 3);\n    addReplyAggregateLen(c,length,'|');\n}\n\nvoid addReplyPushLen(client *c, long length) {\n    serverAssert(c->resp >= 3);\n    addReplyAggregateLen(c,length,'>');\n}\n\nvoid addReplyNull(client *c) {\n    if (c->resp == 2) {\n        addReplyProto(c,\"$-1\\r\\n\",5);\n    } else {\n        addReplyProto(c,\"_\\r\\n\",3);\n    }\n}\n\nvoid addReplyBool(client *c, int b) {\n    if (c->resp == 2) {\n        addReply(c, b ? shared.cone : shared.czero);\n    } else {\n        addReplyProto(c, b ? \"#t\\r\\n\" : \"#f\\r\\n\",4);\n    }\n}\n\n/* A null array is a concept that no longer exists in RESP3. However\n * RESP2 had it, so API-wise we have this call, that will emit the correct\n * RESP2 protocol, however for RESP3 the reply will always be just the\n * Null type \"_\\r\\n\". */\nvoid addReplyNullArray(client *c) {\n    if (c->resp == 2) {\n        addReplyProto(c,\"*-1\\r\\n\",5);\n    } else {\n        addReplyProto(c,\"_\\r\\n\",3);\n    }\n}\n\n/* Create the length prefix of a bulk reply, example: $2234 */\nvoid addReplyBulkLen(client *c, robj *obj) {\n    size_t len = stringObjectLen(obj);\n\n    if (len < OBJ_SHARED_BULKHDR_LEN)\n        addReply(c,shared.bulkhdr[len]);\n    else\n        addReplyLongLongWithPrefix(c,len,'$');\n}\n\n/* Add a Redis Object as a bulk reply */\nvoid addReplyBulk(client *c, robj *obj) {\n    addReplyBulkLen(c,obj);\n    addReply(c,obj);\n    addReply(c,shared.crlf);\n}\n\n/* Add a C buffer as bulk reply */\nvoid addReplyBulkCBuffer(client *c, const void *p, size_t len) {\n    addReplyLongLongWithPrefix(c,len,'$');\n    addReplyProto(c,p,len);\n    addReply(c,shared.crlf);\n}\n\n/* Add sds to reply (takes ownership of sds and frees it) */\nvoid addReplyBulkSds(client *c, sds s)  {\n    addReplyLongLongWithPrefix(c,sdslen(s),'$');\n    addReplySds(c,s);\n    addReply(c,shared.crlf);\n}\n\n/* Add a C null term string as bulk reply */\nvoid addReplyBulkCString(client *c, const char *s) {\n    if (s == NULL) {\n        addReplyNull(c);\n    } else {\n        addReplyBulkCBuffer(c,s,strlen(s));\n    }\n}\n\n/* Add a long long as a bulk reply */\nvoid addReplyBulkLongLong(client *c, long long ll) {\n    char buf[64];\n    int len;\n\n    len = ll2string(buf,64,ll);\n    addReplyBulkCBuffer(c,buf,len);\n}\n\n/* Reply with a verbatim type having the specified extension.\n *\n * The 'ext' is the \"extension\" of the file, actually just a three\n * character type that describes the format of the verbatim string.\n * For instance \"txt\" means it should be interpreted as a text only\n * file by the receiver, \"md \" as markdown, and so forth. Only the\n * three first characters of the extension are used, and if the\n * provided one is shorter than that, the remaining is filled with\n * spaces. */\nvoid addReplyVerbatim(client *c, const char *s, size_t len, const char *ext) {\n    if (c->resp == 2) {\n        addReplyBulkCBuffer(c,s,len);\n    } else {\n        char buf[32];\n        size_t preflen = snprintf(buf,sizeof(buf),\"=%zu\\r\\nxxx:\",len+4);\n        char *p = buf+preflen-4;\n        for (int i = 0; i < 3; i++) {\n            if (*ext == '\\0') {\n                p[i] = ' ';\n            } else {\n                p[i] = *ext++;\n            }\n        }\n        addReplyProto(c,buf,preflen);\n        addReplyProto(c,s,len);\n        addReplyProto(c,\"\\r\\n\",2);\n    }\n}\n\n/* Add an array of C strings as status replies with a heading.\n * This function is typically invoked by from commands that support\n * subcommands in response to the 'help' subcommand. The help array\n * is terminated by NULL sentinel. */\nvoid addReplyHelp(client *c, const char **help) {\n    sds cmd = sdsnew((char*) c->argv[0]->ptr);\n    void *blenp = addReplyDeferredLen(c);\n    int blen = 0;\n\n    sdstoupper(cmd);\n    addReplyStatusFormat(c,\n        \"%s <subcommand> arg arg ... arg. Subcommands are:\",cmd);\n    sdsfree(cmd);\n\n    while (help[blen]) addReplyStatus(c,help[blen++]);\n\n    blen++;  /* Account for the header line(s). */\n    setDeferredArrayLen(c,blenp,blen);\n}\n\n/* Add a suggestive error reply.\n * This function is typically invoked by from commands that support\n * subcommands in response to an unknown subcommand or argument error. */\nvoid addReplySubcommandSyntaxError(client *c) {\n    sds cmd = sdsnew((char*) c->argv[0]->ptr);\n    sdstoupper(cmd);\n    addReplyErrorFormat(c,\n        \"Unknown subcommand or wrong number of arguments for '%s'. Try %s HELP.\",\n        (char*)c->argv[1]->ptr,cmd);\n    sdsfree(cmd);\n}\n\n/* Append 'src' client output buffers into 'dst' client output buffers. \n * This function clears the output buffers of 'src' */\nvoid AddReplyFromClient(client *dst, client *src) {\n    /* If the source client contains a partial response due to client output\n     * buffer limits, propagate that to the dest rather than copy a partial\n     * reply. We don't wanna run the risk of copying partial response in case\n     * for some reason the output limits don't reach the same decision (maybe\n     * they changed) */\n    if (src->flags & CLIENT_CLOSE_ASAP) {\n        sds client = catClientInfoString(sdsempty(),dst);\n        freeClientAsync(dst);\n        serverLog(LL_WARNING,\"Client %s scheduled to be closed ASAP for overcoming of output buffer limits.\", client);\n        sdsfree(client);\n        return;\n    }\n\n    /* First add the static buffer (either into the static buffer or reply list) */\n    addReplyProto(dst,src->buf, src->bufpos);\n\n    /* We need to check with prepareClientToWrite again (after addReplyProto)\n     * since addReplyProto may have changed something (like CLIENT_CLOSE_ASAP) */\n    if (prepareClientToWrite(dst) != C_OK)\n        return;\n\n    /* We're bypassing _addReplyProtoToList, so we need to add the pre/post\n     * checks in it. */\n    if (dst->flags & CLIENT_CLOSE_AFTER_REPLY) return;\n\n    /* Concatenate the reply list into the dest */\n    if (listLength(src->reply))\n        listJoin(dst->reply,src->reply);\n    dst->reply_bytes += src->reply_bytes;\n    src->reply_bytes = 0;\n    src->bufpos = 0;\n\n    /* Check output buffer limits */\n    asyncCloseClientOnOutputBufferLimitReached(dst);\n}\n\n/* Copy 'src' client output buffers into 'dst' client output buffers.\n * The function takes care of freeing the old output buffers of the\n * destination client. */\nvoid copyClientOutputBuffer(client *dst, client *src) {\n    listRelease(dst->reply);\n    dst->sentlen = 0;\n    dst->reply = listDup(src->reply);\n    memcpy(dst->buf,src->buf,src->bufpos);\n    dst->bufpos = src->bufpos;\n    dst->reply_bytes = src->reply_bytes;\n}\n\n/* Return true if the specified client has pending reply buffers to write to\n * the socket. */\nint clientHasPendingReplies(client *c) {\n    return c->bufpos || listLength(c->reply);\n}\n\nvoid clientAcceptHandler(connection *conn) {\n    client *c = connGetPrivateData(conn);\n\n    if (connGetState(conn) != CONN_STATE_CONNECTED) {\n        serverLog(LL_WARNING,\n                \"Error accepting a client connection: %s\",\n                connGetLastError(conn));\n        freeClientAsync(c);\n        return;\n    }\n\n    /* If the server is running in protected mode (the default) and there\n     * is no password set, nor a specific interface is bound, we don't accept\n     * requests from non loopback interfaces. Instead we try to explain the\n     * user what to do to fix it if needed. */\n    if (server.protected_mode &&\n        server.bindaddr_count == 0 &&\n        DefaultUser->flags & USER_FLAG_NOPASS &&\n        !(c->flags & CLIENT_UNIX_SOCKET))\n    {\n        char cip[NET_IP_STR_LEN+1] = { 0 };\n        connPeerToString(conn, cip, sizeof(cip)-1, NULL);\n\n        if (strcmp(cip,\"127.0.0.1\") && strcmp(cip,\"::1\")) {\n            char *err =\n                \"-DENIED Redis is running in protected mode because protected \"\n                \"mode is enabled, no bind address was specified, no \"\n                \"authentication password is requested to clients. In this mode \"\n                \"connections are only accepted from the loopback interface. \"\n                \"If you want to connect from external computers to Redis you \"\n                \"may adopt one of the following solutions: \"\n                \"1) Just disable protected mode sending the command \"\n                \"'CONFIG SET protected-mode no' from the loopback interface \"\n                \"by connecting to Redis from the same host the server is \"\n                \"running, however MAKE SURE Redis is not publicly accessible \"\n                \"from internet if you do so. Use CONFIG REWRITE to make this \"\n                \"change permanent. \"\n                \"2) Alternatively you can just disable the protected mode by \"\n                \"editing the Redis configuration file, and setting the protected \"\n                \"mode option to 'no', and then restarting the server. \"\n                \"3) If you started the server manually just for testing, restart \"\n                \"it with the '--protected-mode no' option. \"\n                \"4) Setup a bind address or an authentication password. \"\n                \"NOTE: You only need to do one of the above things in order for \"\n                \"the server to start accepting connections from the outside.\\r\\n\";\n            if (connWrite(c->conn,err,strlen(err)) == -1) {\n                /* Nothing to do, Just to avoid the warning... */\n            }\n            server.stat_rejected_conn++;\n            freeClientAsync(c);\n            return;\n        }\n    }\n\n    server.stat_numconnections++;\n    moduleFireServerEvent(REDISMODULE_EVENT_CLIENT_CHANGE,\n                          REDISMODULE_SUBEVENT_CLIENT_CHANGE_CONNECTED,\n                          c);\n}\n\n#define MAX_ACCEPTS_PER_CALL 1000\nstatic void acceptCommonHandler(connection *conn, int flags, char *ip) {\n    client *c;\n    char conninfo[100];\n    UNUSED(ip);\n\n    if (connGetState(conn) != CONN_STATE_ACCEPTING) {\n        serverLog(LL_VERBOSE,\n            \"Accepted client connection in error state: %s (conn: %s)\",\n            connGetLastError(conn),\n            connGetInfo(conn, conninfo, sizeof(conninfo)));\n        connClose(conn);\n        return;\n    }\n\n    /* Limit the number of connections we take at the same time.\n     *\n     * Admission control will happen before a client is created and connAccept()\n     * called, because we don't want to even start transport-level negotiation\n     * if rejected. */\n    if (listLength(server.clients) + getClusterConnectionsCount()\n        >= server.maxclients)\n    {\n        char *err;\n        if (server.cluster_enabled)\n            err = \"-ERR max number of clients + cluster \"\n                  \"connections reached\\r\\n\";\n        else\n            err = \"-ERR max number of clients reached\\r\\n\";\n\n        /* That's a best effort error message, don't check write errors.\n         * Note that for TLS connections, no handshake was done yet so nothing\n         * is written and the connection will just drop. */\n        if (connWrite(conn,err,strlen(err)) == -1) {\n            /* Nothing to do, Just to avoid the warning... */\n        }\n        server.stat_rejected_conn++;\n        connClose(conn);\n        return;\n    }\n\n    /* Create connection and client */\n    if ((c = createClient(conn)) == NULL) {\n        serverLog(LL_WARNING,\n            \"Error registering fd event for the new client: %s (conn: %s)\",\n            connGetLastError(conn),\n            connGetInfo(conn, conninfo, sizeof(conninfo)));\n        connClose(conn); /* May be already closed, just ignore errors */\n        return;\n    }\n\n    /* Last chance to keep flags */\n    c->flags |= flags;\n\n    /* Initiate accept.\n     *\n     * Note that connAccept() is free to do two things here:\n     * 1. Call clientAcceptHandler() immediately;\n     * 2. Schedule a future call to clientAcceptHandler().\n     *\n     * Because of that, we must do nothing else afterwards.\n     */\n    if (connAccept(conn, clientAcceptHandler) == C_ERR) {\n        char conninfo[100];\n        if (connGetState(conn) == CONN_STATE_ERROR)\n            serverLog(LL_WARNING,\n                    \"Error accepting a client connection: %s (conn: %s)\",\n                    connGetLastError(conn), connGetInfo(conn, conninfo, sizeof(conninfo)));\n        freeClient(connGetPrivateData(conn));\n        return;\n    }\n}\n\nvoid acceptTcpHandler(aeEventLoop *el, int fd, void *privdata, int mask) {\n    int cport, cfd, max = MAX_ACCEPTS_PER_CALL;\n    char cip[NET_IP_STR_LEN];\n    UNUSED(el);\n    UNUSED(mask);\n    UNUSED(privdata);\n\n    while(max--) {\n        cfd = anetTcpAccept(server.neterr, fd, cip, sizeof(cip), &cport);\n        if (cfd == ANET_ERR) {\n            if (errno != EWOULDBLOCK)\n                serverLog(LL_WARNING,\n                    \"Accepting client connection: %s\", server.neterr);\n            return;\n        }\n        serverLog(LL_VERBOSE,\"Accepted %s:%d\", cip, cport);\n        acceptCommonHandler(connCreateAcceptedSocket(cfd),0,cip);\n    }\n}\n\nvoid acceptTLSHandler(aeEventLoop *el, int fd, void *privdata, int mask) {\n    int cport, cfd, max = MAX_ACCEPTS_PER_CALL;\n    char cip[NET_IP_STR_LEN];\n    UNUSED(el);\n    UNUSED(mask);\n    UNUSED(privdata);\n\n    while(max--) {\n        cfd = anetTcpAccept(server.neterr, fd, cip, sizeof(cip), &cport);\n        if (cfd == ANET_ERR) {\n            if (errno != EWOULDBLOCK)\n                serverLog(LL_WARNING,\n                    \"Accepting client connection: %s\", server.neterr);\n            return;\n        }\n        serverLog(LL_VERBOSE,\"Accepted %s:%d\", cip, cport);\n        acceptCommonHandler(connCreateAcceptedTLS(cfd, server.tls_auth_clients),0,cip);\n    }\n}\n\nvoid acceptUnixHandler(aeEventLoop *el, int fd, void *privdata, int mask) {\n    int cfd, max = MAX_ACCEPTS_PER_CALL;\n    UNUSED(el);\n    UNUSED(mask);\n    UNUSED(privdata);\n\n    while(max--) {\n        cfd = anetUnixAccept(server.neterr, fd);\n        if (cfd == ANET_ERR) {\n            if (errno != EWOULDBLOCK)\n                serverLog(LL_WARNING,\n                    \"Accepting client connection: %s\", server.neterr);\n            return;\n        }\n        serverLog(LL_VERBOSE,\"Accepted connection to %s\", server.unixsocket);\n        acceptCommonHandler(connCreateAcceptedSocket(cfd),CLIENT_UNIX_SOCKET,NULL);\n    }\n}\n\nstatic void freeClientArgv(client *c) {\n    int j;\n    for (j = 0; j < c->argc; j++)\n        decrRefCount(c->argv[j]);\n    c->argc = 0;\n    c->cmd = NULL;\n    c->argv_len_sum = 0;\n}\n\n/* Close all the slaves connections. This is useful in chained replication\n * when we resync with our own master and want to force all our slaves to\n * resync with us as well. */\nvoid disconnectSlaves(void) {\n    listIter li;\n    listNode *ln;\n    listRewind(server.slaves,&li);\n    while((ln = listNext(&li))) {\n        freeClient((client*)ln->value);\n    }\n}\n\n/* Remove the specified client from global lists where the client could\n * be referenced, not including the Pub/Sub channels.\n * This is used by freeClient() and replicationCacheMaster(). */\nvoid unlinkClient(client *c) {\n    listNode *ln;\n\n    /* If this is marked as current client unset it. */\n    if (server.current_client == c) server.current_client = NULL;\n\n    /* Certain operations must be done only if the client has an active connection.\n     * If the client was already unlinked or if it's a \"fake client\" the\n     * conn is already set to NULL. */\n    if (c->conn) {\n        /* Remove from the list of active clients. */\n        if (c->client_list_node) {\n            uint64_t id = htonu64(c->id);\n            raxRemove(server.clients_index,(unsigned char*)&id,sizeof(id),NULL);\n            listDelNode(server.clients,c->client_list_node);\n            c->client_list_node = NULL;\n        }\n\n        /* Check if this is a replica waiting for diskless replication (rdb pipe),\n         * in which case it needs to be cleaned from that list */\n        if (c->flags & CLIENT_SLAVE &&\n            c->replstate == SLAVE_STATE_WAIT_BGSAVE_END &&\n            server.rdb_pipe_conns)\n        {\n            int i;\n            for (i=0; i < server.rdb_pipe_numconns; i++) {\n                if (server.rdb_pipe_conns[i] == c->conn) {\n                    rdbPipeWriteHandlerConnRemoved(c->conn);\n                    server.rdb_pipe_conns[i] = NULL;\n                    break;\n                }\n            }\n        }\n        connClose(c->conn);\n        c->conn = NULL;\n    }\n\n    /* Remove from the list of pending writes if needed. */\n    if (c->flags & CLIENT_PENDING_WRITE) {\n        ln = listSearchKey(server.clients_pending_write,c);\n        serverAssert(ln != NULL);\n        listDelNode(server.clients_pending_write,ln);\n        c->flags &= ~CLIENT_PENDING_WRITE;\n    }\n\n    /* Remove from the list of pending reads if needed. */\n    if (c->flags & CLIENT_PENDING_READ) {\n        ln = listSearchKey(server.clients_pending_read,c);\n        serverAssert(ln != NULL);\n        listDelNode(server.clients_pending_read,ln);\n        c->flags &= ~CLIENT_PENDING_READ;\n    }\n\n    /* When client was just unblocked because of a blocking operation,\n     * remove it from the list of unblocked clients. */\n    if (c->flags & CLIENT_UNBLOCKED) {\n        ln = listSearchKey(server.unblocked_clients,c);\n        serverAssert(ln != NULL);\n        listDelNode(server.unblocked_clients,ln);\n        c->flags &= ~CLIENT_UNBLOCKED;\n    }\n\n    /* Clear the tracking status. */\n    if (c->flags & CLIENT_TRACKING) disableTracking(c);\n}\n\nvoid freeClient(client *c) {\n    listNode *ln;\n\n    /* If a client is protected, yet we need to free it right now, make sure\n     * to at least use asynchronous freeing. */\n    if (c->flags & CLIENT_PROTECTED) {\n        freeClientAsync(c);\n        return;\n    }\n\n    /* For connected clients, call the disconnection event of modules hooks. */\n    if (c->conn) {\n        moduleFireServerEvent(REDISMODULE_EVENT_CLIENT_CHANGE,\n                              REDISMODULE_SUBEVENT_CLIENT_CHANGE_DISCONNECTED,\n                              c);\n    }\n\n    /* Notify module system that this client auth status changed. */\n    moduleNotifyUserChanged(c);\n\n    /* If this client was scheduled for async freeing we need to remove it\n     * from the queue. Note that we need to do this here, because later\n     * we may call replicationCacheMaster() and the client should already\n     * be removed from the list of clients to free. */\n    if (c->flags & CLIENT_CLOSE_ASAP) {\n        ln = listSearchKey(server.clients_to_close,c);\n        serverAssert(ln != NULL);\n        listDelNode(server.clients_to_close,ln);\n    }\n\n    /* If it is our master that's being disconnected we should make sure\n     * to cache the state to try a partial resynchronization later.\n     *\n     * Note that before doing this we make sure that the client is not in\n     * some unexpected state, by checking its flags. */\n    if (server.master && c->flags & CLIENT_MASTER) {\n        serverLog(LL_WARNING,\"Connection with master lost.\");\n        if (!(c->flags & (CLIENT_PROTOCOL_ERROR|CLIENT_BLOCKED))) {\n            c->flags &= ~(CLIENT_CLOSE_ASAP|CLIENT_CLOSE_AFTER_REPLY);\n            replicationCacheMaster(c);\n            return;\n        }\n    }\n\n    /* Log link disconnection with slave */\n    if (getClientType(c) == CLIENT_TYPE_SLAVE) {\n        serverLog(LL_WARNING,\"Connection with replica %s lost.\",\n            replicationGetSlaveName(c));\n    }\n\n    /* Free the query buffer */\n    sdsfree(c->querybuf);\n    sdsfree(c->pending_querybuf);\n    c->querybuf = NULL;\n\n    /* Deallocate structures used to block on blocking ops. */\n    if (c->flags & CLIENT_BLOCKED) unblockClient(c);\n    dictRelease(c->bpop.keys);\n\n    /* UNWATCH all the keys */\n    unwatchAllKeys(c);\n    listRelease(c->watched_keys);\n\n    /* Unsubscribe from all the pubsub channels */\n    pubsubUnsubscribeAllChannels(c,0);\n    pubsubUnsubscribeAllPatterns(c,0);\n    dictRelease(c->pubsub_channels);\n    listRelease(c->pubsub_patterns);\n\n    /* Free data structures. */\n    listRelease(c->reply);\n    freeClientArgv(c);\n\n    /* Unlink the client: this will close the socket, remove the I/O\n     * handlers, and remove references of the client from different\n     * places where active clients may be referenced. */\n    unlinkClient(c);\n\n    /* Master/slave cleanup Case 1:\n     * we lost the connection with a slave. */\n    if (c->flags & CLIENT_SLAVE) {\n        if (c->replstate == SLAVE_STATE_SEND_BULK) {\n            if (c->repldbfd != -1) close(c->repldbfd);\n            if (c->replpreamble) sdsfree(c->replpreamble);\n        }\n        list *l = (c->flags & CLIENT_MONITOR) ? server.monitors : server.slaves;\n        ln = listSearchKey(l,c);\n        serverAssert(ln != NULL);\n        listDelNode(l,ln);\n        /* We need to remember the time when we started to have zero\n         * attached slaves, as after some time we'll free the replication\n         * backlog. */\n        if (getClientType(c) == CLIENT_TYPE_SLAVE && listLength(server.slaves) == 0)\n            server.repl_no_slaves_since = server.unixtime;\n        refreshGoodSlavesCount();\n        /* Fire the replica change modules event. */\n        if (c->replstate == SLAVE_STATE_ONLINE)\n            moduleFireServerEvent(REDISMODULE_EVENT_REPLICA_CHANGE,\n                                  REDISMODULE_SUBEVENT_REPLICA_CHANGE_OFFLINE,\n                                  NULL);\n    }\n\n    /* Master/slave cleanup Case 2:\n     * we lost the connection with the master. */\n    if (c->flags & CLIENT_MASTER) replicationHandleMasterDisconnection();\n\n   /* Remove the contribution that this client gave to our\n     * incrementally computed memory usage. */\n    server.stat_clients_type_memory[c->client_cron_last_memory_type] -=\n        c->client_cron_last_memory_usage;\n\n    /* Release other dynamically allocated client structure fields,\n     * and finally release the client structure itself. */\n    if (c->name) decrRefCount(c->name);\n    zfree(c->argv);\n    c->argv_len_sum = 0;\n    freeClientMultiState(c);\n    sdsfree(c->peerid);\n    zfree(c);\n}\n\n/* Schedule a client to free it at a safe time in the serverCron() function.\n * This function is useful when we need to terminate a client but we are in\n * a context where calling freeClient() is not possible, because the client\n * should be valid for the continuation of the flow of the program. */\nvoid freeClientAsync(client *c) {\n    /* We need to handle concurrent access to the server.clients_to_close list\n     * only in the freeClientAsync() function, since it's the only function that\n     * may access the list while Redis uses I/O threads. All the other accesses\n     * are in the context of the main thread while the other threads are\n     * idle. */\n    if (c->flags & CLIENT_CLOSE_ASAP || c->flags & CLIENT_LUA) return;\n    c->flags |= CLIENT_CLOSE_ASAP;\n    if (server.io_threads_num == 1) {\n        /* no need to bother with locking if there's just one thread (the main thread) */\n        listAddNodeTail(server.clients_to_close,c);\n        return;\n    }\n    static pthread_mutex_t async_free_queue_mutex = PTHREAD_MUTEX_INITIALIZER;\n    pthread_mutex_lock(&async_free_queue_mutex);\n    listAddNodeTail(server.clients_to_close,c);\n    pthread_mutex_unlock(&async_free_queue_mutex);\n}\n\n/* Free the clietns marked as CLOSE_ASAP, return the number of clients\n * freed. */\nint freeClientsInAsyncFreeQueue(void) {\n    int freed = 0;\n    listIter li;\n    listNode *ln;\n\n    listRewind(server.clients_to_close,&li);\n    while ((ln = listNext(&li)) != NULL) {\n        client *c = listNodeValue(ln);\n\n        if (c->flags & CLIENT_PROTECTED) continue;\n\n        c->flags &= ~CLIENT_CLOSE_ASAP;\n        freeClient(c);\n        listDelNode(server.clients_to_close,ln);\n        freed++;\n    }\n    return freed;\n}\n\n/* Return a client by ID, or NULL if the client ID is not in the set\n * of registered clients. Note that \"fake clients\", created with -1 as FD,\n * are not registered clients. */\nclient *lookupClientByID(uint64_t id) {\n    id = htonu64(id);\n    client *c = raxFind(server.clients_index,(unsigned char*)&id,sizeof(id));\n    return (c == raxNotFound) ? NULL : c;\n}\n\n/* Write data in output buffers to client. Return C_OK if the client\n * is still valid after the call, C_ERR if it was freed because of some\n * error.  If handler_installed is set, it will attempt to clear the\n * write event.\n *\n * This function is called by threads, but always with handler_installed\n * set to 0. So when handler_installed is set to 0 the function must be\n * thread safe. */\nint writeToClient(client *c, int handler_installed) {\n    /* Update total number of writes on server */\n    server.stat_total_writes_processed++;\n\n    ssize_t nwritten = 0, totwritten = 0;\n    size_t objlen;\n    clientReplyBlock *o;\n\n    while(clientHasPendingReplies(c)) {\n        if (c->bufpos > 0) {\n            nwritten = connWrite(c->conn,c->buf+c->sentlen,c->bufpos-c->sentlen);\n            if (nwritten <= 0) break;\n            c->sentlen += nwritten;\n            totwritten += nwritten;\n\n            /* If the buffer was sent, set bufpos to zero to continue with\n             * the remainder of the reply. */\n            if ((int)c->sentlen == c->bufpos) {\n                c->bufpos = 0;\n                c->sentlen = 0;\n            }\n        } else {\n            o = listNodeValue(listFirst(c->reply));\n            objlen = o->used;\n\n            if (objlen == 0) {\n                c->reply_bytes -= o->size;\n                listDelNode(c->reply,listFirst(c->reply));\n                continue;\n            }\n\n            nwritten = connWrite(c->conn, o->buf + c->sentlen, objlen - c->sentlen);\n            if (nwritten <= 0) break;\n            c->sentlen += nwritten;\n            totwritten += nwritten;\n\n            /* If we fully sent the object on head go to the next one */\n            if (c->sentlen == objlen) {\n                c->reply_bytes -= o->size;\n                listDelNode(c->reply,listFirst(c->reply));\n                c->sentlen = 0;\n                /* If there are no longer objects in the list, we expect\n                 * the count of reply bytes to be exactly zero. */\n                if (listLength(c->reply) == 0)\n                    serverAssert(c->reply_bytes == 0);\n            }\n        }\n        /* Note that we avoid to send more than NET_MAX_WRITES_PER_EVENT\n         * bytes, in a single threaded server it's a good idea to serve\n         * other clients as well, even if a very large request comes from\n         * super fast link that is always able to accept data (in real world\n         * scenario think about 'KEYS *' against the loopback interface).\n         *\n         * However if we are over the maxmemory limit we ignore that and\n         * just deliver as much data as it is possible to deliver.\n         *\n         * Moreover, we also send as much as possible if the client is\n         * a slave or a monitor (otherwise, on high-speed traffic, the\n         * replication/output buffer will grow indefinitely) */\n        if (totwritten > NET_MAX_WRITES_PER_EVENT &&\n            (server.maxmemory == 0 ||\n             zmalloc_used_memory() < server.maxmemory) &&\n            !(c->flags & CLIENT_SLAVE)) break;\n    }\n    server.stat_net_output_bytes += totwritten;\n    if (nwritten == -1) {\n        if (connGetState(c->conn) == CONN_STATE_CONNECTED) {\n            nwritten = 0;\n        } else {\n            serverLog(LL_VERBOSE,\n                \"Error writing to client: %s\", connGetLastError(c->conn));\n            freeClientAsync(c);\n            return C_ERR;\n        }\n    }\n    if (totwritten > 0) {\n        /* For clients representing masters we don't count sending data\n         * as an interaction, since we always send REPLCONF ACK commands\n         * that take some time to just fill the socket output buffer.\n         * We just rely on data / pings received for timeout detection. */\n        if (!(c->flags & CLIENT_MASTER)) c->lastinteraction = server.unixtime;\n    }\n    if (!clientHasPendingReplies(c)) {\n        c->sentlen = 0;\n        /* Note that writeToClient() is called in a threaded way, but\n         * adDeleteFileEvent() is not thread safe: however writeToClient()\n         * is always called with handler_installed set to 0 from threads\n         * so we are fine. */\n        if (handler_installed) connSetWriteHandler(c->conn, NULL);\n\n        /* Close connection after entire reply has been sent. */\n        if (c->flags & CLIENT_CLOSE_AFTER_REPLY) {\n            freeClientAsync(c);\n            return C_ERR;\n        }\n    }\n    return C_OK;\n}\n\n/* Write event handler. Just send data to the client. */\nvoid sendReplyToClient(connection *conn) {\n    client *c = connGetPrivateData(conn);\n    writeToClient(c,1);\n}\n\n/* This function is called just before entering the event loop, in the hope\n * we can just write the replies to the client output buffer without any\n * need to use a syscall in order to install the writable event handler,\n * get it called, and so forth. */\nint handleClientsWithPendingWrites(void) {\n    listIter li;\n    listNode *ln;\n    int processed = listLength(server.clients_pending_write);\n\n    listRewind(server.clients_pending_write,&li);\n    while((ln = listNext(&li))) {\n        client *c = listNodeValue(ln);\n        c->flags &= ~CLIENT_PENDING_WRITE;\n        listDelNode(server.clients_pending_write,ln);\n\n        /* If a client is protected, don't do anything,\n         * that may trigger write error or recreate handler. */\n        if (c->flags & CLIENT_PROTECTED) continue;\n\n        /* Don't write to clients that are going to be closed anyway. */\n        if (c->flags & CLIENT_CLOSE_ASAP) continue;\n\n        /* Try to write buffers to the client socket. */\n        if (writeToClient(c,0) == C_ERR) continue;\n\n        /* If after the synchronous writes above we still have data to\n         * output to the client, we need to install the writable handler. */\n        if (clientHasPendingReplies(c)) {\n            int ae_barrier = 0;\n            /* For the fsync=always policy, we want that a given FD is never\n             * served for reading and writing in the same event loop iteration,\n             * so that in the middle of receiving the query, and serving it\n             * to the client, we'll call beforeSleep() that will do the\n             * actual fsync of AOF to disk. the write barrier ensures that. */\n            if (server.aof_state == AOF_ON &&\n                server.aof_fsync == AOF_FSYNC_ALWAYS)\n            {\n                ae_barrier = 1;\n            }\n            if (connSetWriteHandlerWithBarrier(c->conn, sendReplyToClient, ae_barrier) == C_ERR) {\n                freeClientAsync(c);\n            }\n        }\n    }\n    return processed;\n}\n\n/* resetClient prepare the client to process the next command */\nvoid resetClient(client *c) {\n    redisCommandProc *prevcmd = c->cmd ? c->cmd->proc : NULL;\n\n    freeClientArgv(c);\n    c->reqtype = 0;\n    c->multibulklen = 0;\n    c->bulklen = -1;\n\n    /* We clear the ASKING flag as well if we are not inside a MULTI, and\n     * if what we just executed is not the ASKING command itself. */\n    if (!(c->flags & CLIENT_MULTI) && prevcmd != askingCommand)\n        c->flags &= ~CLIENT_ASKING;\n\n    /* We do the same for the CACHING command as well. It also affects\n     * the next command or transaction executed, in a way very similar\n     * to ASKING. */\n    if (!(c->flags & CLIENT_MULTI) && prevcmd != clientCommand)\n        c->flags &= ~CLIENT_TRACKING_CACHING;\n\n    /* Remove the CLIENT_REPLY_SKIP flag if any so that the reply\n     * to the next command will be sent, but set the flag if the command\n     * we just processed was \"CLIENT REPLY SKIP\". */\n    c->flags &= ~CLIENT_REPLY_SKIP;\n    if (c->flags & CLIENT_REPLY_SKIP_NEXT) {\n        c->flags |= CLIENT_REPLY_SKIP;\n        c->flags &= ~CLIENT_REPLY_SKIP_NEXT;\n    }\n}\n\n/* This function is used when we want to re-enter the event loop but there\n * is the risk that the client we are dealing with will be freed in some\n * way. This happens for instance in:\n *\n * * DEBUG RELOAD and similar.\n * * When a Lua script is in -BUSY state.\n *\n * So the function will protect the client by doing two things:\n *\n * 1) It removes the file events. This way it is not possible that an\n *    error is signaled on the socket, freeing the client.\n * 2) Moreover it makes sure that if the client is freed in a different code\n *    path, it is not really released, but only marked for later release. */\nvoid protectClient(client *c) {\n    c->flags |= CLIENT_PROTECTED;\n    if (c->conn) {\n        connSetReadHandler(c->conn,NULL);\n        connSetWriteHandler(c->conn,NULL);\n    }\n}\n\n/* This will undo the client protection done by protectClient() */\nvoid unprotectClient(client *c) {\n    if (c->flags & CLIENT_PROTECTED) {\n        c->flags &= ~CLIENT_PROTECTED;\n        if (c->conn) {\n            connSetReadHandler(c->conn,readQueryFromClient);\n            if (clientHasPendingReplies(c)) clientInstallWriteHandler(c);\n        }\n    }\n}\n\n/* Like processMultibulkBuffer(), but for the inline protocol instead of RESP,\n * this function consumes the client query buffer and creates a command ready\n * to be executed inside the client structure. Returns C_OK if the command\n * is ready to be executed, or C_ERR if there is still protocol to read to\n * have a well formed command. The function also returns C_ERR when there is\n * a protocol error: in such a case the client structure is setup to reply\n * with the error and close the connection. */\nint processInlineBuffer(client *c) {\n    char *newline;\n    int argc, j, linefeed_chars = 1;\n    sds *argv, aux;\n    size_t querylen;\n\n    /* Search for end of line */\n    newline = strchr(c->querybuf+c->qb_pos,'\\n');\n\n    /* Nothing to do without a \\r\\n */\n    if (newline == NULL) {\n        if (sdslen(c->querybuf)-c->qb_pos > PROTO_INLINE_MAX_SIZE) {\n            addReplyError(c,\"Protocol error: too big inline request\");\n            setProtocolError(\"too big inline request\",c);\n        }\n        return C_ERR;\n    }\n\n    /* Handle the \\r\\n case. */\n    if (newline && newline != c->querybuf+c->qb_pos && *(newline-1) == '\\r')\n        newline--, linefeed_chars++;\n\n    /* Split the input buffer up to the \\r\\n */\n    querylen = newline-(c->querybuf+c->qb_pos);\n    aux = sdsnewlen(c->querybuf+c->qb_pos,querylen);\n    argv = sdssplitargs(aux,&argc);\n    sdsfree(aux);\n    if (argv == NULL) {\n        addReplyError(c,\"Protocol error: unbalanced quotes in request\");\n        setProtocolError(\"unbalanced quotes in inline request\",c);\n        return C_ERR;\n    }\n\n    /* Newline from slaves can be used to refresh the last ACK time.\n     * This is useful for a slave to ping back while loading a big\n     * RDB file. */\n    if (querylen == 0 && getClientType(c) == CLIENT_TYPE_SLAVE)\n        c->repl_ack_time = server.unixtime;\n\n    /* Masters should never send us inline protocol to run actual\n     * commands. If this happens, it is likely due to a bug in Redis where\n     * we got some desynchronization in the protocol, for example\n     * beause of a PSYNC gone bad.\n     *\n     * However the is an exception: masters may send us just a newline\n     * to keep the connection active. */\n    if (querylen != 0 && c->flags & CLIENT_MASTER) {\n        sdsfreesplitres(argv,argc);\n        serverLog(LL_WARNING,\"WARNING: Receiving inline protocol from master, master stream corruption? Closing the master connection and discarding the cached master.\");\n        setProtocolError(\"Master using the inline protocol. Desync?\",c);\n        return C_ERR;\n    }\n\n    /* Move querybuffer position to the next query in the buffer. */\n    c->qb_pos += querylen+linefeed_chars;\n\n    /* Setup argv array on client structure */\n    if (argc) {\n        if (c->argv) zfree(c->argv);\n        c->argv = zmalloc(sizeof(robj*)*argc);\n        c->argv_len_sum = 0;\n    }\n\n    /* Create redis objects for all arguments. */\n    for (c->argc = 0, j = 0; j < argc; j++) {\n        c->argv[c->argc] = createObject(OBJ_STRING,argv[j]);\n        c->argc++;\n        c->argv_len_sum += sdslen(argv[j]);\n    }\n    zfree(argv);\n    return C_OK;\n}\n\n/* Helper function. Record protocol erro details in server log,\n * and set the client as CLIENT_CLOSE_AFTER_REPLY and\n * CLIENT_PROTOCOL_ERROR. */\n#define PROTO_DUMP_LEN 128\nstatic void setProtocolError(const char *errstr, client *c) {\n    if (server.verbosity <= LL_VERBOSE || c->flags & CLIENT_MASTER) {\n        sds client = catClientInfoString(sdsempty(),c);\n\n        /* Sample some protocol to given an idea about what was inside. */\n        char buf[256];\n        if (sdslen(c->querybuf)-c->qb_pos < PROTO_DUMP_LEN) {\n            snprintf(buf,sizeof(buf),\"Query buffer during protocol error: '%s'\", c->querybuf+c->qb_pos);\n        } else {\n            snprintf(buf,sizeof(buf),\"Query buffer during protocol error: '%.*s' (... more %zu bytes ...) '%.*s'\", PROTO_DUMP_LEN/2, c->querybuf+c->qb_pos, sdslen(c->querybuf)-c->qb_pos-PROTO_DUMP_LEN, PROTO_DUMP_LEN/2, c->querybuf+sdslen(c->querybuf)-PROTO_DUMP_LEN/2);\n        }\n\n        /* Remove non printable chars. */\n        char *p = buf;\n        while (*p != '\\0') {\n            if (!isprint(*p)) *p = '.';\n            p++;\n        }\n\n        /* Log all the client and protocol info. */\n        int loglevel = (c->flags & CLIENT_MASTER) ? LL_WARNING :\n                                                    LL_VERBOSE;\n        serverLog(loglevel,\n            \"Protocol error (%s) from client: %s. %s\", errstr, client, buf);\n        sdsfree(client);\n    }\n    c->flags |= (CLIENT_CLOSE_AFTER_REPLY|CLIENT_PROTOCOL_ERROR);\n}\n\n/* Process the query buffer for client 'c', setting up the client argument\n * vector for command execution. Returns C_OK if after running the function\n * the client has a well-formed ready to be processed command, otherwise\n * C_ERR if there is still to read more buffer to get the full command.\n * The function also returns C_ERR when there is a protocol error: in such a\n * case the client structure is setup to reply with the error and close\n * the connection.\n *\n * This function is called if processInputBuffer() detects that the next\n * command is in RESP format, so the first byte in the command is found\n * to be '*'. Otherwise for inline commands processInlineBuffer() is called. */\nint processMultibulkBuffer(client *c) {\n    char *newline = NULL;\n    int ok;\n    long long ll;\n\n    if (c->multibulklen == 0) {\n        /* The client should have been reset */\n        serverAssertWithInfo(c,NULL,c->argc == 0);\n\n        /* Multi bulk length cannot be read without a \\r\\n */\n        newline = strchr(c->querybuf+c->qb_pos,'\\r');\n        if (newline == NULL) {\n            if (sdslen(c->querybuf)-c->qb_pos > PROTO_INLINE_MAX_SIZE) {\n                addReplyError(c,\"Protocol error: too big mbulk count string\");\n                setProtocolError(\"too big mbulk count string\",c);\n            }\n            return C_ERR;\n        }\n\n        /* Buffer should also contain \\n */\n        if (newline-(c->querybuf+c->qb_pos) > (ssize_t)(sdslen(c->querybuf)-c->qb_pos-2))\n            return C_ERR;\n\n        /* We know for sure there is a whole line since newline != NULL,\n         * so go ahead and find out the multi bulk length. */\n        serverAssertWithInfo(c,NULL,c->querybuf[c->qb_pos] == '*');\n        ok = string2ll(c->querybuf+1+c->qb_pos,newline-(c->querybuf+1+c->qb_pos),&ll);\n        if (!ok || ll > 1024*1024) {\n            addReplyError(c,\"Protocol error: invalid multibulk length\");\n            setProtocolError(\"invalid mbulk count\",c);\n            return C_ERR;\n        }\n\n        c->qb_pos = (newline-c->querybuf)+2;\n\n        if (ll <= 0) return C_OK;\n\n        c->multibulklen = ll;\n\n        /* Setup argv array on client structure */\n        if (c->argv) zfree(c->argv);\n        c->argv = zmalloc(sizeof(robj*)*c->multibulklen);\n        c->argv_len_sum = 0;\n    }\n\n    serverAssertWithInfo(c,NULL,c->multibulklen > 0);\n    while(c->multibulklen) {\n        /* Read bulk length if unknown */\n        if (c->bulklen == -1) {\n            newline = strchr(c->querybuf+c->qb_pos,'\\r');\n            if (newline == NULL) {\n                if (sdslen(c->querybuf)-c->qb_pos > PROTO_INLINE_MAX_SIZE) {\n                    addReplyError(c,\n                        \"Protocol error: too big bulk count string\");\n                    setProtocolError(\"too big bulk count string\",c);\n                    return C_ERR;\n                }\n                break;\n            }\n\n            /* Buffer should also contain \\n */\n            if (newline-(c->querybuf+c->qb_pos) > (ssize_t)(sdslen(c->querybuf)-c->qb_pos-2))\n                break;\n\n            if (c->querybuf[c->qb_pos] != '$') {\n                addReplyErrorFormat(c,\n                    \"Protocol error: expected '$', got '%c'\",\n                    c->querybuf[c->qb_pos]);\n                setProtocolError(\"expected $ but got something else\",c);\n                return C_ERR;\n            }\n\n            ok = string2ll(c->querybuf+c->qb_pos+1,newline-(c->querybuf+c->qb_pos+1),&ll);\n            if (!ok || ll < 0 ||\n                (!(c->flags & CLIENT_MASTER) && ll > server.proto_max_bulk_len)) {\n                addReplyError(c,\"Protocol error: invalid bulk length\");\n                setProtocolError(\"invalid bulk length\",c);\n                return C_ERR;\n            }\n\n            c->qb_pos = newline-c->querybuf+2;\n            if (ll >= PROTO_MBULK_BIG_ARG) {\n                /* If we are going to read a large object from network\n                 * try to make it likely that it will start at c->querybuf\n                 * boundary so that we can optimize object creation\n                 * avoiding a large copy of data.\n                 *\n                 * But only when the data we have not parsed is less than\n                 * or equal to ll+2. If the data length is greater than\n                 * ll+2, trimming querybuf is just a waste of time, because\n                 * at this time the querybuf contains not only our bulk. */\n                if (sdslen(c->querybuf)-c->qb_pos <= (size_t)ll+2) {\n                    sdsrange(c->querybuf,c->qb_pos,-1);\n                    c->qb_pos = 0;\n                    /* Hint the sds library about the amount of bytes this string is\n                     * going to contain. */\n                    c->querybuf = sdsMakeRoomFor(c->querybuf,ll+2-sdslen(c->querybuf));\n                }\n            }\n            c->bulklen = ll;\n        }\n\n        /* Read bulk argument */\n        if (sdslen(c->querybuf)-c->qb_pos < (size_t)(c->bulklen+2)) {\n            /* Not enough data (+2 == trailing \\r\\n) */\n            break;\n        } else {\n            /* Optimization: if the buffer contains JUST our bulk element\n             * instead of creating a new object by *copying* the sds we\n             * just use the current sds string. */\n            if (c->qb_pos == 0 &&\n                c->bulklen >= PROTO_MBULK_BIG_ARG &&\n                sdslen(c->querybuf) == (size_t)(c->bulklen+2))\n            {\n                c->argv[c->argc++] = createObject(OBJ_STRING,c->querybuf);\n                c->argv_len_sum += c->bulklen;\n                sdsIncrLen(c->querybuf,-2); /* remove CRLF */\n                /* Assume that if we saw a fat argument we'll see another one\n                 * likely... */\n                c->querybuf = sdsnewlen(SDS_NOINIT,c->bulklen+2);\n                sdsclear(c->querybuf);\n            } else {\n                c->argv[c->argc++] =\n                    createStringObject(c->querybuf+c->qb_pos,c->bulklen);\n                c->argv_len_sum += c->bulklen;\n                c->qb_pos += c->bulklen+2;\n            }\n            c->bulklen = -1;\n            c->multibulklen--;\n        }\n    }\n\n    /* We're done when c->multibulk == 0 */\n    if (c->multibulklen == 0) return C_OK;\n\n    /* Still not ready to process the command */\n    return C_ERR;\n}\n\n/* Perform necessary tasks after a command was executed:\n *\n * 1. The client is reset unless there are reasons to avoid doing it.\n * 2. In the case of master clients, the replication offset is updated.\n * 3. Propagate commands we got from our master to replicas down the line. */\nvoid commandProcessed(client *c) {\n    long long prev_offset = c->reploff;\n    if (c->flags & CLIENT_MASTER && !(c->flags & CLIENT_MULTI)) {\n        /* Update the applied replication offset of our master. */\n        c->reploff = c->read_reploff - sdslen(c->querybuf) + c->qb_pos;\n    }\n\n    /* Don't reset the client structure for clients blocked in a\n     * module blocking command, so that the reply callback will\n     * still be able to access the client argv and argc field.\n     * The client will be reset in unblockClientFromModule(). */\n    if (!(c->flags & CLIENT_BLOCKED) ||\n        c->btype != BLOCKED_MODULE)\n    {\n        resetClient(c);\n    }\n\n    /* If the client is a master we need to compute the difference\n     * between the applied offset before and after processing the buffer,\n     * to understand how much of the replication stream was actually\n     * applied to the master state: this quantity, and its corresponding\n     * part of the replication stream, will be propagated to the\n     * sub-replicas and to the replication backlog. */\n    if (c->flags & CLIENT_MASTER) {\n        long long applied = c->reploff - prev_offset;\n        if (applied) {\n            replicationFeedSlavesFromMasterStream(server.slaves,\n                    c->pending_querybuf, applied);\n            sdsrange(c->pending_querybuf,applied,-1);\n        }\n    }\n}\n\n/* This function calls processCommand(), but also performs a few sub tasks\n * for the client that are useful in that context:\n *\n * 1. It sets the current client to the client 'c'.\n * 2. calls commandProcessed() if the command was handled.\n *\n * The function returns C_ERR in case the client was freed as a side effect\n * of processing the command, otherwise C_OK is returned. */\nint processCommandAndResetClient(client *c) {\n    int deadclient = 0;\n    server.current_client = c;\n    if (processCommand(c) == C_OK) {\n        commandProcessed(c);\n    }\n    if (server.current_client == NULL) deadclient = 1;\n    server.current_client = NULL;\n    /* freeMemoryIfNeeded may flush slave output buffers. This may\n     * result into a slave, that may be the active client, to be\n     * freed. */\n    return deadclient ? C_ERR : C_OK;\n}\n\n/* This function will execute any fully parsed commands pending on\n * the client. Returns C_ERR if the client is no longer valid after executing\n * the command, and C_OK for all other cases. */\nint processPendingCommandsAndResetClient(client *c) {\n    if (c->flags & CLIENT_PENDING_COMMAND) {\n        c->flags &= ~CLIENT_PENDING_COMMAND;\n        if (processCommandAndResetClient(c) == C_ERR) {\n            return C_ERR;\n        }\n    }\n    return C_OK;\n}\n\n/* This function is called every time, in the client structure 'c', there is\n * more query buffer to process, because we read more data from the socket\n * or because a client was blocked and later reactivated, so there could be\n * pending query buffer, already representing a full command, to process. */\nvoid processInputBuffer(client *c) {\n    /* Keep processing while there is something in the input buffer */\n    while(c->qb_pos < sdslen(c->querybuf)) {\n        /* Return if clients are paused. */\n        if (!(c->flags & CLIENT_SLAVE) && \n            !(c->flags & CLIENT_PENDING_READ) && \n            clientsArePaused()) break;\n\n        /* Immediately abort if the client is in the middle of something. */\n        if (c->flags & CLIENT_BLOCKED) break;\n\n        /* Don't process more buffers from clients that have already pending\n         * commands to execute in c->argv. */\n        if (c->flags & CLIENT_PENDING_COMMAND) break;\n\n        /* Don't process input from the master while there is a busy script\n         * condition on the slave. We want just to accumulate the replication\n         * stream (instead of replying -BUSY like we do with other clients) and\n         * later resume the processing. */\n        if (server.lua_timedout && c->flags & CLIENT_MASTER) break;\n\n        /* CLIENT_CLOSE_AFTER_REPLY closes the connection once the reply is\n         * written to the client. Make sure to not let the reply grow after\n         * this flag has been set (i.e. don't process more commands).\n         *\n         * The same applies for clients we want to terminate ASAP. */\n        if (c->flags & (CLIENT_CLOSE_AFTER_REPLY|CLIENT_CLOSE_ASAP)) break;\n\n        /* Determine request type when unknown. */\n        if (!c->reqtype) {\n            if (c->querybuf[c->qb_pos] == '*') {\n                c->reqtype = PROTO_REQ_MULTIBULK;\n            } else {\n                c->reqtype = PROTO_REQ_INLINE;\n            }\n        }\n\n        if (c->reqtype == PROTO_REQ_INLINE) {\n            if (processInlineBuffer(c) != C_OK) break;\n            /* If the Gopher mode and we got zero or one argument, process\n             * the request in Gopher mode. To avoid data race, Redis won't\n             * support Gopher if enable io threads to read queries. */\n            if (server.gopher_enabled && !server.io_threads_do_reads &&\n                ((c->argc == 1 && ((char*)(c->argv[0]->ptr))[0] == '/') ||\n                  c->argc == 0))\n            {\n                processGopherRequest(c);\n                resetClient(c);\n                c->flags |= CLIENT_CLOSE_AFTER_REPLY;\n                break;\n            }\n        } else if (c->reqtype == PROTO_REQ_MULTIBULK) {\n            if (processMultibulkBuffer(c) != C_OK) break;\n        } else {\n            serverPanic(\"Unknown request type\");\n        }\n\n        /* Multibulk processing could see a <= 0 length. */\n        if (c->argc == 0) {\n            resetClient(c);\n        } else {\n            /* If we are in the context of an I/O thread, we can't really\n             * execute the command here. All we can do is to flag the client\n             * as one that needs to process the command. */\n            if (c->flags & CLIENT_PENDING_READ) {\n                c->flags |= CLIENT_PENDING_COMMAND;\n                break;\n            }\n\n            /* We are finally ready to execute the command. */\n            if (processCommandAndResetClient(c) == C_ERR) {\n                /* If the client is no longer valid, we avoid exiting this\n                 * loop and trimming the client buffer later. So we return\n                 * ASAP in that case. */\n                return;\n            }\n        }\n    }\n\n    /* Trim to pos */\n    if (c->qb_pos) {\n        sdsrange(c->querybuf,c->qb_pos,-1);\n        c->qb_pos = 0;\n    }\n}\n\nvoid readQueryFromClient(connection *conn) {\n    client *c = connGetPrivateData(conn);\n    int nread, readlen;\n    size_t qblen;\n\n    /* Check if we want to read from the client later when exiting from\n     * the event loop. This is the case if threaded I/O is enabled. */\n    if (postponeClientRead(c)) return;\n\n    /* Update total number of reads on server */\n    server.stat_total_reads_processed++;\n\n    readlen = PROTO_IOBUF_LEN;\n    /* If this is a multi bulk request, and we are processing a bulk reply\n     * that is large enough, try to maximize the probability that the query\n     * buffer contains exactly the SDS string representing the object, even\n     * at the risk of requiring more read(2) calls. This way the function\n     * processMultiBulkBuffer() can avoid copying buffers to create the\n     * Redis Object representing the argument. */\n    if (c->reqtype == PROTO_REQ_MULTIBULK && c->multibulklen && c->bulklen != -1\n        && c->bulklen >= PROTO_MBULK_BIG_ARG)\n    {\n        ssize_t remaining = (size_t)(c->bulklen+2)-sdslen(c->querybuf);\n\n        /* Note that the 'remaining' variable may be zero in some edge case,\n         * for example once we resume a blocked client after CLIENT PAUSE. */\n        if (remaining > 0 && remaining < readlen) readlen = remaining;\n    }\n\n    qblen = sdslen(c->querybuf);\n    if (c->querybuf_peak < qblen) c->querybuf_peak = qblen;\n    c->querybuf = sdsMakeRoomFor(c->querybuf, readlen);\n    nread = connRead(c->conn, c->querybuf+qblen, readlen);\n    if (nread == -1) {\n        if (connGetState(conn) == CONN_STATE_CONNECTED) {\n            return;\n        } else {\n            serverLog(LL_VERBOSE, \"Reading from client: %s\",connGetLastError(c->conn));\n            freeClientAsync(c);\n            return;\n        }\n    } else if (nread == 0) {\n        serverLog(LL_VERBOSE, \"Client closed connection\");\n        freeClientAsync(c);\n        return;\n    } else if (c->flags & CLIENT_MASTER) {\n        /* Append the query buffer to the pending (not applied) buffer\n         * of the master. We'll use this buffer later in order to have a\n         * copy of the string applied by the last command executed. */\n        c->pending_querybuf = sdscatlen(c->pending_querybuf,\n                                        c->querybuf+qblen,nread);\n    }\n\n    sdsIncrLen(c->querybuf,nread);\n    c->lastinteraction = server.unixtime;\n    if (c->flags & CLIENT_MASTER) c->read_reploff += nread;\n    server.stat_net_input_bytes += nread;\n    if (sdslen(c->querybuf) > server.client_max_querybuf_len) {\n        sds ci = catClientInfoString(sdsempty(),c), bytes = sdsempty();\n\n        bytes = sdscatrepr(bytes,c->querybuf,64);\n        serverLog(LL_WARNING,\"Closing client that reached max query buffer length: %s (qbuf initial bytes: %s)\", ci, bytes);\n        sdsfree(ci);\n        sdsfree(bytes);\n        freeClientAsync(c);\n        return;\n    }\n\n    /* There is more data in the client input buffer, continue parsing it\n     * in case to check if there is a full command to execute. */\n     processInputBuffer(c);\n}\n\nvoid getClientsMaxBuffers(unsigned long *longest_output_list,\n                          unsigned long *biggest_input_buffer) {\n    client *c;\n    listNode *ln;\n    listIter li;\n    unsigned long lol = 0, bib = 0;\n\n    listRewind(server.clients,&li);\n    while ((ln = listNext(&li)) != NULL) {\n        c = listNodeValue(ln);\n\n        if (listLength(c->reply) > lol) lol = listLength(c->reply);\n        if (sdslen(c->querybuf) > bib) bib = sdslen(c->querybuf);\n    }\n    *longest_output_list = lol;\n    *biggest_input_buffer = bib;\n}\n\n/* A Redis \"Peer ID\" is a colon separated ip:port pair.\n * For IPv4 it's in the form x.y.z.k:port, example: \"127.0.0.1:1234\".\n * For IPv6 addresses we use [] around the IP part, like in \"[::1]:1234\".\n * For Unix sockets we use path:0, like in \"/tmp/redis:0\".\n *\n * A Peer ID always fits inside a buffer of NET_PEER_ID_LEN bytes, including\n * the null term.\n *\n * On failure the function still populates 'peerid' with the \"?:0\" string\n * in case you want to relax error checking or need to display something\n * anyway (see anetPeerToString implementation for more info). */\nvoid genClientPeerId(client *client, char *peerid,\n                            size_t peerid_len) {\n    if (client->flags & CLIENT_UNIX_SOCKET) {\n        /* Unix socket client. */\n        snprintf(peerid,peerid_len,\"%s:0\",server.unixsocket);\n    } else {\n        /* TCP client. */\n        connFormatPeer(client->conn,peerid,peerid_len);\n    }\n}\n\n/* This function returns the client peer id, by creating and caching it\n * if client->peerid is NULL, otherwise returning the cached value.\n * The Peer ID never changes during the life of the client, however it\n * is expensive to compute. */\nchar *getClientPeerId(client *c) {\n    char peerid[NET_PEER_ID_LEN];\n\n    if (c->peerid == NULL) {\n        genClientPeerId(c,peerid,sizeof(peerid));\n        c->peerid = sdsnew(peerid);\n    }\n    return c->peerid;\n}\n\n/* Concatenate a string representing the state of a client in a human\n * readable format, into the sds string 's'. */\nsds catClientInfoString(sds s, client *client) {\n    char flags[16], events[3], conninfo[CONN_INFO_LEN], *p;\n\n    p = flags;\n    if (client->flags & CLIENT_SLAVE) {\n        if (client->flags & CLIENT_MONITOR)\n            *p++ = 'O';\n        else\n            *p++ = 'S';\n    }\n    if (client->flags & CLIENT_MASTER) *p++ = 'M';\n    if (client->flags & CLIENT_PUBSUB) *p++ = 'P';\n    if (client->flags & CLIENT_MULTI) *p++ = 'x';\n    if (client->flags & CLIENT_BLOCKED) *p++ = 'b';\n    if (client->flags & CLIENT_TRACKING) *p++ = 't';\n    if (client->flags & CLIENT_TRACKING_BROKEN_REDIR) *p++ = 'R';\n    if (client->flags & CLIENT_DIRTY_CAS) *p++ = 'd';\n    if (client->flags & CLIENT_CLOSE_AFTER_REPLY) *p++ = 'c';\n    if (client->flags & CLIENT_UNBLOCKED) *p++ = 'u';\n    if (client->flags & CLIENT_CLOSE_ASAP) *p++ = 'A';\n    if (client->flags & CLIENT_UNIX_SOCKET) *p++ = 'U';\n    if (client->flags & CLIENT_READONLY) *p++ = 'r';\n    if (p == flags) *p++ = 'N';\n    *p++ = '\\0';\n\n    p = events;\n    if (client->conn) {\n        if (connHasReadHandler(client->conn)) *p++ = 'r';\n        if (connHasWriteHandler(client->conn)) *p++ = 'w';\n    }\n    *p = '\\0';\n\n    /* Compute the total memory consumed by this client. */\n    size_t obufmem = getClientOutputBufferMemoryUsage(client);\n    size_t total_mem = obufmem;\n    total_mem += zmalloc_size(client); /* includes client->buf */\n    total_mem += sdsZmallocSize(client->querybuf);\n    /* For efficiency (less work keeping track of the argv memory), it doesn't include the used memory\n     * i.e. unused sds space and internal fragmentation, just the string length. but this is enough to\n     * spot problematic clients. */\n    total_mem += client->argv_len_sum;\n    if (client->argv)\n        total_mem += zmalloc_size(client->argv);\n\n    return sdscatfmt(s,\n        \"id=%U addr=%s %s name=%s age=%I idle=%I flags=%s db=%i sub=%i psub=%i multi=%i qbuf=%U qbuf-free=%U argv-mem=%U obl=%U oll=%U omem=%U tot-mem=%U events=%s cmd=%s user=%s\",\n        (unsigned long long) client->id,\n        getClientPeerId(client),\n        connGetInfo(client->conn, conninfo, sizeof(conninfo)),\n        client->name ? (char*)client->name->ptr : \"\",\n        (long long)(server.unixtime - client->ctime),\n        (long long)(server.unixtime - client->lastinteraction),\n        flags,\n        client->db->id,\n        (int) dictSize(client->pubsub_channels),\n        (int) listLength(client->pubsub_patterns),\n        (client->flags & CLIENT_MULTI) ? client->mstate.count : -1,\n        (unsigned long long) sdslen(client->querybuf),\n        (unsigned long long) sdsavail(client->querybuf),\n        (unsigned long long) client->argv_len_sum,\n        (unsigned long long) client->bufpos,\n        (unsigned long long) listLength(client->reply),\n        (unsigned long long) obufmem, /* should not include client->buf since we want to see 0 for static clients. */\n        (unsigned long long) total_mem,\n        events,\n        client->lastcmd ? client->lastcmd->name : \"NULL\",\n        client->user ? client->user->name : \"(superuser)\");\n}\n\nsds getAllClientsInfoString(int type) {\n    listNode *ln;\n    listIter li;\n    client *client;\n    sds o = sdsnewlen(SDS_NOINIT,200*listLength(server.clients));\n    sdsclear(o);\n    listRewind(server.clients,&li);\n    while ((ln = listNext(&li)) != NULL) {\n        client = listNodeValue(ln);\n        if (type != -1 && getClientType(client) != type) continue;\n        o = catClientInfoString(o,client);\n        o = sdscatlen(o,\"\\n\",1);\n    }\n    return o;\n}\n\n/* This function implements CLIENT SETNAME, including replying to the\n * user with an error if the charset is wrong (in that case C_ERR is\n * returned). If the function succeeeded C_OK is returned, and it's up\n * to the caller to send a reply if needed.\n *\n * Setting an empty string as name has the effect of unsetting the\n * currently set name: the client will remain unnamed.\n *\n * This function is also used to implement the HELLO SETNAME option. */\nint clientSetNameOrReply(client *c, robj *name) {\n    int len = sdslen(name->ptr);\n    char *p = name->ptr;\n\n    /* Setting the client name to an empty string actually removes\n     * the current name. */\n    if (len == 0) {\n        if (c->name) decrRefCount(c->name);\n        c->name = NULL;\n        return C_OK;\n    }\n\n    /* Otherwise check if the charset is ok. We need to do this otherwise\n     * CLIENT LIST format will break. You should always be able to\n     * split by space to get the different fields. */\n    for (int j = 0; j < len; j++) {\n        if (p[j] < '!' || p[j] > '~') { /* ASCII is assumed. */\n            addReplyError(c,\n                \"Client names cannot contain spaces, \"\n                \"newlines or special characters.\");\n            return C_ERR;\n        }\n    }\n    if (c->name) decrRefCount(c->name);\n    c->name = name;\n    incrRefCount(name);\n    return C_OK;\n}\n\nvoid clientCommand(client *c) {\n    listNode *ln;\n    listIter li;\n\n    if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,\"help\")) {\n        const char *help[] = {\n\"ID                     -- Return the ID of the current connection.\",\n\"GETNAME                -- Return the name of the current connection.\",\n\"KILL <ip:port>         -- Kill connection made from <ip:port>.\",\n\"KILL <option> <value> [option value ...] -- Kill connections. Options are:\",\n\"     ADDR <ip:port>                      -- Kill connection made from <ip:port>\",\n\"     TYPE (normal|master|replica|pubsub) -- Kill connections by type.\",\n\"     USER <username>   -- Kill connections authenticated with such user.\",\n\"     SKIPME (yes|no)   -- Skip killing current connection (default: yes).\",\n\"LIST [options ...]     -- Return information about client connections. Options:\",\n\"     TYPE (normal|master|replica|pubsub) -- Return clients of specified type.\",\n\"PAUSE <timeout>        -- Suspend all Redis clients for <timout> milliseconds.\",\n\"REPLY (on|off|skip)    -- Control the replies sent to the current connection.\",\n\"SETNAME <name>         -- Assign the name <name> to the current connection.\",\n\"UNBLOCK <clientid> [TIMEOUT|ERROR] -- Unblock the specified blocked client.\",\n\"TRACKING (on|off) [REDIRECT <id>] [BCAST] [PREFIX first] [PREFIX second] [OPTIN] [OPTOUT]... -- Enable client keys tracking for client side caching.\",\n\"CACHING  (yes|no)      -- Enable/Disable tracking of the keys for next command in OPTIN/OPTOUT mode.\",\n\"GETREDIR               -- Return the client ID we are redirecting to when tracking is enabled.\",\nNULL\n        };\n        addReplyHelp(c, help);\n    } else if (!strcasecmp(c->argv[1]->ptr,\"id\") && c->argc == 2) {\n        /* CLIENT ID */\n        addReplyLongLong(c,c->id);\n    } else if (!strcasecmp(c->argv[1]->ptr,\"list\")) {\n        /* CLIENT LIST */\n        int type = -1;\n        if (c->argc == 4 && !strcasecmp(c->argv[2]->ptr,\"type\")) {\n            type = getClientTypeByName(c->argv[3]->ptr);\n            if (type == -1) {\n                addReplyErrorFormat(c,\"Unknown client type '%s'\",\n                    (char*) c->argv[3]->ptr);\n                return;\n             }\n        } else if (c->argc != 2) {\n            addReply(c,shared.syntaxerr);\n            return;\n        }\n        sds o = getAllClientsInfoString(type);\n        addReplyVerbatim(c,o,sdslen(o),\"txt\");\n        sdsfree(o);\n    } else if (!strcasecmp(c->argv[1]->ptr,\"reply\") && c->argc == 3) {\n        /* CLIENT REPLY ON|OFF|SKIP */\n        if (!strcasecmp(c->argv[2]->ptr,\"on\")) {\n            c->flags &= ~(CLIENT_REPLY_SKIP|CLIENT_REPLY_OFF);\n            addReply(c,shared.ok);\n        } else if (!strcasecmp(c->argv[2]->ptr,\"off\")) {\n            c->flags |= CLIENT_REPLY_OFF;\n        } else if (!strcasecmp(c->argv[2]->ptr,\"skip\")) {\n            if (!(c->flags & CLIENT_REPLY_OFF))\n                c->flags |= CLIENT_REPLY_SKIP_NEXT;\n        } else {\n            addReply(c,shared.syntaxerr);\n            return;\n        }\n    } else if (!strcasecmp(c->argv[1]->ptr,\"kill\")) {\n        /* CLIENT KILL <ip:port>\n         * CLIENT KILL <option> [value] ... <option> [value] */\n        char *addr = NULL;\n        user *user = NULL;\n        int type = -1;\n        uint64_t id = 0;\n        int skipme = 1;\n        int killed = 0, close_this_client = 0;\n\n        if (c->argc == 3) {\n            /* Old style syntax: CLIENT KILL <addr> */\n            addr = c->argv[2]->ptr;\n            skipme = 0; /* With the old form, you can kill yourself. */\n        } else if (c->argc > 3) {\n            int i = 2; /* Next option index. */\n\n            /* New style syntax: parse options. */\n            while(i < c->argc) {\n                int moreargs = c->argc > i+1;\n\n                if (!strcasecmp(c->argv[i]->ptr,\"id\") && moreargs) {\n                    long long tmp;\n\n                    if (getLongLongFromObjectOrReply(c,c->argv[i+1],&tmp,NULL)\n                        != C_OK) return;\n                    id = tmp;\n                } else if (!strcasecmp(c->argv[i]->ptr,\"type\") && moreargs) {\n                    type = getClientTypeByName(c->argv[i+1]->ptr);\n                    if (type == -1) {\n                        addReplyErrorFormat(c,\"Unknown client type '%s'\",\n                            (char*) c->argv[i+1]->ptr);\n                        return;\n                    }\n                } else if (!strcasecmp(c->argv[i]->ptr,\"addr\") && moreargs) {\n                    addr = c->argv[i+1]->ptr;\n                } else if (!strcasecmp(c->argv[i]->ptr,\"user\") && moreargs) {\n                    user = ACLGetUserByName(c->argv[i+1]->ptr,\n                                            sdslen(c->argv[i+1]->ptr));\n                    if (user == NULL) {\n                        addReplyErrorFormat(c,\"No such user '%s'\",\n                            (char*) c->argv[i+1]->ptr);\n                        return;\n                    }\n                } else if (!strcasecmp(c->argv[i]->ptr,\"skipme\") && moreargs) {\n                    if (!strcasecmp(c->argv[i+1]->ptr,\"yes\")) {\n                        skipme = 1;\n                    } else if (!strcasecmp(c->argv[i+1]->ptr,\"no\")) {\n                        skipme = 0;\n                    } else {\n                        addReply(c,shared.syntaxerr);\n                        return;\n                    }\n                } else {\n                    addReply(c,shared.syntaxerr);\n                    return;\n                }\n                i += 2;\n            }\n        } else {\n            addReply(c,shared.syntaxerr);\n            return;\n        }\n\n        /* Iterate clients killing all the matching clients. */\n        listRewind(server.clients,&li);\n        while ((ln = listNext(&li)) != NULL) {\n            client *client = listNodeValue(ln);\n            if (addr && strcmp(getClientPeerId(client),addr) != 0) continue;\n            if (type != -1 && getClientType(client) != type) continue;\n            if (id != 0 && client->id != id) continue;\n            if (user && client->user != user) continue;\n            if (c == client && skipme) continue;\n\n            /* Kill it. */\n            if (c == client) {\n                close_this_client = 1;\n            } else {\n                freeClient(client);\n            }\n            killed++;\n        }\n\n        /* Reply according to old/new format. */\n        if (c->argc == 3) {\n            if (killed == 0)\n                addReplyError(c,\"No such client\");\n            else\n                addReply(c,shared.ok);\n        } else {\n            addReplyLongLong(c,killed);\n        }\n\n        /* If this client has to be closed, flag it as CLOSE_AFTER_REPLY\n         * only after we queued the reply to its output buffers. */\n        if (close_this_client) c->flags |= CLIENT_CLOSE_AFTER_REPLY;\n    } else if (!strcasecmp(c->argv[1]->ptr,\"unblock\") && (c->argc == 3 ||\n                                                          c->argc == 4))\n    {\n        /* CLIENT UNBLOCK <id> [timeout|error] */\n        long long id;\n        int unblock_error = 0;\n\n        if (c->argc == 4) {\n            if (!strcasecmp(c->argv[3]->ptr,\"timeout\")) {\n                unblock_error = 0;\n            } else if (!strcasecmp(c->argv[3]->ptr,\"error\")) {\n                unblock_error = 1;\n            } else {\n                addReplyError(c,\n                    \"CLIENT UNBLOCK reason should be TIMEOUT or ERROR\");\n                return;\n            }\n        }\n        if (getLongLongFromObjectOrReply(c,c->argv[2],&id,NULL)\n            != C_OK) return;\n        struct client *target = lookupClientByID(id);\n        if (target && target->flags & CLIENT_BLOCKED) {\n            if (unblock_error)\n                addReplyError(target,\n                    \"-UNBLOCKED client unblocked via CLIENT UNBLOCK\");\n            else\n                replyToBlockedClientTimedOut(target);\n            unblockClient(target);\n            addReply(c,shared.cone);\n        } else {\n            addReply(c,shared.czero);\n        }\n    } else if (!strcasecmp(c->argv[1]->ptr,\"setname\") && c->argc == 3) {\n        /* CLIENT SETNAME */\n        if (clientSetNameOrReply(c,c->argv[2]) == C_OK)\n            addReply(c,shared.ok);\n    } else if (!strcasecmp(c->argv[1]->ptr,\"getname\") && c->argc == 2) {\n        /* CLIENT GETNAME */\n        if (c->name)\n            addReplyBulk(c,c->name);\n        else\n            addReplyNull(c);\n    } else if (!strcasecmp(c->argv[1]->ptr,\"pause\") && c->argc == 3) {\n        /* CLIENT PAUSE */\n        long long duration;\n\n        if (getTimeoutFromObjectOrReply(c,c->argv[2],&duration,\n                UNIT_MILLISECONDS) != C_OK) return;\n        pauseClients(duration);\n        addReply(c,shared.ok);\n    } else if (!strcasecmp(c->argv[1]->ptr,\"tracking\") && c->argc >= 3) {\n        /* CLIENT TRACKING (on|off) [REDIRECT <id>] [BCAST] [PREFIX first]\n         *                          [PREFIX second] [OPTIN] [OPTOUT] ... */\n        long long redir = 0;\n        uint64_t options = 0;\n        robj **prefix = NULL;\n        size_t numprefix = 0;\n\n        /* Parse the options. */\n        for (int j = 3; j < c->argc; j++) {\n            int moreargs = (c->argc-1) - j;\n\n            if (!strcasecmp(c->argv[j]->ptr,\"redirect\") && moreargs) {\n                j++;\n                if (redir != 0) {\n                    addReplyError(c,\"A client can only redirect to a single \"\n                                    \"other client\");\n                    zfree(prefix);\n                    return;\n                }\n\n                if (getLongLongFromObjectOrReply(c,c->argv[j],&redir,NULL) !=\n                    C_OK)\n                {\n                    zfree(prefix);\n                    return;\n                }\n                /* We will require the client with the specified ID to exist\n                 * right now, even if it is possible that it gets disconnected\n                 * later. Still a valid sanity check. */\n                if (lookupClientByID(redir) == NULL) {\n                    addReplyError(c,\"The client ID you want redirect to \"\n                                    \"does not exist\");\n                    zfree(prefix);\n                    return;\n                }\n            } else if (!strcasecmp(c->argv[j]->ptr,\"bcast\")) {\n                options |= CLIENT_TRACKING_BCAST;\n            } else if (!strcasecmp(c->argv[j]->ptr,\"optin\")) {\n                options |= CLIENT_TRACKING_OPTIN;\n            } else if (!strcasecmp(c->argv[j]->ptr,\"optout\")) {\n                options |= CLIENT_TRACKING_OPTOUT;\n            } else if (!strcasecmp(c->argv[j]->ptr,\"noloop\")) {\n                options |= CLIENT_TRACKING_NOLOOP;\n            } else if (!strcasecmp(c->argv[j]->ptr,\"prefix\") && moreargs) {\n                j++;\n                prefix = zrealloc(prefix,sizeof(robj*)*(numprefix+1));\n                prefix[numprefix++] = c->argv[j];\n            } else {\n                zfree(prefix);\n                addReply(c,shared.syntaxerr);\n                return;\n            }\n        }\n\n        /* Options are ok: enable or disable the tracking for this client. */\n        if (!strcasecmp(c->argv[2]->ptr,\"on\")) {\n            /* Before enabling tracking, make sure options are compatible\n             * among each other and with the current state of the client. */\n            if (!(options & CLIENT_TRACKING_BCAST) && numprefix) {\n                addReplyError(c,\n                    \"PREFIX option requires BCAST mode to be enabled\");\n                zfree(prefix);\n                return;\n            }\n\n            if (c->flags & CLIENT_TRACKING) {\n                int oldbcast = !!(c->flags & CLIENT_TRACKING_BCAST);\n                int newbcast = !!(options & CLIENT_TRACKING_BCAST);\n                if (oldbcast != newbcast) {\n                    addReplyError(c,\n                    \"You can't switch BCAST mode on/off before disabling \"\n                    \"tracking for this client, and then re-enabling it with \"\n                    \"a different mode.\");\n                    zfree(prefix);\n                    return;\n                }\n            }\n\n            if (options & CLIENT_TRACKING_BCAST &&\n                options & (CLIENT_TRACKING_OPTIN|CLIENT_TRACKING_OPTOUT))\n            {\n                addReplyError(c,\n                \"OPTIN and OPTOUT are not compatible with BCAST\");\n                zfree(prefix);\n                return;\n            }\n\n            if (options & CLIENT_TRACKING_OPTIN && options & CLIENT_TRACKING_OPTOUT)\n            {\n                addReplyError(c,\n                \"You can't specify both OPTIN mode and OPTOUT mode\");\n                zfree(prefix);\n                return;\n            }\n\n            if ((options & CLIENT_TRACKING_OPTIN && c->flags & CLIENT_TRACKING_OPTOUT) ||\n                (options & CLIENT_TRACKING_OPTOUT && c->flags & CLIENT_TRACKING_OPTIN))\n            {\n                addReplyError(c,\n                \"You can't switch OPTIN/OPTOUT mode before disabling \"\n                \"tracking for this client, and then re-enabling it with \"\n                \"a different mode.\");\n                zfree(prefix);\n                return;\n            }\n\n            enableTracking(c,redir,options,prefix,numprefix);\n        } else if (!strcasecmp(c->argv[2]->ptr,\"off\")) {\n            disableTracking(c);\n        } else {\n            zfree(prefix);\n            addReply(c,shared.syntaxerr);\n            return;\n        }\n        zfree(prefix);\n        addReply(c,shared.ok);\n    } else if (!strcasecmp(c->argv[1]->ptr,\"caching\") && c->argc >= 3) {\n        if (!(c->flags & CLIENT_TRACKING)) {\n            addReplyError(c,\"CLIENT CACHING can be called only when the \"\n                            \"client is in tracking mode with OPTIN or \"\n                            \"OPTOUT mode enabled\");\n            return;\n        }\n\n        char *opt = c->argv[2]->ptr;\n        if (!strcasecmp(opt,\"yes\")) {\n            if (c->flags & CLIENT_TRACKING_OPTIN) {\n                c->flags |= CLIENT_TRACKING_CACHING;\n            } else {\n                addReplyError(c,\"CLIENT CACHING YES is only valid when tracking is enabled in OPTIN mode.\");\n                return;\n            }\n        } else if (!strcasecmp(opt,\"no\")) {\n            if (c->flags & CLIENT_TRACKING_OPTOUT) {\n                c->flags |= CLIENT_TRACKING_CACHING;\n            } else {\n                addReplyError(c,\"CLIENT CACHING NO is only valid when tracking is enabled in OPTOUT mode.\");\n                return;\n            }\n        } else {\n            addReply(c,shared.syntaxerr);\n            return;\n        }\n\n        /* Common reply for when we succeeded. */\n        addReply(c,shared.ok);\n    } else if (!strcasecmp(c->argv[1]->ptr,\"getredir\") && c->argc == 2) {\n        /* CLIENT GETREDIR */\n        if (c->flags & CLIENT_TRACKING) {\n            addReplyLongLong(c,c->client_tracking_redirection);\n        } else {\n            addReplyLongLong(c,-1);\n        }\n    } else {\n        addReplyErrorFormat(c, \"Unknown subcommand or wrong number of arguments for '%s'. Try CLIENT HELP\", (char*)c->argv[1]->ptr);\n    }\n}\n\n/* HELLO <protocol-version> [AUTH <user> <password>] [SETNAME <name>] */\nvoid helloCommand(client *c) {\n    long long ver;\n\n    if (getLongLongFromObject(c->argv[1],&ver) != C_OK ||\n        ver < 2 || ver > 3)\n    {\n        addReplyError(c,\"-NOPROTO unsupported protocol version\");\n        return;\n    }\n\n    for (int j = 2; j < c->argc; j++) {\n        int moreargs = (c->argc-1) - j;\n        const char *opt = c->argv[j]->ptr;\n        if (!strcasecmp(opt,\"AUTH\") && moreargs >= 2) {\n            if (ACLAuthenticateUser(c, c->argv[j+1], c->argv[j+2]) == C_ERR) {\n                addReplyError(c,\"-WRONGPASS invalid username-password pair\");\n                return;\n            }\n            j += 2;\n        } else if (!strcasecmp(opt,\"SETNAME\") && moreargs) {\n            if (clientSetNameOrReply(c, c->argv[j+1]) == C_ERR) return;\n            j++;\n        } else {\n            addReplyErrorFormat(c,\"Syntax error in HELLO option '%s'\",opt);\n            return;\n        }\n    }\n\n    /* At this point we need to be authenticated to continue. */\n    if (!c->authenticated) {\n        addReplyError(c,\"-NOAUTH HELLO must be called with the client already \"\n                        \"authenticated, otherwise the HELLO AUTH <user> <pass> \"\n                        \"option can be used to authenticate the client and \"\n                        \"select the RESP protocol version at the same time\");\n        return;\n    }\n\n    /* Let's switch to the specified RESP mode. */\n    c->resp = ver;\n    addReplyMapLen(c,6 + !server.sentinel_mode);\n\n    addReplyBulkCString(c,\"server\");\n    addReplyBulkCString(c,\"redis\");\n\n    addReplyBulkCString(c,\"version\");\n    addReplyBulkCString(c,REDIS_VERSION);\n\n    addReplyBulkCString(c,\"proto\");\n    addReplyLongLong(c,ver);\n\n    addReplyBulkCString(c,\"id\");\n    addReplyLongLong(c,c->id);\n\n    addReplyBulkCString(c,\"mode\");\n    if (server.sentinel_mode) addReplyBulkCString(c,\"sentinel\");\n    else if (server.cluster_enabled) addReplyBulkCString(c,\"cluster\");\n    else addReplyBulkCString(c,\"standalone\");\n\n    if (!server.sentinel_mode) {\n        addReplyBulkCString(c,\"role\");\n        addReplyBulkCString(c,server.masterhost ? \"replica\" : \"master\");\n    }\n\n    addReplyBulkCString(c,\"modules\");\n    addReplyLoadedModules(c);\n}\n\n/* This callback is bound to POST and \"Host:\" command names. Those are not\n * really commands, but are used in security attacks in order to talk to\n * Redis instances via HTTP, with a technique called \"cross protocol scripting\"\n * which exploits the fact that services like Redis will discard invalid\n * HTTP headers and will process what follows.\n *\n * As a protection against this attack, Redis will terminate the connection\n * when a POST or \"Host:\" header is seen, and will log the event from\n * time to time (to avoid creating a DOS as a result of too many logs). */\nvoid securityWarningCommand(client *c) {\n    static time_t logged_time;\n    time_t now = time(NULL);\n\n    if (labs(now-logged_time) > 60) {\n        serverLog(LL_WARNING,\"Possible SECURITY ATTACK detected. It looks like somebody is sending POST or Host: commands to Redis. This is likely due to an attacker attempting to use Cross Protocol Scripting to compromise your Redis instance. Connection aborted.\");\n        logged_time = now;\n    }\n    freeClientAsync(c);\n}\n\n/* Rewrite the command vector of the client. All the new objects ref count\n * is incremented. The old command vector is freed, and the old objects\n * ref count is decremented. */\nvoid rewriteClientCommandVector(client *c, int argc, ...) {\n    va_list ap;\n    int j;\n    robj **argv; /* The new argument vector */\n\n    argv = zmalloc(sizeof(robj*)*argc);\n    va_start(ap,argc);\n    for (j = 0; j < argc; j++) {\n        robj *a;\n\n        a = va_arg(ap, robj*);\n        argv[j] = a;\n        incrRefCount(a);\n    }\n    /* We free the objects in the original vector at the end, so we are\n     * sure that if the same objects are reused in the new vector the\n     * refcount gets incremented before it gets decremented. */\n    for (j = 0; j < c->argc; j++) decrRefCount(c->argv[j]);\n    zfree(c->argv);\n    /* Replace argv and argc with our new versions. */\n    c->argv = argv;\n    c->argc = argc;\n    c->argv_len_sum = 0;\n    for (j = 0; j < c->argc; j++)\n        if (c->argv[j])\n            c->argv_len_sum += getStringObjectLen(c->argv[j]);\n    c->cmd = lookupCommandOrOriginal(c->argv[0]->ptr);\n    serverAssertWithInfo(c,NULL,c->cmd != NULL);\n    va_end(ap);\n}\n\n/* Completely replace the client command vector with the provided one. */\nvoid replaceClientCommandVector(client *c, int argc, robj **argv) {\n    int j;\n    freeClientArgv(c);\n    zfree(c->argv);\n    c->argv = argv;\n    c->argc = argc;\n    c->argv_len_sum = 0;\n    for (j = 0; j < c->argc; j++)\n        if (c->argv[j])\n            c->argv_len_sum += getStringObjectLen(c->argv[j]);\n    c->cmd = lookupCommandOrOriginal(c->argv[0]->ptr);\n    serverAssertWithInfo(c,NULL,c->cmd != NULL);\n}\n\n/* Rewrite a single item in the command vector.\n * The new val ref count is incremented, and the old decremented.\n *\n * It is possible to specify an argument over the current size of the\n * argument vector: in this case the array of objects gets reallocated\n * and c->argc set to the max value. However it's up to the caller to\n *\n * 1. Make sure there are no \"holes\" and all the arguments are set.\n * 2. If the original argument vector was longer than the one we\n *    want to end with, it's up to the caller to set c->argc and\n *    free the no longer used objects on c->argv. */\nvoid rewriteClientCommandArgument(client *c, int i, robj *newval) {\n    robj *oldval;\n\n    if (i >= c->argc) {\n        c->argv = zrealloc(c->argv,sizeof(robj*)*(i+1));\n        c->argc = i+1;\n        c->argv[i] = NULL;\n    }\n    oldval = c->argv[i];\n    if (oldval) c->argv_len_sum -= getStringObjectLen(oldval);\n    if (newval) c->argv_len_sum += getStringObjectLen(newval);\n    c->argv[i] = newval;\n    incrRefCount(newval);\n    if (oldval) decrRefCount(oldval);\n\n    /* If this is the command name make sure to fix c->cmd. */\n    if (i == 0) {\n        c->cmd = lookupCommandOrOriginal(c->argv[0]->ptr);\n        serverAssertWithInfo(c,NULL,c->cmd != NULL);\n    }\n}\n\n/* This function returns the number of bytes that Redis is\n * using to store the reply still not read by the client.\n *\n * Note: this function is very fast so can be called as many time as\n * the caller wishes. The main usage of this function currently is\n * enforcing the client output length limits. */\nunsigned long getClientOutputBufferMemoryUsage(client *c) {\n    unsigned long list_item_size = sizeof(listNode) + sizeof(clientReplyBlock);\n    return c->reply_bytes + (list_item_size*listLength(c->reply));\n}\n\n/* Get the class of a client, used in order to enforce limits to different\n * classes of clients.\n *\n * The function will return one of the following:\n * CLIENT_TYPE_NORMAL -> Normal client\n * CLIENT_TYPE_SLAVE  -> Slave\n * CLIENT_TYPE_PUBSUB -> Client subscribed to Pub/Sub channels\n * CLIENT_TYPE_MASTER -> The client representing our replication master.\n */\nint getClientType(client *c) {\n    if (c->flags & CLIENT_MASTER) return CLIENT_TYPE_MASTER;\n    /* Even though MONITOR clients are marked as replicas, we\n     * want the expose them as normal clients. */\n    if ((c->flags & CLIENT_SLAVE) && !(c->flags & CLIENT_MONITOR))\n        return CLIENT_TYPE_SLAVE;\n    if (c->flags & CLIENT_PUBSUB) return CLIENT_TYPE_PUBSUB;\n    return CLIENT_TYPE_NORMAL;\n}\n\nint getClientTypeByName(char *name) {\n    if (!strcasecmp(name,\"normal\")) return CLIENT_TYPE_NORMAL;\n    else if (!strcasecmp(name,\"slave\")) return CLIENT_TYPE_SLAVE;\n    else if (!strcasecmp(name,\"replica\")) return CLIENT_TYPE_SLAVE;\n    else if (!strcasecmp(name,\"pubsub\")) return CLIENT_TYPE_PUBSUB;\n    else if (!strcasecmp(name,\"master\")) return CLIENT_TYPE_MASTER;\n    else return -1;\n}\n\nchar *getClientTypeName(int class) {\n    switch(class) {\n    case CLIENT_TYPE_NORMAL: return \"normal\";\n    case CLIENT_TYPE_SLAVE:  return \"slave\";\n    case CLIENT_TYPE_PUBSUB: return \"pubsub\";\n    case CLIENT_TYPE_MASTER: return \"master\";\n    default:                       return NULL;\n    }\n}\n\n/* The function checks if the client reached output buffer soft or hard\n * limit, and also update the state needed to check the soft limit as\n * a side effect.\n *\n * Return value: non-zero if the client reached the soft or the hard limit.\n *               Otherwise zero is returned. */\nint checkClientOutputBufferLimits(client *c) {\n    int soft = 0, hard = 0, class;\n    unsigned long used_mem = getClientOutputBufferMemoryUsage(c);\n\n    class = getClientType(c);\n    /* For the purpose of output buffer limiting, masters are handled\n     * like normal clients. */\n    if (class == CLIENT_TYPE_MASTER) class = CLIENT_TYPE_NORMAL;\n\n    if (server.client_obuf_limits[class].hard_limit_bytes &&\n        used_mem >= server.client_obuf_limits[class].hard_limit_bytes)\n        hard = 1;\n    if (server.client_obuf_limits[class].soft_limit_bytes &&\n        used_mem >= server.client_obuf_limits[class].soft_limit_bytes)\n        soft = 1;\n\n    /* We need to check if the soft limit is reached continuously for the\n     * specified amount of seconds. */\n    if (soft) {\n        if (c->obuf_soft_limit_reached_time == 0) {\n            c->obuf_soft_limit_reached_time = server.unixtime;\n            soft = 0; /* First time we see the soft limit reached */\n        } else {\n            time_t elapsed = server.unixtime - c->obuf_soft_limit_reached_time;\n\n            if (elapsed <=\n                server.client_obuf_limits[class].soft_limit_seconds) {\n                soft = 0; /* The client still did not reached the max number of\n                             seconds for the soft limit to be considered\n                             reached. */\n            }\n        }\n    } else {\n        c->obuf_soft_limit_reached_time = 0;\n    }\n    return soft || hard;\n}\n\n/* Asynchronously close a client if soft or hard limit is reached on the\n * output buffer size. The caller can check if the client will be closed\n * checking if the client CLIENT_CLOSE_ASAP flag is set.\n *\n * Note: we need to close the client asynchronously because this function is\n * called from contexts where the client can't be freed safely, i.e. from the\n * lower level functions pushing data inside the client output buffers. */\nvoid asyncCloseClientOnOutputBufferLimitReached(client *c) {\n    if (!c->conn) return; /* It is unsafe to free fake clients. */\n    serverAssert(c->reply_bytes < SIZE_MAX-(1024*64));\n    if (c->reply_bytes == 0 || c->flags & CLIENT_CLOSE_ASAP) return;\n    if (checkClientOutputBufferLimits(c)) {\n        sds client = catClientInfoString(sdsempty(),c);\n\n        freeClientAsync(c);\n        serverLog(LL_WARNING,\"Client %s scheduled to be closed ASAP for overcoming of output buffer limits.\", client);\n        sdsfree(client);\n    }\n}\n\n/* Helper function used by freeMemoryIfNeeded() in order to flush slaves\n * output buffers without returning control to the event loop.\n * This is also called by SHUTDOWN for a best-effort attempt to send\n * slaves the latest writes. */\nvoid flushSlavesOutputBuffers(void) {\n    listIter li;\n    listNode *ln;\n\n    listRewind(server.slaves,&li);\n    while((ln = listNext(&li))) {\n        client *slave = listNodeValue(ln);\n        int can_receive_writes = connHasWriteHandler(slave->conn) ||\n                                 (slave->flags & CLIENT_PENDING_WRITE);\n\n        /* We don't want to send the pending data to the replica in a few\n         * cases:\n         *\n         * 1. For some reason there is neither the write handler installed\n         *    nor the client is flagged as to have pending writes: for some\n         *    reason this replica may not be set to receive data. This is\n         *    just for the sake of defensive programming.\n         *\n         * 2. The put_online_on_ack flag is true. To know why we don't want\n         *    to send data to the replica in this case, please grep for the\n         *    flag for this flag.\n         *\n         * 3. Obviously if the slave is not ONLINE.\n         */\n        if (slave->replstate == SLAVE_STATE_ONLINE &&\n            can_receive_writes &&\n            !slave->repl_put_online_on_ack &&\n            clientHasPendingReplies(slave))\n        {\n            writeToClient(slave,0);\n        }\n    }\n}\n\n/* Pause clients up to the specified unixtime (in ms). While clients\n * are paused no command is processed from clients, so the data set can't\n * change during that time.\n *\n * However while this function pauses normal and Pub/Sub clients, slaves are\n * still served, so this function can be used on server upgrades where it is\n * required that slaves process the latest bytes from the replication stream\n * before being turned to masters.\n *\n * This function is also internally used by Redis Cluster for the manual\n * failover procedure implemented by CLUSTER FAILOVER.\n *\n * The function always succeed, even if there is already a pause in progress.\n * In such a case, the pause is extended if the duration is more than the\n * time left for the previous duration. However if the duration is smaller\n * than the time left for the previous pause, no change is made to the\n * left duration. */\nvoid pauseClients(mstime_t end) {\n    if (!server.clients_paused || end > server.clients_pause_end_time)\n        server.clients_pause_end_time = end;\n    server.clients_paused = 1;\n}\n\n/* Return non-zero if clients are currently paused. As a side effect the\n * function checks if the pause time was reached and clear it. */\nint clientsArePaused(void) {\n    if (server.clients_paused &&\n        server.clients_pause_end_time < server.mstime)\n    {\n        listNode *ln;\n        listIter li;\n        client *c;\n\n        server.clients_paused = 0;\n\n        /* Put all the clients in the unblocked clients queue in order to\n         * force the re-processing of the input buffer if any. */\n        listRewind(server.clients,&li);\n        while ((ln = listNext(&li)) != NULL) {\n            c = listNodeValue(ln);\n\n            /* Don't touch slaves and blocked clients.\n             * The latter pending requests will be processed when unblocked. */\n            if (c->flags & (CLIENT_SLAVE|CLIENT_BLOCKED)) continue;\n            queueClientForReprocessing(c);\n        }\n    }\n    return server.clients_paused;\n}\n\n/* This function is called by Redis in order to process a few events from\n * time to time while blocked into some not interruptible operation.\n * This allows to reply to clients with the -LOADING error while loading the\n * data set at startup or after a full resynchronization with the master\n * and so forth.\n *\n * It calls the event loop in order to process a few events. Specifically we\n * try to call the event loop 4 times as long as we receive acknowledge that\n * some event was processed, in order to go forward with the accept, read,\n * write, close sequence needed to serve a client.\n *\n * The function returns the total number of events processed. */\nvoid processEventsWhileBlocked(void) {\n    int iterations = 4; /* See the function top-comment. */\n\n    /* Note: when we are processing events while blocked (for instance during\n     * busy Lua scripts), we set a global flag. When such flag is set, we\n     * avoid handling the read part of clients using threaded I/O.\n     * See https://github.com/antirez/redis/issues/6988 for more info. */\n    ProcessingEventsWhileBlocked = 1;\n    while (iterations--) {\n        long long startval = server.events_processed_while_blocked;\n        long long ae_events = aeProcessEvents(server.el,\n            AE_FILE_EVENTS|AE_DONT_WAIT|\n            AE_CALL_BEFORE_SLEEP|AE_CALL_AFTER_SLEEP);\n        /* Note that server.events_processed_while_blocked will also get\n         * incremeted by callbacks called by the event loop handlers. */\n        server.events_processed_while_blocked += ae_events;\n        long long events = server.events_processed_while_blocked - startval;\n        if (!events) break;\n    }\n    ProcessingEventsWhileBlocked = 0;\n}\n\n/* ==========================================================================\n * Threaded I/O\n * ========================================================================== */\n\nint tio_debug = 0;\n\n#define IO_THREADS_MAX_NUM 128\n#define IO_THREADS_OP_READ 0\n#define IO_THREADS_OP_WRITE 1\n\npthread_t io_threads[IO_THREADS_MAX_NUM];\npthread_mutex_t io_threads_mutex[IO_THREADS_MAX_NUM];\n_Atomic unsigned long io_threads_pending[IO_THREADS_MAX_NUM];\nint io_threads_op;      /* IO_THREADS_OP_WRITE or IO_THREADS_OP_READ. */\n\n/* This is the list of clients each thread will serve when threaded I/O is\n * used. We spawn io_threads_num-1 threads, since one is the main thread\n * itself. */\nlist *io_threads_list[IO_THREADS_MAX_NUM];\n\nvoid *IOThreadMain(void *myid) {\n    /* The ID is the thread number (from 0 to server.iothreads_num-1), and is\n     * used by the thread to just manipulate a single sub-array of clients. */\n    long id = (unsigned long)myid;\n    char thdname[16];\n\n    snprintf(thdname, sizeof(thdname), \"io_thd_%ld\", id);\n    redis_set_thread_title(thdname);\n    redisSetCpuAffinity(server.server_cpulist);\n    makeThreadKillable();\n\n    while(1) {\n        /* Wait for start */\n        for (int j = 0; j < 1000000; j++) {\n            if (io_threads_pending[id] != 0) break;\n        }\n\n        /* Give the main thread a chance to stop this thread. */\n        if (io_threads_pending[id] == 0) {\n            pthread_mutex_lock(&io_threads_mutex[id]);\n            pthread_mutex_unlock(&io_threads_mutex[id]);\n            continue;\n        }\n\n        serverAssert(io_threads_pending[id] != 0);\n\n        if (tio_debug) printf(\"[%ld] %d to handle\\n\", id, (int)listLength(io_threads_list[id]));\n\n        /* Process: note that the main thread will never touch our list\n         * before we drop the pending count to 0. */\n        listIter li;\n        listNode *ln;\n        listRewind(io_threads_list[id],&li);\n        while((ln = listNext(&li))) {\n            client *c = listNodeValue(ln);\n            if (io_threads_op == IO_THREADS_OP_WRITE) {\n                writeToClient(c,0);\n            } else if (io_threads_op == IO_THREADS_OP_READ) {\n                readQueryFromClient(c->conn);\n            } else {\n                serverPanic(\"io_threads_op value is unknown\");\n            }\n        }\n        listEmpty(io_threads_list[id]);\n        io_threads_pending[id] = 0;\n\n        if (tio_debug) printf(\"[%ld] Done\\n\", id);\n    }\n}\n\n/* Initialize the data structures needed for threaded I/O. */\nvoid initThreadedIO(void) {\n    server.io_threads_active = 0; /* We start with threads not active. */\n\n    /* Don't spawn any thread if the user selected a single thread:\n     * we'll handle I/O directly from the main thread. */\n    if (server.io_threads_num == 1) return;\n\n    if (server.io_threads_num > IO_THREADS_MAX_NUM) {\n        serverLog(LL_WARNING,\"Fatal: too many I/O threads configured. \"\n                             \"The maximum number is %d.\", IO_THREADS_MAX_NUM);\n        exit(1);\n    }\n\n    /* Spawn and initialize the I/O threads. */\n    for (int i = 0; i < server.io_threads_num; i++) {\n        /* Things we do for all the threads including the main thread. */\n        io_threads_list[i] = listCreate();\n        if (i == 0) continue; /* Thread 0 is the main thread. */\n\n        /* Things we do only for the additional threads. */\n        pthread_t tid;\n        pthread_mutex_init(&io_threads_mutex[i],NULL);\n        io_threads_pending[i] = 0;\n        pthread_mutex_lock(&io_threads_mutex[i]); /* Thread will be stopped. */\n        if (pthread_create(&tid,NULL,IOThreadMain,(void*)(long)i) != 0) {\n            serverLog(LL_WARNING,\"Fatal: Can't initialize IO thread.\");\n            exit(1);\n        }\n        io_threads[i] = tid;\n    }\n}\n\nvoid killIOThreads(void) {\n    int err, j;\n    for (j = 0; j < server.io_threads_num; j++) {\n        if (io_threads[j] == pthread_self()) continue;\n        if (io_threads[j] && pthread_cancel(io_threads[j]) == 0) {\n            if ((err = pthread_join(io_threads[j],NULL)) != 0) {\n                serverLog(LL_WARNING,\n                    \"IO thread(tid:%lu) can not be joined: %s\",\n                        (unsigned long)io_threads[j], strerror(err));\n            } else {\n                serverLog(LL_WARNING,\n                    \"IO thread(tid:%lu) terminated\",(unsigned long)io_threads[j]);\n            }\n        }\n    }\n}\n\nvoid startThreadedIO(void) {\n    if (tio_debug) { printf(\"S\"); fflush(stdout); }\n    if (tio_debug) printf(\"--- STARTING THREADED IO ---\\n\");\n    serverAssert(server.io_threads_active == 0);\n    for (int j = 1; j < server.io_threads_num; j++)\n        pthread_mutex_unlock(&io_threads_mutex[j]);\n    server.io_threads_active = 1;\n}\n\nvoid stopThreadedIO(void) {\n    /* We may have still clients with pending reads when this function\n     * is called: handle them before stopping the threads. */\n    handleClientsWithPendingReadsUsingThreads();\n    if (tio_debug) { printf(\"E\"); fflush(stdout); }\n    if (tio_debug) printf(\"--- STOPPING THREADED IO [R%d] [W%d] ---\\n\",\n        (int) listLength(server.clients_pending_read),\n        (int) listLength(server.clients_pending_write));\n    serverAssert(server.io_threads_active == 1);\n    for (int j = 1; j < server.io_threads_num; j++)\n        pthread_mutex_lock(&io_threads_mutex[j]);\n    server.io_threads_active = 0;\n}\n\n/* This function checks if there are not enough pending clients to justify\n * taking the I/O threads active: in that case I/O threads are stopped if\n * currently active. We track the pending writes as a measure of clients\n * we need to handle in parallel, however the I/O threading is disabled\n * globally for reads as well if we have too little pending clients.\n *\n * The function returns 0 if the I/O threading should be used because there\n * are enough active threads, otherwise 1 is returned and the I/O threads\n * could be possibly stopped (if already active) as a side effect. */\nint stopThreadedIOIfNeeded(void) {\n    int pending = listLength(server.clients_pending_write);\n\n    /* Return ASAP if IO threads are disabled (single threaded mode). */\n    if (server.io_threads_num == 1) return 1;\n\n    if (pending < (server.io_threads_num*2)) {\n        if (server.io_threads_active) stopThreadedIO();\n        return 1;\n    } else {\n        return 0;\n    }\n}\n\nint handleClientsWithPendingWritesUsingThreads(void) {\n    int processed = listLength(server.clients_pending_write);\n    if (processed == 0) return 0; /* Return ASAP if there are no clients. */\n\n    /* If I/O threads are disabled or we have few clients to serve, don't\n     * use I/O threads, but thejboring synchronous code. */\n    if (server.io_threads_num == 1 || stopThreadedIOIfNeeded()) {\n        return handleClientsWithPendingWrites();\n    }\n\n    /* Start threads if needed. */\n    if (!server.io_threads_active) startThreadedIO();\n\n    if (tio_debug) printf(\"%d TOTAL WRITE pending clients\\n\", processed);\n\n    /* Distribute the clients across N different lists. */\n    listIter li;\n    listNode *ln;\n    listRewind(server.clients_pending_write,&li);\n    int item_id = 0;\n    while((ln = listNext(&li))) {\n        client *c = listNodeValue(ln);\n        c->flags &= ~CLIENT_PENDING_WRITE;\n\n        /* Remove clients from the list of pending writes since\n         * they are going to be closed ASAP. */\n        if (c->flags & CLIENT_CLOSE_ASAP) {\n            listDelNode(server.clients_pending_write, ln);\n            continue;\n        }\n\n        int target_id = item_id % server.io_threads_num;\n        listAddNodeTail(io_threads_list[target_id],c);\n        item_id++;\n    }\n\n    /* Give the start condition to the waiting threads, by setting the\n     * start condition atomic var. */\n    io_threads_op = IO_THREADS_OP_WRITE;\n    for (int j = 1; j < server.io_threads_num; j++) {\n        int count = listLength(io_threads_list[j]);\n        io_threads_pending[j] = count;\n    }\n\n    /* Also use the main thread to process a slice of clients. */\n    listRewind(io_threads_list[0],&li);\n    while((ln = listNext(&li))) {\n        client *c = listNodeValue(ln);\n        writeToClient(c,0);\n    }\n    listEmpty(io_threads_list[0]);\n\n    /* Wait for all the other threads to end their work. */\n    while(1) {\n        unsigned long pending = 0;\n        for (int j = 1; j < server.io_threads_num; j++)\n            pending += io_threads_pending[j];\n        if (pending == 0) break;\n    }\n    if (tio_debug) printf(\"I/O WRITE All threads finshed\\n\");\n\n    /* Run the list of clients again to install the write handler where\n     * needed. */\n    listRewind(server.clients_pending_write,&li);\n    while((ln = listNext(&li))) {\n        client *c = listNodeValue(ln);\n\n        /* Install the write handler if there are pending writes in some\n         * of the clients. */\n        if (clientHasPendingReplies(c) &&\n                connSetWriteHandler(c->conn, sendReplyToClient) == AE_ERR)\n        {\n            freeClientAsync(c);\n        }\n    }\n    listEmpty(server.clients_pending_write);\n\n    /* Update processed count on server */\n    server.stat_io_writes_processed += processed;\n\n    return processed;\n}\n\n/* Return 1 if we want to handle the client read later using threaded I/O.\n * This is called by the readable handler of the event loop.\n * As a side effect of calling this function the client is put in the\n * pending read clients and flagged as such. */\nint postponeClientRead(client *c) {\n    if (server.io_threads_active &&\n        server.io_threads_do_reads &&\n        !clientsArePaused() &&\n        !ProcessingEventsWhileBlocked &&\n        !(c->flags & (CLIENT_MASTER|CLIENT_SLAVE|CLIENT_PENDING_READ)))\n    {\n        c->flags |= CLIENT_PENDING_READ;\n        listAddNodeHead(server.clients_pending_read,c);\n        return 1;\n    } else {\n        return 0;\n    }\n}\n\n/* When threaded I/O is also enabled for the reading + parsing side, the\n * readable handler will just put normal clients into a queue of clients to\n * process (instead of serving them synchronously). This function runs\n * the queue using the I/O threads, and process them in order to accumulate\n * the reads in the buffers, and also parse the first command available\n * rendering it in the client structures. */\nint handleClientsWithPendingReadsUsingThreads(void) {\n    if (!server.io_threads_active || !server.io_threads_do_reads) return 0;\n    int processed = listLength(server.clients_pending_read);\n    if (processed == 0) return 0;\n\n    if (tio_debug) printf(\"%d TOTAL READ pending clients\\n\", processed);\n\n    /* Distribute the clients across N different lists. */\n    listIter li;\n    listNode *ln;\n    listRewind(server.clients_pending_read,&li);\n    int item_id = 0;\n    while((ln = listNext(&li))) {\n        client *c = listNodeValue(ln);\n        int target_id = item_id % server.io_threads_num;\n        listAddNodeTail(io_threads_list[target_id],c);\n        item_id++;\n    }\n\n    /* Give the start condition to the waiting threads, by setting the\n     * start condition atomic var. */\n    io_threads_op = IO_THREADS_OP_READ;\n    for (int j = 1; j < server.io_threads_num; j++) {\n        int count = listLength(io_threads_list[j]);\n        io_threads_pending[j] = count;\n    }\n\n    /* Also use the main thread to process a slice of clients. */\n    listRewind(io_threads_list[0],&li);\n    while((ln = listNext(&li))) {\n        client *c = listNodeValue(ln);\n        readQueryFromClient(c->conn);\n    }\n    listEmpty(io_threads_list[0]);\n\n    /* Wait for all the other threads to end their work. */\n    while(1) {\n        unsigned long pending = 0;\n        for (int j = 1; j < server.io_threads_num; j++)\n            pending += io_threads_pending[j];\n        if (pending == 0) break;\n    }\n    if (tio_debug) printf(\"I/O READ All threads finshed\\n\");\n\n    /* Run the list of clients again to process the new buffers. */\n    while(listLength(server.clients_pending_read)) {\n        ln = listFirst(server.clients_pending_read);\n        client *c = listNodeValue(ln);\n        c->flags &= ~CLIENT_PENDING_READ;\n        listDelNode(server.clients_pending_read,ln);\n        /* Clients can become paused while executing the queued commands,\n         * so we need to check in between each command. If a pause was\n         * executed, we still remove the command and it will get picked up\n         * later when clients are unpaused and we re-queue all clients. */\n        if (clientsArePaused()) continue;\n\n        if (processPendingCommandsAndResetClient(c) == C_ERR) {\n            /* If the client is no longer valid, we avoid\n             * processing the client later. So we just go\n             * to the next. */\n            continue;\n        }\n        processInputBuffer(c);\n\n        /* We may have pending replies if a thread readQueryFromClient() produced\n         * replies and did not install a write handler (it can't).\n         */\n        if (!(c->flags & CLIENT_PENDING_WRITE) && clientHasPendingReplies(c))\n            clientInstallWriteHandler(c);\n    }\n\n    /* Update processed count on server */\n    server.stat_io_reads_processed += processed;\n\n    return processed;\n}\n", "/*\n * Copyright (c) 2009-2016, Salvatore Sanfilippo <antirez at gmail dot com>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"server.h\"\n#include \"cluster.h\"\n#include \"slowlog.h\"\n#include \"bio.h\"\n#include \"latency.h\"\n#include \"atomicvar.h\"\n#include \"mt19937-64.h\"\n\n#include <time.h>\n#include <signal.h>\n#include <sys/wait.h>\n#include <errno.h>\n#include <assert.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <arpa/inet.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/resource.h>\n#include <sys/uio.h>\n#include <sys/un.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <sys/resource.h>\n#include <sys/utsname.h>\n#include <locale.h>\n#include <sys/socket.h>\n\n#ifdef __linux__\n#include <sys/mman.h>\n#endif\n\n/* Our shared \"common\" objects */\n\nstruct sharedObjectsStruct shared;\n\n/* Global vars that are actually used as constants. The following double\n * values are used for double on-disk serialization, and are initialized\n * at runtime to avoid strange compiler optimizations. */\n\ndouble R_Zero, R_PosInf, R_NegInf, R_Nan;\n\n/*================================= Globals ================================= */\n\n/* Global vars */\nstruct redisServer server; /* Server global state */\n\n/* Our command table.\n *\n * Every entry is composed of the following fields:\n *\n * name:        A string representing the command name.\n *\n * function:    Pointer to the C function implementing the command.\n *\n * arity:       Number of arguments, it is possible to use -N to say >= N\n *\n * sflags:      Command flags as string. See below for a table of flags.\n *\n * flags:       Flags as bitmask. Computed by Redis using the 'sflags' field.\n *\n * get_keys_proc: An optional function to get key arguments from a command.\n *                This is only used when the following three fields are not\n *                enough to specify what arguments are keys.\n *\n * first_key_index: First argument that is a key\n *\n * last_key_index: Last argument that is a key\n *\n * key_step:    Step to get all the keys from first to last argument.\n *              For instance in MSET the step is two since arguments\n *              are key,val,key,val,...\n *\n * microseconds: Microseconds of total execution time for this command.\n *\n * calls:       Total number of calls of this command.\n *\n * id:          Command bit identifier for ACLs or other goals.\n *\n * The flags, microseconds and calls fields are computed by Redis and should\n * always be set to zero.\n *\n * Command flags are expressed using space separated strings, that are turned\n * into actual flags by the populateCommandTable() function.\n *\n * This is the meaning of the flags:\n *\n * write:       Write command (may modify the key space).\n *\n * read-only:   All the non special commands just reading from keys without\n *              changing the content, or returning other information like\n *              the TIME command. Special commands such administrative commands\n *              or transaction related commands (multi, exec, discard, ...)\n *              are not flagged as read-only commands, since they affect the\n *              server or the connection in other ways.\n *\n * use-memory:  May increase memory usage once called. Don't allow if out\n *              of memory.\n *\n * admin:       Administrative command, like SAVE or SHUTDOWN.\n *\n * pub-sub:     Pub/Sub related command.\n *\n * no-script:   Command not allowed in scripts.\n *\n * random:      Random command. Command is not deterministic, that is, the same\n *              command with the same arguments, with the same key space, may\n *              have different results. For instance SPOP and RANDOMKEY are\n *              two random commands.\n *\n * to-sort:     Sort command output array if called from script, so that the\n *              output is deterministic. When this flag is used (not always\n *              possible), then the \"random\" flag is not needed.\n *\n * ok-loading:  Allow the command while loading the database.\n *\n * ok-stale:    Allow the command while a slave has stale data but is not\n *              allowed to serve this data. Normally no command is accepted\n *              in this condition but just a few.\n *\n * no-monitor:  Do not automatically propagate the command on MONITOR.\n *\n * no-slowlog:  Do not automatically propagate the command to the slowlog.\n *\n * cluster-asking: Perform an implicit ASKING for this command, so the\n *              command will be accepted in cluster mode if the slot is marked\n *              as 'importing'.\n *\n * fast:        Fast command: O(1) or O(log(N)) command that should never\n *              delay its execution as long as the kernel scheduler is giving\n *              us time. Note that commands that may trigger a DEL as a side\n *              effect (like SET) are not fast commands.\n *\n * The following additional flags are only used in order to put commands\n * in a specific ACL category. Commands can have multiple ACL categories.\n *\n * @keyspace, @read, @write, @set, @sortedset, @list, @hash, @string, @bitmap,\n * @hyperloglog, @stream, @admin, @fast, @slow, @pubsub, @blocking, @dangerous,\n * @connection, @transaction, @scripting, @geo.\n *\n * Note that:\n *\n * 1) The read-only flag implies the @read ACL category.\n * 2) The write flag implies the @write ACL category.\n * 3) The fast flag implies the @fast ACL category.\n * 4) The admin flag implies the @admin and @dangerous ACL category.\n * 5) The pub-sub flag implies the @pubsub ACL category.\n * 6) The lack of fast flag implies the @slow ACL category.\n * 7) The non obvious \"keyspace\" category includes the commands\n *    that interact with keys without having anything to do with\n *    specific data structures, such as: DEL, RENAME, MOVE, SELECT,\n *    TYPE, EXPIRE*, PEXPIRE*, TTL, PTTL, ...\n */\n\nstruct redisCommand redisCommandTable[] = {\n    {\"module\",moduleCommand,-2,\n     \"admin no-script\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"get\",getCommand,2,\n     \"read-only fast @string\",\n     0,NULL,1,1,1,0,0,0},\n\n    /* Note that we can't flag set as fast, since it may perform an\n     * implicit DEL of a large key. */\n    {\"set\",setCommand,-3,\n     \"write use-memory @string\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"setnx\",setnxCommand,3,\n     \"write use-memory fast @string\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"setex\",setexCommand,4,\n     \"write use-memory @string\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"psetex\",psetexCommand,4,\n     \"write use-memory @string\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"append\",appendCommand,3,\n     \"write use-memory fast @string\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"strlen\",strlenCommand,2,\n     \"read-only fast @string\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"del\",delCommand,-2,\n     \"write @keyspace\",\n     0,NULL,1,-1,1,0,0,0},\n\n    {\"unlink\",unlinkCommand,-2,\n     \"write fast @keyspace\",\n     0,NULL,1,-1,1,0,0,0},\n\n    {\"exists\",existsCommand,-2,\n     \"read-only fast @keyspace\",\n     0,NULL,1,-1,1,0,0,0},\n\n    {\"setbit\",setbitCommand,4,\n     \"write use-memory @bitmap\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"getbit\",getbitCommand,3,\n     \"read-only fast @bitmap\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"bitfield\",bitfieldCommand,-2,\n     \"write use-memory @bitmap\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"bitfield_ro\",bitfieldroCommand,-2,\n     \"read-only fast @bitmap\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"setrange\",setrangeCommand,4,\n     \"write use-memory @string\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"getrange\",getrangeCommand,4,\n     \"read-only @string\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"substr\",getrangeCommand,4,\n     \"read-only @string\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"incr\",incrCommand,2,\n     \"write use-memory fast @string\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"decr\",decrCommand,2,\n     \"write use-memory fast @string\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"mget\",mgetCommand,-2,\n     \"read-only fast @string\",\n     0,NULL,1,-1,1,0,0,0},\n\n    {\"rpush\",rpushCommand,-3,\n     \"write use-memory fast @list\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"lpush\",lpushCommand,-3,\n     \"write use-memory fast @list\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"rpushx\",rpushxCommand,-3,\n     \"write use-memory fast @list\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"lpushx\",lpushxCommand,-3,\n     \"write use-memory fast @list\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"linsert\",linsertCommand,5,\n     \"write use-memory @list\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"rpop\",rpopCommand,2,\n     \"write fast @list\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"lpop\",lpopCommand,2,\n     \"write fast @list\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"brpop\",brpopCommand,-3,\n     \"write no-script @list @blocking\",\n     0,NULL,1,-2,1,0,0,0},\n\n    {\"brpoplpush\",brpoplpushCommand,4,\n     \"write use-memory no-script @list @blocking\",\n     0,NULL,1,2,1,0,0,0},\n\n    {\"blpop\",blpopCommand,-3,\n     \"write no-script @list @blocking\",\n     0,NULL,1,-2,1,0,0,0},\n\n    {\"llen\",llenCommand,2,\n     \"read-only fast @list\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"lindex\",lindexCommand,3,\n     \"read-only @list\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"lset\",lsetCommand,4,\n     \"write use-memory @list\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"lrange\",lrangeCommand,4,\n     \"read-only @list\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"ltrim\",ltrimCommand,4,\n     \"write @list\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"lpos\",lposCommand,-3,\n     \"read-only @list\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"lrem\",lremCommand,4,\n     \"write @list\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"rpoplpush\",rpoplpushCommand,3,\n     \"write use-memory @list\",\n     0,NULL,1,2,1,0,0,0},\n\n    {\"sadd\",saddCommand,-3,\n     \"write use-memory fast @set\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"srem\",sremCommand,-3,\n     \"write fast @set\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"smove\",smoveCommand,4,\n     \"write fast @set\",\n     0,NULL,1,2,1,0,0,0},\n\n    {\"sismember\",sismemberCommand,3,\n     \"read-only fast @set\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"scard\",scardCommand,2,\n     \"read-only fast @set\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"spop\",spopCommand,-2,\n     \"write random fast @set\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"srandmember\",srandmemberCommand,-2,\n     \"read-only random @set\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"sinter\",sinterCommand,-2,\n     \"read-only to-sort @set\",\n     0,NULL,1,-1,1,0,0,0},\n\n    {\"sinterstore\",sinterstoreCommand,-3,\n     \"write use-memory @set\",\n     0,NULL,1,-1,1,0,0,0},\n\n    {\"sunion\",sunionCommand,-2,\n     \"read-only to-sort @set\",\n     0,NULL,1,-1,1,0,0,0},\n\n    {\"sunionstore\",sunionstoreCommand,-3,\n     \"write use-memory @set\",\n     0,NULL,1,-1,1,0,0,0},\n\n    {\"sdiff\",sdiffCommand,-2,\n     \"read-only to-sort @set\",\n     0,NULL,1,-1,1,0,0,0},\n\n    {\"sdiffstore\",sdiffstoreCommand,-3,\n     \"write use-memory @set\",\n     0,NULL,1,-1,1,0,0,0},\n\n    {\"smembers\",sinterCommand,2,\n     \"read-only to-sort @set\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"sscan\",sscanCommand,-3,\n     \"read-only random @set\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zadd\",zaddCommand,-4,\n     \"write use-memory fast @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zincrby\",zincrbyCommand,4,\n     \"write use-memory fast @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zrem\",zremCommand,-3,\n     \"write fast @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zremrangebyscore\",zremrangebyscoreCommand,4,\n     \"write @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zremrangebyrank\",zremrangebyrankCommand,4,\n     \"write @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zremrangebylex\",zremrangebylexCommand,4,\n     \"write @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zunionstore\",zunionstoreCommand,-4,\n     \"write use-memory @sortedset\",\n     0,zunionInterGetKeys,1,1,1,0,0,0},\n\n    {\"zinterstore\",zinterstoreCommand,-4,\n     \"write use-memory @sortedset\",\n     0,zunionInterGetKeys,1,1,1,0,0,0},\n\n    {\"zrange\",zrangeCommand,-4,\n     \"read-only @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zrangebyscore\",zrangebyscoreCommand,-4,\n     \"read-only @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zrevrangebyscore\",zrevrangebyscoreCommand,-4,\n     \"read-only @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zrangebylex\",zrangebylexCommand,-4,\n     \"read-only @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zrevrangebylex\",zrevrangebylexCommand,-4,\n     \"read-only @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zcount\",zcountCommand,4,\n     \"read-only fast @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zlexcount\",zlexcountCommand,4,\n     \"read-only fast @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zrevrange\",zrevrangeCommand,-4,\n     \"read-only @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zcard\",zcardCommand,2,\n     \"read-only fast @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zscore\",zscoreCommand,3,\n     \"read-only fast @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zrank\",zrankCommand,3,\n     \"read-only fast @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zrevrank\",zrevrankCommand,3,\n     \"read-only fast @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zscan\",zscanCommand,-3,\n     \"read-only random @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zpopmin\",zpopminCommand,-2,\n     \"write fast @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zpopmax\",zpopmaxCommand,-2,\n     \"write fast @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"bzpopmin\",bzpopminCommand,-3,\n     \"write no-script fast @sortedset @blocking\",\n     0,NULL,1,-2,1,0,0,0},\n\n    {\"bzpopmax\",bzpopmaxCommand,-3,\n     \"write no-script fast @sortedset @blocking\",\n     0,NULL,1,-2,1,0,0,0},\n\n    {\"hset\",hsetCommand,-4,\n     \"write use-memory fast @hash\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"hsetnx\",hsetnxCommand,4,\n     \"write use-memory fast @hash\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"hget\",hgetCommand,3,\n     \"read-only fast @hash\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"hmset\",hsetCommand,-4,\n     \"write use-memory fast @hash\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"hmget\",hmgetCommand,-3,\n     \"read-only fast @hash\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"hincrby\",hincrbyCommand,4,\n     \"write use-memory fast @hash\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"hincrbyfloat\",hincrbyfloatCommand,4,\n     \"write use-memory fast @hash\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"hdel\",hdelCommand,-3,\n     \"write fast @hash\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"hlen\",hlenCommand,2,\n     \"read-only fast @hash\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"hstrlen\",hstrlenCommand,3,\n     \"read-only fast @hash\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"hkeys\",hkeysCommand,2,\n     \"read-only to-sort @hash\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"hvals\",hvalsCommand,2,\n     \"read-only to-sort @hash\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"hgetall\",hgetallCommand,2,\n     \"read-only random @hash\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"hexists\",hexistsCommand,3,\n     \"read-only fast @hash\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"hscan\",hscanCommand,-3,\n     \"read-only random @hash\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"incrby\",incrbyCommand,3,\n     \"write use-memory fast @string\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"decrby\",decrbyCommand,3,\n     \"write use-memory fast @string\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"incrbyfloat\",incrbyfloatCommand,3,\n     \"write use-memory fast @string\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"getset\",getsetCommand,3,\n     \"write use-memory fast @string\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"mset\",msetCommand,-3,\n     \"write use-memory @string\",\n     0,NULL,1,-1,2,0,0,0},\n\n    {\"msetnx\",msetnxCommand,-3,\n     \"write use-memory @string\",\n     0,NULL,1,-1,2,0,0,0},\n\n    {\"randomkey\",randomkeyCommand,1,\n     \"read-only random @keyspace\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"select\",selectCommand,2,\n     \"ok-loading fast ok-stale @keyspace\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"swapdb\",swapdbCommand,3,\n     \"write fast @keyspace @dangerous\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"move\",moveCommand,3,\n     \"write fast @keyspace\",\n     0,NULL,1,1,1,0,0,0},\n\n    /* Like for SET, we can't mark rename as a fast command because\n     * overwriting the target key may result in an implicit slow DEL. */\n    {\"rename\",renameCommand,3,\n     \"write @keyspace\",\n     0,NULL,1,2,1,0,0,0},\n\n    {\"renamenx\",renamenxCommand,3,\n     \"write fast @keyspace\",\n     0,NULL,1,2,1,0,0,0},\n\n    {\"expire\",expireCommand,3,\n     \"write fast @keyspace\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"expireat\",expireatCommand,3,\n     \"write fast @keyspace\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"pexpire\",pexpireCommand,3,\n     \"write fast @keyspace\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"pexpireat\",pexpireatCommand,3,\n     \"write fast @keyspace\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"keys\",keysCommand,2,\n     \"read-only to-sort @keyspace @dangerous\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"scan\",scanCommand,-2,\n     \"read-only random @keyspace\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"dbsize\",dbsizeCommand,1,\n     \"read-only fast @keyspace\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"auth\",authCommand,-2,\n     \"no-auth no-script ok-loading ok-stale fast no-monitor no-slowlog @connection\",\n     0,NULL,0,0,0,0,0,0},\n\n    /* We don't allow PING during loading since in Redis PING is used as\n     * failure detection, and a loading server is considered to be\n     * not available. */\n    {\"ping\",pingCommand,-1,\n     \"ok-stale fast @connection\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"echo\",echoCommand,2,\n     \"read-only fast @connection\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"save\",saveCommand,1,\n     \"admin no-script\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"bgsave\",bgsaveCommand,-1,\n     \"admin no-script\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"bgrewriteaof\",bgrewriteaofCommand,1,\n     \"admin no-script\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"shutdown\",shutdownCommand,-1,\n     \"admin no-script ok-loading ok-stale\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"lastsave\",lastsaveCommand,1,\n     \"read-only random fast ok-loading ok-stale @admin @dangerous\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"type\",typeCommand,2,\n     \"read-only fast @keyspace\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"multi\",multiCommand,1,\n     \"no-script fast ok-loading ok-stale @transaction\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"exec\",execCommand,1,\n     \"no-script no-monitor no-slowlog ok-loading ok-stale @transaction\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"discard\",discardCommand,1,\n     \"no-script fast ok-loading ok-stale @transaction\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"sync\",syncCommand,1,\n     \"admin no-script\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"psync\",syncCommand,3,\n     \"admin no-script\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"replconf\",replconfCommand,-1,\n     \"admin no-script ok-loading ok-stale\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"flushdb\",flushdbCommand,-1,\n     \"write @keyspace @dangerous\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"flushall\",flushallCommand,-1,\n     \"write @keyspace @dangerous\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"sort\",sortCommand,-2,\n     \"write use-memory @list @set @sortedset @dangerous\",\n     0,sortGetKeys,1,1,1,0,0,0},\n\n    {\"info\",infoCommand,-1,\n     \"ok-loading ok-stale random @dangerous\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"monitor\",monitorCommand,1,\n     \"admin no-script ok-loading ok-stale\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"ttl\",ttlCommand,2,\n     \"read-only fast random @keyspace\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"touch\",touchCommand,-2,\n     \"read-only fast @keyspace\",\n     0,NULL,1,-1,1,0,0,0},\n\n    {\"pttl\",pttlCommand,2,\n     \"read-only fast random @keyspace\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"persist\",persistCommand,2,\n     \"write fast @keyspace\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"slaveof\",replicaofCommand,3,\n     \"admin no-script ok-stale\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"replicaof\",replicaofCommand,3,\n     \"admin no-script ok-stale\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"role\",roleCommand,1,\n     \"ok-loading ok-stale no-script fast read-only @dangerous\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"debug\",debugCommand,-2,\n     \"admin no-script ok-loading ok-stale\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"config\",configCommand,-2,\n     \"admin ok-loading ok-stale no-script\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"subscribe\",subscribeCommand,-2,\n     \"pub-sub no-script ok-loading ok-stale\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"unsubscribe\",unsubscribeCommand,-1,\n     \"pub-sub no-script ok-loading ok-stale\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"psubscribe\",psubscribeCommand,-2,\n     \"pub-sub no-script ok-loading ok-stale\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"punsubscribe\",punsubscribeCommand,-1,\n     \"pub-sub no-script ok-loading ok-stale\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"publish\",publishCommand,3,\n     \"pub-sub ok-loading ok-stale fast\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"pubsub\",pubsubCommand,-2,\n     \"pub-sub ok-loading ok-stale random\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"watch\",watchCommand,-2,\n     \"no-script fast ok-loading ok-stale @transaction\",\n     0,NULL,1,-1,1,0,0,0},\n\n    {\"unwatch\",unwatchCommand,1,\n     \"no-script fast ok-loading ok-stale @transaction\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"cluster\",clusterCommand,-2,\n     \"admin ok-stale random\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"restore\",restoreCommand,-4,\n     \"write use-memory @keyspace @dangerous\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"restore-asking\",restoreCommand,-4,\n    \"write use-memory cluster-asking @keyspace @dangerous\",\n    0,NULL,1,1,1,0,0,0},\n\n    {\"migrate\",migrateCommand,-6,\n     \"write random @keyspace @dangerous\",\n     0,migrateGetKeys,0,0,0,0,0,0},\n\n    {\"asking\",askingCommand,1,\n     \"fast @keyspace\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"readonly\",readonlyCommand,1,\n     \"fast @keyspace\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"readwrite\",readwriteCommand,1,\n     \"fast @keyspace\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"dump\",dumpCommand,2,\n     \"read-only random @keyspace\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"object\",objectCommand,-2,\n     \"read-only random @keyspace\",\n     0,NULL,2,2,1,0,0,0},\n\n    {\"memory\",memoryCommand,-2,\n     \"random read-only\",\n     0,memoryGetKeys,0,0,0,0,0,0},\n\n    {\"client\",clientCommand,-2,\n     \"admin no-script random ok-loading ok-stale @connection\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"hello\",helloCommand,-2,\n     \"no-auth no-script fast no-monitor ok-loading ok-stale no-slowlog @connection\",\n     0,NULL,0,0,0,0,0,0},\n\n    /* EVAL can modify the dataset, however it is not flagged as a write\n     * command since we do the check while running commands from Lua. */\n    {\"eval\",evalCommand,-3,\n     \"no-script @scripting\",\n     0,evalGetKeys,0,0,0,0,0,0},\n\n    {\"evalsha\",evalShaCommand,-3,\n     \"no-script @scripting\",\n     0,evalGetKeys,0,0,0,0,0,0},\n\n    {\"slowlog\",slowlogCommand,-2,\n     \"admin random ok-loading ok-stale\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"script\",scriptCommand,-2,\n     \"no-script @scripting\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"time\",timeCommand,1,\n     \"read-only random fast ok-loading ok-stale\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"bitop\",bitopCommand,-4,\n     \"write use-memory @bitmap\",\n     0,NULL,2,-1,1,0,0,0},\n\n    {\"bitcount\",bitcountCommand,-2,\n     \"read-only @bitmap\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"bitpos\",bitposCommand,-3,\n     \"read-only @bitmap\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"wait\",waitCommand,3,\n     \"no-script @keyspace\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"command\",commandCommand,-1,\n     \"ok-loading ok-stale random @connection\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"geoadd\",geoaddCommand,-5,\n     \"write use-memory @geo\",\n     0,NULL,1,1,1,0,0,0},\n\n    /* GEORADIUS has store options that may write. */\n    {\"georadius\",georadiusCommand,-6,\n     \"write use-memory @geo\",\n     0,georadiusGetKeys,1,1,1,0,0,0},\n\n    {\"georadius_ro\",georadiusroCommand,-6,\n     \"read-only @geo\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"georadiusbymember\",georadiusbymemberCommand,-5,\n     \"write use-memory @geo\",\n     0,georadiusGetKeys,1,1,1,0,0,0},\n\n    {\"georadiusbymember_ro\",georadiusbymemberroCommand,-5,\n     \"read-only @geo\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"geohash\",geohashCommand,-2,\n     \"read-only @geo\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"geopos\",geoposCommand,-2,\n     \"read-only @geo\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"geodist\",geodistCommand,-4,\n     \"read-only @geo\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"pfselftest\",pfselftestCommand,1,\n     \"admin @hyperloglog\",\n      0,NULL,0,0,0,0,0,0},\n\n    {\"pfadd\",pfaddCommand,-2,\n     \"write use-memory fast @hyperloglog\",\n     0,NULL,1,1,1,0,0,0},\n\n    /* Technically speaking PFCOUNT may change the key since it changes the\n     * final bytes in the HyperLogLog representation. However in this case\n     * we claim that the representation, even if accessible, is an internal\n     * affair, and the command is semantically read only. */\n    {\"pfcount\",pfcountCommand,-2,\n     \"read-only @hyperloglog\",\n     0,NULL,1,-1,1,0,0,0},\n\n    {\"pfmerge\",pfmergeCommand,-2,\n     \"write use-memory @hyperloglog\",\n     0,NULL,1,-1,1,0,0,0},\n\n    {\"pfdebug\",pfdebugCommand,-3,\n     \"admin write\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"xadd\",xaddCommand,-5,\n     \"write use-memory fast random @stream\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"xrange\",xrangeCommand,-4,\n     \"read-only @stream\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"xrevrange\",xrevrangeCommand,-4,\n     \"read-only @stream\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"xlen\",xlenCommand,2,\n     \"read-only fast @stream\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"xread\",xreadCommand,-4,\n     \"read-only @stream @blocking\",\n     0,xreadGetKeys,0,0,0,0,0,0},\n\n    {\"xreadgroup\",xreadCommand,-7,\n     \"write @stream @blocking\",\n     0,xreadGetKeys,0,0,0,0,0,0},\n\n    {\"xgroup\",xgroupCommand,-2,\n     \"write use-memory @stream\",\n     0,NULL,2,2,1,0,0,0},\n\n    {\"xsetid\",xsetidCommand,3,\n     \"write use-memory fast @stream\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"xack\",xackCommand,-4,\n     \"write fast random @stream\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"xpending\",xpendingCommand,-3,\n     \"read-only random @stream\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"xclaim\",xclaimCommand,-6,\n     \"write random fast @stream\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"xinfo\",xinfoCommand,-2,\n     \"read-only random @stream\",\n     0,NULL,2,2,1,0,0,0},\n\n    {\"xdel\",xdelCommand,-3,\n     \"write fast @stream\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"xtrim\",xtrimCommand,-2,\n     \"write random @stream\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"post\",securityWarningCommand,-1,\n     \"ok-loading ok-stale read-only\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"host:\",securityWarningCommand,-1,\n     \"ok-loading ok-stale read-only\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"latency\",latencyCommand,-2,\n     \"admin no-script ok-loading ok-stale\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"lolwut\",lolwutCommand,-1,\n     \"read-only fast\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"acl\",aclCommand,-2,\n     \"admin no-script no-slowlog ok-loading ok-stale\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"stralgo\",stralgoCommand,-2,\n     \"read-only @string\",\n     0,lcsGetKeys,0,0,0,0,0,0}\n};\n\n/*============================ Utility functions ============================ */\n\n/* We use a private localtime implementation which is fork-safe. The logging\n * function of Redis may be called from other threads. */\nvoid nolocks_localtime(struct tm *tmp, time_t t, time_t tz, int dst);\n\n/* Low level logging. To use only for very big messages, otherwise\n * serverLog() is to prefer. */\nvoid serverLogRaw(int level, const char *msg) {\n    const int syslogLevelMap[] = { LOG_DEBUG, LOG_INFO, LOG_NOTICE, LOG_WARNING };\n    const char *c = \".-*#\";\n    FILE *fp;\n    char buf[64];\n    int rawmode = (level & LL_RAW);\n    int log_to_stdout = server.logfile[0] == '\\0';\n\n    level &= 0xff; /* clear flags */\n    if (level < server.verbosity) return;\n\n    fp = log_to_stdout ? stdout : fopen(server.logfile,\"a\");\n    if (!fp) return;\n\n    if (rawmode) {\n        fprintf(fp,\"%s\",msg);\n    } else {\n        int off;\n        struct timeval tv;\n        int role_char;\n        pid_t pid = getpid();\n\n        gettimeofday(&tv,NULL);\n        struct tm tm;\n        nolocks_localtime(&tm,tv.tv_sec,server.timezone,server.daylight_active);\n        off = strftime(buf,sizeof(buf),\"%d %b %Y %H:%M:%S.\",&tm);\n        snprintf(buf+off,sizeof(buf)-off,\"%03d\",(int)tv.tv_usec/1000);\n        if (server.sentinel_mode) {\n            role_char = 'X'; /* Sentinel. */\n        } else if (pid != server.pid) {\n            role_char = 'C'; /* RDB / AOF writing child. */\n        } else {\n            role_char = (server.masterhost ? 'S':'M'); /* Slave or Master. */\n        }\n        fprintf(fp,\"%d:%c %s %c %s\\n\",\n            (int)getpid(),role_char, buf,c[level],msg);\n    }\n    fflush(fp);\n\n    if (!log_to_stdout) fclose(fp);\n    if (server.syslog_enabled) syslog(syslogLevelMap[level], \"%s\", msg);\n}\n\n/* Like serverLogRaw() but with printf-alike support. This is the function that\n * is used across the code. The raw version is only used in order to dump\n * the INFO output on crash. */\nvoid serverLog(int level, const char *fmt, ...) {\n    va_list ap;\n    char msg[LOG_MAX_LEN];\n\n    if ((level&0xff) < server.verbosity) return;\n\n    va_start(ap, fmt);\n    vsnprintf(msg, sizeof(msg), fmt, ap);\n    va_end(ap);\n\n    serverLogRaw(level,msg);\n}\n\n/* Log a fixed message without printf-alike capabilities, in a way that is\n * safe to call from a signal handler.\n *\n * We actually use this only for signals that are not fatal from the point\n * of view of Redis. Signals that are going to kill the server anyway and\n * where we need printf-alike features are served by serverLog(). */\nvoid serverLogFromHandler(int level, const char *msg) {\n    int fd;\n    int log_to_stdout = server.logfile[0] == '\\0';\n    char buf[64];\n\n    if ((level&0xff) < server.verbosity || (log_to_stdout && server.daemonize))\n        return;\n    fd = log_to_stdout ? STDOUT_FILENO :\n                         open(server.logfile, O_APPEND|O_CREAT|O_WRONLY, 0644);\n    if (fd == -1) return;\n    ll2string(buf,sizeof(buf),getpid());\n    if (write(fd,buf,strlen(buf)) == -1) goto err;\n    if (write(fd,\":signal-handler (\",17) == -1) goto err;\n    ll2string(buf,sizeof(buf),time(NULL));\n    if (write(fd,buf,strlen(buf)) == -1) goto err;\n    if (write(fd,\") \",2) == -1) goto err;\n    if (write(fd,msg,strlen(msg)) == -1) goto err;\n    if (write(fd,\"\\n\",1) == -1) goto err;\nerr:\n    if (!log_to_stdout) close(fd);\n}\n\n/* Return the UNIX time in microseconds */\nlong long ustime(void) {\n    struct timeval tv;\n    long long ust;\n\n    gettimeofday(&tv, NULL);\n    ust = ((long long)tv.tv_sec)*1000000;\n    ust += tv.tv_usec;\n    return ust;\n}\n\n/* Return the UNIX time in milliseconds */\nmstime_t mstime(void) {\n    return ustime()/1000;\n}\n\n/* After an RDB dump or AOF rewrite we exit from children using _exit() instead of\n * exit(), because the latter may interact with the same file objects used by\n * the parent process. However if we are testing the coverage normal exit() is\n * used in order to obtain the right coverage information. */\nvoid exitFromChild(int retcode) {\n#ifdef COVERAGE_TEST\n    exit(retcode);\n#else\n    _exit(retcode);\n#endif\n}\n\n/*====================== Hash table type implementation  ==================== */\n\n/* This is a hash table type that uses the SDS dynamic strings library as\n * keys and redis objects as values (objects can hold SDS strings,\n * lists, sets). */\n\nvoid dictVanillaFree(void *privdata, void *val)\n{\n    DICT_NOTUSED(privdata);\n    zfree(val);\n}\n\nvoid dictListDestructor(void *privdata, void *val)\n{\n    DICT_NOTUSED(privdata);\n    listRelease((list*)val);\n}\n\nint dictSdsKeyCompare(void *privdata, const void *key1,\n        const void *key2)\n{\n    int l1,l2;\n    DICT_NOTUSED(privdata);\n\n    l1 = sdslen((sds)key1);\n    l2 = sdslen((sds)key2);\n    if (l1 != l2) return 0;\n    return memcmp(key1, key2, l1) == 0;\n}\n\n/* A case insensitive version used for the command lookup table and other\n * places where case insensitive non binary-safe comparison is needed. */\nint dictSdsKeyCaseCompare(void *privdata, const void *key1,\n        const void *key2)\n{\n    DICT_NOTUSED(privdata);\n\n    return strcasecmp(key1, key2) == 0;\n}\n\nvoid dictObjectDestructor(void *privdata, void *val)\n{\n    DICT_NOTUSED(privdata);\n\n    if (val == NULL) return; /* Lazy freeing will set value to NULL. */\n    decrRefCount(val);\n}\n\nvoid dictSdsDestructor(void *privdata, void *val)\n{\n    DICT_NOTUSED(privdata);\n\n    sdsfree(val);\n}\n\nint dictObjKeyCompare(void *privdata, const void *key1,\n        const void *key2)\n{\n    const robj *o1 = key1, *o2 = key2;\n    return dictSdsKeyCompare(privdata,o1->ptr,o2->ptr);\n}\n\nuint64_t dictObjHash(const void *key) {\n    const robj *o = key;\n    return dictGenHashFunction(o->ptr, sdslen((sds)o->ptr));\n}\n\nuint64_t dictSdsHash(const void *key) {\n    return dictGenHashFunction((unsigned char*)key, sdslen((char*)key));\n}\n\nuint64_t dictSdsCaseHash(const void *key) {\n    return dictGenCaseHashFunction((unsigned char*)key, sdslen((char*)key));\n}\n\nint dictEncObjKeyCompare(void *privdata, const void *key1,\n        const void *key2)\n{\n    robj *o1 = (robj*) key1, *o2 = (robj*) key2;\n    int cmp;\n\n    if (o1->encoding == OBJ_ENCODING_INT &&\n        o2->encoding == OBJ_ENCODING_INT)\n            return o1->ptr == o2->ptr;\n\n    /* Due to OBJ_STATIC_REFCOUNT, we avoid calling getDecodedObject() without\n     * good reasons, because it would incrRefCount() the object, which\n     * is invalid. So we check to make sure dictFind() works with static\n     * objects as well. */\n    if (o1->refcount != OBJ_STATIC_REFCOUNT) o1 = getDecodedObject(o1);\n    if (o2->refcount != OBJ_STATIC_REFCOUNT) o2 = getDecodedObject(o2);\n    cmp = dictSdsKeyCompare(privdata,o1->ptr,o2->ptr);\n    if (o1->refcount != OBJ_STATIC_REFCOUNT) decrRefCount(o1);\n    if (o2->refcount != OBJ_STATIC_REFCOUNT) decrRefCount(o2);\n    return cmp;\n}\n\nuint64_t dictEncObjHash(const void *key) {\n    robj *o = (robj*) key;\n\n    if (sdsEncodedObject(o)) {\n        return dictGenHashFunction(o->ptr, sdslen((sds)o->ptr));\n    } else {\n        if (o->encoding == OBJ_ENCODING_INT) {\n            char buf[32];\n            int len;\n\n            len = ll2string(buf,32,(long)o->ptr);\n            return dictGenHashFunction((unsigned char*)buf, len);\n        } else {\n            uint64_t hash;\n\n            o = getDecodedObject(o);\n            hash = dictGenHashFunction(o->ptr, sdslen((sds)o->ptr));\n            decrRefCount(o);\n            return hash;\n        }\n    }\n}\n\n/* Generic hash table type where keys are Redis Objects, Values\n * dummy pointers. */\ndictType objectKeyPointerValueDictType = {\n    dictEncObjHash,            /* hash function */\n    NULL,                      /* key dup */\n    NULL,                      /* val dup */\n    dictEncObjKeyCompare,      /* key compare */\n    dictObjectDestructor,      /* key destructor */\n    NULL                       /* val destructor */\n};\n\n/* Like objectKeyPointerValueDictType(), but values can be destroyed, if\n * not NULL, calling zfree(). */\ndictType objectKeyHeapPointerValueDictType = {\n    dictEncObjHash,            /* hash function */\n    NULL,                      /* key dup */\n    NULL,                      /* val dup */\n    dictEncObjKeyCompare,      /* key compare */\n    dictObjectDestructor,      /* key destructor */\n    dictVanillaFree            /* val destructor */\n};\n\n/* Set dictionary type. Keys are SDS strings, values are not used. */\ndictType setDictType = {\n    dictSdsHash,               /* hash function */\n    NULL,                      /* key dup */\n    NULL,                      /* val dup */\n    dictSdsKeyCompare,         /* key compare */\n    dictSdsDestructor,         /* key destructor */\n    NULL                       /* val destructor */\n};\n\n/* Sorted sets hash (note: a skiplist is used in addition to the hash table) */\ndictType zsetDictType = {\n    dictSdsHash,               /* hash function */\n    NULL,                      /* key dup */\n    NULL,                      /* val dup */\n    dictSdsKeyCompare,         /* key compare */\n    NULL,                      /* Note: SDS string shared & freed by skiplist */\n    NULL                       /* val destructor */\n};\n\n/* Db->dict, keys are sds strings, vals are Redis objects. */\ndictType dbDictType = {\n    dictSdsHash,                /* hash function */\n    NULL,                       /* key dup */\n    NULL,                       /* val dup */\n    dictSdsKeyCompare,          /* key compare */\n    dictSdsDestructor,          /* key destructor */\n    dictObjectDestructor   /* val destructor */\n};\n\n/* server.lua_scripts sha (as sds string) -> scripts (as robj) cache. */\ndictType shaScriptObjectDictType = {\n    dictSdsCaseHash,            /* hash function */\n    NULL,                       /* key dup */\n    NULL,                       /* val dup */\n    dictSdsKeyCaseCompare,      /* key compare */\n    dictSdsDestructor,          /* key destructor */\n    dictObjectDestructor        /* val destructor */\n};\n\n/* Db->expires */\ndictType keyptrDictType = {\n    dictSdsHash,                /* hash function */\n    NULL,                       /* key dup */\n    NULL,                       /* val dup */\n    dictSdsKeyCompare,          /* key compare */\n    NULL,                       /* key destructor */\n    NULL                        /* val destructor */\n};\n\n/* Command table. sds string -> command struct pointer. */\ndictType commandTableDictType = {\n    dictSdsCaseHash,            /* hash function */\n    NULL,                       /* key dup */\n    NULL,                       /* val dup */\n    dictSdsKeyCaseCompare,      /* key compare */\n    dictSdsDestructor,          /* key destructor */\n    NULL                        /* val destructor */\n};\n\n/* Hash type hash table (note that small hashes are represented with ziplists) */\ndictType hashDictType = {\n    dictSdsHash,                /* hash function */\n    NULL,                       /* key dup */\n    NULL,                       /* val dup */\n    dictSdsKeyCompare,          /* key compare */\n    dictSdsDestructor,          /* key destructor */\n    dictSdsDestructor           /* val destructor */\n};\n\n/* Keylist hash table type has unencoded redis objects as keys and\n * lists as values. It's used for blocking operations (BLPOP) and to\n * map swapped keys to a list of clients waiting for this keys to be loaded. */\ndictType keylistDictType = {\n    dictObjHash,                /* hash function */\n    NULL,                       /* key dup */\n    NULL,                       /* val dup */\n    dictObjKeyCompare,          /* key compare */\n    dictObjectDestructor,       /* key destructor */\n    dictListDestructor          /* val destructor */\n};\n\n/* Cluster nodes hash table, mapping nodes addresses 1.2.3.4:6379 to\n * clusterNode structures. */\ndictType clusterNodesDictType = {\n    dictSdsHash,                /* hash function */\n    NULL,                       /* key dup */\n    NULL,                       /* val dup */\n    dictSdsKeyCompare,          /* key compare */\n    dictSdsDestructor,          /* key destructor */\n    NULL                        /* val destructor */\n};\n\n/* Cluster re-addition blacklist. This maps node IDs to the time\n * we can re-add this node. The goal is to avoid readding a removed\n * node for some time. */\ndictType clusterNodesBlackListDictType = {\n    dictSdsCaseHash,            /* hash function */\n    NULL,                       /* key dup */\n    NULL,                       /* val dup */\n    dictSdsKeyCaseCompare,      /* key compare */\n    dictSdsDestructor,          /* key destructor */\n    NULL                        /* val destructor */\n};\n\n/* Modules system dictionary type. Keys are module name,\n * values are pointer to RedisModule struct. */\ndictType modulesDictType = {\n    dictSdsCaseHash,            /* hash function */\n    NULL,                       /* key dup */\n    NULL,                       /* val dup */\n    dictSdsKeyCaseCompare,      /* key compare */\n    dictSdsDestructor,          /* key destructor */\n    NULL                        /* val destructor */\n};\n\n/* Migrate cache dict type. */\ndictType migrateCacheDictType = {\n    dictSdsHash,                /* hash function */\n    NULL,                       /* key dup */\n    NULL,                       /* val dup */\n    dictSdsKeyCompare,          /* key compare */\n    dictSdsDestructor,          /* key destructor */\n    NULL                        /* val destructor */\n};\n\n/* Replication cached script dict (server.repl_scriptcache_dict).\n * Keys are sds SHA1 strings, while values are not used at all in the current\n * implementation. */\ndictType replScriptCacheDictType = {\n    dictSdsCaseHash,            /* hash function */\n    NULL,                       /* key dup */\n    NULL,                       /* val dup */\n    dictSdsKeyCaseCompare,      /* key compare */\n    dictSdsDestructor,          /* key destructor */\n    NULL                        /* val destructor */\n};\n\nint htNeedsResize(dict *dict) {\n    long long size, used;\n\n    size = dictSlots(dict);\n    used = dictSize(dict);\n    return (size > DICT_HT_INITIAL_SIZE &&\n            (used*100/size < HASHTABLE_MIN_FILL));\n}\n\n/* If the percentage of used slots in the HT reaches HASHTABLE_MIN_FILL\n * we resize the hash table to save memory */\nvoid tryResizeHashTables(int dbid) {\n    if (htNeedsResize(server.db[dbid].dict))\n        dictResize(server.db[dbid].dict);\n    if (htNeedsResize(server.db[dbid].expires))\n        dictResize(server.db[dbid].expires);\n}\n\n/* Our hash table implementation performs rehashing incrementally while\n * we write/read from the hash table. Still if the server is idle, the hash\n * table will use two tables for a long time. So we try to use 1 millisecond\n * of CPU time at every call of this function to perform some rehashing.\n *\n * The function returns 1 if some rehashing was performed, otherwise 0\n * is returned. */\nint incrementallyRehash(int dbid) {\n    /* Keys dictionary */\n    if (dictIsRehashing(server.db[dbid].dict)) {\n        dictRehashMilliseconds(server.db[dbid].dict,1);\n        return 1; /* already used our millisecond for this loop... */\n    }\n    /* Expires */\n    if (dictIsRehashing(server.db[dbid].expires)) {\n        dictRehashMilliseconds(server.db[dbid].expires,1);\n        return 1; /* already used our millisecond for this loop... */\n    }\n    return 0;\n}\n\n/* This function is called once a background process of some kind terminates,\n * as we want to avoid resizing the hash tables when there is a child in order\n * to play well with copy-on-write (otherwise when a resize happens lots of\n * memory pages are copied). The goal of this function is to update the ability\n * for dict.c to resize the hash tables accordingly to the fact we have an\n * active fork child running. */\nvoid updateDictResizePolicy(void) {\n    if (!hasActiveChildProcess())\n        dictEnableResize();\n    else\n        dictDisableResize();\n}\n\n/* Return true if there are no active children processes doing RDB saving,\n * AOF rewriting, or some side process spawned by a loaded module. */\nint hasActiveChildProcess() {\n    return server.rdb_child_pid != -1 ||\n           server.aof_child_pid != -1 ||\n           server.module_child_pid != -1;\n}\n\n/* Return true if this instance has persistence completely turned off:\n * both RDB and AOF are disabled. */\nint allPersistenceDisabled(void) {\n    return server.saveparamslen == 0 && server.aof_state == AOF_OFF;\n}\n\n/* ======================= Cron: called every 100 ms ======================== */\n\n/* Add a sample to the operations per second array of samples. */\nvoid trackInstantaneousMetric(int metric, long long current_reading) {\n    long long t = mstime() - server.inst_metric[metric].last_sample_time;\n    long long ops = current_reading -\n                    server.inst_metric[metric].last_sample_count;\n    long long ops_sec;\n\n    ops_sec = t > 0 ? (ops*1000/t) : 0;\n\n    server.inst_metric[metric].samples[server.inst_metric[metric].idx] =\n        ops_sec;\n    server.inst_metric[metric].idx++;\n    server.inst_metric[metric].idx %= STATS_METRIC_SAMPLES;\n    server.inst_metric[metric].last_sample_time = mstime();\n    server.inst_metric[metric].last_sample_count = current_reading;\n}\n\n/* Return the mean of all the samples. */\nlong long getInstantaneousMetric(int metric) {\n    int j;\n    long long sum = 0;\n\n    for (j = 0; j < STATS_METRIC_SAMPLES; j++)\n        sum += server.inst_metric[metric].samples[j];\n    return sum / STATS_METRIC_SAMPLES;\n}\n\n/* The client query buffer is an sds.c string that can end with a lot of\n * free space not used, this function reclaims space if needed.\n *\n * The function always returns 0 as it never terminates the client. */\nint clientsCronResizeQueryBuffer(client *c) {\n    size_t querybuf_size = sdsAllocSize(c->querybuf);\n    time_t idletime = server.unixtime - c->lastinteraction;\n\n    /* There are two conditions to resize the query buffer:\n     * 1) Query buffer is > BIG_ARG and too big for latest peak.\n     * 2) Query buffer is > BIG_ARG and client is idle. */\n    if (querybuf_size > PROTO_MBULK_BIG_ARG &&\n         ((querybuf_size/(c->querybuf_peak+1)) > 2 ||\n          idletime > 2))\n    {\n        /* Only resize the query buffer if it is actually wasting\n         * at least a few kbytes. */\n        if (sdsavail(c->querybuf) > 1024*4) {\n            c->querybuf = sdsRemoveFreeSpace(c->querybuf);\n        }\n    }\n    /* Reset the peak again to capture the peak memory usage in the next\n     * cycle. */\n    c->querybuf_peak = 0;\n\n    /* Clients representing masters also use a \"pending query buffer\" that\n     * is the yet not applied part of the stream we are reading. Such buffer\n     * also needs resizing from time to time, otherwise after a very large\n     * transfer (a huge value or a big MIGRATE operation) it will keep using\n     * a lot of memory. */\n    if (c->flags & CLIENT_MASTER) {\n        /* There are two conditions to resize the pending query buffer:\n         * 1) Pending Query buffer is > LIMIT_PENDING_QUERYBUF.\n         * 2) Used length is smaller than pending_querybuf_size/2 */\n        size_t pending_querybuf_size = sdsAllocSize(c->pending_querybuf);\n        if(pending_querybuf_size > LIMIT_PENDING_QUERYBUF &&\n           sdslen(c->pending_querybuf) < (pending_querybuf_size/2))\n        {\n            c->pending_querybuf = sdsRemoveFreeSpace(c->pending_querybuf);\n        }\n    }\n    return 0;\n}\n\n/* This function is used in order to track clients using the biggest amount\n * of memory in the latest few seconds. This way we can provide such information\n * in the INFO output (clients section), without having to do an O(N) scan for\n * all the clients.\n *\n * This is how it works. We have an array of CLIENTS_PEAK_MEM_USAGE_SLOTS slots\n * where we track, for each, the biggest client output and input buffers we\n * saw in that slot. Every slot correspond to one of the latest seconds, since\n * the array is indexed by doing UNIXTIME % CLIENTS_PEAK_MEM_USAGE_SLOTS.\n *\n * When we want to know what was recently the peak memory usage, we just scan\n * such few slots searching for the maximum value. */\n#define CLIENTS_PEAK_MEM_USAGE_SLOTS 8\nsize_t ClientsPeakMemInput[CLIENTS_PEAK_MEM_USAGE_SLOTS];\nsize_t ClientsPeakMemOutput[CLIENTS_PEAK_MEM_USAGE_SLOTS];\n\nint clientsCronTrackExpansiveClients(client *c) {\n    size_t in_usage = sdsZmallocSize(c->querybuf) + c->argv_len_sum;\n    size_t out_usage = getClientOutputBufferMemoryUsage(c);\n    int i = server.unixtime % CLIENTS_PEAK_MEM_USAGE_SLOTS;\n    int zeroidx = (i+1) % CLIENTS_PEAK_MEM_USAGE_SLOTS;\n\n    /* Always zero the next sample, so that when we switch to that second, we'll\n     * only register samples that are greater in that second without considering\n     * the history of such slot.\n     *\n     * Note: our index may jump to any random position if serverCron() is not\n     * called for some reason with the normal frequency, for instance because\n     * some slow command is called taking multiple seconds to execute. In that\n     * case our array may end containing data which is potentially older\n     * than CLIENTS_PEAK_MEM_USAGE_SLOTS seconds: however this is not a problem\n     * since here we want just to track if \"recently\" there were very expansive\n     * clients from the POV of memory usage. */\n    ClientsPeakMemInput[zeroidx] = 0;\n    ClientsPeakMemOutput[zeroidx] = 0;\n\n    /* Track the biggest values observed so far in this slot. */\n    if (in_usage > ClientsPeakMemInput[i]) ClientsPeakMemInput[i] = in_usage;\n    if (out_usage > ClientsPeakMemOutput[i]) ClientsPeakMemOutput[i] = out_usage;\n\n    return 0; /* This function never terminates the client. */\n}\n\n/* Iterating all the clients in getMemoryOverheadData() is too slow and\n * in turn would make the INFO command too slow. So we perform this\n * computation incrementally and track the (not instantaneous but updated\n * to the second) total memory used by clients using clinetsCron() in\n * a more incremental way (depending on server.hz). */\nint clientsCronTrackClientsMemUsage(client *c) {\n    size_t mem = 0;\n    int type = getClientType(c);\n    mem += getClientOutputBufferMemoryUsage(c);\n    mem += sdsZmallocSize(c->querybuf);\n    mem += zmalloc_size(c);\n    mem += c->argv_len_sum;\n    if (c->argv) mem += zmalloc_size(c->argv);\n    /* Now that we have the memory used by the client, remove the old\n     * value from the old category, and add it back. */\n    server.stat_clients_type_memory[c->client_cron_last_memory_type] -=\n        c->client_cron_last_memory_usage;\n    server.stat_clients_type_memory[type] += mem;\n    /* Remember what we added and where, to remove it next time. */\n    c->client_cron_last_memory_usage = mem;\n    c->client_cron_last_memory_type = type;\n    return 0;\n}\n\n/* Return the max samples in the memory usage of clients tracked by\n * the function clientsCronTrackExpansiveClients(). */\nvoid getExpansiveClientsInfo(size_t *in_usage, size_t *out_usage) {\n    size_t i = 0, o = 0;\n    for (int j = 0; j < CLIENTS_PEAK_MEM_USAGE_SLOTS; j++) {\n        if (ClientsPeakMemInput[j] > i) i = ClientsPeakMemInput[j];\n        if (ClientsPeakMemOutput[j] > o) o = ClientsPeakMemOutput[j];\n    }\n    *in_usage = i;\n    *out_usage = o;\n}\n\n/* This function is called by serverCron() and is used in order to perform\n * operations on clients that are important to perform constantly. For instance\n * we use this function in order to disconnect clients after a timeout, including\n * clients blocked in some blocking command with a non-zero timeout.\n *\n * The function makes some effort to process all the clients every second, even\n * if this cannot be strictly guaranteed, since serverCron() may be called with\n * an actual frequency lower than server.hz in case of latency events like slow\n * commands.\n *\n * It is very important for this function, and the functions it calls, to be\n * very fast: sometimes Redis has tens of hundreds of connected clients, and the\n * default server.hz value is 10, so sometimes here we need to process thousands\n * of clients per second, turning this function into a source of latency.\n */\n#define CLIENTS_CRON_MIN_ITERATIONS 5\nvoid clientsCron(void) {\n    /* Try to process at least numclients/server.hz of clients\n     * per call. Since normally (if there are no big latency events) this\n     * function is called server.hz times per second, in the average case we\n     * process all the clients in 1 second. */\n    int numclients = listLength(server.clients);\n    int iterations = numclients/server.hz;\n    mstime_t now = mstime();\n\n    /* Process at least a few clients while we are at it, even if we need\n     * to process less than CLIENTS_CRON_MIN_ITERATIONS to meet our contract\n     * of processing each client once per second. */\n    if (iterations < CLIENTS_CRON_MIN_ITERATIONS)\n        iterations = (numclients < CLIENTS_CRON_MIN_ITERATIONS) ?\n                     numclients : CLIENTS_CRON_MIN_ITERATIONS;\n\n    while(listLength(server.clients) && iterations--) {\n        client *c;\n        listNode *head;\n\n        /* Rotate the list, take the current head, process.\n         * This way if the client must be removed from the list it's the\n         * first element and we don't incur into O(N) computation. */\n        listRotateTailToHead(server.clients);\n        head = listFirst(server.clients);\n        c = listNodeValue(head);\n        /* The following functions do different service checks on the client.\n         * The protocol is that they return non-zero if the client was\n         * terminated. */\n        if (clientsCronHandleTimeout(c,now)) continue;\n        if (clientsCronResizeQueryBuffer(c)) continue;\n        if (clientsCronTrackExpansiveClients(c)) continue;\n        if (clientsCronTrackClientsMemUsage(c)) continue;\n    }\n}\n\n/* This function handles 'background' operations we are required to do\n * incrementally in Redis databases, such as active key expiring, resizing,\n * rehashing. */\nvoid databasesCron(void) {\n    /* Expire keys by random sampling. Not required for slaves\n     * as master will synthesize DELs for us. */\n    if (server.active_expire_enabled) {\n        if (iAmMaster()) {\n            activeExpireCycle(ACTIVE_EXPIRE_CYCLE_SLOW);\n        } else {\n            expireSlaveKeys();\n        }\n    }\n\n    /* Defrag keys gradually. */\n    activeDefragCycle();\n\n    /* Perform hash tables rehashing if needed, but only if there are no\n     * other processes saving the DB on disk. Otherwise rehashing is bad\n     * as will cause a lot of copy-on-write of memory pages. */\n    if (!hasActiveChildProcess()) {\n        /* We use global counters so if we stop the computation at a given\n         * DB we'll be able to start from the successive in the next\n         * cron loop iteration. */\n        static unsigned int resize_db = 0;\n        static unsigned int rehash_db = 0;\n        int dbs_per_call = CRON_DBS_PER_CALL;\n        int j;\n\n        /* Don't test more DBs than we have. */\n        if (dbs_per_call > server.dbnum) dbs_per_call = server.dbnum;\n\n        /* Resize */\n        for (j = 0; j < dbs_per_call; j++) {\n            tryResizeHashTables(resize_db % server.dbnum);\n            resize_db++;\n        }\n\n        /* Rehash */\n        if (server.activerehashing) {\n            for (j = 0; j < dbs_per_call; j++) {\n                int work_done = incrementallyRehash(rehash_db);\n                if (work_done) {\n                    /* If the function did some work, stop here, we'll do\n                     * more at the next cron loop. */\n                    break;\n                } else {\n                    /* If this db didn't need rehash, we'll try the next one. */\n                    rehash_db++;\n                    rehash_db %= server.dbnum;\n                }\n            }\n        }\n    }\n}\n\n/* We take a cached value of the unix time in the global state because with\n * virtual memory and aging there is to store the current time in objects at\n * every object access, and accuracy is not needed. To access a global var is\n * a lot faster than calling time(NULL).\n *\n * This function should be fast because it is called at every command execution\n * in call(), so it is possible to decide if to update the daylight saving\n * info or not using the 'update_daylight_info' argument. Normally we update\n * such info only when calling this function from serverCron() but not when\n * calling it from call(). */\nvoid updateCachedTime(int update_daylight_info) {\n    server.ustime = ustime();\n    server.mstime = server.ustime / 1000;\n    server.unixtime = server.mstime / 1000;\n\n    /* To get information about daylight saving time, we need to call\n     * localtime_r and cache the result. However calling localtime_r in this\n     * context is safe since we will never fork() while here, in the main\n     * thread. The logging function will call a thread safe version of\n     * localtime that has no locks. */\n    if (update_daylight_info) {\n        struct tm tm;\n        time_t ut = server.unixtime;\n        localtime_r(&ut,&tm);\n        server.daylight_active = tm.tm_isdst;\n    }\n}\n\nvoid checkChildrenDone(void) {\n    int statloc;\n    pid_t pid;\n\n    if ((pid = wait3(&statloc,WNOHANG,NULL)) != 0) {\n        int exitcode = WEXITSTATUS(statloc);\n        int bysignal = 0;\n\n        if (WIFSIGNALED(statloc)) bysignal = WTERMSIG(statloc);\n\n        /* sigKillChildHandler catches the signal and calls exit(), but we\n         * must make sure not to flag lastbgsave_status, etc incorrectly.\n         * We could directly terminate the child process via SIGUSR1\n         * without handling it, but in this case Valgrind will log an\n         * annoying error. */\n        if (exitcode == SERVER_CHILD_NOERROR_RETVAL) {\n            bysignal = SIGUSR1;\n            exitcode = 1;\n        }\n\n        if (pid == -1) {\n            serverLog(LL_WARNING,\"wait3() returned an error: %s. \"\n                \"rdb_child_pid = %d, aof_child_pid = %d, module_child_pid = %d\",\n                strerror(errno),\n                (int) server.rdb_child_pid,\n                (int) server.aof_child_pid,\n                (int) server.module_child_pid);\n        } else if (pid == server.rdb_child_pid) {\n            backgroundSaveDoneHandler(exitcode,bysignal);\n            if (!bysignal && exitcode == 0) receiveChildInfo();\n        } else if (pid == server.aof_child_pid) {\n            backgroundRewriteDoneHandler(exitcode,bysignal);\n            if (!bysignal && exitcode == 0) receiveChildInfo();\n        } else if (pid == server.module_child_pid) {\n            ModuleForkDoneHandler(exitcode,bysignal);\n            if (!bysignal && exitcode == 0) receiveChildInfo();\n        } else {\n            if (!ldbRemoveChild(pid)) {\n                serverLog(LL_WARNING,\n                    \"Warning, detected child with unmatched pid: %ld\",\n                    (long)pid);\n            }\n        }\n        updateDictResizePolicy();\n        closeChildInfoPipe();\n    }\n}\n\n/* This is our timer interrupt, called server.hz times per second.\n * Here is where we do a number of things that need to be done asynchronously.\n * For instance:\n *\n * - Active expired keys collection (it is also performed in a lazy way on\n *   lookup).\n * - Software watchdog.\n * - Update some statistic.\n * - Incremental rehashing of the DBs hash tables.\n * - Triggering BGSAVE / AOF rewrite, and handling of terminated children.\n * - Clients timeout of different kinds.\n * - Replication reconnection.\n * - Many more...\n *\n * Everything directly called here will be called server.hz times per second,\n * so in order to throttle execution of things we want to do less frequently\n * a macro is used: run_with_period(milliseconds) { .... }\n */\n\nint serverCron(struct aeEventLoop *eventLoop, long long id, void *clientData) {\n    int j;\n    UNUSED(eventLoop);\n    UNUSED(id);\n    UNUSED(clientData);\n\n    /* Software watchdog: deliver the SIGALRM that will reach the signal\n     * handler if we don't return here fast enough. */\n    if (server.watchdog_period) watchdogScheduleSignal(server.watchdog_period);\n\n    /* Update the time cache. */\n    updateCachedTime(1);\n\n    server.hz = server.config_hz;\n    /* Adapt the server.hz value to the number of configured clients. If we have\n     * many clients, we want to call serverCron() with an higher frequency. */\n    if (server.dynamic_hz) {\n        while (listLength(server.clients) / server.hz >\n               MAX_CLIENTS_PER_CLOCK_TICK)\n        {\n            server.hz *= 2;\n            if (server.hz > CONFIG_MAX_HZ) {\n                server.hz = CONFIG_MAX_HZ;\n                break;\n            }\n        }\n    }\n\n    run_with_period(100) {\n        trackInstantaneousMetric(STATS_METRIC_COMMAND,server.stat_numcommands);\n        trackInstantaneousMetric(STATS_METRIC_NET_INPUT,\n                server.stat_net_input_bytes);\n        trackInstantaneousMetric(STATS_METRIC_NET_OUTPUT,\n                server.stat_net_output_bytes);\n    }\n\n    /* We have just LRU_BITS bits per object for LRU information.\n     * So we use an (eventually wrapping) LRU clock.\n     *\n     * Note that even if the counter wraps it's not a big problem,\n     * everything will still work but some object will appear younger\n     * to Redis. However for this to happen a given object should never be\n     * touched for all the time needed to the counter to wrap, which is\n     * not likely.\n     *\n     * Note that you can change the resolution altering the\n     * LRU_CLOCK_RESOLUTION define. */\n    server.lruclock = getLRUClock();\n\n    /* Record the max memory used since the server was started. */\n    if (zmalloc_used_memory() > server.stat_peak_memory)\n        server.stat_peak_memory = zmalloc_used_memory();\n\n    run_with_period(100) {\n        /* Sample the RSS and other metrics here since this is a relatively slow call.\n         * We must sample the zmalloc_used at the same time we take the rss, otherwise\n         * the frag ratio calculate may be off (ratio of two samples at different times) */\n        server.cron_malloc_stats.process_rss = zmalloc_get_rss();\n        server.cron_malloc_stats.zmalloc_used = zmalloc_used_memory();\n        /* Sampling the allcator info can be slow too.\n         * The fragmentation ratio it'll show is potentically more accurate\n         * it excludes other RSS pages such as: shared libraries, LUA and other non-zmalloc\n         * allocations, and allocator reserved pages that can be pursed (all not actual frag) */\n        zmalloc_get_allocator_info(&server.cron_malloc_stats.allocator_allocated,\n                                   &server.cron_malloc_stats.allocator_active,\n                                   &server.cron_malloc_stats.allocator_resident);\n        /* in case the allocator isn't providing these stats, fake them so that\n         * fragmention info still shows some (inaccurate metrics) */\n        if (!server.cron_malloc_stats.allocator_resident) {\n            /* LUA memory isn't part of zmalloc_used, but it is part of the process RSS,\n             * so we must desuct it in order to be able to calculate correct\n             * \"allocator fragmentation\" ratio */\n            size_t lua_memory = lua_gc(server.lua,LUA_GCCOUNT,0)*1024LL;\n            server.cron_malloc_stats.allocator_resident = server.cron_malloc_stats.process_rss - lua_memory;\n        }\n        if (!server.cron_malloc_stats.allocator_active)\n            server.cron_malloc_stats.allocator_active = server.cron_malloc_stats.allocator_resident;\n        if (!server.cron_malloc_stats.allocator_allocated)\n            server.cron_malloc_stats.allocator_allocated = server.cron_malloc_stats.zmalloc_used;\n    }\n\n    /* We received a SIGTERM, shutting down here in a safe way, as it is\n     * not ok doing so inside the signal handler. */\n    if (server.shutdown_asap) {\n        if (prepareForShutdown(SHUTDOWN_NOFLAGS) == C_OK) exit(0);\n        serverLog(LL_WARNING,\"SIGTERM received but errors trying to shut down the server, check the logs for more information\");\n        server.shutdown_asap = 0;\n    }\n\n    /* Show some info about non-empty databases */\n    run_with_period(5000) {\n        for (j = 0; j < server.dbnum; j++) {\n            long long size, used, vkeys;\n\n            size = dictSlots(server.db[j].dict);\n            used = dictSize(server.db[j].dict);\n            vkeys = dictSize(server.db[j].expires);\n            if (used || vkeys) {\n                serverLog(LL_VERBOSE,\"DB %d: %lld keys (%lld volatile) in %lld slots HT.\",j,used,vkeys,size);\n                /* dictPrintStats(server.dict); */\n            }\n        }\n    }\n\n    /* Show information about connected clients */\n    if (!server.sentinel_mode) {\n        run_with_period(5000) {\n            serverLog(LL_DEBUG,\n                \"%lu clients connected (%lu replicas), %zu bytes in use\",\n                listLength(server.clients)-listLength(server.slaves),\n                listLength(server.slaves),\n                zmalloc_used_memory());\n        }\n    }\n\n    /* We need to do a few operations on clients asynchronously. */\n    clientsCron();\n\n    /* Handle background operations on Redis databases. */\n    databasesCron();\n\n    /* Start a scheduled AOF rewrite if this was requested by the user while\n     * a BGSAVE was in progress. */\n    if (!hasActiveChildProcess() &&\n        server.aof_rewrite_scheduled)\n    {\n        rewriteAppendOnlyFileBackground();\n    }\n\n    /* Check if a background saving or AOF rewrite in progress terminated. */\n    if (hasActiveChildProcess() || ldbPendingChildren())\n    {\n        checkChildrenDone();\n    } else {\n        /* If there is not a background saving/rewrite in progress check if\n         * we have to save/rewrite now. */\n        for (j = 0; j < server.saveparamslen; j++) {\n            struct saveparam *sp = server.saveparams+j;\n\n            /* Save if we reached the given amount of changes,\n             * the given amount of seconds, and if the latest bgsave was\n             * successful or if, in case of an error, at least\n             * CONFIG_BGSAVE_RETRY_DELAY seconds already elapsed. */\n            if (server.dirty >= sp->changes &&\n                server.unixtime-server.lastsave > sp->seconds &&\n                (server.unixtime-server.lastbgsave_try >\n                 CONFIG_BGSAVE_RETRY_DELAY ||\n                 server.lastbgsave_status == C_OK))\n            {\n                serverLog(LL_NOTICE,\"%d changes in %d seconds. Saving...\",\n                    sp->changes, (int)sp->seconds);\n                rdbSaveInfo rsi, *rsiptr;\n                rsiptr = rdbPopulateSaveInfo(&rsi);\n                rdbSaveBackground(server.rdb_filename,rsiptr);\n                break;\n            }\n        }\n\n        /* Trigger an AOF rewrite if needed. */\n        if (server.aof_state == AOF_ON &&\n            !hasActiveChildProcess() &&\n            server.aof_rewrite_perc &&\n            server.aof_current_size > server.aof_rewrite_min_size)\n        {\n            long long base = server.aof_rewrite_base_size ?\n                server.aof_rewrite_base_size : 1;\n            long long growth = (server.aof_current_size*100/base) - 100;\n            if (growth >= server.aof_rewrite_perc) {\n                serverLog(LL_NOTICE,\"Starting automatic rewriting of AOF on %lld%% growth\",growth);\n                rewriteAppendOnlyFileBackground();\n            }\n        }\n    }\n    /* Just for the sake of defensive programming, to avoid forgeting to\n     * call this function when need. */\n    updateDictResizePolicy();\n\n\n    /* AOF postponed flush: Try at every cron cycle if the slow fsync\n     * completed. */\n    if (server.aof_flush_postponed_start) flushAppendOnlyFile(0);\n\n    /* AOF write errors: in this case we have a buffer to flush as well and\n     * clear the AOF error in case of success to make the DB writable again,\n     * however to try every second is enough in case of 'hz' is set to\n     * a higher frequency. */\n    run_with_period(1000) {\n        if (server.aof_last_write_status == C_ERR)\n            flushAppendOnlyFile(0);\n    }\n\n    /* Clear the paused clients flag if needed. */\n    clientsArePaused(); /* Don't check return value, just use the side effect.*/\n\n    /* Replication cron function -- used to reconnect to master,\n     * detect transfer failures, start background RDB transfers and so forth. */\n    run_with_period(1000) replicationCron();\n\n    /* Run the Redis Cluster cron. */\n    run_with_period(100) {\n        if (server.cluster_enabled) clusterCron();\n    }\n\n    /* Run the Sentinel timer if we are in sentinel mode. */\n    if (server.sentinel_mode) sentinelTimer();\n\n    /* Cleanup expired MIGRATE cached sockets. */\n    run_with_period(1000) {\n        migrateCloseTimedoutSockets();\n    }\n\n    /* Stop the I/O threads if we don't have enough pending work. */\n    stopThreadedIOIfNeeded();\n\n    /* Resize tracking keys table if needed. This is also done at every\n     * command execution, but we want to be sure that if the last command\n     * executed changes the value via CONFIG SET, the server will perform\n     * the operation even if completely idle. */\n    if (server.tracking_clients) trackingLimitUsedSlots();\n\n    /* Start a scheduled BGSAVE if the corresponding flag is set. This is\n     * useful when we are forced to postpone a BGSAVE because an AOF\n     * rewrite is in progress.\n     *\n     * Note: this code must be after the replicationCron() call above so\n     * make sure when refactoring this file to keep this order. This is useful\n     * because we want to give priority to RDB savings for replication. */\n    if (!hasActiveChildProcess() &&\n        server.rdb_bgsave_scheduled &&\n        (server.unixtime-server.lastbgsave_try > CONFIG_BGSAVE_RETRY_DELAY ||\n         server.lastbgsave_status == C_OK))\n    {\n        rdbSaveInfo rsi, *rsiptr;\n        rsiptr = rdbPopulateSaveInfo(&rsi);\n        if (rdbSaveBackground(server.rdb_filename,rsiptr) == C_OK)\n            server.rdb_bgsave_scheduled = 0;\n    }\n\n    /* Fire the cron loop modules event. */\n    RedisModuleCronLoopV1 ei = {REDISMODULE_CRON_LOOP_VERSION,server.hz};\n    moduleFireServerEvent(REDISMODULE_EVENT_CRON_LOOP,\n                          0,\n                          &ei);\n\n    server.cronloops++;\n    return 1000/server.hz;\n}\n\nextern int ProcessingEventsWhileBlocked;\n\n/* This function gets called every time Redis is entering the\n * main loop of the event driven library, that is, before to sleep\n * for ready file descriptors.\n *\n * Note: This function is (currently) called from two functions:\n * 1. aeMain - The main server loop\n * 2. processEventsWhileBlocked - Process clients during RDB/AOF load\n *\n * If it was called from processEventsWhileBlocked we don't want\n * to perform all actions (For example, we don't want to expire\n * keys), but we do need to perform some actions.\n *\n * The most important is freeClientsInAsyncFreeQueue but we also\n * call some other low-risk functions. */\nvoid beforeSleep(struct aeEventLoop *eventLoop) {\n    UNUSED(eventLoop);\n\n    size_t zmalloc_used = zmalloc_used_memory();\n    if (zmalloc_used > server.stat_peak_memory)\n        server.stat_peak_memory = zmalloc_used;\n\n    /* Just call a subset of vital functions in case we are re-entering\n     * the event loop from processEventsWhileBlocked(). Note that in this\n     * case we keep track of the number of events we are processing, since\n     * processEventsWhileBlocked() wants to stop ASAP if there are no longer\n     * events to handle. */\n    if (ProcessingEventsWhileBlocked) {\n        uint64_t processed = 0;\n        processed += handleClientsWithPendingReadsUsingThreads();\n        processed += tlsProcessPendingData();\n        processed += handleClientsWithPendingWrites();\n        processed += freeClientsInAsyncFreeQueue();\n        server.events_processed_while_blocked += processed;\n        return;\n    }\n\n    /* Handle precise timeouts of blocked clients. */\n    handleBlockedClientsTimeout();\n\n    /* We should handle pending reads clients ASAP after event loop. */\n    handleClientsWithPendingReadsUsingThreads();\n\n    /* Handle TLS pending data. (must be done before flushAppendOnlyFile) */\n    tlsProcessPendingData();\n\n    /* If tls still has pending unread data don't sleep at all. */\n    aeSetDontWait(server.el, tlsHasPendingData());\n\n    /* Call the Redis Cluster before sleep function. Note that this function\n     * may change the state of Redis Cluster (from ok to fail or vice versa),\n     * so it's a good idea to call it before serving the unblocked clients\n     * later in this function. */\n    if (server.cluster_enabled) clusterBeforeSleep();\n\n    /* Run a fast expire cycle (the called function will return\n     * ASAP if a fast cycle is not needed). */\n    if (server.active_expire_enabled && server.masterhost == NULL)\n        activeExpireCycle(ACTIVE_EXPIRE_CYCLE_FAST);\n\n    /* Unblock all the clients blocked for synchronous replication\n     * in WAIT. */\n    if (listLength(server.clients_waiting_acks))\n        processClientsWaitingReplicas();\n\n    /* Check if there are clients unblocked by modules that implement\n     * blocking commands. */\n    if (moduleCount()) moduleHandleBlockedClients();\n\n    /* Try to process pending commands for clients that were just unblocked. */\n    if (listLength(server.unblocked_clients))\n        processUnblockedClients();\n\n    /* Send all the slaves an ACK request if at least one client blocked\n     * during the previous event loop iteration. Note that we do this after\n     * processUnblockedClients(), so if there are multiple pipelined WAITs\n     * and the just unblocked WAIT gets blocked again, we don't have to wait\n     * a server cron cycle in absence of other event loop events. See #6623. */\n    if (server.get_ack_from_slaves) {\n        robj *argv[3];\n\n        argv[0] = createStringObject(\"REPLCONF\",8);\n        argv[1] = createStringObject(\"GETACK\",6);\n        argv[2] = createStringObject(\"*\",1); /* Not used argument. */\n        replicationFeedSlaves(server.slaves, server.slaveseldb, argv, 3);\n        decrRefCount(argv[0]);\n        decrRefCount(argv[1]);\n        decrRefCount(argv[2]);\n        server.get_ack_from_slaves = 0;\n    }\n\n    /* Send the invalidation messages to clients participating to the\n     * client side caching protocol in broadcasting (BCAST) mode. */\n    trackingBroadcastInvalidationMessages();\n\n    /* Write the AOF buffer on disk */\n    flushAppendOnlyFile(0);\n\n    /* Handle writes with pending output buffers. */\n    handleClientsWithPendingWritesUsingThreads();\n\n    /* Close clients that need to be closed asynchronous */\n    freeClientsInAsyncFreeQueue();\n\n    /* Try to process blocked clients every once in while. Example: A module\n     * calls RM_SignalKeyAsReady from within a timer callback (So we don't\n     * visit processCommand() at all). */\n    handleClientsBlockedOnKeys();\n\n    /* Before we are going to sleep, let the threads access the dataset by\n     * releasing the GIL. Redis main thread will not touch anything at this\n     * time. */\n    if (moduleCount()) moduleReleaseGIL();\n\n    /* Do NOT add anything below moduleReleaseGIL !!! */\n}\n\n/* This function is called immediately after the event loop multiplexing\n * API returned, and the control is going to soon return to Redis by invoking\n * the different events callbacks. */\nvoid afterSleep(struct aeEventLoop *eventLoop) {\n    UNUSED(eventLoop);\n\n    /* Do NOT add anything above moduleAcquireGIL !!! */\n\n    /* Aquire the modules GIL so that their threads won't touch anything. */\n    if (!ProcessingEventsWhileBlocked) {\n        if (moduleCount()) moduleAcquireGIL();\n    }\n}\n\n/* =========================== Server initialization ======================== */\n\nvoid createSharedObjects(void) {\n    int j;\n\n    shared.crlf = createObject(OBJ_STRING,sdsnew(\"\\r\\n\"));\n    shared.ok = createObject(OBJ_STRING,sdsnew(\"+OK\\r\\n\"));\n    shared.err = createObject(OBJ_STRING,sdsnew(\"-ERR\\r\\n\"));\n    shared.emptybulk = createObject(OBJ_STRING,sdsnew(\"$0\\r\\n\\r\\n\"));\n    shared.czero = createObject(OBJ_STRING,sdsnew(\":0\\r\\n\"));\n    shared.cone = createObject(OBJ_STRING,sdsnew(\":1\\r\\n\"));\n    shared.emptyarray = createObject(OBJ_STRING,sdsnew(\"*0\\r\\n\"));\n    shared.pong = createObject(OBJ_STRING,sdsnew(\"+PONG\\r\\n\"));\n    shared.queued = createObject(OBJ_STRING,sdsnew(\"+QUEUED\\r\\n\"));\n    shared.emptyscan = createObject(OBJ_STRING,sdsnew(\"*2\\r\\n$1\\r\\n0\\r\\n*0\\r\\n\"));\n    shared.wrongtypeerr = createObject(OBJ_STRING,sdsnew(\n        \"-WRONGTYPE Operation against a key holding the wrong kind of value\\r\\n\"));\n    shared.nokeyerr = createObject(OBJ_STRING,sdsnew(\n        \"-ERR no such key\\r\\n\"));\n    shared.syntaxerr = createObject(OBJ_STRING,sdsnew(\n        \"-ERR syntax error\\r\\n\"));\n    shared.sameobjecterr = createObject(OBJ_STRING,sdsnew(\n        \"-ERR source and destination objects are the same\\r\\n\"));\n    shared.outofrangeerr = createObject(OBJ_STRING,sdsnew(\n        \"-ERR index out of range\\r\\n\"));\n    shared.noscripterr = createObject(OBJ_STRING,sdsnew(\n        \"-NOSCRIPT No matching script. Please use EVAL.\\r\\n\"));\n    shared.loadingerr = createObject(OBJ_STRING,sdsnew(\n        \"-LOADING Redis is loading the dataset in memory\\r\\n\"));\n    shared.slowscripterr = createObject(OBJ_STRING,sdsnew(\n        \"-BUSY Redis is busy running a script. You can only call SCRIPT KILL or SHUTDOWN NOSAVE.\\r\\n\"));\n    shared.masterdownerr = createObject(OBJ_STRING,sdsnew(\n        \"-MASTERDOWN Link with MASTER is down and replica-serve-stale-data is set to 'no'.\\r\\n\"));\n    shared.bgsaveerr = createObject(OBJ_STRING,sdsnew(\n        \"-MISCONF Redis is configured to save RDB snapshots, but it is currently not able to persist on disk. Commands that may modify the data set are disabled, because this instance is configured to report errors during writes if RDB snapshotting fails (stop-writes-on-bgsave-error option). Please check the Redis logs for details about the RDB error.\\r\\n\"));\n    shared.roslaveerr = createObject(OBJ_STRING,sdsnew(\n        \"-READONLY You can't write against a read only replica.\\r\\n\"));\n    shared.noautherr = createObject(OBJ_STRING,sdsnew(\n        \"-NOAUTH Authentication required.\\r\\n\"));\n    shared.oomerr = createObject(OBJ_STRING,sdsnew(\n        \"-OOM command not allowed when used memory > 'maxmemory'.\\r\\n\"));\n    shared.execaborterr = createObject(OBJ_STRING,sdsnew(\n        \"-EXECABORT Transaction discarded because of previous errors.\\r\\n\"));\n    shared.noreplicaserr = createObject(OBJ_STRING,sdsnew(\n        \"-NOREPLICAS Not enough good replicas to write.\\r\\n\"));\n    shared.busykeyerr = createObject(OBJ_STRING,sdsnew(\n        \"-BUSYKEY Target key name already exists.\\r\\n\"));\n    shared.space = createObject(OBJ_STRING,sdsnew(\" \"));\n    shared.colon = createObject(OBJ_STRING,sdsnew(\":\"));\n    shared.plus = createObject(OBJ_STRING,sdsnew(\"+\"));\n\n    /* The shared NULL depends on the protocol version. */\n    shared.null[0] = NULL;\n    shared.null[1] = NULL;\n    shared.null[2] = createObject(OBJ_STRING,sdsnew(\"$-1\\r\\n\"));\n    shared.null[3] = createObject(OBJ_STRING,sdsnew(\"_\\r\\n\"));\n\n    shared.nullarray[0] = NULL;\n    shared.nullarray[1] = NULL;\n    shared.nullarray[2] = createObject(OBJ_STRING,sdsnew(\"*-1\\r\\n\"));\n    shared.nullarray[3] = createObject(OBJ_STRING,sdsnew(\"_\\r\\n\"));\n\n    shared.emptymap[0] = NULL;\n    shared.emptymap[1] = NULL;\n    shared.emptymap[2] = createObject(OBJ_STRING,sdsnew(\"*0\\r\\n\"));\n    shared.emptymap[3] = createObject(OBJ_STRING,sdsnew(\"%0\\r\\n\"));\n\n    shared.emptyset[0] = NULL;\n    shared.emptyset[1] = NULL;\n    shared.emptyset[2] = createObject(OBJ_STRING,sdsnew(\"*0\\r\\n\"));\n    shared.emptyset[3] = createObject(OBJ_STRING,sdsnew(\"~0\\r\\n\"));\n\n    for (j = 0; j < PROTO_SHARED_SELECT_CMDS; j++) {\n        char dictid_str[64];\n        int dictid_len;\n\n        dictid_len = ll2string(dictid_str,sizeof(dictid_str),j);\n        shared.select[j] = createObject(OBJ_STRING,\n            sdscatprintf(sdsempty(),\n                \"*2\\r\\n$6\\r\\nSELECT\\r\\n$%d\\r\\n%s\\r\\n\",\n                dictid_len, dictid_str));\n    }\n    shared.messagebulk = createStringObject(\"$7\\r\\nmessage\\r\\n\",13);\n    shared.pmessagebulk = createStringObject(\"$8\\r\\npmessage\\r\\n\",14);\n    shared.subscribebulk = createStringObject(\"$9\\r\\nsubscribe\\r\\n\",15);\n    shared.unsubscribebulk = createStringObject(\"$11\\r\\nunsubscribe\\r\\n\",18);\n    shared.psubscribebulk = createStringObject(\"$10\\r\\npsubscribe\\r\\n\",17);\n    shared.punsubscribebulk = createStringObject(\"$12\\r\\npunsubscribe\\r\\n\",19);\n    shared.del = createStringObject(\"DEL\",3);\n    shared.unlink = createStringObject(\"UNLINK\",6);\n    shared.rpop = createStringObject(\"RPOP\",4);\n    shared.lpop = createStringObject(\"LPOP\",4);\n    shared.lpush = createStringObject(\"LPUSH\",5);\n    shared.rpoplpush = createStringObject(\"RPOPLPUSH\",9);\n    shared.zpopmin = createStringObject(\"ZPOPMIN\",7);\n    shared.zpopmax = createStringObject(\"ZPOPMAX\",7);\n    shared.multi = createStringObject(\"MULTI\",5);\n    shared.exec = createStringObject(\"EXEC\",4);\n    for (j = 0; j < OBJ_SHARED_INTEGERS; j++) {\n        shared.integers[j] =\n            makeObjectShared(createObject(OBJ_STRING,(void*)(long)j));\n        shared.integers[j]->encoding = OBJ_ENCODING_INT;\n    }\n    for (j = 0; j < OBJ_SHARED_BULKHDR_LEN; j++) {\n        shared.mbulkhdr[j] = createObject(OBJ_STRING,\n            sdscatprintf(sdsempty(),\"*%d\\r\\n\",j));\n        shared.bulkhdr[j] = createObject(OBJ_STRING,\n            sdscatprintf(sdsempty(),\"$%d\\r\\n\",j));\n    }\n    /* The following two shared objects, minstring and maxstrings, are not\n     * actually used for their value but as a special object meaning\n     * respectively the minimum possible string and the maximum possible\n     * string in string comparisons for the ZRANGEBYLEX command. */\n    shared.minstring = sdsnew(\"minstring\");\n    shared.maxstring = sdsnew(\"maxstring\");\n}\n\nvoid initServerConfig(void) {\n    int j;\n\n    updateCachedTime(1);\n    getRandomHexChars(server.runid,CONFIG_RUN_ID_SIZE);\n    server.runid[CONFIG_RUN_ID_SIZE] = '\\0';\n    changeReplicationId();\n    clearReplicationId2();\n    server.hz = CONFIG_DEFAULT_HZ; /* Initialize it ASAP, even if it may get\n                                      updated later after loading the config.\n                                      This value may be used before the server\n                                      is initialized. */\n    server.timezone = getTimeZone(); /* Initialized by tzset(). */\n    server.configfile = NULL;\n    server.executable = NULL;\n    server.arch_bits = (sizeof(long) == 8) ? 64 : 32;\n    server.bindaddr_count = 0;\n    server.unixsocketperm = CONFIG_DEFAULT_UNIX_SOCKET_PERM;\n    server.ipfd_count = 0;\n    server.tlsfd_count = 0;\n    server.sofd = -1;\n    server.active_expire_enabled = 1;\n    server.client_max_querybuf_len = PROTO_MAX_QUERYBUF_LEN;\n    server.saveparams = NULL;\n    server.loading = 0;\n    server.logfile = zstrdup(CONFIG_DEFAULT_LOGFILE);\n    server.aof_state = AOF_OFF;\n    server.aof_rewrite_base_size = 0;\n    server.aof_rewrite_scheduled = 0;\n    server.aof_flush_sleep = 0;\n    server.aof_last_fsync = time(NULL);\n    server.aof_rewrite_time_last = -1;\n    server.aof_rewrite_time_start = -1;\n    server.aof_lastbgrewrite_status = C_OK;\n    server.aof_delayed_fsync = 0;\n    server.aof_fd = -1;\n    server.aof_selected_db = -1; /* Make sure the first time will not match */\n    server.aof_flush_postponed_start = 0;\n    server.pidfile = NULL;\n    server.active_defrag_running = 0;\n    server.notify_keyspace_events = 0;\n    server.blocked_clients = 0;\n    memset(server.blocked_clients_by_type,0,\n           sizeof(server.blocked_clients_by_type));\n    server.shutdown_asap = 0;\n    server.cluster_configfile = zstrdup(CONFIG_DEFAULT_CLUSTER_CONFIG_FILE);\n    server.cluster_module_flags = CLUSTER_MODULE_FLAG_NONE;\n    server.migrate_cached_sockets = dictCreate(&migrateCacheDictType,NULL);\n    server.next_client_id = 1; /* Client IDs, start from 1 .*/\n    server.loading_process_events_interval_bytes = (1024*1024*2);\n\n    server.lruclock = getLRUClock();\n    resetServerSaveParams();\n\n    appendServerSaveParams(60*60,1);  /* save after 1 hour and 1 change */\n    appendServerSaveParams(300,100);  /* save after 5 minutes and 100 changes */\n    appendServerSaveParams(60,10000); /* save after 1 minute and 10000 changes */\n\n    /* Replication related */\n    server.masterauth = NULL;\n    server.masterhost = NULL;\n    server.masterport = 6379;\n    server.master = NULL;\n    server.cached_master = NULL;\n    server.master_initial_offset = -1;\n    server.repl_state = REPL_STATE_NONE;\n    server.repl_transfer_tmpfile = NULL;\n    server.repl_transfer_fd = -1;\n    server.repl_transfer_s = NULL;\n    server.repl_syncio_timeout = CONFIG_REPL_SYNCIO_TIMEOUT;\n    server.repl_down_since = 0; /* Never connected, repl is down since EVER. */\n    server.master_repl_offset = 0;\n\n    /* Replication partial resync backlog */\n    server.repl_backlog = NULL;\n    server.repl_backlog_histlen = 0;\n    server.repl_backlog_idx = 0;\n    server.repl_backlog_off = 0;\n    server.repl_no_slaves_since = time(NULL);\n\n    /* Client output buffer limits */\n    for (j = 0; j < CLIENT_TYPE_OBUF_COUNT; j++)\n        server.client_obuf_limits[j] = clientBufferLimitsDefaults[j];\n\n    /* Linux OOM Score config */\n    for (j = 0; j < CONFIG_OOM_COUNT; j++)\n        server.oom_score_adj_values[j] = configOOMScoreAdjValuesDefaults[j];\n\n    /* Double constants initialization */\n    R_Zero = 0.0;\n    R_PosInf = 1.0/R_Zero;\n    R_NegInf = -1.0/R_Zero;\n    R_Nan = R_Zero/R_Zero;\n\n    /* Command table -- we initialize it here as it is part of the\n     * initial configuration, since command names may be changed via\n     * redis.conf using the rename-command directive. */\n    server.commands = dictCreate(&commandTableDictType,NULL);\n    server.orig_commands = dictCreate(&commandTableDictType,NULL);\n    populateCommandTable();\n    server.delCommand = lookupCommandByCString(\"del\");\n    server.multiCommand = lookupCommandByCString(\"multi\");\n    server.lpushCommand = lookupCommandByCString(\"lpush\");\n    server.lpopCommand = lookupCommandByCString(\"lpop\");\n    server.rpopCommand = lookupCommandByCString(\"rpop\");\n    server.zpopminCommand = lookupCommandByCString(\"zpopmin\");\n    server.zpopmaxCommand = lookupCommandByCString(\"zpopmax\");\n    server.sremCommand = lookupCommandByCString(\"srem\");\n    server.execCommand = lookupCommandByCString(\"exec\");\n    server.expireCommand = lookupCommandByCString(\"expire\");\n    server.pexpireCommand = lookupCommandByCString(\"pexpire\");\n    server.xclaimCommand = lookupCommandByCString(\"xclaim\");\n    server.xgroupCommand = lookupCommandByCString(\"xgroup\");\n    server.rpoplpushCommand = lookupCommandByCString(\"rpoplpush\");\n\n    /* Debugging */\n    server.assert_failed = \"<no assertion failed>\";\n    server.assert_file = \"<no file>\";\n    server.assert_line = 0;\n    server.bug_report_start = 0;\n    server.watchdog_period = 0;\n\n    /* By default we want scripts to be always replicated by effects\n     * (single commands executed by the script), and not by sending the\n     * script to the slave / AOF. This is the new way starting from\n     * Redis 5. However it is possible to revert it via redis.conf. */\n    server.lua_always_replicate_commands = 1;\n\n    initConfigValues();\n}\n\nextern char **environ;\n\n/* Restart the server, executing the same executable that started this\n * instance, with the same arguments and configuration file.\n *\n * The function is designed to directly call execve() so that the new\n * server instance will retain the PID of the previous one.\n *\n * The list of flags, that may be bitwise ORed together, alter the\n * behavior of this function:\n *\n * RESTART_SERVER_NONE              No flags.\n * RESTART_SERVER_GRACEFULLY        Do a proper shutdown before restarting.\n * RESTART_SERVER_CONFIG_REWRITE    Rewrite the config file before restarting.\n *\n * On success the function does not return, because the process turns into\n * a different process. On error C_ERR is returned. */\nint restartServer(int flags, mstime_t delay) {\n    int j;\n\n    /* Check if we still have accesses to the executable that started this\n     * server instance. */\n    if (access(server.executable,X_OK) == -1) {\n        serverLog(LL_WARNING,\"Can't restart: this process has no \"\n                             \"permissions to execute %s\", server.executable);\n        return C_ERR;\n    }\n\n    /* Config rewriting. */\n    if (flags & RESTART_SERVER_CONFIG_REWRITE &&\n        server.configfile &&\n        rewriteConfig(server.configfile, 0) == -1)\n    {\n        serverLog(LL_WARNING,\"Can't restart: configuration rewrite process \"\n                             \"failed\");\n        return C_ERR;\n    }\n\n    /* Perform a proper shutdown. */\n    if (flags & RESTART_SERVER_GRACEFULLY &&\n        prepareForShutdown(SHUTDOWN_NOFLAGS) != C_OK)\n    {\n        serverLog(LL_WARNING,\"Can't restart: error preparing for shutdown\");\n        return C_ERR;\n    }\n\n    /* Close all file descriptors, with the exception of stdin, stdout, strerr\n     * which are useful if we restart a Redis server which is not daemonized. */\n    for (j = 3; j < (int)server.maxclients + 1024; j++) {\n        /* Test the descriptor validity before closing it, otherwise\n         * Valgrind issues a warning on close(). */\n        if (fcntl(j,F_GETFD) != -1) close(j);\n    }\n\n    /* Execute the server with the original command line. */\n    if (delay) usleep(delay*1000);\n    zfree(server.exec_argv[0]);\n    server.exec_argv[0] = zstrdup(server.executable);\n    execve(server.executable,server.exec_argv,environ);\n\n    /* If an error occurred here, there is nothing we can do, but exit. */\n    _exit(1);\n\n    return C_ERR; /* Never reached. */\n}\n\nstatic void readOOMScoreAdj(void) {\n#ifdef HAVE_PROC_OOM_SCORE_ADJ\n    char buf[64];\n    int fd = open(\"/proc/self/oom_score_adj\", O_RDONLY);\n\n    if (fd < 0) return;\n    if (read(fd, buf, sizeof(buf)) > 0)\n        server.oom_score_adj_base = atoi(buf);\n    close(fd);\n#endif\n}\n\n/* This function will configure the current process's oom_score_adj according\n * to user specified configuration. This is currently implemented on Linux\n * only.\n *\n * A process_class value of -1 implies OOM_CONFIG_MASTER or OOM_CONFIG_REPLICA,\n * depending on current role.\n */\nint setOOMScoreAdj(int process_class) {\n\n    if (server.oom_score_adj == OOM_SCORE_ADJ_NO) return C_OK;\n    if (process_class == -1)\n        process_class = (server.masterhost ? CONFIG_OOM_REPLICA : CONFIG_OOM_MASTER);\n\n    serverAssert(process_class >= 0 && process_class < CONFIG_OOM_COUNT);\n\n#ifdef HAVE_PROC_OOM_SCORE_ADJ\n    int fd;\n    int val;\n    char buf[64];\n\n    val = server.oom_score_adj_values[process_class];\n    if (server.oom_score_adj == OOM_SCORE_RELATIVE)\n        val += server.oom_score_adj_base;\n    if (val > 1000) val = 1000;\n    if (val < -1000) val = -1000;\n\n    snprintf(buf, sizeof(buf) - 1, \"%d\\n\", val);\n\n    fd = open(\"/proc/self/oom_score_adj\", O_WRONLY);\n    if (fd < 0 || write(fd, buf, strlen(buf)) < 0) {\n        serverLog(LOG_WARNING, \"Unable to write oom_score_adj: %s\", strerror(errno));\n        if (fd != -1) close(fd);\n        return C_ERR;\n    }\n\n    close(fd);\n    return C_OK;\n#else\n    /* Unsupported */\n    return C_ERR;\n#endif\n}\n\n/* This function will try to raise the max number of open files accordingly to\n * the configured max number of clients. It also reserves a number of file\n * descriptors (CONFIG_MIN_RESERVED_FDS) for extra operations of\n * persistence, listening sockets, log files and so forth.\n *\n * If it will not be possible to set the limit accordingly to the configured\n * max number of clients, the function will do the reverse setting\n * server.maxclients to the value that we can actually handle. */\nvoid adjustOpenFilesLimit(void) {\n    rlim_t maxfiles = server.maxclients+CONFIG_MIN_RESERVED_FDS;\n    struct rlimit limit;\n\n    if (getrlimit(RLIMIT_NOFILE,&limit) == -1) {\n        serverLog(LL_WARNING,\"Unable to obtain the current NOFILE limit (%s), assuming 1024 and setting the max clients configuration accordingly.\",\n            strerror(errno));\n        server.maxclients = 1024-CONFIG_MIN_RESERVED_FDS;\n    } else {\n        rlim_t oldlimit = limit.rlim_cur;\n\n        /* Set the max number of files if the current limit is not enough\n         * for our needs. */\n        if (oldlimit < maxfiles) {\n            rlim_t bestlimit;\n            int setrlimit_error = 0;\n\n            /* Try to set the file limit to match 'maxfiles' or at least\n             * to the higher value supported less than maxfiles. */\n            bestlimit = maxfiles;\n            while(bestlimit > oldlimit) {\n                rlim_t decr_step = 16;\n\n                limit.rlim_cur = bestlimit;\n                limit.rlim_max = bestlimit;\n                if (setrlimit(RLIMIT_NOFILE,&limit) != -1) break;\n                setrlimit_error = errno;\n\n                /* We failed to set file limit to 'bestlimit'. Try with a\n                 * smaller limit decrementing by a few FDs per iteration. */\n                if (bestlimit < decr_step) break;\n                bestlimit -= decr_step;\n            }\n\n            /* Assume that the limit we get initially is still valid if\n             * our last try was even lower. */\n            if (bestlimit < oldlimit) bestlimit = oldlimit;\n\n            if (bestlimit < maxfiles) {\n                unsigned int old_maxclients = server.maxclients;\n                server.maxclients = bestlimit-CONFIG_MIN_RESERVED_FDS;\n                /* maxclients is unsigned so may overflow: in order\n                 * to check if maxclients is now logically less than 1\n                 * we test indirectly via bestlimit. */\n                if (bestlimit <= CONFIG_MIN_RESERVED_FDS) {\n                    serverLog(LL_WARNING,\"Your current 'ulimit -n' \"\n                        \"of %llu is not enough for the server to start. \"\n                        \"Please increase your open file limit to at least \"\n                        \"%llu. Exiting.\",\n                        (unsigned long long) oldlimit,\n                        (unsigned long long) maxfiles);\n                    exit(1);\n                }\n                serverLog(LL_WARNING,\"You requested maxclients of %d \"\n                    \"requiring at least %llu max file descriptors.\",\n                    old_maxclients,\n                    (unsigned long long) maxfiles);\n                serverLog(LL_WARNING,\"Server can't set maximum open files \"\n                    \"to %llu because of OS error: %s.\",\n                    (unsigned long long) maxfiles, strerror(setrlimit_error));\n                serverLog(LL_WARNING,\"Current maximum open files is %llu. \"\n                    \"maxclients has been reduced to %d to compensate for \"\n                    \"low ulimit. \"\n                    \"If you need higher maxclients increase 'ulimit -n'.\",\n                    (unsigned long long) bestlimit, server.maxclients);\n            } else {\n                serverLog(LL_NOTICE,\"Increased maximum number of open files \"\n                    \"to %llu (it was originally set to %llu).\",\n                    (unsigned long long) maxfiles,\n                    (unsigned long long) oldlimit);\n            }\n        }\n    }\n}\n\n/* Check that server.tcp_backlog can be actually enforced in Linux according\n * to the value of /proc/sys/net/core/somaxconn, or warn about it. */\nvoid checkTcpBacklogSettings(void) {\n#ifdef HAVE_PROC_SOMAXCONN\n    FILE *fp = fopen(\"/proc/sys/net/core/somaxconn\",\"r\");\n    char buf[1024];\n    if (!fp) return;\n    if (fgets(buf,sizeof(buf),fp) != NULL) {\n        int somaxconn = atoi(buf);\n        if (somaxconn > 0 && somaxconn < server.tcp_backlog) {\n            serverLog(LL_WARNING,\"WARNING: The TCP backlog setting of %d cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of %d.\", server.tcp_backlog, somaxconn);\n        }\n    }\n    fclose(fp);\n#endif\n}\n\n/* Initialize a set of file descriptors to listen to the specified 'port'\n * binding the addresses specified in the Redis server configuration.\n *\n * The listening file descriptors are stored in the integer array 'fds'\n * and their number is set in '*count'.\n *\n * The addresses to bind are specified in the global server.bindaddr array\n * and their number is server.bindaddr_count. If the server configuration\n * contains no specific addresses to bind, this function will try to\n * bind * (all addresses) for both the IPv4 and IPv6 protocols.\n *\n * On success the function returns C_OK.\n *\n * On error the function returns C_ERR. For the function to be on\n * error, at least one of the server.bindaddr addresses was\n * impossible to bind, or no bind addresses were specified in the server\n * configuration but the function is not able to bind * for at least\n * one of the IPv4 or IPv6 protocols. */\nint listenToPort(int port, int *fds, int *count) {\n    int j;\n\n    /* Force binding of 0.0.0.0 if no bind address is specified, always\n     * entering the loop if j == 0. */\n    if (server.bindaddr_count == 0) server.bindaddr[0] = NULL;\n    for (j = 0; j < server.bindaddr_count || j == 0; j++) {\n        if (server.bindaddr[j] == NULL) {\n            int unsupported = 0;\n            /* Bind * for both IPv6 and IPv4, we enter here only if\n             * server.bindaddr_count == 0. */\n            fds[*count] = anetTcp6Server(server.neterr,port,NULL,\n                server.tcp_backlog);\n            if (fds[*count] != ANET_ERR) {\n                anetNonBlock(NULL,fds[*count]);\n                (*count)++;\n            } else if (errno == EAFNOSUPPORT) {\n                unsupported++;\n                serverLog(LL_WARNING,\"Not listening to IPv6: unsupported\");\n            }\n\n            if (*count == 1 || unsupported) {\n                /* Bind the IPv4 address as well. */\n                fds[*count] = anetTcpServer(server.neterr,port,NULL,\n                    server.tcp_backlog);\n                if (fds[*count] != ANET_ERR) {\n                    anetNonBlock(NULL,fds[*count]);\n                    (*count)++;\n                } else if (errno == EAFNOSUPPORT) {\n                    unsupported++;\n                    serverLog(LL_WARNING,\"Not listening to IPv4: unsupported\");\n                }\n            }\n            /* Exit the loop if we were able to bind * on IPv4 and IPv6,\n             * otherwise fds[*count] will be ANET_ERR and we'll print an\n             * error and return to the caller with an error. */\n            if (*count + unsupported == 2) break;\n        } else if (strchr(server.bindaddr[j],':')) {\n            /* Bind IPv6 address. */\n            fds[*count] = anetTcp6Server(server.neterr,port,server.bindaddr[j],\n                server.tcp_backlog);\n        } else {\n            /* Bind IPv4 address. */\n            fds[*count] = anetTcpServer(server.neterr,port,server.bindaddr[j],\n                server.tcp_backlog);\n        }\n        if (fds[*count] == ANET_ERR) {\n            int net_errno = errno;\n            serverLog(LL_WARNING,\n                \"Could not create server TCP listening socket %s:%d: %s\",\n                server.bindaddr[j] ? server.bindaddr[j] : \"*\",\n                port, server.neterr);\n                if (net_errno == ENOPROTOOPT     || net_errno == EPROTONOSUPPORT ||\n                    net_errno == ESOCKTNOSUPPORT || net_errno == EPFNOSUPPORT ||\n                    net_errno == EAFNOSUPPORT    || net_errno == EADDRNOTAVAIL)\n                    continue;\n            return C_ERR;\n        }\n        anetNonBlock(NULL,fds[*count]);\n        (*count)++;\n    }\n    return C_OK;\n}\n\n/* Resets the stats that we expose via INFO or other means that we want\n * to reset via CONFIG RESETSTAT. The function is also used in order to\n * initialize these fields in initServer() at server startup. */\nvoid resetServerStats(void) {\n    int j;\n\n    server.stat_numcommands = 0;\n    server.stat_numconnections = 0;\n    server.stat_expiredkeys = 0;\n    server.stat_expired_stale_perc = 0;\n    server.stat_expired_time_cap_reached_count = 0;\n    server.stat_expire_cycle_time_used = 0;\n    server.stat_evictedkeys = 0;\n    server.stat_keyspace_misses = 0;\n    server.stat_keyspace_hits = 0;\n    server.stat_active_defrag_hits = 0;\n    server.stat_active_defrag_misses = 0;\n    server.stat_active_defrag_key_hits = 0;\n    server.stat_active_defrag_key_misses = 0;\n    server.stat_active_defrag_scanned = 0;\n    server.stat_fork_time = 0;\n    server.stat_fork_rate = 0;\n    server.stat_rejected_conn = 0;\n    server.stat_sync_full = 0;\n    server.stat_sync_partial_ok = 0;\n    server.stat_sync_partial_err = 0;\n    server.stat_io_reads_processed = 0;\n    server.stat_total_reads_processed = 0;\n    server.stat_io_writes_processed = 0;\n    server.stat_total_writes_processed = 0;\n    for (j = 0; j < STATS_METRIC_COUNT; j++) {\n        server.inst_metric[j].idx = 0;\n        server.inst_metric[j].last_sample_time = mstime();\n        server.inst_metric[j].last_sample_count = 0;\n        memset(server.inst_metric[j].samples,0,\n            sizeof(server.inst_metric[j].samples));\n    }\n    server.stat_net_input_bytes = 0;\n    server.stat_net_output_bytes = 0;\n    server.stat_unexpected_error_replies = 0;\n    server.aof_delayed_fsync = 0;\n}\n\n/* Make the thread killable at any time, so that kill threads functions\n * can work reliably (default cancelability type is PTHREAD_CANCEL_DEFERRED).\n * Needed for pthread_cancel used by the fast memory test used by the crash report. */\nvoid makeThreadKillable(void) {\n    pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);\n    pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);\n}\n\nvoid initServer(void) {\n    int j;\n\n    signal(SIGHUP, SIG_IGN);\n    signal(SIGPIPE, SIG_IGN);\n    setupSignalHandlers();\n    makeThreadKillable();\n\n    if (server.syslog_enabled) {\n        openlog(server.syslog_ident, LOG_PID | LOG_NDELAY | LOG_NOWAIT,\n            server.syslog_facility);\n    }\n\n    /* Initialization after setting defaults from the config system. */\n    server.aof_state = server.aof_enabled ? AOF_ON : AOF_OFF;\n    server.hz = server.config_hz;\n    server.pid = getpid();\n    server.in_fork_child = CHILD_TYPE_NONE;\n    server.main_thread_id = pthread_self();\n    server.current_client = NULL;\n    server.fixed_time_expire = 0;\n    server.clients = listCreate();\n    server.clients_index = raxNew();\n    server.clients_to_close = listCreate();\n    server.slaves = listCreate();\n    server.monitors = listCreate();\n    server.clients_pending_write = listCreate();\n    server.clients_pending_read = listCreate();\n    server.clients_timeout_table = raxNew();\n    server.slaveseldb = -1; /* Force to emit the first SELECT command. */\n    server.unblocked_clients = listCreate();\n    server.ready_keys = listCreate();\n    server.clients_waiting_acks = listCreate();\n    server.get_ack_from_slaves = 0;\n    server.clients_paused = 0;\n    server.events_processed_while_blocked = 0;\n    server.system_memory_size = zmalloc_get_memory_size();\n\n    if ((server.tls_port || server.tls_replication || server.tls_cluster)\n                && tlsConfigure(&server.tls_ctx_config) == C_ERR) {\n        serverLog(LL_WARNING, \"Failed to configure TLS. Check logs for more info.\");\n        exit(1);\n    }\n\n    createSharedObjects();\n    adjustOpenFilesLimit();\n    server.el = aeCreateEventLoop(server.maxclients+CONFIG_FDSET_INCR);\n    if (server.el == NULL) {\n        serverLog(LL_WARNING,\n            \"Failed creating the event loop. Error message: '%s'\",\n            strerror(errno));\n        exit(1);\n    }\n    server.db = zmalloc(sizeof(redisDb)*server.dbnum);\n\n    /* Open the TCP listening socket for the user commands. */\n    if (server.port != 0 &&\n        listenToPort(server.port,server.ipfd,&server.ipfd_count) == C_ERR)\n        exit(1);\n    if (server.tls_port != 0 &&\n        listenToPort(server.tls_port,server.tlsfd,&server.tlsfd_count) == C_ERR)\n        exit(1);\n\n    /* Open the listening Unix domain socket. */\n    if (server.unixsocket != NULL) {\n        unlink(server.unixsocket); /* don't care if this fails */\n        server.sofd = anetUnixServer(server.neterr,server.unixsocket,\n            server.unixsocketperm, server.tcp_backlog);\n        if (server.sofd == ANET_ERR) {\n            serverLog(LL_WARNING, \"Opening Unix socket: %s\", server.neterr);\n            exit(1);\n        }\n        anetNonBlock(NULL,server.sofd);\n    }\n\n    /* Abort if there are no listening sockets at all. */\n    if (server.ipfd_count == 0 && server.tlsfd_count == 0 && server.sofd < 0) {\n        serverLog(LL_WARNING, \"Configured to not listen anywhere, exiting.\");\n        exit(1);\n    }\n\n    /* Create the Redis databases, and initialize other internal state. */\n    for (j = 0; j < server.dbnum; j++) {\n        server.db[j].dict = dictCreate(&dbDictType,NULL);\n        server.db[j].expires = dictCreate(&keyptrDictType,NULL);\n        server.db[j].expires_cursor = 0;\n        server.db[j].blocking_keys = dictCreate(&keylistDictType,NULL);\n        server.db[j].ready_keys = dictCreate(&objectKeyPointerValueDictType,NULL);\n        server.db[j].watched_keys = dictCreate(&keylistDictType,NULL);\n        server.db[j].id = j;\n        server.db[j].avg_ttl = 0;\n        server.db[j].defrag_later = listCreate();\n        listSetFreeMethod(server.db[j].defrag_later,(void (*)(void*))sdsfree);\n    }\n    evictionPoolAlloc(); /* Initialize the LRU keys pool. */\n    server.pubsub_channels = dictCreate(&keylistDictType,NULL);\n    server.pubsub_patterns = listCreate();\n    server.pubsub_patterns_dict = dictCreate(&keylistDictType,NULL);\n    listSetFreeMethod(server.pubsub_patterns,freePubsubPattern);\n    listSetMatchMethod(server.pubsub_patterns,listMatchPubsubPattern);\n    server.cronloops = 0;\n    server.rdb_child_pid = -1;\n    server.aof_child_pid = -1;\n    server.module_child_pid = -1;\n    server.rdb_child_type = RDB_CHILD_TYPE_NONE;\n    server.rdb_pipe_conns = NULL;\n    server.rdb_pipe_numconns = 0;\n    server.rdb_pipe_numconns_writing = 0;\n    server.rdb_pipe_buff = NULL;\n    server.rdb_pipe_bufflen = 0;\n    server.rdb_bgsave_scheduled = 0;\n    server.child_info_pipe[0] = -1;\n    server.child_info_pipe[1] = -1;\n    server.child_info_data.magic = 0;\n    aofRewriteBufferReset();\n    server.aof_buf = sdsempty();\n    server.lastsave = time(NULL); /* At startup we consider the DB saved. */\n    server.lastbgsave_try = 0;    /* At startup we never tried to BGSAVE. */\n    server.rdb_save_time_last = -1;\n    server.rdb_save_time_start = -1;\n    server.dirty = 0;\n    resetServerStats();\n    /* A few stats we don't want to reset: server startup time, and peak mem. */\n    server.stat_starttime = time(NULL);\n    server.stat_peak_memory = 0;\n    server.stat_rdb_cow_bytes = 0;\n    server.stat_aof_cow_bytes = 0;\n    server.stat_module_cow_bytes = 0;\n    for (int j = 0; j < CLIENT_TYPE_COUNT; j++)\n        server.stat_clients_type_memory[j] = 0;\n    server.cron_malloc_stats.zmalloc_used = 0;\n    server.cron_malloc_stats.process_rss = 0;\n    server.cron_malloc_stats.allocator_allocated = 0;\n    server.cron_malloc_stats.allocator_active = 0;\n    server.cron_malloc_stats.allocator_resident = 0;\n    server.lastbgsave_status = C_OK;\n    server.aof_last_write_status = C_OK;\n    server.aof_last_write_errno = 0;\n    server.repl_good_slaves_count = 0;\n\n    /* Create the timer callback, this is our way to process many background\n     * operations incrementally, like clients timeout, eviction of unaccessed\n     * expired keys and so forth. */\n    if (aeCreateTimeEvent(server.el, 1, serverCron, NULL, NULL) == AE_ERR) {\n        serverPanic(\"Can't create event loop timers.\");\n        exit(1);\n    }\n\n    /* Create an event handler for accepting new connections in TCP and Unix\n     * domain sockets. */\n    for (j = 0; j < server.ipfd_count; j++) {\n        if (aeCreateFileEvent(server.el, server.ipfd[j], AE_READABLE,\n            acceptTcpHandler,NULL) == AE_ERR)\n            {\n                serverPanic(\n                    \"Unrecoverable error creating server.ipfd file event.\");\n            }\n    }\n    for (j = 0; j < server.tlsfd_count; j++) {\n        if (aeCreateFileEvent(server.el, server.tlsfd[j], AE_READABLE,\n            acceptTLSHandler,NULL) == AE_ERR)\n            {\n                serverPanic(\n                    \"Unrecoverable error creating server.tlsfd file event.\");\n            }\n    }\n    if (server.sofd > 0 && aeCreateFileEvent(server.el,server.sofd,AE_READABLE,\n        acceptUnixHandler,NULL) == AE_ERR) serverPanic(\"Unrecoverable error creating server.sofd file event.\");\n\n\n    /* Register a readable event for the pipe used to awake the event loop\n     * when a blocked client in a module needs attention. */\n    if (aeCreateFileEvent(server.el, server.module_blocked_pipe[0], AE_READABLE,\n        moduleBlockedClientPipeReadable,NULL) == AE_ERR) {\n            serverPanic(\n                \"Error registering the readable event for the module \"\n                \"blocked clients subsystem.\");\n    }\n\n    /* Register before and after sleep handlers (note this needs to be done\n     * before loading persistence since it is used by processEventsWhileBlocked. */\n    aeSetBeforeSleepProc(server.el,beforeSleep);\n    aeSetAfterSleepProc(server.el,afterSleep);\n\n    /* Open the AOF file if needed. */\n    if (server.aof_state == AOF_ON) {\n        server.aof_fd = open(server.aof_filename,\n                               O_WRONLY|O_APPEND|O_CREAT,0644);\n        if (server.aof_fd == -1) {\n            serverLog(LL_WARNING, \"Can't open the append-only file: %s\",\n                strerror(errno));\n            exit(1);\n        }\n    }\n\n    /* 32 bit instances are limited to 4GB of address space, so if there is\n     * no explicit limit in the user provided configuration we set a limit\n     * at 3 GB using maxmemory with 'noeviction' policy'. This avoids\n     * useless crashes of the Redis instance for out of memory. */\n    if (server.arch_bits == 32 && server.maxmemory == 0) {\n        serverLog(LL_WARNING,\"Warning: 32 bit instance detected but no memory limit set. Setting 3 GB maxmemory limit with 'noeviction' policy now.\");\n        server.maxmemory = 3072LL*(1024*1024); /* 3 GB */\n        server.maxmemory_policy = MAXMEMORY_NO_EVICTION;\n    }\n\n    if (server.cluster_enabled) clusterInit();\n    replicationScriptCacheInit();\n    scriptingInit(1);\n    slowlogInit();\n    latencyMonitorInit();\n}\n\n/* Some steps in server initialization need to be done last (after modules\n * are loaded).\n * Specifically, creation of threads due to a race bug in ld.so, in which\n * Thread Local Storage initialization collides with dlopen call.\n * see: https://sourceware.org/bugzilla/show_bug.cgi?id=19329 */\nvoid InitServerLast() {\n    bioInit();\n    initThreadedIO();\n    set_jemalloc_bg_thread(server.jemalloc_bg_thread);\n    server.initial_memory_usage = zmalloc_used_memory();\n}\n\n/* Parse the flags string description 'strflags' and set them to the\n * command 'c'. If the flags are all valid C_OK is returned, otherwise\n * C_ERR is returned (yet the recognized flags are set in the command). */\nint populateCommandTableParseFlags(struct redisCommand *c, char *strflags) {\n    int argc;\n    sds *argv;\n\n    /* Split the line into arguments for processing. */\n    argv = sdssplitargs(strflags,&argc);\n    if (argv == NULL) return C_ERR;\n\n    for (int j = 0; j < argc; j++) {\n        char *flag = argv[j];\n        if (!strcasecmp(flag,\"write\")) {\n            c->flags |= CMD_WRITE|CMD_CATEGORY_WRITE;\n        } else if (!strcasecmp(flag,\"read-only\")) {\n            c->flags |= CMD_READONLY|CMD_CATEGORY_READ;\n        } else if (!strcasecmp(flag,\"use-memory\")) {\n            c->flags |= CMD_DENYOOM;\n        } else if (!strcasecmp(flag,\"admin\")) {\n            c->flags |= CMD_ADMIN|CMD_CATEGORY_ADMIN|CMD_CATEGORY_DANGEROUS;\n        } else if (!strcasecmp(flag,\"pub-sub\")) {\n            c->flags |= CMD_PUBSUB|CMD_CATEGORY_PUBSUB;\n        } else if (!strcasecmp(flag,\"no-script\")) {\n            c->flags |= CMD_NOSCRIPT;\n        } else if (!strcasecmp(flag,\"random\")) {\n            c->flags |= CMD_RANDOM;\n        } else if (!strcasecmp(flag,\"to-sort\")) {\n            c->flags |= CMD_SORT_FOR_SCRIPT;\n        } else if (!strcasecmp(flag,\"ok-loading\")) {\n            c->flags |= CMD_LOADING;\n        } else if (!strcasecmp(flag,\"ok-stale\")) {\n            c->flags |= CMD_STALE;\n        } else if (!strcasecmp(flag,\"no-monitor\")) {\n            c->flags |= CMD_SKIP_MONITOR;\n        } else if (!strcasecmp(flag,\"no-slowlog\")) {\n            c->flags |= CMD_SKIP_SLOWLOG;\n        } else if (!strcasecmp(flag,\"cluster-asking\")) {\n            c->flags |= CMD_ASKING;\n        } else if (!strcasecmp(flag,\"fast\")) {\n            c->flags |= CMD_FAST | CMD_CATEGORY_FAST;\n        } else if (!strcasecmp(flag,\"no-auth\")) {\n            c->flags |= CMD_NO_AUTH;\n        } else {\n            /* Parse ACL categories here if the flag name starts with @. */\n            uint64_t catflag;\n            if (flag[0] == '@' &&\n                (catflag = ACLGetCommandCategoryFlagByName(flag+1)) != 0)\n            {\n                c->flags |= catflag;\n            } else {\n                sdsfreesplitres(argv,argc);\n                return C_ERR;\n            }\n        }\n    }\n    /* If it's not @fast is @slow in this binary world. */\n    if (!(c->flags & CMD_CATEGORY_FAST)) c->flags |= CMD_CATEGORY_SLOW;\n\n    sdsfreesplitres(argv,argc);\n    return C_OK;\n}\n\n/* Populates the Redis Command Table starting from the hard coded list\n * we have on top of server.c file. */\nvoid populateCommandTable(void) {\n    int j;\n    int numcommands = sizeof(redisCommandTable)/sizeof(struct redisCommand);\n\n    for (j = 0; j < numcommands; j++) {\n        struct redisCommand *c = redisCommandTable+j;\n        int retval1, retval2;\n\n        /* Translate the command string flags description into an actual\n         * set of flags. */\n        if (populateCommandTableParseFlags(c,c->sflags) == C_ERR)\n            serverPanic(\"Unsupported command flag\");\n\n        c->id = ACLGetCommandID(c->name); /* Assign the ID used for ACL. */\n        retval1 = dictAdd(server.commands, sdsnew(c->name), c);\n        /* Populate an additional dictionary that will be unaffected\n         * by rename-command statements in redis.conf. */\n        retval2 = dictAdd(server.orig_commands, sdsnew(c->name), c);\n        serverAssert(retval1 == DICT_OK && retval2 == DICT_OK);\n    }\n}\n\nvoid resetCommandTableStats(void) {\n    struct redisCommand *c;\n    dictEntry *de;\n    dictIterator *di;\n\n    di = dictGetSafeIterator(server.commands);\n    while((de = dictNext(di)) != NULL) {\n        c = (struct redisCommand *) dictGetVal(de);\n        c->microseconds = 0;\n        c->calls = 0;\n    }\n    dictReleaseIterator(di);\n\n}\n\n/* ========================== Redis OP Array API ============================ */\n\nvoid redisOpArrayInit(redisOpArray *oa) {\n    oa->ops = NULL;\n    oa->numops = 0;\n}\n\nint redisOpArrayAppend(redisOpArray *oa, struct redisCommand *cmd, int dbid,\n                       robj **argv, int argc, int target)\n{\n    redisOp *op;\n\n    oa->ops = zrealloc(oa->ops,sizeof(redisOp)*(oa->numops+1));\n    op = oa->ops+oa->numops;\n    op->cmd = cmd;\n    op->dbid = dbid;\n    op->argv = argv;\n    op->argc = argc;\n    op->target = target;\n    oa->numops++;\n    return oa->numops;\n}\n\nvoid redisOpArrayFree(redisOpArray *oa) {\n    while(oa->numops) {\n        int j;\n        redisOp *op;\n\n        oa->numops--;\n        op = oa->ops+oa->numops;\n        for (j = 0; j < op->argc; j++)\n            decrRefCount(op->argv[j]);\n        zfree(op->argv);\n    }\n    zfree(oa->ops);\n}\n\n/* ====================== Commands lookup and execution ===================== */\n\nstruct redisCommand *lookupCommand(sds name) {\n    return dictFetchValue(server.commands, name);\n}\n\nstruct redisCommand *lookupCommandByCString(const char *s) {\n    struct redisCommand *cmd;\n    sds name = sdsnew(s);\n\n    cmd = dictFetchValue(server.commands, name);\n    sdsfree(name);\n    return cmd;\n}\n\n/* Lookup the command in the current table, if not found also check in\n * the original table containing the original command names unaffected by\n * redis.conf rename-command statement.\n *\n * This is used by functions rewriting the argument vector such as\n * rewriteClientCommandVector() in order to set client->cmd pointer\n * correctly even if the command was renamed. */\nstruct redisCommand *lookupCommandOrOriginal(sds name) {\n    struct redisCommand *cmd = dictFetchValue(server.commands, name);\n\n    if (!cmd) cmd = dictFetchValue(server.orig_commands,name);\n    return cmd;\n}\n\n/* Propagate the specified command (in the context of the specified database id)\n * to AOF and Slaves.\n *\n * flags are an xor between:\n * + PROPAGATE_NONE (no propagation of command at all)\n * + PROPAGATE_AOF (propagate into the AOF file if is enabled)\n * + PROPAGATE_REPL (propagate into the replication link)\n *\n * This should not be used inside commands implementation since it will not\n * wrap the resulting commands in MULTI/EXEC. Use instead alsoPropagate(),\n * preventCommandPropagation(), forceCommandPropagation().\n *\n * However for functions that need to (also) propagate out of the context of a\n * command execution, for example when serving a blocked client, you\n * want to use propagate().\n */\nvoid propagate(struct redisCommand *cmd, int dbid, robj **argv, int argc,\n               int flags)\n{\n    if (server.aof_state != AOF_OFF && flags & PROPAGATE_AOF)\n        feedAppendOnlyFile(cmd,dbid,argv,argc);\n    if (flags & PROPAGATE_REPL)\n        replicationFeedSlaves(server.slaves,dbid,argv,argc);\n}\n\n/* Used inside commands to schedule the propagation of additional commands\n * after the current command is propagated to AOF / Replication.\n *\n * 'cmd' must be a pointer to the Redis command to replicate, dbid is the\n * database ID the command should be propagated into.\n * Arguments of the command to propagate are passed as an array of redis\n * objects pointers of len 'argc', using the 'argv' vector.\n *\n * The function does not take a reference to the passed 'argv' vector,\n * so it is up to the caller to release the passed argv (but it is usually\n * stack allocated).  The function automatically increments ref count of\n * passed objects, so the caller does not need to. */\nvoid alsoPropagate(struct redisCommand *cmd, int dbid, robj **argv, int argc,\n                   int target)\n{\n    robj **argvcopy;\n    int j;\n\n    if (server.loading) return; /* No propagation during loading. */\n\n    argvcopy = zmalloc(sizeof(robj*)*argc);\n    for (j = 0; j < argc; j++) {\n        argvcopy[j] = argv[j];\n        incrRefCount(argv[j]);\n    }\n    redisOpArrayAppend(&server.also_propagate,cmd,dbid,argvcopy,argc,target);\n}\n\n/* It is possible to call the function forceCommandPropagation() inside a\n * Redis command implementation in order to to force the propagation of a\n * specific command execution into AOF / Replication. */\nvoid forceCommandPropagation(client *c, int flags) {\n    if (flags & PROPAGATE_REPL) c->flags |= CLIENT_FORCE_REPL;\n    if (flags & PROPAGATE_AOF) c->flags |= CLIENT_FORCE_AOF;\n}\n\n/* Avoid that the executed command is propagated at all. This way we\n * are free to just propagate what we want using the alsoPropagate()\n * API. */\nvoid preventCommandPropagation(client *c) {\n    c->flags |= CLIENT_PREVENT_PROP;\n}\n\n/* AOF specific version of preventCommandPropagation(). */\nvoid preventCommandAOF(client *c) {\n    c->flags |= CLIENT_PREVENT_AOF_PROP;\n}\n\n/* Replication specific version of preventCommandPropagation(). */\nvoid preventCommandReplication(client *c) {\n    c->flags |= CLIENT_PREVENT_REPL_PROP;\n}\n\n/* Call() is the core of Redis execution of a command.\n *\n * The following flags can be passed:\n * CMD_CALL_NONE        No flags.\n * CMD_CALL_SLOWLOG     Check command speed and log in the slow log if needed.\n * CMD_CALL_STATS       Populate command stats.\n * CMD_CALL_PROPAGATE_AOF   Append command to AOF if it modified the dataset\n *                          or if the client flags are forcing propagation.\n * CMD_CALL_PROPAGATE_REPL  Send command to slaves if it modified the dataset\n *                          or if the client flags are forcing propagation.\n * CMD_CALL_PROPAGATE   Alias for PROPAGATE_AOF|PROPAGATE_REPL.\n * CMD_CALL_FULL        Alias for SLOWLOG|STATS|PROPAGATE.\n *\n * The exact propagation behavior depends on the client flags.\n * Specifically:\n *\n * 1. If the client flags CLIENT_FORCE_AOF or CLIENT_FORCE_REPL are set\n *    and assuming the corresponding CMD_CALL_PROPAGATE_AOF/REPL is set\n *    in the call flags, then the command is propagated even if the\n *    dataset was not affected by the command.\n * 2. If the client flags CLIENT_PREVENT_REPL_PROP or CLIENT_PREVENT_AOF_PROP\n *    are set, the propagation into AOF or to slaves is not performed even\n *    if the command modified the dataset.\n *\n * Note that regardless of the client flags, if CMD_CALL_PROPAGATE_AOF\n * or CMD_CALL_PROPAGATE_REPL are not set, then respectively AOF or\n * slaves propagation will never occur.\n *\n * Client flags are modified by the implementation of a given command\n * using the following API:\n *\n * forceCommandPropagation(client *c, int flags);\n * preventCommandPropagation(client *c);\n * preventCommandAOF(client *c);\n * preventCommandReplication(client *c);\n *\n */\nvoid call(client *c, int flags) {\n    long long dirty;\n    ustime_t start, duration;\n    int client_old_flags = c->flags;\n    struct redisCommand *real_cmd = c->cmd;\n\n    /* Send the command to clients in MONITOR mode if applicable.\n     * Administrative commands are considered too dangerous to be shown. */\n    if (listLength(server.monitors) &&\n        !server.loading &&\n        !(c->cmd->flags & (CMD_SKIP_MONITOR|CMD_ADMIN)))\n    {\n        replicationFeedMonitors(c,server.monitors,c->db->id,c->argv,c->argc);\n    }\n\n    /* Initialization: clear the flags that must be set by the command on\n     * demand, and initialize the array for additional commands propagation. */\n    c->flags &= ~(CLIENT_FORCE_AOF|CLIENT_FORCE_REPL|CLIENT_PREVENT_PROP);\n    redisOpArray prev_also_propagate = server.also_propagate;\n    redisOpArrayInit(&server.also_propagate);\n\n    /* Call the command. */\n    dirty = server.dirty;\n\n    /* Update cache time, in case we have nested calls we want to\n     * update only on the first call*/\n    if (server.fixed_time_expire++ == 0) {\n        updateCachedTime(0);\n    }\n\n    start = server.ustime;\n    c->cmd->proc(c);\n    duration = ustime()-start;\n    dirty = server.dirty-dirty;\n    if (dirty < 0) dirty = 0;\n\n    /* After executing command, we will close the client after writing entire\n     * reply if it is set 'CLIENT_CLOSE_AFTER_COMMAND' flag. */\n    if (c->flags & CLIENT_CLOSE_AFTER_COMMAND) {\n        c->flags &= ~CLIENT_CLOSE_AFTER_COMMAND;\n        c->flags |= CLIENT_CLOSE_AFTER_REPLY;\n    }\n\n    /* When EVAL is called loading the AOF we don't want commands called\n     * from Lua to go into the slowlog or to populate statistics. */\n    if (server.loading && c->flags & CLIENT_LUA)\n        flags &= ~(CMD_CALL_SLOWLOG | CMD_CALL_STATS);\n\n    /* If the caller is Lua, we want to force the EVAL caller to propagate\n     * the script if the command flag or client flag are forcing the\n     * propagation. */\n    if (c->flags & CLIENT_LUA && server.lua_caller) {\n        if (c->flags & CLIENT_FORCE_REPL)\n            server.lua_caller->flags |= CLIENT_FORCE_REPL;\n        if (c->flags & CLIENT_FORCE_AOF)\n            server.lua_caller->flags |= CLIENT_FORCE_AOF;\n    }\n\n    /* Log the command into the Slow log if needed, and populate the\n     * per-command statistics that we show in INFO commandstats. */\n    if (flags & CMD_CALL_SLOWLOG && !(c->cmd->flags & CMD_SKIP_SLOWLOG)) {\n        char *latency_event = (c->cmd->flags & CMD_FAST) ?\n                              \"fast-command\" : \"command\";\n        latencyAddSampleIfNeeded(latency_event,duration/1000);\n        slowlogPushEntryIfNeeded(c,c->argv,c->argc,duration);\n    }\n\n    if (flags & CMD_CALL_STATS) {\n        /* use the real command that was executed (cmd and lastamc) may be\n         * different, in case of MULTI-EXEC or re-written commands such as\n         * EXPIRE, GEOADD, etc. */\n        real_cmd->microseconds += duration;\n        real_cmd->calls++;\n    }\n\n    /* Propagate the command into the AOF and replication link */\n    if (flags & CMD_CALL_PROPAGATE &&\n        (c->flags & CLIENT_PREVENT_PROP) != CLIENT_PREVENT_PROP)\n    {\n        int propagate_flags = PROPAGATE_NONE;\n\n        /* Check if the command operated changes in the data set. If so\n         * set for replication / AOF propagation. */\n        if (dirty) propagate_flags |= (PROPAGATE_AOF|PROPAGATE_REPL);\n\n        /* If the client forced AOF / replication of the command, set\n         * the flags regardless of the command effects on the data set. */\n        if (c->flags & CLIENT_FORCE_REPL) propagate_flags |= PROPAGATE_REPL;\n        if (c->flags & CLIENT_FORCE_AOF) propagate_flags |= PROPAGATE_AOF;\n\n        /* However prevent AOF / replication propagation if the command\n         * implementation called preventCommandPropagation() or similar,\n         * or if we don't have the call() flags to do so. */\n        if (c->flags & CLIENT_PREVENT_REPL_PROP ||\n            !(flags & CMD_CALL_PROPAGATE_REPL))\n                propagate_flags &= ~PROPAGATE_REPL;\n        if (c->flags & CLIENT_PREVENT_AOF_PROP ||\n            !(flags & CMD_CALL_PROPAGATE_AOF))\n                propagate_flags &= ~PROPAGATE_AOF;\n\n        /* Call propagate() only if at least one of AOF / replication\n         * propagation is needed. Note that modules commands handle replication\n         * in an explicit way, so we never replicate them automatically. */\n        if (propagate_flags != PROPAGATE_NONE && !(c->cmd->flags & CMD_MODULE))\n            propagate(c->cmd,c->db->id,c->argv,c->argc,propagate_flags);\n    }\n\n    /* Restore the old replication flags, since call() can be executed\n     * recursively. */\n    c->flags &= ~(CLIENT_FORCE_AOF|CLIENT_FORCE_REPL|CLIENT_PREVENT_PROP);\n    c->flags |= client_old_flags &\n        (CLIENT_FORCE_AOF|CLIENT_FORCE_REPL|CLIENT_PREVENT_PROP);\n\n    /* Handle the alsoPropagate() API to handle commands that want to propagate\n     * multiple separated commands. Note that alsoPropagate() is not affected\n     * by CLIENT_PREVENT_PROP flag. */\n    if (server.also_propagate.numops) {\n        int j;\n        redisOp *rop;\n\n        if (flags & CMD_CALL_PROPAGATE) {\n            int multi_emitted = 0;\n            /* Wrap the commands in server.also_propagate array,\n             * but don't wrap it if we are already in MULTI context,\n             * in case the nested MULTI/EXEC.\n             *\n             * And if the array contains only one command, no need to\n             * wrap it, since the single command is atomic. */\n            if (server.also_propagate.numops > 1 &&\n                !(c->cmd->flags & CMD_MODULE) &&\n                !(c->flags & CLIENT_MULTI) &&\n                !(flags & CMD_CALL_NOWRAP))\n            {\n                execCommandPropagateMulti(c);\n                multi_emitted = 1;\n            }\n\n            for (j = 0; j < server.also_propagate.numops; j++) {\n                rop = &server.also_propagate.ops[j];\n                int target = rop->target;\n                /* Whatever the command wish is, we honor the call() flags. */\n                if (!(flags&CMD_CALL_PROPAGATE_AOF)) target &= ~PROPAGATE_AOF;\n                if (!(flags&CMD_CALL_PROPAGATE_REPL)) target &= ~PROPAGATE_REPL;\n                if (target)\n                    propagate(rop->cmd,rop->dbid,rop->argv,rop->argc,target);\n            }\n\n            if (multi_emitted) {\n                execCommandPropagateExec(c);\n            }\n        }\n        redisOpArrayFree(&server.also_propagate);\n    }\n    server.also_propagate = prev_also_propagate;\n\n    /* If the client has keys tracking enabled for client side caching,\n     * make sure to remember the keys it fetched via this command. */\n    if (c->cmd->flags & CMD_READONLY) {\n        client *caller = (c->flags & CLIENT_LUA && server.lua_caller) ?\n                            server.lua_caller : c;\n        if (caller->flags & CLIENT_TRACKING &&\n            !(caller->flags & CLIENT_TRACKING_BCAST))\n        {\n            trackingRememberKeys(caller);\n        }\n    }\n\n    server.fixed_time_expire--;\n    server.stat_numcommands++;\n\n    /* Record peak memory after each command and before the eviction that runs\n     * before the next command. */\n    size_t zmalloc_used = zmalloc_used_memory();\n    if (zmalloc_used > server.stat_peak_memory)\n        server.stat_peak_memory = zmalloc_used;\n}\n\n/* Used when a command that is ready for execution needs to be rejected, due to\n * varios pre-execution checks. it returns the appropriate error to the client.\n * If there's a transaction is flags it as dirty, and if the command is EXEC,\n * it aborts the transaction.\n * Note: 'reply' is expected to end with \\r\\n */\nvoid rejectCommand(client *c, robj *reply) {\n    flagTransaction(c);\n    if (c->cmd && c->cmd->proc == execCommand) {\n        execCommandAbort(c, reply->ptr);\n    } else {\n        /* using addReplyError* rather than addReply so that the error can be logged. */\n        addReplyErrorObject(c, reply);\n    }\n}\n\nvoid rejectCommandFormat(client *c, const char *fmt, ...) {\n    flagTransaction(c);\n    va_list ap;\n    va_start(ap,fmt);\n    sds s = sdscatvprintf(sdsempty(),fmt,ap);\n    va_end(ap);\n    /* Make sure there are no newlines in the string, otherwise invalid protocol\n     * is emitted (The args come from the user, they may contain any character). */\n    sdsmapchars(s, \"\\r\\n\", \"  \",  2);\n    if (c->cmd && c->cmd->proc == execCommand) {\n        execCommandAbort(c, s);\n    } else {\n        addReplyErrorSds(c, s);\n    }\n    sdsfree(s);\n}\n\n/* If this function gets called we already read a whole\n * command, arguments are in the client argv/argc fields.\n * processCommand() execute the command or prepare the\n * server for a bulk read from the client.\n *\n * If C_OK is returned the client is still alive and valid and\n * other operations can be performed by the caller. Otherwise\n * if C_ERR is returned the client was destroyed (i.e. after QUIT). */\nint processCommand(client *c) {\n    moduleCallCommandFilters(c);\n\n    /* The QUIT command is handled separately. Normal command procs will\n     * go through checking for replication and QUIT will cause trouble\n     * when FORCE_REPLICATION is enabled and would be implemented in\n     * a regular command proc. */\n    if (!strcasecmp(c->argv[0]->ptr,\"quit\")) {\n        addReply(c,shared.ok);\n        c->flags |= CLIENT_CLOSE_AFTER_REPLY;\n        return C_ERR;\n    }\n\n    /* Now lookup the command and check ASAP about trivial error conditions\n     * such as wrong arity, bad command name and so forth. */\n    c->cmd = c->lastcmd = lookupCommand(c->argv[0]->ptr);\n    if (!c->cmd) {\n        sds args = sdsempty();\n        int i;\n        for (i=1; i < c->argc && sdslen(args) < 128; i++)\n            args = sdscatprintf(args, \"`%.*s`, \", 128-(int)sdslen(args), (char*)c->argv[i]->ptr);\n        rejectCommandFormat(c,\"unknown command `%s`, with args beginning with: %s\",\n            (char*)c->argv[0]->ptr, args);\n        sdsfree(args);\n        return C_OK;\n    } else if ((c->cmd->arity > 0 && c->cmd->arity != c->argc) ||\n               (c->argc < -c->cmd->arity)) {\n        rejectCommandFormat(c,\"wrong number of arguments for '%s' command\",\n            c->cmd->name);\n        return C_OK;\n    }\n\n    int is_write_command = (c->cmd->flags & CMD_WRITE) ||\n                           (c->cmd->proc == execCommand && (c->mstate.cmd_flags & CMD_WRITE));\n    int is_denyoom_command = (c->cmd->flags & CMD_DENYOOM) ||\n                             (c->cmd->proc == execCommand && (c->mstate.cmd_flags & CMD_DENYOOM));\n    int is_denystale_command = !(c->cmd->flags & CMD_STALE) ||\n                               (c->cmd->proc == execCommand && (c->mstate.cmd_inv_flags & CMD_STALE));\n    int is_denyloading_command = !(c->cmd->flags & CMD_LOADING) ||\n                                 (c->cmd->proc == execCommand && (c->mstate.cmd_inv_flags & CMD_LOADING));\n\n    /* Check if the user is authenticated. This check is skipped in case\n     * the default user is flagged as \"nopass\" and is active. */\n    int auth_required = (!(DefaultUser->flags & USER_FLAG_NOPASS) ||\n                          (DefaultUser->flags & USER_FLAG_DISABLED)) &&\n                        !c->authenticated;\n    if (auth_required) {\n        /* AUTH and HELLO and no auth modules are valid even in\n         * non-authenticated state. */\n        if (!(c->cmd->flags & CMD_NO_AUTH)) {\n            rejectCommand(c,shared.noautherr);\n            return C_OK;\n        }\n    }\n\n    /* Check if the user can run this command according to the current\n     * ACLs. */\n    int acl_keypos;\n    int acl_retval = ACLCheckCommandPerm(c,&acl_keypos);\n    if (acl_retval != ACL_OK) {\n        addACLLogEntry(c,acl_retval,acl_keypos,NULL);\n        if (acl_retval == ACL_DENIED_CMD)\n            rejectCommandFormat(c,\n                \"-NOPERM this user has no permissions to run \"\n                \"the '%s' command or its subcommand\", c->cmd->name);\n        else\n            rejectCommandFormat(c,\n                \"-NOPERM this user has no permissions to access \"\n                \"one of the keys used as arguments\");\n        return C_OK;\n    }\n\n    /* If cluster is enabled perform the cluster redirection here.\n     * However we don't perform the redirection if:\n     * 1) The sender of this command is our master.\n     * 2) The command has no key arguments. */\n    if (server.cluster_enabled &&\n        !(c->flags & CLIENT_MASTER) &&\n        !(c->flags & CLIENT_LUA &&\n          server.lua_caller->flags & CLIENT_MASTER) &&\n        !(c->cmd->getkeys_proc == NULL && c->cmd->firstkey == 0 &&\n          c->cmd->proc != execCommand))\n    {\n        int hashslot;\n        int error_code;\n        clusterNode *n = getNodeByQuery(c,c->cmd,c->argv,c->argc,\n                                        &hashslot,&error_code);\n        if (n == NULL || n != server.cluster->myself) {\n            if (c->cmd->proc == execCommand) {\n                discardTransaction(c);\n            } else {\n                flagTransaction(c);\n            }\n            clusterRedirectClient(c,n,hashslot,error_code);\n            return C_OK;\n        }\n    }\n\n    /* Handle the maxmemory directive.\n     *\n     * Note that we do not want to reclaim memory if we are here re-entering\n     * the event loop since there is a busy Lua script running in timeout\n     * condition, to avoid mixing the propagation of scripts with the\n     * propagation of DELs due to eviction. */\n    if (server.maxmemory && !server.lua_timedout) {\n        int out_of_memory = freeMemoryIfNeededAndSafe() == C_ERR;\n        /* freeMemoryIfNeeded may flush slave output buffers. This may result\n         * into a slave, that may be the active client, to be freed. */\n        if (server.current_client == NULL) return C_ERR;\n\n        int reject_cmd_on_oom = is_denyoom_command;\n        /* If client is in MULTI/EXEC context, queuing may consume an unlimited\n         * amount of memory, so we want to stop that.\n         * However, we never want to reject DISCARD, or even EXEC (unless it\n         * contains denied commands, in which case is_denyoom_command is already\n         * set. */\n        if (c->flags & CLIENT_MULTI &&\n            c->cmd->proc != execCommand &&\n            c->cmd->proc != discardCommand) {\n            reject_cmd_on_oom = 1;\n        }\n\n        if (out_of_memory && reject_cmd_on_oom) {\n            rejectCommand(c, shared.oomerr);\n            return C_OK;\n        }\n\n        /* Save out_of_memory result at script start, otherwise if we check OOM\n         * until first write within script, memory used by lua stack and\n         * arguments might interfere. */\n        if (c->cmd->proc == evalCommand || c->cmd->proc == evalShaCommand) {\n            server.lua_oom = out_of_memory;\n        }\n    }\n\n    /* Make sure to use a reasonable amount of memory for client side\n     * caching metadata. */\n    if (server.tracking_clients) trackingLimitUsedSlots();\n\n    /* Don't accept write commands if there are problems persisting on disk\n     * and if this is a master instance. */\n    int deny_write_type = writeCommandsDeniedByDiskError();\n    if (deny_write_type != DISK_ERROR_TYPE_NONE &&\n        server.masterhost == NULL &&\n        (is_write_command ||c->cmd->proc == pingCommand))\n    {\n        if (deny_write_type == DISK_ERROR_TYPE_RDB)\n            rejectCommand(c, shared.bgsaveerr);\n        else\n            rejectCommandFormat(c,\n                \"-MISCONF Errors writing to the AOF file: %s\",\n                strerror(server.aof_last_write_errno));\n        return C_OK;\n    }\n\n    /* Don't accept write commands if there are not enough good slaves and\n     * user configured the min-slaves-to-write option. */\n    if (server.masterhost == NULL &&\n        server.repl_min_slaves_to_write &&\n        server.repl_min_slaves_max_lag &&\n        is_write_command &&\n        server.repl_good_slaves_count < server.repl_min_slaves_to_write)\n    {\n        rejectCommand(c, shared.noreplicaserr);\n        return C_OK;\n    }\n\n    /* Don't accept write commands if this is a read only slave. But\n     * accept write commands if this is our master. */\n    if (server.masterhost && server.repl_slave_ro &&\n        !(c->flags & CLIENT_MASTER) &&\n        is_write_command)\n    {\n        rejectCommand(c, shared.roslaveerr);\n        return C_OK;\n    }\n\n    /* Only allow a subset of commands in the context of Pub/Sub if the\n     * connection is in RESP2 mode. With RESP3 there are no limits. */\n    if ((c->flags & CLIENT_PUBSUB && c->resp == 2) &&\n        c->cmd->proc != pingCommand &&\n        c->cmd->proc != subscribeCommand &&\n        c->cmd->proc != unsubscribeCommand &&\n        c->cmd->proc != psubscribeCommand &&\n        c->cmd->proc != punsubscribeCommand) {\n        rejectCommandFormat(c,\n            \"Can't execute '%s': only (P)SUBSCRIBE / \"\n            \"(P)UNSUBSCRIBE / PING / QUIT are allowed in this context\",\n            c->cmd->name);\n        return C_OK;\n    }\n\n    /* Only allow commands with flag \"t\", such as INFO, SLAVEOF and so on,\n     * when slave-serve-stale-data is no and we are a slave with a broken\n     * link with master. */\n    if (server.masterhost && server.repl_state != REPL_STATE_CONNECTED &&\n        server.repl_serve_stale_data == 0 &&\n        is_denystale_command)\n    {\n        rejectCommand(c, shared.masterdownerr);\n        return C_OK;\n    }\n\n    /* Loading DB? Return an error if the command has not the\n     * CMD_LOADING flag. */\n    if (server.loading && is_denyloading_command) {\n        rejectCommand(c, shared.loadingerr);\n        return C_OK;\n    }\n\n    /* Lua script too slow? Only allow a limited number of commands.\n     * Note that we need to allow the transactions commands, otherwise clients\n     * sending a transaction with pipelining without error checking, may have\n     * the MULTI plus a few initial commands refused, then the timeout\n     * condition resolves, and the bottom-half of the transaction gets\n     * executed, see Github PR #7022. */\n    if (server.lua_timedout &&\n          c->cmd->proc != authCommand &&\n          c->cmd->proc != helloCommand &&\n          c->cmd->proc != replconfCommand &&\n          c->cmd->proc != multiCommand &&\n          c->cmd->proc != discardCommand &&\n          c->cmd->proc != watchCommand &&\n          c->cmd->proc != unwatchCommand &&\n        !(c->cmd->proc == shutdownCommand &&\n          c->argc == 2 &&\n          tolower(((char*)c->argv[1]->ptr)[0]) == 'n') &&\n        !(c->cmd->proc == scriptCommand &&\n          c->argc == 2 &&\n          tolower(((char*)c->argv[1]->ptr)[0]) == 'k'))\n    {\n        rejectCommand(c, shared.slowscripterr);\n        return C_OK;\n    }\n\n    /* Exec the command */\n    if (c->flags & CLIENT_MULTI &&\n        c->cmd->proc != execCommand && c->cmd->proc != discardCommand &&\n        c->cmd->proc != multiCommand && c->cmd->proc != watchCommand)\n    {\n        queueMultiCommand(c);\n        addReply(c,shared.queued);\n    } else {\n        call(c,CMD_CALL_FULL);\n        c->woff = server.master_repl_offset;\n        if (listLength(server.ready_keys))\n            handleClientsBlockedOnKeys();\n    }\n    return C_OK;\n}\n\n/*================================== Shutdown =============================== */\n\n/* Close listening sockets. Also unlink the unix domain socket if\n * unlink_unix_socket is non-zero. */\nvoid closeListeningSockets(int unlink_unix_socket) {\n    int j;\n\n    for (j = 0; j < server.ipfd_count; j++) close(server.ipfd[j]);\n    for (j = 0; j < server.tlsfd_count; j++) close(server.tlsfd[j]);\n    if (server.sofd != -1) close(server.sofd);\n    if (server.cluster_enabled)\n        for (j = 0; j < server.cfd_count; j++) close(server.cfd[j]);\n    if (unlink_unix_socket && server.unixsocket) {\n        serverLog(LL_NOTICE,\"Removing the unix socket file.\");\n        unlink(server.unixsocket); /* don't care if this fails */\n    }\n}\n\nint prepareForShutdown(int flags) {\n    /* When SHUTDOWN is called while the server is loading a dataset in\n     * memory we need to make sure no attempt is performed to save\n     * the dataset on shutdown (otherwise it could overwrite the current DB\n     * with half-read data).\n     *\n     * Also when in Sentinel mode clear the SAVE flag and force NOSAVE. */\n    if (server.loading || server.sentinel_mode)\n        flags = (flags & ~SHUTDOWN_SAVE) | SHUTDOWN_NOSAVE;\n\n    int save = flags & SHUTDOWN_SAVE;\n    int nosave = flags & SHUTDOWN_NOSAVE;\n\n    serverLog(LL_WARNING,\"User requested shutdown...\");\n    if (server.supervised_mode == SUPERVISED_SYSTEMD)\n        redisCommunicateSystemd(\"STOPPING=1\\n\");\n\n    /* Kill all the Lua debugger forked sessions. */\n    ldbKillForkedSessions();\n\n    /* Kill the saving child if there is a background saving in progress.\n       We want to avoid race conditions, for instance our saving child may\n       overwrite the synchronous saving did by SHUTDOWN. */\n    if (server.rdb_child_pid != -1) {\n        serverLog(LL_WARNING,\"There is a child saving an .rdb. Killing it!\");\n        /* Note that, in killRDBChild, we call rdbRemoveTempFile that will\n         * do close fd(in order to unlink file actully) in background thread.\n         * The temp rdb file fd may won't be closed when redis exits quickly,\n         * but OS will close this fd when process exits. */\n        killRDBChild();\n    }\n\n    /* Kill module child if there is one. */\n    if (server.module_child_pid != -1) {\n        serverLog(LL_WARNING,\"There is a module fork child. Killing it!\");\n        TerminateModuleForkChild(server.module_child_pid,0);\n    }\n\n    if (server.aof_state != AOF_OFF) {\n        /* Kill the AOF saving child as the AOF we already have may be longer\n         * but contains the full dataset anyway. */\n        if (server.aof_child_pid != -1) {\n            /* If we have AOF enabled but haven't written the AOF yet, don't\n             * shutdown or else the dataset will be lost. */\n            if (server.aof_state == AOF_WAIT_REWRITE) {\n                serverLog(LL_WARNING, \"Writing initial AOF, can't exit.\");\n                return C_ERR;\n            }\n            serverLog(LL_WARNING,\n                \"There is a child rewriting the AOF. Killing it!\");\n            killAppendOnlyChild();\n        }\n        /* Append only file: flush buffers and fsync() the AOF at exit */\n        serverLog(LL_NOTICE,\"Calling fsync() on the AOF file.\");\n        flushAppendOnlyFile(1);\n        redis_fsync(server.aof_fd);\n    }\n\n    /* Create a new RDB file before exiting. */\n    if ((server.saveparamslen > 0 && !nosave) || save) {\n        serverLog(LL_NOTICE,\"Saving the final RDB snapshot before exiting.\");\n        if (server.supervised_mode == SUPERVISED_SYSTEMD)\n            redisCommunicateSystemd(\"STATUS=Saving the final RDB snapshot\\n\");\n        /* Snapshotting. Perform a SYNC SAVE and exit */\n        rdbSaveInfo rsi, *rsiptr;\n        rsiptr = rdbPopulateSaveInfo(&rsi);\n        if (rdbSave(server.rdb_filename,rsiptr) != C_OK) {\n            /* Ooops.. error saving! The best we can do is to continue\n             * operating. Note that if there was a background saving process,\n             * in the next cron() Redis will be notified that the background\n             * saving aborted, handling special stuff like slaves pending for\n             * synchronization... */\n            serverLog(LL_WARNING,\"Error trying to save the DB, can't exit.\");\n            if (server.supervised_mode == SUPERVISED_SYSTEMD)\n                redisCommunicateSystemd(\"STATUS=Error trying to save the DB, can't exit.\\n\");\n            return C_ERR;\n        }\n    }\n\n    /* Fire the shutdown modules event. */\n    moduleFireServerEvent(REDISMODULE_EVENT_SHUTDOWN,0,NULL);\n\n    /* Remove the pid file if possible and needed. */\n    if (server.daemonize || server.pidfile) {\n        serverLog(LL_NOTICE,\"Removing the pid file.\");\n        unlink(server.pidfile);\n    }\n\n    /* Best effort flush of slave output buffers, so that we hopefully\n     * send them pending writes. */\n    flushSlavesOutputBuffers();\n\n    /* Close the listening sockets. Apparently this allows faster restarts. */\n    closeListeningSockets(1);\n    serverLog(LL_WARNING,\"%s is now ready to exit, bye bye...\",\n        server.sentinel_mode ? \"Sentinel\" : \"Redis\");\n    return C_OK;\n}\n\n/*================================== Commands =============================== */\n\n/* Sometimes Redis cannot accept write commands because there is a persistence\n * error with the RDB or AOF file, and Redis is configured in order to stop\n * accepting writes in such situation. This function returns if such a\n * condition is active, and the type of the condition.\n *\n * Function return values:\n *\n * DISK_ERROR_TYPE_NONE:    No problems, we can accept writes.\n * DISK_ERROR_TYPE_AOF:     Don't accept writes: AOF errors.\n * DISK_ERROR_TYPE_RDB:     Don't accept writes: RDB errors.\n */\nint writeCommandsDeniedByDiskError(void) {\n    if (server.stop_writes_on_bgsave_err &&\n        server.saveparamslen > 0 &&\n        server.lastbgsave_status == C_ERR)\n    {\n        return DISK_ERROR_TYPE_RDB;\n    } else if (server.aof_state != AOF_OFF &&\n               server.aof_last_write_status == C_ERR)\n    {\n        return DISK_ERROR_TYPE_AOF;\n    } else {\n        return DISK_ERROR_TYPE_NONE;\n    }\n}\n\n/* The PING command. It works in a different way if the client is in\n * in Pub/Sub mode. */\nvoid pingCommand(client *c) {\n    /* The command takes zero or one arguments. */\n    if (c->argc > 2) {\n        addReplyErrorFormat(c,\"wrong number of arguments for '%s' command\",\n            c->cmd->name);\n        return;\n    }\n\n    if (c->flags & CLIENT_PUBSUB && c->resp == 2) {\n        addReply(c,shared.mbulkhdr[2]);\n        addReplyBulkCBuffer(c,\"pong\",4);\n        if (c->argc == 1)\n            addReplyBulkCBuffer(c,\"\",0);\n        else\n            addReplyBulk(c,c->argv[1]);\n    } else {\n        if (c->argc == 1)\n            addReply(c,shared.pong);\n        else\n            addReplyBulk(c,c->argv[1]);\n    }\n}\n\nvoid echoCommand(client *c) {\n    addReplyBulk(c,c->argv[1]);\n}\n\nvoid timeCommand(client *c) {\n    struct timeval tv;\n\n    /* gettimeofday() can only fail if &tv is a bad address so we\n     * don't check for errors. */\n    gettimeofday(&tv,NULL);\n    addReplyArrayLen(c,2);\n    addReplyBulkLongLong(c,tv.tv_sec);\n    addReplyBulkLongLong(c,tv.tv_usec);\n}\n\n/* Helper function for addReplyCommand() to output flags. */\nint addReplyCommandFlag(client *c, struct redisCommand *cmd, int f, char *reply) {\n    if (cmd->flags & f) {\n        addReplyStatus(c, reply);\n        return 1;\n    }\n    return 0;\n}\n\n/* Output the representation of a Redis command. Used by the COMMAND command. */\nvoid addReplyCommand(client *c, struct redisCommand *cmd) {\n    if (!cmd) {\n        addReplyNull(c);\n    } else {\n        /* We are adding: command name, arg count, flags, first, last, offset, categories */\n        addReplyArrayLen(c, 7);\n        addReplyBulkCString(c, cmd->name);\n        addReplyLongLong(c, cmd->arity);\n\n        int flagcount = 0;\n        void *flaglen = addReplyDeferredLen(c);\n        flagcount += addReplyCommandFlag(c,cmd,CMD_WRITE, \"write\");\n        flagcount += addReplyCommandFlag(c,cmd,CMD_READONLY, \"readonly\");\n        flagcount += addReplyCommandFlag(c,cmd,CMD_DENYOOM, \"denyoom\");\n        flagcount += addReplyCommandFlag(c,cmd,CMD_ADMIN, \"admin\");\n        flagcount += addReplyCommandFlag(c,cmd,CMD_PUBSUB, \"pubsub\");\n        flagcount += addReplyCommandFlag(c,cmd,CMD_NOSCRIPT, \"noscript\");\n        flagcount += addReplyCommandFlag(c,cmd,CMD_RANDOM, \"random\");\n        flagcount += addReplyCommandFlag(c,cmd,CMD_SORT_FOR_SCRIPT,\"sort_for_script\");\n        flagcount += addReplyCommandFlag(c,cmd,CMD_LOADING, \"loading\");\n        flagcount += addReplyCommandFlag(c,cmd,CMD_STALE, \"stale\");\n        flagcount += addReplyCommandFlag(c,cmd,CMD_SKIP_MONITOR, \"skip_monitor\");\n        flagcount += addReplyCommandFlag(c,cmd,CMD_SKIP_SLOWLOG, \"skip_slowlog\");\n        flagcount += addReplyCommandFlag(c,cmd,CMD_ASKING, \"asking\");\n        flagcount += addReplyCommandFlag(c,cmd,CMD_FAST, \"fast\");\n        flagcount += addReplyCommandFlag(c,cmd,CMD_NO_AUTH, \"no_auth\");\n        if ((cmd->getkeys_proc && !(cmd->flags & CMD_MODULE)) ||\n            cmd->flags & CMD_MODULE_GETKEYS)\n        {\n            addReplyStatus(c, \"movablekeys\");\n            flagcount += 1;\n        }\n        setDeferredSetLen(c, flaglen, flagcount);\n\n        addReplyLongLong(c, cmd->firstkey);\n        addReplyLongLong(c, cmd->lastkey);\n        addReplyLongLong(c, cmd->keystep);\n\n        addReplyCommandCategories(c,cmd);\n    }\n}\n\n/* COMMAND <subcommand> <args> */\nvoid commandCommand(client *c) {\n    dictIterator *di;\n    dictEntry *de;\n\n    if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,\"help\")) {\n        const char *help[] = {\n\"(no subcommand) -- Return details about all Redis commands.\",\n\"COUNT -- Return the total number of commands in this Redis server.\",\n\"GETKEYS <full-command> -- Return the keys from a full Redis command.\",\n\"INFO [command-name ...] -- Return details about multiple Redis commands.\",\nNULL\n        };\n        addReplyHelp(c, help);\n    } else if (c->argc == 1) {\n        addReplyArrayLen(c, dictSize(server.commands));\n        di = dictGetIterator(server.commands);\n        while ((de = dictNext(di)) != NULL) {\n            addReplyCommand(c, dictGetVal(de));\n        }\n        dictReleaseIterator(di);\n    } else if (!strcasecmp(c->argv[1]->ptr, \"info\")) {\n        int i;\n        addReplyArrayLen(c, c->argc-2);\n        for (i = 2; i < c->argc; i++) {\n            addReplyCommand(c, dictFetchValue(server.commands, c->argv[i]->ptr));\n        }\n    } else if (!strcasecmp(c->argv[1]->ptr, \"count\") && c->argc == 2) {\n        addReplyLongLong(c, dictSize(server.commands));\n    } else if (!strcasecmp(c->argv[1]->ptr,\"getkeys\") && c->argc >= 3) {\n        struct redisCommand *cmd = lookupCommand(c->argv[2]->ptr);\n        getKeysResult result = GETKEYS_RESULT_INIT;\n        int j;\n\n        if (!cmd) {\n            addReplyError(c,\"Invalid command specified\");\n            return;\n        } else if (cmd->getkeys_proc == NULL && cmd->firstkey == 0) {\n            addReplyError(c,\"The command has no key arguments\");\n            return;\n        } else if ((cmd->arity > 0 && cmd->arity != c->argc-2) ||\n                   ((c->argc-2) < -cmd->arity))\n        {\n            addReplyError(c,\"Invalid number of arguments specified for command\");\n            return;\n        }\n\n        if (!getKeysFromCommand(cmd,c->argv+2,c->argc-2,&result)) {\n            addReplyError(c,\"Invalid arguments specified for command\");\n        } else {\n            addReplyArrayLen(c,result.numkeys);\n            for (j = 0; j < result.numkeys; j++) addReplyBulk(c,c->argv[result.keys[j]+2]);\n        }\n        getKeysFreeResult(&result);\n    } else {\n        addReplySubcommandSyntaxError(c);\n    }\n}\n\n/* Convert an amount of bytes into a human readable string in the form\n * of 100B, 2G, 100M, 4K, and so forth. */\nvoid bytesToHuman(char *s, unsigned long long n) {\n    double d;\n\n    if (n < 1024) {\n        /* Bytes */\n        sprintf(s,\"%lluB\",n);\n    } else if (n < (1024*1024)) {\n        d = (double)n/(1024);\n        sprintf(s,\"%.2fK\",d);\n    } else if (n < (1024LL*1024*1024)) {\n        d = (double)n/(1024*1024);\n        sprintf(s,\"%.2fM\",d);\n    } else if (n < (1024LL*1024*1024*1024)) {\n        d = (double)n/(1024LL*1024*1024);\n        sprintf(s,\"%.2fG\",d);\n    } else if (n < (1024LL*1024*1024*1024*1024)) {\n        d = (double)n/(1024LL*1024*1024*1024);\n        sprintf(s,\"%.2fT\",d);\n    } else if (n < (1024LL*1024*1024*1024*1024*1024)) {\n        d = (double)n/(1024LL*1024*1024*1024*1024);\n        sprintf(s,\"%.2fP\",d);\n    } else {\n        /* Let's hope we never need this */\n        sprintf(s,\"%lluB\",n);\n    }\n}\n\n/* Create the string returned by the INFO command. This is decoupled\n * by the INFO command itself as we need to report the same information\n * on memory corruption problems. */\nsds genRedisInfoString(const char *section) {\n    sds info = sdsempty();\n    time_t uptime = server.unixtime-server.stat_starttime;\n    int j;\n    struct rusage self_ru, c_ru;\n    int allsections = 0, defsections = 0, everything = 0, modules = 0;\n    int sections = 0;\n\n    if (section == NULL) section = \"default\";\n    allsections = strcasecmp(section,\"all\") == 0;\n    defsections = strcasecmp(section,\"default\") == 0;\n    everything = strcasecmp(section,\"everything\") == 0;\n    modules = strcasecmp(section,\"modules\") == 0;\n    if (everything) allsections = 1;\n\n    getrusage(RUSAGE_SELF, &self_ru);\n    getrusage(RUSAGE_CHILDREN, &c_ru);\n\n    /* Server */\n    if (allsections || defsections || !strcasecmp(section,\"server\")) {\n        static int call_uname = 1;\n        static struct utsname name;\n        char *mode;\n\n        if (server.cluster_enabled) mode = \"cluster\";\n        else if (server.sentinel_mode) mode = \"sentinel\";\n        else mode = \"standalone\";\n\n        if (sections++) info = sdscat(info,\"\\r\\n\");\n\n        if (call_uname) {\n            /* Uname can be slow and is always the same output. Cache it. */\n            uname(&name);\n            call_uname = 0;\n        }\n\n        info = sdscatfmt(info,\n            \"# Server\\r\\n\"\n            \"redis_version:%s\\r\\n\"\n            \"redis_git_sha1:%s\\r\\n\"\n            \"redis_git_dirty:%i\\r\\n\"\n            \"redis_build_id:%s\\r\\n\"\n            \"redis_mode:%s\\r\\n\"\n            \"os:%s %s %s\\r\\n\"\n            \"arch_bits:%i\\r\\n\"\n            \"multiplexing_api:%s\\r\\n\"\n            \"atomicvar_api:%s\\r\\n\"\n            \"gcc_version:%i.%i.%i\\r\\n\"\n            \"process_id:%I\\r\\n\"\n            \"run_id:%s\\r\\n\"\n            \"tcp_port:%i\\r\\n\"\n            \"uptime_in_seconds:%I\\r\\n\"\n            \"uptime_in_days:%I\\r\\n\"\n            \"hz:%i\\r\\n\"\n            \"configured_hz:%i\\r\\n\"\n            \"lru_clock:%u\\r\\n\"\n            \"executable:%s\\r\\n\"\n            \"config_file:%s\\r\\n\"\n            \"io_threads_active:%i\\r\\n\",\n            REDIS_VERSION,\n            redisGitSHA1(),\n            strtol(redisGitDirty(),NULL,10) > 0,\n            redisBuildIdString(),\n            mode,\n            name.sysname, name.release, name.machine,\n            server.arch_bits,\n            aeGetApiName(),\n            REDIS_ATOMIC_API,\n#ifdef __GNUC__\n            __GNUC__,__GNUC_MINOR__,__GNUC_PATCHLEVEL__,\n#else\n            0,0,0,\n#endif\n            (int64_t) getpid(),\n            server.runid,\n            server.port ? server.port : server.tls_port,\n            (int64_t)uptime,\n            (int64_t)(uptime/(3600*24)),\n            server.hz,\n            server.config_hz,\n            server.lruclock,\n            server.executable ? server.executable : \"\",\n            server.configfile ? server.configfile : \"\",\n            server.io_threads_active);\n    }\n\n    /* Clients */\n    if (allsections || defsections || !strcasecmp(section,\"clients\")) {\n        size_t maxin, maxout;\n        getExpansiveClientsInfo(&maxin,&maxout);\n        if (sections++) info = sdscat(info,\"\\r\\n\");\n        info = sdscatprintf(info,\n            \"# Clients\\r\\n\"\n            \"connected_clients:%lu\\r\\n\"\n            \"client_recent_max_input_buffer:%zu\\r\\n\"\n            \"client_recent_max_output_buffer:%zu\\r\\n\"\n            \"blocked_clients:%d\\r\\n\"\n            \"tracking_clients:%d\\r\\n\"\n            \"clients_in_timeout_table:%llu\\r\\n\",\n            listLength(server.clients)-listLength(server.slaves),\n            maxin, maxout,\n            server.blocked_clients,\n            server.tracking_clients,\n            (unsigned long long) raxSize(server.clients_timeout_table));\n    }\n\n    /* Memory */\n    if (allsections || defsections || !strcasecmp(section,\"memory\")) {\n        char hmem[64];\n        char peak_hmem[64];\n        char total_system_hmem[64];\n        char used_memory_lua_hmem[64];\n        char used_memory_scripts_hmem[64];\n        char used_memory_rss_hmem[64];\n        char maxmemory_hmem[64];\n        size_t zmalloc_used = zmalloc_used_memory();\n        size_t total_system_mem = server.system_memory_size;\n        const char *evict_policy = evictPolicyToString();\n        long long memory_lua = server.lua ? (long long)lua_gc(server.lua,LUA_GCCOUNT,0)*1024 : 0;\n        struct redisMemOverhead *mh = getMemoryOverheadData();\n\n        /* Peak memory is updated from time to time by serverCron() so it\n         * may happen that the instantaneous value is slightly bigger than\n         * the peak value. This may confuse users, so we update the peak\n         * if found smaller than the current memory usage. */\n        if (zmalloc_used > server.stat_peak_memory)\n            server.stat_peak_memory = zmalloc_used;\n\n        bytesToHuman(hmem,zmalloc_used);\n        bytesToHuman(peak_hmem,server.stat_peak_memory);\n        bytesToHuman(total_system_hmem,total_system_mem);\n        bytesToHuman(used_memory_lua_hmem,memory_lua);\n        bytesToHuman(used_memory_scripts_hmem,mh->lua_caches);\n        bytesToHuman(used_memory_rss_hmem,server.cron_malloc_stats.process_rss);\n        bytesToHuman(maxmemory_hmem,server.maxmemory);\n\n        if (sections++) info = sdscat(info,\"\\r\\n\");\n        info = sdscatprintf(info,\n            \"# Memory\\r\\n\"\n            \"used_memory:%zu\\r\\n\"\n            \"used_memory_human:%s\\r\\n\"\n            \"used_memory_rss:%zu\\r\\n\"\n            \"used_memory_rss_human:%s\\r\\n\"\n            \"used_memory_peak:%zu\\r\\n\"\n            \"used_memory_peak_human:%s\\r\\n\"\n            \"used_memory_peak_perc:%.2f%%\\r\\n\"\n            \"used_memory_overhead:%zu\\r\\n\"\n            \"used_memory_startup:%zu\\r\\n\"\n            \"used_memory_dataset:%zu\\r\\n\"\n            \"used_memory_dataset_perc:%.2f%%\\r\\n\"\n            \"allocator_allocated:%zu\\r\\n\"\n            \"allocator_active:%zu\\r\\n\"\n            \"allocator_resident:%zu\\r\\n\"\n            \"total_system_memory:%lu\\r\\n\"\n            \"total_system_memory_human:%s\\r\\n\"\n            \"used_memory_lua:%lld\\r\\n\"\n            \"used_memory_lua_human:%s\\r\\n\"\n            \"used_memory_scripts:%lld\\r\\n\"\n            \"used_memory_scripts_human:%s\\r\\n\"\n            \"number_of_cached_scripts:%lu\\r\\n\"\n            \"maxmemory:%lld\\r\\n\"\n            \"maxmemory_human:%s\\r\\n\"\n            \"maxmemory_policy:%s\\r\\n\"\n            \"allocator_frag_ratio:%.2f\\r\\n\"\n            \"allocator_frag_bytes:%zu\\r\\n\"\n            \"allocator_rss_ratio:%.2f\\r\\n\"\n            \"allocator_rss_bytes:%zd\\r\\n\"\n            \"rss_overhead_ratio:%.2f\\r\\n\"\n            \"rss_overhead_bytes:%zd\\r\\n\"\n            \"mem_fragmentation_ratio:%.2f\\r\\n\"\n            \"mem_fragmentation_bytes:%zd\\r\\n\"\n            \"mem_not_counted_for_evict:%zu\\r\\n\"\n            \"mem_replication_backlog:%zu\\r\\n\"\n            \"mem_clients_slaves:%zu\\r\\n\"\n            \"mem_clients_normal:%zu\\r\\n\"\n            \"mem_aof_buffer:%zu\\r\\n\"\n            \"mem_allocator:%s\\r\\n\"\n            \"active_defrag_running:%d\\r\\n\"\n            \"lazyfree_pending_objects:%zu\\r\\n\",\n            zmalloc_used,\n            hmem,\n            server.cron_malloc_stats.process_rss,\n            used_memory_rss_hmem,\n            server.stat_peak_memory,\n            peak_hmem,\n            mh->peak_perc,\n            mh->overhead_total,\n            mh->startup_allocated,\n            mh->dataset,\n            mh->dataset_perc,\n            server.cron_malloc_stats.allocator_allocated,\n            server.cron_malloc_stats.allocator_active,\n            server.cron_malloc_stats.allocator_resident,\n            (unsigned long)total_system_mem,\n            total_system_hmem,\n            memory_lua,\n            used_memory_lua_hmem,\n            (long long) mh->lua_caches,\n            used_memory_scripts_hmem,\n            dictSize(server.lua_scripts),\n            server.maxmemory,\n            maxmemory_hmem,\n            evict_policy,\n            mh->allocator_frag,\n            mh->allocator_frag_bytes,\n            mh->allocator_rss,\n            mh->allocator_rss_bytes,\n            mh->rss_extra,\n            mh->rss_extra_bytes,\n            mh->total_frag,       /* This is the total RSS overhead, including\n                                     fragmentation, but not just it. This field\n                                     (and the next one) is named like that just\n                                     for backward compatibility. */\n            mh->total_frag_bytes,\n            freeMemoryGetNotCountedMemory(),\n            mh->repl_backlog,\n            mh->clients_slaves,\n            mh->clients_normal,\n            mh->aof_buffer,\n            ZMALLOC_LIB,\n            server.active_defrag_running,\n            lazyfreeGetPendingObjectsCount()\n        );\n        freeMemoryOverheadData(mh);\n    }\n\n    /* Persistence */\n    if (allsections || defsections || !strcasecmp(section,\"persistence\")) {\n        if (sections++) info = sdscat(info,\"\\r\\n\");\n        info = sdscatprintf(info,\n            \"# Persistence\\r\\n\"\n            \"loading:%d\\r\\n\"\n            \"rdb_changes_since_last_save:%lld\\r\\n\"\n            \"rdb_bgsave_in_progress:%d\\r\\n\"\n            \"rdb_last_save_time:%jd\\r\\n\"\n            \"rdb_last_bgsave_status:%s\\r\\n\"\n            \"rdb_last_bgsave_time_sec:%jd\\r\\n\"\n            \"rdb_current_bgsave_time_sec:%jd\\r\\n\"\n            \"rdb_last_cow_size:%zu\\r\\n\"\n            \"aof_enabled:%d\\r\\n\"\n            \"aof_rewrite_in_progress:%d\\r\\n\"\n            \"aof_rewrite_scheduled:%d\\r\\n\"\n            \"aof_last_rewrite_time_sec:%jd\\r\\n\"\n            \"aof_current_rewrite_time_sec:%jd\\r\\n\"\n            \"aof_last_bgrewrite_status:%s\\r\\n\"\n            \"aof_last_write_status:%s\\r\\n\"\n            \"aof_last_cow_size:%zu\\r\\n\"\n            \"module_fork_in_progress:%d\\r\\n\"\n            \"module_fork_last_cow_size:%zu\\r\\n\",\n            server.loading,\n            server.dirty,\n            server.rdb_child_pid != -1,\n            (intmax_t)server.lastsave,\n            (server.lastbgsave_status == C_OK) ? \"ok\" : \"err\",\n            (intmax_t)server.rdb_save_time_last,\n            (intmax_t)((server.rdb_child_pid == -1) ?\n                -1 : time(NULL)-server.rdb_save_time_start),\n            server.stat_rdb_cow_bytes,\n            server.aof_state != AOF_OFF,\n            server.aof_child_pid != -1,\n            server.aof_rewrite_scheduled,\n            (intmax_t)server.aof_rewrite_time_last,\n            (intmax_t)((server.aof_child_pid == -1) ?\n                -1 : time(NULL)-server.aof_rewrite_time_start),\n            (server.aof_lastbgrewrite_status == C_OK) ? \"ok\" : \"err\",\n            (server.aof_last_write_status == C_OK) ? \"ok\" : \"err\",\n            server.stat_aof_cow_bytes,\n            server.module_child_pid != -1,\n            server.stat_module_cow_bytes);\n\n        if (server.aof_enabled) {\n            info = sdscatprintf(info,\n                \"aof_current_size:%lld\\r\\n\"\n                \"aof_base_size:%lld\\r\\n\"\n                \"aof_pending_rewrite:%d\\r\\n\"\n                \"aof_buffer_length:%zu\\r\\n\"\n                \"aof_rewrite_buffer_length:%lu\\r\\n\"\n                \"aof_pending_bio_fsync:%llu\\r\\n\"\n                \"aof_delayed_fsync:%lu\\r\\n\",\n                (long long) server.aof_current_size,\n                (long long) server.aof_rewrite_base_size,\n                server.aof_rewrite_scheduled,\n                sdslen(server.aof_buf),\n                aofRewriteBufferSize(),\n                bioPendingJobsOfType(BIO_AOF_FSYNC),\n                server.aof_delayed_fsync);\n        }\n\n        if (server.loading) {\n            double perc;\n            time_t eta, elapsed;\n            off_t remaining_bytes = server.loading_total_bytes-\n                                    server.loading_loaded_bytes;\n\n            perc = ((double)server.loading_loaded_bytes /\n                   (server.loading_total_bytes+1)) * 100;\n\n            elapsed = time(NULL)-server.loading_start_time;\n            if (elapsed == 0) {\n                eta = 1; /* A fake 1 second figure if we don't have\n                            enough info */\n            } else {\n                eta = (elapsed*remaining_bytes)/(server.loading_loaded_bytes+1);\n            }\n\n            info = sdscatprintf(info,\n                \"loading_start_time:%jd\\r\\n\"\n                \"loading_total_bytes:%llu\\r\\n\"\n                \"loading_loaded_bytes:%llu\\r\\n\"\n                \"loading_loaded_perc:%.2f\\r\\n\"\n                \"loading_eta_seconds:%jd\\r\\n\",\n                (intmax_t) server.loading_start_time,\n                (unsigned long long) server.loading_total_bytes,\n                (unsigned long long) server.loading_loaded_bytes,\n                perc,\n                (intmax_t)eta\n            );\n        }\n    }\n\n    /* Stats */\n    if (allsections || defsections || !strcasecmp(section,\"stats\")) {\n        if (sections++) info = sdscat(info,\"\\r\\n\");\n        info = sdscatprintf(info,\n            \"# Stats\\r\\n\"\n            \"total_connections_received:%lld\\r\\n\"\n            \"total_commands_processed:%lld\\r\\n\"\n            \"instantaneous_ops_per_sec:%lld\\r\\n\"\n            \"total_net_input_bytes:%lld\\r\\n\"\n            \"total_net_output_bytes:%lld\\r\\n\"\n            \"instantaneous_input_kbps:%.2f\\r\\n\"\n            \"instantaneous_output_kbps:%.2f\\r\\n\"\n            \"rejected_connections:%lld\\r\\n\"\n            \"sync_full:%lld\\r\\n\"\n            \"sync_partial_ok:%lld\\r\\n\"\n            \"sync_partial_err:%lld\\r\\n\"\n            \"expired_keys:%lld\\r\\n\"\n            \"expired_stale_perc:%.2f\\r\\n\"\n            \"expired_time_cap_reached_count:%lld\\r\\n\"\n            \"expire_cycle_cpu_milliseconds:%lld\\r\\n\"\n            \"evicted_keys:%lld\\r\\n\"\n            \"keyspace_hits:%lld\\r\\n\"\n            \"keyspace_misses:%lld\\r\\n\"\n            \"pubsub_channels:%ld\\r\\n\"\n            \"pubsub_patterns:%lu\\r\\n\"\n            \"latest_fork_usec:%lld\\r\\n\"\n            \"migrate_cached_sockets:%ld\\r\\n\"\n            \"slave_expires_tracked_keys:%zu\\r\\n\"\n            \"active_defrag_hits:%lld\\r\\n\"\n            \"active_defrag_misses:%lld\\r\\n\"\n            \"active_defrag_key_hits:%lld\\r\\n\"\n            \"active_defrag_key_misses:%lld\\r\\n\"\n            \"tracking_total_keys:%lld\\r\\n\"\n            \"tracking_total_items:%lld\\r\\n\"\n            \"tracking_total_prefixes:%lld\\r\\n\"\n            \"unexpected_error_replies:%lld\\r\\n\"\n            \"total_reads_processed:%lld\\r\\n\"\n            \"total_writes_processed:%lld\\r\\n\"\n            \"io_threaded_reads_processed:%lld\\r\\n\"\n            \"io_threaded_writes_processed:%lld\\r\\n\",\n            server.stat_numconnections,\n            server.stat_numcommands,\n            getInstantaneousMetric(STATS_METRIC_COMMAND),\n            server.stat_net_input_bytes,\n            server.stat_net_output_bytes,\n            (float)getInstantaneousMetric(STATS_METRIC_NET_INPUT)/1024,\n            (float)getInstantaneousMetric(STATS_METRIC_NET_OUTPUT)/1024,\n            server.stat_rejected_conn,\n            server.stat_sync_full,\n            server.stat_sync_partial_ok,\n            server.stat_sync_partial_err,\n            server.stat_expiredkeys,\n            server.stat_expired_stale_perc*100,\n            server.stat_expired_time_cap_reached_count,\n            server.stat_expire_cycle_time_used/1000,\n            server.stat_evictedkeys,\n            server.stat_keyspace_hits,\n            server.stat_keyspace_misses,\n            dictSize(server.pubsub_channels),\n            listLength(server.pubsub_patterns),\n            server.stat_fork_time,\n            dictSize(server.migrate_cached_sockets),\n            getSlaveKeyWithExpireCount(),\n            server.stat_active_defrag_hits,\n            server.stat_active_defrag_misses,\n            server.stat_active_defrag_key_hits,\n            server.stat_active_defrag_key_misses,\n            (unsigned long long) trackingGetTotalKeys(),\n            (unsigned long long) trackingGetTotalItems(),\n            (unsigned long long) trackingGetTotalPrefixes(),\n            server.stat_unexpected_error_replies,\n            server.stat_total_reads_processed,\n            server.stat_total_writes_processed,\n            server.stat_io_reads_processed,\n            server.stat_io_writes_processed);\n    }\n\n    /* Replication */\n    if (allsections || defsections || !strcasecmp(section,\"replication\")) {\n        if (sections++) info = sdscat(info,\"\\r\\n\");\n        info = sdscatprintf(info,\n            \"# Replication\\r\\n\"\n            \"role:%s\\r\\n\",\n            server.masterhost == NULL ? \"master\" : \"slave\");\n        if (server.masterhost) {\n            long long slave_repl_offset = 1;\n\n            if (server.master)\n                slave_repl_offset = server.master->reploff;\n            else if (server.cached_master)\n                slave_repl_offset = server.cached_master->reploff;\n\n            info = sdscatprintf(info,\n                \"master_host:%s\\r\\n\"\n                \"master_port:%d\\r\\n\"\n                \"master_link_status:%s\\r\\n\"\n                \"master_last_io_seconds_ago:%d\\r\\n\"\n                \"master_sync_in_progress:%d\\r\\n\"\n                \"slave_repl_offset:%lld\\r\\n\"\n                ,server.masterhost,\n                server.masterport,\n                (server.repl_state == REPL_STATE_CONNECTED) ?\n                    \"up\" : \"down\",\n                server.master ?\n                ((int)(server.unixtime-server.master->lastinteraction)) : -1,\n                server.repl_state == REPL_STATE_TRANSFER,\n                slave_repl_offset\n            );\n\n            if (server.repl_state == REPL_STATE_TRANSFER) {\n                info = sdscatprintf(info,\n                    \"master_sync_left_bytes:%lld\\r\\n\"\n                    \"master_sync_last_io_seconds_ago:%d\\r\\n\"\n                    , (long long)\n                        (server.repl_transfer_size - server.repl_transfer_read),\n                    (int)(server.unixtime-server.repl_transfer_lastio)\n                );\n            }\n\n            if (server.repl_state != REPL_STATE_CONNECTED) {\n                info = sdscatprintf(info,\n                    \"master_link_down_since_seconds:%jd\\r\\n\",\n                    (intmax_t)(server.unixtime-server.repl_down_since));\n            }\n            info = sdscatprintf(info,\n                \"slave_priority:%d\\r\\n\"\n                \"slave_read_only:%d\\r\\n\",\n                server.slave_priority,\n                server.repl_slave_ro);\n        }\n\n        info = sdscatprintf(info,\n            \"connected_slaves:%lu\\r\\n\",\n            listLength(server.slaves));\n\n        /* If min-slaves-to-write is active, write the number of slaves\n         * currently considered 'good'. */\n        if (server.repl_min_slaves_to_write &&\n            server.repl_min_slaves_max_lag) {\n            info = sdscatprintf(info,\n                \"min_slaves_good_slaves:%d\\r\\n\",\n                server.repl_good_slaves_count);\n        }\n\n        if (listLength(server.slaves)) {\n            int slaveid = 0;\n            listNode *ln;\n            listIter li;\n\n            listRewind(server.slaves,&li);\n            while((ln = listNext(&li))) {\n                client *slave = listNodeValue(ln);\n                char *state = NULL;\n                char ip[NET_IP_STR_LEN], *slaveip = slave->slave_ip;\n                int port;\n                long lag = 0;\n\n                if (slaveip[0] == '\\0') {\n                    if (connPeerToString(slave->conn,ip,sizeof(ip),&port) == -1)\n                        continue;\n                    slaveip = ip;\n                }\n                switch(slave->replstate) {\n                case SLAVE_STATE_WAIT_BGSAVE_START:\n                case SLAVE_STATE_WAIT_BGSAVE_END:\n                    state = \"wait_bgsave\";\n                    break;\n                case SLAVE_STATE_SEND_BULK:\n                    state = \"send_bulk\";\n                    break;\n                case SLAVE_STATE_ONLINE:\n                    state = \"online\";\n                    break;\n                }\n                if (state == NULL) continue;\n                if (slave->replstate == SLAVE_STATE_ONLINE)\n                    lag = time(NULL) - slave->repl_ack_time;\n\n                info = sdscatprintf(info,\n                    \"slave%d:ip=%s,port=%d,state=%s,\"\n                    \"offset=%lld,lag=%ld\\r\\n\",\n                    slaveid,slaveip,slave->slave_listening_port,state,\n                    slave->repl_ack_off, lag);\n                slaveid++;\n            }\n        }\n        info = sdscatprintf(info,\n            \"master_replid:%s\\r\\n\"\n            \"master_replid2:%s\\r\\n\"\n            \"master_repl_offset:%lld\\r\\n\"\n            \"second_repl_offset:%lld\\r\\n\"\n            \"repl_backlog_active:%d\\r\\n\"\n            \"repl_backlog_size:%lld\\r\\n\"\n            \"repl_backlog_first_byte_offset:%lld\\r\\n\"\n            \"repl_backlog_histlen:%lld\\r\\n\",\n            server.replid,\n            server.replid2,\n            server.master_repl_offset,\n            server.second_replid_offset,\n            server.repl_backlog != NULL,\n            server.repl_backlog_size,\n            server.repl_backlog_off,\n            server.repl_backlog_histlen);\n    }\n\n    /* CPU */\n    if (allsections || defsections || !strcasecmp(section,\"cpu\")) {\n        if (sections++) info = sdscat(info,\"\\r\\n\");\n        info = sdscatprintf(info,\n        \"# CPU\\r\\n\"\n        \"used_cpu_sys:%ld.%06ld\\r\\n\"\n        \"used_cpu_user:%ld.%06ld\\r\\n\"\n        \"used_cpu_sys_children:%ld.%06ld\\r\\n\"\n        \"used_cpu_user_children:%ld.%06ld\\r\\n\",\n        (long)self_ru.ru_stime.tv_sec, (long)self_ru.ru_stime.tv_usec,\n        (long)self_ru.ru_utime.tv_sec, (long)self_ru.ru_utime.tv_usec,\n        (long)c_ru.ru_stime.tv_sec, (long)c_ru.ru_stime.tv_usec,\n        (long)c_ru.ru_utime.tv_sec, (long)c_ru.ru_utime.tv_usec);\n    }\n\n    /* Modules */\n    if (allsections || defsections || !strcasecmp(section,\"modules\")) {\n        if (sections++) info = sdscat(info,\"\\r\\n\");\n        info = sdscatprintf(info,\"# Modules\\r\\n\");\n        info = genModulesInfoString(info);\n    }\n\n    /* Command statistics */\n    if (allsections || !strcasecmp(section,\"commandstats\")) {\n        if (sections++) info = sdscat(info,\"\\r\\n\");\n        info = sdscatprintf(info, \"# Commandstats\\r\\n\");\n\n        struct redisCommand *c;\n        dictEntry *de;\n        dictIterator *di;\n        di = dictGetSafeIterator(server.commands);\n        while((de = dictNext(di)) != NULL) {\n            c = (struct redisCommand *) dictGetVal(de);\n            if (!c->calls) continue;\n            info = sdscatprintf(info,\n                \"cmdstat_%s:calls=%lld,usec=%lld,usec_per_call=%.2f\\r\\n\",\n                c->name, c->calls, c->microseconds,\n                (c->calls == 0) ? 0 : ((float)c->microseconds/c->calls));\n        }\n        dictReleaseIterator(di);\n    }\n\n    /* Cluster */\n    if (allsections || defsections || !strcasecmp(section,\"cluster\")) {\n        if (sections++) info = sdscat(info,\"\\r\\n\");\n        info = sdscatprintf(info,\n        \"# Cluster\\r\\n\"\n        \"cluster_enabled:%d\\r\\n\",\n        server.cluster_enabled);\n    }\n\n    /* Key space */\n    if (allsections || defsections || !strcasecmp(section,\"keyspace\")) {\n        if (sections++) info = sdscat(info,\"\\r\\n\");\n        info = sdscatprintf(info, \"# Keyspace\\r\\n\");\n        for (j = 0; j < server.dbnum; j++) {\n            long long keys, vkeys;\n\n            keys = dictSize(server.db[j].dict);\n            vkeys = dictSize(server.db[j].expires);\n            if (keys || vkeys) {\n                info = sdscatprintf(info,\n                    \"db%d:keys=%lld,expires=%lld,avg_ttl=%lld\\r\\n\",\n                    j, keys, vkeys, server.db[j].avg_ttl);\n            }\n        }\n    }\n\n    /* Get info from modules.\n     * if user asked for \"everything\" or \"modules\", or a specific section\n     * that's not found yet. */\n    if (everything || modules ||\n        (!allsections && !defsections && sections==0)) {\n        info = modulesCollectInfo(info,\n                                  everything || modules ? NULL: section,\n                                  0, /* not a crash report */\n                                  sections);\n    }\n    return info;\n}\n\nvoid infoCommand(client *c) {\n    char *section = c->argc == 2 ? c->argv[1]->ptr : \"default\";\n\n    if (c->argc > 2) {\n        addReply(c,shared.syntaxerr);\n        return;\n    }\n    sds info = genRedisInfoString(section);\n    addReplyVerbatim(c,info,sdslen(info),\"txt\");\n    sdsfree(info);\n}\n\nvoid monitorCommand(client *c) {\n    /* ignore MONITOR if already slave or in monitor mode */\n    if (c->flags & CLIENT_SLAVE) return;\n\n    c->flags |= (CLIENT_SLAVE|CLIENT_MONITOR);\n    listAddNodeTail(server.monitors,c);\n    addReply(c,shared.ok);\n}\n\n/* =================================== Main! ================================ */\n\nint checkIgnoreWarning(const char *warning) {\n    int argc, j;\n    sds *argv = sdssplitargs(server.ignore_warnings, &argc);\n    if (argv == NULL)\n        return 0;\n\n    for (j = 0; j < argc; j++) {\n        char *flag = argv[j];\n        if (!strcasecmp(flag, warning))\n            break;\n    }\n    sdsfreesplitres(argv,argc);\n    return j < argc;\n}\n\n#ifdef __linux__\nint linuxOvercommitMemoryValue(void) {\n    FILE *fp = fopen(\"/proc/sys/vm/overcommit_memory\",\"r\");\n    char buf[64];\n\n    if (!fp) return -1;\n    if (fgets(buf,64,fp) == NULL) {\n        fclose(fp);\n        return -1;\n    }\n    fclose(fp);\n\n    return atoi(buf);\n}\n\nvoid linuxMemoryWarnings(void) {\n    if (linuxOvercommitMemoryValue() == 0) {\n        serverLog(LL_WARNING,\"WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add 'vm.overcommit_memory = 1' to /etc/sysctl.conf and then reboot or run the command 'sysctl vm.overcommit_memory=1' for this to take effect.\");\n    }\n    if (THPIsEnabled()) {\n        serverLog(LL_WARNING,\"WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command 'echo madvise > /sys/kernel/mm/transparent_hugepage/enabled' as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled (set to 'madvise' or 'never').\");\n    }\n}\n\n#ifdef __arm64__\n\n/* Get size in kilobytes of the Shared_Dirty pages of the calling process for the\n * memory map corresponding to the provided address, or -1 on error. */\nstatic int smapsGetSharedDirty(unsigned long addr) {\n    int ret, in_mapping = 0, val = -1;\n    unsigned long from, to;\n    char buf[64];\n    FILE *f;\n\n    f = fopen(\"/proc/self/smaps\", \"r\");\n    if (!f) return -1;\n\n    while (1) {\n        if (!fgets(buf, sizeof(buf), f))\n            break;\n\n        ret = sscanf(buf, \"%lx-%lx\", &from, &to);\n        if (ret == 2)\n            in_mapping = from <= addr && addr < to;\n\n        if (in_mapping && !memcmp(buf, \"Shared_Dirty:\", 13)) {\n            sscanf(buf, \"%*s %d\", &val);\n            /* If parsing fails, we remain with val == -1 */\n            break;\n        }\n    }\n\n    fclose(f);\n    return val;\n}\n\n/* Older arm64 Linux kernels have a bug that could lead to data corruption\n * during background save in certain scenarios. This function checks if the\n * kernel is affected.\n * The bug was fixed in commit ff1712f953e27f0b0718762ec17d0adb15c9fd0b\n * titled: \"arm64: pgtable: Ensure dirty bit is preserved across pte_wrprotect()\"\n * Return -1 on unexpected test failure, 1 if the kernel seems to be affected,\n * and 0 otherwise. */\nint linuxMadvFreeForkBugCheck(void) {\n    int ret, pipefd[2] = { -1, -1 };\n    pid_t pid;\n    char *p = NULL, *q;\n    int bug_found = 0;\n    long page_size = sysconf(_SC_PAGESIZE);\n    long map_size = 3 * page_size;\n\n    /* Create a memory map that's in our full control (not one used by the allocator). */\n    p = mmap(NULL, map_size, PROT_READ, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);\n    if (p == MAP_FAILED) {\n        serverLog(LL_WARNING, \"Failed to mmap(): %s\", strerror(errno));\n        return -1;\n    }\n\n    q = p + page_size;\n\n    /* Split the memory map in 3 pages by setting their protection as RO|RW|RO to prevent\n     * Linux from merging this memory map with adjacent VMAs. */\n    ret = mprotect(q, page_size, PROT_READ | PROT_WRITE);\n    if (ret < 0) {\n        serverLog(LL_WARNING, \"Failed to mprotect(): %s\", strerror(errno));\n        bug_found = -1;\n        goto exit;\n    }\n\n    /* Write to the page once to make it resident */\n    *(volatile char*)q = 0;\n\n    /* Tell the kernel that this page is free to be reclaimed. */\n#ifndef MADV_FREE\n#define MADV_FREE 8\n#endif\n    ret = madvise(q, page_size, MADV_FREE);\n    if (ret < 0) {\n        /* MADV_FREE is not available on older kernels that are presumably\n         * not affected. */\n        if (errno == EINVAL) goto exit;\n\n        serverLog(LL_WARNING, \"Failed to madvise(): %s\", strerror(errno));\n        bug_found = -1;\n        goto exit;\n    }\n\n    /* Write to the page after being marked for freeing, this is supposed to take\n     * ownership of that page again. */\n    *(volatile char*)q = 0;\n\n    /* Create a pipe for the child to return the info to the parent. */\n    ret = pipe(pipefd);\n    if (ret < 0) {\n        serverLog(LL_WARNING, \"Failed to create pipe: %s\", strerror(errno));\n        bug_found = -1;\n        goto exit;\n    }\n\n    /* Fork the process. */\n    pid = fork();\n    if (pid < 0) {\n        serverLog(LL_WARNING, \"Failed to fork: %s\", strerror(errno));\n        bug_found = -1;\n        goto exit;\n    } else if (!pid) {\n        /* Child: check if the page is marked as dirty, page_size in kb.\n         * A value of 0 means the kernel is affected by the bug. */\n        ret = smapsGetSharedDirty((unsigned long) q);\n        if (!ret)\n            bug_found = 1;\n        else if (ret == -1)     /* Failed to read */\n            bug_found = -1;\n\n        if (write(pipefd[1], &bug_found, sizeof(bug_found)) < 0)\n            serverLog(LL_WARNING, \"Failed to write to parent: %s\", strerror(errno));\n        exit(0);\n    } else {\n        /* Read the result from the child. */\n        ret = read(pipefd[0], &bug_found, sizeof(bug_found));\n        if (ret < 0) {\n            serverLog(LL_WARNING, \"Failed to read from child: %s\", strerror(errno));\n            bug_found = -1;\n        }\n\n        /* Reap the child pid. */\n        waitpid(pid, NULL, 0);\n    }\n\nexit:\n    /* Cleanup */\n    if (pipefd[0] != -1) close(pipefd[0]);\n    if (pipefd[1] != -1) close(pipefd[1]);\n    if (p != NULL) munmap(p, map_size);\n\n    return bug_found;\n}\n#endif /* __arm64__ */\n#endif /* __linux__ */\n\nvoid createPidFile(void) {\n    /* If pidfile requested, but no pidfile defined, use\n     * default pidfile path */\n    if (!server.pidfile) server.pidfile = zstrdup(CONFIG_DEFAULT_PID_FILE);\n\n    /* Try to write the pid file in a best-effort way. */\n    FILE *fp = fopen(server.pidfile,\"w\");\n    if (fp) {\n        fprintf(fp,\"%d\\n\",(int)getpid());\n        fclose(fp);\n    }\n}\n\nvoid daemonize(void) {\n    int fd;\n\n    if (fork() != 0) exit(0); /* parent exits */\n    setsid(); /* create a new session */\n\n    /* Every output goes to /dev/null. If Redis is daemonized but\n     * the 'logfile' is set to 'stdout' in the configuration file\n     * it will not log at all. */\n    if ((fd = open(\"/dev/null\", O_RDWR, 0)) != -1) {\n        dup2(fd, STDIN_FILENO);\n        dup2(fd, STDOUT_FILENO);\n        dup2(fd, STDERR_FILENO);\n        if (fd > STDERR_FILENO) close(fd);\n    }\n}\n\nvoid version(void) {\n    printf(\"Redis server v=%s sha=%s:%d malloc=%s bits=%d build=%llx\\n\",\n        REDIS_VERSION,\n        redisGitSHA1(),\n        atoi(redisGitDirty()) > 0,\n        ZMALLOC_LIB,\n        sizeof(long) == 4 ? 32 : 64,\n        (unsigned long long) redisBuildId());\n    exit(0);\n}\n\nvoid usage(void) {\n    fprintf(stderr,\"Usage: ./redis-server [/path/to/redis.conf] [options]\\n\");\n    fprintf(stderr,\"       ./redis-server - (read config from stdin)\\n\");\n    fprintf(stderr,\"       ./redis-server -v or --version\\n\");\n    fprintf(stderr,\"       ./redis-server -h or --help\\n\");\n    fprintf(stderr,\"       ./redis-server --test-memory <megabytes>\\n\\n\");\n    fprintf(stderr,\"Examples:\\n\");\n    fprintf(stderr,\"       ./redis-server (run the server with default conf)\\n\");\n    fprintf(stderr,\"       ./redis-server /etc/redis/6379.conf\\n\");\n    fprintf(stderr,\"       ./redis-server --port 7777\\n\");\n    fprintf(stderr,\"       ./redis-server --port 7777 --replicaof 127.0.0.1 8888\\n\");\n    fprintf(stderr,\"       ./redis-server /etc/myredis.conf --loglevel verbose\\n\\n\");\n    fprintf(stderr,\"Sentinel mode:\\n\");\n    fprintf(stderr,\"       ./redis-server /etc/sentinel.conf --sentinel\\n\");\n    exit(1);\n}\n\nvoid redisAsciiArt(void) {\n#include \"asciilogo.h\"\n    char *buf = zmalloc(1024*16);\n    char *mode;\n\n    if (server.cluster_enabled) mode = \"cluster\";\n    else if (server.sentinel_mode) mode = \"sentinel\";\n    else mode = \"standalone\";\n\n    /* Show the ASCII logo if: log file is stdout AND stdout is a\n     * tty AND syslog logging is disabled. Also show logo if the user\n     * forced us to do so via redis.conf. */\n    int show_logo = ((!server.syslog_enabled &&\n                      server.logfile[0] == '\\0' &&\n                      isatty(fileno(stdout))) ||\n                     server.always_show_logo);\n\n    if (!show_logo) {\n        serverLog(LL_NOTICE,\n            \"Running mode=%s, port=%d.\",\n            mode, server.port ? server.port : server.tls_port\n        );\n    } else {\n        snprintf(buf,1024*16,ascii_logo,\n            REDIS_VERSION,\n            redisGitSHA1(),\n            strtol(redisGitDirty(),NULL,10) > 0,\n            (sizeof(long) == 8) ? \"64\" : \"32\",\n            mode, server.port ? server.port : server.tls_port,\n            (long) getpid()\n        );\n        serverLogRaw(LL_NOTICE|LL_RAW,buf);\n    }\n    zfree(buf);\n}\n\nstatic void sigShutdownHandler(int sig) {\n    char *msg;\n\n    switch (sig) {\n    case SIGINT:\n        msg = \"Received SIGINT scheduling shutdown...\";\n        break;\n    case SIGTERM:\n        msg = \"Received SIGTERM scheduling shutdown...\";\n        break;\n    default:\n        msg = \"Received shutdown signal, scheduling shutdown...\";\n    };\n\n    /* SIGINT is often delivered via Ctrl+C in an interactive session.\n     * If we receive the signal the second time, we interpret this as\n     * the user really wanting to quit ASAP without waiting to persist\n     * on disk. */\n    if (server.shutdown_asap && sig == SIGINT) {\n        serverLogFromHandler(LL_WARNING, \"You insist... exiting now.\");\n        rdbRemoveTempFile(getpid(), 1);\n        exit(1); /* Exit with an error since this was not a clean shutdown. */\n    } else if (server.loading) {\n        serverLogFromHandler(LL_WARNING, \"Received shutdown signal during loading, exiting now.\");\n        exit(0);\n    }\n\n    serverLogFromHandler(LL_WARNING, msg);\n    server.shutdown_asap = 1;\n}\n\nvoid setupSignalHandlers(void) {\n    struct sigaction act;\n\n    /* When the SA_SIGINFO flag is set in sa_flags then sa_sigaction is used.\n     * Otherwise, sa_handler is used. */\n    sigemptyset(&act.sa_mask);\n    act.sa_flags = 0;\n    act.sa_handler = sigShutdownHandler;\n    sigaction(SIGTERM, &act, NULL);\n    sigaction(SIGINT, &act, NULL);\n\n#ifdef HAVE_BACKTRACE\n    sigemptyset(&act.sa_mask);\n    act.sa_flags = SA_NODEFER | SA_RESETHAND | SA_SIGINFO;\n    act.sa_sigaction = sigsegvHandler;\n    sigaction(SIGSEGV, &act, NULL);\n    sigaction(SIGBUS, &act, NULL);\n    sigaction(SIGFPE, &act, NULL);\n    sigaction(SIGILL, &act, NULL);\n#endif\n    return;\n}\n\n/* This is the signal handler for children process. It is currently useful\n * in order to track the SIGUSR1, that we send to a child in order to terminate\n * it in a clean way, without the parent detecting an error and stop\n * accepting writes because of a write error condition. */\nstatic void sigKillChildHandler(int sig) {\n    UNUSED(sig);\n    int level = server.in_fork_child == CHILD_TYPE_MODULE? LL_VERBOSE: LL_WARNING;\n    serverLogFromHandler(level, \"Received SIGUSR1 in child, exiting now.\");\n    exitFromChild(SERVER_CHILD_NOERROR_RETVAL);\n}\n\nvoid setupChildSignalHandlers(void) {\n    struct sigaction act;\n\n    /* When the SA_SIGINFO flag is set in sa_flags then sa_sigaction is used.\n     * Otherwise, sa_handler is used. */\n    sigemptyset(&act.sa_mask);\n    act.sa_flags = 0;\n    act.sa_handler = sigKillChildHandler;\n    sigaction(SIGUSR1, &act, NULL);\n    return;\n}\n\n/* After fork, the child process will inherit the resources\n * of the parent process, e.g. fd(socket or flock) etc.\n * should close the resources not used by the child process, so that if the\n * parent restarts it can bind/lock despite the child possibly still running. */\nvoid closeClildUnusedResourceAfterFork() {\n    closeListeningSockets(0);\n    if (server.cluster_enabled && server.cluster_config_file_lock_fd != -1)\n        close(server.cluster_config_file_lock_fd);  /* don't care if this fails */\n\n    /* Clear server.pidfile, this is the parent pidfile which should not\n     * be touched (or deleted) by the child (on exit / crash) */\n    zfree(server.pidfile);\n    server.pidfile = NULL;\n}\n\n/* purpose is one of CHILD_TYPE_ types */\nint redisFork(int purpose) {\n    int childpid;\n    long long start = ustime();\n    if ((childpid = fork()) == 0) {\n        /* Child */\n        server.in_fork_child = purpose;\n        setOOMScoreAdj(CONFIG_OOM_BGCHILD);\n        setupChildSignalHandlers();\n        closeClildUnusedResourceAfterFork();\n    } else {\n        /* Parent */\n        server.stat_fork_time = ustime()-start;\n        server.stat_fork_rate = (double) zmalloc_used_memory() * 1000000 / server.stat_fork_time / (1024*1024*1024); /* GB per second. */\n        latencyAddSampleIfNeeded(\"fork\",server.stat_fork_time/1000);\n        if (childpid == -1) {\n            return -1;\n        }\n    }\n    return childpid;\n}\n\nvoid sendChildCOWInfo(int ptype, char *pname) {\n    size_t private_dirty = zmalloc_get_private_dirty(-1);\n\n    if (private_dirty) {\n        serverLog(LL_NOTICE,\n            \"%s: %zu MB of memory used by copy-on-write\",\n            pname, private_dirty/(1024*1024));\n    }\n\n    server.child_info_data.cow_size = private_dirty;\n    sendChildInfo(ptype);\n}\n\nvoid memtest(size_t megabytes, int passes);\n\n/* Returns 1 if there is --sentinel among the arguments or if\n * argv[0] contains \"redis-sentinel\". */\nint checkForSentinelMode(int argc, char **argv) {\n    int j;\n\n    if (strstr(argv[0],\"redis-sentinel\") != NULL) return 1;\n    for (j = 1; j < argc; j++)\n        if (!strcmp(argv[j],\"--sentinel\")) return 1;\n    return 0;\n}\n\n/* Function called at startup to load RDB or AOF file in memory. */\nvoid loadDataFromDisk(void) {\n    long long start = ustime();\n    if (server.aof_state == AOF_ON) {\n        if (loadAppendOnlyFile(server.aof_filename) == C_OK)\n            serverLog(LL_NOTICE,\"DB loaded from append only file: %.3f seconds\",(float)(ustime()-start)/1000000);\n    } else {\n        rdbSaveInfo rsi = RDB_SAVE_INFO_INIT;\n        errno = 0; /* Prevent a stale value from affecting error checking */\n        if (rdbLoad(server.rdb_filename,&rsi,RDBFLAGS_NONE) == C_OK) {\n            serverLog(LL_NOTICE,\"DB loaded from disk: %.3f seconds\",\n                (float)(ustime()-start)/1000000);\n\n            /* Restore the replication ID / offset from the RDB file. */\n            if ((server.masterhost ||\n                (server.cluster_enabled &&\n                nodeIsSlave(server.cluster->myself))) &&\n                rsi.repl_id_is_set &&\n                rsi.repl_offset != -1 &&\n                /* Note that older implementations may save a repl_stream_db\n                 * of -1 inside the RDB file in a wrong way, see more\n                 * information in function rdbPopulateSaveInfo. */\n                rsi.repl_stream_db != -1)\n            {\n                memcpy(server.replid,rsi.repl_id,sizeof(server.replid));\n                server.master_repl_offset = rsi.repl_offset;\n                /* If we are a slave, create a cached master from this\n                 * information, in order to allow partial resynchronizations\n                 * with masters. */\n                replicationCacheMasterUsingMyself();\n                selectDb(server.cached_master,rsi.repl_stream_db);\n            }\n        } else if (errno != ENOENT) {\n            serverLog(LL_WARNING,\"Fatal error loading the DB: %s. Exiting.\",strerror(errno));\n            exit(1);\n        }\n    }\n}\n\nvoid redisOutOfMemoryHandler(size_t allocation_size) {\n    serverLog(LL_WARNING,\"Out Of Memory allocating %zu bytes!\",\n        allocation_size);\n    serverPanic(\"Redis aborting for OUT OF MEMORY. Allocating %zu bytes!\", \n        allocation_size);\n}\n\nvoid redisSetProcTitle(char *title) {\n#ifdef USE_SETPROCTITLE\n    char *server_mode = \"\";\n    if (server.cluster_enabled) server_mode = \" [cluster]\";\n    else if (server.sentinel_mode) server_mode = \" [sentinel]\";\n\n    setproctitle(\"%s %s:%d%s\",\n        title,\n        server.bindaddr_count ? server.bindaddr[0] : \"*\",\n        server.port ? server.port : server.tls_port,\n        server_mode);\n#else\n    UNUSED(title);\n#endif\n}\n\nvoid redisSetCpuAffinity(const char *cpulist) {\n#ifdef USE_SETCPUAFFINITY\n    setcpuaffinity(cpulist);\n#else\n    UNUSED(cpulist);\n#endif\n}\n\n/*\n * Check whether systemd or upstart have been used to start redis.\n */\n\nint redisSupervisedUpstart(void) {\n    const char *upstart_job = getenv(\"UPSTART_JOB\");\n\n    if (!upstart_job) {\n        serverLog(LL_WARNING,\n                \"upstart supervision requested, but UPSTART_JOB not found\");\n        return 0;\n    }\n\n    serverLog(LL_NOTICE, \"supervised by upstart, will stop to signal readiness\");\n    raise(SIGSTOP);\n    unsetenv(\"UPSTART_JOB\");\n    return 1;\n}\n\nint redisCommunicateSystemd(const char *sd_notify_msg) {\n    const char *notify_socket = getenv(\"NOTIFY_SOCKET\");\n    if (!notify_socket) {\n        serverLog(LL_WARNING,\n                \"systemd supervision requested, but NOTIFY_SOCKET not found\");\n    }\n\n    #ifdef HAVE_LIBSYSTEMD\n    (void) sd_notify(0, sd_notify_msg);\n    #else\n    UNUSED(sd_notify_msg);\n    #endif\n    return 0;\n}\n\nint redisIsSupervised(int mode) {\n    if (mode == SUPERVISED_AUTODETECT) {\n        const char *upstart_job = getenv(\"UPSTART_JOB\");\n        const char *notify_socket = getenv(\"NOTIFY_SOCKET\");\n\n        if (upstart_job) {\n            redisSupervisedUpstart();\n        } else if (notify_socket) {\n            server.supervised_mode = SUPERVISED_SYSTEMD;\n            serverLog(LL_WARNING,\n                \"WARNING auto-supervised by systemd - you MUST set appropriate values for TimeoutStartSec and TimeoutStopSec in your service unit.\");\n            return redisCommunicateSystemd(\"STATUS=Redis is loading...\\n\");\n        }\n    } else if (mode == SUPERVISED_UPSTART) {\n        return redisSupervisedUpstart();\n    } else if (mode == SUPERVISED_SYSTEMD) {\n        serverLog(LL_WARNING,\n            \"WARNING supervised by systemd - you MUST set appropriate values for TimeoutStartSec and TimeoutStopSec in your service unit.\");\n        return redisCommunicateSystemd(\"STATUS=Redis is loading...\\n\");\n    }\n\n    return 0;\n}\n\nint iAmMaster(void) {\n    return ((!server.cluster_enabled && server.masterhost == NULL) ||\n            (server.cluster_enabled && nodeIsMaster(server.cluster->myself)));\n}\n\nint main(int argc, char **argv) {\n    struct timeval tv;\n    int j;\n\n#ifdef REDIS_TEST\n    if (argc == 3 && !strcasecmp(argv[1], \"test\")) {\n        if (!strcasecmp(argv[2], \"ziplist\")) {\n            return ziplistTest(argc, argv);\n        } else if (!strcasecmp(argv[2], \"quicklist\")) {\n            quicklistTest(argc, argv);\n        } else if (!strcasecmp(argv[2], \"intset\")) {\n            return intsetTest(argc, argv);\n        } else if (!strcasecmp(argv[2], \"zipmap\")) {\n            return zipmapTest(argc, argv);\n        } else if (!strcasecmp(argv[2], \"sha1test\")) {\n            return sha1Test(argc, argv);\n        } else if (!strcasecmp(argv[2], \"util\")) {\n            return utilTest(argc, argv);\n        } else if (!strcasecmp(argv[2], \"endianconv\")) {\n            return endianconvTest(argc, argv);\n        } else if (!strcasecmp(argv[2], \"crc64\")) {\n            return crc64Test(argc, argv);\n        } else if (!strcasecmp(argv[2], \"zmalloc\")) {\n            return zmalloc_test(argc, argv);\n        }\n\n        return -1; /* test not found */\n    }\n#endif\n\n    /* We need to initialize our libraries, and the server configuration. */\n#ifdef INIT_SETPROCTITLE_REPLACEMENT\n    spt_init(argc, argv);\n#endif\n    setlocale(LC_COLLATE,\"\");\n    tzset(); /* Populates 'timezone' global. */\n    zmalloc_set_oom_handler(redisOutOfMemoryHandler);\n    srand(time(NULL)^getpid());\n    gettimeofday(&tv,NULL);\n    init_genrand64(((long long) tv.tv_sec * 1000000 + tv.tv_usec) ^ getpid());\n    crc64_init();\n\n    /* Store umask value. Because umask(2) only offers a set-and-get API we have\n     * to reset it and restore it back. We do this early to avoid a potential\n     * race condition with threads that could be creating files or directories.\n     */\n    umask(server.umask = umask(0777));\n\n    uint8_t hashseed[16];\n    getRandomBytes(hashseed,sizeof(hashseed));\n    dictSetHashFunctionSeed(hashseed);\n    server.sentinel_mode = checkForSentinelMode(argc,argv);\n    initServerConfig();\n    ACLInit(); /* The ACL subsystem must be initialized ASAP because the\n                  basic networking code and client creation depends on it. */\n    moduleInitModulesSystem();\n    tlsInit();\n\n    /* Store the executable path and arguments in a safe place in order\n     * to be able to restart the server later. */\n    server.executable = getAbsolutePath(argv[0]);\n    server.exec_argv = zmalloc(sizeof(char*)*(argc+1));\n    server.exec_argv[argc] = NULL;\n    for (j = 0; j < argc; j++) server.exec_argv[j] = zstrdup(argv[j]);\n\n    /* We need to init sentinel right now as parsing the configuration file\n     * in sentinel mode will have the effect of populating the sentinel\n     * data structures with master nodes to monitor. */\n    if (server.sentinel_mode) {\n        initSentinelConfig();\n        initSentinel();\n    }\n\n    /* Check if we need to start in redis-check-rdb/aof mode. We just execute\n     * the program main. However the program is part of the Redis executable\n     * so that we can easily execute an RDB check on loading errors. */\n    if (strstr(argv[0],\"redis-check-rdb\") != NULL)\n        redis_check_rdb_main(argc,argv,NULL);\n    else if (strstr(argv[0],\"redis-check-aof\") != NULL)\n        redis_check_aof_main(argc,argv);\n\n    if (argc >= 2) {\n        j = 1; /* First option to parse in argv[] */\n        sds options = sdsempty();\n        char *configfile = NULL;\n\n        /* Handle special options --help and --version */\n        if (strcmp(argv[1], \"-v\") == 0 ||\n            strcmp(argv[1], \"--version\") == 0) version();\n        if (strcmp(argv[1], \"--help\") == 0 ||\n            strcmp(argv[1], \"-h\") == 0) usage();\n        if (strcmp(argv[1], \"--test-memory\") == 0) {\n            if (argc == 3) {\n                memtest(atoi(argv[2]),50);\n                exit(0);\n            } else {\n                fprintf(stderr,\"Please specify the amount of memory to test in megabytes.\\n\");\n                fprintf(stderr,\"Example: ./redis-server --test-memory 4096\\n\\n\");\n                exit(1);\n            }\n        }\n\n        /* First argument is the config file name? */\n        if (argv[j][0] != '-' || argv[j][1] != '-') {\n            configfile = argv[j];\n            server.configfile = getAbsolutePath(configfile);\n            /* Replace the config file in server.exec_argv with\n             * its absolute path. */\n            zfree(server.exec_argv[j]);\n            server.exec_argv[j] = zstrdup(server.configfile);\n            j++;\n        }\n\n        /* All the other options are parsed and conceptually appended to the\n         * configuration file. For instance --port 6380 will generate the\n         * string \"port 6380\\n\" to be parsed after the actual file name\n         * is parsed, if any. */\n        while(j != argc) {\n            if (argv[j][0] == '-' && argv[j][1] == '-') {\n                /* Option name */\n                if (!strcmp(argv[j], \"--check-rdb\")) {\n                    /* Argument has no options, need to skip for parsing. */\n                    j++;\n                    continue;\n                }\n                if (sdslen(options)) options = sdscat(options,\"\\n\");\n                options = sdscat(options,argv[j]+2);\n                options = sdscat(options,\" \");\n            } else {\n                /* Option argument */\n                options = sdscatrepr(options,argv[j],strlen(argv[j]));\n                options = sdscat(options,\" \");\n            }\n            j++;\n        }\n        if (server.sentinel_mode && configfile && *configfile == '-') {\n            serverLog(LL_WARNING,\n                \"Sentinel config from STDIN not allowed.\");\n            serverLog(LL_WARNING,\n                \"Sentinel needs config file on disk to save state.  Exiting...\");\n            exit(1);\n        }\n        resetServerSaveParams();\n        loadServerConfig(configfile,options);\n        sdsfree(options);\n    }\n\n    server.supervised = redisIsSupervised(server.supervised_mode);\n    int background = server.daemonize && !server.supervised;\n    if (background) daemonize();\n\n    serverLog(LL_WARNING, \"oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo\");\n    serverLog(LL_WARNING,\n        \"Redis version=%s, bits=%d, commit=%s, modified=%d, pid=%d, just started\",\n            REDIS_VERSION,\n            (sizeof(long) == 8) ? 64 : 32,\n            redisGitSHA1(),\n            strtol(redisGitDirty(),NULL,10) > 0,\n            (int)getpid());\n\n    if (argc == 1) {\n        serverLog(LL_WARNING, \"Warning: no config file specified, using the default config. In order to specify a config file use %s /path/to/%s.conf\", argv[0], server.sentinel_mode ? \"sentinel\" : \"redis\");\n    } else {\n        serverLog(LL_WARNING, \"Configuration loaded\");\n    }\n\n    readOOMScoreAdj();\n    initServer();\n    if (background || server.pidfile) createPidFile();\n    redisSetProcTitle(argv[0]);\n    redisAsciiArt();\n    checkTcpBacklogSettings();\n\n    if (!server.sentinel_mode) {\n        /* Things not needed when running in Sentinel mode. */\n        serverLog(LL_WARNING,\"Server initialized\");\n    #ifdef __linux__\n        linuxMemoryWarnings();\n    #if defined (__arm64__)\n        int ret;\n        if ((ret = linuxMadvFreeForkBugCheck())) {\n            if (ret == 1)\n                serverLog(LL_WARNING,\"WARNING Your kernel has a bug that could lead to data corruption during background save. \"\n                                     \"Please upgrade to the latest stable kernel.\");\n            else\n                serverLog(LL_WARNING, \"Failed to test the kernel for a bug that could lead to data corruption during background save. \"\n                                      \"Your system could be affected, please report this error.\");\n            if (!checkIgnoreWarning(\"ARM64-COW-BUG\")) {\n                serverLog(LL_WARNING,\"Redis will now exit to prevent data corruption. \"\n                                     \"Note that it is possible to suppress this warning by setting the following config: ignore-warnings ARM64-COW-BUG\");\n                exit(1);\n            }\n        }\n    #endif /* __arm64__ */\n    #endif /* __linux__ */\n        moduleLoadFromQueue();\n        ACLLoadUsersAtStartup();\n        InitServerLast();\n        loadDataFromDisk();\n        if (server.cluster_enabled) {\n            if (verifyClusterConfigWithData() == C_ERR) {\n                serverLog(LL_WARNING,\n                    \"You can't have keys in a DB different than DB 0 when in \"\n                    \"Cluster mode. Exiting.\");\n                exit(1);\n            }\n        }\n        if (server.ipfd_count > 0 || server.tlsfd_count > 0)\n            serverLog(LL_NOTICE,\"Ready to accept connections\");\n        if (server.sofd > 0)\n            serverLog(LL_NOTICE,\"The server is now ready to accept connections at %s\", server.unixsocket);\n        if (server.supervised_mode == SUPERVISED_SYSTEMD) {\n            if (!server.masterhost) {\n                redisCommunicateSystemd(\"STATUS=Ready to accept connections\\n\");\n                redisCommunicateSystemd(\"READY=1\\n\");\n            } else {\n                redisCommunicateSystemd(\"STATUS=Waiting for MASTER <-> REPLICA sync\\n\");\n            }\n        }\n    } else {\n        InitServerLast();\n        sentinelIsRunning();\n        if (server.supervised_mode == SUPERVISED_SYSTEMD) {\n            redisCommunicateSystemd(\"STATUS=Ready to accept connections\\n\");\n            redisCommunicateSystemd(\"READY=1\\n\");\n        }\n    }\n\n    /* Warning the user about suspicious maxmemory setting. */\n    if (server.maxmemory > 0 && server.maxmemory < 1024*1024) {\n        serverLog(LL_WARNING,\"WARNING: You specified a maxmemory value that is less than 1MB (current value is %llu bytes). Are you sure this is what you really want?\", server.maxmemory);\n    }\n\n    redisSetCpuAffinity(server.server_cpulist);\n    setOOMScoreAdj(-1);\n\n    aeMain(server.el);\n    aeDeleteEventLoop(server.el);\n    return 0;\n}\n\n/* The End */\n", "/*\n * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef __REDIS_H\n#define __REDIS_H\n\n#include \"fmacros.h\"\n#include \"config.h\"\n#include \"solarisfixes.h\"\n#include \"rio.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <limits.h>\n#include <unistd.h>\n#include <errno.h>\n#include <inttypes.h>\n#include <pthread.h>\n#include <syslog.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <lua.h>\n#include <signal.h>\n\n#ifdef HAVE_LIBSYSTEMD\n#include <systemd/sd-daemon.h>\n#endif\n\ntypedef long long mstime_t; /* millisecond time type. */\ntypedef long long ustime_t; /* microsecond time type. */\n\n#include \"ae.h\"      /* Event driven programming library */\n#include \"sds.h\"     /* Dynamic safe strings */\n#include \"dict.h\"    /* Hash tables */\n#include \"adlist.h\"  /* Linked lists */\n#include \"zmalloc.h\" /* total memory usage aware version of malloc/free */\n#include \"anet.h\"    /* Networking the easy way */\n#include \"ziplist.h\" /* Compact list data structure */\n#include \"intset.h\"  /* Compact integer set structure */\n#include \"version.h\" /* Version macro */\n#include \"util.h\"    /* Misc functions useful in many places */\n#include \"latency.h\" /* Latency monitor API */\n#include \"sparkline.h\" /* ASCII graphs API */\n#include \"quicklist.h\"  /* Lists are encoded as linked lists of\n                           N-elements flat arrays */\n#include \"rax.h\"     /* Radix tree */\n#include \"connection.h\" /* Connection abstraction */\n\n#define REDISMODULE_CORE 1\n#include \"redismodule.h\"    /* Redis modules API defines. */\n\n/* Following includes allow test functions to be called from Redis main() */\n#include \"zipmap.h\"\n#include \"sha1.h\"\n#include \"endianconv.h\"\n#include \"crc64.h\"\n\n/* Error codes */\n#define C_OK                    0\n#define C_ERR                   -1\n\n/* Static server configuration */\n#define CONFIG_DEFAULT_HZ        10             /* Time interrupt calls/sec. */\n#define CONFIG_MIN_HZ            1\n#define CONFIG_MAX_HZ            500\n#define MAX_CLIENTS_PER_CLOCK_TICK 200          /* HZ is adapted based on that. */\n#define CONFIG_MAX_LINE    1024\n#define CRON_DBS_PER_CALL 16\n#define NET_MAX_WRITES_PER_EVENT (1024*64)\n#define PROTO_SHARED_SELECT_CMDS 10\n#define OBJ_SHARED_INTEGERS 10000\n#define OBJ_SHARED_BULKHDR_LEN 32\n#define LOG_MAX_LEN    1024 /* Default maximum length of syslog messages.*/\n#define AOF_REWRITE_ITEMS_PER_CMD 64\n#define AOF_READ_DIFF_INTERVAL_BYTES (1024*10)\n#define CONFIG_AUTHPASS_MAX_LEN 512\n#define CONFIG_RUN_ID_SIZE 40\n#define RDB_EOF_MARK_SIZE 40\n#define CONFIG_REPL_BACKLOG_MIN_SIZE (1024*16)          /* 16k */\n#define CONFIG_BGSAVE_RETRY_DELAY 5 /* Wait a few secs before trying again. */\n#define CONFIG_DEFAULT_PID_FILE \"/var/run/redis.pid\"\n#define CONFIG_DEFAULT_CLUSTER_CONFIG_FILE \"nodes.conf\"\n#define CONFIG_DEFAULT_UNIX_SOCKET_PERM 0\n#define CONFIG_DEFAULT_LOGFILE \"\"\n#define NET_IP_STR_LEN 46 /* INET6_ADDRSTRLEN is 46, but we need to be sure */\n#define NET_PEER_ID_LEN (NET_IP_STR_LEN+32) /* Must be enough for ip:port */\n#define CONFIG_BINDADDR_MAX 16\n#define CONFIG_MIN_RESERVED_FDS 32\n\n#define ACTIVE_EXPIRE_CYCLE_SLOW 0\n#define ACTIVE_EXPIRE_CYCLE_FAST 1\n\n/* Children process will exit with this status code to signal that the\n * process terminated without an error: this is useful in order to kill\n * a saving child (RDB or AOF one), without triggering in the parent the\n * write protection that is normally turned on on write errors.\n * Usually children that are terminated with SIGUSR1 will exit with this\n * special code. */\n#define SERVER_CHILD_NOERROR_RETVAL    255\n\n/* Instantaneous metrics tracking. */\n#define STATS_METRIC_SAMPLES 16     /* Number of samples per metric. */\n#define STATS_METRIC_COMMAND 0      /* Number of commands executed. */\n#define STATS_METRIC_NET_INPUT 1    /* Bytes read to network .*/\n#define STATS_METRIC_NET_OUTPUT 2   /* Bytes written to network. */\n#define STATS_METRIC_COUNT 3\n\n/* Protocol and I/O related defines */\n#define PROTO_MAX_QUERYBUF_LEN  (1024*1024*1024) /* 1GB max query buffer. */\n#define PROTO_IOBUF_LEN         (1024*16)  /* Generic I/O buffer size */\n#define PROTO_REPLY_CHUNK_BYTES (16*1024) /* 16k output buffer */\n#define PROTO_INLINE_MAX_SIZE   (1024*64) /* Max size of inline reads */\n#define PROTO_MBULK_BIG_ARG     (1024*32)\n#define LONG_STR_SIZE      21          /* Bytes needed for long -> str + '\\0' */\n#define REDIS_AUTOSYNC_BYTES (1024*1024*32) /* fdatasync every 32MB */\n\n#define LIMIT_PENDING_QUERYBUF (4*1024*1024) /* 4mb */\n\n/* When configuring the server eventloop, we setup it so that the total number\n * of file descriptors we can handle are server.maxclients + RESERVED_FDS +\n * a few more to stay safe. Since RESERVED_FDS defaults to 32, we add 96\n * in order to make sure of not over provisioning more than 128 fds. */\n#define CONFIG_FDSET_INCR (CONFIG_MIN_RESERVED_FDS+96)\n\n/* OOM Score Adjustment classes. */\n#define CONFIG_OOM_MASTER 0\n#define CONFIG_OOM_REPLICA 1\n#define CONFIG_OOM_BGCHILD 2\n#define CONFIG_OOM_COUNT 3\n\nextern int configOOMScoreAdjValuesDefaults[CONFIG_OOM_COUNT];\n\n/* Hash table parameters */\n#define HASHTABLE_MIN_FILL        10      /* Minimal hash table fill 10% */\n\n/* Command flags. Please check the command table defined in the server.c file\n * for more information about the meaning of every flag. */\n#define CMD_WRITE (1ULL<<0)            /* \"write\" flag */\n#define CMD_READONLY (1ULL<<1)         /* \"read-only\" flag */\n#define CMD_DENYOOM (1ULL<<2)          /* \"use-memory\" flag */\n#define CMD_MODULE (1ULL<<3)           /* Command exported by module. */\n#define CMD_ADMIN (1ULL<<4)            /* \"admin\" flag */\n#define CMD_PUBSUB (1ULL<<5)           /* \"pub-sub\" flag */\n#define CMD_NOSCRIPT (1ULL<<6)         /* \"no-script\" flag */\n#define CMD_RANDOM (1ULL<<7)           /* \"random\" flag */\n#define CMD_SORT_FOR_SCRIPT (1ULL<<8)  /* \"to-sort\" flag */\n#define CMD_LOADING (1ULL<<9)          /* \"ok-loading\" flag */\n#define CMD_STALE (1ULL<<10)           /* \"ok-stale\" flag */\n#define CMD_SKIP_MONITOR (1ULL<<11)    /* \"no-monitor\" flag */\n#define CMD_SKIP_SLOWLOG (1ULL<<12)    /* \"no-slowlog\" flag */\n#define CMD_ASKING (1ULL<<13)          /* \"cluster-asking\" flag */\n#define CMD_FAST (1ULL<<14)            /* \"fast\" flag */\n#define CMD_NO_AUTH (1ULL<<15)         /* \"no-auth\" flag */\n\n/* Command flags used by the module system. */\n#define CMD_MODULE_GETKEYS (1ULL<<16)  /* Use the modules getkeys interface. */\n#define CMD_MODULE_NO_CLUSTER (1ULL<<17) /* Deny on Redis Cluster. */\n\n/* Command flags that describe ACLs categories. */\n#define CMD_CATEGORY_KEYSPACE (1ULL<<18)\n#define CMD_CATEGORY_READ (1ULL<<19)\n#define CMD_CATEGORY_WRITE (1ULL<<20)\n#define CMD_CATEGORY_SET (1ULL<<21)\n#define CMD_CATEGORY_SORTEDSET (1ULL<<22)\n#define CMD_CATEGORY_LIST (1ULL<<23)\n#define CMD_CATEGORY_HASH (1ULL<<24)\n#define CMD_CATEGORY_STRING (1ULL<<25)\n#define CMD_CATEGORY_BITMAP (1ULL<<26)\n#define CMD_CATEGORY_HYPERLOGLOG (1ULL<<27)\n#define CMD_CATEGORY_GEO (1ULL<<28)\n#define CMD_CATEGORY_STREAM (1ULL<<29)\n#define CMD_CATEGORY_PUBSUB (1ULL<<30)\n#define CMD_CATEGORY_ADMIN (1ULL<<31)\n#define CMD_CATEGORY_FAST (1ULL<<32)\n#define CMD_CATEGORY_SLOW (1ULL<<33)\n#define CMD_CATEGORY_BLOCKING (1ULL<<34)\n#define CMD_CATEGORY_DANGEROUS (1ULL<<35)\n#define CMD_CATEGORY_CONNECTION (1ULL<<36)\n#define CMD_CATEGORY_TRANSACTION (1ULL<<37)\n#define CMD_CATEGORY_SCRIPTING (1ULL<<38)\n\n/* AOF states */\n#define AOF_OFF 0             /* AOF is off */\n#define AOF_ON 1              /* AOF is on */\n#define AOF_WAIT_REWRITE 2    /* AOF waits rewrite to start appending */\n\n/* Client flags */\n#define CLIENT_SLAVE (1<<0)   /* This client is a repliaca */\n#define CLIENT_MASTER (1<<1)  /* This client is a master */\n#define CLIENT_MONITOR (1<<2) /* This client is a slave monitor, see MONITOR */\n#define CLIENT_MULTI (1<<3)   /* This client is in a MULTI context */\n#define CLIENT_BLOCKED (1<<4) /* The client is waiting in a blocking operation */\n#define CLIENT_DIRTY_CAS (1<<5) /* Watched keys modified. EXEC will fail. */\n#define CLIENT_CLOSE_AFTER_REPLY (1<<6) /* Close after writing entire reply. */\n#define CLIENT_UNBLOCKED (1<<7) /* This client was unblocked and is stored in\n                                  server.unblocked_clients */\n#define CLIENT_LUA (1<<8) /* This is a non connected client used by Lua */\n#define CLIENT_ASKING (1<<9)     /* Client issued the ASKING command */\n#define CLIENT_CLOSE_ASAP (1<<10)/* Close this client ASAP */\n#define CLIENT_UNIX_SOCKET (1<<11) /* Client connected via Unix domain socket */\n#define CLIENT_DIRTY_EXEC (1<<12)  /* EXEC will fail for errors while queueing */\n#define CLIENT_MASTER_FORCE_REPLY (1<<13)  /* Queue replies even if is master */\n#define CLIENT_FORCE_AOF (1<<14)   /* Force AOF propagation of current cmd. */\n#define CLIENT_FORCE_REPL (1<<15)  /* Force replication of current cmd. */\n#define CLIENT_PRE_PSYNC (1<<16)   /* Instance don't understand PSYNC. */\n#define CLIENT_READONLY (1<<17)    /* Cluster client is in read-only state. */\n#define CLIENT_PUBSUB (1<<18)      /* Client is in Pub/Sub mode. */\n#define CLIENT_PREVENT_AOF_PROP (1<<19)  /* Don't propagate to AOF. */\n#define CLIENT_PREVENT_REPL_PROP (1<<20)  /* Don't propagate to slaves. */\n#define CLIENT_PREVENT_PROP (CLIENT_PREVENT_AOF_PROP|CLIENT_PREVENT_REPL_PROP)\n#define CLIENT_PENDING_WRITE (1<<21) /* Client has output to send but a write\n                                        handler is yet not installed. */\n#define CLIENT_REPLY_OFF (1<<22)   /* Don't send replies to client. */\n#define CLIENT_REPLY_SKIP_NEXT (1<<23)  /* Set CLIENT_REPLY_SKIP for next cmd */\n#define CLIENT_REPLY_SKIP (1<<24)  /* Don't send just this reply. */\n#define CLIENT_LUA_DEBUG (1<<25)  /* Run EVAL in debug mode. */\n#define CLIENT_LUA_DEBUG_SYNC (1<<26)  /* EVAL debugging without fork() */\n#define CLIENT_MODULE (1<<27) /* Non connected client used by some module. */\n#define CLIENT_PROTECTED (1<<28) /* Client should not be freed for now. */\n#define CLIENT_PENDING_READ (1<<29) /* The client has pending reads and was put\n                                       in the list of clients we can read\n                                       from. */\n#define CLIENT_PENDING_COMMAND (1<<30) /* Used in threaded I/O to signal after\n                                          we return single threaded that the\n                                          client has already pending commands\n                                          to be executed. */\n#define CLIENT_TRACKING (1ULL<<31) /* Client enabled keys tracking in order to\n                                   perform client side caching. */\n#define CLIENT_TRACKING_BROKEN_REDIR (1ULL<<32) /* Target client is invalid. */\n#define CLIENT_TRACKING_BCAST (1ULL<<33) /* Tracking in BCAST mode. */\n#define CLIENT_TRACKING_OPTIN (1ULL<<34)  /* Tracking in opt-in mode. */\n#define CLIENT_TRACKING_OPTOUT (1ULL<<35) /* Tracking in opt-out mode. */\n#define CLIENT_TRACKING_CACHING (1ULL<<36) /* CACHING yes/no was given,\n                                              depending on optin/optout mode. */\n#define CLIENT_TRACKING_NOLOOP (1ULL<<37) /* Don't send invalidation messages\n                                             about writes performed by myself.*/\n#define CLIENT_IN_TO_TABLE (1ULL<<38) /* This client is in the timeout table. */\n#define CLIENT_PROTOCOL_ERROR (1ULL<<39) /* Protocol error chatting with it. */\n#define CLIENT_CLOSE_AFTER_COMMAND (1ULL<<40) /* Close after executing commands\n                                               * and writing entire reply. */\n\n/* Client block type (btype field in client structure)\n * if CLIENT_BLOCKED flag is set. */\n#define BLOCKED_NONE 0    /* Not blocked, no CLIENT_BLOCKED flag set. */\n#define BLOCKED_LIST 1    /* BLPOP & co. */\n#define BLOCKED_WAIT 2    /* WAIT for synchronous replication. */\n#define BLOCKED_MODULE 3  /* Blocked by a loadable module. */\n#define BLOCKED_STREAM 4  /* XREAD. */\n#define BLOCKED_ZSET 5    /* BZPOP et al. */\n#define BLOCKED_NUM 6     /* Number of blocked states. */\n\n/* Client request types */\n#define PROTO_REQ_INLINE 1\n#define PROTO_REQ_MULTIBULK 2\n\n/* Client classes for client limits, currently used only for\n * the max-client-output-buffer limit implementation. */\n#define CLIENT_TYPE_NORMAL 0 /* Normal req-reply clients + MONITORs */\n#define CLIENT_TYPE_SLAVE 1  /* Slaves. */\n#define CLIENT_TYPE_PUBSUB 2 /* Clients subscribed to PubSub channels. */\n#define CLIENT_TYPE_MASTER 3 /* Master. */\n#define CLIENT_TYPE_COUNT 4  /* Total number of client types. */\n#define CLIENT_TYPE_OBUF_COUNT 3 /* Number of clients to expose to output\n                                    buffer configuration. Just the first\n                                    three: normal, slave, pubsub. */\n\n/* Slave replication state. Used in server.repl_state for slaves to remember\n * what to do next. */\n#define REPL_STATE_NONE 0 /* No active replication */\n#define REPL_STATE_CONNECT 1 /* Must connect to master */\n#define REPL_STATE_CONNECTING 2 /* Connecting to master */\n/* --- Handshake states, must be ordered --- */\n#define REPL_STATE_RECEIVE_PONG 3 /* Wait for PING reply */\n#define REPL_STATE_SEND_AUTH 4 /* Send AUTH to master */\n#define REPL_STATE_RECEIVE_AUTH 5 /* Wait for AUTH reply */\n#define REPL_STATE_SEND_PORT 6 /* Send REPLCONF listening-port */\n#define REPL_STATE_RECEIVE_PORT 7 /* Wait for REPLCONF reply */\n#define REPL_STATE_SEND_IP 8 /* Send REPLCONF ip-address */\n#define REPL_STATE_RECEIVE_IP 9 /* Wait for REPLCONF reply */\n#define REPL_STATE_SEND_CAPA 10 /* Send REPLCONF capa */\n#define REPL_STATE_RECEIVE_CAPA 11 /* Wait for REPLCONF reply */\n#define REPL_STATE_SEND_PSYNC 12 /* Send PSYNC */\n#define REPL_STATE_RECEIVE_PSYNC 13 /* Wait for PSYNC reply */\n/* --- End of handshake states --- */\n#define REPL_STATE_TRANSFER 14 /* Receiving .rdb from master */\n#define REPL_STATE_CONNECTED 15 /* Connected to master */\n\n/* State of slaves from the POV of the master. Used in client->replstate.\n * In SEND_BULK and ONLINE state the slave receives new updates\n * in its output queue. In the WAIT_BGSAVE states instead the server is waiting\n * to start the next background saving in order to send updates to it. */\n#define SLAVE_STATE_WAIT_BGSAVE_START 6 /* We need to produce a new RDB file. */\n#define SLAVE_STATE_WAIT_BGSAVE_END 7 /* Waiting RDB file creation to finish. */\n#define SLAVE_STATE_SEND_BULK 8 /* Sending RDB file to slave. */\n#define SLAVE_STATE_ONLINE 9 /* RDB file transmitted, sending just updates. */\n\n/* Slave capabilities. */\n#define SLAVE_CAPA_NONE 0\n#define SLAVE_CAPA_EOF (1<<0)    /* Can parse the RDB EOF streaming format. */\n#define SLAVE_CAPA_PSYNC2 (1<<1) /* Supports PSYNC2 protocol. */\n\n/* Synchronous read timeout - slave side */\n#define CONFIG_REPL_SYNCIO_TIMEOUT 5\n\n/* List related stuff */\n#define LIST_HEAD 0\n#define LIST_TAIL 1\n#define ZSET_MIN 0\n#define ZSET_MAX 1\n\n/* Sort operations */\n#define SORT_OP_GET 0\n\n/* Log levels */\n#define LL_DEBUG 0\n#define LL_VERBOSE 1\n#define LL_NOTICE 2\n#define LL_WARNING 3\n#define LL_RAW (1<<10) /* Modifier to log without timestamp */\n\n/* Supervision options */\n#define SUPERVISED_NONE 0\n#define SUPERVISED_AUTODETECT 1\n#define SUPERVISED_SYSTEMD 2\n#define SUPERVISED_UPSTART 3\n\n/* Anti-warning macro... */\n#define UNUSED(V) ((void) V)\n\n#define ZSKIPLIST_MAXLEVEL 32 /* Should be enough for 2^64 elements */\n#define ZSKIPLIST_P 0.25      /* Skiplist P = 1/4 */\n\n/* Append only defines */\n#define AOF_FSYNC_NO 0\n#define AOF_FSYNC_ALWAYS 1\n#define AOF_FSYNC_EVERYSEC 2\n\n/* Replication diskless load defines */\n#define REPL_DISKLESS_LOAD_DISABLED 0\n#define REPL_DISKLESS_LOAD_WHEN_DB_EMPTY 1\n#define REPL_DISKLESS_LOAD_SWAPDB 2\n\n/* TLS Client Authentication */\n#define TLS_CLIENT_AUTH_NO 0\n#define TLS_CLIENT_AUTH_YES 1\n#define TLS_CLIENT_AUTH_OPTIONAL 2\n\n/* Sets operations codes */\n#define SET_OP_UNION 0\n#define SET_OP_DIFF 1\n#define SET_OP_INTER 2\n\n/* oom-score-adj defines */\n#define OOM_SCORE_ADJ_NO 0\n#define OOM_SCORE_RELATIVE 1\n#define OOM_SCORE_ADJ_ABSOLUTE 2\n\n/* Redis maxmemory strategies. Instead of using just incremental number\n * for this defines, we use a set of flags so that testing for certain\n * properties common to multiple policies is faster. */\n#define MAXMEMORY_FLAG_LRU (1<<0)\n#define MAXMEMORY_FLAG_LFU (1<<1)\n#define MAXMEMORY_FLAG_ALLKEYS (1<<2)\n#define MAXMEMORY_FLAG_NO_SHARED_INTEGERS \\\n    (MAXMEMORY_FLAG_LRU|MAXMEMORY_FLAG_LFU)\n\n#define MAXMEMORY_VOLATILE_LRU ((0<<8)|MAXMEMORY_FLAG_LRU)\n#define MAXMEMORY_VOLATILE_LFU ((1<<8)|MAXMEMORY_FLAG_LFU)\n#define MAXMEMORY_VOLATILE_TTL (2<<8)\n#define MAXMEMORY_VOLATILE_RANDOM (3<<8)\n#define MAXMEMORY_ALLKEYS_LRU ((4<<8)|MAXMEMORY_FLAG_LRU|MAXMEMORY_FLAG_ALLKEYS)\n#define MAXMEMORY_ALLKEYS_LFU ((5<<8)|MAXMEMORY_FLAG_LFU|MAXMEMORY_FLAG_ALLKEYS)\n#define MAXMEMORY_ALLKEYS_RANDOM ((6<<8)|MAXMEMORY_FLAG_ALLKEYS)\n#define MAXMEMORY_NO_EVICTION (7<<8)\n\n/* Units */\n#define UNIT_SECONDS 0\n#define UNIT_MILLISECONDS 1\n\n/* SHUTDOWN flags */\n#define SHUTDOWN_NOFLAGS 0      /* No flags. */\n#define SHUTDOWN_SAVE 1         /* Force SAVE on SHUTDOWN even if no save\n                                   points are configured. */\n#define SHUTDOWN_NOSAVE 2       /* Don't SAVE on SHUTDOWN. */\n\n/* Command call flags, see call() function */\n#define CMD_CALL_NONE 0\n#define CMD_CALL_SLOWLOG (1<<0)\n#define CMD_CALL_STATS (1<<1)\n#define CMD_CALL_PROPAGATE_AOF (1<<2)\n#define CMD_CALL_PROPAGATE_REPL (1<<3)\n#define CMD_CALL_PROPAGATE (CMD_CALL_PROPAGATE_AOF|CMD_CALL_PROPAGATE_REPL)\n#define CMD_CALL_FULL (CMD_CALL_SLOWLOG | CMD_CALL_STATS | CMD_CALL_PROPAGATE)\n#define CMD_CALL_NOWRAP (1<<4)  /* Don't wrap also propagate array into\n                                   MULTI/EXEC: the caller will handle it.  */\n\n/* Command propagation flags, see propagate() function */\n#define PROPAGATE_NONE 0\n#define PROPAGATE_AOF 1\n#define PROPAGATE_REPL 2\n\n/* RDB active child save type. */\n#define RDB_CHILD_TYPE_NONE 0\n#define RDB_CHILD_TYPE_DISK 1     /* RDB is written to disk. */\n#define RDB_CHILD_TYPE_SOCKET 2   /* RDB is written to slave socket. */\n\n/* Keyspace changes notification classes. Every class is associated with a\n * character for configuration purposes. */\n#define NOTIFY_KEYSPACE (1<<0)    /* K */\n#define NOTIFY_KEYEVENT (1<<1)    /* E */\n#define NOTIFY_GENERIC (1<<2)     /* g */\n#define NOTIFY_STRING (1<<3)      /* $ */\n#define NOTIFY_LIST (1<<4)        /* l */\n#define NOTIFY_SET (1<<5)         /* s */\n#define NOTIFY_HASH (1<<6)        /* h */\n#define NOTIFY_ZSET (1<<7)        /* z */\n#define NOTIFY_EXPIRED (1<<8)     /* x */\n#define NOTIFY_EVICTED (1<<9)     /* e */\n#define NOTIFY_STREAM (1<<10)     /* t */\n#define NOTIFY_KEY_MISS (1<<11)   /* m (Note: This one is excluded from NOTIFY_ALL on purpose) */\n#define NOTIFY_LOADED (1<<12)     /* module only key space notification, indicate a key loaded from rdb */\n#define NOTIFY_ALL (NOTIFY_GENERIC | NOTIFY_STRING | NOTIFY_LIST | NOTIFY_SET | NOTIFY_HASH | NOTIFY_ZSET | NOTIFY_EXPIRED | NOTIFY_EVICTED | NOTIFY_STREAM) /* A flag */\n\n/* Get the first bind addr or NULL */\n#define NET_FIRST_BIND_ADDR (server.bindaddr_count ? server.bindaddr[0] : NULL)\n\n/* Using the following macro you can run code inside serverCron() with the\n * specified period, specified in milliseconds.\n * The actual resolution depends on server.hz. */\n#define run_with_period(_ms_) if ((_ms_ <= 1000/server.hz) || !(server.cronloops%((_ms_)/(1000/server.hz))))\n\n/* We can print the stacktrace, so our assert is defined this way: */\n#define serverAssertWithInfo(_c,_o,_e) ((_e)?(void)0 : (_serverAssertWithInfo(_c,_o,#_e,__FILE__,__LINE__),_exit(1)))\n#define serverAssert(_e) ((_e)?(void)0 : (_serverAssert(#_e,__FILE__,__LINE__),_exit(1)))\n#define serverPanic(...) _serverPanic(__FILE__,__LINE__,__VA_ARGS__),_exit(1)\n\n/*-----------------------------------------------------------------------------\n * Data types\n *----------------------------------------------------------------------------*/\n\n/* A redis object, that is a type able to hold a string / list / set */\n\n/* The actual Redis Object */\n#define OBJ_STRING 0    /* String object. */\n#define OBJ_LIST 1      /* List object. */\n#define OBJ_SET 2       /* Set object. */\n#define OBJ_ZSET 3      /* Sorted set object. */\n#define OBJ_HASH 4      /* Hash object. */\n\n/* The \"module\" object type is a special one that signals that the object\n * is one directly managed by a Redis module. In this case the value points\n * to a moduleValue struct, which contains the object value (which is only\n * handled by the module itself) and the RedisModuleType struct which lists\n * function pointers in order to serialize, deserialize, AOF-rewrite and\n * free the object.\n *\n * Inside the RDB file, module types are encoded as OBJ_MODULE followed\n * by a 64 bit module type ID, which has a 54 bits module-specific signature\n * in order to dispatch the loading to the right module, plus a 10 bits\n * encoding version. */\n#define OBJ_MODULE 5    /* Module object. */\n#define OBJ_STREAM 6    /* Stream object. */\n\n/* Extract encver / signature from a module type ID. */\n#define REDISMODULE_TYPE_ENCVER_BITS 10\n#define REDISMODULE_TYPE_ENCVER_MASK ((1<<REDISMODULE_TYPE_ENCVER_BITS)-1)\n#define REDISMODULE_TYPE_ENCVER(id) (id & REDISMODULE_TYPE_ENCVER_MASK)\n#define REDISMODULE_TYPE_SIGN(id) ((id & ~((uint64_t)REDISMODULE_TYPE_ENCVER_MASK)) >>REDISMODULE_TYPE_ENCVER_BITS)\n\n/* Bit flags for moduleTypeAuxSaveFunc */\n#define REDISMODULE_AUX_BEFORE_RDB (1<<0)\n#define REDISMODULE_AUX_AFTER_RDB (1<<1)\n\nstruct RedisModule;\nstruct RedisModuleIO;\nstruct RedisModuleDigest;\nstruct RedisModuleCtx;\nstruct redisObject;\n\n/* Each module type implementation should export a set of methods in order\n * to serialize and deserialize the value in the RDB file, rewrite the AOF\n * log, create the digest for \"DEBUG DIGEST\", and free the value when a key\n * is deleted. */\ntypedef void *(*moduleTypeLoadFunc)(struct RedisModuleIO *io, int encver);\ntypedef void (*moduleTypeSaveFunc)(struct RedisModuleIO *io, void *value);\ntypedef int (*moduleTypeAuxLoadFunc)(struct RedisModuleIO *rdb, int encver, int when);\ntypedef void (*moduleTypeAuxSaveFunc)(struct RedisModuleIO *rdb, int when);\ntypedef void (*moduleTypeRewriteFunc)(struct RedisModuleIO *io, struct redisObject *key, void *value);\ntypedef void (*moduleTypeDigestFunc)(struct RedisModuleDigest *digest, void *value);\ntypedef size_t (*moduleTypeMemUsageFunc)(const void *value);\ntypedef void (*moduleTypeFreeFunc)(void *value);\n\n/* A callback that is called when the client authentication changes. This\n * needs to be exposed since you can't cast a function pointer to (void *) */\ntypedef void (*RedisModuleUserChangedFunc) (uint64_t client_id, void *privdata);\n\n\n/* The module type, which is referenced in each value of a given type, defines\n * the methods and links to the module exporting the type. */\ntypedef struct RedisModuleType {\n    uint64_t id; /* Higher 54 bits of type ID + 10 lower bits of encoding ver. */\n    struct RedisModule *module;\n    moduleTypeLoadFunc rdb_load;\n    moduleTypeSaveFunc rdb_save;\n    moduleTypeRewriteFunc aof_rewrite;\n    moduleTypeMemUsageFunc mem_usage;\n    moduleTypeDigestFunc digest;\n    moduleTypeFreeFunc free;\n    moduleTypeAuxLoadFunc aux_load;\n    moduleTypeAuxSaveFunc aux_save;\n    int aux_save_triggers;\n    char name[10]; /* 9 bytes name + null term. Charset: A-Z a-z 0-9 _- */\n} moduleType;\n\n/* In Redis objects 'robj' structures of type OBJ_MODULE, the value pointer\n * is set to the following structure, referencing the moduleType structure\n * in order to work with the value, and at the same time providing a raw\n * pointer to the value, as created by the module commands operating with\n * the module type.\n *\n * So for example in order to free such a value, it is possible to use\n * the following code:\n *\n *  if (robj->type == OBJ_MODULE) {\n *      moduleValue *mt = robj->ptr;\n *      mt->type->free(mt->value);\n *      zfree(mt); // We need to release this in-the-middle struct as well.\n *  }\n */\ntypedef struct moduleValue {\n    moduleType *type;\n    void *value;\n} moduleValue;\n\n/* This is a wrapper for the 'rio' streams used inside rdb.c in Redis, so that\n * the user does not have to take the total count of the written bytes nor\n * to care about error conditions. */\ntypedef struct RedisModuleIO {\n    size_t bytes;       /* Bytes read / written so far. */\n    rio *rio;           /* Rio stream. */\n    moduleType *type;   /* Module type doing the operation. */\n    int error;          /* True if error condition happened. */\n    int ver;            /* Module serialization version: 1 (old),\n                         * 2 (current version with opcodes annotation). */\n    struct RedisModuleCtx *ctx; /* Optional context, see RM_GetContextFromIO()*/\n    struct redisObject *key;    /* Optional name of key processed */\n} RedisModuleIO;\n\n/* Macro to initialize an IO context. Note that the 'ver' field is populated\n * inside rdb.c according to the version of the value to load. */\n#define moduleInitIOContext(iovar,mtype,rioptr,keyptr) do { \\\n    iovar.rio = rioptr; \\\n    iovar.type = mtype; \\\n    iovar.bytes = 0; \\\n    iovar.error = 0; \\\n    iovar.ver = 0; \\\n    iovar.key = keyptr; \\\n    iovar.ctx = NULL; \\\n} while(0);\n\n/* This is a structure used to export DEBUG DIGEST capabilities to Redis\n * modules. We want to capture both the ordered and unordered elements of\n * a data structure, so that a digest can be created in a way that correctly\n * reflects the values. See the DEBUG DIGEST command implementation for more\n * background. */\ntypedef struct RedisModuleDigest {\n    unsigned char o[20];    /* Ordered elements. */\n    unsigned char x[20];    /* Xored elements. */\n} RedisModuleDigest;\n\n/* Just start with a digest composed of all zero bytes. */\n#define moduleInitDigestContext(mdvar) do { \\\n    memset(mdvar.o,0,sizeof(mdvar.o)); \\\n    memset(mdvar.x,0,sizeof(mdvar.x)); \\\n} while(0);\n\n/* Objects encoding. Some kind of objects like Strings and Hashes can be\n * internally represented in multiple ways. The 'encoding' field of the object\n * is set to one of this fields for this object. */\n#define OBJ_ENCODING_RAW 0     /* Raw representation */\n#define OBJ_ENCODING_INT 1     /* Encoded as integer */\n#define OBJ_ENCODING_HT 2      /* Encoded as hash table */\n#define OBJ_ENCODING_ZIPMAP 3  /* Encoded as zipmap */\n#define OBJ_ENCODING_LINKEDLIST 4 /* No longer used: old list encoding. */\n#define OBJ_ENCODING_ZIPLIST 5 /* Encoded as ziplist */\n#define OBJ_ENCODING_INTSET 6  /* Encoded as intset */\n#define OBJ_ENCODING_SKIPLIST 7  /* Encoded as skiplist */\n#define OBJ_ENCODING_EMBSTR 8  /* Embedded sds string encoding */\n#define OBJ_ENCODING_QUICKLIST 9 /* Encoded as linked list of ziplists */\n#define OBJ_ENCODING_STREAM 10 /* Encoded as a radix tree of listpacks */\n\n#define LRU_BITS 24\n#define LRU_CLOCK_MAX ((1<<LRU_BITS)-1) /* Max value of obj->lru */\n#define LRU_CLOCK_RESOLUTION 1000 /* LRU clock resolution in ms */\n\n#define OBJ_SHARED_REFCOUNT INT_MAX     /* Global object never destroyed. */\n#define OBJ_STATIC_REFCOUNT (INT_MAX-1) /* Object allocated in the stack. */\n#define OBJ_FIRST_SPECIAL_REFCOUNT OBJ_STATIC_REFCOUNT\ntypedef struct redisObject {\n    unsigned type:4;\n    unsigned encoding:4;\n    unsigned lru:LRU_BITS; /* LRU time (relative to global lru_clock) or\n                            * LFU data (least significant 8 bits frequency\n                            * and most significant 16 bits access time). */\n    int refcount;\n    void *ptr;\n} robj;\n\n/* The a string name for an object's type as listed above\n * Native types are checked against the OBJ_STRING, OBJ_LIST, OBJ_* defines,\n * and Module types have their registered name returned. */\nchar *getObjectTypeName(robj*);\n\n/* Macro used to initialize a Redis object allocated on the stack.\n * Note that this macro is taken near the structure definition to make sure\n * we'll update it when the structure is changed, to avoid bugs like\n * bug #85 introduced exactly in this way. */\n#define initStaticStringObject(_var,_ptr) do { \\\n    _var.refcount = OBJ_STATIC_REFCOUNT; \\\n    _var.type = OBJ_STRING; \\\n    _var.encoding = OBJ_ENCODING_RAW; \\\n    _var.ptr = _ptr; \\\n} while(0)\n\nstruct evictionPoolEntry; /* Defined in evict.c */\n\n/* This structure is used in order to represent the output buffer of a client,\n * which is actually a linked list of blocks like that, that is: client->reply. */\ntypedef struct clientReplyBlock {\n    size_t size, used;\n    char buf[];\n} clientReplyBlock;\n\n/* Redis database representation. There are multiple databases identified\n * by integers from 0 (the default database) up to the max configured\n * database. The database number is the 'id' field in the structure. */\ntypedef struct redisDb {\n    dict *dict;                 /* The keyspace for this DB */\n    dict *expires;              /* Timeout of keys with a timeout set */\n    dict *blocking_keys;        /* Keys with clients waiting for data (BLPOP)*/\n    dict *ready_keys;           /* Blocked keys that received a PUSH */\n    dict *watched_keys;         /* WATCHED keys for MULTI/EXEC CAS */\n    int id;                     /* Database ID */\n    long long avg_ttl;          /* Average TTL, just for stats */\n    unsigned long expires_cursor; /* Cursor of the active expire cycle. */\n    list *defrag_later;         /* List of key names to attempt to defrag one by one, gradually. */\n} redisDb;\n\n/* Declare database backup that include redis main DBs and slots to keys map.\n * Definition is in db.c. We can't define it here since we define CLUSTER_SLOTS\n * in cluster.h. */\ntypedef struct dbBackup dbBackup;\n\n/* Client MULTI/EXEC state */\ntypedef struct multiCmd {\n    robj **argv;\n    int argc;\n    struct redisCommand *cmd;\n} multiCmd;\n\ntypedef struct multiState {\n    multiCmd *commands;     /* Array of MULTI commands */\n    int count;              /* Total number of MULTI commands */\n    int cmd_flags;          /* The accumulated command flags OR-ed together.\n                               So if at least a command has a given flag, it\n                               will be set in this field. */\n    int cmd_inv_flags;      /* Same as cmd_flags, OR-ing the ~flags. so that it\n                               is possible to know if all the commands have a\n                               certain flag. */\n    int minreplicas;        /* MINREPLICAS for synchronous replication */\n    time_t minreplicas_timeout; /* MINREPLICAS timeout as unixtime. */\n} multiState;\n\n/* This structure holds the blocking operation state for a client.\n * The fields used depend on client->btype. */\ntypedef struct blockingState {\n    /* Generic fields. */\n    mstime_t timeout;       /* Blocking operation timeout. If UNIX current time\n                             * is > timeout then the operation timed out. */\n\n    /* BLOCKED_LIST, BLOCKED_ZSET and BLOCKED_STREAM */\n    dict *keys;             /* The keys we are waiting to terminate a blocking\n                             * operation such as BLPOP or XREAD. Or NULL. */\n    robj *target;           /* The key that should receive the element,\n                             * for BRPOPLPUSH. */\n\n    /* BLOCK_STREAM */\n    size_t xread_count;     /* XREAD COUNT option. */\n    robj *xread_group;      /* XREADGROUP group name. */\n    robj *xread_consumer;   /* XREADGROUP consumer name. */\n    mstime_t xread_retry_time, xread_retry_ttl;\n    int xread_group_noack;\n\n    /* BLOCKED_WAIT */\n    int numreplicas;        /* Number of replicas we are waiting for ACK. */\n    long long reploffset;   /* Replication offset to reach. */\n\n    /* BLOCKED_MODULE */\n    void *module_blocked_handle; /* RedisModuleBlockedClient structure.\n                                    which is opaque for the Redis core, only\n                                    handled in module.c. */\n} blockingState;\n\n/* The following structure represents a node in the server.ready_keys list,\n * where we accumulate all the keys that had clients blocked with a blocking\n * operation such as B[LR]POP, but received new data in the context of the\n * last executed command.\n *\n * After the execution of every command or script, we run this list to check\n * if as a result we should serve data to clients blocked, unblocking them.\n * Note that server.ready_keys will not have duplicates as there dictionary\n * also called ready_keys in every structure representing a Redis database,\n * where we make sure to remember if a given key was already added in the\n * server.ready_keys list. */\ntypedef struct readyList {\n    redisDb *db;\n    robj *key;\n} readyList;\n\n/* This structure represents a Redis user. This is useful for ACLs, the\n * user is associated to the connection after the connection is authenticated.\n * If there is no associated user, the connection uses the default user. */\n#define USER_COMMAND_BITS_COUNT 1024    /* The total number of command bits\n                                           in the user structure. The last valid\n                                           command ID we can set in the user\n                                           is USER_COMMAND_BITS_COUNT-1. */\n#define USER_FLAG_ENABLED (1<<0)        /* The user is active. */\n#define USER_FLAG_DISABLED (1<<1)       /* The user is disabled. */\n#define USER_FLAG_ALLKEYS (1<<2)        /* The user can mention any key. */\n#define USER_FLAG_ALLCOMMANDS (1<<3)    /* The user can run all commands. */\n#define USER_FLAG_NOPASS      (1<<4)    /* The user requires no password, any\n                                           provided password will work. For the\n                                           default user, this also means that\n                                           no AUTH is needed, and every\n                                           connection is immediately\n                                           authenticated. */\ntypedef struct {\n    sds name;       /* The username as an SDS string. */\n    uint64_t flags; /* See USER_FLAG_* */\n\n    /* The bit in allowed_commands is set if this user has the right to\n     * execute this command. In commands having subcommands, if this bit is\n     * set, then all the subcommands are also available.\n     *\n     * If the bit for a given command is NOT set and the command has\n     * subcommands, Redis will also check allowed_subcommands in order to\n     * understand if the command can be executed. */\n    uint64_t allowed_commands[USER_COMMAND_BITS_COUNT/64];\n\n    /* This array points, for each command ID (corresponding to the command\n     * bit set in allowed_commands), to an array of SDS strings, terminated by\n     * a NULL pointer, with all the sub commands that can be executed for\n     * this command. When no subcommands matching is used, the field is just\n     * set to NULL to avoid allocating USER_COMMAND_BITS_COUNT pointers. */\n    sds **allowed_subcommands;\n    list *passwords; /* A list of SDS valid passwords for this user. */\n    list *patterns;  /* A list of allowed key patterns. If this field is NULL\n                        the user cannot mention any key in a command, unless\n                        the flag ALLKEYS is set in the user. */\n} user;\n\n/* With multiplexing we need to take per-client state.\n * Clients are taken in a linked list. */\n\n#define CLIENT_ID_AOF (UINT64_MAX) /* Reserved ID for the AOF client. If you\n                                      need more reserved IDs use UINT64_MAX-1,\n                                      -2, ... and so forth. */\n\ntypedef struct client {\n    uint64_t id;            /* Client incremental unique ID. */\n    connection *conn;\n    int resp;               /* RESP protocol version. Can be 2 or 3. */\n    redisDb *db;            /* Pointer to currently SELECTed DB. */\n    robj *name;             /* As set by CLIENT SETNAME. */\n    sds querybuf;           /* Buffer we use to accumulate client queries. */\n    size_t qb_pos;          /* The position we have read in querybuf. */\n    sds pending_querybuf;   /* If this client is flagged as master, this buffer\n                               represents the yet not applied portion of the\n                               replication stream that we are receiving from\n                               the master. */\n    size_t querybuf_peak;   /* Recent (100ms or more) peak of querybuf size. */\n    int argc;               /* Num of arguments of current command. */\n    robj **argv;            /* Arguments of current command. */\n    size_t argv_len_sum;    /* Sum of lengths of objects in argv list. */\n    struct redisCommand *cmd, *lastcmd;  /* Last command executed. */\n    user *user;             /* User associated with this connection. If the\n                               user is set to NULL the connection can do\n                               anything (admin). */\n    int reqtype;            /* Request protocol type: PROTO_REQ_* */\n    int multibulklen;       /* Number of multi bulk arguments left to read. */\n    long bulklen;           /* Length of bulk argument in multi bulk request. */\n    list *reply;            /* List of reply objects to send to the client. */\n    unsigned long long reply_bytes; /* Tot bytes of objects in reply list. */\n    size_t sentlen;         /* Amount of bytes already sent in the current\n                               buffer or object being sent. */\n    time_t ctime;           /* Client creation time. */\n    time_t lastinteraction; /* Time of the last interaction, used for timeout */\n    time_t obuf_soft_limit_reached_time;\n    uint64_t flags;         /* Client flags: CLIENT_* macros. */\n    int authenticated;      /* Needed when the default user requires auth. */\n    int replstate;          /* Replication state if this is a slave. */\n    int repl_put_online_on_ack; /* Install slave write handler on first ACK. */\n    int repldbfd;           /* Replication DB file descriptor. */\n    off_t repldboff;        /* Replication DB file offset. */\n    off_t repldbsize;       /* Replication DB file size. */\n    sds replpreamble;       /* Replication DB preamble. */\n    long long read_reploff; /* Read replication offset if this is a master. */\n    long long reploff;      /* Applied replication offset if this is a master. */\n    long long repl_ack_off; /* Replication ack offset, if this is a slave. */\n    long long repl_ack_time;/* Replication ack time, if this is a slave. */\n    long long repl_last_partial_write; /* The last time the server did a partial write from the RDB child pipe to this replica  */\n    long long psync_initial_offset; /* FULLRESYNC reply offset other slaves\n                                       copying this slave output buffer\n                                       should use. */\n    char replid[CONFIG_RUN_ID_SIZE+1]; /* Master replication ID (if master). */\n    int slave_listening_port; /* As configured with: REPLCONF listening-port */\n    char slave_ip[NET_IP_STR_LEN]; /* Optionally given by REPLCONF ip-address */\n    int slave_capa;         /* Slave capabilities: SLAVE_CAPA_* bitwise OR. */\n    multiState mstate;      /* MULTI/EXEC state */\n    int btype;              /* Type of blocking op if CLIENT_BLOCKED. */\n    blockingState bpop;     /* blocking state */\n    long long woff;         /* Last write global replication offset. */\n    list *watched_keys;     /* Keys WATCHED for MULTI/EXEC CAS */\n    dict *pubsub_channels;  /* channels a client is interested in (SUBSCRIBE) */\n    list *pubsub_patterns;  /* patterns a client is interested in (SUBSCRIBE) */\n    sds peerid;             /* Cached peer ID. */\n    listNode *client_list_node; /* list node in client list */\n    RedisModuleUserChangedFunc auth_callback; /* Module callback to execute\n                                               * when the authenticated user\n                                               * changes. */\n    void *auth_callback_privdata; /* Private data that is passed when the auth\n                                   * changed callback is executed. Opaque for\n                                   * Redis Core. */\n    void *auth_module;      /* The module that owns the callback, which is used\n                             * to disconnect the client if the module is\n                             * unloaded for cleanup. Opaque for Redis Core.*/\n\n    /* If this client is in tracking mode and this field is non zero,\n     * invalidation messages for keys fetched by this client will be send to\n     * the specified client ID. */\n    uint64_t client_tracking_redirection;\n    rax *client_tracking_prefixes; /* A dictionary of prefixes we are already\n                                      subscribed to in BCAST mode, in the\n                                      context of client side caching. */\n    /* In clientsCronTrackClientsMemUsage() we track the memory usage of\n     * each client and add it to the sum of all the clients of a given type,\n     * however we need to remember what was the old contribution of each\n     * client, and in which categoty the client was, in order to remove it\n     * before adding it the new value. */\n    uint64_t client_cron_last_memory_usage;\n    int      client_cron_last_memory_type;\n    /* Response buffer */\n    int bufpos;\n    char buf[PROTO_REPLY_CHUNK_BYTES];\n} client;\n\nstruct saveparam {\n    time_t seconds;\n    int changes;\n};\n\nstruct moduleLoadQueueEntry {\n    sds path;\n    int argc;\n    robj **argv;\n};\n\nstruct sharedObjectsStruct {\n    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *pong, *space,\n    *colon, *queued, *null[4], *nullarray[4], *emptymap[4], *emptyset[4],\n    *emptyarray, *wrongtypeerr, *nokeyerr, *syntaxerr, *sameobjecterr,\n    *outofrangeerr, *noscripterr, *loadingerr, *slowscripterr, *bgsaveerr,\n    *masterdownerr, *roslaveerr, *execaborterr, *noautherr, *noreplicaserr,\n    *busykeyerr, *oomerr, *plus, *messagebulk, *pmessagebulk, *subscribebulk,\n    *unsubscribebulk, *psubscribebulk, *punsubscribebulk, *del, *unlink,\n    *rpop, *lpop, *lpush, *rpoplpush, *zpopmin, *zpopmax, *emptyscan,\n    *multi, *exec,\n    *select[PROTO_SHARED_SELECT_CMDS],\n    *integers[OBJ_SHARED_INTEGERS],\n    *mbulkhdr[OBJ_SHARED_BULKHDR_LEN], /* \"*<value>\\r\\n\" */\n    *bulkhdr[OBJ_SHARED_BULKHDR_LEN];  /* \"$<value>\\r\\n\" */\n    sds minstring, maxstring;\n};\n\n/* ZSETs use a specialized version of Skiplists */\ntypedef struct zskiplistNode {\n    sds ele;\n    double score;\n    struct zskiplistNode *backward;\n    struct zskiplistLevel {\n        struct zskiplistNode *forward;\n        unsigned long span;\n    } level[];\n} zskiplistNode;\n\ntypedef struct zskiplist {\n    struct zskiplistNode *header, *tail;\n    unsigned long length;\n    int level;\n} zskiplist;\n\ntypedef struct zset {\n    dict *dict;\n    zskiplist *zsl;\n} zset;\n\ntypedef struct clientBufferLimitsConfig {\n    unsigned long long hard_limit_bytes;\n    unsigned long long soft_limit_bytes;\n    time_t soft_limit_seconds;\n} clientBufferLimitsConfig;\n\nextern clientBufferLimitsConfig clientBufferLimitsDefaults[CLIENT_TYPE_OBUF_COUNT];\n\n/* The redisOp structure defines a Redis Operation, that is an instance of\n * a command with an argument vector, database ID, propagation target\n * (PROPAGATE_*), and command pointer.\n *\n * Currently only used to additionally propagate more commands to AOF/Replication\n * after the propagation of the executed command. */\ntypedef struct redisOp {\n    robj **argv;\n    int argc, dbid, target;\n    struct redisCommand *cmd;\n} redisOp;\n\n/* Defines an array of Redis operations. There is an API to add to this\n * structure in an easy way.\n *\n * redisOpArrayInit();\n * redisOpArrayAppend();\n * redisOpArrayFree();\n */\ntypedef struct redisOpArray {\n    redisOp *ops;\n    int numops;\n} redisOpArray;\n\n/* This structure is returned by the getMemoryOverheadData() function in\n * order to return memory overhead information. */\nstruct redisMemOverhead {\n    size_t peak_allocated;\n    size_t total_allocated;\n    size_t startup_allocated;\n    size_t repl_backlog;\n    size_t clients_slaves;\n    size_t clients_normal;\n    size_t aof_buffer;\n    size_t lua_caches;\n    size_t overhead_total;\n    size_t dataset;\n    size_t total_keys;\n    size_t bytes_per_key;\n    float dataset_perc;\n    float peak_perc;\n    float total_frag;\n    ssize_t total_frag_bytes;\n    float allocator_frag;\n    ssize_t allocator_frag_bytes;\n    float allocator_rss;\n    ssize_t allocator_rss_bytes;\n    float rss_extra;\n    size_t rss_extra_bytes;\n    size_t num_dbs;\n    struct {\n        size_t dbid;\n        size_t overhead_ht_main;\n        size_t overhead_ht_expires;\n    } *db;\n};\n\n/* This structure can be optionally passed to RDB save/load functions in\n * order to implement additional functionalities, by storing and loading\n * metadata to the RDB file.\n *\n * Currently the only use is to select a DB at load time, useful in\n * replication in order to make sure that chained slaves (slaves of slaves)\n * select the correct DB and are able to accept the stream coming from the\n * top-level master. */\ntypedef struct rdbSaveInfo {\n    /* Used saving and loading. */\n    int repl_stream_db;  /* DB to select in server.master client. */\n\n    /* Used only loading. */\n    int repl_id_is_set;  /* True if repl_id field is set. */\n    char repl_id[CONFIG_RUN_ID_SIZE+1];     /* Replication ID. */\n    long long repl_offset;                  /* Replication offset. */\n} rdbSaveInfo;\n\n#define RDB_SAVE_INFO_INIT {-1,0,\"000000000000000000000000000000\",-1}\n\nstruct malloc_stats {\n    size_t zmalloc_used;\n    size_t process_rss;\n    size_t allocator_allocated;\n    size_t allocator_active;\n    size_t allocator_resident;\n};\n\n/*-----------------------------------------------------------------------------\n * TLS Context Configuration\n *----------------------------------------------------------------------------*/\n\ntypedef struct redisTLSContextConfig {\n    char *cert_file;\n    char *key_file;\n    char *dh_params_file;\n    char *ca_cert_file;\n    char *ca_cert_dir;\n    char *protocols;\n    char *ciphers;\n    char *ciphersuites;\n    int prefer_server_ciphers;\n    int session_caching;\n    int session_cache_size;\n    int session_cache_timeout;\n} redisTLSContextConfig;\n\n/*-----------------------------------------------------------------------------\n * Global server state\n *----------------------------------------------------------------------------*/\n\nstruct clusterState;\n\n/* AIX defines hz to __hz, we don't use this define and in order to allow\n * Redis build on AIX we need to undef it. */\n#ifdef _AIX\n#undef hz\n#endif\n\n#define CHILD_INFO_MAGIC 0xC17DDA7A12345678LL\n#define CHILD_TYPE_NONE 0\n#define CHILD_TYPE_RDB 1\n#define CHILD_TYPE_AOF 2\n#define CHILD_TYPE_LDB 3\n#define CHILD_TYPE_MODULE 4\n\nstruct redisServer {\n    /* General */\n    pid_t pid;                  /* Main process pid. */\n    pthread_t main_thread_id;         /* Main thread id */\n    char *configfile;           /* Absolute config file path, or NULL */\n    char *executable;           /* Absolute executable file path. */\n    char **exec_argv;           /* Executable argv vector (copy). */\n    int dynamic_hz;             /* Change hz value depending on # of clients. */\n    int config_hz;              /* Configured HZ value. May be different than\n                                   the actual 'hz' field value if dynamic-hz\n                                   is enabled. */\n    mode_t umask;               /* The umask value of the process on startup */\n    int hz;                     /* serverCron() calls frequency in hertz */\n    int in_fork_child;          /* indication that this is a fork child */\n    redisDb *db;\n    dict *commands;             /* Command table */\n    dict *orig_commands;        /* Command table before command renaming. */\n    aeEventLoop *el;\n    _Atomic unsigned int lruclock; /* Clock for LRU eviction */\n    volatile sig_atomic_t shutdown_asap; /* SHUTDOWN needed ASAP */\n    int activerehashing;        /* Incremental rehash in serverCron() */\n    int active_defrag_running;  /* Active defragmentation running (holds current scan aggressiveness) */\n    char *pidfile;              /* PID file path */\n    int arch_bits;              /* 32 or 64 depending on sizeof(long) */\n    int cronloops;              /* Number of times the cron function run */\n    char runid[CONFIG_RUN_ID_SIZE+1];  /* ID always different at every exec. */\n    int sentinel_mode;          /* True if this instance is a Sentinel. */\n    size_t initial_memory_usage; /* Bytes used after initialization. */\n    int always_show_logo;       /* Show logo even for non-stdout logging. */\n    char *ignore_warnings;      /* Config: warnings that should be ignored. */\n    /* Modules */\n    dict *moduleapi;            /* Exported core APIs dictionary for modules. */\n    dict *sharedapi;            /* Like moduleapi but containing the APIs that\n                                   modules share with each other. */\n    list *loadmodule_queue;     /* List of modules to load at startup. */\n    int module_blocked_pipe[2]; /* Pipe used to awake the event loop if a\n                                   client blocked on a module command needs\n                                   to be processed. */\n    pid_t module_child_pid;     /* PID of module child */\n    /* Networking */\n    int port;                   /* TCP listening port */\n    int tls_port;               /* TLS listening port */\n    int tcp_backlog;            /* TCP listen() backlog */\n    char *bindaddr[CONFIG_BINDADDR_MAX]; /* Addresses we should bind to */\n    int bindaddr_count;         /* Number of addresses in server.bindaddr[] */\n    char *unixsocket;           /* UNIX socket path */\n    mode_t unixsocketperm;      /* UNIX socket permission */\n    int ipfd[CONFIG_BINDADDR_MAX]; /* TCP socket file descriptors */\n    int ipfd_count;             /* Used slots in ipfd[] */\n    int tlsfd[CONFIG_BINDADDR_MAX]; /* TLS socket file descriptors */\n    int tlsfd_count;            /* Used slots in tlsfd[] */\n    int sofd;                   /* Unix socket file descriptor */\n    int cfd[CONFIG_BINDADDR_MAX];/* Cluster bus listening socket */\n    int cfd_count;              /* Used slots in cfd[] */\n    list *clients;              /* List of active clients */\n    list *clients_to_close;     /* Clients to close asynchronously */\n    list *clients_pending_write; /* There is to write or install handler. */\n    list *clients_pending_read;  /* Client has pending read socket buffers. */\n    list *slaves, *monitors;    /* List of slaves and MONITORs */\n    client *current_client;     /* Current client executing the command. */\n    rax *clients_timeout_table; /* Radix tree for blocked clients timeouts. */\n    long fixed_time_expire;     /* If > 0, expire keys against server.mstime. */\n    rax *clients_index;         /* Active clients dictionary by client ID. */\n    int clients_paused;         /* True if clients are currently paused */\n    mstime_t clients_pause_end_time; /* Time when we undo clients_paused */\n    char neterr[ANET_ERR_LEN];   /* Error buffer for anet.c */\n    dict *migrate_cached_sockets;/* MIGRATE cached sockets */\n    _Atomic uint64_t next_client_id; /* Next client unique ID. Incremental. */\n    int protected_mode;         /* Don't accept external connections. */\n    int gopher_enabled;         /* If true the server will reply to gopher\n                                   queries. Will still serve RESP2 queries. */\n    int io_threads_num;         /* Number of IO threads to use. */\n    int io_threads_do_reads;    /* Read and parse from IO threads? */\n    int io_threads_active;      /* Is IO threads currently active? */\n    long long events_processed_while_blocked; /* processEventsWhileBlocked() */\n\n    /* RDB / AOF loading information */\n    volatile sig_atomic_t loading; /* We are loading data from disk if true */\n    off_t loading_total_bytes;\n    off_t loading_loaded_bytes;\n    time_t loading_start_time;\n    off_t loading_process_events_interval_bytes;\n    /* Fast pointers to often looked up command */\n    struct redisCommand *delCommand, *multiCommand, *lpushCommand,\n                        *lpopCommand, *rpopCommand, *zpopminCommand,\n                        *zpopmaxCommand, *sremCommand, *execCommand,\n                        *expireCommand, *pexpireCommand, *xclaimCommand,\n                        *xgroupCommand, *rpoplpushCommand;\n    /* Fields used only for stats */\n    time_t stat_starttime;          /* Server start time */\n    long long stat_numcommands;     /* Number of processed commands */\n    long long stat_numconnections;  /* Number of connections received */\n    long long stat_expiredkeys;     /* Number of expired keys */\n    double stat_expired_stale_perc; /* Percentage of keys probably expired */\n    long long stat_expired_time_cap_reached_count; /* Early expire cylce stops.*/\n    long long stat_expire_cycle_time_used; /* Cumulative microseconds used. */\n    long long stat_evictedkeys;     /* Number of evicted keys (maxmemory) */\n    long long stat_keyspace_hits;   /* Number of successful lookups of keys */\n    long long stat_keyspace_misses; /* Number of failed lookups of keys */\n    long long stat_active_defrag_hits;      /* number of allocations moved */\n    long long stat_active_defrag_misses;    /* number of allocations scanned but not moved */\n    long long stat_active_defrag_key_hits;  /* number of keys with moved allocations */\n    long long stat_active_defrag_key_misses;/* number of keys scanned and not moved */\n    long long stat_active_defrag_scanned;   /* number of dictEntries scanned */\n    size_t stat_peak_memory;        /* Max used memory record */\n    long long stat_fork_time;       /* Time needed to perform latest fork() */\n    double stat_fork_rate;          /* Fork rate in GB/sec. */\n    long long stat_rejected_conn;   /* Clients rejected because of maxclients */\n    long long stat_sync_full;       /* Number of full resyncs with slaves. */\n    long long stat_sync_partial_ok; /* Number of accepted PSYNC requests. */\n    long long stat_sync_partial_err;/* Number of unaccepted PSYNC requests. */\n    list *slowlog;                  /* SLOWLOG list of commands */\n    long long slowlog_entry_id;     /* SLOWLOG current entry ID */\n    long long slowlog_log_slower_than; /* SLOWLOG time limit (to get logged) */\n    unsigned long slowlog_max_len;     /* SLOWLOG max number of items logged */\n    struct malloc_stats cron_malloc_stats; /* sampled in serverCron(). */\n    _Atomic long long stat_net_input_bytes; /* Bytes read from network. */\n    _Atomic long long stat_net_output_bytes; /* Bytes written to network. */\n    size_t stat_rdb_cow_bytes;      /* Copy on write bytes during RDB saving. */\n    size_t stat_aof_cow_bytes;      /* Copy on write bytes during AOF rewrite. */\n    size_t stat_module_cow_bytes;   /* Copy on write bytes during module fork. */\n    uint64_t stat_clients_type_memory[CLIENT_TYPE_COUNT];/* Mem usage by type */\n    long long stat_unexpected_error_replies; /* Number of unexpected (aof-loading, replica to master, etc.) error replies */\n    long long stat_io_reads_processed; /* Number of read events processed by IO / Main threads */\n    long long stat_io_writes_processed; /* Number of write events processed by IO / Main threads */\n    _Atomic long long stat_total_reads_processed; /* Total number of read events processed */\n    _Atomic long long stat_total_writes_processed; /* Total number of write events processed */\n    /* The following two are used to track instantaneous metrics, like\n     * number of operations per second, network traffic. */\n    struct {\n        long long last_sample_time; /* Timestamp of last sample in ms */\n        long long last_sample_count;/* Count in last sample */\n        long long samples[STATS_METRIC_SAMPLES];\n        int idx;\n    } inst_metric[STATS_METRIC_COUNT];\n    /* Configuration */\n    int verbosity;                  /* Loglevel in redis.conf */\n    int maxidletime;                /* Client timeout in seconds */\n    int tcpkeepalive;               /* Set SO_KEEPALIVE if non-zero. */\n    int active_expire_enabled;      /* Can be disabled for testing purposes. */\n    int active_expire_effort;       /* From 1 (default) to 10, active effort. */\n    int active_defrag_enabled;\n    int jemalloc_bg_thread;         /* Enable jemalloc background thread */\n    size_t active_defrag_ignore_bytes; /* minimum amount of fragmentation waste to start active defrag */\n    int active_defrag_threshold_lower; /* minimum percentage of fragmentation to start active defrag */\n    int active_defrag_threshold_upper; /* maximum percentage of fragmentation at which we use maximum effort */\n    int active_defrag_cycle_min;       /* minimal effort for defrag in CPU percentage */\n    int active_defrag_cycle_max;       /* maximal effort for defrag in CPU percentage */\n    unsigned long active_defrag_max_scan_fields; /* maximum number of fields of set/hash/zset/list to process from within the main dict scan */\n    _Atomic size_t client_max_querybuf_len; /* Limit for client query buffer length */\n    int dbnum;                      /* Total number of configured DBs */\n    int supervised;                 /* 1 if supervised, 0 otherwise. */\n    int supervised_mode;            /* See SUPERVISED_* */\n    int daemonize;                  /* True if running as a daemon */\n    clientBufferLimitsConfig client_obuf_limits[CLIENT_TYPE_OBUF_COUNT];\n    /* AOF persistence */\n    int aof_enabled;                /* AOF configuration */\n    int aof_state;                  /* AOF_(ON|OFF|WAIT_REWRITE) */\n    int aof_fsync;                  /* Kind of fsync() policy */\n    char *aof_filename;             /* Name of the AOF file */\n    int aof_no_fsync_on_rewrite;    /* Don't fsync if a rewrite is in prog. */\n    int aof_rewrite_perc;           /* Rewrite AOF if % growth is > M and... */\n    off_t aof_rewrite_min_size;     /* the AOF file is at least N bytes. */\n    off_t aof_rewrite_base_size;    /* AOF size on latest startup or rewrite. */\n    off_t aof_current_size;         /* AOF current size. */\n    off_t aof_fsync_offset;         /* AOF offset which is already synced to disk. */\n    int aof_flush_sleep;            /* Micros to sleep before flush. (used by tests) */\n    int aof_rewrite_scheduled;      /* Rewrite once BGSAVE terminates. */\n    pid_t aof_child_pid;            /* PID if rewriting process */\n    list *aof_rewrite_buf_blocks;   /* Hold changes during an AOF rewrite. */\n    sds aof_buf;      /* AOF buffer, written before entering the event loop */\n    int aof_fd;       /* File descriptor of currently selected AOF file */\n    int aof_selected_db; /* Currently selected DB in AOF */\n    time_t aof_flush_postponed_start; /* UNIX time of postponed AOF flush */\n    time_t aof_last_fsync;            /* UNIX time of last fsync() */\n    time_t aof_rewrite_time_last;   /* Time used by last AOF rewrite run. */\n    time_t aof_rewrite_time_start;  /* Current AOF rewrite start time. */\n    int aof_lastbgrewrite_status;   /* C_OK or C_ERR */\n    unsigned long aof_delayed_fsync;  /* delayed AOF fsync() counter */\n    int aof_rewrite_incremental_fsync;/* fsync incrementally while aof rewriting? */\n    int rdb_save_incremental_fsync;   /* fsync incrementally while rdb saving? */\n    int aof_last_write_status;      /* C_OK or C_ERR */\n    int aof_last_write_errno;       /* Valid if aof_last_write_status is ERR */\n    int aof_load_truncated;         /* Don't stop on unexpected AOF EOF. */\n    int aof_use_rdb_preamble;       /* Use RDB preamble on AOF rewrites. */\n    /* AOF pipes used to communicate between parent and child during rewrite. */\n    int aof_pipe_write_data_to_child;\n    int aof_pipe_read_data_from_parent;\n    int aof_pipe_write_ack_to_parent;\n    int aof_pipe_read_ack_from_child;\n    int aof_pipe_write_ack_to_child;\n    int aof_pipe_read_ack_from_parent;\n    int aof_stop_sending_diff;     /* If true stop sending accumulated diffs\n                                      to child process. */\n    sds aof_child_diff;             /* AOF diff accumulator child side. */\n    /* RDB persistence */\n    long long dirty;                /* Changes to DB from the last save */\n    long long dirty_before_bgsave;  /* Used to restore dirty on failed BGSAVE */\n    pid_t rdb_child_pid;            /* PID of RDB saving child */\n    struct saveparam *saveparams;   /* Save points array for RDB */\n    int saveparamslen;              /* Number of saving points */\n    char *rdb_filename;             /* Name of RDB file */\n    int rdb_compression;            /* Use compression in RDB? */\n    int rdb_checksum;               /* Use RDB checksum? */\n    int rdb_del_sync_files;         /* Remove RDB files used only for SYNC if\n                                       the instance does not use persistence. */\n    time_t lastsave;                /* Unix time of last successful save */\n    time_t lastbgsave_try;          /* Unix time of last attempted bgsave */\n    time_t rdb_save_time_last;      /* Time used by last RDB save run. */\n    time_t rdb_save_time_start;     /* Current RDB save start time. */\n    int rdb_bgsave_scheduled;       /* BGSAVE when possible if true. */\n    int rdb_child_type;             /* Type of save by active child. */\n    int lastbgsave_status;          /* C_OK or C_ERR */\n    int stop_writes_on_bgsave_err;  /* Don't allow writes if can't BGSAVE */\n    int rdb_pipe_read;              /* RDB pipe used to transfer the rdb data */\n                                    /* to the parent process in diskless repl. */\n    int rdb_child_exit_pipe;        /* Used by the diskless parent allow child exit. */\n    connection **rdb_pipe_conns;    /* Connections which are currently the */\n    int rdb_pipe_numconns;          /* target of diskless rdb fork child. */\n    int rdb_pipe_numconns_writing;  /* Number of rdb conns with pending writes. */\n    char *rdb_pipe_buff;            /* In diskless replication, this buffer holds data */\n    int rdb_pipe_bufflen;           /* that was read from the the rdb pipe. */\n    int rdb_key_save_delay;         /* Delay in microseconds between keys while\n                                     * writing the RDB. (for testings) */\n    int key_load_delay;             /* Delay in microseconds between keys while\n                                     * loading aof or rdb. (for testings) */\n    /* Pipe and data structures for child -> parent info sharing. */\n    int child_info_pipe[2];         /* Pipe used to write the child_info_data. */\n    struct {\n        int process_type;           /* AOF or RDB child? */\n        size_t cow_size;            /* Copy on write size. */\n        unsigned long long magic;   /* Magic value to make sure data is valid. */\n    } child_info_data;\n    /* Propagation of commands in AOF / replication */\n    redisOpArray also_propagate;    /* Additional command to propagate. */\n    /* Logging */\n    char *logfile;                  /* Path of log file */\n    int syslog_enabled;             /* Is syslog enabled? */\n    char *syslog_ident;             /* Syslog ident */\n    int syslog_facility;            /* Syslog facility */\n    /* Replication (master) */\n    char replid[CONFIG_RUN_ID_SIZE+1];  /* My current replication ID. */\n    char replid2[CONFIG_RUN_ID_SIZE+1]; /* replid inherited from master*/\n    long long master_repl_offset;   /* My current replication offset */\n    long long second_replid_offset; /* Accept offsets up to this for replid2. */\n    int slaveseldb;                 /* Last SELECTed DB in replication output */\n    int repl_ping_slave_period;     /* Master pings the slave every N seconds */\n    char *repl_backlog;             /* Replication backlog for partial syncs */\n    long long repl_backlog_size;    /* Backlog circular buffer size */\n    long long repl_backlog_histlen; /* Backlog actual data length */\n    long long repl_backlog_idx;     /* Backlog circular buffer current offset,\n                                       that is the next byte will'll write to.*/\n    long long repl_backlog_off;     /* Replication \"master offset\" of first\n                                       byte in the replication backlog buffer.*/\n    time_t repl_backlog_time_limit; /* Time without slaves after the backlog\n                                       gets released. */\n    time_t repl_no_slaves_since;    /* We have no slaves since that time.\n                                       Only valid if server.slaves len is 0. */\n    int repl_min_slaves_to_write;   /* Min number of slaves to write. */\n    int repl_min_slaves_max_lag;    /* Max lag of <count> slaves to write. */\n    int repl_good_slaves_count;     /* Number of slaves with lag <= max_lag. */\n    int repl_diskless_sync;         /* Master send RDB to slaves sockets directly. */\n    int repl_diskless_load;         /* Slave parse RDB directly from the socket.\n                                     * see REPL_DISKLESS_LOAD_* enum */\n    int repl_diskless_sync_delay;   /* Delay to start a diskless repl BGSAVE. */\n    /* Replication (slave) */\n    char *masteruser;               /* AUTH with this user and masterauth with master */\n    char *masterauth;               /* AUTH with this password with master */\n    char *masterhost;               /* Hostname of master */\n    int masterport;                 /* Port of master */\n    int repl_timeout;               /* Timeout after N seconds of master idle */\n    client *master;     /* Client that is master for this slave */\n    client *cached_master; /* Cached master to be reused for PSYNC. */\n    int repl_syncio_timeout; /* Timeout for synchronous I/O calls */\n    int repl_state;          /* Replication status if the instance is a slave */\n    off_t repl_transfer_size; /* Size of RDB to read from master during sync. */\n    off_t repl_transfer_read; /* Amount of RDB read from master during sync. */\n    off_t repl_transfer_last_fsync_off; /* Offset when we fsync-ed last time. */\n    connection *repl_transfer_s;     /* Slave -> Master SYNC connection */\n    int repl_transfer_fd;    /* Slave -> Master SYNC temp file descriptor */\n    char *repl_transfer_tmpfile; /* Slave-> master SYNC temp file name */\n    time_t repl_transfer_lastio; /* Unix time of the latest read, for timeout */\n    int repl_serve_stale_data; /* Serve stale data when link is down? */\n    int repl_slave_ro;          /* Slave is read only? */\n    int repl_slave_ignore_maxmemory;    /* If true slaves do not evict. */\n    time_t repl_down_since; /* Unix time at which link with master went down */\n    int repl_disable_tcp_nodelay;   /* Disable TCP_NODELAY after SYNC? */\n    int slave_priority;             /* Reported in INFO and used by Sentinel. */\n    int slave_announce_port;        /* Give the master this listening port. */\n    char *slave_announce_ip;        /* Give the master this ip address. */\n    /* The following two fields is where we store master PSYNC replid/offset\n     * while the PSYNC is in progress. At the end we'll copy the fields into\n     * the server->master client structure. */\n    char master_replid[CONFIG_RUN_ID_SIZE+1];  /* Master PSYNC runid. */\n    long long master_initial_offset;           /* Master PSYNC offset. */\n    int repl_slave_lazy_flush;          /* Lazy FLUSHALL before loading DB? */\n    /* Replication script cache. */\n    dict *repl_scriptcache_dict;        /* SHA1 all slaves are aware of. */\n    list *repl_scriptcache_fifo;        /* First in, first out LRU eviction. */\n    unsigned int repl_scriptcache_size; /* Max number of elements. */\n    /* Synchronous replication. */\n    list *clients_waiting_acks;         /* Clients waiting in WAIT command. */\n    int get_ack_from_slaves;            /* If true we send REPLCONF GETACK. */\n    /* Limits */\n    unsigned int maxclients;            /* Max number of simultaneous clients */\n    unsigned long long maxmemory;   /* Max number of memory bytes to use */\n    int maxmemory_policy;           /* Policy for key eviction */\n    int maxmemory_samples;          /* Precision of random sampling */\n    int lfu_log_factor;             /* LFU logarithmic counter factor. */\n    int lfu_decay_time;             /* LFU counter decay factor. */\n    long long proto_max_bulk_len;   /* Protocol bulk length maximum size. */\n    int oom_score_adj_base;         /* Base oom_score_adj value, as observed on startup */\n    int oom_score_adj_values[CONFIG_OOM_COUNT];   /* Linux oom_score_adj configuration */\n    int oom_score_adj;                            /* If true, oom_score_adj is managed */\n    /* Blocked clients */\n    unsigned int blocked_clients;   /* # of clients executing a blocking cmd.*/\n    unsigned int blocked_clients_by_type[BLOCKED_NUM];\n    list *unblocked_clients; /* list of clients to unblock before next loop */\n    list *ready_keys;        /* List of readyList structures for BLPOP & co */\n    /* Client side caching. */\n    unsigned int tracking_clients;  /* # of clients with tracking enabled.*/\n    size_t tracking_table_max_keys; /* Max number of keys in tracking table. */\n    /* Sort parameters - qsort_r() is only available under BSD so we\n     * have to take this state global, in order to pass it to sortCompare() */\n    int sort_desc;\n    int sort_alpha;\n    int sort_bypattern;\n    int sort_store;\n    /* Zip structure config, see redis.conf for more information  */\n    size_t hash_max_ziplist_entries;\n    size_t hash_max_ziplist_value;\n    size_t set_max_intset_entries;\n    size_t zset_max_ziplist_entries;\n    size_t zset_max_ziplist_value;\n    size_t hll_sparse_max_bytes;\n    size_t stream_node_max_bytes;\n    long long stream_node_max_entries;\n    /* List parameters */\n    int list_max_ziplist_size;\n    int list_compress_depth;\n    /* time cache */\n    _Atomic time_t unixtime;    /* Unix time sampled every cron cycle. */\n    time_t timezone;            /* Cached timezone. As set by tzset(). */\n    int daylight_active;        /* Currently in daylight saving time. */\n    mstime_t mstime;            /* 'unixtime' in milliseconds. */\n    ustime_t ustime;            /* 'unixtime' in microseconds. */\n    /* Pubsub */\n    dict *pubsub_channels;  /* Map channels to list of subscribed clients */\n    list *pubsub_patterns;  /* A list of pubsub_patterns */\n    dict *pubsub_patterns_dict;  /* A dict of pubsub_patterns */\n    int notify_keyspace_events; /* Events to propagate via Pub/Sub. This is an\n                                   xor of NOTIFY_... flags. */\n    /* Cluster */\n    int cluster_enabled;      /* Is cluster enabled? */\n    mstime_t cluster_node_timeout; /* Cluster node timeout. */\n    char *cluster_configfile; /* Cluster auto-generated config file name. */\n    struct clusterState *cluster;  /* State of the cluster */\n    int cluster_migration_barrier; /* Cluster replicas migration barrier. */\n    int cluster_slave_validity_factor; /* Slave max data age for failover. */\n    int cluster_require_full_coverage; /* If true, put the cluster down if\n                                          there is at least an uncovered slot.*/\n    int cluster_slave_no_failover;  /* Prevent slave from starting a failover\n                                       if the master is in failure state. */\n    char *cluster_announce_ip;  /* IP address to announce on cluster bus. */\n    int cluster_announce_port;     /* base port to announce on cluster bus. */\n    int cluster_announce_bus_port; /* bus port to announce on cluster bus. */\n    int cluster_module_flags;      /* Set of flags that Redis modules are able\n                                      to set in order to suppress certain\n                                      native Redis Cluster features. Check the\n                                      REDISMODULE_CLUSTER_FLAG_*. */\n    int cluster_allow_reads_when_down; /* Are reads allowed when the cluster\n                                        is down? */\n    int cluster_config_file_lock_fd;   /* cluster config fd, will be flock */\n    /* Scripting */\n    lua_State *lua; /* The Lua interpreter. We use just one for all clients */\n    client *lua_client;   /* The \"fake client\" to query Redis from Lua */\n    client *lua_caller;   /* The client running EVAL right now, or NULL */\n    char* lua_cur_script; /* SHA1 of the script currently running, or NULL */\n    dict *lua_scripts;         /* A dictionary of SHA1 -> Lua scripts */\n    unsigned long long lua_scripts_mem;  /* Cached scripts' memory + oh */\n    mstime_t lua_time_limit;  /* Script timeout in milliseconds */\n    mstime_t lua_time_start;  /* Start time of script, milliseconds time */\n    int lua_write_dirty;  /* True if a write command was called during the\n                             execution of the current script. */\n    int lua_random_dirty; /* True if a random command was called during the\n                             execution of the current script. */\n    int lua_replicate_commands; /* True if we are doing single commands repl. */\n    int lua_multi_emitted;/* True if we already propagated MULTI. */\n    int lua_repl;         /* Script replication flags for redis.set_repl(). */\n    int lua_timedout;     /* True if we reached the time limit for script\n                             execution. */\n    int lua_kill;         /* Kill the script if true. */\n    int lua_always_replicate_commands; /* Default replication type. */\n    int lua_oom;          /* OOM detected when script start? */\n    /* Lazy free */\n    int lazyfree_lazy_eviction;\n    int lazyfree_lazy_expire;\n    int lazyfree_lazy_server_del;\n    int lazyfree_lazy_user_del;\n    /* Latency monitor */\n    long long latency_monitor_threshold;\n    dict *latency_events;\n    /* ACLs */\n    char *acl_filename;     /* ACL Users file. NULL if not configured. */\n    unsigned long acllog_max_len; /* Maximum length of the ACL LOG list. */\n    sds requirepass;        /* Remember the cleartext password set with the\n                               old \"requirepass\" directive for backward\n                               compatibility with Redis <= 5. */\n    /* Assert & bug reporting */\n    const char *assert_failed;\n    const char *assert_file;\n    int assert_line;\n    int bug_report_start; /* True if bug report header was already logged. */\n    int watchdog_period;  /* Software watchdog period in ms. 0 = off */\n    /* System hardware info */\n    size_t system_memory_size;  /* Total memory in system as reported by OS */\n    /* TLS Configuration */\n    int tls_cluster;\n    int tls_replication;\n    int tls_auth_clients;\n    redisTLSContextConfig tls_ctx_config;\n    /* cpu affinity */\n    char *server_cpulist; /* cpu affinity list of redis server main/io thread. */\n    char *bio_cpulist; /* cpu affinity list of bio thread. */\n    char *aof_rewrite_cpulist; /* cpu affinity list of aof rewrite process. */\n    char *bgsave_cpulist; /* cpu affinity list of bgsave process. */\n};\n\ntypedef struct pubsubPattern {\n    client *client;\n    robj *pattern;\n} pubsubPattern;\n\n#define MAX_KEYS_BUFFER 256\n\n/* A result structure for the various getkeys function calls. It lists the\n * keys as indices to the provided argv.\n */\ntypedef struct {\n    int keysbuf[MAX_KEYS_BUFFER];       /* Pre-allocated buffer, to save heap allocations */\n    int *keys;                          /* Key indices array, points to keysbuf or heap */\n    int numkeys;                        /* Number of key indices return */\n    int size;                           /* Available array size */\n} getKeysResult;\n#define GETKEYS_RESULT_INIT { {0}, NULL, 0, MAX_KEYS_BUFFER }\n\ntypedef void redisCommandProc(client *c);\ntypedef int redisGetKeysProc(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result);\nstruct redisCommand {\n    char *name;\n    redisCommandProc *proc;\n    int arity;\n    char *sflags;   /* Flags as string representation, one char per flag. */\n    uint64_t flags; /* The actual flags, obtained from the 'sflags' field. */\n    /* Use a function to determine keys arguments in a command line.\n     * Used for Redis Cluster redirect. */\n    redisGetKeysProc *getkeys_proc;\n    /* What keys should be loaded in background when calling this command? */\n    int firstkey; /* The first argument that's a key (0 = no keys) */\n    int lastkey;  /* The last argument that's a key */\n    int keystep;  /* The step between first and last key */\n    long long microseconds, calls;\n    int id;     /* Command ID. This is a progressive ID starting from 0 that\n                   is assigned at runtime, and is used in order to check\n                   ACLs. A connection is able to execute a given command if\n                   the user associated to the connection has this command\n                   bit set in the bitmap of allowed commands. */\n};\n\nstruct redisFunctionSym {\n    char *name;\n    unsigned long pointer;\n};\n\ntypedef struct _redisSortObject {\n    robj *obj;\n    union {\n        double score;\n        robj *cmpobj;\n    } u;\n} redisSortObject;\n\ntypedef struct _redisSortOperation {\n    int type;\n    robj *pattern;\n} redisSortOperation;\n\n/* Structure to hold list iteration abstraction. */\ntypedef struct {\n    robj *subject;\n    unsigned char encoding;\n    unsigned char direction; /* Iteration direction */\n    quicklistIter *iter;\n} listTypeIterator;\n\n/* Structure for an entry while iterating over a list. */\ntypedef struct {\n    listTypeIterator *li;\n    quicklistEntry entry; /* Entry in quicklist */\n} listTypeEntry;\n\n/* Structure to hold set iteration abstraction. */\ntypedef struct {\n    robj *subject;\n    int encoding;\n    int ii; /* intset iterator */\n    dictIterator *di;\n} setTypeIterator;\n\n/* Structure to hold hash iteration abstraction. Note that iteration over\n * hashes involves both fields and values. Because it is possible that\n * not both are required, store pointers in the iterator to avoid\n * unnecessary memory allocation for fields/values. */\ntypedef struct {\n    robj *subject;\n    int encoding;\n\n    unsigned char *fptr, *vptr;\n\n    dictIterator *di;\n    dictEntry *de;\n} hashTypeIterator;\n\n#include \"stream.h\"  /* Stream data type header file. */\n\n#define OBJ_HASH_KEY 1\n#define OBJ_HASH_VALUE 2\n\n/*-----------------------------------------------------------------------------\n * Extern declarations\n *----------------------------------------------------------------------------*/\n\nextern struct redisServer server;\nextern struct sharedObjectsStruct shared;\nextern dictType objectKeyPointerValueDictType;\nextern dictType objectKeyHeapPointerValueDictType;\nextern dictType setDictType;\nextern dictType zsetDictType;\nextern dictType clusterNodesDictType;\nextern dictType clusterNodesBlackListDictType;\nextern dictType dbDictType;\nextern dictType shaScriptObjectDictType;\nextern double R_Zero, R_PosInf, R_NegInf, R_Nan;\nextern dictType hashDictType;\nextern dictType replScriptCacheDictType;\nextern dictType keyptrDictType;\nextern dictType modulesDictType;\n\n/*-----------------------------------------------------------------------------\n * Functions prototypes\n *----------------------------------------------------------------------------*/\n\n/* Modules */\nvoid moduleInitModulesSystem(void);\nint moduleLoad(const char *path, void **argv, int argc);\nvoid moduleLoadFromQueue(void);\nint moduleGetCommandKeysViaAPI(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result);\nmoduleType *moduleTypeLookupModuleByID(uint64_t id);\nvoid moduleTypeNameByID(char *name, uint64_t moduleid);\nvoid moduleFreeContext(struct RedisModuleCtx *ctx);\nvoid unblockClientFromModule(client *c);\nvoid moduleHandleBlockedClients(void);\nvoid moduleBlockedClientTimedOut(client *c);\nvoid moduleBlockedClientPipeReadable(aeEventLoop *el, int fd, void *privdata, int mask);\nsize_t moduleCount(void);\nvoid moduleAcquireGIL(void);\nint moduleTryAcquireGIL(void);\nvoid moduleReleaseGIL(void);\nvoid moduleNotifyKeyspaceEvent(int type, const char *event, robj *key, int dbid);\nvoid moduleCallCommandFilters(client *c);\nvoid ModuleForkDoneHandler(int exitcode, int bysignal);\nint TerminateModuleForkChild(int child_pid, int wait);\nssize_t rdbSaveModulesAux(rio *rdb, int when);\nint moduleAllDatatypesHandleErrors();\nsds modulesCollectInfo(sds info, const char *section, int for_crash_report, int sections);\nvoid moduleFireServerEvent(uint64_t eid, int subid, void *data);\nvoid processModuleLoadingProgressEvent(int is_aof);\nint moduleTryServeClientBlockedOnKey(client *c, robj *key);\nvoid moduleUnblockClient(client *c);\nint moduleClientIsBlockedOnKeys(client *c);\nvoid moduleNotifyUserChanged(client *c);\n\n/* Utils */\nlong long ustime(void);\nlong long mstime(void);\nvoid getRandomHexChars(char *p, size_t len);\nvoid getRandomBytes(unsigned char *p, size_t len);\nuint64_t crc64(uint64_t crc, const unsigned char *s, uint64_t l);\nvoid exitFromChild(int retcode);\nlong long redisPopcount(void *s, long count);\nvoid redisSetProcTitle(char *title);\nint redisCommunicateSystemd(const char *sd_notify_msg);\nvoid redisSetCpuAffinity(const char *cpulist);\n\n/* networking.c -- Networking and Client related operations */\nclient *createClient(connection *conn);\nvoid closeTimedoutClients(void);\nvoid freeClient(client *c);\nvoid freeClientAsync(client *c);\nvoid resetClient(client *c);\nvoid sendReplyToClient(connection *conn);\nvoid *addReplyDeferredLen(client *c);\nvoid setDeferredArrayLen(client *c, void *node, long length);\nvoid setDeferredMapLen(client *c, void *node, long length);\nvoid setDeferredSetLen(client *c, void *node, long length);\nvoid setDeferredAttributeLen(client *c, void *node, long length);\nvoid setDeferredPushLen(client *c, void *node, long length);\nvoid processInputBuffer(client *c);\nvoid processGopherRequest(client *c);\nvoid acceptHandler(aeEventLoop *el, int fd, void *privdata, int mask);\nvoid acceptTcpHandler(aeEventLoop *el, int fd, void *privdata, int mask);\nvoid acceptTLSHandler(aeEventLoop *el, int fd, void *privdata, int mask);\nvoid acceptUnixHandler(aeEventLoop *el, int fd, void *privdata, int mask);\nvoid readQueryFromClient(connection *conn);\nvoid addReplyNull(client *c);\nvoid addReplyNullArray(client *c);\nvoid addReplyBool(client *c, int b);\nvoid addReplyVerbatim(client *c, const char *s, size_t len, const char *ext);\nvoid addReplyProto(client *c, const char *s, size_t len);\nvoid AddReplyFromClient(client *c, client *src);\nvoid addReplyBulk(client *c, robj *obj);\nvoid addReplyBulkCString(client *c, const char *s);\nvoid addReplyBulkCBuffer(client *c, const void *p, size_t len);\nvoid addReplyBulkLongLong(client *c, long long ll);\nvoid addReply(client *c, robj *obj);\nvoid addReplySds(client *c, sds s);\nvoid addReplyBulkSds(client *c, sds s);\nvoid addReplyErrorObject(client *c, robj *err);\nvoid addReplyErrorSds(client *c, sds err);\nvoid addReplyError(client *c, const char *err);\nvoid addReplyStatus(client *c, const char *status);\nvoid addReplyDouble(client *c, double d);\nvoid addReplyBigNum(client *c, const char* num, size_t len);\nvoid addReplyHumanLongDouble(client *c, long double d);\nvoid addReplyLongLong(client *c, long long ll);\nvoid addReplyArrayLen(client *c, long length);\nvoid addReplyMapLen(client *c, long length);\nvoid addReplySetLen(client *c, long length);\nvoid addReplyAttributeLen(client *c, long length);\nvoid addReplyPushLen(client *c, long length);\nvoid addReplyHelp(client *c, const char **help);\nvoid addReplySubcommandSyntaxError(client *c);\nvoid addReplyLoadedModules(client *c);\nvoid copyClientOutputBuffer(client *dst, client *src);\nsize_t sdsZmallocSize(sds s);\nsize_t getStringObjectSdsUsedMemory(robj *o);\nvoid freeClientReplyValue(void *o);\nvoid *dupClientReplyValue(void *o);\nvoid getClientsMaxBuffers(unsigned long *longest_output_list,\n                          unsigned long *biggest_input_buffer);\nchar *getClientPeerId(client *client);\nsds catClientInfoString(sds s, client *client);\nsds getAllClientsInfoString(int type);\nvoid rewriteClientCommandVector(client *c, int argc, ...);\nvoid rewriteClientCommandArgument(client *c, int i, robj *newval);\nvoid replaceClientCommandVector(client *c, int argc, robj **argv);\nunsigned long getClientOutputBufferMemoryUsage(client *c);\nint freeClientsInAsyncFreeQueue(void);\nvoid asyncCloseClientOnOutputBufferLimitReached(client *c);\nint getClientType(client *c);\nint getClientTypeByName(char *name);\nchar *getClientTypeName(int class);\nvoid flushSlavesOutputBuffers(void);\nvoid disconnectSlaves(void);\nint listenToPort(int port, int *fds, int *count);\nvoid pauseClients(mstime_t duration);\nint clientsArePaused(void);\nvoid processEventsWhileBlocked(void);\nint handleClientsWithPendingWrites(void);\nint handleClientsWithPendingWritesUsingThreads(void);\nint handleClientsWithPendingReadsUsingThreads(void);\nint stopThreadedIOIfNeeded(void);\nint clientHasPendingReplies(client *c);\nvoid unlinkClient(client *c);\nint writeToClient(client *c, int handler_installed);\nvoid linkClient(client *c);\nvoid protectClient(client *c);\nvoid unprotectClient(client *c);\nvoid initThreadedIO(void);\nclient *lookupClientByID(uint64_t id);\n\n#ifdef __GNUC__\nvoid addReplyErrorFormat(client *c, const char *fmt, ...)\n    __attribute__((format(printf, 2, 3)));\nvoid addReplyStatusFormat(client *c, const char *fmt, ...)\n    __attribute__((format(printf, 2, 3)));\n#else\nvoid addReplyErrorFormat(client *c, const char *fmt, ...);\nvoid addReplyStatusFormat(client *c, const char *fmt, ...);\n#endif\n\n/* Client side caching (tracking mode) */\nvoid enableTracking(client *c, uint64_t redirect_to, uint64_t options, robj **prefix, size_t numprefix);\nvoid disableTracking(client *c);\nvoid trackingRememberKeys(client *c);\nvoid trackingInvalidateKey(client *c, robj *keyobj);\nvoid trackingInvalidateKeysOnFlush(int dbid);\nvoid trackingLimitUsedSlots(void);\nuint64_t trackingGetTotalItems(void);\nuint64_t trackingGetTotalKeys(void);\nuint64_t trackingGetTotalPrefixes(void);\nvoid trackingBroadcastInvalidationMessages(void);\n\n/* List data type */\nvoid listTypeTryConversion(robj *subject, robj *value);\nvoid listTypePush(robj *subject, robj *value, int where);\nrobj *listTypePop(robj *subject, int where);\nunsigned long listTypeLength(const robj *subject);\nlistTypeIterator *listTypeInitIterator(robj *subject, long index, unsigned char direction);\nvoid listTypeReleaseIterator(listTypeIterator *li);\nint listTypeNext(listTypeIterator *li, listTypeEntry *entry);\nrobj *listTypeGet(listTypeEntry *entry);\nvoid listTypeInsert(listTypeEntry *entry, robj *value, int where);\nint listTypeEqual(listTypeEntry *entry, robj *o);\nvoid listTypeDelete(listTypeIterator *iter, listTypeEntry *entry);\nvoid listTypeConvert(robj *subject, int enc);\nvoid unblockClientWaitingData(client *c);\nvoid popGenericCommand(client *c, int where);\n\n/* MULTI/EXEC/WATCH... */\nvoid unwatchAllKeys(client *c);\nvoid initClientMultiState(client *c);\nvoid freeClientMultiState(client *c);\nvoid queueMultiCommand(client *c);\nvoid touchWatchedKey(redisDb *db, robj *key);\nint isWatchedKeyExpired(client *c);\nvoid touchAllWatchedKeysInDb(redisDb *emptied, redisDb *replaced_with);\nvoid discardTransaction(client *c);\nvoid flagTransaction(client *c);\nvoid execCommandAbort(client *c, sds error);\nvoid execCommandPropagateMulti(client *c);\nvoid execCommandPropagateExec(client *c);\n\n/* Redis object implementation */\nvoid decrRefCount(robj *o);\nvoid decrRefCountVoid(void *o);\nvoid incrRefCount(robj *o);\nrobj *makeObjectShared(robj *o);\nrobj *resetRefCount(robj *obj);\nvoid freeStringObject(robj *o);\nvoid freeListObject(robj *o);\nvoid freeSetObject(robj *o);\nvoid freeZsetObject(robj *o);\nvoid freeHashObject(robj *o);\nrobj *createObject(int type, void *ptr);\nrobj *createStringObject(const char *ptr, size_t len);\nrobj *createRawStringObject(const char *ptr, size_t len);\nrobj *createEmbeddedStringObject(const char *ptr, size_t len);\nrobj *dupStringObject(const robj *o);\nint isSdsRepresentableAsLongLong(sds s, long long *llval);\nint isObjectRepresentableAsLongLong(robj *o, long long *llongval);\nrobj *tryObjectEncoding(robj *o);\nrobj *getDecodedObject(robj *o);\nsize_t stringObjectLen(robj *o);\nrobj *createStringObjectFromLongLong(long long value);\nrobj *createStringObjectFromLongLongForValue(long long value);\nrobj *createStringObjectFromLongDouble(long double value, int humanfriendly);\nrobj *createQuicklistObject(void);\nrobj *createZiplistObject(void);\nrobj *createSetObject(void);\nrobj *createIntsetObject(void);\nrobj *createHashObject(void);\nrobj *createZsetObject(void);\nrobj *createZsetZiplistObject(void);\nrobj *createStreamObject(void);\nrobj *createModuleObject(moduleType *mt, void *value);\nint getLongFromObjectOrReply(client *c, robj *o, long *target, const char *msg);\nint checkType(client *c, robj *o, int type);\nint getLongLongFromObjectOrReply(client *c, robj *o, long long *target, const char *msg);\nint getDoubleFromObjectOrReply(client *c, robj *o, double *target, const char *msg);\nint getDoubleFromObject(const robj *o, double *target);\nint getLongLongFromObject(robj *o, long long *target);\nint getLongDoubleFromObject(robj *o, long double *target);\nint getLongDoubleFromObjectOrReply(client *c, robj *o, long double *target, const char *msg);\nchar *strEncoding(int encoding);\nint compareStringObjects(robj *a, robj *b);\nint collateStringObjects(robj *a, robj *b);\nint equalStringObjects(robj *a, robj *b);\nunsigned long long estimateObjectIdleTime(robj *o);\nvoid trimStringObjectIfNeeded(robj *o);\n#define sdsEncodedObject(objptr) (objptr->encoding == OBJ_ENCODING_RAW || objptr->encoding == OBJ_ENCODING_EMBSTR)\n\n/* Synchronous I/O with timeout */\nssize_t syncWrite(int fd, char *ptr, ssize_t size, long long timeout);\nssize_t syncRead(int fd, char *ptr, ssize_t size, long long timeout);\nssize_t syncReadLine(int fd, char *ptr, ssize_t size, long long timeout);\n\n/* Replication */\nvoid replicationFeedSlaves(list *slaves, int dictid, robj **argv, int argc);\nvoid replicationFeedSlavesFromMasterStream(list *slaves, char *buf, size_t buflen);\nvoid replicationFeedMonitors(client *c, list *monitors, int dictid, robj **argv, int argc);\nvoid updateSlavesWaitingBgsave(int bgsaveerr, int type);\nvoid replicationCron(void);\nvoid replicationHandleMasterDisconnection(void);\nvoid replicationCacheMaster(client *c);\nvoid resizeReplicationBacklog(long long newsize);\nvoid replicationSetMaster(char *ip, int port);\nvoid replicationUnsetMaster(void);\nvoid refreshGoodSlavesCount(void);\nvoid replicationScriptCacheInit(void);\nvoid replicationScriptCacheFlush(void);\nvoid replicationScriptCacheAdd(sds sha1);\nint replicationScriptCacheExists(sds sha1);\nvoid processClientsWaitingReplicas(void);\nvoid unblockClientWaitingReplicas(client *c);\nint replicationCountAcksByOffset(long long offset);\nvoid replicationSendNewlineToMaster(void);\nlong long replicationGetSlaveOffset(void);\nchar *replicationGetSlaveName(client *c);\nlong long getPsyncInitialOffset(void);\nint replicationSetupSlaveForFullResync(client *slave, long long offset);\nvoid changeReplicationId(void);\nvoid clearReplicationId2(void);\nvoid chopReplicationBacklog(void);\nvoid replicationCacheMasterUsingMyself(void);\nvoid feedReplicationBacklog(void *ptr, size_t len);\nvoid showLatestBacklog(void);\nvoid rdbPipeReadHandler(struct aeEventLoop *eventLoop, int fd, void *clientData, int mask);\nvoid rdbPipeWriteHandlerConnRemoved(struct connection *conn);\n\n/* Generic persistence functions */\nvoid startLoadingFile(FILE* fp, char* filename, int rdbflags);\nvoid startLoading(size_t size, int rdbflags);\nvoid loadingProgress(off_t pos);\nvoid stopLoading(int success);\nvoid startSaving(int rdbflags);\nvoid stopSaving(int success);\nint allPersistenceDisabled(void);\n\n#define DISK_ERROR_TYPE_AOF 1       /* Don't accept writes: AOF errors. */\n#define DISK_ERROR_TYPE_RDB 2       /* Don't accept writes: RDB errors. */\n#define DISK_ERROR_TYPE_NONE 0      /* No problems, we can accept writes. */\nint writeCommandsDeniedByDiskError(void);\n\n/* RDB persistence */\n#include \"rdb.h\"\nvoid killRDBChild(void);\nint bg_unlink(const char *filename);\n\n/* AOF persistence */\nvoid flushAppendOnlyFile(int force);\nvoid feedAppendOnlyFile(struct redisCommand *cmd, int dictid, robj **argv, int argc);\nvoid aofRemoveTempFile(pid_t childpid);\nint rewriteAppendOnlyFileBackground(void);\nint loadAppendOnlyFile(char *filename);\nvoid stopAppendOnly(void);\nint startAppendOnly(void);\nvoid backgroundRewriteDoneHandler(int exitcode, int bysignal);\nvoid aofRewriteBufferReset(void);\nunsigned long aofRewriteBufferSize(void);\nssize_t aofReadDiffFromParent(void);\nvoid killAppendOnlyChild(void);\nvoid restartAOFAfterSYNC();\n\n/* Child info */\nvoid openChildInfoPipe(void);\nvoid closeChildInfoPipe(void);\nvoid sendChildInfo(int process_type);\nvoid receiveChildInfo(void);\n\n/* Fork helpers */\nint redisFork(int type);\nint hasActiveChildProcess();\nvoid sendChildCOWInfo(int ptype, char *pname);\n\n/* acl.c -- Authentication related prototypes. */\nextern rax *Users;\nextern user *DefaultUser;\nvoid ACLInit(void);\n/* Return values for ACLCheckUserCredentials(). */\n#define ACL_OK 0\n#define ACL_DENIED_CMD 1\n#define ACL_DENIED_KEY 2\n#define ACL_DENIED_AUTH 3 /* Only used for ACL LOG entries. */\nint ACLCheckUserCredentials(robj *username, robj *password);\nint ACLAuthenticateUser(client *c, robj *username, robj *password);\nunsigned long ACLGetCommandID(const char *cmdname);\nuser *ACLGetUserByName(const char *name, size_t namelen);\nint ACLCheckCommandPerm(client *c, int *keyidxptr);\nint ACLSetUser(user *u, const char *op, ssize_t oplen);\nsds ACLDefaultUserFirstPassword(void);\nuint64_t ACLGetCommandCategoryFlagByName(const char *name);\nint ACLAppendUserForLoading(sds *argv, int argc, int *argc_err);\nchar *ACLSetUserStringError(void);\nint ACLLoadConfiguredUsers(void);\nsds ACLDescribeUser(user *u);\nvoid ACLLoadUsersAtStartup(void);\nvoid addReplyCommandCategories(client *c, struct redisCommand *cmd);\nuser *ACLCreateUnlinkedUser();\nvoid ACLFreeUserAndKillClients(user *u);\nvoid addACLLogEntry(client *c, int reason, int keypos, sds username);\n\n/* Sorted sets data type */\n\n/* Input flags. */\n#define ZADD_NONE 0\n#define ZADD_INCR (1<<0)    /* Increment the score instead of setting it. */\n#define ZADD_NX (1<<1)      /* Don't touch elements not already existing. */\n#define ZADD_XX (1<<2)      /* Only touch elements already existing. */\n\n/* Output flags. */\n#define ZADD_NOP (1<<3)     /* Operation not performed because of conditionals.*/\n#define ZADD_NAN (1<<4)     /* Only touch elements already existing. */\n#define ZADD_ADDED (1<<5)   /* The element was new and was added. */\n#define ZADD_UPDATED (1<<6) /* The element already existed, score updated. */\n\n/* Flags only used by the ZADD command but not by zsetAdd() API: */\n#define ZADD_CH (1<<16)      /* Return num of elements added or updated. */\n\n/* Struct to hold an inclusive/exclusive range spec by score comparison. */\ntypedef struct {\n    double min, max;\n    int minex, maxex; /* are min or max exclusive? */\n} zrangespec;\n\n/* Struct to hold an inclusive/exclusive range spec by lexicographic comparison. */\ntypedef struct {\n    sds min, max;     /* May be set to shared.(minstring|maxstring) */\n    int minex, maxex; /* are min or max exclusive? */\n} zlexrangespec;\n\nzskiplist *zslCreate(void);\nvoid zslFree(zskiplist *zsl);\nzskiplistNode *zslInsert(zskiplist *zsl, double score, sds ele);\nunsigned char *zzlInsert(unsigned char *zl, sds ele, double score);\nint zslDelete(zskiplist *zsl, double score, sds ele, zskiplistNode **node);\nzskiplistNode *zslFirstInRange(zskiplist *zsl, zrangespec *range);\nzskiplistNode *zslLastInRange(zskiplist *zsl, zrangespec *range);\ndouble zzlGetScore(unsigned char *sptr);\nvoid zzlNext(unsigned char *zl, unsigned char **eptr, unsigned char **sptr);\nvoid zzlPrev(unsigned char *zl, unsigned char **eptr, unsigned char **sptr);\nunsigned char *zzlFirstInRange(unsigned char *zl, zrangespec *range);\nunsigned char *zzlLastInRange(unsigned char *zl, zrangespec *range);\nunsigned long zsetLength(const robj *zobj);\nvoid zsetConvert(robj *zobj, int encoding);\nvoid zsetConvertToZiplistIfNeeded(robj *zobj, size_t maxelelen);\nint zsetScore(robj *zobj, sds member, double *score);\nunsigned long zslGetRank(zskiplist *zsl, double score, sds o);\nint zsetAdd(robj *zobj, double score, sds ele, int *flags, double *newscore);\nlong zsetRank(robj *zobj, sds ele, int reverse);\nint zsetDel(robj *zobj, sds ele);\nvoid genericZpopCommand(client *c, robj **keyv, int keyc, int where, int emitkey, robj *countarg);\nsds ziplistGetObject(unsigned char *sptr);\nint zslValueGteMin(double value, zrangespec *spec);\nint zslValueLteMax(double value, zrangespec *spec);\nvoid zslFreeLexRange(zlexrangespec *spec);\nint zslParseLexRange(robj *min, robj *max, zlexrangespec *spec);\nunsigned char *zzlFirstInLexRange(unsigned char *zl, zlexrangespec *range);\nunsigned char *zzlLastInLexRange(unsigned char *zl, zlexrangespec *range);\nzskiplistNode *zslFirstInLexRange(zskiplist *zsl, zlexrangespec *range);\nzskiplistNode *zslLastInLexRange(zskiplist *zsl, zlexrangespec *range);\nint zzlLexValueGteMin(unsigned char *p, zlexrangespec *spec);\nint zzlLexValueLteMax(unsigned char *p, zlexrangespec *spec);\nint zslLexValueGteMin(sds value, zlexrangespec *spec);\nint zslLexValueLteMax(sds value, zlexrangespec *spec);\n\n/* Core functions */\nint getMaxmemoryState(size_t *total, size_t *logical, size_t *tofree, float *level);\nsize_t freeMemoryGetNotCountedMemory();\nint freeMemoryIfNeeded(void);\nint freeMemoryIfNeededAndSafe(void);\nint processCommand(client *c);\nint processPendingCommandsAndResetClient(client *c);\nvoid setupSignalHandlers(void);\nstruct redisCommand *lookupCommand(sds name);\nstruct redisCommand *lookupCommandByCString(const char *s);\nstruct redisCommand *lookupCommandOrOriginal(sds name);\nvoid call(client *c, int flags);\nvoid propagate(struct redisCommand *cmd, int dbid, robj **argv, int argc, int flags);\nvoid alsoPropagate(struct redisCommand *cmd, int dbid, robj **argv, int argc, int target);\nvoid redisOpArrayInit(redisOpArray *oa);\nvoid redisOpArrayFree(redisOpArray *oa);\nvoid forceCommandPropagation(client *c, int flags);\nvoid preventCommandPropagation(client *c);\nvoid preventCommandAOF(client *c);\nvoid preventCommandReplication(client *c);\nint prepareForShutdown(int flags);\n#ifdef __GNUC__\nvoid serverLog(int level, const char *fmt, ...)\n    __attribute__((format(printf, 2, 3)));\n#else\nvoid serverLog(int level, const char *fmt, ...);\n#endif\nvoid serverLogRaw(int level, const char *msg);\nvoid serverLogFromHandler(int level, const char *msg);\nvoid usage(void);\nvoid updateDictResizePolicy(void);\nint htNeedsResize(dict *dict);\nvoid populateCommandTable(void);\nvoid resetCommandTableStats(void);\nvoid adjustOpenFilesLimit(void);\nvoid closeListeningSockets(int unlink_unix_socket);\nvoid updateCachedTime(int update_daylight_info);\nvoid resetServerStats(void);\nvoid activeDefragCycle(void);\nunsigned int getLRUClock(void);\nunsigned int LRU_CLOCK(void);\nconst char *evictPolicyToString(void);\nstruct redisMemOverhead *getMemoryOverheadData(void);\nvoid freeMemoryOverheadData(struct redisMemOverhead *mh);\nvoid checkChildrenDone(void);\nint setOOMScoreAdj(int process_class);\n\n#define RESTART_SERVER_NONE 0\n#define RESTART_SERVER_GRACEFULLY (1<<0)     /* Do proper shutdown. */\n#define RESTART_SERVER_CONFIG_REWRITE (1<<1) /* CONFIG REWRITE before restart.*/\nint restartServer(int flags, mstime_t delay);\n\n/* Set data type */\nrobj *setTypeCreate(sds value);\nint setTypeAdd(robj *subject, sds value);\nint setTypeRemove(robj *subject, sds value);\nint setTypeIsMember(robj *subject, sds value);\nsetTypeIterator *setTypeInitIterator(robj *subject);\nvoid setTypeReleaseIterator(setTypeIterator *si);\nint setTypeNext(setTypeIterator *si, sds *sdsele, int64_t *llele);\nsds setTypeNextObject(setTypeIterator *si);\nint setTypeRandomElement(robj *setobj, sds *sdsele, int64_t *llele);\nunsigned long setTypeRandomElements(robj *set, unsigned long count, robj *aux_set);\nunsigned long setTypeSize(const robj *subject);\nvoid setTypeConvert(robj *subject, int enc);\n\n/* Hash data type */\n#define HASH_SET_TAKE_FIELD (1<<0)\n#define HASH_SET_TAKE_VALUE (1<<1)\n#define HASH_SET_COPY 0\n\nvoid hashTypeConvert(robj *o, int enc);\nvoid hashTypeTryConversion(robj *subject, robj **argv, int start, int end);\nint hashTypeExists(robj *o, sds key);\nint hashTypeDelete(robj *o, sds key);\nunsigned long hashTypeLength(const robj *o);\nhashTypeIterator *hashTypeInitIterator(robj *subject);\nvoid hashTypeReleaseIterator(hashTypeIterator *hi);\nint hashTypeNext(hashTypeIterator *hi);\nvoid hashTypeCurrentFromZiplist(hashTypeIterator *hi, int what,\n                                unsigned char **vstr,\n                                unsigned int *vlen,\n                                long long *vll);\nsds hashTypeCurrentFromHashTable(hashTypeIterator *hi, int what);\nvoid hashTypeCurrentObject(hashTypeIterator *hi, int what, unsigned char **vstr, unsigned int *vlen, long long *vll);\nsds hashTypeCurrentObjectNewSds(hashTypeIterator *hi, int what);\nrobj *hashTypeLookupWriteOrCreate(client *c, robj *key);\nrobj *hashTypeGetValueObject(robj *o, sds field);\nint hashTypeSet(robj *o, sds field, sds value, int flags);\n\n/* Pub / Sub */\nint pubsubUnsubscribeAllChannels(client *c, int notify);\nint pubsubUnsubscribeAllPatterns(client *c, int notify);\nvoid freePubsubPattern(void *p);\nint listMatchPubsubPattern(void *a, void *b);\nint pubsubPublishMessage(robj *channel, robj *message);\nvoid addReplyPubsubMessage(client *c, robj *channel, robj *msg);\n\n/* Keyspace events notification */\nvoid notifyKeyspaceEvent(int type, char *event, robj *key, int dbid);\nint keyspaceEventsStringToFlags(char *classes);\nsds keyspaceEventsFlagsToString(int flags);\n\n/* Configuration */\nvoid loadServerConfig(char *filename, char *options);\nvoid appendServerSaveParams(time_t seconds, int changes);\nvoid resetServerSaveParams(void);\nstruct rewriteConfigState; /* Forward declaration to export API. */\nvoid rewriteConfigRewriteLine(struct rewriteConfigState *state, const char *option, sds line, int force);\nint rewriteConfig(char *path, int force_all);\nvoid initConfigValues();\n\n/* db.c -- Keyspace access API */\nint removeExpire(redisDb *db, robj *key);\nvoid propagateExpire(redisDb *db, robj *key, int lazy);\nint keyIsExpired(redisDb *db, robj *key);\nint expireIfNeeded(redisDb *db, robj *key);\nlong long getExpire(redisDb *db, robj *key);\nvoid setExpire(client *c, redisDb *db, robj *key, long long when);\nint checkAlreadyExpired(long long when);\nrobj *lookupKey(redisDb *db, robj *key, int flags);\nrobj *lookupKeyRead(redisDb *db, robj *key);\nrobj *lookupKeyWrite(redisDb *db, robj *key);\nrobj *lookupKeyReadOrReply(client *c, robj *key, robj *reply);\nrobj *lookupKeyWriteOrReply(client *c, robj *key, robj *reply);\nrobj *lookupKeyReadWithFlags(redisDb *db, robj *key, int flags);\nrobj *lookupKeyWriteWithFlags(redisDb *db, robj *key, int flags);\nrobj *objectCommandLookup(client *c, robj *key);\nrobj *objectCommandLookupOrReply(client *c, robj *key, robj *reply);\nint objectSetLRUOrLFU(robj *val, long long lfu_freq, long long lru_idle,\n                       long long lru_clock, int lru_multiplier);\n#define LOOKUP_NONE 0\n#define LOOKUP_NOTOUCH (1<<0)\n#define LOOKUP_NONOTIFY (1<<1)\nvoid dbAdd(redisDb *db, robj *key, robj *val);\nint dbAddRDBLoad(redisDb *db, sds key, robj *val);\nvoid dbOverwrite(redisDb *db, robj *key, robj *val);\nvoid genericSetKey(client *c, redisDb *db, robj *key, robj *val, int keepttl, int signal);\nvoid setKey(client *c, redisDb *db, robj *key, robj *val);\nint dbExists(redisDb *db, robj *key);\nrobj *dbRandomKey(redisDb *db);\nint dbSyncDelete(redisDb *db, robj *key);\nint dbDelete(redisDb *db, robj *key);\nrobj *dbUnshareStringValue(redisDb *db, robj *key, robj *o);\n\n#define EMPTYDB_NO_FLAGS 0      /* No flags. */\n#define EMPTYDB_ASYNC (1<<0)    /* Reclaim memory in another thread. */\nlong long emptyDb(int dbnum, int flags, void(callback)(void*));\nlong long emptyDbStructure(redisDb *dbarray, int dbnum, int async, void(callback)(void*));\nvoid flushAllDataAndResetRDB(int flags);\nlong long dbTotalServerKeyCount();\ndbBackup *backupDb(void);\nvoid restoreDbBackup(dbBackup *buckup);\nvoid discardDbBackup(dbBackup *buckup, int flags, void(callback)(void*));\n\n\nint selectDb(client *c, int id);\nvoid signalModifiedKey(client *c, redisDb *db, robj *key);\nvoid signalFlushedDb(int dbid);\nunsigned int getKeysInSlot(unsigned int hashslot, robj **keys, unsigned int count);\nunsigned int countKeysInSlot(unsigned int hashslot);\nunsigned int delKeysInSlot(unsigned int hashslot);\nint verifyClusterConfigWithData(void);\nvoid scanGenericCommand(client *c, robj *o, unsigned long cursor);\nint parseScanCursorOrReply(client *c, robj *o, unsigned long *cursor);\nvoid slotToKeyAdd(sds key);\nvoid slotToKeyDel(sds key);\nint dbAsyncDelete(redisDb *db, robj *key);\nvoid emptyDbAsync(redisDb *db);\nvoid slotToKeyFlush(int async);\nsize_t lazyfreeGetPendingObjectsCount(void);\nvoid freeObjAsync(robj *obj);\nvoid freeSlotsToKeysMapAsync(rax *rt);\nvoid freeSlotsToKeysMap(rax *rt, int async);\n\n\n/* API to get key arguments from commands */\nint *getKeysPrepareResult(getKeysResult *result, int numkeys);\nint getKeysFromCommand(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result);\nvoid getKeysFreeResult(getKeysResult *result);\nint zunionInterGetKeys(struct redisCommand *cmd,robj **argv, int argc, getKeysResult *result);\nint evalGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result);\nint sortGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result);\nint migrateGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result);\nint georadiusGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result);\nint xreadGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result);\nint memoryGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result);\nint lcsGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result);\n\n/* Cluster */\nvoid clusterInit(void);\nunsigned short crc16(const char *buf, int len);\nunsigned int keyHashSlot(char *key, int keylen);\nvoid clusterCron(void);\nvoid clusterPropagatePublish(robj *channel, robj *message);\nvoid migrateCloseTimedoutSockets(void);\nvoid clusterBeforeSleep(void);\nint clusterSendModuleMessageToTarget(const char *target, uint64_t module_id, uint8_t type, unsigned char *payload, uint32_t len);\n\n/* Sentinel */\nvoid initSentinelConfig(void);\nvoid initSentinel(void);\nvoid sentinelTimer(void);\nchar *sentinelHandleConfiguration(char **argv, int argc);\nvoid sentinelIsRunning(void);\n\n/* redis-check-rdb & aof */\nint redis_check_rdb(char *rdbfilename, FILE *fp);\nint redis_check_rdb_main(int argc, char **argv, FILE *fp);\nint redis_check_aof_main(int argc, char **argv);\n\n/* Scripting */\nvoid scriptingInit(int setup);\nint ldbRemoveChild(pid_t pid);\nvoid ldbKillForkedSessions(void);\nint ldbPendingChildren(void);\nsds luaCreateFunction(client *c, lua_State *lua, robj *body);\n\n/* Blocked clients */\nvoid processUnblockedClients(void);\nvoid blockClient(client *c, int btype);\nvoid unblockClient(client *c);\nvoid queueClientForReprocessing(client *c);\nvoid replyToBlockedClientTimedOut(client *c);\nint getTimeoutFromObjectOrReply(client *c, robj *object, mstime_t *timeout, int unit);\nvoid disconnectAllBlockedClients(void);\nvoid handleClientsBlockedOnKeys(void);\nvoid signalKeyAsReady(redisDb *db, robj *key);\nvoid blockForKeys(client *c, int btype, robj **keys, int numkeys, mstime_t timeout, robj *target, streamID *ids);\n\n/* timeout.c -- Blocked clients timeout and connections timeout. */\nvoid addClientToTimeoutTable(client *c);\nvoid removeClientFromTimeoutTable(client *c);\nvoid handleBlockedClientsTimeout(void);\nint clientsCronHandleTimeout(client *c, mstime_t now_ms);\n\n/* expire.c -- Handling of expired keys */\nvoid activeExpireCycle(int type);\nvoid expireSlaveKeys(void);\nvoid rememberSlaveKeyWithExpire(redisDb *db, robj *key);\nvoid flushSlaveKeysWithExpireList(void);\nsize_t getSlaveKeyWithExpireCount(void);\n\n/* evict.c -- maxmemory handling and LRU eviction. */\nvoid evictionPoolAlloc(void);\n#define LFU_INIT_VAL 5\nunsigned long LFUGetTimeInMinutes(void);\nuint8_t LFULogIncr(uint8_t value);\nunsigned long LFUDecrAndReturn(robj *o);\n\n/* Keys hashing / comparison functions for dict.c hash tables. */\nuint64_t dictSdsHash(const void *key);\nint dictSdsKeyCompare(void *privdata, const void *key1, const void *key2);\nvoid dictSdsDestructor(void *privdata, void *val);\n\n/* Git SHA1 */\nchar *redisGitSHA1(void);\nchar *redisGitDirty(void);\nuint64_t redisBuildId(void);\nchar *redisBuildIdString(void);\n\n/* Commands prototypes */\nvoid authCommand(client *c);\nvoid pingCommand(client *c);\nvoid echoCommand(client *c);\nvoid commandCommand(client *c);\nvoid setCommand(client *c);\nvoid setnxCommand(client *c);\nvoid setexCommand(client *c);\nvoid psetexCommand(client *c);\nvoid getCommand(client *c);\nvoid delCommand(client *c);\nvoid unlinkCommand(client *c);\nvoid existsCommand(client *c);\nvoid setbitCommand(client *c);\nvoid getbitCommand(client *c);\nvoid bitfieldCommand(client *c);\nvoid bitfieldroCommand(client *c);\nvoid setrangeCommand(client *c);\nvoid getrangeCommand(client *c);\nvoid incrCommand(client *c);\nvoid decrCommand(client *c);\nvoid incrbyCommand(client *c);\nvoid decrbyCommand(client *c);\nvoid incrbyfloatCommand(client *c);\nvoid selectCommand(client *c);\nvoid swapdbCommand(client *c);\nvoid randomkeyCommand(client *c);\nvoid keysCommand(client *c);\nvoid scanCommand(client *c);\nvoid dbsizeCommand(client *c);\nvoid lastsaveCommand(client *c);\nvoid saveCommand(client *c);\nvoid bgsaveCommand(client *c);\nvoid bgrewriteaofCommand(client *c);\nvoid shutdownCommand(client *c);\nvoid moveCommand(client *c);\nvoid renameCommand(client *c);\nvoid renamenxCommand(client *c);\nvoid lpushCommand(client *c);\nvoid rpushCommand(client *c);\nvoid lpushxCommand(client *c);\nvoid rpushxCommand(client *c);\nvoid linsertCommand(client *c);\nvoid lpopCommand(client *c);\nvoid rpopCommand(client *c);\nvoid llenCommand(client *c);\nvoid lindexCommand(client *c);\nvoid lrangeCommand(client *c);\nvoid ltrimCommand(client *c);\nvoid typeCommand(client *c);\nvoid lsetCommand(client *c);\nvoid saddCommand(client *c);\nvoid sremCommand(client *c);\nvoid smoveCommand(client *c);\nvoid sismemberCommand(client *c);\nvoid scardCommand(client *c);\nvoid spopCommand(client *c);\nvoid srandmemberCommand(client *c);\nvoid sinterCommand(client *c);\nvoid sinterstoreCommand(client *c);\nvoid sunionCommand(client *c);\nvoid sunionstoreCommand(client *c);\nvoid sdiffCommand(client *c);\nvoid sdiffstoreCommand(client *c);\nvoid sscanCommand(client *c);\nvoid syncCommand(client *c);\nvoid flushdbCommand(client *c);\nvoid flushallCommand(client *c);\nvoid sortCommand(client *c);\nvoid lremCommand(client *c);\nvoid lposCommand(client *c);\nvoid rpoplpushCommand(client *c);\nvoid infoCommand(client *c);\nvoid mgetCommand(client *c);\nvoid monitorCommand(client *c);\nvoid expireCommand(client *c);\nvoid expireatCommand(client *c);\nvoid pexpireCommand(client *c);\nvoid pexpireatCommand(client *c);\nvoid getsetCommand(client *c);\nvoid ttlCommand(client *c);\nvoid touchCommand(client *c);\nvoid pttlCommand(client *c);\nvoid persistCommand(client *c);\nvoid replicaofCommand(client *c);\nvoid roleCommand(client *c);\nvoid debugCommand(client *c);\nvoid msetCommand(client *c);\nvoid msetnxCommand(client *c);\nvoid zaddCommand(client *c);\nvoid zincrbyCommand(client *c);\nvoid zrangeCommand(client *c);\nvoid zrangebyscoreCommand(client *c);\nvoid zrevrangebyscoreCommand(client *c);\nvoid zrangebylexCommand(client *c);\nvoid zrevrangebylexCommand(client *c);\nvoid zcountCommand(client *c);\nvoid zlexcountCommand(client *c);\nvoid zrevrangeCommand(client *c);\nvoid zcardCommand(client *c);\nvoid zremCommand(client *c);\nvoid zscoreCommand(client *c);\nvoid zremrangebyscoreCommand(client *c);\nvoid zremrangebylexCommand(client *c);\nvoid zpopminCommand(client *c);\nvoid zpopmaxCommand(client *c);\nvoid bzpopminCommand(client *c);\nvoid bzpopmaxCommand(client *c);\nvoid multiCommand(client *c);\nvoid execCommand(client *c);\nvoid discardCommand(client *c);\nvoid blpopCommand(client *c);\nvoid brpopCommand(client *c);\nvoid brpoplpushCommand(client *c);\nvoid appendCommand(client *c);\nvoid strlenCommand(client *c);\nvoid zrankCommand(client *c);\nvoid zrevrankCommand(client *c);\nvoid hsetCommand(client *c);\nvoid hsetnxCommand(client *c);\nvoid hgetCommand(client *c);\nvoid hmsetCommand(client *c);\nvoid hmgetCommand(client *c);\nvoid hdelCommand(client *c);\nvoid hlenCommand(client *c);\nvoid hstrlenCommand(client *c);\nvoid zremrangebyrankCommand(client *c);\nvoid zunionstoreCommand(client *c);\nvoid zinterstoreCommand(client *c);\nvoid zscanCommand(client *c);\nvoid hkeysCommand(client *c);\nvoid hvalsCommand(client *c);\nvoid hgetallCommand(client *c);\nvoid hexistsCommand(client *c);\nvoid hscanCommand(client *c);\nvoid configCommand(client *c);\nvoid hincrbyCommand(client *c);\nvoid hincrbyfloatCommand(client *c);\nvoid subscribeCommand(client *c);\nvoid unsubscribeCommand(client *c);\nvoid psubscribeCommand(client *c);\nvoid punsubscribeCommand(client *c);\nvoid publishCommand(client *c);\nvoid pubsubCommand(client *c);\nvoid watchCommand(client *c);\nvoid unwatchCommand(client *c);\nvoid clusterCommand(client *c);\nvoid restoreCommand(client *c);\nvoid migrateCommand(client *c);\nvoid askingCommand(client *c);\nvoid readonlyCommand(client *c);\nvoid readwriteCommand(client *c);\nvoid dumpCommand(client *c);\nvoid objectCommand(client *c);\nvoid memoryCommand(client *c);\nvoid clientCommand(client *c);\nvoid helloCommand(client *c);\nvoid evalCommand(client *c);\nvoid evalShaCommand(client *c);\nvoid scriptCommand(client *c);\nvoid timeCommand(client *c);\nvoid bitopCommand(client *c);\nvoid bitcountCommand(client *c);\nvoid bitposCommand(client *c);\nvoid replconfCommand(client *c);\nvoid waitCommand(client *c);\nvoid geoencodeCommand(client *c);\nvoid geodecodeCommand(client *c);\nvoid georadiusbymemberCommand(client *c);\nvoid georadiusbymemberroCommand(client *c);\nvoid georadiusCommand(client *c);\nvoid georadiusroCommand(client *c);\nvoid geoaddCommand(client *c);\nvoid geohashCommand(client *c);\nvoid geoposCommand(client *c);\nvoid geodistCommand(client *c);\nvoid pfselftestCommand(client *c);\nvoid pfaddCommand(client *c);\nvoid pfcountCommand(client *c);\nvoid pfmergeCommand(client *c);\nvoid pfdebugCommand(client *c);\nvoid latencyCommand(client *c);\nvoid moduleCommand(client *c);\nvoid securityWarningCommand(client *c);\nvoid xaddCommand(client *c);\nvoid xrangeCommand(client *c);\nvoid xrevrangeCommand(client *c);\nvoid xlenCommand(client *c);\nvoid xreadCommand(client *c);\nvoid xgroupCommand(client *c);\nvoid xsetidCommand(client *c);\nvoid xackCommand(client *c);\nvoid xpendingCommand(client *c);\nvoid xclaimCommand(client *c);\nvoid xinfoCommand(client *c);\nvoid xdelCommand(client *c);\nvoid xtrimCommand(client *c);\nvoid lolwutCommand(client *c);\nvoid aclCommand(client *c);\nvoid stralgoCommand(client *c);\n\n#if defined(__GNUC__)\nvoid *calloc(size_t count, size_t size) __attribute__ ((deprecated));\nvoid free(void *ptr) __attribute__ ((deprecated));\nvoid *malloc(size_t size) __attribute__ ((deprecated));\nvoid *realloc(void *ptr, size_t size) __attribute__ ((deprecated));\n#endif\n\n/* Debugging stuff */\nvoid _serverAssertWithInfo(const client *c, const robj *o, const char *estr, const char *file, int line);\nvoid _serverAssert(const char *estr, const char *file, int line);\n#ifdef __GNUC__\nvoid _serverPanic(const char *file, int line, const char *msg, ...)\n    __attribute__ ((format (printf, 3, 4)));\n#else\nvoid _serverPanic(const char *file, int line, const char *msg, ...);\n#endif\nvoid bugReportStart(void);\nvoid serverLogObjectDebugInfo(const robj *o);\nvoid sigsegvHandler(int sig, siginfo_t *info, void *secret);\nsds genRedisInfoString(const char *section);\nsds genModulesInfoString(sds info);\nvoid enableWatchdog(int period);\nvoid disableWatchdog(void);\nvoid watchdogScheduleSignal(int period);\nvoid serverLogHexDump(int level, char *descr, void *value, size_t len);\nint memtest_preserving_test(unsigned long *m, size_t bytes, int passes);\nvoid mixDigest(unsigned char *digest, void *ptr, size_t len);\nvoid xorDigest(unsigned char *digest, void *ptr, size_t len);\nint populateCommandTableParseFlags(struct redisCommand *c, char *strflags);\nvoid killIOThreads(void);\nvoid killThreads(void);\nvoid makeThreadKillable(void);\n\n/* TLS stuff */\nvoid tlsInit(void);\nint tlsConfigure(redisTLSContextConfig *ctx_config);\n\n#define redisDebug(fmt, ...) \\\n    printf(\"DEBUG %s:%d > \" fmt \"\\n\", __FILE__, __LINE__, __VA_ARGS__)\n#define redisDebugMark() \\\n    printf(\"-- MARK %s:%d --\\n\", __FILE__, __LINE__)\n\nint iAmMaster(void);\n\n#endif\n", "start_server {tags {\"auth\"}} {\n    test {AUTH fails if there is no password configured server side} {\n        catch {r auth foo} err\n        set _ $err\n    } {ERR*any password*}\n}\n\nstart_server {tags {\"auth\"} overrides {requirepass foobar}} {\n    test {AUTH fails when a wrong password is given} {\n        catch {r auth wrong!} err\n        set _ $err\n    } {WRONGPASS*}\n\n    test {Arbitrary command gives an error when AUTH is required} {\n        catch {r set foo bar} err\n        set _ $err\n    } {NOAUTH*}\n\n    test {AUTH succeeds when the right password is given} {\n        r auth foobar\n    } {OK}\n\n    test {Once AUTH succeeded we can actually send commands to the server} {\n        r set foo 100\n        r incr foo\n    } {101}\n}\n"], "fixing_code": ["/*\n * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"server.h\"\n#include \"atomicvar.h\"\n#include \"cluster.h\"\n#include <sys/socket.h>\n#include <sys/uio.h>\n#include <math.h>\n#include <ctype.h>\n\nstatic void setProtocolError(const char *errstr, client *c);\nint postponeClientRead(client *c);\nint ProcessingEventsWhileBlocked = 0; /* See processEventsWhileBlocked(). */\n\n/* Return the size consumed from the allocator, for the specified SDS string,\n * including internal fragmentation. This function is used in order to compute\n * the client output buffer size. */\nsize_t sdsZmallocSize(sds s) {\n    void *sh = sdsAllocPtr(s);\n    return zmalloc_size(sh);\n}\n\n/* Return the amount of memory used by the sds string at object->ptr\n * for a string object. This includes internal fragmentation. */\nsize_t getStringObjectSdsUsedMemory(robj *o) {\n    serverAssertWithInfo(NULL,o,o->type == OBJ_STRING);\n    switch(o->encoding) {\n    case OBJ_ENCODING_RAW: return sdsZmallocSize(o->ptr);\n    case OBJ_ENCODING_EMBSTR: return zmalloc_size(o)-sizeof(robj);\n    default: return 0; /* Just integer encoding for now. */\n    }\n}\n\n/* Return the length of a string object.\n * This does NOT includes internal fragmentation or sds unused space. */\nsize_t getStringObjectLen(robj *o) {\n    serverAssertWithInfo(NULL,o,o->type == OBJ_STRING);\n    switch(o->encoding) {\n    case OBJ_ENCODING_RAW: return sdslen(o->ptr);\n    case OBJ_ENCODING_EMBSTR: return sdslen(o->ptr);\n    default: return 0; /* Just integer encoding for now. */\n    }\n}\n\n/* Client.reply list dup and free methods. */\nvoid *dupClientReplyValue(void *o) {\n    clientReplyBlock *old = o;\n    clientReplyBlock *buf = zmalloc(sizeof(clientReplyBlock) + old->size);\n    memcpy(buf, o, sizeof(clientReplyBlock) + old->size);\n    return buf;\n}\n\nvoid freeClientReplyValue(void *o) {\n    zfree(o);\n}\n\nint listMatchObjects(void *a, void *b) {\n    return equalStringObjects(a,b);\n}\n\n/* This function links the client to the global linked list of clients.\n * unlinkClient() does the opposite, among other things. */\nvoid linkClient(client *c) {\n    listAddNodeTail(server.clients,c);\n    /* Note that we remember the linked list node where the client is stored,\n     * this way removing the client in unlinkClient() will not require\n     * a linear scan, but just a constant time operation. */\n    c->client_list_node = listLast(server.clients);\n    uint64_t id = htonu64(c->id);\n    raxInsert(server.clients_index,(unsigned char*)&id,sizeof(id),c,NULL);\n}\n\nint authRequired(client *c) {\n    /* Check if the user is authenticated. This check is skipped in case\n     * the default user is flagged as \"nopass\" and is active. */\n    int auth_required = (!(DefaultUser->flags & USER_FLAG_NOPASS) ||\n                          (DefaultUser->flags & USER_FLAG_DISABLED)) &&\n                        !c->authenticated;\n    return auth_required;\n}\n\nclient *createClient(connection *conn) {\n    client *c = zmalloc(sizeof(client));\n\n    /* passing NULL as conn it is possible to create a non connected client.\n     * This is useful since all the commands needs to be executed\n     * in the context of a client. When commands are executed in other\n     * contexts (for instance a Lua script) we need a non connected client. */\n    if (conn) {\n        connNonBlock(conn);\n        connEnableTcpNoDelay(conn);\n        if (server.tcpkeepalive)\n            connKeepAlive(conn,server.tcpkeepalive);\n        connSetReadHandler(conn, readQueryFromClient);\n        connSetPrivateData(conn, c);\n    }\n\n    selectDb(c,0);\n    uint64_t client_id = ++server.next_client_id;\n    c->id = client_id;\n    c->resp = 2;\n    c->conn = conn;\n    c->name = NULL;\n    c->bufpos = 0;\n    c->qb_pos = 0;\n    c->querybuf = sdsempty();\n    c->pending_querybuf = sdsempty();\n    c->querybuf_peak = 0;\n    c->reqtype = 0;\n    c->argc = 0;\n    c->argv = NULL;\n    c->argv_len_sum = 0;\n    c->cmd = c->lastcmd = NULL;\n    c->user = DefaultUser;\n    c->multibulklen = 0;\n    c->bulklen = -1;\n    c->sentlen = 0;\n    c->flags = 0;\n    c->ctime = c->lastinteraction = server.unixtime;\n    /* If the default user does not require authentication, the user is\n     * directly authenticated. */\n    c->authenticated = (c->user->flags & USER_FLAG_NOPASS) &&\n                       !(c->user->flags & USER_FLAG_DISABLED);\n    c->replstate = REPL_STATE_NONE;\n    c->repl_put_online_on_ack = 0;\n    c->reploff = 0;\n    c->read_reploff = 0;\n    c->repl_ack_off = 0;\n    c->repl_ack_time = 0;\n    c->repl_last_partial_write = 0;\n    c->slave_listening_port = 0;\n    c->slave_ip[0] = '\\0';\n    c->slave_capa = SLAVE_CAPA_NONE;\n    c->reply = listCreate();\n    c->reply_bytes = 0;\n    c->obuf_soft_limit_reached_time = 0;\n    listSetFreeMethod(c->reply,freeClientReplyValue);\n    listSetDupMethod(c->reply,dupClientReplyValue);\n    c->btype = BLOCKED_NONE;\n    c->bpop.timeout = 0;\n    c->bpop.keys = dictCreate(&objectKeyHeapPointerValueDictType,NULL);\n    c->bpop.target = NULL;\n    c->bpop.xread_group = NULL;\n    c->bpop.xread_consumer = NULL;\n    c->bpop.xread_group_noack = 0;\n    c->bpop.numreplicas = 0;\n    c->bpop.reploffset = 0;\n    c->woff = 0;\n    c->watched_keys = listCreate();\n    c->pubsub_channels = dictCreate(&objectKeyPointerValueDictType,NULL);\n    c->pubsub_patterns = listCreate();\n    c->peerid = NULL;\n    c->client_list_node = NULL;\n    c->client_tracking_redirection = 0;\n    c->client_tracking_prefixes = NULL;\n    c->client_cron_last_memory_usage = 0;\n    c->client_cron_last_memory_type = CLIENT_TYPE_NORMAL;\n    c->auth_callback = NULL;\n    c->auth_callback_privdata = NULL;\n    c->auth_module = NULL;\n    listSetFreeMethod(c->pubsub_patterns,decrRefCountVoid);\n    listSetMatchMethod(c->pubsub_patterns,listMatchObjects);\n    if (conn) linkClient(c);\n    initClientMultiState(c);\n    return c;\n}\n\n/* This function puts the client in the queue of clients that should write\n * their output buffers to the socket. Note that it does not *yet* install\n * the write handler, to start clients are put in a queue of clients that need\n * to write, so we try to do that before returning in the event loop (see the\n * handleClientsWithPendingWrites() function).\n * If we fail and there is more data to write, compared to what the socket\n * buffers can hold, then we'll really install the handler. */\nvoid clientInstallWriteHandler(client *c) {\n    /* Schedule the client to write the output buffers to the socket only\n     * if not already done and, for slaves, if the slave can actually receive\n     * writes at this stage. */\n    if (!(c->flags & CLIENT_PENDING_WRITE) &&\n        (c->replstate == REPL_STATE_NONE ||\n         (c->replstate == SLAVE_STATE_ONLINE && !c->repl_put_online_on_ack)))\n    {\n        /* Here instead of installing the write handler, we just flag the\n         * client and put it into a list of clients that have something\n         * to write to the socket. This way before re-entering the event\n         * loop, we can try to directly write to the client sockets avoiding\n         * a system call. We'll only really install the write handler if\n         * we'll not be able to write the whole reply at once. */\n        c->flags |= CLIENT_PENDING_WRITE;\n        listAddNodeHead(server.clients_pending_write,c);\n    }\n}\n\n/* This function is called every time we are going to transmit new data\n * to the client. The behavior is the following:\n *\n * If the client should receive new data (normal clients will) the function\n * returns C_OK, and make sure to install the write handler in our event\n * loop so that when the socket is writable new data gets written.\n *\n * If the client should not receive new data, because it is a fake client\n * (used to load AOF in memory), a master or because the setup of the write\n * handler failed, the function returns C_ERR.\n *\n * The function may return C_OK without actually installing the write\n * event handler in the following cases:\n *\n * 1) The event handler should already be installed since the output buffer\n *    already contains something.\n * 2) The client is a slave but not yet online, so we want to just accumulate\n *    writes in the buffer but not actually sending them yet.\n *\n * Typically gets called every time a reply is built, before adding more\n * data to the clients output buffers. If the function returns C_ERR no\n * data should be appended to the output buffers. */\nint prepareClientToWrite(client *c) {\n    /* If it's the Lua client we always return ok without installing any\n     * handler since there is no socket at all. */\n    if (c->flags & (CLIENT_LUA|CLIENT_MODULE)) return C_OK;\n\n    /* If CLIENT_CLOSE_ASAP flag is set, we need not write anything. */\n    if (c->flags & CLIENT_CLOSE_ASAP) return C_ERR;\n\n    /* CLIENT REPLY OFF / SKIP handling: don't send replies. */\n    if (c->flags & (CLIENT_REPLY_OFF|CLIENT_REPLY_SKIP)) return C_ERR;\n\n    /* Masters don't receive replies, unless CLIENT_MASTER_FORCE_REPLY flag\n     * is set. */\n    if ((c->flags & CLIENT_MASTER) &&\n        !(c->flags & CLIENT_MASTER_FORCE_REPLY)) return C_ERR;\n\n    if (!c->conn) return C_ERR; /* Fake client for AOF loading. */\n\n    /* Schedule the client to write the output buffers to the socket, unless\n     * it should already be setup to do so (it has already pending data).\n     *\n     * If CLIENT_PENDING_READ is set, we're in an IO thread and should\n     * not install a write handler. Instead, it will be done by\n     * handleClientsWithPendingReadsUsingThreads() upon return.\n     */\n    if (!clientHasPendingReplies(c) && !(c->flags & CLIENT_PENDING_READ))\n            clientInstallWriteHandler(c);\n\n    /* Authorize the caller to queue in the output buffer of this client. */\n    return C_OK;\n}\n\n/* -----------------------------------------------------------------------------\n * Low level functions to add more data to output buffers.\n * -------------------------------------------------------------------------- */\n\n/* Attempts to add the reply to the static buffer in the client struct.\n * Returns C_ERR if the buffer is full, or the reply list is not empty,\n * in which case the reply must be added to the reply list. */\nint _addReplyToBuffer(client *c, const char *s, size_t len) {\n    size_t available = sizeof(c->buf)-c->bufpos;\n\n    if (c->flags & CLIENT_CLOSE_AFTER_REPLY) return C_OK;\n\n    /* If there already are entries in the reply list, we cannot\n     * add anything more to the static buffer. */\n    if (listLength(c->reply) > 0) return C_ERR;\n\n    /* Check that the buffer has enough space available for this string. */\n    if (len > available) return C_ERR;\n\n    memcpy(c->buf+c->bufpos,s,len);\n    c->bufpos+=len;\n    return C_OK;\n}\n\n/* Adds the reply to the reply linked list.\n * Note: some edits to this function need to be relayed to AddReplyFromClient. */\nvoid _addReplyProtoToList(client *c, const char *s, size_t len) {\n    if (c->flags & CLIENT_CLOSE_AFTER_REPLY) return;\n\n    listNode *ln = listLast(c->reply);\n    clientReplyBlock *tail = ln? listNodeValue(ln): NULL;\n\n    /* Note that 'tail' may be NULL even if we have a tail node, because when\n     * addReplyDeferredLen() is used, it sets a dummy node to NULL just\n     * fo fill it later, when the size of the bulk length is set. */\n\n    /* Append to tail string when possible. */\n    if (tail) {\n        /* Copy the part we can fit into the tail, and leave the rest for a\n         * new node */\n        size_t avail = tail->size - tail->used;\n        size_t copy = avail >= len? len: avail;\n        memcpy(tail->buf + tail->used, s, copy);\n        tail->used += copy;\n        s += copy;\n        len -= copy;\n    }\n    if (len) {\n        /* Create a new node, make sure it is allocated to at\n         * least PROTO_REPLY_CHUNK_BYTES */\n        size_t size = len < PROTO_REPLY_CHUNK_BYTES? PROTO_REPLY_CHUNK_BYTES: len;\n        tail = zmalloc(size + sizeof(clientReplyBlock));\n        /* take over the allocation's internal fragmentation */\n        tail->size = zmalloc_usable(tail) - sizeof(clientReplyBlock);\n        tail->used = len;\n        memcpy(tail->buf, s, len);\n        listAddNodeTail(c->reply, tail);\n        c->reply_bytes += tail->size;\n    }\n    asyncCloseClientOnOutputBufferLimitReached(c);\n}\n\n/* -----------------------------------------------------------------------------\n * Higher level functions to queue data on the client output buffer.\n * The following functions are the ones that commands implementations will call.\n * -------------------------------------------------------------------------- */\n\n/* Add the object 'obj' string representation to the client output buffer. */\nvoid addReply(client *c, robj *obj) {\n    if (prepareClientToWrite(c) != C_OK) return;\n\n    if (sdsEncodedObject(obj)) {\n        if (_addReplyToBuffer(c,obj->ptr,sdslen(obj->ptr)) != C_OK)\n            _addReplyProtoToList(c,obj->ptr,sdslen(obj->ptr));\n    } else if (obj->encoding == OBJ_ENCODING_INT) {\n        /* For integer encoded strings we just convert it into a string\n         * using our optimized function, and attach the resulting string\n         * to the output buffer. */\n        char buf[32];\n        size_t len = ll2string(buf,sizeof(buf),(long)obj->ptr);\n        if (_addReplyToBuffer(c,buf,len) != C_OK)\n            _addReplyProtoToList(c,buf,len);\n    } else {\n        serverPanic(\"Wrong obj->encoding in addReply()\");\n    }\n}\n\n/* Add the SDS 's' string to the client output buffer, as a side effect\n * the SDS string is freed. */\nvoid addReplySds(client *c, sds s) {\n    if (prepareClientToWrite(c) != C_OK) {\n        /* The caller expects the sds to be free'd. */\n        sdsfree(s);\n        return;\n    }\n    if (_addReplyToBuffer(c,s,sdslen(s)) != C_OK)\n        _addReplyProtoToList(c,s,sdslen(s));\n    sdsfree(s);\n}\n\n/* This low level function just adds whatever protocol you send it to the\n * client buffer, trying the static buffer initially, and using the string\n * of objects if not possible.\n *\n * It is efficient because does not create an SDS object nor an Redis object\n * if not needed. The object will only be created by calling\n * _addReplyProtoToList() if we fail to extend the existing tail object\n * in the list of objects. */\nvoid addReplyProto(client *c, const char *s, size_t len) {\n    if (prepareClientToWrite(c) != C_OK) return;\n    if (_addReplyToBuffer(c,s,len) != C_OK)\n        _addReplyProtoToList(c,s,len);\n}\n\n/* Low level function called by the addReplyError...() functions.\n * It emits the protocol for a Redis error, in the form:\n *\n * -ERRORCODE Error Message<CR><LF>\n *\n * If the error code is already passed in the string 's', the error\n * code provided is used, otherwise the string \"-ERR \" for the generic\n * error code is automatically added.\n * Note that 's' must NOT end with \\r\\n. */\nvoid addReplyErrorLength(client *c, const char *s, size_t len) {\n    /* If the string already starts with \"-...\" then the error code\n     * is provided by the caller. Otherwise we use \"-ERR\". */\n    if (!len || s[0] != '-') addReplyProto(c,\"-ERR \",5);\n    addReplyProto(c,s,len);\n    addReplyProto(c,\"\\r\\n\",2);\n}\n\n/* Do some actions after an error reply was sent (Log if needed, updates stats, etc.) */\nvoid afterErrorReply(client *c, const char *s, size_t len) {\n    /* Sometimes it could be normal that a slave replies to a master with\n     * an error and this function gets called. Actually the error will never\n     * be sent because addReply*() against master clients has no effect...\n     * A notable example is:\n     *\n     *    EVAL 'redis.call(\"incr\",KEYS[1]); redis.call(\"nonexisting\")' 1 x\n     *\n     * Where the master must propagate the first change even if the second\n     * will produce an error. However it is useful to log such events since\n     * they are rare and may hint at errors in a script or a bug in Redis. */\n    int ctype = getClientType(c);\n    if (ctype == CLIENT_TYPE_MASTER || ctype == CLIENT_TYPE_SLAVE || c->id == CLIENT_ID_AOF) {\n        char *to, *from;\n\n        if (c->id == CLIENT_ID_AOF) {\n            to = \"AOF-loading-client\";\n            from = \"server\";\n        } else if (ctype == CLIENT_TYPE_MASTER) {\n            to = \"master\";\n            from = \"replica\";\n        } else {\n            to = \"replica\";\n            from = \"master\";\n        }\n\n        if (len > 4096) len = 4096;\n        char *cmdname = c->lastcmd ? c->lastcmd->name : \"<unknown>\";\n        serverLog(LL_WARNING,\"== CRITICAL == This %s is sending an error \"\n                             \"to its %s: '%.*s' after processing the command \"\n                             \"'%s'\", from, to, (int)len, s, cmdname);\n        if (ctype == CLIENT_TYPE_MASTER && server.repl_backlog &&\n            server.repl_backlog_histlen > 0)\n        {\n            showLatestBacklog();\n        }\n        server.stat_unexpected_error_replies++;\n    }\n}\n\n/* The 'err' object is expected to start with -ERRORCODE and end with \\r\\n.\n * Unlike addReplyErrorSds and others alike which rely on addReplyErrorLength. */\nvoid addReplyErrorObject(client *c, robj *err) {\n    addReply(c, err);\n    afterErrorReply(c, err->ptr, sdslen(err->ptr)-2); /* Ignore trailing \\r\\n */\n}\n\n/* See addReplyErrorLength for expectations from the input string. */\nvoid addReplyError(client *c, const char *err) {\n    addReplyErrorLength(c,err,strlen(err));\n    afterErrorReply(c,err,strlen(err));\n}\n\n/* See addReplyErrorLength for expectations from the input string. */\nvoid addReplyErrorSds(client *c, sds err) {\n    addReplyErrorLength(c,err,sdslen(err));\n    afterErrorReply(c,err,sdslen(err));\n}\n\n/* See addReplyErrorLength for expectations from the formatted string.\n * The formatted string is safe to contain \\r and \\n anywhere. */\nvoid addReplyErrorFormat(client *c, const char *fmt, ...) {\n    va_list ap;\n    va_start(ap,fmt);\n    sds s = sdscatvprintf(sdsempty(),fmt,ap);\n    va_end(ap);\n    /* Trim any newlines at the end (ones will be added by addReplyErrorLength) */\n    s = sdstrim(s, \"\\r\\n\");\n    /* Make sure there are no newlines in the middle of the string, otherwise\n     * invalid protocol is emitted. */\n    s = sdsmapchars(s, \"\\r\\n\", \"  \",  2);\n    addReplyErrorLength(c,s,sdslen(s));\n    afterErrorReply(c,s,sdslen(s));\n    sdsfree(s);\n}\n\nvoid addReplyStatusLength(client *c, const char *s, size_t len) {\n    addReplyProto(c,\"+\",1);\n    addReplyProto(c,s,len);\n    addReplyProto(c,\"\\r\\n\",2);\n}\n\nvoid addReplyStatus(client *c, const char *status) {\n    addReplyStatusLength(c,status,strlen(status));\n}\n\nvoid addReplyStatusFormat(client *c, const char *fmt, ...) {\n    va_list ap;\n    va_start(ap,fmt);\n    sds s = sdscatvprintf(sdsempty(),fmt,ap);\n    va_end(ap);\n    addReplyStatusLength(c,s,sdslen(s));\n    sdsfree(s);\n}\n\n/* Sometimes we are forced to create a new reply node, and we can't append to\n * the previous one, when that happens, we wanna try to trim the unused space\n * at the end of the last reply node which we won't use anymore. */\nvoid trimReplyUnusedTailSpace(client *c) {\n    listNode *ln = listLast(c->reply);\n    clientReplyBlock *tail = ln? listNodeValue(ln): NULL;\n\n    /* Note that 'tail' may be NULL even if we have a tail node, becuase when\n     * addReplyDeferredLen() is used */\n    if (!tail) return;\n\n    /* We only try to trim the space is relatively high (more than a 1/4 of the\n     * allocation), otherwise there's a high chance realloc will NOP.\n     * Also, to avoid large memmove which happens as part of realloc, we only do\n     * that if the used part is small.  */\n    if (tail->size - tail->used > tail->size / 4 &&\n        tail->used < PROTO_REPLY_CHUNK_BYTES)\n    {\n        size_t old_size = tail->size;\n        tail = zrealloc(tail, tail->used + sizeof(clientReplyBlock));\n        /* take over the allocation's internal fragmentation (at least for\n         * memory usage tracking) */\n        tail->size = zmalloc_usable(tail) - sizeof(clientReplyBlock);\n        c->reply_bytes = c->reply_bytes + tail->size - old_size;\n        listNodeValue(ln) = tail;\n    }\n}\n\n/* Adds an empty object to the reply list that will contain the multi bulk\n * length, which is not known when this function is called. */\nvoid *addReplyDeferredLen(client *c) {\n    /* Note that we install the write event here even if the object is not\n     * ready to be sent, since we are sure that before returning to the\n     * event loop setDeferredAggregateLen() will be called. */\n    if (prepareClientToWrite(c) != C_OK) return NULL;\n    trimReplyUnusedTailSpace(c);\n    listAddNodeTail(c->reply,NULL); /* NULL is our placeholder. */\n    return listLast(c->reply);\n}\n\n/* Populate the length object and try gluing it to the next chunk. */\nvoid setDeferredAggregateLen(client *c, void *node, long length, char prefix) {\n    serverAssert(length >= 0);\n    listNode *ln = (listNode*)node;\n    clientReplyBlock *next;\n    char lenstr[128];\n    size_t lenstr_len = sprintf(lenstr, \"%c%ld\\r\\n\", prefix, length);\n\n    /* Abort when *node is NULL: when the client should not accept writes\n     * we return NULL in addReplyDeferredLen() */\n    if (node == NULL) return;\n    serverAssert(!listNodeValue(ln));\n\n    /* Normally we fill this dummy NULL node, added by addReplyDeferredLen(),\n     * with a new buffer structure containing the protocol needed to specify\n     * the length of the array following. However sometimes when there is\n     * little memory to move, we may instead remove this NULL node, and prefix\n     * our protocol in the node immediately after to it, in order to save a\n     * write(2) syscall later. Conditions needed to do it:\n     *\n     * - The next node is non-NULL,\n     * - It has enough room already allocated\n     * - And not too large (avoid large memmove) */\n    if (ln->next != NULL && (next = listNodeValue(ln->next)) &&\n        next->size - next->used >= lenstr_len &&\n        next->used < PROTO_REPLY_CHUNK_BYTES * 4) {\n        memmove(next->buf + lenstr_len, next->buf, next->used);\n        memcpy(next->buf, lenstr, lenstr_len);\n        next->used += lenstr_len;\n        listDelNode(c->reply,ln);\n    } else {\n        /* Create a new node */\n        clientReplyBlock *buf = zmalloc(lenstr_len + sizeof(clientReplyBlock));\n        /* Take over the allocation's internal fragmentation */\n        buf->size = zmalloc_usable(buf) - sizeof(clientReplyBlock);\n        buf->used = lenstr_len;\n        memcpy(buf->buf, lenstr, lenstr_len);\n        listNodeValue(ln) = buf;\n        c->reply_bytes += buf->size;\n    }\n    asyncCloseClientOnOutputBufferLimitReached(c);\n}\n\nvoid setDeferredArrayLen(client *c, void *node, long length) {\n    setDeferredAggregateLen(c,node,length,'*');\n}\n\nvoid setDeferredMapLen(client *c, void *node, long length) {\n    int prefix = c->resp == 2 ? '*' : '%';\n    if (c->resp == 2) length *= 2;\n    setDeferredAggregateLen(c,node,length,prefix);\n}\n\nvoid setDeferredSetLen(client *c, void *node, long length) {\n    int prefix = c->resp == 2 ? '*' : '~';\n    setDeferredAggregateLen(c,node,length,prefix);\n}\n\nvoid setDeferredAttributeLen(client *c, void *node, long length) {\n    serverAssert(c->resp >= 3);\n    setDeferredAggregateLen(c,node,length,'|');\n}\n\nvoid setDeferredPushLen(client *c, void *node, long length) {\n    serverAssert(c->resp >= 3);\n    setDeferredAggregateLen(c,node,length,'>');\n}\n\n/* Add a double as a bulk reply */\nvoid addReplyDouble(client *c, double d) {\n    if (isinf(d)) {\n        /* Libc in odd systems (Hi Solaris!) will format infinite in a\n         * different way, so better to handle it in an explicit way. */\n        if (c->resp == 2) {\n            addReplyBulkCString(c, d > 0 ? \"inf\" : \"-inf\");\n        } else {\n            addReplyProto(c, d > 0 ? \",inf\\r\\n\" : \",-inf\\r\\n\",\n                              d > 0 ? 6 : 7);\n        }\n    } else {\n        char dbuf[MAX_LONG_DOUBLE_CHARS+3],\n             sbuf[MAX_LONG_DOUBLE_CHARS+32];\n        int dlen, slen;\n        if (c->resp == 2) {\n            dlen = snprintf(dbuf,sizeof(dbuf),\"%.17g\",d);\n            slen = snprintf(sbuf,sizeof(sbuf),\"$%d\\r\\n%s\\r\\n\",dlen,dbuf);\n            addReplyProto(c,sbuf,slen);\n        } else {\n            dlen = snprintf(dbuf,sizeof(dbuf),\",%.17g\\r\\n\",d);\n            addReplyProto(c,dbuf,dlen);\n        }\n    }\n}\n\nvoid addReplyBigNum(client *c, const char* num, size_t len) {\n    if (c->resp == 2) {\n        addReplyBulkCBuffer(c, num, len);\n    } else {\n        addReplyProto(c,\"(\",1);\n        addReplyProto(c,num,len);\n        addReply(c,shared.crlf);\n    }\n}\n\n/* Add a long double as a bulk reply, but uses a human readable formatting\n * of the double instead of exposing the crude behavior of doubles to the\n * dear user. */\nvoid addReplyHumanLongDouble(client *c, long double d) {\n    if (c->resp == 2) {\n        robj *o = createStringObjectFromLongDouble(d,1);\n        addReplyBulk(c,o);\n        decrRefCount(o);\n    } else {\n        char buf[MAX_LONG_DOUBLE_CHARS];\n        int len = ld2string(buf,sizeof(buf),d,LD_STR_HUMAN);\n        addReplyProto(c,\",\",1);\n        addReplyProto(c,buf,len);\n        addReplyProto(c,\"\\r\\n\",2);\n    }\n}\n\n/* Add a long long as integer reply or bulk len / multi bulk count.\n * Basically this is used to output <prefix><long long><crlf>. */\nvoid addReplyLongLongWithPrefix(client *c, long long ll, char prefix) {\n    char buf[128];\n    int len;\n\n    /* Things like $3\\r\\n or *2\\r\\n are emitted very often by the protocol\n     * so we have a few shared objects to use if the integer is small\n     * like it is most of the times. */\n    if (prefix == '*' && ll < OBJ_SHARED_BULKHDR_LEN && ll >= 0) {\n        addReply(c,shared.mbulkhdr[ll]);\n        return;\n    } else if (prefix == '$' && ll < OBJ_SHARED_BULKHDR_LEN && ll >= 0) {\n        addReply(c,shared.bulkhdr[ll]);\n        return;\n    }\n\n    buf[0] = prefix;\n    len = ll2string(buf+1,sizeof(buf)-1,ll);\n    buf[len+1] = '\\r';\n    buf[len+2] = '\\n';\n    addReplyProto(c,buf,len+3);\n}\n\nvoid addReplyLongLong(client *c, long long ll) {\n    if (ll == 0)\n        addReply(c,shared.czero);\n    else if (ll == 1)\n        addReply(c,shared.cone);\n    else\n        addReplyLongLongWithPrefix(c,ll,':');\n}\n\nvoid addReplyAggregateLen(client *c, long length, int prefix) {\n    if (prefix == '*' && length < OBJ_SHARED_BULKHDR_LEN)\n        addReply(c,shared.mbulkhdr[length]);\n    else\n        addReplyLongLongWithPrefix(c,length,prefix);\n}\n\nvoid addReplyArrayLen(client *c, long length) {\n    addReplyAggregateLen(c,length,'*');\n}\n\nvoid addReplyMapLen(client *c, long length) {\n    int prefix = c->resp == 2 ? '*' : '%';\n    if (c->resp == 2) length *= 2;\n    addReplyAggregateLen(c,length,prefix);\n}\n\nvoid addReplySetLen(client *c, long length) {\n    int prefix = c->resp == 2 ? '*' : '~';\n    addReplyAggregateLen(c,length,prefix);\n}\n\nvoid addReplyAttributeLen(client *c, long length) {\n    serverAssert(c->resp >= 3);\n    addReplyAggregateLen(c,length,'|');\n}\n\nvoid addReplyPushLen(client *c, long length) {\n    serverAssert(c->resp >= 3);\n    addReplyAggregateLen(c,length,'>');\n}\n\nvoid addReplyNull(client *c) {\n    if (c->resp == 2) {\n        addReplyProto(c,\"$-1\\r\\n\",5);\n    } else {\n        addReplyProto(c,\"_\\r\\n\",3);\n    }\n}\n\nvoid addReplyBool(client *c, int b) {\n    if (c->resp == 2) {\n        addReply(c, b ? shared.cone : shared.czero);\n    } else {\n        addReplyProto(c, b ? \"#t\\r\\n\" : \"#f\\r\\n\",4);\n    }\n}\n\n/* A null array is a concept that no longer exists in RESP3. However\n * RESP2 had it, so API-wise we have this call, that will emit the correct\n * RESP2 protocol, however for RESP3 the reply will always be just the\n * Null type \"_\\r\\n\". */\nvoid addReplyNullArray(client *c) {\n    if (c->resp == 2) {\n        addReplyProto(c,\"*-1\\r\\n\",5);\n    } else {\n        addReplyProto(c,\"_\\r\\n\",3);\n    }\n}\n\n/* Create the length prefix of a bulk reply, example: $2234 */\nvoid addReplyBulkLen(client *c, robj *obj) {\n    size_t len = stringObjectLen(obj);\n\n    if (len < OBJ_SHARED_BULKHDR_LEN)\n        addReply(c,shared.bulkhdr[len]);\n    else\n        addReplyLongLongWithPrefix(c,len,'$');\n}\n\n/* Add a Redis Object as a bulk reply */\nvoid addReplyBulk(client *c, robj *obj) {\n    addReplyBulkLen(c,obj);\n    addReply(c,obj);\n    addReply(c,shared.crlf);\n}\n\n/* Add a C buffer as bulk reply */\nvoid addReplyBulkCBuffer(client *c, const void *p, size_t len) {\n    addReplyLongLongWithPrefix(c,len,'$');\n    addReplyProto(c,p,len);\n    addReply(c,shared.crlf);\n}\n\n/* Add sds to reply (takes ownership of sds and frees it) */\nvoid addReplyBulkSds(client *c, sds s)  {\n    addReplyLongLongWithPrefix(c,sdslen(s),'$');\n    addReplySds(c,s);\n    addReply(c,shared.crlf);\n}\n\n/* Add a C null term string as bulk reply */\nvoid addReplyBulkCString(client *c, const char *s) {\n    if (s == NULL) {\n        addReplyNull(c);\n    } else {\n        addReplyBulkCBuffer(c,s,strlen(s));\n    }\n}\n\n/* Add a long long as a bulk reply */\nvoid addReplyBulkLongLong(client *c, long long ll) {\n    char buf[64];\n    int len;\n\n    len = ll2string(buf,64,ll);\n    addReplyBulkCBuffer(c,buf,len);\n}\n\n/* Reply with a verbatim type having the specified extension.\n *\n * The 'ext' is the \"extension\" of the file, actually just a three\n * character type that describes the format of the verbatim string.\n * For instance \"txt\" means it should be interpreted as a text only\n * file by the receiver, \"md \" as markdown, and so forth. Only the\n * three first characters of the extension are used, and if the\n * provided one is shorter than that, the remaining is filled with\n * spaces. */\nvoid addReplyVerbatim(client *c, const char *s, size_t len, const char *ext) {\n    if (c->resp == 2) {\n        addReplyBulkCBuffer(c,s,len);\n    } else {\n        char buf[32];\n        size_t preflen = snprintf(buf,sizeof(buf),\"=%zu\\r\\nxxx:\",len+4);\n        char *p = buf+preflen-4;\n        for (int i = 0; i < 3; i++) {\n            if (*ext == '\\0') {\n                p[i] = ' ';\n            } else {\n                p[i] = *ext++;\n            }\n        }\n        addReplyProto(c,buf,preflen);\n        addReplyProto(c,s,len);\n        addReplyProto(c,\"\\r\\n\",2);\n    }\n}\n\n/* Add an array of C strings as status replies with a heading.\n * This function is typically invoked by from commands that support\n * subcommands in response to the 'help' subcommand. The help array\n * is terminated by NULL sentinel. */\nvoid addReplyHelp(client *c, const char **help) {\n    sds cmd = sdsnew((char*) c->argv[0]->ptr);\n    void *blenp = addReplyDeferredLen(c);\n    int blen = 0;\n\n    sdstoupper(cmd);\n    addReplyStatusFormat(c,\n        \"%s <subcommand> arg arg ... arg. Subcommands are:\",cmd);\n    sdsfree(cmd);\n\n    while (help[blen]) addReplyStatus(c,help[blen++]);\n\n    blen++;  /* Account for the header line(s). */\n    setDeferredArrayLen(c,blenp,blen);\n}\n\n/* Add a suggestive error reply.\n * This function is typically invoked by from commands that support\n * subcommands in response to an unknown subcommand or argument error. */\nvoid addReplySubcommandSyntaxError(client *c) {\n    sds cmd = sdsnew((char*) c->argv[0]->ptr);\n    sdstoupper(cmd);\n    addReplyErrorFormat(c,\n        \"Unknown subcommand or wrong number of arguments for '%s'. Try %s HELP.\",\n        (char*)c->argv[1]->ptr,cmd);\n    sdsfree(cmd);\n}\n\n/* Append 'src' client output buffers into 'dst' client output buffers. \n * This function clears the output buffers of 'src' */\nvoid AddReplyFromClient(client *dst, client *src) {\n    /* If the source client contains a partial response due to client output\n     * buffer limits, propagate that to the dest rather than copy a partial\n     * reply. We don't wanna run the risk of copying partial response in case\n     * for some reason the output limits don't reach the same decision (maybe\n     * they changed) */\n    if (src->flags & CLIENT_CLOSE_ASAP) {\n        sds client = catClientInfoString(sdsempty(),dst);\n        freeClientAsync(dst);\n        serverLog(LL_WARNING,\"Client %s scheduled to be closed ASAP for overcoming of output buffer limits.\", client);\n        sdsfree(client);\n        return;\n    }\n\n    /* First add the static buffer (either into the static buffer or reply list) */\n    addReplyProto(dst,src->buf, src->bufpos);\n\n    /* We need to check with prepareClientToWrite again (after addReplyProto)\n     * since addReplyProto may have changed something (like CLIENT_CLOSE_ASAP) */\n    if (prepareClientToWrite(dst) != C_OK)\n        return;\n\n    /* We're bypassing _addReplyProtoToList, so we need to add the pre/post\n     * checks in it. */\n    if (dst->flags & CLIENT_CLOSE_AFTER_REPLY) return;\n\n    /* Concatenate the reply list into the dest */\n    if (listLength(src->reply))\n        listJoin(dst->reply,src->reply);\n    dst->reply_bytes += src->reply_bytes;\n    src->reply_bytes = 0;\n    src->bufpos = 0;\n\n    /* Check output buffer limits */\n    asyncCloseClientOnOutputBufferLimitReached(dst);\n}\n\n/* Copy 'src' client output buffers into 'dst' client output buffers.\n * The function takes care of freeing the old output buffers of the\n * destination client. */\nvoid copyClientOutputBuffer(client *dst, client *src) {\n    listRelease(dst->reply);\n    dst->sentlen = 0;\n    dst->reply = listDup(src->reply);\n    memcpy(dst->buf,src->buf,src->bufpos);\n    dst->bufpos = src->bufpos;\n    dst->reply_bytes = src->reply_bytes;\n}\n\n/* Return true if the specified client has pending reply buffers to write to\n * the socket. */\nint clientHasPendingReplies(client *c) {\n    return c->bufpos || listLength(c->reply);\n}\n\nvoid clientAcceptHandler(connection *conn) {\n    client *c = connGetPrivateData(conn);\n\n    if (connGetState(conn) != CONN_STATE_CONNECTED) {\n        serverLog(LL_WARNING,\n                \"Error accepting a client connection: %s\",\n                connGetLastError(conn));\n        freeClientAsync(c);\n        return;\n    }\n\n    /* If the server is running in protected mode (the default) and there\n     * is no password set, nor a specific interface is bound, we don't accept\n     * requests from non loopback interfaces. Instead we try to explain the\n     * user what to do to fix it if needed. */\n    if (server.protected_mode &&\n        server.bindaddr_count == 0 &&\n        DefaultUser->flags & USER_FLAG_NOPASS &&\n        !(c->flags & CLIENT_UNIX_SOCKET))\n    {\n        char cip[NET_IP_STR_LEN+1] = { 0 };\n        connPeerToString(conn, cip, sizeof(cip)-1, NULL);\n\n        if (strcmp(cip,\"127.0.0.1\") && strcmp(cip,\"::1\")) {\n            char *err =\n                \"-DENIED Redis is running in protected mode because protected \"\n                \"mode is enabled, no bind address was specified, no \"\n                \"authentication password is requested to clients. In this mode \"\n                \"connections are only accepted from the loopback interface. \"\n                \"If you want to connect from external computers to Redis you \"\n                \"may adopt one of the following solutions: \"\n                \"1) Just disable protected mode sending the command \"\n                \"'CONFIG SET protected-mode no' from the loopback interface \"\n                \"by connecting to Redis from the same host the server is \"\n                \"running, however MAKE SURE Redis is not publicly accessible \"\n                \"from internet if you do so. Use CONFIG REWRITE to make this \"\n                \"change permanent. \"\n                \"2) Alternatively you can just disable the protected mode by \"\n                \"editing the Redis configuration file, and setting the protected \"\n                \"mode option to 'no', and then restarting the server. \"\n                \"3) If you started the server manually just for testing, restart \"\n                \"it with the '--protected-mode no' option. \"\n                \"4) Setup a bind address or an authentication password. \"\n                \"NOTE: You only need to do one of the above things in order for \"\n                \"the server to start accepting connections from the outside.\\r\\n\";\n            if (connWrite(c->conn,err,strlen(err)) == -1) {\n                /* Nothing to do, Just to avoid the warning... */\n            }\n            server.stat_rejected_conn++;\n            freeClientAsync(c);\n            return;\n        }\n    }\n\n    server.stat_numconnections++;\n    moduleFireServerEvent(REDISMODULE_EVENT_CLIENT_CHANGE,\n                          REDISMODULE_SUBEVENT_CLIENT_CHANGE_CONNECTED,\n                          c);\n}\n\n#define MAX_ACCEPTS_PER_CALL 1000\nstatic void acceptCommonHandler(connection *conn, int flags, char *ip) {\n    client *c;\n    char conninfo[100];\n    UNUSED(ip);\n\n    if (connGetState(conn) != CONN_STATE_ACCEPTING) {\n        serverLog(LL_VERBOSE,\n            \"Accepted client connection in error state: %s (conn: %s)\",\n            connGetLastError(conn),\n            connGetInfo(conn, conninfo, sizeof(conninfo)));\n        connClose(conn);\n        return;\n    }\n\n    /* Limit the number of connections we take at the same time.\n     *\n     * Admission control will happen before a client is created and connAccept()\n     * called, because we don't want to even start transport-level negotiation\n     * if rejected. */\n    if (listLength(server.clients) + getClusterConnectionsCount()\n        >= server.maxclients)\n    {\n        char *err;\n        if (server.cluster_enabled)\n            err = \"-ERR max number of clients + cluster \"\n                  \"connections reached\\r\\n\";\n        else\n            err = \"-ERR max number of clients reached\\r\\n\";\n\n        /* That's a best effort error message, don't check write errors.\n         * Note that for TLS connections, no handshake was done yet so nothing\n         * is written and the connection will just drop. */\n        if (connWrite(conn,err,strlen(err)) == -1) {\n            /* Nothing to do, Just to avoid the warning... */\n        }\n        server.stat_rejected_conn++;\n        connClose(conn);\n        return;\n    }\n\n    /* Create connection and client */\n    if ((c = createClient(conn)) == NULL) {\n        serverLog(LL_WARNING,\n            \"Error registering fd event for the new client: %s (conn: %s)\",\n            connGetLastError(conn),\n            connGetInfo(conn, conninfo, sizeof(conninfo)));\n        connClose(conn); /* May be already closed, just ignore errors */\n        return;\n    }\n\n    /* Last chance to keep flags */\n    c->flags |= flags;\n\n    /* Initiate accept.\n     *\n     * Note that connAccept() is free to do two things here:\n     * 1. Call clientAcceptHandler() immediately;\n     * 2. Schedule a future call to clientAcceptHandler().\n     *\n     * Because of that, we must do nothing else afterwards.\n     */\n    if (connAccept(conn, clientAcceptHandler) == C_ERR) {\n        char conninfo[100];\n        if (connGetState(conn) == CONN_STATE_ERROR)\n            serverLog(LL_WARNING,\n                    \"Error accepting a client connection: %s (conn: %s)\",\n                    connGetLastError(conn), connGetInfo(conn, conninfo, sizeof(conninfo)));\n        freeClient(connGetPrivateData(conn));\n        return;\n    }\n}\n\nvoid acceptTcpHandler(aeEventLoop *el, int fd, void *privdata, int mask) {\n    int cport, cfd, max = MAX_ACCEPTS_PER_CALL;\n    char cip[NET_IP_STR_LEN];\n    UNUSED(el);\n    UNUSED(mask);\n    UNUSED(privdata);\n\n    while(max--) {\n        cfd = anetTcpAccept(server.neterr, fd, cip, sizeof(cip), &cport);\n        if (cfd == ANET_ERR) {\n            if (errno != EWOULDBLOCK)\n                serverLog(LL_WARNING,\n                    \"Accepting client connection: %s\", server.neterr);\n            return;\n        }\n        serverLog(LL_VERBOSE,\"Accepted %s:%d\", cip, cport);\n        acceptCommonHandler(connCreateAcceptedSocket(cfd),0,cip);\n    }\n}\n\nvoid acceptTLSHandler(aeEventLoop *el, int fd, void *privdata, int mask) {\n    int cport, cfd, max = MAX_ACCEPTS_PER_CALL;\n    char cip[NET_IP_STR_LEN];\n    UNUSED(el);\n    UNUSED(mask);\n    UNUSED(privdata);\n\n    while(max--) {\n        cfd = anetTcpAccept(server.neterr, fd, cip, sizeof(cip), &cport);\n        if (cfd == ANET_ERR) {\n            if (errno != EWOULDBLOCK)\n                serverLog(LL_WARNING,\n                    \"Accepting client connection: %s\", server.neterr);\n            return;\n        }\n        serverLog(LL_VERBOSE,\"Accepted %s:%d\", cip, cport);\n        acceptCommonHandler(connCreateAcceptedTLS(cfd, server.tls_auth_clients),0,cip);\n    }\n}\n\nvoid acceptUnixHandler(aeEventLoop *el, int fd, void *privdata, int mask) {\n    int cfd, max = MAX_ACCEPTS_PER_CALL;\n    UNUSED(el);\n    UNUSED(mask);\n    UNUSED(privdata);\n\n    while(max--) {\n        cfd = anetUnixAccept(server.neterr, fd);\n        if (cfd == ANET_ERR) {\n            if (errno != EWOULDBLOCK)\n                serverLog(LL_WARNING,\n                    \"Accepting client connection: %s\", server.neterr);\n            return;\n        }\n        serverLog(LL_VERBOSE,\"Accepted connection to %s\", server.unixsocket);\n        acceptCommonHandler(connCreateAcceptedSocket(cfd),CLIENT_UNIX_SOCKET,NULL);\n    }\n}\n\nstatic void freeClientArgv(client *c) {\n    int j;\n    for (j = 0; j < c->argc; j++)\n        decrRefCount(c->argv[j]);\n    c->argc = 0;\n    c->cmd = NULL;\n    c->argv_len_sum = 0;\n}\n\n/* Close all the slaves connections. This is useful in chained replication\n * when we resync with our own master and want to force all our slaves to\n * resync with us as well. */\nvoid disconnectSlaves(void) {\n    listIter li;\n    listNode *ln;\n    listRewind(server.slaves,&li);\n    while((ln = listNext(&li))) {\n        freeClient((client*)ln->value);\n    }\n}\n\n/* Remove the specified client from global lists where the client could\n * be referenced, not including the Pub/Sub channels.\n * This is used by freeClient() and replicationCacheMaster(). */\nvoid unlinkClient(client *c) {\n    listNode *ln;\n\n    /* If this is marked as current client unset it. */\n    if (server.current_client == c) server.current_client = NULL;\n\n    /* Certain operations must be done only if the client has an active connection.\n     * If the client was already unlinked or if it's a \"fake client\" the\n     * conn is already set to NULL. */\n    if (c->conn) {\n        /* Remove from the list of active clients. */\n        if (c->client_list_node) {\n            uint64_t id = htonu64(c->id);\n            raxRemove(server.clients_index,(unsigned char*)&id,sizeof(id),NULL);\n            listDelNode(server.clients,c->client_list_node);\n            c->client_list_node = NULL;\n        }\n\n        /* Check if this is a replica waiting for diskless replication (rdb pipe),\n         * in which case it needs to be cleaned from that list */\n        if (c->flags & CLIENT_SLAVE &&\n            c->replstate == SLAVE_STATE_WAIT_BGSAVE_END &&\n            server.rdb_pipe_conns)\n        {\n            int i;\n            for (i=0; i < server.rdb_pipe_numconns; i++) {\n                if (server.rdb_pipe_conns[i] == c->conn) {\n                    rdbPipeWriteHandlerConnRemoved(c->conn);\n                    server.rdb_pipe_conns[i] = NULL;\n                    break;\n                }\n            }\n        }\n        connClose(c->conn);\n        c->conn = NULL;\n    }\n\n    /* Remove from the list of pending writes if needed. */\n    if (c->flags & CLIENT_PENDING_WRITE) {\n        ln = listSearchKey(server.clients_pending_write,c);\n        serverAssert(ln != NULL);\n        listDelNode(server.clients_pending_write,ln);\n        c->flags &= ~CLIENT_PENDING_WRITE;\n    }\n\n    /* Remove from the list of pending reads if needed. */\n    if (c->flags & CLIENT_PENDING_READ) {\n        ln = listSearchKey(server.clients_pending_read,c);\n        serverAssert(ln != NULL);\n        listDelNode(server.clients_pending_read,ln);\n        c->flags &= ~CLIENT_PENDING_READ;\n    }\n\n    /* When client was just unblocked because of a blocking operation,\n     * remove it from the list of unblocked clients. */\n    if (c->flags & CLIENT_UNBLOCKED) {\n        ln = listSearchKey(server.unblocked_clients,c);\n        serverAssert(ln != NULL);\n        listDelNode(server.unblocked_clients,ln);\n        c->flags &= ~CLIENT_UNBLOCKED;\n    }\n\n    /* Clear the tracking status. */\n    if (c->flags & CLIENT_TRACKING) disableTracking(c);\n}\n\nvoid freeClient(client *c) {\n    listNode *ln;\n\n    /* If a client is protected, yet we need to free it right now, make sure\n     * to at least use asynchronous freeing. */\n    if (c->flags & CLIENT_PROTECTED) {\n        freeClientAsync(c);\n        return;\n    }\n\n    /* For connected clients, call the disconnection event of modules hooks. */\n    if (c->conn) {\n        moduleFireServerEvent(REDISMODULE_EVENT_CLIENT_CHANGE,\n                              REDISMODULE_SUBEVENT_CLIENT_CHANGE_DISCONNECTED,\n                              c);\n    }\n\n    /* Notify module system that this client auth status changed. */\n    moduleNotifyUserChanged(c);\n\n    /* If this client was scheduled for async freeing we need to remove it\n     * from the queue. Note that we need to do this here, because later\n     * we may call replicationCacheMaster() and the client should already\n     * be removed from the list of clients to free. */\n    if (c->flags & CLIENT_CLOSE_ASAP) {\n        ln = listSearchKey(server.clients_to_close,c);\n        serverAssert(ln != NULL);\n        listDelNode(server.clients_to_close,ln);\n    }\n\n    /* If it is our master that's being disconnected we should make sure\n     * to cache the state to try a partial resynchronization later.\n     *\n     * Note that before doing this we make sure that the client is not in\n     * some unexpected state, by checking its flags. */\n    if (server.master && c->flags & CLIENT_MASTER) {\n        serverLog(LL_WARNING,\"Connection with master lost.\");\n        if (!(c->flags & (CLIENT_PROTOCOL_ERROR|CLIENT_BLOCKED))) {\n            c->flags &= ~(CLIENT_CLOSE_ASAP|CLIENT_CLOSE_AFTER_REPLY);\n            replicationCacheMaster(c);\n            return;\n        }\n    }\n\n    /* Log link disconnection with slave */\n    if (getClientType(c) == CLIENT_TYPE_SLAVE) {\n        serverLog(LL_WARNING,\"Connection with replica %s lost.\",\n            replicationGetSlaveName(c));\n    }\n\n    /* Free the query buffer */\n    sdsfree(c->querybuf);\n    sdsfree(c->pending_querybuf);\n    c->querybuf = NULL;\n\n    /* Deallocate structures used to block on blocking ops. */\n    if (c->flags & CLIENT_BLOCKED) unblockClient(c);\n    dictRelease(c->bpop.keys);\n\n    /* UNWATCH all the keys */\n    unwatchAllKeys(c);\n    listRelease(c->watched_keys);\n\n    /* Unsubscribe from all the pubsub channels */\n    pubsubUnsubscribeAllChannels(c,0);\n    pubsubUnsubscribeAllPatterns(c,0);\n    dictRelease(c->pubsub_channels);\n    listRelease(c->pubsub_patterns);\n\n    /* Free data structures. */\n    listRelease(c->reply);\n    freeClientArgv(c);\n\n    /* Unlink the client: this will close the socket, remove the I/O\n     * handlers, and remove references of the client from different\n     * places where active clients may be referenced. */\n    unlinkClient(c);\n\n    /* Master/slave cleanup Case 1:\n     * we lost the connection with a slave. */\n    if (c->flags & CLIENT_SLAVE) {\n        if (c->replstate == SLAVE_STATE_SEND_BULK) {\n            if (c->repldbfd != -1) close(c->repldbfd);\n            if (c->replpreamble) sdsfree(c->replpreamble);\n        }\n        list *l = (c->flags & CLIENT_MONITOR) ? server.monitors : server.slaves;\n        ln = listSearchKey(l,c);\n        serverAssert(ln != NULL);\n        listDelNode(l,ln);\n        /* We need to remember the time when we started to have zero\n         * attached slaves, as after some time we'll free the replication\n         * backlog. */\n        if (getClientType(c) == CLIENT_TYPE_SLAVE && listLength(server.slaves) == 0)\n            server.repl_no_slaves_since = server.unixtime;\n        refreshGoodSlavesCount();\n        /* Fire the replica change modules event. */\n        if (c->replstate == SLAVE_STATE_ONLINE)\n            moduleFireServerEvent(REDISMODULE_EVENT_REPLICA_CHANGE,\n                                  REDISMODULE_SUBEVENT_REPLICA_CHANGE_OFFLINE,\n                                  NULL);\n    }\n\n    /* Master/slave cleanup Case 2:\n     * we lost the connection with the master. */\n    if (c->flags & CLIENT_MASTER) replicationHandleMasterDisconnection();\n\n   /* Remove the contribution that this client gave to our\n     * incrementally computed memory usage. */\n    server.stat_clients_type_memory[c->client_cron_last_memory_type] -=\n        c->client_cron_last_memory_usage;\n\n    /* Release other dynamically allocated client structure fields,\n     * and finally release the client structure itself. */\n    if (c->name) decrRefCount(c->name);\n    zfree(c->argv);\n    c->argv_len_sum = 0;\n    freeClientMultiState(c);\n    sdsfree(c->peerid);\n    zfree(c);\n}\n\n/* Schedule a client to free it at a safe time in the serverCron() function.\n * This function is useful when we need to terminate a client but we are in\n * a context where calling freeClient() is not possible, because the client\n * should be valid for the continuation of the flow of the program. */\nvoid freeClientAsync(client *c) {\n    /* We need to handle concurrent access to the server.clients_to_close list\n     * only in the freeClientAsync() function, since it's the only function that\n     * may access the list while Redis uses I/O threads. All the other accesses\n     * are in the context of the main thread while the other threads are\n     * idle. */\n    if (c->flags & CLIENT_CLOSE_ASAP || c->flags & CLIENT_LUA) return;\n    c->flags |= CLIENT_CLOSE_ASAP;\n    if (server.io_threads_num == 1) {\n        /* no need to bother with locking if there's just one thread (the main thread) */\n        listAddNodeTail(server.clients_to_close,c);\n        return;\n    }\n    static pthread_mutex_t async_free_queue_mutex = PTHREAD_MUTEX_INITIALIZER;\n    pthread_mutex_lock(&async_free_queue_mutex);\n    listAddNodeTail(server.clients_to_close,c);\n    pthread_mutex_unlock(&async_free_queue_mutex);\n}\n\n/* Free the clietns marked as CLOSE_ASAP, return the number of clients\n * freed. */\nint freeClientsInAsyncFreeQueue(void) {\n    int freed = 0;\n    listIter li;\n    listNode *ln;\n\n    listRewind(server.clients_to_close,&li);\n    while ((ln = listNext(&li)) != NULL) {\n        client *c = listNodeValue(ln);\n\n        if (c->flags & CLIENT_PROTECTED) continue;\n\n        c->flags &= ~CLIENT_CLOSE_ASAP;\n        freeClient(c);\n        listDelNode(server.clients_to_close,ln);\n        freed++;\n    }\n    return freed;\n}\n\n/* Return a client by ID, or NULL if the client ID is not in the set\n * of registered clients. Note that \"fake clients\", created with -1 as FD,\n * are not registered clients. */\nclient *lookupClientByID(uint64_t id) {\n    id = htonu64(id);\n    client *c = raxFind(server.clients_index,(unsigned char*)&id,sizeof(id));\n    return (c == raxNotFound) ? NULL : c;\n}\n\n/* Write data in output buffers to client. Return C_OK if the client\n * is still valid after the call, C_ERR if it was freed because of some\n * error.  If handler_installed is set, it will attempt to clear the\n * write event.\n *\n * This function is called by threads, but always with handler_installed\n * set to 0. So when handler_installed is set to 0 the function must be\n * thread safe. */\nint writeToClient(client *c, int handler_installed) {\n    /* Update total number of writes on server */\n    server.stat_total_writes_processed++;\n\n    ssize_t nwritten = 0, totwritten = 0;\n    size_t objlen;\n    clientReplyBlock *o;\n\n    while(clientHasPendingReplies(c)) {\n        if (c->bufpos > 0) {\n            nwritten = connWrite(c->conn,c->buf+c->sentlen,c->bufpos-c->sentlen);\n            if (nwritten <= 0) break;\n            c->sentlen += nwritten;\n            totwritten += nwritten;\n\n            /* If the buffer was sent, set bufpos to zero to continue with\n             * the remainder of the reply. */\n            if ((int)c->sentlen == c->bufpos) {\n                c->bufpos = 0;\n                c->sentlen = 0;\n            }\n        } else {\n            o = listNodeValue(listFirst(c->reply));\n            objlen = o->used;\n\n            if (objlen == 0) {\n                c->reply_bytes -= o->size;\n                listDelNode(c->reply,listFirst(c->reply));\n                continue;\n            }\n\n            nwritten = connWrite(c->conn, o->buf + c->sentlen, objlen - c->sentlen);\n            if (nwritten <= 0) break;\n            c->sentlen += nwritten;\n            totwritten += nwritten;\n\n            /* If we fully sent the object on head go to the next one */\n            if (c->sentlen == objlen) {\n                c->reply_bytes -= o->size;\n                listDelNode(c->reply,listFirst(c->reply));\n                c->sentlen = 0;\n                /* If there are no longer objects in the list, we expect\n                 * the count of reply bytes to be exactly zero. */\n                if (listLength(c->reply) == 0)\n                    serverAssert(c->reply_bytes == 0);\n            }\n        }\n        /* Note that we avoid to send more than NET_MAX_WRITES_PER_EVENT\n         * bytes, in a single threaded server it's a good idea to serve\n         * other clients as well, even if a very large request comes from\n         * super fast link that is always able to accept data (in real world\n         * scenario think about 'KEYS *' against the loopback interface).\n         *\n         * However if we are over the maxmemory limit we ignore that and\n         * just deliver as much data as it is possible to deliver.\n         *\n         * Moreover, we also send as much as possible if the client is\n         * a slave or a monitor (otherwise, on high-speed traffic, the\n         * replication/output buffer will grow indefinitely) */\n        if (totwritten > NET_MAX_WRITES_PER_EVENT &&\n            (server.maxmemory == 0 ||\n             zmalloc_used_memory() < server.maxmemory) &&\n            !(c->flags & CLIENT_SLAVE)) break;\n    }\n    server.stat_net_output_bytes += totwritten;\n    if (nwritten == -1) {\n        if (connGetState(c->conn) == CONN_STATE_CONNECTED) {\n            nwritten = 0;\n        } else {\n            serverLog(LL_VERBOSE,\n                \"Error writing to client: %s\", connGetLastError(c->conn));\n            freeClientAsync(c);\n            return C_ERR;\n        }\n    }\n    if (totwritten > 0) {\n        /* For clients representing masters we don't count sending data\n         * as an interaction, since we always send REPLCONF ACK commands\n         * that take some time to just fill the socket output buffer.\n         * We just rely on data / pings received for timeout detection. */\n        if (!(c->flags & CLIENT_MASTER)) c->lastinteraction = server.unixtime;\n    }\n    if (!clientHasPendingReplies(c)) {\n        c->sentlen = 0;\n        /* Note that writeToClient() is called in a threaded way, but\n         * adDeleteFileEvent() is not thread safe: however writeToClient()\n         * is always called with handler_installed set to 0 from threads\n         * so we are fine. */\n        if (handler_installed) connSetWriteHandler(c->conn, NULL);\n\n        /* Close connection after entire reply has been sent. */\n        if (c->flags & CLIENT_CLOSE_AFTER_REPLY) {\n            freeClientAsync(c);\n            return C_ERR;\n        }\n    }\n    return C_OK;\n}\n\n/* Write event handler. Just send data to the client. */\nvoid sendReplyToClient(connection *conn) {\n    client *c = connGetPrivateData(conn);\n    writeToClient(c,1);\n}\n\n/* This function is called just before entering the event loop, in the hope\n * we can just write the replies to the client output buffer without any\n * need to use a syscall in order to install the writable event handler,\n * get it called, and so forth. */\nint handleClientsWithPendingWrites(void) {\n    listIter li;\n    listNode *ln;\n    int processed = listLength(server.clients_pending_write);\n\n    listRewind(server.clients_pending_write,&li);\n    while((ln = listNext(&li))) {\n        client *c = listNodeValue(ln);\n        c->flags &= ~CLIENT_PENDING_WRITE;\n        listDelNode(server.clients_pending_write,ln);\n\n        /* If a client is protected, don't do anything,\n         * that may trigger write error or recreate handler. */\n        if (c->flags & CLIENT_PROTECTED) continue;\n\n        /* Don't write to clients that are going to be closed anyway. */\n        if (c->flags & CLIENT_CLOSE_ASAP) continue;\n\n        /* Try to write buffers to the client socket. */\n        if (writeToClient(c,0) == C_ERR) continue;\n\n        /* If after the synchronous writes above we still have data to\n         * output to the client, we need to install the writable handler. */\n        if (clientHasPendingReplies(c)) {\n            int ae_barrier = 0;\n            /* For the fsync=always policy, we want that a given FD is never\n             * served for reading and writing in the same event loop iteration,\n             * so that in the middle of receiving the query, and serving it\n             * to the client, we'll call beforeSleep() that will do the\n             * actual fsync of AOF to disk. the write barrier ensures that. */\n            if (server.aof_state == AOF_ON &&\n                server.aof_fsync == AOF_FSYNC_ALWAYS)\n            {\n                ae_barrier = 1;\n            }\n            if (connSetWriteHandlerWithBarrier(c->conn, sendReplyToClient, ae_barrier) == C_ERR) {\n                freeClientAsync(c);\n            }\n        }\n    }\n    return processed;\n}\n\n/* resetClient prepare the client to process the next command */\nvoid resetClient(client *c) {\n    redisCommandProc *prevcmd = c->cmd ? c->cmd->proc : NULL;\n\n    freeClientArgv(c);\n    c->reqtype = 0;\n    c->multibulklen = 0;\n    c->bulklen = -1;\n\n    /* We clear the ASKING flag as well if we are not inside a MULTI, and\n     * if what we just executed is not the ASKING command itself. */\n    if (!(c->flags & CLIENT_MULTI) && prevcmd != askingCommand)\n        c->flags &= ~CLIENT_ASKING;\n\n    /* We do the same for the CACHING command as well. It also affects\n     * the next command or transaction executed, in a way very similar\n     * to ASKING. */\n    if (!(c->flags & CLIENT_MULTI) && prevcmd != clientCommand)\n        c->flags &= ~CLIENT_TRACKING_CACHING;\n\n    /* Remove the CLIENT_REPLY_SKIP flag if any so that the reply\n     * to the next command will be sent, but set the flag if the command\n     * we just processed was \"CLIENT REPLY SKIP\". */\n    c->flags &= ~CLIENT_REPLY_SKIP;\n    if (c->flags & CLIENT_REPLY_SKIP_NEXT) {\n        c->flags |= CLIENT_REPLY_SKIP;\n        c->flags &= ~CLIENT_REPLY_SKIP_NEXT;\n    }\n}\n\n/* This function is used when we want to re-enter the event loop but there\n * is the risk that the client we are dealing with will be freed in some\n * way. This happens for instance in:\n *\n * * DEBUG RELOAD and similar.\n * * When a Lua script is in -BUSY state.\n *\n * So the function will protect the client by doing two things:\n *\n * 1) It removes the file events. This way it is not possible that an\n *    error is signaled on the socket, freeing the client.\n * 2) Moreover it makes sure that if the client is freed in a different code\n *    path, it is not really released, but only marked for later release. */\nvoid protectClient(client *c) {\n    c->flags |= CLIENT_PROTECTED;\n    if (c->conn) {\n        connSetReadHandler(c->conn,NULL);\n        connSetWriteHandler(c->conn,NULL);\n    }\n}\n\n/* This will undo the client protection done by protectClient() */\nvoid unprotectClient(client *c) {\n    if (c->flags & CLIENT_PROTECTED) {\n        c->flags &= ~CLIENT_PROTECTED;\n        if (c->conn) {\n            connSetReadHandler(c->conn,readQueryFromClient);\n            if (clientHasPendingReplies(c)) clientInstallWriteHandler(c);\n        }\n    }\n}\n\n/* Like processMultibulkBuffer(), but for the inline protocol instead of RESP,\n * this function consumes the client query buffer and creates a command ready\n * to be executed inside the client structure. Returns C_OK if the command\n * is ready to be executed, or C_ERR if there is still protocol to read to\n * have a well formed command. The function also returns C_ERR when there is\n * a protocol error: in such a case the client structure is setup to reply\n * with the error and close the connection. */\nint processInlineBuffer(client *c) {\n    char *newline;\n    int argc, j, linefeed_chars = 1;\n    sds *argv, aux;\n    size_t querylen;\n\n    /* Search for end of line */\n    newline = strchr(c->querybuf+c->qb_pos,'\\n');\n\n    /* Nothing to do without a \\r\\n */\n    if (newline == NULL) {\n        if (sdslen(c->querybuf)-c->qb_pos > PROTO_INLINE_MAX_SIZE) {\n            addReplyError(c,\"Protocol error: too big inline request\");\n            setProtocolError(\"too big inline request\",c);\n        }\n        return C_ERR;\n    }\n\n    /* Handle the \\r\\n case. */\n    if (newline && newline != c->querybuf+c->qb_pos && *(newline-1) == '\\r')\n        newline--, linefeed_chars++;\n\n    /* Split the input buffer up to the \\r\\n */\n    querylen = newline-(c->querybuf+c->qb_pos);\n    aux = sdsnewlen(c->querybuf+c->qb_pos,querylen);\n    argv = sdssplitargs(aux,&argc);\n    sdsfree(aux);\n    if (argv == NULL) {\n        addReplyError(c,\"Protocol error: unbalanced quotes in request\");\n        setProtocolError(\"unbalanced quotes in inline request\",c);\n        return C_ERR;\n    }\n\n    /* Newline from slaves can be used to refresh the last ACK time.\n     * This is useful for a slave to ping back while loading a big\n     * RDB file. */\n    if (querylen == 0 && getClientType(c) == CLIENT_TYPE_SLAVE)\n        c->repl_ack_time = server.unixtime;\n\n    /* Masters should never send us inline protocol to run actual\n     * commands. If this happens, it is likely due to a bug in Redis where\n     * we got some desynchronization in the protocol, for example\n     * beause of a PSYNC gone bad.\n     *\n     * However the is an exception: masters may send us just a newline\n     * to keep the connection active. */\n    if (querylen != 0 && c->flags & CLIENT_MASTER) {\n        sdsfreesplitres(argv,argc);\n        serverLog(LL_WARNING,\"WARNING: Receiving inline protocol from master, master stream corruption? Closing the master connection and discarding the cached master.\");\n        setProtocolError(\"Master using the inline protocol. Desync?\",c);\n        return C_ERR;\n    }\n\n    /* Move querybuffer position to the next query in the buffer. */\n    c->qb_pos += querylen+linefeed_chars;\n\n    /* Setup argv array on client structure */\n    if (argc) {\n        if (c->argv) zfree(c->argv);\n        c->argv = zmalloc(sizeof(robj*)*argc);\n        c->argv_len_sum = 0;\n    }\n\n    /* Create redis objects for all arguments. */\n    for (c->argc = 0, j = 0; j < argc; j++) {\n        c->argv[c->argc] = createObject(OBJ_STRING,argv[j]);\n        c->argc++;\n        c->argv_len_sum += sdslen(argv[j]);\n    }\n    zfree(argv);\n    return C_OK;\n}\n\n/* Helper function. Record protocol erro details in server log,\n * and set the client as CLIENT_CLOSE_AFTER_REPLY and\n * CLIENT_PROTOCOL_ERROR. */\n#define PROTO_DUMP_LEN 128\nstatic void setProtocolError(const char *errstr, client *c) {\n    if (server.verbosity <= LL_VERBOSE || c->flags & CLIENT_MASTER) {\n        sds client = catClientInfoString(sdsempty(),c);\n\n        /* Sample some protocol to given an idea about what was inside. */\n        char buf[256];\n        if (sdslen(c->querybuf)-c->qb_pos < PROTO_DUMP_LEN) {\n            snprintf(buf,sizeof(buf),\"Query buffer during protocol error: '%s'\", c->querybuf+c->qb_pos);\n        } else {\n            snprintf(buf,sizeof(buf),\"Query buffer during protocol error: '%.*s' (... more %zu bytes ...) '%.*s'\", PROTO_DUMP_LEN/2, c->querybuf+c->qb_pos, sdslen(c->querybuf)-c->qb_pos-PROTO_DUMP_LEN, PROTO_DUMP_LEN/2, c->querybuf+sdslen(c->querybuf)-PROTO_DUMP_LEN/2);\n        }\n\n        /* Remove non printable chars. */\n        char *p = buf;\n        while (*p != '\\0') {\n            if (!isprint(*p)) *p = '.';\n            p++;\n        }\n\n        /* Log all the client and protocol info. */\n        int loglevel = (c->flags & CLIENT_MASTER) ? LL_WARNING :\n                                                    LL_VERBOSE;\n        serverLog(loglevel,\n            \"Protocol error (%s) from client: %s. %s\", errstr, client, buf);\n        sdsfree(client);\n    }\n    c->flags |= (CLIENT_CLOSE_AFTER_REPLY|CLIENT_PROTOCOL_ERROR);\n}\n\n/* Process the query buffer for client 'c', setting up the client argument\n * vector for command execution. Returns C_OK if after running the function\n * the client has a well-formed ready to be processed command, otherwise\n * C_ERR if there is still to read more buffer to get the full command.\n * The function also returns C_ERR when there is a protocol error: in such a\n * case the client structure is setup to reply with the error and close\n * the connection.\n *\n * This function is called if processInputBuffer() detects that the next\n * command is in RESP format, so the first byte in the command is found\n * to be '*'. Otherwise for inline commands processInlineBuffer() is called. */\nint processMultibulkBuffer(client *c) {\n    char *newline = NULL;\n    int ok;\n    long long ll;\n\n    if (c->multibulklen == 0) {\n        /* The client should have been reset */\n        serverAssertWithInfo(c,NULL,c->argc == 0);\n\n        /* Multi bulk length cannot be read without a \\r\\n */\n        newline = strchr(c->querybuf+c->qb_pos,'\\r');\n        if (newline == NULL) {\n            if (sdslen(c->querybuf)-c->qb_pos > PROTO_INLINE_MAX_SIZE) {\n                addReplyError(c,\"Protocol error: too big mbulk count string\");\n                setProtocolError(\"too big mbulk count string\",c);\n            }\n            return C_ERR;\n        }\n\n        /* Buffer should also contain \\n */\n        if (newline-(c->querybuf+c->qb_pos) > (ssize_t)(sdslen(c->querybuf)-c->qb_pos-2))\n            return C_ERR;\n\n        /* We know for sure there is a whole line since newline != NULL,\n         * so go ahead and find out the multi bulk length. */\n        serverAssertWithInfo(c,NULL,c->querybuf[c->qb_pos] == '*');\n        ok = string2ll(c->querybuf+1+c->qb_pos,newline-(c->querybuf+1+c->qb_pos),&ll);\n        if (!ok || ll > 1024*1024) {\n            addReplyError(c,\"Protocol error: invalid multibulk length\");\n            setProtocolError(\"invalid mbulk count\",c);\n            return C_ERR;\n        } else if (ll > 10 && authRequired(c)) {\n            addReplyError(c, \"Protocol error: unauthenticated multibulk length\");\n            setProtocolError(\"unauth mbulk count\", c);\n            return C_ERR;\n        }\n\n        c->qb_pos = (newline-c->querybuf)+2;\n\n        if (ll <= 0) return C_OK;\n\n        c->multibulklen = ll;\n\n        /* Setup argv array on client structure */\n        if (c->argv) zfree(c->argv);\n        c->argv = zmalloc(sizeof(robj*)*c->multibulklen);\n        c->argv_len_sum = 0;\n    }\n\n    serverAssertWithInfo(c,NULL,c->multibulklen > 0);\n    while(c->multibulklen) {\n        /* Read bulk length if unknown */\n        if (c->bulklen == -1) {\n            newline = strchr(c->querybuf+c->qb_pos,'\\r');\n            if (newline == NULL) {\n                if (sdslen(c->querybuf)-c->qb_pos > PROTO_INLINE_MAX_SIZE) {\n                    addReplyError(c,\n                        \"Protocol error: too big bulk count string\");\n                    setProtocolError(\"too big bulk count string\",c);\n                    return C_ERR;\n                }\n                break;\n            }\n\n            /* Buffer should also contain \\n */\n            if (newline-(c->querybuf+c->qb_pos) > (ssize_t)(sdslen(c->querybuf)-c->qb_pos-2))\n                break;\n\n            if (c->querybuf[c->qb_pos] != '$') {\n                addReplyErrorFormat(c,\n                    \"Protocol error: expected '$', got '%c'\",\n                    c->querybuf[c->qb_pos]);\n                setProtocolError(\"expected $ but got something else\",c);\n                return C_ERR;\n            }\n\n            ok = string2ll(c->querybuf+c->qb_pos+1,newline-(c->querybuf+c->qb_pos+1),&ll);\n            if (!ok || ll < 0 ||\n                (!(c->flags & CLIENT_MASTER) && ll > server.proto_max_bulk_len)) {\n                addReplyError(c,\"Protocol error: invalid bulk length\");\n                setProtocolError(\"invalid bulk length\",c);\n                return C_ERR;\n            } else if (ll > 16384 && authRequired(c)) {\n                addReplyError(c, \"Protocol error: unauthenticated bulk length\");\n                setProtocolError(\"unauth bulk length\", c);\n                return C_ERR;\n            }\n\n            c->qb_pos = newline-c->querybuf+2;\n            if (ll >= PROTO_MBULK_BIG_ARG) {\n                /* If we are going to read a large object from network\n                 * try to make it likely that it will start at c->querybuf\n                 * boundary so that we can optimize object creation\n                 * avoiding a large copy of data.\n                 *\n                 * But only when the data we have not parsed is less than\n                 * or equal to ll+2. If the data length is greater than\n                 * ll+2, trimming querybuf is just a waste of time, because\n                 * at this time the querybuf contains not only our bulk. */\n                if (sdslen(c->querybuf)-c->qb_pos <= (size_t)ll+2) {\n                    sdsrange(c->querybuf,c->qb_pos,-1);\n                    c->qb_pos = 0;\n                    /* Hint the sds library about the amount of bytes this string is\n                     * going to contain. */\n                    c->querybuf = sdsMakeRoomFor(c->querybuf,ll+2-sdslen(c->querybuf));\n                }\n            }\n            c->bulklen = ll;\n        }\n\n        /* Read bulk argument */\n        if (sdslen(c->querybuf)-c->qb_pos < (size_t)(c->bulklen+2)) {\n            /* Not enough data (+2 == trailing \\r\\n) */\n            break;\n        } else {\n            /* Optimization: if the buffer contains JUST our bulk element\n             * instead of creating a new object by *copying* the sds we\n             * just use the current sds string. */\n            if (c->qb_pos == 0 &&\n                c->bulklen >= PROTO_MBULK_BIG_ARG &&\n                sdslen(c->querybuf) == (size_t)(c->bulklen+2))\n            {\n                c->argv[c->argc++] = createObject(OBJ_STRING,c->querybuf);\n                c->argv_len_sum += c->bulklen;\n                sdsIncrLen(c->querybuf,-2); /* remove CRLF */\n                /* Assume that if we saw a fat argument we'll see another one\n                 * likely... */\n                c->querybuf = sdsnewlen(SDS_NOINIT,c->bulklen+2);\n                sdsclear(c->querybuf);\n            } else {\n                c->argv[c->argc++] =\n                    createStringObject(c->querybuf+c->qb_pos,c->bulklen);\n                c->argv_len_sum += c->bulklen;\n                c->qb_pos += c->bulklen+2;\n            }\n            c->bulklen = -1;\n            c->multibulklen--;\n        }\n    }\n\n    /* We're done when c->multibulk == 0 */\n    if (c->multibulklen == 0) return C_OK;\n\n    /* Still not ready to process the command */\n    return C_ERR;\n}\n\n/* Perform necessary tasks after a command was executed:\n *\n * 1. The client is reset unless there are reasons to avoid doing it.\n * 2. In the case of master clients, the replication offset is updated.\n * 3. Propagate commands we got from our master to replicas down the line. */\nvoid commandProcessed(client *c) {\n    long long prev_offset = c->reploff;\n    if (c->flags & CLIENT_MASTER && !(c->flags & CLIENT_MULTI)) {\n        /* Update the applied replication offset of our master. */\n        c->reploff = c->read_reploff - sdslen(c->querybuf) + c->qb_pos;\n    }\n\n    /* Don't reset the client structure for clients blocked in a\n     * module blocking command, so that the reply callback will\n     * still be able to access the client argv and argc field.\n     * The client will be reset in unblockClientFromModule(). */\n    if (!(c->flags & CLIENT_BLOCKED) ||\n        c->btype != BLOCKED_MODULE)\n    {\n        resetClient(c);\n    }\n\n    /* If the client is a master we need to compute the difference\n     * between the applied offset before and after processing the buffer,\n     * to understand how much of the replication stream was actually\n     * applied to the master state: this quantity, and its corresponding\n     * part of the replication stream, will be propagated to the\n     * sub-replicas and to the replication backlog. */\n    if (c->flags & CLIENT_MASTER) {\n        long long applied = c->reploff - prev_offset;\n        if (applied) {\n            replicationFeedSlavesFromMasterStream(server.slaves,\n                    c->pending_querybuf, applied);\n            sdsrange(c->pending_querybuf,applied,-1);\n        }\n    }\n}\n\n/* This function calls processCommand(), but also performs a few sub tasks\n * for the client that are useful in that context:\n *\n * 1. It sets the current client to the client 'c'.\n * 2. calls commandProcessed() if the command was handled.\n *\n * The function returns C_ERR in case the client was freed as a side effect\n * of processing the command, otherwise C_OK is returned. */\nint processCommandAndResetClient(client *c) {\n    int deadclient = 0;\n    server.current_client = c;\n    if (processCommand(c) == C_OK) {\n        commandProcessed(c);\n    }\n    if (server.current_client == NULL) deadclient = 1;\n    server.current_client = NULL;\n    /* freeMemoryIfNeeded may flush slave output buffers. This may\n     * result into a slave, that may be the active client, to be\n     * freed. */\n    return deadclient ? C_ERR : C_OK;\n}\n\n/* This function will execute any fully parsed commands pending on\n * the client. Returns C_ERR if the client is no longer valid after executing\n * the command, and C_OK for all other cases. */\nint processPendingCommandsAndResetClient(client *c) {\n    if (c->flags & CLIENT_PENDING_COMMAND) {\n        c->flags &= ~CLIENT_PENDING_COMMAND;\n        if (processCommandAndResetClient(c) == C_ERR) {\n            return C_ERR;\n        }\n    }\n    return C_OK;\n}\n\n/* This function is called every time, in the client structure 'c', there is\n * more query buffer to process, because we read more data from the socket\n * or because a client was blocked and later reactivated, so there could be\n * pending query buffer, already representing a full command, to process. */\nvoid processInputBuffer(client *c) {\n    /* Keep processing while there is something in the input buffer */\n    while(c->qb_pos < sdslen(c->querybuf)) {\n        /* Return if clients are paused. */\n        if (!(c->flags & CLIENT_SLAVE) && \n            !(c->flags & CLIENT_PENDING_READ) && \n            clientsArePaused()) break;\n\n        /* Immediately abort if the client is in the middle of something. */\n        if (c->flags & CLIENT_BLOCKED) break;\n\n        /* Don't process more buffers from clients that have already pending\n         * commands to execute in c->argv. */\n        if (c->flags & CLIENT_PENDING_COMMAND) break;\n\n        /* Don't process input from the master while there is a busy script\n         * condition on the slave. We want just to accumulate the replication\n         * stream (instead of replying -BUSY like we do with other clients) and\n         * later resume the processing. */\n        if (server.lua_timedout && c->flags & CLIENT_MASTER) break;\n\n        /* CLIENT_CLOSE_AFTER_REPLY closes the connection once the reply is\n         * written to the client. Make sure to not let the reply grow after\n         * this flag has been set (i.e. don't process more commands).\n         *\n         * The same applies for clients we want to terminate ASAP. */\n        if (c->flags & (CLIENT_CLOSE_AFTER_REPLY|CLIENT_CLOSE_ASAP)) break;\n\n        /* Determine request type when unknown. */\n        if (!c->reqtype) {\n            if (c->querybuf[c->qb_pos] == '*') {\n                c->reqtype = PROTO_REQ_MULTIBULK;\n            } else {\n                c->reqtype = PROTO_REQ_INLINE;\n            }\n        }\n\n        if (c->reqtype == PROTO_REQ_INLINE) {\n            if (processInlineBuffer(c) != C_OK) break;\n            /* If the Gopher mode and we got zero or one argument, process\n             * the request in Gopher mode. To avoid data race, Redis won't\n             * support Gopher if enable io threads to read queries. */\n            if (server.gopher_enabled && !server.io_threads_do_reads &&\n                ((c->argc == 1 && ((char*)(c->argv[0]->ptr))[0] == '/') ||\n                  c->argc == 0))\n            {\n                processGopherRequest(c);\n                resetClient(c);\n                c->flags |= CLIENT_CLOSE_AFTER_REPLY;\n                break;\n            }\n        } else if (c->reqtype == PROTO_REQ_MULTIBULK) {\n            if (processMultibulkBuffer(c) != C_OK) break;\n        } else {\n            serverPanic(\"Unknown request type\");\n        }\n\n        /* Multibulk processing could see a <= 0 length. */\n        if (c->argc == 0) {\n            resetClient(c);\n        } else {\n            /* If we are in the context of an I/O thread, we can't really\n             * execute the command here. All we can do is to flag the client\n             * as one that needs to process the command. */\n            if (c->flags & CLIENT_PENDING_READ) {\n                c->flags |= CLIENT_PENDING_COMMAND;\n                break;\n            }\n\n            /* We are finally ready to execute the command. */\n            if (processCommandAndResetClient(c) == C_ERR) {\n                /* If the client is no longer valid, we avoid exiting this\n                 * loop and trimming the client buffer later. So we return\n                 * ASAP in that case. */\n                return;\n            }\n        }\n    }\n\n    /* Trim to pos */\n    if (c->qb_pos) {\n        sdsrange(c->querybuf,c->qb_pos,-1);\n        c->qb_pos = 0;\n    }\n}\n\nvoid readQueryFromClient(connection *conn) {\n    client *c = connGetPrivateData(conn);\n    int nread, readlen;\n    size_t qblen;\n\n    /* Check if we want to read from the client later when exiting from\n     * the event loop. This is the case if threaded I/O is enabled. */\n    if (postponeClientRead(c)) return;\n\n    /* Update total number of reads on server */\n    server.stat_total_reads_processed++;\n\n    readlen = PROTO_IOBUF_LEN;\n    /* If this is a multi bulk request, and we are processing a bulk reply\n     * that is large enough, try to maximize the probability that the query\n     * buffer contains exactly the SDS string representing the object, even\n     * at the risk of requiring more read(2) calls. This way the function\n     * processMultiBulkBuffer() can avoid copying buffers to create the\n     * Redis Object representing the argument. */\n    if (c->reqtype == PROTO_REQ_MULTIBULK && c->multibulklen && c->bulklen != -1\n        && c->bulklen >= PROTO_MBULK_BIG_ARG)\n    {\n        ssize_t remaining = (size_t)(c->bulklen+2)-sdslen(c->querybuf);\n\n        /* Note that the 'remaining' variable may be zero in some edge case,\n         * for example once we resume a blocked client after CLIENT PAUSE. */\n        if (remaining > 0 && remaining < readlen) readlen = remaining;\n    }\n\n    qblen = sdslen(c->querybuf);\n    if (c->querybuf_peak < qblen) c->querybuf_peak = qblen;\n    c->querybuf = sdsMakeRoomFor(c->querybuf, readlen);\n    nread = connRead(c->conn, c->querybuf+qblen, readlen);\n    if (nread == -1) {\n        if (connGetState(conn) == CONN_STATE_CONNECTED) {\n            return;\n        } else {\n            serverLog(LL_VERBOSE, \"Reading from client: %s\",connGetLastError(c->conn));\n            freeClientAsync(c);\n            return;\n        }\n    } else if (nread == 0) {\n        serverLog(LL_VERBOSE, \"Client closed connection\");\n        freeClientAsync(c);\n        return;\n    } else if (c->flags & CLIENT_MASTER) {\n        /* Append the query buffer to the pending (not applied) buffer\n         * of the master. We'll use this buffer later in order to have a\n         * copy of the string applied by the last command executed. */\n        c->pending_querybuf = sdscatlen(c->pending_querybuf,\n                                        c->querybuf+qblen,nread);\n    }\n\n    sdsIncrLen(c->querybuf,nread);\n    c->lastinteraction = server.unixtime;\n    if (c->flags & CLIENT_MASTER) c->read_reploff += nread;\n    server.stat_net_input_bytes += nread;\n    if (sdslen(c->querybuf) > server.client_max_querybuf_len) {\n        sds ci = catClientInfoString(sdsempty(),c), bytes = sdsempty();\n\n        bytes = sdscatrepr(bytes,c->querybuf,64);\n        serverLog(LL_WARNING,\"Closing client that reached max query buffer length: %s (qbuf initial bytes: %s)\", ci, bytes);\n        sdsfree(ci);\n        sdsfree(bytes);\n        freeClientAsync(c);\n        return;\n    }\n\n    /* There is more data in the client input buffer, continue parsing it\n     * in case to check if there is a full command to execute. */\n     processInputBuffer(c);\n}\n\nvoid getClientsMaxBuffers(unsigned long *longest_output_list,\n                          unsigned long *biggest_input_buffer) {\n    client *c;\n    listNode *ln;\n    listIter li;\n    unsigned long lol = 0, bib = 0;\n\n    listRewind(server.clients,&li);\n    while ((ln = listNext(&li)) != NULL) {\n        c = listNodeValue(ln);\n\n        if (listLength(c->reply) > lol) lol = listLength(c->reply);\n        if (sdslen(c->querybuf) > bib) bib = sdslen(c->querybuf);\n    }\n    *longest_output_list = lol;\n    *biggest_input_buffer = bib;\n}\n\n/* A Redis \"Peer ID\" is a colon separated ip:port pair.\n * For IPv4 it's in the form x.y.z.k:port, example: \"127.0.0.1:1234\".\n * For IPv6 addresses we use [] around the IP part, like in \"[::1]:1234\".\n * For Unix sockets we use path:0, like in \"/tmp/redis:0\".\n *\n * A Peer ID always fits inside a buffer of NET_PEER_ID_LEN bytes, including\n * the null term.\n *\n * On failure the function still populates 'peerid' with the \"?:0\" string\n * in case you want to relax error checking or need to display something\n * anyway (see anetPeerToString implementation for more info). */\nvoid genClientPeerId(client *client, char *peerid,\n                            size_t peerid_len) {\n    if (client->flags & CLIENT_UNIX_SOCKET) {\n        /* Unix socket client. */\n        snprintf(peerid,peerid_len,\"%s:0\",server.unixsocket);\n    } else {\n        /* TCP client. */\n        connFormatPeer(client->conn,peerid,peerid_len);\n    }\n}\n\n/* This function returns the client peer id, by creating and caching it\n * if client->peerid is NULL, otherwise returning the cached value.\n * The Peer ID never changes during the life of the client, however it\n * is expensive to compute. */\nchar *getClientPeerId(client *c) {\n    char peerid[NET_PEER_ID_LEN];\n\n    if (c->peerid == NULL) {\n        genClientPeerId(c,peerid,sizeof(peerid));\n        c->peerid = sdsnew(peerid);\n    }\n    return c->peerid;\n}\n\n/* Concatenate a string representing the state of a client in a human\n * readable format, into the sds string 's'. */\nsds catClientInfoString(sds s, client *client) {\n    char flags[16], events[3], conninfo[CONN_INFO_LEN], *p;\n\n    p = flags;\n    if (client->flags & CLIENT_SLAVE) {\n        if (client->flags & CLIENT_MONITOR)\n            *p++ = 'O';\n        else\n            *p++ = 'S';\n    }\n    if (client->flags & CLIENT_MASTER) *p++ = 'M';\n    if (client->flags & CLIENT_PUBSUB) *p++ = 'P';\n    if (client->flags & CLIENT_MULTI) *p++ = 'x';\n    if (client->flags & CLIENT_BLOCKED) *p++ = 'b';\n    if (client->flags & CLIENT_TRACKING) *p++ = 't';\n    if (client->flags & CLIENT_TRACKING_BROKEN_REDIR) *p++ = 'R';\n    if (client->flags & CLIENT_DIRTY_CAS) *p++ = 'd';\n    if (client->flags & CLIENT_CLOSE_AFTER_REPLY) *p++ = 'c';\n    if (client->flags & CLIENT_UNBLOCKED) *p++ = 'u';\n    if (client->flags & CLIENT_CLOSE_ASAP) *p++ = 'A';\n    if (client->flags & CLIENT_UNIX_SOCKET) *p++ = 'U';\n    if (client->flags & CLIENT_READONLY) *p++ = 'r';\n    if (p == flags) *p++ = 'N';\n    *p++ = '\\0';\n\n    p = events;\n    if (client->conn) {\n        if (connHasReadHandler(client->conn)) *p++ = 'r';\n        if (connHasWriteHandler(client->conn)) *p++ = 'w';\n    }\n    *p = '\\0';\n\n    /* Compute the total memory consumed by this client. */\n    size_t obufmem = getClientOutputBufferMemoryUsage(client);\n    size_t total_mem = obufmem;\n    total_mem += zmalloc_size(client); /* includes client->buf */\n    total_mem += sdsZmallocSize(client->querybuf);\n    /* For efficiency (less work keeping track of the argv memory), it doesn't include the used memory\n     * i.e. unused sds space and internal fragmentation, just the string length. but this is enough to\n     * spot problematic clients. */\n    total_mem += client->argv_len_sum;\n    if (client->argv)\n        total_mem += zmalloc_size(client->argv);\n\n    return sdscatfmt(s,\n        \"id=%U addr=%s %s name=%s age=%I idle=%I flags=%s db=%i sub=%i psub=%i multi=%i qbuf=%U qbuf-free=%U argv-mem=%U obl=%U oll=%U omem=%U tot-mem=%U events=%s cmd=%s user=%s\",\n        (unsigned long long) client->id,\n        getClientPeerId(client),\n        connGetInfo(client->conn, conninfo, sizeof(conninfo)),\n        client->name ? (char*)client->name->ptr : \"\",\n        (long long)(server.unixtime - client->ctime),\n        (long long)(server.unixtime - client->lastinteraction),\n        flags,\n        client->db->id,\n        (int) dictSize(client->pubsub_channels),\n        (int) listLength(client->pubsub_patterns),\n        (client->flags & CLIENT_MULTI) ? client->mstate.count : -1,\n        (unsigned long long) sdslen(client->querybuf),\n        (unsigned long long) sdsavail(client->querybuf),\n        (unsigned long long) client->argv_len_sum,\n        (unsigned long long) client->bufpos,\n        (unsigned long long) listLength(client->reply),\n        (unsigned long long) obufmem, /* should not include client->buf since we want to see 0 for static clients. */\n        (unsigned long long) total_mem,\n        events,\n        client->lastcmd ? client->lastcmd->name : \"NULL\",\n        client->user ? client->user->name : \"(superuser)\");\n}\n\nsds getAllClientsInfoString(int type) {\n    listNode *ln;\n    listIter li;\n    client *client;\n    sds o = sdsnewlen(SDS_NOINIT,200*listLength(server.clients));\n    sdsclear(o);\n    listRewind(server.clients,&li);\n    while ((ln = listNext(&li)) != NULL) {\n        client = listNodeValue(ln);\n        if (type != -1 && getClientType(client) != type) continue;\n        o = catClientInfoString(o,client);\n        o = sdscatlen(o,\"\\n\",1);\n    }\n    return o;\n}\n\n/* This function implements CLIENT SETNAME, including replying to the\n * user with an error if the charset is wrong (in that case C_ERR is\n * returned). If the function succeeeded C_OK is returned, and it's up\n * to the caller to send a reply if needed.\n *\n * Setting an empty string as name has the effect of unsetting the\n * currently set name: the client will remain unnamed.\n *\n * This function is also used to implement the HELLO SETNAME option. */\nint clientSetNameOrReply(client *c, robj *name) {\n    int len = sdslen(name->ptr);\n    char *p = name->ptr;\n\n    /* Setting the client name to an empty string actually removes\n     * the current name. */\n    if (len == 0) {\n        if (c->name) decrRefCount(c->name);\n        c->name = NULL;\n        return C_OK;\n    }\n\n    /* Otherwise check if the charset is ok. We need to do this otherwise\n     * CLIENT LIST format will break. You should always be able to\n     * split by space to get the different fields. */\n    for (int j = 0; j < len; j++) {\n        if (p[j] < '!' || p[j] > '~') { /* ASCII is assumed. */\n            addReplyError(c,\n                \"Client names cannot contain spaces, \"\n                \"newlines or special characters.\");\n            return C_ERR;\n        }\n    }\n    if (c->name) decrRefCount(c->name);\n    c->name = name;\n    incrRefCount(name);\n    return C_OK;\n}\n\nvoid clientCommand(client *c) {\n    listNode *ln;\n    listIter li;\n\n    if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,\"help\")) {\n        const char *help[] = {\n\"ID                     -- Return the ID of the current connection.\",\n\"GETNAME                -- Return the name of the current connection.\",\n\"KILL <ip:port>         -- Kill connection made from <ip:port>.\",\n\"KILL <option> <value> [option value ...] -- Kill connections. Options are:\",\n\"     ADDR <ip:port>                      -- Kill connection made from <ip:port>\",\n\"     TYPE (normal|master|replica|pubsub) -- Kill connections by type.\",\n\"     USER <username>   -- Kill connections authenticated with such user.\",\n\"     SKIPME (yes|no)   -- Skip killing current connection (default: yes).\",\n\"LIST [options ...]     -- Return information about client connections. Options:\",\n\"     TYPE (normal|master|replica|pubsub) -- Return clients of specified type.\",\n\"PAUSE <timeout>        -- Suspend all Redis clients for <timout> milliseconds.\",\n\"REPLY (on|off|skip)    -- Control the replies sent to the current connection.\",\n\"SETNAME <name>         -- Assign the name <name> to the current connection.\",\n\"UNBLOCK <clientid> [TIMEOUT|ERROR] -- Unblock the specified blocked client.\",\n\"TRACKING (on|off) [REDIRECT <id>] [BCAST] [PREFIX first] [PREFIX second] [OPTIN] [OPTOUT]... -- Enable client keys tracking for client side caching.\",\n\"CACHING  (yes|no)      -- Enable/Disable tracking of the keys for next command in OPTIN/OPTOUT mode.\",\n\"GETREDIR               -- Return the client ID we are redirecting to when tracking is enabled.\",\nNULL\n        };\n        addReplyHelp(c, help);\n    } else if (!strcasecmp(c->argv[1]->ptr,\"id\") && c->argc == 2) {\n        /* CLIENT ID */\n        addReplyLongLong(c,c->id);\n    } else if (!strcasecmp(c->argv[1]->ptr,\"list\")) {\n        /* CLIENT LIST */\n        int type = -1;\n        if (c->argc == 4 && !strcasecmp(c->argv[2]->ptr,\"type\")) {\n            type = getClientTypeByName(c->argv[3]->ptr);\n            if (type == -1) {\n                addReplyErrorFormat(c,\"Unknown client type '%s'\",\n                    (char*) c->argv[3]->ptr);\n                return;\n             }\n        } else if (c->argc != 2) {\n            addReply(c,shared.syntaxerr);\n            return;\n        }\n        sds o = getAllClientsInfoString(type);\n        addReplyVerbatim(c,o,sdslen(o),\"txt\");\n        sdsfree(o);\n    } else if (!strcasecmp(c->argv[1]->ptr,\"reply\") && c->argc == 3) {\n        /* CLIENT REPLY ON|OFF|SKIP */\n        if (!strcasecmp(c->argv[2]->ptr,\"on\")) {\n            c->flags &= ~(CLIENT_REPLY_SKIP|CLIENT_REPLY_OFF);\n            addReply(c,shared.ok);\n        } else if (!strcasecmp(c->argv[2]->ptr,\"off\")) {\n            c->flags |= CLIENT_REPLY_OFF;\n        } else if (!strcasecmp(c->argv[2]->ptr,\"skip\")) {\n            if (!(c->flags & CLIENT_REPLY_OFF))\n                c->flags |= CLIENT_REPLY_SKIP_NEXT;\n        } else {\n            addReply(c,shared.syntaxerr);\n            return;\n        }\n    } else if (!strcasecmp(c->argv[1]->ptr,\"kill\")) {\n        /* CLIENT KILL <ip:port>\n         * CLIENT KILL <option> [value] ... <option> [value] */\n        char *addr = NULL;\n        user *user = NULL;\n        int type = -1;\n        uint64_t id = 0;\n        int skipme = 1;\n        int killed = 0, close_this_client = 0;\n\n        if (c->argc == 3) {\n            /* Old style syntax: CLIENT KILL <addr> */\n            addr = c->argv[2]->ptr;\n            skipme = 0; /* With the old form, you can kill yourself. */\n        } else if (c->argc > 3) {\n            int i = 2; /* Next option index. */\n\n            /* New style syntax: parse options. */\n            while(i < c->argc) {\n                int moreargs = c->argc > i+1;\n\n                if (!strcasecmp(c->argv[i]->ptr,\"id\") && moreargs) {\n                    long long tmp;\n\n                    if (getLongLongFromObjectOrReply(c,c->argv[i+1],&tmp,NULL)\n                        != C_OK) return;\n                    id = tmp;\n                } else if (!strcasecmp(c->argv[i]->ptr,\"type\") && moreargs) {\n                    type = getClientTypeByName(c->argv[i+1]->ptr);\n                    if (type == -1) {\n                        addReplyErrorFormat(c,\"Unknown client type '%s'\",\n                            (char*) c->argv[i+1]->ptr);\n                        return;\n                    }\n                } else if (!strcasecmp(c->argv[i]->ptr,\"addr\") && moreargs) {\n                    addr = c->argv[i+1]->ptr;\n                } else if (!strcasecmp(c->argv[i]->ptr,\"user\") && moreargs) {\n                    user = ACLGetUserByName(c->argv[i+1]->ptr,\n                                            sdslen(c->argv[i+1]->ptr));\n                    if (user == NULL) {\n                        addReplyErrorFormat(c,\"No such user '%s'\",\n                            (char*) c->argv[i+1]->ptr);\n                        return;\n                    }\n                } else if (!strcasecmp(c->argv[i]->ptr,\"skipme\") && moreargs) {\n                    if (!strcasecmp(c->argv[i+1]->ptr,\"yes\")) {\n                        skipme = 1;\n                    } else if (!strcasecmp(c->argv[i+1]->ptr,\"no\")) {\n                        skipme = 0;\n                    } else {\n                        addReply(c,shared.syntaxerr);\n                        return;\n                    }\n                } else {\n                    addReply(c,shared.syntaxerr);\n                    return;\n                }\n                i += 2;\n            }\n        } else {\n            addReply(c,shared.syntaxerr);\n            return;\n        }\n\n        /* Iterate clients killing all the matching clients. */\n        listRewind(server.clients,&li);\n        while ((ln = listNext(&li)) != NULL) {\n            client *client = listNodeValue(ln);\n            if (addr && strcmp(getClientPeerId(client),addr) != 0) continue;\n            if (type != -1 && getClientType(client) != type) continue;\n            if (id != 0 && client->id != id) continue;\n            if (user && client->user != user) continue;\n            if (c == client && skipme) continue;\n\n            /* Kill it. */\n            if (c == client) {\n                close_this_client = 1;\n            } else {\n                freeClient(client);\n            }\n            killed++;\n        }\n\n        /* Reply according to old/new format. */\n        if (c->argc == 3) {\n            if (killed == 0)\n                addReplyError(c,\"No such client\");\n            else\n                addReply(c,shared.ok);\n        } else {\n            addReplyLongLong(c,killed);\n        }\n\n        /* If this client has to be closed, flag it as CLOSE_AFTER_REPLY\n         * only after we queued the reply to its output buffers. */\n        if (close_this_client) c->flags |= CLIENT_CLOSE_AFTER_REPLY;\n    } else if (!strcasecmp(c->argv[1]->ptr,\"unblock\") && (c->argc == 3 ||\n                                                          c->argc == 4))\n    {\n        /* CLIENT UNBLOCK <id> [timeout|error] */\n        long long id;\n        int unblock_error = 0;\n\n        if (c->argc == 4) {\n            if (!strcasecmp(c->argv[3]->ptr,\"timeout\")) {\n                unblock_error = 0;\n            } else if (!strcasecmp(c->argv[3]->ptr,\"error\")) {\n                unblock_error = 1;\n            } else {\n                addReplyError(c,\n                    \"CLIENT UNBLOCK reason should be TIMEOUT or ERROR\");\n                return;\n            }\n        }\n        if (getLongLongFromObjectOrReply(c,c->argv[2],&id,NULL)\n            != C_OK) return;\n        struct client *target = lookupClientByID(id);\n        if (target && target->flags & CLIENT_BLOCKED) {\n            if (unblock_error)\n                addReplyError(target,\n                    \"-UNBLOCKED client unblocked via CLIENT UNBLOCK\");\n            else\n                replyToBlockedClientTimedOut(target);\n            unblockClient(target);\n            addReply(c,shared.cone);\n        } else {\n            addReply(c,shared.czero);\n        }\n    } else if (!strcasecmp(c->argv[1]->ptr,\"setname\") && c->argc == 3) {\n        /* CLIENT SETNAME */\n        if (clientSetNameOrReply(c,c->argv[2]) == C_OK)\n            addReply(c,shared.ok);\n    } else if (!strcasecmp(c->argv[1]->ptr,\"getname\") && c->argc == 2) {\n        /* CLIENT GETNAME */\n        if (c->name)\n            addReplyBulk(c,c->name);\n        else\n            addReplyNull(c);\n    } else if (!strcasecmp(c->argv[1]->ptr,\"pause\") && c->argc == 3) {\n        /* CLIENT PAUSE */\n        long long duration;\n\n        if (getTimeoutFromObjectOrReply(c,c->argv[2],&duration,\n                UNIT_MILLISECONDS) != C_OK) return;\n        pauseClients(duration);\n        addReply(c,shared.ok);\n    } else if (!strcasecmp(c->argv[1]->ptr,\"tracking\") && c->argc >= 3) {\n        /* CLIENT TRACKING (on|off) [REDIRECT <id>] [BCAST] [PREFIX first]\n         *                          [PREFIX second] [OPTIN] [OPTOUT] ... */\n        long long redir = 0;\n        uint64_t options = 0;\n        robj **prefix = NULL;\n        size_t numprefix = 0;\n\n        /* Parse the options. */\n        for (int j = 3; j < c->argc; j++) {\n            int moreargs = (c->argc-1) - j;\n\n            if (!strcasecmp(c->argv[j]->ptr,\"redirect\") && moreargs) {\n                j++;\n                if (redir != 0) {\n                    addReplyError(c,\"A client can only redirect to a single \"\n                                    \"other client\");\n                    zfree(prefix);\n                    return;\n                }\n\n                if (getLongLongFromObjectOrReply(c,c->argv[j],&redir,NULL) !=\n                    C_OK)\n                {\n                    zfree(prefix);\n                    return;\n                }\n                /* We will require the client with the specified ID to exist\n                 * right now, even if it is possible that it gets disconnected\n                 * later. Still a valid sanity check. */\n                if (lookupClientByID(redir) == NULL) {\n                    addReplyError(c,\"The client ID you want redirect to \"\n                                    \"does not exist\");\n                    zfree(prefix);\n                    return;\n                }\n            } else if (!strcasecmp(c->argv[j]->ptr,\"bcast\")) {\n                options |= CLIENT_TRACKING_BCAST;\n            } else if (!strcasecmp(c->argv[j]->ptr,\"optin\")) {\n                options |= CLIENT_TRACKING_OPTIN;\n            } else if (!strcasecmp(c->argv[j]->ptr,\"optout\")) {\n                options |= CLIENT_TRACKING_OPTOUT;\n            } else if (!strcasecmp(c->argv[j]->ptr,\"noloop\")) {\n                options |= CLIENT_TRACKING_NOLOOP;\n            } else if (!strcasecmp(c->argv[j]->ptr,\"prefix\") && moreargs) {\n                j++;\n                prefix = zrealloc(prefix,sizeof(robj*)*(numprefix+1));\n                prefix[numprefix++] = c->argv[j];\n            } else {\n                zfree(prefix);\n                addReply(c,shared.syntaxerr);\n                return;\n            }\n        }\n\n        /* Options are ok: enable or disable the tracking for this client. */\n        if (!strcasecmp(c->argv[2]->ptr,\"on\")) {\n            /* Before enabling tracking, make sure options are compatible\n             * among each other and with the current state of the client. */\n            if (!(options & CLIENT_TRACKING_BCAST) && numprefix) {\n                addReplyError(c,\n                    \"PREFIX option requires BCAST mode to be enabled\");\n                zfree(prefix);\n                return;\n            }\n\n            if (c->flags & CLIENT_TRACKING) {\n                int oldbcast = !!(c->flags & CLIENT_TRACKING_BCAST);\n                int newbcast = !!(options & CLIENT_TRACKING_BCAST);\n                if (oldbcast != newbcast) {\n                    addReplyError(c,\n                    \"You can't switch BCAST mode on/off before disabling \"\n                    \"tracking for this client, and then re-enabling it with \"\n                    \"a different mode.\");\n                    zfree(prefix);\n                    return;\n                }\n            }\n\n            if (options & CLIENT_TRACKING_BCAST &&\n                options & (CLIENT_TRACKING_OPTIN|CLIENT_TRACKING_OPTOUT))\n            {\n                addReplyError(c,\n                \"OPTIN and OPTOUT are not compatible with BCAST\");\n                zfree(prefix);\n                return;\n            }\n\n            if (options & CLIENT_TRACKING_OPTIN && options & CLIENT_TRACKING_OPTOUT)\n            {\n                addReplyError(c,\n                \"You can't specify both OPTIN mode and OPTOUT mode\");\n                zfree(prefix);\n                return;\n            }\n\n            if ((options & CLIENT_TRACKING_OPTIN && c->flags & CLIENT_TRACKING_OPTOUT) ||\n                (options & CLIENT_TRACKING_OPTOUT && c->flags & CLIENT_TRACKING_OPTIN))\n            {\n                addReplyError(c,\n                \"You can't switch OPTIN/OPTOUT mode before disabling \"\n                \"tracking for this client, and then re-enabling it with \"\n                \"a different mode.\");\n                zfree(prefix);\n                return;\n            }\n\n            enableTracking(c,redir,options,prefix,numprefix);\n        } else if (!strcasecmp(c->argv[2]->ptr,\"off\")) {\n            disableTracking(c);\n        } else {\n            zfree(prefix);\n            addReply(c,shared.syntaxerr);\n            return;\n        }\n        zfree(prefix);\n        addReply(c,shared.ok);\n    } else if (!strcasecmp(c->argv[1]->ptr,\"caching\") && c->argc >= 3) {\n        if (!(c->flags & CLIENT_TRACKING)) {\n            addReplyError(c,\"CLIENT CACHING can be called only when the \"\n                            \"client is in tracking mode with OPTIN or \"\n                            \"OPTOUT mode enabled\");\n            return;\n        }\n\n        char *opt = c->argv[2]->ptr;\n        if (!strcasecmp(opt,\"yes\")) {\n            if (c->flags & CLIENT_TRACKING_OPTIN) {\n                c->flags |= CLIENT_TRACKING_CACHING;\n            } else {\n                addReplyError(c,\"CLIENT CACHING YES is only valid when tracking is enabled in OPTIN mode.\");\n                return;\n            }\n        } else if (!strcasecmp(opt,\"no\")) {\n            if (c->flags & CLIENT_TRACKING_OPTOUT) {\n                c->flags |= CLIENT_TRACKING_CACHING;\n            } else {\n                addReplyError(c,\"CLIENT CACHING NO is only valid when tracking is enabled in OPTOUT mode.\");\n                return;\n            }\n        } else {\n            addReply(c,shared.syntaxerr);\n            return;\n        }\n\n        /* Common reply for when we succeeded. */\n        addReply(c,shared.ok);\n    } else if (!strcasecmp(c->argv[1]->ptr,\"getredir\") && c->argc == 2) {\n        /* CLIENT GETREDIR */\n        if (c->flags & CLIENT_TRACKING) {\n            addReplyLongLong(c,c->client_tracking_redirection);\n        } else {\n            addReplyLongLong(c,-1);\n        }\n    } else {\n        addReplyErrorFormat(c, \"Unknown subcommand or wrong number of arguments for '%s'. Try CLIENT HELP\", (char*)c->argv[1]->ptr);\n    }\n}\n\n/* HELLO <protocol-version> [AUTH <user> <password>] [SETNAME <name>] */\nvoid helloCommand(client *c) {\n    long long ver;\n\n    if (getLongLongFromObject(c->argv[1],&ver) != C_OK ||\n        ver < 2 || ver > 3)\n    {\n        addReplyError(c,\"-NOPROTO unsupported protocol version\");\n        return;\n    }\n\n    for (int j = 2; j < c->argc; j++) {\n        int moreargs = (c->argc-1) - j;\n        const char *opt = c->argv[j]->ptr;\n        if (!strcasecmp(opt,\"AUTH\") && moreargs >= 2) {\n            if (ACLAuthenticateUser(c, c->argv[j+1], c->argv[j+2]) == C_ERR) {\n                addReplyError(c,\"-WRONGPASS invalid username-password pair\");\n                return;\n            }\n            j += 2;\n        } else if (!strcasecmp(opt,\"SETNAME\") && moreargs) {\n            if (clientSetNameOrReply(c, c->argv[j+1]) == C_ERR) return;\n            j++;\n        } else {\n            addReplyErrorFormat(c,\"Syntax error in HELLO option '%s'\",opt);\n            return;\n        }\n    }\n\n    /* At this point we need to be authenticated to continue. */\n    if (!c->authenticated) {\n        addReplyError(c,\"-NOAUTH HELLO must be called with the client already \"\n                        \"authenticated, otherwise the HELLO AUTH <user> <pass> \"\n                        \"option can be used to authenticate the client and \"\n                        \"select the RESP protocol version at the same time\");\n        return;\n    }\n\n    /* Let's switch to the specified RESP mode. */\n    c->resp = ver;\n    addReplyMapLen(c,6 + !server.sentinel_mode);\n\n    addReplyBulkCString(c,\"server\");\n    addReplyBulkCString(c,\"redis\");\n\n    addReplyBulkCString(c,\"version\");\n    addReplyBulkCString(c,REDIS_VERSION);\n\n    addReplyBulkCString(c,\"proto\");\n    addReplyLongLong(c,ver);\n\n    addReplyBulkCString(c,\"id\");\n    addReplyLongLong(c,c->id);\n\n    addReplyBulkCString(c,\"mode\");\n    if (server.sentinel_mode) addReplyBulkCString(c,\"sentinel\");\n    else if (server.cluster_enabled) addReplyBulkCString(c,\"cluster\");\n    else addReplyBulkCString(c,\"standalone\");\n\n    if (!server.sentinel_mode) {\n        addReplyBulkCString(c,\"role\");\n        addReplyBulkCString(c,server.masterhost ? \"replica\" : \"master\");\n    }\n\n    addReplyBulkCString(c,\"modules\");\n    addReplyLoadedModules(c);\n}\n\n/* This callback is bound to POST and \"Host:\" command names. Those are not\n * really commands, but are used in security attacks in order to talk to\n * Redis instances via HTTP, with a technique called \"cross protocol scripting\"\n * which exploits the fact that services like Redis will discard invalid\n * HTTP headers and will process what follows.\n *\n * As a protection against this attack, Redis will terminate the connection\n * when a POST or \"Host:\" header is seen, and will log the event from\n * time to time (to avoid creating a DOS as a result of too many logs). */\nvoid securityWarningCommand(client *c) {\n    static time_t logged_time;\n    time_t now = time(NULL);\n\n    if (labs(now-logged_time) > 60) {\n        serverLog(LL_WARNING,\"Possible SECURITY ATTACK detected. It looks like somebody is sending POST or Host: commands to Redis. This is likely due to an attacker attempting to use Cross Protocol Scripting to compromise your Redis instance. Connection aborted.\");\n        logged_time = now;\n    }\n    freeClientAsync(c);\n}\n\n/* Rewrite the command vector of the client. All the new objects ref count\n * is incremented. The old command vector is freed, and the old objects\n * ref count is decremented. */\nvoid rewriteClientCommandVector(client *c, int argc, ...) {\n    va_list ap;\n    int j;\n    robj **argv; /* The new argument vector */\n\n    argv = zmalloc(sizeof(robj*)*argc);\n    va_start(ap,argc);\n    for (j = 0; j < argc; j++) {\n        robj *a;\n\n        a = va_arg(ap, robj*);\n        argv[j] = a;\n        incrRefCount(a);\n    }\n    /* We free the objects in the original vector at the end, so we are\n     * sure that if the same objects are reused in the new vector the\n     * refcount gets incremented before it gets decremented. */\n    for (j = 0; j < c->argc; j++) decrRefCount(c->argv[j]);\n    zfree(c->argv);\n    /* Replace argv and argc with our new versions. */\n    c->argv = argv;\n    c->argc = argc;\n    c->argv_len_sum = 0;\n    for (j = 0; j < c->argc; j++)\n        if (c->argv[j])\n            c->argv_len_sum += getStringObjectLen(c->argv[j]);\n    c->cmd = lookupCommandOrOriginal(c->argv[0]->ptr);\n    serverAssertWithInfo(c,NULL,c->cmd != NULL);\n    va_end(ap);\n}\n\n/* Completely replace the client command vector with the provided one. */\nvoid replaceClientCommandVector(client *c, int argc, robj **argv) {\n    int j;\n    freeClientArgv(c);\n    zfree(c->argv);\n    c->argv = argv;\n    c->argc = argc;\n    c->argv_len_sum = 0;\n    for (j = 0; j < c->argc; j++)\n        if (c->argv[j])\n            c->argv_len_sum += getStringObjectLen(c->argv[j]);\n    c->cmd = lookupCommandOrOriginal(c->argv[0]->ptr);\n    serverAssertWithInfo(c,NULL,c->cmd != NULL);\n}\n\n/* Rewrite a single item in the command vector.\n * The new val ref count is incremented, and the old decremented.\n *\n * It is possible to specify an argument over the current size of the\n * argument vector: in this case the array of objects gets reallocated\n * and c->argc set to the max value. However it's up to the caller to\n *\n * 1. Make sure there are no \"holes\" and all the arguments are set.\n * 2. If the original argument vector was longer than the one we\n *    want to end with, it's up to the caller to set c->argc and\n *    free the no longer used objects on c->argv. */\nvoid rewriteClientCommandArgument(client *c, int i, robj *newval) {\n    robj *oldval;\n\n    if (i >= c->argc) {\n        c->argv = zrealloc(c->argv,sizeof(robj*)*(i+1));\n        c->argc = i+1;\n        c->argv[i] = NULL;\n    }\n    oldval = c->argv[i];\n    if (oldval) c->argv_len_sum -= getStringObjectLen(oldval);\n    if (newval) c->argv_len_sum += getStringObjectLen(newval);\n    c->argv[i] = newval;\n    incrRefCount(newval);\n    if (oldval) decrRefCount(oldval);\n\n    /* If this is the command name make sure to fix c->cmd. */\n    if (i == 0) {\n        c->cmd = lookupCommandOrOriginal(c->argv[0]->ptr);\n        serverAssertWithInfo(c,NULL,c->cmd != NULL);\n    }\n}\n\n/* This function returns the number of bytes that Redis is\n * using to store the reply still not read by the client.\n *\n * Note: this function is very fast so can be called as many time as\n * the caller wishes. The main usage of this function currently is\n * enforcing the client output length limits. */\nunsigned long getClientOutputBufferMemoryUsage(client *c) {\n    unsigned long list_item_size = sizeof(listNode) + sizeof(clientReplyBlock);\n    return c->reply_bytes + (list_item_size*listLength(c->reply));\n}\n\n/* Get the class of a client, used in order to enforce limits to different\n * classes of clients.\n *\n * The function will return one of the following:\n * CLIENT_TYPE_NORMAL -> Normal client\n * CLIENT_TYPE_SLAVE  -> Slave\n * CLIENT_TYPE_PUBSUB -> Client subscribed to Pub/Sub channels\n * CLIENT_TYPE_MASTER -> The client representing our replication master.\n */\nint getClientType(client *c) {\n    if (c->flags & CLIENT_MASTER) return CLIENT_TYPE_MASTER;\n    /* Even though MONITOR clients are marked as replicas, we\n     * want the expose them as normal clients. */\n    if ((c->flags & CLIENT_SLAVE) && !(c->flags & CLIENT_MONITOR))\n        return CLIENT_TYPE_SLAVE;\n    if (c->flags & CLIENT_PUBSUB) return CLIENT_TYPE_PUBSUB;\n    return CLIENT_TYPE_NORMAL;\n}\n\nint getClientTypeByName(char *name) {\n    if (!strcasecmp(name,\"normal\")) return CLIENT_TYPE_NORMAL;\n    else if (!strcasecmp(name,\"slave\")) return CLIENT_TYPE_SLAVE;\n    else if (!strcasecmp(name,\"replica\")) return CLIENT_TYPE_SLAVE;\n    else if (!strcasecmp(name,\"pubsub\")) return CLIENT_TYPE_PUBSUB;\n    else if (!strcasecmp(name,\"master\")) return CLIENT_TYPE_MASTER;\n    else return -1;\n}\n\nchar *getClientTypeName(int class) {\n    switch(class) {\n    case CLIENT_TYPE_NORMAL: return \"normal\";\n    case CLIENT_TYPE_SLAVE:  return \"slave\";\n    case CLIENT_TYPE_PUBSUB: return \"pubsub\";\n    case CLIENT_TYPE_MASTER: return \"master\";\n    default:                       return NULL;\n    }\n}\n\n/* The function checks if the client reached output buffer soft or hard\n * limit, and also update the state needed to check the soft limit as\n * a side effect.\n *\n * Return value: non-zero if the client reached the soft or the hard limit.\n *               Otherwise zero is returned. */\nint checkClientOutputBufferLimits(client *c) {\n    int soft = 0, hard = 0, class;\n    unsigned long used_mem = getClientOutputBufferMemoryUsage(c);\n\n    class = getClientType(c);\n    /* For the purpose of output buffer limiting, masters are handled\n     * like normal clients. */\n    if (class == CLIENT_TYPE_MASTER) class = CLIENT_TYPE_NORMAL;\n\n    if (server.client_obuf_limits[class].hard_limit_bytes &&\n        used_mem >= server.client_obuf_limits[class].hard_limit_bytes)\n        hard = 1;\n    if (server.client_obuf_limits[class].soft_limit_bytes &&\n        used_mem >= server.client_obuf_limits[class].soft_limit_bytes)\n        soft = 1;\n\n    /* We need to check if the soft limit is reached continuously for the\n     * specified amount of seconds. */\n    if (soft) {\n        if (c->obuf_soft_limit_reached_time == 0) {\n            c->obuf_soft_limit_reached_time = server.unixtime;\n            soft = 0; /* First time we see the soft limit reached */\n        } else {\n            time_t elapsed = server.unixtime - c->obuf_soft_limit_reached_time;\n\n            if (elapsed <=\n                server.client_obuf_limits[class].soft_limit_seconds) {\n                soft = 0; /* The client still did not reached the max number of\n                             seconds for the soft limit to be considered\n                             reached. */\n            }\n        }\n    } else {\n        c->obuf_soft_limit_reached_time = 0;\n    }\n    return soft || hard;\n}\n\n/* Asynchronously close a client if soft or hard limit is reached on the\n * output buffer size. The caller can check if the client will be closed\n * checking if the client CLIENT_CLOSE_ASAP flag is set.\n *\n * Note: we need to close the client asynchronously because this function is\n * called from contexts where the client can't be freed safely, i.e. from the\n * lower level functions pushing data inside the client output buffers. */\nvoid asyncCloseClientOnOutputBufferLimitReached(client *c) {\n    if (!c->conn) return; /* It is unsafe to free fake clients. */\n    serverAssert(c->reply_bytes < SIZE_MAX-(1024*64));\n    if (c->reply_bytes == 0 || c->flags & CLIENT_CLOSE_ASAP) return;\n    if (checkClientOutputBufferLimits(c)) {\n        sds client = catClientInfoString(sdsempty(),c);\n\n        freeClientAsync(c);\n        serverLog(LL_WARNING,\"Client %s scheduled to be closed ASAP for overcoming of output buffer limits.\", client);\n        sdsfree(client);\n    }\n}\n\n/* Helper function used by freeMemoryIfNeeded() in order to flush slaves\n * output buffers without returning control to the event loop.\n * This is also called by SHUTDOWN for a best-effort attempt to send\n * slaves the latest writes. */\nvoid flushSlavesOutputBuffers(void) {\n    listIter li;\n    listNode *ln;\n\n    listRewind(server.slaves,&li);\n    while((ln = listNext(&li))) {\n        client *slave = listNodeValue(ln);\n        int can_receive_writes = connHasWriteHandler(slave->conn) ||\n                                 (slave->flags & CLIENT_PENDING_WRITE);\n\n        /* We don't want to send the pending data to the replica in a few\n         * cases:\n         *\n         * 1. For some reason there is neither the write handler installed\n         *    nor the client is flagged as to have pending writes: for some\n         *    reason this replica may not be set to receive data. This is\n         *    just for the sake of defensive programming.\n         *\n         * 2. The put_online_on_ack flag is true. To know why we don't want\n         *    to send data to the replica in this case, please grep for the\n         *    flag for this flag.\n         *\n         * 3. Obviously if the slave is not ONLINE.\n         */\n        if (slave->replstate == SLAVE_STATE_ONLINE &&\n            can_receive_writes &&\n            !slave->repl_put_online_on_ack &&\n            clientHasPendingReplies(slave))\n        {\n            writeToClient(slave,0);\n        }\n    }\n}\n\n/* Pause clients up to the specified unixtime (in ms). While clients\n * are paused no command is processed from clients, so the data set can't\n * change during that time.\n *\n * However while this function pauses normal and Pub/Sub clients, slaves are\n * still served, so this function can be used on server upgrades where it is\n * required that slaves process the latest bytes from the replication stream\n * before being turned to masters.\n *\n * This function is also internally used by Redis Cluster for the manual\n * failover procedure implemented by CLUSTER FAILOVER.\n *\n * The function always succeed, even if there is already a pause in progress.\n * In such a case, the pause is extended if the duration is more than the\n * time left for the previous duration. However if the duration is smaller\n * than the time left for the previous pause, no change is made to the\n * left duration. */\nvoid pauseClients(mstime_t end) {\n    if (!server.clients_paused || end > server.clients_pause_end_time)\n        server.clients_pause_end_time = end;\n    server.clients_paused = 1;\n}\n\n/* Return non-zero if clients are currently paused. As a side effect the\n * function checks if the pause time was reached and clear it. */\nint clientsArePaused(void) {\n    if (server.clients_paused &&\n        server.clients_pause_end_time < server.mstime)\n    {\n        listNode *ln;\n        listIter li;\n        client *c;\n\n        server.clients_paused = 0;\n\n        /* Put all the clients in the unblocked clients queue in order to\n         * force the re-processing of the input buffer if any. */\n        listRewind(server.clients,&li);\n        while ((ln = listNext(&li)) != NULL) {\n            c = listNodeValue(ln);\n\n            /* Don't touch slaves and blocked clients.\n             * The latter pending requests will be processed when unblocked. */\n            if (c->flags & (CLIENT_SLAVE|CLIENT_BLOCKED)) continue;\n            queueClientForReprocessing(c);\n        }\n    }\n    return server.clients_paused;\n}\n\n/* This function is called by Redis in order to process a few events from\n * time to time while blocked into some not interruptible operation.\n * This allows to reply to clients with the -LOADING error while loading the\n * data set at startup or after a full resynchronization with the master\n * and so forth.\n *\n * It calls the event loop in order to process a few events. Specifically we\n * try to call the event loop 4 times as long as we receive acknowledge that\n * some event was processed, in order to go forward with the accept, read,\n * write, close sequence needed to serve a client.\n *\n * The function returns the total number of events processed. */\nvoid processEventsWhileBlocked(void) {\n    int iterations = 4; /* See the function top-comment. */\n\n    /* Note: when we are processing events while blocked (for instance during\n     * busy Lua scripts), we set a global flag. When such flag is set, we\n     * avoid handling the read part of clients using threaded I/O.\n     * See https://github.com/antirez/redis/issues/6988 for more info. */\n    ProcessingEventsWhileBlocked = 1;\n    while (iterations--) {\n        long long startval = server.events_processed_while_blocked;\n        long long ae_events = aeProcessEvents(server.el,\n            AE_FILE_EVENTS|AE_DONT_WAIT|\n            AE_CALL_BEFORE_SLEEP|AE_CALL_AFTER_SLEEP);\n        /* Note that server.events_processed_while_blocked will also get\n         * incremeted by callbacks called by the event loop handlers. */\n        server.events_processed_while_blocked += ae_events;\n        long long events = server.events_processed_while_blocked - startval;\n        if (!events) break;\n    }\n    ProcessingEventsWhileBlocked = 0;\n}\n\n/* ==========================================================================\n * Threaded I/O\n * ========================================================================== */\n\nint tio_debug = 0;\n\n#define IO_THREADS_MAX_NUM 128\n#define IO_THREADS_OP_READ 0\n#define IO_THREADS_OP_WRITE 1\n\npthread_t io_threads[IO_THREADS_MAX_NUM];\npthread_mutex_t io_threads_mutex[IO_THREADS_MAX_NUM];\n_Atomic unsigned long io_threads_pending[IO_THREADS_MAX_NUM];\nint io_threads_op;      /* IO_THREADS_OP_WRITE or IO_THREADS_OP_READ. */\n\n/* This is the list of clients each thread will serve when threaded I/O is\n * used. We spawn io_threads_num-1 threads, since one is the main thread\n * itself. */\nlist *io_threads_list[IO_THREADS_MAX_NUM];\n\nvoid *IOThreadMain(void *myid) {\n    /* The ID is the thread number (from 0 to server.iothreads_num-1), and is\n     * used by the thread to just manipulate a single sub-array of clients. */\n    long id = (unsigned long)myid;\n    char thdname[16];\n\n    snprintf(thdname, sizeof(thdname), \"io_thd_%ld\", id);\n    redis_set_thread_title(thdname);\n    redisSetCpuAffinity(server.server_cpulist);\n    makeThreadKillable();\n\n    while(1) {\n        /* Wait for start */\n        for (int j = 0; j < 1000000; j++) {\n            if (io_threads_pending[id] != 0) break;\n        }\n\n        /* Give the main thread a chance to stop this thread. */\n        if (io_threads_pending[id] == 0) {\n            pthread_mutex_lock(&io_threads_mutex[id]);\n            pthread_mutex_unlock(&io_threads_mutex[id]);\n            continue;\n        }\n\n        serverAssert(io_threads_pending[id] != 0);\n\n        if (tio_debug) printf(\"[%ld] %d to handle\\n\", id, (int)listLength(io_threads_list[id]));\n\n        /* Process: note that the main thread will never touch our list\n         * before we drop the pending count to 0. */\n        listIter li;\n        listNode *ln;\n        listRewind(io_threads_list[id],&li);\n        while((ln = listNext(&li))) {\n            client *c = listNodeValue(ln);\n            if (io_threads_op == IO_THREADS_OP_WRITE) {\n                writeToClient(c,0);\n            } else if (io_threads_op == IO_THREADS_OP_READ) {\n                readQueryFromClient(c->conn);\n            } else {\n                serverPanic(\"io_threads_op value is unknown\");\n            }\n        }\n        listEmpty(io_threads_list[id]);\n        io_threads_pending[id] = 0;\n\n        if (tio_debug) printf(\"[%ld] Done\\n\", id);\n    }\n}\n\n/* Initialize the data structures needed for threaded I/O. */\nvoid initThreadedIO(void) {\n    server.io_threads_active = 0; /* We start with threads not active. */\n\n    /* Don't spawn any thread if the user selected a single thread:\n     * we'll handle I/O directly from the main thread. */\n    if (server.io_threads_num == 1) return;\n\n    if (server.io_threads_num > IO_THREADS_MAX_NUM) {\n        serverLog(LL_WARNING,\"Fatal: too many I/O threads configured. \"\n                             \"The maximum number is %d.\", IO_THREADS_MAX_NUM);\n        exit(1);\n    }\n\n    /* Spawn and initialize the I/O threads. */\n    for (int i = 0; i < server.io_threads_num; i++) {\n        /* Things we do for all the threads including the main thread. */\n        io_threads_list[i] = listCreate();\n        if (i == 0) continue; /* Thread 0 is the main thread. */\n\n        /* Things we do only for the additional threads. */\n        pthread_t tid;\n        pthread_mutex_init(&io_threads_mutex[i],NULL);\n        io_threads_pending[i] = 0;\n        pthread_mutex_lock(&io_threads_mutex[i]); /* Thread will be stopped. */\n        if (pthread_create(&tid,NULL,IOThreadMain,(void*)(long)i) != 0) {\n            serverLog(LL_WARNING,\"Fatal: Can't initialize IO thread.\");\n            exit(1);\n        }\n        io_threads[i] = tid;\n    }\n}\n\nvoid killIOThreads(void) {\n    int err, j;\n    for (j = 0; j < server.io_threads_num; j++) {\n        if (io_threads[j] == pthread_self()) continue;\n        if (io_threads[j] && pthread_cancel(io_threads[j]) == 0) {\n            if ((err = pthread_join(io_threads[j],NULL)) != 0) {\n                serverLog(LL_WARNING,\n                    \"IO thread(tid:%lu) can not be joined: %s\",\n                        (unsigned long)io_threads[j], strerror(err));\n            } else {\n                serverLog(LL_WARNING,\n                    \"IO thread(tid:%lu) terminated\",(unsigned long)io_threads[j]);\n            }\n        }\n    }\n}\n\nvoid startThreadedIO(void) {\n    if (tio_debug) { printf(\"S\"); fflush(stdout); }\n    if (tio_debug) printf(\"--- STARTING THREADED IO ---\\n\");\n    serverAssert(server.io_threads_active == 0);\n    for (int j = 1; j < server.io_threads_num; j++)\n        pthread_mutex_unlock(&io_threads_mutex[j]);\n    server.io_threads_active = 1;\n}\n\nvoid stopThreadedIO(void) {\n    /* We may have still clients with pending reads when this function\n     * is called: handle them before stopping the threads. */\n    handleClientsWithPendingReadsUsingThreads();\n    if (tio_debug) { printf(\"E\"); fflush(stdout); }\n    if (tio_debug) printf(\"--- STOPPING THREADED IO [R%d] [W%d] ---\\n\",\n        (int) listLength(server.clients_pending_read),\n        (int) listLength(server.clients_pending_write));\n    serverAssert(server.io_threads_active == 1);\n    for (int j = 1; j < server.io_threads_num; j++)\n        pthread_mutex_lock(&io_threads_mutex[j]);\n    server.io_threads_active = 0;\n}\n\n/* This function checks if there are not enough pending clients to justify\n * taking the I/O threads active: in that case I/O threads are stopped if\n * currently active. We track the pending writes as a measure of clients\n * we need to handle in parallel, however the I/O threading is disabled\n * globally for reads as well if we have too little pending clients.\n *\n * The function returns 0 if the I/O threading should be used because there\n * are enough active threads, otherwise 1 is returned and the I/O threads\n * could be possibly stopped (if already active) as a side effect. */\nint stopThreadedIOIfNeeded(void) {\n    int pending = listLength(server.clients_pending_write);\n\n    /* Return ASAP if IO threads are disabled (single threaded mode). */\n    if (server.io_threads_num == 1) return 1;\n\n    if (pending < (server.io_threads_num*2)) {\n        if (server.io_threads_active) stopThreadedIO();\n        return 1;\n    } else {\n        return 0;\n    }\n}\n\nint handleClientsWithPendingWritesUsingThreads(void) {\n    int processed = listLength(server.clients_pending_write);\n    if (processed == 0) return 0; /* Return ASAP if there are no clients. */\n\n    /* If I/O threads are disabled or we have few clients to serve, don't\n     * use I/O threads, but thejboring synchronous code. */\n    if (server.io_threads_num == 1 || stopThreadedIOIfNeeded()) {\n        return handleClientsWithPendingWrites();\n    }\n\n    /* Start threads if needed. */\n    if (!server.io_threads_active) startThreadedIO();\n\n    if (tio_debug) printf(\"%d TOTAL WRITE pending clients\\n\", processed);\n\n    /* Distribute the clients across N different lists. */\n    listIter li;\n    listNode *ln;\n    listRewind(server.clients_pending_write,&li);\n    int item_id = 0;\n    while((ln = listNext(&li))) {\n        client *c = listNodeValue(ln);\n        c->flags &= ~CLIENT_PENDING_WRITE;\n\n        /* Remove clients from the list of pending writes since\n         * they are going to be closed ASAP. */\n        if (c->flags & CLIENT_CLOSE_ASAP) {\n            listDelNode(server.clients_pending_write, ln);\n            continue;\n        }\n\n        int target_id = item_id % server.io_threads_num;\n        listAddNodeTail(io_threads_list[target_id],c);\n        item_id++;\n    }\n\n    /* Give the start condition to the waiting threads, by setting the\n     * start condition atomic var. */\n    io_threads_op = IO_THREADS_OP_WRITE;\n    for (int j = 1; j < server.io_threads_num; j++) {\n        int count = listLength(io_threads_list[j]);\n        io_threads_pending[j] = count;\n    }\n\n    /* Also use the main thread to process a slice of clients. */\n    listRewind(io_threads_list[0],&li);\n    while((ln = listNext(&li))) {\n        client *c = listNodeValue(ln);\n        writeToClient(c,0);\n    }\n    listEmpty(io_threads_list[0]);\n\n    /* Wait for all the other threads to end their work. */\n    while(1) {\n        unsigned long pending = 0;\n        for (int j = 1; j < server.io_threads_num; j++)\n            pending += io_threads_pending[j];\n        if (pending == 0) break;\n    }\n    if (tio_debug) printf(\"I/O WRITE All threads finshed\\n\");\n\n    /* Run the list of clients again to install the write handler where\n     * needed. */\n    listRewind(server.clients_pending_write,&li);\n    while((ln = listNext(&li))) {\n        client *c = listNodeValue(ln);\n\n        /* Install the write handler if there are pending writes in some\n         * of the clients. */\n        if (clientHasPendingReplies(c) &&\n                connSetWriteHandler(c->conn, sendReplyToClient) == AE_ERR)\n        {\n            freeClientAsync(c);\n        }\n    }\n    listEmpty(server.clients_pending_write);\n\n    /* Update processed count on server */\n    server.stat_io_writes_processed += processed;\n\n    return processed;\n}\n\n/* Return 1 if we want to handle the client read later using threaded I/O.\n * This is called by the readable handler of the event loop.\n * As a side effect of calling this function the client is put in the\n * pending read clients and flagged as such. */\nint postponeClientRead(client *c) {\n    if (server.io_threads_active &&\n        server.io_threads_do_reads &&\n        !clientsArePaused() &&\n        !ProcessingEventsWhileBlocked &&\n        !(c->flags & (CLIENT_MASTER|CLIENT_SLAVE|CLIENT_PENDING_READ)))\n    {\n        c->flags |= CLIENT_PENDING_READ;\n        listAddNodeHead(server.clients_pending_read,c);\n        return 1;\n    } else {\n        return 0;\n    }\n}\n\n/* When threaded I/O is also enabled for the reading + parsing side, the\n * readable handler will just put normal clients into a queue of clients to\n * process (instead of serving them synchronously). This function runs\n * the queue using the I/O threads, and process them in order to accumulate\n * the reads in the buffers, and also parse the first command available\n * rendering it in the client structures. */\nint handleClientsWithPendingReadsUsingThreads(void) {\n    if (!server.io_threads_active || !server.io_threads_do_reads) return 0;\n    int processed = listLength(server.clients_pending_read);\n    if (processed == 0) return 0;\n\n    if (tio_debug) printf(\"%d TOTAL READ pending clients\\n\", processed);\n\n    /* Distribute the clients across N different lists. */\n    listIter li;\n    listNode *ln;\n    listRewind(server.clients_pending_read,&li);\n    int item_id = 0;\n    while((ln = listNext(&li))) {\n        client *c = listNodeValue(ln);\n        int target_id = item_id % server.io_threads_num;\n        listAddNodeTail(io_threads_list[target_id],c);\n        item_id++;\n    }\n\n    /* Give the start condition to the waiting threads, by setting the\n     * start condition atomic var. */\n    io_threads_op = IO_THREADS_OP_READ;\n    for (int j = 1; j < server.io_threads_num; j++) {\n        int count = listLength(io_threads_list[j]);\n        io_threads_pending[j] = count;\n    }\n\n    /* Also use the main thread to process a slice of clients. */\n    listRewind(io_threads_list[0],&li);\n    while((ln = listNext(&li))) {\n        client *c = listNodeValue(ln);\n        readQueryFromClient(c->conn);\n    }\n    listEmpty(io_threads_list[0]);\n\n    /* Wait for all the other threads to end their work. */\n    while(1) {\n        unsigned long pending = 0;\n        for (int j = 1; j < server.io_threads_num; j++)\n            pending += io_threads_pending[j];\n        if (pending == 0) break;\n    }\n    if (tio_debug) printf(\"I/O READ All threads finshed\\n\");\n\n    /* Run the list of clients again to process the new buffers. */\n    while(listLength(server.clients_pending_read)) {\n        ln = listFirst(server.clients_pending_read);\n        client *c = listNodeValue(ln);\n        c->flags &= ~CLIENT_PENDING_READ;\n        listDelNode(server.clients_pending_read,ln);\n        /* Clients can become paused while executing the queued commands,\n         * so we need to check in between each command. If a pause was\n         * executed, we still remove the command and it will get picked up\n         * later when clients are unpaused and we re-queue all clients. */\n        if (clientsArePaused()) continue;\n\n        if (processPendingCommandsAndResetClient(c) == C_ERR) {\n            /* If the client is no longer valid, we avoid\n             * processing the client later. So we just go\n             * to the next. */\n            continue;\n        }\n        processInputBuffer(c);\n\n        /* We may have pending replies if a thread readQueryFromClient() produced\n         * replies and did not install a write handler (it can't).\n         */\n        if (!(c->flags & CLIENT_PENDING_WRITE) && clientHasPendingReplies(c))\n            clientInstallWriteHandler(c);\n    }\n\n    /* Update processed count on server */\n    server.stat_io_reads_processed += processed;\n\n    return processed;\n}\n", "/*\n * Copyright (c) 2009-2016, Salvatore Sanfilippo <antirez at gmail dot com>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"server.h\"\n#include \"cluster.h\"\n#include \"slowlog.h\"\n#include \"bio.h\"\n#include \"latency.h\"\n#include \"atomicvar.h\"\n#include \"mt19937-64.h\"\n\n#include <time.h>\n#include <signal.h>\n#include <sys/wait.h>\n#include <errno.h>\n#include <assert.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <arpa/inet.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/resource.h>\n#include <sys/uio.h>\n#include <sys/un.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <sys/resource.h>\n#include <sys/utsname.h>\n#include <locale.h>\n#include <sys/socket.h>\n\n#ifdef __linux__\n#include <sys/mman.h>\n#endif\n\n/* Our shared \"common\" objects */\n\nstruct sharedObjectsStruct shared;\n\n/* Global vars that are actually used as constants. The following double\n * values are used for double on-disk serialization, and are initialized\n * at runtime to avoid strange compiler optimizations. */\n\ndouble R_Zero, R_PosInf, R_NegInf, R_Nan;\n\n/*================================= Globals ================================= */\n\n/* Global vars */\nstruct redisServer server; /* Server global state */\n\n/* Our command table.\n *\n * Every entry is composed of the following fields:\n *\n * name:        A string representing the command name.\n *\n * function:    Pointer to the C function implementing the command.\n *\n * arity:       Number of arguments, it is possible to use -N to say >= N\n *\n * sflags:      Command flags as string. See below for a table of flags.\n *\n * flags:       Flags as bitmask. Computed by Redis using the 'sflags' field.\n *\n * get_keys_proc: An optional function to get key arguments from a command.\n *                This is only used when the following three fields are not\n *                enough to specify what arguments are keys.\n *\n * first_key_index: First argument that is a key\n *\n * last_key_index: Last argument that is a key\n *\n * key_step:    Step to get all the keys from first to last argument.\n *              For instance in MSET the step is two since arguments\n *              are key,val,key,val,...\n *\n * microseconds: Microseconds of total execution time for this command.\n *\n * calls:       Total number of calls of this command.\n *\n * id:          Command bit identifier for ACLs or other goals.\n *\n * The flags, microseconds and calls fields are computed by Redis and should\n * always be set to zero.\n *\n * Command flags are expressed using space separated strings, that are turned\n * into actual flags by the populateCommandTable() function.\n *\n * This is the meaning of the flags:\n *\n * write:       Write command (may modify the key space).\n *\n * read-only:   All the non special commands just reading from keys without\n *              changing the content, or returning other information like\n *              the TIME command. Special commands such administrative commands\n *              or transaction related commands (multi, exec, discard, ...)\n *              are not flagged as read-only commands, since they affect the\n *              server or the connection in other ways.\n *\n * use-memory:  May increase memory usage once called. Don't allow if out\n *              of memory.\n *\n * admin:       Administrative command, like SAVE or SHUTDOWN.\n *\n * pub-sub:     Pub/Sub related command.\n *\n * no-script:   Command not allowed in scripts.\n *\n * random:      Random command. Command is not deterministic, that is, the same\n *              command with the same arguments, with the same key space, may\n *              have different results. For instance SPOP and RANDOMKEY are\n *              two random commands.\n *\n * to-sort:     Sort command output array if called from script, so that the\n *              output is deterministic. When this flag is used (not always\n *              possible), then the \"random\" flag is not needed.\n *\n * ok-loading:  Allow the command while loading the database.\n *\n * ok-stale:    Allow the command while a slave has stale data but is not\n *              allowed to serve this data. Normally no command is accepted\n *              in this condition but just a few.\n *\n * no-monitor:  Do not automatically propagate the command on MONITOR.\n *\n * no-slowlog:  Do not automatically propagate the command to the slowlog.\n *\n * cluster-asking: Perform an implicit ASKING for this command, so the\n *              command will be accepted in cluster mode if the slot is marked\n *              as 'importing'.\n *\n * fast:        Fast command: O(1) or O(log(N)) command that should never\n *              delay its execution as long as the kernel scheduler is giving\n *              us time. Note that commands that may trigger a DEL as a side\n *              effect (like SET) are not fast commands.\n *\n * The following additional flags are only used in order to put commands\n * in a specific ACL category. Commands can have multiple ACL categories.\n *\n * @keyspace, @read, @write, @set, @sortedset, @list, @hash, @string, @bitmap,\n * @hyperloglog, @stream, @admin, @fast, @slow, @pubsub, @blocking, @dangerous,\n * @connection, @transaction, @scripting, @geo.\n *\n * Note that:\n *\n * 1) The read-only flag implies the @read ACL category.\n * 2) The write flag implies the @write ACL category.\n * 3) The fast flag implies the @fast ACL category.\n * 4) The admin flag implies the @admin and @dangerous ACL category.\n * 5) The pub-sub flag implies the @pubsub ACL category.\n * 6) The lack of fast flag implies the @slow ACL category.\n * 7) The non obvious \"keyspace\" category includes the commands\n *    that interact with keys without having anything to do with\n *    specific data structures, such as: DEL, RENAME, MOVE, SELECT,\n *    TYPE, EXPIRE*, PEXPIRE*, TTL, PTTL, ...\n */\n\nstruct redisCommand redisCommandTable[] = {\n    {\"module\",moduleCommand,-2,\n     \"admin no-script\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"get\",getCommand,2,\n     \"read-only fast @string\",\n     0,NULL,1,1,1,0,0,0},\n\n    /* Note that we can't flag set as fast, since it may perform an\n     * implicit DEL of a large key. */\n    {\"set\",setCommand,-3,\n     \"write use-memory @string\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"setnx\",setnxCommand,3,\n     \"write use-memory fast @string\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"setex\",setexCommand,4,\n     \"write use-memory @string\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"psetex\",psetexCommand,4,\n     \"write use-memory @string\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"append\",appendCommand,3,\n     \"write use-memory fast @string\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"strlen\",strlenCommand,2,\n     \"read-only fast @string\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"del\",delCommand,-2,\n     \"write @keyspace\",\n     0,NULL,1,-1,1,0,0,0},\n\n    {\"unlink\",unlinkCommand,-2,\n     \"write fast @keyspace\",\n     0,NULL,1,-1,1,0,0,0},\n\n    {\"exists\",existsCommand,-2,\n     \"read-only fast @keyspace\",\n     0,NULL,1,-1,1,0,0,0},\n\n    {\"setbit\",setbitCommand,4,\n     \"write use-memory @bitmap\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"getbit\",getbitCommand,3,\n     \"read-only fast @bitmap\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"bitfield\",bitfieldCommand,-2,\n     \"write use-memory @bitmap\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"bitfield_ro\",bitfieldroCommand,-2,\n     \"read-only fast @bitmap\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"setrange\",setrangeCommand,4,\n     \"write use-memory @string\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"getrange\",getrangeCommand,4,\n     \"read-only @string\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"substr\",getrangeCommand,4,\n     \"read-only @string\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"incr\",incrCommand,2,\n     \"write use-memory fast @string\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"decr\",decrCommand,2,\n     \"write use-memory fast @string\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"mget\",mgetCommand,-2,\n     \"read-only fast @string\",\n     0,NULL,1,-1,1,0,0,0},\n\n    {\"rpush\",rpushCommand,-3,\n     \"write use-memory fast @list\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"lpush\",lpushCommand,-3,\n     \"write use-memory fast @list\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"rpushx\",rpushxCommand,-3,\n     \"write use-memory fast @list\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"lpushx\",lpushxCommand,-3,\n     \"write use-memory fast @list\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"linsert\",linsertCommand,5,\n     \"write use-memory @list\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"rpop\",rpopCommand,2,\n     \"write fast @list\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"lpop\",lpopCommand,2,\n     \"write fast @list\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"brpop\",brpopCommand,-3,\n     \"write no-script @list @blocking\",\n     0,NULL,1,-2,1,0,0,0},\n\n    {\"brpoplpush\",brpoplpushCommand,4,\n     \"write use-memory no-script @list @blocking\",\n     0,NULL,1,2,1,0,0,0},\n\n    {\"blpop\",blpopCommand,-3,\n     \"write no-script @list @blocking\",\n     0,NULL,1,-2,1,0,0,0},\n\n    {\"llen\",llenCommand,2,\n     \"read-only fast @list\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"lindex\",lindexCommand,3,\n     \"read-only @list\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"lset\",lsetCommand,4,\n     \"write use-memory @list\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"lrange\",lrangeCommand,4,\n     \"read-only @list\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"ltrim\",ltrimCommand,4,\n     \"write @list\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"lpos\",lposCommand,-3,\n     \"read-only @list\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"lrem\",lremCommand,4,\n     \"write @list\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"rpoplpush\",rpoplpushCommand,3,\n     \"write use-memory @list\",\n     0,NULL,1,2,1,0,0,0},\n\n    {\"sadd\",saddCommand,-3,\n     \"write use-memory fast @set\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"srem\",sremCommand,-3,\n     \"write fast @set\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"smove\",smoveCommand,4,\n     \"write fast @set\",\n     0,NULL,1,2,1,0,0,0},\n\n    {\"sismember\",sismemberCommand,3,\n     \"read-only fast @set\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"scard\",scardCommand,2,\n     \"read-only fast @set\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"spop\",spopCommand,-2,\n     \"write random fast @set\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"srandmember\",srandmemberCommand,-2,\n     \"read-only random @set\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"sinter\",sinterCommand,-2,\n     \"read-only to-sort @set\",\n     0,NULL,1,-1,1,0,0,0},\n\n    {\"sinterstore\",sinterstoreCommand,-3,\n     \"write use-memory @set\",\n     0,NULL,1,-1,1,0,0,0},\n\n    {\"sunion\",sunionCommand,-2,\n     \"read-only to-sort @set\",\n     0,NULL,1,-1,1,0,0,0},\n\n    {\"sunionstore\",sunionstoreCommand,-3,\n     \"write use-memory @set\",\n     0,NULL,1,-1,1,0,0,0},\n\n    {\"sdiff\",sdiffCommand,-2,\n     \"read-only to-sort @set\",\n     0,NULL,1,-1,1,0,0,0},\n\n    {\"sdiffstore\",sdiffstoreCommand,-3,\n     \"write use-memory @set\",\n     0,NULL,1,-1,1,0,0,0},\n\n    {\"smembers\",sinterCommand,2,\n     \"read-only to-sort @set\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"sscan\",sscanCommand,-3,\n     \"read-only random @set\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zadd\",zaddCommand,-4,\n     \"write use-memory fast @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zincrby\",zincrbyCommand,4,\n     \"write use-memory fast @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zrem\",zremCommand,-3,\n     \"write fast @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zremrangebyscore\",zremrangebyscoreCommand,4,\n     \"write @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zremrangebyrank\",zremrangebyrankCommand,4,\n     \"write @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zremrangebylex\",zremrangebylexCommand,4,\n     \"write @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zunionstore\",zunionstoreCommand,-4,\n     \"write use-memory @sortedset\",\n     0,zunionInterGetKeys,1,1,1,0,0,0},\n\n    {\"zinterstore\",zinterstoreCommand,-4,\n     \"write use-memory @sortedset\",\n     0,zunionInterGetKeys,1,1,1,0,0,0},\n\n    {\"zrange\",zrangeCommand,-4,\n     \"read-only @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zrangebyscore\",zrangebyscoreCommand,-4,\n     \"read-only @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zrevrangebyscore\",zrevrangebyscoreCommand,-4,\n     \"read-only @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zrangebylex\",zrangebylexCommand,-4,\n     \"read-only @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zrevrangebylex\",zrevrangebylexCommand,-4,\n     \"read-only @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zcount\",zcountCommand,4,\n     \"read-only fast @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zlexcount\",zlexcountCommand,4,\n     \"read-only fast @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zrevrange\",zrevrangeCommand,-4,\n     \"read-only @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zcard\",zcardCommand,2,\n     \"read-only fast @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zscore\",zscoreCommand,3,\n     \"read-only fast @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zrank\",zrankCommand,3,\n     \"read-only fast @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zrevrank\",zrevrankCommand,3,\n     \"read-only fast @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zscan\",zscanCommand,-3,\n     \"read-only random @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zpopmin\",zpopminCommand,-2,\n     \"write fast @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zpopmax\",zpopmaxCommand,-2,\n     \"write fast @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"bzpopmin\",bzpopminCommand,-3,\n     \"write no-script fast @sortedset @blocking\",\n     0,NULL,1,-2,1,0,0,0},\n\n    {\"bzpopmax\",bzpopmaxCommand,-3,\n     \"write no-script fast @sortedset @blocking\",\n     0,NULL,1,-2,1,0,0,0},\n\n    {\"hset\",hsetCommand,-4,\n     \"write use-memory fast @hash\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"hsetnx\",hsetnxCommand,4,\n     \"write use-memory fast @hash\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"hget\",hgetCommand,3,\n     \"read-only fast @hash\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"hmset\",hsetCommand,-4,\n     \"write use-memory fast @hash\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"hmget\",hmgetCommand,-3,\n     \"read-only fast @hash\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"hincrby\",hincrbyCommand,4,\n     \"write use-memory fast @hash\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"hincrbyfloat\",hincrbyfloatCommand,4,\n     \"write use-memory fast @hash\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"hdel\",hdelCommand,-3,\n     \"write fast @hash\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"hlen\",hlenCommand,2,\n     \"read-only fast @hash\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"hstrlen\",hstrlenCommand,3,\n     \"read-only fast @hash\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"hkeys\",hkeysCommand,2,\n     \"read-only to-sort @hash\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"hvals\",hvalsCommand,2,\n     \"read-only to-sort @hash\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"hgetall\",hgetallCommand,2,\n     \"read-only random @hash\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"hexists\",hexistsCommand,3,\n     \"read-only fast @hash\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"hscan\",hscanCommand,-3,\n     \"read-only random @hash\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"incrby\",incrbyCommand,3,\n     \"write use-memory fast @string\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"decrby\",decrbyCommand,3,\n     \"write use-memory fast @string\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"incrbyfloat\",incrbyfloatCommand,3,\n     \"write use-memory fast @string\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"getset\",getsetCommand,3,\n     \"write use-memory fast @string\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"mset\",msetCommand,-3,\n     \"write use-memory @string\",\n     0,NULL,1,-1,2,0,0,0},\n\n    {\"msetnx\",msetnxCommand,-3,\n     \"write use-memory @string\",\n     0,NULL,1,-1,2,0,0,0},\n\n    {\"randomkey\",randomkeyCommand,1,\n     \"read-only random @keyspace\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"select\",selectCommand,2,\n     \"ok-loading fast ok-stale @keyspace\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"swapdb\",swapdbCommand,3,\n     \"write fast @keyspace @dangerous\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"move\",moveCommand,3,\n     \"write fast @keyspace\",\n     0,NULL,1,1,1,0,0,0},\n\n    /* Like for SET, we can't mark rename as a fast command because\n     * overwriting the target key may result in an implicit slow DEL. */\n    {\"rename\",renameCommand,3,\n     \"write @keyspace\",\n     0,NULL,1,2,1,0,0,0},\n\n    {\"renamenx\",renamenxCommand,3,\n     \"write fast @keyspace\",\n     0,NULL,1,2,1,0,0,0},\n\n    {\"expire\",expireCommand,3,\n     \"write fast @keyspace\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"expireat\",expireatCommand,3,\n     \"write fast @keyspace\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"pexpire\",pexpireCommand,3,\n     \"write fast @keyspace\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"pexpireat\",pexpireatCommand,3,\n     \"write fast @keyspace\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"keys\",keysCommand,2,\n     \"read-only to-sort @keyspace @dangerous\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"scan\",scanCommand,-2,\n     \"read-only random @keyspace\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"dbsize\",dbsizeCommand,1,\n     \"read-only fast @keyspace\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"auth\",authCommand,-2,\n     \"no-auth no-script ok-loading ok-stale fast no-monitor no-slowlog @connection\",\n     0,NULL,0,0,0,0,0,0},\n\n    /* We don't allow PING during loading since in Redis PING is used as\n     * failure detection, and a loading server is considered to be\n     * not available. */\n    {\"ping\",pingCommand,-1,\n     \"ok-stale fast @connection\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"echo\",echoCommand,2,\n     \"read-only fast @connection\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"save\",saveCommand,1,\n     \"admin no-script\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"bgsave\",bgsaveCommand,-1,\n     \"admin no-script\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"bgrewriteaof\",bgrewriteaofCommand,1,\n     \"admin no-script\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"shutdown\",shutdownCommand,-1,\n     \"admin no-script ok-loading ok-stale\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"lastsave\",lastsaveCommand,1,\n     \"read-only random fast ok-loading ok-stale @admin @dangerous\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"type\",typeCommand,2,\n     \"read-only fast @keyspace\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"multi\",multiCommand,1,\n     \"no-script fast ok-loading ok-stale @transaction\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"exec\",execCommand,1,\n     \"no-script no-monitor no-slowlog ok-loading ok-stale @transaction\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"discard\",discardCommand,1,\n     \"no-script fast ok-loading ok-stale @transaction\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"sync\",syncCommand,1,\n     \"admin no-script\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"psync\",syncCommand,3,\n     \"admin no-script\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"replconf\",replconfCommand,-1,\n     \"admin no-script ok-loading ok-stale\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"flushdb\",flushdbCommand,-1,\n     \"write @keyspace @dangerous\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"flushall\",flushallCommand,-1,\n     \"write @keyspace @dangerous\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"sort\",sortCommand,-2,\n     \"write use-memory @list @set @sortedset @dangerous\",\n     0,sortGetKeys,1,1,1,0,0,0},\n\n    {\"info\",infoCommand,-1,\n     \"ok-loading ok-stale random @dangerous\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"monitor\",monitorCommand,1,\n     \"admin no-script ok-loading ok-stale\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"ttl\",ttlCommand,2,\n     \"read-only fast random @keyspace\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"touch\",touchCommand,-2,\n     \"read-only fast @keyspace\",\n     0,NULL,1,-1,1,0,0,0},\n\n    {\"pttl\",pttlCommand,2,\n     \"read-only fast random @keyspace\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"persist\",persistCommand,2,\n     \"write fast @keyspace\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"slaveof\",replicaofCommand,3,\n     \"admin no-script ok-stale\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"replicaof\",replicaofCommand,3,\n     \"admin no-script ok-stale\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"role\",roleCommand,1,\n     \"ok-loading ok-stale no-script fast read-only @dangerous\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"debug\",debugCommand,-2,\n     \"admin no-script ok-loading ok-stale\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"config\",configCommand,-2,\n     \"admin ok-loading ok-stale no-script\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"subscribe\",subscribeCommand,-2,\n     \"pub-sub no-script ok-loading ok-stale\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"unsubscribe\",unsubscribeCommand,-1,\n     \"pub-sub no-script ok-loading ok-stale\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"psubscribe\",psubscribeCommand,-2,\n     \"pub-sub no-script ok-loading ok-stale\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"punsubscribe\",punsubscribeCommand,-1,\n     \"pub-sub no-script ok-loading ok-stale\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"publish\",publishCommand,3,\n     \"pub-sub ok-loading ok-stale fast\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"pubsub\",pubsubCommand,-2,\n     \"pub-sub ok-loading ok-stale random\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"watch\",watchCommand,-2,\n     \"no-script fast ok-loading ok-stale @transaction\",\n     0,NULL,1,-1,1,0,0,0},\n\n    {\"unwatch\",unwatchCommand,1,\n     \"no-script fast ok-loading ok-stale @transaction\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"cluster\",clusterCommand,-2,\n     \"admin ok-stale random\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"restore\",restoreCommand,-4,\n     \"write use-memory @keyspace @dangerous\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"restore-asking\",restoreCommand,-4,\n    \"write use-memory cluster-asking @keyspace @dangerous\",\n    0,NULL,1,1,1,0,0,0},\n\n    {\"migrate\",migrateCommand,-6,\n     \"write random @keyspace @dangerous\",\n     0,migrateGetKeys,0,0,0,0,0,0},\n\n    {\"asking\",askingCommand,1,\n     \"fast @keyspace\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"readonly\",readonlyCommand,1,\n     \"fast @keyspace\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"readwrite\",readwriteCommand,1,\n     \"fast @keyspace\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"dump\",dumpCommand,2,\n     \"read-only random @keyspace\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"object\",objectCommand,-2,\n     \"read-only random @keyspace\",\n     0,NULL,2,2,1,0,0,0},\n\n    {\"memory\",memoryCommand,-2,\n     \"random read-only\",\n     0,memoryGetKeys,0,0,0,0,0,0},\n\n    {\"client\",clientCommand,-2,\n     \"admin no-script random ok-loading ok-stale @connection\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"hello\",helloCommand,-2,\n     \"no-auth no-script fast no-monitor ok-loading ok-stale no-slowlog @connection\",\n     0,NULL,0,0,0,0,0,0},\n\n    /* EVAL can modify the dataset, however it is not flagged as a write\n     * command since we do the check while running commands from Lua. */\n    {\"eval\",evalCommand,-3,\n     \"no-script @scripting\",\n     0,evalGetKeys,0,0,0,0,0,0},\n\n    {\"evalsha\",evalShaCommand,-3,\n     \"no-script @scripting\",\n     0,evalGetKeys,0,0,0,0,0,0},\n\n    {\"slowlog\",slowlogCommand,-2,\n     \"admin random ok-loading ok-stale\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"script\",scriptCommand,-2,\n     \"no-script @scripting\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"time\",timeCommand,1,\n     \"read-only random fast ok-loading ok-stale\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"bitop\",bitopCommand,-4,\n     \"write use-memory @bitmap\",\n     0,NULL,2,-1,1,0,0,0},\n\n    {\"bitcount\",bitcountCommand,-2,\n     \"read-only @bitmap\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"bitpos\",bitposCommand,-3,\n     \"read-only @bitmap\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"wait\",waitCommand,3,\n     \"no-script @keyspace\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"command\",commandCommand,-1,\n     \"ok-loading ok-stale random @connection\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"geoadd\",geoaddCommand,-5,\n     \"write use-memory @geo\",\n     0,NULL,1,1,1,0,0,0},\n\n    /* GEORADIUS has store options that may write. */\n    {\"georadius\",georadiusCommand,-6,\n     \"write use-memory @geo\",\n     0,georadiusGetKeys,1,1,1,0,0,0},\n\n    {\"georadius_ro\",georadiusroCommand,-6,\n     \"read-only @geo\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"georadiusbymember\",georadiusbymemberCommand,-5,\n     \"write use-memory @geo\",\n     0,georadiusGetKeys,1,1,1,0,0,0},\n\n    {\"georadiusbymember_ro\",georadiusbymemberroCommand,-5,\n     \"read-only @geo\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"geohash\",geohashCommand,-2,\n     \"read-only @geo\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"geopos\",geoposCommand,-2,\n     \"read-only @geo\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"geodist\",geodistCommand,-4,\n     \"read-only @geo\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"pfselftest\",pfselftestCommand,1,\n     \"admin @hyperloglog\",\n      0,NULL,0,0,0,0,0,0},\n\n    {\"pfadd\",pfaddCommand,-2,\n     \"write use-memory fast @hyperloglog\",\n     0,NULL,1,1,1,0,0,0},\n\n    /* Technically speaking PFCOUNT may change the key since it changes the\n     * final bytes in the HyperLogLog representation. However in this case\n     * we claim that the representation, even if accessible, is an internal\n     * affair, and the command is semantically read only. */\n    {\"pfcount\",pfcountCommand,-2,\n     \"read-only @hyperloglog\",\n     0,NULL,1,-1,1,0,0,0},\n\n    {\"pfmerge\",pfmergeCommand,-2,\n     \"write use-memory @hyperloglog\",\n     0,NULL,1,-1,1,0,0,0},\n\n    {\"pfdebug\",pfdebugCommand,-3,\n     \"admin write\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"xadd\",xaddCommand,-5,\n     \"write use-memory fast random @stream\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"xrange\",xrangeCommand,-4,\n     \"read-only @stream\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"xrevrange\",xrevrangeCommand,-4,\n     \"read-only @stream\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"xlen\",xlenCommand,2,\n     \"read-only fast @stream\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"xread\",xreadCommand,-4,\n     \"read-only @stream @blocking\",\n     0,xreadGetKeys,0,0,0,0,0,0},\n\n    {\"xreadgroup\",xreadCommand,-7,\n     \"write @stream @blocking\",\n     0,xreadGetKeys,0,0,0,0,0,0},\n\n    {\"xgroup\",xgroupCommand,-2,\n     \"write use-memory @stream\",\n     0,NULL,2,2,1,0,0,0},\n\n    {\"xsetid\",xsetidCommand,3,\n     \"write use-memory fast @stream\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"xack\",xackCommand,-4,\n     \"write fast random @stream\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"xpending\",xpendingCommand,-3,\n     \"read-only random @stream\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"xclaim\",xclaimCommand,-6,\n     \"write random fast @stream\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"xinfo\",xinfoCommand,-2,\n     \"read-only random @stream\",\n     0,NULL,2,2,1,0,0,0},\n\n    {\"xdel\",xdelCommand,-3,\n     \"write fast @stream\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"xtrim\",xtrimCommand,-2,\n     \"write random @stream\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"post\",securityWarningCommand,-1,\n     \"ok-loading ok-stale read-only\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"host:\",securityWarningCommand,-1,\n     \"ok-loading ok-stale read-only\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"latency\",latencyCommand,-2,\n     \"admin no-script ok-loading ok-stale\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"lolwut\",lolwutCommand,-1,\n     \"read-only fast\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"acl\",aclCommand,-2,\n     \"admin no-script no-slowlog ok-loading ok-stale\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"stralgo\",stralgoCommand,-2,\n     \"read-only @string\",\n     0,lcsGetKeys,0,0,0,0,0,0}\n};\n\n/*============================ Utility functions ============================ */\n\n/* We use a private localtime implementation which is fork-safe. The logging\n * function of Redis may be called from other threads. */\nvoid nolocks_localtime(struct tm *tmp, time_t t, time_t tz, int dst);\n\n/* Low level logging. To use only for very big messages, otherwise\n * serverLog() is to prefer. */\nvoid serverLogRaw(int level, const char *msg) {\n    const int syslogLevelMap[] = { LOG_DEBUG, LOG_INFO, LOG_NOTICE, LOG_WARNING };\n    const char *c = \".-*#\";\n    FILE *fp;\n    char buf[64];\n    int rawmode = (level & LL_RAW);\n    int log_to_stdout = server.logfile[0] == '\\0';\n\n    level &= 0xff; /* clear flags */\n    if (level < server.verbosity) return;\n\n    fp = log_to_stdout ? stdout : fopen(server.logfile,\"a\");\n    if (!fp) return;\n\n    if (rawmode) {\n        fprintf(fp,\"%s\",msg);\n    } else {\n        int off;\n        struct timeval tv;\n        int role_char;\n        pid_t pid = getpid();\n\n        gettimeofday(&tv,NULL);\n        struct tm tm;\n        nolocks_localtime(&tm,tv.tv_sec,server.timezone,server.daylight_active);\n        off = strftime(buf,sizeof(buf),\"%d %b %Y %H:%M:%S.\",&tm);\n        snprintf(buf+off,sizeof(buf)-off,\"%03d\",(int)tv.tv_usec/1000);\n        if (server.sentinel_mode) {\n            role_char = 'X'; /* Sentinel. */\n        } else if (pid != server.pid) {\n            role_char = 'C'; /* RDB / AOF writing child. */\n        } else {\n            role_char = (server.masterhost ? 'S':'M'); /* Slave or Master. */\n        }\n        fprintf(fp,\"%d:%c %s %c %s\\n\",\n            (int)getpid(),role_char, buf,c[level],msg);\n    }\n    fflush(fp);\n\n    if (!log_to_stdout) fclose(fp);\n    if (server.syslog_enabled) syslog(syslogLevelMap[level], \"%s\", msg);\n}\n\n/* Like serverLogRaw() but with printf-alike support. This is the function that\n * is used across the code. The raw version is only used in order to dump\n * the INFO output on crash. */\nvoid serverLog(int level, const char *fmt, ...) {\n    va_list ap;\n    char msg[LOG_MAX_LEN];\n\n    if ((level&0xff) < server.verbosity) return;\n\n    va_start(ap, fmt);\n    vsnprintf(msg, sizeof(msg), fmt, ap);\n    va_end(ap);\n\n    serverLogRaw(level,msg);\n}\n\n/* Log a fixed message without printf-alike capabilities, in a way that is\n * safe to call from a signal handler.\n *\n * We actually use this only for signals that are not fatal from the point\n * of view of Redis. Signals that are going to kill the server anyway and\n * where we need printf-alike features are served by serverLog(). */\nvoid serverLogFromHandler(int level, const char *msg) {\n    int fd;\n    int log_to_stdout = server.logfile[0] == '\\0';\n    char buf[64];\n\n    if ((level&0xff) < server.verbosity || (log_to_stdout && server.daemonize))\n        return;\n    fd = log_to_stdout ? STDOUT_FILENO :\n                         open(server.logfile, O_APPEND|O_CREAT|O_WRONLY, 0644);\n    if (fd == -1) return;\n    ll2string(buf,sizeof(buf),getpid());\n    if (write(fd,buf,strlen(buf)) == -1) goto err;\n    if (write(fd,\":signal-handler (\",17) == -1) goto err;\n    ll2string(buf,sizeof(buf),time(NULL));\n    if (write(fd,buf,strlen(buf)) == -1) goto err;\n    if (write(fd,\") \",2) == -1) goto err;\n    if (write(fd,msg,strlen(msg)) == -1) goto err;\n    if (write(fd,\"\\n\",1) == -1) goto err;\nerr:\n    if (!log_to_stdout) close(fd);\n}\n\n/* Return the UNIX time in microseconds */\nlong long ustime(void) {\n    struct timeval tv;\n    long long ust;\n\n    gettimeofday(&tv, NULL);\n    ust = ((long long)tv.tv_sec)*1000000;\n    ust += tv.tv_usec;\n    return ust;\n}\n\n/* Return the UNIX time in milliseconds */\nmstime_t mstime(void) {\n    return ustime()/1000;\n}\n\n/* After an RDB dump or AOF rewrite we exit from children using _exit() instead of\n * exit(), because the latter may interact with the same file objects used by\n * the parent process. However if we are testing the coverage normal exit() is\n * used in order to obtain the right coverage information. */\nvoid exitFromChild(int retcode) {\n#ifdef COVERAGE_TEST\n    exit(retcode);\n#else\n    _exit(retcode);\n#endif\n}\n\n/*====================== Hash table type implementation  ==================== */\n\n/* This is a hash table type that uses the SDS dynamic strings library as\n * keys and redis objects as values (objects can hold SDS strings,\n * lists, sets). */\n\nvoid dictVanillaFree(void *privdata, void *val)\n{\n    DICT_NOTUSED(privdata);\n    zfree(val);\n}\n\nvoid dictListDestructor(void *privdata, void *val)\n{\n    DICT_NOTUSED(privdata);\n    listRelease((list*)val);\n}\n\nint dictSdsKeyCompare(void *privdata, const void *key1,\n        const void *key2)\n{\n    int l1,l2;\n    DICT_NOTUSED(privdata);\n\n    l1 = sdslen((sds)key1);\n    l2 = sdslen((sds)key2);\n    if (l1 != l2) return 0;\n    return memcmp(key1, key2, l1) == 0;\n}\n\n/* A case insensitive version used for the command lookup table and other\n * places where case insensitive non binary-safe comparison is needed. */\nint dictSdsKeyCaseCompare(void *privdata, const void *key1,\n        const void *key2)\n{\n    DICT_NOTUSED(privdata);\n\n    return strcasecmp(key1, key2) == 0;\n}\n\nvoid dictObjectDestructor(void *privdata, void *val)\n{\n    DICT_NOTUSED(privdata);\n\n    if (val == NULL) return; /* Lazy freeing will set value to NULL. */\n    decrRefCount(val);\n}\n\nvoid dictSdsDestructor(void *privdata, void *val)\n{\n    DICT_NOTUSED(privdata);\n\n    sdsfree(val);\n}\n\nint dictObjKeyCompare(void *privdata, const void *key1,\n        const void *key2)\n{\n    const robj *o1 = key1, *o2 = key2;\n    return dictSdsKeyCompare(privdata,o1->ptr,o2->ptr);\n}\n\nuint64_t dictObjHash(const void *key) {\n    const robj *o = key;\n    return dictGenHashFunction(o->ptr, sdslen((sds)o->ptr));\n}\n\nuint64_t dictSdsHash(const void *key) {\n    return dictGenHashFunction((unsigned char*)key, sdslen((char*)key));\n}\n\nuint64_t dictSdsCaseHash(const void *key) {\n    return dictGenCaseHashFunction((unsigned char*)key, sdslen((char*)key));\n}\n\nint dictEncObjKeyCompare(void *privdata, const void *key1,\n        const void *key2)\n{\n    robj *o1 = (robj*) key1, *o2 = (robj*) key2;\n    int cmp;\n\n    if (o1->encoding == OBJ_ENCODING_INT &&\n        o2->encoding == OBJ_ENCODING_INT)\n            return o1->ptr == o2->ptr;\n\n    /* Due to OBJ_STATIC_REFCOUNT, we avoid calling getDecodedObject() without\n     * good reasons, because it would incrRefCount() the object, which\n     * is invalid. So we check to make sure dictFind() works with static\n     * objects as well. */\n    if (o1->refcount != OBJ_STATIC_REFCOUNT) o1 = getDecodedObject(o1);\n    if (o2->refcount != OBJ_STATIC_REFCOUNT) o2 = getDecodedObject(o2);\n    cmp = dictSdsKeyCompare(privdata,o1->ptr,o2->ptr);\n    if (o1->refcount != OBJ_STATIC_REFCOUNT) decrRefCount(o1);\n    if (o2->refcount != OBJ_STATIC_REFCOUNT) decrRefCount(o2);\n    return cmp;\n}\n\nuint64_t dictEncObjHash(const void *key) {\n    robj *o = (robj*) key;\n\n    if (sdsEncodedObject(o)) {\n        return dictGenHashFunction(o->ptr, sdslen((sds)o->ptr));\n    } else {\n        if (o->encoding == OBJ_ENCODING_INT) {\n            char buf[32];\n            int len;\n\n            len = ll2string(buf,32,(long)o->ptr);\n            return dictGenHashFunction((unsigned char*)buf, len);\n        } else {\n            uint64_t hash;\n\n            o = getDecodedObject(o);\n            hash = dictGenHashFunction(o->ptr, sdslen((sds)o->ptr));\n            decrRefCount(o);\n            return hash;\n        }\n    }\n}\n\n/* Generic hash table type where keys are Redis Objects, Values\n * dummy pointers. */\ndictType objectKeyPointerValueDictType = {\n    dictEncObjHash,            /* hash function */\n    NULL,                      /* key dup */\n    NULL,                      /* val dup */\n    dictEncObjKeyCompare,      /* key compare */\n    dictObjectDestructor,      /* key destructor */\n    NULL                       /* val destructor */\n};\n\n/* Like objectKeyPointerValueDictType(), but values can be destroyed, if\n * not NULL, calling zfree(). */\ndictType objectKeyHeapPointerValueDictType = {\n    dictEncObjHash,            /* hash function */\n    NULL,                      /* key dup */\n    NULL,                      /* val dup */\n    dictEncObjKeyCompare,      /* key compare */\n    dictObjectDestructor,      /* key destructor */\n    dictVanillaFree            /* val destructor */\n};\n\n/* Set dictionary type. Keys are SDS strings, values are not used. */\ndictType setDictType = {\n    dictSdsHash,               /* hash function */\n    NULL,                      /* key dup */\n    NULL,                      /* val dup */\n    dictSdsKeyCompare,         /* key compare */\n    dictSdsDestructor,         /* key destructor */\n    NULL                       /* val destructor */\n};\n\n/* Sorted sets hash (note: a skiplist is used in addition to the hash table) */\ndictType zsetDictType = {\n    dictSdsHash,               /* hash function */\n    NULL,                      /* key dup */\n    NULL,                      /* val dup */\n    dictSdsKeyCompare,         /* key compare */\n    NULL,                      /* Note: SDS string shared & freed by skiplist */\n    NULL                       /* val destructor */\n};\n\n/* Db->dict, keys are sds strings, vals are Redis objects. */\ndictType dbDictType = {\n    dictSdsHash,                /* hash function */\n    NULL,                       /* key dup */\n    NULL,                       /* val dup */\n    dictSdsKeyCompare,          /* key compare */\n    dictSdsDestructor,          /* key destructor */\n    dictObjectDestructor   /* val destructor */\n};\n\n/* server.lua_scripts sha (as sds string) -> scripts (as robj) cache. */\ndictType shaScriptObjectDictType = {\n    dictSdsCaseHash,            /* hash function */\n    NULL,                       /* key dup */\n    NULL,                       /* val dup */\n    dictSdsKeyCaseCompare,      /* key compare */\n    dictSdsDestructor,          /* key destructor */\n    dictObjectDestructor        /* val destructor */\n};\n\n/* Db->expires */\ndictType keyptrDictType = {\n    dictSdsHash,                /* hash function */\n    NULL,                       /* key dup */\n    NULL,                       /* val dup */\n    dictSdsKeyCompare,          /* key compare */\n    NULL,                       /* key destructor */\n    NULL                        /* val destructor */\n};\n\n/* Command table. sds string -> command struct pointer. */\ndictType commandTableDictType = {\n    dictSdsCaseHash,            /* hash function */\n    NULL,                       /* key dup */\n    NULL,                       /* val dup */\n    dictSdsKeyCaseCompare,      /* key compare */\n    dictSdsDestructor,          /* key destructor */\n    NULL                        /* val destructor */\n};\n\n/* Hash type hash table (note that small hashes are represented with ziplists) */\ndictType hashDictType = {\n    dictSdsHash,                /* hash function */\n    NULL,                       /* key dup */\n    NULL,                       /* val dup */\n    dictSdsKeyCompare,          /* key compare */\n    dictSdsDestructor,          /* key destructor */\n    dictSdsDestructor           /* val destructor */\n};\n\n/* Keylist hash table type has unencoded redis objects as keys and\n * lists as values. It's used for blocking operations (BLPOP) and to\n * map swapped keys to a list of clients waiting for this keys to be loaded. */\ndictType keylistDictType = {\n    dictObjHash,                /* hash function */\n    NULL,                       /* key dup */\n    NULL,                       /* val dup */\n    dictObjKeyCompare,          /* key compare */\n    dictObjectDestructor,       /* key destructor */\n    dictListDestructor          /* val destructor */\n};\n\n/* Cluster nodes hash table, mapping nodes addresses 1.2.3.4:6379 to\n * clusterNode structures. */\ndictType clusterNodesDictType = {\n    dictSdsHash,                /* hash function */\n    NULL,                       /* key dup */\n    NULL,                       /* val dup */\n    dictSdsKeyCompare,          /* key compare */\n    dictSdsDestructor,          /* key destructor */\n    NULL                        /* val destructor */\n};\n\n/* Cluster re-addition blacklist. This maps node IDs to the time\n * we can re-add this node. The goal is to avoid readding a removed\n * node for some time. */\ndictType clusterNodesBlackListDictType = {\n    dictSdsCaseHash,            /* hash function */\n    NULL,                       /* key dup */\n    NULL,                       /* val dup */\n    dictSdsKeyCaseCompare,      /* key compare */\n    dictSdsDestructor,          /* key destructor */\n    NULL                        /* val destructor */\n};\n\n/* Modules system dictionary type. Keys are module name,\n * values are pointer to RedisModule struct. */\ndictType modulesDictType = {\n    dictSdsCaseHash,            /* hash function */\n    NULL,                       /* key dup */\n    NULL,                       /* val dup */\n    dictSdsKeyCaseCompare,      /* key compare */\n    dictSdsDestructor,          /* key destructor */\n    NULL                        /* val destructor */\n};\n\n/* Migrate cache dict type. */\ndictType migrateCacheDictType = {\n    dictSdsHash,                /* hash function */\n    NULL,                       /* key dup */\n    NULL,                       /* val dup */\n    dictSdsKeyCompare,          /* key compare */\n    dictSdsDestructor,          /* key destructor */\n    NULL                        /* val destructor */\n};\n\n/* Replication cached script dict (server.repl_scriptcache_dict).\n * Keys are sds SHA1 strings, while values are not used at all in the current\n * implementation. */\ndictType replScriptCacheDictType = {\n    dictSdsCaseHash,            /* hash function */\n    NULL,                       /* key dup */\n    NULL,                       /* val dup */\n    dictSdsKeyCaseCompare,      /* key compare */\n    dictSdsDestructor,          /* key destructor */\n    NULL                        /* val destructor */\n};\n\nint htNeedsResize(dict *dict) {\n    long long size, used;\n\n    size = dictSlots(dict);\n    used = dictSize(dict);\n    return (size > DICT_HT_INITIAL_SIZE &&\n            (used*100/size < HASHTABLE_MIN_FILL));\n}\n\n/* If the percentage of used slots in the HT reaches HASHTABLE_MIN_FILL\n * we resize the hash table to save memory */\nvoid tryResizeHashTables(int dbid) {\n    if (htNeedsResize(server.db[dbid].dict))\n        dictResize(server.db[dbid].dict);\n    if (htNeedsResize(server.db[dbid].expires))\n        dictResize(server.db[dbid].expires);\n}\n\n/* Our hash table implementation performs rehashing incrementally while\n * we write/read from the hash table. Still if the server is idle, the hash\n * table will use two tables for a long time. So we try to use 1 millisecond\n * of CPU time at every call of this function to perform some rehashing.\n *\n * The function returns 1 if some rehashing was performed, otherwise 0\n * is returned. */\nint incrementallyRehash(int dbid) {\n    /* Keys dictionary */\n    if (dictIsRehashing(server.db[dbid].dict)) {\n        dictRehashMilliseconds(server.db[dbid].dict,1);\n        return 1; /* already used our millisecond for this loop... */\n    }\n    /* Expires */\n    if (dictIsRehashing(server.db[dbid].expires)) {\n        dictRehashMilliseconds(server.db[dbid].expires,1);\n        return 1; /* already used our millisecond for this loop... */\n    }\n    return 0;\n}\n\n/* This function is called once a background process of some kind terminates,\n * as we want to avoid resizing the hash tables when there is a child in order\n * to play well with copy-on-write (otherwise when a resize happens lots of\n * memory pages are copied). The goal of this function is to update the ability\n * for dict.c to resize the hash tables accordingly to the fact we have an\n * active fork child running. */\nvoid updateDictResizePolicy(void) {\n    if (!hasActiveChildProcess())\n        dictEnableResize();\n    else\n        dictDisableResize();\n}\n\n/* Return true if there are no active children processes doing RDB saving,\n * AOF rewriting, or some side process spawned by a loaded module. */\nint hasActiveChildProcess() {\n    return server.rdb_child_pid != -1 ||\n           server.aof_child_pid != -1 ||\n           server.module_child_pid != -1;\n}\n\n/* Return true if this instance has persistence completely turned off:\n * both RDB and AOF are disabled. */\nint allPersistenceDisabled(void) {\n    return server.saveparamslen == 0 && server.aof_state == AOF_OFF;\n}\n\n/* ======================= Cron: called every 100 ms ======================== */\n\n/* Add a sample to the operations per second array of samples. */\nvoid trackInstantaneousMetric(int metric, long long current_reading) {\n    long long t = mstime() - server.inst_metric[metric].last_sample_time;\n    long long ops = current_reading -\n                    server.inst_metric[metric].last_sample_count;\n    long long ops_sec;\n\n    ops_sec = t > 0 ? (ops*1000/t) : 0;\n\n    server.inst_metric[metric].samples[server.inst_metric[metric].idx] =\n        ops_sec;\n    server.inst_metric[metric].idx++;\n    server.inst_metric[metric].idx %= STATS_METRIC_SAMPLES;\n    server.inst_metric[metric].last_sample_time = mstime();\n    server.inst_metric[metric].last_sample_count = current_reading;\n}\n\n/* Return the mean of all the samples. */\nlong long getInstantaneousMetric(int metric) {\n    int j;\n    long long sum = 0;\n\n    for (j = 0; j < STATS_METRIC_SAMPLES; j++)\n        sum += server.inst_metric[metric].samples[j];\n    return sum / STATS_METRIC_SAMPLES;\n}\n\n/* The client query buffer is an sds.c string that can end with a lot of\n * free space not used, this function reclaims space if needed.\n *\n * The function always returns 0 as it never terminates the client. */\nint clientsCronResizeQueryBuffer(client *c) {\n    size_t querybuf_size = sdsAllocSize(c->querybuf);\n    time_t idletime = server.unixtime - c->lastinteraction;\n\n    /* There are two conditions to resize the query buffer:\n     * 1) Query buffer is > BIG_ARG and too big for latest peak.\n     * 2) Query buffer is > BIG_ARG and client is idle. */\n    if (querybuf_size > PROTO_MBULK_BIG_ARG &&\n         ((querybuf_size/(c->querybuf_peak+1)) > 2 ||\n          idletime > 2))\n    {\n        /* Only resize the query buffer if it is actually wasting\n         * at least a few kbytes. */\n        if (sdsavail(c->querybuf) > 1024*4) {\n            c->querybuf = sdsRemoveFreeSpace(c->querybuf);\n        }\n    }\n    /* Reset the peak again to capture the peak memory usage in the next\n     * cycle. */\n    c->querybuf_peak = 0;\n\n    /* Clients representing masters also use a \"pending query buffer\" that\n     * is the yet not applied part of the stream we are reading. Such buffer\n     * also needs resizing from time to time, otherwise after a very large\n     * transfer (a huge value or a big MIGRATE operation) it will keep using\n     * a lot of memory. */\n    if (c->flags & CLIENT_MASTER) {\n        /* There are two conditions to resize the pending query buffer:\n         * 1) Pending Query buffer is > LIMIT_PENDING_QUERYBUF.\n         * 2) Used length is smaller than pending_querybuf_size/2 */\n        size_t pending_querybuf_size = sdsAllocSize(c->pending_querybuf);\n        if(pending_querybuf_size > LIMIT_PENDING_QUERYBUF &&\n           sdslen(c->pending_querybuf) < (pending_querybuf_size/2))\n        {\n            c->pending_querybuf = sdsRemoveFreeSpace(c->pending_querybuf);\n        }\n    }\n    return 0;\n}\n\n/* This function is used in order to track clients using the biggest amount\n * of memory in the latest few seconds. This way we can provide such information\n * in the INFO output (clients section), without having to do an O(N) scan for\n * all the clients.\n *\n * This is how it works. We have an array of CLIENTS_PEAK_MEM_USAGE_SLOTS slots\n * where we track, for each, the biggest client output and input buffers we\n * saw in that slot. Every slot correspond to one of the latest seconds, since\n * the array is indexed by doing UNIXTIME % CLIENTS_PEAK_MEM_USAGE_SLOTS.\n *\n * When we want to know what was recently the peak memory usage, we just scan\n * such few slots searching for the maximum value. */\n#define CLIENTS_PEAK_MEM_USAGE_SLOTS 8\nsize_t ClientsPeakMemInput[CLIENTS_PEAK_MEM_USAGE_SLOTS];\nsize_t ClientsPeakMemOutput[CLIENTS_PEAK_MEM_USAGE_SLOTS];\n\nint clientsCronTrackExpansiveClients(client *c) {\n    size_t in_usage = sdsZmallocSize(c->querybuf) + c->argv_len_sum;\n    size_t out_usage = getClientOutputBufferMemoryUsage(c);\n    int i = server.unixtime % CLIENTS_PEAK_MEM_USAGE_SLOTS;\n    int zeroidx = (i+1) % CLIENTS_PEAK_MEM_USAGE_SLOTS;\n\n    /* Always zero the next sample, so that when we switch to that second, we'll\n     * only register samples that are greater in that second without considering\n     * the history of such slot.\n     *\n     * Note: our index may jump to any random position if serverCron() is not\n     * called for some reason with the normal frequency, for instance because\n     * some slow command is called taking multiple seconds to execute. In that\n     * case our array may end containing data which is potentially older\n     * than CLIENTS_PEAK_MEM_USAGE_SLOTS seconds: however this is not a problem\n     * since here we want just to track if \"recently\" there were very expansive\n     * clients from the POV of memory usage. */\n    ClientsPeakMemInput[zeroidx] = 0;\n    ClientsPeakMemOutput[zeroidx] = 0;\n\n    /* Track the biggest values observed so far in this slot. */\n    if (in_usage > ClientsPeakMemInput[i]) ClientsPeakMemInput[i] = in_usage;\n    if (out_usage > ClientsPeakMemOutput[i]) ClientsPeakMemOutput[i] = out_usage;\n\n    return 0; /* This function never terminates the client. */\n}\n\n/* Iterating all the clients in getMemoryOverheadData() is too slow and\n * in turn would make the INFO command too slow. So we perform this\n * computation incrementally and track the (not instantaneous but updated\n * to the second) total memory used by clients using clinetsCron() in\n * a more incremental way (depending on server.hz). */\nint clientsCronTrackClientsMemUsage(client *c) {\n    size_t mem = 0;\n    int type = getClientType(c);\n    mem += getClientOutputBufferMemoryUsage(c);\n    mem += sdsZmallocSize(c->querybuf);\n    mem += zmalloc_size(c);\n    mem += c->argv_len_sum;\n    if (c->argv) mem += zmalloc_size(c->argv);\n    /* Now that we have the memory used by the client, remove the old\n     * value from the old category, and add it back. */\n    server.stat_clients_type_memory[c->client_cron_last_memory_type] -=\n        c->client_cron_last_memory_usage;\n    server.stat_clients_type_memory[type] += mem;\n    /* Remember what we added and where, to remove it next time. */\n    c->client_cron_last_memory_usage = mem;\n    c->client_cron_last_memory_type = type;\n    return 0;\n}\n\n/* Return the max samples in the memory usage of clients tracked by\n * the function clientsCronTrackExpansiveClients(). */\nvoid getExpansiveClientsInfo(size_t *in_usage, size_t *out_usage) {\n    size_t i = 0, o = 0;\n    for (int j = 0; j < CLIENTS_PEAK_MEM_USAGE_SLOTS; j++) {\n        if (ClientsPeakMemInput[j] > i) i = ClientsPeakMemInput[j];\n        if (ClientsPeakMemOutput[j] > o) o = ClientsPeakMemOutput[j];\n    }\n    *in_usage = i;\n    *out_usage = o;\n}\n\n/* This function is called by serverCron() and is used in order to perform\n * operations on clients that are important to perform constantly. For instance\n * we use this function in order to disconnect clients after a timeout, including\n * clients blocked in some blocking command with a non-zero timeout.\n *\n * The function makes some effort to process all the clients every second, even\n * if this cannot be strictly guaranteed, since serverCron() may be called with\n * an actual frequency lower than server.hz in case of latency events like slow\n * commands.\n *\n * It is very important for this function, and the functions it calls, to be\n * very fast: sometimes Redis has tens of hundreds of connected clients, and the\n * default server.hz value is 10, so sometimes here we need to process thousands\n * of clients per second, turning this function into a source of latency.\n */\n#define CLIENTS_CRON_MIN_ITERATIONS 5\nvoid clientsCron(void) {\n    /* Try to process at least numclients/server.hz of clients\n     * per call. Since normally (if there are no big latency events) this\n     * function is called server.hz times per second, in the average case we\n     * process all the clients in 1 second. */\n    int numclients = listLength(server.clients);\n    int iterations = numclients/server.hz;\n    mstime_t now = mstime();\n\n    /* Process at least a few clients while we are at it, even if we need\n     * to process less than CLIENTS_CRON_MIN_ITERATIONS to meet our contract\n     * of processing each client once per second. */\n    if (iterations < CLIENTS_CRON_MIN_ITERATIONS)\n        iterations = (numclients < CLIENTS_CRON_MIN_ITERATIONS) ?\n                     numclients : CLIENTS_CRON_MIN_ITERATIONS;\n\n    while(listLength(server.clients) && iterations--) {\n        client *c;\n        listNode *head;\n\n        /* Rotate the list, take the current head, process.\n         * This way if the client must be removed from the list it's the\n         * first element and we don't incur into O(N) computation. */\n        listRotateTailToHead(server.clients);\n        head = listFirst(server.clients);\n        c = listNodeValue(head);\n        /* The following functions do different service checks on the client.\n         * The protocol is that they return non-zero if the client was\n         * terminated. */\n        if (clientsCronHandleTimeout(c,now)) continue;\n        if (clientsCronResizeQueryBuffer(c)) continue;\n        if (clientsCronTrackExpansiveClients(c)) continue;\n        if (clientsCronTrackClientsMemUsage(c)) continue;\n    }\n}\n\n/* This function handles 'background' operations we are required to do\n * incrementally in Redis databases, such as active key expiring, resizing,\n * rehashing. */\nvoid databasesCron(void) {\n    /* Expire keys by random sampling. Not required for slaves\n     * as master will synthesize DELs for us. */\n    if (server.active_expire_enabled) {\n        if (iAmMaster()) {\n            activeExpireCycle(ACTIVE_EXPIRE_CYCLE_SLOW);\n        } else {\n            expireSlaveKeys();\n        }\n    }\n\n    /* Defrag keys gradually. */\n    activeDefragCycle();\n\n    /* Perform hash tables rehashing if needed, but only if there are no\n     * other processes saving the DB on disk. Otherwise rehashing is bad\n     * as will cause a lot of copy-on-write of memory pages. */\n    if (!hasActiveChildProcess()) {\n        /* We use global counters so if we stop the computation at a given\n         * DB we'll be able to start from the successive in the next\n         * cron loop iteration. */\n        static unsigned int resize_db = 0;\n        static unsigned int rehash_db = 0;\n        int dbs_per_call = CRON_DBS_PER_CALL;\n        int j;\n\n        /* Don't test more DBs than we have. */\n        if (dbs_per_call > server.dbnum) dbs_per_call = server.dbnum;\n\n        /* Resize */\n        for (j = 0; j < dbs_per_call; j++) {\n            tryResizeHashTables(resize_db % server.dbnum);\n            resize_db++;\n        }\n\n        /* Rehash */\n        if (server.activerehashing) {\n            for (j = 0; j < dbs_per_call; j++) {\n                int work_done = incrementallyRehash(rehash_db);\n                if (work_done) {\n                    /* If the function did some work, stop here, we'll do\n                     * more at the next cron loop. */\n                    break;\n                } else {\n                    /* If this db didn't need rehash, we'll try the next one. */\n                    rehash_db++;\n                    rehash_db %= server.dbnum;\n                }\n            }\n        }\n    }\n}\n\n/* We take a cached value of the unix time in the global state because with\n * virtual memory and aging there is to store the current time in objects at\n * every object access, and accuracy is not needed. To access a global var is\n * a lot faster than calling time(NULL).\n *\n * This function should be fast because it is called at every command execution\n * in call(), so it is possible to decide if to update the daylight saving\n * info or not using the 'update_daylight_info' argument. Normally we update\n * such info only when calling this function from serverCron() but not when\n * calling it from call(). */\nvoid updateCachedTime(int update_daylight_info) {\n    server.ustime = ustime();\n    server.mstime = server.ustime / 1000;\n    server.unixtime = server.mstime / 1000;\n\n    /* To get information about daylight saving time, we need to call\n     * localtime_r and cache the result. However calling localtime_r in this\n     * context is safe since we will never fork() while here, in the main\n     * thread. The logging function will call a thread safe version of\n     * localtime that has no locks. */\n    if (update_daylight_info) {\n        struct tm tm;\n        time_t ut = server.unixtime;\n        localtime_r(&ut,&tm);\n        server.daylight_active = tm.tm_isdst;\n    }\n}\n\nvoid checkChildrenDone(void) {\n    int statloc;\n    pid_t pid;\n\n    if ((pid = wait3(&statloc,WNOHANG,NULL)) != 0) {\n        int exitcode = WEXITSTATUS(statloc);\n        int bysignal = 0;\n\n        if (WIFSIGNALED(statloc)) bysignal = WTERMSIG(statloc);\n\n        /* sigKillChildHandler catches the signal and calls exit(), but we\n         * must make sure not to flag lastbgsave_status, etc incorrectly.\n         * We could directly terminate the child process via SIGUSR1\n         * without handling it, but in this case Valgrind will log an\n         * annoying error. */\n        if (exitcode == SERVER_CHILD_NOERROR_RETVAL) {\n            bysignal = SIGUSR1;\n            exitcode = 1;\n        }\n\n        if (pid == -1) {\n            serverLog(LL_WARNING,\"wait3() returned an error: %s. \"\n                \"rdb_child_pid = %d, aof_child_pid = %d, module_child_pid = %d\",\n                strerror(errno),\n                (int) server.rdb_child_pid,\n                (int) server.aof_child_pid,\n                (int) server.module_child_pid);\n        } else if (pid == server.rdb_child_pid) {\n            backgroundSaveDoneHandler(exitcode,bysignal);\n            if (!bysignal && exitcode == 0) receiveChildInfo();\n        } else if (pid == server.aof_child_pid) {\n            backgroundRewriteDoneHandler(exitcode,bysignal);\n            if (!bysignal && exitcode == 0) receiveChildInfo();\n        } else if (pid == server.module_child_pid) {\n            ModuleForkDoneHandler(exitcode,bysignal);\n            if (!bysignal && exitcode == 0) receiveChildInfo();\n        } else {\n            if (!ldbRemoveChild(pid)) {\n                serverLog(LL_WARNING,\n                    \"Warning, detected child with unmatched pid: %ld\",\n                    (long)pid);\n            }\n        }\n        updateDictResizePolicy();\n        closeChildInfoPipe();\n    }\n}\n\n/* This is our timer interrupt, called server.hz times per second.\n * Here is where we do a number of things that need to be done asynchronously.\n * For instance:\n *\n * - Active expired keys collection (it is also performed in a lazy way on\n *   lookup).\n * - Software watchdog.\n * - Update some statistic.\n * - Incremental rehashing of the DBs hash tables.\n * - Triggering BGSAVE / AOF rewrite, and handling of terminated children.\n * - Clients timeout of different kinds.\n * - Replication reconnection.\n * - Many more...\n *\n * Everything directly called here will be called server.hz times per second,\n * so in order to throttle execution of things we want to do less frequently\n * a macro is used: run_with_period(milliseconds) { .... }\n */\n\nint serverCron(struct aeEventLoop *eventLoop, long long id, void *clientData) {\n    int j;\n    UNUSED(eventLoop);\n    UNUSED(id);\n    UNUSED(clientData);\n\n    /* Software watchdog: deliver the SIGALRM that will reach the signal\n     * handler if we don't return here fast enough. */\n    if (server.watchdog_period) watchdogScheduleSignal(server.watchdog_period);\n\n    /* Update the time cache. */\n    updateCachedTime(1);\n\n    server.hz = server.config_hz;\n    /* Adapt the server.hz value to the number of configured clients. If we have\n     * many clients, we want to call serverCron() with an higher frequency. */\n    if (server.dynamic_hz) {\n        while (listLength(server.clients) / server.hz >\n               MAX_CLIENTS_PER_CLOCK_TICK)\n        {\n            server.hz *= 2;\n            if (server.hz > CONFIG_MAX_HZ) {\n                server.hz = CONFIG_MAX_HZ;\n                break;\n            }\n        }\n    }\n\n    run_with_period(100) {\n        trackInstantaneousMetric(STATS_METRIC_COMMAND,server.stat_numcommands);\n        trackInstantaneousMetric(STATS_METRIC_NET_INPUT,\n                server.stat_net_input_bytes);\n        trackInstantaneousMetric(STATS_METRIC_NET_OUTPUT,\n                server.stat_net_output_bytes);\n    }\n\n    /* We have just LRU_BITS bits per object for LRU information.\n     * So we use an (eventually wrapping) LRU clock.\n     *\n     * Note that even if the counter wraps it's not a big problem,\n     * everything will still work but some object will appear younger\n     * to Redis. However for this to happen a given object should never be\n     * touched for all the time needed to the counter to wrap, which is\n     * not likely.\n     *\n     * Note that you can change the resolution altering the\n     * LRU_CLOCK_RESOLUTION define. */\n    server.lruclock = getLRUClock();\n\n    /* Record the max memory used since the server was started. */\n    if (zmalloc_used_memory() > server.stat_peak_memory)\n        server.stat_peak_memory = zmalloc_used_memory();\n\n    run_with_period(100) {\n        /* Sample the RSS and other metrics here since this is a relatively slow call.\n         * We must sample the zmalloc_used at the same time we take the rss, otherwise\n         * the frag ratio calculate may be off (ratio of two samples at different times) */\n        server.cron_malloc_stats.process_rss = zmalloc_get_rss();\n        server.cron_malloc_stats.zmalloc_used = zmalloc_used_memory();\n        /* Sampling the allcator info can be slow too.\n         * The fragmentation ratio it'll show is potentically more accurate\n         * it excludes other RSS pages such as: shared libraries, LUA and other non-zmalloc\n         * allocations, and allocator reserved pages that can be pursed (all not actual frag) */\n        zmalloc_get_allocator_info(&server.cron_malloc_stats.allocator_allocated,\n                                   &server.cron_malloc_stats.allocator_active,\n                                   &server.cron_malloc_stats.allocator_resident);\n        /* in case the allocator isn't providing these stats, fake them so that\n         * fragmention info still shows some (inaccurate metrics) */\n        if (!server.cron_malloc_stats.allocator_resident) {\n            /* LUA memory isn't part of zmalloc_used, but it is part of the process RSS,\n             * so we must desuct it in order to be able to calculate correct\n             * \"allocator fragmentation\" ratio */\n            size_t lua_memory = lua_gc(server.lua,LUA_GCCOUNT,0)*1024LL;\n            server.cron_malloc_stats.allocator_resident = server.cron_malloc_stats.process_rss - lua_memory;\n        }\n        if (!server.cron_malloc_stats.allocator_active)\n            server.cron_malloc_stats.allocator_active = server.cron_malloc_stats.allocator_resident;\n        if (!server.cron_malloc_stats.allocator_allocated)\n            server.cron_malloc_stats.allocator_allocated = server.cron_malloc_stats.zmalloc_used;\n    }\n\n    /* We received a SIGTERM, shutting down here in a safe way, as it is\n     * not ok doing so inside the signal handler. */\n    if (server.shutdown_asap) {\n        if (prepareForShutdown(SHUTDOWN_NOFLAGS) == C_OK) exit(0);\n        serverLog(LL_WARNING,\"SIGTERM received but errors trying to shut down the server, check the logs for more information\");\n        server.shutdown_asap = 0;\n    }\n\n    /* Show some info about non-empty databases */\n    run_with_period(5000) {\n        for (j = 0; j < server.dbnum; j++) {\n            long long size, used, vkeys;\n\n            size = dictSlots(server.db[j].dict);\n            used = dictSize(server.db[j].dict);\n            vkeys = dictSize(server.db[j].expires);\n            if (used || vkeys) {\n                serverLog(LL_VERBOSE,\"DB %d: %lld keys (%lld volatile) in %lld slots HT.\",j,used,vkeys,size);\n                /* dictPrintStats(server.dict); */\n            }\n        }\n    }\n\n    /* Show information about connected clients */\n    if (!server.sentinel_mode) {\n        run_with_period(5000) {\n            serverLog(LL_DEBUG,\n                \"%lu clients connected (%lu replicas), %zu bytes in use\",\n                listLength(server.clients)-listLength(server.slaves),\n                listLength(server.slaves),\n                zmalloc_used_memory());\n        }\n    }\n\n    /* We need to do a few operations on clients asynchronously. */\n    clientsCron();\n\n    /* Handle background operations on Redis databases. */\n    databasesCron();\n\n    /* Start a scheduled AOF rewrite if this was requested by the user while\n     * a BGSAVE was in progress. */\n    if (!hasActiveChildProcess() &&\n        server.aof_rewrite_scheduled)\n    {\n        rewriteAppendOnlyFileBackground();\n    }\n\n    /* Check if a background saving or AOF rewrite in progress terminated. */\n    if (hasActiveChildProcess() || ldbPendingChildren())\n    {\n        checkChildrenDone();\n    } else {\n        /* If there is not a background saving/rewrite in progress check if\n         * we have to save/rewrite now. */\n        for (j = 0; j < server.saveparamslen; j++) {\n            struct saveparam *sp = server.saveparams+j;\n\n            /* Save if we reached the given amount of changes,\n             * the given amount of seconds, and if the latest bgsave was\n             * successful or if, in case of an error, at least\n             * CONFIG_BGSAVE_RETRY_DELAY seconds already elapsed. */\n            if (server.dirty >= sp->changes &&\n                server.unixtime-server.lastsave > sp->seconds &&\n                (server.unixtime-server.lastbgsave_try >\n                 CONFIG_BGSAVE_RETRY_DELAY ||\n                 server.lastbgsave_status == C_OK))\n            {\n                serverLog(LL_NOTICE,\"%d changes in %d seconds. Saving...\",\n                    sp->changes, (int)sp->seconds);\n                rdbSaveInfo rsi, *rsiptr;\n                rsiptr = rdbPopulateSaveInfo(&rsi);\n                rdbSaveBackground(server.rdb_filename,rsiptr);\n                break;\n            }\n        }\n\n        /* Trigger an AOF rewrite if needed. */\n        if (server.aof_state == AOF_ON &&\n            !hasActiveChildProcess() &&\n            server.aof_rewrite_perc &&\n            server.aof_current_size > server.aof_rewrite_min_size)\n        {\n            long long base = server.aof_rewrite_base_size ?\n                server.aof_rewrite_base_size : 1;\n            long long growth = (server.aof_current_size*100/base) - 100;\n            if (growth >= server.aof_rewrite_perc) {\n                serverLog(LL_NOTICE,\"Starting automatic rewriting of AOF on %lld%% growth\",growth);\n                rewriteAppendOnlyFileBackground();\n            }\n        }\n    }\n    /* Just for the sake of defensive programming, to avoid forgeting to\n     * call this function when need. */\n    updateDictResizePolicy();\n\n\n    /* AOF postponed flush: Try at every cron cycle if the slow fsync\n     * completed. */\n    if (server.aof_flush_postponed_start) flushAppendOnlyFile(0);\n\n    /* AOF write errors: in this case we have a buffer to flush as well and\n     * clear the AOF error in case of success to make the DB writable again,\n     * however to try every second is enough in case of 'hz' is set to\n     * a higher frequency. */\n    run_with_period(1000) {\n        if (server.aof_last_write_status == C_ERR)\n            flushAppendOnlyFile(0);\n    }\n\n    /* Clear the paused clients flag if needed. */\n    clientsArePaused(); /* Don't check return value, just use the side effect.*/\n\n    /* Replication cron function -- used to reconnect to master,\n     * detect transfer failures, start background RDB transfers and so forth. */\n    run_with_period(1000) replicationCron();\n\n    /* Run the Redis Cluster cron. */\n    run_with_period(100) {\n        if (server.cluster_enabled) clusterCron();\n    }\n\n    /* Run the Sentinel timer if we are in sentinel mode. */\n    if (server.sentinel_mode) sentinelTimer();\n\n    /* Cleanup expired MIGRATE cached sockets. */\n    run_with_period(1000) {\n        migrateCloseTimedoutSockets();\n    }\n\n    /* Stop the I/O threads if we don't have enough pending work. */\n    stopThreadedIOIfNeeded();\n\n    /* Resize tracking keys table if needed. This is also done at every\n     * command execution, but we want to be sure that if the last command\n     * executed changes the value via CONFIG SET, the server will perform\n     * the operation even if completely idle. */\n    if (server.tracking_clients) trackingLimitUsedSlots();\n\n    /* Start a scheduled BGSAVE if the corresponding flag is set. This is\n     * useful when we are forced to postpone a BGSAVE because an AOF\n     * rewrite is in progress.\n     *\n     * Note: this code must be after the replicationCron() call above so\n     * make sure when refactoring this file to keep this order. This is useful\n     * because we want to give priority to RDB savings for replication. */\n    if (!hasActiveChildProcess() &&\n        server.rdb_bgsave_scheduled &&\n        (server.unixtime-server.lastbgsave_try > CONFIG_BGSAVE_RETRY_DELAY ||\n         server.lastbgsave_status == C_OK))\n    {\n        rdbSaveInfo rsi, *rsiptr;\n        rsiptr = rdbPopulateSaveInfo(&rsi);\n        if (rdbSaveBackground(server.rdb_filename,rsiptr) == C_OK)\n            server.rdb_bgsave_scheduled = 0;\n    }\n\n    /* Fire the cron loop modules event. */\n    RedisModuleCronLoopV1 ei = {REDISMODULE_CRON_LOOP_VERSION,server.hz};\n    moduleFireServerEvent(REDISMODULE_EVENT_CRON_LOOP,\n                          0,\n                          &ei);\n\n    server.cronloops++;\n    return 1000/server.hz;\n}\n\nextern int ProcessingEventsWhileBlocked;\n\n/* This function gets called every time Redis is entering the\n * main loop of the event driven library, that is, before to sleep\n * for ready file descriptors.\n *\n * Note: This function is (currently) called from two functions:\n * 1. aeMain - The main server loop\n * 2. processEventsWhileBlocked - Process clients during RDB/AOF load\n *\n * If it was called from processEventsWhileBlocked we don't want\n * to perform all actions (For example, we don't want to expire\n * keys), but we do need to perform some actions.\n *\n * The most important is freeClientsInAsyncFreeQueue but we also\n * call some other low-risk functions. */\nvoid beforeSleep(struct aeEventLoop *eventLoop) {\n    UNUSED(eventLoop);\n\n    size_t zmalloc_used = zmalloc_used_memory();\n    if (zmalloc_used > server.stat_peak_memory)\n        server.stat_peak_memory = zmalloc_used;\n\n    /* Just call a subset of vital functions in case we are re-entering\n     * the event loop from processEventsWhileBlocked(). Note that in this\n     * case we keep track of the number of events we are processing, since\n     * processEventsWhileBlocked() wants to stop ASAP if there are no longer\n     * events to handle. */\n    if (ProcessingEventsWhileBlocked) {\n        uint64_t processed = 0;\n        processed += handleClientsWithPendingReadsUsingThreads();\n        processed += tlsProcessPendingData();\n        processed += handleClientsWithPendingWrites();\n        processed += freeClientsInAsyncFreeQueue();\n        server.events_processed_while_blocked += processed;\n        return;\n    }\n\n    /* Handle precise timeouts of blocked clients. */\n    handleBlockedClientsTimeout();\n\n    /* We should handle pending reads clients ASAP after event loop. */\n    handleClientsWithPendingReadsUsingThreads();\n\n    /* Handle TLS pending data. (must be done before flushAppendOnlyFile) */\n    tlsProcessPendingData();\n\n    /* If tls still has pending unread data don't sleep at all. */\n    aeSetDontWait(server.el, tlsHasPendingData());\n\n    /* Call the Redis Cluster before sleep function. Note that this function\n     * may change the state of Redis Cluster (from ok to fail or vice versa),\n     * so it's a good idea to call it before serving the unblocked clients\n     * later in this function. */\n    if (server.cluster_enabled) clusterBeforeSleep();\n\n    /* Run a fast expire cycle (the called function will return\n     * ASAP if a fast cycle is not needed). */\n    if (server.active_expire_enabled && server.masterhost == NULL)\n        activeExpireCycle(ACTIVE_EXPIRE_CYCLE_FAST);\n\n    /* Unblock all the clients blocked for synchronous replication\n     * in WAIT. */\n    if (listLength(server.clients_waiting_acks))\n        processClientsWaitingReplicas();\n\n    /* Check if there are clients unblocked by modules that implement\n     * blocking commands. */\n    if (moduleCount()) moduleHandleBlockedClients();\n\n    /* Try to process pending commands for clients that were just unblocked. */\n    if (listLength(server.unblocked_clients))\n        processUnblockedClients();\n\n    /* Send all the slaves an ACK request if at least one client blocked\n     * during the previous event loop iteration. Note that we do this after\n     * processUnblockedClients(), so if there are multiple pipelined WAITs\n     * and the just unblocked WAIT gets blocked again, we don't have to wait\n     * a server cron cycle in absence of other event loop events. See #6623. */\n    if (server.get_ack_from_slaves) {\n        robj *argv[3];\n\n        argv[0] = createStringObject(\"REPLCONF\",8);\n        argv[1] = createStringObject(\"GETACK\",6);\n        argv[2] = createStringObject(\"*\",1); /* Not used argument. */\n        replicationFeedSlaves(server.slaves, server.slaveseldb, argv, 3);\n        decrRefCount(argv[0]);\n        decrRefCount(argv[1]);\n        decrRefCount(argv[2]);\n        server.get_ack_from_slaves = 0;\n    }\n\n    /* Send the invalidation messages to clients participating to the\n     * client side caching protocol in broadcasting (BCAST) mode. */\n    trackingBroadcastInvalidationMessages();\n\n    /* Write the AOF buffer on disk */\n    flushAppendOnlyFile(0);\n\n    /* Handle writes with pending output buffers. */\n    handleClientsWithPendingWritesUsingThreads();\n\n    /* Close clients that need to be closed asynchronous */\n    freeClientsInAsyncFreeQueue();\n\n    /* Try to process blocked clients every once in while. Example: A module\n     * calls RM_SignalKeyAsReady from within a timer callback (So we don't\n     * visit processCommand() at all). */\n    handleClientsBlockedOnKeys();\n\n    /* Before we are going to sleep, let the threads access the dataset by\n     * releasing the GIL. Redis main thread will not touch anything at this\n     * time. */\n    if (moduleCount()) moduleReleaseGIL();\n\n    /* Do NOT add anything below moduleReleaseGIL !!! */\n}\n\n/* This function is called immediately after the event loop multiplexing\n * API returned, and the control is going to soon return to Redis by invoking\n * the different events callbacks. */\nvoid afterSleep(struct aeEventLoop *eventLoop) {\n    UNUSED(eventLoop);\n\n    /* Do NOT add anything above moduleAcquireGIL !!! */\n\n    /* Aquire the modules GIL so that their threads won't touch anything. */\n    if (!ProcessingEventsWhileBlocked) {\n        if (moduleCount()) moduleAcquireGIL();\n    }\n}\n\n/* =========================== Server initialization ======================== */\n\nvoid createSharedObjects(void) {\n    int j;\n\n    shared.crlf = createObject(OBJ_STRING,sdsnew(\"\\r\\n\"));\n    shared.ok = createObject(OBJ_STRING,sdsnew(\"+OK\\r\\n\"));\n    shared.err = createObject(OBJ_STRING,sdsnew(\"-ERR\\r\\n\"));\n    shared.emptybulk = createObject(OBJ_STRING,sdsnew(\"$0\\r\\n\\r\\n\"));\n    shared.czero = createObject(OBJ_STRING,sdsnew(\":0\\r\\n\"));\n    shared.cone = createObject(OBJ_STRING,sdsnew(\":1\\r\\n\"));\n    shared.emptyarray = createObject(OBJ_STRING,sdsnew(\"*0\\r\\n\"));\n    shared.pong = createObject(OBJ_STRING,sdsnew(\"+PONG\\r\\n\"));\n    shared.queued = createObject(OBJ_STRING,sdsnew(\"+QUEUED\\r\\n\"));\n    shared.emptyscan = createObject(OBJ_STRING,sdsnew(\"*2\\r\\n$1\\r\\n0\\r\\n*0\\r\\n\"));\n    shared.wrongtypeerr = createObject(OBJ_STRING,sdsnew(\n        \"-WRONGTYPE Operation against a key holding the wrong kind of value\\r\\n\"));\n    shared.nokeyerr = createObject(OBJ_STRING,sdsnew(\n        \"-ERR no such key\\r\\n\"));\n    shared.syntaxerr = createObject(OBJ_STRING,sdsnew(\n        \"-ERR syntax error\\r\\n\"));\n    shared.sameobjecterr = createObject(OBJ_STRING,sdsnew(\n        \"-ERR source and destination objects are the same\\r\\n\"));\n    shared.outofrangeerr = createObject(OBJ_STRING,sdsnew(\n        \"-ERR index out of range\\r\\n\"));\n    shared.noscripterr = createObject(OBJ_STRING,sdsnew(\n        \"-NOSCRIPT No matching script. Please use EVAL.\\r\\n\"));\n    shared.loadingerr = createObject(OBJ_STRING,sdsnew(\n        \"-LOADING Redis is loading the dataset in memory\\r\\n\"));\n    shared.slowscripterr = createObject(OBJ_STRING,sdsnew(\n        \"-BUSY Redis is busy running a script. You can only call SCRIPT KILL or SHUTDOWN NOSAVE.\\r\\n\"));\n    shared.masterdownerr = createObject(OBJ_STRING,sdsnew(\n        \"-MASTERDOWN Link with MASTER is down and replica-serve-stale-data is set to 'no'.\\r\\n\"));\n    shared.bgsaveerr = createObject(OBJ_STRING,sdsnew(\n        \"-MISCONF Redis is configured to save RDB snapshots, but it is currently not able to persist on disk. Commands that may modify the data set are disabled, because this instance is configured to report errors during writes if RDB snapshotting fails (stop-writes-on-bgsave-error option). Please check the Redis logs for details about the RDB error.\\r\\n\"));\n    shared.roslaveerr = createObject(OBJ_STRING,sdsnew(\n        \"-READONLY You can't write against a read only replica.\\r\\n\"));\n    shared.noautherr = createObject(OBJ_STRING,sdsnew(\n        \"-NOAUTH Authentication required.\\r\\n\"));\n    shared.oomerr = createObject(OBJ_STRING,sdsnew(\n        \"-OOM command not allowed when used memory > 'maxmemory'.\\r\\n\"));\n    shared.execaborterr = createObject(OBJ_STRING,sdsnew(\n        \"-EXECABORT Transaction discarded because of previous errors.\\r\\n\"));\n    shared.noreplicaserr = createObject(OBJ_STRING,sdsnew(\n        \"-NOREPLICAS Not enough good replicas to write.\\r\\n\"));\n    shared.busykeyerr = createObject(OBJ_STRING,sdsnew(\n        \"-BUSYKEY Target key name already exists.\\r\\n\"));\n    shared.space = createObject(OBJ_STRING,sdsnew(\" \"));\n    shared.colon = createObject(OBJ_STRING,sdsnew(\":\"));\n    shared.plus = createObject(OBJ_STRING,sdsnew(\"+\"));\n\n    /* The shared NULL depends on the protocol version. */\n    shared.null[0] = NULL;\n    shared.null[1] = NULL;\n    shared.null[2] = createObject(OBJ_STRING,sdsnew(\"$-1\\r\\n\"));\n    shared.null[3] = createObject(OBJ_STRING,sdsnew(\"_\\r\\n\"));\n\n    shared.nullarray[0] = NULL;\n    shared.nullarray[1] = NULL;\n    shared.nullarray[2] = createObject(OBJ_STRING,sdsnew(\"*-1\\r\\n\"));\n    shared.nullarray[3] = createObject(OBJ_STRING,sdsnew(\"_\\r\\n\"));\n\n    shared.emptymap[0] = NULL;\n    shared.emptymap[1] = NULL;\n    shared.emptymap[2] = createObject(OBJ_STRING,sdsnew(\"*0\\r\\n\"));\n    shared.emptymap[3] = createObject(OBJ_STRING,sdsnew(\"%0\\r\\n\"));\n\n    shared.emptyset[0] = NULL;\n    shared.emptyset[1] = NULL;\n    shared.emptyset[2] = createObject(OBJ_STRING,sdsnew(\"*0\\r\\n\"));\n    shared.emptyset[3] = createObject(OBJ_STRING,sdsnew(\"~0\\r\\n\"));\n\n    for (j = 0; j < PROTO_SHARED_SELECT_CMDS; j++) {\n        char dictid_str[64];\n        int dictid_len;\n\n        dictid_len = ll2string(dictid_str,sizeof(dictid_str),j);\n        shared.select[j] = createObject(OBJ_STRING,\n            sdscatprintf(sdsempty(),\n                \"*2\\r\\n$6\\r\\nSELECT\\r\\n$%d\\r\\n%s\\r\\n\",\n                dictid_len, dictid_str));\n    }\n    shared.messagebulk = createStringObject(\"$7\\r\\nmessage\\r\\n\",13);\n    shared.pmessagebulk = createStringObject(\"$8\\r\\npmessage\\r\\n\",14);\n    shared.subscribebulk = createStringObject(\"$9\\r\\nsubscribe\\r\\n\",15);\n    shared.unsubscribebulk = createStringObject(\"$11\\r\\nunsubscribe\\r\\n\",18);\n    shared.psubscribebulk = createStringObject(\"$10\\r\\npsubscribe\\r\\n\",17);\n    shared.punsubscribebulk = createStringObject(\"$12\\r\\npunsubscribe\\r\\n\",19);\n    shared.del = createStringObject(\"DEL\",3);\n    shared.unlink = createStringObject(\"UNLINK\",6);\n    shared.rpop = createStringObject(\"RPOP\",4);\n    shared.lpop = createStringObject(\"LPOP\",4);\n    shared.lpush = createStringObject(\"LPUSH\",5);\n    shared.rpoplpush = createStringObject(\"RPOPLPUSH\",9);\n    shared.zpopmin = createStringObject(\"ZPOPMIN\",7);\n    shared.zpopmax = createStringObject(\"ZPOPMAX\",7);\n    shared.multi = createStringObject(\"MULTI\",5);\n    shared.exec = createStringObject(\"EXEC\",4);\n    for (j = 0; j < OBJ_SHARED_INTEGERS; j++) {\n        shared.integers[j] =\n            makeObjectShared(createObject(OBJ_STRING,(void*)(long)j));\n        shared.integers[j]->encoding = OBJ_ENCODING_INT;\n    }\n    for (j = 0; j < OBJ_SHARED_BULKHDR_LEN; j++) {\n        shared.mbulkhdr[j] = createObject(OBJ_STRING,\n            sdscatprintf(sdsempty(),\"*%d\\r\\n\",j));\n        shared.bulkhdr[j] = createObject(OBJ_STRING,\n            sdscatprintf(sdsempty(),\"$%d\\r\\n\",j));\n    }\n    /* The following two shared objects, minstring and maxstrings, are not\n     * actually used for their value but as a special object meaning\n     * respectively the minimum possible string and the maximum possible\n     * string in string comparisons for the ZRANGEBYLEX command. */\n    shared.minstring = sdsnew(\"minstring\");\n    shared.maxstring = sdsnew(\"maxstring\");\n}\n\nvoid initServerConfig(void) {\n    int j;\n\n    updateCachedTime(1);\n    getRandomHexChars(server.runid,CONFIG_RUN_ID_SIZE);\n    server.runid[CONFIG_RUN_ID_SIZE] = '\\0';\n    changeReplicationId();\n    clearReplicationId2();\n    server.hz = CONFIG_DEFAULT_HZ; /* Initialize it ASAP, even if it may get\n                                      updated later after loading the config.\n                                      This value may be used before the server\n                                      is initialized. */\n    server.timezone = getTimeZone(); /* Initialized by tzset(). */\n    server.configfile = NULL;\n    server.executable = NULL;\n    server.arch_bits = (sizeof(long) == 8) ? 64 : 32;\n    server.bindaddr_count = 0;\n    server.unixsocketperm = CONFIG_DEFAULT_UNIX_SOCKET_PERM;\n    server.ipfd_count = 0;\n    server.tlsfd_count = 0;\n    server.sofd = -1;\n    server.active_expire_enabled = 1;\n    server.client_max_querybuf_len = PROTO_MAX_QUERYBUF_LEN;\n    server.saveparams = NULL;\n    server.loading = 0;\n    server.logfile = zstrdup(CONFIG_DEFAULT_LOGFILE);\n    server.aof_state = AOF_OFF;\n    server.aof_rewrite_base_size = 0;\n    server.aof_rewrite_scheduled = 0;\n    server.aof_flush_sleep = 0;\n    server.aof_last_fsync = time(NULL);\n    server.aof_rewrite_time_last = -1;\n    server.aof_rewrite_time_start = -1;\n    server.aof_lastbgrewrite_status = C_OK;\n    server.aof_delayed_fsync = 0;\n    server.aof_fd = -1;\n    server.aof_selected_db = -1; /* Make sure the first time will not match */\n    server.aof_flush_postponed_start = 0;\n    server.pidfile = NULL;\n    server.active_defrag_running = 0;\n    server.notify_keyspace_events = 0;\n    server.blocked_clients = 0;\n    memset(server.blocked_clients_by_type,0,\n           sizeof(server.blocked_clients_by_type));\n    server.shutdown_asap = 0;\n    server.cluster_configfile = zstrdup(CONFIG_DEFAULT_CLUSTER_CONFIG_FILE);\n    server.cluster_module_flags = CLUSTER_MODULE_FLAG_NONE;\n    server.migrate_cached_sockets = dictCreate(&migrateCacheDictType,NULL);\n    server.next_client_id = 1; /* Client IDs, start from 1 .*/\n    server.loading_process_events_interval_bytes = (1024*1024*2);\n\n    server.lruclock = getLRUClock();\n    resetServerSaveParams();\n\n    appendServerSaveParams(60*60,1);  /* save after 1 hour and 1 change */\n    appendServerSaveParams(300,100);  /* save after 5 minutes and 100 changes */\n    appendServerSaveParams(60,10000); /* save after 1 minute and 10000 changes */\n\n    /* Replication related */\n    server.masterauth = NULL;\n    server.masterhost = NULL;\n    server.masterport = 6379;\n    server.master = NULL;\n    server.cached_master = NULL;\n    server.master_initial_offset = -1;\n    server.repl_state = REPL_STATE_NONE;\n    server.repl_transfer_tmpfile = NULL;\n    server.repl_transfer_fd = -1;\n    server.repl_transfer_s = NULL;\n    server.repl_syncio_timeout = CONFIG_REPL_SYNCIO_TIMEOUT;\n    server.repl_down_since = 0; /* Never connected, repl is down since EVER. */\n    server.master_repl_offset = 0;\n\n    /* Replication partial resync backlog */\n    server.repl_backlog = NULL;\n    server.repl_backlog_histlen = 0;\n    server.repl_backlog_idx = 0;\n    server.repl_backlog_off = 0;\n    server.repl_no_slaves_since = time(NULL);\n\n    /* Client output buffer limits */\n    for (j = 0; j < CLIENT_TYPE_OBUF_COUNT; j++)\n        server.client_obuf_limits[j] = clientBufferLimitsDefaults[j];\n\n    /* Linux OOM Score config */\n    for (j = 0; j < CONFIG_OOM_COUNT; j++)\n        server.oom_score_adj_values[j] = configOOMScoreAdjValuesDefaults[j];\n\n    /* Double constants initialization */\n    R_Zero = 0.0;\n    R_PosInf = 1.0/R_Zero;\n    R_NegInf = -1.0/R_Zero;\n    R_Nan = R_Zero/R_Zero;\n\n    /* Command table -- we initialize it here as it is part of the\n     * initial configuration, since command names may be changed via\n     * redis.conf using the rename-command directive. */\n    server.commands = dictCreate(&commandTableDictType,NULL);\n    server.orig_commands = dictCreate(&commandTableDictType,NULL);\n    populateCommandTable();\n    server.delCommand = lookupCommandByCString(\"del\");\n    server.multiCommand = lookupCommandByCString(\"multi\");\n    server.lpushCommand = lookupCommandByCString(\"lpush\");\n    server.lpopCommand = lookupCommandByCString(\"lpop\");\n    server.rpopCommand = lookupCommandByCString(\"rpop\");\n    server.zpopminCommand = lookupCommandByCString(\"zpopmin\");\n    server.zpopmaxCommand = lookupCommandByCString(\"zpopmax\");\n    server.sremCommand = lookupCommandByCString(\"srem\");\n    server.execCommand = lookupCommandByCString(\"exec\");\n    server.expireCommand = lookupCommandByCString(\"expire\");\n    server.pexpireCommand = lookupCommandByCString(\"pexpire\");\n    server.xclaimCommand = lookupCommandByCString(\"xclaim\");\n    server.xgroupCommand = lookupCommandByCString(\"xgroup\");\n    server.rpoplpushCommand = lookupCommandByCString(\"rpoplpush\");\n\n    /* Debugging */\n    server.assert_failed = \"<no assertion failed>\";\n    server.assert_file = \"<no file>\";\n    server.assert_line = 0;\n    server.bug_report_start = 0;\n    server.watchdog_period = 0;\n\n    /* By default we want scripts to be always replicated by effects\n     * (single commands executed by the script), and not by sending the\n     * script to the slave / AOF. This is the new way starting from\n     * Redis 5. However it is possible to revert it via redis.conf. */\n    server.lua_always_replicate_commands = 1;\n\n    initConfigValues();\n}\n\nextern char **environ;\n\n/* Restart the server, executing the same executable that started this\n * instance, with the same arguments and configuration file.\n *\n * The function is designed to directly call execve() so that the new\n * server instance will retain the PID of the previous one.\n *\n * The list of flags, that may be bitwise ORed together, alter the\n * behavior of this function:\n *\n * RESTART_SERVER_NONE              No flags.\n * RESTART_SERVER_GRACEFULLY        Do a proper shutdown before restarting.\n * RESTART_SERVER_CONFIG_REWRITE    Rewrite the config file before restarting.\n *\n * On success the function does not return, because the process turns into\n * a different process. On error C_ERR is returned. */\nint restartServer(int flags, mstime_t delay) {\n    int j;\n\n    /* Check if we still have accesses to the executable that started this\n     * server instance. */\n    if (access(server.executable,X_OK) == -1) {\n        serverLog(LL_WARNING,\"Can't restart: this process has no \"\n                             \"permissions to execute %s\", server.executable);\n        return C_ERR;\n    }\n\n    /* Config rewriting. */\n    if (flags & RESTART_SERVER_CONFIG_REWRITE &&\n        server.configfile &&\n        rewriteConfig(server.configfile, 0) == -1)\n    {\n        serverLog(LL_WARNING,\"Can't restart: configuration rewrite process \"\n                             \"failed\");\n        return C_ERR;\n    }\n\n    /* Perform a proper shutdown. */\n    if (flags & RESTART_SERVER_GRACEFULLY &&\n        prepareForShutdown(SHUTDOWN_NOFLAGS) != C_OK)\n    {\n        serverLog(LL_WARNING,\"Can't restart: error preparing for shutdown\");\n        return C_ERR;\n    }\n\n    /* Close all file descriptors, with the exception of stdin, stdout, strerr\n     * which are useful if we restart a Redis server which is not daemonized. */\n    for (j = 3; j < (int)server.maxclients + 1024; j++) {\n        /* Test the descriptor validity before closing it, otherwise\n         * Valgrind issues a warning on close(). */\n        if (fcntl(j,F_GETFD) != -1) close(j);\n    }\n\n    /* Execute the server with the original command line. */\n    if (delay) usleep(delay*1000);\n    zfree(server.exec_argv[0]);\n    server.exec_argv[0] = zstrdup(server.executable);\n    execve(server.executable,server.exec_argv,environ);\n\n    /* If an error occurred here, there is nothing we can do, but exit. */\n    _exit(1);\n\n    return C_ERR; /* Never reached. */\n}\n\nstatic void readOOMScoreAdj(void) {\n#ifdef HAVE_PROC_OOM_SCORE_ADJ\n    char buf[64];\n    int fd = open(\"/proc/self/oom_score_adj\", O_RDONLY);\n\n    if (fd < 0) return;\n    if (read(fd, buf, sizeof(buf)) > 0)\n        server.oom_score_adj_base = atoi(buf);\n    close(fd);\n#endif\n}\n\n/* This function will configure the current process's oom_score_adj according\n * to user specified configuration. This is currently implemented on Linux\n * only.\n *\n * A process_class value of -1 implies OOM_CONFIG_MASTER or OOM_CONFIG_REPLICA,\n * depending on current role.\n */\nint setOOMScoreAdj(int process_class) {\n\n    if (server.oom_score_adj == OOM_SCORE_ADJ_NO) return C_OK;\n    if (process_class == -1)\n        process_class = (server.masterhost ? CONFIG_OOM_REPLICA : CONFIG_OOM_MASTER);\n\n    serverAssert(process_class >= 0 && process_class < CONFIG_OOM_COUNT);\n\n#ifdef HAVE_PROC_OOM_SCORE_ADJ\n    int fd;\n    int val;\n    char buf[64];\n\n    val = server.oom_score_adj_values[process_class];\n    if (server.oom_score_adj == OOM_SCORE_RELATIVE)\n        val += server.oom_score_adj_base;\n    if (val > 1000) val = 1000;\n    if (val < -1000) val = -1000;\n\n    snprintf(buf, sizeof(buf) - 1, \"%d\\n\", val);\n\n    fd = open(\"/proc/self/oom_score_adj\", O_WRONLY);\n    if (fd < 0 || write(fd, buf, strlen(buf)) < 0) {\n        serverLog(LOG_WARNING, \"Unable to write oom_score_adj: %s\", strerror(errno));\n        if (fd != -1) close(fd);\n        return C_ERR;\n    }\n\n    close(fd);\n    return C_OK;\n#else\n    /* Unsupported */\n    return C_ERR;\n#endif\n}\n\n/* This function will try to raise the max number of open files accordingly to\n * the configured max number of clients. It also reserves a number of file\n * descriptors (CONFIG_MIN_RESERVED_FDS) for extra operations of\n * persistence, listening sockets, log files and so forth.\n *\n * If it will not be possible to set the limit accordingly to the configured\n * max number of clients, the function will do the reverse setting\n * server.maxclients to the value that we can actually handle. */\nvoid adjustOpenFilesLimit(void) {\n    rlim_t maxfiles = server.maxclients+CONFIG_MIN_RESERVED_FDS;\n    struct rlimit limit;\n\n    if (getrlimit(RLIMIT_NOFILE,&limit) == -1) {\n        serverLog(LL_WARNING,\"Unable to obtain the current NOFILE limit (%s), assuming 1024 and setting the max clients configuration accordingly.\",\n            strerror(errno));\n        server.maxclients = 1024-CONFIG_MIN_RESERVED_FDS;\n    } else {\n        rlim_t oldlimit = limit.rlim_cur;\n\n        /* Set the max number of files if the current limit is not enough\n         * for our needs. */\n        if (oldlimit < maxfiles) {\n            rlim_t bestlimit;\n            int setrlimit_error = 0;\n\n            /* Try to set the file limit to match 'maxfiles' or at least\n             * to the higher value supported less than maxfiles. */\n            bestlimit = maxfiles;\n            while(bestlimit > oldlimit) {\n                rlim_t decr_step = 16;\n\n                limit.rlim_cur = bestlimit;\n                limit.rlim_max = bestlimit;\n                if (setrlimit(RLIMIT_NOFILE,&limit) != -1) break;\n                setrlimit_error = errno;\n\n                /* We failed to set file limit to 'bestlimit'. Try with a\n                 * smaller limit decrementing by a few FDs per iteration. */\n                if (bestlimit < decr_step) break;\n                bestlimit -= decr_step;\n            }\n\n            /* Assume that the limit we get initially is still valid if\n             * our last try was even lower. */\n            if (bestlimit < oldlimit) bestlimit = oldlimit;\n\n            if (bestlimit < maxfiles) {\n                unsigned int old_maxclients = server.maxclients;\n                server.maxclients = bestlimit-CONFIG_MIN_RESERVED_FDS;\n                /* maxclients is unsigned so may overflow: in order\n                 * to check if maxclients is now logically less than 1\n                 * we test indirectly via bestlimit. */\n                if (bestlimit <= CONFIG_MIN_RESERVED_FDS) {\n                    serverLog(LL_WARNING,\"Your current 'ulimit -n' \"\n                        \"of %llu is not enough for the server to start. \"\n                        \"Please increase your open file limit to at least \"\n                        \"%llu. Exiting.\",\n                        (unsigned long long) oldlimit,\n                        (unsigned long long) maxfiles);\n                    exit(1);\n                }\n                serverLog(LL_WARNING,\"You requested maxclients of %d \"\n                    \"requiring at least %llu max file descriptors.\",\n                    old_maxclients,\n                    (unsigned long long) maxfiles);\n                serverLog(LL_WARNING,\"Server can't set maximum open files \"\n                    \"to %llu because of OS error: %s.\",\n                    (unsigned long long) maxfiles, strerror(setrlimit_error));\n                serverLog(LL_WARNING,\"Current maximum open files is %llu. \"\n                    \"maxclients has been reduced to %d to compensate for \"\n                    \"low ulimit. \"\n                    \"If you need higher maxclients increase 'ulimit -n'.\",\n                    (unsigned long long) bestlimit, server.maxclients);\n            } else {\n                serverLog(LL_NOTICE,\"Increased maximum number of open files \"\n                    \"to %llu (it was originally set to %llu).\",\n                    (unsigned long long) maxfiles,\n                    (unsigned long long) oldlimit);\n            }\n        }\n    }\n}\n\n/* Check that server.tcp_backlog can be actually enforced in Linux according\n * to the value of /proc/sys/net/core/somaxconn, or warn about it. */\nvoid checkTcpBacklogSettings(void) {\n#ifdef HAVE_PROC_SOMAXCONN\n    FILE *fp = fopen(\"/proc/sys/net/core/somaxconn\",\"r\");\n    char buf[1024];\n    if (!fp) return;\n    if (fgets(buf,sizeof(buf),fp) != NULL) {\n        int somaxconn = atoi(buf);\n        if (somaxconn > 0 && somaxconn < server.tcp_backlog) {\n            serverLog(LL_WARNING,\"WARNING: The TCP backlog setting of %d cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of %d.\", server.tcp_backlog, somaxconn);\n        }\n    }\n    fclose(fp);\n#endif\n}\n\n/* Initialize a set of file descriptors to listen to the specified 'port'\n * binding the addresses specified in the Redis server configuration.\n *\n * The listening file descriptors are stored in the integer array 'fds'\n * and their number is set in '*count'.\n *\n * The addresses to bind are specified in the global server.bindaddr array\n * and their number is server.bindaddr_count. If the server configuration\n * contains no specific addresses to bind, this function will try to\n * bind * (all addresses) for both the IPv4 and IPv6 protocols.\n *\n * On success the function returns C_OK.\n *\n * On error the function returns C_ERR. For the function to be on\n * error, at least one of the server.bindaddr addresses was\n * impossible to bind, or no bind addresses were specified in the server\n * configuration but the function is not able to bind * for at least\n * one of the IPv4 or IPv6 protocols. */\nint listenToPort(int port, int *fds, int *count) {\n    int j;\n\n    /* Force binding of 0.0.0.0 if no bind address is specified, always\n     * entering the loop if j == 0. */\n    if (server.bindaddr_count == 0) server.bindaddr[0] = NULL;\n    for (j = 0; j < server.bindaddr_count || j == 0; j++) {\n        if (server.bindaddr[j] == NULL) {\n            int unsupported = 0;\n            /* Bind * for both IPv6 and IPv4, we enter here only if\n             * server.bindaddr_count == 0. */\n            fds[*count] = anetTcp6Server(server.neterr,port,NULL,\n                server.tcp_backlog);\n            if (fds[*count] != ANET_ERR) {\n                anetNonBlock(NULL,fds[*count]);\n                (*count)++;\n            } else if (errno == EAFNOSUPPORT) {\n                unsupported++;\n                serverLog(LL_WARNING,\"Not listening to IPv6: unsupported\");\n            }\n\n            if (*count == 1 || unsupported) {\n                /* Bind the IPv4 address as well. */\n                fds[*count] = anetTcpServer(server.neterr,port,NULL,\n                    server.tcp_backlog);\n                if (fds[*count] != ANET_ERR) {\n                    anetNonBlock(NULL,fds[*count]);\n                    (*count)++;\n                } else if (errno == EAFNOSUPPORT) {\n                    unsupported++;\n                    serverLog(LL_WARNING,\"Not listening to IPv4: unsupported\");\n                }\n            }\n            /* Exit the loop if we were able to bind * on IPv4 and IPv6,\n             * otherwise fds[*count] will be ANET_ERR and we'll print an\n             * error and return to the caller with an error. */\n            if (*count + unsupported == 2) break;\n        } else if (strchr(server.bindaddr[j],':')) {\n            /* Bind IPv6 address. */\n            fds[*count] = anetTcp6Server(server.neterr,port,server.bindaddr[j],\n                server.tcp_backlog);\n        } else {\n            /* Bind IPv4 address. */\n            fds[*count] = anetTcpServer(server.neterr,port,server.bindaddr[j],\n                server.tcp_backlog);\n        }\n        if (fds[*count] == ANET_ERR) {\n            int net_errno = errno;\n            serverLog(LL_WARNING,\n                \"Could not create server TCP listening socket %s:%d: %s\",\n                server.bindaddr[j] ? server.bindaddr[j] : \"*\",\n                port, server.neterr);\n                if (net_errno == ENOPROTOOPT     || net_errno == EPROTONOSUPPORT ||\n                    net_errno == ESOCKTNOSUPPORT || net_errno == EPFNOSUPPORT ||\n                    net_errno == EAFNOSUPPORT    || net_errno == EADDRNOTAVAIL)\n                    continue;\n            return C_ERR;\n        }\n        anetNonBlock(NULL,fds[*count]);\n        (*count)++;\n    }\n    return C_OK;\n}\n\n/* Resets the stats that we expose via INFO or other means that we want\n * to reset via CONFIG RESETSTAT. The function is also used in order to\n * initialize these fields in initServer() at server startup. */\nvoid resetServerStats(void) {\n    int j;\n\n    server.stat_numcommands = 0;\n    server.stat_numconnections = 0;\n    server.stat_expiredkeys = 0;\n    server.stat_expired_stale_perc = 0;\n    server.stat_expired_time_cap_reached_count = 0;\n    server.stat_expire_cycle_time_used = 0;\n    server.stat_evictedkeys = 0;\n    server.stat_keyspace_misses = 0;\n    server.stat_keyspace_hits = 0;\n    server.stat_active_defrag_hits = 0;\n    server.stat_active_defrag_misses = 0;\n    server.stat_active_defrag_key_hits = 0;\n    server.stat_active_defrag_key_misses = 0;\n    server.stat_active_defrag_scanned = 0;\n    server.stat_fork_time = 0;\n    server.stat_fork_rate = 0;\n    server.stat_rejected_conn = 0;\n    server.stat_sync_full = 0;\n    server.stat_sync_partial_ok = 0;\n    server.stat_sync_partial_err = 0;\n    server.stat_io_reads_processed = 0;\n    server.stat_total_reads_processed = 0;\n    server.stat_io_writes_processed = 0;\n    server.stat_total_writes_processed = 0;\n    for (j = 0; j < STATS_METRIC_COUNT; j++) {\n        server.inst_metric[j].idx = 0;\n        server.inst_metric[j].last_sample_time = mstime();\n        server.inst_metric[j].last_sample_count = 0;\n        memset(server.inst_metric[j].samples,0,\n            sizeof(server.inst_metric[j].samples));\n    }\n    server.stat_net_input_bytes = 0;\n    server.stat_net_output_bytes = 0;\n    server.stat_unexpected_error_replies = 0;\n    server.aof_delayed_fsync = 0;\n}\n\n/* Make the thread killable at any time, so that kill threads functions\n * can work reliably (default cancelability type is PTHREAD_CANCEL_DEFERRED).\n * Needed for pthread_cancel used by the fast memory test used by the crash report. */\nvoid makeThreadKillable(void) {\n    pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);\n    pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);\n}\n\nvoid initServer(void) {\n    int j;\n\n    signal(SIGHUP, SIG_IGN);\n    signal(SIGPIPE, SIG_IGN);\n    setupSignalHandlers();\n    makeThreadKillable();\n\n    if (server.syslog_enabled) {\n        openlog(server.syslog_ident, LOG_PID | LOG_NDELAY | LOG_NOWAIT,\n            server.syslog_facility);\n    }\n\n    /* Initialization after setting defaults from the config system. */\n    server.aof_state = server.aof_enabled ? AOF_ON : AOF_OFF;\n    server.hz = server.config_hz;\n    server.pid = getpid();\n    server.in_fork_child = CHILD_TYPE_NONE;\n    server.main_thread_id = pthread_self();\n    server.current_client = NULL;\n    server.fixed_time_expire = 0;\n    server.clients = listCreate();\n    server.clients_index = raxNew();\n    server.clients_to_close = listCreate();\n    server.slaves = listCreate();\n    server.monitors = listCreate();\n    server.clients_pending_write = listCreate();\n    server.clients_pending_read = listCreate();\n    server.clients_timeout_table = raxNew();\n    server.slaveseldb = -1; /* Force to emit the first SELECT command. */\n    server.unblocked_clients = listCreate();\n    server.ready_keys = listCreate();\n    server.clients_waiting_acks = listCreate();\n    server.get_ack_from_slaves = 0;\n    server.clients_paused = 0;\n    server.events_processed_while_blocked = 0;\n    server.system_memory_size = zmalloc_get_memory_size();\n\n    if ((server.tls_port || server.tls_replication || server.tls_cluster)\n                && tlsConfigure(&server.tls_ctx_config) == C_ERR) {\n        serverLog(LL_WARNING, \"Failed to configure TLS. Check logs for more info.\");\n        exit(1);\n    }\n\n    createSharedObjects();\n    adjustOpenFilesLimit();\n    server.el = aeCreateEventLoop(server.maxclients+CONFIG_FDSET_INCR);\n    if (server.el == NULL) {\n        serverLog(LL_WARNING,\n            \"Failed creating the event loop. Error message: '%s'\",\n            strerror(errno));\n        exit(1);\n    }\n    server.db = zmalloc(sizeof(redisDb)*server.dbnum);\n\n    /* Open the TCP listening socket for the user commands. */\n    if (server.port != 0 &&\n        listenToPort(server.port,server.ipfd,&server.ipfd_count) == C_ERR)\n        exit(1);\n    if (server.tls_port != 0 &&\n        listenToPort(server.tls_port,server.tlsfd,&server.tlsfd_count) == C_ERR)\n        exit(1);\n\n    /* Open the listening Unix domain socket. */\n    if (server.unixsocket != NULL) {\n        unlink(server.unixsocket); /* don't care if this fails */\n        server.sofd = anetUnixServer(server.neterr,server.unixsocket,\n            server.unixsocketperm, server.tcp_backlog);\n        if (server.sofd == ANET_ERR) {\n            serverLog(LL_WARNING, \"Opening Unix socket: %s\", server.neterr);\n            exit(1);\n        }\n        anetNonBlock(NULL,server.sofd);\n    }\n\n    /* Abort if there are no listening sockets at all. */\n    if (server.ipfd_count == 0 && server.tlsfd_count == 0 && server.sofd < 0) {\n        serverLog(LL_WARNING, \"Configured to not listen anywhere, exiting.\");\n        exit(1);\n    }\n\n    /* Create the Redis databases, and initialize other internal state. */\n    for (j = 0; j < server.dbnum; j++) {\n        server.db[j].dict = dictCreate(&dbDictType,NULL);\n        server.db[j].expires = dictCreate(&keyptrDictType,NULL);\n        server.db[j].expires_cursor = 0;\n        server.db[j].blocking_keys = dictCreate(&keylistDictType,NULL);\n        server.db[j].ready_keys = dictCreate(&objectKeyPointerValueDictType,NULL);\n        server.db[j].watched_keys = dictCreate(&keylistDictType,NULL);\n        server.db[j].id = j;\n        server.db[j].avg_ttl = 0;\n        server.db[j].defrag_later = listCreate();\n        listSetFreeMethod(server.db[j].defrag_later,(void (*)(void*))sdsfree);\n    }\n    evictionPoolAlloc(); /* Initialize the LRU keys pool. */\n    server.pubsub_channels = dictCreate(&keylistDictType,NULL);\n    server.pubsub_patterns = listCreate();\n    server.pubsub_patterns_dict = dictCreate(&keylistDictType,NULL);\n    listSetFreeMethod(server.pubsub_patterns,freePubsubPattern);\n    listSetMatchMethod(server.pubsub_patterns,listMatchPubsubPattern);\n    server.cronloops = 0;\n    server.rdb_child_pid = -1;\n    server.aof_child_pid = -1;\n    server.module_child_pid = -1;\n    server.rdb_child_type = RDB_CHILD_TYPE_NONE;\n    server.rdb_pipe_conns = NULL;\n    server.rdb_pipe_numconns = 0;\n    server.rdb_pipe_numconns_writing = 0;\n    server.rdb_pipe_buff = NULL;\n    server.rdb_pipe_bufflen = 0;\n    server.rdb_bgsave_scheduled = 0;\n    server.child_info_pipe[0] = -1;\n    server.child_info_pipe[1] = -1;\n    server.child_info_data.magic = 0;\n    aofRewriteBufferReset();\n    server.aof_buf = sdsempty();\n    server.lastsave = time(NULL); /* At startup we consider the DB saved. */\n    server.lastbgsave_try = 0;    /* At startup we never tried to BGSAVE. */\n    server.rdb_save_time_last = -1;\n    server.rdb_save_time_start = -1;\n    server.dirty = 0;\n    resetServerStats();\n    /* A few stats we don't want to reset: server startup time, and peak mem. */\n    server.stat_starttime = time(NULL);\n    server.stat_peak_memory = 0;\n    server.stat_rdb_cow_bytes = 0;\n    server.stat_aof_cow_bytes = 0;\n    server.stat_module_cow_bytes = 0;\n    for (int j = 0; j < CLIENT_TYPE_COUNT; j++)\n        server.stat_clients_type_memory[j] = 0;\n    server.cron_malloc_stats.zmalloc_used = 0;\n    server.cron_malloc_stats.process_rss = 0;\n    server.cron_malloc_stats.allocator_allocated = 0;\n    server.cron_malloc_stats.allocator_active = 0;\n    server.cron_malloc_stats.allocator_resident = 0;\n    server.lastbgsave_status = C_OK;\n    server.aof_last_write_status = C_OK;\n    server.aof_last_write_errno = 0;\n    server.repl_good_slaves_count = 0;\n\n    /* Create the timer callback, this is our way to process many background\n     * operations incrementally, like clients timeout, eviction of unaccessed\n     * expired keys and so forth. */\n    if (aeCreateTimeEvent(server.el, 1, serverCron, NULL, NULL) == AE_ERR) {\n        serverPanic(\"Can't create event loop timers.\");\n        exit(1);\n    }\n\n    /* Create an event handler for accepting new connections in TCP and Unix\n     * domain sockets. */\n    for (j = 0; j < server.ipfd_count; j++) {\n        if (aeCreateFileEvent(server.el, server.ipfd[j], AE_READABLE,\n            acceptTcpHandler,NULL) == AE_ERR)\n            {\n                serverPanic(\n                    \"Unrecoverable error creating server.ipfd file event.\");\n            }\n    }\n    for (j = 0; j < server.tlsfd_count; j++) {\n        if (aeCreateFileEvent(server.el, server.tlsfd[j], AE_READABLE,\n            acceptTLSHandler,NULL) == AE_ERR)\n            {\n                serverPanic(\n                    \"Unrecoverable error creating server.tlsfd file event.\");\n            }\n    }\n    if (server.sofd > 0 && aeCreateFileEvent(server.el,server.sofd,AE_READABLE,\n        acceptUnixHandler,NULL) == AE_ERR) serverPanic(\"Unrecoverable error creating server.sofd file event.\");\n\n\n    /* Register a readable event for the pipe used to awake the event loop\n     * when a blocked client in a module needs attention. */\n    if (aeCreateFileEvent(server.el, server.module_blocked_pipe[0], AE_READABLE,\n        moduleBlockedClientPipeReadable,NULL) == AE_ERR) {\n            serverPanic(\n                \"Error registering the readable event for the module \"\n                \"blocked clients subsystem.\");\n    }\n\n    /* Register before and after sleep handlers (note this needs to be done\n     * before loading persistence since it is used by processEventsWhileBlocked. */\n    aeSetBeforeSleepProc(server.el,beforeSleep);\n    aeSetAfterSleepProc(server.el,afterSleep);\n\n    /* Open the AOF file if needed. */\n    if (server.aof_state == AOF_ON) {\n        server.aof_fd = open(server.aof_filename,\n                               O_WRONLY|O_APPEND|O_CREAT,0644);\n        if (server.aof_fd == -1) {\n            serverLog(LL_WARNING, \"Can't open the append-only file: %s\",\n                strerror(errno));\n            exit(1);\n        }\n    }\n\n    /* 32 bit instances are limited to 4GB of address space, so if there is\n     * no explicit limit in the user provided configuration we set a limit\n     * at 3 GB using maxmemory with 'noeviction' policy'. This avoids\n     * useless crashes of the Redis instance for out of memory. */\n    if (server.arch_bits == 32 && server.maxmemory == 0) {\n        serverLog(LL_WARNING,\"Warning: 32 bit instance detected but no memory limit set. Setting 3 GB maxmemory limit with 'noeviction' policy now.\");\n        server.maxmemory = 3072LL*(1024*1024); /* 3 GB */\n        server.maxmemory_policy = MAXMEMORY_NO_EVICTION;\n    }\n\n    if (server.cluster_enabled) clusterInit();\n    replicationScriptCacheInit();\n    scriptingInit(1);\n    slowlogInit();\n    latencyMonitorInit();\n}\n\n/* Some steps in server initialization need to be done last (after modules\n * are loaded).\n * Specifically, creation of threads due to a race bug in ld.so, in which\n * Thread Local Storage initialization collides with dlopen call.\n * see: https://sourceware.org/bugzilla/show_bug.cgi?id=19329 */\nvoid InitServerLast() {\n    bioInit();\n    initThreadedIO();\n    set_jemalloc_bg_thread(server.jemalloc_bg_thread);\n    server.initial_memory_usage = zmalloc_used_memory();\n}\n\n/* Parse the flags string description 'strflags' and set them to the\n * command 'c'. If the flags are all valid C_OK is returned, otherwise\n * C_ERR is returned (yet the recognized flags are set in the command). */\nint populateCommandTableParseFlags(struct redisCommand *c, char *strflags) {\n    int argc;\n    sds *argv;\n\n    /* Split the line into arguments for processing. */\n    argv = sdssplitargs(strflags,&argc);\n    if (argv == NULL) return C_ERR;\n\n    for (int j = 0; j < argc; j++) {\n        char *flag = argv[j];\n        if (!strcasecmp(flag,\"write\")) {\n            c->flags |= CMD_WRITE|CMD_CATEGORY_WRITE;\n        } else if (!strcasecmp(flag,\"read-only\")) {\n            c->flags |= CMD_READONLY|CMD_CATEGORY_READ;\n        } else if (!strcasecmp(flag,\"use-memory\")) {\n            c->flags |= CMD_DENYOOM;\n        } else if (!strcasecmp(flag,\"admin\")) {\n            c->flags |= CMD_ADMIN|CMD_CATEGORY_ADMIN|CMD_CATEGORY_DANGEROUS;\n        } else if (!strcasecmp(flag,\"pub-sub\")) {\n            c->flags |= CMD_PUBSUB|CMD_CATEGORY_PUBSUB;\n        } else if (!strcasecmp(flag,\"no-script\")) {\n            c->flags |= CMD_NOSCRIPT;\n        } else if (!strcasecmp(flag,\"random\")) {\n            c->flags |= CMD_RANDOM;\n        } else if (!strcasecmp(flag,\"to-sort\")) {\n            c->flags |= CMD_SORT_FOR_SCRIPT;\n        } else if (!strcasecmp(flag,\"ok-loading\")) {\n            c->flags |= CMD_LOADING;\n        } else if (!strcasecmp(flag,\"ok-stale\")) {\n            c->flags |= CMD_STALE;\n        } else if (!strcasecmp(flag,\"no-monitor\")) {\n            c->flags |= CMD_SKIP_MONITOR;\n        } else if (!strcasecmp(flag,\"no-slowlog\")) {\n            c->flags |= CMD_SKIP_SLOWLOG;\n        } else if (!strcasecmp(flag,\"cluster-asking\")) {\n            c->flags |= CMD_ASKING;\n        } else if (!strcasecmp(flag,\"fast\")) {\n            c->flags |= CMD_FAST | CMD_CATEGORY_FAST;\n        } else if (!strcasecmp(flag,\"no-auth\")) {\n            c->flags |= CMD_NO_AUTH;\n        } else {\n            /* Parse ACL categories here if the flag name starts with @. */\n            uint64_t catflag;\n            if (flag[0] == '@' &&\n                (catflag = ACLGetCommandCategoryFlagByName(flag+1)) != 0)\n            {\n                c->flags |= catflag;\n            } else {\n                sdsfreesplitres(argv,argc);\n                return C_ERR;\n            }\n        }\n    }\n    /* If it's not @fast is @slow in this binary world. */\n    if (!(c->flags & CMD_CATEGORY_FAST)) c->flags |= CMD_CATEGORY_SLOW;\n\n    sdsfreesplitres(argv,argc);\n    return C_OK;\n}\n\n/* Populates the Redis Command Table starting from the hard coded list\n * we have on top of server.c file. */\nvoid populateCommandTable(void) {\n    int j;\n    int numcommands = sizeof(redisCommandTable)/sizeof(struct redisCommand);\n\n    for (j = 0; j < numcommands; j++) {\n        struct redisCommand *c = redisCommandTable+j;\n        int retval1, retval2;\n\n        /* Translate the command string flags description into an actual\n         * set of flags. */\n        if (populateCommandTableParseFlags(c,c->sflags) == C_ERR)\n            serverPanic(\"Unsupported command flag\");\n\n        c->id = ACLGetCommandID(c->name); /* Assign the ID used for ACL. */\n        retval1 = dictAdd(server.commands, sdsnew(c->name), c);\n        /* Populate an additional dictionary that will be unaffected\n         * by rename-command statements in redis.conf. */\n        retval2 = dictAdd(server.orig_commands, sdsnew(c->name), c);\n        serverAssert(retval1 == DICT_OK && retval2 == DICT_OK);\n    }\n}\n\nvoid resetCommandTableStats(void) {\n    struct redisCommand *c;\n    dictEntry *de;\n    dictIterator *di;\n\n    di = dictGetSafeIterator(server.commands);\n    while((de = dictNext(di)) != NULL) {\n        c = (struct redisCommand *) dictGetVal(de);\n        c->microseconds = 0;\n        c->calls = 0;\n    }\n    dictReleaseIterator(di);\n\n}\n\n/* ========================== Redis OP Array API ============================ */\n\nvoid redisOpArrayInit(redisOpArray *oa) {\n    oa->ops = NULL;\n    oa->numops = 0;\n}\n\nint redisOpArrayAppend(redisOpArray *oa, struct redisCommand *cmd, int dbid,\n                       robj **argv, int argc, int target)\n{\n    redisOp *op;\n\n    oa->ops = zrealloc(oa->ops,sizeof(redisOp)*(oa->numops+1));\n    op = oa->ops+oa->numops;\n    op->cmd = cmd;\n    op->dbid = dbid;\n    op->argv = argv;\n    op->argc = argc;\n    op->target = target;\n    oa->numops++;\n    return oa->numops;\n}\n\nvoid redisOpArrayFree(redisOpArray *oa) {\n    while(oa->numops) {\n        int j;\n        redisOp *op;\n\n        oa->numops--;\n        op = oa->ops+oa->numops;\n        for (j = 0; j < op->argc; j++)\n            decrRefCount(op->argv[j]);\n        zfree(op->argv);\n    }\n    zfree(oa->ops);\n}\n\n/* ====================== Commands lookup and execution ===================== */\n\nstruct redisCommand *lookupCommand(sds name) {\n    return dictFetchValue(server.commands, name);\n}\n\nstruct redisCommand *lookupCommandByCString(const char *s) {\n    struct redisCommand *cmd;\n    sds name = sdsnew(s);\n\n    cmd = dictFetchValue(server.commands, name);\n    sdsfree(name);\n    return cmd;\n}\n\n/* Lookup the command in the current table, if not found also check in\n * the original table containing the original command names unaffected by\n * redis.conf rename-command statement.\n *\n * This is used by functions rewriting the argument vector such as\n * rewriteClientCommandVector() in order to set client->cmd pointer\n * correctly even if the command was renamed. */\nstruct redisCommand *lookupCommandOrOriginal(sds name) {\n    struct redisCommand *cmd = dictFetchValue(server.commands, name);\n\n    if (!cmd) cmd = dictFetchValue(server.orig_commands,name);\n    return cmd;\n}\n\n/* Propagate the specified command (in the context of the specified database id)\n * to AOF and Slaves.\n *\n * flags are an xor between:\n * + PROPAGATE_NONE (no propagation of command at all)\n * + PROPAGATE_AOF (propagate into the AOF file if is enabled)\n * + PROPAGATE_REPL (propagate into the replication link)\n *\n * This should not be used inside commands implementation since it will not\n * wrap the resulting commands in MULTI/EXEC. Use instead alsoPropagate(),\n * preventCommandPropagation(), forceCommandPropagation().\n *\n * However for functions that need to (also) propagate out of the context of a\n * command execution, for example when serving a blocked client, you\n * want to use propagate().\n */\nvoid propagate(struct redisCommand *cmd, int dbid, robj **argv, int argc,\n               int flags)\n{\n    if (server.aof_state != AOF_OFF && flags & PROPAGATE_AOF)\n        feedAppendOnlyFile(cmd,dbid,argv,argc);\n    if (flags & PROPAGATE_REPL)\n        replicationFeedSlaves(server.slaves,dbid,argv,argc);\n}\n\n/* Used inside commands to schedule the propagation of additional commands\n * after the current command is propagated to AOF / Replication.\n *\n * 'cmd' must be a pointer to the Redis command to replicate, dbid is the\n * database ID the command should be propagated into.\n * Arguments of the command to propagate are passed as an array of redis\n * objects pointers of len 'argc', using the 'argv' vector.\n *\n * The function does not take a reference to the passed 'argv' vector,\n * so it is up to the caller to release the passed argv (but it is usually\n * stack allocated).  The function automatically increments ref count of\n * passed objects, so the caller does not need to. */\nvoid alsoPropagate(struct redisCommand *cmd, int dbid, robj **argv, int argc,\n                   int target)\n{\n    robj **argvcopy;\n    int j;\n\n    if (server.loading) return; /* No propagation during loading. */\n\n    argvcopy = zmalloc(sizeof(robj*)*argc);\n    for (j = 0; j < argc; j++) {\n        argvcopy[j] = argv[j];\n        incrRefCount(argv[j]);\n    }\n    redisOpArrayAppend(&server.also_propagate,cmd,dbid,argvcopy,argc,target);\n}\n\n/* It is possible to call the function forceCommandPropagation() inside a\n * Redis command implementation in order to to force the propagation of a\n * specific command execution into AOF / Replication. */\nvoid forceCommandPropagation(client *c, int flags) {\n    if (flags & PROPAGATE_REPL) c->flags |= CLIENT_FORCE_REPL;\n    if (flags & PROPAGATE_AOF) c->flags |= CLIENT_FORCE_AOF;\n}\n\n/* Avoid that the executed command is propagated at all. This way we\n * are free to just propagate what we want using the alsoPropagate()\n * API. */\nvoid preventCommandPropagation(client *c) {\n    c->flags |= CLIENT_PREVENT_PROP;\n}\n\n/* AOF specific version of preventCommandPropagation(). */\nvoid preventCommandAOF(client *c) {\n    c->flags |= CLIENT_PREVENT_AOF_PROP;\n}\n\n/* Replication specific version of preventCommandPropagation(). */\nvoid preventCommandReplication(client *c) {\n    c->flags |= CLIENT_PREVENT_REPL_PROP;\n}\n\n/* Call() is the core of Redis execution of a command.\n *\n * The following flags can be passed:\n * CMD_CALL_NONE        No flags.\n * CMD_CALL_SLOWLOG     Check command speed and log in the slow log if needed.\n * CMD_CALL_STATS       Populate command stats.\n * CMD_CALL_PROPAGATE_AOF   Append command to AOF if it modified the dataset\n *                          or if the client flags are forcing propagation.\n * CMD_CALL_PROPAGATE_REPL  Send command to slaves if it modified the dataset\n *                          or if the client flags are forcing propagation.\n * CMD_CALL_PROPAGATE   Alias for PROPAGATE_AOF|PROPAGATE_REPL.\n * CMD_CALL_FULL        Alias for SLOWLOG|STATS|PROPAGATE.\n *\n * The exact propagation behavior depends on the client flags.\n * Specifically:\n *\n * 1. If the client flags CLIENT_FORCE_AOF or CLIENT_FORCE_REPL are set\n *    and assuming the corresponding CMD_CALL_PROPAGATE_AOF/REPL is set\n *    in the call flags, then the command is propagated even if the\n *    dataset was not affected by the command.\n * 2. If the client flags CLIENT_PREVENT_REPL_PROP or CLIENT_PREVENT_AOF_PROP\n *    are set, the propagation into AOF or to slaves is not performed even\n *    if the command modified the dataset.\n *\n * Note that regardless of the client flags, if CMD_CALL_PROPAGATE_AOF\n * or CMD_CALL_PROPAGATE_REPL are not set, then respectively AOF or\n * slaves propagation will never occur.\n *\n * Client flags are modified by the implementation of a given command\n * using the following API:\n *\n * forceCommandPropagation(client *c, int flags);\n * preventCommandPropagation(client *c);\n * preventCommandAOF(client *c);\n * preventCommandReplication(client *c);\n *\n */\nvoid call(client *c, int flags) {\n    long long dirty;\n    ustime_t start, duration;\n    int client_old_flags = c->flags;\n    struct redisCommand *real_cmd = c->cmd;\n\n    /* Send the command to clients in MONITOR mode if applicable.\n     * Administrative commands are considered too dangerous to be shown. */\n    if (listLength(server.monitors) &&\n        !server.loading &&\n        !(c->cmd->flags & (CMD_SKIP_MONITOR|CMD_ADMIN)))\n    {\n        replicationFeedMonitors(c,server.monitors,c->db->id,c->argv,c->argc);\n    }\n\n    /* Initialization: clear the flags that must be set by the command on\n     * demand, and initialize the array for additional commands propagation. */\n    c->flags &= ~(CLIENT_FORCE_AOF|CLIENT_FORCE_REPL|CLIENT_PREVENT_PROP);\n    redisOpArray prev_also_propagate = server.also_propagate;\n    redisOpArrayInit(&server.also_propagate);\n\n    /* Call the command. */\n    dirty = server.dirty;\n\n    /* Update cache time, in case we have nested calls we want to\n     * update only on the first call*/\n    if (server.fixed_time_expire++ == 0) {\n        updateCachedTime(0);\n    }\n\n    start = server.ustime;\n    c->cmd->proc(c);\n    duration = ustime()-start;\n    dirty = server.dirty-dirty;\n    if (dirty < 0) dirty = 0;\n\n    /* After executing command, we will close the client after writing entire\n     * reply if it is set 'CLIENT_CLOSE_AFTER_COMMAND' flag. */\n    if (c->flags & CLIENT_CLOSE_AFTER_COMMAND) {\n        c->flags &= ~CLIENT_CLOSE_AFTER_COMMAND;\n        c->flags |= CLIENT_CLOSE_AFTER_REPLY;\n    }\n\n    /* When EVAL is called loading the AOF we don't want commands called\n     * from Lua to go into the slowlog or to populate statistics. */\n    if (server.loading && c->flags & CLIENT_LUA)\n        flags &= ~(CMD_CALL_SLOWLOG | CMD_CALL_STATS);\n\n    /* If the caller is Lua, we want to force the EVAL caller to propagate\n     * the script if the command flag or client flag are forcing the\n     * propagation. */\n    if (c->flags & CLIENT_LUA && server.lua_caller) {\n        if (c->flags & CLIENT_FORCE_REPL)\n            server.lua_caller->flags |= CLIENT_FORCE_REPL;\n        if (c->flags & CLIENT_FORCE_AOF)\n            server.lua_caller->flags |= CLIENT_FORCE_AOF;\n    }\n\n    /* Log the command into the Slow log if needed, and populate the\n     * per-command statistics that we show in INFO commandstats. */\n    if (flags & CMD_CALL_SLOWLOG && !(c->cmd->flags & CMD_SKIP_SLOWLOG)) {\n        char *latency_event = (c->cmd->flags & CMD_FAST) ?\n                              \"fast-command\" : \"command\";\n        latencyAddSampleIfNeeded(latency_event,duration/1000);\n        slowlogPushEntryIfNeeded(c,c->argv,c->argc,duration);\n    }\n\n    if (flags & CMD_CALL_STATS) {\n        /* use the real command that was executed (cmd and lastamc) may be\n         * different, in case of MULTI-EXEC or re-written commands such as\n         * EXPIRE, GEOADD, etc. */\n        real_cmd->microseconds += duration;\n        real_cmd->calls++;\n    }\n\n    /* Propagate the command into the AOF and replication link */\n    if (flags & CMD_CALL_PROPAGATE &&\n        (c->flags & CLIENT_PREVENT_PROP) != CLIENT_PREVENT_PROP)\n    {\n        int propagate_flags = PROPAGATE_NONE;\n\n        /* Check if the command operated changes in the data set. If so\n         * set for replication / AOF propagation. */\n        if (dirty) propagate_flags |= (PROPAGATE_AOF|PROPAGATE_REPL);\n\n        /* If the client forced AOF / replication of the command, set\n         * the flags regardless of the command effects on the data set. */\n        if (c->flags & CLIENT_FORCE_REPL) propagate_flags |= PROPAGATE_REPL;\n        if (c->flags & CLIENT_FORCE_AOF) propagate_flags |= PROPAGATE_AOF;\n\n        /* However prevent AOF / replication propagation if the command\n         * implementation called preventCommandPropagation() or similar,\n         * or if we don't have the call() flags to do so. */\n        if (c->flags & CLIENT_PREVENT_REPL_PROP ||\n            !(flags & CMD_CALL_PROPAGATE_REPL))\n                propagate_flags &= ~PROPAGATE_REPL;\n        if (c->flags & CLIENT_PREVENT_AOF_PROP ||\n            !(flags & CMD_CALL_PROPAGATE_AOF))\n                propagate_flags &= ~PROPAGATE_AOF;\n\n        /* Call propagate() only if at least one of AOF / replication\n         * propagation is needed. Note that modules commands handle replication\n         * in an explicit way, so we never replicate them automatically. */\n        if (propagate_flags != PROPAGATE_NONE && !(c->cmd->flags & CMD_MODULE))\n            propagate(c->cmd,c->db->id,c->argv,c->argc,propagate_flags);\n    }\n\n    /* Restore the old replication flags, since call() can be executed\n     * recursively. */\n    c->flags &= ~(CLIENT_FORCE_AOF|CLIENT_FORCE_REPL|CLIENT_PREVENT_PROP);\n    c->flags |= client_old_flags &\n        (CLIENT_FORCE_AOF|CLIENT_FORCE_REPL|CLIENT_PREVENT_PROP);\n\n    /* Handle the alsoPropagate() API to handle commands that want to propagate\n     * multiple separated commands. Note that alsoPropagate() is not affected\n     * by CLIENT_PREVENT_PROP flag. */\n    if (server.also_propagate.numops) {\n        int j;\n        redisOp *rop;\n\n        if (flags & CMD_CALL_PROPAGATE) {\n            int multi_emitted = 0;\n            /* Wrap the commands in server.also_propagate array,\n             * but don't wrap it if we are already in MULTI context,\n             * in case the nested MULTI/EXEC.\n             *\n             * And if the array contains only one command, no need to\n             * wrap it, since the single command is atomic. */\n            if (server.also_propagate.numops > 1 &&\n                !(c->cmd->flags & CMD_MODULE) &&\n                !(c->flags & CLIENT_MULTI) &&\n                !(flags & CMD_CALL_NOWRAP))\n            {\n                execCommandPropagateMulti(c);\n                multi_emitted = 1;\n            }\n\n            for (j = 0; j < server.also_propagate.numops; j++) {\n                rop = &server.also_propagate.ops[j];\n                int target = rop->target;\n                /* Whatever the command wish is, we honor the call() flags. */\n                if (!(flags&CMD_CALL_PROPAGATE_AOF)) target &= ~PROPAGATE_AOF;\n                if (!(flags&CMD_CALL_PROPAGATE_REPL)) target &= ~PROPAGATE_REPL;\n                if (target)\n                    propagate(rop->cmd,rop->dbid,rop->argv,rop->argc,target);\n            }\n\n            if (multi_emitted) {\n                execCommandPropagateExec(c);\n            }\n        }\n        redisOpArrayFree(&server.also_propagate);\n    }\n    server.also_propagate = prev_also_propagate;\n\n    /* If the client has keys tracking enabled for client side caching,\n     * make sure to remember the keys it fetched via this command. */\n    if (c->cmd->flags & CMD_READONLY) {\n        client *caller = (c->flags & CLIENT_LUA && server.lua_caller) ?\n                            server.lua_caller : c;\n        if (caller->flags & CLIENT_TRACKING &&\n            !(caller->flags & CLIENT_TRACKING_BCAST))\n        {\n            trackingRememberKeys(caller);\n        }\n    }\n\n    server.fixed_time_expire--;\n    server.stat_numcommands++;\n\n    /* Record peak memory after each command and before the eviction that runs\n     * before the next command. */\n    size_t zmalloc_used = zmalloc_used_memory();\n    if (zmalloc_used > server.stat_peak_memory)\n        server.stat_peak_memory = zmalloc_used;\n}\n\n/* Used when a command that is ready for execution needs to be rejected, due to\n * varios pre-execution checks. it returns the appropriate error to the client.\n * If there's a transaction is flags it as dirty, and if the command is EXEC,\n * it aborts the transaction.\n * Note: 'reply' is expected to end with \\r\\n */\nvoid rejectCommand(client *c, robj *reply) {\n    flagTransaction(c);\n    if (c->cmd && c->cmd->proc == execCommand) {\n        execCommandAbort(c, reply->ptr);\n    } else {\n        /* using addReplyError* rather than addReply so that the error can be logged. */\n        addReplyErrorObject(c, reply);\n    }\n}\n\nvoid rejectCommandFormat(client *c, const char *fmt, ...) {\n    flagTransaction(c);\n    va_list ap;\n    va_start(ap,fmt);\n    sds s = sdscatvprintf(sdsempty(),fmt,ap);\n    va_end(ap);\n    /* Make sure there are no newlines in the string, otherwise invalid protocol\n     * is emitted (The args come from the user, they may contain any character). */\n    sdsmapchars(s, \"\\r\\n\", \"  \",  2);\n    if (c->cmd && c->cmd->proc == execCommand) {\n        execCommandAbort(c, s);\n    } else {\n        addReplyErrorSds(c, s);\n    }\n    sdsfree(s);\n}\n\n/* If this function gets called we already read a whole\n * command, arguments are in the client argv/argc fields.\n * processCommand() execute the command or prepare the\n * server for a bulk read from the client.\n *\n * If C_OK is returned the client is still alive and valid and\n * other operations can be performed by the caller. Otherwise\n * if C_ERR is returned the client was destroyed (i.e. after QUIT). */\nint processCommand(client *c) {\n    moduleCallCommandFilters(c);\n\n    /* The QUIT command is handled separately. Normal command procs will\n     * go through checking for replication and QUIT will cause trouble\n     * when FORCE_REPLICATION is enabled and would be implemented in\n     * a regular command proc. */\n    if (!strcasecmp(c->argv[0]->ptr,\"quit\")) {\n        addReply(c,shared.ok);\n        c->flags |= CLIENT_CLOSE_AFTER_REPLY;\n        return C_ERR;\n    }\n\n    /* Now lookup the command and check ASAP about trivial error conditions\n     * such as wrong arity, bad command name and so forth. */\n    c->cmd = c->lastcmd = lookupCommand(c->argv[0]->ptr);\n    if (!c->cmd) {\n        sds args = sdsempty();\n        int i;\n        for (i=1; i < c->argc && sdslen(args) < 128; i++)\n            args = sdscatprintf(args, \"`%.*s`, \", 128-(int)sdslen(args), (char*)c->argv[i]->ptr);\n        rejectCommandFormat(c,\"unknown command `%s`, with args beginning with: %s\",\n            (char*)c->argv[0]->ptr, args);\n        sdsfree(args);\n        return C_OK;\n    } else if ((c->cmd->arity > 0 && c->cmd->arity != c->argc) ||\n               (c->argc < -c->cmd->arity)) {\n        rejectCommandFormat(c,\"wrong number of arguments for '%s' command\",\n            c->cmd->name);\n        return C_OK;\n    }\n\n    int is_write_command = (c->cmd->flags & CMD_WRITE) ||\n                           (c->cmd->proc == execCommand && (c->mstate.cmd_flags & CMD_WRITE));\n    int is_denyoom_command = (c->cmd->flags & CMD_DENYOOM) ||\n                             (c->cmd->proc == execCommand && (c->mstate.cmd_flags & CMD_DENYOOM));\n    int is_denystale_command = !(c->cmd->flags & CMD_STALE) ||\n                               (c->cmd->proc == execCommand && (c->mstate.cmd_inv_flags & CMD_STALE));\n    int is_denyloading_command = !(c->cmd->flags & CMD_LOADING) ||\n                                 (c->cmd->proc == execCommand && (c->mstate.cmd_inv_flags & CMD_LOADING));\n\n    if (authRequired(c)) {\n        /* AUTH and HELLO and no auth commands are valid even in\n         * non-authenticated state. */\n        if (!(c->cmd->flags & CMD_NO_AUTH)) {\n            rejectCommand(c,shared.noautherr);\n            return C_OK;\n        }\n    }\n\n    /* Check if the user can run this command according to the current\n     * ACLs. */\n    int acl_keypos;\n    int acl_retval = ACLCheckCommandPerm(c,&acl_keypos);\n    if (acl_retval != ACL_OK) {\n        addACLLogEntry(c,acl_retval,acl_keypos,NULL);\n        if (acl_retval == ACL_DENIED_CMD)\n            rejectCommandFormat(c,\n                \"-NOPERM this user has no permissions to run \"\n                \"the '%s' command or its subcommand\", c->cmd->name);\n        else\n            rejectCommandFormat(c,\n                \"-NOPERM this user has no permissions to access \"\n                \"one of the keys used as arguments\");\n        return C_OK;\n    }\n\n    /* If cluster is enabled perform the cluster redirection here.\n     * However we don't perform the redirection if:\n     * 1) The sender of this command is our master.\n     * 2) The command has no key arguments. */\n    if (server.cluster_enabled &&\n        !(c->flags & CLIENT_MASTER) &&\n        !(c->flags & CLIENT_LUA &&\n          server.lua_caller->flags & CLIENT_MASTER) &&\n        !(c->cmd->getkeys_proc == NULL && c->cmd->firstkey == 0 &&\n          c->cmd->proc != execCommand))\n    {\n        int hashslot;\n        int error_code;\n        clusterNode *n = getNodeByQuery(c,c->cmd,c->argv,c->argc,\n                                        &hashslot,&error_code);\n        if (n == NULL || n != server.cluster->myself) {\n            if (c->cmd->proc == execCommand) {\n                discardTransaction(c);\n            } else {\n                flagTransaction(c);\n            }\n            clusterRedirectClient(c,n,hashslot,error_code);\n            return C_OK;\n        }\n    }\n\n    /* Handle the maxmemory directive.\n     *\n     * Note that we do not want to reclaim memory if we are here re-entering\n     * the event loop since there is a busy Lua script running in timeout\n     * condition, to avoid mixing the propagation of scripts with the\n     * propagation of DELs due to eviction. */\n    if (server.maxmemory && !server.lua_timedout) {\n        int out_of_memory = freeMemoryIfNeededAndSafe() == C_ERR;\n        /* freeMemoryIfNeeded may flush slave output buffers. This may result\n         * into a slave, that may be the active client, to be freed. */\n        if (server.current_client == NULL) return C_ERR;\n\n        int reject_cmd_on_oom = is_denyoom_command;\n        /* If client is in MULTI/EXEC context, queuing may consume an unlimited\n         * amount of memory, so we want to stop that.\n         * However, we never want to reject DISCARD, or even EXEC (unless it\n         * contains denied commands, in which case is_denyoom_command is already\n         * set. */\n        if (c->flags & CLIENT_MULTI &&\n            c->cmd->proc != execCommand &&\n            c->cmd->proc != discardCommand) {\n            reject_cmd_on_oom = 1;\n        }\n\n        if (out_of_memory && reject_cmd_on_oom) {\n            rejectCommand(c, shared.oomerr);\n            return C_OK;\n        }\n\n        /* Save out_of_memory result at script start, otherwise if we check OOM\n         * until first write within script, memory used by lua stack and\n         * arguments might interfere. */\n        if (c->cmd->proc == evalCommand || c->cmd->proc == evalShaCommand) {\n            server.lua_oom = out_of_memory;\n        }\n    }\n\n    /* Make sure to use a reasonable amount of memory for client side\n     * caching metadata. */\n    if (server.tracking_clients) trackingLimitUsedSlots();\n\n    /* Don't accept write commands if there are problems persisting on disk\n     * and if this is a master instance. */\n    int deny_write_type = writeCommandsDeniedByDiskError();\n    if (deny_write_type != DISK_ERROR_TYPE_NONE &&\n        server.masterhost == NULL &&\n        (is_write_command ||c->cmd->proc == pingCommand))\n    {\n        if (deny_write_type == DISK_ERROR_TYPE_RDB)\n            rejectCommand(c, shared.bgsaveerr);\n        else\n            rejectCommandFormat(c,\n                \"-MISCONF Errors writing to the AOF file: %s\",\n                strerror(server.aof_last_write_errno));\n        return C_OK;\n    }\n\n    /* Don't accept write commands if there are not enough good slaves and\n     * user configured the min-slaves-to-write option. */\n    if (server.masterhost == NULL &&\n        server.repl_min_slaves_to_write &&\n        server.repl_min_slaves_max_lag &&\n        is_write_command &&\n        server.repl_good_slaves_count < server.repl_min_slaves_to_write)\n    {\n        rejectCommand(c, shared.noreplicaserr);\n        return C_OK;\n    }\n\n    /* Don't accept write commands if this is a read only slave. But\n     * accept write commands if this is our master. */\n    if (server.masterhost && server.repl_slave_ro &&\n        !(c->flags & CLIENT_MASTER) &&\n        is_write_command)\n    {\n        rejectCommand(c, shared.roslaveerr);\n        return C_OK;\n    }\n\n    /* Only allow a subset of commands in the context of Pub/Sub if the\n     * connection is in RESP2 mode. With RESP3 there are no limits. */\n    if ((c->flags & CLIENT_PUBSUB && c->resp == 2) &&\n        c->cmd->proc != pingCommand &&\n        c->cmd->proc != subscribeCommand &&\n        c->cmd->proc != unsubscribeCommand &&\n        c->cmd->proc != psubscribeCommand &&\n        c->cmd->proc != punsubscribeCommand) {\n        rejectCommandFormat(c,\n            \"Can't execute '%s': only (P)SUBSCRIBE / \"\n            \"(P)UNSUBSCRIBE / PING / QUIT are allowed in this context\",\n            c->cmd->name);\n        return C_OK;\n    }\n\n    /* Only allow commands with flag \"t\", such as INFO, SLAVEOF and so on,\n     * when slave-serve-stale-data is no and we are a slave with a broken\n     * link with master. */\n    if (server.masterhost && server.repl_state != REPL_STATE_CONNECTED &&\n        server.repl_serve_stale_data == 0 &&\n        is_denystale_command)\n    {\n        rejectCommand(c, shared.masterdownerr);\n        return C_OK;\n    }\n\n    /* Loading DB? Return an error if the command has not the\n     * CMD_LOADING flag. */\n    if (server.loading && is_denyloading_command) {\n        rejectCommand(c, shared.loadingerr);\n        return C_OK;\n    }\n\n    /* Lua script too slow? Only allow a limited number of commands.\n     * Note that we need to allow the transactions commands, otherwise clients\n     * sending a transaction with pipelining without error checking, may have\n     * the MULTI plus a few initial commands refused, then the timeout\n     * condition resolves, and the bottom-half of the transaction gets\n     * executed, see Github PR #7022. */\n    if (server.lua_timedout &&\n          c->cmd->proc != authCommand &&\n          c->cmd->proc != helloCommand &&\n          c->cmd->proc != replconfCommand &&\n          c->cmd->proc != multiCommand &&\n          c->cmd->proc != discardCommand &&\n          c->cmd->proc != watchCommand &&\n          c->cmd->proc != unwatchCommand &&\n        !(c->cmd->proc == shutdownCommand &&\n          c->argc == 2 &&\n          tolower(((char*)c->argv[1]->ptr)[0]) == 'n') &&\n        !(c->cmd->proc == scriptCommand &&\n          c->argc == 2 &&\n          tolower(((char*)c->argv[1]->ptr)[0]) == 'k'))\n    {\n        rejectCommand(c, shared.slowscripterr);\n        return C_OK;\n    }\n\n    /* Exec the command */\n    if (c->flags & CLIENT_MULTI &&\n        c->cmd->proc != execCommand && c->cmd->proc != discardCommand &&\n        c->cmd->proc != multiCommand && c->cmd->proc != watchCommand)\n    {\n        queueMultiCommand(c);\n        addReply(c,shared.queued);\n    } else {\n        call(c,CMD_CALL_FULL);\n        c->woff = server.master_repl_offset;\n        if (listLength(server.ready_keys))\n            handleClientsBlockedOnKeys();\n    }\n    return C_OK;\n}\n\n/*================================== Shutdown =============================== */\n\n/* Close listening sockets. Also unlink the unix domain socket if\n * unlink_unix_socket is non-zero. */\nvoid closeListeningSockets(int unlink_unix_socket) {\n    int j;\n\n    for (j = 0; j < server.ipfd_count; j++) close(server.ipfd[j]);\n    for (j = 0; j < server.tlsfd_count; j++) close(server.tlsfd[j]);\n    if (server.sofd != -1) close(server.sofd);\n    if (server.cluster_enabled)\n        for (j = 0; j < server.cfd_count; j++) close(server.cfd[j]);\n    if (unlink_unix_socket && server.unixsocket) {\n        serverLog(LL_NOTICE,\"Removing the unix socket file.\");\n        unlink(server.unixsocket); /* don't care if this fails */\n    }\n}\n\nint prepareForShutdown(int flags) {\n    /* When SHUTDOWN is called while the server is loading a dataset in\n     * memory we need to make sure no attempt is performed to save\n     * the dataset on shutdown (otherwise it could overwrite the current DB\n     * with half-read data).\n     *\n     * Also when in Sentinel mode clear the SAVE flag and force NOSAVE. */\n    if (server.loading || server.sentinel_mode)\n        flags = (flags & ~SHUTDOWN_SAVE) | SHUTDOWN_NOSAVE;\n\n    int save = flags & SHUTDOWN_SAVE;\n    int nosave = flags & SHUTDOWN_NOSAVE;\n\n    serverLog(LL_WARNING,\"User requested shutdown...\");\n    if (server.supervised_mode == SUPERVISED_SYSTEMD)\n        redisCommunicateSystemd(\"STOPPING=1\\n\");\n\n    /* Kill all the Lua debugger forked sessions. */\n    ldbKillForkedSessions();\n\n    /* Kill the saving child if there is a background saving in progress.\n       We want to avoid race conditions, for instance our saving child may\n       overwrite the synchronous saving did by SHUTDOWN. */\n    if (server.rdb_child_pid != -1) {\n        serverLog(LL_WARNING,\"There is a child saving an .rdb. Killing it!\");\n        /* Note that, in killRDBChild, we call rdbRemoveTempFile that will\n         * do close fd(in order to unlink file actully) in background thread.\n         * The temp rdb file fd may won't be closed when redis exits quickly,\n         * but OS will close this fd when process exits. */\n        killRDBChild();\n    }\n\n    /* Kill module child if there is one. */\n    if (server.module_child_pid != -1) {\n        serverLog(LL_WARNING,\"There is a module fork child. Killing it!\");\n        TerminateModuleForkChild(server.module_child_pid,0);\n    }\n\n    if (server.aof_state != AOF_OFF) {\n        /* Kill the AOF saving child as the AOF we already have may be longer\n         * but contains the full dataset anyway. */\n        if (server.aof_child_pid != -1) {\n            /* If we have AOF enabled but haven't written the AOF yet, don't\n             * shutdown or else the dataset will be lost. */\n            if (server.aof_state == AOF_WAIT_REWRITE) {\n                serverLog(LL_WARNING, \"Writing initial AOF, can't exit.\");\n                return C_ERR;\n            }\n            serverLog(LL_WARNING,\n                \"There is a child rewriting the AOF. Killing it!\");\n            killAppendOnlyChild();\n        }\n        /* Append only file: flush buffers and fsync() the AOF at exit */\n        serverLog(LL_NOTICE,\"Calling fsync() on the AOF file.\");\n        flushAppendOnlyFile(1);\n        redis_fsync(server.aof_fd);\n    }\n\n    /* Create a new RDB file before exiting. */\n    if ((server.saveparamslen > 0 && !nosave) || save) {\n        serverLog(LL_NOTICE,\"Saving the final RDB snapshot before exiting.\");\n        if (server.supervised_mode == SUPERVISED_SYSTEMD)\n            redisCommunicateSystemd(\"STATUS=Saving the final RDB snapshot\\n\");\n        /* Snapshotting. Perform a SYNC SAVE and exit */\n        rdbSaveInfo rsi, *rsiptr;\n        rsiptr = rdbPopulateSaveInfo(&rsi);\n        if (rdbSave(server.rdb_filename,rsiptr) != C_OK) {\n            /* Ooops.. error saving! The best we can do is to continue\n             * operating. Note that if there was a background saving process,\n             * in the next cron() Redis will be notified that the background\n             * saving aborted, handling special stuff like slaves pending for\n             * synchronization... */\n            serverLog(LL_WARNING,\"Error trying to save the DB, can't exit.\");\n            if (server.supervised_mode == SUPERVISED_SYSTEMD)\n                redisCommunicateSystemd(\"STATUS=Error trying to save the DB, can't exit.\\n\");\n            return C_ERR;\n        }\n    }\n\n    /* Fire the shutdown modules event. */\n    moduleFireServerEvent(REDISMODULE_EVENT_SHUTDOWN,0,NULL);\n\n    /* Remove the pid file if possible and needed. */\n    if (server.daemonize || server.pidfile) {\n        serverLog(LL_NOTICE,\"Removing the pid file.\");\n        unlink(server.pidfile);\n    }\n\n    /* Best effort flush of slave output buffers, so that we hopefully\n     * send them pending writes. */\n    flushSlavesOutputBuffers();\n\n    /* Close the listening sockets. Apparently this allows faster restarts. */\n    closeListeningSockets(1);\n    serverLog(LL_WARNING,\"%s is now ready to exit, bye bye...\",\n        server.sentinel_mode ? \"Sentinel\" : \"Redis\");\n    return C_OK;\n}\n\n/*================================== Commands =============================== */\n\n/* Sometimes Redis cannot accept write commands because there is a persistence\n * error with the RDB or AOF file, and Redis is configured in order to stop\n * accepting writes in such situation. This function returns if such a\n * condition is active, and the type of the condition.\n *\n * Function return values:\n *\n * DISK_ERROR_TYPE_NONE:    No problems, we can accept writes.\n * DISK_ERROR_TYPE_AOF:     Don't accept writes: AOF errors.\n * DISK_ERROR_TYPE_RDB:     Don't accept writes: RDB errors.\n */\nint writeCommandsDeniedByDiskError(void) {\n    if (server.stop_writes_on_bgsave_err &&\n        server.saveparamslen > 0 &&\n        server.lastbgsave_status == C_ERR)\n    {\n        return DISK_ERROR_TYPE_RDB;\n    } else if (server.aof_state != AOF_OFF &&\n               server.aof_last_write_status == C_ERR)\n    {\n        return DISK_ERROR_TYPE_AOF;\n    } else {\n        return DISK_ERROR_TYPE_NONE;\n    }\n}\n\n/* The PING command. It works in a different way if the client is in\n * in Pub/Sub mode. */\nvoid pingCommand(client *c) {\n    /* The command takes zero or one arguments. */\n    if (c->argc > 2) {\n        addReplyErrorFormat(c,\"wrong number of arguments for '%s' command\",\n            c->cmd->name);\n        return;\n    }\n\n    if (c->flags & CLIENT_PUBSUB && c->resp == 2) {\n        addReply(c,shared.mbulkhdr[2]);\n        addReplyBulkCBuffer(c,\"pong\",4);\n        if (c->argc == 1)\n            addReplyBulkCBuffer(c,\"\",0);\n        else\n            addReplyBulk(c,c->argv[1]);\n    } else {\n        if (c->argc == 1)\n            addReply(c,shared.pong);\n        else\n            addReplyBulk(c,c->argv[1]);\n    }\n}\n\nvoid echoCommand(client *c) {\n    addReplyBulk(c,c->argv[1]);\n}\n\nvoid timeCommand(client *c) {\n    struct timeval tv;\n\n    /* gettimeofday() can only fail if &tv is a bad address so we\n     * don't check for errors. */\n    gettimeofday(&tv,NULL);\n    addReplyArrayLen(c,2);\n    addReplyBulkLongLong(c,tv.tv_sec);\n    addReplyBulkLongLong(c,tv.tv_usec);\n}\n\n/* Helper function for addReplyCommand() to output flags. */\nint addReplyCommandFlag(client *c, struct redisCommand *cmd, int f, char *reply) {\n    if (cmd->flags & f) {\n        addReplyStatus(c, reply);\n        return 1;\n    }\n    return 0;\n}\n\n/* Output the representation of a Redis command. Used by the COMMAND command. */\nvoid addReplyCommand(client *c, struct redisCommand *cmd) {\n    if (!cmd) {\n        addReplyNull(c);\n    } else {\n        /* We are adding: command name, arg count, flags, first, last, offset, categories */\n        addReplyArrayLen(c, 7);\n        addReplyBulkCString(c, cmd->name);\n        addReplyLongLong(c, cmd->arity);\n\n        int flagcount = 0;\n        void *flaglen = addReplyDeferredLen(c);\n        flagcount += addReplyCommandFlag(c,cmd,CMD_WRITE, \"write\");\n        flagcount += addReplyCommandFlag(c,cmd,CMD_READONLY, \"readonly\");\n        flagcount += addReplyCommandFlag(c,cmd,CMD_DENYOOM, \"denyoom\");\n        flagcount += addReplyCommandFlag(c,cmd,CMD_ADMIN, \"admin\");\n        flagcount += addReplyCommandFlag(c,cmd,CMD_PUBSUB, \"pubsub\");\n        flagcount += addReplyCommandFlag(c,cmd,CMD_NOSCRIPT, \"noscript\");\n        flagcount += addReplyCommandFlag(c,cmd,CMD_RANDOM, \"random\");\n        flagcount += addReplyCommandFlag(c,cmd,CMD_SORT_FOR_SCRIPT,\"sort_for_script\");\n        flagcount += addReplyCommandFlag(c,cmd,CMD_LOADING, \"loading\");\n        flagcount += addReplyCommandFlag(c,cmd,CMD_STALE, \"stale\");\n        flagcount += addReplyCommandFlag(c,cmd,CMD_SKIP_MONITOR, \"skip_monitor\");\n        flagcount += addReplyCommandFlag(c,cmd,CMD_SKIP_SLOWLOG, \"skip_slowlog\");\n        flagcount += addReplyCommandFlag(c,cmd,CMD_ASKING, \"asking\");\n        flagcount += addReplyCommandFlag(c,cmd,CMD_FAST, \"fast\");\n        flagcount += addReplyCommandFlag(c,cmd,CMD_NO_AUTH, \"no_auth\");\n        if ((cmd->getkeys_proc && !(cmd->flags & CMD_MODULE)) ||\n            cmd->flags & CMD_MODULE_GETKEYS)\n        {\n            addReplyStatus(c, \"movablekeys\");\n            flagcount += 1;\n        }\n        setDeferredSetLen(c, flaglen, flagcount);\n\n        addReplyLongLong(c, cmd->firstkey);\n        addReplyLongLong(c, cmd->lastkey);\n        addReplyLongLong(c, cmd->keystep);\n\n        addReplyCommandCategories(c,cmd);\n    }\n}\n\n/* COMMAND <subcommand> <args> */\nvoid commandCommand(client *c) {\n    dictIterator *di;\n    dictEntry *de;\n\n    if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,\"help\")) {\n        const char *help[] = {\n\"(no subcommand) -- Return details about all Redis commands.\",\n\"COUNT -- Return the total number of commands in this Redis server.\",\n\"GETKEYS <full-command> -- Return the keys from a full Redis command.\",\n\"INFO [command-name ...] -- Return details about multiple Redis commands.\",\nNULL\n        };\n        addReplyHelp(c, help);\n    } else if (c->argc == 1) {\n        addReplyArrayLen(c, dictSize(server.commands));\n        di = dictGetIterator(server.commands);\n        while ((de = dictNext(di)) != NULL) {\n            addReplyCommand(c, dictGetVal(de));\n        }\n        dictReleaseIterator(di);\n    } else if (!strcasecmp(c->argv[1]->ptr, \"info\")) {\n        int i;\n        addReplyArrayLen(c, c->argc-2);\n        for (i = 2; i < c->argc; i++) {\n            addReplyCommand(c, dictFetchValue(server.commands, c->argv[i]->ptr));\n        }\n    } else if (!strcasecmp(c->argv[1]->ptr, \"count\") && c->argc == 2) {\n        addReplyLongLong(c, dictSize(server.commands));\n    } else if (!strcasecmp(c->argv[1]->ptr,\"getkeys\") && c->argc >= 3) {\n        struct redisCommand *cmd = lookupCommand(c->argv[2]->ptr);\n        getKeysResult result = GETKEYS_RESULT_INIT;\n        int j;\n\n        if (!cmd) {\n            addReplyError(c,\"Invalid command specified\");\n            return;\n        } else if (cmd->getkeys_proc == NULL && cmd->firstkey == 0) {\n            addReplyError(c,\"The command has no key arguments\");\n            return;\n        } else if ((cmd->arity > 0 && cmd->arity != c->argc-2) ||\n                   ((c->argc-2) < -cmd->arity))\n        {\n            addReplyError(c,\"Invalid number of arguments specified for command\");\n            return;\n        }\n\n        if (!getKeysFromCommand(cmd,c->argv+2,c->argc-2,&result)) {\n            addReplyError(c,\"Invalid arguments specified for command\");\n        } else {\n            addReplyArrayLen(c,result.numkeys);\n            for (j = 0; j < result.numkeys; j++) addReplyBulk(c,c->argv[result.keys[j]+2]);\n        }\n        getKeysFreeResult(&result);\n    } else {\n        addReplySubcommandSyntaxError(c);\n    }\n}\n\n/* Convert an amount of bytes into a human readable string in the form\n * of 100B, 2G, 100M, 4K, and so forth. */\nvoid bytesToHuman(char *s, unsigned long long n) {\n    double d;\n\n    if (n < 1024) {\n        /* Bytes */\n        sprintf(s,\"%lluB\",n);\n    } else if (n < (1024*1024)) {\n        d = (double)n/(1024);\n        sprintf(s,\"%.2fK\",d);\n    } else if (n < (1024LL*1024*1024)) {\n        d = (double)n/(1024*1024);\n        sprintf(s,\"%.2fM\",d);\n    } else if (n < (1024LL*1024*1024*1024)) {\n        d = (double)n/(1024LL*1024*1024);\n        sprintf(s,\"%.2fG\",d);\n    } else if (n < (1024LL*1024*1024*1024*1024)) {\n        d = (double)n/(1024LL*1024*1024*1024);\n        sprintf(s,\"%.2fT\",d);\n    } else if (n < (1024LL*1024*1024*1024*1024*1024)) {\n        d = (double)n/(1024LL*1024*1024*1024*1024);\n        sprintf(s,\"%.2fP\",d);\n    } else {\n        /* Let's hope we never need this */\n        sprintf(s,\"%lluB\",n);\n    }\n}\n\n/* Create the string returned by the INFO command. This is decoupled\n * by the INFO command itself as we need to report the same information\n * on memory corruption problems. */\nsds genRedisInfoString(const char *section) {\n    sds info = sdsempty();\n    time_t uptime = server.unixtime-server.stat_starttime;\n    int j;\n    struct rusage self_ru, c_ru;\n    int allsections = 0, defsections = 0, everything = 0, modules = 0;\n    int sections = 0;\n\n    if (section == NULL) section = \"default\";\n    allsections = strcasecmp(section,\"all\") == 0;\n    defsections = strcasecmp(section,\"default\") == 0;\n    everything = strcasecmp(section,\"everything\") == 0;\n    modules = strcasecmp(section,\"modules\") == 0;\n    if (everything) allsections = 1;\n\n    getrusage(RUSAGE_SELF, &self_ru);\n    getrusage(RUSAGE_CHILDREN, &c_ru);\n\n    /* Server */\n    if (allsections || defsections || !strcasecmp(section,\"server\")) {\n        static int call_uname = 1;\n        static struct utsname name;\n        char *mode;\n\n        if (server.cluster_enabled) mode = \"cluster\";\n        else if (server.sentinel_mode) mode = \"sentinel\";\n        else mode = \"standalone\";\n\n        if (sections++) info = sdscat(info,\"\\r\\n\");\n\n        if (call_uname) {\n            /* Uname can be slow and is always the same output. Cache it. */\n            uname(&name);\n            call_uname = 0;\n        }\n\n        info = sdscatfmt(info,\n            \"# Server\\r\\n\"\n            \"redis_version:%s\\r\\n\"\n            \"redis_git_sha1:%s\\r\\n\"\n            \"redis_git_dirty:%i\\r\\n\"\n            \"redis_build_id:%s\\r\\n\"\n            \"redis_mode:%s\\r\\n\"\n            \"os:%s %s %s\\r\\n\"\n            \"arch_bits:%i\\r\\n\"\n            \"multiplexing_api:%s\\r\\n\"\n            \"atomicvar_api:%s\\r\\n\"\n            \"gcc_version:%i.%i.%i\\r\\n\"\n            \"process_id:%I\\r\\n\"\n            \"run_id:%s\\r\\n\"\n            \"tcp_port:%i\\r\\n\"\n            \"uptime_in_seconds:%I\\r\\n\"\n            \"uptime_in_days:%I\\r\\n\"\n            \"hz:%i\\r\\n\"\n            \"configured_hz:%i\\r\\n\"\n            \"lru_clock:%u\\r\\n\"\n            \"executable:%s\\r\\n\"\n            \"config_file:%s\\r\\n\"\n            \"io_threads_active:%i\\r\\n\",\n            REDIS_VERSION,\n            redisGitSHA1(),\n            strtol(redisGitDirty(),NULL,10) > 0,\n            redisBuildIdString(),\n            mode,\n            name.sysname, name.release, name.machine,\n            server.arch_bits,\n            aeGetApiName(),\n            REDIS_ATOMIC_API,\n#ifdef __GNUC__\n            __GNUC__,__GNUC_MINOR__,__GNUC_PATCHLEVEL__,\n#else\n            0,0,0,\n#endif\n            (int64_t) getpid(),\n            server.runid,\n            server.port ? server.port : server.tls_port,\n            (int64_t)uptime,\n            (int64_t)(uptime/(3600*24)),\n            server.hz,\n            server.config_hz,\n            server.lruclock,\n            server.executable ? server.executable : \"\",\n            server.configfile ? server.configfile : \"\",\n            server.io_threads_active);\n    }\n\n    /* Clients */\n    if (allsections || defsections || !strcasecmp(section,\"clients\")) {\n        size_t maxin, maxout;\n        getExpansiveClientsInfo(&maxin,&maxout);\n        if (sections++) info = sdscat(info,\"\\r\\n\");\n        info = sdscatprintf(info,\n            \"# Clients\\r\\n\"\n            \"connected_clients:%lu\\r\\n\"\n            \"client_recent_max_input_buffer:%zu\\r\\n\"\n            \"client_recent_max_output_buffer:%zu\\r\\n\"\n            \"blocked_clients:%d\\r\\n\"\n            \"tracking_clients:%d\\r\\n\"\n            \"clients_in_timeout_table:%llu\\r\\n\",\n            listLength(server.clients)-listLength(server.slaves),\n            maxin, maxout,\n            server.blocked_clients,\n            server.tracking_clients,\n            (unsigned long long) raxSize(server.clients_timeout_table));\n    }\n\n    /* Memory */\n    if (allsections || defsections || !strcasecmp(section,\"memory\")) {\n        char hmem[64];\n        char peak_hmem[64];\n        char total_system_hmem[64];\n        char used_memory_lua_hmem[64];\n        char used_memory_scripts_hmem[64];\n        char used_memory_rss_hmem[64];\n        char maxmemory_hmem[64];\n        size_t zmalloc_used = zmalloc_used_memory();\n        size_t total_system_mem = server.system_memory_size;\n        const char *evict_policy = evictPolicyToString();\n        long long memory_lua = server.lua ? (long long)lua_gc(server.lua,LUA_GCCOUNT,0)*1024 : 0;\n        struct redisMemOverhead *mh = getMemoryOverheadData();\n\n        /* Peak memory is updated from time to time by serverCron() so it\n         * may happen that the instantaneous value is slightly bigger than\n         * the peak value. This may confuse users, so we update the peak\n         * if found smaller than the current memory usage. */\n        if (zmalloc_used > server.stat_peak_memory)\n            server.stat_peak_memory = zmalloc_used;\n\n        bytesToHuman(hmem,zmalloc_used);\n        bytesToHuman(peak_hmem,server.stat_peak_memory);\n        bytesToHuman(total_system_hmem,total_system_mem);\n        bytesToHuman(used_memory_lua_hmem,memory_lua);\n        bytesToHuman(used_memory_scripts_hmem,mh->lua_caches);\n        bytesToHuman(used_memory_rss_hmem,server.cron_malloc_stats.process_rss);\n        bytesToHuman(maxmemory_hmem,server.maxmemory);\n\n        if (sections++) info = sdscat(info,\"\\r\\n\");\n        info = sdscatprintf(info,\n            \"# Memory\\r\\n\"\n            \"used_memory:%zu\\r\\n\"\n            \"used_memory_human:%s\\r\\n\"\n            \"used_memory_rss:%zu\\r\\n\"\n            \"used_memory_rss_human:%s\\r\\n\"\n            \"used_memory_peak:%zu\\r\\n\"\n            \"used_memory_peak_human:%s\\r\\n\"\n            \"used_memory_peak_perc:%.2f%%\\r\\n\"\n            \"used_memory_overhead:%zu\\r\\n\"\n            \"used_memory_startup:%zu\\r\\n\"\n            \"used_memory_dataset:%zu\\r\\n\"\n            \"used_memory_dataset_perc:%.2f%%\\r\\n\"\n            \"allocator_allocated:%zu\\r\\n\"\n            \"allocator_active:%zu\\r\\n\"\n            \"allocator_resident:%zu\\r\\n\"\n            \"total_system_memory:%lu\\r\\n\"\n            \"total_system_memory_human:%s\\r\\n\"\n            \"used_memory_lua:%lld\\r\\n\"\n            \"used_memory_lua_human:%s\\r\\n\"\n            \"used_memory_scripts:%lld\\r\\n\"\n            \"used_memory_scripts_human:%s\\r\\n\"\n            \"number_of_cached_scripts:%lu\\r\\n\"\n            \"maxmemory:%lld\\r\\n\"\n            \"maxmemory_human:%s\\r\\n\"\n            \"maxmemory_policy:%s\\r\\n\"\n            \"allocator_frag_ratio:%.2f\\r\\n\"\n            \"allocator_frag_bytes:%zu\\r\\n\"\n            \"allocator_rss_ratio:%.2f\\r\\n\"\n            \"allocator_rss_bytes:%zd\\r\\n\"\n            \"rss_overhead_ratio:%.2f\\r\\n\"\n            \"rss_overhead_bytes:%zd\\r\\n\"\n            \"mem_fragmentation_ratio:%.2f\\r\\n\"\n            \"mem_fragmentation_bytes:%zd\\r\\n\"\n            \"mem_not_counted_for_evict:%zu\\r\\n\"\n            \"mem_replication_backlog:%zu\\r\\n\"\n            \"mem_clients_slaves:%zu\\r\\n\"\n            \"mem_clients_normal:%zu\\r\\n\"\n            \"mem_aof_buffer:%zu\\r\\n\"\n            \"mem_allocator:%s\\r\\n\"\n            \"active_defrag_running:%d\\r\\n\"\n            \"lazyfree_pending_objects:%zu\\r\\n\",\n            zmalloc_used,\n            hmem,\n            server.cron_malloc_stats.process_rss,\n            used_memory_rss_hmem,\n            server.stat_peak_memory,\n            peak_hmem,\n            mh->peak_perc,\n            mh->overhead_total,\n            mh->startup_allocated,\n            mh->dataset,\n            mh->dataset_perc,\n            server.cron_malloc_stats.allocator_allocated,\n            server.cron_malloc_stats.allocator_active,\n            server.cron_malloc_stats.allocator_resident,\n            (unsigned long)total_system_mem,\n            total_system_hmem,\n            memory_lua,\n            used_memory_lua_hmem,\n            (long long) mh->lua_caches,\n            used_memory_scripts_hmem,\n            dictSize(server.lua_scripts),\n            server.maxmemory,\n            maxmemory_hmem,\n            evict_policy,\n            mh->allocator_frag,\n            mh->allocator_frag_bytes,\n            mh->allocator_rss,\n            mh->allocator_rss_bytes,\n            mh->rss_extra,\n            mh->rss_extra_bytes,\n            mh->total_frag,       /* This is the total RSS overhead, including\n                                     fragmentation, but not just it. This field\n                                     (and the next one) is named like that just\n                                     for backward compatibility. */\n            mh->total_frag_bytes,\n            freeMemoryGetNotCountedMemory(),\n            mh->repl_backlog,\n            mh->clients_slaves,\n            mh->clients_normal,\n            mh->aof_buffer,\n            ZMALLOC_LIB,\n            server.active_defrag_running,\n            lazyfreeGetPendingObjectsCount()\n        );\n        freeMemoryOverheadData(mh);\n    }\n\n    /* Persistence */\n    if (allsections || defsections || !strcasecmp(section,\"persistence\")) {\n        if (sections++) info = sdscat(info,\"\\r\\n\");\n        info = sdscatprintf(info,\n            \"# Persistence\\r\\n\"\n            \"loading:%d\\r\\n\"\n            \"rdb_changes_since_last_save:%lld\\r\\n\"\n            \"rdb_bgsave_in_progress:%d\\r\\n\"\n            \"rdb_last_save_time:%jd\\r\\n\"\n            \"rdb_last_bgsave_status:%s\\r\\n\"\n            \"rdb_last_bgsave_time_sec:%jd\\r\\n\"\n            \"rdb_current_bgsave_time_sec:%jd\\r\\n\"\n            \"rdb_last_cow_size:%zu\\r\\n\"\n            \"aof_enabled:%d\\r\\n\"\n            \"aof_rewrite_in_progress:%d\\r\\n\"\n            \"aof_rewrite_scheduled:%d\\r\\n\"\n            \"aof_last_rewrite_time_sec:%jd\\r\\n\"\n            \"aof_current_rewrite_time_sec:%jd\\r\\n\"\n            \"aof_last_bgrewrite_status:%s\\r\\n\"\n            \"aof_last_write_status:%s\\r\\n\"\n            \"aof_last_cow_size:%zu\\r\\n\"\n            \"module_fork_in_progress:%d\\r\\n\"\n            \"module_fork_last_cow_size:%zu\\r\\n\",\n            server.loading,\n            server.dirty,\n            server.rdb_child_pid != -1,\n            (intmax_t)server.lastsave,\n            (server.lastbgsave_status == C_OK) ? \"ok\" : \"err\",\n            (intmax_t)server.rdb_save_time_last,\n            (intmax_t)((server.rdb_child_pid == -1) ?\n                -1 : time(NULL)-server.rdb_save_time_start),\n            server.stat_rdb_cow_bytes,\n            server.aof_state != AOF_OFF,\n            server.aof_child_pid != -1,\n            server.aof_rewrite_scheduled,\n            (intmax_t)server.aof_rewrite_time_last,\n            (intmax_t)((server.aof_child_pid == -1) ?\n                -1 : time(NULL)-server.aof_rewrite_time_start),\n            (server.aof_lastbgrewrite_status == C_OK) ? \"ok\" : \"err\",\n            (server.aof_last_write_status == C_OK) ? \"ok\" : \"err\",\n            server.stat_aof_cow_bytes,\n            server.module_child_pid != -1,\n            server.stat_module_cow_bytes);\n\n        if (server.aof_enabled) {\n            info = sdscatprintf(info,\n                \"aof_current_size:%lld\\r\\n\"\n                \"aof_base_size:%lld\\r\\n\"\n                \"aof_pending_rewrite:%d\\r\\n\"\n                \"aof_buffer_length:%zu\\r\\n\"\n                \"aof_rewrite_buffer_length:%lu\\r\\n\"\n                \"aof_pending_bio_fsync:%llu\\r\\n\"\n                \"aof_delayed_fsync:%lu\\r\\n\",\n                (long long) server.aof_current_size,\n                (long long) server.aof_rewrite_base_size,\n                server.aof_rewrite_scheduled,\n                sdslen(server.aof_buf),\n                aofRewriteBufferSize(),\n                bioPendingJobsOfType(BIO_AOF_FSYNC),\n                server.aof_delayed_fsync);\n        }\n\n        if (server.loading) {\n            double perc;\n            time_t eta, elapsed;\n            off_t remaining_bytes = server.loading_total_bytes-\n                                    server.loading_loaded_bytes;\n\n            perc = ((double)server.loading_loaded_bytes /\n                   (server.loading_total_bytes+1)) * 100;\n\n            elapsed = time(NULL)-server.loading_start_time;\n            if (elapsed == 0) {\n                eta = 1; /* A fake 1 second figure if we don't have\n                            enough info */\n            } else {\n                eta = (elapsed*remaining_bytes)/(server.loading_loaded_bytes+1);\n            }\n\n            info = sdscatprintf(info,\n                \"loading_start_time:%jd\\r\\n\"\n                \"loading_total_bytes:%llu\\r\\n\"\n                \"loading_loaded_bytes:%llu\\r\\n\"\n                \"loading_loaded_perc:%.2f\\r\\n\"\n                \"loading_eta_seconds:%jd\\r\\n\",\n                (intmax_t) server.loading_start_time,\n                (unsigned long long) server.loading_total_bytes,\n                (unsigned long long) server.loading_loaded_bytes,\n                perc,\n                (intmax_t)eta\n            );\n        }\n    }\n\n    /* Stats */\n    if (allsections || defsections || !strcasecmp(section,\"stats\")) {\n        if (sections++) info = sdscat(info,\"\\r\\n\");\n        info = sdscatprintf(info,\n            \"# Stats\\r\\n\"\n            \"total_connections_received:%lld\\r\\n\"\n            \"total_commands_processed:%lld\\r\\n\"\n            \"instantaneous_ops_per_sec:%lld\\r\\n\"\n            \"total_net_input_bytes:%lld\\r\\n\"\n            \"total_net_output_bytes:%lld\\r\\n\"\n            \"instantaneous_input_kbps:%.2f\\r\\n\"\n            \"instantaneous_output_kbps:%.2f\\r\\n\"\n            \"rejected_connections:%lld\\r\\n\"\n            \"sync_full:%lld\\r\\n\"\n            \"sync_partial_ok:%lld\\r\\n\"\n            \"sync_partial_err:%lld\\r\\n\"\n            \"expired_keys:%lld\\r\\n\"\n            \"expired_stale_perc:%.2f\\r\\n\"\n            \"expired_time_cap_reached_count:%lld\\r\\n\"\n            \"expire_cycle_cpu_milliseconds:%lld\\r\\n\"\n            \"evicted_keys:%lld\\r\\n\"\n            \"keyspace_hits:%lld\\r\\n\"\n            \"keyspace_misses:%lld\\r\\n\"\n            \"pubsub_channels:%ld\\r\\n\"\n            \"pubsub_patterns:%lu\\r\\n\"\n            \"latest_fork_usec:%lld\\r\\n\"\n            \"migrate_cached_sockets:%ld\\r\\n\"\n            \"slave_expires_tracked_keys:%zu\\r\\n\"\n            \"active_defrag_hits:%lld\\r\\n\"\n            \"active_defrag_misses:%lld\\r\\n\"\n            \"active_defrag_key_hits:%lld\\r\\n\"\n            \"active_defrag_key_misses:%lld\\r\\n\"\n            \"tracking_total_keys:%lld\\r\\n\"\n            \"tracking_total_items:%lld\\r\\n\"\n            \"tracking_total_prefixes:%lld\\r\\n\"\n            \"unexpected_error_replies:%lld\\r\\n\"\n            \"total_reads_processed:%lld\\r\\n\"\n            \"total_writes_processed:%lld\\r\\n\"\n            \"io_threaded_reads_processed:%lld\\r\\n\"\n            \"io_threaded_writes_processed:%lld\\r\\n\",\n            server.stat_numconnections,\n            server.stat_numcommands,\n            getInstantaneousMetric(STATS_METRIC_COMMAND),\n            server.stat_net_input_bytes,\n            server.stat_net_output_bytes,\n            (float)getInstantaneousMetric(STATS_METRIC_NET_INPUT)/1024,\n            (float)getInstantaneousMetric(STATS_METRIC_NET_OUTPUT)/1024,\n            server.stat_rejected_conn,\n            server.stat_sync_full,\n            server.stat_sync_partial_ok,\n            server.stat_sync_partial_err,\n            server.stat_expiredkeys,\n            server.stat_expired_stale_perc*100,\n            server.stat_expired_time_cap_reached_count,\n            server.stat_expire_cycle_time_used/1000,\n            server.stat_evictedkeys,\n            server.stat_keyspace_hits,\n            server.stat_keyspace_misses,\n            dictSize(server.pubsub_channels),\n            listLength(server.pubsub_patterns),\n            server.stat_fork_time,\n            dictSize(server.migrate_cached_sockets),\n            getSlaveKeyWithExpireCount(),\n            server.stat_active_defrag_hits,\n            server.stat_active_defrag_misses,\n            server.stat_active_defrag_key_hits,\n            server.stat_active_defrag_key_misses,\n            (unsigned long long) trackingGetTotalKeys(),\n            (unsigned long long) trackingGetTotalItems(),\n            (unsigned long long) trackingGetTotalPrefixes(),\n            server.stat_unexpected_error_replies,\n            server.stat_total_reads_processed,\n            server.stat_total_writes_processed,\n            server.stat_io_reads_processed,\n            server.stat_io_writes_processed);\n    }\n\n    /* Replication */\n    if (allsections || defsections || !strcasecmp(section,\"replication\")) {\n        if (sections++) info = sdscat(info,\"\\r\\n\");\n        info = sdscatprintf(info,\n            \"# Replication\\r\\n\"\n            \"role:%s\\r\\n\",\n            server.masterhost == NULL ? \"master\" : \"slave\");\n        if (server.masterhost) {\n            long long slave_repl_offset = 1;\n\n            if (server.master)\n                slave_repl_offset = server.master->reploff;\n            else if (server.cached_master)\n                slave_repl_offset = server.cached_master->reploff;\n\n            info = sdscatprintf(info,\n                \"master_host:%s\\r\\n\"\n                \"master_port:%d\\r\\n\"\n                \"master_link_status:%s\\r\\n\"\n                \"master_last_io_seconds_ago:%d\\r\\n\"\n                \"master_sync_in_progress:%d\\r\\n\"\n                \"slave_repl_offset:%lld\\r\\n\"\n                ,server.masterhost,\n                server.masterport,\n                (server.repl_state == REPL_STATE_CONNECTED) ?\n                    \"up\" : \"down\",\n                server.master ?\n                ((int)(server.unixtime-server.master->lastinteraction)) : -1,\n                server.repl_state == REPL_STATE_TRANSFER,\n                slave_repl_offset\n            );\n\n            if (server.repl_state == REPL_STATE_TRANSFER) {\n                info = sdscatprintf(info,\n                    \"master_sync_left_bytes:%lld\\r\\n\"\n                    \"master_sync_last_io_seconds_ago:%d\\r\\n\"\n                    , (long long)\n                        (server.repl_transfer_size - server.repl_transfer_read),\n                    (int)(server.unixtime-server.repl_transfer_lastio)\n                );\n            }\n\n            if (server.repl_state != REPL_STATE_CONNECTED) {\n                info = sdscatprintf(info,\n                    \"master_link_down_since_seconds:%jd\\r\\n\",\n                    (intmax_t)(server.unixtime-server.repl_down_since));\n            }\n            info = sdscatprintf(info,\n                \"slave_priority:%d\\r\\n\"\n                \"slave_read_only:%d\\r\\n\",\n                server.slave_priority,\n                server.repl_slave_ro);\n        }\n\n        info = sdscatprintf(info,\n            \"connected_slaves:%lu\\r\\n\",\n            listLength(server.slaves));\n\n        /* If min-slaves-to-write is active, write the number of slaves\n         * currently considered 'good'. */\n        if (server.repl_min_slaves_to_write &&\n            server.repl_min_slaves_max_lag) {\n            info = sdscatprintf(info,\n                \"min_slaves_good_slaves:%d\\r\\n\",\n                server.repl_good_slaves_count);\n        }\n\n        if (listLength(server.slaves)) {\n            int slaveid = 0;\n            listNode *ln;\n            listIter li;\n\n            listRewind(server.slaves,&li);\n            while((ln = listNext(&li))) {\n                client *slave = listNodeValue(ln);\n                char *state = NULL;\n                char ip[NET_IP_STR_LEN], *slaveip = slave->slave_ip;\n                int port;\n                long lag = 0;\n\n                if (slaveip[0] == '\\0') {\n                    if (connPeerToString(slave->conn,ip,sizeof(ip),&port) == -1)\n                        continue;\n                    slaveip = ip;\n                }\n                switch(slave->replstate) {\n                case SLAVE_STATE_WAIT_BGSAVE_START:\n                case SLAVE_STATE_WAIT_BGSAVE_END:\n                    state = \"wait_bgsave\";\n                    break;\n                case SLAVE_STATE_SEND_BULK:\n                    state = \"send_bulk\";\n                    break;\n                case SLAVE_STATE_ONLINE:\n                    state = \"online\";\n                    break;\n                }\n                if (state == NULL) continue;\n                if (slave->replstate == SLAVE_STATE_ONLINE)\n                    lag = time(NULL) - slave->repl_ack_time;\n\n                info = sdscatprintf(info,\n                    \"slave%d:ip=%s,port=%d,state=%s,\"\n                    \"offset=%lld,lag=%ld\\r\\n\",\n                    slaveid,slaveip,slave->slave_listening_port,state,\n                    slave->repl_ack_off, lag);\n                slaveid++;\n            }\n        }\n        info = sdscatprintf(info,\n            \"master_replid:%s\\r\\n\"\n            \"master_replid2:%s\\r\\n\"\n            \"master_repl_offset:%lld\\r\\n\"\n            \"second_repl_offset:%lld\\r\\n\"\n            \"repl_backlog_active:%d\\r\\n\"\n            \"repl_backlog_size:%lld\\r\\n\"\n            \"repl_backlog_first_byte_offset:%lld\\r\\n\"\n            \"repl_backlog_histlen:%lld\\r\\n\",\n            server.replid,\n            server.replid2,\n            server.master_repl_offset,\n            server.second_replid_offset,\n            server.repl_backlog != NULL,\n            server.repl_backlog_size,\n            server.repl_backlog_off,\n            server.repl_backlog_histlen);\n    }\n\n    /* CPU */\n    if (allsections || defsections || !strcasecmp(section,\"cpu\")) {\n        if (sections++) info = sdscat(info,\"\\r\\n\");\n        info = sdscatprintf(info,\n        \"# CPU\\r\\n\"\n        \"used_cpu_sys:%ld.%06ld\\r\\n\"\n        \"used_cpu_user:%ld.%06ld\\r\\n\"\n        \"used_cpu_sys_children:%ld.%06ld\\r\\n\"\n        \"used_cpu_user_children:%ld.%06ld\\r\\n\",\n        (long)self_ru.ru_stime.tv_sec, (long)self_ru.ru_stime.tv_usec,\n        (long)self_ru.ru_utime.tv_sec, (long)self_ru.ru_utime.tv_usec,\n        (long)c_ru.ru_stime.tv_sec, (long)c_ru.ru_stime.tv_usec,\n        (long)c_ru.ru_utime.tv_sec, (long)c_ru.ru_utime.tv_usec);\n    }\n\n    /* Modules */\n    if (allsections || defsections || !strcasecmp(section,\"modules\")) {\n        if (sections++) info = sdscat(info,\"\\r\\n\");\n        info = sdscatprintf(info,\"# Modules\\r\\n\");\n        info = genModulesInfoString(info);\n    }\n\n    /* Command statistics */\n    if (allsections || !strcasecmp(section,\"commandstats\")) {\n        if (sections++) info = sdscat(info,\"\\r\\n\");\n        info = sdscatprintf(info, \"# Commandstats\\r\\n\");\n\n        struct redisCommand *c;\n        dictEntry *de;\n        dictIterator *di;\n        di = dictGetSafeIterator(server.commands);\n        while((de = dictNext(di)) != NULL) {\n            c = (struct redisCommand *) dictGetVal(de);\n            if (!c->calls) continue;\n            info = sdscatprintf(info,\n                \"cmdstat_%s:calls=%lld,usec=%lld,usec_per_call=%.2f\\r\\n\",\n                c->name, c->calls, c->microseconds,\n                (c->calls == 0) ? 0 : ((float)c->microseconds/c->calls));\n        }\n        dictReleaseIterator(di);\n    }\n\n    /* Cluster */\n    if (allsections || defsections || !strcasecmp(section,\"cluster\")) {\n        if (sections++) info = sdscat(info,\"\\r\\n\");\n        info = sdscatprintf(info,\n        \"# Cluster\\r\\n\"\n        \"cluster_enabled:%d\\r\\n\",\n        server.cluster_enabled);\n    }\n\n    /* Key space */\n    if (allsections || defsections || !strcasecmp(section,\"keyspace\")) {\n        if (sections++) info = sdscat(info,\"\\r\\n\");\n        info = sdscatprintf(info, \"# Keyspace\\r\\n\");\n        for (j = 0; j < server.dbnum; j++) {\n            long long keys, vkeys;\n\n            keys = dictSize(server.db[j].dict);\n            vkeys = dictSize(server.db[j].expires);\n            if (keys || vkeys) {\n                info = sdscatprintf(info,\n                    \"db%d:keys=%lld,expires=%lld,avg_ttl=%lld\\r\\n\",\n                    j, keys, vkeys, server.db[j].avg_ttl);\n            }\n        }\n    }\n\n    /* Get info from modules.\n     * if user asked for \"everything\" or \"modules\", or a specific section\n     * that's not found yet. */\n    if (everything || modules ||\n        (!allsections && !defsections && sections==0)) {\n        info = modulesCollectInfo(info,\n                                  everything || modules ? NULL: section,\n                                  0, /* not a crash report */\n                                  sections);\n    }\n    return info;\n}\n\nvoid infoCommand(client *c) {\n    char *section = c->argc == 2 ? c->argv[1]->ptr : \"default\";\n\n    if (c->argc > 2) {\n        addReply(c,shared.syntaxerr);\n        return;\n    }\n    sds info = genRedisInfoString(section);\n    addReplyVerbatim(c,info,sdslen(info),\"txt\");\n    sdsfree(info);\n}\n\nvoid monitorCommand(client *c) {\n    /* ignore MONITOR if already slave or in monitor mode */\n    if (c->flags & CLIENT_SLAVE) return;\n\n    c->flags |= (CLIENT_SLAVE|CLIENT_MONITOR);\n    listAddNodeTail(server.monitors,c);\n    addReply(c,shared.ok);\n}\n\n/* =================================== Main! ================================ */\n\nint checkIgnoreWarning(const char *warning) {\n    int argc, j;\n    sds *argv = sdssplitargs(server.ignore_warnings, &argc);\n    if (argv == NULL)\n        return 0;\n\n    for (j = 0; j < argc; j++) {\n        char *flag = argv[j];\n        if (!strcasecmp(flag, warning))\n            break;\n    }\n    sdsfreesplitres(argv,argc);\n    return j < argc;\n}\n\n#ifdef __linux__\nint linuxOvercommitMemoryValue(void) {\n    FILE *fp = fopen(\"/proc/sys/vm/overcommit_memory\",\"r\");\n    char buf[64];\n\n    if (!fp) return -1;\n    if (fgets(buf,64,fp) == NULL) {\n        fclose(fp);\n        return -1;\n    }\n    fclose(fp);\n\n    return atoi(buf);\n}\n\nvoid linuxMemoryWarnings(void) {\n    if (linuxOvercommitMemoryValue() == 0) {\n        serverLog(LL_WARNING,\"WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add 'vm.overcommit_memory = 1' to /etc/sysctl.conf and then reboot or run the command 'sysctl vm.overcommit_memory=1' for this to take effect.\");\n    }\n    if (THPIsEnabled()) {\n        serverLog(LL_WARNING,\"WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command 'echo madvise > /sys/kernel/mm/transparent_hugepage/enabled' as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled (set to 'madvise' or 'never').\");\n    }\n}\n\n#ifdef __arm64__\n\n/* Get size in kilobytes of the Shared_Dirty pages of the calling process for the\n * memory map corresponding to the provided address, or -1 on error. */\nstatic int smapsGetSharedDirty(unsigned long addr) {\n    int ret, in_mapping = 0, val = -1;\n    unsigned long from, to;\n    char buf[64];\n    FILE *f;\n\n    f = fopen(\"/proc/self/smaps\", \"r\");\n    if (!f) return -1;\n\n    while (1) {\n        if (!fgets(buf, sizeof(buf), f))\n            break;\n\n        ret = sscanf(buf, \"%lx-%lx\", &from, &to);\n        if (ret == 2)\n            in_mapping = from <= addr && addr < to;\n\n        if (in_mapping && !memcmp(buf, \"Shared_Dirty:\", 13)) {\n            sscanf(buf, \"%*s %d\", &val);\n            /* If parsing fails, we remain with val == -1 */\n            break;\n        }\n    }\n\n    fclose(f);\n    return val;\n}\n\n/* Older arm64 Linux kernels have a bug that could lead to data corruption\n * during background save in certain scenarios. This function checks if the\n * kernel is affected.\n * The bug was fixed in commit ff1712f953e27f0b0718762ec17d0adb15c9fd0b\n * titled: \"arm64: pgtable: Ensure dirty bit is preserved across pte_wrprotect()\"\n * Return -1 on unexpected test failure, 1 if the kernel seems to be affected,\n * and 0 otherwise. */\nint linuxMadvFreeForkBugCheck(void) {\n    int ret, pipefd[2] = { -1, -1 };\n    pid_t pid;\n    char *p = NULL, *q;\n    int bug_found = 0;\n    long page_size = sysconf(_SC_PAGESIZE);\n    long map_size = 3 * page_size;\n\n    /* Create a memory map that's in our full control (not one used by the allocator). */\n    p = mmap(NULL, map_size, PROT_READ, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);\n    if (p == MAP_FAILED) {\n        serverLog(LL_WARNING, \"Failed to mmap(): %s\", strerror(errno));\n        return -1;\n    }\n\n    q = p + page_size;\n\n    /* Split the memory map in 3 pages by setting their protection as RO|RW|RO to prevent\n     * Linux from merging this memory map with adjacent VMAs. */\n    ret = mprotect(q, page_size, PROT_READ | PROT_WRITE);\n    if (ret < 0) {\n        serverLog(LL_WARNING, \"Failed to mprotect(): %s\", strerror(errno));\n        bug_found = -1;\n        goto exit;\n    }\n\n    /* Write to the page once to make it resident */\n    *(volatile char*)q = 0;\n\n    /* Tell the kernel that this page is free to be reclaimed. */\n#ifndef MADV_FREE\n#define MADV_FREE 8\n#endif\n    ret = madvise(q, page_size, MADV_FREE);\n    if (ret < 0) {\n        /* MADV_FREE is not available on older kernels that are presumably\n         * not affected. */\n        if (errno == EINVAL) goto exit;\n\n        serverLog(LL_WARNING, \"Failed to madvise(): %s\", strerror(errno));\n        bug_found = -1;\n        goto exit;\n    }\n\n    /* Write to the page after being marked for freeing, this is supposed to take\n     * ownership of that page again. */\n    *(volatile char*)q = 0;\n\n    /* Create a pipe for the child to return the info to the parent. */\n    ret = pipe(pipefd);\n    if (ret < 0) {\n        serverLog(LL_WARNING, \"Failed to create pipe: %s\", strerror(errno));\n        bug_found = -1;\n        goto exit;\n    }\n\n    /* Fork the process. */\n    pid = fork();\n    if (pid < 0) {\n        serverLog(LL_WARNING, \"Failed to fork: %s\", strerror(errno));\n        bug_found = -1;\n        goto exit;\n    } else if (!pid) {\n        /* Child: check if the page is marked as dirty, page_size in kb.\n         * A value of 0 means the kernel is affected by the bug. */\n        ret = smapsGetSharedDirty((unsigned long) q);\n        if (!ret)\n            bug_found = 1;\n        else if (ret == -1)     /* Failed to read */\n            bug_found = -1;\n\n        if (write(pipefd[1], &bug_found, sizeof(bug_found)) < 0)\n            serverLog(LL_WARNING, \"Failed to write to parent: %s\", strerror(errno));\n        exit(0);\n    } else {\n        /* Read the result from the child. */\n        ret = read(pipefd[0], &bug_found, sizeof(bug_found));\n        if (ret < 0) {\n            serverLog(LL_WARNING, \"Failed to read from child: %s\", strerror(errno));\n            bug_found = -1;\n        }\n\n        /* Reap the child pid. */\n        waitpid(pid, NULL, 0);\n    }\n\nexit:\n    /* Cleanup */\n    if (pipefd[0] != -1) close(pipefd[0]);\n    if (pipefd[1] != -1) close(pipefd[1]);\n    if (p != NULL) munmap(p, map_size);\n\n    return bug_found;\n}\n#endif /* __arm64__ */\n#endif /* __linux__ */\n\nvoid createPidFile(void) {\n    /* If pidfile requested, but no pidfile defined, use\n     * default pidfile path */\n    if (!server.pidfile) server.pidfile = zstrdup(CONFIG_DEFAULT_PID_FILE);\n\n    /* Try to write the pid file in a best-effort way. */\n    FILE *fp = fopen(server.pidfile,\"w\");\n    if (fp) {\n        fprintf(fp,\"%d\\n\",(int)getpid());\n        fclose(fp);\n    }\n}\n\nvoid daemonize(void) {\n    int fd;\n\n    if (fork() != 0) exit(0); /* parent exits */\n    setsid(); /* create a new session */\n\n    /* Every output goes to /dev/null. If Redis is daemonized but\n     * the 'logfile' is set to 'stdout' in the configuration file\n     * it will not log at all. */\n    if ((fd = open(\"/dev/null\", O_RDWR, 0)) != -1) {\n        dup2(fd, STDIN_FILENO);\n        dup2(fd, STDOUT_FILENO);\n        dup2(fd, STDERR_FILENO);\n        if (fd > STDERR_FILENO) close(fd);\n    }\n}\n\nvoid version(void) {\n    printf(\"Redis server v=%s sha=%s:%d malloc=%s bits=%d build=%llx\\n\",\n        REDIS_VERSION,\n        redisGitSHA1(),\n        atoi(redisGitDirty()) > 0,\n        ZMALLOC_LIB,\n        sizeof(long) == 4 ? 32 : 64,\n        (unsigned long long) redisBuildId());\n    exit(0);\n}\n\nvoid usage(void) {\n    fprintf(stderr,\"Usage: ./redis-server [/path/to/redis.conf] [options]\\n\");\n    fprintf(stderr,\"       ./redis-server - (read config from stdin)\\n\");\n    fprintf(stderr,\"       ./redis-server -v or --version\\n\");\n    fprintf(stderr,\"       ./redis-server -h or --help\\n\");\n    fprintf(stderr,\"       ./redis-server --test-memory <megabytes>\\n\\n\");\n    fprintf(stderr,\"Examples:\\n\");\n    fprintf(stderr,\"       ./redis-server (run the server with default conf)\\n\");\n    fprintf(stderr,\"       ./redis-server /etc/redis/6379.conf\\n\");\n    fprintf(stderr,\"       ./redis-server --port 7777\\n\");\n    fprintf(stderr,\"       ./redis-server --port 7777 --replicaof 127.0.0.1 8888\\n\");\n    fprintf(stderr,\"       ./redis-server /etc/myredis.conf --loglevel verbose\\n\\n\");\n    fprintf(stderr,\"Sentinel mode:\\n\");\n    fprintf(stderr,\"       ./redis-server /etc/sentinel.conf --sentinel\\n\");\n    exit(1);\n}\n\nvoid redisAsciiArt(void) {\n#include \"asciilogo.h\"\n    char *buf = zmalloc(1024*16);\n    char *mode;\n\n    if (server.cluster_enabled) mode = \"cluster\";\n    else if (server.sentinel_mode) mode = \"sentinel\";\n    else mode = \"standalone\";\n\n    /* Show the ASCII logo if: log file is stdout AND stdout is a\n     * tty AND syslog logging is disabled. Also show logo if the user\n     * forced us to do so via redis.conf. */\n    int show_logo = ((!server.syslog_enabled &&\n                      server.logfile[0] == '\\0' &&\n                      isatty(fileno(stdout))) ||\n                     server.always_show_logo);\n\n    if (!show_logo) {\n        serverLog(LL_NOTICE,\n            \"Running mode=%s, port=%d.\",\n            mode, server.port ? server.port : server.tls_port\n        );\n    } else {\n        snprintf(buf,1024*16,ascii_logo,\n            REDIS_VERSION,\n            redisGitSHA1(),\n            strtol(redisGitDirty(),NULL,10) > 0,\n            (sizeof(long) == 8) ? \"64\" : \"32\",\n            mode, server.port ? server.port : server.tls_port,\n            (long) getpid()\n        );\n        serverLogRaw(LL_NOTICE|LL_RAW,buf);\n    }\n    zfree(buf);\n}\n\nstatic void sigShutdownHandler(int sig) {\n    char *msg;\n\n    switch (sig) {\n    case SIGINT:\n        msg = \"Received SIGINT scheduling shutdown...\";\n        break;\n    case SIGTERM:\n        msg = \"Received SIGTERM scheduling shutdown...\";\n        break;\n    default:\n        msg = \"Received shutdown signal, scheduling shutdown...\";\n    };\n\n    /* SIGINT is often delivered via Ctrl+C in an interactive session.\n     * If we receive the signal the second time, we interpret this as\n     * the user really wanting to quit ASAP without waiting to persist\n     * on disk. */\n    if (server.shutdown_asap && sig == SIGINT) {\n        serverLogFromHandler(LL_WARNING, \"You insist... exiting now.\");\n        rdbRemoveTempFile(getpid(), 1);\n        exit(1); /* Exit with an error since this was not a clean shutdown. */\n    } else if (server.loading) {\n        serverLogFromHandler(LL_WARNING, \"Received shutdown signal during loading, exiting now.\");\n        exit(0);\n    }\n\n    serverLogFromHandler(LL_WARNING, msg);\n    server.shutdown_asap = 1;\n}\n\nvoid setupSignalHandlers(void) {\n    struct sigaction act;\n\n    /* When the SA_SIGINFO flag is set in sa_flags then sa_sigaction is used.\n     * Otherwise, sa_handler is used. */\n    sigemptyset(&act.sa_mask);\n    act.sa_flags = 0;\n    act.sa_handler = sigShutdownHandler;\n    sigaction(SIGTERM, &act, NULL);\n    sigaction(SIGINT, &act, NULL);\n\n#ifdef HAVE_BACKTRACE\n    sigemptyset(&act.sa_mask);\n    act.sa_flags = SA_NODEFER | SA_RESETHAND | SA_SIGINFO;\n    act.sa_sigaction = sigsegvHandler;\n    sigaction(SIGSEGV, &act, NULL);\n    sigaction(SIGBUS, &act, NULL);\n    sigaction(SIGFPE, &act, NULL);\n    sigaction(SIGILL, &act, NULL);\n#endif\n    return;\n}\n\n/* This is the signal handler for children process. It is currently useful\n * in order to track the SIGUSR1, that we send to a child in order to terminate\n * it in a clean way, without the parent detecting an error and stop\n * accepting writes because of a write error condition. */\nstatic void sigKillChildHandler(int sig) {\n    UNUSED(sig);\n    int level = server.in_fork_child == CHILD_TYPE_MODULE? LL_VERBOSE: LL_WARNING;\n    serverLogFromHandler(level, \"Received SIGUSR1 in child, exiting now.\");\n    exitFromChild(SERVER_CHILD_NOERROR_RETVAL);\n}\n\nvoid setupChildSignalHandlers(void) {\n    struct sigaction act;\n\n    /* When the SA_SIGINFO flag is set in sa_flags then sa_sigaction is used.\n     * Otherwise, sa_handler is used. */\n    sigemptyset(&act.sa_mask);\n    act.sa_flags = 0;\n    act.sa_handler = sigKillChildHandler;\n    sigaction(SIGUSR1, &act, NULL);\n    return;\n}\n\n/* After fork, the child process will inherit the resources\n * of the parent process, e.g. fd(socket or flock) etc.\n * should close the resources not used by the child process, so that if the\n * parent restarts it can bind/lock despite the child possibly still running. */\nvoid closeClildUnusedResourceAfterFork() {\n    closeListeningSockets(0);\n    if (server.cluster_enabled && server.cluster_config_file_lock_fd != -1)\n        close(server.cluster_config_file_lock_fd);  /* don't care if this fails */\n\n    /* Clear server.pidfile, this is the parent pidfile which should not\n     * be touched (or deleted) by the child (on exit / crash) */\n    zfree(server.pidfile);\n    server.pidfile = NULL;\n}\n\n/* purpose is one of CHILD_TYPE_ types */\nint redisFork(int purpose) {\n    int childpid;\n    long long start = ustime();\n    if ((childpid = fork()) == 0) {\n        /* Child */\n        server.in_fork_child = purpose;\n        setOOMScoreAdj(CONFIG_OOM_BGCHILD);\n        setupChildSignalHandlers();\n        closeClildUnusedResourceAfterFork();\n    } else {\n        /* Parent */\n        server.stat_fork_time = ustime()-start;\n        server.stat_fork_rate = (double) zmalloc_used_memory() * 1000000 / server.stat_fork_time / (1024*1024*1024); /* GB per second. */\n        latencyAddSampleIfNeeded(\"fork\",server.stat_fork_time/1000);\n        if (childpid == -1) {\n            return -1;\n        }\n    }\n    return childpid;\n}\n\nvoid sendChildCOWInfo(int ptype, char *pname) {\n    size_t private_dirty = zmalloc_get_private_dirty(-1);\n\n    if (private_dirty) {\n        serverLog(LL_NOTICE,\n            \"%s: %zu MB of memory used by copy-on-write\",\n            pname, private_dirty/(1024*1024));\n    }\n\n    server.child_info_data.cow_size = private_dirty;\n    sendChildInfo(ptype);\n}\n\nvoid memtest(size_t megabytes, int passes);\n\n/* Returns 1 if there is --sentinel among the arguments or if\n * argv[0] contains \"redis-sentinel\". */\nint checkForSentinelMode(int argc, char **argv) {\n    int j;\n\n    if (strstr(argv[0],\"redis-sentinel\") != NULL) return 1;\n    for (j = 1; j < argc; j++)\n        if (!strcmp(argv[j],\"--sentinel\")) return 1;\n    return 0;\n}\n\n/* Function called at startup to load RDB or AOF file in memory. */\nvoid loadDataFromDisk(void) {\n    long long start = ustime();\n    if (server.aof_state == AOF_ON) {\n        if (loadAppendOnlyFile(server.aof_filename) == C_OK)\n            serverLog(LL_NOTICE,\"DB loaded from append only file: %.3f seconds\",(float)(ustime()-start)/1000000);\n    } else {\n        rdbSaveInfo rsi = RDB_SAVE_INFO_INIT;\n        errno = 0; /* Prevent a stale value from affecting error checking */\n        if (rdbLoad(server.rdb_filename,&rsi,RDBFLAGS_NONE) == C_OK) {\n            serverLog(LL_NOTICE,\"DB loaded from disk: %.3f seconds\",\n                (float)(ustime()-start)/1000000);\n\n            /* Restore the replication ID / offset from the RDB file. */\n            if ((server.masterhost ||\n                (server.cluster_enabled &&\n                nodeIsSlave(server.cluster->myself))) &&\n                rsi.repl_id_is_set &&\n                rsi.repl_offset != -1 &&\n                /* Note that older implementations may save a repl_stream_db\n                 * of -1 inside the RDB file in a wrong way, see more\n                 * information in function rdbPopulateSaveInfo. */\n                rsi.repl_stream_db != -1)\n            {\n                memcpy(server.replid,rsi.repl_id,sizeof(server.replid));\n                server.master_repl_offset = rsi.repl_offset;\n                /* If we are a slave, create a cached master from this\n                 * information, in order to allow partial resynchronizations\n                 * with masters. */\n                replicationCacheMasterUsingMyself();\n                selectDb(server.cached_master,rsi.repl_stream_db);\n            }\n        } else if (errno != ENOENT) {\n            serverLog(LL_WARNING,\"Fatal error loading the DB: %s. Exiting.\",strerror(errno));\n            exit(1);\n        }\n    }\n}\n\nvoid redisOutOfMemoryHandler(size_t allocation_size) {\n    serverLog(LL_WARNING,\"Out Of Memory allocating %zu bytes!\",\n        allocation_size);\n    serverPanic(\"Redis aborting for OUT OF MEMORY. Allocating %zu bytes!\", \n        allocation_size);\n}\n\nvoid redisSetProcTitle(char *title) {\n#ifdef USE_SETPROCTITLE\n    char *server_mode = \"\";\n    if (server.cluster_enabled) server_mode = \" [cluster]\";\n    else if (server.sentinel_mode) server_mode = \" [sentinel]\";\n\n    setproctitle(\"%s %s:%d%s\",\n        title,\n        server.bindaddr_count ? server.bindaddr[0] : \"*\",\n        server.port ? server.port : server.tls_port,\n        server_mode);\n#else\n    UNUSED(title);\n#endif\n}\n\nvoid redisSetCpuAffinity(const char *cpulist) {\n#ifdef USE_SETCPUAFFINITY\n    setcpuaffinity(cpulist);\n#else\n    UNUSED(cpulist);\n#endif\n}\n\n/*\n * Check whether systemd or upstart have been used to start redis.\n */\n\nint redisSupervisedUpstart(void) {\n    const char *upstart_job = getenv(\"UPSTART_JOB\");\n\n    if (!upstart_job) {\n        serverLog(LL_WARNING,\n                \"upstart supervision requested, but UPSTART_JOB not found\");\n        return 0;\n    }\n\n    serverLog(LL_NOTICE, \"supervised by upstart, will stop to signal readiness\");\n    raise(SIGSTOP);\n    unsetenv(\"UPSTART_JOB\");\n    return 1;\n}\n\nint redisCommunicateSystemd(const char *sd_notify_msg) {\n    const char *notify_socket = getenv(\"NOTIFY_SOCKET\");\n    if (!notify_socket) {\n        serverLog(LL_WARNING,\n                \"systemd supervision requested, but NOTIFY_SOCKET not found\");\n    }\n\n    #ifdef HAVE_LIBSYSTEMD\n    (void) sd_notify(0, sd_notify_msg);\n    #else\n    UNUSED(sd_notify_msg);\n    #endif\n    return 0;\n}\n\nint redisIsSupervised(int mode) {\n    if (mode == SUPERVISED_AUTODETECT) {\n        const char *upstart_job = getenv(\"UPSTART_JOB\");\n        const char *notify_socket = getenv(\"NOTIFY_SOCKET\");\n\n        if (upstart_job) {\n            redisSupervisedUpstart();\n        } else if (notify_socket) {\n            server.supervised_mode = SUPERVISED_SYSTEMD;\n            serverLog(LL_WARNING,\n                \"WARNING auto-supervised by systemd - you MUST set appropriate values for TimeoutStartSec and TimeoutStopSec in your service unit.\");\n            return redisCommunicateSystemd(\"STATUS=Redis is loading...\\n\");\n        }\n    } else if (mode == SUPERVISED_UPSTART) {\n        return redisSupervisedUpstart();\n    } else if (mode == SUPERVISED_SYSTEMD) {\n        serverLog(LL_WARNING,\n            \"WARNING supervised by systemd - you MUST set appropriate values for TimeoutStartSec and TimeoutStopSec in your service unit.\");\n        return redisCommunicateSystemd(\"STATUS=Redis is loading...\\n\");\n    }\n\n    return 0;\n}\n\nint iAmMaster(void) {\n    return ((!server.cluster_enabled && server.masterhost == NULL) ||\n            (server.cluster_enabled && nodeIsMaster(server.cluster->myself)));\n}\n\nint main(int argc, char **argv) {\n    struct timeval tv;\n    int j;\n\n#ifdef REDIS_TEST\n    if (argc == 3 && !strcasecmp(argv[1], \"test\")) {\n        if (!strcasecmp(argv[2], \"ziplist\")) {\n            return ziplistTest(argc, argv);\n        } else if (!strcasecmp(argv[2], \"quicklist\")) {\n            quicklistTest(argc, argv);\n        } else if (!strcasecmp(argv[2], \"intset\")) {\n            return intsetTest(argc, argv);\n        } else if (!strcasecmp(argv[2], \"zipmap\")) {\n            return zipmapTest(argc, argv);\n        } else if (!strcasecmp(argv[2], \"sha1test\")) {\n            return sha1Test(argc, argv);\n        } else if (!strcasecmp(argv[2], \"util\")) {\n            return utilTest(argc, argv);\n        } else if (!strcasecmp(argv[2], \"endianconv\")) {\n            return endianconvTest(argc, argv);\n        } else if (!strcasecmp(argv[2], \"crc64\")) {\n            return crc64Test(argc, argv);\n        } else if (!strcasecmp(argv[2], \"zmalloc\")) {\n            return zmalloc_test(argc, argv);\n        }\n\n        return -1; /* test not found */\n    }\n#endif\n\n    /* We need to initialize our libraries, and the server configuration. */\n#ifdef INIT_SETPROCTITLE_REPLACEMENT\n    spt_init(argc, argv);\n#endif\n    setlocale(LC_COLLATE,\"\");\n    tzset(); /* Populates 'timezone' global. */\n    zmalloc_set_oom_handler(redisOutOfMemoryHandler);\n    srand(time(NULL)^getpid());\n    gettimeofday(&tv,NULL);\n    init_genrand64(((long long) tv.tv_sec * 1000000 + tv.tv_usec) ^ getpid());\n    crc64_init();\n\n    /* Store umask value. Because umask(2) only offers a set-and-get API we have\n     * to reset it and restore it back. We do this early to avoid a potential\n     * race condition with threads that could be creating files or directories.\n     */\n    umask(server.umask = umask(0777));\n\n    uint8_t hashseed[16];\n    getRandomBytes(hashseed,sizeof(hashseed));\n    dictSetHashFunctionSeed(hashseed);\n    server.sentinel_mode = checkForSentinelMode(argc,argv);\n    initServerConfig();\n    ACLInit(); /* The ACL subsystem must be initialized ASAP because the\n                  basic networking code and client creation depends on it. */\n    moduleInitModulesSystem();\n    tlsInit();\n\n    /* Store the executable path and arguments in a safe place in order\n     * to be able to restart the server later. */\n    server.executable = getAbsolutePath(argv[0]);\n    server.exec_argv = zmalloc(sizeof(char*)*(argc+1));\n    server.exec_argv[argc] = NULL;\n    for (j = 0; j < argc; j++) server.exec_argv[j] = zstrdup(argv[j]);\n\n    /* We need to init sentinel right now as parsing the configuration file\n     * in sentinel mode will have the effect of populating the sentinel\n     * data structures with master nodes to monitor. */\n    if (server.sentinel_mode) {\n        initSentinelConfig();\n        initSentinel();\n    }\n\n    /* Check if we need to start in redis-check-rdb/aof mode. We just execute\n     * the program main. However the program is part of the Redis executable\n     * so that we can easily execute an RDB check on loading errors. */\n    if (strstr(argv[0],\"redis-check-rdb\") != NULL)\n        redis_check_rdb_main(argc,argv,NULL);\n    else if (strstr(argv[0],\"redis-check-aof\") != NULL)\n        redis_check_aof_main(argc,argv);\n\n    if (argc >= 2) {\n        j = 1; /* First option to parse in argv[] */\n        sds options = sdsempty();\n        char *configfile = NULL;\n\n        /* Handle special options --help and --version */\n        if (strcmp(argv[1], \"-v\") == 0 ||\n            strcmp(argv[1], \"--version\") == 0) version();\n        if (strcmp(argv[1], \"--help\") == 0 ||\n            strcmp(argv[1], \"-h\") == 0) usage();\n        if (strcmp(argv[1], \"--test-memory\") == 0) {\n            if (argc == 3) {\n                memtest(atoi(argv[2]),50);\n                exit(0);\n            } else {\n                fprintf(stderr,\"Please specify the amount of memory to test in megabytes.\\n\");\n                fprintf(stderr,\"Example: ./redis-server --test-memory 4096\\n\\n\");\n                exit(1);\n            }\n        }\n\n        /* First argument is the config file name? */\n        if (argv[j][0] != '-' || argv[j][1] != '-') {\n            configfile = argv[j];\n            server.configfile = getAbsolutePath(configfile);\n            /* Replace the config file in server.exec_argv with\n             * its absolute path. */\n            zfree(server.exec_argv[j]);\n            server.exec_argv[j] = zstrdup(server.configfile);\n            j++;\n        }\n\n        /* All the other options are parsed and conceptually appended to the\n         * configuration file. For instance --port 6380 will generate the\n         * string \"port 6380\\n\" to be parsed after the actual file name\n         * is parsed, if any. */\n        while(j != argc) {\n            if (argv[j][0] == '-' && argv[j][1] == '-') {\n                /* Option name */\n                if (!strcmp(argv[j], \"--check-rdb\")) {\n                    /* Argument has no options, need to skip for parsing. */\n                    j++;\n                    continue;\n                }\n                if (sdslen(options)) options = sdscat(options,\"\\n\");\n                options = sdscat(options,argv[j]+2);\n                options = sdscat(options,\" \");\n            } else {\n                /* Option argument */\n                options = sdscatrepr(options,argv[j],strlen(argv[j]));\n                options = sdscat(options,\" \");\n            }\n            j++;\n        }\n        if (server.sentinel_mode && configfile && *configfile == '-') {\n            serverLog(LL_WARNING,\n                \"Sentinel config from STDIN not allowed.\");\n            serverLog(LL_WARNING,\n                \"Sentinel needs config file on disk to save state.  Exiting...\");\n            exit(1);\n        }\n        resetServerSaveParams();\n        loadServerConfig(configfile,options);\n        sdsfree(options);\n    }\n\n    server.supervised = redisIsSupervised(server.supervised_mode);\n    int background = server.daemonize && !server.supervised;\n    if (background) daemonize();\n\n    serverLog(LL_WARNING, \"oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo\");\n    serverLog(LL_WARNING,\n        \"Redis version=%s, bits=%d, commit=%s, modified=%d, pid=%d, just started\",\n            REDIS_VERSION,\n            (sizeof(long) == 8) ? 64 : 32,\n            redisGitSHA1(),\n            strtol(redisGitDirty(),NULL,10) > 0,\n            (int)getpid());\n\n    if (argc == 1) {\n        serverLog(LL_WARNING, \"Warning: no config file specified, using the default config. In order to specify a config file use %s /path/to/%s.conf\", argv[0], server.sentinel_mode ? \"sentinel\" : \"redis\");\n    } else {\n        serverLog(LL_WARNING, \"Configuration loaded\");\n    }\n\n    readOOMScoreAdj();\n    initServer();\n    if (background || server.pidfile) createPidFile();\n    redisSetProcTitle(argv[0]);\n    redisAsciiArt();\n    checkTcpBacklogSettings();\n\n    if (!server.sentinel_mode) {\n        /* Things not needed when running in Sentinel mode. */\n        serverLog(LL_WARNING,\"Server initialized\");\n    #ifdef __linux__\n        linuxMemoryWarnings();\n    #if defined (__arm64__)\n        int ret;\n        if ((ret = linuxMadvFreeForkBugCheck())) {\n            if (ret == 1)\n                serverLog(LL_WARNING,\"WARNING Your kernel has a bug that could lead to data corruption during background save. \"\n                                     \"Please upgrade to the latest stable kernel.\");\n            else\n                serverLog(LL_WARNING, \"Failed to test the kernel for a bug that could lead to data corruption during background save. \"\n                                      \"Your system could be affected, please report this error.\");\n            if (!checkIgnoreWarning(\"ARM64-COW-BUG\")) {\n                serverLog(LL_WARNING,\"Redis will now exit to prevent data corruption. \"\n                                     \"Note that it is possible to suppress this warning by setting the following config: ignore-warnings ARM64-COW-BUG\");\n                exit(1);\n            }\n        }\n    #endif /* __arm64__ */\n    #endif /* __linux__ */\n        moduleLoadFromQueue();\n        ACLLoadUsersAtStartup();\n        InitServerLast();\n        loadDataFromDisk();\n        if (server.cluster_enabled) {\n            if (verifyClusterConfigWithData() == C_ERR) {\n                serverLog(LL_WARNING,\n                    \"You can't have keys in a DB different than DB 0 when in \"\n                    \"Cluster mode. Exiting.\");\n                exit(1);\n            }\n        }\n        if (server.ipfd_count > 0 || server.tlsfd_count > 0)\n            serverLog(LL_NOTICE,\"Ready to accept connections\");\n        if (server.sofd > 0)\n            serverLog(LL_NOTICE,\"The server is now ready to accept connections at %s\", server.unixsocket);\n        if (server.supervised_mode == SUPERVISED_SYSTEMD) {\n            if (!server.masterhost) {\n                redisCommunicateSystemd(\"STATUS=Ready to accept connections\\n\");\n                redisCommunicateSystemd(\"READY=1\\n\");\n            } else {\n                redisCommunicateSystemd(\"STATUS=Waiting for MASTER <-> REPLICA sync\\n\");\n            }\n        }\n    } else {\n        InitServerLast();\n        sentinelIsRunning();\n        if (server.supervised_mode == SUPERVISED_SYSTEMD) {\n            redisCommunicateSystemd(\"STATUS=Ready to accept connections\\n\");\n            redisCommunicateSystemd(\"READY=1\\n\");\n        }\n    }\n\n    /* Warning the user about suspicious maxmemory setting. */\n    if (server.maxmemory > 0 && server.maxmemory < 1024*1024) {\n        serverLog(LL_WARNING,\"WARNING: You specified a maxmemory value that is less than 1MB (current value is %llu bytes). Are you sure this is what you really want?\", server.maxmemory);\n    }\n\n    redisSetCpuAffinity(server.server_cpulist);\n    setOOMScoreAdj(-1);\n\n    aeMain(server.el);\n    aeDeleteEventLoop(server.el);\n    return 0;\n}\n\n/* The End */\n", "/*\n * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef __REDIS_H\n#define __REDIS_H\n\n#include \"fmacros.h\"\n#include \"config.h\"\n#include \"solarisfixes.h\"\n#include \"rio.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <limits.h>\n#include <unistd.h>\n#include <errno.h>\n#include <inttypes.h>\n#include <pthread.h>\n#include <syslog.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <lua.h>\n#include <signal.h>\n\n#ifdef HAVE_LIBSYSTEMD\n#include <systemd/sd-daemon.h>\n#endif\n\ntypedef long long mstime_t; /* millisecond time type. */\ntypedef long long ustime_t; /* microsecond time type. */\n\n#include \"ae.h\"      /* Event driven programming library */\n#include \"sds.h\"     /* Dynamic safe strings */\n#include \"dict.h\"    /* Hash tables */\n#include \"adlist.h\"  /* Linked lists */\n#include \"zmalloc.h\" /* total memory usage aware version of malloc/free */\n#include \"anet.h\"    /* Networking the easy way */\n#include \"ziplist.h\" /* Compact list data structure */\n#include \"intset.h\"  /* Compact integer set structure */\n#include \"version.h\" /* Version macro */\n#include \"util.h\"    /* Misc functions useful in many places */\n#include \"latency.h\" /* Latency monitor API */\n#include \"sparkline.h\" /* ASCII graphs API */\n#include \"quicklist.h\"  /* Lists are encoded as linked lists of\n                           N-elements flat arrays */\n#include \"rax.h\"     /* Radix tree */\n#include \"connection.h\" /* Connection abstraction */\n\n#define REDISMODULE_CORE 1\n#include \"redismodule.h\"    /* Redis modules API defines. */\n\n/* Following includes allow test functions to be called from Redis main() */\n#include \"zipmap.h\"\n#include \"sha1.h\"\n#include \"endianconv.h\"\n#include \"crc64.h\"\n\n/* Error codes */\n#define C_OK                    0\n#define C_ERR                   -1\n\n/* Static server configuration */\n#define CONFIG_DEFAULT_HZ        10             /* Time interrupt calls/sec. */\n#define CONFIG_MIN_HZ            1\n#define CONFIG_MAX_HZ            500\n#define MAX_CLIENTS_PER_CLOCK_TICK 200          /* HZ is adapted based on that. */\n#define CONFIG_MAX_LINE    1024\n#define CRON_DBS_PER_CALL 16\n#define NET_MAX_WRITES_PER_EVENT (1024*64)\n#define PROTO_SHARED_SELECT_CMDS 10\n#define OBJ_SHARED_INTEGERS 10000\n#define OBJ_SHARED_BULKHDR_LEN 32\n#define LOG_MAX_LEN    1024 /* Default maximum length of syslog messages.*/\n#define AOF_REWRITE_ITEMS_PER_CMD 64\n#define AOF_READ_DIFF_INTERVAL_BYTES (1024*10)\n#define CONFIG_AUTHPASS_MAX_LEN 512\n#define CONFIG_RUN_ID_SIZE 40\n#define RDB_EOF_MARK_SIZE 40\n#define CONFIG_REPL_BACKLOG_MIN_SIZE (1024*16)          /* 16k */\n#define CONFIG_BGSAVE_RETRY_DELAY 5 /* Wait a few secs before trying again. */\n#define CONFIG_DEFAULT_PID_FILE \"/var/run/redis.pid\"\n#define CONFIG_DEFAULT_CLUSTER_CONFIG_FILE \"nodes.conf\"\n#define CONFIG_DEFAULT_UNIX_SOCKET_PERM 0\n#define CONFIG_DEFAULT_LOGFILE \"\"\n#define NET_IP_STR_LEN 46 /* INET6_ADDRSTRLEN is 46, but we need to be sure */\n#define NET_PEER_ID_LEN (NET_IP_STR_LEN+32) /* Must be enough for ip:port */\n#define CONFIG_BINDADDR_MAX 16\n#define CONFIG_MIN_RESERVED_FDS 32\n\n#define ACTIVE_EXPIRE_CYCLE_SLOW 0\n#define ACTIVE_EXPIRE_CYCLE_FAST 1\n\n/* Children process will exit with this status code to signal that the\n * process terminated without an error: this is useful in order to kill\n * a saving child (RDB or AOF one), without triggering in the parent the\n * write protection that is normally turned on on write errors.\n * Usually children that are terminated with SIGUSR1 will exit with this\n * special code. */\n#define SERVER_CHILD_NOERROR_RETVAL    255\n\n/* Instantaneous metrics tracking. */\n#define STATS_METRIC_SAMPLES 16     /* Number of samples per metric. */\n#define STATS_METRIC_COMMAND 0      /* Number of commands executed. */\n#define STATS_METRIC_NET_INPUT 1    /* Bytes read to network .*/\n#define STATS_METRIC_NET_OUTPUT 2   /* Bytes written to network. */\n#define STATS_METRIC_COUNT 3\n\n/* Protocol and I/O related defines */\n#define PROTO_MAX_QUERYBUF_LEN  (1024*1024*1024) /* 1GB max query buffer. */\n#define PROTO_IOBUF_LEN         (1024*16)  /* Generic I/O buffer size */\n#define PROTO_REPLY_CHUNK_BYTES (16*1024) /* 16k output buffer */\n#define PROTO_INLINE_MAX_SIZE   (1024*64) /* Max size of inline reads */\n#define PROTO_MBULK_BIG_ARG     (1024*32)\n#define LONG_STR_SIZE      21          /* Bytes needed for long -> str + '\\0' */\n#define REDIS_AUTOSYNC_BYTES (1024*1024*32) /* fdatasync every 32MB */\n\n#define LIMIT_PENDING_QUERYBUF (4*1024*1024) /* 4mb */\n\n/* When configuring the server eventloop, we setup it so that the total number\n * of file descriptors we can handle are server.maxclients + RESERVED_FDS +\n * a few more to stay safe. Since RESERVED_FDS defaults to 32, we add 96\n * in order to make sure of not over provisioning more than 128 fds. */\n#define CONFIG_FDSET_INCR (CONFIG_MIN_RESERVED_FDS+96)\n\n/* OOM Score Adjustment classes. */\n#define CONFIG_OOM_MASTER 0\n#define CONFIG_OOM_REPLICA 1\n#define CONFIG_OOM_BGCHILD 2\n#define CONFIG_OOM_COUNT 3\n\nextern int configOOMScoreAdjValuesDefaults[CONFIG_OOM_COUNT];\n\n/* Hash table parameters */\n#define HASHTABLE_MIN_FILL        10      /* Minimal hash table fill 10% */\n\n/* Command flags. Please check the command table defined in the server.c file\n * for more information about the meaning of every flag. */\n#define CMD_WRITE (1ULL<<0)            /* \"write\" flag */\n#define CMD_READONLY (1ULL<<1)         /* \"read-only\" flag */\n#define CMD_DENYOOM (1ULL<<2)          /* \"use-memory\" flag */\n#define CMD_MODULE (1ULL<<3)           /* Command exported by module. */\n#define CMD_ADMIN (1ULL<<4)            /* \"admin\" flag */\n#define CMD_PUBSUB (1ULL<<5)           /* \"pub-sub\" flag */\n#define CMD_NOSCRIPT (1ULL<<6)         /* \"no-script\" flag */\n#define CMD_RANDOM (1ULL<<7)           /* \"random\" flag */\n#define CMD_SORT_FOR_SCRIPT (1ULL<<8)  /* \"to-sort\" flag */\n#define CMD_LOADING (1ULL<<9)          /* \"ok-loading\" flag */\n#define CMD_STALE (1ULL<<10)           /* \"ok-stale\" flag */\n#define CMD_SKIP_MONITOR (1ULL<<11)    /* \"no-monitor\" flag */\n#define CMD_SKIP_SLOWLOG (1ULL<<12)    /* \"no-slowlog\" flag */\n#define CMD_ASKING (1ULL<<13)          /* \"cluster-asking\" flag */\n#define CMD_FAST (1ULL<<14)            /* \"fast\" flag */\n#define CMD_NO_AUTH (1ULL<<15)         /* \"no-auth\" flag */\n\n/* Command flags used by the module system. */\n#define CMD_MODULE_GETKEYS (1ULL<<16)  /* Use the modules getkeys interface. */\n#define CMD_MODULE_NO_CLUSTER (1ULL<<17) /* Deny on Redis Cluster. */\n\n/* Command flags that describe ACLs categories. */\n#define CMD_CATEGORY_KEYSPACE (1ULL<<18)\n#define CMD_CATEGORY_READ (1ULL<<19)\n#define CMD_CATEGORY_WRITE (1ULL<<20)\n#define CMD_CATEGORY_SET (1ULL<<21)\n#define CMD_CATEGORY_SORTEDSET (1ULL<<22)\n#define CMD_CATEGORY_LIST (1ULL<<23)\n#define CMD_CATEGORY_HASH (1ULL<<24)\n#define CMD_CATEGORY_STRING (1ULL<<25)\n#define CMD_CATEGORY_BITMAP (1ULL<<26)\n#define CMD_CATEGORY_HYPERLOGLOG (1ULL<<27)\n#define CMD_CATEGORY_GEO (1ULL<<28)\n#define CMD_CATEGORY_STREAM (1ULL<<29)\n#define CMD_CATEGORY_PUBSUB (1ULL<<30)\n#define CMD_CATEGORY_ADMIN (1ULL<<31)\n#define CMD_CATEGORY_FAST (1ULL<<32)\n#define CMD_CATEGORY_SLOW (1ULL<<33)\n#define CMD_CATEGORY_BLOCKING (1ULL<<34)\n#define CMD_CATEGORY_DANGEROUS (1ULL<<35)\n#define CMD_CATEGORY_CONNECTION (1ULL<<36)\n#define CMD_CATEGORY_TRANSACTION (1ULL<<37)\n#define CMD_CATEGORY_SCRIPTING (1ULL<<38)\n\n/* AOF states */\n#define AOF_OFF 0             /* AOF is off */\n#define AOF_ON 1              /* AOF is on */\n#define AOF_WAIT_REWRITE 2    /* AOF waits rewrite to start appending */\n\n/* Client flags */\n#define CLIENT_SLAVE (1<<0)   /* This client is a repliaca */\n#define CLIENT_MASTER (1<<1)  /* This client is a master */\n#define CLIENT_MONITOR (1<<2) /* This client is a slave monitor, see MONITOR */\n#define CLIENT_MULTI (1<<3)   /* This client is in a MULTI context */\n#define CLIENT_BLOCKED (1<<4) /* The client is waiting in a blocking operation */\n#define CLIENT_DIRTY_CAS (1<<5) /* Watched keys modified. EXEC will fail. */\n#define CLIENT_CLOSE_AFTER_REPLY (1<<6) /* Close after writing entire reply. */\n#define CLIENT_UNBLOCKED (1<<7) /* This client was unblocked and is stored in\n                                  server.unblocked_clients */\n#define CLIENT_LUA (1<<8) /* This is a non connected client used by Lua */\n#define CLIENT_ASKING (1<<9)     /* Client issued the ASKING command */\n#define CLIENT_CLOSE_ASAP (1<<10)/* Close this client ASAP */\n#define CLIENT_UNIX_SOCKET (1<<11) /* Client connected via Unix domain socket */\n#define CLIENT_DIRTY_EXEC (1<<12)  /* EXEC will fail for errors while queueing */\n#define CLIENT_MASTER_FORCE_REPLY (1<<13)  /* Queue replies even if is master */\n#define CLIENT_FORCE_AOF (1<<14)   /* Force AOF propagation of current cmd. */\n#define CLIENT_FORCE_REPL (1<<15)  /* Force replication of current cmd. */\n#define CLIENT_PRE_PSYNC (1<<16)   /* Instance don't understand PSYNC. */\n#define CLIENT_READONLY (1<<17)    /* Cluster client is in read-only state. */\n#define CLIENT_PUBSUB (1<<18)      /* Client is in Pub/Sub mode. */\n#define CLIENT_PREVENT_AOF_PROP (1<<19)  /* Don't propagate to AOF. */\n#define CLIENT_PREVENT_REPL_PROP (1<<20)  /* Don't propagate to slaves. */\n#define CLIENT_PREVENT_PROP (CLIENT_PREVENT_AOF_PROP|CLIENT_PREVENT_REPL_PROP)\n#define CLIENT_PENDING_WRITE (1<<21) /* Client has output to send but a write\n                                        handler is yet not installed. */\n#define CLIENT_REPLY_OFF (1<<22)   /* Don't send replies to client. */\n#define CLIENT_REPLY_SKIP_NEXT (1<<23)  /* Set CLIENT_REPLY_SKIP for next cmd */\n#define CLIENT_REPLY_SKIP (1<<24)  /* Don't send just this reply. */\n#define CLIENT_LUA_DEBUG (1<<25)  /* Run EVAL in debug mode. */\n#define CLIENT_LUA_DEBUG_SYNC (1<<26)  /* EVAL debugging without fork() */\n#define CLIENT_MODULE (1<<27) /* Non connected client used by some module. */\n#define CLIENT_PROTECTED (1<<28) /* Client should not be freed for now. */\n#define CLIENT_PENDING_READ (1<<29) /* The client has pending reads and was put\n                                       in the list of clients we can read\n                                       from. */\n#define CLIENT_PENDING_COMMAND (1<<30) /* Used in threaded I/O to signal after\n                                          we return single threaded that the\n                                          client has already pending commands\n                                          to be executed. */\n#define CLIENT_TRACKING (1ULL<<31) /* Client enabled keys tracking in order to\n                                   perform client side caching. */\n#define CLIENT_TRACKING_BROKEN_REDIR (1ULL<<32) /* Target client is invalid. */\n#define CLIENT_TRACKING_BCAST (1ULL<<33) /* Tracking in BCAST mode. */\n#define CLIENT_TRACKING_OPTIN (1ULL<<34)  /* Tracking in opt-in mode. */\n#define CLIENT_TRACKING_OPTOUT (1ULL<<35) /* Tracking in opt-out mode. */\n#define CLIENT_TRACKING_CACHING (1ULL<<36) /* CACHING yes/no was given,\n                                              depending on optin/optout mode. */\n#define CLIENT_TRACKING_NOLOOP (1ULL<<37) /* Don't send invalidation messages\n                                             about writes performed by myself.*/\n#define CLIENT_IN_TO_TABLE (1ULL<<38) /* This client is in the timeout table. */\n#define CLIENT_PROTOCOL_ERROR (1ULL<<39) /* Protocol error chatting with it. */\n#define CLIENT_CLOSE_AFTER_COMMAND (1ULL<<40) /* Close after executing commands\n                                               * and writing entire reply. */\n\n/* Client block type (btype field in client structure)\n * if CLIENT_BLOCKED flag is set. */\n#define BLOCKED_NONE 0    /* Not blocked, no CLIENT_BLOCKED flag set. */\n#define BLOCKED_LIST 1    /* BLPOP & co. */\n#define BLOCKED_WAIT 2    /* WAIT for synchronous replication. */\n#define BLOCKED_MODULE 3  /* Blocked by a loadable module. */\n#define BLOCKED_STREAM 4  /* XREAD. */\n#define BLOCKED_ZSET 5    /* BZPOP et al. */\n#define BLOCKED_NUM 6     /* Number of blocked states. */\n\n/* Client request types */\n#define PROTO_REQ_INLINE 1\n#define PROTO_REQ_MULTIBULK 2\n\n/* Client classes for client limits, currently used only for\n * the max-client-output-buffer limit implementation. */\n#define CLIENT_TYPE_NORMAL 0 /* Normal req-reply clients + MONITORs */\n#define CLIENT_TYPE_SLAVE 1  /* Slaves. */\n#define CLIENT_TYPE_PUBSUB 2 /* Clients subscribed to PubSub channels. */\n#define CLIENT_TYPE_MASTER 3 /* Master. */\n#define CLIENT_TYPE_COUNT 4  /* Total number of client types. */\n#define CLIENT_TYPE_OBUF_COUNT 3 /* Number of clients to expose to output\n                                    buffer configuration. Just the first\n                                    three: normal, slave, pubsub. */\n\n/* Slave replication state. Used in server.repl_state for slaves to remember\n * what to do next. */\n#define REPL_STATE_NONE 0 /* No active replication */\n#define REPL_STATE_CONNECT 1 /* Must connect to master */\n#define REPL_STATE_CONNECTING 2 /* Connecting to master */\n/* --- Handshake states, must be ordered --- */\n#define REPL_STATE_RECEIVE_PONG 3 /* Wait for PING reply */\n#define REPL_STATE_SEND_AUTH 4 /* Send AUTH to master */\n#define REPL_STATE_RECEIVE_AUTH 5 /* Wait for AUTH reply */\n#define REPL_STATE_SEND_PORT 6 /* Send REPLCONF listening-port */\n#define REPL_STATE_RECEIVE_PORT 7 /* Wait for REPLCONF reply */\n#define REPL_STATE_SEND_IP 8 /* Send REPLCONF ip-address */\n#define REPL_STATE_RECEIVE_IP 9 /* Wait for REPLCONF reply */\n#define REPL_STATE_SEND_CAPA 10 /* Send REPLCONF capa */\n#define REPL_STATE_RECEIVE_CAPA 11 /* Wait for REPLCONF reply */\n#define REPL_STATE_SEND_PSYNC 12 /* Send PSYNC */\n#define REPL_STATE_RECEIVE_PSYNC 13 /* Wait for PSYNC reply */\n/* --- End of handshake states --- */\n#define REPL_STATE_TRANSFER 14 /* Receiving .rdb from master */\n#define REPL_STATE_CONNECTED 15 /* Connected to master */\n\n/* State of slaves from the POV of the master. Used in client->replstate.\n * In SEND_BULK and ONLINE state the slave receives new updates\n * in its output queue. In the WAIT_BGSAVE states instead the server is waiting\n * to start the next background saving in order to send updates to it. */\n#define SLAVE_STATE_WAIT_BGSAVE_START 6 /* We need to produce a new RDB file. */\n#define SLAVE_STATE_WAIT_BGSAVE_END 7 /* Waiting RDB file creation to finish. */\n#define SLAVE_STATE_SEND_BULK 8 /* Sending RDB file to slave. */\n#define SLAVE_STATE_ONLINE 9 /* RDB file transmitted, sending just updates. */\n\n/* Slave capabilities. */\n#define SLAVE_CAPA_NONE 0\n#define SLAVE_CAPA_EOF (1<<0)    /* Can parse the RDB EOF streaming format. */\n#define SLAVE_CAPA_PSYNC2 (1<<1) /* Supports PSYNC2 protocol. */\n\n/* Synchronous read timeout - slave side */\n#define CONFIG_REPL_SYNCIO_TIMEOUT 5\n\n/* List related stuff */\n#define LIST_HEAD 0\n#define LIST_TAIL 1\n#define ZSET_MIN 0\n#define ZSET_MAX 1\n\n/* Sort operations */\n#define SORT_OP_GET 0\n\n/* Log levels */\n#define LL_DEBUG 0\n#define LL_VERBOSE 1\n#define LL_NOTICE 2\n#define LL_WARNING 3\n#define LL_RAW (1<<10) /* Modifier to log without timestamp */\n\n/* Supervision options */\n#define SUPERVISED_NONE 0\n#define SUPERVISED_AUTODETECT 1\n#define SUPERVISED_SYSTEMD 2\n#define SUPERVISED_UPSTART 3\n\n/* Anti-warning macro... */\n#define UNUSED(V) ((void) V)\n\n#define ZSKIPLIST_MAXLEVEL 32 /* Should be enough for 2^64 elements */\n#define ZSKIPLIST_P 0.25      /* Skiplist P = 1/4 */\n\n/* Append only defines */\n#define AOF_FSYNC_NO 0\n#define AOF_FSYNC_ALWAYS 1\n#define AOF_FSYNC_EVERYSEC 2\n\n/* Replication diskless load defines */\n#define REPL_DISKLESS_LOAD_DISABLED 0\n#define REPL_DISKLESS_LOAD_WHEN_DB_EMPTY 1\n#define REPL_DISKLESS_LOAD_SWAPDB 2\n\n/* TLS Client Authentication */\n#define TLS_CLIENT_AUTH_NO 0\n#define TLS_CLIENT_AUTH_YES 1\n#define TLS_CLIENT_AUTH_OPTIONAL 2\n\n/* Sets operations codes */\n#define SET_OP_UNION 0\n#define SET_OP_DIFF 1\n#define SET_OP_INTER 2\n\n/* oom-score-adj defines */\n#define OOM_SCORE_ADJ_NO 0\n#define OOM_SCORE_RELATIVE 1\n#define OOM_SCORE_ADJ_ABSOLUTE 2\n\n/* Redis maxmemory strategies. Instead of using just incremental number\n * for this defines, we use a set of flags so that testing for certain\n * properties common to multiple policies is faster. */\n#define MAXMEMORY_FLAG_LRU (1<<0)\n#define MAXMEMORY_FLAG_LFU (1<<1)\n#define MAXMEMORY_FLAG_ALLKEYS (1<<2)\n#define MAXMEMORY_FLAG_NO_SHARED_INTEGERS \\\n    (MAXMEMORY_FLAG_LRU|MAXMEMORY_FLAG_LFU)\n\n#define MAXMEMORY_VOLATILE_LRU ((0<<8)|MAXMEMORY_FLAG_LRU)\n#define MAXMEMORY_VOLATILE_LFU ((1<<8)|MAXMEMORY_FLAG_LFU)\n#define MAXMEMORY_VOLATILE_TTL (2<<8)\n#define MAXMEMORY_VOLATILE_RANDOM (3<<8)\n#define MAXMEMORY_ALLKEYS_LRU ((4<<8)|MAXMEMORY_FLAG_LRU|MAXMEMORY_FLAG_ALLKEYS)\n#define MAXMEMORY_ALLKEYS_LFU ((5<<8)|MAXMEMORY_FLAG_LFU|MAXMEMORY_FLAG_ALLKEYS)\n#define MAXMEMORY_ALLKEYS_RANDOM ((6<<8)|MAXMEMORY_FLAG_ALLKEYS)\n#define MAXMEMORY_NO_EVICTION (7<<8)\n\n/* Units */\n#define UNIT_SECONDS 0\n#define UNIT_MILLISECONDS 1\n\n/* SHUTDOWN flags */\n#define SHUTDOWN_NOFLAGS 0      /* No flags. */\n#define SHUTDOWN_SAVE 1         /* Force SAVE on SHUTDOWN even if no save\n                                   points are configured. */\n#define SHUTDOWN_NOSAVE 2       /* Don't SAVE on SHUTDOWN. */\n\n/* Command call flags, see call() function */\n#define CMD_CALL_NONE 0\n#define CMD_CALL_SLOWLOG (1<<0)\n#define CMD_CALL_STATS (1<<1)\n#define CMD_CALL_PROPAGATE_AOF (1<<2)\n#define CMD_CALL_PROPAGATE_REPL (1<<3)\n#define CMD_CALL_PROPAGATE (CMD_CALL_PROPAGATE_AOF|CMD_CALL_PROPAGATE_REPL)\n#define CMD_CALL_FULL (CMD_CALL_SLOWLOG | CMD_CALL_STATS | CMD_CALL_PROPAGATE)\n#define CMD_CALL_NOWRAP (1<<4)  /* Don't wrap also propagate array into\n                                   MULTI/EXEC: the caller will handle it.  */\n\n/* Command propagation flags, see propagate() function */\n#define PROPAGATE_NONE 0\n#define PROPAGATE_AOF 1\n#define PROPAGATE_REPL 2\n\n/* RDB active child save type. */\n#define RDB_CHILD_TYPE_NONE 0\n#define RDB_CHILD_TYPE_DISK 1     /* RDB is written to disk. */\n#define RDB_CHILD_TYPE_SOCKET 2   /* RDB is written to slave socket. */\n\n/* Keyspace changes notification classes. Every class is associated with a\n * character for configuration purposes. */\n#define NOTIFY_KEYSPACE (1<<0)    /* K */\n#define NOTIFY_KEYEVENT (1<<1)    /* E */\n#define NOTIFY_GENERIC (1<<2)     /* g */\n#define NOTIFY_STRING (1<<3)      /* $ */\n#define NOTIFY_LIST (1<<4)        /* l */\n#define NOTIFY_SET (1<<5)         /* s */\n#define NOTIFY_HASH (1<<6)        /* h */\n#define NOTIFY_ZSET (1<<7)        /* z */\n#define NOTIFY_EXPIRED (1<<8)     /* x */\n#define NOTIFY_EVICTED (1<<9)     /* e */\n#define NOTIFY_STREAM (1<<10)     /* t */\n#define NOTIFY_KEY_MISS (1<<11)   /* m (Note: This one is excluded from NOTIFY_ALL on purpose) */\n#define NOTIFY_LOADED (1<<12)     /* module only key space notification, indicate a key loaded from rdb */\n#define NOTIFY_ALL (NOTIFY_GENERIC | NOTIFY_STRING | NOTIFY_LIST | NOTIFY_SET | NOTIFY_HASH | NOTIFY_ZSET | NOTIFY_EXPIRED | NOTIFY_EVICTED | NOTIFY_STREAM) /* A flag */\n\n/* Get the first bind addr or NULL */\n#define NET_FIRST_BIND_ADDR (server.bindaddr_count ? server.bindaddr[0] : NULL)\n\n/* Using the following macro you can run code inside serverCron() with the\n * specified period, specified in milliseconds.\n * The actual resolution depends on server.hz. */\n#define run_with_period(_ms_) if ((_ms_ <= 1000/server.hz) || !(server.cronloops%((_ms_)/(1000/server.hz))))\n\n/* We can print the stacktrace, so our assert is defined this way: */\n#define serverAssertWithInfo(_c,_o,_e) ((_e)?(void)0 : (_serverAssertWithInfo(_c,_o,#_e,__FILE__,__LINE__),_exit(1)))\n#define serverAssert(_e) ((_e)?(void)0 : (_serverAssert(#_e,__FILE__,__LINE__),_exit(1)))\n#define serverPanic(...) _serverPanic(__FILE__,__LINE__,__VA_ARGS__),_exit(1)\n\n/*-----------------------------------------------------------------------------\n * Data types\n *----------------------------------------------------------------------------*/\n\n/* A redis object, that is a type able to hold a string / list / set */\n\n/* The actual Redis Object */\n#define OBJ_STRING 0    /* String object. */\n#define OBJ_LIST 1      /* List object. */\n#define OBJ_SET 2       /* Set object. */\n#define OBJ_ZSET 3      /* Sorted set object. */\n#define OBJ_HASH 4      /* Hash object. */\n\n/* The \"module\" object type is a special one that signals that the object\n * is one directly managed by a Redis module. In this case the value points\n * to a moduleValue struct, which contains the object value (which is only\n * handled by the module itself) and the RedisModuleType struct which lists\n * function pointers in order to serialize, deserialize, AOF-rewrite and\n * free the object.\n *\n * Inside the RDB file, module types are encoded as OBJ_MODULE followed\n * by a 64 bit module type ID, which has a 54 bits module-specific signature\n * in order to dispatch the loading to the right module, plus a 10 bits\n * encoding version. */\n#define OBJ_MODULE 5    /* Module object. */\n#define OBJ_STREAM 6    /* Stream object. */\n\n/* Extract encver / signature from a module type ID. */\n#define REDISMODULE_TYPE_ENCVER_BITS 10\n#define REDISMODULE_TYPE_ENCVER_MASK ((1<<REDISMODULE_TYPE_ENCVER_BITS)-1)\n#define REDISMODULE_TYPE_ENCVER(id) (id & REDISMODULE_TYPE_ENCVER_MASK)\n#define REDISMODULE_TYPE_SIGN(id) ((id & ~((uint64_t)REDISMODULE_TYPE_ENCVER_MASK)) >>REDISMODULE_TYPE_ENCVER_BITS)\n\n/* Bit flags for moduleTypeAuxSaveFunc */\n#define REDISMODULE_AUX_BEFORE_RDB (1<<0)\n#define REDISMODULE_AUX_AFTER_RDB (1<<1)\n\nstruct RedisModule;\nstruct RedisModuleIO;\nstruct RedisModuleDigest;\nstruct RedisModuleCtx;\nstruct redisObject;\n\n/* Each module type implementation should export a set of methods in order\n * to serialize and deserialize the value in the RDB file, rewrite the AOF\n * log, create the digest for \"DEBUG DIGEST\", and free the value when a key\n * is deleted. */\ntypedef void *(*moduleTypeLoadFunc)(struct RedisModuleIO *io, int encver);\ntypedef void (*moduleTypeSaveFunc)(struct RedisModuleIO *io, void *value);\ntypedef int (*moduleTypeAuxLoadFunc)(struct RedisModuleIO *rdb, int encver, int when);\ntypedef void (*moduleTypeAuxSaveFunc)(struct RedisModuleIO *rdb, int when);\ntypedef void (*moduleTypeRewriteFunc)(struct RedisModuleIO *io, struct redisObject *key, void *value);\ntypedef void (*moduleTypeDigestFunc)(struct RedisModuleDigest *digest, void *value);\ntypedef size_t (*moduleTypeMemUsageFunc)(const void *value);\ntypedef void (*moduleTypeFreeFunc)(void *value);\n\n/* A callback that is called when the client authentication changes. This\n * needs to be exposed since you can't cast a function pointer to (void *) */\ntypedef void (*RedisModuleUserChangedFunc) (uint64_t client_id, void *privdata);\n\n\n/* The module type, which is referenced in each value of a given type, defines\n * the methods and links to the module exporting the type. */\ntypedef struct RedisModuleType {\n    uint64_t id; /* Higher 54 bits of type ID + 10 lower bits of encoding ver. */\n    struct RedisModule *module;\n    moduleTypeLoadFunc rdb_load;\n    moduleTypeSaveFunc rdb_save;\n    moduleTypeRewriteFunc aof_rewrite;\n    moduleTypeMemUsageFunc mem_usage;\n    moduleTypeDigestFunc digest;\n    moduleTypeFreeFunc free;\n    moduleTypeAuxLoadFunc aux_load;\n    moduleTypeAuxSaveFunc aux_save;\n    int aux_save_triggers;\n    char name[10]; /* 9 bytes name + null term. Charset: A-Z a-z 0-9 _- */\n} moduleType;\n\n/* In Redis objects 'robj' structures of type OBJ_MODULE, the value pointer\n * is set to the following structure, referencing the moduleType structure\n * in order to work with the value, and at the same time providing a raw\n * pointer to the value, as created by the module commands operating with\n * the module type.\n *\n * So for example in order to free such a value, it is possible to use\n * the following code:\n *\n *  if (robj->type == OBJ_MODULE) {\n *      moduleValue *mt = robj->ptr;\n *      mt->type->free(mt->value);\n *      zfree(mt); // We need to release this in-the-middle struct as well.\n *  }\n */\ntypedef struct moduleValue {\n    moduleType *type;\n    void *value;\n} moduleValue;\n\n/* This is a wrapper for the 'rio' streams used inside rdb.c in Redis, so that\n * the user does not have to take the total count of the written bytes nor\n * to care about error conditions. */\ntypedef struct RedisModuleIO {\n    size_t bytes;       /* Bytes read / written so far. */\n    rio *rio;           /* Rio stream. */\n    moduleType *type;   /* Module type doing the operation. */\n    int error;          /* True if error condition happened. */\n    int ver;            /* Module serialization version: 1 (old),\n                         * 2 (current version with opcodes annotation). */\n    struct RedisModuleCtx *ctx; /* Optional context, see RM_GetContextFromIO()*/\n    struct redisObject *key;    /* Optional name of key processed */\n} RedisModuleIO;\n\n/* Macro to initialize an IO context. Note that the 'ver' field is populated\n * inside rdb.c according to the version of the value to load. */\n#define moduleInitIOContext(iovar,mtype,rioptr,keyptr) do { \\\n    iovar.rio = rioptr; \\\n    iovar.type = mtype; \\\n    iovar.bytes = 0; \\\n    iovar.error = 0; \\\n    iovar.ver = 0; \\\n    iovar.key = keyptr; \\\n    iovar.ctx = NULL; \\\n} while(0);\n\n/* This is a structure used to export DEBUG DIGEST capabilities to Redis\n * modules. We want to capture both the ordered and unordered elements of\n * a data structure, so that a digest can be created in a way that correctly\n * reflects the values. See the DEBUG DIGEST command implementation for more\n * background. */\ntypedef struct RedisModuleDigest {\n    unsigned char o[20];    /* Ordered elements. */\n    unsigned char x[20];    /* Xored elements. */\n} RedisModuleDigest;\n\n/* Just start with a digest composed of all zero bytes. */\n#define moduleInitDigestContext(mdvar) do { \\\n    memset(mdvar.o,0,sizeof(mdvar.o)); \\\n    memset(mdvar.x,0,sizeof(mdvar.x)); \\\n} while(0);\n\n/* Objects encoding. Some kind of objects like Strings and Hashes can be\n * internally represented in multiple ways. The 'encoding' field of the object\n * is set to one of this fields for this object. */\n#define OBJ_ENCODING_RAW 0     /* Raw representation */\n#define OBJ_ENCODING_INT 1     /* Encoded as integer */\n#define OBJ_ENCODING_HT 2      /* Encoded as hash table */\n#define OBJ_ENCODING_ZIPMAP 3  /* Encoded as zipmap */\n#define OBJ_ENCODING_LINKEDLIST 4 /* No longer used: old list encoding. */\n#define OBJ_ENCODING_ZIPLIST 5 /* Encoded as ziplist */\n#define OBJ_ENCODING_INTSET 6  /* Encoded as intset */\n#define OBJ_ENCODING_SKIPLIST 7  /* Encoded as skiplist */\n#define OBJ_ENCODING_EMBSTR 8  /* Embedded sds string encoding */\n#define OBJ_ENCODING_QUICKLIST 9 /* Encoded as linked list of ziplists */\n#define OBJ_ENCODING_STREAM 10 /* Encoded as a radix tree of listpacks */\n\n#define LRU_BITS 24\n#define LRU_CLOCK_MAX ((1<<LRU_BITS)-1) /* Max value of obj->lru */\n#define LRU_CLOCK_RESOLUTION 1000 /* LRU clock resolution in ms */\n\n#define OBJ_SHARED_REFCOUNT INT_MAX     /* Global object never destroyed. */\n#define OBJ_STATIC_REFCOUNT (INT_MAX-1) /* Object allocated in the stack. */\n#define OBJ_FIRST_SPECIAL_REFCOUNT OBJ_STATIC_REFCOUNT\ntypedef struct redisObject {\n    unsigned type:4;\n    unsigned encoding:4;\n    unsigned lru:LRU_BITS; /* LRU time (relative to global lru_clock) or\n                            * LFU data (least significant 8 bits frequency\n                            * and most significant 16 bits access time). */\n    int refcount;\n    void *ptr;\n} robj;\n\n/* The a string name for an object's type as listed above\n * Native types are checked against the OBJ_STRING, OBJ_LIST, OBJ_* defines,\n * and Module types have their registered name returned. */\nchar *getObjectTypeName(robj*);\n\n/* Macro used to initialize a Redis object allocated on the stack.\n * Note that this macro is taken near the structure definition to make sure\n * we'll update it when the structure is changed, to avoid bugs like\n * bug #85 introduced exactly in this way. */\n#define initStaticStringObject(_var,_ptr) do { \\\n    _var.refcount = OBJ_STATIC_REFCOUNT; \\\n    _var.type = OBJ_STRING; \\\n    _var.encoding = OBJ_ENCODING_RAW; \\\n    _var.ptr = _ptr; \\\n} while(0)\n\nstruct evictionPoolEntry; /* Defined in evict.c */\n\n/* This structure is used in order to represent the output buffer of a client,\n * which is actually a linked list of blocks like that, that is: client->reply. */\ntypedef struct clientReplyBlock {\n    size_t size, used;\n    char buf[];\n} clientReplyBlock;\n\n/* Redis database representation. There are multiple databases identified\n * by integers from 0 (the default database) up to the max configured\n * database. The database number is the 'id' field in the structure. */\ntypedef struct redisDb {\n    dict *dict;                 /* The keyspace for this DB */\n    dict *expires;              /* Timeout of keys with a timeout set */\n    dict *blocking_keys;        /* Keys with clients waiting for data (BLPOP)*/\n    dict *ready_keys;           /* Blocked keys that received a PUSH */\n    dict *watched_keys;         /* WATCHED keys for MULTI/EXEC CAS */\n    int id;                     /* Database ID */\n    long long avg_ttl;          /* Average TTL, just for stats */\n    unsigned long expires_cursor; /* Cursor of the active expire cycle. */\n    list *defrag_later;         /* List of key names to attempt to defrag one by one, gradually. */\n} redisDb;\n\n/* Declare database backup that include redis main DBs and slots to keys map.\n * Definition is in db.c. We can't define it here since we define CLUSTER_SLOTS\n * in cluster.h. */\ntypedef struct dbBackup dbBackup;\n\n/* Client MULTI/EXEC state */\ntypedef struct multiCmd {\n    robj **argv;\n    int argc;\n    struct redisCommand *cmd;\n} multiCmd;\n\ntypedef struct multiState {\n    multiCmd *commands;     /* Array of MULTI commands */\n    int count;              /* Total number of MULTI commands */\n    int cmd_flags;          /* The accumulated command flags OR-ed together.\n                               So if at least a command has a given flag, it\n                               will be set in this field. */\n    int cmd_inv_flags;      /* Same as cmd_flags, OR-ing the ~flags. so that it\n                               is possible to know if all the commands have a\n                               certain flag. */\n    int minreplicas;        /* MINREPLICAS for synchronous replication */\n    time_t minreplicas_timeout; /* MINREPLICAS timeout as unixtime. */\n} multiState;\n\n/* This structure holds the blocking operation state for a client.\n * The fields used depend on client->btype. */\ntypedef struct blockingState {\n    /* Generic fields. */\n    mstime_t timeout;       /* Blocking operation timeout. If UNIX current time\n                             * is > timeout then the operation timed out. */\n\n    /* BLOCKED_LIST, BLOCKED_ZSET and BLOCKED_STREAM */\n    dict *keys;             /* The keys we are waiting to terminate a blocking\n                             * operation such as BLPOP or XREAD. Or NULL. */\n    robj *target;           /* The key that should receive the element,\n                             * for BRPOPLPUSH. */\n\n    /* BLOCK_STREAM */\n    size_t xread_count;     /* XREAD COUNT option. */\n    robj *xread_group;      /* XREADGROUP group name. */\n    robj *xread_consumer;   /* XREADGROUP consumer name. */\n    mstime_t xread_retry_time, xread_retry_ttl;\n    int xread_group_noack;\n\n    /* BLOCKED_WAIT */\n    int numreplicas;        /* Number of replicas we are waiting for ACK. */\n    long long reploffset;   /* Replication offset to reach. */\n\n    /* BLOCKED_MODULE */\n    void *module_blocked_handle; /* RedisModuleBlockedClient structure.\n                                    which is opaque for the Redis core, only\n                                    handled in module.c. */\n} blockingState;\n\n/* The following structure represents a node in the server.ready_keys list,\n * where we accumulate all the keys that had clients blocked with a blocking\n * operation such as B[LR]POP, but received new data in the context of the\n * last executed command.\n *\n * After the execution of every command or script, we run this list to check\n * if as a result we should serve data to clients blocked, unblocking them.\n * Note that server.ready_keys will not have duplicates as there dictionary\n * also called ready_keys in every structure representing a Redis database,\n * where we make sure to remember if a given key was already added in the\n * server.ready_keys list. */\ntypedef struct readyList {\n    redisDb *db;\n    robj *key;\n} readyList;\n\n/* This structure represents a Redis user. This is useful for ACLs, the\n * user is associated to the connection after the connection is authenticated.\n * If there is no associated user, the connection uses the default user. */\n#define USER_COMMAND_BITS_COUNT 1024    /* The total number of command bits\n                                           in the user structure. The last valid\n                                           command ID we can set in the user\n                                           is USER_COMMAND_BITS_COUNT-1. */\n#define USER_FLAG_ENABLED (1<<0)        /* The user is active. */\n#define USER_FLAG_DISABLED (1<<1)       /* The user is disabled. */\n#define USER_FLAG_ALLKEYS (1<<2)        /* The user can mention any key. */\n#define USER_FLAG_ALLCOMMANDS (1<<3)    /* The user can run all commands. */\n#define USER_FLAG_NOPASS      (1<<4)    /* The user requires no password, any\n                                           provided password will work. For the\n                                           default user, this also means that\n                                           no AUTH is needed, and every\n                                           connection is immediately\n                                           authenticated. */\ntypedef struct {\n    sds name;       /* The username as an SDS string. */\n    uint64_t flags; /* See USER_FLAG_* */\n\n    /* The bit in allowed_commands is set if this user has the right to\n     * execute this command. In commands having subcommands, if this bit is\n     * set, then all the subcommands are also available.\n     *\n     * If the bit for a given command is NOT set and the command has\n     * subcommands, Redis will also check allowed_subcommands in order to\n     * understand if the command can be executed. */\n    uint64_t allowed_commands[USER_COMMAND_BITS_COUNT/64];\n\n    /* This array points, for each command ID (corresponding to the command\n     * bit set in allowed_commands), to an array of SDS strings, terminated by\n     * a NULL pointer, with all the sub commands that can be executed for\n     * this command. When no subcommands matching is used, the field is just\n     * set to NULL to avoid allocating USER_COMMAND_BITS_COUNT pointers. */\n    sds **allowed_subcommands;\n    list *passwords; /* A list of SDS valid passwords for this user. */\n    list *patterns;  /* A list of allowed key patterns. If this field is NULL\n                        the user cannot mention any key in a command, unless\n                        the flag ALLKEYS is set in the user. */\n} user;\n\n/* With multiplexing we need to take per-client state.\n * Clients are taken in a linked list. */\n\n#define CLIENT_ID_AOF (UINT64_MAX) /* Reserved ID for the AOF client. If you\n                                      need more reserved IDs use UINT64_MAX-1,\n                                      -2, ... and so forth. */\n\ntypedef struct client {\n    uint64_t id;            /* Client incremental unique ID. */\n    connection *conn;\n    int resp;               /* RESP protocol version. Can be 2 or 3. */\n    redisDb *db;            /* Pointer to currently SELECTed DB. */\n    robj *name;             /* As set by CLIENT SETNAME. */\n    sds querybuf;           /* Buffer we use to accumulate client queries. */\n    size_t qb_pos;          /* The position we have read in querybuf. */\n    sds pending_querybuf;   /* If this client is flagged as master, this buffer\n                               represents the yet not applied portion of the\n                               replication stream that we are receiving from\n                               the master. */\n    size_t querybuf_peak;   /* Recent (100ms or more) peak of querybuf size. */\n    int argc;               /* Num of arguments of current command. */\n    robj **argv;            /* Arguments of current command. */\n    size_t argv_len_sum;    /* Sum of lengths of objects in argv list. */\n    struct redisCommand *cmd, *lastcmd;  /* Last command executed. */\n    user *user;             /* User associated with this connection. If the\n                               user is set to NULL the connection can do\n                               anything (admin). */\n    int reqtype;            /* Request protocol type: PROTO_REQ_* */\n    int multibulklen;       /* Number of multi bulk arguments left to read. */\n    long bulklen;           /* Length of bulk argument in multi bulk request. */\n    list *reply;            /* List of reply objects to send to the client. */\n    unsigned long long reply_bytes; /* Tot bytes of objects in reply list. */\n    size_t sentlen;         /* Amount of bytes already sent in the current\n                               buffer or object being sent. */\n    time_t ctime;           /* Client creation time. */\n    time_t lastinteraction; /* Time of the last interaction, used for timeout */\n    time_t obuf_soft_limit_reached_time;\n    uint64_t flags;         /* Client flags: CLIENT_* macros. */\n    int authenticated;      /* Needed when the default user requires auth. */\n    int replstate;          /* Replication state if this is a slave. */\n    int repl_put_online_on_ack; /* Install slave write handler on first ACK. */\n    int repldbfd;           /* Replication DB file descriptor. */\n    off_t repldboff;        /* Replication DB file offset. */\n    off_t repldbsize;       /* Replication DB file size. */\n    sds replpreamble;       /* Replication DB preamble. */\n    long long read_reploff; /* Read replication offset if this is a master. */\n    long long reploff;      /* Applied replication offset if this is a master. */\n    long long repl_ack_off; /* Replication ack offset, if this is a slave. */\n    long long repl_ack_time;/* Replication ack time, if this is a slave. */\n    long long repl_last_partial_write; /* The last time the server did a partial write from the RDB child pipe to this replica  */\n    long long psync_initial_offset; /* FULLRESYNC reply offset other slaves\n                                       copying this slave output buffer\n                                       should use. */\n    char replid[CONFIG_RUN_ID_SIZE+1]; /* Master replication ID (if master). */\n    int slave_listening_port; /* As configured with: REPLCONF listening-port */\n    char slave_ip[NET_IP_STR_LEN]; /* Optionally given by REPLCONF ip-address */\n    int slave_capa;         /* Slave capabilities: SLAVE_CAPA_* bitwise OR. */\n    multiState mstate;      /* MULTI/EXEC state */\n    int btype;              /* Type of blocking op if CLIENT_BLOCKED. */\n    blockingState bpop;     /* blocking state */\n    long long woff;         /* Last write global replication offset. */\n    list *watched_keys;     /* Keys WATCHED for MULTI/EXEC CAS */\n    dict *pubsub_channels;  /* channels a client is interested in (SUBSCRIBE) */\n    list *pubsub_patterns;  /* patterns a client is interested in (SUBSCRIBE) */\n    sds peerid;             /* Cached peer ID. */\n    listNode *client_list_node; /* list node in client list */\n    RedisModuleUserChangedFunc auth_callback; /* Module callback to execute\n                                               * when the authenticated user\n                                               * changes. */\n    void *auth_callback_privdata; /* Private data that is passed when the auth\n                                   * changed callback is executed. Opaque for\n                                   * Redis Core. */\n    void *auth_module;      /* The module that owns the callback, which is used\n                             * to disconnect the client if the module is\n                             * unloaded for cleanup. Opaque for Redis Core.*/\n\n    /* If this client is in tracking mode and this field is non zero,\n     * invalidation messages for keys fetched by this client will be send to\n     * the specified client ID. */\n    uint64_t client_tracking_redirection;\n    rax *client_tracking_prefixes; /* A dictionary of prefixes we are already\n                                      subscribed to in BCAST mode, in the\n                                      context of client side caching. */\n    /* In clientsCronTrackClientsMemUsage() we track the memory usage of\n     * each client and add it to the sum of all the clients of a given type,\n     * however we need to remember what was the old contribution of each\n     * client, and in which categoty the client was, in order to remove it\n     * before adding it the new value. */\n    uint64_t client_cron_last_memory_usage;\n    int      client_cron_last_memory_type;\n    /* Response buffer */\n    int bufpos;\n    char buf[PROTO_REPLY_CHUNK_BYTES];\n} client;\n\nstruct saveparam {\n    time_t seconds;\n    int changes;\n};\n\nstruct moduleLoadQueueEntry {\n    sds path;\n    int argc;\n    robj **argv;\n};\n\nstruct sharedObjectsStruct {\n    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *pong, *space,\n    *colon, *queued, *null[4], *nullarray[4], *emptymap[4], *emptyset[4],\n    *emptyarray, *wrongtypeerr, *nokeyerr, *syntaxerr, *sameobjecterr,\n    *outofrangeerr, *noscripterr, *loadingerr, *slowscripterr, *bgsaveerr,\n    *masterdownerr, *roslaveerr, *execaborterr, *noautherr, *noreplicaserr,\n    *busykeyerr, *oomerr, *plus, *messagebulk, *pmessagebulk, *subscribebulk,\n    *unsubscribebulk, *psubscribebulk, *punsubscribebulk, *del, *unlink,\n    *rpop, *lpop, *lpush, *rpoplpush, *zpopmin, *zpopmax, *emptyscan,\n    *multi, *exec,\n    *select[PROTO_SHARED_SELECT_CMDS],\n    *integers[OBJ_SHARED_INTEGERS],\n    *mbulkhdr[OBJ_SHARED_BULKHDR_LEN], /* \"*<value>\\r\\n\" */\n    *bulkhdr[OBJ_SHARED_BULKHDR_LEN];  /* \"$<value>\\r\\n\" */\n    sds minstring, maxstring;\n};\n\n/* ZSETs use a specialized version of Skiplists */\ntypedef struct zskiplistNode {\n    sds ele;\n    double score;\n    struct zskiplistNode *backward;\n    struct zskiplistLevel {\n        struct zskiplistNode *forward;\n        unsigned long span;\n    } level[];\n} zskiplistNode;\n\ntypedef struct zskiplist {\n    struct zskiplistNode *header, *tail;\n    unsigned long length;\n    int level;\n} zskiplist;\n\ntypedef struct zset {\n    dict *dict;\n    zskiplist *zsl;\n} zset;\n\ntypedef struct clientBufferLimitsConfig {\n    unsigned long long hard_limit_bytes;\n    unsigned long long soft_limit_bytes;\n    time_t soft_limit_seconds;\n} clientBufferLimitsConfig;\n\nextern clientBufferLimitsConfig clientBufferLimitsDefaults[CLIENT_TYPE_OBUF_COUNT];\n\n/* The redisOp structure defines a Redis Operation, that is an instance of\n * a command with an argument vector, database ID, propagation target\n * (PROPAGATE_*), and command pointer.\n *\n * Currently only used to additionally propagate more commands to AOF/Replication\n * after the propagation of the executed command. */\ntypedef struct redisOp {\n    robj **argv;\n    int argc, dbid, target;\n    struct redisCommand *cmd;\n} redisOp;\n\n/* Defines an array of Redis operations. There is an API to add to this\n * structure in an easy way.\n *\n * redisOpArrayInit();\n * redisOpArrayAppend();\n * redisOpArrayFree();\n */\ntypedef struct redisOpArray {\n    redisOp *ops;\n    int numops;\n} redisOpArray;\n\n/* This structure is returned by the getMemoryOverheadData() function in\n * order to return memory overhead information. */\nstruct redisMemOverhead {\n    size_t peak_allocated;\n    size_t total_allocated;\n    size_t startup_allocated;\n    size_t repl_backlog;\n    size_t clients_slaves;\n    size_t clients_normal;\n    size_t aof_buffer;\n    size_t lua_caches;\n    size_t overhead_total;\n    size_t dataset;\n    size_t total_keys;\n    size_t bytes_per_key;\n    float dataset_perc;\n    float peak_perc;\n    float total_frag;\n    ssize_t total_frag_bytes;\n    float allocator_frag;\n    ssize_t allocator_frag_bytes;\n    float allocator_rss;\n    ssize_t allocator_rss_bytes;\n    float rss_extra;\n    size_t rss_extra_bytes;\n    size_t num_dbs;\n    struct {\n        size_t dbid;\n        size_t overhead_ht_main;\n        size_t overhead_ht_expires;\n    } *db;\n};\n\n/* This structure can be optionally passed to RDB save/load functions in\n * order to implement additional functionalities, by storing and loading\n * metadata to the RDB file.\n *\n * Currently the only use is to select a DB at load time, useful in\n * replication in order to make sure that chained slaves (slaves of slaves)\n * select the correct DB and are able to accept the stream coming from the\n * top-level master. */\ntypedef struct rdbSaveInfo {\n    /* Used saving and loading. */\n    int repl_stream_db;  /* DB to select in server.master client. */\n\n    /* Used only loading. */\n    int repl_id_is_set;  /* True if repl_id field is set. */\n    char repl_id[CONFIG_RUN_ID_SIZE+1];     /* Replication ID. */\n    long long repl_offset;                  /* Replication offset. */\n} rdbSaveInfo;\n\n#define RDB_SAVE_INFO_INIT {-1,0,\"000000000000000000000000000000\",-1}\n\nstruct malloc_stats {\n    size_t zmalloc_used;\n    size_t process_rss;\n    size_t allocator_allocated;\n    size_t allocator_active;\n    size_t allocator_resident;\n};\n\n/*-----------------------------------------------------------------------------\n * TLS Context Configuration\n *----------------------------------------------------------------------------*/\n\ntypedef struct redisTLSContextConfig {\n    char *cert_file;\n    char *key_file;\n    char *dh_params_file;\n    char *ca_cert_file;\n    char *ca_cert_dir;\n    char *protocols;\n    char *ciphers;\n    char *ciphersuites;\n    int prefer_server_ciphers;\n    int session_caching;\n    int session_cache_size;\n    int session_cache_timeout;\n} redisTLSContextConfig;\n\n/*-----------------------------------------------------------------------------\n * Global server state\n *----------------------------------------------------------------------------*/\n\nstruct clusterState;\n\n/* AIX defines hz to __hz, we don't use this define and in order to allow\n * Redis build on AIX we need to undef it. */\n#ifdef _AIX\n#undef hz\n#endif\n\n#define CHILD_INFO_MAGIC 0xC17DDA7A12345678LL\n#define CHILD_TYPE_NONE 0\n#define CHILD_TYPE_RDB 1\n#define CHILD_TYPE_AOF 2\n#define CHILD_TYPE_LDB 3\n#define CHILD_TYPE_MODULE 4\n\nstruct redisServer {\n    /* General */\n    pid_t pid;                  /* Main process pid. */\n    pthread_t main_thread_id;         /* Main thread id */\n    char *configfile;           /* Absolute config file path, or NULL */\n    char *executable;           /* Absolute executable file path. */\n    char **exec_argv;           /* Executable argv vector (copy). */\n    int dynamic_hz;             /* Change hz value depending on # of clients. */\n    int config_hz;              /* Configured HZ value. May be different than\n                                   the actual 'hz' field value if dynamic-hz\n                                   is enabled. */\n    mode_t umask;               /* The umask value of the process on startup */\n    int hz;                     /* serverCron() calls frequency in hertz */\n    int in_fork_child;          /* indication that this is a fork child */\n    redisDb *db;\n    dict *commands;             /* Command table */\n    dict *orig_commands;        /* Command table before command renaming. */\n    aeEventLoop *el;\n    _Atomic unsigned int lruclock; /* Clock for LRU eviction */\n    volatile sig_atomic_t shutdown_asap; /* SHUTDOWN needed ASAP */\n    int activerehashing;        /* Incremental rehash in serverCron() */\n    int active_defrag_running;  /* Active defragmentation running (holds current scan aggressiveness) */\n    char *pidfile;              /* PID file path */\n    int arch_bits;              /* 32 or 64 depending on sizeof(long) */\n    int cronloops;              /* Number of times the cron function run */\n    char runid[CONFIG_RUN_ID_SIZE+1];  /* ID always different at every exec. */\n    int sentinel_mode;          /* True if this instance is a Sentinel. */\n    size_t initial_memory_usage; /* Bytes used after initialization. */\n    int always_show_logo;       /* Show logo even for non-stdout logging. */\n    char *ignore_warnings;      /* Config: warnings that should be ignored. */\n    /* Modules */\n    dict *moduleapi;            /* Exported core APIs dictionary for modules. */\n    dict *sharedapi;            /* Like moduleapi but containing the APIs that\n                                   modules share with each other. */\n    list *loadmodule_queue;     /* List of modules to load at startup. */\n    int module_blocked_pipe[2]; /* Pipe used to awake the event loop if a\n                                   client blocked on a module command needs\n                                   to be processed. */\n    pid_t module_child_pid;     /* PID of module child */\n    /* Networking */\n    int port;                   /* TCP listening port */\n    int tls_port;               /* TLS listening port */\n    int tcp_backlog;            /* TCP listen() backlog */\n    char *bindaddr[CONFIG_BINDADDR_MAX]; /* Addresses we should bind to */\n    int bindaddr_count;         /* Number of addresses in server.bindaddr[] */\n    char *unixsocket;           /* UNIX socket path */\n    mode_t unixsocketperm;      /* UNIX socket permission */\n    int ipfd[CONFIG_BINDADDR_MAX]; /* TCP socket file descriptors */\n    int ipfd_count;             /* Used slots in ipfd[] */\n    int tlsfd[CONFIG_BINDADDR_MAX]; /* TLS socket file descriptors */\n    int tlsfd_count;            /* Used slots in tlsfd[] */\n    int sofd;                   /* Unix socket file descriptor */\n    int cfd[CONFIG_BINDADDR_MAX];/* Cluster bus listening socket */\n    int cfd_count;              /* Used slots in cfd[] */\n    list *clients;              /* List of active clients */\n    list *clients_to_close;     /* Clients to close asynchronously */\n    list *clients_pending_write; /* There is to write or install handler. */\n    list *clients_pending_read;  /* Client has pending read socket buffers. */\n    list *slaves, *monitors;    /* List of slaves and MONITORs */\n    client *current_client;     /* Current client executing the command. */\n    rax *clients_timeout_table; /* Radix tree for blocked clients timeouts. */\n    long fixed_time_expire;     /* If > 0, expire keys against server.mstime. */\n    rax *clients_index;         /* Active clients dictionary by client ID. */\n    int clients_paused;         /* True if clients are currently paused */\n    mstime_t clients_pause_end_time; /* Time when we undo clients_paused */\n    char neterr[ANET_ERR_LEN];   /* Error buffer for anet.c */\n    dict *migrate_cached_sockets;/* MIGRATE cached sockets */\n    _Atomic uint64_t next_client_id; /* Next client unique ID. Incremental. */\n    int protected_mode;         /* Don't accept external connections. */\n    int gopher_enabled;         /* If true the server will reply to gopher\n                                   queries. Will still serve RESP2 queries. */\n    int io_threads_num;         /* Number of IO threads to use. */\n    int io_threads_do_reads;    /* Read and parse from IO threads? */\n    int io_threads_active;      /* Is IO threads currently active? */\n    long long events_processed_while_blocked; /* processEventsWhileBlocked() */\n\n    /* RDB / AOF loading information */\n    volatile sig_atomic_t loading; /* We are loading data from disk if true */\n    off_t loading_total_bytes;\n    off_t loading_loaded_bytes;\n    time_t loading_start_time;\n    off_t loading_process_events_interval_bytes;\n    /* Fast pointers to often looked up command */\n    struct redisCommand *delCommand, *multiCommand, *lpushCommand,\n                        *lpopCommand, *rpopCommand, *zpopminCommand,\n                        *zpopmaxCommand, *sremCommand, *execCommand,\n                        *expireCommand, *pexpireCommand, *xclaimCommand,\n                        *xgroupCommand, *rpoplpushCommand;\n    /* Fields used only for stats */\n    time_t stat_starttime;          /* Server start time */\n    long long stat_numcommands;     /* Number of processed commands */\n    long long stat_numconnections;  /* Number of connections received */\n    long long stat_expiredkeys;     /* Number of expired keys */\n    double stat_expired_stale_perc; /* Percentage of keys probably expired */\n    long long stat_expired_time_cap_reached_count; /* Early expire cylce stops.*/\n    long long stat_expire_cycle_time_used; /* Cumulative microseconds used. */\n    long long stat_evictedkeys;     /* Number of evicted keys (maxmemory) */\n    long long stat_keyspace_hits;   /* Number of successful lookups of keys */\n    long long stat_keyspace_misses; /* Number of failed lookups of keys */\n    long long stat_active_defrag_hits;      /* number of allocations moved */\n    long long stat_active_defrag_misses;    /* number of allocations scanned but not moved */\n    long long stat_active_defrag_key_hits;  /* number of keys with moved allocations */\n    long long stat_active_defrag_key_misses;/* number of keys scanned and not moved */\n    long long stat_active_defrag_scanned;   /* number of dictEntries scanned */\n    size_t stat_peak_memory;        /* Max used memory record */\n    long long stat_fork_time;       /* Time needed to perform latest fork() */\n    double stat_fork_rate;          /* Fork rate in GB/sec. */\n    long long stat_rejected_conn;   /* Clients rejected because of maxclients */\n    long long stat_sync_full;       /* Number of full resyncs with slaves. */\n    long long stat_sync_partial_ok; /* Number of accepted PSYNC requests. */\n    long long stat_sync_partial_err;/* Number of unaccepted PSYNC requests. */\n    list *slowlog;                  /* SLOWLOG list of commands */\n    long long slowlog_entry_id;     /* SLOWLOG current entry ID */\n    long long slowlog_log_slower_than; /* SLOWLOG time limit (to get logged) */\n    unsigned long slowlog_max_len;     /* SLOWLOG max number of items logged */\n    struct malloc_stats cron_malloc_stats; /* sampled in serverCron(). */\n    _Atomic long long stat_net_input_bytes; /* Bytes read from network. */\n    _Atomic long long stat_net_output_bytes; /* Bytes written to network. */\n    size_t stat_rdb_cow_bytes;      /* Copy on write bytes during RDB saving. */\n    size_t stat_aof_cow_bytes;      /* Copy on write bytes during AOF rewrite. */\n    size_t stat_module_cow_bytes;   /* Copy on write bytes during module fork. */\n    uint64_t stat_clients_type_memory[CLIENT_TYPE_COUNT];/* Mem usage by type */\n    long long stat_unexpected_error_replies; /* Number of unexpected (aof-loading, replica to master, etc.) error replies */\n    long long stat_io_reads_processed; /* Number of read events processed by IO / Main threads */\n    long long stat_io_writes_processed; /* Number of write events processed by IO / Main threads */\n    _Atomic long long stat_total_reads_processed; /* Total number of read events processed */\n    _Atomic long long stat_total_writes_processed; /* Total number of write events processed */\n    /* The following two are used to track instantaneous metrics, like\n     * number of operations per second, network traffic. */\n    struct {\n        long long last_sample_time; /* Timestamp of last sample in ms */\n        long long last_sample_count;/* Count in last sample */\n        long long samples[STATS_METRIC_SAMPLES];\n        int idx;\n    } inst_metric[STATS_METRIC_COUNT];\n    /* Configuration */\n    int verbosity;                  /* Loglevel in redis.conf */\n    int maxidletime;                /* Client timeout in seconds */\n    int tcpkeepalive;               /* Set SO_KEEPALIVE if non-zero. */\n    int active_expire_enabled;      /* Can be disabled for testing purposes. */\n    int active_expire_effort;       /* From 1 (default) to 10, active effort. */\n    int active_defrag_enabled;\n    int jemalloc_bg_thread;         /* Enable jemalloc background thread */\n    size_t active_defrag_ignore_bytes; /* minimum amount of fragmentation waste to start active defrag */\n    int active_defrag_threshold_lower; /* minimum percentage of fragmentation to start active defrag */\n    int active_defrag_threshold_upper; /* maximum percentage of fragmentation at which we use maximum effort */\n    int active_defrag_cycle_min;       /* minimal effort for defrag in CPU percentage */\n    int active_defrag_cycle_max;       /* maximal effort for defrag in CPU percentage */\n    unsigned long active_defrag_max_scan_fields; /* maximum number of fields of set/hash/zset/list to process from within the main dict scan */\n    _Atomic size_t client_max_querybuf_len; /* Limit for client query buffer length */\n    int dbnum;                      /* Total number of configured DBs */\n    int supervised;                 /* 1 if supervised, 0 otherwise. */\n    int supervised_mode;            /* See SUPERVISED_* */\n    int daemonize;                  /* True if running as a daemon */\n    clientBufferLimitsConfig client_obuf_limits[CLIENT_TYPE_OBUF_COUNT];\n    /* AOF persistence */\n    int aof_enabled;                /* AOF configuration */\n    int aof_state;                  /* AOF_(ON|OFF|WAIT_REWRITE) */\n    int aof_fsync;                  /* Kind of fsync() policy */\n    char *aof_filename;             /* Name of the AOF file */\n    int aof_no_fsync_on_rewrite;    /* Don't fsync if a rewrite is in prog. */\n    int aof_rewrite_perc;           /* Rewrite AOF if % growth is > M and... */\n    off_t aof_rewrite_min_size;     /* the AOF file is at least N bytes. */\n    off_t aof_rewrite_base_size;    /* AOF size on latest startup or rewrite. */\n    off_t aof_current_size;         /* AOF current size. */\n    off_t aof_fsync_offset;         /* AOF offset which is already synced to disk. */\n    int aof_flush_sleep;            /* Micros to sleep before flush. (used by tests) */\n    int aof_rewrite_scheduled;      /* Rewrite once BGSAVE terminates. */\n    pid_t aof_child_pid;            /* PID if rewriting process */\n    list *aof_rewrite_buf_blocks;   /* Hold changes during an AOF rewrite. */\n    sds aof_buf;      /* AOF buffer, written before entering the event loop */\n    int aof_fd;       /* File descriptor of currently selected AOF file */\n    int aof_selected_db; /* Currently selected DB in AOF */\n    time_t aof_flush_postponed_start; /* UNIX time of postponed AOF flush */\n    time_t aof_last_fsync;            /* UNIX time of last fsync() */\n    time_t aof_rewrite_time_last;   /* Time used by last AOF rewrite run. */\n    time_t aof_rewrite_time_start;  /* Current AOF rewrite start time. */\n    int aof_lastbgrewrite_status;   /* C_OK or C_ERR */\n    unsigned long aof_delayed_fsync;  /* delayed AOF fsync() counter */\n    int aof_rewrite_incremental_fsync;/* fsync incrementally while aof rewriting? */\n    int rdb_save_incremental_fsync;   /* fsync incrementally while rdb saving? */\n    int aof_last_write_status;      /* C_OK or C_ERR */\n    int aof_last_write_errno;       /* Valid if aof_last_write_status is ERR */\n    int aof_load_truncated;         /* Don't stop on unexpected AOF EOF. */\n    int aof_use_rdb_preamble;       /* Use RDB preamble on AOF rewrites. */\n    /* AOF pipes used to communicate between parent and child during rewrite. */\n    int aof_pipe_write_data_to_child;\n    int aof_pipe_read_data_from_parent;\n    int aof_pipe_write_ack_to_parent;\n    int aof_pipe_read_ack_from_child;\n    int aof_pipe_write_ack_to_child;\n    int aof_pipe_read_ack_from_parent;\n    int aof_stop_sending_diff;     /* If true stop sending accumulated diffs\n                                      to child process. */\n    sds aof_child_diff;             /* AOF diff accumulator child side. */\n    /* RDB persistence */\n    long long dirty;                /* Changes to DB from the last save */\n    long long dirty_before_bgsave;  /* Used to restore dirty on failed BGSAVE */\n    pid_t rdb_child_pid;            /* PID of RDB saving child */\n    struct saveparam *saveparams;   /* Save points array for RDB */\n    int saveparamslen;              /* Number of saving points */\n    char *rdb_filename;             /* Name of RDB file */\n    int rdb_compression;            /* Use compression in RDB? */\n    int rdb_checksum;               /* Use RDB checksum? */\n    int rdb_del_sync_files;         /* Remove RDB files used only for SYNC if\n                                       the instance does not use persistence. */\n    time_t lastsave;                /* Unix time of last successful save */\n    time_t lastbgsave_try;          /* Unix time of last attempted bgsave */\n    time_t rdb_save_time_last;      /* Time used by last RDB save run. */\n    time_t rdb_save_time_start;     /* Current RDB save start time. */\n    int rdb_bgsave_scheduled;       /* BGSAVE when possible if true. */\n    int rdb_child_type;             /* Type of save by active child. */\n    int lastbgsave_status;          /* C_OK or C_ERR */\n    int stop_writes_on_bgsave_err;  /* Don't allow writes if can't BGSAVE */\n    int rdb_pipe_read;              /* RDB pipe used to transfer the rdb data */\n                                    /* to the parent process in diskless repl. */\n    int rdb_child_exit_pipe;        /* Used by the diskless parent allow child exit. */\n    connection **rdb_pipe_conns;    /* Connections which are currently the */\n    int rdb_pipe_numconns;          /* target of diskless rdb fork child. */\n    int rdb_pipe_numconns_writing;  /* Number of rdb conns with pending writes. */\n    char *rdb_pipe_buff;            /* In diskless replication, this buffer holds data */\n    int rdb_pipe_bufflen;           /* that was read from the the rdb pipe. */\n    int rdb_key_save_delay;         /* Delay in microseconds between keys while\n                                     * writing the RDB. (for testings) */\n    int key_load_delay;             /* Delay in microseconds between keys while\n                                     * loading aof or rdb. (for testings) */\n    /* Pipe and data structures for child -> parent info sharing. */\n    int child_info_pipe[2];         /* Pipe used to write the child_info_data. */\n    struct {\n        int process_type;           /* AOF or RDB child? */\n        size_t cow_size;            /* Copy on write size. */\n        unsigned long long magic;   /* Magic value to make sure data is valid. */\n    } child_info_data;\n    /* Propagation of commands in AOF / replication */\n    redisOpArray also_propagate;    /* Additional command to propagate. */\n    /* Logging */\n    char *logfile;                  /* Path of log file */\n    int syslog_enabled;             /* Is syslog enabled? */\n    char *syslog_ident;             /* Syslog ident */\n    int syslog_facility;            /* Syslog facility */\n    /* Replication (master) */\n    char replid[CONFIG_RUN_ID_SIZE+1];  /* My current replication ID. */\n    char replid2[CONFIG_RUN_ID_SIZE+1]; /* replid inherited from master*/\n    long long master_repl_offset;   /* My current replication offset */\n    long long second_replid_offset; /* Accept offsets up to this for replid2. */\n    int slaveseldb;                 /* Last SELECTed DB in replication output */\n    int repl_ping_slave_period;     /* Master pings the slave every N seconds */\n    char *repl_backlog;             /* Replication backlog for partial syncs */\n    long long repl_backlog_size;    /* Backlog circular buffer size */\n    long long repl_backlog_histlen; /* Backlog actual data length */\n    long long repl_backlog_idx;     /* Backlog circular buffer current offset,\n                                       that is the next byte will'll write to.*/\n    long long repl_backlog_off;     /* Replication \"master offset\" of first\n                                       byte in the replication backlog buffer.*/\n    time_t repl_backlog_time_limit; /* Time without slaves after the backlog\n                                       gets released. */\n    time_t repl_no_slaves_since;    /* We have no slaves since that time.\n                                       Only valid if server.slaves len is 0. */\n    int repl_min_slaves_to_write;   /* Min number of slaves to write. */\n    int repl_min_slaves_max_lag;    /* Max lag of <count> slaves to write. */\n    int repl_good_slaves_count;     /* Number of slaves with lag <= max_lag. */\n    int repl_diskless_sync;         /* Master send RDB to slaves sockets directly. */\n    int repl_diskless_load;         /* Slave parse RDB directly from the socket.\n                                     * see REPL_DISKLESS_LOAD_* enum */\n    int repl_diskless_sync_delay;   /* Delay to start a diskless repl BGSAVE. */\n    /* Replication (slave) */\n    char *masteruser;               /* AUTH with this user and masterauth with master */\n    char *masterauth;               /* AUTH with this password with master */\n    char *masterhost;               /* Hostname of master */\n    int masterport;                 /* Port of master */\n    int repl_timeout;               /* Timeout after N seconds of master idle */\n    client *master;     /* Client that is master for this slave */\n    client *cached_master; /* Cached master to be reused for PSYNC. */\n    int repl_syncio_timeout; /* Timeout for synchronous I/O calls */\n    int repl_state;          /* Replication status if the instance is a slave */\n    off_t repl_transfer_size; /* Size of RDB to read from master during sync. */\n    off_t repl_transfer_read; /* Amount of RDB read from master during sync. */\n    off_t repl_transfer_last_fsync_off; /* Offset when we fsync-ed last time. */\n    connection *repl_transfer_s;     /* Slave -> Master SYNC connection */\n    int repl_transfer_fd;    /* Slave -> Master SYNC temp file descriptor */\n    char *repl_transfer_tmpfile; /* Slave-> master SYNC temp file name */\n    time_t repl_transfer_lastio; /* Unix time of the latest read, for timeout */\n    int repl_serve_stale_data; /* Serve stale data when link is down? */\n    int repl_slave_ro;          /* Slave is read only? */\n    int repl_slave_ignore_maxmemory;    /* If true slaves do not evict. */\n    time_t repl_down_since; /* Unix time at which link with master went down */\n    int repl_disable_tcp_nodelay;   /* Disable TCP_NODELAY after SYNC? */\n    int slave_priority;             /* Reported in INFO and used by Sentinel. */\n    int slave_announce_port;        /* Give the master this listening port. */\n    char *slave_announce_ip;        /* Give the master this ip address. */\n    /* The following two fields is where we store master PSYNC replid/offset\n     * while the PSYNC is in progress. At the end we'll copy the fields into\n     * the server->master client structure. */\n    char master_replid[CONFIG_RUN_ID_SIZE+1];  /* Master PSYNC runid. */\n    long long master_initial_offset;           /* Master PSYNC offset. */\n    int repl_slave_lazy_flush;          /* Lazy FLUSHALL before loading DB? */\n    /* Replication script cache. */\n    dict *repl_scriptcache_dict;        /* SHA1 all slaves are aware of. */\n    list *repl_scriptcache_fifo;        /* First in, first out LRU eviction. */\n    unsigned int repl_scriptcache_size; /* Max number of elements. */\n    /* Synchronous replication. */\n    list *clients_waiting_acks;         /* Clients waiting in WAIT command. */\n    int get_ack_from_slaves;            /* If true we send REPLCONF GETACK. */\n    /* Limits */\n    unsigned int maxclients;            /* Max number of simultaneous clients */\n    unsigned long long maxmemory;   /* Max number of memory bytes to use */\n    int maxmemory_policy;           /* Policy for key eviction */\n    int maxmemory_samples;          /* Precision of random sampling */\n    int lfu_log_factor;             /* LFU logarithmic counter factor. */\n    int lfu_decay_time;             /* LFU counter decay factor. */\n    long long proto_max_bulk_len;   /* Protocol bulk length maximum size. */\n    int oom_score_adj_base;         /* Base oom_score_adj value, as observed on startup */\n    int oom_score_adj_values[CONFIG_OOM_COUNT];   /* Linux oom_score_adj configuration */\n    int oom_score_adj;                            /* If true, oom_score_adj is managed */\n    /* Blocked clients */\n    unsigned int blocked_clients;   /* # of clients executing a blocking cmd.*/\n    unsigned int blocked_clients_by_type[BLOCKED_NUM];\n    list *unblocked_clients; /* list of clients to unblock before next loop */\n    list *ready_keys;        /* List of readyList structures for BLPOP & co */\n    /* Client side caching. */\n    unsigned int tracking_clients;  /* # of clients with tracking enabled.*/\n    size_t tracking_table_max_keys; /* Max number of keys in tracking table. */\n    /* Sort parameters - qsort_r() is only available under BSD so we\n     * have to take this state global, in order to pass it to sortCompare() */\n    int sort_desc;\n    int sort_alpha;\n    int sort_bypattern;\n    int sort_store;\n    /* Zip structure config, see redis.conf for more information  */\n    size_t hash_max_ziplist_entries;\n    size_t hash_max_ziplist_value;\n    size_t set_max_intset_entries;\n    size_t zset_max_ziplist_entries;\n    size_t zset_max_ziplist_value;\n    size_t hll_sparse_max_bytes;\n    size_t stream_node_max_bytes;\n    long long stream_node_max_entries;\n    /* List parameters */\n    int list_max_ziplist_size;\n    int list_compress_depth;\n    /* time cache */\n    _Atomic time_t unixtime;    /* Unix time sampled every cron cycle. */\n    time_t timezone;            /* Cached timezone. As set by tzset(). */\n    int daylight_active;        /* Currently in daylight saving time. */\n    mstime_t mstime;            /* 'unixtime' in milliseconds. */\n    ustime_t ustime;            /* 'unixtime' in microseconds. */\n    /* Pubsub */\n    dict *pubsub_channels;  /* Map channels to list of subscribed clients */\n    list *pubsub_patterns;  /* A list of pubsub_patterns */\n    dict *pubsub_patterns_dict;  /* A dict of pubsub_patterns */\n    int notify_keyspace_events; /* Events to propagate via Pub/Sub. This is an\n                                   xor of NOTIFY_... flags. */\n    /* Cluster */\n    int cluster_enabled;      /* Is cluster enabled? */\n    mstime_t cluster_node_timeout; /* Cluster node timeout. */\n    char *cluster_configfile; /* Cluster auto-generated config file name. */\n    struct clusterState *cluster;  /* State of the cluster */\n    int cluster_migration_barrier; /* Cluster replicas migration barrier. */\n    int cluster_slave_validity_factor; /* Slave max data age for failover. */\n    int cluster_require_full_coverage; /* If true, put the cluster down if\n                                          there is at least an uncovered slot.*/\n    int cluster_slave_no_failover;  /* Prevent slave from starting a failover\n                                       if the master is in failure state. */\n    char *cluster_announce_ip;  /* IP address to announce on cluster bus. */\n    int cluster_announce_port;     /* base port to announce on cluster bus. */\n    int cluster_announce_bus_port; /* bus port to announce on cluster bus. */\n    int cluster_module_flags;      /* Set of flags that Redis modules are able\n                                      to set in order to suppress certain\n                                      native Redis Cluster features. Check the\n                                      REDISMODULE_CLUSTER_FLAG_*. */\n    int cluster_allow_reads_when_down; /* Are reads allowed when the cluster\n                                        is down? */\n    int cluster_config_file_lock_fd;   /* cluster config fd, will be flock */\n    /* Scripting */\n    lua_State *lua; /* The Lua interpreter. We use just one for all clients */\n    client *lua_client;   /* The \"fake client\" to query Redis from Lua */\n    client *lua_caller;   /* The client running EVAL right now, or NULL */\n    char* lua_cur_script; /* SHA1 of the script currently running, or NULL */\n    dict *lua_scripts;         /* A dictionary of SHA1 -> Lua scripts */\n    unsigned long long lua_scripts_mem;  /* Cached scripts' memory + oh */\n    mstime_t lua_time_limit;  /* Script timeout in milliseconds */\n    mstime_t lua_time_start;  /* Start time of script, milliseconds time */\n    int lua_write_dirty;  /* True if a write command was called during the\n                             execution of the current script. */\n    int lua_random_dirty; /* True if a random command was called during the\n                             execution of the current script. */\n    int lua_replicate_commands; /* True if we are doing single commands repl. */\n    int lua_multi_emitted;/* True if we already propagated MULTI. */\n    int lua_repl;         /* Script replication flags for redis.set_repl(). */\n    int lua_timedout;     /* True if we reached the time limit for script\n                             execution. */\n    int lua_kill;         /* Kill the script if true. */\n    int lua_always_replicate_commands; /* Default replication type. */\n    int lua_oom;          /* OOM detected when script start? */\n    /* Lazy free */\n    int lazyfree_lazy_eviction;\n    int lazyfree_lazy_expire;\n    int lazyfree_lazy_server_del;\n    int lazyfree_lazy_user_del;\n    /* Latency monitor */\n    long long latency_monitor_threshold;\n    dict *latency_events;\n    /* ACLs */\n    char *acl_filename;     /* ACL Users file. NULL if not configured. */\n    unsigned long acllog_max_len; /* Maximum length of the ACL LOG list. */\n    sds requirepass;        /* Remember the cleartext password set with the\n                               old \"requirepass\" directive for backward\n                               compatibility with Redis <= 5. */\n    /* Assert & bug reporting */\n    const char *assert_failed;\n    const char *assert_file;\n    int assert_line;\n    int bug_report_start; /* True if bug report header was already logged. */\n    int watchdog_period;  /* Software watchdog period in ms. 0 = off */\n    /* System hardware info */\n    size_t system_memory_size;  /* Total memory in system as reported by OS */\n    /* TLS Configuration */\n    int tls_cluster;\n    int tls_replication;\n    int tls_auth_clients;\n    redisTLSContextConfig tls_ctx_config;\n    /* cpu affinity */\n    char *server_cpulist; /* cpu affinity list of redis server main/io thread. */\n    char *bio_cpulist; /* cpu affinity list of bio thread. */\n    char *aof_rewrite_cpulist; /* cpu affinity list of aof rewrite process. */\n    char *bgsave_cpulist; /* cpu affinity list of bgsave process. */\n};\n\ntypedef struct pubsubPattern {\n    client *client;\n    robj *pattern;\n} pubsubPattern;\n\n#define MAX_KEYS_BUFFER 256\n\n/* A result structure for the various getkeys function calls. It lists the\n * keys as indices to the provided argv.\n */\ntypedef struct {\n    int keysbuf[MAX_KEYS_BUFFER];       /* Pre-allocated buffer, to save heap allocations */\n    int *keys;                          /* Key indices array, points to keysbuf or heap */\n    int numkeys;                        /* Number of key indices return */\n    int size;                           /* Available array size */\n} getKeysResult;\n#define GETKEYS_RESULT_INIT { {0}, NULL, 0, MAX_KEYS_BUFFER }\n\ntypedef void redisCommandProc(client *c);\ntypedef int redisGetKeysProc(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result);\nstruct redisCommand {\n    char *name;\n    redisCommandProc *proc;\n    int arity;\n    char *sflags;   /* Flags as string representation, one char per flag. */\n    uint64_t flags; /* The actual flags, obtained from the 'sflags' field. */\n    /* Use a function to determine keys arguments in a command line.\n     * Used for Redis Cluster redirect. */\n    redisGetKeysProc *getkeys_proc;\n    /* What keys should be loaded in background when calling this command? */\n    int firstkey; /* The first argument that's a key (0 = no keys) */\n    int lastkey;  /* The last argument that's a key */\n    int keystep;  /* The step between first and last key */\n    long long microseconds, calls;\n    int id;     /* Command ID. This is a progressive ID starting from 0 that\n                   is assigned at runtime, and is used in order to check\n                   ACLs. A connection is able to execute a given command if\n                   the user associated to the connection has this command\n                   bit set in the bitmap of allowed commands. */\n};\n\nstruct redisFunctionSym {\n    char *name;\n    unsigned long pointer;\n};\n\ntypedef struct _redisSortObject {\n    robj *obj;\n    union {\n        double score;\n        robj *cmpobj;\n    } u;\n} redisSortObject;\n\ntypedef struct _redisSortOperation {\n    int type;\n    robj *pattern;\n} redisSortOperation;\n\n/* Structure to hold list iteration abstraction. */\ntypedef struct {\n    robj *subject;\n    unsigned char encoding;\n    unsigned char direction; /* Iteration direction */\n    quicklistIter *iter;\n} listTypeIterator;\n\n/* Structure for an entry while iterating over a list. */\ntypedef struct {\n    listTypeIterator *li;\n    quicklistEntry entry; /* Entry in quicklist */\n} listTypeEntry;\n\n/* Structure to hold set iteration abstraction. */\ntypedef struct {\n    robj *subject;\n    int encoding;\n    int ii; /* intset iterator */\n    dictIterator *di;\n} setTypeIterator;\n\n/* Structure to hold hash iteration abstraction. Note that iteration over\n * hashes involves both fields and values. Because it is possible that\n * not both are required, store pointers in the iterator to avoid\n * unnecessary memory allocation for fields/values. */\ntypedef struct {\n    robj *subject;\n    int encoding;\n\n    unsigned char *fptr, *vptr;\n\n    dictIterator *di;\n    dictEntry *de;\n} hashTypeIterator;\n\n#include \"stream.h\"  /* Stream data type header file. */\n\n#define OBJ_HASH_KEY 1\n#define OBJ_HASH_VALUE 2\n\n/*-----------------------------------------------------------------------------\n * Extern declarations\n *----------------------------------------------------------------------------*/\n\nextern struct redisServer server;\nextern struct sharedObjectsStruct shared;\nextern dictType objectKeyPointerValueDictType;\nextern dictType objectKeyHeapPointerValueDictType;\nextern dictType setDictType;\nextern dictType zsetDictType;\nextern dictType clusterNodesDictType;\nextern dictType clusterNodesBlackListDictType;\nextern dictType dbDictType;\nextern dictType shaScriptObjectDictType;\nextern double R_Zero, R_PosInf, R_NegInf, R_Nan;\nextern dictType hashDictType;\nextern dictType replScriptCacheDictType;\nextern dictType keyptrDictType;\nextern dictType modulesDictType;\n\n/*-----------------------------------------------------------------------------\n * Functions prototypes\n *----------------------------------------------------------------------------*/\n\n/* Modules */\nvoid moduleInitModulesSystem(void);\nint moduleLoad(const char *path, void **argv, int argc);\nvoid moduleLoadFromQueue(void);\nint moduleGetCommandKeysViaAPI(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result);\nmoduleType *moduleTypeLookupModuleByID(uint64_t id);\nvoid moduleTypeNameByID(char *name, uint64_t moduleid);\nvoid moduleFreeContext(struct RedisModuleCtx *ctx);\nvoid unblockClientFromModule(client *c);\nvoid moduleHandleBlockedClients(void);\nvoid moduleBlockedClientTimedOut(client *c);\nvoid moduleBlockedClientPipeReadable(aeEventLoop *el, int fd, void *privdata, int mask);\nsize_t moduleCount(void);\nvoid moduleAcquireGIL(void);\nint moduleTryAcquireGIL(void);\nvoid moduleReleaseGIL(void);\nvoid moduleNotifyKeyspaceEvent(int type, const char *event, robj *key, int dbid);\nvoid moduleCallCommandFilters(client *c);\nvoid ModuleForkDoneHandler(int exitcode, int bysignal);\nint TerminateModuleForkChild(int child_pid, int wait);\nssize_t rdbSaveModulesAux(rio *rdb, int when);\nint moduleAllDatatypesHandleErrors();\nsds modulesCollectInfo(sds info, const char *section, int for_crash_report, int sections);\nvoid moduleFireServerEvent(uint64_t eid, int subid, void *data);\nvoid processModuleLoadingProgressEvent(int is_aof);\nint moduleTryServeClientBlockedOnKey(client *c, robj *key);\nvoid moduleUnblockClient(client *c);\nint moduleClientIsBlockedOnKeys(client *c);\nvoid moduleNotifyUserChanged(client *c);\n\n/* Utils */\nlong long ustime(void);\nlong long mstime(void);\nvoid getRandomHexChars(char *p, size_t len);\nvoid getRandomBytes(unsigned char *p, size_t len);\nuint64_t crc64(uint64_t crc, const unsigned char *s, uint64_t l);\nvoid exitFromChild(int retcode);\nlong long redisPopcount(void *s, long count);\nvoid redisSetProcTitle(char *title);\nint redisCommunicateSystemd(const char *sd_notify_msg);\nvoid redisSetCpuAffinity(const char *cpulist);\n\n/* networking.c -- Networking and Client related operations */\nclient *createClient(connection *conn);\nvoid closeTimedoutClients(void);\nvoid freeClient(client *c);\nvoid freeClientAsync(client *c);\nvoid resetClient(client *c);\nvoid sendReplyToClient(connection *conn);\nvoid *addReplyDeferredLen(client *c);\nvoid setDeferredArrayLen(client *c, void *node, long length);\nvoid setDeferredMapLen(client *c, void *node, long length);\nvoid setDeferredSetLen(client *c, void *node, long length);\nvoid setDeferredAttributeLen(client *c, void *node, long length);\nvoid setDeferredPushLen(client *c, void *node, long length);\nvoid processInputBuffer(client *c);\nvoid processGopherRequest(client *c);\nvoid acceptHandler(aeEventLoop *el, int fd, void *privdata, int mask);\nvoid acceptTcpHandler(aeEventLoop *el, int fd, void *privdata, int mask);\nvoid acceptTLSHandler(aeEventLoop *el, int fd, void *privdata, int mask);\nvoid acceptUnixHandler(aeEventLoop *el, int fd, void *privdata, int mask);\nvoid readQueryFromClient(connection *conn);\nvoid addReplyNull(client *c);\nvoid addReplyNullArray(client *c);\nvoid addReplyBool(client *c, int b);\nvoid addReplyVerbatim(client *c, const char *s, size_t len, const char *ext);\nvoid addReplyProto(client *c, const char *s, size_t len);\nvoid AddReplyFromClient(client *c, client *src);\nvoid addReplyBulk(client *c, robj *obj);\nvoid addReplyBulkCString(client *c, const char *s);\nvoid addReplyBulkCBuffer(client *c, const void *p, size_t len);\nvoid addReplyBulkLongLong(client *c, long long ll);\nvoid addReply(client *c, robj *obj);\nvoid addReplySds(client *c, sds s);\nvoid addReplyBulkSds(client *c, sds s);\nvoid addReplyErrorObject(client *c, robj *err);\nvoid addReplyErrorSds(client *c, sds err);\nvoid addReplyError(client *c, const char *err);\nvoid addReplyStatus(client *c, const char *status);\nvoid addReplyDouble(client *c, double d);\nvoid addReplyBigNum(client *c, const char* num, size_t len);\nvoid addReplyHumanLongDouble(client *c, long double d);\nvoid addReplyLongLong(client *c, long long ll);\nvoid addReplyArrayLen(client *c, long length);\nvoid addReplyMapLen(client *c, long length);\nvoid addReplySetLen(client *c, long length);\nvoid addReplyAttributeLen(client *c, long length);\nvoid addReplyPushLen(client *c, long length);\nvoid addReplyHelp(client *c, const char **help);\nvoid addReplySubcommandSyntaxError(client *c);\nvoid addReplyLoadedModules(client *c);\nvoid copyClientOutputBuffer(client *dst, client *src);\nsize_t sdsZmallocSize(sds s);\nsize_t getStringObjectSdsUsedMemory(robj *o);\nvoid freeClientReplyValue(void *o);\nvoid *dupClientReplyValue(void *o);\nvoid getClientsMaxBuffers(unsigned long *longest_output_list,\n                          unsigned long *biggest_input_buffer);\nchar *getClientPeerId(client *client);\nsds catClientInfoString(sds s, client *client);\nsds getAllClientsInfoString(int type);\nvoid rewriteClientCommandVector(client *c, int argc, ...);\nvoid rewriteClientCommandArgument(client *c, int i, robj *newval);\nvoid replaceClientCommandVector(client *c, int argc, robj **argv);\nunsigned long getClientOutputBufferMemoryUsage(client *c);\nint freeClientsInAsyncFreeQueue(void);\nvoid asyncCloseClientOnOutputBufferLimitReached(client *c);\nint getClientType(client *c);\nint getClientTypeByName(char *name);\nchar *getClientTypeName(int class);\nvoid flushSlavesOutputBuffers(void);\nvoid disconnectSlaves(void);\nint listenToPort(int port, int *fds, int *count);\nvoid pauseClients(mstime_t duration);\nint clientsArePaused(void);\nvoid processEventsWhileBlocked(void);\nint handleClientsWithPendingWrites(void);\nint handleClientsWithPendingWritesUsingThreads(void);\nint handleClientsWithPendingReadsUsingThreads(void);\nint stopThreadedIOIfNeeded(void);\nint clientHasPendingReplies(client *c);\nvoid unlinkClient(client *c);\nint writeToClient(client *c, int handler_installed);\nvoid linkClient(client *c);\nvoid protectClient(client *c);\nvoid unprotectClient(client *c);\nvoid initThreadedIO(void);\nclient *lookupClientByID(uint64_t id);\nint authRequired(client *c);\n\n#ifdef __GNUC__\nvoid addReplyErrorFormat(client *c, const char *fmt, ...)\n    __attribute__((format(printf, 2, 3)));\nvoid addReplyStatusFormat(client *c, const char *fmt, ...)\n    __attribute__((format(printf, 2, 3)));\n#else\nvoid addReplyErrorFormat(client *c, const char *fmt, ...);\nvoid addReplyStatusFormat(client *c, const char *fmt, ...);\n#endif\n\n/* Client side caching (tracking mode) */\nvoid enableTracking(client *c, uint64_t redirect_to, uint64_t options, robj **prefix, size_t numprefix);\nvoid disableTracking(client *c);\nvoid trackingRememberKeys(client *c);\nvoid trackingInvalidateKey(client *c, robj *keyobj);\nvoid trackingInvalidateKeysOnFlush(int dbid);\nvoid trackingLimitUsedSlots(void);\nuint64_t trackingGetTotalItems(void);\nuint64_t trackingGetTotalKeys(void);\nuint64_t trackingGetTotalPrefixes(void);\nvoid trackingBroadcastInvalidationMessages(void);\n\n/* List data type */\nvoid listTypeTryConversion(robj *subject, robj *value);\nvoid listTypePush(robj *subject, robj *value, int where);\nrobj *listTypePop(robj *subject, int where);\nunsigned long listTypeLength(const robj *subject);\nlistTypeIterator *listTypeInitIterator(robj *subject, long index, unsigned char direction);\nvoid listTypeReleaseIterator(listTypeIterator *li);\nint listTypeNext(listTypeIterator *li, listTypeEntry *entry);\nrobj *listTypeGet(listTypeEntry *entry);\nvoid listTypeInsert(listTypeEntry *entry, robj *value, int where);\nint listTypeEqual(listTypeEntry *entry, robj *o);\nvoid listTypeDelete(listTypeIterator *iter, listTypeEntry *entry);\nvoid listTypeConvert(robj *subject, int enc);\nvoid unblockClientWaitingData(client *c);\nvoid popGenericCommand(client *c, int where);\n\n/* MULTI/EXEC/WATCH... */\nvoid unwatchAllKeys(client *c);\nvoid initClientMultiState(client *c);\nvoid freeClientMultiState(client *c);\nvoid queueMultiCommand(client *c);\nvoid touchWatchedKey(redisDb *db, robj *key);\nint isWatchedKeyExpired(client *c);\nvoid touchAllWatchedKeysInDb(redisDb *emptied, redisDb *replaced_with);\nvoid discardTransaction(client *c);\nvoid flagTransaction(client *c);\nvoid execCommandAbort(client *c, sds error);\nvoid execCommandPropagateMulti(client *c);\nvoid execCommandPropagateExec(client *c);\n\n/* Redis object implementation */\nvoid decrRefCount(robj *o);\nvoid decrRefCountVoid(void *o);\nvoid incrRefCount(robj *o);\nrobj *makeObjectShared(robj *o);\nrobj *resetRefCount(robj *obj);\nvoid freeStringObject(robj *o);\nvoid freeListObject(robj *o);\nvoid freeSetObject(robj *o);\nvoid freeZsetObject(robj *o);\nvoid freeHashObject(robj *o);\nrobj *createObject(int type, void *ptr);\nrobj *createStringObject(const char *ptr, size_t len);\nrobj *createRawStringObject(const char *ptr, size_t len);\nrobj *createEmbeddedStringObject(const char *ptr, size_t len);\nrobj *dupStringObject(const robj *o);\nint isSdsRepresentableAsLongLong(sds s, long long *llval);\nint isObjectRepresentableAsLongLong(robj *o, long long *llongval);\nrobj *tryObjectEncoding(robj *o);\nrobj *getDecodedObject(robj *o);\nsize_t stringObjectLen(robj *o);\nrobj *createStringObjectFromLongLong(long long value);\nrobj *createStringObjectFromLongLongForValue(long long value);\nrobj *createStringObjectFromLongDouble(long double value, int humanfriendly);\nrobj *createQuicklistObject(void);\nrobj *createZiplistObject(void);\nrobj *createSetObject(void);\nrobj *createIntsetObject(void);\nrobj *createHashObject(void);\nrobj *createZsetObject(void);\nrobj *createZsetZiplistObject(void);\nrobj *createStreamObject(void);\nrobj *createModuleObject(moduleType *mt, void *value);\nint getLongFromObjectOrReply(client *c, robj *o, long *target, const char *msg);\nint checkType(client *c, robj *o, int type);\nint getLongLongFromObjectOrReply(client *c, robj *o, long long *target, const char *msg);\nint getDoubleFromObjectOrReply(client *c, robj *o, double *target, const char *msg);\nint getDoubleFromObject(const robj *o, double *target);\nint getLongLongFromObject(robj *o, long long *target);\nint getLongDoubleFromObject(robj *o, long double *target);\nint getLongDoubleFromObjectOrReply(client *c, robj *o, long double *target, const char *msg);\nchar *strEncoding(int encoding);\nint compareStringObjects(robj *a, robj *b);\nint collateStringObjects(robj *a, robj *b);\nint equalStringObjects(robj *a, robj *b);\nunsigned long long estimateObjectIdleTime(robj *o);\nvoid trimStringObjectIfNeeded(robj *o);\n#define sdsEncodedObject(objptr) (objptr->encoding == OBJ_ENCODING_RAW || objptr->encoding == OBJ_ENCODING_EMBSTR)\n\n/* Synchronous I/O with timeout */\nssize_t syncWrite(int fd, char *ptr, ssize_t size, long long timeout);\nssize_t syncRead(int fd, char *ptr, ssize_t size, long long timeout);\nssize_t syncReadLine(int fd, char *ptr, ssize_t size, long long timeout);\n\n/* Replication */\nvoid replicationFeedSlaves(list *slaves, int dictid, robj **argv, int argc);\nvoid replicationFeedSlavesFromMasterStream(list *slaves, char *buf, size_t buflen);\nvoid replicationFeedMonitors(client *c, list *monitors, int dictid, robj **argv, int argc);\nvoid updateSlavesWaitingBgsave(int bgsaveerr, int type);\nvoid replicationCron(void);\nvoid replicationHandleMasterDisconnection(void);\nvoid replicationCacheMaster(client *c);\nvoid resizeReplicationBacklog(long long newsize);\nvoid replicationSetMaster(char *ip, int port);\nvoid replicationUnsetMaster(void);\nvoid refreshGoodSlavesCount(void);\nvoid replicationScriptCacheInit(void);\nvoid replicationScriptCacheFlush(void);\nvoid replicationScriptCacheAdd(sds sha1);\nint replicationScriptCacheExists(sds sha1);\nvoid processClientsWaitingReplicas(void);\nvoid unblockClientWaitingReplicas(client *c);\nint replicationCountAcksByOffset(long long offset);\nvoid replicationSendNewlineToMaster(void);\nlong long replicationGetSlaveOffset(void);\nchar *replicationGetSlaveName(client *c);\nlong long getPsyncInitialOffset(void);\nint replicationSetupSlaveForFullResync(client *slave, long long offset);\nvoid changeReplicationId(void);\nvoid clearReplicationId2(void);\nvoid chopReplicationBacklog(void);\nvoid replicationCacheMasterUsingMyself(void);\nvoid feedReplicationBacklog(void *ptr, size_t len);\nvoid showLatestBacklog(void);\nvoid rdbPipeReadHandler(struct aeEventLoop *eventLoop, int fd, void *clientData, int mask);\nvoid rdbPipeWriteHandlerConnRemoved(struct connection *conn);\n\n/* Generic persistence functions */\nvoid startLoadingFile(FILE* fp, char* filename, int rdbflags);\nvoid startLoading(size_t size, int rdbflags);\nvoid loadingProgress(off_t pos);\nvoid stopLoading(int success);\nvoid startSaving(int rdbflags);\nvoid stopSaving(int success);\nint allPersistenceDisabled(void);\n\n#define DISK_ERROR_TYPE_AOF 1       /* Don't accept writes: AOF errors. */\n#define DISK_ERROR_TYPE_RDB 2       /* Don't accept writes: RDB errors. */\n#define DISK_ERROR_TYPE_NONE 0      /* No problems, we can accept writes. */\nint writeCommandsDeniedByDiskError(void);\n\n/* RDB persistence */\n#include \"rdb.h\"\nvoid killRDBChild(void);\nint bg_unlink(const char *filename);\n\n/* AOF persistence */\nvoid flushAppendOnlyFile(int force);\nvoid feedAppendOnlyFile(struct redisCommand *cmd, int dictid, robj **argv, int argc);\nvoid aofRemoveTempFile(pid_t childpid);\nint rewriteAppendOnlyFileBackground(void);\nint loadAppendOnlyFile(char *filename);\nvoid stopAppendOnly(void);\nint startAppendOnly(void);\nvoid backgroundRewriteDoneHandler(int exitcode, int bysignal);\nvoid aofRewriteBufferReset(void);\nunsigned long aofRewriteBufferSize(void);\nssize_t aofReadDiffFromParent(void);\nvoid killAppendOnlyChild(void);\nvoid restartAOFAfterSYNC();\n\n/* Child info */\nvoid openChildInfoPipe(void);\nvoid closeChildInfoPipe(void);\nvoid sendChildInfo(int process_type);\nvoid receiveChildInfo(void);\n\n/* Fork helpers */\nint redisFork(int type);\nint hasActiveChildProcess();\nvoid sendChildCOWInfo(int ptype, char *pname);\n\n/* acl.c -- Authentication related prototypes. */\nextern rax *Users;\nextern user *DefaultUser;\nvoid ACLInit(void);\n/* Return values for ACLCheckUserCredentials(). */\n#define ACL_OK 0\n#define ACL_DENIED_CMD 1\n#define ACL_DENIED_KEY 2\n#define ACL_DENIED_AUTH 3 /* Only used for ACL LOG entries. */\nint ACLCheckUserCredentials(robj *username, robj *password);\nint ACLAuthenticateUser(client *c, robj *username, robj *password);\nunsigned long ACLGetCommandID(const char *cmdname);\nuser *ACLGetUserByName(const char *name, size_t namelen);\nint ACLCheckCommandPerm(client *c, int *keyidxptr);\nint ACLSetUser(user *u, const char *op, ssize_t oplen);\nsds ACLDefaultUserFirstPassword(void);\nuint64_t ACLGetCommandCategoryFlagByName(const char *name);\nint ACLAppendUserForLoading(sds *argv, int argc, int *argc_err);\nchar *ACLSetUserStringError(void);\nint ACLLoadConfiguredUsers(void);\nsds ACLDescribeUser(user *u);\nvoid ACLLoadUsersAtStartup(void);\nvoid addReplyCommandCategories(client *c, struct redisCommand *cmd);\nuser *ACLCreateUnlinkedUser();\nvoid ACLFreeUserAndKillClients(user *u);\nvoid addACLLogEntry(client *c, int reason, int keypos, sds username);\n\n/* Sorted sets data type */\n\n/* Input flags. */\n#define ZADD_NONE 0\n#define ZADD_INCR (1<<0)    /* Increment the score instead of setting it. */\n#define ZADD_NX (1<<1)      /* Don't touch elements not already existing. */\n#define ZADD_XX (1<<2)      /* Only touch elements already existing. */\n\n/* Output flags. */\n#define ZADD_NOP (1<<3)     /* Operation not performed because of conditionals.*/\n#define ZADD_NAN (1<<4)     /* Only touch elements already existing. */\n#define ZADD_ADDED (1<<5)   /* The element was new and was added. */\n#define ZADD_UPDATED (1<<6) /* The element already existed, score updated. */\n\n/* Flags only used by the ZADD command but not by zsetAdd() API: */\n#define ZADD_CH (1<<16)      /* Return num of elements added or updated. */\n\n/* Struct to hold an inclusive/exclusive range spec by score comparison. */\ntypedef struct {\n    double min, max;\n    int minex, maxex; /* are min or max exclusive? */\n} zrangespec;\n\n/* Struct to hold an inclusive/exclusive range spec by lexicographic comparison. */\ntypedef struct {\n    sds min, max;     /* May be set to shared.(minstring|maxstring) */\n    int minex, maxex; /* are min or max exclusive? */\n} zlexrangespec;\n\nzskiplist *zslCreate(void);\nvoid zslFree(zskiplist *zsl);\nzskiplistNode *zslInsert(zskiplist *zsl, double score, sds ele);\nunsigned char *zzlInsert(unsigned char *zl, sds ele, double score);\nint zslDelete(zskiplist *zsl, double score, sds ele, zskiplistNode **node);\nzskiplistNode *zslFirstInRange(zskiplist *zsl, zrangespec *range);\nzskiplistNode *zslLastInRange(zskiplist *zsl, zrangespec *range);\ndouble zzlGetScore(unsigned char *sptr);\nvoid zzlNext(unsigned char *zl, unsigned char **eptr, unsigned char **sptr);\nvoid zzlPrev(unsigned char *zl, unsigned char **eptr, unsigned char **sptr);\nunsigned char *zzlFirstInRange(unsigned char *zl, zrangespec *range);\nunsigned char *zzlLastInRange(unsigned char *zl, zrangespec *range);\nunsigned long zsetLength(const robj *zobj);\nvoid zsetConvert(robj *zobj, int encoding);\nvoid zsetConvertToZiplistIfNeeded(robj *zobj, size_t maxelelen);\nint zsetScore(robj *zobj, sds member, double *score);\nunsigned long zslGetRank(zskiplist *zsl, double score, sds o);\nint zsetAdd(robj *zobj, double score, sds ele, int *flags, double *newscore);\nlong zsetRank(robj *zobj, sds ele, int reverse);\nint zsetDel(robj *zobj, sds ele);\nvoid genericZpopCommand(client *c, robj **keyv, int keyc, int where, int emitkey, robj *countarg);\nsds ziplistGetObject(unsigned char *sptr);\nint zslValueGteMin(double value, zrangespec *spec);\nint zslValueLteMax(double value, zrangespec *spec);\nvoid zslFreeLexRange(zlexrangespec *spec);\nint zslParseLexRange(robj *min, robj *max, zlexrangespec *spec);\nunsigned char *zzlFirstInLexRange(unsigned char *zl, zlexrangespec *range);\nunsigned char *zzlLastInLexRange(unsigned char *zl, zlexrangespec *range);\nzskiplistNode *zslFirstInLexRange(zskiplist *zsl, zlexrangespec *range);\nzskiplistNode *zslLastInLexRange(zskiplist *zsl, zlexrangespec *range);\nint zzlLexValueGteMin(unsigned char *p, zlexrangespec *spec);\nint zzlLexValueLteMax(unsigned char *p, zlexrangespec *spec);\nint zslLexValueGteMin(sds value, zlexrangespec *spec);\nint zslLexValueLteMax(sds value, zlexrangespec *spec);\n\n/* Core functions */\nint getMaxmemoryState(size_t *total, size_t *logical, size_t *tofree, float *level);\nsize_t freeMemoryGetNotCountedMemory();\nint freeMemoryIfNeeded(void);\nint freeMemoryIfNeededAndSafe(void);\nint processCommand(client *c);\nint processPendingCommandsAndResetClient(client *c);\nvoid setupSignalHandlers(void);\nstruct redisCommand *lookupCommand(sds name);\nstruct redisCommand *lookupCommandByCString(const char *s);\nstruct redisCommand *lookupCommandOrOriginal(sds name);\nvoid call(client *c, int flags);\nvoid propagate(struct redisCommand *cmd, int dbid, robj **argv, int argc, int flags);\nvoid alsoPropagate(struct redisCommand *cmd, int dbid, robj **argv, int argc, int target);\nvoid redisOpArrayInit(redisOpArray *oa);\nvoid redisOpArrayFree(redisOpArray *oa);\nvoid forceCommandPropagation(client *c, int flags);\nvoid preventCommandPropagation(client *c);\nvoid preventCommandAOF(client *c);\nvoid preventCommandReplication(client *c);\nint prepareForShutdown(int flags);\n#ifdef __GNUC__\nvoid serverLog(int level, const char *fmt, ...)\n    __attribute__((format(printf, 2, 3)));\n#else\nvoid serverLog(int level, const char *fmt, ...);\n#endif\nvoid serverLogRaw(int level, const char *msg);\nvoid serverLogFromHandler(int level, const char *msg);\nvoid usage(void);\nvoid updateDictResizePolicy(void);\nint htNeedsResize(dict *dict);\nvoid populateCommandTable(void);\nvoid resetCommandTableStats(void);\nvoid adjustOpenFilesLimit(void);\nvoid closeListeningSockets(int unlink_unix_socket);\nvoid updateCachedTime(int update_daylight_info);\nvoid resetServerStats(void);\nvoid activeDefragCycle(void);\nunsigned int getLRUClock(void);\nunsigned int LRU_CLOCK(void);\nconst char *evictPolicyToString(void);\nstruct redisMemOverhead *getMemoryOverheadData(void);\nvoid freeMemoryOverheadData(struct redisMemOverhead *mh);\nvoid checkChildrenDone(void);\nint setOOMScoreAdj(int process_class);\n\n#define RESTART_SERVER_NONE 0\n#define RESTART_SERVER_GRACEFULLY (1<<0)     /* Do proper shutdown. */\n#define RESTART_SERVER_CONFIG_REWRITE (1<<1) /* CONFIG REWRITE before restart.*/\nint restartServer(int flags, mstime_t delay);\n\n/* Set data type */\nrobj *setTypeCreate(sds value);\nint setTypeAdd(robj *subject, sds value);\nint setTypeRemove(robj *subject, sds value);\nint setTypeIsMember(robj *subject, sds value);\nsetTypeIterator *setTypeInitIterator(robj *subject);\nvoid setTypeReleaseIterator(setTypeIterator *si);\nint setTypeNext(setTypeIterator *si, sds *sdsele, int64_t *llele);\nsds setTypeNextObject(setTypeIterator *si);\nint setTypeRandomElement(robj *setobj, sds *sdsele, int64_t *llele);\nunsigned long setTypeRandomElements(robj *set, unsigned long count, robj *aux_set);\nunsigned long setTypeSize(const robj *subject);\nvoid setTypeConvert(robj *subject, int enc);\n\n/* Hash data type */\n#define HASH_SET_TAKE_FIELD (1<<0)\n#define HASH_SET_TAKE_VALUE (1<<1)\n#define HASH_SET_COPY 0\n\nvoid hashTypeConvert(robj *o, int enc);\nvoid hashTypeTryConversion(robj *subject, robj **argv, int start, int end);\nint hashTypeExists(robj *o, sds key);\nint hashTypeDelete(robj *o, sds key);\nunsigned long hashTypeLength(const robj *o);\nhashTypeIterator *hashTypeInitIterator(robj *subject);\nvoid hashTypeReleaseIterator(hashTypeIterator *hi);\nint hashTypeNext(hashTypeIterator *hi);\nvoid hashTypeCurrentFromZiplist(hashTypeIterator *hi, int what,\n                                unsigned char **vstr,\n                                unsigned int *vlen,\n                                long long *vll);\nsds hashTypeCurrentFromHashTable(hashTypeIterator *hi, int what);\nvoid hashTypeCurrentObject(hashTypeIterator *hi, int what, unsigned char **vstr, unsigned int *vlen, long long *vll);\nsds hashTypeCurrentObjectNewSds(hashTypeIterator *hi, int what);\nrobj *hashTypeLookupWriteOrCreate(client *c, robj *key);\nrobj *hashTypeGetValueObject(robj *o, sds field);\nint hashTypeSet(robj *o, sds field, sds value, int flags);\n\n/* Pub / Sub */\nint pubsubUnsubscribeAllChannels(client *c, int notify);\nint pubsubUnsubscribeAllPatterns(client *c, int notify);\nvoid freePubsubPattern(void *p);\nint listMatchPubsubPattern(void *a, void *b);\nint pubsubPublishMessage(robj *channel, robj *message);\nvoid addReplyPubsubMessage(client *c, robj *channel, robj *msg);\n\n/* Keyspace events notification */\nvoid notifyKeyspaceEvent(int type, char *event, robj *key, int dbid);\nint keyspaceEventsStringToFlags(char *classes);\nsds keyspaceEventsFlagsToString(int flags);\n\n/* Configuration */\nvoid loadServerConfig(char *filename, char *options);\nvoid appendServerSaveParams(time_t seconds, int changes);\nvoid resetServerSaveParams(void);\nstruct rewriteConfigState; /* Forward declaration to export API. */\nvoid rewriteConfigRewriteLine(struct rewriteConfigState *state, const char *option, sds line, int force);\nint rewriteConfig(char *path, int force_all);\nvoid initConfigValues();\n\n/* db.c -- Keyspace access API */\nint removeExpire(redisDb *db, robj *key);\nvoid propagateExpire(redisDb *db, robj *key, int lazy);\nint keyIsExpired(redisDb *db, robj *key);\nint expireIfNeeded(redisDb *db, robj *key);\nlong long getExpire(redisDb *db, robj *key);\nvoid setExpire(client *c, redisDb *db, robj *key, long long when);\nint checkAlreadyExpired(long long when);\nrobj *lookupKey(redisDb *db, robj *key, int flags);\nrobj *lookupKeyRead(redisDb *db, robj *key);\nrobj *lookupKeyWrite(redisDb *db, robj *key);\nrobj *lookupKeyReadOrReply(client *c, robj *key, robj *reply);\nrobj *lookupKeyWriteOrReply(client *c, robj *key, robj *reply);\nrobj *lookupKeyReadWithFlags(redisDb *db, robj *key, int flags);\nrobj *lookupKeyWriteWithFlags(redisDb *db, robj *key, int flags);\nrobj *objectCommandLookup(client *c, robj *key);\nrobj *objectCommandLookupOrReply(client *c, robj *key, robj *reply);\nint objectSetLRUOrLFU(robj *val, long long lfu_freq, long long lru_idle,\n                       long long lru_clock, int lru_multiplier);\n#define LOOKUP_NONE 0\n#define LOOKUP_NOTOUCH (1<<0)\n#define LOOKUP_NONOTIFY (1<<1)\nvoid dbAdd(redisDb *db, robj *key, robj *val);\nint dbAddRDBLoad(redisDb *db, sds key, robj *val);\nvoid dbOverwrite(redisDb *db, robj *key, robj *val);\nvoid genericSetKey(client *c, redisDb *db, robj *key, robj *val, int keepttl, int signal);\nvoid setKey(client *c, redisDb *db, robj *key, robj *val);\nint dbExists(redisDb *db, robj *key);\nrobj *dbRandomKey(redisDb *db);\nint dbSyncDelete(redisDb *db, robj *key);\nint dbDelete(redisDb *db, robj *key);\nrobj *dbUnshareStringValue(redisDb *db, robj *key, robj *o);\n\n#define EMPTYDB_NO_FLAGS 0      /* No flags. */\n#define EMPTYDB_ASYNC (1<<0)    /* Reclaim memory in another thread. */\nlong long emptyDb(int dbnum, int flags, void(callback)(void*));\nlong long emptyDbStructure(redisDb *dbarray, int dbnum, int async, void(callback)(void*));\nvoid flushAllDataAndResetRDB(int flags);\nlong long dbTotalServerKeyCount();\ndbBackup *backupDb(void);\nvoid restoreDbBackup(dbBackup *buckup);\nvoid discardDbBackup(dbBackup *buckup, int flags, void(callback)(void*));\n\n\nint selectDb(client *c, int id);\nvoid signalModifiedKey(client *c, redisDb *db, robj *key);\nvoid signalFlushedDb(int dbid);\nunsigned int getKeysInSlot(unsigned int hashslot, robj **keys, unsigned int count);\nunsigned int countKeysInSlot(unsigned int hashslot);\nunsigned int delKeysInSlot(unsigned int hashslot);\nint verifyClusterConfigWithData(void);\nvoid scanGenericCommand(client *c, robj *o, unsigned long cursor);\nint parseScanCursorOrReply(client *c, robj *o, unsigned long *cursor);\nvoid slotToKeyAdd(sds key);\nvoid slotToKeyDel(sds key);\nint dbAsyncDelete(redisDb *db, robj *key);\nvoid emptyDbAsync(redisDb *db);\nvoid slotToKeyFlush(int async);\nsize_t lazyfreeGetPendingObjectsCount(void);\nvoid freeObjAsync(robj *obj);\nvoid freeSlotsToKeysMapAsync(rax *rt);\nvoid freeSlotsToKeysMap(rax *rt, int async);\n\n\n/* API to get key arguments from commands */\nint *getKeysPrepareResult(getKeysResult *result, int numkeys);\nint getKeysFromCommand(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result);\nvoid getKeysFreeResult(getKeysResult *result);\nint zunionInterGetKeys(struct redisCommand *cmd,robj **argv, int argc, getKeysResult *result);\nint evalGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result);\nint sortGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result);\nint migrateGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result);\nint georadiusGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result);\nint xreadGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result);\nint memoryGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result);\nint lcsGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result);\n\n/* Cluster */\nvoid clusterInit(void);\nunsigned short crc16(const char *buf, int len);\nunsigned int keyHashSlot(char *key, int keylen);\nvoid clusterCron(void);\nvoid clusterPropagatePublish(robj *channel, robj *message);\nvoid migrateCloseTimedoutSockets(void);\nvoid clusterBeforeSleep(void);\nint clusterSendModuleMessageToTarget(const char *target, uint64_t module_id, uint8_t type, unsigned char *payload, uint32_t len);\n\n/* Sentinel */\nvoid initSentinelConfig(void);\nvoid initSentinel(void);\nvoid sentinelTimer(void);\nchar *sentinelHandleConfiguration(char **argv, int argc);\nvoid sentinelIsRunning(void);\n\n/* redis-check-rdb & aof */\nint redis_check_rdb(char *rdbfilename, FILE *fp);\nint redis_check_rdb_main(int argc, char **argv, FILE *fp);\nint redis_check_aof_main(int argc, char **argv);\n\n/* Scripting */\nvoid scriptingInit(int setup);\nint ldbRemoveChild(pid_t pid);\nvoid ldbKillForkedSessions(void);\nint ldbPendingChildren(void);\nsds luaCreateFunction(client *c, lua_State *lua, robj *body);\n\n/* Blocked clients */\nvoid processUnblockedClients(void);\nvoid blockClient(client *c, int btype);\nvoid unblockClient(client *c);\nvoid queueClientForReprocessing(client *c);\nvoid replyToBlockedClientTimedOut(client *c);\nint getTimeoutFromObjectOrReply(client *c, robj *object, mstime_t *timeout, int unit);\nvoid disconnectAllBlockedClients(void);\nvoid handleClientsBlockedOnKeys(void);\nvoid signalKeyAsReady(redisDb *db, robj *key);\nvoid blockForKeys(client *c, int btype, robj **keys, int numkeys, mstime_t timeout, robj *target, streamID *ids);\n\n/* timeout.c -- Blocked clients timeout and connections timeout. */\nvoid addClientToTimeoutTable(client *c);\nvoid removeClientFromTimeoutTable(client *c);\nvoid handleBlockedClientsTimeout(void);\nint clientsCronHandleTimeout(client *c, mstime_t now_ms);\n\n/* expire.c -- Handling of expired keys */\nvoid activeExpireCycle(int type);\nvoid expireSlaveKeys(void);\nvoid rememberSlaveKeyWithExpire(redisDb *db, robj *key);\nvoid flushSlaveKeysWithExpireList(void);\nsize_t getSlaveKeyWithExpireCount(void);\n\n/* evict.c -- maxmemory handling and LRU eviction. */\nvoid evictionPoolAlloc(void);\n#define LFU_INIT_VAL 5\nunsigned long LFUGetTimeInMinutes(void);\nuint8_t LFULogIncr(uint8_t value);\nunsigned long LFUDecrAndReturn(robj *o);\n\n/* Keys hashing / comparison functions for dict.c hash tables. */\nuint64_t dictSdsHash(const void *key);\nint dictSdsKeyCompare(void *privdata, const void *key1, const void *key2);\nvoid dictSdsDestructor(void *privdata, void *val);\n\n/* Git SHA1 */\nchar *redisGitSHA1(void);\nchar *redisGitDirty(void);\nuint64_t redisBuildId(void);\nchar *redisBuildIdString(void);\n\n/* Commands prototypes */\nvoid authCommand(client *c);\nvoid pingCommand(client *c);\nvoid echoCommand(client *c);\nvoid commandCommand(client *c);\nvoid setCommand(client *c);\nvoid setnxCommand(client *c);\nvoid setexCommand(client *c);\nvoid psetexCommand(client *c);\nvoid getCommand(client *c);\nvoid delCommand(client *c);\nvoid unlinkCommand(client *c);\nvoid existsCommand(client *c);\nvoid setbitCommand(client *c);\nvoid getbitCommand(client *c);\nvoid bitfieldCommand(client *c);\nvoid bitfieldroCommand(client *c);\nvoid setrangeCommand(client *c);\nvoid getrangeCommand(client *c);\nvoid incrCommand(client *c);\nvoid decrCommand(client *c);\nvoid incrbyCommand(client *c);\nvoid decrbyCommand(client *c);\nvoid incrbyfloatCommand(client *c);\nvoid selectCommand(client *c);\nvoid swapdbCommand(client *c);\nvoid randomkeyCommand(client *c);\nvoid keysCommand(client *c);\nvoid scanCommand(client *c);\nvoid dbsizeCommand(client *c);\nvoid lastsaveCommand(client *c);\nvoid saveCommand(client *c);\nvoid bgsaveCommand(client *c);\nvoid bgrewriteaofCommand(client *c);\nvoid shutdownCommand(client *c);\nvoid moveCommand(client *c);\nvoid renameCommand(client *c);\nvoid renamenxCommand(client *c);\nvoid lpushCommand(client *c);\nvoid rpushCommand(client *c);\nvoid lpushxCommand(client *c);\nvoid rpushxCommand(client *c);\nvoid linsertCommand(client *c);\nvoid lpopCommand(client *c);\nvoid rpopCommand(client *c);\nvoid llenCommand(client *c);\nvoid lindexCommand(client *c);\nvoid lrangeCommand(client *c);\nvoid ltrimCommand(client *c);\nvoid typeCommand(client *c);\nvoid lsetCommand(client *c);\nvoid saddCommand(client *c);\nvoid sremCommand(client *c);\nvoid smoveCommand(client *c);\nvoid sismemberCommand(client *c);\nvoid scardCommand(client *c);\nvoid spopCommand(client *c);\nvoid srandmemberCommand(client *c);\nvoid sinterCommand(client *c);\nvoid sinterstoreCommand(client *c);\nvoid sunionCommand(client *c);\nvoid sunionstoreCommand(client *c);\nvoid sdiffCommand(client *c);\nvoid sdiffstoreCommand(client *c);\nvoid sscanCommand(client *c);\nvoid syncCommand(client *c);\nvoid flushdbCommand(client *c);\nvoid flushallCommand(client *c);\nvoid sortCommand(client *c);\nvoid lremCommand(client *c);\nvoid lposCommand(client *c);\nvoid rpoplpushCommand(client *c);\nvoid infoCommand(client *c);\nvoid mgetCommand(client *c);\nvoid monitorCommand(client *c);\nvoid expireCommand(client *c);\nvoid expireatCommand(client *c);\nvoid pexpireCommand(client *c);\nvoid pexpireatCommand(client *c);\nvoid getsetCommand(client *c);\nvoid ttlCommand(client *c);\nvoid touchCommand(client *c);\nvoid pttlCommand(client *c);\nvoid persistCommand(client *c);\nvoid replicaofCommand(client *c);\nvoid roleCommand(client *c);\nvoid debugCommand(client *c);\nvoid msetCommand(client *c);\nvoid msetnxCommand(client *c);\nvoid zaddCommand(client *c);\nvoid zincrbyCommand(client *c);\nvoid zrangeCommand(client *c);\nvoid zrangebyscoreCommand(client *c);\nvoid zrevrangebyscoreCommand(client *c);\nvoid zrangebylexCommand(client *c);\nvoid zrevrangebylexCommand(client *c);\nvoid zcountCommand(client *c);\nvoid zlexcountCommand(client *c);\nvoid zrevrangeCommand(client *c);\nvoid zcardCommand(client *c);\nvoid zremCommand(client *c);\nvoid zscoreCommand(client *c);\nvoid zremrangebyscoreCommand(client *c);\nvoid zremrangebylexCommand(client *c);\nvoid zpopminCommand(client *c);\nvoid zpopmaxCommand(client *c);\nvoid bzpopminCommand(client *c);\nvoid bzpopmaxCommand(client *c);\nvoid multiCommand(client *c);\nvoid execCommand(client *c);\nvoid discardCommand(client *c);\nvoid blpopCommand(client *c);\nvoid brpopCommand(client *c);\nvoid brpoplpushCommand(client *c);\nvoid appendCommand(client *c);\nvoid strlenCommand(client *c);\nvoid zrankCommand(client *c);\nvoid zrevrankCommand(client *c);\nvoid hsetCommand(client *c);\nvoid hsetnxCommand(client *c);\nvoid hgetCommand(client *c);\nvoid hmsetCommand(client *c);\nvoid hmgetCommand(client *c);\nvoid hdelCommand(client *c);\nvoid hlenCommand(client *c);\nvoid hstrlenCommand(client *c);\nvoid zremrangebyrankCommand(client *c);\nvoid zunionstoreCommand(client *c);\nvoid zinterstoreCommand(client *c);\nvoid zscanCommand(client *c);\nvoid hkeysCommand(client *c);\nvoid hvalsCommand(client *c);\nvoid hgetallCommand(client *c);\nvoid hexistsCommand(client *c);\nvoid hscanCommand(client *c);\nvoid configCommand(client *c);\nvoid hincrbyCommand(client *c);\nvoid hincrbyfloatCommand(client *c);\nvoid subscribeCommand(client *c);\nvoid unsubscribeCommand(client *c);\nvoid psubscribeCommand(client *c);\nvoid punsubscribeCommand(client *c);\nvoid publishCommand(client *c);\nvoid pubsubCommand(client *c);\nvoid watchCommand(client *c);\nvoid unwatchCommand(client *c);\nvoid clusterCommand(client *c);\nvoid restoreCommand(client *c);\nvoid migrateCommand(client *c);\nvoid askingCommand(client *c);\nvoid readonlyCommand(client *c);\nvoid readwriteCommand(client *c);\nvoid dumpCommand(client *c);\nvoid objectCommand(client *c);\nvoid memoryCommand(client *c);\nvoid clientCommand(client *c);\nvoid helloCommand(client *c);\nvoid evalCommand(client *c);\nvoid evalShaCommand(client *c);\nvoid scriptCommand(client *c);\nvoid timeCommand(client *c);\nvoid bitopCommand(client *c);\nvoid bitcountCommand(client *c);\nvoid bitposCommand(client *c);\nvoid replconfCommand(client *c);\nvoid waitCommand(client *c);\nvoid geoencodeCommand(client *c);\nvoid geodecodeCommand(client *c);\nvoid georadiusbymemberCommand(client *c);\nvoid georadiusbymemberroCommand(client *c);\nvoid georadiusCommand(client *c);\nvoid georadiusroCommand(client *c);\nvoid geoaddCommand(client *c);\nvoid geohashCommand(client *c);\nvoid geoposCommand(client *c);\nvoid geodistCommand(client *c);\nvoid pfselftestCommand(client *c);\nvoid pfaddCommand(client *c);\nvoid pfcountCommand(client *c);\nvoid pfmergeCommand(client *c);\nvoid pfdebugCommand(client *c);\nvoid latencyCommand(client *c);\nvoid moduleCommand(client *c);\nvoid securityWarningCommand(client *c);\nvoid xaddCommand(client *c);\nvoid xrangeCommand(client *c);\nvoid xrevrangeCommand(client *c);\nvoid xlenCommand(client *c);\nvoid xreadCommand(client *c);\nvoid xgroupCommand(client *c);\nvoid xsetidCommand(client *c);\nvoid xackCommand(client *c);\nvoid xpendingCommand(client *c);\nvoid xclaimCommand(client *c);\nvoid xinfoCommand(client *c);\nvoid xdelCommand(client *c);\nvoid xtrimCommand(client *c);\nvoid lolwutCommand(client *c);\nvoid aclCommand(client *c);\nvoid stralgoCommand(client *c);\n\n#if defined(__GNUC__)\nvoid *calloc(size_t count, size_t size) __attribute__ ((deprecated));\nvoid free(void *ptr) __attribute__ ((deprecated));\nvoid *malloc(size_t size) __attribute__ ((deprecated));\nvoid *realloc(void *ptr, size_t size) __attribute__ ((deprecated));\n#endif\n\n/* Debugging stuff */\nvoid _serverAssertWithInfo(const client *c, const robj *o, const char *estr, const char *file, int line);\nvoid _serverAssert(const char *estr, const char *file, int line);\n#ifdef __GNUC__\nvoid _serverPanic(const char *file, int line, const char *msg, ...)\n    __attribute__ ((format (printf, 3, 4)));\n#else\nvoid _serverPanic(const char *file, int line, const char *msg, ...);\n#endif\nvoid bugReportStart(void);\nvoid serverLogObjectDebugInfo(const robj *o);\nvoid sigsegvHandler(int sig, siginfo_t *info, void *secret);\nsds genRedisInfoString(const char *section);\nsds genModulesInfoString(sds info);\nvoid enableWatchdog(int period);\nvoid disableWatchdog(void);\nvoid watchdogScheduleSignal(int period);\nvoid serverLogHexDump(int level, char *descr, void *value, size_t len);\nint memtest_preserving_test(unsigned long *m, size_t bytes, int passes);\nvoid mixDigest(unsigned char *digest, void *ptr, size_t len);\nvoid xorDigest(unsigned char *digest, void *ptr, size_t len);\nint populateCommandTableParseFlags(struct redisCommand *c, char *strflags);\nvoid killIOThreads(void);\nvoid killThreads(void);\nvoid makeThreadKillable(void);\n\n/* TLS stuff */\nvoid tlsInit(void);\nint tlsConfigure(redisTLSContextConfig *ctx_config);\n\n#define redisDebug(fmt, ...) \\\n    printf(\"DEBUG %s:%d > \" fmt \"\\n\", __FILE__, __LINE__, __VA_ARGS__)\n#define redisDebugMark() \\\n    printf(\"-- MARK %s:%d --\\n\", __FILE__, __LINE__)\n\nint iAmMaster(void);\n\n#endif\n", "start_server {tags {\"auth\"}} {\n    test {AUTH fails if there is no password configured server side} {\n        catch {r auth foo} err\n        set _ $err\n    } {ERR*any password*}\n}\n\nstart_server {tags {\"auth\"} overrides {requirepass foobar}} {\n    test {AUTH fails when a wrong password is given} {\n        catch {r auth wrong!} err\n        set _ $err\n    } {WRONGPASS*}\n\n    test {Arbitrary command gives an error when AUTH is required} {\n        catch {r set foo bar} err\n        set _ $err\n    } {NOAUTH*}\n\n    test {AUTH succeeds when the right password is given} {\n        r auth foobar\n    } {OK}\n\n    test {Once AUTH succeeded we can actually send commands to the server} {\n        r set foo 100\n        r incr foo\n    } {101}\n\n    test {For unauthenticated clients multibulk and bulk length are limited} {\n        set rr [redis [srv \"host\"] [srv \"port\"] 0 $::tls]\n        $rr write \"*100\\r\\n\"\n        $rr flush\n        catch {[$rr read]} e\n        assert_match {*unauthenticated multibulk length*} $e\n        $rr close\n\n        set rr [redis [srv \"host\"] [srv \"port\"] 0 $::tls]\n        $rr write \"*1\\r\\n\\$100000000\\r\\n\"\n        $rr flush\n        catch {[$rr read]} e\n        assert_match {*unauthenticated bulk length*} $e\n        $rr close\n    }\n}\n"], "filenames": ["src/networking.c", "src/server.c", "src/server.h", "tests/unit/auth.tcl"], "buggy_code_start_loc": [97, 3593, 1745, 26], "buggy_code_end_loc": [1792, 3600, 1745, 26], "fixing_code_start_loc": [98, 3593, 1746, 27], "fixing_code_end_loc": [1810, 3595, 1747, 43], "type": "CWE-770", "message": "Redis is an open source, in-memory database that persists on disk. When parsing an incoming Redis Standard Protocol (RESP) request, Redis allocates memory according to user-specified values which determine the number of elements (in the multi-bulk header) and size of each element (in the bulk header). An attacker delivering specially crafted requests over multiple connections can cause the server to allocate significant amount of memory. Because the same parsing mechanism is used to handle authentication requests, this vulnerability can also be exploited by unauthenticated users. The problem is fixed in Redis versions 6.2.6, 6.0.16 and 5.0.14. An additional workaround to mitigate this problem without patching the redis-server executable is to block access to prevent unauthenticated users from connecting to Redis. This can be done in different ways: Using network access control tools like firewalls, iptables, security groups, etc. or Enabling TLS and requiring users to authenticate using client side certificates.", "other": {"cve": {"id": "CVE-2021-32675", "sourceIdentifier": "security-advisories@github.com", "published": "2021-10-04T18:15:08.923", "lastModified": "2022-10-06T16:51:01.897", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Redis is an open source, in-memory database that persists on disk. When parsing an incoming Redis Standard Protocol (RESP) request, Redis allocates memory according to user-specified values which determine the number of elements (in the multi-bulk header) and size of each element (in the bulk header). An attacker delivering specially crafted requests over multiple connections can cause the server to allocate significant amount of memory. Because the same parsing mechanism is used to handle authentication requests, this vulnerability can also be exploited by unauthenticated users. The problem is fixed in Redis versions 6.2.6, 6.0.16 and 5.0.14. An additional workaround to mitigate this problem without patching the redis-server executable is to block access to prevent unauthenticated users from connecting to Redis. This can be done in different ways: Using network access control tools like firewalls, iptables, security groups, etc. or Enabling TLS and requiring users to authenticate using client side certificates."}, {"lang": "es", "value": "Redis es una base de datos en memoria de c\u00f3digo abierto que persiste en el disco. Cuando es analizada una petici\u00f3n entrante del Protocolo Est\u00e1ndar de Redis (RESP), Redis asigna la memoria de acuerdo con los valores especificados por el usuario, que determinan el n\u00famero de elementos (en el encabezado multi-bulk) y el tama\u00f1o de cada elemento (en el encabezado bulk). Un atacante que env\u00ede peticiones especialmente dise\u00f1adas a trav\u00e9s de m\u00faltiples conexiones puede causar que el servidor asigne una cantidad significativa de memoria. Debido a que el mismo mecanismo de an\u00e1lisis es usado para manejar las peticiones de autenticaci\u00f3n, esta vulnerabilidad tambi\u00e9n puede ser explotada por usuarios no autenticados. El problema se ha corregido en las versiones de Redis 6.2.6, 6.0.16 y 5.0.14. Una soluci\u00f3n adicional para mitigar este problema sin necesidad de parchear el ejecutable del servidor Redis es bloquear el acceso para evitar que los usuarios no autentificados se conecten a Redis. Esto puede hacerse de diferentes maneras: Usando herramientas de control de acceso a la red como firewalls, iptables, grupos de seguridad, etc. o Habilitando TLS y requiriendo que los usuarios se autentiquen usando certificados del lado del cliente"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-770"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-770"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redis:redis:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.0.0", "versionEndExcluding": "5.0.14", "matchCriteriaId": "D5D64A76-B253-4A64-8AA2-DD8815CB3CF8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redis:redis:*:*:*:*:*:*:*:*", "versionStartIncluding": "6.0.0", "versionEndExcluding": "6.0.16", "matchCriteriaId": "02DF8086-645E-4D42-93D3-A4B11D289C7C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redis:redis:*:*:*:*:*:*:*:*", "versionStartIncluding": "6.2.0", "versionEndExcluding": "6.2.6", "matchCriteriaId": "4686800E-16BA-42CE-B691-011D1D5D0CC2"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:33:*:*:*:*:*:*:*", "matchCriteriaId": "E460AA51-FCDA-46B9-AE97-E6676AA5E194"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:11.0:*:*:*:*:*:*:*", "matchCriteriaId": "FA6FEEC2-9F11-4643-8827-749718254FED"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:management_services_for_element_software:-:*:*:*:*:*:*:*", "matchCriteriaId": "86B51137-28D9-41F2-AFA2-3CC22B4954D1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:management_services_for_netapp_hci:-:*:*:*:*:*:*:*", "matchCriteriaId": "4455CF3A-CC91-4BE4-A7AB-929AC82E34F5"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_operations_monitor:4.3:*:*:*:*:*:*:*", "matchCriteriaId": "CBE1A019-7BB6-4226-8AC4-9D6927ADAEFA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_operations_monitor:4.4:*:*:*:*:*:*:*", "matchCriteriaId": "B98BAEB2-A540-4E8A-A946-C4331B913AFD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_operations_monitor:5.0:*:*:*:*:*:*:*", "matchCriteriaId": "B8FBE260-E306-4215-80C0-D2D27CA43E0F"}]}]}], "references": [{"url": "https://github.com/redis/redis/commit/5674b0057ff2903d43eaff802017eddf37c360f8", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/redis/redis/security/advisories/GHSA-f6pw-v9gw-v64p", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/ra603ff6e04549d7f290f61f9b11e2d2e4dba693b05ff053f4ec6bc47@%3Cnotifications.geode.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/HTYQ5ZF37HNGTZWVNJD3VXP7I6MEEF42/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/VL5KXFN3ATM7IIM7Q4O4PWTSRGZ5744Z/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/WR5WKJWXD4D6S3DJCZ56V74ESLTDQRAB/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202209-17", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20211104-0003/", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2021/dsa-5001", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpuapr2022.html", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/redis/redis/commit/5674b0057ff2903d43eaff802017eddf37c360f8"}}