{"buggy_code": ["/*\n * Copyright (c) 2007 Henrique Pinto <henrique.pinto@kdemail.net>\n * Copyright (c) 2008-2009 Harald Hvaal <haraldhv@stud.ntnu.no>\n * Copyright (c) 2010 Raphael Kubo da Costa <rakuco@FreeBSD.org>\n * Copyright (c) 2016 Vladyslav Batyrenko <mvlabat@gmail.com>\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ( INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION ) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * ( INCLUDING NEGLIGENCE OR OTHERWISE ) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"libarchiveplugin.h\"\n#include \"ark_debug.h\"\n#include \"queries.h\"\n\n#include <KLocalizedString>\n\n#include <QThread>\n#include <QFileInfo>\n#include <QDir>\n\n#include <archive_entry.h>\n\nLibarchivePlugin::LibarchivePlugin(QObject *parent, const QVariantList &args)\n    : ReadWriteArchiveInterface(parent, args)\n    , m_archiveReadDisk(archive_read_disk_new())\n    , m_cachedArchiveEntryCount(0)\n    , m_emitNoEntries(false)\n    , m_extractedFilesSize(0)\n{\n    qCDebug(ARK) << \"Initializing libarchive plugin\";\n    archive_read_disk_set_standard_lookup(m_archiveReadDisk.data());\n\n    connect(this, &ReadOnlyArchiveInterface::error, this, &LibarchivePlugin::slotRestoreWorkingDir);\n    connect(this, &ReadOnlyArchiveInterface::cancelled, this, &LibarchivePlugin::slotRestoreWorkingDir);\n}\n\nLibarchivePlugin::~LibarchivePlugin()\n{\n    for (const auto e : qAsConst(m_emittedEntries)) {\n        // Entries might be passed to pending slots, so we just schedule their deletion.\n        e->deleteLater();\n    }\n}\n\nbool LibarchivePlugin::list()\n{\n    qCDebug(ARK) << \"Listing archive contents\";\n\n    if (!initializeReader()) {\n        return false;\n    }\n\n    qCDebug(ARK) << \"Detected compression filter:\" << archive_filter_name(m_archiveReader.data(), 0);\n    QString compMethod = convertCompressionName(QString::fromUtf8(archive_filter_name(m_archiveReader.data(), 0)));\n    if (!compMethod.isEmpty()) {\n        emit compressionMethodFound(compMethod);\n    }\n\n    m_cachedArchiveEntryCount = 0;\n    m_extractedFilesSize = 0;\n    m_numberOfEntries = 0;\n    auto compressedArchiveSize = QFileInfo(filename()).size();\n\n    struct archive_entry *aentry;\n    int result = ARCHIVE_RETRY;\n\n    bool firstEntry = true;\n    while (!QThread::currentThread()->isInterruptionRequested() && (result = archive_read_next_header(m_archiveReader.data(), &aentry)) == ARCHIVE_OK) {\n\n        if (firstEntry) {\n            qCDebug(ARK) << \"Detected format for first entry:\" << archive_format_name(m_archiveReader.data());\n            firstEntry = false;\n        }\n\n        if (!m_emitNoEntries) {\n            emitEntryFromArchiveEntry(aentry);\n        }\n\n        m_extractedFilesSize += (qlonglong)archive_entry_size(aentry);\n\n        emit progress(float(archive_filter_bytes(m_archiveReader.data(), -1))/float(compressedArchiveSize));\n\n        m_cachedArchiveEntryCount++;\n\n        // Skip the entry data.\n        int readSkipResult = archive_read_data_skip(m_archiveReader.data());\n        if (readSkipResult != ARCHIVE_OK) {\n            qCCritical(ARK) << \"Error while skipping data for entry:\"\n                            << QString::fromWCharArray(archive_entry_pathname_w(aentry))\n                            << readSkipResult\n                            << QLatin1String(archive_error_string(m_archiveReader.data()));\n            if (!emitCorruptArchive()) {\n                return false;\n            }\n        }\n    }\n\n    if (result != ARCHIVE_EOF) {\n        qCCritical(ARK) << \"Error while reading archive:\"\n                        << result\n                        << QLatin1String(archive_error_string(m_archiveReader.data()));\n        if (!emitCorruptArchive()) {\n            return false;\n        }\n    }\n\n    return archive_read_close(m_archiveReader.data()) == ARCHIVE_OK;\n}\n\nbool LibarchivePlugin::emitCorruptArchive()\n{\n    Kerfuffle::LoadCorruptQuery query(filename());\n    emit userQuery(&query);\n    query.waitForResponse();\n    if (!query.responseYes()) {\n        emit cancelled();\n        archive_read_close(m_archiveReader.data());\n        return false;\n    } else {\n        emit progress(1.0);\n        return true;\n    }\n}\n\nbool LibarchivePlugin::addFiles(const QVector<Archive::Entry*> &files, const Archive::Entry *destination, const CompressionOptions &options, uint numberOfEntriesToAdd)\n{\n    Q_UNUSED(files)\n    Q_UNUSED(destination)\n    Q_UNUSED(options)\n    Q_UNUSED(numberOfEntriesToAdd)\n    return false;\n}\n\nbool LibarchivePlugin::moveFiles(const QVector<Archive::Entry*> &files, Archive::Entry *destination, const CompressionOptions &options)\n{\n    Q_UNUSED(files)\n    Q_UNUSED(destination)\n    Q_UNUSED(options)\n    return false;\n}\n\nbool LibarchivePlugin::copyFiles(const QVector<Archive::Entry*> &files, Archive::Entry *destination, const CompressionOptions &options)\n{\n    Q_UNUSED(files)\n    Q_UNUSED(destination)\n    Q_UNUSED(options)\n    return false;\n}\n\nbool LibarchivePlugin::deleteFiles(const QVector<Archive::Entry*> &files)\n{\n    Q_UNUSED(files)\n    return false;\n}\n\nbool LibarchivePlugin::addComment(const QString &comment)\n{\n    Q_UNUSED(comment)\n    return false;\n}\n\nbool LibarchivePlugin::testArchive()\n{\n    return false;\n}\n\nbool LibarchivePlugin::hasBatchExtractionProgress() const\n{\n    return true;\n}\n\nbool LibarchivePlugin::doKill()\n{\n    return false;\n}\n\nbool LibarchivePlugin::extractFiles(const QVector<Archive::Entry*> &files, const QString &destinationDirectory, const ExtractionOptions &options)\n{\n    if (!initializeReader()) {\n        return false;\n    }\n\n    ArchiveWrite writer(archive_write_disk_new());\n    if (!writer.data()) {\n        return false;\n    }\n\n    archive_write_disk_set_options(writer.data(), extractionFlags());\n\n    int totalEntriesCount = 0;\n    const bool extractAll = files.isEmpty();\n    if (extractAll) {\n        if (!m_cachedArchiveEntryCount) {\n            emit progress(0);\n            //TODO: once information progress has been implemented, send\n            //feedback here that the archive is being read\n            qCDebug(ARK) << \"For getting progress information, the archive will be listed once\";\n            m_emitNoEntries = true;\n            list();\n            m_emitNoEntries = false;\n        }\n        totalEntriesCount = m_cachedArchiveEntryCount;\n    } else {\n        totalEntriesCount = files.size();\n    }\n\n    qCDebug(ARK) << \"Going to extract\" << totalEntriesCount << \"entries\";\n\n    qCDebug(ARK) << \"Changing current directory to \" << destinationDirectory;\n    m_oldWorkingDir = QDir::currentPath();\n    QDir::setCurrent(destinationDirectory);\n\n    // Initialize variables.\n    const bool preservePaths = options.preservePaths();\n    const bool removeRootNode = options.isDragAndDropEnabled();\n    bool overwriteAll = false; // Whether to overwrite all files\n    bool skipAll = false; // Whether to skip all files\n    bool dontPromptErrors = false; // Whether to prompt for errors\n    m_currentExtractedFilesSize = 0;\n    int extractedEntriesCount = 0;\n    int progressEntryCount = 0;\n    struct archive_entry *entry;\n    QString fileBeingRenamed;\n    // To avoid traversing the entire archive when extracting a limited set of\n    // entries, we maintain a list of remaining entries and stop when it's empty.\n    const QStringList fullPaths = entryFullPaths(files);\n    QStringList remainingFiles = entryFullPaths(files);\n\n    // Iterate through all entries in archive.\n    while (!QThread::currentThread()->isInterruptionRequested() && (archive_read_next_header(m_archiveReader.data(), &entry) == ARCHIVE_OK)) {\n\n        if (!extractAll && remainingFiles.isEmpty()) {\n            break;\n        }\n\n        fileBeingRenamed.clear();\n        int index = -1;\n\n        // Retry with renamed entry, fire an overwrite query again\n        // if the new entry also exists.\n    retry:\n        const bool entryIsDir = S_ISDIR(archive_entry_mode(entry));\n        // Skip directories if not preserving paths.\n        if (!preservePaths && entryIsDir) {\n            archive_read_data_skip(m_archiveReader.data());\n            continue;\n        }\n\n        // entryName is the name inside the archive, full path\n        QString entryName = QDir::fromNativeSeparators(QFile::decodeName(archive_entry_pathname(entry)));\n\n        // Some archive types e.g. AppImage prepend all entries with \"./\" so remove this part.\n        if (entryName.startsWith(QLatin1String(\"./\"))) {\n            entryName.remove(0, 2);\n        }\n\n        // Static libraries (*.a) contain the two entries \"/\" and \"//\".\n        // We just skip these to allow extracting this archive type.\n        if (entryName == QLatin1String(\"/\") || entryName == QLatin1String(\"//\")) {\n            archive_read_data_skip(m_archiveReader.data());\n            continue;\n        }\n\n        // For now we just can't handle absolute filenames in a tar archive.\n        // TODO: find out what to do here!!\n        if (entryName.startsWith(QLatin1Char( '/' ))) {\n            emit error(i18n(\"This archive contains archive entries with absolute paths, \"\n                            \"which are not supported by Ark.\"));\n            return false;\n        }\n\n        // Should the entry be extracted?\n        if (extractAll ||\n            remainingFiles.contains(entryName) ||\n            entryName == fileBeingRenamed) {\n\n            // Find the index of entry.\n            if (entryName != fileBeingRenamed) {\n                index = fullPaths.indexOf(entryName);\n            }\n            if (!extractAll && index == -1) {\n                // If entry is not found in files, skip entry.\n                continue;\n            }\n\n            // entryFI is the fileinfo pointing to where the file will be\n            // written from the archive.\n            QFileInfo entryFI(entryName);\n            //qCDebug(ARK) << \"setting path to \" << archive_entry_pathname( entry );\n\n            const QString fileWithoutPath(entryFI.fileName());\n            // If we DON'T preserve paths, we cut the path and set the entryFI\n            // fileinfo to the one without the path.\n            if (!preservePaths) {\n                // Empty filenames (ie dirs) should have been skipped already,\n                // so asserting.\n                Q_ASSERT(!fileWithoutPath.isEmpty());\n                archive_entry_copy_pathname(entry, QFile::encodeName(fileWithoutPath).constData());\n                entryFI = QFileInfo(fileWithoutPath);\n\n            // OR, if the file has a rootNode attached, remove it from file path.\n            } else if (!extractAll && removeRootNode && entryName != fileBeingRenamed) {\n                const QString &rootNode = files.at(index)->rootNode;\n                if (!rootNode.isEmpty()) {\n                    const QString truncatedFilename(entryName.remove(entryName.indexOf(rootNode), rootNode.size()));\n                    archive_entry_copy_pathname(entry, QFile::encodeName(truncatedFilename).constData());\n                    entryFI = QFileInfo(truncatedFilename);\n                }\n            }\n\n            // Check if the file about to be written already exists.\n            if (!entryIsDir && entryFI.exists()) {\n                if (skipAll) {\n                    archive_read_data_skip(m_archiveReader.data());\n                    archive_entry_clear(entry);\n                    continue;\n                } else if (!overwriteAll && !skipAll) {\n                    Kerfuffle::OverwriteQuery query(entryName);\n                    emit userQuery(&query);\n                    query.waitForResponse();\n\n                    if (query.responseCancelled()) {\n                        emit cancelled();\n                        archive_read_data_skip(m_archiveReader.data());\n                        archive_entry_clear(entry);\n                        break;\n                    } else if (query.responseSkip()) {\n                        archive_read_data_skip(m_archiveReader.data());\n                        archive_entry_clear(entry);\n                        continue;\n                    } else if (query.responseAutoSkip()) {\n                        archive_read_data_skip(m_archiveReader.data());\n                        archive_entry_clear(entry);\n                        skipAll = true;\n                        continue;\n                    } else if (query.responseRename()) {\n                        const QString newName(query.newFilename());\n                        fileBeingRenamed = newName;\n                        archive_entry_copy_pathname(entry, QFile::encodeName(newName).constData());\n                        goto retry;\n                    } else if (query.responseOverwriteAll()) {\n                        overwriteAll = true;\n                    }\n                }\n            }\n\n            // If there is an already existing directory.\n            if (entryIsDir && entryFI.exists()) {\n                if (entryFI.isWritable()) {\n                    qCWarning(ARK) << \"Warning, existing, but writable dir\";\n                } else {\n                    qCWarning(ARK) << \"Warning, existing, but non-writable dir. skipping\";\n                    archive_entry_clear(entry);\n                    archive_read_data_skip(m_archiveReader.data());\n                    continue;\n                }\n            }\n\n            // Write the entry header and check return value.\n            const int returnCode = archive_write_header(writer.data(), entry);\n            switch (returnCode) {\n            case ARCHIVE_OK:\n                // If the whole archive is extracted and the total filesize is\n                // available, we use partial progress.\n                copyData(entryName, m_archiveReader.data(), writer.data(), (extractAll && m_extractedFilesSize));\n                break;\n\n            case ARCHIVE_FAILED:\n                qCCritical(ARK) << \"archive_write_header() has returned\" << returnCode\n                                << \"with errno\" << archive_errno(writer.data());\n\n                // If they user previously decided to ignore future errors,\n                // don't bother prompting again.\n                if (!dontPromptErrors) {\n                    // Ask the user if he wants to continue extraction despite an error for this entry.\n                    Kerfuffle::ContinueExtractionQuery query(QLatin1String(archive_error_string(writer.data())),\n                                                             entryName);\n                    emit userQuery(&query);\n                    query.waitForResponse();\n\n                    if (query.responseCancelled()) {\n                        emit cancelled();\n                        return false;\n                    }\n                    dontPromptErrors = query.dontAskAgain();\n                }\n                break;\n\n            case ARCHIVE_FATAL:\n                qCCritical(ARK) << \"archive_write_header() has returned\" << returnCode\n                                << \"with errno\" << archive_errno(writer.data());\n                emit error(i18nc(\"@info\", \"Fatal error, extraction aborted.\"));\n                return false;\n            default:\n                qCDebug(ARK) << \"archive_write_header() returned\" << returnCode\n                             << \"which will be ignored.\";\n                break;\n            }\n\n            // If we only partially extract the archive and the number of\n            // archive entries is available we use a simple progress based on\n            // number of items extracted.\n            if (!extractAll && m_cachedArchiveEntryCount) {\n                ++progressEntryCount;\n                emit progress(float(progressEntryCount) / totalEntriesCount);\n            }\n\n            extractedEntriesCount++;\n            remainingFiles.removeOne(entryName);\n        } else {\n            // Archive entry not among selected files, skip it.\n            archive_read_data_skip(m_archiveReader.data());\n        }\n    }\n\n    qCDebug(ARK) << \"Extracted\" << extractedEntriesCount << \"entries\";\n    slotRestoreWorkingDir();\n    return archive_read_close(m_archiveReader.data()) == ARCHIVE_OK;\n}\n\nbool LibarchivePlugin::initializeReader()\n{\n    m_archiveReader.reset(archive_read_new());\n\n    if (!(m_archiveReader.data())) {\n        emit error(i18n(\"The archive reader could not be initialized.\"));\n        return false;\n    }\n\n    if (archive_read_support_filter_all(m_archiveReader.data()) != ARCHIVE_OK) {\n        return false;\n    }\n\n    if (archive_read_support_format_all(m_archiveReader.data()) != ARCHIVE_OK) {\n        return false;\n    }\n\n    if (archive_read_open_filename(m_archiveReader.data(), QFile::encodeName(filename()).constData(), 10240) != ARCHIVE_OK) {\n        qCWarning(ARK) << \"Could not open the archive:\" << archive_error_string(m_archiveReader.data());\n        emit error(i18nc(\"@info\", \"Archive corrupted or insufficient permissions.\"));\n        return false;\n    }\n\n    return true;\n}\n\nvoid LibarchivePlugin::emitEntryFromArchiveEntry(struct archive_entry *aentry)\n{\n    auto e = new Archive::Entry();\n\n#ifdef Q_OS_WIN\n    e->setProperty(\"fullPath\", QDir::fromNativeSeparators(QString::fromUtf16((ushort*)archive_entry_pathname_w(aentry))));\n#else\n    e->setProperty(\"fullPath\", QDir::fromNativeSeparators(QString::fromWCharArray(archive_entry_pathname_w(aentry))));\n#endif\n\n    const QString owner = QString::fromLatin1(archive_entry_uname(aentry));\n    if (!owner.isEmpty()) {\n        e->setProperty(\"owner\", owner);\n    } else {\n        e->setProperty(\"owner\", static_cast<qlonglong>(archive_entry_uid(aentry)));\n    }\n\n    const QString group = QString::fromLatin1(archive_entry_gname(aentry));\n    if (!group.isEmpty()) {\n        e->setProperty(\"group\", group);\n    } else {\n        e->setProperty(\"group\", static_cast<qlonglong>(archive_entry_gid(aentry)));\n    }\n\n    const mode_t mode = archive_entry_mode(aentry);\n    if (mode != 0) {\n        e->setProperty(\"permissions\", QString::number(mode, 8));\n    }\n    e->setProperty(\"isExecutable\", mode & (S_IXUSR | S_IXGRP | S_IXOTH));\n\n    e->compressedSizeIsSet = false;\n    e->setProperty(\"size\", (qlonglong)archive_entry_size(aentry));\n    e->setProperty(\"isDirectory\", S_ISDIR(archive_entry_mode(aentry)));\n\n    if (archive_entry_symlink(aentry)) {\n        e->setProperty(\"link\", QLatin1String( archive_entry_symlink(aentry) ));\n    }\n\n    auto time = static_cast<uint>(archive_entry_mtime(aentry));\n    e->setProperty(\"timestamp\", QDateTime::fromSecsSinceEpoch(time));\n\n    emit entry(e);\n    m_emittedEntries << e;\n}\n\nint LibarchivePlugin::extractionFlags() const\n{\n    int result = ARCHIVE_EXTRACT_TIME;\n    result |= ARCHIVE_EXTRACT_SECURE_NODOTDOT;\n\n    // TODO: Don't use arksettings here\n    /*if ( ArkSettings::preservePerms() )\n    {\n        result &= ARCHIVE_EXTRACT_PERM;\n    }\n\n    if ( !ArkSettings::extractOverwrite() )\n    {\n        result &= ARCHIVE_EXTRACT_NO_OVERWRITE;\n    }*/\n\n    return result;\n}\n\nvoid LibarchivePlugin::copyData(const QString& filename, struct archive *dest, bool partialprogress)\n{\n    char buff[10240];\n    QFile file(filename);\n\n    if (!file.open(QIODevice::ReadOnly)) {\n        return;\n    }\n\n    auto readBytes = file.read(buff, sizeof(buff));\n    while (readBytes > 0 && !QThread::currentThread()->isInterruptionRequested()) {\n        archive_write_data(dest, buff, static_cast<size_t>(readBytes));\n        if (archive_errno(dest) != ARCHIVE_OK) {\n            qCCritical(ARK) << \"Error while writing\" << filename << \":\" << archive_error_string(dest)\n                            << \"(error no =\" << archive_errno(dest) << ')';\n            return;\n        }\n\n        if (partialprogress) {\n            m_currentExtractedFilesSize += readBytes;\n            emit progress(float(m_currentExtractedFilesSize) / m_extractedFilesSize);\n        }\n\n        readBytes = file.read(buff, sizeof(buff));\n    }\n\n    file.close();\n}\n\nvoid LibarchivePlugin::copyData(const QString& filename, struct archive *source, struct archive *dest, bool partialprogress)\n{\n    char buff[10240];\n\n    auto readBytes = archive_read_data(source, buff, sizeof(buff));\n    while (readBytes > 0 && !QThread::currentThread()->isInterruptionRequested()) {\n        archive_write_data(dest, buff, static_cast<size_t>(readBytes));\n        if (archive_errno(dest) != ARCHIVE_OK) {\n            qCCritical(ARK) << \"Error while extracting\" << filename << \":\" << archive_error_string(dest)\n                            << \"(error no =\" << archive_errno(dest) << ')';\n            return;\n        }\n\n        if (partialprogress) {\n            m_currentExtractedFilesSize += readBytes;\n            emit progress(float(m_currentExtractedFilesSize) / m_extractedFilesSize);\n        }\n\n        readBytes = archive_read_data(source, buff, sizeof(buff));\n    }\n}\n\nvoid LibarchivePlugin::slotRestoreWorkingDir()\n{\n    if (m_oldWorkingDir.isEmpty()) {\n        return;\n    }\n\n    if (!QDir::setCurrent(m_oldWorkingDir)) {\n        qCWarning(ARK) << \"Failed to restore old working directory:\" << m_oldWorkingDir;\n    } else {\n        m_oldWorkingDir.clear();\n    }\n}\n\nQString LibarchivePlugin::convertCompressionName(const QString &method)\n{\n    if (method == QLatin1String(\"gzip\")) {\n        return QStringLiteral(\"GZip\");\n    } else if (method == QLatin1String(\"bzip2\")) {\n        return QStringLiteral(\"BZip2\");\n    } else if (method == QLatin1String(\"xz\")) {\n        return QStringLiteral(\"XZ\");\n    } else if (method == QLatin1String(\"compress (.Z)\")) {\n        return QStringLiteral(\"Compress\");\n    } else if (method == QLatin1String(\"lrzip\")) {\n        return QStringLiteral(\"LRZip\");\n    } else if (method == QLatin1String(\"lzip\")) {\n        return QStringLiteral(\"LZip\");\n    } else if (method == QLatin1String(\"lz4\")) {\n        return QStringLiteral(\"LZ4\");\n    } else if (method == QLatin1String(\"lzop\")) {\n        return QStringLiteral(\"lzop\");\n    } else if (method == QLatin1String(\"lzma\")) {\n        return QStringLiteral(\"LZMA\");\n    } else if (method == QLatin1String(\"zstd\")) {\n        return QStringLiteral(\"Zstandard\");\n    }\n    return QString();\n}\n\n"], "fixing_code": ["/*\n * Copyright (c) 2007 Henrique Pinto <henrique.pinto@kdemail.net>\n * Copyright (c) 2008-2009 Harald Hvaal <haraldhv@stud.ntnu.no>\n * Copyright (c) 2010 Raphael Kubo da Costa <rakuco@FreeBSD.org>\n * Copyright (c) 2016 Vladyslav Batyrenko <mvlabat@gmail.com>\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ( INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION ) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * ( INCLUDING NEGLIGENCE OR OTHERWISE ) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"libarchiveplugin.h\"\n#include \"ark_debug.h\"\n#include \"queries.h\"\n\n#include <KLocalizedString>\n\n#include <QThread>\n#include <QFileInfo>\n#include <QDir>\n\n#include <archive_entry.h>\n\nLibarchivePlugin::LibarchivePlugin(QObject *parent, const QVariantList &args)\n    : ReadWriteArchiveInterface(parent, args)\n    , m_archiveReadDisk(archive_read_disk_new())\n    , m_cachedArchiveEntryCount(0)\n    , m_emitNoEntries(false)\n    , m_extractedFilesSize(0)\n{\n    qCDebug(ARK) << \"Initializing libarchive plugin\";\n    archive_read_disk_set_standard_lookup(m_archiveReadDisk.data());\n\n    connect(this, &ReadOnlyArchiveInterface::error, this, &LibarchivePlugin::slotRestoreWorkingDir);\n    connect(this, &ReadOnlyArchiveInterface::cancelled, this, &LibarchivePlugin::slotRestoreWorkingDir);\n}\n\nLibarchivePlugin::~LibarchivePlugin()\n{\n    for (const auto e : qAsConst(m_emittedEntries)) {\n        // Entries might be passed to pending slots, so we just schedule their deletion.\n        e->deleteLater();\n    }\n}\n\nbool LibarchivePlugin::list()\n{\n    qCDebug(ARK) << \"Listing archive contents\";\n\n    if (!initializeReader()) {\n        return false;\n    }\n\n    qCDebug(ARK) << \"Detected compression filter:\" << archive_filter_name(m_archiveReader.data(), 0);\n    QString compMethod = convertCompressionName(QString::fromUtf8(archive_filter_name(m_archiveReader.data(), 0)));\n    if (!compMethod.isEmpty()) {\n        emit compressionMethodFound(compMethod);\n    }\n\n    m_cachedArchiveEntryCount = 0;\n    m_extractedFilesSize = 0;\n    m_numberOfEntries = 0;\n    auto compressedArchiveSize = QFileInfo(filename()).size();\n\n    struct archive_entry *aentry;\n    int result = ARCHIVE_RETRY;\n\n    bool firstEntry = true;\n    while (!QThread::currentThread()->isInterruptionRequested() && (result = archive_read_next_header(m_archiveReader.data(), &aentry)) == ARCHIVE_OK) {\n\n        if (firstEntry) {\n            qCDebug(ARK) << \"Detected format for first entry:\" << archive_format_name(m_archiveReader.data());\n            firstEntry = false;\n        }\n\n        if (!m_emitNoEntries) {\n            emitEntryFromArchiveEntry(aentry);\n        }\n\n        m_extractedFilesSize += (qlonglong)archive_entry_size(aentry);\n\n        emit progress(float(archive_filter_bytes(m_archiveReader.data(), -1))/float(compressedArchiveSize));\n\n        m_cachedArchiveEntryCount++;\n\n        // Skip the entry data.\n        int readSkipResult = archive_read_data_skip(m_archiveReader.data());\n        if (readSkipResult != ARCHIVE_OK) {\n            qCCritical(ARK) << \"Error while skipping data for entry:\"\n                            << QString::fromWCharArray(archive_entry_pathname_w(aentry))\n                            << readSkipResult\n                            << QLatin1String(archive_error_string(m_archiveReader.data()));\n            if (!emitCorruptArchive()) {\n                return false;\n            }\n        }\n    }\n\n    if (result != ARCHIVE_EOF) {\n        qCCritical(ARK) << \"Error while reading archive:\"\n                        << result\n                        << QLatin1String(archive_error_string(m_archiveReader.data()));\n        if (!emitCorruptArchive()) {\n            return false;\n        }\n    }\n\n    return archive_read_close(m_archiveReader.data()) == ARCHIVE_OK;\n}\n\nbool LibarchivePlugin::emitCorruptArchive()\n{\n    Kerfuffle::LoadCorruptQuery query(filename());\n    emit userQuery(&query);\n    query.waitForResponse();\n    if (!query.responseYes()) {\n        emit cancelled();\n        archive_read_close(m_archiveReader.data());\n        return false;\n    } else {\n        emit progress(1.0);\n        return true;\n    }\n}\n\nbool LibarchivePlugin::addFiles(const QVector<Archive::Entry*> &files, const Archive::Entry *destination, const CompressionOptions &options, uint numberOfEntriesToAdd)\n{\n    Q_UNUSED(files)\n    Q_UNUSED(destination)\n    Q_UNUSED(options)\n    Q_UNUSED(numberOfEntriesToAdd)\n    return false;\n}\n\nbool LibarchivePlugin::moveFiles(const QVector<Archive::Entry*> &files, Archive::Entry *destination, const CompressionOptions &options)\n{\n    Q_UNUSED(files)\n    Q_UNUSED(destination)\n    Q_UNUSED(options)\n    return false;\n}\n\nbool LibarchivePlugin::copyFiles(const QVector<Archive::Entry*> &files, Archive::Entry *destination, const CompressionOptions &options)\n{\n    Q_UNUSED(files)\n    Q_UNUSED(destination)\n    Q_UNUSED(options)\n    return false;\n}\n\nbool LibarchivePlugin::deleteFiles(const QVector<Archive::Entry*> &files)\n{\n    Q_UNUSED(files)\n    return false;\n}\n\nbool LibarchivePlugin::addComment(const QString &comment)\n{\n    Q_UNUSED(comment)\n    return false;\n}\n\nbool LibarchivePlugin::testArchive()\n{\n    return false;\n}\n\nbool LibarchivePlugin::hasBatchExtractionProgress() const\n{\n    return true;\n}\n\nbool LibarchivePlugin::doKill()\n{\n    return false;\n}\n\nbool LibarchivePlugin::extractFiles(const QVector<Archive::Entry*> &files, const QString &destinationDirectory, const ExtractionOptions &options)\n{\n    if (!initializeReader()) {\n        return false;\n    }\n\n    ArchiveWrite writer(archive_write_disk_new());\n    if (!writer.data()) {\n        return false;\n    }\n\n    archive_write_disk_set_options(writer.data(), extractionFlags());\n\n    int totalEntriesCount = 0;\n    const bool extractAll = files.isEmpty();\n    if (extractAll) {\n        if (!m_cachedArchiveEntryCount) {\n            emit progress(0);\n            //TODO: once information progress has been implemented, send\n            //feedback here that the archive is being read\n            qCDebug(ARK) << \"For getting progress information, the archive will be listed once\";\n            m_emitNoEntries = true;\n            list();\n            m_emitNoEntries = false;\n        }\n        totalEntriesCount = m_cachedArchiveEntryCount;\n    } else {\n        totalEntriesCount = files.size();\n    }\n\n    qCDebug(ARK) << \"Going to extract\" << totalEntriesCount << \"entries\";\n\n    qCDebug(ARK) << \"Changing current directory to \" << destinationDirectory;\n    m_oldWorkingDir = QDir::currentPath();\n    QDir::setCurrent(destinationDirectory);\n\n    // Initialize variables.\n    const bool preservePaths = options.preservePaths();\n    const bool removeRootNode = options.isDragAndDropEnabled();\n    bool overwriteAll = false; // Whether to overwrite all files\n    bool skipAll = false; // Whether to skip all files\n    bool dontPromptErrors = false; // Whether to prompt for errors\n    m_currentExtractedFilesSize = 0;\n    int extractedEntriesCount = 0;\n    int progressEntryCount = 0;\n    struct archive_entry *entry;\n    QString fileBeingRenamed;\n    // To avoid traversing the entire archive when extracting a limited set of\n    // entries, we maintain a list of remaining entries and stop when it's empty.\n    const QStringList fullPaths = entryFullPaths(files);\n    QStringList remainingFiles = entryFullPaths(files);\n\n    // Iterate through all entries in archive.\n    while (!QThread::currentThread()->isInterruptionRequested() && (archive_read_next_header(m_archiveReader.data(), &entry) == ARCHIVE_OK)) {\n\n        if (!extractAll && remainingFiles.isEmpty()) {\n            break;\n        }\n\n        fileBeingRenamed.clear();\n        int index = -1;\n\n        // Retry with renamed entry, fire an overwrite query again\n        // if the new entry also exists.\n    retry:\n        const bool entryIsDir = S_ISDIR(archive_entry_mode(entry));\n        // Skip directories if not preserving paths.\n        if (!preservePaths && entryIsDir) {\n            archive_read_data_skip(m_archiveReader.data());\n            continue;\n        }\n\n        // entryName is the name inside the archive, full path\n        QString entryName = QDir::fromNativeSeparators(QFile::decodeName(archive_entry_pathname(entry)));\n\n        // Some archive types e.g. AppImage prepend all entries with \"./\" so remove this part.\n        if (entryName.startsWith(QLatin1String(\"./\"))) {\n            entryName.remove(0, 2);\n        }\n\n        // Static libraries (*.a) contain the two entries \"/\" and \"//\".\n        // We just skip these to allow extracting this archive type.\n        if (entryName == QLatin1String(\"/\") || entryName == QLatin1String(\"//\")) {\n            archive_read_data_skip(m_archiveReader.data());\n            continue;\n        }\n\n        // For now we just can't handle absolute filenames in a tar archive.\n        // TODO: find out what to do here!!\n        if (entryName.startsWith(QLatin1Char( '/' ))) {\n            emit error(i18n(\"This archive contains archive entries with absolute paths, \"\n                            \"which are not supported by Ark.\"));\n            return false;\n        }\n\n        // Should the entry be extracted?\n        if (extractAll ||\n            remainingFiles.contains(entryName) ||\n            entryName == fileBeingRenamed) {\n\n            // Find the index of entry.\n            if (entryName != fileBeingRenamed) {\n                index = fullPaths.indexOf(entryName);\n            }\n            if (!extractAll && index == -1) {\n                // If entry is not found in files, skip entry.\n                continue;\n            }\n\n            // entryFI is the fileinfo pointing to where the file will be\n            // written from the archive.\n            QFileInfo entryFI(entryName);\n            //qCDebug(ARK) << \"setting path to \" << archive_entry_pathname( entry );\n\n            const QString fileWithoutPath(entryFI.fileName());\n            // If we DON'T preserve paths, we cut the path and set the entryFI\n            // fileinfo to the one without the path.\n            if (!preservePaths) {\n                // Empty filenames (ie dirs) should have been skipped already,\n                // so asserting.\n                Q_ASSERT(!fileWithoutPath.isEmpty());\n                archive_entry_copy_pathname(entry, QFile::encodeName(fileWithoutPath).constData());\n                entryFI = QFileInfo(fileWithoutPath);\n\n            // OR, if the file has a rootNode attached, remove it from file path.\n            } else if (!extractAll && removeRootNode && entryName != fileBeingRenamed) {\n                const QString &rootNode = files.at(index)->rootNode;\n                if (!rootNode.isEmpty()) {\n                    const QString truncatedFilename(entryName.remove(entryName.indexOf(rootNode), rootNode.size()));\n                    archive_entry_copy_pathname(entry, QFile::encodeName(truncatedFilename).constData());\n                    entryFI = QFileInfo(truncatedFilename);\n                }\n            }\n\n            // Check if the file about to be written already exists.\n            if (!entryIsDir && entryFI.exists()) {\n                if (skipAll) {\n                    archive_read_data_skip(m_archiveReader.data());\n                    archive_entry_clear(entry);\n                    continue;\n                } else if (!overwriteAll && !skipAll) {\n                    Kerfuffle::OverwriteQuery query(entryName);\n                    emit userQuery(&query);\n                    query.waitForResponse();\n\n                    if (query.responseCancelled()) {\n                        emit cancelled();\n                        archive_read_data_skip(m_archiveReader.data());\n                        archive_entry_clear(entry);\n                        break;\n                    } else if (query.responseSkip()) {\n                        archive_read_data_skip(m_archiveReader.data());\n                        archive_entry_clear(entry);\n                        continue;\n                    } else if (query.responseAutoSkip()) {\n                        archive_read_data_skip(m_archiveReader.data());\n                        archive_entry_clear(entry);\n                        skipAll = true;\n                        continue;\n                    } else if (query.responseRename()) {\n                        const QString newName(query.newFilename());\n                        fileBeingRenamed = newName;\n                        archive_entry_copy_pathname(entry, QFile::encodeName(newName).constData());\n                        goto retry;\n                    } else if (query.responseOverwriteAll()) {\n                        overwriteAll = true;\n                    }\n                }\n            }\n\n            // If there is an already existing directory.\n            if (entryIsDir && entryFI.exists()) {\n                if (entryFI.isWritable()) {\n                    qCWarning(ARK) << \"Warning, existing, but writable dir\";\n                } else {\n                    qCWarning(ARK) << \"Warning, existing, but non-writable dir. skipping\";\n                    archive_entry_clear(entry);\n                    archive_read_data_skip(m_archiveReader.data());\n                    continue;\n                }\n            }\n\n            // Write the entry header and check return value.\n            const int returnCode = archive_write_header(writer.data(), entry);\n            switch (returnCode) {\n            case ARCHIVE_OK:\n                // If the whole archive is extracted and the total filesize is\n                // available, we use partial progress.\n                copyData(entryName, m_archiveReader.data(), writer.data(), (extractAll && m_extractedFilesSize));\n                break;\n\n            case ARCHIVE_FAILED:\n                qCCritical(ARK) << \"archive_write_header() has returned\" << returnCode\n                                << \"with errno\" << archive_errno(writer.data());\n\n                // If they user previously decided to ignore future errors,\n                // don't bother prompting again.\n                if (!dontPromptErrors) {\n                    // Ask the user if he wants to continue extraction despite an error for this entry.\n                    Kerfuffle::ContinueExtractionQuery query(QLatin1String(archive_error_string(writer.data())),\n                                                             entryName);\n                    emit userQuery(&query);\n                    query.waitForResponse();\n\n                    if (query.responseCancelled()) {\n                        emit cancelled();\n                        return false;\n                    }\n                    dontPromptErrors = query.dontAskAgain();\n                }\n                break;\n\n            case ARCHIVE_FATAL:\n                qCCritical(ARK) << \"archive_write_header() has returned\" << returnCode\n                                << \"with errno\" << archive_errno(writer.data());\n                emit error(i18nc(\"@info\", \"Fatal error, extraction aborted.\"));\n                return false;\n            default:\n                qCDebug(ARK) << \"archive_write_header() returned\" << returnCode\n                             << \"which will be ignored.\";\n                break;\n            }\n\n            // If we only partially extract the archive and the number of\n            // archive entries is available we use a simple progress based on\n            // number of items extracted.\n            if (!extractAll && m_cachedArchiveEntryCount) {\n                ++progressEntryCount;\n                emit progress(float(progressEntryCount) / totalEntriesCount);\n            }\n\n            extractedEntriesCount++;\n            remainingFiles.removeOne(entryName);\n        } else {\n            // Archive entry not among selected files, skip it.\n            archive_read_data_skip(m_archiveReader.data());\n        }\n    }\n\n    qCDebug(ARK) << \"Extracted\" << extractedEntriesCount << \"entries\";\n    slotRestoreWorkingDir();\n    return archive_read_close(m_archiveReader.data()) == ARCHIVE_OK;\n}\n\nbool LibarchivePlugin::initializeReader()\n{\n    m_archiveReader.reset(archive_read_new());\n\n    if (!(m_archiveReader.data())) {\n        emit error(i18n(\"The archive reader could not be initialized.\"));\n        return false;\n    }\n\n    if (archive_read_support_filter_all(m_archiveReader.data()) != ARCHIVE_OK) {\n        return false;\n    }\n\n    if (archive_read_support_format_all(m_archiveReader.data()) != ARCHIVE_OK) {\n        return false;\n    }\n\n    if (archive_read_open_filename(m_archiveReader.data(), QFile::encodeName(filename()).constData(), 10240) != ARCHIVE_OK) {\n        qCWarning(ARK) << \"Could not open the archive:\" << archive_error_string(m_archiveReader.data());\n        emit error(i18nc(\"@info\", \"Archive corrupted or insufficient permissions.\"));\n        return false;\n    }\n\n    return true;\n}\n\nvoid LibarchivePlugin::emitEntryFromArchiveEntry(struct archive_entry *aentry)\n{\n    auto e = new Archive::Entry();\n\n#ifdef Q_OS_WIN\n    e->setProperty(\"fullPath\", QDir::fromNativeSeparators(QString::fromUtf16((ushort*)archive_entry_pathname_w(aentry))));\n#else\n    e->setProperty(\"fullPath\", QDir::fromNativeSeparators(QString::fromWCharArray(archive_entry_pathname_w(aentry))));\n#endif\n\n    const QString owner = QString::fromLatin1(archive_entry_uname(aentry));\n    if (!owner.isEmpty()) {\n        e->setProperty(\"owner\", owner);\n    } else {\n        e->setProperty(\"owner\", static_cast<qlonglong>(archive_entry_uid(aentry)));\n    }\n\n    const QString group = QString::fromLatin1(archive_entry_gname(aentry));\n    if (!group.isEmpty()) {\n        e->setProperty(\"group\", group);\n    } else {\n        e->setProperty(\"group\", static_cast<qlonglong>(archive_entry_gid(aentry)));\n    }\n\n    const mode_t mode = archive_entry_mode(aentry);\n    if (mode != 0) {\n        e->setProperty(\"permissions\", QString::number(mode, 8));\n    }\n    e->setProperty(\"isExecutable\", mode & (S_IXUSR | S_IXGRP | S_IXOTH));\n\n    e->compressedSizeIsSet = false;\n    e->setProperty(\"size\", (qlonglong)archive_entry_size(aentry));\n    e->setProperty(\"isDirectory\", S_ISDIR(archive_entry_mode(aentry)));\n\n    if (archive_entry_symlink(aentry)) {\n        e->setProperty(\"link\", QLatin1String( archive_entry_symlink(aentry) ));\n    }\n\n    auto time = static_cast<uint>(archive_entry_mtime(aentry));\n    e->setProperty(\"timestamp\", QDateTime::fromSecsSinceEpoch(time));\n\n    emit entry(e);\n    m_emittedEntries << e;\n}\n\nint LibarchivePlugin::extractionFlags() const\n{\n    return ARCHIVE_EXTRACT_TIME\n           | ARCHIVE_EXTRACT_SECURE_NODOTDOT\n           | ARCHIVE_EXTRACT_SECURE_SYMLINKS;\n}\n\nvoid LibarchivePlugin::copyData(const QString& filename, struct archive *dest, bool partialprogress)\n{\n    char buff[10240];\n    QFile file(filename);\n\n    if (!file.open(QIODevice::ReadOnly)) {\n        return;\n    }\n\n    auto readBytes = file.read(buff, sizeof(buff));\n    while (readBytes > 0 && !QThread::currentThread()->isInterruptionRequested()) {\n        archive_write_data(dest, buff, static_cast<size_t>(readBytes));\n        if (archive_errno(dest) != ARCHIVE_OK) {\n            qCCritical(ARK) << \"Error while writing\" << filename << \":\" << archive_error_string(dest)\n                            << \"(error no =\" << archive_errno(dest) << ')';\n            return;\n        }\n\n        if (partialprogress) {\n            m_currentExtractedFilesSize += readBytes;\n            emit progress(float(m_currentExtractedFilesSize) / m_extractedFilesSize);\n        }\n\n        readBytes = file.read(buff, sizeof(buff));\n    }\n\n    file.close();\n}\n\nvoid LibarchivePlugin::copyData(const QString& filename, struct archive *source, struct archive *dest, bool partialprogress)\n{\n    char buff[10240];\n\n    auto readBytes = archive_read_data(source, buff, sizeof(buff));\n    while (readBytes > 0 && !QThread::currentThread()->isInterruptionRequested()) {\n        archive_write_data(dest, buff, static_cast<size_t>(readBytes));\n        if (archive_errno(dest) != ARCHIVE_OK) {\n            qCCritical(ARK) << \"Error while extracting\" << filename << \":\" << archive_error_string(dest)\n                            << \"(error no =\" << archive_errno(dest) << ')';\n            return;\n        }\n\n        if (partialprogress) {\n            m_currentExtractedFilesSize += readBytes;\n            emit progress(float(m_currentExtractedFilesSize) / m_extractedFilesSize);\n        }\n\n        readBytes = archive_read_data(source, buff, sizeof(buff));\n    }\n}\n\nvoid LibarchivePlugin::slotRestoreWorkingDir()\n{\n    if (m_oldWorkingDir.isEmpty()) {\n        return;\n    }\n\n    if (!QDir::setCurrent(m_oldWorkingDir)) {\n        qCWarning(ARK) << \"Failed to restore old working directory:\" << m_oldWorkingDir;\n    } else {\n        m_oldWorkingDir.clear();\n    }\n}\n\nQString LibarchivePlugin::convertCompressionName(const QString &method)\n{\n    if (method == QLatin1String(\"gzip\")) {\n        return QStringLiteral(\"GZip\");\n    } else if (method == QLatin1String(\"bzip2\")) {\n        return QStringLiteral(\"BZip2\");\n    } else if (method == QLatin1String(\"xz\")) {\n        return QStringLiteral(\"XZ\");\n    } else if (method == QLatin1String(\"compress (.Z)\")) {\n        return QStringLiteral(\"Compress\");\n    } else if (method == QLatin1String(\"lrzip\")) {\n        return QStringLiteral(\"LRZip\");\n    } else if (method == QLatin1String(\"lzip\")) {\n        return QStringLiteral(\"LZip\");\n    } else if (method == QLatin1String(\"lz4\")) {\n        return QStringLiteral(\"LZ4\");\n    } else if (method == QLatin1String(\"lzop\")) {\n        return QStringLiteral(\"lzop\");\n    } else if (method == QLatin1String(\"lzma\")) {\n        return QStringLiteral(\"LZMA\");\n    } else if (method == QLatin1String(\"zstd\")) {\n        return QStringLiteral(\"Zstandard\");\n    }\n    return QString();\n}\n\n"], "filenames": ["plugins/libarchive/libarchiveplugin.cpp"], "buggy_code_start_loc": [512], "buggy_code_end_loc": [527], "fixing_code_start_loc": [512], "fixing_code_end_loc": [515], "type": "CWE-59", "message": "In KDE Ark before 20.08.1, a crafted TAR archive with symlinks can install files outside the extraction directory, as demonstrated by a write operation to a user's home directory.", "other": {"cve": {"id": "CVE-2020-24654", "sourceIdentifier": "cve@mitre.org", "published": "2020-09-02T17:15:12.327", "lastModified": "2022-09-12T03:54:36.657", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In KDE Ark before 20.08.1, a crafted TAR archive with symlinks can install files outside the extraction directory, as demonstrated by a write operation to a user's home directory."}, {"lang": "es", "value": "En KDE Ark versiones anteriores a 20.08.1, un archivo TAR dise\u00f1ado con enlaces simb\u00f3licos puede instalar archivos fuera del directorio de extracci\u00f3n, como es demostrado mediante una operaci\u00f3n de escritura en el directorio de inicio del usuario"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:L/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 3.3, "baseSeverity": "LOW"}, "exploitabilityScore": 1.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-59"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:kde:ark:*:*:*:*:*:*:*:*", "versionEndExcluding": "20.08.1", "matchCriteriaId": "785B922D-7B29-4839-9E69-208ABD25BB69"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:20.04:*:*:*:lts:*:*:*", "matchCriteriaId": "902B8056-9E37-443B-8905-8AA93E2447FB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:32:*:*:*:*:*:*:*", "matchCriteriaId": "36D96259-24BD-44E2-96D9-78CE1D41F956"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.2:*:*:*:*:*:*:*", "matchCriteriaId": "B009C22E-30A4-4288-BCF6-C3E81DEAF45A"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:33:*:*:*:*:*:*:*", "matchCriteriaId": "E460AA51-FCDA-46B9-AE97-E6676AA5E194"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-09/msg00001.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://bugzilla.suse.com/show_bug.cgi?id=1175857", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/KDE/ark/commit/8bf8c5ef07b0ac5e914d752681e470dea403a5bd", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://kde.org/info/security/advisory-20200827-1.txt", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/05/msg00026.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/LXMMXNJDYOCJRZTESIUGHG6CS4RJKECX/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/YJOZ6YRNPZX5MJGVBMOCOA7N6Z4EU2OK/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202010-06", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202101-06", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4482-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2020/dsa-4759", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/KDE/ark/commit/8bf8c5ef07b0ac5e914d752681e470dea403a5bd"}}