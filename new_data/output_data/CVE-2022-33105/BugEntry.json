{"buggy_code": ["/*\n * Copyright (c) 2017, Salvatore Sanfilippo <antirez at gmail dot com>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"server.h\"\n#include \"endianconv.h\"\n#include \"stream.h\"\n\n/* Every stream item inside the listpack, has a flags field that is used to\n * mark the entry as deleted, or having the same field as the \"master\"\n * entry at the start of the listpack> */\n#define STREAM_ITEM_FLAG_NONE 0             /* No special flags. */\n#define STREAM_ITEM_FLAG_DELETED (1<<0)     /* Entry is deleted. Skip it. */\n#define STREAM_ITEM_FLAG_SAMEFIELDS (1<<1)  /* Same fields as master entry. */\n\n/* For stream commands that require multiple IDs\n * when the number of IDs is less than 'STREAMID_STATIC_VECTOR_LEN',\n * avoid malloc allocation.*/\n#define STREAMID_STATIC_VECTOR_LEN 8\n\n/* Max pre-allocation for listpack. This is done to avoid abuse of a user\n * setting stream_node_max_bytes to a huge number. */\n#define STREAM_LISTPACK_MAX_PRE_ALLOCATE 4096\n\n/* Don't let listpacks grow too big, even if the user config allows it.\n * doing so can lead to an overflow (trying to store more than 32bit length\n * into the listpack header), or actually an assertion since lpInsert\n * will return NULL. */\n#define STREAM_LISTPACK_MAX_SIZE (1<<30)\n\nvoid streamFreeCG(streamCG *cg);\nvoid streamFreeNACK(streamNACK *na);\nsize_t streamReplyWithRangeFromConsumerPEL(client *c, stream *s, streamID *start, streamID *end, size_t count, streamConsumer *consumer);\nint streamParseStrictIDOrReply(client *c, robj *o, streamID *id, uint64_t missing_seq, int *seq_given);\nint streamParseIDOrReply(client *c, robj *o, streamID *id, uint64_t missing_seq);\n\n/* -----------------------------------------------------------------------\n * Low level stream encoding: a radix tree of listpacks.\n * ----------------------------------------------------------------------- */\n\n/* Create a new stream data structure. */\nstream *streamNew(void) {\n    stream *s = zmalloc(sizeof(*s));\n    s->rax = raxNew();\n    s->length = 0;\n    s->first_id.ms = 0;\n    s->first_id.seq = 0;\n    s->last_id.ms = 0;\n    s->last_id.seq = 0;\n    s->max_deleted_entry_id.seq = 0;\n    s->max_deleted_entry_id.ms = 0;\n    s->entries_added = 0;\n    s->cgroups = NULL; /* Created on demand to save memory when not used. */\n    return s;\n}\n\n/* Free a stream, including the listpacks stored inside the radix tree. */\nvoid freeStream(stream *s) {\n    raxFreeWithCallback(s->rax,(void(*)(void*))lpFree);\n    if (s->cgroups)\n        raxFreeWithCallback(s->cgroups,(void(*)(void*))streamFreeCG);\n    zfree(s);\n}\n\n/* Return the length of a stream. */\nunsigned long streamLength(const robj *subject) {\n    stream *s = subject->ptr;\n    return s->length;\n}\n\n/* Set 'id' to be its successor stream ID.\n * If 'id' is the maximal possible id, it is wrapped around to 0-0 and a\n * C_ERR is returned. */\nint streamIncrID(streamID *id) {\n    int ret = C_OK;\n    if (id->seq == UINT64_MAX) {\n        if (id->ms == UINT64_MAX) {\n            /* Special case where 'id' is the last possible streamID... */\n            id->ms = id->seq = 0;\n            ret = C_ERR;\n        } else {\n            id->ms++;\n            id->seq = 0;\n        }\n    } else {\n        id->seq++;\n    }\n    return ret;\n}\n\n/* Set 'id' to be its predecessor stream ID.\n * If 'id' is the minimal possible id, it remains 0-0 and a C_ERR is\n * returned. */\nint streamDecrID(streamID *id) {\n    int ret = C_OK;\n    if (id->seq == 0) {\n        if (id->ms == 0) {\n            /* Special case where 'id' is the first possible streamID... */\n            id->ms = id->seq = UINT64_MAX;\n            ret = C_ERR;\n        } else {\n            id->ms--;\n            id->seq = UINT64_MAX;\n        }\n    } else {\n        id->seq--;\n    }\n    return ret;\n}\n\n/* Generate the next stream item ID given the previous one. If the current\n * milliseconds Unix time is greater than the previous one, just use this\n * as time part and start with sequence part of zero. Otherwise we use the\n * previous time (and never go backward) and increment the sequence. */\nvoid streamNextID(streamID *last_id, streamID *new_id) {\n    uint64_t ms = mstime();\n    if (ms > last_id->ms) {\n        new_id->ms = ms;\n        new_id->seq = 0;\n    } else {\n        *new_id = *last_id;\n        streamIncrID(new_id);\n    }\n}\n\n/* This is a helper function for the COPY command.\n * Duplicate a Stream object, with the guarantee that the returned object\n * has the same encoding as the original one.\n *\n * The resulting object always has refcount set to 1 */\nrobj *streamDup(robj *o) {\n    robj *sobj;\n\n    serverAssert(o->type == OBJ_STREAM);\n\n    switch (o->encoding) {\n        case OBJ_ENCODING_STREAM:\n            sobj = createStreamObject();\n            break;\n        default:\n            serverPanic(\"Wrong encoding.\");\n            break;\n    }\n\n    stream *s;\n    stream *new_s;\n    s = o->ptr;\n    new_s = sobj->ptr;\n\n    raxIterator ri;\n    uint64_t rax_key[2];\n    raxStart(&ri, s->rax);\n    raxSeek(&ri, \"^\", NULL, 0);\n    size_t lp_bytes = 0;      /* Total bytes in the listpack. */\n    unsigned char *lp = NULL; /* listpack pointer. */\n    /* Get a reference to the listpack node. */\n    while (raxNext(&ri)) {\n        lp = ri.data;\n        lp_bytes = lpBytes(lp);\n        unsigned char *new_lp = zmalloc(lp_bytes);\n        memcpy(new_lp, lp, lp_bytes);\n        memcpy(rax_key, ri.key, sizeof(rax_key));\n        raxInsert(new_s->rax, (unsigned char *)&rax_key, sizeof(rax_key),\n                  new_lp, NULL);\n    }\n    new_s->length = s->length;\n    new_s->first_id = s->first_id;\n    new_s->last_id = s->last_id;\n    new_s->max_deleted_entry_id = s->max_deleted_entry_id;\n    new_s->entries_added = s->entries_added;\n    raxStop(&ri);\n\n    if (s->cgroups == NULL) return sobj;\n\n    /* Consumer Groups */\n    raxIterator ri_cgroups;\n    raxStart(&ri_cgroups, s->cgroups);\n    raxSeek(&ri_cgroups, \"^\", NULL, 0);\n    while (raxNext(&ri_cgroups)) {\n        streamCG *cg = ri_cgroups.data;\n        streamCG *new_cg = streamCreateCG(new_s, (char *)ri_cgroups.key,\n                                          ri_cgroups.key_len, &cg->last_id,\n                                          cg->entries_read);\n\n        serverAssert(new_cg != NULL);\n\n        /* Consumer Group PEL */\n        raxIterator ri_cg_pel;\n        raxStart(&ri_cg_pel,cg->pel);\n        raxSeek(&ri_cg_pel,\"^\",NULL,0);\n        while(raxNext(&ri_cg_pel)){\n            streamNACK *nack = ri_cg_pel.data;\n            streamNACK *new_nack = streamCreateNACK(NULL);\n            new_nack->delivery_time = nack->delivery_time;\n            new_nack->delivery_count = nack->delivery_count;\n            raxInsert(new_cg->pel, ri_cg_pel.key, sizeof(streamID), new_nack, NULL);\n        }\n        raxStop(&ri_cg_pel);\n\n        /* Consumers */\n        raxIterator ri_consumers;\n        raxStart(&ri_consumers, cg->consumers);\n        raxSeek(&ri_consumers, \"^\", NULL, 0);\n        while (raxNext(&ri_consumers)) {\n            streamConsumer *consumer = ri_consumers.data;\n            streamConsumer *new_consumer;\n            new_consumer = zmalloc(sizeof(*new_consumer));\n            new_consumer->name = sdsdup(consumer->name);\n            new_consumer->pel = raxNew();\n            raxInsert(new_cg->consumers,(unsigned char *)new_consumer->name,\n                        sdslen(new_consumer->name), new_consumer, NULL);\n            new_consumer->seen_time = consumer->seen_time;\n\n            /* Consumer PEL */\n            raxIterator ri_cpel;\n            raxStart(&ri_cpel, consumer->pel);\n            raxSeek(&ri_cpel, \"^\", NULL, 0);\n            while (raxNext(&ri_cpel)) {\n                streamNACK *new_nack = raxFind(new_cg->pel,ri_cpel.key,sizeof(streamID));\n\n                serverAssert(new_nack != raxNotFound);\n\n                new_nack->consumer = new_consumer;\n                raxInsert(new_consumer->pel,ri_cpel.key,sizeof(streamID),new_nack,NULL);\n            }\n            raxStop(&ri_cpel);\n        }\n        raxStop(&ri_consumers);\n    }\n    raxStop(&ri_cgroups);\n    return sobj;\n}\n\n/* This is a wrapper function for lpGet() to directly get an integer value\n * from the listpack (that may store numbers as a string), converting\n * the string if needed.\n * The 'valid\" argument is an optional output parameter to get an indication\n * if the record was valid, when this parameter is NULL, the function will\n * fail with an assertion. */\nstatic inline int64_t lpGetIntegerIfValid(unsigned char *ele, int *valid) {\n    int64_t v;\n    unsigned char *e = lpGet(ele,&v,NULL);\n    if (e == NULL) {\n        if (valid)\n            *valid = 1;\n        return v;\n    }\n    /* The following code path should never be used for how listpacks work:\n     * they should always be able to store an int64_t value in integer\n     * encoded form. However the implementation may change. */\n    long long ll;\n    int ret = string2ll((char*)e,v,&ll);\n    if (valid)\n        *valid = ret;\n    else\n        serverAssert(ret != 0);\n    v = ll;\n    return v;\n}\n\n#define lpGetInteger(ele) lpGetIntegerIfValid(ele, NULL)\n\n/* Get an edge streamID of a given listpack.\n * 'master_id' is an input param, used to build the 'edge_id' output param */\nint lpGetEdgeStreamID(unsigned char *lp, int first, streamID *master_id, streamID *edge_id)\n{\n   if (lp == NULL)\n       return 0;\n\n   unsigned char *lp_ele;\n\n   /* We need to seek either the first or the last entry depending\n    * on the direction of the iteration. */\n   if (first) {\n       /* Get the master fields count. */\n       lp_ele = lpFirst(lp);        /* Seek items count */\n       lp_ele = lpNext(lp, lp_ele); /* Seek deleted count. */\n       lp_ele = lpNext(lp, lp_ele); /* Seek num fields. */\n       int64_t master_fields_count = lpGetInteger(lp_ele);\n       lp_ele = lpNext(lp, lp_ele); /* Seek first field. */\n\n       /* If we are iterating in normal order, skip the master fields\n        * to seek the first actual entry. */\n       for (int64_t i = 0; i < master_fields_count; i++)\n           lp_ele = lpNext(lp, lp_ele);\n\n       /* If we are going forward, skip the previous entry's\n        * lp-count field (or in case of the master entry, the zero\n        * term field) */\n       lp_ele = lpNext(lp, lp_ele);\n       if (lp_ele == NULL)\n           return 0;\n   } else {\n       /* If we are iterating in reverse direction, just seek the\n        * last part of the last entry in the listpack (that is, the\n        * fields count). */\n       lp_ele = lpLast(lp);\n\n       /* If we are going backward, read the number of elements this\n        * entry is composed of, and jump backward N times to seek\n        * its start. */\n       int64_t lp_count = lpGetInteger(lp_ele);\n       if (lp_count == 0) /* We reached the master entry. */\n           return 0;\n\n       while (lp_count--)\n           lp_ele = lpPrev(lp, lp_ele);\n   }\n\n   lp_ele = lpNext(lp, lp_ele); /* Seek ID (lp_ele currently points to 'flags'). */\n\n   /* Get the ID: it is encoded as difference between the master\n    * ID and this entry ID. */\n   streamID id = *master_id;\n   id.ms += lpGetInteger(lp_ele);\n   lp_ele = lpNext(lp, lp_ele);\n   id.seq += lpGetInteger(lp_ele);\n   *edge_id = id;\n   return 1;\n}\n\n/* Debugging function to log the full content of a listpack. Useful\n * for development and debugging. */\nvoid streamLogListpackContent(unsigned char *lp) {\n    unsigned char *p = lpFirst(lp);\n    while(p) {\n        unsigned char buf[LP_INTBUF_SIZE];\n        int64_t v;\n        unsigned char *ele = lpGet(p,&v,buf);\n        serverLog(LL_WARNING,\"- [%d] '%.*s'\", (int)v, (int)v, ele);\n        p = lpNext(lp,p);\n    }\n}\n\n/* Convert the specified stream entry ID as a 128 bit big endian number, so\n * that the IDs can be sorted lexicographically. */\nvoid streamEncodeID(void *buf, streamID *id) {\n    uint64_t e[2];\n    e[0] = htonu64(id->ms);\n    e[1] = htonu64(id->seq);\n    memcpy(buf,e,sizeof(e));\n}\n\n/* This is the reverse of streamEncodeID(): the decoded ID will be stored\n * in the 'id' structure passed by reference. The buffer 'buf' must point\n * to a 128 bit big-endian encoded ID. */\nvoid streamDecodeID(void *buf, streamID *id) {\n    uint64_t e[2];\n    memcpy(e,buf,sizeof(e));\n    id->ms = ntohu64(e[0]);\n    id->seq = ntohu64(e[1]);\n}\n\n/* Compare two stream IDs. Return -1 if a < b, 0 if a == b, 1 if a > b. */\nint streamCompareID(streamID *a, streamID *b) {\n    if (a->ms > b->ms) return 1;\n    else if (a->ms < b->ms) return -1;\n    /* The ms part is the same. Check the sequence part. */\n    else if (a->seq > b->seq) return 1;\n    else if (a->seq < b->seq) return -1;\n    /* Everything is the same: IDs are equal. */\n    return 0;\n}\n\n/* Retrieves the ID of the stream edge entry. An edge is either the first or\n * the last ID in the stream, and may be a tombstone. To filter out tombstones,\n * set the'skip_tombstones' argument to 1. */\nvoid streamGetEdgeID(stream *s, int first, int skip_tombstones, streamID *edge_id)\n{\n    streamIterator si;\n    int64_t numfields;\n    streamIteratorStart(&si,s,NULL,NULL,!first);\n    si.skip_tombstones = skip_tombstones;\n    int found = streamIteratorGetID(&si,edge_id,&numfields);\n    if (!found) {\n        streamID min_id = {0, 0}, max_id = {UINT64_MAX, UINT64_MAX};\n        *edge_id = first ? max_id : min_id;\n    }\n\n}\n\n/* Adds a new item into the stream 's' having the specified number of\n * field-value pairs as specified in 'numfields' and stored into 'argv'.\n * Returns the new entry ID populating the 'added_id' structure.\n *\n * If 'use_id' is not NULL, the ID is not auto-generated by the function,\n * but instead the passed ID is used to add the new entry. In this case\n * adding the entry may fail as specified later in this comment.\n * \n * When 'use_id' is used alongside with a zero 'seq-given', the sequence\n * part of the passed ID is ignored and the function will attempt to use an\n * auto-generated sequence.\n *\n * The function returns C_OK if the item was added, this is always true\n * if the ID was generated by the function. However the function may return\n * C_ERR in several cases:\n * 1. If an ID was given via 'use_id', but adding it failed since the\n *    current top ID is greater or equal. errno will be set to EDOM.\n * 2. If a size of a single element or the sum of the elements is too big to\n *    be stored into the stream. errno will be set to ERANGE. */\nint streamAppendItem(stream *s, robj **argv, int64_t numfields, streamID *added_id, streamID *use_id, int seq_given) {\n\n    /* Generate the new entry ID. */\n    streamID id;\n    if (use_id) {\n        if (seq_given) {\n            id = *use_id;\n        } else {\n            /* The automatically generated sequence can be either zero (new\n             * timestamps) or the incremented sequence of the last ID. In the\n             * latter case, we need to prevent an overflow/advancing forward\n             * in time. */\n            if (s->last_id.ms == use_id->ms) {\n                if (s->last_id.seq == UINT64_MAX) {\n                    return C_ERR;\n                }\n                id = s->last_id;\n                id.seq++;\n            } else {\n                id = *use_id;\n            }\n        }\n    } else {\n        streamNextID(&s->last_id,&id);\n    }\n\n    /* Check that the new ID is greater than the last entry ID\n     * or return an error. Automatically generated IDs might\n     * overflow (and wrap-around) when incrementing the sequence\n       part. */\n    if (streamCompareID(&id,&s->last_id) <= 0) {\n        errno = EDOM;\n        return C_ERR;\n    }\n\n    /* Avoid overflow when trying to add an element to the stream (listpack\n     * can only host up to 32bit length sttrings, and also a total listpack size\n     * can't be bigger than 32bit length. */\n    size_t totelelen = 0;\n    for (int64_t i = 0; i < numfields*2; i++) {\n        sds ele = argv[i]->ptr;\n        totelelen += sdslen(ele);\n    }\n    if (totelelen > STREAM_LISTPACK_MAX_SIZE) {\n        errno = ERANGE;\n        return C_ERR;\n    }\n\n    /* Add the new entry. */\n    raxIterator ri;\n    raxStart(&ri,s->rax);\n    raxSeek(&ri,\"$\",NULL,0);\n\n    size_t lp_bytes = 0;        /* Total bytes in the tail listpack. */\n    unsigned char *lp = NULL;   /* Tail listpack pointer. */\n\n    if (!raxEOF(&ri)) {\n        /* Get a reference to the tail node listpack. */\n        lp = ri.data;\n        lp_bytes = lpBytes(lp);\n    }\n    raxStop(&ri);\n\n    /* We have to add the key into the radix tree in lexicographic order,\n     * to do so we consider the ID as a single 128 bit number written in\n     * big endian, so that the most significant bytes are the first ones. */\n    uint64_t rax_key[2];    /* Key in the radix tree containing the listpack.*/\n    streamID master_id;     /* ID of the master entry in the listpack. */\n\n    /* Create a new listpack and radix tree node if needed. Note that when\n     * a new listpack is created, we populate it with a \"master entry\". This\n     * is just a set of fields that is taken as references in order to compress\n     * the stream entries that we'll add inside the listpack.\n     *\n     * Note that while we use the first added entry fields to create\n     * the master entry, the first added entry is NOT represented in the master\n     * entry, which is a stand alone object. But of course, the first entry\n     * will compress well because it's used as reference.\n     *\n     * The master entry is composed like in the following example:\n     *\n     * +-------+---------+------------+---------+--/--+---------+---------+-+\n     * | count | deleted | num-fields | field_1 | field_2 | ... | field_N |0|\n     * +-------+---------+------------+---------+--/--+---------+---------+-+\n     *\n     * count and deleted just represent respectively the total number of\n     * entries inside the listpack that are valid, and marked as deleted\n     * (deleted flag in the entry flags set). So the total number of items\n     * actually inside the listpack (both deleted and not) is count+deleted.\n     *\n     * The real entries will be encoded with an ID that is just the\n     * millisecond and sequence difference compared to the key stored at\n     * the radix tree node containing the listpack (delta encoding), and\n     * if the fields of the entry are the same as the master entry fields, the\n     * entry flags will specify this fact and the entry fields and number\n     * of fields will be omitted (see later in the code of this function).\n     *\n     * The \"0\" entry at the end is the same as the 'lp-count' entry in the\n     * regular stream entries (see below), and marks the fact that there are\n     * no more entries, when we scan the stream from right to left. */\n\n    /* First of all, check if we can append to the current macro node or\n     * if we need to switch to the next one. 'lp' will be set to NULL if\n     * the current node is full. */\n    if (lp != NULL) {\n        size_t node_max_bytes = server.stream_node_max_bytes;\n        if (node_max_bytes == 0 || node_max_bytes > STREAM_LISTPACK_MAX_SIZE)\n            node_max_bytes = STREAM_LISTPACK_MAX_SIZE;\n        if (lp_bytes + totelelen >= node_max_bytes) {\n            lp = NULL;\n        } else if (server.stream_node_max_entries) {\n            unsigned char *lp_ele = lpFirst(lp);\n            /* Count both live entries and deleted ones. */\n            int64_t count = lpGetInteger(lp_ele) + lpGetInteger(lpNext(lp,lp_ele));\n            if (count >= server.stream_node_max_entries) {\n                /* Shrink extra pre-allocated memory */\n                lp = lpShrinkToFit(lp);\n                if (ri.data != lp)\n                    raxInsert(s->rax,ri.key,ri.key_len,lp,NULL);\n                lp = NULL;\n            }\n        }\n    }\n\n    int flags = STREAM_ITEM_FLAG_NONE;\n    if (lp == NULL) {\n        master_id = id;\n        streamEncodeID(rax_key,&id);\n        /* Create the listpack having the master entry ID and fields.\n         * Pre-allocate some bytes when creating listpack to avoid realloc on\n         * every XADD. Since listpack.c uses malloc_size, it'll grow in steps,\n         * and won't realloc on every XADD.\n         * When listpack reaches max number of entries, we'll shrink the\n         * allocation to fit the data. */\n        size_t prealloc = STREAM_LISTPACK_MAX_PRE_ALLOCATE;\n        if (server.stream_node_max_bytes > 0 && server.stream_node_max_bytes < prealloc) {\n            prealloc = server.stream_node_max_bytes;\n        }\n        lp = lpNew(prealloc);\n        lp = lpAppendInteger(lp,1); /* One item, the one we are adding. */\n        lp = lpAppendInteger(lp,0); /* Zero deleted so far. */\n        lp = lpAppendInteger(lp,numfields);\n        for (int64_t i = 0; i < numfields; i++) {\n            sds field = argv[i*2]->ptr;\n            lp = lpAppend(lp,(unsigned char*)field,sdslen(field));\n        }\n        lp = lpAppendInteger(lp,0); /* Master entry zero terminator. */\n        raxInsert(s->rax,(unsigned char*)&rax_key,sizeof(rax_key),lp,NULL);\n        /* The first entry we insert, has obviously the same fields of the\n         * master entry. */\n        flags |= STREAM_ITEM_FLAG_SAMEFIELDS;\n    } else {\n        serverAssert(ri.key_len == sizeof(rax_key));\n        memcpy(rax_key,ri.key,sizeof(rax_key));\n\n        /* Read the master ID from the radix tree key. */\n        streamDecodeID(rax_key,&master_id);\n        unsigned char *lp_ele = lpFirst(lp);\n\n        /* Update count and skip the deleted fields. */\n        int64_t count = lpGetInteger(lp_ele);\n        lp = lpReplaceInteger(lp,&lp_ele,count+1);\n        lp_ele = lpNext(lp,lp_ele); /* seek deleted. */\n        lp_ele = lpNext(lp,lp_ele); /* seek master entry num fields. */\n\n        /* Check if the entry we are adding, have the same fields\n         * as the master entry. */\n        int64_t master_fields_count = lpGetInteger(lp_ele);\n        lp_ele = lpNext(lp,lp_ele);\n        if (numfields == master_fields_count) {\n            int64_t i;\n            for (i = 0; i < master_fields_count; i++) {\n                sds field = argv[i*2]->ptr;\n                int64_t e_len;\n                unsigned char buf[LP_INTBUF_SIZE];\n                unsigned char *e = lpGet(lp_ele,&e_len,buf);\n                /* Stop if there is a mismatch. */\n                if (sdslen(field) != (size_t)e_len ||\n                    memcmp(e,field,e_len) != 0) break;\n                lp_ele = lpNext(lp,lp_ele);\n            }\n            /* All fields are the same! We can compress the field names\n             * setting a single bit in the flags. */\n            if (i == master_fields_count) flags |= STREAM_ITEM_FLAG_SAMEFIELDS;\n        }\n    }\n\n    /* Populate the listpack with the new entry. We use the following\n     * encoding:\n     *\n     * +-----+--------+----------+-------+-------+-/-+-------+-------+--------+\n     * |flags|entry-id|num-fields|field-1|value-1|...|field-N|value-N|lp-count|\n     * +-----+--------+----------+-------+-------+-/-+-------+-------+--------+\n     *\n     * However if the SAMEFIELD flag is set, we have just to populate\n     * the entry with the values, so it becomes:\n     *\n     * +-----+--------+-------+-/-+-------+--------+\n     * |flags|entry-id|value-1|...|value-N|lp-count|\n     * +-----+--------+-------+-/-+-------+--------+\n     *\n     * The entry-id field is actually two separated fields: the ms\n     * and seq difference compared to the master entry.\n     *\n     * The lp-count field is a number that states the number of listpack pieces\n     * that compose the entry, so that it's possible to travel the entry\n     * in reverse order: we can just start from the end of the listpack, read\n     * the entry, and jump back N times to seek the \"flags\" field to read\n     * the stream full entry. */\n    lp = lpAppendInteger(lp,flags);\n    lp = lpAppendInteger(lp,id.ms - master_id.ms);\n    lp = lpAppendInteger(lp,id.seq - master_id.seq);\n    if (!(flags & STREAM_ITEM_FLAG_SAMEFIELDS))\n        lp = lpAppendInteger(lp,numfields);\n    for (int64_t i = 0; i < numfields; i++) {\n        sds field = argv[i*2]->ptr, value = argv[i*2+1]->ptr;\n        if (!(flags & STREAM_ITEM_FLAG_SAMEFIELDS))\n            lp = lpAppend(lp,(unsigned char*)field,sdslen(field));\n        lp = lpAppend(lp,(unsigned char*)value,sdslen(value));\n    }\n    /* Compute and store the lp-count field. */\n    int64_t lp_count = numfields;\n    lp_count += 3; /* Add the 3 fixed fields flags + ms-diff + seq-diff. */\n    if (!(flags & STREAM_ITEM_FLAG_SAMEFIELDS)) {\n        /* If the item is not compressed, it also has the fields other than\n         * the values, and an additional num-fields field. */\n        lp_count += numfields+1;\n    }\n    lp = lpAppendInteger(lp,lp_count);\n\n    /* Insert back into the tree in order to update the listpack pointer. */\n    if (ri.data != lp)\n        raxInsert(s->rax,(unsigned char*)&rax_key,sizeof(rax_key),lp,NULL);\n    s->length++;\n    s->entries_added++;\n    s->last_id = id;\n    if (s->length == 1) s->first_id = id;\n    if (added_id) *added_id = id;\n    return C_OK;\n}\n\ntypedef struct {\n    /* XADD options */\n    streamID id; /* User-provided ID, for XADD only. */\n    int id_given; /* Was an ID different than \"*\" specified? for XADD only. */\n    int seq_given; /* Was an ID different than \"ms-*\" specified? for XADD only. */\n    int no_mkstream; /* if set to 1 do not create new stream */\n\n    /* XADD + XTRIM common options */\n    int trim_strategy; /* TRIM_STRATEGY_* */\n    int trim_strategy_arg_idx; /* Index of the count in MAXLEN/MINID, for rewriting. */\n    int approx_trim; /* If 1 only delete whole radix tree nodes, so\n                      * the trim argument is not applied verbatim. */\n    long long limit; /* Maximum amount of entries to trim. If 0, no limitation\n                      * on the amount of trimming work is enforced. */\n    /* TRIM_STRATEGY_MAXLEN options */\n    long long maxlen; /* After trimming, leave stream at this length . */\n    /* TRIM_STRATEGY_MINID options */\n    streamID minid; /* Trim by ID (No stream entries with ID < 'minid' will remain) */\n} streamAddTrimArgs;\n\n#define TRIM_STRATEGY_NONE 0\n#define TRIM_STRATEGY_MAXLEN 1\n#define TRIM_STRATEGY_MINID 2\n\n/* Trim the stream 's' according to args->trim_strategy, and return the\n * number of elements removed from the stream. The 'approx' option, if non-zero,\n * specifies that the trimming must be performed in a approximated way in\n * order to maximize performances. This means that the stream may contain\n * entries with IDs < 'id' in case of MINID (or more elements than 'maxlen'\n * in case of MAXLEN), and elements are only removed if we can remove\n * a *whole* node of the radix tree. The elements are removed from the head\n * of the stream (older elements).\n *\n * The function may return zero if:\n *\n * 1) The minimal entry ID of the stream is already < 'id' (MINID); or\n * 2) The stream is already shorter or equal to the specified max length (MAXLEN); or\n * 3) The 'approx' option is true and the head node did not have enough elements\n *    to be deleted.\n *\n * args->limit is the maximum number of entries to delete. The purpose is to\n * prevent this function from taking to long.\n * If 'limit' is 0 then we do not limit the number of deleted entries.\n * Much like the 'approx', if 'limit' is smaller than the number of entries\n * that should be trimmed, there is a chance we will still have entries with\n * IDs < 'id' (or number of elements >= maxlen in case of MAXLEN).\n */\nint64_t streamTrim(stream *s, streamAddTrimArgs *args) {\n    size_t maxlen = args->maxlen;\n    streamID *id = &args->minid;\n    int approx = args->approx_trim;\n    int64_t limit = args->limit;\n    int trim_strategy = args->trim_strategy;\n\n    if (trim_strategy == TRIM_STRATEGY_NONE)\n        return 0;\n\n    raxIterator ri;\n    raxStart(&ri,s->rax);\n    raxSeek(&ri,\"^\",NULL,0);\n\n    int64_t deleted = 0;\n    while (raxNext(&ri)) {\n        if (trim_strategy == TRIM_STRATEGY_MAXLEN && s->length <= maxlen)\n            break;\n\n        unsigned char *lp = ri.data, *p = lpFirst(lp);\n        int64_t entries = lpGetInteger(p);\n\n        /* Check if we exceeded the amount of work we could do */\n        if (limit && (deleted + entries) > limit)\n            break;\n\n        /* Check if we can remove the whole node. */\n        int remove_node;\n        streamID master_id = {0}; /* For MINID */\n        if (trim_strategy == TRIM_STRATEGY_MAXLEN) {\n            remove_node = s->length - entries >= maxlen;\n        } else {\n            /* Read the master ID from the radix tree key. */\n            streamDecodeID(ri.key, &master_id);\n\n            /* Read last ID. */\n            streamID last_id;\n            lpGetEdgeStreamID(lp, 0, &master_id, &last_id);\n\n            /* We can remove the entire node id its last ID < 'id' */\n            remove_node = streamCompareID(&last_id, id) < 0;\n        }\n\n        if (remove_node) {\n            lpFree(lp);\n            raxRemove(s->rax,ri.key,ri.key_len,NULL);\n            raxSeek(&ri,\">=\",ri.key,ri.key_len);\n            s->length -= entries;\n            deleted += entries;\n            continue;\n        }\n\n        /* If we cannot remove a whole element, and approx is true,\n         * stop here. */\n        if (approx) break;\n\n        /* Now we have to trim entries from within 'lp' */\n        int64_t deleted_from_lp = 0;\n\n        p = lpNext(lp, p); /* Skip deleted field. */\n        p = lpNext(lp, p); /* Skip num-of-fields in the master entry. */\n\n        /* Skip all the master fields. */\n        int64_t master_fields_count = lpGetInteger(p);\n        p = lpNext(lp,p); /* Skip the first field. */\n        for (int64_t j = 0; j < master_fields_count; j++)\n            p = lpNext(lp,p); /* Skip all master fields. */\n        p = lpNext(lp,p); /* Skip the zero master entry terminator. */\n\n        /* 'p' is now pointing to the first entry inside the listpack.\n         * We have to run entry after entry, marking entries as deleted\n         * if they are already not deleted. */\n        while (p) {\n            /* We keep a copy of p (which point to flags part) in order to\n             * update it after (and if) we actually remove the entry */\n            unsigned char *pcopy = p;\n\n            int64_t flags = lpGetInteger(p);\n            p = lpNext(lp, p); /* Skip flags. */\n            int64_t to_skip;\n\n            int64_t ms_delta = lpGetInteger(p);\n            p = lpNext(lp, p); /* Skip ID ms delta */\n            int64_t seq_delta = lpGetInteger(p);\n            p = lpNext(lp, p); /* Skip ID seq delta */\n\n            streamID currid = {0}; /* For MINID */\n            if (trim_strategy == TRIM_STRATEGY_MINID) {\n                currid.ms = master_id.ms + ms_delta;\n                currid.seq = master_id.seq + seq_delta;\n            }\n\n            int stop;\n            if (trim_strategy == TRIM_STRATEGY_MAXLEN) {\n                stop = s->length <= maxlen;\n            } else {\n                /* Following IDs will definitely be greater because the rax\n                 * tree is sorted, no point of continuing. */\n                stop = streamCompareID(&currid, id) >= 0;\n            }\n            if (stop)\n                break;\n\n            if (flags & STREAM_ITEM_FLAG_SAMEFIELDS) {\n                to_skip = master_fields_count;\n            } else {\n                to_skip = lpGetInteger(p); /* Get num-fields. */\n                p = lpNext(lp,p); /* Skip num-fields. */\n                to_skip *= 2; /* Fields and values. */\n            }\n\n            while(to_skip--) p = lpNext(lp,p); /* Skip the whole entry. */\n            p = lpNext(lp,p); /* Skip the final lp-count field. */\n\n            /* Mark the entry as deleted. */\n            if (!(flags & STREAM_ITEM_FLAG_DELETED)) {\n                intptr_t delta = p - lp;\n                flags |= STREAM_ITEM_FLAG_DELETED;\n                lp = lpReplaceInteger(lp, &pcopy, flags);\n                deleted_from_lp++;\n                s->length--;\n                p = lp + delta;\n            }\n        }\n        deleted += deleted_from_lp;\n\n        /* Now we update the entries/deleted counters. */\n        p = lpFirst(lp);\n        lp = lpReplaceInteger(lp,&p,entries-deleted_from_lp);\n        p = lpNext(lp,p); /* Skip deleted field. */\n        int64_t marked_deleted = lpGetInteger(p);\n        lp = lpReplaceInteger(lp,&p,marked_deleted+deleted_from_lp);\n        p = lpNext(lp,p); /* Skip num-of-fields in the master entry. */\n\n        /* Here we should perform garbage collection in case at this point\n         * there are too many entries deleted inside the listpack. */\n        entries -= deleted_from_lp;\n        marked_deleted += deleted_from_lp;\n        if (entries + marked_deleted > 10 && marked_deleted > entries/2) {\n            /* TODO: perform a garbage collection. */\n        }\n\n        /* Update the listpack with the new pointer. */\n        raxInsert(s->rax,ri.key,ri.key_len,lp,NULL);\n\n        break; /* If we are here, there was enough to delete in the current\n                  node, so no need to go to the next node. */\n    }\n    raxStop(&ri);\n\n    /* Update the stream's first ID after the trimming. */\n    if (s->length == 0) {\n        s->first_id.ms = 0;\n        s->first_id.seq = 0;\n    } else if (deleted) {\n        streamGetEdgeID(s,1,1,&s->first_id);\n    }\n\n    return deleted;\n}\n\n/* Trims a stream by length. Returns the number of deleted items. */\nint64_t streamTrimByLength(stream *s, long long maxlen, int approx) {\n    streamAddTrimArgs args = {\n        .trim_strategy = TRIM_STRATEGY_MAXLEN,\n        .approx_trim = approx,\n        .limit = approx ? 100 * server.stream_node_max_entries : 0,\n        .maxlen = maxlen\n    };\n    return streamTrim(s, &args);\n}\n\n/* Trims a stream by minimum ID. Returns the number of deleted items. */\nint64_t streamTrimByID(stream *s, streamID minid, int approx) {\n    streamAddTrimArgs args = {\n        .trim_strategy = TRIM_STRATEGY_MINID,\n        .approx_trim = approx,\n        .limit = approx ? 100 * server.stream_node_max_entries : 0,\n        .minid = minid\n    };\n    return streamTrim(s, &args);\n}\n\n/* Parse the arguments of XADD/XTRIM.\n *\n * See streamAddTrimArgs for more details about the arguments handled.\n *\n * This function returns the position of the ID argument (relevant only to XADD).\n * On error -1 is returned and a reply is sent. */\nstatic int streamParseAddOrTrimArgsOrReply(client *c, streamAddTrimArgs *args, int xadd) {\n    /* Initialize arguments to defaults */\n    memset(args, 0, sizeof(*args));\n\n    /* Parse options. */\n    int i = 2; /* This is the first argument position where we could\n                  find an option, or the ID. */\n    int limit_given = 0;\n    for (; i < c->argc; i++) {\n        int moreargs = (c->argc-1) - i; /* Number of additional arguments. */\n        char *opt = c->argv[i]->ptr;\n        if (xadd && opt[0] == '*' && opt[1] == '\\0') {\n            /* This is just a fast path for the common case of auto-ID\n             * creation. */\n            break;\n        } else if (!strcasecmp(opt,\"maxlen\") && moreargs) {\n            if (args->trim_strategy != TRIM_STRATEGY_NONE) {\n                addReplyError(c,\"syntax error, MAXLEN and MINID options at the same time are not compatible\");\n                return -1;\n            }\n            args->approx_trim = 0;\n            char *next = c->argv[i+1]->ptr;\n            /* Check for the form MAXLEN ~ <count>. */\n            if (moreargs >= 2 && next[0] == '~' && next[1] == '\\0') {\n                args->approx_trim = 1;\n                i++;\n            } else if (moreargs >= 2 && next[0] == '=' && next[1] == '\\0') {\n                i++;\n            }\n            if (getLongLongFromObjectOrReply(c,c->argv[i+1],&args->maxlen,NULL)\n                != C_OK) return -1;\n\n            if (args->maxlen < 0) {\n                addReplyError(c,\"The MAXLEN argument must be >= 0.\");\n                return -1;\n            }\n            i++;\n            args->trim_strategy = TRIM_STRATEGY_MAXLEN;\n            args->trim_strategy_arg_idx = i;\n        } else if (!strcasecmp(opt,\"minid\") && moreargs) {\n            if (args->trim_strategy != TRIM_STRATEGY_NONE) {\n                addReplyError(c,\"syntax error, MAXLEN and MINID options at the same time are not compatible\");\n                return -1;\n            }\n            args->approx_trim = 0;\n            char *next = c->argv[i+1]->ptr;\n            /* Check for the form MINID ~ <id>|<age>. */\n            if (moreargs >= 2 && next[0] == '~' && next[1] == '\\0') {\n                args->approx_trim = 1;\n                i++;\n            } else if (moreargs >= 2 && next[0] == '=' && next[1] == '\\0') {\n                i++;\n            }\n\n            if (streamParseStrictIDOrReply(c,c->argv[i+1],&args->minid,0,NULL) != C_OK)\n                return -1;\n            \n            i++;\n            args->trim_strategy = TRIM_STRATEGY_MINID;\n            args->trim_strategy_arg_idx = i;\n        } else if (!strcasecmp(opt,\"limit\") && moreargs) {\n            /* Note about LIMIT: If it was not provided by the caller we set\n             * it to 100*server.stream_node_max_entries, and that's to prevent the\n             * trimming from taking too long, on the expense of not deleting entries\n             * that should be trimmed.\n             * If user wanted exact trimming (i.e. no '~') we never limit the number\n             * of trimmed entries */\n            if (getLongLongFromObjectOrReply(c,c->argv[i+1],&args->limit,NULL) != C_OK)\n                return -1;\n\n            if (args->limit < 0) {\n                addReplyError(c,\"The LIMIT argument must be >= 0.\");\n                return -1;\n            }\n            limit_given = 1;\n            i++;\n        } else if (xadd && !strcasecmp(opt,\"nomkstream\")) {\n            args->no_mkstream = 1;\n        } else if (xadd) {\n            /* If we are here is a syntax error or a valid ID. */\n            if (streamParseStrictIDOrReply(c,c->argv[i],&args->id,0,&args->seq_given) != C_OK)\n                return -1;\n            args->id_given = 1;\n            break;\n        } else {\n            addReplyErrorObject(c,shared.syntaxerr);\n            return -1;\n        }\n    }\n\n    if (args->limit && args->trim_strategy == TRIM_STRATEGY_NONE) {\n        addReplyError(c,\"syntax error, LIMIT cannot be used without specifying a trimming strategy\");\n        return -1;\n    }\n\n    if (!xadd && args->trim_strategy == TRIM_STRATEGY_NONE) {\n        addReplyError(c,\"syntax error, XTRIM must be called with a trimming strategy\");\n        return -1;\n    }\n\n    if (mustObeyClient(c)) {\n        /* If command came from master or from AOF we must not enforce maxnodes\n         * (The maxlen/minid argument was re-written to make sure there's no\n         * inconsistency). */\n        args->limit = 0;\n    } else {\n        /* We need to set the limit (only if we got '~') */\n        if (limit_given) {\n            if (!args->approx_trim) {\n                /* LIMIT was provided without ~ */\n                addReplyError(c,\"syntax error, LIMIT cannot be used without the special ~ option\");\n                return -1;\n            }\n        } else {\n            /* User didn't provide LIMIT, we must set it. */\n            if (args->approx_trim) {\n                /* In order to prevent from trimming to do too much work and \n                 * cause latency spikes we limit the amount of work it can do.\n                 * We have to cap args->limit from both sides in case \n                 * stream_node_max_entries is 0 or too big (could cause overflow)\n                 */\n                args->limit = 100 * server.stream_node_max_entries; /* Maximum 100 rax nodes. */\n                if (args->limit <= 0) args->limit = 10000;\n                if (args->limit > 1000000) args->limit = 1000000;\n            } else {\n                /* No LIMIT for exact trimming */\n                args->limit = 0;\n            }\n        }\n    }\n\n    return i;\n}\n\n/* Initialize the stream iterator, so that we can call iterating functions\n * to get the next items. This requires a corresponding streamIteratorStop()\n * at the end. The 'rev' parameter controls the direction. If it's zero the\n * iteration is from the start to the end element (inclusive), otherwise\n * if rev is non-zero, the iteration is reversed.\n *\n * Once the iterator is initialized, we iterate like this:\n *\n *  streamIterator myiterator;\n *  streamIteratorStart(&myiterator,...);\n *  int64_t numfields;\n *  while(streamIteratorGetID(&myiterator,&ID,&numfields)) {\n *      while(numfields--) {\n *          unsigned char *key, *value;\n *          size_t key_len, value_len;\n *          streamIteratorGetField(&myiterator,&key,&value,&key_len,&value_len);\n *\n *          ... do what you want with key and value ...\n *      }\n *  }\n *  streamIteratorStop(&myiterator); */\nvoid streamIteratorStart(streamIterator *si, stream *s, streamID *start, streamID *end, int rev) {\n    /* Initialize the iterator and translates the iteration start/stop\n     * elements into a 128 big big-endian number. */\n    if (start) {\n        streamEncodeID(si->start_key,start);\n    } else {\n        si->start_key[0] = 0;\n        si->start_key[1] = 0;\n    }\n\n    if (end) {\n        streamEncodeID(si->end_key,end);\n    } else {\n        si->end_key[0] = UINT64_MAX;\n        si->end_key[1] = UINT64_MAX;\n    }\n\n    /* Seek the correct node in the radix tree. */\n    raxStart(&si->ri,s->rax);\n    if (!rev) {\n        if (start && (start->ms || start->seq)) {\n            raxSeek(&si->ri,\"<=\",(unsigned char*)si->start_key,\n                    sizeof(si->start_key));\n            if (raxEOF(&si->ri)) raxSeek(&si->ri,\"^\",NULL,0);\n        } else {\n            raxSeek(&si->ri,\"^\",NULL,0);\n        }\n    } else {\n        if (end && (end->ms || end->seq)) {\n            raxSeek(&si->ri,\"<=\",(unsigned char*)si->end_key,\n                    sizeof(si->end_key));\n            if (raxEOF(&si->ri)) raxSeek(&si->ri,\"$\",NULL,0);\n        } else {\n            raxSeek(&si->ri,\"$\",NULL,0);\n        }\n    }\n    si->stream = s;\n    si->lp = NULL;     /* There is no current listpack right now. */\n    si->lp_ele = NULL; /* Current listpack cursor. */\n    si->rev = rev;     /* Direction, if non-zero reversed, from end to start. */\n    si->skip_tombstones = 1;    /* By default tombstones aren't emitted. */\n}\n\n/* Return 1 and store the current item ID at 'id' if there are still\n * elements within the iteration range, otherwise return 0 in order to\n * signal the iteration terminated. */\nint streamIteratorGetID(streamIterator *si, streamID *id, int64_t *numfields) {\n    while(1) { /* Will stop when element > stop_key or end of radix tree. */\n        /* If the current listpack is set to NULL, this is the start of the\n         * iteration or the previous listpack was completely iterated.\n         * Go to the next node. */\n        if (si->lp == NULL || si->lp_ele == NULL) {\n            if (!si->rev && !raxNext(&si->ri)) return 0;\n            else if (si->rev && !raxPrev(&si->ri)) return 0;\n            serverAssert(si->ri.key_len == sizeof(streamID));\n            /* Get the master ID. */\n            streamDecodeID(si->ri.key,&si->master_id);\n            /* Get the master fields count. */\n            si->lp = si->ri.data;\n            si->lp_ele = lpFirst(si->lp);           /* Seek items count */\n            si->lp_ele = lpNext(si->lp,si->lp_ele); /* Seek deleted count. */\n            si->lp_ele = lpNext(si->lp,si->lp_ele); /* Seek num fields. */\n            si->master_fields_count = lpGetInteger(si->lp_ele);\n            si->lp_ele = lpNext(si->lp,si->lp_ele); /* Seek first field. */\n            si->master_fields_start = si->lp_ele;\n            /* We are now pointing to the first field of the master entry.\n             * We need to seek either the first or the last entry depending\n             * on the direction of the iteration. */\n            if (!si->rev) {\n                /* If we are iterating in normal order, skip the master fields\n                 * to seek the first actual entry. */\n                for (uint64_t i = 0; i < si->master_fields_count; i++)\n                    si->lp_ele = lpNext(si->lp,si->lp_ele);\n            } else {\n                /* If we are iterating in reverse direction, just seek the\n                 * last part of the last entry in the listpack (that is, the\n                 * fields count). */\n                si->lp_ele = lpLast(si->lp);\n            }\n        } else if (si->rev) {\n            /* If we are iterating in the reverse order, and this is not\n             * the first entry emitted for this listpack, then we already\n             * emitted the current entry, and have to go back to the previous\n             * one. */\n            int64_t lp_count = lpGetInteger(si->lp_ele);\n            while(lp_count--) si->lp_ele = lpPrev(si->lp,si->lp_ele);\n            /* Seek lp-count of prev entry. */\n            si->lp_ele = lpPrev(si->lp,si->lp_ele);\n        }\n\n        /* For every radix tree node, iterate the corresponding listpack,\n         * returning elements when they are within range. */\n        while(1) {\n            if (!si->rev) {\n                /* If we are going forward, skip the previous entry\n                 * lp-count field (or in case of the master entry, the zero\n                 * term field) */\n                si->lp_ele = lpNext(si->lp,si->lp_ele);\n                if (si->lp_ele == NULL) break;\n            } else {\n                /* If we are going backward, read the number of elements this\n                 * entry is composed of, and jump backward N times to seek\n                 * its start. */\n                int64_t lp_count = lpGetInteger(si->lp_ele);\n                if (lp_count == 0) { /* We reached the master entry. */\n                    si->lp = NULL;\n                    si->lp_ele = NULL;\n                    break;\n                }\n                while(lp_count--) si->lp_ele = lpPrev(si->lp,si->lp_ele);\n            }\n\n            /* Get the flags entry. */\n            si->lp_flags = si->lp_ele;\n            int64_t flags = lpGetInteger(si->lp_ele);\n            si->lp_ele = lpNext(si->lp,si->lp_ele); /* Seek ID. */\n\n            /* Get the ID: it is encoded as difference between the master\n             * ID and this entry ID. */\n            *id = si->master_id;\n            id->ms += lpGetInteger(si->lp_ele);\n            si->lp_ele = lpNext(si->lp,si->lp_ele);\n            id->seq += lpGetInteger(si->lp_ele);\n            si->lp_ele = lpNext(si->lp,si->lp_ele);\n            unsigned char buf[sizeof(streamID)];\n            streamEncodeID(buf,id);\n\n            /* The number of entries is here or not depending on the\n             * flags. */\n            if (flags & STREAM_ITEM_FLAG_SAMEFIELDS) {\n                *numfields = si->master_fields_count;\n            } else {\n                *numfields = lpGetInteger(si->lp_ele);\n                si->lp_ele = lpNext(si->lp,si->lp_ele);\n            }\n            serverAssert(*numfields>=0);\n\n            /* If current >= start, and the entry is not marked as\n             * deleted or tombstones are included, emit it. */\n            if (!si->rev) {\n                if (memcmp(buf,si->start_key,sizeof(streamID)) >= 0 &&\n                    (!si->skip_tombstones || !(flags & STREAM_ITEM_FLAG_DELETED)))\n                {\n                    if (memcmp(buf,si->end_key,sizeof(streamID)) > 0)\n                        return 0; /* We are already out of range. */\n                    si->entry_flags = flags;\n                    if (flags & STREAM_ITEM_FLAG_SAMEFIELDS)\n                        si->master_fields_ptr = si->master_fields_start;\n                    return 1; /* Valid item returned. */\n                }\n            } else {\n                if (memcmp(buf,si->end_key,sizeof(streamID)) <= 0 &&\n                    (!si->skip_tombstones || !(flags & STREAM_ITEM_FLAG_DELETED)))\n                {\n                    if (memcmp(buf,si->start_key,sizeof(streamID)) < 0)\n                        return 0; /* We are already out of range. */\n                    si->entry_flags = flags;\n                    if (flags & STREAM_ITEM_FLAG_SAMEFIELDS)\n                        si->master_fields_ptr = si->master_fields_start;\n                    return 1; /* Valid item returned. */\n                }\n            }\n\n            /* If we do not emit, we have to discard if we are going\n             * forward, or seek the previous entry if we are going\n             * backward. */\n            if (!si->rev) {\n                int64_t to_discard = (flags & STREAM_ITEM_FLAG_SAMEFIELDS) ?\n                                      *numfields : *numfields*2;\n                for (int64_t i = 0; i < to_discard; i++)\n                    si->lp_ele = lpNext(si->lp,si->lp_ele);\n            } else {\n                int64_t prev_times = 4; /* flag + id ms + id seq + one more to\n                                           go back to the previous entry \"count\"\n                                           field. */\n                /* If the entry was not flagged SAMEFIELD we also read the\n                 * number of fields, so go back one more. */\n                if (!(flags & STREAM_ITEM_FLAG_SAMEFIELDS)) prev_times++;\n                while(prev_times--) si->lp_ele = lpPrev(si->lp,si->lp_ele);\n            }\n        }\n\n        /* End of listpack reached. Try the next/prev radix tree node. */\n    }\n}\n\n/* Get the field and value of the current item we are iterating. This should\n * be called immediately after streamIteratorGetID(), and for each field\n * according to the number of fields returned by streamIteratorGetID().\n * The function populates the field and value pointers and the corresponding\n * lengths by reference, that are valid until the next iterator call, assuming\n * no one touches the stream meanwhile. */\nvoid streamIteratorGetField(streamIterator *si, unsigned char **fieldptr, unsigned char **valueptr, int64_t *fieldlen, int64_t *valuelen) {\n    if (si->entry_flags & STREAM_ITEM_FLAG_SAMEFIELDS) {\n        *fieldptr = lpGet(si->master_fields_ptr,fieldlen,si->field_buf);\n        si->master_fields_ptr = lpNext(si->lp,si->master_fields_ptr);\n    } else {\n        *fieldptr = lpGet(si->lp_ele,fieldlen,si->field_buf);\n        si->lp_ele = lpNext(si->lp,si->lp_ele);\n    }\n    *valueptr = lpGet(si->lp_ele,valuelen,si->value_buf);\n    si->lp_ele = lpNext(si->lp,si->lp_ele);\n}\n\n/* Remove the current entry from the stream: can be called after the\n * GetID() API or after any GetField() call, however we need to iterate\n * a valid entry while calling this function. Moreover the function\n * requires the entry ID we are currently iterating, that was previously\n * returned by GetID().\n *\n * Note that after calling this function, next calls to GetField() can't\n * be performed: the entry is now deleted. Instead the iterator will\n * automatically re-seek to the next entry, so the caller should continue\n * with GetID(). */\nvoid streamIteratorRemoveEntry(streamIterator *si, streamID *current) {\n    unsigned char *lp = si->lp;\n    int64_t aux;\n\n    /* We do not really delete the entry here. Instead we mark it as\n     * deleted by flagging it, and also incrementing the count of the\n     * deleted entries in the listpack header.\n     *\n     * We start flagging: */\n    int64_t flags = lpGetInteger(si->lp_flags);\n    flags |= STREAM_ITEM_FLAG_DELETED;\n    lp = lpReplaceInteger(lp,&si->lp_flags,flags);\n\n    /* Change the valid/deleted entries count in the master entry. */\n    unsigned char *p = lpFirst(lp);\n    aux = lpGetInteger(p);\n\n    if (aux == 1) {\n        /* If this is the last element in the listpack, we can remove the whole\n         * node. */\n        lpFree(lp);\n        raxRemove(si->stream->rax,si->ri.key,si->ri.key_len,NULL);\n    } else {\n        /* In the base case we alter the counters of valid/deleted entries. */\n        lp = lpReplaceInteger(lp,&p,aux-1);\n        p = lpNext(lp,p); /* Seek deleted field. */\n        aux = lpGetInteger(p);\n        lp = lpReplaceInteger(lp,&p,aux+1);\n\n        /* Update the listpack with the new pointer. */\n        if (si->lp != lp)\n            raxInsert(si->stream->rax,si->ri.key,si->ri.key_len,lp,NULL);\n    }\n\n    /* Update the number of entries counter. */\n    si->stream->length--;\n\n    /* Re-seek the iterator to fix the now messed up state. */\n    streamID start, end;\n    if (si->rev) {\n        streamDecodeID(si->start_key,&start);\n        end = *current;\n    } else {\n        start = *current;\n        streamDecodeID(si->end_key,&end);\n    }\n    streamIteratorStop(si);\n    streamIteratorStart(si,si->stream,&start,&end,si->rev);\n\n    /* TODO: perform a garbage collection here if the ratio between\n     * deleted and valid goes over a certain limit. */\n}\n\n/* Stop the stream iterator. The only cleanup we need is to free the rax\n * iterator, since the stream iterator itself is supposed to be stack\n * allocated. */\nvoid streamIteratorStop(streamIterator *si) {\n    raxStop(&si->ri);\n}\n\n/* Return 1 if `id` exists in `s` (and not marked as deleted) */\nint streamEntryExists(stream *s, streamID *id) {\n    streamIterator si;\n    streamIteratorStart(&si,s,id,id,0);\n    streamID myid;\n    int64_t numfields;\n    int found = streamIteratorGetID(&si,&myid,&numfields);\n    streamIteratorStop(&si);\n    if (!found)\n        return 0;\n    serverAssert(streamCompareID(id,&myid) == 0);\n    return 1;\n}\n\n/* Delete the specified item ID from the stream, returning 1 if the item\n * was deleted 0 otherwise (if it does not exist). */\nint streamDeleteItem(stream *s, streamID *id) {\n    int deleted = 0;\n    streamIterator si;\n    streamIteratorStart(&si,s,id,id,0);\n    streamID myid;\n    int64_t numfields;\n    if (streamIteratorGetID(&si,&myid,&numfields)) {\n        streamIteratorRemoveEntry(&si,&myid);\n        deleted = 1;\n    }\n    streamIteratorStop(&si);\n    return deleted;\n}\n\n/* Get the last valid (non-tombstone) streamID of 's'. */\nvoid streamLastValidID(stream *s, streamID *maxid)\n{\n    streamIterator si;\n    streamIteratorStart(&si,s,NULL,NULL,1);\n    int64_t numfields;\n    if (!streamIteratorGetID(&si,maxid,&numfields) && s->length)\n        serverPanic(\"Corrupt stream, length is %llu, but no max id\", (unsigned long long)s->length);\n    streamIteratorStop(&si);\n}\n\n/* Maximum size for a stream ID string. In theory 20*2+1 should be enough,\n * But to avoid chance for off by one issues and null-term, in case this will\n * be used as parsing buffer, we use a slightly larger buffer. On the other\n * hand considering sds header is gonna add 4 bytes, we wanna keep below the\n * allocator's 48 bytes bin. */\n#define STREAM_ID_STR_LEN 44\n\nsds createStreamIDString(streamID *id) {\n    /* Optimization: pre-allocate a big enough buffer to avoid reallocs. */\n    sds str = sdsnewlen(SDS_NOINIT, STREAM_ID_STR_LEN);\n    sdssetlen(str, 0);\n    return sdscatfmt(str,\"%U-%U\", id->ms,id->seq);\n}\n\n/* Emit a reply in the client output buffer by formatting a Stream ID\n * in the standard <ms>-<seq> format, using the simple string protocol\n * of REPL. */\nvoid addReplyStreamID(client *c, streamID *id) {\n    addReplyBulkSds(c,createStreamIDString(id));\n}\n\nvoid setDeferredReplyStreamID(client *c, void *dr, streamID *id) {\n    setDeferredReplyBulkSds(c, dr, createStreamIDString(id));\n}\n\n/* Similar to the above function, but just creates an object, usually useful\n * for replication purposes to create arguments. */\nrobj *createObjectFromStreamID(streamID *id) {\n    return createObject(OBJ_STRING, createStreamIDString(id));\n}\n\n/* Returns non-zero if the ID is 0-0. */\nint streamIDEqZero(streamID *id) {\n    return !(id->ms || id->seq);\n}\n\n/* A helper that returns non-zero if the range from 'start' to `end`\n * contains a tombstone.\n *\n * NOTE: this assumes that the caller had verified that 'start' is less than\n * 's->last_id'. */\nint streamRangeHasTombstones(stream *s, streamID *start, streamID *end) {\n    streamID start_id, end_id;\n\n    if (!s->length || streamIDEqZero(&s->max_deleted_entry_id)) {\n        /* The stream is empty or has no tombstones. */\n        return 0;\n    }\n\n    if (streamCompareID(&s->first_id,&s->max_deleted_entry_id) > 0) {\n        /* The latest tombstone is before the first entry. */\n        return 0;\n    }\n\n    if (start) {\n        start_id = *start;\n    } else {\n        start_id.ms = 0;\n        start_id.seq = 0;\n    }\n\n    if (end) {\n        end_id = *end;\n    } else {\n        end_id.ms = UINT64_MAX;\n        end_id.seq = UINT64_MAX;\n    }\n\n    if (streamCompareID(&start_id,&s->max_deleted_entry_id) <= 0 &&\n        streamCompareID(&s->max_deleted_entry_id,&end_id) <= 0)\n    {\n        /* start_id <= max_deleted_entry_id <= end_id: The range does include a tombstone. */\n        return 1;\n    }\n\n    /* The range doesn't includes a tombstone. */\n    return 0;\n}\n\n/* Replies with a consumer group's current lag, that is the number of messages\n * in the stream that are yet to be delivered. In case that the lag isn't\n * available due to fragmentation, the reply to the client is a null. */\nvoid streamReplyWithCGLag(client *c, stream *s, streamCG *cg) {\n    int valid = 0;\n    long long lag = 0;\n\n    if (!s->entries_added) {\n        /* The lag of a newly-initialized stream is 0. */\n        lag = 0;\n        valid = 1;\n    } else if (cg->entries_read != SCG_INVALID_ENTRIES_READ && !streamRangeHasTombstones(s,&cg->last_id,NULL)) {\n        /* No fragmentation ahead means that the group's logical reads counter\n         * is valid for performing the lag calculation. */\n        lag = (long long)s->entries_added - cg->entries_read;\n        valid = 1;\n    } else {\n        /* Attempt to retrieve the group's last ID logical read counter. */\n        long long entries_read = streamEstimateDistanceFromFirstEverEntry(s,&cg->last_id);\n        if (entries_read != SCG_INVALID_ENTRIES_READ) {\n            /* A valid counter was obtained. */\n            lag = (long long)s->entries_added - entries_read;\n            valid = 1;\n        }\n    }\n\n    if (valid) {\n        addReplyLongLong(c,lag);\n    } else {\n        addReplyNull(c);\n    }\n}\n\n/* This function returns a value that is the ID's logical read counter, or its\n * distance (the number of entries) from the first entry ever to have been added\n * to the stream.\n * \n * A counter is returned only in one of the following cases:\n * 1. The ID is the same as the stream's last ID. In this case, the returned\n *    is the same as the stream's entries_added counter.\n * 2. The ID equals that of the currently first entry in the stream, and the\n *    stream has no tombstones. The returned value, in this case, is the result\n *    of subtracting the stream's length from its added_entries, incremented by\n *    one.\n * 3. The ID less than the stream's first current entry's ID, and there are no\n *    tombstones. Here the estimated counter is the result of subtracting the\n *    stream's length from its added_entries.\n * 4. The stream's added_entries is zero, meaning that no entries were ever\n *    added.\n *\n * The special return value of ULLONG_MAX signals that the counter's value isn't\n * obtainable. It is returned in these cases:\n * 1. The provided ID, if it even exists, is somewhere between the stream's\n *    current first and last entries' IDs, or in the future.\n * 2. The stream contains one or more tombstones. */\nlong long streamEstimateDistanceFromFirstEverEntry(stream *s, streamID *id) {\n    /* The counter of any ID in an empty, never-before-used stream is 0. */\n    if (!s->entries_added) {\n        return 0;\n    }\n\n    /* In the empty stream, if the ID is smaller or equal to the last ID,\n     * it can set to the current added_entries value. */\n    if (!s->length && streamCompareID(id,&s->last_id) < 1) {\n        return s->entries_added;\n    }\n\n    int cmp_last = streamCompareID(id,&s->last_id);\n    if (cmp_last == 0) {\n        /* Return the exact counter of the last entry in the stream. */\n        return s->entries_added;\n    } else if (cmp_last > 0) {\n        /* The counter of a future ID is unknown. */\n        return SCG_INVALID_ENTRIES_READ;\n    }\n\n    int cmp_id_first = streamCompareID(id,&s->first_id);\n    int cmp_xdel_first = streamCompareID(&s->max_deleted_entry_id,&s->first_id);\n    if (streamIDEqZero(&s->max_deleted_entry_id) || cmp_xdel_first < 0) {\n        /* There's definitely no fragmentation ahead. */\n        if (cmp_id_first < 0) {\n            /* Return the estimated counter. */\n            return s->entries_added - s->length;\n        } else if (cmp_id_first == 0) {\n            /* Return the exact counter of the first entry in the stream. */\n            return s->entries_added - s->length + 1;\n        }\n    }\n\n    /* The ID is either before an XDEL that fragments the stream or an arbitrary\n     * ID. Either case, so we can't make a prediction. */\n    return SCG_INVALID_ENTRIES_READ;\n}\n\n/* As a result of an explicit XCLAIM or XREADGROUP command, new entries\n * are created in the pending list of the stream and consumers. We need\n * to propagate this changes in the form of XCLAIM commands. */\nvoid streamPropagateXCLAIM(client *c, robj *key, streamCG *group, robj *groupname, robj *id, streamNACK *nack) {\n    /* We need to generate an XCLAIM that will work in a idempotent fashion:\n     *\n     * XCLAIM <key> <group> <consumer> 0 <id> TIME <milliseconds-unix-time>\n     *        RETRYCOUNT <count> FORCE JUSTID LASTID <id>.\n     *\n     * Note that JUSTID is useful in order to avoid that XCLAIM will do\n     * useless work in the slave side, trying to fetch the stream item. */\n    robj *argv[14];\n    argv[0] = shared.xclaim;\n    argv[1] = key;\n    argv[2] = groupname;\n    argv[3] = createStringObject(nack->consumer->name,sdslen(nack->consumer->name));\n    argv[4] = shared.integers[0];\n    argv[5] = id;\n    argv[6] = shared.time;\n    argv[7] = createStringObjectFromLongLong(nack->delivery_time);\n    argv[8] = shared.retrycount;\n    argv[9] = createStringObjectFromLongLong(nack->delivery_count);\n    argv[10] = shared.force;\n    argv[11] = shared.justid;\n    argv[12] = shared.lastid;\n    argv[13] = createObjectFromStreamID(&group->last_id);\n\n    alsoPropagate(c->db->id,argv,14,PROPAGATE_AOF|PROPAGATE_REPL);\n\n    decrRefCount(argv[3]);\n    decrRefCount(argv[7]);\n    decrRefCount(argv[9]);\n    decrRefCount(argv[13]);\n}\n\n/* We need this when we want to propagate the new last-id of a consumer group\n * that was consumed by XREADGROUP with the NOACK option: in that case we can't\n * propagate the last ID just using the XCLAIM LASTID option, so we emit\n *\n *  XGROUP SETID <key> <groupname> <id> ENTRIESREAD <entries_read>\n */\nvoid streamPropagateGroupID(client *c, robj *key, streamCG *group, robj *groupname) {\n    robj *argv[7];\n    argv[0] = shared.xgroup;\n    argv[1] = shared.setid;\n    argv[2] = key;\n    argv[3] = groupname;\n    argv[4] = createObjectFromStreamID(&group->last_id);\n    argv[5] = shared.entriesread;\n    argv[6] = createStringObjectFromLongLong(group->entries_read);\n\n    alsoPropagate(c->db->id,argv,7,PROPAGATE_AOF|PROPAGATE_REPL);\n\n    decrRefCount(argv[4]);\n    decrRefCount(argv[6]);\n}\n\n/* We need this when we want to propagate creation of consumer that was created\n * by XREADGROUP with the NOACK option. In that case, the only way to create\n * the consumer at the replica is by using XGROUP CREATECONSUMER (see issue #7140)\n *\n *  XGROUP CREATECONSUMER <key> <groupname> <consumername>\n */\nvoid streamPropagateConsumerCreation(client *c, robj *key, robj *groupname, sds consumername) {\n    robj *argv[5];\n    argv[0] = shared.xgroup;\n    argv[1] = shared.createconsumer;\n    argv[2] = key;\n    argv[3] = groupname;\n    argv[4] = createObject(OBJ_STRING,sdsdup(consumername));\n\n    alsoPropagate(c->db->id,argv,5,PROPAGATE_AOF|PROPAGATE_REPL);\n\n    decrRefCount(argv[4]);\n}\n\n/* Send the stream items in the specified range to the client 'c'. The range\n * the client will receive is between start and end inclusive, if 'count' is\n * non zero, no more than 'count' elements are sent.\n *\n * The 'end' pointer can be NULL to mean that we want all the elements from\n * 'start' till the end of the stream. If 'rev' is non zero, elements are\n * produced in reversed order from end to start.\n *\n * The function returns the number of entries emitted.\n *\n * If group and consumer are not NULL, the function performs additional work:\n * 1. It updates the last delivered ID in the group in case we are\n *    sending IDs greater than the current last ID.\n * 2. If the requested IDs are already assigned to some other consumer, the\n *    function will not return it to the client.\n * 3. An entry in the pending list will be created for every entry delivered\n *    for the first time to this consumer.\n * 4. The group's read counter is incremented if it is already valid and there\n *    are no future tombstones, or is invalidated (set to 0) otherwise. If the\n *    counter is invalid to begin with, we try to obtain it for the last\n *    delivered ID.\n *\n * The behavior may be modified passing non-zero flags:\n *\n * STREAM_RWR_NOACK: Do not create PEL entries, that is, the point \"3\" above\n *                   is not performed.\n * STREAM_RWR_RAWENTRIES: Do not emit array boundaries, but just the entries,\n *                        and return the number of entries emitted as usually.\n *                        This is used when the function is just used in order\n *                        to emit data and there is some higher level logic.\n *\n * The final argument 'spi' (stream propagation info pointer) is a structure\n * filled with information needed to propagate the command execution to AOF\n * and slaves, in the case a consumer group was passed: we need to generate\n * XCLAIM commands to create the pending list into AOF/slaves in that case.\n *\n * If 'spi' is set to NULL no propagation will happen even if the group was\n * given, but currently such a feature is never used by the code base that\n * will always pass 'spi' and propagate when a group is passed.\n *\n * Note that this function is recursive in certain cases. When it's called\n * with a non NULL group and consumer argument, it may call\n * streamReplyWithRangeFromConsumerPEL() in order to get entries from the\n * consumer pending entries list. However such a function will then call\n * streamReplyWithRange() in order to emit single entries (found in the\n * PEL by ID) to the client. This is the use case for the STREAM_RWR_RAWENTRIES\n * flag.\n */\n#define STREAM_RWR_NOACK (1<<0)         /* Do not create entries in the PEL. */\n#define STREAM_RWR_RAWENTRIES (1<<1)    /* Do not emit protocol for array\n                                           boundaries, just the entries. */\n#define STREAM_RWR_HISTORY (1<<2)       /* Only serve consumer local PEL. */\nsize_t streamReplyWithRange(client *c, stream *s, streamID *start, streamID *end, size_t count, int rev, streamCG *group, streamConsumer *consumer, int flags, streamPropInfo *spi) {\n    void *arraylen_ptr = NULL;\n    size_t arraylen = 0;\n    streamIterator si;\n    int64_t numfields;\n    streamID id;\n    int propagate_last_id = 0;\n    int noack = flags & STREAM_RWR_NOACK;\n\n    /* If the client is asking for some history, we serve it using a\n     * different function, so that we return entries *solely* from its\n     * own PEL. This ensures each consumer will always and only see\n     * the history of messages delivered to it and not yet confirmed\n     * as delivered. */\n    if (group && (flags & STREAM_RWR_HISTORY)) {\n        return streamReplyWithRangeFromConsumerPEL(c,s,start,end,count,\n                                                   consumer);\n    }\n\n    if (!(flags & STREAM_RWR_RAWENTRIES))\n        arraylen_ptr = addReplyDeferredLen(c);\n    streamIteratorStart(&si,s,start,end,rev);\n    while(streamIteratorGetID(&si,&id,&numfields)) {\n        /* Update the group last_id if needed. */\n        if (group && streamCompareID(&id,&group->last_id) > 0) {\n            if (group->entries_read != SCG_INVALID_ENTRIES_READ && !streamRangeHasTombstones(s,&id,NULL)) {\n                /* A valid counter and no future tombstones mean we can \n                 * increment the read counter to keep tracking the group's\n                 * progress. */\n                group->entries_read++;\n            } else if (s->entries_added) {\n                /* The group's counter may be invalid, so we try to obtain it. */\n                group->entries_read = streamEstimateDistanceFromFirstEverEntry(s,&id);\n            }\n            group->last_id = id;\n            /* Group last ID should be propagated only if NOACK was\n             * specified, otherwise the last id will be included\n             * in the propagation of XCLAIM itself. */\n            if (noack) propagate_last_id = 1;\n        }\n\n        /* Emit a two elements array for each item. The first is\n         * the ID, the second is an array of field-value pairs. */\n        addReplyArrayLen(c,2);\n        addReplyStreamID(c,&id);\n\n        addReplyArrayLen(c,numfields*2);\n\n        /* Emit the field-value pairs. */\n        while(numfields--) {\n            unsigned char *key, *value;\n            int64_t key_len, value_len;\n            streamIteratorGetField(&si,&key,&value,&key_len,&value_len);\n            addReplyBulkCBuffer(c,key,key_len);\n            addReplyBulkCBuffer(c,value,value_len);\n        }\n\n        /* If a group is passed, we need to create an entry in the\n         * PEL (pending entries list) of this group *and* this consumer.\n         *\n         * Note that we cannot be sure about the fact the message is not\n         * already owned by another consumer, because the admin is able\n         * to change the consumer group last delivered ID using the\n         * XGROUP SETID command. So if we find that there is already\n         * a NACK for the entry, we need to associate it to the new\n         * consumer. */\n        if (group && !noack) {\n            unsigned char buf[sizeof(streamID)];\n            streamEncodeID(buf,&id);\n\n            /* Try to add a new NACK. Most of the time this will work and\n             * will not require extra lookups. We'll fix the problem later\n             * if we find that there is already a entry for this ID. */\n            streamNACK *nack = streamCreateNACK(consumer);\n            int group_inserted =\n                raxTryInsert(group->pel,buf,sizeof(buf),nack,NULL);\n            int consumer_inserted =\n                raxTryInsert(consumer->pel,buf,sizeof(buf),nack,NULL);\n\n            /* Now we can check if the entry was already busy, and\n             * in that case reassign the entry to the new consumer,\n             * or update it if the consumer is the same as before. */\n            if (group_inserted == 0) {\n                streamFreeNACK(nack);\n                nack = raxFind(group->pel,buf,sizeof(buf));\n                serverAssert(nack != raxNotFound);\n                raxRemove(nack->consumer->pel,buf,sizeof(buf),NULL);\n                /* Update the consumer and NACK metadata. */\n                nack->consumer = consumer;\n                nack->delivery_time = mstime();\n                nack->delivery_count = 1;\n                /* Add the entry in the new consumer local PEL. */\n                raxInsert(consumer->pel,buf,sizeof(buf),nack,NULL);\n            } else if (group_inserted == 1 && consumer_inserted == 0) {\n                serverPanic(\"NACK half-created. Should not be possible.\");\n            }\n\n            /* Propagate as XCLAIM. */\n            if (spi) {\n                robj *idarg = createObjectFromStreamID(&id);\n                streamPropagateXCLAIM(c,spi->keyname,group,spi->groupname,idarg,nack);\n                decrRefCount(idarg);\n            }\n        }\n\n        arraylen++;\n        if (count && count == arraylen) break;\n    }\n\n    if (spi && propagate_last_id)\n        streamPropagateGroupID(c,spi->keyname,group,spi->groupname);\n\n    streamIteratorStop(&si);\n    if (arraylen_ptr) setDeferredArrayLen(c,arraylen_ptr,arraylen);\n    return arraylen;\n}\n\n/* This is a helper function for streamReplyWithRange() when called with\n * group and consumer arguments, but with a range that is referring to already\n * delivered messages. In this case we just emit messages that are already\n * in the history of the consumer, fetching the IDs from its PEL.\n *\n * Note that this function does not have a 'rev' argument because it's not\n * possible to iterate in reverse using a group. Basically this function\n * is only called as a result of the XREADGROUP command.\n *\n * This function is more expensive because it needs to inspect the PEL and then\n * seek into the radix tree of the messages in order to emit the full message\n * to the client. However clients only reach this code path when they are\n * fetching the history of already retrieved messages, which is rare. */\nsize_t streamReplyWithRangeFromConsumerPEL(client *c, stream *s, streamID *start, streamID *end, size_t count, streamConsumer *consumer) {\n    raxIterator ri;\n    unsigned char startkey[sizeof(streamID)];\n    unsigned char endkey[sizeof(streamID)];\n    streamEncodeID(startkey,start);\n    if (end) streamEncodeID(endkey,end);\n\n    size_t arraylen = 0;\n    void *arraylen_ptr = addReplyDeferredLen(c);\n    raxStart(&ri,consumer->pel);\n    raxSeek(&ri,\">=\",startkey,sizeof(startkey));\n    while(raxNext(&ri) && (!count || arraylen < count)) {\n        if (end && memcmp(ri.key,end,ri.key_len) > 0) break;\n        streamID thisid;\n        streamDecodeID(ri.key,&thisid);\n        if (streamReplyWithRange(c,s,&thisid,&thisid,1,0,NULL,NULL,\n                                 STREAM_RWR_RAWENTRIES,NULL) == 0)\n        {\n            /* Note that we may have a not acknowledged entry in the PEL\n             * about a message that's no longer here because was removed\n             * by the user by other means. In that case we signal it emitting\n             * the ID but then a NULL entry for the fields. */\n            addReplyArrayLen(c,2);\n            addReplyStreamID(c,&thisid);\n            addReplyNullArray(c);\n        } else {\n            streamNACK *nack = ri.data;\n            nack->delivery_time = mstime();\n            nack->delivery_count++;\n        }\n        arraylen++;\n    }\n    raxStop(&ri);\n    setDeferredArrayLen(c,arraylen_ptr,arraylen);\n    return arraylen;\n}\n\n/* -----------------------------------------------------------------------\n * Stream commands implementation\n * ----------------------------------------------------------------------- */\n\n/* Look the stream at 'key' and return the corresponding stream object.\n * The function creates a key setting it to an empty stream if needed. */\nrobj *streamTypeLookupWriteOrCreate(client *c, robj *key, int no_create) {\n    robj *o = lookupKeyWrite(c->db,key);\n    if (checkType(c,o,OBJ_STREAM)) return NULL;\n    if (o == NULL) {\n        if (no_create) {\n            addReplyNull(c);\n            return NULL;\n        }\n        o = createStreamObject();\n        dbAdd(c->db,key,o);\n    }\n    return o;\n}\n\n/* Parse a stream ID in the format given by clients to Redis, that is\n * <ms>-<seq>, and converts it into a streamID structure. If\n * the specified ID is invalid C_ERR is returned and an error is reported\n * to the client, otherwise C_OK is returned. The ID may be in incomplete\n * form, just stating the milliseconds time part of the stream. In such a case\n * the missing part is set according to the value of 'missing_seq' parameter.\n *\n * The IDs \"-\" and \"+\" specify respectively the minimum and maximum IDs\n * that can be represented. If 'strict' is set to 1, \"-\" and \"+\" will be\n * treated as an invalid ID.\n *\n * The ID form <ms>-* specifies a millisconds-only ID, leaving the sequence part\n * to be autogenerated. When a non-NULL 'seq_given' argument is provided, this\n * form is accepted and the argument is set to 0 unless the sequence part is\n * specified.\n * \n * If 'c' is set to NULL, no reply is sent to the client. */\nint streamGenericParseIDOrReply(client *c, const robj *o, streamID *id, uint64_t missing_seq, int strict, int *seq_given) {\n    char buf[128];\n    if (sdslen(o->ptr) > sizeof(buf)-1) goto invalid;\n    memcpy(buf,o->ptr,sdslen(o->ptr)+1);\n\n    if (strict && (buf[0] == '-' || buf[0] == '+') && buf[1] == '\\0')\n        goto invalid;\n\n    if (seq_given != NULL) {\n        *seq_given = 1;\n    }\n\n    /* Handle the \"-\" and \"+\" special cases. */\n    if (buf[0] == '-' && buf[1] == '\\0') {\n        id->ms = 0;\n        id->seq = 0;\n        return C_OK;\n    } else if (buf[0] == '+' && buf[1] == '\\0') {\n        id->ms = UINT64_MAX;\n        id->seq = UINT64_MAX;\n        return C_OK;\n    }\n\n    /* Parse <ms>-<seq> form. */\n    unsigned long long ms, seq;\n    char *dot = strchr(buf,'-');\n    if (dot) *dot = '\\0';\n    if (string2ull(buf,&ms) == 0) goto invalid;\n    if (dot) {\n        size_t seqlen = strlen(dot+1);\n        if (seq_given != NULL && seqlen == 1 && *(dot + 1) == '*') {\n            /* Handle the <ms>-* form. */\n            seq = 0;\n            *seq_given = 0;\n        } else if (string2ull(dot+1,&seq) == 0) {\n            goto invalid;\n        }\n    } else {\n        seq = missing_seq;\n    }\n    id->ms = ms;\n    id->seq = seq;\n    return C_OK;\n\ninvalid:\n    if (c) addReplyError(c,\"Invalid stream ID specified as stream \"\n                           \"command argument\");\n    return C_ERR;\n}\n\n/* Wrapper for streamGenericParseIDOrReply() used by module API. */\nint streamParseID(const robj *o, streamID *id) {\n    return streamGenericParseIDOrReply(NULL,o,id,0,0,NULL);\n}\n\n/* Wrapper for streamGenericParseIDOrReply() with 'strict' argument set to\n * 0, to be used when - and + are acceptable IDs. */\nint streamParseIDOrReply(client *c, robj *o, streamID *id, uint64_t missing_seq) {\n    return streamGenericParseIDOrReply(c,o,id,missing_seq,0,NULL);\n}\n\n/* Wrapper for streamGenericParseIDOrReply() with 'strict' argument set to\n * 1, to be used when we want to return an error if the special IDs + or -\n * are provided. */\nint streamParseStrictIDOrReply(client *c, robj *o, streamID *id, uint64_t missing_seq, int *seq_given) {\n    return streamGenericParseIDOrReply(c,o,id,missing_seq,1,seq_given);\n}\n\n/* Helper for parsing a stream ID that is a range query interval. When the\n * exclude argument is NULL, streamParseIDOrReply() is called and the interval\n * is treated as close (inclusive). Otherwise, the exclude argument is set if \n * the interval is open (the \"(\" prefix) and streamParseStrictIDOrReply() is\n * called in that case.\n */\nint streamParseIntervalIDOrReply(client *c, robj *o, streamID *id, int *exclude, uint64_t missing_seq) {\n    char *p = o->ptr;\n    size_t len = sdslen(p);\n    int invalid = 0;\n    \n    if (exclude != NULL) *exclude = (len > 1 && p[0] == '(');\n    if (exclude != NULL && *exclude) {\n        robj *t = createStringObject(p+1,len-1);\n        invalid = (streamParseStrictIDOrReply(c,t,id,missing_seq,NULL) == C_ERR);\n        decrRefCount(t);\n    } else \n        invalid = (streamParseIDOrReply(c,o,id,missing_seq) == C_ERR);\n    if (invalid)\n        return C_ERR;\n    return C_OK;\n}\n\nvoid streamRewriteApproxSpecifier(client *c, int idx) {\n    rewriteClientCommandArgument(c,idx,shared.special_equals);\n}\n\n/* We propagate MAXLEN/MINID ~ <count> as MAXLEN/MINID = <resulting-len-of-stream>\n * otherwise trimming is no longer deterministic on replicas / AOF. */\nvoid streamRewriteTrimArgument(client *c, stream *s, int trim_strategy, int idx) {\n    robj *arg;\n    if (trim_strategy == TRIM_STRATEGY_MAXLEN) {\n        arg = createStringObjectFromLongLong(s->length);\n    } else {\n        streamID first_id;\n        streamGetEdgeID(s,1,0,&first_id);\n        arg = createObjectFromStreamID(&first_id);\n    }\n\n    rewriteClientCommandArgument(c,idx,arg);\n    decrRefCount(arg);\n}\n\n/* XADD key [(MAXLEN [~|=] <count> | MINID [~|=] <id>) [LIMIT <entries>]] [NOMKSTREAM] <ID or *> [field value] [field value] ... */\nvoid xaddCommand(client *c) {\n    /* Parse options. */\n    streamAddTrimArgs parsed_args;\n    int idpos = streamParseAddOrTrimArgsOrReply(c, &parsed_args, 1);\n    if (idpos < 0)\n        return; /* streamParseAddOrTrimArgsOrReply already replied. */\n    int field_pos = idpos+1; /* The ID is always one argument before the first field */\n\n    /* Check arity. */\n    if ((c->argc - field_pos) < 2 || ((c->argc-field_pos) % 2) == 1) {\n        addReplyErrorArity(c);\n        return;\n    }\n\n    /* Return ASAP if minimal ID (0-0) was given so we avoid possibly creating\n     * a new stream and have streamAppendItem fail, leaving an empty key in the\n     * database. */\n    if (parsed_args.id_given && parsed_args.seq_given &&\n        parsed_args.id.ms == 0 && parsed_args.id.seq == 0)\n    {\n        addReplyError(c,\"The ID specified in XADD must be greater than 0-0\");\n        return;\n    }\n\n    /* Lookup the stream at key. */\n    robj *o;\n    stream *s;\n    if ((o = streamTypeLookupWriteOrCreate(c,c->argv[1],parsed_args.no_mkstream)) == NULL) return;\n    s = o->ptr;\n\n    /* Return ASAP if the stream has reached the last possible ID */\n    if (s->last_id.ms == UINT64_MAX && s->last_id.seq == UINT64_MAX) {\n        addReplyError(c,\"The stream has exhausted the last possible ID, \"\n                        \"unable to add more items\");\n        return;\n    }\n\n    /* Append using the low level function and return the ID. */\n    streamID id;\n    if (streamAppendItem(s,c->argv+field_pos,(c->argc-field_pos)/2,\n        &id,parsed_args.id_given ? &parsed_args.id : NULL,parsed_args.seq_given) == C_ERR)\n    {\n        if (errno == EDOM)\n            addReplyError(c,\"The ID specified in XADD is equal or smaller than \"\n                            \"the target stream top item\");\n        else\n            addReplyError(c,\"Elements are too large to be stored\");\n        return;\n    }\n    sds replyid = createStreamIDString(&id);\n    addReplyBulkCBuffer(c, replyid, sdslen(replyid));\n\n    signalModifiedKey(c,c->db,c->argv[1]);\n    notifyKeyspaceEvent(NOTIFY_STREAM,\"xadd\",c->argv[1],c->db->id);\n    server.dirty++;\n\n    /* Trim if needed. */\n    if (parsed_args.trim_strategy != TRIM_STRATEGY_NONE) {\n        if (streamTrim(s, &parsed_args)) {\n            notifyKeyspaceEvent(NOTIFY_STREAM,\"xtrim\",c->argv[1],c->db->id);\n        }\n        if (parsed_args.approx_trim) {\n            /* In case our trimming was limited (by LIMIT or by ~) we must\n             * re-write the relevant trim argument to make sure there will be\n             * no inconsistencies in AOF loading or in the replica.\n             * It's enough to check only args->approx because there is no\n             * way LIMIT is given without the ~ option. */\n            streamRewriteApproxSpecifier(c,parsed_args.trim_strategy_arg_idx-1);\n            streamRewriteTrimArgument(c,s,parsed_args.trim_strategy,parsed_args.trim_strategy_arg_idx);\n        }\n    }\n\n    /* Let's rewrite the ID argument with the one actually generated for\n     * AOF/replication propagation. */\n    if (!parsed_args.id_given || !parsed_args.seq_given) {\n        robj *idarg = createObject(OBJ_STRING, replyid);\n        rewriteClientCommandArgument(c, idpos, idarg);\n        decrRefCount(idarg);\n    } else {\n        sdsfree(replyid);\n    }\n\n    /* We need to signal to blocked clients that there is new data on this\n     * stream. */\n    signalKeyAsReady(c->db, c->argv[1], OBJ_STREAM);\n}\n\n/* XRANGE/XREVRANGE actual implementation.\n * The 'start' and 'end' IDs are parsed as follows:\n *   Incomplete 'start' has its sequence set to 0, and 'end' to UINT64_MAX.\n *   \"-\" and \"+\"\" mean the minimal and maximal ID values, respectively.\n *   The \"(\" prefix means an open (exclusive) range, so XRANGE stream (1-0 (2-0\n *   will match anything from 1-1 and 1-UINT64_MAX.\n */\nvoid xrangeGenericCommand(client *c, int rev) {\n    robj *o;\n    stream *s;\n    streamID startid, endid;\n    long long count = -1;\n    robj *startarg = rev ? c->argv[3] : c->argv[2];\n    robj *endarg = rev ? c->argv[2] : c->argv[3];\n    int startex = 0, endex = 0;\n    \n    /* Parse start and end IDs. */\n    if (streamParseIntervalIDOrReply(c,startarg,&startid,&startex,0) != C_OK)\n        return;\n    if (startex && streamIncrID(&startid) != C_OK) {\n        addReplyError(c,\"invalid start ID for the interval\");\n        return;\n    }\n    if (streamParseIntervalIDOrReply(c,endarg,&endid,&endex,UINT64_MAX) != C_OK)\n        return;\n    if (endex && streamDecrID(&endid) != C_OK) {\n        addReplyError(c,\"invalid end ID for the interval\");\n        return;\n    }\n\n    /* Parse the COUNT option if any. */\n    if (c->argc > 4) {\n        for (int j = 4; j < c->argc; j++) {\n            int additional = c->argc-j-1;\n            if (strcasecmp(c->argv[j]->ptr,\"COUNT\") == 0 && additional >= 1) {\n                if (getLongLongFromObjectOrReply(c,c->argv[j+1],&count,NULL)\n                    != C_OK) return;\n                if (count < 0) count = 0;\n                j++; /* Consume additional arg. */\n            } else {\n                addReplyErrorObject(c,shared.syntaxerr);\n                return;\n            }\n        }\n    }\n\n    /* Return the specified range to the user. */\n    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.emptyarray)) == NULL ||\n         checkType(c,o,OBJ_STREAM)) return;\n\n    s = o->ptr;\n\n    if (count == 0) {\n        addReplyNullArray(c);\n    } else {\n        if (count == -1) count = 0;\n        streamReplyWithRange(c,s,&startid,&endid,count,rev,NULL,NULL,0,NULL);\n    }\n}\n\n/* XRANGE key start end [COUNT <n>] */\nvoid xrangeCommand(client *c) {\n    xrangeGenericCommand(c,0);\n}\n\n/* XREVRANGE key end start [COUNT <n>] */\nvoid xrevrangeCommand(client *c) {\n    xrangeGenericCommand(c,1);\n}\n\n/* XLEN */\nvoid xlenCommand(client *c) {\n    robj *o;\n    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL\n        || checkType(c,o,OBJ_STREAM)) return;\n    stream *s = o->ptr;\n    addReplyLongLong(c,s->length);\n}\n\n/* XREAD [BLOCK <milliseconds>] [COUNT <count>] STREAMS key_1 key_2 ... key_N\n *       ID_1 ID_2 ... ID_N\n *\n * This function also implements the XREAD-GROUP command, which is like XREAD\n * but accepting the [GROUP group-name consumer-name] additional option.\n * This is useful because while XREAD is a read command and can be called\n * on slaves, XREAD-GROUP is not. */\n#define XREAD_BLOCKED_DEFAULT_COUNT 1000\nvoid xreadCommand(client *c) {\n    long long timeout = -1; /* -1 means, no BLOCK argument given. */\n    long long count = 0;\n    int streams_count = 0;\n    int streams_arg = 0;\n    int noack = 0;          /* True if NOACK option was specified. */\n    streamID static_ids[STREAMID_STATIC_VECTOR_LEN];\n    streamID *ids = static_ids;\n    streamCG **groups = NULL;\n    int xreadgroup = sdslen(c->argv[0]->ptr) == 10; /* XREAD or XREADGROUP? */\n    robj *groupname = NULL;\n    robj *consumername = NULL;\n\n    /* Parse arguments. */\n    for (int i = 1; i < c->argc; i++) {\n        int moreargs = c->argc-i-1;\n        char *o = c->argv[i]->ptr;\n        if (!strcasecmp(o,\"BLOCK\") && moreargs) {\n            if (c->flags & CLIENT_SCRIPT) {\n                /*\n                 * Although the CLIENT_DENY_BLOCKING flag should protect from blocking the client\n                 * on Lua/MULTI/RM_Call we want special treatment for Lua to keep backward compatibility.\n                 * There is no sense to use BLOCK option within Lua. */\n                addReplyErrorFormat(c, \"%s command is not allowed with BLOCK option from scripts\", (char *)c->argv[0]->ptr);\n                return;\n            }\n            i++;\n            if (getTimeoutFromObjectOrReply(c,c->argv[i],&timeout,\n                UNIT_MILLISECONDS) != C_OK) return;\n        } else if (!strcasecmp(o,\"COUNT\") && moreargs) {\n            i++;\n            if (getLongLongFromObjectOrReply(c,c->argv[i],&count,NULL) != C_OK)\n                return;\n            if (count < 0) count = 0;\n        } else if (!strcasecmp(o,\"STREAMS\") && moreargs) {\n            streams_arg = i+1;\n            streams_count = (c->argc-streams_arg);\n            if ((streams_count % 2) != 0) {\n                addReplyError(c,\"Unbalanced XREAD list of streams: \"\n                                \"for each stream key an ID or '$' must be \"\n                                \"specified.\");\n                return;\n            }\n            streams_count /= 2; /* We have two arguments for each stream. */\n            break;\n        } else if (!strcasecmp(o,\"GROUP\") && moreargs >= 2) {\n            if (!xreadgroup) {\n                addReplyError(c,\"The GROUP option is only supported by \"\n                                \"XREADGROUP. You called XREAD instead.\");\n                return;\n            }\n            groupname = c->argv[i+1];\n            consumername = c->argv[i+2];\n            i += 2;\n        } else if (!strcasecmp(o,\"NOACK\")) {\n            if (!xreadgroup) {\n                addReplyError(c,\"The NOACK option is only supported by \"\n                                \"XREADGROUP. You called XREAD instead.\");\n                return;\n            }\n            noack = 1;\n        } else {\n            addReplyErrorObject(c,shared.syntaxerr);\n            return;\n        }\n    }\n\n    /* STREAMS option is mandatory. */\n    if (streams_arg == 0) {\n        addReplyErrorObject(c,shared.syntaxerr);\n        return;\n    }\n\n    /* If the user specified XREADGROUP then it must also\n     * provide the GROUP option. */\n    if (xreadgroup && groupname == NULL) {\n        addReplyError(c,\"Missing GROUP option for XREADGROUP\");\n        return;\n    }\n\n    /* Parse the IDs and resolve the group name. */\n    if (streams_count > STREAMID_STATIC_VECTOR_LEN)\n        ids = zmalloc(sizeof(streamID)*streams_count);\n    if (groupname) groups = zmalloc(sizeof(streamCG*)*streams_count);\n\n    for (int i = streams_arg + streams_count; i < c->argc; i++) {\n        /* Specifying \"$\" as last-known-id means that the client wants to be\n         * served with just the messages that will arrive into the stream\n         * starting from now. */\n        int id_idx = i - streams_arg - streams_count;\n        robj *key = c->argv[i-streams_count];\n        robj *o = lookupKeyRead(c->db,key);\n        if (checkType(c,o,OBJ_STREAM)) goto cleanup;\n        streamCG *group = NULL;\n\n        /* If a group was specified, than we need to be sure that the\n         * key and group actually exist. */\n        if (groupname) {\n            if (o == NULL ||\n                (group = streamLookupCG(o->ptr,groupname->ptr)) == NULL)\n            {\n                addReplyErrorFormat(c, \"-NOGROUP No such key '%s' or consumer \"\n                                       \"group '%s' in XREADGROUP with GROUP \"\n                                       \"option\",\n                                    (char*)key->ptr,(char*)groupname->ptr);\n                goto cleanup;\n            }\n            groups[id_idx] = group;\n        }\n\n        if (strcmp(c->argv[i]->ptr,\"$\") == 0) {\n            if (xreadgroup) {\n                addReplyError(c,\"The $ ID is meaningless in the context of \"\n                                \"XREADGROUP: you want to read the history of \"\n                                \"this consumer by specifying a proper ID, or \"\n                                \"use the > ID to get new messages. The $ ID would \"\n                                \"just return an empty result set.\");\n                goto cleanup;\n            }\n            if (o) {\n                stream *s = o->ptr;\n                ids[id_idx] = s->last_id;\n            } else {\n                ids[id_idx].ms = 0;\n                ids[id_idx].seq = 0;\n            }\n            continue;\n        } else if (strcmp(c->argv[i]->ptr,\">\") == 0) {\n            if (!xreadgroup) {\n                addReplyError(c,\"The > ID can be specified only when calling \"\n                                \"XREADGROUP using the GROUP <group> \"\n                                \"<consumer> option.\");\n                goto cleanup;\n            }\n            /* We use just the maximum ID to signal this is a \">\" ID, anyway\n             * the code handling the blocking clients will have to update the\n             * ID later in order to match the changing consumer group last ID. */\n            ids[id_idx].ms = UINT64_MAX;\n            ids[id_idx].seq = UINT64_MAX;\n            continue;\n        }\n        if (streamParseStrictIDOrReply(c,c->argv[i],ids+id_idx,0,NULL) != C_OK)\n            goto cleanup;\n    }\n\n    /* Try to serve the client synchronously. */\n    size_t arraylen = 0;\n    void *arraylen_ptr = NULL;\n    for (int i = 0; i < streams_count; i++) {\n        robj *o = lookupKeyRead(c->db,c->argv[streams_arg+i]);\n        if (o == NULL) continue;\n        stream *s = o->ptr;\n        streamID *gt = ids+i; /* ID must be greater than this. */\n        int serve_synchronously = 0;\n        int serve_history = 0; /* True for XREADGROUP with ID != \">\". */\n\n        /* Check if there are the conditions to serve the client\n         * synchronously. */\n        if (groups) {\n            /* If the consumer is blocked on a group, we always serve it\n             * synchronously (serving its local history) if the ID specified\n             * was not the special \">\" ID. */\n            if (gt->ms != UINT64_MAX ||\n                gt->seq != UINT64_MAX)\n            {\n                serve_synchronously = 1;\n                serve_history = 1;\n            } else if (s->length) {\n                /* We also want to serve a consumer in a consumer group\n                 * synchronously in case the group top item delivered is smaller\n                 * than what the stream has inside. */\n                streamID maxid, *last = &groups[i]->last_id;\n                streamLastValidID(s, &maxid);\n                if (streamCompareID(&maxid, last) > 0) {\n                    serve_synchronously = 1;\n                    *gt = *last;\n                }\n            }\n        } else if (s->length) {\n            /* For consumers without a group, we serve synchronously if we can\n             * actually provide at least one item from the stream. */\n            streamID maxid;\n            streamLastValidID(s, &maxid);\n            if (streamCompareID(&maxid, gt) > 0) {\n                serve_synchronously = 1;\n            }\n        }\n\n        if (serve_synchronously) {\n            arraylen++;\n            if (arraylen == 1) arraylen_ptr = addReplyDeferredLen(c);\n            /* streamReplyWithRange() handles the 'start' ID as inclusive,\n             * so start from the next ID, since we want only messages with\n             * IDs greater than start. */\n            streamID start = *gt;\n            streamIncrID(&start);\n\n            /* Emit the two elements sub-array consisting of the name\n             * of the stream and the data we extracted from it. */\n            if (c->resp == 2) addReplyArrayLen(c,2);\n            addReplyBulk(c,c->argv[streams_arg+i]);\n            streamConsumer *consumer = NULL;\n            streamPropInfo spi = {c->argv[i+streams_arg],groupname};\n            if (groups) {\n                consumer = streamLookupConsumer(groups[i],consumername->ptr,SLC_DEFAULT);\n                if (consumer == NULL) {\n                    consumer = streamCreateConsumer(groups[i],consumername->ptr,\n                                                    c->argv[streams_arg+i],\n                                                    c->db->id,SCC_DEFAULT);\n                    if (noack)\n                        streamPropagateConsumerCreation(c,spi.keyname,\n                                                        spi.groupname,\n                                                        consumer->name);\n                }\n            }\n            int flags = 0;\n            if (noack) flags |= STREAM_RWR_NOACK;\n            if (serve_history) flags |= STREAM_RWR_HISTORY;\n            streamReplyWithRange(c,s,&start,NULL,count,0,\n                                 groups ? groups[i] : NULL,\n                                 consumer, flags, &spi);\n            if (groups) server.dirty++;\n        }\n    }\n\n     /* We replied synchronously! Set the top array len and return to caller. */\n    if (arraylen) {\n        if (c->resp == 2)\n            setDeferredArrayLen(c,arraylen_ptr,arraylen);\n        else\n            setDeferredMapLen(c,arraylen_ptr,arraylen);\n        goto cleanup;\n    }\n\n    /* Block if needed. */\n    if (timeout != -1) {\n        /* If we are not allowed to block the client, the only thing\n         * we can do is treating it as a timeout (even with timeout 0). */\n        if (c->flags & CLIENT_DENY_BLOCKING) {\n            addReplyNullArray(c);\n            goto cleanup;\n        }\n        blockForKeys(c, BLOCKED_STREAM, c->argv+streams_arg, streams_count,\n                     -1, timeout, NULL, NULL, ids);\n        /* If no COUNT is given and we block, set a relatively small count:\n         * in case the ID provided is too low, we do not want the server to\n         * block just to serve this client a huge stream of messages. */\n        c->bpop.xread_count = count ? count : XREAD_BLOCKED_DEFAULT_COUNT;\n\n        /* If this is a XREADGROUP + GROUP we need to remember for which\n         * group and consumer name we are blocking, so later when one of the\n         * keys receive more data, we can call streamReplyWithRange() passing\n         * the right arguments. */\n        if (groupname) {\n            incrRefCount(groupname);\n            incrRefCount(consumername);\n            c->bpop.xread_group = groupname;\n            c->bpop.xread_consumer = consumername;\n            c->bpop.xread_group_noack = noack;\n        } else {\n            c->bpop.xread_group = NULL;\n            c->bpop.xread_consumer = NULL;\n        }\n        goto cleanup;\n    }\n\n    /* No BLOCK option, nor any stream we can serve. Reply as with a\n     * timeout happened. */\n    addReplyNullArray(c);\n    /* Continue to cleanup... */\n\ncleanup: /* Cleanup. */\n\n    /* The command is propagated (in the READGROUP form) as a side effect\n     * of calling lower level APIs. So stop any implicit propagation. */\n    preventCommandPropagation(c);\n    if (ids != static_ids) zfree(ids);\n    zfree(groups);\n}\n\n/* -----------------------------------------------------------------------\n * Low level implementation of consumer groups\n * ----------------------------------------------------------------------- */\n\n/* Create a NACK entry setting the delivery count to 1 and the delivery\n * time to the current time. The NACK consumer will be set to the one\n * specified as argument of the function. */\nstreamNACK *streamCreateNACK(streamConsumer *consumer) {\n    streamNACK *nack = zmalloc(sizeof(*nack));\n    nack->delivery_time = mstime();\n    nack->delivery_count = 1;\n    nack->consumer = consumer;\n    return nack;\n}\n\n/* Free a NACK entry. */\nvoid streamFreeNACK(streamNACK *na) {\n    zfree(na);\n}\n\n/* Free a consumer and associated data structures. Note that this function\n * will not reassign the pending messages associated with this consumer\n * nor will delete them from the stream, so when this function is called\n * to delete a consumer, and not when the whole stream is destroyed, the caller\n * should do some work before. */\nvoid streamFreeConsumer(streamConsumer *sc) {\n    raxFree(sc->pel); /* No value free callback: the PEL entries are shared\n                         between the consumer and the main stream PEL. */\n    sdsfree(sc->name);\n    zfree(sc);\n}\n\n/* Create a new consumer group in the context of the stream 's', having the\n * specified name, last server ID and reads counter. If a consumer group with\n * the same name already exists NULL is returned, otherwise the pointer to the\n * consumer group is returned. */\nstreamCG *streamCreateCG(stream *s, char *name, size_t namelen, streamID *id, long long entries_read) {\n    if (s->cgroups == NULL) s->cgroups = raxNew();\n    if (raxFind(s->cgroups,(unsigned char*)name,namelen) != raxNotFound)\n        return NULL;\n\n    streamCG *cg = zmalloc(sizeof(*cg));\n    cg->pel = raxNew();\n    cg->consumers = raxNew();\n    cg->last_id = *id;\n    cg->entries_read = entries_read;\n    raxInsert(s->cgroups,(unsigned char*)name,namelen,cg,NULL);\n    return cg;\n}\n\n/* Free a consumer group and all its associated data. */\nvoid streamFreeCG(streamCG *cg) {\n    raxFreeWithCallback(cg->pel,(void(*)(void*))streamFreeNACK);\n    raxFreeWithCallback(cg->consumers,(void(*)(void*))streamFreeConsumer);\n    zfree(cg);\n}\n\n/* Lookup the consumer group in the specified stream and returns its\n * pointer, otherwise if there is no such group, NULL is returned. */\nstreamCG *streamLookupCG(stream *s, sds groupname) {\n    if (s->cgroups == NULL) return NULL;\n    streamCG *cg = raxFind(s->cgroups,(unsigned char*)groupname,\n                           sdslen(groupname));\n    return (cg == raxNotFound) ? NULL : cg;\n}\n\n/* Create a consumer with the specified name in the group 'cg' and return.\n * If the consumer exists, return NULL. As a side effect, when the consumer\n * is successfully created, the key space will be notified and dirty++ unless\n * the SCC_NO_NOTIFY or SCC_NO_DIRTIFY flags is specified. */\nstreamConsumer *streamCreateConsumer(streamCG *cg, sds name, robj *key, int dbid, int flags) {\n    if (cg == NULL) return NULL;\n    int notify = !(flags & SCC_NO_NOTIFY);\n    int dirty = !(flags & SCC_NO_DIRTIFY);\n    streamConsumer *consumer = zmalloc(sizeof(*consumer));\n    int success = raxTryInsert(cg->consumers,(unsigned char*)name,\n                               sdslen(name),consumer,NULL);\n    if (!success) {\n        zfree(consumer);\n        return NULL;\n    }\n    consumer->name = sdsdup(name);\n    consumer->pel = raxNew();\n    consumer->seen_time = mstime();\n    if (dirty) server.dirty++;\n    if (notify) notifyKeyspaceEvent(NOTIFY_STREAM,\"xgroup-createconsumer\",key,dbid);\n    return consumer;\n}\n\n/* Lookup the consumer with the specified name in the group 'cg'. Its last \n * seen time is updated unless the SLC_NO_REFRESH flag is specified. */\nstreamConsumer *streamLookupConsumer(streamCG *cg, sds name, int flags) {\n    if (cg == NULL) return NULL;\n    int refresh = !(flags & SLC_NO_REFRESH);\n    streamConsumer *consumer = raxFind(cg->consumers,(unsigned char*)name,\n                                       sdslen(name));\n    if (consumer == raxNotFound) return NULL;\n    if (refresh) consumer->seen_time = mstime();\n    return consumer;\n}\n\n/* Delete the consumer specified in the consumer group 'cg'. */\nvoid streamDelConsumer(streamCG *cg, streamConsumer *consumer) {\n    /* Iterate all the consumer pending messages, deleting every corresponding\n     * entry from the global entry. */\n    raxIterator ri;\n    raxStart(&ri,consumer->pel);\n    raxSeek(&ri,\"^\",NULL,0);\n    while(raxNext(&ri)) {\n        streamNACK *nack = ri.data;\n        raxRemove(cg->pel,ri.key,ri.key_len,NULL);\n        streamFreeNACK(nack);\n    }\n    raxStop(&ri);\n\n    /* Deallocate the consumer. */\n    raxRemove(cg->consumers,(unsigned char*)consumer->name,\n              sdslen(consumer->name),NULL);\n    streamFreeConsumer(consumer);\n}\n\n/* -----------------------------------------------------------------------\n * Consumer groups commands\n * ----------------------------------------------------------------------- */\n\n/* XGROUP CREATE <key> <groupname> <id or $> [MKSTREAM] [ENTRIESADDED count]\n * XGROUP SETID <key> <groupname> <id or $> [ENTRIESADDED count]\n * XGROUP DESTROY <key> <groupname>\n * XGROUP CREATECONSUMER <key> <groupname> <consumer>\n * XGROUP DELCONSUMER <key> <groupname> <consumername> */\nvoid xgroupCommand(client *c) {\n    stream *s = NULL;\n    sds grpname = NULL;\n    streamCG *cg = NULL;\n    char *opt = c->argv[1]->ptr; /* Subcommand name. */\n    int mkstream = 0;\n    long long entries_read = SCG_INVALID_ENTRIES_READ;\n    robj *o;\n\n    /* Everything but the \"HELP\" option requires a key and group name. */\n    if (c->argc >= 4) {\n        /* Parse optional arguments for CREATE and SETID */\n        int i = 5;\n        int create_subcmd = !strcasecmp(opt,\"CREATE\");\n        int setid_subcmd = !strcasecmp(opt,\"SETID\");\n        while (i < c->argc) {\n            if (create_subcmd && !strcasecmp(c->argv[i]->ptr,\"MKSTREAM\")) {\n                mkstream = 1;\n                i++;\n            } else if ((create_subcmd || setid_subcmd) && !strcasecmp(c->argv[i]->ptr,\"ENTRIESREAD\") && i + 1 < c->argc) {\n                if (getLongLongFromObjectOrReply(c,c->argv[i+1],&entries_read,NULL) != C_OK)\n                    return;\n                if (entries_read < 0 && entries_read != SCG_INVALID_ENTRIES_READ) {\n                    addReplyError(c,\"value for ENTRIESREAD must be positive or -1\");\n                    return;\n                }\n                i += 2;\n            } else {\n                addReplySubcommandSyntaxError(c);\n                return;\n            }\n        }\n\n        o = lookupKeyWrite(c->db,c->argv[2]);\n        if (o) {\n            if (checkType(c,o,OBJ_STREAM)) return;\n            s = o->ptr;\n        }\n        grpname = c->argv[3]->ptr;\n    }\n\n    /* Check for missing key/group. */\n    if (c->argc >= 4 && !mkstream) {\n        /* At this point key must exist, or there is an error. */\n        if (s == NULL) {\n            addReplyError(c,\n                \"The XGROUP subcommand requires the key to exist. \"\n                \"Note that for CREATE you may want to use the MKSTREAM \"\n                \"option to create an empty stream automatically.\");\n            return;\n        }\n\n        /* Certain subcommands require the group to exist. */\n        if ((cg = streamLookupCG(s,grpname)) == NULL &&\n            (!strcasecmp(opt,\"SETID\") ||\n             !strcasecmp(opt,\"CREATECONSUMER\") ||\n             !strcasecmp(opt,\"DELCONSUMER\")))\n        {\n            addReplyErrorFormat(c, \"-NOGROUP No such consumer group '%s' \"\n                                   \"for key name '%s'\",\n                                   (char*)grpname, (char*)c->argv[2]->ptr);\n            return;\n        }\n    }\n\n    /* Dispatch the different subcommands. */\n    if (c->argc == 2 && !strcasecmp(opt,\"HELP\")) {\n        const char *help[] = {\n\"CREATE <key> <groupname> <id|$> [option]\",\n\"    Create a new consumer group. Options are:\",\n\"    * MKSTREAM\",\n\"      Create the empty stream if it does not exist.\",\n\"    * ENTRIESREAD entries_read\",\n\"      Set the group's entries_read counter (internal use).\",\n\"CREATECONSUMER <key> <groupname> <consumer>\",\n\"    Create a new consumer in the specified group.\",\n\"DELCONSUMER <key> <groupname> <consumer>\",\n\"    Remove the specified consumer.\",\n\"DESTROY <key> <groupname>\",\n\"    Remove the specified group.\",\n\"SETID <key> <groupname> <id|$> [ENTRIESREAD entries_read]\",\n\"    Set the current group ID and entries_read counter.\",\nNULL\n        };\n        addReplyHelp(c, help);\n    } else if (!strcasecmp(opt,\"CREATE\") && (c->argc >= 5 && c->argc <= 8)) {\n        streamID id;\n        if (!strcmp(c->argv[4]->ptr,\"$\")) {\n            if (s) {\n                id = s->last_id;\n            } else {\n                id.ms = 0;\n                id.seq = 0;\n            }\n        } else if (streamParseStrictIDOrReply(c,c->argv[4],&id,0,NULL) != C_OK) {\n            return;\n        }\n\n        /* Handle the MKSTREAM option now that the command can no longer fail. */\n        if (s == NULL) {\n            serverAssert(mkstream);\n            o = createStreamObject();\n            dbAdd(c->db,c->argv[2],o);\n            s = o->ptr;\n            signalModifiedKey(c,c->db,c->argv[2]);\n        }\n\n        streamCG *cg = streamCreateCG(s,grpname,sdslen(grpname),&id,entries_read);\n        if (cg) {\n            addReply(c,shared.ok);\n            server.dirty++;\n            notifyKeyspaceEvent(NOTIFY_STREAM,\"xgroup-create\",\n                                c->argv[2],c->db->id);\n        } else {\n            addReplyError(c,\"-BUSYGROUP Consumer Group name already exists\");\n        }\n    } else if (!strcasecmp(opt,\"SETID\") && (c->argc == 5 || c->argc == 7)) {\n        streamID id;\n        if (!strcmp(c->argv[4]->ptr,\"$\")) {\n            id = s->last_id;\n        } else if (streamParseIDOrReply(c,c->argv[4],&id,0) != C_OK) {\n            return;\n        }\n        cg->last_id = id;\n        cg->entries_read = entries_read;\n        addReply(c,shared.ok);\n        server.dirty++;\n        notifyKeyspaceEvent(NOTIFY_STREAM,\"xgroup-setid\",c->argv[2],c->db->id);\n    } else if (!strcasecmp(opt,\"DESTROY\") && c->argc == 4) {\n        if (cg) {\n            raxRemove(s->cgroups,(unsigned char*)grpname,sdslen(grpname),NULL);\n            streamFreeCG(cg);\n            addReply(c,shared.cone);\n            server.dirty++;\n            notifyKeyspaceEvent(NOTIFY_STREAM,\"xgroup-destroy\",\n                                c->argv[2],c->db->id);\n            /* We want to unblock any XREADGROUP consumers with -NOGROUP. */\n            signalKeyAsReady(c->db,c->argv[2],OBJ_STREAM);\n        } else {\n            addReply(c,shared.czero);\n        }\n    } else if (!strcasecmp(opt,\"CREATECONSUMER\") && c->argc == 5) {\n        streamConsumer *created = streamCreateConsumer(cg,c->argv[4]->ptr,c->argv[2],\n                                                       c->db->id,SCC_DEFAULT);\n        addReplyLongLong(c,created ? 1 : 0);\n    } else if (!strcasecmp(opt,\"DELCONSUMER\") && c->argc == 5) {\n        long long pending = 0;\n        streamConsumer *consumer = streamLookupConsumer(cg,c->argv[4]->ptr,SLC_NO_REFRESH);\n        if (consumer) {\n            /* Delete the consumer and returns the number of pending messages\n             * that were yet associated with such a consumer. */\n            pending = raxSize(consumer->pel);\n            streamDelConsumer(cg,consumer);\n            server.dirty++;\n            notifyKeyspaceEvent(NOTIFY_STREAM,\"xgroup-delconsumer\",\n                                c->argv[2],c->db->id);\n        }\n        addReplyLongLong(c,pending);\n    } else {\n        addReplySubcommandSyntaxError(c);\n    }\n}\n\n/* XSETID <stream> <id> [ENTRIESADDED entries_added] [MAXDELETEDID max_deleted_entry_id]\n *\n * Set the internal \"last ID\", \"added entries\" and \"maximal deleted entry ID\"\n * of a stream. */\nvoid xsetidCommand(client *c) {\n    streamID id, max_xdel_id = {0, 0};\n    long long entries_added = -1;\n\n    if (streamParseStrictIDOrReply(c,c->argv[2],&id,0,NULL) != C_OK)\n        return;\n\n    int i = 3;\n    while (i < c->argc) {\n        int moreargs = (c->argc-1) - i; /* Number of additional arguments. */\n        char *opt = c->argv[i]->ptr;\n        if (!strcasecmp(opt,\"ENTRIESADDED\") && moreargs) {\n            if (getLongLongFromObjectOrReply(c,c->argv[i+1],&entries_added,NULL) != C_OK) {\n                return;\n            } else if (entries_added < 0) {\n                addReplyError(c,\"entries_added must be positive\");\n                return;\n            }\n            i += 2;\n        } else if (!strcasecmp(opt,\"MAXDELETEDID\") && moreargs) {\n            if (streamParseStrictIDOrReply(c,c->argv[i+1],&max_xdel_id,0,NULL) != C_OK) {\n                return;\n            } else if (streamCompareID(&id,&max_xdel_id) < 0) {\n                addReplyError(c,\"The ID specified in XSETID is smaller than the provided max_deleted_entry_id\");\n                return;\n            }\n            i += 2;\n        } else {\n            addReplyErrorObject(c,shared.syntaxerr);\n            return;\n        }\n    }\n\n    robj *o = lookupKeyWriteOrReply(c,c->argv[1],shared.nokeyerr);\n    if (o == NULL || checkType(c,o,OBJ_STREAM)) return;\n    stream *s = o->ptr;\n\n    /* If the stream has at least one item, we want to check that the user\n     * is setting a last ID that is equal or greater than the current top\n     * item, otherwise the fundamental ID monotonicity assumption is violated. */\n    if (s->length > 0) {\n        streamID maxid;\n        streamLastValidID(s,&maxid);\n\n        if (streamCompareID(&id,&maxid) < 0) {\n            addReplyError(c,\"The ID specified in XSETID is smaller than the target stream top item\");\n            return;\n        }\n\n        /* If an entries_added was provided, it can't be lower than the length. */\n        if (entries_added != -1 && s->length > (uint64_t)entries_added) {\n            addReplyError(c,\"The entries_added specified in XSETID is smaller than the target stream length\");\n            return;\n        }\n    }\n\n    s->last_id = id;\n    if (entries_added != -1)\n        s->entries_added = entries_added;\n    if (!streamIDEqZero(&max_xdel_id))\n        s->max_deleted_entry_id = max_xdel_id;\n    addReply(c,shared.ok);\n    server.dirty++;\n    notifyKeyspaceEvent(NOTIFY_STREAM,\"xsetid\",c->argv[1],c->db->id);\n}\n\n/* XACK <key> <group> <id> <id> ... <id>\n *\n * Acknowledge a message as processed. In practical terms we just check the\n * pending entries list (PEL) of the group, and delete the PEL entry both from\n * the group and the consumer (pending messages are referenced in both places).\n *\n * Return value of the command is the number of messages successfully\n * acknowledged, that is, the IDs we were actually able to resolve in the PEL.\n */\nvoid xackCommand(client *c) {\n    streamCG *group = NULL;\n    robj *o = lookupKeyRead(c->db,c->argv[1]);\n    if (o) {\n        if (checkType(c,o,OBJ_STREAM)) return; /* Type error. */\n        group = streamLookupCG(o->ptr,c->argv[2]->ptr);\n    }\n\n    /* No key or group? Nothing to ack. */\n    if (o == NULL || group == NULL) {\n        addReply(c,shared.czero);\n        return;\n    }\n\n    /* Start parsing the IDs, so that we abort ASAP if there is a syntax\n     * error: the return value of this command cannot be an error in case\n     * the client successfully acknowledged some messages, so it should be\n     * executed in a \"all or nothing\" fashion. */\n    streamID static_ids[STREAMID_STATIC_VECTOR_LEN];\n    streamID *ids = static_ids;\n    int id_count = c->argc-3;\n    if (id_count > STREAMID_STATIC_VECTOR_LEN)\n        ids = zmalloc(sizeof(streamID)*id_count);\n    for (int j = 3; j < c->argc; j++) {\n        if (streamParseStrictIDOrReply(c,c->argv[j],&ids[j-3],0,NULL) != C_OK) goto cleanup;\n    }\n\n    int acknowledged = 0;\n    for (int j = 3; j < c->argc; j++) {\n        unsigned char buf[sizeof(streamID)];\n        streamEncodeID(buf,&ids[j-3]);\n\n        /* Lookup the ID in the group PEL: it will have a reference to the\n         * NACK structure that will have a reference to the consumer, so that\n         * we are able to remove the entry from both PELs. */\n        streamNACK *nack = raxFind(group->pel,buf,sizeof(buf));\n        if (nack != raxNotFound) {\n            raxRemove(group->pel,buf,sizeof(buf),NULL);\n            raxRemove(nack->consumer->pel,buf,sizeof(buf),NULL);\n            streamFreeNACK(nack);\n            acknowledged++;\n            server.dirty++;\n        }\n    }\n    addReplyLongLong(c,acknowledged);\ncleanup:\n    if (ids != static_ids) zfree(ids);\n}\n\n/* XPENDING <key> <group> [[IDLE <idle>] <start> <stop> <count> [<consumer>]]\n *\n * If start and stop are omitted, the command just outputs information about\n * the amount of pending messages for the key/group pair, together with\n * the minimum and maximum ID of pending messages.\n *\n * If start and stop are provided instead, the pending messages are returned\n * with information about the current owner, number of deliveries and last\n * delivery time and so forth. */\nvoid xpendingCommand(client *c) {\n    int justinfo = c->argc == 3; /* Without the range just outputs general\n                                    information about the PEL. */\n    robj *key = c->argv[1];\n    robj *groupname = c->argv[2];\n    robj *consumername = NULL;\n    streamID startid, endid;\n    long long count = 0;\n    long long minidle = 0;\n    int startex = 0, endex = 0;\n\n    /* Start and stop, and the consumer, can be omitted. Also the IDLE modifier. */\n    if (c->argc != 3 && (c->argc < 6 || c->argc > 9)) {\n        addReplyErrorObject(c,shared.syntaxerr);\n        return;\n    }\n\n    /* Parse start/end/count arguments ASAP if needed, in order to report\n     * syntax errors before any other error. */\n    if (c->argc >= 6) {\n        int startidx = 3; /* Without IDLE */\n\n        if (!strcasecmp(c->argv[3]->ptr, \"IDLE\")) {\n            if (getLongLongFromObjectOrReply(c, c->argv[4], &minidle, NULL) == C_ERR)\n                return;\n            if (c->argc < 8) {\n                /* If IDLE was provided we must have at least 'start end count' */\n                addReplyErrorObject(c,shared.syntaxerr);\n                return;\n            }\n            /* Search for rest of arguments after 'IDLE <idle>' */\n            startidx += 2;\n        }\n\n        /* count argument. */\n        if (getLongLongFromObjectOrReply(c,c->argv[startidx+2],&count,NULL) == C_ERR)\n            return;\n        if (count < 0) count = 0;\n\n        /* start and end arguments. */\n        if (streamParseIntervalIDOrReply(c,c->argv[startidx],&startid,&startex,0) != C_OK)\n            return;\n        if (startex && streamIncrID(&startid) != C_OK) {\n            addReplyError(c,\"invalid start ID for the interval\");\n            return;\n        }\n        if (streamParseIntervalIDOrReply(c,c->argv[startidx+1],&endid,&endex,UINT64_MAX) != C_OK)\n            return;\n        if (endex && streamDecrID(&endid) != C_OK) {\n            addReplyError(c,\"invalid end ID for the interval\");\n            return;\n        }\n\n        if (startidx+3 < c->argc) {\n            /* 'consumer' was provided */\n            consumername = c->argv[startidx+3];\n        }\n    }\n\n    /* Lookup the key and the group inside the stream. */\n    robj *o = lookupKeyRead(c->db,c->argv[1]);\n    streamCG *group;\n\n    if (checkType(c,o,OBJ_STREAM)) return;\n    if (o == NULL ||\n        (group = streamLookupCG(o->ptr,groupname->ptr)) == NULL)\n    {\n        addReplyErrorFormat(c, \"-NOGROUP No such key '%s' or consumer \"\n                               \"group '%s'\",\n                               (char*)key->ptr,(char*)groupname->ptr);\n        return;\n    }\n\n    /* XPENDING <key> <group> variant. */\n    if (justinfo) {\n        addReplyArrayLen(c,4);\n        /* Total number of messages in the PEL. */\n        addReplyLongLong(c,raxSize(group->pel));\n        /* First and last IDs. */\n        if (raxSize(group->pel) == 0) {\n            addReplyNull(c); /* Start. */\n            addReplyNull(c); /* End. */\n            addReplyNullArray(c); /* Clients. */\n        } else {\n            /* Start. */\n            raxIterator ri;\n            raxStart(&ri,group->pel);\n            raxSeek(&ri,\"^\",NULL,0);\n            raxNext(&ri);\n            streamDecodeID(ri.key,&startid);\n            addReplyStreamID(c,&startid);\n\n            /* End. */\n            raxSeek(&ri,\"$\",NULL,0);\n            raxNext(&ri);\n            streamDecodeID(ri.key,&endid);\n            addReplyStreamID(c,&endid);\n            raxStop(&ri);\n\n            /* Consumers with pending messages. */\n            raxStart(&ri,group->consumers);\n            raxSeek(&ri,\"^\",NULL,0);\n            void *arraylen_ptr = addReplyDeferredLen(c);\n            size_t arraylen = 0;\n            while(raxNext(&ri)) {\n                streamConsumer *consumer = ri.data;\n                if (raxSize(consumer->pel) == 0) continue;\n                addReplyArrayLen(c,2);\n                addReplyBulkCBuffer(c,ri.key,ri.key_len);\n                addReplyBulkLongLong(c,raxSize(consumer->pel));\n                arraylen++;\n            }\n            setDeferredArrayLen(c,arraylen_ptr,arraylen);\n            raxStop(&ri);\n        }\n    } else { /* <start>, <stop> and <count> provided, return actual pending entries (not just info) */\n        streamConsumer *consumer = NULL;\n        if (consumername) {\n            consumer = streamLookupConsumer(group,consumername->ptr,SLC_NO_REFRESH);\n\n            /* If a consumer name was mentioned but it does not exist, we can\n             * just return an empty array. */\n            if (consumer == NULL) {\n                addReplyArrayLen(c,0);\n                return;\n            }\n        }\n\n        rax *pel = consumer ? consumer->pel : group->pel;\n        unsigned char startkey[sizeof(streamID)];\n        unsigned char endkey[sizeof(streamID)];\n        raxIterator ri;\n        mstime_t now = mstime();\n\n        streamEncodeID(startkey,&startid);\n        streamEncodeID(endkey,&endid);\n        raxStart(&ri,pel);\n        raxSeek(&ri,\">=\",startkey,sizeof(startkey));\n        void *arraylen_ptr = addReplyDeferredLen(c);\n        size_t arraylen = 0;\n\n        while(count && raxNext(&ri) && memcmp(ri.key,endkey,ri.key_len) <= 0) {\n            streamNACK *nack = ri.data;\n\n            if (minidle) {\n                mstime_t this_idle = now - nack->delivery_time;\n                if (this_idle < minidle) continue;\n            }\n\n            arraylen++;\n            count--;\n            addReplyArrayLen(c,4);\n\n            /* Entry ID. */\n            streamID id;\n            streamDecodeID(ri.key,&id);\n            addReplyStreamID(c,&id);\n\n            /* Consumer name. */\n            addReplyBulkCBuffer(c,nack->consumer->name,\n                                sdslen(nack->consumer->name));\n\n            /* Milliseconds elapsed since last delivery. */\n            mstime_t elapsed = now - nack->delivery_time;\n            if (elapsed < 0) elapsed = 0;\n            addReplyLongLong(c,elapsed);\n\n            /* Number of deliveries. */\n            addReplyLongLong(c,nack->delivery_count);\n        }\n        raxStop(&ri);\n        setDeferredArrayLen(c,arraylen_ptr,arraylen);\n    }\n}\n\n/* XCLAIM <key> <group> <consumer> <min-idle-time> <ID-1> <ID-2>\n *        [IDLE <milliseconds>] [TIME <mstime>] [RETRYCOUNT <count>]\n *        [FORCE] [JUSTID]\n *\n * Gets ownership of one or multiple messages in the Pending Entries List\n * of a given stream consumer group.\n *\n * If the message ID (among the specified ones) exists, and its idle\n * time greater or equal to <min-idle-time>, then the message new owner\n * becomes the specified <consumer>. If the minimum idle time specified\n * is zero, messages are claimed regardless of their idle time.\n *\n * All the messages that cannot be found inside the pending entries list\n * are ignored, but in case the FORCE option is used. In that case we\n * create the NACK (representing a not yet acknowledged message) entry in\n * the consumer group PEL.\n *\n * This command creates the consumer as side effect if it does not yet\n * exists. Moreover the command reset the idle time of the message to 0,\n * even if by using the IDLE or TIME options, the user can control the\n * new idle time.\n *\n * The options at the end can be used in order to specify more attributes\n * to set in the representation of the pending message:\n *\n * 1. IDLE <ms>:\n *      Set the idle time (last time it was delivered) of the message.\n *      If IDLE is not specified, an IDLE of 0 is assumed, that is,\n *      the time count is reset because the message has now a new\n *      owner trying to process it.\n *\n * 2. TIME <ms-unix-time>:\n *      This is the same as IDLE but instead of a relative amount of\n *      milliseconds, it sets the idle time to a specific unix time\n *      (in milliseconds). This is useful in order to rewrite the AOF\n *      file generating XCLAIM commands.\n *\n * 3. RETRYCOUNT <count>:\n *      Set the retry counter to the specified value. This counter is\n *      incremented every time a message is delivered again. Normally\n *      XCLAIM does not alter this counter, which is just served to clients\n *      when the XPENDING command is called: this way clients can detect\n *      anomalies, like messages that are never processed for some reason\n *      after a big number of delivery attempts.\n *\n * 4. FORCE:\n *      Creates the pending message entry in the PEL even if certain\n *      specified IDs are not already in the PEL assigned to a different\n *      client. However the message must be exist in the stream, otherwise\n *      the IDs of non existing messages are ignored.\n *\n * 5. JUSTID:\n *      Return just an array of IDs of messages successfully claimed,\n *      without returning the actual message.\n *\n * 6. LASTID <id>:\n *      Update the consumer group last ID with the specified ID if the\n *      current last ID is smaller than the provided one.\n *      This is used for replication / AOF, so that when we read from a\n *      consumer group, the XCLAIM that gets propagated to give ownership\n *      to the consumer, is also used in order to update the group current\n *      ID.\n *\n * The command returns an array of messages that the user\n * successfully claimed, so that the caller is able to understand\n * what messages it is now in charge of. */\nvoid xclaimCommand(client *c) {\n    streamCG *group = NULL;\n    robj *o = lookupKeyRead(c->db,c->argv[1]);\n    long long minidle; /* Minimum idle time argument. */\n    long long retrycount = -1;   /* -1 means RETRYCOUNT option not given. */\n    mstime_t deliverytime = -1;  /* -1 means IDLE/TIME options not given. */\n    int force = 0;\n    int justid = 0;\n\n    if (o) {\n        if (checkType(c,o,OBJ_STREAM)) return; /* Type error. */\n        group = streamLookupCG(o->ptr,c->argv[2]->ptr);\n    }\n\n    /* No key or group? Send an error given that the group creation\n     * is mandatory. */\n    if (o == NULL || group == NULL) {\n        addReplyErrorFormat(c,\"-NOGROUP No such key '%s' or \"\n                              \"consumer group '%s'\", (char*)c->argv[1]->ptr,\n                              (char*)c->argv[2]->ptr);\n        return;\n    }\n\n    if (getLongLongFromObjectOrReply(c,c->argv[4],&minidle,\n        \"Invalid min-idle-time argument for XCLAIM\")\n        != C_OK) return;\n    if (minidle < 0) minidle = 0;\n\n    /* Start parsing the IDs, so that we abort ASAP if there is a syntax\n     * error: the return value of this command cannot be an error in case\n     * the client successfully claimed some message, so it should be\n     * executed in a \"all or nothing\" fashion. */\n    int j;\n    streamID static_ids[STREAMID_STATIC_VECTOR_LEN];\n    streamID *ids = static_ids;\n    int id_count = c->argc-5;\n    if (id_count > STREAMID_STATIC_VECTOR_LEN)\n        ids = zmalloc(sizeof(streamID)*id_count);\n    for (j = 5; j < c->argc; j++) {\n        if (streamParseStrictIDOrReply(NULL,c->argv[j],&ids[j-5],0,NULL) != C_OK) break;\n    }\n    int last_id_arg = j-1; /* Next time we iterate the IDs we now the range. */\n\n    /* If we stopped because some IDs cannot be parsed, perhaps they\n     * are trailing options. */\n    mstime_t now = mstime();\n    streamID last_id = {0,0};\n    int propagate_last_id = 0;\n    for (; j < c->argc; j++) {\n        int moreargs = (c->argc-1) - j; /* Number of additional arguments. */\n        char *opt = c->argv[j]->ptr;\n        if (!strcasecmp(opt,\"FORCE\")) {\n            force = 1;\n        } else if (!strcasecmp(opt,\"JUSTID\")) {\n            justid = 1;\n        } else if (!strcasecmp(opt,\"IDLE\") && moreargs) {\n            j++;\n            if (getLongLongFromObjectOrReply(c,c->argv[j],&deliverytime,\n                \"Invalid IDLE option argument for XCLAIM\")\n                != C_OK) goto cleanup;\n            deliverytime = now - deliverytime;\n        } else if (!strcasecmp(opt,\"TIME\") && moreargs) {\n            j++;\n            if (getLongLongFromObjectOrReply(c,c->argv[j],&deliverytime,\n                \"Invalid TIME option argument for XCLAIM\")\n                != C_OK) goto cleanup;\n        } else if (!strcasecmp(opt,\"RETRYCOUNT\") && moreargs) {\n            j++;\n            if (getLongLongFromObjectOrReply(c,c->argv[j],&retrycount,\n                \"Invalid RETRYCOUNT option argument for XCLAIM\")\n                != C_OK) goto cleanup;\n        } else if (!strcasecmp(opt,\"LASTID\") && moreargs) {\n            j++;\n            if (streamParseStrictIDOrReply(c,c->argv[j],&last_id,0,NULL) != C_OK) goto cleanup;\n        } else {\n            addReplyErrorFormat(c,\"Unrecognized XCLAIM option '%s'\",opt);\n            goto cleanup;\n        }\n    }\n\n    if (streamCompareID(&last_id,&group->last_id) > 0) {\n        group->last_id = last_id;\n        propagate_last_id = 1;\n    }\n\n    if (deliverytime != -1) {\n        /* If a delivery time was passed, either with IDLE or TIME, we\n         * do some sanity check on it, and set the deliverytime to now\n         * (which is a sane choice usually) if the value is bogus.\n         * To raise an error here is not wise because clients may compute\n         * the idle time doing some math starting from their local time,\n         * and this is not a good excuse to fail in case, for instance,\n         * the computer time is a bit in the future from our POV. */\n        if (deliverytime < 0 || deliverytime > now) deliverytime = now;\n    } else {\n        /* If no IDLE/TIME option was passed, we want the last delivery\n         * time to be now, so that the idle time of the message will be\n         * zero. */\n        deliverytime = now;\n    }\n\n    /* Do the actual claiming. */\n    streamConsumer *consumer = NULL;\n    void *arraylenptr = addReplyDeferredLen(c);\n    size_t arraylen = 0;\n    sds name = c->argv[3]->ptr;\n    for (int j = 5; j <= last_id_arg; j++) {\n        streamID id = ids[j-5];\n        unsigned char buf[sizeof(streamID)];\n        streamEncodeID(buf,&id);\n\n        /* Lookup the ID in the group PEL. */\n        streamNACK *nack = raxFind(group->pel,buf,sizeof(buf));\n\n        /* Item must exist for us to transfer it to another consumer. */\n        if (!streamEntryExists(o->ptr,&id)) {\n            /* Clear this entry from the PEL, it no longer exists */\n            if (nack != raxNotFound) {\n                /* Propagate this change (we are going to delete the NACK). */\n                streamPropagateXCLAIM(c,c->argv[1],group,c->argv[2],c->argv[j],nack);\n                propagate_last_id = 0; /* Will be propagated by XCLAIM itself. */\n                server.dirty++;\n                /* Release the NACK */\n                raxRemove(group->pel,buf,sizeof(buf),NULL);\n                raxRemove(nack->consumer->pel,buf,sizeof(buf),NULL);\n                streamFreeNACK(nack);\n            }\n            continue;\n        }\n\n        /* If FORCE is passed, let's check if at least the entry\n         * exists in the Stream. In such case, we'll create a new\n         * entry in the PEL from scratch, so that XCLAIM can also\n         * be used to create entries in the PEL. Useful for AOF\n         * and replication of consumer groups. */\n        if (force && nack == raxNotFound) {\n            /* Create the NACK. */\n            nack = streamCreateNACK(NULL);\n            raxInsert(group->pel,buf,sizeof(buf),nack,NULL);\n        }\n\n        if (nack != raxNotFound) {\n            /* We need to check if the minimum idle time requested\n             * by the caller is satisfied by this entry.\n             *\n             * Note that the nack could be created by FORCE, in this\n             * case there was no pre-existing entry and minidle should\n             * be ignored, but in that case nack->consumer is NULL. */\n            if (nack->consumer && minidle) {\n                mstime_t this_idle = now - nack->delivery_time;\n                if (this_idle < minidle) continue;\n            }\n\n            if (consumer == NULL &&\n                (consumer = streamLookupConsumer(group,name,SLC_DEFAULT)) == NULL)\n            {\n                consumer = streamCreateConsumer(group,name,c->argv[1],c->db->id,SCC_DEFAULT);\n            }\n            if (nack->consumer != consumer) {\n                /* Remove the entry from the old consumer.\n                 * Note that nack->consumer is NULL if we created the\n                 * NACK above because of the FORCE option. */\n                if (nack->consumer)\n                    raxRemove(nack->consumer->pel,buf,sizeof(buf),NULL);\n            }\n            nack->delivery_time = deliverytime;\n            /* Set the delivery attempts counter if given, otherwise\n             * autoincrement unless JUSTID option provided */\n            if (retrycount >= 0) {\n                nack->delivery_count = retrycount;\n            } else if (!justid) {\n                nack->delivery_count++;\n            }\n            if (nack->consumer != consumer) {\n                /* Add the entry in the new consumer local PEL. */\n                raxInsert(consumer->pel,buf,sizeof(buf),nack,NULL);\n                nack->consumer = consumer;\n            }\n            /* Send the reply for this entry. */\n            if (justid) {\n                addReplyStreamID(c,&id);\n            } else {\n                serverAssert(streamReplyWithRange(c,o->ptr,&id,&id,1,0,NULL,NULL,STREAM_RWR_RAWENTRIES,NULL) == 1);\n            }\n            arraylen++;\n\n            /* Propagate this change. */\n            streamPropagateXCLAIM(c,c->argv[1],group,c->argv[2],c->argv[j],nack);\n            propagate_last_id = 0; /* Will be propagated by XCLAIM itself. */\n            server.dirty++;\n        }\n    }\n    if (propagate_last_id) {\n        streamPropagateGroupID(c,c->argv[1],group,c->argv[2]);\n        server.dirty++;\n    }\n    setDeferredArrayLen(c,arraylenptr,arraylen);\n    preventCommandPropagation(c);\ncleanup:\n    if (ids != static_ids) zfree(ids);\n}\n\n/* XAUTOCLAIM <key> <group> <consumer> <min-idle-time> <start> [COUNT <count>] [JUSTID]\n *\n * Gets ownership of one or multiple messages in the Pending Entries List\n * of a given stream consumer group.\n *\n * For each PEL entry, if its idle time greater or equal to <min-idle-time>,\n * then the message new owner becomes the specified <consumer>.\n * If the minimum idle time specified is zero, messages are claimed\n * regardless of their idle time.\n *\n * This command creates the consumer as side effect if it does not yet\n * exists. Moreover the command reset the idle time of the message to 0.\n *\n * The command returns an array of messages that the user\n * successfully claimed, so that the caller is able to understand\n * what messages it is now in charge of. */\nvoid xautoclaimCommand(client *c) {\n    streamCG *group = NULL;\n    robj *o = lookupKeyRead(c->db,c->argv[1]);\n    long long minidle; /* Minimum idle time argument, in milliseconds. */\n    long count = 100; /* Maximum entries to claim. */\n    streamID startid;\n    int startex;\n    int justid = 0;\n\n    /* Parse idle/start/end/count arguments ASAP if needed, in order to report\n     * syntax errors before any other error. */\n    if (getLongLongFromObjectOrReply(c,c->argv[4],&minidle,\"Invalid min-idle-time argument for XAUTOCLAIM\") != C_OK)\n        return;\n    if (minidle < 0) minidle = 0;\n\n    if (streamParseIntervalIDOrReply(c,c->argv[5],&startid,&startex,0) != C_OK)\n        return;\n    if (startex && streamIncrID(&startid) != C_OK) {\n        addReplyError(c,\"invalid start ID for the interval\");\n        return;\n    }\n\n    int j = 6; /* options start at argv[6] */\n    while(j < c->argc) {\n        int moreargs = (c->argc-1) - j; /* Number of additional arguments. */\n        char *opt = c->argv[j]->ptr;\n        if (!strcasecmp(opt,\"COUNT\") && moreargs) {\n            if (getRangeLongFromObjectOrReply(c,c->argv[j+1],1,LONG_MAX,&count,\"COUNT must be > 0\") != C_OK)\n                return;\n            j++;\n        } else if (!strcasecmp(opt,\"JUSTID\")) {\n            justid = 1;\n        } else {\n            addReplyErrorObject(c,shared.syntaxerr);\n            return;\n        }\n        j++;\n    }\n\n    if (o) {\n        if (checkType(c,o,OBJ_STREAM))\n            return; /* Type error. */\n        group = streamLookupCG(o->ptr,c->argv[2]->ptr);\n    }\n\n    /* No key or group? Send an error given that the group creation\n     * is mandatory. */\n    if (o == NULL || group == NULL) {\n        addReplyErrorFormat(c,\"-NOGROUP No such key '%s' or consumer group '%s'\",\n                            (char*)c->argv[1]->ptr,\n                            (char*)c->argv[2]->ptr);\n        return;\n    }\n\n    /* Do the actual claiming. */\n    streamConsumer *consumer = NULL;\n    long long attempts = count*10;\n\n    addReplyArrayLen(c, 3); /* We add another reply later */\n    void *endidptr = addReplyDeferredLen(c); /* reply[0] */\n    void *arraylenptr = addReplyDeferredLen(c); /* reply[1] */\n\n    unsigned char startkey[sizeof(streamID)];\n    streamEncodeID(startkey,&startid);\n    raxIterator ri;\n    raxStart(&ri,group->pel);\n    raxSeek(&ri,\">=\",startkey,sizeof(startkey));\n    size_t arraylen = 0;\n    mstime_t now = mstime();\n    sds name = c->argv[3]->ptr;\n    streamID *deleted_ids = zmalloc(count * sizeof(streamID));\n    int deleted_id_num = 0;\n    while (attempts-- && count && raxNext(&ri)) {\n        streamNACK *nack = ri.data;\n\n        streamID id;\n        streamDecodeID(ri.key, &id);\n\n        /* Item must exist for us to transfer it to another consumer. */\n        if (!streamEntryExists(o->ptr,&id)) {\n            /* Propagate this change (we are going to delete the NACK). */\n            robj *idstr = createObjectFromStreamID(&id);\n            streamPropagateXCLAIM(c,c->argv[1],group,c->argv[2],idstr,nack);\n            decrRefCount(idstr);\n            server.dirty++;\n            /* Clear this entry from the PEL, it no longer exists */\n            raxRemove(group->pel,ri.key,ri.key_len,NULL);\n            raxRemove(nack->consumer->pel,ri.key,ri.key_len,NULL);\n            streamFreeNACK(nack);\n            /* Remember the ID for later */\n            deleted_ids[deleted_id_num++] = id;\n            raxSeek(&ri,\">=\",ri.key,ri.key_len);\n            continue;\n        }\n\n        if (minidle) {\n            mstime_t this_idle = now - nack->delivery_time;\n            if (this_idle < minidle)\n                continue;\n        }\n\n        if (consumer == NULL &&\n            (consumer = streamLookupConsumer(group,name,SLC_DEFAULT)) == NULL)\n        {\n            consumer = streamCreateConsumer(group,name,c->argv[1],c->db->id,SCC_DEFAULT);\n        }\n        if (nack->consumer != consumer) {\n            /* Remove the entry from the old consumer.\n             * Note that nack->consumer is NULL if we created the\n             * NACK above because of the FORCE option. */\n            if (nack->consumer)\n                raxRemove(nack->consumer->pel,ri.key,ri.key_len,NULL);\n        }\n\n        /* Update the consumer and idle time. */\n        nack->delivery_time = now;\n        /* Increment the delivery attempts counter unless JUSTID option provided */\n        if (!justid)\n            nack->delivery_count++;\n\n        if (nack->consumer != consumer) {\n            /* Add the entry in the new consumer local PEL. */\n            raxInsert(consumer->pel,ri.key,ri.key_len,nack,NULL);\n            nack->consumer = consumer;\n        }\n\n        /* Send the reply for this entry. */\n        if (justid) {\n            addReplyStreamID(c,&id);\n        } else {\n            serverAssert(streamReplyWithRange(c,o->ptr,&id,&id,1,0,NULL,NULL,STREAM_RWR_RAWENTRIES,NULL) == 1);\n        }\n        arraylen++;\n        count--;\n\n        /* Propagate this change. */\n        robj *idstr = createObjectFromStreamID(&id);\n        streamPropagateXCLAIM(c,c->argv[1],group,c->argv[2],idstr,nack);\n        decrRefCount(idstr);\n        server.dirty++;\n    }\n\n    /* We need to return the next entry as a cursor for the next XAUTOCLAIM call */\n    raxNext(&ri);\n\n    streamID endid;\n    if (raxEOF(&ri)) {\n        endid.ms = endid.seq = 0;\n    } else {\n        streamDecodeID(ri.key, &endid);\n    }\n    raxStop(&ri);\n\n    setDeferredArrayLen(c,arraylenptr,arraylen);\n    setDeferredReplyStreamID(c,endidptr,&endid);\n\n    addReplyArrayLen(c, deleted_id_num); /* reply[2] */\n    for (int i = 0; i < deleted_id_num; i++) {\n        addReplyStreamID(c, &deleted_ids[i]);\n    }\n    zfree(deleted_ids);\n\n    preventCommandPropagation(c);\n}\n\n/* XDEL <key> [<ID1> <ID2> ... <IDN>]\n *\n * Removes the specified entries from the stream. Returns the number\n * of items actually deleted, that may be different from the number\n * of IDs passed in case certain IDs do not exist. */\nvoid xdelCommand(client *c) {\n    robj *o;\n\n    if ((o = lookupKeyWriteOrReply(c,c->argv[1],shared.czero)) == NULL\n        || checkType(c,o,OBJ_STREAM)) return;\n    stream *s = o->ptr;\n\n    /* We need to sanity check the IDs passed to start. Even if not\n     * a big issue, it is not great that the command is only partially\n     * executed because at some point an invalid ID is parsed. */\n    streamID static_ids[STREAMID_STATIC_VECTOR_LEN];\n    streamID *ids = static_ids;\n    int id_count = c->argc-2;\n    if (id_count > STREAMID_STATIC_VECTOR_LEN)\n        ids = zmalloc(sizeof(streamID)*id_count);\n    for (int j = 2; j < c->argc; j++) {\n        if (streamParseStrictIDOrReply(c,c->argv[j],&ids[j-2],0,NULL) != C_OK) goto cleanup;\n    }\n\n    /* Actually apply the command. */\n    int deleted = 0;\n    int first_entry = 0;\n    for (int j = 2; j < c->argc; j++) {\n        streamID *id = &ids[j-2];\n        if (streamDeleteItem(s,id)) {\n            /* We want to know if the first entry in the stream was deleted\n             * so we can later set the new one. */\n            if (streamCompareID(id,&s->first_id) == 0) {\n                first_entry = 1;\n            }\n            /* Update the stream's maximal tombstone if needed. */\n            if (streamCompareID(id,&s->max_deleted_entry_id) > 0) {\n                s->max_deleted_entry_id = *id;\n            }\n            deleted++;\n        };\n    }\n\n    /* Update the stream's first ID. */\n    if (deleted) {\n        if (s->length == 0) {\n            s->first_id.ms = 0;\n            s->first_id.seq = 0;\n        } else if (first_entry) {\n            streamGetEdgeID(s,1,1,&s->first_id);\n        }\n    }\n\n    /* Propagate the write if needed. */\n    if (deleted) {\n        signalModifiedKey(c,c->db,c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_STREAM,\"xdel\",c->argv[1],c->db->id);\n        server.dirty += deleted;\n    }\n    addReplyLongLong(c,deleted);\ncleanup:\n    if (ids != static_ids) zfree(ids);\n}\n\n/* General form: XTRIM <key> [... options ...]\n *\n * List of options:\n *\n * Trim strategies:\n *\n * MAXLEN [~|=] <count>     -- Trim so that the stream will be capped at\n *                             the specified length. Use ~ before the\n *                             count in order to demand approximated trimming\n *                             (like XADD MAXLEN option).\n * MINID [~|=] <id>         -- Trim so that the stream will not contain entries\n *                             with IDs smaller than 'id'. Use ~ before the\n *                             count in order to demand approximated trimming\n *                             (like XADD MINID option).\n *\n * Other options:\n *\n * LIMIT <entries>          -- The maximum number of entries to trim.\n *                             0 means unlimited. Unless specified, it is set\n *                             to a default of 100*server.stream_node_max_entries,\n *                             and that's in order to keep the trimming time sane.\n *                             Has meaning only if `~` was provided.\n */\nvoid xtrimCommand(client *c) {\n    robj *o;\n\n    /* Argument parsing. */\n    streamAddTrimArgs parsed_args;\n    if (streamParseAddOrTrimArgsOrReply(c, &parsed_args, 0) < 0)\n        return; /* streamParseAddOrTrimArgsOrReply already replied. */\n\n    /* If the key does not exist, we are ok returning zero, that is, the\n     * number of elements removed from the stream. */\n    if ((o = lookupKeyWriteOrReply(c,c->argv[1],shared.czero)) == NULL\n        || checkType(c,o,OBJ_STREAM)) return;\n    stream *s = o->ptr;\n\n    /* Perform the trimming. */\n    int64_t deleted = streamTrim(s, &parsed_args);\n    if (deleted) {\n        notifyKeyspaceEvent(NOTIFY_STREAM,\"xtrim\",c->argv[1],c->db->id);\n        if (parsed_args.approx_trim) {\n            /* In case our trimming was limited (by LIMIT or by ~) we must\n             * re-write the relevant trim argument to make sure there will be\n             * no inconsistencies in AOF loading or in the replica.\n             * It's enough to check only args->approx because there is no\n             * way LIMIT is given without the ~ option. */\n            streamRewriteApproxSpecifier(c,parsed_args.trim_strategy_arg_idx-1);\n            streamRewriteTrimArgument(c,s,parsed_args.trim_strategy,parsed_args.trim_strategy_arg_idx);\n        }\n\n        /* Propagate the write. */\n        signalModifiedKey(c, c->db,c->argv[1]);\n        server.dirty += deleted;\n    }\n    addReplyLongLong(c,deleted);\n}\n\n/* Helper function for xinfoCommand.\n * Handles the variants of XINFO STREAM */\nvoid xinfoReplyWithStreamInfo(client *c, stream *s) {\n    int full = 1;\n    long long count = 10; /* Default COUNT is 10 so we don't block the server */\n    robj **optv = c->argv + 3; /* Options start after XINFO STREAM <key> */\n    int optc = c->argc - 3;\n\n    /* Parse options. */\n    if (optc == 0) {\n        full = 0;\n    } else {\n        /* Valid options are [FULL] or [FULL COUNT <count>] */\n        if (optc != 1 && optc != 3) {\n            addReplySubcommandSyntaxError(c);\n            return;\n        }\n\n        /* First option must be \"FULL\" */\n        if (strcasecmp(optv[0]->ptr,\"full\")) {\n            addReplySubcommandSyntaxError(c);\n            return;\n        }\n\n        if (optc == 3) {\n            /* First option must be \"FULL\" */\n            if (strcasecmp(optv[1]->ptr,\"count\")) {\n                addReplySubcommandSyntaxError(c);\n                return;\n            }\n            if (getLongLongFromObjectOrReply(c,optv[2],&count,NULL) == C_ERR)\n                return;\n            if (count < 0) count = 10;\n        }\n    }\n\n    addReplyMapLen(c,full ? 9 : 10);\n    addReplyBulkCString(c,\"length\");\n    addReplyLongLong(c,s->length);\n    addReplyBulkCString(c,\"radix-tree-keys\");\n    addReplyLongLong(c,raxSize(s->rax));\n    addReplyBulkCString(c,\"radix-tree-nodes\");\n    addReplyLongLong(c,s->rax->numnodes);\n    addReplyBulkCString(c,\"last-generated-id\");\n    addReplyStreamID(c,&s->last_id);\n    addReplyBulkCString(c,\"max-deleted-entry-id\");\n    addReplyStreamID(c,&s->max_deleted_entry_id);\n    addReplyBulkCString(c,\"entries-added\");\n    addReplyLongLong(c,s->entries_added);\n    addReplyBulkCString(c,\"recorded-first-entry-id\");\n    addReplyStreamID(c,&s->first_id);\n\n    if (!full) {\n        /* XINFO STREAM <key> */\n\n        addReplyBulkCString(c,\"groups\");\n        addReplyLongLong(c,s->cgroups ? raxSize(s->cgroups) : 0);\n\n        /* To emit the first/last entry we use streamReplyWithRange(). */\n        int emitted;\n        streamID start, end;\n        start.ms = start.seq = 0;\n        end.ms = end.seq = UINT64_MAX;\n        addReplyBulkCString(c,\"first-entry\");\n        emitted = streamReplyWithRange(c,s,&start,&end,1,0,NULL,NULL,\n                                       STREAM_RWR_RAWENTRIES,NULL);\n        if (!emitted) addReplyNull(c);\n        addReplyBulkCString(c,\"last-entry\");\n        emitted = streamReplyWithRange(c,s,&start,&end,1,1,NULL,NULL,\n                                       STREAM_RWR_RAWENTRIES,NULL);\n        if (!emitted) addReplyNull(c);\n    } else {\n        /* XINFO STREAM <key> FULL [COUNT <count>] */\n\n        /* Stream entries */\n        addReplyBulkCString(c,\"entries\");\n        streamReplyWithRange(c,s,NULL,NULL,count,0,NULL,NULL,0,NULL);\n\n        /* Consumer groups */\n        addReplyBulkCString(c,\"groups\");\n        if (s->cgroups == NULL) {\n            addReplyArrayLen(c,0);\n        } else {\n            addReplyArrayLen(c,raxSize(s->cgroups));\n            raxIterator ri_cgroups;\n            raxStart(&ri_cgroups,s->cgroups);\n            raxSeek(&ri_cgroups,\"^\",NULL,0);\n            while(raxNext(&ri_cgroups)) {\n                streamCG *cg = ri_cgroups.data;\n                addReplyMapLen(c,7);\n\n                /* Name */\n                addReplyBulkCString(c,\"name\");\n                addReplyBulkCBuffer(c,ri_cgroups.key,ri_cgroups.key_len);\n\n                /* Last delivered ID */\n                addReplyBulkCString(c,\"last-delivered-id\");\n                addReplyStreamID(c,&cg->last_id);\n\n                /* Read counter of the last delivered ID */\n                addReplyBulkCString(c,\"entries-read\");\n                if (cg->entries_read != SCG_INVALID_ENTRIES_READ) {\n                    addReplyLongLong(c,cg->entries_read);\n                } else {\n                    addReplyNull(c);\n                }\n\n                /* Group lag */\n                addReplyBulkCString(c,\"lag\");\n                streamReplyWithCGLag(c,s,cg);\n\n                /* Group PEL count */\n                addReplyBulkCString(c,\"pel-count\");\n                addReplyLongLong(c,raxSize(cg->pel));\n\n                /* Group PEL */\n                addReplyBulkCString(c,\"pending\");\n                long long arraylen_cg_pel = 0;\n                void *arrayptr_cg_pel = addReplyDeferredLen(c);\n                raxIterator ri_cg_pel;\n                raxStart(&ri_cg_pel,cg->pel);\n                raxSeek(&ri_cg_pel,\"^\",NULL,0);\n                while(raxNext(&ri_cg_pel) && (!count || arraylen_cg_pel < count)) {\n                    streamNACK *nack = ri_cg_pel.data;\n                    addReplyArrayLen(c,4);\n\n                    /* Entry ID. */\n                    streamID id;\n                    streamDecodeID(ri_cg_pel.key,&id);\n                    addReplyStreamID(c,&id);\n\n                    /* Consumer name. */\n                    serverAssert(nack->consumer); /* assertion for valgrind (avoid NPD) */\n                    addReplyBulkCBuffer(c,nack->consumer->name,\n                                        sdslen(nack->consumer->name));\n\n                    /* Last delivery. */\n                    addReplyLongLong(c,nack->delivery_time);\n\n                    /* Number of deliveries. */\n                    addReplyLongLong(c,nack->delivery_count);\n\n                    arraylen_cg_pel++;\n                }\n                setDeferredArrayLen(c,arrayptr_cg_pel,arraylen_cg_pel);\n                raxStop(&ri_cg_pel);\n\n                /* Consumers */\n                addReplyBulkCString(c,\"consumers\");\n                addReplyArrayLen(c,raxSize(cg->consumers));\n                raxIterator ri_consumers;\n                raxStart(&ri_consumers,cg->consumers);\n                raxSeek(&ri_consumers,\"^\",NULL,0);\n                while(raxNext(&ri_consumers)) {\n                    streamConsumer *consumer = ri_consumers.data;\n                    addReplyMapLen(c,4);\n\n                    /* Consumer name */\n                    addReplyBulkCString(c,\"name\");\n                    addReplyBulkCBuffer(c,consumer->name,sdslen(consumer->name));\n\n                    /* Seen-time */\n                    addReplyBulkCString(c,\"seen-time\");\n                    addReplyLongLong(c,consumer->seen_time);\n\n                    /* Consumer PEL count */\n                    addReplyBulkCString(c,\"pel-count\");\n                    addReplyLongLong(c,raxSize(consumer->pel));\n\n                    /* Consumer PEL */\n                    addReplyBulkCString(c,\"pending\");\n                    long long arraylen_cpel = 0;\n                    void *arrayptr_cpel = addReplyDeferredLen(c);\n                    raxIterator ri_cpel;\n                    raxStart(&ri_cpel,consumer->pel);\n                    raxSeek(&ri_cpel,\"^\",NULL,0);\n                    while(raxNext(&ri_cpel) && (!count || arraylen_cpel < count)) {\n                        streamNACK *nack = ri_cpel.data;\n                        addReplyArrayLen(c,3);\n\n                        /* Entry ID. */\n                        streamID id;\n                        streamDecodeID(ri_cpel.key,&id);\n                        addReplyStreamID(c,&id);\n\n                        /* Last delivery. */\n                        addReplyLongLong(c,nack->delivery_time);\n\n                        /* Number of deliveries. */\n                        addReplyLongLong(c,nack->delivery_count);\n\n                        arraylen_cpel++;\n                    }\n                    setDeferredArrayLen(c,arrayptr_cpel,arraylen_cpel);\n                    raxStop(&ri_cpel);\n                }\n                raxStop(&ri_consumers);\n            }\n            raxStop(&ri_cgroups);\n        }\n    }\n}\n\n/* XINFO CONSUMERS <key> <group>\n * XINFO GROUPS <key>\n * XINFO STREAM <key> [FULL [COUNT <count>]]\n * XINFO HELP. */\nvoid xinfoCommand(client *c) {\n    stream *s = NULL;\n    char *opt;\n    robj *key;\n\n    /* HELP is special. Handle it ASAP. */\n    if (!strcasecmp(c->argv[1]->ptr,\"HELP\")) {\n        if (c->argc != 2) {\n            addReplySubcommandSyntaxError(c);\n            return;\n        }\n\n        const char *help[] = {\n\"CONSUMERS <key> <groupname>\",\n\"    Show consumers of <groupname>.\",\n\"GROUPS <key>\",\n\"    Show the stream consumer groups.\",\n\"STREAM <key> [FULL [COUNT <count>]\",\n\"    Show information about the stream.\",\nNULL\n        };\n        addReplyHelp(c, help);\n        return;\n    } else if (c->argc < 3) {\n        addReplySubcommandSyntaxError(c);\n        return;\n    }\n\n    /* With the exception of HELP handled before any other sub commands, all\n     * the ones are in the form of \"<subcommand> <key>\". */\n    opt = c->argv[1]->ptr;\n    key = c->argv[2];\n\n    /* Lookup the key now, this is common for all the subcommands but HELP. */\n    robj *o = lookupKeyReadOrReply(c,key,shared.nokeyerr);\n    if (o == NULL || checkType(c,o,OBJ_STREAM)) return;\n    s = o->ptr;\n\n    /* Dispatch the different subcommands. */\n    if (!strcasecmp(opt,\"CONSUMERS\") && c->argc == 4) {\n        /* XINFO CONSUMERS <key> <group>. */\n        streamCG *cg = streamLookupCG(s,c->argv[3]->ptr);\n        if (cg == NULL) {\n            addReplyErrorFormat(c, \"-NOGROUP No such consumer group '%s' \"\n                                   \"for key name '%s'\",\n                                   (char*)c->argv[3]->ptr, (char*)key->ptr);\n            return;\n        }\n\n        addReplyArrayLen(c,raxSize(cg->consumers));\n        raxIterator ri;\n        raxStart(&ri,cg->consumers);\n        raxSeek(&ri,\"^\",NULL,0);\n        mstime_t now = mstime();\n        while(raxNext(&ri)) {\n            streamConsumer *consumer = ri.data;\n            mstime_t idle = now - consumer->seen_time;\n            if (idle < 0) idle = 0;\n\n            addReplyMapLen(c,3);\n            addReplyBulkCString(c,\"name\");\n            addReplyBulkCBuffer(c,consumer->name,sdslen(consumer->name));\n            addReplyBulkCString(c,\"pending\");\n            addReplyLongLong(c,raxSize(consumer->pel));\n            addReplyBulkCString(c,\"idle\");\n            addReplyLongLong(c,idle);\n        }\n        raxStop(&ri);\n    } else if (!strcasecmp(opt,\"GROUPS\") && c->argc == 3) {\n        /* XINFO GROUPS <key>. */\n        if (s->cgroups == NULL) {\n            addReplyArrayLen(c,0);\n            return;\n        }\n\n        addReplyArrayLen(c,raxSize(s->cgroups));\n        raxIterator ri;\n        raxStart(&ri,s->cgroups);\n        raxSeek(&ri,\"^\",NULL,0);\n        while(raxNext(&ri)) {\n            streamCG *cg = ri.data;\n            addReplyMapLen(c,6);\n            addReplyBulkCString(c,\"name\");\n            addReplyBulkCBuffer(c,ri.key,ri.key_len);\n            addReplyBulkCString(c,\"consumers\");\n            addReplyLongLong(c,raxSize(cg->consumers));\n            addReplyBulkCString(c,\"pending\");\n            addReplyLongLong(c,raxSize(cg->pel));\n            addReplyBulkCString(c,\"last-delivered-id\");\n            addReplyStreamID(c,&cg->last_id);\n            addReplyBulkCString(c,\"entries-read\");\n            if (cg->entries_read != SCG_INVALID_ENTRIES_READ) {\n                addReplyLongLong(c,cg->entries_read);\n            } else {\n                addReplyNull(c);\n            }\n            addReplyBulkCString(c,\"lag\");\n            streamReplyWithCGLag(c,s,cg);\n        }\n        raxStop(&ri);\n    } else if (!strcasecmp(opt,\"STREAM\")) {\n        /* XINFO STREAM <key> [FULL [COUNT <count>]]. */\n        xinfoReplyWithStreamInfo(c,s);\n    } else {\n        addReplySubcommandSyntaxError(c);\n    }\n}\n\n/* Validate the integrity stream listpack entries structure. Both in term of a\n * valid listpack, but also that the structure of the entries matches a valid\n * stream. return 1 if valid 0 if not valid. */\nint streamValidateListpackIntegrity(unsigned char *lp, size_t size, int deep) {\n    int valid_record;\n    unsigned char *p, *next;\n\n    /* Since we don't want to run validation of all records twice, we'll\n     * run the listpack validation of just the header and do the rest here. */\n    if (!lpValidateIntegrity(lp, size, 0, NULL, NULL))\n        return 0;\n\n    /* In non-deep mode we just validated the listpack header (encoded size) */\n    if (!deep) return 1;\n\n    next = p = lpValidateFirst(lp);\n    if (!lpValidateNext(lp, &next, size)) return 0;\n    if (!p) return 0;\n\n    /* entry count */\n    int64_t entry_count = lpGetIntegerIfValid(p, &valid_record);\n    if (!valid_record) return 0;\n    p = next; if (!lpValidateNext(lp, &next, size)) return 0;\n\n    /* deleted */\n    int64_t deleted_count = lpGetIntegerIfValid(p, &valid_record);\n    if (!valid_record) return 0;\n    p = next; if (!lpValidateNext(lp, &next, size)) return 0;\n\n    /* num-of-fields */\n    int64_t master_fields = lpGetIntegerIfValid(p, &valid_record);\n    if (!valid_record) return 0;\n    p = next; if (!lpValidateNext(lp, &next, size)) return 0;\n\n    /* the field names */\n    for (int64_t j = 0; j < master_fields; j++) {\n        p = next; if (!lpValidateNext(lp, &next, size)) return 0;\n    }\n\n    /* the zero master entry terminator. */\n    int64_t zero = lpGetIntegerIfValid(p, &valid_record);\n    if (!valid_record || zero != 0) return 0;\n    p = next; if (!lpValidateNext(lp, &next, size)) return 0;\n\n    entry_count += deleted_count;\n    while (entry_count--) {\n        if (!p) return 0;\n        int64_t fields = master_fields, extra_fields = 3;\n        int64_t flags = lpGetIntegerIfValid(p, &valid_record);\n        if (!valid_record) return 0;\n        p = next; if (!lpValidateNext(lp, &next, size)) return 0;\n\n        /* entry id */\n        lpGetIntegerIfValid(p, &valid_record);\n        if (!valid_record) return 0;\n        p = next; if (!lpValidateNext(lp, &next, size)) return 0;\n        lpGetIntegerIfValid(p, &valid_record);\n        if (!valid_record) return 0;\n        p = next; if (!lpValidateNext(lp, &next, size)) return 0;\n\n        if (!(flags & STREAM_ITEM_FLAG_SAMEFIELDS)) {\n            /* num-of-fields */\n            fields = lpGetIntegerIfValid(p, &valid_record);\n            if (!valid_record) return 0;\n            p = next; if (!lpValidateNext(lp, &next, size)) return 0;\n\n            /* the field names */\n            for (int64_t j = 0; j < fields; j++) {\n                p = next; if (!lpValidateNext(lp, &next, size)) return 0;\n            }\n\n            extra_fields += fields + 1;\n        }\n\n        /* the values */\n        for (int64_t j = 0; j < fields; j++) {\n            p = next; if (!lpValidateNext(lp, &next, size)) return 0;\n        }\n\n        /* lp-count */\n        int64_t lp_count = lpGetIntegerIfValid(p, &valid_record);\n        if (!valid_record) return 0;\n        if (lp_count != fields + extra_fields) return 0;\n        p = next; if (!lpValidateNext(lp, &next, size)) return 0;\n    }\n\n    if (next)\n        return 0;\n\n    return 1;\n}\n"], "fixing_code": ["/*\n * Copyright (c) 2017, Salvatore Sanfilippo <antirez at gmail dot com>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"server.h\"\n#include \"endianconv.h\"\n#include \"stream.h\"\n\n/* Every stream item inside the listpack, has a flags field that is used to\n * mark the entry as deleted, or having the same field as the \"master\"\n * entry at the start of the listpack> */\n#define STREAM_ITEM_FLAG_NONE 0             /* No special flags. */\n#define STREAM_ITEM_FLAG_DELETED (1<<0)     /* Entry is deleted. Skip it. */\n#define STREAM_ITEM_FLAG_SAMEFIELDS (1<<1)  /* Same fields as master entry. */\n\n/* For stream commands that require multiple IDs\n * when the number of IDs is less than 'STREAMID_STATIC_VECTOR_LEN',\n * avoid malloc allocation.*/\n#define STREAMID_STATIC_VECTOR_LEN 8\n\n/* Max pre-allocation for listpack. This is done to avoid abuse of a user\n * setting stream_node_max_bytes to a huge number. */\n#define STREAM_LISTPACK_MAX_PRE_ALLOCATE 4096\n\n/* Don't let listpacks grow too big, even if the user config allows it.\n * doing so can lead to an overflow (trying to store more than 32bit length\n * into the listpack header), or actually an assertion since lpInsert\n * will return NULL. */\n#define STREAM_LISTPACK_MAX_SIZE (1<<30)\n\nvoid streamFreeCG(streamCG *cg);\nvoid streamFreeNACK(streamNACK *na);\nsize_t streamReplyWithRangeFromConsumerPEL(client *c, stream *s, streamID *start, streamID *end, size_t count, streamConsumer *consumer);\nint streamParseStrictIDOrReply(client *c, robj *o, streamID *id, uint64_t missing_seq, int *seq_given);\nint streamParseIDOrReply(client *c, robj *o, streamID *id, uint64_t missing_seq);\n\n/* -----------------------------------------------------------------------\n * Low level stream encoding: a radix tree of listpacks.\n * ----------------------------------------------------------------------- */\n\n/* Create a new stream data structure. */\nstream *streamNew(void) {\n    stream *s = zmalloc(sizeof(*s));\n    s->rax = raxNew();\n    s->length = 0;\n    s->first_id.ms = 0;\n    s->first_id.seq = 0;\n    s->last_id.ms = 0;\n    s->last_id.seq = 0;\n    s->max_deleted_entry_id.seq = 0;\n    s->max_deleted_entry_id.ms = 0;\n    s->entries_added = 0;\n    s->cgroups = NULL; /* Created on demand to save memory when not used. */\n    return s;\n}\n\n/* Free a stream, including the listpacks stored inside the radix tree. */\nvoid freeStream(stream *s) {\n    raxFreeWithCallback(s->rax,(void(*)(void*))lpFree);\n    if (s->cgroups)\n        raxFreeWithCallback(s->cgroups,(void(*)(void*))streamFreeCG);\n    zfree(s);\n}\n\n/* Return the length of a stream. */\nunsigned long streamLength(const robj *subject) {\n    stream *s = subject->ptr;\n    return s->length;\n}\n\n/* Set 'id' to be its successor stream ID.\n * If 'id' is the maximal possible id, it is wrapped around to 0-0 and a\n * C_ERR is returned. */\nint streamIncrID(streamID *id) {\n    int ret = C_OK;\n    if (id->seq == UINT64_MAX) {\n        if (id->ms == UINT64_MAX) {\n            /* Special case where 'id' is the last possible streamID... */\n            id->ms = id->seq = 0;\n            ret = C_ERR;\n        } else {\n            id->ms++;\n            id->seq = 0;\n        }\n    } else {\n        id->seq++;\n    }\n    return ret;\n}\n\n/* Set 'id' to be its predecessor stream ID.\n * If 'id' is the minimal possible id, it remains 0-0 and a C_ERR is\n * returned. */\nint streamDecrID(streamID *id) {\n    int ret = C_OK;\n    if (id->seq == 0) {\n        if (id->ms == 0) {\n            /* Special case where 'id' is the first possible streamID... */\n            id->ms = id->seq = UINT64_MAX;\n            ret = C_ERR;\n        } else {\n            id->ms--;\n            id->seq = UINT64_MAX;\n        }\n    } else {\n        id->seq--;\n    }\n    return ret;\n}\n\n/* Generate the next stream item ID given the previous one. If the current\n * milliseconds Unix time is greater than the previous one, just use this\n * as time part and start with sequence part of zero. Otherwise we use the\n * previous time (and never go backward) and increment the sequence. */\nvoid streamNextID(streamID *last_id, streamID *new_id) {\n    uint64_t ms = mstime();\n    if (ms > last_id->ms) {\n        new_id->ms = ms;\n        new_id->seq = 0;\n    } else {\n        *new_id = *last_id;\n        streamIncrID(new_id);\n    }\n}\n\n/* This is a helper function for the COPY command.\n * Duplicate a Stream object, with the guarantee that the returned object\n * has the same encoding as the original one.\n *\n * The resulting object always has refcount set to 1 */\nrobj *streamDup(robj *o) {\n    robj *sobj;\n\n    serverAssert(o->type == OBJ_STREAM);\n\n    switch (o->encoding) {\n        case OBJ_ENCODING_STREAM:\n            sobj = createStreamObject();\n            break;\n        default:\n            serverPanic(\"Wrong encoding.\");\n            break;\n    }\n\n    stream *s;\n    stream *new_s;\n    s = o->ptr;\n    new_s = sobj->ptr;\n\n    raxIterator ri;\n    uint64_t rax_key[2];\n    raxStart(&ri, s->rax);\n    raxSeek(&ri, \"^\", NULL, 0);\n    size_t lp_bytes = 0;      /* Total bytes in the listpack. */\n    unsigned char *lp = NULL; /* listpack pointer. */\n    /* Get a reference to the listpack node. */\n    while (raxNext(&ri)) {\n        lp = ri.data;\n        lp_bytes = lpBytes(lp);\n        unsigned char *new_lp = zmalloc(lp_bytes);\n        memcpy(new_lp, lp, lp_bytes);\n        memcpy(rax_key, ri.key, sizeof(rax_key));\n        raxInsert(new_s->rax, (unsigned char *)&rax_key, sizeof(rax_key),\n                  new_lp, NULL);\n    }\n    new_s->length = s->length;\n    new_s->first_id = s->first_id;\n    new_s->last_id = s->last_id;\n    new_s->max_deleted_entry_id = s->max_deleted_entry_id;\n    new_s->entries_added = s->entries_added;\n    raxStop(&ri);\n\n    if (s->cgroups == NULL) return sobj;\n\n    /* Consumer Groups */\n    raxIterator ri_cgroups;\n    raxStart(&ri_cgroups, s->cgroups);\n    raxSeek(&ri_cgroups, \"^\", NULL, 0);\n    while (raxNext(&ri_cgroups)) {\n        streamCG *cg = ri_cgroups.data;\n        streamCG *new_cg = streamCreateCG(new_s, (char *)ri_cgroups.key,\n                                          ri_cgroups.key_len, &cg->last_id,\n                                          cg->entries_read);\n\n        serverAssert(new_cg != NULL);\n\n        /* Consumer Group PEL */\n        raxIterator ri_cg_pel;\n        raxStart(&ri_cg_pel,cg->pel);\n        raxSeek(&ri_cg_pel,\"^\",NULL,0);\n        while(raxNext(&ri_cg_pel)){\n            streamNACK *nack = ri_cg_pel.data;\n            streamNACK *new_nack = streamCreateNACK(NULL);\n            new_nack->delivery_time = nack->delivery_time;\n            new_nack->delivery_count = nack->delivery_count;\n            raxInsert(new_cg->pel, ri_cg_pel.key, sizeof(streamID), new_nack, NULL);\n        }\n        raxStop(&ri_cg_pel);\n\n        /* Consumers */\n        raxIterator ri_consumers;\n        raxStart(&ri_consumers, cg->consumers);\n        raxSeek(&ri_consumers, \"^\", NULL, 0);\n        while (raxNext(&ri_consumers)) {\n            streamConsumer *consumer = ri_consumers.data;\n            streamConsumer *new_consumer;\n            new_consumer = zmalloc(sizeof(*new_consumer));\n            new_consumer->name = sdsdup(consumer->name);\n            new_consumer->pel = raxNew();\n            raxInsert(new_cg->consumers,(unsigned char *)new_consumer->name,\n                        sdslen(new_consumer->name), new_consumer, NULL);\n            new_consumer->seen_time = consumer->seen_time;\n\n            /* Consumer PEL */\n            raxIterator ri_cpel;\n            raxStart(&ri_cpel, consumer->pel);\n            raxSeek(&ri_cpel, \"^\", NULL, 0);\n            while (raxNext(&ri_cpel)) {\n                streamNACK *new_nack = raxFind(new_cg->pel,ri_cpel.key,sizeof(streamID));\n\n                serverAssert(new_nack != raxNotFound);\n\n                new_nack->consumer = new_consumer;\n                raxInsert(new_consumer->pel,ri_cpel.key,sizeof(streamID),new_nack,NULL);\n            }\n            raxStop(&ri_cpel);\n        }\n        raxStop(&ri_consumers);\n    }\n    raxStop(&ri_cgroups);\n    return sobj;\n}\n\n/* This is a wrapper function for lpGet() to directly get an integer value\n * from the listpack (that may store numbers as a string), converting\n * the string if needed.\n * The 'valid\" argument is an optional output parameter to get an indication\n * if the record was valid, when this parameter is NULL, the function will\n * fail with an assertion. */\nstatic inline int64_t lpGetIntegerIfValid(unsigned char *ele, int *valid) {\n    int64_t v;\n    unsigned char *e = lpGet(ele,&v,NULL);\n    if (e == NULL) {\n        if (valid)\n            *valid = 1;\n        return v;\n    }\n    /* The following code path should never be used for how listpacks work:\n     * they should always be able to store an int64_t value in integer\n     * encoded form. However the implementation may change. */\n    long long ll;\n    int ret = string2ll((char*)e,v,&ll);\n    if (valid)\n        *valid = ret;\n    else\n        serverAssert(ret != 0);\n    v = ll;\n    return v;\n}\n\n#define lpGetInteger(ele) lpGetIntegerIfValid(ele, NULL)\n\n/* Get an edge streamID of a given listpack.\n * 'master_id' is an input param, used to build the 'edge_id' output param */\nint lpGetEdgeStreamID(unsigned char *lp, int first, streamID *master_id, streamID *edge_id)\n{\n   if (lp == NULL)\n       return 0;\n\n   unsigned char *lp_ele;\n\n   /* We need to seek either the first or the last entry depending\n    * on the direction of the iteration. */\n   if (first) {\n       /* Get the master fields count. */\n       lp_ele = lpFirst(lp);        /* Seek items count */\n       lp_ele = lpNext(lp, lp_ele); /* Seek deleted count. */\n       lp_ele = lpNext(lp, lp_ele); /* Seek num fields. */\n       int64_t master_fields_count = lpGetInteger(lp_ele);\n       lp_ele = lpNext(lp, lp_ele); /* Seek first field. */\n\n       /* If we are iterating in normal order, skip the master fields\n        * to seek the first actual entry. */\n       for (int64_t i = 0; i < master_fields_count; i++)\n           lp_ele = lpNext(lp, lp_ele);\n\n       /* If we are going forward, skip the previous entry's\n        * lp-count field (or in case of the master entry, the zero\n        * term field) */\n       lp_ele = lpNext(lp, lp_ele);\n       if (lp_ele == NULL)\n           return 0;\n   } else {\n       /* If we are iterating in reverse direction, just seek the\n        * last part of the last entry in the listpack (that is, the\n        * fields count). */\n       lp_ele = lpLast(lp);\n\n       /* If we are going backward, read the number of elements this\n        * entry is composed of, and jump backward N times to seek\n        * its start. */\n       int64_t lp_count = lpGetInteger(lp_ele);\n       if (lp_count == 0) /* We reached the master entry. */\n           return 0;\n\n       while (lp_count--)\n           lp_ele = lpPrev(lp, lp_ele);\n   }\n\n   lp_ele = lpNext(lp, lp_ele); /* Seek ID (lp_ele currently points to 'flags'). */\n\n   /* Get the ID: it is encoded as difference between the master\n    * ID and this entry ID. */\n   streamID id = *master_id;\n   id.ms += lpGetInteger(lp_ele);\n   lp_ele = lpNext(lp, lp_ele);\n   id.seq += lpGetInteger(lp_ele);\n   *edge_id = id;\n   return 1;\n}\n\n/* Debugging function to log the full content of a listpack. Useful\n * for development and debugging. */\nvoid streamLogListpackContent(unsigned char *lp) {\n    unsigned char *p = lpFirst(lp);\n    while(p) {\n        unsigned char buf[LP_INTBUF_SIZE];\n        int64_t v;\n        unsigned char *ele = lpGet(p,&v,buf);\n        serverLog(LL_WARNING,\"- [%d] '%.*s'\", (int)v, (int)v, ele);\n        p = lpNext(lp,p);\n    }\n}\n\n/* Convert the specified stream entry ID as a 128 bit big endian number, so\n * that the IDs can be sorted lexicographically. */\nvoid streamEncodeID(void *buf, streamID *id) {\n    uint64_t e[2];\n    e[0] = htonu64(id->ms);\n    e[1] = htonu64(id->seq);\n    memcpy(buf,e,sizeof(e));\n}\n\n/* This is the reverse of streamEncodeID(): the decoded ID will be stored\n * in the 'id' structure passed by reference. The buffer 'buf' must point\n * to a 128 bit big-endian encoded ID. */\nvoid streamDecodeID(void *buf, streamID *id) {\n    uint64_t e[2];\n    memcpy(e,buf,sizeof(e));\n    id->ms = ntohu64(e[0]);\n    id->seq = ntohu64(e[1]);\n}\n\n/* Compare two stream IDs. Return -1 if a < b, 0 if a == b, 1 if a > b. */\nint streamCompareID(streamID *a, streamID *b) {\n    if (a->ms > b->ms) return 1;\n    else if (a->ms < b->ms) return -1;\n    /* The ms part is the same. Check the sequence part. */\n    else if (a->seq > b->seq) return 1;\n    else if (a->seq < b->seq) return -1;\n    /* Everything is the same: IDs are equal. */\n    return 0;\n}\n\n/* Retrieves the ID of the stream edge entry. An edge is either the first or\n * the last ID in the stream, and may be a tombstone. To filter out tombstones,\n * set the'skip_tombstones' argument to 1. */\nvoid streamGetEdgeID(stream *s, int first, int skip_tombstones, streamID *edge_id)\n{\n    streamIterator si;\n    int64_t numfields;\n    streamIteratorStart(&si,s,NULL,NULL,!first);\n    si.skip_tombstones = skip_tombstones;\n    int found = streamIteratorGetID(&si,edge_id,&numfields);\n    if (!found) {\n        streamID min_id = {0, 0}, max_id = {UINT64_MAX, UINT64_MAX};\n        *edge_id = first ? max_id : min_id;\n    }\n    streamIteratorStop(&si);\n}\n\n/* Adds a new item into the stream 's' having the specified number of\n * field-value pairs as specified in 'numfields' and stored into 'argv'.\n * Returns the new entry ID populating the 'added_id' structure.\n *\n * If 'use_id' is not NULL, the ID is not auto-generated by the function,\n * but instead the passed ID is used to add the new entry. In this case\n * adding the entry may fail as specified later in this comment.\n * \n * When 'use_id' is used alongside with a zero 'seq-given', the sequence\n * part of the passed ID is ignored and the function will attempt to use an\n * auto-generated sequence.\n *\n * The function returns C_OK if the item was added, this is always true\n * if the ID was generated by the function. However the function may return\n * C_ERR in several cases:\n * 1. If an ID was given via 'use_id', but adding it failed since the\n *    current top ID is greater or equal. errno will be set to EDOM.\n * 2. If a size of a single element or the sum of the elements is too big to\n *    be stored into the stream. errno will be set to ERANGE. */\nint streamAppendItem(stream *s, robj **argv, int64_t numfields, streamID *added_id, streamID *use_id, int seq_given) {\n\n    /* Generate the new entry ID. */\n    streamID id;\n    if (use_id) {\n        if (seq_given) {\n            id = *use_id;\n        } else {\n            /* The automatically generated sequence can be either zero (new\n             * timestamps) or the incremented sequence of the last ID. In the\n             * latter case, we need to prevent an overflow/advancing forward\n             * in time. */\n            if (s->last_id.ms == use_id->ms) {\n                if (s->last_id.seq == UINT64_MAX) {\n                    return C_ERR;\n                }\n                id = s->last_id;\n                id.seq++;\n            } else {\n                id = *use_id;\n            }\n        }\n    } else {\n        streamNextID(&s->last_id,&id);\n    }\n\n    /* Check that the new ID is greater than the last entry ID\n     * or return an error. Automatically generated IDs might\n     * overflow (and wrap-around) when incrementing the sequence\n       part. */\n    if (streamCompareID(&id,&s->last_id) <= 0) {\n        errno = EDOM;\n        return C_ERR;\n    }\n\n    /* Avoid overflow when trying to add an element to the stream (listpack\n     * can only host up to 32bit length sttrings, and also a total listpack size\n     * can't be bigger than 32bit length. */\n    size_t totelelen = 0;\n    for (int64_t i = 0; i < numfields*2; i++) {\n        sds ele = argv[i]->ptr;\n        totelelen += sdslen(ele);\n    }\n    if (totelelen > STREAM_LISTPACK_MAX_SIZE) {\n        errno = ERANGE;\n        return C_ERR;\n    }\n\n    /* Add the new entry. */\n    raxIterator ri;\n    raxStart(&ri,s->rax);\n    raxSeek(&ri,\"$\",NULL,0);\n\n    size_t lp_bytes = 0;        /* Total bytes in the tail listpack. */\n    unsigned char *lp = NULL;   /* Tail listpack pointer. */\n\n    if (!raxEOF(&ri)) {\n        /* Get a reference to the tail node listpack. */\n        lp = ri.data;\n        lp_bytes = lpBytes(lp);\n    }\n    raxStop(&ri);\n\n    /* We have to add the key into the radix tree in lexicographic order,\n     * to do so we consider the ID as a single 128 bit number written in\n     * big endian, so that the most significant bytes are the first ones. */\n    uint64_t rax_key[2];    /* Key in the radix tree containing the listpack.*/\n    streamID master_id;     /* ID of the master entry in the listpack. */\n\n    /* Create a new listpack and radix tree node if needed. Note that when\n     * a new listpack is created, we populate it with a \"master entry\". This\n     * is just a set of fields that is taken as references in order to compress\n     * the stream entries that we'll add inside the listpack.\n     *\n     * Note that while we use the first added entry fields to create\n     * the master entry, the first added entry is NOT represented in the master\n     * entry, which is a stand alone object. But of course, the first entry\n     * will compress well because it's used as reference.\n     *\n     * The master entry is composed like in the following example:\n     *\n     * +-------+---------+------------+---------+--/--+---------+---------+-+\n     * | count | deleted | num-fields | field_1 | field_2 | ... | field_N |0|\n     * +-------+---------+------------+---------+--/--+---------+---------+-+\n     *\n     * count and deleted just represent respectively the total number of\n     * entries inside the listpack that are valid, and marked as deleted\n     * (deleted flag in the entry flags set). So the total number of items\n     * actually inside the listpack (both deleted and not) is count+deleted.\n     *\n     * The real entries will be encoded with an ID that is just the\n     * millisecond and sequence difference compared to the key stored at\n     * the radix tree node containing the listpack (delta encoding), and\n     * if the fields of the entry are the same as the master entry fields, the\n     * entry flags will specify this fact and the entry fields and number\n     * of fields will be omitted (see later in the code of this function).\n     *\n     * The \"0\" entry at the end is the same as the 'lp-count' entry in the\n     * regular stream entries (see below), and marks the fact that there are\n     * no more entries, when we scan the stream from right to left. */\n\n    /* First of all, check if we can append to the current macro node or\n     * if we need to switch to the next one. 'lp' will be set to NULL if\n     * the current node is full. */\n    if (lp != NULL) {\n        size_t node_max_bytes = server.stream_node_max_bytes;\n        if (node_max_bytes == 0 || node_max_bytes > STREAM_LISTPACK_MAX_SIZE)\n            node_max_bytes = STREAM_LISTPACK_MAX_SIZE;\n        if (lp_bytes + totelelen >= node_max_bytes) {\n            lp = NULL;\n        } else if (server.stream_node_max_entries) {\n            unsigned char *lp_ele = lpFirst(lp);\n            /* Count both live entries and deleted ones. */\n            int64_t count = lpGetInteger(lp_ele) + lpGetInteger(lpNext(lp,lp_ele));\n            if (count >= server.stream_node_max_entries) {\n                /* Shrink extra pre-allocated memory */\n                lp = lpShrinkToFit(lp);\n                if (ri.data != lp)\n                    raxInsert(s->rax,ri.key,ri.key_len,lp,NULL);\n                lp = NULL;\n            }\n        }\n    }\n\n    int flags = STREAM_ITEM_FLAG_NONE;\n    if (lp == NULL) {\n        master_id = id;\n        streamEncodeID(rax_key,&id);\n        /* Create the listpack having the master entry ID and fields.\n         * Pre-allocate some bytes when creating listpack to avoid realloc on\n         * every XADD. Since listpack.c uses malloc_size, it'll grow in steps,\n         * and won't realloc on every XADD.\n         * When listpack reaches max number of entries, we'll shrink the\n         * allocation to fit the data. */\n        size_t prealloc = STREAM_LISTPACK_MAX_PRE_ALLOCATE;\n        if (server.stream_node_max_bytes > 0 && server.stream_node_max_bytes < prealloc) {\n            prealloc = server.stream_node_max_bytes;\n        }\n        lp = lpNew(prealloc);\n        lp = lpAppendInteger(lp,1); /* One item, the one we are adding. */\n        lp = lpAppendInteger(lp,0); /* Zero deleted so far. */\n        lp = lpAppendInteger(lp,numfields);\n        for (int64_t i = 0; i < numfields; i++) {\n            sds field = argv[i*2]->ptr;\n            lp = lpAppend(lp,(unsigned char*)field,sdslen(field));\n        }\n        lp = lpAppendInteger(lp,0); /* Master entry zero terminator. */\n        raxInsert(s->rax,(unsigned char*)&rax_key,sizeof(rax_key),lp,NULL);\n        /* The first entry we insert, has obviously the same fields of the\n         * master entry. */\n        flags |= STREAM_ITEM_FLAG_SAMEFIELDS;\n    } else {\n        serverAssert(ri.key_len == sizeof(rax_key));\n        memcpy(rax_key,ri.key,sizeof(rax_key));\n\n        /* Read the master ID from the radix tree key. */\n        streamDecodeID(rax_key,&master_id);\n        unsigned char *lp_ele = lpFirst(lp);\n\n        /* Update count and skip the deleted fields. */\n        int64_t count = lpGetInteger(lp_ele);\n        lp = lpReplaceInteger(lp,&lp_ele,count+1);\n        lp_ele = lpNext(lp,lp_ele); /* seek deleted. */\n        lp_ele = lpNext(lp,lp_ele); /* seek master entry num fields. */\n\n        /* Check if the entry we are adding, have the same fields\n         * as the master entry. */\n        int64_t master_fields_count = lpGetInteger(lp_ele);\n        lp_ele = lpNext(lp,lp_ele);\n        if (numfields == master_fields_count) {\n            int64_t i;\n            for (i = 0; i < master_fields_count; i++) {\n                sds field = argv[i*2]->ptr;\n                int64_t e_len;\n                unsigned char buf[LP_INTBUF_SIZE];\n                unsigned char *e = lpGet(lp_ele,&e_len,buf);\n                /* Stop if there is a mismatch. */\n                if (sdslen(field) != (size_t)e_len ||\n                    memcmp(e,field,e_len) != 0) break;\n                lp_ele = lpNext(lp,lp_ele);\n            }\n            /* All fields are the same! We can compress the field names\n             * setting a single bit in the flags. */\n            if (i == master_fields_count) flags |= STREAM_ITEM_FLAG_SAMEFIELDS;\n        }\n    }\n\n    /* Populate the listpack with the new entry. We use the following\n     * encoding:\n     *\n     * +-----+--------+----------+-------+-------+-/-+-------+-------+--------+\n     * |flags|entry-id|num-fields|field-1|value-1|...|field-N|value-N|lp-count|\n     * +-----+--------+----------+-------+-------+-/-+-------+-------+--------+\n     *\n     * However if the SAMEFIELD flag is set, we have just to populate\n     * the entry with the values, so it becomes:\n     *\n     * +-----+--------+-------+-/-+-------+--------+\n     * |flags|entry-id|value-1|...|value-N|lp-count|\n     * +-----+--------+-------+-/-+-------+--------+\n     *\n     * The entry-id field is actually two separated fields: the ms\n     * and seq difference compared to the master entry.\n     *\n     * The lp-count field is a number that states the number of listpack pieces\n     * that compose the entry, so that it's possible to travel the entry\n     * in reverse order: we can just start from the end of the listpack, read\n     * the entry, and jump back N times to seek the \"flags\" field to read\n     * the stream full entry. */\n    lp = lpAppendInteger(lp,flags);\n    lp = lpAppendInteger(lp,id.ms - master_id.ms);\n    lp = lpAppendInteger(lp,id.seq - master_id.seq);\n    if (!(flags & STREAM_ITEM_FLAG_SAMEFIELDS))\n        lp = lpAppendInteger(lp,numfields);\n    for (int64_t i = 0; i < numfields; i++) {\n        sds field = argv[i*2]->ptr, value = argv[i*2+1]->ptr;\n        if (!(flags & STREAM_ITEM_FLAG_SAMEFIELDS))\n            lp = lpAppend(lp,(unsigned char*)field,sdslen(field));\n        lp = lpAppend(lp,(unsigned char*)value,sdslen(value));\n    }\n    /* Compute and store the lp-count field. */\n    int64_t lp_count = numfields;\n    lp_count += 3; /* Add the 3 fixed fields flags + ms-diff + seq-diff. */\n    if (!(flags & STREAM_ITEM_FLAG_SAMEFIELDS)) {\n        /* If the item is not compressed, it also has the fields other than\n         * the values, and an additional num-fields field. */\n        lp_count += numfields+1;\n    }\n    lp = lpAppendInteger(lp,lp_count);\n\n    /* Insert back into the tree in order to update the listpack pointer. */\n    if (ri.data != lp)\n        raxInsert(s->rax,(unsigned char*)&rax_key,sizeof(rax_key),lp,NULL);\n    s->length++;\n    s->entries_added++;\n    s->last_id = id;\n    if (s->length == 1) s->first_id = id;\n    if (added_id) *added_id = id;\n    return C_OK;\n}\n\ntypedef struct {\n    /* XADD options */\n    streamID id; /* User-provided ID, for XADD only. */\n    int id_given; /* Was an ID different than \"*\" specified? for XADD only. */\n    int seq_given; /* Was an ID different than \"ms-*\" specified? for XADD only. */\n    int no_mkstream; /* if set to 1 do not create new stream */\n\n    /* XADD + XTRIM common options */\n    int trim_strategy; /* TRIM_STRATEGY_* */\n    int trim_strategy_arg_idx; /* Index of the count in MAXLEN/MINID, for rewriting. */\n    int approx_trim; /* If 1 only delete whole radix tree nodes, so\n                      * the trim argument is not applied verbatim. */\n    long long limit; /* Maximum amount of entries to trim. If 0, no limitation\n                      * on the amount of trimming work is enforced. */\n    /* TRIM_STRATEGY_MAXLEN options */\n    long long maxlen; /* After trimming, leave stream at this length . */\n    /* TRIM_STRATEGY_MINID options */\n    streamID minid; /* Trim by ID (No stream entries with ID < 'minid' will remain) */\n} streamAddTrimArgs;\n\n#define TRIM_STRATEGY_NONE 0\n#define TRIM_STRATEGY_MAXLEN 1\n#define TRIM_STRATEGY_MINID 2\n\n/* Trim the stream 's' according to args->trim_strategy, and return the\n * number of elements removed from the stream. The 'approx' option, if non-zero,\n * specifies that the trimming must be performed in a approximated way in\n * order to maximize performances. This means that the stream may contain\n * entries with IDs < 'id' in case of MINID (or more elements than 'maxlen'\n * in case of MAXLEN), and elements are only removed if we can remove\n * a *whole* node of the radix tree. The elements are removed from the head\n * of the stream (older elements).\n *\n * The function may return zero if:\n *\n * 1) The minimal entry ID of the stream is already < 'id' (MINID); or\n * 2) The stream is already shorter or equal to the specified max length (MAXLEN); or\n * 3) The 'approx' option is true and the head node did not have enough elements\n *    to be deleted.\n *\n * args->limit is the maximum number of entries to delete. The purpose is to\n * prevent this function from taking to long.\n * If 'limit' is 0 then we do not limit the number of deleted entries.\n * Much like the 'approx', if 'limit' is smaller than the number of entries\n * that should be trimmed, there is a chance we will still have entries with\n * IDs < 'id' (or number of elements >= maxlen in case of MAXLEN).\n */\nint64_t streamTrim(stream *s, streamAddTrimArgs *args) {\n    size_t maxlen = args->maxlen;\n    streamID *id = &args->minid;\n    int approx = args->approx_trim;\n    int64_t limit = args->limit;\n    int trim_strategy = args->trim_strategy;\n\n    if (trim_strategy == TRIM_STRATEGY_NONE)\n        return 0;\n\n    raxIterator ri;\n    raxStart(&ri,s->rax);\n    raxSeek(&ri,\"^\",NULL,0);\n\n    int64_t deleted = 0;\n    while (raxNext(&ri)) {\n        if (trim_strategy == TRIM_STRATEGY_MAXLEN && s->length <= maxlen)\n            break;\n\n        unsigned char *lp = ri.data, *p = lpFirst(lp);\n        int64_t entries = lpGetInteger(p);\n\n        /* Check if we exceeded the amount of work we could do */\n        if (limit && (deleted + entries) > limit)\n            break;\n\n        /* Check if we can remove the whole node. */\n        int remove_node;\n        streamID master_id = {0}; /* For MINID */\n        if (trim_strategy == TRIM_STRATEGY_MAXLEN) {\n            remove_node = s->length - entries >= maxlen;\n        } else {\n            /* Read the master ID from the radix tree key. */\n            streamDecodeID(ri.key, &master_id);\n\n            /* Read last ID. */\n            streamID last_id;\n            lpGetEdgeStreamID(lp, 0, &master_id, &last_id);\n\n            /* We can remove the entire node id its last ID < 'id' */\n            remove_node = streamCompareID(&last_id, id) < 0;\n        }\n\n        if (remove_node) {\n            lpFree(lp);\n            raxRemove(s->rax,ri.key,ri.key_len,NULL);\n            raxSeek(&ri,\">=\",ri.key,ri.key_len);\n            s->length -= entries;\n            deleted += entries;\n            continue;\n        }\n\n        /* If we cannot remove a whole element, and approx is true,\n         * stop here. */\n        if (approx) break;\n\n        /* Now we have to trim entries from within 'lp' */\n        int64_t deleted_from_lp = 0;\n\n        p = lpNext(lp, p); /* Skip deleted field. */\n        p = lpNext(lp, p); /* Skip num-of-fields in the master entry. */\n\n        /* Skip all the master fields. */\n        int64_t master_fields_count = lpGetInteger(p);\n        p = lpNext(lp,p); /* Skip the first field. */\n        for (int64_t j = 0; j < master_fields_count; j++)\n            p = lpNext(lp,p); /* Skip all master fields. */\n        p = lpNext(lp,p); /* Skip the zero master entry terminator. */\n\n        /* 'p' is now pointing to the first entry inside the listpack.\n         * We have to run entry after entry, marking entries as deleted\n         * if they are already not deleted. */\n        while (p) {\n            /* We keep a copy of p (which point to flags part) in order to\n             * update it after (and if) we actually remove the entry */\n            unsigned char *pcopy = p;\n\n            int64_t flags = lpGetInteger(p);\n            p = lpNext(lp, p); /* Skip flags. */\n            int64_t to_skip;\n\n            int64_t ms_delta = lpGetInteger(p);\n            p = lpNext(lp, p); /* Skip ID ms delta */\n            int64_t seq_delta = lpGetInteger(p);\n            p = lpNext(lp, p); /* Skip ID seq delta */\n\n            streamID currid = {0}; /* For MINID */\n            if (trim_strategy == TRIM_STRATEGY_MINID) {\n                currid.ms = master_id.ms + ms_delta;\n                currid.seq = master_id.seq + seq_delta;\n            }\n\n            int stop;\n            if (trim_strategy == TRIM_STRATEGY_MAXLEN) {\n                stop = s->length <= maxlen;\n            } else {\n                /* Following IDs will definitely be greater because the rax\n                 * tree is sorted, no point of continuing. */\n                stop = streamCompareID(&currid, id) >= 0;\n            }\n            if (stop)\n                break;\n\n            if (flags & STREAM_ITEM_FLAG_SAMEFIELDS) {\n                to_skip = master_fields_count;\n            } else {\n                to_skip = lpGetInteger(p); /* Get num-fields. */\n                p = lpNext(lp,p); /* Skip num-fields. */\n                to_skip *= 2; /* Fields and values. */\n            }\n\n            while(to_skip--) p = lpNext(lp,p); /* Skip the whole entry. */\n            p = lpNext(lp,p); /* Skip the final lp-count field. */\n\n            /* Mark the entry as deleted. */\n            if (!(flags & STREAM_ITEM_FLAG_DELETED)) {\n                intptr_t delta = p - lp;\n                flags |= STREAM_ITEM_FLAG_DELETED;\n                lp = lpReplaceInteger(lp, &pcopy, flags);\n                deleted_from_lp++;\n                s->length--;\n                p = lp + delta;\n            }\n        }\n        deleted += deleted_from_lp;\n\n        /* Now we update the entries/deleted counters. */\n        p = lpFirst(lp);\n        lp = lpReplaceInteger(lp,&p,entries-deleted_from_lp);\n        p = lpNext(lp,p); /* Skip deleted field. */\n        int64_t marked_deleted = lpGetInteger(p);\n        lp = lpReplaceInteger(lp,&p,marked_deleted+deleted_from_lp);\n        p = lpNext(lp,p); /* Skip num-of-fields in the master entry. */\n\n        /* Here we should perform garbage collection in case at this point\n         * there are too many entries deleted inside the listpack. */\n        entries -= deleted_from_lp;\n        marked_deleted += deleted_from_lp;\n        if (entries + marked_deleted > 10 && marked_deleted > entries/2) {\n            /* TODO: perform a garbage collection. */\n        }\n\n        /* Update the listpack with the new pointer. */\n        raxInsert(s->rax,ri.key,ri.key_len,lp,NULL);\n\n        break; /* If we are here, there was enough to delete in the current\n                  node, so no need to go to the next node. */\n    }\n    raxStop(&ri);\n\n    /* Update the stream's first ID after the trimming. */\n    if (s->length == 0) {\n        s->first_id.ms = 0;\n        s->first_id.seq = 0;\n    } else if (deleted) {\n        streamGetEdgeID(s,1,1,&s->first_id);\n    }\n\n    return deleted;\n}\n\n/* Trims a stream by length. Returns the number of deleted items. */\nint64_t streamTrimByLength(stream *s, long long maxlen, int approx) {\n    streamAddTrimArgs args = {\n        .trim_strategy = TRIM_STRATEGY_MAXLEN,\n        .approx_trim = approx,\n        .limit = approx ? 100 * server.stream_node_max_entries : 0,\n        .maxlen = maxlen\n    };\n    return streamTrim(s, &args);\n}\n\n/* Trims a stream by minimum ID. Returns the number of deleted items. */\nint64_t streamTrimByID(stream *s, streamID minid, int approx) {\n    streamAddTrimArgs args = {\n        .trim_strategy = TRIM_STRATEGY_MINID,\n        .approx_trim = approx,\n        .limit = approx ? 100 * server.stream_node_max_entries : 0,\n        .minid = minid\n    };\n    return streamTrim(s, &args);\n}\n\n/* Parse the arguments of XADD/XTRIM.\n *\n * See streamAddTrimArgs for more details about the arguments handled.\n *\n * This function returns the position of the ID argument (relevant only to XADD).\n * On error -1 is returned and a reply is sent. */\nstatic int streamParseAddOrTrimArgsOrReply(client *c, streamAddTrimArgs *args, int xadd) {\n    /* Initialize arguments to defaults */\n    memset(args, 0, sizeof(*args));\n\n    /* Parse options. */\n    int i = 2; /* This is the first argument position where we could\n                  find an option, or the ID. */\n    int limit_given = 0;\n    for (; i < c->argc; i++) {\n        int moreargs = (c->argc-1) - i; /* Number of additional arguments. */\n        char *opt = c->argv[i]->ptr;\n        if (xadd && opt[0] == '*' && opt[1] == '\\0') {\n            /* This is just a fast path for the common case of auto-ID\n             * creation. */\n            break;\n        } else if (!strcasecmp(opt,\"maxlen\") && moreargs) {\n            if (args->trim_strategy != TRIM_STRATEGY_NONE) {\n                addReplyError(c,\"syntax error, MAXLEN and MINID options at the same time are not compatible\");\n                return -1;\n            }\n            args->approx_trim = 0;\n            char *next = c->argv[i+1]->ptr;\n            /* Check for the form MAXLEN ~ <count>. */\n            if (moreargs >= 2 && next[0] == '~' && next[1] == '\\0') {\n                args->approx_trim = 1;\n                i++;\n            } else if (moreargs >= 2 && next[0] == '=' && next[1] == '\\0') {\n                i++;\n            }\n            if (getLongLongFromObjectOrReply(c,c->argv[i+1],&args->maxlen,NULL)\n                != C_OK) return -1;\n\n            if (args->maxlen < 0) {\n                addReplyError(c,\"The MAXLEN argument must be >= 0.\");\n                return -1;\n            }\n            i++;\n            args->trim_strategy = TRIM_STRATEGY_MAXLEN;\n            args->trim_strategy_arg_idx = i;\n        } else if (!strcasecmp(opt,\"minid\") && moreargs) {\n            if (args->trim_strategy != TRIM_STRATEGY_NONE) {\n                addReplyError(c,\"syntax error, MAXLEN and MINID options at the same time are not compatible\");\n                return -1;\n            }\n            args->approx_trim = 0;\n            char *next = c->argv[i+1]->ptr;\n            /* Check for the form MINID ~ <id>|<age>. */\n            if (moreargs >= 2 && next[0] == '~' && next[1] == '\\0') {\n                args->approx_trim = 1;\n                i++;\n            } else if (moreargs >= 2 && next[0] == '=' && next[1] == '\\0') {\n                i++;\n            }\n\n            if (streamParseStrictIDOrReply(c,c->argv[i+1],&args->minid,0,NULL) != C_OK)\n                return -1;\n            \n            i++;\n            args->trim_strategy = TRIM_STRATEGY_MINID;\n            args->trim_strategy_arg_idx = i;\n        } else if (!strcasecmp(opt,\"limit\") && moreargs) {\n            /* Note about LIMIT: If it was not provided by the caller we set\n             * it to 100*server.stream_node_max_entries, and that's to prevent the\n             * trimming from taking too long, on the expense of not deleting entries\n             * that should be trimmed.\n             * If user wanted exact trimming (i.e. no '~') we never limit the number\n             * of trimmed entries */\n            if (getLongLongFromObjectOrReply(c,c->argv[i+1],&args->limit,NULL) != C_OK)\n                return -1;\n\n            if (args->limit < 0) {\n                addReplyError(c,\"The LIMIT argument must be >= 0.\");\n                return -1;\n            }\n            limit_given = 1;\n            i++;\n        } else if (xadd && !strcasecmp(opt,\"nomkstream\")) {\n            args->no_mkstream = 1;\n        } else if (xadd) {\n            /* If we are here is a syntax error or a valid ID. */\n            if (streamParseStrictIDOrReply(c,c->argv[i],&args->id,0,&args->seq_given) != C_OK)\n                return -1;\n            args->id_given = 1;\n            break;\n        } else {\n            addReplyErrorObject(c,shared.syntaxerr);\n            return -1;\n        }\n    }\n\n    if (args->limit && args->trim_strategy == TRIM_STRATEGY_NONE) {\n        addReplyError(c,\"syntax error, LIMIT cannot be used without specifying a trimming strategy\");\n        return -1;\n    }\n\n    if (!xadd && args->trim_strategy == TRIM_STRATEGY_NONE) {\n        addReplyError(c,\"syntax error, XTRIM must be called with a trimming strategy\");\n        return -1;\n    }\n\n    if (mustObeyClient(c)) {\n        /* If command came from master or from AOF we must not enforce maxnodes\n         * (The maxlen/minid argument was re-written to make sure there's no\n         * inconsistency). */\n        args->limit = 0;\n    } else {\n        /* We need to set the limit (only if we got '~') */\n        if (limit_given) {\n            if (!args->approx_trim) {\n                /* LIMIT was provided without ~ */\n                addReplyError(c,\"syntax error, LIMIT cannot be used without the special ~ option\");\n                return -1;\n            }\n        } else {\n            /* User didn't provide LIMIT, we must set it. */\n            if (args->approx_trim) {\n                /* In order to prevent from trimming to do too much work and \n                 * cause latency spikes we limit the amount of work it can do.\n                 * We have to cap args->limit from both sides in case \n                 * stream_node_max_entries is 0 or too big (could cause overflow)\n                 */\n                args->limit = 100 * server.stream_node_max_entries; /* Maximum 100 rax nodes. */\n                if (args->limit <= 0) args->limit = 10000;\n                if (args->limit > 1000000) args->limit = 1000000;\n            } else {\n                /* No LIMIT for exact trimming */\n                args->limit = 0;\n            }\n        }\n    }\n\n    return i;\n}\n\n/* Initialize the stream iterator, so that we can call iterating functions\n * to get the next items. This requires a corresponding streamIteratorStop()\n * at the end. The 'rev' parameter controls the direction. If it's zero the\n * iteration is from the start to the end element (inclusive), otherwise\n * if rev is non-zero, the iteration is reversed.\n *\n * Once the iterator is initialized, we iterate like this:\n *\n *  streamIterator myiterator;\n *  streamIteratorStart(&myiterator,...);\n *  int64_t numfields;\n *  while(streamIteratorGetID(&myiterator,&ID,&numfields)) {\n *      while(numfields--) {\n *          unsigned char *key, *value;\n *          size_t key_len, value_len;\n *          streamIteratorGetField(&myiterator,&key,&value,&key_len,&value_len);\n *\n *          ... do what you want with key and value ...\n *      }\n *  }\n *  streamIteratorStop(&myiterator); */\nvoid streamIteratorStart(streamIterator *si, stream *s, streamID *start, streamID *end, int rev) {\n    /* Initialize the iterator and translates the iteration start/stop\n     * elements into a 128 big big-endian number. */\n    if (start) {\n        streamEncodeID(si->start_key,start);\n    } else {\n        si->start_key[0] = 0;\n        si->start_key[1] = 0;\n    }\n\n    if (end) {\n        streamEncodeID(si->end_key,end);\n    } else {\n        si->end_key[0] = UINT64_MAX;\n        si->end_key[1] = UINT64_MAX;\n    }\n\n    /* Seek the correct node in the radix tree. */\n    raxStart(&si->ri,s->rax);\n    if (!rev) {\n        if (start && (start->ms || start->seq)) {\n            raxSeek(&si->ri,\"<=\",(unsigned char*)si->start_key,\n                    sizeof(si->start_key));\n            if (raxEOF(&si->ri)) raxSeek(&si->ri,\"^\",NULL,0);\n        } else {\n            raxSeek(&si->ri,\"^\",NULL,0);\n        }\n    } else {\n        if (end && (end->ms || end->seq)) {\n            raxSeek(&si->ri,\"<=\",(unsigned char*)si->end_key,\n                    sizeof(si->end_key));\n            if (raxEOF(&si->ri)) raxSeek(&si->ri,\"$\",NULL,0);\n        } else {\n            raxSeek(&si->ri,\"$\",NULL,0);\n        }\n    }\n    si->stream = s;\n    si->lp = NULL;     /* There is no current listpack right now. */\n    si->lp_ele = NULL; /* Current listpack cursor. */\n    si->rev = rev;     /* Direction, if non-zero reversed, from end to start. */\n    si->skip_tombstones = 1;    /* By default tombstones aren't emitted. */\n}\n\n/* Return 1 and store the current item ID at 'id' if there are still\n * elements within the iteration range, otherwise return 0 in order to\n * signal the iteration terminated. */\nint streamIteratorGetID(streamIterator *si, streamID *id, int64_t *numfields) {\n    while(1) { /* Will stop when element > stop_key or end of radix tree. */\n        /* If the current listpack is set to NULL, this is the start of the\n         * iteration or the previous listpack was completely iterated.\n         * Go to the next node. */\n        if (si->lp == NULL || si->lp_ele == NULL) {\n            if (!si->rev && !raxNext(&si->ri)) return 0;\n            else if (si->rev && !raxPrev(&si->ri)) return 0;\n            serverAssert(si->ri.key_len == sizeof(streamID));\n            /* Get the master ID. */\n            streamDecodeID(si->ri.key,&si->master_id);\n            /* Get the master fields count. */\n            si->lp = si->ri.data;\n            si->lp_ele = lpFirst(si->lp);           /* Seek items count */\n            si->lp_ele = lpNext(si->lp,si->lp_ele); /* Seek deleted count. */\n            si->lp_ele = lpNext(si->lp,si->lp_ele); /* Seek num fields. */\n            si->master_fields_count = lpGetInteger(si->lp_ele);\n            si->lp_ele = lpNext(si->lp,si->lp_ele); /* Seek first field. */\n            si->master_fields_start = si->lp_ele;\n            /* We are now pointing to the first field of the master entry.\n             * We need to seek either the first or the last entry depending\n             * on the direction of the iteration. */\n            if (!si->rev) {\n                /* If we are iterating in normal order, skip the master fields\n                 * to seek the first actual entry. */\n                for (uint64_t i = 0; i < si->master_fields_count; i++)\n                    si->lp_ele = lpNext(si->lp,si->lp_ele);\n            } else {\n                /* If we are iterating in reverse direction, just seek the\n                 * last part of the last entry in the listpack (that is, the\n                 * fields count). */\n                si->lp_ele = lpLast(si->lp);\n            }\n        } else if (si->rev) {\n            /* If we are iterating in the reverse order, and this is not\n             * the first entry emitted for this listpack, then we already\n             * emitted the current entry, and have to go back to the previous\n             * one. */\n            int64_t lp_count = lpGetInteger(si->lp_ele);\n            while(lp_count--) si->lp_ele = lpPrev(si->lp,si->lp_ele);\n            /* Seek lp-count of prev entry. */\n            si->lp_ele = lpPrev(si->lp,si->lp_ele);\n        }\n\n        /* For every radix tree node, iterate the corresponding listpack,\n         * returning elements when they are within range. */\n        while(1) {\n            if (!si->rev) {\n                /* If we are going forward, skip the previous entry\n                 * lp-count field (or in case of the master entry, the zero\n                 * term field) */\n                si->lp_ele = lpNext(si->lp,si->lp_ele);\n                if (si->lp_ele == NULL) break;\n            } else {\n                /* If we are going backward, read the number of elements this\n                 * entry is composed of, and jump backward N times to seek\n                 * its start. */\n                int64_t lp_count = lpGetInteger(si->lp_ele);\n                if (lp_count == 0) { /* We reached the master entry. */\n                    si->lp = NULL;\n                    si->lp_ele = NULL;\n                    break;\n                }\n                while(lp_count--) si->lp_ele = lpPrev(si->lp,si->lp_ele);\n            }\n\n            /* Get the flags entry. */\n            si->lp_flags = si->lp_ele;\n            int64_t flags = lpGetInteger(si->lp_ele);\n            si->lp_ele = lpNext(si->lp,si->lp_ele); /* Seek ID. */\n\n            /* Get the ID: it is encoded as difference between the master\n             * ID and this entry ID. */\n            *id = si->master_id;\n            id->ms += lpGetInteger(si->lp_ele);\n            si->lp_ele = lpNext(si->lp,si->lp_ele);\n            id->seq += lpGetInteger(si->lp_ele);\n            si->lp_ele = lpNext(si->lp,si->lp_ele);\n            unsigned char buf[sizeof(streamID)];\n            streamEncodeID(buf,id);\n\n            /* The number of entries is here or not depending on the\n             * flags. */\n            if (flags & STREAM_ITEM_FLAG_SAMEFIELDS) {\n                *numfields = si->master_fields_count;\n            } else {\n                *numfields = lpGetInteger(si->lp_ele);\n                si->lp_ele = lpNext(si->lp,si->lp_ele);\n            }\n            serverAssert(*numfields>=0);\n\n            /* If current >= start, and the entry is not marked as\n             * deleted or tombstones are included, emit it. */\n            if (!si->rev) {\n                if (memcmp(buf,si->start_key,sizeof(streamID)) >= 0 &&\n                    (!si->skip_tombstones || !(flags & STREAM_ITEM_FLAG_DELETED)))\n                {\n                    if (memcmp(buf,si->end_key,sizeof(streamID)) > 0)\n                        return 0; /* We are already out of range. */\n                    si->entry_flags = flags;\n                    if (flags & STREAM_ITEM_FLAG_SAMEFIELDS)\n                        si->master_fields_ptr = si->master_fields_start;\n                    return 1; /* Valid item returned. */\n                }\n            } else {\n                if (memcmp(buf,si->end_key,sizeof(streamID)) <= 0 &&\n                    (!si->skip_tombstones || !(flags & STREAM_ITEM_FLAG_DELETED)))\n                {\n                    if (memcmp(buf,si->start_key,sizeof(streamID)) < 0)\n                        return 0; /* We are already out of range. */\n                    si->entry_flags = flags;\n                    if (flags & STREAM_ITEM_FLAG_SAMEFIELDS)\n                        si->master_fields_ptr = si->master_fields_start;\n                    return 1; /* Valid item returned. */\n                }\n            }\n\n            /* If we do not emit, we have to discard if we are going\n             * forward, or seek the previous entry if we are going\n             * backward. */\n            if (!si->rev) {\n                int64_t to_discard = (flags & STREAM_ITEM_FLAG_SAMEFIELDS) ?\n                                      *numfields : *numfields*2;\n                for (int64_t i = 0; i < to_discard; i++)\n                    si->lp_ele = lpNext(si->lp,si->lp_ele);\n            } else {\n                int64_t prev_times = 4; /* flag + id ms + id seq + one more to\n                                           go back to the previous entry \"count\"\n                                           field. */\n                /* If the entry was not flagged SAMEFIELD we also read the\n                 * number of fields, so go back one more. */\n                if (!(flags & STREAM_ITEM_FLAG_SAMEFIELDS)) prev_times++;\n                while(prev_times--) si->lp_ele = lpPrev(si->lp,si->lp_ele);\n            }\n        }\n\n        /* End of listpack reached. Try the next/prev radix tree node. */\n    }\n}\n\n/* Get the field and value of the current item we are iterating. This should\n * be called immediately after streamIteratorGetID(), and for each field\n * according to the number of fields returned by streamIteratorGetID().\n * The function populates the field and value pointers and the corresponding\n * lengths by reference, that are valid until the next iterator call, assuming\n * no one touches the stream meanwhile. */\nvoid streamIteratorGetField(streamIterator *si, unsigned char **fieldptr, unsigned char **valueptr, int64_t *fieldlen, int64_t *valuelen) {\n    if (si->entry_flags & STREAM_ITEM_FLAG_SAMEFIELDS) {\n        *fieldptr = lpGet(si->master_fields_ptr,fieldlen,si->field_buf);\n        si->master_fields_ptr = lpNext(si->lp,si->master_fields_ptr);\n    } else {\n        *fieldptr = lpGet(si->lp_ele,fieldlen,si->field_buf);\n        si->lp_ele = lpNext(si->lp,si->lp_ele);\n    }\n    *valueptr = lpGet(si->lp_ele,valuelen,si->value_buf);\n    si->lp_ele = lpNext(si->lp,si->lp_ele);\n}\n\n/* Remove the current entry from the stream: can be called after the\n * GetID() API or after any GetField() call, however we need to iterate\n * a valid entry while calling this function. Moreover the function\n * requires the entry ID we are currently iterating, that was previously\n * returned by GetID().\n *\n * Note that after calling this function, next calls to GetField() can't\n * be performed: the entry is now deleted. Instead the iterator will\n * automatically re-seek to the next entry, so the caller should continue\n * with GetID(). */\nvoid streamIteratorRemoveEntry(streamIterator *si, streamID *current) {\n    unsigned char *lp = si->lp;\n    int64_t aux;\n\n    /* We do not really delete the entry here. Instead we mark it as\n     * deleted by flagging it, and also incrementing the count of the\n     * deleted entries in the listpack header.\n     *\n     * We start flagging: */\n    int64_t flags = lpGetInteger(si->lp_flags);\n    flags |= STREAM_ITEM_FLAG_DELETED;\n    lp = lpReplaceInteger(lp,&si->lp_flags,flags);\n\n    /* Change the valid/deleted entries count in the master entry. */\n    unsigned char *p = lpFirst(lp);\n    aux = lpGetInteger(p);\n\n    if (aux == 1) {\n        /* If this is the last element in the listpack, we can remove the whole\n         * node. */\n        lpFree(lp);\n        raxRemove(si->stream->rax,si->ri.key,si->ri.key_len,NULL);\n    } else {\n        /* In the base case we alter the counters of valid/deleted entries. */\n        lp = lpReplaceInteger(lp,&p,aux-1);\n        p = lpNext(lp,p); /* Seek deleted field. */\n        aux = lpGetInteger(p);\n        lp = lpReplaceInteger(lp,&p,aux+1);\n\n        /* Update the listpack with the new pointer. */\n        if (si->lp != lp)\n            raxInsert(si->stream->rax,si->ri.key,si->ri.key_len,lp,NULL);\n    }\n\n    /* Update the number of entries counter. */\n    si->stream->length--;\n\n    /* Re-seek the iterator to fix the now messed up state. */\n    streamID start, end;\n    if (si->rev) {\n        streamDecodeID(si->start_key,&start);\n        end = *current;\n    } else {\n        start = *current;\n        streamDecodeID(si->end_key,&end);\n    }\n    streamIteratorStop(si);\n    streamIteratorStart(si,si->stream,&start,&end,si->rev);\n\n    /* TODO: perform a garbage collection here if the ratio between\n     * deleted and valid goes over a certain limit. */\n}\n\n/* Stop the stream iterator. The only cleanup we need is to free the rax\n * iterator, since the stream iterator itself is supposed to be stack\n * allocated. */\nvoid streamIteratorStop(streamIterator *si) {\n    raxStop(&si->ri);\n}\n\n/* Return 1 if `id` exists in `s` (and not marked as deleted) */\nint streamEntryExists(stream *s, streamID *id) {\n    streamIterator si;\n    streamIteratorStart(&si,s,id,id,0);\n    streamID myid;\n    int64_t numfields;\n    int found = streamIteratorGetID(&si,&myid,&numfields);\n    streamIteratorStop(&si);\n    if (!found)\n        return 0;\n    serverAssert(streamCompareID(id,&myid) == 0);\n    return 1;\n}\n\n/* Delete the specified item ID from the stream, returning 1 if the item\n * was deleted 0 otherwise (if it does not exist). */\nint streamDeleteItem(stream *s, streamID *id) {\n    int deleted = 0;\n    streamIterator si;\n    streamIteratorStart(&si,s,id,id,0);\n    streamID myid;\n    int64_t numfields;\n    if (streamIteratorGetID(&si,&myid,&numfields)) {\n        streamIteratorRemoveEntry(&si,&myid);\n        deleted = 1;\n    }\n    streamIteratorStop(&si);\n    return deleted;\n}\n\n/* Get the last valid (non-tombstone) streamID of 's'. */\nvoid streamLastValidID(stream *s, streamID *maxid)\n{\n    streamIterator si;\n    streamIteratorStart(&si,s,NULL,NULL,1);\n    int64_t numfields;\n    if (!streamIteratorGetID(&si,maxid,&numfields) && s->length)\n        serverPanic(\"Corrupt stream, length is %llu, but no max id\", (unsigned long long)s->length);\n    streamIteratorStop(&si);\n}\n\n/* Maximum size for a stream ID string. In theory 20*2+1 should be enough,\n * But to avoid chance for off by one issues and null-term, in case this will\n * be used as parsing buffer, we use a slightly larger buffer. On the other\n * hand considering sds header is gonna add 4 bytes, we wanna keep below the\n * allocator's 48 bytes bin. */\n#define STREAM_ID_STR_LEN 44\n\nsds createStreamIDString(streamID *id) {\n    /* Optimization: pre-allocate a big enough buffer to avoid reallocs. */\n    sds str = sdsnewlen(SDS_NOINIT, STREAM_ID_STR_LEN);\n    sdssetlen(str, 0);\n    return sdscatfmt(str,\"%U-%U\", id->ms,id->seq);\n}\n\n/* Emit a reply in the client output buffer by formatting a Stream ID\n * in the standard <ms>-<seq> format, using the simple string protocol\n * of REPL. */\nvoid addReplyStreamID(client *c, streamID *id) {\n    addReplyBulkSds(c,createStreamIDString(id));\n}\n\nvoid setDeferredReplyStreamID(client *c, void *dr, streamID *id) {\n    setDeferredReplyBulkSds(c, dr, createStreamIDString(id));\n}\n\n/* Similar to the above function, but just creates an object, usually useful\n * for replication purposes to create arguments. */\nrobj *createObjectFromStreamID(streamID *id) {\n    return createObject(OBJ_STRING, createStreamIDString(id));\n}\n\n/* Returns non-zero if the ID is 0-0. */\nint streamIDEqZero(streamID *id) {\n    return !(id->ms || id->seq);\n}\n\n/* A helper that returns non-zero if the range from 'start' to `end`\n * contains a tombstone.\n *\n * NOTE: this assumes that the caller had verified that 'start' is less than\n * 's->last_id'. */\nint streamRangeHasTombstones(stream *s, streamID *start, streamID *end) {\n    streamID start_id, end_id;\n\n    if (!s->length || streamIDEqZero(&s->max_deleted_entry_id)) {\n        /* The stream is empty or has no tombstones. */\n        return 0;\n    }\n\n    if (streamCompareID(&s->first_id,&s->max_deleted_entry_id) > 0) {\n        /* The latest tombstone is before the first entry. */\n        return 0;\n    }\n\n    if (start) {\n        start_id = *start;\n    } else {\n        start_id.ms = 0;\n        start_id.seq = 0;\n    }\n\n    if (end) {\n        end_id = *end;\n    } else {\n        end_id.ms = UINT64_MAX;\n        end_id.seq = UINT64_MAX;\n    }\n\n    if (streamCompareID(&start_id,&s->max_deleted_entry_id) <= 0 &&\n        streamCompareID(&s->max_deleted_entry_id,&end_id) <= 0)\n    {\n        /* start_id <= max_deleted_entry_id <= end_id: The range does include a tombstone. */\n        return 1;\n    }\n\n    /* The range doesn't includes a tombstone. */\n    return 0;\n}\n\n/* Replies with a consumer group's current lag, that is the number of messages\n * in the stream that are yet to be delivered. In case that the lag isn't\n * available due to fragmentation, the reply to the client is a null. */\nvoid streamReplyWithCGLag(client *c, stream *s, streamCG *cg) {\n    int valid = 0;\n    long long lag = 0;\n\n    if (!s->entries_added) {\n        /* The lag of a newly-initialized stream is 0. */\n        lag = 0;\n        valid = 1;\n    } else if (cg->entries_read != SCG_INVALID_ENTRIES_READ && !streamRangeHasTombstones(s,&cg->last_id,NULL)) {\n        /* No fragmentation ahead means that the group's logical reads counter\n         * is valid for performing the lag calculation. */\n        lag = (long long)s->entries_added - cg->entries_read;\n        valid = 1;\n    } else {\n        /* Attempt to retrieve the group's last ID logical read counter. */\n        long long entries_read = streamEstimateDistanceFromFirstEverEntry(s,&cg->last_id);\n        if (entries_read != SCG_INVALID_ENTRIES_READ) {\n            /* A valid counter was obtained. */\n            lag = (long long)s->entries_added - entries_read;\n            valid = 1;\n        }\n    }\n\n    if (valid) {\n        addReplyLongLong(c,lag);\n    } else {\n        addReplyNull(c);\n    }\n}\n\n/* This function returns a value that is the ID's logical read counter, or its\n * distance (the number of entries) from the first entry ever to have been added\n * to the stream.\n * \n * A counter is returned only in one of the following cases:\n * 1. The ID is the same as the stream's last ID. In this case, the returned\n *    is the same as the stream's entries_added counter.\n * 2. The ID equals that of the currently first entry in the stream, and the\n *    stream has no tombstones. The returned value, in this case, is the result\n *    of subtracting the stream's length from its added_entries, incremented by\n *    one.\n * 3. The ID less than the stream's first current entry's ID, and there are no\n *    tombstones. Here the estimated counter is the result of subtracting the\n *    stream's length from its added_entries.\n * 4. The stream's added_entries is zero, meaning that no entries were ever\n *    added.\n *\n * The special return value of ULLONG_MAX signals that the counter's value isn't\n * obtainable. It is returned in these cases:\n * 1. The provided ID, if it even exists, is somewhere between the stream's\n *    current first and last entries' IDs, or in the future.\n * 2. The stream contains one or more tombstones. */\nlong long streamEstimateDistanceFromFirstEverEntry(stream *s, streamID *id) {\n    /* The counter of any ID in an empty, never-before-used stream is 0. */\n    if (!s->entries_added) {\n        return 0;\n    }\n\n    /* In the empty stream, if the ID is smaller or equal to the last ID,\n     * it can set to the current added_entries value. */\n    if (!s->length && streamCompareID(id,&s->last_id) < 1) {\n        return s->entries_added;\n    }\n\n    int cmp_last = streamCompareID(id,&s->last_id);\n    if (cmp_last == 0) {\n        /* Return the exact counter of the last entry in the stream. */\n        return s->entries_added;\n    } else if (cmp_last > 0) {\n        /* The counter of a future ID is unknown. */\n        return SCG_INVALID_ENTRIES_READ;\n    }\n\n    int cmp_id_first = streamCompareID(id,&s->first_id);\n    int cmp_xdel_first = streamCompareID(&s->max_deleted_entry_id,&s->first_id);\n    if (streamIDEqZero(&s->max_deleted_entry_id) || cmp_xdel_first < 0) {\n        /* There's definitely no fragmentation ahead. */\n        if (cmp_id_first < 0) {\n            /* Return the estimated counter. */\n            return s->entries_added - s->length;\n        } else if (cmp_id_first == 0) {\n            /* Return the exact counter of the first entry in the stream. */\n            return s->entries_added - s->length + 1;\n        }\n    }\n\n    /* The ID is either before an XDEL that fragments the stream or an arbitrary\n     * ID. Either case, so we can't make a prediction. */\n    return SCG_INVALID_ENTRIES_READ;\n}\n\n/* As a result of an explicit XCLAIM or XREADGROUP command, new entries\n * are created in the pending list of the stream and consumers. We need\n * to propagate this changes in the form of XCLAIM commands. */\nvoid streamPropagateXCLAIM(client *c, robj *key, streamCG *group, robj *groupname, robj *id, streamNACK *nack) {\n    /* We need to generate an XCLAIM that will work in a idempotent fashion:\n     *\n     * XCLAIM <key> <group> <consumer> 0 <id> TIME <milliseconds-unix-time>\n     *        RETRYCOUNT <count> FORCE JUSTID LASTID <id>.\n     *\n     * Note that JUSTID is useful in order to avoid that XCLAIM will do\n     * useless work in the slave side, trying to fetch the stream item. */\n    robj *argv[14];\n    argv[0] = shared.xclaim;\n    argv[1] = key;\n    argv[2] = groupname;\n    argv[3] = createStringObject(nack->consumer->name,sdslen(nack->consumer->name));\n    argv[4] = shared.integers[0];\n    argv[5] = id;\n    argv[6] = shared.time;\n    argv[7] = createStringObjectFromLongLong(nack->delivery_time);\n    argv[8] = shared.retrycount;\n    argv[9] = createStringObjectFromLongLong(nack->delivery_count);\n    argv[10] = shared.force;\n    argv[11] = shared.justid;\n    argv[12] = shared.lastid;\n    argv[13] = createObjectFromStreamID(&group->last_id);\n\n    alsoPropagate(c->db->id,argv,14,PROPAGATE_AOF|PROPAGATE_REPL);\n\n    decrRefCount(argv[3]);\n    decrRefCount(argv[7]);\n    decrRefCount(argv[9]);\n    decrRefCount(argv[13]);\n}\n\n/* We need this when we want to propagate the new last-id of a consumer group\n * that was consumed by XREADGROUP with the NOACK option: in that case we can't\n * propagate the last ID just using the XCLAIM LASTID option, so we emit\n *\n *  XGROUP SETID <key> <groupname> <id> ENTRIESREAD <entries_read>\n */\nvoid streamPropagateGroupID(client *c, robj *key, streamCG *group, robj *groupname) {\n    robj *argv[7];\n    argv[0] = shared.xgroup;\n    argv[1] = shared.setid;\n    argv[2] = key;\n    argv[3] = groupname;\n    argv[4] = createObjectFromStreamID(&group->last_id);\n    argv[5] = shared.entriesread;\n    argv[6] = createStringObjectFromLongLong(group->entries_read);\n\n    alsoPropagate(c->db->id,argv,7,PROPAGATE_AOF|PROPAGATE_REPL);\n\n    decrRefCount(argv[4]);\n    decrRefCount(argv[6]);\n}\n\n/* We need this when we want to propagate creation of consumer that was created\n * by XREADGROUP with the NOACK option. In that case, the only way to create\n * the consumer at the replica is by using XGROUP CREATECONSUMER (see issue #7140)\n *\n *  XGROUP CREATECONSUMER <key> <groupname> <consumername>\n */\nvoid streamPropagateConsumerCreation(client *c, robj *key, robj *groupname, sds consumername) {\n    robj *argv[5];\n    argv[0] = shared.xgroup;\n    argv[1] = shared.createconsumer;\n    argv[2] = key;\n    argv[3] = groupname;\n    argv[4] = createObject(OBJ_STRING,sdsdup(consumername));\n\n    alsoPropagate(c->db->id,argv,5,PROPAGATE_AOF|PROPAGATE_REPL);\n\n    decrRefCount(argv[4]);\n}\n\n/* Send the stream items in the specified range to the client 'c'. The range\n * the client will receive is between start and end inclusive, if 'count' is\n * non zero, no more than 'count' elements are sent.\n *\n * The 'end' pointer can be NULL to mean that we want all the elements from\n * 'start' till the end of the stream. If 'rev' is non zero, elements are\n * produced in reversed order from end to start.\n *\n * The function returns the number of entries emitted.\n *\n * If group and consumer are not NULL, the function performs additional work:\n * 1. It updates the last delivered ID in the group in case we are\n *    sending IDs greater than the current last ID.\n * 2. If the requested IDs are already assigned to some other consumer, the\n *    function will not return it to the client.\n * 3. An entry in the pending list will be created for every entry delivered\n *    for the first time to this consumer.\n * 4. The group's read counter is incremented if it is already valid and there\n *    are no future tombstones, or is invalidated (set to 0) otherwise. If the\n *    counter is invalid to begin with, we try to obtain it for the last\n *    delivered ID.\n *\n * The behavior may be modified passing non-zero flags:\n *\n * STREAM_RWR_NOACK: Do not create PEL entries, that is, the point \"3\" above\n *                   is not performed.\n * STREAM_RWR_RAWENTRIES: Do not emit array boundaries, but just the entries,\n *                        and return the number of entries emitted as usually.\n *                        This is used when the function is just used in order\n *                        to emit data and there is some higher level logic.\n *\n * The final argument 'spi' (stream propagation info pointer) is a structure\n * filled with information needed to propagate the command execution to AOF\n * and slaves, in the case a consumer group was passed: we need to generate\n * XCLAIM commands to create the pending list into AOF/slaves in that case.\n *\n * If 'spi' is set to NULL no propagation will happen even if the group was\n * given, but currently such a feature is never used by the code base that\n * will always pass 'spi' and propagate when a group is passed.\n *\n * Note that this function is recursive in certain cases. When it's called\n * with a non NULL group and consumer argument, it may call\n * streamReplyWithRangeFromConsumerPEL() in order to get entries from the\n * consumer pending entries list. However such a function will then call\n * streamReplyWithRange() in order to emit single entries (found in the\n * PEL by ID) to the client. This is the use case for the STREAM_RWR_RAWENTRIES\n * flag.\n */\n#define STREAM_RWR_NOACK (1<<0)         /* Do not create entries in the PEL. */\n#define STREAM_RWR_RAWENTRIES (1<<1)    /* Do not emit protocol for array\n                                           boundaries, just the entries. */\n#define STREAM_RWR_HISTORY (1<<2)       /* Only serve consumer local PEL. */\nsize_t streamReplyWithRange(client *c, stream *s, streamID *start, streamID *end, size_t count, int rev, streamCG *group, streamConsumer *consumer, int flags, streamPropInfo *spi) {\n    void *arraylen_ptr = NULL;\n    size_t arraylen = 0;\n    streamIterator si;\n    int64_t numfields;\n    streamID id;\n    int propagate_last_id = 0;\n    int noack = flags & STREAM_RWR_NOACK;\n\n    /* If the client is asking for some history, we serve it using a\n     * different function, so that we return entries *solely* from its\n     * own PEL. This ensures each consumer will always and only see\n     * the history of messages delivered to it and not yet confirmed\n     * as delivered. */\n    if (group && (flags & STREAM_RWR_HISTORY)) {\n        return streamReplyWithRangeFromConsumerPEL(c,s,start,end,count,\n                                                   consumer);\n    }\n\n    if (!(flags & STREAM_RWR_RAWENTRIES))\n        arraylen_ptr = addReplyDeferredLen(c);\n    streamIteratorStart(&si,s,start,end,rev);\n    while(streamIteratorGetID(&si,&id,&numfields)) {\n        /* Update the group last_id if needed. */\n        if (group && streamCompareID(&id,&group->last_id) > 0) {\n            if (group->entries_read != SCG_INVALID_ENTRIES_READ && !streamRangeHasTombstones(s,&id,NULL)) {\n                /* A valid counter and no future tombstones mean we can \n                 * increment the read counter to keep tracking the group's\n                 * progress. */\n                group->entries_read++;\n            } else if (s->entries_added) {\n                /* The group's counter may be invalid, so we try to obtain it. */\n                group->entries_read = streamEstimateDistanceFromFirstEverEntry(s,&id);\n            }\n            group->last_id = id;\n            /* Group last ID should be propagated only if NOACK was\n             * specified, otherwise the last id will be included\n             * in the propagation of XCLAIM itself. */\n            if (noack) propagate_last_id = 1;\n        }\n\n        /* Emit a two elements array for each item. The first is\n         * the ID, the second is an array of field-value pairs. */\n        addReplyArrayLen(c,2);\n        addReplyStreamID(c,&id);\n\n        addReplyArrayLen(c,numfields*2);\n\n        /* Emit the field-value pairs. */\n        while(numfields--) {\n            unsigned char *key, *value;\n            int64_t key_len, value_len;\n            streamIteratorGetField(&si,&key,&value,&key_len,&value_len);\n            addReplyBulkCBuffer(c,key,key_len);\n            addReplyBulkCBuffer(c,value,value_len);\n        }\n\n        /* If a group is passed, we need to create an entry in the\n         * PEL (pending entries list) of this group *and* this consumer.\n         *\n         * Note that we cannot be sure about the fact the message is not\n         * already owned by another consumer, because the admin is able\n         * to change the consumer group last delivered ID using the\n         * XGROUP SETID command. So if we find that there is already\n         * a NACK for the entry, we need to associate it to the new\n         * consumer. */\n        if (group && !noack) {\n            unsigned char buf[sizeof(streamID)];\n            streamEncodeID(buf,&id);\n\n            /* Try to add a new NACK. Most of the time this will work and\n             * will not require extra lookups. We'll fix the problem later\n             * if we find that there is already a entry for this ID. */\n            streamNACK *nack = streamCreateNACK(consumer);\n            int group_inserted =\n                raxTryInsert(group->pel,buf,sizeof(buf),nack,NULL);\n            int consumer_inserted =\n                raxTryInsert(consumer->pel,buf,sizeof(buf),nack,NULL);\n\n            /* Now we can check if the entry was already busy, and\n             * in that case reassign the entry to the new consumer,\n             * or update it if the consumer is the same as before. */\n            if (group_inserted == 0) {\n                streamFreeNACK(nack);\n                nack = raxFind(group->pel,buf,sizeof(buf));\n                serverAssert(nack != raxNotFound);\n                raxRemove(nack->consumer->pel,buf,sizeof(buf),NULL);\n                /* Update the consumer and NACK metadata. */\n                nack->consumer = consumer;\n                nack->delivery_time = mstime();\n                nack->delivery_count = 1;\n                /* Add the entry in the new consumer local PEL. */\n                raxInsert(consumer->pel,buf,sizeof(buf),nack,NULL);\n            } else if (group_inserted == 1 && consumer_inserted == 0) {\n                serverPanic(\"NACK half-created. Should not be possible.\");\n            }\n\n            /* Propagate as XCLAIM. */\n            if (spi) {\n                robj *idarg = createObjectFromStreamID(&id);\n                streamPropagateXCLAIM(c,spi->keyname,group,spi->groupname,idarg,nack);\n                decrRefCount(idarg);\n            }\n        }\n\n        arraylen++;\n        if (count && count == arraylen) break;\n    }\n\n    if (spi && propagate_last_id)\n        streamPropagateGroupID(c,spi->keyname,group,spi->groupname);\n\n    streamIteratorStop(&si);\n    if (arraylen_ptr) setDeferredArrayLen(c,arraylen_ptr,arraylen);\n    return arraylen;\n}\n\n/* This is a helper function for streamReplyWithRange() when called with\n * group and consumer arguments, but with a range that is referring to already\n * delivered messages. In this case we just emit messages that are already\n * in the history of the consumer, fetching the IDs from its PEL.\n *\n * Note that this function does not have a 'rev' argument because it's not\n * possible to iterate in reverse using a group. Basically this function\n * is only called as a result of the XREADGROUP command.\n *\n * This function is more expensive because it needs to inspect the PEL and then\n * seek into the radix tree of the messages in order to emit the full message\n * to the client. However clients only reach this code path when they are\n * fetching the history of already retrieved messages, which is rare. */\nsize_t streamReplyWithRangeFromConsumerPEL(client *c, stream *s, streamID *start, streamID *end, size_t count, streamConsumer *consumer) {\n    raxIterator ri;\n    unsigned char startkey[sizeof(streamID)];\n    unsigned char endkey[sizeof(streamID)];\n    streamEncodeID(startkey,start);\n    if (end) streamEncodeID(endkey,end);\n\n    size_t arraylen = 0;\n    void *arraylen_ptr = addReplyDeferredLen(c);\n    raxStart(&ri,consumer->pel);\n    raxSeek(&ri,\">=\",startkey,sizeof(startkey));\n    while(raxNext(&ri) && (!count || arraylen < count)) {\n        if (end && memcmp(ri.key,end,ri.key_len) > 0) break;\n        streamID thisid;\n        streamDecodeID(ri.key,&thisid);\n        if (streamReplyWithRange(c,s,&thisid,&thisid,1,0,NULL,NULL,\n                                 STREAM_RWR_RAWENTRIES,NULL) == 0)\n        {\n            /* Note that we may have a not acknowledged entry in the PEL\n             * about a message that's no longer here because was removed\n             * by the user by other means. In that case we signal it emitting\n             * the ID but then a NULL entry for the fields. */\n            addReplyArrayLen(c,2);\n            addReplyStreamID(c,&thisid);\n            addReplyNullArray(c);\n        } else {\n            streamNACK *nack = ri.data;\n            nack->delivery_time = mstime();\n            nack->delivery_count++;\n        }\n        arraylen++;\n    }\n    raxStop(&ri);\n    setDeferredArrayLen(c,arraylen_ptr,arraylen);\n    return arraylen;\n}\n\n/* -----------------------------------------------------------------------\n * Stream commands implementation\n * ----------------------------------------------------------------------- */\n\n/* Look the stream at 'key' and return the corresponding stream object.\n * The function creates a key setting it to an empty stream if needed. */\nrobj *streamTypeLookupWriteOrCreate(client *c, robj *key, int no_create) {\n    robj *o = lookupKeyWrite(c->db,key);\n    if (checkType(c,o,OBJ_STREAM)) return NULL;\n    if (o == NULL) {\n        if (no_create) {\n            addReplyNull(c);\n            return NULL;\n        }\n        o = createStreamObject();\n        dbAdd(c->db,key,o);\n    }\n    return o;\n}\n\n/* Parse a stream ID in the format given by clients to Redis, that is\n * <ms>-<seq>, and converts it into a streamID structure. If\n * the specified ID is invalid C_ERR is returned and an error is reported\n * to the client, otherwise C_OK is returned. The ID may be in incomplete\n * form, just stating the milliseconds time part of the stream. In such a case\n * the missing part is set according to the value of 'missing_seq' parameter.\n *\n * The IDs \"-\" and \"+\" specify respectively the minimum and maximum IDs\n * that can be represented. If 'strict' is set to 1, \"-\" and \"+\" will be\n * treated as an invalid ID.\n *\n * The ID form <ms>-* specifies a millisconds-only ID, leaving the sequence part\n * to be autogenerated. When a non-NULL 'seq_given' argument is provided, this\n * form is accepted and the argument is set to 0 unless the sequence part is\n * specified.\n * \n * If 'c' is set to NULL, no reply is sent to the client. */\nint streamGenericParseIDOrReply(client *c, const robj *o, streamID *id, uint64_t missing_seq, int strict, int *seq_given) {\n    char buf[128];\n    if (sdslen(o->ptr) > sizeof(buf)-1) goto invalid;\n    memcpy(buf,o->ptr,sdslen(o->ptr)+1);\n\n    if (strict && (buf[0] == '-' || buf[0] == '+') && buf[1] == '\\0')\n        goto invalid;\n\n    if (seq_given != NULL) {\n        *seq_given = 1;\n    }\n\n    /* Handle the \"-\" and \"+\" special cases. */\n    if (buf[0] == '-' && buf[1] == '\\0') {\n        id->ms = 0;\n        id->seq = 0;\n        return C_OK;\n    } else if (buf[0] == '+' && buf[1] == '\\0') {\n        id->ms = UINT64_MAX;\n        id->seq = UINT64_MAX;\n        return C_OK;\n    }\n\n    /* Parse <ms>-<seq> form. */\n    unsigned long long ms, seq;\n    char *dot = strchr(buf,'-');\n    if (dot) *dot = '\\0';\n    if (string2ull(buf,&ms) == 0) goto invalid;\n    if (dot) {\n        size_t seqlen = strlen(dot+1);\n        if (seq_given != NULL && seqlen == 1 && *(dot + 1) == '*') {\n            /* Handle the <ms>-* form. */\n            seq = 0;\n            *seq_given = 0;\n        } else if (string2ull(dot+1,&seq) == 0) {\n            goto invalid;\n        }\n    } else {\n        seq = missing_seq;\n    }\n    id->ms = ms;\n    id->seq = seq;\n    return C_OK;\n\ninvalid:\n    if (c) addReplyError(c,\"Invalid stream ID specified as stream \"\n                           \"command argument\");\n    return C_ERR;\n}\n\n/* Wrapper for streamGenericParseIDOrReply() used by module API. */\nint streamParseID(const robj *o, streamID *id) {\n    return streamGenericParseIDOrReply(NULL,o,id,0,0,NULL);\n}\n\n/* Wrapper for streamGenericParseIDOrReply() with 'strict' argument set to\n * 0, to be used when - and + are acceptable IDs. */\nint streamParseIDOrReply(client *c, robj *o, streamID *id, uint64_t missing_seq) {\n    return streamGenericParseIDOrReply(c,o,id,missing_seq,0,NULL);\n}\n\n/* Wrapper for streamGenericParseIDOrReply() with 'strict' argument set to\n * 1, to be used when we want to return an error if the special IDs + or -\n * are provided. */\nint streamParseStrictIDOrReply(client *c, robj *o, streamID *id, uint64_t missing_seq, int *seq_given) {\n    return streamGenericParseIDOrReply(c,o,id,missing_seq,1,seq_given);\n}\n\n/* Helper for parsing a stream ID that is a range query interval. When the\n * exclude argument is NULL, streamParseIDOrReply() is called and the interval\n * is treated as close (inclusive). Otherwise, the exclude argument is set if \n * the interval is open (the \"(\" prefix) and streamParseStrictIDOrReply() is\n * called in that case.\n */\nint streamParseIntervalIDOrReply(client *c, robj *o, streamID *id, int *exclude, uint64_t missing_seq) {\n    char *p = o->ptr;\n    size_t len = sdslen(p);\n    int invalid = 0;\n    \n    if (exclude != NULL) *exclude = (len > 1 && p[0] == '(');\n    if (exclude != NULL && *exclude) {\n        robj *t = createStringObject(p+1,len-1);\n        invalid = (streamParseStrictIDOrReply(c,t,id,missing_seq,NULL) == C_ERR);\n        decrRefCount(t);\n    } else \n        invalid = (streamParseIDOrReply(c,o,id,missing_seq) == C_ERR);\n    if (invalid)\n        return C_ERR;\n    return C_OK;\n}\n\nvoid streamRewriteApproxSpecifier(client *c, int idx) {\n    rewriteClientCommandArgument(c,idx,shared.special_equals);\n}\n\n/* We propagate MAXLEN/MINID ~ <count> as MAXLEN/MINID = <resulting-len-of-stream>\n * otherwise trimming is no longer deterministic on replicas / AOF. */\nvoid streamRewriteTrimArgument(client *c, stream *s, int trim_strategy, int idx) {\n    robj *arg;\n    if (trim_strategy == TRIM_STRATEGY_MAXLEN) {\n        arg = createStringObjectFromLongLong(s->length);\n    } else {\n        streamID first_id;\n        streamGetEdgeID(s,1,0,&first_id);\n        arg = createObjectFromStreamID(&first_id);\n    }\n\n    rewriteClientCommandArgument(c,idx,arg);\n    decrRefCount(arg);\n}\n\n/* XADD key [(MAXLEN [~|=] <count> | MINID [~|=] <id>) [LIMIT <entries>]] [NOMKSTREAM] <ID or *> [field value] [field value] ... */\nvoid xaddCommand(client *c) {\n    /* Parse options. */\n    streamAddTrimArgs parsed_args;\n    int idpos = streamParseAddOrTrimArgsOrReply(c, &parsed_args, 1);\n    if (idpos < 0)\n        return; /* streamParseAddOrTrimArgsOrReply already replied. */\n    int field_pos = idpos+1; /* The ID is always one argument before the first field */\n\n    /* Check arity. */\n    if ((c->argc - field_pos) < 2 || ((c->argc-field_pos) % 2) == 1) {\n        addReplyErrorArity(c);\n        return;\n    }\n\n    /* Return ASAP if minimal ID (0-0) was given so we avoid possibly creating\n     * a new stream and have streamAppendItem fail, leaving an empty key in the\n     * database. */\n    if (parsed_args.id_given && parsed_args.seq_given &&\n        parsed_args.id.ms == 0 && parsed_args.id.seq == 0)\n    {\n        addReplyError(c,\"The ID specified in XADD must be greater than 0-0\");\n        return;\n    }\n\n    /* Lookup the stream at key. */\n    robj *o;\n    stream *s;\n    if ((o = streamTypeLookupWriteOrCreate(c,c->argv[1],parsed_args.no_mkstream)) == NULL) return;\n    s = o->ptr;\n\n    /* Return ASAP if the stream has reached the last possible ID */\n    if (s->last_id.ms == UINT64_MAX && s->last_id.seq == UINT64_MAX) {\n        addReplyError(c,\"The stream has exhausted the last possible ID, \"\n                        \"unable to add more items\");\n        return;\n    }\n\n    /* Append using the low level function and return the ID. */\n    streamID id;\n    if (streamAppendItem(s,c->argv+field_pos,(c->argc-field_pos)/2,\n        &id,parsed_args.id_given ? &parsed_args.id : NULL,parsed_args.seq_given) == C_ERR)\n    {\n        if (errno == EDOM)\n            addReplyError(c,\"The ID specified in XADD is equal or smaller than \"\n                            \"the target stream top item\");\n        else\n            addReplyError(c,\"Elements are too large to be stored\");\n        return;\n    }\n    sds replyid = createStreamIDString(&id);\n    addReplyBulkCBuffer(c, replyid, sdslen(replyid));\n\n    signalModifiedKey(c,c->db,c->argv[1]);\n    notifyKeyspaceEvent(NOTIFY_STREAM,\"xadd\",c->argv[1],c->db->id);\n    server.dirty++;\n\n    /* Trim if needed. */\n    if (parsed_args.trim_strategy != TRIM_STRATEGY_NONE) {\n        if (streamTrim(s, &parsed_args)) {\n            notifyKeyspaceEvent(NOTIFY_STREAM,\"xtrim\",c->argv[1],c->db->id);\n        }\n        if (parsed_args.approx_trim) {\n            /* In case our trimming was limited (by LIMIT or by ~) we must\n             * re-write the relevant trim argument to make sure there will be\n             * no inconsistencies in AOF loading or in the replica.\n             * It's enough to check only args->approx because there is no\n             * way LIMIT is given without the ~ option. */\n            streamRewriteApproxSpecifier(c,parsed_args.trim_strategy_arg_idx-1);\n            streamRewriteTrimArgument(c,s,parsed_args.trim_strategy,parsed_args.trim_strategy_arg_idx);\n        }\n    }\n\n    /* Let's rewrite the ID argument with the one actually generated for\n     * AOF/replication propagation. */\n    if (!parsed_args.id_given || !parsed_args.seq_given) {\n        robj *idarg = createObject(OBJ_STRING, replyid);\n        rewriteClientCommandArgument(c, idpos, idarg);\n        decrRefCount(idarg);\n    } else {\n        sdsfree(replyid);\n    }\n\n    /* We need to signal to blocked clients that there is new data on this\n     * stream. */\n    signalKeyAsReady(c->db, c->argv[1], OBJ_STREAM);\n}\n\n/* XRANGE/XREVRANGE actual implementation.\n * The 'start' and 'end' IDs are parsed as follows:\n *   Incomplete 'start' has its sequence set to 0, and 'end' to UINT64_MAX.\n *   \"-\" and \"+\"\" mean the minimal and maximal ID values, respectively.\n *   The \"(\" prefix means an open (exclusive) range, so XRANGE stream (1-0 (2-0\n *   will match anything from 1-1 and 1-UINT64_MAX.\n */\nvoid xrangeGenericCommand(client *c, int rev) {\n    robj *o;\n    stream *s;\n    streamID startid, endid;\n    long long count = -1;\n    robj *startarg = rev ? c->argv[3] : c->argv[2];\n    robj *endarg = rev ? c->argv[2] : c->argv[3];\n    int startex = 0, endex = 0;\n    \n    /* Parse start and end IDs. */\n    if (streamParseIntervalIDOrReply(c,startarg,&startid,&startex,0) != C_OK)\n        return;\n    if (startex && streamIncrID(&startid) != C_OK) {\n        addReplyError(c,\"invalid start ID for the interval\");\n        return;\n    }\n    if (streamParseIntervalIDOrReply(c,endarg,&endid,&endex,UINT64_MAX) != C_OK)\n        return;\n    if (endex && streamDecrID(&endid) != C_OK) {\n        addReplyError(c,\"invalid end ID for the interval\");\n        return;\n    }\n\n    /* Parse the COUNT option if any. */\n    if (c->argc > 4) {\n        for (int j = 4; j < c->argc; j++) {\n            int additional = c->argc-j-1;\n            if (strcasecmp(c->argv[j]->ptr,\"COUNT\") == 0 && additional >= 1) {\n                if (getLongLongFromObjectOrReply(c,c->argv[j+1],&count,NULL)\n                    != C_OK) return;\n                if (count < 0) count = 0;\n                j++; /* Consume additional arg. */\n            } else {\n                addReplyErrorObject(c,shared.syntaxerr);\n                return;\n            }\n        }\n    }\n\n    /* Return the specified range to the user. */\n    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.emptyarray)) == NULL ||\n         checkType(c,o,OBJ_STREAM)) return;\n\n    s = o->ptr;\n\n    if (count == 0) {\n        addReplyNullArray(c);\n    } else {\n        if (count == -1) count = 0;\n        streamReplyWithRange(c,s,&startid,&endid,count,rev,NULL,NULL,0,NULL);\n    }\n}\n\n/* XRANGE key start end [COUNT <n>] */\nvoid xrangeCommand(client *c) {\n    xrangeGenericCommand(c,0);\n}\n\n/* XREVRANGE key end start [COUNT <n>] */\nvoid xrevrangeCommand(client *c) {\n    xrangeGenericCommand(c,1);\n}\n\n/* XLEN */\nvoid xlenCommand(client *c) {\n    robj *o;\n    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL\n        || checkType(c,o,OBJ_STREAM)) return;\n    stream *s = o->ptr;\n    addReplyLongLong(c,s->length);\n}\n\n/* XREAD [BLOCK <milliseconds>] [COUNT <count>] STREAMS key_1 key_2 ... key_N\n *       ID_1 ID_2 ... ID_N\n *\n * This function also implements the XREAD-GROUP command, which is like XREAD\n * but accepting the [GROUP group-name consumer-name] additional option.\n * This is useful because while XREAD is a read command and can be called\n * on slaves, XREAD-GROUP is not. */\n#define XREAD_BLOCKED_DEFAULT_COUNT 1000\nvoid xreadCommand(client *c) {\n    long long timeout = -1; /* -1 means, no BLOCK argument given. */\n    long long count = 0;\n    int streams_count = 0;\n    int streams_arg = 0;\n    int noack = 0;          /* True if NOACK option was specified. */\n    streamID static_ids[STREAMID_STATIC_VECTOR_LEN];\n    streamID *ids = static_ids;\n    streamCG **groups = NULL;\n    int xreadgroup = sdslen(c->argv[0]->ptr) == 10; /* XREAD or XREADGROUP? */\n    robj *groupname = NULL;\n    robj *consumername = NULL;\n\n    /* Parse arguments. */\n    for (int i = 1; i < c->argc; i++) {\n        int moreargs = c->argc-i-1;\n        char *o = c->argv[i]->ptr;\n        if (!strcasecmp(o,\"BLOCK\") && moreargs) {\n            if (c->flags & CLIENT_SCRIPT) {\n                /*\n                 * Although the CLIENT_DENY_BLOCKING flag should protect from blocking the client\n                 * on Lua/MULTI/RM_Call we want special treatment for Lua to keep backward compatibility.\n                 * There is no sense to use BLOCK option within Lua. */\n                addReplyErrorFormat(c, \"%s command is not allowed with BLOCK option from scripts\", (char *)c->argv[0]->ptr);\n                return;\n            }\n            i++;\n            if (getTimeoutFromObjectOrReply(c,c->argv[i],&timeout,\n                UNIT_MILLISECONDS) != C_OK) return;\n        } else if (!strcasecmp(o,\"COUNT\") && moreargs) {\n            i++;\n            if (getLongLongFromObjectOrReply(c,c->argv[i],&count,NULL) != C_OK)\n                return;\n            if (count < 0) count = 0;\n        } else if (!strcasecmp(o,\"STREAMS\") && moreargs) {\n            streams_arg = i+1;\n            streams_count = (c->argc-streams_arg);\n            if ((streams_count % 2) != 0) {\n                addReplyError(c,\"Unbalanced XREAD list of streams: \"\n                                \"for each stream key an ID or '$' must be \"\n                                \"specified.\");\n                return;\n            }\n            streams_count /= 2; /* We have two arguments for each stream. */\n            break;\n        } else if (!strcasecmp(o,\"GROUP\") && moreargs >= 2) {\n            if (!xreadgroup) {\n                addReplyError(c,\"The GROUP option is only supported by \"\n                                \"XREADGROUP. You called XREAD instead.\");\n                return;\n            }\n            groupname = c->argv[i+1];\n            consumername = c->argv[i+2];\n            i += 2;\n        } else if (!strcasecmp(o,\"NOACK\")) {\n            if (!xreadgroup) {\n                addReplyError(c,\"The NOACK option is only supported by \"\n                                \"XREADGROUP. You called XREAD instead.\");\n                return;\n            }\n            noack = 1;\n        } else {\n            addReplyErrorObject(c,shared.syntaxerr);\n            return;\n        }\n    }\n\n    /* STREAMS option is mandatory. */\n    if (streams_arg == 0) {\n        addReplyErrorObject(c,shared.syntaxerr);\n        return;\n    }\n\n    /* If the user specified XREADGROUP then it must also\n     * provide the GROUP option. */\n    if (xreadgroup && groupname == NULL) {\n        addReplyError(c,\"Missing GROUP option for XREADGROUP\");\n        return;\n    }\n\n    /* Parse the IDs and resolve the group name. */\n    if (streams_count > STREAMID_STATIC_VECTOR_LEN)\n        ids = zmalloc(sizeof(streamID)*streams_count);\n    if (groupname) groups = zmalloc(sizeof(streamCG*)*streams_count);\n\n    for (int i = streams_arg + streams_count; i < c->argc; i++) {\n        /* Specifying \"$\" as last-known-id means that the client wants to be\n         * served with just the messages that will arrive into the stream\n         * starting from now. */\n        int id_idx = i - streams_arg - streams_count;\n        robj *key = c->argv[i-streams_count];\n        robj *o = lookupKeyRead(c->db,key);\n        if (checkType(c,o,OBJ_STREAM)) goto cleanup;\n        streamCG *group = NULL;\n\n        /* If a group was specified, than we need to be sure that the\n         * key and group actually exist. */\n        if (groupname) {\n            if (o == NULL ||\n                (group = streamLookupCG(o->ptr,groupname->ptr)) == NULL)\n            {\n                addReplyErrorFormat(c, \"-NOGROUP No such key '%s' or consumer \"\n                                       \"group '%s' in XREADGROUP with GROUP \"\n                                       \"option\",\n                                    (char*)key->ptr,(char*)groupname->ptr);\n                goto cleanup;\n            }\n            groups[id_idx] = group;\n        }\n\n        if (strcmp(c->argv[i]->ptr,\"$\") == 0) {\n            if (xreadgroup) {\n                addReplyError(c,\"The $ ID is meaningless in the context of \"\n                                \"XREADGROUP: you want to read the history of \"\n                                \"this consumer by specifying a proper ID, or \"\n                                \"use the > ID to get new messages. The $ ID would \"\n                                \"just return an empty result set.\");\n                goto cleanup;\n            }\n            if (o) {\n                stream *s = o->ptr;\n                ids[id_idx] = s->last_id;\n            } else {\n                ids[id_idx].ms = 0;\n                ids[id_idx].seq = 0;\n            }\n            continue;\n        } else if (strcmp(c->argv[i]->ptr,\">\") == 0) {\n            if (!xreadgroup) {\n                addReplyError(c,\"The > ID can be specified only when calling \"\n                                \"XREADGROUP using the GROUP <group> \"\n                                \"<consumer> option.\");\n                goto cleanup;\n            }\n            /* We use just the maximum ID to signal this is a \">\" ID, anyway\n             * the code handling the blocking clients will have to update the\n             * ID later in order to match the changing consumer group last ID. */\n            ids[id_idx].ms = UINT64_MAX;\n            ids[id_idx].seq = UINT64_MAX;\n            continue;\n        }\n        if (streamParseStrictIDOrReply(c,c->argv[i],ids+id_idx,0,NULL) != C_OK)\n            goto cleanup;\n    }\n\n    /* Try to serve the client synchronously. */\n    size_t arraylen = 0;\n    void *arraylen_ptr = NULL;\n    for (int i = 0; i < streams_count; i++) {\n        robj *o = lookupKeyRead(c->db,c->argv[streams_arg+i]);\n        if (o == NULL) continue;\n        stream *s = o->ptr;\n        streamID *gt = ids+i; /* ID must be greater than this. */\n        int serve_synchronously = 0;\n        int serve_history = 0; /* True for XREADGROUP with ID != \">\". */\n\n        /* Check if there are the conditions to serve the client\n         * synchronously. */\n        if (groups) {\n            /* If the consumer is blocked on a group, we always serve it\n             * synchronously (serving its local history) if the ID specified\n             * was not the special \">\" ID. */\n            if (gt->ms != UINT64_MAX ||\n                gt->seq != UINT64_MAX)\n            {\n                serve_synchronously = 1;\n                serve_history = 1;\n            } else if (s->length) {\n                /* We also want to serve a consumer in a consumer group\n                 * synchronously in case the group top item delivered is smaller\n                 * than what the stream has inside. */\n                streamID maxid, *last = &groups[i]->last_id;\n                streamLastValidID(s, &maxid);\n                if (streamCompareID(&maxid, last) > 0) {\n                    serve_synchronously = 1;\n                    *gt = *last;\n                }\n            }\n        } else if (s->length) {\n            /* For consumers without a group, we serve synchronously if we can\n             * actually provide at least one item from the stream. */\n            streamID maxid;\n            streamLastValidID(s, &maxid);\n            if (streamCompareID(&maxid, gt) > 0) {\n                serve_synchronously = 1;\n            }\n        }\n\n        if (serve_synchronously) {\n            arraylen++;\n            if (arraylen == 1) arraylen_ptr = addReplyDeferredLen(c);\n            /* streamReplyWithRange() handles the 'start' ID as inclusive,\n             * so start from the next ID, since we want only messages with\n             * IDs greater than start. */\n            streamID start = *gt;\n            streamIncrID(&start);\n\n            /* Emit the two elements sub-array consisting of the name\n             * of the stream and the data we extracted from it. */\n            if (c->resp == 2) addReplyArrayLen(c,2);\n            addReplyBulk(c,c->argv[streams_arg+i]);\n            streamConsumer *consumer = NULL;\n            streamPropInfo spi = {c->argv[i+streams_arg],groupname};\n            if (groups) {\n                consumer = streamLookupConsumer(groups[i],consumername->ptr,SLC_DEFAULT);\n                if (consumer == NULL) {\n                    consumer = streamCreateConsumer(groups[i],consumername->ptr,\n                                                    c->argv[streams_arg+i],\n                                                    c->db->id,SCC_DEFAULT);\n                    if (noack)\n                        streamPropagateConsumerCreation(c,spi.keyname,\n                                                        spi.groupname,\n                                                        consumer->name);\n                }\n            }\n            int flags = 0;\n            if (noack) flags |= STREAM_RWR_NOACK;\n            if (serve_history) flags |= STREAM_RWR_HISTORY;\n            streamReplyWithRange(c,s,&start,NULL,count,0,\n                                 groups ? groups[i] : NULL,\n                                 consumer, flags, &spi);\n            if (groups) server.dirty++;\n        }\n    }\n\n     /* We replied synchronously! Set the top array len and return to caller. */\n    if (arraylen) {\n        if (c->resp == 2)\n            setDeferredArrayLen(c,arraylen_ptr,arraylen);\n        else\n            setDeferredMapLen(c,arraylen_ptr,arraylen);\n        goto cleanup;\n    }\n\n    /* Block if needed. */\n    if (timeout != -1) {\n        /* If we are not allowed to block the client, the only thing\n         * we can do is treating it as a timeout (even with timeout 0). */\n        if (c->flags & CLIENT_DENY_BLOCKING) {\n            addReplyNullArray(c);\n            goto cleanup;\n        }\n        blockForKeys(c, BLOCKED_STREAM, c->argv+streams_arg, streams_count,\n                     -1, timeout, NULL, NULL, ids);\n        /* If no COUNT is given and we block, set a relatively small count:\n         * in case the ID provided is too low, we do not want the server to\n         * block just to serve this client a huge stream of messages. */\n        c->bpop.xread_count = count ? count : XREAD_BLOCKED_DEFAULT_COUNT;\n\n        /* If this is a XREADGROUP + GROUP we need to remember for which\n         * group and consumer name we are blocking, so later when one of the\n         * keys receive more data, we can call streamReplyWithRange() passing\n         * the right arguments. */\n        if (groupname) {\n            incrRefCount(groupname);\n            incrRefCount(consumername);\n            c->bpop.xread_group = groupname;\n            c->bpop.xread_consumer = consumername;\n            c->bpop.xread_group_noack = noack;\n        } else {\n            c->bpop.xread_group = NULL;\n            c->bpop.xread_consumer = NULL;\n        }\n        goto cleanup;\n    }\n\n    /* No BLOCK option, nor any stream we can serve. Reply as with a\n     * timeout happened. */\n    addReplyNullArray(c);\n    /* Continue to cleanup... */\n\ncleanup: /* Cleanup. */\n\n    /* The command is propagated (in the READGROUP form) as a side effect\n     * of calling lower level APIs. So stop any implicit propagation. */\n    preventCommandPropagation(c);\n    if (ids != static_ids) zfree(ids);\n    zfree(groups);\n}\n\n/* -----------------------------------------------------------------------\n * Low level implementation of consumer groups\n * ----------------------------------------------------------------------- */\n\n/* Create a NACK entry setting the delivery count to 1 and the delivery\n * time to the current time. The NACK consumer will be set to the one\n * specified as argument of the function. */\nstreamNACK *streamCreateNACK(streamConsumer *consumer) {\n    streamNACK *nack = zmalloc(sizeof(*nack));\n    nack->delivery_time = mstime();\n    nack->delivery_count = 1;\n    nack->consumer = consumer;\n    return nack;\n}\n\n/* Free a NACK entry. */\nvoid streamFreeNACK(streamNACK *na) {\n    zfree(na);\n}\n\n/* Free a consumer and associated data structures. Note that this function\n * will not reassign the pending messages associated with this consumer\n * nor will delete them from the stream, so when this function is called\n * to delete a consumer, and not when the whole stream is destroyed, the caller\n * should do some work before. */\nvoid streamFreeConsumer(streamConsumer *sc) {\n    raxFree(sc->pel); /* No value free callback: the PEL entries are shared\n                         between the consumer and the main stream PEL. */\n    sdsfree(sc->name);\n    zfree(sc);\n}\n\n/* Create a new consumer group in the context of the stream 's', having the\n * specified name, last server ID and reads counter. If a consumer group with\n * the same name already exists NULL is returned, otherwise the pointer to the\n * consumer group is returned. */\nstreamCG *streamCreateCG(stream *s, char *name, size_t namelen, streamID *id, long long entries_read) {\n    if (s->cgroups == NULL) s->cgroups = raxNew();\n    if (raxFind(s->cgroups,(unsigned char*)name,namelen) != raxNotFound)\n        return NULL;\n\n    streamCG *cg = zmalloc(sizeof(*cg));\n    cg->pel = raxNew();\n    cg->consumers = raxNew();\n    cg->last_id = *id;\n    cg->entries_read = entries_read;\n    raxInsert(s->cgroups,(unsigned char*)name,namelen,cg,NULL);\n    return cg;\n}\n\n/* Free a consumer group and all its associated data. */\nvoid streamFreeCG(streamCG *cg) {\n    raxFreeWithCallback(cg->pel,(void(*)(void*))streamFreeNACK);\n    raxFreeWithCallback(cg->consumers,(void(*)(void*))streamFreeConsumer);\n    zfree(cg);\n}\n\n/* Lookup the consumer group in the specified stream and returns its\n * pointer, otherwise if there is no such group, NULL is returned. */\nstreamCG *streamLookupCG(stream *s, sds groupname) {\n    if (s->cgroups == NULL) return NULL;\n    streamCG *cg = raxFind(s->cgroups,(unsigned char*)groupname,\n                           sdslen(groupname));\n    return (cg == raxNotFound) ? NULL : cg;\n}\n\n/* Create a consumer with the specified name in the group 'cg' and return.\n * If the consumer exists, return NULL. As a side effect, when the consumer\n * is successfully created, the key space will be notified and dirty++ unless\n * the SCC_NO_NOTIFY or SCC_NO_DIRTIFY flags is specified. */\nstreamConsumer *streamCreateConsumer(streamCG *cg, sds name, robj *key, int dbid, int flags) {\n    if (cg == NULL) return NULL;\n    int notify = !(flags & SCC_NO_NOTIFY);\n    int dirty = !(flags & SCC_NO_DIRTIFY);\n    streamConsumer *consumer = zmalloc(sizeof(*consumer));\n    int success = raxTryInsert(cg->consumers,(unsigned char*)name,\n                               sdslen(name),consumer,NULL);\n    if (!success) {\n        zfree(consumer);\n        return NULL;\n    }\n    consumer->name = sdsdup(name);\n    consumer->pel = raxNew();\n    consumer->seen_time = mstime();\n    if (dirty) server.dirty++;\n    if (notify) notifyKeyspaceEvent(NOTIFY_STREAM,\"xgroup-createconsumer\",key,dbid);\n    return consumer;\n}\n\n/* Lookup the consumer with the specified name in the group 'cg'. Its last \n * seen time is updated unless the SLC_NO_REFRESH flag is specified. */\nstreamConsumer *streamLookupConsumer(streamCG *cg, sds name, int flags) {\n    if (cg == NULL) return NULL;\n    int refresh = !(flags & SLC_NO_REFRESH);\n    streamConsumer *consumer = raxFind(cg->consumers,(unsigned char*)name,\n                                       sdslen(name));\n    if (consumer == raxNotFound) return NULL;\n    if (refresh) consumer->seen_time = mstime();\n    return consumer;\n}\n\n/* Delete the consumer specified in the consumer group 'cg'. */\nvoid streamDelConsumer(streamCG *cg, streamConsumer *consumer) {\n    /* Iterate all the consumer pending messages, deleting every corresponding\n     * entry from the global entry. */\n    raxIterator ri;\n    raxStart(&ri,consumer->pel);\n    raxSeek(&ri,\"^\",NULL,0);\n    while(raxNext(&ri)) {\n        streamNACK *nack = ri.data;\n        raxRemove(cg->pel,ri.key,ri.key_len,NULL);\n        streamFreeNACK(nack);\n    }\n    raxStop(&ri);\n\n    /* Deallocate the consumer. */\n    raxRemove(cg->consumers,(unsigned char*)consumer->name,\n              sdslen(consumer->name),NULL);\n    streamFreeConsumer(consumer);\n}\n\n/* -----------------------------------------------------------------------\n * Consumer groups commands\n * ----------------------------------------------------------------------- */\n\n/* XGROUP CREATE <key> <groupname> <id or $> [MKSTREAM] [ENTRIESADDED count]\n * XGROUP SETID <key> <groupname> <id or $> [ENTRIESADDED count]\n * XGROUP DESTROY <key> <groupname>\n * XGROUP CREATECONSUMER <key> <groupname> <consumer>\n * XGROUP DELCONSUMER <key> <groupname> <consumername> */\nvoid xgroupCommand(client *c) {\n    stream *s = NULL;\n    sds grpname = NULL;\n    streamCG *cg = NULL;\n    char *opt = c->argv[1]->ptr; /* Subcommand name. */\n    int mkstream = 0;\n    long long entries_read = SCG_INVALID_ENTRIES_READ;\n    robj *o;\n\n    /* Everything but the \"HELP\" option requires a key and group name. */\n    if (c->argc >= 4) {\n        /* Parse optional arguments for CREATE and SETID */\n        int i = 5;\n        int create_subcmd = !strcasecmp(opt,\"CREATE\");\n        int setid_subcmd = !strcasecmp(opt,\"SETID\");\n        while (i < c->argc) {\n            if (create_subcmd && !strcasecmp(c->argv[i]->ptr,\"MKSTREAM\")) {\n                mkstream = 1;\n                i++;\n            } else if ((create_subcmd || setid_subcmd) && !strcasecmp(c->argv[i]->ptr,\"ENTRIESREAD\") && i + 1 < c->argc) {\n                if (getLongLongFromObjectOrReply(c,c->argv[i+1],&entries_read,NULL) != C_OK)\n                    return;\n                if (entries_read < 0 && entries_read != SCG_INVALID_ENTRIES_READ) {\n                    addReplyError(c,\"value for ENTRIESREAD must be positive or -1\");\n                    return;\n                }\n                i += 2;\n            } else {\n                addReplySubcommandSyntaxError(c);\n                return;\n            }\n        }\n\n        o = lookupKeyWrite(c->db,c->argv[2]);\n        if (o) {\n            if (checkType(c,o,OBJ_STREAM)) return;\n            s = o->ptr;\n        }\n        grpname = c->argv[3]->ptr;\n    }\n\n    /* Check for missing key/group. */\n    if (c->argc >= 4 && !mkstream) {\n        /* At this point key must exist, or there is an error. */\n        if (s == NULL) {\n            addReplyError(c,\n                \"The XGROUP subcommand requires the key to exist. \"\n                \"Note that for CREATE you may want to use the MKSTREAM \"\n                \"option to create an empty stream automatically.\");\n            return;\n        }\n\n        /* Certain subcommands require the group to exist. */\n        if ((cg = streamLookupCG(s,grpname)) == NULL &&\n            (!strcasecmp(opt,\"SETID\") ||\n             !strcasecmp(opt,\"CREATECONSUMER\") ||\n             !strcasecmp(opt,\"DELCONSUMER\")))\n        {\n            addReplyErrorFormat(c, \"-NOGROUP No such consumer group '%s' \"\n                                   \"for key name '%s'\",\n                                   (char*)grpname, (char*)c->argv[2]->ptr);\n            return;\n        }\n    }\n\n    /* Dispatch the different subcommands. */\n    if (c->argc == 2 && !strcasecmp(opt,\"HELP\")) {\n        const char *help[] = {\n\"CREATE <key> <groupname> <id|$> [option]\",\n\"    Create a new consumer group. Options are:\",\n\"    * MKSTREAM\",\n\"      Create the empty stream if it does not exist.\",\n\"    * ENTRIESREAD entries_read\",\n\"      Set the group's entries_read counter (internal use).\",\n\"CREATECONSUMER <key> <groupname> <consumer>\",\n\"    Create a new consumer in the specified group.\",\n\"DELCONSUMER <key> <groupname> <consumer>\",\n\"    Remove the specified consumer.\",\n\"DESTROY <key> <groupname>\",\n\"    Remove the specified group.\",\n\"SETID <key> <groupname> <id|$> [ENTRIESREAD entries_read]\",\n\"    Set the current group ID and entries_read counter.\",\nNULL\n        };\n        addReplyHelp(c, help);\n    } else if (!strcasecmp(opt,\"CREATE\") && (c->argc >= 5 && c->argc <= 8)) {\n        streamID id;\n        if (!strcmp(c->argv[4]->ptr,\"$\")) {\n            if (s) {\n                id = s->last_id;\n            } else {\n                id.ms = 0;\n                id.seq = 0;\n            }\n        } else if (streamParseStrictIDOrReply(c,c->argv[4],&id,0,NULL) != C_OK) {\n            return;\n        }\n\n        /* Handle the MKSTREAM option now that the command can no longer fail. */\n        if (s == NULL) {\n            serverAssert(mkstream);\n            o = createStreamObject();\n            dbAdd(c->db,c->argv[2],o);\n            s = o->ptr;\n            signalModifiedKey(c,c->db,c->argv[2]);\n        }\n\n        streamCG *cg = streamCreateCG(s,grpname,sdslen(grpname),&id,entries_read);\n        if (cg) {\n            addReply(c,shared.ok);\n            server.dirty++;\n            notifyKeyspaceEvent(NOTIFY_STREAM,\"xgroup-create\",\n                                c->argv[2],c->db->id);\n        } else {\n            addReplyError(c,\"-BUSYGROUP Consumer Group name already exists\");\n        }\n    } else if (!strcasecmp(opt,\"SETID\") && (c->argc == 5 || c->argc == 7)) {\n        streamID id;\n        if (!strcmp(c->argv[4]->ptr,\"$\")) {\n            id = s->last_id;\n        } else if (streamParseIDOrReply(c,c->argv[4],&id,0) != C_OK) {\n            return;\n        }\n        cg->last_id = id;\n        cg->entries_read = entries_read;\n        addReply(c,shared.ok);\n        server.dirty++;\n        notifyKeyspaceEvent(NOTIFY_STREAM,\"xgroup-setid\",c->argv[2],c->db->id);\n    } else if (!strcasecmp(opt,\"DESTROY\") && c->argc == 4) {\n        if (cg) {\n            raxRemove(s->cgroups,(unsigned char*)grpname,sdslen(grpname),NULL);\n            streamFreeCG(cg);\n            addReply(c,shared.cone);\n            server.dirty++;\n            notifyKeyspaceEvent(NOTIFY_STREAM,\"xgroup-destroy\",\n                                c->argv[2],c->db->id);\n            /* We want to unblock any XREADGROUP consumers with -NOGROUP. */\n            signalKeyAsReady(c->db,c->argv[2],OBJ_STREAM);\n        } else {\n            addReply(c,shared.czero);\n        }\n    } else if (!strcasecmp(opt,\"CREATECONSUMER\") && c->argc == 5) {\n        streamConsumer *created = streamCreateConsumer(cg,c->argv[4]->ptr,c->argv[2],\n                                                       c->db->id,SCC_DEFAULT);\n        addReplyLongLong(c,created ? 1 : 0);\n    } else if (!strcasecmp(opt,\"DELCONSUMER\") && c->argc == 5) {\n        long long pending = 0;\n        streamConsumer *consumer = streamLookupConsumer(cg,c->argv[4]->ptr,SLC_NO_REFRESH);\n        if (consumer) {\n            /* Delete the consumer and returns the number of pending messages\n             * that were yet associated with such a consumer. */\n            pending = raxSize(consumer->pel);\n            streamDelConsumer(cg,consumer);\n            server.dirty++;\n            notifyKeyspaceEvent(NOTIFY_STREAM,\"xgroup-delconsumer\",\n                                c->argv[2],c->db->id);\n        }\n        addReplyLongLong(c,pending);\n    } else {\n        addReplySubcommandSyntaxError(c);\n    }\n}\n\n/* XSETID <stream> <id> [ENTRIESADDED entries_added] [MAXDELETEDID max_deleted_entry_id]\n *\n * Set the internal \"last ID\", \"added entries\" and \"maximal deleted entry ID\"\n * of a stream. */\nvoid xsetidCommand(client *c) {\n    streamID id, max_xdel_id = {0, 0};\n    long long entries_added = -1;\n\n    if (streamParseStrictIDOrReply(c,c->argv[2],&id,0,NULL) != C_OK)\n        return;\n\n    int i = 3;\n    while (i < c->argc) {\n        int moreargs = (c->argc-1) - i; /* Number of additional arguments. */\n        char *opt = c->argv[i]->ptr;\n        if (!strcasecmp(opt,\"ENTRIESADDED\") && moreargs) {\n            if (getLongLongFromObjectOrReply(c,c->argv[i+1],&entries_added,NULL) != C_OK) {\n                return;\n            } else if (entries_added < 0) {\n                addReplyError(c,\"entries_added must be positive\");\n                return;\n            }\n            i += 2;\n        } else if (!strcasecmp(opt,\"MAXDELETEDID\") && moreargs) {\n            if (streamParseStrictIDOrReply(c,c->argv[i+1],&max_xdel_id,0,NULL) != C_OK) {\n                return;\n            } else if (streamCompareID(&id,&max_xdel_id) < 0) {\n                addReplyError(c,\"The ID specified in XSETID is smaller than the provided max_deleted_entry_id\");\n                return;\n            }\n            i += 2;\n        } else {\n            addReplyErrorObject(c,shared.syntaxerr);\n            return;\n        }\n    }\n\n    robj *o = lookupKeyWriteOrReply(c,c->argv[1],shared.nokeyerr);\n    if (o == NULL || checkType(c,o,OBJ_STREAM)) return;\n    stream *s = o->ptr;\n\n    /* If the stream has at least one item, we want to check that the user\n     * is setting a last ID that is equal or greater than the current top\n     * item, otherwise the fundamental ID monotonicity assumption is violated. */\n    if (s->length > 0) {\n        streamID maxid;\n        streamLastValidID(s,&maxid);\n\n        if (streamCompareID(&id,&maxid) < 0) {\n            addReplyError(c,\"The ID specified in XSETID is smaller than the target stream top item\");\n            return;\n        }\n\n        /* If an entries_added was provided, it can't be lower than the length. */\n        if (entries_added != -1 && s->length > (uint64_t)entries_added) {\n            addReplyError(c,\"The entries_added specified in XSETID is smaller than the target stream length\");\n            return;\n        }\n    }\n\n    s->last_id = id;\n    if (entries_added != -1)\n        s->entries_added = entries_added;\n    if (!streamIDEqZero(&max_xdel_id))\n        s->max_deleted_entry_id = max_xdel_id;\n    addReply(c,shared.ok);\n    server.dirty++;\n    notifyKeyspaceEvent(NOTIFY_STREAM,\"xsetid\",c->argv[1],c->db->id);\n}\n\n/* XACK <key> <group> <id> <id> ... <id>\n *\n * Acknowledge a message as processed. In practical terms we just check the\n * pending entries list (PEL) of the group, and delete the PEL entry both from\n * the group and the consumer (pending messages are referenced in both places).\n *\n * Return value of the command is the number of messages successfully\n * acknowledged, that is, the IDs we were actually able to resolve in the PEL.\n */\nvoid xackCommand(client *c) {\n    streamCG *group = NULL;\n    robj *o = lookupKeyRead(c->db,c->argv[1]);\n    if (o) {\n        if (checkType(c,o,OBJ_STREAM)) return; /* Type error. */\n        group = streamLookupCG(o->ptr,c->argv[2]->ptr);\n    }\n\n    /* No key or group? Nothing to ack. */\n    if (o == NULL || group == NULL) {\n        addReply(c,shared.czero);\n        return;\n    }\n\n    /* Start parsing the IDs, so that we abort ASAP if there is a syntax\n     * error: the return value of this command cannot be an error in case\n     * the client successfully acknowledged some messages, so it should be\n     * executed in a \"all or nothing\" fashion. */\n    streamID static_ids[STREAMID_STATIC_VECTOR_LEN];\n    streamID *ids = static_ids;\n    int id_count = c->argc-3;\n    if (id_count > STREAMID_STATIC_VECTOR_LEN)\n        ids = zmalloc(sizeof(streamID)*id_count);\n    for (int j = 3; j < c->argc; j++) {\n        if (streamParseStrictIDOrReply(c,c->argv[j],&ids[j-3],0,NULL) != C_OK) goto cleanup;\n    }\n\n    int acknowledged = 0;\n    for (int j = 3; j < c->argc; j++) {\n        unsigned char buf[sizeof(streamID)];\n        streamEncodeID(buf,&ids[j-3]);\n\n        /* Lookup the ID in the group PEL: it will have a reference to the\n         * NACK structure that will have a reference to the consumer, so that\n         * we are able to remove the entry from both PELs. */\n        streamNACK *nack = raxFind(group->pel,buf,sizeof(buf));\n        if (nack != raxNotFound) {\n            raxRemove(group->pel,buf,sizeof(buf),NULL);\n            raxRemove(nack->consumer->pel,buf,sizeof(buf),NULL);\n            streamFreeNACK(nack);\n            acknowledged++;\n            server.dirty++;\n        }\n    }\n    addReplyLongLong(c,acknowledged);\ncleanup:\n    if (ids != static_ids) zfree(ids);\n}\n\n/* XPENDING <key> <group> [[IDLE <idle>] <start> <stop> <count> [<consumer>]]\n *\n * If start and stop are omitted, the command just outputs information about\n * the amount of pending messages for the key/group pair, together with\n * the minimum and maximum ID of pending messages.\n *\n * If start and stop are provided instead, the pending messages are returned\n * with information about the current owner, number of deliveries and last\n * delivery time and so forth. */\nvoid xpendingCommand(client *c) {\n    int justinfo = c->argc == 3; /* Without the range just outputs general\n                                    information about the PEL. */\n    robj *key = c->argv[1];\n    robj *groupname = c->argv[2];\n    robj *consumername = NULL;\n    streamID startid, endid;\n    long long count = 0;\n    long long minidle = 0;\n    int startex = 0, endex = 0;\n\n    /* Start and stop, and the consumer, can be omitted. Also the IDLE modifier. */\n    if (c->argc != 3 && (c->argc < 6 || c->argc > 9)) {\n        addReplyErrorObject(c,shared.syntaxerr);\n        return;\n    }\n\n    /* Parse start/end/count arguments ASAP if needed, in order to report\n     * syntax errors before any other error. */\n    if (c->argc >= 6) {\n        int startidx = 3; /* Without IDLE */\n\n        if (!strcasecmp(c->argv[3]->ptr, \"IDLE\")) {\n            if (getLongLongFromObjectOrReply(c, c->argv[4], &minidle, NULL) == C_ERR)\n                return;\n            if (c->argc < 8) {\n                /* If IDLE was provided we must have at least 'start end count' */\n                addReplyErrorObject(c,shared.syntaxerr);\n                return;\n            }\n            /* Search for rest of arguments after 'IDLE <idle>' */\n            startidx += 2;\n        }\n\n        /* count argument. */\n        if (getLongLongFromObjectOrReply(c,c->argv[startidx+2],&count,NULL) == C_ERR)\n            return;\n        if (count < 0) count = 0;\n\n        /* start and end arguments. */\n        if (streamParseIntervalIDOrReply(c,c->argv[startidx],&startid,&startex,0) != C_OK)\n            return;\n        if (startex && streamIncrID(&startid) != C_OK) {\n            addReplyError(c,\"invalid start ID for the interval\");\n            return;\n        }\n        if (streamParseIntervalIDOrReply(c,c->argv[startidx+1],&endid,&endex,UINT64_MAX) != C_OK)\n            return;\n        if (endex && streamDecrID(&endid) != C_OK) {\n            addReplyError(c,\"invalid end ID for the interval\");\n            return;\n        }\n\n        if (startidx+3 < c->argc) {\n            /* 'consumer' was provided */\n            consumername = c->argv[startidx+3];\n        }\n    }\n\n    /* Lookup the key and the group inside the stream. */\n    robj *o = lookupKeyRead(c->db,c->argv[1]);\n    streamCG *group;\n\n    if (checkType(c,o,OBJ_STREAM)) return;\n    if (o == NULL ||\n        (group = streamLookupCG(o->ptr,groupname->ptr)) == NULL)\n    {\n        addReplyErrorFormat(c, \"-NOGROUP No such key '%s' or consumer \"\n                               \"group '%s'\",\n                               (char*)key->ptr,(char*)groupname->ptr);\n        return;\n    }\n\n    /* XPENDING <key> <group> variant. */\n    if (justinfo) {\n        addReplyArrayLen(c,4);\n        /* Total number of messages in the PEL. */\n        addReplyLongLong(c,raxSize(group->pel));\n        /* First and last IDs. */\n        if (raxSize(group->pel) == 0) {\n            addReplyNull(c); /* Start. */\n            addReplyNull(c); /* End. */\n            addReplyNullArray(c); /* Clients. */\n        } else {\n            /* Start. */\n            raxIterator ri;\n            raxStart(&ri,group->pel);\n            raxSeek(&ri,\"^\",NULL,0);\n            raxNext(&ri);\n            streamDecodeID(ri.key,&startid);\n            addReplyStreamID(c,&startid);\n\n            /* End. */\n            raxSeek(&ri,\"$\",NULL,0);\n            raxNext(&ri);\n            streamDecodeID(ri.key,&endid);\n            addReplyStreamID(c,&endid);\n            raxStop(&ri);\n\n            /* Consumers with pending messages. */\n            raxStart(&ri,group->consumers);\n            raxSeek(&ri,\"^\",NULL,0);\n            void *arraylen_ptr = addReplyDeferredLen(c);\n            size_t arraylen = 0;\n            while(raxNext(&ri)) {\n                streamConsumer *consumer = ri.data;\n                if (raxSize(consumer->pel) == 0) continue;\n                addReplyArrayLen(c,2);\n                addReplyBulkCBuffer(c,ri.key,ri.key_len);\n                addReplyBulkLongLong(c,raxSize(consumer->pel));\n                arraylen++;\n            }\n            setDeferredArrayLen(c,arraylen_ptr,arraylen);\n            raxStop(&ri);\n        }\n    } else { /* <start>, <stop> and <count> provided, return actual pending entries (not just info) */\n        streamConsumer *consumer = NULL;\n        if (consumername) {\n            consumer = streamLookupConsumer(group,consumername->ptr,SLC_NO_REFRESH);\n\n            /* If a consumer name was mentioned but it does not exist, we can\n             * just return an empty array. */\n            if (consumer == NULL) {\n                addReplyArrayLen(c,0);\n                return;\n            }\n        }\n\n        rax *pel = consumer ? consumer->pel : group->pel;\n        unsigned char startkey[sizeof(streamID)];\n        unsigned char endkey[sizeof(streamID)];\n        raxIterator ri;\n        mstime_t now = mstime();\n\n        streamEncodeID(startkey,&startid);\n        streamEncodeID(endkey,&endid);\n        raxStart(&ri,pel);\n        raxSeek(&ri,\">=\",startkey,sizeof(startkey));\n        void *arraylen_ptr = addReplyDeferredLen(c);\n        size_t arraylen = 0;\n\n        while(count && raxNext(&ri) && memcmp(ri.key,endkey,ri.key_len) <= 0) {\n            streamNACK *nack = ri.data;\n\n            if (minidle) {\n                mstime_t this_idle = now - nack->delivery_time;\n                if (this_idle < minidle) continue;\n            }\n\n            arraylen++;\n            count--;\n            addReplyArrayLen(c,4);\n\n            /* Entry ID. */\n            streamID id;\n            streamDecodeID(ri.key,&id);\n            addReplyStreamID(c,&id);\n\n            /* Consumer name. */\n            addReplyBulkCBuffer(c,nack->consumer->name,\n                                sdslen(nack->consumer->name));\n\n            /* Milliseconds elapsed since last delivery. */\n            mstime_t elapsed = now - nack->delivery_time;\n            if (elapsed < 0) elapsed = 0;\n            addReplyLongLong(c,elapsed);\n\n            /* Number of deliveries. */\n            addReplyLongLong(c,nack->delivery_count);\n        }\n        raxStop(&ri);\n        setDeferredArrayLen(c,arraylen_ptr,arraylen);\n    }\n}\n\n/* XCLAIM <key> <group> <consumer> <min-idle-time> <ID-1> <ID-2>\n *        [IDLE <milliseconds>] [TIME <mstime>] [RETRYCOUNT <count>]\n *        [FORCE] [JUSTID]\n *\n * Gets ownership of one or multiple messages in the Pending Entries List\n * of a given stream consumer group.\n *\n * If the message ID (among the specified ones) exists, and its idle\n * time greater or equal to <min-idle-time>, then the message new owner\n * becomes the specified <consumer>. If the minimum idle time specified\n * is zero, messages are claimed regardless of their idle time.\n *\n * All the messages that cannot be found inside the pending entries list\n * are ignored, but in case the FORCE option is used. In that case we\n * create the NACK (representing a not yet acknowledged message) entry in\n * the consumer group PEL.\n *\n * This command creates the consumer as side effect if it does not yet\n * exists. Moreover the command reset the idle time of the message to 0,\n * even if by using the IDLE or TIME options, the user can control the\n * new idle time.\n *\n * The options at the end can be used in order to specify more attributes\n * to set in the representation of the pending message:\n *\n * 1. IDLE <ms>:\n *      Set the idle time (last time it was delivered) of the message.\n *      If IDLE is not specified, an IDLE of 0 is assumed, that is,\n *      the time count is reset because the message has now a new\n *      owner trying to process it.\n *\n * 2. TIME <ms-unix-time>:\n *      This is the same as IDLE but instead of a relative amount of\n *      milliseconds, it sets the idle time to a specific unix time\n *      (in milliseconds). This is useful in order to rewrite the AOF\n *      file generating XCLAIM commands.\n *\n * 3. RETRYCOUNT <count>:\n *      Set the retry counter to the specified value. This counter is\n *      incremented every time a message is delivered again. Normally\n *      XCLAIM does not alter this counter, which is just served to clients\n *      when the XPENDING command is called: this way clients can detect\n *      anomalies, like messages that are never processed for some reason\n *      after a big number of delivery attempts.\n *\n * 4. FORCE:\n *      Creates the pending message entry in the PEL even if certain\n *      specified IDs are not already in the PEL assigned to a different\n *      client. However the message must be exist in the stream, otherwise\n *      the IDs of non existing messages are ignored.\n *\n * 5. JUSTID:\n *      Return just an array of IDs of messages successfully claimed,\n *      without returning the actual message.\n *\n * 6. LASTID <id>:\n *      Update the consumer group last ID with the specified ID if the\n *      current last ID is smaller than the provided one.\n *      This is used for replication / AOF, so that when we read from a\n *      consumer group, the XCLAIM that gets propagated to give ownership\n *      to the consumer, is also used in order to update the group current\n *      ID.\n *\n * The command returns an array of messages that the user\n * successfully claimed, so that the caller is able to understand\n * what messages it is now in charge of. */\nvoid xclaimCommand(client *c) {\n    streamCG *group = NULL;\n    robj *o = lookupKeyRead(c->db,c->argv[1]);\n    long long minidle; /* Minimum idle time argument. */\n    long long retrycount = -1;   /* -1 means RETRYCOUNT option not given. */\n    mstime_t deliverytime = -1;  /* -1 means IDLE/TIME options not given. */\n    int force = 0;\n    int justid = 0;\n\n    if (o) {\n        if (checkType(c,o,OBJ_STREAM)) return; /* Type error. */\n        group = streamLookupCG(o->ptr,c->argv[2]->ptr);\n    }\n\n    /* No key or group? Send an error given that the group creation\n     * is mandatory. */\n    if (o == NULL || group == NULL) {\n        addReplyErrorFormat(c,\"-NOGROUP No such key '%s' or \"\n                              \"consumer group '%s'\", (char*)c->argv[1]->ptr,\n                              (char*)c->argv[2]->ptr);\n        return;\n    }\n\n    if (getLongLongFromObjectOrReply(c,c->argv[4],&minidle,\n        \"Invalid min-idle-time argument for XCLAIM\")\n        != C_OK) return;\n    if (minidle < 0) minidle = 0;\n\n    /* Start parsing the IDs, so that we abort ASAP if there is a syntax\n     * error: the return value of this command cannot be an error in case\n     * the client successfully claimed some message, so it should be\n     * executed in a \"all or nothing\" fashion. */\n    int j;\n    streamID static_ids[STREAMID_STATIC_VECTOR_LEN];\n    streamID *ids = static_ids;\n    int id_count = c->argc-5;\n    if (id_count > STREAMID_STATIC_VECTOR_LEN)\n        ids = zmalloc(sizeof(streamID)*id_count);\n    for (j = 5; j < c->argc; j++) {\n        if (streamParseStrictIDOrReply(NULL,c->argv[j],&ids[j-5],0,NULL) != C_OK) break;\n    }\n    int last_id_arg = j-1; /* Next time we iterate the IDs we now the range. */\n\n    /* If we stopped because some IDs cannot be parsed, perhaps they\n     * are trailing options. */\n    mstime_t now = mstime();\n    streamID last_id = {0,0};\n    int propagate_last_id = 0;\n    for (; j < c->argc; j++) {\n        int moreargs = (c->argc-1) - j; /* Number of additional arguments. */\n        char *opt = c->argv[j]->ptr;\n        if (!strcasecmp(opt,\"FORCE\")) {\n            force = 1;\n        } else if (!strcasecmp(opt,\"JUSTID\")) {\n            justid = 1;\n        } else if (!strcasecmp(opt,\"IDLE\") && moreargs) {\n            j++;\n            if (getLongLongFromObjectOrReply(c,c->argv[j],&deliverytime,\n                \"Invalid IDLE option argument for XCLAIM\")\n                != C_OK) goto cleanup;\n            deliverytime = now - deliverytime;\n        } else if (!strcasecmp(opt,\"TIME\") && moreargs) {\n            j++;\n            if (getLongLongFromObjectOrReply(c,c->argv[j],&deliverytime,\n                \"Invalid TIME option argument for XCLAIM\")\n                != C_OK) goto cleanup;\n        } else if (!strcasecmp(opt,\"RETRYCOUNT\") && moreargs) {\n            j++;\n            if (getLongLongFromObjectOrReply(c,c->argv[j],&retrycount,\n                \"Invalid RETRYCOUNT option argument for XCLAIM\")\n                != C_OK) goto cleanup;\n        } else if (!strcasecmp(opt,\"LASTID\") && moreargs) {\n            j++;\n            if (streamParseStrictIDOrReply(c,c->argv[j],&last_id,0,NULL) != C_OK) goto cleanup;\n        } else {\n            addReplyErrorFormat(c,\"Unrecognized XCLAIM option '%s'\",opt);\n            goto cleanup;\n        }\n    }\n\n    if (streamCompareID(&last_id,&group->last_id) > 0) {\n        group->last_id = last_id;\n        propagate_last_id = 1;\n    }\n\n    if (deliverytime != -1) {\n        /* If a delivery time was passed, either with IDLE or TIME, we\n         * do some sanity check on it, and set the deliverytime to now\n         * (which is a sane choice usually) if the value is bogus.\n         * To raise an error here is not wise because clients may compute\n         * the idle time doing some math starting from their local time,\n         * and this is not a good excuse to fail in case, for instance,\n         * the computer time is a bit in the future from our POV. */\n        if (deliverytime < 0 || deliverytime > now) deliverytime = now;\n    } else {\n        /* If no IDLE/TIME option was passed, we want the last delivery\n         * time to be now, so that the idle time of the message will be\n         * zero. */\n        deliverytime = now;\n    }\n\n    /* Do the actual claiming. */\n    streamConsumer *consumer = NULL;\n    void *arraylenptr = addReplyDeferredLen(c);\n    size_t arraylen = 0;\n    sds name = c->argv[3]->ptr;\n    for (int j = 5; j <= last_id_arg; j++) {\n        streamID id = ids[j-5];\n        unsigned char buf[sizeof(streamID)];\n        streamEncodeID(buf,&id);\n\n        /* Lookup the ID in the group PEL. */\n        streamNACK *nack = raxFind(group->pel,buf,sizeof(buf));\n\n        /* Item must exist for us to transfer it to another consumer. */\n        if (!streamEntryExists(o->ptr,&id)) {\n            /* Clear this entry from the PEL, it no longer exists */\n            if (nack != raxNotFound) {\n                /* Propagate this change (we are going to delete the NACK). */\n                streamPropagateXCLAIM(c,c->argv[1],group,c->argv[2],c->argv[j],nack);\n                propagate_last_id = 0; /* Will be propagated by XCLAIM itself. */\n                server.dirty++;\n                /* Release the NACK */\n                raxRemove(group->pel,buf,sizeof(buf),NULL);\n                raxRemove(nack->consumer->pel,buf,sizeof(buf),NULL);\n                streamFreeNACK(nack);\n            }\n            continue;\n        }\n\n        /* If FORCE is passed, let's check if at least the entry\n         * exists in the Stream. In such case, we'll create a new\n         * entry in the PEL from scratch, so that XCLAIM can also\n         * be used to create entries in the PEL. Useful for AOF\n         * and replication of consumer groups. */\n        if (force && nack == raxNotFound) {\n            /* Create the NACK. */\n            nack = streamCreateNACK(NULL);\n            raxInsert(group->pel,buf,sizeof(buf),nack,NULL);\n        }\n\n        if (nack != raxNotFound) {\n            /* We need to check if the minimum idle time requested\n             * by the caller is satisfied by this entry.\n             *\n             * Note that the nack could be created by FORCE, in this\n             * case there was no pre-existing entry and minidle should\n             * be ignored, but in that case nack->consumer is NULL. */\n            if (nack->consumer && minidle) {\n                mstime_t this_idle = now - nack->delivery_time;\n                if (this_idle < minidle) continue;\n            }\n\n            if (consumer == NULL &&\n                (consumer = streamLookupConsumer(group,name,SLC_DEFAULT)) == NULL)\n            {\n                consumer = streamCreateConsumer(group,name,c->argv[1],c->db->id,SCC_DEFAULT);\n            }\n            if (nack->consumer != consumer) {\n                /* Remove the entry from the old consumer.\n                 * Note that nack->consumer is NULL if we created the\n                 * NACK above because of the FORCE option. */\n                if (nack->consumer)\n                    raxRemove(nack->consumer->pel,buf,sizeof(buf),NULL);\n            }\n            nack->delivery_time = deliverytime;\n            /* Set the delivery attempts counter if given, otherwise\n             * autoincrement unless JUSTID option provided */\n            if (retrycount >= 0) {\n                nack->delivery_count = retrycount;\n            } else if (!justid) {\n                nack->delivery_count++;\n            }\n            if (nack->consumer != consumer) {\n                /* Add the entry in the new consumer local PEL. */\n                raxInsert(consumer->pel,buf,sizeof(buf),nack,NULL);\n                nack->consumer = consumer;\n            }\n            /* Send the reply for this entry. */\n            if (justid) {\n                addReplyStreamID(c,&id);\n            } else {\n                serverAssert(streamReplyWithRange(c,o->ptr,&id,&id,1,0,NULL,NULL,STREAM_RWR_RAWENTRIES,NULL) == 1);\n            }\n            arraylen++;\n\n            /* Propagate this change. */\n            streamPropagateXCLAIM(c,c->argv[1],group,c->argv[2],c->argv[j],nack);\n            propagate_last_id = 0; /* Will be propagated by XCLAIM itself. */\n            server.dirty++;\n        }\n    }\n    if (propagate_last_id) {\n        streamPropagateGroupID(c,c->argv[1],group,c->argv[2]);\n        server.dirty++;\n    }\n    setDeferredArrayLen(c,arraylenptr,arraylen);\n    preventCommandPropagation(c);\ncleanup:\n    if (ids != static_ids) zfree(ids);\n}\n\n/* XAUTOCLAIM <key> <group> <consumer> <min-idle-time> <start> [COUNT <count>] [JUSTID]\n *\n * Gets ownership of one or multiple messages in the Pending Entries List\n * of a given stream consumer group.\n *\n * For each PEL entry, if its idle time greater or equal to <min-idle-time>,\n * then the message new owner becomes the specified <consumer>.\n * If the minimum idle time specified is zero, messages are claimed\n * regardless of their idle time.\n *\n * This command creates the consumer as side effect if it does not yet\n * exists. Moreover the command reset the idle time of the message to 0.\n *\n * The command returns an array of messages that the user\n * successfully claimed, so that the caller is able to understand\n * what messages it is now in charge of. */\nvoid xautoclaimCommand(client *c) {\n    streamCG *group = NULL;\n    robj *o = lookupKeyRead(c->db,c->argv[1]);\n    long long minidle; /* Minimum idle time argument, in milliseconds. */\n    long count = 100; /* Maximum entries to claim. */\n    streamID startid;\n    int startex;\n    int justid = 0;\n\n    /* Parse idle/start/end/count arguments ASAP if needed, in order to report\n     * syntax errors before any other error. */\n    if (getLongLongFromObjectOrReply(c,c->argv[4],&minidle,\"Invalid min-idle-time argument for XAUTOCLAIM\") != C_OK)\n        return;\n    if (minidle < 0) minidle = 0;\n\n    if (streamParseIntervalIDOrReply(c,c->argv[5],&startid,&startex,0) != C_OK)\n        return;\n    if (startex && streamIncrID(&startid) != C_OK) {\n        addReplyError(c,\"invalid start ID for the interval\");\n        return;\n    }\n\n    int j = 6; /* options start at argv[6] */\n    while(j < c->argc) {\n        int moreargs = (c->argc-1) - j; /* Number of additional arguments. */\n        char *opt = c->argv[j]->ptr;\n        if (!strcasecmp(opt,\"COUNT\") && moreargs) {\n            if (getRangeLongFromObjectOrReply(c,c->argv[j+1],1,LONG_MAX,&count,\"COUNT must be > 0\") != C_OK)\n                return;\n            j++;\n        } else if (!strcasecmp(opt,\"JUSTID\")) {\n            justid = 1;\n        } else {\n            addReplyErrorObject(c,shared.syntaxerr);\n            return;\n        }\n        j++;\n    }\n\n    if (o) {\n        if (checkType(c,o,OBJ_STREAM))\n            return; /* Type error. */\n        group = streamLookupCG(o->ptr,c->argv[2]->ptr);\n    }\n\n    /* No key or group? Send an error given that the group creation\n     * is mandatory. */\n    if (o == NULL || group == NULL) {\n        addReplyErrorFormat(c,\"-NOGROUP No such key '%s' or consumer group '%s'\",\n                            (char*)c->argv[1]->ptr,\n                            (char*)c->argv[2]->ptr);\n        return;\n    }\n\n    /* Do the actual claiming. */\n    streamConsumer *consumer = NULL;\n    long long attempts = count*10;\n\n    addReplyArrayLen(c, 3); /* We add another reply later */\n    void *endidptr = addReplyDeferredLen(c); /* reply[0] */\n    void *arraylenptr = addReplyDeferredLen(c); /* reply[1] */\n\n    unsigned char startkey[sizeof(streamID)];\n    streamEncodeID(startkey,&startid);\n    raxIterator ri;\n    raxStart(&ri,group->pel);\n    raxSeek(&ri,\">=\",startkey,sizeof(startkey));\n    size_t arraylen = 0;\n    mstime_t now = mstime();\n    sds name = c->argv[3]->ptr;\n    streamID *deleted_ids = zmalloc(count * sizeof(streamID));\n    int deleted_id_num = 0;\n    while (attempts-- && count && raxNext(&ri)) {\n        streamNACK *nack = ri.data;\n\n        streamID id;\n        streamDecodeID(ri.key, &id);\n\n        /* Item must exist for us to transfer it to another consumer. */\n        if (!streamEntryExists(o->ptr,&id)) {\n            /* Propagate this change (we are going to delete the NACK). */\n            robj *idstr = createObjectFromStreamID(&id);\n            streamPropagateXCLAIM(c,c->argv[1],group,c->argv[2],idstr,nack);\n            decrRefCount(idstr);\n            server.dirty++;\n            /* Clear this entry from the PEL, it no longer exists */\n            raxRemove(group->pel,ri.key,ri.key_len,NULL);\n            raxRemove(nack->consumer->pel,ri.key,ri.key_len,NULL);\n            streamFreeNACK(nack);\n            /* Remember the ID for later */\n            deleted_ids[deleted_id_num++] = id;\n            raxSeek(&ri,\">=\",ri.key,ri.key_len);\n            continue;\n        }\n\n        if (minidle) {\n            mstime_t this_idle = now - nack->delivery_time;\n            if (this_idle < minidle)\n                continue;\n        }\n\n        if (consumer == NULL &&\n            (consumer = streamLookupConsumer(group,name,SLC_DEFAULT)) == NULL)\n        {\n            consumer = streamCreateConsumer(group,name,c->argv[1],c->db->id,SCC_DEFAULT);\n        }\n        if (nack->consumer != consumer) {\n            /* Remove the entry from the old consumer.\n             * Note that nack->consumer is NULL if we created the\n             * NACK above because of the FORCE option. */\n            if (nack->consumer)\n                raxRemove(nack->consumer->pel,ri.key,ri.key_len,NULL);\n        }\n\n        /* Update the consumer and idle time. */\n        nack->delivery_time = now;\n        /* Increment the delivery attempts counter unless JUSTID option provided */\n        if (!justid)\n            nack->delivery_count++;\n\n        if (nack->consumer != consumer) {\n            /* Add the entry in the new consumer local PEL. */\n            raxInsert(consumer->pel,ri.key,ri.key_len,nack,NULL);\n            nack->consumer = consumer;\n        }\n\n        /* Send the reply for this entry. */\n        if (justid) {\n            addReplyStreamID(c,&id);\n        } else {\n            serverAssert(streamReplyWithRange(c,o->ptr,&id,&id,1,0,NULL,NULL,STREAM_RWR_RAWENTRIES,NULL) == 1);\n        }\n        arraylen++;\n        count--;\n\n        /* Propagate this change. */\n        robj *idstr = createObjectFromStreamID(&id);\n        streamPropagateXCLAIM(c,c->argv[1],group,c->argv[2],idstr,nack);\n        decrRefCount(idstr);\n        server.dirty++;\n    }\n\n    /* We need to return the next entry as a cursor for the next XAUTOCLAIM call */\n    raxNext(&ri);\n\n    streamID endid;\n    if (raxEOF(&ri)) {\n        endid.ms = endid.seq = 0;\n    } else {\n        streamDecodeID(ri.key, &endid);\n    }\n    raxStop(&ri);\n\n    setDeferredArrayLen(c,arraylenptr,arraylen);\n    setDeferredReplyStreamID(c,endidptr,&endid);\n\n    addReplyArrayLen(c, deleted_id_num); /* reply[2] */\n    for (int i = 0; i < deleted_id_num; i++) {\n        addReplyStreamID(c, &deleted_ids[i]);\n    }\n    zfree(deleted_ids);\n\n    preventCommandPropagation(c);\n}\n\n/* XDEL <key> [<ID1> <ID2> ... <IDN>]\n *\n * Removes the specified entries from the stream. Returns the number\n * of items actually deleted, that may be different from the number\n * of IDs passed in case certain IDs do not exist. */\nvoid xdelCommand(client *c) {\n    robj *o;\n\n    if ((o = lookupKeyWriteOrReply(c,c->argv[1],shared.czero)) == NULL\n        || checkType(c,o,OBJ_STREAM)) return;\n    stream *s = o->ptr;\n\n    /* We need to sanity check the IDs passed to start. Even if not\n     * a big issue, it is not great that the command is only partially\n     * executed because at some point an invalid ID is parsed. */\n    streamID static_ids[STREAMID_STATIC_VECTOR_LEN];\n    streamID *ids = static_ids;\n    int id_count = c->argc-2;\n    if (id_count > STREAMID_STATIC_VECTOR_LEN)\n        ids = zmalloc(sizeof(streamID)*id_count);\n    for (int j = 2; j < c->argc; j++) {\n        if (streamParseStrictIDOrReply(c,c->argv[j],&ids[j-2],0,NULL) != C_OK) goto cleanup;\n    }\n\n    /* Actually apply the command. */\n    int deleted = 0;\n    int first_entry = 0;\n    for (int j = 2; j < c->argc; j++) {\n        streamID *id = &ids[j-2];\n        if (streamDeleteItem(s,id)) {\n            /* We want to know if the first entry in the stream was deleted\n             * so we can later set the new one. */\n            if (streamCompareID(id,&s->first_id) == 0) {\n                first_entry = 1;\n            }\n            /* Update the stream's maximal tombstone if needed. */\n            if (streamCompareID(id,&s->max_deleted_entry_id) > 0) {\n                s->max_deleted_entry_id = *id;\n            }\n            deleted++;\n        };\n    }\n\n    /* Update the stream's first ID. */\n    if (deleted) {\n        if (s->length == 0) {\n            s->first_id.ms = 0;\n            s->first_id.seq = 0;\n        } else if (first_entry) {\n            streamGetEdgeID(s,1,1,&s->first_id);\n        }\n    }\n\n    /* Propagate the write if needed. */\n    if (deleted) {\n        signalModifiedKey(c,c->db,c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_STREAM,\"xdel\",c->argv[1],c->db->id);\n        server.dirty += deleted;\n    }\n    addReplyLongLong(c,deleted);\ncleanup:\n    if (ids != static_ids) zfree(ids);\n}\n\n/* General form: XTRIM <key> [... options ...]\n *\n * List of options:\n *\n * Trim strategies:\n *\n * MAXLEN [~|=] <count>     -- Trim so that the stream will be capped at\n *                             the specified length. Use ~ before the\n *                             count in order to demand approximated trimming\n *                             (like XADD MAXLEN option).\n * MINID [~|=] <id>         -- Trim so that the stream will not contain entries\n *                             with IDs smaller than 'id'. Use ~ before the\n *                             count in order to demand approximated trimming\n *                             (like XADD MINID option).\n *\n * Other options:\n *\n * LIMIT <entries>          -- The maximum number of entries to trim.\n *                             0 means unlimited. Unless specified, it is set\n *                             to a default of 100*server.stream_node_max_entries,\n *                             and that's in order to keep the trimming time sane.\n *                             Has meaning only if `~` was provided.\n */\nvoid xtrimCommand(client *c) {\n    robj *o;\n\n    /* Argument parsing. */\n    streamAddTrimArgs parsed_args;\n    if (streamParseAddOrTrimArgsOrReply(c, &parsed_args, 0) < 0)\n        return; /* streamParseAddOrTrimArgsOrReply already replied. */\n\n    /* If the key does not exist, we are ok returning zero, that is, the\n     * number of elements removed from the stream. */\n    if ((o = lookupKeyWriteOrReply(c,c->argv[1],shared.czero)) == NULL\n        || checkType(c,o,OBJ_STREAM)) return;\n    stream *s = o->ptr;\n\n    /* Perform the trimming. */\n    int64_t deleted = streamTrim(s, &parsed_args);\n    if (deleted) {\n        notifyKeyspaceEvent(NOTIFY_STREAM,\"xtrim\",c->argv[1],c->db->id);\n        if (parsed_args.approx_trim) {\n            /* In case our trimming was limited (by LIMIT or by ~) we must\n             * re-write the relevant trim argument to make sure there will be\n             * no inconsistencies in AOF loading or in the replica.\n             * It's enough to check only args->approx because there is no\n             * way LIMIT is given without the ~ option. */\n            streamRewriteApproxSpecifier(c,parsed_args.trim_strategy_arg_idx-1);\n            streamRewriteTrimArgument(c,s,parsed_args.trim_strategy,parsed_args.trim_strategy_arg_idx);\n        }\n\n        /* Propagate the write. */\n        signalModifiedKey(c, c->db,c->argv[1]);\n        server.dirty += deleted;\n    }\n    addReplyLongLong(c,deleted);\n}\n\n/* Helper function for xinfoCommand.\n * Handles the variants of XINFO STREAM */\nvoid xinfoReplyWithStreamInfo(client *c, stream *s) {\n    int full = 1;\n    long long count = 10; /* Default COUNT is 10 so we don't block the server */\n    robj **optv = c->argv + 3; /* Options start after XINFO STREAM <key> */\n    int optc = c->argc - 3;\n\n    /* Parse options. */\n    if (optc == 0) {\n        full = 0;\n    } else {\n        /* Valid options are [FULL] or [FULL COUNT <count>] */\n        if (optc != 1 && optc != 3) {\n            addReplySubcommandSyntaxError(c);\n            return;\n        }\n\n        /* First option must be \"FULL\" */\n        if (strcasecmp(optv[0]->ptr,\"full\")) {\n            addReplySubcommandSyntaxError(c);\n            return;\n        }\n\n        if (optc == 3) {\n            /* First option must be \"FULL\" */\n            if (strcasecmp(optv[1]->ptr,\"count\")) {\n                addReplySubcommandSyntaxError(c);\n                return;\n            }\n            if (getLongLongFromObjectOrReply(c,optv[2],&count,NULL) == C_ERR)\n                return;\n            if (count < 0) count = 10;\n        }\n    }\n\n    addReplyMapLen(c,full ? 9 : 10);\n    addReplyBulkCString(c,\"length\");\n    addReplyLongLong(c,s->length);\n    addReplyBulkCString(c,\"radix-tree-keys\");\n    addReplyLongLong(c,raxSize(s->rax));\n    addReplyBulkCString(c,\"radix-tree-nodes\");\n    addReplyLongLong(c,s->rax->numnodes);\n    addReplyBulkCString(c,\"last-generated-id\");\n    addReplyStreamID(c,&s->last_id);\n    addReplyBulkCString(c,\"max-deleted-entry-id\");\n    addReplyStreamID(c,&s->max_deleted_entry_id);\n    addReplyBulkCString(c,\"entries-added\");\n    addReplyLongLong(c,s->entries_added);\n    addReplyBulkCString(c,\"recorded-first-entry-id\");\n    addReplyStreamID(c,&s->first_id);\n\n    if (!full) {\n        /* XINFO STREAM <key> */\n\n        addReplyBulkCString(c,\"groups\");\n        addReplyLongLong(c,s->cgroups ? raxSize(s->cgroups) : 0);\n\n        /* To emit the first/last entry we use streamReplyWithRange(). */\n        int emitted;\n        streamID start, end;\n        start.ms = start.seq = 0;\n        end.ms = end.seq = UINT64_MAX;\n        addReplyBulkCString(c,\"first-entry\");\n        emitted = streamReplyWithRange(c,s,&start,&end,1,0,NULL,NULL,\n                                       STREAM_RWR_RAWENTRIES,NULL);\n        if (!emitted) addReplyNull(c);\n        addReplyBulkCString(c,\"last-entry\");\n        emitted = streamReplyWithRange(c,s,&start,&end,1,1,NULL,NULL,\n                                       STREAM_RWR_RAWENTRIES,NULL);\n        if (!emitted) addReplyNull(c);\n    } else {\n        /* XINFO STREAM <key> FULL [COUNT <count>] */\n\n        /* Stream entries */\n        addReplyBulkCString(c,\"entries\");\n        streamReplyWithRange(c,s,NULL,NULL,count,0,NULL,NULL,0,NULL);\n\n        /* Consumer groups */\n        addReplyBulkCString(c,\"groups\");\n        if (s->cgroups == NULL) {\n            addReplyArrayLen(c,0);\n        } else {\n            addReplyArrayLen(c,raxSize(s->cgroups));\n            raxIterator ri_cgroups;\n            raxStart(&ri_cgroups,s->cgroups);\n            raxSeek(&ri_cgroups,\"^\",NULL,0);\n            while(raxNext(&ri_cgroups)) {\n                streamCG *cg = ri_cgroups.data;\n                addReplyMapLen(c,7);\n\n                /* Name */\n                addReplyBulkCString(c,\"name\");\n                addReplyBulkCBuffer(c,ri_cgroups.key,ri_cgroups.key_len);\n\n                /* Last delivered ID */\n                addReplyBulkCString(c,\"last-delivered-id\");\n                addReplyStreamID(c,&cg->last_id);\n\n                /* Read counter of the last delivered ID */\n                addReplyBulkCString(c,\"entries-read\");\n                if (cg->entries_read != SCG_INVALID_ENTRIES_READ) {\n                    addReplyLongLong(c,cg->entries_read);\n                } else {\n                    addReplyNull(c);\n                }\n\n                /* Group lag */\n                addReplyBulkCString(c,\"lag\");\n                streamReplyWithCGLag(c,s,cg);\n\n                /* Group PEL count */\n                addReplyBulkCString(c,\"pel-count\");\n                addReplyLongLong(c,raxSize(cg->pel));\n\n                /* Group PEL */\n                addReplyBulkCString(c,\"pending\");\n                long long arraylen_cg_pel = 0;\n                void *arrayptr_cg_pel = addReplyDeferredLen(c);\n                raxIterator ri_cg_pel;\n                raxStart(&ri_cg_pel,cg->pel);\n                raxSeek(&ri_cg_pel,\"^\",NULL,0);\n                while(raxNext(&ri_cg_pel) && (!count || arraylen_cg_pel < count)) {\n                    streamNACK *nack = ri_cg_pel.data;\n                    addReplyArrayLen(c,4);\n\n                    /* Entry ID. */\n                    streamID id;\n                    streamDecodeID(ri_cg_pel.key,&id);\n                    addReplyStreamID(c,&id);\n\n                    /* Consumer name. */\n                    serverAssert(nack->consumer); /* assertion for valgrind (avoid NPD) */\n                    addReplyBulkCBuffer(c,nack->consumer->name,\n                                        sdslen(nack->consumer->name));\n\n                    /* Last delivery. */\n                    addReplyLongLong(c,nack->delivery_time);\n\n                    /* Number of deliveries. */\n                    addReplyLongLong(c,nack->delivery_count);\n\n                    arraylen_cg_pel++;\n                }\n                setDeferredArrayLen(c,arrayptr_cg_pel,arraylen_cg_pel);\n                raxStop(&ri_cg_pel);\n\n                /* Consumers */\n                addReplyBulkCString(c,\"consumers\");\n                addReplyArrayLen(c,raxSize(cg->consumers));\n                raxIterator ri_consumers;\n                raxStart(&ri_consumers,cg->consumers);\n                raxSeek(&ri_consumers,\"^\",NULL,0);\n                while(raxNext(&ri_consumers)) {\n                    streamConsumer *consumer = ri_consumers.data;\n                    addReplyMapLen(c,4);\n\n                    /* Consumer name */\n                    addReplyBulkCString(c,\"name\");\n                    addReplyBulkCBuffer(c,consumer->name,sdslen(consumer->name));\n\n                    /* Seen-time */\n                    addReplyBulkCString(c,\"seen-time\");\n                    addReplyLongLong(c,consumer->seen_time);\n\n                    /* Consumer PEL count */\n                    addReplyBulkCString(c,\"pel-count\");\n                    addReplyLongLong(c,raxSize(consumer->pel));\n\n                    /* Consumer PEL */\n                    addReplyBulkCString(c,\"pending\");\n                    long long arraylen_cpel = 0;\n                    void *arrayptr_cpel = addReplyDeferredLen(c);\n                    raxIterator ri_cpel;\n                    raxStart(&ri_cpel,consumer->pel);\n                    raxSeek(&ri_cpel,\"^\",NULL,0);\n                    while(raxNext(&ri_cpel) && (!count || arraylen_cpel < count)) {\n                        streamNACK *nack = ri_cpel.data;\n                        addReplyArrayLen(c,3);\n\n                        /* Entry ID. */\n                        streamID id;\n                        streamDecodeID(ri_cpel.key,&id);\n                        addReplyStreamID(c,&id);\n\n                        /* Last delivery. */\n                        addReplyLongLong(c,nack->delivery_time);\n\n                        /* Number of deliveries. */\n                        addReplyLongLong(c,nack->delivery_count);\n\n                        arraylen_cpel++;\n                    }\n                    setDeferredArrayLen(c,arrayptr_cpel,arraylen_cpel);\n                    raxStop(&ri_cpel);\n                }\n                raxStop(&ri_consumers);\n            }\n            raxStop(&ri_cgroups);\n        }\n    }\n}\n\n/* XINFO CONSUMERS <key> <group>\n * XINFO GROUPS <key>\n * XINFO STREAM <key> [FULL [COUNT <count>]]\n * XINFO HELP. */\nvoid xinfoCommand(client *c) {\n    stream *s = NULL;\n    char *opt;\n    robj *key;\n\n    /* HELP is special. Handle it ASAP. */\n    if (!strcasecmp(c->argv[1]->ptr,\"HELP\")) {\n        if (c->argc != 2) {\n            addReplySubcommandSyntaxError(c);\n            return;\n        }\n\n        const char *help[] = {\n\"CONSUMERS <key> <groupname>\",\n\"    Show consumers of <groupname>.\",\n\"GROUPS <key>\",\n\"    Show the stream consumer groups.\",\n\"STREAM <key> [FULL [COUNT <count>]\",\n\"    Show information about the stream.\",\nNULL\n        };\n        addReplyHelp(c, help);\n        return;\n    } else if (c->argc < 3) {\n        addReplySubcommandSyntaxError(c);\n        return;\n    }\n\n    /* With the exception of HELP handled before any other sub commands, all\n     * the ones are in the form of \"<subcommand> <key>\". */\n    opt = c->argv[1]->ptr;\n    key = c->argv[2];\n\n    /* Lookup the key now, this is common for all the subcommands but HELP. */\n    robj *o = lookupKeyReadOrReply(c,key,shared.nokeyerr);\n    if (o == NULL || checkType(c,o,OBJ_STREAM)) return;\n    s = o->ptr;\n\n    /* Dispatch the different subcommands. */\n    if (!strcasecmp(opt,\"CONSUMERS\") && c->argc == 4) {\n        /* XINFO CONSUMERS <key> <group>. */\n        streamCG *cg = streamLookupCG(s,c->argv[3]->ptr);\n        if (cg == NULL) {\n            addReplyErrorFormat(c, \"-NOGROUP No such consumer group '%s' \"\n                                   \"for key name '%s'\",\n                                   (char*)c->argv[3]->ptr, (char*)key->ptr);\n            return;\n        }\n\n        addReplyArrayLen(c,raxSize(cg->consumers));\n        raxIterator ri;\n        raxStart(&ri,cg->consumers);\n        raxSeek(&ri,\"^\",NULL,0);\n        mstime_t now = mstime();\n        while(raxNext(&ri)) {\n            streamConsumer *consumer = ri.data;\n            mstime_t idle = now - consumer->seen_time;\n            if (idle < 0) idle = 0;\n\n            addReplyMapLen(c,3);\n            addReplyBulkCString(c,\"name\");\n            addReplyBulkCBuffer(c,consumer->name,sdslen(consumer->name));\n            addReplyBulkCString(c,\"pending\");\n            addReplyLongLong(c,raxSize(consumer->pel));\n            addReplyBulkCString(c,\"idle\");\n            addReplyLongLong(c,idle);\n        }\n        raxStop(&ri);\n    } else if (!strcasecmp(opt,\"GROUPS\") && c->argc == 3) {\n        /* XINFO GROUPS <key>. */\n        if (s->cgroups == NULL) {\n            addReplyArrayLen(c,0);\n            return;\n        }\n\n        addReplyArrayLen(c,raxSize(s->cgroups));\n        raxIterator ri;\n        raxStart(&ri,s->cgroups);\n        raxSeek(&ri,\"^\",NULL,0);\n        while(raxNext(&ri)) {\n            streamCG *cg = ri.data;\n            addReplyMapLen(c,6);\n            addReplyBulkCString(c,\"name\");\n            addReplyBulkCBuffer(c,ri.key,ri.key_len);\n            addReplyBulkCString(c,\"consumers\");\n            addReplyLongLong(c,raxSize(cg->consumers));\n            addReplyBulkCString(c,\"pending\");\n            addReplyLongLong(c,raxSize(cg->pel));\n            addReplyBulkCString(c,\"last-delivered-id\");\n            addReplyStreamID(c,&cg->last_id);\n            addReplyBulkCString(c,\"entries-read\");\n            if (cg->entries_read != SCG_INVALID_ENTRIES_READ) {\n                addReplyLongLong(c,cg->entries_read);\n            } else {\n                addReplyNull(c);\n            }\n            addReplyBulkCString(c,\"lag\");\n            streamReplyWithCGLag(c,s,cg);\n        }\n        raxStop(&ri);\n    } else if (!strcasecmp(opt,\"STREAM\")) {\n        /* XINFO STREAM <key> [FULL [COUNT <count>]]. */\n        xinfoReplyWithStreamInfo(c,s);\n    } else {\n        addReplySubcommandSyntaxError(c);\n    }\n}\n\n/* Validate the integrity stream listpack entries structure. Both in term of a\n * valid listpack, but also that the structure of the entries matches a valid\n * stream. return 1 if valid 0 if not valid. */\nint streamValidateListpackIntegrity(unsigned char *lp, size_t size, int deep) {\n    int valid_record;\n    unsigned char *p, *next;\n\n    /* Since we don't want to run validation of all records twice, we'll\n     * run the listpack validation of just the header and do the rest here. */\n    if (!lpValidateIntegrity(lp, size, 0, NULL, NULL))\n        return 0;\n\n    /* In non-deep mode we just validated the listpack header (encoded size) */\n    if (!deep) return 1;\n\n    next = p = lpValidateFirst(lp);\n    if (!lpValidateNext(lp, &next, size)) return 0;\n    if (!p) return 0;\n\n    /* entry count */\n    int64_t entry_count = lpGetIntegerIfValid(p, &valid_record);\n    if (!valid_record) return 0;\n    p = next; if (!lpValidateNext(lp, &next, size)) return 0;\n\n    /* deleted */\n    int64_t deleted_count = lpGetIntegerIfValid(p, &valid_record);\n    if (!valid_record) return 0;\n    p = next; if (!lpValidateNext(lp, &next, size)) return 0;\n\n    /* num-of-fields */\n    int64_t master_fields = lpGetIntegerIfValid(p, &valid_record);\n    if (!valid_record) return 0;\n    p = next; if (!lpValidateNext(lp, &next, size)) return 0;\n\n    /* the field names */\n    for (int64_t j = 0; j < master_fields; j++) {\n        p = next; if (!lpValidateNext(lp, &next, size)) return 0;\n    }\n\n    /* the zero master entry terminator. */\n    int64_t zero = lpGetIntegerIfValid(p, &valid_record);\n    if (!valid_record || zero != 0) return 0;\n    p = next; if (!lpValidateNext(lp, &next, size)) return 0;\n\n    entry_count += deleted_count;\n    while (entry_count--) {\n        if (!p) return 0;\n        int64_t fields = master_fields, extra_fields = 3;\n        int64_t flags = lpGetIntegerIfValid(p, &valid_record);\n        if (!valid_record) return 0;\n        p = next; if (!lpValidateNext(lp, &next, size)) return 0;\n\n        /* entry id */\n        lpGetIntegerIfValid(p, &valid_record);\n        if (!valid_record) return 0;\n        p = next; if (!lpValidateNext(lp, &next, size)) return 0;\n        lpGetIntegerIfValid(p, &valid_record);\n        if (!valid_record) return 0;\n        p = next; if (!lpValidateNext(lp, &next, size)) return 0;\n\n        if (!(flags & STREAM_ITEM_FLAG_SAMEFIELDS)) {\n            /* num-of-fields */\n            fields = lpGetIntegerIfValid(p, &valid_record);\n            if (!valid_record) return 0;\n            p = next; if (!lpValidateNext(lp, &next, size)) return 0;\n\n            /* the field names */\n            for (int64_t j = 0; j < fields; j++) {\n                p = next; if (!lpValidateNext(lp, &next, size)) return 0;\n            }\n\n            extra_fields += fields + 1;\n        }\n\n        /* the values */\n        for (int64_t j = 0; j < fields; j++) {\n            p = next; if (!lpValidateNext(lp, &next, size)) return 0;\n        }\n\n        /* lp-count */\n        int64_t lp_count = lpGetIntegerIfValid(p, &valid_record);\n        if (!valid_record) return 0;\n        if (lp_count != fields + extra_fields) return 0;\n        p = next; if (!lpValidateNext(lp, &next, size)) return 0;\n    }\n\n    if (next)\n        return 0;\n\n    return 1;\n}\n"], "filenames": ["src/t_stream.c"], "buggy_code_start_loc": [404], "buggy_code_end_loc": [405], "fixing_code_start_loc": [404], "fixing_code_end_loc": [405], "type": "CWE-401", "message": "Redis v7.0 was discovered to contain a memory leak via the component streamGetEdgeID.", "other": {"cve": {"id": "CVE-2022-33105", "sourceIdentifier": "cve@mitre.org", "published": "2022-06-23T17:15:14.747", "lastModified": "2022-10-07T15:49:20.337", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Redis v7.0 was discovered to contain a memory leak via the component streamGetEdgeID."}, {"lang": "es", "value": "Se ha detectado que Redis versi\u00f3n v7.0, contiene una p\u00e9rdida de memoria por medio del componente streamGetEdgeID"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-401"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redis:redis:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "3B244902-3085-4022-9690-395BA84B60FB"}]}]}], "references": [{"url": "https://github.com/redis/redis/commit/4a7a4e42db8ff757cdf3f4a824f66426036034ef", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/redis/redis/pull/10753", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/redis/redis/pull/10829", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Release Notes", "Third Party Advisory"]}, {"url": "https://raw.githubusercontent.com/redis/redis/7.0.1/00-RELEASENOTES", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202209-17", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20220729-0005/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/redis/redis/commit/4a7a4e42db8ff757cdf3f4a824f66426036034ef"}}