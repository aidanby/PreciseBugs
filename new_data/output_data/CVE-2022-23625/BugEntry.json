{"buggy_code": ["//\n// Wire\n// Copyright (C) 2018 Wire Swiss GmbH\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with this program. If not, see http://www.gnu.org/licenses/.\n//\n\n\nimport Foundation\nimport WireUtilities\n\nextension String {\n    fileprivate static let UUIDMatcher: NSRegularExpression = {\n        let regex = try! NSRegularExpression(pattern: \"[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}\", options: .caseInsensitive)\n        return regex\n    }()\n    \n    fileprivate static let clientIDMatcher: NSRegularExpression = {\n        let regex = try! NSRegularExpression(pattern: \"[a-f0-9]{13,16}\", options: .caseInsensitive)\n        return regex\n    }()\n    \n    fileprivate static let matchers = [UUIDMatcher, clientIDMatcher]\n\n    var removingSensitiveInfo: String {\n        let result = NSMutableString(string: self)\n        let range = NSMakeRange(0, self.count)\n\n        String.matchers\n        .flatMap {\n            $0.matches(in: self, options: [], range: range)\n        }\n        .reversed()\n        .forEach {\n            let matchedString = result.substring(with: $0.range)\n            result.replaceCharacters(in: $0.range, with: matchedString.readableHash)\n        }\n\n        return result as String\n    }\n}\n\nextension ZMTransportRequest: SafeForLoggingStringConvertible {\n    @objc public var safeForLoggingDescription: String {\n        let identifier = \"\\(Unmanaged.passUnretained(self).toOpaque())\".readableHash\n        return \"<\\(identifier)> \\(ZMTransportRequest.string(for: self.method)) \\(self.path.removingSensitiveInfo)\"\n    }\n}\n", "// \n// Wire\n// Copyright (C) 2016 Wire Swiss GmbH\n// \n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n// \n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// GNU General Public License for more details.\n// \n// You should have received a copy of the GNU General Public License\n// along with this program. If not, see http://www.gnu.org/licenses/.\n// \n\n\n@import XCTest;\n@import WireTesting;\n@import WireTransport;\n@import WireSystem;\n@import WireUtilities;\n\n#if TARGET_OS_IPHONE\n@import MobileCoreServices;\n#else\n@import CoreServices;\n#endif\n\n#import \"ZMTransportRequest+Internal.h\"\n#import \"ZMTransportRequest+AssetGet.h\"\n\n\n@interface ZMTransportRequestTests : ZMTBaseTest\n\n@end\n\n@interface ZMTransportRequestTests (ResponseMediaTypes)\n@end\n@interface ZMTransportRequestTests (HTTPHeaders)\n@end\n@interface ZMTransportRequestTests (Payload)\n@end\n@interface ZMTransportRequestTests (TimeoutOverride)\n@end\n@interface ZMTransportRequestTests (Debugging)\n@end\n\n@implementation ZMTransportRequestTests\n\n-(void)testThatNeedsAuthenticationIsSetByDefault;\n{\n    XCTAssertTrue([[ZMTransportRequest alloc] initWithPath:@\"/bar\" method:ZMMethodPOST payload:@{}].needsAuthentication);\n    XCTAssertTrue([ZMTransportRequest requestGetFromPath:@\"/bar\"].needsAuthentication);\n    XCTAssertTrue([ZMTransportRequest requestWithPath:@\"/bar\" method:ZMMethodPOST payload:@{}].needsAuthentication);\n}\n\n-(void)testThatCreatesAccessTokenIsNotSetByDefault;\n{\n    XCTAssertFalse([[ZMTransportRequest alloc] initWithPath:@\"/bar\" method:ZMMethodPOST payload:@{}].responseWillContainAccessToken);\n    XCTAssertFalse([ZMTransportRequest requestGetFromPath:@\"/bar\"].responseWillContainAccessToken);\n    XCTAssertFalse([ZMTransportRequest requestWithPath:@\"/bar\" method:ZMMethodPOST payload:@{}].responseWillContainAccessToken);\n}\n\n- (void)testThatNeedsAuthenticationIsSet\n{\n    XCTAssertFalse([[ZMTransportRequest alloc] initWithPath:@\"/bar\" method:ZMMethodPOST payload:@{} authentication:ZMTransportRequestAuthNone].needsAuthentication);\n    XCTAssertFalse([[ZMTransportRequest alloc] initWithPath:@\"/bar\" method:ZMMethodPOST payload:@{} authentication:ZMTransportRequestAuthCreatesCookieAndAccessToken].needsAuthentication);\n    XCTAssertTrue([[ZMTransportRequest alloc] initWithPath:@\"/bar\" method:ZMMethodPOST payload:@{} authentication:ZMTransportRequestAuthNeedsAccess].needsAuthentication);\n    XCTAssertTrue([[ZMTransportRequest alloc] initWithPath:@\"/bar\" method:ZMMethodPOST payload:@{} authentication:ZMTransportRequestAuthNeedsCookieAndAccessToken].needsAuthentication);\n}\n\n- (void)testThatNeedsCookieIsSet\n{\n    XCTAssertFalse([[ZMTransportRequest alloc] initWithPath:@\"/bar\" method:ZMMethodPOST payload:@{} authentication:ZMTransportRequestAuthNone].needsCookie);\n    XCTAssertFalse([[ZMTransportRequest alloc] initWithPath:@\"/bar\" method:ZMMethodPOST payload:@{} authentication:ZMTransportRequestAuthCreatesCookieAndAccessToken].needsCookie);\n    XCTAssertFalse([[ZMTransportRequest alloc] initWithPath:@\"/bar\" method:ZMMethodPOST payload:@{} authentication:ZMTransportRequestAuthNeedsAccess].needsCookie);\n    XCTAssertTrue([[ZMTransportRequest alloc] initWithPath:@\"/bar\" method:ZMMethodPOST payload:@{} authentication:ZMTransportRequestAuthNeedsCookieAndAccessToken].needsCookie);\n}\n\n- (void)testThatCreatesAccessTokenIsSet\n{\n    XCTAssertFalse([[ZMTransportRequest alloc] initWithPath:@\"/bar\" method:ZMMethodPOST payload:@{} authentication:ZMTransportRequestAuthNone].responseWillContainAccessToken);\n    XCTAssertTrue([[ZMTransportRequest alloc] initWithPath:@\"/bar\" method:ZMMethodPOST payload:@{} authentication:ZMTransportRequestAuthCreatesCookieAndAccessToken].responseWillContainAccessToken);\n    XCTAssertFalse([[ZMTransportRequest alloc] initWithPath:@\"/bar\" method:ZMMethodPOST payload:@{} authentication:ZMTransportRequestAuthNeedsAccess].responseWillContainAccessToken);\n}\n\n- (void)testThatResponseWillContainCookieIsSet;\n{\n    XCTAssertFalse([[ZMTransportRequest alloc] initWithPath:@\"/bar\" method:ZMMethodPOST payload:@{} authentication:ZMTransportRequestAuthNone].responseWillContainCookie);\n    XCTAssertTrue([[ZMTransportRequest alloc] initWithPath:@\"/bar\" method:ZMMethodPOST payload:@{} authentication:ZMTransportRequestAuthCreatesCookieAndAccessToken].responseWillContainCookie);\n    XCTAssertFalse([[ZMTransportRequest alloc] initWithPath:@\"/bar\" method:ZMMethodPOST payload:@{} authentication:ZMTransportRequestAuthNeedsAccess].responseWillContainCookie);\n}\n\n-(void)testThatRequestGetFromPathSetsProperties\n{\n    // given\n    NSString *originalPath = @\"foo-bar\";\n    NSMutableString *path = [NSMutableString stringWithString:originalPath];\n    \n    // when\n    ZMTransportRequest *request = [ZMTransportRequest requestGetFromPath:path];\n    [path setString:@\"baz\"]; // test that it is copied\n    \n    // then\n    XCTAssertEqualObjects(request.path, originalPath);\n    XCTAssertEqual(request.method, ZMMethodGET);\n    XCTAssertNil(request.payload);\n    XCTAssertFalse(request.shouldFailInsteadOfRetry);\n    XCTAssertEqual(request.contentDisposition.count, 0U);\n}\n\n- (void)testThatRequestWithBinaryDataSetsProperties;\n{\n    // given\n    NSString * const path = @\"/some/path\";\n    ZMTransportRequestMethod const method = ZMMethodPOST;\n    NSData * const data = [NSData dataWithBytes:((const char []){'z', 'q'}) length:2];\n    NSDictionary * const disposition = @{@\"zasset\": [NSNull null], @\"conv_id\": [NSUUID createUUID].transportString};\n    \n    // when\n    ZMTransportRequest *request = [[ZMTransportRequest alloc] initWithPath:path method:method binaryData:data type:(__bridge id) kUTTypePNG contentDisposition:disposition];\n    \n    // then\n    XCTAssertNotNil(request);\n    XCTAssertNil(request.payload);\n    XCTAssertEqualObjects(request.path, path);\n    XCTAssertEqual(request.method, method);\n    XCTAssertEqualObjects(request.contentDisposition, disposition);\n    XCTAssertEqualObjects(request.binaryData, data);\n    XCTAssertEqualObjects(request.binaryDataType, (__bridge id) kUTTypePNG);\n    XCTAssertFalse(request.shouldFailInsteadOfRetry);\n}\n\n- (void)testThatFileUploadRequestSetsProperties;\n{\n    // given\n    NSURL *fileURL = [NSURL URLWithString:@\"/url/to/some/private/file\"];\n    NSString *path = @\"some/path\";\n    \n    // when\n    NSString *contentType = @\"multipart/mixed; boundary=frontier\";\n    ZMTransportRequest *request = [ZMTransportRequest uploadRequestWithFileURL:fileURL path:path contentType:contentType];\n    \n    // then\n    XCTAssertNotNil(request);\n    XCTAssertNil(request.payload);\n    XCTAssertEqualObjects(request.path, path);\n    XCTAssertEqual(request.method, ZMMethodPOST);\n    XCTAssertNil(request.contentDisposition);\n    XCTAssertNil(request.binaryData);\n    XCTAssertEqualObjects(fileURL, request.fileUploadURL);\n    XCTAssertTrue(request.shouldUseOnlyBackgroundSession);\n    XCTAssertTrue(request.shouldFailInsteadOfRetry);\n}\n\n- (void)testThatEmptyPUTRequestSetsProperties;\n{\n    // given\n    NSString * const path = @\"/some/path\";\n    ZMTransportRequestMethod const method = ZMMethodPUT;\n    \n    // when\n    ZMTransportRequest *request = [ZMTransportRequest emptyPutRequestWithPath:path];\n    NSMutableURLRequest *httpRequest = [[NSMutableURLRequest alloc] init];\n    [request setBodyDataAndMediaTypeOnHTTPRequest:httpRequest];\n    \n    // when\n\n    // then\n    XCTAssertNotNil(request);\n    XCTAssertNil(request.payload);\n    XCTAssertEqualObjects(request.path, path);\n    XCTAssertEqual(request.method, method);\n    XCTAssertNil(request.contentDisposition);\n    XCTAssertFalse(request.shouldFailInsteadOfRetry);\n    XCTAssertEqualObjects(request.binaryData, [NSData data]);\n    XCTAssertEqualObjects([httpRequest valueForHTTPHeaderField:@\"Content-Type\"], @\"application/json\");\n}\n\n- (void)testThatImagePostRequestSetsProperties;\n{\n    // given\n    NSString * const path = @\"/some/path\";\n    NSData * const data = [self verySmallJPEGData];\n    NSDictionary * const disposition = @{@\"zasset\": [NSNull null], @\"conv_id\": [NSUUID createUUID].transportString};\n    \n    // when\n    ZMTransportRequest *request = [ZMTransportRequest postRequestWithPath:path imageData:data contentDisposition:disposition];\n    \n    // then\n    XCTAssertNotNil(request);\n    XCTAssertNil(request.payload);\n    XCTAssertEqualObjects(request.path, path);\n    XCTAssertEqual(request.method, ZMMethodPOST);\n    XCTAssertEqualObjects(request.contentDisposition, disposition);\n    XCTAssertEqualObjects(request.binaryData, data);\n    XCTAssertFalse(request.shouldFailInsteadOfRetry);\n    XCTAssertEqualObjects(request.binaryDataType, (__bridge id) kUTTypeJPEG);\n}\n\n- (void)testThatImagePostRequestIsNilForNonImageData\n{\n    // given\n    NSData * const textData = [self dataForResource:@\"Lorem Ipsum\" extension:@\"txt\"];\n    XCTAssertNotNil(textData);\n    \n    // when\n    ZMTransportRequest *request = [ZMTransportRequest postRequestWithPath:@\"/some/path\" imageData:textData contentDisposition:@{}];\n    \n    // then\n    XCTAssertNil(request);\n}\n\n- (void)testThatMultipartImagePostRequestSetsProperties;\n{\n    // given\n    NSString * const path = @\"/some/path\";\n    NSData * const data = [self verySmallJPEGData];\n    NSDictionary * const disposition = @{@\"zasset\": [NSNull null], @\"conv_id\": [NSUUID createUUID].transportString};\n\n    NSString *boundary = @\"frontier\";\n    NSData *metaDataData = [NSJSONSerialization dataWithJSONObject:disposition options:0 error:NULL];\n\n    // when\n    ZMTransportRequest *request = [ZMTransportRequest multipartRequestWithPath:path imageData:data metaData:disposition];\n    \n    // then\n    XCTAssertNotNil(request);\n    XCTAssertNil(request.payload);\n    XCTAssertEqualObjects(request.path, path);\n    XCTAssertEqual(request.method, ZMMethodPOST);\n    XCTAssertNil(request.contentDisposition);\n    XCTAssertFalse(request.shouldFailInsteadOfRetry);\n    NSArray *items = [request multipartBodyItems];\n    XCTAssertEqual(items.count, 2u);\n\n    ZMMultipartBodyItem *metadataItem = items.firstObject;\n    XCTAssertEqualObjects(metadataItem.contentType, @\"application/json; charset=utf-8\");\n    XCTAssertEqualObjects(metadataItem.data, metaDataData);\n\n    ZMMultipartBodyItem *imageItem = items.lastObject;\n    XCTAssertEqualObjects(imageItem.contentType, @\"image/jpeg\");\n    XCTAssertEqualObjects(imageItem.headers, @{@\"Content-MD5\": [[data zmMD5Digest] base64EncodedStringWithOptions:0]});\n    XCTAssertEqualObjects(imageItem.data, data);\n    \n    NSString *expectedContentType = [NSString stringWithFormat:@\"multipart/mixed; boundary=%@\", boundary];\n    XCTAssertEqualObjects(request.binaryDataType, expectedContentType);\n}\n\n- (void)testThatMultipartImagePostRequestIsNilForNonImageData\n{\n    // given\n    NSData * const textData = [self dataForResource:@\"Lorem Ipsum\" extension:@\"txt\"];\n    XCTAssertNotNil(textData);\n    \n    // when\n    ZMTransportRequest *request = [ZMTransportRequest multipartRequestWithPath:@\"/some/path\" imageData:textData metaData:@{}];\n    \n    // then\n    XCTAssertNil(request);\n}\n\n- (void)testThatItCallsTaskCreatedHandler\n{\n    // given\n    XCTestExpectation *expectation = [self expectationWithDescription:@\"Task created handler called\"];\n    ZMTransportRequest *transportRequest = [ZMTransportRequest requestWithPath:@\"/something\" method:ZMMethodPUT payload:@{}];\n    ZMTaskIdentifier *expectedIdentifier = [ZMTaskIdentifier identifierWithIdentifier:2 sessionIdentifier:@\"test-session\"];\n    \n    ZMTaskCreatedHandler *handler = [ZMTaskCreatedHandler handlerOnGroupQueue:self.fakeSyncContext block:^(ZMTaskIdentifier *identifier) {\n        XCTAssertEqualObjects(identifier, expectedIdentifier);\n        [expectation fulfill];\n    }];\n    \n    [transportRequest addTaskCreatedHandler:handler];\n    \n    // when\n    [transportRequest callTaskCreationHandlersWithIdentifier:2 sessionIdentifier:@\"test-session\"];\n    \n    // then\n    XCTAssert([self waitForCustomExpectationsWithTimeout:0.5]);\n}\n\n- (void)testThatItCallsMultipleTaskCreatedHandlers\n{\n    // given\n    XCTestExpectation *firstExpectation = [self expectationWithDescription:@\"First task created handler called\"];\n    XCTestExpectation *secondExpectation = [self expectationWithDescription:@\"Second task created handler called\"];;\n    \n    ZMTransportRequest *transportRequest = [ZMTransportRequest requestWithPath:@\"/something\" method:ZMMethodPUT payload:@{}];\n    ZMTaskIdentifier *expectedIdentifier = [ZMTaskIdentifier identifierWithIdentifier:2 sessionIdentifier:@\"test-session\"];\n    \n    ZMTaskCreatedHandler *firstHandler = [ZMTaskCreatedHandler handlerOnGroupQueue:self.fakeSyncContext block:^(ZMTaskIdentifier *identifier) {\n        XCTAssertEqualObjects(identifier, expectedIdentifier);\n        [firstExpectation fulfill];\n    }];\n    \n    ZMTaskCreatedHandler *secondHandler = [ZMTaskCreatedHandler handlerOnGroupQueue:self.fakeSyncContext block:^(ZMTaskIdentifier *identifier) {\n        XCTAssertEqualObjects(identifier, expectedIdentifier);\n        [secondExpectation fulfill];\n    }];\n    \n    [transportRequest addTaskCreatedHandler:firstHandler];\n    [transportRequest addTaskCreatedHandler:secondHandler];\n    \n    // when\n    [transportRequest callTaskCreationHandlersWithIdentifier:2 sessionIdentifier:@\"test-session\"];\n    \n    // then\n    XCTAssert([self waitForCustomExpectationsWithTimeout:0.5]);\n}\n\n- (void)testThatItDoesNotAttemptToCallATaskCreatedHandlerIfNoneIsSet\n{\n    // given\n    ZMTransportRequest *transportRequest = [ZMTransportRequest requestWithPath:@\"/something\" method:ZMMethodPUT payload:@{}];\n    \n    // when\n    XCTAssertNoThrow([transportRequest callTaskCreationHandlersWithIdentifier:0 sessionIdentifier:@\"\"]);\n}\n\n- (void)testThatItSetsStartOfUploadTimestamp\n{\n    // given\n    ZMTransportRequest *transportRequest = [ZMTransportRequest requestWithPath:@\"/something\" method:ZMMethodPUT payload:@{}];\n    [transportRequest markStartOfUploadTimestamp];\n    \n    ZMTransportResponse *response = [ZMTransportResponse responseWithPayload:@{@\"name\":@\"foo\"} HTTPStatus:213 transportSessionError:nil];\n    \n    // when\n    [transportRequest completeWithResponse:response];\n    \n    // then\n    XCTAssertEqual(transportRequest.startOfUploadTimestamp, response.startOfUploadTimestamp);\n}\n\n- (void)testThatItCallsTheCompletionHandler\n{\n    // given\n    XCTestExpectation *expectation = [self expectationWithDescription:@\"Completion handler called\"];\n    ZMTransportRequest *transportRequest = [ZMTransportRequest requestWithPath:@\"/something\" method:ZMMethodPUT payload:@{}];\n\n    [transportRequest addCompletionHandler:\n     [ZMCompletionHandler handlerOnGroupQueue:self.fakeSyncContext block:^(ZMTransportResponse *response ZM_UNUSED){\n        [expectation fulfill];\n    }]];\n\n    // when\n    [transportRequest completeWithResponse:[[ZMTransportResponse alloc] init]];\n\n    // then\n    XCTAssert([self waitForCustomExpectationsWithTimeout:0.5]);\n}\n\n- (void)testThatItCallsMultipleCompletionHandlers\n{\n    // given\n    XCTestExpectation *expectation1 = [self expectationWithDescription:@\"Completion 1 handler called\"];\n    XCTestExpectation *expectation2 = [self expectationWithDescription:@\"Completion 2 handler called\"];\n\n    ZMTransportRequest *transportRequest = [ZMTransportRequest requestWithPath:@\"/something\" method:ZMMethodPUT payload:@{}];\n    \n    [transportRequest addCompletionHandler:\n     [ZMCompletionHandler handlerOnGroupQueue:self.fakeSyncContext block:^(ZMTransportResponse *response ZM_UNUSED){\n        [expectation1 fulfill];\n    }]];\n    \n    [transportRequest addCompletionHandler:\n     [ZMCompletionHandler handlerOnGroupQueue:self.fakeSyncContext block:^(ZMTransportResponse *response ZM_UNUSED){\n        [expectation2 fulfill];\n    }]];\n    \n    // when\n    [transportRequest completeWithResponse:[[ZMTransportResponse alloc] init]];\n    \n    // then\n    XCTAssert([self waitForCustomExpectationsWithTimeout:0.5]);\n}\n\n\n- (void)testThatItDoesNotAttemptToCallACompletionHandlerIfNoneIsSet\n{\n    // given\n    ZMTransportRequest *transportRequest = [ZMTransportRequest requestWithPath:@\"/something\" method:ZMMethodPUT payload:@{}];\n\n    // when\n    XCTAssertNoThrow([transportRequest completeWithResponse:[[ZMTransportResponse alloc] init]]);\n}\n\n\n- (void)testThatCompletionHandlerIsExecutedWithTheResponse;\n{\n    // given\n    XCTestExpectation *expectation = [self expectationWithDescription:@\"Completion handler called\"];\n    ZMTransportResponse *response = [ZMTransportResponse responseWithPayload:@{@\"name\":@\"foo\"} HTTPStatus:213 transportSessionError:nil];\n    __block ZMTransportResponse *receivedResponse;\n    \n    ZMTransportRequest *request = [ZMTransportRequest requestWithPath:@\"\" method:ZMMethodGET payload:nil];\n    [request addCompletionHandler:\n     [ZMCompletionHandler handlerOnGroupQueue:self.fakeSyncContext block:^(ZMTransportResponse *actualResponse){\n        receivedResponse = actualResponse;\n        [expectation fulfill];\n    }]];\n    \n    // when\n    [request completeWithResponse:response];\n    \n    // then\n    XCTAssert([self waitForCustomExpectationsWithTimeout:0.5]);\n    XCTAssertEqualObjects(response, receivedResponse);\n}\n\n\n- (void)testThatCompletionHandlersAreExecutedFromFirstToLast\n{\n    // given\n    XCTestExpectation *expectation1 = [self expectationWithDescription:@\"Completion 1 handler called\"];\n    XCTestExpectation *expectation2 = [self expectationWithDescription:@\"Completion 2 handler called\"];\n    XCTestExpectation *expectation3 = [self expectationWithDescription:@\"Completion 3 handler called\"];\n    ZMTransportResponse *response = [ZMTransportResponse responseWithPayload:@{} HTTPStatus:200 transportSessionError:nil];\n\n    __block NSMutableString *responses = [[NSMutableString alloc] init];\n\n\n    ZMTransportRequest *request = [ZMTransportRequest requestWithPath:@\"\" method:ZMMethodGET payload:nil];\n\n    [request addCompletionHandler:[ZMCompletionHandler handlerOnGroupQueue:self.fakeSyncContext block:^(ZMTransportResponse *resp) {\n        NOT_USED(resp);\n        [responses appendString:@\"a\"];\n        [expectation1 fulfill];\n    }]];\n\n    [request addCompletionHandler:[ZMCompletionHandler handlerOnGroupQueue:self.fakeSyncContext block:^(ZMTransportResponse *resp) {\n        NOT_USED(resp);\n        [responses appendString:@\"b\"];\n        [expectation2 fulfill];\n    }]];\n\n    [request addCompletionHandler:[ZMCompletionHandler handlerOnGroupQueue:self.fakeSyncContext block:^(ZMTransportResponse *resp) {\n        NOT_USED(resp);\n        [responses appendString:@\"c\"];\n        [expectation3 fulfill];\n    }]];\n\n    // when\n    [request completeWithResponse:response];\n\n    // then\n    XCTAssert([self waitForCustomExpectationsWithTimeout:0.5]);\n    XCTAssertEqualObjects(responses, @\"abc\");\n}\n\n\n- (void)testThatItCallsTaskProgressHandler\n{\n    // given\n    const float expectedProgress = 0.5f;\n    \n    XCTestExpectation *expectation = [self expectationWithDescription:@\"Task progress handler called\"];\n    ZMTransportRequest *transportRequest = [ZMTransportRequest requestWithPath:@\"/something\" method:ZMMethodPUT payload:@{}];\n    \n    [transportRequest addProgressHandler: [ZMTaskProgressHandler handlerOnGroupQueue:self.fakeSyncContext block:^(float progress) {\n        XCTAssertEqual(expectedProgress, progress);\n        [expectation fulfill];\n    }]];\n    \n    // when\n    [transportRequest updateProgress:expectedProgress];\n    \n    // then\n    XCTAssert([self waitForCustomExpectationsWithTimeout:0.5]);\n}\n\n- (void)testThatItCallsTaskProgressHandlerContinuously\n{\n    // given\n    const static float expectedProgress[] = {0.0f, 0.1f, 0.5f, 0.9f, 1.0f};\n    const static size_t expectedProgressSize = sizeof(expectedProgress) / sizeof(expectedProgress[0]);\n    \n    XCTestExpectation *expectation = [self expectationWithDescription:@\"Task progress handler called\"];\n    ZMTransportRequest *transportRequest = [ZMTransportRequest requestWithPath:@\"/something\" method:ZMMethodPUT payload:@{}];\n    \n    NSUInteger __block currentCallIndex = 0;\n    \n    [transportRequest addProgressHandler: [ZMTaskProgressHandler handlerOnGroupQueue:self.fakeSyncContext block:^(float progress) {\n        XCTAssertEqual(expectedProgress[currentCallIndex], progress);\n        currentCallIndex++;\n        \n        if (currentCallIndex == expectedProgressSize) {\n            [expectation fulfill];\n        }\n    }]];\n    \n    // when\n    for (size_t i = 0 ; i < expectedProgressSize; i++) {\n        [transportRequest updateProgress:expectedProgress[i]];\n    }\n    \n    // then\n    XCTAssert([self waitForCustomExpectationsWithTimeout:0.5]);\n}\n\n- (void)testThatItCallsTaskProgressHandlerWithProgressLessOrEqualToComplete\n{\n    // given\n    const float randomProgress = 1000234.0f;\n    const float expectedProgress = 1.0f;\n    \n    XCTestExpectation *expectation = [self expectationWithDescription:@\"Task progress handler called\"];\n    ZMTransportRequest *transportRequest = [ZMTransportRequest requestWithPath:@\"/something\" method:ZMMethodPUT payload:@{}];\n    \n    [transportRequest addProgressHandler: [ZMTaskProgressHandler handlerOnGroupQueue:self.fakeSyncContext block:^(float progress) {\n        XCTAssertEqual(expectedProgress, progress);\n        [expectation fulfill];\n    }]];\n    \n    // when\n    [transportRequest updateProgress:randomProgress];\n    \n    // then\n    XCTAssert([self waitForCustomExpectationsWithTimeout:0.5]);\n}\n\n- (void)testThatItCallsTaskProgressHandlerWithProgressLessOrEqualToInitial\n{\n    // given\n    const float randomProgress = -123.0f;\n    const float expectedProgress = 0.0f;\n    \n    XCTestExpectation *expectation = [self expectationWithDescription:@\"Task progress handler called\"];\n    ZMTransportRequest *transportRequest = [ZMTransportRequest requestWithPath:@\"/something\" method:ZMMethodPUT payload:@{}];\n    \n    [transportRequest addProgressHandler: [ZMTaskProgressHandler handlerOnGroupQueue:self.fakeSyncContext block:^(float progress) {\n        XCTAssertEqual(expectedProgress, progress);\n        [expectation fulfill];\n    }]];\n    \n    // when\n    [transportRequest updateProgress:randomProgress];\n    \n    // then\n    XCTAssert([self waitForCustomExpectationsWithTimeout:0.5]);\n}\n\n- (void)testThatItCallsMultipleTaskProgressHandlers\n{\n    // given\n    const float expectedProgress = 0.5f;\n    \n    XCTestExpectation *expectation1 = [self expectationWithDescription:@\"Task progress handler 1 called\"];\n    XCTestExpectation *expectation2 = [self expectationWithDescription:@\"Task progress handler 2 called\"];\n\n    ZMTransportRequest *transportRequest = [ZMTransportRequest requestWithPath:@\"/something\" method:ZMMethodPUT payload:@{}];\n    \n    [transportRequest addProgressHandler: [ZMTaskProgressHandler handlerOnGroupQueue:self.fakeSyncContext block:^(float progress) {\n        XCTAssertEqual(expectedProgress, progress);\n        [expectation1 fulfill];\n    }]];\n    \n    [transportRequest addProgressHandler: [ZMTaskProgressHandler handlerOnGroupQueue:self.fakeSyncContext block:^(float progress) {\n        XCTAssertEqual(expectedProgress, progress);\n        [expectation2 fulfill];\n    }]];\n    \n    // when\n    [transportRequest updateProgress:expectedProgress];\n    \n    // then\n    XCTAssert([self waitForCustomExpectationsWithTimeout:0.5]);\n}\n\n- (void)testThatItDoesNotAttemptToCallATaskProgressHandlerIfNoneIsSet\n{\n    // given\n    ZMTransportRequest *transportRequest = [ZMTransportRequest requestWithPath:@\"/something\" method:ZMMethodPUT payload:@{}];\n    \n    // when\n    XCTAssertNoThrow([transportRequest updateProgress:1.0f]);\n}\n\n\n- (void)testThatARequestShouldBeExecutedOnlyOnForegroundSessionByDefault\n{\n    // given\n    ZMTransportRequest *request = [ZMTransportRequest requestGetFromPath:@\"Foo\"];\n    \n    // then\n    XCTAssertFalse(request.shouldUseOnlyBackgroundSession);\n    XCTAssertFalse(request.shouldUseVoipSession);\n}\n\n- (void)testThatARequestShouldUseOnlyBackgroundSessionWhenForced\n{\n    // given\n    ZMTransportRequest *request = [ZMTransportRequest requestGetFromPath:@\"Foo\"];\n\n    // when\n    [request forceToBackgroundSession];\n    \n    // then\n    XCTAssertTrue(request.shouldUseOnlyBackgroundSession);\n    XCTAssertFalse(request.shouldUseVoipSession);\n}\n\n- (void)testThatARequestShouldUseOnlyVoipSessionWhenForced\n{\n    // given\n    ZMTransportRequest *request = [ZMTransportRequest requestGetFromPath:@\"Foo\"];\n    \n    // when\n    [request forceToVoipSession];\n    \n    // then\n    XCTAssertTrue(request.shouldUseVoipSession);\n    XCTAssertFalse(request.shouldUseOnlyBackgroundSession);\n\n}\n\n\n@end\n\n\n\n@implementation ZMTransportRequestTests (ResponseMediaTypes)\n\n- (void)testThatItSetsAcceptsImageData;\n{\n    // given\n    ZMTransportRequest *sut = [ZMTransportRequest imageGetRequestFromPath:@\"/foo/bar\"];\n    \n    // then\n    XCTAssertEqual(sut.acceptedResponseMediaTypes, ZMTransportAcceptImage);\n}\n\n- (void)testThatItSetsAcceptsTransportData;\n{\n    // (1) given\n    ZMTransportRequest *sut = [ZMTransportRequest requestGetFromPath:@\"/foo/bar\"];\n    \n    // then\n    XCTAssertEqual(sut.acceptedResponseMediaTypes, ZMTransportAcceptTransportData);\n    \n    // (2) given\n    sut = [ZMTransportRequest requestWithPath:@\"/foo2\" method:ZMMethodPOST payload:@{@\"f\": @2}];\n    \n    // then\n    XCTAssertEqual(sut.acceptedResponseMediaTypes, ZMTransportAcceptTransportData);\n\n    // (3) given\n    sut = [[ZMTransportRequest alloc] initWithPath:@\"/hello\" method:ZMMethodPUT binaryData:[@\"asdf\" dataUsingEncoding:NSUTF8StringEncoding] type:@\"image/jpeg\" contentDisposition:@{@\"asdf\": @42}];\n    \n    // then\n    XCTAssertEqual(sut.acceptedResponseMediaTypes, ZMTransportAcceptTransportData);\n\n    // (4) given\n    sut = [[ZMTransportRequest alloc] initWithPath:@\"/hello\" method:ZMMethodPUT payload:@{@\"A\": @3} authentication:ZMTransportRequestAuthNeedsAccess];\n\n    // then\n    XCTAssertEqual(sut.acceptedResponseMediaTypes, ZMTransportAcceptTransportData);\n}\n\n@end\n\n\n\n@implementation ZMTransportRequestTests (HTTPHeaders)\n\n- (void)testThatItSetsBodyDataAndMediaTypeForTransportData;\n{\n    // given\n    NSDictionary *payload = @{@\"A\": @2};\n    ZMTransportRequest *sut = [[ZMTransportRequest alloc] initWithPath:@\"/foo\" method:ZMMethodPOST payload:payload];\n    NSMutableURLRequest *request = [[NSMutableURLRequest alloc] init];\n    \n    // when\n    [sut setBodyDataAndMediaTypeOnHTTPRequest:request];\n    \n    // then\n    XCTAssertNotNil(request.HTTPBody);\n    NSDictionary *body = (id) [NSJSONSerialization JSONObjectWithData:request.HTTPBody options:0 error:NULL];\n    AssertEqualDictionaries(body, payload);\n    XCTAssertEqualObjects([request valueForHTTPHeaderField:@\"Content-Type\"], @\"application/json\");\n}\n\n- (void)testThatItSetsAdditionalHeaderFieldsOnURLRequest;\n{\n    ZMTransportRequest *sut = [[ZMTransportRequest alloc] initWithPath:@\"/foo\" method:ZMMethodGET payload:nil];\n    [sut addValue:@\"as73e8f98a7==\" forAdditionalHeaderField:@\"Access-Token\"];\n    NSMutableURLRequest *request = [[NSMutableURLRequest alloc] init];\n\n    // when\n    [sut setAdditionalHeaderFieldsOnHTTPRequest:request];\n\n    // then\n    XCTAssertEqualObjects([request valueForHTTPHeaderField:@\"Access-Token\"], @\"as73e8f98a7==\");\n}\n\n- (void)testThatAssetGetRequestSetsAccessTokenIfPresent;\n{\n    // given\n    NSString *token = @\"NzFoNzJoZDYyMTI=\";\n    ZMTransportRequest *sut = [ZMTransportRequest assetGetRequestFromPath:@\"/assets/v3\" assetToken:token];\n    NSMutableURLRequest *request = [[NSMutableURLRequest alloc] init];\n    \n    // when\n    [sut setAdditionalHeaderFieldsOnHTTPRequest:request];\n    \n    // then\n    XCTAssertEqualObjects([request valueForHTTPHeaderField:@\"Asset-Token\"], token);\n}\n\n- (void)testThatAssetGetRequestDoesNotSetAccessTokenIfNotPresent;\n{\n    // given\n    ZMTransportRequest *sut = [ZMTransportRequest assetGetRequestFromPath:@\"/assets/v3\" assetToken:nil];\n    NSMutableURLRequest *request = [[NSMutableURLRequest alloc] init];\n    \n    // when\n    [sut setAdditionalHeaderFieldsOnHTTPRequest:request];\n    \n    // then\n    XCTAssertNil([request valueForHTTPHeaderField:@\"Asset-Token\"] );\n}\n\n- (void)testThatItSetsCompressedBodyDataAndMediaTypeForLargeTransportData;\n{\n    // given\n    NSMutableArray *payload = [NSMutableArray array];\n    for (int i = 0; i < 250; ++i) {\n        NSMutableData *data = [NSMutableData dataWithLength:sizeof(uuid_t)];\n        NSUUID *uuid = [NSUUID createUUID];\n        [uuid getUUIDBytes:data.mutableBytes];\n        NSDictionary *a = @{@\"card\": @(i),\n                            @\"data\": [data base64EncodedStringWithOptions:0],};\n        [payload addObject:a];\n    }\n    // The encoded transport data is approximately 46k bytes.\n    ZMTransportRequest *sut = [ZMTransportRequest requestWithPath:@\"/foo\" method:ZMMethodPOST payload:payload shouldCompress:YES];\n    NSMutableURLRequest *request = [[NSMutableURLRequest alloc] init];\n    NSString *expected = @\"H4sIAAAAAAAAE4XaS08qWRhG4f/C1DMoLlVQJzkD+yjeFRCvn\"\n    @\"R5wEwUUBRS10/+9k056sNdgffM9eJLlpeqt/effldFgNa78zH5UxoPNoPKzMpwUeWc2and\"\n    @\"7O+t5b5GV/eXubvfXr8o/P/4/XPXD0+RwzQ9vk8N1PfzHbnK44YdTc+6HU3Phh1NzUw//T\"\n    @\"s0tP5yaSz+cmque8HeKrnrDvVRd9Yh7+PHwintwe8Y9uL3jPtwech9uL7kPt6fch9tbtlN\"\n    @\"3zVu2U3fNW7bx++gt26m75i0P4PaWB3B7ywO4veUB3N7yEG5veQi3tzxM3XVveYg/gN7yK\"\n    @\"HXXveVR6q57yyO4veUR3N7yGG5veQy3tzyG21sew+0tT/Afx1uepO6GtzxJ3Q1veZK6G97\"\n    @\"yFG5veQq3tzyF21uewu0tz+D2lmdwe8uz1J17y7PUnXvL89Sde8tzPJp4y3O4veU53N7yA\"\n    @\"m5veQG3t7yA21tewO0tO6m78Jad1F14yw6eBb1lJ3UX3rILt7fswu0tu3B7yy7c3rIHt7f\"\n    @\"swe0te6m76S17ePj2lpepu+ktL1N301tewu0tL+H2ln24vWUfbm/Zh9tb9uH2lld42/GWV\"\n    @\"6m75S2vUnfLW16l7pa3vIbbW17D7S2v4faW13B7yxu4veUN3N7yJnWX3vImdZfe8jZ1l97\"\n    @\"yFq/F3vIWbm95C7e3vIPbW97B7S3v4PaWd3B7y3u8F2ce8x4vxpnXvOcS4Tnv8Wqcec8B7\"\n    @\"R50QLsXHdDuSQe0e9Mh7R51SLtXHcIeTEBDTkBedQR7MAKNYA9WoBHtXnVEu1cd0+5Vx7R\"\n    @\"71THtXnVMu1edcHvzqhPYgzVoAnswB01gD/agB9q96gPtXvWBdq/6QLtXndLuVae0e9Up7\"\n    @\"MEsNIU92IUeYQ+GoUcOtl71kXav+ki7V32i3as+0e5Vn2j3qk+0e9UZ7MFANIM9WIhmXMq\"\n    @\"96gz2YCOa0+5V57R71TntXnVOu1dd0O5VF7R71QXswVS04CcKr/oMezAWPcMerEXPtHvVZ\"\n    @\"9q96gvtXvWFdq/6QrtXfaHdqy75bcirLmEPVqMl7MFstIQ92I1eafeqr7R71Vfaveor7V7\"\n    @\"1jXav+ka7V32DPZiP3mAP9qMV7MGAtOIHRa+6ot2rrmj3qmvaveqadq+6pt2rrmn3qhvYg\"\n    @\"yFpA3uwJG34JderbmAPtqR32r3qO+1e9Z12r/pOu1f9oN2rftDuVT9gDyalD35C96pb2IN\"\n    @\"RaQt7sCptafeqW9q96iftXvWTdq/6SbtX/aTdq37x7oJX/cLH9GBb+sItgGBb+sI1gGBb+\"\n    @\"qbdq37T7lW/afeq37R71Yx2r5rR7lUz2INtKYM92JaqsAfbUpUXXrxqlXavWqXdq9Zo96o\"\n    @\"12r1qjXavWqPdq9ZhD7alOuzBtlTnTSOvWoc92JYatHvVBu1etUG7V23Q7lVz2r1qTrtXz\"\n    @\"WEPtqWcV7y8agF7sC0VsAfbUkG7Vy1o96pN2r1qk3av2qTdqzZp96ot3q3zqi3Yg22pBXu\"\n    @\"wLbVgD7alknavWtLuVUvavWpJu1fdod2r7tDuVXf+s//1L0rK7jh5LQAA\";\n    NSData *expectedBody = [[NSData alloc] initWithBase64EncodedString:expected options:0];\n    \n    // when\n    [sut setBodyDataAndMediaTypeOnHTTPRequest:request];\n    \n    // then\n    XCTAssertNotNil(request.HTTPBody);\n    AssertEqualData(request.HTTPBody, expectedBody);\n    XCTAssertEqualObjects([request valueForHTTPHeaderField:@\"Content-Type\"], @\"application/json\");\n    XCTAssertEqualObjects([request valueForHTTPHeaderField:@\"Content-Encoding\"], @\"gzip\");\n}\n\n- (void)testThatItSetsBodyDataAndMediaTypeForImageRequest;\n{\n    // given\n    NSData *data = [@\"jhasdhjkadshjklad\" dataUsingEncoding:NSUTF8StringEncoding];\n    ZMTransportRequest *sut = [[ZMTransportRequest alloc] initWithPath:@\"/foo\" method:ZMMethodPOST binaryData:data type:(__bridge NSString *) kUTTypeJPEG contentDisposition:nil];\n    NSMutableURLRequest *request = [[NSMutableURLRequest alloc] init];\n    \n    // when\n    [sut setBodyDataAndMediaTypeOnHTTPRequest:request];\n    \n    // then\n    XCTAssertEqualObjects(request.HTTPBody, data);\n    XCTAssertEqualObjects([request valueForHTTPHeaderField:@\"Content-Type\"], @\"image/jpeg\");\n}\n\n- (void)testThatItDoesNotSetMediaTypeForRequestWithoutPayload;\n{\n    // given\n    ZMTransportRequest *sut = [[ZMTransportRequest alloc] initWithPath:@\"/foo\" method:ZMMethodGET payload:nil];\n    NSMutableURLRequest *request = [[NSMutableURLRequest alloc] init];\n    \n    // when\n    [sut setBodyDataAndMediaTypeOnHTTPRequest:request];\n    \n    // then\n    XCTAssertNil(request.HTTPBody);\n    XCTAssertNil([request valueForHTTPHeaderField:@\"Content-Type\"]);\n}\n\n- (void)testThatItSetsTheContentTypeForFileUploadRequests;\n{\n    // given\n    NSString *contentType = @\"multipart/mixed; boundary=frontier\";\n    NSURL *fileURL = [NSURL URLWithString:@\"file://url/to/file\"];\n    ZMTransportRequest *sut = [ZMTransportRequest uploadRequestWithFileURL:fileURL\n                                                                      path:[[NSBundle mainBundle] bundlePath]\n                                                               contentType:contentType];\n    NSMutableURLRequest *request = [[NSMutableURLRequest alloc] init];\n    \n    // when\n    [sut setBodyDataAndMediaTypeOnHTTPRequest:request];\n    \n    // then\n    XCTAssertNil(request.HTTPBody);\n    XCTAssertEqualObjects([request valueForHTTPHeaderField:@\"Content-Type\"], contentType);\n}\n\n- (void)testThatItSetsTheContentDispositionForImageRequest;\n{\n    // given\n    NSData *data = [@\"jhasdhjkadshjklad\" dataUsingEncoding:NSUTF8StringEncoding];\n    NSDictionary *disposition = @{@\"A\": @YES, @\"b\": @1, @\"c\": @\"foo bar\", @\"d\": @\"z\", @\"e\": [NSNull null]};\n    ZMTransportRequest *sut = [[ZMTransportRequest alloc] initWithPath:@\"/foo\" method:ZMMethodPOST binaryData:data type:(__bridge NSString *) kUTTypeJPEG contentDisposition:disposition];\n    NSMutableURLRequest *request = [[NSMutableURLRequest alloc] init];\n    \n    // when\n    [sut setContentDispositionOnHTTPRequest:request];\n    \n    // then\n    XCTAssertEqualObjects([request valueForHTTPHeaderField:@\"Content-Disposition\"], @\"e;A=true;b=1;c=\\\"foo bar\\\";d=z\");\n}\n\n- (void)testThatItDoesNotSetTheContentDispositionHeaderWhenNoDispostionIsSpecified;\n{\n    // given\n    NSData *data = [@\"jhasdhjkadshjklad\" dataUsingEncoding:NSUTF8StringEncoding];\n    ZMTransportRequest *sut = [[ZMTransportRequest alloc] initWithPath:@\"/foo\" method:ZMMethodPOST binaryData:data type:(__bridge NSString *) kUTTypeJPEG contentDisposition:nil];\n    NSMutableURLRequest *request = [[NSMutableURLRequest alloc] init];\n    \n    // when\n    [sut setContentDispositionOnHTTPRequest:request];\n    \n    // then\n    XCTAssertNil([request valueForHTTPHeaderField:@\"Content-Disposition\"]);\n}\n\n- (void)testThatItSetsAnExpirationDate;\n{\n    // given\n    ZMTransportRequest *sut = [[ZMTransportRequest alloc] initWithPath:@\"/foo\" method:ZMMethodGET payload:nil];\n    NSTimeInterval interval = 35;\n    \n    // when\n    [sut expireAfterInterval:interval];\n    NSDate *expirationDate = sut.expirationDate;\n    \n    // then\n    NSDate *then = [NSDate dateWithTimeIntervalSinceNow:interval];\n    float timePrecision = 10.0f;\n    XCTAssertTrue(fabs(then.timeIntervalSinceReferenceDate - expirationDate.timeIntervalSinceReferenceDate) < timePrecision);\n    \n}\n\n@end\n\n\n\n@implementation ZMTransportRequestTests (Payload)\n\n- (void)testThatPOSTWithPayloadHasRequiredPayload\n{\n    // given\n    ZMTransportRequest *request = [ZMTransportRequest requestWithPath:@\"foo\" method:ZMMethodPOST payload:@{}];\n    \n    // then\n    XCTAssertTrue(request.hasRequiredPayload);\n}\n\n- (void)testThatPOSTWithNoPayloadHasRequiredPayload\n{\n    // given\n    ZMTransportRequest *request = [ZMTransportRequest requestWithPath:@\"foo\" method:ZMMethodPOST payload:nil];\n    \n    // then\n    XCTAssertTrue(request.hasRequiredPayload);\n}\n\n- (void)testThatDELETEWithPayloadHasRequiredPayload\n{\n    // given\n    ZMTransportRequest *request = [ZMTransportRequest requestWithPath:@\"Foo\" method:ZMMethodDELETE payload:@{}];\n    \n    // then\n    XCTAssertTrue(request.hasRequiredPayload);\n}\n\n- (void)testThatDELETEWithNoPayloadHasRequiredPayload\n{\n    // given\n    ZMTransportRequest *request = [ZMTransportRequest requestWithPath:@\"Foo\" method:ZMMethodDELETE payload:nil];\n    \n    // then\n    XCTAssertTrue(request.hasRequiredPayload);\n}\n\n- (void)testThatGETWithoutPayloadHasRequiredPayload\n{\n    // given\n    ZMTransportRequest *request = [ZMTransportRequest requestWithPath:@\"Foo\" method:ZMMethodGET payload:nil];\n    \n    // then\n    XCTAssertTrue(request.hasRequiredPayload);\n}\n\n- (void)testThatHEADHasRequiredPayload\n{\n    // given\n    ZMTransportRequest *request = [ZMTransportRequest requestWithPath:@\"foo\" method:ZMMethodHEAD payload:nil];\n    \n    // then\n    XCTAssertTrue(request.hasRequiredPayload);\n}\n\n@end\n\n\n@implementation ZMTransportRequestTests (TimeoutOverride)\n\n- (void)testThatItSetsTheTimeoutOverrideWhenTheApplicationisInTheBackgroundAndTheRequestDoesNotEnforceTheBackgroundSession;\n{\n    [self checkThatItDoesSetTheTimeoutInterval:YES applicationInBackground:YES usingBackgroundSession:NO];\n}\n\n- (void)testThatItDoesNotSetTheTimeoutOverrideWhenTheApplicationisInTheBackgroundAndTheRequestDoesEnforceTheBackgroundSession;\n{\n    [self checkThatItDoesSetTheTimeoutInterval:NO applicationInBackground:YES usingBackgroundSession:YES];\n}\n\n- (void)testThatItDoesNotSetTheTimeoutOverrideWhenTheApplicationisNotInTheBackgroundAndTheRequestDoesNotEnforceTheBackgroundSession;\n{\n    [self checkThatItDoesSetTheTimeoutInterval:NO applicationInBackground:NO usingBackgroundSession:NO];\n}\n\n- (void)testThatItDoesNotSetTheTimeoutOverrideWhenTheApplicationisNotInTheBackgroundAndTheRequestDoesEnforceTheBackgroundSession;\n{\n    [self checkThatItDoesSetTheTimeoutInterval:NO applicationInBackground:NO usingBackgroundSession:YES];\n}\n\n- (void)checkThatItDoesSetTheTimeoutInterval:(BOOL)shouldSetInterval\n                     applicationInBackground:(BOOL)backgrounded\n                      usingBackgroundSession:(BOOL)usingBackgroundSession\n{\n    // given\n    ZMTransportRequest *sut = [[ZMTransportRequest alloc] initWithPath:@\"/foo\" method:ZMMethodPOST payload:nil];\n    if (usingBackgroundSession) {\n        [sut forceToBackgroundSession];\n    }\n    \n    NSMutableURLRequest *request = [[NSMutableURLRequest alloc] init];\n    \n    // when\n    [sut setTimeoutIntervalOnRequestIfNeeded:request applicationIsBackgrounded:backgrounded usingBackgroundSession:usingBackgroundSession];\n    \n    // then\n    if (shouldSetInterval) {\n        XCTAssertEqual(request.timeoutInterval, 25);\n    } else {\n        XCTAssertEqual(request.timeoutInterval, 60);\n    }\n}\n\n@end\n\n\n@implementation ZMTransportRequestTests (Debugging)\n\n- (void)testThatItPrintsDebugInformation\n{\n    // given\n    NSString *info1 = @\"....xxxXXXxxx....\";\n    NSString *info2 = @\"32432525245345435\";\n    ZMTransportRequest *request = [ZMTransportRequest requestWithPath:@\"foo\" method:ZMMethodHEAD payload:nil];\n    \n    // when\n    [request addContentDebugInformation:info1];\n    [request addContentDebugInformation:info2];\n    \n    // then\n    NSString *description = request.description;\n    XCTAssertNotEqual([description rangeOfString:info1].location, NSNotFound);\n    XCTAssertNotEqual([description rangeOfString:info2].location, NSNotFound);\n\n}\n\n- (void)testPrivateDescription\n{\n    // given\n    ZMTransportRequest *request = [ZMTransportRequest requestWithPath:@\"foo\" method:ZMMethodHEAD payload:nil];\n    \n    // when\n    NSString *privateDescription = [request safeForLoggingDescription];\n    \n    // then\n    XCTAssertTrue([privateDescription rangeOfString:@\"HEAD\"].location != NSNotFound);\n    XCTAssertTrue([privateDescription rangeOfString:@\"foo\"].location != NSNotFound);\n}\n\n- (void)testPrivateDescriptionWithUUID\n{\n    // given\n    NSString *clientID = @\"608b4f25ba2b193\";\n    NSString *uuid = @\"9e86b08a-8de7-11e9-810f-22000a62954d\";\n    NSString *path = [NSString stringWithFormat:@\"do/something/%@/useful?client=%@\", uuid, clientID];\n    ZMTransportRequest *request = [ZMTransportRequest requestWithPath:path method:ZMMethodHEAD payload:nil];\n    \n    // when\n    NSString *privateDescription = [request safeForLoggingDescription];\n    \n    // then\n    XCTAssertTrue([privateDescription rangeOfString:@\"useful\"].location != NSNotFound);\n    XCTAssertTrue([privateDescription rangeOfString:@\"do/something\"].location != NSNotFound);\n    XCTAssertTrue([privateDescription rangeOfString:uuid].location == NSNotFound);\n    XCTAssertTrue([privateDescription rangeOfString:clientID].location == NSNotFound);\n}\n\n@end\n"], "fixing_code": ["//\n// Wire\n// Copyright (C) 2018 Wire Swiss GmbH\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with this program. If not, see http://www.gnu.org/licenses/.\n//\n\n\nimport Foundation\nimport WireUtilities\n\nextension String {\n    fileprivate static let UUIDMatcher: NSRegularExpression = {\n        let regex = try! NSRegularExpression(pattern: \"[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}\", options: .caseInsensitive)\n        return regex\n    }()\n    \n    fileprivate static let clientIDMatcher: NSRegularExpression = {\n        let regex = try! NSRegularExpression(pattern: \"[a-f0-9]{13,16}\", options: .caseInsensitive)\n        return regex\n    }()\n    \n    fileprivate static let matchers = [UUIDMatcher, clientIDMatcher]\n\n    var removingSensitiveInfo: String {\n        let result = NSMutableString(string: self)\n        let range = NSMakeRange(0, utf16.count)\n\n        String.matchers\n            .flatMap { $0.matches(in: self, options: [], range: range) }\n            .sorted { $0.range.lowerBound < $1.range.lowerBound }\n            .map { $0.range }\n            .reduce(into: [NSRange]()) { result, range in\n                guard let last = result.popLast() else {\n                    result.append(range)\n                    return\n                }\n\n                if NSIntersectionRange(last, range).length > 0 {\n                    let mergedRange = NSUnionRange(last, range)\n                    result.append(mergedRange)\n                } else {\n                    result.append(last)\n                    result.append(range)\n                }\n            }\n            .reversed()\n            .forEach {\n                let substring = result.substring(with: $0)\n                result.replaceCharacters(in: $0, with: substring.readableHash)\n            }\n\n        return result as String\n    }\n}\n\nextension ZMTransportRequest: SafeForLoggingStringConvertible {\n    @objc public var safeForLoggingDescription: String {\n        let identifier = \"\\(Unmanaged.passUnretained(self).toOpaque())\".readableHash\n        return \"<\\(identifier)> \\(ZMTransportRequest.string(for: self.method)) \\(self.path.removingSensitiveInfo)\"\n    }\n}\n", "// \n// Wire\n// Copyright (C) 2016 Wire Swiss GmbH\n// \n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n// \n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// GNU General Public License for more details.\n// \n// You should have received a copy of the GNU General Public License\n// along with this program. If not, see http://www.gnu.org/licenses/.\n// \n\n\n@import XCTest;\n@import WireTesting;\n@import WireTransport;\n@import WireSystem;\n@import WireUtilities;\n\n#if TARGET_OS_IPHONE\n@import MobileCoreServices;\n#else\n@import CoreServices;\n#endif\n\n#import \"ZMTransportRequest+Internal.h\"\n#import \"ZMTransportRequest+AssetGet.h\"\n\n\n@interface ZMTransportRequestTests : ZMTBaseTest\n\n@end\n\n@interface ZMTransportRequestTests (ResponseMediaTypes)\n@end\n@interface ZMTransportRequestTests (HTTPHeaders)\n@end\n@interface ZMTransportRequestTests (Payload)\n@end\n@interface ZMTransportRequestTests (TimeoutOverride)\n@end\n@interface ZMTransportRequestTests (Debugging)\n@end\n\n@implementation ZMTransportRequestTests\n\n-(void)testThatNeedsAuthenticationIsSetByDefault;\n{\n    XCTAssertTrue([[ZMTransportRequest alloc] initWithPath:@\"/bar\" method:ZMMethodPOST payload:@{}].needsAuthentication);\n    XCTAssertTrue([ZMTransportRequest requestGetFromPath:@\"/bar\"].needsAuthentication);\n    XCTAssertTrue([ZMTransportRequest requestWithPath:@\"/bar\" method:ZMMethodPOST payload:@{}].needsAuthentication);\n}\n\n-(void)testThatCreatesAccessTokenIsNotSetByDefault;\n{\n    XCTAssertFalse([[ZMTransportRequest alloc] initWithPath:@\"/bar\" method:ZMMethodPOST payload:@{}].responseWillContainAccessToken);\n    XCTAssertFalse([ZMTransportRequest requestGetFromPath:@\"/bar\"].responseWillContainAccessToken);\n    XCTAssertFalse([ZMTransportRequest requestWithPath:@\"/bar\" method:ZMMethodPOST payload:@{}].responseWillContainAccessToken);\n}\n\n- (void)testThatNeedsAuthenticationIsSet\n{\n    XCTAssertFalse([[ZMTransportRequest alloc] initWithPath:@\"/bar\" method:ZMMethodPOST payload:@{} authentication:ZMTransportRequestAuthNone].needsAuthentication);\n    XCTAssertFalse([[ZMTransportRequest alloc] initWithPath:@\"/bar\" method:ZMMethodPOST payload:@{} authentication:ZMTransportRequestAuthCreatesCookieAndAccessToken].needsAuthentication);\n    XCTAssertTrue([[ZMTransportRequest alloc] initWithPath:@\"/bar\" method:ZMMethodPOST payload:@{} authentication:ZMTransportRequestAuthNeedsAccess].needsAuthentication);\n    XCTAssertTrue([[ZMTransportRequest alloc] initWithPath:@\"/bar\" method:ZMMethodPOST payload:@{} authentication:ZMTransportRequestAuthNeedsCookieAndAccessToken].needsAuthentication);\n}\n\n- (void)testThatNeedsCookieIsSet\n{\n    XCTAssertFalse([[ZMTransportRequest alloc] initWithPath:@\"/bar\" method:ZMMethodPOST payload:@{} authentication:ZMTransportRequestAuthNone].needsCookie);\n    XCTAssertFalse([[ZMTransportRequest alloc] initWithPath:@\"/bar\" method:ZMMethodPOST payload:@{} authentication:ZMTransportRequestAuthCreatesCookieAndAccessToken].needsCookie);\n    XCTAssertFalse([[ZMTransportRequest alloc] initWithPath:@\"/bar\" method:ZMMethodPOST payload:@{} authentication:ZMTransportRequestAuthNeedsAccess].needsCookie);\n    XCTAssertTrue([[ZMTransportRequest alloc] initWithPath:@\"/bar\" method:ZMMethodPOST payload:@{} authentication:ZMTransportRequestAuthNeedsCookieAndAccessToken].needsCookie);\n}\n\n- (void)testThatCreatesAccessTokenIsSet\n{\n    XCTAssertFalse([[ZMTransportRequest alloc] initWithPath:@\"/bar\" method:ZMMethodPOST payload:@{} authentication:ZMTransportRequestAuthNone].responseWillContainAccessToken);\n    XCTAssertTrue([[ZMTransportRequest alloc] initWithPath:@\"/bar\" method:ZMMethodPOST payload:@{} authentication:ZMTransportRequestAuthCreatesCookieAndAccessToken].responseWillContainAccessToken);\n    XCTAssertFalse([[ZMTransportRequest alloc] initWithPath:@\"/bar\" method:ZMMethodPOST payload:@{} authentication:ZMTransportRequestAuthNeedsAccess].responseWillContainAccessToken);\n}\n\n- (void)testThatResponseWillContainCookieIsSet;\n{\n    XCTAssertFalse([[ZMTransportRequest alloc] initWithPath:@\"/bar\" method:ZMMethodPOST payload:@{} authentication:ZMTransportRequestAuthNone].responseWillContainCookie);\n    XCTAssertTrue([[ZMTransportRequest alloc] initWithPath:@\"/bar\" method:ZMMethodPOST payload:@{} authentication:ZMTransportRequestAuthCreatesCookieAndAccessToken].responseWillContainCookie);\n    XCTAssertFalse([[ZMTransportRequest alloc] initWithPath:@\"/bar\" method:ZMMethodPOST payload:@{} authentication:ZMTransportRequestAuthNeedsAccess].responseWillContainCookie);\n}\n\n-(void)testThatRequestGetFromPathSetsProperties\n{\n    // given\n    NSString *originalPath = @\"foo-bar\";\n    NSMutableString *path = [NSMutableString stringWithString:originalPath];\n    \n    // when\n    ZMTransportRequest *request = [ZMTransportRequest requestGetFromPath:path];\n    [path setString:@\"baz\"]; // test that it is copied\n    \n    // then\n    XCTAssertEqualObjects(request.path, originalPath);\n    XCTAssertEqual(request.method, ZMMethodGET);\n    XCTAssertNil(request.payload);\n    XCTAssertFalse(request.shouldFailInsteadOfRetry);\n    XCTAssertEqual(request.contentDisposition.count, 0U);\n}\n\n- (void)testThatRequestWithBinaryDataSetsProperties;\n{\n    // given\n    NSString * const path = @\"/some/path\";\n    ZMTransportRequestMethod const method = ZMMethodPOST;\n    NSData * const data = [NSData dataWithBytes:((const char []){'z', 'q'}) length:2];\n    NSDictionary * const disposition = @{@\"zasset\": [NSNull null], @\"conv_id\": [NSUUID createUUID].transportString};\n    \n    // when\n    ZMTransportRequest *request = [[ZMTransportRequest alloc] initWithPath:path method:method binaryData:data type:(__bridge id) kUTTypePNG contentDisposition:disposition];\n    \n    // then\n    XCTAssertNotNil(request);\n    XCTAssertNil(request.payload);\n    XCTAssertEqualObjects(request.path, path);\n    XCTAssertEqual(request.method, method);\n    XCTAssertEqualObjects(request.contentDisposition, disposition);\n    XCTAssertEqualObjects(request.binaryData, data);\n    XCTAssertEqualObjects(request.binaryDataType, (__bridge id) kUTTypePNG);\n    XCTAssertFalse(request.shouldFailInsteadOfRetry);\n}\n\n- (void)testThatFileUploadRequestSetsProperties;\n{\n    // given\n    NSURL *fileURL = [NSURL URLWithString:@\"/url/to/some/private/file\"];\n    NSString *path = @\"some/path\";\n    \n    // when\n    NSString *contentType = @\"multipart/mixed; boundary=frontier\";\n    ZMTransportRequest *request = [ZMTransportRequest uploadRequestWithFileURL:fileURL path:path contentType:contentType];\n    \n    // then\n    XCTAssertNotNil(request);\n    XCTAssertNil(request.payload);\n    XCTAssertEqualObjects(request.path, path);\n    XCTAssertEqual(request.method, ZMMethodPOST);\n    XCTAssertNil(request.contentDisposition);\n    XCTAssertNil(request.binaryData);\n    XCTAssertEqualObjects(fileURL, request.fileUploadURL);\n    XCTAssertTrue(request.shouldUseOnlyBackgroundSession);\n    XCTAssertTrue(request.shouldFailInsteadOfRetry);\n}\n\n- (void)testThatEmptyPUTRequestSetsProperties;\n{\n    // given\n    NSString * const path = @\"/some/path\";\n    ZMTransportRequestMethod const method = ZMMethodPUT;\n    \n    // when\n    ZMTransportRequest *request = [ZMTransportRequest emptyPutRequestWithPath:path];\n    NSMutableURLRequest *httpRequest = [[NSMutableURLRequest alloc] init];\n    [request setBodyDataAndMediaTypeOnHTTPRequest:httpRequest];\n    \n    // when\n\n    // then\n    XCTAssertNotNil(request);\n    XCTAssertNil(request.payload);\n    XCTAssertEqualObjects(request.path, path);\n    XCTAssertEqual(request.method, method);\n    XCTAssertNil(request.contentDisposition);\n    XCTAssertFalse(request.shouldFailInsteadOfRetry);\n    XCTAssertEqualObjects(request.binaryData, [NSData data]);\n    XCTAssertEqualObjects([httpRequest valueForHTTPHeaderField:@\"Content-Type\"], @\"application/json\");\n}\n\n- (void)testThatImagePostRequestSetsProperties;\n{\n    // given\n    NSString * const path = @\"/some/path\";\n    NSData * const data = [self verySmallJPEGData];\n    NSDictionary * const disposition = @{@\"zasset\": [NSNull null], @\"conv_id\": [NSUUID createUUID].transportString};\n    \n    // when\n    ZMTransportRequest *request = [ZMTransportRequest postRequestWithPath:path imageData:data contentDisposition:disposition];\n    \n    // then\n    XCTAssertNotNil(request);\n    XCTAssertNil(request.payload);\n    XCTAssertEqualObjects(request.path, path);\n    XCTAssertEqual(request.method, ZMMethodPOST);\n    XCTAssertEqualObjects(request.contentDisposition, disposition);\n    XCTAssertEqualObjects(request.binaryData, data);\n    XCTAssertFalse(request.shouldFailInsteadOfRetry);\n    XCTAssertEqualObjects(request.binaryDataType, (__bridge id) kUTTypeJPEG);\n}\n\n- (void)testThatImagePostRequestIsNilForNonImageData\n{\n    // given\n    NSData * const textData = [self dataForResource:@\"Lorem Ipsum\" extension:@\"txt\"];\n    XCTAssertNotNil(textData);\n    \n    // when\n    ZMTransportRequest *request = [ZMTransportRequest postRequestWithPath:@\"/some/path\" imageData:textData contentDisposition:@{}];\n    \n    // then\n    XCTAssertNil(request);\n}\n\n- (void)testThatMultipartImagePostRequestSetsProperties;\n{\n    // given\n    NSString * const path = @\"/some/path\";\n    NSData * const data = [self verySmallJPEGData];\n    NSDictionary * const disposition = @{@\"zasset\": [NSNull null], @\"conv_id\": [NSUUID createUUID].transportString};\n\n    NSString *boundary = @\"frontier\";\n    NSData *metaDataData = [NSJSONSerialization dataWithJSONObject:disposition options:0 error:NULL];\n\n    // when\n    ZMTransportRequest *request = [ZMTransportRequest multipartRequestWithPath:path imageData:data metaData:disposition];\n    \n    // then\n    XCTAssertNotNil(request);\n    XCTAssertNil(request.payload);\n    XCTAssertEqualObjects(request.path, path);\n    XCTAssertEqual(request.method, ZMMethodPOST);\n    XCTAssertNil(request.contentDisposition);\n    XCTAssertFalse(request.shouldFailInsteadOfRetry);\n    NSArray *items = [request multipartBodyItems];\n    XCTAssertEqual(items.count, 2u);\n\n    ZMMultipartBodyItem *metadataItem = items.firstObject;\n    XCTAssertEqualObjects(metadataItem.contentType, @\"application/json; charset=utf-8\");\n    XCTAssertEqualObjects(metadataItem.data, metaDataData);\n\n    ZMMultipartBodyItem *imageItem = items.lastObject;\n    XCTAssertEqualObjects(imageItem.contentType, @\"image/jpeg\");\n    XCTAssertEqualObjects(imageItem.headers, @{@\"Content-MD5\": [[data zmMD5Digest] base64EncodedStringWithOptions:0]});\n    XCTAssertEqualObjects(imageItem.data, data);\n    \n    NSString *expectedContentType = [NSString stringWithFormat:@\"multipart/mixed; boundary=%@\", boundary];\n    XCTAssertEqualObjects(request.binaryDataType, expectedContentType);\n}\n\n- (void)testThatMultipartImagePostRequestIsNilForNonImageData\n{\n    // given\n    NSData * const textData = [self dataForResource:@\"Lorem Ipsum\" extension:@\"txt\"];\n    XCTAssertNotNil(textData);\n    \n    // when\n    ZMTransportRequest *request = [ZMTransportRequest multipartRequestWithPath:@\"/some/path\" imageData:textData metaData:@{}];\n    \n    // then\n    XCTAssertNil(request);\n}\n\n- (void)testThatItCallsTaskCreatedHandler\n{\n    // given\n    XCTestExpectation *expectation = [self expectationWithDescription:@\"Task created handler called\"];\n    ZMTransportRequest *transportRequest = [ZMTransportRequest requestWithPath:@\"/something\" method:ZMMethodPUT payload:@{}];\n    ZMTaskIdentifier *expectedIdentifier = [ZMTaskIdentifier identifierWithIdentifier:2 sessionIdentifier:@\"test-session\"];\n    \n    ZMTaskCreatedHandler *handler = [ZMTaskCreatedHandler handlerOnGroupQueue:self.fakeSyncContext block:^(ZMTaskIdentifier *identifier) {\n        XCTAssertEqualObjects(identifier, expectedIdentifier);\n        [expectation fulfill];\n    }];\n    \n    [transportRequest addTaskCreatedHandler:handler];\n    \n    // when\n    [transportRequest callTaskCreationHandlersWithIdentifier:2 sessionIdentifier:@\"test-session\"];\n    \n    // then\n    XCTAssert([self waitForCustomExpectationsWithTimeout:0.5]);\n}\n\n- (void)testThatItCallsMultipleTaskCreatedHandlers\n{\n    // given\n    XCTestExpectation *firstExpectation = [self expectationWithDescription:@\"First task created handler called\"];\n    XCTestExpectation *secondExpectation = [self expectationWithDescription:@\"Second task created handler called\"];;\n    \n    ZMTransportRequest *transportRequest = [ZMTransportRequest requestWithPath:@\"/something\" method:ZMMethodPUT payload:@{}];\n    ZMTaskIdentifier *expectedIdentifier = [ZMTaskIdentifier identifierWithIdentifier:2 sessionIdentifier:@\"test-session\"];\n    \n    ZMTaskCreatedHandler *firstHandler = [ZMTaskCreatedHandler handlerOnGroupQueue:self.fakeSyncContext block:^(ZMTaskIdentifier *identifier) {\n        XCTAssertEqualObjects(identifier, expectedIdentifier);\n        [firstExpectation fulfill];\n    }];\n    \n    ZMTaskCreatedHandler *secondHandler = [ZMTaskCreatedHandler handlerOnGroupQueue:self.fakeSyncContext block:^(ZMTaskIdentifier *identifier) {\n        XCTAssertEqualObjects(identifier, expectedIdentifier);\n        [secondExpectation fulfill];\n    }];\n    \n    [transportRequest addTaskCreatedHandler:firstHandler];\n    [transportRequest addTaskCreatedHandler:secondHandler];\n    \n    // when\n    [transportRequest callTaskCreationHandlersWithIdentifier:2 sessionIdentifier:@\"test-session\"];\n    \n    // then\n    XCTAssert([self waitForCustomExpectationsWithTimeout:0.5]);\n}\n\n- (void)testThatItDoesNotAttemptToCallATaskCreatedHandlerIfNoneIsSet\n{\n    // given\n    ZMTransportRequest *transportRequest = [ZMTransportRequest requestWithPath:@\"/something\" method:ZMMethodPUT payload:@{}];\n    \n    // when\n    XCTAssertNoThrow([transportRequest callTaskCreationHandlersWithIdentifier:0 sessionIdentifier:@\"\"]);\n}\n\n- (void)testThatItSetsStartOfUploadTimestamp\n{\n    // given\n    ZMTransportRequest *transportRequest = [ZMTransportRequest requestWithPath:@\"/something\" method:ZMMethodPUT payload:@{}];\n    [transportRequest markStartOfUploadTimestamp];\n    \n    ZMTransportResponse *response = [ZMTransportResponse responseWithPayload:@{@\"name\":@\"foo\"} HTTPStatus:213 transportSessionError:nil];\n    \n    // when\n    [transportRequest completeWithResponse:response];\n    \n    // then\n    XCTAssertEqual(transportRequest.startOfUploadTimestamp, response.startOfUploadTimestamp);\n}\n\n- (void)testThatItCallsTheCompletionHandler\n{\n    // given\n    XCTestExpectation *expectation = [self expectationWithDescription:@\"Completion handler called\"];\n    ZMTransportRequest *transportRequest = [ZMTransportRequest requestWithPath:@\"/something\" method:ZMMethodPUT payload:@{}];\n\n    [transportRequest addCompletionHandler:\n     [ZMCompletionHandler handlerOnGroupQueue:self.fakeSyncContext block:^(ZMTransportResponse *response ZM_UNUSED){\n        [expectation fulfill];\n    }]];\n\n    // when\n    [transportRequest completeWithResponse:[[ZMTransportResponse alloc] init]];\n\n    // then\n    XCTAssert([self waitForCustomExpectationsWithTimeout:0.5]);\n}\n\n- (void)testThatItCallsMultipleCompletionHandlers\n{\n    // given\n    XCTestExpectation *expectation1 = [self expectationWithDescription:@\"Completion 1 handler called\"];\n    XCTestExpectation *expectation2 = [self expectationWithDescription:@\"Completion 2 handler called\"];\n\n    ZMTransportRequest *transportRequest = [ZMTransportRequest requestWithPath:@\"/something\" method:ZMMethodPUT payload:@{}];\n    \n    [transportRequest addCompletionHandler:\n     [ZMCompletionHandler handlerOnGroupQueue:self.fakeSyncContext block:^(ZMTransportResponse *response ZM_UNUSED){\n        [expectation1 fulfill];\n    }]];\n    \n    [transportRequest addCompletionHandler:\n     [ZMCompletionHandler handlerOnGroupQueue:self.fakeSyncContext block:^(ZMTransportResponse *response ZM_UNUSED){\n        [expectation2 fulfill];\n    }]];\n    \n    // when\n    [transportRequest completeWithResponse:[[ZMTransportResponse alloc] init]];\n    \n    // then\n    XCTAssert([self waitForCustomExpectationsWithTimeout:0.5]);\n}\n\n\n- (void)testThatItDoesNotAttemptToCallACompletionHandlerIfNoneIsSet\n{\n    // given\n    ZMTransportRequest *transportRequest = [ZMTransportRequest requestWithPath:@\"/something\" method:ZMMethodPUT payload:@{}];\n\n    // when\n    XCTAssertNoThrow([transportRequest completeWithResponse:[[ZMTransportResponse alloc] init]]);\n}\n\n\n- (void)testThatCompletionHandlerIsExecutedWithTheResponse;\n{\n    // given\n    XCTestExpectation *expectation = [self expectationWithDescription:@\"Completion handler called\"];\n    ZMTransportResponse *response = [ZMTransportResponse responseWithPayload:@{@\"name\":@\"foo\"} HTTPStatus:213 transportSessionError:nil];\n    __block ZMTransportResponse *receivedResponse;\n    \n    ZMTransportRequest *request = [ZMTransportRequest requestWithPath:@\"\" method:ZMMethodGET payload:nil];\n    [request addCompletionHandler:\n     [ZMCompletionHandler handlerOnGroupQueue:self.fakeSyncContext block:^(ZMTransportResponse *actualResponse){\n        receivedResponse = actualResponse;\n        [expectation fulfill];\n    }]];\n    \n    // when\n    [request completeWithResponse:response];\n    \n    // then\n    XCTAssert([self waitForCustomExpectationsWithTimeout:0.5]);\n    XCTAssertEqualObjects(response, receivedResponse);\n}\n\n\n- (void)testThatCompletionHandlersAreExecutedFromFirstToLast\n{\n    // given\n    XCTestExpectation *expectation1 = [self expectationWithDescription:@\"Completion 1 handler called\"];\n    XCTestExpectation *expectation2 = [self expectationWithDescription:@\"Completion 2 handler called\"];\n    XCTestExpectation *expectation3 = [self expectationWithDescription:@\"Completion 3 handler called\"];\n    ZMTransportResponse *response = [ZMTransportResponse responseWithPayload:@{} HTTPStatus:200 transportSessionError:nil];\n\n    __block NSMutableString *responses = [[NSMutableString alloc] init];\n\n\n    ZMTransportRequest *request = [ZMTransportRequest requestWithPath:@\"\" method:ZMMethodGET payload:nil];\n\n    [request addCompletionHandler:[ZMCompletionHandler handlerOnGroupQueue:self.fakeSyncContext block:^(ZMTransportResponse *resp) {\n        NOT_USED(resp);\n        [responses appendString:@\"a\"];\n        [expectation1 fulfill];\n    }]];\n\n    [request addCompletionHandler:[ZMCompletionHandler handlerOnGroupQueue:self.fakeSyncContext block:^(ZMTransportResponse *resp) {\n        NOT_USED(resp);\n        [responses appendString:@\"b\"];\n        [expectation2 fulfill];\n    }]];\n\n    [request addCompletionHandler:[ZMCompletionHandler handlerOnGroupQueue:self.fakeSyncContext block:^(ZMTransportResponse *resp) {\n        NOT_USED(resp);\n        [responses appendString:@\"c\"];\n        [expectation3 fulfill];\n    }]];\n\n    // when\n    [request completeWithResponse:response];\n\n    // then\n    XCTAssert([self waitForCustomExpectationsWithTimeout:0.5]);\n    XCTAssertEqualObjects(responses, @\"abc\");\n}\n\n\n- (void)testThatItCallsTaskProgressHandler\n{\n    // given\n    const float expectedProgress = 0.5f;\n    \n    XCTestExpectation *expectation = [self expectationWithDescription:@\"Task progress handler called\"];\n    ZMTransportRequest *transportRequest = [ZMTransportRequest requestWithPath:@\"/something\" method:ZMMethodPUT payload:@{}];\n    \n    [transportRequest addProgressHandler: [ZMTaskProgressHandler handlerOnGroupQueue:self.fakeSyncContext block:^(float progress) {\n        XCTAssertEqual(expectedProgress, progress);\n        [expectation fulfill];\n    }]];\n    \n    // when\n    [transportRequest updateProgress:expectedProgress];\n    \n    // then\n    XCTAssert([self waitForCustomExpectationsWithTimeout:0.5]);\n}\n\n- (void)testThatItCallsTaskProgressHandlerContinuously\n{\n    // given\n    const static float expectedProgress[] = {0.0f, 0.1f, 0.5f, 0.9f, 1.0f};\n    const static size_t expectedProgressSize = sizeof(expectedProgress) / sizeof(expectedProgress[0]);\n    \n    XCTestExpectation *expectation = [self expectationWithDescription:@\"Task progress handler called\"];\n    ZMTransportRequest *transportRequest = [ZMTransportRequest requestWithPath:@\"/something\" method:ZMMethodPUT payload:@{}];\n    \n    NSUInteger __block currentCallIndex = 0;\n    \n    [transportRequest addProgressHandler: [ZMTaskProgressHandler handlerOnGroupQueue:self.fakeSyncContext block:^(float progress) {\n        XCTAssertEqual(expectedProgress[currentCallIndex], progress);\n        currentCallIndex++;\n        \n        if (currentCallIndex == expectedProgressSize) {\n            [expectation fulfill];\n        }\n    }]];\n    \n    // when\n    for (size_t i = 0 ; i < expectedProgressSize; i++) {\n        [transportRequest updateProgress:expectedProgress[i]];\n    }\n    \n    // then\n    XCTAssert([self waitForCustomExpectationsWithTimeout:0.5]);\n}\n\n- (void)testThatItCallsTaskProgressHandlerWithProgressLessOrEqualToComplete\n{\n    // given\n    const float randomProgress = 1000234.0f;\n    const float expectedProgress = 1.0f;\n    \n    XCTestExpectation *expectation = [self expectationWithDescription:@\"Task progress handler called\"];\n    ZMTransportRequest *transportRequest = [ZMTransportRequest requestWithPath:@\"/something\" method:ZMMethodPUT payload:@{}];\n    \n    [transportRequest addProgressHandler: [ZMTaskProgressHandler handlerOnGroupQueue:self.fakeSyncContext block:^(float progress) {\n        XCTAssertEqual(expectedProgress, progress);\n        [expectation fulfill];\n    }]];\n    \n    // when\n    [transportRequest updateProgress:randomProgress];\n    \n    // then\n    XCTAssert([self waitForCustomExpectationsWithTimeout:0.5]);\n}\n\n- (void)testThatItCallsTaskProgressHandlerWithProgressLessOrEqualToInitial\n{\n    // given\n    const float randomProgress = -123.0f;\n    const float expectedProgress = 0.0f;\n    \n    XCTestExpectation *expectation = [self expectationWithDescription:@\"Task progress handler called\"];\n    ZMTransportRequest *transportRequest = [ZMTransportRequest requestWithPath:@\"/something\" method:ZMMethodPUT payload:@{}];\n    \n    [transportRequest addProgressHandler: [ZMTaskProgressHandler handlerOnGroupQueue:self.fakeSyncContext block:^(float progress) {\n        XCTAssertEqual(expectedProgress, progress);\n        [expectation fulfill];\n    }]];\n    \n    // when\n    [transportRequest updateProgress:randomProgress];\n    \n    // then\n    XCTAssert([self waitForCustomExpectationsWithTimeout:0.5]);\n}\n\n- (void)testThatItCallsMultipleTaskProgressHandlers\n{\n    // given\n    const float expectedProgress = 0.5f;\n    \n    XCTestExpectation *expectation1 = [self expectationWithDescription:@\"Task progress handler 1 called\"];\n    XCTestExpectation *expectation2 = [self expectationWithDescription:@\"Task progress handler 2 called\"];\n\n    ZMTransportRequest *transportRequest = [ZMTransportRequest requestWithPath:@\"/something\" method:ZMMethodPUT payload:@{}];\n    \n    [transportRequest addProgressHandler: [ZMTaskProgressHandler handlerOnGroupQueue:self.fakeSyncContext block:^(float progress) {\n        XCTAssertEqual(expectedProgress, progress);\n        [expectation1 fulfill];\n    }]];\n    \n    [transportRequest addProgressHandler: [ZMTaskProgressHandler handlerOnGroupQueue:self.fakeSyncContext block:^(float progress) {\n        XCTAssertEqual(expectedProgress, progress);\n        [expectation2 fulfill];\n    }]];\n    \n    // when\n    [transportRequest updateProgress:expectedProgress];\n    \n    // then\n    XCTAssert([self waitForCustomExpectationsWithTimeout:0.5]);\n}\n\n- (void)testThatItDoesNotAttemptToCallATaskProgressHandlerIfNoneIsSet\n{\n    // given\n    ZMTransportRequest *transportRequest = [ZMTransportRequest requestWithPath:@\"/something\" method:ZMMethodPUT payload:@{}];\n    \n    // when\n    XCTAssertNoThrow([transportRequest updateProgress:1.0f]);\n}\n\n\n- (void)testThatARequestShouldBeExecutedOnlyOnForegroundSessionByDefault\n{\n    // given\n    ZMTransportRequest *request = [ZMTransportRequest requestGetFromPath:@\"Foo\"];\n    \n    // then\n    XCTAssertFalse(request.shouldUseOnlyBackgroundSession);\n    XCTAssertFalse(request.shouldUseVoipSession);\n}\n\n- (void)testThatARequestShouldUseOnlyBackgroundSessionWhenForced\n{\n    // given\n    ZMTransportRequest *request = [ZMTransportRequest requestGetFromPath:@\"Foo\"];\n\n    // when\n    [request forceToBackgroundSession];\n    \n    // then\n    XCTAssertTrue(request.shouldUseOnlyBackgroundSession);\n    XCTAssertFalse(request.shouldUseVoipSession);\n}\n\n- (void)testThatARequestShouldUseOnlyVoipSessionWhenForced\n{\n    // given\n    ZMTransportRequest *request = [ZMTransportRequest requestGetFromPath:@\"Foo\"];\n    \n    // when\n    [request forceToVoipSession];\n    \n    // then\n    XCTAssertTrue(request.shouldUseVoipSession);\n    XCTAssertFalse(request.shouldUseOnlyBackgroundSession);\n\n}\n\n\n@end\n\n\n\n@implementation ZMTransportRequestTests (ResponseMediaTypes)\n\n- (void)testThatItSetsAcceptsImageData;\n{\n    // given\n    ZMTransportRequest *sut = [ZMTransportRequest imageGetRequestFromPath:@\"/foo/bar\"];\n    \n    // then\n    XCTAssertEqual(sut.acceptedResponseMediaTypes, ZMTransportAcceptImage);\n}\n\n- (void)testThatItSetsAcceptsTransportData;\n{\n    // (1) given\n    ZMTransportRequest *sut = [ZMTransportRequest requestGetFromPath:@\"/foo/bar\"];\n    \n    // then\n    XCTAssertEqual(sut.acceptedResponseMediaTypes, ZMTransportAcceptTransportData);\n    \n    // (2) given\n    sut = [ZMTransportRequest requestWithPath:@\"/foo2\" method:ZMMethodPOST payload:@{@\"f\": @2}];\n    \n    // then\n    XCTAssertEqual(sut.acceptedResponseMediaTypes, ZMTransportAcceptTransportData);\n\n    // (3) given\n    sut = [[ZMTransportRequest alloc] initWithPath:@\"/hello\" method:ZMMethodPUT binaryData:[@\"asdf\" dataUsingEncoding:NSUTF8StringEncoding] type:@\"image/jpeg\" contentDisposition:@{@\"asdf\": @42}];\n    \n    // then\n    XCTAssertEqual(sut.acceptedResponseMediaTypes, ZMTransportAcceptTransportData);\n\n    // (4) given\n    sut = [[ZMTransportRequest alloc] initWithPath:@\"/hello\" method:ZMMethodPUT payload:@{@\"A\": @3} authentication:ZMTransportRequestAuthNeedsAccess];\n\n    // then\n    XCTAssertEqual(sut.acceptedResponseMediaTypes, ZMTransportAcceptTransportData);\n}\n\n@end\n\n\n\n@implementation ZMTransportRequestTests (HTTPHeaders)\n\n- (void)testThatItSetsBodyDataAndMediaTypeForTransportData;\n{\n    // given\n    NSDictionary *payload = @{@\"A\": @2};\n    ZMTransportRequest *sut = [[ZMTransportRequest alloc] initWithPath:@\"/foo\" method:ZMMethodPOST payload:payload];\n    NSMutableURLRequest *request = [[NSMutableURLRequest alloc] init];\n    \n    // when\n    [sut setBodyDataAndMediaTypeOnHTTPRequest:request];\n    \n    // then\n    XCTAssertNotNil(request.HTTPBody);\n    NSDictionary *body = (id) [NSJSONSerialization JSONObjectWithData:request.HTTPBody options:0 error:NULL];\n    AssertEqualDictionaries(body, payload);\n    XCTAssertEqualObjects([request valueForHTTPHeaderField:@\"Content-Type\"], @\"application/json\");\n}\n\n- (void)testThatItSetsAdditionalHeaderFieldsOnURLRequest;\n{\n    ZMTransportRequest *sut = [[ZMTransportRequest alloc] initWithPath:@\"/foo\" method:ZMMethodGET payload:nil];\n    [sut addValue:@\"as73e8f98a7==\" forAdditionalHeaderField:@\"Access-Token\"];\n    NSMutableURLRequest *request = [[NSMutableURLRequest alloc] init];\n\n    // when\n    [sut setAdditionalHeaderFieldsOnHTTPRequest:request];\n\n    // then\n    XCTAssertEqualObjects([request valueForHTTPHeaderField:@\"Access-Token\"], @\"as73e8f98a7==\");\n}\n\n- (void)testThatAssetGetRequestSetsAccessTokenIfPresent;\n{\n    // given\n    NSString *token = @\"NzFoNzJoZDYyMTI=\";\n    ZMTransportRequest *sut = [ZMTransportRequest assetGetRequestFromPath:@\"/assets/v3\" assetToken:token];\n    NSMutableURLRequest *request = [[NSMutableURLRequest alloc] init];\n    \n    // when\n    [sut setAdditionalHeaderFieldsOnHTTPRequest:request];\n    \n    // then\n    XCTAssertEqualObjects([request valueForHTTPHeaderField:@\"Asset-Token\"], token);\n}\n\n- (void)testThatAssetGetRequestDoesNotSetAccessTokenIfNotPresent;\n{\n    // given\n    ZMTransportRequest *sut = [ZMTransportRequest assetGetRequestFromPath:@\"/assets/v3\" assetToken:nil];\n    NSMutableURLRequest *request = [[NSMutableURLRequest alloc] init];\n    \n    // when\n    [sut setAdditionalHeaderFieldsOnHTTPRequest:request];\n    \n    // then\n    XCTAssertNil([request valueForHTTPHeaderField:@\"Asset-Token\"] );\n}\n\n- (void)testThatItSetsCompressedBodyDataAndMediaTypeForLargeTransportData;\n{\n    // given\n    NSMutableArray *payload = [NSMutableArray array];\n    for (int i = 0; i < 250; ++i) {\n        NSMutableData *data = [NSMutableData dataWithLength:sizeof(uuid_t)];\n        NSUUID *uuid = [NSUUID createUUID];\n        [uuid getUUIDBytes:data.mutableBytes];\n        NSDictionary *a = @{@\"card\": @(i),\n                            @\"data\": [data base64EncodedStringWithOptions:0],};\n        [payload addObject:a];\n    }\n    // The encoded transport data is approximately 46k bytes.\n    ZMTransportRequest *sut = [ZMTransportRequest requestWithPath:@\"/foo\" method:ZMMethodPOST payload:payload shouldCompress:YES];\n    NSMutableURLRequest *request = [[NSMutableURLRequest alloc] init];\n    NSString *expected = @\"H4sIAAAAAAAAE4XaS08qWRhG4f/C1DMoLlVQJzkD+yjeFRCvn\"\n    @\"R5wEwUUBRS10/+9k056sNdgffM9eJLlpeqt/effldFgNa78zH5UxoPNoPKzMpwUeWc2and\"\n    @\"7O+t5b5GV/eXubvfXr8o/P/4/XPXD0+RwzQ9vk8N1PfzHbnK44YdTc+6HU3Phh1NzUw//T\"\n    @\"s0tP5yaSz+cmque8HeKrnrDvVRd9Yh7+PHwintwe8Y9uL3jPtwech9uL7kPt6fch9tbtlN\"\n    @\"3zVu2U3fNW7bx++gt26m75i0P4PaWB3B7ywO4veUB3N7yEG5veQi3tzxM3XVveYg/gN7yK\"\n    @\"HXXveVR6q57yyO4veUR3N7yGG5veQy3tzyG21sew+0tT/Afx1uepO6GtzxJ3Q1veZK6G97\"\n    @\"yFG5veQq3tzyF21uewu0tz+D2lmdwe8uz1J17y7PUnXvL89Sde8tzPJp4y3O4veU53N7yA\"\n    @\"m5veQG3t7yA21tewO0tO6m78Jad1F14yw6eBb1lJ3UX3rILt7fswu0tu3B7yy7c3rIHt7f\"\n    @\"swe0te6m76S17ePj2lpepu+ktL1N301tewu0tL+H2ln24vWUfbm/Zh9tb9uH2lld42/GWV\"\n    @\"6m75S2vUnfLW16l7pa3vIbbW17D7S2v4faW13B7yxu4veUN3N7yJnWX3vImdZfe8jZ1l97\"\n    @\"yFq/F3vIWbm95C7e3vIPbW97B7S3v4PaWd3B7y3u8F2ce8x4vxpnXvOcS4Tnv8Wqcec8B7\"\n    @\"R50QLsXHdDuSQe0e9Mh7R51SLtXHcIeTEBDTkBedQR7MAKNYA9WoBHtXnVEu1cd0+5Vx7R\"\n    @\"71THtXnVMu1edcHvzqhPYgzVoAnswB01gD/agB9q96gPtXvWBdq/6QLtXndLuVae0e9Up7\"\n    @\"MEsNIU92IUeYQ+GoUcOtl71kXav+ki7V32i3as+0e5Vn2j3qk+0e9UZ7MFANIM9WIhmXMq\"\n    @\"96gz2YCOa0+5V57R71TntXnVOu1dd0O5VF7R71QXswVS04CcKr/oMezAWPcMerEXPtHvVZ\"\n    @\"9q96gvtXvWFdq/6QrtXfaHdqy75bcirLmEPVqMl7MFstIQ92I1eafeqr7R71Vfaveor7V7\"\n    @\"1jXav+ka7V32DPZiP3mAP9qMV7MGAtOIHRa+6ot2rrmj3qmvaveqadq+6pt2rrmn3qhvYg\"\n    @\"yFpA3uwJG34JderbmAPtqR32r3qO+1e9Z12r/pOu1f9oN2rftDuVT9gDyalD35C96pb2IN\"\n    @\"RaQt7sCptafeqW9q96iftXvWTdq/6SbtX/aTdq37x7oJX/cLH9GBb+sItgGBb+sI1gGBb+\"\n    @\"qbdq37T7lW/afeq37R71Yx2r5rR7lUz2INtKYM92JaqsAfbUpUXXrxqlXavWqXdq9Zo96o\"\n    @\"12r1qjXavWqPdq9ZhD7alOuzBtlTnTSOvWoc92JYatHvVBu1etUG7V23Q7lVz2r1qTrtXz\"\n    @\"WEPtqWcV7y8agF7sC0VsAfbUkG7Vy1o96pN2r1qk3av2qTdqzZp96ot3q3zqi3Yg22pBXu\"\n    @\"wLbVgD7alknavWtLuVUvavWpJu1fdod2r7tDuVXf+s//1L0rK7jh5LQAA\";\n    NSData *expectedBody = [[NSData alloc] initWithBase64EncodedString:expected options:0];\n    \n    // when\n    [sut setBodyDataAndMediaTypeOnHTTPRequest:request];\n    \n    // then\n    XCTAssertNotNil(request.HTTPBody);\n    AssertEqualData(request.HTTPBody, expectedBody);\n    XCTAssertEqualObjects([request valueForHTTPHeaderField:@\"Content-Type\"], @\"application/json\");\n    XCTAssertEqualObjects([request valueForHTTPHeaderField:@\"Content-Encoding\"], @\"gzip\");\n}\n\n- (void)testThatItSetsBodyDataAndMediaTypeForImageRequest;\n{\n    // given\n    NSData *data = [@\"jhasdhjkadshjklad\" dataUsingEncoding:NSUTF8StringEncoding];\n    ZMTransportRequest *sut = [[ZMTransportRequest alloc] initWithPath:@\"/foo\" method:ZMMethodPOST binaryData:data type:(__bridge NSString *) kUTTypeJPEG contentDisposition:nil];\n    NSMutableURLRequest *request = [[NSMutableURLRequest alloc] init];\n    \n    // when\n    [sut setBodyDataAndMediaTypeOnHTTPRequest:request];\n    \n    // then\n    XCTAssertEqualObjects(request.HTTPBody, data);\n    XCTAssertEqualObjects([request valueForHTTPHeaderField:@\"Content-Type\"], @\"image/jpeg\");\n}\n\n- (void)testThatItDoesNotSetMediaTypeForRequestWithoutPayload;\n{\n    // given\n    ZMTransportRequest *sut = [[ZMTransportRequest alloc] initWithPath:@\"/foo\" method:ZMMethodGET payload:nil];\n    NSMutableURLRequest *request = [[NSMutableURLRequest alloc] init];\n    \n    // when\n    [sut setBodyDataAndMediaTypeOnHTTPRequest:request];\n    \n    // then\n    XCTAssertNil(request.HTTPBody);\n    XCTAssertNil([request valueForHTTPHeaderField:@\"Content-Type\"]);\n}\n\n- (void)testThatItSetsTheContentTypeForFileUploadRequests;\n{\n    // given\n    NSString *contentType = @\"multipart/mixed; boundary=frontier\";\n    NSURL *fileURL = [NSURL URLWithString:@\"file://url/to/file\"];\n    ZMTransportRequest *sut = [ZMTransportRequest uploadRequestWithFileURL:fileURL\n                                                                      path:[[NSBundle mainBundle] bundlePath]\n                                                               contentType:contentType];\n    NSMutableURLRequest *request = [[NSMutableURLRequest alloc] init];\n    \n    // when\n    [sut setBodyDataAndMediaTypeOnHTTPRequest:request];\n    \n    // then\n    XCTAssertNil(request.HTTPBody);\n    XCTAssertEqualObjects([request valueForHTTPHeaderField:@\"Content-Type\"], contentType);\n}\n\n- (void)testThatItSetsTheContentDispositionForImageRequest;\n{\n    // given\n    NSData *data = [@\"jhasdhjkadshjklad\" dataUsingEncoding:NSUTF8StringEncoding];\n    NSDictionary *disposition = @{@\"A\": @YES, @\"b\": @1, @\"c\": @\"foo bar\", @\"d\": @\"z\", @\"e\": [NSNull null]};\n    ZMTransportRequest *sut = [[ZMTransportRequest alloc] initWithPath:@\"/foo\" method:ZMMethodPOST binaryData:data type:(__bridge NSString *) kUTTypeJPEG contentDisposition:disposition];\n    NSMutableURLRequest *request = [[NSMutableURLRequest alloc] init];\n    \n    // when\n    [sut setContentDispositionOnHTTPRequest:request];\n    \n    // then\n    XCTAssertEqualObjects([request valueForHTTPHeaderField:@\"Content-Disposition\"], @\"e;A=true;b=1;c=\\\"foo bar\\\";d=z\");\n}\n\n- (void)testThatItDoesNotSetTheContentDispositionHeaderWhenNoDispostionIsSpecified;\n{\n    // given\n    NSData *data = [@\"jhasdhjkadshjklad\" dataUsingEncoding:NSUTF8StringEncoding];\n    ZMTransportRequest *sut = [[ZMTransportRequest alloc] initWithPath:@\"/foo\" method:ZMMethodPOST binaryData:data type:(__bridge NSString *) kUTTypeJPEG contentDisposition:nil];\n    NSMutableURLRequest *request = [[NSMutableURLRequest alloc] init];\n    \n    // when\n    [sut setContentDispositionOnHTTPRequest:request];\n    \n    // then\n    XCTAssertNil([request valueForHTTPHeaderField:@\"Content-Disposition\"]);\n}\n\n- (void)testThatItSetsAnExpirationDate;\n{\n    // given\n    ZMTransportRequest *sut = [[ZMTransportRequest alloc] initWithPath:@\"/foo\" method:ZMMethodGET payload:nil];\n    NSTimeInterval interval = 35;\n    \n    // when\n    [sut expireAfterInterval:interval];\n    NSDate *expirationDate = sut.expirationDate;\n    \n    // then\n    NSDate *then = [NSDate dateWithTimeIntervalSinceNow:interval];\n    float timePrecision = 10.0f;\n    XCTAssertTrue(fabs(then.timeIntervalSinceReferenceDate - expirationDate.timeIntervalSinceReferenceDate) < timePrecision);\n    \n}\n\n@end\n\n\n\n@implementation ZMTransportRequestTests (Payload)\n\n- (void)testThatPOSTWithPayloadHasRequiredPayload\n{\n    // given\n    ZMTransportRequest *request = [ZMTransportRequest requestWithPath:@\"foo\" method:ZMMethodPOST payload:@{}];\n    \n    // then\n    XCTAssertTrue(request.hasRequiredPayload);\n}\n\n- (void)testThatPOSTWithNoPayloadHasRequiredPayload\n{\n    // given\n    ZMTransportRequest *request = [ZMTransportRequest requestWithPath:@\"foo\" method:ZMMethodPOST payload:nil];\n    \n    // then\n    XCTAssertTrue(request.hasRequiredPayload);\n}\n\n- (void)testThatDELETEWithPayloadHasRequiredPayload\n{\n    // given\n    ZMTransportRequest *request = [ZMTransportRequest requestWithPath:@\"Foo\" method:ZMMethodDELETE payload:@{}];\n    \n    // then\n    XCTAssertTrue(request.hasRequiredPayload);\n}\n\n- (void)testThatDELETEWithNoPayloadHasRequiredPayload\n{\n    // given\n    ZMTransportRequest *request = [ZMTransportRequest requestWithPath:@\"Foo\" method:ZMMethodDELETE payload:nil];\n    \n    // then\n    XCTAssertTrue(request.hasRequiredPayload);\n}\n\n- (void)testThatGETWithoutPayloadHasRequiredPayload\n{\n    // given\n    ZMTransportRequest *request = [ZMTransportRequest requestWithPath:@\"Foo\" method:ZMMethodGET payload:nil];\n    \n    // then\n    XCTAssertTrue(request.hasRequiredPayload);\n}\n\n- (void)testThatHEADHasRequiredPayload\n{\n    // given\n    ZMTransportRequest *request = [ZMTransportRequest requestWithPath:@\"foo\" method:ZMMethodHEAD payload:nil];\n    \n    // then\n    XCTAssertTrue(request.hasRequiredPayload);\n}\n\n@end\n\n\n@implementation ZMTransportRequestTests (TimeoutOverride)\n\n- (void)testThatItSetsTheTimeoutOverrideWhenTheApplicationisInTheBackgroundAndTheRequestDoesNotEnforceTheBackgroundSession;\n{\n    [self checkThatItDoesSetTheTimeoutInterval:YES applicationInBackground:YES usingBackgroundSession:NO];\n}\n\n- (void)testThatItDoesNotSetTheTimeoutOverrideWhenTheApplicationisInTheBackgroundAndTheRequestDoesEnforceTheBackgroundSession;\n{\n    [self checkThatItDoesSetTheTimeoutInterval:NO applicationInBackground:YES usingBackgroundSession:YES];\n}\n\n- (void)testThatItDoesNotSetTheTimeoutOverrideWhenTheApplicationisNotInTheBackgroundAndTheRequestDoesNotEnforceTheBackgroundSession;\n{\n    [self checkThatItDoesSetTheTimeoutInterval:NO applicationInBackground:NO usingBackgroundSession:NO];\n}\n\n- (void)testThatItDoesNotSetTheTimeoutOverrideWhenTheApplicationisNotInTheBackgroundAndTheRequestDoesEnforceTheBackgroundSession;\n{\n    [self checkThatItDoesSetTheTimeoutInterval:NO applicationInBackground:NO usingBackgroundSession:YES];\n}\n\n- (void)checkThatItDoesSetTheTimeoutInterval:(BOOL)shouldSetInterval\n                     applicationInBackground:(BOOL)backgrounded\n                      usingBackgroundSession:(BOOL)usingBackgroundSession\n{\n    // given\n    ZMTransportRequest *sut = [[ZMTransportRequest alloc] initWithPath:@\"/foo\" method:ZMMethodPOST payload:nil];\n    if (usingBackgroundSession) {\n        [sut forceToBackgroundSession];\n    }\n    \n    NSMutableURLRequest *request = [[NSMutableURLRequest alloc] init];\n    \n    // when\n    [sut setTimeoutIntervalOnRequestIfNeeded:request applicationIsBackgrounded:backgrounded usingBackgroundSession:usingBackgroundSession];\n    \n    // then\n    if (shouldSetInterval) {\n        XCTAssertEqual(request.timeoutInterval, 25);\n    } else {\n        XCTAssertEqual(request.timeoutInterval, 60);\n    }\n}\n\n@end\n\n\n@implementation ZMTransportRequestTests (Debugging)\n\n- (void)testThatItPrintsDebugInformation\n{\n    // given\n    NSString *info1 = @\"....xxxXXXxxx....\";\n    NSString *info2 = @\"32432525245345435\";\n    ZMTransportRequest *request = [ZMTransportRequest requestWithPath:@\"foo\" method:ZMMethodHEAD payload:nil];\n    \n    // when\n    [request addContentDebugInformation:info1];\n    [request addContentDebugInformation:info2];\n    \n    // then\n    NSString *description = request.description;\n    XCTAssertNotEqual([description rangeOfString:info1].location, NSNotFound);\n    XCTAssertNotEqual([description rangeOfString:info2].location, NSNotFound);\n\n}\n\n- (void)testPrivateDescription\n{\n    // given\n    ZMTransportRequest *request = [ZMTransportRequest requestWithPath:@\"foo\" method:ZMMethodHEAD payload:nil];\n    \n    // when\n    NSString *privateDescription = [request safeForLoggingDescription];\n    \n    // then\n    XCTAssertTrue([privateDescription rangeOfString:@\"HEAD\"].location != NSNotFound);\n    XCTAssertTrue([privateDescription rangeOfString:@\"foo\"].location != NSNotFound);\n}\n\n- (void)testPrivateDescriptionWithUUID\n{\n    // given\n    NSString *clientID = @\"608b4f25ba2b193\";\n    NSString *uuid = @\"9e86b08a-8de7-11e9-810f-22000a62954d\";\n    NSString *path = [NSString stringWithFormat:@\"do/something/%@/useful?client=%@\", uuid, clientID];\n    ZMTransportRequest *request = [ZMTransportRequest requestWithPath:path method:ZMMethodHEAD payload:nil];\n    \n    // when\n    NSString *privateDescription = [request safeForLoggingDescription];\n    \n    // then\n    XCTAssertTrue([privateDescription rangeOfString:@\"useful\"].location != NSNotFound);\n    XCTAssertTrue([privateDescription rangeOfString:@\"do/something\"].location != NSNotFound);\n    XCTAssertTrue([privateDescription rangeOfString:uuid].location == NSNotFound);\n    XCTAssertTrue([privateDescription rangeOfString:clientID].location == NSNotFound);\n}\n\n- (void)testPrivateDescriptionWithEmoji\n{\n    // given\n    NSString *clientID = @\"608b4f25ba2b193\";\n    NSString *uuid = @\"9e86b08a-8de7-11e9-810f-22000a62954d\";\n    NSString *path = [NSString stringWithFormat:@\"with/%@/\ud83e\udd28/%@/emoji\", clientID, uuid];\n    ZMTransportRequest *request = [ZMTransportRequest requestWithPath:path method:ZMMethodHEAD payload:nil];\n\n    // when\n    NSString *privateDescription = [request safeForLoggingDescription];\n\n    // then\n    XCTAssertTrue([privateDescription rangeOfString:@\"with/\"].location != NSNotFound);\n    XCTAssertTrue([privateDescription rangeOfString:@\"/emoji\"].location != NSNotFound);\n    XCTAssertTrue([privateDescription rangeOfString:@\"/\ud83e\udd28/\"].location != NSNotFound);\n    XCTAssertTrue([privateDescription rangeOfString:uuid].location == NSNotFound);\n    XCTAssertTrue([privateDescription rangeOfString:clientID].location == NSNotFound);\n}\n\n- (void)testPrivateDescriptionWithOverlappedIDs\n{\n    // given\n    NSString *clientID = @\"608b4f25ba2b193\";\n    NSString *uuid = @\"9e86b08a-8de7-11e9-810f-22000a62954d\";\n    NSString *path = [NSString stringWithFormat:@\"ids/%@%@/overlapped\", clientID, uuid];\n    ZMTransportRequest *request = [ZMTransportRequest requestWithPath:path method:ZMMethodHEAD payload:nil];\n\n    // when\n    NSString *privateDescription = [request safeForLoggingDescription];\n\n    // then\n    XCTAssertTrue([privateDescription rangeOfString:@\"ids/\"].location != NSNotFound);\n    XCTAssertTrue([privateDescription rangeOfString:@\"/overlapped\"].location != NSNotFound);\n    XCTAssertTrue([privateDescription rangeOfString:uuid].location == NSNotFound);\n    XCTAssertTrue([privateDescription rangeOfString:clientID].location == NSNotFound);\n\n    // given\n    path = [NSString stringWithFormat:@\"ids/%@%@/overlapped\", uuid, clientID];\n    request = [ZMTransportRequest requestWithPath:path method:ZMMethodHEAD payload:nil];\n\n    // when\n    privateDescription = [request safeForLoggingDescription];\n\n    // then\n    XCTAssertTrue([privateDescription rangeOfString:@\"ids/\"].location != NSNotFound);\n    XCTAssertTrue([privateDescription rangeOfString:@\"/overlapped\"].location != NSNotFound);\n    XCTAssertTrue([privateDescription rangeOfString:uuid].location == NSNotFound);\n    XCTAssertTrue([privateDescription rangeOfString:clientID].location == NSNotFound);\n\n    // given\n    path = [NSString stringWithFormat:@\"ids/%@%@/overlapped\", uuid, uuid];\n    request = [ZMTransportRequest requestWithPath:path method:ZMMethodHEAD payload:nil];\n\n    // when\n    privateDescription = [request safeForLoggingDescription];\n\n    // then\n    XCTAssertTrue([privateDescription rangeOfString:@\"ids/\"].location != NSNotFound);\n    XCTAssertTrue([privateDescription rangeOfString:@\"/overlapped\"].location != NSNotFound);\n    XCTAssertTrue([privateDescription rangeOfString:uuid].location == NSNotFound);\n\n    // given\n    path = [NSString stringWithFormat:@\"ids/%@%@/overlapped\", clientID, clientID];\n    request = [ZMTransportRequest requestWithPath:path method:ZMMethodHEAD payload:nil];\n\n    // when\n    privateDescription = [request safeForLoggingDescription];\n\n    // then\n    XCTAssertTrue([privateDescription rangeOfString:@\"ids/\"].location != NSNotFound);\n    XCTAssertTrue([privateDescription rangeOfString:@\"/overlapped\"].location != NSNotFound);\n    XCTAssertTrue([privateDescription rangeOfString:clientID].location == NSNotFound);\n}\n\n@end\n"], "filenames": ["Source/Public/ZMTransportRequest.swift", "Tests/Source/Requests/ZMTransportRequestTests.m"], "buggy_code_start_loc": [38, 1032], "buggy_code_end_loc": [49, 1032], "fixing_code_start_loc": [38, 1033], "fixing_code_end_loc": [63, 1107], "type": "CWE-755", "message": "Wire-ios is a messaging application using the wire protocol on apple's ios platform. In versions prior to 3.95 malformed resource identifiers may render the iOS Wire Client completely unusable by causing it to repeatedly crash on launch. These malformed resource identifiers can be generated and sent between Wire users. The root cause lies in [wireapp/wire-ios-transport](https://github.com/wireapp/wire-ios-transport), where code responsible for removing sensible tokens before logging may fail and lead to a crash (Swift exception) of the application. This causes undesirable behavior, however the (greater) Wire system is still functional. Users are advised to upgrade as soon as possible. There are no known workarounds for this issue.", "other": {"cve": {"id": "CVE-2022-23625", "sourceIdentifier": "security-advisories@github.com", "published": "2022-03-11T18:15:31.493", "lastModified": "2022-03-18T20:16:25.673", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Wire-ios is a messaging application using the wire protocol on apple's ios platform. In versions prior to 3.95 malformed resource identifiers may render the iOS Wire Client completely unusable by causing it to repeatedly crash on launch. These malformed resource identifiers can be generated and sent between Wire users. The root cause lies in [wireapp/wire-ios-transport](https://github.com/wireapp/wire-ios-transport), where code responsible for removing sensible tokens before logging may fail and lead to a crash (Swift exception) of the application. This causes undesirable behavior, however the (greater) Wire system is still functional. Users are advised to upgrade as soon as possible. There are no known workarounds for this issue."}, {"lang": "es", "value": "Wire-ios es una aplicaci\u00f3n de mensajer\u00eda que usando el protocolo wire en la plataforma ios de apple. En versiones anteriores a 3.95, los identificadores de recursos malformados pueden hacer que el cliente Wire de iOS sea completamente inusable al causar que sea bloqueado repetidamente al iniciarse. Estos identificadores de recursos malformados pueden ser generados y enviados entre usuarios de Wire. La causa root es encontrada en [wireapp/wire-ios-transport](https://github.com/wireapp/wire-ios-transport), donde el c\u00f3digo responsable de eliminar los tokens confidenciales antes del registro puede fallar y conllevar a un fallo (excepci\u00f3n Swift) de la aplicaci\u00f3n. Esto causa un comportamiento no deseable, sin embargo el sistema Wire (mayor) sigue siendo funcional. Es recomendado a usuarios actualizar lo antes posible. No se presentan medidas de mitigaci\u00f3n conocidas para este problema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-755"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-755"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire:*:*:*:*:*:iphone_os:*:*", "versionEndExcluding": "3.95", "matchCriteriaId": "8676CA54-328C-4C00-8EF8-DD54BF8712E2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-ios-transport:*:*:*:*:*:iphone_os:*:*", "versionEndExcluding": "84.1.1", "matchCriteriaId": "4D57B655-B6AF-481B-8B58-425F1561722D"}]}]}], "references": [{"url": "https://github.com/wireapp/wire-ios-transport/commit/02e90aa45edaf7eb2d8b97fa2377cd8104274170", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/wireapp/wire-ios-transport/security/advisories/GHSA-3xvh-x964-572h", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/wireapp/wire-ios/security/advisories/GHSA-rq36-8qfp-79mc", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/wireapp/wire-ios-transport/commit/02e90aa45edaf7eb2d8b97fa2377cd8104274170"}}