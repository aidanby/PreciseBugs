{"buggy_code": ["/* vim: set tabstop=8 shiftwidth=4 softtabstop=4 expandtab smarttab colorcolumn=80: */\n/*\n * Copyright (c) 2020 Red Hat, Inc.\n * Author: Sergio Correia <scorreia@redhat.com>\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <string.h>\n#include <dirent.h>\n#include <stdio.h>\n\n#include <jose/b64.h>\n#include <jose/jwk.h>\n#include <jose/jws.h>\n\n#include \"keys.h\"\n\n#ifndef PATH_MAX\n#define PATH_MAX 4096\n#endif\n\n/* Default hash to use with JWK thumbprints (S256 = SHA-256). */\n#define DEFAULT_THP_HASH \"S256\"\n\nstatic const char**\nsupported_hashes(void)\n{\n    /* TODO: check if jose has a way to export the hash algorithms it\n     * supports. */\n    static const char* hashes[] = {\"S1\", \"S224\", \"S256\", \"S384\", \"S512\", NULL};\n    return hashes;\n}\n\nstatic int\nis_hash(const char* alg)\n{\n    if (!alg) {\n        return 0;\n    }\n\n    const char** algs = supported_hashes();\n    for (size_t a = 0; algs[a]; a++) {\n        if (strcmp(alg, algs[a]) == 0) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\nstatic json_t*\njwk_generate(const char* alg)\n{\n    json_auto_t* jalg = json_pack(\"{s:s}\", \"alg\", alg);\n    if (!jalg) {\n        fprintf(stderr, \"Error packing JSON with alg %s\\n\", alg);\n        return NULL;\n    }\n\n    if (!jose_jwk_gen(NULL, jalg)) {\n        fprintf(stderr, \"Error generating JWK with alg %s\\n\", alg);\n        return NULL;\n    }\n\n    return json_incref(jalg);\n}\n\nstatic char*\njwk_thumbprint(const json_t* jwk, const char* alg)\n{\n    size_t elen = 0;\n    size_t dlen = 0;\n\n    if (!jwk) {\n        fprintf(stderr, \"Invalid JWK\\n\");\n        return NULL;\n    }\n\n    if (!alg || !is_hash(alg)) {\n        fprintf(stderr, \"Invalid hash algorithm (%s)\\n\", alg);\n        return NULL;\n    }\n\n    dlen = jose_jwk_thp_buf(NULL, NULL, alg, NULL, 0);\n    if (dlen == SIZE_MAX) {\n        fprintf(stderr, \"Error determining hash size for %s\\n\", alg);\n        return NULL;\n    }\n\n    elen = jose_b64_enc_buf(NULL, dlen, NULL, 0);\n    if (elen == SIZE_MAX) {\n        fprintf(stderr, \"Error determining encoded size for %s\\n\", alg);\n        return NULL;\n    }\n\n    uint8_t dec[dlen];\n    char enc[elen];\n\n    if (!jose_jwk_thp_buf(NULL, jwk, alg, dec, sizeof(dec))) {\n        fprintf(stderr, \"Error making thumbprint\\n\");\n        return NULL;\n    }\n\n    if (jose_b64_enc_buf(dec, dlen, enc, sizeof(enc)) != elen) {\n        fprintf(stderr, \"Error encoding data Base64\\n\");\n        return NULL;\n    }\n\n    return strndup(enc, elen);\n}\n\nvoid\nfree_tang_keys_info(struct tang_keys_info* tki)\n{\n    if (!tki) {\n        return;\n    }\n\n    json_t* to_free[] = {tki->m_keys, tki->m_rotated_keys,\n                         tki->m_payload, tki->m_sign\n    };\n    size_t len = sizeof(to_free) / sizeof(to_free[0]);\n\n    for (size_t i = 0; i < len; i++) {\n        if (to_free[i] == NULL) {\n            continue;\n        }\n        json_decref(to_free[i]);\n    }\n    free(tki);\n}\n\nvoid\ncleanup_tang_keys_info(struct tang_keys_info** tki)\n{\n    if (!tki || !*tki) {\n        return;\n    }\n    free_tang_keys_info(*tki);\n    *tki = NULL;\n}\n\nstatic struct tang_keys_info*\nnew_tang_keys_info(void)\n{\n    struct tang_keys_info* tki = calloc(1, sizeof(*tki));\n    if (!tki) {\n        return NULL;\n    }\n\n    tki->m_keys = json_array();\n    tki->m_rotated_keys = json_array();\n    tki->m_payload = json_array();\n    tki->m_sign = json_array();\n\n    if (!tki->m_keys || !tki->m_rotated_keys ||\n        !tki->m_payload || !tki->m_sign) {\n        free_tang_keys_info(tki);\n        return NULL;\n    }\n    tki->m_keys_count = 0;\n    return tki;\n}\n\nstatic int\njwk_valid_for(const json_t* jwk, const char* use)\n{\n    if (!jwk || !use) {\n        return 0;\n    }\n    return jose_jwk_prm(NULL, jwk, false, use);\n}\n\nstatic int\njwk_valid_for_signing_and_verifying(const json_t* jwk)\n{\n    const char* uses[] = {\"sign\", \"verify\", NULL};\n    int ret = 1;\n    for (int i = 0; uses[i]; i++) {\n        if (!jwk_valid_for(jwk, uses[i])) {\n            ret = 0;\n            break;\n        }\n    }\n    return ret;\n}\n\nstatic int\njwk_valid_for_signing(const json_t* jwk)\n{\n    return jwk_valid_for(jwk, \"sign\");\n}\n\nstatic int\njwk_valid_for_deriving_keys(const json_t* jwk)\n{\n    return jwk_valid_for(jwk, \"deriveKey\");\n}\n\nstatic void\ncleanup_str(char** str)\n{\n    if (!str || !*str) {\n        return;\n    }\n    free(*str);\n    *str = NULL;\n}\n\nstatic json_t*\njwk_sign(const json_t* to_sign, const json_t* sig_keys)\n{\n    if (!sig_keys || !json_is_array(sig_keys) || !json_is_array(to_sign)) {\n        return NULL;\n    }\n\n    json_auto_t* to_sign_copy = json_deep_copy(to_sign);\n    if (!jose_jwk_pub(NULL, to_sign_copy)) {\n        fprintf(stderr, \"Error removing private material from data to sign\\n\");\n        return NULL;\n    }\n\n    json_auto_t* payload = json_pack(\"{s:O}\", \"keys\", to_sign_copy);\n    json_auto_t* sig_template = json_pack(\"{s:{s:s}}\",\n                                          \"protected\", \"cty\", \"jwk-set+json\");\n\n    __attribute__ ((__cleanup__(cleanup_str))) char* data_to_sign = json_dumps(payload, 0);\n    json_auto_t* jws = json_pack(\"{s:o}\", \"payload\",\n                                 jose_b64_enc(data_to_sign, strlen(data_to_sign)));\n\n    if (!jose_jws_sig(NULL, jws, sig_template, sig_keys)) {\n        fprintf(stderr, \"Error trying to jose_jws_sign\\n\");\n        return NULL;\n    }\n    return json_incref(jws);\n}\n\nstatic json_t*\nfind_by_thp(struct tang_keys_info* tki, const char* target)\n{\n    if (!tki) {\n        return NULL;\n    }\n\n    json_auto_t* keys = json_deep_copy(tki->m_keys);\n    json_array_extend(keys, tki->m_rotated_keys);\n\n    size_t idx;\n    json_t* jwk;\n    const char** hashes = supported_hashes();\n    json_array_foreach(keys, idx, jwk) {\n        for (int i = 0; hashes[i]; i++) {\n            __attribute__ ((__cleanup__(cleanup_str))) char* thumbprint = jwk_thumbprint(jwk, hashes[i]);\n            if (!thumbprint || strcmp(thumbprint, target) != 0) {\n                continue;\n            }\n            return json_incref(jwk);\n        }\n    }\n    return NULL;\n}\n\nstatic int\nprepare_payload_and_sign(struct tang_keys_info* tki)\n{\n    if (!tki) {\n        return 0;\n    }\n\n    size_t idx;\n    json_t* jwk;\n    json_array_foreach(tki->m_keys, idx, jwk) {\n        if (jwk_valid_for_signing_and_verifying(jwk)) {\n            if (json_array_append(tki->m_sign, jwk) == -1) {\n                continue;\n            }\n            if (json_array_append(tki->m_payload, jwk) == -1) {\n                continue;\n            }\n        } else if (jwk_valid_for_deriving_keys(jwk)) {\n            if (json_array_append(tki->m_payload, jwk) == -1) {\n                continue;\n            }\n        }\n    }\n    if (json_array_size(tki->m_sign) == 0 || json_array_size(tki->m_payload) == 0) {\n        return 0;\n    }\n    return 1;\n}\n\nstatic int\ncreate_new_keys(const char* jwkdir)\n{\n    const char* alg[] = {\"ES512\", \"ECMR\", NULL};\n    char path[PATH_MAX];\n    for (int i = 0; alg[i] != NULL; i++) {\n        json_auto_t* jwk = jwk_generate(alg[i]);\n        if (!jwk) {\n            return 0;\n        }\n        __attribute__ ((__cleanup__(cleanup_str))) char* thp = jwk_thumbprint(jwk, DEFAULT_THP_HASH);\n        if (!thp) {\n            return 0;\n        }\n        if (snprintf(path, PATH_MAX, \"%s/%s.jwk\", jwkdir, thp) < 0) {\n            fprintf(stderr, \"Unable to prepare variable with file full path (%s)\\n\", thp);\n            return 0;\n        }\n        path[sizeof(path) - 1] = '\\0';\n        if (json_dump_file(jwk, path, 0) == -1) {\n            fprintf(stderr, \"Error saving JWK to file (%s)\\n\", path);\n            return 0;\n        }\n\n        /* Set 0440 permission for the new key. */\n        if (chmod(path, S_IRUSR | S_IRGRP) == -1) {\n            fprintf(stderr, \"Unable to set permissions for JWK file (%s)\\n\", path);\n            return 0;\n        }\n    }\n    return 1;\n}\n\nstatic struct tang_keys_info*\nload_keys(const char* jwkdir)\n{\n    struct tang_keys_info* tki = new_tang_keys_info();\n    if (!tki) {\n        return NULL;\n    }\n\n    struct dirent* d;\n    DIR* dir = opendir(jwkdir);\n    if (!dir) {\n        free_tang_keys_info(tki);\n        return NULL;\n    }\n\n    char filepath[PATH_MAX];\n    const char* pattern = \".jwk\";\n    while ((d = readdir(dir)) != NULL) {\n        if (strcmp(d->d_name, \".\") == 0 || strcmp(d->d_name, \"..\") == 0) {\n            continue;\n        }\n\n        char* dot = strrchr(d->d_name, '.');\n        if (!dot) {\n            continue;\n        }\n\n        if (strcmp(dot, pattern) == 0) {\n            /* Found a file with .jwk extension. */\n            if (snprintf(filepath, PATH_MAX, \"%s/%s\", jwkdir, d->d_name) < 0) {\n                fprintf(stderr, \"Unable to prepare variable with file full path (%s); skipping\\n\", d->d_name);\n                continue;\n            }\n            filepath[sizeof(filepath) - 1] = '\\0';\n            json_error_t error;\n            json_auto_t* json = json_load_file(filepath, 0, &error);\n            if (!json) {\n                fprintf(stderr, \"Cannot load JSON file (%s); skipping\\n\", filepath);\n                fprintf(stderr, \"error text %s, line %d, col %d, pos %d\\n\",\n                    error.text, error.line, error.column, error.position);\n                continue;\n            }\n\n            json_t* arr = tki->m_keys;\n            if (d->d_name[0] == '.') {\n                arr = tki->m_rotated_keys;\n                tki->m_rotated_keys_count++;\n            } else {\n                tki->m_keys_count++;\n            }\n\n            if (json_array_append(arr, json) == -1) {\n                fprintf(stderr, \"Unable to append JSON (%s) to array; skipping\\n\", d->d_name);\n                continue;\n            }\n        }\n    }\n    closedir(dir);\n    return tki;\n}\n\nstruct tang_keys_info*\nread_keys(const char* jwkdir)\n{\n    struct tang_keys_info* tki = load_keys(jwkdir);\n    if (!tki) {\n        return NULL;\n    }\n\n    if (tki->m_keys_count == 0) {\n        /* Let's attempt to create a new pair of keys. */\n        free_tang_keys_info(tki);\n        if (!create_new_keys(jwkdir)) {\n            return NULL;\n        }\n        tki = load_keys(jwkdir);\n    }\n\n    if (!prepare_payload_and_sign(tki)) {\n        free_tang_keys_info(tki);\n        return NULL;\n    }\n    return tki;\n}\n\njson_t*\nfind_jws(struct tang_keys_info* tki, const char* thp)\n{\n    if (!tki) {\n        return NULL;\n    }\n\n    if (thp == NULL) {\n        /* Default advertisement. */\n        json_auto_t* jws = jwk_sign(tki->m_payload, tki->m_sign);\n        if (!jws) {\n            return NULL;\n        }\n        return json_incref(jws);\n    }\n\n    json_auto_t* jwk = find_by_thp(tki, thp);\n    if (!jwk_valid_for_signing(jwk)) {\n        return NULL;\n    }\n\n    json_auto_t* sign = json_deep_copy(tki->m_sign);\n    if (json_array_append(sign, jwk) == -1) {\n        return NULL;\n    }\n    json_auto_t* jws = jwk_sign(tki->m_payload, sign);\n    if (!jws) {\n        return NULL;\n    }\n    return json_incref(jws);\n}\n\njson_t*\nfind_jwk(struct tang_keys_info* tki, const char* thp)\n{\n    if (!tki || !thp) {\n        return NULL;\n    }\n    return find_by_thp(tki, thp);\n}\n", "#!/bin/sh\n# vim: set tabstop=8 shiftwidth=4 softtabstop=4 expandtab smarttab colorcolumn=80:\n#\n# Copyright (c) 2016 Red Hat, Inc.\n# Author: Nathaniel McCallum <npmccallum@redhat.com>\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n#\n\nset -e\n\nusage() {\n    echo \"Usage: $0 <jwkdir> [<sig> <exc>]\" >&2\n    exit 1\n}\n\nset_perms() {\n    chmod -- 0440 \"${1}\"\n    if ! chown -- @user@:@group@ \"${1}\" 2>/dev/null; then\n        echo \"Unable to change owner/group for ${1} to @user@:@group@\" >&2\n    fi\n}\n\n[ $# -ne 1 ] && [ $# -ne 3 ] && usage\n[ -d \"$1\" ] || usage\n\n[ $# -eq 3 ] && sig=$2 && exc=$3\n\nTHP_DEFAULT_HASH=S256     # SHA-256.\njwe=$(jose jwk gen -i '{\"alg\":\"ES512\"}')\n[ -z \"$sig\" ] && sig=$(echo \"$jwe\" | jose jwk thp -i- -a \"${THP_DEFAULT_HASH}\")\necho \"$jwe\" > \"$1/$sig.jwk\"\nset_perms \"$1/$sig.jwk\"\n\n\njwe=$(jose jwk gen -i '{\"alg\":\"ECMR\"}')\n[ -z \"$exc\" ] && exc=$(echo \"$jwe\" | jose jwk thp -i- -a \"${THP_DEFAULT_HASH}\")\necho \"$jwe\" > \"$1/$exc.jwk\"\nset_perms \"$1/$exc.jwk\"\n", "#!/bin/sh -e\n# vim: set ts=8 shiftwidth=4 softtabstop=4 expandtab smarttab colorcolumn=80:\n#\n# Copyright (c) 2020 Red Hat, Inc.\n# Author: Sergio Correia <scorreia@redhat.com>\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n#\n\nSUMMARY=\"Perform rotation of tang keys\"\n\nusage() {\n    _ret=\"${1:-1}\"\n    exec >&2\n    echo \"Usage: ${0} [-h] [-v] -d <KEYDIR>\"\n    echo\n    echo \"${SUMMARY}\"\n    echo\n    echo \"  -d KEYDIR  The directory with the keys, e.g. /var/db/tang\"\n    echo\n    echo \"  -h         Display this usage information\"\n    echo\n    echo \"  -v         Verbose. Display additional info on keys created/rotated\"\n    echo\n    exit \"${_ret}\"\n}\n\nlog() {\n    _msg=\"${1}\"\n    _verbose=\"${2:-}\"\n    [ -z \"${_verbose}\" ] && return 0\n    echo \"${_msg}\" >&2\n}\n\nerror() {\n    log \"${1}\" 1\n    usage 1\n}\n\nset_perms() {\n    chmod -- 0440 \"${1}\"\n    if ! chown -- @user@:@group@ \"${1}\" 2>/dev/null; then\n        echo \"Unable to change owner/group for ${1} to @user@:@group@\" >&2\n    fi\n}\n\nJWKDIR=\nVERBOSE=\nwhile getopts \"hvd:\" o; do\n    case \"${o}\" in\n        d) JWKDIR=\"${OPTARG}\";;\n        h) usage 0;;\n        v) VERBOSE=1;;\n        *) usage 1;;\n    esac\ndone\n\n[ -z \"${JWKDIR}\" ] && error \"Please specify the keys directory with -d switch\"\n[ -r \"${JWKDIR}\" ] || error \"Error trying to access JWK directory '${JWKDIR}'\"\n\ncd \"${JWKDIR}\" || error \"Unable to change to keys directory '${JWKDIR}'\"\n    # Disable advertisement of current keys.\n    for key in *.jwk; do\n        [ -r \"${key}\" ] || continue\n        mv -f -- \"${key}\" .\"${key}\"\n        log \"Disabled advertisement of key ${key} -> .${key}\" \"${VERBOSE}\"\n    done\n\n    # Create a new set of keys.\n    DEFAULT_THP_HASH=\"S256\"\n    for alg in \"ES512\" \"ECMR\"; do\n        json=\"$(printf '{\"alg\": \"%s\"}' \"${alg}\")\"\n        jwe=\"$(jose jwk gen --input \"${json}\")\"\n        thp=\"$(printf '%s' \"${jwe}\" | jose jwk thp --input=- \\\n                                           -a \"${DEFAULT_THP_HASH}\")\"\n        echo \"${jwe}\" > \"${thp}.jwk\"\n        set_perms \"${thp}.jwk\"\n        log \"Created new key ${thp}.jwk\" \"${VERBOSE}\"\n    done\ncd - >/dev/null\n\nlog \"Keys rotated successfully\" \"${VERBOSE}\"\n"], "fixing_code": ["/* vim: set tabstop=8 shiftwidth=4 softtabstop=4 expandtab smarttab colorcolumn=80: */\n/*\n * Copyright (c) 2020 Red Hat, Inc.\n * Author: Sergio Correia <scorreia@redhat.com>\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <string.h>\n#include <dirent.h>\n#include <stdio.h>\n\n#include <jose/b64.h>\n#include <jose/jwk.h>\n#include <jose/jws.h>\n\n#include \"keys.h\"\n\n#ifndef PATH_MAX\n#define PATH_MAX 4096\n#endif\n\n/* Default hash to use with JWK thumbprints (S256 = SHA-256). */\n#define DEFAULT_THP_HASH \"S256\"\n\nstatic const char**\nsupported_hashes(void)\n{\n    /* TODO: check if jose has a way to export the hash algorithms it\n     * supports. */\n    static const char* hashes[] = {\"S1\", \"S224\", \"S256\", \"S384\", \"S512\", NULL};\n    return hashes;\n}\n\nstatic int\nis_hash(const char* alg)\n{\n    if (!alg) {\n        return 0;\n    }\n\n    const char** algs = supported_hashes();\n    for (size_t a = 0; algs[a]; a++) {\n        if (strcmp(alg, algs[a]) == 0) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\nstatic json_t*\njwk_generate(const char* alg)\n{\n    json_auto_t* jalg = json_pack(\"{s:s}\", \"alg\", alg);\n    if (!jalg) {\n        fprintf(stderr, \"Error packing JSON with alg %s\\n\", alg);\n        return NULL;\n    }\n\n    if (!jose_jwk_gen(NULL, jalg)) {\n        fprintf(stderr, \"Error generating JWK with alg %s\\n\", alg);\n        return NULL;\n    }\n\n    return json_incref(jalg);\n}\n\nstatic char*\njwk_thumbprint(const json_t* jwk, const char* alg)\n{\n    size_t elen = 0;\n    size_t dlen = 0;\n\n    if (!jwk) {\n        fprintf(stderr, \"Invalid JWK\\n\");\n        return NULL;\n    }\n\n    if (!alg || !is_hash(alg)) {\n        fprintf(stderr, \"Invalid hash algorithm (%s)\\n\", alg);\n        return NULL;\n    }\n\n    dlen = jose_jwk_thp_buf(NULL, NULL, alg, NULL, 0);\n    if (dlen == SIZE_MAX) {\n        fprintf(stderr, \"Error determining hash size for %s\\n\", alg);\n        return NULL;\n    }\n\n    elen = jose_b64_enc_buf(NULL, dlen, NULL, 0);\n    if (elen == SIZE_MAX) {\n        fprintf(stderr, \"Error determining encoded size for %s\\n\", alg);\n        return NULL;\n    }\n\n    uint8_t dec[dlen];\n    char enc[elen];\n\n    if (!jose_jwk_thp_buf(NULL, jwk, alg, dec, sizeof(dec))) {\n        fprintf(stderr, \"Error making thumbprint\\n\");\n        return NULL;\n    }\n\n    if (jose_b64_enc_buf(dec, dlen, enc, sizeof(enc)) != elen) {\n        fprintf(stderr, \"Error encoding data Base64\\n\");\n        return NULL;\n    }\n\n    return strndup(enc, elen);\n}\n\nvoid\nfree_tang_keys_info(struct tang_keys_info* tki)\n{\n    if (!tki) {\n        return;\n    }\n\n    json_t* to_free[] = {tki->m_keys, tki->m_rotated_keys,\n                         tki->m_payload, tki->m_sign\n    };\n    size_t len = sizeof(to_free) / sizeof(to_free[0]);\n\n    for (size_t i = 0; i < len; i++) {\n        if (to_free[i] == NULL) {\n            continue;\n        }\n        json_decref(to_free[i]);\n    }\n    free(tki);\n}\n\nvoid\ncleanup_tang_keys_info(struct tang_keys_info** tki)\n{\n    if (!tki || !*tki) {\n        return;\n    }\n    free_tang_keys_info(*tki);\n    *tki = NULL;\n}\n\nstatic struct tang_keys_info*\nnew_tang_keys_info(void)\n{\n    struct tang_keys_info* tki = calloc(1, sizeof(*tki));\n    if (!tki) {\n        return NULL;\n    }\n\n    tki->m_keys = json_array();\n    tki->m_rotated_keys = json_array();\n    tki->m_payload = json_array();\n    tki->m_sign = json_array();\n\n    if (!tki->m_keys || !tki->m_rotated_keys ||\n        !tki->m_payload || !tki->m_sign) {\n        free_tang_keys_info(tki);\n        return NULL;\n    }\n    tki->m_keys_count = 0;\n    return tki;\n}\n\nstatic int\njwk_valid_for(const json_t* jwk, const char* use)\n{\n    if (!jwk || !use) {\n        return 0;\n    }\n    return jose_jwk_prm(NULL, jwk, false, use);\n}\n\nstatic int\njwk_valid_for_signing_and_verifying(const json_t* jwk)\n{\n    const char* uses[] = {\"sign\", \"verify\", NULL};\n    int ret = 1;\n    for (int i = 0; uses[i]; i++) {\n        if (!jwk_valid_for(jwk, uses[i])) {\n            ret = 0;\n            break;\n        }\n    }\n    return ret;\n}\n\nstatic int\njwk_valid_for_signing(const json_t* jwk)\n{\n    return jwk_valid_for(jwk, \"sign\");\n}\n\nstatic int\njwk_valid_for_deriving_keys(const json_t* jwk)\n{\n    return jwk_valid_for(jwk, \"deriveKey\");\n}\n\nstatic void\ncleanup_str(char** str)\n{\n    if (!str || !*str) {\n        return;\n    }\n    free(*str);\n    *str = NULL;\n}\n\nstatic json_t*\njwk_sign(const json_t* to_sign, const json_t* sig_keys)\n{\n    if (!sig_keys || !json_is_array(sig_keys) || !json_is_array(to_sign)) {\n        return NULL;\n    }\n\n    json_auto_t* to_sign_copy = json_deep_copy(to_sign);\n    if (!jose_jwk_pub(NULL, to_sign_copy)) {\n        fprintf(stderr, \"Error removing private material from data to sign\\n\");\n        return NULL;\n    }\n\n    json_auto_t* payload = json_pack(\"{s:O}\", \"keys\", to_sign_copy);\n    json_auto_t* sig_template = json_pack(\"{s:{s:s}}\",\n                                          \"protected\", \"cty\", \"jwk-set+json\");\n\n    __attribute__ ((__cleanup__(cleanup_str))) char* data_to_sign = json_dumps(payload, 0);\n    json_auto_t* jws = json_pack(\"{s:o}\", \"payload\",\n                                 jose_b64_enc(data_to_sign, strlen(data_to_sign)));\n\n    if (!jose_jws_sig(NULL, jws, sig_template, sig_keys)) {\n        fprintf(stderr, \"Error trying to jose_jws_sign\\n\");\n        return NULL;\n    }\n    return json_incref(jws);\n}\n\nstatic json_t*\nfind_by_thp(struct tang_keys_info* tki, const char* target)\n{\n    if (!tki) {\n        return NULL;\n    }\n\n    json_auto_t* keys = json_deep_copy(tki->m_keys);\n    json_array_extend(keys, tki->m_rotated_keys);\n\n    size_t idx;\n    json_t* jwk;\n    const char** hashes = supported_hashes();\n    json_array_foreach(keys, idx, jwk) {\n        for (int i = 0; hashes[i]; i++) {\n            __attribute__ ((__cleanup__(cleanup_str))) char* thumbprint = jwk_thumbprint(jwk, hashes[i]);\n            if (!thumbprint || strcmp(thumbprint, target) != 0) {\n                continue;\n            }\n            return json_incref(jwk);\n        }\n    }\n    return NULL;\n}\n\nstatic int\nprepare_payload_and_sign(struct tang_keys_info* tki)\n{\n    if (!tki) {\n        return 0;\n    }\n\n    size_t idx;\n    json_t* jwk;\n    json_array_foreach(tki->m_keys, idx, jwk) {\n        if (jwk_valid_for_signing_and_verifying(jwk)) {\n            if (json_array_append(tki->m_sign, jwk) == -1) {\n                continue;\n            }\n            if (json_array_append(tki->m_payload, jwk) == -1) {\n                continue;\n            }\n        } else if (jwk_valid_for_deriving_keys(jwk)) {\n            if (json_array_append(tki->m_payload, jwk) == -1) {\n                continue;\n            }\n        }\n    }\n    if (json_array_size(tki->m_sign) == 0 || json_array_size(tki->m_payload) == 0) {\n        return 0;\n    }\n    return 1;\n}\n\nstatic int\ncreate_new_keys(const char* jwkdir)\n{\n    const char* alg[] = {\"ES512\", \"ECMR\", NULL};\n    char path[PATH_MAX];\n\n    /* Set default umask for file creation. */\n    umask(0337);\n    for (int i = 0; alg[i] != NULL; i++) {\n        json_auto_t* jwk = jwk_generate(alg[i]);\n        if (!jwk) {\n            return 0;\n        }\n        __attribute__ ((__cleanup__(cleanup_str))) char* thp = jwk_thumbprint(jwk, DEFAULT_THP_HASH);\n        if (!thp) {\n            return 0;\n        }\n        if (snprintf(path, PATH_MAX, \"%s/%s.jwk\", jwkdir, thp) < 0) {\n            fprintf(stderr, \"Unable to prepare variable with file full path (%s)\\n\", thp);\n            return 0;\n        }\n        path[sizeof(path) - 1] = '\\0';\n        if (json_dump_file(jwk, path, 0) == -1) {\n            fprintf(stderr, \"Error saving JWK to file (%s)\\n\", path);\n            return 0;\n        }\n\n        /* Set 0440 permission for the new key. */\n        if (chmod(path, S_IRUSR | S_IRGRP) == -1) {\n            fprintf(stderr, \"Unable to set permissions for JWK file (%s)\\n\", path);\n            return 0;\n        }\n    }\n    return 1;\n}\n\nstatic struct tang_keys_info*\nload_keys(const char* jwkdir)\n{\n    struct tang_keys_info* tki = new_tang_keys_info();\n    if (!tki) {\n        return NULL;\n    }\n\n    struct dirent* d;\n    DIR* dir = opendir(jwkdir);\n    if (!dir) {\n        free_tang_keys_info(tki);\n        return NULL;\n    }\n\n    char filepath[PATH_MAX];\n    const char* pattern = \".jwk\";\n    while ((d = readdir(dir)) != NULL) {\n        if (strcmp(d->d_name, \".\") == 0 || strcmp(d->d_name, \"..\") == 0) {\n            continue;\n        }\n\n        char* dot = strrchr(d->d_name, '.');\n        if (!dot) {\n            continue;\n        }\n\n        if (strcmp(dot, pattern) == 0) {\n            /* Found a file with .jwk extension. */\n            if (snprintf(filepath, PATH_MAX, \"%s/%s\", jwkdir, d->d_name) < 0) {\n                fprintf(stderr, \"Unable to prepare variable with file full path (%s); skipping\\n\", d->d_name);\n                continue;\n            }\n            filepath[sizeof(filepath) - 1] = '\\0';\n            json_error_t error;\n            json_auto_t* json = json_load_file(filepath, 0, &error);\n            if (!json) {\n                fprintf(stderr, \"Cannot load JSON file (%s); skipping\\n\", filepath);\n                fprintf(stderr, \"error text %s, line %d, col %d, pos %d\\n\",\n                    error.text, error.line, error.column, error.position);\n                continue;\n            }\n\n            json_t* arr = tki->m_keys;\n            if (d->d_name[0] == '.') {\n                arr = tki->m_rotated_keys;\n                tki->m_rotated_keys_count++;\n            } else {\n                tki->m_keys_count++;\n            }\n\n            if (json_array_append(arr, json) == -1) {\n                fprintf(stderr, \"Unable to append JSON (%s) to array; skipping\\n\", d->d_name);\n                continue;\n            }\n        }\n    }\n    closedir(dir);\n    return tki;\n}\n\nstruct tang_keys_info*\nread_keys(const char* jwkdir)\n{\n    struct tang_keys_info* tki = load_keys(jwkdir);\n    if (!tki) {\n        return NULL;\n    }\n\n    if (tki->m_keys_count == 0) {\n        /* Let's attempt to create a new pair of keys. */\n        free_tang_keys_info(tki);\n        if (!create_new_keys(jwkdir)) {\n            return NULL;\n        }\n        tki = load_keys(jwkdir);\n    }\n\n    if (!prepare_payload_and_sign(tki)) {\n        free_tang_keys_info(tki);\n        return NULL;\n    }\n    return tki;\n}\n\njson_t*\nfind_jws(struct tang_keys_info* tki, const char* thp)\n{\n    if (!tki) {\n        return NULL;\n    }\n\n    if (thp == NULL) {\n        /* Default advertisement. */\n        json_auto_t* jws = jwk_sign(tki->m_payload, tki->m_sign);\n        if (!jws) {\n            return NULL;\n        }\n        return json_incref(jws);\n    }\n\n    json_auto_t* jwk = find_by_thp(tki, thp);\n    if (!jwk_valid_for_signing(jwk)) {\n        return NULL;\n    }\n\n    json_auto_t* sign = json_deep_copy(tki->m_sign);\n    if (json_array_append(sign, jwk) == -1) {\n        return NULL;\n    }\n    json_auto_t* jws = jwk_sign(tki->m_payload, sign);\n    if (!jws) {\n        return NULL;\n    }\n    return json_incref(jws);\n}\n\njson_t*\nfind_jwk(struct tang_keys_info* tki, const char* thp)\n{\n    if (!tki || !thp) {\n        return NULL;\n    }\n    return find_by_thp(tki, thp);\n}\n", "#!/bin/sh\n# vim: set tabstop=8 shiftwidth=4 softtabstop=4 expandtab smarttab colorcolumn=80:\n#\n# Copyright (c) 2016 Red Hat, Inc.\n# Author: Nathaniel McCallum <npmccallum@redhat.com>\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n#\n\nset -e\n\nusage() {\n    echo \"Usage: $0 <jwkdir> [<sig> <exc>]\" >&2\n    exit 1\n}\n\nset_perms() {\n    chmod -- 0440 \"${1}\"\n    if ! chown -- @user@:@group@ \"${1}\" 2>/dev/null; then\n        echo \"Unable to change owner/group for ${1} to @user@:@group@\" >&2\n    fi\n}\n\n[ $# -ne 1 ] && [ $# -ne 3 ] && usage\n[ -d \"$1\" ] || usage\n\n[ $# -eq 3 ] && sig=$2 && exc=$3\n\nTHP_DEFAULT_HASH=S256     # SHA-256.\n\n# Set default umask for file creation.\numask 0337\n\njwe=$(jose jwk gen -i '{\"alg\":\"ES512\"}')\n[ -z \"$sig\" ] && sig=$(echo \"$jwe\" | jose jwk thp -i- -a \"${THP_DEFAULT_HASH}\")\necho \"$jwe\" > \"$1/$sig.jwk\"\nset_perms \"$1/$sig.jwk\"\n\n\njwe=$(jose jwk gen -i '{\"alg\":\"ECMR\"}')\n[ -z \"$exc\" ] && exc=$(echo \"$jwe\" | jose jwk thp -i- -a \"${THP_DEFAULT_HASH}\")\necho \"$jwe\" > \"$1/$exc.jwk\"\nset_perms \"$1/$exc.jwk\"\n", "#!/bin/sh -e\n# vim: set ts=8 shiftwidth=4 softtabstop=4 expandtab smarttab colorcolumn=80:\n#\n# Copyright (c) 2020 Red Hat, Inc.\n# Author: Sergio Correia <scorreia@redhat.com>\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n#\n\nSUMMARY=\"Perform rotation of tang keys\"\n\nusage() {\n    _ret=\"${1:-1}\"\n    exec >&2\n    echo \"Usage: ${0} [-h] [-v] -d <KEYDIR>\"\n    echo\n    echo \"${SUMMARY}\"\n    echo\n    echo \"  -d KEYDIR  The directory with the keys, e.g. /var/db/tang\"\n    echo\n    echo \"  -h         Display this usage information\"\n    echo\n    echo \"  -v         Verbose. Display additional info on keys created/rotated\"\n    echo\n    exit \"${_ret}\"\n}\n\nlog() {\n    _msg=\"${1}\"\n    _verbose=\"${2:-}\"\n    [ -z \"${_verbose}\" ] && return 0\n    echo \"${_msg}\" >&2\n}\n\nerror() {\n    log \"${1}\" 1\n    usage 1\n}\n\nset_perms() {\n    chmod -- 0440 \"${1}\"\n    if ! chown -- @user@:@group@ \"${1}\" 2>/dev/null; then\n        echo \"Unable to change owner/group for ${1} to @user@:@group@\" >&2\n    fi\n}\n\nJWKDIR=\nVERBOSE=\nwhile getopts \"hvd:\" o; do\n    case \"${o}\" in\n        d) JWKDIR=\"${OPTARG}\";;\n        h) usage 0;;\n        v) VERBOSE=1;;\n        *) usage 1;;\n    esac\ndone\n\n[ -z \"${JWKDIR}\" ] && error \"Please specify the keys directory with -d switch\"\n[ -r \"${JWKDIR}\" ] || error \"Error trying to access JWK directory '${JWKDIR}'\"\n\ncd \"${JWKDIR}\" || error \"Unable to change to keys directory '${JWKDIR}'\"\n    # Disable advertisement of current keys.\n    for key in *.jwk; do\n        [ -r \"${key}\" ] || continue\n        mv -f -- \"${key}\" .\"${key}\"\n        log \"Disabled advertisement of key ${key} -> .${key}\" \"${VERBOSE}\"\n    done\n\n    # Create a new set of keys.\n    DEFAULT_THP_HASH=\"S256\"\n\n    # Set default umask for file creation.\n    umask 0337\n\n    for alg in \"ES512\" \"ECMR\"; do\n        json=\"$(printf '{\"alg\": \"%s\"}' \"${alg}\")\"\n        jwe=\"$(jose jwk gen --input \"${json}\")\"\n        thp=\"$(printf '%s' \"${jwe}\" | jose jwk thp --input=- \\\n                                           -a \"${DEFAULT_THP_HASH}\")\"\n        echo \"${jwe}\" > \"${thp}.jwk\"\n        set_perms \"${thp}.jwk\"\n        log \"Created new key ${thp}.jwk\" \"${VERBOSE}\"\n    done\ncd - >/dev/null\n\nlog \"Keys rotated successfully\" \"${VERBOSE}\"\n"], "filenames": ["src/keys.c", "src/tangd-keygen.in", "src/tangd-rotate-keys.in"], "buggy_code_start_loc": [309, 40, 81], "buggy_code_end_loc": [309, 40, 81], "fixing_code_start_loc": [310, 41, 82], "fixing_code_end_loc": [313, 45, 86], "type": "CWE-362", "message": "A race condition exists in the Tang server functionality for key generation and key rotation. This flaw results in a small time window where Tang private keys become readable by other processes on the same host.", "other": {"cve": {"id": "CVE-2023-1672", "sourceIdentifier": "secalert@redhat.com", "published": "2023-07-11T12:15:09.520", "lastModified": "2023-11-07T21:15:08.837", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "A race condition exists in the Tang server functionality for key generation and key rotation. This flaw results in a small time window where Tang private keys become readable by other processes on the same host."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:A/AC:H/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.6, "impactScore": 3.6}, {"source": "secalert@redhat.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:A/AC:H/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.6, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-362"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-362"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:tang_project:tang:*:*:*:*:*:*:*:*", "versionEndExcluding": "14", "matchCriteriaId": "91FB668D-32F0-442D-BC21-36133C7CC6F7"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:38:*:*:*:*:*:*:*", "matchCriteriaId": "CC559B26-5DFC-4B7A-A27C-B77DE755DFF9"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "F4CFF558-3C47-480D-A2F0-BABF26042943"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "7F6FB57C-2BC7-487C-96DD-132683AEB35D"}]}]}], "references": [{"url": "https://access.redhat.com/security/cve/CVE-2023-1672", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=2180999", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/latchset/tang/commit/8dbbed10870378f1b2c3cf3df2ea7edca7617096", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "https://lists.debian.org/debian-lts-announce/2023/11/msg00004.html", "source": "secalert@redhat.com"}, {"url": "https://www.openwall.com/lists/oss-security/2023/06/15/1", "source": "secalert@redhat.com", "tags": ["Exploit", "Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/latchset/tang/commit/8dbbed10870378f1b2c3cf3df2ea7edca7617096"}}