{"buggy_code": ["Sup's Hook System\n-----------------\n\nSup can be easily customized via its hook system, which allows custom\nuser code to be injected into Sup's execution path by \"hooking\" the\ncode onto pre-defined events. When those events occur, the code is\nexecuted.\n\nTo see which hooks are available, simply run sup -l. Each hook sits in\na file in ~/.sup/hooks/. Hooks are written in Ruby, and require no\nclass or method definitions, just the executable code itself.\n\nInformation passes from Sup to the hook code via Ruby variables\n(actually method calls), and from the hook code back to Sup via a\nreturn value. The values of variables persists across calls to the\nsame hook, but is NOT available to other hooks. To make the value of a\nvariable available to other hooks, use the get and set methods.  Each\nhook description lists the variables and return value expected, if\nany.\n\nThe following special functions are available to hooks:\n* say msg\n  Displays the string msg to the user at the bottom of the screen.\n* log msg\n  Adds the string msg to the log, which the user can access via the\n  buffer list.\n* ask_yes_or_no question\n  Prompts the user with the string question for a yes or no\n  response. Returns true if the user answered yes, false otherwise.\n* get key\n  Gets the cross-hook value associated with key (which is typically a\n  string). If there is no value for a given key, nil is returned.\n* set key value\n  Sets the cross-hook value associated with key to value. key is\n  typically a string, while value can be whatever type it needs to be,\n  including nil.\n\nSome example hooks:\n\nbefore-poll:\n  ## runs fetchmail before polling\n  if (@last_fetchmail_time || Time.now) < Time.now - 60\n    say \"Running fetchmail...\"\n    system \"fetchmail >& /dev/null\"\n    say \"Done running fetchmail.\"\n  end\n  @last_fetchmail_time = Time.now\n\n\nmime-decode:\n  ## turn text/html attachments into plain text, unless they are part\n  ## of a multipart/alternative pair\n  unless sibling_types.member? \"text/plain\"\n    case content_type\n    when \"text/html\"\n      `/usr/bin/w3m -dump -T #{content_type} '#{filename}'`\n    end\n  end\n\nstartup:\n  ## runs a background task\n  @bgtask_pid = fork\n  if @bgtask_pid\n    set 'bgtask_pid' @bgtask_pid\n    Process.detach(@bgtask_pid) # so we don't have to wait on it when we go to kill it\n  else\n    exec \"background-task args 2&>1 >> /tmp/logfile\"\n  end\n\nafter-poll:\n  ## kills the background task after the first poll\n  @bgtask_pid = get 'bgtask_pid'\n  Process.kill(\"TERM\", @bgtask_pid) unless @bgtask_pid == nil\n  set 'bgtask_pid' nil\n", "require 'tempfile'\nrequire 'rbconfig'\nrequire 'shellwords'\n\n## Here we define all the \"chunks\" that a message is parsed\n## into. Chunks are used by ThreadViewMode to render a message. Chunks\n## are used for both MIME stuff like attachments, for Sup's parsing of\n## the message body into text, quote, and signature regions, and for\n## notices like \"this message was decrypted\" or \"this message contains\n## a valid signature\"---basically, anything we want to differentiate\n## at display time.\n##\n## A chunk can be inlineable, expandable, or viewable. If it's\n## inlineable, #color and #lines are called and the output is treated\n## as part of the message text. This is how Text and one-line Quotes\n## and Signatures work.\n##\n## If it's not inlineable but is expandable, #patina_color and\n## #patina_text are called to generate a \"patina\" (a one-line widget,\n## basically), and the user can press enter to toggle the display of\n## the chunk content, which is generated from #color and #lines as\n## above. This is how Quote, Signature, and most widgets\n## work. Exandable chunks can additionally define #initial_state to be\n## :open if they want to start expanded (default is to start collapsed).\n##\n## If it's not expandable but is viewable, a patina is displayed using\n## #patina_color and #patina_text, but no toggling is allowed. Instead,\n## if #view! is defined, pressing enter on the widget calls view! and\n## (if that returns false) #to_s. Otherwise, enter does nothing. This\n##  is how non-inlineable attachments work.\n##\n## Independent of all that, a chunk can be quotable, in which case it's\n## included as quoted text during a reply. Text, Quotes, and mime-parsed\n## attachments are quotable; Signatures are not.\n\n## monkey-patch time: make temp files have the right extension\n## Backport from Ruby 1.9.2 for versions lower than 1.8.7\nif RUBY_VERSION < '1.8.7'\n  class Tempfile\n    def make_tmpname(prefix_suffix, n)\n      case prefix_suffix\n      when String\n        prefix = prefix_suffix\n        suffix = \"\"\n      when Array\n        prefix = prefix_suffix[0]\n        suffix = prefix_suffix[1]\n      else\n        raise ArgumentError, \"unexpected prefix_suffix: #{prefix_suffix.inspect}\"\n      end\n      t = Time.now.strftime(\"%Y%m%d\")\n      path = \"#{prefix}#{t}-#{$$}-#{rand(0x100000000).to_s(36)}\"\n      path << \"-#{n}\" if n\n      path << suffix\n    end\n  end\nend\n\n\nmodule Redwood\nmodule Chunk\n  class Attachment\n    HookManager.register \"mime-decode\", <<EOS\nDecodes a MIME attachment into text form. The text will be displayed\ndirectly in Sup. For attachments that you wish to use a separate program\nto view (e.g. images), you should use the mime-view hook instead.\n\nVariables:\n   content_type: the content-type of the attachment\n        charset: the charset of the attachment, if applicable\n       filename: the filename of the attachment as saved to disk\n  sibling_types: if this attachment is part of a multipart MIME attachment,\n                 an array of content-types for all attachments. Otherwise,\n                 the empty array.\nReturn value:\n  The decoded text of the attachment, or nil if not decoded.\nEOS\n\n    HookManager.register \"mime-view\", <<EOS\nViews a non-text MIME attachment. This hook allows you to run\nthird-party programs for attachments that require such a thing (e.g.\nimages). To instead display a text version of the attachment directly in\nSup, use the mime-decode hook instead.\n\nNote that by default (at least on systems that have a run-mailcap command),\nSup uses the default mailcap handler for the attachment's MIME type. If\nyou want a particular behavior to be global, you may wish to change your\nmailcap instead.\n\nVariables:\n   content_type: the content-type of the attachment\n       filename: the filename of the attachment as saved to disk\nReturn value:\n  True if the viewing was successful, false otherwise. If false, calling\n  /usr/bin/run-mailcap will be tried.\nEOS\n#' stupid ruby-mode\n\n    ## raw_content is the post-MIME-decode content. this is used for\n    ## saving the attachment to disk.\n    attr_reader :content_type, :filename, :lines, :raw_content\n    bool_reader :quotable\n\n    ## store tempfile objects as class variables so that they\n    ## are not removed when the viewing process returns. they\n    ## should be garbage collected when the class variable is removed.\n    @@view_tempfiles = []\n\n    def initialize content_type, filename, encoded_content, sibling_types\n      @content_type = content_type.downcase\n      @filename = filename\n      @quotable = false # changed to true if we can parse it through the\n                        # mime-decode hook, or if it's plain text\n      @raw_content =\n        if encoded_content.body\n          encoded_content.decode\n        else\n          \"For some bizarre reason, RubyMail was unable to parse this attachment.\\n\"\n        end\n\n      text = case @content_type\n      when /^text\\/plain\\b/\n        @raw_content\n      else\n        HookManager.run \"mime-decode\", :content_type => content_type,\n                        :filename => lambda { write_to_disk },\n                        :charset => encoded_content.charset,\n                        :sibling_types => sibling_types\n      end\n\n      @lines = nil\n      if text\n        text = text.transcode(encoded_content.charset || $encoding)\n        @lines = text.gsub(\"\\r\\n\", \"\\n\").gsub(/\\t/, \"        \").gsub(/\\r/, \"\").split(\"\\n\")\n        @quotable = true\n      end\n    end\n\n    def color; :text_color end\n    def patina_color; :attachment_color end\n    def patina_text\n      if expandable?\n        \"Attachment: #{filename} (#{lines.length} lines)\"\n      else\n        \"Attachment: #{filename} (#{content_type}; #{@raw_content.size.to_human_size})\"\n      end\n    end\n\n    ## an attachment is exapndable if we've managed to decode it into\n    ## something we can display inline. otherwise, it's viewable.\n    def inlineable?; false end\n    def expandable?; !viewable? end\n    def initial_state; :open end\n    def viewable?; @lines.nil? end\n    def view_default! path\n      case RbConfig::CONFIG['arch']\n        when /darwin/\n          cmd = \"open '#{path}'\"\n        else\n          cmd = \"/usr/bin/run-mailcap --action=view '#{@content_type}:#{path}'\"\n      end\n      debug \"running: #{cmd.inspect}\"\n      BufferManager.shell_out(cmd)\n      $? == 0\n    end\n\n    def view!\n      write_to_disk do |file|\n\n        @@view_tempfiles.push file # make sure the tempfile is not garbage collected before sup stops\n\n        ret = HookManager.run \"mime-view\", :content_type => @content_type,\n                                           :filename => file.path\n        ret || view_default!(file.path)\n      end\n    end\n\n    def write_to_disk\n      begin\n        file = Tempfile.new([\"sup\", Shellwords.escape(@filename.gsub(\"/\", \"_\")) || \"sup-attachment\"])\n        file.print @raw_content\n        yield file if block_given?\n        return file.path\n      ensure\n        file.close\n      end\n    end\n\n    ## used when viewing the attachment as text\n    def to_s\n      @lines || @raw_content\n    end\n  end\n\n  class Text\n\n    attr_reader :lines\n    def initialize lines\n      @lines = lines\n      ## trim off all empty lines except one\n      @lines.pop while @lines.length > 1 && @lines[-1] =~ /^\\s*$/ && @lines[-2] =~ /^\\s*$/\n    end\n\n    def inlineable?; true end\n    def quotable?; true end\n    def expandable?; false end\n    def viewable?; false end\n    def color; :text_color end\n  end\n\n  class Quote\n    attr_reader :lines\n    def initialize lines\n      @lines = lines\n    end\n\n    def inlineable?; @lines.length == 1 end\n    def quotable?; true end\n    def expandable?; !inlineable? end\n    def viewable?; false end\n\n    def patina_color; :quote_patina_color end\n    def patina_text; \"(#{lines.length} quoted lines)\" end\n    def color; :quote_color end\n  end\n\n  class Signature\n    attr_reader :lines\n    def initialize lines\n      @lines = lines\n    end\n\n    def inlineable?; @lines.length == 1 end\n    def quotable?; false end\n    def expandable?; !inlineable? end\n    def viewable?; false end\n\n    def patina_color; :sig_patina_color end\n    def patina_text; \"(#{lines.length}-line signature)\" end\n    def color; :sig_color end\n  end\n\n  class EnclosedMessage\n    attr_reader :lines\n    def initialize from, to, cc, date, subj\n      @from = from ? \"unknown sender\" : from.full_adress\n      @to = to ? \"\" : to.map { |p| p.full_address }.join(\", \")\n      @cc = cc ? \"\" : cc.map { |p| p.full_address }.join(\", \")\n      if date\n        @date = date.rfc822\n      else\n        @date = \"\"\n      end\n\n      @subj = subj\n\n      @lines = \"\\nFrom: #{from}\\n\"\n      @lines += \"To: #{to}\\n\"\n      if !cc.empty?\n        @lines += \"Cc: #{cc}\\n\"\n      end\n      @lines += \"Date: #{date}\\n\"\n      @lines += \"Subject: #{subj}\\n\\n\"\n    end\n\n    def inlineable?; false end\n    def quotable?; false end\n    def expandable?; true end\n    def initial_state; :closed end\n    def viewable?; false end\n\n    def patina_color; :generic_notice_patina_color end\n    def patina_text; \"Begin enclosed message sent on #{@date}\" end\n\n    def color; :quote_color end\n  end\n\n  class CryptoNotice\n    attr_reader :lines, :status, :patina_text\n\n    def initialize status, description, lines=[]\n      @status = status\n      @patina_text = description\n      @lines = lines\n    end\n\n    def patina_color\n      case status\n      when :valid then :cryptosig_valid_color\n      when :valid_untrusted then :cryptosig_valid_untrusted_color\n      when :invalid then :cryptosig_invalid_color\n      else :cryptosig_unknown_color\n      end\n    end\n    def color; patina_color end\n\n    def inlineable?; false end\n    def quotable?; false end\n    def expandable?; !@lines.empty? end\n    def viewable?; false end\n  end\nend\nend\n"], "fixing_code": ["Sup's Hook System\n-----------------\n\nSup can be easily customized via its hook system, which allows custom\nuser code to be injected into Sup's execution path by \"hooking\" the\ncode onto pre-defined events. When those events occur, the code is\nexecuted.\n\nTo see which hooks are available, simply run sup -l. Each hook sits in\na file in ~/.sup/hooks/. Hooks are written in Ruby, and require no\nclass or method definitions, just the executable code itself.\n\nInformation passes from Sup to the hook code via Ruby variables\n(actually method calls), and from the hook code back to Sup via a\nreturn value. The values of variables persists across calls to the\nsame hook, but is NOT available to other hooks. To make the value of a\nvariable available to other hooks, use the get and set methods.  Each\nhook description lists the variables and return value expected, if\nany.\n\nThe following special functions are available to hooks:\n* say msg\n  Displays the string msg to the user at the bottom of the screen.\n* log msg\n  Adds the string msg to the log, which the user can access via the\n  buffer list.\n* ask_yes_or_no question\n  Prompts the user with the string question for a yes or no\n  response. Returns true if the user answered yes, false otherwise.\n* get key\n  Gets the cross-hook value associated with key (which is typically a\n  string). If there is no value for a given key, nil is returned.\n* set key value\n  Sets the cross-hook value associated with key to value. key is\n  typically a string, while value can be whatever type it needs to be,\n  including nil.\n\nSome example hooks:\n\nbefore-poll:\n  ## runs fetchmail before polling\n  if (@last_fetchmail_time || Time.now) < Time.now - 60\n    say \"Running fetchmail...\"\n    system \"fetchmail >& /dev/null\"\n    say \"Done running fetchmail.\"\n  end\n  @last_fetchmail_time = Time.now\n\n\nmime-decode:\n  ## turn text/html attachments into plain text, unless they are part\n  ## of a multipart/alternative pair\n  require 'shellwords'\n  unless sibling_types.member? \"text/plain\"\n    case content_type\n    when \"text/html\"\n      `/usr/bin/w3m -dump -T #{content_type} #{Shellwords.escape filename}`\n    end\n  end\n\nstartup:\n  ## runs a background task\n  @bgtask_pid = fork\n  if @bgtask_pid\n    set 'bgtask_pid' @bgtask_pid\n    Process.detach(@bgtask_pid) # so we don't have to wait on it when we go to kill it\n  else\n    exec \"background-task args 2&>1 >> /tmp/logfile\"\n  end\n\nafter-poll:\n  ## kills the background task after the first poll\n  @bgtask_pid = get 'bgtask_pid'\n  Process.kill(\"TERM\", @bgtask_pid) unless @bgtask_pid == nil\n  set 'bgtask_pid' nil\n", "require 'tempfile'\nrequire 'rbconfig'\nrequire 'shellwords'\n\n## Here we define all the \"chunks\" that a message is parsed\n## into. Chunks are used by ThreadViewMode to render a message. Chunks\n## are used for both MIME stuff like attachments, for Sup's parsing of\n## the message body into text, quote, and signature regions, and for\n## notices like \"this message was decrypted\" or \"this message contains\n## a valid signature\"---basically, anything we want to differentiate\n## at display time.\n##\n## A chunk can be inlineable, expandable, or viewable. If it's\n## inlineable, #color and #lines are called and the output is treated\n## as part of the message text. This is how Text and one-line Quotes\n## and Signatures work.\n##\n## If it's not inlineable but is expandable, #patina_color and\n## #patina_text are called to generate a \"patina\" (a one-line widget,\n## basically), and the user can press enter to toggle the display of\n## the chunk content, which is generated from #color and #lines as\n## above. This is how Quote, Signature, and most widgets\n## work. Exandable chunks can additionally define #initial_state to be\n## :open if they want to start expanded (default is to start collapsed).\n##\n## If it's not expandable but is viewable, a patina is displayed using\n## #patina_color and #patina_text, but no toggling is allowed. Instead,\n## if #view! is defined, pressing enter on the widget calls view! and\n## (if that returns false) #to_s. Otherwise, enter does nothing. This\n##  is how non-inlineable attachments work.\n##\n## Independent of all that, a chunk can be quotable, in which case it's\n## included as quoted text during a reply. Text, Quotes, and mime-parsed\n## attachments are quotable; Signatures are not.\n\n## monkey-patch time: make temp files have the right extension\n## Backport from Ruby 1.9.2 for versions lower than 1.8.7\nif RUBY_VERSION < '1.8.7'\n  class Tempfile\n    def make_tmpname(prefix_suffix, n)\n      case prefix_suffix\n      when String\n        prefix = prefix_suffix\n        suffix = \"\"\n      when Array\n        prefix = prefix_suffix[0]\n        suffix = prefix_suffix[1]\n      else\n        raise ArgumentError, \"unexpected prefix_suffix: #{prefix_suffix.inspect}\"\n      end\n      t = Time.now.strftime(\"%Y%m%d\")\n      path = \"#{prefix}#{t}-#{$$}-#{rand(0x100000000).to_s(36)}\"\n      path << \"-#{n}\" if n\n      path << suffix\n    end\n  end\nend\n\n\nmodule Redwood\nmodule Chunk\n  class Attachment\n    ## please see note in write_to_disk on important usage\n    ## of quotes to avoid remote command injection.\n    HookManager.register \"mime-decode\", <<EOS\nDecodes a MIME attachment into text form. The text will be displayed\ndirectly in Sup. For attachments that you wish to use a separate program\nto view (e.g. images), you should use the mime-view hook instead.\n\nVariables:\n   content_type: the content-type of the attachment\n        charset: the charset of the attachment, if applicable\n       filename: the filename of the attachment as saved to disk\n  sibling_types: if this attachment is part of a multipart MIME attachment,\n                 an array of content-types for all attachments. Otherwise,\n                 the empty array.\nReturn value:\n  The decoded text of the attachment, or nil if not decoded.\nEOS\n\n\n    ## please see note in write_to_disk on important usage\n    ## of quotes to avoid remote command injection.\n    HookManager.register \"mime-view\", <<EOS\nViews a non-text MIME attachment. This hook allows you to run\nthird-party programs for attachments that require such a thing (e.g.\nimages). To instead display a text version of the attachment directly in\nSup, use the mime-decode hook instead.\n\nNote that by default (at least on systems that have a run-mailcap command),\nSup uses the default mailcap handler for the attachment's MIME type. If\nyou want a particular behavior to be global, you may wish to change your\nmailcap instead.\n\nVariables:\n   content_type: the content-type of the attachment\n       filename: the filename of the attachment as saved to disk\nReturn value:\n  True if the viewing was successful, false otherwise. If false, calling\n  /usr/bin/run-mailcap will be tried.\nEOS\n#' stupid ruby-mode\n\n    ## raw_content is the post-MIME-decode content. this is used for\n    ## saving the attachment to disk.\n    attr_reader :content_type, :filename, :lines, :raw_content\n    bool_reader :quotable\n\n    ## store tempfile objects as class variables so that they\n    ## are not removed when the viewing process returns. they\n    ## should be garbage collected when the class variable is removed.\n    @@view_tempfiles = []\n\n    def initialize content_type, filename, encoded_content, sibling_types\n      @content_type = content_type.downcase\n      @filename = filename\n      @quotable = false # changed to true if we can parse it through the\n                        # mime-decode hook, or if it's plain text\n      @raw_content =\n        if encoded_content.body\n          encoded_content.decode\n        else\n          \"For some bizarre reason, RubyMail was unable to parse this attachment.\\n\"\n        end\n\n      text = case @content_type\n      when /^text\\/plain\\b/\n        @raw_content\n      else\n        ## please see note in write_to_disk on important usage\n        ## of quotes to avoid remote command injection.\n        HookManager.run \"mime-decode\", :content_type => content_type,\n                        :filename => lambda { write_to_disk },\n                        :charset => encoded_content.charset,\n                        :sibling_types => sibling_types\n      end\n\n      @lines = nil\n      if text\n        text = text.transcode(encoded_content.charset || $encoding)\n        @lines = text.gsub(\"\\r\\n\", \"\\n\").gsub(/\\t/, \"        \").gsub(/\\r/, \"\").split(\"\\n\")\n        @quotable = true\n      end\n    end\n\n    def color; :text_color end\n    def patina_color; :attachment_color end\n    def patina_text\n      if expandable?\n        \"Attachment: #{filename} (#{lines.length} lines)\"\n      else\n        \"Attachment: #{filename} (#{content_type}; #{@raw_content.size.to_human_size})\"\n      end\n    end\n\n    ## an attachment is exapndable if we've managed to decode it into\n    ## something we can display inline. otherwise, it's viewable.\n    def inlineable?; false end\n    def expandable?; !viewable? end\n    def initial_state; :open end\n    def viewable?; @lines.nil? end\n    def view_default! path\n      ## please see note in write_to_disk on important usage\n      ## of quotes to avoid remote command injection.\n      case RbConfig::CONFIG['arch']\n        when /darwin/\n          cmd = \"open #{path}\"\n        else\n          cmd = \"/usr/bin/run-mailcap --action=view #{@content_type}:#{path}\"\n      end\n      debug \"running: #{cmd.inspect}\"\n      BufferManager.shell_out(cmd)\n      $? == 0\n    end\n\n    def view!\n      ## please see note in write_to_disk on important usage\n      ## of quotes to avoid remote command injection.\n      write_to_disk do |file|\n\n        @@view_tempfiles.push file # make sure the tempfile is not garbage collected before sup stops\n\n        ret = HookManager.run \"mime-view\", :content_type => @content_type,\n                                           :filename => file.path\n        ret || view_default!(file.path)\n      end\n    end\n\n    ## note that the path returned from write_to_disk is\n    ## Shellwords.escaped and is intended to be used without single\n    ## or double quotes. the use of either opens sup up for remote\n    ## code injection in the file name.\n    def write_to_disk\n      begin\n        file = Tempfile.new([\"sup\", Shellwords.escape(@filename.gsub(\"/\", \"_\")) || \"sup-attachment\"])\n        file.print @raw_content\n        yield file if block_given?\n        return file.path\n      ensure\n        file.close\n      end\n    end\n\n    ## used when viewing the attachment as text\n    def to_s\n      @lines || @raw_content\n    end\n  end\n\n  class Text\n\n    attr_reader :lines\n    def initialize lines\n      @lines = lines\n      ## trim off all empty lines except one\n      @lines.pop while @lines.length > 1 && @lines[-1] =~ /^\\s*$/ && @lines[-2] =~ /^\\s*$/\n    end\n\n    def inlineable?; true end\n    def quotable?; true end\n    def expandable?; false end\n    def viewable?; false end\n    def color; :text_color end\n  end\n\n  class Quote\n    attr_reader :lines\n    def initialize lines\n      @lines = lines\n    end\n\n    def inlineable?; @lines.length == 1 end\n    def quotable?; true end\n    def expandable?; !inlineable? end\n    def viewable?; false end\n\n    def patina_color; :quote_patina_color end\n    def patina_text; \"(#{lines.length} quoted lines)\" end\n    def color; :quote_color end\n  end\n\n  class Signature\n    attr_reader :lines\n    def initialize lines\n      @lines = lines\n    end\n\n    def inlineable?; @lines.length == 1 end\n    def quotable?; false end\n    def expandable?; !inlineable? end\n    def viewable?; false end\n\n    def patina_color; :sig_patina_color end\n    def patina_text; \"(#{lines.length}-line signature)\" end\n    def color; :sig_color end\n  end\n\n  class EnclosedMessage\n    attr_reader :lines\n    def initialize from, to, cc, date, subj\n      @from = from ? \"unknown sender\" : from.full_address\n      @to = to ? \"\" : to.map { |p| p.full_address }.join(\", \")\n      @cc = cc ? \"\" : cc.map { |p| p.full_address }.join(\", \")\n      if date\n        @date = date.rfc822\n      else\n        @date = \"\"\n      end\n\n      @subj = subj\n\n      @lines = \"\\nFrom: #{from}\\n\"\n      @lines += \"To: #{to}\\n\"\n      if !cc.empty?\n        @lines += \"Cc: #{cc}\\n\"\n      end\n      @lines += \"Date: #{date}\\n\"\n      @lines += \"Subject: #{subj}\\n\\n\"\n    end\n\n    def inlineable?; false end\n    def quotable?; false end\n    def expandable?; true end\n    def initial_state; :closed end\n    def viewable?; false end\n\n    def patina_color; :generic_notice_patina_color end\n    def patina_text; \"Begin enclosed message sent on #{@date}\" end\n\n    def color; :quote_color end\n  end\n\n  class CryptoNotice\n    attr_reader :lines, :status, :patina_text\n\n    def initialize status, description, lines=[]\n      @status = status\n      @patina_text = description\n      @lines = lines\n    end\n\n    def patina_color\n      case status\n      when :valid then :cryptosig_valid_color\n      when :valid_untrusted then :cryptosig_valid_untrusted_color\n      when :invalid then :cryptosig_invalid_color\n      else :cryptosig_unknown_color\n      end\n    end\n    def color; patina_color end\n\n    def inlineable?; false end\n    def quotable?; false end\n    def expandable?; !@lines.empty? end\n    def viewable?; false end\n  end\nend\nend\n"], "filenames": ["doc/Hooks.txt", "lib/sup/message_chunks.rb"], "buggy_code_start_loc": [52, 62], "buggy_code_end_loc": [57, 247], "fixing_code_start_loc": [53, 63], "fixing_code_end_loc": [58, 262], "type": "CWE-94", "message": "Sup before 0.13.2.1 and 0.14.x before 0.14.1.1 allows remote attackers to execute arbitrary commands via shell metacharacters in the filename of an email attachment.", "other": {"cve": {"id": "CVE-2013-4478", "sourceIdentifier": "secalert@redhat.com", "published": "2013-12-07T20:55:02.460", "lastModified": "2013-12-09T17:54:33.770", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Sup before 0.13.2.1 and 0.14.x before 0.14.1.1 allows remote attackers to execute arbitrary commands via shell metacharacters in the filename of an email attachment."}, {"lang": "es", "value": "Sup anterior a la versi\u00f3n 0.13.2.1 y 0.14.x anterior a 0.14.1.1 permite a atacantes remotos ejecutar comandos arbitrarios a trav\u00e9s de metacaracteres de shell en el nombre de archivo de un adjunto por email."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-94"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:supmua:sup:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.13.2", "matchCriteriaId": "CEF11CEF-BE1B-468D-9072-EAEDCCEE7877"}, {"vulnerable": true, "criteria": "cpe:2.3:a:supmua:sup:0.13.0:*:*:*:*:*:*:*", "matchCriteriaId": "35DC51E3-079D-42FD-A055-3E96626015FF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:supmua:sup:0.13.1:*:*:*:*:*:*:*", "matchCriteriaId": "00BA053E-289D-4360-97E4-F05F03B611E5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:supmua:sup:0.14.0:*:*:*:*:*:*:*", "matchCriteriaId": "E5DE677F-6E4C-4A72-B5F7-A081DFFF12A4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:supmua:sup:0.14.1:*:*:*:*:*:*:*", "matchCriteriaId": "610B9FD9-2C1A-4DFC-A687-FA82BEA28723"}]}]}], "references": [{"url": "http://rubyforge.org/pipermail/sup-talk/2013-August/004993.html", "source": "secalert@redhat.com"}, {"url": "http://rubyforge.org/pipermail/sup-talk/2013-October/004996.html", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2013/10/30/2", "source": "secalert@redhat.com"}, {"url": "https://github.com/sup-heliotrope/sup/commit/8b46cdbfc14e07ca07d403aa28b0e7bc1c544785", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}]}, "github_commit_url": "https://github.com/sup-heliotrope/sup/commit/8b46cdbfc14e07ca07d403aa28b0e7bc1c544785"}}