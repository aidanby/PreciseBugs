{"buggy_code": ["/* cgif.c -- a merge of some GIF-decoding files from giflib by E.S.Raymond\n * by pts@fazekas.hu at Wed Feb 27 13:18:04 CET 2002\n\nThe GIFLIB distribution is Copyright (c) 1997  Eric S. Raymond\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n */\n\n/*The creators of the GIF format require the following\n  acknowledgement:\n  The Graphics Interchange Format(c) is the Copyright property of\n  CompuServe Incorporated. GIF(sm) is a Service Mark property of\n  CompuServe Incorporated.\n*/\n\n#ifdef __GNUC__\n#ifndef __clang__\n#pragma implementation\n#endif\n#endif\n\n/**** pts: not an ANSI C function */\n#undef EXTERN_C\n#ifdef __cplusplus\n#define EXTERN_C extern \"C\"\n#define CGIFFF CGIF::\n#else\n#define EXTERN_C extern\n#define CGIFFF\n#endif\n#if OBJDEP\n#  warning PROVIDES: cgif\n#endif\n\n#if 0\nEXTERN_C FILE *fdopen (int fildes, const char *mode); /* GCC 3.0 SUXX */\n#else\n#undef  _POSIX_SOURCE\n#define _POSIX_SOURCE 1\n#undef  _POSIX_C_SOURCE\n#define _POSIX_C_SOURCE 2\n#endif\n\n/* --- gifalloc.c */\n\n/*****************************************************************************\n*   \"Gif-Lib\" - Yet another gif library.\t\t\t\t     *\n*\t\t\t\t\t\t\t\t\t     *\n* Written by:  Gershon Elber\t\t\t\tVer 0.1, Jun. 1989   *\n* Extensively hacked by: Eric S. Raymond\t\tVer 1.?, Sep 1992    *\n******************************************************************************\n* GIF construction tools\t\t\t\t\t\t      *\n******************************************************************************\n* History:\t\t\t\t\t\t\t\t     *\n* 15 Sep 92 - Version 1.0 by Eric Raymond.\t\t\t\t     *\n*****************************************************************************/\n\n// #undef __STRICT_ANSI__ /* for MINGW32 open() !! */\n#include <stdio.h>\n#include \"cgif.h\"\n\n/**** pts ****/\n#include <stdlib.h> /* malloc(), free(), realloc() */\n#include <string.h> /* memset() */\n\n\n//#include <unistd.h>\n\n#if USE_CGIF_FDOPEN\n#include <fcntl.h> /* open() */\n#include <sys/types.h>\n#include <sys/stat.h>\n#  if defined(__MINGW32__) || defined(__CYGWIN__) || defined(_MSC_VER)\n#    undef __STRICT_ANSI__\n#    include <io.h>\n     /*#define open _open*/\n#  endif\n#endif\n\n/* --- gif_err.c */\n\n/*****************************************************************************\n*   \"Gif-Lib\" - Yet another gif library.\t\t\t\t     *\n*\t\t\t\t\t\t\t\t\t     *\n* Written by:  Gershon Elber\t\t\tIBM PC Ver 0.1,\tJun. 1989    *\n******************************************************************************\n* Handle error reporting for the GIF library.\t\t\t\t     *\n******************************************************************************\n* History:\t\t\t\t\t\t\t\t     *\n* 17 Jun 89 - Version 1.0 by Gershon Elber.\t\t\t\t     *\n*****************************************************************************/\n\n/* #include <stdio.h> already */\n/* #include \"gif_lib.h\" already */\n\n/* --- dgif_lib.c */\n\n/******************************************************************************\n*   \"Gif-Lib\" - Yet another gif library.\t\t\t\t      *\n*\t\t\t\t\t\t\t\t\t      *\n* Written by:  Gershon Elber\t\t\tIBM PC Ver 1.1,\tAug. 1990     *\n*******************************************************************************\n* The kernel of the GIF Decoding process can be found here.\t\t      *\n*******************************************************************************\n* History:\t\t\t\t\t\t\t\t      *\n* 16 Jun 89 - Version 1.0 by Gershon Elber.\t\t\t\t      *\n*  3 Sep 90 - Version 1.1 by Gershon Elber (Support for Gif89, Unique names). *\n******************************************************************************/\n\n#ifdef __MSDOS__\n#include <io.h>\n#include <alloc.h>\n#include <stdlib.h>\n#include <sys\\stat.h>\n#else\n#include <sys/types.h>\n#include <sys/stat.h>\n#endif /* __MSDOS__ */\n\n#include <fcntl.h>\n/* #include <stdio.h> already */\n/* #include <string.h> already */\n/* #include \"gif_lib.h\" already */\n\n/* #include <stdlib.h> already */ /* malloc(), free() */\n#include <assert.h>\n\n/* ---- */\n\nstatic void *xmalloc(size_t size);\nstatic void *xrealloc(void *ptr, size_t size);\n\n/* --- gif_err.c */\n\n/* #define PROGRAM_NAME\t\"GIF_LIBRARY\" */\n\nint CGIFFF _GifError = 0;\n\n/*****************************************************************************\n* Return the last GIF error (0 if none) and reset the error.\t\t     *\n*****************************************************************************/\nint CGIFFF GifLastError(void)\n{\n    int i = _GifError;\n\n    _GifError = 0;\n\n    return i;\n}\n\n/**** pts ****/\n/** May return NULL. */\nPTS_const char *CGIFFF GetGifError(void)\n{\n    PTS_const char *Err;\n\n    switch(_GifError) {\n#if 0 /**** pts ****/\n\tcase E_GIF_ERR_OPEN_FAILED:\n\t    Err = \"Failed to open given file\";\n\t    break;\n\tcase E_GIF_ERR_WRITE_FAILED:\n\t    Err = \"Failed to Write to given file\";\n\t    break;\n\tcase E_GIF_ERR_HAS_SCRN_DSCR:\n\t    Err = \"Screen Descriptor already been set\";\n\t    break;\n\tcase E_GIF_ERR_HAS_IMAG_DSCR:\n\t    Err = \"Image Descriptor is still active\";\n\t    break;\n\tcase E_GIF_ERR_NO_COLOR_MAP:\n\t    Err = \"Neither Global Nor Local color map\";\n\t    break;\n\tcase E_GIF_ERR_DATA_TOO_BIG:\n\t    Err = \"#Pixels bigger than Width * Height\";\n\t    break;\n\tcase E_GIF_ERR_NOT_ENOUGH_MEM:\n\t    Err = \"Fail to allocate required memory\";\n\t    break;\n\tcase E_GIF_ERR_DISK_IS_FULL:\n\t    Err = \"Write failed (disk full?)\";\n\t    break;\n\tcase E_GIF_ERR_CLOSE_FAILED:\n\t    Err = \"Failed to close given file\";\n\t    break;\n\tcase E_GIF_ERR_NOT_WRITEABLE:\n\t    Err = \"Given file was not opened for write\";\n\t    break;\n#endif\n\tcase D_GIF_ERR_OPEN_FAILED:\n\t    Err = \"Failed to open given file\";\n\t    break;\n\tcase D_GIF_ERR_READ_FAILED:\n\t    Err = \"Failed to Read from given file\";\n\t    break;\n\tcase D_GIF_ERR_NOT_GIF_FILE:\n\t    Err = \"Given file is NOT GIF file\";\n\t    break;\n\tcase D_GIF_ERR_NO_SCRN_DSCR:\n\t    Err = \"No Screen Descriptor detected\";\n\t    break;\n\tcase D_GIF_ERR_NO_IMAG_DSCR:\n\t    Err = \"No Image Descriptor detected\";\n\t    break;\n\tcase D_GIF_ERR_NO_COLOR_MAP:\n\t    Err = \"Neither Global Nor Local color map\";\n\t    break;\n\tcase D_GIF_ERR_WRONG_RECORD:\n\t    Err = \"Wrong record type detected\";\n\t    break;\n\tcase D_GIF_ERR_DATA_TOO_BIG:\n\t    Err = \"#Pixels bigger than Width * Height\";\n\t    break;\n\tcase D_GIF_ERR_NOT_ENOUGH_MEM:\n\t    Err = \"Fail to allocate required memory\";\n\t    break;\n\tcase D_GIF_ERR_CLOSE_FAILED:\n\t    Err = \"Failed to close given file\";\n\t    break;\n\tcase D_GIF_ERR_NOT_READABLE:\n\t    Err = \"Given file was not opened for read\";\n\t    break;\n\tcase D_GIF_ERR_IMAGE_DEFECT:\n\t    Err = \"Image is defective, decoding aborted\";\n\t    break;\n\tcase D_GIF_ERR_EOF_TOO_SOON:\n\t    Err = \"Image EOF detected, before image complete\";\n\t    break;\n\tcase D_GIF_ERR_EXT_TOO_SHORT:\n\t    Err = \"Extension data too short\";\n\t    break;\n\tdefault:\n\t    Err = NULL;\n\t    break;\n    }\n    return Err;\n}\n\n/*****************************************************************************\n* Print the last GIF error to stderr.\t\t\t\t\t     *\n*****************************************************************************/\nvoid CGIFFF PrintGifError(void)\n{\n    PTS_const char *Err=GetGifError();\n    if (Err != NULL)\n\tfprintf(stderr, \"\\nGIF-LIB error: %s.\\n\", Err);\n    else\n\tfprintf(stderr, \"\\nGIF-LIB undefined error %d.\\n\", _GifError);\n}\n\n/* --- gifalloc.c */\n\n#define MAXGIF(x, y)\t(((x) > (y)) ? (x) : (y))\n\n/******************************************************************************\n* Miscellaneous utility functions\t\t\t\t\t      *\n******************************************************************************/\n\nstatic int BitSize(int n)\n/* return smallest bitfield size n will fit in */\n{\n    register\tint i;\n\n    for (i = 1; i <= 8; i++)\n\tif ((1 << i) >= n)\n\t    break;\n    return(i);\n}\n\n\n/******************************************************************************\n* Color map object functions\t\t\t\t\t\t      *\n******************************************************************************/\n\nCGIFFF ColorMapObject *CGIFFF MakeMapObject(int ColorCount, GifColorType *ColorMap)\n/*\n * Allocate a color map of given size; initialize with contents of\n * ColorMap if that pointer is non-NULL.\n */\n{\n    ColorMapObject *Object;\n\n    if (ColorCount != (1 << BitSize(ColorCount)))\n\treturn((ColorMapObject *)NULL);\n\n    Object = (ColorMapObject *)xmalloc(sizeof(ColorMapObject));\n\n    Object->Colors = (GifColorType *)xmalloc(ColorCount * sizeof(GifColorType));\n    memset(Object->Colors, '\\0', ColorCount * sizeof(GifColorType));\n\n    Object->ColorCount = ColorCount;\n    Object->BitsPerPixel = BitSize(ColorCount);\n\n    if (ColorMap)\n\tmemcpy((char *)Object->Colors,\n\t       (char *)ColorMap, ColorCount * sizeof(GifColorType));\n\n    return(Object);\n}\n\nvoid CGIFFF FreeMapObject(CGIFFF ColorMapObject *Object)\n/*\n * Free a color map object\n */\n{\n    free(Object->Colors);\n    free(Object);\n}\n\n#if 0\nvoid DumpColorMap(ColorMapObject *Object, FILE *fp)\n{\n    if (Object)\n    {\n\tint i, j, Len = Object->ColorCount;\n\n\tfor (i = 0; i < Len; i+=4) {\n\t    for (j = 0; j < 4 && j < Len; j++) {\n\t\tfprintf(fp,\n\t\t\t\"%3d: %02x %02x %02x   \", i + j,\n\t\t       Object->Colors[i + j].Red,\n\t\t       Object->Colors[i + j].Green,\n\t\t       Object->Colors[i + j].Blue);\n\t    }\n\t    fprintf(fp, \"\\n\");\n\t}\n    }\n}\n#endif /* DEBUG */\n\n#if 0\nColorMapObject *CGIFFF UnionColorMap(\n\t\t\t ColorMapObject *ColorIn1,\n\t\t\t ColorMapObject *ColorIn2,\n\t\t\t GifPixelType ColorTransIn2[])\n/*\n * Compute the union of two given color maps and return it.  If result can't\n * fit into 256 colors, NULL is returned, the allocated union otherwise.\n * ColorIn1 is copied as is to ColorUnion, while colors from ColorIn2 are\n * copied iff they didn't exist before.  ColorTransIn2 maps the old\n * ColorIn2 into ColorUnion color map table.\n */\n{\n    int i, j, CrntSlot, RoundUpTo, NewBitSize;\n    ColorMapObject *ColorUnion;\n\n    /*\n     * Allocate table which will hold the result for sure.\n     */\n    ColorUnion\n\t= MakeMapObject(MAXGIF(ColorIn1->ColorCount,ColorIn2->ColorCount)*2,NULL);\n\n    if (ColorUnion == NULL)\n\treturn(NULL);\n\n    /* Copy ColorIn1 to ColorUnionSize; */\n    for (i = 0; i < ColorIn1->ColorCount; i++)\n\tColorUnion->Colors[i] = ColorIn1->Colors[i];\n    CrntSlot = ColorIn1->ColorCount;\n\n    /*\n     * Potentially obnoxious hack:\n     *\n     * Back CrntSlot down past all contiguous {0, 0, 0} slots at the end\n     * of table 1.  This is very useful if your display is limited to\n     * 16 colors.\n     */\n    while (ColorIn1->Colors[CrntSlot-1].Red == 0\n\t   && ColorIn1->Colors[CrntSlot-1].Green == 0\n\t   && ColorIn1->Colors[CrntSlot-1].Red == 0)\n\tCrntSlot--;\n\n    /* Copy ColorIn2 to ColorUnionSize (use old colors if they exist): */\n    for (i = 0; i < ColorIn2->ColorCount && CrntSlot<=256; i++)\n    {\n\t/* Let's see if this color already exists: */\n\tfor (j = 0; j < ColorIn1->ColorCount; j++)\n\t    if (memcmp(&ColorIn1->Colors[j], &ColorIn2->Colors[i], sizeof(GifColorType)) == 0)\n\t\tbreak;\n\n\tif (j < ColorIn1->ColorCount)\n\t    ColorTransIn2[i] = j;\t/* color exists in Color1 */\n\telse\n\t{\n\t    /* Color is new - copy it to a new slot: */\n\t    ColorUnion->Colors[CrntSlot] = ColorIn2->Colors[i];\n\t    ColorTransIn2[i] = CrntSlot++;\n\t}\n    }\n\n    if (CrntSlot > 256)\n    {\n\tFreeMapObject(ColorUnion);\n\treturn((ColorMapObject *)NULL);\n    }\n\n    NewBitSize = BitSize(CrntSlot);\n    RoundUpTo = (1 << NewBitSize);\n\n    if (RoundUpTo != ColorUnion->ColorCount)\n    {\n\tregister GifColorType\t*Map = ColorUnion->Colors;\n\n\t/*\n\t * Zero out slots up to next power of 2.\n\t * We know these slots exist because of the way ColorUnion's\n\t * start dimension was computed.\n\t */\n\tfor (j = CrntSlot; j < RoundUpTo; j++)\n\t    Map[j].Red = Map[j].Green = Map[j].Blue = 0;\n\n\t/* perhaps we can shrink the map? */\n\tif (RoundUpTo < ColorUnion->ColorCount)\n\t    ColorUnion->Colors\n\t\t= (GifColorType *)xrealloc(Map, sizeof(GifColorType)*RoundUpTo);\n    }\n\n    ColorUnion->ColorCount = RoundUpTo;\n    ColorUnion->BitsPerPixel = NewBitSize;\n\n    return(ColorUnion);\n}\nvoid ApplyTranslation(SavedImage *Image, GifPixelType Translation[])\n/*\n * Apply a given color translation to the raster bits of an image\n */\n{\n    register int i;\n    register int RasterSize = Image->ImageDesc.Height * Image->ImageDesc.Width;\n\n    for (i = 0; i < RasterSize; i++)\n\tImage->RasterBits[i] = Translation[Image->RasterBits[i]];\n}\n#endif\n\n/******************************************************************************\n* Extension record functions\t\t\t\t\t\t      *\n******************************************************************************/\n\n#if 0 /**** pts ****/\nvoid MakeExtension(SavedImage *New, int Function)\n{\n    New->Function = Function;\n    /*\n     * Someday we might have to deal with multiple extensions.\n     */\n}\n#endif\n\nint CGIFFF AddExtensionBlock(CGIFFF SavedImage *New, int Len, CGIFFF GifByteType ExtData[])\n{\n    ExtensionBlock\t*ep;\n\n    if (New->ExtensionBlocks == NULL)\n\tNew->ExtensionBlocks = (ExtensionBlock *)xmalloc(sizeof(ExtensionBlock));\n    else\n\tNew->ExtensionBlocks =\n\t    (ExtensionBlock *)xrealloc(New->ExtensionBlocks,\n\t\t      sizeof(ExtensionBlock) * (New->ExtensionBlockCount + 1));\n\n    if (New->ExtensionBlocks == NULL)\n\treturn(GIF_ERROR);\n\n    ep = &New->ExtensionBlocks[New->ExtensionBlockCount++];\n\n    ep->Bytes = (GifByteType *)xmalloc(ep->ByteCount = Len);\n\n    if (ExtData)\n\tmemcpy(ep->Bytes, ExtData, Len);\n\n    return(GIF_OK);\n}\n\nvoid CGIFFF FreeExtension(CGIFFF SavedImage *Image)\n{\n    ExtensionBlock\t*ep;\n\n    for (ep = Image->ExtensionBlocks;\n\t ep < Image->ExtensionBlocks + Image->ExtensionBlockCount;\n\t ep++)\n\t(void) free((char *)ep->Bytes);\n    free((char *)Image->ExtensionBlocks);\n    Image->ExtensionBlocks = NULL;\n}\n\n/******************************************************************************\n* Image block allocation functions\t\t\t\t\t      *\n******************************************************************************/\nCGIFFF SavedImage *CGIFFF MakeSavedImage(CGIFFF GifFileType *GifFile, CGIFFF SavedImage *CopyFrom)\n/*\n * Append an image block to the SavedImages array\n */\n{\n    SavedImage\t*sp;\n\n    if (GifFile->SavedImages == NULL)\n\tGifFile->SavedImages = (SavedImage *)xmalloc(sizeof(SavedImage));\n    else\n\tGifFile->SavedImages = (SavedImage *)xrealloc(GifFile->SavedImages,\n\t\t\t\tsizeof(SavedImage) * (GifFile->ImageCount+1));\n\n    {\n\tsp = &GifFile->SavedImages[GifFile->ImageCount++];\n\tmemset((char *)sp, '\\0', sizeof(SavedImage));\n\n\tif (CopyFrom)\n\t{\n\t    memcpy((char *)sp, CopyFrom, sizeof(SavedImage));\n\n\t    /*\n\t     * Make our own allocated copies of the heap fields in the\n\t     * copied record.  This guards against potential aliasing\n\t     * problems.\n\t     */\n\n\t    /* first, the local color map */\n\t    if (sp->ImageDesc.ColorMap)\n\t\tsp->ImageDesc.ColorMap =\n\t\t    MakeMapObject(CopyFrom->ImageDesc.ColorMap->ColorCount,\n\t\t\t\t  CopyFrom->ImageDesc.ColorMap->Colors);\n\n\t    /* next, the raster */\n\t    sp->RasterBits = (GifPixelType *)xmalloc(sizeof(GifPixelType)\n\t\t\t\t* CopyFrom->ImageDesc.Height\n\t\t\t\t* CopyFrom->ImageDesc.Width);\n\t    memcpy(sp->RasterBits,\n\t\t   CopyFrom->RasterBits,\n\t\t   sizeof(GifPixelType)\n\t\t\t* CopyFrom->ImageDesc.Height\n\t\t\t* CopyFrom->ImageDesc.Width);\n\n\t    /* finally, the extension blocks */\n\t    if (sp->ExtensionBlocks)\n\t    {\n\t\tsp->ExtensionBlocks\n\t\t    = (ExtensionBlock*)xmalloc(sizeof(ExtensionBlock)\n\t\t\t\t\t      * CopyFrom->ExtensionBlockCount);\n\t\tmemcpy(sp->ExtensionBlocks,\n\t\t   CopyFrom->ExtensionBlocks,\n\t\t   sizeof(ExtensionBlock)\n\t\t   \t* CopyFrom->ExtensionBlockCount);\n\n\t\t/*\n\t\t * For the moment, the actual blocks can take their\n\t\t * chances with free().  We'll fix this later.\n\t\t */\n\t    }\n\t}\n\n\treturn(sp);\n    }\n}\n\nvoid CGIFFF FreeSavedImages(CGIFFF GifFileType *GifFile)\n{\n    SavedImage\t*sp;\n\n    for (sp = GifFile->SavedImages;\n\t sp < GifFile->SavedImages + GifFile->ImageCount;\n\t sp++)\n    {\n\tif (sp->ImageDesc.ColorMap)\n\t    FreeMapObject(sp->ImageDesc.ColorMap);\n\n\tif (sp->RasterBits)\n\t    free((char *)sp->RasterBits);\n\n\tif (sp->ExtensionBlocks)\n\t    FreeExtension(sp);\n    }\n    free((char *) GifFile->SavedImages);\n}\n\n/* --- dgif_lib.c */\n\n#define GIF_FILE_BUFFER_SIZE 16384  /* Files uses bigger buffers than usual. */\n\n/* #define PROGRAM_NAME\t\"GIFLIB\" */\n\n#define COMMENT_EXT_FUNC_CODE\t0xfe /* Extension function code for comment. */\n#define GIF_STAMP\t\"GIFVER\"\t /* First chars in file - GIF stamp. */\n#define GIF_STAMP_LEN\tsizeof(GIF_STAMP) - 1\n#define GIF_VERSION_POS\t3\t\t/* Version first character in stamp. */\n\n#define LZ_MAX_CODE\t4095\t\t/* Biggest code possible in 12 bits. */\n#define LZ_BITS\t\t12\n\n#define FILE_STATE_READ\t\t0x01/* 1 write, 0 read - EGIF_LIB compatible.*/\n\n#define FLUSH_OUTPUT\t\t4096    /* Impossible code, to signal flush. */\n#define FIRST_CODE\t\t4097    /* Impossible code, to signal first. */\n#define NO_SUCH_CODE\t\t4098    /* Impossible code, to signal empty. */\n\n#define IS_READABLE(Private)\t(!(Private->FileState & FILE_STATE_READ))\n\ntypedef struct GifFilePrivateType {\n    int FileState,\n\t/*FileHandle,*/\t\t\t     /* Where all this data goes to! */\n\tBitsPerPixel,\t    /* Bits per pixel (Codes uses at list this + 1). */\n\tClearCode,\t\t\t\t       /* The CLEAR LZ code. */\n\tEOFCode,\t\t\t\t         /* The EOF LZ code. */\n\tRunningCode,\t\t    /* The next code algorithm can generate. */\n\tRunningBits,/* The number of bits required to represent RunningCode. */\n\tMaxCode1,  /* 1 bigger than max. possible code, in RunningBits bits. */\n\tLastCode,\t\t        /* The code before the current code. */\n\tCrntCode,\t\t\t\t  /* Current algorithm code. */\n\tStackPtr,\t\t         /* For character stack (see below). */\n\tCrntShiftState;\t\t        /* Number of bits in CrntShiftDWord. */\n    unsigned long CrntShiftDWord;     /* For bytes decomposition into codes. */\n    unsigned long PixelCount;\t\t       /* Number of pixels in image. */\n    FILE *File;\t\t\t\t\t\t  /* File as stream. */\n    CGIFFF GifByteType Buf[256];\t       /* Compressed input is buffered here. */\n    CGIFFF GifByteType Stack[LZ_MAX_CODE];\t /* Decoded pixels are stacked here. */\n    CGIFFF GifByteType Suffix[LZ_MAX_CODE+1];\t       /* So we can trace the codes. */\n    unsigned int Prefix[LZ_MAX_CODE+1];\n} GifFilePrivateType;\n\n/* extern int _GifError; */\n\nstatic int DGifGetWord(FILE *File, int *Word);\nstatic int DGifSetupDecompress(CGIFFF GifFileType *GifFile);\nstatic int DGifDecompressLine(CGIFFF GifFileType *GifFile, CGIFFF GifPixelType *Line,\n\t\t\t\t\t\t\t\tint LineLen);\nstatic int DGifGetPrefixChar(unsigned int *Prefix, int Code, int ClearCode);\nstatic int DGifDecompressInput(GifFilePrivateType *Private, int *Code);\nstatic int DGifBufferedInput(FILE *File, CGIFFF GifByteType *Buf,\n\t\t\t\t\t\t     CGIFFF GifByteType *NextByte);\n\n/******************************************************************************\n*   Open a new gif file for read, given by its name.\t\t\t      *\n*   Returns GifFileType pointer dynamically allocated which serves as the gif *\n* info record. _GifError is cleared if succesfull.\t\t\t      *\n******************************************************************************/\nCGIFFF GifFileType *CGIFFF DGifOpenFileName(const char *FileName) {\n#if 0 /**** pts ****/\nCGIFFF GifFileType *CGIFFF DGifOpenFileName(const char *FileName)\n{\n    int FileHandle;\n\n    if ((FileHandle = open(FileName, O_RDONLY\n#ifdef __MSDOS__\n\t\t\t           | O_BINARY\n#endif /* __MSDOS__ */\n\t\t\t                     )) == -1) {\n\t_GifError = D_GIF_ERR_OPEN_FAILED;\n\treturn NULL;\n    }\n\n    return DGifOpenFileHandle(FileHandle);\n#else\n  FILE *f;\n  if (NULL==(f=fopen(FileName,\"rb\"))) { _GifError=D_GIF_ERR_OPEN_FAILED; return NULL; }\n  return DGifOpenFILE(f);\n#endif\n}\n\n#if USE_CGIF_FDOPEN\n\n/******************************************************************************\n*   Update a new gif file, given its file handle.\t\t\t      *\n*   Returns GifFileType pointer dynamically allocated which serves as the gif *\n* info record. _GifError is cleared if succesfull.\t\t\t      *\n******************************************************************************/\nCGIFFF GifFileType *CGIFFF DGifOpenFileHandle(int FileHandle)\n{\n    FILE *f;\n\n#ifdef __MSDOS__\n    setmode(FileHandle, O_BINARY);\t  /* Make sure it is in binary mode. */\n    f = fdopen(FileHandle, \"rb\");\t\t   /* Make it into a stream: */\n    setvbuf(f, NULL, _IOFBF, GIF_FILE_BUFFER_SIZE);/* And inc. stream buffer.*/\n#else\n    f = fdopen(FileHandle, \"rb\");\t\t   /* Make it into a stream: */\n#endif /* __MSDOS__ */\n    return DGifOpenFILE(f);\n}\n#endif\n\n/**** pts ****/\nCGIFFF GifFileType *CGIFFF DGifOpenFILE(void/*FILE*/ *f) {\n    char Buf[GIF_STAMP_LEN+1];\n    GifFileType *GifFile;\n    GifFilePrivateType *Private;\n    GifFile = (GifFileType *) xmalloc(sizeof(GifFileType));\n\n    memset(GifFile, '\\0', sizeof(GifFileType));\n\n    Private = (GifFilePrivateType *) xmalloc(sizeof(GifFilePrivateType));\n    GifFile->Private = (VoidPtr) Private;\n    /* Private->FileHandle = FileHandle; */\n    Private->File = (FILE*)f;\n    Private->FileState = 0;   /* Make sure bit 0 = 0 (File open for read). */\n\n    /* Let's see if this is a GIF file: */\n    if (fread(Buf, 1, GIF_STAMP_LEN, Private->File) != GIF_STAMP_LEN) {\n\t_GifError = D_GIF_ERR_READ_FAILED;\n\tfree((char *) Private);\n\tfree((char *) GifFile);\n\treturn NULL;\n    }\n\n    /* The GIF Version number is ignored at this time. Maybe we should do    */\n    /* something more useful with it.\t\t\t\t\t     */\n    Buf[GIF_STAMP_LEN] = 0;\n    if (strncmp(GIF_STAMP, Buf, GIF_VERSION_POS) != 0) {\n\t_GifError = D_GIF_ERR_NOT_GIF_FILE;\n\tfree((char *) Private);\n\tfree((char *) GifFile);\n\treturn NULL;\n    }\n\n    if (DGifGetScreenDesc(GifFile) == GIF_ERROR) {\n\tfree((char *) Private);\n\tfree((char *) GifFile);\n\treturn NULL;\n    }\n\n    _GifError = 0;\n\n    return GifFile;\n}\n\n/******************************************************************************\n*   This routine should be called before any other DGif calls. Note that      *\n* this routine is called automatically from DGif file open routines.\t      *\n******************************************************************************/\nint CGIFFF DGifGetScreenDesc(CGIFFF GifFileType *GifFile)\n{\n    int i, BitsPerPixel;\n    GifByteType Buf[3];\n    GifFilePrivateType *Private = (GifFilePrivateType *) GifFile->Private;\n\n    if (!IS_READABLE(Private)) {\n\t/* This file was NOT open for reading: */\n\t_GifError = D_GIF_ERR_NOT_READABLE;\n\treturn GIF_ERROR;\n    }\n\n    /* Put the screen descriptor into the file: */\n    if (DGifGetWord(Private->File, &GifFile->SWidth) == GIF_ERROR ||\n\tDGifGetWord(Private->File, &GifFile->SHeight) == GIF_ERROR)\n\treturn GIF_ERROR;\n\n    if (fread(Buf, 1, 3, Private->File) != 3) {\n\t_GifError = D_GIF_ERR_READ_FAILED;\n\treturn GIF_ERROR;\n    }\n    GifFile->SColorResolution = (((Buf[0] & 0x70) + 1) >> 4) + 1;\n    BitsPerPixel = (Buf[0] & 0x07) + 1;\n    GifFile->SBackGroundColor = Buf[1];\n    // fprintf(stderr, \"colres=%d bpp=%d bgcol=%d\\n\", GifFile->SColorResolution, BitsPerPixel, GifFile->SBackGroundColor);\n    if (Buf[0] & 0x80) {\t\t     /* Do we have global color map? */\n        // fprintf(stderr, \"have gcolormap\\n\");\n\tGifFile->SColorMap = MakeMapObject(1 << BitsPerPixel, NULL);\n\n\t/* Get the global color map: */\n\tfor (i = 0; i < GifFile->SColorMap->ColorCount; i++) {\n\t    if (fread(Buf, 1, 3, Private->File) != 3) {\n\t\t_GifError = D_GIF_ERR_READ_FAILED;\n\t\treturn GIF_ERROR;\n\t    }\n\t    GifFile->SColorMap->Colors[i].Red = Buf[0];\n\t    GifFile->SColorMap->Colors[i].Green = Buf[1];\n\t    GifFile->SColorMap->Colors[i].Blue = Buf[2];\n\t}\n    }\n\n    return GIF_OK;\n}\n\n/******************************************************************************\n*   This routine should be called before any attemp to read an image.         *\n******************************************************************************/\nint CGIFFF DGifGetRecordType(CGIFFF GifFileType *GifFile, CGIFFF GifRecordType *Type)\n{\n    GifByteType Buf;\n    GifFilePrivateType *Private = (GifFilePrivateType *) GifFile->Private;\n\n    if (!IS_READABLE(Private)) {\n\t/* This file was NOT open for reading: */\n\t_GifError = D_GIF_ERR_NOT_READABLE;\n\treturn GIF_ERROR;\n    }\n\n    if (fread(&Buf, 1, 1, Private->File) != 1) {\n\t_GifError = D_GIF_ERR_READ_FAILED;\n\treturn GIF_ERROR;\n    }\n\n    // fprintf(stderr, \"record %d at offset %ld\\n\", Buf&255, ftell(Private->File));\n    switch (Buf) {\n\tcase ',': *Type = IMAGE_DESC_RECORD_TYPE; break;\n\tcase '!': *Type = EXTENSION_RECORD_TYPE;  break;\n\tcase ';': *Type = TERMINATE_RECORD_TYPE;  break;\n\tdefault:  *Type = UNDEFINED_RECORD_TYPE;\n\t    // fprintf(stderr, \"wrong record %d at offset %ld\\n\", Buf&255, ftell(Private->File));\n\t    _GifError = D_GIF_ERR_WRONG_RECORD;\n\t    return GIF_ERROR;\n    }\n\n    return GIF_OK;\n}\n\n/******************************************************************************\n*   This routine should be called before any attemp to read an image.         *\n*   Note it is assumed the Image desc. header (',') has been read.\t      *\n******************************************************************************/\nint CGIFFF DGifGetImageDesc(CGIFFF GifFileType *GifFile)\n{\n    int i, BitsPerPixel;\n    GifByteType Buf[3];\n    GifImageDesc Image;\n    GifFilePrivateType *Private = (GifFilePrivateType *) GifFile->Private;\n    memset(&Image, 0, sizeof(Image));\n\n    if (!IS_READABLE(Private)) {\n\t/* This file was NOT open for reading: */\n\t_GifError = D_GIF_ERR_NOT_READABLE;\n\treturn GIF_ERROR;\n    }\n\n    if (DGifGetWord(Private->File, &Image.Left) == GIF_ERROR ||\n\tDGifGetWord(Private->File, &Image.Top) == GIF_ERROR ||\n\tDGifGetWord(Private->File, &Image.Width) == GIF_ERROR ||\n\tDGifGetWord(Private->File, &Image.Height) == GIF_ERROR)\n\treturn GIF_ERROR;\n    if (fread(Buf, 1, 1, Private->File) != 1) {\n\t_GifError = D_GIF_ERR_READ_FAILED;\n\treturn GIF_ERROR;\n    }\n    BitsPerPixel = (Buf[0] & 0x07) + 1;\n    Image.Interlace = (Buf[0] & 0x40);\n    if (Buf[0] & 0x80) {\t    /* Does this image have local color map? */\n\n\tif (Image.ColorMap && GifFile->SavedImages == NULL)\n\t    FreeMapObject(Image.ColorMap);\n\n\tImage.ColorMap = MakeMapObject(1 << BitsPerPixel, NULL);\n\n\t/* Get the image local color map: */\n\tfor (i = 0; i < Image.ColorMap->ColorCount; i++) {\n\t    if (fread(Buf, 1, 3, Private->File) != 3) {\n\t\t_GifError = D_GIF_ERR_READ_FAILED;\n\t\treturn GIF_ERROR;\n\t    }\n\t    Image.ColorMap->Colors[i].Red = Buf[0];\n\t    Image.ColorMap->Colors[i].Green = Buf[1];\n\t    Image.ColorMap->Colors[i].Blue = Buf[2];\n\t}\n    }\n\n    /**** pts ****/\n    if (NULL!=GifFile->SavedImages) {\n      GifFile->SavedImages = (SavedImage *)xrealloc(GifFile->SavedImages,\n\t\t    sizeof(SavedImage) * (GifFile->ImageCount + 1));\n    } else {\n      assert(GifFile->ImageCount==0);\n      GifFile->SavedImages = (SavedImage *)xmalloc(sizeof(SavedImage));\n    }\n\n    {\n\tSavedImage\t*sp;\n\tsp = &GifFile->SavedImages[GifFile->ImageCount];\n\tmemcpy(&sp->ImageDesc, &Image, sizeof(GifImageDesc));\n\tsp->RasterBits = (GifPixelType *)NULL;\n\tsp->ExtensionBlockCount = 0;\n\tsp->ExtensionBlocks = (ExtensionBlock *)NULL;\n        sp->delay=0;\n        sp->dispose=0;\n        sp->iter=1;\n        sp->transp=(-1);\n    }\n\n    GifFile->ImageCount++;\n\n    Private->PixelCount = (long) Image.Width *\n\t\t\t    (long) Image.Height;\n\n    /* Reset decompress algorithm parameters. */\n    if (DGifSetupDecompress(GifFile)==GIF_ERROR) {\n      _GifError = D_GIF_ERR_READ_FAILED;\n      return GIF_ERROR;\n    }\n\n    return GIF_OK;\n}\n\n/******************************************************************************\n*  Get one full scanned line (Line) of length LineLen from GIF file.\t      *\n******************************************************************************/\nint CGIFFF DGifGetLine(CGIFFF GifFileType *GifFile, CGIFFF GifPixelType *Line, int LineLen)\n{\n    GifByteType *Dummy;\n    GifFilePrivateType *Private = (GifFilePrivateType *) GifFile->Private;\n\n    if (!IS_READABLE(Private)) {\n\t/* This file was NOT open for reading: */\n\t_GifError = D_GIF_ERR_NOT_READABLE;\n\treturn GIF_ERROR;\n    }\n\n    /**** pts ****/\n    /* if (!LineLen) LineLen = GifFile->Image.Width; */\n\n#if defined(__MSDOS__) || defined(__GNUC__)\n    if ((Private->PixelCount -= LineLen) > 0xffff0000UL) {\n#else\n    if ((Private->PixelCount -= LineLen) > 0xffff0000) {\n#endif /* __MSDOS__ */\n\t_GifError = D_GIF_ERR_DATA_TOO_BIG;\n\treturn GIF_ERROR;\n    }\n\n    if (DGifDecompressLine(GifFile, Line, LineLen) == GIF_OK) {\n\tif (Private->PixelCount == 0) {\n\t    /* We probably would not be called any more, so lets clean \t     */\n\t    /* everything before we return: need to flush out all rest of    */\n\t    /* image until empty block (size 0) detected. We use GetCodeNext.*/\n\t    do if (DGifGetCodeNext(GifFile, &Dummy) == GIF_ERROR)\n\t\treturn GIF_ERROR;\n\t    while (Dummy != NULL);\n\t}\n\treturn GIF_OK;\n    }\n    else\n\treturn GIF_ERROR;\n}\n\n/******************************************************************************\n* Put one pixel (Pixel) into GIF file.\t\t\t\t\t      *\n******************************************************************************/\nint CGIFFF DGifGetPixel(CGIFFF GifFileType *GifFile, CGIFFF GifPixelType Pixel)\n{\n    GifByteType *Dummy;\n    GifFilePrivateType *Private = (GifFilePrivateType *) GifFile->Private;\n\n    if (!IS_READABLE(Private)) {\n\t/* This file was NOT open for reading: */\n\t_GifError = D_GIF_ERR_NOT_READABLE;\n\treturn GIF_ERROR;\n    }\n\n#if defined(__MSDOS__) || defined(__GNUC__)\n    if (--Private->PixelCount > 0xffff0000UL)\n#else\n    if (--Private->PixelCount > 0xffff0000)\n#endif /* __MSDOS__ */\n    {\n\t_GifError = D_GIF_ERR_DATA_TOO_BIG;\n\treturn GIF_ERROR;\n    }\n\n    if (DGifDecompressLine(GifFile, &Pixel, 1) == GIF_OK) {\n\tif (Private->PixelCount == 0) {\n\t    /* We probably would not be called any more, so lets clean \t     */\n\t    /* everything before we return: need to flush out all rest of    */\n\t    /* image until empty block (size 0) detected. We use GetCodeNext.*/\n\t    do if (DGifGetCodeNext(GifFile, &Dummy) == GIF_ERROR)\n\t\treturn GIF_ERROR;\n\t    while (Dummy != NULL);\n\t}\n\treturn GIF_OK;\n    }\n    else\n\treturn GIF_ERROR;\n}\n\n/******************************************************************************\n*   Get an extension block (see GIF manual) from gif file. This routine only  *\n* returns the first data block, and DGifGetExtensionNext shouldbe called      *\n* after this one until NULL extension is returned.\t\t\t      *\n*   The Extension should NOT be freed by the user (not dynamically allocated).*\n*   Note it is assumed the Extension desc. header ('!') has been read.\t      *\n******************************************************************************/\nint CGIFFF DGifGetExtension(CGIFFF GifFileType *GifFile, int *ExtCode,\n\t\t\t\t\t\t    CGIFFF GifByteType **Extension)\n{\n    GifByteType Buf;\n    GifFilePrivateType *Private = (GifFilePrivateType *) GifFile->Private;\n\n\n    if (!IS_READABLE(Private)) {\n\t/* This file was NOT open for reading: */\n\t_GifError = D_GIF_ERR_NOT_READABLE;\n\treturn GIF_ERROR;\n    }\n\n    if (fread(&Buf, 1, 1, Private->File) != 1) {\n\t_GifError = D_GIF_ERR_READ_FAILED;\n\treturn GIF_ERROR;\n    }\n    *ExtCode = Buf;\n\n    return DGifGetExtensionNext(GifFile, Extension);\n}\n\n/******************************************************************************\n*   Get a following extension block (see GIF manual) from gif file. This      *\n* routine sould be called until NULL Extension is returned.\t\t      *\n*   The Extension should NOT be freed by the user (not dynamically allocated).*\n******************************************************************************/\nint CGIFFF DGifGetExtensionNext(CGIFFF GifFileType *GifFile, CGIFFF GifByteType **Extension)\n{\n    GifByteType Buf;\n    GifFilePrivateType *Private = (GifFilePrivateType *) GifFile->Private;\n\n    if (fread(&Buf, 1, 1, Private->File) != 1) {\n\t_GifError = D_GIF_ERR_READ_FAILED;\n\treturn GIF_ERROR;\n    }\n    if (Buf > 0) {\n\t*Extension = Private->Buf;           /* Use private unused buffer. */\n\t(*Extension)[0] = Buf;  /* Pascal strings notation (pos. 0 is len.). */\n\tif (fread(&((*Extension)[1]), 1, Buf, Private->File) != Buf) {\n\t    _GifError = D_GIF_ERR_READ_FAILED;\n\t    return GIF_ERROR;\n\t}\n    }\n    else\n\t*Extension = NULL;\n\n    return GIF_OK;\n}\n\n/******************************************************************************\n*   This routine should be called last, to close the GIF file.\t\t      *\n******************************************************************************/\nint CGIFFF DGifCloseFile(CGIFFF GifFileType *GifFile)\n{\n    GifFilePrivateType *Private;\n\n    if (GifFile == NULL) return GIF_ERROR;\n\n    Private = (GifFilePrivateType *) GifFile->Private;\n\n    if (!IS_READABLE(Private)) {\n\t/* This file was NOT open for reading: */\n\t_GifError = D_GIF_ERR_NOT_READABLE;\n\treturn GIF_ERROR;\n    }\n\n    #if 0 /**** pts ****/\n    if (GifFile->Image.ColorMap)\n\tFreeMapObject(GifFile->Image.ColorMap);\n    #endif\n    if (GifFile->SColorMap)\n\tFreeMapObject(GifFile->SColorMap);\n    if (Private)\n\tfree((char *) Private);\n    if (GifFile->SavedImages)\n\tFreeSavedImages(GifFile);\n    free(GifFile);\n\n#if 0 /**** pts ****/\n    if (fclose(File) != 0) {\n\t_GifError = D_GIF_ERR_CLOSE_FAILED;\n\treturn GIF_ERROR;\n    }\n#endif\n    return GIF_OK;\n}\n\n/******************************************************************************\n*   Get 2 bytes (word) from the given file:\t\t\t\t      *\n******************************************************************************/\nstatic int DGifGetWord(FILE *File, int *Word)\n{\n    unsigned char c[2];\n\n    if (fread(c, 1, 2, File) != 2) {\n\tCGIFFF _GifError = D_GIF_ERR_READ_FAILED;\n\treturn GIF_ERROR;\n    }\n\n    *Word = (((unsigned int) c[1]) << 8) + c[0];\n    return GIF_OK;\n}\n\n/******************************************************************************\n*   Get the image code in compressed form.  his routine can be called if the  *\n* information needed to be piped out as is. Obviously this is much faster     *\n* than decoding and encoding again. This routine should be followed by calls  *\n* to DGifGetCodeNext, until NULL block is returned.\t\t\t      *\n*   The block should NOT be freed by the user (not dynamically allocated).    *\n******************************************************************************/\nint CGIFFF DGifGetCode(CGIFFF GifFileType *GifFile, int *CodeSize, CGIFFF GifByteType **CodeBlock)\n{\n    GifFilePrivateType *Private = (GifFilePrivateType *) GifFile->Private;\n\n    if (!IS_READABLE(Private)) {\n\t/* This file was NOT open for reading: */\n\t_GifError = D_GIF_ERR_NOT_READABLE;\n\treturn GIF_ERROR;\n    }\n\n    *CodeSize = Private->BitsPerPixel;\n\n    return DGifGetCodeNext(GifFile, CodeBlock);\n}\n\n/******************************************************************************\n*   Continue to get the image code in compressed form. This routine should be *\n* called until NULL block is returned.\t\t\t\t\t      *\n*   The block should NOT be freed by the user (not dynamically allocated).    *\n******************************************************************************/\nint CGIFFF DGifGetCodeNext(CGIFFF GifFileType *GifFile, CGIFFF GifByteType **CodeBlock)\n{\n    GifByteType Buf;\n    GifFilePrivateType *Private = (GifFilePrivateType *) GifFile->Private;\n\n    if (fread(&Buf, 1, 1, Private->File) != 1) {\n\t_GifError = D_GIF_ERR_READ_FAILED;\n\treturn GIF_ERROR;\n    }\n\n    if (Buf > 0) {\n\t*CodeBlock = Private->Buf;\t       /* Use private unused buffer. */\n\t(*CodeBlock)[0] = Buf;  /* Pascal strings notation (pos. 0 is len.). */\n\tif (fread(&((*CodeBlock)[1]), 1, Buf, Private->File) != Buf) {\n\t    _GifError = D_GIF_ERR_READ_FAILED;\n\t    return GIF_ERROR;\n\t}\n    }\n    else {\n\t*CodeBlock = NULL;\n\tPrivate->Buf[0] = 0;\t\t   /* Make sure the buffer is empty! */\n\tPrivate->PixelCount = 0;   /* And local info. indicate image read. */\n    }\n\n    return GIF_OK;\n}\n\n/******************************************************************************\n*   Setup the LZ decompression for this image:\t\t\t\t      *\n******************************************************************************/\nstatic int DGifSetupDecompress(CGIFFF GifFileType *GifFile)\n{\n    int i, BitsPerPixel;\n    CGIFFF GifByteType CodeSize;\n    unsigned int *Prefix;\n    GifFilePrivateType *Private = (GifFilePrivateType *) GifFile->Private;\n\n    if (fread(&CodeSize, 1, 1, Private->File) != 1)  /* Read Code size from file. */\n      return GIF_ERROR;\n    BitsPerPixel = CodeSize;\n\n    Private->Buf[0] = 0;\t\t\t      /* Input Buffer empty. */\n    Private->BitsPerPixel = BitsPerPixel;\n    Private->ClearCode = (1 << BitsPerPixel);\n    Private->EOFCode = Private->ClearCode + 1;\n    Private->RunningCode = Private->EOFCode + 1;\n    Private->RunningBits = BitsPerPixel + 1;\t /* Number of bits per code. */\n    Private->MaxCode1 = 1 << Private->RunningBits;     /* Max. code + 1. */\n    Private->StackPtr = 0;\t\t    /* No pixels on the pixel stack. */\n    Private->LastCode = NO_SUCH_CODE;\n    Private->CrntShiftState = 0;\t/* No information in CrntShiftDWord. */\n    Private->CrntShiftDWord = 0;\n\n    Prefix = Private->Prefix;\n    for (i = 0; i <= LZ_MAX_CODE; i++) Prefix[i] = NO_SUCH_CODE;\n\n    return GIF_OK;\n}\n\n/******************************************************************************\n*   The LZ decompression routine:\t\t\t\t\t      *\n*   This version decompress the given gif file into Line of length LineLen.   *\n*   This routine can be called few times (one per scan line, for example), in *\n* order the complete the whole image.\t\t\t\t\t      *\n******************************************************************************/\nstatic int DGifDecompressLine(CGIFFF GifFileType *GifFile, CGIFFF GifPixelType *Line,\n\t\t\t\t\t\t\t\tint LineLen)\n{\n    int i = 0, j, CrntCode, EOFCode, ClearCode, CrntPrefix, LastCode, StackPtr;\n    CGIFFF GifByteType *Stack, *Suffix;\n    unsigned int *Prefix;\n    GifFilePrivateType *Private = (GifFilePrivateType *) GifFile->Private;\n\n    StackPtr = Private->StackPtr;\n    Prefix = Private->Prefix;\n    Suffix = Private->Suffix;\n    Stack = Private->Stack;\n    EOFCode = Private->EOFCode;\n    ClearCode = Private->ClearCode;\n    LastCode = Private->LastCode;\n\n    if (StackPtr != 0) {\n\t/* Let pop the stack off before continueing to read the gif file: */\n\twhile (StackPtr != 0 && i < LineLen) Line[i++] = Stack[--StackPtr];\n    }\n\n    while (i < LineLen) {\t\t\t    /* Decode LineLen items. */\n\tif (DGifDecompressInput(Private, &CrntCode) == GIF_ERROR)\n    \t    return GIF_ERROR;\n\n        /*fprintf(stderr,\"CrntCode=0x%x\\n\",CrntCode);*/\n\tif (CrntCode == EOFCode) {\n\t    /* Note however that usually we will not be here as we will stop */\n\t    /* decoding as soon as we got all the pixel, or EOF code will    */\n\t    /* not be read at all, and DGifGetLine/Pixel clean everything.   */\n\t    if (i != LineLen - 1 || Private->PixelCount != 0) {\n\t\tCGIFFF _GifError = D_GIF_ERR_EOF_TOO_SOON;\n\t\treturn GIF_ERROR;\n\t    }\n\t    i++;\n\t}\n\telse if (CrntCode == ClearCode) {\n\t    /* We need to start over again: */\n\t    for (j = 0; j <= LZ_MAX_CODE; j++) Prefix[j] = NO_SUCH_CODE;\n\t    Private->RunningCode = Private->EOFCode + 1;\n\t    Private->RunningBits = Private->BitsPerPixel + 1;\n\t    Private->MaxCode1 = 1 << Private->RunningBits;\n\t    LastCode = Private->LastCode = NO_SUCH_CODE;\n\t}\n\telse {\n\t    /* Its regular code - if in pixel range simply add it to output  */\n\t    /* stream, otherwise trace to codes linked list until the prefix */\n\t    /* is in pixel range:\t\t\t\t\t     */\n\t    if (CrntCode < ClearCode) {\n\t\t/* This is simple - its pixel scalar, so add it to output:   */\n\t\tLine[i++] = CrntCode;\n\t    }\n\t    else {\n\t\t/* Its a code to needed to be traced: trace the linked list  */\n\t\t/* until the prefix is a pixel, while pushing the suffix     */\n\t\t/* pixels on our stack. If we done, pop the stack in reverse */\n\t\t/* (thats what stack is good for!) order to output.\t     */\n\t\tif (Prefix[CrntCode] == NO_SUCH_CODE) {\n\t\t    /* Only allowed if CrntCode is exactly the running code: */\n\t\t    /* In that case CrntCode = XXXCode, CrntCode or the\t     */\n\t\t    /* prefix code is last code and the suffix char is\t     */\n\t\t    /* exactly the prefix of last code!\t\t\t     */\n\t\t    if (CrntCode == Private->RunningCode - 2) {\n\t\t\tCrntPrefix = LastCode;\n\t\t\tSuffix[Private->RunningCode - 2] =\n\t\t\tStack[StackPtr++] = DGifGetPrefixChar(Prefix,\n\t\t\t\t\t\t\tLastCode, ClearCode);\n\t\t    }\n\t\t    else {\n\t\t\tCGIFFF _GifError = D_GIF_ERR_IMAGE_DEFECT;\n\t\t\treturn GIF_ERROR;\n\t\t    }\n\t\t}\n\t\telse\n\t\t    CrntPrefix = CrntCode;\n\n\t\t/* Now (if image is O.K.) we should not get an NO_SUCH_CODE  */\n\t\t/* During the trace. As we might loop forever, in case of    */\n\t\t/* defective image, we count the number of loops we trace    */\n\t\t/* and stop if we got LZ_MAX_CODE. obviously we can not      */\n\t\t/* loop more than that.\t\t\t\t\t     */\n\t\tj = 0;\n\t\twhile (j++ <= LZ_MAX_CODE &&\n\t\t       CrntPrefix > ClearCode &&\n\t\t       CrntPrefix <= LZ_MAX_CODE) {\n\t\t    Stack[StackPtr++] = Suffix[CrntPrefix];\n\t\t    CrntPrefix = Prefix[CrntPrefix];\n\t\t}\n\t\tif (j >= LZ_MAX_CODE || CrntPrefix > LZ_MAX_CODE) {\n\t\t    CGIFFF _GifError = D_GIF_ERR_IMAGE_DEFECT;\n\t\t    return GIF_ERROR;\n\t\t}\n\t\t/* Push the last character on stack: */\n\t\tStack[StackPtr++] = CrntPrefix;\n\n\t\t/* Now lets pop all the stack into output: */\n\t\twhile (StackPtr != 0 && i < LineLen)\n\t\t    Line[i++] = Stack[--StackPtr];\n\t    }\n\t    if (LastCode != NO_SUCH_CODE) {\n\t\tPrefix[Private->RunningCode - 2] = LastCode;\n\n\t\tif (CrntCode == Private->RunningCode - 2) {\n\t\t    /* Only allowed if CrntCode is exactly the running code: */\n\t\t    /* In that case CrntCode = XXXCode, CrntCode or the\t     */\n\t\t    /* prefix code is last code and the suffix char is\t     */\n\t\t    /* exactly the prefix of last code!\t\t\t     */\n\t\t    Suffix[Private->RunningCode - 2] =\n\t\t\tDGifGetPrefixChar(Prefix, LastCode, ClearCode);\n\t\t}\n\t\telse {\n\t\t    Suffix[Private->RunningCode - 2] =\n\t\t\tDGifGetPrefixChar(Prefix, CrntCode, ClearCode);\n\t\t}\n\t    }\n\t    LastCode = CrntCode;\n\t}\n    }\n\n    Private->LastCode = LastCode;\n    Private->StackPtr = StackPtr;\n\n    return GIF_OK;\n}\n\n/******************************************************************************\n* Routine to trace the Prefixes linked list until we get a prefix which is    *\n* not code, but a pixel value (less than ClearCode). Returns that pixel value.*\n* If image is defective, we might loop here forever, so we limit the loops to *\n* the maximum possible if image O.k. - LZ_MAX_CODE times.\t\t      *\n******************************************************************************/\nstatic int DGifGetPrefixChar(unsigned int *Prefix, int Code, int ClearCode)\n{\n    int i = 0;\n\n    while (Code > ClearCode && i++ <= LZ_MAX_CODE) Code = Prefix[Code];\n    return Code;\n}\n\n/******************************************************************************\n*   Interface for accessing the LZ codes directly. Set Code to the real code  *\n* (12bits), or to -1 if EOF code is returned.\t\t\t\t      *\n******************************************************************************/\nint CGIFFF DGifGetLZCodes(CGIFFF GifFileType *GifFile, int *Code)\n{\n    GifByteType *CodeBlock;\n    GifFilePrivateType *Private = (GifFilePrivateType *) GifFile->Private;\n\n    if (!IS_READABLE(Private)) {\n\t/* This file was NOT open for reading: */\n\t_GifError = D_GIF_ERR_NOT_READABLE;\n\treturn GIF_ERROR;\n    }\n\n    if (DGifDecompressInput(Private, Code) == GIF_ERROR)\n\treturn GIF_ERROR;\n\n    if (*Code == Private->EOFCode) {\n\t/* Skip rest of codes (hopefully only NULL terminating block): */\n\tdo if (DGifGetCodeNext(GifFile, &CodeBlock) == GIF_ERROR)\n    \t    return GIF_ERROR;\n\twhile (CodeBlock != NULL);\n\n\t*Code = -1;\n    }\n    else if (*Code == Private->ClearCode) {\n\t/* We need to start over again: */\n\tPrivate->RunningCode = Private->EOFCode + 1;\n\tPrivate->RunningBits = Private->BitsPerPixel + 1;\n\tPrivate->MaxCode1 = 1 << Private->RunningBits;\n    }\n\n    return GIF_OK;\n}\n\n/******************************************************************************\n*   The LZ decompression input routine:\t\t\t\t\t      *\n*   This routine is responsable for the decompression of the bit stream from  *\n* 8 bits (bytes) packets, into the real codes.\t\t\t\t      *\n*   Returns GIF_OK if read succesfully.\t\t\t\t\t      *\n******************************************************************************/\nstatic int DGifDecompressInput(GifFilePrivateType *Private, int *Code)\n{\n    CGIFFF GifByteType NextByte;\n    static unsigned int CodeMasks[] = {\n\t0x0000, 0x0001, 0x0003, 0x0007,\n\t0x000f, 0x001f, 0x003f, 0x007f,\n\t0x00ff, 0x01ff, 0x03ff, 0x07ff,\n\t0x0fff\n    };\n\n    /* The image can't contain more than LZ_BITS per code. */\n    if (Private->RunningBits > LZ_BITS) {\n        return GIF_ERROR;\n    }\n    \n\n    while (Private->CrntShiftState < Private->RunningBits) {\n\t/* Needs to get more bytes from input stream for next code: */\n\tif (DGifBufferedInput(Private->File, Private->Buf, &NextByte)\n\t    == GIF_ERROR) {\n\t    return GIF_ERROR;\n\t}\n\tPrivate->CrntShiftDWord |=\n\t\t((unsigned long) NextByte) << Private->CrntShiftState;\n\tPrivate->CrntShiftState += 8;\n    }\n    *Code = Private->CrntShiftDWord & CodeMasks[Private->RunningBits];\n\n    Private->CrntShiftDWord >>= Private->RunningBits;\n    Private->CrntShiftState -= Private->RunningBits;\n\n    /* If code cannt fit into RunningBits bits, must raise its size. Note  */\n    /* however that codes above 4095 are used for special signaling.       */\n    /* If we're using LZ_BITS bits already and we're at the max code, just */\n    /* keep using the table as it is, don't increment Private->RunningCode.*/ \n    if (Private->RunningCode < LZ_MAX_CODE + 2 &&\n\t++Private->RunningCode > Private->MaxCode1 &&\n\tPrivate->RunningBits < LZ_BITS) {\n\tPrivate->MaxCode1 <<= 1;\n\tPrivate->RunningBits++;\n    }\n    return GIF_OK;\n}\n\n/******************************************************************************\n*   This routines read one gif data block at a time and buffers it internally *\n* so that the decompression routine could access it.\t\t\t      *\n*   The routine returns the next byte from its internal buffer (or read next  *\n* block in if buffer empty) and returns GIF_OK if succesful.\t\t      *\n******************************************************************************/\nstatic int DGifBufferedInput(FILE *File, CGIFFF GifByteType *Buf,\n\t\t\t\t\t\t      CGIFFF GifByteType *NextByte)\n{\n    if (Buf[0] == 0) {\n\t/* Needs to read the next buffer - this one is empty: */\n\tif (fread(Buf, 1, 1, File) != 1)\n\t{\n\t    CGIFFF _GifError = D_GIF_ERR_READ_FAILED;\n\t    return GIF_ERROR;\n\t}\n\tif (fread(&Buf[1], 1, Buf[0], File) != Buf[0])\n\t{\n\t    CGIFFF _GifError = D_GIF_ERR_READ_FAILED;\n\t    return GIF_ERROR;\n\t}\n\t*NextByte = Buf[1];\n\tBuf[1] = 2;\t   /* We use now the second place as last char read! */\n\tBuf[0]--;\n    }\n    else {\n\t*NextByte = Buf[Buf[1]++];\n\tBuf[0]--;\n    }\n\n    return GIF_OK;\n}\n\n/******************************************************************************\n* This routine reads an entire GIF into core, hanging all its state info off  *\n* the GifFileType pointer.  Call DGifOpenFileName() or DGifOpenFileHandle()   *\n* first to initialize I/O.  Its inverse is EGifSpew().\t\t\t      *\n******************************************************************************/\nint CGIFFF DGifSlurp(CGIFFF GifFileType *GifFile)\n{\n    static unsigned InterlacedOffset[] = { 0, 4, 2, 1 }, /* The way Interlaced image should. */\n                    InterlacedJumps[] = { 8, 8, 4, 2 };  /* be read - offsets and jumps... */\n    /**** pts: unused vars ****/\n    /* int i, j, Error, ImageSize; */\n    int ext_code;\n\n    GifRecordType RecordType;\n    /**** pts ****/\n    SavedImage *sp=0; /**** pts: avoid gcc warning */\n    /** Extension info of next SavedImage */\n    SavedImage ext;\n    /** No-extension info */\n    SavedImage noext;\n\n    GifByteType *ExtData;\n\n    /**** pts ****/\n    memset(&noext, 0, sizeof(noext));\n    noext.delay=0;\n    noext.dispose=0;\n    noext.iter=1;\n    noext.transp=(-1);\n    noext.ExtensionBlocks=NULL;\n    noext.ExtensionBlockCount=0;\n    ext=noext;\n\n    /**** pts ****/\n    GifFile->SavedImages=0;\n\n    do {\n\tif (DGifGetRecordType(GifFile, &RecordType) == GIF_ERROR)\n\t    return(GIF_ERROR);\n\n\tswitch (RecordType) {\n\t    case IMAGE_DESC_RECORD_TYPE:\n\t\tif (DGifGetImageDesc(GifFile) == GIF_ERROR)\n\t\t    return(GIF_ERROR);\n\n                /**** pts: DGifGetImageDesc has already allocated the mem ****/\n\t\tsp = &GifFile->SavedImages[GifFile->ImageCount-1];\n\t\t/**** pts: apply extensions to the image just read */\n\t\text.RasterBits=sp->RasterBits;\n\t\text.ImageDesc=sp->ImageDesc;\n\t\t*sp=ext;\n\t\text=noext;\n\n\t\t/**** pts ****/\n\t\tsp->RasterBits = (GifPixelType*) xmalloc((0L+sp->ImageDesc.Width) * sp->ImageDesc.Height * sizeof(GifPixelType));\n\t\tif (sp->ImageDesc.Interlace) {\n\t\t  unsigned i, j, Height=sp->ImageDesc.Height, Width=sp->ImageDesc.Width;\n\t\t  /* Need to perform 4 passes on the images: */\n \t\t  for (i = 0; i < 4; i++)\n\t\t    for (j = InterlacedOffset[i]; j < Height; j += InterlacedJumps[i])\n\t\t      if (DGifGetLine(GifFile, sp->RasterBits+Width*j, Width) != GIF_OK) return GIF_ERROR;\n\t\t} else {\n\t\t  if (DGifGetLine(GifFile, sp->RasterBits, (0L+sp->ImageDesc.Width) * sp->ImageDesc.Height)\n\t\t      == GIF_ERROR)\n\t\t      return(GIF_ERROR);\n\t\t}\n\t\tbreak;\n\n\t    case EXTENSION_RECORD_TYPE:\n\n\t\tif (DGifGetExtension(GifFile,&ext_code,&ExtData)==GIF_ERROR)\n\t\t    return(GIF_ERROR);\n\t\tif (ExtData!=NULL) {\n\t\t    #if 0 /**** pts ****/\n\t\t      ep = &ext.ExtensionBlocks[ext.ExtensionBlockCount++];\n\t\t      ep->ByteCount = ExtData[0];\n\t\t      ep->Bytes = (GifByteType *)xmalloc(ep->ByteCount * sizeof(GifByteType));\n\t\t      memcpy(ep->Bytes, ExtData, ep->ByteCount * sizeof(char));\n\t\t    #else\n                      /**** pts ****/\n                      if (0xf9==(unsigned char)(ext_code)) {\n                        if (ExtData[0] < 4) { ext_too_short:\n                          _GifError = D_GIF_ERR_EXT_TOO_SHORT;\n                          return GIF_ERROR;\n                        }\n                        ext.dispose=ExtData[1]>>2;\n                        ext.delay=(ExtData[3] << 8) | ExtData[2];\n                        if ((ExtData[1] & 0x01) == 1) {\n                          if (ExtData[0] < 5) goto ext_too_short;\n                          ext.transp=ExtData[4];\n                        }\n                      } else if (0xff==(unsigned char)(ext_code)) {\n                        if (ExtData[0] < 4) goto ext_too_short;\n                        ext.iter=(ExtData[3] << 8) | ExtData[2];\n                      } else {\n                        AddExtensionBlock(&ext, ExtData[0], ExtData+1);\n                        ext.ExtensionBlocks[ext.ExtensionBlockCount-1].code=ext_code;\n                      }\n\t\t    #endif\n\t\t    while (1) {\n\t\t        if (DGifGetExtensionNext(GifFile, &ExtData) == GIF_ERROR)\n\t\t\t  return(GIF_ERROR);\n\t\t        #if 0 /**** pts ****/\n  \t\t\t  ep = &ext.ExtensionBlocks[ext.ExtensionBlockCount++];\n  \t\t\t  ep->ByteCount = ExtData[0];\n\t\t\t  ep->Bytes = (GifByteType *)xmalloc(ep->ByteCount * sizeof(GifByteType));\n  \t\t\t  memcpy(ep->Bytes,ExtData,ep->ByteCount * sizeof(char));\n  \t\t\t#else\n  \t\t\t  if (ExtData==NULL) break;\n  \t\t\t  AddExtensionBlock(sp, ExtData[0], ExtData+1);\n  \t\t\t#endif\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    case TERMINATE_RECORD_TYPE:\n\t\tbreak;\n\n\t    default:\t/* Should be trapped by DGifGetRecordType */\n\t\tbreak;\n\t}\n    }\n    while\n\t(RecordType != TERMINATE_RECORD_TYPE);\n\n    return(GIF_OK);\n}\n\n/* __END__ */\n"], "fixing_code": ["/* cgif.c -- a merge of some GIF-decoding files from giflib by E.S.Raymond\n * by pts@fazekas.hu at Wed Feb 27 13:18:04 CET 2002\n\nThe GIFLIB distribution is Copyright (c) 1997  Eric S. Raymond\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n */\n\n/*The creators of the GIF format require the following\n  acknowledgement:\n  The Graphics Interchange Format(c) is the Copyright property of\n  CompuServe Incorporated. GIF(sm) is a Service Mark property of\n  CompuServe Incorporated.\n*/\n\n#ifdef __GNUC__\n#ifndef __clang__\n#pragma implementation\n#endif\n#endif\n\n/**** pts: not an ANSI C function */\n#undef EXTERN_C\n#ifdef __cplusplus\n#define EXTERN_C extern \"C\"\n#define CGIFFF CGIF::\n#else\n#define EXTERN_C extern\n#define CGIFFF\n#endif\n#if OBJDEP\n#  warning PROVIDES: cgif\n#endif\n\n#if 0\nEXTERN_C FILE *fdopen (int fildes, const char *mode); /* GCC 3.0 SUXX */\n#else\n#undef  _POSIX_SOURCE\n#define _POSIX_SOURCE 1\n#undef  _POSIX_C_SOURCE\n#define _POSIX_C_SOURCE 2\n#endif\n\n/* --- gifalloc.c */\n\n/*****************************************************************************\n*   \"Gif-Lib\" - Yet another gif library.\t\t\t\t     *\n*\t\t\t\t\t\t\t\t\t     *\n* Written by:  Gershon Elber\t\t\t\tVer 0.1, Jun. 1989   *\n* Extensively hacked by: Eric S. Raymond\t\tVer 1.?, Sep 1992    *\n******************************************************************************\n* GIF construction tools\t\t\t\t\t\t      *\n******************************************************************************\n* History:\t\t\t\t\t\t\t\t     *\n* 15 Sep 92 - Version 1.0 by Eric Raymond.\t\t\t\t     *\n*****************************************************************************/\n\n// #undef __STRICT_ANSI__ /* for MINGW32 open() !! */\n#include <stdio.h>\n#include \"cgif.h\"\n\n/**** pts ****/\n#include <stdlib.h> /* malloc(), free(), realloc() */\n#include <string.h> /* memset() */\n\n\n//#include <unistd.h>\n\n#if USE_CGIF_FDOPEN\n#include <fcntl.h> /* open() */\n#include <sys/types.h>\n#include <sys/stat.h>\n#  if defined(__MINGW32__) || defined(__CYGWIN__) || defined(_MSC_VER)\n#    undef __STRICT_ANSI__\n#    include <io.h>\n     /*#define open _open*/\n#  endif\n#endif\n\n/* --- gif_err.c */\n\n/*****************************************************************************\n*   \"Gif-Lib\" - Yet another gif library.\t\t\t\t     *\n*\t\t\t\t\t\t\t\t\t     *\n* Written by:  Gershon Elber\t\t\tIBM PC Ver 0.1,\tJun. 1989    *\n******************************************************************************\n* Handle error reporting for the GIF library.\t\t\t\t     *\n******************************************************************************\n* History:\t\t\t\t\t\t\t\t     *\n* 17 Jun 89 - Version 1.0 by Gershon Elber.\t\t\t\t     *\n*****************************************************************************/\n\n/* #include <stdio.h> already */\n/* #include \"gif_lib.h\" already */\n\n/* --- dgif_lib.c */\n\n/******************************************************************************\n*   \"Gif-Lib\" - Yet another gif library.\t\t\t\t      *\n*\t\t\t\t\t\t\t\t\t      *\n* Written by:  Gershon Elber\t\t\tIBM PC Ver 1.1,\tAug. 1990     *\n*******************************************************************************\n* The kernel of the GIF Decoding process can be found here.\t\t      *\n*******************************************************************************\n* History:\t\t\t\t\t\t\t\t      *\n* 16 Jun 89 - Version 1.0 by Gershon Elber.\t\t\t\t      *\n*  3 Sep 90 - Version 1.1 by Gershon Elber (Support for Gif89, Unique names). *\n******************************************************************************/\n\n#ifdef __MSDOS__\n#include <io.h>\n#include <alloc.h>\n#include <stdlib.h>\n#include <sys\\stat.h>\n#else\n#include <sys/types.h>\n#include <sys/stat.h>\n#endif /* __MSDOS__ */\n\n#include <fcntl.h>\n/* #include <stdio.h> already */\n/* #include <string.h> already */\n/* #include \"gif_lib.h\" already */\n\n/* #include <stdlib.h> already */ /* malloc(), free() */\n#include <assert.h>\n\n/* ---- */\n\nstatic void *xmalloc(size_t size);\nstatic void *xrealloc(void *ptr, size_t size);\n\n/* --- gif_err.c */\n\n/* #define PROGRAM_NAME\t\"GIF_LIBRARY\" */\n\nint CGIFFF _GifError = 0;\n\n/*****************************************************************************\n* Return the last GIF error (0 if none) and reset the error.\t\t     *\n*****************************************************************************/\nint CGIFFF GifLastError(void)\n{\n    int i = _GifError;\n\n    _GifError = 0;\n\n    return i;\n}\n\n/**** pts ****/\n/** May return NULL. */\nPTS_const char *CGIFFF GetGifError(void)\n{\n    PTS_const char *Err;\n\n    switch(_GifError) {\n#if 0 /**** pts ****/\n\tcase E_GIF_ERR_OPEN_FAILED:\n\t    Err = \"Failed to open given file\";\n\t    break;\n\tcase E_GIF_ERR_WRITE_FAILED:\n\t    Err = \"Failed to Write to given file\";\n\t    break;\n\tcase E_GIF_ERR_HAS_SCRN_DSCR:\n\t    Err = \"Screen Descriptor already been set\";\n\t    break;\n\tcase E_GIF_ERR_HAS_IMAG_DSCR:\n\t    Err = \"Image Descriptor is still active\";\n\t    break;\n\tcase E_GIF_ERR_NO_COLOR_MAP:\n\t    Err = \"Neither Global Nor Local color map\";\n\t    break;\n\tcase E_GIF_ERR_DATA_TOO_BIG:\n\t    Err = \"#Pixels bigger than Width * Height\";\n\t    break;\n\tcase E_GIF_ERR_NOT_ENOUGH_MEM:\n\t    Err = \"Fail to allocate required memory\";\n\t    break;\n\tcase E_GIF_ERR_DISK_IS_FULL:\n\t    Err = \"Write failed (disk full?)\";\n\t    break;\n\tcase E_GIF_ERR_CLOSE_FAILED:\n\t    Err = \"Failed to close given file\";\n\t    break;\n\tcase E_GIF_ERR_NOT_WRITEABLE:\n\t    Err = \"Given file was not opened for write\";\n\t    break;\n#endif\n\tcase D_GIF_ERR_OPEN_FAILED:\n\t    Err = \"Failed to open given file\";\n\t    break;\n\tcase D_GIF_ERR_READ_FAILED:\n\t    Err = \"Failed to Read from given file\";\n\t    break;\n\tcase D_GIF_ERR_NOT_GIF_FILE:\n\t    Err = \"Given file is NOT GIF file\";\n\t    break;\n\tcase D_GIF_ERR_NO_SCRN_DSCR:\n\t    Err = \"No Screen Descriptor detected\";\n\t    break;\n\tcase D_GIF_ERR_NO_IMAG_DSCR:\n\t    Err = \"No Image Descriptor detected\";\n\t    break;\n\tcase D_GIF_ERR_NO_COLOR_MAP:\n\t    Err = \"Neither Global Nor Local color map\";\n\t    break;\n\tcase D_GIF_ERR_WRONG_RECORD:\n\t    Err = \"Wrong record type detected\";\n\t    break;\n\tcase D_GIF_ERR_DATA_TOO_BIG:\n\t    Err = \"#Pixels bigger than Width * Height\";\n\t    break;\n\tcase D_GIF_ERR_NOT_ENOUGH_MEM:\n\t    Err = \"Fail to allocate required memory\";\n\t    break;\n\tcase D_GIF_ERR_CLOSE_FAILED:\n\t    Err = \"Failed to close given file\";\n\t    break;\n\tcase D_GIF_ERR_NOT_READABLE:\n\t    Err = \"Given file was not opened for read\";\n\t    break;\n\tcase D_GIF_ERR_IMAGE_DEFECT:\n\t    Err = \"Image is defective, decoding aborted\";\n\t    break;\n\tcase D_GIF_ERR_EOF_TOO_SOON:\n\t    Err = \"Image EOF detected, before image complete\";\n\t    break;\n\tcase D_GIF_ERR_EXT_TOO_SHORT:\n\t    Err = \"Extension data too short\";\n\t    break;\n\tdefault:\n\t    Err = NULL;\n\t    break;\n    }\n    return Err;\n}\n\n/*****************************************************************************\n* Print the last GIF error to stderr.\t\t\t\t\t     *\n*****************************************************************************/\nvoid CGIFFF PrintGifError(void)\n{\n    PTS_const char *Err=GetGifError();\n    if (Err != NULL)\n\tfprintf(stderr, \"\\nGIF-LIB error: %s.\\n\", Err);\n    else\n\tfprintf(stderr, \"\\nGIF-LIB undefined error %d.\\n\", _GifError);\n}\n\n/* --- gifalloc.c */\n\n#define MAXGIF(x, y)\t(((x) > (y)) ? (x) : (y))\n\n/******************************************************************************\n* Miscellaneous utility functions\t\t\t\t\t      *\n******************************************************************************/\n\nstatic int BitSize(int n)\n/* return smallest bitfield size n will fit in */\n{\n    register\tint i;\n\n    for (i = 1; i <= 8; i++)\n\tif ((1 << i) >= n)\n\t    break;\n    return(i);\n}\n\n\n/******************************************************************************\n* Color map object functions\t\t\t\t\t\t      *\n******************************************************************************/\n\nCGIFFF ColorMapObject *CGIFFF MakeMapObject(int ColorCount, GifColorType *ColorMap)\n/*\n * Allocate a color map of given size; initialize with contents of\n * ColorMap if that pointer is non-NULL.\n */\n{\n    ColorMapObject *Object;\n\n    if (ColorCount != (1 << BitSize(ColorCount)))\n\treturn((ColorMapObject *)NULL);\n\n    Object = (ColorMapObject *)xmalloc(sizeof(ColorMapObject));\n\n    Object->Colors = (GifColorType *)xmalloc(ColorCount * sizeof(GifColorType));\n    memset(Object->Colors, '\\0', ColorCount * sizeof(GifColorType));\n\n    Object->ColorCount = ColorCount;\n    Object->BitsPerPixel = BitSize(ColorCount);\n\n    if (ColorMap)\n\tmemcpy((char *)Object->Colors,\n\t       (char *)ColorMap, ColorCount * sizeof(GifColorType));\n\n    return(Object);\n}\n\nvoid CGIFFF FreeMapObject(CGIFFF ColorMapObject *Object)\n/*\n * Free a color map object\n */\n{\n    free(Object->Colors);\n    free(Object);\n}\n\n#if 0\nvoid DumpColorMap(ColorMapObject *Object, FILE *fp)\n{\n    if (Object)\n    {\n\tint i, j, Len = Object->ColorCount;\n\n\tfor (i = 0; i < Len; i+=4) {\n\t    for (j = 0; j < 4 && j < Len; j++) {\n\t\tfprintf(fp,\n\t\t\t\"%3d: %02x %02x %02x   \", i + j,\n\t\t       Object->Colors[i + j].Red,\n\t\t       Object->Colors[i + j].Green,\n\t\t       Object->Colors[i + j].Blue);\n\t    }\n\t    fprintf(fp, \"\\n\");\n\t}\n    }\n}\n#endif /* DEBUG */\n\n#if 0\nColorMapObject *CGIFFF UnionColorMap(\n\t\t\t ColorMapObject *ColorIn1,\n\t\t\t ColorMapObject *ColorIn2,\n\t\t\t GifPixelType ColorTransIn2[])\n/*\n * Compute the union of two given color maps and return it.  If result can't\n * fit into 256 colors, NULL is returned, the allocated union otherwise.\n * ColorIn1 is copied as is to ColorUnion, while colors from ColorIn2 are\n * copied iff they didn't exist before.  ColorTransIn2 maps the old\n * ColorIn2 into ColorUnion color map table.\n */\n{\n    int i, j, CrntSlot, RoundUpTo, NewBitSize;\n    ColorMapObject *ColorUnion;\n\n    /*\n     * Allocate table which will hold the result for sure.\n     */\n    ColorUnion\n\t= MakeMapObject(MAXGIF(ColorIn1->ColorCount,ColorIn2->ColorCount)*2,NULL);\n\n    if (ColorUnion == NULL)\n\treturn(NULL);\n\n    /* Copy ColorIn1 to ColorUnionSize; */\n    for (i = 0; i < ColorIn1->ColorCount; i++)\n\tColorUnion->Colors[i] = ColorIn1->Colors[i];\n    CrntSlot = ColorIn1->ColorCount;\n\n    /*\n     * Potentially obnoxious hack:\n     *\n     * Back CrntSlot down past all contiguous {0, 0, 0} slots at the end\n     * of table 1.  This is very useful if your display is limited to\n     * 16 colors.\n     */\n    while (ColorIn1->Colors[CrntSlot-1].Red == 0\n\t   && ColorIn1->Colors[CrntSlot-1].Green == 0\n\t   && ColorIn1->Colors[CrntSlot-1].Red == 0)\n\tCrntSlot--;\n\n    /* Copy ColorIn2 to ColorUnionSize (use old colors if they exist): */\n    for (i = 0; i < ColorIn2->ColorCount && CrntSlot<=256; i++)\n    {\n\t/* Let's see if this color already exists: */\n\tfor (j = 0; j < ColorIn1->ColorCount; j++)\n\t    if (memcmp(&ColorIn1->Colors[j], &ColorIn2->Colors[i], sizeof(GifColorType)) == 0)\n\t\tbreak;\n\n\tif (j < ColorIn1->ColorCount)\n\t    ColorTransIn2[i] = j;\t/* color exists in Color1 */\n\telse\n\t{\n\t    /* Color is new - copy it to a new slot: */\n\t    ColorUnion->Colors[CrntSlot] = ColorIn2->Colors[i];\n\t    ColorTransIn2[i] = CrntSlot++;\n\t}\n    }\n\n    if (CrntSlot > 256)\n    {\n\tFreeMapObject(ColorUnion);\n\treturn((ColorMapObject *)NULL);\n    }\n\n    NewBitSize = BitSize(CrntSlot);\n    RoundUpTo = (1 << NewBitSize);\n\n    if (RoundUpTo != ColorUnion->ColorCount)\n    {\n\tregister GifColorType\t*Map = ColorUnion->Colors;\n\n\t/*\n\t * Zero out slots up to next power of 2.\n\t * We know these slots exist because of the way ColorUnion's\n\t * start dimension was computed.\n\t */\n\tfor (j = CrntSlot; j < RoundUpTo; j++)\n\t    Map[j].Red = Map[j].Green = Map[j].Blue = 0;\n\n\t/* perhaps we can shrink the map? */\n\tif (RoundUpTo < ColorUnion->ColorCount)\n\t    ColorUnion->Colors\n\t\t= (GifColorType *)xrealloc(Map, sizeof(GifColorType)*RoundUpTo);\n    }\n\n    ColorUnion->ColorCount = RoundUpTo;\n    ColorUnion->BitsPerPixel = NewBitSize;\n\n    return(ColorUnion);\n}\nvoid ApplyTranslation(SavedImage *Image, GifPixelType Translation[])\n/*\n * Apply a given color translation to the raster bits of an image\n */\n{\n    register int i;\n    register int RasterSize = Image->ImageDesc.Height * Image->ImageDesc.Width;\n\n    for (i = 0; i < RasterSize; i++)\n\tImage->RasterBits[i] = Translation[Image->RasterBits[i]];\n}\n#endif\n\n/******************************************************************************\n* Extension record functions\t\t\t\t\t\t      *\n******************************************************************************/\n\n#if 0 /**** pts ****/\nvoid MakeExtension(SavedImage *New, int Function)\n{\n    New->Function = Function;\n    /*\n     * Someday we might have to deal with multiple extensions.\n     */\n}\n#endif\n\nint CGIFFF AddExtensionBlock(CGIFFF SavedImage *New, int Len, CGIFFF GifByteType ExtData[])\n{\n    ExtensionBlock\t*ep;\n\n    if (New->ExtensionBlocks == NULL)\n\tNew->ExtensionBlocks = (ExtensionBlock *)xmalloc(sizeof(ExtensionBlock));\n    else\n\tNew->ExtensionBlocks =\n\t    (ExtensionBlock *)xrealloc(New->ExtensionBlocks,\n\t\t      sizeof(ExtensionBlock) * (New->ExtensionBlockCount + 1));\n\n    if (New->ExtensionBlocks == NULL)\n\treturn(GIF_ERROR);\n\n    ep = &New->ExtensionBlocks[New->ExtensionBlockCount++];\n\n    ep->Bytes = (GifByteType *)xmalloc(ep->ByteCount = Len);\n\n    if (ExtData)\n\tmemcpy(ep->Bytes, ExtData, Len);\n\n    return(GIF_OK);\n}\n\nvoid CGIFFF FreeExtension(CGIFFF SavedImage *Image)\n{\n    ExtensionBlock\t*ep;\n\n    for (ep = Image->ExtensionBlocks;\n\t ep < Image->ExtensionBlocks + Image->ExtensionBlockCount;\n\t ep++)\n\t(void) free((char *)ep->Bytes);\n    free((char *)Image->ExtensionBlocks);\n    Image->ExtensionBlocks = NULL;\n}\n\n/******************************************************************************\n* Image block allocation functions\t\t\t\t\t      *\n******************************************************************************/\nCGIFFF SavedImage *CGIFFF MakeSavedImage(CGIFFF GifFileType *GifFile, CGIFFF SavedImage *CopyFrom)\n/*\n * Append an image block to the SavedImages array\n */\n{\n    SavedImage\t*sp;\n\n    if (GifFile->SavedImages == NULL)\n\tGifFile->SavedImages = (SavedImage *)xmalloc(sizeof(SavedImage));\n    else\n\tGifFile->SavedImages = (SavedImage *)xrealloc(GifFile->SavedImages,\n\t\t\t\tsizeof(SavedImage) * (GifFile->ImageCount+1));\n\n    {\n\tsp = &GifFile->SavedImages[GifFile->ImageCount++];\n\tmemset((char *)sp, '\\0', sizeof(SavedImage));\n\n\tif (CopyFrom)\n\t{\n\t    memcpy((char *)sp, CopyFrom, sizeof(SavedImage));\n\n\t    /*\n\t     * Make our own allocated copies of the heap fields in the\n\t     * copied record.  This guards against potential aliasing\n\t     * problems.\n\t     */\n\n\t    /* first, the local color map */\n\t    if (sp->ImageDesc.ColorMap)\n\t\tsp->ImageDesc.ColorMap =\n\t\t    MakeMapObject(CopyFrom->ImageDesc.ColorMap->ColorCount,\n\t\t\t\t  CopyFrom->ImageDesc.ColorMap->Colors);\n\n\t    /* next, the raster */\n\t    sp->RasterBits = (GifPixelType *)xmalloc(sizeof(GifPixelType)\n\t\t\t\t* CopyFrom->ImageDesc.Height\n\t\t\t\t* CopyFrom->ImageDesc.Width);\n\t    memcpy(sp->RasterBits,\n\t\t   CopyFrom->RasterBits,\n\t\t   sizeof(GifPixelType)\n\t\t\t* CopyFrom->ImageDesc.Height\n\t\t\t* CopyFrom->ImageDesc.Width);\n\n\t    /* finally, the extension blocks */\n\t    if (sp->ExtensionBlocks)\n\t    {\n\t\tsp->ExtensionBlocks\n\t\t    = (ExtensionBlock*)xmalloc(sizeof(ExtensionBlock)\n\t\t\t\t\t      * CopyFrom->ExtensionBlockCount);\n\t\tmemcpy(sp->ExtensionBlocks,\n\t\t   CopyFrom->ExtensionBlocks,\n\t\t   sizeof(ExtensionBlock)\n\t\t   \t* CopyFrom->ExtensionBlockCount);\n\n\t\t/*\n\t\t * For the moment, the actual blocks can take their\n\t\t * chances with free().  We'll fix this later.\n\t\t */\n\t    }\n\t}\n\n\treturn(sp);\n    }\n}\n\nvoid CGIFFF FreeSavedImages(CGIFFF GifFileType *GifFile)\n{\n    SavedImage\t*sp;\n\n    for (sp = GifFile->SavedImages;\n\t sp < GifFile->SavedImages + GifFile->ImageCount;\n\t sp++)\n    {\n\tif (sp->ImageDesc.ColorMap)\n\t    FreeMapObject(sp->ImageDesc.ColorMap);\n\n\tif (sp->RasterBits)\n\t    free((char *)sp->RasterBits);\n\n\tif (sp->ExtensionBlocks)\n\t    FreeExtension(sp);\n    }\n    free((char *) GifFile->SavedImages);\n}\n\n/* --- dgif_lib.c */\n\n#define GIF_FILE_BUFFER_SIZE 16384  /* Files uses bigger buffers than usual. */\n\n/* #define PROGRAM_NAME\t\"GIFLIB\" */\n\n#define COMMENT_EXT_FUNC_CODE\t0xfe /* Extension function code for comment. */\n#define GIF_STAMP\t\"GIFVER\"\t /* First chars in file - GIF stamp. */\n#define GIF_STAMP_LEN\tsizeof(GIF_STAMP) - 1\n#define GIF_VERSION_POS\t3\t\t/* Version first character in stamp. */\n\n#define LZ_MAX_CODE\t4095\t\t/* Biggest code possible in 12 bits. */\n#define LZ_BITS\t\t12\n\n#define FILE_STATE_READ\t\t0x01/* 1 write, 0 read - EGIF_LIB compatible.*/\n\n#define FLUSH_OUTPUT\t\t4096    /* Impossible code, to signal flush. */\n#define FIRST_CODE\t\t4097    /* Impossible code, to signal first. */\n#define NO_SUCH_CODE\t\t4098    /* Impossible code, to signal empty. */\n\n#define IS_READABLE(Private)\t(!(Private->FileState & FILE_STATE_READ))\n\ntypedef struct GifFilePrivateType {\n    int FileState,\n\t/*FileHandle,*/\t\t\t     /* Where all this data goes to! */\n\tBitsPerPixel,\t    /* Bits per pixel (Codes uses at list this + 1). */\n\tClearCode,\t\t\t\t       /* The CLEAR LZ code. */\n\tEOFCode,\t\t\t\t         /* The EOF LZ code. */\n\tRunningCode,\t\t    /* The next code algorithm can generate. */\n\tRunningBits,/* The number of bits required to represent RunningCode. */\n\tMaxCode1,  /* 1 bigger than max. possible code, in RunningBits bits. */\n\tLastCode,\t\t        /* The code before the current code. */\n\tCrntCode,\t\t\t\t  /* Current algorithm code. */\n\tStackPtr,\t\t         /* For character stack (see below). */\n\tCrntShiftState;\t\t        /* Number of bits in CrntShiftDWord. */\n    unsigned long CrntShiftDWord;     /* For bytes decomposition into codes. */\n    unsigned long PixelCount;\t\t       /* Number of pixels in image. */\n    FILE *File;\t\t\t\t\t\t  /* File as stream. */\n    CGIFFF GifByteType Buf[256];\t       /* Compressed input is buffered here. */\n    CGIFFF GifByteType Stack[LZ_MAX_CODE];\t /* Decoded pixels are stacked here. */\n    CGIFFF GifByteType Suffix[LZ_MAX_CODE+1];\t       /* So we can trace the codes. */\n    unsigned int Prefix[LZ_MAX_CODE+1];\n} GifFilePrivateType;\n\n/* extern int _GifError; */\n\nstatic int DGifGetWord(FILE *File, int *Word);\nstatic int DGifSetupDecompress(CGIFFF GifFileType *GifFile);\nstatic int DGifDecompressLine(CGIFFF GifFileType *GifFile, CGIFFF GifPixelType *Line,\n\t\t\t\t\t\t\t\tint LineLen);\nstatic int DGifGetPrefixChar(unsigned int *Prefix, int Code, int ClearCode);\nstatic int DGifDecompressInput(GifFilePrivateType *Private, int *Code);\nstatic int DGifBufferedInput(FILE *File, CGIFFF GifByteType *Buf,\n\t\t\t\t\t\t     CGIFFF GifByteType *NextByte);\n\n/******************************************************************************\n*   Open a new gif file for read, given by its name.\t\t\t      *\n*   Returns GifFileType pointer dynamically allocated which serves as the gif *\n* info record. _GifError is cleared if succesfull.\t\t\t      *\n******************************************************************************/\nCGIFFF GifFileType *CGIFFF DGifOpenFileName(const char *FileName) {\n#if 0 /**** pts ****/\nCGIFFF GifFileType *CGIFFF DGifOpenFileName(const char *FileName)\n{\n    int FileHandle;\n\n    if ((FileHandle = open(FileName, O_RDONLY\n#ifdef __MSDOS__\n\t\t\t           | O_BINARY\n#endif /* __MSDOS__ */\n\t\t\t                     )) == -1) {\n\t_GifError = D_GIF_ERR_OPEN_FAILED;\n\treturn NULL;\n    }\n\n    return DGifOpenFileHandle(FileHandle);\n#else\n  FILE *f;\n  if (NULL==(f=fopen(FileName,\"rb\"))) { _GifError=D_GIF_ERR_OPEN_FAILED; return NULL; }\n  return DGifOpenFILE(f);\n#endif\n}\n\n#if USE_CGIF_FDOPEN\n\n/******************************************************************************\n*   Update a new gif file, given its file handle.\t\t\t      *\n*   Returns GifFileType pointer dynamically allocated which serves as the gif *\n* info record. _GifError is cleared if succesfull.\t\t\t      *\n******************************************************************************/\nCGIFFF GifFileType *CGIFFF DGifOpenFileHandle(int FileHandle)\n{\n    FILE *f;\n\n#ifdef __MSDOS__\n    setmode(FileHandle, O_BINARY);\t  /* Make sure it is in binary mode. */\n    f = fdopen(FileHandle, \"rb\");\t\t   /* Make it into a stream: */\n    setvbuf(f, NULL, _IOFBF, GIF_FILE_BUFFER_SIZE);/* And inc. stream buffer.*/\n#else\n    f = fdopen(FileHandle, \"rb\");\t\t   /* Make it into a stream: */\n#endif /* __MSDOS__ */\n    return DGifOpenFILE(f);\n}\n#endif\n\n/**** pts ****/\nCGIFFF GifFileType *CGIFFF DGifOpenFILE(void/*FILE*/ *f) {\n    char Buf[GIF_STAMP_LEN+1];\n    GifFileType *GifFile;\n    GifFilePrivateType *Private;\n    GifFile = (GifFileType *) xmalloc(sizeof(GifFileType));\n\n    memset(GifFile, '\\0', sizeof(GifFileType));\n\n    Private = (GifFilePrivateType *) xmalloc(sizeof(GifFilePrivateType));\n    GifFile->Private = (VoidPtr) Private;\n    /* Private->FileHandle = FileHandle; */\n    Private->File = (FILE*)f;\n    Private->FileState = 0;   /* Make sure bit 0 = 0 (File open for read). */\n\n    /* Let's see if this is a GIF file: */\n    if (fread(Buf, 1, GIF_STAMP_LEN, Private->File) != GIF_STAMP_LEN) {\n\t_GifError = D_GIF_ERR_READ_FAILED;\n\tfree((char *) Private);\n\tfree((char *) GifFile);\n\treturn NULL;\n    }\n\n    /* The GIF Version number is ignored at this time. Maybe we should do    */\n    /* something more useful with it.\t\t\t\t\t     */\n    Buf[GIF_STAMP_LEN] = 0;\n    if (strncmp(GIF_STAMP, Buf, GIF_VERSION_POS) != 0) {\n\t_GifError = D_GIF_ERR_NOT_GIF_FILE;\n\tfree((char *) Private);\n\tfree((char *) GifFile);\n\treturn NULL;\n    }\n\n    if (DGifGetScreenDesc(GifFile) == GIF_ERROR) {\n\tfree((char *) Private);\n\tfree((char *) GifFile);\n\treturn NULL;\n    }\n\n    _GifError = 0;\n\n    return GifFile;\n}\n\n/******************************************************************************\n*   This routine should be called before any other DGif calls. Note that      *\n* this routine is called automatically from DGif file open routines.\t      *\n******************************************************************************/\nint CGIFFF DGifGetScreenDesc(CGIFFF GifFileType *GifFile)\n{\n    int i, BitsPerPixel;\n    GifByteType Buf[3];\n    GifFilePrivateType *Private = (GifFilePrivateType *) GifFile->Private;\n\n    if (!IS_READABLE(Private)) {\n\t/* This file was NOT open for reading: */\n\t_GifError = D_GIF_ERR_NOT_READABLE;\n\treturn GIF_ERROR;\n    }\n\n    /* Put the screen descriptor into the file: */\n    if (DGifGetWord(Private->File, &GifFile->SWidth) == GIF_ERROR ||\n\tDGifGetWord(Private->File, &GifFile->SHeight) == GIF_ERROR)\n\treturn GIF_ERROR;\n\n    if (fread(Buf, 1, 3, Private->File) != 3) {\n\t_GifError = D_GIF_ERR_READ_FAILED;\n\treturn GIF_ERROR;\n    }\n    GifFile->SColorResolution = (((Buf[0] & 0x70) + 1) >> 4) + 1;\n    BitsPerPixel = (Buf[0] & 0x07) + 1;\n    GifFile->SBackGroundColor = Buf[1];\n    // fprintf(stderr, \"colres=%d bpp=%d bgcol=%d\\n\", GifFile->SColorResolution, BitsPerPixel, GifFile->SBackGroundColor);\n    if (Buf[0] & 0x80) {\t\t     /* Do we have global color map? */\n        // fprintf(stderr, \"have gcolormap\\n\");\n\tGifFile->SColorMap = MakeMapObject(1 << BitsPerPixel, NULL);\n\n\t/* Get the global color map: */\n\tfor (i = 0; i < GifFile->SColorMap->ColorCount; i++) {\n\t    if (fread(Buf, 1, 3, Private->File) != 3) {\n\t\t_GifError = D_GIF_ERR_READ_FAILED;\n\t\treturn GIF_ERROR;\n\t    }\n\t    GifFile->SColorMap->Colors[i].Red = Buf[0];\n\t    GifFile->SColorMap->Colors[i].Green = Buf[1];\n\t    GifFile->SColorMap->Colors[i].Blue = Buf[2];\n\t}\n    }\n\n    return GIF_OK;\n}\n\n/******************************************************************************\n*   This routine should be called before any attemp to read an image.         *\n******************************************************************************/\nint CGIFFF DGifGetRecordType(CGIFFF GifFileType *GifFile, CGIFFF GifRecordType *Type)\n{\n    GifByteType Buf;\n    GifFilePrivateType *Private = (GifFilePrivateType *) GifFile->Private;\n\n    if (!IS_READABLE(Private)) {\n\t/* This file was NOT open for reading: */\n\t_GifError = D_GIF_ERR_NOT_READABLE;\n\treturn GIF_ERROR;\n    }\n\n    if (fread(&Buf, 1, 1, Private->File) != 1) {\n\t_GifError = D_GIF_ERR_READ_FAILED;\n\treturn GIF_ERROR;\n    }\n\n    // fprintf(stderr, \"record %d at offset %ld\\n\", Buf&255, ftell(Private->File));\n    switch (Buf) {\n\tcase ',': *Type = IMAGE_DESC_RECORD_TYPE; break;\n\tcase '!': *Type = EXTENSION_RECORD_TYPE;  break;\n\tcase ';': *Type = TERMINATE_RECORD_TYPE;  break;\n\tdefault:  *Type = UNDEFINED_RECORD_TYPE;\n\t    // fprintf(stderr, \"wrong record %d at offset %ld\\n\", Buf&255, ftell(Private->File));\n\t    _GifError = D_GIF_ERR_WRONG_RECORD;\n\t    return GIF_ERROR;\n    }\n\n    return GIF_OK;\n}\n\n/******************************************************************************\n*   This routine should be called before any attemp to read an image.         *\n*   Note it is assumed the Image desc. header (',') has been read.\t      *\n******************************************************************************/\nint CGIFFF DGifGetImageDesc(CGIFFF GifFileType *GifFile)\n{\n    int i, BitsPerPixel;\n    GifByteType Buf[3];\n    GifImageDesc Image;\n    GifFilePrivateType *Private = (GifFilePrivateType *) GifFile->Private;\n    memset(&Image, 0, sizeof(Image));\n\n    if (!IS_READABLE(Private)) {\n\t/* This file was NOT open for reading: */\n\t_GifError = D_GIF_ERR_NOT_READABLE;\n\treturn GIF_ERROR;\n    }\n\n    if (DGifGetWord(Private->File, &Image.Left) == GIF_ERROR ||\n\tDGifGetWord(Private->File, &Image.Top) == GIF_ERROR ||\n\tDGifGetWord(Private->File, &Image.Width) == GIF_ERROR ||\n\tDGifGetWord(Private->File, &Image.Height) == GIF_ERROR)\n\treturn GIF_ERROR;\n    if (fread(Buf, 1, 1, Private->File) != 1) {\n\t_GifError = D_GIF_ERR_READ_FAILED;\n\treturn GIF_ERROR;\n    }\n    BitsPerPixel = (Buf[0] & 0x07) + 1;\n    Image.Interlace = (Buf[0] & 0x40);\n    if (Buf[0] & 0x80) {\t    /* Does this image have local color map? */\n\n\tif (Image.ColorMap && GifFile->SavedImages == NULL)\n\t    FreeMapObject(Image.ColorMap);\n\n\tImage.ColorMap = MakeMapObject(1 << BitsPerPixel, NULL);\n\n\t/* Get the image local color map: */\n\tfor (i = 0; i < Image.ColorMap->ColorCount; i++) {\n\t    if (fread(Buf, 1, 3, Private->File) != 3) {\n\t\t_GifError = D_GIF_ERR_READ_FAILED;\n\t\treturn GIF_ERROR;\n\t    }\n\t    Image.ColorMap->Colors[i].Red = Buf[0];\n\t    Image.ColorMap->Colors[i].Green = Buf[1];\n\t    Image.ColorMap->Colors[i].Blue = Buf[2];\n\t}\n    }\n\n    /**** pts ****/\n    if (NULL!=GifFile->SavedImages) {\n      GifFile->SavedImages = (SavedImage *)xrealloc(GifFile->SavedImages,\n\t\t    sizeof(SavedImage) * (GifFile->ImageCount + 1));\n    } else {\n      assert(GifFile->ImageCount==0);\n      GifFile->SavedImages = (SavedImage *)xmalloc(sizeof(SavedImage));\n    }\n\n    {\n\tSavedImage\t*sp;\n\tsp = &GifFile->SavedImages[GifFile->ImageCount];\n\tmemcpy(&sp->ImageDesc, &Image, sizeof(GifImageDesc));\n\tsp->RasterBits = (GifPixelType *)NULL;\n\tsp->ExtensionBlockCount = 0;\n\tsp->ExtensionBlocks = (ExtensionBlock *)NULL;\n        sp->delay=0;\n        sp->dispose=0;\n        sp->iter=1;\n        sp->transp=(-1);\n    }\n\n    GifFile->ImageCount++;\n\n    Private->PixelCount = (long) Image.Width *\n\t\t\t    (long) Image.Height;\n\n    /* Reset decompress algorithm parameters. */\n    if (DGifSetupDecompress(GifFile)==GIF_ERROR) {\n      _GifError = D_GIF_ERR_READ_FAILED;\n      return GIF_ERROR;\n    }\n\n    return GIF_OK;\n}\n\n/******************************************************************************\n*  Get one full scanned line (Line) of length LineLen from GIF file.\t      *\n******************************************************************************/\nint CGIFFF DGifGetLine(CGIFFF GifFileType *GifFile, CGIFFF GifPixelType *Line, int LineLen)\n{\n    GifByteType *Dummy;\n    GifFilePrivateType *Private = (GifFilePrivateType *) GifFile->Private;\n\n    if (!IS_READABLE(Private)) {\n\t/* This file was NOT open for reading: */\n\t_GifError = D_GIF_ERR_NOT_READABLE;\n\treturn GIF_ERROR;\n    }\n\n    /**** pts ****/\n    /* if (!LineLen) LineLen = GifFile->Image.Width; */\n\n#if defined(__MSDOS__) || defined(__GNUC__)\n    if ((Private->PixelCount -= LineLen) > 0xffff0000UL) {\n#else\n    if ((Private->PixelCount -= LineLen) > 0xffff0000) {\n#endif /* __MSDOS__ */\n\t_GifError = D_GIF_ERR_DATA_TOO_BIG;\n\treturn GIF_ERROR;\n    }\n\n    if (DGifDecompressLine(GifFile, Line, LineLen) == GIF_OK) {\n\tif (Private->PixelCount == 0) {\n\t    /* We probably would not be called any more, so lets clean \t     */\n\t    /* everything before we return: need to flush out all rest of    */\n\t    /* image until empty block (size 0) detected. We use GetCodeNext.*/\n\t    do if (DGifGetCodeNext(GifFile, &Dummy) == GIF_ERROR)\n\t\treturn GIF_ERROR;\n\t    while (Dummy != NULL);\n\t}\n\treturn GIF_OK;\n    }\n    else\n\treturn GIF_ERROR;\n}\n\n/******************************************************************************\n* Put one pixel (Pixel) into GIF file.\t\t\t\t\t      *\n******************************************************************************/\nint CGIFFF DGifGetPixel(CGIFFF GifFileType *GifFile, CGIFFF GifPixelType Pixel)\n{\n    GifByteType *Dummy;\n    GifFilePrivateType *Private = (GifFilePrivateType *) GifFile->Private;\n\n    if (!IS_READABLE(Private)) {\n\t/* This file was NOT open for reading: */\n\t_GifError = D_GIF_ERR_NOT_READABLE;\n\treturn GIF_ERROR;\n    }\n\n#if defined(__MSDOS__) || defined(__GNUC__)\n    if (--Private->PixelCount > 0xffff0000UL)\n#else\n    if (--Private->PixelCount > 0xffff0000)\n#endif /* __MSDOS__ */\n    {\n\t_GifError = D_GIF_ERR_DATA_TOO_BIG;\n\treturn GIF_ERROR;\n    }\n\n    if (DGifDecompressLine(GifFile, &Pixel, 1) == GIF_OK) {\n\tif (Private->PixelCount == 0) {\n\t    /* We probably would not be called any more, so lets clean \t     */\n\t    /* everything before we return: need to flush out all rest of    */\n\t    /* image until empty block (size 0) detected. We use GetCodeNext.*/\n\t    do if (DGifGetCodeNext(GifFile, &Dummy) == GIF_ERROR)\n\t\treturn GIF_ERROR;\n\t    while (Dummy != NULL);\n\t}\n\treturn GIF_OK;\n    }\n    else\n\treturn GIF_ERROR;\n}\n\n/******************************************************************************\n*   Get an extension block (see GIF manual) from gif file. This routine only  *\n* returns the first data block, and DGifGetExtensionNext shouldbe called      *\n* after this one until NULL extension is returned.\t\t\t      *\n*   The Extension should NOT be freed by the user (not dynamically allocated).*\n*   Note it is assumed the Extension desc. header ('!') has been read.\t      *\n******************************************************************************/\nint CGIFFF DGifGetExtension(CGIFFF GifFileType *GifFile, int *ExtCode,\n\t\t\t\t\t\t    CGIFFF GifByteType **Extension)\n{\n    GifByteType Buf;\n    GifFilePrivateType *Private = (GifFilePrivateType *) GifFile->Private;\n\n\n    if (!IS_READABLE(Private)) {\n\t/* This file was NOT open for reading: */\n\t_GifError = D_GIF_ERR_NOT_READABLE;\n\treturn GIF_ERROR;\n    }\n\n    if (fread(&Buf, 1, 1, Private->File) != 1) {\n\t_GifError = D_GIF_ERR_READ_FAILED;\n\treturn GIF_ERROR;\n    }\n    *ExtCode = Buf;\n\n    return DGifGetExtensionNext(GifFile, Extension);\n}\n\n/******************************************************************************\n*   Get a following extension block (see GIF manual) from gif file. This      *\n* routine sould be called until NULL Extension is returned.\t\t      *\n*   The Extension should NOT be freed by the user (not dynamically allocated).*\n******************************************************************************/\nint CGIFFF DGifGetExtensionNext(CGIFFF GifFileType *GifFile, CGIFFF GifByteType **Extension)\n{\n    GifByteType Buf;\n    GifFilePrivateType *Private = (GifFilePrivateType *) GifFile->Private;\n\n    if (fread(&Buf, 1, 1, Private->File) != 1) {\n\t_GifError = D_GIF_ERR_READ_FAILED;\n\treturn GIF_ERROR;\n    }\n    if (Buf > 0) {\n\t*Extension = Private->Buf;           /* Use private unused buffer. */\n\t(*Extension)[0] = Buf;  /* Pascal strings notation (pos. 0 is len.). */\n\tif (fread(&((*Extension)[1]), 1, Buf, Private->File) != Buf) {\n\t    _GifError = D_GIF_ERR_READ_FAILED;\n\t    return GIF_ERROR;\n\t}\n    }\n    else\n\t*Extension = NULL;\n\n    return GIF_OK;\n}\n\n/******************************************************************************\n*   This routine should be called last, to close the GIF file.\t\t      *\n******************************************************************************/\nint CGIFFF DGifCloseFile(CGIFFF GifFileType *GifFile)\n{\n    GifFilePrivateType *Private;\n\n    if (GifFile == NULL) return GIF_ERROR;\n\n    Private = (GifFilePrivateType *) GifFile->Private;\n\n    if (!IS_READABLE(Private)) {\n\t/* This file was NOT open for reading: */\n\t_GifError = D_GIF_ERR_NOT_READABLE;\n\treturn GIF_ERROR;\n    }\n\n    #if 0 /**** pts ****/\n    if (GifFile->Image.ColorMap)\n\tFreeMapObject(GifFile->Image.ColorMap);\n    #endif\n    if (GifFile->SColorMap)\n\tFreeMapObject(GifFile->SColorMap);\n    if (Private)\n\tfree((char *) Private);\n    if (GifFile->SavedImages)\n\tFreeSavedImages(GifFile);\n    free(GifFile);\n\n#if 0 /**** pts ****/\n    if (fclose(File) != 0) {\n\t_GifError = D_GIF_ERR_CLOSE_FAILED;\n\treturn GIF_ERROR;\n    }\n#endif\n    return GIF_OK;\n}\n\n/******************************************************************************\n*   Get 2 bytes (word) from the given file:\t\t\t\t      *\n******************************************************************************/\nstatic int DGifGetWord(FILE *File, int *Word)\n{\n    unsigned char c[2];\n\n    if (fread(c, 1, 2, File) != 2) {\n\tCGIFFF _GifError = D_GIF_ERR_READ_FAILED;\n\treturn GIF_ERROR;\n    }\n\n    *Word = (((unsigned int) c[1]) << 8) + c[0];\n    return GIF_OK;\n}\n\n/******************************************************************************\n*   Get the image code in compressed form.  his routine can be called if the  *\n* information needed to be piped out as is. Obviously this is much faster     *\n* than decoding and encoding again. This routine should be followed by calls  *\n* to DGifGetCodeNext, until NULL block is returned.\t\t\t      *\n*   The block should NOT be freed by the user (not dynamically allocated).    *\n******************************************************************************/\nint CGIFFF DGifGetCode(CGIFFF GifFileType *GifFile, int *CodeSize, CGIFFF GifByteType **CodeBlock)\n{\n    GifFilePrivateType *Private = (GifFilePrivateType *) GifFile->Private;\n\n    if (!IS_READABLE(Private)) {\n\t/* This file was NOT open for reading: */\n\t_GifError = D_GIF_ERR_NOT_READABLE;\n\treturn GIF_ERROR;\n    }\n\n    *CodeSize = Private->BitsPerPixel;\n\n    return DGifGetCodeNext(GifFile, CodeBlock);\n}\n\n/******************************************************************************\n*   Continue to get the image code in compressed form. This routine should be *\n* called until NULL block is returned.\t\t\t\t\t      *\n*   The block should NOT be freed by the user (not dynamically allocated).    *\n******************************************************************************/\nint CGIFFF DGifGetCodeNext(CGIFFF GifFileType *GifFile, CGIFFF GifByteType **CodeBlock)\n{\n    GifByteType Buf;\n    GifFilePrivateType *Private = (GifFilePrivateType *) GifFile->Private;\n\n    if (fread(&Buf, 1, 1, Private->File) != 1) {\n\t_GifError = D_GIF_ERR_READ_FAILED;\n\treturn GIF_ERROR;\n    }\n\n    if (Buf > 0) {\n\t*CodeBlock = Private->Buf;\t       /* Use private unused buffer. */\n\t(*CodeBlock)[0] = Buf;  /* Pascal strings notation (pos. 0 is len.). */\n\tif (fread(&((*CodeBlock)[1]), 1, Buf, Private->File) != Buf) {\n\t    _GifError = D_GIF_ERR_READ_FAILED;\n\t    return GIF_ERROR;\n\t}\n    }\n    else {\n\t*CodeBlock = NULL;\n\tPrivate->Buf[0] = 0;\t\t   /* Make sure the buffer is empty! */\n\tPrivate->PixelCount = 0;   /* And local info. indicate image read. */\n    }\n\n    return GIF_OK;\n}\n\n/******************************************************************************\n*   Setup the LZ decompression for this image:\t\t\t\t      *\n******************************************************************************/\nstatic int DGifSetupDecompress(CGIFFF GifFileType *GifFile)\n{\n    int i, BitsPerPixel;\n    CGIFFF GifByteType CodeSize;\n    unsigned int *Prefix;\n    GifFilePrivateType *Private = (GifFilePrivateType *) GifFile->Private;\n\n    if (fread(&CodeSize, 1, 1, Private->File) != 1)  /* Read Code size from file. */\n      return GIF_ERROR;\n    BitsPerPixel = CodeSize;\n\n    Private->Buf[0] = 0;\t\t\t      /* Input Buffer empty. */\n    Private->BitsPerPixel = BitsPerPixel;\n    Private->ClearCode = (1 << BitsPerPixel);\n    Private->EOFCode = Private->ClearCode + 1;\n    Private->RunningCode = Private->EOFCode + 1;\n    Private->RunningBits = BitsPerPixel + 1;\t /* Number of bits per code. */\n    Private->MaxCode1 = 1 << Private->RunningBits;     /* Max. code + 1. */\n    Private->StackPtr = 0;\t\t    /* No pixels on the pixel stack. */\n    Private->LastCode = NO_SUCH_CODE;\n    Private->CrntShiftState = 0;\t/* No information in CrntShiftDWord. */\n    Private->CrntShiftDWord = 0;\n\n    Prefix = Private->Prefix;\n    for (i = 0; i <= LZ_MAX_CODE; i++) Prefix[i] = NO_SUCH_CODE;\n\n    return GIF_OK;\n}\n\n/******************************************************************************\n*   The LZ decompression routine:\t\t\t\t\t      *\n*   This version decompress the given gif file into Line of length LineLen.   *\n*   This routine can be called few times (one per scan line, for example), in *\n* order the complete the whole image.\t\t\t\t\t      *\n******************************************************************************/\nstatic int DGifDecompressLine(CGIFFF GifFileType *GifFile, CGIFFF GifPixelType *Line,\n\t\t\t\t\t\t\t\tint LineLen)\n{\n    int i = 0, j, CrntCode, EOFCode, ClearCode, CrntPrefix, LastCode, StackPtr;\n    CGIFFF GifByteType *Stack, *Suffix;\n    unsigned int *Prefix;\n    GifFilePrivateType *Private = (GifFilePrivateType *) GifFile->Private;\n\n    StackPtr = Private->StackPtr;\n    Prefix = Private->Prefix;\n    Suffix = Private->Suffix;\n    Stack = Private->Stack;\n    EOFCode = Private->EOFCode;\n    ClearCode = Private->ClearCode;\n    LastCode = Private->LastCode;\n\n    if (StackPtr != 0) {\n\t/* Let pop the stack off before continueing to read the gif file: */\n\twhile (StackPtr != 0 && i < LineLen) Line[i++] = Stack[--StackPtr];\n    }\n\n    while (i < LineLen) {\t\t\t    /* Decode LineLen items. */\n\tif (DGifDecompressInput(Private, &CrntCode) == GIF_ERROR)\n    \t    return GIF_ERROR;\n\n        /*fprintf(stderr,\"CrntCode=0x%x\\n\",CrntCode);*/\n\tif (CrntCode == EOFCode) {\n\t    /* Note however that usually we will not be here as we will stop */\n\t    /* decoding as soon as we got all the pixel, or EOF code will    */\n\t    /* not be read at all, and DGifGetLine/Pixel clean everything.   */\n\t    if (i != LineLen - 1 || Private->PixelCount != 0) {\n\t\tCGIFFF _GifError = D_GIF_ERR_EOF_TOO_SOON;\n\t\treturn GIF_ERROR;\n\t    }\n\t    i++;\n\t}\n\telse if (CrntCode == ClearCode) {\n\t    /* We need to start over again: */\n\t    for (j = 0; j <= LZ_MAX_CODE; j++) Prefix[j] = NO_SUCH_CODE;\n\t    Private->RunningCode = Private->EOFCode + 1;\n\t    Private->RunningBits = Private->BitsPerPixel + 1;\n\t    Private->MaxCode1 = 1 << Private->RunningBits;\n\t    LastCode = Private->LastCode = NO_SUCH_CODE;\n\t}\n\telse {\n\t    /* Its regular code - if in pixel range simply add it to output  */\n\t    /* stream, otherwise trace to codes linked list until the prefix */\n\t    /* is in pixel range:\t\t\t\t\t     */\n\t    if (CrntCode < ClearCode) {\n\t\t/* This is simple - its pixel scalar, so add it to output:   */\n\t\tLine[i++] = CrntCode;\n\t    }\n\t    else {\n\t\t/* Its a code to needed to be traced: trace the linked list  */\n\t\t/* until the prefix is a pixel, while pushing the suffix     */\n\t\t/* pixels on our stack. If we done, pop the stack in reverse */\n\t\t/* (thats what stack is good for!) order to output.\t     */\n\t\tif (Prefix[CrntCode] == NO_SUCH_CODE) {\n\t\t    /* Only allowed if CrntCode is exactly the running code: */\n\t\t    /* In that case CrntCode = XXXCode, CrntCode or the\t     */\n\t\t    /* prefix code is last code and the suffix char is\t     */\n\t\t    /* exactly the prefix of last code!\t\t\t     */\n\t\t    if (CrntCode == Private->RunningCode - 2) {\n\t\t\tCrntPrefix = LastCode;\n\t\t\tSuffix[Private->RunningCode - 2] =\n\t\t\tStack[StackPtr++] = DGifGetPrefixChar(Prefix,\n\t\t\t\t\t\t\tLastCode, ClearCode);\n\t\t    }\n\t\t    else {\n\t\t\tCGIFFF _GifError = D_GIF_ERR_IMAGE_DEFECT;\n\t\t\treturn GIF_ERROR;\n\t\t    }\n\t\t}\n\t\telse\n\t\t    CrntPrefix = CrntCode;\n\n\t\t/* Now (if image is O.K.) we should not get an NO_SUCH_CODE  */\n\t\t/* During the trace. As we might loop forever, in case of    */\n\t\t/* defective image, we count the number of loops we trace    */\n\t\t/* and stop if we got LZ_MAX_CODE. obviously we can not      */\n\t\t/* loop more than that.\t\t\t\t\t     */\n\t\tj = 0;\n\t\twhile (j++ <= LZ_MAX_CODE &&\n\t\t       CrntPrefix > ClearCode &&\n\t\t       CrntPrefix <= LZ_MAX_CODE) {\n\t\t    Stack[StackPtr++] = Suffix[CrntPrefix];\n\t\t    CrntPrefix = Prefix[CrntPrefix];\n\t\t}\n\t\tif (j >= LZ_MAX_CODE || CrntPrefix > LZ_MAX_CODE) {\n\t\t    CGIFFF _GifError = D_GIF_ERR_IMAGE_DEFECT;\n\t\t    return GIF_ERROR;\n\t\t}\n\t\t/* Push the last character on stack: */\n\t\tStack[StackPtr++] = CrntPrefix;\n\n\t\t/* Now lets pop all the stack into output: */\n\t\twhile (StackPtr != 0 && i < LineLen)\n\t\t    Line[i++] = Stack[--StackPtr];\n\t    }\n\t    if (LastCode != NO_SUCH_CODE) {\n\t\tPrefix[Private->RunningCode - 2] = LastCode;\n\n\t\tif (CrntCode == Private->RunningCode - 2) {\n\t\t    /* Only allowed if CrntCode is exactly the running code: */\n\t\t    /* In that case CrntCode = XXXCode, CrntCode or the\t     */\n\t\t    /* prefix code is last code and the suffix char is\t     */\n\t\t    /* exactly the prefix of last code!\t\t\t     */\n\t\t    Suffix[Private->RunningCode - 2] =\n\t\t\tDGifGetPrefixChar(Prefix, LastCode, ClearCode);\n\t\t}\n\t\telse {\n\t\t    Suffix[Private->RunningCode - 2] =\n\t\t\tDGifGetPrefixChar(Prefix, CrntCode, ClearCode);\n\t\t}\n\t    }\n\t    LastCode = CrntCode;\n\t}\n    }\n\n    Private->LastCode = LastCode;\n    Private->StackPtr = StackPtr;\n\n    return GIF_OK;\n}\n\n/******************************************************************************\n* Routine to trace the Prefixes linked list until we get a prefix which is    *\n* not code, but a pixel value (less than ClearCode). Returns that pixel value.*\n* If image is defective, we might loop here forever, so we limit the loops to *\n* the maximum possible if image O.k. - LZ_MAX_CODE times.\t\t      *\n******************************************************************************/\nstatic int DGifGetPrefixChar(unsigned int *Prefix, int Code, int ClearCode)\n{\n    int i = 0;\n\n    while (Code > ClearCode && i++ <= LZ_MAX_CODE) Code = Prefix[Code];\n    return Code;\n}\n\n/******************************************************************************\n*   Interface for accessing the LZ codes directly. Set Code to the real code  *\n* (12bits), or to -1 if EOF code is returned.\t\t\t\t      *\n******************************************************************************/\nint CGIFFF DGifGetLZCodes(CGIFFF GifFileType *GifFile, int *Code)\n{\n    GifByteType *CodeBlock;\n    GifFilePrivateType *Private = (GifFilePrivateType *) GifFile->Private;\n\n    if (!IS_READABLE(Private)) {\n\t/* This file was NOT open for reading: */\n\t_GifError = D_GIF_ERR_NOT_READABLE;\n\treturn GIF_ERROR;\n    }\n\n    if (DGifDecompressInput(Private, Code) == GIF_ERROR)\n\treturn GIF_ERROR;\n\n    if (*Code == Private->EOFCode) {\n\t/* Skip rest of codes (hopefully only NULL terminating block): */\n\tdo if (DGifGetCodeNext(GifFile, &CodeBlock) == GIF_ERROR)\n    \t    return GIF_ERROR;\n\twhile (CodeBlock != NULL);\n\n\t*Code = -1;\n    }\n    else if (*Code == Private->ClearCode) {\n\t/* We need to start over again: */\n\tPrivate->RunningCode = Private->EOFCode + 1;\n\tPrivate->RunningBits = Private->BitsPerPixel + 1;\n\tPrivate->MaxCode1 = 1 << Private->RunningBits;\n    }\n\n    return GIF_OK;\n}\n\n/******************************************************************************\n*   The LZ decompression input routine:\t\t\t\t\t      *\n*   This routine is responsable for the decompression of the bit stream from  *\n* 8 bits (bytes) packets, into the real codes.\t\t\t\t      *\n*   Returns GIF_OK if read succesfully.\t\t\t\t\t      *\n******************************************************************************/\nstatic int DGifDecompressInput(GifFilePrivateType *Private, int *Code)\n{\n    CGIFFF GifByteType NextByte;\n    static unsigned int CodeMasks[] = {\n\t0x0000, 0x0001, 0x0003, 0x0007,\n\t0x000f, 0x001f, 0x003f, 0x007f,\n\t0x00ff, 0x01ff, 0x03ff, 0x07ff,\n\t0x0fff\n    };\n\n    /* The image can't contain more than LZ_BITS per code. */\n    if (Private->RunningBits > LZ_BITS) {\n        return GIF_ERROR;\n    }\n    \n\n    while (Private->CrntShiftState < Private->RunningBits) {\n\t/* Needs to get more bytes from input stream for next code: */\n\tif (DGifBufferedInput(Private->File, Private->Buf, &NextByte)\n\t    == GIF_ERROR) {\n\t    return GIF_ERROR;\n\t}\n\tPrivate->CrntShiftDWord |=\n\t\t((unsigned long) NextByte) << Private->CrntShiftState;\n\tPrivate->CrntShiftState += 8;\n    }\n    *Code = Private->CrntShiftDWord & CodeMasks[Private->RunningBits];\n\n    Private->CrntShiftDWord >>= Private->RunningBits;\n    Private->CrntShiftState -= Private->RunningBits;\n\n    /* If code cannt fit into RunningBits bits, must raise its size. Note  */\n    /* however that codes above 4095 are used for special signaling.       */\n    /* If we're using LZ_BITS bits already and we're at the max code, just */\n    /* keep using the table as it is, don't increment Private->RunningCode.*/ \n    if (Private->RunningCode < LZ_MAX_CODE + 2 &&\n\t++Private->RunningCode > Private->MaxCode1 &&\n\tPrivate->RunningBits < LZ_BITS) {\n\tPrivate->MaxCode1 <<= 1;\n\tPrivate->RunningBits++;\n    }\n    return GIF_OK;\n}\n\n/******************************************************************************\n*   This routines read one gif data block at a time and buffers it internally *\n* so that the decompression routine could access it.\t\t\t      *\n*   The routine returns the next byte from its internal buffer (or read next  *\n* block in if buffer empty) and returns GIF_OK if succesful.\t\t      *\n******************************************************************************/\nstatic int DGifBufferedInput(FILE *File, CGIFFF GifByteType *Buf,\n\t\t\t\t\t\t      CGIFFF GifByteType *NextByte)\n{\n    if (Buf[0] == 0) {\n\t/* Needs to read the next buffer - this one is empty: */\n\tif (fread(Buf, 1, 1, File) != 1)\n\t{\n\t    CGIFFF _GifError = D_GIF_ERR_READ_FAILED;\n\t    return GIF_ERROR;\n\t}\n\tif (fread(&Buf[1], 1, Buf[0], File) != Buf[0])\n\t{\n\t    CGIFFF _GifError = D_GIF_ERR_READ_FAILED;\n\t    return GIF_ERROR;\n\t}\n\t*NextByte = Buf[1];\n\tBuf[1] = 2;\t   /* We use now the second place as last char read! */\n\tBuf[0]--;\n    }\n    else {\n\t*NextByte = Buf[Buf[1]++];\n\tBuf[0]--;\n    }\n\n    return GIF_OK;\n}\n\n/******************************************************************************\n* This routine reads an entire GIF into core, hanging all its state info off  *\n* the GifFileType pointer.  Call DGifOpenFileName() or DGifOpenFileHandle()   *\n* first to initialize I/O.  Its inverse is EGifSpew().\t\t\t      *\n******************************************************************************/\nint CGIFFF DGifSlurp(CGIFFF GifFileType *GifFile)\n{\n    static unsigned InterlacedOffset[] = { 0, 4, 2, 1 }, /* The way Interlaced image should. */\n                    InterlacedJumps[] = { 8, 8, 4, 2 };  /* be read - offsets and jumps... */\n    /**** pts: unused vars ****/\n    /* int i, j, Error, ImageSize; */\n    int ext_code;\n\n    GifRecordType RecordType;\n    /**** pts ****/\n    SavedImage *sp=0; /**** pts: avoid gcc warning */\n    /** Extension info of next SavedImage */\n    SavedImage ext;\n    /** No-extension info */\n    SavedImage noext;\n\n    GifByteType *ExtData;\n\n    /**** pts ****/\n    memset(&noext, 0, sizeof(noext));\n    noext.delay=0;\n    noext.dispose=0;\n    noext.iter=1;\n    noext.transp=(-1);\n    noext.ExtensionBlocks=NULL;\n    noext.ExtensionBlockCount=0;\n    ext=noext;\n\n    /**** pts ****/\n    GifFile->SavedImages=0;\n\n    do {\n\tif (DGifGetRecordType(GifFile, &RecordType) == GIF_ERROR)\n\t    return(GIF_ERROR);\n\n\tswitch (RecordType) {\n\t    case IMAGE_DESC_RECORD_TYPE:\n\t\tif (DGifGetImageDesc(GifFile) == GIF_ERROR)\n\t\t    return(GIF_ERROR);\n\n                /**** pts: DGifGetImageDesc has already allocated the mem ****/\n\t\tsp = &GifFile->SavedImages[GifFile->ImageCount-1];\n\t\t/**** pts: apply extensions to the image just read */\n\t\text.RasterBits=sp->RasterBits;\n\t\text.ImageDesc=sp->ImageDesc;\n\t\t*sp=ext;\n\t\text=noext;\n\n\t\t/**** pts ****/\n\t\tsp->RasterBits = (GifPixelType*) xmalloc((0L+sp->ImageDesc.Width) * sp->ImageDesc.Height * sizeof(GifPixelType));\n\t\tif (sp->ImageDesc.Interlace) {\n\t\t  unsigned i, j, Height=sp->ImageDesc.Height, Width=sp->ImageDesc.Width;\n\t\t  /* Need to perform 4 passes on the images: */\n \t\t  for (i = 0; i < 4; i++)\n\t\t    for (j = InterlacedOffset[i]; j < Height; j += InterlacedJumps[i])\n\t\t      if (DGifGetLine(GifFile, sp->RasterBits+Width*j, Width) != GIF_OK) return GIF_ERROR;\n\t\t} else {\n\t\t  if (DGifGetLine(GifFile, sp->RasterBits, (0L+sp->ImageDesc.Width) * sp->ImageDesc.Height)\n\t\t      == GIF_ERROR)\n\t\t      return(GIF_ERROR);\n\t\t}\n\t\tbreak;\n\n\t    case EXTENSION_RECORD_TYPE:\n\n\t\tif (DGifGetExtension(GifFile,&ext_code,&ExtData)==GIF_ERROR)\n\t\t    return(GIF_ERROR);\n\t\tif (ExtData!=NULL) {\n\t\t    #if 0 /**** pts ****/\n\t\t      ep = &ext.ExtensionBlocks[ext.ExtensionBlockCount++];\n\t\t      ep->ByteCount = ExtData[0];\n\t\t      ep->Bytes = (GifByteType *)xmalloc(ep->ByteCount * sizeof(GifByteType));\n\t\t      memcpy(ep->Bytes, ExtData, ep->ByteCount * sizeof(char));\n\t\t    #else\n                      /**** pts ****/\n                      if (0xf9==(unsigned char)(ext_code)) {\n                        if (ExtData[0] < 4) { ext_too_short:\n                          _GifError = D_GIF_ERR_EXT_TOO_SHORT;\n                          return GIF_ERROR;\n                        }\n                        ext.dispose=ExtData[1]>>2;\n                        ext.delay=(ExtData[3] << 8) | ExtData[2];\n                        if ((ExtData[1] & 0x01) == 1) {\n                          if (ExtData[0] < 5) goto ext_too_short;\n                          ext.transp=ExtData[4];\n                        }\n                      } else if (0xff==(unsigned char)(ext_code)) {\n                        if (ExtData[0] < 4) goto ext_too_short;\n                        ext.iter=(ExtData[3] << 8) | ExtData[2];\n                      } else {\n                        AddExtensionBlock(&ext, ExtData[0], ExtData+1);\n                        ext.ExtensionBlocks[ext.ExtensionBlockCount-1].code=ext_code;\n                      }\n\t\t    #endif\n\t\t    while (1) {\n\t\t        if (DGifGetExtensionNext(GifFile, &ExtData) == GIF_ERROR)\n\t\t\t  return(GIF_ERROR);\n\t\t        #if 0 /**** pts ****/\n  \t\t\t  ep = &ext.ExtensionBlocks[ext.ExtensionBlockCount++];\n  \t\t\t  ep->ByteCount = ExtData[0];\n\t\t\t  ep->Bytes = (GifByteType *)xmalloc(ep->ByteCount * sizeof(GifByteType));\n  \t\t\t  memcpy(ep->Bytes,ExtData,ep->ByteCount * sizeof(char));\n  \t\t\t#else\n  \t\t\t  if (ExtData==NULL) break;\n                          AddExtensionBlock(&ext, ExtData[0], ExtData+1);\n                          ext.ExtensionBlocks[ext.ExtensionBlockCount-1].code=ext_code;\n  \t\t\t#endif\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    case TERMINATE_RECORD_TYPE:\n\t\tbreak;\n\n\t    default:\t/* Should be trapped by DGifGetRecordType */\n\t\tbreak;\n\t}\n    }\n    while\n\t(RecordType != TERMINATE_RECORD_TYPE);\n\n    return(GIF_OK);\n}\n\n/* __END__ */\n"], "filenames": ["cgif.c"], "buggy_code_start_loc": [1554], "buggy_code_end_loc": [1555], "fixing_code_start_loc": [1554], "fixing_code_end_loc": [1556], "type": "CWE-787", "message": "There is an invalid memory access bug in cgif.c that leads to a Segmentation fault in sam2p 0.49.4. A crafted input will lead to a denial of service or possibly unspecified other impact.", "other": {"cve": {"id": "CVE-2020-19491", "sourceIdentifier": "cve@mitre.org", "published": "2021-07-21T18:15:09.030", "lastModified": "2022-06-28T14:11:45.273", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "There is an invalid memory access bug in cgif.c that leads to a Segmentation fault in sam2p 0.49.4. A crafted input will lead to a denial of service or possibly unspecified other impact."}, {"lang": "es", "value": "Se presenta un error de acceso a memoria no v\u00e1lida en el archivo cgif.c que conlleva a un Fallo de Segmentaci\u00f3n en sam2p versi\u00f3n 0.49.4. Una entrada dise\u00f1ada conllevar\u00eda a una denegaci\u00f3n de servicio o posiblemente otro impacto no especificado"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:sam2p_project:sam2p:0.49.4:*:*:*:*:*:*:*", "matchCriteriaId": "EE79927B-648D-46F8-ACDF-5E96440FDD02"}]}]}], "references": [{"url": "https://github.com/pts/sam2p/commit/1d62cf8964bfcafa6561c4c3bb66d4aa4c529a73", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/pts/sam2p/issues/67", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/pts/sam2p/commit/1d62cf8964bfcafa6561c4c3bb66d4aa4c529a73"}}