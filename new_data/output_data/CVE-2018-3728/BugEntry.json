{"buggy_code": ["'use strict';\n\n// Load modules\n\nconst Assert = require('assert');\nconst Crypto = require('crypto');\nconst Path = require('path');\nconst Util = require('util');\n\nconst Escape = require('./escape');\n\n\n// Declare internals\n\nconst internals = {};\n\n\n// Clone object or array\n\nexports.clone = function (obj, seen) {\n\n    if (typeof obj !== 'object' ||\n        obj === null) {\n\n        return obj;\n    }\n\n    seen = seen || new Map();\n\n    const lookup = seen.get(obj);\n    if (lookup) {\n        return lookup;\n    }\n\n    let newObj;\n    let cloneDeep = false;\n\n    if (!Array.isArray(obj)) {\n        if (Buffer.isBuffer(obj)) {\n            newObj = Buffer.from(obj);\n        }\n        else if (obj instanceof Date) {\n            newObj = new Date(obj.getTime());\n        }\n        else if (obj instanceof RegExp) {\n            newObj = new RegExp(obj);\n        }\n        else {\n            const proto = Object.getPrototypeOf(obj);\n            if (proto &&\n                proto.isImmutable) {\n\n                newObj = obj;\n            }\n            else {\n                newObj = Object.create(proto);\n                cloneDeep = true;\n            }\n        }\n    }\n    else {\n        newObj = [];\n        cloneDeep = true;\n    }\n\n    seen.set(obj, newObj);\n\n    if (cloneDeep) {\n        const keys = Object.getOwnPropertyNames(obj);\n        for (let i = 0; i < keys.length; ++i) {\n            const key = keys[i];\n            const descriptor = Object.getOwnPropertyDescriptor(obj, key);\n            if (descriptor &&\n                (descriptor.get ||\n                    descriptor.set)) {\n\n                Object.defineProperty(newObj, key, descriptor);\n            }\n            else {\n                newObj[key] = exports.clone(obj[key], seen);\n            }\n        }\n    }\n\n    return newObj;\n};\n\n\n// Merge all the properties of source into target, source wins in conflict, and by default null and undefined from source are applied\n\n/*eslint-disable */\nexports.merge = function (target, source, isNullOverride /* = true */, isMergeArrays /* = true */) {\n    /*eslint-enable */\n\n    exports.assert(target && typeof target === 'object', 'Invalid target value: must be an object');\n    exports.assert(source === null || source === undefined || typeof source === 'object', 'Invalid source value: must be null, undefined, or an object');\n\n    if (!source) {\n        return target;\n    }\n\n    if (Array.isArray(source)) {\n        exports.assert(Array.isArray(target), 'Cannot merge array onto an object');\n        if (isMergeArrays === false) {                                                  // isMergeArrays defaults to true\n            target.length = 0;                                                          // Must not change target assignment\n        }\n\n        for (let i = 0; i < source.length; ++i) {\n            target.push(exports.clone(source[i]));\n        }\n\n        return target;\n    }\n\n    const keys = Object.keys(source);\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i];\n        const value = source[key];\n        if (value &&\n            typeof value === 'object') {\n\n            if (!target[key] ||\n                typeof target[key] !== 'object' ||\n                (Array.isArray(target[key]) !== Array.isArray(value)) ||\n                value instanceof Date ||\n                Buffer.isBuffer(value) ||\n                value instanceof RegExp) {\n\n                target[key] = exports.clone(value);\n            }\n            else {\n                exports.merge(target[key], value, isNullOverride, isMergeArrays);\n            }\n        }\n        else {\n            if (value !== null &&\n                value !== undefined) {                              // Explicit to preserve empty strings\n\n                target[key] = value;\n            }\n            else if (isNullOverride !== false) {                    // Defaults to true\n                target[key] = value;\n            }\n        }\n    }\n\n    return target;\n};\n\n\n// Apply options to a copy of the defaults\n\nexports.applyToDefaults = function (defaults, options, isNullOverride) {\n\n    exports.assert(defaults && typeof defaults === 'object', 'Invalid defaults value: must be an object');\n    exports.assert(!options || options === true || typeof options === 'object', 'Invalid options value: must be true, falsy or an object');\n\n    if (!options) {                                                 // If no options, return null\n        return null;\n    }\n\n    const copy = exports.clone(defaults);\n\n    if (options === true) {                                         // If options is set to true, use defaults\n        return copy;\n    }\n\n    return exports.merge(copy, options, isNullOverride === true, false);\n};\n\n\n// Clone an object except for the listed keys which are shallow copied\n\nexports.cloneWithShallow = function (source, keys) {\n\n    if (!source ||\n        typeof source !== 'object') {\n\n        return source;\n    }\n\n    const storage = internals.store(source, keys);    // Move shallow copy items to storage\n    const copy = exports.clone(source);               // Deep copy the rest\n    internals.restore(copy, source, storage);       // Shallow copy the stored items and restore\n    return copy;\n};\n\n\ninternals.store = function (source, keys) {\n\n    const storage = {};\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i];\n        const value = exports.reach(source, key);\n        if (value !== undefined) {\n            storage[key] = value;\n            internals.reachSet(source, key, undefined);\n        }\n    }\n\n    return storage;\n};\n\n\ninternals.restore = function (copy, source, storage) {\n\n    const keys = Object.keys(storage);\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i];\n        internals.reachSet(copy, key, storage[key]);\n        internals.reachSet(source, key, storage[key]);\n    }\n};\n\n\ninternals.reachSet = function (obj, key, value) {\n\n    const path = key.split('.');\n    let ref = obj;\n    for (let i = 0; i < path.length; ++i) {\n        const segment = path[i];\n        if (i + 1 === path.length) {\n            ref[segment] = value;\n        }\n\n        ref = ref[segment];\n    }\n};\n\n\n// Apply options to defaults except for the listed keys which are shallow copied from option without merging\n\nexports.applyToDefaultsWithShallow = function (defaults, options, keys) {\n\n    exports.assert(defaults && typeof defaults === 'object', 'Invalid defaults value: must be an object');\n    exports.assert(!options || options === true || typeof options === 'object', 'Invalid options value: must be true, falsy or an object');\n    exports.assert(keys && Array.isArray(keys), 'Invalid keys');\n\n    if (!options) {                                                 // If no options, return null\n        return null;\n    }\n\n    const copy = exports.cloneWithShallow(defaults, keys);\n\n    if (options === true) {                                         // If options is set to true, use defaults\n        return copy;\n    }\n\n    const storage = internals.store(options, keys);   // Move shallow copy items to storage\n    exports.merge(copy, options, false, false);     // Deep copy the rest\n    internals.restore(copy, options, storage);      // Shallow copy the stored items and restore\n    return copy;\n};\n\n\n// Deep object or array comparison\n\nexports.deepEqual = function (obj, ref, options, seen) {\n\n    options = options || { prototype: true };\n\n    const type = typeof obj;\n\n    if (type !== typeof ref) {\n        return false;\n    }\n\n    if (type !== 'object' ||\n        obj === null ||\n        ref === null) {\n\n        if (obj === ref) {                                                      // Copied from Deep-eql, copyright(c) 2013 Jake Luer, jake@alogicalparadox.com, MIT Licensed, https://github.com/chaijs/deep-eql\n            return obj !== 0 || 1 / obj === 1 / ref;        // -0 / +0\n        }\n\n        return obj !== obj && ref !== ref;                  // NaN\n    }\n\n    seen = seen || [];\n    if (seen.indexOf(obj) !== -1) {\n        return true;                            // If previous comparison failed, it would have stopped execution\n    }\n\n    seen.push(obj);\n\n    if (Array.isArray(obj)) {\n        if (!Array.isArray(ref)) {\n            return false;\n        }\n\n        if (!options.part && obj.length !== ref.length) {\n            return false;\n        }\n\n        for (let i = 0; i < obj.length; ++i) {\n            if (options.part) {\n                let found = false;\n                for (let j = 0; j < ref.length; ++j) {\n                    if (exports.deepEqual(obj[i], ref[j], options)) {\n                        found = true;\n                        break;\n                    }\n                }\n\n                return found;\n            }\n\n            if (!exports.deepEqual(obj[i], ref[i], options)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    if (Buffer.isBuffer(obj)) {\n        if (!Buffer.isBuffer(ref)) {\n            return false;\n        }\n\n        if (obj.length !== ref.length) {\n            return false;\n        }\n\n        for (let i = 0; i < obj.length; ++i) {\n            if (obj[i] !== ref[i]) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    if (obj instanceof Date) {\n        return (ref instanceof Date && obj.getTime() === ref.getTime());\n    }\n\n    if (obj instanceof RegExp) {\n        return (ref instanceof RegExp && obj.toString() === ref.toString());\n    }\n\n    if (options.prototype) {\n        if (Object.getPrototypeOf(obj) !== Object.getPrototypeOf(ref)) {\n            return false;\n        }\n    }\n\n    const keys = Object.getOwnPropertyNames(obj);\n\n    if (!options.part && keys.length !== Object.getOwnPropertyNames(ref).length) {\n        return false;\n    }\n\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i];\n        const descriptor = Object.getOwnPropertyDescriptor(obj, key);\n        if (descriptor.get) {\n            if (!exports.deepEqual(descriptor, Object.getOwnPropertyDescriptor(ref, key), options, seen)) {\n                return false;\n            }\n        }\n        else if (!exports.deepEqual(obj[key], ref[key], options, seen)) {\n            return false;\n        }\n    }\n\n    return true;\n};\n\n\n// Remove duplicate items from array\n\nexports.unique = (array, key) => {\n\n    let result;\n    if (key) {\n        result = [];\n        const index = new Set();\n        array.forEach((item) => {\n\n            const identifier = item[key];\n            if (!index.has(identifier)) {\n                index.add(identifier);\n                result.push(item);\n            }\n        });\n    }\n    else {\n        result = Array.from(new Set(array));\n    }\n\n    return result;\n};\n\n\n// Convert array into object\n\nexports.mapToObject = function (array, key) {\n\n    if (!array) {\n        return null;\n    }\n\n    const obj = {};\n    for (let i = 0; i < array.length; ++i) {\n        if (key) {\n            if (array[i][key]) {\n                obj[array[i][key]] = true;\n            }\n        }\n        else {\n            obj[array[i]] = true;\n        }\n    }\n\n    return obj;\n};\n\n\n// Find the common unique items in two arrays\n\nexports.intersect = function (array1, array2, justFirst) {\n\n    if (!array1 || !array2) {\n        return [];\n    }\n\n    const common = [];\n    const hash = (Array.isArray(array1) ? exports.mapToObject(array1) : array1);\n    const found = {};\n    for (let i = 0; i < array2.length; ++i) {\n        if (hash[array2[i]] && !found[array2[i]]) {\n            if (justFirst) {\n                return array2[i];\n            }\n\n            common.push(array2[i]);\n            found[array2[i]] = true;\n        }\n    }\n\n    return (justFirst ? null : common);\n};\n\n\n// Test if the reference contains the values\n\nexports.contain = function (ref, values, options) {\n\n    /*\n        string -> string(s)\n        array -> item(s)\n        object -> key(s)\n        object -> object (key:value)\n    */\n\n    let valuePairs = null;\n    if (typeof ref === 'object' &&\n        typeof values === 'object' &&\n        !Array.isArray(ref) &&\n        !Array.isArray(values)) {\n\n        valuePairs = values;\n        values = Object.keys(values);\n    }\n    else {\n        values = [].concat(values);\n    }\n\n    options = options || {};            // deep, once, only, part\n\n    exports.assert(typeof ref === 'string' || typeof ref === 'object', 'Reference must be string or an object');\n    exports.assert(values.length, 'Values array cannot be empty');\n\n    let compare;\n    let compareFlags;\n    if (options.deep) {\n        compare = exports.deepEqual;\n\n        const hasOnly = options.hasOwnProperty('only');\n        const hasPart = options.hasOwnProperty('part');\n\n        compareFlags = {\n            prototype: hasOnly ? options.only : hasPart ? !options.part : false,\n            part: hasOnly ? !options.only : hasPart ? options.part : true\n        };\n    }\n    else {\n        compare = (a, b) => a === b;\n    }\n\n    let misses = false;\n    const matches = new Array(values.length);\n    for (let i = 0; i < matches.length; ++i) {\n        matches[i] = 0;\n    }\n\n    if (typeof ref === 'string') {\n        let pattern = '(';\n        for (let i = 0; i < values.length; ++i) {\n            const value = values[i];\n            exports.assert(typeof value === 'string', 'Cannot compare string reference to non-string value');\n            pattern += (i ? '|' : '') + exports.escapeRegex(value);\n        }\n\n        const regex = new RegExp(pattern + ')', 'g');\n        const leftovers = ref.replace(regex, ($0, $1) => {\n\n            const index = values.indexOf($1);\n            ++matches[index];\n            return '';          // Remove from string\n        });\n\n        misses = !!leftovers;\n    }\n    else if (Array.isArray(ref)) {\n        for (let i = 0; i < ref.length; ++i) {\n            let matched = false;\n            for (let j = 0; j < values.length && matched === false; ++j) {\n                matched = compare(values[j], ref[i], compareFlags) && j;\n            }\n\n            if (matched !== false) {\n                ++matches[matched];\n            }\n            else {\n                misses = true;\n            }\n        }\n    }\n    else {\n        const keys = Object.getOwnPropertyNames(ref);\n        for (let i = 0; i < keys.length; ++i) {\n            const key = keys[i];\n            const pos = values.indexOf(key);\n            if (pos !== -1) {\n                if (valuePairs &&\n                    !compare(valuePairs[key], ref[key], compareFlags)) {\n\n                    return false;\n                }\n\n                ++matches[pos];\n            }\n            else {\n                misses = true;\n            }\n        }\n    }\n\n    let result = false;\n    for (let i = 0; i < matches.length; ++i) {\n        result = result || !!matches[i];\n        if ((options.once && matches[i] > 1) ||\n            (!options.part && !matches[i])) {\n\n            return false;\n        }\n    }\n\n    if (options.only &&\n        misses) {\n\n        return false;\n    }\n\n    return result;\n};\n\n\n// Flatten array\n\nexports.flatten = function (array, target) {\n\n    const result = target || [];\n\n    for (let i = 0; i < array.length; ++i) {\n        if (Array.isArray(array[i])) {\n            exports.flatten(array[i], result);\n        }\n        else {\n            result.push(array[i]);\n        }\n    }\n\n    return result;\n};\n\n\n// Convert an object key chain string ('a.b.c') to reference (object[a][b][c])\n\nexports.reach = function (obj, chain, options) {\n\n    if (chain === false ||\n        chain === null ||\n        typeof chain === 'undefined') {\n\n        return obj;\n    }\n\n    options = options || {};\n    if (typeof options === 'string') {\n        options = { separator: options };\n    }\n\n    const path = chain.split(options.separator || '.');\n    let ref = obj;\n    for (let i = 0; i < path.length; ++i) {\n        let key = path[i];\n        if (key[0] === '-' && Array.isArray(ref)) {\n            key = key.slice(1, key.length);\n            key = ref.length - key;\n        }\n\n        if (!ref ||\n            !((typeof ref === 'object' || typeof ref === 'function') && key in ref) ||\n            (typeof ref !== 'object' && options.functions === false)) {         // Only object and function can have properties\n\n            exports.assert(!options.strict || i + 1 === path.length, 'Missing segment', key, 'in reach path ', chain);\n            exports.assert(typeof ref === 'object' || options.functions === true || typeof ref !== 'function', 'Invalid segment', key, 'in reach path ', chain);\n            ref = options.default;\n            break;\n        }\n\n        ref = ref[key];\n    }\n\n    return ref;\n};\n\n\nexports.reachTemplate = function (obj, template, options) {\n\n    return template.replace(/{([^}]+)}/g, ($0, chain) => {\n\n        const value = exports.reach(obj, chain, options);\n        return (value === undefined || value === null ? '' : value);\n    });\n};\n\n\nexports.formatStack = function (stack) {\n\n    const trace = [];\n    for (let i = 0; i < stack.length; ++i) {\n        const item = stack[i];\n        trace.push([item.getFileName(), item.getLineNumber(), item.getColumnNumber(), item.getFunctionName(), item.isConstructor()]);\n    }\n\n    return trace;\n};\n\n\nexports.formatTrace = function (trace) {\n\n    const display = [];\n\n    for (let i = 0; i < trace.length; ++i) {\n        const row = trace[i];\n        display.push((row[4] ? 'new ' : '') + row[3] + ' (' + row[0] + ':' + row[1] + ':' + row[2] + ')');\n    }\n\n    return display;\n};\n\n\nexports.callStack = function (slice) {\n\n    // http://code.google.com/p/v8/wiki/JavaScriptStackTraceApi\n\n    const v8 = Error.prepareStackTrace;\n    Error.prepareStackTrace = function (_, stack) {\n\n        return stack;\n    };\n\n    const capture = {};\n    Error.captureStackTrace(capture, this);\n    const stack = capture.stack;\n\n    Error.prepareStackTrace = v8;\n\n    const trace = exports.formatStack(stack);\n\n    return trace.slice(1 + slice);\n};\n\n\nexports.displayStack = function (slice) {\n\n    const trace = exports.callStack(slice === undefined ? 1 : slice + 1);\n\n    return exports.formatTrace(trace);\n};\n\n\nexports.abortThrow = false;\n\n\nexports.abort = function (message, hideStack) {\n\n    if (process.env.NODE_ENV === 'test' || exports.abortThrow === true) {\n        throw new Error(message || 'Unknown error');\n    }\n\n    let stack = '';\n    if (!hideStack) {\n        stack = exports.displayStack(1).join('\\n\\t');\n    }\n    console.log('ABORT: ' + message + '\\n\\t' + stack);\n    process.exit(1);\n};\n\n\nexports.assert = function (condition, ...args) {\n\n    if (condition) {\n        return;\n    }\n\n    if (args.length === 1 && args[0] instanceof Error) {\n        throw args[0];\n    }\n\n    const msgs = args\n        .filter((arg) => arg !== '')\n        .map((arg) => {\n\n            return typeof arg === 'string' ? arg : arg instanceof Error ? arg.message : exports.stringify(arg);\n        });\n\n    throw new Assert.AssertionError({\n        message: msgs.join(' ') || 'Unknown error',\n        actual: false,\n        expected: true,\n        operator: '==',\n        stackStartFunction: exports.assert\n    });\n};\n\n\nexports.Bench = function () {\n\n    this.ts = 0;\n    this.reset();\n};\n\n\nexports.Bench.prototype.reset = function () {\n\n    this.ts = exports.Bench.now();\n};\n\n\nexports.Bench.prototype.elapsed = function () {\n\n    return exports.Bench.now() - this.ts;\n};\n\n\nexports.Bench.now = function () {\n\n    const ts = process.hrtime();\n    return (ts[0] * 1e3) + (ts[1] / 1e6);\n};\n\n\n// Escape string for Regex construction\n\nexports.escapeRegex = function (string) {\n\n    // Escape ^$.*+-?=!:|\\/()[]{},\n    return string.replace(/[\\^\\$\\.\\*\\+\\-\\?\\=\\!\\:\\|\\\\\\/\\(\\)\\[\\]\\{\\}\\,]/g, '\\\\$&');\n};\n\n\n// Base64url (RFC 4648) encode\n\nexports.base64urlEncode = function (value, encoding) {\n\n    exports.assert(typeof value === 'string' || Buffer.isBuffer(value), 'value must be string or buffer');\n    const buf = (Buffer.isBuffer(value) ? value : Buffer.from(value, encoding || 'binary'));\n    return buf.toString('base64').replace(/\\+/g, '-').replace(/\\//g, '_').replace(/\\=/g, '');\n};\n\n\n// Base64url (RFC 4648) decode\n\nexports.base64urlDecode = function (value, encoding) {\n\n    if (typeof value !== 'string') {\n\n        throw new Error('Value not a string');\n    }\n\n    if (!/^[\\w\\-]*$/.test(value)) {\n\n        throw new Error('Invalid character');\n    }\n\n    const buf = Buffer.from(value, 'base64');\n    return (encoding === 'buffer' ? buf : buf.toString(encoding || 'binary'));\n};\n\n\n// Escape attribute value for use in HTTP header\n\nexports.escapeHeaderAttribute = function (attribute) {\n\n    // Allowed value characters: !#$%&'()*+,-./:;<=>?@[]^_`{|}~ and space, a-z, A-Z, 0-9, \\, \"\n\n    exports.assert(/^[ \\w\\!#\\$%&'\\(\\)\\*\\+,\\-\\.\\/\\:;<\\=>\\?@\\[\\]\\^`\\{\\|\\}~\\\"\\\\]*$/.test(attribute), 'Bad attribute value (' + attribute + ')');\n\n    return attribute.replace(/\\\\/g, '\\\\\\\\').replace(/\\\"/g, '\\\\\"');                             // Escape quotes and slash\n};\n\n\nexports.escapeHtml = function (string) {\n\n    return Escape.escapeHtml(string);\n};\n\n\nexports.escapeJavaScript = function (string) {\n\n    return Escape.escapeJavaScript(string);\n};\n\n\nexports.escapeJson = function (string) {\n\n    return Escape.escapeJson(string);\n};\n\n\nexports.once = function (method) {\n\n    if (method._hoekOnce) {\n        return method;\n    }\n\n    let once = false;\n    const wrapped = function (...args) {\n\n        if (!once) {\n            once = true;\n            method.apply(null, args);\n        }\n    };\n\n    wrapped._hoekOnce = true;\n    return wrapped;\n};\n\n\nexports.isInteger = Number.isSafeInteger;\n\n\nexports.ignore = function () { };\n\n\nexports.inherits = Util.inherits;\n\n\nexports.format = Util.format;\n\n\nexports.transform = function (source, transform, options) {\n\n    exports.assert(source === null || source === undefined || typeof source === 'object' || Array.isArray(source), 'Invalid source object: must be null, undefined, an object, or an array');\n    const separator = (typeof options === 'object' && options !== null) ? (options.separator || '.') : '.';\n\n    if (Array.isArray(source)) {\n        const results = [];\n        for (let i = 0; i < source.length; ++i) {\n            results.push(exports.transform(source[i], transform, options));\n        }\n        return results;\n    }\n\n    const result = {};\n    const keys = Object.keys(transform);\n\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i];\n        const path = key.split(separator);\n        const sourcePath = transform[key];\n\n        exports.assert(typeof sourcePath === 'string', 'All mappings must be \".\" delineated strings');\n\n        let segment;\n        let res = result;\n\n        while (path.length > 1) {\n            segment = path.shift();\n            if (!res[segment]) {\n                res[segment] = {};\n            }\n            res = res[segment];\n        }\n        segment = path.shift();\n        res[segment] = exports.reach(source, sourcePath, options);\n    }\n\n    return result;\n};\n\n\nexports.uniqueFilename = function (path, extension) {\n\n    if (extension) {\n        extension = extension[0] !== '.' ? '.' + extension : extension;\n    }\n    else {\n        extension = '';\n    }\n\n    path = Path.resolve(path);\n    const name = [Date.now(), process.pid, Crypto.randomBytes(8).toString('hex')].join('-') + extension;\n    return Path.join(path, name);\n};\n\n\nexports.stringify = function (...args) {\n\n    try {\n        return JSON.stringify.apply(null, args);\n    }\n    catch (err) {\n        return '[Cannot display object: ' + err.message + ']';\n    }\n};\n\n\nexports.shallow = function (source) {\n\n    const target = {};\n    const keys = Object.keys(source);\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i];\n        target[key] = source[key];\n    }\n\n    return target;\n};\n\n\nexports.wait = function (timeout) {\n\n    return new Promise((resolve) => setTimeout(resolve, timeout));\n};\n\n\nexports.block = function () {\n\n    return new Promise(exports.ignore);\n};\n", "'use strict';\n\n// Load modules\n\nconst Fs = require('fs');\nconst Path = require('path');\nconst Util = require('util');\n\nconst Code = require('code');\nconst Hoek = require('../lib');\nconst Lab = require('lab');\n\n\n// Declare internals\n\nconst internals = {};\n\n\n// Test shortcuts\n\nconst { describe, it } = exports.lab = Lab.script();\nconst expect = Code.expect;\n\n\nconst nestedObj = {\n    v: [7, 8, 9],\n    w: /^something$/igm,\n    x: {\n        a: [1, 2, 3],\n        b: 123456,\n        c: new Date(),\n        d: /hi/igm,\n        e: /hello/\n    },\n    y: 'y',\n    z: new Date(1378775452757)\n};\n\ninternals.unique = {\n    item: {\n        objects: [nestedObj, { z: 'z' }]\n    }\n};\n\ninternals.unique.objectsByKey = {\n    dups: [internals.unique.item.objects[0], internals.unique.item.objects[1], internals.unique.item.objects[0]],\n    result: [internals.unique.item.objects[0], internals.unique.item.objects[1]]\n};\n\ninternals.unique.objects = {\n    dups: [internals.unique.item.objects[1], internals.unique.item.objects[0], internals.unique.item.objects[0]],\n    result: [internals.unique.item.objects[1], internals.unique.item.objects[0]]\n};\n\ninternals.unique.integers = {\n    dups: [1, 2, 3, 2, 2, 1, 3, 4, 5],\n    result: [1, 2, 3, 4, 5]\n};\n\ninternals.unique.strings = {\n    dups: ['a', 'b', 'c', 'd', 'a', 'c', 'e'],\n    result: ['a', 'b', 'c', 'd', 'e']\n};\n\ninternals.unique.mixed = {\n    dups: [1, 2, 'a', 'b', internals.unique.item.objects[0], 'a', '2', 3, internals.unique.item.objects[0]],\n    result: [1, 2, 'a', ',b', internals.unique.item.objects[0], 3]\n};\n\n\ndescribe('clone()', () => {\n\n    it('clones a nested object', () => {\n\n        const a = nestedObj;\n        const b = Hoek.clone(a);\n\n        expect(a).to.equal(b);\n        expect(a.z.getTime()).to.equal(b.z.getTime());\n    });\n\n    it('clones a null object', () => {\n\n        const b = Hoek.clone(null);\n\n        expect(b).to.equal(null);\n    });\n\n    it('should not convert undefined properties to null', () => {\n\n        const obj = { something: undefined };\n        const b = Hoek.clone(obj);\n\n        expect(typeof b.something).to.equal('undefined');\n    });\n\n    it('should not throw on circular reference', () => {\n\n        const a = {};\n        a.x = a;\n\n        expect(() => {\n\n            Hoek.clone(a);\n        }).to.not.throw();\n    });\n\n    it('clones circular reference', () => {\n\n        const x = {\n            'z': new Date()\n        };\n        x.y = x;\n\n        const b = Hoek.clone(x);\n        expect(Object.keys(b.y)).to.equal(Object.keys(x));\n        expect(b.z).to.not.shallow.equal(x.z);\n        expect(b.y).to.not.shallow.equal(x.y);\n        expect(b.y.z).to.not.shallow.equal(x.y.z);\n        expect(b.y).to.equal(b);\n        expect(b.y.y.y.y).to.equal(b);\n    });\n\n    it('clones an object with a null prototype', () => {\n\n        const obj = Object.create(null);\n        const b = Hoek.clone(obj);\n\n        expect(b).to.equal(obj);\n    });\n\n    it('clones deeply nested object', () => {\n\n        const a = {\n            x: {\n                y: {\n                    a: [1, 2, 3],\n                    b: 123456,\n                    c: new Date(),\n                    d: /hi/igm,\n                    e: /hello/\n                }\n            }\n        };\n\n        const b = Hoek.clone(a);\n\n        expect(a).to.equal(b);\n        expect(a.x.y.c.getTime()).to.equal(b.x.y.c.getTime());\n    });\n\n    it('clones arrays', () => {\n\n        const a = [1, 2, 3];\n\n        const b = Hoek.clone(a);\n\n        expect(a).to.equal(b);\n    });\n\n    it('performs actual copy for shallow keys (no pass by reference)', () => {\n\n        const x = Hoek.clone(nestedObj);\n        const y = Hoek.clone(nestedObj);\n\n        // Date\n        expect(x.z).to.not.shallow.equal(nestedObj.z);\n        expect(x.z).to.not.shallow.equal(y.z);\n\n        // Regex\n        expect(x.w).to.not.shallow.equal(nestedObj.w);\n        expect(x.w).to.not.shallow.equal(y.w);\n\n        // Array\n        expect(x.v).to.not.shallow.equal(nestedObj.v);\n        expect(x.v).to.not.shallow.equal(y.v);\n\n        // Immutable(s)\n        x.y = 5;\n        expect(x.y).to.not.equal(nestedObj.y);\n        expect(x.y).to.not.equal(y.y);\n    });\n\n    it('performs actual copy for deep keys (no pass by reference)', () => {\n\n        const x = Hoek.clone(nestedObj);\n        const y = Hoek.clone(nestedObj);\n\n        expect(x.x.c).to.not.shallow.equal(nestedObj.x.c);\n        expect(x.x.c).to.not.shallow.equal(y.x.c);\n\n        expect(x.x.c.getTime()).to.equal(nestedObj.x.c.getTime());\n        expect(x.x.c.getTime()).to.equal(y.x.c.getTime());\n    });\n\n    it('copies functions with properties', () => {\n\n        const a = {\n            x: function () {\n\n                return 1;\n            },\n            y: {}\n        };\n        a.x.z = 'string in function';\n        a.x.v = function () {\n\n            return 2;\n        };\n        a.y.u = a.x;\n\n        const b = Hoek.clone(a);\n        expect(b.x()).to.equal(1);\n        expect(b.x.v()).to.equal(2);\n        expect(b.y.u).to.equal(b.x);\n        expect(b.x.z).to.equal('string in function');\n    });\n\n    it('should copy a buffer', () => {\n\n        const tls = {\n            key: Buffer.from([1, 2, 3, 4, 5]),\n            cert: Buffer.from([1, 2, 3, 4, 5, 6, 10])\n        };\n\n        const copiedTls = Hoek.clone(tls);\n        expect(Buffer.isBuffer(copiedTls.key)).to.equal(true);\n        expect(JSON.stringify(copiedTls.key)).to.equal(JSON.stringify(tls.key));\n        expect(Buffer.isBuffer(copiedTls.cert)).to.equal(true);\n        expect(JSON.stringify(copiedTls.cert)).to.equal(JSON.stringify(tls.cert));\n\n        tls.key.write('hi');\n        expect(JSON.stringify(copiedTls.key)).to.not.equal(JSON.stringify(tls.key));\n    });\n\n    it('clones an object with a prototype', () => {\n\n        const Obj = function () {\n\n            this.a = 5;\n        };\n\n        Obj.prototype.b = function () {\n\n            return 'c';\n        };\n\n        const a = new Obj();\n        const b = Hoek.clone(a);\n\n        expect(b.a).to.equal(5);\n        expect(b.b()).to.equal('c');\n        expect(a).to.equal(b);\n    });\n\n    it('reuses cloned Date object', () => {\n\n        const obj = {\n            a: new Date()\n        };\n\n        obj.b = obj.a;\n\n        const copy = Hoek.clone(obj);\n        expect(copy.a).to.equal(copy.b);\n    });\n\n    it('shallow copies an object with a prototype and isImmutable flag', () => {\n\n        const Obj = function () {\n\n            this.value = 5;\n        };\n\n        Obj.prototype.b = function () {\n\n            return 'c';\n        };\n\n        Obj.prototype.isImmutable = true;\n\n        const obj = {\n            a: new Obj()\n        };\n\n        const copy = Hoek.clone(obj);\n\n        expect(obj.a.value).to.equal(5);\n        expect(copy.a.value).to.equal(5);\n        expect(copy.a.b()).to.equal('c');\n        expect(obj.a).to.equal(copy.a);\n    });\n\n    it('clones an object with property getter without executing it', () => {\n\n        const obj = {};\n        const value = 1;\n        let execCount = 0;\n\n        Object.defineProperty(obj, 'test', {\n            enumerable: true,\n            configurable: true,\n            get: function () {\n\n                ++execCount;\n                return value;\n            }\n        });\n\n        const copy = Hoek.clone(obj);\n        expect(execCount).to.equal(0);\n        expect(copy.test).to.equal(1);\n        expect(execCount).to.equal(1);\n    });\n\n    it('clones an object with property getter and setter', () => {\n\n        const obj = {\n            _test: 0\n        };\n\n        Object.defineProperty(obj, 'test', {\n            enumerable: true,\n            configurable: true,\n            get: function () {\n\n                return this._test;\n            },\n            set: function (value) {\n\n                this._test = value - 1;\n            }\n        });\n\n        const copy = Hoek.clone(obj);\n        expect(copy.test).to.equal(0);\n        copy.test = 5;\n        expect(copy.test).to.equal(4);\n    });\n\n    it('clones an object with only property setter', () => {\n\n        const obj = {\n            _test: 0\n        };\n\n        Object.defineProperty(obj, 'test', {\n            enumerable: true,\n            configurable: true,\n            set: function (value) {\n\n                this._test = value - 1;\n            }\n        });\n\n        const copy = Hoek.clone(obj);\n        expect(copy._test).to.equal(0);\n        copy.test = 5;\n        expect(copy._test).to.equal(4);\n    });\n\n    it('clones an object with non-enumerable properties', () => {\n\n        const obj = {\n            _test: 0\n        };\n\n        Object.defineProperty(obj, 'test', {\n            enumerable: false,\n            configurable: true,\n            set: function (value) {\n\n                this._test = value - 1;\n            }\n        });\n\n        const copy = Hoek.clone(obj);\n        expect(copy._test).to.equal(0);\n        copy.test = 5;\n        expect(copy._test).to.equal(4);\n    });\n\n    it('clones an object where getOwnPropertyDescriptor returns undefined', () => {\n\n        const oldGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n        const obj = { a: 'b' };\n        Object.getOwnPropertyDescriptor = function () {\n\n            return undefined;\n        };\n\n        const copy = Hoek.clone(obj);\n        Object.getOwnPropertyDescriptor = oldGetOwnPropertyDescriptor;\n        expect(copy).to.equal(obj);\n    });\n});\n\ndescribe('merge()', () => {\n\n    it('deep copies source items', () => {\n\n        const target = {\n            b: 3,\n            d: []\n        };\n\n        const source = {\n            c: {\n                d: 1\n            },\n            d: [{ e: 1 }]\n        };\n\n        Hoek.merge(target, source);\n        expect(target.c).to.not.shallow.equal(source.c);\n        expect(target.c).to.equal(source.c);\n        expect(target.d).to.not.shallow.equal(source.d);\n        expect(target.d[0]).to.not.shallow.equal(source.d[0]);\n        expect(target.d).to.equal(source.d);\n    });\n\n    it('merges array over an object', () => {\n\n        const a = {\n            x: ['n', 'm']\n        };\n\n        const b = {\n            x: {\n                n: '1',\n                m: '2'\n            }\n        };\n\n        Hoek.merge(b, a);\n        expect(a.x[0]).to.equal('n');\n        expect(a.x.n).to.not.exist();\n    });\n\n    it('merges object over an array', () => {\n\n        const a = {\n            x: ['n', 'm']\n        };\n\n        const b = {\n            x: {\n                n: '1',\n                m: '2'\n            }\n        };\n\n        Hoek.merge(a, b);\n        expect(a.x.n).to.equal('1');\n        expect(a.x[0]).to.not.exist();\n    });\n\n    it('does not throw if source is null', () => {\n\n        const a = {};\n        const b = null;\n        let c = null;\n\n        expect(() => {\n\n            c = Hoek.merge(a, b);\n        }).to.not.throw();\n\n        expect(c).to.equal(a);\n    });\n\n    it('does not throw if source is undefined', () => {\n\n        const a = {};\n        const b = undefined;\n        let c = null;\n\n        expect(() => {\n\n            c = Hoek.merge(a, b);\n        }).to.not.throw();\n\n        expect(c).to.equal(a);\n    });\n\n    it('throws if source is not an object', () => {\n\n        expect(() => {\n\n            const a = {};\n            const b = 0;\n\n            Hoek.merge(a, b);\n        }).to.throw('Invalid source value: must be null, undefined, or an object');\n    });\n\n    it('throws if target is not an object', () => {\n\n        expect(() => {\n\n            const a = 0;\n            const b = {};\n\n            Hoek.merge(a, b);\n        }).to.throw('Invalid target value: must be an object');\n    });\n\n    it('throws if target is not an array and source is', () => {\n\n        expect(() => {\n\n            const a = {};\n            const b = [1, 2];\n\n            Hoek.merge(a, b);\n        }).to.throw('Cannot merge array onto an object');\n    });\n\n    it('returns the same object when merging arrays', () => {\n\n        const a = [];\n        const b = [1, 2];\n\n        expect(Hoek.merge(a, b)).to.equal(a);\n    });\n\n    it('combines an empty object with a non-empty object', () => {\n\n        const a = {};\n        const b = nestedObj;\n\n        const c = Hoek.merge(a, b);\n        expect(a).to.equal(b);\n        expect(c).to.equal(b);\n    });\n\n    it('overrides values in target', () => {\n\n        const a = { x: 1, y: 2, z: 3, v: 5, t: 'test', m: 'abc' };\n        const b = { x: null, z: 4, v: 0, t: { u: 6 }, m: '123' };\n\n        const c = Hoek.merge(a, b);\n        expect(c.x).to.equal(null);\n        expect(c.y).to.equal(2);\n        expect(c.z).to.equal(4);\n        expect(c.v).to.equal(0);\n        expect(c.m).to.equal('123');\n        expect(c.t).to.equal({ u: 6 });\n    });\n\n    it('overrides values in target (flip)', () => {\n\n        const a = { x: 1, y: 2, z: 3, v: 5, t: 'test', m: 'abc' };\n        const b = { x: null, z: 4, v: 0, t: { u: 6 }, m: '123' };\n\n        const d = Hoek.merge(b, a);\n        expect(d.x).to.equal(1);\n        expect(d.y).to.equal(2);\n        expect(d.z).to.equal(3);\n        expect(d.v).to.equal(5);\n        expect(d.m).to.equal('abc');\n        expect(d.t).to.equal('test');\n    });\n\n    it('retains Date properties', () => {\n\n        const a = { x: new Date(1378776452757) };\n\n        const b = Hoek.merge({}, a);\n        expect(a.x.getTime()).to.equal(b.x.getTime());\n    });\n\n    it('retains Date properties when merging keys', () => {\n\n        const a = { x: new Date(1378776452757) };\n\n        const b = Hoek.merge({ x: {} }, a);\n        expect(a.x.getTime()).to.equal(b.x.getTime());\n    });\n\n    it('overrides Buffer', () => {\n\n        const a = { x: Buffer.from('abc') };\n\n        Hoek.merge({ x: {} }, a);\n        expect(a.x.toString()).to.equal('abc');\n    });\n});\n\ndescribe('applyToDefaults()', () => {\n\n    const defaults = {\n        a: 1,\n        b: 2,\n        c: {\n            d: 3,\n            e: [5, 6]\n        },\n        f: 6,\n        g: 'test'\n    };\n\n    it('throws when target is null', () => {\n\n        expect(() => {\n\n            Hoek.applyToDefaults(null, {});\n        }).to.throw('Invalid defaults value: must be an object');\n    });\n\n    it('returns null if options is false', () => {\n\n        const result = Hoek.applyToDefaults(defaults, false);\n        expect(result).to.equal(null);\n    });\n\n    it('returns null if options is null', () => {\n\n        const result = Hoek.applyToDefaults(defaults, null);\n        expect(result).to.equal(null);\n    });\n\n    it('returns null if options is undefined', () => {\n\n        const result = Hoek.applyToDefaults(defaults, undefined);\n        expect(result).to.equal(null);\n    });\n\n    it('returns a copy of defaults if options is true', () => {\n\n        const result = Hoek.applyToDefaults(defaults, true);\n        expect(result).to.equal(defaults);\n    });\n\n    it('applies object to defaults', () => {\n\n        const obj = {\n            a: null,\n            c: {\n                e: [4]\n            },\n            f: 0,\n            g: {\n                h: 5\n            }\n        };\n\n        const result = Hoek.applyToDefaults(defaults, obj);\n        expect(result.c.e).to.equal([4]);\n        expect(result.a).to.equal(1);\n        expect(result.b).to.equal(2);\n        expect(result.f).to.equal(0);\n        expect(result.g).to.equal({ h: 5 });\n    });\n\n    it('applies object to defaults with null', () => {\n\n        const obj = {\n            a: null,\n            c: {\n                e: [4]\n            },\n            f: 0,\n            g: {\n                h: 5\n            }\n        };\n\n        const result = Hoek.applyToDefaults(defaults, obj, true);\n        expect(result.c.e).to.equal([4]);\n        expect(result.a).to.equal(null);\n        expect(result.b).to.equal(2);\n        expect(result.f).to.equal(0);\n        expect(result.g).to.equal({ h: 5 });\n    });\n});\n\ndescribe('cloneWithShallow()', () => {\n\n    it('deep clones except for listed keys', () => {\n\n        const source = {\n            a: {\n                b: 5\n            },\n            c: {\n                d: 6\n            }\n        };\n\n        const copy = Hoek.cloneWithShallow(source, ['c']);\n        expect(copy).to.equal(source);\n        expect(copy).to.not.shallow.equal(source);\n        expect(copy.a).to.not.shallow.equal(source.a);\n        expect(copy.b).to.equal(source.b);\n    });\n\n    it('returns immutable value', () => {\n\n        expect(Hoek.cloneWithShallow(5)).to.equal(5);\n    });\n\n    it('returns null value', () => {\n\n        expect(Hoek.cloneWithShallow(null)).to.equal(null);\n    });\n\n    it('returns undefined value', () => {\n\n        expect(Hoek.cloneWithShallow(undefined)).to.equal(undefined);\n    });\n\n    it('deep clones except for listed keys (including missing keys)', () => {\n\n        const source = {\n            a: {\n                b: 5\n            },\n            c: {\n                d: 6\n            }\n        };\n\n        const copy = Hoek.cloneWithShallow(source, ['c', 'v']);\n        expect(copy).to.equal(source);\n        expect(copy).to.not.shallow.equal(source);\n        expect(copy.a).to.not.shallow.equal(source.a);\n        expect(copy.b).to.equal(source.b);\n    });\n});\n\ndescribe('applyToDefaultsWithShallow()', () => {\n\n    it('shallow copies the listed keys from options without merging', () => {\n\n        const defaults = {\n            a: {\n                b: 5,\n                e: 3\n            },\n            c: {\n                d: 7,\n                g: 1\n            }\n        };\n\n        const options = {\n            a: {\n                b: 4\n            },\n            c: {\n                d: 6,\n                f: 7\n            }\n        };\n\n        const merged = Hoek.applyToDefaultsWithShallow(defaults, options, ['a']);\n        expect(merged).to.equal({ a: { b: 4 }, c: { d: 6, g: 1, f: 7 } });\n        expect(merged.a).to.equal(options.a);\n        expect(merged.a).to.not.equal(defaults.a);\n        expect(merged.c).to.not.equal(options.c);\n        expect(merged.c).to.not.equal(defaults.c);\n    });\n\n    it('shallow copies the nested keys (override)', () => {\n\n        const defaults = {\n            a: {\n                b: 5\n            },\n            c: {\n                d: 7,\n                g: 1\n            }\n        };\n\n        const options = {\n            a: {\n                b: 4\n            },\n            c: {\n                d: 6,\n                g: {\n                    h: 8\n                }\n            }\n        };\n\n        const merged = Hoek.applyToDefaultsWithShallow(defaults, options, ['c.g']);\n        expect(merged).to.equal({ a: { b: 4 }, c: { d: 6, g: { h: 8 } } });\n        expect(merged.c.g).to.equal(options.c.g);\n    });\n\n    it('shallow copies the nested keys (missing)', () => {\n\n        const defaults = {\n            a: {\n                b: 5\n            }\n        };\n\n        const options = {\n            a: {\n                b: 4\n            },\n            c: {\n                g: {\n                    h: 8\n                }\n            }\n        };\n\n        const merged = Hoek.applyToDefaultsWithShallow(defaults, options, ['c.g']);\n        expect(merged).to.equal({ a: { b: 4 }, c: { g: { h: 8 } } });\n        expect(merged.c.g).to.equal(options.c.g);\n    });\n\n    it('shallow copies the nested keys (override)', () => {\n\n        const defaults = {\n            a: {\n                b: 5\n            },\n            c: {\n                g: {\n                    d: 7\n                }\n            }\n        };\n\n        const options = {\n            a: {\n                b: 4\n            },\n            c: {\n                g: {\n                    h: 8\n                }\n            }\n        };\n\n        const merged = Hoek.applyToDefaultsWithShallow(defaults, options, ['c.g']);\n        expect(merged).to.equal({ a: { b: 4 }, c: { g: { h: 8 } } });\n        expect(merged.c.g).to.equal(options.c.g);\n    });\n\n    it('shallow copies the nested keys (deeper)', () => {\n\n        const defaults = {\n            a: {\n                b: 5\n            }\n        };\n\n        const options = {\n            a: {\n                b: 4\n            },\n            c: {\n                g: {\n                    r: {\n                        h: 8\n                    }\n                }\n            }\n        };\n\n        const merged = Hoek.applyToDefaultsWithShallow(defaults, options, ['c.g.r']);\n        expect(merged).to.equal({ a: { b: 4 }, c: { g: { r: { h: 8 } } } });\n        expect(merged.c.g.r).to.equal(options.c.g.r);\n    });\n\n    it('shallow copies the nested keys (not present)', () => {\n\n        const defaults = {\n            a: {\n                b: 5\n            }\n        };\n\n        const options = {\n            a: {\n                b: 4\n            },\n            c: {\n                g: {\n                    r: {\n                        h: 8\n                    }\n                }\n            }\n        };\n\n        const merged = Hoek.applyToDefaultsWithShallow(defaults, options, ['x.y']);\n        expect(merged).to.equal({ a: { b: 4 }, c: { g: { r: { h: 8 } } } });\n    });\n\n    it('shallow copies the listed keys in the defaults', () => {\n\n        const defaults = {\n            a: {\n                b: 1\n            }\n        };\n\n        const merged = Hoek.applyToDefaultsWithShallow(defaults, {}, ['a']);\n        expect(merged.a).to.equal(defaults.a);\n    });\n\n    it('shallow copies the listed keys in the defaults (true)', () => {\n\n        const defaults = {\n            a: {\n                b: 1\n            }\n        };\n\n        const merged = Hoek.applyToDefaultsWithShallow(defaults, true, ['a']);\n        expect(merged.a).to.equal(defaults.a);\n    });\n\n    it('returns null on false', () => {\n\n        const defaults = {\n            a: {\n                b: 1\n            }\n        };\n\n        const merged = Hoek.applyToDefaultsWithShallow(defaults, false, ['a']);\n        expect(merged).to.equal(null);\n    });\n\n    it('throws on missing defaults', () => {\n\n        expect(() => {\n\n            Hoek.applyToDefaultsWithShallow(null, {}, ['a']);\n        }).to.throw('Invalid defaults value: must be an object');\n    });\n\n    it('throws on invalid defaults', () => {\n\n        expect(() => {\n\n            Hoek.applyToDefaultsWithShallow('abc', {}, ['a']);\n        }).to.throw('Invalid defaults value: must be an object');\n    });\n\n    it('throws on invalid options', () => {\n\n        expect(() => {\n\n            Hoek.applyToDefaultsWithShallow({}, 'abc', ['a']);\n        }).to.throw('Invalid options value: must be true, falsy or an object');\n    });\n\n    it('throws on missing keys', () => {\n\n        expect(() => {\n\n            Hoek.applyToDefaultsWithShallow({}, true);\n        }).to.throw('Invalid keys');\n    });\n\n    it('throws on invalid keys', () => {\n\n        expect(() => {\n\n            Hoek.applyToDefaultsWithShallow({}, true, 'a');\n        }).to.throw('Invalid keys');\n    });\n});\n\ndescribe('deepEqual()', () => {\n\n    it('compares simple values', () => {\n\n        expect(Hoek.deepEqual('x', 'x')).to.be.true();\n        expect(Hoek.deepEqual('x', 'y')).to.be.false();\n        expect(Hoek.deepEqual('x1', 'x')).to.be.false();\n        expect(Hoek.deepEqual(-0, +0)).to.be.false();\n        expect(Hoek.deepEqual(-0, -0)).to.be.true();\n        expect(Hoek.deepEqual(+0, +0)).to.be.true();\n        expect(Hoek.deepEqual(+0, -0)).to.be.false();\n        expect(Hoek.deepEqual(1, 1)).to.be.true();\n        expect(Hoek.deepEqual(0, 0)).to.be.true();\n        expect(Hoek.deepEqual(-1, 1)).to.be.false();\n        expect(Hoek.deepEqual(NaN, 0)).to.be.false();\n        expect(Hoek.deepEqual(NaN, NaN)).to.be.true();\n    });\n\n    it('compares different types', () => {\n\n        expect(Hoek.deepEqual([], 5)).to.be.false();\n        expect(Hoek.deepEqual(5, [])).to.be.false();\n        expect(Hoek.deepEqual({}, null)).to.be.false();\n        expect(Hoek.deepEqual(null, {})).to.be.false();\n        expect(Hoek.deepEqual('abc', {})).to.be.false();\n        expect(Hoek.deepEqual({}, 'abc')).to.be.false();\n    });\n\n    it('compares empty structures', () => {\n\n        expect(Hoek.deepEqual([], [])).to.be.true();\n        expect(Hoek.deepEqual({}, {})).to.be.true();\n        expect(Hoek.deepEqual([], {})).to.be.false();\n    });\n\n    it('compares empty arguments object', () => {\n\n        const compare = function () {\n\n            expect(Hoek.deepEqual([], arguments)).to.be.false();\n        };\n\n        compare();\n    });\n\n    it('compares empty arguments objects', () => {\n\n        const compare = function () {\n\n            const arg1 = arguments;\n\n            const inner = function () {\n\n                expect(Hoek.deepEqual(arg1, arguments)).to.be.true(); // callee is not supported in strict mode, was previously false becuse callee was different\n            };\n\n            inner();\n        };\n\n        compare();\n    });\n\n    it('compares dates', () => {\n\n        expect(Hoek.deepEqual(new Date(2015, 1, 1), new Date(2015, 1, 1))).to.be.true();\n        expect(Hoek.deepEqual(new Date(100), new Date(101))).to.be.false();\n        expect(Hoek.deepEqual(new Date(), {})).to.be.false();\n    });\n\n    it('compares regular expressions', () => {\n\n        expect(Hoek.deepEqual(/\\s/, new RegExp('\\\\\\s'))).to.be.true();\n        expect(Hoek.deepEqual(/\\s/g, /\\s/g)).to.be.true();\n        expect(Hoek.deepEqual(/a/, {})).to.be.false();\n        expect(Hoek.deepEqual(/\\s/g, /\\s/i)).to.be.false();\n        expect(Hoek.deepEqual(/a/g, /b/g)).to.be.false();\n    });\n\n    it('compares arrays', () => {\n\n        expect(Hoek.deepEqual([[1]], [[1]])).to.be.true();\n        expect(Hoek.deepEqual([1, 2, 3], [1, 2, 3])).to.be.true();\n        expect(Hoek.deepEqual([1, 2, 3], [1, 3, 2])).to.be.false();\n        expect(Hoek.deepEqual([1, 2, 3], [1, 2])).to.be.false();\n        expect(Hoek.deepEqual([1], [1])).to.be.true();\n        const item1 = { key: 'value1' };\n        const item2 = { key: 'value2' };\n        expect(Hoek.deepEqual([item1, item1], [item1, item2])).to.be.false();\n    });\n\n    it('compares buffers', () => {\n\n        expect(Hoek.deepEqual(Buffer.from([1, 2, 3]), Buffer.from([1, 2, 3]))).to.be.true();\n        expect(Hoek.deepEqual(Buffer.from([1, 2, 3]), Buffer.from([1, 3, 2]))).to.be.false();\n        expect(Hoek.deepEqual(Buffer.from([1, 2, 3]), Buffer.from([1, 2]))).to.be.false();\n        expect(Hoek.deepEqual(Buffer.from([1, 2, 3]), {})).to.be.false();\n        expect(Hoek.deepEqual(Buffer.from([1, 2, 3]), [1, 2, 3])).to.be.false();\n    });\n\n    it('compares objects', () => {\n\n        expect(Hoek.deepEqual({ a: 1, b: 2, c: 3 }, { a: 1, b: 2, c: 3 })).to.be.true();\n        expect(Hoek.deepEqual({ foo: 'bar' }, { foo: 'baz' })).to.be.false();\n        expect(Hoek.deepEqual({ foo: { bar: 'foo' } }, { foo: { bar: 'baz' } })).to.be.false();\n    });\n\n    it('handles circular dependency', () => {\n\n        const a = {};\n        a.x = a;\n\n        const b = Hoek.clone(a);\n        expect(Hoek.deepEqual(a, b)).to.be.true();\n    });\n\n    it('compares an object with property getter without executing it', () => {\n\n        const obj = {};\n        const value = 1;\n        let execCount = 0;\n\n        Object.defineProperty(obj, 'test', {\n            enumerable: true,\n            configurable: true,\n            get: function () {\n\n                ++execCount;\n                return value;\n            }\n        });\n\n        const copy = Hoek.clone(obj);\n        expect(Hoek.deepEqual(obj, copy)).to.be.true();\n        expect(execCount).to.equal(0);\n        expect(copy.test).to.equal(1);\n        expect(execCount).to.equal(1);\n    });\n\n    it('compares objects with property getters', () => {\n\n        const obj = {};\n        Object.defineProperty(obj, 'test', {\n            enumerable: true,\n            configurable: true,\n            get: function () {\n\n                return 1;\n            }\n        });\n\n        const ref = {};\n        Object.defineProperty(ref, 'test', {\n            enumerable: true,\n            configurable: true,\n            get: function () {\n\n                return 2;\n            }\n        });\n\n        expect(Hoek.deepEqual(obj, ref)).to.be.false();\n    });\n\n    it('compares object prototypes', () => {\n\n        const Obj = function () {\n\n            this.a = 5;\n        };\n\n        Obj.prototype.b = function () {\n\n            return this.a;\n        };\n\n        const Ref = function () {\n\n            this.a = 5;\n        };\n\n        Ref.prototype.b = function () {\n\n            return this.a;\n        };\n\n        expect(Hoek.deepEqual(new Obj(), new Ref())).to.be.false();\n        expect(Hoek.deepEqual(new Obj(), new Obj())).to.be.true();\n        expect(Hoek.deepEqual(new Ref(), new Ref())).to.be.true();\n    });\n\n    it('compares plain objects', () => {\n\n        const a = Object.create(null);\n        const b = Object.create(null);\n\n        a.b = 'c';\n        b.b = 'c';\n\n        expect(Hoek.deepEqual(a, b)).to.be.true();\n        expect(Hoek.deepEqual(a, { b: 'c' })).to.be.false();\n    });\n\n    it('compares an object with an empty object', () => {\n\n        const a = { a: 1, b: 2 };\n\n        expect(Hoek.deepEqual({}, a)).to.be.false();\n        expect(Hoek.deepEqual(a, {})).to.be.false();\n    });\n\n    it('compares an object ignoring the prototype', () => {\n\n        const a = Object.create(null);\n        const b = {};\n\n        expect(Hoek.deepEqual(a, b, { prototype: false })).to.be.true();\n    });\n\n    it('compares an object ignoring the prototype recursively', () => {\n\n        const a = [Object.create(null)];\n        const b = [{}];\n\n        expect(Hoek.deepEqual(a, b, { prototype: false })).to.be.true();\n    });\n});\n\ndescribe('unique()', () => {\n\n    const deprecatedUnique = function (array, key) { // previous method of unique from hapi 3.0.4\n\n        const index = {};\n        const result = [];\n\n        for (let i = 0; i < array.length; ++i) {\n            const id = (key ? array[i][key] : array[i]);\n            if (index[id] !== true) {\n\n                result.push(array[i]);\n                index[id] = true;\n            }\n        }\n\n        return result;\n    };\n\n    it('ensures uniqueness within array of objects based on subkey', () => {\n\n        expect(Hoek.unique(internals.unique.objectsByKey.dups, 'x')).to.equal(internals.unique.objectsByKey.result);\n        expect(deprecatedUnique(internals.unique.objectsByKey.dups, 'x')).to.equal(internals.unique.objectsByKey.result);\n\n    });\n\n    it('removes duplicated integers without key', () => {\n\n        expect(Hoek.unique(internals.unique.integers.dups)).to.equal(internals.unique.integers.result);\n        expect(deprecatedUnique(internals.unique.integers.dups)).to.equal(internals.unique.integers.result);\n    });\n\n    it('removes duplicated strings without key', () => {\n\n        expect(Hoek.unique(internals.unique.strings.dups)).to.equal(internals.unique.strings.result);\n        expect(deprecatedUnique(internals.unique.strings.dups)).to.equal(internals.unique.strings.result);\n    });\n\n    it('removes duplicated objects without key', () => { // this was not supported in earlier versions\n\n        expect(Hoek.unique(internals.unique.objects.dups)).to.equal(internals.unique.objects.result);\n        expect(deprecatedUnique(internals.unique.objects.dups)).to.not.equal(internals.unique.objects.result);\n    });\n});\n\ndescribe('mapToObject()', () => {\n\n    it('returns null on null array', () => {\n\n        const a = Hoek.mapToObject(null);\n        expect(a).to.equal(null);\n    });\n\n    it('converts basic array to existential object', () => {\n\n        const keys = [1, 2, 3, 4];\n        const a = Hoek.mapToObject(keys);\n        expect(Object.keys(a)).to.equal(['1', '2', '3', '4']);\n    });\n\n    it('converts array of objects to existential object', () => {\n\n        const keys = [{ x: 1 }, { x: 2 }, { x: 3 }, { y: 4 }];\n        const subkey = 'x';\n        const a = Hoek.mapToObject(keys, subkey);\n        expect(a).to.equal({ 1: true, 2: true, 3: true });\n    });\n});\n\ndescribe('intersect()', () => {\n\n    it('returns the common objects of two arrays', () => {\n\n        const array1 = [1, 2, 3, 4, 4, 5, 5];\n        const array2 = [5, 4, 5, 6, 7];\n        const common = Hoek.intersect(array1, array2);\n        expect(common.length).to.equal(2);\n    });\n\n    it('returns just the first common object of two arrays', () => {\n\n        const array1 = [1, 2, 3, 4, 4, 5, 5];\n        const array2 = [5, 4, 5, 6, 7];\n        const common = Hoek.intersect(array1, array2, true);\n        expect(common).to.equal(5);\n    });\n\n    it('returns null when no common and returning just the first common object of two arrays', () => {\n\n        const array1 = [1, 2, 3, 4, 4, 5, 5];\n        const array2 = [6, 7];\n        const common = Hoek.intersect(array1, array2, true);\n        expect(common).to.equal(null);\n    });\n\n    it('returns an empty array if either input is null', () => {\n\n        expect(Hoek.intersect([1], null).length).to.equal(0);\n        expect(Hoek.intersect(null, [1]).length).to.equal(0);\n    });\n\n    it('returns the common objects of object and array', () => {\n\n        const array1 = [1, 2, 3, 4, 4, 5, 5];\n        const array2 = [5, 4, 5, 6, 7];\n        const common = Hoek.intersect(Hoek.mapToObject(array1), array2);\n        expect(common.length).to.equal(2);\n    });\n});\n\ndescribe('contain()', () => {\n\n    it('tests strings', () => {\n\n        expect(Hoek.contain('abc', 'ab')).to.be.true();\n        expect(Hoek.contain('abc', 'abc', { only: true })).to.be.true();\n        expect(Hoek.contain('aaa', 'a', { only: true })).to.be.true();\n        expect(Hoek.contain('abc', 'b', { once: true })).to.be.true();\n        expect(Hoek.contain('abc', ['a', 'c'])).to.be.true();\n        expect(Hoek.contain('abc', ['a', 'd'], { part: true })).to.be.true();\n\n        expect(Hoek.contain('abc', 'ac')).to.be.false();\n        expect(Hoek.contain('abcd', 'abc', { only: true })).to.be.false();\n        expect(Hoek.contain('aab', 'a', { only: true })).to.be.false();\n        expect(Hoek.contain('abb', 'b', { once: true })).to.be.false();\n        expect(Hoek.contain('abc', ['a', 'd'])).to.be.false();\n        expect(Hoek.contain('abc', ['ab', 'bc'])).to.be.false();                      // Overlapping values not supported\n    });\n\n    it('tests arrays', () => {\n\n        expect(Hoek.contain([1, 2, 3], 1)).to.be.true();\n        expect(Hoek.contain([{ a: 1 }], { a: 1 }, { deep: true })).to.be.true();\n        expect(Hoek.contain([1, 2, 3], [1, 2])).to.be.true();\n        expect(Hoek.contain([{ a: 1 }], [{ a: 1 }], { deep: true })).to.be.true();\n        expect(Hoek.contain([1, 1, 2], [1, 2], { only: true })).to.be.true();\n        expect(Hoek.contain([1, 2], [1, 2], { once: true })).to.be.true();\n        expect(Hoek.contain([1, 2, 3], [1, 4], { part: true })).to.be.true();\n        expect(Hoek.contain([[1], [2]], [[1]], { deep: true })).to.be.true();\n\n        expect(Hoek.contain([1, 2, 3], 4)).to.be.false();\n        expect(Hoek.contain([{ a: 1 }], { a: 2 }, { deep: true })).to.be.false();\n        expect(Hoek.contain([{ a: 1 }], { a: 1 })).to.be.false();\n        expect(Hoek.contain([1, 2, 3], [4, 5])).to.be.false();\n        expect(Hoek.contain([[3], [2]], [[1]])).to.be.false();\n        expect(Hoek.contain([[1], [2]], [[1]])).to.be.false();\n        expect(Hoek.contain([{ a: 1 }], [{ a: 2 }], { deep: true })).to.be.false();\n        expect(Hoek.contain([1, 3, 2], [1, 2], { only: true })).to.be.false();\n        expect(Hoek.contain([1, 2, 2], [1, 2], { once: true })).to.be.false();\n        expect(Hoek.contain([0, 2, 3], [1, 4], { part: true })).to.be.false();\n    });\n\n    it('tests objects', () => {\n\n        expect(Hoek.contain({ a: 1, b: 2, c: 3 }, 'a')).to.be.true();\n        expect(Hoek.contain({ a: 1, b: 2, c: 3 }, ['a', 'c'])).to.be.true();\n        expect(Hoek.contain({ a: 1, b: 2, c: 3 }, ['a', 'b', 'c'], { only: true })).to.be.true();\n        expect(Hoek.contain({ a: 1, b: 2, c: 3 }, { a: 1 })).to.be.true();\n        expect(Hoek.contain({ a: 1, b: 2, c: 3 }, { a: 1, c: 3 })).to.be.true();\n        expect(Hoek.contain({ a: 1, b: 2, c: 3 }, { a: 1, d: 4 }, { part: true })).to.be.true();\n        expect(Hoek.contain({ a: 1, b: 2, c: 3 }, { a: 1, b: 2, c: 3 }, { only: true })).to.be.true();\n        expect(Hoek.contain({ a: [1], b: [2], c: [3] }, { a: [1], c: [3] }, { deep: true })).to.be.true();\n        expect(Hoek.contain({ a: [{ b: 1 }, { c: 2 }, { d: 3, e: 4 }] }, { a: [{ b: 1 }, { d: 3 }] }, { deep: true })).to.be.true();\n        expect(Hoek.contain({ a: [{ b: 1 }, { c: 2 }, { d: 3, e: 4 }] }, { a: [{ b: 1 }, { d: 3 }] }, { deep: true, part: true })).to.be.true();\n        expect(Hoek.contain({ a: [{ b: 1 }, { c: 2 }, { d: 3, e: 4 }] }, { a: [{ b: 1 }, { d: 3 }] }, { deep: true, part: false })).to.be.false();\n        expect(Hoek.contain({ a: [{ b: 1 }, { c: 2 }, { d: 3, e: 4 }] }, { a: [{ b: 1 }, { d: 3 }] }, { deep: true, only: true })).to.be.false();\n        expect(Hoek.contain({ a: [{ b: 1 }, { c: 2 }, { d: 3, e: 4 }] }, { a: [{ b: 1 }, { d: 3 }] }, { deep: true, only: false })).to.be.true();\n\n        expect(Hoek.contain({ a: 1, b: 2, c: 3 }, 'd')).to.be.false();\n        expect(Hoek.contain({ a: 1, b: 2, c: 3 }, ['a', 'd'])).to.be.false();\n        expect(Hoek.contain({ a: 1, b: 2, c: 3, d: 4 }, ['a', 'b', 'c'], { only: true })).to.be.false();\n        expect(Hoek.contain({ a: 1, b: 2, c: 3 }, { a: 2 })).to.be.false();\n        expect(Hoek.contain({ a: 1, b: 2, c: 3 }, { a: 2, b: 2 }, { part: true })).to.be.false();             // part does not ignore bad value\n        expect(Hoek.contain({ a: 1, b: 2, c: 3 }, { a: 1, d: 3 })).to.be.false();\n        expect(Hoek.contain({ a: 1, b: 2, c: 3 }, { a: 1, d: 4 })).to.be.false();\n        expect(Hoek.contain({ a: 1, b: 2, c: 3 }, { a: 1, b: 2 }, { only: true })).to.be.false();\n        expect(Hoek.contain({ a: [1], b: [2], c: [3] }, { a: [1], c: [3] })).to.be.false();\n        expect(Hoek.contain({ a: { b: { c: 1, d: 2 } } }, { a: { b: { c: 1 } } })).to.be.false();\n        expect(Hoek.contain({ a: { b: { c: 1, d: 2 } } }, { a: { b: { c: 1 } } }, { deep: true })).to.be.true();\n        expect(Hoek.contain({ a: { b: { c: 1, d: 2 } } }, { a: { b: { c: 1 } } }, { deep: true, only: true })).to.be.false();\n        expect(Hoek.contain({ a: { b: { c: 1, d: 2 } } }, { a: { b: { c: 1 } } }, { deep: true, only: false })).to.be.true();\n        expect(Hoek.contain({ a: { b: { c: 1, d: 2 } } }, { a: { b: { c: 1 } } }, { deep: true, part: true })).to.be.true();\n        expect(Hoek.contain({ a: { b: { c: 1, d: 2 } } }, { a: { b: { c: 1 } } }, { deep: true, part: false })).to.be.false();\n\n        // Getter check\n        {\n            const Foo = function (bar) {\n\n                this.bar = bar;\n            };\n\n            Object.defineProperty(Foo.prototype, 'baz', {\n                enumerable: true,\n                get: function () {\n\n                    return this.bar;\n                }\n            });\n\n            expect(Hoek.contain({ a: new Foo('b') }, { a: new Foo('b') }, { deep: true })).to.be.true();\n            expect(Hoek.contain({ a: new Foo('b') }, { a: new Foo('b') }, { deep: true, part: true })).to.be.true();\n            expect(Hoek.contain({ a: new Foo('b') }, { a: { baz: 'b' } }, { deep: true })).to.be.true();\n            expect(Hoek.contain({ a: new Foo('b') }, { a: { baz: 'b' } }, { deep: true, only: true })).to.be.false();\n            expect(Hoek.contain({ a: new Foo('b') }, { a: { baz: 'b' } }, { deep: true, part: false })).to.be.false();\n            expect(Hoek.contain({ a: new Foo('b') }, { a: { baz: 'b' } }, { deep: true, part: true })).to.be.true();\n            expect(Hoek.contain({ a: new Foo('b') }, { a: new Foo('b') }, { deep: true })).to.be.true();\n        }\n\n        // Properties on prototype not visible\n        {\n            const Foo = function () {\n\n                this.a = 1;\n            };\n\n            Object.defineProperty(Foo.prototype, 'b', {\n                enumerable: true,\n                value: 2\n            });\n\n            const Bar = function () {\n\n                Foo.call(this);\n                this.c = 3;\n            };\n\n            Util.inherits(Bar, Foo);\n\n            expect((new Bar()).a).to.equal(1);\n            expect((new Bar()).b).to.equal(2);\n            expect((new Bar()).c).to.equal(3);\n            expect(Hoek.contain(new Bar(), { 'a': 1, 'c': 3 }, { only: true })).to.be.true();\n            expect(Hoek.contain(new Bar(), 'b')).to.be.false();\n        }\n\n        // Non-Enumerable properties\n        {\n            const foo = { a: 1, b: 2 };\n\n            Object.defineProperty(foo, 'c', {\n                enumerable: false,\n                value: 3\n            });\n\n            expect(Hoek.contain(foo, 'c')).to.be.true();\n            expect(Hoek.contain(foo, { 'c': 3 })).to.be.true();\n            expect(Hoek.contain(foo, { 'a': 1, 'b': 2, 'c': 3 }, { only: true })).to.be.true();\n        }\n    });\n});\n\ndescribe('flatten()', () => {\n\n    it('returns a flat array', () => {\n\n        const result = Hoek.flatten([1, 2, [3, 4, [5, 6], [7], 8], [9], [10, [11, 12]], 13]);\n        expect(result.length).to.equal(13);\n        expect(result).to.equal([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]);\n    });\n});\n\ndescribe('reach()', () => {\n\n    const obj = {\n        a: {\n            b: {\n                c: {\n                    d: 1,\n                    e: 2\n                },\n                f: 'hello'\n            },\n            g: {\n                h: 3\n            }\n        },\n        i: function () { },\n        j: null,\n        k: [4, 8, 9, 1]\n    };\n\n    obj.i.x = 5;\n\n    it('returns object itself', () => {\n\n        expect(Hoek.reach(obj, null)).to.equal(obj);\n        expect(Hoek.reach(obj, false)).to.equal(obj);\n        expect(Hoek.reach(obj)).to.equal(obj);\n    });\n\n    it('returns first value of array', () => {\n\n        expect(Hoek.reach(obj, 'k.0')).to.equal(4);\n    });\n\n    it('returns last value of array using negative index', () => {\n\n        expect(Hoek.reach(obj, 'k.-2')).to.equal(9);\n    });\n\n    it('returns a valid member', () => {\n\n        expect(Hoek.reach(obj, 'a.b.c.d')).to.equal(1);\n    });\n\n    it('returns a valid member with separator override', () => {\n\n        expect(Hoek.reach(obj, 'a/b/c/d', '/')).to.equal(1);\n    });\n\n    it('returns undefined on null object', () => {\n\n        expect(Hoek.reach(null, 'a.b.c.d')).to.equal(undefined);\n    });\n\n    it('returns undefined on missing object member', () => {\n\n        expect(Hoek.reach(obj, 'a.b.c.d.x')).to.equal(undefined);\n    });\n\n    it('returns undefined on missing function member', () => {\n\n        expect(Hoek.reach(obj, 'i.y', { functions: true })).to.equal(undefined);\n    });\n\n    it('throws on missing member in strict mode', () => {\n\n        expect(() => {\n\n            Hoek.reach(obj, 'a.b.c.o.x', { strict: true });\n        }).to.throw('Missing segment o in reach path  a.b.c.o.x');\n\n    });\n\n    it('returns undefined on invalid member', () => {\n\n        expect(Hoek.reach(obj, 'a.b.c.d-.x')).to.equal(undefined);\n    });\n\n    it('returns function member', () => {\n\n        expect(typeof Hoek.reach(obj, 'i')).to.equal('function');\n    });\n\n    it('returns function property', () => {\n\n        expect(Hoek.reach(obj, 'i.x')).to.equal(5);\n    });\n\n    it('returns null', () => {\n\n        expect(Hoek.reach(obj, 'j')).to.equal(null);\n    });\n\n    it('throws on function property when functions not allowed', () => {\n\n        expect(() => {\n\n            Hoek.reach(obj, 'i.x', { functions: false });\n        }).to.throw('Invalid segment x in reach path  i.x');\n    });\n\n    it('will return a default value if property is not found', () => {\n\n        expect(Hoek.reach(obj, 'a.b.q', { default: 'defaultValue' })).to.equal('defaultValue');\n    });\n\n    it('will return a default value if path is not found', () => {\n\n        expect(Hoek.reach(obj, 'q', { default: 'defaultValue' })).to.equal('defaultValue');\n    });\n\n    it('allows a falsey value to be used as the default value', () => {\n\n        expect(Hoek.reach(obj, 'q', { default: '' })).to.equal('');\n    });\n});\n\ndescribe('reachTemplate()', () => {\n\n    it('applies object to template', () => {\n\n        const obj = {\n            a: {\n                b: {\n                    c: {\n                        d: 1\n                    }\n                }\n            },\n            j: null,\n            k: [4, 8, 9, 1]\n        };\n\n        const template = '{k.0}:{k.-2}:{a.b.c.d}:{x.y}:{j}';\n\n        expect(Hoek.reachTemplate(obj, template)).to.equal('4:9:1::');\n    });\n\n    it('applies object to template (options)', () => {\n\n        const obj = {\n            a: {\n                b: {\n                    c: {\n                        d: 1\n                    }\n                }\n            },\n            j: null,\n            k: [4, 8, 9, 1]\n        };\n\n        const template = '{k/0}:{k/-2}:{a/b/c/d}:{x/y}:{j}';\n\n        expect(Hoek.reachTemplate(obj, template, '/')).to.equal('4:9:1::');\n    });\n});\n\ndescribe('callStack()', () => {\n\n    it('returns the full call stack', () => {\n\n        const stack = Hoek.callStack();\n        expect(stack[0][0]).to.contain('index.js');\n    });\n});\n\ndescribe('displayStack ()', () => {\n\n    it('returns the full call stack for display', () => {\n\n        const stack = Hoek.displayStack();\n        expect(stack[0]).to.contain(Path.normalize('/test/index.js') + ':');\n    });\n\n    it('includes constructor functions correctly', () => {\n\n        return new Promise((resolve) => {\n\n            const Something = function (next) {\n\n                next();\n            };\n\n            new Something(() => {\n\n                const stack = Hoek.displayStack();\n                expect(stack[1]).to.contain('new Something');\n                resolve();\n            });\n        });\n    });\n});\n\ndescribe('abort()', () => {\n\n    it('exits process when not in test mode', async () => {\n\n        const env = process.env.NODE_ENV;\n        const write = process.stdout.write;\n        const exit = process.exit;\n\n        process.env.NODE_ENV = 'nottatest';\n        process.stdout.write = function () { };\n\n        const abort = new Promise((resolve) => {\n\n            process.exit = function (state) {\n\n                process.exit = exit;\n                process.env.NODE_ENV = env;\n                process.stdout.write = write;\n\n                expect(state).to.equal(1);\n                resolve();\n            };\n        });\n\n        Hoek.abort('Boom');\n        await abort;\n    });\n\n    it('throws when not in test mode and abortThrow is true', () => {\n\n        const env = process.env.NODE_ENV;\n        process.env.NODE_ENV = 'nottatest';\n        Hoek.abortThrow = true;\n\n        expect(() => {\n\n            Hoek.abort('my error message');\n        }).to.throw('my error message');\n        Hoek.abortThrow = false;\n        process.env.NODE_ENV = env;\n    });\n\n    it('respects hideStack argument', () => {\n\n        const env = process.env.NODE_ENV;\n        const write = process.stdout.write;\n        const exit = process.exit;\n        let output = '';\n\n        process.exit = function () { };\n        process.env.NODE_ENV = '';\n        process.stdout.write = function (message) {\n\n            output = message;\n        };\n\n        Hoek.abort('my error message', true);\n\n        process.env.NODE_ENV = env;\n        process.stdout.write = write;\n        process.exit = exit;\n\n        expect(output).to.equal('ABORT: my error message\\n\\t\\n');\n    });\n\n    it('throws in test mode', () => {\n\n        const env = process.env.NODE_ENV;\n        process.env.NODE_ENV = 'test';\n\n        expect(() => {\n\n            Hoek.abort('my error message', true);\n        }).to.throw('my error message');\n\n        process.env.NODE_ENV = env;\n    });\n\n    it('throws in test mode with default message', () => {\n\n        const env = process.env.NODE_ENV;\n        process.env.NODE_ENV = 'test';\n\n        expect(() => {\n\n            Hoek.abort('', true);\n        }).to.throw('Unknown error');\n\n        process.env.NODE_ENV = env;\n    });\n\n    it('defaults to showing stack', () => {\n\n        const env = process.env.NODE_ENV;\n        const write = process.stdout.write;\n        const exit = process.exit;\n        let output = '';\n\n        process.exit = function () { };\n        process.env.NODE_ENV = '';\n        process.stdout.write = function (message) {\n\n            output = message;\n        };\n\n        Hoek.abort('my error message');\n\n        process.env.NODE_ENV = env;\n        process.stdout.write = write;\n        process.exit = exit;\n\n        expect(output).to.contain('index.js');\n    });\n});\n\ndescribe('assert()', () => {\n\n    it('throws an Error when using assert in a test', () => {\n\n        expect(() => {\n\n            Hoek.assert(false, 'my error message');\n        }).to.throw('my error message');\n    });\n\n    it('throws an Error when using assert in a test with no message', () => {\n\n        expect(() => {\n\n            Hoek.assert(false);\n        }).to.throw('Unknown error');\n    });\n\n    it('throws an Error when using assert in a test with multipart message', () => {\n\n        expect(() => {\n\n            Hoek.assert(false, 'This', 'is', 'my message');\n        }).to.throw('This is my message');\n    });\n\n    it('throws an Error when using assert in a test with multipart message (empty)', () => {\n\n        expect(() => {\n\n            Hoek.assert(false, 'This', 'is', '', 'my message');\n        }).to.throw('This is my message');\n    });\n\n    it('throws an Error when using assert in a test with object message', () => {\n\n        expect(() => {\n\n            Hoek.assert(false, 'This', 'is', { spinal: 'tap' });\n        }).to.throw('This is {\"spinal\":\"tap\"}');\n    });\n\n    it('throws an Error when using assert in a test with multipart string and error messages', () => {\n\n        expect(() => {\n\n            Hoek.assert(false, 'This', 'is', new Error('spinal'), new Error('tap'));\n        }).to.throw('This is spinal tap');\n    });\n\n    it('throws an Error when using assert in a test with error object message', () => {\n\n        expect(() => {\n\n            Hoek.assert(false, new Error('This is spinal tap'));\n        }).to.throw('This is spinal tap');\n    });\n\n    it('throws the same Error that is passed to it if there is only one error passed', () => {\n\n        const error = new Error('ruh roh');\n        const error2 = new Error('ruh roh');\n\n        const fn = function () {\n\n            Hoek.assert(false, error);\n        };\n\n        try {\n            fn();\n        }\n        catch (err) {\n            expect(err).to.equal(error);  // should be the same reference\n            expect(err).to.not.shallow.equal(error2); // error with the same message should not match\n        }\n    });\n});\n\ndescribe('Bench', () => {\n\n    it('returns time elapsed', async () => {\n\n        const timer = new Hoek.Bench();\n        await Hoek.wait(12);\n        expect(timer.elapsed()).to.be.above(9);\n    });\n});\n\ndescribe('escapeRegex()', () => {\n\n    it('escapes all special regular expression characters', () => {\n\n        const a = Hoek.escapeRegex('4^f$s.4*5+-_?%=#!:@|~\\\\/`\"(>)[<]d{}s,');\n        expect(a).to.equal('4\\\\^f\\\\$s\\\\.4\\\\*5\\\\+\\\\-_\\\\?%\\\\=#\\\\!\\\\:@\\\\|~\\\\\\\\\\\\/`\"\\\\(>\\\\)\\\\[<\\\\]d\\\\{\\\\}s\\\\,');\n    });\n});\n\ndescribe('Base64Url', () => {\n\n    const base64str = 'AAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIjJCUmJygpKissLS4vMDEyMzQ1Njc4OTo7PD0-P0BBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWltcXV5fYGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6e3x9fn-AgYKDhIWGh4iJiouMjY6PkJGSk5SVlpeYmZqbnJ2en6ChoqOkpaanqKmqq6ytrq-wsbKztLW2t7i5uru8vb6_wMHCw8TFxsfIycrLzM3Oz9DR0tPU1dbX2Nna29zd3t_g4eLj5OXm5-jp6uvs7e7v8PHy8_T19vf4-fr7_P3-_w';\n    const str = unescape('%00%01%02%03%04%05%06%07%08%09%0A%0B%0C%0D%0E%0F%10%11%12%13%14%15%16%17%18%19%1A%1B%1C%1D%1E%1F%20%21%22%23%24%25%26%27%28%29*+%2C-./0123456789%3A%3B%3C%3D%3E%3F@ABCDEFGHIJKLMNOPQRSTUVWXYZ%5B%5C%5D%5E_%60abcdefghijklmnopqrstuvwxyz%7B%7C%7D%7E%7F%80%81%82%83%84%85%86%87%88%89%8A%8B%8C%8D%8E%8F%90%91%92%93%94%95%96%97%98%99%9A%9B%9C%9D%9E%9F%A0%A1%A2%A3%A4%A5%A6%A7%A8%A9%AA%AB%AC%AD%AE%AF%B0%B1%B2%B3%B4%B5%B6%B7%B8%B9%BA%BB%BC%BD%BE%BF%C0%C1%C2%C3%C4%C5%C6%C7%C8%C9%CA%CB%CC%CD%CE%CF%D0%D1%D2%D3%D4%D5%D6%D7%D8%D9%DA%DB%DC%DD%DE%DF%E0%E1%E2%E3%E4%E5%E6%E7%E8%E9%EA%EB%EC%ED%EE%EF%F0%F1%F2%F3%F4%F5%F6%F7%F8%F9%FA%FB%FC%FD%FE%FF');\n\n    describe('base64urlEncode()', () => {\n\n        it('should assert function input is a string or buffer', () => {\n\n            const number = 1024;\n            const func = () => {\n\n                return Hoek.base64urlEncode(number);\n            };\n            expect(func).throws(Error);\n        });\n\n        it('should base64 URL-safe a string', () => {\n\n            expect(Hoek.base64urlEncode(str)).to.equal(base64str);\n        });\n\n        it('encodes a buffer', () => {\n\n            expect(Hoek.base64urlEncode(Buffer.from(str, 'binary'))).to.equal(base64str);\n        });\n\n        it('should base64 URL-safe a hex string', () => {\n\n            const buffer = Buffer.from(str, 'binary');\n            expect(Hoek.base64urlEncode(buffer.toString('hex'), 'hex')).to.equal(base64str);\n        });\n\n        it('works on larger input strings', () => {\n\n            const input = Fs.readFileSync(Path.join(__dirname, 'index.js')).toString();\n            const encoded = Hoek.base64urlEncode(input);\n\n            expect(encoded).to.not.contain('+');\n            expect(encoded).to.not.contain('/');\n\n            const decoded = Hoek.base64urlDecode(encoded);\n            expect(decoded).to.equal(input);\n        });\n    });\n\n    describe('base64urlDecode()', () => {\n\n        it('should un-base64 URL-safe a string', () => {\n\n            expect(Hoek.base64urlDecode(base64str)).to.equal(str);\n        });\n\n        it('should un-base64 URL-safe a string into hex', () => {\n\n            expect(Hoek.base64urlDecode(base64str, 'hex')).to.equal(Buffer.from(str, 'binary').toString('hex'));\n        });\n\n        it('should un-base64 URL-safe a string and return a buffer', () => {\n\n            const buf = Hoek.base64urlDecode(base64str, 'buffer');\n            expect(buf instanceof Buffer).to.equal(true);\n            expect(buf.toString('binary')).to.equal(str);\n        });\n\n        it('throws error on invalid input', () => {\n\n            expect(() => Hoek.base64urlDecode(1024)).to.throw('Value not a string');\n        });\n\n        it('throws error on invalid input', () => {\n\n            expect(() => Hoek.base64urlDecode('*')).to.throw('Invalid character');\n        });\n    });\n});\n\ndescribe('escapeHeaderAttribute()', () => {\n\n    it('should not alter ascii values', () => {\n\n        const a = Hoek.escapeHeaderAttribute('My Value');\n        expect(a).to.equal('My Value');\n    });\n\n    it('escapes all special HTTP header attribute characters', () => {\n\n        const a = Hoek.escapeHeaderAttribute('I said go!!!#\"' + String.fromCharCode(92));\n        expect(a).to.equal('I said go!!!#\\\\\"\\\\\\\\');\n    });\n\n    it('throws on large unicode characters', () => {\n\n        expect(() => {\n\n            Hoek.escapeHeaderAttribute('this is a test' + String.fromCharCode(500) + String.fromCharCode(300));\n        }).to.throw(Error);\n    });\n\n    it('throws on CRLF to prevent response splitting', () => {\n\n        expect(() => {\n\n            Hoek.escapeHeaderAttribute('this is a test\\r\\n');\n        }).to.throw(Error);\n    });\n});\n\ndescribe('escapeHtml()', () => {\n\n    it('escapes all special HTML characters', () => {\n\n        const a = Hoek.escapeHtml('&<>\"\\'`');\n        expect(a).to.equal('&amp;&lt;&gt;&quot;&#x27;&#x60;');\n    });\n\n    it('returns empty string on falsy input', () => {\n\n        const a = Hoek.escapeHtml('');\n        expect(a).to.equal('');\n    });\n\n    it('returns unchanged string on no reserved input', () => {\n\n        const a = Hoek.escapeHtml('abc');\n        expect(a).to.equal('abc');\n    });\n});\n\ndescribe('once()', () => {\n\n    it('allows function to only execute once', () => {\n\n        let gen = 0;\n        let add = function (x) {\n\n            gen += x;\n        };\n\n        add(5);\n        expect(gen).to.equal(5);\n        add = Hoek.once(add);\n        add(5);\n        expect(gen).to.equal(10);\n        add(5);\n        expect(gen).to.equal(10);\n    });\n\n    it('double once wraps one time', () => {\n\n        let method = function () { };\n        method = Hoek.once(method);\n        method.x = 1;\n        method = Hoek.once(method);\n        expect(method.x).to.equal(1);\n    });\n});\n\n\ndescribe('isInteger()', () => {\n\n    it('validates integers', () => {\n\n        expect(Hoek.isInteger(0)).to.equal(true);\n        expect(Hoek.isInteger(1)).to.equal(true);\n        expect(Hoek.isInteger(1394035612500)).to.equal(true);\n        expect(Hoek.isInteger('0')).to.equal(false);\n        expect(Hoek.isInteger(1.0)).to.equal(true);\n        expect(Hoek.isInteger(1.1)).to.equal(false);\n        expect(Hoek.isInteger(90071992547409910.1)).to.equal(false);\n        expect(Hoek.isInteger(NaN)).to.equal(false);\n    });\n});\n\ndescribe('ignore()', () => {\n\n    it('exists', () => {\n\n        expect(Hoek.ignore).to.exist();\n        expect(typeof Hoek.ignore).to.equal('function');\n    });\n});\n\ndescribe('inherits()', () => {\n\n    it('exists', () => {\n\n        expect(Hoek.inherits).to.exist();\n        expect(typeof Hoek.inherits).to.equal('function');\n    });\n});\n\ndescribe('format()', () => {\n\n    it('exists', () => {\n\n        expect(Hoek.format).to.exist();\n        expect(typeof Hoek.format).to.equal('function');\n    });\n\n    it('is a reference to Util.format', () => {\n\n        expect(Hoek.format('hello %s', 'world')).to.equal('hello world');\n    });\n});\n\ndescribe('transform()', () => {\n\n    const source = {\n        address: {\n            one: '123 main street',\n            two: 'PO Box 1234'\n        },\n        zip: {\n            code: 3321232,\n            province: null\n        },\n        title: 'Warehouse',\n        state: 'CA'\n    };\n\n    const sourcesArray = [{\n        address: {\n            one: '123 main street',\n            two: 'PO Box 1234'\n        },\n        zip: {\n            code: 3321232,\n            province: null\n        },\n        title: 'Warehouse',\n        state: 'CA'\n    }, {\n        address: {\n            one: '456 market street',\n            two: 'PO Box 5678'\n        },\n        zip: {\n            code: 9876,\n            province: null\n        },\n        title: 'Garage',\n        state: 'NY'\n    }];\n\n    it('transforms an object based on the input object', () => {\n\n        const result = Hoek.transform(source, {\n            'person.address.lineOne': 'address.one',\n            'person.address.lineTwo': 'address.two',\n            'title': 'title',\n            'person.address.region': 'state',\n            'person.address.zip': 'zip.code',\n            'person.address.location': 'zip.province'\n        });\n\n        expect(result).to.equal({\n            person: {\n                address: {\n                    lineOne: '123 main street',\n                    lineTwo: 'PO Box 1234',\n                    region: 'CA',\n                    zip: 3321232,\n                    location: null\n                }\n            },\n            title: 'Warehouse'\n        });\n    });\n\n    it('transforms an array of objects based on the input object', () => {\n\n        const result = Hoek.transform(sourcesArray, {\n            'person.address.lineOne': 'address.one',\n            'person.address.lineTwo': 'address.two',\n            'title': 'title',\n            'person.address.region': 'state',\n            'person.address.zip': 'zip.code',\n            'person.address.location': 'zip.province'\n        });\n\n        expect(result).to.equal([\n            {\n                person: {\n                    address: {\n                        lineOne: '123 main street',\n                        lineTwo: 'PO Box 1234',\n                        region: 'CA',\n                        zip: 3321232,\n                        location: null\n                    }\n                },\n                title: 'Warehouse'\n            },\n            {\n                person: {\n                    address: {\n                        lineOne: '456 market street',\n                        lineTwo: 'PO Box 5678',\n                        region: 'NY',\n                        zip: 9876,\n                        location: null\n                    }\n                },\n                title: 'Garage'\n            }\n        ]);\n    });\n\n    it('uses the reach options passed into it', () => {\n\n        const schema = {\n            'person-address-lineOne': 'address-one',\n            'person-address-lineTwo': 'address-two',\n            'title': 'title',\n            'person-address-region': 'state',\n            'person-prefix': 'person-title',\n            'person-zip': 'zip-code'\n        };\n        const options = {\n            separator: '-',\n            default: 'unknown'\n        };\n        const result = Hoek.transform(source, schema, options);\n\n        expect(result).to.equal({\n            person: {\n                address: {\n                    lineOne: '123 main street',\n                    lineTwo: 'PO Box 1234',\n                    region: 'CA'\n                },\n                prefix: 'unknown',\n                zip: 3321232\n            },\n            title: 'Warehouse'\n        });\n    });\n\n    it('uses a default separator for keys if options does not specify on', () => {\n\n        const schema = {\n            'person.address.lineOne': 'address.one',\n            'person.address.lineTwo': 'address.two',\n            'title': 'title',\n            'person.address.region': 'state',\n            'person.prefix': 'person.title',\n            'person.zip': 'zip.code'\n        };\n        const options = {\n            default: 'unknown'\n        };\n        const result = Hoek.transform(source, schema, options);\n\n        expect(result).to.equal({\n            person: {\n                address: {\n                    lineOne: '123 main street',\n                    lineTwo: 'PO Box 1234',\n                    region: 'CA'\n                },\n                prefix: 'unknown',\n                zip: 3321232\n            },\n            title: 'Warehouse'\n        });\n    });\n\n    it('works to create shallow objects', () => {\n\n        const result = Hoek.transform(source, {\n            lineOne: 'address.one',\n            lineTwo: 'address.two',\n            title: 'title',\n            region: 'state',\n            province: 'zip.province'\n        });\n\n        expect(result).to.equal({\n            lineOne: '123 main street',\n            lineTwo: 'PO Box 1234',\n            title: 'Warehouse',\n            region: 'CA',\n            province: null\n        });\n    });\n\n    it('only allows strings in the map', () => {\n\n        expect(() => {\n\n            Hoek.transform(source, {\n                lineOne: {}\n            });\n        }).to.throw('All mappings must be \".\" delineated strings');\n    });\n\n    it('throws an error on invalid arguments', () => {\n\n        expect(() => {\n\n            Hoek.transform(NaN, {});\n        }).to.throw('Invalid source object: must be null, undefined, an object, or an array');\n    });\n\n    it('is safe to pass null', () => {\n\n        const result = Hoek.transform(null, {});\n        expect(result).to.equal({});\n    });\n\n    it('is safe to pass undefined', () => {\n\n        const result = Hoek.transform(undefined, {});\n        expect(result).to.equal({});\n    });\n});\n\ndescribe('uniqueFilename()', () => {\n\n    it('generates a random file path', () => {\n\n        const result = Hoek.uniqueFilename('./test/modules');\n\n        expect(result).to.exist();\n        expect(result).to.be.a.string();\n        expect(result).to.contain(`test${Path.sep}modules`);\n    });\n\n    it('is random enough to use in fast loops', () => {\n\n        const results = [];\n\n        for (let i = 0; i < 10; ++i) {\n            results[i] = Hoek.uniqueFilename('./test/modules');\n        }\n\n        const filter = results.filter((item, index, array) => {\n\n            return array.indexOf(item) === index;\n        });\n\n        expect(filter.length).to.equal(10);\n        expect(results.length).to.equal(10);\n    });\n\n    it('combines the random elements with a supplied character', () => {\n\n        const result = Hoek.uniqueFilename('./test', 'txt');\n\n        expect(result).to.contain(`test${Path.sep}`);\n        expect(result).to.contain('.txt');\n    });\n\n    it('accepts extensions with a \".\" in it', () => {\n\n        const result = Hoek.uniqueFilename('./test', '.mp3');\n\n        expect(result).to.contain(`test${Path.sep}`);\n        expect(result).to.contain('.mp3');\n    });\n});\n\ndescribe('stringify()', () => {\n\n    it('converts object to string', () => {\n\n        const obj = { a: 1 };\n        expect(Hoek.stringify(obj)).to.equal('{\"a\":1}');\n    });\n\n    it('returns error in result string', () => {\n\n        const obj = { a: 1 };\n        obj.b = obj;\n        expect(Hoek.stringify(obj)).to.equal('[Cannot display object: Converting circular structure to JSON]');\n    });\n});\n\ndescribe('shallow()', () => {\n\n    it('shallow copies an object', () => {\n\n        const obj = {\n            a: 5,\n            b: {\n                c: 6\n            }\n        };\n\n        const shallow = Hoek.shallow(obj);\n        expect(shallow).to.not.shallow.equal(obj);\n        expect(shallow).to.equal(obj);\n        expect(shallow.b).to.equal(obj.b);\n    });\n});\n\ndescribe('block()', () => {\n\n    it('executes ignore function', async () => {\n\n        const orig = Hoek.ignore;\n        Hoek.ignore = (resolve) => resolve();\n        await Hoek.block();\n        Hoek.ignore = orig;\n    });\n});\n"], "fixing_code": ["'use strict';\n\n// Load modules\n\nconst Assert = require('assert');\nconst Crypto = require('crypto');\nconst Path = require('path');\nconst Util = require('util');\n\nconst Escape = require('./escape');\n\n\n// Declare internals\n\nconst internals = {};\n\n\n// Clone object or array\n\nexports.clone = function (obj, seen) {\n\n    if (typeof obj !== 'object' ||\n        obj === null) {\n\n        return obj;\n    }\n\n    seen = seen || new Map();\n\n    const lookup = seen.get(obj);\n    if (lookup) {\n        return lookup;\n    }\n\n    let newObj;\n    let cloneDeep = false;\n\n    if (!Array.isArray(obj)) {\n        if (Buffer.isBuffer(obj)) {\n            newObj = Buffer.from(obj);\n        }\n        else if (obj instanceof Date) {\n            newObj = new Date(obj.getTime());\n        }\n        else if (obj instanceof RegExp) {\n            newObj = new RegExp(obj);\n        }\n        else {\n            const proto = Object.getPrototypeOf(obj);\n            if (proto &&\n                proto.isImmutable) {\n\n                newObj = obj;\n            }\n            else {\n                newObj = Object.create(proto);\n                cloneDeep = true;\n            }\n        }\n    }\n    else {\n        newObj = [];\n        cloneDeep = true;\n    }\n\n    seen.set(obj, newObj);\n\n    if (cloneDeep) {\n        const keys = Object.getOwnPropertyNames(obj);\n        for (let i = 0; i < keys.length; ++i) {\n            const key = keys[i];\n            const descriptor = Object.getOwnPropertyDescriptor(obj, key);\n            if (descriptor &&\n                (descriptor.get ||\n                    descriptor.set)) {\n\n                Object.defineProperty(newObj, key, descriptor);\n            }\n            else {\n                newObj[key] = exports.clone(obj[key], seen);\n            }\n        }\n    }\n\n    return newObj;\n};\n\n\n// Merge all the properties of source into target, source wins in conflict, and by default null and undefined from source are applied\n\n/*eslint-disable */\nexports.merge = function (target, source, isNullOverride /* = true */, isMergeArrays /* = true */) {\n    /*eslint-enable */\n\n    exports.assert(target && typeof target === 'object', 'Invalid target value: must be an object');\n    exports.assert(source === null || source === undefined || typeof source === 'object', 'Invalid source value: must be null, undefined, or an object');\n\n    if (!source) {\n        return target;\n    }\n\n    if (Array.isArray(source)) {\n        exports.assert(Array.isArray(target), 'Cannot merge array onto an object');\n        if (isMergeArrays === false) {                                                  // isMergeArrays defaults to true\n            target.length = 0;                                                          // Must not change target assignment\n        }\n\n        for (let i = 0; i < source.length; ++i) {\n            target.push(exports.clone(source[i]));\n        }\n\n        return target;\n    }\n\n    const keys = Object.keys(source);\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i];\n        if (key === '__proto__') {\n            continue;\n        }\n\n        const value = source[key];\n        if (value &&\n            typeof value === 'object') {\n\n            if (!target[key] ||\n                typeof target[key] !== 'object' ||\n                (Array.isArray(target[key]) !== Array.isArray(value)) ||\n                value instanceof Date ||\n                Buffer.isBuffer(value) ||\n                value instanceof RegExp) {\n\n                target[key] = exports.clone(value);\n            }\n            else {\n                exports.merge(target[key], value, isNullOverride, isMergeArrays);\n            }\n        }\n        else {\n            if (value !== null &&\n                value !== undefined) {                              // Explicit to preserve empty strings\n\n                target[key] = value;\n            }\n            else if (isNullOverride !== false) {                    // Defaults to true\n                target[key] = value;\n            }\n        }\n    }\n\n    return target;\n};\n\n\n// Apply options to a copy of the defaults\n\nexports.applyToDefaults = function (defaults, options, isNullOverride) {\n\n    exports.assert(defaults && typeof defaults === 'object', 'Invalid defaults value: must be an object');\n    exports.assert(!options || options === true || typeof options === 'object', 'Invalid options value: must be true, falsy or an object');\n\n    if (!options) {                                                 // If no options, return null\n        return null;\n    }\n\n    const copy = exports.clone(defaults);\n\n    if (options === true) {                                         // If options is set to true, use defaults\n        return copy;\n    }\n\n    return exports.merge(copy, options, isNullOverride === true, false);\n};\n\n\n// Clone an object except for the listed keys which are shallow copied\n\nexports.cloneWithShallow = function (source, keys) {\n\n    if (!source ||\n        typeof source !== 'object') {\n\n        return source;\n    }\n\n    const storage = internals.store(source, keys);    // Move shallow copy items to storage\n    const copy = exports.clone(source);               // Deep copy the rest\n    internals.restore(copy, source, storage);       // Shallow copy the stored items and restore\n    return copy;\n};\n\n\ninternals.store = function (source, keys) {\n\n    const storage = {};\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i];\n        const value = exports.reach(source, key);\n        if (value !== undefined) {\n            storage[key] = value;\n            internals.reachSet(source, key, undefined);\n        }\n    }\n\n    return storage;\n};\n\n\ninternals.restore = function (copy, source, storage) {\n\n    const keys = Object.keys(storage);\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i];\n        internals.reachSet(copy, key, storage[key]);\n        internals.reachSet(source, key, storage[key]);\n    }\n};\n\n\ninternals.reachSet = function (obj, key, value) {\n\n    const path = key.split('.');\n    let ref = obj;\n    for (let i = 0; i < path.length; ++i) {\n        const segment = path[i];\n        if (i + 1 === path.length) {\n            ref[segment] = value;\n        }\n\n        ref = ref[segment];\n    }\n};\n\n\n// Apply options to defaults except for the listed keys which are shallow copied from option without merging\n\nexports.applyToDefaultsWithShallow = function (defaults, options, keys) {\n\n    exports.assert(defaults && typeof defaults === 'object', 'Invalid defaults value: must be an object');\n    exports.assert(!options || options === true || typeof options === 'object', 'Invalid options value: must be true, falsy or an object');\n    exports.assert(keys && Array.isArray(keys), 'Invalid keys');\n\n    if (!options) {                                                 // If no options, return null\n        return null;\n    }\n\n    const copy = exports.cloneWithShallow(defaults, keys);\n\n    if (options === true) {                                         // If options is set to true, use defaults\n        return copy;\n    }\n\n    const storage = internals.store(options, keys);   // Move shallow copy items to storage\n    exports.merge(copy, options, false, false);     // Deep copy the rest\n    internals.restore(copy, options, storage);      // Shallow copy the stored items and restore\n    return copy;\n};\n\n\n// Deep object or array comparison\n\nexports.deepEqual = function (obj, ref, options, seen) {\n\n    options = options || { prototype: true };\n\n    const type = typeof obj;\n\n    if (type !== typeof ref) {\n        return false;\n    }\n\n    if (type !== 'object' ||\n        obj === null ||\n        ref === null) {\n\n        if (obj === ref) {                                                      // Copied from Deep-eql, copyright(c) 2013 Jake Luer, jake@alogicalparadox.com, MIT Licensed, https://github.com/chaijs/deep-eql\n            return obj !== 0 || 1 / obj === 1 / ref;        // -0 / +0\n        }\n\n        return obj !== obj && ref !== ref;                  // NaN\n    }\n\n    seen = seen || [];\n    if (seen.indexOf(obj) !== -1) {\n        return true;                            // If previous comparison failed, it would have stopped execution\n    }\n\n    seen.push(obj);\n\n    if (Array.isArray(obj)) {\n        if (!Array.isArray(ref)) {\n            return false;\n        }\n\n        if (!options.part && obj.length !== ref.length) {\n            return false;\n        }\n\n        for (let i = 0; i < obj.length; ++i) {\n            if (options.part) {\n                let found = false;\n                for (let j = 0; j < ref.length; ++j) {\n                    if (exports.deepEqual(obj[i], ref[j], options)) {\n                        found = true;\n                        break;\n                    }\n                }\n\n                return found;\n            }\n\n            if (!exports.deepEqual(obj[i], ref[i], options)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    if (Buffer.isBuffer(obj)) {\n        if (!Buffer.isBuffer(ref)) {\n            return false;\n        }\n\n        if (obj.length !== ref.length) {\n            return false;\n        }\n\n        for (let i = 0; i < obj.length; ++i) {\n            if (obj[i] !== ref[i]) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    if (obj instanceof Date) {\n        return (ref instanceof Date && obj.getTime() === ref.getTime());\n    }\n\n    if (obj instanceof RegExp) {\n        return (ref instanceof RegExp && obj.toString() === ref.toString());\n    }\n\n    if (options.prototype) {\n        if (Object.getPrototypeOf(obj) !== Object.getPrototypeOf(ref)) {\n            return false;\n        }\n    }\n\n    const keys = Object.getOwnPropertyNames(obj);\n\n    if (!options.part && keys.length !== Object.getOwnPropertyNames(ref).length) {\n        return false;\n    }\n\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i];\n        const descriptor = Object.getOwnPropertyDescriptor(obj, key);\n        if (descriptor.get) {\n            if (!exports.deepEqual(descriptor, Object.getOwnPropertyDescriptor(ref, key), options, seen)) {\n                return false;\n            }\n        }\n        else if (!exports.deepEqual(obj[key], ref[key], options, seen)) {\n            return false;\n        }\n    }\n\n    return true;\n};\n\n\n// Remove duplicate items from array\n\nexports.unique = (array, key) => {\n\n    let result;\n    if (key) {\n        result = [];\n        const index = new Set();\n        array.forEach((item) => {\n\n            const identifier = item[key];\n            if (!index.has(identifier)) {\n                index.add(identifier);\n                result.push(item);\n            }\n        });\n    }\n    else {\n        result = Array.from(new Set(array));\n    }\n\n    return result;\n};\n\n\n// Convert array into object\n\nexports.mapToObject = function (array, key) {\n\n    if (!array) {\n        return null;\n    }\n\n    const obj = {};\n    for (let i = 0; i < array.length; ++i) {\n        if (key) {\n            if (array[i][key]) {\n                obj[array[i][key]] = true;\n            }\n        }\n        else {\n            obj[array[i]] = true;\n        }\n    }\n\n    return obj;\n};\n\n\n// Find the common unique items in two arrays\n\nexports.intersect = function (array1, array2, justFirst) {\n\n    if (!array1 || !array2) {\n        return [];\n    }\n\n    const common = [];\n    const hash = (Array.isArray(array1) ? exports.mapToObject(array1) : array1);\n    const found = {};\n    for (let i = 0; i < array2.length; ++i) {\n        if (hash[array2[i]] && !found[array2[i]]) {\n            if (justFirst) {\n                return array2[i];\n            }\n\n            common.push(array2[i]);\n            found[array2[i]] = true;\n        }\n    }\n\n    return (justFirst ? null : common);\n};\n\n\n// Test if the reference contains the values\n\nexports.contain = function (ref, values, options) {\n\n    /*\n        string -> string(s)\n        array -> item(s)\n        object -> key(s)\n        object -> object (key:value)\n    */\n\n    let valuePairs = null;\n    if (typeof ref === 'object' &&\n        typeof values === 'object' &&\n        !Array.isArray(ref) &&\n        !Array.isArray(values)) {\n\n        valuePairs = values;\n        values = Object.keys(values);\n    }\n    else {\n        values = [].concat(values);\n    }\n\n    options = options || {};            // deep, once, only, part\n\n    exports.assert(typeof ref === 'string' || typeof ref === 'object', 'Reference must be string or an object');\n    exports.assert(values.length, 'Values array cannot be empty');\n\n    let compare;\n    let compareFlags;\n    if (options.deep) {\n        compare = exports.deepEqual;\n\n        const hasOnly = options.hasOwnProperty('only');\n        const hasPart = options.hasOwnProperty('part');\n\n        compareFlags = {\n            prototype: hasOnly ? options.only : hasPart ? !options.part : false,\n            part: hasOnly ? !options.only : hasPart ? options.part : true\n        };\n    }\n    else {\n        compare = (a, b) => a === b;\n    }\n\n    let misses = false;\n    const matches = new Array(values.length);\n    for (let i = 0; i < matches.length; ++i) {\n        matches[i] = 0;\n    }\n\n    if (typeof ref === 'string') {\n        let pattern = '(';\n        for (let i = 0; i < values.length; ++i) {\n            const value = values[i];\n            exports.assert(typeof value === 'string', 'Cannot compare string reference to non-string value');\n            pattern += (i ? '|' : '') + exports.escapeRegex(value);\n        }\n\n        const regex = new RegExp(pattern + ')', 'g');\n        const leftovers = ref.replace(regex, ($0, $1) => {\n\n            const index = values.indexOf($1);\n            ++matches[index];\n            return '';          // Remove from string\n        });\n\n        misses = !!leftovers;\n    }\n    else if (Array.isArray(ref)) {\n        for (let i = 0; i < ref.length; ++i) {\n            let matched = false;\n            for (let j = 0; j < values.length && matched === false; ++j) {\n                matched = compare(values[j], ref[i], compareFlags) && j;\n            }\n\n            if (matched !== false) {\n                ++matches[matched];\n            }\n            else {\n                misses = true;\n            }\n        }\n    }\n    else {\n        const keys = Object.getOwnPropertyNames(ref);\n        for (let i = 0; i < keys.length; ++i) {\n            const key = keys[i];\n            const pos = values.indexOf(key);\n            if (pos !== -1) {\n                if (valuePairs &&\n                    !compare(valuePairs[key], ref[key], compareFlags)) {\n\n                    return false;\n                }\n\n                ++matches[pos];\n            }\n            else {\n                misses = true;\n            }\n        }\n    }\n\n    let result = false;\n    for (let i = 0; i < matches.length; ++i) {\n        result = result || !!matches[i];\n        if ((options.once && matches[i] > 1) ||\n            (!options.part && !matches[i])) {\n\n            return false;\n        }\n    }\n\n    if (options.only &&\n        misses) {\n\n        return false;\n    }\n\n    return result;\n};\n\n\n// Flatten array\n\nexports.flatten = function (array, target) {\n\n    const result = target || [];\n\n    for (let i = 0; i < array.length; ++i) {\n        if (Array.isArray(array[i])) {\n            exports.flatten(array[i], result);\n        }\n        else {\n            result.push(array[i]);\n        }\n    }\n\n    return result;\n};\n\n\n// Convert an object key chain string ('a.b.c') to reference (object[a][b][c])\n\nexports.reach = function (obj, chain, options) {\n\n    if (chain === false ||\n        chain === null ||\n        typeof chain === 'undefined') {\n\n        return obj;\n    }\n\n    options = options || {};\n    if (typeof options === 'string') {\n        options = { separator: options };\n    }\n\n    const path = chain.split(options.separator || '.');\n    let ref = obj;\n    for (let i = 0; i < path.length; ++i) {\n        let key = path[i];\n        if (key[0] === '-' && Array.isArray(ref)) {\n            key = key.slice(1, key.length);\n            key = ref.length - key;\n        }\n\n        if (!ref ||\n            !((typeof ref === 'object' || typeof ref === 'function') && key in ref) ||\n            (typeof ref !== 'object' && options.functions === false)) {         // Only object and function can have properties\n\n            exports.assert(!options.strict || i + 1 === path.length, 'Missing segment', key, 'in reach path ', chain);\n            exports.assert(typeof ref === 'object' || options.functions === true || typeof ref !== 'function', 'Invalid segment', key, 'in reach path ', chain);\n            ref = options.default;\n            break;\n        }\n\n        ref = ref[key];\n    }\n\n    return ref;\n};\n\n\nexports.reachTemplate = function (obj, template, options) {\n\n    return template.replace(/{([^}]+)}/g, ($0, chain) => {\n\n        const value = exports.reach(obj, chain, options);\n        return (value === undefined || value === null ? '' : value);\n    });\n};\n\n\nexports.formatStack = function (stack) {\n\n    const trace = [];\n    for (let i = 0; i < stack.length; ++i) {\n        const item = stack[i];\n        trace.push([item.getFileName(), item.getLineNumber(), item.getColumnNumber(), item.getFunctionName(), item.isConstructor()]);\n    }\n\n    return trace;\n};\n\n\nexports.formatTrace = function (trace) {\n\n    const display = [];\n\n    for (let i = 0; i < trace.length; ++i) {\n        const row = trace[i];\n        display.push((row[4] ? 'new ' : '') + row[3] + ' (' + row[0] + ':' + row[1] + ':' + row[2] + ')');\n    }\n\n    return display;\n};\n\n\nexports.callStack = function (slice) {\n\n    // http://code.google.com/p/v8/wiki/JavaScriptStackTraceApi\n\n    const v8 = Error.prepareStackTrace;\n    Error.prepareStackTrace = function (_, stack) {\n\n        return stack;\n    };\n\n    const capture = {};\n    Error.captureStackTrace(capture, this);\n    const stack = capture.stack;\n\n    Error.prepareStackTrace = v8;\n\n    const trace = exports.formatStack(stack);\n\n    return trace.slice(1 + slice);\n};\n\n\nexports.displayStack = function (slice) {\n\n    const trace = exports.callStack(slice === undefined ? 1 : slice + 1);\n\n    return exports.formatTrace(trace);\n};\n\n\nexports.abortThrow = false;\n\n\nexports.abort = function (message, hideStack) {\n\n    if (process.env.NODE_ENV === 'test' || exports.abortThrow === true) {\n        throw new Error(message || 'Unknown error');\n    }\n\n    let stack = '';\n    if (!hideStack) {\n        stack = exports.displayStack(1).join('\\n\\t');\n    }\n    console.log('ABORT: ' + message + '\\n\\t' + stack);\n    process.exit(1);\n};\n\n\nexports.assert = function (condition, ...args) {\n\n    if (condition) {\n        return;\n    }\n\n    if (args.length === 1 && args[0] instanceof Error) {\n        throw args[0];\n    }\n\n    const msgs = args\n        .filter((arg) => arg !== '')\n        .map((arg) => {\n\n            return typeof arg === 'string' ? arg : arg instanceof Error ? arg.message : exports.stringify(arg);\n        });\n\n    throw new Assert.AssertionError({\n        message: msgs.join(' ') || 'Unknown error',\n        actual: false,\n        expected: true,\n        operator: '==',\n        stackStartFunction: exports.assert\n    });\n};\n\n\nexports.Bench = function () {\n\n    this.ts = 0;\n    this.reset();\n};\n\n\nexports.Bench.prototype.reset = function () {\n\n    this.ts = exports.Bench.now();\n};\n\n\nexports.Bench.prototype.elapsed = function () {\n\n    return exports.Bench.now() - this.ts;\n};\n\n\nexports.Bench.now = function () {\n\n    const ts = process.hrtime();\n    return (ts[0] * 1e3) + (ts[1] / 1e6);\n};\n\n\n// Escape string for Regex construction\n\nexports.escapeRegex = function (string) {\n\n    // Escape ^$.*+-?=!:|\\/()[]{},\n    return string.replace(/[\\^\\$\\.\\*\\+\\-\\?\\=\\!\\:\\|\\\\\\/\\(\\)\\[\\]\\{\\}\\,]/g, '\\\\$&');\n};\n\n\n// Base64url (RFC 4648) encode\n\nexports.base64urlEncode = function (value, encoding) {\n\n    exports.assert(typeof value === 'string' || Buffer.isBuffer(value), 'value must be string or buffer');\n    const buf = (Buffer.isBuffer(value) ? value : Buffer.from(value, encoding || 'binary'));\n    return buf.toString('base64').replace(/\\+/g, '-').replace(/\\//g, '_').replace(/\\=/g, '');\n};\n\n\n// Base64url (RFC 4648) decode\n\nexports.base64urlDecode = function (value, encoding) {\n\n    if (typeof value !== 'string') {\n\n        throw new Error('Value not a string');\n    }\n\n    if (!/^[\\w\\-]*$/.test(value)) {\n\n        throw new Error('Invalid character');\n    }\n\n    const buf = Buffer.from(value, 'base64');\n    return (encoding === 'buffer' ? buf : buf.toString(encoding || 'binary'));\n};\n\n\n// Escape attribute value for use in HTTP header\n\nexports.escapeHeaderAttribute = function (attribute) {\n\n    // Allowed value characters: !#$%&'()*+,-./:;<=>?@[]^_`{|}~ and space, a-z, A-Z, 0-9, \\, \"\n\n    exports.assert(/^[ \\w\\!#\\$%&'\\(\\)\\*\\+,\\-\\.\\/\\:;<\\=>\\?@\\[\\]\\^`\\{\\|\\}~\\\"\\\\]*$/.test(attribute), 'Bad attribute value (' + attribute + ')');\n\n    return attribute.replace(/\\\\/g, '\\\\\\\\').replace(/\\\"/g, '\\\\\"');                             // Escape quotes and slash\n};\n\n\nexports.escapeHtml = function (string) {\n\n    return Escape.escapeHtml(string);\n};\n\n\nexports.escapeJavaScript = function (string) {\n\n    return Escape.escapeJavaScript(string);\n};\n\n\nexports.escapeJson = function (string) {\n\n    return Escape.escapeJson(string);\n};\n\n\nexports.once = function (method) {\n\n    if (method._hoekOnce) {\n        return method;\n    }\n\n    let once = false;\n    const wrapped = function (...args) {\n\n        if (!once) {\n            once = true;\n            method.apply(null, args);\n        }\n    };\n\n    wrapped._hoekOnce = true;\n    return wrapped;\n};\n\n\nexports.isInteger = Number.isSafeInteger;\n\n\nexports.ignore = function () { };\n\n\nexports.inherits = Util.inherits;\n\n\nexports.format = Util.format;\n\n\nexports.transform = function (source, transform, options) {\n\n    exports.assert(source === null || source === undefined || typeof source === 'object' || Array.isArray(source), 'Invalid source object: must be null, undefined, an object, or an array');\n    const separator = (typeof options === 'object' && options !== null) ? (options.separator || '.') : '.';\n\n    if (Array.isArray(source)) {\n        const results = [];\n        for (let i = 0; i < source.length; ++i) {\n            results.push(exports.transform(source[i], transform, options));\n        }\n        return results;\n    }\n\n    const result = {};\n    const keys = Object.keys(transform);\n\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i];\n        const path = key.split(separator);\n        const sourcePath = transform[key];\n\n        exports.assert(typeof sourcePath === 'string', 'All mappings must be \".\" delineated strings');\n\n        let segment;\n        let res = result;\n\n        while (path.length > 1) {\n            segment = path.shift();\n            if (!res[segment]) {\n                res[segment] = {};\n            }\n            res = res[segment];\n        }\n        segment = path.shift();\n        res[segment] = exports.reach(source, sourcePath, options);\n    }\n\n    return result;\n};\n\n\nexports.uniqueFilename = function (path, extension) {\n\n    if (extension) {\n        extension = extension[0] !== '.' ? '.' + extension : extension;\n    }\n    else {\n        extension = '';\n    }\n\n    path = Path.resolve(path);\n    const name = [Date.now(), process.pid, Crypto.randomBytes(8).toString('hex')].join('-') + extension;\n    return Path.join(path, name);\n};\n\n\nexports.stringify = function (...args) {\n\n    try {\n        return JSON.stringify.apply(null, args);\n    }\n    catch (err) {\n        return '[Cannot display object: ' + err.message + ']';\n    }\n};\n\n\nexports.shallow = function (source) {\n\n    const target = {};\n    const keys = Object.keys(source);\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i];\n        target[key] = source[key];\n    }\n\n    return target;\n};\n\n\nexports.wait = function (timeout) {\n\n    return new Promise((resolve) => setTimeout(resolve, timeout));\n};\n\n\nexports.block = function () {\n\n    return new Promise(exports.ignore);\n};\n", "'use strict';\n\n// Load modules\n\nconst Fs = require('fs');\nconst Path = require('path');\nconst Util = require('util');\n\nconst Code = require('code');\nconst Hoek = require('../lib');\nconst Lab = require('lab');\n\n\n// Declare internals\n\nconst internals = {};\n\n\n// Test shortcuts\n\nconst { describe, it } = exports.lab = Lab.script();\nconst expect = Code.expect;\n\n\nconst nestedObj = {\n    v: [7, 8, 9],\n    w: /^something$/igm,\n    x: {\n        a: [1, 2, 3],\n        b: 123456,\n        c: new Date(),\n        d: /hi/igm,\n        e: /hello/\n    },\n    y: 'y',\n    z: new Date(1378775452757)\n};\n\ninternals.unique = {\n    item: {\n        objects: [nestedObj, { z: 'z' }]\n    }\n};\n\ninternals.unique.objectsByKey = {\n    dups: [internals.unique.item.objects[0], internals.unique.item.objects[1], internals.unique.item.objects[0]],\n    result: [internals.unique.item.objects[0], internals.unique.item.objects[1]]\n};\n\ninternals.unique.objects = {\n    dups: [internals.unique.item.objects[1], internals.unique.item.objects[0], internals.unique.item.objects[0]],\n    result: [internals.unique.item.objects[1], internals.unique.item.objects[0]]\n};\n\ninternals.unique.integers = {\n    dups: [1, 2, 3, 2, 2, 1, 3, 4, 5],\n    result: [1, 2, 3, 4, 5]\n};\n\ninternals.unique.strings = {\n    dups: ['a', 'b', 'c', 'd', 'a', 'c', 'e'],\n    result: ['a', 'b', 'c', 'd', 'e']\n};\n\ninternals.unique.mixed = {\n    dups: [1, 2, 'a', 'b', internals.unique.item.objects[0], 'a', '2', 3, internals.unique.item.objects[0]],\n    result: [1, 2, 'a', ',b', internals.unique.item.objects[0], 3]\n};\n\n\ndescribe('clone()', () => {\n\n    it('clones a nested object', () => {\n\n        const a = nestedObj;\n        const b = Hoek.clone(a);\n\n        expect(a).to.equal(b);\n        expect(a.z.getTime()).to.equal(b.z.getTime());\n    });\n\n    it('clones a null object', () => {\n\n        const b = Hoek.clone(null);\n\n        expect(b).to.equal(null);\n    });\n\n    it('should not convert undefined properties to null', () => {\n\n        const obj = { something: undefined };\n        const b = Hoek.clone(obj);\n\n        expect(typeof b.something).to.equal('undefined');\n    });\n\n    it('should not throw on circular reference', () => {\n\n        const a = {};\n        a.x = a;\n\n        expect(() => {\n\n            Hoek.clone(a);\n        }).to.not.throw();\n    });\n\n    it('clones circular reference', () => {\n\n        const x = {\n            'z': new Date()\n        };\n        x.y = x;\n\n        const b = Hoek.clone(x);\n        expect(Object.keys(b.y)).to.equal(Object.keys(x));\n        expect(b.z).to.not.shallow.equal(x.z);\n        expect(b.y).to.not.shallow.equal(x.y);\n        expect(b.y.z).to.not.shallow.equal(x.y.z);\n        expect(b.y).to.equal(b);\n        expect(b.y.y.y.y).to.equal(b);\n    });\n\n    it('clones an object with a null prototype', () => {\n\n        const obj = Object.create(null);\n        const b = Hoek.clone(obj);\n\n        expect(b).to.equal(obj);\n    });\n\n    it('clones deeply nested object', () => {\n\n        const a = {\n            x: {\n                y: {\n                    a: [1, 2, 3],\n                    b: 123456,\n                    c: new Date(),\n                    d: /hi/igm,\n                    e: /hello/\n                }\n            }\n        };\n\n        const b = Hoek.clone(a);\n\n        expect(a).to.equal(b);\n        expect(a.x.y.c.getTime()).to.equal(b.x.y.c.getTime());\n    });\n\n    it('clones arrays', () => {\n\n        const a = [1, 2, 3];\n\n        const b = Hoek.clone(a);\n\n        expect(a).to.equal(b);\n    });\n\n    it('performs actual copy for shallow keys (no pass by reference)', () => {\n\n        const x = Hoek.clone(nestedObj);\n        const y = Hoek.clone(nestedObj);\n\n        // Date\n        expect(x.z).to.not.shallow.equal(nestedObj.z);\n        expect(x.z).to.not.shallow.equal(y.z);\n\n        // Regex\n        expect(x.w).to.not.shallow.equal(nestedObj.w);\n        expect(x.w).to.not.shallow.equal(y.w);\n\n        // Array\n        expect(x.v).to.not.shallow.equal(nestedObj.v);\n        expect(x.v).to.not.shallow.equal(y.v);\n\n        // Immutable(s)\n        x.y = 5;\n        expect(x.y).to.not.equal(nestedObj.y);\n        expect(x.y).to.not.equal(y.y);\n    });\n\n    it('performs actual copy for deep keys (no pass by reference)', () => {\n\n        const x = Hoek.clone(nestedObj);\n        const y = Hoek.clone(nestedObj);\n\n        expect(x.x.c).to.not.shallow.equal(nestedObj.x.c);\n        expect(x.x.c).to.not.shallow.equal(y.x.c);\n\n        expect(x.x.c.getTime()).to.equal(nestedObj.x.c.getTime());\n        expect(x.x.c.getTime()).to.equal(y.x.c.getTime());\n    });\n\n    it('copies functions with properties', () => {\n\n        const a = {\n            x: function () {\n\n                return 1;\n            },\n            y: {}\n        };\n        a.x.z = 'string in function';\n        a.x.v = function () {\n\n            return 2;\n        };\n        a.y.u = a.x;\n\n        const b = Hoek.clone(a);\n        expect(b.x()).to.equal(1);\n        expect(b.x.v()).to.equal(2);\n        expect(b.y.u).to.equal(b.x);\n        expect(b.x.z).to.equal('string in function');\n    });\n\n    it('should copy a buffer', () => {\n\n        const tls = {\n            key: Buffer.from([1, 2, 3, 4, 5]),\n            cert: Buffer.from([1, 2, 3, 4, 5, 6, 10])\n        };\n\n        const copiedTls = Hoek.clone(tls);\n        expect(Buffer.isBuffer(copiedTls.key)).to.equal(true);\n        expect(JSON.stringify(copiedTls.key)).to.equal(JSON.stringify(tls.key));\n        expect(Buffer.isBuffer(copiedTls.cert)).to.equal(true);\n        expect(JSON.stringify(copiedTls.cert)).to.equal(JSON.stringify(tls.cert));\n\n        tls.key.write('hi');\n        expect(JSON.stringify(copiedTls.key)).to.not.equal(JSON.stringify(tls.key));\n    });\n\n    it('clones an object with a prototype', () => {\n\n        const Obj = function () {\n\n            this.a = 5;\n        };\n\n        Obj.prototype.b = function () {\n\n            return 'c';\n        };\n\n        const a = new Obj();\n        const b = Hoek.clone(a);\n\n        expect(b.a).to.equal(5);\n        expect(b.b()).to.equal('c');\n        expect(a).to.equal(b);\n    });\n\n    it('reuses cloned Date object', () => {\n\n        const obj = {\n            a: new Date()\n        };\n\n        obj.b = obj.a;\n\n        const copy = Hoek.clone(obj);\n        expect(copy.a).to.equal(copy.b);\n    });\n\n    it('shallow copies an object with a prototype and isImmutable flag', () => {\n\n        const Obj = function () {\n\n            this.value = 5;\n        };\n\n        Obj.prototype.b = function () {\n\n            return 'c';\n        };\n\n        Obj.prototype.isImmutable = true;\n\n        const obj = {\n            a: new Obj()\n        };\n\n        const copy = Hoek.clone(obj);\n\n        expect(obj.a.value).to.equal(5);\n        expect(copy.a.value).to.equal(5);\n        expect(copy.a.b()).to.equal('c');\n        expect(obj.a).to.equal(copy.a);\n    });\n\n    it('clones an object with property getter without executing it', () => {\n\n        const obj = {};\n        const value = 1;\n        let execCount = 0;\n\n        Object.defineProperty(obj, 'test', {\n            enumerable: true,\n            configurable: true,\n            get: function () {\n\n                ++execCount;\n                return value;\n            }\n        });\n\n        const copy = Hoek.clone(obj);\n        expect(execCount).to.equal(0);\n        expect(copy.test).to.equal(1);\n        expect(execCount).to.equal(1);\n    });\n\n    it('clones an object with property getter and setter', () => {\n\n        const obj = {\n            _test: 0\n        };\n\n        Object.defineProperty(obj, 'test', {\n            enumerable: true,\n            configurable: true,\n            get: function () {\n\n                return this._test;\n            },\n            set: function (value) {\n\n                this._test = value - 1;\n            }\n        });\n\n        const copy = Hoek.clone(obj);\n        expect(copy.test).to.equal(0);\n        copy.test = 5;\n        expect(copy.test).to.equal(4);\n    });\n\n    it('clones an object with only property setter', () => {\n\n        const obj = {\n            _test: 0\n        };\n\n        Object.defineProperty(obj, 'test', {\n            enumerable: true,\n            configurable: true,\n            set: function (value) {\n\n                this._test = value - 1;\n            }\n        });\n\n        const copy = Hoek.clone(obj);\n        expect(copy._test).to.equal(0);\n        copy.test = 5;\n        expect(copy._test).to.equal(4);\n    });\n\n    it('clones an object with non-enumerable properties', () => {\n\n        const obj = {\n            _test: 0\n        };\n\n        Object.defineProperty(obj, 'test', {\n            enumerable: false,\n            configurable: true,\n            set: function (value) {\n\n                this._test = value - 1;\n            }\n        });\n\n        const copy = Hoek.clone(obj);\n        expect(copy._test).to.equal(0);\n        copy.test = 5;\n        expect(copy._test).to.equal(4);\n    });\n\n    it('clones an object where getOwnPropertyDescriptor returns undefined', () => {\n\n        const oldGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n        const obj = { a: 'b' };\n        Object.getOwnPropertyDescriptor = function () {\n\n            return undefined;\n        };\n\n        const copy = Hoek.clone(obj);\n        Object.getOwnPropertyDescriptor = oldGetOwnPropertyDescriptor;\n        expect(copy).to.equal(obj);\n    });\n});\n\ndescribe('merge()', () => {\n\n    it('deep copies source items', () => {\n\n        const target = {\n            b: 3,\n            d: []\n        };\n\n        const source = {\n            c: {\n                d: 1\n            },\n            d: [{ e: 1 }]\n        };\n\n        Hoek.merge(target, source);\n        expect(target.c).to.not.shallow.equal(source.c);\n        expect(target.c).to.equal(source.c);\n        expect(target.d).to.not.shallow.equal(source.d);\n        expect(target.d[0]).to.not.shallow.equal(source.d[0]);\n        expect(target.d).to.equal(source.d);\n    });\n\n    it('merges array over an object', () => {\n\n        const a = {\n            x: ['n', 'm']\n        };\n\n        const b = {\n            x: {\n                n: '1',\n                m: '2'\n            }\n        };\n\n        Hoek.merge(b, a);\n        expect(a.x[0]).to.equal('n');\n        expect(a.x.n).to.not.exist();\n    });\n\n    it('merges object over an array', () => {\n\n        const a = {\n            x: ['n', 'm']\n        };\n\n        const b = {\n            x: {\n                n: '1',\n                m: '2'\n            }\n        };\n\n        Hoek.merge(a, b);\n        expect(a.x.n).to.equal('1');\n        expect(a.x[0]).to.not.exist();\n    });\n\n    it('does not throw if source is null', () => {\n\n        const a = {};\n        const b = null;\n        let c = null;\n\n        expect(() => {\n\n            c = Hoek.merge(a, b);\n        }).to.not.throw();\n\n        expect(c).to.equal(a);\n    });\n\n    it('does not throw if source is undefined', () => {\n\n        const a = {};\n        const b = undefined;\n        let c = null;\n\n        expect(() => {\n\n            c = Hoek.merge(a, b);\n        }).to.not.throw();\n\n        expect(c).to.equal(a);\n    });\n\n    it('throws if source is not an object', () => {\n\n        expect(() => {\n\n            const a = {};\n            const b = 0;\n\n            Hoek.merge(a, b);\n        }).to.throw('Invalid source value: must be null, undefined, or an object');\n    });\n\n    it('throws if target is not an object', () => {\n\n        expect(() => {\n\n            const a = 0;\n            const b = {};\n\n            Hoek.merge(a, b);\n        }).to.throw('Invalid target value: must be an object');\n    });\n\n    it('throws if target is not an array and source is', () => {\n\n        expect(() => {\n\n            const a = {};\n            const b = [1, 2];\n\n            Hoek.merge(a, b);\n        }).to.throw('Cannot merge array onto an object');\n    });\n\n    it('returns the same object when merging arrays', () => {\n\n        const a = [];\n        const b = [1, 2];\n\n        expect(Hoek.merge(a, b)).to.equal(a);\n    });\n\n    it('combines an empty object with a non-empty object', () => {\n\n        const a = {};\n        const b = nestedObj;\n\n        const c = Hoek.merge(a, b);\n        expect(a).to.equal(b);\n        expect(c).to.equal(b);\n    });\n\n    it('overrides values in target', () => {\n\n        const a = { x: 1, y: 2, z: 3, v: 5, t: 'test', m: 'abc' };\n        const b = { x: null, z: 4, v: 0, t: { u: 6 }, m: '123' };\n\n        const c = Hoek.merge(a, b);\n        expect(c.x).to.equal(null);\n        expect(c.y).to.equal(2);\n        expect(c.z).to.equal(4);\n        expect(c.v).to.equal(0);\n        expect(c.m).to.equal('123');\n        expect(c.t).to.equal({ u: 6 });\n    });\n\n    it('overrides values in target (flip)', () => {\n\n        const a = { x: 1, y: 2, z: 3, v: 5, t: 'test', m: 'abc' };\n        const b = { x: null, z: 4, v: 0, t: { u: 6 }, m: '123' };\n\n        const d = Hoek.merge(b, a);\n        expect(d.x).to.equal(1);\n        expect(d.y).to.equal(2);\n        expect(d.z).to.equal(3);\n        expect(d.v).to.equal(5);\n        expect(d.m).to.equal('abc');\n        expect(d.t).to.equal('test');\n    });\n\n    it('retains Date properties', () => {\n\n        const a = { x: new Date(1378776452757) };\n\n        const b = Hoek.merge({}, a);\n        expect(a.x.getTime()).to.equal(b.x.getTime());\n    });\n\n    it('retains Date properties when merging keys', () => {\n\n        const a = { x: new Date(1378776452757) };\n\n        const b = Hoek.merge({ x: {} }, a);\n        expect(a.x.getTime()).to.equal(b.x.getTime());\n    });\n\n    it('overrides Buffer', () => {\n\n        const a = { x: Buffer.from('abc') };\n\n        Hoek.merge({ x: {} }, a);\n        expect(a.x.toString()).to.equal('abc');\n    });\n\n    it('skips __proto__', () => {\n\n        const a = '{ \"ok\": \"value\", \"__proto__\": { \"test\": \"value\" } }';\n\n        const b = Hoek.merge({}, JSON.parse(a));\n        expect(b).to.equal({ ok: 'value' });\n        expect(b.test).to.equal(undefined);\n    });\n});\n\ndescribe('applyToDefaults()', () => {\n\n    const defaults = {\n        a: 1,\n        b: 2,\n        c: {\n            d: 3,\n            e: [5, 6]\n        },\n        f: 6,\n        g: 'test'\n    };\n\n    it('throws when target is null', () => {\n\n        expect(() => {\n\n            Hoek.applyToDefaults(null, {});\n        }).to.throw('Invalid defaults value: must be an object');\n    });\n\n    it('returns null if options is false', () => {\n\n        const result = Hoek.applyToDefaults(defaults, false);\n        expect(result).to.equal(null);\n    });\n\n    it('returns null if options is null', () => {\n\n        const result = Hoek.applyToDefaults(defaults, null);\n        expect(result).to.equal(null);\n    });\n\n    it('returns null if options is undefined', () => {\n\n        const result = Hoek.applyToDefaults(defaults, undefined);\n        expect(result).to.equal(null);\n    });\n\n    it('returns a copy of defaults if options is true', () => {\n\n        const result = Hoek.applyToDefaults(defaults, true);\n        expect(result).to.equal(defaults);\n    });\n\n    it('applies object to defaults', () => {\n\n        const obj = {\n            a: null,\n            c: {\n                e: [4]\n            },\n            f: 0,\n            g: {\n                h: 5\n            }\n        };\n\n        const result = Hoek.applyToDefaults(defaults, obj);\n        expect(result.c.e).to.equal([4]);\n        expect(result.a).to.equal(1);\n        expect(result.b).to.equal(2);\n        expect(result.f).to.equal(0);\n        expect(result.g).to.equal({ h: 5 });\n    });\n\n    it('applies object to defaults with null', () => {\n\n        const obj = {\n            a: null,\n            c: {\n                e: [4]\n            },\n            f: 0,\n            g: {\n                h: 5\n            }\n        };\n\n        const result = Hoek.applyToDefaults(defaults, obj, true);\n        expect(result.c.e).to.equal([4]);\n        expect(result.a).to.equal(null);\n        expect(result.b).to.equal(2);\n        expect(result.f).to.equal(0);\n        expect(result.g).to.equal({ h: 5 });\n    });\n});\n\ndescribe('cloneWithShallow()', () => {\n\n    it('deep clones except for listed keys', () => {\n\n        const source = {\n            a: {\n                b: 5\n            },\n            c: {\n                d: 6\n            }\n        };\n\n        const copy = Hoek.cloneWithShallow(source, ['c']);\n        expect(copy).to.equal(source);\n        expect(copy).to.not.shallow.equal(source);\n        expect(copy.a).to.not.shallow.equal(source.a);\n        expect(copy.b).to.equal(source.b);\n    });\n\n    it('returns immutable value', () => {\n\n        expect(Hoek.cloneWithShallow(5)).to.equal(5);\n    });\n\n    it('returns null value', () => {\n\n        expect(Hoek.cloneWithShallow(null)).to.equal(null);\n    });\n\n    it('returns undefined value', () => {\n\n        expect(Hoek.cloneWithShallow(undefined)).to.equal(undefined);\n    });\n\n    it('deep clones except for listed keys (including missing keys)', () => {\n\n        const source = {\n            a: {\n                b: 5\n            },\n            c: {\n                d: 6\n            }\n        };\n\n        const copy = Hoek.cloneWithShallow(source, ['c', 'v']);\n        expect(copy).to.equal(source);\n        expect(copy).to.not.shallow.equal(source);\n        expect(copy.a).to.not.shallow.equal(source.a);\n        expect(copy.b).to.equal(source.b);\n    });\n});\n\ndescribe('applyToDefaultsWithShallow()', () => {\n\n    it('shallow copies the listed keys from options without merging', () => {\n\n        const defaults = {\n            a: {\n                b: 5,\n                e: 3\n            },\n            c: {\n                d: 7,\n                g: 1\n            }\n        };\n\n        const options = {\n            a: {\n                b: 4\n            },\n            c: {\n                d: 6,\n                f: 7\n            }\n        };\n\n        const merged = Hoek.applyToDefaultsWithShallow(defaults, options, ['a']);\n        expect(merged).to.equal({ a: { b: 4 }, c: { d: 6, g: 1, f: 7 } });\n        expect(merged.a).to.equal(options.a);\n        expect(merged.a).to.not.equal(defaults.a);\n        expect(merged.c).to.not.equal(options.c);\n        expect(merged.c).to.not.equal(defaults.c);\n    });\n\n    it('shallow copies the nested keys (override)', () => {\n\n        const defaults = {\n            a: {\n                b: 5\n            },\n            c: {\n                d: 7,\n                g: 1\n            }\n        };\n\n        const options = {\n            a: {\n                b: 4\n            },\n            c: {\n                d: 6,\n                g: {\n                    h: 8\n                }\n            }\n        };\n\n        const merged = Hoek.applyToDefaultsWithShallow(defaults, options, ['c.g']);\n        expect(merged).to.equal({ a: { b: 4 }, c: { d: 6, g: { h: 8 } } });\n        expect(merged.c.g).to.equal(options.c.g);\n    });\n\n    it('shallow copies the nested keys (missing)', () => {\n\n        const defaults = {\n            a: {\n                b: 5\n            }\n        };\n\n        const options = {\n            a: {\n                b: 4\n            },\n            c: {\n                g: {\n                    h: 8\n                }\n            }\n        };\n\n        const merged = Hoek.applyToDefaultsWithShallow(defaults, options, ['c.g']);\n        expect(merged).to.equal({ a: { b: 4 }, c: { g: { h: 8 } } });\n        expect(merged.c.g).to.equal(options.c.g);\n    });\n\n    it('shallow copies the nested keys (override)', () => {\n\n        const defaults = {\n            a: {\n                b: 5\n            },\n            c: {\n                g: {\n                    d: 7\n                }\n            }\n        };\n\n        const options = {\n            a: {\n                b: 4\n            },\n            c: {\n                g: {\n                    h: 8\n                }\n            }\n        };\n\n        const merged = Hoek.applyToDefaultsWithShallow(defaults, options, ['c.g']);\n        expect(merged).to.equal({ a: { b: 4 }, c: { g: { h: 8 } } });\n        expect(merged.c.g).to.equal(options.c.g);\n    });\n\n    it('shallow copies the nested keys (deeper)', () => {\n\n        const defaults = {\n            a: {\n                b: 5\n            }\n        };\n\n        const options = {\n            a: {\n                b: 4\n            },\n            c: {\n                g: {\n                    r: {\n                        h: 8\n                    }\n                }\n            }\n        };\n\n        const merged = Hoek.applyToDefaultsWithShallow(defaults, options, ['c.g.r']);\n        expect(merged).to.equal({ a: { b: 4 }, c: { g: { r: { h: 8 } } } });\n        expect(merged.c.g.r).to.equal(options.c.g.r);\n    });\n\n    it('shallow copies the nested keys (not present)', () => {\n\n        const defaults = {\n            a: {\n                b: 5\n            }\n        };\n\n        const options = {\n            a: {\n                b: 4\n            },\n            c: {\n                g: {\n                    r: {\n                        h: 8\n                    }\n                }\n            }\n        };\n\n        const merged = Hoek.applyToDefaultsWithShallow(defaults, options, ['x.y']);\n        expect(merged).to.equal({ a: { b: 4 }, c: { g: { r: { h: 8 } } } });\n    });\n\n    it('shallow copies the listed keys in the defaults', () => {\n\n        const defaults = {\n            a: {\n                b: 1\n            }\n        };\n\n        const merged = Hoek.applyToDefaultsWithShallow(defaults, {}, ['a']);\n        expect(merged.a).to.equal(defaults.a);\n    });\n\n    it('shallow copies the listed keys in the defaults (true)', () => {\n\n        const defaults = {\n            a: {\n                b: 1\n            }\n        };\n\n        const merged = Hoek.applyToDefaultsWithShallow(defaults, true, ['a']);\n        expect(merged.a).to.equal(defaults.a);\n    });\n\n    it('returns null on false', () => {\n\n        const defaults = {\n            a: {\n                b: 1\n            }\n        };\n\n        const merged = Hoek.applyToDefaultsWithShallow(defaults, false, ['a']);\n        expect(merged).to.equal(null);\n    });\n\n    it('throws on missing defaults', () => {\n\n        expect(() => {\n\n            Hoek.applyToDefaultsWithShallow(null, {}, ['a']);\n        }).to.throw('Invalid defaults value: must be an object');\n    });\n\n    it('throws on invalid defaults', () => {\n\n        expect(() => {\n\n            Hoek.applyToDefaultsWithShallow('abc', {}, ['a']);\n        }).to.throw('Invalid defaults value: must be an object');\n    });\n\n    it('throws on invalid options', () => {\n\n        expect(() => {\n\n            Hoek.applyToDefaultsWithShallow({}, 'abc', ['a']);\n        }).to.throw('Invalid options value: must be true, falsy or an object');\n    });\n\n    it('throws on missing keys', () => {\n\n        expect(() => {\n\n            Hoek.applyToDefaultsWithShallow({}, true);\n        }).to.throw('Invalid keys');\n    });\n\n    it('throws on invalid keys', () => {\n\n        expect(() => {\n\n            Hoek.applyToDefaultsWithShallow({}, true, 'a');\n        }).to.throw('Invalid keys');\n    });\n});\n\ndescribe('deepEqual()', () => {\n\n    it('compares simple values', () => {\n\n        expect(Hoek.deepEqual('x', 'x')).to.be.true();\n        expect(Hoek.deepEqual('x', 'y')).to.be.false();\n        expect(Hoek.deepEqual('x1', 'x')).to.be.false();\n        expect(Hoek.deepEqual(-0, +0)).to.be.false();\n        expect(Hoek.deepEqual(-0, -0)).to.be.true();\n        expect(Hoek.deepEqual(+0, +0)).to.be.true();\n        expect(Hoek.deepEqual(+0, -0)).to.be.false();\n        expect(Hoek.deepEqual(1, 1)).to.be.true();\n        expect(Hoek.deepEqual(0, 0)).to.be.true();\n        expect(Hoek.deepEqual(-1, 1)).to.be.false();\n        expect(Hoek.deepEqual(NaN, 0)).to.be.false();\n        expect(Hoek.deepEqual(NaN, NaN)).to.be.true();\n    });\n\n    it('compares different types', () => {\n\n        expect(Hoek.deepEqual([], 5)).to.be.false();\n        expect(Hoek.deepEqual(5, [])).to.be.false();\n        expect(Hoek.deepEqual({}, null)).to.be.false();\n        expect(Hoek.deepEqual(null, {})).to.be.false();\n        expect(Hoek.deepEqual('abc', {})).to.be.false();\n        expect(Hoek.deepEqual({}, 'abc')).to.be.false();\n    });\n\n    it('compares empty structures', () => {\n\n        expect(Hoek.deepEqual([], [])).to.be.true();\n        expect(Hoek.deepEqual({}, {})).to.be.true();\n        expect(Hoek.deepEqual([], {})).to.be.false();\n    });\n\n    it('compares empty arguments object', () => {\n\n        const compare = function () {\n\n            expect(Hoek.deepEqual([], arguments)).to.be.false();\n        };\n\n        compare();\n    });\n\n    it('compares empty arguments objects', () => {\n\n        const compare = function () {\n\n            const arg1 = arguments;\n\n            const inner = function () {\n\n                expect(Hoek.deepEqual(arg1, arguments)).to.be.true(); // callee is not supported in strict mode, was previously false becuse callee was different\n            };\n\n            inner();\n        };\n\n        compare();\n    });\n\n    it('compares dates', () => {\n\n        expect(Hoek.deepEqual(new Date(2015, 1, 1), new Date(2015, 1, 1))).to.be.true();\n        expect(Hoek.deepEqual(new Date(100), new Date(101))).to.be.false();\n        expect(Hoek.deepEqual(new Date(), {})).to.be.false();\n    });\n\n    it('compares regular expressions', () => {\n\n        expect(Hoek.deepEqual(/\\s/, new RegExp('\\\\\\s'))).to.be.true();\n        expect(Hoek.deepEqual(/\\s/g, /\\s/g)).to.be.true();\n        expect(Hoek.deepEqual(/a/, {})).to.be.false();\n        expect(Hoek.deepEqual(/\\s/g, /\\s/i)).to.be.false();\n        expect(Hoek.deepEqual(/a/g, /b/g)).to.be.false();\n    });\n\n    it('compares arrays', () => {\n\n        expect(Hoek.deepEqual([[1]], [[1]])).to.be.true();\n        expect(Hoek.deepEqual([1, 2, 3], [1, 2, 3])).to.be.true();\n        expect(Hoek.deepEqual([1, 2, 3], [1, 3, 2])).to.be.false();\n        expect(Hoek.deepEqual([1, 2, 3], [1, 2])).to.be.false();\n        expect(Hoek.deepEqual([1], [1])).to.be.true();\n        const item1 = { key: 'value1' };\n        const item2 = { key: 'value2' };\n        expect(Hoek.deepEqual([item1, item1], [item1, item2])).to.be.false();\n    });\n\n    it('compares buffers', () => {\n\n        expect(Hoek.deepEqual(Buffer.from([1, 2, 3]), Buffer.from([1, 2, 3]))).to.be.true();\n        expect(Hoek.deepEqual(Buffer.from([1, 2, 3]), Buffer.from([1, 3, 2]))).to.be.false();\n        expect(Hoek.deepEqual(Buffer.from([1, 2, 3]), Buffer.from([1, 2]))).to.be.false();\n        expect(Hoek.deepEqual(Buffer.from([1, 2, 3]), {})).to.be.false();\n        expect(Hoek.deepEqual(Buffer.from([1, 2, 3]), [1, 2, 3])).to.be.false();\n    });\n\n    it('compares objects', () => {\n\n        expect(Hoek.deepEqual({ a: 1, b: 2, c: 3 }, { a: 1, b: 2, c: 3 })).to.be.true();\n        expect(Hoek.deepEqual({ foo: 'bar' }, { foo: 'baz' })).to.be.false();\n        expect(Hoek.deepEqual({ foo: { bar: 'foo' } }, { foo: { bar: 'baz' } })).to.be.false();\n    });\n\n    it('handles circular dependency', () => {\n\n        const a = {};\n        a.x = a;\n\n        const b = Hoek.clone(a);\n        expect(Hoek.deepEqual(a, b)).to.be.true();\n    });\n\n    it('compares an object with property getter without executing it', () => {\n\n        const obj = {};\n        const value = 1;\n        let execCount = 0;\n\n        Object.defineProperty(obj, 'test', {\n            enumerable: true,\n            configurable: true,\n            get: function () {\n\n                ++execCount;\n                return value;\n            }\n        });\n\n        const copy = Hoek.clone(obj);\n        expect(Hoek.deepEqual(obj, copy)).to.be.true();\n        expect(execCount).to.equal(0);\n        expect(copy.test).to.equal(1);\n        expect(execCount).to.equal(1);\n    });\n\n    it('compares objects with property getters', () => {\n\n        const obj = {};\n        Object.defineProperty(obj, 'test', {\n            enumerable: true,\n            configurable: true,\n            get: function () {\n\n                return 1;\n            }\n        });\n\n        const ref = {};\n        Object.defineProperty(ref, 'test', {\n            enumerable: true,\n            configurable: true,\n            get: function () {\n\n                return 2;\n            }\n        });\n\n        expect(Hoek.deepEqual(obj, ref)).to.be.false();\n    });\n\n    it('compares object prototypes', () => {\n\n        const Obj = function () {\n\n            this.a = 5;\n        };\n\n        Obj.prototype.b = function () {\n\n            return this.a;\n        };\n\n        const Ref = function () {\n\n            this.a = 5;\n        };\n\n        Ref.prototype.b = function () {\n\n            return this.a;\n        };\n\n        expect(Hoek.deepEqual(new Obj(), new Ref())).to.be.false();\n        expect(Hoek.deepEqual(new Obj(), new Obj())).to.be.true();\n        expect(Hoek.deepEqual(new Ref(), new Ref())).to.be.true();\n    });\n\n    it('compares plain objects', () => {\n\n        const a = Object.create(null);\n        const b = Object.create(null);\n\n        a.b = 'c';\n        b.b = 'c';\n\n        expect(Hoek.deepEqual(a, b)).to.be.true();\n        expect(Hoek.deepEqual(a, { b: 'c' })).to.be.false();\n    });\n\n    it('compares an object with an empty object', () => {\n\n        const a = { a: 1, b: 2 };\n\n        expect(Hoek.deepEqual({}, a)).to.be.false();\n        expect(Hoek.deepEqual(a, {})).to.be.false();\n    });\n\n    it('compares an object ignoring the prototype', () => {\n\n        const a = Object.create(null);\n        const b = {};\n\n        expect(Hoek.deepEqual(a, b, { prototype: false })).to.be.true();\n    });\n\n    it('compares an object ignoring the prototype recursively', () => {\n\n        const a = [Object.create(null)];\n        const b = [{}];\n\n        expect(Hoek.deepEqual(a, b, { prototype: false })).to.be.true();\n    });\n});\n\ndescribe('unique()', () => {\n\n    const deprecatedUnique = function (array, key) { // previous method of unique from hapi 3.0.4\n\n        const index = {};\n        const result = [];\n\n        for (let i = 0; i < array.length; ++i) {\n            const id = (key ? array[i][key] : array[i]);\n            if (index[id] !== true) {\n\n                result.push(array[i]);\n                index[id] = true;\n            }\n        }\n\n        return result;\n    };\n\n    it('ensures uniqueness within array of objects based on subkey', () => {\n\n        expect(Hoek.unique(internals.unique.objectsByKey.dups, 'x')).to.equal(internals.unique.objectsByKey.result);\n        expect(deprecatedUnique(internals.unique.objectsByKey.dups, 'x')).to.equal(internals.unique.objectsByKey.result);\n\n    });\n\n    it('removes duplicated integers without key', () => {\n\n        expect(Hoek.unique(internals.unique.integers.dups)).to.equal(internals.unique.integers.result);\n        expect(deprecatedUnique(internals.unique.integers.dups)).to.equal(internals.unique.integers.result);\n    });\n\n    it('removes duplicated strings without key', () => {\n\n        expect(Hoek.unique(internals.unique.strings.dups)).to.equal(internals.unique.strings.result);\n        expect(deprecatedUnique(internals.unique.strings.dups)).to.equal(internals.unique.strings.result);\n    });\n\n    it('removes duplicated objects without key', () => { // this was not supported in earlier versions\n\n        expect(Hoek.unique(internals.unique.objects.dups)).to.equal(internals.unique.objects.result);\n        expect(deprecatedUnique(internals.unique.objects.dups)).to.not.equal(internals.unique.objects.result);\n    });\n});\n\ndescribe('mapToObject()', () => {\n\n    it('returns null on null array', () => {\n\n        const a = Hoek.mapToObject(null);\n        expect(a).to.equal(null);\n    });\n\n    it('converts basic array to existential object', () => {\n\n        const keys = [1, 2, 3, 4];\n        const a = Hoek.mapToObject(keys);\n        expect(Object.keys(a)).to.equal(['1', '2', '3', '4']);\n    });\n\n    it('converts array of objects to existential object', () => {\n\n        const keys = [{ x: 1 }, { x: 2 }, { x: 3 }, { y: 4 }];\n        const subkey = 'x';\n        const a = Hoek.mapToObject(keys, subkey);\n        expect(a).to.equal({ 1: true, 2: true, 3: true });\n    });\n});\n\ndescribe('intersect()', () => {\n\n    it('returns the common objects of two arrays', () => {\n\n        const array1 = [1, 2, 3, 4, 4, 5, 5];\n        const array2 = [5, 4, 5, 6, 7];\n        const common = Hoek.intersect(array1, array2);\n        expect(common.length).to.equal(2);\n    });\n\n    it('returns just the first common object of two arrays', () => {\n\n        const array1 = [1, 2, 3, 4, 4, 5, 5];\n        const array2 = [5, 4, 5, 6, 7];\n        const common = Hoek.intersect(array1, array2, true);\n        expect(common).to.equal(5);\n    });\n\n    it('returns null when no common and returning just the first common object of two arrays', () => {\n\n        const array1 = [1, 2, 3, 4, 4, 5, 5];\n        const array2 = [6, 7];\n        const common = Hoek.intersect(array1, array2, true);\n        expect(common).to.equal(null);\n    });\n\n    it('returns an empty array if either input is null', () => {\n\n        expect(Hoek.intersect([1], null).length).to.equal(0);\n        expect(Hoek.intersect(null, [1]).length).to.equal(0);\n    });\n\n    it('returns the common objects of object and array', () => {\n\n        const array1 = [1, 2, 3, 4, 4, 5, 5];\n        const array2 = [5, 4, 5, 6, 7];\n        const common = Hoek.intersect(Hoek.mapToObject(array1), array2);\n        expect(common.length).to.equal(2);\n    });\n});\n\ndescribe('contain()', () => {\n\n    it('tests strings', () => {\n\n        expect(Hoek.contain('abc', 'ab')).to.be.true();\n        expect(Hoek.contain('abc', 'abc', { only: true })).to.be.true();\n        expect(Hoek.contain('aaa', 'a', { only: true })).to.be.true();\n        expect(Hoek.contain('abc', 'b', { once: true })).to.be.true();\n        expect(Hoek.contain('abc', ['a', 'c'])).to.be.true();\n        expect(Hoek.contain('abc', ['a', 'd'], { part: true })).to.be.true();\n\n        expect(Hoek.contain('abc', 'ac')).to.be.false();\n        expect(Hoek.contain('abcd', 'abc', { only: true })).to.be.false();\n        expect(Hoek.contain('aab', 'a', { only: true })).to.be.false();\n        expect(Hoek.contain('abb', 'b', { once: true })).to.be.false();\n        expect(Hoek.contain('abc', ['a', 'd'])).to.be.false();\n        expect(Hoek.contain('abc', ['ab', 'bc'])).to.be.false();                      // Overlapping values not supported\n    });\n\n    it('tests arrays', () => {\n\n        expect(Hoek.contain([1, 2, 3], 1)).to.be.true();\n        expect(Hoek.contain([{ a: 1 }], { a: 1 }, { deep: true })).to.be.true();\n        expect(Hoek.contain([1, 2, 3], [1, 2])).to.be.true();\n        expect(Hoek.contain([{ a: 1 }], [{ a: 1 }], { deep: true })).to.be.true();\n        expect(Hoek.contain([1, 1, 2], [1, 2], { only: true })).to.be.true();\n        expect(Hoek.contain([1, 2], [1, 2], { once: true })).to.be.true();\n        expect(Hoek.contain([1, 2, 3], [1, 4], { part: true })).to.be.true();\n        expect(Hoek.contain([[1], [2]], [[1]], { deep: true })).to.be.true();\n\n        expect(Hoek.contain([1, 2, 3], 4)).to.be.false();\n        expect(Hoek.contain([{ a: 1 }], { a: 2 }, { deep: true })).to.be.false();\n        expect(Hoek.contain([{ a: 1 }], { a: 1 })).to.be.false();\n        expect(Hoek.contain([1, 2, 3], [4, 5])).to.be.false();\n        expect(Hoek.contain([[3], [2]], [[1]])).to.be.false();\n        expect(Hoek.contain([[1], [2]], [[1]])).to.be.false();\n        expect(Hoek.contain([{ a: 1 }], [{ a: 2 }], { deep: true })).to.be.false();\n        expect(Hoek.contain([1, 3, 2], [1, 2], { only: true })).to.be.false();\n        expect(Hoek.contain([1, 2, 2], [1, 2], { once: true })).to.be.false();\n        expect(Hoek.contain([0, 2, 3], [1, 4], { part: true })).to.be.false();\n    });\n\n    it('tests objects', () => {\n\n        expect(Hoek.contain({ a: 1, b: 2, c: 3 }, 'a')).to.be.true();\n        expect(Hoek.contain({ a: 1, b: 2, c: 3 }, ['a', 'c'])).to.be.true();\n        expect(Hoek.contain({ a: 1, b: 2, c: 3 }, ['a', 'b', 'c'], { only: true })).to.be.true();\n        expect(Hoek.contain({ a: 1, b: 2, c: 3 }, { a: 1 })).to.be.true();\n        expect(Hoek.contain({ a: 1, b: 2, c: 3 }, { a: 1, c: 3 })).to.be.true();\n        expect(Hoek.contain({ a: 1, b: 2, c: 3 }, { a: 1, d: 4 }, { part: true })).to.be.true();\n        expect(Hoek.contain({ a: 1, b: 2, c: 3 }, { a: 1, b: 2, c: 3 }, { only: true })).to.be.true();\n        expect(Hoek.contain({ a: [1], b: [2], c: [3] }, { a: [1], c: [3] }, { deep: true })).to.be.true();\n        expect(Hoek.contain({ a: [{ b: 1 }, { c: 2 }, { d: 3, e: 4 }] }, { a: [{ b: 1 }, { d: 3 }] }, { deep: true })).to.be.true();\n        expect(Hoek.contain({ a: [{ b: 1 }, { c: 2 }, { d: 3, e: 4 }] }, { a: [{ b: 1 }, { d: 3 }] }, { deep: true, part: true })).to.be.true();\n        expect(Hoek.contain({ a: [{ b: 1 }, { c: 2 }, { d: 3, e: 4 }] }, { a: [{ b: 1 }, { d: 3 }] }, { deep: true, part: false })).to.be.false();\n        expect(Hoek.contain({ a: [{ b: 1 }, { c: 2 }, { d: 3, e: 4 }] }, { a: [{ b: 1 }, { d: 3 }] }, { deep: true, only: true })).to.be.false();\n        expect(Hoek.contain({ a: [{ b: 1 }, { c: 2 }, { d: 3, e: 4 }] }, { a: [{ b: 1 }, { d: 3 }] }, { deep: true, only: false })).to.be.true();\n\n        expect(Hoek.contain({ a: 1, b: 2, c: 3 }, 'd')).to.be.false();\n        expect(Hoek.contain({ a: 1, b: 2, c: 3 }, ['a', 'd'])).to.be.false();\n        expect(Hoek.contain({ a: 1, b: 2, c: 3, d: 4 }, ['a', 'b', 'c'], { only: true })).to.be.false();\n        expect(Hoek.contain({ a: 1, b: 2, c: 3 }, { a: 2 })).to.be.false();\n        expect(Hoek.contain({ a: 1, b: 2, c: 3 }, { a: 2, b: 2 }, { part: true })).to.be.false();             // part does not ignore bad value\n        expect(Hoek.contain({ a: 1, b: 2, c: 3 }, { a: 1, d: 3 })).to.be.false();\n        expect(Hoek.contain({ a: 1, b: 2, c: 3 }, { a: 1, d: 4 })).to.be.false();\n        expect(Hoek.contain({ a: 1, b: 2, c: 3 }, { a: 1, b: 2 }, { only: true })).to.be.false();\n        expect(Hoek.contain({ a: [1], b: [2], c: [3] }, { a: [1], c: [3] })).to.be.false();\n        expect(Hoek.contain({ a: { b: { c: 1, d: 2 } } }, { a: { b: { c: 1 } } })).to.be.false();\n        expect(Hoek.contain({ a: { b: { c: 1, d: 2 } } }, { a: { b: { c: 1 } } }, { deep: true })).to.be.true();\n        expect(Hoek.contain({ a: { b: { c: 1, d: 2 } } }, { a: { b: { c: 1 } } }, { deep: true, only: true })).to.be.false();\n        expect(Hoek.contain({ a: { b: { c: 1, d: 2 } } }, { a: { b: { c: 1 } } }, { deep: true, only: false })).to.be.true();\n        expect(Hoek.contain({ a: { b: { c: 1, d: 2 } } }, { a: { b: { c: 1 } } }, { deep: true, part: true })).to.be.true();\n        expect(Hoek.contain({ a: { b: { c: 1, d: 2 } } }, { a: { b: { c: 1 } } }, { deep: true, part: false })).to.be.false();\n\n        // Getter check\n        {\n            const Foo = function (bar) {\n\n                this.bar = bar;\n            };\n\n            Object.defineProperty(Foo.prototype, 'baz', {\n                enumerable: true,\n                get: function () {\n\n                    return this.bar;\n                }\n            });\n\n            expect(Hoek.contain({ a: new Foo('b') }, { a: new Foo('b') }, { deep: true })).to.be.true();\n            expect(Hoek.contain({ a: new Foo('b') }, { a: new Foo('b') }, { deep: true, part: true })).to.be.true();\n            expect(Hoek.contain({ a: new Foo('b') }, { a: { baz: 'b' } }, { deep: true })).to.be.true();\n            expect(Hoek.contain({ a: new Foo('b') }, { a: { baz: 'b' } }, { deep: true, only: true })).to.be.false();\n            expect(Hoek.contain({ a: new Foo('b') }, { a: { baz: 'b' } }, { deep: true, part: false })).to.be.false();\n            expect(Hoek.contain({ a: new Foo('b') }, { a: { baz: 'b' } }, { deep: true, part: true })).to.be.true();\n            expect(Hoek.contain({ a: new Foo('b') }, { a: new Foo('b') }, { deep: true })).to.be.true();\n        }\n\n        // Properties on prototype not visible\n        {\n            const Foo = function () {\n\n                this.a = 1;\n            };\n\n            Object.defineProperty(Foo.prototype, 'b', {\n                enumerable: true,\n                value: 2\n            });\n\n            const Bar = function () {\n\n                Foo.call(this);\n                this.c = 3;\n            };\n\n            Util.inherits(Bar, Foo);\n\n            expect((new Bar()).a).to.equal(1);\n            expect((new Bar()).b).to.equal(2);\n            expect((new Bar()).c).to.equal(3);\n            expect(Hoek.contain(new Bar(), { 'a': 1, 'c': 3 }, { only: true })).to.be.true();\n            expect(Hoek.contain(new Bar(), 'b')).to.be.false();\n        }\n\n        // Non-Enumerable properties\n        {\n            const foo = { a: 1, b: 2 };\n\n            Object.defineProperty(foo, 'c', {\n                enumerable: false,\n                value: 3\n            });\n\n            expect(Hoek.contain(foo, 'c')).to.be.true();\n            expect(Hoek.contain(foo, { 'c': 3 })).to.be.true();\n            expect(Hoek.contain(foo, { 'a': 1, 'b': 2, 'c': 3 }, { only: true })).to.be.true();\n        }\n    });\n});\n\ndescribe('flatten()', () => {\n\n    it('returns a flat array', () => {\n\n        const result = Hoek.flatten([1, 2, [3, 4, [5, 6], [7], 8], [9], [10, [11, 12]], 13]);\n        expect(result.length).to.equal(13);\n        expect(result).to.equal([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]);\n    });\n});\n\ndescribe('reach()', () => {\n\n    const obj = {\n        a: {\n            b: {\n                c: {\n                    d: 1,\n                    e: 2\n                },\n                f: 'hello'\n            },\n            g: {\n                h: 3\n            }\n        },\n        i: function () { },\n        j: null,\n        k: [4, 8, 9, 1]\n    };\n\n    obj.i.x = 5;\n\n    it('returns object itself', () => {\n\n        expect(Hoek.reach(obj, null)).to.equal(obj);\n        expect(Hoek.reach(obj, false)).to.equal(obj);\n        expect(Hoek.reach(obj)).to.equal(obj);\n    });\n\n    it('returns first value of array', () => {\n\n        expect(Hoek.reach(obj, 'k.0')).to.equal(4);\n    });\n\n    it('returns last value of array using negative index', () => {\n\n        expect(Hoek.reach(obj, 'k.-2')).to.equal(9);\n    });\n\n    it('returns a valid member', () => {\n\n        expect(Hoek.reach(obj, 'a.b.c.d')).to.equal(1);\n    });\n\n    it('returns a valid member with separator override', () => {\n\n        expect(Hoek.reach(obj, 'a/b/c/d', '/')).to.equal(1);\n    });\n\n    it('returns undefined on null object', () => {\n\n        expect(Hoek.reach(null, 'a.b.c.d')).to.equal(undefined);\n    });\n\n    it('returns undefined on missing object member', () => {\n\n        expect(Hoek.reach(obj, 'a.b.c.d.x')).to.equal(undefined);\n    });\n\n    it('returns undefined on missing function member', () => {\n\n        expect(Hoek.reach(obj, 'i.y', { functions: true })).to.equal(undefined);\n    });\n\n    it('throws on missing member in strict mode', () => {\n\n        expect(() => {\n\n            Hoek.reach(obj, 'a.b.c.o.x', { strict: true });\n        }).to.throw('Missing segment o in reach path  a.b.c.o.x');\n\n    });\n\n    it('returns undefined on invalid member', () => {\n\n        expect(Hoek.reach(obj, 'a.b.c.d-.x')).to.equal(undefined);\n    });\n\n    it('returns function member', () => {\n\n        expect(typeof Hoek.reach(obj, 'i')).to.equal('function');\n    });\n\n    it('returns function property', () => {\n\n        expect(Hoek.reach(obj, 'i.x')).to.equal(5);\n    });\n\n    it('returns null', () => {\n\n        expect(Hoek.reach(obj, 'j')).to.equal(null);\n    });\n\n    it('throws on function property when functions not allowed', () => {\n\n        expect(() => {\n\n            Hoek.reach(obj, 'i.x', { functions: false });\n        }).to.throw('Invalid segment x in reach path  i.x');\n    });\n\n    it('will return a default value if property is not found', () => {\n\n        expect(Hoek.reach(obj, 'a.b.q', { default: 'defaultValue' })).to.equal('defaultValue');\n    });\n\n    it('will return a default value if path is not found', () => {\n\n        expect(Hoek.reach(obj, 'q', { default: 'defaultValue' })).to.equal('defaultValue');\n    });\n\n    it('allows a falsey value to be used as the default value', () => {\n\n        expect(Hoek.reach(obj, 'q', { default: '' })).to.equal('');\n    });\n});\n\ndescribe('reachTemplate()', () => {\n\n    it('applies object to template', () => {\n\n        const obj = {\n            a: {\n                b: {\n                    c: {\n                        d: 1\n                    }\n                }\n            },\n            j: null,\n            k: [4, 8, 9, 1]\n        };\n\n        const template = '{k.0}:{k.-2}:{a.b.c.d}:{x.y}:{j}';\n\n        expect(Hoek.reachTemplate(obj, template)).to.equal('4:9:1::');\n    });\n\n    it('applies object to template (options)', () => {\n\n        const obj = {\n            a: {\n                b: {\n                    c: {\n                        d: 1\n                    }\n                }\n            },\n            j: null,\n            k: [4, 8, 9, 1]\n        };\n\n        const template = '{k/0}:{k/-2}:{a/b/c/d}:{x/y}:{j}';\n\n        expect(Hoek.reachTemplate(obj, template, '/')).to.equal('4:9:1::');\n    });\n});\n\ndescribe('callStack()', () => {\n\n    it('returns the full call stack', () => {\n\n        const stack = Hoek.callStack();\n        expect(stack[0][0]).to.contain('index.js');\n    });\n});\n\ndescribe('displayStack ()', () => {\n\n    it('returns the full call stack for display', () => {\n\n        const stack = Hoek.displayStack();\n        expect(stack[0]).to.contain(Path.normalize('/test/index.js') + ':');\n    });\n\n    it('includes constructor functions correctly', () => {\n\n        return new Promise((resolve) => {\n\n            const Something = function (next) {\n\n                next();\n            };\n\n            new Something(() => {\n\n                const stack = Hoek.displayStack();\n                expect(stack[1]).to.contain('new Something');\n                resolve();\n            });\n        });\n    });\n});\n\ndescribe('abort()', () => {\n\n    it('exits process when not in test mode', async () => {\n\n        const env = process.env.NODE_ENV;\n        const write = process.stdout.write;\n        const exit = process.exit;\n\n        process.env.NODE_ENV = 'nottatest';\n        process.stdout.write = function () { };\n\n        const abort = new Promise((resolve) => {\n\n            process.exit = function (state) {\n\n                process.exit = exit;\n                process.env.NODE_ENV = env;\n                process.stdout.write = write;\n\n                expect(state).to.equal(1);\n                resolve();\n            };\n        });\n\n        Hoek.abort('Boom');\n        await abort;\n    });\n\n    it('throws when not in test mode and abortThrow is true', () => {\n\n        const env = process.env.NODE_ENV;\n        process.env.NODE_ENV = 'nottatest';\n        Hoek.abortThrow = true;\n\n        expect(() => {\n\n            Hoek.abort('my error message');\n        }).to.throw('my error message');\n        Hoek.abortThrow = false;\n        process.env.NODE_ENV = env;\n    });\n\n    it('respects hideStack argument', () => {\n\n        const env = process.env.NODE_ENV;\n        const write = process.stdout.write;\n        const exit = process.exit;\n        let output = '';\n\n        process.exit = function () { };\n        process.env.NODE_ENV = '';\n        process.stdout.write = function (message) {\n\n            output = message;\n        };\n\n        Hoek.abort('my error message', true);\n\n        process.env.NODE_ENV = env;\n        process.stdout.write = write;\n        process.exit = exit;\n\n        expect(output).to.equal('ABORT: my error message\\n\\t\\n');\n    });\n\n    it('throws in test mode', () => {\n\n        const env = process.env.NODE_ENV;\n        process.env.NODE_ENV = 'test';\n\n        expect(() => {\n\n            Hoek.abort('my error message', true);\n        }).to.throw('my error message');\n\n        process.env.NODE_ENV = env;\n    });\n\n    it('throws in test mode with default message', () => {\n\n        const env = process.env.NODE_ENV;\n        process.env.NODE_ENV = 'test';\n\n        expect(() => {\n\n            Hoek.abort('', true);\n        }).to.throw('Unknown error');\n\n        process.env.NODE_ENV = env;\n    });\n\n    it('defaults to showing stack', () => {\n\n        const env = process.env.NODE_ENV;\n        const write = process.stdout.write;\n        const exit = process.exit;\n        let output = '';\n\n        process.exit = function () { };\n        process.env.NODE_ENV = '';\n        process.stdout.write = function (message) {\n\n            output = message;\n        };\n\n        Hoek.abort('my error message');\n\n        process.env.NODE_ENV = env;\n        process.stdout.write = write;\n        process.exit = exit;\n\n        expect(output).to.contain('index.js');\n    });\n});\n\ndescribe('assert()', () => {\n\n    it('throws an Error when using assert in a test', () => {\n\n        expect(() => {\n\n            Hoek.assert(false, 'my error message');\n        }).to.throw('my error message');\n    });\n\n    it('throws an Error when using assert in a test with no message', () => {\n\n        expect(() => {\n\n            Hoek.assert(false);\n        }).to.throw('Unknown error');\n    });\n\n    it('throws an Error when using assert in a test with multipart message', () => {\n\n        expect(() => {\n\n            Hoek.assert(false, 'This', 'is', 'my message');\n        }).to.throw('This is my message');\n    });\n\n    it('throws an Error when using assert in a test with multipart message (empty)', () => {\n\n        expect(() => {\n\n            Hoek.assert(false, 'This', 'is', '', 'my message');\n        }).to.throw('This is my message');\n    });\n\n    it('throws an Error when using assert in a test with object message', () => {\n\n        expect(() => {\n\n            Hoek.assert(false, 'This', 'is', { spinal: 'tap' });\n        }).to.throw('This is {\"spinal\":\"tap\"}');\n    });\n\n    it('throws an Error when using assert in a test with multipart string and error messages', () => {\n\n        expect(() => {\n\n            Hoek.assert(false, 'This', 'is', new Error('spinal'), new Error('tap'));\n        }).to.throw('This is spinal tap');\n    });\n\n    it('throws an Error when using assert in a test with error object message', () => {\n\n        expect(() => {\n\n            Hoek.assert(false, new Error('This is spinal tap'));\n        }).to.throw('This is spinal tap');\n    });\n\n    it('throws the same Error that is passed to it if there is only one error passed', () => {\n\n        const error = new Error('ruh roh');\n        const error2 = new Error('ruh roh');\n\n        const fn = function () {\n\n            Hoek.assert(false, error);\n        };\n\n        try {\n            fn();\n        }\n        catch (err) {\n            expect(err).to.equal(error);  // should be the same reference\n            expect(err).to.not.shallow.equal(error2); // error with the same message should not match\n        }\n    });\n});\n\ndescribe('Bench', () => {\n\n    it('returns time elapsed', async () => {\n\n        const timer = new Hoek.Bench();\n        await Hoek.wait(12);\n        expect(timer.elapsed()).to.be.above(9);\n    });\n});\n\ndescribe('escapeRegex()', () => {\n\n    it('escapes all special regular expression characters', () => {\n\n        const a = Hoek.escapeRegex('4^f$s.4*5+-_?%=#!:@|~\\\\/`\"(>)[<]d{}s,');\n        expect(a).to.equal('4\\\\^f\\\\$s\\\\.4\\\\*5\\\\+\\\\-_\\\\?%\\\\=#\\\\!\\\\:@\\\\|~\\\\\\\\\\\\/`\"\\\\(>\\\\)\\\\[<\\\\]d\\\\{\\\\}s\\\\,');\n    });\n});\n\ndescribe('Base64Url', () => {\n\n    const base64str = 'AAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIjJCUmJygpKissLS4vMDEyMzQ1Njc4OTo7PD0-P0BBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWltcXV5fYGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6e3x9fn-AgYKDhIWGh4iJiouMjY6PkJGSk5SVlpeYmZqbnJ2en6ChoqOkpaanqKmqq6ytrq-wsbKztLW2t7i5uru8vb6_wMHCw8TFxsfIycrLzM3Oz9DR0tPU1dbX2Nna29zd3t_g4eLj5OXm5-jp6uvs7e7v8PHy8_T19vf4-fr7_P3-_w';\n    const str = unescape('%00%01%02%03%04%05%06%07%08%09%0A%0B%0C%0D%0E%0F%10%11%12%13%14%15%16%17%18%19%1A%1B%1C%1D%1E%1F%20%21%22%23%24%25%26%27%28%29*+%2C-./0123456789%3A%3B%3C%3D%3E%3F@ABCDEFGHIJKLMNOPQRSTUVWXYZ%5B%5C%5D%5E_%60abcdefghijklmnopqrstuvwxyz%7B%7C%7D%7E%7F%80%81%82%83%84%85%86%87%88%89%8A%8B%8C%8D%8E%8F%90%91%92%93%94%95%96%97%98%99%9A%9B%9C%9D%9E%9F%A0%A1%A2%A3%A4%A5%A6%A7%A8%A9%AA%AB%AC%AD%AE%AF%B0%B1%B2%B3%B4%B5%B6%B7%B8%B9%BA%BB%BC%BD%BE%BF%C0%C1%C2%C3%C4%C5%C6%C7%C8%C9%CA%CB%CC%CD%CE%CF%D0%D1%D2%D3%D4%D5%D6%D7%D8%D9%DA%DB%DC%DD%DE%DF%E0%E1%E2%E3%E4%E5%E6%E7%E8%E9%EA%EB%EC%ED%EE%EF%F0%F1%F2%F3%F4%F5%F6%F7%F8%F9%FA%FB%FC%FD%FE%FF');\n\n    describe('base64urlEncode()', () => {\n\n        it('should assert function input is a string or buffer', () => {\n\n            const number = 1024;\n            const func = () => {\n\n                return Hoek.base64urlEncode(number);\n            };\n            expect(func).throws(Error);\n        });\n\n        it('should base64 URL-safe a string', () => {\n\n            expect(Hoek.base64urlEncode(str)).to.equal(base64str);\n        });\n\n        it('encodes a buffer', () => {\n\n            expect(Hoek.base64urlEncode(Buffer.from(str, 'binary'))).to.equal(base64str);\n        });\n\n        it('should base64 URL-safe a hex string', () => {\n\n            const buffer = Buffer.from(str, 'binary');\n            expect(Hoek.base64urlEncode(buffer.toString('hex'), 'hex')).to.equal(base64str);\n        });\n\n        it('works on larger input strings', () => {\n\n            const input = Fs.readFileSync(Path.join(__dirname, 'index.js')).toString();\n            const encoded = Hoek.base64urlEncode(input);\n\n            expect(encoded).to.not.contain('+');\n            expect(encoded).to.not.contain('/');\n\n            const decoded = Hoek.base64urlDecode(encoded);\n            expect(decoded).to.equal(input);\n        });\n    });\n\n    describe('base64urlDecode()', () => {\n\n        it('should un-base64 URL-safe a string', () => {\n\n            expect(Hoek.base64urlDecode(base64str)).to.equal(str);\n        });\n\n        it('should un-base64 URL-safe a string into hex', () => {\n\n            expect(Hoek.base64urlDecode(base64str, 'hex')).to.equal(Buffer.from(str, 'binary').toString('hex'));\n        });\n\n        it('should un-base64 URL-safe a string and return a buffer', () => {\n\n            const buf = Hoek.base64urlDecode(base64str, 'buffer');\n            expect(buf instanceof Buffer).to.equal(true);\n            expect(buf.toString('binary')).to.equal(str);\n        });\n\n        it('throws error on invalid input', () => {\n\n            expect(() => Hoek.base64urlDecode(1024)).to.throw('Value not a string');\n        });\n\n        it('throws error on invalid input', () => {\n\n            expect(() => Hoek.base64urlDecode('*')).to.throw('Invalid character');\n        });\n    });\n});\n\ndescribe('escapeHeaderAttribute()', () => {\n\n    it('should not alter ascii values', () => {\n\n        const a = Hoek.escapeHeaderAttribute('My Value');\n        expect(a).to.equal('My Value');\n    });\n\n    it('escapes all special HTTP header attribute characters', () => {\n\n        const a = Hoek.escapeHeaderAttribute('I said go!!!#\"' + String.fromCharCode(92));\n        expect(a).to.equal('I said go!!!#\\\\\"\\\\\\\\');\n    });\n\n    it('throws on large unicode characters', () => {\n\n        expect(() => {\n\n            Hoek.escapeHeaderAttribute('this is a test' + String.fromCharCode(500) + String.fromCharCode(300));\n        }).to.throw(Error);\n    });\n\n    it('throws on CRLF to prevent response splitting', () => {\n\n        expect(() => {\n\n            Hoek.escapeHeaderAttribute('this is a test\\r\\n');\n        }).to.throw(Error);\n    });\n});\n\ndescribe('escapeHtml()', () => {\n\n    it('escapes all special HTML characters', () => {\n\n        const a = Hoek.escapeHtml('&<>\"\\'`');\n        expect(a).to.equal('&amp;&lt;&gt;&quot;&#x27;&#x60;');\n    });\n\n    it('returns empty string on falsy input', () => {\n\n        const a = Hoek.escapeHtml('');\n        expect(a).to.equal('');\n    });\n\n    it('returns unchanged string on no reserved input', () => {\n\n        const a = Hoek.escapeHtml('abc');\n        expect(a).to.equal('abc');\n    });\n});\n\ndescribe('once()', () => {\n\n    it('allows function to only execute once', () => {\n\n        let gen = 0;\n        let add = function (x) {\n\n            gen += x;\n        };\n\n        add(5);\n        expect(gen).to.equal(5);\n        add = Hoek.once(add);\n        add(5);\n        expect(gen).to.equal(10);\n        add(5);\n        expect(gen).to.equal(10);\n    });\n\n    it('double once wraps one time', () => {\n\n        let method = function () { };\n        method = Hoek.once(method);\n        method.x = 1;\n        method = Hoek.once(method);\n        expect(method.x).to.equal(1);\n    });\n});\n\n\ndescribe('isInteger()', () => {\n\n    it('validates integers', () => {\n\n        expect(Hoek.isInteger(0)).to.equal(true);\n        expect(Hoek.isInteger(1)).to.equal(true);\n        expect(Hoek.isInteger(1394035612500)).to.equal(true);\n        expect(Hoek.isInteger('0')).to.equal(false);\n        expect(Hoek.isInteger(1.0)).to.equal(true);\n        expect(Hoek.isInteger(1.1)).to.equal(false);\n        expect(Hoek.isInteger(90071992547409910.1)).to.equal(false);\n        expect(Hoek.isInteger(NaN)).to.equal(false);\n    });\n});\n\ndescribe('ignore()', () => {\n\n    it('exists', () => {\n\n        expect(Hoek.ignore).to.exist();\n        expect(typeof Hoek.ignore).to.equal('function');\n    });\n});\n\ndescribe('inherits()', () => {\n\n    it('exists', () => {\n\n        expect(Hoek.inherits).to.exist();\n        expect(typeof Hoek.inherits).to.equal('function');\n    });\n});\n\ndescribe('format()', () => {\n\n    it('exists', () => {\n\n        expect(Hoek.format).to.exist();\n        expect(typeof Hoek.format).to.equal('function');\n    });\n\n    it('is a reference to Util.format', () => {\n\n        expect(Hoek.format('hello %s', 'world')).to.equal('hello world');\n    });\n});\n\ndescribe('transform()', () => {\n\n    const source = {\n        address: {\n            one: '123 main street',\n            two: 'PO Box 1234'\n        },\n        zip: {\n            code: 3321232,\n            province: null\n        },\n        title: 'Warehouse',\n        state: 'CA'\n    };\n\n    const sourcesArray = [{\n        address: {\n            one: '123 main street',\n            two: 'PO Box 1234'\n        },\n        zip: {\n            code: 3321232,\n            province: null\n        },\n        title: 'Warehouse',\n        state: 'CA'\n    }, {\n        address: {\n            one: '456 market street',\n            two: 'PO Box 5678'\n        },\n        zip: {\n            code: 9876,\n            province: null\n        },\n        title: 'Garage',\n        state: 'NY'\n    }];\n\n    it('transforms an object based on the input object', () => {\n\n        const result = Hoek.transform(source, {\n            'person.address.lineOne': 'address.one',\n            'person.address.lineTwo': 'address.two',\n            'title': 'title',\n            'person.address.region': 'state',\n            'person.address.zip': 'zip.code',\n            'person.address.location': 'zip.province'\n        });\n\n        expect(result).to.equal({\n            person: {\n                address: {\n                    lineOne: '123 main street',\n                    lineTwo: 'PO Box 1234',\n                    region: 'CA',\n                    zip: 3321232,\n                    location: null\n                }\n            },\n            title: 'Warehouse'\n        });\n    });\n\n    it('transforms an array of objects based on the input object', () => {\n\n        const result = Hoek.transform(sourcesArray, {\n            'person.address.lineOne': 'address.one',\n            'person.address.lineTwo': 'address.two',\n            'title': 'title',\n            'person.address.region': 'state',\n            'person.address.zip': 'zip.code',\n            'person.address.location': 'zip.province'\n        });\n\n        expect(result).to.equal([\n            {\n                person: {\n                    address: {\n                        lineOne: '123 main street',\n                        lineTwo: 'PO Box 1234',\n                        region: 'CA',\n                        zip: 3321232,\n                        location: null\n                    }\n                },\n                title: 'Warehouse'\n            },\n            {\n                person: {\n                    address: {\n                        lineOne: '456 market street',\n                        lineTwo: 'PO Box 5678',\n                        region: 'NY',\n                        zip: 9876,\n                        location: null\n                    }\n                },\n                title: 'Garage'\n            }\n        ]);\n    });\n\n    it('uses the reach options passed into it', () => {\n\n        const schema = {\n            'person-address-lineOne': 'address-one',\n            'person-address-lineTwo': 'address-two',\n            'title': 'title',\n            'person-address-region': 'state',\n            'person-prefix': 'person-title',\n            'person-zip': 'zip-code'\n        };\n        const options = {\n            separator: '-',\n            default: 'unknown'\n        };\n        const result = Hoek.transform(source, schema, options);\n\n        expect(result).to.equal({\n            person: {\n                address: {\n                    lineOne: '123 main street',\n                    lineTwo: 'PO Box 1234',\n                    region: 'CA'\n                },\n                prefix: 'unknown',\n                zip: 3321232\n            },\n            title: 'Warehouse'\n        });\n    });\n\n    it('uses a default separator for keys if options does not specify on', () => {\n\n        const schema = {\n            'person.address.lineOne': 'address.one',\n            'person.address.lineTwo': 'address.two',\n            'title': 'title',\n            'person.address.region': 'state',\n            'person.prefix': 'person.title',\n            'person.zip': 'zip.code'\n        };\n        const options = {\n            default: 'unknown'\n        };\n        const result = Hoek.transform(source, schema, options);\n\n        expect(result).to.equal({\n            person: {\n                address: {\n                    lineOne: '123 main street',\n                    lineTwo: 'PO Box 1234',\n                    region: 'CA'\n                },\n                prefix: 'unknown',\n                zip: 3321232\n            },\n            title: 'Warehouse'\n        });\n    });\n\n    it('works to create shallow objects', () => {\n\n        const result = Hoek.transform(source, {\n            lineOne: 'address.one',\n            lineTwo: 'address.two',\n            title: 'title',\n            region: 'state',\n            province: 'zip.province'\n        });\n\n        expect(result).to.equal({\n            lineOne: '123 main street',\n            lineTwo: 'PO Box 1234',\n            title: 'Warehouse',\n            region: 'CA',\n            province: null\n        });\n    });\n\n    it('only allows strings in the map', () => {\n\n        expect(() => {\n\n            Hoek.transform(source, {\n                lineOne: {}\n            });\n        }).to.throw('All mappings must be \".\" delineated strings');\n    });\n\n    it('throws an error on invalid arguments', () => {\n\n        expect(() => {\n\n            Hoek.transform(NaN, {});\n        }).to.throw('Invalid source object: must be null, undefined, an object, or an array');\n    });\n\n    it('is safe to pass null', () => {\n\n        const result = Hoek.transform(null, {});\n        expect(result).to.equal({});\n    });\n\n    it('is safe to pass undefined', () => {\n\n        const result = Hoek.transform(undefined, {});\n        expect(result).to.equal({});\n    });\n});\n\ndescribe('uniqueFilename()', () => {\n\n    it('generates a random file path', () => {\n\n        const result = Hoek.uniqueFilename('./test/modules');\n\n        expect(result).to.exist();\n        expect(result).to.be.a.string();\n        expect(result).to.contain(`test${Path.sep}modules`);\n    });\n\n    it('is random enough to use in fast loops', () => {\n\n        const results = [];\n\n        for (let i = 0; i < 10; ++i) {\n            results[i] = Hoek.uniqueFilename('./test/modules');\n        }\n\n        const filter = results.filter((item, index, array) => {\n\n            return array.indexOf(item) === index;\n        });\n\n        expect(filter.length).to.equal(10);\n        expect(results.length).to.equal(10);\n    });\n\n    it('combines the random elements with a supplied character', () => {\n\n        const result = Hoek.uniqueFilename('./test', 'txt');\n\n        expect(result).to.contain(`test${Path.sep}`);\n        expect(result).to.contain('.txt');\n    });\n\n    it('accepts extensions with a \".\" in it', () => {\n\n        const result = Hoek.uniqueFilename('./test', '.mp3');\n\n        expect(result).to.contain(`test${Path.sep}`);\n        expect(result).to.contain('.mp3');\n    });\n});\n\ndescribe('stringify()', () => {\n\n    it('converts object to string', () => {\n\n        const obj = { a: 1 };\n        expect(Hoek.stringify(obj)).to.equal('{\"a\":1}');\n    });\n\n    it('returns error in result string', () => {\n\n        const obj = { a: 1 };\n        obj.b = obj;\n        expect(Hoek.stringify(obj)).to.equal('[Cannot display object: Converting circular structure to JSON]');\n    });\n});\n\ndescribe('shallow()', () => {\n\n    it('shallow copies an object', () => {\n\n        const obj = {\n            a: 5,\n            b: {\n                c: 6\n            }\n        };\n\n        const shallow = Hoek.shallow(obj);\n        expect(shallow).to.not.shallow.equal(obj);\n        expect(shallow).to.equal(obj);\n        expect(shallow.b).to.equal(obj.b);\n    });\n});\n\ndescribe('block()', () => {\n\n    it('executes ignore function', async () => {\n\n        const orig = Hoek.ignore;\n        Hoek.ignore = (resolve) => resolve();\n        await Hoek.block();\n        Hoek.ignore = orig;\n    });\n});\n"], "filenames": ["lib/index.js", "test/index.js"], "buggy_code_start_loc": [117, 586], "buggy_code_end_loc": [117, 586], "fixing_code_start_loc": [118, 587], "fixing_code_end_loc": [122, 596], "type": "CWE-471", "message": "hoek node module before 4.2.0 and 5.0.x before 5.0.3 suffers from a Modification of Assumed-Immutable Data (MAID) vulnerability via 'merge' and 'applyToDefaults' functions, which allows a malicious user to modify the prototype of \"Object\" via __proto__, causing the addition or modification of an existing property that will exist on all objects.", "other": {"cve": {"id": "CVE-2018-3728", "sourceIdentifier": "support@hackerone.com", "published": "2018-03-30T19:29:00.210", "lastModified": "2019-10-09T23:40:33.200", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "hoek node module before 4.2.0 and 5.0.x before 5.0.3 suffers from a Modification of Assumed-Immutable Data (MAID) vulnerability via 'merge' and 'applyToDefaults' functions, which allows a malicious user to modify the prototype of \"Object\" via __proto__, causing the addition or modification of an existing property that will exist on all objects."}, {"lang": "es", "value": "El m\u00f3dulo hoek en Node en versiones anteriores a la 5.0.3 se ve afectada por una vulnerabilidad MAID (modificaci\u00f3n de datos asumidos como inmutables) mediante las funciones \"merge\" y \"applyToDefaults\", lo que permite que un usuario malicioso modifique el prototipo de \"Object\" mediante __proto__, provocando la adici\u00f3n o modificaci\u00f3n de una propiedad existente que va a existir en todos los objetos."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-471"}]}, {"source": "support@hackerone.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-471"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:hapijs:hoek:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "4.2.0", "matchCriteriaId": "95E7F4B8-573D-417C-8591-CD4CF7B5EF14"}, {"vulnerable": true, "criteria": "cpe:2.3:a:hapijs:hoek:*:*:*:*:*:node.js:*:*", "versionStartIncluding": "5.0.0", "versionEndExcluding": "5.0.3", "matchCriteriaId": "92E82C0D-613B-4A5E-A9E6-5F21FDCA25EE"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/103108", "source": "support@hackerone.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:1263", "source": "support@hackerone.com", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:1264", "source": "support@hackerone.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/hapijs/hoek/commit/32ed5c9413321fbc37da5ca81a7cbab693786dee", "source": "support@hackerone.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://hackerone.com/reports/310439", "source": "support@hackerone.com", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://nodesecurity.io/advisories/566", "source": "support@hackerone.com", "tags": ["Broken Link"]}, {"url": "https://snyk.io/vuln/npm:hoek:20180212", "source": "support@hackerone.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/hapijs/hoek/commit/32ed5c9413321fbc37da5ca81a7cbab693786dee"}}