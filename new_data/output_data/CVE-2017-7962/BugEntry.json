{"buggy_code": ["// imagew-gif.c\n// Part of ImageWorsener, Copyright (c) 2011 by Jason Summers.\n// For more information, see the readme.txt file.\n\n// This is a self-contained GIF image decoder.\n// It supports a single image only, so it does not support animated GIFs,\n// or any GIF where the main image is constructed from multiple sub-images.\n\n#include \"imagew-config.h\"\n\n#include <stdlib.h>\n#include <string.h>\n\n#define IW_INCLUDE_UTIL_FUNCTIONS\n#include \"imagew.h\"\n\nstruct iwgifrcontext {\n\tstruct iw_iodescr *iodescr;\n\tstruct iw_context *ctx;\n\tstruct iw_image *img;\n\n\tstruct iw_csdescr csdescr;\n\tint page; // Page to read. 1=first\n\n\tint screen_width, screen_height; // Same as .img->width, .img->height\n\tint image_width, image_height;\n\tint image_left, image_top;\n\n\tint include_screen; // Do we paint the image onto the \"screen\", or just extract it?\n\tint screen_initialized;\n\tint pages_seen;\n\tint interlaced;\n\tint bytes_per_pixel;\n\tint has_transparency;\n\tint has_bg_color;\n\tint bg_color_index;\n\tint trans_color_index;\n\n\tsize_t pixels_set; // Number of pixels decoded so far\n\tsize_t total_npixels; // Total number of pixels in the \"image\" (not the \"screen\")\n\n\tiw_byte **row_pointers;\n\n\tstruct iw_palette colortable;\n\n\t// A buffer used when reading the GIF file.\n\t// The largest block we need to read is a 256-color palette.\n\tiw_byte rbuf[768];\n};\n\nstatic int iwgif_read(struct iwgifrcontext *rctx,\n\t\tiw_byte *buf, size_t buflen)\n{\n\tint ret;\n\tsize_t bytesread = 0;\n\n\tret = (*rctx->iodescr->read_fn)(rctx->ctx,rctx->iodescr,\n\t\tbuf,buflen,&bytesread);\n\tif(!ret || bytesread!=buflen) {\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic int iwgif_read_file_header(struct iwgifrcontext *rctx)\n{\n\tif(!iwgif_read(rctx,rctx->rbuf,6)) return 0;\n\tif(rctx->rbuf[0]!='G' || rctx->rbuf[1]!='I' || rctx->rbuf[2]!='F') {\n\t\tiw_set_error(rctx->ctx,\"Not a GIF file\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic int iwgif_read_screen_descriptor(struct iwgifrcontext *rctx)\n{\n\tint has_global_ct;\n\tint global_ct_size;\n\tint aspect_ratio_code;\n\n\t// The screen descriptor is always 7 bytes in size.\n\tif(!iwgif_read(rctx,rctx->rbuf,7)) return 0;\n\trctx->screen_width = (int)iw_get_ui16le(&rctx->rbuf[0]);\n\trctx->screen_height = (int)iw_get_ui16le(&rctx->rbuf[2]);\n\t// screen_width and _height may be updated in iwgif_init_screen().\n\n\thas_global_ct = (int)((rctx->rbuf[4]>>7)&0x01);\n\n\tif(has_global_ct) {\n\t\t// Size of global color table\n\t\tglobal_ct_size = (int)(rctx->rbuf[4]&0x07);\n\t\trctx->colortable.num_entries = 1<<(1+global_ct_size);\n\n\t\t// Background color\n\t\trctx->bg_color_index = (int)rctx->rbuf[5];\n\t\tif(rctx->bg_color_index < rctx->colortable.num_entries)\n\t\t\trctx->has_bg_color = 1;\n\t}\n\n\taspect_ratio_code = (int)rctx->rbuf[6];\n\tif(aspect_ratio_code!=0) {\n\t\t// [aspect ratio = (pixel width)/(pixel height)]\n\t\trctx->img->density_code = IW_DENSITY_UNITS_UNKNOWN;\n\t\trctx->img->density_x = 64000.0/(double)(aspect_ratio_code + 15);\n\t\trctx->img->density_y = 1000.0;\n\t}\n\n\treturn 1;\n}\n\n// Read a global or local palette into memory.\n// ct->num_entries must be set by caller\nstatic int iwgif_read_color_table(struct iwgifrcontext *rctx, struct iw_palette *ct)\n{\n\tint i;\n\tif(ct->num_entries<1) return 1;\n\n\tif(!iwgif_read(rctx,rctx->rbuf,3*ct->num_entries)) return 0;\n\tfor(i=0;i<ct->num_entries;i++) {\n\t\tct->entry[i].r = rctx->rbuf[3*i+0];\n\t\tct->entry[i].g = rctx->rbuf[3*i+1];\n\t\tct->entry[i].b = rctx->rbuf[3*i+2];\n\t}\n\treturn 1;\n}\n\nstatic int iwgif_skip_subblocks(struct iwgifrcontext *rctx)\n{\n\tiw_byte subblock_size;\n\n\twhile(1) {\n\t\t// Read the subblock size\n\t\tif(!iwgif_read(rctx,rctx->rbuf,1)) return 0;\n\n\t\tsubblock_size = rctx->rbuf[0];\n\t\t// A size of 0 marks the end of the subblocks.\n\t\tif(subblock_size==0) return 1;\n\n\t\t// Read the subblock's data\n\t\tif(!iwgif_read(rctx,rctx->rbuf,(size_t)subblock_size)) return 0;\n\t}\n}\n\n// We need transparency information, so we have to process graphic control\n// extensions.\nstatic int iwgif_read_graphic_control_ext(struct iwgifrcontext *rctx)\n{\n\tint retval;\n\n\t// Read 6 bytes:\n\t//  The first is the subblock size, which must be 4.\n\t//  The last is the block terminator.\n\t//  The middle 4 contain the actual data.\n\tif(!iwgif_read(rctx,rctx->rbuf,6)) goto done;\n\n\tif(rctx->rbuf[0]!=4) goto done;\n\tif(rctx->rbuf[5]!=0) goto done;\n\trctx->has_transparency = (int)((rctx->rbuf[1])&0x01);\n\tif(rctx->has_transparency) {\n\t\trctx->trans_color_index = (int)rctx->rbuf[4];\n\t}\n\n\tretval=1;\ndone:\n\treturn retval;\n}\n\nstatic int iwgif_read_extension(struct iwgifrcontext *rctx)\n{\n\tint retval=0;\n\tiw_byte ext_type;\n\n\tif(!iwgif_read(rctx,rctx->rbuf,1)) goto done;\n\text_type=rctx->rbuf[0];\n\n\tswitch(ext_type) {\n\tcase 0xf9:\n\t\tif(rctx->page == rctx->pages_seen+1) {\n\t\t\tif(!iwgif_read_graphic_control_ext(rctx)) goto done;\n\t\t}\n\t\telse {\n\t\t\t// This extension's scope does not include the image we're\n\t\t\t// processing, so ignore it.\n\t\t\tif(!iwgif_skip_subblocks(rctx)) goto done;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tif(!iwgif_skip_subblocks(rctx)) goto done;\n\t}\n\n\tretval=1;\ndone:\n\treturn retval;\n}\n\n// Set the (rctx->pixels_set + offset)th pixel in the logical image to the\n// color represented by palette entry #coloridx.\nstatic void iwgif_record_pixel(struct iwgifrcontext *rctx, unsigned int coloridx,\n\t\tint offset)\n{\n\tstruct iw_image *img;\n\tunsigned int r,g,b,a;\n\tsize_t pixnum;\n\tsize_t xi,yi; // position in image coordinates\n\tsize_t xs,ys; // position in screen coordinates\n\tiw_byte *ptr;\n\n\timg = rctx->img;\n\n\t// Figure out which pixel to set.\n\n\tpixnum = rctx->pixels_set + offset;\n\txi = pixnum%rctx->image_width;\n\tyi = pixnum/rctx->image_width;\n\txs = rctx->image_left + xi;\n\tys = rctx->image_top + yi;\n\n\t// Make sure the coordinate is within the image, and on the screen.\n\tif(yi>=(size_t)rctx->image_height) return;\n\tif(xs>=(size_t)rctx->screen_width) return;\n\tif(ys>=(size_t)rctx->screen_height) return;\n\n\t// Because of how we de-interlace, it's not obvious whether the Y coordinate\n\t// is on the screen. The easiest way is to check if the row pointer is NULL.\n\tif(rctx->row_pointers[yi]==NULL) return;\n\n\t// Figure out what color to set the pixel to.\n\n\tif(coloridx<(unsigned int)rctx->colortable.num_entries) {\n\t\tr=rctx->colortable.entry[coloridx].r;\n\t\tg=rctx->colortable.entry[coloridx].g;\n\t\tb=rctx->colortable.entry[coloridx].b;\n\t\ta=rctx->colortable.entry[coloridx].a;\n\t}\n\telse {\n\t\treturn; // Illegal palette index\n\t}\n\n\t// Set the pixel.\n\n\tptr = &rctx->row_pointers[yi][rctx->bytes_per_pixel*xi];\n\tptr[0]=r; ptr[1]=g; ptr[2]=b;\n\tif(img->imgtype==IW_IMGTYPE_RGBA) {\n\t\tptr[3]=a;\n\t}\n}\n\n////////////////////////////////////////////////////////\n//                    LZW decoder\n////////////////////////////////////////////////////////\n\nstruct lzw_tableentry {\n\tiw_uint16 parent; // pointer to previous table entry (if not a root code)\n\tiw_uint16 length;\n\tiw_byte firstchar;\n\tiw_byte lastchar;\n};\n\nstruct lzwdeccontext {\n\tunsigned int root_codesize;\n\tunsigned int current_codesize;\n\tint eoi_flag;\n\tunsigned int oldcode;\n\tunsigned int pending_code;\n\tunsigned int bits_in_pending_code;\n\tunsigned int num_root_codes;\n\tint ncodes_since_clear;\n\n\tunsigned int clear_code;\n\tunsigned int eoi_code;\n\tunsigned int last_code_added;\n\n\tunsigned int ct_used; // Number of items used in the code table\n\tstruct lzw_tableentry ct[4096]; // Code table\n};\n\nstatic void lzw_init(struct lzwdeccontext *d, unsigned int root_codesize)\n{\n\tunsigned int i;\n\n\tiw_zeromem(d,sizeof(struct lzwdeccontext));\n\n\td->root_codesize = root_codesize;\n\td->num_root_codes = 1<<d->root_codesize;\n\td->clear_code = d->num_root_codes;\n\td->eoi_code = d->num_root_codes+1;\n\tfor(i=0;i<d->num_root_codes;i++) {\n\t\td->ct[i].parent = 0;\n\t\td->ct[i].length = 1;\n\t\td->ct[i].lastchar = (iw_byte)i;\n\t\td->ct[i].firstchar = (iw_byte)i;\n\t}\n}\n\nstatic void lzw_clear(struct lzwdeccontext *d)\n{\n\td->ct_used = d->num_root_codes+2;\n\td->current_codesize = d->root_codesize+1;\n\td->ncodes_since_clear=0;\n\td->oldcode=0;\n}\n\n// Decode an LZW code to one or more pixels, and record it in the image.\nstatic void lzw_emit_code(struct iwgifrcontext *rctx, struct lzwdeccontext *d,\n\t\tunsigned int first_code)\n{\n\tunsigned int code;\n\tcode = first_code;\n\n\t// An LZW code may decode to more than one pixel. Note that the pixels for\n\t// an LZW code are decoded in reverse order (right to left).\n\n\twhile(1) {\n\t\tiwgif_record_pixel(rctx, (unsigned int)d->ct[code].lastchar, (int)(d->ct[code].length-1));\n\t\tif(d->ct[code].length<=1) break;\n\t\t// The codes are structured as a \"forest\" (multiple trees).\n\t\t// Go to the parent code, which will have a length 1 less than this one.\n\t\tcode = (unsigned int)d->ct[code].parent;\n\t}\n\n\t// Track the total number of pixels decoded in this image.\n\trctx->pixels_set += d->ct[first_code].length;\n}\n\n// Add a code to the dictionary.\n// Sets d->last_code_added to the position where it was added.\n// Returns 1 if successful, 0 if table is full.\nstatic int lzw_add_to_dict(struct lzwdeccontext *d, unsigned int oldcode, iw_byte val)\n{\n\tstatic const unsigned int last_code_of_size[] = {\n\t\t// The first 3 values are unused.\n\t\t0,0,0,7,15,31,63,127,255,511,1023,2047,4095\n\t};\n\tunsigned int newpos;\n\n\tif(d->ct_used>=4096) {\n\t\td->last_code_added = 0;\n\t\treturn 0;\n\t}\n\n\tnewpos = d->ct_used;\n\td->ct_used++;\n\n\td->ct[newpos].parent = (iw_uint16)oldcode;\n\td->ct[newpos].length = d->ct[oldcode].length + 1;\n\td->ct[newpos].firstchar = d->ct[oldcode].firstchar;\n\td->ct[newpos].lastchar = val;\n\n\t// If we've used the last code of this size, we need to increase the codesize.\n\tif(newpos == last_code_of_size[d->current_codesize]) {\n\t\tif(d->current_codesize<12) {\n\t\t\td->current_codesize++;\n\t\t}\n\t}\n\n\td->last_code_added = newpos;\n\treturn 1;\n}\n\n// Process a single LZW code that was read from the input stream.\nstatic int lzw_process_code(struct iwgifrcontext *rctx, struct lzwdeccontext *d,\n\t\tunsigned int code)\n{\n\tif(code==d->eoi_code) {\n\t\td->eoi_flag=1;\n\t\treturn 1;\n\t}\n\n\tif(code==d->clear_code) {\n\t\tlzw_clear(d);\n\t\treturn 1;\n\t}\n\n\td->ncodes_since_clear++;\n\n\tif(d->ncodes_since_clear==1) {\n\t\t// Special case for the first code.\n\t\tlzw_emit_code(rctx,d,code);\n\t\td->oldcode = code;\n\t\treturn 1;\n\t}\n\n\t// Is code in code table?\n\tif(code < d->ct_used) {\n\t\t// Yes, code is in table.\n\t\tlzw_emit_code(rctx,d,code);\n\n\t\t// Let k = the first character of the translation of the code.\n\t\t// Add <oldcode>k to the dictionary.\n\t\tlzw_add_to_dict(d,d->oldcode,d->ct[code].firstchar);\n\t}\n\telse {\n\t\t// No, code is not in table.\n\t\tif(d->oldcode>=d->ct_used) {\n\t\t\tiw_set_error(rctx->ctx,\"GIF decoding error\");\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Let k = the first char of the translation of oldcode.\n\t\t// Add <oldcode>k to the dictionary.\n\t\tif(lzw_add_to_dict(d,d->oldcode,d->ct[d->oldcode].firstchar)) {\n\t\t\t// Write <oldcode>k to the output stream.\n\t\t\tlzw_emit_code(rctx,d,d->last_code_added);\n\t\t}\n\t}\n\td->oldcode = code;\n\n\treturn 1;\n}\n\n// Decode as much as possible of the provided LZW-encoded data.\n// Any unfinished business is recorded, to be continued the next time\n// this function is called.\nstatic int lzw_process_bytes(struct iwgifrcontext *rctx, struct lzwdeccontext *d,\n\tiw_byte *data, size_t data_size)\n{\n\tsize_t i;\n\tint b;\n\tint retval=0;\n\n\tfor(i=0;i<data_size;i++) {\n\t\t// Look at the bits one at a time.\n\t\tfor(b=0;b<8;b++) {\n\t\t\tif(d->eoi_flag) { // Stop if we've seen an EOI (end of image) code.\n\t\t\t\tretval=1;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif(data[i]&(1<<b))\n\t\t\t\td->pending_code |= 1<<d->bits_in_pending_code;\n\t\t\td->bits_in_pending_code++;\n\n\t\t\t// When we get enough bits to form a complete LZW code, process it.\n\t\t\tif(d->bits_in_pending_code >= d->current_codesize) {\n\t\t\t\tif(!lzw_process_code(rctx,d,d->pending_code)) goto done;\n\t\t\t\td->pending_code=0;\n\t\t\t\td->bits_in_pending_code=0;\n\t\t\t}\n\t\t}\n\t}\n\tretval=1;\n\ndone:\n\treturn retval;\n}\n\n////////////////////////////////////////////////////////\n\n// Allocate and set up the global \"screen\".\nstatic int iwgif_init_screen(struct iwgifrcontext *rctx)\n{\n\tstruct iw_image *img;\n\tint bg_visible=0;\n\tint retval=0;\n\n\tif(rctx->screen_initialized) return 1;\n\trctx->screen_initialized = 1;\n\n\timg = rctx->img;\n\n\tif(!rctx->include_screen) {\n\t\t// If ->include_screen is disabled, pretend the screen is the same size as\n\t\t// the GIF image, and pretend the GIF image is positioned at (0,0).\n\t\trctx->screen_width = rctx->image_width;\n\t\trctx->screen_height = rctx->image_height;\n\t\trctx->image_left = 0;\n\t\trctx->image_top = 0;\n\t}\n\n\timg->width = rctx->screen_width;\n\timg->height = rctx->screen_height;\n\tif(!iw_check_image_dimensions(rctx->ctx,img->width,img->height)) {\n\t\treturn 0;\n\t}\n\n\tif(rctx->image_left>0 || rctx->image_top>0 ||\n\t\t(rctx->image_left+rctx->image_width < rctx->screen_width) ||\n\t\t(rctx->image_top+rctx->image_height < rctx->screen_height) )\n\t{\n\t\t// Image does not cover the entire \"screen\". We'll make the exposed\n\t\t// regions of the screen transparent, so set a flag to let us know we\n\t\t// need an image type that supports transparency.\n\t\tbg_visible = 1;\n\t}\n\n\t// Allocate IW image\n\tif(rctx->has_transparency || bg_visible) {\n\t\trctx->bytes_per_pixel=4;\n\t\timg->imgtype = IW_IMGTYPE_RGBA;\n\t}\n\telse {\n\t\trctx->bytes_per_pixel=3;\n\t\timg->imgtype = IW_IMGTYPE_RGB;\n\t}\n\timg->bit_depth = 8;\n\timg->bpr = rctx->bytes_per_pixel * img->width;\n\n\timg->pixels = (iw_byte*)iw_malloc_large(rctx->ctx, img->bpr, img->height);\n\tif(!img->pixels) goto done;\n\n\t// Start by clearing the screen to black, or transparent black.\n\tiw_zeromem(img->pixels,img->bpr*img->height);\n\n\tretval=1;\ndone:\n\treturn retval;\n}\n\n// Make an array of pointers into the global screen, which point to the\n// start of each row in the local image. This will be useful for\n// de-interlacing.\nstatic int iwgif_make_row_pointers(struct iwgifrcontext *rctx)\n{\n\tstruct iw_image *img;\n\tint pass;\n\tint startrow, rowskip;\n\tint rowcount;\n\tint row;\n\n\tif(rctx->row_pointers) iw_free(rctx->ctx,rctx->row_pointers);\n\trctx->row_pointers = (iw_byte**)iw_malloc(rctx->ctx, sizeof(iw_byte*)*rctx->image_height);\n\tif(!rctx->row_pointers) return 0;\n\n\timg = rctx->img;\n\n\tif(rctx->interlaced) {\n\t\t// Image is interlaced. Rearrange the row pointers, so that it will be\n\t\t// de-interlaced as it is decoded.\n\t\trowcount=0;\n\t\tfor(pass=1;pass<=4;pass++) {\n\t\t\tif(pass==1) { startrow=0; rowskip=8; }\n\t\t\telse if(pass==2) { startrow=4; rowskip=8; }\n\t\t\telse if(pass==3) { startrow=2; rowskip=4; }\n\t\t\telse { startrow=1; rowskip=2; }\n\n\t\t\tfor(row=startrow;row<rctx->image_height;row+=rowskip) {\n\t\t\t\tif(rctx->image_top+row < rctx->screen_height) {\n\t\t\t\t\trctx->row_pointers[rowcount] = &img->pixels[(rctx->image_top+row)*img->bpr + (rctx->image_left)*rctx->bytes_per_pixel];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\trctx->row_pointers[rowcount] = NULL;\n\t\t\t\t}\n\t\t\t\trowcount++;\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\t// Image is not interlaced.\n\t\tfor(row=0;row<rctx->image_height;row++) {\n\t\t\tif(rctx->image_top+row < rctx->screen_height) {\n\t\t\t\trctx->row_pointers[row] = &img->pixels[(rctx->image_top+row)*img->bpr + (rctx->image_left)*rctx->bytes_per_pixel];\n\t\t\t}\n\t\t\telse {\n\t\t\t\trctx->row_pointers[row] = NULL;\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic int iwgif_skip_image(struct iwgifrcontext *rctx)\n{\n\tint has_local_ct;\n\tint local_ct_size;\n\tint ct_num_entries;\n\tint retval=0;\n\n\t// Read image header information\n\tif(!iwgif_read(rctx,rctx->rbuf,9)) goto done;\n\n\thas_local_ct = (int)((rctx->rbuf[8]>>7)&0x01);\n\tif(has_local_ct) {\n\t\tlocal_ct_size = (int)(rctx->rbuf[8]&0x07);\n\t\tct_num_entries = 1<<(1+local_ct_size);\n\t}\n\n\t// Skip the local color table\n\tif(has_local_ct) {\n\t\tif(!iwgif_read(rctx,rctx->rbuf,3*ct_num_entries)) goto done;\n\t}\n\n\t// Skip the LZW code size\n\tif(!iwgif_read(rctx,rctx->rbuf,1)) goto done;\n\n\t// Skip the image pixels\n\tif(!iwgif_skip_subblocks(rctx)) goto done;\n\n\t// Reset anything that might have been set by a graphic control extension.\n\t// Their scope is the first image that follows them.\n\trctx->has_transparency = 0;\n\n\tretval=1;\n\ndone:\n\treturn retval;\n}\n\nstatic int iwgif_read_image(struct iwgifrcontext *rctx)\n{\n\tint retval=0;\n\tstruct lzwdeccontext d;\n\tsize_t subblocksize;\n\tint has_local_ct;\n\tint local_ct_size;\n\n\tunsigned int root_codesize;\n\n\t// Read image header information\n\tif(!iwgif_read(rctx,rctx->rbuf,9)) goto done;\n\n\trctx->image_left = (int)iw_get_ui16le(&rctx->rbuf[0]);\n\trctx->image_top = (int)iw_get_ui16le(&rctx->rbuf[2]);\n\t// image_left and _top may be updated in iwgif_init_screen().\n\n\trctx->image_width = (int)iw_get_ui16le(&rctx->rbuf[4]);\n\trctx->image_height = (int)iw_get_ui16le(&rctx->rbuf[6]);\n\n\trctx->interlaced = (int)((rctx->rbuf[8]>>6)&0x01);\n\n\thas_local_ct = (int)((rctx->rbuf[8]>>7)&0x01);\n\tif(has_local_ct) {\n\t\tlocal_ct_size = (int)(rctx->rbuf[8]&0x07);\n\t\trctx->colortable.num_entries = 1<<(1+local_ct_size);\n\t}\n\n\tif(has_local_ct) {\n\t\t// We only support one image, so we don't need to keep both a global and a\n\t\t// local color table. If an image has both, the local table will overwrite\n\t\t// the global one.\n\t\tif(!iwgif_read_color_table(rctx,&rctx->colortable)) goto done;\n\t}\n\n\t// Make the transparent color transparent.\n\tif(rctx->has_transparency) {\n\t    rctx->colortable.entry[rctx->trans_color_index].a = 0;\n\t}\n\n\t// Read LZW code size\n\tif(!iwgif_read(rctx,rctx->rbuf,1)) goto done;\n\troot_codesize = (unsigned int)rctx->rbuf[0];\n\n\t// The spec does not allow the \"minimum code size\" to be less than 2.\n\t// Sizes >=12 are impossible to support.\n\t// There's no reason for the size to be larger than 8, but the spec\n\t// does not seem to forbid it.\n\tif(root_codesize<2 || root_codesize>11) {\n\t\tiw_set_error(rctx->ctx,\"Invalid LZW minimum code size\");\n\t\tgoto done;\n\t}\n\n\t// The creation of the global \"screen\" was deferred until now, to wait until\n\t// we know whether the image has transparency.\n\t// (And if !rctx->include_screen, to wait until we know the size of the image.)\n\tif(!iwgif_init_screen(rctx)) goto done;\n\n\trctx->total_npixels = (size_t)rctx->image_width * (size_t)rctx->image_height;\n\n\tif(!iwgif_make_row_pointers(rctx)) goto done;\n\n\tlzw_init(&d,root_codesize);\n\tlzw_clear(&d);\n\n\twhile(1) {\n\t\t// Read size of next subblock\n\t\tif(!iwgif_read(rctx,rctx->rbuf,1)) goto done;\n\t\tsubblocksize = (size_t)rctx->rbuf[0];\n\t\tif(subblocksize==0) break;\n\n\t\t// Read next subblock\n\t\tif(!iwgif_read(rctx,rctx->rbuf,subblocksize)) goto done;\n\t\tif(!lzw_process_bytes(rctx,&d,rctx->rbuf,subblocksize)) goto done;\n\n\t\tif(d.eoi_flag) break;\n\n\t\t// Stop if we reached the end of the image. We don't care if we've read an\n\t\t// EOI code or not.\n\t\tif(rctx->pixels_set >= rctx->total_npixels) break;\n\t}\n\n\tretval=1;\n\ndone:\n\treturn retval;\n}\n\nstatic int iwgif_read_main(struct iwgifrcontext *rctx)\n{\n\tint retval=0;\n\tint i;\n\tint image_found=0;\n\n\t// Make all colors opaque by default.\n\tfor(i=0;i<256;i++) {\n\t\trctx->colortable.entry[i].a=255;\n\t}\n\n\tif(!iwgif_read_file_header(rctx)) goto done;\n\n\tif(!iwgif_read_screen_descriptor(rctx)) goto done;\n\n\t// Read global color table\n\tif(!iwgif_read_color_table(rctx,&rctx->colortable)) goto done;\n\n\t// Tell IW the background color.\n\tif(rctx->has_bg_color) {\n\t\tiw_set_input_bkgd_label(rctx->ctx,\n\t\t\t((double)rctx->colortable.entry[rctx->bg_color_index].r)/255.0,\n\t\t\t((double)rctx->colortable.entry[rctx->bg_color_index].g)/255.0,\n\t\t\t((double)rctx->colortable.entry[rctx->bg_color_index].b)/255.0);\n\t}\n\n\t// The remainder of the file consists of blocks whose type is indicated by\n\t// their initial byte.\n\n\twhile(!image_found) {\n\t\t// Read block type\n\t\tif(!iwgif_read(rctx,rctx->rbuf,1)) goto done;\n\n\t\tswitch(rctx->rbuf[0]) {\n\t\tcase 0x21: // extension\n\t\t\tif(!iwgif_read_extension(rctx)) goto done;\n\t\t\tbreak;\n\t\tcase 0x2c: // image\n\t\t\trctx->pages_seen++;\n\t\t\tif(rctx->page == rctx->pages_seen) {\n\t\t\t\tif(!iwgif_read_image(rctx)) goto done;\n\t\t\t\timage_found=1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif(!iwgif_skip_image(rctx)) goto done;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x3b: // file trailer\n\t\t\t// We stop after we decode an image, so if we ever see a file\n\t\t\t// trailer, something's wrong.\n\t\t\tif(rctx->pages_seen==0)\n\t\t\t\tiw_set_error(rctx->ctx,\"No image in file\");\n\t\t\telse\n\t\t\t\tiw_set_error(rctx->ctx,\"Image not found\");\n\t\t\tgoto done;\n\t\tdefault:\n\t\t\tiw_set_error(rctx->ctx,\"Invalid or unsupported GIF file\");\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tretval=1;\n\ndone:\n\treturn retval;\n}\n\nIW_IMPL(int) iw_read_gif_file(struct iw_context *ctx, struct iw_iodescr *iodescr)\n{\n\tstruct iw_image img;\n\tstruct iwgifrcontext *rctx = NULL;\n\tint retval=0;\n\n\tiw_zeromem(&img,sizeof(struct iw_image));\n\trctx = iw_mallocz(ctx,sizeof(struct iwgifrcontext));\n\tif(!rctx) goto done;\n\n\trctx->ctx = ctx;\n\trctx->iodescr = iodescr;\n\trctx->img = &img;\n\n\t// Assume GIF images are sRGB.\n\tiw_make_srgb_csdescr_2(&rctx->csdescr);\n\n\trctx->page = iw_get_value(ctx,IW_VAL_PAGE_TO_READ);\n\tif(rctx->page<1) rctx->page = 1;\n\n\trctx->include_screen = iw_get_value(ctx,IW_VAL_INCLUDE_SCREEN);\n\n\tif(!iwgif_read_main(rctx))\n\t\tgoto done;\n\n\tiw_set_input_image(ctx, &img);\n\n\tiw_set_input_colorspace(ctx,&rctx->csdescr);\n\n\tretval = 1;\n\ndone:\n\tif(!retval) {\n\t\tiw_set_error(ctx,\"Failed to read GIF file\");\n\t}\n\n\tif(rctx) {\n\t\tif(rctx->row_pointers) iw_free(ctx,rctx->row_pointers);\n\t\tiw_free(ctx,rctx);\n\t}\n\n\treturn retval;\n}\n"], "fixing_code": ["// imagew-gif.c\n// Part of ImageWorsener, Copyright (c) 2011 by Jason Summers.\n// For more information, see the readme.txt file.\n\n// This is a self-contained GIF image decoder.\n// It supports a single image only, so it does not support animated GIFs,\n// or any GIF where the main image is constructed from multiple sub-images.\n\n#include \"imagew-config.h\"\n\n#include <stdlib.h>\n#include <string.h>\n\n#define IW_INCLUDE_UTIL_FUNCTIONS\n#include \"imagew.h\"\n\nstruct iwgifrcontext {\n\tstruct iw_iodescr *iodescr;\n\tstruct iw_context *ctx;\n\tstruct iw_image *img;\n\n\tstruct iw_csdescr csdescr;\n\tint page; // Page to read. 1=first\n\n\tint screen_width, screen_height; // Same as .img->width, .img->height\n\tint image_width, image_height;\n\tint image_left, image_top;\n\n\tint include_screen; // Do we paint the image onto the \"screen\", or just extract it?\n\tint screen_initialized;\n\tint pages_seen;\n\tint interlaced;\n\tint bytes_per_pixel;\n\tint has_transparency;\n\tint has_bg_color;\n\tint bg_color_index;\n\tint trans_color_index;\n\n\tsize_t pixels_set; // Number of pixels decoded so far\n\tsize_t total_npixels; // Total number of pixels in the \"image\" (not the \"screen\")\n\n\tiw_byte **row_pointers;\n\n\tstruct iw_palette colortable;\n\n\t// A buffer used when reading the GIF file.\n\t// The largest block we need to read is a 256-color palette.\n\tiw_byte rbuf[768];\n};\n\nstatic int iwgif_read(struct iwgifrcontext *rctx,\n\t\tiw_byte *buf, size_t buflen)\n{\n\tint ret;\n\tsize_t bytesread = 0;\n\n\tret = (*rctx->iodescr->read_fn)(rctx->ctx,rctx->iodescr,\n\t\tbuf,buflen,&bytesread);\n\tif(!ret || bytesread!=buflen) {\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic int iwgif_read_file_header(struct iwgifrcontext *rctx)\n{\n\tif(!iwgif_read(rctx,rctx->rbuf,6)) return 0;\n\tif(rctx->rbuf[0]!='G' || rctx->rbuf[1]!='I' || rctx->rbuf[2]!='F') {\n\t\tiw_set_error(rctx->ctx,\"Not a GIF file\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic int iwgif_read_screen_descriptor(struct iwgifrcontext *rctx)\n{\n\tint has_global_ct;\n\tint global_ct_size;\n\tint aspect_ratio_code;\n\n\t// The screen descriptor is always 7 bytes in size.\n\tif(!iwgif_read(rctx,rctx->rbuf,7)) return 0;\n\trctx->screen_width = (int)iw_get_ui16le(&rctx->rbuf[0]);\n\trctx->screen_height = (int)iw_get_ui16le(&rctx->rbuf[2]);\n\t// screen_width and _height may be updated in iwgif_init_screen().\n\n\thas_global_ct = (int)((rctx->rbuf[4]>>7)&0x01);\n\n\tif(has_global_ct) {\n\t\t// Size of global color table\n\t\tglobal_ct_size = (int)(rctx->rbuf[4]&0x07);\n\t\trctx->colortable.num_entries = 1<<(1+global_ct_size);\n\n\t\t// Background color\n\t\trctx->bg_color_index = (int)rctx->rbuf[5];\n\t\tif(rctx->bg_color_index < rctx->colortable.num_entries)\n\t\t\trctx->has_bg_color = 1;\n\t}\n\n\taspect_ratio_code = (int)rctx->rbuf[6];\n\tif(aspect_ratio_code!=0) {\n\t\t// [aspect ratio = (pixel width)/(pixel height)]\n\t\trctx->img->density_code = IW_DENSITY_UNITS_UNKNOWN;\n\t\trctx->img->density_x = 64000.0/(double)(aspect_ratio_code + 15);\n\t\trctx->img->density_y = 1000.0;\n\t}\n\n\treturn 1;\n}\n\n// Read a global or local palette into memory.\n// ct->num_entries must be set by caller\nstatic int iwgif_read_color_table(struct iwgifrcontext *rctx, struct iw_palette *ct)\n{\n\tint i;\n\tif(ct->num_entries<1) return 1;\n\n\tif(!iwgif_read(rctx,rctx->rbuf,3*ct->num_entries)) return 0;\n\tfor(i=0;i<ct->num_entries;i++) {\n\t\tct->entry[i].r = rctx->rbuf[3*i+0];\n\t\tct->entry[i].g = rctx->rbuf[3*i+1];\n\t\tct->entry[i].b = rctx->rbuf[3*i+2];\n\t}\n\treturn 1;\n}\n\nstatic int iwgif_skip_subblocks(struct iwgifrcontext *rctx)\n{\n\tiw_byte subblock_size;\n\n\twhile(1) {\n\t\t// Read the subblock size\n\t\tif(!iwgif_read(rctx,rctx->rbuf,1)) return 0;\n\n\t\tsubblock_size = rctx->rbuf[0];\n\t\t// A size of 0 marks the end of the subblocks.\n\t\tif(subblock_size==0) return 1;\n\n\t\t// Read the subblock's data\n\t\tif(!iwgif_read(rctx,rctx->rbuf,(size_t)subblock_size)) return 0;\n\t}\n}\n\n// We need transparency information, so we have to process graphic control\n// extensions.\nstatic int iwgif_read_graphic_control_ext(struct iwgifrcontext *rctx)\n{\n\tint retval;\n\n\t// Read 6 bytes:\n\t//  The first is the subblock size, which must be 4.\n\t//  The last is the block terminator.\n\t//  The middle 4 contain the actual data.\n\tif(!iwgif_read(rctx,rctx->rbuf,6)) goto done;\n\n\tif(rctx->rbuf[0]!=4) goto done;\n\tif(rctx->rbuf[5]!=0) goto done;\n\trctx->has_transparency = (int)((rctx->rbuf[1])&0x01);\n\tif(rctx->has_transparency) {\n\t\trctx->trans_color_index = (int)rctx->rbuf[4];\n\t}\n\n\tretval=1;\ndone:\n\treturn retval;\n}\n\nstatic int iwgif_read_extension(struct iwgifrcontext *rctx)\n{\n\tint retval=0;\n\tiw_byte ext_type;\n\n\tif(!iwgif_read(rctx,rctx->rbuf,1)) goto done;\n\text_type=rctx->rbuf[0];\n\n\tswitch(ext_type) {\n\tcase 0xf9:\n\t\tif(rctx->page == rctx->pages_seen+1) {\n\t\t\tif(!iwgif_read_graphic_control_ext(rctx)) goto done;\n\t\t}\n\t\telse {\n\t\t\t// This extension's scope does not include the image we're\n\t\t\t// processing, so ignore it.\n\t\t\tif(!iwgif_skip_subblocks(rctx)) goto done;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tif(!iwgif_skip_subblocks(rctx)) goto done;\n\t}\n\n\tretval=1;\ndone:\n\treturn retval;\n}\n\n// Set the (rctx->pixels_set + offset)th pixel in the logical image to the\n// color represented by palette entry #coloridx.\nstatic void iwgif_record_pixel(struct iwgifrcontext *rctx, unsigned int coloridx,\n\t\tint offset)\n{\n\tstruct iw_image *img;\n\tunsigned int r,g,b,a;\n\tsize_t pixnum;\n\tsize_t xi,yi; // position in image coordinates\n\tsize_t xs,ys; // position in screen coordinates\n\tiw_byte *ptr;\n\n\timg = rctx->img;\n\n\t// Figure out which pixel to set.\n\n\tpixnum = rctx->pixels_set + offset;\n\txi = pixnum%rctx->image_width;\n\tyi = pixnum/rctx->image_width;\n\txs = rctx->image_left + xi;\n\tys = rctx->image_top + yi;\n\n\t// Make sure the coordinate is within the image, and on the screen.\n\tif(yi>=(size_t)rctx->image_height) return;\n\tif(xs>=(size_t)rctx->screen_width) return;\n\tif(ys>=(size_t)rctx->screen_height) return;\n\n\t// Because of how we de-interlace, it's not obvious whether the Y coordinate\n\t// is on the screen. The easiest way is to check if the row pointer is NULL.\n\tif(rctx->row_pointers[yi]==NULL) return;\n\n\t// Figure out what color to set the pixel to.\n\n\tif(coloridx<(unsigned int)rctx->colortable.num_entries) {\n\t\tr=rctx->colortable.entry[coloridx].r;\n\t\tg=rctx->colortable.entry[coloridx].g;\n\t\tb=rctx->colortable.entry[coloridx].b;\n\t\ta=rctx->colortable.entry[coloridx].a;\n\t}\n\telse {\n\t\treturn; // Illegal palette index\n\t}\n\n\t// Set the pixel.\n\n\tptr = &rctx->row_pointers[yi][rctx->bytes_per_pixel*xi];\n\tptr[0]=r; ptr[1]=g; ptr[2]=b;\n\tif(img->imgtype==IW_IMGTYPE_RGBA) {\n\t\tptr[3]=a;\n\t}\n}\n\n////////////////////////////////////////////////////////\n//                    LZW decoder\n////////////////////////////////////////////////////////\n\nstruct lzw_tableentry {\n\tiw_uint16 parent; // pointer to previous table entry (if not a root code)\n\tiw_uint16 length;\n\tiw_byte firstchar;\n\tiw_byte lastchar;\n};\n\nstruct lzwdeccontext {\n\tunsigned int root_codesize;\n\tunsigned int current_codesize;\n\tint eoi_flag;\n\tunsigned int oldcode;\n\tunsigned int pending_code;\n\tunsigned int bits_in_pending_code;\n\tunsigned int num_root_codes;\n\tint ncodes_since_clear;\n\n\tunsigned int clear_code;\n\tunsigned int eoi_code;\n\tunsigned int last_code_added;\n\n\tunsigned int ct_used; // Number of items used in the code table\n\tstruct lzw_tableentry ct[4096]; // Code table\n};\n\nstatic void lzw_init(struct lzwdeccontext *d, unsigned int root_codesize)\n{\n\tunsigned int i;\n\n\tiw_zeromem(d,sizeof(struct lzwdeccontext));\n\n\td->root_codesize = root_codesize;\n\td->num_root_codes = 1<<d->root_codesize;\n\td->clear_code = d->num_root_codes;\n\td->eoi_code = d->num_root_codes+1;\n\tfor(i=0;i<d->num_root_codes;i++) {\n\t\td->ct[i].parent = 0;\n\t\td->ct[i].length = 1;\n\t\td->ct[i].lastchar = (iw_byte)i;\n\t\td->ct[i].firstchar = (iw_byte)i;\n\t}\n}\n\nstatic void lzw_clear(struct lzwdeccontext *d)\n{\n\td->ct_used = d->num_root_codes+2;\n\td->current_codesize = d->root_codesize+1;\n\td->ncodes_since_clear=0;\n\td->oldcode=0;\n}\n\n// Decode an LZW code to one or more pixels, and record it in the image.\nstatic void lzw_emit_code(struct iwgifrcontext *rctx, struct lzwdeccontext *d,\n\t\tunsigned int first_code)\n{\n\tunsigned int code;\n\tcode = first_code;\n\n\t// An LZW code may decode to more than one pixel. Note that the pixels for\n\t// an LZW code are decoded in reverse order (right to left).\n\n\twhile(1) {\n\t\tiwgif_record_pixel(rctx, (unsigned int)d->ct[code].lastchar, (int)(d->ct[code].length-1));\n\t\tif(d->ct[code].length<=1) break;\n\t\t// The codes are structured as a \"forest\" (multiple trees).\n\t\t// Go to the parent code, which will have a length 1 less than this one.\n\t\tcode = (unsigned int)d->ct[code].parent;\n\t}\n\n\t// Track the total number of pixels decoded in this image.\n\trctx->pixels_set += d->ct[first_code].length;\n}\n\n// Add a code to the dictionary.\n// Sets d->last_code_added to the position where it was added.\n// Returns 1 if successful, 0 if table is full.\nstatic int lzw_add_to_dict(struct lzwdeccontext *d, unsigned int oldcode, iw_byte val)\n{\n\tstatic const unsigned int last_code_of_size[] = {\n\t\t// The first 3 values are unused.\n\t\t0,0,0,7,15,31,63,127,255,511,1023,2047,4095\n\t};\n\tunsigned int newpos;\n\n\tif(d->ct_used>=4096) {\n\t\td->last_code_added = 0;\n\t\treturn 0;\n\t}\n\n\tnewpos = d->ct_used;\n\td->ct_used++;\n\n\td->ct[newpos].parent = (iw_uint16)oldcode;\n\td->ct[newpos].length = d->ct[oldcode].length + 1;\n\td->ct[newpos].firstchar = d->ct[oldcode].firstchar;\n\td->ct[newpos].lastchar = val;\n\n\t// If we've used the last code of this size, we need to increase the codesize.\n\tif(newpos == last_code_of_size[d->current_codesize]) {\n\t\tif(d->current_codesize<12) {\n\t\t\td->current_codesize++;\n\t\t}\n\t}\n\n\td->last_code_added = newpos;\n\treturn 1;\n}\n\n// Process a single LZW code that was read from the input stream.\nstatic int lzw_process_code(struct iwgifrcontext *rctx, struct lzwdeccontext *d,\n\t\tunsigned int code)\n{\n\tif(code==d->eoi_code) {\n\t\td->eoi_flag=1;\n\t\treturn 1;\n\t}\n\n\tif(code==d->clear_code) {\n\t\tlzw_clear(d);\n\t\treturn 1;\n\t}\n\n\td->ncodes_since_clear++;\n\n\tif(d->ncodes_since_clear==1) {\n\t\t// Special case for the first code.\n\t\tlzw_emit_code(rctx,d,code);\n\t\td->oldcode = code;\n\t\treturn 1;\n\t}\n\n\t// Is code in code table?\n\tif(code < d->ct_used) {\n\t\t// Yes, code is in table.\n\t\tlzw_emit_code(rctx,d,code);\n\n\t\t// Let k = the first character of the translation of the code.\n\t\t// Add <oldcode>k to the dictionary.\n\t\tlzw_add_to_dict(d,d->oldcode,d->ct[code].firstchar);\n\t}\n\telse {\n\t\t// No, code is not in table.\n\t\tif(d->oldcode>=d->ct_used) {\n\t\t\tiw_set_error(rctx->ctx,\"GIF decoding error\");\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Let k = the first char of the translation of oldcode.\n\t\t// Add <oldcode>k to the dictionary.\n\t\tif(lzw_add_to_dict(d,d->oldcode,d->ct[d->oldcode].firstchar)) {\n\t\t\t// Write <oldcode>k to the output stream.\n\t\t\tlzw_emit_code(rctx,d,d->last_code_added);\n\t\t}\n\t}\n\td->oldcode = code;\n\n\treturn 1;\n}\n\n// Decode as much as possible of the provided LZW-encoded data.\n// Any unfinished business is recorded, to be continued the next time\n// this function is called.\nstatic int lzw_process_bytes(struct iwgifrcontext *rctx, struct lzwdeccontext *d,\n\tiw_byte *data, size_t data_size)\n{\n\tsize_t i;\n\tint b;\n\tint retval=0;\n\n\tfor(i=0;i<data_size;i++) {\n\t\t// Look at the bits one at a time.\n\t\tfor(b=0;b<8;b++) {\n\t\t\tif(d->eoi_flag) { // Stop if we've seen an EOI (end of image) code.\n\t\t\t\tretval=1;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif(data[i]&(1<<b))\n\t\t\t\td->pending_code |= 1<<d->bits_in_pending_code;\n\t\t\td->bits_in_pending_code++;\n\n\t\t\t// When we get enough bits to form a complete LZW code, process it.\n\t\t\tif(d->bits_in_pending_code >= d->current_codesize) {\n\t\t\t\tif(!lzw_process_code(rctx,d,d->pending_code)) goto done;\n\t\t\t\td->pending_code=0;\n\t\t\t\td->bits_in_pending_code=0;\n\t\t\t}\n\t\t}\n\t}\n\tretval=1;\n\ndone:\n\treturn retval;\n}\n\n////////////////////////////////////////////////////////\n\n// Allocate and set up the global \"screen\".\nstatic int iwgif_init_screen(struct iwgifrcontext *rctx)\n{\n\tstruct iw_image *img;\n\tint bg_visible=0;\n\tint retval=0;\n\n\tif(rctx->screen_initialized) return 1;\n\trctx->screen_initialized = 1;\n\n\timg = rctx->img;\n\n\tif(!rctx->include_screen) {\n\t\t// If ->include_screen is disabled, pretend the screen is the same size as\n\t\t// the GIF image, and pretend the GIF image is positioned at (0,0).\n\t\trctx->screen_width = rctx->image_width;\n\t\trctx->screen_height = rctx->image_height;\n\t\trctx->image_left = 0;\n\t\trctx->image_top = 0;\n\t}\n\n\timg->width = rctx->screen_width;\n\timg->height = rctx->screen_height;\n\tif(!iw_check_image_dimensions(rctx->ctx,img->width,img->height)) {\n\t\treturn 0;\n\t}\n\n\tif(rctx->image_left>0 || rctx->image_top>0 ||\n\t\t(rctx->image_left+rctx->image_width < rctx->screen_width) ||\n\t\t(rctx->image_top+rctx->image_height < rctx->screen_height) )\n\t{\n\t\t// Image does not cover the entire \"screen\". We'll make the exposed\n\t\t// regions of the screen transparent, so set a flag to let us know we\n\t\t// need an image type that supports transparency.\n\t\tbg_visible = 1;\n\t}\n\n\t// Allocate IW image\n\tif(rctx->has_transparency || bg_visible) {\n\t\trctx->bytes_per_pixel=4;\n\t\timg->imgtype = IW_IMGTYPE_RGBA;\n\t}\n\telse {\n\t\trctx->bytes_per_pixel=3;\n\t\timg->imgtype = IW_IMGTYPE_RGB;\n\t}\n\timg->bit_depth = 8;\n\timg->bpr = rctx->bytes_per_pixel * img->width;\n\n\timg->pixels = (iw_byte*)iw_malloc_large(rctx->ctx, img->bpr, img->height);\n\tif(!img->pixels) goto done;\n\n\t// Start by clearing the screen to black, or transparent black.\n\tiw_zeromem(img->pixels,img->bpr*img->height);\n\n\tretval=1;\ndone:\n\treturn retval;\n}\n\n// Make an array of pointers into the global screen, which point to the\n// start of each row in the local image. This will be useful for\n// de-interlacing.\nstatic int iwgif_make_row_pointers(struct iwgifrcontext *rctx)\n{\n\tstruct iw_image *img;\n\tint pass;\n\tint startrow, rowskip;\n\tint rowcount;\n\tint row;\n\n\tif(rctx->row_pointers) iw_free(rctx->ctx,rctx->row_pointers);\n\trctx->row_pointers = (iw_byte**)iw_malloc(rctx->ctx, sizeof(iw_byte*)*rctx->image_height);\n\tif(!rctx->row_pointers) return 0;\n\n\timg = rctx->img;\n\n\tif(rctx->interlaced) {\n\t\t// Image is interlaced. Rearrange the row pointers, so that it will be\n\t\t// de-interlaced as it is decoded.\n\t\trowcount=0;\n\t\tfor(pass=1;pass<=4;pass++) {\n\t\t\tif(pass==1) { startrow=0; rowskip=8; }\n\t\t\telse if(pass==2) { startrow=4; rowskip=8; }\n\t\t\telse if(pass==3) { startrow=2; rowskip=4; }\n\t\t\telse { startrow=1; rowskip=2; }\n\n\t\t\tfor(row=startrow;row<rctx->image_height;row+=rowskip) {\n\t\t\t\tif(rctx->image_top+row < rctx->screen_height) {\n\t\t\t\t\trctx->row_pointers[rowcount] = &img->pixels[(rctx->image_top+row)*img->bpr + (rctx->image_left)*rctx->bytes_per_pixel];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\trctx->row_pointers[rowcount] = NULL;\n\t\t\t\t}\n\t\t\t\trowcount++;\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\t// Image is not interlaced.\n\t\tfor(row=0;row<rctx->image_height;row++) {\n\t\t\tif(rctx->image_top+row < rctx->screen_height) {\n\t\t\t\trctx->row_pointers[row] = &img->pixels[(rctx->image_top+row)*img->bpr + (rctx->image_left)*rctx->bytes_per_pixel];\n\t\t\t}\n\t\t\telse {\n\t\t\t\trctx->row_pointers[row] = NULL;\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic int iwgif_skip_image(struct iwgifrcontext *rctx)\n{\n\tint has_local_ct;\n\tint local_ct_size;\n\tint ct_num_entries;\n\tint retval=0;\n\n\t// Read image header information\n\tif(!iwgif_read(rctx,rctx->rbuf,9)) goto done;\n\n\thas_local_ct = (int)((rctx->rbuf[8]>>7)&0x01);\n\tif(has_local_ct) {\n\t\tlocal_ct_size = (int)(rctx->rbuf[8]&0x07);\n\t\tct_num_entries = 1<<(1+local_ct_size);\n\t}\n\n\t// Skip the local color table\n\tif(has_local_ct) {\n\t\tif(!iwgif_read(rctx,rctx->rbuf,3*ct_num_entries)) goto done;\n\t}\n\n\t// Skip the LZW code size\n\tif(!iwgif_read(rctx,rctx->rbuf,1)) goto done;\n\n\t// Skip the image pixels\n\tif(!iwgif_skip_subblocks(rctx)) goto done;\n\n\t// Reset anything that might have been set by a graphic control extension.\n\t// Their scope is the first image that follows them.\n\trctx->has_transparency = 0;\n\n\tretval=1;\n\ndone:\n\treturn retval;\n}\n\nstatic int iwgif_read_image(struct iwgifrcontext *rctx)\n{\n\tint retval=0;\n\tstruct lzwdeccontext d;\n\tsize_t subblocksize;\n\tint has_local_ct;\n\tint local_ct_size;\n\n\tunsigned int root_codesize;\n\n\t// Read image header information\n\tif(!iwgif_read(rctx,rctx->rbuf,9)) goto done;\n\n\trctx->image_left = (int)iw_get_ui16le(&rctx->rbuf[0]);\n\trctx->image_top = (int)iw_get_ui16le(&rctx->rbuf[2]);\n\t// image_left and _top may be updated in iwgif_init_screen().\n\n\trctx->image_width = (int)iw_get_ui16le(&rctx->rbuf[4]);\n\trctx->image_height = (int)iw_get_ui16le(&rctx->rbuf[6]);\n\tif(rctx->image_width<1 || rctx->image_height<1) {\n\t\tiw_set_error(rctx->ctx, \"Invalid image dimensions\");\n\t\tgoto done;\n\t}\n\n\trctx->interlaced = (int)((rctx->rbuf[8]>>6)&0x01);\n\n\thas_local_ct = (int)((rctx->rbuf[8]>>7)&0x01);\n\tif(has_local_ct) {\n\t\tlocal_ct_size = (int)(rctx->rbuf[8]&0x07);\n\t\trctx->colortable.num_entries = 1<<(1+local_ct_size);\n\t}\n\n\tif(has_local_ct) {\n\t\t// We only support one image, so we don't need to keep both a global and a\n\t\t// local color table. If an image has both, the local table will overwrite\n\t\t// the global one.\n\t\tif(!iwgif_read_color_table(rctx,&rctx->colortable)) goto done;\n\t}\n\n\t// Make the transparent color transparent.\n\tif(rctx->has_transparency) {\n\t    rctx->colortable.entry[rctx->trans_color_index].a = 0;\n\t}\n\n\t// Read LZW code size\n\tif(!iwgif_read(rctx,rctx->rbuf,1)) goto done;\n\troot_codesize = (unsigned int)rctx->rbuf[0];\n\n\t// The spec does not allow the \"minimum code size\" to be less than 2.\n\t// Sizes >=12 are impossible to support.\n\t// There's no reason for the size to be larger than 8, but the spec\n\t// does not seem to forbid it.\n\tif(root_codesize<2 || root_codesize>11) {\n\t\tiw_set_error(rctx->ctx,\"Invalid LZW minimum code size\");\n\t\tgoto done;\n\t}\n\n\t// The creation of the global \"screen\" was deferred until now, to wait until\n\t// we know whether the image has transparency.\n\t// (And if !rctx->include_screen, to wait until we know the size of the image.)\n\tif(!iwgif_init_screen(rctx)) goto done;\n\n\trctx->total_npixels = (size_t)rctx->image_width * (size_t)rctx->image_height;\n\n\tif(!iwgif_make_row_pointers(rctx)) goto done;\n\n\tlzw_init(&d,root_codesize);\n\tlzw_clear(&d);\n\n\twhile(1) {\n\t\t// Read size of next subblock\n\t\tif(!iwgif_read(rctx,rctx->rbuf,1)) goto done;\n\t\tsubblocksize = (size_t)rctx->rbuf[0];\n\t\tif(subblocksize==0) break;\n\n\t\t// Read next subblock\n\t\tif(!iwgif_read(rctx,rctx->rbuf,subblocksize)) goto done;\n\t\tif(!lzw_process_bytes(rctx,&d,rctx->rbuf,subblocksize)) goto done;\n\n\t\tif(d.eoi_flag) break;\n\n\t\t// Stop if we reached the end of the image. We don't care if we've read an\n\t\t// EOI code or not.\n\t\tif(rctx->pixels_set >= rctx->total_npixels) break;\n\t}\n\n\tretval=1;\n\ndone:\n\treturn retval;\n}\n\nstatic int iwgif_read_main(struct iwgifrcontext *rctx)\n{\n\tint retval=0;\n\tint i;\n\tint image_found=0;\n\n\t// Make all colors opaque by default.\n\tfor(i=0;i<256;i++) {\n\t\trctx->colortable.entry[i].a=255;\n\t}\n\n\tif(!iwgif_read_file_header(rctx)) goto done;\n\n\tif(!iwgif_read_screen_descriptor(rctx)) goto done;\n\n\t// Read global color table\n\tif(!iwgif_read_color_table(rctx,&rctx->colortable)) goto done;\n\n\t// Tell IW the background color.\n\tif(rctx->has_bg_color) {\n\t\tiw_set_input_bkgd_label(rctx->ctx,\n\t\t\t((double)rctx->colortable.entry[rctx->bg_color_index].r)/255.0,\n\t\t\t((double)rctx->colortable.entry[rctx->bg_color_index].g)/255.0,\n\t\t\t((double)rctx->colortable.entry[rctx->bg_color_index].b)/255.0);\n\t}\n\n\t// The remainder of the file consists of blocks whose type is indicated by\n\t// their initial byte.\n\n\twhile(!image_found) {\n\t\t// Read block type\n\t\tif(!iwgif_read(rctx,rctx->rbuf,1)) goto done;\n\n\t\tswitch(rctx->rbuf[0]) {\n\t\tcase 0x21: // extension\n\t\t\tif(!iwgif_read_extension(rctx)) goto done;\n\t\t\tbreak;\n\t\tcase 0x2c: // image\n\t\t\trctx->pages_seen++;\n\t\t\tif(rctx->page == rctx->pages_seen) {\n\t\t\t\tif(!iwgif_read_image(rctx)) goto done;\n\t\t\t\timage_found=1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif(!iwgif_skip_image(rctx)) goto done;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x3b: // file trailer\n\t\t\t// We stop after we decode an image, so if we ever see a file\n\t\t\t// trailer, something's wrong.\n\t\t\tif(rctx->pages_seen==0)\n\t\t\t\tiw_set_error(rctx->ctx,\"No image in file\");\n\t\t\telse\n\t\t\t\tiw_set_error(rctx->ctx,\"Image not found\");\n\t\t\tgoto done;\n\t\tdefault:\n\t\t\tiw_set_error(rctx->ctx,\"Invalid or unsupported GIF file\");\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tretval=1;\n\ndone:\n\treturn retval;\n}\n\nIW_IMPL(int) iw_read_gif_file(struct iw_context *ctx, struct iw_iodescr *iodescr)\n{\n\tstruct iw_image img;\n\tstruct iwgifrcontext *rctx = NULL;\n\tint retval=0;\n\n\tiw_zeromem(&img,sizeof(struct iw_image));\n\trctx = iw_mallocz(ctx,sizeof(struct iwgifrcontext));\n\tif(!rctx) goto done;\n\n\trctx->ctx = ctx;\n\trctx->iodescr = iodescr;\n\trctx->img = &img;\n\n\t// Assume GIF images are sRGB.\n\tiw_make_srgb_csdescr_2(&rctx->csdescr);\n\n\trctx->page = iw_get_value(ctx,IW_VAL_PAGE_TO_READ);\n\tif(rctx->page<1) rctx->page = 1;\n\n\trctx->include_screen = iw_get_value(ctx,IW_VAL_INCLUDE_SCREEN);\n\n\tif(!iwgif_read_main(rctx))\n\t\tgoto done;\n\n\tiw_set_input_image(ctx, &img);\n\n\tiw_set_input_colorspace(ctx,&rctx->csdescr);\n\n\tretval = 1;\n\ndone:\n\tif(!retval) {\n\t\tiw_set_error(ctx,\"Failed to read GIF file\");\n\t}\n\n\tif(rctx) {\n\t\tif(rctx->row_pointers) iw_free(ctx,rctx->row_pointers);\n\t\tiw_free(ctx,rctx);\n\t}\n\n\treturn retval;\n}\n"], "filenames": ["src/imagew-gif.c"], "buggy_code_start_loc": [616], "buggy_code_end_loc": [616], "fixing_code_start_loc": [617], "fixing_code_end_loc": [621], "type": "CWE-369", "message": "The iwgif_read_image function in imagew-gif.c in libimageworsener.a in ImageWorsener 1.3.0 allows remote attackers to cause a denial of service (divide-by-zero error and application crash) via a crafted file.", "other": {"cve": {"id": "CVE-2017-7962", "sourceIdentifier": "cve@mitre.org", "published": "2017-04-19T15:59:00.240", "lastModified": "2019-09-16T14:33:28.640", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The iwgif_read_image function in imagew-gif.c in libimageworsener.a in ImageWorsener 1.3.0 allows remote attackers to cause a denial of service (divide-by-zero error and application crash) via a crafted file."}, {"lang": "es", "value": "La funci\u00f3n iwgif_read_image en imagew-gif.c en libimageworsener.a en ImageWorsener 1.3.0 permite a atacantes remotos provocar una denegaci\u00f3n de servicio (error de divisi\u00f3n por cero y ca\u00edda de aplicaci\u00f3n) a trav\u00e9s de un archivo manipulado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-369"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:entropymine:imageworsener:1.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "7885E7F5-9F67-4322-B157-0C25804EBC71"}]}]}], "references": [{"url": "https://blogs.gentoo.org/ago/2017/04/17/imageworsener-divide-by-zero-in-iwgif_record_pixel-imagew-gif-c/", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/jsummers/imageworsener/commit/ca3356eb49fee03e2eaf6b6aff826988c1122d93", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/jsummers/imageworsener/issues/15", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Vendor Advisory"]}, {"url": "https://security.gentoo.org/glsa/201706-06", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/jsummers/imageworsener/commit/ca3356eb49fee03e2eaf6b6aff826988c1122d93"}}