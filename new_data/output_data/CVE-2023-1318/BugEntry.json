{"buggy_code": ["<?php\n/*******************************************************************\n    class.osticket.php\n\n    osTicket (sys) -> Config.\n\n    Core osTicket object: loads congfig and provides loggging facility.\n\n    Use osTicket::start(configId)\n\n    Peter Rotich <peter@osticket.com>\n    Copyright (c)  2006-2013 osTicket\n    http://www.osticket.com\n\n    Released under the GNU General Public License WITHOUT ANY WARRANTY.\n    See LICENSE.TXT for details.\n\n    vim: expandtab sw=4 ts=4 sts=4:\n**********************************************************************/\n\nrequire_once(INCLUDE_DIR.'class.csrf.php'); //CSRF token class.\nrequire_once(INCLUDE_DIR.'class.migrater.php');\nrequire_once(INCLUDE_DIR.'class.plugin.php');\nrequire_once INCLUDE_DIR . 'class.message.php';\n\ndefine('LOG_WARN',LOG_WARNING);\n\nclass osTicket {\n\n    var $loglevel=array(1=>'Error','Warning','Debug');\n\n    //Page errors.\n    var $errors;\n\n    //System\n    var $system;\n\n\n\n\n    var $warning;\n    var $message;\n\n    var $title; //Custom title. html > head > title.\n    var $headers;\n    var $pjax_extra;\n\n    var $config;\n    var $session;\n    var $csrf;\n    var $company;\n    var $plugins;\n\n    function __construct() {\n\n        require_once(INCLUDE_DIR.'class.config.php'); //Config helper\n        require_once(INCLUDE_DIR.'class.company.php');\n        // Load the config\n        $this->config = new OsticketConfig();\n        // Start session  (if not disabled)\n        if (!defined('DISABLE_SESSION') || !DISABLE_SESSION)\n            $this->session = osTicketSession::start(SESSION_TTL,\n                    $this->isUpgradePending());\n        // CSRF Token\n        $this->csrf = new CSRF('__CSRFToken__');\n        // Company information\n        $this->company = new Company();\n        // Load Plugin Manager\n        $this->plugins = new PluginManager();\n    }\n\n    function isSystemOnline() {\n        return ($this->getConfig() && $this->getConfig()->isHelpDeskOnline() && !$this->isUpgradePending());\n    }\n\n    function isUpgradePending() {\n\t\tforeach (DatabaseMigrater::getUpgradeStreams(UPGRADE_DIR.'streams/') as $stream=>$hash)\n\t\t\tif (strcasecmp($hash,\n\t\t\t\t\t$this->getConfig()->getSchemaSignature($stream)))\n\t\t\t\treturn true;\n\t\treturn false;\n    }\n\n    function getSession() {\n        return $this->session;\n    }\n\n    function getConfig() {\n        return $this->config;\n    }\n\n    function getDBSignature($namespace='core') {\n        return $this->getConfig()->getSchemaSignature($namespace);\n    }\n\n    function getVersion() {\n        return THIS_VERSION;\n    }\n\n    function getCSRF(){\n        return $this->csrf;\n    }\n\n    function getCSRFToken() {\n        return $this->getCSRF()->getToken();\n    }\n\n    function getCSRFFormInput() {\n        return $this->getCSRF()->getFormInput();\n    }\n\n    function validateCSRFToken($token) {\n        return ($token && $this->getCSRF()->validateToken($token));\n    }\n\n    function checkCSRFToken($name=false, $rotate=false) {\n        $name = $name ?: $this->getCSRF()->getTokenName();\n        $token = $_POST[$name] ?: $_SERVER['HTTP_X_CSRFTOKEN'];\n        if ($token && $this->validateCSRFToken($token)) {\n            if ($rotate) $this->getCSRF()->rotate();\n            return true;\n        }\n\n        $msg=sprintf(__('Invalid CSRF token [%1$s] on %2$s'),\n                Format::htmlchars(Format::sanitize($token)), THISPAGE);\n        $this->logWarning(__('Invalid CSRF Token').' '.$name, $msg, false);\n\n        return false;\n    }\n\n    function getLinkToken() {\n        return md5($this->getCSRFToken().SECRET_SALT.session_id());\n    }\n\n    function validateLinkToken($token) {\n            return ($token && !strcasecmp($token, $this->getLinkToken()));\n    }\n\n    /* Replace Template Variables */\n    function replaceTemplateVariables($input, $vars=array()) {\n\n        $replacer = new VariableReplacer();\n        $replacer->assign(array_merge($vars,\n            array('url' => $this->getConfig()->getBaseUrl(),\n                'company' => $this->company)\n                    ));\n\n        return $replacer->replaceVars($input);\n    }\n\n    static function getVarScope() {\n        return array(\n            'url' => __(\"osTicket's base url (FQDN)\"),\n            'company' => array('class' => 'Company', 'desc' => __('Company Information')),\n        );\n    }\n\n    function addExtraHeader($header, $pjax_script=false) {\n        $this->headers[md5($header)] = $header;\n        $this->pjax_extra[md5($header)] = $pjax_script;\n    }\n\n    function getExtraHeaders() {\n        return $this->headers;\n    }\n    function getExtraPjax() {\n        return $this->pjax_extra;\n    }\n\n    function setPageTitle($title) {\n        $this->title = $title;\n    }\n\n    function getPageTitle() {\n        return $this->title;\n    }\n\n    function getErrors() {\n        return $this->errors;\n    }\n\n    function setErrors($errors) {\n        $this->errors = $errors;\n    }\n\n    function getError() {\n        return $this->system['err'] ?? null;\n    }\n\n    function setError($error) {\n        $this->system['error'] = $error;\n    }\n\n    function clearError() {\n        $this->setError('');\n    }\n\n    function getWarning() {\n        return $this->system['warning'];\n    }\n\n    function setWarning($warning) {\n        $this->system['warning'] = $warning;\n    }\n\n    function clearWarning() {\n        $this->setWarning('');\n    }\n\n\n    function getNotice() {\n        return $this->system['notice'] ?? null;\n    }\n\n    function setNotice($notice) {\n        $this->system['notice'] = $notice;\n    }\n\n    function clearNotice() {\n        $this->setNotice('');\n    }\n\n\n    function alertAdmin($subject, $message, $log=false) {\n\n        //Set admin's email address\n        if (!($to = $this->getConfig()->getAdminEmail()))\n            $to = ADMIN_EMAIL;\n\n        //append URL to the message\n        $message.=\"\\n\\n\".$this->getConfig()->getBaseUrl();\n\n        //Try getting the alert email.\n        $email=null;\n        if(!($email=$this->getConfig()->getAlertEmail()))\n            $email=$this->getConfig()->getDefaultEmail(); //will take the default email.\n\n        if($email) {\n            $email->sendAlert($to, $subject, $message, null, array('text'=>true, 'reply-tag'=>false));\n        } else {//no luck - try the system mail.\n            Mailer::sendmail($to, $subject, $message, '\"'.__('osTicket Alerts').sprintf('\" <%s>',$to));\n        }\n\n        //log the alert? Watch out for loops here.\n        if($log)\n            $this->log(LOG_CRIT, $subject, $message, false); //Log the entry...and make sure no alerts are resent.\n\n    }\n\n    function logDebug($title, $message, $force=false) {\n        return $this->log(LOG_DEBUG, $title, $message, false, $force);\n    }\n\n    function logInfo($title, $message, $alert=false) {\n        return $this->log(LOG_INFO, $title, $message, $alert);\n    }\n\n    function logWarning($title, $message, $alert=true) {\n        return $this->log(LOG_WARN, $title, $message, $alert);\n    }\n\n    function logError($title, $error, $alert=true) {\n        return $this->log(LOG_ERR, $title, $error, $alert);\n    }\n\n    function logDBError($title, $error, $alert=true) {\n\n        if($alert && !$this->getConfig()->alertONSQLError())\n            $alert =false;\n\n        $e = new Exception();\n        $bt = str_replace(ROOT_DIR, _S(/* `root` is a root folder */ '(root)').'/',\n            $e->getTraceAsString());\n        $error .= nl2br(\"\\n\\n---- \"._S('Backtrace').\" ----\\n\".$bt);\n\n        // Prevent recursive loops through this code path\n        if (substr_count($bt, __FUNCTION__) > 1)\n            return;\n\n        return $this->log(LOG_ERR, $title, $error, $alert);\n    }\n\n    function log($priority, $title, $message, $alert=false, $force=false) {\n\n        //We are providing only 3 levels of logs. Windows style.\n        switch($priority) {\n            case LOG_EMERG:\n            case LOG_ALERT:\n            case LOG_CRIT:\n            case LOG_ERR:\n                $level=1; //Error\n                break;\n            case LOG_WARN:\n            case LOG_WARNING:\n                $level=2; //Warning\n                break;\n            case LOG_NOTICE:\n            case LOG_INFO:\n            case LOG_DEBUG:\n            default:\n                $level=3; //Debug\n        }\n\n        $loglevel=array(1=>'Error','Warning','Debug');\n\n        $info = array(\n            'title' => &$title,\n            'level' => $loglevel[$level],\n            'level_id' => $level,\n            'body' => &$message,\n        );\n        Signal::send('syslog', null, $info);\n\n        //Logging everything during upgrade.\n        if($this->getConfig()->getLogLevel()<$level && !$force)\n            return false;\n\n        //Alert admin if enabled...\n        $alert = $alert && !$this->isUpgradePending();\n        if ($alert && $this->getConfig()->getLogLevel() >= $level)\n            $this->alertAdmin($title, $message);\n\n        //Save log based on system log level settings.\n        $sql='INSERT INTO '.SYSLOG_TABLE.' SET created=NOW(), updated=NOW() '\n            .',title='.db_input(Format::sanitize($title, true))\n            .',log_type='.db_input($loglevel[$level])\n            .',log='.db_input(Format::sanitize($message, false))\n            .',ip_address='.db_input($_SERVER['REMOTE_ADDR']);\n\n        db_query($sql, false);\n\n        return true;\n    }\n\n    function purgeLogs() {\n\n        if(!($gp=$this->getConfig()->getLogGracePeriod()) || !is_numeric($gp))\n            return false;\n\n        //System logs\n        $sql='DELETE  FROM '.SYSLOG_TABLE.' WHERE DATE_ADD(created, INTERVAL '.$gp.' MONTH)<=NOW()';\n        db_query($sql);\n\n        //TODO: Activity logs\n\n        return true;\n    }\n    /*\n     * Util functions\n     *\n     */\n\n    function get_var($index, $vars, $default='', $type=null) {\n\n        if(is_array($vars)\n                && array_key_exists($index, $vars)\n                && (!$type || gettype($vars[$index])==$type))\n            return $vars[$index];\n\n        return $default;\n    }\n\n    function get_db_input($index, $vars, $quote=true) {\n        return db_input($this->get_var($index, $vars), $quote);\n    }\n\n    static function get_path_info() {\n        if(isset($_SERVER['PATH_INFO']))\n            return $_SERVER['PATH_INFO'];\n\n        if(isset($_SERVER['ORIG_PATH_INFO']))\n            return $_SERVER['ORIG_PATH_INFO'];\n\n        //TODO: conruct possible path info.\n\n        return null;\n    }\n\n    /**\n     * Fetch the current version(s) of osTicket softwares via DNS. The\n     * constants of MAJOR_VERSION, THIS_VERSION, and GIT_VERSION will be\n     * consulted to arrive at the most relevant version code for the latest\n     * release.\n     *\n     * Parameters:\n     * $product - (string|default:'core') the product to fetch versions for\n     * $major - (string|optional) optional major version to compare. This is\n     *      useful if more than one version is available. Only versions\n     *      specifying this major version ('m') are considered as version\n     *      candidates.\n     *\n     * Dns:\n     * The DNS zone will have TXT records for the product will be published\n     * in this format:\n     *\n     * \"v=1; m=1.9; V=1.9.11; c=deadbeef\"\n     *\n     * Where the string is a semicolon-separated string of key/value pairs\n     * with the following meanings:\n     *\n     * --+--------------------------\n     * v | DNS record format version\n     *\n     * For v=1, this is the meaning of the other keys\n     * --+-------------------------------------------\n     * m | (optional) major product version\n     * V | Full product version (usually a git tag)\n     * c | Git commit id of the release tag\n     * s | Schema signature of the version, which might help detect\n     *   | required migration\n     *\n     * Returns:\n     * (string|bool|null)\n     *  - 'v1.9.11' or 'deadbeef' if release tag or git commit id seems to\n     *      be most appropriate based on the value of GIT_VERSION\n     *  - null if the $major version is no longer supported\n     *  - false if no information is available in DNS\n     */\n     function getLatestVersion($product='core', $major=null) {\n        $records = dns_get_record($product.'.updates.osticket.com', DNS_TXT);\n        if (!$records)\n            return false;\n\n        $versions = array();\n        foreach ($records as $r) {\n            $txt = $r['txt'];\n            $info = array();\n            foreach (explode(';', $r['txt']) as $kv) {\n                list($k, $v) = explode('=', $kv);\n                if (!($k = trim($k)))\n                    continue;\n                $info[$k] = trim($v);\n            }\n            $versions[] = $info;\n        }\n        foreach ($versions as $info) {\n            switch ($info['v']) {\n            case '1':\n                if ($major && $info['m'] && $info['m'] != $major)\n                    continue 2;\n                if ($product == 'core' && GIT_VERSION == '$git')\n                    return $info['c'];\n                return $info['V'];\n            }\n        }\n    }\n\n   /*\n    * getTrustedProxies\n    *\n    * Get defined trusted proxies\n    */\n\n    static function getTrustedProxies() {\n        static $proxies = null;\n        // Parse trusted proxies from config file\n        if (!isset($proxies) && defined('TRUSTED_PROXIES'))\n            $proxies = array_filter(\n                    array_map('trim', explode(',', TRUSTED_PROXIES)));\n\n        return $proxies ?: array();\n    }\n\n    /*\n     * getLocalNetworkAddresses\n     *\n     * Get defined local network addresses\n     */\n    static function getLocalNetworkAddresses() {\n        static $ips = null;\n        // Parse local addreses from config file\n        if (!isset($ips) && defined('LOCAL_NETWORKS'))\n            $ips = array_filter(\n                    array_map('trim', explode(',', LOCAL_NETWORKS)));\n\n        return $ips ?: array();\n    }\n\n    static function get_root_path($dir) {\n\n        /* If run from the commandline, DOCUMENT_ROOT will not be set. It is\n         * also likely that the ROOT_PATH will not be necessary, so don't\n         * bother attempting to figure it out.\n         *\n         * Secondly, if the directory of main.inc.php is the same as the\n         * document root, the the ROOT path truly is '/'\n         */\n        if(!isset($_SERVER['DOCUMENT_ROOT'])\n                || !strcasecmp($_SERVER['DOCUMENT_ROOT'], $dir))\n            return '/';\n\n        /* The main idea is to try and use full-path filename of PHP_SELF and\n         * SCRIPT_NAME. The SCRIPT_NAME should be the path of that script\n         * inside the DOCUMENT_ROOT. This is most likely useful if osTicket\n         * is run using something like Apache UserDir setting where the\n         * DOCUMENT_ROOT of Apache and the installation path of osTicket\n         * have nothing in comon.\n         *\n         * +---------------------------+-------------------+----------------+\n         * | PHP Script                | SCRIPT_NAME       | ROOT_PATH      |\n         * +---------------------------+-------------------+----------------+\n         * | /home/u1/www/osticket/... | /~u1/osticket/... | /~u1/osticket/ |\n         * +---------------------------+-------------------+----------------+\n         *\n         * The algorithm will remove the directory of main.inc.php from\n         * as seen. What's left should be the script executed inside\n         * the osTicket installation. That is removed from SCRIPT_NAME.\n         * What's left is the ROOT_PATH.\n         */\n        $bt = debug_backtrace(false);\n        $frame = array_pop($bt);\n        $file = str_replace('\\\\','/', $frame['file']);\n        $path = substr($file, strlen(ROOT_DIR));\n        if($path && ($pos=strpos($_SERVER['SCRIPT_NAME'], $path))!==false)\n            return ($pos) ? substr($_SERVER['SCRIPT_NAME'], 0, $pos) : '/';\n\n        if (self::is_cli())\n            return '/';\n\n        return null;\n    }\n\n    /*\n     * get_base_url\n     *\n     * Get base url osTicket is installed on\n     * It Should match help desk url.\n     *\n     */\n    static function get_base_url() {\n        return sprintf('http%s://%s',\n                osTicket::is_https() ? 's' : '',\n                $_SERVER['HTTP_HOST'] . ROOT_PATH);\n    }\n\n    /*\n     * get_client_port\n     *\n     * Get client PORT from \"Http_X-Forwarded-PORT\" if we have trusted\n     * proxies set.\n     * FIXME: Follow trusted proxies chain\n     *\n     */\n    static function get_client_port($header='HTTP_X_FORWARDED_PORT') {\n        $port = $_SERVER['SERVER_PORT'];\n        // We're just making sure we have Trusted Proxies\n        // FIXME: Validate\n        $proxies = self::getTrustedProxies();\n        if (isset($_SERVER[$header]) &&  $proxies)\n            $port = $_SERVER[$header];\n\n        return $port;\n    }\n\n    /*\n     * get_client_ip\n     *\n     * Get client IP address from \"Http_X-Forwarded-For\" header by following a\n     * chain of trusted proxies.\n     *\n     * \"Http_X-Forwarded-For\" header value is a comma+space separated list of IP\n     * addresses, the left-most being the original client, and each successive\n     * proxy that passed the request all the way to the originating IP address.\n     *\n     */\n    static function get_client_ip($header='HTTP_X_FORWARDED_FOR') {\n\n        // Request IP\n        $ip = $_SERVER['REMOTE_ADDR'];\n        // Trusted proxies.\n        $proxies = self::getTrustedProxies();\n        // Return current IP address if header is not set and\n        // request is not from a trusted proxy.\n        if (!isset($_SERVER[$header])\n                || !$proxies\n                || !self::is_trusted_proxy($ip, $proxies))\n            return $ip;\n\n        // Get chain of proxied ip addresses\n        $ips = array_map('trim', explode(',', $_SERVER[$header]));\n        // Add request IP to the chain\n        $ips[] = $ip;\n        // Walk the chain in reverse - remove invalid IPs\n        $ips = array_reverse($ips);\n        foreach ($ips as $k => $ip) {\n            // Make sure the IP is valid and not a trusted proxy\n            if ($k && !Validator::is_ip($ip))\n                unset($ips[$k]);\n            elseif ($k && !self::is_trusted_proxy($ip, $proxies))\n                return $ip;\n        }\n\n        // We trust the 400 lb hacker... return left most valid IP\n        return array_pop($ips);\n    }\n\n    /*\n     * Checks if the IP is that of a trusted proxy\n     *\n     */\n    static function is_trusted_proxy($ip, $proxies=array()) {\n        $proxies = $proxies ?: self::getTrustedProxies();\n        // We don't have any proxies set.\n        if (!$proxies)\n            return false;\n        // Wildcard set - trust all proxies\n        else if (in_array('*', $proxies))\n            return true;\n\n        return ($proxies && Validator::check_ip($ip, $proxies));\n    }\n\n    /**\n     * is_local_ip\n     *\n     * Check if a given IP is part of defined local address blocks\n     *\n     */\n    static function is_local_ip($ip, $ips=array()) {\n        $ips = $ips\n            ?: self::getLocalNetworkAddresses()\n            ?: array();\n\n        foreach ($ips as $addr) {\n            if (Validator::check_ip($ip, $addr))\n                return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Returns TRUE if the request was made via HTTPS and false otherwise\n     */\n    static function is_https() {\n\n        // Local server flags\n        if (isset($_SERVER['HTTPS'])\n                && strtolower($_SERVER['HTTPS']) == 'on')\n            return true;\n\n        // Check if SSL was terminated by a loadbalancer\n        return (isset($_SERVER['HTTP_X_FORWARDED_PROTO'])\n                && !strcasecmp($_SERVER['HTTP_X_FORWARDED_PROTO'], 'https'));\n    }\n\n    /**\n     * Returns TRUE if the current browser is IE and FALSE otherwise\n     */\n    static function is_ie() {\n        if (preg_match('/MSIE|Internet Explorer|Trident\\/[\\d]{1}\\.[\\d]{1,2}/',\n                $_SERVER['HTTP_USER_AGENT']))\n            return true;\n\n        return false;\n    }\n\n    /* returns true if script is being executed via commandline */\n    static function is_cli() {\n        return (!strcasecmp(substr(php_sapi_name(), 0, 3), 'cli')\n                || (!isset($_SERVER['REQUEST_METHOD']) &&\n                    !isset($_SERVER['HTTP_HOST']))\n                    //Fallback when php-cgi binary is used via cli\n                );\n    }\n\n    /**** static functions ****/\n    static function start() {\n        // Prep basic translation support\n        Internationalization::bootstrap();\n\n        if(!($ost = new osTicket()))\n            return null;\n\n        // Bootstrap installed plugins\n        $ost->plugins->bootstrap();\n\n        // Mirror content updates to the search backend\n        $ost->searcher = new SearchInterface();\n\n        return $ost;\n    }\n}\n\n?>\n"], "fixing_code": ["<?php\n/*******************************************************************\n    class.osticket.php\n\n    osTicket (sys) -> Config.\n\n    Core osTicket object: loads congfig and provides loggging facility.\n\n    Use osTicket::start(configId)\n\n    Peter Rotich <peter@osticket.com>\n    Copyright (c)  2006-2013 osTicket\n    http://www.osticket.com\n\n    Released under the GNU General Public License WITHOUT ANY WARRANTY.\n    See LICENSE.TXT for details.\n\n    vim: expandtab sw=4 ts=4 sts=4:\n**********************************************************************/\n\nrequire_once(INCLUDE_DIR.'class.csrf.php'); //CSRF token class.\nrequire_once(INCLUDE_DIR.'class.migrater.php');\nrequire_once(INCLUDE_DIR.'class.plugin.php');\nrequire_once INCLUDE_DIR . 'class.message.php';\n\ndefine('LOG_WARN',LOG_WARNING);\n\nclass osTicket {\n\n    var $loglevel=array(1=>'Error','Warning','Debug');\n\n    //Page errors.\n    var $errors;\n\n    //System\n    var $system;\n\n\n\n\n    var $warning;\n    var $message;\n\n    var $title; //Custom title. html > head > title.\n    var $headers;\n    var $pjax_extra;\n\n    var $config;\n    var $session;\n    var $csrf;\n    var $company;\n    var $plugins;\n\n    function __construct() {\n\n        require_once(INCLUDE_DIR.'class.config.php'); //Config helper\n        require_once(INCLUDE_DIR.'class.company.php');\n        // Load the config\n        $this->config = new OsticketConfig();\n        // Start session  (if not disabled)\n        if (!defined('DISABLE_SESSION') || !DISABLE_SESSION)\n            $this->session = osTicketSession::start(SESSION_TTL,\n                    $this->isUpgradePending());\n        // CSRF Token\n        $this->csrf = new CSRF('__CSRFToken__');\n        // Company information\n        $this->company = new Company();\n        // Load Plugin Manager\n        $this->plugins = new PluginManager();\n    }\n\n    function isSystemOnline() {\n        return ($this->getConfig() && $this->getConfig()->isHelpDeskOnline() && !$this->isUpgradePending());\n    }\n\n    function isUpgradePending() {\n\t\tforeach (DatabaseMigrater::getUpgradeStreams(UPGRADE_DIR.'streams/') as $stream=>$hash)\n\t\t\tif (strcasecmp($hash,\n\t\t\t\t\t$this->getConfig()->getSchemaSignature($stream)))\n\t\t\t\treturn true;\n\t\treturn false;\n    }\n\n    function getSession() {\n        return $this->session;\n    }\n\n    function getConfig() {\n        return $this->config;\n    }\n\n    function getDBSignature($namespace='core') {\n        return $this->getConfig()->getSchemaSignature($namespace);\n    }\n\n    function getVersion() {\n        return THIS_VERSION;\n    }\n\n    function getCSRF(){\n        return $this->csrf;\n    }\n\n    function getCSRFToken() {\n        return $this->getCSRF()->getToken();\n    }\n\n    function getCSRFFormInput() {\n        return $this->getCSRF()->getFormInput();\n    }\n\n    function validateCSRFToken($token) {\n        return ($token && $this->getCSRF()->validateToken($token));\n    }\n\n    function checkCSRFToken($name=false, $rotate=false) {\n        $name = $name ?: $this->getCSRF()->getTokenName();\n        $token = $_POST[$name] ?: $_SERVER['HTTP_X_CSRFTOKEN'];\n        if ($token && $this->validateCSRFToken($token)) {\n            if ($rotate) $this->getCSRF()->rotate();\n            return true;\n        }\n\n        $msg=sprintf(__('Invalid CSRF token [%1$s] on %2$s'),\n                Format::htmlchars(Format::sanitize($token)), THISPAGE);\n        $this->logWarning(__('Invalid CSRF Token').' '.$name, $msg, false);\n\n        return false;\n    }\n\n    function getLinkToken() {\n        return md5($this->getCSRFToken().SECRET_SALT.session_id());\n    }\n\n    function validateLinkToken($token) {\n            return ($token && !strcasecmp($token, $this->getLinkToken()));\n    }\n\n    /* Replace Template Variables */\n    function replaceTemplateVariables($input, $vars=array()) {\n\n        $replacer = new VariableReplacer();\n        $replacer->assign(array_merge($vars,\n            array('url' => $this->getConfig()->getBaseUrl(),\n                'company' => $this->company)\n                    ));\n\n        return $replacer->replaceVars($input);\n    }\n\n    static function getVarScope() {\n        return array(\n            'url' => __(\"osTicket's base url (FQDN)\"),\n            'company' => array('class' => 'Company', 'desc' => __('Company Information')),\n        );\n    }\n\n    function addExtraHeader($header, $pjax_script=false) {\n        $this->headers[md5($header)] = $header;\n        $this->pjax_extra[md5($header)] = $pjax_script;\n    }\n\n    function getExtraHeaders() {\n        return $this->headers;\n    }\n    function getExtraPjax() {\n        return $this->pjax_extra;\n    }\n\n    function setPageTitle($title) {\n        $this->title = $title;\n    }\n\n    function getPageTitle() {\n        return $this->title;\n    }\n\n    function getErrors() {\n        return $this->errors;\n    }\n\n    function setErrors($errors) {\n        $this->errors = $errors;\n    }\n\n    function getError() {\n        return $this->system['err'] ?? null;\n    }\n\n    function setError($error) {\n        $this->system['error'] = $error;\n    }\n\n    function clearError() {\n        $this->setError('');\n    }\n\n    function getWarning() {\n        return $this->system['warning'];\n    }\n\n    function setWarning($warning) {\n        $this->system['warning'] = $warning;\n    }\n\n    function clearWarning() {\n        $this->setWarning('');\n    }\n\n\n    function getNotice() {\n        return $this->system['notice'] ?? null;\n    }\n\n    function setNotice($notice) {\n        $this->system['notice'] = $notice;\n    }\n\n    function clearNotice() {\n        $this->setNotice('');\n    }\n\n\n    function alertAdmin($subject, $message, $log=false) {\n\n        //Set admin's email address\n        if (!($to = $this->getConfig()->getAdminEmail()))\n            $to = ADMIN_EMAIL;\n\n        //append URL to the message\n        $message.=\"\\n\\n\".$this->getConfig()->getBaseUrl();\n\n        //Try getting the alert email.\n        $email=null;\n        if(!($email=$this->getConfig()->getAlertEmail()))\n            $email=$this->getConfig()->getDefaultEmail(); //will take the default email.\n\n        if($email) {\n            $email->sendAlert($to, $subject, $message, null, array('text'=>true, 'reply-tag'=>false));\n        } else {//no luck - try the system mail.\n            Mailer::sendmail($to, $subject, $message, '\"'.__('osTicket Alerts').sprintf('\" <%s>',$to));\n        }\n\n        //log the alert? Watch out for loops here.\n        if($log)\n            $this->log(LOG_CRIT, $subject, $message, false); //Log the entry...and make sure no alerts are resent.\n\n    }\n\n    function logDebug($title, $message, $force=false) {\n        return $this->log(LOG_DEBUG, $title, $message, false, $force);\n    }\n\n    function logInfo($title, $message, $alert=false) {\n        return $this->log(LOG_INFO, $title, $message, $alert);\n    }\n\n    function logWarning($title, $message, $alert=true) {\n        return $this->log(LOG_WARN, $title, $message, $alert);\n    }\n\n    function logError($title, $error, $alert=true) {\n        return $this->log(LOG_ERR, $title, $error, $alert);\n    }\n\n    function logDBError($title, $error, $alert=true) {\n\n        if($alert && !$this->getConfig()->alertONSQLError())\n            $alert =false;\n\n        $e = new Exception();\n        $bt = str_replace(ROOT_DIR, _S(/* `root` is a root folder */ '(root)').'/',\n            $e->getTraceAsString());\n        $error .= nl2br(\"\\n\\n---- \"._S('Backtrace').\" ----\\n\".$bt);\n\n        // Prevent recursive loops through this code path\n        if (substr_count($bt, __FUNCTION__) > 1)\n            return;\n\n        return $this->log(LOG_ERR, $title, $error, $alert);\n    }\n\n    function log($priority, $title, $message, $alert=false, $force=false) {\n\n        //We are providing only 3 levels of logs. Windows style.\n        switch($priority) {\n            case LOG_EMERG:\n            case LOG_ALERT:\n            case LOG_CRIT:\n            case LOG_ERR:\n                $level=1; //Error\n                break;\n            case LOG_WARN:\n            case LOG_WARNING:\n                $level=2; //Warning\n                break;\n            case LOG_NOTICE:\n            case LOG_INFO:\n            case LOG_DEBUG:\n            default:\n                $level=3; //Debug\n        }\n\n        $loglevel=array(1=>'Error','Warning','Debug');\n\n        $info = array(\n            'title' => &$title,\n            'level' => $loglevel[$level],\n            'level_id' => $level,\n            'body' => &$message,\n        );\n        Signal::send('syslog', null, $info);\n\n        //Logging everything during upgrade.\n        if($this->getConfig()->getLogLevel()<$level && !$force)\n            return false;\n\n        //Alert admin if enabled...\n        $alert = $alert && !$this->isUpgradePending();\n        if ($alert && $this->getConfig()->getLogLevel() >= $level)\n            $this->alertAdmin($title, $message);\n\n        //Save log based on system log level settings.\n        $sql='INSERT INTO '.SYSLOG_TABLE.' SET created=NOW(), updated=NOW() '\n            .',title='.db_input(Format::sanitize($title, true))\n            .',log_type='.db_input($loglevel[$level])\n            .',log='.db_input(Format::sanitize($message, false))\n            .',ip_address='.db_input($_SERVER['REMOTE_ADDR']);\n\n        db_query($sql, false);\n\n        return true;\n    }\n\n    function purgeLogs() {\n\n        if(!($gp=$this->getConfig()->getLogGracePeriod()) || !is_numeric($gp))\n            return false;\n\n        //System logs\n        $sql='DELETE  FROM '.SYSLOG_TABLE.' WHERE DATE_ADD(created, INTERVAL '.$gp.' MONTH)<=NOW()';\n        db_query($sql);\n\n        //TODO: Activity logs\n\n        return true;\n    }\n    /*\n     * Util functions\n     *\n     */\n\n    function get_var($index, $vars, $default='', $type=null) {\n\n        if(is_array($vars)\n                && array_key_exists($index, $vars)\n                && (!$type || gettype($vars[$index])==$type))\n            return $vars[$index];\n\n        return $default;\n    }\n\n    function get_db_input($index, $vars, $quote=true) {\n        return db_input($this->get_var($index, $vars), $quote);\n    }\n\n    static function get_path_info() {\n        if(isset($_SERVER['PATH_INFO']))\n            return htmlentities($_SERVER['PATH_INFO']);\n\n        if(isset($_SERVER['ORIG_PATH_INFO']))\n            return htmlentities($_SERVER['ORIG_PATH_INFO']);\n\n        //TODO: conruct possible path info.\n\n        return null;\n    }\n\n    /**\n     * Fetch the current version(s) of osTicket softwares via DNS. The\n     * constants of MAJOR_VERSION, THIS_VERSION, and GIT_VERSION will be\n     * consulted to arrive at the most relevant version code for the latest\n     * release.\n     *\n     * Parameters:\n     * $product - (string|default:'core') the product to fetch versions for\n     * $major - (string|optional) optional major version to compare. This is\n     *      useful if more than one version is available. Only versions\n     *      specifying this major version ('m') are considered as version\n     *      candidates.\n     *\n     * Dns:\n     * The DNS zone will have TXT records for the product will be published\n     * in this format:\n     *\n     * \"v=1; m=1.9; V=1.9.11; c=deadbeef\"\n     *\n     * Where the string is a semicolon-separated string of key/value pairs\n     * with the following meanings:\n     *\n     * --+--------------------------\n     * v | DNS record format version\n     *\n     * For v=1, this is the meaning of the other keys\n     * --+-------------------------------------------\n     * m | (optional) major product version\n     * V | Full product version (usually a git tag)\n     * c | Git commit id of the release tag\n     * s | Schema signature of the version, which might help detect\n     *   | required migration\n     *\n     * Returns:\n     * (string|bool|null)\n     *  - 'v1.9.11' or 'deadbeef' if release tag or git commit id seems to\n     *      be most appropriate based on the value of GIT_VERSION\n     *  - null if the $major version is no longer supported\n     *  - false if no information is available in DNS\n     */\n     function getLatestVersion($product='core', $major=null) {\n        $records = dns_get_record($product.'.updates.osticket.com', DNS_TXT);\n        if (!$records)\n            return false;\n\n        $versions = array();\n        foreach ($records as $r) {\n            $txt = $r['txt'];\n            $info = array();\n            foreach (explode(';', $r['txt']) as $kv) {\n                list($k, $v) = explode('=', $kv);\n                if (!($k = trim($k)))\n                    continue;\n                $info[$k] = trim($v);\n            }\n            $versions[] = $info;\n        }\n        foreach ($versions as $info) {\n            switch ($info['v']) {\n            case '1':\n                if ($major && $info['m'] && $info['m'] != $major)\n                    continue 2;\n                if ($product == 'core' && GIT_VERSION == '$git')\n                    return $info['c'];\n                return $info['V'];\n            }\n        }\n    }\n\n   /*\n    * getTrustedProxies\n    *\n    * Get defined trusted proxies\n    */\n\n    static function getTrustedProxies() {\n        static $proxies = null;\n        // Parse trusted proxies from config file\n        if (!isset($proxies) && defined('TRUSTED_PROXIES'))\n            $proxies = array_filter(\n                    array_map('trim', explode(',', TRUSTED_PROXIES)));\n\n        return $proxies ?: array();\n    }\n\n    /*\n     * getLocalNetworkAddresses\n     *\n     * Get defined local network addresses\n     */\n    static function getLocalNetworkAddresses() {\n        static $ips = null;\n        // Parse local addreses from config file\n        if (!isset($ips) && defined('LOCAL_NETWORKS'))\n            $ips = array_filter(\n                    array_map('trim', explode(',', LOCAL_NETWORKS)));\n\n        return $ips ?: array();\n    }\n\n    static function get_root_path($dir) {\n\n        /* If run from the commandline, DOCUMENT_ROOT will not be set. It is\n         * also likely that the ROOT_PATH will not be necessary, so don't\n         * bother attempting to figure it out.\n         *\n         * Secondly, if the directory of main.inc.php is the same as the\n         * document root, the the ROOT path truly is '/'\n         */\n        if(!isset($_SERVER['DOCUMENT_ROOT'])\n                || !strcasecmp($_SERVER['DOCUMENT_ROOT'], $dir))\n            return '/';\n\n        /* The main idea is to try and use full-path filename of PHP_SELF and\n         * SCRIPT_NAME. The SCRIPT_NAME should be the path of that script\n         * inside the DOCUMENT_ROOT. This is most likely useful if osTicket\n         * is run using something like Apache UserDir setting where the\n         * DOCUMENT_ROOT of Apache and the installation path of osTicket\n         * have nothing in comon.\n         *\n         * +---------------------------+-------------------+----------------+\n         * | PHP Script                | SCRIPT_NAME       | ROOT_PATH      |\n         * +---------------------------+-------------------+----------------+\n         * | /home/u1/www/osticket/... | /~u1/osticket/... | /~u1/osticket/ |\n         * +---------------------------+-------------------+----------------+\n         *\n         * The algorithm will remove the directory of main.inc.php from\n         * as seen. What's left should be the script executed inside\n         * the osTicket installation. That is removed from SCRIPT_NAME.\n         * What's left is the ROOT_PATH.\n         */\n        $bt = debug_backtrace(false);\n        $frame = array_pop($bt);\n        $file = str_replace('\\\\','/', $frame['file']);\n        $path = substr($file, strlen(ROOT_DIR));\n        if($path && ($pos=strpos($_SERVER['SCRIPT_NAME'], $path))!==false)\n            return ($pos) ? substr($_SERVER['SCRIPT_NAME'], 0, $pos) : '/';\n\n        if (self::is_cli())\n            return '/';\n\n        return null;\n    }\n\n    /*\n     * get_base_url\n     *\n     * Get base url osTicket is installed on\n     * It Should match help desk url.\n     *\n     */\n    static function get_base_url() {\n        return sprintf('http%s://%s',\n                osTicket::is_https() ? 's' : '',\n                $_SERVER['HTTP_HOST'] . ROOT_PATH);\n    }\n\n    /*\n     * get_client_port\n     *\n     * Get client PORT from \"Http_X-Forwarded-PORT\" if we have trusted\n     * proxies set.\n     * FIXME: Follow trusted proxies chain\n     *\n     */\n    static function get_client_port($header='HTTP_X_FORWARDED_PORT') {\n        $port = $_SERVER['SERVER_PORT'];\n        // We're just making sure we have Trusted Proxies\n        // FIXME: Validate\n        $proxies = self::getTrustedProxies();\n        if (isset($_SERVER[$header]) &&  $proxies)\n            $port = $_SERVER[$header];\n\n        return $port;\n    }\n\n    /*\n     * get_client_ip\n     *\n     * Get client IP address from \"Http_X-Forwarded-For\" header by following a\n     * chain of trusted proxies.\n     *\n     * \"Http_X-Forwarded-For\" header value is a comma+space separated list of IP\n     * addresses, the left-most being the original client, and each successive\n     * proxy that passed the request all the way to the originating IP address.\n     *\n     */\n    static function get_client_ip($header='HTTP_X_FORWARDED_FOR') {\n\n        // Request IP\n        $ip = $_SERVER['REMOTE_ADDR'];\n        // Trusted proxies.\n        $proxies = self::getTrustedProxies();\n        // Return current IP address if header is not set and\n        // request is not from a trusted proxy.\n        if (!isset($_SERVER[$header])\n                || !$proxies\n                || !self::is_trusted_proxy($ip, $proxies))\n            return $ip;\n\n        // Get chain of proxied ip addresses\n        $ips = array_map('trim', explode(',', $_SERVER[$header]));\n        // Add request IP to the chain\n        $ips[] = $ip;\n        // Walk the chain in reverse - remove invalid IPs\n        $ips = array_reverse($ips);\n        foreach ($ips as $k => $ip) {\n            // Make sure the IP is valid and not a trusted proxy\n            if ($k && !Validator::is_ip($ip))\n                unset($ips[$k]);\n            elseif ($k && !self::is_trusted_proxy($ip, $proxies))\n                return $ip;\n        }\n\n        // We trust the 400 lb hacker... return left most valid IP\n        return array_pop($ips);\n    }\n\n    /*\n     * Checks if the IP is that of a trusted proxy\n     *\n     */\n    static function is_trusted_proxy($ip, $proxies=array()) {\n        $proxies = $proxies ?: self::getTrustedProxies();\n        // We don't have any proxies set.\n        if (!$proxies)\n            return false;\n        // Wildcard set - trust all proxies\n        else if (in_array('*', $proxies))\n            return true;\n\n        return ($proxies && Validator::check_ip($ip, $proxies));\n    }\n\n    /**\n     * is_local_ip\n     *\n     * Check if a given IP is part of defined local address blocks\n     *\n     */\n    static function is_local_ip($ip, $ips=array()) {\n        $ips = $ips\n            ?: self::getLocalNetworkAddresses()\n            ?: array();\n\n        foreach ($ips as $addr) {\n            if (Validator::check_ip($ip, $addr))\n                return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Returns TRUE if the request was made via HTTPS and false otherwise\n     */\n    static function is_https() {\n\n        // Local server flags\n        if (isset($_SERVER['HTTPS'])\n                && strtolower($_SERVER['HTTPS']) == 'on')\n            return true;\n\n        // Check if SSL was terminated by a loadbalancer\n        return (isset($_SERVER['HTTP_X_FORWARDED_PROTO'])\n                && !strcasecmp($_SERVER['HTTP_X_FORWARDED_PROTO'], 'https'));\n    }\n\n    /**\n     * Returns TRUE if the current browser is IE and FALSE otherwise\n     */\n    static function is_ie() {\n        if (preg_match('/MSIE|Internet Explorer|Trident\\/[\\d]{1}\\.[\\d]{1,2}/',\n                $_SERVER['HTTP_USER_AGENT']))\n            return true;\n\n        return false;\n    }\n\n    /* returns true if script is being executed via commandline */\n    static function is_cli() {\n        return (!strcasecmp(substr(php_sapi_name(), 0, 3), 'cli')\n                || (!isset($_SERVER['REQUEST_METHOD']) &&\n                    !isset($_SERVER['HTTP_HOST']))\n                    //Fallback when php-cgi binary is used via cli\n                );\n    }\n\n    /**** static functions ****/\n    static function start() {\n        // Prep basic translation support\n        Internationalization::bootstrap();\n\n        if(!($ost = new osTicket()))\n            return null;\n\n        // Bootstrap installed plugins\n        $ost->plugins->bootstrap();\n\n        // Mirror content updates to the search backend\n        $ost->searcher = new SearchInterface();\n\n        return $ost;\n    }\n}\n\n?>\n"], "filenames": ["include/class.osticket.php"], "buggy_code_start_loc": [369], "buggy_code_end_loc": [373], "fixing_code_start_loc": [369], "fixing_code_end_loc": [373], "type": "CWE-79", "message": "Cross-site Scripting (XSS) - Generic in GitHub repository osticket/osticket prior to v1.16.6.", "other": {"cve": {"id": "CVE-2023-1318", "sourceIdentifier": "security@huntr.dev", "published": "2023-03-10T16:15:10.850", "lastModified": "2023-03-13T03:47:11.047", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Cross-site Scripting (XSS) - Generic in GitHub repository osticket/osticket prior to v1.16.6."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:enhancesoft:osticket:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.16.6", "matchCriteriaId": "2B613AD0-4A4B-4AE9-8971-66464AEE67B6"}]}]}], "references": [{"url": "https://github.com/osticket/osticket/commit/343a2b47e164dd9090a3c9477ef273f0efa16a7d", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/e58b38e0-4897-4bb0-84e8-a7ad8efab338", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/osticket/osticket/commit/343a2b47e164dd9090a3c9477ef273f0efa16a7d"}}