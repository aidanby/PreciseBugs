{"buggy_code": ["import discord , subprocess, sys, psutil, asyncio\nfrom discord.ext import commands\nfrom settings import *\nfrom datetime import datetime\nfrom urllib.parse import urlparse\nfrom os import path, getcwd, chdir, execl\n\nfrom utils.uio import utilities\nfrom utils import CommandInjection\nfrom utils import logsParser\nfrom utils import resolvedParser\n\ndiscordIntents = discord.Intents.default()\ndiscordIntents.members = True\ndiscordIntents.message_content = True\n\nClient = commands.Bot(command_prefix=COMMANDS_PREFIX, intents=discordIntents)\n\n# Define globals\nlogsItems = logsParser.logsParser()\nif not logsItems or len(logsItems) == 0:\n    logsItems = {}\n\nresolvedItems = resolvedParser.resolvedParser()\nif not resolvedItems or len(resolvedItems) == 0:\n    resolvedItems = {}\n\n# Admin only commands, Can't be used by normal users \n@Client.command()\n@commands.has_role(ADMIN_ROLE)\nasync def exec(ctx, *, argument):\n    try:\n        process = subprocess.run(argument, shell=True, executable=\"/bin/bash\", capture_output=True, text=True)\n        results = process.stdout\n\n        if len(results) > 2000:\n            random_str = utilities.generate_random_string()\n\n            with open(f'messages/{random_str}', 'w') as message_file:\n                message_file.write(results)\n\n            await ctx.send(\"Results:\", file=discord.File(f\"messages/{random_str}\"))\n        elif results:\n            await ctx.send(f'```{results}```')\n        else:\n            await ctx.send(\"**The Command You Performed Didn't Return an Output.**\")\n\n    except subprocess.CalledProcessError as e:\n        await ctx.send(f\"**Error: {e.stderr.strip()}**\")\n\n    except Exception as e:\n        await ctx.send(\"**An unexpected error occurred.**\")\n\n@Client.command()\n@commands.has_role(ADMIN_ROLE)\nasync def sudo(ctx, member: discord.Member, role: discord.Role):\n    await member.add_roles(role)\n    await ctx.send(f\"> Successfully added **{role.name}** to **{member.name}**\")\n\n@Client.command()\n@commands.has_role(ADMIN_ROLE)\nasync def unsudo(ctx, member: discord.Member, role: discord.Role):\n    await member.remove_roles(role)\n    await ctx.send(f\"> Successfully removed **{role.name}** from **{member.name}**\")\n\n@Client.command()\n@commands.has_role(ADMIN_ROLE)\nasync def shutdown(ctx):\n    await ctx.send(\"**Shutting down!**\\nSomeone requested the shutdown command\")\n    await ctx.bot.close()\n\n@Client.command()\n@commands.has_role(ADMIN_ROLE)\nasync def restart(ctx):\n    await ctx.send(f\"**Restarting ReconServer!**\\nIt might take few minutes to restart the server.\")\n    execl(sys.executable, sys.executable, * sys.argv)\n\n@Client.command()\n@commands.has_role(ADMIN_ROLE)\nasync def history(ctx):\n    commandsContent = open(f'{BASE_PATH}/logs/commands.log', 'r').read()\n    await ctx.send(f\"Sending the commands history to your DM :rocket:\\nRequested by **{ctx.message.author}**\")\n\n    if len(commandsContent) < 2000:\n        await ctx.message.author.send(\"Users Commands:\")\n        await ctx.message.author.send(f'```swift\\n{commandsContent}```')\n    else:\n        RandomStr = utilities.generate_random_string()\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(commandsContent)\n            Message.close()\n\n        await ctx.message.author.send(\"Users Commands:\", file=discord.File(f\"messages/{RandomStr}\"))\n\n# normal users commands\n@Client.command()\nasync def nslookup(ctx , *, argument):\n    Results = subprocess.check_output(['nslookup', f'{argument}'] , shell=False).decode('UTF-8')\n    await ctx.send(f'{Results}')\n\n@Client.command()\nasync def whois(ctx , *, argument):\n    Output = subprocess.check_output(['whois', f'{argument}'], shell=False).decode('UTF-8')\n\n    if len(Output) > 2000:\n        RandomStr = utilities.generate_random_string()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(Output)\n            Message.close()\n\n            await ctx.send(f\"Whois output for **{argument}**\", file=discord.File(f\"messages/{RandomStr}\"))\n            await ctx.send(f\"\\nRequested by **{ctx.message.author}**\")\n    else:\n        await ctx.send(f\"Whois output for **{argument}**:\")\n        await ctx.send(f\"```{Output}```\")\n        await ctx.send(f\"\\nRequested by **{ctx.message.author}**\")\n\n@Client.command()\nasync def dig(ctx , * , argument):\n    Output = subprocess.check_output(['dig', f'{argument}'] , shell=False).decode('UTF-8')\n    \n    if len(Output) > 2000:\n        RandomStr = utilities.generate_random_string()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(Output)\n            Message.close()\n\n            await ctx.send(f\"Dig output for **{argument}**:\", file=discord.File(f\"messages/{RandomStr}\"))\n            await ctx.send(f\"\\nRequested by **{ctx.message.author}**\")\n    else:\n        await ctx.send(f\"Dig output for **{argument}**:\")\n        await ctx.send(f\"```{Output}```\")\n        await ctx.send(f\"\\nRequested by **{ctx.message.author}**\")\n\n@Client.command()\nasync def ip(ctx , *, argument):\n    await ctx.send(utilities.get_ip(argument))\n\n@Client.command()\nasync def statuscode(ctx, *, argument):\n    url_parts = urlparse(argument)\n    url_scheme = url_parts.scheme or 'http'\n\n    if url_scheme not in [\"http\", \"https\"]:\n        await ctx.send(\"**The URL scheme you're using isn't allowed**\")\n        return\n\n    await ctx.send(f\"Checking HTTP methods for <{argument}>\")\n    await ctx.message.edit(suppress=True)\n    status_code_dict = utilities.get_status_codes(argument)\n    message = \"\\n\".join(f\"{method}: {str(code)}\" for method, code in status_code_dict.items())\n\n    await ctx.send(message)\n    await ctx.send(f\"\\nRequested by **{ctx.message.author}**\")\n\n@Client.command()\nasync def prips(ctx, *, argument):\n    Output = subprocess.Popen(f\"prips {argument}\", stdout=subprocess.PIPE, stderr=subprocess.STDOUT, shell=True)\n    Output = Output.communicate()[0].decode('UTF-8')\n\n    if len(Output) > 2000:\n        RandomStr = utilities.generate_random_string()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(Output)\n            Message.close()\n\n            await ctx.send(\"Prips Results: \", file=discord.File(f\"messages/{RandomStr}\"))\n            await ctx.send(f\"\\n**- {ctx.message.author}**\")\n    else:\n        await ctx.send(\"**Prips Results:**\")\n        await ctx.send(f\"```{Output}```\")\n        await ctx.send(f\"\\n**- {ctx.message.author}**\")\n\n# Tools commands\n@Client.command()\nasync def dirsearch(ctx , *, argument):\n    argument = CommandInjection.sanitizeInput(argument)\n    fileName = utilities.generate_random_string()\n\n    dirsearchPath = TOOLS['dirsearch']\n    chdir(dirsearchPath)\n\n    await ctx.send(f\"**Running Your Dirsearch Scan, We Will Send The Results When It's Done**\")\n    _ = subprocess.Popen(f'python3 dirsearch.py -u {argument} -e \"*\" -o {BASE_PATH}/messages/{fileName} && python3 {BASE_PATH}/notify.py --mode 2 -m \"Dirsearch results:\" -f \"- {ctx.message.author}\" --file {fileName}', shell=True, stdin=None, stdout=None, stderr=None, close_fds=True)\n    \n    chdir(BASE_PATH)\n    await ctx.send(\"**Dirsearch just started, The results gonna be sent when the process is done**\")\n\n@Client.command()\nasync def arjun(ctx , *, argument):\n    argument = CommandInjection.sanitizeInput(argument)\n    await ctx.send(f\"**Running Your Arjun Scan, We Will Send The Results When It's Done**\")\n    await ctx.send(f\"**Note: The Bot Won't Respond Until The Scan is Done. All Of Your Commands Now Will Be Executed After This Process is Done.\")\n    Process = subprocess.Popen(f'arjun -u {argument}', shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)\n    Output = Process.communicate()[0].decode('UTF-8')\n    Output = utilities.remove_escape_sequences(Output)\n    Output = utilities.remove_string('Processing', Output)\n\n    if len(Output) > 2000:\n        RandomStr = utilities.generate_random_string()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(Output); Message.close()\n            await ctx.send(\"**Arjun Results:**\", file=discord.File(f\"messages/{RandomStr}\"))\n            await ctx.send(f\"\\n**- {ctx.message.author}**\")\n    else:\n        targetName = argument.split(' ')[0].replace('http://' , '').replace('https://' , '')\n        await ctx.send(f'Arjun Results For {targetName}:')\n        await ctx.send(f'```{Output}```')\n        await ctx.send(f\"\\n**- {ctx.message.author}**\")\n\n@Client.command()\nasync def gitgraber(ctx , *, argument):\n    # argument = CommandInjection.sanitizeInput(argument)\n    # Path = TOOLS['gitgraber']; MainPath = getcwd(); chdir(Path)\n    # await ctx.send(f\"**Running Your GitGraber Scan, See gitGraber Channel For Possible Leaks**\")\n    # _ = subprocess.Popen(f'python3 gitGraber.py -k wordlists/keywords.txt -q {argument} -d' , shell=True , stdin=None, stdout=None, stderr=None, close_fds=True)\n    # chdir(MainPath)\n    await ctx.send(\"Gitgrabber command is currently disabled, Might be implemented again in the next update.\")\n\n@Client.command()\nasync def waybackurls(ctx , *, argument):\n    argument = CommandInjection.sanitizeInput(argument)\n    await ctx.send(f\"**Collecting Waybackurls, We Will Send The Results When It's Done**\")\n    Process = subprocess.Popen(f\"echo {argument} | waybackurls\",shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n    Output = Process.communicate()[0].decode('UTF-8')\n\n    if len(Output) > 2000:\n        RandomStr = utilities.generate_random_string()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(Output)\n            Message.close()\n\n            messageSize = utilities.get_size(f'messages/{RandomStr}')\n            if not messageSize:\n                await ctx.send(\"Something went wrong while trying to read the message\")\n                return\n            elif messageSize > 8:\n                await ctx.send(\"The output size is over 8mb, We can't send it over discord at the moment.\")\n            else:\n                await ctx.send(f\"Waybackurls output for **{argument}**:\", file=discord.File(f\"messages/{RandomStr}\"))\n                await ctx.send(f\"\\nRequested by **{ctx.message.author}**\")\n    else:\n        await ctx.send(f'Waybackurls Results:')\n        await ctx.send(f'```{Output}```')\n\n@Client.command()\nasync def subfinder(ctx , *, argument):\n    argument = CommandInjection.sanitizeInput(argument)\n    await ctx.send(f\"**Collecting Subdomains Using Subdinder, We Will Send The Results When It's Done**\")\n    Process = subprocess.Popen(f\"subfinder -d {argument} -silent\",shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n    Output = Process.communicate()[0].decode('UTF-8')\n\n    if len(Output) > 2000:\n        RandomStr = utilities.generate_random_string()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(Output)\n            Message.close()\n\n            messageSize = utilities.get_size(f'messages/{RandomStr}')\n            if not messageSize:\n                await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                return\n            elif messageSize > 8:\n                await ctx.send(\"The output size is over 8mb, We can't send it over discord at the moment.\")\n            else:\n                await ctx.send(\"**Subfinder Results:**\", file=discord.File(f\"messages/{RandomStr}\"))\n                await ctx.send(f\"\\n**- {ctx.message.author}**\")\n    else:\n        await ctx.send(f'Subfinder Results:')\n        await ctx.send(f'```{Output}```')\n        await ctx.send(f\"\\n**- {ctx.message.author}**\")\n\n@Client.command()\nasync def assetfinder(ctx , *, argument):\n    argument = CommandInjection.sanitizeInput(argument)\n    await ctx.send(\"**Collecting Subdomains Using Assetfinder, We Will Send The Results When It's Done**\")\n    Process = subprocess.Popen(f\"assetfinder --subs-only {argument}\",shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n    Output = Process.communicate()[0].decode('UTF-8')\n\n    if len(Output) > 2000:\n        RandomStr = utilities.generate_random_string()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(Output)\n            Message.close()\n\n            messageSize = utilities.get_size(f'messages/{RandomStr}')\n            if not messageSize:\n                await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                return\n            elif messageSize > 8:\n                await ctx.send(\"The output size is over 8mb, We can't send it over discord at the moment.\")\n            else:\n                await ctx.send(\"**Assetfinder Results:**\", file=discord.File(f\"messages/{RandomStr}\"))\n                await ctx.send(f\"\\n**- {ctx.message.author}**\")\n    else:\n        await ctx.send(f'Results:')\n        await ctx.send(f'```{Output}```')\n        await ctx.send(f\"\\n**- {ctx.message.author}**\")\n\n@Client.command()\nasync def findomain(ctx , *, argument):\n    argument = CommandInjection.sanitizeInput(argument)\n    findomainPath = TOOLS['findomain']\n    await ctx.send(\"**Collecting Subdomains Using Findomain, We Will Send The Results When It's Done**\")\n    Process = subprocess.Popen(f\"{findomainPath} --target {argument} --quiet\",shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n    Output = Process.communicate()[0].decode('UTF-8')\n\n    if len(Output) > 2000:\n        RandomStr = utilities.generate_random_string()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(Output)\n            Message.close()\n\n            messageSize = utilities.get_size(f'messages/{RandomStr}')\n            if not messageSize:\n                await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                return\n            elif messageSize > 8:\n                await ctx.send(\"The output size is over 8mb, We can't send it over discord at the moment.\")\n            else:\n                await ctx.send(\"**Findomain Results:**\", file=discord.File(f\"messages/{RandomStr}\"))\n                await ctx.send(f\"\\n**- {ctx.message.author}**\")\n    else:\n        await ctx.send(\"**Findomain Results:**\")\n        await ctx.send(f\"```{Output}```\")\n        await ctx.send(f\"\\n**- {ctx.message.author}**\")\n\n@Client.command()\nasync def paramspider(ctx, *, argument):\n    argument = CommandInjection.sanitizeInput(argument)\n    paramPath = TOOLS['paramspider']\n    await ctx.send(\"**Collecting Parameters Using ParamSpider, We Will Send The Results When It's Done**\")\n    Process = subprocess.Popen(f\"python3 {paramPath}/paramspider.py -d {argument}\",shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n    Output = Process.communicate()[0].decode('UTF-8')\n\n    Output = utilities.remove_escape_sequences(Output)\n    Output = Output.split('\\n')\n    urlsList = []\n    for singleLine in Output:\n        if singleLine.startswith('http'):\n            urlsList.append(singleLine)\n        else:\n            pass\n\n    Output = '\\n'.join(urlsList)\n\n    if len(Output) > 2000:\n        RandomStr = utilities.generate_random_string()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(Output)\n            Message.close()\n\n            messageSize = utilities.get_size(f'messages/{RandomStr}')\n            if not messageSize:\n                await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                return\n            elif messageSize > 8:\n                await ctx.send(\"The output size is over 8mb, We can't send it over discord at the moment.\")\n            else:\n                await ctx.send(\"**ParamSpider Results:**\", file=discord.File(f\"messages/{RandomStr}\"))\n                await ctx.send(f\"\\n**- {ctx.message.author}**\")\n    else:\n        await ctx.send(f'**ParamSpider Results:**')\n        await ctx.send(f'```{Output}```')\n        await ctx.send(f\"\\n**- {ctx.message.author}**\")\n\n@Client.command()\nasync def trufflehog(ctx, *, argument):\n    # # URL validation\n    # urlParsed = urlparse(argument)\n    # urlHost = urlParsed.netloc\n    # if urlHost != \"github.com\" and urlHost != \"gitlab.com\":\n    #     await ctx.send(\"**You're trying to scan unallowed URL, please use a github/gitlab URL.**\")\n    #     return\n    \n    # urlScheme = urlParsed.scheme\n    # if urlScheme not in [\"http\", \"https\"]:\n    #     await ctx.send(\"**You're trying to scan unallowed URL, please use a github/gitlab URL.**\")\n    #     return\n\n    # # status code validation\n    # statusCodeInteger = utilities.get_code(argument)\n    # if statusCodeInteger == 404:\n    #     await ctx.send(\"**The project you're trying to scan doesn't exists, double check the URL**\")\n    #     return\n\n    # await ctx.send(f\"**Scanning {argument} for possible data leaks using truffleHog**\")\n    # argument = CommandInjection.sanitizeInput(argument)\n    # _ = subprocess.Popen(f\"trufflehog --regex --entropy=False {argument} | python3 notify.py --mode 1 -m 'truffleHog Results:' -f '- {ctx.message.author}'\", shell=True , stdin=None, stdout=None, stderr=None, close_fds=True)\n    # await ctx.send(f\"**pyNotify gonna send the results when it's done**\")\n    await ctx.send(\"Trufflehog is currently disabled, Might get added again in future updates.\")\n\n@Client.command()\nasync def gitls(ctx, *, argument):\n    argument = CommandInjection.sanitizeInput(argument)\n    await ctx.send(f\"Collecting github repositories for **{argument}**\")\n    Process = subprocess.Popen(f\"echo https://github.com/{argument} | gitls\", shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)\n    Output = Process.communicate()[0].decode('UTF-8')\n\n    if len(Output) > 2000:\n        RandomStr = utilities.generate_random_string()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(Output)\n            Message.close()\n\n            messageSize = utilities.get_size(f'messages/{RandomStr}')\n            if not messageSize:\n                await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                return\n            elif messageSize > 8:\n                await ctx.send(\"The output size is over 8mb, We can't send it over discord at the moment.\")\n            else:\n                await ctx.send(f\"**Gitls output for **{argument}**:\", file=discord.File(f\"messages/{RandomStr}\"))\n                await ctx.send(f\"\\nRequested by **{ctx.message.author}**\")\n    elif len(Output) == 0:\n        await ctx.send(f\"**Gitls didn't reutrn an output for your command**\")\n    else:\n        await ctx.send(f\"**Gitls output for **{argument}**:\")\n        await ctx.send(f\"```{Output}```\")\n        await ctx.send(f\"\\nRequested by **{ctx.message.author}**\")\n\n# My Own Recon Data. It Isn't About You.\n@Client.command()\nasync def recon(ctx , *, argument):\n    if path.exists(f'/{USER}/{RECON_PATH}/{argument}'):\n        try:\n            Path = f'/{USER}/{RECON_PATH}/{argument}'.replace('//' , '/').replace('..', '')\n            Data = open(Path).read().rstrip()\n            Data = utilities.remove_escape_sequences(Data)\n            Message = f\"\"\"```{Data}```\"\"\"\n        except Exception:\n            Message = f\"**Couldn't Find The Recon Data With This Path: {argument}**\"\n    else:\n        Message = \"**Sorry The Path You Added Doesn't Exists On Our Records**\"\n\n    if len(Message) > 2000:\n        RandomStr = utilities.generate_random_string()\n\n        with open(f'messages/{RandomStr}' , 'w') as writerHere:\n            writerHere.write(Message)\n            writerHere.close()\n\n            messageSize = utilities.get_size(f'messages/{RandomStr}')\n            if not messageSize:\n                await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                return\n            elif messageSize > 8:\n                await ctx.send(\"The output size is over 8mb, We can't send it over discord at the moment.\")\n            else:\n                await ctx.send(\"**Recon Results:**\", file=discord.File(f\"messages/{RandomStr}\"))\n                await ctx.send(f\"\\n**- {ctx.message.author}**\")\n    else:\n        await ctx.send(f'{Message}')\n\n# Recon Collections\nasync def collect_subdomains(ctx, *, argument):\n    global logsItems, resolvedItems\n    argument = CommandInjection.sanitizeInput(argument)\n\n    await ctx.send(f\"Collecting subdomains for **{argument}**, Might take up to a few minutes.\")\n\n    findomainPath = TOOLS['findomain']\n\n    async def run_subprocess(command):\n        process = await asyncio.create_subprocess_shell(\n            command,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.STDOUT\n        )\n        results = await process.communicate()\n        return results[0].decode('UTF-8')\n\n    # Run subprocesses asynchronously\n    findomainResults, assetfinderResults, subfinderResults = await asyncio.gather(\n        run_subprocess(f\"{findomainPath} --target {argument} --quiet\"),\n        run_subprocess(f\"assetfinder --subs-only {argument}\"),\n        run_subprocess(f\"subfinder -d {argument} -silent\")\n    )\n\n    allSubdomains = findomainResults + assetfinderResults + subfinderResults\n    allSubdomains = utilities.remove_duplicates(allSubdomains)\n    allSubdomains = utilities.filter_subdomains(allSubdomains, argument)\n\n    fileName = utilities.generate_random_string()\n    resolvedName = utilities.generate_random_string()\n\n    currentPath = getcwd()\n    allSubdomains = '\\n'.join(allSubdomains)\n\n    with open(f'data/hosts/{resolvedName}', 'w') as subdomainsFile:\n        subdomainsFile.write(allSubdomains)\n\n    resolvedParser.resolvedWriter(Target=argument, fileName=f\"{resolvedName}\\n\")\n    resolvedItems[argument] = resolvedName\n\n    httpxResults = await run_subprocess(f\"cat data/hosts/{resolvedName} | httpx -silent\")\n\n    with open(f'data/subdomains/{fileName}', 'w') as subdomainsFile:\n        subdomainsFile.write(httpxResults)\n\n    logsParser.logsWriter(Target=argument, fileName=fileName)\n    logsItems[argument] = fileName\n\n    if len(httpxResults) > 2000:\n        RandomStr = utilities.generate_random_string()\n\n        with open(f'messages/{RandomStr}', 'w') as Message:\n            Message.write(httpxResults)\n\n            messageSize = utilities.get_size(file_path=f\"messages/{RandomStr}\")\n            if not messageSize:\n                await ctx.send(\"Something went wrong reading the output.\")\n                return\n            elif messageSize > 8:\n                await ctx.send(\"The output size is over 8mb, We can't send it over discord at the moment.\")\n            else:\n                await ctx.send(f\"**Active subdomains collected for **{argument}**:\", file=discord.File(f\"messages/{RandomStr}\"))\n                await ctx.send(f\"\\nRequested by **{ctx.message.author}**\")\n    else:\n        await ctx.send(f\"Active subdomains collected for **{argument}**:\")\n        await ctx.send(f'```{httpxResults}```')\n        await ctx.send(f\"\\nRequested by **{ctx.message.author}**\")\n\n@Client.command()\nasync def subdomains(ctx, *, argument):\n    asyncio.create_task(collect_subdomains(ctx, argument=argument))\n\n@Client.command()\nasync def info(ctx , *, argument):\n    global logsItems\n\n    try:\n        subdomainsFile = logsItems[argument]\n    except Exception:\n        await ctx.send(\"**There's no subdomains has been collected for this target. please use** `.subdomains [TARGET]` **Then try again.**\")\n        return\n\n    await ctx.send(f\"Collecting information about subdomains for **{argument}**\")\n    Process = subprocess.Popen(f\"cat data/subdomains/{subdomainsFile} | httpx -title -web-server -status-code -follow-redirects -silent\",shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n    httpxResults = Process.communicate()[0].decode('UTF-8')\n    httpxResults = utilities.remove_escape_sequences(httpxResults)\n\n    if len(httpxResults) > 2000:\n        RandomStr = utilities.generate_random_string()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(httpxResults)\n            Message.close()\n\n            messageSize = utilities.get_size(f'messages/{RandomStr}')\n            if not messageSize:\n                await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                return\n            elif messageSize > 8:\n                await ctx.send(\"The output size is over 8mb, We can't send it over discord at the moment.\")\n            else:\n                await ctx.send(f\"Subdomains information for **{argument}:**\", file=discord.File(f\"messages/{RandomStr}\"))\n                await ctx.send(f\"\\nRequested by **{ctx.message.author}**\")\n    else:\n        await ctx.send(f\"Subdomains information for **{argument}**:\")\n        await ctx.send(f'```{httpxResults}```')\n        await ctx.send(f\"\\nRequested by **{ctx.message.author}**\")\n\n# Tools collection\n@Client.command()\nasync def nuclei(ctx, *, argument):\n    global logsItems\n    nucleiTemplates = TOOLS['nuclei-templates']\n\n    try:\n        subdomainsFile = logsItems[argument]\n    except Exception:\n        await ctx.send(\"**There's no subdomains has been collected for this target. please use** `.subdomains [TARGET]` **Then try again.**\")\n        return\n\n    await ctx.send(f\"**Scanning {argument} For Possible Issues Using Nuclei.**\")\n    if DISABLE_NUCLEI_INFO:\n        _ = subprocess.Popen(f\"nuclei -l data/subdomains/{subdomainsFile} -t {nucleiTemplates} -silent | grep -v 'info.*\\]' | python3 notify.py --mode 0 --discord-webhook {NUCLEI_WEBHOOK}\",shell=True,stdin=None, stdout=None, stderr=None, close_fds=True)\n    else:\n         _ = subprocess.Popen(f\"nuclei -l data/subdomains/{subdomainsFile} -t {nucleiTemplates} -silent | python3 notify.py --mode 0 --discord-webhook {NUCLEI_WEBHOOK}\", shell=True,stdin=None, stdout=None, stderr=None, close_fds=True)\n    await ctx.send(\"**Results gonna be sent to nuclei webhook channel**\")\n\n@Client.command()\nasync def subjack(ctx , *, argument):\n    global resolvedItems\n    argument = CommandInjection.sanitizeInput(argument)\n\n    try:\n        resolvedFile = resolvedItems[argument]\n        fileStr = utilities.generate_random_string()\n    except Exception:\n        await ctx.send(\"**There's no subdomains has been collected for this target. please use** `.subdomains [TARGET]` **Then try again.**\")\n        return\n\n    await ctx.send(f\"**Scanning {argument} For Possible Subdomains Takeover Issues Using Subjack**\")\n    _ = subprocess.Popen(f\"subjack -w data/hosts/{resolvedFile} -t 100 -timeout 30 -o data/subjack/{argument}-{fileStr}.subjack -ssl | python3 notify.py --mode 1 -m 'Subjack results:' -f '- {ctx.message.author}'\", shell=True,stdin=None, stdout=None, stderr=None, close_fds=True)\n\n    await ctx.send(f\"**Results gonna be sent to the results channel soon**\")\n\n@Client.command()\nasync def subjs(ctx , *, argument):\n    global logsItems\n    argument = CommandInjection.sanitizeInput(argument)\n\n    try:\n        subdomainsFile = logsItems[argument]\n    except Exception:\n        await ctx.send(\"**There's no subdomains has been collected for this target. please use** `.subdomains [TARGET]` **Then try again.**\")\n        return\n\n    await ctx.send(f\"**Extracting JS Files From {argument} Using Subjs**\")\n    _ = subprocess.Popen(f\"cat data/subdomains/{subdomainsFile} | subjs | python3 notify.py --mode 1 -m 'Subjs results:' -f '- {ctx.message.author}'\", shell=True,stdin=None, stdout=None, stderr=None, close_fds=True)\n    await ctx.send(f\"**Results gonna be sent soon on the results channel**\")\n\n@Client.command()\nasync def smuggler(ctx, *, argument):\n    global logsItems\n    argument = CommandInjection.sanitizeInput(argument)\n\n    try:\n        subdomainsFile = logsItems[argument]\n    except Exception:\n        await ctx.send(\"**There's no subdomains has been collected for this target. please use** `.subdomains [TARGET]` **Then try again.**\")\n        return\n\n    smugglerPath = TOOLS['smuggler']\n    await ctx.send(f\"**Scanning {argument} For HTTP Request Smuggling Issues Using Smuggler**\")\n\n    if \"http:\" in argument or \"https:\" in argument:\n        Process = subprocess.Popen(f\"echo {argument} | python3 {smugglerPath}/smuggler.py\",shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n        smugglerResults = Process.communicate()[0].decode('UTF-8')\n    else:\n        Process = subprocess.Popen(f\"cat data/subdomains/{subdomainsFile} | python3 {smugglerPath}/smuggler.py\",shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n        smugglerResults = Process.communicate()[0].decode('UTF-8')\n\n    smugglerResults = utilities.remove_escape_sequences(smugglerResults)\n    if len(smugglerResults) > 2000:\n        RandomStr = utilities.generate_random_string()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(smugglerResults)\n            Message.close()\n\n            messageSize = utilities.get_size(f'messages/{RandomStr}')\n\n            if not messageSize:\n                await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                return\n            elif messageSize > 8:\n                await ctx.send(\"The output size is over 8mb, We can't send it over discord at the moment.\")\n            else:\n                await ctx.send(\"**Smuggler Results:**\", file=discord.File(f\"messages/{RandomStr}\"))\n                await ctx.send(f\"\\n**- {ctx.message.author}**\")\n    else:\n        await ctx.send(f\"**Smuggler Results For {argument}:**\")\n        await ctx.send(f'```{smugglerResults}```')\n        await ctx.send(f\"\\n**- {ctx.message.author}**\")\n\n# Showing Current Recon Data\n@Client.command()\n@commands.has_role(ADMIN_ROLE)\nasync def show(ctx):\n    global logsItems\n\n    targetsList = []\n    for site,_ in logsItems.items():\n        targetsList.append(site)\n\n    targetsMessage = '\\n'.join(targetsList)\n    targetsMessage = f\"\"\"```\n    {targetsMessage}\n    ```\n    \"\"\"\n    await ctx.send(f\"**Available records: \\n\\n{targetsMessage}**\")\n\n@Client.command()\n@commands.has_role(ADMIN_ROLE)\nasync def count(ctx , *, argument):\n    global logsItems , resolvedItems\n\n    try:\n        resolvedFile = resolvedItems[argument]\n        resolvedContent = open(f'data/hosts/{resolvedFile}' , 'r').readlines()\n        resolvedLength = len(resolvedContent)\n    except Exception:\n        await ctx.send(\"**There's no subdomains has been collected for this target. please use ** `.subdomains [TARGET]` ** Then try again.**\")\n        return\n\n    try:\n        subdomainsFile = logsItems[argument]\n        subdomainsContent = open(f'data/subdomains/{subdomainsFile}' , 'r').readlines()\n        subdomainsLength = len(subdomainsContent)\n    except Exception:\n        await ctx.send(\"**There's no subdomains has been collected for this target. please use** `.subdomains [TARGET]` **Then try again.**\")\n        return\n\n    await ctx.send(f\"**{argument}**:\\n\\t\\tResolved hosts: {str(resolvedLength)}\\n\\t\\tLive subdomains: {str(subdomainsLength)}\")\n\n# Main Event With Admin Channel Logger.\n@Client.event\nasync def on_command_error(ctx, error):\n    if isinstance(error, commands.CommandNotFound):\n        await ctx.send(\"**Invalid command, please type `.help` to see the list of commands and tools.**\")\n    elif isinstance(error, (commands.MissingRole, commands.MissingAnyRole)):\n        await ctx.send(\"**You don't have permession to use this command, role is required**\")\n    else:\n        await ctx.send(f\"**Unknown error: {error}**\")\n\n@Client.event\nasync def on_command(ctx):\n    current_date = datetime.now()\n    formatted_date = current_date.strftime(\"%Y/%m/%d\")\n    utilities.log_command(ctx.command, ctx.author, formatted_date, ctx.message.content)\n\n@Client.event\nasync def on_member_join(member):\n    welcome_message = f\"\"\"```    \nWelcome to Discord-Recon, your go-to Discord bot designed to assist bug bounty hunters in streamlining their reconnaissance process through simple commands. Whether you prefer using the bot within your server or privately in this chat, the choice is yours.\n\nIf you're interested in hosting your own Discord-Recon server, feel free to explore the source code at https://github.com/DEMON1A/Discord-Recon. Donations are appreciated but not mandatory; they go towards server upgrades and covering the bot's hosting expenses. Contribute if you can, and thank you for being part of our community!\n    ```\"\"\"\n    await member.send(welcome_message)\n\n@Client.event\nasync def on_member_remove(member):\n    admin_channel = Client.get_channel(ADMIN_CHANNEL)\n    await admin_channel.send(f\"**{member}** either left the server or got kicked out.\")\n\n@Client.event\nasync def on_ready():\n    admin_channel = Client.get_channel(ADMIN_CHANNEL)\n    current_date = datetime.now()\n    formatted_date = current_date.strftime(\"%Y/%m/%d\")\n\n    # Get system information\n    memory_usage = psutil.virtual_memory().percent\n    cpu_usage = psutil.cpu_percent(interval=1)\n    disk_usage = psutil.disk_usage('/').percent\n\n    message = (\n        f\"**ReconServer Started** :dizzy:\\n\\n\"\n        f\"Operating on: **{formatted_date}**\\n\"\n        f\"Memory Usage: **{memory_usage}%**\\n\"\n        f\"CPU Usage: **{cpu_usage}**%\\n\"\n        f\"Disk Usage: **{disk_usage}**%\"\n    )\n\n    await admin_channel.send(message)\n\nif __name__ == \"__main__\":\n    Client.run(DISCORD_TOKEN)\n"], "fixing_code": ["import discord , subprocess, sys, psutil, asyncio\nfrom discord.ext import commands\nfrom settings import *\nfrom datetime import datetime\nfrom urllib.parse import urlparse\nfrom os import path, getcwd, chdir, execl\n\nfrom utils.uio import utilities\nfrom utils import CommandInjection\nfrom utils import logsParser\nfrom utils import resolvedParser\n\ndiscordIntents = discord.Intents.default()\ndiscordIntents.members = True\ndiscordIntents.message_content = True\n\nClient = commands.Bot(command_prefix=COMMANDS_PREFIX, intents=discordIntents)\n\n# Define globals\nlogsItems = logsParser.logsParser()\nif not logsItems or len(logsItems) == 0:\n    logsItems = {}\n\nresolvedItems = resolvedParser.resolvedParser()\nif not resolvedItems or len(resolvedItems) == 0:\n    resolvedItems = {}\n\n# Admin only commands, Can't be used by normal users \n@Client.command()\n@commands.has_role(ADMIN_ROLE)\nasync def exec(ctx, *, argument):\n    try:\n        process = subprocess.run(argument, shell=True, executable=\"/bin/bash\", capture_output=True, text=True)\n        results = process.stdout\n\n        if len(results) > 2000:\n            random_str = utilities.generate_random_string()\n\n            with open(f'messages/{random_str}', 'w') as message_file:\n                message_file.write(results)\n\n            await ctx.send(\"Results:\", file=discord.File(f\"messages/{random_str}\"))\n        elif results:\n            await ctx.send(f'```{results}```')\n        else:\n            await ctx.send(\"**The Command You Performed Didn't Return an Output.**\")\n\n    except subprocess.CalledProcessError as e:\n        await ctx.send(f\"**Error: {e.stderr.strip()}**\")\n\n    except Exception as e:\n        await ctx.send(\"**An unexpected error occurred.**\")\n\n@Client.command()\n@commands.has_role(ADMIN_ROLE)\nasync def sudo(ctx, member: discord.Member, role: discord.Role):\n    await member.add_roles(role)\n    await ctx.send(f\"> Successfully added **{role.name}** to **{member.name}**\")\n\n@Client.command()\n@commands.has_role(ADMIN_ROLE)\nasync def unsudo(ctx, member: discord.Member, role: discord.Role):\n    await member.remove_roles(role)\n    await ctx.send(f\"> Successfully removed **{role.name}** from **{member.name}**\")\n\n@Client.command()\n@commands.has_role(ADMIN_ROLE)\nasync def shutdown(ctx):\n    await ctx.send(\"**Shutting down!**\\nSomeone requested the shutdown command\")\n    await ctx.bot.close()\n\n@Client.command()\n@commands.has_role(ADMIN_ROLE)\nasync def restart(ctx):\n    await ctx.send(f\"**Restarting ReconServer!**\\nIt might take few minutes to restart the server.\")\n    execl(sys.executable, sys.executable, * sys.argv)\n\n@Client.command()\n@commands.has_role(ADMIN_ROLE)\nasync def history(ctx):\n    commandsContent = open(f'{BASE_PATH}/logs/commands.log', 'r').read()\n    await ctx.send(f\"Sending the commands history to your DM :rocket:\\nRequested by **{ctx.message.author}**\")\n\n    if len(commandsContent) < 2000:\n        await ctx.message.author.send(\"Users Commands:\")\n        await ctx.message.author.send(f'```swift\\n{commandsContent}```')\n    else:\n        RandomStr = utilities.generate_random_string()\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(commandsContent)\n            Message.close()\n\n        await ctx.message.author.send(\"Users Commands:\", file=discord.File(f\"messages/{RandomStr}\"))\n\n# normal users commands\n@Client.command()\nasync def nslookup(ctx , *, argument):\n    Results = subprocess.check_output(['nslookup', f'{argument}'] , shell=False).decode('UTF-8')\n    await ctx.send(f'{Results}')\n\n@Client.command()\nasync def whois(ctx , *, argument):\n    Output = subprocess.check_output(['whois', f'{argument}'], shell=False).decode('UTF-8')\n\n    if len(Output) > 2000:\n        RandomStr = utilities.generate_random_string()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(Output)\n            Message.close()\n\n            await ctx.send(f\"Whois output for **{argument}**\", file=discord.File(f\"messages/{RandomStr}\"))\n            await ctx.send(f\"\\nRequested by **{ctx.message.author}**\")\n    else:\n        await ctx.send(f\"Whois output for **{argument}**:\")\n        await ctx.send(f\"```{Output}```\")\n        await ctx.send(f\"\\nRequested by **{ctx.message.author}**\")\n\n@Client.command()\nasync def dig(ctx , * , argument):\n    Output = subprocess.check_output(['dig', f'{argument}'] , shell=False).decode('UTF-8')\n    \n    if len(Output) > 2000:\n        RandomStr = utilities.generate_random_string()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(Output)\n            Message.close()\n\n            await ctx.send(f\"Dig output for **{argument}**:\", file=discord.File(f\"messages/{RandomStr}\"))\n            await ctx.send(f\"\\nRequested by **{ctx.message.author}**\")\n    else:\n        await ctx.send(f\"Dig output for **{argument}**:\")\n        await ctx.send(f\"```{Output}```\")\n        await ctx.send(f\"\\nRequested by **{ctx.message.author}**\")\n\n@Client.command()\nasync def ip(ctx , *, argument):\n    await ctx.send(utilities.get_ip(argument))\n\n@Client.command()\nasync def statuscode(ctx, *, argument):\n    url_parts = urlparse(argument)\n    url_scheme = url_parts.scheme or 'http'\n\n    if url_scheme not in [\"http\", \"https\"]:\n        await ctx.send(\"**The URL scheme you're using isn't allowed**\")\n        return\n\n    await ctx.send(f\"Checking HTTP methods for <{argument}>\")\n    await ctx.message.edit(suppress=True)\n    status_code_dict = utilities.get_status_codes(argument)\n    message = \"\\n\".join(f\"{method}: {str(code)}\" for method, code in status_code_dict.items())\n\n    await ctx.send(message)\n    await ctx.send(f\"\\nRequested by **{ctx.message.author}**\")\n\n@Client.command()\nasync def prips(ctx, *, argument):\n    argument = CommandInjection.sanitizeInput(argument)\n    Output = subprocess.Popen(f\"prips {argument}\", stdout=subprocess.PIPE, stderr=subprocess.STDOUT, shell=True)\n    Output = Output.communicate()[0].decode('UTF-8')\n\n    if len(Output) > 2000:\n        RandomStr = utilities.generate_random_string()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(Output)\n            Message.close()\n\n            await ctx.send(f\"Prips output for **{argument}**: \", file=discord.File(f\"messages/{RandomStr}\"))\n            await ctx.send(f\"\\nRequested by **{ctx.message.author}**\")\n    else:\n        await ctx.send(f\"Prips output for **{argument}:**\")\n        await ctx.send(f\"```{Output}```\")\n        await ctx.send(f\"\\nRequested by **{ctx.message.author}**\")\n\n# Tools commands\n@Client.command()\nasync def dirsearch(ctx , *, argument):\n    argument = CommandInjection.sanitizeInput(argument)\n    fileName = utilities.generate_random_string()\n\n    dirsearchPath = TOOLS['dirsearch']\n    chdir(dirsearchPath)\n\n    await ctx.send(f\"**Running Your Dirsearch Scan, We Will Send The Results When It's Done**\")\n    _ = subprocess.Popen(f'python3 dirsearch.py -u {argument} -e \"*\" -o {BASE_PATH}/messages/{fileName} && python3 {BASE_PATH}/notify.py --mode 2 -m \"Dirsearch results:\" -f \"- {ctx.message.author}\" --file {fileName}', shell=True, stdin=None, stdout=None, stderr=None, close_fds=True)\n    \n    chdir(BASE_PATH)\n    await ctx.send(\"**Dirsearch just started, The results gonna be sent when the process is done**\")\n\n@Client.command()\nasync def arjun(ctx , *, argument):\n    argument = CommandInjection.sanitizeInput(argument)\n    await ctx.send(f\"**Running Your Arjun Scan, We Will Send The Results When It's Done**\")\n    await ctx.send(f\"**Note: The Bot Won't Respond Until The Scan is Done. All Of Your Commands Now Will Be Executed After This Process is Done.\")\n    Process = subprocess.Popen(f'arjun -u {argument}', shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)\n    Output = Process.communicate()[0].decode('UTF-8')\n    Output = utilities.remove_escape_sequences(Output)\n    Output = utilities.remove_string('Processing', Output)\n\n    if len(Output) > 2000:\n        RandomStr = utilities.generate_random_string()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(Output); Message.close()\n            await ctx.send(\"**Arjun Results:**\", file=discord.File(f\"messages/{RandomStr}\"))\n            await ctx.send(f\"\\n**- {ctx.message.author}**\")\n    else:\n        targetName = argument.split(' ')[0].replace('http://' , '').replace('https://' , '')\n        await ctx.send(f'Arjun Results For {targetName}:')\n        await ctx.send(f'```{Output}```')\n        await ctx.send(f\"\\n**- {ctx.message.author}**\")\n\n@Client.command()\nasync def gitgraber(ctx , *, argument):\n    # argument = CommandInjection.sanitizeInput(argument)\n    # Path = TOOLS['gitgraber']; MainPath = getcwd(); chdir(Path)\n    # await ctx.send(f\"**Running Your GitGraber Scan, See gitGraber Channel For Possible Leaks**\")\n    # _ = subprocess.Popen(f'python3 gitGraber.py -k wordlists/keywords.txt -q {argument} -d' , shell=True , stdin=None, stdout=None, stderr=None, close_fds=True)\n    # chdir(MainPath)\n    await ctx.send(\"Gitgrabber command is currently disabled, Might be implemented again in the next update.\")\n\n@Client.command()\nasync def waybackurls(ctx , *, argument):\n    argument = CommandInjection.sanitizeInput(argument)\n    await ctx.send(f\"**Collecting Waybackurls, We Will Send The Results When It's Done**\")\n    Process = subprocess.Popen(f\"echo {argument} | waybackurls\",shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n    Output = Process.communicate()[0].decode('UTF-8')\n\n    if len(Output) > 2000:\n        RandomStr = utilities.generate_random_string()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(Output)\n            Message.close()\n\n            messageSize = utilities.get_size(f'messages/{RandomStr}')\n            if not messageSize:\n                await ctx.send(\"Something went wrong while trying to read the message\")\n                return\n            elif messageSize > 8:\n                await ctx.send(\"The output size is over 8mb, We can't send it over discord at the moment.\")\n            else:\n                await ctx.send(f\"Waybackurls output for **{argument}**:\", file=discord.File(f\"messages/{RandomStr}\"))\n                await ctx.send(f\"\\nRequested by **{ctx.message.author}**\")\n    else:\n        await ctx.send(f'Waybackurls Results:')\n        await ctx.send(f'```{Output}```')\n\n@Client.command()\nasync def subfinder(ctx , *, argument):\n    argument = CommandInjection.sanitizeInput(argument)\n    await ctx.send(f\"**Collecting Subdomains Using Subdinder, We Will Send The Results When It's Done**\")\n    Process = subprocess.Popen(f\"subfinder -d {argument} -silent\",shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n    Output = Process.communicate()[0].decode('UTF-8')\n\n    if len(Output) > 2000:\n        RandomStr = utilities.generate_random_string()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(Output)\n            Message.close()\n\n            messageSize = utilities.get_size(f'messages/{RandomStr}')\n            if not messageSize:\n                await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                return\n            elif messageSize > 8:\n                await ctx.send(\"The output size is over 8mb, We can't send it over discord at the moment.\")\n            else:\n                await ctx.send(\"**Subfinder Results:**\", file=discord.File(f\"messages/{RandomStr}\"))\n                await ctx.send(f\"\\n**- {ctx.message.author}**\")\n    else:\n        await ctx.send(f'Subfinder Results:')\n        await ctx.send(f'```{Output}```')\n        await ctx.send(f\"\\n**- {ctx.message.author}**\")\n\n@Client.command()\nasync def assetfinder(ctx , *, argument):\n    argument = CommandInjection.sanitizeInput(argument)\n    await ctx.send(\"**Collecting Subdomains Using Assetfinder, We Will Send The Results When It's Done**\")\n    Process = subprocess.Popen(f\"assetfinder --subs-only {argument}\",shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n    Output = Process.communicate()[0].decode('UTF-8')\n\n    if len(Output) > 2000:\n        RandomStr = utilities.generate_random_string()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(Output)\n            Message.close()\n\n            messageSize = utilities.get_size(f'messages/{RandomStr}')\n            if not messageSize:\n                await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                return\n            elif messageSize > 8:\n                await ctx.send(\"The output size is over 8mb, We can't send it over discord at the moment.\")\n            else:\n                await ctx.send(\"**Assetfinder Results:**\", file=discord.File(f\"messages/{RandomStr}\"))\n                await ctx.send(f\"\\n**- {ctx.message.author}**\")\n    else:\n        await ctx.send(f'Results:')\n        await ctx.send(f'```{Output}```')\n        await ctx.send(f\"\\n**- {ctx.message.author}**\")\n\n@Client.command()\nasync def findomain(ctx , *, argument):\n    argument = CommandInjection.sanitizeInput(argument)\n    findomainPath = TOOLS['findomain']\n    await ctx.send(\"**Collecting Subdomains Using Findomain, We Will Send The Results When It's Done**\")\n    Process = subprocess.Popen(f\"{findomainPath} --target {argument} --quiet\",shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n    Output = Process.communicate()[0].decode('UTF-8')\n\n    if len(Output) > 2000:\n        RandomStr = utilities.generate_random_string()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(Output)\n            Message.close()\n\n            messageSize = utilities.get_size(f'messages/{RandomStr}')\n            if not messageSize:\n                await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                return\n            elif messageSize > 8:\n                await ctx.send(\"The output size is over 8mb, We can't send it over discord at the moment.\")\n            else:\n                await ctx.send(\"**Findomain Results:**\", file=discord.File(f\"messages/{RandomStr}\"))\n                await ctx.send(f\"\\n**- {ctx.message.author}**\")\n    else:\n        await ctx.send(\"**Findomain Results:**\")\n        await ctx.send(f\"```{Output}```\")\n        await ctx.send(f\"\\n**- {ctx.message.author}**\")\n\n@Client.command()\nasync def paramspider(ctx, *, argument):\n    argument = CommandInjection.sanitizeInput(argument)\n    paramPath = TOOLS['paramspider']\n    await ctx.send(\"**Collecting Parameters Using ParamSpider, We Will Send The Results When It's Done**\")\n    Process = subprocess.Popen(f\"python3 {paramPath}/paramspider.py -d {argument}\",shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n    Output = Process.communicate()[0].decode('UTF-8')\n\n    Output = utilities.remove_escape_sequences(Output)\n    Output = Output.split('\\n')\n    urlsList = []\n    for singleLine in Output:\n        if singleLine.startswith('http'):\n            urlsList.append(singleLine)\n        else:\n            pass\n\n    Output = '\\n'.join(urlsList)\n\n    if len(Output) > 2000:\n        RandomStr = utilities.generate_random_string()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(Output)\n            Message.close()\n\n            messageSize = utilities.get_size(f'messages/{RandomStr}')\n            if not messageSize:\n                await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                return\n            elif messageSize > 8:\n                await ctx.send(\"The output size is over 8mb, We can't send it over discord at the moment.\")\n            else:\n                await ctx.send(\"**ParamSpider Results:**\", file=discord.File(f\"messages/{RandomStr}\"))\n                await ctx.send(f\"\\n**- {ctx.message.author}**\")\n    else:\n        await ctx.send(f'**ParamSpider Results:**')\n        await ctx.send(f'```{Output}```')\n        await ctx.send(f\"\\n**- {ctx.message.author}**\")\n\n@Client.command()\nasync def trufflehog(ctx, *, argument):\n    # # URL validation\n    # urlParsed = urlparse(argument)\n    # urlHost = urlParsed.netloc\n    # if urlHost != \"github.com\" and urlHost != \"gitlab.com\":\n    #     await ctx.send(\"**You're trying to scan unallowed URL, please use a github/gitlab URL.**\")\n    #     return\n    \n    # urlScheme = urlParsed.scheme\n    # if urlScheme not in [\"http\", \"https\"]:\n    #     await ctx.send(\"**You're trying to scan unallowed URL, please use a github/gitlab URL.**\")\n    #     return\n\n    # # status code validation\n    # statusCodeInteger = utilities.get_code(argument)\n    # if statusCodeInteger == 404:\n    #     await ctx.send(\"**The project you're trying to scan doesn't exists, double check the URL**\")\n    #     return\n\n    # await ctx.send(f\"**Scanning {argument} for possible data leaks using truffleHog**\")\n    # argument = CommandInjection.sanitizeInput(argument)\n    # _ = subprocess.Popen(f\"trufflehog --regex --entropy=False {argument} | python3 notify.py --mode 1 -m 'truffleHog Results:' -f '- {ctx.message.author}'\", shell=True , stdin=None, stdout=None, stderr=None, close_fds=True)\n    # await ctx.send(f\"**pyNotify gonna send the results when it's done**\")\n    await ctx.send(\"Trufflehog is currently disabled, Might get added again in future updates.\")\n\n@Client.command()\nasync def gitls(ctx, *, argument):\n    argument = CommandInjection.sanitizeInput(argument)\n    await ctx.send(f\"Collecting github repositories for **{argument}**\")\n    Process = subprocess.Popen(f\"echo https://github.com/{argument} | gitls\", shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)\n    Output = Process.communicate()[0].decode('UTF-8')\n\n    if len(Output) > 2000:\n        RandomStr = utilities.generate_random_string()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(Output)\n            Message.close()\n\n            messageSize = utilities.get_size(f'messages/{RandomStr}')\n            if not messageSize:\n                await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                return\n            elif messageSize > 8:\n                await ctx.send(\"The output size is over 8mb, We can't send it over discord at the moment.\")\n            else:\n                await ctx.send(f\"**Gitls output for **{argument}**:\", file=discord.File(f\"messages/{RandomStr}\"))\n                await ctx.send(f\"\\nRequested by **{ctx.message.author}**\")\n    elif len(Output) == 0:\n        await ctx.send(f\"**Gitls didn't reutrn an output for your command**\")\n    else:\n        await ctx.send(f\"**Gitls output for **{argument}**:\")\n        await ctx.send(f\"```{Output}```\")\n        await ctx.send(f\"\\nRequested by **{ctx.message.author}**\")\n\n# My Own Recon Data. It Isn't About You.\n@Client.command()\nasync def recon(ctx , *, argument):\n    if path.exists(f'/{USER}/{RECON_PATH}/{argument}'):\n        try:\n            Path = f'/{USER}/{RECON_PATH}/{argument}'.replace('//' , '/').replace('..', '')\n            Data = open(Path).read().rstrip()\n            Data = utilities.remove_escape_sequences(Data)\n            Message = f\"\"\"```{Data}```\"\"\"\n        except Exception:\n            Message = f\"**Couldn't Find The Recon Data With This Path: {argument}**\"\n    else:\n        Message = \"**Sorry The Path You Added Doesn't Exists On Our Records**\"\n\n    if len(Message) > 2000:\n        RandomStr = utilities.generate_random_string()\n\n        with open(f'messages/{RandomStr}' , 'w') as writerHere:\n            writerHere.write(Message)\n            writerHere.close()\n\n            messageSize = utilities.get_size(f'messages/{RandomStr}')\n            if not messageSize:\n                await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                return\n            elif messageSize > 8:\n                await ctx.send(\"The output size is over 8mb, We can't send it over discord at the moment.\")\n            else:\n                await ctx.send(\"**Recon Results:**\", file=discord.File(f\"messages/{RandomStr}\"))\n                await ctx.send(f\"\\n**- {ctx.message.author}**\")\n    else:\n        await ctx.send(f'{Message}')\n\n# Recon Collections\nasync def collect_subdomains(ctx, *, argument):\n    global logsItems, resolvedItems\n    argument = CommandInjection.sanitizeInput(argument)\n\n    await ctx.send(f\"Collecting subdomains for **{argument}**, Might take up to a few minutes.\")\n\n    findomainPath = TOOLS['findomain']\n\n    async def run_subprocess(command):\n        process = await asyncio.create_subprocess_shell(\n            command,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.STDOUT\n        )\n        results = await process.communicate()\n        return results[0].decode('UTF-8')\n\n    # Run subprocesses asynchronously\n    findomainResults, assetfinderResults, subfinderResults = await asyncio.gather(\n        run_subprocess(f\"{findomainPath} --target {argument} --quiet\"),\n        run_subprocess(f\"assetfinder --subs-only {argument}\"),\n        run_subprocess(f\"subfinder -d {argument} -silent\")\n    )\n\n    allSubdomains = findomainResults + assetfinderResults + subfinderResults\n    allSubdomains = utilities.remove_duplicates(allSubdomains)\n    allSubdomains = utilities.filter_subdomains(allSubdomains, argument)\n\n    fileName = utilities.generate_random_string()\n    resolvedName = utilities.generate_random_string()\n\n    currentPath = getcwd()\n    allSubdomains = '\\n'.join(allSubdomains)\n\n    with open(f'data/hosts/{resolvedName}', 'w') as subdomainsFile:\n        subdomainsFile.write(allSubdomains)\n\n    resolvedParser.resolvedWriter(Target=argument, fileName=f\"{resolvedName}\\n\")\n    resolvedItems[argument] = resolvedName\n\n    httpxResults = await run_subprocess(f\"cat data/hosts/{resolvedName} | httpx -silent\")\n\n    with open(f'data/subdomains/{fileName}', 'w') as subdomainsFile:\n        subdomainsFile.write(httpxResults)\n\n    logsParser.logsWriter(Target=argument, fileName=fileName)\n    logsItems[argument] = fileName\n\n    if len(httpxResults) > 2000:\n        RandomStr = utilities.generate_random_string()\n\n        with open(f'messages/{RandomStr}', 'w') as Message:\n            Message.write(httpxResults)\n\n            messageSize = utilities.get_size(file_path=f\"messages/{RandomStr}\")\n            if not messageSize:\n                await ctx.send(\"Something went wrong reading the output.\")\n                return\n            elif messageSize > 8:\n                await ctx.send(\"The output size is over 8mb, We can't send it over discord at the moment.\")\n            else:\n                await ctx.send(f\"**Active subdomains collected for **{argument}**:\", file=discord.File(f\"messages/{RandomStr}\"))\n                await ctx.send(f\"\\nRequested by **{ctx.message.author}**\")\n    else:\n        await ctx.send(f\"Active subdomains collected for **{argument}**:\")\n        await ctx.send(f'```{httpxResults}```')\n        await ctx.send(f\"\\nRequested by **{ctx.message.author}**\")\n\n@Client.command()\nasync def subdomains(ctx, *, argument):\n    asyncio.create_task(collect_subdomains(ctx, argument=argument))\n\n@Client.command()\nasync def info(ctx , *, argument):\n    global logsItems\n\n    try:\n        subdomainsFile = logsItems[argument]\n    except Exception:\n        await ctx.send(\"**There's no subdomains has been collected for this target. please use** `.subdomains [TARGET]` **Then try again.**\")\n        return\n\n    await ctx.send(f\"Collecting information about subdomains for **{argument}**\")\n    Process = subprocess.Popen(f\"cat data/subdomains/{subdomainsFile} | httpx -title -web-server -status-code -follow-redirects -silent\",shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n    httpxResults = Process.communicate()[0].decode('UTF-8')\n    httpxResults = utilities.remove_escape_sequences(httpxResults)\n\n    if len(httpxResults) > 2000:\n        RandomStr = utilities.generate_random_string()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(httpxResults)\n            Message.close()\n\n            messageSize = utilities.get_size(f'messages/{RandomStr}')\n            if not messageSize:\n                await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                return\n            elif messageSize > 8:\n                await ctx.send(\"The output size is over 8mb, We can't send it over discord at the moment.\")\n            else:\n                await ctx.send(f\"Subdomains information for **{argument}:**\", file=discord.File(f\"messages/{RandomStr}\"))\n                await ctx.send(f\"\\nRequested by **{ctx.message.author}**\")\n    else:\n        await ctx.send(f\"Subdomains information for **{argument}**:\")\n        await ctx.send(f'```{httpxResults}```')\n        await ctx.send(f\"\\nRequested by **{ctx.message.author}**\")\n\n# Tools collection\n@Client.command()\nasync def nuclei(ctx, *, argument):\n    global logsItems\n    nucleiTemplates = TOOLS['nuclei-templates']\n\n    try:\n        subdomainsFile = logsItems[argument]\n    except Exception:\n        await ctx.send(\"**There's no subdomains has been collected for this target. please use** `.subdomains [TARGET]` **Then try again.**\")\n        return\n\n    await ctx.send(f\"**Scanning {argument} For Possible Issues Using Nuclei.**\")\n    if DISABLE_NUCLEI_INFO:\n        _ = subprocess.Popen(f\"nuclei -l data/subdomains/{subdomainsFile} -t {nucleiTemplates} -silent | grep -v 'info.*\\]' | python3 notify.py --mode 0 --discord-webhook {NUCLEI_WEBHOOK}\",shell=True,stdin=None, stdout=None, stderr=None, close_fds=True)\n    else:\n         _ = subprocess.Popen(f\"nuclei -l data/subdomains/{subdomainsFile} -t {nucleiTemplates} -silent | python3 notify.py --mode 0 --discord-webhook {NUCLEI_WEBHOOK}\", shell=True,stdin=None, stdout=None, stderr=None, close_fds=True)\n    await ctx.send(\"**Results gonna be sent to nuclei webhook channel**\")\n\n@Client.command()\nasync def subjack(ctx , *, argument):\n    global resolvedItems\n    argument = CommandInjection.sanitizeInput(argument)\n\n    try:\n        resolvedFile = resolvedItems[argument]\n        fileStr = utilities.generate_random_string()\n    except Exception:\n        await ctx.send(\"**There's no subdomains has been collected for this target. please use** `.subdomains [TARGET]` **Then try again.**\")\n        return\n\n    await ctx.send(f\"**Scanning {argument} For Possible Subdomains Takeover Issues Using Subjack**\")\n    _ = subprocess.Popen(f\"subjack -w data/hosts/{resolvedFile} -t 100 -timeout 30 -o data/subjack/{argument}-{fileStr}.subjack -ssl | python3 notify.py --mode 1 -m 'Subjack results:' -f '- {ctx.message.author}'\", shell=True,stdin=None, stdout=None, stderr=None, close_fds=True)\n\n    await ctx.send(f\"**Results gonna be sent to the results channel soon**\")\n\n@Client.command()\nasync def subjs(ctx , *, argument):\n    global logsItems\n    argument = CommandInjection.sanitizeInput(argument)\n\n    try:\n        subdomainsFile = logsItems[argument]\n    except Exception:\n        await ctx.send(\"**There's no subdomains has been collected for this target. please use** `.subdomains [TARGET]` **Then try again.**\")\n        return\n\n    await ctx.send(f\"**Extracting JS Files From {argument} Using Subjs**\")\n    _ = subprocess.Popen(f\"cat data/subdomains/{subdomainsFile} | subjs | python3 notify.py --mode 1 -m 'Subjs results:' -f '- {ctx.message.author}'\", shell=True,stdin=None, stdout=None, stderr=None, close_fds=True)\n    await ctx.send(f\"**Results gonna be sent soon on the results channel**\")\n\n@Client.command()\nasync def smuggler(ctx, *, argument):\n    global logsItems\n    argument = CommandInjection.sanitizeInput(argument)\n\n    try:\n        subdomainsFile = logsItems[argument]\n    except Exception:\n        await ctx.send(\"**There's no subdomains has been collected for this target. please use** `.subdomains [TARGET]` **Then try again.**\")\n        return\n\n    smugglerPath = TOOLS['smuggler']\n    await ctx.send(f\"**Scanning {argument} For HTTP Request Smuggling Issues Using Smuggler**\")\n\n    if \"http:\" in argument or \"https:\" in argument:\n        Process = subprocess.Popen(f\"echo {argument} | python3 {smugglerPath}/smuggler.py\",shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n        smugglerResults = Process.communicate()[0].decode('UTF-8')\n    else:\n        Process = subprocess.Popen(f\"cat data/subdomains/{subdomainsFile} | python3 {smugglerPath}/smuggler.py\",shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n        smugglerResults = Process.communicate()[0].decode('UTF-8')\n\n    smugglerResults = utilities.remove_escape_sequences(smugglerResults)\n    if len(smugglerResults) > 2000:\n        RandomStr = utilities.generate_random_string()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(smugglerResults)\n            Message.close()\n\n            messageSize = utilities.get_size(f'messages/{RandomStr}')\n\n            if not messageSize:\n                await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                return\n            elif messageSize > 8:\n                await ctx.send(\"The output size is over 8mb, We can't send it over discord at the moment.\")\n            else:\n                await ctx.send(\"**Smuggler Results:**\", file=discord.File(f\"messages/{RandomStr}\"))\n                await ctx.send(f\"\\n**- {ctx.message.author}**\")\n    else:\n        await ctx.send(f\"**Smuggler Results For {argument}:**\")\n        await ctx.send(f'```{smugglerResults}```')\n        await ctx.send(f\"\\n**- {ctx.message.author}**\")\n\n# Showing Current Recon Data\n@Client.command()\n@commands.has_role(ADMIN_ROLE)\nasync def show(ctx):\n    global logsItems\n\n    targetsList = []\n    for site,_ in logsItems.items():\n        targetsList.append(site)\n\n    targetsMessage = '\\n'.join(targetsList)\n    targetsMessage = f\"\"\"```\n    {targetsMessage}\n    ```\n    \"\"\"\n    await ctx.send(f\"**Available records: \\n\\n{targetsMessage}**\")\n\n@Client.command()\n@commands.has_role(ADMIN_ROLE)\nasync def count(ctx , *, argument):\n    global logsItems , resolvedItems\n\n    try:\n        resolvedFile = resolvedItems[argument]\n        resolvedContent = open(f'data/hosts/{resolvedFile}' , 'r').readlines()\n        resolvedLength = len(resolvedContent)\n    except Exception:\n        await ctx.send(\"**There's no subdomains has been collected for this target. please use ** `.subdomains [TARGET]` ** Then try again.**\")\n        return\n\n    try:\n        subdomainsFile = logsItems[argument]\n        subdomainsContent = open(f'data/subdomains/{subdomainsFile}' , 'r').readlines()\n        subdomainsLength = len(subdomainsContent)\n    except Exception:\n        await ctx.send(\"**There's no subdomains has been collected for this target. please use** `.subdomains [TARGET]` **Then try again.**\")\n        return\n\n    await ctx.send(f\"**{argument}**:\\n\\t\\tResolved hosts: {str(resolvedLength)}\\n\\t\\tLive subdomains: {str(subdomainsLength)}\")\n\n# Main Event With Admin Channel Logger.\n@Client.event\nasync def on_command_error(ctx, error):\n    if isinstance(error, commands.CommandNotFound):\n        await ctx.send(\"**Invalid command, please type `.help` to see the list of commands and tools.**\")\n    elif isinstance(error, (commands.MissingRole, commands.MissingAnyRole)):\n        await ctx.send(\"**You don't have permession to use this command, role is required**\")\n    else:\n        await ctx.send(f\"**Unknown error: {error}**\")\n\n@Client.event\nasync def on_command(ctx):\n    current_date = datetime.now()\n    formatted_date = current_date.strftime(\"%Y/%m/%d\")\n    utilities.log_command(ctx.command, ctx.author, formatted_date, ctx.message.content)\n\n@Client.event\nasync def on_member_join(member):\n    welcome_message = f\"\"\"```    \nWelcome to Discord-Recon, your go-to Discord bot designed to assist bug bounty hunters in streamlining their reconnaissance process through simple commands. Whether you prefer using the bot within your server or privately in this chat, the choice is yours.\n\nIf you're interested in hosting your own Discord-Recon server, feel free to explore the source code at https://github.com/DEMON1A/Discord-Recon. Donations are appreciated but not mandatory; they go towards server upgrades and covering the bot's hosting expenses. Contribute if you can, and thank you for being part of our community!\n    ```\"\"\"\n    await member.send(welcome_message)\n\n@Client.event\nasync def on_member_remove(member):\n    admin_channel = Client.get_channel(ADMIN_CHANNEL)\n    await admin_channel.send(f\"**{member}** either left the server or got kicked out.\")\n\n@Client.event\nasync def on_ready():\n    admin_channel = Client.get_channel(ADMIN_CHANNEL)\n    current_date = datetime.now()\n    formatted_date = current_date.strftime(\"%Y/%m/%d\")\n\n    # Get system information\n    memory_usage = psutil.virtual_memory().percent\n    cpu_usage = psutil.cpu_percent(interval=1)\n    disk_usage = psutil.disk_usage('/').percent\n\n    message = (\n        f\"**ReconServer Started** :dizzy:\\n\\n\"\n        f\"Operating on: **{formatted_date}**\\n\"\n        f\"Memory Usage: **{memory_usage}%**\\n\"\n        f\"CPU Usage: **{cpu_usage}**%\\n\"\n        f\"Disk Usage: **{disk_usage}**%\"\n    )\n\n    await admin_channel.send(message)\n\nif __name__ == \"__main__\":\n    Client.run(DISCORD_TOKEN)\n"], "filenames": ["app.py"], "buggy_code_start_loc": [159], "buggy_code_end_loc": [176], "fixing_code_start_loc": [160], "fixing_code_end_loc": [177], "type": "CWE-77", "message": "Discord-Recon is a Discord bot created to automate bug bounty recon, automated scans and information gathering via a discord server. Discord-Recon is vulnerable to remote code execution. An attacker is able to execute shell commands in the server without having an admin role. This vulnerability has been fixed in version 0.0.8.\n", "other": {"cve": {"id": "CVE-2024-21663", "sourceIdentifier": "security-advisories@github.com", "published": "2024-01-09T00:15:44.790", "lastModified": "2024-01-12T15:22:42.607", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Discord-Recon is a Discord bot created to automate bug bounty recon, automated scans and information gathering via a discord server. Discord-Recon is vulnerable to remote code execution. An attacker is able to execute shell commands in the server without having an admin role. This vulnerability has been fixed in version 0.0.8.\n"}, {"lang": "es", "value": "Discord-Recon es un bot de Discord creado para automatizar el reconocimiento de errores, escaneos automatizados y recopilaci\u00f3n de informaci\u00f3n a trav\u00e9s de un servidor de Discord. Discord-Recon es vulnerable a la ejecuci\u00f3n remota de c\u00f3digo. Un atacante puede ejecutar comandos de shell en el servidor sin tener una funci\u00f3n de administrador. Esta vulnerabilidad se ha solucionado en la versi\u00f3n 0.0.8."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.9, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.1, "impactScore": 6.0}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-77"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:demon1a:discord-recon:*:*:*:*:*:discord:*:*", "versionEndExcluding": "0.0.8", "matchCriteriaId": "C89EDC32-6EF6-4868-A4A5-911E552F82B8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:demon1a:discord-recon:0.0.8:beta:*:*:*:discord:*:*", "matchCriteriaId": "5EF620EA-979B-4367-903C-DC2BFAFCAD09"}]}]}], "references": [{"url": "https://github.com/DEMON1A/Discord-Recon/commit/f9cb0f67177f5e2f1022295ca8e641e47837ec7a", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/DEMON1A/Discord-Recon/issues/23", "source": "security-advisories@github.com", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/DEMON1A/Discord-Recon/security/advisories/GHSA-fjcj-g7x8-4rp7", "source": "security-advisories@github.com", "tags": ["Exploit", "Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/DEMON1A/Discord-Recon/commit/f9cb0f67177f5e2f1022295ca8e641e47837ec7a"}}