{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%          OOO   PPPP   EEEE  RRRR    AA   TTTTT  III   OOO   N   N           %\n%         O   O  P   P  E     R   R  A  A    T     I   O   O  NN  N           %\n%         O   O  PPPP   EEE   RRRR   AAAA    T     I   O   O  N N N           %\n%         O   O  P      E     R R    A  A    T     I   O   O  N  NN           %\n%          OOO   P      EEEE  R  RR  A  A    T    III   OOO   N   N           %\n%                                                                             %\n%                                                                             %\n%                         CLI Magick Option Methods                           %\n%                                                                             %\n%                              Dragon Computing                               %\n%                              Anthony Thyssen                                %\n%                               September 2011                                %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2019 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n% Apply the given options (settings, and simple, or sequence operations) to\n% the given image(s) according to the current \"image_info\", \"draw_info\", and\n% \"quantize_info\" settings, stored in a special CLI Image Wand.\n%\n% The final goal is to allow the execution in a strict one option at a time\n% manner that is needed for 'pipelining and file scripting' of options in\n% IMv7.\n%\n% Anthony Thyssen, September 2011\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickWand/studio.h\"\n#include \"MagickWand/MagickWand.h\"\n#include \"MagickWand/magick-wand-private.h\"\n#include \"MagickWand/mogrify.h\"\n#include \"MagickWand/operation.h\"\n#include \"MagickWand/wand.h\"\n#include \"MagickWand/wandcli.h\"\n#include \"MagickWand/wandcli-private.h\"\n#include \"MagickCore/composite-private.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/pixel-private.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/thread-private.h\"\n#include \"MagickCore/timer-private.h\"\n\f\n/*\n  Constant declaration.\n*/\nstatic const char\n  MogrifyAlphaColor[] = \"#bdbdbd\",  /* slightly darker gray */\n  MogrifyBackgroundColor[] = \"#fff\",  /* white */\n  MogrifyBorderColor[] = \"#dfdfdf\";  /* sRGB gray */\n\f\n/*\n  Define declarations.\n*/\n#define USE_WAND_METHODS  1\n#define MAX_STACK_DEPTH  32\n#define UNDEFINED_COMPRESSION_QUALITY  0UL\n\n/* FUTURE: why is this default so specific? */\n#define DEFAULT_DISSIMILARITY_THRESHOLD \"0.31830988618379067154\"\n\n/* For Debugging Geometry Input */\n#define ReportGeometry(flags,info) \\\n  (void) FormatLocaleFile(stderr, \"Geometry = 0x%04X : %lg x %lg %+lg %+lg\\n\", \\\n       flags, info.rho, info.sigma, info.xi, info.psi )\n\f\n/*\n** Function to report on the progress of image operations\n*/\nstatic MagickBooleanType MonitorProgress(const char *text,\n  const MagickOffsetType offset,const MagickSizeType extent,\n  void *wand_unused(client_data))\n{\n  char\n    message[MagickPathExtent],\n    tag[MagickPathExtent];\n\n  const char\n    *locale_message;\n\n  register char\n    *p;\n\n  magick_unreferenced(client_data);\n\n  if ((extent <= 1) || (offset < 0) || (offset >= (MagickOffsetType) extent))\n    return(MagickTrue);\n  if ((offset != (MagickOffsetType) (extent-1)) && ((offset % 50) != 0))\n    return(MagickTrue);\n  (void) CopyMagickString(tag,text,MagickPathExtent);\n  p=strrchr(tag,'/');\n  if (p != (char *) NULL)\n    *p='\\0';\n  (void) FormatLocaleString(message,MagickPathExtent,\"Monitor/%s\",tag);\n  locale_message=GetLocaleMessage(message);\n  if (locale_message == message)\n    locale_message=tag;\n  if (p == (char *) NULL)\n    (void) FormatLocaleFile(stderr,\"%s: %ld of %lu, %02ld%% complete\\r\",\n      locale_message,(long) offset,(unsigned long) extent,(long)\n      (100L*offset/(extent-1)));\n  else\n    (void) FormatLocaleFile(stderr,\"%s[%s]: %ld of %lu, %02ld%% complete\\r\",\n      locale_message,p+1,(long) offset,(unsigned long) extent,(long)\n      (100L*offset/(extent-1)));\n  if (offset == (MagickOffsetType) (extent-1))\n    (void) FormatLocaleFile(stderr,\"\\n\");\n  (void) fflush(stderr);\n  return(MagickTrue);\n}\n\n/*\n** GetImageCache() will read an image into a image cache if not already\n** present then return the image that is in the cache under that filename.\n*/\nstatic inline Image *GetImageCache(const ImageInfo *image_info,const char *path,\n  ExceptionInfo *exception)\n{\n  char\n    key[MagickPathExtent];\n\n  ExceptionInfo\n    *sans_exception;\n\n  Image\n    *image;\n\n  ImageInfo\n    *read_info;\n\n  (void) FormatLocaleString(key,MagickPathExtent,\"cache:%s\",path);\n  sans_exception=AcquireExceptionInfo();\n  image=(Image *) GetImageRegistry(ImageRegistryType,key,sans_exception);\n  sans_exception=DestroyExceptionInfo(sans_exception);\n  if (image != (Image *) NULL)\n    return(image);\n  read_info=CloneImageInfo(image_info);\n  if (path != (const char *) NULL)\n    (void) CopyMagickString(read_info->filename,path,MagickPathExtent);\n  image=ReadImage(read_info,exception);\n  read_info=DestroyImageInfo(read_info);\n  if (image != (Image *) NULL)\n    (void) SetImageRegistry(ImageRegistryType,key,image,exception);\n  return(image);\n}\n\n/*\n  SparseColorOption() parse the complex -sparse-color argument into an\n  an array of floating point values than call SparseColorImage().\n  Argument is a complex mix of floating-point pixel coodinates, and color\n  specifications (or direct floating point numbers).  The number of floats\n  needed to represent a color varies depending on the current channel\n  setting.\n\n  This really should be in MagickCore, so that other API's can make use of it.\n*/\nstatic Image *SparseColorOption(const Image *image,\n  const SparseColorMethod method,const char *arguments,ExceptionInfo *exception)\n{\n  char\n    token[MagickPathExtent];\n\n  const char\n    *p;\n\n  double\n    *sparse_arguments;\n\n  Image\n    *sparse_image;\n\n  PixelInfo\n    color;\n\n  MagickBooleanType\n    error;\n\n  register size_t\n    x;\n\n  size_t\n    number_arguments,\n    number_colors;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  /*\n    Limit channels according to image\n    add up number of values needed per color.\n  */\n  number_colors=0;\n  if ((GetPixelRedTraits(image) & UpdatePixelTrait) != 0)\n    number_colors++;\n  if ((GetPixelGreenTraits(image) & UpdatePixelTrait) != 0)\n    number_colors++;\n  if ((GetPixelBlueTraits(image) & UpdatePixelTrait) != 0)\n    number_colors++;\n  if (((GetPixelBlackTraits(image) & UpdatePixelTrait) != 0) &&\n      (image->colorspace == CMYKColorspace))\n    number_colors++;\n  if (((GetPixelAlphaTraits(image) & UpdatePixelTrait) != 0) &&\n      image->alpha_trait != UndefinedPixelTrait)\n    number_colors++;\n\n  /*\n    Read string, to determine number of arguments needed,\n  */\n  p=arguments;\n  x=0;\n  while( *p != '\\0' )\n  {\n    GetNextToken(p,&p,MagickPathExtent,token);\n    if ( token[0] == ',' ) continue;\n    if ( isalpha((int) token[0]) || token[0] == '#' )\n      x += number_colors;  /* color argument found */\n    else\n      x++;   /* floating point argument */\n  }\n  /* control points and color values */\n  if ((x % (2+number_colors)) != 0)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"InvalidArgument\",\"'%s': %s\", \"sparse-color\",\n        \"Invalid number of Arguments\");\n      return( (Image *) NULL);\n    }\n  error=MagickFalse;\n  number_arguments=x;\n\n  /* Allocate and fill in the floating point arguments */\n  sparse_arguments=(double *) AcquireQuantumMemory(number_arguments,\n    sizeof(*sparse_arguments));\n  if (sparse_arguments == (double *) NULL) {\n    (void) ThrowMagickException(exception,GetMagickModule(),ResourceLimitError,\n      \"MemoryAllocationFailed\",\"%s\",\"SparseColorOption\");\n    return( (Image *) NULL);\n  }\n  (void) memset(sparse_arguments,0,number_arguments*\n    sizeof(*sparse_arguments));\n  p=arguments;\n  x=0;\n  while( *p != '\\0' && x < number_arguments ) {\n    /* X coordinate */\n    token[0]=','; while ( token[0] == ',' ) GetNextToken(p,&p,MagickPathExtent,token);\n    if ( token[0] == '\\0' ) break;\n    if ( isalpha((int) token[0]) || token[0] == '#' ) {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n            OptionError, \"InvalidArgument\", \"'%s': %s\", \"sparse-color\",\n            \"Color found, instead of X-coord\");\n      error=MagickTrue;\n      break;\n    }\n    sparse_arguments[x++]=StringToDouble(token,(char **) NULL);\n    /* Y coordinate */\n    token[0]=','; while ( token[0] == ',' ) GetNextToken(p,&p,MagickPathExtent,token);\n    if ( token[0] == '\\0' ) break;\n    if ( isalpha((int) token[0]) || token[0] == '#' ) {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n            OptionError, \"InvalidArgument\", \"'%s': %s\", \"sparse-color\",\n            \"Color found, instead of Y-coord\");\n      error=MagickTrue;\n      break;\n    }\n    sparse_arguments[x++]=StringToDouble(token,(char **) NULL);\n    /* color name or function given in string argument */\n    token[0]=','; while ( token[0] == ',' ) GetNextToken(p,&p,MagickPathExtent,token);\n    if ( token[0] == '\\0' ) break;\n    if ( isalpha((int) token[0]) || token[0] == '#' ) {\n      /* Color string given */\n      (void) QueryColorCompliance(token,AllCompliance,&color,\n                exception);\n      if ((GetPixelRedTraits(image) & UpdatePixelTrait) != 0)\n        sparse_arguments[x++] = QuantumScale*color.red;\n      if ((GetPixelGreenTraits(image) & UpdatePixelTrait) != 0)\n        sparse_arguments[x++] = QuantumScale*color.green;\n      if ((GetPixelBlueTraits(image) & UpdatePixelTrait) != 0)\n        sparse_arguments[x++] = QuantumScale*color.blue;\n      if (((GetPixelBlackTraits(image) & UpdatePixelTrait) != 0) &&\n          (image->colorspace == CMYKColorspace))\n        sparse_arguments[x++] = QuantumScale*color.black;\n      if (((GetPixelAlphaTraits(image) & UpdatePixelTrait) != 0) &&\n          image->alpha_trait != UndefinedPixelTrait)\n        sparse_arguments[x++] = QuantumScale*color.alpha;\n    }\n    else {\n      /* Colors given as a set of floating point values - experimental */\n      /* NB: token contains the first floating point value to use! */\n      if ((GetPixelRedTraits(image) & UpdatePixelTrait) != 0)\n        {\n        while ( token[0] == ',' ) GetNextToken(p,&p,MagickPathExtent,token);\n        if ( token[0] == '\\0' || isalpha((int)token[0]) || token[0] == '#' )\n          break;\n        sparse_arguments[x++]=StringToDouble(token,(char **) NULL);\n        token[0] = ','; /* used this token - get another */\n      }\n      if ((GetPixelGreenTraits(image) & UpdatePixelTrait) != 0)\n        {\n        while ( token[0] == ',' ) GetNextToken(p,&p,MagickPathExtent,token);\n        if ( token[0] == '\\0' || isalpha((int)token[0]) || token[0] == '#' )\n          break;\n        sparse_arguments[x++]=StringToDouble(token,(char **) NULL);\n        token[0] = ','; /* used this token - get another */\n      }\n      if ((GetPixelBlueTraits(image) & UpdatePixelTrait) != 0)\n        {\n        while ( token[0] == ',' ) GetNextToken(p,&p,MagickPathExtent,token);\n        if ( token[0] == '\\0' || isalpha((int)token[0]) || token[0] == '#' )\n          break;\n        sparse_arguments[x++]=StringToDouble(token,(char **) NULL);\n        token[0] = ','; /* used this token - get another */\n      }\n      if (((GetPixelBlackTraits(image) & UpdatePixelTrait) != 0) &&\n          (image->colorspace == CMYKColorspace))\n        {\n        while ( token[0] == ',' ) GetNextToken(p,&p,MagickPathExtent,token);\n        if ( token[0] == '\\0' || isalpha((int)token[0]) || token[0] == '#' )\n          break;\n        sparse_arguments[x++]=StringToDouble(token,(char **) NULL);\n        token[0] = ','; /* used this token - get another */\n      }\n      if (((GetPixelAlphaTraits(image) & UpdatePixelTrait) != 0) &&\n          image->alpha_trait != UndefinedPixelTrait)\n        {\n        while ( token[0] == ',' ) GetNextToken(p,&p,MagickPathExtent,token);\n        if ( token[0] == '\\0' || isalpha((int)token[0]) || token[0] == '#' )\n          break;\n        sparse_arguments[x++]=StringToDouble(token,(char **) NULL);\n        token[0] = ','; /* used this token - get another */\n      }\n    }\n  }\n  if (error != MagickFalse)\n    {\n      sparse_arguments=(double *) RelinquishMagickMemory(sparse_arguments);\n      return((Image *) NULL);\n    }\n  if (number_arguments != x)\n    {\n      sparse_arguments=(double *) RelinquishMagickMemory(sparse_arguments);\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"InvalidArgument\",\"'%s': %s\",\"sparse-color\",\"Argument Parsing Error\");\n      return((Image *) NULL);\n    }\n  /* Call the Sparse Color Interpolation function with the parsed arguments */\n  sparse_image=SparseColorImage(image,method,number_arguments,sparse_arguments,\n    exception);\n  sparse_arguments=(double *) RelinquishMagickMemory(sparse_arguments);\n  return( sparse_image );\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   C L I S e t t i n g O p t i o n I n f o                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CLISettingOptionInfo() applies a single settings option into a CLI wand\n%  holding the image_info, draw_info, quantize_info structures that will be\n%  used when processing the images.\n%\n%  These options do no require images to be present in the CLI wand for them\n%  to be able to be set, in which case they will generally be applied to image\n%  that are read in later\n%\n%  Options handled by this function are listed in CommandOptions[] of\n%  \"option.c\" that is one of \"SettingOptionFlags\" option flags.\n%\n%  The format of the CLISettingOptionInfo method is:\n%\n%    void CLISettingOptionInfo(MagickCLI *cli_wand,\n%               const char *option, const char *arg1, const char *arg2)\n%\n%  A description of each parameter follows:\n%\n%    o cli_wand: structure holding settings to be applied\n%\n%    o option: The option string to be set\n%\n%    o arg1, arg2: optional argument strings to the operation\n%        arg2 is currently only used by \"-limit\"\n%\n*/\nWandPrivate void CLISettingOptionInfo(MagickCLI *cli_wand,\n     const char *option,const char *arg1n, const char *arg2n)\n{\n  ssize_t\n    parse;     /* option argument parsing (string to value table lookup) */\n\n  const char    /* percent escaped versions of the args */\n    *arg1,\n    *arg2;\n\n#define _image_info       (cli_wand->wand.image_info)\n#define _image            (cli_wand->wand.images)\n#define _exception        (cli_wand->wand.exception)\n#define _draw_info        (cli_wand->draw_info)\n#define _quantize_info    (cli_wand->quantize_info)\n#define IfSetOption       (*option=='-')\n#define ArgBoolean        IfSetOption ? MagickTrue : MagickFalse\n#define ArgBooleanNot     IfSetOption ? MagickFalse : MagickTrue\n#define ArgBooleanString  (IfSetOption?\"true\":\"false\")\n#define ArgOption(def)    (IfSetOption?arg1:(const char *)(def))\n\n  assert(cli_wand != (MagickCLI *) NULL);\n  assert(cli_wand->signature == MagickWandSignature);\n  assert(cli_wand->wand.signature == MagickWandSignature);\n\n  if (cli_wand->wand.debug != MagickFalse)\n    (void) CLILogEvent(cli_wand,CommandEvent,GetMagickModule(),\n         \"- Setting Option: %s \\\"%s\\\" \\\"%s\\\"\", option,arg1n,arg2n);\n\n  arg1 = arg1n,\n  arg2 = arg2n;\n\n#if 1\n#define _process_flags    (cli_wand->process_flags)\n#define _option_type      ((CommandOptionFlags) cli_wand->command->flags)\n  /* Interpret Percent Escapes in Arguments - using first image */\n  if ( (((_process_flags & ProcessInterpretProperities) != 0 )\n        || ((_option_type & AlwaysInterpretArgsFlag) != 0)\n       )  && ((_option_type & NeverInterpretArgsFlag) == 0) ) {\n    /* Interpret Percent escapes in argument 1 */\n    if (arg1n != (char *) NULL) {\n      arg1=InterpretImageProperties(_image_info,_image,arg1n,_exception);\n      if (arg1 == (char *) NULL) {\n        CLIWandException(OptionWarning,\"InterpretPropertyFailure\",option);\n        arg1=arg1n;  /* use the given argument as is */\n      }\n    }\n    if (arg2n != (char *) NULL) {\n      arg2=InterpretImageProperties(_image_info,_image,arg2n,_exception);\n      if (arg2 == (char *) NULL) {\n        CLIWandException(OptionWarning,\"InterpretPropertyFailure\",option);\n        arg2=arg2n;  /* use the given argument as is */\n      }\n    }\n  }\n#undef _process_flags\n#undef _option_type\n#endif\n\n  switch (*(option+1))\n  {\n    case 'a':\n    {\n      if (LocaleCompare(\"adjoin\",option+1) == 0)\n        {\n          _image_info->adjoin = ArgBoolean;\n          break;\n        }\n      if (LocaleCompare(\"affine\",option+1) == 0)\n        {\n          CLIWandWarnReplaced(\"-draw 'affine ...'\");\n          if (IfSetOption)\n            (void) ParseAffineGeometry(arg1,&_draw_info->affine,_exception);\n          else\n            GetAffineMatrix(&_draw_info->affine);\n          break;\n        }\n      if (LocaleCompare(\"antialias\",option+1) == 0)\n        {\n          _image_info->antialias =\n            _draw_info->stroke_antialias =\n              _draw_info->text_antialias = ArgBoolean;\n          break;\n        }\n      if (LocaleCompare(\"attenuate\",option+1) == 0)\n        {\n          if (IfSetOption && (IsGeometry(arg1) == MagickFalse))\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) SetImageOption(_image_info,option+1,ArgOption(\"1.0\"));\n          break;\n        }\n      if (LocaleCompare(\"authenticate\",option+1) == 0)\n        {\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'b':\n    {\n      if (LocaleCompare(\"background\",option+1) == 0)\n        {\n          /* FUTURE: both _image_info attribute & ImageOption in use!\n             _image_info only used directly for generating new images.\n             SyncImageSettings() used to set per-image attribute.\n\n             FUTURE: if _image_info->background_color is not set then\n             we should fall back to per-image background_color\n\n             At this time -background will 'wipe out' the per-image\n             background color!\n\n             Better error handling of QueryColorCompliance() needed.\n          */\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          (void) QueryColorCompliance(ArgOption(MogrifyBackgroundColor),AllCompliance,\n             &_image_info->background_color,_exception);\n          break;\n        }\n      if (LocaleCompare(\"bias\",option+1) == 0)\n        {\n          /* FUTURE: bias OBSOLETED, replaced by Artifact \"convolve:bias\"\n             as it is actually rarely used except in direct convolve operations\n             Usage outside a direct convolve operation is actally non-sensible!\n\n             SyncImageSettings() used to set per-image attribute.\n          */\n          if (IfSetOption && (IsGeometry(arg1) == MagickFalse))\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) SetImageOption(_image_info,\"convolve:bias\",ArgOption(NULL));\n          break;\n        }\n      if (LocaleCompare(\"black-point-compensation\",option+1) == 0)\n        {\n          /* Used as a image chromaticity setting\n             SyncImageSettings() used to set per-image attribute.\n          */\n          (void) SetImageOption(_image_info,option+1,ArgBooleanString);\n          break;\n        }\n      if (LocaleCompare(\"blue-primary\",option+1) == 0)\n        {\n          /* Image chromaticity X,Y  NB: Y=X if Y not defined\n             Used by many coders including PNG\n             SyncImageSettings() used to set per-image attribute.\n          */\n          arg1=ArgOption(\"0.0\");\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) SetImageOption(_image_info,option+1,arg1);\n          break;\n        }\n      if (LocaleCompare(\"bordercolor\",option+1) == 0)\n        {\n          /* FUTURE: both _image_info attribute & ImageOption in use!\n             SyncImageSettings() used to set per-image attribute.\n             Better error checking of QueryColorCompliance().\n          */\n          if (IfSetOption)\n            {\n              (void) SetImageOption(_image_info,option+1,arg1);\n              (void) QueryColorCompliance(arg1,AllCompliance,\n                  &_image_info->border_color,_exception);\n              (void) QueryColorCompliance(arg1,AllCompliance,\n                  &_draw_info->border_color,_exception);\n              break;\n            }\n          (void) DeleteImageOption(_image_info,option+1);\n          (void) QueryColorCompliance(MogrifyBorderColor,AllCompliance,\n            &_image_info->border_color,_exception);\n          (void) QueryColorCompliance(MogrifyBorderColor,AllCompliance,\n            &_draw_info->border_color,_exception);\n          break;\n        }\n      if (LocaleCompare(\"box\",option+1) == 0)\n        {\n          CLIWandWarnReplaced(\"-undercolor\");\n          CLISettingOptionInfo(cli_wand,\"-undercolor\",arg1, arg2);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'c':\n    {\n      if (LocaleCompare(\"cache\",option+1) == 0)\n        {\n          MagickSizeType\n            limit;\n\n          if (IfSetOption && (IsGeometry(arg1) == MagickFalse))\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          limit=MagickResourceInfinity;\n          if (LocaleCompare(\"unlimited\",arg1) != 0)\n            limit=(MagickSizeType) SiPrefixToDoubleInterval(arg1,100.0);\n          (void) SetMagickResourceLimit(MemoryResource,limit);\n          (void) SetMagickResourceLimit(MapResource,2*limit);\n          break;\n        }\n      if (LocaleCompare(\"caption\",option+1) == 0)\n        {\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          break;\n        }\n      if (LocaleCompare(\"colorspace\",option+1) == 0)\n        {\n          /* Setting used for new images via AquireImage()\n             But also used as a SimpleImageOperator\n             Undefined colorspace means don't modify images on\n             read or as a operation */\n          parse=ParseCommandOption(MagickColorspaceOptions,MagickFalse,\n             ArgOption(\"undefined\"));\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedColorspace\",option,\n              arg1);\n          _image_info->colorspace=(ColorspaceType) parse;\n          break;\n        }\n      if (LocaleCompare(\"comment\",option+1) == 0)\n        {\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          break;\n        }\n      if (LocaleCompare(\"compose\",option+1) == 0)\n        {\n          /* FUTURE: _image_info should be used,\n             SyncImageSettings() used to set per-image attribute. - REMOVE\n\n             This setting should NOT be used to set image 'compose'\n             \"-layer\" operators shoud use _image_info if defined otherwise\n             they should use a per-image compose setting.\n          */\n          parse = ParseCommandOption(MagickComposeOptions,MagickFalse,\n                          ArgOption(\"undefined\"));\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedComposeOperator\",\n                                      option,arg1);\n          _image_info->compose=(CompositeOperator) parse;\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          break;\n        }\n      if (LocaleCompare(\"compress\",option+1) == 0)\n        {\n          /* FUTURE: What should be used?  _image_info  or ImageOption ???\n             The former is more efficent, but Crisy prefers the latter!\n             SyncImageSettings() used to set per-image attribute.\n\n             The coders appears to use _image_info, not Image_Option\n             however the image attribute (for save) is set from the\n             ImageOption!\n\n             Note that \"undefined\" is a different setting to \"none\".\n          */\n          parse = ParseCommandOption(MagickCompressOptions,MagickFalse,\n                     ArgOption(\"undefined\"));\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedImageCompression\",\n                                      option,arg1);\n          _image_info->compression=(CompressionType) parse;\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'd':\n    {\n      if (LocaleCompare(\"debug\",option+1) == 0)\n        {\n          /* SyncImageSettings() used to set per-image attribute. */\n          arg1=ArgOption(\"none\");\n          parse = ParseCommandOption(MagickLogEventOptions,MagickFalse,arg1);\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedEventType\",\n                                      option,arg1);\n          (void) SetLogEventMask(arg1);\n          _image_info->debug=IsEventLogging();   /* extract logging*/\n          cli_wand->wand.debug=IsEventLogging();\n          break;\n        }\n      if (LocaleCompare(\"define\",option+1) == 0)\n        {\n          if (LocaleNCompare(arg1,\"registry:\",9) == 0)\n            {\n              if (IfSetOption)\n                (void) DefineImageRegistry(StringRegistryType,arg1+9,_exception);\n              else\n                (void) DeleteImageRegistry(arg1+9);\n              break;\n            }\n          /* DefineImageOption() equals SetImageOption() but with '=' */\n          if (IfSetOption)\n            (void) DefineImageOption(_image_info,arg1);\n          else if (DeleteImageOption(_image_info,arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"NoSuchOption\",option,arg1);\n          break;\n        }\n      if (LocaleCompare(\"delay\",option+1) == 0)\n        {\n          /* Only used for new images via AcquireImage()\n             FUTURE: Option should also be used for \"-morph\" (color morphing)\n          */\n          arg1=ArgOption(\"0\");\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) SetImageOption(_image_info,option+1,arg1);\n          break;\n        }\n      if (LocaleCompare(\"density\",option+1) == 0)\n        {\n          /* FUTURE: strings used in _image_info attr and _draw_info!\n             Basically as density can be in a XxY form!\n\n             SyncImageSettings() used to set per-image attribute.\n          */\n          if (IfSetOption && (IsGeometry(arg1) == MagickFalse))\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          (void) CloneString(&_image_info->density,ArgOption(NULL));\n          (void) CloneString(&_draw_info->density,_image_info->density);\n          break;\n        }\n      if (LocaleCompare(\"depth\",option+1) == 0)\n        {\n          /* This is also a SimpleImageOperator! for 8->16 vaule trunc !!!!\n             SyncImageSettings() used to set per-image attribute.\n          */\n          if (IfSetOption && (IsGeometry(arg1) == MagickFalse))\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          _image_info->depth=IfSetOption?StringToUnsignedLong(arg1)\n                                       :MAGICKCORE_QUANTUM_DEPTH;\n          break;\n        }\n      if (LocaleCompare(\"direction\",option+1) == 0)\n        {\n          /* Image Option is only used to set _draw_info */\n          arg1=ArgOption(\"undefined\");\n          parse = ParseCommandOption(MagickDirectionOptions,MagickFalse,arg1);\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedDirectionType\",\n                                      option,arg1);\n          _draw_info->direction=(DirectionType) parse;\n          (void) SetImageOption(_image_info,option+1,arg1);\n          break;\n        }\n      if (LocaleCompare(\"display\",option+1) == 0)\n        {\n          (void) CloneString(&_image_info->server_name,ArgOption(NULL));\n          (void) CloneString(&_draw_info->server_name,_image_info->server_name);\n          break;\n        }\n      if (LocaleCompare(\"dispose\",option+1) == 0)\n        {\n          /* only used in setting new images */\n          arg1=ArgOption(\"undefined\");\n          parse = ParseCommandOption(MagickDisposeOptions,MagickFalse,arg1);\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedDisposeMethod\",\n                                      option,arg1);\n          (void) SetImageOption(_image_info,option+1,ArgOption(\"undefined\"));\n          break;\n        }\n      if (LocaleCompare(\"dissimilarity-threshold\",option+1) == 0)\n        {\n          /* FUTURE: this is only used by CompareImages() which is used\n             only by the \"compare\" CLI program at this time.  */\n          arg1=ArgOption(DEFAULT_DISSIMILARITY_THRESHOLD);\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) SetImageOption(_image_info,option+1,arg1);\n          break;\n        }\n      if (LocaleCompare(\"dither\",option+1) == 0)\n        {\n          /* _image_info attr (on/off), _quantize_info attr (on/off)\n             but also ImageInfo and _quantize_info method!\n             FUTURE: merge the duality of the dithering options\n          */\n          _image_info->dither = ArgBoolean;\n          (void) SetImageOption(_image_info,option+1,ArgOption(\"none\"));\n          _quantize_info->dither_method=(DitherMethod) ParseCommandOption(\n             MagickDitherOptions,MagickFalse,ArgOption(\"none\"));\n          if (_quantize_info->dither_method == NoDitherMethod)\n            _image_info->dither = MagickFalse;\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'e':\n    {\n      if (LocaleCompare(\"encoding\",option+1) == 0)\n        {\n          (void) CloneString(&_draw_info->encoding,ArgOption(\"undefined\"));\n          (void) SetImageOption(_image_info,option+1,_draw_info->encoding);\n          break;\n        }\n      if (LocaleCompare(\"endian\",option+1) == 0)\n        {\n          /* Both _image_info attr and ImageInfo */\n          arg1 = ArgOption(\"undefined\");\n          parse = ParseCommandOption(MagickEndianOptions,MagickFalse,arg1);\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedEndianType\",\n                                      option,arg1);\n          /* FUTURE: check alloc/free of endian string!  - remove? */\n          _image_info->endian=(EndianType) (*arg1);\n          (void) SetImageOption(_image_info,option+1,arg1);\n          break;\n        }\n      if (LocaleCompare(\"extract\",option+1) == 0)\n        {\n          (void) CloneString(&_image_info->extract,ArgOption(NULL));\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'f':\n    {\n      if (LocaleCompare(\"family\",option+1) == 0)\n        {\n          (void) CloneString(&_draw_info->family,ArgOption(NULL));\n          break;\n        }\n      if (LocaleCompare(\"features\",option+1) == 0)\n        {\n          (void) SetImageOption(_image_info,\"identify:features\",\n            ArgBooleanString);\n          if (IfSetOption)\n            (void) SetImageArtifact(_image,\"verbose\",\"true\");\n          break;\n        }\n      if (LocaleCompare(\"fill\",option+1) == 0)\n        {\n          /* Set \"fill\" OR \"fill-pattern\" in _draw_info\n             The original fill color is preserved if a fill-pattern is given.\n             That way it does not effect other operations that directly using\n             the fill color and, can be retored using \"+tile\".\n          */\n          MagickBooleanType\n            status;\n\n          ExceptionInfo\n            *sans;\n\n          PixelInfo\n            color;\n\n          arg1 = ArgOption(\"none\");  /* +fill turns it off! */\n          (void) SetImageOption(_image_info,option+1,arg1);\n          if (_draw_info->fill_pattern != (Image *) NULL)\n            _draw_info->fill_pattern=DestroyImage(_draw_info->fill_pattern);\n\n          /* is it a color or a image? -- ignore exceptions */\n          sans=AcquireExceptionInfo();\n          status=QueryColorCompliance(arg1,AllCompliance,&color,sans);\n          sans=DestroyExceptionInfo(sans);\n\n          if (status == MagickFalse)\n            _draw_info->fill_pattern=GetImageCache(_image_info,arg1,_exception);\n          else\n            _draw_info->fill=color;\n          break;\n        }\n      if (LocaleCompare(\"filter\",option+1) == 0)\n        {\n          /* SyncImageSettings() used to set per-image attribute. */\n          arg1 = ArgOption(\"undefined\");\n          parse = ParseCommandOption(MagickFilterOptions,MagickFalse,arg1);\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedImageFilter\",\n                                      option,arg1);\n          (void) SetImageOption(_image_info,option+1,arg1);\n          break;\n        }\n      if (LocaleCompare(\"font\",option+1) == 0)\n        {\n          (void) CloneString(&_draw_info->font,ArgOption(NULL));\n          (void) CloneString(&_image_info->font,_draw_info->font);\n          break;\n        }\n      if (LocaleCompare(\"format\",option+1) == 0)\n        {\n          /* FUTURE: why the ping test, you could set ping after this! */\n          /*\n          register const char\n            *q;\n\n          for (q=strchr(arg1,'%'); q != (char *) NULL; q=strchr(q+1,'%'))\n            if (strchr(\"Agkrz@[#\",*(q+1)) != (char *) NULL)\n              _image_info->ping=MagickFalse;\n          */\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          break;\n        }\n      if (LocaleCompare(\"fuzz\",option+1) == 0)\n        {\n          /* Option used to set image fuzz! unless blank canvas (from color)\n             Image attribute used for color compare operations\n             SyncImageSettings() used to set per-image attribute.\n\n             FUTURE: Can't find anything else using _image_info->fuzz directly!\n                     convert structure attribute to 'option' string\n          */\n          arg1=ArgOption(\"0\");\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          _image_info->fuzz=StringToDoubleInterval(arg1,(double)\n                QuantumRange+1.0);\n          (void) SetImageOption(_image_info,option+1,arg1);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'g':\n    {\n      if (LocaleCompare(\"gravity\",option+1) == 0)\n        {\n          /* SyncImageSettings() used to set per-image attribute. */\n          arg1 = ArgOption(\"none\");\n          parse = ParseCommandOption(MagickGravityOptions,MagickFalse,arg1);\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedGravityType\",\n                                      option,arg1);\n          _draw_info->gravity=(GravityType) parse;\n          (void) SetImageOption(_image_info,option+1,arg1);\n          break;\n        }\n      if (LocaleCompare(\"green-primary\",option+1) == 0)\n        {\n          /* Image chromaticity X,Y  NB: Y=X if Y not defined\n             SyncImageSettings() used to set per-image attribute.\n             Used directly by many coders\n          */\n          arg1=ArgOption(\"0.0\");\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) SetImageOption(_image_info,option+1,arg1);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'h':\n    {\n      if (LocaleCompare(\"highlight-color\",option+1) == 0)\n        {\n          /* FUTURE: this is only used by CompareImages() which is used\n             only by the \"compare\" CLI program at this time.  */\n          (void) SetImageOption(_image_info,\"compare:highlight-color\",\n            ArgOption(NULL));\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'i':\n    {\n      if (LocaleCompare(\"intensity\",option+1) == 0)\n        {\n          arg1 = ArgOption(\"undefined\");\n          parse = ParseCommandOption(MagickPixelIntensityOptions,MagickFalse,\n            arg1);\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedIntensityType\",\n              option,arg1);\n          (void) SetImageOption(_image_info,option+1,arg1);\n          break;\n        }\n      if (LocaleCompare(\"intent\",option+1) == 0)\n        {\n          /* Only used by coders: MIFF, MPC, BMP, PNG\n             and for image profile call to AcquireTransformThreadSet()\n             SyncImageSettings() used to set per-image attribute.\n          */\n          arg1 = ArgOption(\"undefined\");\n          parse = ParseCommandOption(MagickIntentOptions,MagickFalse,arg1);\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedIntentType\",\n                                      option,arg1);\n          (void) SetImageOption(_image_info,option+1,arg1);\n          break;\n        }\n      if (LocaleCompare(\"interlace\",option+1) == 0)\n        {\n          /* _image_info is directly used by coders (so why an image setting?)\n             SyncImageSettings() used to set per-image attribute.\n          */\n          arg1 = ArgOption(\"undefined\");\n          parse = ParseCommandOption(MagickInterlaceOptions,MagickFalse,arg1);\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedInterlaceType\",\n                                      option,arg1);\n          _image_info->interlace=(InterlaceType) parse;\n          (void) SetImageOption(_image_info,option+1,arg1);\n          break;\n        }\n      if (LocaleCompare(\"interline-spacing\",option+1) == 0)\n        {\n          if (IfSetOption && (IsGeometry(arg1) == MagickFalse))\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) SetImageOption(_image_info,option+1, ArgOption(NULL));\n          _draw_info->interline_spacing=StringToDouble(ArgOption(\"0\"),\n               (char **) NULL);\n          break;\n        }\n      if (LocaleCompare(\"interpolate\",option+1) == 0)\n        {\n          /* SyncImageSettings() used to set per-image attribute. */\n          arg1 = ArgOption(\"undefined\");\n          parse = ParseCommandOption(MagickInterpolateOptions,MagickFalse,arg1);\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedInterpolateMethod\",\n                                      option,arg1);\n          (void) SetImageOption(_image_info,option+1,arg1);\n          break;\n        }\n      if (LocaleCompare(\"interword-spacing\",option+1) == 0)\n        {\n          if (IfSetOption && (IsGeometry(arg1) == MagickFalse))\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) SetImageOption(_image_info,option+1, ArgOption(NULL));\n          _draw_info->interword_spacing=StringToDouble(ArgOption(\"0\"),(char **) NULL);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'k':\n    {\n      if (LocaleCompare(\"kerning\",option+1) == 0)\n        {\n          if (IfSetOption && (IsGeometry(arg1) == MagickFalse))\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          _draw_info->kerning=StringToDouble(ArgOption(\"0\"),(char **) NULL);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'l':\n    {\n      if (LocaleCompare(\"label\",option+1) == 0)\n        {\n          /* only used for new images - not in SyncImageOptions() */\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          break;\n        }\n      if (LocaleCompare(\"limit\",option+1) == 0)\n        {\n          MagickSizeType\n            limit;\n\n          limit=MagickResourceInfinity;\n          parse= ParseCommandOption(MagickResourceOptions,MagickFalse,arg1);\n          if ( parse < 0 )\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedResourceType\",\n                option,arg1);\n          if (LocaleCompare(\"unlimited\",arg2) != 0)\n            limit=(MagickSizeType) SiPrefixToDoubleInterval(arg2,100.0);\n          (void) SetMagickResourceLimit((ResourceType)parse,limit);\n          break;\n        }\n      if (LocaleCompare(\"log\",option+1) == 0)\n        {\n          if (IfSetOption) {\n            if ((strchr(arg1,'%') == (char *) NULL))\n              CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n            (void) SetLogFormat(arg1);\n          }\n          break;\n        }\n      if (LocaleCompare(\"lowlight-color\",option+1) == 0)\n        {\n          /* FUTURE: this is only used by CompareImages() which is used\n             only by the \"compare\" CLI program at this time.  */\n          (void) SetImageOption(_image_info,\"compare:lowlight-color\",\n            ArgOption(NULL));\n          break;\n        }\n      if (LocaleCompare(\"loop\",option+1) == 0)\n        {\n          /* SyncImageSettings() used to set per-image attribute. */\n          arg1=ArgOption(\"0\");\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) SetImageOption(_image_info,option+1,arg1);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'm':\n    {\n      if (LocaleCompare(\"mattecolor\",option+1) == 0)\n        {\n          /* SyncImageSettings() used to set per-image attribute. */\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          (void) QueryColorCompliance(ArgOption(MogrifyAlphaColor),\n            AllCompliance,&_image_info->matte_color,_exception);\n          break;\n        }\n      if (LocaleCompare(\"metric\",option+1) == 0)\n        {\n          /* FUTURE: this is only used by CompareImages() which is used\n             only by the \"compare\" CLI program at this time.  */\n          parse=ParseCommandOption(MagickMetricOptions,MagickFalse,arg1);\n          if ( parse < 0 )\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedMetricType\",\n                option,arg1);\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          break;\n        }\n      if (LocaleCompare(\"moments\",option+1) == 0)\n        {\n          (void) SetImageOption(_image_info,\"identify:moments\",\n            ArgBooleanString);\n          if (IfSetOption)\n            (void) SetImageArtifact(_image,\"verbose\",\"true\");\n          break;\n        }\n      if (LocaleCompare(\"monitor\",option+1) == 0)\n        {\n          (void) SetImageInfoProgressMonitor(_image_info, IfSetOption?\n                MonitorProgress: (MagickProgressMonitor) NULL, (void *) NULL);\n          break;\n        }\n      if (LocaleCompare(\"monochrome\",option+1) == 0)\n        {\n          /* Setting (used by some input coders!) -- why?\n             Warning: This is also Special '-type' SimpleOperator\n          */\n          _image_info->monochrome= ArgBoolean;\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'o':\n    {\n      if (LocaleCompare(\"orient\",option+1) == 0)\n        {\n          /* Is not used when defining for new images.\n             This makes it more of a 'operation' than a setting\n             FUTURE: make set meta-data operator instead.\n             SyncImageSettings() used to set per-image attribute.\n          */\n          parse=ParseCommandOption(MagickOrientationOptions,MagickFalse,\n               ArgOption(\"undefined\"));\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedImageOrientation\",\n                                      option,arg1);\n          _image_info->orientation=(OrientationType)parse;\n          (void) SetImageOption(_image_info,option+1, ArgOption(NULL));\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'p':\n    {\n      if (LocaleCompare(\"page\",option+1) == 0)\n        {\n          /* Only used for new images and image generators.\n             SyncImageSettings() used to set per-image attribute. ?????\n             That last is WRONG!!!!\n             FUTURE: adjust named 'page' sizes according density\n          */\n          char\n            *canonical_page,\n            page[MagickPathExtent];\n\n          const char\n            *image_option;\n\n          MagickStatusType\n            flags;\n\n          RectangleInfo\n            geometry;\n\n          if (!IfSetOption)\n            {\n              (void) DeleteImageOption(_image_info,option+1);\n              (void) CloneString(&_image_info->page,(char *) NULL);\n              break;\n            }\n          (void) memset(&geometry,0,sizeof(geometry));\n          image_option=GetImageOption(_image_info,\"page\");\n          if (image_option != (const char *) NULL)\n            flags=ParseAbsoluteGeometry(image_option,&geometry);\n          canonical_page=GetPageGeometry(arg1);\n          flags=ParseAbsoluteGeometry(canonical_page,&geometry);\n          canonical_page=DestroyString(canonical_page);\n          (void) FormatLocaleString(page,MagickPathExtent,\"%lux%lu\",\n            (unsigned long) geometry.width,(unsigned long) geometry.height);\n          if (((flags & XValue) != 0) || ((flags & YValue) != 0))\n            (void) FormatLocaleString(page,MagickPathExtent,\"%lux%lu%+ld%+ld\",\n              (unsigned long) geometry.width,(unsigned long) geometry.height,\n              (long) geometry.x,(long) geometry.y);\n          (void) SetImageOption(_image_info,option+1,page);\n          (void) CloneString(&_image_info->page,page);\n          break;\n        }\n      if (LocaleCompare(\"ping\",option+1) == 0)\n        {\n          _image_info->ping = ArgBoolean;\n          break;\n        }\n      if (LocaleCompare(\"pointsize\",option+1) == 0)\n        {\n          if (IfSetOption) {\n            if (IsGeometry(arg1) == MagickFalse)\n              CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n            _image_info->pointsize =\n            _draw_info->pointsize =\n              StringToDouble(arg1,(char **) NULL);\n          }\n          else {\n            _image_info->pointsize=0.0; /* unset pointsize */\n            _draw_info->pointsize=12.0;\n          }\n          break;\n        }\n      if (LocaleCompare(\"precision\",option+1) == 0)\n        {\n          arg1=ArgOption(\"-1\");\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) SetMagickPrecision(StringToInteger(arg1));\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'q':\n    {\n      if (LocaleCompare(\"quality\",option+1) == 0)\n        {\n          if (IfSetOption && (IsGeometry(arg1) == MagickFalse))\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          _image_info->quality= IfSetOption ? StringToUnsignedLong(arg1)\n                                            : UNDEFINED_COMPRESSION_QUALITY;\n          (void) SetImageOption(_image_info,option+1,ArgOption(\"0\"));\n          break;\n        }\n      if (LocaleCompare(\"quantize\",option+1) == 0)\n        {\n          /* Just a set direct in _quantize_info */\n          arg1=ArgOption(\"undefined\");\n          parse=ParseCommandOption(MagickColorspaceOptions,MagickFalse,arg1);\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedColorspace\",\n                 option,arg1);\n          _quantize_info->colorspace=(ColorspaceType)parse;\n          break;\n        }\n      if (LocaleCompare(\"quiet\",option+1) == 0)\n        {\n          /* FUTURE: if two -quiet is performed you can not do +quiet!\n             This needs to be checked over thoughly.\n          */\n          static WarningHandler\n            warning_handler = (WarningHandler) NULL;\n\n          WarningHandler\n            tmp = SetWarningHandler((WarningHandler) NULL);\n\n          if ( tmp != (WarningHandler) NULL)\n            warning_handler = tmp; /* remember the old handler */\n          if (!IfSetOption)        /* set the old handler */\n            warning_handler=SetWarningHandler(warning_handler);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'r':\n    {\n      if (LocaleCompare(\"red-primary\",option+1) == 0)\n        {\n          /* Image chromaticity X,Y  NB: Y=X if Y not defined\n             Used by many coders\n             SyncImageSettings() used to set per-image attribute.\n          */\n          arg1=ArgOption(\"0.0\");\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) SetImageOption(_image_info,option+1,arg1);\n          break;\n        }\n      if (LocaleCompare(\"regard-warnings\",option+1) == 0)\n        /* FUTURE: to be replaced by a 'fatal-level' type setting */\n        break;\n      if (LocaleCompare(\"render\",option+1) == 0)\n        {\n          /* _draw_info only setting */\n          _draw_info->render= ArgBooleanNot;\n          break;\n        }\n      if (LocaleCompare(\"respect-parenthesis\",option+1) == 0)\n        {\n          /* link image and setting stacks - option is itself saved on stack! */\n          (void) SetImageOption(_image_info,option+1,ArgBooleanString);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 's':\n    {\n      if (LocaleCompare(\"sampling-factor\",option+1) == 0)\n        {\n          /* FUTURE: should be converted to jpeg:sampling_factor */\n          if (IfSetOption && (IsGeometry(arg1) == MagickFalse))\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) CloneString(&_image_info->sampling_factor,ArgOption(NULL));\n          break;\n        }\n      if (LocaleCompare(\"scene\",option+1) == 0)\n        {\n          /* SyncImageSettings() used to set this as a per-image attribute.\n             What ??? Why ????\n          */\n          if (IfSetOption && (IsGeometry(arg1) == MagickFalse))\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          _image_info->scene=StringToUnsignedLong(ArgOption(\"0\"));\n          break;\n        }\n      if (LocaleCompare(\"seed\",option+1) == 0)\n        {\n          if (IfSetOption && (IsGeometry(arg1) == MagickFalse))\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          SetRandomSecretKey(\n               IfSetOption ? (unsigned long) StringToUnsignedLong(arg1)\n                           : (unsigned long) time((time_t *) NULL));\n          break;\n        }\n      if (LocaleCompare(\"size\",option+1) == 0)\n        {\n          /* FUTURE: string in _image_info -- convert to Option ???\n             Look at the special handling for \"size\" in SetImageOption()\n           */\n          (void) CloneString(&_image_info->size,ArgOption(NULL));\n          break;\n        }\n      if (LocaleCompare(\"stretch\",option+1) == 0)\n        {\n          arg1=ArgOption(\"undefined\");\n          parse = ParseCommandOption(MagickStretchOptions,MagickFalse,arg1);\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedStretchType\",\n                 option,arg1);\n          _draw_info->stretch=(StretchType) parse;\n          break;\n        }\n      if (LocaleCompare(\"stroke\",option+1) == 0)\n        {\n          /* set stroke color OR stroke-pattern\n             UPDATE: ensure stroke color is not destroyed is a pattern\n             is given. Just in case the color is also used for other purposes.\n           */\n          MagickBooleanType\n            status;\n\n          ExceptionInfo\n            *sans;\n\n          PixelInfo\n            color;\n\n          arg1 = ArgOption(\"none\");  /* +fill turns it off! */\n          (void) SetImageOption(_image_info,option+1,arg1);\n          if (_draw_info->stroke_pattern != (Image *) NULL)\n            _draw_info->stroke_pattern=DestroyImage(_draw_info->stroke_pattern);\n\n          /* is it a color or a image? -- ignore exceptions */\n          sans=AcquireExceptionInfo();\n          status=QueryColorCompliance(arg1,AllCompliance,&color,sans);\n          sans=DestroyExceptionInfo(sans);\n\n          if (status == MagickFalse)\n            _draw_info->stroke_pattern=GetImageCache(_image_info,arg1,_exception);\n          else\n            _draw_info->stroke=color;\n          break;\n        }\n      if (LocaleCompare(\"strokewidth\",option+1) == 0)\n        {\n          if (IfSetOption && (IsGeometry(arg1) == MagickFalse))\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          _draw_info->stroke_width=StringToDouble(ArgOption(\"1.0\"),\n               (char **) NULL);\n          break;\n        }\n      if (LocaleCompare(\"style\",option+1) == 0)\n        {\n          arg1=ArgOption(\"undefined\");\n          parse = ParseCommandOption(MagickStyleOptions,MagickFalse,arg1);\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedStyleType\",\n                 option,arg1);\n          _draw_info->style=(StyleType) parse;\n          break;\n        }\n#if 0\n      if (LocaleCompare(\"subimage-search\",option+1) == 0)\n        {\n        /* FUTURE: this is only used by CompareImages() which is used\n            only by the \"compare\" CLI program at this time.  */\n          (void) SetImageOption(_image_info,option+1,ArgBooleanString);\n          break;\n        }\n#endif\n      if (LocaleCompare(\"synchronize\",option+1) == 0)\n        {\n          /* FUTURE: syncronize to storage - but what does that mean? */\n          _image_info->synchronize = ArgBoolean;\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 't':\n    {\n      if (LocaleCompare(\"taint\",option+1) == 0)\n        {\n          /* SyncImageSettings() used to set per-image attribute. */\n          (void) SetImageOption(_image_info,option+1,ArgBooleanString);\n          break;\n        }\n      if (LocaleCompare(\"texture\",option+1) == 0)\n        {\n          /* Note: arguments do not have percent escapes expanded */\n          /* FUTURE: move _image_info string to option splay-tree\n             Other than \"montage\" what uses \"texture\" ????\n          */\n          (void) CloneString(&_image_info->texture,ArgOption(NULL));\n          break;\n        }\n      if (LocaleCompare(\"tile\",option+1) == 0)\n        {\n          /* Note: arguments do not have percent escapes expanded */\n          _draw_info->fill_pattern=IfSetOption\n                                 ?GetImageCache(_image_info,arg1,_exception)\n                                 :DestroyImage(_draw_info->fill_pattern);\n          break;\n        }\n      if (LocaleCompare(\"tile-offset\",option+1) == 0)\n        {\n          /* SyncImageSettings() used to set per-image attribute. ??? */\n          arg1=ArgOption(\"0\");\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) SetImageOption(_image_info,option+1,arg1);\n          break;\n        }\n      if (LocaleCompare(\"transparent-color\",option+1) == 0)\n        {\n          /* FUTURE: both _image_info attribute & ImageOption in use!\n             _image_info only used for generating new images.\n             SyncImageSettings() used to set per-image attribute.\n\n             Note that +transparent-color, means fall-back to image\n             attribute so ImageOption is deleted, not set to a default.\n          */\n          if (IfSetOption && (IsGeometry(arg1) == MagickFalse))\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          (void) QueryColorCompliance(ArgOption(\"none\"),AllCompliance,\n              &_image_info->transparent_color,_exception);\n          break;\n        }\n      if (LocaleCompare(\"treedepth\",option+1) == 0)\n        {\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          _quantize_info->tree_depth=StringToUnsignedLong(ArgOption(\"0\"));\n          break;\n        }\n      if (LocaleCompare(\"type\",option+1) == 0)\n        {\n          /* SyncImageSettings() used to set per-image attribute. */\n          parse=ParseCommandOption(MagickTypeOptions,MagickFalse,\n               ArgOption(\"undefined\"));\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedImageType\",\n                 option,arg1);\n          _image_info->type=(ImageType) parse;\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'u':\n    {\n      if (LocaleCompare(\"undercolor\",option+1) == 0)\n        {\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          (void) QueryColorCompliance(ArgOption(\"none\"),AllCompliance,\n               &_draw_info->undercolor,_exception);\n          break;\n        }\n      if (LocaleCompare(\"units\",option+1) == 0)\n        {\n          /* SyncImageSettings() used to set per-image attribute.\n             Should this effect _draw_info X and Y resolution?\n             FUTURE: this probably should be part of the density setting\n          */\n          parse=ParseCommandOption(MagickResolutionOptions,MagickFalse,\n               ArgOption(\"undefined\"));\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedUnitsType\",\n                 option,arg1);\n          _image_info->units=(ResolutionType) parse;\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'v':\n    {\n      if (LocaleCompare(\"verbose\",option+1) == 0)\n        {\n          /* FUTURE: Remember all options become image artifacts\n             _image_info->verbose is only used by coders.\n          */\n          (void) SetImageOption(_image_info,option+1,ArgBooleanString);\n          _image_info->verbose= ArgBoolean;\n          _image_info->ping=MagickFalse; /* verbose can't be a ping */\n          break;\n        }\n      if (LocaleCompare(\"virtual-pixel\",option+1) == 0)\n        {\n          /* SyncImageSettings() used to set per-image attribute.\n             This is VERY deep in the image caching structure.\n          */\n          parse=ParseCommandOption(MagickVirtualPixelOptions,MagickFalse,\n               ArgOption(\"undefined\"));\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedVirtualPixelMethod\",\n                 option,arg1);\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'w':\n    {\n      if (LocaleCompare(\"weight\",option+1) == 0)\n        {\n          ssize_t\n            weight;\n\n          weight=ParseCommandOption(MagickWeightOptions,MagickFalse,arg1);\n          if (weight == -1)\n            weight=(ssize_t) StringToUnsignedLong(arg1);\n          _draw_info->weight=(size_t) weight;\n          break;\n        }\n      if (LocaleCompare(\"white-point\",option+1) == 0)\n        {\n          /* Used as a image chromaticity setting\n             SyncImageSettings() used to set per-image attribute.\n          */\n          arg1=ArgOption(\"0.0\");\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) SetImageOption(_image_info,option+1,arg1);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    default:\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n  }\n\n  /* clean up percent escape interpreted strings */\n  if ((arg1 && arg1n) && (arg1 != arg1n ))\n    arg1=DestroyString((char *) arg1);\n  if ((arg2 && arg2n) && (arg2 != arg2n ))\n    arg2=DestroyString((char *) arg2);\n\n#undef _image_info\n#undef _exception\n#undef _draw_info\n#undef _quantize_info\n#undef IfSetOption\n#undef ArgBoolean\n#undef ArgBooleanNot\n#undef ArgBooleanString\n#undef ArgOption\n\n  return;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+     C L I S i m p l e O p e r a t o r I m a g e s                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CLISimpleOperatorImages() applys one simple image operation given to all\n%  the images in the CLI wand, using any per-image or global settings that was\n%  previously saved in the CLI wand.\n%\n%  It is assumed that any such settings are up-to-date.\n%\n%  The format of the WandSimpleOperatorImages method is:\n%\n%    MagickBooleanType CLISimpleOperatorImages(MagickCLI *cli_wand,const char *option,\n%      const char *arg1, const char *arg2,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o cli_wand: structure holding settings and images to be operated on\n%\n%    o option:  The option string for the operation\n%\n%    o arg1, arg2: optional argument strings to the operation\n%\n*/\n\n/*\n  CLISimpleOperatorImage() is an Internal subrountine to apply one simple\n  image operation to the current image pointed to by the CLI wand.\n\n  The image in the list may be modified in three different ways...\n    * directly modified (EG: -negate, -gamma, -level, -annotate, -draw),\n    * replaced by a new image (EG: -spread, -resize, -rotate, -morphology)\n    * one image replace by a list of images (-separate and -crop only!)\n\n  In each case the result replaces the single original image in the list, as\n  well as the pointer to the modified image (last image added if replaced by a\n  list of images) is returned.\n\n  As the image pointed to may be replaced, the first image in the list may\n  also change.  GetFirstImageInList() should be used by caller if they wish\n  return the Image pointer to the first image in list.\n*/\nstatic MagickBooleanType CLISimpleOperatorImage(MagickCLI *cli_wand,\n  const char *option, const char *arg1n, const char *arg2n,\n  ExceptionInfo *exception)\n{\n  Image *\n    new_image;\n\n  GeometryInfo\n    geometry_info;\n\n  RectangleInfo\n    geometry;\n\n  MagickStatusType\n    flags;\n\n  ssize_t\n    parse;\n\n  const char    /* percent escaped versions of the args */\n    *arg1,\n    *arg2;\n\n#define _image_info       (cli_wand->wand.image_info)\n#define _image            (cli_wand->wand.images)\n#define _exception        (cli_wand->wand.exception)\n#define _draw_info        (cli_wand->draw_info)\n#define _quantize_info    (cli_wand->quantize_info)\n#define _process_flags    (cli_wand->process_flags)\n#define _option_type      ((CommandOptionFlags) cli_wand->command->flags)\n#define IfNormalOp        (*option=='-')\n#define IfPlusOp          (*option!='-')\n#define IsNormalOp        IfNormalOp ? MagickTrue : MagickFalse\n#define IsPlusOp          IfNormalOp ? MagickFalse : MagickTrue\n\n  assert(cli_wand != (MagickCLI *) NULL);\n  assert(cli_wand->signature == MagickWandSignature);\n  assert(cli_wand->wand.signature == MagickWandSignature);\n  assert(_image != (Image *) NULL);             /* an image must be present */\n  if (cli_wand->wand.debug != MagickFalse)\n    (void) LogMagickEvent(WandEvent,GetMagickModule(),\"%s\",cli_wand->wand.name);\n\n  arg1 = arg1n,\n  arg2 = arg2n;\n\n  /* Interpret Percent Escapes in Arguments - using first image */\n  if ( (((_process_flags & ProcessInterpretProperities) != 0 )\n        || ((_option_type & AlwaysInterpretArgsFlag) != 0)\n       )  && ((_option_type & NeverInterpretArgsFlag) == 0) ) {\n    /* Interpret Percent escapes in argument 1 */\n    if (arg1n != (char *) NULL) {\n      arg1=InterpretImageProperties(_image_info,_image,arg1n,_exception);\n      if (arg1 == (char *) NULL) {\n        CLIWandException(OptionWarning,\"InterpretPropertyFailure\",option);\n        arg1=arg1n;  /* use the given argument as is */\n      }\n    }\n    if (arg2n != (char *) NULL) {\n      arg2=InterpretImageProperties(_image_info,_image,arg2n,_exception);\n      if (arg2 == (char *) NULL) {\n        CLIWandException(OptionWarning,\"InterpretPropertyFailure\",option);\n        arg2=arg2n;  /* use the given argument as is */\n      }\n    }\n  }\n#undef _process_flags\n#undef _option_type\n\n#if 0\n  (void) FormatLocaleFile(stderr,\n    \"CLISimpleOperatorImage: \\\"%s\\\" \\\"%s\\\" \\\"%s\\\"\\n\",option,arg1,arg2);\n#endif\n\n  new_image = (Image *) NULL; /* the replacement image, if not null at end */\n  SetGeometryInfo(&geometry_info);\n\n  switch (*(option+1))\n  {\n    case 'a':\n    {\n      if (LocaleCompare(\"adaptive-blur\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=1.0;\n          new_image=AdaptiveBlurImage(_image,geometry_info.rho,\n            geometry_info.sigma,_exception);\n          break;\n        }\n      if (LocaleCompare(\"adaptive-resize\",option+1) == 0)\n        {\n          /* FUTURE: Roll into a resize special operator */\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) ParseRegionGeometry(_image,arg1,&geometry,_exception);\n          new_image=AdaptiveResizeImage(_image,geometry.width,geometry.height,\n            _exception);\n          break;\n        }\n      if (LocaleCompare(\"adaptive-sharpen\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=1.0;\n          new_image=AdaptiveSharpenImage(_image,geometry_info.rho,\n            geometry_info.sigma,_exception);\n          break;\n        }\n      if (LocaleCompare(\"alpha\",option+1) == 0)\n        {\n          parse=ParseCommandOption(MagickAlphaChannelOptions,MagickFalse,arg1);\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedAlphaChannelOption\",\n              option,arg1);\n          (void) SetImageAlphaChannel(_image,(AlphaChannelOption) parse,\n            _exception);\n          break;\n        }\n      if (LocaleCompare(\"annotate\",option+1) == 0)\n        {\n          char\n            geometry[MagickPathExtent];\n\n          SetGeometryInfo(&geometry_info);\n          flags=ParseGeometry(arg1,&geometry_info);\n          if (flags == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=geometry_info.rho;\n          (void) CloneString(&_draw_info->text,arg2);\n          (void) FormatLocaleString(geometry,MagickPathExtent,\"%+f%+f\",\n            geometry_info.xi,geometry_info.psi);\n          (void) CloneString(&_draw_info->geometry,geometry);\n          _draw_info->affine.sx=cos(DegreesToRadians(\n            fmod(geometry_info.rho,360.0)));\n          _draw_info->affine.rx=sin(DegreesToRadians(\n            fmod(geometry_info.rho,360.0)));\n          _draw_info->affine.ry=(-sin(DegreesToRadians(\n            fmod(geometry_info.sigma,360.0))));\n          _draw_info->affine.sy=cos(DegreesToRadians(\n            fmod(geometry_info.sigma,360.0)));\n          (void) AnnotateImage(_image,_draw_info,_exception);\n          GetAffineMatrix(&_draw_info->affine);\n          break;\n        }\n      if (LocaleCompare(\"auto-gamma\",option+1) == 0)\n        {\n          (void) AutoGammaImage(_image,_exception);\n          break;\n        }\n      if (LocaleCompare(\"auto-level\",option+1) == 0)\n        {\n          (void) AutoLevelImage(_image,_exception);\n          break;\n        }\n      if (LocaleCompare(\"auto-orient\",option+1) == 0)\n        {\n          new_image=AutoOrientImage(_image,_image->orientation,_exception);\n          break;\n        }\n      if (LocaleCompare(\"auto-threshold\",option+1) == 0)\n        {\n          AutoThresholdMethod\n            method;\n\n          method=(AutoThresholdMethod) ParseCommandOption(\n            MagickAutoThresholdOptions,MagickFalse,arg1);\n          (void) AutoThresholdImage(_image,method,_exception);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'b':\n    {\n      if (LocaleCompare(\"black-threshold\",option+1) == 0)\n        {\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) BlackThresholdImage(_image,arg1,_exception);\n          break;\n        }\n      if (LocaleCompare(\"blue-shift\",option+1) == 0)\n        {\n          geometry_info.rho=1.5;\n          if (IfNormalOp) {\n            flags=ParseGeometry(arg1,&geometry_info);\n            if ((flags & RhoValue) == 0)\n              CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          }\n          new_image=BlueShiftImage(_image,geometry_info.rho,_exception);\n          break;\n        }\n      if (LocaleCompare(\"blur\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=1.0;\n          new_image=BlurImage(_image,geometry_info.rho,geometry_info.sigma,\n           _exception);\n          break;\n        }\n      if (LocaleCompare(\"border\",option+1) == 0)\n        {\n          CompositeOperator\n            compose;\n\n          const char*\n            value;\n\n          flags=ParsePageGeometry(_image,arg1,&geometry,_exception);\n          if ((flags & (WidthValue | HeightValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          compose=OverCompositeOp;\n          value=GetImageOption(_image_info,\"compose\");\n          if (value != (const char *) NULL)\n            compose=(CompositeOperator) ParseCommandOption(MagickComposeOptions,\n              MagickFalse,value);\n          new_image=BorderImage(_image,&geometry,compose,_exception);\n          break;\n        }\n      if (LocaleCompare(\"brightness-contrast\",option+1) == 0)\n        {\n          double\n            brightness,\n            contrast;\n\n          GeometryInfo\n            geometry_info;\n\n          MagickStatusType\n            flags;\n\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & RhoValue) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          brightness=geometry_info.rho;\n          contrast=0.0;\n          if ((flags & SigmaValue) != 0)\n            contrast=geometry_info.sigma;\n          (void) BrightnessContrastImage(_image,brightness,contrast,\n            _exception);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'c':\n    {\n      if (LocaleCompare(\"canny\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=1.0;\n          if ((flags & XiValue) == 0)\n            geometry_info.xi=10;\n          if ((flags & PsiValue) == 0)\n            geometry_info.psi=30;\n          if ((flags & PercentValue) != 0)\n            {\n              geometry_info.xi/=100.0;\n              geometry_info.psi/=100.0;\n            }\n          new_image=CannyEdgeImage(_image,geometry_info.rho,geometry_info.sigma,\n            geometry_info.xi,geometry_info.psi,_exception);\n          break;\n        }\n      if (LocaleCompare(\"cdl\",option+1) == 0)\n        {\n          char\n            *color_correction_collection; /* Note: arguments do not have percent escapes expanded */\n\n          /*\n            Color correct with a color decision list.\n          */\n          color_correction_collection=FileToString(arg1,~0UL,_exception);\n          if (color_correction_collection == (char *) NULL)\n            break;\n          (void) ColorDecisionListImage(_image,color_correction_collection,\n            _exception);\n          break;\n        }\n      if (LocaleCompare(\"channel\",option+1) == 0)\n        {\n          if (IfPlusOp)\n            {\n              (void) SetPixelChannelMask(_image,DefaultChannels);\n              break;\n            }\n          parse=ParseChannelOption(arg1);\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedChannelType\",option,\n              arg1);\n          (void) SetPixelChannelMask(_image,(ChannelType) parse);\n          break;\n        }\n      if (LocaleCompare(\"charcoal\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=1.0;\n          if ((flags & XiValue) == 0)\n            geometry_info.xi=1.0;\n          new_image=CharcoalImage(_image,geometry_info.rho,geometry_info.sigma,\n            _exception);\n          break;\n        }\n      if (LocaleCompare(\"chop\",option+1) == 0)\n        {\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) ParseGravityGeometry(_image,arg1,&geometry,_exception);\n          new_image=ChopImage(_image,&geometry,_exception);\n          break;\n        }\n      if (LocaleCompare(\"clahe\",option+1) == 0)\n        {\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          flags=ParseGeometry(arg1,&geometry_info);\n          flags=ParseRegionGeometry(_image,arg1,&geometry,_exception);\n          (void) CLAHEImage(_image,geometry.width,geometry.height,\n            (size_t) geometry.x,geometry_info.psi,_exception);\n          break;\n        }\n      if (LocaleCompare(\"clamp\",option+1) == 0)\n        {\n          (void) ClampImage(_image,_exception);\n          break;\n        }\n      if (LocaleCompare(\"clip\",option+1) == 0)\n        {\n          if (IfNormalOp)\n            (void) ClipImage(_image,_exception);\n          else /* \"+mask\" remove the write mask */\n            (void) SetImageMask(_image,WritePixelMask,(Image *) NULL,\n              _exception);\n          break;\n        }\n      if (LocaleCompare(\"clip-mask\",option+1) == 0)\n        {\n          Image\n            *clip_mask;\n\n          if (IfPlusOp) {\n            /* use \"+clip-mask\" Remove the write mask for -clip-path */\n            (void) SetImageMask(_image,WritePixelMask,(Image *) NULL,_exception);\n            break;\n          }\n          clip_mask=GetImageCache(_image_info,arg1,_exception);\n          if (clip_mask == (Image *) NULL)\n            break;\n          (void) SetImageMask(_image,WritePixelMask,clip_mask,_exception);\n          clip_mask=DestroyImage(clip_mask);\n          break;\n        }\n      if (LocaleCompare(\"clip-path\",option+1) == 0)\n        {\n          (void) ClipImagePath(_image,arg1,IsNormalOp,_exception);\n          /* Note: Use \"+clip-mask\" remove the write mask added */\n          break;\n        }\n      if (LocaleCompare(\"colorize\",option+1) == 0)\n        {\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          new_image=ColorizeImage(_image,arg1,&_draw_info->fill,_exception);\n          break;\n        }\n      if (LocaleCompare(\"color-matrix\",option+1) == 0)\n        {\n          KernelInfo\n            *kernel;\n\n          kernel=AcquireKernelInfo(arg1,exception);\n          if (kernel == (KernelInfo *) NULL)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          new_image=ColorMatrixImage(_image,kernel,_exception);\n          kernel=DestroyKernelInfo(kernel);\n          break;\n        }\n      if (LocaleCompare(\"colors\",option+1) == 0)\n        {\n          /* Reduce the number of colors in the image.\n             FUTURE: also provide 'plus version with image 'color counts'\n          */\n          _quantize_info->number_colors=StringToUnsignedLong(arg1);\n          if (_quantize_info->number_colors == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((_image->storage_class == DirectClass) ||\n              _image->colors > _quantize_info->number_colors)\n            (void) QuantizeImage(_quantize_info,_image,_exception);\n          else\n            (void) CompressImageColormap(_image,_exception);\n          break;\n        }\n      if (LocaleCompare(\"colorspace\",option+1) == 0)\n        {\n          /* WARNING: this is both a image_info setting (already done)\n                      and a operator to change image colorspace.\n\n             FUTURE: default colorspace should be sRGB!\n             Unless some type of 'linear colorspace' mode is set.\n\n             Note that +colorspace sets \"undefined\" or no effect on\n             new images, but forces images already in memory back to RGB!\n             That seems to be a little strange!\n          */\n          (void) TransformImageColorspace(_image,\n                    IfNormalOp ? _image_info->colorspace : sRGBColorspace,\n                    _exception);\n          break;\n        }\n      if (LocaleCompare(\"connected-components\",option+1) == 0)\n        {\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          new_image=ConnectedComponentsImage(_image,(size_t)\n            StringToInteger(arg1),(CCObjectInfo **) NULL,_exception);\n          break;\n        }\n      if (LocaleCompare(\"contrast\",option+1) == 0)\n        {\n          CLIWandWarnReplaced(IfNormalOp?\"-level\":\"+level\");\n          (void) ContrastImage(_image,IsNormalOp,_exception);\n          break;\n        }\n      if (LocaleCompare(\"contrast-stretch\",option+1) == 0)\n        {\n          double\n            black_point,\n            white_point;\n\n          MagickStatusType\n            flags;\n\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & RhoValue) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          black_point=geometry_info.rho;\n          white_point=(flags & SigmaValue) != 0 ? geometry_info.sigma :\n            black_point;\n          if ((flags & PercentValue) != 0) {\n              black_point*=(double) _image->columns*_image->rows/100.0;\n              white_point*=(double) _image->columns*_image->rows/100.0;\n            }\n          white_point=(double) _image->columns*_image->rows-white_point;\n          (void) ContrastStretchImage(_image,black_point,white_point,\n            _exception);\n          break;\n        }\n      if (LocaleCompare(\"convolve\",option+1) == 0)\n        {\n          double\n            gamma;\n\n          KernelInfo\n            *kernel_info;\n\n          register ssize_t\n            j;\n\n          kernel_info=AcquireKernelInfo(arg1,exception);\n          if (kernel_info == (KernelInfo *) NULL)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          gamma=0.0;\n          for (j=0; j < (ssize_t) (kernel_info->width*kernel_info->height); j++)\n            gamma+=kernel_info->values[j];\n          gamma=1.0/(fabs((double) gamma) <= MagickEpsilon ? 1.0 : gamma);\n          for (j=0; j < (ssize_t) (kernel_info->width*kernel_info->height); j++)\n            kernel_info->values[j]*=gamma;\n          new_image=MorphologyImage(_image,CorrelateMorphology,1,kernel_info,\n            _exception);\n          kernel_info=DestroyKernelInfo(kernel_info);\n          break;\n        }\n      if (LocaleCompare(\"crop\",option+1) == 0)\n        {\n          /* WARNING: This can generate multiple images! */\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          new_image=CropImageToTiles(_image,arg1,_exception);\n          break;\n        }\n      if (LocaleCompare(\"cycle\",option+1) == 0)\n        {\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) CycleColormapImage(_image,(ssize_t) StringToLong(arg1),\n            _exception);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'd':\n    {\n      if (LocaleCompare(\"decipher\",option+1) == 0)\n        {\n          /* Note: arguments do not have percent escapes expanded */\n          StringInfo\n            *passkey;\n\n          passkey=FileToStringInfo(arg1,~0UL,_exception);\n          if (passkey == (StringInfo *) NULL)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n\n          (void) PasskeyDecipherImage(_image,passkey,_exception);\n          passkey=DestroyStringInfo(passkey);\n          break;\n        }\n      if (LocaleCompare(\"depth\",option+1) == 0)\n        {\n          /* The _image_info->depth setting has already been set\n             We just need to apply it to all images in current sequence\n\n             WARNING: Depth from 8 to 16 causes 'quantum rounding to images!\n             That is it really is an operation, not a setting! Arrgghhh\n\n             FUTURE: this should not be an operator!!!\n          */\n          (void) SetImageDepth(_image,_image_info->depth,_exception);\n          break;\n        }\n      if (LocaleCompare(\"deskew\",option+1) == 0)\n        {\n          double\n            threshold;\n\n          if (IfNormalOp) {\n            if (IsGeometry(arg1) == MagickFalse)\n              CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n            threshold=StringToDoubleInterval(arg1,(double) QuantumRange+1.0);\n          }\n          else\n            threshold=40.0*QuantumRange/100.0;\n          new_image=DeskewImage(_image,threshold,_exception);\n          break;\n        }\n      if (LocaleCompare(\"despeckle\",option+1) == 0)\n        {\n          new_image=DespeckleImage(_image,_exception);\n          break;\n        }\n      if (LocaleCompare(\"distort\",option+1) == 0)\n        {\n          double\n            *args;\n\n          ssize_t\n            count;\n\n          parse = ParseCommandOption(MagickDistortOptions,MagickFalse,arg1);\n          if ( parse < 0 )\n             CLIWandExceptArgBreak(OptionError,\"UnrecognizedDistortMethod\",\n                                      option,arg1);\n          if ((DistortMethod) parse == ResizeDistortion)\n            {\n               double\n                 resize_args[2];\n               /* Special Case - Argument is actually a resize geometry!\n               ** Convert that to an appropriate distortion argument array.\n               ** FUTURE: make a separate special resize operator\n                    Roll into a resize special operator */\n               if (IsGeometry(arg2) == MagickFalse)\n                 CLIWandExceptArgBreak(OptionError,\"InvalidGeometry\",\n                                           option,arg2);\n               (void) ParseRegionGeometry(_image,arg2,&geometry,_exception);\n               resize_args[0]=(double) geometry.width;\n               resize_args[1]=(double) geometry.height;\n               new_image=DistortImage(_image,(DistortMethod) parse,\n                    (size_t)2,resize_args,MagickTrue,_exception);\n               break;\n            }\n          /* convert argument string into an array of doubles */\n          args = StringToArrayOfDoubles(arg2,&count,_exception);\n          if (args == (double *) NULL )\n            CLIWandExceptArgBreak(OptionError,\"InvalidNumberList\",option,arg2);\n\n          new_image=DistortImage(_image,(DistortMethod) parse,(size_t)\n             count,args,IsPlusOp,_exception);\n          args=(double *) RelinquishMagickMemory(args);\n          break;\n        }\n      if (LocaleCompare(\"draw\",option+1) == 0)\n        {\n          (void) CloneString(&_draw_info->primitive,arg1);\n          (void) DrawImage(_image,_draw_info,_exception);\n          (void) CloneString(&_draw_info->primitive,(char *) NULL);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'e':\n    {\n      if (LocaleCompare(\"edge\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          new_image=EdgeImage(_image,geometry_info.rho,_exception);\n          break;\n        }\n      if (LocaleCompare(\"emboss\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=1.0;\n          new_image=EmbossImage(_image,geometry_info.rho,\n            geometry_info.sigma,_exception);\n          break;\n        }\n      if (LocaleCompare(\"encipher\",option+1) == 0)\n        {\n          /* Note: arguments do not have percent escapes expanded */\n          StringInfo\n            *passkey;\n\n          passkey=FileToStringInfo(arg1,~0UL,_exception);\n          if (passkey != (StringInfo *) NULL)\n            {\n              (void) PasskeyEncipherImage(_image,passkey,_exception);\n              passkey=DestroyStringInfo(passkey);\n            }\n          break;\n        }\n      if (LocaleCompare(\"enhance\",option+1) == 0)\n        {\n          new_image=EnhanceImage(_image,_exception);\n          break;\n        }\n      if (LocaleCompare(\"equalize\",option+1) == 0)\n        {\n          (void) EqualizeImage(_image,_exception);\n          break;\n        }\n      if (LocaleCompare(\"evaluate\",option+1) == 0)\n        {\n          double\n            constant;\n\n          parse = ParseCommandOption(MagickEvaluateOptions,MagickFalse,arg1);\n          if ( parse < 0 )\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedEvaluateOperator\",\n                 option,arg1);\n          if (IsGeometry(arg2) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg2);\n          constant=StringToDoubleInterval(arg2,(double) QuantumRange+1.0);\n          (void) EvaluateImage(_image,(MagickEvaluateOperator)parse,constant,\n               _exception);\n          break;\n        }\n      if (LocaleCompare(\"extent\",option+1) == 0)\n        {\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          flags=ParseGravityGeometry(_image,arg1,&geometry,_exception);\n          if (geometry.width == 0)\n            geometry.width=_image->columns;\n          if (geometry.height == 0)\n            geometry.height=_image->rows;\n          new_image=ExtentImage(_image,&geometry,_exception);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'f':\n    {\n      if (LocaleCompare(\"flip\",option+1) == 0)\n        {\n          new_image=FlipImage(_image,_exception);\n          break;\n        }\n      if (LocaleCompare(\"flop\",option+1) == 0)\n        {\n          new_image=FlopImage(_image,_exception);\n          break;\n        }\n      if (LocaleCompare(\"floodfill\",option+1) == 0)\n        {\n          PixelInfo\n            target;\n\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) ParsePageGeometry(_image,arg1,&geometry,_exception);\n          (void) QueryColorCompliance(arg2,AllCompliance,&target,_exception);\n          (void) FloodfillPaintImage(_image,_draw_info,&target,geometry.x,\n            geometry.y,IsPlusOp,_exception);\n          break;\n        }\n      if (LocaleCompare(\"frame\",option+1) == 0)\n        {\n          FrameInfo\n            frame_info;\n\n          CompositeOperator\n            compose;\n\n          const char*\n            value;\n\n          value=GetImageOption(_image_info,\"compose\");\n            compose=OverCompositeOp;  /* use Over not _image->compose */\n          if (value != (const char *) NULL)\n            compose=(CompositeOperator) ParseCommandOption(MagickComposeOptions,\n              MagickFalse,value);\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          flags=ParsePageGeometry(_image,arg1,&geometry,_exception);\n          frame_info.width=geometry.width;\n          frame_info.height=geometry.height;\n          frame_info.outer_bevel=geometry.x;\n          frame_info.inner_bevel=geometry.y;\n          frame_info.x=(ssize_t) frame_info.width;\n          frame_info.y=(ssize_t) frame_info.height;\n          frame_info.width=_image->columns+2*frame_info.width;\n          frame_info.height=_image->rows+2*frame_info.height;\n          new_image=FrameImage(_image,&frame_info,compose,_exception);\n          break;\n        }\n      if (LocaleCompare(\"function\",option+1) == 0)\n        {\n          double\n            *args;\n\n          ssize_t\n            count;\n\n          parse=ParseCommandOption(MagickFunctionOptions,MagickFalse,arg1);\n          if ( parse < 0 )\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedFunction\",\n                 option,arg1);\n          /* convert argument string into an array of doubles */\n          args = StringToArrayOfDoubles(arg2,&count,_exception);\n          if (args == (double *) NULL )\n            CLIWandExceptArgBreak(OptionError,\"InvalidNumberList\",option,arg2);\n\n          (void) FunctionImage(_image,(MagickFunction)parse,(size_t) count,args,\n               _exception);\n          args=(double *) RelinquishMagickMemory(args);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'g':\n    {\n      if (LocaleCompare(\"gamma\",option+1) == 0)\n        {\n          double\n            constant;\n\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          constant=StringToDouble(arg1,(char **) NULL);\n#if 0\n          /* Using Gamma, via a cache */\n          if (IfPlusOp)\n            constant=PerceptibleReciprocal(constant);\n          (void) GammaImage(_image,constant,_exception);\n#else\n          /* Using Evaluate POW, direct update of values - more accurite */\n          if (IfNormalOp)\n            constant=PerceptibleReciprocal(constant);\n          (void) EvaluateImage(_image,PowEvaluateOperator,constant,_exception);\n          _image->gamma*=StringToDouble(arg1,(char **) NULL);\n#endif\n          /* Set gamma setting -- Old meaning of \"+gamma\"\n           * _image->gamma=StringToDouble(arg1,(char **) NULL);\n           */\n          break;\n        }\n      if (LocaleCompare(\"gaussian-blur\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=1.0;\n          new_image=GaussianBlurImage(_image,geometry_info.rho,\n            geometry_info.sigma,_exception);\n          break;\n        }\n      if (LocaleCompare(\"gaussian\",option+1) == 0)\n        {\n          CLIWandWarnReplaced(\"-gaussian-blur\");\n          (void) CLISimpleOperatorImage(cli_wand,\"-gaussian-blur\",arg1,NULL,exception);\n        }\n      if (LocaleCompare(\"geometry\",option+1) == 0)\n        {\n          /*\n            Record Image offset for composition. (A Setting)\n            Resize last _image. (ListOperator)  -- DEPRECIATE\n            FUTURE: Why if no 'offset' does this resize ALL images?\n            Also why is the setting recorded in the IMAGE non-sense!\n          */\n          if (IfPlusOp)\n            { /* remove the previous composition geometry offset! */\n              if (_image->geometry != (char *) NULL)\n                _image->geometry=DestroyString(_image->geometry);\n              break;\n            }\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          flags=ParseRegionGeometry(_image,arg1,&geometry,_exception);\n          if (((flags & XValue) != 0) || ((flags & YValue) != 0))\n            (void) CloneString(&_image->geometry,arg1);\n          else\n            new_image=ResizeImage(_image,geometry.width,geometry.height,\n              _image->filter,_exception);\n          break;\n        }\n      if (LocaleCompare(\"grayscale\",option+1) == 0)\n        {\n          parse=ParseCommandOption(MagickPixelIntensityOptions,\n            MagickFalse,arg1);\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedIntensityMethod\",\n              option,arg1);\n          (void) GrayscaleImage(_image,(PixelIntensityMethod) parse,_exception);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'h':\n    {\n      if (LocaleCompare(\"hough-lines\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=geometry_info.rho;\n          if ((flags & XiValue) == 0)\n            geometry_info.xi=40;\n          new_image=HoughLineImage(_image,(size_t) geometry_info.rho,\n            (size_t) geometry_info.sigma,(size_t) geometry_info.xi,_exception);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'i':\n    {\n      if (LocaleCompare(\"identify\",option+1) == 0)\n        {\n          const char\n            *format,\n            *text;\n\n          format=GetImageOption(_image_info,\"format\");\n          if (format == (char *) NULL)\n            {\n              (void) IdentifyImage(_image,stdout,_image_info->verbose,\n                _exception);\n              break;\n            }\n          text=InterpretImageProperties(_image_info,_image,format,_exception);\n          if (text == (char *) NULL)\n            CLIWandExceptionBreak(OptionWarning,\"InterpretPropertyFailure\",\n              option);\n          (void) fputs(text,stdout);\n          text=DestroyString((char *)text);\n          break;\n        }\n      if (LocaleCompare(\"implode\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & RhoValue) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          new_image=ImplodeImage(_image,geometry_info.rho,_image->interpolate,\n               _exception);\n          break;\n        }\n      if (LocaleCompare(\"interpolative-resize\",option+1) == 0)\n        {\n          /* FUTURE: New to IMv7\n               Roll into a resize special operator */\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) ParseRegionGeometry(_image,arg1,&geometry,_exception);\n          new_image=InterpolativeResizeImage(_image,geometry.width,\n               geometry.height,_image->interpolate,_exception);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'k':\n    {\n      if (LocaleCompare(\"kuwahara\",option+1) == 0)\n        {\n          /*\n            Edge preserving blur.\n          */\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=geometry_info.rho-0.5;\n          new_image=KuwaharaImage(_image,geometry_info.rho,geometry_info.sigma,\n           _exception);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'l':\n    {\n      if (LocaleCompare(\"lat\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=1.0;\n          if ((flags & PercentValue) != 0)\n            geometry_info.xi=(double) QuantumRange*geometry_info.xi/100.0;\n          new_image=AdaptiveThresholdImage(_image,(size_t) geometry_info.rho,\n               (size_t) geometry_info.sigma,(double) geometry_info.xi,\n               _exception);\n          break;\n        }\n      if (LocaleCompare(\"level\",option+1) == 0)\n        {\n          double\n            black_point,\n            gamma,\n            white_point;\n\n          MagickStatusType\n            flags;\n\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & RhoValue) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          black_point=geometry_info.rho;\n          white_point=(double) QuantumRange;\n          if ((flags & SigmaValue) != 0)\n            white_point=geometry_info.sigma;\n          gamma=1.0;\n          if ((flags & XiValue) != 0)\n            gamma=geometry_info.xi;\n          if ((flags & PercentValue) != 0)\n            {\n              black_point*=(double) (QuantumRange/100.0);\n              white_point*=(double) (QuantumRange/100.0);\n            }\n          if ((flags & SigmaValue) == 0)\n            white_point=(double) QuantumRange-black_point;\n          if (IfPlusOp || ((flags & AspectValue) != 0))\n            (void) LevelizeImage(_image,black_point,white_point,gamma,_exception);\n          else\n            (void) LevelImage(_image,black_point,white_point,gamma,_exception);\n          break;\n        }\n      if (LocaleCompare(\"level-colors\",option+1) == 0)\n        {\n          char\n            token[MagickPathExtent];\n\n          const char\n            *p;\n\n          PixelInfo\n            black_point,\n            white_point;\n\n          p=(const char *) arg1;\n          GetNextToken(p,&p,MagickPathExtent,token);  /* get black point color */\n          if ((isalpha((int) *token) != 0) || ((*token == '#') != 0))\n            (void) QueryColorCompliance(token,AllCompliance,\n                      &black_point,_exception);\n          else\n            (void) QueryColorCompliance(\"#000000\",AllCompliance,\n                      &black_point,_exception);\n          if (isalpha((int) token[0]) || (token[0] == '#'))\n            GetNextToken(p,&p,MagickPathExtent,token);\n          if (*token == '\\0')\n            white_point=black_point; /* set everything to that color */\n          else\n            {\n              if ((isalpha((int) *token) == 0) && ((*token == '#') == 0))\n                GetNextToken(p,&p,MagickPathExtent,token); /* Get white point color. */\n              if ((isalpha((int) *token) != 0) || ((*token == '#') != 0))\n                (void) QueryColorCompliance(token,AllCompliance,\n                           &white_point,_exception);\n              else\n                (void) QueryColorCompliance(\"#ffffff\",AllCompliance,\n                           &white_point,_exception);\n            }\n          (void) LevelImageColors(_image,&black_point,&white_point,\n                     IsPlusOp,_exception);\n          break;\n        }\n      if (LocaleCompare(\"linear-stretch\",option+1) == 0)\n        {\n          double\n            black_point,\n            white_point;\n\n          MagickStatusType\n            flags;\n\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & RhoValue) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          black_point=geometry_info.rho;\n          white_point=(double) _image->columns*_image->rows;\n          if ((flags & SigmaValue) != 0)\n            white_point=geometry_info.sigma;\n          if ((flags & PercentValue) != 0)\n            {\n              black_point*=(double) _image->columns*_image->rows/100.0;\n              white_point*=(double) _image->columns*_image->rows/100.0;\n            }\n          if ((flags & SigmaValue) == 0)\n            white_point=(double) _image->columns*_image->rows-\n              black_point;\n          (void) LinearStretchImage(_image,black_point,white_point,_exception);\n          break;\n        }\n      if (LocaleCompare(\"liquid-rescale\",option+1) == 0)\n        {\n          /* FUTURE: Roll into a resize special operator */\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          flags=ParseRegionGeometry(_image,arg1,&geometry,_exception);\n          if ((flags & XValue) == 0)\n            geometry.x=1;\n          if ((flags & YValue) == 0)\n            geometry.y=0;\n          new_image=LiquidRescaleImage(_image,geometry.width,\n            geometry.height,1.0*geometry.x,1.0*geometry.y,_exception);\n          break;\n        }\n      if (LocaleCompare(\"local-contrast\",option+1) == 0)\n        {\n          MagickStatusType\n            flags;\n\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & RhoValue) == 0)\n            geometry_info.rho=10;\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=12.5;\n          new_image=LocalContrastImage(_image,geometry_info.rho,\n            geometry_info.sigma,exception);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'm':\n    {\n      if (LocaleCompare(\"magnify\",option+1) == 0)\n        {\n          new_image=MagnifyImage(_image,_exception);\n          break;\n        }\n      if (LocaleCompare(\"map\",option+1) == 0)\n        {\n          CLIWandWarnReplaced(\"-remap\");\n          (void) CLISimpleOperatorImage(cli_wand,\"-remap\",NULL,NULL,exception);\n          break;\n        }\n      if (LocaleCompare(\"mask\",option+1) == 0)\n        {\n          Image\n            *mask;\n\n          if (IfPlusOp)\n            {\n              /*\n                Remove a mask.\n              */\n              (void) SetImageMask(_image,WritePixelMask,(Image *) NULL,\n                _exception);\n              break;\n            }\n          /*\n            Set the image mask.\n          */\n          mask=GetImageCache(_image_info,arg1,_exception);\n          if (mask == (Image *) NULL)\n            break;\n          (void) SetImageMask(_image,WritePixelMask,mask,_exception);\n          mask=DestroyImage(mask);\n          break;\n        }\n      if (LocaleCompare(\"matte\",option+1) == 0)\n        {\n          CLIWandWarnReplaced(IfNormalOp?\"-alpha Set\":\"-alpha Off\");\n          (void) SetImageAlphaChannel(_image,IfNormalOp ? SetAlphaChannel :\n            DeactivateAlphaChannel, _exception);\n          break;\n        }\n      if (LocaleCompare(\"mean-shift\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=1.0;\n          if ((flags & XiValue) == 0)\n            geometry_info.xi=0.10*QuantumRange;\n          if ((flags & PercentValue) != 0)\n            geometry_info.xi=(double) QuantumRange*geometry_info.xi/100.0;\n          new_image=MeanShiftImage(_image,(size_t) geometry_info.rho,\n            (size_t) geometry_info.sigma,geometry_info.xi,_exception);\n          break;\n        }\n      if (LocaleCompare(\"median\",option+1) == 0)\n        {\n          CLIWandWarnReplaced(\"-statistic Median\");\n          (void) CLISimpleOperatorImage(cli_wand,\"-statistic\",\"Median\",arg1,exception);\n          break;\n        }\n      if (LocaleCompare(\"mode\",option+1) == 0)\n        {\n          /* FUTURE: note this is also a special \"montage\" option */\n          CLIWandWarnReplaced(\"-statistic Mode\");\n          (void) CLISimpleOperatorImage(cli_wand,\"-statistic\",\"Mode\",arg1,exception);\n          break;\n        }\n      if (LocaleCompare(\"modulate\",option+1) == 0)\n        {\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) ModulateImage(_image,arg1,_exception);\n          break;\n        }\n      if (LocaleCompare(\"monitor\",option+1) == 0)\n        {\n          (void) SetImageProgressMonitor(_image, IfNormalOp ? MonitorProgress :\n                (MagickProgressMonitor) NULL,(void *) NULL);\n          break;\n        }\n      if (LocaleCompare(\"monochrome\",option+1) == 0)\n        {\n          (void) SetImageType(_image,BilevelType,_exception);\n          break;\n        }\n      if (LocaleCompare(\"morphology\",option+1) == 0)\n        {\n          char\n            token[MagickPathExtent];\n\n          const char\n            *p;\n\n          KernelInfo\n            *kernel;\n\n          ssize_t\n            iterations;\n\n          p=arg1;\n          GetNextToken(p,&p,MagickPathExtent,token);\n          parse=ParseCommandOption(MagickMorphologyOptions,MagickFalse,token);\n          if ( parse < 0 )\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedFunction\",option,\n              arg1);\n          iterations=1L;\n          GetNextToken(p,&p,MagickPathExtent,token);\n          if ((*p == ':') || (*p == ','))\n            GetNextToken(p,&p,MagickPathExtent,token);\n          if ((*p != '\\0'))\n            iterations=(ssize_t) StringToLong(p);\n          kernel=AcquireKernelInfo(arg2,exception);\n          if (kernel == (KernelInfo *) NULL)\n            CLIWandExceptArgBreak(OptionError,\"UnabletoParseKernel\",option,arg2);\n          new_image=MorphologyImage(_image,(MorphologyMethod)parse,iterations,\n            kernel,_exception);\n          kernel=DestroyKernelInfo(kernel);\n          break;\n        }\n      if (LocaleCompare(\"motion-blur\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=1.0;\n          new_image=MotionBlurImage(_image,geometry_info.rho,geometry_info.sigma,\n            geometry_info.xi,_exception);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'n':\n    {\n      if (LocaleCompare(\"negate\",option+1) == 0)\n        {\n          (void) NegateImage(_image, IsPlusOp, _exception);\n          break;\n        }\n      if (LocaleCompare(\"noise\",option+1) == 0)\n        {\n          double\n            attenuate;\n\n          const char*\n            value;\n\n          if (IfNormalOp)\n            {\n              CLIWandWarnReplaced(\"-statistic NonPeak\");\n              (void) CLISimpleOperatorImage(cli_wand,\"-statistic\",\"NonPeak\",arg1,exception);\n              break;\n            }\n          parse=ParseCommandOption(MagickNoiseOptions,MagickFalse,arg1);\n          if ( parse < 0 )\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedNoiseType\",\n                option,arg1);\n          attenuate=1.0;\n          value=GetImageOption(_image_info,\"attenuate\");\n          if  (value != (const char *) NULL)\n            attenuate=StringToDouble(value,(char **) NULL);\n          new_image=AddNoiseImage(_image,(NoiseType)parse,attenuate,\n               _exception);\n          break;\n        }\n      if (LocaleCompare(\"normalize\",option+1) == 0)\n        {\n          (void) NormalizeImage(_image,_exception);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'o':\n    {\n      if (LocaleCompare(\"opaque\",option+1) == 0)\n        {\n          PixelInfo\n            target;\n\n          (void) QueryColorCompliance(arg1,AllCompliance,&target,_exception);\n          (void) OpaquePaintImage(_image,&target,&_draw_info->fill,IsPlusOp,\n               _exception);\n          break;\n        }\n      if (LocaleCompare(\"ordered-dither\",option+1) == 0)\n        {\n          (void) OrderedDitherImage(_image,arg1,_exception);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'p':\n    {\n      if (LocaleCompare(\"paint\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          new_image=OilPaintImage(_image,geometry_info.rho,geometry_info.sigma,\n               _exception);\n          break;\n        }\n      if (LocaleCompare(\"perceptible\",option+1) == 0)\n        {\n          (void) PerceptibleImage(_image,StringToDouble(arg1,(char **) NULL),\n            _exception);\n          break;\n        }\n      if (LocaleCompare(\"polaroid\",option+1) == 0)\n        {\n          const char\n            *caption;\n\n          double\n            angle;\n\n          if (IfPlusOp) {\n            RandomInfo\n              *random_info;\n\n            random_info=AcquireRandomInfo();\n            angle=22.5*(GetPseudoRandomValue(random_info)-0.5);\n            random_info=DestroyRandomInfo(random_info);\n          }\n          else {\n            flags=ParseGeometry(arg1,&geometry_info);\n            if ((flags & RhoValue) == 0)\n              CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n            angle=geometry_info.rho;\n          }\n          caption=GetImageProperty(_image,\"caption\",_exception);\n          new_image=PolaroidImage(_image,_draw_info,caption,angle,\n            _image->interpolate,_exception);\n          break;\n        }\n      if (LocaleCompare(\"posterize\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & RhoValue) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) PosterizeImage(_image,(size_t) geometry_info.rho,\n            _quantize_info->dither_method,_exception);\n          break;\n        }\n      if (LocaleCompare(\"preview\",option+1) == 0)\n        {\n          /* FUTURE: should be a 'Genesis' option?\n             Option however is also in WandSettingOptionInfo()\n             Why???\n          */\n          parse=ParseCommandOption(MagickPreviewOptions, MagickFalse,arg1);\n          if ( parse < 0 )\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedPreviewType\",\n                option,arg1);\n          new_image=PreviewImage(_image,(PreviewType)parse,_exception);\n          break;\n        }\n      if (LocaleCompare(\"profile\",option+1) == 0)\n        {\n          const char\n            *name;\n\n          const StringInfo\n            *profile;\n\n          Image\n            *profile_image;\n\n          ImageInfo\n            *profile_info;\n\n          /* Note: arguments do not have percent escapes expanded */\n          if (IfPlusOp)\n            { /* Remove a profile from the _image.  */\n              (void) ProfileImage(_image,arg1,(const unsigned char *)\n                NULL,0,_exception);\n              break;\n            }\n          /* Associate a profile with the _image.  */\n          profile_info=CloneImageInfo(_image_info);\n          profile=GetImageProfile(_image,\"iptc\");\n          if (profile != (StringInfo *) NULL)\n            profile_info->profile=(void *) CloneStringInfo(profile);\n          profile_image=GetImageCache(profile_info,arg1,_exception);\n          profile_info=DestroyImageInfo(profile_info);\n          if (profile_image == (Image *) NULL)\n            {\n              StringInfo\n                *profile;\n\n              profile_info=CloneImageInfo(_image_info);\n              (void) CopyMagickString(profile_info->filename,arg1,\n                MagickPathExtent);\n              profile=FileToStringInfo(profile_info->filename,~0UL,_exception);\n              if (profile != (StringInfo *) NULL)\n                {\n                  (void) SetImageInfo(profile_info,0,_exception);\n                  (void) ProfileImage(_image,profile_info->magick,\n                    GetStringInfoDatum(profile),(size_t)\n                    GetStringInfoLength(profile),_exception);\n                  profile=DestroyStringInfo(profile);\n                }\n              profile_info=DestroyImageInfo(profile_info);\n              break;\n            }\n          ResetImageProfileIterator(profile_image);\n          name=GetNextImageProfile(profile_image);\n          while (name != (const char *) NULL)\n          {\n            profile=GetImageProfile(profile_image,name);\n            if (profile != (StringInfo *) NULL)\n              (void) ProfileImage(_image,name,GetStringInfoDatum(profile),\n                (size_t) GetStringInfoLength(profile),_exception);\n            name=GetNextImageProfile(profile_image);\n          }\n          profile_image=DestroyImage(profile_image);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'r':\n    {\n      if (LocaleCompare(\"raise\",option+1) == 0)\n        {\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          flags=ParsePageGeometry(_image,arg1,&geometry,_exception);\n          (void) RaiseImage(_image,&geometry,IsNormalOp,_exception);\n          break;\n        }\n      if (LocaleCompare(\"random-threshold\",option+1) == 0)\n        {\n          double\n            min_threshold,\n            max_threshold;\n\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          min_threshold=0.0;\n          max_threshold=(double) QuantumRange;\n          flags=ParseGeometry(arg1,&geometry_info);\n          min_threshold=geometry_info.rho;\n          max_threshold=geometry_info.sigma;\n          if ((flags & SigmaValue) == 0)\n            max_threshold=min_threshold;\n          if (strchr(arg1,'%') != (char *) NULL)\n            {\n              max_threshold*=(double) (0.01*QuantumRange);\n              min_threshold*=(double) (0.01*QuantumRange);\n            }\n          (void) RandomThresholdImage(_image,min_threshold,max_threshold,\n            _exception);\n          break;\n        }\n      if (LocaleCompare(\"range-threshold\",option+1) == 0)\n        {\n          /*\n            Range threshold image.\n          */\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=geometry_info.rho;\n          if ((flags & XiValue) == 0)\n            geometry_info.xi=geometry_info.sigma;\n          if ((flags & PsiValue) == 0)\n            geometry_info.psi=geometry_info.xi;\n          if (strchr(arg1,'%') != (char *) NULL)\n            {\n              geometry_info.rho*=(double) (0.01*QuantumRange);\n              geometry_info.sigma*=(double) (0.01*QuantumRange);\n              geometry_info.xi*=(double) (0.01*QuantumRange);\n              geometry_info.psi*=(double) (0.01*QuantumRange);\n            }\n          (void) RangeThresholdImage(_image,geometry_info.rho,\n            geometry_info.sigma,geometry_info.xi,geometry_info.psi,exception);\n          break;\n        }\n      if (LocaleCompare(\"read-mask\",option+1) == 0)\n        {\n          /* Note: arguments do not have percent escapes expanded */\n          Image\n            *mask;\n\n          if (IfPlusOp)\n            { /* Remove a mask. */\n              (void) SetImageMask(_image,ReadPixelMask,(Image *) NULL,\n                _exception);\n              break;\n            }\n          /* Set the image mask. */\n          mask=GetImageCache(_image_info,arg1,_exception);\n          if (mask == (Image *) NULL)\n            break;\n          (void) SetImageMask(_image,ReadPixelMask,mask,_exception);\n          mask=DestroyImage(mask);\n          break;\n        }\n      if (LocaleCompare(\"recolor\",option+1) == 0)\n        {\n          CLIWandWarnReplaced(\"-color-matrix\");\n          (void) CLISimpleOperatorImage(cli_wand,\"-color-matrix\",arg1,NULL,\n            exception);\n        }\n      if (LocaleCompare(\"region\",option+1) == 0)\n        {\n          if (*option == '+')\n            {\n              (void) SetImageRegionMask(_image,WritePixelMask,\n                (const RectangleInfo *) NULL,_exception);\n              break;\n            }\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) ParseGravityGeometry(_image,arg1,&geometry,_exception);\n          (void) SetImageRegionMask(_image,WritePixelMask,&geometry,_exception);\n          break;\n        }\n      if (LocaleCompare(\"remap\",option+1) == 0)\n        {\n          /* Note: arguments do not have percent escapes expanded */\n          Image\n            *remap_image;\n\n          remap_image=GetImageCache(_image_info,arg1,_exception);\n          if (remap_image == (Image *) NULL)\n            break;\n          (void) RemapImage(_quantize_info,_image,remap_image,_exception);\n          remap_image=DestroyImage(remap_image);\n          break;\n        }\n      if (LocaleCompare(\"repage\",option+1) == 0)\n        {\n          if (IfNormalOp)\n            {\n              if (IsGeometry(arg1) == MagickFalse)\n                CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,\n                  arg1);\n              (void) ResetImagePage(_image,arg1);\n            }\n          else\n            (void) ParseAbsoluteGeometry(\"0x0+0+0\",&_image->page);\n          break;\n        }\n      if (LocaleCompare(\"resample\",option+1) == 0)\n        {\n          /* FUTURE: Roll into a resize special operation */\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=geometry_info.rho;\n          new_image=ResampleImage(_image,geometry_info.rho,\n            geometry_info.sigma,_image->filter,_exception);\n          break;\n        }\n      if (LocaleCompare(\"resize\",option+1) == 0)\n        {\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) ParseRegionGeometry(_image,arg1,&geometry,_exception);\n          new_image=ResizeImage(_image,geometry.width,geometry.height,\n            _image->filter,_exception);\n          break;\n        }\n      if (LocaleCompare(\"roll\",option+1) == 0)\n        {\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          flags=ParsePageGeometry(_image,arg1,&geometry,_exception);\n          if ((flags & PercentValue) != 0)\n            {\n              geometry.x*=(double) _image->columns/100.0;\n              geometry.y*=(double) _image->rows/100.0;\n            }\n          new_image=RollImage(_image,geometry.x,geometry.y,_exception);\n          break;\n        }\n      if (LocaleCompare(\"rotate\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & RhoValue) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & GreaterValue) != 0 && (_image->columns <= _image->rows))\n            break;\n          if ((flags & LessValue) != 0 && (_image->columns >= _image->rows))\n            break;\n          new_image=RotateImage(_image,geometry_info.rho,_exception);\n          break;\n        }\n      if (LocaleCompare(\"rotational-blur\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & RhoValue) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          new_image=RotationalBlurImage(_image,geometry_info.rho,_exception);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 's':\n    {\n      if (LocaleCompare(\"sample\",option+1) == 0)\n        {\n          /* FUTURE: Roll into a resize special operator */\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) ParseRegionGeometry(_image,arg1,&geometry,_exception);\n          new_image=SampleImage(_image,geometry.width,geometry.height,\n            _exception);\n          break;\n        }\n      if (LocaleCompare(\"scale\",option+1) == 0)\n        {\n          /* FUTURE: Roll into a resize special operator */\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) ParseRegionGeometry(_image,arg1,&geometry,_exception);\n          new_image=ScaleImage(_image,geometry.width,geometry.height,\n            _exception);\n          break;\n        }\n      if (LocaleCompare(\"segment\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=1.0;\n          (void) SegmentImage(_image,_image->colorspace,\n            _image_info->verbose,geometry_info.rho,geometry_info.sigma,\n            _exception);\n          break;\n        }\n      if (LocaleCompare(\"selective-blur\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=1.0;\n          if ((flags & PercentValue) != 0)\n            geometry_info.xi=(double) QuantumRange*geometry_info.xi/100.0;\n          new_image=SelectiveBlurImage(_image,geometry_info.rho,\n            geometry_info.sigma,geometry_info.xi,_exception);\n          break;\n        }\n      if (LocaleCompare(\"separate\",option+1) == 0)\n        {\n          /* WARNING: This can generate multiple images! */\n          /* FUTURE - this may be replaced by a \"-channel\" method */\n          new_image=SeparateImages(_image,_exception);\n          break;\n        }\n      if (LocaleCompare(\"sepia-tone\",option+1) == 0)\n        {\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          new_image=SepiaToneImage(_image,StringToDoubleInterval(arg1,\n                 (double) QuantumRange+1.0),_exception);\n          break;\n        }\n      if (LocaleCompare(\"shade\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if (((flags & RhoValue) == 0) || ((flags & SigmaValue) == 0))\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          new_image=ShadeImage(_image,IsNormalOp,geometry_info.rho,\n               geometry_info.sigma,_exception);\n          break;\n        }\n      if (LocaleCompare(\"shadow\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=1.0;\n          if ((flags & XiValue) == 0)\n            geometry_info.xi=4.0;\n          if ((flags & PsiValue) == 0)\n            geometry_info.psi=4.0;\n          new_image=ShadowImage(_image,geometry_info.rho,geometry_info.sigma,\n            (ssize_t) ceil(geometry_info.xi-0.5),(ssize_t)\n            ceil(geometry_info.psi-0.5),_exception);\n          break;\n        }\n      if (LocaleCompare(\"sharpen\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=1.0;\n          if ((flags & XiValue) == 0)\n            geometry_info.xi=0.0;\n          new_image=SharpenImage(_image,geometry_info.rho,geometry_info.sigma,\n           _exception);\n          break;\n        }\n      if (LocaleCompare(\"shave\",option+1) == 0)\n        {\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          flags=ParsePageGeometry(_image,arg1,&geometry,_exception);\n          new_image=ShaveImage(_image,&geometry,_exception);\n          break;\n        }\n      if (LocaleCompare(\"shear\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & RhoValue) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=geometry_info.rho;\n          new_image=ShearImage(_image,geometry_info.rho,geometry_info.sigma,\n            _exception);\n          break;\n        }\n      if (LocaleCompare(\"sigmoidal-contrast\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & RhoValue) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=(double) QuantumRange/2.0;\n          if ((flags & PercentValue) != 0)\n            geometry_info.sigma=(double) QuantumRange*geometry_info.sigma/\n              100.0;\n          (void) SigmoidalContrastImage(_image,IsNormalOp,geometry_info.rho,\n               geometry_info.sigma,_exception);\n          break;\n        }\n      if (LocaleCompare(\"sketch\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=1.0;\n          new_image=SketchImage(_image,geometry_info.rho,\n            geometry_info.sigma,geometry_info.xi,_exception);\n          break;\n        }\n      if (LocaleCompare(\"solarize\",option+1) == 0)\n        {\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) SolarizeImage(_image,StringToDoubleInterval(arg1,(double)\n                 QuantumRange+1.0),_exception);\n          break;\n        }\n      if (LocaleCompare(\"sparse-color\",option+1) == 0)\n        {\n          parse= ParseCommandOption(MagickSparseColorOptions,MagickFalse,arg1);\n          if ( parse < 0 )\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedSparseColorMethod\",\n                option,arg1);\n          new_image=SparseColorOption(_image,(SparseColorMethod)parse,arg2,\n               _exception);\n          break;\n        }\n      if (LocaleCompare(\"splice\",option+1) == 0)\n        {\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          flags=ParseGravityGeometry(_image,arg1,&geometry,_exception);\n          new_image=SpliceImage(_image,&geometry,_exception);\n          break;\n        }\n      if (LocaleCompare(\"spread\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & RhoValue) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg2);\n          new_image=SpreadImage(_image,_image->interpolate,geometry_info.rho,\n           _exception);\n          break;\n        }\n      if (LocaleCompare(\"statistic\",option+1) == 0)\n        {\n          parse=ParseCommandOption(MagickStatisticOptions,MagickFalse,arg1);\n          if ( parse < 0 )\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedStatisticType\",\n                 option,arg1);\n          flags=ParseGeometry(arg2,&geometry_info);\n          if ((flags & RhoValue) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg2);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=geometry_info.rho;\n          new_image=StatisticImage(_image,(StatisticType)parse,\n               (size_t) geometry_info.rho,(size_t) geometry_info.sigma,\n               _exception);\n          break;\n        }\n      if (LocaleCompare(\"strip\",option+1) == 0)\n        {\n          (void) StripImage(_image,_exception);\n          break;\n        }\n      if (LocaleCompare(\"swirl\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & RhoValue) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          new_image=SwirlImage(_image,geometry_info.rho,\n            _image->interpolate,_exception);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 't':\n    {\n      if (LocaleCompare(\"threshold\",option+1) == 0)\n        {\n          double\n            threshold;\n\n          threshold=(double) QuantumRange/2;\n          if (IfNormalOp) {\n            if (IsGeometry(arg1) == MagickFalse)\n              CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n            threshold=StringToDoubleInterval(arg1,(double) QuantumRange+1.0);\n          }\n          (void) BilevelImage(_image,threshold,_exception);\n          break;\n        }\n      if (LocaleCompare(\"thumbnail\",option+1) == 0)\n        {\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) ParseRegionGeometry(_image,arg1,&geometry,_exception);\n          new_image=ThumbnailImage(_image,geometry.width,geometry.height,\n            _exception);\n          break;\n        }\n      if (LocaleCompare(\"tint\",option+1) == 0)\n        {\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          new_image=TintImage(_image,arg1,&_draw_info->fill,_exception);\n          break;\n        }\n      if (LocaleCompare(\"transform\",option+1) == 0)\n        {\n          CLIWandWarnReplaced(\"+distort AffineProjection\");\n          new_image=AffineTransformImage(_image,&_draw_info->affine,_exception);\n          break;\n        }\n      if (LocaleCompare(\"transparent\",option+1) == 0)\n        {\n          PixelInfo\n            target;\n\n          (void) QueryColorCompliance(arg1,AllCompliance,&target,_exception);\n          (void) TransparentPaintImage(_image,&target,(Quantum)\n            TransparentAlpha,IsPlusOp,_exception);\n          break;\n        }\n      if (LocaleCompare(\"transpose\",option+1) == 0)\n        {\n          new_image=TransposeImage(_image,_exception);\n          break;\n        }\n      if (LocaleCompare(\"transverse\",option+1) == 0)\n        {\n          new_image=TransverseImage(_image,_exception);\n          break;\n        }\n      if (LocaleCompare(\"trim\",option+1) == 0)\n        {\n          new_image=TrimImage(_image,_exception);\n          break;\n        }\n      if (LocaleCompare(\"type\",option+1) == 0)\n        {\n          /* Note that \"type\" setting should have already been defined */\n          (void) SetImageType(_image,_image_info->type,_exception);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'u':\n    {\n      if (LocaleCompare(\"unique\",option+1) == 0)\n        {\n          /* FUTURE: move to SyncImageSettings() and AcqireImage()???\n             Option is not documented, bt appears to be for \"identify\".\n             We may need a identify specific verbose!\n          */\n          if (IsPlusOp) {\n              (void) DeleteImageArtifact(_image,\"identify:unique-colors\");\n              break;\n            }\n          (void) SetImageArtifact(_image,\"identify:unique-colors\",\"true\");\n          (void) SetImageArtifact(_image,\"verbose\",\"true\");\n          break;\n        }\n      if (LocaleCompare(\"unique-colors\",option+1) == 0)\n        {\n          new_image=UniqueImageColors(_image,_exception);\n          break;\n        }\n      if (LocaleCompare(\"unsharp\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=1.0;\n          if ((flags & XiValue) == 0)\n            geometry_info.xi=1.0;\n          if ((flags & PsiValue) == 0)\n            geometry_info.psi=0.05;\n          new_image=UnsharpMaskImage(_image,geometry_info.rho,\n            geometry_info.sigma,geometry_info.xi,geometry_info.psi,_exception);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'v':\n    {\n      if (LocaleCompare(\"verbose\",option+1) == 0)\n        {\n          /* FUTURE: move to SyncImageSettings() and AcquireImage()???\n             three places!   ImageArtifact   ImageOption  _image_info->verbose\n             Some how new images also get this artifact!\n          */\n          (void) SetImageArtifact(_image,option+1,\n                           IfNormalOp ? \"true\" : \"false\" );\n          break;\n        }\n      if (LocaleCompare(\"vignette\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=1.0;\n          if ((flags & XiValue) == 0)\n            geometry_info.xi=0.1*_image->columns;\n          if ((flags & PsiValue) == 0)\n            geometry_info.psi=0.1*_image->rows;\n          if ((flags & PercentValue) != 0)\n            {\n              geometry_info.xi*=(double) _image->columns/100.0;\n              geometry_info.psi*=(double) _image->rows/100.0;\n            }\n          new_image=VignetteImage(_image,geometry_info.rho,geometry_info.sigma,\n            (ssize_t) ceil(geometry_info.xi-0.5),(ssize_t)\n            ceil(geometry_info.psi-0.5),_exception);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'w':\n    {\n      if (LocaleCompare(\"wave\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=1.0;\n          new_image=WaveImage(_image,geometry_info.rho,geometry_info.sigma,\n            _image->interpolate,_exception);\n          break;\n        }\n      if (LocaleCompare(\"wavelet-denoise\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & RhoValue) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & PercentValue) != 0)\n            {\n              geometry_info.rho=QuantumRange*geometry_info.rho/100.0;\n              geometry_info.sigma=QuantumRange*geometry_info.sigma/100.0;\n            }\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=0.0;\n          new_image=WaveletDenoiseImage(_image,geometry_info.rho,\n            geometry_info.sigma,_exception);\n          break;\n        }\n      if (LocaleCompare(\"white-threshold\",option+1) == 0)\n        {\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) WhiteThresholdImage(_image,arg1,_exception);\n          break;\n        }\n      if (LocaleCompare(\"write-mask\",option+1) == 0)\n        {\n          /* Note: arguments do not have percent escapes expanded */\n          Image\n            *mask;\n\n          if (IfPlusOp)\n            { /* Remove a mask. */\n              (void) SetImageMask(_image,WritePixelMask,(Image *) NULL,\n                _exception);\n              break;\n            }\n          /* Set the image mask. */\n          mask=GetImageCache(_image_info,arg1,_exception);\n          if (mask == (Image *) NULL)\n            break;\n          (void) SetImageMask(_image,WritePixelMask,mask,_exception);\n          mask=DestroyImage(mask);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    default:\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n  }\n  /* clean up percent escape interpreted strings */\n  if (arg1 != arg1n )\n    arg1=DestroyString((char *)arg1);\n  if (arg2 != arg2n )\n    arg2=DestroyString((char *)arg2);\n\n  /* Replace current image with any image that was generated\n     and set image point to last image (so image->next is correct) */\n  if (new_image != (Image *) NULL)\n    ReplaceImageInListReturnLast(&_image,new_image);\n\n  return(MagickTrue);\n#undef _image_info\n#undef _draw_info\n#undef _quantize_info\n#undef _image\n#undef _exception\n#undef IfNormalOp\n#undef IfPlusOp\n#undef IsNormalOp\n#undef IsPlusOp\n}\n\nWandPrivate MagickBooleanType CLISimpleOperatorImages(MagickCLI *cli_wand,\n  const char *option,const char *arg1,const char *arg2,ExceptionInfo *exception)\n{\n#if !USE_WAND_METHODS\n  size_t\n    n,\n    i;\n#endif\n\n  assert(cli_wand != (MagickCLI *) NULL);\n  assert(cli_wand->signature == MagickWandSignature);\n  assert(cli_wand->wand.signature == MagickWandSignature);\n  assert(cli_wand->wand.images != (Image *) NULL); /* images must be present */\n\n  if (cli_wand->wand.debug != MagickFalse)\n    (void) CLILogEvent(cli_wand,CommandEvent,GetMagickModule(),\n         \"- Simple Operator: %s \\\"%s\\\" \\\"%s\\\"\", option,arg1,arg2);\n\n#if !USE_WAND_METHODS\n  /* FUTURE add appropriate tracing */\n  i=0;\n  n=GetImageListLength(cli_wand->wand.images);\n  cli_wand->wand.images=GetFirstImageInList(cli_wand->wand.images);\n  while (1) {\n    i++;\n    CLISimpleOperatorImage(cli_wand, option, arg1, arg2,exception);\n    if ( cli_wand->wand.images->next == (Image *) NULL )\n      break;\n    cli_wand->wand.images=cli_wand->wand.images->next;\n  }\n  assert( i == n );\n  cli_wand->wand.images=GetFirstImageInList(cli_wand->wand.images);\n#else\n  MagickResetIterator(&cli_wand->wand);\n  while (MagickNextImage(&cli_wand->wand) != MagickFalse)\n    (void) CLISimpleOperatorImage(cli_wand, option, arg1, arg2,exception);\n  MagickResetIterator(&cli_wand->wand);\n#endif\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+     C L I L i s t O p e r a t o r I m a g e s                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CLIListOperatorImages() applies a single operation that is apply to the\n%  entire image list as a whole. The result is often a complete replacment\n%  of the image list with a completely new list, or with just a single image\n%  result.\n%\n%  The format of the MogrifyImage method is:\n%\n%    MagickBooleanType CLIListOperatorImages(MagickCLI *cli_wand,\n%      const char *option,const char *arg1,const char *arg2)\n%\n%  A description of each parameter follows:\n%\n%    o cli_wand: structure holding settings to be applied\n%\n%    o option:  The option string for the operation\n%\n%    o arg1, arg2: optional argument strings to the operation\n%        arg2 is currently not used\n%\n*/\nWandPrivate MagickBooleanType CLIListOperatorImages(MagickCLI *cli_wand,\n  const char *option,const char *arg1n,const char *arg2n)\n{\n  const char    /* percent escaped versions of the args */\n    *arg1,\n    *arg2;\n\n  Image\n    *new_images;\n\n  MagickStatusType\n    status;\n\n  ssize_t\n    parse;\n\n#define _image_info     (cli_wand->wand.image_info)\n#define _images         (cli_wand->wand.images)\n#define _exception      (cli_wand->wand.exception)\n#define _draw_info      (cli_wand->draw_info)\n#define _quantize_info  (cli_wand->quantize_info)\n#define _process_flags  (cli_wand->process_flags)\n#define _option_type    ((CommandOptionFlags) cli_wand->command->flags)\n#define IfNormalOp      (*option=='-')\n#define IfPlusOp        (*option!='-')\n#define IsNormalOp      IfNormalOp ? MagickTrue : MagickFalse\n\n  assert(cli_wand != (MagickCLI *) NULL);\n  assert(cli_wand->signature == MagickWandSignature);\n  assert(cli_wand->wand.signature == MagickWandSignature);\n  assert(_images != (Image *) NULL);             /* _images must be present */\n\n  if (cli_wand->wand.debug != MagickFalse)\n    (void) CLILogEvent(cli_wand,CommandEvent,GetMagickModule(),\n       \"- List Operator: %s \\\"%s\\\" \\\"%s\\\"\", option,\n       arg1n == (const char *) NULL ? \"null\" : arg1n,\n       arg2n == (const char *) NULL ? \"null\" : arg2n);\n\n  arg1 = arg1n;\n  arg2 = arg2n;\n\n  /* Interpret Percent Escapes in Arguments - using first image */\n  if ( (((_process_flags & ProcessInterpretProperities) != 0 )\n        || ((_option_type & AlwaysInterpretArgsFlag) != 0)\n       )  && ((_option_type & NeverInterpretArgsFlag) == 0) ) {\n    /* Interpret Percent escapes in argument 1 */\n    if (arg1n != (char *) NULL) {\n      arg1=InterpretImageProperties(_image_info,_images,arg1n,_exception);\n      if (arg1 == (char *) NULL) {\n        CLIWandException(OptionWarning,\"InterpretPropertyFailure\",option);\n        arg1=arg1n;  /* use the given argument as is */\n      }\n    }\n    if (arg2n != (char *) NULL) {\n      arg2=InterpretImageProperties(_image_info,_images,arg2n,_exception);\n      if (arg2 == (char *) NULL) {\n        CLIWandException(OptionWarning,\"InterpretPropertyFailure\",option);\n        arg2=arg2n;  /* use the given argument as is */\n      }\n    }\n  }\n#undef _process_flags\n#undef _option_type\n\n  status=MagickTrue;\n  new_images=NewImageList();\n\n  switch (*(option+1))\n  {\n    case 'a':\n    {\n      if (LocaleCompare(\"append\",option+1) == 0)\n        {\n          new_images=AppendImages(_images,IsNormalOp,_exception);\n          break;\n        }\n      if (LocaleCompare(\"average\",option+1) == 0)\n        {\n          CLIWandWarnReplaced(\"-evaluate-sequence Mean\");\n          (void) CLIListOperatorImages(cli_wand,\"-evaluate-sequence\",\"Mean\",\n            NULL);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'c':\n    {\n      if (LocaleCompare(\"channel-fx\",option+1) == 0)\n        {\n          new_images=ChannelFxImage(_images,arg1,_exception);\n          break;\n        }\n      if (LocaleCompare(\"clut\",option+1) == 0)\n        {\n          Image\n            *clut_image;\n\n          /* FUTURE - make this a compose option, and thus can be used\n             with layers compose or even compose last image over all other\n             _images.\n          */\n          new_images=RemoveFirstImageFromList(&_images);\n          clut_image=RemoveLastImageFromList(&_images);\n          /* FUTURE - produce Exception, rather than silent fail */\n          if (clut_image == (Image *) NULL)\n            break;\n          (void) ClutImage(new_images,clut_image,new_images->interpolate,\n            _exception);\n          clut_image=DestroyImage(clut_image);\n          break;\n        }\n      if (LocaleCompare(\"coalesce\",option+1) == 0)\n        {\n          new_images=CoalesceImages(_images,_exception);\n          break;\n        }\n      if (LocaleCompare(\"combine\",option+1) == 0)\n        {\n          parse=(ssize_t) _images->colorspace;\n          if (_images->number_channels < GetImageListLength(_images))\n            parse=sRGBColorspace;\n          if ( IfPlusOp )\n            parse=ParseCommandOption(MagickColorspaceOptions,MagickFalse,arg1);\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedColorspace\",option,\n              arg1);\n          new_images=CombineImages(_images,(ColorspaceType) parse,_exception);\n          break;\n        }\n      if (LocaleCompare(\"compare\",option+1) == 0)\n        {\n          double\n            distortion;\n\n          Image\n            *image,\n            *reconstruct_image;\n\n          MetricType\n            metric;\n\n          /*\n            Mathematically and visually annotate the difference between an\n            image and its reconstruction.\n          */\n          image=RemoveFirstImageFromList(&_images);\n          reconstruct_image=RemoveFirstImageFromList(&_images);\n          /* FUTURE - produce Exception, rather than silent fail */\n          if (reconstruct_image == (Image *) NULL)\n            break;\n          metric=UndefinedErrorMetric;\n          option=GetImageOption(_image_info,\"metric\");\n          if (option != (const char *) NULL)\n            metric=(MetricType) ParseCommandOption(MagickMetricOptions,\n              MagickFalse,option);\n          new_images=CompareImages(image,reconstruct_image,metric,&distortion,\n            _exception);\n          (void) distortion;\n          reconstruct_image=DestroyImage(reconstruct_image);\n          image=DestroyImage(image);\n          break;\n        }\n      if (LocaleCompare(\"complex\",option+1) == 0)\n        {\n          parse=ParseCommandOption(MagickComplexOptions,MagickFalse,arg1);\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedEvaluateOperator\",\n              option,arg1);\n          new_images=ComplexImages(_images,(ComplexOperator) parse,_exception);\n          break;\n        }\n      if (LocaleCompare(\"composite\",option+1) == 0)\n        {\n          CompositeOperator\n            compose;\n\n          const char*\n            value;\n\n          MagickBooleanType\n            clip_to_self;\n\n          Image\n            *mask_image,\n            *source_image;\n\n          RectangleInfo\n            geometry;\n\n          /* Compose value from \"-compose\" option only */\n          value=GetImageOption(_image_info,\"compose\");\n          if (value == (const char *) NULL)\n            compose=OverCompositeOp;  /* use Over not source_image->compose */\n          else\n            compose=(CompositeOperator) ParseCommandOption(MagickComposeOptions,\n              MagickFalse,value);\n\n          /* Get \"clip-to-self\" expert setting (false is normal) */\n          clip_to_self=GetCompositeClipToSelf(compose);\n          value=GetImageOption(_image_info,\"compose:clip-to-self\");\n          if (value != (const char *) NULL)\n            clip_to_self=IsStringTrue(value);\n          value=GetImageOption(_image_info,\"compose:outside-overlay\");\n          if (value != (const char *) NULL)\n            clip_to_self=IsStringFalse(value);  /* deprecated */\n\n          new_images=RemoveFirstImageFromList(&_images);\n          source_image=RemoveFirstImageFromList(&_images);\n          if (source_image == (Image *) NULL)\n            break; /* FUTURE - produce Exception, rather than silent fail */\n\n          /* FUTURE - this should not be here! - should be part of -geometry */\n          if (source_image->geometry != (char *) NULL)\n            {\n              RectangleInfo\n                resize_geometry;\n\n              (void) ParseRegionGeometry(source_image,source_image->geometry,\n                &resize_geometry,_exception);\n              if ((source_image->columns != resize_geometry.width) ||\n                  (source_image->rows != resize_geometry.height))\n                {\n                  Image\n                    *resize_image;\n\n                  resize_image=ResizeImage(source_image,resize_geometry.width,\n                    resize_geometry.height,source_image->filter,_exception);\n                  if (resize_image != (Image *) NULL)\n                    {\n                      source_image=DestroyImage(source_image);\n                      source_image=resize_image;\n                    }\n                }\n            }\n          SetGeometry(source_image,&geometry);\n          (void) ParseAbsoluteGeometry(source_image->geometry,&geometry);\n          GravityAdjustGeometry(new_images->columns,new_images->rows,\n            new_images->gravity, &geometry);\n          mask_image=RemoveFirstImageFromList(&_images);\n          if (mask_image == (Image *) NULL)\n            status&=CompositeImage(new_images,source_image,compose,clip_to_self,\n              geometry.x,geometry.y,_exception);\n          else\n            {\n              if ((compose == DisplaceCompositeOp) ||\n                  (compose == DistortCompositeOp))\n                {\n                  status&=CompositeImage(source_image,mask_image,\n                    CopyGreenCompositeOp,MagickTrue,0,0,_exception);\n                  status&=CompositeImage(new_images,source_image,compose,\n                    clip_to_self,geometry.x,geometry.y,_exception);\n                }\n              else\n                {\n                  Image\n                    *clone_image;\n\n                  clone_image=CloneImage(new_images,0,0,MagickTrue,_exception);\n                  if (clone_image == (Image *) NULL)\n                    break;\n                  status&=CompositeImage(new_images,source_image,compose,\n                    clip_to_self,geometry.x,geometry.y,_exception);\n                  status&=CompositeImage(new_images,mask_image,\n                    CopyAlphaCompositeOp,MagickTrue,0,0,_exception);\n                  status&=CompositeImage(clone_image,new_images,OverCompositeOp,\n                    clip_to_self,0,0,_exception);\n                  new_images=DestroyImage(new_images);\n                  new_images=clone_image;\n                }\n              mask_image=DestroyImage(mask_image);\n            }\n          source_image=DestroyImage(source_image);\n          break;\n        }\n        if (LocaleCompare(\"copy\",option+1) == 0)\n          {\n            Image\n              *source_image;\n\n            OffsetInfo\n              offset;\n\n            RectangleInfo\n              geometry;\n\n            /*\n              Copy image pixels.\n            */\n            if (IsGeometry(arg1) == MagickFalse)\n              CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n            if (IsGeometry(arg2) == MagickFalse)\n              CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n            (void) ParsePageGeometry(_images,arg2,&geometry,_exception);\n            offset.x=geometry.x;\n            offset.y=geometry.y;\n            source_image=_images;\n            if (source_image->next != (Image *) NULL)\n              source_image=source_image->next;\n            (void) ParsePageGeometry(source_image,arg1,&geometry,_exception);\n            (void) CopyImagePixels(_images,source_image,&geometry,&offset,\n              _exception);\n            break;\n          }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'd':\n    {\n      if (LocaleCompare(\"deconstruct\",option+1) == 0)\n        {\n          CLIWandWarnReplaced(\"-layer CompareAny\");\n          (void) CLIListOperatorImages(cli_wand,\"-layer\",\"CompareAny\",NULL);\n          break;\n        }\n      if (LocaleCompare(\"delete\",option+1) == 0)\n        {\n          if (IfNormalOp)\n            DeleteImages(&_images,arg1,_exception);\n          else\n            DeleteImages(&_images,\"-1\",_exception);\n          break;\n        }\n      if (LocaleCompare(\"duplicate\",option+1) == 0)\n        {\n          if (IfNormalOp)\n            {\n              const char\n                *p;\n\n              size_t\n                number_duplicates;\n\n              if (IsGeometry(arg1) == MagickFalse)\n                CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,\n                      arg1);\n              number_duplicates=(size_t) StringToLong(arg1);\n              p=strchr(arg1,',');\n              if (p == (const char *) NULL)\n                new_images=DuplicateImages(_images,number_duplicates,\"-1\",\n                  _exception);\n              else\n                new_images=DuplicateImages(_images,number_duplicates,p,\n                  _exception);\n            }\n          else\n            new_images=DuplicateImages(_images,1,\"-1\",_exception);\n          AppendImageToList(&_images, new_images);\n          new_images=(Image *) NULL;\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'e':\n    {\n      if (LocaleCompare(\"evaluate-sequence\",option+1) == 0)\n        {\n          parse=ParseCommandOption(MagickEvaluateOptions,MagickFalse,arg1);\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedEvaluateOperator\",\n              option,arg1);\n          new_images=EvaluateImages(_images,(MagickEvaluateOperator) parse,\n            _exception);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'f':\n    {\n      if (LocaleCompare(\"fft\",option+1) == 0)\n        {\n          new_images=ForwardFourierTransformImage(_images,IsNormalOp,\n           _exception);\n          break;\n        }\n      if (LocaleCompare(\"flatten\",option+1) == 0)\n        {\n          /* REDIRECTED to use -layers flatten instead */\n          (void) CLIListOperatorImages(cli_wand,\"-layers\",option+1,NULL);\n          break;\n        }\n      if (LocaleCompare(\"fx\",option+1) == 0)\n        {\n          new_images=FxImage(_images,arg1,_exception);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'h':\n    {\n      if (LocaleCompare(\"hald-clut\",option+1) == 0)\n        {\n          /* FUTURE - make this a compose option (and thus layers compose )\n             or perhaps compose last image over all other _images.\n          */\n          Image\n            *hald_image;\n\n          new_images=RemoveFirstImageFromList(&_images);\n          hald_image=RemoveLastImageFromList(&_images);\n          if (hald_image == (Image *) NULL)\n            break;\n          (void) HaldClutImage(new_images,hald_image,_exception);\n          hald_image=DestroyImage(hald_image);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'i':\n    {\n      if (LocaleCompare(\"ift\",option+1) == 0)\n        {\n          Image\n            *magnitude_image,\n            *phase_image;\n\n           magnitude_image=RemoveFirstImageFromList(&_images);\n           phase_image=RemoveFirstImageFromList(&_images);\n          /* FUTURE - produce Exception, rather than silent fail */\n           if (phase_image == (Image *) NULL)\n             break;\n           new_images=InverseFourierTransformImage(magnitude_image,phase_image,\n             IsNormalOp,_exception);\n           magnitude_image=DestroyImage(magnitude_image);\n           phase_image=DestroyImage(phase_image);\n          break;\n        }\n      if (LocaleCompare(\"insert\",option+1) == 0)\n        {\n          Image\n            *insert_image,\n            *index_image;\n\n          ssize_t\n            index;\n\n          if (IfNormalOp && (IsGeometry(arg1) == MagickFalse))\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          index=0;\n          insert_image=RemoveLastImageFromList(&_images);\n          if (IfNormalOp)\n            index=(ssize_t) StringToLong(arg1);\n          index_image=insert_image;\n          if (index == 0)\n            PrependImageToList(&_images,insert_image);\n          else if (index == (ssize_t) GetImageListLength(_images))\n            AppendImageToList(&_images,insert_image);\n          else\n            {\n               index_image=GetImageFromList(_images,index-1);\n               if (index_image == (Image *) NULL)\n                 CLIWandExceptArgBreak(OptionError,\"NoSuchImage\",option,arg1);\n              InsertImageInList(&index_image,insert_image);\n            }\n          _images=GetFirstImageInList(index_image);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'l':\n    {\n      if (LocaleCompare(\"layers\",option+1) == 0)\n        {\n          parse=ParseCommandOption(MagickLayerOptions,MagickFalse,arg1);\n          if ( parse < 0 )\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedLayerMethod\",\n                 option,arg1);\n          switch ((LayerMethod) parse)\n          {\n            case CoalesceLayer:\n            {\n              new_images=CoalesceImages(_images,_exception);\n              break;\n            }\n            case CompareAnyLayer:\n            case CompareClearLayer:\n            case CompareOverlayLayer:\n            default:\n            {\n              new_images=CompareImagesLayers(_images,(LayerMethod) parse,\n                   _exception);\n              break;\n            }\n            case MergeLayer:\n            case FlattenLayer:\n            case MosaicLayer:\n            case TrimBoundsLayer:\n            {\n              new_images=MergeImageLayers(_images,(LayerMethod) parse,\n                _exception);\n              break;\n            }\n            case DisposeLayer:\n            {\n              new_images=DisposeImages(_images,_exception);\n              break;\n            }\n            case OptimizeImageLayer:\n            {\n              new_images=OptimizeImageLayers(_images,_exception);\n              break;\n            }\n            case OptimizePlusLayer:\n            {\n              new_images=OptimizePlusImageLayers(_images,_exception);\n              break;\n            }\n            case OptimizeTransLayer:\n            {\n              OptimizeImageTransparency(_images,_exception);\n              break;\n            }\n            case RemoveDupsLayer:\n            {\n              RemoveDuplicateLayers(&_images,_exception);\n              break;\n            }\n            case RemoveZeroLayer:\n            {\n              RemoveZeroDelayLayers(&_images,_exception);\n              break;\n            }\n            case OptimizeLayer:\n            { /* General Purpose, GIF Animation Optimizer.  */\n              new_images=CoalesceImages(_images,_exception);\n              if (new_images == (Image *) NULL)\n                break;\n              _images=DestroyImageList(_images);\n              _images=OptimizeImageLayers(new_images,_exception);\n              if (_images == (Image *) NULL)\n                break;\n              new_images=DestroyImageList(new_images);\n              OptimizeImageTransparency(_images,_exception);\n              (void) RemapImages(_quantize_info,_images,(Image *) NULL,\n                _exception);\n              break;\n            }\n            case CompositeLayer:\n            {\n              Image\n                *source;\n\n              RectangleInfo\n                geometry;\n\n              CompositeOperator\n                compose;\n\n              const char*\n                value;\n\n              value=GetImageOption(_image_info,\"compose\");\n              compose=OverCompositeOp;  /* Default to Over */\n              if (value != (const char *) NULL)\n                compose=(CompositeOperator) ParseCommandOption(\n                      MagickComposeOptions,MagickFalse,value);\n\n              /* Split image sequence at the first 'NULL:' image. */\n              source=_images;\n              while (source != (Image *) NULL)\n              {\n                source=GetNextImageInList(source);\n                if ((source != (Image *) NULL) &&\n                    (LocaleCompare(source->magick,\"NULL\") == 0))\n                  break;\n              }\n              if (source != (Image *) NULL)\n                {\n                  if ((GetPreviousImageInList(source) == (Image *) NULL) ||\n                      (GetNextImageInList(source) == (Image *) NULL))\n                    source=(Image *) NULL;\n                  else\n                    { /* Separate the two lists, junk the null: image.  */\n                      source=SplitImageList(source->previous);\n                      DeleteImageFromList(&source);\n                    }\n                }\n              if (source == (Image *) NULL)\n                {\n                  (void) ThrowMagickException(_exception,GetMagickModule(),\n                    OptionError,\"MissingNullSeparator\",\"layers Composite\");\n                  break;\n                }\n              /* Adjust offset with gravity and virtual canvas.  */\n              SetGeometry(_images,&geometry);\n              (void) ParseAbsoluteGeometry(_images->geometry,&geometry);\n              geometry.width=source->page.width != 0 ?\n                source->page.width : source->columns;\n              geometry.height=source->page.height != 0 ?\n               source->page.height : source->rows;\n              GravityAdjustGeometry(_images->page.width != 0 ?\n                _images->page.width : _images->columns,\n                _images->page.height != 0 ? _images->page.height :\n                _images->rows,_images->gravity,&geometry);\n\n              /* Compose the two image sequences together */\n              CompositeLayers(_images,compose,source,geometry.x,geometry.y,\n                _exception);\n              source=DestroyImageList(source);\n              break;\n            }\n          }\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'm':\n    {\n      if (LocaleCompare(\"map\",option+1) == 0)\n        {\n          CLIWandWarnReplaced(\"+remap\");\n          (void) RemapImages(_quantize_info,_images,(Image *) NULL,_exception);\n          break;\n        }\n      if (LocaleCompare(\"metric\",option+1) == 0)\n        {\n          (void) SetImageOption(_image_info,option+1,arg1);\n          break;\n        }\n      if (LocaleCompare(\"morph\",option+1) == 0)\n        {\n          Image\n            *morph_image;\n\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          morph_image=MorphImages(_images,StringToUnsignedLong(arg1),\n            _exception);\n          if (morph_image == (Image *) NULL)\n            break;\n          _images=DestroyImageList(_images);\n          _images=morph_image;\n          break;\n        }\n      if (LocaleCompare(\"mosaic\",option+1) == 0)\n        {\n          /* REDIRECTED to use -layers mosaic instead */\n          (void) CLIListOperatorImages(cli_wand,\"-layers\",option+1,NULL);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'p':\n    {\n      if (LocaleCompare(\"poly\",option+1) == 0)\n        {\n          double\n            *args;\n\n          ssize_t\n            count;\n\n          /* convert argument string into an array of doubles */\n          args = StringToArrayOfDoubles(arg1,&count,_exception);\n          if (args == (double *) NULL )\n            CLIWandExceptArgBreak(OptionError,\"InvalidNumberList\",option,arg1);\n          new_images=PolynomialImage(_images,(size_t) (count >> 1),args,\n           _exception);\n          args=(double *) RelinquishMagickMemory(args);\n          break;\n        }\n      if (LocaleCompare(\"process\",option+1) == 0)\n        {\n          /* FUTURE: better parsing using ScriptToken() from string ??? */\n          char\n            **arguments;\n\n          int\n            j,\n            number_arguments;\n\n          arguments=StringToArgv(arg1,&number_arguments);\n          if (arguments == (char **) NULL)\n            break;\n          if (strchr(arguments[1],'=') != (char *) NULL)\n            {\n              char\n                breaker,\n                quote,\n                *token;\n\n              const char\n                *arguments;\n\n              int\n                next,\n                status;\n\n              size_t\n                length;\n\n              TokenInfo\n                *token_info;\n\n              /*\n                Support old style syntax, filter=\"-option arg1\".\n              */\n              assert(arg1 != (const char *) NULL);\n              length=strlen(arg1);\n              token=(char *) NULL;\n              if (~length >= (MagickPathExtent-1))\n                token=(char *) AcquireQuantumMemory(length+MagickPathExtent,\n                  sizeof(*token));\n              if (token == (char *) NULL)\n                break;\n              next=0;\n              arguments=arg1;\n              token_info=AcquireTokenInfo();\n              status=Tokenizer(token_info,0,token,length,arguments,\"\",\"=\",\n                \"\\\"\",'\\0',&breaker,&next,&quote);\n              token_info=DestroyTokenInfo(token_info);\n              if (status == 0)\n                {\n                  const char\n                    *argv;\n\n                  argv=(&(arguments[next]));\n                  (void) InvokeDynamicImageFilter(token,&_images,1,&argv,\n                    _exception);\n                }\n              token=DestroyString(token);\n              break;\n            }\n          (void) SubstituteString(&arguments[1],\"-\",\"\");\n          (void) InvokeDynamicImageFilter(arguments[1],&_images,\n            number_arguments-2,(const char **) arguments+2,_exception);\n          for (j=0; j < number_arguments; j++)\n            arguments[j]=DestroyString(arguments[j]);\n          arguments=(char **) RelinquishMagickMemory(arguments);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'r':\n    {\n      if (LocaleCompare(\"remap\",option+1) == 0)\n        {\n          (void) RemapImages(_quantize_info,_images,(Image *) NULL,_exception);\n          break;\n        }\n      if (LocaleCompare(\"reverse\",option+1) == 0)\n        {\n          ReverseImageList(&_images);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 's':\n    {\n      if (LocaleCompare(\"smush\",option+1) == 0)\n        {\n          /* FUTURE: this option needs more work to make better */\n          ssize_t\n            offset;\n\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          offset=(ssize_t) StringToLong(arg1);\n          new_images=SmushImages(_images,IsNormalOp,offset,_exception);\n          break;\n        }\n      if (LocaleCompare(\"subimage\",option+1) == 0)\n        {\n          Image\n            *base_image,\n            *compare_image;\n\n          const char\n            *value;\n\n          MetricType\n            metric;\n\n          double\n            similarity;\n\n          RectangleInfo\n            offset;\n\n          base_image=GetImageFromList(_images,0);\n          compare_image=GetImageFromList(_images,1);\n\n          /* Comparision Metric */\n          metric=UndefinedErrorMetric;\n          value=GetImageOption(_image_info,\"metric\");\n          if (value != (const char *) NULL)\n            metric=(MetricType) ParseCommandOption(MagickMetricOptions,\n              MagickFalse,value);\n\n          new_images=SimilarityImage(base_image,compare_image,metric,0.0,\n            &offset,&similarity,_exception);\n\n          if (new_images != (Image *) NULL)\n            {\n              char\n                result[MagickPathExtent];\n\n              (void) FormatLocaleString(result,MagickPathExtent,\"%lf\",\n                similarity);\n              (void) SetImageProperty(new_images,\"subimage:similarity\",result,\n                _exception);\n              (void) FormatLocaleString(result,MagickPathExtent,\"%+ld\",(long)\n                offset.x);\n              (void) SetImageProperty(new_images,\"subimage:x\",result,\n                _exception);\n              (void) FormatLocaleString(result,MagickPathExtent,\"%+ld\",(long)\n                offset.y);\n              (void) SetImageProperty(new_images,\"subimage:y\",result,\n                _exception);\n              (void) FormatLocaleString(result,MagickPathExtent,\n                \"%lux%lu%+ld%+ld\",(unsigned long) offset.width,(unsigned long)\n                offset.height,(long) offset.x,(long) offset.y);\n              (void) SetImageProperty(new_images,\"subimage:offset\",result,\n                _exception);\n            }\n          break;\n        }\n      if (LocaleCompare(\"swap\",option+1) == 0)\n        {\n        Image\n          *p,\n          *q,\n          *swap;\n\n        ssize_t\n          index,\n          swap_index;\n\n        index=(-1);\n        swap_index=(-2);\n        if (IfNormalOp) {\n          GeometryInfo\n            geometry_info;\n\n          MagickStatusType\n            flags;\n\n          swap_index=(-1);\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & RhoValue) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          index=(ssize_t) geometry_info.rho;\n          if ((flags & SigmaValue) != 0)\n            swap_index=(ssize_t) geometry_info.sigma;\n        }\n        p=GetImageFromList(_images,index);\n        q=GetImageFromList(_images,swap_index);\n        if ((p == (Image *) NULL) || (q == (Image *) NULL)) {\n          if (IfNormalOp)\n            CLIWandExceptArgBreak(OptionError,\"InvalidImageIndex\",option,arg1)\n          else\n            CLIWandExceptionBreak(OptionError,\"TwoOrMoreImagesRequired\",option);\n        }\n        if (p == q)\n          CLIWandExceptArgBreak(OptionError,\"InvalidImageIndex\",option,arg1);\n        swap=CloneImage(p,0,0,MagickTrue,_exception);\n        if (swap == (Image *) NULL)\n          CLIWandExceptArgBreak(ResourceLimitError,\"MemoryAllocationFailed\",\n            option,GetExceptionMessage(errno));\n        ReplaceImageInList(&p,CloneImage(q,0,0,MagickTrue,_exception));\n        ReplaceImageInList(&q,swap);\n        _images=GetFirstImageInList(q);\n        break;\n      }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    default:\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n  }\n\n  /* clean up percent escape interpreted strings */\n  if (arg1 != arg1n )\n    arg1=DestroyString((char *)arg1);\n  if (arg2 != arg2n )\n    arg2=DestroyString((char *)arg2);\n\n  /* if new image list generated, replace existing image list */\n  if (new_images == (Image *) NULL)\n    return(status == 0 ? MagickFalse : MagickTrue);\n  _images=DestroyImageList(_images);\n  _images=GetFirstImageInList(new_images);\n  return(status == 0 ? MagickFalse : MagickTrue);\n\n#undef _image_info\n#undef _images\n#undef _exception\n#undef _draw_info\n#undef _quantize_info\n#undef IfNormalOp\n#undef IfPlusOp\n#undef IsNormalOp\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   C L I N o I m a g e O p e r a t i o n s                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CLINoImageOperator() Applies operations that may not actually need images\n%  in an image list.\n%\n%  The classic operators of this type is \"-read\", which actually creates\n%  images even when no images are present.  Or image stack operators, which\n%  can be applied (push or pop) to an empty image list.\n%\n%  Note that these operators may involve other special 'option' prefix\n%  characters other  than '-' or '+', namely parenthesis and braces.\n%\n%  The format of the CLINoImageOption method is:\n%\n%      void CLINoImageOption(MagickCLI *cli_wand,const char *option,\n%           const char *arg1, const char *arg2)\n%\n%  A description of each parameter follows:\n%\n%    o cli_wand: the main CLI Wand to use. (sometimes not required)\n%\n%    o option: The special option (with any switch char) to process\n%\n%    o arg1 & arg2: Argument for option, if required\n%                   Currently arg2 is not used.\n%\n*/\nWandPrivate void CLINoImageOperator(MagickCLI *cli_wand,\n  const char *option,const char *arg1n,const char *arg2n)\n{\n  const char    /* percent escaped versions of the args */\n    *arg1,\n    *arg2;\n\n#define _image_info     (cli_wand->wand.image_info)\n#define _images         (cli_wand->wand.images)\n#define _exception      (cli_wand->wand.exception)\n#define _process_flags  (cli_wand->process_flags)\n#define _option_type    ((CommandOptionFlags) cli_wand->command->flags)\n#define IfNormalOp      (*option=='-')\n#define IfPlusOp        (*option!='-')\n\n  assert(cli_wand != (MagickCLI *) NULL);\n  assert(cli_wand->signature == MagickWandSignature);\n  assert(cli_wand->wand.signature == MagickWandSignature);\n\n  if (cli_wand->wand.debug != MagickFalse)\n    (void) CLILogEvent(cli_wand,CommandEvent,GetMagickModule(),\n      \"- NoImage Operator: %s \\\"%s\\\" \\\"%s\\\"\", option,\n      arg1n != (char *) NULL ? arg1n : \"\",\n      arg2n != (char *) NULL ? arg2n : \"\");\n\n  arg1 = arg1n;\n  arg2 = arg2n;\n\n  /* Interpret Percent Escapes in Arguments - using first image */\n  if ( (((_process_flags & ProcessInterpretProperities) != 0 )\n        || ((_option_type & AlwaysInterpretArgsFlag) != 0)\n       )  && ((_option_type & NeverInterpretArgsFlag) == 0) ) {\n    /* Interpret Percent escapes in argument 1 */\n    if (arg1n != (char *) NULL) {\n      arg1=InterpretImageProperties(_image_info,_images,arg1n,_exception);\n      if (arg1 == (char *) NULL) {\n        CLIWandException(OptionWarning,\"InterpretPropertyFailure\",option);\n        arg1=arg1n;  /* use the given argument as is */\n      }\n    }\n    if (arg2n != (char *) NULL) {\n      arg2=InterpretImageProperties(_image_info,_images,arg2n,_exception);\n      if (arg2 == (char *) NULL) {\n        CLIWandException(OptionWarning,\"InterpretPropertyFailure\",option);\n        arg2=arg2n;  /* use the given argument as is */\n      }\n    }\n  }\n#undef _process_flags\n#undef _option_type\n\n  do {  /* break to exit code */\n    /*\n      No-op options  (ignore these)\n    */\n    if (LocaleCompare(\"noop\",option+1) == 0)   /* zero argument */\n      break;\n    if (LocaleCompare(\"sans\",option+1) == 0)   /* one argument */\n      break;\n    if (LocaleCompare(\"sans0\",option+1) == 0)  /* zero argument */\n      break;\n    if (LocaleCompare(\"sans1\",option+1) == 0)  /* one argument */\n      break;\n    if (LocaleCompare(\"sans2\",option+1) == 0)  /* two arguments */\n      break;\n    /*\n      Image Reading\n    */\n    if ( ( LocaleCompare(\"read\",option+1) == 0 ) ||\n      ( LocaleCompare(\"--\",option) == 0 ) ) {\n      /* Do Glob filename Expansion for 'arg1' then read all images.\n      *\n      * Expansion handles '@', '~', '*', and '?' meta-characters while ignoring\n      * (but attaching to the filenames in the generated argument list) any\n      * [...] read modifiers that may be present.\n      *\n      * For example: It will expand '*.gif[20x20]' into a list such as\n      * 'abc.gif[20x20]',  'foobar.gif[20x20]',  'xyzzy.gif[20x20]'\n      *\n      * NOTE: In IMv6 this was done globally across all images. This\n      * meant you could include IM options in '@filename' lists, but you\n      * could not include comments.   Doing it only for image read makes\n      * it far more secure.\n      *\n      * Note: arguments do not have percent escapes expanded for security\n      * reasons.\n      */\n      int      argc;\n      char     **argv;\n      ssize_t  i;\n\n      argc = 1;\n      argv = (char **) &arg1;\n\n      /* Expand 'glob' expressions in the given filename.\n        Expansion handles any 'coder:' prefix, or read modifiers attached\n        to the filename, including them in the resulting expanded list.\n      */\n      if (ExpandFilenames(&argc,&argv) == MagickFalse)\n        CLIWandExceptArgBreak(ResourceLimitError,\"MemoryAllocationFailed\",\n            option,GetExceptionMessage(errno));\n\n      /* loop over expanded filename list, and read then all in */\n      for (i=0; i < (ssize_t) argc; i++) {\n        Image *\n          new_images;\n        if (_image_info->ping != MagickFalse)\n          new_images=PingImages(_image_info,argv[i],_exception);\n        else\n          new_images=ReadImages(_image_info,argv[i],_exception);\n        AppendImageToList(&_images, new_images);\n        argv[i]=DestroyString(argv[i]);\n      }\n      argv=(char **) RelinquishMagickMemory(argv);\n      break;\n    }\n    /*\n      Image Writing\n      Note: Writing a empty image list is valid in specific cases\n    */\n    if (LocaleCompare(\"write\",option+1) == 0) {\n      /* Note: arguments do not have percent escapes expanded */\n      char\n        key[MagickPathExtent];\n\n      Image\n        *write_images;\n\n      ImageInfo\n        *write_info;\n\n      /* Need images, unless a \"null:\" output coder is used */\n      if ( _images == (Image *) NULL ) {\n        if ( LocaleCompare(arg1,\"null:\") == 0 )\n          break;\n        CLIWandExceptArgBreak(OptionError,\"NoImagesForWrite\",option,arg1);\n      }\n\n      (void) FormatLocaleString(key,MagickPathExtent,\"cache:%s\",arg1);\n      (void) DeleteImageRegistry(key);\n      write_images=_images;\n      if (IfPlusOp)\n        write_images=CloneImageList(_images,_exception);\n      write_info=CloneImageInfo(_image_info);\n      (void) WriteImages(write_info,write_images,arg1,_exception);\n      write_info=DestroyImageInfo(write_info);\n      if (IfPlusOp)\n        write_images=DestroyImageList(write_images);\n      break;\n    }\n    /*\n      Parenthesis and Brace operations\n    */\n    if (LocaleCompare(\"(\",option) == 0) {\n      /* stack 'push' images */\n      Stack\n        *node;\n\n      size_t\n        size;\n\n      size=0;\n      node=cli_wand->image_list_stack;\n      for ( ; node != (Stack *) NULL; node=node->next)\n        size++;\n      if ( size >= MAX_STACK_DEPTH )\n        CLIWandExceptionBreak(OptionError,\"ParenthesisNestedTooDeeply\",option);\n      node=(Stack *) AcquireMagickMemory(sizeof(*node));\n      if (node == (Stack *) NULL)\n        CLIWandExceptionBreak(ResourceLimitFatalError,\n            \"MemoryAllocationFailed\",option);\n      node->data = (void *)cli_wand->wand.images;\n      node->next = cli_wand->image_list_stack;\n      cli_wand->image_list_stack = node;\n      cli_wand->wand.images = NewImageList();\n\n      /* handle respect-parenthesis */\n      if (IsStringTrue(GetImageOption(cli_wand->wand.image_info,\n                    \"respect-parenthesis\")) != MagickFalse)\n        option=\"{\"; /* fall-thru so as to push image settings too */\n      else\n        break;\n      /* fall thru to operation */\n    }\n    if (LocaleCompare(\"{\",option) == 0) {\n      /* stack 'push' of image_info settings */\n      Stack\n        *node;\n\n      size_t\n        size;\n\n      size=0;\n      node=cli_wand->image_info_stack;\n      for ( ; node != (Stack *) NULL; node=node->next)\n        size++;\n      if ( size >= MAX_STACK_DEPTH )\n        CLIWandExceptionBreak(OptionError,\"CurlyBracesNestedTooDeeply\",option);\n      node=(Stack *) AcquireMagickMemory(sizeof(*node));\n      if (node == (Stack *) NULL)\n        CLIWandExceptionBreak(ResourceLimitFatalError,\n            \"MemoryAllocationFailed\",option);\n\n      node->data = (void *)cli_wand->wand.image_info;\n      node->next = cli_wand->image_info_stack;\n\n      cli_wand->image_info_stack = node;\n      cli_wand->wand.image_info = CloneImageInfo(cli_wand->wand.image_info);\n      if (cli_wand->wand.image_info == (ImageInfo *) NULL) {\n        CLIWandException(ResourceLimitFatalError,\"MemoryAllocationFailed\",\n            option);\n        cli_wand->wand.image_info = (ImageInfo *)node->data;\n        node = (Stack *)RelinquishMagickMemory(node);\n        break;\n      }\n\n      break;\n    }\n    if (LocaleCompare(\")\",option) == 0) {\n      /* pop images from stack */\n      Stack\n        *node;\n\n      node = (Stack *)cli_wand->image_list_stack;\n      if ( node == (Stack *) NULL)\n        CLIWandExceptionBreak(OptionError,\"UnbalancedParenthesis\",option);\n      cli_wand->image_list_stack = node->next;\n\n      AppendImageToList((Image **)&node->data,cli_wand->wand.images);\n      cli_wand->wand.images= (Image *)node->data;\n      node = (Stack *)RelinquishMagickMemory(node);\n\n      /* handle respect-parenthesis - of the previous 'pushed' settings */\n      node = cli_wand->image_info_stack;\n      if ( node != (Stack *) NULL)\n        {\n          if (IsStringTrue(GetImageOption(\n                cli_wand->wand.image_info,\"respect-parenthesis\")) != MagickFalse)\n            option=\"}\"; /* fall-thru so as to pop image settings too */\n          else\n            break;\n        }\n      else\n        break;\n      /* fall thru to next if */\n    }\n    if (LocaleCompare(\"}\",option) == 0) {\n      /* pop image_info settings from stack */\n      Stack\n        *node;\n\n      node = (Stack *)cli_wand->image_info_stack;\n      if ( node == (Stack *) NULL)\n        CLIWandExceptionBreak(OptionError,\"UnbalancedCurlyBraces\",option);\n      cli_wand->image_info_stack = node->next;\n\n      (void) DestroyImageInfo(cli_wand->wand.image_info);\n      cli_wand->wand.image_info = (ImageInfo *)node->data;\n      node = (Stack *)RelinquishMagickMemory(node);\n\n      GetDrawInfo(cli_wand->wand.image_info, cli_wand->draw_info);\n      cli_wand->quantize_info=DestroyQuantizeInfo(cli_wand->quantize_info);\n      cli_wand->quantize_info=AcquireQuantizeInfo(cli_wand->wand.image_info);\n\n      break;\n    }\n      if (LocaleCompare(\"print\",option+1) == 0)\n        {\n          (void) FormatLocaleFile(stdout,\"%s\",arg1);\n          break;\n        }\n    if (LocaleCompare(\"set\",option+1) == 0)\n      {\n        /* Settings are applied to each image in memory in turn (if any).\n           While a option: only need to be applied once globally.\n\n           NOTE: rguments have not been automatically percent expaneded\n        */\n\n        /* escape the 'key' once only, using first image. */\n        arg1=InterpretImageProperties(_image_info,_images,arg1n,_exception);\n        if (arg1 == (char *) NULL)\n          CLIWandExceptionBreak(OptionWarning,\"InterpretPropertyFailure\",\n                option);\n\n        if (LocaleNCompare(arg1,\"registry:\",9) == 0)\n          {\n            if (IfPlusOp)\n              {\n                (void) DeleteImageRegistry(arg1+9);\n                arg1=DestroyString((char *)arg1);\n                break;\n              }\n            arg2=InterpretImageProperties(_image_info,_images,arg2n,_exception);\n            if (arg2 == (char *) NULL) {\n              arg1=DestroyString((char *)arg1);\n              CLIWandExceptionBreak(OptionWarning,\"InterpretPropertyFailure\",\n                    option);\n            }\n            (void) SetImageRegistry(StringRegistryType,arg1+9,arg2,_exception);\n            arg1=DestroyString((char *)arg1);\n            arg2=DestroyString((char *)arg2);\n            break;\n          }\n        if (LocaleNCompare(arg1,\"option:\",7) == 0)\n          {\n            /* delete equivelent artifact from all images (if any) */\n            if (_images != (Image *) NULL)\n              {\n                MagickResetIterator(&cli_wand->wand);\n                while (MagickNextImage(&cli_wand->wand) != MagickFalse)\n                  (void) DeleteImageArtifact(_images,arg1+7);\n                MagickResetIterator(&cli_wand->wand);\n              }\n            /* now set/delete the global option as needed */\n            /* FUTURE: make escapes in a global 'option:' delayed */\n            arg2=(char *) NULL;\n            if (IfNormalOp)\n              {\n                arg2=InterpretImageProperties(_image_info,_images,arg2n,_exception);\n                if (arg2 == (char *) NULL)\n                  CLIWandExceptionBreak(OptionWarning,\n                       \"InterpretPropertyFailure\",option);\n              }\n            (void) SetImageOption(_image_info,arg1+7,arg2);\n            arg1=DestroyString((char *)arg1);\n            arg2=DestroyString((char *)arg2);\n            break;\n          }\n        /* Set Artifacts/Properties/Attributes all images (required) */\n        if ( _images == (Image *) NULL )\n          CLIWandExceptArgBreak(OptionWarning,\"NoImageForProperty\",option,arg1);\n\n        MagickResetIterator(&cli_wand->wand);\n        while (MagickNextImage(&cli_wand->wand) != MagickFalse)\n          {\n            arg2=(char *) NULL;\n            if (IfNormalOp)\n              {\n                arg2=InterpretImageProperties(_image_info,_images,arg2n,_exception);\n                if (arg2 == (char *) NULL)\n                  CLIWandExceptionBreak(OptionWarning,\n                       \"InterpretPropertyFailure\",option);\n              }\n            if (LocaleNCompare(arg1,\"artifact:\",9) == 0)\n              (void) SetImageArtifact(_images,arg1+9,arg2);\n            else if (LocaleNCompare(arg1,\"property:\",9) == 0)\n              (void) SetImageProperty(_images,arg1+9,arg2,_exception);\n            else\n              (void) SetImageProperty(_images,arg1,arg2,_exception);\n            arg2=DestroyString((char *)arg2);\n          }\n        MagickResetIterator(&cli_wand->wand);\n        arg1=DestroyString((char *)arg1);\n        break;\n     }\n    if (LocaleCompare(\"clone\",option+1) == 0) {\n        Image\n          *new_images;\n\n        if (*option == '+')\n          arg1=AcquireString(\"-1\");\n        if (IsSceneGeometry(arg1,MagickFalse) == MagickFalse)\n          CLIWandExceptionBreak(OptionError,\"InvalidArgument\",option);\n        if ( cli_wand->image_list_stack == (Stack *) NULL)\n          CLIWandExceptionBreak(OptionError,\"UnableToCloneImage\",option);\n        new_images = (Image *)cli_wand->image_list_stack->data;\n        if (new_images == (Image *) NULL)\n          CLIWandExceptionBreak(OptionError,\"UnableToCloneImage\",option);\n        new_images=CloneImages(new_images,arg1,_exception);\n        if (new_images == (Image *) NULL)\n          CLIWandExceptionBreak(OptionError,\"NoSuchImage\",option);\n        AppendImageToList(&_images,new_images);\n        break;\n      }\n    /*\n       Informational Operations.\n\n       Note that these do not require either a cli-wand or images!\n       Though currently a cli-wand much be provided regardless.\n    */\n    if (LocaleCompare(\"version\",option+1) == 0)\n      {\n        ListMagickVersion(stdout);\n        break;\n      }\n    if (LocaleCompare(\"list\",option+1) == 0) {\n      /*\n         FUTURE: This 'switch' should really be part of MagickCore\n      */\n      ssize_t\n        list;\n\n      list=ParseCommandOption(MagickListOptions,MagickFalse,arg1);\n      if ( list < 0 ) {\n        CLIWandExceptionArg(OptionError,\"UnrecognizedListType\",option,arg1);\n        break;\n      }\n      switch (list)\n      {\n        case MagickCoderOptions:\n        {\n          (void) ListCoderInfo((FILE *) NULL,_exception);\n          break;\n        }\n        case MagickColorOptions:\n        {\n          (void) ListColorInfo((FILE *) NULL,_exception);\n          break;\n        }\n        case MagickConfigureOptions:\n        {\n          (void) ListConfigureInfo((FILE *) NULL,_exception);\n          break;\n        }\n        case MagickDelegateOptions:\n        {\n          (void) ListDelegateInfo((FILE *) NULL,_exception);\n          break;\n        }\n        case MagickFontOptions:\n        {\n          (void) ListTypeInfo((FILE *) NULL,_exception);\n          break;\n        }\n        case MagickFormatOptions:\n          (void) ListMagickInfo((FILE *) NULL,_exception);\n          break;\n        case MagickLocaleOptions:\n          (void) ListLocaleInfo((FILE *) NULL,_exception);\n          break;\n        case MagickLogOptions:\n          (void) ListLogInfo((FILE *) NULL,_exception);\n          break;\n        case MagickMagicOptions:\n          (void) ListMagicInfo((FILE *) NULL,_exception);\n          break;\n        case MagickMimeOptions:\n          (void) ListMimeInfo((FILE *) NULL,_exception);\n          break;\n        case MagickModuleOptions:\n          (void) ListModuleInfo((FILE *) NULL,_exception);\n          break;\n        case MagickPolicyOptions:\n          (void) ListPolicyInfo((FILE *) NULL,_exception);\n          break;\n        case MagickResourceOptions:\n          (void) ListMagickResourceInfo((FILE *) NULL,_exception);\n          break;\n        case MagickThresholdOptions:\n          (void) ListThresholdMaps((FILE *) NULL,_exception);\n          break;\n        default:\n          (void) ListCommandOptions((FILE *) NULL,(CommandOption) list,\n            _exception);\n          break;\n      }\n      break;\n    }\n\n    CLIWandException(OptionError,\"UnrecognizedOption\",option);\n\nDisableMSCWarning(4127)\n  } while (0);  /* break to exit code. */\nRestoreMSCWarning\n\n  /* clean up percent escape interpreted strings */\n  if (arg1 != arg1n )\n    arg1=DestroyString((char *)arg1);\n  if (arg2 != arg2n )\n    arg2=DestroyString((char *)arg2);\n\n#undef _image_info\n#undef _images\n#undef _exception\n#undef IfNormalOp\n#undef IfPlusOp\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   C L I O p t i o n                                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CLIOption() Processes the given option using the given CLI Magick Wand.\n%  The option arguments can be variable in number, though at this time no more\n%  that two is actually used by any option (this may change). Excess options\n%  are simply ignored.\n%\n%  If the cli_wand->command pointer is non-null, then it is assumed that the\n%  option has already been search for up from the CommandOptions[] table in\n%  \"MagickCore/options.c\" using  GetCommandOptionInfo().  If not set this\n%  routine will do the lookup instead. The pointer is reset afterward.\n%\n%  This action allows the caller to lookup and pre-handle any 'special'\n%  options, (such as implicit reads) before calling this general option\n%  handler to deal with 'standard' command line options.\n%\n%  The format of the CLIOption method is:\n%\n%       void CLIOption(MagickCLI *cli_wand,const char *option, ...)\n%\n%  A description of each parameter follows:\n%\n%     o cli_wand: the main CLI Wand to use.\n%\n%     o option: The special option (with any switch char) to process\n%\n%     o args: any required arguments for an option (variable number)\n%\n%  Example Usage...\n%\n%    CLIoption(cli_wand,\"-read\",\"rose:\");\n%    CLIoption(cli_wand,\"-virtual-pixel\",\"transparent\");\n%    CLIoption(cli_wand,\"-distort\",\"SRT:\",\"30\");\n%    CLIoption(cli_wand,\"-write\",\"rotated_rose.png\");\n%\n*/\nWandExport void CLIOption(MagickCLI *cli_wand,const char *option,...)\n{\n  const char    /* extracted option args from args */\n    *arg1,\n    *arg2;\n\n  CommandOptionFlags\n    option_type;\n\n  assert(cli_wand != (MagickCLI *) NULL);\n  assert(cli_wand->signature == MagickWandSignature);\n  assert(cli_wand->wand.signature == MagickWandSignature);\n\n  do { /* Break Code Block for error handling */\n\n    /* get information about option */\n    if ( cli_wand->command == (const OptionInfo *) NULL )\n      cli_wand->command = GetCommandOptionInfo(option);\n#if 0\n      (void) FormatLocaleFile(stderr, \"CLIOption \\\"%s\\\" matched \\\"%s\\\"\\n\",\n            option, cli_wand->command->mnemonic );\n#endif\n    option_type=(CommandOptionFlags) cli_wand->command->flags;\n\n    if ( option_type == UndefinedOptionFlag )\n      CLIWandExceptionReturn(OptionFatalError,\"UnrecognizedOption\",option);\n\n    assert( LocaleCompare(cli_wand->command->mnemonic,option) == 0 );\n\n    /* deprecated options */\n    if ( (option_type & DeprecateOptionFlag) != 0 )\n      CLIWandExceptionBreak(OptionError,\"DeprecatedOptionNoCode\",option);\n\n    /* options that this module does not handle */\n    if ((option_type & (SpecialOptionFlag|GenesisOptionFlag)) != 0 )\n      CLIWandExceptionBreak(OptionFatalError,\"InvalidUseOfOption\",option);\n\n    /* Get argument strings from VarArgs\n      How can you determine if enough arguments was supplied?\n      What happens if not enough arguments were supplied?\n    */\n    { size_t\n        count = (size_t) cli_wand->command->type;\n\n      va_list\n        operands;\n\n      va_start(operands,option);\n\n      arg1=arg2=NULL;\n      if ( count >= 1 )\n        arg1=(const char *) va_arg(operands, const char *);\n      if ( count >= 2 )\n        arg2=(const char *) va_arg(operands, const char *);\n\n      va_end(operands);\n#if 0\n      (void) FormatLocaleFile(stderr,\n        \"CLIOption: \\\"%s\\\"  Count: %ld  Flags: %04x  Args: \\\"%s\\\" \\\"%s\\\"\\n\",\n            option,(long) count,option_type,arg1,arg2);\n#endif\n    }\n\n    /*\n      Call the appropriate option handler\n    */\n\n    /* FUTURE: this is temporary - get 'settings' to handle distribution of\n      settings to images attributes,proprieties,artifacts */\n    if ( cli_wand->wand.images != (Image *) NULL )\n      (void) SyncImagesSettings(cli_wand->wand.image_info,cli_wand->wand.images,\n        cli_wand->wand.exception);\n\n    if ( (option_type & SettingOptionFlags) != 0 ) {\n      CLISettingOptionInfo(cli_wand, option, arg1, arg2);\n      /*\n        FUTURE: Sync Specific Settings into Image Properities (not global)\n      */\n    }\n\n    /* Operators that do not need images - read, write, stack, clone */\n    if ((option_type & NoImageOperatorFlag) != 0)\n      CLINoImageOperator(cli_wand, option, arg1, arg2);\n\n    /* FUTURE: The not a setting part below is a temporary hack due to\n    * some options being both a Setting and a Simple operator.\n    * Specifically -monitor, -depth, and  -colorspace */\n    if ( cli_wand->wand.images == (Image *) NULL )\n      if ( ((option_type & (SimpleOperatorFlag|ListOperatorFlag)) != 0 ) &&\n          ((option_type & SettingOptionFlags) == 0 ))  /* temp hack */\n        CLIWandExceptionBreak(OptionError,\"NoImagesFound\",option);\n\n    /* Operators which loop of individual images, simply */\n    if ( (option_type & SimpleOperatorFlag) != 0 &&\n         cli_wand->wand.images != (Image *) NULL) /* temp hack */\n      {\n        ExceptionInfo *exception=AcquireExceptionInfo();\n        (void) CLISimpleOperatorImages(cli_wand, option, arg1, arg2,exception);\n        exception=DestroyExceptionInfo(exception);\n      }\n\n    /* Operators that work on the image list as a whole */\n    if ( (option_type & ListOperatorFlag) != 0 )\n      (void) CLIListOperatorImages(cli_wand, option, arg1, arg2);\n\nDisableMSCWarning(4127)\n  } while (0);  /* end Break code block */\nRestoreMSCWarning\n\n  cli_wand->command = (const OptionInfo *) NULL; /* prevent re-use later */\n}\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%          OOO   PPPP   EEEE  RRRR    AA   TTTTT  III   OOO   N   N           %\n%         O   O  P   P  E     R   R  A  A    T     I   O   O  NN  N           %\n%         O   O  PPPP   EEE   RRRR   AAAA    T     I   O   O  N N N           %\n%         O   O  P      E     R R    A  A    T     I   O   O  N  NN           %\n%          OOO   P      EEEE  R  RR  A  A    T    III   OOO   N   N           %\n%                                                                             %\n%                                                                             %\n%                         CLI Magick Option Methods                           %\n%                                                                             %\n%                              Dragon Computing                               %\n%                              Anthony Thyssen                                %\n%                               September 2011                                %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2019 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n% Apply the given options (settings, and simple, or sequence operations) to\n% the given image(s) according to the current \"image_info\", \"draw_info\", and\n% \"quantize_info\" settings, stored in a special CLI Image Wand.\n%\n% The final goal is to allow the execution in a strict one option at a time\n% manner that is needed for 'pipelining and file scripting' of options in\n% IMv7.\n%\n% Anthony Thyssen, September 2011\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickWand/studio.h\"\n#include \"MagickWand/MagickWand.h\"\n#include \"MagickWand/magick-wand-private.h\"\n#include \"MagickWand/mogrify.h\"\n#include \"MagickWand/operation.h\"\n#include \"MagickWand/wand.h\"\n#include \"MagickWand/wandcli.h\"\n#include \"MagickWand/wandcli-private.h\"\n#include \"MagickCore/composite-private.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/pixel-private.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/thread-private.h\"\n#include \"MagickCore/timer-private.h\"\n\f\n/*\n  Constant declaration.\n*/\nstatic const char\n  MogrifyAlphaColor[] = \"#bdbdbd\",  /* slightly darker gray */\n  MogrifyBackgroundColor[] = \"#fff\",  /* white */\n  MogrifyBorderColor[] = \"#dfdfdf\";  /* sRGB gray */\n\f\n/*\n  Define declarations.\n*/\n#define USE_WAND_METHODS  1\n#define MAX_STACK_DEPTH  32\n#define UNDEFINED_COMPRESSION_QUALITY  0UL\n\n/* FUTURE: why is this default so specific? */\n#define DEFAULT_DISSIMILARITY_THRESHOLD \"0.31830988618379067154\"\n\n/* For Debugging Geometry Input */\n#define ReportGeometry(flags,info) \\\n  (void) FormatLocaleFile(stderr, \"Geometry = 0x%04X : %lg x %lg %+lg %+lg\\n\", \\\n       flags, info.rho, info.sigma, info.xi, info.psi )\n\f\n/*\n** Function to report on the progress of image operations\n*/\nstatic MagickBooleanType MonitorProgress(const char *text,\n  const MagickOffsetType offset,const MagickSizeType extent,\n  void *wand_unused(client_data))\n{\n  char\n    message[MagickPathExtent],\n    tag[MagickPathExtent];\n\n  const char\n    *locale_message;\n\n  register char\n    *p;\n\n  magick_unreferenced(client_data);\n\n  if ((extent <= 1) || (offset < 0) || (offset >= (MagickOffsetType) extent))\n    return(MagickTrue);\n  if ((offset != (MagickOffsetType) (extent-1)) && ((offset % 50) != 0))\n    return(MagickTrue);\n  (void) CopyMagickString(tag,text,MagickPathExtent);\n  p=strrchr(tag,'/');\n  if (p != (char *) NULL)\n    *p='\\0';\n  (void) FormatLocaleString(message,MagickPathExtent,\"Monitor/%s\",tag);\n  locale_message=GetLocaleMessage(message);\n  if (locale_message == message)\n    locale_message=tag;\n  if (p == (char *) NULL)\n    (void) FormatLocaleFile(stderr,\"%s: %ld of %lu, %02ld%% complete\\r\",\n      locale_message,(long) offset,(unsigned long) extent,(long)\n      (100L*offset/(extent-1)));\n  else\n    (void) FormatLocaleFile(stderr,\"%s[%s]: %ld of %lu, %02ld%% complete\\r\",\n      locale_message,p+1,(long) offset,(unsigned long) extent,(long)\n      (100L*offset/(extent-1)));\n  if (offset == (MagickOffsetType) (extent-1))\n    (void) FormatLocaleFile(stderr,\"\\n\");\n  (void) fflush(stderr);\n  return(MagickTrue);\n}\n\n/*\n** GetImageCache() will read an image into a image cache if not already\n** present then return the image that is in the cache under that filename.\n*/\nstatic inline Image *GetImageCache(const ImageInfo *image_info,const char *path,\n  ExceptionInfo *exception)\n{\n  char\n    key[MagickPathExtent];\n\n  ExceptionInfo\n    *sans_exception;\n\n  Image\n    *image;\n\n  ImageInfo\n    *read_info;\n\n  (void) FormatLocaleString(key,MagickPathExtent,\"cache:%s\",path);\n  sans_exception=AcquireExceptionInfo();\n  image=(Image *) GetImageRegistry(ImageRegistryType,key,sans_exception);\n  sans_exception=DestroyExceptionInfo(sans_exception);\n  if (image != (Image *) NULL)\n    return(image);\n  read_info=CloneImageInfo(image_info);\n  if (path != (const char *) NULL)\n    (void) CopyMagickString(read_info->filename,path,MagickPathExtent);\n  image=ReadImage(read_info,exception);\n  read_info=DestroyImageInfo(read_info);\n  if (image != (Image *) NULL)\n    (void) SetImageRegistry(ImageRegistryType,key,image,exception);\n  return(image);\n}\n\n/*\n  SparseColorOption() parse the complex -sparse-color argument into an\n  an array of floating point values than call SparseColorImage().\n  Argument is a complex mix of floating-point pixel coodinates, and color\n  specifications (or direct floating point numbers).  The number of floats\n  needed to represent a color varies depending on the current channel\n  setting.\n\n  This really should be in MagickCore, so that other API's can make use of it.\n*/\nstatic Image *SparseColorOption(const Image *image,\n  const SparseColorMethod method,const char *arguments,ExceptionInfo *exception)\n{\n  char\n    token[MagickPathExtent];\n\n  const char\n    *p;\n\n  double\n    *sparse_arguments;\n\n  Image\n    *sparse_image;\n\n  PixelInfo\n    color;\n\n  MagickBooleanType\n    error;\n\n  register size_t\n    x;\n\n  size_t\n    number_arguments,\n    number_colors;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  /*\n    Limit channels according to image\n    add up number of values needed per color.\n  */\n  number_colors=0;\n  if ((GetPixelRedTraits(image) & UpdatePixelTrait) != 0)\n    number_colors++;\n  if ((GetPixelGreenTraits(image) & UpdatePixelTrait) != 0)\n    number_colors++;\n  if ((GetPixelBlueTraits(image) & UpdatePixelTrait) != 0)\n    number_colors++;\n  if (((GetPixelBlackTraits(image) & UpdatePixelTrait) != 0) &&\n      (image->colorspace == CMYKColorspace))\n    number_colors++;\n  if (((GetPixelAlphaTraits(image) & UpdatePixelTrait) != 0) &&\n      image->alpha_trait != UndefinedPixelTrait)\n    number_colors++;\n\n  /*\n    Read string, to determine number of arguments needed,\n  */\n  p=arguments;\n  x=0;\n  while( *p != '\\0' )\n  {\n    GetNextToken(p,&p,MagickPathExtent,token);\n    if ( token[0] == ',' ) continue;\n    if ( isalpha((int) token[0]) || token[0] == '#' )\n      x += number_colors;  /* color argument found */\n    else\n      x++;   /* floating point argument */\n  }\n  /* control points and color values */\n  if ((x % (2+number_colors)) != 0)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"InvalidArgument\",\"'%s': %s\", \"sparse-color\",\n        \"Invalid number of Arguments\");\n      return( (Image *) NULL);\n    }\n  error=MagickFalse;\n  number_arguments=x;\n\n  /* Allocate and fill in the floating point arguments */\n  sparse_arguments=(double *) AcquireQuantumMemory(number_arguments,\n    sizeof(*sparse_arguments));\n  if (sparse_arguments == (double *) NULL) {\n    (void) ThrowMagickException(exception,GetMagickModule(),ResourceLimitError,\n      \"MemoryAllocationFailed\",\"%s\",\"SparseColorOption\");\n    return( (Image *) NULL);\n  }\n  (void) memset(sparse_arguments,0,number_arguments*\n    sizeof(*sparse_arguments));\n  p=arguments;\n  x=0;\n  while( *p != '\\0' && x < number_arguments ) {\n    /* X coordinate */\n    token[0]=','; while ( token[0] == ',' ) GetNextToken(p,&p,MagickPathExtent,token);\n    if ( token[0] == '\\0' ) break;\n    if ( isalpha((int) token[0]) || token[0] == '#' ) {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n            OptionError, \"InvalidArgument\", \"'%s': %s\", \"sparse-color\",\n            \"Color found, instead of X-coord\");\n      error=MagickTrue;\n      break;\n    }\n    sparse_arguments[x++]=StringToDouble(token,(char **) NULL);\n    /* Y coordinate */\n    token[0]=','; while ( token[0] == ',' ) GetNextToken(p,&p,MagickPathExtent,token);\n    if ( token[0] == '\\0' ) break;\n    if ( isalpha((int) token[0]) || token[0] == '#' ) {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n            OptionError, \"InvalidArgument\", \"'%s': %s\", \"sparse-color\",\n            \"Color found, instead of Y-coord\");\n      error=MagickTrue;\n      break;\n    }\n    sparse_arguments[x++]=StringToDouble(token,(char **) NULL);\n    /* color name or function given in string argument */\n    token[0]=','; while ( token[0] == ',' ) GetNextToken(p,&p,MagickPathExtent,token);\n    if ( token[0] == '\\0' ) break;\n    if ( isalpha((int) token[0]) || token[0] == '#' ) {\n      /* Color string given */\n      (void) QueryColorCompliance(token,AllCompliance,&color,\n                exception);\n      if ((GetPixelRedTraits(image) & UpdatePixelTrait) != 0)\n        sparse_arguments[x++] = QuantumScale*color.red;\n      if ((GetPixelGreenTraits(image) & UpdatePixelTrait) != 0)\n        sparse_arguments[x++] = QuantumScale*color.green;\n      if ((GetPixelBlueTraits(image) & UpdatePixelTrait) != 0)\n        sparse_arguments[x++] = QuantumScale*color.blue;\n      if (((GetPixelBlackTraits(image) & UpdatePixelTrait) != 0) &&\n          (image->colorspace == CMYKColorspace))\n        sparse_arguments[x++] = QuantumScale*color.black;\n      if (((GetPixelAlphaTraits(image) & UpdatePixelTrait) != 0) &&\n          image->alpha_trait != UndefinedPixelTrait)\n        sparse_arguments[x++] = QuantumScale*color.alpha;\n    }\n    else {\n      /* Colors given as a set of floating point values - experimental */\n      /* NB: token contains the first floating point value to use! */\n      if ((GetPixelRedTraits(image) & UpdatePixelTrait) != 0)\n        {\n        while ( token[0] == ',' ) GetNextToken(p,&p,MagickPathExtent,token);\n        if ( token[0] == '\\0' || isalpha((int)token[0]) || token[0] == '#' )\n          break;\n        sparse_arguments[x++]=StringToDouble(token,(char **) NULL);\n        token[0] = ','; /* used this token - get another */\n      }\n      if ((GetPixelGreenTraits(image) & UpdatePixelTrait) != 0)\n        {\n        while ( token[0] == ',' ) GetNextToken(p,&p,MagickPathExtent,token);\n        if ( token[0] == '\\0' || isalpha((int)token[0]) || token[0] == '#' )\n          break;\n        sparse_arguments[x++]=StringToDouble(token,(char **) NULL);\n        token[0] = ','; /* used this token - get another */\n      }\n      if ((GetPixelBlueTraits(image) & UpdatePixelTrait) != 0)\n        {\n        while ( token[0] == ',' ) GetNextToken(p,&p,MagickPathExtent,token);\n        if ( token[0] == '\\0' || isalpha((int)token[0]) || token[0] == '#' )\n          break;\n        sparse_arguments[x++]=StringToDouble(token,(char **) NULL);\n        token[0] = ','; /* used this token - get another */\n      }\n      if (((GetPixelBlackTraits(image) & UpdatePixelTrait) != 0) &&\n          (image->colorspace == CMYKColorspace))\n        {\n        while ( token[0] == ',' ) GetNextToken(p,&p,MagickPathExtent,token);\n        if ( token[0] == '\\0' || isalpha((int)token[0]) || token[0] == '#' )\n          break;\n        sparse_arguments[x++]=StringToDouble(token,(char **) NULL);\n        token[0] = ','; /* used this token - get another */\n      }\n      if (((GetPixelAlphaTraits(image) & UpdatePixelTrait) != 0) &&\n          image->alpha_trait != UndefinedPixelTrait)\n        {\n        while ( token[0] == ',' ) GetNextToken(p,&p,MagickPathExtent,token);\n        if ( token[0] == '\\0' || isalpha((int)token[0]) || token[0] == '#' )\n          break;\n        sparse_arguments[x++]=StringToDouble(token,(char **) NULL);\n        token[0] = ','; /* used this token - get another */\n      }\n    }\n  }\n  if (error != MagickFalse)\n    {\n      sparse_arguments=(double *) RelinquishMagickMemory(sparse_arguments);\n      return((Image *) NULL);\n    }\n  if (number_arguments != x)\n    {\n      sparse_arguments=(double *) RelinquishMagickMemory(sparse_arguments);\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"InvalidArgument\",\"'%s': %s\",\"sparse-color\",\"Argument Parsing Error\");\n      return((Image *) NULL);\n    }\n  /* Call the Sparse Color Interpolation function with the parsed arguments */\n  sparse_image=SparseColorImage(image,method,number_arguments,sparse_arguments,\n    exception);\n  sparse_arguments=(double *) RelinquishMagickMemory(sparse_arguments);\n  return( sparse_image );\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   C L I S e t t i n g O p t i o n I n f o                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CLISettingOptionInfo() applies a single settings option into a CLI wand\n%  holding the image_info, draw_info, quantize_info structures that will be\n%  used when processing the images.\n%\n%  These options do no require images to be present in the CLI wand for them\n%  to be able to be set, in which case they will generally be applied to image\n%  that are read in later\n%\n%  Options handled by this function are listed in CommandOptions[] of\n%  \"option.c\" that is one of \"SettingOptionFlags\" option flags.\n%\n%  The format of the CLISettingOptionInfo method is:\n%\n%    void CLISettingOptionInfo(MagickCLI *cli_wand,\n%               const char *option, const char *arg1, const char *arg2)\n%\n%  A description of each parameter follows:\n%\n%    o cli_wand: structure holding settings to be applied\n%\n%    o option: The option string to be set\n%\n%    o arg1, arg2: optional argument strings to the operation\n%        arg2 is currently only used by \"-limit\"\n%\n*/\nWandPrivate void CLISettingOptionInfo(MagickCLI *cli_wand,\n     const char *option,const char *arg1n, const char *arg2n)\n{\n  ssize_t\n    parse;     /* option argument parsing (string to value table lookup) */\n\n  const char    /* percent escaped versions of the args */\n    *arg1,\n    *arg2;\n\n#define _image_info       (cli_wand->wand.image_info)\n#define _image            (cli_wand->wand.images)\n#define _exception        (cli_wand->wand.exception)\n#define _draw_info        (cli_wand->draw_info)\n#define _quantize_info    (cli_wand->quantize_info)\n#define IfSetOption       (*option=='-')\n#define ArgBoolean        IfSetOption ? MagickTrue : MagickFalse\n#define ArgBooleanNot     IfSetOption ? MagickFalse : MagickTrue\n#define ArgBooleanString  (IfSetOption?\"true\":\"false\")\n#define ArgOption(def)    (IfSetOption?arg1:(const char *)(def))\n\n  assert(cli_wand != (MagickCLI *) NULL);\n  assert(cli_wand->signature == MagickWandSignature);\n  assert(cli_wand->wand.signature == MagickWandSignature);\n\n  if (cli_wand->wand.debug != MagickFalse)\n    (void) CLILogEvent(cli_wand,CommandEvent,GetMagickModule(),\n         \"- Setting Option: %s \\\"%s\\\" \\\"%s\\\"\", option,arg1n,arg2n);\n\n  arg1 = arg1n,\n  arg2 = arg2n;\n\n#if 1\n#define _process_flags    (cli_wand->process_flags)\n#define _option_type      ((CommandOptionFlags) cli_wand->command->flags)\n  /* Interpret Percent Escapes in Arguments - using first image */\n  if ( (((_process_flags & ProcessInterpretProperities) != 0 )\n        || ((_option_type & AlwaysInterpretArgsFlag) != 0)\n       )  && ((_option_type & NeverInterpretArgsFlag) == 0) ) {\n    /* Interpret Percent escapes in argument 1 */\n    if (arg1n != (char *) NULL) {\n      arg1=InterpretImageProperties(_image_info,_image,arg1n,_exception);\n      if (arg1 == (char *) NULL) {\n        CLIWandException(OptionWarning,\"InterpretPropertyFailure\",option);\n        arg1=arg1n;  /* use the given argument as is */\n      }\n    }\n    if (arg2n != (char *) NULL) {\n      arg2=InterpretImageProperties(_image_info,_image,arg2n,_exception);\n      if (arg2 == (char *) NULL) {\n        CLIWandException(OptionWarning,\"InterpretPropertyFailure\",option);\n        arg2=arg2n;  /* use the given argument as is */\n      }\n    }\n  }\n#undef _process_flags\n#undef _option_type\n#endif\n\n  switch (*(option+1))\n  {\n    case 'a':\n    {\n      if (LocaleCompare(\"adjoin\",option+1) == 0)\n        {\n          _image_info->adjoin = ArgBoolean;\n          break;\n        }\n      if (LocaleCompare(\"affine\",option+1) == 0)\n        {\n          CLIWandWarnReplaced(\"-draw 'affine ...'\");\n          if (IfSetOption)\n            (void) ParseAffineGeometry(arg1,&_draw_info->affine,_exception);\n          else\n            GetAffineMatrix(&_draw_info->affine);\n          break;\n        }\n      if (LocaleCompare(\"antialias\",option+1) == 0)\n        {\n          _image_info->antialias =\n            _draw_info->stroke_antialias =\n              _draw_info->text_antialias = ArgBoolean;\n          break;\n        }\n      if (LocaleCompare(\"attenuate\",option+1) == 0)\n        {\n          if (IfSetOption && (IsGeometry(arg1) == MagickFalse))\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) SetImageOption(_image_info,option+1,ArgOption(\"1.0\"));\n          break;\n        }\n      if (LocaleCompare(\"authenticate\",option+1) == 0)\n        {\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'b':\n    {\n      if (LocaleCompare(\"background\",option+1) == 0)\n        {\n          /* FUTURE: both _image_info attribute & ImageOption in use!\n             _image_info only used directly for generating new images.\n             SyncImageSettings() used to set per-image attribute.\n\n             FUTURE: if _image_info->background_color is not set then\n             we should fall back to per-image background_color\n\n             At this time -background will 'wipe out' the per-image\n             background color!\n\n             Better error handling of QueryColorCompliance() needed.\n          */\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          (void) QueryColorCompliance(ArgOption(MogrifyBackgroundColor),AllCompliance,\n             &_image_info->background_color,_exception);\n          break;\n        }\n      if (LocaleCompare(\"bias\",option+1) == 0)\n        {\n          /* FUTURE: bias OBSOLETED, replaced by Artifact \"convolve:bias\"\n             as it is actually rarely used except in direct convolve operations\n             Usage outside a direct convolve operation is actally non-sensible!\n\n             SyncImageSettings() used to set per-image attribute.\n          */\n          if (IfSetOption && (IsGeometry(arg1) == MagickFalse))\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) SetImageOption(_image_info,\"convolve:bias\",ArgOption(NULL));\n          break;\n        }\n      if (LocaleCompare(\"black-point-compensation\",option+1) == 0)\n        {\n          /* Used as a image chromaticity setting\n             SyncImageSettings() used to set per-image attribute.\n          */\n          (void) SetImageOption(_image_info,option+1,ArgBooleanString);\n          break;\n        }\n      if (LocaleCompare(\"blue-primary\",option+1) == 0)\n        {\n          /* Image chromaticity X,Y  NB: Y=X if Y not defined\n             Used by many coders including PNG\n             SyncImageSettings() used to set per-image attribute.\n          */\n          arg1=ArgOption(\"0.0\");\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) SetImageOption(_image_info,option+1,arg1);\n          break;\n        }\n      if (LocaleCompare(\"bordercolor\",option+1) == 0)\n        {\n          /* FUTURE: both _image_info attribute & ImageOption in use!\n             SyncImageSettings() used to set per-image attribute.\n             Better error checking of QueryColorCompliance().\n          */\n          if (IfSetOption)\n            {\n              (void) SetImageOption(_image_info,option+1,arg1);\n              (void) QueryColorCompliance(arg1,AllCompliance,\n                  &_image_info->border_color,_exception);\n              (void) QueryColorCompliance(arg1,AllCompliance,\n                  &_draw_info->border_color,_exception);\n              break;\n            }\n          (void) DeleteImageOption(_image_info,option+1);\n          (void) QueryColorCompliance(MogrifyBorderColor,AllCompliance,\n            &_image_info->border_color,_exception);\n          (void) QueryColorCompliance(MogrifyBorderColor,AllCompliance,\n            &_draw_info->border_color,_exception);\n          break;\n        }\n      if (LocaleCompare(\"box\",option+1) == 0)\n        {\n          CLIWandWarnReplaced(\"-undercolor\");\n          CLISettingOptionInfo(cli_wand,\"-undercolor\",arg1, arg2);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'c':\n    {\n      if (LocaleCompare(\"cache\",option+1) == 0)\n        {\n          MagickSizeType\n            limit;\n\n          if (IfSetOption && (IsGeometry(arg1) == MagickFalse))\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          limit=MagickResourceInfinity;\n          if (LocaleCompare(\"unlimited\",arg1) != 0)\n            limit=(MagickSizeType) SiPrefixToDoubleInterval(arg1,100.0);\n          (void) SetMagickResourceLimit(MemoryResource,limit);\n          (void) SetMagickResourceLimit(MapResource,2*limit);\n          break;\n        }\n      if (LocaleCompare(\"caption\",option+1) == 0)\n        {\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          break;\n        }\n      if (LocaleCompare(\"colorspace\",option+1) == 0)\n        {\n          /* Setting used for new images via AquireImage()\n             But also used as a SimpleImageOperator\n             Undefined colorspace means don't modify images on\n             read or as a operation */\n          parse=ParseCommandOption(MagickColorspaceOptions,MagickFalse,\n             ArgOption(\"undefined\"));\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedColorspace\",option,\n              arg1);\n          _image_info->colorspace=(ColorspaceType) parse;\n          break;\n        }\n      if (LocaleCompare(\"comment\",option+1) == 0)\n        {\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          break;\n        }\n      if (LocaleCompare(\"compose\",option+1) == 0)\n        {\n          /* FUTURE: _image_info should be used,\n             SyncImageSettings() used to set per-image attribute. - REMOVE\n\n             This setting should NOT be used to set image 'compose'\n             \"-layer\" operators shoud use _image_info if defined otherwise\n             they should use a per-image compose setting.\n          */\n          parse = ParseCommandOption(MagickComposeOptions,MagickFalse,\n                          ArgOption(\"undefined\"));\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedComposeOperator\",\n                                      option,arg1);\n          _image_info->compose=(CompositeOperator) parse;\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          break;\n        }\n      if (LocaleCompare(\"compress\",option+1) == 0)\n        {\n          /* FUTURE: What should be used?  _image_info  or ImageOption ???\n             The former is more efficent, but Crisy prefers the latter!\n             SyncImageSettings() used to set per-image attribute.\n\n             The coders appears to use _image_info, not Image_Option\n             however the image attribute (for save) is set from the\n             ImageOption!\n\n             Note that \"undefined\" is a different setting to \"none\".\n          */\n          parse = ParseCommandOption(MagickCompressOptions,MagickFalse,\n                     ArgOption(\"undefined\"));\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedImageCompression\",\n                                      option,arg1);\n          _image_info->compression=(CompressionType) parse;\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'd':\n    {\n      if (LocaleCompare(\"debug\",option+1) == 0)\n        {\n          /* SyncImageSettings() used to set per-image attribute. */\n          arg1=ArgOption(\"none\");\n          parse = ParseCommandOption(MagickLogEventOptions,MagickFalse,arg1);\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedEventType\",\n                                      option,arg1);\n          (void) SetLogEventMask(arg1);\n          _image_info->debug=IsEventLogging();   /* extract logging*/\n          cli_wand->wand.debug=IsEventLogging();\n          break;\n        }\n      if (LocaleCompare(\"define\",option+1) == 0)\n        {\n          if (LocaleNCompare(arg1,\"registry:\",9) == 0)\n            {\n              if (IfSetOption)\n                (void) DefineImageRegistry(StringRegistryType,arg1+9,_exception);\n              else\n                (void) DeleteImageRegistry(arg1+9);\n              break;\n            }\n          /* DefineImageOption() equals SetImageOption() but with '=' */\n          if (IfSetOption)\n            (void) DefineImageOption(_image_info,arg1);\n          else if (DeleteImageOption(_image_info,arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"NoSuchOption\",option,arg1);\n          break;\n        }\n      if (LocaleCompare(\"delay\",option+1) == 0)\n        {\n          /* Only used for new images via AcquireImage()\n             FUTURE: Option should also be used for \"-morph\" (color morphing)\n          */\n          arg1=ArgOption(\"0\");\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) SetImageOption(_image_info,option+1,arg1);\n          break;\n        }\n      if (LocaleCompare(\"density\",option+1) == 0)\n        {\n          /* FUTURE: strings used in _image_info attr and _draw_info!\n             Basically as density can be in a XxY form!\n\n             SyncImageSettings() used to set per-image attribute.\n          */\n          if (IfSetOption && (IsGeometry(arg1) == MagickFalse))\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          (void) CloneString(&_image_info->density,ArgOption(NULL));\n          (void) CloneString(&_draw_info->density,_image_info->density);\n          break;\n        }\n      if (LocaleCompare(\"depth\",option+1) == 0)\n        {\n          /* This is also a SimpleImageOperator! for 8->16 vaule trunc !!!!\n             SyncImageSettings() used to set per-image attribute.\n          */\n          if (IfSetOption && (IsGeometry(arg1) == MagickFalse))\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          _image_info->depth=IfSetOption?StringToUnsignedLong(arg1)\n                                       :MAGICKCORE_QUANTUM_DEPTH;\n          break;\n        }\n      if (LocaleCompare(\"direction\",option+1) == 0)\n        {\n          /* Image Option is only used to set _draw_info */\n          arg1=ArgOption(\"undefined\");\n          parse = ParseCommandOption(MagickDirectionOptions,MagickFalse,arg1);\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedDirectionType\",\n                                      option,arg1);\n          _draw_info->direction=(DirectionType) parse;\n          (void) SetImageOption(_image_info,option+1,arg1);\n          break;\n        }\n      if (LocaleCompare(\"display\",option+1) == 0)\n        {\n          (void) CloneString(&_image_info->server_name,ArgOption(NULL));\n          (void) CloneString(&_draw_info->server_name,_image_info->server_name);\n          break;\n        }\n      if (LocaleCompare(\"dispose\",option+1) == 0)\n        {\n          /* only used in setting new images */\n          arg1=ArgOption(\"undefined\");\n          parse = ParseCommandOption(MagickDisposeOptions,MagickFalse,arg1);\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedDisposeMethod\",\n                                      option,arg1);\n          (void) SetImageOption(_image_info,option+1,ArgOption(\"undefined\"));\n          break;\n        }\n      if (LocaleCompare(\"dissimilarity-threshold\",option+1) == 0)\n        {\n          /* FUTURE: this is only used by CompareImages() which is used\n             only by the \"compare\" CLI program at this time.  */\n          arg1=ArgOption(DEFAULT_DISSIMILARITY_THRESHOLD);\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) SetImageOption(_image_info,option+1,arg1);\n          break;\n        }\n      if (LocaleCompare(\"dither\",option+1) == 0)\n        {\n          /* _image_info attr (on/off), _quantize_info attr (on/off)\n             but also ImageInfo and _quantize_info method!\n             FUTURE: merge the duality of the dithering options\n          */\n          _image_info->dither = ArgBoolean;\n          (void) SetImageOption(_image_info,option+1,ArgOption(\"none\"));\n          _quantize_info->dither_method=(DitherMethod) ParseCommandOption(\n             MagickDitherOptions,MagickFalse,ArgOption(\"none\"));\n          if (_quantize_info->dither_method == NoDitherMethod)\n            _image_info->dither = MagickFalse;\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'e':\n    {\n      if (LocaleCompare(\"encoding\",option+1) == 0)\n        {\n          (void) CloneString(&_draw_info->encoding,ArgOption(\"undefined\"));\n          (void) SetImageOption(_image_info,option+1,_draw_info->encoding);\n          break;\n        }\n      if (LocaleCompare(\"endian\",option+1) == 0)\n        {\n          /* Both _image_info attr and ImageInfo */\n          arg1 = ArgOption(\"undefined\");\n          parse = ParseCommandOption(MagickEndianOptions,MagickFalse,arg1);\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedEndianType\",\n                                      option,arg1);\n          /* FUTURE: check alloc/free of endian string!  - remove? */\n          _image_info->endian=(EndianType) (*arg1);\n          (void) SetImageOption(_image_info,option+1,arg1);\n          break;\n        }\n      if (LocaleCompare(\"extract\",option+1) == 0)\n        {\n          (void) CloneString(&_image_info->extract,ArgOption(NULL));\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'f':\n    {\n      if (LocaleCompare(\"family\",option+1) == 0)\n        {\n          (void) CloneString(&_draw_info->family,ArgOption(NULL));\n          break;\n        }\n      if (LocaleCompare(\"features\",option+1) == 0)\n        {\n          (void) SetImageOption(_image_info,\"identify:features\",\n            ArgBooleanString);\n          if (IfSetOption)\n            (void) SetImageArtifact(_image,\"verbose\",\"true\");\n          break;\n        }\n      if (LocaleCompare(\"fill\",option+1) == 0)\n        {\n          /* Set \"fill\" OR \"fill-pattern\" in _draw_info\n             The original fill color is preserved if a fill-pattern is given.\n             That way it does not effect other operations that directly using\n             the fill color and, can be retored using \"+tile\".\n          */\n          MagickBooleanType\n            status;\n\n          ExceptionInfo\n            *sans;\n\n          PixelInfo\n            color;\n\n          arg1 = ArgOption(\"none\");  /* +fill turns it off! */\n          (void) SetImageOption(_image_info,option+1,arg1);\n          if (_draw_info->fill_pattern != (Image *) NULL)\n            _draw_info->fill_pattern=DestroyImage(_draw_info->fill_pattern);\n\n          /* is it a color or a image? -- ignore exceptions */\n          sans=AcquireExceptionInfo();\n          status=QueryColorCompliance(arg1,AllCompliance,&color,sans);\n          sans=DestroyExceptionInfo(sans);\n\n          if (status == MagickFalse)\n            _draw_info->fill_pattern=GetImageCache(_image_info,arg1,_exception);\n          else\n            _draw_info->fill=color;\n          break;\n        }\n      if (LocaleCompare(\"filter\",option+1) == 0)\n        {\n          /* SyncImageSettings() used to set per-image attribute. */\n          arg1 = ArgOption(\"undefined\");\n          parse = ParseCommandOption(MagickFilterOptions,MagickFalse,arg1);\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedImageFilter\",\n                                      option,arg1);\n          (void) SetImageOption(_image_info,option+1,arg1);\n          break;\n        }\n      if (LocaleCompare(\"font\",option+1) == 0)\n        {\n          (void) CloneString(&_draw_info->font,ArgOption(NULL));\n          (void) CloneString(&_image_info->font,_draw_info->font);\n          break;\n        }\n      if (LocaleCompare(\"format\",option+1) == 0)\n        {\n          /* FUTURE: why the ping test, you could set ping after this! */\n          /*\n          register const char\n            *q;\n\n          for (q=strchr(arg1,'%'); q != (char *) NULL; q=strchr(q+1,'%'))\n            if (strchr(\"Agkrz@[#\",*(q+1)) != (char *) NULL)\n              _image_info->ping=MagickFalse;\n          */\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          break;\n        }\n      if (LocaleCompare(\"fuzz\",option+1) == 0)\n        {\n          /* Option used to set image fuzz! unless blank canvas (from color)\n             Image attribute used for color compare operations\n             SyncImageSettings() used to set per-image attribute.\n\n             FUTURE: Can't find anything else using _image_info->fuzz directly!\n                     convert structure attribute to 'option' string\n          */\n          arg1=ArgOption(\"0\");\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          _image_info->fuzz=StringToDoubleInterval(arg1,(double)\n                QuantumRange+1.0);\n          (void) SetImageOption(_image_info,option+1,arg1);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'g':\n    {\n      if (LocaleCompare(\"gravity\",option+1) == 0)\n        {\n          /* SyncImageSettings() used to set per-image attribute. */\n          arg1 = ArgOption(\"none\");\n          parse = ParseCommandOption(MagickGravityOptions,MagickFalse,arg1);\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedGravityType\",\n                                      option,arg1);\n          _draw_info->gravity=(GravityType) parse;\n          (void) SetImageOption(_image_info,option+1,arg1);\n          break;\n        }\n      if (LocaleCompare(\"green-primary\",option+1) == 0)\n        {\n          /* Image chromaticity X,Y  NB: Y=X if Y not defined\n             SyncImageSettings() used to set per-image attribute.\n             Used directly by many coders\n          */\n          arg1=ArgOption(\"0.0\");\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) SetImageOption(_image_info,option+1,arg1);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'h':\n    {\n      if (LocaleCompare(\"highlight-color\",option+1) == 0)\n        {\n          /* FUTURE: this is only used by CompareImages() which is used\n             only by the \"compare\" CLI program at this time.  */\n          (void) SetImageOption(_image_info,\"compare:highlight-color\",\n            ArgOption(NULL));\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'i':\n    {\n      if (LocaleCompare(\"intensity\",option+1) == 0)\n        {\n          arg1 = ArgOption(\"undefined\");\n          parse = ParseCommandOption(MagickPixelIntensityOptions,MagickFalse,\n            arg1);\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedIntensityType\",\n              option,arg1);\n          (void) SetImageOption(_image_info,option+1,arg1);\n          break;\n        }\n      if (LocaleCompare(\"intent\",option+1) == 0)\n        {\n          /* Only used by coders: MIFF, MPC, BMP, PNG\n             and for image profile call to AcquireTransformThreadSet()\n             SyncImageSettings() used to set per-image attribute.\n          */\n          arg1 = ArgOption(\"undefined\");\n          parse = ParseCommandOption(MagickIntentOptions,MagickFalse,arg1);\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedIntentType\",\n                                      option,arg1);\n          (void) SetImageOption(_image_info,option+1,arg1);\n          break;\n        }\n      if (LocaleCompare(\"interlace\",option+1) == 0)\n        {\n          /* _image_info is directly used by coders (so why an image setting?)\n             SyncImageSettings() used to set per-image attribute.\n          */\n          arg1 = ArgOption(\"undefined\");\n          parse = ParseCommandOption(MagickInterlaceOptions,MagickFalse,arg1);\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedInterlaceType\",\n                                      option,arg1);\n          _image_info->interlace=(InterlaceType) parse;\n          (void) SetImageOption(_image_info,option+1,arg1);\n          break;\n        }\n      if (LocaleCompare(\"interline-spacing\",option+1) == 0)\n        {\n          if (IfSetOption && (IsGeometry(arg1) == MagickFalse))\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) SetImageOption(_image_info,option+1, ArgOption(NULL));\n          _draw_info->interline_spacing=StringToDouble(ArgOption(\"0\"),\n               (char **) NULL);\n          break;\n        }\n      if (LocaleCompare(\"interpolate\",option+1) == 0)\n        {\n          /* SyncImageSettings() used to set per-image attribute. */\n          arg1 = ArgOption(\"undefined\");\n          parse = ParseCommandOption(MagickInterpolateOptions,MagickFalse,arg1);\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedInterpolateMethod\",\n                                      option,arg1);\n          (void) SetImageOption(_image_info,option+1,arg1);\n          break;\n        }\n      if (LocaleCompare(\"interword-spacing\",option+1) == 0)\n        {\n          if (IfSetOption && (IsGeometry(arg1) == MagickFalse))\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) SetImageOption(_image_info,option+1, ArgOption(NULL));\n          _draw_info->interword_spacing=StringToDouble(ArgOption(\"0\"),(char **) NULL);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'k':\n    {\n      if (LocaleCompare(\"kerning\",option+1) == 0)\n        {\n          if (IfSetOption && (IsGeometry(arg1) == MagickFalse))\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          _draw_info->kerning=StringToDouble(ArgOption(\"0\"),(char **) NULL);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'l':\n    {\n      if (LocaleCompare(\"label\",option+1) == 0)\n        {\n          /* only used for new images - not in SyncImageOptions() */\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          break;\n        }\n      if (LocaleCompare(\"limit\",option+1) == 0)\n        {\n          MagickSizeType\n            limit;\n\n          limit=MagickResourceInfinity;\n          parse= ParseCommandOption(MagickResourceOptions,MagickFalse,arg1);\n          if ( parse < 0 )\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedResourceType\",\n                option,arg1);\n          if (LocaleCompare(\"unlimited\",arg2) != 0)\n            limit=(MagickSizeType) SiPrefixToDoubleInterval(arg2,100.0);\n          (void) SetMagickResourceLimit((ResourceType)parse,limit);\n          break;\n        }\n      if (LocaleCompare(\"log\",option+1) == 0)\n        {\n          if (IfSetOption) {\n            if ((strchr(arg1,'%') == (char *) NULL))\n              CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n            (void) SetLogFormat(arg1);\n          }\n          break;\n        }\n      if (LocaleCompare(\"lowlight-color\",option+1) == 0)\n        {\n          /* FUTURE: this is only used by CompareImages() which is used\n             only by the \"compare\" CLI program at this time.  */\n          (void) SetImageOption(_image_info,\"compare:lowlight-color\",\n            ArgOption(NULL));\n          break;\n        }\n      if (LocaleCompare(\"loop\",option+1) == 0)\n        {\n          /* SyncImageSettings() used to set per-image attribute. */\n          arg1=ArgOption(\"0\");\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) SetImageOption(_image_info,option+1,arg1);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'm':\n    {\n      if (LocaleCompare(\"mattecolor\",option+1) == 0)\n        {\n          /* SyncImageSettings() used to set per-image attribute. */\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          (void) QueryColorCompliance(ArgOption(MogrifyAlphaColor),\n            AllCompliance,&_image_info->matte_color,_exception);\n          break;\n        }\n      if (LocaleCompare(\"metric\",option+1) == 0)\n        {\n          /* FUTURE: this is only used by CompareImages() which is used\n             only by the \"compare\" CLI program at this time.  */\n          parse=ParseCommandOption(MagickMetricOptions,MagickFalse,arg1);\n          if ( parse < 0 )\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedMetricType\",\n                option,arg1);\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          break;\n        }\n      if (LocaleCompare(\"moments\",option+1) == 0)\n        {\n          (void) SetImageOption(_image_info,\"identify:moments\",\n            ArgBooleanString);\n          if (IfSetOption)\n            (void) SetImageArtifact(_image,\"verbose\",\"true\");\n          break;\n        }\n      if (LocaleCompare(\"monitor\",option+1) == 0)\n        {\n          (void) SetImageInfoProgressMonitor(_image_info, IfSetOption?\n                MonitorProgress: (MagickProgressMonitor) NULL, (void *) NULL);\n          break;\n        }\n      if (LocaleCompare(\"monochrome\",option+1) == 0)\n        {\n          /* Setting (used by some input coders!) -- why?\n             Warning: This is also Special '-type' SimpleOperator\n          */\n          _image_info->monochrome= ArgBoolean;\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'o':\n    {\n      if (LocaleCompare(\"orient\",option+1) == 0)\n        {\n          /* Is not used when defining for new images.\n             This makes it more of a 'operation' than a setting\n             FUTURE: make set meta-data operator instead.\n             SyncImageSettings() used to set per-image attribute.\n          */\n          parse=ParseCommandOption(MagickOrientationOptions,MagickFalse,\n               ArgOption(\"undefined\"));\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedImageOrientation\",\n                                      option,arg1);\n          _image_info->orientation=(OrientationType)parse;\n          (void) SetImageOption(_image_info,option+1, ArgOption(NULL));\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'p':\n    {\n      if (LocaleCompare(\"page\",option+1) == 0)\n        {\n          /* Only used for new images and image generators.\n             SyncImageSettings() used to set per-image attribute. ?????\n             That last is WRONG!!!!\n             FUTURE: adjust named 'page' sizes according density\n          */\n          char\n            *canonical_page,\n            page[MagickPathExtent];\n\n          const char\n            *image_option;\n\n          MagickStatusType\n            flags;\n\n          RectangleInfo\n            geometry;\n\n          if (!IfSetOption)\n            {\n              (void) DeleteImageOption(_image_info,option+1);\n              (void) CloneString(&_image_info->page,(char *) NULL);\n              break;\n            }\n          (void) memset(&geometry,0,sizeof(geometry));\n          image_option=GetImageOption(_image_info,\"page\");\n          if (image_option != (const char *) NULL)\n            flags=ParseAbsoluteGeometry(image_option,&geometry);\n          canonical_page=GetPageGeometry(arg1);\n          flags=ParseAbsoluteGeometry(canonical_page,&geometry);\n          canonical_page=DestroyString(canonical_page);\n          (void) FormatLocaleString(page,MagickPathExtent,\"%lux%lu\",\n            (unsigned long) geometry.width,(unsigned long) geometry.height);\n          if (((flags & XValue) != 0) || ((flags & YValue) != 0))\n            (void) FormatLocaleString(page,MagickPathExtent,\"%lux%lu%+ld%+ld\",\n              (unsigned long) geometry.width,(unsigned long) geometry.height,\n              (long) geometry.x,(long) geometry.y);\n          (void) SetImageOption(_image_info,option+1,page);\n          (void) CloneString(&_image_info->page,page);\n          break;\n        }\n      if (LocaleCompare(\"ping\",option+1) == 0)\n        {\n          _image_info->ping = ArgBoolean;\n          break;\n        }\n      if (LocaleCompare(\"pointsize\",option+1) == 0)\n        {\n          if (IfSetOption) {\n            if (IsGeometry(arg1) == MagickFalse)\n              CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n            _image_info->pointsize =\n            _draw_info->pointsize =\n              StringToDouble(arg1,(char **) NULL);\n          }\n          else {\n            _image_info->pointsize=0.0; /* unset pointsize */\n            _draw_info->pointsize=12.0;\n          }\n          break;\n        }\n      if (LocaleCompare(\"precision\",option+1) == 0)\n        {\n          arg1=ArgOption(\"-1\");\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) SetMagickPrecision(StringToInteger(arg1));\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'q':\n    {\n      if (LocaleCompare(\"quality\",option+1) == 0)\n        {\n          if (IfSetOption && (IsGeometry(arg1) == MagickFalse))\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          _image_info->quality= IfSetOption ? StringToUnsignedLong(arg1)\n                                            : UNDEFINED_COMPRESSION_QUALITY;\n          (void) SetImageOption(_image_info,option+1,ArgOption(\"0\"));\n          break;\n        }\n      if (LocaleCompare(\"quantize\",option+1) == 0)\n        {\n          /* Just a set direct in _quantize_info */\n          arg1=ArgOption(\"undefined\");\n          parse=ParseCommandOption(MagickColorspaceOptions,MagickFalse,arg1);\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedColorspace\",\n                 option,arg1);\n          _quantize_info->colorspace=(ColorspaceType)parse;\n          break;\n        }\n      if (LocaleCompare(\"quiet\",option+1) == 0)\n        {\n          /* FUTURE: if two -quiet is performed you can not do +quiet!\n             This needs to be checked over thoughly.\n          */\n          static WarningHandler\n            warning_handler = (WarningHandler) NULL;\n\n          WarningHandler\n            tmp = SetWarningHandler((WarningHandler) NULL);\n\n          if ( tmp != (WarningHandler) NULL)\n            warning_handler = tmp; /* remember the old handler */\n          if (!IfSetOption)        /* set the old handler */\n            warning_handler=SetWarningHandler(warning_handler);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'r':\n    {\n      if (LocaleCompare(\"red-primary\",option+1) == 0)\n        {\n          /* Image chromaticity X,Y  NB: Y=X if Y not defined\n             Used by many coders\n             SyncImageSettings() used to set per-image attribute.\n          */\n          arg1=ArgOption(\"0.0\");\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) SetImageOption(_image_info,option+1,arg1);\n          break;\n        }\n      if (LocaleCompare(\"regard-warnings\",option+1) == 0)\n        /* FUTURE: to be replaced by a 'fatal-level' type setting */\n        break;\n      if (LocaleCompare(\"render\",option+1) == 0)\n        {\n          /* _draw_info only setting */\n          _draw_info->render= ArgBooleanNot;\n          break;\n        }\n      if (LocaleCompare(\"respect-parenthesis\",option+1) == 0)\n        {\n          /* link image and setting stacks - option is itself saved on stack! */\n          (void) SetImageOption(_image_info,option+1,ArgBooleanString);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 's':\n    {\n      if (LocaleCompare(\"sampling-factor\",option+1) == 0)\n        {\n          /* FUTURE: should be converted to jpeg:sampling_factor */\n          if (IfSetOption && (IsGeometry(arg1) == MagickFalse))\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) CloneString(&_image_info->sampling_factor,ArgOption(NULL));\n          break;\n        }\n      if (LocaleCompare(\"scene\",option+1) == 0)\n        {\n          /* SyncImageSettings() used to set this as a per-image attribute.\n             What ??? Why ????\n          */\n          if (IfSetOption && (IsGeometry(arg1) == MagickFalse))\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          _image_info->scene=StringToUnsignedLong(ArgOption(\"0\"));\n          break;\n        }\n      if (LocaleCompare(\"seed\",option+1) == 0)\n        {\n          if (IfSetOption && (IsGeometry(arg1) == MagickFalse))\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          SetRandomSecretKey(\n               IfSetOption ? (unsigned long) StringToUnsignedLong(arg1)\n                           : (unsigned long) time((time_t *) NULL));\n          break;\n        }\n      if (LocaleCompare(\"size\",option+1) == 0)\n        {\n          /* FUTURE: string in _image_info -- convert to Option ???\n             Look at the special handling for \"size\" in SetImageOption()\n           */\n          (void) CloneString(&_image_info->size,ArgOption(NULL));\n          break;\n        }\n      if (LocaleCompare(\"stretch\",option+1) == 0)\n        {\n          arg1=ArgOption(\"undefined\");\n          parse = ParseCommandOption(MagickStretchOptions,MagickFalse,arg1);\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedStretchType\",\n                 option,arg1);\n          _draw_info->stretch=(StretchType) parse;\n          break;\n        }\n      if (LocaleCompare(\"stroke\",option+1) == 0)\n        {\n          /* set stroke color OR stroke-pattern\n             UPDATE: ensure stroke color is not destroyed is a pattern\n             is given. Just in case the color is also used for other purposes.\n           */\n          MagickBooleanType\n            status;\n\n          ExceptionInfo\n            *sans;\n\n          PixelInfo\n            color;\n\n          arg1 = ArgOption(\"none\");  /* +fill turns it off! */\n          (void) SetImageOption(_image_info,option+1,arg1);\n          if (_draw_info->stroke_pattern != (Image *) NULL)\n            _draw_info->stroke_pattern=DestroyImage(_draw_info->stroke_pattern);\n\n          /* is it a color or a image? -- ignore exceptions */\n          sans=AcquireExceptionInfo();\n          status=QueryColorCompliance(arg1,AllCompliance,&color,sans);\n          sans=DestroyExceptionInfo(sans);\n\n          if (status == MagickFalse)\n            _draw_info->stroke_pattern=GetImageCache(_image_info,arg1,_exception);\n          else\n            _draw_info->stroke=color;\n          break;\n        }\n      if (LocaleCompare(\"strokewidth\",option+1) == 0)\n        {\n          if (IfSetOption && (IsGeometry(arg1) == MagickFalse))\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          _draw_info->stroke_width=StringToDouble(ArgOption(\"1.0\"),\n               (char **) NULL);\n          break;\n        }\n      if (LocaleCompare(\"style\",option+1) == 0)\n        {\n          arg1=ArgOption(\"undefined\");\n          parse = ParseCommandOption(MagickStyleOptions,MagickFalse,arg1);\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedStyleType\",\n                 option,arg1);\n          _draw_info->style=(StyleType) parse;\n          break;\n        }\n#if 0\n      if (LocaleCompare(\"subimage-search\",option+1) == 0)\n        {\n        /* FUTURE: this is only used by CompareImages() which is used\n            only by the \"compare\" CLI program at this time.  */\n          (void) SetImageOption(_image_info,option+1,ArgBooleanString);\n          break;\n        }\n#endif\n      if (LocaleCompare(\"synchronize\",option+1) == 0)\n        {\n          /* FUTURE: syncronize to storage - but what does that mean? */\n          _image_info->synchronize = ArgBoolean;\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 't':\n    {\n      if (LocaleCompare(\"taint\",option+1) == 0)\n        {\n          /* SyncImageSettings() used to set per-image attribute. */\n          (void) SetImageOption(_image_info,option+1,ArgBooleanString);\n          break;\n        }\n      if (LocaleCompare(\"texture\",option+1) == 0)\n        {\n          /* Note: arguments do not have percent escapes expanded */\n          /* FUTURE: move _image_info string to option splay-tree\n             Other than \"montage\" what uses \"texture\" ????\n          */\n          (void) CloneString(&_image_info->texture,ArgOption(NULL));\n          break;\n        }\n      if (LocaleCompare(\"tile\",option+1) == 0)\n        {\n          /* Note: arguments do not have percent escapes expanded */\n          _draw_info->fill_pattern=IfSetOption\n                                 ?GetImageCache(_image_info,arg1,_exception)\n                                 :DestroyImage(_draw_info->fill_pattern);\n          break;\n        }\n      if (LocaleCompare(\"tile-offset\",option+1) == 0)\n        {\n          /* SyncImageSettings() used to set per-image attribute. ??? */\n          arg1=ArgOption(\"0\");\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) SetImageOption(_image_info,option+1,arg1);\n          break;\n        }\n      if (LocaleCompare(\"transparent-color\",option+1) == 0)\n        {\n          /* FUTURE: both _image_info attribute & ImageOption in use!\n             _image_info only used for generating new images.\n             SyncImageSettings() used to set per-image attribute.\n\n             Note that +transparent-color, means fall-back to image\n             attribute so ImageOption is deleted, not set to a default.\n          */\n          if (IfSetOption && (IsGeometry(arg1) == MagickFalse))\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          (void) QueryColorCompliance(ArgOption(\"none\"),AllCompliance,\n              &_image_info->transparent_color,_exception);\n          break;\n        }\n      if (LocaleCompare(\"treedepth\",option+1) == 0)\n        {\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          _quantize_info->tree_depth=StringToUnsignedLong(ArgOption(\"0\"));\n          break;\n        }\n      if (LocaleCompare(\"type\",option+1) == 0)\n        {\n          /* SyncImageSettings() used to set per-image attribute. */\n          parse=ParseCommandOption(MagickTypeOptions,MagickFalse,\n               ArgOption(\"undefined\"));\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedImageType\",\n                 option,arg1);\n          _image_info->type=(ImageType) parse;\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'u':\n    {\n      if (LocaleCompare(\"undercolor\",option+1) == 0)\n        {\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          (void) QueryColorCompliance(ArgOption(\"none\"),AllCompliance,\n               &_draw_info->undercolor,_exception);\n          break;\n        }\n      if (LocaleCompare(\"units\",option+1) == 0)\n        {\n          /* SyncImageSettings() used to set per-image attribute.\n             Should this effect _draw_info X and Y resolution?\n             FUTURE: this probably should be part of the density setting\n          */\n          parse=ParseCommandOption(MagickResolutionOptions,MagickFalse,\n               ArgOption(\"undefined\"));\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedUnitsType\",\n                 option,arg1);\n          _image_info->units=(ResolutionType) parse;\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'v':\n    {\n      if (LocaleCompare(\"verbose\",option+1) == 0)\n        {\n          /* FUTURE: Remember all options become image artifacts\n             _image_info->verbose is only used by coders.\n          */\n          (void) SetImageOption(_image_info,option+1,ArgBooleanString);\n          _image_info->verbose= ArgBoolean;\n          _image_info->ping=MagickFalse; /* verbose can't be a ping */\n          break;\n        }\n      if (LocaleCompare(\"virtual-pixel\",option+1) == 0)\n        {\n          /* SyncImageSettings() used to set per-image attribute.\n             This is VERY deep in the image caching structure.\n          */\n          parse=ParseCommandOption(MagickVirtualPixelOptions,MagickFalse,\n               ArgOption(\"undefined\"));\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedVirtualPixelMethod\",\n                 option,arg1);\n          (void) SetImageOption(_image_info,option+1,ArgOption(NULL));\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'w':\n    {\n      if (LocaleCompare(\"weight\",option+1) == 0)\n        {\n          ssize_t\n            weight;\n\n          weight=ParseCommandOption(MagickWeightOptions,MagickFalse,arg1);\n          if (weight == -1)\n            weight=(ssize_t) StringToUnsignedLong(arg1);\n          _draw_info->weight=(size_t) weight;\n          break;\n        }\n      if (LocaleCompare(\"white-point\",option+1) == 0)\n        {\n          /* Used as a image chromaticity setting\n             SyncImageSettings() used to set per-image attribute.\n          */\n          arg1=ArgOption(\"0.0\");\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) SetImageOption(_image_info,option+1,arg1);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    default:\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n  }\n\n  /* clean up percent escape interpreted strings */\n  if ((arg1 && arg1n) && (arg1 != arg1n ))\n    arg1=DestroyString((char *) arg1);\n  if ((arg2 && arg2n) && (arg2 != arg2n ))\n    arg2=DestroyString((char *) arg2);\n\n#undef _image_info\n#undef _exception\n#undef _draw_info\n#undef _quantize_info\n#undef IfSetOption\n#undef ArgBoolean\n#undef ArgBooleanNot\n#undef ArgBooleanString\n#undef ArgOption\n\n  return;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+     C L I S i m p l e O p e r a t o r I m a g e s                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CLISimpleOperatorImages() applys one simple image operation given to all\n%  the images in the CLI wand, using any per-image or global settings that was\n%  previously saved in the CLI wand.\n%\n%  It is assumed that any such settings are up-to-date.\n%\n%  The format of the WandSimpleOperatorImages method is:\n%\n%    MagickBooleanType CLISimpleOperatorImages(MagickCLI *cli_wand,const char *option,\n%      const char *arg1, const char *arg2,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o cli_wand: structure holding settings and images to be operated on\n%\n%    o option:  The option string for the operation\n%\n%    o arg1, arg2: optional argument strings to the operation\n%\n*/\n\n/*\n  CLISimpleOperatorImage() is an Internal subrountine to apply one simple\n  image operation to the current image pointed to by the CLI wand.\n\n  The image in the list may be modified in three different ways...\n    * directly modified (EG: -negate, -gamma, -level, -annotate, -draw),\n    * replaced by a new image (EG: -spread, -resize, -rotate, -morphology)\n    * one image replace by a list of images (-separate and -crop only!)\n\n  In each case the result replaces the single original image in the list, as\n  well as the pointer to the modified image (last image added if replaced by a\n  list of images) is returned.\n\n  As the image pointed to may be replaced, the first image in the list may\n  also change.  GetFirstImageInList() should be used by caller if they wish\n  return the Image pointer to the first image in list.\n*/\nstatic MagickBooleanType CLISimpleOperatorImage(MagickCLI *cli_wand,\n  const char *option, const char *arg1n, const char *arg2n,\n  ExceptionInfo *exception)\n{\n  Image *\n    new_image;\n\n  GeometryInfo\n    geometry_info;\n\n  RectangleInfo\n    geometry;\n\n  MagickStatusType\n    flags;\n\n  ssize_t\n    parse;\n\n  const char    /* percent escaped versions of the args */\n    *arg1,\n    *arg2;\n\n#define _image_info       (cli_wand->wand.image_info)\n#define _image            (cli_wand->wand.images)\n#define _exception        (cli_wand->wand.exception)\n#define _draw_info        (cli_wand->draw_info)\n#define _quantize_info    (cli_wand->quantize_info)\n#define _process_flags    (cli_wand->process_flags)\n#define _option_type      ((CommandOptionFlags) cli_wand->command->flags)\n#define IfNormalOp        (*option=='-')\n#define IfPlusOp          (*option!='-')\n#define IsNormalOp        IfNormalOp ? MagickTrue : MagickFalse\n#define IsPlusOp          IfNormalOp ? MagickFalse : MagickTrue\n\n  assert(cli_wand != (MagickCLI *) NULL);\n  assert(cli_wand->signature == MagickWandSignature);\n  assert(cli_wand->wand.signature == MagickWandSignature);\n  assert(_image != (Image *) NULL);             /* an image must be present */\n  if (cli_wand->wand.debug != MagickFalse)\n    (void) LogMagickEvent(WandEvent,GetMagickModule(),\"%s\",cli_wand->wand.name);\n\n  arg1 = arg1n,\n  arg2 = arg2n;\n\n  /* Interpret Percent Escapes in Arguments - using first image */\n  if ( (((_process_flags & ProcessInterpretProperities) != 0 )\n        || ((_option_type & AlwaysInterpretArgsFlag) != 0)\n       )  && ((_option_type & NeverInterpretArgsFlag) == 0) ) {\n    /* Interpret Percent escapes in argument 1 */\n    if (arg1n != (char *) NULL) {\n      arg1=InterpretImageProperties(_image_info,_image,arg1n,_exception);\n      if (arg1 == (char *) NULL) {\n        CLIWandException(OptionWarning,\"InterpretPropertyFailure\",option);\n        arg1=arg1n;  /* use the given argument as is */\n      }\n    }\n    if (arg2n != (char *) NULL) {\n      arg2=InterpretImageProperties(_image_info,_image,arg2n,_exception);\n      if (arg2 == (char *) NULL) {\n        CLIWandException(OptionWarning,\"InterpretPropertyFailure\",option);\n        arg2=arg2n;  /* use the given argument as is */\n      }\n    }\n  }\n#undef _process_flags\n#undef _option_type\n\n#if 0\n  (void) FormatLocaleFile(stderr,\n    \"CLISimpleOperatorImage: \\\"%s\\\" \\\"%s\\\" \\\"%s\\\"\\n\",option,arg1,arg2);\n#endif\n\n  new_image = (Image *) NULL; /* the replacement image, if not null at end */\n  SetGeometryInfo(&geometry_info);\n\n  switch (*(option+1))\n  {\n    case 'a':\n    {\n      if (LocaleCompare(\"adaptive-blur\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=1.0;\n          new_image=AdaptiveBlurImage(_image,geometry_info.rho,\n            geometry_info.sigma,_exception);\n          break;\n        }\n      if (LocaleCompare(\"adaptive-resize\",option+1) == 0)\n        {\n          /* FUTURE: Roll into a resize special operator */\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) ParseRegionGeometry(_image,arg1,&geometry,_exception);\n          new_image=AdaptiveResizeImage(_image,geometry.width,geometry.height,\n            _exception);\n          break;\n        }\n      if (LocaleCompare(\"adaptive-sharpen\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=1.0;\n          new_image=AdaptiveSharpenImage(_image,geometry_info.rho,\n            geometry_info.sigma,_exception);\n          break;\n        }\n      if (LocaleCompare(\"alpha\",option+1) == 0)\n        {\n          parse=ParseCommandOption(MagickAlphaChannelOptions,MagickFalse,arg1);\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedAlphaChannelOption\",\n              option,arg1);\n          (void) SetImageAlphaChannel(_image,(AlphaChannelOption) parse,\n            _exception);\n          break;\n        }\n      if (LocaleCompare(\"annotate\",option+1) == 0)\n        {\n          char\n            geometry[MagickPathExtent];\n\n          SetGeometryInfo(&geometry_info);\n          flags=ParseGeometry(arg1,&geometry_info);\n          if (flags == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=geometry_info.rho;\n          (void) CloneString(&_draw_info->text,arg2);\n          (void) FormatLocaleString(geometry,MagickPathExtent,\"%+f%+f\",\n            geometry_info.xi,geometry_info.psi);\n          (void) CloneString(&_draw_info->geometry,geometry);\n          _draw_info->affine.sx=cos(DegreesToRadians(\n            fmod(geometry_info.rho,360.0)));\n          _draw_info->affine.rx=sin(DegreesToRadians(\n            fmod(geometry_info.rho,360.0)));\n          _draw_info->affine.ry=(-sin(DegreesToRadians(\n            fmod(geometry_info.sigma,360.0))));\n          _draw_info->affine.sy=cos(DegreesToRadians(\n            fmod(geometry_info.sigma,360.0)));\n          (void) AnnotateImage(_image,_draw_info,_exception);\n          GetAffineMatrix(&_draw_info->affine);\n          break;\n        }\n      if (LocaleCompare(\"auto-gamma\",option+1) == 0)\n        {\n          (void) AutoGammaImage(_image,_exception);\n          break;\n        }\n      if (LocaleCompare(\"auto-level\",option+1) == 0)\n        {\n          (void) AutoLevelImage(_image,_exception);\n          break;\n        }\n      if (LocaleCompare(\"auto-orient\",option+1) == 0)\n        {\n          new_image=AutoOrientImage(_image,_image->orientation,_exception);\n          break;\n        }\n      if (LocaleCompare(\"auto-threshold\",option+1) == 0)\n        {\n          AutoThresholdMethod\n            method;\n\n          method=(AutoThresholdMethod) ParseCommandOption(\n            MagickAutoThresholdOptions,MagickFalse,arg1);\n          (void) AutoThresholdImage(_image,method,_exception);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'b':\n    {\n      if (LocaleCompare(\"black-threshold\",option+1) == 0)\n        {\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) BlackThresholdImage(_image,arg1,_exception);\n          break;\n        }\n      if (LocaleCompare(\"blue-shift\",option+1) == 0)\n        {\n          geometry_info.rho=1.5;\n          if (IfNormalOp) {\n            flags=ParseGeometry(arg1,&geometry_info);\n            if ((flags & RhoValue) == 0)\n              CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          }\n          new_image=BlueShiftImage(_image,geometry_info.rho,_exception);\n          break;\n        }\n      if (LocaleCompare(\"blur\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=1.0;\n          new_image=BlurImage(_image,geometry_info.rho,geometry_info.sigma,\n           _exception);\n          break;\n        }\n      if (LocaleCompare(\"border\",option+1) == 0)\n        {\n          CompositeOperator\n            compose;\n\n          const char*\n            value;\n\n          flags=ParsePageGeometry(_image,arg1,&geometry,_exception);\n          if ((flags & (WidthValue | HeightValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          compose=OverCompositeOp;\n          value=GetImageOption(_image_info,\"compose\");\n          if (value != (const char *) NULL)\n            compose=(CompositeOperator) ParseCommandOption(MagickComposeOptions,\n              MagickFalse,value);\n          new_image=BorderImage(_image,&geometry,compose,_exception);\n          break;\n        }\n      if (LocaleCompare(\"brightness-contrast\",option+1) == 0)\n        {\n          double\n            brightness,\n            contrast;\n\n          GeometryInfo\n            geometry_info;\n\n          MagickStatusType\n            flags;\n\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & RhoValue) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          brightness=geometry_info.rho;\n          contrast=0.0;\n          if ((flags & SigmaValue) != 0)\n            contrast=geometry_info.sigma;\n          (void) BrightnessContrastImage(_image,brightness,contrast,\n            _exception);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'c':\n    {\n      if (LocaleCompare(\"canny\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=1.0;\n          if ((flags & XiValue) == 0)\n            geometry_info.xi=10;\n          if ((flags & PsiValue) == 0)\n            geometry_info.psi=30;\n          if ((flags & PercentValue) != 0)\n            {\n              geometry_info.xi/=100.0;\n              geometry_info.psi/=100.0;\n            }\n          new_image=CannyEdgeImage(_image,geometry_info.rho,geometry_info.sigma,\n            geometry_info.xi,geometry_info.psi,_exception);\n          break;\n        }\n      if (LocaleCompare(\"cdl\",option+1) == 0)\n        {\n          char\n            *color_correction_collection; /* Note: arguments do not have percent escapes expanded */\n\n          /*\n            Color correct with a color decision list.\n          */\n          color_correction_collection=FileToString(arg1,~0UL,_exception);\n          if (color_correction_collection == (char *) NULL)\n            break;\n          (void) ColorDecisionListImage(_image,color_correction_collection,\n            _exception);\n          break;\n        }\n      if (LocaleCompare(\"channel\",option+1) == 0)\n        {\n          if (IfPlusOp)\n            {\n              (void) SetPixelChannelMask(_image,DefaultChannels);\n              break;\n            }\n          parse=ParseChannelOption(arg1);\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedChannelType\",option,\n              arg1);\n          (void) SetPixelChannelMask(_image,(ChannelType) parse);\n          break;\n        }\n      if (LocaleCompare(\"charcoal\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=1.0;\n          if ((flags & XiValue) == 0)\n            geometry_info.xi=1.0;\n          new_image=CharcoalImage(_image,geometry_info.rho,geometry_info.sigma,\n            _exception);\n          break;\n        }\n      if (LocaleCompare(\"chop\",option+1) == 0)\n        {\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) ParseGravityGeometry(_image,arg1,&geometry,_exception);\n          new_image=ChopImage(_image,&geometry,_exception);\n          break;\n        }\n      if (LocaleCompare(\"clahe\",option+1) == 0)\n        {\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          flags=ParseGeometry(arg1,&geometry_info);\n          flags=ParseRegionGeometry(_image,arg1,&geometry,_exception);\n          (void) CLAHEImage(_image,geometry.width,geometry.height,\n            (size_t) geometry.x,geometry_info.psi,_exception);\n          break;\n        }\n      if (LocaleCompare(\"clamp\",option+1) == 0)\n        {\n          (void) ClampImage(_image,_exception);\n          break;\n        }\n      if (LocaleCompare(\"clip\",option+1) == 0)\n        {\n          if (IfNormalOp)\n            (void) ClipImage(_image,_exception);\n          else /* \"+mask\" remove the write mask */\n            (void) SetImageMask(_image,WritePixelMask,(Image *) NULL,\n              _exception);\n          break;\n        }\n      if (LocaleCompare(\"clip-mask\",option+1) == 0)\n        {\n          Image\n            *clip_mask;\n\n          if (IfPlusOp) {\n            /* use \"+clip-mask\" Remove the write mask for -clip-path */\n            (void) SetImageMask(_image,WritePixelMask,(Image *) NULL,_exception);\n            break;\n          }\n          clip_mask=GetImageCache(_image_info,arg1,_exception);\n          if (clip_mask == (Image *) NULL)\n            break;\n          (void) SetImageMask(_image,WritePixelMask,clip_mask,_exception);\n          clip_mask=DestroyImage(clip_mask);\n          break;\n        }\n      if (LocaleCompare(\"clip-path\",option+1) == 0)\n        {\n          (void) ClipImagePath(_image,arg1,IsNormalOp,_exception);\n          /* Note: Use \"+clip-mask\" remove the write mask added */\n          break;\n        }\n      if (LocaleCompare(\"colorize\",option+1) == 0)\n        {\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          new_image=ColorizeImage(_image,arg1,&_draw_info->fill,_exception);\n          break;\n        }\n      if (LocaleCompare(\"color-matrix\",option+1) == 0)\n        {\n          KernelInfo\n            *kernel;\n\n          kernel=AcquireKernelInfo(arg1,exception);\n          if (kernel == (KernelInfo *) NULL)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          new_image=ColorMatrixImage(_image,kernel,_exception);\n          kernel=DestroyKernelInfo(kernel);\n          break;\n        }\n      if (LocaleCompare(\"colors\",option+1) == 0)\n        {\n          /* Reduce the number of colors in the image.\n             FUTURE: also provide 'plus version with image 'color counts'\n          */\n          _quantize_info->number_colors=StringToUnsignedLong(arg1);\n          if (_quantize_info->number_colors == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((_image->storage_class == DirectClass) ||\n              _image->colors > _quantize_info->number_colors)\n            (void) QuantizeImage(_quantize_info,_image,_exception);\n          else\n            (void) CompressImageColormap(_image,_exception);\n          break;\n        }\n      if (LocaleCompare(\"colorspace\",option+1) == 0)\n        {\n          /* WARNING: this is both a image_info setting (already done)\n                      and a operator to change image colorspace.\n\n             FUTURE: default colorspace should be sRGB!\n             Unless some type of 'linear colorspace' mode is set.\n\n             Note that +colorspace sets \"undefined\" or no effect on\n             new images, but forces images already in memory back to RGB!\n             That seems to be a little strange!\n          */\n          (void) TransformImageColorspace(_image,\n                    IfNormalOp ? _image_info->colorspace : sRGBColorspace,\n                    _exception);\n          break;\n        }\n      if (LocaleCompare(\"connected-components\",option+1) == 0)\n        {\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          new_image=ConnectedComponentsImage(_image,(size_t)\n            StringToInteger(arg1),(CCObjectInfo **) NULL,_exception);\n          break;\n        }\n      if (LocaleCompare(\"contrast\",option+1) == 0)\n        {\n          CLIWandWarnReplaced(IfNormalOp?\"-level\":\"+level\");\n          (void) ContrastImage(_image,IsNormalOp,_exception);\n          break;\n        }\n      if (LocaleCompare(\"contrast-stretch\",option+1) == 0)\n        {\n          double\n            black_point,\n            white_point;\n\n          MagickStatusType\n            flags;\n\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & RhoValue) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          black_point=geometry_info.rho;\n          white_point=(flags & SigmaValue) != 0 ? geometry_info.sigma :\n            black_point;\n          if ((flags & PercentValue) != 0) {\n              black_point*=(double) _image->columns*_image->rows/100.0;\n              white_point*=(double) _image->columns*_image->rows/100.0;\n            }\n          white_point=(double) _image->columns*_image->rows-white_point;\n          (void) ContrastStretchImage(_image,black_point,white_point,\n            _exception);\n          break;\n        }\n      if (LocaleCompare(\"convolve\",option+1) == 0)\n        {\n          double\n            gamma;\n\n          KernelInfo\n            *kernel_info;\n\n          register ssize_t\n            j;\n\n          kernel_info=AcquireKernelInfo(arg1,exception);\n          if (kernel_info == (KernelInfo *) NULL)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          gamma=0.0;\n          for (j=0; j < (ssize_t) (kernel_info->width*kernel_info->height); j++)\n            gamma+=kernel_info->values[j];\n          gamma=1.0/(fabs((double) gamma) <= MagickEpsilon ? 1.0 : gamma);\n          for (j=0; j < (ssize_t) (kernel_info->width*kernel_info->height); j++)\n            kernel_info->values[j]*=gamma;\n          new_image=MorphologyImage(_image,CorrelateMorphology,1,kernel_info,\n            _exception);\n          kernel_info=DestroyKernelInfo(kernel_info);\n          break;\n        }\n      if (LocaleCompare(\"crop\",option+1) == 0)\n        {\n          /* WARNING: This can generate multiple images! */\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          new_image=CropImageToTiles(_image,arg1,_exception);\n          break;\n        }\n      if (LocaleCompare(\"cycle\",option+1) == 0)\n        {\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) CycleColormapImage(_image,(ssize_t) StringToLong(arg1),\n            _exception);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'd':\n    {\n      if (LocaleCompare(\"decipher\",option+1) == 0)\n        {\n          /* Note: arguments do not have percent escapes expanded */\n          StringInfo\n            *passkey;\n\n          passkey=FileToStringInfo(arg1,~0UL,_exception);\n          if (passkey == (StringInfo *) NULL)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n\n          (void) PasskeyDecipherImage(_image,passkey,_exception);\n          passkey=DestroyStringInfo(passkey);\n          break;\n        }\n      if (LocaleCompare(\"depth\",option+1) == 0)\n        {\n          /* The _image_info->depth setting has already been set\n             We just need to apply it to all images in current sequence\n\n             WARNING: Depth from 8 to 16 causes 'quantum rounding to images!\n             That is it really is an operation, not a setting! Arrgghhh\n\n             FUTURE: this should not be an operator!!!\n          */\n          (void) SetImageDepth(_image,_image_info->depth,_exception);\n          break;\n        }\n      if (LocaleCompare(\"deskew\",option+1) == 0)\n        {\n          double\n            threshold;\n\n          if (IfNormalOp) {\n            if (IsGeometry(arg1) == MagickFalse)\n              CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n            threshold=StringToDoubleInterval(arg1,(double) QuantumRange+1.0);\n          }\n          else\n            threshold=40.0*QuantumRange/100.0;\n          new_image=DeskewImage(_image,threshold,_exception);\n          break;\n        }\n      if (LocaleCompare(\"despeckle\",option+1) == 0)\n        {\n          new_image=DespeckleImage(_image,_exception);\n          break;\n        }\n      if (LocaleCompare(\"distort\",option+1) == 0)\n        {\n          double\n            *args;\n\n          ssize_t\n            count;\n\n          parse = ParseCommandOption(MagickDistortOptions,MagickFalse,arg1);\n          if ( parse < 0 )\n             CLIWandExceptArgBreak(OptionError,\"UnrecognizedDistortMethod\",\n                                      option,arg1);\n          if ((DistortMethod) parse == ResizeDistortion)\n            {\n               double\n                 resize_args[2];\n               /* Special Case - Argument is actually a resize geometry!\n               ** Convert that to an appropriate distortion argument array.\n               ** FUTURE: make a separate special resize operator\n                    Roll into a resize special operator */\n               if (IsGeometry(arg2) == MagickFalse)\n                 CLIWandExceptArgBreak(OptionError,\"InvalidGeometry\",\n                                           option,arg2);\n               (void) ParseRegionGeometry(_image,arg2,&geometry,_exception);\n               resize_args[0]=(double) geometry.width;\n               resize_args[1]=(double) geometry.height;\n               new_image=DistortImage(_image,(DistortMethod) parse,\n                    (size_t)2,resize_args,MagickTrue,_exception);\n               break;\n            }\n          /* convert argument string into an array of doubles */\n          args = StringToArrayOfDoubles(arg2,&count,_exception);\n          if (args == (double *) NULL )\n            CLIWandExceptArgBreak(OptionError,\"InvalidNumberList\",option,arg2);\n\n          new_image=DistortImage(_image,(DistortMethod) parse,(size_t)\n             count,args,IsPlusOp,_exception);\n          args=(double *) RelinquishMagickMemory(args);\n          break;\n        }\n      if (LocaleCompare(\"draw\",option+1) == 0)\n        {\n          (void) CloneString(&_draw_info->primitive,arg1);\n          (void) DrawImage(_image,_draw_info,_exception);\n          (void) CloneString(&_draw_info->primitive,(char *) NULL);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'e':\n    {\n      if (LocaleCompare(\"edge\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          new_image=EdgeImage(_image,geometry_info.rho,_exception);\n          break;\n        }\n      if (LocaleCompare(\"emboss\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=1.0;\n          new_image=EmbossImage(_image,geometry_info.rho,\n            geometry_info.sigma,_exception);\n          break;\n        }\n      if (LocaleCompare(\"encipher\",option+1) == 0)\n        {\n          /* Note: arguments do not have percent escapes expanded */\n          StringInfo\n            *passkey;\n\n          passkey=FileToStringInfo(arg1,~0UL,_exception);\n          if (passkey != (StringInfo *) NULL)\n            {\n              (void) PasskeyEncipherImage(_image,passkey,_exception);\n              passkey=DestroyStringInfo(passkey);\n            }\n          break;\n        }\n      if (LocaleCompare(\"enhance\",option+1) == 0)\n        {\n          new_image=EnhanceImage(_image,_exception);\n          break;\n        }\n      if (LocaleCompare(\"equalize\",option+1) == 0)\n        {\n          (void) EqualizeImage(_image,_exception);\n          break;\n        }\n      if (LocaleCompare(\"evaluate\",option+1) == 0)\n        {\n          double\n            constant;\n\n          parse = ParseCommandOption(MagickEvaluateOptions,MagickFalse,arg1);\n          if ( parse < 0 )\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedEvaluateOperator\",\n                 option,arg1);\n          if (IsGeometry(arg2) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg2);\n          constant=StringToDoubleInterval(arg2,(double) QuantumRange+1.0);\n          (void) EvaluateImage(_image,(MagickEvaluateOperator)parse,constant,\n               _exception);\n          break;\n        }\n      if (LocaleCompare(\"extent\",option+1) == 0)\n        {\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          flags=ParseGravityGeometry(_image,arg1,&geometry,_exception);\n          if (geometry.width == 0)\n            geometry.width=_image->columns;\n          if (geometry.height == 0)\n            geometry.height=_image->rows;\n          new_image=ExtentImage(_image,&geometry,_exception);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'f':\n    {\n      if (LocaleCompare(\"flip\",option+1) == 0)\n        {\n          new_image=FlipImage(_image,_exception);\n          break;\n        }\n      if (LocaleCompare(\"flop\",option+1) == 0)\n        {\n          new_image=FlopImage(_image,_exception);\n          break;\n        }\n      if (LocaleCompare(\"floodfill\",option+1) == 0)\n        {\n          PixelInfo\n            target;\n\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) ParsePageGeometry(_image,arg1,&geometry,_exception);\n          (void) QueryColorCompliance(arg2,AllCompliance,&target,_exception);\n          (void) FloodfillPaintImage(_image,_draw_info,&target,geometry.x,\n            geometry.y,IsPlusOp,_exception);\n          break;\n        }\n      if (LocaleCompare(\"frame\",option+1) == 0)\n        {\n          FrameInfo\n            frame_info;\n\n          CompositeOperator\n            compose;\n\n          const char*\n            value;\n\n          value=GetImageOption(_image_info,\"compose\");\n            compose=OverCompositeOp;  /* use Over not _image->compose */\n          if (value != (const char *) NULL)\n            compose=(CompositeOperator) ParseCommandOption(MagickComposeOptions,\n              MagickFalse,value);\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          flags=ParsePageGeometry(_image,arg1,&geometry,_exception);\n          frame_info.width=geometry.width;\n          frame_info.height=geometry.height;\n          frame_info.outer_bevel=geometry.x;\n          frame_info.inner_bevel=geometry.y;\n          frame_info.x=(ssize_t) frame_info.width;\n          frame_info.y=(ssize_t) frame_info.height;\n          frame_info.width=_image->columns+2*frame_info.width;\n          frame_info.height=_image->rows+2*frame_info.height;\n          new_image=FrameImage(_image,&frame_info,compose,_exception);\n          break;\n        }\n      if (LocaleCompare(\"function\",option+1) == 0)\n        {\n          double\n            *args;\n\n          ssize_t\n            count;\n\n          parse=ParseCommandOption(MagickFunctionOptions,MagickFalse,arg1);\n          if ( parse < 0 )\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedFunction\",\n                 option,arg1);\n          /* convert argument string into an array of doubles */\n          args = StringToArrayOfDoubles(arg2,&count,_exception);\n          if (args == (double *) NULL )\n            CLIWandExceptArgBreak(OptionError,\"InvalidNumberList\",option,arg2);\n\n          (void) FunctionImage(_image,(MagickFunction)parse,(size_t) count,args,\n               _exception);\n          args=(double *) RelinquishMagickMemory(args);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'g':\n    {\n      if (LocaleCompare(\"gamma\",option+1) == 0)\n        {\n          double\n            constant;\n\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          constant=StringToDouble(arg1,(char **) NULL);\n#if 0\n          /* Using Gamma, via a cache */\n          if (IfPlusOp)\n            constant=PerceptibleReciprocal(constant);\n          (void) GammaImage(_image,constant,_exception);\n#else\n          /* Using Evaluate POW, direct update of values - more accurite */\n          if (IfNormalOp)\n            constant=PerceptibleReciprocal(constant);\n          (void) EvaluateImage(_image,PowEvaluateOperator,constant,_exception);\n          _image->gamma*=StringToDouble(arg1,(char **) NULL);\n#endif\n          /* Set gamma setting -- Old meaning of \"+gamma\"\n           * _image->gamma=StringToDouble(arg1,(char **) NULL);\n           */\n          break;\n        }\n      if (LocaleCompare(\"gaussian-blur\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=1.0;\n          new_image=GaussianBlurImage(_image,geometry_info.rho,\n            geometry_info.sigma,_exception);\n          break;\n        }\n      if (LocaleCompare(\"gaussian\",option+1) == 0)\n        {\n          CLIWandWarnReplaced(\"-gaussian-blur\");\n          (void) CLISimpleOperatorImage(cli_wand,\"-gaussian-blur\",arg1,NULL,exception);\n        }\n      if (LocaleCompare(\"geometry\",option+1) == 0)\n        {\n          /*\n            Record Image offset for composition. (A Setting)\n            Resize last _image. (ListOperator)  -- DEPRECIATE\n            FUTURE: Why if no 'offset' does this resize ALL images?\n            Also why is the setting recorded in the IMAGE non-sense!\n          */\n          if (IfPlusOp)\n            { /* remove the previous composition geometry offset! */\n              if (_image->geometry != (char *) NULL)\n                _image->geometry=DestroyString(_image->geometry);\n              break;\n            }\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          flags=ParseRegionGeometry(_image,arg1,&geometry,_exception);\n          if (((flags & XValue) != 0) || ((flags & YValue) != 0))\n            (void) CloneString(&_image->geometry,arg1);\n          else\n            new_image=ResizeImage(_image,geometry.width,geometry.height,\n              _image->filter,_exception);\n          break;\n        }\n      if (LocaleCompare(\"grayscale\",option+1) == 0)\n        {\n          parse=ParseCommandOption(MagickPixelIntensityOptions,\n            MagickFalse,arg1);\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedIntensityMethod\",\n              option,arg1);\n          (void) GrayscaleImage(_image,(PixelIntensityMethod) parse,_exception);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'h':\n    {\n      if (LocaleCompare(\"hough-lines\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=geometry_info.rho;\n          if ((flags & XiValue) == 0)\n            geometry_info.xi=40;\n          new_image=HoughLineImage(_image,(size_t) geometry_info.rho,\n            (size_t) geometry_info.sigma,(size_t) geometry_info.xi,_exception);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'i':\n    {\n      if (LocaleCompare(\"identify\",option+1) == 0)\n        {\n          const char\n            *format,\n            *text;\n\n          format=GetImageOption(_image_info,\"format\");\n          if (format == (char *) NULL)\n            {\n              (void) IdentifyImage(_image,stdout,_image_info->verbose,\n                _exception);\n              break;\n            }\n          text=InterpretImageProperties(_image_info,_image,format,_exception);\n          if (text == (char *) NULL)\n            CLIWandExceptionBreak(OptionWarning,\"InterpretPropertyFailure\",\n              option);\n          (void) fputs(text,stdout);\n          text=DestroyString((char *)text);\n          break;\n        }\n      if (LocaleCompare(\"implode\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & RhoValue) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          new_image=ImplodeImage(_image,geometry_info.rho,_image->interpolate,\n               _exception);\n          break;\n        }\n      if (LocaleCompare(\"interpolative-resize\",option+1) == 0)\n        {\n          /* FUTURE: New to IMv7\n               Roll into a resize special operator */\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) ParseRegionGeometry(_image,arg1,&geometry,_exception);\n          new_image=InterpolativeResizeImage(_image,geometry.width,\n               geometry.height,_image->interpolate,_exception);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'k':\n    {\n      if (LocaleCompare(\"kuwahara\",option+1) == 0)\n        {\n          /*\n            Edge preserving blur.\n          */\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=geometry_info.rho-0.5;\n          new_image=KuwaharaImage(_image,geometry_info.rho,geometry_info.sigma,\n           _exception);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'l':\n    {\n      if (LocaleCompare(\"lat\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=1.0;\n          if ((flags & PercentValue) != 0)\n            geometry_info.xi=(double) QuantumRange*geometry_info.xi/100.0;\n          new_image=AdaptiveThresholdImage(_image,(size_t) geometry_info.rho,\n               (size_t) geometry_info.sigma,(double) geometry_info.xi,\n               _exception);\n          break;\n        }\n      if (LocaleCompare(\"level\",option+1) == 0)\n        {\n          double\n            black_point,\n            gamma,\n            white_point;\n\n          MagickStatusType\n            flags;\n\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & RhoValue) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          black_point=geometry_info.rho;\n          white_point=(double) QuantumRange;\n          if ((flags & SigmaValue) != 0)\n            white_point=geometry_info.sigma;\n          gamma=1.0;\n          if ((flags & XiValue) != 0)\n            gamma=geometry_info.xi;\n          if ((flags & PercentValue) != 0)\n            {\n              black_point*=(double) (QuantumRange/100.0);\n              white_point*=(double) (QuantumRange/100.0);\n            }\n          if ((flags & SigmaValue) == 0)\n            white_point=(double) QuantumRange-black_point;\n          if (IfPlusOp || ((flags & AspectValue) != 0))\n            (void) LevelizeImage(_image,black_point,white_point,gamma,_exception);\n          else\n            (void) LevelImage(_image,black_point,white_point,gamma,_exception);\n          break;\n        }\n      if (LocaleCompare(\"level-colors\",option+1) == 0)\n        {\n          char\n            token[MagickPathExtent];\n\n          const char\n            *p;\n\n          PixelInfo\n            black_point,\n            white_point;\n\n          p=(const char *) arg1;\n          GetNextToken(p,&p,MagickPathExtent,token);  /* get black point color */\n          if ((isalpha((int) *token) != 0) || ((*token == '#') != 0))\n            (void) QueryColorCompliance(token,AllCompliance,\n                      &black_point,_exception);\n          else\n            (void) QueryColorCompliance(\"#000000\",AllCompliance,\n                      &black_point,_exception);\n          if (isalpha((int) token[0]) || (token[0] == '#'))\n            GetNextToken(p,&p,MagickPathExtent,token);\n          if (*token == '\\0')\n            white_point=black_point; /* set everything to that color */\n          else\n            {\n              if ((isalpha((int) *token) == 0) && ((*token == '#') == 0))\n                GetNextToken(p,&p,MagickPathExtent,token); /* Get white point color. */\n              if ((isalpha((int) *token) != 0) || ((*token == '#') != 0))\n                (void) QueryColorCompliance(token,AllCompliance,\n                           &white_point,_exception);\n              else\n                (void) QueryColorCompliance(\"#ffffff\",AllCompliance,\n                           &white_point,_exception);\n            }\n          (void) LevelImageColors(_image,&black_point,&white_point,\n                     IsPlusOp,_exception);\n          break;\n        }\n      if (LocaleCompare(\"linear-stretch\",option+1) == 0)\n        {\n          double\n            black_point,\n            white_point;\n\n          MagickStatusType\n            flags;\n\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & RhoValue) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          black_point=geometry_info.rho;\n          white_point=(double) _image->columns*_image->rows;\n          if ((flags & SigmaValue) != 0)\n            white_point=geometry_info.sigma;\n          if ((flags & PercentValue) != 0)\n            {\n              black_point*=(double) _image->columns*_image->rows/100.0;\n              white_point*=(double) _image->columns*_image->rows/100.0;\n            }\n          if ((flags & SigmaValue) == 0)\n            white_point=(double) _image->columns*_image->rows-\n              black_point;\n          (void) LinearStretchImage(_image,black_point,white_point,_exception);\n          break;\n        }\n      if (LocaleCompare(\"liquid-rescale\",option+1) == 0)\n        {\n          /* FUTURE: Roll into a resize special operator */\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          flags=ParseRegionGeometry(_image,arg1,&geometry,_exception);\n          if ((flags & XValue) == 0)\n            geometry.x=1;\n          if ((flags & YValue) == 0)\n            geometry.y=0;\n          new_image=LiquidRescaleImage(_image,geometry.width,\n            geometry.height,1.0*geometry.x,1.0*geometry.y,_exception);\n          break;\n        }\n      if (LocaleCompare(\"local-contrast\",option+1) == 0)\n        {\n          MagickStatusType\n            flags;\n\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & RhoValue) == 0)\n            geometry_info.rho=10;\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=12.5;\n          new_image=LocalContrastImage(_image,geometry_info.rho,\n            geometry_info.sigma,exception);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'm':\n    {\n      if (LocaleCompare(\"magnify\",option+1) == 0)\n        {\n          new_image=MagnifyImage(_image,_exception);\n          break;\n        }\n      if (LocaleCompare(\"map\",option+1) == 0)\n        {\n          CLIWandWarnReplaced(\"-remap\");\n          (void) CLISimpleOperatorImage(cli_wand,\"-remap\",NULL,NULL,exception);\n          break;\n        }\n      if (LocaleCompare(\"mask\",option+1) == 0)\n        {\n          Image\n            *mask;\n\n          if (IfPlusOp)\n            {\n              /*\n                Remove a mask.\n              */\n              (void) SetImageMask(_image,WritePixelMask,(Image *) NULL,\n                _exception);\n              break;\n            }\n          /*\n            Set the image mask.\n          */\n          mask=GetImageCache(_image_info,arg1,_exception);\n          if (mask == (Image *) NULL)\n            break;\n          (void) SetImageMask(_image,WritePixelMask,mask,_exception);\n          mask=DestroyImage(mask);\n          break;\n        }\n      if (LocaleCompare(\"matte\",option+1) == 0)\n        {\n          CLIWandWarnReplaced(IfNormalOp?\"-alpha Set\":\"-alpha Off\");\n          (void) SetImageAlphaChannel(_image,IfNormalOp ? SetAlphaChannel :\n            DeactivateAlphaChannel, _exception);\n          break;\n        }\n      if (LocaleCompare(\"mean-shift\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=1.0;\n          if ((flags & XiValue) == 0)\n            geometry_info.xi=0.10*QuantumRange;\n          if ((flags & PercentValue) != 0)\n            geometry_info.xi=(double) QuantumRange*geometry_info.xi/100.0;\n          new_image=MeanShiftImage(_image,(size_t) geometry_info.rho,\n            (size_t) geometry_info.sigma,geometry_info.xi,_exception);\n          break;\n        }\n      if (LocaleCompare(\"median\",option+1) == 0)\n        {\n          CLIWandWarnReplaced(\"-statistic Median\");\n          (void) CLISimpleOperatorImage(cli_wand,\"-statistic\",\"Median\",arg1,exception);\n          break;\n        }\n      if (LocaleCompare(\"mode\",option+1) == 0)\n        {\n          /* FUTURE: note this is also a special \"montage\" option */\n          CLIWandWarnReplaced(\"-statistic Mode\");\n          (void) CLISimpleOperatorImage(cli_wand,\"-statistic\",\"Mode\",arg1,exception);\n          break;\n        }\n      if (LocaleCompare(\"modulate\",option+1) == 0)\n        {\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) ModulateImage(_image,arg1,_exception);\n          break;\n        }\n      if (LocaleCompare(\"monitor\",option+1) == 0)\n        {\n          (void) SetImageProgressMonitor(_image, IfNormalOp ? MonitorProgress :\n                (MagickProgressMonitor) NULL,(void *) NULL);\n          break;\n        }\n      if (LocaleCompare(\"monochrome\",option+1) == 0)\n        {\n          (void) SetImageType(_image,BilevelType,_exception);\n          break;\n        }\n      if (LocaleCompare(\"morphology\",option+1) == 0)\n        {\n          char\n            token[MagickPathExtent];\n\n          const char\n            *p;\n\n          KernelInfo\n            *kernel;\n\n          ssize_t\n            iterations;\n\n          p=arg1;\n          GetNextToken(p,&p,MagickPathExtent,token);\n          parse=ParseCommandOption(MagickMorphologyOptions,MagickFalse,token);\n          if ( parse < 0 )\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedFunction\",option,\n              arg1);\n          iterations=1L;\n          GetNextToken(p,&p,MagickPathExtent,token);\n          if ((*p == ':') || (*p == ','))\n            GetNextToken(p,&p,MagickPathExtent,token);\n          if ((*p != '\\0'))\n            iterations=(ssize_t) StringToLong(p);\n          kernel=AcquireKernelInfo(arg2,exception);\n          if (kernel == (KernelInfo *) NULL)\n            CLIWandExceptArgBreak(OptionError,\"UnabletoParseKernel\",option,arg2);\n          new_image=MorphologyImage(_image,(MorphologyMethod)parse,iterations,\n            kernel,_exception);\n          kernel=DestroyKernelInfo(kernel);\n          break;\n        }\n      if (LocaleCompare(\"motion-blur\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=1.0;\n          new_image=MotionBlurImage(_image,geometry_info.rho,geometry_info.sigma,\n            geometry_info.xi,_exception);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'n':\n    {\n      if (LocaleCompare(\"negate\",option+1) == 0)\n        {\n          (void) NegateImage(_image, IsPlusOp, _exception);\n          break;\n        }\n      if (LocaleCompare(\"noise\",option+1) == 0)\n        {\n          double\n            attenuate;\n\n          const char*\n            value;\n\n          if (IfNormalOp)\n            {\n              CLIWandWarnReplaced(\"-statistic NonPeak\");\n              (void) CLISimpleOperatorImage(cli_wand,\"-statistic\",\"NonPeak\",arg1,exception);\n              break;\n            }\n          parse=ParseCommandOption(MagickNoiseOptions,MagickFalse,arg1);\n          if ( parse < 0 )\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedNoiseType\",\n                option,arg1);\n          attenuate=1.0;\n          value=GetImageOption(_image_info,\"attenuate\");\n          if  (value != (const char *) NULL)\n            attenuate=StringToDouble(value,(char **) NULL);\n          new_image=AddNoiseImage(_image,(NoiseType)parse,attenuate,\n               _exception);\n          break;\n        }\n      if (LocaleCompare(\"normalize\",option+1) == 0)\n        {\n          (void) NormalizeImage(_image,_exception);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'o':\n    {\n      if (LocaleCompare(\"opaque\",option+1) == 0)\n        {\n          PixelInfo\n            target;\n\n          (void) QueryColorCompliance(arg1,AllCompliance,&target,_exception);\n          (void) OpaquePaintImage(_image,&target,&_draw_info->fill,IsPlusOp,\n               _exception);\n          break;\n        }\n      if (LocaleCompare(\"ordered-dither\",option+1) == 0)\n        {\n          (void) OrderedDitherImage(_image,arg1,_exception);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'p':\n    {\n      if (LocaleCompare(\"paint\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          new_image=OilPaintImage(_image,geometry_info.rho,geometry_info.sigma,\n               _exception);\n          break;\n        }\n      if (LocaleCompare(\"perceptible\",option+1) == 0)\n        {\n          (void) PerceptibleImage(_image,StringToDouble(arg1,(char **) NULL),\n            _exception);\n          break;\n        }\n      if (LocaleCompare(\"polaroid\",option+1) == 0)\n        {\n          const char\n            *caption;\n\n          double\n            angle;\n\n          if (IfPlusOp) {\n            RandomInfo\n              *random_info;\n\n            random_info=AcquireRandomInfo();\n            angle=22.5*(GetPseudoRandomValue(random_info)-0.5);\n            random_info=DestroyRandomInfo(random_info);\n          }\n          else {\n            flags=ParseGeometry(arg1,&geometry_info);\n            if ((flags & RhoValue) == 0)\n              CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n            angle=geometry_info.rho;\n          }\n          caption=GetImageProperty(_image,\"caption\",_exception);\n          new_image=PolaroidImage(_image,_draw_info,caption,angle,\n            _image->interpolate,_exception);\n          break;\n        }\n      if (LocaleCompare(\"posterize\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & RhoValue) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) PosterizeImage(_image,(size_t) geometry_info.rho,\n            _quantize_info->dither_method,_exception);\n          break;\n        }\n      if (LocaleCompare(\"preview\",option+1) == 0)\n        {\n          /* FUTURE: should be a 'Genesis' option?\n             Option however is also in WandSettingOptionInfo()\n             Why???\n          */\n          parse=ParseCommandOption(MagickPreviewOptions, MagickFalse,arg1);\n          if ( parse < 0 )\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedPreviewType\",\n                option,arg1);\n          new_image=PreviewImage(_image,(PreviewType)parse,_exception);\n          break;\n        }\n      if (LocaleCompare(\"profile\",option+1) == 0)\n        {\n          const char\n            *name;\n\n          const StringInfo\n            *profile;\n\n          Image\n            *profile_image;\n\n          ImageInfo\n            *profile_info;\n\n          /* Note: arguments do not have percent escapes expanded */\n          if (IfPlusOp)\n            { /* Remove a profile from the _image.  */\n              (void) ProfileImage(_image,arg1,(const unsigned char *)\n                NULL,0,_exception);\n              break;\n            }\n          /* Associate a profile with the _image.  */\n          profile_info=CloneImageInfo(_image_info);\n          profile=GetImageProfile(_image,\"iptc\");\n          if (profile != (StringInfo *) NULL)\n            profile_info->profile=(void *) CloneStringInfo(profile);\n          profile_image=GetImageCache(profile_info,arg1,_exception);\n          profile_info=DestroyImageInfo(profile_info);\n          if (profile_image == (Image *) NULL)\n            {\n              StringInfo\n                *profile;\n\n              profile_info=CloneImageInfo(_image_info);\n              (void) CopyMagickString(profile_info->filename,arg1,\n                MagickPathExtent);\n              profile=FileToStringInfo(profile_info->filename,~0UL,_exception);\n              if (profile != (StringInfo *) NULL)\n                {\n                  (void) SetImageInfo(profile_info,0,_exception);\n                  (void) ProfileImage(_image,profile_info->magick,\n                    GetStringInfoDatum(profile),(size_t)\n                    GetStringInfoLength(profile),_exception);\n                  profile=DestroyStringInfo(profile);\n                }\n              profile_info=DestroyImageInfo(profile_info);\n              break;\n            }\n          ResetImageProfileIterator(profile_image);\n          name=GetNextImageProfile(profile_image);\n          while (name != (const char *) NULL)\n          {\n            profile=GetImageProfile(profile_image,name);\n            if (profile != (StringInfo *) NULL)\n              (void) ProfileImage(_image,name,GetStringInfoDatum(profile),\n                (size_t) GetStringInfoLength(profile),_exception);\n            name=GetNextImageProfile(profile_image);\n          }\n          profile_image=DestroyImage(profile_image);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'r':\n    {\n      if (LocaleCompare(\"raise\",option+1) == 0)\n        {\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          flags=ParsePageGeometry(_image,arg1,&geometry,_exception);\n          (void) RaiseImage(_image,&geometry,IsNormalOp,_exception);\n          break;\n        }\n      if (LocaleCompare(\"random-threshold\",option+1) == 0)\n        {\n          double\n            min_threshold,\n            max_threshold;\n\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          min_threshold=0.0;\n          max_threshold=(double) QuantumRange;\n          flags=ParseGeometry(arg1,&geometry_info);\n          min_threshold=geometry_info.rho;\n          max_threshold=geometry_info.sigma;\n          if ((flags & SigmaValue) == 0)\n            max_threshold=min_threshold;\n          if (strchr(arg1,'%') != (char *) NULL)\n            {\n              max_threshold*=(double) (0.01*QuantumRange);\n              min_threshold*=(double) (0.01*QuantumRange);\n            }\n          (void) RandomThresholdImage(_image,min_threshold,max_threshold,\n            _exception);\n          break;\n        }\n      if (LocaleCompare(\"range-threshold\",option+1) == 0)\n        {\n          /*\n            Range threshold image.\n          */\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=geometry_info.rho;\n          if ((flags & XiValue) == 0)\n            geometry_info.xi=geometry_info.sigma;\n          if ((flags & PsiValue) == 0)\n            geometry_info.psi=geometry_info.xi;\n          if (strchr(arg1,'%') != (char *) NULL)\n            {\n              geometry_info.rho*=(double) (0.01*QuantumRange);\n              geometry_info.sigma*=(double) (0.01*QuantumRange);\n              geometry_info.xi*=(double) (0.01*QuantumRange);\n              geometry_info.psi*=(double) (0.01*QuantumRange);\n            }\n          (void) RangeThresholdImage(_image,geometry_info.rho,\n            geometry_info.sigma,geometry_info.xi,geometry_info.psi,exception);\n          break;\n        }\n      if (LocaleCompare(\"read-mask\",option+1) == 0)\n        {\n          /* Note: arguments do not have percent escapes expanded */\n          Image\n            *mask;\n\n          if (IfPlusOp)\n            { /* Remove a mask. */\n              (void) SetImageMask(_image,ReadPixelMask,(Image *) NULL,\n                _exception);\n              break;\n            }\n          /* Set the image mask. */\n          mask=GetImageCache(_image_info,arg1,_exception);\n          if (mask == (Image *) NULL)\n            break;\n          (void) SetImageMask(_image,ReadPixelMask,mask,_exception);\n          mask=DestroyImage(mask);\n          break;\n        }\n      if (LocaleCompare(\"recolor\",option+1) == 0)\n        {\n          CLIWandWarnReplaced(\"-color-matrix\");\n          (void) CLISimpleOperatorImage(cli_wand,\"-color-matrix\",arg1,NULL,\n            exception);\n        }\n      if (LocaleCompare(\"region\",option+1) == 0)\n        {\n          if (*option == '+')\n            {\n              (void) SetImageRegionMask(_image,WritePixelMask,\n                (const RectangleInfo *) NULL,_exception);\n              break;\n            }\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) ParseGravityGeometry(_image,arg1,&geometry,_exception);\n          (void) SetImageRegionMask(_image,WritePixelMask,&geometry,_exception);\n          break;\n        }\n      if (LocaleCompare(\"remap\",option+1) == 0)\n        {\n          /* Note: arguments do not have percent escapes expanded */\n          Image\n            *remap_image;\n\n          remap_image=GetImageCache(_image_info,arg1,_exception);\n          if (remap_image == (Image *) NULL)\n            break;\n          (void) RemapImage(_quantize_info,_image,remap_image,_exception);\n          remap_image=DestroyImage(remap_image);\n          break;\n        }\n      if (LocaleCompare(\"repage\",option+1) == 0)\n        {\n          if (IfNormalOp)\n            {\n              if (IsGeometry(arg1) == MagickFalse)\n                CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,\n                  arg1);\n              (void) ResetImagePage(_image,arg1);\n            }\n          else\n            (void) ParseAbsoluteGeometry(\"0x0+0+0\",&_image->page);\n          break;\n        }\n      if (LocaleCompare(\"resample\",option+1) == 0)\n        {\n          /* FUTURE: Roll into a resize special operation */\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=geometry_info.rho;\n          new_image=ResampleImage(_image,geometry_info.rho,\n            geometry_info.sigma,_image->filter,_exception);\n          break;\n        }\n      if (LocaleCompare(\"resize\",option+1) == 0)\n        {\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) ParseRegionGeometry(_image,arg1,&geometry,_exception);\n          new_image=ResizeImage(_image,geometry.width,geometry.height,\n            _image->filter,_exception);\n          break;\n        }\n      if (LocaleCompare(\"roll\",option+1) == 0)\n        {\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          flags=ParsePageGeometry(_image,arg1,&geometry,_exception);\n          if ((flags & PercentValue) != 0)\n            {\n              geometry.x*=(double) _image->columns/100.0;\n              geometry.y*=(double) _image->rows/100.0;\n            }\n          new_image=RollImage(_image,geometry.x,geometry.y,_exception);\n          break;\n        }\n      if (LocaleCompare(\"rotate\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & RhoValue) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & GreaterValue) != 0 && (_image->columns <= _image->rows))\n            break;\n          if ((flags & LessValue) != 0 && (_image->columns >= _image->rows))\n            break;\n          new_image=RotateImage(_image,geometry_info.rho,_exception);\n          break;\n        }\n      if (LocaleCompare(\"rotational-blur\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & RhoValue) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          new_image=RotationalBlurImage(_image,geometry_info.rho,_exception);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 's':\n    {\n      if (LocaleCompare(\"sample\",option+1) == 0)\n        {\n          /* FUTURE: Roll into a resize special operator */\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) ParseRegionGeometry(_image,arg1,&geometry,_exception);\n          new_image=SampleImage(_image,geometry.width,geometry.height,\n            _exception);\n          break;\n        }\n      if (LocaleCompare(\"scale\",option+1) == 0)\n        {\n          /* FUTURE: Roll into a resize special operator */\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) ParseRegionGeometry(_image,arg1,&geometry,_exception);\n          new_image=ScaleImage(_image,geometry.width,geometry.height,\n            _exception);\n          break;\n        }\n      if (LocaleCompare(\"segment\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=1.0;\n          (void) SegmentImage(_image,_image->colorspace,\n            _image_info->verbose,geometry_info.rho,geometry_info.sigma,\n            _exception);\n          break;\n        }\n      if (LocaleCompare(\"selective-blur\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=1.0;\n          if ((flags & PercentValue) != 0)\n            geometry_info.xi=(double) QuantumRange*geometry_info.xi/100.0;\n          new_image=SelectiveBlurImage(_image,geometry_info.rho,\n            geometry_info.sigma,geometry_info.xi,_exception);\n          break;\n        }\n      if (LocaleCompare(\"separate\",option+1) == 0)\n        {\n          /* WARNING: This can generate multiple images! */\n          /* FUTURE - this may be replaced by a \"-channel\" method */\n          new_image=SeparateImages(_image,_exception);\n          break;\n        }\n      if (LocaleCompare(\"sepia-tone\",option+1) == 0)\n        {\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          new_image=SepiaToneImage(_image,StringToDoubleInterval(arg1,\n                 (double) QuantumRange+1.0),_exception);\n          break;\n        }\n      if (LocaleCompare(\"shade\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if (((flags & RhoValue) == 0) || ((flags & SigmaValue) == 0))\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          new_image=ShadeImage(_image,IsNormalOp,geometry_info.rho,\n               geometry_info.sigma,_exception);\n          break;\n        }\n      if (LocaleCompare(\"shadow\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=1.0;\n          if ((flags & XiValue) == 0)\n            geometry_info.xi=4.0;\n          if ((flags & PsiValue) == 0)\n            geometry_info.psi=4.0;\n          new_image=ShadowImage(_image,geometry_info.rho,geometry_info.sigma,\n            (ssize_t) ceil(geometry_info.xi-0.5),(ssize_t)\n            ceil(geometry_info.psi-0.5),_exception);\n          break;\n        }\n      if (LocaleCompare(\"sharpen\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=1.0;\n          if ((flags & XiValue) == 0)\n            geometry_info.xi=0.0;\n          new_image=SharpenImage(_image,geometry_info.rho,geometry_info.sigma,\n           _exception);\n          break;\n        }\n      if (LocaleCompare(\"shave\",option+1) == 0)\n        {\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          flags=ParsePageGeometry(_image,arg1,&geometry,_exception);\n          new_image=ShaveImage(_image,&geometry,_exception);\n          break;\n        }\n      if (LocaleCompare(\"shear\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & RhoValue) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=geometry_info.rho;\n          new_image=ShearImage(_image,geometry_info.rho,geometry_info.sigma,\n            _exception);\n          break;\n        }\n      if (LocaleCompare(\"sigmoidal-contrast\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & RhoValue) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=(double) QuantumRange/2.0;\n          if ((flags & PercentValue) != 0)\n            geometry_info.sigma=(double) QuantumRange*geometry_info.sigma/\n              100.0;\n          (void) SigmoidalContrastImage(_image,IsNormalOp,geometry_info.rho,\n               geometry_info.sigma,_exception);\n          break;\n        }\n      if (LocaleCompare(\"sketch\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=1.0;\n          new_image=SketchImage(_image,geometry_info.rho,\n            geometry_info.sigma,geometry_info.xi,_exception);\n          break;\n        }\n      if (LocaleCompare(\"solarize\",option+1) == 0)\n        {\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) SolarizeImage(_image,StringToDoubleInterval(arg1,(double)\n                 QuantumRange+1.0),_exception);\n          break;\n        }\n      if (LocaleCompare(\"sparse-color\",option+1) == 0)\n        {\n          parse= ParseCommandOption(MagickSparseColorOptions,MagickFalse,arg1);\n          if ( parse < 0 )\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedSparseColorMethod\",\n                option,arg1);\n          new_image=SparseColorOption(_image,(SparseColorMethod)parse,arg2,\n               _exception);\n          break;\n        }\n      if (LocaleCompare(\"splice\",option+1) == 0)\n        {\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          flags=ParseGravityGeometry(_image,arg1,&geometry,_exception);\n          new_image=SpliceImage(_image,&geometry,_exception);\n          break;\n        }\n      if (LocaleCompare(\"spread\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & RhoValue) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg2);\n          new_image=SpreadImage(_image,_image->interpolate,geometry_info.rho,\n           _exception);\n          break;\n        }\n      if (LocaleCompare(\"statistic\",option+1) == 0)\n        {\n          parse=ParseCommandOption(MagickStatisticOptions,MagickFalse,arg1);\n          if ( parse < 0 )\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedStatisticType\",\n                 option,arg1);\n          flags=ParseGeometry(arg2,&geometry_info);\n          if ((flags & RhoValue) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg2);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=geometry_info.rho;\n          new_image=StatisticImage(_image,(StatisticType)parse,\n               (size_t) geometry_info.rho,(size_t) geometry_info.sigma,\n               _exception);\n          break;\n        }\n      if (LocaleCompare(\"strip\",option+1) == 0)\n        {\n          (void) StripImage(_image,_exception);\n          break;\n        }\n      if (LocaleCompare(\"swirl\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & RhoValue) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          new_image=SwirlImage(_image,geometry_info.rho,\n            _image->interpolate,_exception);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 't':\n    {\n      if (LocaleCompare(\"threshold\",option+1) == 0)\n        {\n          double\n            threshold;\n\n          threshold=(double) QuantumRange/2;\n          if (IfNormalOp) {\n            if (IsGeometry(arg1) == MagickFalse)\n              CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n            threshold=StringToDoubleInterval(arg1,(double) QuantumRange+1.0);\n          }\n          (void) BilevelImage(_image,threshold,_exception);\n          break;\n        }\n      if (LocaleCompare(\"thumbnail\",option+1) == 0)\n        {\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) ParseRegionGeometry(_image,arg1,&geometry,_exception);\n          new_image=ThumbnailImage(_image,geometry.width,geometry.height,\n            _exception);\n          break;\n        }\n      if (LocaleCompare(\"tint\",option+1) == 0)\n        {\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          new_image=TintImage(_image,arg1,&_draw_info->fill,_exception);\n          break;\n        }\n      if (LocaleCompare(\"transform\",option+1) == 0)\n        {\n          CLIWandWarnReplaced(\"+distort AffineProjection\");\n          new_image=AffineTransformImage(_image,&_draw_info->affine,_exception);\n          break;\n        }\n      if (LocaleCompare(\"transparent\",option+1) == 0)\n        {\n          PixelInfo\n            target;\n\n          (void) QueryColorCompliance(arg1,AllCompliance,&target,_exception);\n          (void) TransparentPaintImage(_image,&target,(Quantum)\n            TransparentAlpha,IsPlusOp,_exception);\n          break;\n        }\n      if (LocaleCompare(\"transpose\",option+1) == 0)\n        {\n          new_image=TransposeImage(_image,_exception);\n          break;\n        }\n      if (LocaleCompare(\"transverse\",option+1) == 0)\n        {\n          new_image=TransverseImage(_image,_exception);\n          break;\n        }\n      if (LocaleCompare(\"trim\",option+1) == 0)\n        {\n          new_image=TrimImage(_image,_exception);\n          break;\n        }\n      if (LocaleCompare(\"type\",option+1) == 0)\n        {\n          /* Note that \"type\" setting should have already been defined */\n          (void) SetImageType(_image,_image_info->type,_exception);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'u':\n    {\n      if (LocaleCompare(\"unique\",option+1) == 0)\n        {\n          /* FUTURE: move to SyncImageSettings() and AcqireImage()???\n             Option is not documented, bt appears to be for \"identify\".\n             We may need a identify specific verbose!\n          */\n          if (IsPlusOp) {\n              (void) DeleteImageArtifact(_image,\"identify:unique-colors\");\n              break;\n            }\n          (void) SetImageArtifact(_image,\"identify:unique-colors\",\"true\");\n          (void) SetImageArtifact(_image,\"verbose\",\"true\");\n          break;\n        }\n      if (LocaleCompare(\"unique-colors\",option+1) == 0)\n        {\n          new_image=UniqueImageColors(_image,_exception);\n          break;\n        }\n      if (LocaleCompare(\"unsharp\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=1.0;\n          if ((flags & XiValue) == 0)\n            geometry_info.xi=1.0;\n          if ((flags & PsiValue) == 0)\n            geometry_info.psi=0.05;\n          new_image=UnsharpMaskImage(_image,geometry_info.rho,\n            geometry_info.sigma,geometry_info.xi,geometry_info.psi,_exception);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'v':\n    {\n      if (LocaleCompare(\"verbose\",option+1) == 0)\n        {\n          /* FUTURE: move to SyncImageSettings() and AcquireImage()???\n             three places!   ImageArtifact   ImageOption  _image_info->verbose\n             Some how new images also get this artifact!\n          */\n          (void) SetImageArtifact(_image,option+1,\n                           IfNormalOp ? \"true\" : \"false\" );\n          break;\n        }\n      if (LocaleCompare(\"vignette\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=1.0;\n          if ((flags & XiValue) == 0)\n            geometry_info.xi=0.1*_image->columns;\n          if ((flags & PsiValue) == 0)\n            geometry_info.psi=0.1*_image->rows;\n          if ((flags & PercentValue) != 0)\n            {\n              geometry_info.xi*=(double) _image->columns/100.0;\n              geometry_info.psi*=(double) _image->rows/100.0;\n            }\n          new_image=VignetteImage(_image,geometry_info.rho,geometry_info.sigma,\n            (ssize_t) ceil(geometry_info.xi-0.5),(ssize_t)\n            ceil(geometry_info.psi-0.5),_exception);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'w':\n    {\n      if (LocaleCompare(\"wave\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & (RhoValue|SigmaValue)) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=1.0;\n          new_image=WaveImage(_image,geometry_info.rho,geometry_info.sigma,\n            _image->interpolate,_exception);\n          break;\n        }\n      if (LocaleCompare(\"wavelet-denoise\",option+1) == 0)\n        {\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & RhoValue) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          if ((flags & PercentValue) != 0)\n            {\n              geometry_info.rho=QuantumRange*geometry_info.rho/100.0;\n              geometry_info.sigma=QuantumRange*geometry_info.sigma/100.0;\n            }\n          if ((flags & SigmaValue) == 0)\n            geometry_info.sigma=0.0;\n          new_image=WaveletDenoiseImage(_image,geometry_info.rho,\n            geometry_info.sigma,_exception);\n          break;\n        }\n      if (LocaleCompare(\"white-threshold\",option+1) == 0)\n        {\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          (void) WhiteThresholdImage(_image,arg1,_exception);\n          break;\n        }\n      if (LocaleCompare(\"write-mask\",option+1) == 0)\n        {\n          /* Note: arguments do not have percent escapes expanded */\n          Image\n            *mask;\n\n          if (IfPlusOp)\n            { /* Remove a mask. */\n              (void) SetImageMask(_image,WritePixelMask,(Image *) NULL,\n                _exception);\n              break;\n            }\n          /* Set the image mask. */\n          mask=GetImageCache(_image_info,arg1,_exception);\n          if (mask == (Image *) NULL)\n            break;\n          (void) SetImageMask(_image,WritePixelMask,mask,_exception);\n          mask=DestroyImage(mask);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    default:\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n  }\n  /* clean up percent escape interpreted strings */\n  if (arg1 != arg1n )\n    arg1=DestroyString((char *)arg1);\n  if (arg2 != arg2n )\n    arg2=DestroyString((char *)arg2);\n\n  /* Replace current image with any image that was generated\n     and set image point to last image (so image->next is correct) */\n  if (new_image != (Image *) NULL)\n    ReplaceImageInListReturnLast(&_image,new_image);\n\n  return(MagickTrue);\n#undef _image_info\n#undef _draw_info\n#undef _quantize_info\n#undef _image\n#undef _exception\n#undef IfNormalOp\n#undef IfPlusOp\n#undef IsNormalOp\n#undef IsPlusOp\n}\n\nWandPrivate MagickBooleanType CLISimpleOperatorImages(MagickCLI *cli_wand,\n  const char *option,const char *arg1,const char *arg2,ExceptionInfo *exception)\n{\n#if !USE_WAND_METHODS\n  size_t\n    n,\n    i;\n#endif\n\n  assert(cli_wand != (MagickCLI *) NULL);\n  assert(cli_wand->signature == MagickWandSignature);\n  assert(cli_wand->wand.signature == MagickWandSignature);\n  assert(cli_wand->wand.images != (Image *) NULL); /* images must be present */\n\n  if (cli_wand->wand.debug != MagickFalse)\n    (void) CLILogEvent(cli_wand,CommandEvent,GetMagickModule(),\n         \"- Simple Operator: %s \\\"%s\\\" \\\"%s\\\"\", option,arg1,arg2);\n\n#if !USE_WAND_METHODS\n  /* FUTURE add appropriate tracing */\n  i=0;\n  n=GetImageListLength(cli_wand->wand.images);\n  cli_wand->wand.images=GetFirstImageInList(cli_wand->wand.images);\n  while (1) {\n    i++;\n    CLISimpleOperatorImage(cli_wand, option, arg1, arg2,exception);\n    if ( cli_wand->wand.images->next == (Image *) NULL )\n      break;\n    cli_wand->wand.images=cli_wand->wand.images->next;\n  }\n  assert( i == n );\n  cli_wand->wand.images=GetFirstImageInList(cli_wand->wand.images);\n#else\n  MagickResetIterator(&cli_wand->wand);\n  while (MagickNextImage(&cli_wand->wand) != MagickFalse)\n    (void) CLISimpleOperatorImage(cli_wand, option, arg1, arg2,exception);\n  MagickResetIterator(&cli_wand->wand);\n#endif\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+     C L I L i s t O p e r a t o r I m a g e s                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CLIListOperatorImages() applies a single operation that is apply to the\n%  entire image list as a whole. The result is often a complete replacment\n%  of the image list with a completely new list, or with just a single image\n%  result.\n%\n%  The format of the MogrifyImage method is:\n%\n%    MagickBooleanType CLIListOperatorImages(MagickCLI *cli_wand,\n%      const char *option,const char *arg1,const char *arg2)\n%\n%  A description of each parameter follows:\n%\n%    o cli_wand: structure holding settings to be applied\n%\n%    o option:  The option string for the operation\n%\n%    o arg1, arg2: optional argument strings to the operation\n%        arg2 is currently not used\n%\n*/\nWandPrivate MagickBooleanType CLIListOperatorImages(MagickCLI *cli_wand,\n  const char *option,const char *arg1n,const char *arg2n)\n{\n  const char    /* percent escaped versions of the args */\n    *arg1,\n    *arg2;\n\n  Image\n    *new_images;\n\n  MagickStatusType\n    status;\n\n  ssize_t\n    parse;\n\n#define _image_info     (cli_wand->wand.image_info)\n#define _images         (cli_wand->wand.images)\n#define _exception      (cli_wand->wand.exception)\n#define _draw_info      (cli_wand->draw_info)\n#define _quantize_info  (cli_wand->quantize_info)\n#define _process_flags  (cli_wand->process_flags)\n#define _option_type    ((CommandOptionFlags) cli_wand->command->flags)\n#define IfNormalOp      (*option=='-')\n#define IfPlusOp        (*option!='-')\n#define IsNormalOp      IfNormalOp ? MagickTrue : MagickFalse\n\n  assert(cli_wand != (MagickCLI *) NULL);\n  assert(cli_wand->signature == MagickWandSignature);\n  assert(cli_wand->wand.signature == MagickWandSignature);\n  assert(_images != (Image *) NULL);             /* _images must be present */\n\n  if (cli_wand->wand.debug != MagickFalse)\n    (void) CLILogEvent(cli_wand,CommandEvent,GetMagickModule(),\n       \"- List Operator: %s \\\"%s\\\" \\\"%s\\\"\", option,\n       arg1n == (const char *) NULL ? \"null\" : arg1n,\n       arg2n == (const char *) NULL ? \"null\" : arg2n);\n\n  arg1 = arg1n;\n  arg2 = arg2n;\n\n  /* Interpret Percent Escapes in Arguments - using first image */\n  if ( (((_process_flags & ProcessInterpretProperities) != 0 )\n        || ((_option_type & AlwaysInterpretArgsFlag) != 0)\n       )  && ((_option_type & NeverInterpretArgsFlag) == 0) ) {\n    /* Interpret Percent escapes in argument 1 */\n    if (arg1n != (char *) NULL) {\n      arg1=InterpretImageProperties(_image_info,_images,arg1n,_exception);\n      if (arg1 == (char *) NULL) {\n        CLIWandException(OptionWarning,\"InterpretPropertyFailure\",option);\n        arg1=arg1n;  /* use the given argument as is */\n      }\n    }\n    if (arg2n != (char *) NULL) {\n      arg2=InterpretImageProperties(_image_info,_images,arg2n,_exception);\n      if (arg2 == (char *) NULL) {\n        CLIWandException(OptionWarning,\"InterpretPropertyFailure\",option);\n        arg2=arg2n;  /* use the given argument as is */\n      }\n    }\n  }\n#undef _process_flags\n#undef _option_type\n\n  status=MagickTrue;\n  new_images=NewImageList();\n\n  switch (*(option+1))\n  {\n    case 'a':\n    {\n      if (LocaleCompare(\"append\",option+1) == 0)\n        {\n          new_images=AppendImages(_images,IsNormalOp,_exception);\n          break;\n        }\n      if (LocaleCompare(\"average\",option+1) == 0)\n        {\n          CLIWandWarnReplaced(\"-evaluate-sequence Mean\");\n          (void) CLIListOperatorImages(cli_wand,\"-evaluate-sequence\",\"Mean\",\n            NULL);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'c':\n    {\n      if (LocaleCompare(\"channel-fx\",option+1) == 0)\n        {\n          new_images=ChannelFxImage(_images,arg1,_exception);\n          break;\n        }\n      if (LocaleCompare(\"clut\",option+1) == 0)\n        {\n          Image\n            *clut_image;\n\n          /* FUTURE - make this a compose option, and thus can be used\n             with layers compose or even compose last image over all other\n             _images.\n          */\n          new_images=RemoveFirstImageFromList(&_images);\n          clut_image=RemoveLastImageFromList(&_images);\n          /* FUTURE - produce Exception, rather than silent fail */\n          if (clut_image == (Image *) NULL)\n            break;\n          (void) ClutImage(new_images,clut_image,new_images->interpolate,\n            _exception);\n          clut_image=DestroyImage(clut_image);\n          break;\n        }\n      if (LocaleCompare(\"coalesce\",option+1) == 0)\n        {\n          new_images=CoalesceImages(_images,_exception);\n          break;\n        }\n      if (LocaleCompare(\"combine\",option+1) == 0)\n        {\n          parse=(ssize_t) _images->colorspace;\n          if (_images->number_channels < GetImageListLength(_images))\n            parse=sRGBColorspace;\n          if ( IfPlusOp )\n            parse=ParseCommandOption(MagickColorspaceOptions,MagickFalse,arg1);\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedColorspace\",option,\n              arg1);\n          new_images=CombineImages(_images,(ColorspaceType) parse,_exception);\n          break;\n        }\n      if (LocaleCompare(\"compare\",option+1) == 0)\n        {\n          double\n            distortion;\n\n          Image\n            *image,\n            *reconstruct_image;\n\n          MetricType\n            metric;\n\n          /*\n            Mathematically and visually annotate the difference between an\n            image and its reconstruction.\n          */\n          image=RemoveFirstImageFromList(&_images);\n          reconstruct_image=RemoveFirstImageFromList(&_images);\n          /* FUTURE - produce Exception, rather than silent fail */\n          if (reconstruct_image == (Image *) NULL)\n            { \n              image=DestroyImage(image);\n              break;\n            }\n          metric=UndefinedErrorMetric;\n          option=GetImageOption(_image_info,\"metric\");\n          if (option != (const char *) NULL)\n            metric=(MetricType) ParseCommandOption(MagickMetricOptions,\n              MagickFalse,option);\n          new_images=CompareImages(image,reconstruct_image,metric,&distortion,\n            _exception);\n          (void) distortion;\n          reconstruct_image=DestroyImage(reconstruct_image);\n          image=DestroyImage(image);\n          break;\n        }\n      if (LocaleCompare(\"complex\",option+1) == 0)\n        {\n          parse=ParseCommandOption(MagickComplexOptions,MagickFalse,arg1);\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedEvaluateOperator\",\n              option,arg1);\n          new_images=ComplexImages(_images,(ComplexOperator) parse,_exception);\n          break;\n        }\n      if (LocaleCompare(\"composite\",option+1) == 0)\n        {\n          CompositeOperator\n            compose;\n\n          const char*\n            value;\n\n          MagickBooleanType\n            clip_to_self;\n\n          Image\n            *mask_image,\n            *source_image;\n\n          RectangleInfo\n            geometry;\n\n          /* Compose value from \"-compose\" option only */\n          value=GetImageOption(_image_info,\"compose\");\n          if (value == (const char *) NULL)\n            compose=OverCompositeOp;  /* use Over not source_image->compose */\n          else\n            compose=(CompositeOperator) ParseCommandOption(MagickComposeOptions,\n              MagickFalse,value);\n\n          /* Get \"clip-to-self\" expert setting (false is normal) */\n          clip_to_self=GetCompositeClipToSelf(compose);\n          value=GetImageOption(_image_info,\"compose:clip-to-self\");\n          if (value != (const char *) NULL)\n            clip_to_self=IsStringTrue(value);\n          value=GetImageOption(_image_info,\"compose:outside-overlay\");\n          if (value != (const char *) NULL)\n            clip_to_self=IsStringFalse(value);  /* deprecated */\n\n          new_images=RemoveFirstImageFromList(&_images);\n          source_image=RemoveFirstImageFromList(&_images);\n          if (source_image == (Image *) NULL)\n            break; /* FUTURE - produce Exception, rather than silent fail */\n\n          /* FUTURE - this should not be here! - should be part of -geometry */\n          if (source_image->geometry != (char *) NULL)\n            {\n              RectangleInfo\n                resize_geometry;\n\n              (void) ParseRegionGeometry(source_image,source_image->geometry,\n                &resize_geometry,_exception);\n              if ((source_image->columns != resize_geometry.width) ||\n                  (source_image->rows != resize_geometry.height))\n                {\n                  Image\n                    *resize_image;\n\n                  resize_image=ResizeImage(source_image,resize_geometry.width,\n                    resize_geometry.height,source_image->filter,_exception);\n                  if (resize_image != (Image *) NULL)\n                    {\n                      source_image=DestroyImage(source_image);\n                      source_image=resize_image;\n                    }\n                }\n            }\n          SetGeometry(source_image,&geometry);\n          (void) ParseAbsoluteGeometry(source_image->geometry,&geometry);\n          GravityAdjustGeometry(new_images->columns,new_images->rows,\n            new_images->gravity, &geometry);\n          mask_image=RemoveFirstImageFromList(&_images);\n          if (mask_image == (Image *) NULL)\n            status&=CompositeImage(new_images,source_image,compose,clip_to_self,\n              geometry.x,geometry.y,_exception);\n          else\n            {\n              if ((compose == DisplaceCompositeOp) ||\n                  (compose == DistortCompositeOp))\n                {\n                  status&=CompositeImage(source_image,mask_image,\n                    CopyGreenCompositeOp,MagickTrue,0,0,_exception);\n                  status&=CompositeImage(new_images,source_image,compose,\n                    clip_to_self,geometry.x,geometry.y,_exception);\n                }\n              else\n                {\n                  Image\n                    *clone_image;\n\n                  clone_image=CloneImage(new_images,0,0,MagickTrue,_exception);\n                  if (clone_image == (Image *) NULL)\n                    break;\n                  status&=CompositeImage(new_images,source_image,compose,\n                    clip_to_self,geometry.x,geometry.y,_exception);\n                  status&=CompositeImage(new_images,mask_image,\n                    CopyAlphaCompositeOp,MagickTrue,0,0,_exception);\n                  status&=CompositeImage(clone_image,new_images,OverCompositeOp,\n                    clip_to_self,0,0,_exception);\n                  new_images=DestroyImage(new_images);\n                  new_images=clone_image;\n                }\n              mask_image=DestroyImage(mask_image);\n            }\n          source_image=DestroyImage(source_image);\n          break;\n        }\n        if (LocaleCompare(\"copy\",option+1) == 0)\n          {\n            Image\n              *source_image;\n\n            OffsetInfo\n              offset;\n\n            RectangleInfo\n              geometry;\n\n            /*\n              Copy image pixels.\n            */\n            if (IsGeometry(arg1) == MagickFalse)\n              CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n            if (IsGeometry(arg2) == MagickFalse)\n              CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n            (void) ParsePageGeometry(_images,arg2,&geometry,_exception);\n            offset.x=geometry.x;\n            offset.y=geometry.y;\n            source_image=_images;\n            if (source_image->next != (Image *) NULL)\n              source_image=source_image->next;\n            (void) ParsePageGeometry(source_image,arg1,&geometry,_exception);\n            (void) CopyImagePixels(_images,source_image,&geometry,&offset,\n              _exception);\n            break;\n          }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'd':\n    {\n      if (LocaleCompare(\"deconstruct\",option+1) == 0)\n        {\n          CLIWandWarnReplaced(\"-layer CompareAny\");\n          (void) CLIListOperatorImages(cli_wand,\"-layer\",\"CompareAny\",NULL);\n          break;\n        }\n      if (LocaleCompare(\"delete\",option+1) == 0)\n        {\n          if (IfNormalOp)\n            DeleteImages(&_images,arg1,_exception);\n          else\n            DeleteImages(&_images,\"-1\",_exception);\n          break;\n        }\n      if (LocaleCompare(\"duplicate\",option+1) == 0)\n        {\n          if (IfNormalOp)\n            {\n              const char\n                *p;\n\n              size_t\n                number_duplicates;\n\n              if (IsGeometry(arg1) == MagickFalse)\n                CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,\n                      arg1);\n              number_duplicates=(size_t) StringToLong(arg1);\n              p=strchr(arg1,',');\n              if (p == (const char *) NULL)\n                new_images=DuplicateImages(_images,number_duplicates,\"-1\",\n                  _exception);\n              else\n                new_images=DuplicateImages(_images,number_duplicates,p,\n                  _exception);\n            }\n          else\n            new_images=DuplicateImages(_images,1,\"-1\",_exception);\n          AppendImageToList(&_images, new_images);\n          new_images=(Image *) NULL;\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'e':\n    {\n      if (LocaleCompare(\"evaluate-sequence\",option+1) == 0)\n        {\n          parse=ParseCommandOption(MagickEvaluateOptions,MagickFalse,arg1);\n          if (parse < 0)\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedEvaluateOperator\",\n              option,arg1);\n          new_images=EvaluateImages(_images,(MagickEvaluateOperator) parse,\n            _exception);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'f':\n    {\n      if (LocaleCompare(\"fft\",option+1) == 0)\n        {\n          new_images=ForwardFourierTransformImage(_images,IsNormalOp,\n           _exception);\n          break;\n        }\n      if (LocaleCompare(\"flatten\",option+1) == 0)\n        {\n          /* REDIRECTED to use -layers flatten instead */\n          (void) CLIListOperatorImages(cli_wand,\"-layers\",option+1,NULL);\n          break;\n        }\n      if (LocaleCompare(\"fx\",option+1) == 0)\n        {\n          new_images=FxImage(_images,arg1,_exception);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'h':\n    {\n      if (LocaleCompare(\"hald-clut\",option+1) == 0)\n        {\n          /* FUTURE - make this a compose option (and thus layers compose )\n             or perhaps compose last image over all other _images.\n          */\n          Image\n            *hald_image;\n\n          new_images=RemoveFirstImageFromList(&_images);\n          hald_image=RemoveLastImageFromList(&_images);\n          if (hald_image == (Image *) NULL)\n            break;\n          (void) HaldClutImage(new_images,hald_image,_exception);\n          hald_image=DestroyImage(hald_image);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'i':\n    {\n      if (LocaleCompare(\"ift\",option+1) == 0)\n        {\n          Image\n            *magnitude_image,\n            *phase_image;\n\n           magnitude_image=RemoveFirstImageFromList(&_images);\n           phase_image=RemoveFirstImageFromList(&_images);\n          /* FUTURE - produce Exception, rather than silent fail */\n           if (phase_image == (Image *) NULL)\n             break;\n           new_images=InverseFourierTransformImage(magnitude_image,phase_image,\n             IsNormalOp,_exception);\n           magnitude_image=DestroyImage(magnitude_image);\n           phase_image=DestroyImage(phase_image);\n          break;\n        }\n      if (LocaleCompare(\"insert\",option+1) == 0)\n        {\n          Image\n            *insert_image,\n            *index_image;\n\n          ssize_t\n            index;\n\n          if (IfNormalOp && (IsGeometry(arg1) == MagickFalse))\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          index=0;\n          insert_image=RemoveLastImageFromList(&_images);\n          if (IfNormalOp)\n            index=(ssize_t) StringToLong(arg1);\n          index_image=insert_image;\n          if (index == 0)\n            PrependImageToList(&_images,insert_image);\n          else if (index == (ssize_t) GetImageListLength(_images))\n            AppendImageToList(&_images,insert_image);\n          else\n            {\n               index_image=GetImageFromList(_images,index-1);\n               if (index_image == (Image *) NULL)\n                 CLIWandExceptArgBreak(OptionError,\"NoSuchImage\",option,arg1);\n              InsertImageInList(&index_image,insert_image);\n            }\n          _images=GetFirstImageInList(index_image);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'l':\n    {\n      if (LocaleCompare(\"layers\",option+1) == 0)\n        {\n          parse=ParseCommandOption(MagickLayerOptions,MagickFalse,arg1);\n          if ( parse < 0 )\n            CLIWandExceptArgBreak(OptionError,\"UnrecognizedLayerMethod\",\n                 option,arg1);\n          switch ((LayerMethod) parse)\n          {\n            case CoalesceLayer:\n            {\n              new_images=CoalesceImages(_images,_exception);\n              break;\n            }\n            case CompareAnyLayer:\n            case CompareClearLayer:\n            case CompareOverlayLayer:\n            default:\n            {\n              new_images=CompareImagesLayers(_images,(LayerMethod) parse,\n                   _exception);\n              break;\n            }\n            case MergeLayer:\n            case FlattenLayer:\n            case MosaicLayer:\n            case TrimBoundsLayer:\n            {\n              new_images=MergeImageLayers(_images,(LayerMethod) parse,\n                _exception);\n              break;\n            }\n            case DisposeLayer:\n            {\n              new_images=DisposeImages(_images,_exception);\n              break;\n            }\n            case OptimizeImageLayer:\n            {\n              new_images=OptimizeImageLayers(_images,_exception);\n              break;\n            }\n            case OptimizePlusLayer:\n            {\n              new_images=OptimizePlusImageLayers(_images,_exception);\n              break;\n            }\n            case OptimizeTransLayer:\n            {\n              OptimizeImageTransparency(_images,_exception);\n              break;\n            }\n            case RemoveDupsLayer:\n            {\n              RemoveDuplicateLayers(&_images,_exception);\n              break;\n            }\n            case RemoveZeroLayer:\n            {\n              RemoveZeroDelayLayers(&_images,_exception);\n              break;\n            }\n            case OptimizeLayer:\n            { /* General Purpose, GIF Animation Optimizer.  */\n              new_images=CoalesceImages(_images,_exception);\n              if (new_images == (Image *) NULL)\n                break;\n              _images=DestroyImageList(_images);\n              _images=OptimizeImageLayers(new_images,_exception);\n              if (_images == (Image *) NULL)\n                break;\n              new_images=DestroyImageList(new_images);\n              OptimizeImageTransparency(_images,_exception);\n              (void) RemapImages(_quantize_info,_images,(Image *) NULL,\n                _exception);\n              break;\n            }\n            case CompositeLayer:\n            {\n              Image\n                *source;\n\n              RectangleInfo\n                geometry;\n\n              CompositeOperator\n                compose;\n\n              const char*\n                value;\n\n              value=GetImageOption(_image_info,\"compose\");\n              compose=OverCompositeOp;  /* Default to Over */\n              if (value != (const char *) NULL)\n                compose=(CompositeOperator) ParseCommandOption(\n                      MagickComposeOptions,MagickFalse,value);\n\n              /* Split image sequence at the first 'NULL:' image. */\n              source=_images;\n              while (source != (Image *) NULL)\n              {\n                source=GetNextImageInList(source);\n                if ((source != (Image *) NULL) &&\n                    (LocaleCompare(source->magick,\"NULL\") == 0))\n                  break;\n              }\n              if (source != (Image *) NULL)\n                {\n                  if ((GetPreviousImageInList(source) == (Image *) NULL) ||\n                      (GetNextImageInList(source) == (Image *) NULL))\n                    source=(Image *) NULL;\n                  else\n                    { /* Separate the two lists, junk the null: image.  */\n                      source=SplitImageList(source->previous);\n                      DeleteImageFromList(&source);\n                    }\n                }\n              if (source == (Image *) NULL)\n                {\n                  (void) ThrowMagickException(_exception,GetMagickModule(),\n                    OptionError,\"MissingNullSeparator\",\"layers Composite\");\n                  break;\n                }\n              /* Adjust offset with gravity and virtual canvas.  */\n              SetGeometry(_images,&geometry);\n              (void) ParseAbsoluteGeometry(_images->geometry,&geometry);\n              geometry.width=source->page.width != 0 ?\n                source->page.width : source->columns;\n              geometry.height=source->page.height != 0 ?\n               source->page.height : source->rows;\n              GravityAdjustGeometry(_images->page.width != 0 ?\n                _images->page.width : _images->columns,\n                _images->page.height != 0 ? _images->page.height :\n                _images->rows,_images->gravity,&geometry);\n\n              /* Compose the two image sequences together */\n              CompositeLayers(_images,compose,source,geometry.x,geometry.y,\n                _exception);\n              source=DestroyImageList(source);\n              break;\n            }\n          }\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'm':\n    {\n      if (LocaleCompare(\"map\",option+1) == 0)\n        {\n          CLIWandWarnReplaced(\"+remap\");\n          (void) RemapImages(_quantize_info,_images,(Image *) NULL,_exception);\n          break;\n        }\n      if (LocaleCompare(\"metric\",option+1) == 0)\n        {\n          (void) SetImageOption(_image_info,option+1,arg1);\n          break;\n        }\n      if (LocaleCompare(\"morph\",option+1) == 0)\n        {\n          Image\n            *morph_image;\n\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          morph_image=MorphImages(_images,StringToUnsignedLong(arg1),\n            _exception);\n          if (morph_image == (Image *) NULL)\n            break;\n          _images=DestroyImageList(_images);\n          _images=morph_image;\n          break;\n        }\n      if (LocaleCompare(\"mosaic\",option+1) == 0)\n        {\n          /* REDIRECTED to use -layers mosaic instead */\n          (void) CLIListOperatorImages(cli_wand,\"-layers\",option+1,NULL);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'p':\n    {\n      if (LocaleCompare(\"poly\",option+1) == 0)\n        {\n          double\n            *args;\n\n          ssize_t\n            count;\n\n          /* convert argument string into an array of doubles */\n          args = StringToArrayOfDoubles(arg1,&count,_exception);\n          if (args == (double *) NULL )\n            CLIWandExceptArgBreak(OptionError,\"InvalidNumberList\",option,arg1);\n          new_images=PolynomialImage(_images,(size_t) (count >> 1),args,\n           _exception);\n          args=(double *) RelinquishMagickMemory(args);\n          break;\n        }\n      if (LocaleCompare(\"process\",option+1) == 0)\n        {\n          /* FUTURE: better parsing using ScriptToken() from string ??? */\n          char\n            **arguments;\n\n          int\n            j,\n            number_arguments;\n\n          arguments=StringToArgv(arg1,&number_arguments);\n          if (arguments == (char **) NULL)\n            break;\n          if (strchr(arguments[1],'=') != (char *) NULL)\n            {\n              char\n                breaker,\n                quote,\n                *token;\n\n              const char\n                *arguments;\n\n              int\n                next,\n                status;\n\n              size_t\n                length;\n\n              TokenInfo\n                *token_info;\n\n              /*\n                Support old style syntax, filter=\"-option arg1\".\n              */\n              assert(arg1 != (const char *) NULL);\n              length=strlen(arg1);\n              token=(char *) NULL;\n              if (~length >= (MagickPathExtent-1))\n                token=(char *) AcquireQuantumMemory(length+MagickPathExtent,\n                  sizeof(*token));\n              if (token == (char *) NULL)\n                break;\n              next=0;\n              arguments=arg1;\n              token_info=AcquireTokenInfo();\n              status=Tokenizer(token_info,0,token,length,arguments,\"\",\"=\",\n                \"\\\"\",'\\0',&breaker,&next,&quote);\n              token_info=DestroyTokenInfo(token_info);\n              if (status == 0)\n                {\n                  const char\n                    *argv;\n\n                  argv=(&(arguments[next]));\n                  (void) InvokeDynamicImageFilter(token,&_images,1,&argv,\n                    _exception);\n                }\n              token=DestroyString(token);\n              break;\n            }\n          (void) SubstituteString(&arguments[1],\"-\",\"\");\n          (void) InvokeDynamicImageFilter(arguments[1],&_images,\n            number_arguments-2,(const char **) arguments+2,_exception);\n          for (j=0; j < number_arguments; j++)\n            arguments[j]=DestroyString(arguments[j]);\n          arguments=(char **) RelinquishMagickMemory(arguments);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 'r':\n    {\n      if (LocaleCompare(\"remap\",option+1) == 0)\n        {\n          (void) RemapImages(_quantize_info,_images,(Image *) NULL,_exception);\n          break;\n        }\n      if (LocaleCompare(\"reverse\",option+1) == 0)\n        {\n          ReverseImageList(&_images);\n          break;\n        }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    case 's':\n    {\n      if (LocaleCompare(\"smush\",option+1) == 0)\n        {\n          /* FUTURE: this option needs more work to make better */\n          ssize_t\n            offset;\n\n          if (IsGeometry(arg1) == MagickFalse)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          offset=(ssize_t) StringToLong(arg1);\n          new_images=SmushImages(_images,IsNormalOp,offset,_exception);\n          break;\n        }\n      if (LocaleCompare(\"subimage\",option+1) == 0)\n        {\n          Image\n            *base_image,\n            *compare_image;\n\n          const char\n            *value;\n\n          MetricType\n            metric;\n\n          double\n            similarity;\n\n          RectangleInfo\n            offset;\n\n          base_image=GetImageFromList(_images,0);\n          compare_image=GetImageFromList(_images,1);\n\n          /* Comparision Metric */\n          metric=UndefinedErrorMetric;\n          value=GetImageOption(_image_info,\"metric\");\n          if (value != (const char *) NULL)\n            metric=(MetricType) ParseCommandOption(MagickMetricOptions,\n              MagickFalse,value);\n\n          new_images=SimilarityImage(base_image,compare_image,metric,0.0,\n            &offset,&similarity,_exception);\n\n          if (new_images != (Image *) NULL)\n            {\n              char\n                result[MagickPathExtent];\n\n              (void) FormatLocaleString(result,MagickPathExtent,\"%lf\",\n                similarity);\n              (void) SetImageProperty(new_images,\"subimage:similarity\",result,\n                _exception);\n              (void) FormatLocaleString(result,MagickPathExtent,\"%+ld\",(long)\n                offset.x);\n              (void) SetImageProperty(new_images,\"subimage:x\",result,\n                _exception);\n              (void) FormatLocaleString(result,MagickPathExtent,\"%+ld\",(long)\n                offset.y);\n              (void) SetImageProperty(new_images,\"subimage:y\",result,\n                _exception);\n              (void) FormatLocaleString(result,MagickPathExtent,\n                \"%lux%lu%+ld%+ld\",(unsigned long) offset.width,(unsigned long)\n                offset.height,(long) offset.x,(long) offset.y);\n              (void) SetImageProperty(new_images,\"subimage:offset\",result,\n                _exception);\n            }\n          break;\n        }\n      if (LocaleCompare(\"swap\",option+1) == 0)\n        {\n        Image\n          *p,\n          *q,\n          *swap;\n\n        ssize_t\n          index,\n          swap_index;\n\n        index=(-1);\n        swap_index=(-2);\n        if (IfNormalOp) {\n          GeometryInfo\n            geometry_info;\n\n          MagickStatusType\n            flags;\n\n          swap_index=(-1);\n          flags=ParseGeometry(arg1,&geometry_info);\n          if ((flags & RhoValue) == 0)\n            CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);\n          index=(ssize_t) geometry_info.rho;\n          if ((flags & SigmaValue) != 0)\n            swap_index=(ssize_t) geometry_info.sigma;\n        }\n        p=GetImageFromList(_images,index);\n        q=GetImageFromList(_images,swap_index);\n        if ((p == (Image *) NULL) || (q == (Image *) NULL)) {\n          if (IfNormalOp)\n            CLIWandExceptArgBreak(OptionError,\"InvalidImageIndex\",option,arg1)\n          else\n            CLIWandExceptionBreak(OptionError,\"TwoOrMoreImagesRequired\",option);\n        }\n        if (p == q)\n          CLIWandExceptArgBreak(OptionError,\"InvalidImageIndex\",option,arg1);\n        swap=CloneImage(p,0,0,MagickTrue,_exception);\n        if (swap == (Image *) NULL)\n          CLIWandExceptArgBreak(ResourceLimitError,\"MemoryAllocationFailed\",\n            option,GetExceptionMessage(errno));\n        ReplaceImageInList(&p,CloneImage(q,0,0,MagickTrue,_exception));\n        ReplaceImageInList(&q,swap);\n        _images=GetFirstImageInList(q);\n        break;\n      }\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n    }\n    default:\n      CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);\n  }\n\n  /* clean up percent escape interpreted strings */\n  if (arg1 != arg1n )\n    arg1=DestroyString((char *)arg1);\n  if (arg2 != arg2n )\n    arg2=DestroyString((char *)arg2);\n\n  /* if new image list generated, replace existing image list */\n  if (new_images == (Image *) NULL)\n    return(status == 0 ? MagickFalse : MagickTrue);\n  _images=DestroyImageList(_images);\n  _images=GetFirstImageInList(new_images);\n  return(status == 0 ? MagickFalse : MagickTrue);\n\n#undef _image_info\n#undef _images\n#undef _exception\n#undef _draw_info\n#undef _quantize_info\n#undef IfNormalOp\n#undef IfPlusOp\n#undef IsNormalOp\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   C L I N o I m a g e O p e r a t i o n s                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CLINoImageOperator() Applies operations that may not actually need images\n%  in an image list.\n%\n%  The classic operators of this type is \"-read\", which actually creates\n%  images even when no images are present.  Or image stack operators, which\n%  can be applied (push or pop) to an empty image list.\n%\n%  Note that these operators may involve other special 'option' prefix\n%  characters other  than '-' or '+', namely parenthesis and braces.\n%\n%  The format of the CLINoImageOption method is:\n%\n%      void CLINoImageOption(MagickCLI *cli_wand,const char *option,\n%           const char *arg1, const char *arg2)\n%\n%  A description of each parameter follows:\n%\n%    o cli_wand: the main CLI Wand to use. (sometimes not required)\n%\n%    o option: The special option (with any switch char) to process\n%\n%    o arg1 & arg2: Argument for option, if required\n%                   Currently arg2 is not used.\n%\n*/\nWandPrivate void CLINoImageOperator(MagickCLI *cli_wand,\n  const char *option,const char *arg1n,const char *arg2n)\n{\n  const char    /* percent escaped versions of the args */\n    *arg1,\n    *arg2;\n\n#define _image_info     (cli_wand->wand.image_info)\n#define _images         (cli_wand->wand.images)\n#define _exception      (cli_wand->wand.exception)\n#define _process_flags  (cli_wand->process_flags)\n#define _option_type    ((CommandOptionFlags) cli_wand->command->flags)\n#define IfNormalOp      (*option=='-')\n#define IfPlusOp        (*option!='-')\n\n  assert(cli_wand != (MagickCLI *) NULL);\n  assert(cli_wand->signature == MagickWandSignature);\n  assert(cli_wand->wand.signature == MagickWandSignature);\n\n  if (cli_wand->wand.debug != MagickFalse)\n    (void) CLILogEvent(cli_wand,CommandEvent,GetMagickModule(),\n      \"- NoImage Operator: %s \\\"%s\\\" \\\"%s\\\"\", option,\n      arg1n != (char *) NULL ? arg1n : \"\",\n      arg2n != (char *) NULL ? arg2n : \"\");\n\n  arg1 = arg1n;\n  arg2 = arg2n;\n\n  /* Interpret Percent Escapes in Arguments - using first image */\n  if ( (((_process_flags & ProcessInterpretProperities) != 0 )\n        || ((_option_type & AlwaysInterpretArgsFlag) != 0)\n       )  && ((_option_type & NeverInterpretArgsFlag) == 0) ) {\n    /* Interpret Percent escapes in argument 1 */\n    if (arg1n != (char *) NULL) {\n      arg1=InterpretImageProperties(_image_info,_images,arg1n,_exception);\n      if (arg1 == (char *) NULL) {\n        CLIWandException(OptionWarning,\"InterpretPropertyFailure\",option);\n        arg1=arg1n;  /* use the given argument as is */\n      }\n    }\n    if (arg2n != (char *) NULL) {\n      arg2=InterpretImageProperties(_image_info,_images,arg2n,_exception);\n      if (arg2 == (char *) NULL) {\n        CLIWandException(OptionWarning,\"InterpretPropertyFailure\",option);\n        arg2=arg2n;  /* use the given argument as is */\n      }\n    }\n  }\n#undef _process_flags\n#undef _option_type\n\n  do {  /* break to exit code */\n    /*\n      No-op options  (ignore these)\n    */\n    if (LocaleCompare(\"noop\",option+1) == 0)   /* zero argument */\n      break;\n    if (LocaleCompare(\"sans\",option+1) == 0)   /* one argument */\n      break;\n    if (LocaleCompare(\"sans0\",option+1) == 0)  /* zero argument */\n      break;\n    if (LocaleCompare(\"sans1\",option+1) == 0)  /* one argument */\n      break;\n    if (LocaleCompare(\"sans2\",option+1) == 0)  /* two arguments */\n      break;\n    /*\n      Image Reading\n    */\n    if ( ( LocaleCompare(\"read\",option+1) == 0 ) ||\n      ( LocaleCompare(\"--\",option) == 0 ) ) {\n      /* Do Glob filename Expansion for 'arg1' then read all images.\n      *\n      * Expansion handles '@', '~', '*', and '?' meta-characters while ignoring\n      * (but attaching to the filenames in the generated argument list) any\n      * [...] read modifiers that may be present.\n      *\n      * For example: It will expand '*.gif[20x20]' into a list such as\n      * 'abc.gif[20x20]',  'foobar.gif[20x20]',  'xyzzy.gif[20x20]'\n      *\n      * NOTE: In IMv6 this was done globally across all images. This\n      * meant you could include IM options in '@filename' lists, but you\n      * could not include comments.   Doing it only for image read makes\n      * it far more secure.\n      *\n      * Note: arguments do not have percent escapes expanded for security\n      * reasons.\n      */\n      int      argc;\n      char     **argv;\n      ssize_t  i;\n\n      argc = 1;\n      argv = (char **) &arg1;\n\n      /* Expand 'glob' expressions in the given filename.\n        Expansion handles any 'coder:' prefix, or read modifiers attached\n        to the filename, including them in the resulting expanded list.\n      */\n      if (ExpandFilenames(&argc,&argv) == MagickFalse)\n        CLIWandExceptArgBreak(ResourceLimitError,\"MemoryAllocationFailed\",\n            option,GetExceptionMessage(errno));\n\n      /* loop over expanded filename list, and read then all in */\n      for (i=0; i < (ssize_t) argc; i++) {\n        Image *\n          new_images;\n        if (_image_info->ping != MagickFalse)\n          new_images=PingImages(_image_info,argv[i],_exception);\n        else\n          new_images=ReadImages(_image_info,argv[i],_exception);\n        AppendImageToList(&_images, new_images);\n        argv[i]=DestroyString(argv[i]);\n      }\n      argv=(char **) RelinquishMagickMemory(argv);\n      break;\n    }\n    /*\n      Image Writing\n      Note: Writing a empty image list is valid in specific cases\n    */\n    if (LocaleCompare(\"write\",option+1) == 0) {\n      /* Note: arguments do not have percent escapes expanded */\n      char\n        key[MagickPathExtent];\n\n      Image\n        *write_images;\n\n      ImageInfo\n        *write_info;\n\n      /* Need images, unless a \"null:\" output coder is used */\n      if ( _images == (Image *) NULL ) {\n        if ( LocaleCompare(arg1,\"null:\") == 0 )\n          break;\n        CLIWandExceptArgBreak(OptionError,\"NoImagesForWrite\",option,arg1);\n      }\n\n      (void) FormatLocaleString(key,MagickPathExtent,\"cache:%s\",arg1);\n      (void) DeleteImageRegistry(key);\n      write_images=_images;\n      if (IfPlusOp)\n        write_images=CloneImageList(_images,_exception);\n      write_info=CloneImageInfo(_image_info);\n      (void) WriteImages(write_info,write_images,arg1,_exception);\n      write_info=DestroyImageInfo(write_info);\n      if (IfPlusOp)\n        write_images=DestroyImageList(write_images);\n      break;\n    }\n    /*\n      Parenthesis and Brace operations\n    */\n    if (LocaleCompare(\"(\",option) == 0) {\n      /* stack 'push' images */\n      Stack\n        *node;\n\n      size_t\n        size;\n\n      size=0;\n      node=cli_wand->image_list_stack;\n      for ( ; node != (Stack *) NULL; node=node->next)\n        size++;\n      if ( size >= MAX_STACK_DEPTH )\n        CLIWandExceptionBreak(OptionError,\"ParenthesisNestedTooDeeply\",option);\n      node=(Stack *) AcquireMagickMemory(sizeof(*node));\n      if (node == (Stack *) NULL)\n        CLIWandExceptionBreak(ResourceLimitFatalError,\n            \"MemoryAllocationFailed\",option);\n      node->data = (void *)cli_wand->wand.images;\n      node->next = cli_wand->image_list_stack;\n      cli_wand->image_list_stack = node;\n      cli_wand->wand.images = NewImageList();\n\n      /* handle respect-parenthesis */\n      if (IsStringTrue(GetImageOption(cli_wand->wand.image_info,\n                    \"respect-parenthesis\")) != MagickFalse)\n        option=\"{\"; /* fall-thru so as to push image settings too */\n      else\n        break;\n      /* fall thru to operation */\n    }\n    if (LocaleCompare(\"{\",option) == 0) {\n      /* stack 'push' of image_info settings */\n      Stack\n        *node;\n\n      size_t\n        size;\n\n      size=0;\n      node=cli_wand->image_info_stack;\n      for ( ; node != (Stack *) NULL; node=node->next)\n        size++;\n      if ( size >= MAX_STACK_DEPTH )\n        CLIWandExceptionBreak(OptionError,\"CurlyBracesNestedTooDeeply\",option);\n      node=(Stack *) AcquireMagickMemory(sizeof(*node));\n      if (node == (Stack *) NULL)\n        CLIWandExceptionBreak(ResourceLimitFatalError,\n            \"MemoryAllocationFailed\",option);\n\n      node->data = (void *)cli_wand->wand.image_info;\n      node->next = cli_wand->image_info_stack;\n\n      cli_wand->image_info_stack = node;\n      cli_wand->wand.image_info = CloneImageInfo(cli_wand->wand.image_info);\n      if (cli_wand->wand.image_info == (ImageInfo *) NULL) {\n        CLIWandException(ResourceLimitFatalError,\"MemoryAllocationFailed\",\n            option);\n        cli_wand->wand.image_info = (ImageInfo *)node->data;\n        node = (Stack *)RelinquishMagickMemory(node);\n        break;\n      }\n\n      break;\n    }\n    if (LocaleCompare(\")\",option) == 0) {\n      /* pop images from stack */\n      Stack\n        *node;\n\n      node = (Stack *)cli_wand->image_list_stack;\n      if ( node == (Stack *) NULL)\n        CLIWandExceptionBreak(OptionError,\"UnbalancedParenthesis\",option);\n      cli_wand->image_list_stack = node->next;\n\n      AppendImageToList((Image **)&node->data,cli_wand->wand.images);\n      cli_wand->wand.images= (Image *)node->data;\n      node = (Stack *)RelinquishMagickMemory(node);\n\n      /* handle respect-parenthesis - of the previous 'pushed' settings */\n      node = cli_wand->image_info_stack;\n      if ( node != (Stack *) NULL)\n        {\n          if (IsStringTrue(GetImageOption(\n                cli_wand->wand.image_info,\"respect-parenthesis\")) != MagickFalse)\n            option=\"}\"; /* fall-thru so as to pop image settings too */\n          else\n            break;\n        }\n      else\n        break;\n      /* fall thru to next if */\n    }\n    if (LocaleCompare(\"}\",option) == 0) {\n      /* pop image_info settings from stack */\n      Stack\n        *node;\n\n      node = (Stack *)cli_wand->image_info_stack;\n      if ( node == (Stack *) NULL)\n        CLIWandExceptionBreak(OptionError,\"UnbalancedCurlyBraces\",option);\n      cli_wand->image_info_stack = node->next;\n\n      (void) DestroyImageInfo(cli_wand->wand.image_info);\n      cli_wand->wand.image_info = (ImageInfo *)node->data;\n      node = (Stack *)RelinquishMagickMemory(node);\n\n      GetDrawInfo(cli_wand->wand.image_info, cli_wand->draw_info);\n      cli_wand->quantize_info=DestroyQuantizeInfo(cli_wand->quantize_info);\n      cli_wand->quantize_info=AcquireQuantizeInfo(cli_wand->wand.image_info);\n\n      break;\n    }\n      if (LocaleCompare(\"print\",option+1) == 0)\n        {\n          (void) FormatLocaleFile(stdout,\"%s\",arg1);\n          break;\n        }\n    if (LocaleCompare(\"set\",option+1) == 0)\n      {\n        /* Settings are applied to each image in memory in turn (if any).\n           While a option: only need to be applied once globally.\n\n           NOTE: rguments have not been automatically percent expaneded\n        */\n\n        /* escape the 'key' once only, using first image. */\n        arg1=InterpretImageProperties(_image_info,_images,arg1n,_exception);\n        if (arg1 == (char *) NULL)\n          CLIWandExceptionBreak(OptionWarning,\"InterpretPropertyFailure\",\n                option);\n\n        if (LocaleNCompare(arg1,\"registry:\",9) == 0)\n          {\n            if (IfPlusOp)\n              {\n                (void) DeleteImageRegistry(arg1+9);\n                arg1=DestroyString((char *)arg1);\n                break;\n              }\n            arg2=InterpretImageProperties(_image_info,_images,arg2n,_exception);\n            if (arg2 == (char *) NULL) {\n              arg1=DestroyString((char *)arg1);\n              CLIWandExceptionBreak(OptionWarning,\"InterpretPropertyFailure\",\n                    option);\n            }\n            (void) SetImageRegistry(StringRegistryType,arg1+9,arg2,_exception);\n            arg1=DestroyString((char *)arg1);\n            arg2=DestroyString((char *)arg2);\n            break;\n          }\n        if (LocaleNCompare(arg1,\"option:\",7) == 0)\n          {\n            /* delete equivelent artifact from all images (if any) */\n            if (_images != (Image *) NULL)\n              {\n                MagickResetIterator(&cli_wand->wand);\n                while (MagickNextImage(&cli_wand->wand) != MagickFalse)\n                  (void) DeleteImageArtifact(_images,arg1+7);\n                MagickResetIterator(&cli_wand->wand);\n              }\n            /* now set/delete the global option as needed */\n            /* FUTURE: make escapes in a global 'option:' delayed */\n            arg2=(char *) NULL;\n            if (IfNormalOp)\n              {\n                arg2=InterpretImageProperties(_image_info,_images,arg2n,_exception);\n                if (arg2 == (char *) NULL)\n                  CLIWandExceptionBreak(OptionWarning,\n                       \"InterpretPropertyFailure\",option);\n              }\n            (void) SetImageOption(_image_info,arg1+7,arg2);\n            arg1=DestroyString((char *)arg1);\n            arg2=DestroyString((char *)arg2);\n            break;\n          }\n        /* Set Artifacts/Properties/Attributes all images (required) */\n        if ( _images == (Image *) NULL )\n          CLIWandExceptArgBreak(OptionWarning,\"NoImageForProperty\",option,arg1);\n\n        MagickResetIterator(&cli_wand->wand);\n        while (MagickNextImage(&cli_wand->wand) != MagickFalse)\n          {\n            arg2=(char *) NULL;\n            if (IfNormalOp)\n              {\n                arg2=InterpretImageProperties(_image_info,_images,arg2n,_exception);\n                if (arg2 == (char *) NULL)\n                  CLIWandExceptionBreak(OptionWarning,\n                       \"InterpretPropertyFailure\",option);\n              }\n            if (LocaleNCompare(arg1,\"artifact:\",9) == 0)\n              (void) SetImageArtifact(_images,arg1+9,arg2);\n            else if (LocaleNCompare(arg1,\"property:\",9) == 0)\n              (void) SetImageProperty(_images,arg1+9,arg2,_exception);\n            else\n              (void) SetImageProperty(_images,arg1,arg2,_exception);\n            arg2=DestroyString((char *)arg2);\n          }\n        MagickResetIterator(&cli_wand->wand);\n        arg1=DestroyString((char *)arg1);\n        break;\n     }\n    if (LocaleCompare(\"clone\",option+1) == 0) {\n        Image\n          *new_images;\n\n        if (*option == '+')\n          arg1=AcquireString(\"-1\");\n        if (IsSceneGeometry(arg1,MagickFalse) == MagickFalse)\n          CLIWandExceptionBreak(OptionError,\"InvalidArgument\",option);\n        if ( cli_wand->image_list_stack == (Stack *) NULL)\n          CLIWandExceptionBreak(OptionError,\"UnableToCloneImage\",option);\n        new_images = (Image *)cli_wand->image_list_stack->data;\n        if (new_images == (Image *) NULL)\n          CLIWandExceptionBreak(OptionError,\"UnableToCloneImage\",option);\n        new_images=CloneImages(new_images,arg1,_exception);\n        if (new_images == (Image *) NULL)\n          CLIWandExceptionBreak(OptionError,\"NoSuchImage\",option);\n        AppendImageToList(&_images,new_images);\n        break;\n      }\n    /*\n       Informational Operations.\n\n       Note that these do not require either a cli-wand or images!\n       Though currently a cli-wand much be provided regardless.\n    */\n    if (LocaleCompare(\"version\",option+1) == 0)\n      {\n        ListMagickVersion(stdout);\n        break;\n      }\n    if (LocaleCompare(\"list\",option+1) == 0) {\n      /*\n         FUTURE: This 'switch' should really be part of MagickCore\n      */\n      ssize_t\n        list;\n\n      list=ParseCommandOption(MagickListOptions,MagickFalse,arg1);\n      if ( list < 0 ) {\n        CLIWandExceptionArg(OptionError,\"UnrecognizedListType\",option,arg1);\n        break;\n      }\n      switch (list)\n      {\n        case MagickCoderOptions:\n        {\n          (void) ListCoderInfo((FILE *) NULL,_exception);\n          break;\n        }\n        case MagickColorOptions:\n        {\n          (void) ListColorInfo((FILE *) NULL,_exception);\n          break;\n        }\n        case MagickConfigureOptions:\n        {\n          (void) ListConfigureInfo((FILE *) NULL,_exception);\n          break;\n        }\n        case MagickDelegateOptions:\n        {\n          (void) ListDelegateInfo((FILE *) NULL,_exception);\n          break;\n        }\n        case MagickFontOptions:\n        {\n          (void) ListTypeInfo((FILE *) NULL,_exception);\n          break;\n        }\n        case MagickFormatOptions:\n          (void) ListMagickInfo((FILE *) NULL,_exception);\n          break;\n        case MagickLocaleOptions:\n          (void) ListLocaleInfo((FILE *) NULL,_exception);\n          break;\n        case MagickLogOptions:\n          (void) ListLogInfo((FILE *) NULL,_exception);\n          break;\n        case MagickMagicOptions:\n          (void) ListMagicInfo((FILE *) NULL,_exception);\n          break;\n        case MagickMimeOptions:\n          (void) ListMimeInfo((FILE *) NULL,_exception);\n          break;\n        case MagickModuleOptions:\n          (void) ListModuleInfo((FILE *) NULL,_exception);\n          break;\n        case MagickPolicyOptions:\n          (void) ListPolicyInfo((FILE *) NULL,_exception);\n          break;\n        case MagickResourceOptions:\n          (void) ListMagickResourceInfo((FILE *) NULL,_exception);\n          break;\n        case MagickThresholdOptions:\n          (void) ListThresholdMaps((FILE *) NULL,_exception);\n          break;\n        default:\n          (void) ListCommandOptions((FILE *) NULL,(CommandOption) list,\n            _exception);\n          break;\n      }\n      break;\n    }\n\n    CLIWandException(OptionError,\"UnrecognizedOption\",option);\n\nDisableMSCWarning(4127)\n  } while (0);  /* break to exit code. */\nRestoreMSCWarning\n\n  /* clean up percent escape interpreted strings */\n  if (arg1 != arg1n )\n    arg1=DestroyString((char *)arg1);\n  if (arg2 != arg2n )\n    arg2=DestroyString((char *)arg2);\n\n#undef _image_info\n#undef _images\n#undef _exception\n#undef IfNormalOp\n#undef IfPlusOp\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   C L I O p t i o n                                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CLIOption() Processes the given option using the given CLI Magick Wand.\n%  The option arguments can be variable in number, though at this time no more\n%  that two is actually used by any option (this may change). Excess options\n%  are simply ignored.\n%\n%  If the cli_wand->command pointer is non-null, then it is assumed that the\n%  option has already been search for up from the CommandOptions[] table in\n%  \"MagickCore/options.c\" using  GetCommandOptionInfo().  If not set this\n%  routine will do the lookup instead. The pointer is reset afterward.\n%\n%  This action allows the caller to lookup and pre-handle any 'special'\n%  options, (such as implicit reads) before calling this general option\n%  handler to deal with 'standard' command line options.\n%\n%  The format of the CLIOption method is:\n%\n%       void CLIOption(MagickCLI *cli_wand,const char *option, ...)\n%\n%  A description of each parameter follows:\n%\n%     o cli_wand: the main CLI Wand to use.\n%\n%     o option: The special option (with any switch char) to process\n%\n%     o args: any required arguments for an option (variable number)\n%\n%  Example Usage...\n%\n%    CLIoption(cli_wand,\"-read\",\"rose:\");\n%    CLIoption(cli_wand,\"-virtual-pixel\",\"transparent\");\n%    CLIoption(cli_wand,\"-distort\",\"SRT:\",\"30\");\n%    CLIoption(cli_wand,\"-write\",\"rotated_rose.png\");\n%\n*/\nWandExport void CLIOption(MagickCLI *cli_wand,const char *option,...)\n{\n  const char    /* extracted option args from args */\n    *arg1,\n    *arg2;\n\n  CommandOptionFlags\n    option_type;\n\n  assert(cli_wand != (MagickCLI *) NULL);\n  assert(cli_wand->signature == MagickWandSignature);\n  assert(cli_wand->wand.signature == MagickWandSignature);\n\n  do { /* Break Code Block for error handling */\n\n    /* get information about option */\n    if ( cli_wand->command == (const OptionInfo *) NULL )\n      cli_wand->command = GetCommandOptionInfo(option);\n#if 0\n      (void) FormatLocaleFile(stderr, \"CLIOption \\\"%s\\\" matched \\\"%s\\\"\\n\",\n            option, cli_wand->command->mnemonic );\n#endif\n    option_type=(CommandOptionFlags) cli_wand->command->flags;\n\n    if ( option_type == UndefinedOptionFlag )\n      CLIWandExceptionReturn(OptionFatalError,\"UnrecognizedOption\",option);\n\n    assert( LocaleCompare(cli_wand->command->mnemonic,option) == 0 );\n\n    /* deprecated options */\n    if ( (option_type & DeprecateOptionFlag) != 0 )\n      CLIWandExceptionBreak(OptionError,\"DeprecatedOptionNoCode\",option);\n\n    /* options that this module does not handle */\n    if ((option_type & (SpecialOptionFlag|GenesisOptionFlag)) != 0 )\n      CLIWandExceptionBreak(OptionFatalError,\"InvalidUseOfOption\",option);\n\n    /* Get argument strings from VarArgs\n      How can you determine if enough arguments was supplied?\n      What happens if not enough arguments were supplied?\n    */\n    { size_t\n        count = (size_t) cli_wand->command->type;\n\n      va_list\n        operands;\n\n      va_start(operands,option);\n\n      arg1=arg2=NULL;\n      if ( count >= 1 )\n        arg1=(const char *) va_arg(operands, const char *);\n      if ( count >= 2 )\n        arg2=(const char *) va_arg(operands, const char *);\n\n      va_end(operands);\n#if 0\n      (void) FormatLocaleFile(stderr,\n        \"CLIOption: \\\"%s\\\"  Count: %ld  Flags: %04x  Args: \\\"%s\\\" \\\"%s\\\"\\n\",\n            option,(long) count,option_type,arg1,arg2);\n#endif\n    }\n\n    /*\n      Call the appropriate option handler\n    */\n\n    /* FUTURE: this is temporary - get 'settings' to handle distribution of\n      settings to images attributes,proprieties,artifacts */\n    if ( cli_wand->wand.images != (Image *) NULL )\n      (void) SyncImagesSettings(cli_wand->wand.image_info,cli_wand->wand.images,\n        cli_wand->wand.exception);\n\n    if ( (option_type & SettingOptionFlags) != 0 ) {\n      CLISettingOptionInfo(cli_wand, option, arg1, arg2);\n      /*\n        FUTURE: Sync Specific Settings into Image Properities (not global)\n      */\n    }\n\n    /* Operators that do not need images - read, write, stack, clone */\n    if ((option_type & NoImageOperatorFlag) != 0)\n      CLINoImageOperator(cli_wand, option, arg1, arg2);\n\n    /* FUTURE: The not a setting part below is a temporary hack due to\n    * some options being both a Setting and a Simple operator.\n    * Specifically -monitor, -depth, and  -colorspace */\n    if ( cli_wand->wand.images == (Image *) NULL )\n      if ( ((option_type & (SimpleOperatorFlag|ListOperatorFlag)) != 0 ) &&\n          ((option_type & SettingOptionFlags) == 0 ))  /* temp hack */\n        CLIWandExceptionBreak(OptionError,\"NoImagesFound\",option);\n\n    /* Operators which loop of individual images, simply */\n    if ( (option_type & SimpleOperatorFlag) != 0 &&\n         cli_wand->wand.images != (Image *) NULL) /* temp hack */\n      {\n        ExceptionInfo *exception=AcquireExceptionInfo();\n        (void) CLISimpleOperatorImages(cli_wand, option, arg1, arg2,exception);\n        exception=DestroyExceptionInfo(exception);\n      }\n\n    /* Operators that work on the image list as a whole */\n    if ( (option_type & ListOperatorFlag) != 0 )\n      (void) CLIListOperatorImages(cli_wand, option, arg1, arg2);\n\nDisableMSCWarning(4127)\n  } while (0);  /* end Break code block */\nRestoreMSCWarning\n\n  cli_wand->command = (const OptionInfo *) NULL; /* prevent re-use later */\n}\n"], "filenames": ["MagickWand/operation.c"], "buggy_code_start_loc": [3878], "buggy_code_end_loc": [3879], "fixing_code_start_loc": [3878], "fixing_code_end_loc": [3882], "type": "CWE-401", "message": "ImageMagick 7.0.8-50 Q16 has direct memory leaks in AcquireMagickMemory because of an error in CLIListOperatorImages in MagickWand/operation.c for a NULL value.", "other": {"cve": {"id": "CVE-2019-13296", "sourceIdentifier": "cve@mitre.org", "published": "2019-07-05T01:15:09.983", "lastModified": "2023-03-02T15:57:52.417", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "ImageMagick 7.0.8-50 Q16 has direct memory leaks in AcquireMagickMemory because of an error in CLIListOperatorImages in MagickWand/operation.c for a NULL value."}, {"lang": "es", "value": "ImageMagick versi\u00f3n 7.0.8-50 Q16, presenta p\u00e9rdidas de memoria directa en la funci\u00f3n AcquireMagickMemory debido a un error en CLIListOperatorImages en el archivo MagickWand/operation.c para un valor NULL."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-401"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.8-50:q16:*:*:*:*:*:*", "matchCriteriaId": "25CCEA99-8329-46C6-9625-4FE15F24CF69"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.0:*:*:*:*:*:*:*", "matchCriteriaId": "F1E78106-58E6-4D59-990F-75DA575BFAD9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2019-08/msg00069.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/ce08a3691a8ac29125e29fc41967b3737fa3f425", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/ImageMagick/ImageMagick/issues/1604", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/ce08a3691a8ac29125e29fc41967b3737fa3f425"}}