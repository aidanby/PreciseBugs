{"buggy_code": ["import { useEffect, useState, useRef } from \"react\";\nimport { useTranslation } from \"react-i18next\";\nimport { useLocationStore, useDialogStore } from \"../store/module\";\nimport { memoSpecialTypes } from \"../helpers/filter\";\nimport Icon from \"./Icon\";\nimport \"../less/search-bar.less\";\n\nconst SearchBar = () => {\n  const { t } = useTranslation();\n  const locationStore = useLocationStore();\n  const dialogStore = useDialogStore();\n  const memoType = locationStore.state.query.type;\n  const [queryText, setQueryText] = useState(\"\");\n  const inputRef = useRef<HTMLInputElement>(null);\n  const [isFocus, setIsFocus] = useState(false);\n\n  useEffect(() => {\n    const handleKeyDown = (event: KeyboardEvent) => {\n      if (!inputRef.current) {\n        return;\n      }\n      if (dialogStore.getState().dialogStack.length) {\n        return;\n      }\n      const isMetaKey = event.ctrlKey || event.metaKey;\n      if (isMetaKey && event.key === \"f\") {\n        event.preventDefault();\n        inputRef.current.focus();\n        return;\n      }\n    };\n    document.body.addEventListener(\"keydown\", handleKeyDown);\n    return () => {\n      document.body.removeEventListener(\"keydown\", handleKeyDown);\n    };\n  }, []);\n\n  useEffect(() => {\n    const text = locationStore.getState().query.text;\n    setQueryText(text === undefined ? \"\" : text);\n  }, [locationStore.getState().query.text]);\n\n  const handleMemoTypeItemClick = (type: MemoSpecType | undefined) => {\n    const { type: prevType } = locationStore.getState().query ?? {};\n    if (type === prevType) {\n      type = undefined;\n    }\n    locationStore.setMemoTypeQuery(type);\n  };\n\n  const handleTextQueryInput = (event: React.FormEvent<HTMLInputElement>) => {\n    const text = event.currentTarget.value;\n    setQueryText(text);\n    locationStore.setTextQuery(text.length === 0 ? undefined : text);\n  };\n\n  const handleFocus = () => {\n    setIsFocus(true);\n  };\n\n  const handleBlur = () => {\n    setIsFocus(false);\n  };\n\n  return (\n    <div className={`search-bar-container ${isFocus ? \"is-focus\" : \"\"}`}>\n      <div className=\"search-bar-inputer\">\n        <Icon.Search className=\"icon-img\" />\n        <input\n          className=\"text-input\"\n          autoComplete=\"new-password\"\n          type=\"text\"\n          placeholder=\"\"\n          ref={inputRef}\n          value={queryText}\n          onChange={handleTextQueryInput}\n          onFocus={handleFocus}\n          onBlur={handleBlur}\n        />\n      </div>\n      <div className=\"quickly-action-wrapper\">\n        <div className=\"quickly-action-container\">\n          <p className=\"title-text\">{t(\"search.quickly-filter\").toUpperCase()}</p>\n          <div className=\"section-container types-container\">\n            <span className=\"section-text\">{t(\"common.type\").toUpperCase()}:</span>\n            <div className=\"values-container\">\n              {memoSpecialTypes.map((type, idx) => {\n                return (\n                  <div key={type.value}>\n                    <span\n                      className={`type-item ${memoType === type.value ? \"selected\" : \"\"}`}\n                      onClick={() => {\n                        handleMemoTypeItemClick(type.value as MemoSpecType);\n                      }}\n                    >\n                      {t(type.text)}\n                    </span>\n                    {idx + 1 < memoSpecialTypes.length ? <span className=\"split-text\">/</span> : null}\n                  </div>\n                );\n              })}\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default SearchBar;\n", "const escapeRegExp = (str: string): string => {\n  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n};\n\nconst walkthroughNodeWithKeyword = (node: HTMLElement, keyword: string) => {\n  if (node.nodeType === 3) {\n    const span = document.createElement(\"span\");\n    span.innerHTML = node.nodeValue?.replace(new RegExp(keyword, \"g\"), `<mark>${keyword}</mark>`) ?? \"\";\n    node.parentNode?.insertBefore(span, node);\n    node.parentNode?.removeChild(node);\n  }\n  for (const child of Array.from(node.childNodes)) {\n    walkthroughNodeWithKeyword(<HTMLElement>child, keyword);\n  }\n  return node.innerHTML;\n};\n\nexport const highlightWithWord = (html: string, keyword?: string): string => {\n  if (!keyword) {\n    return html;\n  }\n  keyword = escapeRegExp(keyword);\n  const wrap = document.createElement(\"div\");\n  wrap.innerHTML = html;\n  return walkthroughNodeWithKeyword(wrap, keyword);\n};\n", "import { marked } from \"..\";\nimport Link from \"./Link\";\n\nexport const BOLD_REG = /\\*\\*(.+?)\\*\\*/;\n\nconst matcher = (rawStr: string) => {\n  const matchResult = rawStr.match(BOLD_REG);\n  return matchResult;\n};\n\nconst renderer = (rawStr: string): string => {\n  const matchResult = matcher(rawStr);\n  if (!matchResult) {\n    return rawStr;\n  }\n\n  const parsedContent = marked(matchResult[1], [], [Link]);\n  return `<strong>${parsedContent}</strong>`;\n};\n\nexport default {\n  name: \"bold\",\n  regex: BOLD_REG,\n  matcher,\n  renderer,\n};\n", "import { marked } from \"..\";\nimport Link from \"./Link\";\n\nexport const BOLD_EMPHASIS_REG = /\\*\\*\\*(.+?)\\*\\*\\*/;\n\nconst matcher = (rawStr: string) => {\n  const matchResult = rawStr.match(BOLD_EMPHASIS_REG);\n  return matchResult;\n};\n\nconst renderer = (rawStr: string): string => {\n  const matchResult = matcher(rawStr);\n  if (!matchResult) {\n    return rawStr;\n  }\n\n  const parsedContent = marked(matchResult[1], [], [Link]);\n  return `<strong><em>${parsedContent}</em></strong>`;\n};\n\nexport default {\n  name: \"bold emphasis\",\n  regex: BOLD_EMPHASIS_REG,\n  matcher,\n  renderer,\n};\n", "import { marked } from \"..\";\nimport Link from \"./Link\";\n\nexport const EMPHASIS_REG = /\\*(.+?)\\*/;\n\nconst matcher = (rawStr: string) => {\n  const matchResult = rawStr.match(EMPHASIS_REG);\n  return matchResult;\n};\n\nconst renderer = (rawStr: string): string => {\n  const matchResult = matcher(rawStr);\n  if (!matchResult) {\n    return rawStr;\n  }\n\n  const parsedContent = marked(matchResult[1], [], [Link]);\n  return `<em>${parsedContent}</em>`;\n};\n\nexport default {\n  name: \"emphasis\",\n  regex: EMPHASIS_REG,\n  matcher,\n  renderer,\n};\n", "import { escape } from \"lodash-es\";\nimport Emphasis from \"./Emphasis\";\nimport Bold from \"./Bold\";\nimport { marked } from \"..\";\nimport InlineCode from \"./InlineCode\";\nimport BoldEmphasis from \"./BoldEmphasis\";\n\nexport const LINK_REG = /\\[(.*?)\\]\\((.+?)\\)+/;\n\nconst matcher = (rawStr: string) => {\n  const matchResult = rawStr.match(LINK_REG);\n  return matchResult;\n};\n\nconst renderer = (rawStr: string): string => {\n  const matchResult = matcher(rawStr);\n  if (!matchResult) {\n    return rawStr;\n  }\n  const parsedContent = marked(matchResult[1], [], [InlineCode, BoldEmphasis, Emphasis, Bold]);\n  return `<a class='link' target='_blank' rel='noreferrer' href='${escape(matchResult[2])}'>${parsedContent}</a>`;\n};\n\nexport default {\n  name: \"link\",\n  regex: LINK_REG,\n  matcher,\n  renderer,\n};\n"], "fixing_code": ["import { useEffect, useState, useRef } from \"react\";\nimport { useTranslation } from \"react-i18next\";\nimport { useLocationStore, useDialogStore } from \"../store/module\";\nimport { memoSpecialTypes } from \"../helpers/filter\";\nimport Icon from \"./Icon\";\nimport \"../less/search-bar.less\";\n\nconst SearchBar = () => {\n  const { t } = useTranslation();\n  const locationStore = useLocationStore();\n  const dialogStore = useDialogStore();\n  const memoType = locationStore.state.query.type;\n  const [queryText, setQueryText] = useState(\"\");\n  const inputRef = useRef<HTMLInputElement>(null);\n  const [isFocus, setIsFocus] = useState(false);\n\n  useEffect(() => {\n    const handleKeyDown = (event: KeyboardEvent) => {\n      if (!inputRef.current) {\n        return;\n      }\n      if (dialogStore.getState().dialogStack.length) {\n        return;\n      }\n      const isMetaKey = event.ctrlKey || event.metaKey;\n      if (isMetaKey && event.key === \"f\") {\n        event.preventDefault();\n        inputRef.current.focus();\n        return;\n      }\n    };\n    document.body.addEventListener(\"keydown\", handleKeyDown);\n    return () => {\n      document.body.removeEventListener(\"keydown\", handleKeyDown);\n    };\n  }, []);\n\n  useEffect(() => {\n    const text = locationStore.getState().query.text;\n    setQueryText(text === undefined ? \"\" : text);\n  }, [locationStore.state.query.text]);\n\n  const handleMemoTypeItemClick = (type: MemoSpecType | undefined) => {\n    const { type: prevType } = locationStore.getState().query ?? {};\n    if (type === prevType) {\n      type = undefined;\n    }\n    locationStore.setMemoTypeQuery(type);\n  };\n\n  const handleTextQueryInput = (event: React.FormEvent<HTMLInputElement>) => {\n    const text = event.currentTarget.value;\n    setQueryText(text);\n    locationStore.setTextQuery(text.length === 0 ? undefined : text);\n  };\n\n  const handleFocus = () => {\n    setIsFocus(true);\n  };\n\n  const handleBlur = () => {\n    setIsFocus(false);\n  };\n\n  return (\n    <div className={`search-bar-container ${isFocus ? \"is-focus\" : \"\"}`}>\n      <div className=\"search-bar-inputer\">\n        <Icon.Search className=\"icon-img\" />\n        <input\n          className=\"text-input\"\n          autoComplete=\"new-password\"\n          type=\"text\"\n          placeholder=\"\"\n          ref={inputRef}\n          value={queryText}\n          onChange={handleTextQueryInput}\n          onFocus={handleFocus}\n          onBlur={handleBlur}\n        />\n      </div>\n      <div className=\"quickly-action-wrapper\">\n        <div className=\"quickly-action-container\">\n          <p className=\"title-text\">{t(\"search.quickly-filter\").toUpperCase()}</p>\n          <div className=\"section-container types-container\">\n            <span className=\"section-text\">{t(\"common.type\").toUpperCase()}:</span>\n            <div className=\"values-container\">\n              {memoSpecialTypes.map((type, idx) => {\n                return (\n                  <div key={type.value}>\n                    <span\n                      className={`type-item ${memoType === type.value ? \"selected\" : \"\"}`}\n                      onClick={() => {\n                        handleMemoTypeItemClick(type.value as MemoSpecType);\n                      }}\n                    >\n                      {t(type.text)}\n                    </span>\n                    {idx + 1 < memoSpecialTypes.length ? <span className=\"split-text\">/</span> : null}\n                  </div>\n                );\n              })}\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default SearchBar;\n", "import { escape } from \"lodash\";\n\nconst walkthroughNodeWithKeyword = (node: HTMLElement, keyword: string) => {\n  if (node.nodeType === 3) {\n    const span = document.createElement(\"span\");\n    span.innerHTML = node.nodeValue?.replace(new RegExp(keyword, \"g\"), `<mark>${keyword}</mark>`) ?? \"\";\n    node.parentNode?.insertBefore(span, node);\n    node.parentNode?.removeChild(node);\n  }\n  for (const child of Array.from(node.childNodes)) {\n    walkthroughNodeWithKeyword(<HTMLElement>child, keyword);\n  }\n  return node.innerHTML;\n};\n\nexport const highlightWithWord = (html: string, keyword?: string): string => {\n  if (!keyword) {\n    return html;\n  }\n  keyword = escape(keyword);\n  const wrap = document.createElement(\"div\");\n  wrap.innerHTML = escape(html);\n  return walkthroughNodeWithKeyword(wrap, keyword);\n};\n", "import { escape } from \"lodash\";\nimport { marked } from \"..\";\nimport Link from \"./Link\";\n\nexport const BOLD_REG = /\\*\\*(.+?)\\*\\*/;\n\nconst matcher = (rawStr: string) => {\n  const matchResult = rawStr.match(BOLD_REG);\n  return matchResult;\n};\n\nconst renderer = (rawStr: string): string => {\n  const matchResult = matcher(rawStr);\n  if (!matchResult) {\n    return rawStr;\n  }\n\n  const parsedContent = marked(escape(matchResult[1]), [], [Link]);\n  return `<strong>${parsedContent}</strong>`;\n};\n\nexport default {\n  name: \"bold\",\n  regex: BOLD_REG,\n  matcher,\n  renderer,\n};\n", "import { escape } from \"lodash\";\nimport { marked } from \"..\";\nimport Link from \"./Link\";\n\nexport const BOLD_EMPHASIS_REG = /\\*\\*\\*(.+?)\\*\\*\\*/;\n\nconst matcher = (rawStr: string) => {\n  const matchResult = rawStr.match(BOLD_EMPHASIS_REG);\n  return matchResult;\n};\n\nconst renderer = (rawStr: string): string => {\n  const matchResult = matcher(rawStr);\n  if (!matchResult) {\n    return rawStr;\n  }\n\n  const parsedContent = marked(escape(matchResult[1]), [], [Link]);\n  return `<strong><em>${parsedContent}</em></strong>`;\n};\n\nexport default {\n  name: \"bold emphasis\",\n  regex: BOLD_EMPHASIS_REG,\n  matcher,\n  renderer,\n};\n", "import { escape } from \"lodash\";\nimport { marked } from \"..\";\nimport Link from \"./Link\";\n\nexport const EMPHASIS_REG = /\\*(.+?)\\*/;\n\nconst matcher = (rawStr: string) => {\n  const matchResult = rawStr.match(EMPHASIS_REG);\n  return matchResult;\n};\n\nconst renderer = (rawStr: string): string => {\n  const matchResult = matcher(rawStr);\n  if (!matchResult) {\n    return rawStr;\n  }\n\n  const parsedContent = marked(escape(matchResult[1]), [], [Link]);\n  return `<em>${parsedContent}</em>`;\n};\n\nexport default {\n  name: \"emphasis\",\n  regex: EMPHASIS_REG,\n  matcher,\n  renderer,\n};\n", "import { escape } from \"lodash-es\";\nimport Emphasis from \"./Emphasis\";\nimport Bold from \"./Bold\";\nimport { marked } from \"..\";\nimport InlineCode from \"./InlineCode\";\nimport BoldEmphasis from \"./BoldEmphasis\";\n\nexport const LINK_REG = /\\[(.*?)\\]\\((.+?)\\)+/;\n\nconst matcher = (rawStr: string) => {\n  const matchResult = rawStr.match(LINK_REG);\n  return matchResult;\n};\n\nconst renderer = (rawStr: string): string => {\n  const matchResult = matcher(rawStr);\n  if (!matchResult) {\n    return rawStr;\n  }\n  const parsedContent = marked(escape(matchResult[1]), [], [InlineCode, BoldEmphasis, Emphasis, Bold]);\n  return `<a class='link' target='_blank' rel='noreferrer' href='${escape(matchResult[2])}'>${parsedContent}</a>`;\n};\n\nexport default {\n  name: \"link\",\n  regex: LINK_REG,\n  matcher,\n  renderer,\n};\n"], "filenames": ["web/src/components/SearchBar.tsx", "web/src/labs/highlighter/index.ts", "web/src/labs/marked/parser/Bold.ts", "web/src/labs/marked/parser/BoldEmphasis.ts", "web/src/labs/marked/parser/Emphasis.ts", "web/src/labs/marked/parser/Link.ts"], "buggy_code_start_loc": [41, 1, 0, 0, 0, 20], "buggy_code_end_loc": [42, 25, 18, 18, 18, 21], "fixing_code_start_loc": [41, 1, 1, 1, 1, 20], "fixing_code_end_loc": [42, 23, 19, 19, 19, 21], "type": "CWE-79", "message": "Cross-site Scripting (XSS) - Stored in GitHub repository usememos/memos prior to 0.9.0.", "other": {"cve": {"id": "CVE-2022-4695", "sourceIdentifier": "security@huntr.dev", "published": "2022-12-27T15:15:11.603", "lastModified": "2023-01-05T14:07:08.003", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Cross-site Scripting (XSS) - Stored in GitHub repository usememos/memos prior to 0.9.0."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "HIGH", "baseScore": 7.6, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 4.7}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:usememos:memos:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.9.0", "matchCriteriaId": "9E9BB4B3-BBB1-406D-96EE-69114B828CF0"}]}]}], "references": [{"url": "https://github.com/usememos/memos/commit/65cc19c12efa392f792f6bb154b4838547e0af5e", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/2559d548-b847-40fb-94d6-18c1ad58b789", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/usememos/memos/commit/65cc19c12efa392f792f6bb154b4838547e0af5e"}}